00:00:07 <carter> but aside from that, i swear i was mostly nice at hackphi
00:00:10 <carter> luke's cool
00:00:51 <yitz> one of these years i hope i'll make hackphi
00:00:56 <dmj> yitz: Unsurprising :) Funny I commute from north side too. LSD drive is nice.
00:01:01 <yitz> yes
00:01:07 <carter> lsd drive?
00:01:10 <carter> sounds dangerous :)
00:01:10 <liyang> (Luke's warm.)
00:01:14 <dmj> lake shore drive
00:01:18 <yitz> it was a surprisingly pleasant commute, even in traffic, even in winter
00:01:20 <carter> lsd, hehe
00:01:21 <carter> :)
00:01:25 <cinimod> I am using literate haskell and pandoc. Titles in pandoc start with e.g. ### but for some reason ghci is interpreting these even though they are not in \begin{code} .. \end{code} blocks. Is there some way of telling ghci not to do this or is it a bug in ghci?
00:02:14 <carter> cinimod run lhs2hs?
00:02:15 <carter> or something
00:02:47 <yitz> cinimod: did you enable cpp?
00:03:15 <cinimod> Nope I was just in my emacs buffer and hit C-c C-l
00:03:52 <yitz> dmj: i was at washtenaw and granville
00:04:25 <scshunt> The general rule for package versioning is that a maintenance release (third number) should not break any APIs, right?
00:04:38 <yitz> cinimod: was it the first line in the file? there's some hack in ghc to ignore shell bangs.
00:05:05 <dmj> yitz: ah ok edge water or roger park area? I'm at division and wells. Student housing sort of
00:05:09 <yitz> scshunt: it can add APIs but not break existing ones
00:05:25 <c_wraith> scshunt: err.  on hackage, the maintenance releases number is the 4th number.  And it means "don't change any API at all"
00:05:25 <scshunt> :(
00:05:27 <cinimod> yitz: no I have titles scattered throughout the document
00:05:30 <yitz> dmj: yeah ok. yeah rogers pk.
00:05:39 <scshunt> c_wraith: err indeed
00:06:16 <enthropy> cinimod: you could also use === titles ===, right?
00:06:24 <scshunt> c_wraith: so fourth is "no API", third is "no break", second is "small changes", first is "major changes, or maybe I just decided to release version 1"?
00:06:55 <yitz> ah so that's almost n. loop
00:07:13 <c_wraith> scshunt: the third digit (minor release number) allows adding functions and data types, but not instances.  First and second are any change more extensive than that, however you want to divide them up.
00:07:23 <yitz> how far from cabrini green?
00:07:25 <carter> there are packages which for good reasons break that convention
00:07:39 <carter> but unless you have a VERY VERY good reason, its better not to
00:07:52 <cinimod> enthropy: yes but I think that only works for h1 and h2 - I would also like h3
00:08:04 <scshunt> c_wraith: is this actually documented somewhere?
00:08:05 <carter> because then it makes it easier for client libs to build correctly
00:08:05 <yitz> carter: there are also package which for bad reasons break that convention
00:08:12 <carter> yitz: i don't care about those
00:08:18 <yitz> ok fair enough
00:08:20 <cinimod> enthropy: it's turned into quite a long blog post which needs that level of structure
00:08:23 <dmj> yitz: quite close. Area between division and north ave on sedgwick is a minefield
00:08:28 <carter> yitz the good example is llvm bindings
00:08:39 <carter> where llvm has a lot of changes between major versions
00:08:48 <carter> and its much better engineering to support the major versions erperately
00:08:50 <carter> *seperately
00:08:51 <yitz> dmj: got it. so you've got hard boundaries around there, too.
00:08:58 <carter> @hackage llvm-general
00:08:59 <lambdabot> http://hackage.haskell.org/package/llvm-general
00:09:13 <carter> supports both llvm 3.2 and 3.3 on hackage
00:09:24 <carter> and tracks llvm 3.4 HEAD on master
00:09:39 <carter> so the first two version numbers on hackage
00:09:42 <carter> tracks the llvm version
00:09:52 <yitz> carter: someone asked yesterday if llvm works on non-linux
00:09:56 <carter> yup
00:10:09 <yitz> ok nice
00:10:17 <carter> ralith has an idris backend that uses llvm general to back in llvm backend
00:10:26 <carter> and had tested it on windows mac and linxu
00:10:34 <dmj> yitz: absolutely.
00:11:03 <carter> apparently theres some wibbly bits if you want dynamic linking + llvm on arm
00:11:03 <Ralith> yitz: LLVM is primarily developed on OSX.
00:11:09 <Ralith> Apple is its largest investor
00:11:14 <yitz> dmj: otoh you're within walking distance of some really nice places
00:11:29 <carter> one of teh cooler things apple has done
00:12:00 <yitz> Ralith: ok. there's the haskell side too though, which for some things is best supported on linux. glad to hear that this is really multi-platform.
00:12:59 <dmj> yitz: yes, that strip on wells. chipotle. whole foods. not too far from beach
00:13:38 <Ralith> haskell side's just a C++ binding with some C(++) shims as far as portability's concerned
00:13:52 <carter> well tested shims mind you
00:13:58 <carter> well
00:14:01 <carter> well tested at this point
00:14:04 <carter> mostly thanks to Ralith
00:14:12 <dmj> carter: 485 issues, weren't jokin
00:15:00 <Ralith> bscarlet's done an excellent job of making everything nice and clean and maintainable, fortunately
00:15:10 <Ralith> (and portable)
00:15:34 <yitz> Ralith: you make it sound easy, but getting those kinds of binds to Just Work on all platforms isn't always so simple.
00:15:45 <carter> dmj huh?
00:15:49 <carter> cabal?
00:15:50 <carter> dmj: what are you referring to?
00:15:50 <carter> indeed, Ralith  is absolutely right
00:15:50 <carter> its reallly really nice
00:15:50 <carter> i'm glad someone else didd it
00:15:50 <carter> and nicer and sooner than i'd have ever gotten around to it
00:16:03 <dmj> carter: cabal on github
00:16:15 <carter> yitz yup
00:16:21 <carter> bscarlet is awesome
00:16:31 <carter> and Ralith  has gotten peopel to test it on all the platforms
00:16:39 <carter> well, except arm linux
00:16:44 <carter> but thats a tricky one
00:16:45 <Ralith> win32 actually doesn't work yet.
00:16:48 <carter> oh
00:16:53 <carter> wind64 does?
00:16:58 <carter> oh… we don't have that yet right?
00:16:59 <Ralith> I would expect it to
00:17:06 <Ralith> I don't have a build environment for that
00:17:09 <carter> doe ghc currently have win 64?
00:17:16 <yitz> carter: yes
00:17:18 <carter> ok
00:17:19 <dmj> yitz: what program were you in
00:17:25 <yitz> dmj: math
00:17:28 <Ralith> I strongly suspect the bug is a FFI 64bitness and/or calling convention mismatch
00:17:38 <carter> huh
00:17:39 <carter> well
00:17:50 <carter> was it an idriss issue
00:17:53 <carter> or llvm-general issue?
00:17:56 <Ralith> it's a llvm-general issue
00:18:10 <carter> i don't see an open ticket for that...
00:18:13 <Ralith> OSX32 used to have a very similar issue, which turned out to be a case of CULLong vs. Word64 for uint64_t
00:18:14 <carter> https://github.com/bscarlet/llvm-general/issues?page=1&state=open
00:18:27 <carter> feed the tracker
00:18:45 <Ralith> perhaps when I have more time
00:18:48 <carter> k
00:18:53 <carter> you do have a busy next 2 weeks right?
00:19:00 <Ralith> yep
00:19:00 <carter> fuck, icfp contest is coming
00:19:38 <carter> and no team
00:19:39 <carter> oh well
00:19:51 <carter> i'm probably not going to code on any weekend in the near future
00:21:47 <dmj> yitz: nice, come back to chicago, needs more haskell love. There was one startup in www.1871.com that was running yesod. Had a ghc contributor with them
00:22:04 <carter> which contributor?
00:22:18 <dmj> carter: who assigns issues here? or is it a free-for-all? Don't want to step on toes
00:22:26 <dmj> carter: let me see if I can pull it up
00:22:31 <carter> dmj what are you talking about?
00:22:43 <carter> cabal ? i was talking about llvm-general
00:22:56 <dmj> cabal yea
00:23:10 <carter> dmj why are you wondering about cabal issues?
00:23:14 <carter> they're on github
00:23:53 <yitz> dmj: was?
00:24:43 <carter> they likely did what most startups ever do
00:24:44 <carter> :)
00:24:45 <carter> DIE
00:25:11 <carter> spoke with a dude getting a neat real estate market data startup off the ground today
00:25:55 <carter> if that dude's startup doesn't succeed, i will ask him how he fucked it up, they have some legit stuff
00:26:07 <carter> tech + biz at the same time is hard word
00:26:09 <carter> *work
00:26:23 <carter> and a celebration every time a viable tech driven interesting business is born
00:26:27 <yitz> carter: there needs to exist a real estate market for that one to work. maybe one appear soon.
00:26:38 <carter> yitz they're doing something related to that
00:26:52 <carter> but on the banking side of real eastate
00:26:56 <carter> not the consumer side
00:27:01 <dmj> these guys: http://www.lassocountry.com/ took the github links off tho
00:27:22 <carter> apparently it takes 100-1000hrs to evaluate the value  of a property the way people currently do it
00:27:42 <carter> they ahve some demo software that lets the analyst do in a day
00:27:58 <carter> and theres HUGE orgs in finance that do this
00:28:23 <carter> i hate the word hustle, but the dude doing this has it, plus legit math background
00:29:21 <carter> anyways
00:29:23 <yitz> carter: sounds cool. hope they succeed.
00:29:23 <carter> i should crash
00:29:41 <hvr> dmj: jfyi, there's now also http://haskell.github.io/haskell-mode/manual/latest/#Indentation
00:29:41 <carter> yitz: hope they somehow get some haskell in  with their python
00:29:49 <carter> but i did like the dude
00:29:55 <carter> and it'd be a neat biz
00:30:14 <yitz> carter: i still maintain that the overall volume of real estate market activity will have an effect on their chances. and that's relatively low still.
00:30:20 <carter> well
00:30:29 <carter> good thing its not related to normal buy / sell activity
00:30:30 <carter> ish
00:30:33 <dmj> hvr: ahh intellesting
00:30:40 <carter> this is  at a different point in the flow
00:31:01 <carter> and allegedly 1+ large nyc banks are like "we want 100 seats when this is ready"
00:31:05 <yitz> carter: if no one is buying or selling then no one is interested in appraisal either
00:31:12 <carter> could be
00:31:14 <carter> not my biz
00:31:16 <carter> not my problem
00:31:20 <carter> :)
00:31:34 <yitz> well we hope they will succeed - and use haskell
00:31:41 <carter> well, tehy're pythoning for now
00:31:47 <carter> i'm haskelling my stuff
00:31:49 <carter> i should sleep
00:31:51 <carter> night all
00:32:05 <carter> hvr btw: excited about the infrastructure stuff!
00:32:50 <carter> dmj i'm deeply skeptical of b2c or social b2c things
00:32:52 <carter> as busineses :)
00:33:01 <carter> night all
00:33:06 <dmj> carter: as am I :)
00:33:18 <hvr> carter: /me too :)
00:34:02 <nerrz> is there a way to import all the modules in a directory like import Problems.* ?
00:38:48 <hvr> nerrz: not with standard Haskell; but maybe w/ the help of TemplateHaskell
00:39:09 <hvr> (but probably TH isn't allowed to splice in import declarations)
00:39:44 <nerrz> hvr: I will look into that, since I dont want to have to import all of my PE problems
00:40:10 <hvr> physical education?
00:41:12 <hvr> (first item on http://en.wikipedia.org/wiki/PE)
00:41:46 <Saizan> Project Euler
00:41:49 <nerrz> hvr: Project Euler (projecteuler..net)
00:41:59 <hvr> oh, right
00:42:01 <nerrz> just one .
00:42:40 <hvr> nerrz: you could also generate a re-exporting module via shell script
00:42:56 <hvr> nerrz: that just contains import declarations, and re-exports those modules
00:43:12 <nerrz> actually, that is a great idea
00:43:46 <hvr> if you import everything all modules as 'import ModuleFoo as X'
00:43:53 <hvr> with the same dummy 'X'
00:44:04 <hvr> you just need to re-export the single X alias
00:46:27 <nerrz> hvr: well, if the module just has imports, and then I import that module it should import everything that imports, right?
00:48:36 <Saizan> only if you reexport them
00:48:59 <nerrz> Saizan: how do you do that?
00:49:12 <Saizan> "module Foo (module X) where .."
00:49:17 <nerrz> just module M (x) where .....
00:49:24 <nerrz> oh, okay
00:52:01 <haasn> He need hlint with lens support
00:52:03 <haasn> We*
00:52:26 <haasn> that can detect optimizations, reductions of code or redundancies relating to it
00:57:49 <solrize> anyone seen tekmo?  i'm wondering if he's all over this new oleg paper
00:57:50 <solrize> http://www.cs.indiana.edu/~sabry/papers/exteff.pdf
01:16:01 <germerz> If we list all the perfect squares below 10 we get 1, 4 and 9. If we add them together we get 14. What is the sum of all the perfect squares below 5000?
01:16:30 <mr-> germerz: there's only one way to find out!
01:16:55 <germerz> 116795
01:17:17 <mr-> > sum $ takeWhile (<5000) [n^2  | n <- [1..] ]
01:17:18 <lambdabot>   116795
01:17:28 <mr-> right ;-)
01:17:43 <germerz> mr-: How is that done in ideone?
01:17:52 <germerz> Or in an actual program
01:18:06 <mr-> hmm? I showed you one
01:18:27 <germerz> mr-: Is that not eval?
01:18:37 <germerz> lambdabot
01:18:38 <Yaniel> do you know what eval is?
01:18:48 <germerz> not the function
01:18:54 <mr-> germerz: You mean: main = print $ sum $ takeWhile (<5000) [n^2  | n <- [1..] ]
01:18:54 <mr-> ?
01:18:56 <germerz> But it evaluates an expression
01:19:20 <mr-> you can also just run it in ghci
01:19:29 <germerz> Ah I see.
01:19:31 <haasn> > sum . takeWhile (<5000) $ map (^2) [1..] -- pointfree
01:19:33 <lambdabot>   116795
01:20:27 <mr-> haasn: should that be prefere?
01:20:29 <mr-> d
01:20:47 <haasn> I like it more
01:20:51 <haasn> but suit yourself
01:22:13 <mr-> There was a funny bug recently where changing from one to the other increased memory usage dramatically
01:22:20 <supki> > sumOf (takingWhile (< 5000) (folded . to (^2))) [1..]
01:22:22 <lambdabot>   116795
01:22:30 <mikeplus64> > sum [ n^2 | n <- [1..sqrt 5000-1] ]
01:22:32 <lambdabot>   116795.0
01:22:50 <haasn> mikeplus64: ack, double!
01:23:10 <mikeplus64> fear not the floating point (maybe)
01:23:49 <haasn> hmm
01:24:05 <haasn> oh, (&) binds tighter than ($)
01:24:22 <Cale> haasn: Most things do ;)
01:32:53 <germerz> Why would main = sum . takeWhile (<5000) $ map (^2) [1..] -- pointfree
01:32:56 <germerz> not work?
01:33:03 <haasn> incorrect type
01:33:11 <haasn> main must be of type :: IO a -- for some ‘a’
01:33:43 <haasn> you probably want to add a ‘print’
01:33:52 <haasn> ie print . sum . ...
01:39:53 <johnw> haasn: language-c produces enough information that you just need a backend
01:40:15 <haasn> johnw: yeah, I saw it listed in the deps of hcc
01:40:32 <johnw> it's fairly easy to work with to (c2hsc is based on it)
01:42:01 <shiona> Are there other project-sized haskell tutorials than "write yourself scheme"?
01:44:21 <quchen> I haven't heard of another one.
01:45:32 <kingugo> !give germerz enter
01:53:34 <johnw> i wonder why there isn't an equivalent of "unsigned int" in base Haskell
01:53:40 <johnw> Nat
01:54:13 <haasn> yeah :(
01:54:28 <haasn> I guess because Integer covers most use cases, and we aren't big on ‘restricted number types’ in general
01:54:31 <johnw> i mean, it seems like such a natural restriction you'd want to represent at the type levels
01:54:32 <Lethalman> johnw, Data.Word ?
01:54:41 <johnw> yeah, I guess there's that
01:54:48 <haasn> Lethalman: not unbounded
01:54:56 <johnw> I'd want Nat and Natural
01:54:57 <Lethalman> Word32?
01:55:13 <haasn> johnw: agree
01:55:25 <Lethalman> isn't nat unbounded? -.-'
01:55:33 <haasn> Nat as equivalent to Int in size; Natural as equivalent to Integer
01:55:59 <haasn> > 10^100 :: Integer
01:55:59 <Lethalman> haasn, Data.Word has bounded stuff
01:56:00 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
01:56:02 <haasn> > 10^100 :: Word
01:56:03 <lambdabot>   0
01:56:20 <haasn> Lethalman: but nothing unbounded, that being the point
01:56:31 <Lethalman> haasn, didn't understand when you said "not unbounded"
01:56:49 <Lethalman> better put a verb next time :)
01:58:39 <haasn> > 10^100 `rem` (succ . toInteger $ maxBound :: Word)
01:58:40 <lambdabot>   Couldn't match expected type `GHC.Types.Word'
01:58:41 <lambdabot>              with actual type...
01:58:48 <haasn> oh
01:58:52 <haasn> > 10^100 `rem` (succ . toInteger (maxBound :: Word))
01:58:53 <lambdabot>   Couldn't match expected type `a0 -> c0'
01:58:53 <lambdabot>              with actual type `GHC....
01:58:56 <haasn> ugh
01:59:05 <haasn> > 10^100 `rem` (1 + toInteger (maxBound :: Word))
01:59:09 <lambdabot>   mueval-core: Time limit exceeded
01:59:17 <haasn> oh well, it evaluates to 0 here :)
01:59:27 <haasn> that's an amusing coincidence
02:13:32 <haskellelephant> @pl (\k t -> chr $ a + flip mod 26 (ord k + ord t -2*a))
02:13:35 <lambdabot> (id chr .) . ((a +) .) . (flip mod 26 .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
02:13:36 <lambdabot> optimization suspended, use @pl-resume to continue.
02:13:45 <haskellelephant> @pl-resume
02:13:51 <lambdabot> (id chr .) . ((a +) .) . (flip mod 26 .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
02:13:51 <lambdabot> optimization suspended, use @pl-resume to continue.
02:15:59 <yopikh> @pl-resume
02:16:11 <lambdabot> (id chr .) . ((a +) .) . (flip mod 26 .) . flip flip (2 * a) . ((-) .) . (. ord) . (+) . ord
02:16:11 <lambdabot> optimization suspended, use @pl-resume to continue.
02:18:36 <sipa> @pl-resume
02:18:51 <lambdabot> Plugin `pl' failed with: <<timeout>>
02:18:52 <johnw> sometimes type inference feels like pure magic
02:19:02 <haskellelephant> It mostly is
02:19:56 <arnsholt> Not as magical as you might think
02:20:09 <arnsholt> It's mostly a question of unification
02:20:15 <johnw> haha
02:20:42 <arnsholt> Learning Prolog is useful for grokking unification =)
02:20:42 <sipa> any technology distinguishable from magic is insufficiently advanced
02:20:53 <johnw> arnsholt: haskell_20130728.log:[01:21:41] <johnw> sure thing.  it's a lot less magical than you might imagine too
02:21:00 <johnw> I said the exact same thing to somebody 3 days ago :)
02:21:10 <haskellelephant> I like better the explenation that it is proof checking in first order logic...
02:22:40 <haasn> > 'a' & enum +~ 3
02:22:41 <lambdabot>   Couldn't match type `GHC.Types.Int' with `GHC.Types.Char'
02:22:41 <lambdabot>  Expected type: C...
02:22:47 <haasn> > 'a' & from enum +~ 3
02:22:47 <arnsholt> Well, term unification is first order logic, essentially. Prolog is a Turing-complete subset of first-order logic =)
02:22:48 <lambdabot>   'd'
02:22:49 <quchen> Just because you can understand it doesn't mean it's not magic. Obligatory link: http://abstrusegoose.com/73
02:24:04 <quchen> I for one am amazed at how much the little monad laws do.
02:24:24 <quchen> That's as easy to understand as it is magical to me.
02:24:29 <johnw> i'm amazed at how little the category laws do!
02:24:34 <johnw> monoids are crazy things
02:24:44 <quchen> Monoids are crazy.
02:24:57 <quchen> That's the new quote.
02:25:09 <johnw> they're like: give me identity and a assoc binop, and I'll give you *a whole damn field of mathematics that spans every discipline and logic and programming too)
02:25:12 <quchen> Scratch the easy part, that's so 2012 :-)
02:25:31 <quchen> Monoids are a field of mathematics?
02:25:38 <johnw> monoidoids
02:25:43 <haasn> I'm a professional monoid theoretician
02:26:12 <mgsloan> I hear it's the easiest profession
02:26:24 <johnw> quchen: category theory is basically a monoid algebra of arrows
02:26:37 <quchen> johnw: Right, id and (.)
02:26:54 <quchen> Let M be the monoid of *everything*, then …
02:29:01 <chexxor_> New Haskell learner here. Quick question about functions and guards: http://lpaste.net/91363
02:29:22 <chexxor_> Why does the prof say "this works, but is much too complicated?"
02:29:33 <haasn> because there's some redundancy going on
02:29:44 <Yuu-chan> The result of boolean expression is already a Bool
02:29:50 <haasn> chexxor_: think about “if x then True else False”
02:30:05 <Yuu-chan> isEven n = n `mod` 2 == 0
02:30:45 <chexxor_> ok, so the code is fine, it's just a little redundant?
02:30:49 <haasn> yes
02:30:49 <johnw> yes
02:31:00 <haasn> “much too complicated” is a bit of an exaggeration :)
02:31:30 <Yuu-chan> @pl (\n -> n `mod` 2 == 0)
02:31:33 <lambdabot> (0 ==) . (`mod` 2)
02:31:33 <lambdabot> optimization suspended, use @pl-resume to continue.
02:31:38 <chexxor_> thanks! :-)
02:31:46 <ziman> @pl-resume
02:31:52 <lambdabot> (0 ==) . (`mod` 2)
02:31:52 <lambdabot> optimization suspended, use @pl-resume to continue.
02:32:02 <haasn> elliott: can we really get that message removed so people stop compulsively typing @pl-resume?
02:32:27 <Yuu-chan> But we want it optimized!
02:33:03 * ziman was curious about just how the above could be even more optimized :)
02:33:31 <haasn> it could be optimized even more by writing it ‘even’
02:33:31 <johnw> (0==).(`mod`2)
02:34:10 <haskellelephant> Does lambdabot do source code lookup?
02:34:10 <bennofs> I think you could use rem instead of mod there
02:34:19 <bennofs> @src (.)
02:34:19 <lambdabot> (f . g) x = f (g x)
02:34:19 <lambdabot> NB: In lambdabot,  (.) = fmap
02:34:21 <haasn> haskellelephant: no. but there's a @src command which has a small static database
02:34:21 <haskellelephant> In wich case we could look up even
02:34:24 <haskellelephant> @src even
02:34:24 <lambdabot> even n = n `rem` 2 == 0
02:34:26 <haasn> @src even
02:34:26 <lambdabot> even n = n `rem` 2 == 0
02:34:27 <haasn> oops
02:34:28 <mr-> and flip instead of ` ` of course!
02:34:47 <haasn> apparently `rem` is less expensive to compute than `mod`. Or something
02:34:55 <haasn> no check for the sign first
02:35:07 <Yuu-chan> Are quot and rem really faster than div and mod?
02:35:13 <Yuu-chan> Oh, I see
02:35:26 <bennofs> @src mod
02:35:27 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
02:35:29 <haskellelephant> @src rem
02:35:29 <lambdabot> Source not found. Abort, Retry, Panic?
02:35:34 <haskellelephant> Panic def
02:35:38 <haasn> @src Integral
02:35:38 <lambdabot> class  (Real a, Enum a) => Integral a  where
02:35:38 <lambdabot>     quot, rem, div, mod :: a -> a -> a
02:35:38 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
02:35:38 <lambdabot>     toInteger           :: a -> Integer
02:35:50 <bennofs> @src mod Int
02:35:50 <lambdabot> Source not found. I feel much better now.
02:35:55 <haasn> bennofs: it's primitive
02:36:17 <haasn> eventually gets down to some x86 opcode or w/e
02:36:20 <haskellelephant> right, its part of Integral, we would have to lookup Int...
02:36:31 <haskellelephant> @src Int
02:36:32 <lambdabot> data Int = I# Int#
02:37:04 <haskellelephant> primitive ofc, doesn't show the instance declarations...
02:37:11 <haskellelephant> Probably primitive anyways...
02:43:00 <nominolo> joelteon: the scion-binary package should be inside the scionide repo (on bitbucket)
02:43:30 <nominolo> joelteon: in the bundle directory
02:44:05 <ocharles> mm_freak: I think I'm getting the hang of this! I can now move a square around an SDL window, with acceleration and friction
02:44:10 <ocharles> I feel like a GOD
02:44:34 <ocharles> next up is adding bounds checking so I can't move it out of the window's bounds
02:45:20 <haskellelephant> ocharles: Nice work!
02:45:46 <haasn> ocharles: FRP?
02:46:29 <ocharles> indeed
02:46:46 <hpaste> ocharles pasted “Netwire & SDL” at http://lpaste.net/91364
02:46:49 <ocharles> for those curious
02:46:50 <haasn> netwire then I take -- ah :)
02:47:19 <haasn> needs way more lenses
02:47:30 <ocharles> I feel like I'm just learning how to program again. which is actually kinda nice, reminds me of how I got into programming trying to make games in BASIC :)
02:47:34 <haasn> the very first function already could probably be greatly reduced
02:47:37 <ocharles> haasn: where do you think lenses would help?
02:47:45 <ocharles> haasn: keyDown?
02:47:48 <haasn> yeah
02:47:53 * ocharles has a think
02:49:17 <haasn> hmm
02:49:39 <haasn> I'll have to think about this as well
02:50:20 <haskellelephant> haasn: Seems like a good idea to encapsulate your go loop into a State Monad...
02:50:31 <ocharles> haskellelephant: I think you meant that towards me
02:50:35 <haskellelephant> yea
02:50:38 <haskellelephant> Sorry about that
02:52:02 <haskellelephant> ocharles: Seems like a good idea to make screen, keysdown, s and w part of the state...
02:52:30 <haasn> haskellelephant: actually, I have no idea how to use lenses there
02:52:48 <haskellelephant> :D
02:53:37 <ocharles> haasn: keyDown k = unless (Set.null . Set.filter ((== k) . SDL.symKey)) -- is one simplification
02:54:21 <ocharles> though I might expand that 'unless' into 'when (not . Set.null ...)' for clarity
02:54:22 <Ghoul_> So I changed documentation = true in my cabal config
02:54:27 <Ghoul_> I now want to force reinstall every package
02:54:36 <Ghoul_> (I'm aware its dangerous) -- how ?
02:54:57 <Saizan> cabal install --reinstall world, i guess
02:55:03 <mm_freak> ocharles: great…  i hope to get around to finishing netwire 5 soon =)
02:55:20 <mm_freak> haasn: i don't know what kind of lenses to use in netwire
02:55:26 <donri> mm_freak: what's the state of formwire, new fastirc, pipeswire? :)
02:55:29 <ocharles> mm_freak: ooo, what kind of shiney can we expect?
02:55:35 <Saizan> or maybe just rm -fr ~/.ghc and cabal install what you need
02:55:48 <ocharles> mm_freak: oh also I heard you mention netwire-vty - can you throw up whatever you have online for that, even if it doesn't even build?
02:56:19 <Ghoul_> I might do a wipe, yeah
02:56:22 <Ghoul_> thats not a bad idea
02:56:45 <mm_freak> donri: i'm not working on fastirc right now…  pipeswire is basically netwire 5, and formwire will depend on it
02:57:04 <donri> cool!
02:57:29 <haasn> hmm
02:57:47 <mm_freak> in fact pipes and netwire 5 may actually work together…  it will be designed such that there is a functor from wires to proxies
02:57:55 <haasn> nullOf (folded . to SDL.symKey . filtered (==k))
02:58:04 <haasn> not exactly a huge improvement :)
02:58:06 <mm_freak> tekmo likes the idea of combining wires with pipes and pipes-concurrency in particular
02:58:45 <mm_freak> ocharles: nothing much currently…  netwire is fine for real-time stuff, but its semantics don't support GUIs very well
02:58:45 <ocharles> haasn: I was exploring something with 'contains'
02:58:52 <mm_freak> that's the main motivation for a new major version
02:59:28 <mm_freak> also i want to "fix" events…  there is currently no notion of simultanity and discrete and continuous events should be separate
03:00:17 <ocharles> sounds interesting
03:00:36 <mm_freak> considering x <|> y, originally i had thought that it makes a lot of sense to ignore y, when x produces…  this turned out to be a mistake
03:00:48 <mm_freak> the new netwire will follow both branches, even if the first produces
03:00:55 <ocharles> and then combine with a monoid?
03:01:00 <mm_freak> exactly
03:01:09 <ocharles> that does make sense, yea
03:01:19 <ocharles> I sometimes think 'Alternative' was a bad name for that type class
03:01:34 <mm_freak> well, it should probably be called Monoid =)
03:01:37 <ocharles> :)
03:01:51 <Taneb> For Parsers, Alternative makes sense
03:02:03 <Taneb> (and I think parsers were the original use case?)
03:02:06 <donri> problem is Alternative makes sense for much more than Parsers :p
03:02:14 <mm_freak> Taneb: and Monoid makes sense for everything using this pattern =)
03:02:17 <johnw> Alternative makes sense for STM too
03:02:31 <mm_freak> it's about the most general term you can come up with
03:02:41 <ocharles> ever for parsers if you consider the output to be First then a monoid fits
03:02:47 <ocharles> even*
03:03:17 <ocharles> but if you change that monoid you can consider all the parsing possibilities, in case something is ambiguous
03:03:24 <ocharles> and I don't think you can do with parsecs Alternative
03:03:28 <ocharles> though maybe I'm wrong
03:03:54 <quchen> What always confused me about Alternative is that there's no law connecting it to Applicative, e.g. empty <*> _ = empty.
03:03:58 <twomashi2> is there any json package that allows you to do lookups on a json object using a path type notation? ie 'key.key.key'
03:04:05 <Taneb> But what's in a name? A class by any other name would be as useful
03:04:06 <johnw> lens-aeson
03:04:13 <johnw> twomashi2: ^^
03:04:22 <ocharles> johnw: lens-aeson doesn't give you path notation, but you can build path notation out of it
03:04:28 <johnw> right
03:04:38 <johnw> i haven't used lens-aeson, but aeson-lens let you do: key x.key y.key z
03:04:50 <mm_freak> i always view Monoid, Alternative, ArrowZero+ArrowPlus and MonadPlus to be the same thing…  it's really just haskell's type system that isn't powerful enough to reflect that in any useful way
03:04:57 <ocharles> twomashi2: I wrote a String -> Lens thing for aeson-lens at: https://github.com/ocharles/digestive-functors-aeson/blob/master/src/Text/Digestive/Aeson.hs#L78
03:05:07 <haasn> I just.. whoa
03:05:16 <chexxor_> omg, I think I just wrote my first Haskell code. I'm quite excited. :-)
03:05:25 <johnw> chexxor_: congrats!
03:05:25 <ocharles> chexxor_: congratulations!
03:05:26 <Taneb> chexxor_, good for you!
03:05:27 <johnw> welcome to the madness
03:05:30 <donri> does it type check
03:05:41 <Ghoul_> is there a way to make my cabal generate the colored "Source" files you see like on hackage?
03:05:46 <quchen> donri: If it doesn't typecheck it's text, not Haskell :P
03:05:48 <Ghoul_> and the respective source links?
03:05:51 <haskellelephant> chexxtor_: :D!
03:05:59 <mm_freak> chexxor_: great stuff, now compile it with -W and let hlint bombard you with style warnings =)
03:06:01 <haasn> ocharles: it would be cool if we could, like, serialize/deserialize Tapes (from lens' Zippers), then you could build a zipper using lens-aeson's traversals and pass those around as paths
03:06:05 <donri> Ghoul_: --haddock-hyperlink-source IIRC
03:06:08 <hvr> johnw: lens-aeson vs aeson-lens sounds like People's Front of Judea vs Judean People's Front ;)
03:06:10 <chexxor_> it's just the isEven function in ghci, but setting up infrastructure takes time :)
03:06:26 <haasn> donri: wouldn't be Haskell code otherwise ;)
03:06:26 <Ghoul_> thanks, now I have to figure out the config option for that :)
03:06:38 <donri> Ghoul_: there isn't one :(
03:06:40 <haskellelephant> chexxor_: yea it does! Did you use haskell-platform?
03:06:44 <mm_freak> chexxor_: depends on your operating system…  in most linux distributions you can get up and running pretty quickly
03:06:47 <Ghoul_> baww really
03:06:48 <Ghoul_> lame.
03:06:52 <chexxor_> mm_freak: GHC has a built-in style checker? Like, not syntax, but style?
03:06:59 <twomashi2> ocharles: cool thanks
03:07:03 <mm_freak> chexxor_: no, hlint is a separate program
03:07:26 <mm_freak> chexxor_: -W gives you some warnings like unmatched cases
03:07:31 <mm_freak> it's a GHC flag
03:07:38 <chexxor_> haskellelephant: yeah, haskell-platform on Win8 - super simple. But I was setting up a git repo and pushing around notes and code.
03:07:39 <Taneb> hvr, aeson-lens doesn't obey the lens laws
03:07:43 <mm_freak> if you really want the compiler to annoy you, you can also compile with -Wall
03:07:47 <Ghoul_> is there some hack I can do in the config file to always pass --haddock-hyperlink-source ?
03:07:51 <mm_freak> personally i prefer -W
03:08:00 <haskellelephant> chexxor_: You can install hlint with cabal-install (cabal install hlint on linux, you will find the executable in ~/.cabal/bin/)
03:08:01 <haasn> mm_freak: what does -W default?
03:08:07 <Ghoul_> actually, maybe thats a bad idea.
03:08:11 <mm_freak> haasn: error: no parse
03:08:14 <donri> Ghoul_: you'd have to write a shell function i imagine
03:08:22 <merijn> mm_freak: -Wall -fno-warn-unused-do-bind :p
03:08:31 <donri> Ghoul_: or a makefile for your project
03:08:36 <Taneb> hvr, and lens-aeson uses some fancier lens stuff
03:08:42 <quchen> merijn: -fno-warn-default-stuff?
03:08:48 <mm_freak> merijn: i haven't seen -Wall emit any useful warning that isn't emitted by -W =)
03:08:49 <haasn> mm_freak: well, I mean, what does -W leave out compared to -Wall
03:09:04 <haasn> merijn: when I use -Wall in serious projects my -fno-warn-* lines tend to explode
03:09:06 <Ghoul_> I require entire haskell documentation because I find it naively impossible to code haskell on the train due to the lack of internet
03:09:07 <merijn> mm_freak: Does -W include -fwarn-wrong-do-bind?
03:09:13 <mm_freak> haasn: do x <- blah; return ()
03:09:14 <Ghoul_> but I can live without source links /I guess/
03:09:19 <quchen> GHC Warnings: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-sanity.html
03:09:30 <haasn> quchen: ah, thanks
03:09:33 <quchen> "-W provides the standard warnings plus -fwarn-incomplete-patterns, -fwarn-dodgy-exports, -fwarn-dodgy-imports, -fwarn-unused-matches, -fwarn-unused-imports, and -fwarn-unused-binds."
03:09:35 <haasn> I was having trouble finding the list in GHC's man page
03:09:44 <donri> -Wall -Werror mwahahah
03:09:52 <Ghoul_> lol
03:10:08 <hvr> Taneb: well, the most important difference is that aeson-lens is by ekmett =)
03:10:17 <mm_freak> haasn: i don't remember all the stuff it complains about, but most of it just gets in the way when writing code
03:10:22 <Taneb> hvr, :D
03:10:22 <quchen> donri: Critical error: '1' defaulting to Integer
03:10:23 <hvr> Taneb: err,, lens-aeson I mean
03:10:23 <quchen> :-D
03:10:47 <donri> Ghoul_: alias ci='cabal install --haddock-hyperlink-source' ? :)
03:10:58 <Ghoul_> That's the thing -- windows XD
03:11:00 <quchen> Funny how -Wall doesn't enable all warnings.
03:11:13 <haasn> -Wreally-all
03:11:13 <mm_freak> do you remember that GHC bug that was once in HEAD that deleted the offending source file when there was a type error?  i think that should become a warning flag
03:11:16 <mm_freak> -Wdelete-source-files-on-type-error
03:11:16 <Ghoul_> I'll just live with it :)
03:11:19 <donri> -Wall-the-things
03:11:38 * haasn runs with -w -fdefer-type-errors
03:11:58 <mm_freak> https://twitter.com/bos31337/status/116372971509121025
03:11:59 <Ghoul_> -Wdestroy-evil-types
03:12:05 <mm_freak> http://www.reddit.com/r/haskell/comments/127emo/brian_osullivans_favorite_bug_in_ghc/
03:12:08 <twomashi2> ocharles: is it the pathToLens function that I want? how do I use it?
03:12:08 * quchen runs with > /dev/null
03:12:35 <twomashi2> ocharles: does it require additional data declerations?
03:12:52 <donri> mm_freak: the bug was fixed by compiling that version of ghc with itself
03:13:10 <quchen> donri: Followed by a git pull?
03:13:28 <mm_freak> lol
03:13:34 <ocharles> twomashi2: yes you want pathToLens, no it doesn't require any data declarations, and there is example usage of it further up in that file
03:13:40 <ocharles> twomashi2: I suggest loading it into ghci and having a play
03:13:45 <mm_freak> but my personal favorite bug isn't related to haskell (fortunately)
03:13:48 <mm_freak> https://github.com/saltstack/salt/commit/5dd304276ba5745ec21fc1e6686a0b28da29e6fc
03:13:52 <mm_freak> this patch made my day
03:14:15 <quchen> mm_freak: Is that an exponent of 1?
03:14:34 <haasn> mm_freak: the GHC overmind does not approve of faulty code. it must be purged
03:15:03 <nerrz> is there a way to make a function that takes an int and calls a function like prob 1 = problem_1, prob 2 = problem_2... without making a list of guards or patterns? maybe template haskell?
03:15:15 <donri> mm_freak: how about that one where there was a space after the first slash in an rm -rf /... line? :p
03:16:59 <mm_freak> quchen: yeah
03:17:04 <donri> i'm probably thinking of this https://github.com/MrMEEE/bumblebee-Old-and-abbandoned/commit/a047be85247755cdbe0acce6f1dafc8beb84f2ac
03:17:23 <mm_freak> he realized that while e = 1 is really fast it has a small security problem
03:18:07 <mm_freak> donri: i actually have a file called "-rf *" in my home directory everywhere
03:18:22 <mm_freak> to create it type:  touch -- "-rf *"
03:18:27 <donri> heh
03:19:03 <donri> i have rm aliased to trash-put but that doesn't help scripts i guess
03:19:13 <mm_freak> i should probably include that file in my source repositories as well to confuse people =)
03:19:45 <mm_freak> but cabal doesn't allow it
03:19:59 <mm_freak> extra-source-files: "-rf *"  -- error
03:20:13 <donri> incidentally your hack wouldn't work in my shell anyway ;)
03:20:26 <mm_freak> it "works" in no shell
03:20:27 <ocharles> haasn: keyDown k = when (anyOf (folded.to SDL.symKey) (== k))
03:20:28 <dcoutts> mm_freak: that's surprising, that should work to include a file called "-rf *"
03:20:41 <ocharles> haasn: that's a lensy version
03:20:45 <mm_freak> dcoutts: last time i tried it complained about my abuse of the wildcard
03:20:48 <haasn> ocharles: not bad
03:21:01 <donri> mm_freak: or maybe i misunderstood the point
03:21:09 <dcoutts> mm_freak: ooh, perhaps we do support wildcards there, I'd forgotten
03:21:15 <ocharles> haasn: it's certainly better than what I had before - feels much more haskelly
03:21:20 <haasn> yeah
03:21:31 <mm_freak> dcoutts: we do, but not at that point
03:21:41 <mm_freak> allowed: *.txt, disallowed: blah.*
03:21:50 <dcoutts> right
03:22:07 <mm_freak> donri: no point, it's just a joke =)
03:22:56 <donri> mm_freak: yes i misunderstood. i thought the point was that 'rm -rf *' would now delete those files instead. but that's the inverse of how wildcards work in most shells now that i think about it
03:23:23 <mm_freak> donri: zsh actually warns you about doing that
03:23:31 <haasn> what kind of IRC libraries are there in Haskell?
03:23:41 <donri> haasn: the kind that connect to IRC
03:23:45 <donri> next question!
03:23:45 <mm_freak> haasn: quite a bunch actually, but none of them are satisfying
03:24:06 <merijn> mm_freak: :(
03:24:14 <haasn> mm_freak: that's what I feared :(
03:24:16 <merijn> mm_freak: I looked at your saltstack link, now I'm depressed
03:24:21 <mm_freak> haasn: including my own unsatisfying library fastirc =)
03:24:40 <haasn> mm_freak: I'm looking for something new and edgy that incorporates awesome buzz things like lenses or FRP or other really cool abstractions
03:24:45 <mm_freak> the repository for the next version is lying around on github, but i don't get around to working on it
03:24:48 <haasn> trying to make my code feel functional and declarative
03:25:13 <ocharles> I wanted to write an IRC client that is a bit like uzbl for web browsing. You have a server, and you spawn clients that attach to a specific channel
03:25:13 <haasn> oh, maybe I'll base it off machines
03:25:13 <mm_freak> haasn: well, if i ever find time to finish fastirc, i can start with netwire-irc =)
03:25:22 <ocharles> so you can just use your WM/terminal multiplexer to lay stuff out
03:25:31 <haasn> mm_freak: if only I could imagine how netwire-irc might actually work :P
03:25:32 <Ghoul_> gah, im missing documentation for global packages
03:25:42 <Ghoul_> can I instal local documentation for global packages somehow?
03:25:55 <mm_freak> haasn: if you want a fast IRC protocol library you can make something from the current fastirc draft:  https://github.com/ertes/fastirc
03:26:04 <haasn> mm_freak: it seems that IRC frameworks tend to be request -> response oriented; but sometimes one may want a realtime component (eg. a countdown or interactive game)
03:26:23 <mm_freak> haasn: yeah, that's exactly the point of netwire-irc
03:26:36 <mm_freak> a component system with real-time components, separate from each other
03:27:01 <mm_freak> but don't wait for it, if you want to get going =)
03:27:24 * haasn waits for it
03:27:31 <haasn> no pressure or anything
03:27:35 <haasn> but I really want this :)
03:28:46 <mm_freak> and i'm happy to report that i'm finally getting used to lenses =)
03:28:52 <haasn> mm_freak: that is some ugly nesting in ‘parseMessage’ :(
03:29:12 <haasn> mm_freak: I have no idea how it would even begin to work, but if you manage to fuse netwire with lenses, my mind would be blown
03:30:02 <Ghoul_> is it safe to delete all the globally installed packages like base?
03:30:02 <mm_freak> haasn: well, parseMessage is faaaaast
03:30:15 <mm_freak> haasn: i'm pretty much emulating a lightweight attoparsec there
03:30:47 <mm_freak> haasn: it used to be attoparsec itself before that, but dealing with bytestrings directly turned out to be an order of magnitude faster
03:31:17 <haasn> interesting
03:31:48 <gavri> is there a way to get a list of running processes in haskell?
03:31:58 <mm_freak> don't get me wrong, attoparsec is just as fast for most stuff, but not this stuff =)
03:32:08 <haasn> mm_freak: I'm hoping to write a little toy bot that has time-based or scheduled interactive sessions, and an internal storage system (based on acid-state or something cool like that) for keeping track of statistics
03:33:14 <mm_freak> gavri: if you manage to get a bunch of PIDs (e.g. by reading /proc), you can use System.Posix.*
03:33:24 <haasn> an example could be a guessing game, where the bot dispenses another hint every X seconds until somebody gets the answer right; after which he scores a point and the session is ended
03:33:32 <gavri> mm_freak: thanks. will check that out
03:33:45 <mm_freak> haasn: you may be interested in my 'continue' library =)
03:33:50 <haasn> (idea totally not shamelessly stolen fr--  provided by alexander__b)
03:34:11 <mm_freak> haasn: https://github.com/ertes/continue
03:36:56 <mm_freak> haasn: 'continue' is a good way to describe imperative sessions for stateless protocols like IRC chats
03:37:16 <mm_freak> even though the chat itself is disconnected you write it like an interactive IO session
03:37:54 <mm_freak> the original motivation was HTTP, because presenting form data and getting the user's submission would look like putStrLn and getLine
03:38:01 <ocharles> Hmm, I don't get this 'w' parameter to integralLim_
03:38:12 <mm_freak> ocharles: read 'w' as 'world'
03:38:13 <ocharles> I've ended up with: boundedTo 0 0 640 480 .  first frictionVelocity .  first (first acceleration) .  arr (\k -> ((k, ()), ()))
03:38:21 <ocharles> but I don't care about the world for my limit
03:38:23 <haasn> mm_freak: how does Alt and Plus differ from Alternative/MonadPlus?
03:38:29 <ocharles> maybe I should encode the bounds in the world
03:38:38 <Ghoul_> ugh, thats annoying.
03:38:40 <mm_freak> it's some arbitrary environment information you can pass to the function
03:38:45 <Ghoul_> Was the cabal documentation feature actually tested on windows?
03:38:47 <ocharles> i got that much
03:38:51 <mm_freak> haasn: no dependence on Applicative
03:38:55 <ocharles> but the composition seems to get worse the more integralLims_ i have
03:38:58 <mm_freak> or Monad respectively
03:39:05 <ocharles> (once for frictionVelocity, once for acceleration)
03:39:13 <mm_freak> haasn: with the Applicative constraint Map is not an Alternative, but it is a Plus
03:39:26 <haasn> mm_freak: ah, okay
03:39:38 <dcoutts> Ghoul_: you mean generating haddocks? it certainly has worked, I'm not aware of it being broken
03:39:45 <Ghoul_> Cabal generates links that look like this "C:/User/foo/bar" but thats not understood by firefox because it expects all the links to have a file:// at the start, otherwise it sees the protocol as C:/
03:39:48 <merijn> mm_freak: What would the advantage of continue be over, for example, just implementing it as a forkIO thread doing dispatch?
03:39:56 <Ghoul_> so you cant click any of the links!
03:40:18 <Ghoul_> I assume this works fine on linux because they don't have silly colons after their drive names
03:40:29 <mm_freak> merijn: i don't think they are very related
03:40:35 <dcoutts> Ghoul_: ah, interesting, something has changed then, file a ticket with the details
03:40:50 <mm_freak> ContinueT : forkIO = FreeT : forkIO
03:41:10 <dcoutts> Ghoul_: include the output of ghc-pkg describe for the example
03:41:16 <mm_freak> a good alternative name for FreeT is Coroutine (see the monad-coroutine package) =)
03:41:23 <mm_freak> they are the same thing
03:41:47 <merijn> mm_freak: Well, that'd be my first approach to having IRC session like things, just do it as IO in a thread. So I was just wondering what continue does that makes it better for IRC interactions than plain IO?
03:42:09 <mm_freak> merijn: let me give you a ContinueT example:  an interactive calculator
03:42:18 <mm_freak> like pari/gp
03:42:57 <mm_freak> you write commands like:  "x = 3; compute_some_stuff(x); y = 5; other_stuff(x, y); … some long session …"
03:43:23 <mm_freak> then after this long session it occurs to you that x = 4 may be what you actually want
03:43:33 <mm_freak> with ContinueT you can replay the whole session with x = 4
03:44:09 <mm_freak> interactive sessions over a stateless protocol are just one example
03:44:34 <haasn> mm_freak: and how would that work?
03:44:49 <mm_freak> let me dig out my ages old example
03:45:35 <mm_freak> http://lpaste.net/79601 ⇐ this was the motivating example for ContinueT…  App is a special case
03:45:47 <mm_freak> look at the annotation at the bottom
03:46:14 <mm_freak> look at the main function, too
03:46:21 <mm_freak> the rest is pretty much internal
03:47:33 <mm_freak> ContinueT is highly related to Cofree
03:47:59 <mm_freak> in fact ContinueT has the same relationship to Cofree as Coroutine has to Free, except that ContinueT is actually a monad transformer instead of a comonad transformer
03:48:01 <haasn> I'm sure ContinueT is also highly related to coffee
03:48:45 <mm_freak> oh yeah, i needed quite some coffee to counter the headache =)
03:49:02 <mm_freak> and then Coroutine is related to Ffee
03:49:26 <ocharles> gameWire = boundedToWorld . (frictionVelocity &&& arr snd) .  first acceleration
03:49:30 <ocharles> that's a little better
03:49:35 <ocharles> I think it might be time to learn about arrow notation
03:50:12 <mm_freak> ocharles: and applicative style =)
03:50:48 <ocharles> hmm, I should be better with applicative style
03:51:29 <Ghoul_> dcoutts: is this okay? https://github.com/haskell/cabal/issues/1406
03:51:41 * dcoutts looks
03:52:01 <mm_freak> ocharles: boundedToWorld . first (frictionVelocity . acceleration)
03:52:41 <mm_freak> oh, no
03:52:42 <ocharles> doesn't type check
03:52:58 <mm_freak> my bad =)
03:53:02 <ocharles> It seems to be because each of frictionVelocity and acceleration don't carry on threading the world
03:54:40 <dcoutts> Ghoul_: could you include the ghc-pkg describe parsec, since that's the one that's the target of the link
03:54:49 <Ghoul_> ok
03:55:12 <dcoutts> Ghoul_: thanks, and include output of cabal --version
03:55:18 <ocharles> Anyway, on to the next challenge - getting the velocity to flip when my cube goes out of bounds. but first, breakfast
03:56:16 <Ghoul_> dcoutts: done
03:58:49 <mm_freak> ocharles: when your compositions get as large as this, i recommend using 'where'
03:59:03 <mm_freak> c1 . c2 . c3 where c1 = …; c2 = …; c3 = …
03:59:12 <mm_freak> of course with more meaningful names =)
03:59:35 <hpc> and when you start using where, consider moving things from out of 'where' to the top-level
04:00:20 <Ghoul_> > foldl (.) id [(+1), (+2), (+3)] $ 5
04:00:21 <lambdabot>   11
04:00:23 <Ghoul_> ha!
04:00:43 <Ghoul_> foldl (.) id [c1, c2, c3] $ b -- hehhee
04:01:22 <Yuu-chan> @src foldl1
04:01:22 <lambdabot> foldl1 f (x:xs) = foldl f x xs
04:01:22 <lambdabot> foldl1 _ []     = undefined
04:02:17 <Ghoul_> > foldl1 (.) (map (+) [1..5]) 1
04:02:18 <lambdabot>   16
04:02:22 <Ghoul_> that works too I guess.
04:10:57 <simion314> hi all, I am a beginer, i am confused of the result of this expresion "[10,9..1]"  what is 9 here? it should be the step right?
04:11:13 <danr> the step is the delta between 10 and 9
04:11:26 <Yaniel> > [10,9..1]
04:11:27 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
04:11:28 <danr> i.e (-1)
04:11:50 <Yaniel> > [10..1]
04:11:51 <lambdabot>   []
04:12:01 <Yaniel> because the default step is 1
04:12:05 <Lethalman> > [100,90,..,0]
04:12:06 <lambdabot>   <hint>:1:9: parse error on input `..'
04:12:14 <Lethalman> > [100,90..0]
04:12:15 <lambdabot>   [100,90,80,70,60,50,40,30,20,10,0]
04:12:26 <danr> relevant ticket: http://ghc.haskell.org/trac/ghc/ticket/7881
04:13:21 <simion314> thx,
04:18:50 * hackagebot hackport 0.3.3 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.3.3 (SergeiTrofimovich)
04:33:41 <Svedrin> when trying to import Locale, I get "Could not find module `Locale'": http://pastebin.com/mJ4wXL51 why is that? LANG is set to de_DE.UTF-8
04:33:46 <mauke> The paste mJ4wXL51 has been copied to http://lpaste.net/91366
04:34:57 <byorgey> Svedrin: Locale is an old, deprecated module name
04:35:04 <byorgey> Svedrin: you probably want something like System.Locale
04:36:03 <donri> from the old-locale package. what's the "new locale" though? System.IO?
04:36:19 <mm_freak> haskell people might love this talk: http://vimeo.com/71278954
04:36:24 <haskellelephant> I keep using this pattern for writing input files to theorem solvers. Basically variables have several subscripts eg. b_ij and c_ik. I often resort to using zipWithM_ to write stuff like b_ij + c_ik to match up subscripts of lists. Any thoughts on better ways of doing it?
04:36:25 <Svedrin> byorgey, that seems to work, thanks :)
04:36:45 <byorgey> donri: hmm, I forget
04:38:04 <donri> mm_freak: but he dissed modal editors in that other talk :(
04:38:18 <donri> argument to the person! this new talk must be bad!
04:38:24 <haasn> mm_freak: wait a minute, I was confused by this for ages until I realized if you type ‘x 6’ after all that it again asks you for y
04:38:33 <haasn> and just like that, the magic was gone :P
04:39:58 <haasn> I was confused for ages ‘how does entering y possibly update all of the other continuations to be in some magic parallel universe where I had picked a different y’
04:41:14 <ocharles> Hmmm, ArrowLoop you confusing little beast
04:41:32 <mm_freak> haasn: it doesn't have to…  ContinueT allows you to to implement a "use last value" logic
04:41:44 <donri> hm isn't arrowloop the monadfix of arrow or do i misremember
04:41:49 <ocharles> donri: something like that
04:41:57 <mm_freak> it's exactly that
04:42:26 <mm_freak> if the arrow has an ArrowApply, then MonadFix and ArrowLoop have a one-to-one correspondence
04:42:30 <ocharles> I have 'boundedPosition :: Wire e m (V2, Bounds) (V2, Collisions)' and 'frictionVelocity :: Wire e m (V2, Collisions) V2' and I was hoping I could use a feedback loop to feed collisions into velocity and get a final V2 out of it
04:42:40 <ocharles> but the types don't work for ArrowLoop, so I think i may be on the wrong track
04:42:57 <mm_freak> ocharles: for ArrowLoop i really recommend using arrow notation
04:43:04 <mm_freak> using loop directly is extremely confusing
04:43:08 <ocharles> ah, ok
04:43:14 <mm_freak> for simple cases there is a predefined combinator fixW
04:43:28 <mm_freak> it's a specialized loop
04:43:29 <ocharles> yea, I've seen that one too but I also haven't figured out how to get the type that wants
04:43:42 <ocharles> that says it ignores its input, but I don't think I want to do that
04:43:57 <ocharles> The final wire should take acceleration as input, and give me a position as output
04:44:09 <ocharles> that was my plan, anyway
04:44:27 <mm_freak> yeah, fixW works only for wires that don't expect any other input than their own feedback
04:44:31 <ocharles> right
04:44:50 <mm_freak> :t loop
04:44:51 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
04:44:58 <mm_freak> consider a wire w1
04:45:13 <mm_freak> this wire produces a tuple as output and takes a tuple as input
04:45:26 <mm_freak> whatever it produces as the snd value is fed back to it in snd
04:45:36 <mm_freak> that's the basic idea
04:45:50 <ocharles> yea, that bit I got
04:46:02 <ocharles> that's why I wanted to feed collision information "back into" the velocity wire
04:46:04 <haasn> mm_freak: by sticking another monad on top of it to provide the environment?
04:46:24 <mm_freak> haasn: no, by coding that logic into addCont
04:46:51 <mm_freak> rather using addCont, not "into" addCont per se
04:54:45 <haasn> mm_freak: anyway, I can begin to appreciate the use of this for providing interactive sessions
04:54:57 <haasn> by updating the continuations as commands get added or removed
04:55:17 <haasn> ‘commands’ here including inquiries for user response
04:57:37 <haasn> either way, I don't think it would be useful in this particular use case I am imagining to use netwire-irc in
04:58:37 <donri> mm_freak: relevant to that talk i think http://worrydream.com/ABriefRantOnTheFutureOfInteractionDesign/
04:58:45 <mm_freak> haasn: i'd rather use them together
04:59:15 <haasn> mm_freak: speaking of which; how would netwire-irc be designed? What would the API be? a Wire e m a IRCCommand -- that gets periodically polled by some driver, and whenever it produces an IRC command, that gets sent to the server?
05:02:06 <donri> mm_freak: did you see Peaker's lamdu?
05:02:25 <ocharles> mm_freak: wow, it's much easier with arrow notation! I now have my little cube pinging off the walls when I hit them :)
05:03:50 <haasn> ocharles: I want to see :)
05:05:04 <ocharles> haasn: one last tweak and I'll paste again :) do you have SDL installed?
05:05:09 <ocharles> if not, go grab that
05:05:16 <ocharles> it needs SDL, netwire and lens atm
05:05:28 <haasn> I have dev-haskell/sdl installed yeah
05:05:30 <haasn> might as well updated it
05:06:00 <ocharles> ok, cool
05:09:21 <mm_freak> donri: interesting rant
05:09:36 <mm_freak> donri: and no, i didn't see it…  whatever it is =)
05:09:46 <haasn> “Are we really going to accept an Interface Of The Future that is less expressive than a sandwich?” <- as long as Apple tells us it's the future, sure we will
05:09:49 <donri> mm_freak: https://github.com/Peaker/lamdu
05:10:06 <haasn> donri: is this like a fork of Bottle or whatever?
05:10:15 <donri> i don't know bottle
05:10:17 <mm_freak> haasn: (MonadReader IRCState m, MonadWriter IRCAction m) => Wire e m a b
05:10:23 <mm_freak> haasn: some combination of that sort
05:10:30 <mm_freak> probably lens-heavy
05:10:45 <mm_freak> ocharles: i'm happy to see your final product =)
05:10:49 <haasn> mm_freak: oh, that seems neat
05:11:23 <haasn> mm_freak: where would input come from?
05:12:26 <hpaste> ocharles pasted “A rectangle in a room with elastic walls” at http://lpaste.net/91368
05:12:34 <ocharles> mm_freak, haasn ^
05:12:46 <ocharles> the collision detection is shitty, but whatever :)
05:13:03 <ocharles> that arrow notation makes this much more usable
05:13:13 <ocharles> it took a bit of getting my head around, but I get it now
05:14:17 <ocharles> my naive attempt with boundedPosition not doing the whole +/-1 thing just meant I got stuck in the wall, but this seems to do the job
05:14:56 <haasn> why do you need outAs pDouble 0 instead of just 0?
05:15:32 <ocharles> I might not anymore, but it was getting confused as to which vectorspace I wanted before
05:15:37 <ocharles> that was probably before I had type annotations
05:15:46 <haasn> probably, yeah
05:16:03 <ocharles> yep, not needed now
05:16:04 <ocharles> thanks!
05:17:31 <haasn> more minor nitpicking: the way you've written xAccel/yAccel biases the input towards the topright; a more natural interface would be to go with whatever key the user pressed more recently (when both are held down)
05:18:42 <ocharles> haasn: good point
05:18:56 <ocharles> so then I would probably want to change keysDown to Map Key Time
05:19:36 <haasn> Or use [Key] ;)
05:19:55 <haasn> not like there are going to be so many keys pressed at a single time that a logarithmic lookup will matter much
05:20:15 <enthropy> can something be done on the cabal side for packages with broken pkg-config configurations?
05:20:32 <ocharles> haasn: ah yes, so recent key presses go to the head
05:20:35 <ocharles> nice idea, I'll try that
05:20:46 <haasn> ocharles: and you could use something like preview (folded . filtered isVertical) -- to get the first Key in that direction
05:21:05 <haasn> to shamelessly abuse lens some more
05:21:31 <mm_freak> haasn: whatever controls the wire…  likely some controller Proxy that is responsible for the networking
05:21:33 <ocharles> that doesn't seem like abuse :)
05:21:53 <haasn> mm_freak: right, but I mean, how does the wire get input?
05:22:57 <mm_freak> ocharles: btw, your code demonstrates a slight overuse of lenses =)
05:23:07 <haasn> ocharles: it just occurred to me how confusing “folded.to SDL.symKey” is
05:23:11 <haasn> looks like SDL is a constructor
05:23:13 <mm_freak> i think Set with S.member is perfectly fine there =)
05:23:15 <haasn> and symKey is another lens
05:23:24 <ocharles> mm_freak: member doesn't let me apply a predicate
05:23:31 <mm_freak> haasn: through the MonadReader and its input signal
05:23:45 <ocharles> mm_freak: I want the element that satisfies some predicate, not the exact element
05:23:57 <ocharles> SDL.Keysym has other constructors that I don't care about for now (such as modifiers)
05:24:02 <mm_freak> ocharles: but the predicate is (== x)
05:24:10 <mm_freak> which is exactly what S.member does
05:24:11 <edkk> have any of you written/read a nice implementation of edmonds-karp or another max-flow algo in haskell?
05:24:13 <ocharles> mm_freak: no, folded . to keySym takes the keysym field
05:24:17 <haasn> mm_freak: but he's combining it with the ‘to SDL.symKey’ getter
05:24:26 <ocharles> symKey even :)
05:24:28 <haasn> the predicate would be ((==x) . SDL.symKey)
05:24:36 <ocharles> si
05:24:54 <ocharles> if Set was a functor I could fmap and member, but it's not
05:25:43 <haasn> ocharles: wait a minute
05:26:00 <haasn> keyDown k = when $ elemOf k (folded.to SDL.symKey) -- should work?
05:26:14 <haasn> oh, swap the parameters to elemOf
05:26:48 <ocharles> what does that gain me above what I already have?
05:26:57 <haasn> point-freedom
05:27:05 <haasn> keyDown = when . elemOf (folded . to SDL.symKey)
05:27:11 <ocharles> ah
05:27:31 <haasn> besides, silly to reinvent the wheel with anyOf and (==) when elemOf is already the same thing =)
05:27:43 <mm_freak> ah, indeed
05:27:46 <mm_freak> missed that =)
05:28:51 * hackagebot unix-time 0.2.0 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.2.0 (KazuYamamoto)
05:28:52 <ocharles> haasn: that's true, I wrote the exact definition of elemOf :)
05:29:22 <haasn> ocharles: isn't your ‘collX’ and ‘collY’ a bit redundant? min/max should be a no-op if it fails
05:29:37 <haasn> and you're not saving any work since you perform the same comparisons either way
05:29:50 <ocharles> haasn: I wanted to perform collisions on the full space, but adjust it to a bounded space
05:30:16 <ocharles> i originally had just bX and bY and collX = bX /= x', but that causes the square to get stuck in the wall
05:31:24 <haasn> oh, I see, you're passing along the collision information so you can calculate friction
05:31:52 <ocharles> i'm passing the collision information out so I can invert the velocity along the direction of collision
05:32:03 <ocharles> i mean if i was being a bit more robust about this i'd provide a normal of collision or something
05:33:51 * hackagebot fast-logger 0.3.3 - A fast logging system  http://hackage.haskell.org/package/fast-logger-0.3.3 (KazuYamamoto)
05:35:17 <Format> > map * [2,2]
05:35:18 <lambdabot>   Couldn't match expected type `(a0 -> b0) -> [a0] -> [b0]'
05:35:18 <lambdabot>              with...
05:36:08 <supki> @ty map (*) [2,2]
05:36:09 <lambdabot> Num a => [a -> a]
05:36:19 <haasn> > map (*) [2,2] -- =)
05:36:20 <lambdabot>   [<Integer -> Integer>,<Integer -> Integer>]
05:36:54 <supki> nice
05:37:00 <supki> I mean terrible
05:37:01 <k00mi> > (*)
05:37:03 <lambdabot>   <Integer -> Integer -> Integer>
05:37:19 <k00mi> > (/)
05:37:20 <lambdabot>   <Double -> Double -> Double>
05:37:40 <k00mi> > id
05:37:42 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
05:37:42 <lambdabot>    arising from a use ...
05:37:45 <k00mi> aw
05:37:48 <Guest7667> ciao
05:43:52 * hackagebot postmark 0.1.0 - Library for postmarkapp.com HTTP Api  http://hackage.haskell.org/package/postmark-0.1.0 (MarkHibberd)
05:52:02 <haasn> @ask edwardk "Hello, world" & itraversed.indices (<5) .~ '*' -- return "*****, world"; but swapping out itraversed for imapped returns ⊥. Why?
05:52:03 <lambdabot> Consider it noted.
05:53:53 <CaptainK> what is the -- =) in map (*) [2,2] -- =)
05:54:01 <haasn> a comment and a smiley
05:54:20 <CaptainK> oh ya, that threw me off
05:54:33 <CaptainK> was stuck on infix
05:56:23 <osfameron> hehe
05:57:12 <Lethalman> ahah
05:59:51 <mr-> :-)
06:02:00 <mm_freak> donri: btw, i don't like modal UIs either
06:02:19 <donri> mm_freak: hehe. what editor do you use?
06:02:50 <mm_freak> given that i don't like modality, which one could it be? ;)
06:02:56 <haasn> hmm. Maybe somebody can help me find a good data structure to use: I need efficient lookup of random indices, and the ability to pick out that elements and place it at the head/tail; eg. pick 3 [a,b,c,d,e]  -> (c, [a,b,d,e])
06:03:09 <haasn> that element*
06:03:17 <supki> haasn: what lens version do you have?
06:03:17 <haasn> mm_freak: vim!
06:03:20 <donri> mm_freak: i don't know, every editor is modal :p
06:03:34 <haasn> supki: 3.9
06:03:38 <donri> emacs is probably more modal than vim ;)
06:03:41 <supki> haasn: imapped worked for me for 3.9.0.2
06:04:19 <mm_freak> donri: i use emacs precisely because it's not modal
06:04:42 <mm_freak> there is no difference between writing code, configuring the editor and watching compiler output
06:04:55 <mauke> if emacs isn't modal, then what is haskell-mode?
06:05:20 <mm_freak> mauke: don't confuse "mode" with "modality"
06:06:32 <mauke> what's your definition of modality?
06:06:50 <raichoo> Oh, editor discussion *fetches popcorn*
06:07:01 <mauke> oops
06:07:05 * mauke goes to #haskell-blah
06:07:14 <raichoo> :D
06:07:38 <mm_freak> mauke: it's vague…  modality is when different tasks require different kinds of interaction
06:08:01 <banister> is the way to think of IO
06:08:08 <banister> as the state monad, but the state is the entire world?
06:08:12 <mauke> banister: no
06:08:26 <mauke> because the universe doesn't actually get piped through your PC
06:08:34 <mm_freak> banister: think of IO as a language for writing procedures, nothing more
06:08:37 <haasn> and you don't have ‘putState’
06:08:41 <haasn> or whatever
06:08:45 <mauke> banister: I think of it as callbacks
06:08:58 <mauke> it helps if you know AJAX or similar
06:09:15 <banister> mauke: can you make the ajax analogy more explicit for me (sorry)
06:09:49 <banister> s/ajax/callback
06:09:57 <mauke> well, look at the >>= operator
06:10:07 <mauke> (>>=) :: IO a -> (a -> IO b) -> IO b
06:10:22 <haasn> one completely adequate way of thinking about IO is to imagine it expands to some sort of abstract description of commands, eg. data IO' a = Return a | GetLine (String -> IO' a) | WriteLine String (IO' a)
06:10:32 <mauke> it takes an IO action and a callback, and returns a new IO action (that is the result of attaching the callback to the first action)
06:11:00 <mauke> i.e. running 'x >>= f' will first run x, then "call back" f
06:11:10 <mauke> (then run the result of f, but that's another thing)
06:11:39 <banister> mauke: oh sure, but im trying to understand IO in terms of a 'computational context' / 'container' model of monads, what is the 'container' / 'computational context' of IO?
06:11:59 <mauke> no idea what that is
06:12:12 <haasn> “because the universe doesn't actually get piped through your PC” sounds like a challenge http://hackage.haskell.org/packages/archive/acme-realworld/0.1.1/doc/html/Acme-RealWorld.html
06:12:17 <mauke> something about magic boxes made of time travel?
06:12:27 <haasn> @@ banister @quote /usr/bin/ls
06:12:28 <lambdabot>  banister No quotes match. And you call yourself a Rocket Surgeon!
06:12:31 <haasn> hmm
06:12:33 <haasn> @quote /bin/ls
06:12:33 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
06:13:41 <mauke> @quote duqicnk
06:13:42 <lambdabot> No quotes match. My pet ferret can type better than you!
06:13:53 <mauke> @quote Duqicnk
06:13:53 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
06:15:32 <haasn> banister: in short, ‘IO’ doesn't “contain” anything or carry around any “computational context” - it simply represents some sort of action that could be performed in the real world, with the usual Monad operations
06:15:57 <mauke> there is no real world, btw
06:16:25 <mauke> you could see it as a "computational context" if you define "computational context" as "monad"
06:16:29 <mauke> :-)
06:16:46 <haasn> Haskell programs never see the light of the day
06:17:19 <Taneb> If monads are computational context, would comonads be mptuational ntext?
06:17:28 <haasn> :(
06:17:44 <mauke> Taneb: of course! you should write a tutorial
06:17:56 <mauke> no, you should co-author one
06:18:07 <haasn> I like to imagine comonads as ntainers of things
06:19:47 <donri> me on people, these jokes are old
06:20:11 <quchen> Mpletely old
06:21:03 <haasn> on the topic of amusing things
06:21:05 <haasn> @quote lemon
06:21:05 <lambdabot> xplat says: when life gives you lemons, make lemonads
06:35:40 <hpaste> Svedrin pasted “Msmt” at http://lpaste.net/91369
06:35:50 <Svedrin> oy
06:36:19 <Svedrin> okay then, is there a way to refactor those lines 12-16 to look a little... less copypasta-like?
06:37:20 <mauke> msmtFromSql [msmtid, checkuuid, time, field, value] = Msmt {..}  -- 1) does this actually work?  2) how evil would it be?
06:37:39 <mauke> oh, it doesn't because fromSql
06:39:21 <quchen> Yaay Marlow's book is out!
06:39:39 <Tinned_Tuna> Marlow's book?
06:39:41 <quchen> We need an official abbreviation for it. PACPIH?
06:40:00 <quchen> Simon Marlow - Parallel and concurrent programming in Haskell
06:40:19 <quchen> I vote for SimonPar :-)
06:40:36 <quchen> Or Parlow
06:41:16 <haasn> marlow13 ?
06:41:28 <quchen> 13?
06:41:37 <haasn> 2013?
06:41:43 <quchen> Oh.
06:42:08 <quchen> Meh. I'm not Latex.
06:42:29 <tikhon> PACP isn't bad
06:42:34 <donri> The Book of Marlow
06:42:51 <shergill> +1 for parlow
06:43:31 <quchen> Yeah I think I'm going to lobby for Parlow. PACP makes my tongue sore pronouncing it :-P
06:43:42 <tikhon> eh, it's no worse than SICP or TAPL
06:47:17 <bennofs> Does the ByteString IsString instance have the same problems as Data.ByteString.Char8?
06:48:20 <haasn> bennofs: I'd count on it
06:48:34 <haasn> there's no way to make a sane IsString instance for ByteString
06:49:06 <bennofs> Why can't it just use UTF-Something?
06:49:10 <shergill> oh parlow has examples from repa. how does repa compare to hmatrix?
06:50:31 <haasn> bennofs: I checked, does the exact same thing as .Char8
06:50:46 <haasn> bennofs: and, well, what UTF-something would you default to and why should that be the default choice?
06:50:56 <bennofs> But for let x = "æŧ" (I hope that's actually a string that produces problems with Char8?), Char8.pack x displays "\230B", whereas just x gives "\230\322"
06:51:52 <FreeFull> I'm pretty sure let x = "♥" won't work with Char8
06:51:56 <byorgey> shergill: they are quite different.  hmatrix is a binding to BLAS/LAPACK and is for doing linear algebra with vectors and matrices and such.  repa is for working, efficiently and in parallel, with multidimensional arrays
06:52:22 <byorgey> shergill: note that *matrices* and *arrays* are not at all the same thing (despite the fact that one often uses the latter as a concrete representation of the former)
06:52:34 <haasn> bennofs: are you sure you're not outputting as String there?
06:52:40 <haasn> \322 shouldn't occur in a ByteString :)
06:52:48 <byorgey> in other words, hmatrix is about doing math; repa is about working with data structures
06:53:06 <simukis_> > x = "♥" :: ByteString
06:53:06 <bennofs> Oops, I forgot that I have to specify a type for overloaded string literals ^^
06:53:07 <lambdabot>   <hint>:1:3: parse error on input `='
06:54:26 <bennofs> But, I think anything would be better than just to clamp the values to 8 bits. With UTF-Something, at least pack . unpack = unpack . pack = id should be true
06:55:15 <simukis_> well always enforcing UTF-8 on bytestring is wrong, but defaulting to UTF-8 in IsString for bytestring would be sane
06:55:26 <FreeFull> > C8.pack "♥"
06:55:30 <lambdabot>   mueval-core: Time limit exceeded
06:55:55 <donri> isn't that what utf8-string does
06:56:04 <byorgey> bennofs: bytestring is designed for storing sequences of bytes.  If you want to convert a String to a bytestring you have to do the encoding yourself.
06:56:09 <shergill> byorgey: hmm ok. but ultimately with those data structures you'd want to do math wouldn't you?
06:56:15 <merijn> bennofs: If you want "UTF-something" you probably want Text rather than ByteString anyway
06:56:21 <byorgey> bennofs: why do you want to convert a String to a bytestring anyway?  Perhaps you want Text instead?
06:56:26 <shergill> well assuming they're numeric arrays
06:56:53 <bennofs> The hedis package doesn't support Text for whatever reason (maybe because you can also store binary data in a redis database?)
06:56:53 <byorgey> shergill: well, you will want to do operations on them.  But not necessarily linear-algebra sorts of operations.
06:56:59 <merijn> The only valid usecase for String -> ByteString is network protocols that use ASCII commands that you want to write
06:57:00 <bennofs> @hackage hedis
06:57:00 <lambdabot> http://hackage.haskell.org/package/hedis
06:57:04 <byorgey> shergill: for example, suppose you have arrays of pixels
06:57:17 <merijn> bennofs: Yes, but Text has a sane "encodeUtf8"
06:57:33 <byorgey> shergill: those are definitely not "matrices" in the sense of representing linear operators
06:57:35 <merijn> bennofs: So you can just convert to utf8 or whatever when passing Text to hedis
06:57:36 <bennofs> But then I have to write encodeUtf8 all over my code
06:57:55 <merijn> Why all over? Just convert when interfacing with it?
06:58:06 <haasn> byorgey: pixels being a good example, suppose I want to subpartition an image into small 32x32 chunks and then do some (sequential) mangling on those blocks; but blocks themselves are still independent from others. Can repa do this?
06:58:11 <merijn> Or even better, ask the author of hedis to support Text? :>
06:58:16 <byorgey> bennofs: yep.  And you have to put types all over your code too.  Boo hoo.
06:58:26 <byorgey> bennofs: implicit conversions is not The Haskell Way.
06:58:36 <shergill> byorgey: ah gotcha. and true, but there's a fair bit of overlap, since computer vision problems use linear algebra tools heavily
06:58:38 <haasn> Text is the haskell way :)
06:58:40 <byorgey> haasn: yes
06:58:48 <byorgey> shergill: right.
06:58:56 <bennofs> Yeah, but set (encodeUtf8 "key") (encodeUtf8 "value") doesn't look nearly as nice as set "key" "value".
06:59:23 <haasn> bennofs: so write a helper?
06:59:24 <byorgey> bennofs: so make a function  set' k v = set (encodeUtf8 k) (encodeUtf8 v) .
06:59:33 <arnsholt> Also, implicit conversions of string data is evil and a sure way to get into horrible messes down the road (see also pretty much every scripting language and interacting properly with Unicode data)
06:59:37 <merijn> bennofs: Or you just write "textSet key val = set (encodeUtf8 key) (encodeUtf8 val)"
06:59:49 <Cale> bennofs: There's always OverloadedStrings
06:59:56 <haasn> Cale: that's what this is about :)
07:00:02 <merijn> Cale: No, there isn't, that was his complaint
07:00:10 <Cale> If you're actually using set "key" "value" and not set k v
07:00:15 <haasn> Cale: specifically, he needs to use ByteStrings
07:00:27 <merijn> Cale: ByteString only supports ASCII encoding in its IsString
07:00:31 <Cale> ah
07:00:38 <FreeFull> Oh
07:00:44 <typoclass> hm. http://hackage.haskell.org/packages/archive/hedis/0.6.2/doc/html/Database-Redis.html#g:17 has a section "Strings" which seems to talk only about ByteStrings. that's an unfortunate choice of words and a bit misleading. there's an important difference between Strings (unicode) and ByteStrings (bunches of 8-bit bytes)
07:00:53 <FreeFull> I just realised you can't implement tuples using functions in Haskell without dependent typing
07:00:58 <donri> > maxBound + 1 :: Word8
07:00:59 <lambdabot>   0
07:01:07 <bennofs> I really don't care what IsString for bytestring does, I'd just like that it doesn't throw something away
07:01:16 <haasn> FreeFull: what do you mean?
07:01:29 <merijn> bennofs: So, what you're saying is that you do care :)
07:01:29 <roconnor> FreeFull: forall r. (a -> b -> r) -> r
07:01:31 <typoclass> bennofs: you're right about that. things should not be thrown away
07:01:58 <donri> > 300 :: Word8
07:01:59 <lambdabot>   44
07:02:05 <donri> it's not exactly unique to bytestring or IsString
07:02:13 <FreeFull> haasn: As in    makeTuple a b x = if x then a else b    fst tuple = tuple True;  snd tuple = tuple False;
07:02:33 <haasn> FreeFull: what roconnor said
07:02:37 <merijn> donri: IMO the behaviour of Word8 is desirable
07:03:01 <haasn> fst tuple = tuple const; snd tuple = tuple (flip const)
07:03:12 <FreeFull> Oh
07:03:14 <merijn> At least, for the fromInteger function (which by extension affects literals)
07:03:17 <roconnor> haasn: makeTuple a b f = f a b   ;   fst p = p const   ; snd p = p (flip const)
07:03:20 <FreeFull> That could work, potentially
07:03:25 <roconnor> er FreeFull
07:03:41 <merijn> If there was a separate conversion function for literals I'd be okay with that, but lacking that I think the current approach is best
07:03:41 <haasn> ‘potentially’ here meaning ‘actually’? :)
07:03:46 <FreeFull> Let me try it out =P
07:03:53 * hackagebot unix-process-conduit 0.2.2 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.2.2 (MichaelSnoyman)
07:04:01 <haasn> FreeFull: you can encode any non-recursive data type that way
07:04:09 <haasn> and recursive ones if you allow helper types for recursion, I guess
07:04:10 <roconnor> FreeFull: may require RankNTypes and some type signatures to work well.
07:04:10 <typoclass> donri: yes but i think his complaint is still valid. things should not silently overflow. (also, people have just told him things like "implicit conversion is not The Haskell Way" and "you also need to put types everywhere, boo hoo")
07:05:17 <FreeFull> Yeah, that works
07:05:28 <FreeFull> roconnor: It actually works without type signatures just fine
07:05:57 <FreeFull> And without any pragmas
07:06:38 <roconnor> FreeFull: it won't keep working like that when you start making heavy use of it.
07:06:48 <haasn> FreeFull: you need RankNTypes when you want to use both fields of a tuple with differing types
07:07:02 <roconnor> FreeFull: toHaskellPair p = (myfst p, mysnd p)  --- this will require rank2types to work.
07:07:33 <haasn> roconnor: that or :: Tuple a a -> (a, a)
07:08:58 <FreeFull> Yeah, you're right
07:13:22 <t7> how do i define a sequence based on its last element?
07:13:41 <t7> @hoogle (a -> a) -> a -> [a]
07:13:42 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
07:13:42 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
07:13:42 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
07:14:18 <mauke> t7: what do you mean?
07:14:25 <donri> @quote zip`ap`tails
07:14:25 <lambdabot> No quotes match. Just try something else.
07:14:35 <quchen> @quote zip`ap`tail
07:14:36 <lambdabot> quicksilver says: zip`ap`tail the aztec god of consecutive numbers
07:14:40 <t7> i mean previous
07:14:48 <quchen> t7: unfoldr?
07:14:49 <mauke> iterate
07:15:20 <t7> iterate works
07:22:45 <typoclass> bennofs: ok, i wrote up an OverloadedString thingy that will let you use "abc" in place of a ByteString. the encoding is fixed to utf-8 (you need to make sure this is what you want) http://lpaste.net/91370
07:23:38 <sirspazzolot> > [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]
07:23:40 <lambdabot>   [(1,1,1),(2,1,1),(3,1,1),(4,1,1),(5,1,1),(6,1,1),(7,1,1),(8,1,1),(9,1,1),(1...
07:23:54 <LowPotential> I know that in general, foldr is preferable to explicit tail-recursion. In my case though, the thing that I'm folding over is generated at every step (the remaining ByteString in parsing one part of a binary file). Is there a good alternative to cons'ing to a list and reversing at the end? Does the question make sense?
07:24:04 <sirspazzolot> > [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10], a^2+b^2==c^2, a+b+c==24 ]
07:24:05 <lambdabot>   [(8,6,10),(6,8,10)]
07:24:16 <mm_freak> :t \f x -> fix ((pure x <|>) . fmap f)
07:24:17 <lambdabot> Alternative f => (a -> a) -> a -> f a
07:24:37 <donri> typoclass: it will fail if any other code imports this code and .Char8, though
07:24:38 <sirspazzolot> in lyah this only returns the second triple. eh?
07:24:41 <donri> yay orphan instances
07:24:46 <mm_freak> > (\f x -> fix ((pure x <|>) . fmap f)) (2*) 1 :: [Integer]
07:24:47 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
07:25:23 <b2coutts> sirspazzolot: maybe in lyah they take the head of the list or something? looking at that code, it should clearly return both things
07:25:50 <bennofs> typoclass: Unfortunally, the IsString instance using Char8 for ByteString is exported by default, so I get a duplicate instance error.
07:26:02 <merijn> LowPotential: One common solution is to build a list by doing "\l -> startOfList ++ l", which is O(1) append
07:26:04 <mm_freak> LowPotential: foldr is certainly not preferable to tail recursion =)
07:26:10 <sirspazzolot> ohh I see the issue. b is taken from [1..c] and a is taken from [1..b]
07:26:13 <sirspazzolot> whoops haha
07:26:18 <mm_freak> foldr is inherently not tail-recursive
07:26:20 <merijn> LowPotential: Then at the end you just have to pass in a final []
07:26:31 <sirspazzolot> > [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2+b^2==c^2, a+b+c==24 ]
07:26:32 <lambdabot>   [(6,8,10)]
07:26:46 <applicative> LowPotential: can you extract a bit of the source, then people might be clearer
07:27:04 <mm_freak> LowPotential: to answer your question see difference lists
07:27:09 <typoclass> donri: seems so! interesting. plausible fix would be for the Data.ByteString.Char8 authors to move the instance to D.B.Char8.OverloadedStrings, so that users can specifically control importing that one instance?
07:27:14 <LowPotential> applicative: This is a hobby project, so I'll try to post a minimal complete example.
07:27:15 <mm_freak> @hackage dlist
07:27:15 <lambdabot> http://hackage.haskell.org/package/dlist
07:28:01 <typoclass> bennofs: yes that's true. well spotted. (do you still need .Char8 imported everywhere?)
07:28:01 <b2coutts> > head [ (a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2+b^2==c^2, a+b+c==24 ]
07:28:02 <applicative> LowPotential: what are the things you're consing to a list?
07:28:03 <lambdabot>   (6,8,10)
07:28:15 <b2coutts> woah, I didn't think that would actually work
07:28:25 <bennofs> typoclass: It happens even if I don't import .Char8
07:28:43 <mm_freak> b2coutts: why not?
07:28:43 <b2coutts> I figured it would just iterate over all (c,1,1)
07:28:56 <bennofs> typoclass: I just compiled the code you pasted
07:29:00 <b2coutts> though I don't really know a lot about how list comprehensions are implemented
07:29:26 <mm_freak> b2coutts: if you desugar the list comprehension you will end up with a bunch of concatMaps
07:29:26 <hpaste> LowPotential pasted “Explicit Tail-Recursion Improvements?” at http://lpaste.net/91371
07:29:27 <b2coutts> wait actually now that I think about it it makes sense
07:29:34 <LowPotential> Something like this?
07:29:40 <LowPotential> Let me know if more would be helpful.
07:30:21 <typoclass> bennofs: hm. it does run for me. maybe we have different versions. could you paste the error message that you're getting?
07:30:22 <b2coutts> > take 5 [ (a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2+b^2==c^2 ]
07:30:23 <lambdabot>   [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17)]
07:30:43 <b2coutts> lambdabot: ++
07:31:08 <hpaste> bennofs pasted “Error message: Duplicate instances ” at http://lpaste.net/91372
07:31:13 <mm_freak> > concatMap (\c -> concatMap (\b -> concatMap (\a -> if a^2 + b^2 == c^2 && a + b + c == 24 then [(a, b, c)] else []) [1..b]) [1..c]) [1..]
07:31:17 <lambdabot>   mueval-core: Time limit exceeded
07:31:28 <mm_freak> > head $ concatMap (\c -> concatMap (\b -> concatMap (\a -> if a^2 + b^2 == c^2 && a + b + c == 24 then [(a, b, c)] else []) [1..b]) [1..c]) [1..]
07:31:29 <lambdabot>   (6,8,10)
07:31:52 <bennofs> I have bytestring-0.10.0.2
07:31:58 <mm_freak> that's what the list comprehension desugars to, conceptually
07:33:06 <LowPotential> applicative mm_freak: lpaste'd, just in case you didn't see. :)
07:34:36 <quchen> LowPotential: If you're building a list as a result, I don't think tail recursion is what you're looking for anyway. I don't think the acccumulator you're using is necessary here, it just puts the list thunk in another place.
07:34:58 <mm_freak> LowPotential: to me that's a left-fold of the bytestring
07:35:24 <mm_freak> unfortunately the left-fold combinator for ByteString sucks, so you need to write your own
07:35:35 <mm_freak> a foldM may be handy for your case
07:35:38 <mm_freak> :t foldM
07:35:38 <quchen> mm_freak: How does it suck?
07:35:39 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
07:35:47 <mm_freak> quchen: look at its type
07:35:53 <mm_freak> :t B.foldl
07:35:54 <lambdabot> Couldn't find qualified module.
07:35:58 <mm_freak> :t BS.foldl
07:35:59 <lambdabot> (a -> Word8 -> a) -> a -> BSC.ByteString -> a
07:36:03 <quchen> CHAR!?
07:36:13 <mauke> wrong module
07:36:16 <mm_freak> oh, actually it doesn't suck
07:36:20 <applicative> what is RawProgram , LowPotential
07:36:20 <mm_freak> no, not because of the Word8
07:36:33 <quchen> BS.Char8 uses Char there.
07:36:45 <mm_freak> my memory fooled me…  i remembered it as being non-polymorphic
07:36:48 <LowPotential> applicative: Sorry. Just "type Ast.RawProgram = [Ast.Statement]"
07:37:12 <applicative> I see, you are accumulating a list
07:37:24 <mm_freak> it's amazing how you say that BS.foldl sucks and everybody just assumes that it's because of the byte type
07:38:05 <merijn> quchen: You shouldn't be using BS.Char8 anyway
07:38:06 <applicative> why does BS.foldl suck? surely it's fine
07:38:19 <typoclass> bennofs: hm that's unfortunate. i don't know how to fix that, sorry
07:38:21 <quchen> merijn: Yeah, I soon relized I looked at the worst module in the BS family
07:38:24 <donri> bennofs, typoclass: yes it happens also if anything in your recursive tree of imports import .Char8
07:38:25 <mm_freak> btw, BSC.foldl actually sucks, because the entire BSC interface sucks =)
07:38:31 <mm_freak> BS.foldl doesn't suck
07:38:37 <LowPotential> quchen: Yes, I'm accumulating a list. What would be the alternative?
07:38:39 <chunkstuntman> I'm trying to find the number of digits in a number by using logBase 10 n
07:38:42 <typoclass> (... short of patching the bytestring package)
07:38:48 <bennofs> donri: I know, but why does Data.ByteString import Data.ByteString.Char8?
07:38:50 <merijn> mm_freak: THe problem is that you end up appending one Word8 at a time?
07:38:51 <chunkstuntman> but when n is too big, I get an "infinate" output
07:38:57 <chunkstuntman> infinite*
07:39:00 <mm_freak> merijn: there is no problem
07:39:00 <mauke> chunkstuntman: length . show
07:39:19 <bennofs> I guess a patch would break backwards compatibility.
07:39:28 <mm_freak> chunkstuntman: integers?
07:39:31 <donri> bennofs: i don't think it does?
07:39:50 <merijn> bennofs: Where did you get the idea that Data.ByteString imports Data.ByteString.Char8?
07:39:51 <LowPotential> quchen: A 'Ast.RawProgram' is a list of 'Ast.Statement' and I need to parse one or many 'getStatement :: Get (Ast.Statement)'
07:40:05 <applicative> LowPotential: this seems okay, it isn't the sort of place where we want 'tail recursion' in haskell; then the accumulator would be something like a number, not a list itself
07:40:17 <bennofs> donri: If I do: > :set -XOverloadedStrings; import qualified Data.ByteString as BS; "3" :: BS.ByteString; I don't get an error => instance imported
07:40:28 <mm_freak> > let intLog b = length . takeWhile (> 0) . iterate (`div` 10) in intLog 12345
07:40:29 <lambdabot>   <Integer -> Int>
07:40:38 <mm_freak> > let intLog b = length . takeWhile (> 0) . iterate (`div` b) in intLog 10 12345
07:40:39 <lambdabot>   5
07:40:52 <bennofs> The instance is defined in Data.ByteString.Char8, so at some point in the import chain, that module must have been imported
07:41:08 <mm_freak> > let intLog b = length . takeWhile (> 0) . iterate (`div` b) in intLog 10 (3^100000)
07:41:10 <lambdabot>   47713
07:41:22 <donri> bennofs: i get No instance for (Data.String.IsString ByteString)
07:41:26 <typoclass> donri: to clarify, benno is talking about the IsString instance. bytestring-0.9.* had it in D.B.Char8, bytestring-0.10.* apparently has it in Data.ByteString.Internal, which is what you get when you do import Data.ByteString
07:41:35 <donri> bennofs: maybe we have different versions or you're importing something more than bytestring
07:41:35 <mm_freak> note that this function is off-by-one for proper powers of 10
07:41:48 <merijn> bennofs: No, there's an instace of IsString in Data.ByteString
07:41:49 <applicative> LowPotential: this wont be great if there are a huge number of 'program statements' but I think it would have to be huge.
07:41:50 <donri> typoclass: ah
07:42:01 <haasn> bennofs: http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/src/Data-ByteString-Internal.html#ByteString
07:42:04 <bennofs> Ah, maybe I looked at the old bytestring then
07:42:05 <quchen> LowPotential: Oh, you're not looking at the BS byte-wise, `statement` is kind of a parser?
07:42:06 <applicative> there is in ByteString.Char8
07:42:14 <quchen> In that case, have you considered using a parser? :-)
07:42:18 <merijn> bennofs: It's defined in Data.ByteString.Internal
07:42:27 <typoclass> donri: ... which honestly is a mistake, isn't it ...
07:42:30 <donri> also this is complete and utter abuse of type classes :)
07:42:32 <mm_freak> > let intLog b = succ . length . takeWhile (> 9) . iterate (`div` b) in (intLog 10 10000, intLog 10 12345)
07:42:34 <lambdabot>   (5,5)
07:42:39 <mm_freak> this one works
07:42:43 <donri> typoclass: the mistake is that there is an instance at all :p
07:42:45 <LowPotential> applicative: Sorry, my "lingo" might be a bit wrong. Would it be more correct to call what I'm doing explicit recursion with an accumulator?
07:43:09 <LowPotential> quchen: Yup. This is actually a disassembler.
07:43:17 <applicative> LowPotential: yes, it is a left fold; there is an accumulator; it is explicit recursion for sure
07:43:40 <mm_freak> it's a left foldM
07:43:47 <donri> bennofs: might be better to write a quasiquoter for this. [utf8|Hi there!|]
07:43:53 <haasn> mm_freak: is there even a right foldM?
07:43:57 <quchen> applicative: But contrary to a fold, the BS isn't consumed bytewise, it has multi-byte lookahead
07:44:02 <mm_freak> haasn: sure
07:44:06 <LowPotential> quchen: Correct.
07:44:15 <haasn> mm_freak: but the effects have to be composed left-to-right, no?
07:44:27 <LowPotential> haasn: Yes.
07:44:35 <bennofs> donri: That seems like a good idea, is there already a package providing that?
07:44:40 <mm_freak> haasn: both make sense
07:44:45 <applicative> quchen: yes, I see that, I was still thinking the jargon is appropriate, as one often uses the language e.g with streams of data coming from IO and so on,
07:44:46 <LowPotential> I can't know ahead of time how much of the ByteString will be consumed at each step.
07:44:47 <haasn> oh, wait, no, both make sense
07:44:53 <mm_freak> so you would have a foldrMr and foldrMl
07:45:03 <quchen> LowPotential: Which brings us back to "why don't you use a parser lib"? :-)
07:45:06 <applicative> quchen: I mean, the jargon of a left fold, but maybe thats too remote an analogy
07:45:29 <typoclass> bennofs: i think you're right that this a weakness in haskell. your best bet might be to do «u "abc"», with u being a little helper function that you wrote. (or use a quasiquoter)
07:45:46 <LowPotential> quchen: I'm already using Parsec for the assembler. My cursury impression was that Data.Binary was easier for handling binary data.
07:46:31 <LowPotential> quchen: Maybe not. :)
07:46:52 <quchen> LowPotential: I don't understand. Data.Binary is for serialization, not working with data, isn't it?
07:47:01 <donri> bennofs: yeah function would work too. u = encodeUtf8, then use OverloadedStrings and it will use Text because of the type of "u"
07:47:12 <bennofs> typoclass: right. One could even write "f `u` "3" `u` "æ" " with an appropriate u
07:47:20 <applicative> of course, this program can also be viewed as an ordinary list unfold, LowPotential
07:47:24 <applicative> @type unfold
07:47:25 <lambdabot>     Not in scope: `unfold'
07:47:25 <lambdabot>     Perhaps you meant one of these:
07:47:25 <lambdabot>       `BS.unfoldr' (imported from Data.ByteString),
07:47:36 <quchen> :t BS.unfoldr
07:47:37 <lambdabot> (a -> Maybe (Word8, a)) -> a -> BSC.ByteString
07:48:18 <mm_freak> bennofs: there is also utf8-string, which gives you a UTF-8 interface to ByteString…  applying a function is easier and requires less code than using a quasiquoter in this case
07:48:20 <typoclass> i think i'll report a bug on bytestring. that instance pretty much sucks, doesn't it. the use case that we had (write your own IsString instance that utf8-encodes) isn't so far-fetched
07:48:31 <applicative> that's for unfolding a bytestring out of something, we are unfolding a list from a bytestring seed, and a -> Either e (b,a)
07:48:35 <mm_freak> compare `[u|…|]` with `u "…"`
07:48:40 <applicative> :t Prelude.unfoldr
07:48:41 <lambdabot>     Not in scope: `Prelude.unfoldr'
07:48:41 <lambdabot>     Perhaps you meant one of these:
07:48:41 <lambdabot>       `Prelude.foldr' (imported from Prelude),
07:48:48 <LowPotential> As an asside, does anyone else notice that searching hackage packages on Google often results in outdated versions? It's very frutrating.
07:48:48 <applicative> :t Data.List.unfoldr
07:48:49 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
07:49:14 <applicative> LowPotential: see the similarity of the type of ^^^ unfoldr to what youre doing
07:49:18 <mm_freak> the bug is that ByteString has an IsString instance…  but it's a useful bug when parsing stuff
07:49:23 <zvrba> bah, I have to download msysgit :S
07:49:30 <quchen> LowPotential: I use new-hackage for package searching. It's still beta yadda yadda: http://new-hackage.haskell.org/
07:49:31 <applicative> LowPotential: yes, it's annoying, it's much better lately, or had been
07:49:34 <quchen> LowPotential: Or Hoogle.
07:50:10 <applicative> ooo this new-hackage is shiny
07:50:13 <LowPotential> applicative: That looks exactly right, ectually.
07:50:17 <typoclass> mm_freak: i have no opinion if the instance is good or bad, but i think it shouldn't be in Data.ByteString. it should have its own module which contains only that instance, so that users can control importing precisely
07:50:21 <mm_freak> LowPotential: duckduckgo.com is usually better for looking up haskell packages
07:50:23 <applicative> kinda like old-hackage
07:50:29 <mm_freak> try "hackage lens"
07:50:39 <LowPotential> I can just replace (Either EncodeError) with Maybe and 'unfold' should work.
07:50:53 <LowPotential> Learn something new every day. :)
07:50:54 <mm_freak> typoclass: that's a poor solution
07:50:57 <zvrba> applicative: what was it I was supposed to do with your fork of hdirect?
07:51:06 <zvrba> I'll d/l it and test it...
07:51:16 <LowPotential> Thanks everyone for the input!
07:51:27 <bennofs> LowPotential: If you only search functions/packages/modules, you can also use hayoo
07:51:31 <applicative> zvrba: oh, nothing, we already figured out the Version thing.
07:51:40 <zvrba> yeah
07:51:50 <applicative> zvrba: where I thought it was sometihng about Data.Version
07:51:50 <quchen> LowPotential: I'm still not sure I understand your approach. So at some point, you've got ASM source coming in, and you'd like to make an AST out of that, correct?
07:52:06 <quchen> Why the ByteStrings at all in that case?
07:52:45 <[2]theWinner> Does GHC prove the lack of aliasing in certain cases and thereby optimize data updates with in-place mutation?
07:52:58 <typoclass> mm_freak: well, if you don't have a better idea ... *shrug*
07:53:00 <quchen> What about Text + Parsec.Text?
07:53:06 <applicative> zvrba: I think the main question was whether it works. If it does, we would do well to contact SigborneFinne or dons with the update
07:53:23 <zvrba> applicative: I'm cloning your repo now and am going to test it
07:53:25 <mm_freak> typoclass: the better idea is to figure out whether the instance is correct, and if not, remove it or replace it
07:53:30 <LowPotential> quchen: Sorry, I was a bit unclear. I have an assembler (which translates assembly to an AST and then encodes it to a binary file), AND a disassembler (which reads back binary files into an AST and then writes the AST as plain-text). They're complementary functions.
07:53:34 <zvrba> if I figure out all type madness inside IO monad :P
07:53:45 <mm_freak> don't make the visibility of instances conditional on importing a special module, because that will break down
07:53:54 <zvrba> applicative: why doesn't cabal have uninstall?
07:54:07 <applicative> it looks complicated this hdirect
07:54:08 <LowPotential> quchen: Er... Complementary functionality.
07:54:10 <zvrba> when I do cabal install on hdirect again, I get a warning about it being potentially dangerous to reinstall packages..
07:54:22 <zvrba> applicative: yup. it can even write out TLB files.
07:54:28 <applicative> zvrba: because ghc-pkg unregister hdirect is uninstall
07:54:32 <applicative> to put it crudely
07:54:35 <zvrba> ok
07:54:42 <quchen> LowPotential: Ah, I see. So you use BS.readFile in binary mode to get your input, and that's where the BS comes from. Alright, now we're on the same page.
07:55:01 <zvrba> now it complains about cache being out of date :S
07:55:03 <applicative> it would in fact leave the library; but in the present case it will be overwritten zvrba
07:55:33 <LowPotential> quchen: Yup. I think unfold makes sense, but I haven't tried it yet.
07:56:00 <quchen> LowPotential: I think something like "program = many1 statement" also makes a lot of sense. :-)
07:56:03 <applicative> oh wait, zvrba this is ghc-pkg complaining about cache out of date
07:56:10 <zvrba> yup
07:56:33 <applicative> hm, I haven't seen that forever
07:56:50 <quchen> LowPotential: You didn't show us the AST -> binary part, right? All this code/talk was just for the binary -> AST?
07:56:50 <typoclass> mm_freak: i don't have an opinion if the instance is correct, mostly because i don't have an opinion what "correct" means in this case. i'm not aware of (e.g.) laws for IsString that someone has written up. why would it break to have a module Data.ByteString.Char8.OverloadedString containing only the IsString instance?
07:56:56 <quchen> Or did I overlook something
07:57:06 <zvrba> but then it can't modify a file in c:/program files (UAC..)
07:57:15 <ptek> does anyone of you use quickcheck extensively?
07:57:17 <LowPotential> quchen: That's correct.
07:57:30 <tikhon> ptek: Maybe not *extensively*, but I certainly use it
07:57:36 <applicative> does ghc-pkg recache --user do anything strange zvrba
07:57:37 <mm_freak> typoclass: user wants the instance in module A, but not in module B…  unfortunately module B imports module A
07:57:55 <ptek> tikhon, how do you come up with the properties of a function you want to test?
07:57:56 <mm_freak> because of this it's better to assume that instances are global and always there
07:58:08 <tikhon> umm, it depends
07:58:42 <tikhon> usually the invariants occur naturally in the problem domain
07:58:48 <zvrba> applicative: hm, your version doesn'c compile. ambigous catch (Prelude or Control.Exception)
07:58:53 <zvrba> applicative: which one to choose?
07:59:02 <applicative> bah, what module is that happening
07:59:03 <applicative> in
07:59:14 <applicative> zvrba: must be subtly different ghc from mine
07:59:18 <zvrba> Utils.lhs
07:59:27 <typoclass> mm_freak: hmmm
07:59:27 <b-rye> Does _any_ Haskell compiler prove the lack of aliasing in certain cases and thereby optimize data updates with in-place mutation behind the scenes?
07:59:57 <tikhon> b-rye: I think some libraries do that, but I doubt the compilers do it in general
08:00:07 <tikhon> but I'm hardly an expert on optimization
08:00:35 <mm_freak> b-rye: what is in-place update?  don't confuse haskell's heap allocation with malloc()
08:01:04 <zvrba> applicative: hmm, must import C.Exc. because it wants SomeException
08:01:06 <abaw> hi, I am new to haskell and trying to write some little program.
08:01:13 <abaw> having a question about ByteString
08:01:19 <mm_freak> b-rye: if you crunch on a number GHC will likely not waste time getting a new memory cell, especially if you use the LLVM backend
08:01:30 <ptek> tikhon, I am wondering if there is any way to get the properties right, and also to make sure one has the minimal set of properties which would unambiguously define a function
08:01:35 <abaw> some module exporting a type "Domain" which is defined as "type Domain = ByteString"
08:01:43 <applicative> oh is zvrba I was assuming a ghc-7.6 I think with that repair
08:01:57 <zvrba> I have 7.4.2
08:02:03 <abaw> how could I convert String to Domain? I tried:  C.pack "foo" :: Domain
08:02:15 <zvrba> applicative: there are more files that error on that.
08:02:16 <tikhon> ptek: I don't think it's worth trying to unambigously define a function with invariants
08:02:20 <mm_freak> abaw: depends on what "convert" means
08:02:22 <abaw> where is C is: import qualified ByteString.Char8 as C
08:02:23 <zvrba> applicative: how to fix it?
08:02:51 <tikhon> ptek: the testing isn't meant to be a *complete* specification of the progam—just enough to catch a bunch of bugs
08:02:57 <mm_freak> abaw: C.pack works, but you should require ASCII when using it
08:03:23 <tikhon> it's similar to how unit tests don't unambigously specify a function either
08:03:24 <abaw> mm_freak: I have only ascii bytes in my string and want to convert to Domain.
08:03:40 <abaw> mm_freak: there will only be ASCII chars.
08:03:43 <abaw> mm_freak: but
08:03:43 <typoclass> abaw: as a heads-up, Data.ByteString.Char8 will truncate every Char to 8 bits. essentially it will only work for ascii characters, and mess it up if you ever give it unicode
08:03:49 <abaw> mm_freak: the type doe snot check
08:03:58 <quchen> LowPotential: Here's what I'd do: http://lpaste.net/91373
08:04:08 <mm_freak> abaw: your error is likely somewhere else
08:04:30 <mm_freak> `pack` applied to a String works and gives you a ByteString
08:04:38 <applicative> zvrba: I fixed it i think, it's just I assumed prelude didn't export catch, but yours still does
08:04:50 <zvrba> mm
08:04:58 <zvrba> pushed to git?
08:05:04 <zvrba> github?
08:05:14 <applicative> zvrba: sorry, now pushed
08:05:17 <zvrba> ok
08:05:45 <applicative> git commit -m blah somehow seems like the final act
08:06:00 <abaw> mm_freak: yes, you are right. there must be errors somewhere else
08:06:11 <ptek> tikhon, but if we would consider map: there are two properties which should hold - "g f [x] = [f x]" and "g f xs = fold (f) [] xs" (if fold is defined). Then one can call the g anyhow one wants. its always a map
08:06:24 <abaw> mm_freak: let me try to find it out. Thanks very much
08:06:46 <zvrba> applicative: ohoh, but there are multiple files!
08:06:46 <typoclass> abaw: if you can't figure it out, feel free to put your code and the error message on lpaste:
08:06:48 <ptek> tikhon, thus I wonder if there is a way to do this kind of stuff for any function
08:06:50 <typoclass> @where paste
08:06:50 <lambdabot> http://lpaste.net/new/haskell
08:07:07 <tikhon> ptek: if you want to look at theory, read about axiomatic semantics
08:07:11 <tikhon> and Hoare logic
08:07:20 <ptek> tikhon, a-ha
08:07:24 <abaw> typoclass: thanks for the information. Let me try it a little bit hard :P
08:07:30 <tikhon> but QuickCheck is not really the ideal tool for that
08:07:33 <zvrba> applicative: CoreUtils, GetOpt,ImportLib,HugsCodeGen,Main,MarshallAuto
08:07:40 <zvrba> applicative: etc..
08:07:42 <tikhon> moreover, it's somewhat difficult to use in practice, so it has gone out of popularity
08:07:56 <typoclass> abaw: alright :-) good luck
08:10:39 <zvrba> applicative: hmm, I gues I can just import Prelude hiding (catch) at the top of each module..
08:10:57 <zvrba> or maybe it's easier to install new haskell platform.
08:11:26 <ptek> tikhon, thanks! We are using QuickCheck more and more lately, and find that the tests become more concise and test more. What I am struggling with, though, is to find a way to get the properties right...
08:12:11 <tikhon> yeah, I wouldn't recommend trying to be complete—just get enough invariants so that it's easy to write and will probably break if you change your code too much
08:12:19 <tikhon> think of it more like enhanced unit tests than a formal specification
08:13:33 <tikhon> I usually stick to "obvious" properties that are easy to encode, which seems to be the pragmatic compromise
08:14:25 <tikhon> QuickCheck is a partial specification, as are unit tests and the type system
08:14:28 <zvrba> hm
08:14:34 <tikhon> but when you combine all three, you get a surprising amount of guarantees
08:14:43 <tikhon> with much less effort than a full specification
08:15:47 <hpaste> abaw pasted “ByteString” at http://lpaste.net/91374
08:16:18 <abaw> Hi my code works in GHC 7.6 but it does not type check in GHC 7.4
08:16:31 <abaw> and given the errors as shown in lpaste
08:17:49 <hpaste> LowPotential revised “Explicit Tail-Recursion Improvements?”: “Binary-parser solution.” at http://lpaste.net/91371
08:18:15 <LowPotential> New version that I think I'm happy with. Thanks again everyone.
08:18:46 <typoclass> abaw: that's interesting
08:19:25 <abaw> typoclass: I am trying to figure out why it does not type check for > 30 mins
08:19:54 <typoclass> abaw: have you tried Data.ByteString.Lazy.Char8 instead of Data.ByteString.Char8?
08:20:06 <abaw> yes I tried every variant of ByteString
08:21:41 <abaw> typoclass: this what I got if I use :info in ghci: Prelude Network.DNS> :info Domain
08:21:41 <abaw> type Domain =
08:21:41 <abaw>   bytestring-0.9.2.1:Data.ByteString.Internal.ByteString
08:21:41 <abaw>         -- Defined in `dns-0.3.6:Network.DNS.Internal'
08:21:46 <abaw>  
08:23:44 <zzing> I have imported Graphics.Rendering.OpenGL.Raw.Core31.Types and I am using GLint. I get a complaint about the constructor not being in scope. I notice in the docs GLint is defined as type GLint = CInt. Is there a reason why this might not be behaving for me that I am just unaware?
08:23:56 <byorgey> abaw: perhaps Network.DNS is compiled against a different version of bytestring than the one you are using
08:23:58 <typoclass> abaw: maybe a version thing. check if "ghc-pkg list" for your ghc 7.4 reports bytestring-0.9
08:25:09 <abaw> byorgev: how do I check that?
08:25:52 <abaw> typoclass: there are two bytestring, how could this happen?
08:26:13 <abaw>     bytestring-0.9.2.1 and bytestring-0.10.0.2
08:26:28 <byorgey> abaw: it happens because some packages you installed required different versions of bytestring, so both versions got installed
08:26:50 <byorgey> there is nothing inherently bad about having multiple versions of a package installed, but it can lead to problems like this
08:27:40 <abaw> byorgey: O.K. so I definitely need something like cabal-dev to prevent this kind of thing, right?
08:27:51 <donri> it is particularly bad with core packages like bytestring IME
08:28:06 <zzing> In type X = Y   does X become both a type constructor and data constructor?
08:28:22 <donri> zzing: 'type' is purely type level
08:28:52 <zzing> donri, so does that mean it is replaced by Y and then analyzed?
08:29:30 <donri> i think that depends on LiberalTypeSynonyms, in what order things are done
08:29:42 <byorgey> abaw: cabal-dev or hsenv will certainly help.
08:30:39 <abaw> byorgey: Thanks, I will try it. Learned a lesson from this.
08:33:47 <augur> so edsko's talk highlights the impurity of IO and laziness when mixed
08:34:32 <augur> is it possible to introduce some kind of type-level laziness and evaluation strategy indicators, that can restore purity, by making manifest the various properties involved?
08:34:37 <zzing> donri, can you suggest a place I can read more about the issues surrounding 'type' so that I might understand what I am being hit with?
08:35:33 <Cale> augur: hmm, well, which kind of impurity are you referring to?
08:35:35 <donri> zzing: i don't know what you're being hit with. 'type' just makes an alias
08:35:50 <Cale> (I'm not sure I've seen the talk you're referring to)
08:36:03 <augur> Cale: edsko's example with unsafeInterleaveIO and evaluation order leading to opacity
08:36:09 <augur> http://skillsmatter.com/podcast/home/lazy-io-and-alternatives-in-haskell/mh-8133
08:36:41 <edsko> augur: actually there is quite a bit of research into type system extensions that attempt to talk about strict evaluation (Clean has some support for it) but I don't think people have found a compositional way to do it yet. also, I'm not convinced that it will really solve the problem (though it might indeed make it somewhat more tractible)
08:36:52 <Cale> Well, unsafeInterleaveIO *does* let you observe evaluation order, though things built up in terms of it perhaps don't.
08:37:07 <zzing> I think I might have found my issue. I am doing this; (GLint logsize) <- infoLogLength shader    which used to work, that is why it is talking about a data constructor
08:37:48 <zzing> fixed, now that I understand what is going on
08:38:09 <augur> Cale: right, that's what edsko points out. what i was thinking was maybe there could be some type-level thing that makes it so that there's no longer any opacity. like an applicative order monad or who knows.
08:38:13 <augur> edsko: oh?
08:39:04 <Cale> augur: Well, lazy IO in the sense of using unsafeInterleaveIO to get String values which read from things on demand is basically a convenient lie. If you want to explicitly order things, that's what IO actions give you.
08:39:36 <augur> a convenient lie but can we make it a truth!
08:39:44 <Cale> Well, I would say no.
08:40:03 <zzing> These things that are using type used to use newtype
08:41:35 <edsko> augur: you could have a look at http://www.cl.cam.ac.uk/~mb566/papers/tacc-hs09.pdf for instance
08:41:48 <Cale> Fundamentally, the contents of a file on disk over time are not a String (and not just because of encoding issues). You could say they're a String at any given point in time, but if we defer that, any number of funny things can happen. You can get halfway through evaluating and have the file change out from under you.
08:42:09 <edsko> and of course one might consider Clean's uniqueness types to be a way to address the problem through a type system too, albeit in quite a different manner
08:42:13 <augur> ill give it a look
08:42:42 <Cale> augur: Are you familiar with any of the iteratee libraries though?
08:42:48 <Cale> (e.g. pipes)
08:42:50 <augur> Cale: nup
08:42:53 <Cale> oh, okay
08:43:00 <Cale> Well, that might satisfy you well enough.
08:43:06 <augur> but edko uses pipes in the talk from what ive seen so ill get a bit of introduction :p
08:44:08 <Cale> There was a talk recently which gave an in-depth discussion of the construction of the pipes library, in small steps.
08:44:24 <Cale> I'll see if I can find the url
08:44:29 <edsko> Cale: yes, mine :)
08:44:34 <edsko> I think that's the talk that augur is talking about
08:44:49 <augur> Cale: haha. :D
08:45:14 <Cale> ah, right, yes, it was yours :)
08:46:10 <haskellelephant> help
08:46:17 <haskellelephant> exit
08:46:21 <Cale> haha
08:46:49 <Cale> Anyway, yeah, what edsko does there is explain how to build a library which does essentially encode all the extra information about what's going on.
08:47:19 <augur> Cale: well yes, i was hoping for a more principled type-level thing tho. im a big fan of pushing things into the type system
08:47:47 <Cale> Well, it does effectively put work into the type system.
08:48:20 <augur> eh.. but it doesnt put GHC's evaluation order into the type system
08:48:39 <augur> i wonder if thats even possible without the nasty sort of interaction that logicians tend to want to avoid.. hmm
08:48:46 <Cale> Right, and making GHC's evaluation order irrelevant is important.
08:50:44 <augur> hm
08:52:11 <Cale> At least, when the goal is to be able to guarantee certain things about resource usage, leaving those things in the hands of the garbage collector and evaluation order are what gets us into the messes which the iteratee libraries are trying to solve.
08:52:23 <zzing> @src when
08:52:23 <lambdabot> when p s = if p then s else return ()
08:53:00 <Cale> Personally, I think the problem is made a good deal worse than it actually should be by stupid OS constraints, but of course you kind of have to live with that.
08:53:25 <Cale> (Specifically, the draconian constraints on the number of open filehandles seem really silly to me.)
08:54:13 <augur> edsko: you should be in blah!
08:55:21 <edsko> augur: I should be what?
08:55:28 <augur> #haskell-blah
08:55:53 <edsko> augur: oh. why?
08:55:59 <Cale> Nobody should really be in -blah. There's too much inappropriately on-topic discussion that goes on in there. (i.e. stuff which should be in #haskell or ##categorytheory or ##hott or somewhere else)
08:56:13 <augur> because i cant ask you off-topic questions here without being off-topic!
08:56:43 <edsko> augur: feel free to ask me questions directly
08:56:55 <typoclass> cale: true. i'll do my part to fix it. so here is a cat video http://www.youtube.com/watch?v=NKXgun-xqfE
08:57:02 <tikhon> why is it ##hott rather than #hott?
08:57:21 <Cale> Because the ghost of lilo haunts us to this day.
08:57:37 <typoclass> tikhon: it's some weird distinction that freenode makes. in my opinion it's largely meaningless
08:57:38 <navaati> tikhon: unofficial chan
08:57:58 <tikhon> ah
08:58:25 <tikhon> that seems esepcially odd for something like ##categorytheory—what would an "official" category theory channel be?
08:58:36 <zzing> @src <$>
08:58:36 <lambdabot> f <$> a = fmap f a
08:58:57 <Cale> tikhon: Yeah, it's stupid and arbitrary.
08:59:11 <Cale> and I don't know whether anyone's even enforcing it anymore
08:59:12 * hackagebot ztail 1.1 - Multi-file, colored, filtered log tailer.  http://hackage.haskell.org/package/ztail-1.1 (DylanSimon)
09:00:26 <augur> hm
09:00:29 <augur> also i wonder
09:01:04 <augur> could monad brackets be used to let use simulate "real" IO, "real" state, etc.
09:01:25 <n-dolio> It doesn't get enforced actively, for the most part.
09:01:50 <n-dolio> But someone officially from the organization can kick you out of an official channel.
09:02:42 <typoclass> n-dolio: ok, but is that really different from saying "some people are ops"?
09:02:51 <n-dolio> Yes.
09:03:20 <elliott> haskell.org could overthrow #haskell and install their own ops if they wanted.
09:03:26 <n-dolio> If you're not officially from the homotopy type theory organization, someone who is can get your founder status of the #hott channel revoked.
09:03:36 <Tinned_Tuna> elliott: oo, violent revolution?
09:04:13 * hackagebot fixed-storable-array 0.2.0.0 - Fixed-size wrapper for StorableArrays, with its own  Storable instance  http://hackage.haskell.org/package/fixed-storable-array-0.2.0.0 (CarlHowells)
09:04:59 <kayloos> Using the `local' function from Control.Monad.Reader, how do you implement failure? The function given to `local' cannot use `fail' or any other method of expressing error, so how do you do it?
09:05:22 <Cale> kayloos: You... don't?
09:05:56 <merijn> kayloos: Why are you wanting to express failure in the Reader monad?
09:06:07 <typoclass> kayloos: could you tell us what you are planning?
09:06:09 <merijn> kayloos: also, FYI, the use of "fail" is awful and grounds for a whipping
09:06:17 <Cale> kayloos: local is a way to express a locally scoped modification to the environment.
09:06:47 <kayloos> Cale, merijn: I want to add another variable key to the reader environment (list), and if it's already in the list, I want to throw an error.
09:07:14 <Cale> kayloos: Yeah, you'll have to handle the error separately by testing beforehand.
09:07:51 <applicative> zvrba: sorry, you can import Prelude hiding (catch) or import qualified Control.Exception as Exc and then qualify the uses of 'Exc.catch' and 'Exc.SomeException'
09:07:57 <merijn> Or use a combination of StateT and MaybeT?
09:07:58 <applicative> or various things
09:08:55 <kayloos> Cale, merijn: It seemed like a natural approach to have an addKey function that returns an error if there is a duplicate, and returns the modified list if everything's cool
09:09:12 <Cale> That's not to say you couldn't build something similar in nature to local but which does produce such an error, but just that since a reader monad in general has no mechanism for exceptions, local provides no facility for doing that.
09:09:23 <Cale> It just lets you apply a function to the environment locally, that's all.
09:09:39 <merijn> kayloos: Are you sure you want Reader if you want to update it?
09:09:48 <applicative> what's this? 'there's a massive gap between 'average' and 'expert' Haskeller blah blah ' ?
09:09:48 <merijn> kayloos: That sounds a lot more like State to me
09:10:03 <kayloos> So it's a constraint based on my choice of type class?
09:10:04 <Cale> merijn: Reader is actually really good when you have something like an interpreter for a pure language.
09:10:06 * applicative affirms that all Haskellers are 'above average'
09:10:10 <Cale> and you need locally scoped bindings
09:10:14 <merijn> applicative: I think it's more that he's confusing expert and average :)
09:10:36 <merijn> applicative: Also, there's nothing that prevents most haskellers from being above average
09:11:02 <kayloos> merijn: I read the description of the Reader type class and it seemed like a good fit: .. which can read values from a shared environment, pass values from function to function, and execute sub-computations in a modified environment ..
09:11:03 <applicative> merijn: what is he confusing
09:11:04 <Cale> I don't think there are any real gaps between Haskellers if you consider us as a collection.
09:11:22 <Cale> (probably only really small ones :)
09:11:31 <joelteon> yeah, we don't do the hoverhand
09:11:35 <applicative> we arent so many as to constitute a continuum
09:11:47 <merijn> kayloos: It's hard to say how appropriate Reader is without more details about what you're doing
09:12:00 <merijn> Anyhoo...
09:12:07 <merijn> paper deadline tonight, back to writing
09:12:33 <Cale> kayloos: There's no exceptions though.
09:13:01 <kayloos> OK, merijn, thanks for the help, have fun making the deadline :)
09:13:19 <kayloos> Cale: what do you mean?
09:13:44 <Cale> kayloos: Reader doesn't give you any way to throw an exception.
09:15:05 <kayloos> Cale: I know, but I use ReaderT in conjunction with ErrorT, so I can throw errors. This is the type of my computation type class: type Comp a = ReaderT CompEnv (ErrorT String IO) a
09:16:17 <Cale> Ah, okay, so you could easily just lift (throwError "Binding already in environment")
09:16:29 <Cale> (though catching errors will be awkward)
09:16:43 <Cale> er, no it won't because of the lifting instance, right.
09:16:59 <kayloos> Cale: It's not a problem, since I actually do not want the error to be catched.
09:17:04 <Cale> (You don't even have to lift there, because the whole monad will be an instance of MonadError)
09:18:32 <kayloos> Cale: I'm curious, you don't happen to have an example of how to use `local' properly laying around that I could take a peek at, do you?
09:19:22 <kayloos> My problem really is understanding the type, local :: (r -> r) -> m a -> m a
09:19:30 <Cale> So, you can write something like  withBinding k v x = do r <- asks (lookupEnv k); case r of Nothing -> local (insertEnv k v) x; Just u -> throwError ("Binding for " ++ show k ++ " already in environment")
09:20:16 <Cale> You give local a function to apply to the environment, and you give it an action to be executed in the modified environment
09:20:37 <Cale> and it gives you an action which locally modifies its environment in that way when executed
09:21:00 <Cale> If you want, you can imagine the case where m a = r -> a
09:21:23 <Cale> and then local :: (r -> r) -> (r -> a) -> (r -> a) will be implemented by function composition
09:21:55 <Cale> (This is what happens for the MonadReader instance for functions)
09:22:29 <kayloos> Cale: what does that mean? The function you apply to the environment alters the list? What is this monad "action" that should be executed?
09:23:15 <Cale> > (do x <- id; y <- reverse; return (x,y)) "hello"
09:23:16 <lambdabot>   ("hello","olleh")
09:24:00 <Cale> > let foo = do x <- id; y <- reverse; return (x,y) in (do (x,y) <- foo; (x',y') <- local (map toUpper) foo; return (x,y,x',y')) "hello"
09:24:01 <lambdabot>   ("hello","olleh","HELLO","OLLEH")
09:25:20 <kayloos> that is an amazing line of code
09:25:24 <kayloos> gimmie a sec to digest
09:25:31 <augur> edsko: man, that pipe example that requests three numbers is confusing :(
09:26:01 <edsko> augur: I would suggest to play with the code
09:26:04 <Cale> kayloos: If you're not already familiar with the function monad (which is the same as Reader, just unwrapped), then it might be good to have a look at that first :)
09:26:05 <edsko> no better way to understand pipes
09:26:18 <augur> edsko: oh im sure. im just saying given the way its written, vs. what it does
09:26:38 <ClaudiusMaximus> hi.  any implementations of graph colouring algorithms laying around anywhere?  i did look at fgl but the documentation is sparse so i might have missed one...
09:27:24 <ClaudiusMaximus> my graph is planar and small (<50 nodes, <10 edges per node)
09:27:57 <Cale> ClaudiusMaximus: I know I've implemented graph colouring before as part of a register allocator, but it was so long ago, I'm pretty sure I don't have that code anymore.
09:28:18 <Cale> (it was over a decade ago...)
09:28:46 <applicative> augur: where is this example?
09:28:53 <applicative> augur: of pipes code
09:28:56 <augur> http://skillsmatter.com/podcast/home/lazy-io-and-alternatives-in-haskell/mh-8133
09:29:20 <applicative> ah thanks
09:29:39 <Cale> ClaudiusMaximus: You could perhaps iteratively use indep...
09:31:43 <ClaudiusMaximus> Cale: thanks, what does it do?  (what is a maximum independent node set?)
09:31:56 <applicative> edsko: i guess everyone will have asked, are there slides somewhere?
09:32:22 <Cale> It gets you a maximal set of nodes which are not adjacent to each other.
09:32:37 <Cale> i.e. you could colour all those nodes the same colour
09:32:40 <ClaudiusMaximus> Cale: aha, sounds good
09:33:06 <Cale> It's a rather greedy strategy for getting a colouring
09:33:27 <Cale> and I don't know how efficient that'll be
09:33:32 <Cale> but it should at least work
09:33:45 <edsko> applicative, augur: slides and code samples are available at the well-typed blog http://www.well-typed.com/blog/79
09:34:33 <applicative> oh, thanks edsko
09:35:04 <ClaudiusMaximus> Cale: true, but efficiency isn't that much of a concern at the moment (at least, not now that i optimized (deidioted) my algorithms to prune during search instead of filtering afterwards)
09:35:31 <ClaudiusMaximus> Cale: will let you know how it goes
09:40:30 <monochrom> independent set is another hard problem... :)
09:44:14 <yitz> edsko: having looked carefully at both pipes and conduit, how do they compare?
09:44:59 <typoclass> @remember ClaudiusMaximus now that i optimized (deidioted) my algorithms
09:44:59 <lambdabot> It is stored.
09:45:04 <edsko> yitz: these days they are very similar. conduit I think breaks stuff because of the way it deals with leftovers, but it is easier to understand because it's less abstract
09:45:45 <edsko> yitz: and pipes is more generic, pipe transformers and the like, although that will change again in pipes 4 I think
09:45:51 <yitz> edsko: breaks stuff? that's one of the claimed advantages of conduit.
09:47:17 <applicative> pipes 4 will use a concrete type, and use regular monad transformers; i guess that's less generic
09:47:52 <applicative> but who knows it seems to have changed 40 times in the last few weeks ...
09:49:18 <edsko> yitz: the way it deals with leftovers breaks the laws
09:49:35 <edsko> for instance, it's not true that if you compose a pipe with the identity pipe it is the same pipe as the original pipe
09:49:50 <yitz> edsko: that is a long-running argument between snoyberg and Tekmo.
09:50:40 <yitz> edsko: snoyberg claims that if you use conduits in straightforward way as documented, it does follow the laws.
09:50:49 <typoclass> edsko: does breaking the laws translate to breaking a lot of code in practice? (i know next to nothing about conduit/pipes)
09:50:54 <scshunt> no
09:50:59 <scshunt> in practice you ignore it
09:51:11 * edsko is not convinced that's true
09:51:29 <edsko> I think if those laws break in ways that are unexpected you will eventually end up with bugs in your code
09:51:46 <sclv_> unexpected features in your code you mean!
09:51:47 <yitz> edsko: and that it's not worth it to make it harder to deal with leftovers just to make it impossible for people doing crazy things to break the laws
09:52:37 <scshunt> http://www.yesodweb.com/blog/2012/05/response-conduit-bugs
09:52:50 * edsko declines to get involved in that discussion :)
09:53:42 <edwardk> note: you can come up with a formulation where you can't break the laws and can have leftovers so long as you just indicate how much you have consumed rather than feed back the remaining input
09:53:49 <edwardk> this prevents pushback and fixes the laws
09:54:17 <edwardk> the cost is that you have to 'drop' the prefix twice
09:54:49 * elliott thinks the author of conduit is not an unbiased source on whether conduit's weaker laws pose a problem or not
09:55:21 * applicative notes that edsko our unbiased source has already refused to take sides
09:55:24 <scshunt> given that he's also one of the primary users of the library, it stands to reason that he at least has some practical experience
09:55:48 <edsko> I would say it's generally worth working hard to have laws
09:55:58 <edsko> that's what makes Haskell beautiful I think
09:56:08 <edsko> insistence on things done 'lawfullly'
09:56:14 <edsko> that's as far as I'll go :)
09:56:16 <elliott> I'm sure Lerdorf doesn't find PHP's alleged flaws a problem in practice either. (not a statement on the quality of conduit: certainly it is indeed possible that the weaker laws do not pose a problem in practice.)
09:56:22 <scshunt> (note that Conduit has changed significantly since the blog post I linked; version 1 was a fairly substantial rewrite)
09:56:32 <augur> any interesting applications of (delimited?) continuations outside of CS?
09:56:36 <FreeFull> What laws does PHP have?
09:56:37 <yitz> scshunt: there are many users of the library nowadays. it's pretty widespread in commercial yesod shops, of which there are more and more nowadays.
09:56:47 <scshunt> elliott: he does, actually. He's apologized for it.
09:56:59 <scshunt> yitz: right, and he develops yesod
09:57:01 <zomg> FreeFull: none and it shows. -- zomg, 12 year php veteran
09:57:09 <zomg> lol
09:57:13 <augur> or, i should say, outside of PLT continuations, i guess
09:57:26 <applicative> ha, zomg++
09:57:29 <FreeFull> zomg: That's what I was thinking =P
09:57:35 <yitz> scshunt: actually other people do a lot of the work now. he's still on the team though.
09:57:43 <scshunt> ah, ok
09:57:57 <haasn> zomg: PHP does actually have a single law: “Nothing must make sense”
09:57:58 * geekosaur thought the primary law of php was to do it wrong
09:58:02 <edwardk> zomg the scars on your psyche must be intense ;)
09:58:02 <FreeFull> I think the only languages where you'd talk about laws are the strongly-typed functional languages
09:58:03 <geekosaur> heh
09:58:07 <zomg> haasn: possibly =)
09:58:28 <typoclass> FreeFull: i guess you could say, php has a lot of laws, but they're all adhoc, implicit, undocumented, and changing. basically you have to be an expert in the implementation details of everything. that's what makes it so hard
09:58:49 <FreeFull> typoclass: Or you could not write PHP
09:58:49 <zomg> edwardk: haha, it's mostly just caused by people who misuse it and not because it's possible to misuse it ;)
09:58:51 <b-rye> so, just like modern law
09:59:21 * hackagebot ratio-int 0.1 - Fast specialisation of Data.Ratio for Int.  http://hackage.haskell.org/package/ratio-int-0.1 (RaphaelJavaux)
09:59:24 <typoclass> FreeFull: i'm not :-) and i never have. i'm just saying there's value in trying to make your laws explicit and documented
09:59:26 <yitz> edsko: michael agrees with that in his post and claims that the laws are indeed satified and that Tekmo's claims are wrong.
09:59:30 <Twey> edwardk: Why does Void have a Semigroup instance (specifically)?
09:59:38 <edwardk> i like laws because i'm lazy. when i was younger i used to try to think through everything using all the particulars of every benefit offered by my particular choice of implementation. now i'm lazier i like to know that something is correct across a whole host of possible implementations, and i can know that if i reason just with the laws that all such valid implementations are correct
09:59:47 <edwardk> Twey: because it forms a semigroup ;)
09:59:48 <FreeFull> I wonder if PHP is the exact opposite of Haskell
09:59:49 <sclv_> Twey: is it a valid instance? then because it can!
09:59:57 <haasn> sclv_: it is
09:59:59 <zomg> And yeah in practice there are laws in PHP just like in all languages, eg. you indent like this, you use white space like that, KISS, DRY, all that
10:00:01 * edsko agrees with edwardk 
10:00:02 <yitz> edsko: anyway, that's a very old post. both pipes and conduit have changed significantly since then. i thought maybe you were up on the current situation.
10:00:10 <sclv_> remember things grow upwards
10:00:11 <tdammers> edwardk: that sounded eerily familiar
10:00:15 <sclv_> so like you have compound instances
10:00:18 <edsko> yitz: I have a counterexample to the identity law in conduit in my code snippets for the talk
10:00:19 <haasn> sclv_: it's vacuously valid :)
10:00:22 <Twey> edwardk: But not in an interesting sense :þ
10:00:25 <FreeFull> zomg: Those aren't laws though
10:00:39 <FreeFull> Well, at least not KISS and DRY
10:00:39 <sclv_> and if all yr prim types have the raw instances they can, then the fancier types you build on them can too
10:00:40 <edwardk> Twey: depends. i've actually used that instance in other places
10:00:41 <zomg> FreeFull: well if you let me be the guy in charge they are laws ;>
10:00:42 <FreeFull> Those are more like gentle suggestions
10:00:51 <edsko> yitz: yes, the situation *is* much better now but leftovers still mess things up
10:01:02 <FreeFull> At least, considering the average person who'll write PHP
10:01:06 <edwardk> Twey: omitting it causes knock on loss of functionality elsewhere
10:01:07 <edsko> note that the treatment of leftovers in pipes isn't completely satisfactory either
10:01:15 <yitz> edsko: does it follow the conduit laws, as stated in the docs/on the blog?
10:01:25 <Twey> edwardk: Ah, okay
10:01:52 <edsko> yitz: oh, if Michael states some laws, I'd be quite confident they hold. I'm just saying that basic laws that you'd expect to hold, don't
10:02:05 <edsko> don't get me wrong: I think both pipes and conduit are great
10:02:21 <edsko> I think think it's a pity that the treatment of leftovers messes things up
10:02:43 <ocharles> edsko: pipes 4 has yet another new approach to leftovers btw :)
10:02:47 <edsko> but as I said, the treatment in pipes is not great either. I don't think we have found the right abstraction yet
10:02:48 <yitz> edsko: leftovers are very important in practical uses of io libraries in the real world.
10:02:54 <ocharles> edsko: I forgot to email you after your talk, I forgot about that
10:03:10 <ocharles>  https://groups.google.com/forum/#!forum/haskell-pipes has a lot of very interesting discussion on the new approaches
10:03:11 <scshunt> dealing with leftovers is a serious practical problem
10:03:17 <edsko> yes, but "very important for practical uses" should not mean, in my opinion, to violate nice laws
10:03:20 <scshunt> not just a "what laws does it violate" problem
10:03:40 <edsko> if we go down that path we end up with F# rather than haskell :)
10:03:43 <yitz> edsko: they are not laws about conduit. they are laws that your code must follow when you use conduit. the monad laws can be derived from them.
10:03:47 * Cale just ate some leftovers. Mmmm... Indian food.
10:03:52 <edsko> :-D
10:04:36 <yitz> edsko: but that's not the claim
10:04:39 <sclv_> Cale: agreed. the best tool i have for handling leftovers is tupperware
10:04:40 <typoclass> cale: that is lawless, but practical
10:04:41 <haasn> Cale: straight out of the keyboard?
10:05:21 <edsko> yitz: the example is very simple. it's in UsingPkgConduit.hs in my code
10:05:30 <sclv_> so when a library hangs on to leftovers too long, do they get moldy?
10:05:39 * edsko is outta here
10:06:05 <yitz> sclv_: depends which io library you're using ;)
10:17:40 <yitz> edsko's example claiming to show that conduit violates the identity law is clearly invalid conduit code
10:18:25 <typoclass> yitz: you mean it doesn't typecheck?
10:19:05 <yitz> no. it uses leftover without first consuming input. leftover is not allowed to be used that way.
10:19:13 <typoclass> ah i see
10:19:57 <applicative> it's pretty straightforward, it is a little freaky to call it idPipe ...
10:20:48 <applicative> I see and this is after the 'interpreter' is applied via $$
10:21:16 <ClaudiusMaximus> Cale: iterated indep works fairly well (~1.5% of my graphs get 5 colours instead of theoretical minimum 4) and acceptably fast (adds about 30 seconds to the previously 10min runtime;  but...
10:21:40 <yitz> i'm sure there's some way to construct types in a way that would prevent that statically, but it would be a huge mess. just use the library as designed; it's not hard.
10:21:40 <ClaudiusMaximus> Cale: ...i realized that it's not quite what i wanted, so i will have to code up my own colouring algorithm anyway
10:21:58 <applicative> so it isnt like the way Pipes 4 or 'ProxyFast' Breaks the Laws
10:22:16 <yitz> applicative: i don't know
10:22:33 <applicative> yitz, yes of course, I'm wouldn't attack the conduit approach
10:22:39 <applicative> I wouldnt
10:23:35 <yitz> anyway, if there really is some reason to use one over the other, i would think about changing. so it's important for me to know.
10:23:36 <applicative> yitz the internal implementation of Pipes/Proxies doesnt get idpipe right either, it's like operational i guess, but the run function is supposed to iron all this out
10:23:39 <ClaudiusMaximus> Cale: (what i want is "given a graph with a 5-colouring, construct a different 5-colouring such that each of the original colours has a fairly flat distribution of the new colours)
10:24:56 <applicative> so that run $ blah blah idpipe blah blah = run $ blah blah blah blah , even if blah blah idpipe blah blah /= blah blah blah blah
10:24:59 <applicative> so to say
10:26:05 <yitz> applicative: any usable io library (at least currently) can be expected to do stuff internally that violates laws. i very much doubt it's possible otherwise.
10:28:12 <applicative> yitz, yes I was just reflecting on what could be left of pipes v. conduits, chapter XLIX, "Who breaks the laws?" in the light of recent implementation of pipes (the library)
10:28:42 <applicative> the treatment of leftovers, however reasonable, does still make things different.
10:29:03 <applicative> I'm thinking this anyway, not sure
10:29:08 <typoclass> hm, is that chapter 44?
10:29:15 <applicative> 49
10:29:28 <applicative> it did seem to go on and on that
10:29:29 <typoclass> oh right of course :-)
10:29:29 <c_wraith> 44 would be XLIV
10:30:07 <typoclass> in my system, X stands for 10 and also for 5, depending on factors yet to be defined
10:30:18 <yitz> @hackage roman-numerals
10:30:18 <lambdabot> http://hackage.haskell.org/package/roman-numerals
10:33:00 <typoclass> what's this? convertTo :: Monoid s => Ord n => Num n => NumeralConfig s n -> n -> s. same as "(Monoid s, Ord n, ...) => ..."?
10:33:15 <byorgey> yes
10:34:01 <joelteon> why do people write constraints like that
10:34:14 <byorgey> that probably wins the prize for "valid Haskell2010 syntax which is least likely to be recognized as such by most Haskellers"
10:34:37 <sludo> i've always liked it
10:35:00 <byorgey> I must confess it does have a certain consistency and elegance to it.
10:35:04 <typoclass> (i'm wondering because the same module a few lines later uses the common style)
10:35:46 <byorgey> perhaps they were using a simple script to automatically add constraints based on error messages
10:35:51 <typoclass> can i please have my thing where adding a constraint does not mean changing the start of the line? "f :: a -> b -> c <= (Ord a, Num b)" etc.
10:36:12 <byorgey> ugh, what
10:36:40 <typoclass> byorgey: just kidding :-) it's on my WANT list between "pony" and "maserati"
10:37:16 * haasn .oO(  (<=) :: * -> Constraint -> *  )
10:38:02 <typoclass> haasn: muahaha you're giving me ideas
10:38:15 <byorgey> well, it's on my DO NOT WANT list between "cockroach" and "motorcycle driving over my leg"
10:38:27 <typoclass> :-D
10:38:30 <elliott> weird, "motorcycle driving over byorgey's leg" is on my do not want list too.
10:38:43 <c_wraith> those both sound towards the more minor end of the do not want spectrum
10:39:05 <byorgey> c_wraith: indeed
10:39:09 <sludo> you haven't seen byorgey's cockroaches
10:39:10 <c_wraith> I mean where, "rabid chihuahua" on the list?
10:39:15 <c_wraith> *where's
10:39:31 <byorgey> typoclass: I presume you would then also want  a -> b -> c <- d  to be an abbreviation for  d -> a -> b -> c  ?
10:39:38 <elliott> interestingly enough, the only things less wanted on my list are "universe explodes" and "motorcycle drives over byorgey's leg -- twice".
10:40:14 <typoclass> elliott: well, the universe does explode. it's in the middle of doing it and always has been
10:40:28 <typoclass> byorgey: no that is clearly silly
10:40:35 <applicative> byorgey: can't you have that abbreviation, or rather synonym?
10:40:59 <haasn> byorgey: no, that would obviously be a -> (b, d) -> c
10:41:01 <elliott> typoclass: well, now that you've told me that I'll go drive a motorcycle over byorgey's leg.
10:41:14 <byorgey> typoclass: your personal line between "silly" and "not silly" is in a very strange place
10:41:17 <applicative> no TypeOperators wont allow it
10:42:21 <applicative> hm, well haasn can have a -> b -> c <-- d
10:42:59 <applicative> which perhaps looks better as a --> b --> c <-- d
10:43:31 <byorgey> is it possible to give --> the right precedence to make that work?
10:43:43 <byorgey> it has to scope over the whole  a -> b -> c
10:43:47 <byorgey> I mean <-- of course
10:43:52 <applicative> that's what I thought let me try
10:44:17 <haasn> fmap :: (a --> b) --> f b <-- f a <= Functor f
10:45:01 <applicative> darn no, byorgey -> has precedence 0
10:45:17 <tikhon> what if you define --> as well?
10:45:18 <applicative> all the more reason to chuck -> in favor of --> at the same time
10:45:19 <haasn> easy
10:45:22 <haasn> just do what tikhon said
10:45:24 <byorgey> right, I see
10:45:51 <tikhon> hmm
10:45:59 <tikhon> what about defining → and ←?
10:46:12 <tikhon> prettier
10:46:25 <tikhon> but not compatible with -XUnicodeSyntax, I guess
10:46:38 * byorgey exit stage right, before it gets too ugly
10:46:46 <haasn> who needs -XUnicodeSyntax when you have unicode syntax
10:46:50 <tikhon> No, no, Unicode makes it *prettier*
10:46:56 <joelteon> I do not like unicodesyntax
10:47:00 <joelteon> just use conceal or something
10:47:08 <quchen> Hardcoded colors would also make Haskell code prettier.
10:47:12 <quchen> Maybe we should propose that.
10:47:25 <tikhon> hey, I've actually used a lanugage with that feature (colorForth) :P
10:47:32 <applicative> d :: Int --> Bool <-- Int;  d = (<)
10:47:34 <Format> > getNick
10:47:35 <lambdabot>   Not in scope: `getNick'
10:47:35 <typoclass> anyway, in (C) => x -> y, i've always thought of x -> y as the primary part that specifies the basic structure, and of C as a secondary restriction or qualification. i dunno, it just feels more natural on some level. primary first, qualifications later. (yes i know about the implementation detail with passing dictionaries around, but still)
10:47:38 <tikhon> they completely obviated parsing by using colors instead
10:47:39 <haasn> quchen: I eagerly anticipate the wave of upcoming syntax highlighting wars
10:47:57 <applicative> "d :: Int --> Bool <-- Int;  d = (<)" works, but my syntax highligher is cheap
10:48:23 <tikhon> see, we're witnessing progress in language design, right here!
10:48:41 <applicative> it makes sense of course x < y has type Int --> Bool <-- Int
10:48:42 <haasn> tikhon: I'm pretty sure there's at least one language that distinguishes syntax from names by whether or not you bold it
10:48:54 <tikhon> possible
10:48:55 <monochrom> I love colours.
10:49:04 <quchen> They are so easy.
10:49:06 <CaptainK> haasn: who are the main player for the highlight syntax war?  emacs, vim, sublime
10:49:08 <tikhon> I think colorForth has an option like that for colorblind people
10:49:19 * applicative agrees with typoclass the stuff before => is a huge strain when learning; as usual people just forget
10:49:24 <monochrom> I love colours so much, I love just one colour. :)
10:49:26 <byorgey> typoclass: it's a bit more than just an implementation detail.  If you think about it via the curry-howard correspondence, constraints really are just proof arguments
10:49:39 <tikhon> also, if I remember correctly, bold numbers were in hex where normal ones were in decimal
10:50:09 <CaptainK> monochrom: you're just shades of grey!
10:50:30 * haasn .oO(  fmap :: (a -> b) -> f a -> f b, Functor f  )
10:51:00 <applicative>  fmap :: (a -> b) -> f a -> f b (Functor f)
10:51:19 <typoclass> haasn: good idea! but somehow it would need to indicate visually that ", Functor f" applies to the entire line, not just to "f b"
10:51:22 <tikhon> maybe fmap :: (a -> b) -> f a -> f b | Functor f
10:51:24 * applicative downloads haasn 's compiler
10:51:31 <tikhon> like list/set comprehensions
10:51:37 * applicative downloads tikhon 's compiler
10:51:37 <typoclass> so erm, "fmap :: (a -> b) -> f a -> f b :: Functor f"
10:51:58 <haasn> tikhon: yeah, that was the motivation for my idea as well
10:52:10 <haasn> typoclass: no no, that would be kind signatures, silly
10:53:11 <merijn> Isn't pigworker usually talking about the colour of values? :)
10:53:11 <haasn> foo :: a | Num a, Read a -- does seem quite nice, actually
10:53:26 <applicative> stay away from the green slime!
10:53:39 <tikhon> it also fits with the idea that the typeclass is like a predicate over types
10:53:44 <typoclass> haasn: nonono, kinds should have their own thing. ;; or whatever
10:53:49 <haasn> typoclass: too sad!
10:55:52 <haasn> typoclass: kind signatures can be ∷∷
10:56:24 <typoclass> haasn: obviously. sorts will then be ::::::
10:56:41 <haasn> typoclass: they will be two UNICODE DOUBLE DOUBLE COLONs
10:56:52 <Philippa> you don't need kind signatures to use a different separator
10:57:06 <Philippa> they're the same kind of relation: key lesson of Pure Type Systems and the Lambda Cube
10:57:34 * haasn glares innocently at typoclass
10:57:47 <typoclass> Philippa: but but but, i want "fmap :: (a -> b) -> f a -> f b :: Functor f"
10:57:55 <Philippa> byorgey: evidence-passing matters, dictionaries are an implementation detail
10:58:18 <Philippa> (this is why giving evidence its own sort in the first place is a good idea: you get to ask how that sort is implemented!)
11:00:18 <c_wraith> If you make a kind-polymorphic typeclass, will instance selection be based on the kind of the argument as a first pass?
11:01:44 <Philippa> c_wraith: er. More detail? I mean, I'm fairly sure I've managed to use the things without actual type annotations per se
11:01:49 <typoclass> can i constrain the kinds somehow? "f :: (kind whatnots) ==> (constraints) => signature"
11:01:53 <Philippa> but it's been a while since I poked at the kind
11:02:25 <typoclass> (to clarify, i'm still talking about the hypothetical haskell dialect we have been making up)
11:02:51 <c_wraith> Philippa: I'm really wondering if I can write an instance like  instance Foo (a :: Nat) where ... and not have it overlap with instance Foo (Int) where ...
11:03:02 <haasn> c_wraith: you can
11:03:09 <schoppenhauer> http://www.haskell.org/tutorial/arrays.html is something similar available in modern haskell, too? especially, I need arrays I can access recursively inside their definition
11:03:25 <c_wraith> haasn: I wonder what this can do for me...  Thanks! :)
11:04:12 <schoppenhauer> (I am writing stuff that evaluates some sort of RLE encoding, and need quick backbuffer access)
11:04:50 <dmwit> schoppenhauer: Yes, all that stuff is in Data.Array.
11:07:17 <schoppenhauer> dmwit: thx
11:07:26 <schoppenhauer> sorry, forgot to import it
11:09:29 * hackagebot tsparse 0.4.0.0 - Parses U.S. federal Thrift Savings Plan PDF quarterly statements  http://hackage.haskell.org/package/tsparse-0.4.0.0 (OmariNorman)
11:10:27 <hpaste> haasn pasted “Kindable” at http://lpaste.net/91378
11:10:32 <haasn> c_wraith: some weird stuff, apparently ^
11:11:47 <dmwit> Wow, that's a really niche package.
11:12:26 <ReinH> edwardk: hai
11:12:33 <edwardk> yo
11:12:40 <typoclass> dmwit: yeah, but not in a bad way i guess
11:13:12 <dmwit> right
11:14:04 <ReinH> edwardk: I am bothering you in /msg now
11:14:06 <ReinH> :)
11:21:45 <c_wraith> Hmm.  So I can get rid of Nat -> * proxies for my lib if I use polymorphic kinds and lifted tuples.
11:21:48 <c_wraith> This sounds like a win!
11:22:20 <haasn> c_wraith: what lib?
11:22:47 <c_wraith> oh, the thing I've been working on, the StorableArray wrapper with type nats fixing its dimensions
11:23:18 <dmwit> StorableStorableArray?
11:23:31 <c_wraith> pretty much.  That's exactly the point.  It has its own Storable instance.
11:23:53 <haasn> java territory ahead
11:24:04 <c_wraith> It's strictly an FFI tool.
11:24:17 <c_wraith> But it seems like it's got promise for that job.
11:24:22 <jfischoff> haasn: hehe
11:24:33 <Yaniel> http://www.youtube.com/watch?v=Mk3qkQROb_k haasn you asked for this
11:24:43 <dmwit> c_wraith: I think haasn was making fun of my proposed name.
11:25:00 <tikhon> subtle
11:25:15 <c_wraith> dmwit: ah, yes.  I totally missed that. :)
11:25:52 <tomboy64> could someone take a quick look at this code and tell me what newbie mistake i made?
11:25:59 <tomboy64> i want to get away from do notation
11:26:02 <tomboy64> http://bpaste.net/show/119082/
11:26:22 <c_wraith> The crazy part is I have to write instances like  instance Foo ('(a, b) :: (Nat, Nat)).  it's rejected if I leave the ' out on the type, or include it on the kind.
11:26:25 <haasn> tomboy64: does it work?
11:26:29 <tikhon> you can use lpaste.net instead of bpaste.net
11:26:32 <tomboy64> haasn: no.
11:26:32 <c_wraith> I still don't fully understand when the ' is necessary for DataKinds
11:26:47 <tomboy64> tikhon: with wgetpaste?
11:27:03 <tikhon> oh, I don't know about that
11:27:04 <haasn> tomboy64: and uh, line 12 doesn't seem like it fits in there
11:27:10 <tikhon> I actually have an Emacs mode for it :P
11:27:15 <haasn> did you forget a (>>) or something?
11:27:21 <tikhon> lpaste has some nice Haskell-specific features
11:27:39 <tomboy64> haasn: right. line 12 is superfluous.
11:28:02 <haasn> lpaste integration with wgetpaste would be awesome
11:28:22 <haasn> I tend to use wgetpaste but for haskell code I always have to manually open up lpaste.net and paste the code in there :(
11:28:24 <tomboy64> Couldn't match expected type `IO a0' with actual type `[a1]' In the return type of a call of `cM'
11:28:37 <applicative> tomboy64: with >> before putStrLn "Done" main compiles
11:28:43 <Rarrikins> tomboy64: You need to return.
11:28:44 <applicative> then theres a problem with cM
11:28:52 <tikhon> hpaste.el: http://www.haskell.org/haskellwiki/Hpaste.el
11:28:52 <applicative> tomboy64: just forgot >>
11:29:06 <haasn> tomboy64: for starters, add a type signature to ‘cM’
11:29:17 <typoclass> tomboy64: looks fairly tidy! are you aware of the lines and unlines function? they convert between a String and a list of lines (= list of Strings)
11:29:42 <Rarrikins> tomboy64: The left side of the last >>= has to be IO a, but the type of cM isn't IO a.
11:29:55 <Rarrikins> Or the return type of cM
11:31:18 <tikhon> coincidentally, why do we use lpaste instead of hpaste now?
11:31:29 <applicative> > span (/='\n') "hello\nworld"
11:31:30 <lambdabot>   ("hello","\nworld")
11:31:47 <tomboy64> hrrr span was it
11:31:51 <tomboy64> i knew it was there
11:31:51 <dmwit> tikhon: 'SBROKEN
11:31:53 <applicative> tomboy64: ^^^ use something like this instead of drop...  oh yeah
11:31:57 <tomboy64> okay, new try
11:31:58 <tikhon> dmwit: yes
11:31:59 <tikhon> but why?
11:32:16 <dmwit> I think some registrar was being a turd.
11:32:25 <tikhon> ah
11:32:26 <applicative> tomboy64: there's also break,
11:32:27 <tikhon> happens
11:32:46 <applicative> > break (=='\n') "hello\nworld"
11:32:48 <lambdabot>   ("hello","\nworld")
11:32:49 <typoclass> tikhon: chris done (guy who runs hpaste) needed to change something about teh servers or teh dns or some other internet thing
11:32:56 <tikhon> I like the new logo (λ-paste) more
11:33:37 <tikhon> hmm, wouldn't it be possible to register λ-paste.org?
11:33:47 <tikhon> I'm not entirely certain about how special characters work in URLs.
11:34:44 <typoclass> tikhon: many people would have to copy-paste the url, because they couldn't casually type it
11:35:01 <tikhon> yeah
11:35:10 <tikhon> I have a hardline stance about Unicode though :P
11:35:23 <tikhon> but this question is mostly out of curiousity about URLs with weird characters
11:35:39 <djahandarie> typoclass, if only that line of reasoning worked with people who insist on putting unicode in their code...
11:35:45 <Rarrikins> tikhon: I think that you can't combine different scripts like that.
11:36:09 <Yaniel> aren't unicode urls basically allowed these days?
11:36:20 <Yaniel> at least scandinavian letters can be used IIRC
11:37:11 <typoclass> Yaniel: yeah it's been pretty standard for quite some years. but i don't know what special characters are allowed in .org
11:37:22 <Rarrikins> "Countries with officially registered languages will get to go first through a fast-track process. Names for those domains must be composed entirely of the non-Latin characters of that particular language — no mongrel names combining scripts from separate languages will be allowed." http://www.wired.com/business/2009/10/icann-international-scripts/
11:37:42 <Yaniel> hmm
11:37:51 <koala_man> unicode host names are basically just translated to an ascii representation
11:38:11 <typoclass> koala_man: yes, the encoding is known as punycode
11:38:35 <haasn> https://en.wikipedia.org/wiki/Internationalized_domain_name#Internationalizing_Domain_Names_in_Applications
11:39:23 <typoclass> tomboy64: so, your code is downloading that file from project euler, which has lines like "12,34,56", which you're converting to haskell lists?
11:39:29 <tomboy64> typoclass: that is the idea, yeah
11:39:35 <JSisJS> bqwqwq
11:39:49 <applicative> is it possible to use ghc without libgmp nowadays?
11:40:01 <JSisJS> yesno
11:40:12 <c_wraith> yes, if you put some effort into installing it
11:40:25 <c_wraith> Installing ghc, that is
11:40:29 <typoclass> tomboy64: i see :-) to make sense of a program, you often need to see one piece of example input and output
11:40:38 <typoclass> tomboy64: so have you thought about using 'lines'?
11:40:40 <c_wraith> There's an alternate Integer implementation, but it takes work to use it by default
11:40:45 <typoclass> > lines "abc\ndef\nghi"
11:40:46 <lambdabot>   ["abc","def","ghi"]
11:40:52 <applicative> c_wraith: hm
11:41:17 <applicative> c_wraith: I was just wondering if there was an adequate response to real gpl paranoiacs
11:41:25 <tomboy64> typoclass: yes. but for now i just want this particular thing working.
11:41:26 <c_wraith> applicative: you might have to install ghc from source, unless you find it packaged that way
11:41:56 <tomboy64> typoclass: i had the logic properly worked out for another problem, i'm just struggling with converting IO to pure now
11:43:46 <tomboy64> prob0082.hs:10:28:
11:43:48 <tomboy64>     Couldn't match expected type `IO a0' with actual type `[[Int]]'
11:43:56 <tomboy64> http://lpaste.net/91382
11:45:37 <tomboy64> why does getResponseBody eat IO and (for example) lines doesn't?
11:45:44 <tomboy64> :t getResponseBody
11:45:45 <lambdabot> Not in scope: `getResponseBody'
11:46:14 <Chousuke> eat IO?
11:46:17 <Cale> Your problem is likely that (\x -> cM ...) isn't a function that produces an IO action
11:46:31 <Cale> and so it is unsuitable as a right hand parameter to >>= here
11:46:58 <tomboy64> hm
11:47:12 <tomboy64> Chousuke: capable of processing IO
11:47:13 <typoclass> tomboy64: to fix what cale described, try (\x -> return $ cM ...)
11:47:46 <Chousuke> tomboy64: getResponseBody sounds like something that deals with HTTP so it makes sense it'd be in IO
11:48:11 <Cale> It would probably be easier for you to simply use do-notation to start with
11:49:20 <Chousuke> tomboy64: on the other hand, breaking a string into lines is a pure function so it doesn't need to be an IO action.
11:49:56 <tomboy64> Cale: i used to use do notation. i want to use functional notation.
11:50:26 <Cale> tomboy64: In order to translate away do-notation mechanically, you can use these rules:
11:50:30 <Chousuke> tomboy64: if you want to apply a pure function to an IO result, use fmap
11:50:36 <Cale> do { x } = x -- base case
11:50:49 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
11:51:12 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> } -- whenever v is a pattern that can't fail to match
11:52:26 <Cale> do { p <- x ; <stmts> } = let { ok p = do { <stmts> }; ok _ = fail "pattern match failure" } in x >>= ok -- whenever p is a pattern that can fail to match (somewhat uncommon to actually use this)
11:52:32 <typoclass> tomboy64: the difference between do notation and functional notation (as you named it) is purely superficial. you can translate them back and forth with no loss
11:52:50 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
11:52:57 <Cale> and that's all
11:54:13 <Chousuke> tomboy64: assuming getResponseBody returns an IO String, you could do fmap lines getResponseBody
11:55:01 <Chousuke> and by returns I mean is :P
11:57:00 * tomboy64 sighs
11:57:03 <tomboy64> thanks so far guys
11:57:09 <tomboy64> gotta read a bit more about that
11:57:23 <typoclass> tomboy64: you saw my message earlier? the quick fix is to insert "return $"
11:57:34 <tomboy64> typoclass: that works, yes
11:57:41 <typoclass> tomboy64: alright
11:58:05 <tomboy64> typoclass: but i need to do more processing. using $ in between all the time gets cumbersome
11:58:20 <tomboy64> so i will need to make a bigger function chain for that.
11:58:34 <Chousuke> tomboy64: I find that a big part of learning haskell is learning the tools that you can use to make your types match. :P
11:59:00 <Cale> tomboy64: You don't really want to use return here
11:59:03 <Cale> You want to use let
11:59:38 <tomboy64> :) will do after my tea
11:59:43 <hpaste> typoclass annotated “cM fails with IO foo” with “cM fails with IO foo (annotation)” at http://lpaste.net/91382#a91385
12:00:07 <typoclass> tomboy64: here is a rewrite of your version to do notation, for reference
12:00:16 <Cale> (or that)
12:07:57 <hpaste> tdammers revised “Ambiguous type variable”: “Ambiguous type variable” at http://lpaste.net/91387
12:09:19 <tdammers> ^ this gives me "Ambiguous type variable r0' in the expression: resolve c k
12:10:01 <dmwit> Perhaps because the type of "resolves" doesn't fix the "r" part of its constraint.
12:10:11 <byorgey> s/Perhaps//
12:10:18 <tdammers> so how do I fix it?
12:10:21 <dmwit> You may like to turn on FunctionalDependencies and write class Collection p i r c | p i c -> r or similar.
12:10:54 <dmwit> Although I suspect from the other functions in your class that won't be enough, either.
12:11:28 <dmwit> Maybe a given collection c determines p, i, and r?
12:11:38 <dmwit> If so, then class Collection p i r c | c -> p i r might be better.
12:12:05 <tdammers> yes, c determines p i r
12:12:11 <tdammers> to clarify:
12:12:20 <byorgey> in that case class Collection c where  type PrimaryKey c :: * ... etc. might be better =)
12:12:23 <tdammers> c is the collection type, p is the primary key, i is an index, and r is the record type
12:12:43 <tdammers> wait what?
12:12:45 <dmwit> Yes, associated type families are how I would recommend doing it these days.
12:12:48 <tdammers> I can have types inside classes?
12:12:55 <byorgey> yes!
12:12:56 <tdammers> whoa
12:13:01 <dmwit> Well, you can, but it's mostly an illusion. =)
12:13:20 <byorgey> the main thing is that you can have functions on types.
12:13:24 <dmwit> right
12:13:27 <byorgey> called "type families"
12:13:51 <tdammers> I think I need a bit of reading material on this stuff
12:14:17 <dmwit> ?wiki Type families
12:14:17 <lambdabot> http://www.haskell.org/haskellwiki/Type_families
12:14:36 <typoclass> tdammers: the relevant section of the ghc user guide usually gets you 80% of the way there
12:15:26 <byorgey> tdammers: in particular, take a look at http://www.haskell.org/haskellwiki/Type_families#An_associated_type_synonym_example  which is similar to your use case
12:16:00 <dmwit> Type families are not injective. Your first three inscrutable error messages with type families in them will be because you don't understand this rule.
12:16:25 <byorgey> dmwit: =D
12:16:29 <dmwit> =)
12:16:51 <typoclass> @remember dmwit Type families are not injective. Your first three inscrutable error messages with type families in them will be because you don't understand this rule.
12:16:51 <lambdabot> Done.
12:16:54 <c_wraith> Holy crap, haddock spits out some incomprehensible instance summaries: (SingI Nat a, SingI Nat b) => HasBounds ((,) Nat Nat) ((,) Nat Nat a b)
12:17:10 <c_wraith> No part of that is syntactically valid.
12:17:21 <byorgey> c_wraith: yeah, Haddock's pretty-printer needs some TLC
12:17:40 <Cale> Haddock's pretty printer needs to do a lot *less* to the original source
12:17:42 <elliott> c_wraith: some or all of that is ghc's fault
12:17:47 <elliott> it likes inserting kind arguments explicitly with polykinds
12:17:51 <byorgey> c_wraith: the problem there is that it's printing kind arguments
12:17:56 <elliott> it really sucks
12:18:08 <typoclass> we should have a series of those! "your first three inscrutable 'ambiguous something' error messages can be cured by just adding {-# LANGUAGE NoMonomorphismRestriction #-}. just do it, don't think about it."
12:18:08 <elliott> like ok if it was (,) @Nat @Nat or something.
12:18:13 <byorgey> elliott: what? how else would polykinds work?
12:18:21 <byorgey> that's not GHC's "fault".
12:18:22 <elliott> byorgey: I mean in its pretty-printing.
12:18:33 <dmwit> typoclass: hah, fun idea!
12:18:35 <byorgey> ah, true, I agree with you there.
12:18:41 <elliott> byorgey: I think it's just wrong to talk about that type "Foo * Int" when it is actually "Foo Int".
12:18:49 <byorgey> you're right, GHC's pretty-printing with polykinds is screwed up too.
12:18:53 <elliott> and when it becomes "Foo Nat Nat Int 34 7" or whatever, it just gets ridiculous
12:19:13 <dmwit> Well, as pointed out earlier in-channel, "Foo a" is no longer enough information.
12:19:17 <byorgey> but I think GHC's pretty-printing and Haddock's are screwed up independently.
12:19:27 <dmwit> Because "Foo Nat a" and "Foo * a" can be completely separate instances.
12:19:47 <byorgey> yeah, you can actually dispatch on kinds
12:19:51 <c_wraith> dmwit: yes, but it'd be nice if it printed it in a syntactically valid way.
12:20:01 <bennofs> Why doesn't ghc pretty print it as Proxy (a :: * -> *) ?
12:20:07 <dmwit> Foo {- Nat -} a
12:20:09 <c_wraith> Foo (a :: Nat)  and  Foo (a :: *)
12:20:26 <dmwit> c_wraith: Okay, yeah, that would be better.
12:20:30 <elliott> dmwit: I sort of consider that a bug.
12:20:30 <dmwit> Can it always be done?
12:20:49 <dmwit> Maybe "(Foo :: Nat -> Constraint) a" is more obviously complete.
12:20:49 <elliott> dmwit: PolyKinds is fiddly because you get AnyKind being explicitly used or whatever when you actually want something properly polymorphic in the kind.
12:20:55 <elliott> and stuff that I don't quite understand.
12:21:41 <byorgey> anyway, someone is working on syntax for explicit type application this summer, so hopefully things like  Foo @Nat a   will soon be syntactically valid
12:21:50 <byorgey> (yes, I realize that is kind application)
12:24:30 <tomejaguar> I've never used Template Haskell before.  Can I use it to do "import Paths_my_package_name (version)" into my module automatically?
12:24:43 <c_wraith> tomejaguar: nope.  TH can't do imports at all
12:25:01 <tomejaguar> Ah damn.  That would have saved a lot of boilerplate.
12:25:33 <c_wraith> Huh.  My core code didn't change at all when I started using PolyKinds, except for removing a data type.  Everything else is just changing the types (and kinds) of instances.
12:25:48 <sclv_> tomejaguar: maybe you can do it with CPP?
12:26:17 <typoclass> tomejaguar: you need the version number in lots of modules ...?
12:27:06 <geekosaur> import it into one module with a fixed name, re-export from there (so Paths_mumble only needs to be changed once)?
12:27:08 <c_wraith> in theory, I could have even left all the old instances and the one data type I removed, and just added more instances, since they wouldn't have even conflicted.
12:27:29 <geekosaur> won't work for a library unless you restrict further export of course
12:35:11 <merijn> Which library do I wanted to a lifted bracket/exception, etc.
12:36:09 <elliott> @hackage exceptions
12:36:09 <lambdabot> http://hackage.haskell.org/package/exceptions
12:36:24 <tomejaguar> sclv_: thanks i'll check it out
12:36:34 <elliott> merijn: ^
12:36:49 <tomejaguar> typoclass: I need it on one module per project
12:39:35 <tdammers> whee, FunctionalDependencies does the trick
12:39:44 <tdammers> now to understand what that magic does :x
12:39:51 <merijn> elliott: Oh, neat
12:40:09 <merijn> Blah, edwardk isn't here for me to yell at him :\
12:41:00 <merijn> He exposes mask but not uninterruptibleMask ಠ_ಠ
12:42:27 <merijn> Oh well, I guess I'm fine using that in IO for now
12:45:39 <trism> Is there a standard haskell function that will map a sequence of functions to a sequence, say: mapl [f, g, h] (x : xs) = f x : g x : h x : mapl [f, g, h] xs?
12:46:01 <tikhon> you want each function to apply to each value?
12:46:04 <dmwit> :t liftM2 ($)
12:46:04 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
12:46:11 <opqdonut> in the list monad
12:46:23 <yesthisisuser> speaking of applying values.. i am trying to say something in English here but i don't know how: "the value which when applied to function f ..."
12:46:43 <opqdonut> > liftM2 ($) [(*2), (+1), (-1)] [1, 10, 100]
12:46:44 <lambdabot>   No instance for (GHC.Show.Show r0)
12:46:45 <lambdabot>    arising from a use of `M286504117.sho...
12:46:45 <yesthisisuser> wrong channel i know.. but i usually get good answers here ;)
12:46:48 <dmwit> > do { fun <- [f, g, h]; val <- [x, y, z]; return (fun val) }
12:46:49 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:46:49 <lambdabot>    arising from a us...
12:46:56 <dmwit> > do { fun <- [f, g, h]; val <- [x, y, z]; return (fun val) } :: [Expr]
12:46:57 <lambdabot>   [f x,f y,f z,g x,g y,g z,h x,h y,h z]
12:47:00 <tikhon> > [f, g, h] <$> [x, y, z]
12:47:01 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr -> b0'
12:47:01 <lambdabot>         ...
12:47:04 <opqdonut> hehe
12:47:10 <tikhon> > [f, g, h] <*> [x, y, z]
12:47:11 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:47:11 <lambdabot>    arising from a us...
12:47:21 <dmwit> > liftM2 ($) [f, g, h] [x, y, z] :: [Expr]
12:47:22 <lambdabot>   [f x,f y,f z,g x,g y,g z,h x,h y,h z]
12:47:32 <Rarrikins> opqdonut: It's the (-1)
12:47:35 <tikhon> > [f, g, h] `ap` [x, y, z]
12:47:36 <lambdabot>   No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
12:47:36 <lambdabot>    arising from a us...
12:47:39 <tikhon> hmm
12:47:40 <Rarrikins> > liftM2 ($) [id, negate, (*5)] [20..23]
12:47:41 <lambdabot>   [20,21,22,23,-20,-21,-22,-23,100,105,110,115]
12:47:43 <opqdonut> Rarrikins: right, I always forget
12:47:47 <dmwit> tikhon: It's not ap, no matter how you spell ap.
12:48:01 <tikhon> hmm
12:48:05 <opqdonut> :t ap
12:48:06 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:48:09 <opqdonut> :t liftM2 ($)
12:48:10 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
12:48:13 <dmwit> wait
12:48:16 <opqdonut> it is
12:48:18 <tikhon> am I missing something?
12:48:22 <dmwit> Why am I so wrong?
12:48:31 <dmwit> > [f, g, h] <*> [x, y, z] :: [Expr]
12:48:33 <lambdabot>   [f x,f y,f z,g x,g y,g z,h x,h y,h z]
12:48:35 <tikhon> aha
12:48:43 <tikhon> the :: [Expr] might be it
12:48:46 <dmwit> yes
12:49:19 <dmwit> Okay, (<*>) is much nicer than liftM2 ($), and I feel silly.
12:49:38 <trism> excellent, thanks
12:49:51 <int-e> @type ap
12:49:52 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:49:59 <tikhon> :t (<*>)'
12:50:00 <lambdabot>     lexical error in string/character literal at end of input
12:50:01 <tikhon> :t (<*>)
12:50:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:50:11 <tikhon> the same as ap but for Applicative instead of Monad
12:50:16 <tikhon> for historical reasons, and stuff
12:51:07 <elliott> ap is the historical one
12:51:33 <tikhon> it's all before my time :)
12:54:23 * merijn is still waiting until the AMP proposal will finally be a thing
12:54:33 * hackagebot idris 0.9.9 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.9 (EdwinBrady)
12:54:35 <tikhon> AMP?
12:56:02 <supki> Applicative => Monad Proposal proposal
12:56:12 <tikhon> ah
12:56:24 <tikhon> I had actually guessed the "A" and "M", but not the "P"
12:56:30 <tikhon> I would have assumed FAM instead
12:56:33 <tikhon> but I am an idealist
12:56:41 <elliott> Functor => Applicative already exists...
12:56:51 <tikhon> oh, I guess that's true
12:57:50 <renny> Hello
12:58:29 <hpaste> renny pasted “code extract for message.hs” at http://lpaste.net/91389
13:02:08 <hpaste> renny pasted “Error in message.hs” at http://lpaste.net/91390
13:03:42 <renny> help need in posted code. Thanks in advanced
13:04:33 * hackagebot fixed-storable-array 0.3.0.0 - Fixed-size wrapper for StorableArray, providing a  Storable instance  http://hackage.haskell.org/package/fixed-storable-array-0.3.0.0 (CarlHowells)
13:07:15 <Zenol> merijin: Why wasn't it made? It seams it's something that everyone agree with, and from a long time. No?
13:07:53 <merijn> Zenol: Oh, the proposal was accepted and the first steps have been started, but it'll probably be a year or so before that makes it to the platform
13:08:39 <merijn> Until that time I will have to write silly things like "(Functor f, Monad f) => ..."
13:09:15 <tikhon> more generally, some people are worried about backwards compatiblity and such
13:09:32 <tikhon> I think that's why it took so long even to get to this point
13:09:38 <jfischoff> preflex: seen augustss
13:09:38 <preflex>  augustss was last seen on #haskell 44 days, 54 minutes and 51 seconds ago, saying: tgeeky, No, Traytel&Nipkow doesn't feel like a pearl.
13:10:01 <c_wraith> Which is kind of silly.  Things that it breaks are usually pretty easy to fix.  Lots of bigger breaking changes have been made with far less trepidation.
13:10:09 <tikhon> well
13:10:19 <Zenol> tikhon> They are already some break with backward compatibility in GHC 7.7 from 7.6
13:10:39 <jfischoff> @tell augustss did you think it was a bad idea to have Functor be a superclass of Monad?
13:10:39 <lambdabot> Consider it noted.
13:10:51 <c_wraith> Is the Typeable change still on course for GHC 7.8?  That's a *huge* change.
13:11:17 <dmwit> It also has a much better backing story than "it pleases me mathematically".
13:11:53 <c_wraith> I don't care about math for the monad thing.  I just want to never have to write (Functor m, Monad m) again.
13:11:56 <dmwit> (Just playing Devil's Advocate here. I'm generally in favor of Applicative => Monad.)
13:12:42 <jfischoff> we don't really have a good way to express the many faceted relationship between this things
13:12:46 <dmwit> I mean, I would also argue that the argument for the Typeable change is also significantly better than "I don't want to type Functor m in my type declarations".
13:12:48 <c_wraith> But yeah, the Typeable change is a huge increase in safety, which is a good thing.
13:13:23 <c_wraith> The fact that it's simultaneously a big increase in expressivity is just a nice side effect.
13:13:30 <Zenol> I may have to learn what is Typeable, one day...
13:13:47 <jfischoff> monads are also a type of monoid, it would be nice if we could easily switch between different representations
13:13:50 <n-dolio> "I don't want to type Functor m" is huge.
13:13:56 <merijn> n-dolio++
13:14:06 <n-dolio> If you don't think so, I don't believe you've written significant haskell programs.
13:14:21 <Clint> what's the Typeable change?
13:14:41 <n-dolio> It isn't just that, either.
13:14:48 <tomejaguar> Is [| exp |] just a shorthand for building up a value of Q Exp in the Q monad?
13:15:24 <n-dolio> It's, "I put Monad m in these 5 type signatures because it's what I needed. Then I wanted to use (<*>), so now I have to recompile 5 times to find all the cascades."
13:15:50 <Zenol> dmwit: You know that your article with the (((A ->F) -> F) -> F) -> A story still puzzle me?
13:16:04 <dmwit> oh?
13:16:32 <Zenol> It's about the morphism.
13:16:54 <c_wraith> Clint: just about everything about the current way it works is being thrown out. Highlights of the new system involve using a polykinded proxy, having only one class, and completely forbidding manual instances.
13:17:00 <n-dolio> "And also I need to write an orphan instance because someone forgot to write the Applicative instance."
13:17:20 <Clint> c_wraith: thanks
13:17:21 <Zenol> I though that if you have forall.m, then you can just replace m by the identity monad and that was a morphism wrote in haskell :/
13:17:44 <elliott> tomejaguar: AIUI, yes
13:18:41 <dmwit> Zenol: Yes, it is the other direction (adding forall m's everywhere) that cannot be expressed in Haskell.
13:19:12 <Zenol> dmwit> But if we have a proof for the m case, then we can just go back with a proof for the non monadic case?
13:19:55 * Zenol lost the link to the article
13:20:53 <dmwit> http://okmij.org/ftp/Computation/lem.html
13:21:11 <dmwit> The type of the constructive LEM is forall a. (forall m. Monad m => ((a -> m F) -> m F)) -> a
13:21:46 <dmwit> You want to write the non-constructive LEM, whose type is forall a. ((a -> F) -> F) -> a
13:22:20 <dmwit> Thus, to use the constructive LEM, you must write something of type forall a. (((a -> F) -> F) -> a) -> (forall m. Monad m => ((a -> m F) -> m F))
13:22:32 <dmwit> Adding m's is the hard direction.
13:23:18 <dmwit> Sorry, you must write something of type forall a. ((a -> F) -> F) -> (forall m. Monad m => (a -> m F) -> m F)
13:25:16 <dmwit> I think an interesting question might be: can we get away with less than Monad? How little is enough?
13:26:51 <n-dolio> I think your question is backwards.
13:27:19 <n-dolio> You can 'weaken' Monad to nothing, and then it becomes obviously trivial.
13:27:57 <n-dolio> Because it might as well be '(forall r. (a -> r) -> r) -> a'.
13:28:54 <dmwit> I'm not sure I understand. Are you saying that forall a. (forall m. ((a -> m F) -> m F)) -> a is easy to implement?
13:29:02 <elflord> hi all i'm browsing some haskell code; it imported a library, say Control.Concurrent; is there anyway to find out which functions from this library is used ?
13:29:05 <n-dolio> Because you can pick r = a or m = Const a.
13:29:22 <elflord> i'm using vim with some plugins
13:29:25 <yesthisisuser> f g = g (f g) in point-free notation?  what is the lambdabot command..
13:30:02 <Taneb> @pl \f g -> g (f g)
13:30:03 <lambdabot> ap id
13:30:03 <tikhon> @pl \ f g -> g (f g)
13:30:03 <lambdabot> ap id
13:30:03 <dmwit> I mean, I believe that type is easy to implement, sort of. What I don't believe is that it's still isomorphic to ((a -> F) -> F) -> a.
13:30:07 <dmwit> n-dolio: ^^
13:30:25 <dmwit> ?pl f g = g (f g)
13:30:25 <lambdabot> f = fix (ap id)
13:30:25 <yesthisisuser> Taneb: thanks
13:30:27 <Taneb> Wait, that's not quite it
13:30:39 <Taneb> Nevermind
13:30:53 <n-dolio> The Monad version isn't isomorphic to ((a -> F) -> F) -> a.
13:30:53 <tikhon> oh yeah, it has to be recursive
13:31:14 <dmwit> n-dolio: The claim of okmij.org/ftp/Computation/lem.html is that it is.
13:31:23 <yesthisisuser> ap id doesn't work
13:31:28 <Nisstyre> elflord: you mean you want something that will look through the source and pick out which names are imported from Control.Concurrent?
13:31:41 <dmwit> yesthisisuser: Yes; see my corrected query.
13:31:43 <elflord> yes
13:31:55 <elflord> @Nisstyre: yes
13:31:55 <lambdabot> Unknown command, try @list
13:31:55 <Nisstyre> elflord: I don't think there's anything like that that comes with ghc but I might be wrong
13:32:03 <yesthisisuser> sure.. fix (ap id).. thanks
13:32:13 <Nisstyre> elflord: you can type Control.Concurrent at ghci and hit tab to see what it exports though
13:32:21 <elflord> oh ?
13:32:26 <elflord> that might help
13:32:31 <dmwit> :t fix (ap id)
13:32:31 <lambdabot> (a -> a) -> a
13:32:34 <Nisstyre> elflord: yes but it won't necessarily be what the author used
13:32:36 <dmwit> hm =)
13:32:47 <dmwit> I suspect I know a shorter spelling...
13:33:00 <Nisstyre> It seems like ghc has this capability though because it can tell you if something was imported but none of the names were used
13:33:42 <dmwit> :browse Control.Concurrent is the pro way to import Control.Concurrent and hit tab.
13:33:54 <n-dolio> dmwit: I suspect that by 'isomorphic' oleg doesn't mean isomorphic.
13:34:09 <dmwit> n-dolio: It wouldn't surprise me.
13:34:17 <dmwit> n-dolio: At the very least it doesn't seem to be isomorphic in Hask.
13:34:17 <n-dolio> Because it's clearly not isomorphic.
13:34:26 * elliott considers linking the same roconnor post I did last time this came up
13:34:26 <n-dolio> Because one is inhabited and the other isn't.
13:35:19 <dmwit> n-dolio: Well, I suspect he means that for each a, the type (forall m. Monad m => (a -> m F) -> m F) is isomorphic to ((a -> F) -> F).
13:36:21 <n-dolio> That is also wrong, I think.
13:36:26 * elliott finishes considering: http://r6.ca/blog/20040616T005300Z.html
13:36:39 <n-dolio> Just like (a -> F) -> F is not isomorphic to forall r. (a -> r) -> r.
13:36:45 <n-dolio> The latter of which is isomorphic to a.
13:37:10 <dmwit> uh
13:37:18 <dmwit> Is (a -> F) -> F really not isomorphic to a?
13:37:27 <n-dolio> F is the empty type, right?
13:37:32 <dmwit> I mean, it's obviously not isomorphic inside the language.
13:37:35 <dmwit> F is the empty type, yes.
13:37:43 <n-dolio> Then no.
13:37:43 <elliott> the blog post answers this question!
13:38:00 <dmwit> right
13:38:04 <dmwit> Yes, right.
13:38:06 <n-dolio> Unless we're not talking about intuitionistic type theory or something like it.
13:38:10 <elliott> ~~(((a -> b) -> a) -> a) is inhabited but not without the ~~s.
13:38:13 <elliott> also insert quantifiers in there.
13:38:36 <elliott> I think the reason Oleg's LEM works is because the fact that the function passed in runs in the Monad stops you doing the kind of "circularity" you need.
13:38:49 <elliott> you'd need MonadFix or something to get (((a -> b) -> a) -> a) from it.
13:38:53 <elliott> or something.
13:38:54 <merijn> edwardk: Is there a specific reason that exceptions doesn't have uninterruptibleMask?
13:39:26 <edwardk> nobody asked for it?
13:40:09 <edwardk> if you wanted to bash out a patch adding it and plumbing it through the appropriate monads i'd take it
13:40:27 <Zenol> dmwit: "forall a. ((a -> F) -> F) -> (forall m. Monad m => (a -> m F) -> m F)" Oh, ok, thanks :)
13:40:54 <merijn> edwardk: That's what I figured, I'll add it to my yak shaving queue :>
13:41:00 <edwardk> k
13:41:05 <edwardk> let me know if you start
13:41:15 <edwardk> that way i'll know not to force the thunk on my end ;)
13:41:42 <merijn> edwardk: It's on github, right? I'll just submit a PR when I get around to it
13:41:53 <edwardk> github.com/ekmett/exceptions
13:42:11 <merijn> Which, given the fact I'm working on a paper and thus procrastinating, might happen sooner than it should :>
13:42:22 <edwardk> added you there, you can just push now
13:42:45 <merijn> Oh god, the responsibility
13:44:04 <format> Hi all, some one here model a Coloured Petri net in haskell? im doing it if someone wants to join :)
13:46:25 <Zenol> Hum, foo f = return . f :: (a->F) -> (a -> m F)  ?
13:47:39 <byorgey> Zenol: are you asking if foo has some other standard name?  If so, the answer is no
13:47:58 <byorgey> or rather, its standard name is (return .)
13:47:59 <Zenol> byorgey> Nop, if the rype is right
13:48:14 <byorgey> oh, yes, the type looks right to me
13:48:37 <byorgey> well, except that you need a  Monad m => ...  constraint
13:48:46 <Zenol> Yep, and a forall somewhere
13:48:55 <byorgey> the forall is not necessary
13:49:11 <Zenol> yep, but I want a forall m. :)
13:49:22 <jfischoff> Zenol: ?
13:49:35 <byorgey> forall m.  will be implicit, you don't need to write it explicitly
13:50:01 <Zenol> oh, ok.
13:50:36 <tikhon> although it does look cooler, especially if you write it as ∀ :)
13:51:11 <Zenol> tikhon> Not sure that I can type something from my keyboard :p
13:51:19 <tikhon> are you on Emacs?
13:51:36 <Zenol> not when i'm on irc :p
13:51:41 <tikhon> classic mistake
13:51:48 <tikhon> M-x erc for IRC on Emacs
13:52:10 <tikhon> then you can turn on TeX input mode using C-\
13:52:18 <tikhon> which lets you type \forall to get a ∀
13:52:22 <tikhon> and a bunch of other useful symbols
13:52:42 <Zenol> ohw
13:53:38 <zenol`> n^i_c\mathbb{E}
13:53:44 <Zenol> doesn't works so well xD
13:53:51 <tikhon> yeah, there's some weird things
13:54:05 <tikhon> it's limited by what characters it can support
13:54:11 <tikhon> numbers work though: x₁, x²
13:54:28 <zenol`> \forall \exitsts
13:54:35 <tikhon> and the basic bb letters: ℤ, ℕ, ℝ, ℙ
13:54:37 <zenol`> I must doing something wrong.
13:54:42 <zenol`> \forall
13:54:45 <tikhon> with \Bbb{N} for ℕ
13:54:47 <tikhon> hmm
13:54:57 <tikhon> did you do C-\ and enter TeX?
13:55:38 <zenol`> C-\ just write 1> near U:**- #haskell@freenode
13:55:47 <tikhon> hmm
13:55:56 <tikhon> maybe you have a different input mode enabled
13:55:59 <tikhon> try
13:56:11 <tikhon> C-x RET C-\
13:56:15 <tikhon> this will let you change it to TeX
13:56:31 <mauke> TᴇX
13:56:38 <tikhon> (this keybinding is *completely* unintuitive)
13:57:09 <zenol`> ∀
13:57:11 <zenol`> Ok :)
13:57:15 <tikhon> you should have a \ in your modeline now
13:57:19 <mauke> ∀̈
13:57:25 <tikhon> ∃
13:57:51 <mauke> ⊂⊃
13:57:56 <tikhon> it shows you hints in the minibuffer
13:58:05 <zenol`> ∀user : user∈#haskell, thanks_∅(user) :)
13:58:37 <joelteon> thanks for nothing?
13:58:42 <tikhon> ⊂⊃
13:58:45 <zenol`> Nop
13:59:11 <mauke> ω̈≙∴∎
13:59:20 <quchen> Eh, I opened this window to see Haskell stuff.
13:59:26 <zenol`> It's a definable thanks, that do not requite to add elements of the model to the langage :p
13:59:35 <zenol`> Did I mad too much math? :/
13:59:39 <zenol`> *made
13:59:53 <tikhon> oh yeah, there is also a GHC extension called UnicodeSyntax
13:59:57 <mauke> "did" takes the infinite form: make
14:00:02 <tikhon> which allows you to really use this
14:00:07 <mauke> er. infinitive?
14:00:28 <tikhon> ⌣̈
14:00:37 <zenol`> mauke> I prefer infinite :)
14:01:49 <tikhon> also, with the Emacs Haskell mode, you can make forall *appear* like ∀, without actually changing the file
14:02:43 <tomejaguar> wow what happened to my terminal
14:02:44 <tomejaguar> :)
14:03:23 * mauke prepares to go full zalgo
14:03:30 <Zenol> Ohh, I see, you would have to take the (a -> m F) and make it a (a -> F) to be able to produce a m F from return.
14:03:44 <Zenol> hum
14:04:04 <Zenol> humand with runIdentity ?
14:05:41 <Zenol> ok, impossible, because it's the same m.
14:08:09 <Zenol> (a -> m b) -> m (a -> b) is impossible?
14:08:34 <byorgey> it's only possible for certain types a
14:08:44 <n-dolio> Or certain m.
14:08:46 <byorgey> in particular, types which only have finitely many values
14:09:35 <Zenol> byorgey> Oh? Could you detail a bit more why finitely many values?
14:10:12 <byorgey> Zenol: http://winterkoninkje.dreamwidth.org/81209.html
14:10:49 <byorgey> I don't know a better way to explain it than to say "go do those exercises"
14:11:23 <byorgey> n-dolio: for which m is it possible?
14:11:41 <tikhon> Identity, I imagine
14:11:41 <n-dolio> (->) r, at least.
14:11:47 <n-dolio> Also Identity.
14:11:50 <byorgey> heh, right
14:12:11 <byorgey> maybe only for representable m?
14:12:20 <tikhon> representable?
14:12:31 <byorgey> representable ==  isomorphic to  (->) r  for some type r
14:12:36 <tikhon> oh
14:12:53 <tikhon> I guess Identity == (->) ()?
14:12:58 <byorgey> yep
14:13:02 <tikhon> hmm
14:13:22 <byorgey> representable functors are special since they have a fixed structure.
14:13:26 <tikhon> which other ones are there?
14:13:41 <c_wraith> Hmm.  Is there any reason for auto-derived Eq instances to stop compilation if the constructor's type isn't a H98 type?
14:13:48 <n-dolio> @djinn (a -> (b -> r) -> r) -> ((a -> b) -> r) -> r
14:13:48 <lambdabot> -- f cannot be realized.
14:14:00 <n-dolio> Yeah, representable seems plausible.
14:14:07 <byorgey> the reason you can't have, say,  (a -> Maybe b) -> Maybe (a -> b)  is that you might have to call the function on infinitely many values of a, and you can't know whether you're going to get a Nothing or a Just out at the end until you've looked at all of them
14:14:48 <tikhon> that's also assuming a reasonable definition of the function
14:14:48 <hpc> what's more, a might not even be an enumerable type
14:14:56 <byorgey> for a representable functor, on the other hand, you know the top-level structure automatically and you just have to (lazily) compute the contents of type (a -> b)
14:15:04 <hpc> imagine if a was the type for a network handle
14:16:01 <byorgey> tikhon: I'm implicitly assuming that the goal is to get a total, terminating definition of (a -> m b) -> m (a -> b)
14:16:21 <tikhon> right
14:18:18 <roconnor> In order for (a -> m b) -> m (a -> b) to hold "Reasonably" for all m and for all b, then (a ->) would have to be a traversable functor.
14:18:39 <roconnor> that would imply that (a ->) is a finitary container, which would imply that a is finite.
14:19:04 <n-dolio> Actually, you can write something with that type for Maybe as well. But it's const Nothing, which presumably isn't desirable.
14:19:11 <stepkut> how do I know which lens library to use?
14:19:20 <c_wraith> use the one named "lens"
14:19:22 <roconnor> (by forall m, I mean forall Applicative m, but it is conjectured that the same holds forall Monad m).
14:19:43 <tikhon> yeah, I was thinking about const Nothing, but that's only going to hold for some m
14:19:51 <tikhon> you could generalize it to const mzero
14:35:40 <hpaste> ixmatus pasted “Simplifying types?” at http://lpaste.net/91391
14:35:54 <ixmatus> I'm trying to simplify my types like so: http://lpaste.net/91391
14:36:16 <ixmatus> but I'm having a hard time understanding how to use it; I get (understandably) a not in scope data constructor error
14:36:38 <ixmatus> whenever I try to construct with it...
14:37:01 <S_J> Would it be possible to quantify how well generating test cases tests a preoprty test? what can you actually say about a property test in more specific terms?
14:37:47 <quchen> S_J: There's the `classify` function
14:38:24 <quchen> It allows you to give labels to test cases, e.g. when you're checking lists you can log how many empties/singletons/multiples you get
14:39:35 <pentace> ixmatus: You can't have two types with the same name in the same module
14:40:00 <ixmatus> I know that, the paste is showing what my type was before and then after
14:40:24 <ixmatus> factoring redundant types out
14:40:32 <pentace> Hhm, I don't understand your question then
14:40:44 <ixmatus> how do I use it
14:40:58 <pentace> Use what?
14:41:02 <monochrom> ixmatus, I still don't understand the question. the pasted code, after deleting one version of "data Test = ...", should work fine. what error?
14:41:21 <zzing> If I have a Maybe [a]   and I have a function a -> b  what is the easiest way to map over this?
14:41:42 <ixmatus> if I have a data type with records of a redundant type :: String -> Int
14:41:48 <ixmatus> I want to factor out the String
14:41:53 <supki> zzing: fmap . fmap
14:42:10 <erisco> is there a canonical type class for applicative-like interfaces with (<*>) :: f a -> f (a -> b) -> f b  ? note that I am not looking for <**>, as this just maps to <*>
14:42:15 <jfischoff> supki: fmap fmap fmap ;)
14:42:27 <ixmatus> or at least was told I could, into the type of `type Engine = String -> OldEngine
14:42:37 <hpaste> quchen pasted “S_J: QuickCheck `classify`” at http://lpaste.net/91392
14:42:40 <erisco> or is there a redunance in such an interface I am not seeing?
14:43:42 <monochrom> ok, so just do it, what error?
14:43:43 <supki> erisco: Control.Applicative.Backwards provides a newtype for applying effects in the reverse order (if that's what you want?)
14:44:01 <quchen> erisco: What behaviour do you expect? What does <**> not do what you want to do?
14:44:30 <erisco> I may have made a misstep in my thinking here. hm
14:44:34 <quchen> If you're looking for things like "backwards state" you can write that, but it's not in the standard libs.
14:44:48 <ixmatus> monochrome: I get a data constructor error if I try to use the type because type synonyms can't be used that way
14:44:55 <ixmatus> this might be easier
14:45:21 <monochrom> I don't get an error. what actual code could I use to get an error?>
14:45:59 <monochrom> do you understand that if I just load up lines 7-13 I won't get an error?
14:46:42 <hpaste> ixmatus pasted “monochrome” at http://lpaste.net/91393
14:46:45 <erisco> hm, I do have to rethink this
14:47:04 <ixmatus> monochrome how would you simplify the types for that data type?
14:47:21 <quchen> erisco: Are you looking for a <*> that evaluates the "function" part first?
14:47:26 <quchen> Eh, the non-function part
14:47:39 <c_wraith> arg.  Why is standalone deriving so much less brittle than deriving clauses?
14:47:51 <quchen> I.e. when both `a` and `b` have some effect, do you want b's effect to come first in `a <*> b`?
14:48:04 <erisco> no
14:48:15 <quchen> Ah. Good. Because that would be awkward! :-D
14:48:32 <erisco> that is what <**> seems to do
14:49:06 <erisco> > Just 5 <**> Just ((-)1)
14:49:07 <lambdabot>   Just (-4)
14:49:14 <quchen> Not really. <**> just flips the arguments, and doesn't do anything crazy.
14:49:32 <erisco> the RHS is being done first, clearly
14:49:33 <quchen> On the other hand, having b's effects come first in `a <*> b` is certainly unexpected.
14:49:39 <S_J> > let g f x = Just x >>= return . (Just (f x)) in g (+4) 7
14:49:40 <lambdabot>   Couldn't match expected type `a0 -> b0'
14:49:41 <lambdabot>              with actual type `Data...
14:49:56 <erisco> I realize it is flipped around to <*>, but that isn't what I want, see.
14:50:02 <erisco> anyways, I have to do a bit more thinking
14:50:05 <hpaste> monochrom annotated “monochrome” with “monochrome (annotation)” at http://lpaste.net/91393#a91394
14:50:12 <S_J> > let g f x = Just x >>= return . (f x) in g (+4) 7
14:50:13 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> b0
14:50:13 <lambdabot>  Expected t...
14:50:23 <monochrom> ixmatus: http://lpaste.net/91393#a91394
14:51:05 <S_J> > let justify f v = Just (f v) in justify (+4) 7
14:51:06 <lambdabot>   Just 11
14:51:19 <ixmatus> ahhhh I understand now
14:51:47 <kaan> hello there
14:52:04 <ixmatus> I thought there was something missing in my understanding of how to construct a simpler type out of redundant types
14:52:10 <S_J> > 9 >> 7
14:52:11 <lambdabot>   Could not deduce (GHC.Num.Num (m a0))
14:52:11 <lambdabot>    arising from the ambiguity check f...
14:52:18 <S_J> > Just 9 >> 7
14:52:19 <lambdabot>   No instance for (GHC.Show.Show b0)
14:52:20 <lambdabot>    arising from a use of `M2114374339.sh...
14:52:23 <S_J> > Just 9 >> print 7
14:52:24 <lambdabot>   Couldn't match type `GHC.Types.IO' with `Data.Maybe.Maybe'
14:52:24 <lambdabot>  Expected type: ...
14:52:27 <ixmatus> monochrom: thank you
14:52:27 <quchen> S_J: You can also /msg lambdabot :-)
14:52:32 <monochrom> you're welcome
14:53:27 <kaan> i have a question, hopefully not so dumb. Here it is: I am building a package, and I cabal installed it. Now I want to make changes to some files of it, but when I change it, and invoke cabal install "file.cabal"  it doesn't change the installed package
14:53:37 <Tene> Is there any difference between concat and join, or is it just like map/fmap ?
14:54:50 <quchen> Tene: Yes, it's similar.
14:55:06 <Tene> Thanks.
14:55:24 <quchen> Note that for lists, fmap = map, but concat and join are differently defined (although they do the same thing).
14:55:50 <quchen> For lists, join m = m >>= id = concatMap id m = concat m
14:56:18 <quchen> I guess in this case both versions should be optimized to the same code in the end, so it doesn't matter much.
14:58:38 <monochrom> kaan: I have not heard of "cabal install file.cabal", how did you know of that syntax? instead, I have only known: cd to the right directory, then "cabal install"
14:58:52 <S_J> quchen: ty.
14:59:07 <donri> cabal install path/to/dir works too
14:59:40 <kaan> yes. that's indeed not the problem. the problem is: i installed the package
14:59:47 <kaan> but now, i updated some code
15:00:08 <kaan> but when i run cabal install again, it won't update the module
15:00:10 <kaan> -.-
15:00:18 <quchen> Bump the version number?
15:00:21 <monochrom> what output did you get?
15:00:30 <S_J> quchen: can you say something about the properties of a function that can be well tested with random input? i mean how do you know you hit a good sample of the possible input. i mean the input has to have some kind of uniformity right? so that you dont keep generating a lot of input that just test the same thing.
15:00:38 <monochrom> complete verbatim unabridged output
15:01:09 <quchen> S_J: That's what `classify` is used for
15:01:19 <monochrom> IIRC worksforme
15:01:28 <quchen> There's also some way of printing all test cases explicitly I think, but it's pretty verbose as you might imagine
15:01:42 <quchen> verboseCheck it's called I think
15:01:44 <donri> is ghc the library supposed to come with haskell platform?
15:02:06 <quchen> donri: http://www.haskell.org/platform/changelog.html
15:02:11 <geekosaur> yes, since it comes with the compiler
15:02:18 <geekosaur> and the compiler comes with the platform
15:02:21 <monochrom> comes with even just GHC
15:02:34 <donri> the compiler and the library are separate
15:02:40 <kaan> monochrom, what do you mean? It doesnt compile the whole package (normally it takes much longer time) but it does "something"
15:03:20 <monochrom> I mean when you enter "cabal-install" what screen output do you get? complete verbatim unabridged.
15:03:38 <monochrom> err, s/cabal-install/cabal install/
15:04:52 <merijn> kaan: Why would it compile the whole package if you only changed a little?
15:05:36 <kaan> merijn, how can i improve that? sorry, i am new to the package-building-thing
15:06:02 <kaan> btw. monochrom thanks for your help, apparantly it works now
15:06:23 <kaan> :-) dont know, what i have done different, but meh...
15:08:01 <zzing> I have a function call that is   showMonitor <$> mons  where it is (Monitor -> IO String) -> [Monitor] -> [IO String]       I would like to get an IO [String], what is the best way to do this?
15:08:36 <geekosaur> :t sequence
15:08:36 <lambdabot> Monad m => [m a] -> m [a]
15:09:23 <byorgey> zzing: you can also use mapM instead of <$>
15:09:24 <quchen> Also mapM. Instead of `showMonitor <$> mons`, write `mapM showMonitor mons`
15:09:42 <zzing> Is there a reason to use mapM instead?
15:09:59 <byorgey> it's shorter, and more idiomatic
15:10:03 <arkeet> mapM f x = sequence (f <$> x)
15:10:09 <zzing> oh ok
15:10:26 <erisco> quchen, it seems what I was trying to do results in an infinite type...
15:10:45 <arkeet> @src mapM
15:10:45 <lambdabot> mapM f as = sequence (map f as)
15:11:20 <zzing> I wish lambdabot src would work in my ghci + goa
15:11:21 <merijn> zzing: Basically, mapM has the sequence that you (usually) want built in
15:11:28 <kaan> anyways merijn, can you tell me, how i should "update" my package, when i only change few things? would be good to know
15:11:30 <arkeet> zzing: lambdabot src is pretty dumb.
15:11:32 <zzing> That will save some effort
15:11:33 <arkeet> @where src
15:11:33 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
15:11:41 <zzing> arkeet, I love it though :P
15:11:44 <quchen> erisco: Okay. (Now what?)
15:11:45 <elliott> that database is wrong. :p
15:11:46 <merijn> kaan: Cabal already does that, it only recompiles what it needs
15:11:55 <merijn> zzing: @src is filled with lies, though
15:11:58 <erisco> quchen, I dunno... could be screwed
15:12:00 <zzing> :t intercalate
15:12:01 <lambdabot> [a] -> [[a]] -> [a]
15:12:07 <elliott> I mean, it's not even the one lambdabot uses.
15:12:09 <quchen> erisco: I'm not trained in reading thoughts
15:12:11 <zzing> @src intercalate
15:12:11 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
15:12:14 <arkeet> elliott: heh
15:12:15 <merijn> zzing: FYI, hoogle has source links for most functions
15:12:42 <zzing> What is the best way to [String] -> String    with adding new lines?
15:12:49 <quchen> unlines
15:12:50 <erisco> data Foo a = Foo (Foo b)   it is this problem in a nutshell
15:13:22 <merijn> erisco: Where is b coming from?
15:13:53 <erisco> well, exactly. the point is that the type you recurse on it not the same
15:14:11 <merijn> erisco: So you don't know what b will be?
15:14:16 <erisco> nope
15:14:34 <merijn> erisco: Why are a/b in the type at all, then?
15:14:39 <kaan> okay thank you merijn  :-)
15:15:02 <elliott> how do you plan to use this type?
15:15:52 <erisco> data Foo a = Foo a (Foo b)  makes more sense, sorry
15:16:20 <quchen> There's still a `b` popping up on the right hand side
15:16:30 <quchen> That's like writing `f x = x y`
15:16:51 <quchen> … just on type level
15:19:35 <erisco> data Foo a b c = Foo a (Foo b (Foo c () ()) ()) ()
15:19:55 <erisco> see, you can take it to a certain depth, but inconveniently so
15:20:46 <merijn> erisco: You can do it nicer with type families
15:21:15 <merijn> Although I guess you'd want an associated data family to actually instantiate it
15:21:29 <zzing> merijn, is there a nice example of type families and practical applications?
15:22:18 <quchen> zzing: The Wiki gives a few examples. http://www.haskell.org/haskellwiki/Type_family
15:22:19 <erisco> merijn, I suppose I should read on those but also think of some other way to formulate the problem
15:23:08 <merijn> zzing: I wrote a cool one that lets you define functions like "any a, except Int"
15:23:21 <merijn> Lemme find the link
15:23:28 <zzing> merijn, that is getting into cool like c++ tmp :P
15:23:48 <merijn> zzing: http://lpaste.net/91143
15:25:09 <quchen> I don't understand anything in that code.
15:25:11 <merijn> zzing: I also used them in a function that could a function of X arguments with a (heterogeneous) list of X values, typechecking the types and number of arguments match at compile time
15:25:21 <merijn> quchen: No? It's not very hard :)
15:25:34 <quchen> merijn: It's got one extension per line of code :-s
15:25:36 <crocket> Does haskell on JVM(Frege) have advantages over scala?
15:25:37 <johnw> merijn: is this checked for at runtime, or compile-time?
15:25:44 <johnw> I guess the ~ makes it a type error
15:25:46 <merijn> johnw: Compile time! \o/
15:25:51 <quchen> crocket: This is #haskell.
15:25:57 <quchen> Oh, nevermind.
15:26:02 <merijn> johnw: It doesn't play very nice with polymorphic values like 1, etc. though
15:26:15 <merijn> johnw: Because GHC can't proof that 1 won't be ()
15:26:18 <crocket> quchen: haskell on JVM
15:26:29 <quchen> crocket: Yeah, sorry
15:26:42 <nexx> crocket add a "Oh, nevermind" :D
15:27:05 <quchen> merijn: The first thing I don't understand is line 5, which is quite good, because that means there's one line I *do* understand (3).
15:27:11 <merijn> quchen: It's fairly simple, it defines a tye family (read: type level function) that takes a type of any kind 'k' and a list of kinds of type 'k' as arguments
15:27:12 <crocket> Do you guys think haskell is superior to scala? or are they just different?
15:27:45 <johnw> crocket: X vs. Y arguments are very fruitful
15:27:45 * quchen doesn't feel like language war
15:27:46 <byorgey> crocket: "is language X better than language Y" questions are rarely productive.  Do you have any more specific questions?
15:27:54 <johnw> s/are/aren't
15:27:56 <RichyB> Oh Haskell is clearly impeccable in every way, shape and form. Also we're not even slightly biased.
15:28:00 <merijn> quchen: The result of this type function is a Constraint. Basically, it checks whether the first type is part of the list, if so, it returns a Constraint that doesn't match
15:28:06 <nexx> I hardly know scala. But at least there are topics in wich haskell is superior e.g. scala has null pointer
15:28:15 <crocket> Does haskell have advantages over scala in startups?
15:28:28 <johnw> crocket: there are too many other factors involved in answering such a question
15:28:36 <johnw> if you have a team of crack scala developers, use scala
15:28:42 <quchen> merijn: Processing that statement …
15:28:47 <merijn> quchen: Line 7 is mostly to make the type error more sensible, obviously "a" will never have type equality with that Symbol, it's just tricking GHC to print out the text in the type error
15:29:00 <crocket> johnw: Language selection is important.
15:29:05 <erisco> mmm I might, just might be able to fix the problem with a type class, since I only need partial information from the successor which has constant type
15:29:07 <quchen> merijn: ~ is type level equality?
15:29:10 <merijn> quchen: Yes
15:29:12 <crocket> It literally affects culture.
15:29:15 <slack1256> @where hpaste
15:29:15 <lambdabot> http://lpaste.net/new/haskell
15:29:23 <erisco> (ie, the information I need is always of the same type)
15:29:35 <johnw> crocket: but it depends on more than absolute determination of quality between languages; it depends on what resources you have, who you can hire, your current knowledge base, infrastructure, etc., etc.
15:29:57 <quchen> merijn: I'm not sure what types and kinds and values are in that code anymore, it all seems to be mixed. How can the type a equal a String?
15:29:58 <merijn> quchen: So basically, if the first type is not in the list of type it returns an empty (always matching) Constraint in line 9
15:30:02 <hpaste> slack1256 pasted “meaning ~ type classes” at http://lpaste.net/91397
15:30:13 <crocket> johnw: And I'll bet on functional programming languages.
15:30:25 <slack1256> can somebody help me to understand the above paste?
15:30:29 <merijn> quchen: DataKinds promotes values to the type level. It's not a String, it's a Symbol (i.e. type level string literal)
15:30:34 <slack1256> I have problem understanding the type of editFile
15:30:45 <merijn> quchen: Which, as I said is just to trick the compiler into printing a semi-useful type error
15:30:46 <johnw> crocket: pick a small piece of the problem you want to solve, and try to solve it in both languages.  The answer should become pretty clear for _you_ by then
15:31:13 <quchen> merijn: Ah, same thing as when I use naive nats' constructors on type level for the canonical length-encoded vector example
15:31:15 <crocket> johnw: For small programs, yes
15:31:27 <merijn> quchen: You could mentally replace line 7 with (Int ~ Char) or any other impossible Constraint
15:31:30 <crocket> In a company, many small modules are combined, or a big system is created.
15:31:46 <quchen> merijn: So "Foobar" is the name of a specific type, just like Char is a type
15:31:48 <johnw> otherwise, you're in #haskell, most of us have already chosen Haskell as the answer to your question, so there's not much of comparative value to be found here
15:31:56 <merijn> quchen: Yes
15:32:11 <Philippa> johnw: so folks like edwardk have opinions to be offered here
15:32:11 <merijn> quchen: A type of kind Symbol, to be precise
15:32:22 <johnw> yes, edwardk would know
15:32:29 <crocket> johnw: Do you like to combine small modules or create a big sytem?
15:32:30 <johnw> I have never touch Scala, I do not know
15:32:30 <crocket> system
15:32:51 <johnw> crocket: I don't see why there is an "or" in that sentence
15:32:55 <crocket> I personally don't like a big monolithic system.
15:33:04 <erisco> or a light-weight type class aka just passing the needed function around :)
15:33:05 <crocket> It's difficult to understand and difficult to maintain.
15:33:21 <merijn> quchen: Basically, if you try to pass () to foo, then the type family will produce the constraint "(() ~ "that string") => () -> ()", which is obviously a type error as () and "that string" don't unify and thus the constraint doesn't hold :)
15:33:34 <johnw> I use Haskell for programs of all sies
15:33:35 <johnw> sizes
15:33:35 <Philippa> parametric polymorphism alone buys you a lot of room to get out of monolith-meets-ball-of-crud systems
15:33:48 <Philippa> johnw: you've worked on a BLoC project in it?!
15:33:48 <FreeFull> Monomorphism restriction?
15:33:51 <zzing> If I have something like liftM unlines case x of     what can I do to make the case be a valid parse?
15:33:53 <crocket> johnw: Does haskell scale well to large programs?
15:33:58 <quchen> merijn: And in the pattern in line 7 you use `a` twice, is that something special about type instances compared to normal patterns?
15:34:17 <crocket> By large programs, I mean a big codebase maintained by a constant influx of devs.
15:34:18 <merijn> quchen: That's just comparing two types for equality
15:34:20 <johnw> crocket: Haskell emphasizes composition, so inherently, yes
15:34:38 <quchen> merijn: Yea, but "f x x = 8" is an error, whereas on type level it doesn't seem to be
15:34:40 <Philippa> crocket: people's ideas of 'big' vary, hence my wisecrack above...
15:34:54 <merijn> quchen: I'm using the (new in 7.7) feature that type family instance are tried in order
15:34:55 <johnw> Philippa: is BLoC, billion lines of code?
15:35:01 <Philippa> johnw: yep
15:35:12 <johnw> let me count how many lines of Haskell there are in our current project
15:35:14 <crocket> billion lines?
15:35:23 <quchen> merijn: So basically it is the type level version of `Restrict x (y:ys) | x == y = foobar`
15:35:23 <Philippa> I was being a little sarcastic
15:35:25 <merijn> quchen: Yeah, it's a bit different from the value level, in the sense that all variables have to unify
15:35:31 <merijn> quchen: Yes
15:35:41 <quchen> Alright. Making progress. :-)
15:35:49 <crocket> johnw: What haskell programs do you make for your commercial projects?
15:35:53 <quchen> Line 8-9 then recurse until termination or error
15:35:55 <Philippa> (I've poked around MLoC C++ codebases before, it's not much fun. I don't want to do the same for Haskell either, but you'd fit much of the same functionality in a smaller line count)
15:35:59 <merijn> quchen: Yeah
15:36:03 <johnw> crocket: http://fpcomplete.com
15:36:11 <johnw> that is an entirely-Haskell site, from bottom to top
15:36:12 <merijn> quchen: Well, not really error, but impossible constraint
15:36:17 <quchen> merijn: () is the unit *type* in line 9?
15:36:27 <merijn> quchen: It's the empty Constraint
15:36:34 <johnw> Philippa: 422K LoC
15:36:38 <crocket> johnw: Is that what you make?
15:36:44 <johnw> crocket: yes, that's what I work on
15:36:46 <quchen> merijn: Which is no constraint, i.e. one that is always fulfilled?
15:36:48 <merijn> Compare: "(Monad m, Functor m)", "(Monad m)" and "()"
15:36:49 <Philippa> johnw: *nod*. Yeah, that's a fair ol' chunk of Haskell
15:36:50 <johnw> Philippa: oh, the Haskell part is 226K
15:36:51 <merijn> quchen: Yes
15:37:00 <johnw> not every line of that is a line we wrote, either
15:37:07 <johnw> let me isolate
15:37:10 <merijn> quchen: You could also write, for example, (a ~ a) there
15:37:48 <quchen> merijn: Alright, `Restrict a '[(), Int]` then lifts the [] to type-level, which is then evaluated by the family instance to make sure a isn't unit or Int?
15:37:49 <crocket> johnw: Which one do you use between IDE or vim/emacs to code in haskell?
15:37:56 <johnw> I use Emacs myself
15:37:58 <merijn> quchen: Yes
15:38:07 <Philippa> crocket: so one nice thing about Haskell is how little effort it takes to switch types around or other things you'd expect to cause coupling
15:38:11 <merijn> quchen: the ' signifies a promoted literal
15:38:33 <merijn> quchen: i.e. a type of kind [*], rather than one of type *
15:38:37 <quchen> merijn: ' promotes type to kind, while value->type is done automatically?
15:38:41 <Philippa> the sheer pervasiveness of parametric polymorphism - and the fact you don't have to ask for it - gains you a lot of the flexibility of working in a dynamically-typed language, only safely
15:38:53 <merijn> quchen: They're always automatic, but ' disambiguates
15:39:13 <quchen> A little like using `lift` explicitly in transformer stacks?
15:39:22 <merijn> quchen: Which is not usually needed, since "Just Int" isn't valid syntax normally, but [Int] is valid normally
15:39:36 <Philippa> it's my understanding that Scala is not quite as good at pushing the edge for such things, but you'd want to ask someone like edwardk who's worked in both
15:39:40 <merijn> So you need to signify the difference between "[Int] :: [*]" and "[Int] :: *"
15:39:45 <johnw> Philippa: ok, weeding out code we didn't write, 70K LoC of Haskell
15:40:00 <FreeFull> I guess  [Int, Char]  doesn't need to be disambiguated
15:40:11 <Philippa> johnw: *nod*
15:40:19 <johnw> so, not a BLoC
15:40:28 <merijn> FreeFull: Possibly, I originally had a one item list, so I never checked to remove the '
15:40:32 <crocket> Do you guys use IDE to code in haskell?
15:40:37 <edwardk>  merijn: patch looks good
15:40:41 <Philippa> well no, I didn't expect so :-) But being well into the 10KLoCs range is significant
15:40:47 <merijn> edwardk: I didn't break anything \o/
15:40:51 <merijn> I think...
15:40:59 <merijn> ;)
15:41:09 <quchen> merijn: Alright, so back to line 5. This defines the type family "Restrict" that has two fields, one of a kind, and one of a list of kinds
15:41:23 <quchen> And the whole thing is a Constraint and I'm confused again.
15:41:26 <Philippa> not a guy here - don't have a good-for-Haskell IDE to hand, make do with my own taste in text editors. The features I'd want out of an IDE are... a bit more involved than traditional IDEs are used to providing
15:41:34 <Philippa> say it together, everyone - where's my typing debugger?
15:41:36 <merijn> quchen: Constraint is the return type
15:41:49 <johnw> Philippa: mgsloan is often thinking about typing debuggers
15:41:50 <merijn> quchen: You can read it as "Restrict :: k -> [k] -> Constraint"
15:41:51 <crocket> edwardk: How do you compare scala and haskell?
15:42:07 <merijn> quchen: You just can't write the type that way for stupid syntactic reasons
15:42:11 <edwardk> Scala works on the jvm. Haskell is well designed.
15:42:18 <johnw> well put
15:42:24 <DanBurton> consider the category where objects are type constructors of kind (* -> *) for which there is a Monad instance, and arrows from M to N are functions (forall x. M x -> N x). Can I refer to this as "MHask" or is there a better name for it?
15:42:46 <edwardk> I wrote a language to get out of writing Scala. ;)
15:43:03 <erisco> is there a canonical extension of $ for multiple arguments?
15:43:07 <Philippa> johnw: I've joked about a "typefecker" whose job is to prove that the term couldn't possibly be typed and thus throw/feck it out the window
15:43:13 <edwardk> erisco: make a $ with the fixity flipped
15:43:19 <edwardk> erisco: then you can use it with multiple args
15:43:22 <merijn> quchen: Basically, GHC can't guess whether "Restrict :: * -> *" is a type family that takes 1 argument and returns * or whether it is a type family of zero arguments returning "* -> *"
15:43:25 <Philippa> (the 'untyping's thus being more complex forms of error messages)
15:43:30 <quchen> merijn: What's the connection between the type family and the type instance? The type instance doesn't mention `Restrict` in its head like classes do.
15:43:49 <quchen> merijn: i.e. how does the "type instance" know it's used to define something with `Restrict`?
15:43:52 <quchen> By the where clause somehow?
15:43:56 <edwardk> @let infixl 0 ?;f ? x = f x
15:43:57 <lambdabot>  Defined.
15:44:15 <Philippa> johnw: tbh, I throw it in the "ewww, sounds like UI work" pile until someone convinces me there's an easy enough UI lib. But I'm lazy
15:44:25 <merijn> quchen: The "normal" syntax is "type instance Restrict x (a ': as) = ..."
15:44:27 <edwardk> > (*) ? 1 + 2 ? 3 + 4
15:44:31 <lambdabot>   mueval-core: Time limit exceeded
15:44:32 <johnw> Philippa: I hear you
15:44:33 <edwardk> > (*) ? 1 + 2 ? 3 + 4
15:44:37 <lambdabot>   mueval-core: Time limit exceeded
15:44:50 <merijn> quchen: But type family instances (like type classes) have no ordering, so you can't have overlapping definitions like Restrict
15:44:55 <edwardk> > (*) ? 1 + 2 ? 3 + 4
15:44:56 <FreeFull> edwardk: That looks suspiciously like ap
15:44:59 <lambdabot>   21
15:45:11 <Philippa> johnw: I'd probably be running that past some more influential folks next week but for having to take a health break though :-(
15:45:24 <FreeFull> > (*) <*> 1 + 2 <*> 3 + 4
15:45:25 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
15:45:26 <lambdabot>    arising from a use ...
15:45:26 <johnw> Philippa: running what past them?
15:45:28 <merijn> quchen: "type instance where" is a hack (that will likely be replace with the proper closed type families recently published by SPJ) that guarantees lexical order of patterns
15:45:35 <FreeFull> Actually, it isn't quite
15:45:45 <FreeFull> I guess maybe if you did this:
15:45:48 <edwardk> FreeFull: it should, its just $ with different fixity and f you look at the signature of $ and (<*>) you'll see similarities
15:45:50 <edwardk> :t ($)
15:45:50 <lambdabot> (a -> b) -> a -> b
15:45:52 <edwardk> :t (<*>)
15:45:53 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:45:53 <FreeFull> > (*) <*> ($) 1 + 2 <*> ($) 3 + 4
15:45:54 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable b0)
15:45:54 <lambdabot>    arising from a use ...
15:46:06 <edwardk> you'd have to replace the first one with <$>
15:46:09 <haasn> who maintains ‘pipes’?
15:46:13 <johnw> haasn: Tekmo
15:46:15 <edwardk> haasn: Tekmo
15:46:19 <FreeFull> Yeah, but I wonder if it could be done without fmap
15:46:22 <johnw> first time I beat edwardk to anything
15:46:32 <quchen> merijn: Alright, let me see whether I encounter a use case in the wild some day :-)
15:46:35 <Philippa> johnw: some of my ideas re typing-debuggers etc etc
15:46:36 <merijn> quchen: You might also want to read "Fun with Type Functions"
15:46:54 <merijn> quchen: It's a very easy paper to read, especially if you got most of this explanation
15:47:12 <quchen> merijn: To be honest I'm just procrastinating from crawling through GHC's source right now. Now there's a full paper to use for that. Excellent! :>
15:47:30 <haasn> @ask Tekmo in Control.Proxy.Tutorial you mention “mapD pull = pull”; did you mean “mapD id = pull” ?
15:47:30 <lambdabot> Consider it noted.
15:47:31 <merijn> quchen: TypeFamilies are great when combined with GADTs and phantom types <3
15:47:33 <edwardk> erisco: anyways that one will do it, but there isn't a standard version of that in haskell. its kind of a shame that ($) didn't historically get the flipped fixity
15:47:54 <FreeFull> :t join const
15:47:55 <lambdabot> a -> a
15:48:12 <merijn> quchen: You can encode things in phantom type with GADTs and then use typefamilies to do stuff with the phantom types
15:48:43 <haasn> merijn: oh, we get a replacement for ‘type instance where’ now?
15:48:59 <erisco> sorry just to make sure I am asking this right.... in     a `op` b    I am expecting   a :: x -> y    and 'b' to be anything so long as it returns something of type 'x'
15:49:26 <haasn> merijn: does that give us (==) :: k -> k -> Bool -- then?
15:49:45 <erisco> @pl (\x y -> a (b x y))
15:49:45 <lambdabot> (a .) . b
15:49:58 <quchen> erisco:  a `op` b = op a b. Both a and b can by anything, depending on how op is defined.
15:50:00 <merijn> haasn: Proper closed type families are coming, yes
15:50:07 <haasn> erisco: a .: b -- if you live in a world where we had that operator
15:50:11 <merijn> haasn: https://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/axioms-extended.pdf
15:50:20 <quchen> merijn: How useful is trying to understand them right now if there's an overhaul coming? :-)
15:50:21 <merijn> haasn: "Closed type families with overlapping equations"
15:50:24 <erisco> @pl (\x y z -> a (b x y z))
15:50:24 <lambdabot> ((a .) .) . b
15:50:32 <erisco> well that seems to be the pattern then
15:50:34 <haasn> merijn: neat
15:50:43 <merijn> quchen: The overhaul won't impact the existing type families, just add a second class of closed type families
15:50:51 <haasn> erisco: a .:: b -- if you live in a world where we had that operator
15:51:06 <erisco> haasn, why do you keep saying this?
15:51:11 <FreeFull> haasn: I'm pretty sure that operator is in a library
15:51:13 <quchen> erisco: The Dotdotdot operator!  (.).(.)
15:51:14 <haasn> erisco: or uh ‘fmap fmap fmap a b’; ‘fmap fmap fmap fmap fmap a b’
15:51:19 <quchen> :-D
15:51:19 <merijn> quchen: i.e. normal type families are open, i.e. anyone can add new instances. Closed type families are...closed, i.e. no new instances can be provided
15:51:21 <haasn> FreeFull: yeah, pointless-fun is the example I know of
15:51:38 <haasn> erisco: because it tends to be defined in lambdabot but isn't actually in base or any commonly used library :)
15:51:45 <haasn> :t (.:) -- do we have it right now?
15:51:46 <lambdabot>     Not in scope: `.:'
15:51:46 <lambdabot>     Perhaps you meant one of these:
15:51:46 <lambdabot>       `.' (imported from Data.Function),
15:52:04 <johnw> closed type families are like a programmatic mafia
15:52:10 <johnw> bu once you're in, you're made
15:52:22 <merijn> Closed type families are like hugs and cuddles of a unicorn
15:52:37 <quchen> Only possible in your dreams? :s
15:52:38 <erisco> quchen, indeed. my head spins looking at dot combined in such ways
15:52:59 <johnw> does anyone actually use (.).(.)?
15:53:10 <johnw> i find (foo .) . bar much easier to read than foo ((.) .(.)) bar
15:53:13 <erisco> so I'll just use the lamba instead
15:53:25 <FreeFull> @let infixr 9 .: ; (.:) = (.).(.)
15:53:26 <lambdabot>  Defined.
15:53:28 <elliott> foo ((.) . (.)) bar doesn't mean the same thing
15:53:31 <FreeFull> :t (.:)
15:53:32 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:53:35 <haasn> johnw: I'll do (.:) = fmap fmap fmap
15:53:42 <haasn> or = fmap . fmap
15:53:49 <quchen> erisco: (a . b) x = ((.) a b) x = a (b x)       ((.)(.)(.) a b) x y = a (b x y)
15:53:49 <elliott> (fmap . fmap) foo bar is sort of nice.
15:53:52 <elliott> at least it follows a pattern.
15:54:08 <johnw> sorry, ((.) .()) foo bar
15:54:12 <erisco> enough dots or my head will asplode
15:54:19 <johnw> :t \f g -> (f .) . g
15:54:19 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:54:22 <johnw> :t \f g -> ((.) . (.)) f g
15:54:22 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
15:54:37 * hackagebot exceptions 0.2 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.2 (EdwardKmett)
15:54:55 <johnw> edwardk: what are you using exceptions for?
15:55:08 <quchen> merijn: Thanks for the explanations by the way.
15:55:14 <merijn> quchen: np
15:55:38 <crocket> meh
15:55:43 <edwardk> johnw: mzero asked me to release a standard form of MonadCatchIO-transformers that we could standardize and threw the initial implementation at me
15:55:59 <johnw> edwardk: I have one major bone to pick with exceptions
15:56:02 <edwardk> its designed to replace MonadCatchIO-transformers but actually be able to be built with GHC head
15:56:05 <edwardk> great pick away
15:56:13 <johnw> it's `finally` does not necessarily mean that the block will execute in the presence of an exception
15:56:23 <edwardk> then fix it and send me the patch
15:56:25 <johnw> it will execute in the presence of an *exceptions library* exception
15:56:29 <edwardk> oh
15:56:30 <johnw> but not a real exception
15:56:33 <edwardk> yes
15:56:38 <johnw> so, it can lead to very confusing code
15:56:39 <edwardk> i can't control that without being dangerous
15:56:47 <johnw> you see finally, but it's not really finally
15:56:58 <johnw> it's another concept masquerading behind the same interface
15:57:12 <johnw> much like that finallyE I sent you in a pull request against the either package
15:57:21 <merijn> johnw: Which non-exceptions exceptions are there?
15:57:44 <johnw> merijn: in the exceptions library, short-circuting with a Left value from EitherT will cause that finally block to trigger as the Left "goes by"
15:57:53 <edwardk> I'm happy to take patches to the documentation that clear up that misunderstanding. i'm also willing to consider patches that make it capable of plucking _real_ exceptions out of the air, but that is more dangerous because it would mean it isn't SafeHaskell
15:58:22 <merijn> johnw: oh, right, nothing that I have to worry about then :)
15:58:23 <johnw> edwardk: if you ask me, I like the idea, I'd just rather the function names distinguished it from real exceptions
15:58:35 <edwardk> there i'm not sure i can bring myself to agree
15:58:41 <merijn> johnw: That'd break compatibility with Control.Exception
15:58:49 <merijn> atm it's a drop-in replacement
15:58:50 <johnw> merijn: yes, that's what I want
15:58:58 <johnw> because it doesn't do what Control.Exception does
15:59:05 <johnw> exceptions (such as async exceptions) can still occur
15:59:16 <johnw> and yet, that finally is not doing what the real finally does in that case
15:59:19 <edwardk> Think of the CatchT implementation as a weak toy you can use for when you need to mock IO, not for the main intent of the library
15:59:32 <edwardk> the bulk of the time you'll be working in IO or some transformer stack on top of IO
15:59:34 <johnw> edwardk: ah, that's one way of looking at it
15:59:37 <edwardk> CatchT is really only for mocking
15:59:43 <johnw> ok, I can buy the mocking argument
16:00:11 <edwardk> the purpose of exceptions is to lift catch, etc. over monad transformer stacks
16:00:22 <edwardk> and CatchT exists as a reference implementation of it that can be implemented purely
16:00:40 <johnw> you mean, without the same strict requirements as lifted-base?
16:01:01 <johnw> because I use lifted-base already to catch, etc., over monad transformers
16:01:19 <johnw> but it imposes a MonadBaseControl IO constraint that makes some things impossible
16:01:26 <johnw> (like catching through ContT, a well-known problem)
16:02:27 <edwardk> its fairly similar to that at any rate
16:02:32 <crocket> Do you feel punished when you use java?
16:02:34 <elliott> MonadControl doesn't really make any sense.
16:02:37 <edwardk> MonadBase IO is too strong
16:02:45 <johnw> crocket: I would ask you to take these questions to another channel
16:03:21 <johnw> edwardk: here is some code for you: https://gist.github.com/6126999
16:03:42 <johnw> the throwM triggers the finally block, but the throwIO and the undefined don't, as you probably expect
16:03:56 <edwardk> crocket: We generally try to avoid fielding big 'why does language X suck compared to haskell' inquiries here. It makes for rather toxic discussions and feeds trolls.
16:03:57 <johnw> but with lifted-base, those would get caught
16:04:28 <edwardk> you shouldn't use CatchT with IO
16:04:36 <johnw> fair enough
16:04:43 <johnw> that fits with the point on mocking
16:04:50 <edwardk> its setting up two incompatible systems of handling exceptions
16:04:55 <edwardk> you can now travel through either one
16:05:04 <johnw> so, lifted-base for transformer stacks on IO, and exceptions for transformer stacks not based in IO?
16:05:17 <edwardk> exceptions works on transformers stacks based on IO too
16:05:22 <edwardk> it just _also_ works with Catch as a base
16:05:32 <johnw> but won't it have the same problem as in that example?
16:05:38 <johnw> wait, I'll try with StateT s IO a
16:05:39 <edwardk> will it?
16:05:50 <joelteon> where's that library that ensures that all possible exceptions are caught on the type level?
16:05:53 <edwardk> if it does have a problem with StateT s IO a, then i'd consider it a bug
16:06:11 <edwardk> joelteon: i worked on one with pepe iborra ~4 years back, not sure what happened to it
16:06:27 <johnw> edwardk: yes, it has the same behavior with StateT as with IO
16:06:57 <johnw> and I can't see why it wouldn't, finally doesn't catch real exceptions
16:07:05 <joelteon> edwardk: I saw it on reddit just recently
16:07:13 <hpaste> flebron pasted “Out of stack space?” at http://lpaste.net/91398
16:07:16 <johnw> edwardk: I'll file a bug for ya
16:07:49 <flebron> Could someone (try to ) explain to me where I'm running out of stack space? I'm giving the program about 3000 lines/points, and it's an O(n^2) algorithm, n the number of lines.
16:08:16 <edwardk> johnw: that strikes me as a fairly serious issue. thanks for bringing it up
16:09:15 <johnw> sure thing
16:09:28 <crocket> flebron: You're also here.
16:09:41 <flebron> Indeed I am.
16:09:52 <merijn> johnw: Can you pastebin the StateT code you used?
16:10:01 <johnw> merijn: https://github.com/ekmett/exceptions/issues/14
16:10:42 <flebron> (I assume it's the expression "x <- ts, y <- ts" that's guilty?)
16:10:59 <merijn> johnw: That's still using CatchT
16:11:29 <edwardk> can you remove the CatchT?
16:11:44 <johnw> i'm not sure I follow
16:12:01 <johnw> oh, you mean using finally from Control.Monad.Catch, just not the CatchT transformer
16:12:24 <johnw> then it work
16:12:25 <johnw> s
16:12:29 <edwardk> flip runStateT () $ runCatchT ((do
16:12:29 <edwardk>         -- throwM Overflow
16:12:31 <edwardk>         liftIO $ throwIO Overflow
16:12:35 <edwardk> that is using CatchT on IO
16:12:40 <edwardk> the thing we said doesn't make sense =)
16:12:42 <supki> I think CatchT should move to Control.Monad.Don'tUseOnTopOfIO.Catch
16:12:44 <johnw> ah, ok
16:12:52 <edwardk> supki: hah
16:13:02 <edwardk> Control.Monad.TransButNotForIO.Catch
16:14:33 <johnw> i had high hopes for the layers library too, but it seems to have gone nowhere
16:14:44 <jfischoff> elliot: what's wrong with MonadControl (I don't really use it)?
16:14:56 <johnw> I use MonadControl, it just has its limit
16:15:29 <johnw> it lets you liftWith $ \run > ..., and now you have a lifted calculation which can use "run" to access the enclosing monad
16:15:55 <johnw> but not every monad is able to cross that transition barrier
16:16:06 <johnw> ContT can't, ConduitM can't etc.
16:16:34 <jfischoff> well I'm confused
16:16:44 <johnw> "layers" claimed to solve this for ContT, but in the end did not
16:17:23 <johnw> jfischoff: imagine you have a function foo :: IO a -> IO a
16:17:33 <johnw> you need to "liftIO $ foo x" in order to call foo with some x
16:17:38 <johnw> but what if x is not in IO?
16:17:59 <johnw> then you need to: liftBaseWith $ \run -> foo (run x)
16:19:17 <johnw> anyway, if you want the full details: http://hackage.haskell.org/packages/archive/layers/0.1/doc/html/Documentation-Layers-Overview.html
16:19:24 <jfischoff> like if is x :: StateT Int IO Int?
16:19:29 <johnw> the layers library may not solve the problem as fully as it claims, but its docs are good
16:19:34 <johnw> jfischoff: exactly
16:19:57 <jfischoff> hmm I can't remember needing that
16:20:06 * jfischoff most program moar!
16:20:13 <johnw> you need it if you ever want to use "bracket" in StateT s m a
16:20:21 <jfischoff> ah
16:20:25 <johnw> which lifted-base and exceptions both let you do
16:20:43 <johnw> (and layers, and mmorph)
16:20:49 <johnw> solving it for StateT is not that hard
16:20:55 <jfischoff> exceptions, that's where the devil is :p
16:21:15 <johnw> well, or any lifted computations that taken a computation in its based monad
16:21:22 <johnw> wow
16:21:31 <johnw> well, or any lifted computation that takes a computation in its base monad
16:22:59 <johnw> exceptions are just a very common case of needing this :)
16:23:33 <jfischoff> more reason to avoid exceptions if at all possible
16:23:43 <johnw> you can never avoid exceptions
16:23:52 <johnw> anyone can "kill" your process at any time
16:23:55 <jfischoff> you can minimize
16:23:58 <jfischoff> yes
16:24:19 <jfischoff> but you don't have to throw them indiscrimiantly
16:24:23 <johnw> i've been learning lately that making Haskell properly exception safe takes real thought, and it's not something to be lightly ignored
16:24:28 <edwardk> johnw: sure you can. when you get an exception die ;)
16:24:52 <edwardk> and then shut down the machine, uninstall the vm its on, scrub the operating system on the host box and start over
16:24:55 <johnw> edwardk: and use some kind of transactional framework like STM or ResourceT or something else that does all the cleanup for you :)
16:25:01 <johnw> haha
16:25:15 <johnw> edwardk: the real man's onException
16:25:26 <jfischoff> johnw: right more reason to not take their use lightly
16:25:34 <edwardk> caught an exception, damn, time to code an new operating system
16:25:41 <johnw> I've recently learned the trick of containing exceptional behavior by sparking
16:26:06 <johnw> as far as I'm concerned, IO = exceptions are the rule, and that's how I write my code now
16:26:57 <merijn> johnw: Word, I've been trying to consider how to get my library safe and not leak resources in the presence of exceptions, its...non-trivial
16:27:17 <haasn> when running something causes an exception delete all intermediate output and pretend nothing happened the next time you try. This is what lambdabot does to handle exceptions
16:28:10 <merijn> haasn: That works only if you properly delete all intermediate output :p
16:28:32 <haasn> merijn: I suggest Acme.RealWorld to save and restore the state of the universe
16:29:12 <sclv> edwardk: i actually think that just moving CatchT to a new module would clear it up a bit? Control.Monad.Catch.Pure ?
16:29:36 <edwardk> i'm open to that
16:29:43 <johnw> sclv: that's a great idea
16:29:48 <johnw> Control.Monad.Trans.Catch
16:30:09 <johnw> then you know that if you're importing it, you're asking for what it entails
16:30:15 <edwardk> or we split the existing code out into Control.Monad.Catch.Class
16:30:30 <johnw> or that
16:30:31 <edwardk> and keep Control.Monad.Catch as it is, and write in big honking letters that this is a reference impl?
16:30:48 <sclv> eh i think that the shorter module name should be the one people are encouraged to import
16:30:48 <edwardk> exiling CatchT might make more sense though
16:30:54 <edwardk> yeah
16:31:17 <edwardk> i'd take a Control.Monad.Catch.Pure patch
16:31:56 <merijn> edwardk: Your new dev approach is "I'd accept that patch" and then add them to the repo? :p
16:32:05 <edwardk> yes
16:32:07 <sclv> i guess that this patch falls to johnw then :-)
16:32:11 <edwardk> thats my old approach actually
16:32:16 <edwardk> started it in january or so
16:32:18 <edwardk> works well
16:32:23 <sclv> "old" in edwardk years
16:32:31 <edwardk> sclv on the other hand is too smart to be trapped that way
16:32:43 <edwardk> i've only managed to sucker him into helping with a handful of repos
16:32:51 <sclv> yeah i don't even commit to my own libraries :-P
16:32:52 <edwardk> shachaf on the other hand is glued to like 20-30
16:32:53 <johnw> give me the commit bit, I'll do put it on my list
16:33:28 <edwardk> there ya go
16:33:45 <johnw> ok, i'll see if I can't do that like tonight, so it doesn't fall into my task wastebin
16:34:00 <johnw> i've got some free time this eve, and monad transformer logic is always so much fun
16:34:38 * hackagebot MHask 0.1.0.0 - The category of monads  http://hackage.haskell.org/package/MHask-0.1.0.0 (DanBurton)
16:35:08 <johnw> huh, that sounds like a library edwardk would have written
16:35:32 <johnw> i didn't know other people were allowed yet
16:36:43 <merijn> johnw: edwardk would've just called it "monads" or "categories" :)
16:36:56 <johnw> true, the MHask name isn't quite his style
16:37:04 <johnw> monads
16:37:14 <edwardk> i actually have a 'monads' package i just never released it
16:37:22 <merijn> See, I told you
16:37:30 <edwardk> putting me in charge of the mtl kind of took the pressure off of that one ;)
16:37:38 <merijn> Anyhoo, bed time
16:37:40 <edwardk> and mtl is a shorter name ;)
16:37:58 <johnw> i got so used to using only transformers, that I always lift now and forget that mtl is available
16:38:29 <zzing> If I have liftM unlines case monitors of …     and I get a parse error on 'case', is there an easy solution to fix this?
16:38:34 <johnw> but it lends itself so nicely to monadic parametricity (MonadReader m => m a), that I need to change that
16:38:58 <johnw> zzing: can you show us more actual code?
16:39:16 <johnw> at the very least you would need a $ in front of case
16:39:46 <zzing> https://gist.github.com/iaefai/4609b903c2e44d18bd57
16:39:57 <zzing> line 30
16:39:57 <haasn> wait, why is that even the case. what's the problem with parsing “foo bar case x of y -> z” as “foo bar (case x of y -> z)”?
16:40:45 <johnw> zzing: now, what's the error?
16:40:59 <johnw> ah
16:41:01 <johnw> putStrLn =<<
16:41:08 <johnw> you can't fmap putStrLn in that context
16:41:40 <zzing> johnw, ok, =<< works. What was going on?
16:42:00 <johnw> haasn: I tried putStrLn case True of True -> "foo" in ghci, it doesn't work
16:42:12 <johnw> zzing: putStrLn <$> will return you an IO (IO ())
16:42:17 <johnw> but you need an IO () in that context
16:42:29 <haasn> johnw: yes, I realize it doesn't work. But why doesn't it work? :)
16:42:31 <johnw> you can either putStrLn =<<, or join $ putStrLn <$>
16:42:42 <johnw> haasn: good question, I don't know!
16:43:14 <haasn> a question not to be answered tonight, at any rate; bed time
16:43:25 <zzing> johnw, is there any better way I could do the stuff you see?
16:43:28 <johnw> :t putStrLn <$> (return "Foo" :: IO String)
16:43:28 <lambdabot> IO (IO ())
16:43:37 <tabemann> johnw: putStrLn $ case True of True -> "foo" does work
16:43:40 <xplat> i wonder how MHask compares to mmorph
16:44:12 <DanBurton> it's basically the same
16:44:20 <johnw> DanBurton!
16:44:24 <jfischoff> heh I was just about to ping you :)
16:44:59 <DanBurton> except that I add Monad constraints all over, because I defined MHask objects to be the instances of Monad
16:45:46 <DanBurton> I had a data type that I wanted to make an instance of MFunctor, but Tekmo only had the Monad constraint on one of the two objects, which messed me up because my implementation required the other object to be a monad
16:46:54 <DanBurton> plus I wanted to have the comonad and the indexed stuff too, so I just made my own package
16:47:00 <johnw> zzing: as for "better", I don't know the code well enough to say
16:52:54 <danbst> @pl \x -> x
16:52:54 <lambdabot> id
16:53:09 <danbst> @pl \(a, b) -> (a, b 1)
16:53:12 <lambdabot> ap (flip ((.) . (,)) ($ 1) . fst) snd
16:53:12 <lambdabot> optimization suspended, use @pl-resume to continue.
16:53:30 <johnw> for that, you may want to "fmap ($ 1)" instead
16:54:21 <dmj> @src not
16:54:21 <lambdabot> not True   =  False
16:54:21 <lambdabot> not False  =  True
16:54:25 <danbst> johnw, thanks. but functor instance for tuple is confusing me
16:54:39 <johnw> it just "maps" the function over the second element
16:54:53 <johnw> fmap f (a,b) = (a, f b)
16:55:02 <danbst> why second?
16:55:15 <johnw> due to the syntax of the Haskell type system
16:55:33 <johnw> you can expression Functor ((,) e), but not anything else
16:55:49 <danbst> ah
16:56:16 <johnw> also, for it to be a functor that fmaps over both elements, those elements would have to have the same type
16:56:37 <johnw> the nature of a functor is that it maps a single object (here: type)
16:56:51 <dmj> danbst: data Pair a = Pair a a would be an example where it maps both
16:56:56 <johnw> right
16:57:03 <johnw> fmap f (Pair x y) = Pair (f x) (f y)
16:57:16 <johnw> to do otherwise would require f and g, which is exactly what Bifunctors do
16:57:24 <johnw> bimap f g (x,y) = (f x, g y)
16:57:48 * tabemann is going to be doing a presentation on STM at work, and was originally going to use Haskell for his non-pseudocode examples (due to Haskell having a really nice and *simple* STM system), but his coworkers have been trying to convince him to use an STM system for Java instead, despite STM not working out nearly as well with Java :(
16:57:54 <johnw> you could always make a: newtype Leftwards = Leftwards (a,b)
16:58:04 <danbst> I'm supposed to better use lens
16:58:07 <johnw> and define fmap f (Leftwards (a,b)) = Leftwards (f a, b)
16:58:13 <johnw> yes, then it's much easier :)
16:58:30 <johnw> (a,b) & _1 %~ f
16:58:47 <Zenol> tabemann> Just don't listen to your coworkers? :D
16:58:59 <dmj> danbst: you could use arrows too.
16:59:04 <dmj> > first (+1) (1,2)
16:59:05 <lambdabot>   (2,2)
16:59:21 <johnw> tabemann: yeah, they are trying to convince exactly because they need to see how nicely Haskell dose it
16:59:26 <tabemann> Zenol: I was thinking of potentially providing *both* Java and Haskell examples
16:59:45 <johnw> if they knew, they wouldn't be pushing Java :)
16:59:52 <Zenol> tabemann> But you'll have to do the work twice :p
17:00:21 <johnw> STM in Haskell isn't just nicer, it's actually *fun*
17:00:31 <johnw> each time I use retry in some clever way, I feel like I'm getting away with something
17:00:32 <tabemann> they're pushing Java because it's a Java company and that's what all the programmers know (even though some of our code is in C too)
17:00:47 <tabemann> I was looking at STM systems for Java today, and yuckk...
17:01:05 <Clint> make doing it in java an exercise for the audience
17:01:13 <johnw> Clint++
17:01:20 <tabemann> nothing even approaching the elegance of STM in Haskell, or even, say, STM in Clojure
17:02:23 <tabemann> Clint: haha
17:03:50 <mapreduce> STM in Java sounds like a job for aspects or code generators.
17:03:51 <sclv> i'd like to read about clever uses of retry!
17:04:04 <erisco> :o I made it work quchen
17:04:08 <erisco> I made it wooooork
17:04:19 <mapreduce> Doing it in plain Java sounds really painful.
17:04:33 <erisco> I *was* able to do it by revealing partial information :D this is the smartest I've felt in forever
17:04:42 <tabemann> the idea of doing STM in Java, aside from crap like having to wrap everything in Runnable, bothers me because it is too easy for transactions to leak state like a sieve
17:05:01 <edwardk> STM in haskell has the benefit that it just works. you aren't constantly worrying that you missed some extra effect, or that you overlooked something
17:05:02 <erisco> with this I can now do left recursion with my top down parser
17:05:08 <c_wraith> tabemann: did you see the .NET team's report on their failure to make STM work in .NET?
17:05:21 <tabemann> c_wraith: I heard it mentioned, but I didn't see their report
17:06:38 <tabemann> edwardk: yep; even the other language that really sticks out to me as having a really good STM system, Clojure, still has the possibility for transactions to leak state, even though in Clojure it isn't nearly as easy to do it by accident as it is in Java
17:06:39 <johnw> sclv: I've been meaning to blog about it
17:06:45 <c_wraith> tabemann: http://www.bluebytesoftware.com/blog/2010/01/03/ABriefRetrospectiveOnTransactionalMemory.aspx
17:06:59 <sclv> its a great topic
17:07:00 <erisco> like ... any context free grammar aint no thang :D
17:07:12 <johnw> I like that when I try to use IO in STM, my hand gets slapped and I say to myself, "Oh yeah, right..."
17:07:22 <edwardk> erisco: what's this?
17:07:39 <erisco> my parser! I've been on here for about a month working on it
17:07:44 <tabemann> there *is* an escape hatch to do IO in STM, actually, but you can't do it by accident
17:08:20 <johnw> sclv: like, here's a function that implements waiting on a process's state.  With retry, it's as straightforward as possible: https://gist.github.com/6127399
17:08:21 <erisco> ~60 lines of Haskell and I can parse any context free grammar ... even ambiguous :)
17:08:46 <erisco> so, uh, thanks for all the help guys
17:09:27 * tabemann is planning on showing the Dining Philosophers using TMVar, implemented itself with retry, and showing how what is a *hard* concurrency problem without STM is made into an utterly trivial one with STM + retry
17:09:30 <johnw> and not only that, but the scope of the retry is decided by my caller, not by me
17:09:44 <johnw> this function just composes with whatever transaction it's called from within
17:10:17 <johnw> MAGIC I SAY!
17:11:19 <johnw> actually, STM would be a great topic to speak on in NYC
17:12:02 <johnw> I see it as one of Haskell's "unsung heroes" at the moment; it's not getting as much press as it deserves
17:12:13 <c_wraith> tabemann: I always feel like the proper solution is to teach the philosophers how to get by with a single fork.
17:12:20 <tabemann> c_wraith: haha
17:12:51 <erisco> chopsticks aren't they?
17:12:51 <c_wraith> They need two forks each?  That's just greedy!
17:12:56 <erisco> rather hard to eat with one chopstick
17:13:07 <Clint> depends what you're stabbing
17:13:11 <tabemann> erisco: the classic presentation has forks, but some do have chopsticks
17:13:11 <johnw> erisco: exactly as hard as clapping with one hand
17:13:15 <erisco> it is a bowl of rice, no?
17:13:35 <c_wraith> if the table was set with one chopstick per individual, I'd say the problem was with the people setting the table.
17:13:37 <tabemann> spaghetti in the presentation I've seen... but then I for one can eat spaghetti with one fork
17:13:55 <Ghoul_> does alloca always allocate on the heap?
17:14:00 <erisco> the disappointing thing to me is that I thought it was a riddle rather than an abstract framework for discussion
17:14:16 <tabemann> the original presentation by Dijkstra used computers sharing disk drives
17:14:22 <johnw> Ghoul_: I thought it allocated on the stack
17:14:24 <c_wraith> Ghoul_: yes, though that doesn't mean all that much.  GHC's allocator is just a pointer bump, except when it's at the end of a page.
17:14:29 <johnw> malloc is the heap
17:14:29 <erisco> I was hoping for rule set that could be given to each philosopher such that they could all eat
17:14:40 <Clint> i thought ghc alloca used malloc
17:14:42 <c_wraith> johnw: the FFI alloca, not C's alloca
17:14:44 <johnw> ah, ok
17:14:59 <johnw> so GHC's alloca is just a scoped malloc?
17:15:03 <c_wraith> yeah
17:15:07 <erisco> but given the symmetry, I don't think any such rule set is possible
17:15:15 * tabemann wants to find one or two other concurrency problems to present other than just the Dining Philosophers
17:15:29 <erisco> now, if it was a straight table, rather than round, you can probably make something up
17:15:35 <tabemann> they have to be pretty trivial to implement using STM, though, because the code has to fit onto PowerPoint slides
17:15:45 <johnw> tabemann: lockfree queues
17:15:50 <jfischoff> wat? alloca ~ malloc?
17:16:06 <tabemann> johnw: i.e. reimplement TChan basically
17:16:10 <Ghoul_> the catch is whether malloc can be cleaned up by the GC?
17:16:14 <Ghoul_> I assume not?
17:16:21 <johnw> yep, and then compare it with the complexity of getting it right without STM
17:16:36 * tabemann has seen a number of different examples of ways to implement TChan-like things
17:17:00 <johnw> another one: the many reader one writer type of gate
17:17:12 <tabemann> probably the biggest difference between examples being the exact data structure used to represent the queue and whether more than one reader is allowed for a given writer
17:17:17 <tabemann> yeah
17:17:22 <johnw> that is just trivial beyond belief in STM, but rather tricky with locking
17:17:39 <tabemann> STM makes many things seem trivial beyond belief
17:18:02 <johnw> i just started reading Marlow's concurrency book last night
17:18:17 <sclv> johnw that task code is nice
17:18:17 <jfischoff> pretty dope
17:18:19 <johnw> well, I'm in the parallel section of it
17:18:33 <Clint> hmm, http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Foreign-Marshal-Alloc.html#alloca
17:18:51 <tabemann> is the copy of Marlow's book online incomplete or is it complete now?
17:18:56 <jfischoff> that is where it truly dawn on me, how poorly I understand exceptions
17:19:06 <johnw> i dunno, I bought the O'Reilly copy just out of solidarotiy
17:19:22 <sclv> i get your point about using retry directly more clearly now
17:19:45 * tabemann is still considering buying the dead tree book just to have a copy of it on hand
17:19:46 <sclv> reputedly the online version will be taken down or go behind a paywall after a certain date
17:20:09 <sclv> at least that's what sm said he expected to happen on the reddit thread
17:20:15 <Soft> Has someone here succesfully installed haskell-gtk on arch linux?
17:21:18 <Soft> it requires a different version of libpng but it's not listed as a depency
17:22:01 <tabemann> okay, they actually already closed the book online
17:25:24 <tabemann> (I'm buying it because I just really want a copy of that book on hand)
17:27:28 <dmj> tabemann: http://chimera.labs.oreilly.com/books/1230000000929/index.html
17:28:03 <dmj> i bought it tho
17:31:28 <tabemann> my, as an ebook it is almost 18 megs over my thin straw of an Internet connection
17:33:53 <tabemann> (even though it was probably unnecessary, I felt that as long as I was paying money for it, I might as well get the dead tree edition too, even though it meant paying a bit more)
17:34:54 <_Cactus_> Hi, any idea where would be a good place to get help with haskell.org mailing lists? I'm trying to subscribe to ghc-dev, but I never get the acknowledgement email
17:35:32 <dmj> _Cactus_: http://www.haskell.org/haskellwiki/Mailing_lists
17:36:34 <dmj> _Cactus_: Oh sorry, that wasn't helpful. I'm unsure.
17:37:32 <_Cactus_> dmj: yeah...
17:38:25 <geekosaur> all the lists were kinda broken for a while; possibly that one still is. dunno who to contact about it though
17:38:52 <_Cactus_> I guess I'll try the two email addresses listed as admins of the specific mailing list
17:39:35 <dmj> _Cactus_: is this where you subscribed? http://www.haskell.org/mailman/listinfo/ghc-devs
17:39:50 <dmj> here's a list: http://www.haskell.org/mailman/roster/ghc-devs
17:40:00 <_Cactus_> Dmj: it's what I tried, yes
17:40:49 <_Cactus_> I'm not on that list because when you sub, you're supposed to get an email with a link to confirm
17:41:01 <_Cactus_> But I never get that
17:46:04 <_Cactus_> Ok let's see if my email to ghc-devs-owners bears fruit
17:46:21 <_Cactus_> Bye
17:56:36 <tabemann> okay, I'm implementing multireader channels with STM - does anyone know anything on how to "boot" the readers when there is no values in the channel (because the TMVar in the reader has to point at a cell, and I can't just tell the writer about that TMVar as that TMVar may be duplicated)?
17:58:12 <tabemann> Marlow's book covers the implementation of single-reader STM channels, but not multi-reader ones
17:58:13 <Gracenotes> Maybe someone knows
17:58:28 <Gracenotes> Maybe.. it's Maybe!
17:58:49 <Gracenotes> or Maybe Not
17:58:56 <tabemann> the only approach I can think of at the moment is making each cell have a *mutable* value, and making that a Maybe
17:59:08 <tabemann> so that there is initially a single cell in a channel, with Nothing as its value
17:59:38 <tabemann> and that when a value is written into the channel, its value is changed to Just value
17:59:47 <tabemann> feels inefficient though
18:00:17 <tabemann> oh better
18:00:51 <tabemann> I make Cell { ...} and EmptyCell { ... } constructors, and when a reader tries to read an EmptyCell value it just skips over it
18:02:50 <pentace> Is there any documentation/tutorial about how to structure GUI code in Haskell? I have a GUI program with only few elements but a lot of functionality (event handlers, processing of user commands, etc.) and so far everything is defined in a quite bloated main function.
18:03:40 <pentace> The problem in separating the code is that I need the GUI elements and stored data in nearly each part of the code
18:05:36 <pentace> So I thought about definig a type "newtype GUIAction a = GUIAction (ReaderT (IORef GUI) IO a)" with Monad instance and an instance of "MonadState GUI GUIAction". But that feels a bit like misusing the MonadState class :S
18:24:42 <hpaste> tabemann pasted “Can you check this for correctness (or possible improvements)?” at http://lpaste.net/91401
18:25:26 <tabemann> and yes, I did leave out new*IO functions, but I was meaning for this to be succinct, as it has to go into PowerPoint slides
18:25:35 <mgsloan> Philippa: Yeah, I'm really interested in the UI of better type info / errors.  Very curious to hear more ideas about such stuff
18:27:53 <danharaj> edwardk: I'm building up material for a talk on kan extensions. Want to give me a few more leads? My two lines so far are a paper by Hinze on codensity and Johann + Ghani's line of papers that uses them to derive fold/build for various varieties of datatypes.
18:27:54 <mgsloan> Philippa: In particular if it's closer to the GHC-level implementation details, I've mostly been thinking about what the UI end of things would be like.  Anyway, feel free to email any rough ideas or notes or whatever to mgsloan @ gmail
18:28:04 <parcs> in 'unsafeDupableInterleaveIO (unsafeInterleaveIO foo)', does foo have a chance of being called twice?
18:28:14 <edwardk> danharaj: have you read the comonad.com posts?
18:28:29 <danharaj> edwardk: of course! but they are not cached in my brain and I can't refresh them lately :P
18:28:43 <edwardk> http://comonad.newartisans.com/reader/index.html
18:28:45 <edwardk> thank johnw
18:29:00 <danharaj> thanks obama
18:29:04 <danharaj> I mean johnw.
18:29:18 <edwardk> johnw: hrmm, i wonder if i should just point comonad.com to your mirror for now
18:29:34 <danharaj> edwardk: you may get complaints that a few posts are missing
18:29:43 <danharaj> this may be more or less than all of them being missing
18:29:45 <edwardk> better than the nothing they get now
18:30:05 <hpaste> tabemann revised “Can you check this for correctness (or possible improvements)?”: “Can you check this for correctness (or possible improvements)?” at http://lpaste.net/91401
18:30:22 <danharaj> edwardk: By the way, my boss is giving a talk at CUFP so I might be in Boston that week!
18:30:29 <edwardk> nice
18:30:35 <edwardk> i'm also giving one there
18:30:49 <zRecursive> morning
18:30:49 <danharaj> edwardk: should I prepare my questions for you in a pdf or hardcover volume set?
18:32:25 <edwardk> pdf is better that way i can skim them on my ipad, and it'll weigh less
18:35:12 <sclv> danharaj: this is a talk for ny haskell?
18:37:48 <danharaj> sclv: you weren't supposed to know until I was done with it
18:38:03 <sclv> haha well then don' advertise on irc :-P
18:38:14 <sclv> i'll forget it tho, don't worry
18:38:27 <danharaj> sclv: I heard you gave the last talk and it was good?
18:38:33 <danharaj> some basic category theory ;)
18:38:36 <sclv> that's what i heard too
18:38:45 <tabemann> little question I'm pretty sure I'm right about but I'm asking just to make sure: you can't create recursion with <-, right?
18:38:47 <danharaj> Ryan told me you covered adjunctions and that was my reaction.
18:38:54 <danharaj> I think I drank too much koolaid
18:39:14 <danharaj> tabemann: you can if your monad is an instance of monadfix and you enable an extension
18:39:23 <danharaj> and there is slightly special syntax for it
18:39:29 <sclv> the two refs you have on kan extensions are the two main ones i know of
18:40:27 <edwardk> he last chapter of categories for the working mathematician also goes into kan extensions (the one before the 2-category extension if you have a later edition)
18:40:58 <danharaj> edwardk: of course. I was wondering mostly about interpretations in functional programming since it seems to be a relatively recent way of looking at / deriving things.
18:41:26 <edwardk> then that stuff, and the tricks from abusing codensity to speed up free monads are about it
18:41:30 <danharaj> I am intrigued by the striking language of Johann and Ghani: Ran is generalized continuation types.
18:41:41 <edwardk> yeah thats the way i phrase it too
18:41:53 <edwardk> a right kan extension is just generalized continuation passing style
18:42:45 <danharaj> edwardk: what about kan lifts?
18:42:52 <sclv> its worth going over why right and left kan extensions are described as existential and universal quantification
18:42:52 <danharaj> there's hardly any talk about those :P
18:43:08 <sclv> i think not just in an fp context
18:43:11 <danharaj> sclv: I thought general ends and coends were existential and universal quantification.
18:43:22 <danharaj> (something I need to grok)
18:43:28 <edwardk> danharaj: good point
18:43:42 <danharaj> edwardk: speaking of which, could you clarify a paragraph on ncatlab for me?
18:44:15 <edwardk> throw it out here, and i'm sure someone like dolio will have it solved for you instantaneously ;)
18:44:22 <sclv> i'm sure there's some relation between the two described that way
18:44:33 <danharaj> http://ncatlab.org/nlab/show/endomorphism
18:44:33 <sclv> (via the end formula for extensions, etc)
18:45:01 <danharaj> I was wondering about how that construction of the endomorphism monoid on general ends.
18:45:09 <darinm> so any haskell/cabal and mac/homebrew folks seen this https://github.com/mxcl/homebrew/pull/21231 and https://github.com/mxcl/homebrew/pull/21335? Homebrew adding cabal package dependency checking and apparently installing with cabal --global. Seems like a bad idea to me but I don't know enough to complain/comment
18:45:16 <danharaj> Also I am pretty sure there is a typo? They should be talking about th terminal diagram?
18:45:41 <danharaj> darinm: I use hsenv on my mac to keep my paths honest and clean.
18:45:43 <carter> i'm going to yell at them politely
18:45:44 <c_wraith> Aaaaaaagh.  I forgot about CPP's refusal to handle source files with ' in them.
18:46:37 <tabemann> CPP doesn't allow you to use prime in your source files?!
18:46:39 <edwardk> never seen that thing before
18:46:52 <edwardk> i'd sound out dolio or ddarius
18:47:21 <Clint> it gets whiny about unbalanced '
18:47:50 <tabemann> I always wondered why they even allowed the C preprocessor into Haskell anyways
18:47:56 <c_wraith> I need new syntax for promoted data types now.
18:48:03 <c_wraith> I can't use 'Foo
18:48:05 <tabemann> I mean, if they need its functionality, why not just write their own, better, preprocessor?
18:48:12 <Clint> you can work around it by adding another apostorphe on that line
18:48:16 <Clint> or apostrophe
18:48:21 <c_wraith> oh, interesting.
18:48:29 <tabemann> but that's an unnecessary hoop to jump through
18:48:35 <danharaj> edwardk: Thanks for the nameping. There's another thing I've been thinking of about ends. Particularly how abstract syntax can be represented by functors over a category of contexts. I was thinking that *closed* terms could be gotten by using an end to quantify over contexts. But that's a general speculation I'm researching on.
18:48:35 <Clint> yeah, it's annoying
18:49:32 <danharaj> edwardk: mostly I want to understand how Oleg's finally tagless stuff has initial semantics in *some* category, I just have to figure out where it is. Also initial semantics for mixed variant functors.
18:49:47 <edwardk> danharaj: i hate to ask the predictable question, but have you looked at bound yet?
18:50:02 <danharaj> edwardk: That is my favorite kind of question to get back from you :P
18:50:20 <edwardk> =)
18:50:45 <edwardk> i just had to prefix that with that because i could practically hear sclv groaning as i wrote it
18:51:07 <danharaj> edwardk: We are big fans of you at the office.
18:51:17 <danharaj> you and Bryan O'Sullivan power our tech.
18:51:21 <edwardk> heh
18:51:48 <c_wraith> wow...  I just realized bindings-DSL works the way it does *specifically* to give you a route around the ' problem.
18:52:07 <dolio> The tagless stuff is Church encoding.
18:52:11 <carter> dysinger thanks for chiming in, do you mind if i claim we've both contribed to various haskell build tooling?
18:52:13 <dolio> Using type classes to avoid higher-rank types.
18:52:30 <danharaj> edwardk: I am getting a little obsessed with giving categorical semantics to Haskell right now hence my lean on the theoretical side of variable binding languages.
18:52:51 <danharaj> I have a crazy scheme to turn end/coend calculus into a programming language I guess :P
18:53:23 <danharaj> There is a big gaping hole where my understanding of parametricity should be though...
18:53:43 <sclv> starting with ends would be a good way to structure a talk too...
18:54:14 <edwardk> anyways you should be able to view a classic hoas style term in end terms, look into the fegaras and sheard catamorphism, and my old 'rotten bananas' post, the xmap machinery was about dealing with variables that occurred in both positive and negative position.
18:54:32 <edwardk> split that into two arguments that are related they'd be the positive and negative term for the end
18:54:49 <Saizan> danharaj: bob atkey has a cool paper on building a parametric model of dependent type theory through categories with families
18:54:57 <sclv> hm i think i had a story for hoas as an adjoint too but i forget it
18:55:20 <dolio> And you can read off ends/coends as universal or existential quantification by analogy of dinatural transformations as universal quantification, I think.
18:55:29 <scshunt> fffffff
18:55:31 <scshunt> that is all
18:56:27 <dolio> Coend J -> R ~ J => Const R = forall x. J x -> R
18:56:51 <edwardk> i just had something come up where i needed to view existential quantification as mapping from one indexing kind to another unit kind and it was all quite natural. i should probably figure out how to write that up, and then fix up the blog so i have some place to write it up ;)
18:56:59 <dolio> The latter of which is the same as (exists x. J x) -> R.
18:57:41 <edwardk> (basically in 'indexed' i wanted to add higher kinded maps, so you can have keys that take a type parameter yielding values with a matching parameter, analogous to indexed monads, etc.
18:57:42 <dolio> You just have to reinterpret quantification as enforcing naturality in whatever category the objects you're quantifying over live in.
18:58:18 <edwardk> but then i wound up needing to work with tuples of key value pairs, and tying off those pairs existentially, but i wanted to see about getting away without losing the 'index' parameter entirely
18:58:20 <dolio> And I guess I should have put x in there twice.
18:58:42 <edwardk> anyways i should try to figure out how to make that not suck
18:59:21 <dolio> And for ends it's: forall x. R -> J x x = Const R => J ~ R -> End J, and you move the quantifier to the right.
19:04:35 <tabemann> hmm... from reading the docs, there apparently is a question as to how random the numbers produced by applying System.Random.split to System.Random.StdGen... anyone know anything about this?
19:04:50 <tabemann> (I wonder because it's an extremely useful function, to say the very least)
19:05:16 <tabemann> s/.../are ...
19:06:15 <carter> dysinger darinm your posts were way more articulate than mine
19:06:17 <carter> wo!
19:22:15 <Ghoul_> Ugh, I shouldn't be getting frustrated at people for the reasons I do, but I really hate it when people send generic responses down mailing lists
19:22:29 <Ghoul_> especially when it shows that they were even more obnoxious than I
19:22:59 <Ghoul_> How much longer will comonad be down? :)
19:23:34 <edwardk> go to the comonad.newartisans.com mirror in the meantime
19:23:45 <Ghoul_> Oh, cool
19:24:05 <carter> a johnw  production?
19:24:08 <edwardk> yeah
19:24:11 <edwardk> johnw++
19:24:15 <carter> he's a cool guy
19:27:34 <danharaj> looks like I missed an interesting convo for pizza :3
19:29:31 <carter> food
19:30:07 <hgolden> hi. is there a "server" (runtime-only) installation of the haskell platform for windows?
19:30:51 <carter> hgolden yes: its called theres not runtime, just CPU + binary code :)
19:31:20 <carter> statically linked haskell code has not runtime deps to run
19:32:01 <hgolden> carter: what if i want dynamic linking?
19:32:08 <ion> % ldd .cabal/bin/hlint | grep gmp
19:32:09 <ion> libgmp.so.10 => /usr/lib/x86_64-linux-gnu/libgmp.so.10 (0x00007fd8fddc3000)
19:32:24 <danharaj> edwardk: is there a write-up on ermine yet?
19:32:51 <edwardk> danharaj: no, but there is a video and an irc channel ;)
19:33:03 <danharaj> ooh
19:33:14 <edwardk> #ermine
19:33:16 <edwardk> let me find the video
19:33:44 <edwardk> http://www.youtube.com/watch?v=QCvXlOCBe5A
19:33:54 <ion> Ooh
19:34:26 <edwardk> and of course, haskell and scala implementations on github.com/ermine-language
19:34:43 <edwardk> though the haskell one is still in-progress
19:35:32 <edwardk> the channel is much more active during the business day ;)
19:49:18 <carter> oh? a practical FP lang eh? :)
19:52:57 <tertl3> carter aye
19:53:06 <carter> woot
19:53:12 <tertl3> woot woot
19:56:34 <tertl3> are being being sarcastic or just making a joke @ <carter> oh? a practical FP lang eh? :)?
19:56:53 <tertl3> i was going to suggest F# for increased practicality
19:57:02 <tertl3> at least in windows environment
19:57:59 <carter> i'm sure they could port ermine to .net if they wanted to :)
19:58:02 <carter> they're really smart
19:58:47 <tertl3> is that like scalaz?
19:58:50 <tabemann> practicality... I for one find any more "practicality" than, say, Haskell or OCaml to be somewhat distasteful in practice, as "practicality" almost always means compromising the core values of a language
19:59:24 <tabemann> (Haskell and OCaml both have plenty of compromise already, and at least from what I have read, too much for some even)
19:59:24 <carter> ermines really cool
19:59:27 <solrize> i haven't really looked at ocaml.  it sounds too practical to be interesting
19:59:56 <solrize> i looked at the ermine github page but don't see anything about the language -- did i look in the right place
20:00:20 <tabemann> solrize: well it's an impure, strict language, so that is plenty of "practicality" as it is
20:00:31 <solrize> ocaml?
20:00:34 <tabemann> yeah
20:01:11 <solrize> what about ermine?
20:01:15 <tabemann> as for F#, that's basically OCaml horribly bastardized to fit the .NET world... (i.e. stripped of all the interesting stuff from OCaml, such as parameterized modules)
20:01:20 <tabemann> I've never looked at ermine
20:02:55 <tabemann> I've seen the source tree, but I haven't seen anything written about it, so I can't say much about it as staring at the compiler source isn't that enlightening
20:04:08 <sclv> solrize: this is the right page https://github.com/ermine-language/
20:04:19 <solrize> yeah i looked there
20:04:25 <sclv> that's what there is
20:04:41 <sclv> its an internal tool now open sourced and under active development
20:04:43 <solrize> This is an experimental compiler for the Ermine programming language developed at McGraw Hill Financial.
20:04:55 <solrize> but i mean, is there a 4 line description of the language?
20:05:02 <sclv> "haskell, but on the jvm"
20:05:06 <solrize> oh
20:05:14 <carter> with type safe joins for data manipulation
20:05:16 <sclv> "with some differences regarding typing database relations"
20:05:17 <sclv> right
20:05:17 <carter> because it has Row types
20:05:36 <carter> does it still use bound for variable binding?
20:05:39 * tabemann cringes at the "on the JVM" part
20:05:39 <carter> on the haskell verison?
20:05:45 <solrize> what's frege?  haskell on the jvm?
20:05:47 <solrize> and scala?
20:05:48 <sclv> afaik -- you can look at it
20:06:00 <sclv> frege is haskell on the jvm but with way more comprimises
20:06:09 <sclv> scala is java on the jvm
20:06:13 <solrize> ur/web looked interesting and has row types, are ermine's related to that?
20:06:20 <sclv> but a bit nicer
20:06:27 <solrize> hmm
20:06:31 <tabemann> I wonder when people call Scala an FP, as from reading about it it just seems like a nicer Java
20:06:45 <sclv> related in the broad sense yes. the actual system is different in both
20:07:00 <tabemann> OCaml is quite the FP compared to Scala, even with its own compromises, i.e. not being pure
20:07:59 <tabemann> as JVM languages go, Clojure seems far more FPish than Scala...
20:08:50 <finishingmove> scala is hybrid really
20:08:55 <tabemann> (Clojure being Lisp on the JVM for the record)
20:08:56 <finishingmove> clojure definitely more fp
20:09:50 <Gracenotes> this discussion might be amiss, as well, without mentioning Frege
20:10:13 <tabemann> at least with Clojure they made some good design decisions from the get-go, such as basically making everything immutable except when the user specifically declares it to be mutable or when forced to be mutable to be interoperable with Java
20:10:51 <zRecursive> a bit like erlang ?
20:10:51 <tabemann> and building STM into the very core of the language
20:10:56 <solrize> too bad about the jvm part.  other than that clojure seems like about the best lisp out there right now
20:11:21 <mapreduce> Scala defaults to immutable in some areas, and the normal coding style is to minimise mutability.
20:11:47 <tabemann> the biggest compromise I've seen with Clojure is that they don't really support true tail recursion, with only self-recursion and trampolining being implemented, and being invoked explicitly
20:11:51 <mapreduce> It improves over Java on types in ways that matter for FP (kinds, particularly).
20:11:56 <mapreduce> Clojure has.. 1 type. :)
20:12:37 <tabemann> so things like CPS are basically impossible as-is in Clojure
20:12:38 <mapreduce> Tail recursion is a tricky one when you don't have the whole program available at compilation time, which I assume is true of Clojure too.
20:12:48 <Gracenotes> JVM makes things a bit tricky
20:12:52 <mapreduce> That's why people push for the JVM to have it.
20:13:07 <tabemann> yeah, your runtime needs to support tail recursion for it to work
20:13:20 <mapreduce> or you need to do whole program compilation.
20:13:21 <Gracenotes> who knows what the Java security model for that would look like
20:13:37 <Gracenotes> mapreduce: or you can have sufficiently descriptive interface files.
20:13:54 <mapreduce> I don't get how that helps.
20:14:11 <dolio> Does the security stuff actually get used?
20:14:15 <mapreduce> Another option is a custom classloader that does a transformation to TCO.
20:14:22 <S11001001> dolio: lots
20:14:25 <Gracenotes> oh, hm, it helps in some cases with inlining, but not for generalized tail recursion I suppose.
20:14:29 <tabemann> the problem with the Java security model is that they have this silly idea that you ought to be able to look at the state of the entire stack and magically see what code is bad
20:14:33 <mapreduce> dolio: Hardly at all. :)
20:15:01 <Gracenotes> I think I might be thinking too specifically of Haskell here
20:15:01 <mapreduce> It's mostly for the client side (applets etc.) which are a relatively small use of Java.
20:15:03 <tabemann> and of course tail recursion conflicts with that, as tail recursion replaces the current stack frame altogether
20:15:06 <dolio> Right.
20:15:35 <mapreduce> tabemann: The raised objections have been more about programmers not understanding stack traces.
20:15:43 <dolio> S11001001: Need to make sure my applets that generate text on my website are secure.
20:15:55 <tabemann> well programmers should understand tail recursion, and if they don't, their loss
20:16:21 <Gracenotes> tail recursion is kind of a particular operational thing
20:16:28 <Gracenotes> just use infinite stacks
20:16:30 <mapreduce> tabemann: Unfortunately it's novice FPers that get hit by this more than others.
20:16:32 <tabemann> what is gained from tail call optimization far outweighs a slight bit of difficulty on programmers' part when debugging
20:16:33 <Gracenotes> :)
20:16:48 <mapreduce> Ah, I misunderstood, and I agree.
20:17:13 <tabemann> Gracenote: or do *all* returns CPS-style, and just unwind the entire stack when you run out of room
20:17:15 <tertl3> well look what you started carter
20:17:30 <carter> damn, it was on accident too
20:17:57 <carter> tabemann chicken scheme does that :)
20:18:04 <zRecursive> :t (*>)
20:18:04 <lambdabot> Applicative f => f a -> f b -> f b
20:18:05 <carter> with the stack being the heap
20:18:06 <tabemann> carter: exactly
20:18:16 <carter> but that sort of stack inspection is problematic on jvm
20:18:20 <carter> i think .net lets you do stuff maybe
20:19:07 <tabemann> too bad .NET is a Microsoft product, as it's definitely better-designed than the JVM...
20:20:06 <mapreduce> On the JVM you'd probably have to be as low level as a garbage collector to get at that info.
20:20:43 <carter> mono is pretty cool these days
20:20:49 <mapreduce> .NET has other considerations.  Apparently it's why F# doesn't have kinds.
20:21:07 <carter> xamarin's really using their business as an excuse to invest in mono
20:21:10 <carter> which is cool
20:21:31 <Gracenotes> in what way is F#'s type system is limited by .NET?
20:21:39 <Gracenotes> it seems like a cosmetic thing
20:21:53 <mapreduce> Gracenotes: I believe it can't have kinds because the runtime doesn't have them.
20:21:56 <tabemann> part of me just doesn't trust Microsoft, which has a level of irony to it since GHC is basically a product of Microsoft Research these days
20:22:04 <mapreduce> whereas Scala can because the runtime doesn't have any generics.
20:22:18 <tabemann> Gracenotes: doesn't F# lack things like parameterized modules too?
20:22:21 <leroux> tabemann: How's GHC a product of MSR?
20:22:36 <tabemann> leroux: you do know who employs the two SImons, right?
20:22:39 <leroux> Yes.
20:22:41 <sclv> only one now
20:22:48 <sclv> the other simon is employed by facebook
20:22:53 <sclv> and not doing core ghc work
20:23:15 <Gracenotes> the .NET runtime has an opinion on the types of runtime objects such that kinds are disallowed?
20:23:34 <tabemann> why would you jump from Microsoft Research to Facebook?
20:23:48 <tabemann> at least MSR does support basic research
20:23:50 <mapreduce> Gracenotes: I believe so but have no details to hand.
20:24:12 <yaron> Great minds require new problems from time to time.
20:24:14 <Gracenotes> okay, yeah, erase everything I say
20:24:40 <Gracenotes> even the values themselves. ahm.
20:24:45 <dolio> Presumably F# doesn't have kinds because it's an ML derivative, which also doesn't have kinds.
20:25:43 * elliott suspects Simon Marlow is better at picking jobs that Simon Marlow will like than tabemann :P
20:26:04 <mapreduce> Gracenotes: dolio: Evidence for my point: http://visualstudio.uservoice.com/forums/121579-visual-studio/suggestions/2228766-add-higher-order-generics-to-f-type-classes-
20:26:10 <dolio> I guess that might also mesh better with .net generics, though.
20:26:40 <carter> agree with elliott
20:26:50 <carter> he's still hacking on haskell
20:26:51 <carter> just not as much
20:27:05 <sclv> we don't know what he's doing exactly in fact
20:27:24 <sclv> and honestly you should switch up your research/career direction every seven years or so anyway
20:27:28 <carter> true
20:27:40 <carter> otoh, i've seen him chatter on ghc-dev and trac
20:27:50 <carter> so he's at least doing some things that require ghc + dynamic linking in funky ways
20:28:07 <tabemann> one could ask why the hell I jumped from working at NASA to working at a itty bitty company that sells medical software...
20:28:42 <carter> oh?
20:28:48 <carter> variety?
20:29:12 <tabemann> family reasons and it seemed the team that I was working on was going to run out of funding sooner or later, and I wanted to be out of there *before* it ran out of funding
20:29:25 <carter> Good call
20:29:34 <carter> i had a friend who wouldn't leave a startup that was a sinking ship
20:29:37 <carter> it was sad
20:29:49 <tabemann> and it turned out that this was what was available in Wisconsin, the compensation is quite nice, and I love the work environment
20:29:56 <carter> awesome
20:30:56 <Gracenotes> do you have to deal with US laws and regulations?
20:30:59 <tabemann> the only downsides are that A) Java and B) the pace of work is *slow*, which comes with the area (processes basically mandated by the FDA)
20:31:03 <tabemann> yep
20:31:12 <Gracenotes> (I guess everyone does, some more than others)
20:31:49 <tabemann> but I mean there's things like we're basically mandated to do formal design work on just about everything we do that becomes a product, which means wading through lots of UML in practice
20:32:34 <tabemann> we have a habit of coding things up just to show them as examples to the doctor who runs the company, just with the expectation that we'll have to throw out the example altogether, design it from scratch, and code it again!
20:32:35 <yaron> Man. When I hear "formal design", UML definitely isn't the first thing that comes to mind.
20:32:48 <tabemann> it's not really formal, it's what the FDA thinks is formal
20:33:33 <Modius> waitForProcess pid - imagine I have a list of pids - what do I have to do to successively call/wait for all of them in the list?
20:33:47 <yaron> mapM_ waitForProcess pids
20:34:41 <tabemann> but yeah... it is definitely a change from working at NASA, where we basically just coded shit up from scratch with no design processes at all and with requirements that were a complete joke
20:35:32 <tabemann> (most requirements were literally copied-and-pasted between requirements docs for different projects, to the point that we just ignored the ones that didn't make sense for a given project)
20:41:08 <zbcm> Is Leksah any good?
20:42:01 <hamishmack> It's great! (I might be biased)
20:42:22 <luite> hehe
20:42:23 <zbcm> I'm sure it is fine. It was the first result on Google. :p
20:51:33 <Modius> How can I define a IO (String, ProcessHandle) -> IO (String) where processHandle runs from waitForProcess
20:52:19 <levi> zbcm: The last time I was able to get it to build (I haven't tried recently, though) it was pretty cool. The Eclipse-based IDE is not bad as far as Eclipse-based IDEs go, either.
20:54:41 <zbcm> levi, the eclipse one?
20:55:03 <zbcm> Oh nevermind, I think I have found it.
20:55:20 <geekosaur> eclipsefp.github.io I think?
20:57:40 <enthropy> template haskell can be used to access things not exported by modules?
20:59:04 <joelteon> it can?
21:01:00 <geekosaur> probably not intentionally
21:04:51 <geekosaur> I could imagine something not exported still receiving a reference in an interface file for use by (say) cross-module inlining, and some TH hackery might be able to tease it out and abuse it
21:05:08 <geekosaur> or something along those lines
21:05:39 <enthropy> module X (x) where x = [| somethingNotExported |] -- users of $x won't have  somethingNotExported out of scope
21:06:41 <geekosaur> that sounds like it's worth a message to glasgow-haskell-users@
21:07:39 <elliott> isn't that just lexical scoping?
21:09:35 <thermoplyae> hi have there been attempts to compute the cohomology of any particular monads in haskell
21:10:34 <thermoplyae> or to use monads to construct resolutions of objects w/ the bar construction like other branches of math use them for
21:15:04 <hpaste> enthropy pasted “violating module boundaries with TH” at http://lpaste.net/91403
21:15:08 <enthropy> geekosaur: ^^
21:15:33 <enthropy> unfortunate that you need the full package name in there
21:17:10 <scshunt> enthropy: how does that violate module boundaries?
21:17:30 <scshunt> you imported XLM
21:18:14 <enthropy> the data constructor isn't exported
21:19:22 <scshunt> oh dear
21:19:30 <scshunt> *why* is that function exported from LHTHS?
21:19:45 <scshunt> the docs even say not to use it
21:21:31 <enthropy> it's probably for when you get tired of repetitively writing 'Name1 'Name2 'Name3 ...
21:22:09 <scshunt> the docs say it's for implementing that
21:22:24 <scshunt> "not available to the programmer" the docs say
21:26:55 <scshunt> enthropy: although it's not clear if "mkNameG_*" is supposed to be available
21:28:02 <enthropy> scshunt: I don't think it's a mistake. You have the data constructors of Name also exported
21:28:12 <scshunt> enthropy: the whole module is exported
21:28:21 <scshunt> that smells of "nobody bothered figuring out what is API or not"
21:29:06 <enthropy> the more public parts are in Language.Haskell.TH
21:29:45 * hackagebot papillon 0.0.62 - packrat parser  http://hackage.haskell.org/package/papillon-0.0.62 (YoshikuniJujo)
21:31:18 <enthropy> Saizan: can you recall any discussion about this issue (you can make NameS that access supposedly hidden identifiers)?
21:33:08 <scshunt> enthropy: what about things like qAddDependentFile?
21:33:28 <enthropy> scshunt: that it's useless?
21:33:52 <scshunt> enthropy: it doesn't appear to be
21:34:17 <scshunt> enthropy: and I mean how to access them from outside .Syntax
21:35:56 <enthropy> `import Language.Haskell.TH.Syntax' is a lot less likely to break your code than `import Data.ByteString'
21:36:13 <scshunt> enthropy: hahaha
21:36:19 <scshunt> enthropy: why do you say it's useless?
21:40:00 <scshunt> wait, you can... oh god
21:40:16 <scshunt> mkNameG is evil
21:40:30 * enthropy takes it back... apparently qAddDependentFile works as advertised
21:40:59 <enthropy> scshunt: you need to hook into cabal to get the secret package versions
21:41:11 <scshunt> enthropy: oh no, it's worse than that
21:41:16 <scshunt> you don't even need to have /imported/ the module
21:41:24 <scshunt> hello dependency problems
21:42:01 <enthropy> so does that finally give a solution to mutually recursive modules?
21:42:28 <scshunt> no, because you can't export the dependnecies
21:42:30 <scshunt> *dependencies
21:50:18 <zzing> Is there a shortcut way of taking a function like unless that takes a Bool and lift it to handle an IO Bool?
21:50:24 <scshunt> enthropy: so you'd be running the risk of running into all sorts of problems
21:51:27 <geekosaur> someone just proposed one recently, seems to have been shot down
21:51:29 <scshunt> maybe if the only thing you were importing this way was values, and the API didn't change, then the linker would solve it
21:51:35 <johnw> geekosaur: sniff
21:51:37 <enthropy> ?quote om
21:51:38 <lambdabot> geheimdienst says: "the proposal to split split split the community"
21:51:46 <johnw> scshunt: that function got put into the monad-extras package
21:51:49 <johnw> Control.Monad.Extra.om
21:52:12 <scshunt> johnw: wha
21:52:21 <scshunt> (and by values, I mean functions too)
21:52:23 <geekosaur> I think that was supposed to be aimed at zzing
21:52:41 <scshunt> enthropy: datatypes or anything more complicated would probably lead to heaps upon heaps of problems
21:53:38 <scshunt> enthropy: actually, I take that back. It wouldn't work on a clean build since you wouldn't be able to refer to it probably
21:53:40 <zzing> What package is that in?
21:53:54 <johnw> oh, yeah, zzing
21:53:56 <johnw> sorry scshunt
21:57:01 <zzing> Why did they call that 'om'?
21:57:42 <geekosaur> 'on monad', I think
22:00:42 <geekosaur> or over monad
22:01:16 <johnw> yeah, on monad is what I think of
22:01:25 <zzing> ok
22:01:26 <johnw> it's just something meant to be short and easy to type, really
22:01:36 <ClaudiusMaximus> surely it's because 'nom' is in the same module
22:01:42 <zzing> nom nom nom
22:01:46 <sclv> a more descriptive name might be flipAndApplyMonadically
22:01:48 <johnw> yeah, we couldn't resist that :)
22:01:55 <sclv> i think people would object less to that, since it is clearer
22:02:02 <johnw> haha
22:02:23 <geekosaur> omnad
22:02:30 <johnw> sclv: ok, time to deal with CatchT  :)
22:02:49 <johnw> you prefer Control.Monad.Catch.Pure to Control.Monad.Trans.Catch?
22:02:49 <zzing> An intuition is sitll missing on me on some of these structures
22:05:07 <sclv> i don't feel strongly
22:05:21 <sclv> the latter is probably fine
22:06:01 <johnw> I'm just wondering, is it better to use a strange module name that really makes them think (the former), or the typical module name they'd be likely to reach for (which may mean they use it without thinking)
22:06:09 <johnw> given the pitfalls here, I think the former might be better
22:06:25 <johnw> because every other monad transformer in the Trans.* namespace sits on IO just fine
22:09:13 <zzing> Does anyone remember a language called 'Eff' that was trying to take a different approach to effects?
22:13:03 <geekosaur> andrej?
22:13:12 <zzing> I believe so
22:13:32 <zzing> It sounded like an interesting idea, but I haven't gotten through the paper yet.
22:14:23 <zRecursive> :t (&&&)
22:14:24 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
22:18:03 <c_wraith> It turns out, good api design is *way* harder than type-level tricks. >_>
22:18:37 <c_wraith> I've been following "release early and often", but now I've reached a point where I need to make a change that makes the current name of the package questionable.
22:19:25 <c_wraith> What's sane to do in this situation? Say the current package is deprecated and release a new one with an appropriate name?  Just say the package name is a historical accident?
22:19:25 <zzing> API design in haskell is a very interesting topic - for instance in a GUI and graphics library
22:19:50 <zzing> c_wraith, how much different?
22:20:12 <carter> c_wraith whats the lib?
22:20:49 <c_wraith> http://hackage.haskell.org/package/fixed-storable-array  All the current releases wrap a StorableArray
22:21:02 <carter> oh
22:21:08 <carter> and whats the change
22:21:18 <c_wraith> But it turns out StorableArray is the wrong backing type, and I'm going to change to supporting either Array or UArray
22:21:35 <carter> wrong backing type for what use case?
22:22:06 <carter> sounds like what you're saying it it no longer suites your use case
22:22:09 <zzing> c_wraith, you should deprecate the old one, and refer to the new one.
22:22:10 <c_wraith> use in marshaling data for FFI use.  StorableArray *seemed* to be a good fit for a long time.
22:22:16 <carter> but
22:22:28 <c_wraith> Until I really got deep into the semantics of what the Foreign.Marshal stuff is doing
22:22:35 <carter> how so?
22:22:36 <c_wraith> And realized I shouldn't be using a mutable array.
22:22:43 <carter> what should you be using?
22:23:11 <c_wraith> Something that can be used in pure contexts
22:23:22 <carter> you can make it usable in pure contexts
22:23:29 <c_wraith> like, for instance, it can have a sane Eq instance
22:23:34 <c_wraith> which StorableArray can't
22:23:37 <carter> why not?
22:24:12 <carter> sound like you want to write a NEW lib
22:24:17 <carter> based on what you learned
22:24:25 <carter> and tag this one as depricated
22:25:20 <c_wraith> I kind of feel bad about having it as yet another hackage entry though.
22:25:33 <c_wraith> Made it less than 24 hours before deprecation!
22:25:59 <carter> c_wraith email ross patterson and ask him to remove it :)
22:26:03 <carter> problem solved
22:26:09 <carter> (ask really nicely)
22:26:12 <c_wraith> ack, about to lose internet.  I'll be back later.
22:26:28 <c_wraith> I guess I thought that would be too much hassle for him, but I guess it's reasonable.
22:26:29 <carter> @tell c_wraith  email ross patternson to ask him to remove it from hackage
22:26:30 <lambdabot> Consider it noted.
22:26:56 <c_wraith> @msgs
22:26:56 <lambdabot> Not enough privileges
22:26:57 <newsham> haskell gadt's can have type definitions in the body right?
22:27:02 <c_wraith> err, wrong things.  oh well!
22:27:11 <carter> c_wraith as you penance, help hackage2 get out :)
22:27:19 <carter> :)
22:27:27 <c_wraith> hackage2 *would* solve this problem in a better way.
22:27:55 <c_wraith> Too bad it's hard to make work :)
22:27:59 <carter> thats the point
22:28:01 <carter> help fix that :)
22:28:11 <carter> as the penance / community service for name space usage :)
22:28:15 <carter> mwahahah
22:28:17 <carter> i kid
22:28:17 <c_wraith> well, time for me to go. Thanks for the feedback.
22:28:20 <carter> np
22:28:36 <zzing> hackage2 isn't out yet? I thought people were talkinga bout that last year
22:28:54 <carter> zzing you can build it and use it
22:29:00 <lispy> and the year before last
22:29:00 <carter> but it needs more love
22:29:10 <lispy> hackage forever will take some time
22:29:23 <zzing> It will be released once template haskell is in the language?
22:29:24 <lispy> I hope you didn't preorder
22:29:42 <carter> lispy: sclv  talked me out of doing weekend hackign on an alternate
22:34:38 <johnw> lispy: lol @ "hackage forever"
22:34:46 <johnw> lispy: are you coming to ICFP?
22:35:13 <lispy> johnw: it's becoming more and more likely
22:35:17 <johnw> yay!
22:35:22 <johnw> seeing you there would be awesome
22:35:29 <lispy> I think I found a friend to stay with
22:35:41 <lispy> So now I need to find a way to take time off work and the money :)
22:36:08 <lispy> (it shouldn't be that hard either, I just have to suck it up)
22:37:07 <zRecursive> @hoogle Template Haskell
22:37:08 <lambdabot> Did you mean: :: Template Haskell
22:37:08 <lambdabot> package template-haskell
22:41:41 <zzing> Is there anything that talks a little about EitherT? I have old code that uses types like tryGL :: IO r -> EitherT [Error] IO r    for handling errors. But it is a year old, so I am unfamiliar of how and why to use it.
22:44:56 <Ralith> :t runEitherT
22:44:56 <lambdabot>     Not in scope: `runEitherT'
22:44:57 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
22:45:07 <Ralith> @hoogle runEitherT
22:45:07 <lambdabot> No results found
22:45:16 <Ralith> huh.
22:45:16 <zzing> Control.Error.runEitherT
22:45:55 <Ralith> well, anyway, it's probably just a function that returns IO (Either [Error] r)
22:48:28 <zzing> I believe this is the kind of thing I have issues mentally understanding. EitherT e m a - so many things to put together
22:49:10 <zzing> :t (<*)
22:49:10 <lambdabot> Applicative f => f a -> f b -> f a
22:53:48 <zvrba> petersen's paper on Intels HRC is available now
22:53:59 <zzing> HRC?
22:54:06 <zvrba> haskell research compiler
22:54:13 <carter> intel haskell compiler mod of ghc
22:55:05 <zzing> Just to optimize it?
22:56:44 <carter> yeah
22:56:51 <carter> they kinda know how to optmize their cpus
22:59:32 <carter> @tell irene-knapp do the thing
22:59:33 <lambdabot> Consider it noted.
23:04:00 <zvrba> hm
23:04:52 <zvrba> compared to ghc+llvm, the hrc runtimes are between 3.25x (slower) and 0.1x (faster)
23:25:48 <hpaste> stevejb pasted “why the Just on line 18” at http://lpaste.net/91404
23:26:23 <stevejb> zvrba: do you have a url to the paper?
23:26:48 <stevejb> http://www.leafpetersen.com/leaf/publications/hs2013/hrc-paper.pdf ?
23:26:54 <scshunt> stevejb: presumably because parMapChunk requires a Maybe
23:27:40 <stevejb> scshunt: thanks. I suppose I am trying to understand the design behind it. I am trying to follow the monad-par tutorial
23:27:43 <zvrba> stevejb: yes, that one.
23:47:11 <kvda> how can you write a function that accepts both "Text" and "Maybe Text"?
23:47:45 <johnw> kvda: use (Text, Maybe Text)?
23:48:09 <johnw> but I don't think you can do what you're asking
23:48:29 <kvda> Polymorphism is involved, but I don't know the actual method
23:49:00 <Ralith> this sounds like homework
23:49:03 <Ralith> maybe you should ask your TA?
23:49:05 <johnw> well, the type Text is a subset of Maybe Text
23:49:23 <kvda> Ralith, no, just new to haskell
23:49:28 <kvda> well 'new
23:49:39 <Ralith> kvda: then why are you so sure polymorphism is involved?
23:51:02 <kvda> I'm not 100%, but it seems to me that that's the direction from my understanding
23:51:44 <kvda> I think you're assuming way too much Ralith
