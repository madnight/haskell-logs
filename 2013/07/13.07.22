00:00:15 <ogew> Thanks
00:00:42 <yesthisisuser> reading code can be hard in any language.. in declarative programming it is different since there is no real notion of sequentiality
00:01:35 <ogew> I just done reading LYAH 3rd time. This time I got it. =)
00:26:19 <MouseTheLuckyDog> Let  "M a"  be a monad over type a.  What exactly is "M ( M a)"?
00:27:50 <dmitrymatveev> MouseTheLuckyDog: Monad over monad over type a
00:28:30 <logicalguy> hi, is there any IDE for haskell?
00:28:32 <dmitrymatveev> MouseTheLuckyDog: see also join :: Monad m => m (m a) -> m a
00:29:28 <blackdog> logicalguy: emacs or vim with ghc-mod gives you a few IDE-like features.
00:29:33 <shachaf> MouseTheLuckyDog: What does "a monad over type a" mean?
00:29:41 <blackdog> i know there are a few genuine IDEs floating about, don't know how usable they are
00:29:55 <MouseTheLuckyDog> dmitrymatveev, that would be problematic, since join is what I was looking at when I saw M (M a) .
00:30:17 <notdan_> logicalguy: many people use Emacs with ghc-mod and haskell-mode. There is also leksah: http://leksah.org/
00:30:18 <biscarch> logicalguy: Leksah or the one from fpcomplete are the only ones I really know of
00:30:25 <blackdog> notdan_: that's the one :)
00:30:29 <biscarch> and emacs, as notdan_ said
00:30:30 <shachaf> I mean, did you make up the phrase or did you see it somewhere or what?
00:30:36 <notdan_> logicalguy: also you can use popular editors like SublimeText and TextMate
00:31:13 <shachaf> MouseTheLuckyDog: Anyway, it sounds to me like you're trying to understand this in abstract when your life would be much easier with concrete examples first.
00:31:27 <shachaf> E.g. You know what [[a]] means, presumably.
00:31:31 <logicalguy> okay, thanks, blackdog notdan_ biscarch
00:32:17 <notdan_> M (M a) is basically like (M a), but instead of 'a' you have 'M a'. You can have lists of lists, or maybes of maybes: Maybe (Maybe a)
00:32:45 <MouseTheLuckyDog> I think by IDE logicalguy means something with a "GUI builder".
00:33:20 <MouseTheLuckyDog> notdan_: BUt then what is "Just Nothing"?
00:33:36 <yesthisisuser> is the fpcomplete IDE free?
00:33:41 <notdan> that doesn't make much sense tho. "GUI builder" are for GUI libraries not for languages
00:33:44 <logicalguy> not really, MouseTheLuckyDog, I just didn't want to type always in interactive mode or switch between vim and command line
00:34:02 <blackdog> logicalguy: i would really look at ghc-mod if you're already a vim user
00:34:13 <blackdog> https://github.com/eagletmt/ghcmod-vim
00:34:28 <notdan> MouseTheLuckyDog: it's a value of type Maybe (Maybe a)
00:34:41 <logicalguy> let me check if it is available in portage, blackdog
00:35:14 <MouseTheLuckyDog> notdan: like Delphi, C++Builder, or FranzLisp( IIRC).
00:36:53 <shachaf> MouseTheLuckyDog: But they already said it's not what they want. You don't have to make a guess at what people mean and speak for them. :-)
00:41:13 <notdan> MouseTheLuckyDog: so, for example you might have a computation that divides three numbers: (a/b)/c. And you want to return Just (Just x) if the result of (a/b)/c = x. But if b or c is equal to zero  you want to return Nothing. If b is equal to 0 than you want to return Nothing, if c is equal to 0 but b is non-zero you want to return Just Nothing. http://paste.hskll.org/get/307
00:47:51 <orzo> Is there a way to search hackage for packages that depend on a given package?
00:48:29 <notdan> orzo: http://packdeps.haskellers.com/
00:50:33 <orzo> thanks
01:24:46 <t7> > unwords $ mapConcat (\x -> if x == "dollar" then replicate 3 x) $ words "I need the dollar is what i need"
01:24:47 <lambdabot>   <hint>:1:63: parse error on input `)'
01:25:07 <t7> i forgot else :(
01:25:15 <shachaf> dreixel: Wait, instances of what?
01:25:22 * t7 hands back programmers card
01:25:30 <shachaf> dreixel: Are you talking about this gcast Refl thing or Typeable changes in general?
01:28:23 <dreixel> shachaf: I had the impression this was doing both
01:28:38 <dreixel> shachaf: namely, adding Data.Proxy, and some type-level proof stuff
01:29:41 <shachaf> OK, so you're talking about the whole new-typeable branch.
01:30:07 <shachaf> I'll pull HEAD tomorrow and look at the state of it right now.
01:30:50 <dreixel> shachaf: no, not new-typeable
01:31:00 <dreixel> data-proxy: https://github.com/ghc/packages-base/tree/data-proxy
01:31:06 <dreixel> it's a base branch, not a ghc branch
01:31:07 <shachaf> Oh, data-proxy. Which is a distinct thing, in base.
01:31:10 <shachaf> Right, I see now.
01:31:22 <shachaf> Remind me, what was the reason Data.Proxy was necessary in base at all? PolyKinds?
01:31:30 <shachaf> A canonical way to use Typeable?
01:31:45 <dreixel> canonical way to use Typeable, yes
01:31:47 <dreixel> I think that was the conclusion
01:31:57 <shachaf> (Since you can use typeRep just as well with e.g. Maybe, if you're just dealing with *-kinded types.)
01:32:03 <dreixel> we don't really use it, I think, but it's something you often need
01:32:11 <shachaf> But I suppose it's good to have it in base anyway.
01:32:21 <dreixel> so better define it there than have everyone defining it themselves
01:33:58 <shachaf> dreixel: Well, the "canonical" place is edwardk's tagged: http://hackage.haskell.org/packages/archive/tagged/latest/doc/html/Data-Proxy.html
01:34:36 <dreixel> shachaf: I think this is basically copying that into GHC.
01:34:40 <shachaf> Right.
01:34:43 <shachaf> I think it'd be OK to move it to base and have tagged re-export the module, but if so then it should be as compatible as possible.
01:35:03 <shachaf> Maybe the bits that mention Tagged would have to move into Data.Tagged instead or something.
01:35:38 <yesthisisuser> i am looking at the acid-state examples but i don't really understand this TemplateHaskell thing.
01:35:39 <shachaf> But e.g. reproxy and asProxyTypeOf are useful.
01:35:52 <shachaf> And some of the extra instances.
01:36:23 <shachaf> I can probably send you a patch tomorrow to add them.
01:36:50 <shachaf> (Also, they should have polymorphic, lowercase-proxy types, rather than capital-Proxy types. HEAD tagged does that but it looks like the released version doesn't.)
01:37:34 <yesthisisuser> in this example: http://lpaste.net/91117
01:38:13 <yesthisisuser> how is the query database (ViewMessages 10) part associated with viewMessages?
01:38:26 <shachaf> dreixel: Also I should mention that _ == _ = True is different from ()'s Eq instance, or the instance that deriving Eq generates. I think it's OK, though.
01:41:00 <dreixel> shachaf: those comments are very helpful, but can you perhaps email them?
01:41:04 <merijn> shachaf: Because that one admits _|_ as being equal to ()?
01:41:15 <mstksg> is there a persistance/database abstraction in haskell that doesn't rely on TH?
01:41:23 <dreixel> shachaf: my attention span on IRC is very short :P
01:41:44 <jpcooper> hello
01:41:48 <shachaf> dreixel: Sounds good, but maybe I'll go to sleep now and email them tomorrow. :-)
01:42:14 <Gracenotes> mstksg: most ORM systems rely on language reflection
01:42:41 <dreixel> shachaf: sure, no hurry :)
01:42:42 <Gracenotes> or code generation of some kind
01:42:43 <dreixel> thanks again
01:42:59 <Gracenotes> in languages other than Haskell, that is.
01:43:03 <jpcooper> I'm interested in using Haskell efficiently for things involving large hash tables, string parsing, binary data reading and CSVs. Is there a paper/book that covers using Haskell in this area?
01:44:04 <merijn> jpcooper: Preemptive note: never use String for large amounts of data/parsing, Text is pretty much universally better. I have no real suggestion for papers/books, though
01:44:29 <jpcooper> I have indeed heard about Text
01:44:35 <jpcooper> okay
01:44:40 <Gracenotes> Real World Haskell is good for exploring how to create and organize performant code, though some of it is not current best-practices. why hash tables, btw?
01:45:08 <jpcooper> Gracenotes: I don't know yet. I was thinking they might pop up in the future
01:45:15 <Gracenotes> in Haskell, they tend not to
01:45:49 <mstksg> Gracenotes: i guess i've been spoiled by ruby's expressive metaprogramming built into the language.  i've never had to use a preprocessor of any kind
01:45:52 <Gracenotes> unless you are giving up normal evaluation wholesale... depends
01:45:54 <jpcooper> right now, for instance, I have written a CSV parser in C to count the size of every contiguous group on a certain column, and output that. I have not been able to do it nearly as fast in Haskell
01:46:18 <Lethalman> jpcooper, start by using Text instead of String
01:46:31 <sipa> fast as in runtime or development time?
01:46:42 <jpcooper> development time took bloody ages, and of course, I take this into account
01:46:43 <Gracenotes> mstksg: it still is reflection, and it's arguably even more fragile, even though it's surely terser to implement
01:46:48 <Lethalman> I did something similar and changing from string to text helped a lot
01:46:50 <jpcooper> but I've been working on files of size 10GB
01:47:00 <jpcooper> I will give Text a go, though
01:47:11 <Gracenotes> TH is definitely wordy, I think...
01:47:19 <Gracenotes> well, dense
01:47:20 <jpcooper> TH?
01:47:22 <mstksg> Gracenotes: so reflection is impossible in haskell without TH?
01:47:37 <sipa> i think it is very unlikely that you'll come close to the performance of a C program that was written to be efficient, for somethig like this
01:47:55 <jpcooper> I'd be happy with some linear difference
01:48:12 <taylorgb> Have you profiled where the slowness is?
01:48:22 <sipa> even if just for the fact that something like that can be done in C without dynamic memory
01:48:24 <jpcooper> no, I haven't looked into Haskell profiling before. I will, though
01:49:28 <jpcooper> sipa: will Haskell reuse the memory of a value if it knows that that value will not be referenced again?
01:49:33 <Gracenotes> mstksg: yes, and that's a good thing. hopefully people will be motivated to use less broken abstractions... reflection is the ultimate sort of leakiness.
01:49:57 <merijn> mstksg: TH doesn't let you do reflection
01:49:59 <jpcooper> sorry, I mean GHC
01:50:22 <Gracenotes> well, I am being a bit hyperbolic
01:50:57 <Gracenotes> It seems like database libraries like to say 'you get to manipulate pure values, except at these boundaries', and that involves many a boilerplate.
01:51:01 <sipa> jpcooper: i'm no expert, and not up to date with recent development, but in general: don't assume that the compiler is magical
01:51:26 <jpcooper> this leaves me wondering whether there are libraries specifically suited to this kind of thing
01:51:42 <mstksg> Gracenotes: so if i tried today to write an ORM library in haskell w/o TH, where would i first run into trouble?
01:51:52 <merijn> jpcooper: I recently saw someone in here who was parsing a 2.5 million element list as string and had his program crash due to lack of memory, once he changed to Text the program ran with no problem
01:52:05 <jpcooper> that sounds promising
01:52:11 <merijn> jpcooper: If you have 10GB files String is completely unsuitable, it uses something like 20 bytes per char
01:52:14 <dobblego> mstksg: you can write ORM libraries without reflection, just like all the good ones do
01:52:22 <jpcooper> thanks for the advice. I should get back to work
01:52:30 <merijn> jpcooper: Text is the datatype for densely packed unicode text
01:52:36 <Gracenotes> ORM isn't the only way. ...I'm not sure what the best way is, really.
01:52:42 <merijn> jpcooper: (For binary data you'll want ByteString)
01:52:52 <Ghoul_> jpcooper: after its recycled, yes
01:52:54 <shachaf> String is ridiculously memory-inefficient, of course.
01:53:05 <jpcooper> okay
01:53:25 <mstksg> so at what point in the creation of a persistance/database abstraction library will i have to give up and use TH?
01:53:32 <jpcooper> cheers
01:53:38 <dobblego> mstksg: never, if you do it nicely
01:53:48 <Ghoul_> I hate the current TH
01:53:57 <mstksg> dobblego: i guess i asked this earlier, but what libraries today don't use TH?
01:53:57 <Ghoul_> the compile time cost of pulling in TH is really silly right now
01:54:04 <merijn> mstksg: TH just lets you do compile time code generation, i.e. auto boilerplate production
01:54:10 <dobblego> mstksg: that is a pretty huge list
01:54:14 <Gracenotes> in other languages, at least, ones that don't use reflection still try to present pure values or plain-old-objects, while actually representing them full of state and the like.
01:55:02 <Gracenotes> This is the point of ORMs, though...
01:55:21 <mstksg> dobblego: ah, is there really.  i guess i've only been looking at a narrow subset, the canonical ones for the popular web frameworks
01:57:04 <mstksg> it seems like there really are a lot now that i broaden my search.  any reason why all of the popular web frameworks seem to integrate heavily with just ones that use TH?
01:57:50 <blackdog> really dumb question: why does "instance Ord Thingo" with no body not cause ghci to complain vociferously?
01:58:50 <merijn> blackdog: Probably a default implementation of comparing that exists
01:58:51 <mstksg> and i guess compile-time boilerplate code generation is something that i'll just have to accept as a necessity in languages without built-in metaprogramming capabilities?  i had been kind of living under the illusion that good libraries in any modern language shouldn't require boilerplate code.
01:59:17 <merijn> mstksg: oh, and how would that be possible?
01:59:28 <merijn> mstksg: for example, creating lenses for data structures
01:59:35 <merijn> mstksg: The code has to come from somewhere
02:00:40 <mstksg> it just feels dirty.
02:00:42 <Gracenotes> metaprogramming is yet another (potentially dangerous) thing Haskell sometimes moves from runtime to compile time
02:02:05 <mauke> blackdog: because defining methods is optional
02:02:23 <notdan> @src (==)
02:02:24 <lambdabot> x == y = not (x /= y)
02:02:31 <mstksg> it feels like something i had seen a friend do; he had to generate 500 images, so he wrote a bash script to write 500 python programs, each time changing a number in one line of the outputted python script
02:02:53 <mstksg> and ran all 500 python programs
02:03:02 <mstksg> why introduce an extra language into the loop?
02:03:05 <banister`sleep> mstksg: sounds weird, why didnt he just write one python program that changed the number itself? :)
02:03:14 <mstksg> banister`sleep: that's the point i'm trying to make haha
02:03:16 <banister`sleep> oh
02:03:20 <mauke> what a noob! he could have concatenated all 500 programs into one script
02:04:10 <taylorgb> Personally, I think I'd prefer boilerplate that I have to write once to magic that I can't change if it doesn't do what I want
02:04:11 <mstksg> does nobody else harbor these uncanny feelings towards this whole idea of outsourcing to a separate language to generate code in another language?
02:04:20 <zvrba> I have two isomorphic types. is it possible to make Haskell convert implicitly between them when giving them as arguments to functions?
02:04:29 <notdan> blackdog: there are default definitions for compare, < , > in terms of each other. I don't hthink you'll be able to use that instance though
02:04:41 <notdan> @src (<)
02:04:41 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
02:04:42 <zvrba> concretely: I can represent an array element both as a (row,col) and as a 1-dim index.
02:04:45 <notdan> @src compare
02:04:45 <lambdabot> compare x y | x == y    = EQ
02:04:45 <lambdabot>             | x <= y    = LT
02:04:45 <lambdabot>             | otherwise = GT
02:04:59 <zvrba> hm
02:05:08 <mauke> zvrba: haskell never converts implicitly
02:05:10 <zvrba> nevermind. it doesn't quite make sense.
02:05:32 <merijn> mstksg: Not really, I've written C, Haskell, ocaml and Lisp, all of them use meta-programming at some point
02:05:49 <notdan> mstksg: I used to dislike TH, but I don't think your analogy is correct. Surely, TH can be abused
02:05:57 <notdan> but not in the case of persistent/orm libraries
02:06:09 <merijn> mstksg: Some languages meta-programming facilities are nicer than other (CPP ಠ_ಠ)
02:06:33 <Urchin> what is th?
02:06:37 <notdan> template haskell
02:06:38 <merijn> Urchin: Template Haskell
02:06:41 <taylorgb> merijn: Is CPP the nicer or the other :p
02:06:45 <Urchin> ok, thanks
02:07:00 <merijn> taylorgb: CPP would be nice if I could have includes inside defines so I could recurse my CPP :(
02:07:18 <mauke> merijn: you can #include yourself
02:07:32 <zvrba> ok, a more coherent question. is it possible to make a function F that, given X returns Y and given Y returns X ?
02:07:42 <merijn> mauke: Yes, but not inside a #define so providing macro's that use this recursion isn't possible
02:07:45 <mauke> f X = Y; f Y = X
02:07:48 <zvrba> it's be simple overloading in C++.
02:07:53 <zvrba> mauke: X and Y are types...
02:08:05 <zvrba> F : X->Y and F : Y->X
02:08:11 <zvrba> simultaneously.
02:08:13 <mauke> class C a b where { f :: a -> b }
02:08:20 <mauke> instance C X Y; instance C Y X
02:08:21 <merijn> zvrba: Not without explicit conversion, unless one is a newtype, in which case you can unwrap/rewrap it
02:08:28 <zvrba> mauke: oh, ok.
02:08:29 <mstksg> it's not necessarily the potential of abuse that bothers me; it's just the idea of outsourcing a separate language to generate code in another language.  it's like i'm not even using haskell anymore, but a meta-haskell.  why can't we just keep everything under one framework?
02:08:34 <Gracenotes> Haskell has so many ways to abstract, anyway, that unsafe runtime hackneying of code/data is rarely necessary, and even so the core of the language is pretty small..
02:08:44 <mauke> mstksg: wait, what separate language?
02:08:51 <mstksg> can't there possibly be a safe compromise?
02:09:05 <merijn> mstksg: We have typesafe TH in HEAD now...
02:09:08 <shachaf> Gracenotes: You run into more trouble with de/codata, though.
02:09:44 <Gracenotes> shachaf: do you have more operational or denotational trouble in mind?
02:10:49 <Gracenotes> also, okay okay, co, quite funny. really though.
02:10:56 <Gracenotes> <_<
02:11:32 * Gracenotes is cobeside himself
02:12:16 <Gracenotes> mstksg: my point, though, is that as far as I can tell there's very little safe about what other languages do.
02:12:34 <Gracenotes> in the metaprogramming category. even if it's quite powerful.
02:12:37 <Lethalman> @faq can haskell go comad?
02:12:37 <lambdabot> The answer is: Yes! Haskell can do that.
02:13:31 <mstksg> mauke: actually i guess the more i look at it, the more haskell-like template haskell is.  so maybe that open loop i was imagining isn't really there in reality
02:13:59 <mauke> mstksg: uh. template haskell is haskell
02:17:22 <osfameron> it looks rather like a mini-language embedded into haskell though?
02:17:49 <osfameron> e.g. it's not as integrated into the usual syntax as, say, lisp macros are into lisp
02:18:00 <mauke> that's because lisp is crazy, though
02:18:09 <osfameron> ;-)
02:18:57 <applicative> the standard uses arent really like that, the lisp user is forever writing macro things and so on
02:19:17 <applicative> the standard bread and butter th is like
02:19:36 <applicative> 'makeClassy 'deriveSafeCopy 'makeAcidic
02:20:00 <mstksg> it has to be interpreted by a wholly different processor, though; while it's still haskell...it sort of isn't the same type of haskell you use with normal code.  but i feel like you're right and this superficial-ish difference makes it not as "open loop" as I had felt.  but it's still a layer of haskell-on-haskell...perhaps just more "explicit" than i'm used to.
02:21:15 <Walther> I think an analogy would be CSS and Sass or Less
02:21:15 <mstksg> i'm probably not making sense anymore at this point
02:21:20 <notdan> I don't get it, what is exactly your problem with that?
02:21:38 <notdan> Yeah, it's another layer. But it's there for a reason
02:21:52 <mstksg> notdan: yeah, i guess what i was writing was my own internal realization of the whole thing.
02:21:55 <applicative> no one complains the 'deriving Ord' isn't really haskell, because the compiler does it
02:25:07 * hackagebot monad-par 0.3.4.3 - A library for parallel programming based on a monad  http://hackage.haskell.org/package/monad-par-0.3.4.3 (SimonMarlow)
02:26:18 <mstksg> applicative: maybe because it's a language keyword. if i could write my own "deriving" methods *in haskell*, using only the built in language constructs, that would be nice.
02:26:36 <merijn> mstksg: You can
02:26:38 <mauke> TH is built in
02:26:40 <merijn> mstksg: See Generic
02:29:28 <mstksg> thank you all for helping me broaden my perspectives.
02:35:18 <shiona> is there a reason I always get "error in RTS option -Ksize: size outside allowed range" when passing any value to it?
02:35:42 <shachaf> Presumably your value is outside allowed range.
02:36:31 <int-e> shiona: a guess, you should remove the space between the option and the number?
02:37:32 <shiona> int-e: did not help
02:38:19 <int-e> so what is the command you tried?
02:38:32 <shiona> values 8,64,1000,10000,100000,1000000,10000000 and 18446744073709551615 have been tested, it gives me a "legal range" of 8-18446744073709551615
02:38:55 <shiona> "./scc +RTS -Ksize1000000000 -RTS" with and without a space
02:39:00 <shachaf> shiona: I'm with int-e. The first thing you should give is a complete command line and a complete error.
02:39:02 <int-e> remove the 'size'
02:39:17 <watermind> what name do you use for "non-higher-order"?
02:39:17 <shiona> god damnit
02:39:20 <shiona> thanks
02:39:41 <shachaf> The lesson is: Give your complete code (and complete error).
02:39:45 <shiona> I feel so stupid once again
02:39:57 <shachaf> The error is almost never where you think it is.
02:40:02 <kartoffelbrei> watermind: first-order
02:40:10 <shiona> shachaf: yea, I just don't feel it's right to paste multiple (even if it's just two) lines into IRC
02:40:19 <shachaf> @where paste
02:40:19 <lambdabot> http://lpaste.net/new/haskell
02:40:19 <shiona> and pasting that to a pastebin seems wasteful
02:40:21 <int-e> in ghc-7.6.3 the error is "ghc: error in RTS option -K1: size outside allowed range (8 - 18446744073709551615)"
02:40:30 <shachaf> Anyway, even if you write just one line, that line should be your command line.
02:40:45 <watermind> kartoffelbrei: hmm I consider first order to be higher-order.... I mean, what do you call order 0?
02:41:10 <shiona> shachaf: true
02:41:34 <watermind> i.e. what do you call terms/types that are not computational, no arrows
02:42:00 <watermind> I was thinking value types / computational types...
02:42:14 <watermind> but I already use value for something else
02:43:03 <shiona> ok, so that wasn't the answer. I'll have to work out how to strictify constructing this graph
02:53:28 <ocharles> Any idea what http://sneezy.cs.nott.ac.uk/darcs/term/Idiomatics.lhs might be?
02:53:45 <ocharles> I randomly found it googling "Napeirian functor" and it seems good, I wondered if there was a rendered edition or something
02:53:52 <ocharles> (obviously I can render it myself)
03:07:50 <lpaste> danilo2 pasted “Lenses and typeclasses” at http://lpaste.net/91118
03:08:24 <Peaker> danilo2, Simple Lens is just Lens' isn't it?
03:08:48 <danilo2> hi! Could somebody help me with an error? (http://lpaste.net/91118) : the compiler says: Test.hs:9:14:Could not deduce (Graph gr a b0) arising from a use of `reprLens' from the context (Graph gr a b)
03:09:01 <Peaker> danilo2, you don't need to put "Graph gr a b" constraint in a method of "class Graph gr a b"
03:09:38 <danilo2> Peaker: Thank you, but I've got still the same error :(
03:09:51 <Peaker> danilo2, your class is problematic because the "add" method doesn't mention "b", so GHC can't tell which "b" to use for instance selection
03:10:52 <Peaker> danilo2, you might want to use functional dependencies or type families here
03:11:08 <danilo2> Paeker - coudl you please tell me how can I fix it? I would be very thankful :)
03:11:33 <danilo2> Peaker: The main idea is, that I want to have typeclass Graph, which declares common methods for data types which implements it
03:12:06 <mauke> sounds like an antipattern
03:13:00 <Peaker> danilo2, what's the point of this class?
03:13:41 <danilo2> Peaker: Here is my question with detail information about what I'm trying to do: http://stackoverflow.com/questions/17763438/record-selectors-in-haskells-type-classes
03:14:43 <Peaker> danilo2, so your A,B,C types need to have a common field within them, via typeclass trickery?
03:15:34 <danilo2> my A,B and C data types need to heva a common field AND share some functions, like "add", "delete" etc. - These functions should be implemented the same way, appart that for example "add" in A should be a little different
03:16:08 <Peaker> danilo2, the functions can simply use the shared field, can't they?
03:16:26 <Peaker> danilo2, are your functions operating any differently in the A,B,C case except for getting the graph field via the appropriate lens?
03:17:09 <Peaker> danilo2, http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/Control-Lens-TH.html#v:makeClassy
03:18:38 <danilo2> Peaker: I dont understand the sentence with "shared field", I'm sorry. Yeah - these functions shoudl behave slighty different - lets say that A,B and C have field repr :: DG.Gr a b (where a and b are distinct for A, B and C). A,B and C should have method add, which adds anode to repr, but additional when using add on data type A it should register the node in a map - so the add for A is "a little" different than for B and C, but i
03:20:04 <Peaker> danilo2, can you extend your paste with 2 types that have differing operations?
03:20:23 <danilo2> Peaker: yes of course :) brb
03:20:45 <Peaker> danilo2, btw, consider using "newtype" and not "data" when you have just one field and don't need the extra laziness
03:21:03 <danilo2> Peaker: I'll have more fields there :)
03:28:42 <danilo2> Peaker: I'm sorry for the long time I was writting it
03:29:04 <danilo2> Peaker: The code should show what I'm trying to have got - It has 3 data types and 3 functions,. which behave very simmilar
03:29:22 <danilo2> of course this is very simpe example - each data type will have more common dfucntions
03:29:36 <lpaste> danilo2 pasted “Common functions” at http://lpaste.net/91119
03:30:06 <danilo2> Peaker: http://lpaste.net/91119
03:30:12 <logicalguy> hi, this is a noob question.  Are parameterless functions (definitions) the same as variables if all it returns is a primitive type value?
03:30:18 <Peaker> danilo2, B and C seem identical?
03:30:31 <danilo2> Peaker - right now yes, but they will not be
03:30:40 <Peaker> logicalguy, parameterless functions are an oxymoron.. they aren't functions
03:30:43 <danilo2> They will have more parameters, but the functions "add" for them will be identical
03:31:30 <mauke> logicalguy: what is a "primitive type"?
03:31:50 <supki> and "returns"
03:32:03 <logicalguy> Peaker, quoting from Learn you Haskell etc etc, ---  When a function doesn't take any parameters, we usually say it's a definition (or a name).
03:32:15 <logicalguy> mauke, I mean values like numbers or strings
03:32:21 <lpaste> danilo2 pasted “Common functions” at http://lpaste.net/91120
03:32:27 <mauke> logicalguy: functions are numbers. your definition is invalid
03:32:51 <danilo2> Peaker: here is the "updated example" - it is very simpel,. but the types A,B and C will have a lot fields, that arre not common between them: http://lpaste.net/91120
03:33:35 <bxc> logicalguy: if you write x = 3 at the top level of your code, or x = 3 + (gocomputesomestuff 10) at the top level, both of those are the same thing
03:33:42 <bxc> logicalguy: if thats what you are asking
03:33:53 <bxc> (aside from the fact that they might return different values)
03:34:35 <RichyB> You *can* think of values as 0-arity functions if you want.
03:34:51 <mauke> RichyB: not under my watch!
03:34:52 <RichyB> It's just not particularly instructive.
03:35:04 <logicalguy> I'm not writing any code yet, just statements in the ghci interpreter
03:35:05 <RichyB> mauke, stop putting your watch on top of people, then!
03:35:27 <mauke> not ... on my watch?
03:35:54 <RichyB> mauke, stop putting your watch under people! That's mildly rude!
03:36:33 <RichyB> logicalguy, but, uh, expressions are just expressions. I wouldn't use the word "variable" because in Haskell, things don't vary unless they're some kind of type like an IORef.
03:36:52 <dobblego> RichyB: even then they do not "vary"
03:37:02 <mauke> (\x -> x)  -- x is a variable
03:37:03 <dobblego> also, 0-arity values are values, not functions
03:37:05 <logicalguy> ok, so is a function an expression?
03:37:14 <mauke> logicalguy: depends on how you define "function"
03:37:25 <mauke> my definition: a function is a value of type A -> B for some types A, B
03:37:30 <danilo2> Peaker: Do you have any idea, how can I solve this sittuation? :(
03:37:58 <bxc> logicalguy: one thing in haskell is that a function is a type of value, just strings and integers are
03:38:01 <logicalguy> a function is a block of code that does some task, right.
03:38:48 <Peaker> danilo2, writing something down
03:38:57 <logicalguy> a function is a *named* block of code that does some task, rather
03:39:23 <osfameron> a function is more like a mapping from one type of value to another
03:40:02 <RichyB> logicalguy, no. The a function (f :: a -> b) is a thing which takes an argument of one type (a) and returns a value of another type (b).
03:40:09 * hackagebot spy 0.9 - A compact file system watcher for Mac OS X, Linux and Windows  http://hackage.haskell.org/package/spy-0.9 (StefanSaasen)
03:40:13 <lpaste> Peaker revised “Common functions”: “Look ma, no typeclasses!” at http://lpaste.net/91119
03:40:25 <Peaker> danilo2, Look at this ^^
03:40:27 <logicalguy> that's a mathematical definition, RichiH
03:40:31 <RichyB> logicalguy, e.g. (\a -> a + 1) is a function but I didn't give it a name. It is an anonymous function, often called a lambda.
03:40:34 <logicalguy> oops RichyB
03:40:43 <RichyB> logicalguy, yes! Haskell functions are meant to resemble mathematical functions. :)
03:40:52 <silasm> logicalguy, you'll get flack from declarative programmers anytime you write "function" and "does" in the same sentence ;)
03:41:25 <logicalguy> oh, then it's so easy to tick off declarative programmers... :)
03:41:39 <Lethalman> danilo2, what about data X a = { ...., a } ?
03:41:41 <RichyB> The pedantry is meant to be helpful.
03:41:51 <RichiH> logicalguy: RichyB != RichiH
03:42:03 <Lethalman> err , something :: a }
03:42:20 <logicalguy> sorry, RichiH, blame it on hexchat's autocomplete thingy
03:43:03 <Peaker> danilo2, instead of type-classes, I use explicit records, so I avoid all the difficulties of automatic instance selection that you had
03:43:08 <RichiH> logicalguy: no, i will blame it on you personally and make a note to take revenge when you least expect it
03:43:10 <ion> Too bad the autocomplete thing is sentient and stubborn. It would be so much easier if the user could control it.
03:43:18 <RichiH> logicalguy: would next tuesday be fine?
03:43:36 <Peaker> danilo2, OTOH you have to manually select the instance and pass it around.. if you really want I can type-classify this..
03:43:56 <logicalguy> RichiH, first of all, you typed !=
03:44:11 <logicalguy> that doesn't work in Haskell afaik, RichiH
03:44:14 <mstksg> yes it is important to clearly see the difference between functions in haskell -- pure mappings from a to be which **always return** the same result (the same way that x^2 will always return the same result no matter how many times you calculate it) versus the typical procedural definition of function -- a block of instructions.  indeed procedural 'functions' are just subroutines which leave a value at the exit point
03:44:29 <RichiH> logicalguy: i'm not a haskell person, i just needed help compiling git-annex from source and forgot to /part
03:45:09 * hackagebot spy 0.10 - A compact file system watcher for Mac OS X, Linux and Windows  http://hackage.haskell.org/package/spy-0.10 (StefanSaasen)
03:45:19 <logicalguy> :) next Tuesday will be fine, all things being equal, RichiH
03:45:48 <lpaste> Peaker annotated “Common functions” with “Classified” at http://lpaste.net/91119#a91122
03:46:06 <Peaker> danilo2, ^^  what were the parameters you needed to control in your MPTC?
03:50:09 * hackagebot papillon 0.0.58 - packrat parser  http://hackage.haskell.org/package/papillon-0.0.58 (YoshikuniJujo)
03:51:14 <danilo2> Peaker: Each of A,B and C have _repr :: DG.Gr a b, where (!) "a" and "b" are DIFFERENT for each of A, B and C
03:51:23 <danilo2> Peaker: I hope it answers your question
03:57:22 <lpaste> Peaker revised “Common functions”: “With TypeFamilies” at http://lpaste.net/91119
03:57:28 <Peaker> danilo2, ^^
03:58:45 <RichiH> logicalguy: well, RichyB is not equal RichiH, but tuesday it is
03:58:53 * RichiH looks around
03:59:09 <RichyB> It's not Tuesday yet.
03:59:44 <lpaste> danilo2 pasted “Common functions” at http://lpaste.net/91124
03:59:54 <logicalguy> so what's the haskell equivalent of a gunfight
04:00:12 <danilo2> Peaker: Thnak you! It seems it works, but I managed (right now!) to do it using functional dependencies (as you;'ve told me): http://lpaste.net/91124
04:00:37 <Peaker> danilo2, your new paste has a fundep that makes little sense -- you probably want:  gr -> a, gr -> b
04:00:38 <danilo2> Peaker: I've tried it before but it didnt work - do you rthink my solution is worse than yours?
04:00:54 <danilo2> Peaker: I mean - what solution should I use in "production code"
04:00:59 <Peaker> danilo2, your solution also makes it possible to use the "reprLens" to construct a new A value where the map is inconsistent
04:01:07 <Peaker> danilo2, (with the graph)
04:01:43 <Peaker> danilo2, if you have "add" that does a consistent graph update, you really don't want to also have "reprLens" which lets you inconsistently edit the graph without also editing the map
04:01:51 <danilo2> Peaker: Ok, I see it, I've changed it to:  gr -> a, gr -> b - does it make sense now?
04:02:29 <Peaker> danilo2, with gr -> a, gr -> b,  it's pretty much the same as the type families' solution -- except the "reprLens" thing is a bad idea
04:02:54 <Peaker> danilo2, also I don't know how you intend to use this, so I don't know if having a class is a good idea or a bad one (compared with a simple record)
04:04:07 <Peaker> danilo2, if you find yourself using existential graph instances, it's almost certainly a bad idea and you ought to use records instead.  If it's mostly a convenience around multiple graph types, maybe it's fine
04:04:32 <danilo2> Peaker: I'm thinking about everything youre talking, and after watching your solution again I saw, that each instance of class Graph (in your solution) define function "add" - I would love to define it once and "modify" it in some instances - like "overriding" in imperative languages
04:05:06 <Peaker> danilo2, let me add something...
04:05:27 <danilo2> Peaker: Of course :) Thank you :)
04:09:52 <merijn> hmmm, given a list of elements, what's the best way to get all permutations of X elements from that list (the ordering is irrelevant, i.e. [1,2,3] and [3,2,1] are the same)
04:10:13 <lpaste> Peaker revised “Common functions”: “Add defaultAdd” at http://lpaste.net/91119
04:10:56 <Peaker> merijn, permutations are all about order, what do you mean?
04:11:06 <Peaker> @index permutations
04:11:07 <lambdabot> bzzt
04:11:19 <Peaker> Data.List has permutations
04:11:29 <Peaker> danilo2, ^^
04:12:25 <danilo2> Peaker: I'm reading it:) Thanks!
04:12:50 <Peaker> danilo2, I think it's a really bad idea to have a "default add" that does the wrong thing in some cases because: A) It means the wrong thing is available on types where it shouldn't be used (if you use the default directly rather than the method)   B) It's error-prone: You get a wrong default if you do nothing. Bug without compiler error.    Instead: you explicitly opt in for the default via "add = defaultAdd myLens" and if that's wrong, it's more apparent
04:12:50 <Peaker>  because myLens is only accessing the graph and not (e.g:) the map
04:13:15 <merijn> Peaker: No they're not
04:13:34 <Peaker> merijn, permutations are all the possible orderings?
04:13:41 <merijn> Peaker: I've run into this before, permutations can be both ordered or unordered, but the US only seems to teach the former?
04:14:37 <merijn> To quote wikipedia: "In elementary combinatorics, the k-permutations, or partial permutations, are the sequences of k distinct elements selected from a set. When k is equal to the size of the set, these are the permutations of the set."
04:14:55 <danilo2> Peaker: Thank you! That makes a lot sense! Could you please tell me if (I know this is not beautifull and error prone - I'm asking out of curius) - is it possible to modify this in such way, that "add" will be defined by default and you can "override" it in data type A ?
04:15:11 <danilo2> Peaker: But, when overriding - can we use the base definition?
04:15:23 <merijn> Oh wait, that's not the right line. I need to store this for next time I get into an argument
04:15:34 <merijn> So I don't have to scour wikipedia for the relevant bit >.>
04:15:35 <RichyB> merijn, permutations without ordering are combinations, no?
04:16:00 <Peaker> danilo2, only if you make it possible to edit the graph directly and not via the class (e.g: your "reprLens") which exposes potential to inconsistently touch the graph.  It is possible to do this semi-safely by not exposing this method ("reprLens") from your module defining the class and instances
04:16:22 <Peaker> danilo2, you cannot use the "base definition" in subclasses if you override it
04:16:43 <chrisdone> Peaker: advertise your lamdu more, nobody seems to know its features =p
04:16:52 <Peaker> merijn, I don't get it -- what are the permutations you're talking about?
04:17:16 <Peaker> chrisdone, not yet :) we want to have type synonyms, recursive types, and type-classes first,  perhaps even sumtypes and pattern matching
04:17:18 <chrisdone> <randomdude> would be ideal if a haskell editor had X <chrisdone> yeah lamdu has that
04:17:27 <Peaker> well, lamdu is still a toy :)
04:17:47 <chrisdone> sure, but it's still worth knowing someone's working on it
04:17:52 <Peaker> chrisdone, we're worried that prematurely exposing lamdu will black-list it as a toy or not good enough with unimaginative people who can't fill in the blanks
04:18:04 <merijn> Peaker, RichyB: I got taught the same name for both, and last time someone argued with me about it I looked it up and even in English the same name applies to both, although some countries (most notably the US?) only uses permutation to refer to ordered sequences
04:18:10 <danilo2>  Peaker: The idea with not exposing the method is very nice
04:18:13 <Peaker> so we want to have some threshold of usability with "real" things -- then we'll probably screencast and we believe that'll go viral
04:18:22 <danilo2> Peaker: Thnak you very much for all the informations - it helped me a lot!
04:18:26 <Peaker> danilo2, but that means other modules cannot define instances
04:18:47 <Peaker> danilo2, I really suggest not using an error-prone default implementation, and just expose a "default implementation generator" that you give necessary information to, instead
04:18:52 <danilo2> Peaker: Yes I know - I see the downsides of such solution
04:19:13 <Peaker> merijn, can you give an example of the other meaning of permutations? I only understand one meaning
04:19:16 <danilo2> Peaker: I'll do it like you've told :)
04:19:51 <danilo2> Peaker: I understand that this solution with "default generator" is normally used in Haskell community? Or the overall design which I proposed is simply wrong?
04:20:10 <merijn> Peaker: RichyB seems to imply I want combinations, which is probably right?
04:20:13 <danilo2> Peaker: Sorry for such "maybe silly" question, but I've got no strong background in functional programming
04:20:28 <merijn> Peaker: i.e. pick X with putting back vs pick X without putting back
04:20:46 <RichyB> merijn, all of the combinatronics I've ever been taught (in the UK) refers to ordered permutations as just "permutations" and uses "combinations" for selections whose ordering doesn't matter.
04:20:49 <merijn> Although I guess that doesn't remove ordering
04:20:50 <Peaker> danilo2, I'm not sure, I'm not sure my project even has any of its own type-classes...
04:21:23 <merijn> RichyB: In Dutch we just use permutation for everything in combinatorics
04:21:32 <Peaker> danilo2, we have just one type-class in 17KLOC -- of course we heavily use the standard type-classes
04:21:36 <merijn> Anyhoo, so all combinations of X elements from a list, then
04:22:05 <Peaker> danilo2, People with OO background tend to use type-classes for everything
04:22:16 <Peaker> danilo2, It's the equivalent of "writing Fortran in any language" :)
04:22:35 <merijn> danilo2: Many typeclasses can be replaced by just passing functions as arguments
04:22:37 <danilo2> Peaker: That is very interesting - I wanted to have this typeclass to implement default methods and "override" them sometimes
04:23:01 <danilo2> Peaker: But i see it does not work here, I ghave to do default generators etc - so the type classes also does not make sense
04:23:09 <danilo2> Peaker: maybe ...
04:23:25 <Peaker> danilo2, I doubt you really need your Graph type-class at all, it should probably be a record or just 2 distinct APIs if the generalization is not needed
04:24:23 <danilo2> Peaker: It cannot be a record if A,B and C should use its methods (I think), but I didnt understeand the part with 2 APIs
04:24:58 <Peaker> danilo2, I showed you a record-based solution
04:25:20 <Peaker> danilo2, basically anything that uses type-classes can (somewhat more tediously) use records (at least with RankNTypes enabled)
04:25:22 <danilo2> Peaker: ouch - I understood it wrong :)
04:26:48 <Peaker> danilo2, http://lpaste.net/91119 is the one without type-classes
04:26:59 <Peaker> oops! It was edited in place
04:27:12 <Peaker> ok, now I properly understand "Edit" vs "Annotate", in lpaste, hah :)
04:27:17 <benokit> Hi, I have tried to install bytestring-lexing-0.4.3, but it failed due to: "The program alex version >=2.3 is required but it could not be found." although my version of alex is 3.0.5. Any idea?
04:29:14 <merijn> So suggestions on the k-combinations thing?
04:31:00 <danilo2> Peaker: your example ( http://lpaste.net/91119 ) use type classes - is it the right link ?
04:31:44 <Peaker> danilo2, yes, I thought "edit" in lpaste was like annotate
04:31:47 <merijn> gah, there is a permutations library, but for some idiotic reason it's restricted to Ints...
04:31:49 <Peaker> danilo2, so it changed in-place
04:31:52 <merijn> "listChoose :: Int -> Int -> [Int] -> Choose"
04:31:56 <Peaker> danilo2, making a new example now, with records
04:32:04 <danilo2> Peaker: thank you!
04:35:42 <lpaste> Peaker pasted “Look ma, no typeclasses!” at http://lpaste.net/91126
04:35:52 <Peaker> danilo2, ^^
04:37:16 <danilo2> Peaker: Thank you for this example - I have to study it.
04:37:29 <danilo2> Peaker: I understand - you think this is the best solution?
04:39:09 <Peaker> danilo2, I can't tell - because A,B,C are toy types and not real types. I'd have to see what A,B,C really are and how they are really used to know whether I'd prefer a type-class or a record
04:39:45 <Peaker> danilo2, or just simple lifting of the ordinary graph functions for B,C directly where they're used (rather than the type-class)
04:42:04 <danilo2> Peaker: Thank you very very much for all the help! :)
04:44:58 <Eduard_Munteanu> Argh, Haskell makes named pipes horrible to use.
04:45:37 <merijn> Eduard_Munteanu: How so?
04:46:22 <edkk> damn, this "lenses in pictures" post is beautiful
04:46:36 <Eduard_Munteanu> merijn: System.IO stuff doesn't really grok them
04:46:58 <zvrba> edkk: i managed to follow it all the way until it introduced "Identity"
04:47:07 <taylorgb> Sounds like it's more of a library issue rather than Haskell being to blame
04:47:08 <Eduard_Munteanu> I suspect the only sane way is fd{Read,Write}Buf from System.Posix.IO.
04:47:22 <merijn> Eduard_Munteanu: Eh, why not just use fdToHandle?
04:47:34 <zvrba> edkk: it's totally unclear why we need to map stuff into Identity to get more stuff done.
04:47:35 <Peaker> Eduard_Munteanu, are Named pipes portable to non-posix?
04:47:40 <Eduard_Munteanu> merijn: does that work? It gets me a non-blocking handle.
04:47:47 <merijn> Peaker: No, I shouldn't think so
04:48:02 <Eduard_Munteanu> taylorgb: sort of, but System.IO is part of the language
04:48:08 <Peaker> then I don't understand the problem..
04:48:14 <merijn> Eduard_Munteanu: So?
04:48:47 <merijn> Eduard_Munteanu: Haskell always using non-blocking handles since the runtime takes care of blocking
04:48:55 <merijn> s/using/uses
04:49:09 <Eduard_Munteanu> merijn: well, in the read case, it seems it's no more different than readFile, no?
04:49:49 <Eduard_Munteanu> AFAICT, only opening pipes for writing can fail at open-time.
04:50:25 <Peaker> zvrba, It's put into Identity for the Applicative instance of Identity (that doesn't do anything) so that the traversal becomes an fmap, allowing you to run pure computations in the traversed positions
04:50:41 <Peaker> zvrba, or rather, allowing you to do pure transforms in the traversal, rather than effect-ful transforms
04:50:56 <merijn> Eduard_Munteanu: I don't know what you mean by those sentences
04:51:02 <RichyB> edkk, link please?
04:51:24 <zvrba> http://adit.io/posts/2013-07-22-lenses-in-pictures.html
04:51:35 <|apriori|> hey guys.. did anyone of you happen to use accelerate yet and encountered such an error? https://gist.github.com/anonymous/6053276
04:51:54 <supki> zvrba: it's to get  forall f. Functor f => (a -> f b) -> s -> f t  to work both as a Setter (f = Identity) and a Getter (f = Const r)
04:52:13 <Eduard_Munteanu> merijn: I mean reading from such a handle could give you nothing... which is pretty much a silent failure for hGetContents
04:52:39 <zvrba> supki: but is it a type or a type-class?
04:53:00 <merijn> Eduard_Munteanu: That's what the Haskell functions should take care of
04:53:02 <supki> zvrba: newtype Identity a = Identity a
04:53:07 <zvrba> aha
04:53:10 <merijn> Eduard_Munteanu: You probably want hGetSome
04:53:28 <merijn> Eduard_Munteanu: "Like hGet, except that a shorter ByteString may be returned if there are not enough bytes immediately available to satisfy the whole request. hGetSome only blocks if there is no data available, and EOF has not yet been reached."
04:53:29 <Eduard_Munteanu> Oh? Never heard of that.
04:54:00 <merijn> Eduard_Munteanu: Data.ByteString has a ton of functions to read from handles
04:54:01 <Eduard_Munteanu> "come hGetSome!"
04:56:07 <Eduard_Munteanu> Hm, their hGetContents seems to block, which is what I want.
04:56:45 <zvrba> supki: the text says " you can compose setters and go one level deeper into your nested data"... but this sounds like "join" for monads, except that join draws out everything to the surface where you can do stuff with it. so why invent Identity et al.?
04:57:25 <zvrba> supki: (join removes one level of monadic nesting)
04:59:00 <supki> zvrba: well, join smashes 2 layers of monadic computations and setter composition places you 1 level deeper into some structure, they aren't really related at all
04:59:56 <zvrba> supki: why cannot a one-level traversal of a data structure be made into a monadic action?
05:00:14 <zvrba> which you can then smash together to get "deeper" into the data structure
05:01:46 <yesthisisuser> is there anyone who is good at acid-state here?
05:02:09 <supki> zvrba: you probably can, that's just not how lens works
05:02:32 <zvrba> supki: yeah, that was a question unrelated to lenses.
05:02:56 <supki> zvrba: also monads aren't nearly as nicely composable as Functors/Applicatives are
05:03:37 <zvrba> (>>=) :: m a -> (a -> m b) -> m b
05:03:45 <zvrba> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
05:03:57 <zvrba> glaring similarity..
05:04:13 <ion> @type traverse
05:04:43 <zvrba> supki: I have read the paper on applicatives, read the LYAH chapter on them, and I still don't get the point.
05:04:58 <Peaker> zvrba, "join" loses the structure, you can't use it to do:
05:05:03 <Peaker> @type (traverse . traverse) (\x -> print x >> getLine)
05:05:05 <lambdabot> (Show a, Traversable t, Traversable t1) => t (t1 a) -> IO (t (t1 String))
05:05:16 <Peaker> zvrba, the point of Applicative is the phase distinction that Monad loses
05:05:28 <zvrba> Peaker: which phase distinction?
05:05:59 <Peaker> zvrba, With Applicative, all the "effects" are known statically, so you can think of an Applicative: f a   as two-phased, 1) all effects, 2) dynamic value result
05:06:11 <zvrba> ah
05:06:17 <Peaker> zvrba, whereas with Monad, effects are allowed to depend on previous dynamic *values*
05:06:21 <merijn> zvrba: monad can make decisions based on the result of an effect
05:06:25 <zvrba> but what is "effect" in Applicative? _that_ is the part that's eluding me...
05:06:43 <Peaker> zvrba, same effect as with Monad.. Maybe: Failure,   List: non-determinism,  IO: side-effects
05:06:46 <merijn> zvrba: Anything that can be a monad effect is an applicative too
05:07:01 <merijn> But some thing that can be applicatives can't be monads
05:07:04 <Peaker> zvrba, Applicative composition of effects just guarantees that we know all effects without executing any of them
05:07:40 <Peaker> zvrba, so for example, if you write a parser combinator library, a parser composition where all parsers are known before hand can be optimized to a fast automaton,  whereas a monadic parser cannot because you don't know all the parsers until you've actually executed the parser
05:08:16 <merijn> Another interesting thing
05:08:21 <zvrba> Peaker: the docs say that Applicative can inspect the computation  before executing it.
05:08:36 <zvrba> Peaker: but I haven't seen any examples of, e.g., combining parsers before executing them
05:08:37 <Peaker> zvrba, so Applicative is useful for making faster parsers.  Also, any two Applicative instances compose, i.e:   if f,g are both Applicatives,  then  f:.g  is also an Applicative (where (f:.g) = f (g a)
05:09:18 <merijn> zvrba: A concrete example, I recently implemented the Supply monad, which is a monad for "(->) r", but unlike Reader (which passes the same value to all functions, Supply passes different values to each function
05:09:38 <merijn> zvrba: I use it for unique name generation, for example where I supply different function with unique names
05:09:44 <Peaker> zvrba, indeed I am really waiting for someone to implement a damn fast Applicative parser :)  It's been done with arrows, which are pretty much isomorphic to Applicatives (if you also have a category instance)
05:10:07 <merijn> zvrba: I have both an Applicative and Monad implementation for Supply, with subtle differences between them
05:10:08 <Peaker> zvrba, I think http://hackage.haskell.org/package/cmdtheline  uses applicative composition so it can print a help/usage screen to the user without having to parse anything
05:10:52 <merijn> zvrba: When you use the Applicative it doesn't execute any of the effects until *all* consumers have been supplied, which means you can partially supply the computation and then continue later and only get effects later
05:11:09 <merijn> zvrba: The downside is, that the Applicative can't make decisions/conditionally consume a value
05:11:12 <Peaker> zvrba, the point above about  "f :. g"  being an Applicative if f and g  are is important.   Because if "f" and "g" are Monads,   f :. g     isn't a Monad    this is why "Applicatives compose, monads don't"
05:11:24 <zvrba> what is :. ?
05:11:43 <merijn> zvrba: The monad can conditionally consume values, but as a result running it causes effects to happen, even if you can finish running the entire computation
05:12:18 <zvrba> blargh
05:12:18 <merijn> zvrba: The fancy way to write Data.Functor.Compose
05:12:24 <zvrba> WHAT IS EFFECT?!?!
05:12:31 <zvrba> (sorry for shouting)
05:12:31 <merijn> zvrba: "newtype Compose f g a = f (g a)"
05:12:43 <merijn> zvrba: That depends on the applicative you wrap
05:12:53 <zvrba> the distinction between value/effect/computation and lax use of that is confusing.
05:12:57 <merijn> zvrba: Could be IO, could be State, could be Reader
05:13:16 <zvrba> but IO "effects" are also only values
05:13:18 <lpaste> elflord pasted “case for tuples” at http://lpaste.net/91127
05:13:20 <zvrba> only interpreted by RTS
05:13:32 <merijn> zvrba: Yes, but there is an ordering on their execution
05:13:32 <zvrba> so, what is effect?
05:13:38 <zvrba> merijn: also in applicative?
05:13:44 <merijn> zvrba: Yes
05:13:50 <zvrba> but only IO monad is magic
05:13:56 <zvrba> so how can applicative enforce ordering?
05:14:09 <merijn> zvrba: The implementation of Applicative has to enforce it
05:14:19 <merijn> zvrba: Otherwise you can't comply with the applicative laws
05:14:23 <Peaker> zvrba, "IO a"  the "IO" part (side-effects) is the "effect", the "a" is the "value".   "Maybe a":  The "Maybe" part is the effect (failure/success), the "a" is the value
05:14:36 <merijn> "f <*> x" runs the effects of f before the effects of x
05:14:51 <elflord> Hi all, can i pattern match (Bool,Bool) in a case clause ?
05:15:02 <Peaker> zvrba, Applicative composes effects and values independently,  all effects compose with all effects (in-order).  All values compose with all values (order is irrelevant).  And the two "phases" are independent.
05:15:13 <merijn> zvrba: The reason why people are so vague about the definition of effect is that there is no way to be concrete about them
05:15:13 <Peaker> elflord, sure:  case (x, y) of (True, False) -> ...
05:15:32 <elflord> thanks peaker, but my code has some problem
05:15:34 <zvrba> Peaker: sorry, I don't buy that. Maybe a is a data type. maybe you mean that "effect" is a predetermined interpretation of certaing combinations of values of the given datatype?
05:15:44 <elflord> i've pasted it on http://lpaste.net/new/haskell
05:15:45 <Peaker> zvrba, "effect" is just an interpretation, of course
05:15:50 <merijn> zvrba: Well, sure if you wanna call it that
05:15:50 <elflord> but couldn't see it here
05:16:01 <merijn> zvrba: Seems a bit more inconvenient to say than "effect", though
05:16:02 <Peaker> zvrba, it's a useful outlook when thinking about Applicatives/Monads
05:16:24 <ion> One could say the effect in the Maybe Functor/Applicative/Monad is the termination upon Nothing.
05:16:27 <Peaker> zvrba, some call it a "context", but basically it's the structure embodied in "f" of "f a" that is independent of the "a"
05:16:56 <zvrba> Peaker: but there may be multiple structures embodied. like nondeterminism or threading in case of lists.
05:16:57 <merijn> zvrba: The "effect" of Maybe is that "Nothing <*> _ = Nothing"
05:17:01 <zvrba> (zipList)
05:17:14 <zvrba> merijn: but that's just an arbitrary evaluation rule.
05:17:15 <Peaker> zvrba, then the composition of those structures is still a "context" or "effect"
05:17:26 <merijn> zvrba: I don't understand what you want to hear
05:17:32 <zvrba> merijn: a rule that makes sense, but it's still an ordinary function.
05:17:40 <merijn> zvrba: Well of course it is
05:17:47 <merijn> zvrba: <*> is *just* an ordinary function
05:17:52 <zvrba> yes.
05:18:01 <merijn> What's your point?
05:18:10 <merijn> All of this is just ordinary functions
05:18:18 <zvrba> that Iæm confused about what people mean by "effects"
05:18:33 <merijn> zvrba: They don't mean anything specific because there's nothing to be specific about
05:18:35 <zvrba> is it a value? is it a data type? is it ..
05:18:41 <Peaker> zvrba, the word "effects" refers to the meaning embodied in a type "f a" that is independent of the "a"
05:18:45 <merijn> zvrba: "effect" for Maybe can be short-circuit implementation
05:18:52 <merijn> zvrba: For IO it can mean doing IO
05:19:06 <Peaker> zvrba, the "meaning" given to that part by its Applicative/Monad instances
05:19:12 <merijn> zvrba: "effect" is just "that thing that f in (f a) does..."
05:19:29 <Peaker> zvrba, we're not talking about a language feature, but about an interpretation of ordinary values
05:19:34 <zvrba> merijn: but f is a type constructor, it does not "do" anything.
05:19:44 <merijn> zvrba: It describes something happening
05:19:49 <merijn> zvrba: Else why have that type
05:19:51 <zvrba> it describes a value!
05:19:54 <Peaker> zvrba, but it has effects in the Applicative composition
05:19:56 <zvrba> values do not happen or run or..
05:20:00 <zvrba> Peaker: aha!
05:20:04 <zvrba> ok
05:20:08 <zvrba> now we're getting somewhere.
05:20:21 <Peaker> zvrba, Nothing <*> 1    the "Nothing" has the effect of "terminating" the applicative composition with Nothing
05:20:59 <Peaker> (,) <$> getLine <*> print "Hi!"    the "getLine"  and  "print"   have effects of getting a line from user, or printing the line for the user  in the IO action that results from this applicative composition
05:21:38 <zvrba> Peaker: that actually makes sense.
05:22:07 <Peaker> zvrba, "IO" has "effects" by virtue of being assigned an effectful meaning in "main".   Other types have "effects" by virtue of their Applicative/Monad instances doing interesting things upon such values
05:22:12 <lpaste> elflord pasted “case for tuples” at http://lpaste.net/91128
05:22:26 <zvrba> Peaker: ok.
05:22:31 <merijn_> In "f <*> x" (where f and x are IO something) it has the "effect" of first running the IO of f and *then* running the IO of x
05:22:39 <merijn_> whoo, UK internet sucks balls
05:22:55 <zvrba> ok, so far so clear.
05:23:04 <zvrba> (finally!)
05:23:05 <Peaker> zvrba, do you understand parser combinators?
05:23:11 <Peaker> (e.g: parsec)
05:23:18 <zvrba> no, haven't read or used them.
05:23:19 <taylorgb> Aren't you on JaNet? Didn't think that fell over so often
05:23:56 <merijn> No clue what I'm on, but both my home broadband and university connection drops multiple times a day
05:24:18 <Peaker> zvrba, I can present a simpler example of Applicative utility then,  the "Const" type
05:24:19 <taylorgb> frustrating
05:24:53 <Lethalman> merijn, isn't f <*> x first running x and then f on the result?
05:25:08 <Peaker> zvrba, Do you understand how we can take a type like:  (a -> f b) -> s -> f t      and turn it into a "Getter" for "a" in "s"?   i.e:    ((a -> f b) -> s -> f t) -> s -> a
05:25:11 <zvrba> Peaker: what is the Const type?
05:25:19 <Lethalman> that is, do x' <- x; y' <- f; f x
05:25:22 <Lethalman> oh maybe not indeed
05:25:30 <Lethalman> *f' x
05:25:40 <Peaker> zvrba, (the way lens getters work)
05:25:55 * Lethalman forgot left hand side of <*> is a functor as well
05:26:29 <Peaker> zvrba, the "Const" type is:   newtype Const a dummy = Const { runConst :: a }          <-- this seems silly, but we can use it to implement a Getter
05:26:32 <merijn> Lethalman: No, it applies the function produced by f on the value produced by x
05:27:02 <zvrba> Peaker: hmm. let's not go there yet.
05:27:12 <zvrba> Lenses are too complicated right now. let's got back to Applicatives.
05:27:18 <Lethalman> ok, it's producing f first, mh
05:27:25 <Peaker> zvrba, well, "Const" can be an instance of Applicative, but not of Monad
05:28:05 <zvrba> Peaker: how can an Applicative "analyze" the computation? an example? where can it store the state? who does the analysis? the "final" function (before <$>) ?
05:29:23 <Peaker> zvrba, data MyApplicative a = Pure a | SomeEffect | ...           instance Applicative MyApplicative where  pure = Pure ; (<*>) = .. inspect all you want here! ..
05:29:37 <Peaker> @type (=<<)
05:29:37 <lambdabot> Monad m => (a -> m b) -> m a -> m b
05:29:39 <Peaker> @type (<*>)
05:29:40 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:29:59 <Peaker> zvrba, note with Monad, if you implement >>=, you get a lambda, which is essentially a black box, and you cannot look inside
05:30:10 <zvrba> Peaker: aaa! it makes sense when you describe data MyApplicative .. like that!
05:30:39 <Peaker> zvrba, but with Applicative, you implement (<*>) which gets two "f x" values (and the lambda is hidden inside the f where you don't care)
05:30:52 <Peaker> zvrba, so both sides of (<*>) are inspectable, and you can build yet another inspectable value
05:31:13 <zvrba> right. and because in Applicative laws, it shouldn't matter in which order the computation is composed.
05:31:19 <Peaker> with (>>=), one side is a black box that forces you to fully execute the effect in order to even see what the other effect is
05:31:22 <zvrba> i get it :)
05:32:27 <Peaker> zvrba, it shouldn't matter in terms of associativity:  i.e:  (f <*> b) <*> c     vs:  uncurry f <*> ((,) <$> b <*> c)      but it definitely matters if you do:   f <*> x <*> y   or   flip f <*> y <*> x
05:32:37 <zvrba> right
05:32:52 <zvrba> (yeah, I meant associativity)
05:32:59 * Eduard_Munteanu "buffers" the fifo with an MVar
05:33:36 <Peaker> zvrba, let's try to implement Applicative and then Monad instances for (Const a)
05:33:43 <Peaker> or start with Functor
05:33:50 <zvrba> Peaker: hmm. can we please wait until later today?
05:33:53 <Peaker> ok sure
05:33:59 <zvrba> alternatively, tomorrow earlier in the day.
05:34:08 <zvrba> I'm at work an have to finish a task for the day :)
05:34:26 <zvrba> bbl
05:35:04 <mauke> join (Const x) = Const x
05:36:35 <Peaker> mauke, way to be an outlaw :)
05:37:02 <mauke> is that actually valid?
05:37:10 <Peaker> it violates the monad laws
05:37:36 <mauke> but it typechecks! therefore it's valid code
05:38:07 <kartoffelbrei> join = error "i don't feel like joining today"
05:38:12 <kartoffelbrei> typechecks as well
05:38:37 <mauke> error doesn't count
05:38:46 <mauke> ah, I see: return x >>= f /= f x
05:38:49 <Eduard_Munteanu> Is that supposed to be   type Const a b = a   ?
05:38:56 <Peaker> mauke, hmm.. if you use indexed monads, you'll not type-check either
05:38:58 <mauke> Eduard_Munteanu: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:Const
05:39:03 <Peaker> (I think)
05:39:15 <Eduard_Munteanu> (err, wait, it's newtype wrapped)
05:39:44 <Peaker> join :: m i1 i2 (m i2 i3 a) -> m i1 i3 a
05:40:18 <mauke> that doesn't even kind check
05:40:21 <Eduard_Munteanu> Can you index arbitrary monads, generally?
05:40:30 <Peaker> hmm.. I guess an indexed version of "Const" will allow any indices there and won't help
05:40:47 <Eduard_Munteanu> I've seen it for e.g. State, but it seems rather monad-specific.
05:41:34 <Peaker> Eduard_Munteanu, you can always add the indices as phantom types
05:41:50 <Peaker> though an indexed IO, for example, might be able to use the indices to represent some pre-conditions/post-conditions or such
05:42:30 <Eduard_Munteanu> Hm.
05:42:59 <merijn> See also McBride's Kleisli Arrows of Outrageous Fortune
05:43:08 <Eduard_Munteanu> Well, you need to decide what indices mean when you write functions for it.
05:43:57 <Peaker> Eduard_Munteanu, they may mean nothing in most monadic contexts, and still be nice in that they give some more info for monad-general functions (e.g: join shows you the order of effects, any monad-generic function does)
05:45:14 <Peaker> imagine:  foo :: m i1 i2 (a -> m i2 i3 a) -> ...      tells you some useful information that:   foo :: m (a -> m a) -> ...  does not
05:45:26 <Eduard_Munteanu> I guess you could use indices to track global state in IO.
05:45:48 <Peaker> you can use the indices to restrict what kind of monadic compositions functions do
05:45:58 <Peaker> even if eventually, all instances just throw the indices to the garbage
05:46:25 <Peaker> (though State being able to change the "s" type is nice)
05:46:28 <Eduard_Munteanu> Peaker: isn't it rather easy to end up with ambiguous indices?
05:46:41 <Peaker> Eduard_Munteanu, what do you mean?
05:47:42 <cseder> I'm considering adding a functional language to my list of languages. (short list). I mainly work with C++ and C# and some Python. Would Haskell be a too big shock compared to maybe F# or should I just go fot it?
05:47:47 <typoclass> Peaker: so i1, i2 and so on are type-level nats?
05:48:03 <cseder> fot/for
05:48:24 <Eduard_Munteanu> Peaker: foo :: IxIO i i a     foo = f1 >> f2    where f1 :: IxIO i j a,  f2 :: IxIO j i a    might give errors if you don't specify types explicitly
05:48:35 <Peaker> typoclass, not necessarily, they could just be phantom types that restrict (>>=) and join to be used only with index-matching actions, even if the index is throw-away phantom
05:48:51 <typoclass> Peaker: hm i see
05:49:13 <typoclass> cseder: i'm not familiar with f#, but i think they're roughly on the same level. in other words, the shock will be equally big ;-)
05:49:18 <Peaker> Eduard_Munteanu, it won't give any errors because ambiguous type errors are only for instance resolution
05:49:20 <cseder> What makes Haskell so great compared to other languages like F# or Erlang?
05:49:44 <Peaker> Eduard_Munteanu, and f1 and f2 are the same type, btw, and will be inferred that way correctly
05:50:00 <Eduard_Munteanu> Ah.
05:50:01 <typoclass> cseder: but in general, go for it! learn haskell :-) i think you'll become a better programmer, whether you end up using haskell or some other language
05:50:07 <Eduard_Munteanu> Peaker: what do you mean same type?
05:50:12 <paintcan> cesder: as someone who can't program a lick of haskell, i can recommend picking up a book or two - purely functional datastructures is good
05:50:15 <Peaker> cseder, Compared to F#: Type-classes, purity, laziness(laziness is controversial though).    Compared to Erlang: A good static type system
05:50:27 <hape02> Is F# nonstrict too?
05:50:32 <Peaker> hape02, no
05:50:42 <Peaker> Eduard_Munteanu, you wrote down the types of f1/f2 but they both have implicit "forall i j ." there
05:50:56 <Peaker> Eduard_Munteanu, so they will just work with any indices for input/output
05:51:17 <Eduard_Munteanu> Peaker: I meant the i and j from foo's type (assume ScopedTypeVariables for example)
05:51:34 <typoclass> cseder: note that when we talk about static type systems, that doesn't mean you have to write lots of signatures. haskell has powerful type inference, and nearly all signatures are optional. the rough convention is to write down signatures for top-level functions and not bother with anything else
05:51:47 <Eduard_Munteanu> Peaker: could be some concrete types actually
05:51:48 <Peaker> Eduard_Munteanu, oh, then if you don't give types it'll still work
05:51:48 <cseder> I have a book here called "Learn You a Haskell for Great Good". Strange title...
05:52:02 <Eduard_Munteanu> Yeah, you're right about instances.
05:52:04 <Peaker> Eduard_Munteanu, but index types of monad-general functions will not be concrete in general
05:52:30 <hape02> Types in haskell seem to me more implicit than in other languages.
05:52:46 <typoclass> cseder: yep, that's a good book. (the style is quirky, some people find it silly. but i like it. i like elephants wearing sunglasses :-)  )
05:52:56 <Eduard_Munteanu> Peaker: also, for the general case, I guess there's no reason to limit yourself to 2 indices, it could have 1 or 2 or more.
05:53:33 <Eduard_Munteanu> Not sure how bind works for >2 though.
05:53:39 <jmcarthur_mobile> hape02: I wouldn't say implicit. We just have good type inference
05:53:57 <jmcarthur_mobile> hape02: you can be as explicit as you want to be
05:54:00 <Peaker> Eduard_Munteanu, how more?
05:54:15 <Eduard_Munteanu> For one index, something like   m i a -> (a -> m i b) -> m i b   does I think.
05:54:17 <typoclass> hape02: yeah i guess so. at least at the syntactic level. implicit in the sense that you write "abc" and that specifies both the value "abc" and the type String
05:54:30 <cseder> typoclass, never seen one, but I guess they're allright
05:54:33 <Peaker> Eduard_Munteanu, (>>=), join, (<*>) always compose 2 actions into 1, at a time.  That's isomorphic to using "n" instead of "m"
05:54:47 <Peaker> Eduard_Munteanu, oops, from "That's..." is addressing your one index
05:55:13 <applicative> hape01: you mean, because there's type inference for stuff in the core of the language?
05:55:27 <Peaker> Eduard_Munteanu, since >>= and <*> compose 2 at a time, no more than 2 indices are needed to make sure the pieces fit.   1 index is isomorphic to using multiple monadic types
05:56:19 <Eduard_Munteanu> Peaker: ah, you mean equivalent to    m a -> (a -> m' b) -> m' b ?
05:56:56 <cseder> I read on haskell.org that the packages OpenGL and GLUT are updated. Is Haskell really used for grapical programming and 3D?
05:57:26 <Eduard_Munteanu> Peaker: arguably 3 indices could be like the combination of 2 and 1-cases:   m i j a -> (a -> m' j k b) -> m' i k b   I suppose
05:57:29 <Peaker> Eduard_Munteanu, yeah, except (>>=) will need to compose the m and m' there so it'll be forced to be the same "m"
05:57:57 <typoclass> Peaker: this is a good moment for you to direct cseder to the newest lamdu video :-D lamdu uses opengl doesn't it
05:58:00 <Peaker> Eduard_Munteanu, just like   m i a -> (a -> m j b) -> m j b       will require composition of "m i" and "m j", and if that's allowed, then you added no safety?
05:58:10 <applicat1ve> cseder: the Haskell platform always had opengl and glut
05:58:11 <Eduard_Munteanu> Peaker: presumably you have a different (>>=)
05:58:21 <Peaker> typoclass, cseder: Yeah, lamdu uses OpenGL (for 2d though)
05:58:45 <Peaker> Eduard_Munteanu, but if (>>=) lets you compose monads of any index together, then the indices say nothing?
05:59:03 <Eduard_Munteanu> Peaker: right... not sure about the 3 indices case above.
05:59:37 <cseder> hmmm... Is execution fast enough for realtime 3d?
05:59:44 <Peaker> Eduard_Munteanu, whereas:  m i j a -> (a -> m j k b) -> m i k b     is actually restricting things.   you don't need any more than 2 indices because the monadic composition has a total order on the monadic effects
05:59:51 <Eduard_Munteanu> Peaker: perhaps you can tie indices and monads to particular typeclasses?
06:00:00 <typoclass> > flip take <*> (subtract 4 . length) $ "applicat1ive"
06:00:01 <lambdabot>   "applicat"
06:00:02 <Peaker> cseder, yeah, relatively easy to get 60fps
06:00:07 <typoclass> awww, cat
06:00:11 * hackagebot polimorf 0.7.3 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.7.3 (JakubWaszczuk)
06:00:18 <Peaker> cseder, it depends of course on your code :)
06:00:33 <applicat1ve> Peaker: what are some things cseder could look at I wonder.
06:00:36 <cseder> yeah, obviously.
06:00:53 <Eduard_Munteanu> Hm, right, not sure it makes sense at all.
06:00:58 <typoclass> cseder: very roughly, haskell is among the faster languages
06:01:00 <Peaker> cseder, try running lamdu to see some of our graphics :)
06:01:42 <cseder> I will, when I figure out what lambdu is!
06:02:07 <typoclass> Peaker: isn't there, like, youtube videos around? or something
06:02:57 <applicat1ve> cseder: heres a demo of a simple 'real time' graphical manipulation. maybe hello worldish from your point of view? http://www.youtube.com/watch?v=UGN0GxGEDsY
06:03:10 <Peaker> typoclass, too premature, we don't want
06:04:07 <cseder> applicat1ve, cool!
06:04:29 <applicat1ve> heres the source, he exports the algorithm and calls it in some objective c he uses http://code.ouroborus.net/beholder/beholder-head/Process.hs
06:04:44 <Peaker> cseder, https://www.youtube.com/watch?v=WNB5V9Z7Obc
06:05:41 <cseder> hmmm... Nice stuff...
06:06:17 <cseder> And I see that hsc2h makes it easy to use C/C++ functionality in Haskell?
06:06:31 <typoclass> cseder: lamdu is basically a very wild code editor that uses opengl. i don't know if it's actually representative of anything, i just mentioned it because the lamdu guy happens to be here today :-)
06:07:02 <typoclass> cseder: yes, haskell has a pretty painless ffi (= thingy to call c from haskell)
06:07:17 <merijn> cseder: If you only use primitive types (i.e. not structs) using C is trivial, if you use more complex things it becomes slighlty harder, but still very easy compared to many other languages
06:07:36 <merijn> cseder: C++ is as easy as it is to access C++ from C (I don't have experience with that)
06:07:43 <typoclass> applicat1ve: i believe you have my stapler
06:08:23 <applicat1ve> ?!
06:08:23 <lambdabot> Maybe you meant: v @ ? .
06:08:41 <typoclass> applicat1ve: never mind, i was just kidding about the video
06:08:48 <applicat1ve> cseder: oh heres a ray tracer demo from repa guy http://code.ouroborus.net/gloss/video/
06:09:11 <applicat1ve> those are just ordinary haskell, not his repa library, which is a bit avant garde
06:09:39 <applicat1ve> typoclass: ah
06:10:07 <cseder> I'm not getting great download speed from his server, but I will watch them soon...
06:10:42 <applicat1ve> they demonstrate his gloss library which is nice for moving graphics and so on
06:11:14 <applicat1ve> its a very nice library, which can be cabal installed on the basis of the haskell platform
06:11:33 <applicat1ve> if you download the source there are a zillion demos
06:12:02 <Eduard_Munteanu> I wonder if something like "forall any any'.   m i any j a -> (a -> m any j any' b) -> (b -> m j any' k c) -> m i j k c" could be useful,  m i j k (for concrete types) denotes computations where the index has to "go through" 'j'.
06:12:45 <applicat1ve> repa is his n-d array library with inbuilt parallelization etc.
06:13:43 <Eduard_Munteanu> I don't see how that could be built out of smaller index monads.
06:14:12 * Eduard_Munteanu should write some code
06:15:22 <cseder> Thhe raytracing video made me convinced that I'm going to learn Haskell. I've been working on a RT in C++ and it's a great deal of funny math involved, so this will be fun to try out in Haskell
06:16:02 <Peaker> cseder, a raytracer is one of the first toys I wrote in Haskell :)
06:16:08 <|apriori|> cseder, yup.. that's pretty much what I'm doing now :P
06:16:21 <|apriori|> but I'm not at all satisfied with the performance I achieved so far
06:16:37 <Peaker> typoclass, I wouldn't say Haskell's FFI to C is "pretty painless"
06:16:47 <|apriori|> I mean.. ok.. it went down from 120s to 5 secs per frame.. but that nowhere near the 200ms I got a in a C solution
06:16:48 <Peaker> I'd say Haskell's FFI to C is very basic and gets very painful very fast
06:17:42 <|apriori|> Peaker, well, FFI in general gets very painful very fast
06:17:46 <cseder> How about GPU coding in Haskell? ANy good libraries?
06:18:01 <|apriori|> cseder, busy trying accelerate right now.. causing me headaches so far :P
06:18:02 <Peaker> |apriori|, not necessarily. C++ FFI to C is not painful
06:18:16 <merijn> Peaker: Really? I thought the C FFI is pretty sweet
06:18:17 <Peaker> |apriori|, Python FFI to C via ctypes or such is nicer than Haskell FFI to C
06:18:27 <Peaker> merijn, as long as no structs are needed.. hsc2hs is terrible
06:18:47 <merijn> Peaker: I manage to get by using johnw's c2hsc
06:18:52 <HugoDaniel> you can use c2hs
06:18:54 <HugoDaniel> which is great
06:18:59 <k00mi> Peaker: well C isn't really foreign to C++
06:19:00 <cseder> I mean, writing a raytracer without GPU rendering support today is like madness...
06:19:01 <merijn> For simple structs that generates the hsc for you :)
06:19:26 <merijn> k00mi: That just means you don't know C and C++ very well :)
06:19:27 <|apriori|> cseder, I agree.. but if you end up getting a huge scene.. that wont really work
06:19:41 <|apriori|> cseder, unless of cause, you apply chunking.. and distribute stuff to multiple gpus..
06:19:51 <typoclass> Peaker: hm interesting. i was going by my own (small amount of) experience, plus what i thought the general consensus of #haskellfolk is. do you have any examples or blog posts about what's painful?
06:19:58 <typoclass> it would be interesting to read
06:20:04 <|apriori|> cseder, for a gpu framework take a look at 'accelerate' .. or 'nikola' (although 2nd seems to be slower in dev it seems)
06:20:23 <applicat1ve> oh, lippmeier does use repa at one point in that gloss ray tracer business
06:20:38 <|apriori|> it defines an EDSL for gpu computing.. actually quite simple.. but I currently end up in loads of trouble with it.. because I sometimes have a hard time to prevent nested parallelism
06:21:01 <k00mi> merijn: I don't, but isn't C as subset of C++?
06:21:19 <cseder> ok. Accelerate sounds like a good thing
06:21:23 <merijn> k00mi: Nope, not if you mean "all valid C is valid C++"
06:21:35 <Peaker> typoclass, just examples:  I don't know c2hsc (which seems like a heuristic parser for C that sort of works most of the time) but with hsc2hs you're supposed to manually duplicate every C data structure into a Haskell data-type, and manually write peek/poke methods for each struct field with a tonne of redundancy.. so whenever your C side involves structs, you're going to need a lot more code than C does to just re-declare the C structures
06:21:40 <|apriori|> merijn, incorrect
06:21:43 <merijn> k00mi: If you mean there is a subset of code that is both valid C and valid C++, then *maybe*
06:21:47 <|apriori|> C++ type checking is way stricter
06:21:55 <mauke> |apriori|: incorrect
06:22:04 <applicat1ve> youre both right!
06:22:05 <mauke> |apriori|: C++ type checking is stricter in some ways, looser in others
06:22:11 <mauke> it's just different
06:22:13 <|apriori|> mauke, ok, even more precise
06:22:15 <Peaker> mauke, where is it looser?
06:22:27 <mauke> Peaker: implicit conversion from Derived * to Base *
06:22:33 <typoclass> k00mi: i have not much clue, but i think c started out as a subset of c++ (whether that means it's easy or not), but later, things got more messy
06:22:36 <merijn> I know several C and C++ language lawyers, they're not subsets
06:22:39 <Peaker> |apriori|, C has features that C++ doesn't (e.g: int x[dynamic_size])
06:22:53 <|apriori|> I know, Peaker
06:23:01 <mauke> let's move the C/C++ stuff to #haskell-blah
06:23:02 <|apriori|> they started on commons grounds.. and then split up
06:23:13 <k00mi> merijn: I meant the former
06:23:20 <|apriori|> agreed, mauke
06:23:38 <|apriori|> on gpu computing + haskell.. do you guys have any experiences with accelerate, yet?
06:23:47 <merijn> Is there "isPrintableAscii :: Word8 -> Bool"?
06:24:16 <mauke> merijn: inRange (' ', '~')
06:24:18 <|apriori|> merijn, maybe hoogle on the type
06:24:19 * typoclass . o O ( "to create c++, bjarne stroustrup bolts everything he has ever heard of onto c" http://james-iry.blogspot.de/2009/05/brief-incomplete-and-mostly-wrong.html )
06:24:30 <merijn> |apriori|: I already did, of course
06:25:14 <merijn> mauke: combined with "toEnum . fromEnum" I guess?
06:25:27 <mauke> oh, d'oh
06:25:35 <mauke> inRange (ord ' ', ord '~')
06:25:40 <merijn> oh, duh
06:25:41 <merijn> ord
06:25:44 <mauke> bah, still needs fromIntegral
06:25:57 <merijn> :t ord
06:25:57 <lambdabot> Char -> Int
06:26:04 <typoclass> :t isPrint
06:26:05 <lambdabot> Char -> Bool
06:26:09 <typoclass> merijn: ^^ ?
06:26:16 <merijn> typoclass: Works on Char not Word8
06:26:20 * cseder is looking for a Sublime Text Haskell plugin
06:26:29 <typoclass> merijn: ah of course. sorry
06:26:35 <merijn> > isPrint '\SOH'
06:26:36 <lambdabot>   False
06:26:57 <mauke> > isPrint '\160'
06:26:58 <lambdabot>   can't find file: L.hs
06:27:02 <mauke> > isPrint '\160'
06:27:03 <lambdabot>   True
06:27:04 <typoclass> > isPrint (chr 123)
06:27:05 <lambdabot>   True
06:27:10 <typoclass> > isPrint (chr 456)
06:27:11 <lambdabot>   True
06:27:19 <merijn> > chr 456
06:27:20 <lambdabot>   '\456'
06:27:28 <merijn> That's where it fails
06:27:39 <mauke> you'd have to manually check < 128
06:27:53 * cseder found SublimeREPL with Haskell support...
06:27:55 <merijn> It might not matter, since Word8 can't exceed 256 I guess
06:28:51 <typoclass> > let isPrint = (==3) . length . show in isPrint (chr 90) -- muahaha
06:28:52 <lambdabot>   True
06:29:00 <applicat1ve> cseder: https://github.com/SublimeHaskell/SublimeHaskell
06:29:05 <edkk> hmm, what is the name of fold in a monadic context ?   (brain fart)
06:29:11 <cseder> I'm still trying to de-vim myself into using a commercial text-editor... That's madness...
06:29:17 <mauke> > let isPrint = (==3) . length . show in isPrint '\\'
06:29:18 <lambdabot>   False
06:29:29 <edkk> say I want to fold using Maybes, until it (possibly) fails
06:29:46 <applicat1ve> I think vim may make a better fit with haskell, it's vim v. emacs all day on this channel....
06:29:56 <cseder> But Sublime works identical on all platforms. That's the reason.
06:30:08 <mauke> vim works identical on all platforms!
06:30:13 <edkk> always use vim. (axiom)
06:30:22 <cseder> Kindof.
06:30:42 <edkk> ah, foldM. sorry
06:31:39 <applicat1ve> cseder: no one spoke up for emacs, amazing!
06:32:02 <cseder> Wow, there's something called Visual Haskell that integrates with Visual Studio... I use VS at work everyday, so...
06:32:20 <applicative> somehow i sense catastrophe ...
06:32:22 <typoclass> ... somewhere in america, johnw is getting restless in his sleep and will soon walk in here and talk about emacs
06:32:48 <applicative> typoclass: johnw is hardly the worst of them, his manners are way too good
06:33:19 <cseder> hmm... looks as if it's abandoned..
06:33:40 <typoclass> applicative: sure. john is not "the worst" or even bad in any way. he's a thoroughly calm and polite fellow
06:34:19 <applicative> typoclass: yes, i was taking the occasion to praise him
06:34:52 <typoclass> applicative: right. then we all agree vigorously. again
06:36:22 <applicative> cseder: I don't know for real, but my sense is that Sublime has a decent crowd of knowledgeable haskell users so it might make sense
06:37:37 * applicative mostly uses his insanely rube-goldbergish textmate I  haskell machinery
06:39:40 <merijn> hmm, there's no showHex that lets you pad to a given number of digits?
06:39:49 <mauke> merijn: printf
06:40:05 <merijn> mauke: That's the answer tha makes me sad :(
06:40:17 <mauke> $(printf "%02X")
06:40:59 <applicative> people always say printf, but there is something better, no?
06:41:11 <applicative> in a library by dafis?
06:42:16 <typoclass> a 'pad' function is easy to write, but yeah, i guess it would be a candidate for putting in base
06:43:51 <applicative> oh i was thinking of this, but its not to the point http://hackage.haskell.org/package/floatshow
06:45:12 * hackagebot dawg 0.11 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.11 (JakubWaszczuk)
06:45:14 * hackagebot adict 0.4.0 - Approximate dictionary searching  http://hackage.haskell.org/package/adict-0.4.0 (JakubWaszczuk)
06:45:23 <merijn> Numeric has a showFFloat that pads, hence my hope there was similar for the others
06:45:28 <cseder> applicative, I use Sublime for almost everything now. For C++, Python and PySide(Qt), Markdown, HTML, you get the idea.
06:45:36 <mauke> :t showFFloat
06:45:37 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
06:45:42 <mauke> doesn't really pad
06:45:52 <mauke> > showFFloat (Just 5) 3.14 ""
06:45:53 <lambdabot>   "3.14000"
06:46:12 <mauke> > printf "%.5f" 3.14 ++ ""
06:46:13 <lambdabot>   "3.14000"
06:46:14 <applicative> hah, daniel fischer's readme for showfloat on bitbucket, is just the criterion results
06:59:58 <sobhan> any one can help me with http://bpaste.net/show/116324/ ?
07:00:54 <sobhan> i have the exact r <- quickQuerry stuff in another function and no error there :/
07:01:49 <mauke> the error is probably the next line
07:01:55 <mauke> what's the type of fromSql?
07:02:36 <sobhan> yeah...
07:02:38 <sobhan> thanks
07:24:59 <merijn> Is there a hton/ntoh for the various WordX datatype?
07:26:44 <mauke> I don't know but I personally think hton/ntoh are evil
07:26:51 <mauke> (they have the wrong type)
07:27:25 <merijn> mauke: I'm open to alternatives...
07:28:30 <mauke> well, what do you need them for?
07:29:00 <hvr> applicative: there's no need to speak up for Emacs, as it's undeniable that Emacs is superior =)
07:29:12 <merijn> To convert data into the proper byte order for writing to the network? attoparsec has primitives for parsing the various byte orders, but that doesn't give an easy way to convert values I'm outputting
07:30:02 <merijn> binary has Put primitives, but I'm still in the phase where I'm manually interacting with the socket to test I'm getting the protocol right, which means using the the Put monad is rather inconvenient to use
07:30:07 <tulcod> merijn: shouldn't you read a bytestring and parse that?
07:31:01 <merijn> Actually, no, binary only has primitives for writing host order, not network order
07:31:09 <merijn> tulcod: That's the reverse of what I want
07:31:35 <tulcod> merijn: ... calculate the bytestring from an int, then?
07:31:41 <merijn> tulcod: Also, parsing would still require me to convert byte orders (although there's already tools from there)
07:32:08 <merijn> tulcod: I was asking for a function to do that to begin with...
07:32:36 <tulcod> okay, just wanted to make sure you weren't looking for Int->Int :)
07:33:13 <merijn> I'm looking for Word16 -> Word16 and friends
07:33:28 <merijn> You can meaningfully change the byte order of Int
07:33:39 <merijn> s/can/can't
07:34:30 <merijn> There doesn't seem to be a "Word16 -> ByteString" either
07:34:51 <mauke> merijn: runPut . putWord16be
07:35:22 <merijn> \o/
07:35:27 <merijn> System.Endian
07:36:18 <merijn> oh, no, I guess that "runPut . putWord16be" is the best option then
07:39:18 <matt444> Hi, just learning. I often see functions declared like so
07:39:29 <matt444> sum :: (Num a) => [a] -> [a]
07:39:40 <matt444> However when I type this into ghci I get an error
07:39:43 <matt444> what am I doing wrong?
07:39:52 <mauke> matt444: typing it into ghci
07:39:59 <mauke> that kind of code is supposed to go in a file
07:40:04 <mauke> you can load files in ghci, though
07:40:10 <matt444> Ah, ok
07:40:18 <matt444> I am used to lisp, where everything can be done in a repl
07:40:36 <matt444> So what is a haskell workflow like? Write functions in a file, load them in the repl to test?
07:41:00 <merijn> matt444: That's my usual workflow, yeah
07:41:15 <merijn> matt444: I tend to define things in a file and then play with them in short expressions in ghci
07:41:28 <MasseR_> matt444: You can also write functions in ghci, but with let syntax
07:41:33 <MasseR_> let foo a b = a + b
07:41:51 <Sculptor> yo
07:41:51 <merijn> MasseR: Those get wiped if you reload your code, though
07:42:06 <FreeFull_> ghci basically behaves like you're in the IO monad
07:42:21 <MasseR> merijn: They do yes. Then again afaik lisp code ran in repl is wiped out too
07:42:22 <matt444> ok, thanks everyone
07:42:32 <MasseR> Oh! 'after you reload', yup true that too
07:43:27 <HugoDaniel> is jhc still being developed ?
07:43:29 <merijn> matt444: Anyhoo, I recommend just using :l and :r to load and reload files
07:43:50 <matt444> I will definitely do that
07:44:02 <matt444> main won't get ran or anything, right?
07:44:15 <MasseR> No it won't
07:44:24 <MasseR> But you can run it explicitly with :main (or just main)
07:48:01 <earth> Haskell rocks
07:48:09 <earth> Somebody had to say it
07:48:21 <int-e> @quote rocks
07:48:22 <lambdabot> dons says: xmonad rocks
07:48:36 <taylorgb> @faq can haskell be awesome
07:48:36 <lambdabot> The answer is: Yes! Haskell can do that.
07:48:41 <sm> earth: right you are
07:48:47 <int-e> @quote monstrosity
07:48:47 <lambdabot> mwc says: control.appliative rocks. now to conver this beautiful three liner into some horrible C monstrosity
07:48:59 <earth> :)
07:49:28 <int-e> !quote ivory
07:49:31 <int-e> @quote ivory
07:49:31 <lambdabot> dons says: we had 15 years building ivory towers - time to throw rocks from the top!
07:49:33 <taylorgb> I suppose the horrible and monstrosity goes without saying
07:49:34 <elliott> earth: I guess you'd know all about rocks
07:49:41 <earth> yes
07:49:52 <earth> heaven is quite elusive though
07:49:56 <int-e> (wrong meaning of "rocks" but nevertheless, oddly appropriate)
07:54:14 <edkk> people of extreme skill, how do I get "parseRawLog rl = fst <$> foldM accum ([], Nothing) (lines rl)" pointfree ?
07:54:31 <edkk> not that that necessarily will look good :p just of curiosity
07:54:34 <elliott> parseRawLog = fmap fst . foldM accum ([], Nothing) . lines
07:54:37 <tulcod> great. the FFI bindings are wrote are a factor 1000 slower than the C library.
07:54:45 <tulcod> that, or my test code is horrible
07:54:47 <elliott> how to derive this: know that (f <$> x) is (fmap f x).
07:54:57 <elliott> rewrite as parseRawLog rl = fmap fst (foldM accum ([], Nothing) (lines rl))
07:55:04 <mauke> @pl parseRawLog rl = fst <$> foldM accum ([], Nothing) (lines rl)
07:55:04 <lambdabot> parseRawLog = (fst <$>) . foldM accum ([], Nothing) . lines
07:55:06 * Eduard_Munteanu only has skill points in summoning @pl
07:55:10 <elliott> know that "f x = g (h (i x))" can be written as "f = g . h . i"
07:55:12 <elliott> and you're done
07:55:15 <edkk> elliott: thanks, man! :-)
07:55:26 <elliott> hm, @pl doesn't change (f <$>) to fmap f?
07:55:30 <Maior> ...does @pl work how I think it does?
07:55:31 <elliott> maybe that's one of the regressions
07:55:36 <Maior> if so, I'm substantially impressed
07:55:41 <tdammers> the (fst <$>) part feels kind of weird, but the rest is actually something I might have done
07:55:54 <Eduard_Munteanu> Maior: it mostly applies a bunch of rules, AFAIK
07:56:02 <earth> ell-i-ott. ee tee phone home.
07:58:12 <edkk> elliott: "how to derive this" especially helpful
07:58:42 <elliott> it comes naturally after a while :)
08:00:23 <mauke> (\x -> f (g x)) ==> (f . g)
08:00:35 <mauke>  @pl 101
08:13:40 <earth> I don't get the elusive monadic, does that make me moronic?
08:15:11 <merijn> earth: Have you read "You Could Have Invented Monads"?
08:15:23 <earth> I certainly have not
08:15:46 <earth> I seriously doubt the proposition :)
08:15:59 * earth googles
08:16:17 <Eduard_Munteanu> It's pretty common to reinvent State for example.
08:16:19 <merijn> earth: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
08:16:24 <earth> there
08:19:57 <tdammers> I'd support "You could have invented some monads", but not necessarily "You could have discovered the monad concept"
08:20:56 <earth> MayBe Not
08:22:55 <earth> I declare monands a form of intellectual terrorism
08:24:20 <edkk> *hand-roll parser using Maybe monad* ... 30 min later ... Nothing
08:24:29 <earth> heh
08:27:02 <tulcod> when running an executable with +RTS -p, i get "the flag -p requires the program to be built with -prof". however, i've done "cabal configure -p --enable-executable-profiling && cabal build". what did i forget?
08:27:45 <Saizan> tulcod: are you running the executable in dist/build/.... ?
08:27:51 <tulcod> Saizan: yes
08:28:21 <Saizan> should work then
08:28:24 <tulcod> do i need to enable some cabal option, or something in ~/.cabal/config, ?
08:29:46 <Saizan> not really, has the build completed successfully?
08:29:57 <tulcod> yes
08:30:06 <tulcod> i mean, i can remove dist/ and get the binary back
08:30:13 <elliott> in my experience --enable-executable-profiling doesn't seem to work. YMMV
08:30:28 <elliott> I just do --ghc-options="-prof -auto-all" or whatever.
08:31:02 <Saizan> mh, it used to work at least
08:31:59 <tulcod> elliott: yep, thanks
08:32:12 <tulcod> so... this is a bug, right?
08:33:13 <elliott> maybe.
08:33:20 <elliott> or maybe it's meant to work like this and neither of us understand it.
08:33:36 <tulcod> in that case, i sense a bug in the documentation :P
08:33:54 <tulcod> any haskell dev who can enlighten us?
08:34:22 <ocharles> didn't GHC change syntax for this in 7.6?
08:34:24 <ocharles> maybe it's related to that
08:35:25 <tulcod> ocharles: that would be weird, because it does work with --ghc-options="-prof -auto-all". the problem is with cabal
08:35:37 <Saizan> tulcod, elliott: https://github.com/haskell/cabal/issues/1199
08:36:09 <elliott> hah
08:36:12 <elliott> maybe that was why it didn't work for me
08:36:14 <Saizan> ocharles: ghc changed -auto-all into something else, but i think it still supports -auto-all
08:36:29 <tulcod> Saizan: THANKS! ugh, i have 1.16.0.2
08:36:57 <ocharles> tulcod: classic off-by-one error ;)
08:37:38 <tulcod> ocharles: hehe
08:37:50 <tulcod> okay thanks guys, now i'm gonna complain to the packagers that htey need to update cabal
08:40:17 <tulcod> oh great
08:40:20 <tulcod> 1.16.0.3 is not released yet
08:41:20 <elliott> git cabal is pretty good
08:42:28 <tulcod> so... any chance 1.16.0.3 will be released soon?
08:48:44 <tulcod> i love it when CS tools work. after a bit of profiling, i reduced the execution time tenfold already
08:50:02 <applicative> nice work tulcod
08:50:17 <tulcod> hm. time for Data.Vector, i think
08:50:33 <applicative> this is a dumb question, but is there some test like "isTextFile" or does that make sense
08:50:51 <applicative> Data.Vector.Unboxed
08:50:57 * applicative repeats his mantra
08:51:44 <applicative> or maybe a test like "isObnoxiousBinaryFileDon'tDoTextHGetLineOnMe"
08:53:10 <shanse> well, you could consult file(1)
08:53:20 <applicative> hm...
08:53:37 <mauke> it's all guesswork
08:54:47 <applicative> ah, I see something like file(1) is what I was looking for inside haskell; but the man page warns its 'probably safe to read in the terminal' if its "text"
08:55:43 <merijn> applicative: Maybe google for mimetype-sniffing
08:55:56 <applicative> hm, yes the man page makes it seem like pretty dark business
08:56:03 <shanse> it really is
08:56:19 <joeyh> is the goal to avoid a crash with an encoding error?
08:56:31 <applicative> joeyh: basically yes.
08:56:53 <applicative> i'm just writing various filesystem recurse type functions testing the new pipes
08:57:49 <applicative> but most of the actions it is natural for me to perform, given a flood of filepaths, is to open and read ...
08:58:03 <joeyh> one approach is to open the file, and then set the handle to use GHC.IO.Encoding.getFileSystemEncoding
08:58:30 <joeyh> then anything you read that is not decodable in the current locale will be represented in a way that avoids encoding crashes
08:59:00 <applicative> oh thanks joeyh I will study that
08:59:40 <joeyh> hmm, I suppose just using ByteString might be a better way, depending on what you're doing ;)
09:02:23 <applicative> joeyh: maybe combining bytestring with some of the validation functions for encodings in Data.Text or something
09:04:03 <elliott> you can do bytestring -> decode using text so that invalid stuff gets replaced with substitution chars
09:11:15 <tulcod> okay, so i have one big "main loop" function which just calls a bunch of functions in a do {} statement. according to the profiler, it takes up 86% of the execution time, with no subfunction really explaining that. what is that main loop func doing?
09:11:40 <applicative> sounds like it's calculating
09:12:01 <tulcod> applicative: it's not doing many calculations, it's just passing IO vars around
09:12:07 <tulcod> though it has 95% alloc
09:12:49 <applicative> can you paste, some people can tell at a glance ...
09:13:53 <tulcod> applicative: just had an idea, let me see if i wrote the Vector stuff wrong
09:13:57 <applicative> elliott I was wondering if I could just get a bunch of bytes though, and test for Textiness; the test might break because I didn't end at a break 'between chars' but I will study
09:14:21 <applicative> you have Vectors of IORefs or something
09:14:44 <tulcod> applicative: just had an idea, let me see if i wrote the Vector stuff wrong
09:14:46 <tulcod> oops
09:14:55 <applicative> of course, a Data.Vector.Vector sort of is a Vector of IORefs or something
09:15:32 <elliott> applicative: what will you do if it's not text?
09:15:33 <tulcod> ah yeah, my Vector update code is better than my list update code, but not quite good enough :P
09:15:40 <tulcod> seems like i'll have to dive into this MVector thing
09:16:00 <elliott> tulcod: I wouldn't jump to a mutable vector
09:16:06 <elliott> what kind of vector are you using?
09:16:46 <tulcod> elliott: boxed vector of Bools
09:17:13 <elliott> try unboxed.
09:17:16 <tulcod> in a loop, i generate a typical value, switch the Bools at the corresponding index, and depending on True or False i do adifferent FFI
09:17:21 <applicative> elliott: I was going to throw it out, I'm basically wanting a "isPlainText" test, like "doesDirectoryExist" , at least at the moment.
09:17:27 <tulcod> s/typical/random/
09:17:50 <tulcod> elliott: what's the difference?
09:18:11 <bscarlet> applicative: Do you know what encoding you mean by "plain text"? UTF-8, ascii, ?
09:18:16 <elliott> tulcod: instead of storing pointers to possibly unevaluated values, it stores the values directly.
09:18:20 <mauke> there is no such thing as "plain text"
09:18:23 <elliott> so it's strict. but often a lot better.
09:18:28 <tulcod> elliott: ah. awesome, i need that
09:18:35 <elliott> just importing .Unboxed instead should work.
09:18:37 <tulcod> elliott: yes.
09:20:26 <applicative> bscarlet: I'm just thinking this through, the simpleminded thing I want is a test that e.g. Data.Text.IO.Readfile wont break
09:20:48 <applicative> the more I think about it the more nonsensical it seems.
09:20:59 <bscarlet> applicative: yeah.
09:21:16 <applicative> mauke: yes I understand that, thats why I adopted such a stupid name
09:21:21 <tulcod> elliott: yeah, it's a lot better. let's see if it's as fast as the C code when i disable profiling :)
09:21:54 <tulcod> (C code is 5.27s, haskell with profiling 27.7s)
09:22:18 <applicative> oh, it was a vector of bools tulcod?
09:22:24 <tulcod> yes
09:22:43 <elliott> tulcod: remember -O2!
09:22:54 <tulcod> 11.18s, but i'm outputting much more stuff (redirected to /dev/null)
09:22:58 <tulcod> elliott: do i pass that to cabal?
09:23:04 <elliott> --ghc-options="-O2"
09:23:11 <elliott> maybe there is a cabal thing for it. dunno
09:23:18 <applicative> you can put it in the .cabal file if you have one too yes
09:23:29 <applicative> cabal defaults to something sensible,no?
09:24:04 <elliott> -O
09:24:06 <djahandarie> I believe it defaults to -O
09:24:07 <tulcod> 10s.
09:24:09 <elliott> but if you are measuring performance intensive stuff vs. C...
09:24:12 <applicative> hm
09:24:22 <tulcod> well, it's only 2x slower than the C code. good enough for my purposes
09:24:25 <elliott> tulcod: twice as slow as C with more output is pretty good :)
09:24:30 <elliott> though I'm sure you could get it even better
09:24:32 <tulcod> yeah i disabled that
09:24:54 <tulcod> elliott: i'm sure i could. but this is only test code
09:25:23 <tulcod> the point is to show that my FFI doesn't add loads of performance issues
09:25:55 * djahandarie has recently generated code which is faster than the C code thanks to the recent SIMD stuff
09:26:17 <applicative> tulcod: in the .cabal file add  GHC-Options: -O2 on a level with Build-Depends or whatever
09:26:29 <tulcod> applicative: sweet, thanks
09:26:46 <djahandarie> You can try -fllvm too, sometimes (often) it does better
09:27:58 <tulcod> okay thanks a lot guys, i'm another step further :)
09:30:02 <Apocalisp> @type flip either id
09:30:02 <lambdabot> (a -> c) -> Either a c -> c
09:32:48 <applicative> mauke my idea was to write things equivalent to say grep -R Monad . without crashing somewhere, now that I have the -R handled ...
09:34:17 <applicative> i guess grep just goes throught the binary files too having turned "Monad" into its conception of a bytestring
09:37:18 <monochrom> applicative, tulcod: there is no longer a need to hardcode -O2. see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#O2
09:38:02 <tulcod> monochrom: thanks :)
09:38:17 <applicat1ve> That's right, it does not have to be boolean!
09:39:00 <applicat1ve> I take it that when building libraries I want this to have accumulated, as with profiling
09:39:42 <applicat1ve> monochrom: but I want my libraries built with -O2 even if you are an -O slacker
09:40:00 <applicat1ve> I mean, I want your cabal to build them thus
09:41:32 <applicat1ve> wasnt there a plan to test an omnibus of more dangerous timeconsuming flags to be -O3
09:41:43 <monochrom> this falls into the grey area of who (author vs user) should control optimization settings
09:42:36 <applicat1ve> yes, I hadn't reflected that there is a conflict there
09:43:00 <applicat1ve> I remember when `text` used to require -fspec-constr=1003 or something
09:43:08 <applicat1ve> and I felt a little conflict
09:43:09 <monochrom> marx : society :: monochrom : programming. monochrom says: programming is a dialectic class struggle between authors and users :)
09:52:54 <josephle> ...who is the proletariat and who is the bourgeois?
09:54:26 <monochrom> everyone thinks that self is the oppressed proletariat
09:55:01 <aristid> applicat1ve: what did -fspec-constr=1003 do?
10:13:33 <gdoteof> not sure if ic an really get support for this in here: http://pastie.org/8164650
10:14:24 <Jeanne-Kamikaze> use -v3 to get more output
10:14:40 <Cale> gdoteof: That looks like maybe the build got OOM killed?
10:15:07 <Cale> ExitFailure 9 means that the process received a SIGKILL from somewhere
10:15:18 <gdoteof> Cale: ah.  okay.
10:15:24 <gdoteof> makes sense.. 512M machine
10:17:40 <c_wraith> oh.  yeah, many haskell packages make the linker eat way more than 512M
10:18:13 <luite> als GHC itself
10:18:15 <luite> also
10:18:43 <c_wraith> GHC usually doesn't use that much by itself.  It's usually ld that goes nuts dealing with GHC's object files
10:18:47 <notdan> I heard that you could use gold to reduce the memory footprint when linking
10:19:00 <gdoteof> thanks, yeah that fixed it.  i made a swap file for it and it was fine
10:19:12 <notdan> But it didn't work nice for me, I forgot what was the problem tho
10:19:29 <c_wraith> notdan: I've tried, it has trouble linking against native code sometimes
10:19:38 <luite> notdan: also linux's linker seems better/faster than the os x linker
10:19:52 <luite> but it all doesn't help for things like haskell-src-exts where ghc itself uses well over a GB
10:20:19 <c_wraith> notdan: but they're actually compatible.  You can use gold while building problematic packages and ld the rest of the time, and things work - at least in the few tests I did.
10:20:34 <c_wraith> The really hard-to-build package from my testing was hxt
10:21:38 <notdan> hm, strange, hxt built just fine on my low-on-memory machine
10:21:46 <notdan> it took a long time to compile all the modules though
10:22:07 <notdan> pandoc was a disaster
10:22:23 <klrr> do you need to learn pipes, frp and lenses to do stuff properly, is using vanilla haskell consider "less good"?
10:22:30 <chrisdone> hvr: poke
10:22:41 <notdan> klrr: I don't think so
10:22:54 <notdan> don't think it's necessary
10:22:54 <klrr> it feels like cheating not to use them :x
10:23:00 <hvr> chrisdone: 'sup?
10:23:02 <josephle> klrr: not particularly, each one of those answers a specific problem people hit when they code haskell
10:23:10 <notdan> all of those are examples of very good and thought-through libraries
10:23:34 <klrr> none with has lots of documentation though
10:23:36 <pamojarpan_> hi
10:24:03 <klrr> chrisdone: did you see the name search term issue in lpaste i posted on github?
10:24:36 <chrisdone> klrr: yeah it's less trivial than you think but not hard, i'll do it later this evening
10:24:46 <supki> wait what
10:24:54 <supki> lens has lots of documentation
10:24:57 <josephle> to be fair, pipes and frp have a diversity of implementations on hackage, and lens is actually pretty well documented
10:24:59 <pamojarpan_> can someone help with a performance problem? http://pastebin.com/m7JR7Ez9
10:25:04 <mauke> The paste m7JR7Ez9 has been copied to http://lpaste.net/91129
10:25:26 <pamojarpan_> I'm getting stack overflow with this image: https://filetea.me/default/#t1sgFx2xNefS6eofVf6WV83fw
10:25:34 <chrisdone> hvr: i'm thinking it would be nice to have projects in emacs that can specify things of interest about sessions
10:25:37 <klrr> chrisdone: also, is the source code on github outdated or me just suck at understanding code?
10:26:01 <klrr> supki: didnt mean lens havent tried to learn it yet :P
10:26:04 <hvr> chrisdone: ...I don't follow (yet)...
10:26:31 <chrisdone> klrr: the git repo is up to date
10:26:42 <Cale> pamojarpan_: This is obviously unrelated, but there are tabs in your source code. You might want to configure your text editor to convert them to spaces automatically.
10:26:50 <hvr> chrisdone: what kind of 'things' are you referring to?
10:27:28 <Cale> pamojarpan_: Probably the stack overflow is in median'
10:27:41 <pamojarpan_> thanks Cale (I prefer tabs over spaces, but I know spaces are better for haskell source)
10:27:58 <klrr> chrisdone: okey, but the Irclog.hs file did use some other irc log website than the one running
10:28:13 <Cale> pamojarpan_: Yeah, using tabs in Haskell source is a bit antisocial :)
10:28:25 <pamojarpan_> Cale: I think the problem is in histogram
10:29:26 <Cale> pamojarpan_: Well, how long is the list produced by histogram?
10:29:52 <Cale> pamojarpan_: Your image link is a 404
10:30:06 <pamojarpan_> Cale: about 4000
10:30:42 <Cale> 4000 should not be an issue...
10:31:01 <chrisdone> hvr: e.g. the cabal dir and current directories, right now, are guessed and prompted. whether to use fobject code or not is an option, whether to use hsenv and where from, per-project indefinite history (like SLIME has) and perhaps some other settings that we're not aware could be settings because we don't have a means to save per-project settings
10:31:03 <pamojarpan_> Cale:  thats the produced list
10:31:38 <pamojarpan_> the input list (pixelList img) has 6,000,000 elements
10:31:56 <pamojarpan_> Cale: it depends on the size of the image
10:32:43 <Cale> pamojarpan_: Rather than concatMap nub, why not map head?
10:33:00 <hvr> chrisdone: tbh, I never liked the Eclipse approach to force me to create projects... so how invasive would the project-support you have in mind be?
10:33:28 <elediaz> histogram ∷ GrayImage → [(Double, Int)]
10:33:29 <elediaz> histogram !img = fmap (λx → x `seq` (head x, length x)) sorted
10:33:29 <elediaz>     where
10:33:29 <elediaz>         !sorted = group $ sort $ pixelList img -- [[a]]
10:33:43 <elediaz> pamojarpan_: head and map
10:34:09 <Cale> elediaz: Why the bang pattern?
10:34:23 <Cale> That's not going to do much at these types
10:34:37 <pamojarpan_> Cale: a friend of mine (elediaz) tried it, but he got the same performance
10:34:42 <elediaz> i dont know how reduce gc
10:34:54 <chrisdone> hvr: i'd consider it more like a way to persist settings for a session
10:35:07 <Cale> Can I have your image file?
10:35:15 <pamojarpan_> sure
10:35:22 <pamojarpan_> give me a second, Cale
10:35:23 <hvr> chrisdone: ...like creating a .-file besides the .cabal file?
10:35:26 <chrisdone> hvr: e.g. haskell-menu could be the entry point
10:35:39 <chrisdone> hvr: possibly, not sure
10:35:40 <dcoutts> hvr: next version of cabal has local config files
10:36:05 <hvr> dcoutts: I noticed already (and even mentioned them in my lecture)
10:36:16 <pamojarpan_> Cale: any pgm over 2megapixels may produce a stack overflow
10:36:32 <chrisdone> dcoutts: what's a "local" config file?
10:36:33 <hvr> dcoutts: I told the students to forget about cabal-dev, and look out for the Cabal release instead :)
10:36:55 <chrisdone> ah, you're talking about a package config?
10:37:03 <dcoutts> chrisdone: like ~/.cabal/config but in a project-local file, e.g. you can check it in to source control
10:37:08 <chrisdone> as in, -package-db or -package-conf or whatever it's calling itself these days =)
10:37:11 <chrisdone> ahhh
10:37:13 <chrisdone> cool
10:37:32 <hvr> dcoutts: I've already played with it in the context of CI build-jobs
10:37:33 <luite> elediaz: hmm, sorting all pixels sounds rather suboptimal
10:38:29 <luite> elediaz: you can do it with one pass through the list by adding everything to a Map every step, the intermediate list might be optimized out then
10:38:46 <hvr> chrisdone: but I'm not sure per-project .cabal/config files are of any use to us
10:39:02 <hvr> (for Emacs)
10:39:36 <chrisdone> hvr: yeah, neither did i mean per-project .cabal/config files. i think duncan was just mentioning it
10:39:43 <chrisdone> i mean emacs-specific stuff
10:39:58 <chrisdone> the .cabal file already has cabal-specific stuff, we don't have anything to save emacs settings
10:40:32 <dcoutts> chrisdone, hvr: yes, just mentioned it because it seemed related, and in case it was useful to you
10:40:34 <elediaz> luite: its true
10:40:59 <Cale> I would really like to be able to actually run this program to see what's happening here
10:41:30 <pamojarpan_> Cale: sorry, I'm in a slow internet connection right now
10:42:46 <hvr> chrisdone: I was wondering some time ago, if something like that could be accomplished the Emacs way, by using file-local variables in the .cabal file
10:43:07 <hvr> chrisdone: as the .cabal file is usually the entry point for sessions
10:43:09 <chrisdone> that seams neat for emacs, but invasive for the cabal file
10:43:15 <johnw> hvr: hi, just about to try out your ghci-ng integration :)
10:43:29 <hvr> johnw: good luck :-)
10:43:41 <luite> elediaz: but the stack overflow should be fixable in the current version :)
10:43:42 <hvr> johnw: which ghc-version and OS are you on?
10:44:09 <johnw> 7.4.2 OS X 10.8.4
10:44:29 <hvr> johnw: that's going to be interesting then :)
10:44:29 <pamojarpan_> Cale, luit: https://anonfiles.com/file/b8c59a621f9c9d0e377bfe56db7b9c68
10:44:36 <pamojarpan_> that's the test image
10:45:13 <hvr> johnw: the ghci-ng 7.4.x version has only ":complete" support backported so far
10:45:33 <hvr> (which is all that haskell-mode uses so far)
10:45:52 <prophile> so the composition of functors is a functor and the composition of applicatives will be an applicative - but not necessarily for monads. what's the condition under which the composition of two monads is itself a monad?
10:46:01 <hvr> johnw: did 'cabal install ghci-ng' work?
10:47:10 <johnw> let me see
10:47:23 <johnw> i also have a 7.6.3 env
10:47:25 <Cale> oh
10:47:26 <johnw> it worked there
10:47:33 <Cale> Yeah, this is definitely mediam
10:47:37 <Cale> median*
10:47:47 <Cale> You compute the median of the entire image in mtb
10:48:09 <Cale> errr
10:48:17 <Cale> actually, maybe not
10:48:26 <Cale> That actually prints out okay, I just noticed
10:48:33 <Cale> So, perhaps it's writeImage
10:49:38 <pamojarpan_> Cale: the problem is realted to memory allocation, without writeImage calling, the memory used is about 500MBs... too much memory for a such simple filter
10:49:45 <pamojarpan_> related*
10:50:11 <pamojarpan_> Cale: including writeImage, it goes to over 800MBs
10:50:36 <Cale> That's not entirely surprising, given the way this program is written.
10:51:15 <Cale> You're using lists of pixel values, you can't expect it to be memory efficient at all :P
10:51:19 <pamojarpan_> Cale: I'm a newbie... :S
10:51:27 <Cale> (if you weren't sorting the list, maybe)
10:51:50 <luite> pamojarpan_: is each pixel value an Int?
10:52:26 <luite> i think i missed the location of the actual prgoram
10:52:48 <pamojarpan_> I'm using a library to read/write images (and I wanna use it for convolutions and other filters) that uses Doubles
10:53:05 <pamojarpan_> luite: http://pastebin.com/m7JR7Ez9
10:53:05 <mauke> The paste m7JR7Ez9 has been copied to http://lpaste.net/91129
10:55:10 <Cale> okaaaaaay
10:55:12 <Cale> That's interesting
10:55:17 <hvr> chrisdone: I see the value to have some few things persisted "per-project" in some way, but right now I don't miss the ability (yet)
10:56:40 <hsn> @faq is there something like a list filtering?
10:56:40 <lambdabot> The answer is: Yes! Haskell can do that.
10:56:56 <haasn> :t filter
10:56:57 <lambdabot> (a -> Bool) -> [a] -> [a]
10:57:00 <johnw> hvr: ghci-ng does not install under 7.4.2
10:57:10 <luite> pamojarpan_: ok, a Double... a list of pixels, fully evaluated would take ~40 bytes of memory per pixel
10:57:13 <hvr> johnw: can you locate the cause?
10:57:14 <luite> on 64 bit
10:57:33 <Cale> I just copied the code for toPGM into the source file, and recompiled, and it worked
10:57:38 <johnw> hvr: https://gist.github.com/6056026
10:58:20 <lpaste> Cale pasted “lol toPGM why” at http://lpaste.net/91130
10:58:41 <Cale> ^^ build that with -O2 and it doesn't crash
10:59:04 <hvr> johnw: that's weird... it works fine here on GHC-7.4.2/linux
11:00:11 <Cale> pamojarpan_: I think you can blame the authors of this image library you're using
11:00:24 <skypers> hi
11:00:29 <hvr> johnw: could you maybe rerun the cabal install with a high --verbose setting?
11:00:29 <pamojarpan_> Cale: thank you very much
11:00:49 <pamojarpan_> Cale: I shoub be using something more "serious" like OpenCV
11:00:54 <pamojarpan_> should*
11:01:24 <pamojarpan_> Cale: do you have experience with OpenCV and its bindings for haskell?
11:02:34 <Cale> pamojarpan_: http://hackage.haskell.org/package/CV ?
11:02:36 <pamojarpan_> Cale: and as conclusion, list of doubles has a really poor performance and the library I'm using has a naive implementation, right?
11:03:19 <pamojarpan_> Cale: right, I'm reading that
11:03:20 <Cale> pamojarpan_: Well, you'd probably want to use something like Data.Vector for this, and store the images packed neatly in memory even if it is a giant array of Doubles
11:05:31 <c_wraith> If you want interop with native libs, which I assume you do with OpenCV, you really want the Storable vectors
11:05:33 <Cale> But a list, if it ends up all in memory, is going to have cons cells which consist of an integer tag, together with a pair of pointers, for each of the elements of the list, and then the elements themselves are boxed (to support laziness and polymorphism), which means that you have another tag and pointer to deal with for each element
11:05:54 <Cale> and you can see how that multiplies the size of memory required to store the thing :)
11:06:11 <pamojarpan_> Cale: So list are a arrays of pointers?
11:06:30 <Cale> Lists are linked lists
11:06:44 <Cale> and in fact, they're kind of weird linked lists
11:06:56 <Cale> where the pointers are pointers to code
11:07:04 <pamojarpan_> Cale: ah, I got it
11:07:18 <Cale> (because you might have unevaluated expressions)
11:08:15 <Cale> If you have something like   map (*2) [1..]  and you evaluate that one step by pattern matching on it with the pattern (x:xs), you end up with a list like  ((*2) 1) : (map (*2) [2..])
11:08:17 <pamojarpan_> Cale: and is Vector.Unboxed the best alternative?
11:08:35 <c_wraith> pamojarpan_: no, you want Vector.Storable for native interop
11:09:01 <Cale> Well, Vector.Unboxed would be okay too if you don't need to do FFI with OpenCV
11:09:18 <c_wraith> I'm pretty sure you do need to do FFI with that, though
11:09:28 <Cale> yeah
11:10:01 <Cale> Well, the CV package seems to just use ForeignPtrs for images anyway
11:11:07 <pamojarpan_> I didn't know that a map is translated to that, Cale
11:11:40 <luite> hmm, perhaps the FFI should be extended a bit to make it easier to pass ByteArray# to foreign code
11:12:21 <Cale> pamojarpan_: Oh, what I was going to say about that list above is that you actually end up with some representations of those expressions in memory
11:12:51 <Cale> So the (:) is represented by an integer tag (which distinguishes it from []), together with pointers to code for each of the expressions that it was applied to
11:13:26 <Cale> Normally, I wouldn't bother thinking at this low a level, and just picture the partially evaluated expressions at runtime as graphs of code
11:13:40 <Cale> (after all, the pointers are essentially arcs in a graph)
11:14:47 <pamojarpan_> Cale: but the proyect i'm working on is realted to image processing, I'm translating it from C++ (I hate it) but I need some performance
11:15:29 <c_wraith> luite: is bytearray# pinned?
11:15:35 <c_wraith> err, ByteArray#
11:15:42 <Cale> Right, well, for big images, you probably don't want to use lists. Lists are basically for things you're going to loop over. They can be *very* efficient if you only need one (or a few) elements of the list at a time.
11:15:51 <luite> c_wraith: you can make a pinned one, but not always
11:16:22 <Cale> But if you need random access of any sort, lists are fairly bad, performance wise.
11:16:54 <pamojarpan_> Cale: ah, that's why ! 1000 has a fucking poor performance
11:17:02 <c_wraith> luite: oh, hmm.  ByteArray# supports mutation, doesn't it?  Yeah, it would be nice if you could get FFI to cooperate with it.
11:17:03 <pamojarpan_> Cale: I'm learning a lot :D
11:17:21 <pamojarpan_> ( !1000) -> Look up by index
11:17:26 <Cale> pamojarpan_: Well, xs !! n takes O(n) steps
11:17:30 <luite> c_wraith: you can allready pass them to foreign things with the UnliftedFFITypes extension, but that's rather annoying to work with
11:17:31 <Cale> @src (!!)
11:17:31 <lambdabot> xs     !! n | n < 0 = undefined
11:17:31 <lambdabot> []     !! _         = undefined
11:17:31 <lambdabot> (x:_)  !! 0         = x
11:17:31 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:17:50 <Cale> It *has* to walk down the list one element at a time
11:17:51 <c_wraith> luite: holy crap, yet another extension I'd never heard of.
11:18:24 <luite> c_wraith: you did hear of the JavaScriptFFI extension, didn't you? ;)
11:18:38 <c_wraith> luite: I heard of that one!
11:18:43 <luite> good :p
11:18:46 <klrr> anyone know a tutorial on pipes that is not made by the author of the library+
11:18:53 <Cale> pamojarpan_: An operation like modifying the nth element of a list is about as unnatural as writing a loop which does something entirely different on its nth iteration.
11:19:18 <pamojarpan_> Cale: got it :)
11:19:58 <Cale> pamojarpan_: Just as a loop either doesn't happen, or has one iteration followed by another loop, a list is either empty, or has an element followed by another list. :)
11:21:20 <pamojarpan_> I have to go for some minutes, I'm allways on #haskell.es (spanish) but I'll be here more ofte. Be right back
11:21:26 <pamojarpan_> thank you guys
11:21:27 <pamojarpan_> :D
11:22:52 <klrr> > foldr (\x y -> concat ["(f ",x," ",y,")"]) "z" (map show [1..5]) -- (C) Cale 2008
11:22:53 <lambdabot>   "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
11:23:01 <luite> :)
11:23:50 <Cale> klrr: lol
11:24:05 <klrr> Cale: found it on some random website :P
11:24:07 <luite> oh! i promised i'd make the ghcjs web heap/stack step by step reduction thing interactive. going to do that next week, no realli :p
11:24:22 <luite> letting you enter your own expr
11:24:34 <Cale> klrr: Well, I did write that code, but I don't hold any claim to copyright on it :P
11:25:00 <klrr> Cale: was more of a joke :P bad joke sry...
11:25:49 <Cale> I thought it was funny. I would just find it a bit weird if you found it with the (C) in the wild like that :)
11:25:57 <elliott> > foldr f z [1..5]
11:25:57 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
11:26:03 <elliott> modern technology.
11:26:52 <klrr> foldr cons nil [1..5]
11:26:55 <klrr> :P
11:28:25 <klrr> > foldr (:) [] [1..5]
11:28:26 <lambdabot>   [1,2,3,4,5]
11:28:28 <klrr> :D
11:31:21 <Ankhers> Is there a way, without a lambda, that I would be able to add a list of Integers together?
11:31:36 <tac> > sum [1,2,3]
11:31:37 <lambdabot>   6
11:31:42 <c_wraith> Ankhers: without a literal lambda? of course.  You can always write a named function instead
11:31:55 <bscarlet> > foldr (+) 0 [1,2,3]
11:31:56 <lambdabot>   6
11:32:21 <klrr> > [1..]
11:32:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:32:28 <Ankhers> I had been thinking about this for the past couple days... and the second I hit enter, I remember about folds...
11:32:33 <Ankhers> Thank you everyone...
11:32:35 <klrr> > take 2[1..]
11:32:36 <lambdabot>   [1,2]
11:32:41 <klrr> > take 100 [1..]
11:32:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:32:45 <klrr> hmm
11:33:01 <bscarlet> > getSum . fold . map Sum $ [1,2,3]
11:33:02 <lambdabot>   6
11:33:13 <c_wraith> > let incrediblyVerboselyNamedSum [] = 0 ; incrediblyVerboselyNamedSum (x:xs) = x + incrediblyVerboselyNamedSum xs in incrediblyVerboselyNamedSum [1..100]
11:33:14 <lambdabot>   5050
11:33:38 <klrr> that looks like C++
11:33:41 <klrr> variable names
11:33:52 <c_wraith> Or java
11:34:49 <klrr> both have C-like syntax , is OOP, and both is maintream
11:34:53 <bscarlet> no, in C++ it'd be incrediblyVerboselyNamedSumInstanceManagerOperation
11:35:26 <b2coutts> and in java, it'd be incrediblyVerboselyNamedSumDataFactoryNodeI
11:35:43 <haasn> > sumOf each [1..100]
11:35:44 <lambdabot>   Not in scope: `sumOf'Not in scope: `each'
11:35:48 <haasn> elliott!!
11:36:07 <elliott> I've been busy! sorry!
11:36:25 <elliott> you could help fix it by writing a patch to make Control.Lens.Action Trustworthy. and then fixing whatever else you need to get Control.Lens safe. :p
11:36:28 <shachaf> It's very bizarre that people see "forall" and think "existential type".
11:36:40 <shachaf> It means the exact opposite.
11:37:40 <johnw> maybe because you can enable the use of forall with LANGUAGE ExistentialQuantification?
11:39:09 <shachaf> Maybe.
11:39:22 <shachaf> I wrote an explanation of "fast" reflection: http://stackoverflow.com/questions/17793466/black-magic-in-haskell-reflection
11:42:29 <Eduard_Munteanu> Fun: even though I spawn a thread to read from the fifo and put it into an MVar, takeMVar dies with "thread blocked indefinitely in an MVar operation"
11:43:23 <c_wraith> Eduard_Munteanu: that would mean that no running code can write to that MVar
11:43:43 <c_wraith> Eduard_Munteanu: so maybe that thread is dying somehow
11:43:56 <Eduard_Munteanu> c_wraith: you mean the MVar writer?
11:44:02 <Cale> yeah
11:44:22 <Eduard_Munteanu> Hrmpf... so perhaps hGetContents from ByteString.Char8 doesn't work either.
11:45:08 <Eduard_Munteanu> I think only fdReadBuf fixes this madness. :(
11:45:47 <Eduard_Munteanu> (cause even fdRead throws an exception on EOF, as far as the docs say)
11:46:11 <Eduard_Munteanu> I'm pretty sure I want to block reading from the fifo until EOF.
11:46:46 <c_wraith> Eduard_Munteanu: you could try just catching the exception
11:47:18 <taylorgb> Is he still suffering with named pipes?
11:47:50 <Eduard_Munteanu> I am. :)
11:48:14 <pentace> Is there an easy-to-understand documentation about what actually happens behind the scenes in GHC when expressions are evaluated, how data is stored, etc.?
11:49:08 <c_wraith> pentace: maybe this series of posts? http://blog.ezyang.com/2011/04/the-haskell-heap/
11:50:44 <taylorgb> Also the section in RWH that explains evaluation in terms of parallel programming can be a fair introduction I guess
11:51:23 <pentace> c_wraith: No, I want it more in detail :)
11:51:32 <josephle> does anyone know what madness lies beyond STG? Does GHC compile STG to continuations? Does it "eliminate" closures?
11:51:48 <luite> josephle: it compiles STG to Cmm
11:52:17 <luite> josephle: first to "normal" code, that just calls a function to force a thunk, etc
11:52:29 <haasn> josephle: you should see the variety of publications by SPJ on this topic if you're interested
11:52:30 <luite> josephle: then it runs a CPS transformation, convertion all calls to tail calls
11:53:27 <pentace> taylorgb: RWH = Real World Haskell?
11:53:32 <taylorgb> yeah
11:53:44 <taylorgb> but given your comments I suspect it's probably too light for your interests
11:54:19 <c_wraith> There was a presentation by Simon Marlow on changes to the evaluation mechanism around GHC 7's release
11:54:23 <josephle> luite haasn: thanks! I took a course on compiling functional langauges (source language SML), so I was wondering what type of transformations ghc did on the path to c--
11:54:28 <c_wraith> I suspect that's the level of detail you want
11:54:32 <c_wraith> I wonder if I can find it again
11:55:40 <luite> josephle: laziness makes a pretty big difference here
11:56:11 <haasn> josephle: https://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
11:56:21 <haasn> https://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/ might also be interesting
11:56:24 <c_wraith> He's done so many things. I can't figure out which was the presentation I'm thinking of. :(
11:56:58 <haasn> there's also another book on the STG in particular somewhere
11:57:35 <josephle> luite: well according to your list, it seems laziness is eliminated in the first transformation from STG?
11:57:54 <haasn> laziness is never eliminated
11:58:18 <haasn> well, not necessarily
11:58:20 <ReinH> @pl p (x,y) = Point x y
11:58:20 <lambdabot> p = uncurry Point
11:58:51 <klrr> kind of off topic but what is your guiys opinion on this? https://gist.github.com/klrr/6049842
11:58:56 <pentace> taylorgb: Not sure I'm looking at the correct chapter but I can't find anything about it in there
11:59:02 <ReinH> timezome appropriate greeting folks
11:59:08 <edwardk> lambdabot: seen refold
11:59:12 <luite> josephle: the generated code still looks different. in general, closures and data types are converted to heap objects, that store a function, some data (free variables, or the fields of a constructor) and some metadata
11:59:14 <edwardk> @seen refold
11:59:14 <lambdabot> reFO1D
11:59:22 <shachaf> preflex: seen refold
11:59:22 <preflex>  refold was last seen on #ghc 11 days, 17 hours, 34 minutes and 41 seconds ago, saying: ?
11:59:26 <edwardk> preflex: xseen refold
11:59:26 <preflex>  refold was last seen on freenode/#ghc 11 days, 17 hours, 34 minutes and 44 seconds ago, saying: ?
11:59:45 <shachaf> edwardk: Note that preflex has been offline for a bit recently.
12:00:01 <luite> josephle: when you pattern match on something, and you get a thunk, you call the associated function to reduce it to whnf
12:00:11 <edwardk> yeah, i went to tab complete and it wasn't showing up so i just asked lambdabot. should have just hit tab a couple of extra times ;)
12:00:52 <ReinH> edwardk: hai
12:00:58 <ReinH> edwardk: do you have a sec to chat?
12:00:59 <edwardk> heya ReinH
12:01:00 <edwardk> sure
12:05:33 <shiona> I've never really seen the point in client ads in quit messages
12:05:59 <shiona> Like, if your client doesn't run 24/7, why advertise the fact
12:15:49 <edkk> shiona: agreed
12:31:08 <edwardk> supki: re CatchT docs, go for it
12:33:17 <MouseTheLuckyDog> It's a boy.
12:34:16 <Taneb> MouseTheLuckyDog, shh, spoilers, I'm only up to episode 4 yet
12:34:26 <Taneb> Also, completely off-topic
12:43:35 <sobhan> any idea why try ( print 1 ) is complaining ?
12:44:03 <c_wraith> sobhan: my best guess is because it doesn't know what type of exception you're talking about
12:44:10 <johnw> sobhan: you really have to give us more to go on than that
12:44:52 <HexSquid> Hi folks :)
12:44:58 <johnw> hello HexSquid
12:45:19 <sobhan> HexSquid: Hi
12:45:32 <Cale> sobhan: How is it complaining?
12:45:44 <Cale> :t print 1
12:45:45 <lambdabot> IO ()
12:45:52 <Cale> It's a valid IO action
12:46:07 <johnw> > try $ print 1
12:46:08 <lambdabot>   No instance for (GHC.Exception.Exception e0)
12:46:09 <lambdabot>    arising from a use of `e_11...
12:46:19 <johnw> > try $ print 1 :: Either SomeException ()
12:46:20 <lambdabot>   Couldn't match expected type `Data.Either.Either
12:46:20 <lambdabot>                           ...
12:46:25 <johnw> > try $ print 1 :: IO (Either SomeException ())
12:46:26 <lambdabot>   <IO (Either SomeException ())>
12:46:29 <Cale> oh, try
12:47:20 <sobhan> johnw: thanks
12:47:20 <sobhan> Cale: thanks
12:47:30 <Cale> Yeah, you have to specify the type there so that it knows which exceptions to catch
12:47:48 <HexSquid> I'm just getting started with Haskell and FP in general - I'm trying to find the right way to understand what -> actually means in a :t signature.
12:47:50 <Cale> (if you use SomeException, it'll catch everything)
12:48:01 <joelteon> :t try
12:48:02 <lambdabot> Exception e => IO a -> IO (Either e a)
12:48:06 <HexSquid> Does it mean 'returns' or 'takes a ... ' ?
12:48:22 <Cale> HexSquid: A -> B is the type of functions which have a parameter of type A, and produce a result of type B.
12:48:49 <Cale> HexSquid: -> associates to the right, so when you see: A -> B -> C -> D, it means A -> (B -> (C -> D))
12:49:06 <geekosaur> HexSquid, it's a little more complex than that. multi-parameter functions are, internally, functions which take a single parameter and return a function which takes another parameter
12:49:07 <HexSquid> So when you read A -> B you might think 'type A, returns type B'... ?
12:49:20 <Cale> HexSquid: think "function from A to B"
12:50:12 <Cale> For example, chr :: Int -> Char is a function which takes an Int, and produces a Char
12:50:17 <Cale> > chr 73
12:50:18 <lambdabot>   'I'
12:50:20 <HexSquid> It seems like there is a lot of meaning in '->'
12:50:52 <ParahSailin> @kind (->)
12:50:53 <HexSquid> Yup -- I sort of get that I  can't just say it means 'currys' or 'returns'
12:50:53 <lambdabot> * -> * -> *
12:51:05 <Cale> HexSquid: and to go along with the right associativity of -> function application associates to the left, so when you see  f x y z  it means  ((f x) y) z
12:51:59 <Cale> But if you prefer, you can always think of A -> B -> C -> D as being a type of function which takes three parameters (of types A, B and C respectively), and produces a result of type D
12:52:19 <Cale> It's just that it's also a type of function which takes a parameter of type A, and produces a function of type B -> C -> D
12:52:42 <HexSquid> Oh nice
12:54:27 <sobhan> > try $ putStrLn 3 :: IO (Either SomeException  ())
12:54:28 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
12:54:28 <lambdabot>    arising from the literal `...
12:54:36 <sobhan> :/
12:54:57 <roboguy_> (try $ putStrLn 3) :: IO (Either SomeException ())
12:55:00 <roboguy_> > (try $ putStrLn 3) :: IO (Either SomeException ())
12:55:01 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
12:55:01 <lambdabot>    arising from the literal `...
12:55:15 <roboguy_> > (try $ putStrLn "3") :: IO (Either SomeException ())
12:55:16 <lambdabot>   <IO (Either SomeException ())>
12:55:21 <HexSquid> Nice thank you
12:55:57 <sobhan> roboguy_: that wont give an Exception :/
12:56:09 <sobhan> maybe..
12:56:20 <HexSquid> Also - when I read (A -> A) -> A -> A  ... the first part denotes a function ?
12:57:08 <HexSquid> Oh Cale that explanation 'But if you prefer ...' really good
12:57:49 <sobhan> > try $ print 3 :: IO (Either SomeException  ())
12:57:50 <lambdabot>   <IO (Either SomeException ())>
12:57:54 <twopoint718> Is there a function that's something like ($), but for 2-arity? I'd imagine you'd be able to write something like: f $$ inc $ dec
12:58:02 <sobhan> > let a =try $ print 3 :: IO (Either SomeException  ())
12:58:03 <lambdabot>   not an expression: `let a =try $ print 3 :: IO (Either SomeException  ())'
12:58:08 <sobhan> > let a =try $ print 3 :: IO (Either SomeException  ())
12:58:09 <lambdabot>   not an expression: `let a =try $ print 3 :: IO (Either SomeException  ())'
12:58:15 <sobhan> > let a =$try $ print 3 :: IO (Either SomeException  ())
12:58:16 <lambdabot>   <hint>:1:5:
12:58:16 <lambdabot>      Invalid type signature: a =$ try
12:58:16 <lambdabot>                          ...
12:58:20 <Cale> HexSquid: right, so that would be the type of a function which takes a function of type (A -> A), and a value of type A, and produces a result of type A
12:58:23 <sobhan> > let a = $try $ print 3 :: IO (Either SomeException  ())
12:58:24 <lambdabot>   <hint>:1:9: parse error on input `$'
12:58:33 <twopoint718> Rather than: f (inc 1) (dec 2)
12:58:34 <roboguy_> sobhan: try a "let ... in"
12:59:04 <sobhan> > let rights a in a = $try $ print 3 :: IO (Either SomeException  ())
12:59:05 <twopoint718> Sorry if that's puzzling.
12:59:05 <lambdabot>   <hint>:1:14: parse error on input `in'
12:59:16 * sobhan forgot how to use let
12:59:27 <roboguy_> > let a = try $ print 3 in a
12:59:28 <lambdabot>   No instance for (GHC.Exception.Exception e0)
12:59:28 <lambdabot>    arising from a use of `e_13...
12:59:31 <Cale> :t let threeTimes f x = f (f (f x))) in threeTimes
12:59:31 <lambdabot> parse error on input `)'
12:59:35 <Cale> :t let threeTimes f x = f (f (f x)) in threeTimes
12:59:35 <lambdabot> (t -> t) -> t -> t
12:59:45 <Cale> > let threeTimes f x = f (f (f x)) in threeTimes (*2) 1
12:59:46 <lambdabot>   8
13:00:17 <HexSquid> dang!
13:01:24 <sobhan> > let a try $ print 3 in rights a:: IO (Either SomeException  ())
13:01:25 <lambdabot>   <hint>:1:21: parse error on input `in'
13:01:49 <Cale> You're missing an = sign there
13:02:10 <Cale> But also, you can't execute IO actions with lambdabot
13:02:32 <ignacio> sounds pretty sane
13:03:11 <ignacio> we need a chrooted lambdabot' that can do IO
13:03:23 <sobhan> > let a try $ print 3 in rights a
13:03:24 <lambdabot>   <hint>:1:21: parse error on input `in'
13:03:36 <sobhan> > let a = try $ print 3 in rights a
13:03:37 <lambdabot>   Couldn't match expected type `[Data.Either.Either a1 b0]'
13:03:37 <lambdabot>              with...
13:03:47 <sobhan> oh thanks
13:05:28 <roboguy_> sobhan: note that rights works with lists though. also, you can't directly apply it to an IO action like that
13:06:46 <roboguy_> you might want something more like: do a <- try $ print 3; case a of (Right r) -> ...
13:06:53 <johnw> > let a = try $ print 3 in rights <$> a
13:06:54 <lambdabot>   Couldn't match type `Data.Either.Either e0 ()'
13:06:54 <lambdabot>                with `[Data.E...
13:07:07 <johnw> > let a = try $ print 3 in (rights <$> a :: IO [Either SomeException ()])
13:07:08 <lambdabot>   Couldn't match type `Data.Either.Either e0 ()'
13:07:08 <lambdabot>                with `[Data.E...
13:07:21 <johnw> n/m
13:09:29 <roboguy_> you could put it into a list by fmapping (:[]) on the IO action (or (\x -> [x]) if you prefer), but there's not really a reason to do that so do notation is probably best
13:09:46 * applicative hadn't done ghci> import Panic  before ...
13:11:15 * applicative thinks he will use sorry :: String -> a more often ...
13:11:43 <sobhan> i'm really not getting it
13:11:43 <sobhan> msg <- try (pluginRun s conn) :: IO (Either SomeException ())
13:11:44 <sobhan> pluginRun returns -> IO String
13:12:08 <roboguy_> sobhan: I'm not entirely sure what that means
13:12:24 <roboguy_> what do you want it to do?
13:12:37 <applicative> sobhan: where's pluginRun from ?
13:12:42 <sobhan> roboguy_: `` is me
13:12:43 <``> i have a function that do some Sql stuff
13:13:02 <``> applicative: it's a func that i wrote
13:13:03 <``> **i've
13:13:17 <``> roboguy_: some time it fails
13:13:33 <``> but i don't want the program to exit
13:13:52 <``> i want to just print some warning and stuff
13:14:07 <roboguy_> ``: you need to use bind to get the result of the IO action and then I'd pattern match on Right with case
13:14:49 <roboguy_> like (if I understand): do { msg <- try (pluginRun s conn) :: IO (Either SomeException ()); case msg of (Right x) -> ...; (Left er) -> ... }
13:14:52 <applicative> if pluginRun x y returns IO String, try (pluginRun  x y) returns IO (Either e String),
13:14:52 <``> roboguy_: but it's complaining about msg <- try (pluginRun s conn) :: IO (Either SomeException ())
13:15:16 <sobhan>  http://bpaste.net/show/116403/
13:15:18 <applicative> because its IO (Either SomeException String) ?
13:15:35 * hackagebot io-streams 1.1.0.2 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.0.2 (GregoryCollins)
13:15:53 <applicative> hey just like i said, I take it you dont want the String/[Char]?
13:16:00 <sobhan> ah thanks
13:16:29 <applicative> if not then you do something to get rid of it void $ ... for example, or whatever
13:16:46 <sobhan> applicative: no i need it
13:17:15 <lingxiao> hey all, does anyone know what is/if there is the best implementation of an incremental parser ?
13:18:19 <lingxiao> So far I can only find Attoparsec.Incremental, but it's depricated
13:18:26 <c_wraith> incremental in what way?  Input?  Output?
13:18:28 <c_wraith> both?
13:18:54 <lingxiao> output, but I'd be interested in both too
13:19:37 <c_wraith> Not sure what the state of the art there is.
13:20:14 <lingxiao> hmm... do you have a favorite/goto one in mind by any chance?
13:22:02 <``> roboguy_:  Prelude.(!!): negative index
13:22:07 <``> :/
13:22:15 <roboguy_> ``: ?
13:22:50 <``> if i run a fun that run a func that run a fun it's not enough to put the first fun in a try ?
13:24:23 <roboguy_> ``: you mean like: try (f (g (h ...)))?
13:24:42 <c_wraith> lingxiao: I tend towards uu-parsinglib, though it's not the fastest. It seems easiest for me to work with. And it can produce partial results, though the api is a bit awkward
13:27:21 <S_J> Can I FFI from ghci? Do I have to compile the C-file or does ghci do that for me?
13:30:53 <yesthisisuser> what does Control.Exception.bracket do?
13:31:28 <lingxiao> c_wraith: thank you I'll take a look!
13:31:54 <c_wraith> yesthisisuser: It guarantees the finalizer will be run, regardless of whether the main action threw an exception or not
13:32:24 <c_wraith> yesthisisuser: the main use for it is things like closing file handles, or other cleanup you want to happen regardless of whether the main computation succeeds or not
13:33:26 <yesthisisuser> c_wraith: thanks
13:34:23 <yesthisisuser> i guess it is a bit like the RAII pattern in C++
13:34:32 <S_J> so currently, to test C code with Quickcheck id have to write an FFI for each fucntion ...?
13:35:05 <c_wraith> yesthisisuser: in purpose, it's similar..  It's more explicit, though.
13:35:21 <Odd_Bloke> Hello all.  I've defined "data Tour = Tour [Point]" (where "data Point = Point Int Int deriving (Show, Eq)").  I would now like to treat Tour as a list of Points (by map'ing) it, but I can't do so.
13:35:36 <Odd_Bloke> Should Tour be deriving from something to make it list-like?
13:36:14 <taylorgb> well you could make it an alias for list, or implement functor for it
13:36:27 <yesthisisuser> if you want to map over it Functor is what you want
13:36:43 <taylorgb> Kinda depends what you want to use it for
13:39:12 <yesthisisuser> but it sounds almost like you could define Tour as type Tour = [Point], or?
13:39:44 <taylorgb> Depends whether any existing instances for list are inconvenient, or you want to define additional instances
13:42:18 <S_J> foreign import ccall "inc" c_inc :: CInt -> CInt // if that is all that is needed to use C code couldnt that be autogenerated? is it harder with more compelx types(structs)?
13:42:41 <haasn> Odd_Bloke: I would use lenses
13:43:28 <ipuustin> Hi, how to deal with cabal "ghc" dependency?
13:43:43 <joelteon> install ghc
13:43:49 <ipuustin> I'm running "cabal configure" in the ghc-mod source code root.
13:44:20 <Odd_Bloke> yesthisisuser: Yeah, I think I could be doing that.
13:44:26 <geekosaur> ipuustin, that generally means it needs the ghc-api, and it often requires a specific version (which means you must be using a specific compiler version; you cant simply install a library)
13:44:28 <ipuustin> I have Haskell Platform installed (running Fedora 19). All other dependencies can be installed with cabal, but "ghc" I don't understand. I obviously have it installed.
13:44:39 <ipuustin> geekosaur: oh, I see.
13:44:45 <Odd_Bloke> yesthisisuser: Where that is "type Tour = [Point]".
13:47:27 <ipuustin> geekosaur: at least the .cabal file doesn't specify any ghc version: https://github.com/kazu-yamamoto/ghc-mod/blob/master/ghc-mod.cabal
13:48:05 <Odd_Bloke> If I wanted to be able to explicitly construct Tours, how could I do that with the "type Tour = [Point]"?
13:48:21 <Odd_Bloke> Because I have some lists of Points which represent something other than a Tour.
13:48:29 <Odd_Bloke> So I'd like to be explicit when something is a Tour.
13:48:37 <geekosaur> odd. is this ghc from a vendor package? you may need to install the package corresponding to ghc in that case. (check "ghc-pkg list")
13:49:39 <bscarlet> Odd_Bloke: are you looking for "data Tour = Tour [Point]" and/or "newtype Tour = Tour [Point]"?
13:50:12 <S_J> can i get from CInt to Int?
13:50:23 <S_J> and how would i write an arbitrary for CInt?
13:50:24 <Odd_Bloke> bscarlet: I had that, but then I couldn't (for example) map over it.
13:50:35 <Odd_Bloke> bscarlet: I had the former. I will investigate the latter.
13:50:51 <ipuustin> geekosaur: thanks for advice. I'll play around with the fedora packages...
13:50:52 <bscarlet> Odd_Bloke: newtype will probably not take you where you want to go.
13:51:17 <Odd_Bloke> bscarlet: I shan't go there then. :)
13:51:51 <haasn> bscarlet: I don't see a reason to use data instead of newtype in that case. That said, a type synonym would suffice if he doesn't need any conflicting instances
13:52:05 <bscarlet> Odd_Bloke: do you dislike stuff like (\(Tour pts) -> Tour (map f pts))
13:53:03 <Gracenotes> (in that particular instance, newtype deriving of Functor might be helpful.)
13:53:15 <haasn> Gracenotes: that newtype isn't a valid functor
13:53:35 <Gracenotes> oh. I thought it was... :x I see
13:53:44 <haasn> if you have to use a newtype but still want to map, I'd personally write a traversal like points :: Traversal' Tour Point
13:53:49 <haasn> and use that instead
13:55:31 <bscarlet> haasn: some people start with data and switch to newtype as an optimization, others start with newtype and switch to data if they need multiple constructors or multiple members. either or.
13:56:15 <bscarlet> haasn: as to the type synonym, it's a perfectly good suggestion but I read his latest question as indicating he wasn't too happy with that approach.
13:57:17 <lingxiao> c_wraith: may I ask you another question about parsers?
13:57:37 <c_wraith> lingxiao: you can, but I don't know everything.  General address might get you more answers. :)
13:57:55 <haasn> Gracenotes: functors have to be polymorphic, so it'd have to be something like Tour a = Tour [a] -- and then use Tour Point, but that's just silly
13:58:13 <haasn> but lenses fit that use case so perfectly
13:58:21 <haasn> since they have all the power of functors (and more) yet aren't required to be polymorphic
13:58:33 <lingxiao> Ah awesome, :) I'll do a general shoutout
13:58:59 <Odd_Bloke> I think a type synonym gets me closest to what I want with the least effort. :)
13:59:04 <Gracenotes> yeah... lenses are definitely V8-engines-included, though
13:59:41 <Odd_Bloke> I'll finish Learn You A Haskell and then revisit it. ;)
14:00:04 <lingxiao> hey all: I'm making a little parser for self-education. And if I'm trying to explicitly describe the action of passing a buffer of inputs to a coroutine, which may yield a result, or request more chars in the buffer, am I trying to implement an incremental parser?
14:00:13 <lingxiao> or should I be looking for something else?
14:03:38 <lingxiao> ##
14:08:07 <lingxiao_> r
14:08:13 <roboguy_> is it possible to put a ByteString (or something like it) into an unboxed Vector? does that even make sense?
14:08:32 <c_wraith> roboguy_: it's not.  Things in an unboxed Vector must be constant-size
14:09:25 <c_wraith> roboguy_: and while the ByteString constructor is technically constant-size, putting *those* into an unboxed Vector doesn't buy you much at all
14:09:48 <shachaf> You can have an unboxed Vector of Word8s.
14:10:00 <shachaf> It wouldn't be the same as ByteString, though.
14:10:37 <roboguy_> basically I want a fast way to read in a space separated list of Ints and put them into an unboxed Vector.
14:11:02 <roboguy_> the way I'm doing it now is probably fast enough though, actually
14:15:19 <Peaker> If Vectors supported arbitrary GC pinning/etc, would that allow them to be like ByteStrings? can we get rid of ByteStrings (or make them a type-alias to a Vector?)
14:15:35 <danharaj> I think there's a package that does that
14:15:47 <Peaker> GC pinning support for vectors?
14:15:57 <danharaj> making ByteString an alias of Vector
14:16:02 <S_J> foreign import ccall "inc" c_inc :: CInt -> CInt // if that is all that is needed to use C code couldnt that be autogenerated? is it harder with more compelx types(structs)?
14:16:10 <S_J> and how would i write an arbitrary for CInt?
14:16:56 <c_wraith> Hasn't someone already made a wrapper providing the bytestring api to storable vectors of Word8?
14:17:15 <danharaj> http://hackage.haskell.org/package/vector-bytestring
14:17:17 <Ralith> S_J: you can't automatically determine whether a function is pure
14:17:21 <danharaj> idk if it is a high quality package
14:17:57 <c_wraith> Bas is a pretty reliable contributor, but it doesn't mean he's done all the optimization work ByteString has
14:18:10 <shachaf> And all the pessimizations!
14:18:11 <danharaj> right
14:18:17 <danharaj> A lot of guys worked on ByteString
14:18:21 <danharaj> (and gals)
14:18:26 <danharaj> (presumably)
14:18:56 <danharaj> shachaf: what pessimizations? :P
14:19:16 <shachaf> Like the thing we ran into in lens that caused a terrible space leak
14:19:27 <shachaf> A bug in a fold function or something. It was pretty broken. :-(
14:19:35 <shachaf> By bug I just mean performance Problem.
14:19:49 <danharaj> the worst kind of bug
14:19:53 <shachaf> dcoutts fixed it, though.
14:20:28 <shachaf> "Re-implement the foldr and foldl functions and fix unpack fusion They were just wrong. The old foldr and foldl were doing strict accumulation when they should be lazy."
14:20:40 <roboguy_> I hope I can get used to optimizing haskell code. it seems like it can often be pretty unintuitive
14:20:47 <shachaf> Here it is: http://ghc.haskell.org/trac/ghc/ticket/7556
14:23:31 <johnw> roboguy_: that really depends a lot on your intuitions :)
14:23:55 <roboguy_> johnw: yeah, that's true. I guess I just need to keep practicing
14:24:08 <johnw> never a truer word was said
14:25:52 <monochrom> um, you must haven't heard my tautologies of infinite wisdom, such as "the solution depends on the problem" :)
14:26:15 <monochrom> tautologies of infinite useless wisdom :)
14:27:35 <Pegleg> Are you guys kind to noobs? :-X I just started to learn haskell today
14:28:10 <banister_> Pegleg: what languages do you come from? :)
14:28:11 <monochrom> I think we are. but as all tautologies go, it depends on the actual noob.
14:29:00 <shachaf> As Tom Lehrer said: #haskell is like a sewer. What you get out of it depends on what you put into it.
14:29:01 <lpaste> Pegleg pasted “Bellards Base 2” at http://lpaste.net/2643943809712390144
14:29:48 <Pegleg> Alright so how do I properly do a summation of a function
14:30:02 <Pegleg> I have the code there and my attempt but it goes to infinity and I didn't know how to filter it correctly
14:30:03 <monochrom> you need to indent, beginning from line 4.
14:30:19 <monochrom> err, line 3
14:30:22 <Pegleg> Why is that?
14:30:31 <monochrom> syntax requirement
14:31:22 <Pegleg> Alright
14:32:35 <Pegleg> Should I be thinking about approaching the problem in a different way? I was thinking for the summation you store each result in a list and then sum them all together to get the proper result
14:32:53 <cseder> I started with Haskell today as well... Pretty intense stuff...
14:34:03 <monochrom> mathworld.wolfram.com is taking forever to respond. I cannot see the formula yet.
14:34:05 <Pegleg> Yeah it is pretty cool so far though I just need to work at it more
14:34:19 <Pegleg> Ah 1 sec I will try to find it somewhere else
14:34:45 <Pegleg> http://upload.wikimedia.org/math/c/4/3/c43db33aa2adcff44b4e7966a8750be0.png
14:35:37 * hackagebot GraphSCC 1.0.4 - Tarjan's algorithm for computing the strongly connected components of a graph.  http://hackage.haskell.org/package/GraphSCC-1.0.4 (IavorDiatchki)
14:36:31 <monochrom> you have an infinite series. you cannot ask to sum all infinitely many terms. you have to decide, you only care about 100 terms, or 1000 terms, or whatever. then it's a simple finite sum and you know how to do it.
14:37:02 <Pegleg> I don't actually how do I close it off to finish at the first 100
14:37:19 <banister_> Pegleg: what language/languages are oyu proficient at already?
14:37:32 <Pegleg> Java/Python
14:37:40 <FreeFull> Depending on the type of series, you could find the sum that you'd get if you did sum all of the terms
14:38:16 <monochrom> ok, sum this list: [ the_pi n | n<-[0..99] ]
14:39:36 <monochrom> FreeFull: the sum should give pi, so you could say, just answer pi... :)
14:41:20 <monochrom> the syntax "[ the_pi n | n<-[0..99] ]" is called "list comprehension", if you want to search for it
14:41:20 <FreeFull> I wonder if there is a function whose fixpoint is pi
14:41:30 <Pegleg> It still goes to infinity with that list comprehension
14:41:32 <FreeFull> Other than const pi of course =P
14:41:34 <monochrom> const pi has fixpoint pi
14:41:42 <monochrom> darn
14:41:54 <monochrom> no, [0..99] leads to exactly 100 terms.
14:42:04 <FreeFull> One that you can calculate without knowing the value of pi beforehand
14:42:17 * monochrom hugs fix (const pi) :)
14:42:18 <danharaj> since pi is computable the answer is yes
14:42:28 <ClaudiusMaximus> if you can use numerical analysis to show that terms go to 0 at at least a certain rate, you can get an upper bound on how many terms you need to add before the sum of the tail is insignificant relative to your desired output precision
14:42:57 <FreeFull> danharaj: So, for all computable numbers, there is a function for which the computable number is its fixed point?
14:43:21 <danharaj> yes
14:43:28 <S_J> how can i go from CInt to Int?
14:43:32 <monochrom> > (-1)^(fromIntegral 99 :: Double)
14:43:33 <lambdabot>   Could not deduce (GHC.Real.Integral GHC.Types.Double)
14:43:33 <lambdabot>    arising from a use...
14:43:53 <danharaj> (-1)**(fromIntegral 99 :: Double)
14:43:55 <ParahSailin> :t fromIntegral
14:43:56 <lambdabot> (Integral a, Num b) => a -> b
14:43:57 <geekosaur> S_J: fromIntegral or fromEnum
14:43:58 <danharaj> blah
14:44:04 <monochrom> I think you want simply "(-1)^n"
14:44:35 <monochrom> of course, even better is "(if even n then 1 else -1)"
14:46:00 <ClaudiusMaximus> Pegleg: oh, i think it explodes because of incorrect precedence: ^ binds more tightly than *
14:46:47 <monochrom> good catch
14:47:07 <monochrom> 2^(10*n) should be good
14:47:08 <Pegleg> Oh
14:47:10 <Pegleg> fml
14:48:16 <Pegleg> OMG
14:48:18 <Pegleg> thank you
14:48:39 <Pegleg> I was stuck on this for so long I couldn't figure out why it kept going to infinity
14:50:49 <Peaker> Pegleg, you can sprinkly some Debug.Trace calls
14:51:26 <S_J> so it is a bit quirky to go from C code to something that is callable by quickcheck. easier to use quviq i guesss, jsut the enormous license fee in the way :(
14:51:28 <monochrom> yikes, it's pi approximation day 22/7
14:53:15 <Pegleg> Peaker: Thanks I will look up how to use it right now
14:55:44 <roboguy_> wow what is happening. how is it possible for {-# SCC ... #-} to make something faster?
14:56:16 <Pegleg> monochrom: Lol wow I didn't even know that existed
14:56:21 <mauke> reverse tachyon flow
14:57:06 <josephle> mauke: wait, if you reverse the direction of a tachyon flow...don't you go *forwards* in time?
14:57:29 <mauke> yes, I'm a time traveller
14:57:36 <kryft> josephle: Well that depends on your field polarity of course
14:57:42 <kryft> I like to reverse mine
14:57:44 <tulcod> is there any library which enums the keys in linux/input.h?
14:58:45 <josephle> kryft: those pesky reference frames!
14:59:46 <roboguy_> it only makes it faster when I have profiling enabled of course, but I still don't understand...
15:00:29 <Peaker> roboguy_, performance works in mysterious ways
15:01:10 <yo`yo> try will catch all exceptions ?
15:01:37 <Peaker> yo`yo, I think so
15:01:42 <yo`yo> Peaker: :/
15:01:57 <Peaker> yo`yo, note that things like heap exhaustion are not exceptions, and just kill you
15:02:42 <roboguy_> yo`yo: I guess you could rethrow every exception except the one you want to catch (assuming I understand how exceptions work in haskell)
15:03:21 <yo`yo> even irc: Prelude.(!!): negative index
15:03:25 <johnw> try does not catch all exceptions
15:03:45 <johnw> it depends on how the type of the Either that it returns is inferred
15:03:55 <johnw> if it's inferred to be Either SomeException a, then yes, it catches all exceptions
15:04:04 <johnw> but you can contrain the type to something more specific to catch only that family
15:04:08 <``> johnw: but it doesn't
15:04:08 <johnw> of exceptions
15:04:28 <johnw> it doesn't what?
15:04:30 <``> johnw: try will catch all exceptions that happens in it ?
15:04:34 <``> irc: Prelude.(!!): negative index
15:04:46 <johnw> try catches the exceptions it's type is specialized to catch
15:05:08 <``> johnw: it's not an exception it can catch?
15:05:14 <johnw> try docs: "Similar to catch, but returns an Either result which is (Right a) if no exception of type e was raised, or (Left ex) if an exception of type e was raised and its value is ex. If any other type of exception is raised than it will be propogated up to the next enclosing exception handler."
15:05:42 <johnw> there is also tryJust, if you need finer grained control
15:05:53 <``> johnw: my code http://www.pasteall.org/44281
15:06:02 <tulcod> can i have cabal first generate some code, and then compile it?
15:06:06 <johnw> exactly, you're using SomeException
15:06:14 <johnw> so it catches all exceptions
15:06:34 <``> but it doesn't catch irc: Prelude.(!!): negative index
15:06:51 <johnw> one sec
15:08:03 <johnw> your probably is lazy evaluation
15:08:09 <johnw> > print =<< (try (return $! [1,2] !! 3) :: IO (Either SomeException Int))
15:08:10 <lambdabot>   <IO ()>
15:08:14 <johnw> that results in a Left
15:08:21 <johnw> change the $! to $, and it results in a Right, which then throws an exception
15:08:27 <johnw> s/probably/problem
15:13:54 <tulcod> can i use template haskell to generate haskell code based on a C header file?
15:14:25 <tulcod> specifically, i have a bunch of #defines which i need to #{enum}, and i don't feel like hardcoding it or anythig
15:14:38 <johnw> tulcod: c2hsc will generate them for you
15:14:54 <monochrom> yes, runIO let's you read a C header file (or any file), but I would consider hsc2hs or c2hs or... first
15:15:02 <johnw> you could also have template haskell run c2hsc even
15:15:35 <monochrom> darn, s/let's/lets/
15:16:36 <tulcod> johnw: not sure i can just use a tool for this - i really need to do some regex-ish parsing
15:17:23 <tulcod> johnw: "It cannot translate macros, or anything related to the preprocessor, for example."
15:17:32 <tulcod> #define would be preprocessor, no?
15:18:11 <tulcod> monochrom: so vaguely speaking, i can just write a parser in haskell, and that gets run at compile time?
15:18:42 <monochrom> yes, but I wouldn't want to write a parser
15:19:10 <tulcod> well i don't want to either, but i really have a *long* list of #defines which i need to put into one big haskell type
15:19:11 <monochrom> I would rather use TH's runIO to play a movie :)
15:19:38 <tulcod> (incl. constructors)
15:22:15 <johnw> tulcod: oh, right, sorry about that
15:31:10 <ReinH> Can anyone suggest a more elegant way to use lenses here? https://gist.github.com/reinh/3fe9f48eba639276b940
15:32:14 <carter> johnw ooo, c2hsc looks landy
15:33:29 <johnw> carter: for what it does, it is :)
15:33:49 <carter> *handy
15:34:19 <carter> that said, i've enough structure in my c code that i can just do the CPP style that Vector does for generating lots of instances
15:38:38 <``> err how do i use =<< ?
15:39:46 <Tene> same as >>= but with the arguments flipped
15:40:38 <``> Tene: and what >>= means ?
15:40:58 <Tene> same as =<< but with the arguments flipped ;)
15:41:05 <joehillen> rofl
15:41:18 <joehillen> recursion is really easy in haskell
15:41:30 <Tene> > :t (>>=)
15:41:31 <lambdabot>   <hint>:1:1: parse error on input `:'
15:41:36 <Tene> :t (>>=)
15:41:37 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:41:49 <``> :D
15:42:09 <Tene> It's used to do things with values in a monad
15:43:15 <johnw> ` `: the free online book Learn You A Haskell talks about >>= in the chapters on Monads
15:43:55 * `` should finish learn you haskell
15:45:06 <Tene> ``: >>= is what's used to join together lines in a 'do' block, if you've used those.
15:45:35 <shachaf> What happened to nicks that have at least one letter in them?
15:45:40 <shachaf> I think we used to have those.
15:45:59 <johnw> I preferred sobhan myself
15:46:03 <Tene> ``: you'll also want to compare it against fmap
15:46:04 <Tene> :t fmap
15:46:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:46:52 <shachaf> I, too, prefer sobhan.
15:47:07 <Tene> The difference is that >>= is used with functions that produce a monadic value on their own, and fmap is used just to apply a general function inside a monadic context.
15:50:44 * hackagebot CheatSheet 2.9 - A Haskell cheat sheet in PDF and literate formats.  http://hackage.haskell.org/package/CheatSheet-2.9 (JustinBailey)
16:02:19 <shachaf> dreixel: Wait, the data-proxy branch also adds type equality?
16:02:36 <shachaf> Separate from the other type equality in GHC.TypeLits?
16:08:05 <shachaf> dreixel: And this is defininv Void too?
16:08:22 <shachaf> Not that I object to Void in base, but this seems like an odd way to get all these things in.
16:10:39 <ReinH> is there a simpler way to write this sort of monadic pattern? https://gist.github.com/reinh/e2423661f2211f6dda96
16:10:44 <ignacio> what's better, LYAH monads or RWH monads?
16:11:17 <ReinH> basically: recursively attempt to get input until we get an input we recognize
16:13:40 <ReinH> Tene: inside a *functorial* context /pedant
16:16:57 <shachaf> You should find better things to be pedantic about. There are so many.
16:17:41 <Tene> ReinH: Yes, thank you. :)
16:18:21 <c_wraith> ReinH: I don't think there's anything particularly better unless something monad-loops can apply
16:20:26 <augur> hughes's Monads and All That lectures are the first time ive understood monad transformers
16:20:28 <merijn> ignacio: LYAH is probably more accessible, there' also "You Could Have Invented Monads (And Maybe You Already Have!)"
16:20:39 <c_wraith> Hmm.  lambdabot no longer has implicit params
16:20:44 * hackagebot highlighting-kate 0.5.5 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.5 (JohnMacFarlane)
16:22:35 <Fuuzetsu> > let 可愛い = mappend; う = mempty; ぐう = [1,2,3]; in 可愛い う ぐう
16:22:36 <lambdabot>   [1,2,3]
16:25:58 <ReinH> c_wraith: ok thanks
16:26:28 <ReinH> nothing made monads click for me until I started actually using them
16:26:50 <ReinH> all the tutorials are basically with "assuming you understand monads, here is how you understand monads"
16:26:54 <ReinH> s/with//
16:28:44 <c_wraith> ReinH: people who actually want you to understand monads tell you to write code, not read tutorials. :)
16:32:37 <ReinH> c_wraith: indeed
16:34:59 <ReinH> c_wraith: btw monad-loops has untilJust
16:35:59 <ogew> Is quickcheck able to test if functor/applicatives meet their respective laws?
16:36:45 <c_wraith> ReinH: monad-loops has a ton of stuff. Doesn't surprise me. :)
16:37:57 <geekosaur> ogew: quickcheck can't prove anything, really. it throws values at a function and looks for outliers; not finding one doesn't necessarily mean none exist, just that it didn't find one.
16:38:08 <c_wraith> It can prove there are bugs
16:38:15 <c_wraith> Just not the other way around.
16:39:02 <ReinH> c_wraith: it seems nice
16:39:10 <mgsloan> ogew: I haven't used it in a while, but http://hackage.haskell.org/package/quickcheck-poly seems like a good way to use quickcheck on multiple instances at once
16:39:49 <ogew> Ok thanks. Another newbie questions, is there a ghci way of checking if a function is strict. Like :t (+) doesn't tell me
16:39:59 <ReinH> c_wraith: this is quite nice: getInput = untilJust $ charToInput `liftM` getChar
16:40:15 <geekosaur> the type system can't (or at least doesn't) indicate strictness, sadly
16:40:33 <ogew> So the only way is to check for document/code?
16:40:41 <ogew> check *in*
16:40:44 <c_wraith> ogew: (+) has the added issue that it's a class function.  Some implementations are strict, some aren't.
16:40:46 <enthropy> ogew: you try    (undefined + 1) and  (1 + undefined)
16:41:18 <ogew> thanks c_wraith, enthropy! cool tips
16:41:30 <enthropy> if one of them gives you something sensible, you can say it's not strict
16:41:31 <geekosaur> enthropy, but how you try them matters too. even a lazy (+) would fail that if you actually use the result, thus forcing it to be evaluated
16:41:59 <c_wraith> yeah, you really need (undefined + 1) `seq` () and (1 + undefined) `seq` ()
16:42:20 <c_wraith> Those will tell you if you can do *something* with them with an undefined argument
16:42:26 <shachaf> The nuances of strictness are a bit tricky.
16:42:29 <c_wraith> Though...  Not necessarily if it's something useful.
16:42:34 <shachaf> For example, seq is a non-strict function.
16:42:41 <c_wraith> Like, i think CReal will give you () for both of those
16:42:51 <c_wraith> But you can't calculate anything with the results, anyway
16:43:14 <enthropy> in some cases you can see how much of your result is defined
16:43:21 <enthropy> > "abcde" ++ undefined
16:43:22 <lambdabot>   "abcde*Exception: Prelude.undefined
16:43:25 <c_wraith> > (undefined + 1 :: CReal) `seq` ()
16:43:26 <lambdabot>   *Exception: Prelude.undefined
16:43:41 <c_wraith> Oh, I was wrong.  CReal actually does look at the values it's given a bit.
16:44:45 <haasn> c_wraith: it just pattern matches on the constructor
16:44:50 <haasn> oddly enough it's using a data type and not a newtype
16:45:24 <enthropy>   instance (Num a, Num b) => Num (a,b) -- this one, if we had it, might be lazy
16:45:33 <benmachine> shachaf: surely only in the moderately-silly sense that seq undefined is const undefined and not undefined?
16:45:37 <c_wraith> I wonder if it's using data specifically to make pattern matches on undefined blow up.
16:45:49 <c_wraith> That seems like the only reason it would have to do so.
16:45:57 <haasn> c_wraith: might as well use strict pattern matching on a newtype for that purpose
16:46:07 <haasn> not like forcing a lambda is going to do anything unless it's undefined
16:46:23 <shachaf> benmachine: Yes.
16:46:39 <c_wraith> using data makes you work to skip the check though, instead of work to perform the test.
16:46:42 <shachaf> benmachine: Normally I might be willing to forgive that difference, but given the function in question...
16:46:46 <benmachine> shachaf: :P
16:49:01 <cmccann> shachaf: it seems you judge functions very strictly.
16:49:21 <monochrom> haha
16:49:45 <Fuuzetsu> How can I always pass --haddock-html to cabal install?
16:49:59 <haasn> > seq undefined `seq` ()
16:50:00 <lambdabot>   ()
16:50:14 <shachaf> hi cmccann
16:50:17 <Fuuzetsu> It's an unrecognised field in cabal config
16:50:20 <cmccann> hi shachaf
16:51:41 <monochrom> Fuuzetsu: isn't it just "--enable-documentation" (command line) or "documentation: True" (.cabal/config)?
16:52:15 <Fuuzetsu> Ah, there's a documentation flag, brilliant
16:52:17 <Fuuzetsu> thanks
16:57:25 <ogew> is there any binary function that isn't strict beside && and || >
16:57:37 <c_wraith> sure
16:57:43 <c_wraith> Many of them.
16:57:44 <haasn> `seq`
16:57:47 <ogew> simple examples...
16:57:53 <c_wraith> > [1, 2, 3] ++ undefined
16:57:53 <lambdabot>   [1,2,3*Exception: Prelude.undefined
16:58:05 <c_wraith> as you can see, there was a partial result!
16:58:17 <ogew> got it
16:58:30 <shachaf> By "partial" c_wraith means "not ⊥".
16:58:35 <monochrom> > take 2 ([1,2,3] ++ undefined)
16:58:36 <lambdabot>   [1,2]
16:58:40 <c_wraith> yes, that is precisely what I meant
16:58:49 <monochrom> this shows that ++ is very non-strict
16:58:59 <c_wraith> > 10 `const` undefined
16:58:59 <lambdabot>   10
16:59:28 <monochrom> and also "take 2" is pretty non-strict
16:59:28 <haasn> hmm
16:59:34 <haasn> > 0 * (1/0) :: CReal
16:59:38 <lambdabot>   mueval-core: Time limit exceeded
17:00:18 <roboguy__> haskell is generally non-strict by default
17:00:21 <c_wraith> haasn: CReal can't optimize multiplication by 0
17:00:29 <haasn> makes sense
17:00:43 <c_wraith> haasn: so all it can do is expand the decimal result until it finds a non-zero digit to print
17:00:50 <c_wraith> and it didn't find one in a timely manner
17:01:16 <enthropy> there could be a special case for 0, no?
17:01:25 <c_wraith> enthropy: no, there can't.
17:01:28 <ogew> ok, was a dumb question but really wasn't obvious to me until it was answered with clear examples. thanks all
17:01:44 <c_wraith> enthropy: you can't test to see if a number is 0 with CReal
17:01:53 <thoughtpolice> it's really amazing how much some of the -dsuppress-* flags help make Core readable
17:02:05 <enthropy> c_wraith: I mean  fromRational 0 could be a separate constructor of CReal
17:02:31 <monochrom> that can be done but has marginal utility
17:02:32 <haasn> doesn't seem like a useful enough case to warrant that kind of special treatment, imo
17:02:37 <c_wraith> enthropy: well, that's true, but it would really complicate things for not much gain.
17:02:49 <c_wraith> huh.  I was the third person to say that.  I'm slow today.
17:03:01 <haasn> though I could see use in trying to separate integers from non-integers in general
17:03:30 <c_wraith> why stop there? You could put all known-rationals into one constructor
17:03:36 <monochrom> if I have mathematically e0-e1 = 0 but it is computationally hard to know, (e0-e1)*5 will still hose you.
17:03:57 <c_wraith> And only functions that go outside of rationals get the function representation
17:04:10 <haasn> I guess in practice it breaks down because in those situations where you do actually work with rationals, you'd be using rationals
17:04:12 <volitek> Asking in here because no one replies in #yesod and I'm desperate: I'm trying to do a yesod example from the book, but the code is still 1.1 rather than 1.2. I've fixed two of the errors, but one still remains. This is what I've got: http://pastebin.com/NjJmqYyG and this is the error: http://pastebin.com/iS4Km2K1 What on earth should I do?
17:04:17 <mauke> The pastes NjJmqYyG iS4Km2K1 have been copied to http://lpaste.net/91133 http://lpaste.net/91134
17:04:21 <c_wraith> Or if you really wanted, you could make all algebraic numbers be a special constructor
17:04:27 <haasn> and it's easy enough to use rationals and then fromRational where necessary
17:04:37 <haasn> instead of having the library special treat it for you, make a library to special treat it on top of CReal
17:04:42 <Gracenotes> how about algebraic numbers
17:04:59 <monochrom> instead, consider http://hackage.haskell.org/package/cyclotomic
17:05:04 <Gracenotes> well, granted, those are ridiculously slow
17:05:10 <c_wraith> algebraic numbers can be calculated with exactly, I believe.
17:05:26 <c_wraith> but yeah, the cyclomatic package abstracts this out
17:07:38 <c_wraith> ... cyclomatic? wtf is that?  cyclotomic.
17:08:30 <augur> anyone happen to know where john hughes is from in England?
17:08:34 <shachaf> It's a kind of washing machine.
17:08:48 <c_wraith> shachaf: I was starting to suspect that.
17:08:52 <sipa> there's also cyclotronic
17:10:11 <c_wraith> wasn't that a band in the 90s?
17:13:24 <shachaf> a commutative band
17:15:28 <Rarrikins> Does IO contain anything for storing state?
17:15:51 <c_wraith> many things.
17:15:55 <Clint> the entire universe
17:15:57 <c_wraith> What do you actually need to do?
17:15:58 <cdk> Rarrikins: what problem are you trying to solve, storing state in IO might not be the best answer?
17:16:10 <cdk> s/?//
17:16:18 <Rarrikins> I want to store an incrementing Word32 that can be updated from an HTTP call as well.
17:16:37 <cdk> have you used the StateT monad before?
17:16:42 <Rarrikins> No, but I can.
17:16:47 <c_wraith> Does the server need to handle concurrent calls?
17:17:03 <Rarrikins> Not really.
17:17:24 <cdk> you might want "StateT Int IO something"
17:17:40 <Clint> StateT Word32 IO
17:17:42 <cdk> err, StateT Word32 IO something
17:17:43 <Rarrikins> Ahh, OK.
17:17:43 <cdk> yes
17:17:47 <c_wraith> Then anything works.  You only really need mutability to handle concurrent updates (such that one thread can see updates made by another)
17:18:06 <Rarrikins> What would I use if I needed that?
17:18:12 <Rarrikins> (concurrency)
17:18:28 <c_wraith> for your use case, probably an IORef with atomicModifyIORef
17:18:43 <cdk> or even better, if you're only incrementing the Word32 you might be able to get away with WriterT (Sum Word32) IO
17:18:49 <haasn> hey, is there something like (forall a. f a -> g a) -> someTransformer f a -> someTransformer g a
17:18:56 * BMeph_ was going to suggest an IORef
17:19:03 <Rarrikins> Ahh, OK. I'll check all those out. Thanks :)
17:19:28 <c_wraith> haasn: I've written that for specific transformers. I don't know if you can write it generically, and I don't think there's a class for it.
17:19:44 <c_wraith> actually, I'm sure you can't write it generically
17:20:04 <haasn> yeah but there might still be some typeclass for ‘someTransformer’
17:20:13 <BMeph_> c_wraith: Maybe, FSVO "generically," you can? :)
17:20:43 <cdk> haasn: Control.MFunctor.hoist
17:20:48 <cdk> from pipes
17:20:52 <BMeph_> There are three axes of exploration to go on for that.
17:21:29 <haasn> cdk: seems like that's in Control.Monad.Morph from package mmorph
17:21:44 <cdk> oh, it might have been moved around a bit
17:21:52 <cdk> mmorph sounds right
17:21:59 <haasn> but yes that seems exactly what I was thinking of
17:22:26 <haasn> it has instances for the common ‘transformers’ types
17:22:29 * BMeph_ thinks "mmorph" sounds like the sound someone would make after being force-fed too many Transformers... ;)
17:28:05 * geekosaur is trying to mistranslate it as massively multiplayer online role-playing ???
17:28:26 <haasn> ‘h’ is obviously a type of ‘g’
17:28:45 <haasn> typo, even
17:29:28 <c_wraith> role-playing hame
17:31:25 <shachaf> So the second functor law is just "(<$>) distributes over (.)".
17:32:08 <shachaf> And of course (.) = (<$>), as Cale likes pointing out. So can you say "(<$>) is self-distributive" or something? Is there a typed generalization of "self-distributive" like that?
17:32:58 <shachaf> And the first law is something like "id annihilates (<$>)"?
17:33:38 <haasn> <$> distributes over (.)?  wouldn't that mean (f . g) <$> x = (f <$> x) . (g <$> x) ?
17:34:32 <haasn> though I guess that's not far off from ((f . g) <$>) = (f <$>) . (g <$>)
17:34:43 <shachaf> Well, I just meant fmap (f . g) = fmap f . fmap g. It's not quite the same but perhaps it's related.
17:35:09 <shachaf> (f . g) <$> x = (f <$> x) . (g <$> x)
17:35:22 <haasn> also that isn't what annihilation is; annihilation is like 0 * x = 0; but id <$> x = x
17:35:24 <haasn> it's an identity
17:35:27 <haasn> unless I'm misunderstanding
17:35:57 <shachaf> You're right, I had it backwards.
17:36:02 <shachaf> That's much nicer.
17:36:47 <shachaf> Anyway none of these things are generally defined in a typed context like that.
17:38:23 <haasn> https://en.wikipedia.org/wiki/Distributivity#Generalizations_of_distributivity perhaps
17:39:04 <roboguy__> wouldn't it be a special case rather than a generalization?
17:40:34 <haasn> I don't think so, you're taking a notion that's generally applied to binary operations (of the type :: a -> a -> a) and finding similar things in a wider context
17:40:48 <shachaf> Right.
17:40:58 <Rarrikins> Is there such a thing as an unboxed IORef for simple types like Word32?
17:41:27 <shachaf> No.
17:41:33 <Rarrikins> OK, thanks.
17:41:34 <haasn> (the notion here being that you can swap two constructs if you duplicate the outer one)
17:43:19 <c_wraith> Rarrikins: part of the implementation of things like atomicModifyIORef actually depends on the fact that it's a boxed representation.
17:43:30 <Rarrikins> Ahh, I see
17:43:47 <shachaf> I wonder whether https://en.wikipedia.org/wiki/Distributive_law_between_monads relates to monad transformers.
17:45:42 <cdk> shachaf: the definition for unit at the end certainly looks a lot like monad transformers
17:46:07 <haasn> could be. when you think about it, all transformers are are regular stacks m (n a) with built-in plumbing
17:46:11 <haasn> to form a new monad
17:46:16 <hpc> the way they transpose S and T smells a lot like transformers' (>>=)
17:46:54 <hpc> but i don't think you can construct l
17:48:54 <hpc> at least, not directly
17:49:12 <hpc> in haskell terms, l would be the logic specific to each transformer instance
17:49:41 <hpc> that tells it how to unwrap T, perform S, then re-wrap
17:50:14 <haasn> transformers would work for any base monad so the implication would be that l :: forall m a. Monad m => m (T a) -> T (m a)
17:50:29 <haasn> transformers work*
17:51:10 <haasn> wait a minute
17:51:12 <hpc> perhaps if you limited T/S to being transformers
17:51:36 <haasn> State s (m a) -- is quite distinct from StateT s (m a)
17:51:51 <hpc> @unmtl State s (m a)
17:51:51 <lambdabot> s -> ((m a), s)
17:51:57 <hpc> @unmtl StateT s (m a)
17:51:57 <lambdabot> Plugin `unmtl' failed with: `StateT s (m a)' is not applied to enough arguments, giving `/\A. s -> (m a) (A, s)'
17:52:03 <haasn> s -> m (a, s)
17:52:06 <hpc> @unmtl StateT s m a
17:52:06 <lambdabot> s -> m (a, s)
17:52:36 <hpc> :t lift
17:52:37 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
17:53:14 <hpc> hmm, that's tricky
17:53:36 <hpc> it seems like you can't really "compose" transformers out of their bases
17:53:44 <hpc> (at least for State/StateT)
17:54:27 <hpc> this probably needs more than my feeble grasp of CT
17:54:39 <nerrz> hello, does anyone know how to set up tab completion behavior for a command line utility?
17:54:51 <Clint> depends on your shell
17:54:54 <hpc> nerrz: it's different for each shell
17:55:12 <nerrz> I am using gnome-terminal
17:55:13 <hpc> for bash, there's a good document somewhere
17:55:14 * hpc finds
17:55:34 <Demos> gnome-terminal is not a shell
17:56:02 <nerrz> sorry, I am new TT
17:56:04 <roboguy__> nerrz: what does echo $SHELL say
17:56:15 <hpc> http://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html#Programmable-Completion-Builtins
17:56:42 <hpc> nerrz: this is probably not a relevant topic for #haskell, btw
17:57:03 <nerrz> oh, I didn't know if I needed to add something to my haskell program
17:57:38 <haasn> if you want advanced completion functionality that only your program would know enough information to provide, you'd need to find some sort of integration with your particular shell
17:57:49 <haasn> but as far as I'm aware there's no consistent way to do that
17:58:19 <nerrz> hmm, okay, thank you
17:58:55 <hpc> if you need a basic example of emiting bash completion code from haskell, you can check out ghc-man-completion
17:59:37 <hpc> someone should make a library that unifies man, completion, and reading command-line arguments
17:59:50 <hpc> similar to how some libraries unify parsing and pretty-printing
18:00:41 <lpaste> MedDev pasted “From Do to Pure. 99 Problems and types are some” at http://lpaste.net/91135
18:01:17 <Clint> hpc: good idea
18:04:49 <MedDev> Do the errors I'm getting mean I need to define types in the where clause of my function(s)?  The module itself loads fine it's only when I call it that I get the type errors. (http://lpaste.net/91135)
18:07:21 <ReinH> Is there an easy way to combine/compose these two operations on the same lens? https://gist.github.com/reinh/58df50d8dfabdba02a15
18:07:54 <edwardk> just compose the functions and apply them with %~
18:09:11 <ReinH> edwardk:  so just world & pLocation %~ ((+coord) . clamp) ?
18:09:27 <edwardk> other way around, but yes
18:09:28 <ReinH> but with less parens
18:09:49 <ReinH> right
18:10:22 <edwardk> technically that is a +offset not a coord ;)
18:10:45 <ReinH> true
18:13:47 <ReinH> edwardk: while I've got you, is there a more elegant way to do this using super lens powers? https://gist.github.com/reinh/3fe9f48eba639276b940
18:14:48 <bgamari> ReinH, This doesn't really answer the question but I would probably use a more specific type that (,)
18:15:22 <bgamari> ReinH, As then you'd have an appropriate Applicative instance to work with
18:15:40 <ReinH> bgamari: yeah I'll probably switch to data Coord = Coord x y eventually
18:16:09 <bgamari> although I think both does what you need
18:16:17 <bgamari> http://haddocks.fpcomplete.com/fp/7.4.2/20130704-120/lens/Control-Lens-Traversal.html#v:both
18:16:24 <ReinH> I can also make that an instance of Ord to give min and max the correct behavior
18:16:54 <bgamari> ReinH, the linear package provides some nice low-dimensional vector types
18:17:07 <bgamari> http://hackage.haskell.org/packages/archive/linear/1.1.4/doc/html/Linear-V2.html
18:17:17 <ReinH> oh look 2D vectors
18:17:19 <ReinH> awesome
18:17:23 <haasn> both %~ clamp  -- reminds me of that pong game :)
18:17:46 <haasn> oh, not quite the same
18:18:41 <haasn> would be to be some sort of zip-like thing rather than a map over both parameters, since you're clamping the x coordinate of the value by the x coordinate of the parameters and so on
18:18:50 <ReinH> right
18:18:51 <bgamari> ReinH, For one, (,)'s laziness isn't so great for vectors
18:19:00 <ReinH> bgamari: true
18:19:02 <haasn> I don't think that can be done with lenses well at all
18:19:12 <bgamari> yeah, that's true
18:19:16 <ReinH> bgamari: I absolutely plan on using more performant types after I get it working
18:19:21 <bgamari> I think you really just want an applicative
18:19:22 <haasn> in your case I would look into generalizing ‘max’ and ‘min’ to n-tuples
18:19:30 <haasn> well, not generalizing, but rewriting for your use case
18:19:46 <ReinH> haasn: right, I could define max' and min' for coords
18:19:49 <haasn> and then using clampCoord = start end val = start `max2` val `min2` end
18:19:55 <ReinH> is there an extension I can use to make Coord an instance of Ord?
18:20:09 <ReinH> that would give me max and min "for free"
18:20:30 <haasn> the type of ‘compare’ sort of excludes that
18:20:35 <ReinH> (another good reason to make Coord its own data type)
18:20:48 <haasn> Coord -> Coord -> Ordering -- would need (Ordering, Ordering) for this to make sense or something similar
18:21:30 <haasn> and min/max simply don't work that way, there's no way you can provide an instance to have the predefined min/max do their picking on a per-coordinate basis
18:21:59 <haasn> oh, of course, min/max are class functions
18:22:03 <haasn> what are the laws on Ord anyway?
18:23:09 <FreeFull> I just realised
18:23:17 <FreeFull> You can implement seq in terms of strict tuples
18:23:33 <haasn> you can implement seq in terms of strict datatypes in general
18:24:28 <jmcarthur> not all of seq
18:24:53 <jmcarthur> oh, i see, this isn't what i thought
18:25:27 <jmcarthur> i misread the claim as "you can implement seq in terms of datatypes and pattern matching" when in fact the claim was about strict fields, which according to the spec is the same as using seq
18:25:28 <haasn> jmcarthur: data Seq a = Seq !a; a `mySeq` b = case Seq a of Seq _ -> b
18:25:38 <haasn> oh, yes
18:25:40 <ReinH> haasn: well this is definitely cleaner https://gist.github.com/reinh/0c7c9ce781c832fe25d7
18:25:52 <haasn> ReinH: yes
18:26:05 <jmcarthur> the spec literally defines strict fields as desugaring to using seq
18:26:17 <haasn> yes
18:26:18 <jmcarthur> so this isn't really the same as "implementing" seq in terms of something else :P
18:26:37 <haasn> but you can also literally introduce strict fields and then define seq in terms of that
18:26:37 <jmcarthur> but then you have to define what a strict field does
18:26:41 <haasn> the same as what seq does :P
18:26:46 <haasn> move the definition, easy
18:26:53 <haasn> they're equivalent, that's sort of the point here I guess
18:26:58 <jmcarthur> right
18:27:32 <ReinH> I don't even want to know, but...
18:27:36 <ReinH> @pl max' (x,y) (x',y') = ( x `max` x' , y `max` y')
18:27:37 <lambdabot> max' = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. max) . flip . (((.) . (,)) .) . max)
18:27:41 <haasn> no.
18:27:43 <ReinH> gg pfbot
18:28:00 <haasn> hmm
18:28:09 <haasn> max' (x,y) = x max *** y max -- ?
18:29:12 <haasn> err
18:29:23 <haasn> ‘max x’ instead of ‘x max’ obviously
18:29:26 <jmcarthur> :t uncurry (***) <<< join (***) max
18:29:27 <lambdabot> Ord a => (a, a) -> (a, a) -> (a, a)
18:29:36 <jmcarthur> :t uncurry (***) <<< max *** max
18:29:36 <lambdabot> (Ord c, Ord c') => (c, c') -> (c, c') -> (c, c')
18:30:18 <haasn> :t uncurry ((***) `on` max)
18:30:21 <lambdabot> Ord b => (b, b) -> (b, b) -> (b, b)
18:30:24 <haasn> what do I win?
18:30:29 <haasn> not quite as general, mind
18:30:33 <haasn> but for your purposes, fine
18:30:54 <jmcarthur> > uncurry ((***) `on` max) (4, 3) (2, 5)
18:30:57 <lambdabot>   mueval-core: Time limit exceeded
18:30:59 <jmcarthur> > uncurry ((***) `on` max) (4, 3) (2, 5)
18:31:03 <lambdabot>   mueval-core: Time limit exceeded
18:31:04 <haasn> oh no
18:31:06 <ReinH> yeah
18:31:07 <jmcarthur> fffuuuuuuu
18:31:13 <haasn> works here
18:31:14 <ReinH> so... I'm going to stick with what I have...
18:31:15 <haasn> elliott!!
18:31:20 <ReinH> ;)
18:31:47 <elliott> I looked into the timeout and I think it's just processing all the imports that takes the time.
18:31:51 <haasn> > 1
18:31:52 <lambdabot>   1
18:31:53 <elliott> though why it sometimes randomly takes two seconds more, I have no idea.
18:31:56 <jmcarthur> @undef
18:31:57 <lambdabot> Undefined.
18:32:02 <jmcarthur> > uncurry ((***) `on` max) (4, 3) (2, 5)
18:32:03 <lambdabot>   (4,5)
18:32:08 <haasn> poor shachaf
18:32:21 <jmcarthur> maybe it's just due to people @let importing stuff
18:32:32 <shachaf> help
18:32:33 <haasn> no
18:32:33 <elliott> well, it has like 50 imports anyway.
18:32:34 <haasn> let's blame elliott
18:32:38 <shachaf> What did I do?
18:32:48 <haasn> shachaf: all of your @let import's are gone
18:33:25 <haasn> y-you're demanding too much of poor lambdabot, jeez
18:37:17 <luite> elliott: you can preload the imports and then fork for eval, much faster
18:37:42 <haasn> isn't that what elliott's been trying to implement for the past month or so
18:37:49 <luite> oh i dunno
18:37:56 <ReinH> elliott: just preload every module on hackage
18:37:58 <ReinH> do it
18:38:02 <luite> notdan has it for the paste site gsoc
18:38:06 <haasn> ReinH: unqualified
18:38:10 <ReinH> confirm
18:38:14 <ReinH> I too like to live dangerously
18:38:17 <elliott> luite: like, OS-level fork? gross :p
18:38:27 <luite> elliott: yes, it works
18:39:18 <Fuuzetsu> does anyone know why Djinn struggles with lists?
18:39:19 <Fuuzetsu> @djinn (a -> b) -> [a] -> [b]
18:39:19 <lambdabot> Error: Undefined type []
18:40:03 <haasn> I'm not sure on whether or not it's impossible or just not implemented, but I do know that recursive types don't make a lot of sense in the context in which djinn is used
18:41:17 <haasn> though, of course, if it's possible then I expect to see the next iteration of Haskell where we only type the type signatures and let the compiler inference the code from it ;-)
18:41:30 <haasn> infer*
18:41:43 <Cale> Fuuzetsu: The logic which it's based on has no notion of recursion
18:41:53 <Cale> Fuuzetsu: and in particular, no recursive types for lists
18:42:25 <Fuuzetsu> Cale: yet on the excerpt here http://lambda-the-ultimate.org/node/1178 we can clearly see that lists were fine in the past
18:42:40 <haasn> come to think of it, it would still be quite funny to have djinn as a compiler extension that lets us omit the signatures for functions it can implement
18:42:44 <luite> elliott: what do you currently use to stop computations that take too long or use too much memory?
18:42:46 <haasn> language extension*
18:42:50 <haasn> omit the code*
18:43:00 <elliott> luite: it uses just calling out to mueval
18:43:01 <Cale> Fuuzetsu: I don't think they were ever supported really well
18:43:37 <edkk> for something like this (http://ideone.com/krhUTP), can I assume that the RE.compile's are re-written so they "are cached" or should I hoist out the RE compilations to top-level? (assuming that I need to do a lot of matching)
18:43:58 <luite> elliott: preloading + fork (when importing some big things like diagrams, which is the point of the gsoc) helped reduce the startup time from ~1.0s to ~0.05s
18:44:12 <haasn> Fuuzetsu: that definition for :: a -> [a] -> [a]  doesn't look particularly useful either =)
18:44:21 <Cale> Fuuzetsu: It's possible that the implementation just treated [a] similarly to how it would a new variable separate from a
18:45:10 <Fuuzetsu> noted, thanks
18:47:19 <elliott> luite: well, I have half-finished local code for using a patched version of the repl package
18:47:31 <elliott> which should avoid even a fork most of the time
18:47:49 <haasn> hmm
18:47:51 <luite> elliott: does that have reliable memory and time restrictions?
18:47:58 <haasn> @djinn f:: a -> Either b c -> Either a c
18:47:58 <lambdabot> Cannot parse command
18:48:00 <haasn> @djinn f :: a -> Either b c -> Either a c
18:48:00 <lambdabot> Cannot parse command
18:48:03 <haasn> @djinn a -> Either b c -> Either a c
18:48:04 <lambdabot> f a b =
18:48:04 <lambdabot>     case b of
18:48:04 <lambdabot>     Left _ -> Left a
18:48:04 <lambdabot>     Right c -> Right c
18:48:04 <FreeFull> @djinn (a -> b,a) -> b
18:48:05 <lambdabot> f (a, b) = a b
18:49:19 <Ghoul_> is ther a perf win
18:49:22 <Ghoul_> from unpacking an Integer?
18:49:30 <Ghoul_> unboxing*
18:49:56 <FreeFull> Lemme try something impossible
18:50:08 <FreeFull> @djinn (b,a->b)->a
18:50:08 <lambdabot> -- f cannot be realized.
18:51:42 <c_wraith> I think that can be defined if you implicitly believe in the axiom of choice.
18:51:54 <haasn> “ Djinn has proven to be much fun on #haskell.” the ultimate goal of every single academic Haskell work
18:51:55 <c_wraith> oh, I guess you need arbitrary equality, too
18:52:10 <FreeFull> @djinn (a->b)->b
18:52:10 <lambdabot> -- f cannot be realized.
18:52:14 <FreeFull> :t fix
18:52:15 <lambdabot> (a -> a) -> a
18:52:19 <FreeFull> @djinn (a->a)->a
18:52:19 <lambdabot> -- f cannot be realized.
18:52:23 <johnw> c_wraith: or if a is representable
18:52:41 <FreeFull> Seems djinn can't do fix
18:52:48 <c_wraith> fix isn't total
18:52:53 <c_wraith> djinn can only do total things
18:53:03 <FreeFull> Fair enough
18:53:20 <haasn> oh, I totally know what syntax would be awesome for djinn-as-a-language-extension
18:53:31 <FreeFull> Can it do all total things that don't involve recursive data structures?
18:53:36 <haasn> something like map (_ :: the -> signature)
18:53:44 <haasn> or f :: foo -> bar; f = _
18:54:23 <haasn> heck even ‘map _’ where it can be inferred
18:54:46 <FreeFull> I can't see many cases where it could be inferred
18:55:04 <c_wraith> remember, in the case of multiple solutions, djinn just picks one by the use of a couple heuristics
18:55:05 <FreeFull> Actually
18:55:07 <FreeFull> I can now
18:55:23 <c_wraith> @djinn (a -> a -> a) -> a -> a -> a
18:55:23 <lambdabot> f a = a
18:55:27 <roboguy__> is there a nice way to change a single element in a 2 dimensional vector?
18:55:43 <Ghoul_> is ther a perf win from unboxing an Integer with MagicHash?
18:55:46 <c_wraith> There are many other implementations of that signature!
18:55:50 <haasn> say you're working with something like ‘state’ and a function that is like it but has its arguments in the wrong order
18:55:55 <FreeFull> c_wraith: I see
18:56:04 <c_wraith> where "many" = "infinite"
18:56:05 <FreeFull> It could have just picked one of the two as
18:56:15 <FreeFull> But instead it picked the definition that made the most sense
18:56:21 <haasn> c_wraith: or just (a -> a) -> a -> a
18:56:29 <c_wraith> FreeFull: it tries to pick a definition that uses each input once
19:00:09 <Fuuzetsu> Is there a way to unload lambdabot plugins without recompilation?
19:00:24 <haasn> hmm come to think of it omitting the type signature *and* the code would just result in a lot of ambiguous type errors in most cases where it could be useful
19:00:26 <Fuuzetsu> (or disable)
19:00:57 <c_wraith> Fuuzetsu: no, lambdabot isn't designed to be dynamic
19:01:07 <Fuuzetsu> too bad
19:02:00 <Nisstyre> @djinn a -> b
19:02:00 <lambdabot> -- f cannot be realized.
19:02:02 <Fuuzetsu> oh, I did find @url-off in the code which does what I wanted in this case so I guess that's nice
19:06:51 <haasn> shachaf: re: distribution of fmap I just realized that looking at the left-distributive law makes a lot more sense: a * (b + c) = a * b + a * c;  now name f = (a *) and (.) = (+)
19:08:16 <carter> whats the lambda bot command where lambda bot replies "yes haskell can solve it"
19:08:46 <dmwit> ?faq Can carter be replaced with a bot?
19:08:47 <lambdabot> The answer is: Yes! Haskell can do that.
19:09:03 <carter> @faq can at signs work too?
19:09:03 <lambdabot> The answer is: Yes! Haskell can do that.
19:10:28 <haasn> as such it should be fairly easy to generalize distributivity to any form of f (g (x₀, x₁, x₂..)) to g (f x₀, f x₁, f x₂...); just have to figure out what kind of types would allow that law
19:11:14 <carter> for N ary might be nicest if done depedently, but theres probably some clever trick using type classes
19:12:49 <haasn> perhaps even something like f . g = g . map_f
19:15:47 <haasn> the example with (+) and (*) then boiling down to (x *) . sum = sum . map (x *)
19:17:44 <jmcarthur> haasn: what is this left-distributive law you are talking about relating to fmap?
19:19:07 <haasn> jmcarthur: fmap (f . g) = fmap f . fmap g -- ‘fmap’ distributes over (.)
19:19:18 <jmcarthur> ah
19:19:47 <shachaf> haasn: Right.
19:20:02 <haasn> finding a formulation of distributivity that plays nicely with the type signatures involved
19:20:53 <sclv> that's "fmap respects composition"
19:21:26 <sclv> if you move to monoidal functors you get "fmap respects (,)"
19:21:43 <sclv> and that's applicatives
19:22:11 <sclv> there's a way to think about (*) and (+) in that framework
19:22:49 <sclv> by taking the "free ring over a monoid" construction and lifting it to work over monoidal categories
19:22:56 <sclv> i've got like 1/3 of a blog post working this out
19:28:38 <haasn> sounds interesting, I'd have to refresh my memory on monoidal categories
19:29:53 <CADD> sclv: whats your blog's url?
19:30:18 <sclv> well it was going to be part of the series on comonad.com, which i've guest blogged at a bit
19:30:25 <sclv> but a) its not done and b) comonad is down at the moment
19:31:16 <sclv> there are backups of some of my other posts on applicatives here http://www.kmett.com/reader/ but they don't do the monoidal category stuff at all
19:31:32 <sclv> i probably need to work through my posts again to highlight the interesting bits
19:31:41 <sclv> (the queued up ones that is)
19:32:13 <Rarrikins> Why does the following print 1?  let a = newIORef 1 in fmap (flip writeIORef 2) a >> (join . fmap readIORef) a >>= print
19:32:35 <CADD> sclv: oh great, i love comonad
19:32:38 <sclv> a is an action that creates a new ioref with the default value one
19:32:47 <Rarrikins> Ahh
19:32:51 <Rarrikins> Thanks :)
19:33:02 <sclv> you need to use its result to get the actual ioref thus created
19:34:04 * sclv wonders if "all" distributive laws can be built out of monoidal categories
19:34:17 <haasn> shachaf: I just realized “hey, that sort of looks like the laws of a homomorphism; since (.) is associative and has an identity I guess that'd be like a monoid homomorphism.. except instead of a monoid we have something that's typed more like a category.. oh! I know! fmap is just like a functor!”
19:34:21 <Rarrikins> Is there a way to store that in, say data Whatever = Whatever Thing Thing (IORef a), in such a way that the third member is the already-created IORef?
19:34:46 <Rarrikins> (without requiring it to be inside of IO)
19:34:48 <sclv> yep, that's what the f in fmap stands for!
19:35:17 <sclv> Rarrikins: we call that "top level state" and frown upon it greatly
19:35:30 <sclv> there is the "unsafePerformIO hack" for creating a shared IORef at the top level
19:35:36 <Rarrikins> Ahh, OK
19:35:39 <sclv> it requires delicacy and is almost always the wrong thing
19:35:50 <shachaf> haasn: It's true.
19:35:53 <sclv> and everytime someone proposes codifying it as an extension people will yell at them
19:36:31 <cdk> Rarrikins: i see you've chosen to use an IORef instead of StateT Word32 IO a?
19:36:46 <cdk> it sounded like your problem was a perfect fit for StateT or WriterT
19:38:03 <pentace> Rarrikins: You can have the IORef stored in Whatever, though, as long as you pass this value around inside of IO
19:38:03 <haasn> shachaf: which actually leads me to instead suggest that we forget about distributivity and simply start talking about (*) being a family of functors
19:38:05 <haasn> perfect
19:38:52 <Rarrikins> cdk: I had the idea that people might use my code in many threads.
19:39:16 <Rarrikins> cdk: I wanted to make it resilient to that.
19:39:42 <cdk> okay, IORef is better (maybe not best) in that case
19:47:22 <sclv> if you want many threads you either need to exclusively use atomicModifyIORef, or move to mvars
19:52:37 <dmwit> Hm. It seems to me like sclv may have misinterpreted Rarrikins' question.
19:52:45 <sclv> ok?
19:53:03 <dmwit> If the question is "do I have to write data Whatever = Whatever Thing Thing (IO (IORef a))", then the answer is no.
19:53:41 <dmwit> You can have "data Whatever a = Whatever Thing Thing (IORef a)" without storing an IO action inside. You just need to use IO to build one of those.
19:53:48 <shachaf> "no" as in "yes, there's a way". :-)
19:54:06 <dmwit> "no" as in "no, you do not have to write that".
19:54:25 <sclv> double negation elimination? blasphemy!
19:55:01 <shachaf> Right. But the question was phrased "is there a way", so I just clarified that "no" meant that there was a way.
19:55:31 <Rarrikins> MVars look neat.
19:55:38 <dmwit> I modified the question. Pray I do not modify it further.
19:55:41 <Gracenotes> Both the short and long answers are no-with-a-but
19:55:53 <Rarrikins> I was hoping to avoid having to construct in IO, but it looks like I'll have to.
19:56:09 <Rarrikins> (if I want to avoid unsafePerformIO)
19:56:17 <dmwit> (which you do)
19:56:38 <shachaf> If OI existed, you could nstruct. But it doesn't.
19:56:59 <Gracenotes> is IORef creation threadsafe?
19:57:08 <sclv> yeah
19:57:17 <Gracenotes> I'd assume, otherwise the top-level global mutable state wouldn't use it
19:57:22 <sclv> IORefs are totally threadsafe in the "not crashy" sense
19:57:33 <shachaf> Gracenotes: Well, it's more of a matter of unsafePerformIO, there.
19:57:40 <sclv> they're just hard to keep disciplined with multithreading in the "co-ordinate sensibly" sense
19:57:55 <shachaf> Gracenotes: See http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
19:58:01 <Gracenotes> shachaf: hm yes, I would assume the IORef would introduce a blackhole
19:58:02 <Gracenotes> yeah
19:58:08 <Gracenotes> which is threadsafe
19:58:26 <sclv> the threadsafety of unsafeperformio is pretty neat
19:58:29 <shachaf> Otherwise you might e.g. create two different IORefs, presumably.
19:58:44 <Gracenotes> the miracle of sharinga
19:58:47 <Gracenotes> -a
19:59:15 <dmwit> Black holes are thread safe because of purity. IORef creation isn't pure. unsafePerformIO bends over backwards to add thread safety back in.
19:59:50 <Gracenotes> oh, well, what's the problem with IO actions spuriously happening twice :)
20:00:57 <dmwit> Also, everything I just said is cargo-culted, so take it with a squint and a question.
20:02:42 <brooksbp> Yay! Haskell!
20:03:06 <dmwit> \ol
20:03:26 * dmwit does an impromptu Walk Like An Egyptian
20:03:41 <edwardk> dmwit: just make sure to wrap it in a NOINLINE
20:03:48 <Nisstyre> so that Simon Marlow book looks really good
20:04:09 <Nisstyre> I may buy but I'm worried about it being outdated in a year
20:04:27 <edwardk> the code that i have for my chase-lev deque was totally broken… because I missed a few NOINLINEs
20:04:28 <edwardk> =/
20:04:30 <Gracenotes> yeah.. parts may well be
20:04:47 <edwardk> ryan newton demonstrated the patience of a saint tracking down all the issues
20:04:54 <brooksbp> Nisstyre: do you never buy hardware because it will most certainly be outdated within a year?
20:05:10 <Gracenotes> a great book about concurrency that will never get outdated, though, is Java Concurrent in Practice
20:05:40 <Gracenotes> which is about an imperative language, and the corresponding fine-grained tactics required, but still has a bunch of general wisom
20:05:43 <Gracenotes> wisdom
20:05:50 <Nisstyre> brooksbp: well, I do buy hardware knowing it will be outdated, but I use it much more frequently
20:05:53 <Nisstyre> so I get more out of it
20:06:04 <Nisstyre> I tend to go back to books years later if they're still relevant
20:06:11 * Gracenotes brb
20:18:19 <Ghoul_> on the note of unsafePerformIO and things happening twice
20:18:37 <Ghoul_> mmap package has a glitch in it and its usage of unsafePerformIO I think
20:27:04 <carter_away> edwardk is the patent worry still in play for the chase lev stuff?
20:27:13 <edwardk> dunno
20:27:23 <edwardk> knock yourself out. i was just implementing it =P
20:27:50 <carter> edwardk i was thinking it'd be pretty easy to email the original paper authors to ask them
20:28:16 <carter> sounds like you havne
20:30:04 <carter> *havent
20:30:14 <edwardk> i asked chase back at NEPLS 2008 about it and he seemed to indicate they weren't going after folks about patent stuff for it when it was being used for fork join parallelism, then i stopped thinking about it
20:30:15 <carter> edwardk what happened to work stealing for analyticsdb?
20:30:27 <carter> ah
20:30:27 <edwardk> i evolved past the need for it
20:30:40 <carter> i've not seen any new commits either!
20:30:48 <carter> (though you are crazy busy)
20:30:50 <edwardk> i've evolved past those, too ;)
20:31:24 <carter> walking around perturbs the butterfly that scatters the high energy radiation that writes the bits on you laptop
20:31:26 <carter> got it
20:31:43 <carter> M x wandering-butterfly mode?
20:31:45 <edwardk> yes. its somewhat of an inexact science writing code this way
20:33:29 <Ghoul_> im unsatisfied that pattern matching is working correctly here
20:33:47 <Ghoul_> http://lpaste.net/91139
20:33:53 <Ghoul_> that's 5.
20:34:05 <Ghoul_> I would have expected an exception from exhausted guards or something
20:34:24 <carter> Ghoul_ you have a fall through
20:34:28 <carter> its kosher
20:34:28 <Gracenotes> it really is just top-to-bottom
20:34:31 <carter> yeah
20:34:48 <carter> its try the matches in order semantics
20:34:53 <carter> not "most specific" order
20:35:23 <Cale> Ghoul_: The guard where a == 3 fails, and the f a = 5 case matches f 4 with a = 4
20:35:40 <Ghoul_> guards are smarter than I thought they were then I guess
20:35:46 <Ghoul_> thanks :P
20:37:13 <carter> they're simpler tooo
20:38:55 <Gracenotes> the above basically compiles down to 'if a == 3 then 4 else 5'
20:39:16 <carter> yup
20:41:13 <Gracenotes> indeed, if you wrote it like that you'd basically produce the same output file
20:47:41 <johnw> Ghoul_: think of guards as an extension of the pattern: therefore, if it doesn't match, the next pattern or pattern+guard is tried
21:09:33 <shachaf> Ghoul_: ...(Integral a#) => a# -> a# -> a#?
21:09:50 <shachaf> I'm pretty sure that does not do what you want.
21:10:03 <Ghoul_> shachaf: indeed it doesn't.
21:10:37 <Ghoul_> Well, actually, I'm not sure. It doesn't do anything for Integer, but the core shows that all the regular Int stuff is unboxed
21:10:45 <Ghoul_> whether thats a result of magic hashing the type or not, I'm actually not sure.
21:10:48 <Ghoul_> Not my code :)
21:11:39 <Ghoul_> changing 111 to (111 :: Int) and you see the unboxing in the core
21:11:40 <haasn> shachaf: isn't that just a regular variable name?
21:11:51 <haasn> actually, a syntax error
21:12:03 <haasn> unless MagicHash is enabled I guess
21:12:16 <shachaf> haasn: Right. Nothing unboxed about it.
21:12:37 <Ghoul_> shachaf: what would be the correct way?
21:12:42 <shachaf> The class constraint gives a pretty big hint there.
21:13:03 <shachaf> Correct way to what?
21:13:20 <shachaf> The default correct way is not to unbox things.
21:14:18 <shachaf> Ghoul_: (I'm talking in here because #ghc is for GHC development. I try to keep general Haskell discussion in other channels.)
21:15:06 <Ghoul_> aight. Let's say that I /want/ to unbox something explicitly -- how would I do that?
21:15:21 <shachaf> That depends. What's the something?
21:15:23 <Ghoul_> in f a b = a + b
21:15:34 <Ghoul_> f :: Integral a => a -> a -> a
21:15:40 <haasn> can't be done polymorphically, for reasons that I hope should be obvious
21:15:53 <solrize_> Int# is the unboxed int type, but it's of a different kind than Int
21:15:54 <shachaf> There are no type classes or polymorphism for unboxed types.
21:15:54 <Ghoul_> can I specialize an unboxed type?
21:16:08 <Ghoul_> hm
21:16:12 * hackagebot postgresql-simple 0.3.4.0 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.3.4.0 (LeonSmith)
21:16:22 <shachaf> But note that GHC can often do plenty of unboxing on its own.
21:16:44 <Ghoul_> out of curiosity, has anyone ever suggested adding a typeclass for things that can be unboxed?
21:17:10 <solrize_> erm, from the regular type system's point of view, unboxed values don't exist :)
21:17:38 <Ghoul_> Ah, true.
21:19:02 <solrize_> i don't know why there's a kind distinction.  seq may require similar hackishness but has a regular type signature.
21:19:38 <shachaf> Hmm? Why does seq require hackishness?
21:22:12 <solrize_> seq breaks the denotation of f _|_ i thought
21:24:07 <Cale> solrize_: The only denotational thing which changes in the presence of seq is that you have to distinguish between (\x -> _|_) and _|_
21:25:47 <Cale> A lot of the laws we'd like to have hold of things end up failing in the presence of such a distinction, but mostly as language users we just ignore them. (c.f. "Fast and loose reasoning is morally correct")
21:27:12 <solrize_> fair enough.  and there can be polymorphism over types some of which have strict constructors and others of which don't
21:27:43 <solrize_> so i still wonder, why does Int# have a different kind than Int?  I remember having to duplicate a bunch of code in order to use Int# for something a while back.
21:27:49 <shachaf> solrize_: That's not related to the problems with unboxing.
21:27:57 <Cale> The reason for Int# having a different kind from Int is polymorphism
21:29:12 <Cale> When you compile a function with a type variable in its type, only one piece of code is generated, and because all values of kind * in the language implementation have the same memory representation (a pointer to code) the same code works at all possible types of kind *
21:29:25 <Cale> But unboxed types may have different memory representations.
21:31:09 <Cale> and in particular, they may be a different number of bytes, so compiled polymorphic functions which assume everything has the same size as a code pointer would generally not manipulate unboxed values correctly
21:31:14 <solrize_> a polymorphic call could still wrap a thunk around an unboxed value
21:31:47 <Cale> Well, that's exactly what the difference between Int and Int# is.
21:31:55 <solrize_> or could just figure out the type at the call site, and bloat out the code like a C++ template
21:32:04 <Cale> Maybe you could do it automatically
21:32:39 <Cale> In fact, iirc, the original paper which introduced the unboxed kinds also laid out a plan for polymorphism...
21:33:19 <Cale> let me look at that again, I might not be remembering clearly
21:34:21 <sclv> Ghoul_: here's one way of sort of giving operations to unboxable stuff http://hackage.haskell.org/packages/archive/primitive/0.5.0.1/doc/html/Data-Primitive-Types.html
21:34:55 <sclv> its used in vector to handle vectors of unboxed things
21:36:26 <Cale> Oh, it just mentions the possibility briefly, but mentions that it's of debateable value, given that the reason that unboxed values are there in the first place is to help programmers improve performance. Adding (potentially expensive) implicit coercions everywhere to restore polymorphism might be counterproductive.
21:37:16 <Cale> Another danger of treating Int# values as being kind * is what happens if the GC ever tries to garbage collect one.
21:38:02 <solrize_> i think the problem i had wasn't polymorphism but that i could no longer create types for different uses of unboxed ints
21:38:06 <Cale> (even if they are the same size as code pointers)
21:38:22 <solrize_> the unboxed part of the program was effectively untyped
21:38:42 <Ghoul_> sclv: thanks
21:38:43 <solrize_> i couldn't say newtype Temperature# = Temperature# Float#
21:38:49 <solrize_> to prevent it from getting mixed up with a distance
21:39:03 <Cale> That is a good point
21:40:19 <Cale> The original paper about unboxed types discussed a scheme for declaring unboxed product and sum types.
21:41:06 <startling> edwardk: does parsers/trifecta have anything for infix operators?
21:41:16 <edwardk> yes
21:41:31 <edwardk> http://hackage.haskell.org/packages/archive/parsers/0.8.3/doc/html/Text-Parser-Expression.html
21:41:42 <startling> aha
21:41:43 <startling> thanks
21:41:45 <Cale> It gives an example like  data unboxed UCpx# = UCpx# Int# Int#
21:42:04 <solrize_> what about sums?
21:42:23 <solrize_> it makes something with a tag field?
21:42:28 <Cale> Or  data unboxed Colour# = Red# | Green# | Blue#
21:42:55 <Cale> An unboxed Maybe# would be a bit funny perhaps
21:43:33 <elliott> kmc wrote Maybe# once
21:43:51 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/Papers/unboxed-values.ps.Z
21:44:00 <elliott> http://lpaste.net/56370
21:45:10 <monochrom> God
21:46:22 <haasn> I got as far as “reallyUnsafePtrEquality#”
21:58:19 <DiegoNolan> Why is there no mapM_ in Control.Monad.Parallel?
21:59:07 <mm_freak> DiegoNolan: mapM_ is in Prelude and Control.Monad
21:59:23 <DiegoNolan> Yeah but I want tho parrellel version
21:59:41 <DiegoNolan> there is a mapM in Control.Monad.Parallel
21:59:45 <DiegoNolan> but not mapM_
21:59:52 <DiegoNolan> :t mapM_
21:59:53 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
22:03:01 <mm_freak> DiegoNolan: good question, but you can write it in terms of sequence_
22:03:12 <mm_freak> :t sequence_ . map
22:03:13 <lambdabot>     Couldn't match type `[a1] -> [b0]' with `[m0 a0]'
22:03:13 <lambdabot>     Expected type: (a1 -> b0) -> [m0 a0]
22:03:13 <lambdabot>       Actual type: (a1 -> b0) -> [a1] -> [b0]
22:04:02 <mm_freak> :t \f -> sequence_ . map f
22:04:02 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m ()
22:04:04 <haasn> :t sequence_ .: map
22:04:05 <lambdabot>     Not in scope: `.:'
22:04:05 <lambdabot>     Perhaps you meant one of these:
22:04:05 <lambdabot>       `.' (imported from Data.Function),
22:04:09 <haasn> elliott!!
22:08:32 <kai_> I'm wondering why the Data.ByteString package doesn't contain the "lines" function?
22:08:47 <dmj> kai_: just ran into that today
22:09:02 <shachaf> kai_: Because Data.ByteString is a sequence of bytes, not of characters.
22:09:11 <shachaf> Maybe you're after Data.Text.
22:11:33 <kai_> shachaf, the Data.ByteString.Char8 has "lines", but why doesn't it have the "join" function?
22:11:47 <johnw> you mean, unlines?
22:12:02 <shachaf> kai_: Data.ByteString.Char8 is a bad module. Experts only.
22:12:03 <kai_> unlines only join '\n'
22:12:24 <shachaf> By bad I mean broken. It pretends each character is one byte, which isn't true.
22:12:45 <shachaf> So you should use Data.Text, or maybe Data.ByteString.UTF8 for ByteStrings, or something else.
22:12:57 <johnw> it's like Data.ASCII, except that the bytes don't need to conform to ASCII
22:13:12 <johnw> yes, Char8 makes a host of assumptions
22:13:21 <kai_> Is Data.Text faster than Data.String?
22:13:38 <kai_> The default String is really slow
22:13:44 <johnw> kai_: on the whole, it's much faster
22:13:49 <shachaf> A data type isn't fast or slow. :-)
22:13:59 <shachaf> Many Text operations are faster. Some are much slower.
22:14:15 <shachaf> It's usually more memory-efficient.
22:15:41 <kai_> I want to read a file, and write something to another file, when using default String, it was 2X slower than Python. But after I switched to Data.ByteString.Char8, it is 5X faster than Python
22:16:07 <haasn> is strict Text just a big continuous segment of memory like bytestring, with the lazy variant being a list of strict segments?
22:16:30 <johnw> yes
22:16:58 <haasn> so something like inserting a character at the nth position of a Text is fairly cumbersome? (compared to a String)
22:17:24 <johnw> yes, a simple "cons" to a strict Text would be much slower, for example
22:17:26 <johnw> if it were a long string
22:17:41 <johnw> it's like (list of) arrays vs. lists
22:27:14 <solrize_> i thoguht strict and lazy were both lists of chunks under the covers
22:27:43 <solrize_> strict just doesn't do lazy i/o
22:27:56 <Cale> no
22:28:16 <Cale> Lazy Bytestrings are essentially lists of strict bytestrings
22:37:42 <dmj> fac (n+1) = (n+1) * fac n, isn't valid haskell right
22:38:08 <dmj> oh, npluskpatterns
22:38:22 <dmj> ah
22:39:41 <shachaf> No, not valid Haskell 2010.
22:46:40 <startling> does {-! ... !-} mean something in haskell?
22:47:17 <dmj> startling: {- -} are multiline comments
22:47:27 <MrRacoon> startling++
22:47:27 <startling> dmj, sure. I'm asking about the bangs specifically.
22:47:36 <yopikh> I've seen people telling compiler to use the '...' extension
22:47:40 <yopikh> with that.
22:47:51 <startling> yopikh, that's {-# Language ... #-}
22:48:30 <yopikh> startling: hmm ow. :P
22:52:33 <dmj> startling: where do you see it?
22:53:16 <dialelo>  /close
22:53:28 <startling> dmj, idris' source code. :/
22:54:22 <startling> there's a lot of {-! deriving instance Binary ... !-} and, coincidentally, a lot of missing Binary instances when I try to run it in ghci.
22:55:32 <startling> seems to be unrelated on further exploration; I guess it's just an odd convention?
22:58:57 <dmj> startling: maybe its his own todo markup.
22:59:30 <startling> dmj, evidently.
22:59:33 <dmj> startling: ("let", Nothing) -- FIXME syntax for let
22:59:50 <dmj> startling: in Completion.hs
23:00:33 <LordBrain> anyone use alex,happy,bnfc ?
23:01:41 <LordBrain> I am trying to find the entry points for the generated parser, the test parser file that it generated gives an error message without a column number and with the line number embedded into a string, this seems not ideal.
23:02:23 <LordBrain> if there is an error, i don't know why i wouldn't want complete position information stored in separate Ints
23:02:38 <haasn> doesn't ghc use alex/happy
23:02:56 <LordBrain> yeah but i havent coded on ghc
23:04:28 <LordBrain> bnfc is a tool that lets you define your language in a bnf like syntax, and then it generates the input files for alex and happy
23:05:12 <Hafydd> Doesn't alex already take a "BNF-like" syntax?
23:06:34 <Hafydd> Er, s/alex/happy/
23:07:27 <LordBrain> there's no escaped haskell or anything like that in the bnf file, the tool doesn't just generate alex and happy files, it generates JLex, Flex, CUP, and Bison stuf too.
23:07:58 <LordBrain> as well as documentation for your language
23:09:00 <LordBrain> so you can write your compiler in c, c++, java, C#, Haskell, whatever
23:09:40 <LordBrain> http://bnfc.digitalgrammars.com/
23:10:10 <LordBrain> it's a neat idea, at least in theory.
23:10:47 <LordBrain> so i've been tinkering with it
23:11:49 <LordBrain> and i have my little language, and it parses and lexes etc... but if i want to take this and start embedding it now in a haskell program, i need to understand the appropriate entry point
23:13:40 <LordBrain> it generated a test parser program, but the test parser program uses an error monad which seems to embed the line number into an error message string, and otherwise discard all position information, that may be fine for a test thing to see my language is parsing correctly, but seems like not a good entrypoint for production code...
23:16:04 <Ghoul_> @pl (\x -> (phi $ sieve n) x)
23:16:04 <lambdabot> phi (sieve n)
23:16:04 <LordBrain> so i thought, well i will look at the module that happy generated, but it has a bunch of functions and no export list, so they're all exported... so it's not clear to me what i am going to call
23:16:18 <Ghoul_> @pl (\_ -> (phi $ sieve n) x)
23:16:21 <lambdabot> const ((phi $ sieve n) x)
23:16:21 <lambdabot> optimization suspended, use @pl-resume to continue.
23:16:31 <LordBrain> maybe someone more experienced with happy could help me figure it out?
23:20:55 <lpaste> LordBrain pasted “Parmylang.hs” at http://lpaste.net/91140
23:21:12 <LordBrain> ^ That's the happy generated module
23:22:01 <LordBrain> so what's the entry point? I can post the .y file if that will help
23:24:07 <lpaste> LordBrain pasted “Parmylang.y” at http://lpaste.net/91141
23:24:26 <LordBrain>  ^ That is the input to happy
23:26:13 <LordBrain> It seems like to make this more useful for haskell , i might need to modify bnfc, which is fortunately written in haskell tho the developers i think might be prioritizing the other backends.
23:26:57 <LordBrain>   Bad $ "syntax error at " ++ tokenPos ts ++
23:28:51 <LordBrain> I can't understand why this would be what it offers me, wouldn't Bad with an error position having the line & column stored in Ints be more generally what the users want?
23:32:32 <LordBrain> After all, this language neutral syntax error message is not really so general, and it throws away the column and absolute character position which are being tracked, the line number is in it, but now i have to lex the error message to get the line number out for my program, because I may want to do something else than this message, and preferably i wouldn't want to modify generated files like this .y file.
23:33:30 <LordBrain> Am I making sense?
23:34:25 <LordBrain> so i see this happyError function in the .y file, and is it just me or is it kinda stupid?
23:36:30 <notdan> elliott: how is calling the mueval binary directly is better than forking? :P
23:37:02 <notdan> elliott: right now my IRC bot evalues the code faster than lambdabot. it is not as feature-rich and half-baked though
23:38:31 <elliott> notdan: didn't say it was
23:55:36 <dlackili> How could this be done in haskell? http://wiki.tcl.tk/3468
23:56:13 <ezyang_> 'lo Haskell. I'm looking for famous Haskell tutorials whose primary point of reference come from other languages
23:56:19 <ezyang_> Something like "Haskell for X programmers"
23:58:05 <shachaf> I don't think most of those are very famous.
23:58:19 <edwardk> ezyang: I now want to write "Haskell for Haskell programmers" ;)
23:58:23 <shachaf> Also, in my experience not very good.
23:58:26 <zvrba> there is Haskell for C programmers
23:58:30 <shachaf> edwardk: That's the Gentle Introduction.
23:58:57 <ezyang_> I'll give it away: I want to write a gag article "Haskell for Coq programmers"
23:59:10 <ezyang_> "So you may have heard about this popular new programming language called Haskell."
23:59:18 <edwardk> "Haskell for Agda programmers"
23:59:34 <edwardk> Haskell is like agda without *gasp* dependent types.
