00:00:25 <lightquake> is http-conduit the best http library? for a reasonable value of 'best'
00:00:59 <lightquake> i like that it follows redirects, but I'm a little ambivalent about the idea of it throwing exceptions
00:10:00 <johnw> you can always use teaspoon
00:21:03 <thoughtpolice> spoon is evil. personally, for something like this if i was worried about exceptions coming out of nowhere, i might just use async to fire a thread and get any exceptions propogated back through Either. async makes this fairly easy and it at least gives you some isolation
00:21:15 <thoughtpolice> but maybe just catching the exceptions is easier, depending on what you're doing
00:28:50 <Modius> I know this may be a yesod-specific question; but when I see in the yesod TH expamsion, what does [yesod-routes-1.2.0.1:Yesod.Routes.TH.Types.ResourceLeaf mean? Isn't : a cons/list constructor?
00:35:00 <roboguy_> Modius: I don't know much about yesod, but I bet it that bit of code involves template haskell
00:38:31 <Saizan> Modius: that's how ghc qualifies identifier names with the package they are from
00:55:24 <johnw> thoughtpolice: does async have a functino like teaspoon but which uses another thread?  I know that Snoyman just added something like that to one of his libraries last week
00:56:00 <thoughtpolice> waitEither is what i was talking about.
00:56:17 <thoughtpolice> oh, wait, wrong one
00:56:25 <thoughtpolice> ah, waitCatch
00:56:44 <johnw> ah, nice
00:56:50 <johnw> i'll use that in future instead of teaspoon, thanks!
00:56:56 <shachaf> waitCatch isn't much like teaspoon.
00:57:41 <shachaf> johnw: If you're using teaspoon where you can be using an IO thing, you shouldn't be using teaspoon.
00:57:44 <thoughtpolice> well, i sort of ignored the point about spoon because in the case of http-conduit you're not going to need something like spoon, you just want to deal with exceptions
00:57:57 <thoughtpolice> which is fine (and spoon is still evil.)
00:59:34 <pharaun> why spoon is evil?
00:59:39 <pharaun> *why is
01:00:13 <johnw> shachaf: but teaspons is just "catches", how is that different from just "an IO thing"?
01:00:48 <shachaf> Well, there's the whole unsafePerformIO deal...
01:01:07 <johnw> oh, true
01:01:11 <johnw> never mind then, you're right
01:01:15 <shachaf> evaluate + catch is catching an exception in IO. teaspoon is breaking a much bigger promise.
01:01:52 <johnw> right; I now see its evilness
01:02:45 <thoughtpolice> pharaun: all undefined values are equal, and you can't "tell the difference." so undefined == error "foo" == last [1..], etc.
01:03:00 <thoughtpolice> if you have x == y, you'd expect f x == f y, but this isn't true with spoon
01:03:06 <startling> honestly it seems like errors are the evil thing, not teaspoon.
01:04:42 <johnw> well, errors in IO are natural to such a monad, I think
01:04:51 <johnw> the RealWorld has errors in it.  But for pure functions, I agree
01:04:59 <startling> yeah.
01:05:07 <johnw> and yet, people do forget to provide total coverage for their pattern matches, etc.
01:05:11 <johnw> so you have to represent that somehow
01:06:17 <thoughtpolice> well, i'd say errors in pure code are evil, but using spoon is also evil.
01:06:24 <thoughtpolice> (for the most part)
01:06:49 <shachaf> :-(
01:06:56 <johnw> hidden unsafePerformIO's masquerading as something safe are a pretty bad evis
01:06:56 <shachaf> Whatever. Now is not the hour for this sort of thing.
01:07:04 <johnw> huh?
01:07:18 <startling> shachaf, can I make an appointment? :)
01:08:45 <pharaun> thoughtpolice: ahh i see
01:13:33 <bennofs> Is it possible to generate standalone deriving declarations with template haskell?
01:13:57 <startling> You mean using the ordinary "deriving" mechanism? I don't think so.
01:14:11 <bennofs> I mean the -XStandaloneDeriving mechanism
01:14:37 <bennofs> runQ [d| deriving instance (Show a) => Show (Const a b) |] returns []
01:14:42 <startling> oh
01:16:13 <johnw> isn't it weird that there is no Traversable instance for Either e in Data.Traversable?
01:17:06 <johnw> i see lens has them
01:17:29 <startling> yeah.
01:17:35 <thoughtpolice> johnw: it's in HEAD
01:17:37 <startling> (,) a, too.
01:17:40 <johnw> oh!  great
01:17:44 <thoughtpolice> it was proposed like a year ago and Ross forgot to merge the patches
01:17:48 <startling> haha
01:17:59 <thoughtpolice> same with (,) a
01:20:26 <bennofs> Is it possible to manually write Typeable instances in GHC 7.7?
01:20:32 <bennofs> (GHC 7.8)
01:20:57 <thoughtpolice> IIRC, they're ignored now since Typeable is polykinded
01:25:27 <bennofs> > typeRep (Const 3 :: Const Int Int)
01:25:28 <lambdabot>   Not in scope: `typeRep'
01:30:32 <bennofs> Is there any way to generate a Typeable instance in GHC 7.8 via template haskell? (Standalone deriving seems to be unsupported by TH)
01:32:52 <thoughtpolice> i don't know, but you can use -XAutoDeriveTypeable in the module itself
01:33:19 <thoughtpolice> if there's not support in TH, i'd say you should file a bug
01:33:24 <thoughtpolice> it could likely be fixed before 7.8
01:33:34 <thoughtpolice> (for standalone deriving, i mean)
01:33:56 <bennofs> Ok, I will file a bug report
01:49:33 <johnw> i seriously need a cxx-options field in Cabal
01:57:10 <mstksg> is there any way to deal with naming clashes for accessors on records
01:57:30 <mstksg> can i really not have two data types with the same name for a field
01:57:43 <mstksg> :(
01:58:11 <zomg> mstksg: if it's in another module you can do a qualified import but besides that nope
02:00:37 <mstksg> zomg: am i the only one who is disheartened by this or is this a problem that never really comes up in everyday haskelling
02:02:46 <zomg> I think it's regarded as one of the weak spots of haskell in general so you're not alone
02:03:52 <mstksg> thanks
02:10:45 <Heffalump> zomg, mstksg: there's a GSoC project to address it at the moment
02:16:20 * hackagebot phybin 0.2.11 - Utility for clustering phylogenetic trees in Newick format based on Robinson-Foulds distance.  http://hackage.haskell.org/package/phybin-0.2.11 (RyanNewton)
02:16:37 <startling> Heffalump: cool!
02:16:59 <startling> (that sounds way too feasible for a GSoC project...)
02:25:23 <startling> does this already exist somewhere? https://gist.github.com/startling/cacfe54c338b80b414cf
02:33:12 <mstksg> is there a way to runhaskell a file and specify a module to be imported through command line?
02:33:55 <startling> do you mean a module or package?
02:34:22 <mstksg> startling: er...basically the same as if the file had an "import ..." at the top
02:34:39 <startling> I don't think there's a way to do that.
02:34:45 <startling> it seems silly anyhow.
02:35:08 <mstksg> startling: yea ... when i read it again it does seem silly.
02:36:24 <mstksg> i just have a file that's a dsl that is meant to be runhaskell'd with an alias...the dsl requires an import, but i want to be able to have the actual file have no import statement to kind of hide the fact that it's a haskell file
02:39:31 <adas> what is the difference between hayoo and hoogle?
02:39:41 <startling> hayoo is newer and supposedly nicer.
02:39:56 <startling> hayoo indexes packages, too, I think.
02:40:20 <donri> hayoo indexes all of hackage but hoogle has better type signature matching
02:41:27 <adas> so i can't do type signatures on hayoo?
02:42:00 <adas> ill chk it ou
02:42:21 <adas> thanks for the clarification though
02:43:27 <startling> is there something like data Pair f g a = Pair (f a) (g a) with e.g. instance (Foldable f, Foldable g) => Foldable (Pair f g) ?
02:43:35 <donri> adas: i think you can but hoogle is better at dealing with polymorphism i think
02:44:58 <donri> @hoogle Int -> Int
02:44:58 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
02:44:58 <lambdabot> Data.Text.Unsafe iter_ :: Text -> Int -> Int
02:44:58 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
02:46:11 <adas> donri: can i do that from my cmd line?
02:46:14 <donri> adas: ok not the best example but anyway hoogle will also find a -> a etc, hayoo just literally searches for Int -> Int more or less
02:46:30 <donri> adas: you can use hoogle from the command line offline, yes, duno about hayoo
02:46:36 <donri> @hackage hoogle
02:46:36 <lambdabot> http://hackage.haskell.org/package/hoogle
02:53:06 <hpaste> ocharles pasted “Text.Builder for rendering XML” at http://lpaste.net/91267
02:53:23 <ocharles> Hi all. I'm trying to render XML (from XML.Light) to Text using Text.Builder
02:53:35 <ocharles> the above paste uses 1GB memory according to a heap profile, yet produces 64MB XML
02:53:41 <ocharles> and it's 40% productive
02:53:49 <ocharles> However, I have no idea how to go about getting this faster :(
02:54:34 <hpaste> ocharles pasted “XML rendering profiling report” at http://lpaste.net/91268
02:54:38 <ocharles> there's the profiling report
02:56:00 <ocharles> http://i.imgur.com/p1sWXyx.png is the program with +RTS -l viewed in threadscope
02:57:34 <ocharles> zooming in on the dense green section in thread scope just shows it constantly spiking the GCing
02:58:04 <adas> when i try installng haddock with `cabal install haddock` i get "Program alex version >= 2.3 is required but could not be found".
02:58:36 <ocharles> adas: cabal install alex, and make sure ~/.cabal/bin is on your $PATH
03:01:40 <donri> ocharles: why not use hexpat
03:02:08 <adas> hexpat?
03:02:38 <donri> adas: not for you
03:03:08 <ocharles> donri: I could, but this is a nice exercise to learn how to write fast text generation
03:03:24 <adas> ocharles: why can't cabal auto-find alex? when i do cabal install alex it works. but when i do cabal install haddock it quits saying that it couldn't find alex
03:03:24 <ocharles> whether or not I'll end up using it, I'd still like to know how to get this code faster
03:03:36 <ocharles> adas: did you check PATH like I said?
03:04:31 <adas> ocharles: yup. i added it to PATH
03:04:49 <adas> and now it says it can't find `happy`. but cabal install happy worked
03:05:17 <donri> adas: both happy and alex come with haskell platform
03:05:48 <adas> i didn't install the platform. that msut be the problem. i thought i could instead just install what i need
03:06:09 <donri> adas: thing is cabal tracks libraries not executables and alex and happy only provide executables, so you can't write a dependency for them
03:07:48 <adas> haddock install failed. exception was ExitFailure and the actual error is "Not in Scope: type constructor or class `SafeHaskellMode`"
03:07:56 <adas> *ExitFailure 1
03:09:06 <adas> and path is properly set
03:10:16 <adas> is there anything i may try out to solve the problem?
03:10:22 <donri> adas: hm i think haddock should come with ghc? how did you install ghc
03:10:44 <donri> and i think it's closely tied to the ghc version
03:10:46 <adas> im think i need to install some package that has the class safehaskellmode
03:10:52 <donri> and if you don't have safe haskell your ghc is kinda old
03:11:01 <adas> donri: sudo apt-get install ghc
03:11:10 <donri> on what, debian stable?
03:11:41 <adas> ubuntu precise
03:12:00 <donri> which version is that again
03:12:10 <donri> anyway i highly suggest installing haskell-platform
03:13:09 <adas> Glasgow Haskell Compiler, Version 7.4.1, stage 2 booted by Version 7.4.1
03:13:22 <donri> but if you do that now you'll want to rm ~/.ghc (or back it up)
03:13:38 <adas> isn't 7.4.1 new enough?
03:13:41 <donri> ok that's not too old
03:13:41 <adas> or is that really old?
03:14:06 <adas> i thought the latest version of the haskell-platform came with an older version of ghc
03:14:08 <donri> but in any case i'm not sure you can just cabal install haddock
03:14:21 <donri> the latest version comes with 7.4.2 i think
03:14:33 <donri> but ubuntu will just use the same ghc package anyway
03:14:53 <donri> on linux the platform is usually just a meta package
03:15:39 <Ralith> pretty sure the haskell platform's been on 7.6 for a while
03:16:25 <donri> ah you're right
03:18:31 <adas> so usally everyone simply installs the haskell-platform? i thought most folks here install the latest version of ghc and then install modules in a piece meal fashion?
03:19:14 <ocharles> donri: moved the question to SO
03:19:40 <startling> adas, it doesn't matter a whole lot now that the platform's on 7.6.
03:21:41 <adas> i think ill do a fresh install of the haskell platform. Could you please tell me what I have to remove now so i don't have any conflicts when i install the platform?
03:21:45 <donri> adas: i suggest installing the platform unless you "know what you're doing", and in any case, if you're installing ghc with apt-get anyway there's little reason not to install the platform
03:22:00 <adas> cos i already have ghc 7.4.1 and a bunch of packages installed through cabal
03:22:25 <donri> adas: reasons for not using the platform are usually things like, using a different version, or multiple versions, and/or compiling ghc yourself
03:22:46 <adas> so i do sudo apt-get autoremove --purge ghc. And then i delete ~./ghc and ~./cabal?
03:22:51 <donri> adas: rm ~/.ghc; sudo apt-get install haskell-platform; cabal install world
03:23:18 <donri> don't need to apt-get remove ghc, it's the same package haskell-platform will pull as a dependency anyway
03:24:57 <adas> donri: but if i wanted to uninstall cabal packages that i installed via cabal, would it be sufficient if i simply rm ~/.cabal
03:26:16 <donri> adas: no, they're in ~/.ghc
03:26:32 <adas> so i don't have to touch .cabal?
03:27:11 <donri> don't have to, but may or may not want to clean out ~/.cabal/bin
03:27:44 <donri> or you'll have multiple alex and happy executables and it depends on the order of $PATH which ends up used
03:32:08 <Saizan> btw ~/.ghc has versioned directories so there's no real reason to delete it
03:32:23 <Saizan> but it only contains the metadata
03:32:41 <donri> Saizan: this is the same ghc version though
03:32:56 <Saizan> ah
03:34:08 <donri> but installing platform will pull in some system libraries and you don't want to interleave user and system installs
03:36:15 <merijn> Is there a cleaner way to do (for example) "fromIntegral (maxBound :: CInt) < (fromIntegral (maxBound :: Int) :: Integer)"?
03:39:24 <adas> after installing the haskell-platform the docs are usally in /usr/share .. right?
03:42:24 <Saizan> ?type toInteger
03:42:24 <lambdabot> Integral a => a -> Integer
03:43:31 <merijn> Saizan: That helps a little, I guess.
03:44:02 <merijn> Maybe I should implement like "integerMaxBound :: Bounded a => a -> Integer"
04:26:59 <tortrot> Hello! I'm trying to port a small c lib to haskell and I think I am over-writing it. I pass a data structure from function to function applying transformations on one of two parts of it, right now I'm using the Data { name::type, etc} syntax which works well, but to propagate my struct I am essentially writing: fn str = Struct { a = a str, b = b str, c = c str + b str, etc} anyway to pass structure without so much duplication of
04:26:59 <tortrot>  unchanged values?
04:30:32 <merijn> tortrot: You don't need to copy all fields :)
04:30:42 <merijn> tortrot: There is update syntax for records
04:30:51 <nadirs> tortrot: Hi, I'm a very (very) beginner, so I might be wrong, but from what I've read around Lenses should help there. Have you already read about Lenses?
04:30:59 <merijn> tortrot: "fn str = str { c = c str + b }"
04:31:09 <merijn> nadirs: Lenses can help, but are overkill for his problem :)
04:31:34 <merijn> tortrot: basically, braces after an existing record create a copy of the record with all fields the same, except the ones updated
04:31:54 <tortrot> wow, that is great
04:31:57 <merijn> tortrot: So my example just now returns a copy of "str" with 'c' changed to "c str + b"
04:32:18 <tortrot> and i've heard about lenses, but I am also a beginner and still figuring out.. syntax (:
04:32:36 <merijn> tortrot: Lenses are neat, but can be "a bit" intimidating :)
04:32:53 <tortrot> thanks merijn++
04:33:03 <nadirs> I can relate..
04:33:16 <tortrot> err tried to karma.
04:33:56 <merijn> tortrot: It's actually a common pattern to have a record "defaultBlah" so that people can write their code by doing "foo defaultBlah { change one of the default here }"
04:34:36 <nadirs> merijn: kind of a prototype?
04:35:46 <tortrot> its kindof hilarious, 90% of functions so far are one line, then a few are major data passing fluff. i will hack them down
04:37:34 <merijn> tortrot: :)
04:37:49 <Moggle> Anyone know of a simple package to escape a string so it is safe for HTML?
04:37:55 <Moggle> ie. change " to &quot;
04:38:08 <merijn> nadirs: Well, take cabal for example, it has a "userHooks" record, where you can update one or multiple fields to add your own hooks to the build process
04:38:12 <Moggle> Web.Encodings looks perfect but it depends on 50 things that won't install on windows.
04:40:30 <donri> Moggle: how about blaze-html
04:41:09 <nadirs> merijn: I see :)
04:50:01 <Moggle> we'll try this blaze-html
04:50:08 <Moggle> it doesn't provide a nice easy escape function. >_>
04:51:28 <Moggle> wonderful it appears my bytestring package is broken
04:51:57 <Moggle> Prelude Text.Blaze.Html.Renderer.String Text.Blaze.Html5> renderHtml $ toHtml "\"Hello\""
04:52:02 <Moggle> if that ends up working when i figure out bytestrings
04:52:05 <Moggle> i will be rather happy
04:52:30 <ben_m> " Prelude Text.Blaze.Html.Renderer.String Text.Blaze.Html5" ... pleasant
04:53:22 <Moggle> i am nothing if not the best at using GHCI
04:53:27 <Moggle> Loading package bytestring-0.9.2.1 ... <interactive>: Unknown PEi386 section nam
04:53:29 <Moggle> e `.eh_frame' (while processing: C:\Users\Drew\AppData\Roaming\cabal\bytestring-
04:53:30 <Moggle> 0.9.2.1\ghc-7.6.3\HSbytestring-0.9.2.1.o)
04:53:34 <Moggle> if anyone has any ideas on how on earth I go about fixing this
04:53:37 <Moggle> i'd appreciate it
04:53:42 <Moggle> cabal install bytestring --reinstall
04:53:44 <Moggle> did not work as hoped.
04:55:41 <donri> Moggle: ghc-pkg list bytestring says what?
04:56:21 <Moggle> that I have 0.9.2.1 and 0.10.2.0
04:56:28 <donri> Moggle: there's your problem
04:56:36 <Moggle> how does one fix this?
04:56:47 <tortrot> multiple versions breaks it?
04:57:07 <donri> multiple bytestring versions tend to break stuff because ghc uses bytestring
04:57:13 <Moggle> lovely.
04:57:28 <Moggle> so I should just get rid of 0.9.2.1 with...
04:57:37 <Moggle> ghc-pkg uninstall bytestring-0.9.2.1 or something?
04:57:41 <donri> you should get rid of the one that didn't come with ghc
04:58:02 <donri> what version of ghc do you have?
04:58:15 <donri> did ghc-pkg show different installation directories btw?
04:58:19 <Moggle> 7.6.3
04:58:23 <Moggle> and yes it shows two different directories
04:58:31 <Moggle> one in my haskell installation dir
04:58:34 <Moggle> another in AppData
04:59:00 <donri> yes get rid of 0.9
04:59:06 <donri> ghc-pkg unregister bytestring-0.9.2.1
04:59:14 <Moggle> ah, unregister
04:59:19 <donri> if that complains, you have something built against that version
04:59:33 <donri> in which case, unregister those too and reinstall them later
04:59:34 <Moggle> ... blaze-html uses 0.9.2.1
04:59:36 <Moggle> :(
05:00:15 <donri> Moggle: you need to rebuild it against bytestring 0.10
05:00:25 <donri> Moggle: and best do cabal update first
05:00:37 <donri> Moggle: what version of blaze-html do you have?
05:00:43 <nadirs> donri: sorry to jump in, one question: does 'unregister' remove the package or does it just ignore it?
05:00:58 <Moggle> uh.
05:01:03 <Moggle> text is built against 0.9.2.1
05:01:11 <Moggle> text is another GHC core library isn't it?
05:01:22 <aristid> is upgrading bytestring without upgrading ghc ever a good idea?
05:01:24 <donri> nadirs: it does what it says :) removes the metadata from the package database but leaves the files
05:01:53 <nadirs> donri: makes sense. Thanks
05:01:59 <Moggle> i may be forced to just reinstall the entirety of GHC at this point
05:02:02 <donri> Moggle: it sounds like you have a messed up ghc install, maybe leftovers from a previous install?
05:02:08 <Moggle> yeahhhhhh who knows.
05:02:12 <Moggle> i thought i got rid of all of that.
05:03:52 <Moggle> stupid cabal not having an uninstall option
05:05:11 <Moggle> Prelude Text.Blaze.Html.Renderer.String Text.Blaze.Html5> renderHtml $ toHtml "\"Hello\""
05:05:12 <Moggle> "&quot;Hello&quot;"
05:05:14 <Moggle> :D
05:05:18 <Moggle> thank you donri for everything
05:05:36 <Moggle> today I have learned many things
05:06:06 <tortrot> blaze looks slick
05:06:24 <Moggle> I didnt even have to reinstall GHC!
05:06:28 <Moggle> i kinda removed text though.
05:06:33 <Moggle> i hope nothing relies on that.
05:07:18 <klrr> :t (<*>)
05:07:19 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:07:29 <klrr> ?src (<*>)
05:07:29 <lambdabot> Source not found. Are you on drugs?
05:07:35 <klrr> ?src <*>
05:07:36 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
05:08:07 <Moggle> klrr: <*> has no src
05:08:19 <Moggle> it's based entirely on the Applicative in question
05:08:32 <Moggle> do you have a particular instance of Applicative you want the source to <*> for?
05:09:01 <donri> @src Maybe <*>
05:09:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:10:41 <mr-> klrr: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html#Applicative
05:10:49 <klrr> mr-: thanks :)
05:11:30 <klrr> wot <*> aint defined for functors =o
05:11:41 <mauke> hence applicative functors
05:11:50 <klrr> mauke: what you mean?
05:12:02 <aristid> it's defined for Applicative.
05:12:12 <Moggle> All applicatives are functors, not all functors are applicatives!
05:12:26 <klrr> does (<*>) take a function inside a functor and applies it to a value inside a functor?
05:12:33 <aristid> no
05:12:40 <klrr> > [(+ 2)] <*> [1]
05:12:41 <lambdabot>   [3]
05:12:44 <klrr> it does :P
05:12:46 <aristid> because (<*>) is for applicative.
05:12:50 <Moggle> klrr: it depends on the functor in question.
05:13:05 <Moggle> for the list functor, yes.
05:13:17 <klrr> > Just (+2) <*> [1]
05:13:18 <lambdabot>   Couldn't match type `[]' with `Data.Maybe.Maybe'
05:13:18 <lambdabot>  Expected type: Data.Maybe...
05:13:19 <donri> @where typeclassopedia
05:13:19 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:13:23 <klrr> > Just (+2) <*> Just 3
05:13:24 <lambdabot>   Just 5
05:13:26 <klrr> :D
05:13:35 <klrr> > Just (+2) <*> Nothing
05:13:36 <lambdabot>   Nothing
05:13:54 <Moggle> It's sort of a beefed up function.
05:13:59 <Moggle> functor*
05:14:08 <yopikh> > Just (+2) <*> Just 3
05:14:09 <lambdabot>   Just 5
05:14:15 <yopikh> > Just (2) <*> Just (+3)
05:14:16 <lambdabot>   Could not deduce (GHC.Num.Num
05:14:16 <lambdabot>                      ((GHC.Integer.Type.Integ...
05:14:43 <Moggle> (+) <$> (+2) <*> (*3) $ 5
05:14:47 <klrr> > (fmap (+2) [2]) == ((+2) <$> [2])
05:14:48 <lambdabot>   True
05:14:50 <klrr> :D
05:14:52 <Moggle> > (+) <$> (+2) <*> (*3) $ 5
05:14:53 <lambdabot>   22
05:15:00 <Moggle> as you can see there
05:15:06 <klrr> WOT
05:15:10 <Moggle> it's not so simple as "applying" the function
05:15:12 <Moggle> on the left
05:15:14 <Moggle> onto the stuff on the right.
05:15:18 <klrr> :t (+) <$> (+2) <*> (*3) $ 5
05:15:19 <lambdabot> Num a => a
05:15:28 <Moggle> in this case, klrr
05:15:37 <Moggle> that takes (+2) and (*3)
05:15:39 <haasn> > liftA2 (+) (*2) (*3) 5
05:15:40 <lambdabot>   25
05:15:42 <Moggle> applies 5 to each of them
05:15:46 <klrr> Moggle: that example confuses me, the reason i wanna understand this is beacause it's used like your example in Helm source code
05:15:49 <`Jake`> @src flip
05:15:49 <lambdabot> flip f x y = f y x
05:16:03 <klrr> :t (+) <$> (+2) <*> (*3)
05:16:04 <lambdabot> Num a => a -> a
05:16:06 <Moggle> klrr: yes, applicatives get very confusing.
05:16:14 <Moggle> klrr: i recommend reading the Learn You a Haskell section on them
05:16:23 <donri> and the typeclassopedia
05:16:24 <kqr1> specifically the applicative instance of (a->) gets very confusing
05:16:25 <donri> @where typeclassopedia
05:16:25 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:16:36 <kqr1> hell, the anything instance of (a->) gets confusing
05:16:42 <kqr1> if you're not used to functions being treated that way
05:16:45 <haasn> the easiest formulation of applicatives I know is :: Applicative f => f a -> f b -> f (a, b)
05:16:56 <Moggle> klrr: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
05:17:06 <Moggle> the function example I gave is expanded on there
05:17:09 <haasn> aka liftA2 (,)
05:17:37 <Moggle> (and don't feel bad if it confuses you at all, applicatives get silly when you're using the function applicative)
05:17:54 <haasn> which for the example with (->) is :: (r -> a) -> (r -> b) -> r -> (a, b)
05:17:54 <nadirs> nice pics: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html#applicatives
05:17:54 <Moggle> ... is that even the correct terminology?
05:18:02 <klrr> Nothing <*> Just 5
05:18:06 <haasn> Moggle: the reader applicative would be a more technical term
05:18:08 <klrr> > Nothing <*> Just 5
05:18:09 <lambdabot>   Nothing
05:18:18 <klrr> > Just Nothing <*> Just 5
05:18:19 <lambdabot>   Couldn't match expected type `a0 -> b0'
05:18:19 <lambdabot>              with actual type `Data...
05:18:19 <haasn> Moggle: but ‘function applicative’ should be fine
05:18:26 <Moggle> haasn: thanks!
05:19:13 <Moggle> klrr: if they keep confusing you, i can help more!
05:20:14 <Moggle> > (\x y z -> [x,y,z]) <$> (+2) <*> (*10) <*> (+5) $ 10
05:20:15 <lambdabot>   [12,100,15]
05:20:32 <Moggle> that was what made that use of applicatives click for me.
05:20:37 <Moggle> it extends to any number of arguments.
05:20:58 <Moggle> > (\x y z a -> [x,y,z,a]) <$> (+2) <*> (*10) <*> (+5) <*> (*9) $ 10
05:20:59 <lambdabot>   [12,100,15,90]
05:21:23 <haasn> > liftA2 (+) f g x :: Expr
05:21:24 <lambdabot>   Ambiguous occurrence `x'
05:21:25 <lambdabot>  It could refer to either `L.x', defined at L.hs:1...
05:21:28 <haasn> ugh
05:21:36 <haasn> > liftA2 (+) f g a :: Expr -- I hope this at least works
05:21:37 <lambdabot>   f a + g a
05:21:45 <haasn> :t L.x
05:21:46 <lambdabot> Integer -> Integer
05:21:53 <mauke> @undefine
05:21:53 <lambdabot> Undefined.
05:21:53 <haasn> uh huh
05:21:55 <haasn> :t L.x
05:21:56 <lambdabot> Not in scope: `L.x'
05:22:04 <aristid> @undefine
05:22:04 <lambdabot> Undefined.
05:22:08 <aristid> :t x
05:22:09 <lambdabot> Expr
05:22:26 <aristid> oh, mauke had killed it already, nevermind
05:23:06 <Moggle> oh parsec, oh so elegant.
05:23:19 <Moggle> why can't other languages be as nice as haskell?
05:23:19 <haasn> the f <$> x <*> y -- pattern is easiest approached via liftA2, imo
05:24:22 <haasn> parsec's the tip of the iceberg imo
05:24:29 <kqr1> i think it's easier to either start out soft with just <$> and then extend to <*> as a way to allow multiple arguments
05:24:32 <Moggle> I've been trying to learn Haskell seriously for a few months
05:24:44 <Moggle> and I still feel like I've barely scratched the surface
05:24:50 <Moggle> I haven't even seriously looked into lens yet.
05:24:54 <kqr1> or to start out with <*> and pure and then extend <$> to just mean pure something <*>
05:25:04 <haasn> most of Haskell's diversity comes from the libraries
05:25:18 <haasn> the core language itself isn't that complex, at least not without extensions
05:25:29 <Moggle> the extensions are giving me a bit of trouble
05:25:36 <aristid> which?
05:25:39 <Moggle> RankNTypes in particular
05:25:44 <Moggle> though I think I've pretty much gotten that one down
05:25:53 <haasn> but therein lies Haskell's strength, where other languages need new language features, Haskell generally makes do with a library
05:26:06 <Moggle> yeah, haskell is rather amazing in that regard
05:26:07 <aristid> Moggle: yes i think that's one of the more difficult-to-understand ones
05:26:10 <haasn> RankNTypes just allows arguments to functions to be polymorphic
05:26:11 <mauke> ~lisp snobbery~
05:26:29 <Moggle> well
05:26:33 <kqr1> someone said about haskell libraries that "in other languages, syntax or the built-in constructs are limiting me. in haskell, it's my own brain."
05:26:34 <Moggle> I also read a paper on Free monads
05:26:36 <aristid> mauke: lisp snobbery is generic to haskell as well? oO
05:26:42 <Moggle> and how they make some regular monads more efficient
05:26:49 <Moggle> and I'm basically completely lost on those still
05:26:50 <mauke> Moggle: do you know runST, btw?
05:26:58 <haasn> kqr1: unless you're edwardk
05:27:01 <haasn> then the type system is limiting you
05:27:07 <Moggle> mauke: ST monad being a monad for nice imperative code/arrays and the like? RWH had a chapter on it
05:27:09 <kqr1> haha i guess
05:27:14 <kqr1> i was thinking of us mortals
05:27:22 <aristid> @quote oleg
05:27:22 <lambdabot> oleg says: The implementation of RSA on type level is left for future work.
05:27:30 <Moggle> I wouldn't say I'm very competent in it (haven't coded with it yet) but it wasn't that confusing
05:27:56 <aristid> :t runST
05:27:57 <lambdabot> (forall s. ST s a) -> a
05:27:57 <haasn> Moggle: Free monads themselves are just a general way to write free monads (ones that you get for free from a Functor); they don't inherently make things more or less efficient
05:28:00 <aristid> note the forall
05:28:58 <Moggle> haasn: as I recall, doing a Tree monad is 'inefficient' because it has to go through a lot of wrapping and unwrapping, and free monads fixed that issue
05:29:09 <Moggle> sort of like how difference lists solve the inefficiency of (++) in some cases.
05:29:16 <haasn> you might be thinking of the codensity transformation or other CPS tricks
05:29:20 <Moggle> yes!
05:29:23 <Moggle> that is a phrase I was thinking of
05:29:30 <haasn> not related to free monads :)
05:29:34 <Moggle> codensity transformation involved free monads I thought? no?
05:29:35 <haasn> but often used in combination
05:29:51 <Moggle> well, I appear to understand very little!
05:30:01 <Moggle> rereading the codensity transform is on my reading list
05:30:08 <Moggle> riiiight after I pick up Godel Escher Bach.
05:30:08 <CaptainK> vo sind deautchen heir?
05:30:30 <Clint> ow, my eyes
05:30:37 <haasn> Moggle: http://hackage.haskell.org/packages/archive/kan-extensions/3.1.1/doc/html/Control-Monad-Codensity.html <- it's just a CPS'd version of ‘m a’
05:30:49 <aristid> CaptainK: they exist, but you thoroughly misspelled that, also it's not a particularly relevant question.
05:31:06 <haasn> which means you can build up big chains of >>= without wrapping/unwrapping big trees in each step
05:31:22 <Moggle> haasn: interesting!
05:31:50 <Moggle> ... and edwardk is the maintainer of that package
05:32:04 <haasn> edwardk tends to be the maintainer of most CT packages on hackage
05:32:05 <Moggle> not surprised, he seems to be everywhere.
05:32:15 <haasn> Moggle: http://blog.sigfpe.com/2006/11/yoneda-lemma.html
05:32:20 <aristid> @quote edwardk
05:32:21 <lambdabot> edwardk says: {-# LANGUAGE time to pay the cutting edge typing features tax #-}
05:32:45 <mauke> youneeda lemma
05:33:03 <Moggle> haasn: I am immediately intrigued and will be reading this
05:33:42 <CaptainK> #haskell.de schlafen, ya ich muss mein deutsch ueben
05:34:14 <aristid> CaptainK: try #haskell-blah for idle banter
05:36:27 <CaptainK> dankst du, mein deutsch ist nur banter?
05:38:38 <merijn> What is peoples opinion on packaging modules, should they be stuffed in the module hierarchy or should I just define a package specific root in the module hierarchy to avoid ridiculously nested module names?
05:40:24 <Moggle> merijin: no clue! i asked that question and I didn't get any satisfying answers either way.
05:40:34 <Moggle> i personally dislike haskell's global namespace
05:40:57 <CaptainK> wie gross ist die deutsche haskell community hier?
05:41:46 <elliott> CaptainK: is there something wrong with aristid's answers?
05:42:27 <aristid> elliott: he is "offended" by me saying him speaking german is banter.
05:42:36 <CaptainK> lol
05:42:59 <aristid> CaptainK: this channel is not for learning german, sorry.
05:43:00 <elliott> well, please cut it out :p
05:43:45 <CaptainK> ok, ok  ... just seeing if any germs here :P
05:45:41 <aristid> Moggle: what do you mean with global namespace? everything is qualified with a module after all
05:46:48 <haasn> this is related to module names and categories, no?
05:46:50 <Moggle> aristid: I dislike the whole "Text.Combinators.<packagename>" business
05:47:27 <haasn> there's no way to please everybody
05:47:30 <Moggle> I prefer python's "import <packagename>" for nearly everything
05:47:39 <Moggle> but yeah it's only a mild annoyance
05:47:50 <haasn> but personally I'd be for just having package names at the top level and everything that belongs to it inside that
05:47:51 <Moggle> working in languages that aren't haskell has become slightly disgusting for me :D
05:48:13 <aristid> i would agree that the Control/Data/... hierarchy is a bit silly
05:48:19 <Moggle> which is unfortunate because I'm going to be working in Java this fall
05:48:25 <Moggle> I will have to learn to deal!
05:48:44 <haasn> Moggle: oh, thanks for reminding me, I'll probably have to write some Java at university too, ugh
05:49:05 <haasn> but from what I hear, not much
05:49:09 <Moggle> haasn: yeah, my two comp sci 'intro' classes were both java, though I'm in computer engineering and they're thankfully changing that to python
05:49:18 <Moggle> dunno what your university will be like though
05:49:20 <aristid> haasn: i suppose that depends on which university, right?:)
05:49:36 <haasn> aristid: already enrolled, semester starts this fall for me too
05:50:13 <Moggle> though personally I think ruby is far far far better than python
05:50:20 <Moggle> but that is getting just a little off topic :P
05:50:28 <Moggle> thanks for your help everyone i'm going to head out
05:50:51 <haasn> I wonder if any profs will let me hand in code that requires GHC 7.7+
05:52:22 <CaptainK> anyone have a good url describing eta reduction?
05:52:39 <haasn> \x -> f x  =>  f
05:52:42 <haasn> don't need a URL now :P
05:52:46 <CaptainK> lol\
05:53:01 <aristid> you could make a data url out of it
05:53:08 <merijn> aristid: Yeah, I was just wondering whether I should use "Network.Blah" or "System.Blah" as module name or whether I should just go with "Blah"
05:53:25 <aristid> merijn: the Network. prefix is one of the less silly ones tho
05:53:47 <merijn> aristid: Yeah, but I still end up with everything nested at least two folders
05:54:02 <merijn> i.e. "Network/Blah/actual module hierarchy here"
05:55:20 <aristid> CaptainK: data:text/plain,%5Cx-%3Ef%20x%3D%3Ef
05:55:49 <haasn> nice, firefox loads it correctly
05:56:06 <CaptainK> cool
05:56:36 <klrr> anyone know any guide or such on how to use sdl_mixer bindings? i loaded a music file into ghci and now has it with type Music but when i wanna play the music it gives me an exception that the audio device aint set?
06:04:02 <merijn> There's no Data.Binary.Put.Lazy?
06:04:21 <merijn> or Strict, whatever, I'm getting a lazy/strict mismatch in my code :\
06:05:57 <Nisstyre> merijn: have you tried using :info to figure out what's wrong?
06:07:29 <merijn> I know what's wrong, runPut returns a different bytestring from the one I use everywhere so I needto convert from lazy to strict (or the other way around, I'm never sure which order type mismatches are reported in)
06:08:05 <aristid> merijn: ghci it?:P
06:09:01 <merijn> Right, I have a lazy bytestring and need a strict one
06:10:10 <merijn> Data.ByteString.Lazy.toStrict is what I want, apparently
06:10:21 <Nisstyre> probably, yeah
06:10:23 <aristid> oh that function must be relatively new
06:10:33 <Nisstyre> why do you have a lazy bytestring in the first place?
06:10:54 <Nisstyre> I mean, why does runPut return one?
06:11:04 <aristid> Nisstyre: because that way serialising is easier?
06:11:28 <Nisstyre> easier how?
06:11:37 <aristid> Nisstyre: well you don't need to preallocate buffers
06:12:15 <aristid> merijn: it appears that Put is just a front-end to Builder these days
06:13:53 <merijn> Nisstyre: Because runPut happens to return one and I don't think there's any serious serialisation libraries other than binary?
06:14:26 <aristid> merijn: cereal isn't serious?
06:14:43 <aristid> (cereal uses strict bytestrings by default)
06:15:16 <klrr> hpaste:
06:15:28 <merijn> oh, hmm
06:15:36 <merijn> I thought they used the same Put monad
06:15:51 <Nisstyre> does that require that it use lazy bytestrings?
06:15:51 <merijn> Maybe I should switch to cereal
06:16:10 <aristid> merijn: cereal has its own Builder that supports strict bytestrings
06:16:22 <merijn> Nisstyre: That question is nonsensical
06:18:05 <aristid> merijn: oh, cereal's Builder just uses concat to get the strict bytestring out of the builder
06:18:13 <aristid> merijn: no reason to switch from cereal then
06:18:20 <aristid> *from binary
06:19:19 <aristid> merijn: can you precompute the output size? well i guess that might be premature optimization:D
06:20:40 <merijn> aristid: I'm just attaching some fixed size headers to existing bytestrings and concatting the entire stuff
06:21:56 <aristid> merijn: well if it's a small size, the Builder/Put will only return a single chunk anyways
06:22:28 <aristid> merijn: couldn't you use lazy bytestrings to avoid the actual concatenation?:D
06:25:57 <CaptainK> does lyah have a section on eta reduction?
06:26:21 <haasn> what, specifically, do you want to know about eta reduction?
06:26:34 <merijn> aristid: Maybe, I'm coding first, then I'll figure out whether lazy or strict is better later
06:28:46 <CaptainK> some examples, where to use, not possible in list comprehension or only in let
06:34:06 <CaptainK> ok, searching brings up beta reductions...interesting.
06:35:46 <CaptainK> This seems to be going towards math...better to bring my interest there.
06:36:29 <haasn> I can think of two situations in which you'd be unable to eta reduce: 1. top-level polymorphic terms without a type signature and the DMR turned on; 2. undefined vs const undefined
06:37:25 <aristid> haasn: i.e. ghc will often not do it:)
06:37:40 <haasn> well, that's an optimization issue
06:37:52 <haasn> but I mean being unable as in breaking the code
06:37:54 <CaptainK> haasn: newbie question, what is the DMR flag?
06:37:57 <haasn> ie. changing the semantics
06:38:06 <haasn> CaptainK: http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:38:15 <CaptainK> ah ok
06:38:23 <tortrot> If I am adding flags internally, what is best practice for naming / style. I am just xor and anding them and the flag name is just all lowercase- is there any more preferred method?
06:38:27 <aristid> D standing for Dreaded
06:38:37 <CaptainK> :P
06:39:04 <aristid> haasn: ghc totally needs to accept the flag in the form NoDreadedMonomorphismRestriction :D
06:39:23 <haasn> as long as you make NoDMR be an alias
06:39:26 <haasn> speaking of which
06:39:28 <aristid> (now while reviled, the monomorphism restriction actually exists for a reason :P)
06:39:29 <haasn> where is -XMPTCs?
06:39:54 <aristid> @quote tax
06:39:54 <lambdabot> geoid says: <geoid> I'm wondering why I would want to use Haskell? [...]  <zzing> geoid, it is a tool in your toolbox.  <geoid> I notice it has an efficient syntax.. but I can't think of a use for
06:39:54 <lambdabot> this tool, other than preventing my toolbox from closing :p
06:39:58 <aristid> no the other one
06:40:16 <aristid> @quote edwardk tax
06:40:17 <lambdabot> edwardk says: says: i used to be a huge proponent of unicode syntax everywhere, then i used  agda ;)
06:40:22 <aristid> argh
06:40:36 <paolino> hello everyone, I'm trying the lens package. I want to insert a filter in a lens as a Setter. testinput test def l x = lens (\s -> s ^. l) (\s i -> if test i then l .~ s $ i else l .~ s $ def)
06:41:25 <paolino> but ghc says l is a Getter not an ASetter, well I understand not both
06:41:55 <haasn> careful with the lens laws there
06:42:38 <paolino> before breaking them I have to make it compile
06:42:46 <haasn> actually, I'm quite certain that's illegal
06:43:02 <haasn> but as for your question, l needs to be a lens
06:43:13 <haasn> not a Getter
06:43:27 <haasn> (the resulting type will be rank-2)
06:43:52 <paolino> well I put no signature, that is the problem ?
06:43:58 <haasn> ghc can't infer rank-2 types
06:44:17 <haasn> actually hang on
06:44:19 <haasn> not sure if that's still the case
06:45:07 <haasn> yes, it is still the case
06:45:32 <merijn> haasn: Rank2Type inference is undecidable :)
06:45:38 <haasn> view requires f ~ Accessor, and over requires f ~ Mutator
06:45:53 <merijn> haasn: So it's theoretically impossible to make ghc infer them :)
06:46:13 <haasn> merijn: I thought this was just true for RankN
06:46:29 <haasn> or is it due to fancy GHC extensions?
06:46:58 <merijn> haasn: It true for RankN for any N greater or equal than 2 :p
06:48:41 <Zenol> Hum, guys, do you know how to apply HXT's getText in all sub not to create one string. I'm using >>> (deep getText && gettAttrValue "href") but it create as many tuples as getText is aplied. I need come "concat" or thing like that. It should exist but I'm playing with arrow without understanding them :p
06:49:00 <Zenol> -come + some
06:49:25 <donri> Zenol: tuple, you sure?
06:49:26 <haasn> hmm http://stackoverflow.com/questions/15020428/are-there-any-advantages-of-using-rank2types-in-favor-of-rankntypes
06:49:30 <donri> Zenol: hxt is a list arrow
06:49:50 <Zenol> donri &&& create a tuple, so it's a list of tuples
06:50:01 <donri> oh &&&
06:50:09 <Zenol> The thing is that deep isn't exactly what I'm looking for
06:50:17 <donri> Zenol: so what do you want exactly
06:50:57 <aristid> haasn: hah
06:51:04 <Zenol> Instead of [("some", "http:..."), ("thing", "http:...")] (occuring from deep) I would like [("some thing", "http:...")]
06:51:33 <paolino> haasn, I'm not able to write the signature
06:52:20 <donri> Zenol: are you sure? :D
06:52:33 <donri> seems odd to concat URLs
06:53:00 <Zenol> donri> Not url. It's <a href="blabla"> some <b> stuff</b> <font> here</font></a>
06:53:32 <Zenol> donri> I would like to throw away all those <b>, <font> and so.
06:54:43 <donri> Zenol: listA (deep getText) is a start
06:55:50 <donri> Zenol: >>> arr concat, maybe
06:57:26 <paolino> haasn, (a -> Bool) -> a -> Lens a a a a -> Lens a a a a     -- compiles
06:57:59 <haasn> paolino: (s -> Bool) -> s -> Lens s t a b -> Lens s t a b
06:58:13 <haasn> you also seem to have swapped the parameters to your lambda earlier
06:58:48 <haasn> either way, the resulting lens is not necessarily legal
06:59:22 <haasn> for every valid lens l the following must hold: over l f . over l g = over l (f . g)
06:59:49 <haasn> if ‘g’ modifies your structure in such a way that ‘test’ fails; and ‘f’ distinguishes between ‘def’ and the old value; then this is violated
06:59:53 <Zenol> donri> arr concat . listA ? :/
07:00:08 <donri> Zenol: yes
07:00:14 <Zenol> donri> listA produce s (["some", "thing"], "http:...")
07:00:26 <Zenol> donri> But type checking don't like arr concat x)
07:00:30 <donri> Zenol: it's for getText, not &&&
07:00:42 <donri> :t arr concat
07:00:43 <lambdabot> Arrow a => a [[a1]] [a1]
07:01:01 <Zenol> (arr concat . listA $ deep getText) &&& ...
07:01:24 <Zenol> hum, arrow, so it's not .
07:01:33 <donri> >>> (arr concat . listA (deep getText) &&& gettAttrValue "href")
07:01:45 <donri> you want . from Control.Category
07:01:53 <donri> or just use <<< (or >>> and reverse the sides)
07:02:11 <donri> also, probably easier in arrow notation
07:02:19 <donri> although it's good to know how to write it by hand :)
07:02:39 <Zenol> hum, arrow, so it's not .
07:02:42 <Zenol> sorry
07:02:58 <Zenol> It compile with arr concat <<< listA (deep getText)
07:05:00 <Zenol> donri> works well :) Thanks
07:05:03 <donri> Zenol: and is it doing what you want?
07:05:04 <donri> cool :)
07:05:05 <donri> np
07:06:37 <haasn> donri: for the longest time ever I always thought it was easier to write things by hand than to use arrow notation
07:07:10 <zvrba> hm
07:07:28 <donri> haasn: might depend on the arrow and what the code does
07:07:28 <zvrba> how can I find out what does ++ do operationally. for example, let z = [1..3] ++ undefined
07:07:42 <zvrba> take 3 z returns [1..3], so it's lazy, as expected. so far so good.
07:08:09 <donri> haasn: arrow notation is probably nicer for pointful style
07:08:13 <zvrba> but take 4 z will then evaluate ++. will ++ "know" where the first list ended, or will it traverse [1..3] once more?
07:08:19 <donri> just like with do notation
07:09:33 <donri> zvrba: ++ makes a new list 1 : 2 : 3 : undefined : []
07:09:59 <donri> zvrba: take 3 makes a new list 1 : 2 : 3 : []
07:10:22 <zvrba> what does "new list" mean when you have no means to test for identity (i.e., being stored at the same address)
07:10:39 <zvrba> all lists [1..3] are equal.
07:10:52 <zvrba> but you don't know whether they have the same identity.
07:10:56 <haasn> donri: yeah, but you have to understand how it works first
07:11:05 <haasn> arrow notation is probably nicer for FRP
07:11:22 <donri> zvrba: i suppose more importantly, a list is just a chain of items linked with (:)
07:13:27 <haasn> zvrba: (++) just keeps lazily producing cons cells until it reaches [], and when it does, it returns the right hand side
07:13:55 <zvrba> haasn: ! OK, that answers my question :)
07:14:06 <haasn> @src (++)
07:14:06 <lambdabot> []     ++ ys = ys
07:14:06 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:14:06 <lambdabot> -- OR
07:14:06 <lambdabot> xs ++ ys = foldr (:) ys xs
07:14:40 <zvrba> cool :)
07:14:54 <donri> a list is either empty [] or something linked to another list with (:)
07:16:10 <zvrba> but a LAZY list is also a control structure.
07:16:44 <zvrba> haasn: it's not that efficiency mattered in what I'm doing now, but it's good to know that detail :)
07:17:01 <donri> a finite list is just something that links the empty list at some point
07:17:50 <haasn> I'm quite sure (++) is basically the only way to append two lists, as far as efficiency is concerned
07:18:51 <donri> if you're talking about the list type [a] then yes, but there are other sequential data structures that allow for more efficient concatenation
07:19:03 <zvrba> haasn: of course. I got momentarily stunned trying to figure out how ++ would remember the current place in the list. seeing the definition made it clear :)
07:20:01 <zvrba> donri: ++ visits each element of the source lists exactly once. how can you get more efficient than that?
07:20:44 <donri> zvrba: by just linking the two lists instead of traversing them to create a third, for one
07:20:55 <donri> @hackage dlist
07:20:55 <lambdabot> http://hackage.haskell.org/package/dlist
07:22:00 <haasn> dlist basically reduces redundancy
07:22:09 <donri> for bytes and text there's also the Builder types
07:22:18 <haasn> but you still have to traverse each cons cell once
07:22:20 <haasn> ultimately
07:22:21 <zvrba> but i'm traversing the whole result of ++ anyway.
07:22:30 <haasn> dlist is just there to avoid redundancy in (xs ++ ys) ++ zs
07:22:34 <zvrba> so no need to compliate with nonstandard lists.
07:22:40 <haasn> by rearranging it to xs ++ (ys ++ zs)
07:22:50 <donri> zvrba: so then you're traversing multiple times
07:22:55 <zvrba> ?
07:22:59 <zvrba> nope
07:23:26 <zvrba> the lazy suspension in ++ remembers where to continue.
07:23:29 <haasn> donri: modulo fusion
07:23:44 <zvrba> @src ++
07:23:44 <lambdabot> []     ++ ys = ys
07:23:44 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:23:44 <lambdabot> -- OR
07:23:44 <lambdabot> xs ++ ys = foldr (:) ys xs
07:24:31 <zvrba> in x : (xs ++ ys), the x part exists, xs is stripped of the head, and next evaluation of the tail will do the same again. no multiple traversals.
07:25:26 <zvrba> or, more clearly, (xs++ys) is the rest of the computation where the first list has been shortened by 1 element.
07:26:08 <donri> could be true, depends on what exactly you're doing
07:26:26 <zvrba> ...
07:26:33 <zvrba> traversing the result of x ++ y
07:26:35 <applicative> dlists dont have any advantage for just one (xs ++ ys)
07:26:48 <applicative> if I understand
07:26:55 <donri> yes, that is my understanding as well
07:27:03 <applicative> of if all uses are associated perfectly
07:27:17 <applicative> xs ++ (ys ++ (zs ++..)
07:27:27 <frx> I believe dlist wouldn't have to traverse xs to append ys to it
07:27:46 <zvrba> frx: perhaps not, but I'm traversing the whole of the result anyway. so no advantage of using dlists.
07:27:55 <applicative> I have trouble distinguishing left and right, but,
07:28:02 <applicative> the killer app of dlist is
07:28:11 <zvrba> append element to the end?
07:28:17 <applicative> ((((xs ++ ys) ++ zs ) ++ ...)
07:28:53 <Cale> The trick behind the DList library is simple enough that I pretty much never use that package.
07:28:59 <applicative> yes
07:29:11 <donri> i wasn't really suggesting using it :)
07:29:17 <Cale> You just replace [a] with [a] -> [a], and [] with id, and [x] with (x:), and (++) with (.)
07:29:25 <applicative> the same trick is used in bytestring-builder but is incredibly complicated in detail
07:30:25 <zvrba> hm
07:30:27 <donri> the answer to the question "how can you get more efficient than O(n)" is "O(<n)", is the point :)
07:30:28 <haasn> zvrba: compare “sum (xs ++ ys)” vs “sum xs + sum ys”
07:31:11 <haasn> in the first example, (++) goes through ‘xs’ and returns a ‘new’ cons cell for each of its elements; which then ‘sum’ goes through again
07:31:15 <Cale> I've used this trick in a first attempt to improve the performance of some ByteString code before I'd really thought too hard about what was making it perform poorly (but it did take a large data file, chop it apart and rearrange the pieces while generating a sort of index)
07:31:59 <Cale> and the performance of that program went from taking half an hour and using gigabytes of memory to being done in about a minute and using about a dozen megabytes :)
07:32:05 <donri> the bytestring Builder is more than just dlist though IIUC; in particular it's doing some tricks to make sure the final write use a single system call, something like that?
07:32:20 <applicative> donri its way more complicated
07:32:24 <donri> heh
07:32:26 <applicative> I mean, yes
07:32:51 <zvrba> ok, another Q: I have something like data V = X Int Int | Y Int Int. Is it possible to write a _single_ pattern like (_ 3 _) that would match both X'es and Y'es where the 1st component is 3?
07:32:54 <applicative> i was thinking thought that something like the dlist idea was part of oit
07:33:10 <zvrba> or filter predicate?
07:33:29 <haasn> frx: it does, when you evaluate it. fromList = (++)
07:33:49 <geekosaur> zvrba, nope
07:33:49 <haasn> frx: so even though append xs ys = xs . ys -- O(1); when you run it through toList again, you get (xs++) . (ys++) $ []
07:34:09 <applicative> type V = (Bool, Int , Int)
07:34:13 <zvrba> geekosaur: no structural pattern matching even over the same datatype? :/
07:34:22 <zvrba> oh well
07:34:27 <zvrba> applicative: hm?
07:34:29 <haasn> Cale: I use it for the Monoid instance, mainly
07:34:33 <luite> donri: the Builder also tries to copy stuffs to same-sized buffers to avoid memory fragmentation
07:34:34 <applicative> zvrba: if youre going to do it, you can redesign the type
07:34:35 <haasn> Cale: I often find myself using Writer (DList String)
07:34:43 <luite> donri: for small bytestrings
07:34:44 <zvrba> applicative: redesign? how?
07:34:46 <frx> haasn calling toList wasn't part of the argument
07:34:48 <geekosaur> applicative is suggesting moving the constructor into a Bool element so you can match against it
07:35:00 <zvrba> ah
07:35:11 <WarzoneCommand> question: I am building some multi-threaded program that reacts on events. For one of these events the handler would be something like: handler b = if b then removeFile foo else do-nothing
07:35:17 <WarzoneCommand> is there a nice way of doing that atomically?
07:35:19 <zvrba> geekosaur: meh. don't like that.
07:35:20 <applicative> or make your own type with X | Y
07:35:43 <zvrba> hm, that would need a lot of refactoring.
07:35:45 <WarzoneCommand> the answer likein http://stackoverflow.com/questions/8502201/remove-file-if-it-exists-in-haskell seems nice. But I'm not sure if it is applicable in this case
07:35:50 <zvrba> I'll just do it the simple, verbose way now.
07:35:56 <donri> zvrba: you could abstract it with view patterns or maybe generics
07:35:57 <haasn> zvrba: you could do something like data V = X { a :: Int, b :: Int} | Y { a :: Int, b :: Int} and then use f x | a x == 3
07:36:12 <applicative> zvrba: you can define a lens as well, if you're forever doing it
07:36:13 <zvrba> I'm solving the problem bottom-up so I can't know beforehand what will be needed.
07:36:26 <haasn> or just write your own function for ‘a’
07:36:48 <zvrba> haasn: oh, so records belogning to the same type can have same field names?
07:36:52 <zvrba> that was useful :-)
07:36:59 <applicative> wait no
07:37:11 <donri> zvrba: if the Ints in that datatype mean the same thing, it would probably be a better design to abstract out X and Y
07:37:30 <haasn> zvrba: yes, but they must have the same type
07:37:33 <zvrba> well, the real type is Int (Int, Int)
07:37:41 <donri> then you have (V,Int,Int) or make another data type for it
07:37:43 <zvrba> it represents either a horizontal or vertical chord
07:37:59 <zvrba> where the 1st int is the constant coordinate, the tuple is the rang across the "other" axis
07:38:28 --- mode: ChanServ set +o elliott
07:38:30 <zvrba> so I have VC Int (Int,Int) | HC Int (Int,Int) [vertical or horizontal chord]
07:38:40 --- mode: elliott set +b kizzx2!*@*$##fixyourconnection
07:38:41 <haasn> zvrba: you could have data Direction = H | V
07:38:44 --- mode: elliott set -o elliott
07:38:56 <haasn> and then use (Direction, Int, Range) or something (with Range = (Int, Int))
07:39:10 <zvrba> haasn: right. yeah, that may be more practical for pattern matching.
07:39:12 <haasn> (might as well package that whole thing into a newtype then)
07:39:19 <haasn> data type*
07:39:47 <haasn> data Coord = Coord Direction Int (Int, Int) -- f (Coord _ _ 3 _) = ...; g (Coord X ...
07:39:50 <zvrba> ok, thanks for the suggestions :-)
07:45:31 <merijn> WarzoneCommand: Which part of that did you want to do atomically?
07:46:09 <WarzoneCommand> the 'check and remove part'
07:46:35 <merijn> You can't, unless you happen to have a transactional filesystem
07:46:48 <veryrandomname> I have a newtype Animation = Animation [Frame], how could I prevent the user from creating empty lists?
07:46:49 <applicative> Oh I just noticed WarzoneCommand 's question, grr
07:47:00 <merijn> And even if you had a transactional filesystem, the posix standard doesn't have functions to interact with it
07:47:05 <WarzoneCommand> :(
07:47:15 <haasn> applicative: same!
07:47:33 <klrr> what does GrabMode mean http://hackage.haskell.org/packages/archive/SDL/0.6.5/doc/html/Graphics-UI-SDL-WindowManagement.html ?
07:47:34 <merijn> WarzoneCommand: You should follow the advice in the answer to that SO question
07:48:11 <WarzoneCommand> well
07:48:17 <geekosaur> klrr, see grabInput
07:48:23 <WarzoneCommand> for removal that works I guess
07:48:29 <WarzoneCommand> but not for things like move
07:48:37 <merijn> WarzoneCommand: Why not?
07:48:41 <applicative> veryrandomname: ther standard procedure involves hiding the Animation constructor
07:49:09 <geekosaur> implementation in different environments differs, but the "grab" terminology is taken from X11 where they are referring specifically to X11's keyboard grab
07:49:39 <geekosaur> (there is also poiinter grab which constrains only the mouse, and server grab which is used by things like xscreensaver)
07:49:41 <WarzoneCommand> hmm maybe move is a bad example
07:50:19 <applicative> veryrandomname: note that the constructors are not exported by http://hackage.haskell.org/packages/archive/NonEmptyList/0.0.9/doc/html/src/Data-List-NonEmpty.html#NonEmpty only 'accessors' etc
07:50:36 <merijn> WarzoneCommand: Also, this is highly OS dependent, are you on *nix, windows or both?
07:50:49 <applicative> veryrandomname: the type is then actually Animation Frame [Frame] in this case
07:50:58 <WarzoneCommand> hmm let me give a bit more details
07:50:59 <klrr> geekosaur: okey
07:51:02 <WarzoneCommand> of the problem
07:51:06 <WarzoneCommand> (on unix by the way)
07:51:07 <veryrandomname> applicative: I'm creating the Animation data from a list and since the user could supply a empty list I don't know what to do
07:51:14 <applicative> veryrandomname: wait I take all that back, not the kind of game Iw was looking for
07:51:18 <klrr> geekosaur: so if in fullscreen for example then GrabOn should be enabled?
07:51:40 <veryrandomname> applicative: why? whats wrong?
07:51:41 <applicative> veryrandomname: I mean the nonemtpy list package
07:51:45 <WarzoneCommand> so the handlers handle different types of events. Some events may be copies: i.e. copy a file to some other location (replacing the already existing file if one)
07:51:49 <WarzoneCommand> others can do removes
07:52:00 <veryrandomname> applicative: oh. I thought about using it. should I not?
07:52:20 <geekosaur> probably? but it depends on context.
07:52:28 <WarzoneCommand> each of those events carries a file identifyier of the file it wants to remove (i.e. a SHA1 hash or so)
07:53:09 <applicative> veryrandomname: no, it's just that there are various procedures for this kind of thing, but I started describing one of them, using a package that was doing another of them...
07:53:24 <geekosaur> many full screen games use it to make sure nothing else can use keys the game wants to use (e.g. F1 may be intercepted by the system to launch a help window normally, GrabOn prevents this)
07:53:30 <veryrandomname> applicative: the thing is I'm doing something like createAnimation :: [Frame] -> Animation, I don't know how to handle a empty list as input
07:54:24 <applicative> veryrandomname  createAnimation :: Frame -> [Frame] -> Animation
07:54:29 <radish> not sure if anyone tried to help me or not but my connection went down again lol. sorry. :(
07:54:29 <WarzoneCommand> now what I want to avoid is that some copy handler is handled in between the check and the delete
07:54:48 <geekosaur> it's also used by things like remote desktop programs and virtual machine managers to route all keys to the remote / virtual machine
07:54:50 <applicative> veryrandomname: is Frame a complicated type?
07:54:59 <merijn> WarzoneCommand: Right, on linux you probably want to use flock
07:55:02 <veryrandomname> applicative: thats pretty ugly :/ I think non-empty would be better
07:55:49 <WarzoneCommand> i.e. two parallel handlers, one copy one delete of file A. The first handler thinks the file signature is X, the second handler thinks it is Y. So first the copy handler is executed, which replaces the file (thus changingg it sig) and then the delete removes this newer file
07:55:49 <applicative> veryrandomname: for NonEmpty, createAnimation would basically be the concstructor for Animation = Animation Frame [Frame]
07:55:50 <veryrandomname> applicative: its a bit complicated. I don't think I could do an empty frame or something
07:56:05 <applicative> ah, thats what I was wondering
07:56:43 <WarzoneCommand> ah that looks good merijn
07:56:48 <merijn> WarzoneCommand: flock doesn't actually stop anyone from moving/deleting a file, but it provides and interface that lets you atomically "lock" a file and check whether a file is locked
07:56:52 <veryrandomname> applicative: I think the real bottom line is, it should be impossible to create an animation without frames. so non-empty is the most straightforward one, right?
07:57:08 <merijn> WarzoneCommand: If all your handlers properly lock and check using flock, then you can guarantee that your handlers won't interfere
07:57:28 <merijn> WarzoneCommand: Someone else might still remove/copy files, but that's probably not something you are worrying about?
07:57:36 <WarzoneCommand> no indeed
07:57:58 <WarzoneCommand> ty :)
07:58:00 <merijn> There seems to be an flock package on Hackage already
07:58:47 <WarzoneCommand> indeed
08:00:37 <merijn> Is there a "reasonable block size" defined somewhere in System.IO/Data.ByteString for use with hGetSome?
08:06:10 <WarzoneCommand> merijn: do you know what the meaning of a 'non blocking flock' is exaclty ?
08:06:23 <WarzoneCommand> i.e. what is the expected behaviour
08:06:33 <WarzoneCommand> will it just fail
08:07:45 <merijn> WarzoneCommand: Might want to consult "man flock"
08:08:20 <WarzoneCommand> I did, but is is kind of vague on the non-blocking part
08:08:23 <geekosaur> the underlying syscall would return -1 with errno EAGAIN (formerly EWOULDBLOCK). I don't know how Haskell bindings expose this
08:08:35 <WarzoneCommand> I guess I can just use block
08:09:12 <merijn> geekosaur: on darwin (and maybe BSD?) it's still EWOULDBLOCK
08:09:58 <geekosaur> not really. /usr/include/sys/errno.h:#define	EWOULDBLOCK	EAGAIN		/* Operation would block */
08:09:59 <merijn> WarzoneCommand: I suspect NoBlock throws an exception
08:10:27 <geekosaur> it's backward compat with 4.2BSD
08:13:12 <WarzoneCommand> I'll just use Block. When the process than would obtain the lock it will simply fail the check. That should work :)
08:13:18 <WarzoneCommand> thanks again though :)
08:32:12 <merijn> hmm, I guess I will just have to use join if I want "Monad m => m (a -> m b) -> m a -> m b"?
08:37:09 <aristid> :t \x a -> do i <- x; v <- a; return i v
08:37:10 <lambdabot> Monad m => m (m b) -> m t -> m b
08:37:21 <aristid> :t \x a -> do i <- x; v <- a; return (i v)
08:37:21 <lambdabot> Monad m => m (t -> b) -> m t -> m b
08:37:39 <aristid> merijn: i don't think you _have_ to use join ;)
08:38:28 <ion> :t \mf ma -> do f <- mf; ma >>= f
08:38:28 <lambdabot> Monad m => m (a -> m b) -> m a -> m b
08:38:41 <aristid> ah yeah my version was wrong, but still
08:38:42 <merijn> I'm just gonna define an operator for it
08:39:23 <aristid> @. pl undo \mf ma -> do f <- mf; ma >>= f
08:39:23 <lambdabot> (. (>>=)) . (>>=)
08:39:33 <aristid> the shifty eyes operator:D
08:39:36 <merijn> That was you could write "foo <$> bar <*> baz <%> xyzzy" instead of "join $ foo <$> bar <*> baz <*> xyzzy"
08:39:43 <merijn> s/was/way
08:52:34 <elliott> merijn: (<%>) is just (=<<).
08:52:44 <elliott> but I dislike it because it feels like it should go on the first operator. :(
08:54:43 <merijn> elliott: No, it's not
08:54:55 <merijn> :t (=<<)
08:54:56 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:55:11 <merijn> I'm talking about "Monad m => m (a -> m b) -> m a -> m b"
08:56:48 <elliott> well, ok, I was going by your join example.
08:57:23 <applicative> he wanted to end the f <$> mx <*> my ... series with a join
08:57:48 <merijn> elliott: =<< doesn't work in my join example either
08:57:59 <elliott> hmm.
08:58:01 <applicative> but isn't it \a b -> join (a <*> b)
08:58:10 <merijn> applicative: Pretty much
08:58:36 <elliott> right, okay.
08:59:42 <bscarlet> :t ((.).(.)) join (<*>)
08:59:43 <lambdabot> (Monad m, Applicative m) => m (a1 -> m a) -> m a1 -> m a
09:00:18 <merijn> Are there any problems with using Data.ByteString.Lazy.hGetContents in long lived processes? I'm pretty sure the problems with lazy IO don't apply, but I'm not positive I understand/know all the caveats
09:01:48 <merijn> oh, hmm
09:05:50 * applicative refuses to accept an 'om' in Control.Monad without a 'nom'
09:14:52 <merijn> GHC depends on binary?!
09:15:19 <rul> Hi all. Shouldn't  (decode . encode $ "jamn")  return "jamn" instead of  "jam\243n", where decode and encode are from Codec.Binary.UTF8.String?
09:15:26 <merijn> ghc-pkg: unregistering bin-package-db would break the following packages:
09:15:26 <merijn> ghc-7.6.3 (use --force to override)
09:15:42 <Hafydd> > "jam\243n"
09:15:43 <lambdabot>   "jam\243n"
09:15:49 <merijn> Will things break if I just install a new binary?
09:16:24 <Hafydd> > "jamón"
09:16:25 <lambdabot>   "jam\243n"
09:16:36 <Hafydd> 'tis the same value.
09:16:49 <applicative> rul: aren't they the same,
09:16:52 <rul> ("jam\243n") ==  "jamn" returns True
09:16:54 <rul> yes
09:17:22 <rul> I want to know why it does not show the return value encoded
09:17:40 <Hafydd> How are you showing it?
09:17:48 <rul> I would like to show "jamn" instead of  "jam\243n"
09:17:49 <applicative> rul: if it's shown as a haskell string, it will have \243, if it's putStrLn's it'll have ó
09:18:27 <rul> applicative: oh, I see... that was I was looking for. Thanks!
09:18:51 <applicative> > text "jam\243n"
09:18:52 <lambdabot>   jamón
09:18:53 <Hafydd> ó_ó
09:20:27 <tortrot> I'm trying to figure out a way to pipe left hand values as the first argument of the proceeding function, I don't know what I should be looking for
09:21:14 <Hafydd> > "hello" & reverse
09:21:15 <lambdabot>   Not in scope: `&'
09:22:27 <int-e> @where quine
09:22:27 <lambdabot> ap (++) show "ap (++) show "
09:23:33 <Hafydd> > let (&) = flip id in "hello" & reverse -- I thought there was something like that.
09:23:34 <lambdabot>   "olleh"
09:24:18 <Hafydd> Anyway, what do you actualyl mean, tortrot?
09:26:02 <tortrot> Hayfydd: sorry if I wasn't clear; all functions return the same type except possibly the last one, so instead of doing something like (add (add (basefn) "hi") "hello") I could write something that works like base | add "hi" | add "hello"
09:26:41 <tortrot> I initially used infix operators, but some of my functions only take one argument so it broke
09:27:36 <tortrot> whereas basefn :: Base && add :: Base -> String -> Base
09:30:34 <Hafydd> @pl flip id
09:30:34 <lambdabot> flip id
09:30:50 <merijn> tortrot: Looks like a fold to me
09:30:53 <merijn> :t foldl
09:30:53 <lambdabot> (a -> b -> a) -> a -> [b] -> a
09:31:22 <Hafydd> So you were doing this before, right?
09:31:24 <Hafydd> > let (&) = flip id in "hello" & (++" ") & (++"world")
09:31:25 <lambdabot>   "hello world"
09:31:38 <Hafydd> And how does it break in this case?
09:32:13 <tortrot> no I was basically just doing     basefn `add` "hi" `add` "hello"
09:32:49 <tortrot> merijn: I didn't know foldl was that general
09:33:14 <tortrot> thats crazy, I'm trying both
09:38:25 <merijn> tortrot: :)
09:38:26 <tortrot> Hayfydd: I was getting parse error on input `` when I used a single arg one like this: basefn `start` `add` "hi"
09:39:19 <merijn> tortrot: You could change that to "foldl add basefn ["hi", "hello"]"
09:39:21 <Hafydd> I see; well, an infix operator by nature takes two arguments, so that approach fails for that reason.
09:39:29 <merijn> Hafydd: two are more!
09:39:32 <merijn> eh
09:39:34 <merijn> s/are/or
09:39:52 <Hafydd> Yes.
09:40:07 <tortrot> Hmm, I guess I assumed oddly because of the - operator
09:40:12 <merijn> > let (!!!) x y z = if z then x else y in 1 !!! 2 $ False
09:40:13 <lambdabot>   2
09:40:18 <merijn> > let (!!!) x y z = if z then x else y in 1 !!! 2 $ True
09:40:19 <lambdabot>   1
09:41:18 <tortrot> merijn: I don't think I can use a fold for this because I have more functions that are similar to add (many just call it) but I want them to be unified in stringing together
09:41:50 <merijn> tortrot: You could also have a list of function and compose those
09:42:22 <merijn> > foldl (.) id [(+2), (*3), (+10)] $ 1
09:42:23 <lambdabot>   35
09:43:13 <zebr> hey all. is there any shorthand for 'return (x >>= id)'?
09:43:54 <shachaf> join x = x >>= id
09:44:15 <elliott> zebr: x
09:44:23 <shachaf> elliott: return . join is not id
09:44:29 <elliott> oh.
09:44:32 <elliott> right.
09:44:35 <elliott> sorry.
09:44:41 <shachaf> It's a kind of weird thing to be doing, though.
09:45:04 <zebr> agreed. but it's apparently necessary. :p thanks, i'll use return.join
09:50:31 <hamid> Is this okay to use http://hackage.haskell.org/package/plugins ?
09:51:35 <tortrot> merijn: huh, I'm not sure, having trouble figuring it out. Perhaps I should get some rest and look at it tomorrow. A lot of information for one day! (:
09:52:08 <tortrot> merijn: huh, I'm not sure, having trouble figuring it out. Perhaps I should get some rest and look at it tomorrow. A lot of information for one day! (:
09:52:24 <bscarlet> hamid: in what context?
09:52:47 <Hafydd> :t flip id
09:52:48 <lambdabot> b -> (b -> c) -> c
09:52:51 <geekosaur> hamid: doesn't look like it's been updated recently and it's rather tightly tied to ghc internals; it may well not work right with recent ghc
09:52:54 <Hafydd> @hoogle b -> (b -> c) -> c
09:52:54 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
09:52:54 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
09:52:54 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
09:53:18 <tortrot> :Hayfydd thanks for the flip id, I have that snippet saved to play with later. Cheers and good day to you both, and all!
09:53:33 <Hafydd> I have a feeling it's defined in some library alrady.
09:54:38 <hamid> geekosaur, bscarlet, I just want to write a plugin based application.
09:55:04 <hamid> I didn't find anything else
09:55:48 <geekosaur> depending on what exactly you need, http://hackage.haskell.org/package/hint
09:56:21 <geekosaur> actually it looks like plugins has been shown to at least compile on ghc 7.6, so you can try it
09:57:21 <hamid> geekosaur, thank you :)
09:58:00 <applicative> it has a decent number of reverse dependencies http://packdeps.haskellers.com/reverse/plugins
09:58:42 <applicative> I think it would be used more if dons were around to advertise and explain it still
09:59:23 <Hafydd> tortrot, by the way, is there a particular reason you need to compute left-to-right?
09:59:37 <geekosaur> or not; any remotely type safe plugin setup for haskell is pretty much guaranteed to be complex
10:00:18 <Hafydd> > (++[1]) $ (++[2]) $ (++[3]) $ [0] -- is less hassle
10:00:19 <lambdabot>   [0,3,2,1]
10:02:24 <applicative> geekosaur: yes, I just dimly remember there was more enthusiasm around this sort of thing a couple of years ago.
10:03:03 <tortrot> Hayfydd: well, my example was quite small. Basically I am chaining a bunch of transformations together to build something up. It seems a lot clearer to write it that way.
10:03:15 <geekosaur> I recall there being a lot of interest in it.. usually evaporating when people realized just how much of an unfixable PITA plugins is
10:03:25 <geekosaur> (even with dons' active help)
10:04:17 <geekosaur> for one thing, plugins used to break completely with every new ghc release, although these days (a) it uses ghc to parse interface files for it (b) and the interface files are not changing as much between versions
10:05:16 <applicative> geekosaur: I see, so the waning of enthusiasm was basically sensible
10:05:23 <geekosaur> yep
10:06:30 <tortrot> Hayfydd: basically it is a regex builder and has transformations in a way that seems much more well suited for sort of natural language expression rather than nesting which detracts from its readability
10:08:14 <merijn> Is it weird to use attoparsec to provide an implementation of Data.Binary's typeclass?
10:08:27 <merijn> Wait, I guess that's not even possible
10:08:31 <merijn> ugh
10:08:57 <merijn> Is there no "encode only" typeclass/library for binary data?
10:10:33 <Hafydd> > const [] >>= const.(++"a") >>= const.(++"b") >>= const.(++"c") $ () -- using the (() ->) Monad.
10:10:34 <lambdabot>   "abc"
10:12:08 <applicative> shouldn't it be more like
10:12:51 <applicative> > (const.(++"a") >=> const.(++"b") >=> const.(++'c')) [] ()
10:12:52 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
10:12:52 <lambdabot>              with actual ty...
10:12:55 <applicative> woops
10:13:42 <applicative> hm whats my mistake
10:14:07 <applicative> oh obvious
10:14:14 <applicative> > (const.(++"a") >=> const.(++"b") >=> const.(++"c")) [] ()
10:14:15 <lambdabot>   "abc"
10:14:45 <Hafydd> Yes, right, because those are actually composable pipelines.
10:19:13 <tulcod> in foreign ccalls, which arguments and return types are acceptable, exactly?
10:19:30 <tulcod> can I make an arbitrary type acceptable using some typeclass?
10:20:28 <geekosaur> you can pass around opaque pointers (StablePtr-s, so the gc doesn't move them out from under the C code) to haskell types; otherwise, it has to be some type that C understands. which means *not* most native Haskell types
10:21:42 <tulcod> geekosaur: what about newtype?
10:22:05 <tulcod> i mean, what's considered a type that C understansd?
10:22:16 <geekosaur> the question is disordered...
10:22:39 <geekosaur> tulcod, C is stupid. it understands its types, which are more or less raw machine words of various kinds
10:22:57 <geekosaur> *every* Haskell type has at least one constructor associated with it (newtype-s don
10:23:15 <geekosaur> t *add* constructors, but they also don't remove the original, so they are no different from the standpoint of C)
10:23:41 <Demos> c is not really as strongly typed as we would like, the set of programs that are correct and fail the typechecker seems to be all interesting programs
10:23:53 <donri> isn't it simply "anything Storable"?
10:24:00 <geekosaur> C has no idea what to do with a constructor. it has no clue whatsoever about garbage collection. it can't deal sensibly with types that have multiple constructors
10:24:03 <tulcod> donri: that would be my guess
10:24:17 <Sonarpulse> rust shall replace C and C++, ideally
10:24:32 <geekosaur> Storable can be thought of as a marshaling protocol to produce something C might be able to cope with
10:24:36 <tulcod> geekosaur: so a newtype is acceptable if it newtypes something that already was acceptable
10:24:42 <geekosaur> yes
10:24:44 <tulcod> geekosaur: and a data type is never acceptable?
10:24:56 <Sonarpulse> I got some FFI concurrency questions. Read a bunch but still a bit confused
10:25:10 <geekosaur> ecept insofar as if you don't derive "through" a type that is acceptable, the newtype will cause the compiler to *forget* that it is acceptable
10:25:27 <Sonarpulse> If I call forkIO from a bound thread, the resulting light thread is guaranteed to run in a different host thread?>
10:25:41 <geekosaur> as donri said: something acceptable is something with a Storable instance which tells the compiler how to strip something down to the idiot types C knows what to do with
10:25:54 <geekosaur> and how to turn idiot C types back into Haskell
10:26:01 <tulcod> ah, so basically it's acceptable iff it is Storable
10:26:05 <geekosaur> yes
10:26:06 <tulcod> gerat
10:26:08 <tulcod> *great
10:26:20 <tulcod> donri, geekosaur, Demos: thanks
10:26:28 <Sonarpulse> will calling blocking "unsafe" ffi functions from a bound thread cause haskell light threads running in other OS threads to block?
10:26:33 <donri> although i'm not sure when the Storable constraint applies really; for example i know i'm using an empty data type with no instances at all in a foreign import
10:27:07 <geekosaur> (but that's also only half the story as anything that isn't trivial will require extra C code to deal with. for example, Word16 is fine because its Storable is usually (unsigned short) --- but an array of them requires extra work on the C side because arrays are not a first class data type in C
10:27:10 <geekosaur> )
10:27:12 <donri> but that might be a special case
10:27:28 <Sonarpulse> I am basically using this C library to make an event loop in one OS thread (must be used from one thread), and want to forkIO everytime I get a packet
10:27:48 <Sonarpulse> ideally wth unsafe imports and ONLY the OS thread/ bound thread with the event loop blocking
10:28:13 <Demos> I dont trust rust, it seems like it is trying to merge C++ and haskell which could result in something nightmarish
10:28:32 <Sonarpulse> It has gotten better
10:28:55 <donri> rust is surprisingly nice
10:28:57 <Demos> also, I dont trust mozilla to keep it simple!
10:28:59 <Sonarpulse> it's basically C++ with typeclasses + existentials instead of OO, and shrunking A LOT
10:29:23 <Sonarpulse> the type systems are so similar, I wonder if we couldn't have some automatic FFI bindings setup
10:29:35 <Sonarpulse> granted memory management works different
10:29:37 <Demos> can if FFI to c++?
10:29:52 <Sonarpulse> it was planned in haskell98 but no
10:29:58 <Sonarpulse> unless you full back on extern "C"
10:30:00 <Demos> rust I mean
10:30:11 <Sonarpulse> same "solution"
10:30:25 <Demos> I know in general FFIin to c++ is not worth it, COM tried, XPCOM tried, CORBA tried and all those things are hell spawn
10:30:30 <Sonarpulse> aka loosing all but the most trivial type information over the FFI interace
10:30:45 <Sonarpulse> rust is the modern bits of C++
10:30:58 <geekosaur> c++ is more or less impossible to interface with from anything but c++. and it used to be worse: it had to be the same version of the same compiler too!
10:31:08 <donri> rust can be told to compile to ccall convention so it's probably possible "somehow"
10:31:28 <Sonarpulse> yeah, anything that can fall back on C++ calling convention should wok
10:31:31 <Sonarpulse> *work
10:31:37 <Sonarpulse> but that IMO is kinda defeating the point
10:31:53 <Sonarpulse> I heard GHC has experimental per-thread GC
10:31:55 <donri> depends on what the point is :)
10:32:29 <Sonarpulse> well I want a way to do manaul memory/ low-level hackery only when I need it, while loosing as little type information as nessisary
10:32:42 <Sonarpulse> also manaually making FFI bindings is a pain, and the current automations I still find lacking
10:33:07 <Sonarpulse> with C it is understandable, as the nessisary semantical information isn't really encoded in the language
10:33:19 <Sonarpulse> but with something like rust it might be more feasable
10:35:04 <tulcod> Sonarpulse: i thought the green card approach was interesting... i'm sad it died
10:35:13 <Sonarpulse> green card? not aware of that
10:43:21 <yosemite_newbie> Hi all, i have a question about passing are recursive function to map, i can't get it to work the way i expect
10:43:29 <tswett> Hi yosemite_newbie.
10:43:33 <yosemite_newbie> Consider where hp2 is a recursive function -- map (hp2 0) [1..20]
10:44:01 <yosemite_newbie> i expect hp2 to restart with each element of [1..20]
10:44:42 <tswett> That's what I'd expect, too. Can you give an example of what hp2 might be and what you expect it to do?
10:44:43 <yosemite_newbie> but it doesn't, it seems to continue recursing
10:45:25 <yosemite_newbie> yes, i have a simple example at http://pastebin.com/8RUtZBVN
10:45:31 <mauke> The paste 8RUtZBVN has been copied to http://lpaste.net/91272
10:45:52 <geekosaur> every call to the mapped function is complete in and of itself, yes, and consumes one input element and produces one output element
10:46:20 <geekosaur> if you are looking for something else, you may be interested in folds
10:46:23 <yosemite_newbie> hp2 gets the highest power of 2 for the second argument
10:46:35 <tswett> yosemite_newbie: okay, so hp2 0 6 is supposed to be 1, but it's actually 0, right?
10:46:55 <yosemite_newbie> tswett, yes
10:47:10 <yosemite_newbie> What I want to get is  	0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, . . .
10:47:21 <yosemite_newbie> What I get is 	0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, . . .
10:47:27 <tswett> So when we calculate hp2 0 6, we find that 6 isn't odd, and it's not equal to 2^0, and it's not less than 2^0. So then we try hp0 1 6.
10:47:39 <yosemite_newbie> yes
10:47:49 <tswett> Same thing again, and we end up trying hp0 2 6. And then it happens again, and we try hp0 3 6.
10:48:00 <tswett> And then, finally, 6 < 2^3, so it returns 0.
10:48:27 <yosemite_newbie> it should return 3
10:48:42 <yosemite_newbie> oops
10:49:03 <yosemite_newbie> oh, duh
11:01:13 <ruzu> hello.  i'm trying to figure out how to declare a symbol/constant/whatever, say x, that has the value of 1, but using let x=1 gives a parse error, and x=1 says no instance for num arising from literal 1, but using stuff like Num x = 1 or Int x = 1 gives a not in scope error.  Any tips?
11:02:26 <donri> ruzu: either give it a type signature or disable the monomorphism restriction
11:02:44 <donri> x :: Int; x = 1
11:05:48 <kqr1> can i read more about the monomorphism restriction somewhere? not heavy stuff, just why it's there and when it occurs
11:06:48 <donri> kqr1: i guess http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:07:02 <kqr1> fair enough
11:08:39 <Sonarpulse> so does anybody know about "unsafe" FFI usage relegated to a bound thread
11:09:56 <geekosaur> Sonarpulse, not sure what you're asking
11:10:22 <Sonarpulse> does calling a blocking C function from a bound/forkOS thread block jsut that thread?
11:10:50 <geekosaur> unsafe has two conflated meanings, one is the one you mentioned, the other is allowing for C code that uses thread-local storage
11:11:43 <Sonarpulse> So I am write that it does block just that thread?
11:11:58 <geekosaur> since the solution to both is the same (migrate the call to a specific thread which is thereby allowed to block or reference TLS stuff as it wishes without impacting Haskell or breaking) they are treated the same
11:12:09 <geekosaur> yes
11:12:35 <Sonarpulse> oh good
11:13:11 <geekosaur> the other thread "soft blocks" insofar as haskell won't schedule it until the result is available, but it can't "infect" and block the whole process
11:13:59 <hpaste> Luke pasted “Classes” at http://lpaste.net/91274
11:14:25 <Sonarpulse> the other thread?
11:14:36 <geekosaur> the thread making the call that would otherwise block
11:14:51 <geekosaur> (so we migrate the blocking call elsewhere)
11:15:03 <Luke> can someone help me out with this class problem here? http://lpaste.net/91274 I'm getting a kind mismatch because it says HasStripe should be of kind * -> * but I'm not sure how to do that in this context
11:15:12 <geekosaur> because if that original thread blocked, it would block the haskell thread scheduler and therefore the whole program
11:15:33 <geekosaur> so the call is migrated to a thread which is allowed to block
11:15:40 <ruzu> what is ghci doing that code type into it won't work in an hs file?  i'm guessing it's wrapping the code somehow
11:16:01 <geekosaur> ghci pretends to be the inside of a "do"
11:16:18 <geekosaur> it has an execution context via the ghc-api, and runs code inside that context
11:17:58 <merijn> Right, I've decided on a different approach to deal with my binary parsing troubles
11:18:19 <merijn> Change the protocol >.>
11:18:21 <Sonarpulse> geekosaur, well I don't quite get all that
11:18:29 <Sonarpulse> but the take away is for my event loop
11:18:36 <Sonarpulse> networking library usage all in one bound thread
11:19:05 <enthropy> Luke: you should write  instance HasStripe (Handler b) where
11:19:06 <geekosaur> ghc's thread scheduler is "green" threads possibly multiplexed onto OS threads
11:19:16 <Sonarpulse> unsafe import should be fine?
11:19:23 <monochrom> Sonarpulse: have you read my http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml ?
11:19:23 <Sonarpulse> yeah i get that
11:19:25 <geekosaur> so they're cooperative, and no thread should ever actually block at the OS level
11:19:58 <joelteon> @src ap
11:19:58 <lambdabot> ap = liftM2 id
11:20:04 <enthropy> Luke: or you could change the class to be    class HasStripe m where getStripeState :: m
11:20:15 <Luke> enthropy: thanks
11:20:25 <enthropy> probably it's better to change the instance
11:20:30 <chrisdotcode> guys, what's the difference between IO and MonadIO? Isn't IO *already* a monad?
11:20:40 <tomboy65> why does this not work? filter (\ x -> isPrime $ fromInteger x) $ createSet 34567     - isPrime :: Integer -> Bool, createSet :: Int -> [Int]   - it says "Couldn't match expected type `Integer' with actual type `Int' ... In the return type of a call of `createSet'
11:20:49 <monochrom> also, ghci adds an implicit "forkIO" to almost every line you enter. see -fno-ghci-sandbox
11:20:57 <enthropy> chrisdotcode: the latter is a class for monads that are like IO
11:21:14 <Luke> enthropy: I'm just not sure how I could write an instance without the "view" (in snap framework speak) being the StripeState
11:21:26 <Sonarpulse> monochrom: so my library isn't thread safe
11:21:31 <geekosaur> chrisdotcode, MonadIO is a way to let a monad transformer built on top of IO quickly get at the IO monad no matter how deep it is
11:21:39 <chrisdotcode> enthropy: okay, so in addition to having monadic interfaces, they also have IO interfaces?
11:21:44 <Sonarpulse> can use it in multithreaded program as long as it's used from only one thread
11:21:49 <geekosaur> instead of having to chain "lift"s together to reach it, it can just "liftIO"
11:22:04 <merijn> geekosaur: Eh, GHC threads are not cooperative
11:22:08 <geekosaur> Sonarpulse, yes, that's the *other* case I mentioned
11:22:09 <merijn> geekosaur: They're preemptive
11:22:10 <chrisdotcode> geekosaur: okay, so the IO of the monad is directly accessible?
11:22:21 <Sonarpulse> I'll go back and reread
11:22:27 <tomboy65> :t isPrime
11:22:28 <lambdabot>     Not in scope: `isPrime'
11:22:28 <lambdabot>     Perhaps you meant `isPrint' (imported from Data.Char)
11:23:26 <geekosaur> chrisdotcode, in the absence of liftIO, you have to know how deep your monad stack is and chain an appropriate number of "lift"s together to get at the IO monad. MonadIO does only one thing: it defines "liftIO" which can automaticaly chaion those together to the necessary depth for you
11:23:54 <Sonarpulse> merijn: you sure? bunch of stuff i read said GHC inserted the yields automatically
11:24:00 <geekosaur> because just being based on IO doesn't mean you can just make IO calls
11:24:01 <Sonarpulse> via some heristic I guess
11:24:27 <geekosaur> Sonarpulse, strictly speaking it's a hybrid. the problem with the hybrid is that you cannot safely preempt something running in C-land
11:24:38 <Sonarpulse> that makes sense
11:24:45 <merijn> Sonarpulse: Yes, that is what preemptive means
11:24:48 <geekosaur> so, *in the context of calls into C*, it is effectively cooperative instead of preemptive
11:25:12 <merijn> Sonarpulse: Preemptive threading means threads get preempted (i.e. a running thread will be stopped to let another run)
11:25:25 <merijn> Sonarpulse: Cooperative threading means that threads rely on each other to yield
11:25:25 <Sonarpulse> yeah
11:25:48 <merijn> Sonarpulse: This means that threads that don't yield can accidentaly tie up your execution, this can't happen in preemptive threading
11:25:56 <Sonarpulse> my impression with with haskell's guarantees of immutablility (well most of the time) coopertive was feasible, and what made the light threads lighter
11:26:21 <chrisdotcode> geekosaur: oh, okay. so like if you had Just (Just (Just (IO a))), liftIO would just apply the IO action?
11:26:38 <merijn> Sonarpulse: No, it's the other way around, haskell's purity means the preemption is much more feasible than in any other language
11:26:43 <chrisdotcode> instead of having to use bind to reach inside?
11:26:54 <Sonarpulse> oh duh, that makes more sense
11:26:56 <geekosaur> well, Just isn't part of a monad transformer, no
11:27:01 <merijn> geekosaur: You seem to be abusing the word cooperative really badly :(
11:27:14 <Sonarpulse> but that OS threads are premptive it what makes them clunky
11:27:15 <geekosaur> merijn, suit yourself.
11:27:19 <NemesisD> this error message seems to contradict itself, what am I missing? (hashable-1.1.2.5:Data.Hashable.Hashable a) arising from the use of H.fromList from the context (SafeCopy a, Eq a, Hashable a, SafeCopy b)
11:27:27 <geekosaur> or read what I actually said
11:27:35 <NemesisD> couldn't deduce Hashable a from context Hashable a. wat?
11:27:45 <geekosaur> (again: You Cannot Safely Preempt An FFI Call)
11:27:45 <elliott> NemesisD: the version number prefix is relevant here.
11:28:04 <chrisdotcode> geekosaur: but yeah, I understand more or less, I think. thanks :)
11:28:19 <geekosaur> or you can keep focusing on the wronh part or the theory and ignore the thing that makes bound threads necessary
11:28:24 <merijn> geekosaur: I did, there's nothing related to calls to C that makes haskell threading effectively cooperative. Calling into C just unschedules a thread for the duration of the call, this is orthogonal to the distinction between preemptive and cooperative scheduling
11:28:32 <NemesisD> elliott: ah might i need to add hashable as an explicit dependency in the cabal file?
11:28:54 <NemesisD> ah yes that did it
11:29:06 <merijn> geekosaur: Oh, wait, I missed the line above that
11:29:08 <NemesisD> wait no it didn't
11:29:14 <merijn> geekosaur: Ignore me >.>
11:30:41 <enthropy> Luke: I'm not familiar with snap, but there are plenty of ways to have some state (StripeState) exist in your program
11:31:21 <Luke> enthropy: after I asked that question I think it's not possible from this context. I have to grab the lens. Thanks for your help. You've given me enough to think about to hopefully make some progress
11:31:23 <enthropy> if it's not supposed to be per-request (?) you can put it somewhere else
11:31:33 <Sonarpulse> "safe" imports also avoid blocking problems, but not for libraries that also need to be run from one thread?
11:32:18 <Sonarpulse> which doesn't apply to my case, but good to know
11:32:26 <NemesisD> Luke: didn't see your original question but it looks like snap's monadd is an RWST
11:32:41 <enthropy> say something like:    main = do stripeState <- newIORef initial_stripe_state; actualServerProgramHere stripeState
11:32:42 <NemesisD> welp
11:33:31 <NemesisD> elliott: could you illuminate the situation with hashable a bit more?
11:34:27 <elliott> NemesisD: you have two versions of hashable installed
11:34:34 <elliott> and your dependencies disagree about them
11:34:40 <elliott> you should probably reinstall your packages from scratch
11:35:06 <NemesisD> damn
11:35:09 <Sonarpulse> lastly, is there anway to use the type system to make sure the library is used from one thread?
11:36:04 <NemesisD> *cabal sandbox delete && cabal sandbox init && cabal install -j4 --only-dependencies, put laptop on a cool surface, go make lunch*
11:36:10 <Sonarpulse> I guess I could do the ST phantom variable thing, but that seems cumberson
12:08:03 <Luke> enthropy: what exactly does it mean by "Expecting one more argument to b" in this type? :: (HasStripe b, HasHeist b) => SnapletISplice b
12:08:56 <Luke> meaning where does it expect me to specify the "other argument"?
12:08:57 <enthropy> Luke: if in ghci you write :k HasStripe
12:09:25 <enthropy> and the same for the other two capitalized names there, you should have the same    (* -> *) -> Constraint
12:09:32 <enthropy> or say   * -> Constraint
12:09:57 <enthropy> oops, the SnapletISplice won't be a constraint, but whether it takes a  * or a (* -> *) is the important thing
12:10:03 <Luke> enthropy: no I understand it is kind * -> * but I don't know how to give it another type variable
12:10:57 <enthropy> my guess is that one of those uses needs a type variable with kind *
12:11:20 <enthropy> so you should actually write something like    (HasStripe b, HasHeist b) => SnapletISplice (b ()) -- for example
12:12:28 <enthropy> Luke: you could also leave off the type signature and see what ghc can infer
12:12:36 <Luke> that's what I'm trying to do
12:12:46 <Luke> it's failing on other problems like not having Monad m etc
12:13:09 <enthropy> {-# LANGUAGE NoMonomorphismRestriction #-}
12:13:15 <enthropy> that'll probably help
12:13:46 <Luke> yeah good call
12:13:48 <Luke> thanks
12:13:53 <Xiron> hello, I have two questions for this matter: http://pastebin.com/8MqfLZd0 1. What is the the lambda abstrakion for the (++) ? and 2. can someone give me please some hints how I can write the function in the link  in lambda?
12:13:56 <mauke> The paste 8MqfLZd0 has been copied to http://lpaste.net/91275
12:14:13 <Luke> stripePublicKeySplice :: (Monad m, Functor m, HasStripe (HeistT n m)) => HeistT n m Template
12:14:15 <Luke> bingo
12:14:17 <Luke> thanks a lot
12:14:18 <hpc> oh, when will we be getting hpaste.org back, btw?
12:14:27 <mr-> hpc: hpaste is now lpaste
12:14:45 <hpc> i know
12:14:48 <hpc> when will the domain be back?
12:14:52 <Luke> I was trying to do (HasStripe (HasHeist b)) but that didn't work for some reason
12:15:01 <mr-> hpc: Oh, no clue ;-)
12:15:09 <merijn> hpc: Whenever someone can get bos to react
12:15:27 <merijn> hpc: bos owns it, but he hasn't been in contact with anyone that's tried to reach him
12:15:33 <nexx> What happened to hpaset?
12:15:38 <hpc> also, if you are going to stick to λ-paste, i suggest registering λ-paste.net :D
12:15:48 <hpc> for funzies
12:16:14 <nexx> *hpaste
12:16:49 <Clint> why not λ-paste.org
12:16:52 <Clint> for funzies
12:17:00 <opqdonut> probably can't be reserved
12:17:13 <hpc> Xiron: (++) is likely going to defined recursively
12:17:16 <opqdonut> due to the "single language plane" (or whatever it is) restruciton
12:17:27 <opqdonut> (the domain name λ-paste, that is)
12:17:31 <hpc> and since you are using lambdacalculus, that means great pain
12:18:41 <Luke> enthropy: thanks so much
12:18:47 <Luke> enthropy: I would have never figured that type out =D
12:19:29 <Clint> opqdonut: what's a "language plane" in this context?
12:20:12 <opqdonut> Clint: you can reserve a domain name that uses solely the latin alphabet, greek alphabet, or something else, but not a mixture
12:20:40 <opqdonut> they have this restriction for at least .net, .org and .info
12:21:23 <opqdonut> see http://en.wikipedia.org/wiki/IDN_homograph_attack
12:22:20 <opqdonut> oh, that doesn't actually talk about the restrictions registrars have
12:22:22 <opqdonut> anyway, offtopic
12:23:32 <NemesisD> is there a function that will shuffle one array into another?
12:24:10 <Xiron> hmm
12:24:39 <ion> nemesisd: Would shuffling a list be enough?
12:25:06 <NemesisD> ion: well i don't need it to be random and i need it to be pure
12:25:33 <NemesisD> i suppose this is easy enough to do by hand
12:26:06 <NemesisD> its kind of like a zip that collapses into a list
12:26:16 <ion> > map snd . sortBy (comparing fst) . zip (randoms (mkStdGen 42) :: [Double]) $ words "Hello world foo bar baz quux 0 1 2 3 4 5 6 7 8 9"
12:26:17 <lambdabot>   ["7","4","3","2","Hello","baz","world","foo","9","bar","6","8","1","0","5",...
12:26:55 <ion> That is not efficient, but it’s trivial and good enough for small lists.
12:33:11 <Spockz> should I write 'datatype' or 'data type' when referring to a Haskell datatype/data type? I have seen both version in papers.
12:34:21 <Spockz> even here: http://www.haskell.org/haskellwiki/Generalised_algebraic_datatype it is mixed
12:38:42 <Xiron> hello, I have two questions for this matter: http://pastebin.com/8MqfLZd0 1. What is the the lambda abstrakion for the (++) ? and 2. can someone give me please some hints how I can write the function in the link  in lambda?
12:38:43 <mauke> The paste 8MqfLZd0 has been copied to http://lpaste.net/91275
12:39:11 <Sonarpulse> what happens when you call forkIO from a bound thread (ie one created with forkOS)
12:41:25 <Spockz> Xiron: I think that that is a confusing syntax
12:41:41 <Xiron> why?
12:41:51 <ParahSail1n> @ty reverse
12:41:52 <lambdabot> [a] -> [a]
12:41:57 <ParahSail1n> @src reverse
12:41:57 <lambdabot> reverse = foldl (flip (:)) []
12:42:03 <Spockz> what does \ x.xTFF mean? And the \ ?
12:42:08 <Spockz> err, the /
12:42:57 <Xiron> it's a lambda abstraktion
12:43:32 <Xiron> should be the same symbol sry
12:43:56 <hpc> Spockz: https://en.wikipedia.org/wiki/Algebraic_data_type "data type", probably
12:44:09 <hpc> Spockz: much like how the correct term is "type class", i imagine
12:44:39 <Spockz> hpc: If you say so. But I've seen it spelled without the space as well...
12:45:10 <Spockz> could there be a difference between the English spelling "data type" and the term "datatype"
12:47:29 <nbouscal> Spockz: pretty sure it's just people being lazy with their typing, same thing as type class vs typeclass
12:47:37 <Spockz> nbouscal: okay
12:48:16 <nbouscal> pretty common linguistic pattern, when you have a two word phrase that is used that commonly it almost always gets shortened in some way or another
12:48:17 <Spockz> There is also a significant difference in the amount of hits between datatype and data type: 13.6 mill vs 628 million
12:48:59 <brgr> hi
12:49:59 <nbouscal> Spockz: actually should search "data type" not data type, and the results there are only 7.8 mill
12:50:11 <brgr> can someone help me? i have a ghci.conf in my ~/.ghc/ directory but when i execute ghci it cant read the file. it says:WARNING: /home/dominik/.ghc is writable by someone else, IGNORING!
12:50:17 <nbouscal> Spockz: so it appears datatype is now more common
12:50:24 <Spockz> nbouscal: ah you are right indeed
12:50:42 <nbouscal> brgr: sounds like a permissions issue
12:51:48 <Xiron> do nobody know how I can write it in lambda? :-/
12:51:49 <brgr> ive made chmod a+r ghci.conf but the issue still exists
12:53:32 <NemesisD> anyone use edwardk's tables library?
12:53:33 <nbouscal> you need your .ghc folder to only be writable by owner. so 744 or something like that
12:53:56 <Luke> What's going on here?: Couldn't match type `Data.Text.Lazy.Internal.Text' with `Text'
12:54:11 <Luke> why does it thing those are two different types?
12:54:20 <Clint> because the latter is probably strict Text
12:55:06 <Luke> does it default to strict if I don't specify lazy?
12:55:25 <Clint> what is "it"?
12:55:44 <Luke> Data.Text
12:56:01 <hpc> use the docs, luke
12:56:01 <nbouscal> from the docs, Data.Text provides strict, Data.Text.Lazy provides lazy
12:56:06 <nbouscal> same as ByteString
12:56:13 <Clint> Luke: http://hackage.haskell.org/packages/archive/text/0.11.1.13/doc/html/Data-Text.html#g:1
12:56:24 <Luke> hmm that's not the problem. still complaining about internal vs. not
12:56:31 <brgr> @nbouscal thank you. that did it for me!
12:56:31 <lambdabot> Unknown command, try @list
12:56:44 <Clint> misuse of "package" there
12:57:25 <Xiron> http://pastebin.com/8MqfLZd0
12:57:25 <mauke> The paste 8MqfLZd0 has been copied to http://lpaste.net/91275
13:00:19 <Luke> I think the problem is XmlHtml is referencing the Data.Text.Internal and Data.Text.Format explicitly returns a lazy Text
13:01:21 <Luke> http://hackage.haskell.org/packages/archive/xmlhtml/0.1/doc/html/Text-XmlHtml.html#t:Node
13:01:26 <Luke> am I reading that correctly?
13:09:24 <nbouscal> from the XmlHtml source it looks like it's just using Text from Data.Text, doesn't appear to use Data.Text.Internal at all
13:09:46 <nbouscal> it defines InternalText as a type constructor for the InternalSubset data type, but that appears to be something completely different
13:12:02 <Luke> nbouscal: right but if it's importing Text from Data.Text, is that incompatible with Data.Text.Lazy's Text type?
13:12:07 <Xiron> I have two questionsabout this : http://pastebin.com/8MqfLZd0 1. What is the the lambda abstrakion for the (++) ? and 2. can someone give me please some hints how I can write the function in the link  in lambda?
13:12:07 <mauke> The paste 8MqfLZd0 has been copied to http://lpaste.net/91275
13:12:37 <nbouscal> Luke: yes. but Data.Text.Lazy has toStrict
13:12:46 <nbouscal> as well as fromStrict
13:12:49 <Luke> nbouscal: ok gotcha - thanks
13:12:52 <Luke> i didn't see that
13:12:53 <Xiron> I have two questions about this : http://pastebin.com/8MqfLZd0 1. What is the the lambda abstrakion for the (++) ? and 2. can someone give me please some hints how I can write the function in the link  in lambda?
13:12:54 <mauke> The paste 8MqfLZd0 has been copied to http://lpaste.net/91275
13:13:24 <nbouscal> Luke: No problem. I've been fussing with ByteStrings for the last two weeks and they're set up the same way
13:14:03 <Luke> nbouscal: the weird thing is it's complaining about Text vs. Internal not lazy vs. nonlazy
13:14:12 <Luke> nbouscal: so I wasn't sure I had a strictness issue
13:14:27 <nbouscal> Luke: I think it's just referencing where the lazy type is defined internally? that'd be my guess anyway
13:14:41 <Luke> yeah could be
13:17:12 <nbouscal> On a related note, can someone explain why the lazy types all use Int64?
13:21:40 <merijn> nbouscal: Because they are supposed to be used for things like streaming terabytes of data from disk
13:24:06 <Peaker> s/used/usable
13:24:11 <nbouscal> merijn: Hm, ok.
13:24:50 <Sonarpulse> what is the easiest way to download some json
13:24:57 <Sonarpulse> just need curl
13:24:58 <nbouscal> And the strict types are kept using regular Ints to not incur that extra overhead?
13:25:07 <Sonarpulse> I have my Aeson instance all ready
13:25:28 <nbouscal> Just caused me some headaches having to define the same function twice for strict and for lazy
13:25:51 <k00mi> Sonarpulse: Network.HTTP.simpleHTTP
13:26:04 <Sonarpulse> thanks
13:26:15 <k00mi> simplest I know, atleast
13:26:32 <Peaker> nbouscal, the refusal to type-class the overlap between strict/lazy APIs is one of the main annoyances in Haskell IMO too
13:26:38 <Spockz> does the function argument of >>= have a name? Would continuation be a good name?
13:26:52 <donri> Sonarpulse: there seems to be a curl-aeson package even :p
13:27:00 <Peaker> Spockz, continuation might be confusing since people would think you're referring to Cont/ContT. Maybe the "callback"?
13:27:05 <donri> otherwise, probably http-conduit or http-streams
13:27:10 <Sonarpulse> donri: alright
13:27:19 <Sonarpulse> oh i definitely don't need fancy IO
13:27:36 <Sonarpulse> now, the big question
13:27:43 <Sonarpulse> GUI library
13:27:45 <nbouscal> Peaker: yeah, seems like we have this fantastic type classing ability so why not use it? Assuming that we could get consistency across the libraries
13:27:53 <Sonarpulse> something native haskell would be neat
13:28:02 <donri> well the other options either don't support tls or use fragile ffi code
13:28:05 <Sonarpulse> WxWigets, he I don't care that much
13:28:07 <donri> notably curl likes to segfault
13:28:17 <Spockz> Peaker: could be, but I don't refer to Cont/ContT at all, would that make it okay? Callback has some asynchronous connotation for me
13:28:43 <nbouscal> Spockz: maybe use some suffix on bind, like binded or bound or whatever
13:28:51 <nbouscal> bindee
13:28:56 <donri> Sonarpulse: for something "haskelly" maybe reactive-banana-wx
13:29:22 <Spockz> nbouscal: sounds fishy :P
13:29:25 <Peaker> wx is hard to build, depends on old ghc's, my pull request to fix it is ignored.. so I don't work on fixing it to support newer wx versions either
13:29:36 <Peaker> bos also ignored my bug fix pull request :(
13:29:49 <Sonarpulse> this is for a game
13:29:53 <merijn> Peaker: bos seems very unresponsive lately
13:29:59 <Sonarpulse> so non-native-looking wigets is fine
13:30:09 <nbouscal> Spockz: I just agree with Peaker that some people will get thrown off if you call it continuation
13:30:13 <Sonarpulse> I meant to say I _don't_ want to deal with WX for that reason
13:30:22 <Spockz> nbouscal: fair enough
13:30:43 <Peaker> Spockz, but the asynchronous connotation is a correct connotation
13:31:27 <Spockz> Peaker: even for bind?
13:31:45 <Peaker> Spockz, yes, it is a valid view of bind
13:31:54 <Peaker> At least IMO :)
13:32:06 <nbouscal> I'm not sure I agree… but not sure I disagree either haha
13:32:08 <Spockz> Peaker: I've never looked at bind that way
13:32:45 <nbouscal> I think it's a pretty non-standard way of looking at it in any case, so probably not the best didactic choice? What's this for anyway, Spockz?
13:32:54 <donri> Sonarpulse: well it gives you a nice frp interface atop it
13:32:58 <donri> but i haven't used it so duno
13:33:14 <Spockz> nbouscal: I'm writing my thesis and I find I have to refer 'to the second argument of bind' a lot :)
13:33:18 <Spockz> so I would like a name for it
13:33:37 <monochrom> bindee
13:33:44 <nbouscal> that's two votes for bindee!
13:33:53 <monochrom> nice :)
13:33:53 <elliott> perhaps "the substitution"
13:35:02 <Spockz> but isn't the first argument the value that is being bound?
13:35:04 <hpc> perhaps "before" and "after"?
13:35:10 <hpc> as in (before >>= after)
13:35:33 <nbouscal> you could maybe have the first argument be the bound value and the second be the bound function?
13:35:40 <hpc> you can also look at what other papers did
13:36:02 <Sonarpulse> oh, I was wondering if there might be a backend
13:36:12 <Sonarpulse> well I'll try isntalling it
13:37:00 <Sonarpulse> *another backend
13:37:12 <Sonarpulse> if it installs fine, I'll use it
13:37:24 <nbouscal> or monadic value >>= monadic function?
13:37:29 <Sonarpulse> I just don't want to take on another finicky FFI thing, cause I already have one
13:41:13 <mel-> hi
13:41:31 <mel-> is there any halfway decent documentation/tutorial on implementing new Read instances?
13:42:30 <Spockz> nbouscal: monadic function sounds pleasingly specific
13:42:48 <Peaker> mel-, I don't think anybody does that.. either you use "deriving Read" or you use parsec/attoparsec/trifecta/etc
13:43:19 <mel-> (I find the few example hard to read and the documentation not helpful either. I have an algebraic data type which holds two [Integers]'s. What I want is way to parse something like ( 1 2 3 | 4 5 ) such that the first list in my datatype is [1,2,3] and the second is [4,5]
13:43:37 <hpc> mel-: you want parsec
13:43:42 <hpc> or some other parsing lib
13:43:55 <monochrom> elliott: "subsitution" refers to either doing it (so, the whole "m >>= k") or the specification "replace x by sin(5)" (so, close to the "m" part). neither refers to the "k" part.
13:44:05 <Sonarpulse> oh a related note, the current version  of unbuntu does not come with the haskell platform for what seems like no good reason
13:44:23 <mel-> hpc: but the Read class does not support parsec, as far as i can tell
13:44:26 <mel-> does it?
13:44:36 <Sonarpulse> (looks like reactive-banna was going to try to install some things from it)
13:45:02 <Sonarpulse> does anybody know of a decent way to get the package from debian-testing or something?
13:45:41 <Sonarpulse> As far as I can tell it's just because some awkward release cycle timing, and not some underlying incompatability
13:46:21 <elliott> monochrom: "replace x by sin(5)" I identify with k.
13:46:26 <elliott> monochrom: consider the Tree monad.
13:47:03 <monochrom> no, consider "let x=sin(5) in x+x+x" = "return (sin(5)) >>= \x -> x+x+x"
13:47:06 <elliott> or nested-data-type-style lambda calculus terms (e.g. as in the bound library)
13:47:41 <elliott> there, (tm >>= e) corresponds precisely to rewriting by the substitution/lookup table "e" on the term "tm"
13:48:28 <monochrom> my example is more general and more elementary. your example requires a niche monad
13:49:06 <monochrom> my example is also in line with Moggi's paper
13:53:59 * elliott likes to think of these substitution monads as elementary :)
13:54:27 <monochrom> the Identity monad is the most elementary
13:57:19 <elliott> of course! it's the monad of terms consisting only of variables.
13:57:26 <Peaker> The   Const ()  monad is the most elementary?
13:59:35 <hpc> the Tardis monad is the most elementary!
14:00:20 <pharaun> hmm i can't decide if i want to do this via records or via typeclass
14:01:04 <Taneb> hpc, I'm still surprised that the Tardis monad actually is occasionally useful
14:02:12 <hpc> the backwards state is kind of like a giant recursive let
14:02:14 <benzrf> I think I understand monads.
14:02:23 <benzrf> ...maybe?
14:02:51 <elliott> pharaun: the former.
14:02:51 <ion> hpc: also forwards
14:03:01 <benzrf> they're used for pipelines where any individual pipeline element is able to have some kind of influence over the pipeline as a whole
14:03:18 <benzrf> or otherwise affect something other than just its one step
14:03:27 <hpc> well yes, that too
14:03:53 <kier> A package I'm attempting to install (virthualenv) requires base <4.6, yet I have 4.6.0.1 installed. Do I assume 4.6.0.1 is compatible with bases < 4.6 and edit the requirement in the package's .cabal file, or try to "down-grade" my base?
14:04:02 <benzrf> how on-point am I?
14:05:03 <pharaun> elliott: any particular reason?
14:05:13 <dcoutts_> kier: if it says it needs base < 4.6, either it's been tested and it doesn't yet work with the later base, or the author hasn't checked yet and is taking the conservative approach
14:05:30 <pharaun> elliott: i'm leaning toward records so i can define and reuse several functions and composite them into the record and update only what i want
14:05:37 <dcoutts_> kier: so you can try unpacking it, adjusting the constraint in the .cabal file and seeing if it does work
14:06:14 <kier> dcoutts_: The last commit to its repo was a year ago, so I imagine it's the latter. I'll try adjusting the constraint.
14:06:36 <benzrf> hey, can somebody help me?
14:06:53 <dcoutts_> kier: oh, now that I think of it, I think there's a replacement called hsenv (iirc)
14:08:14 <Peaker> benzrf, I think that's a good intuition -- every step can compute a new value *and* do something that affects the "pipeline" beyond the value
14:08:21 <benzrf> ok.
14:08:26 <benzrf> so in this way of thinking about it...
14:08:27 <Peaker> benzrf, though it's not the complete picture
14:08:30 <kier> dcoutts_: Seeing as fixing that problem revealed a more complex dependency conflict, I'll go check that out
14:08:33 <benzrf> the actual Monad values aren't as significant
14:08:40 <benzrf> except as carriers between pipeline steps
14:08:40 <Peaker> benzrf, why?
14:08:52 <Peaker> benzrf, the pipeline and its result are both important
14:09:04 <benzrf> no, I mean the 'wrapped' values
14:09:09 <benzrf> ugh
14:09:11 <benzrf> I'm misspeaking
14:09:32 <monochrom> for most monads, everything is important
14:09:44 <benzrf> yeah ugh
14:09:54 <kier> dcoutts_: hsenv installed without problem, thanks for the tips :)
14:10:08 <dcoutts_> great
14:10:09 <Peaker> benzrf, you need to contrast Monads with Applicatives to understand them more deeply, IMO
14:10:14 <benzrf> yeah,,,
14:10:22 <benzrf> The problem is that I don't think I really understand applicatives
14:10:23 <benzrf> :(
14:10:39 <benzrf> any recommended reading? lyah's section kind of hurt my brain
14:10:40 <benzrf> >_>
14:10:47 <tulcod> benzrf: if you understand monads, those things aren't really complicated anymore
14:10:49 <tulcod> just get monads right first
14:10:52 <benzrf> eh
14:11:00 <tulcod> after that... applicatives, functors, arrows, all that shit follows
14:11:12 <benzrf> maybe I should learn category theory
14:11:36 <Peaker> benzrf, Applicatives are intuitively a statically-known list of "actions", where each generates a value of some type (can be different types, it's not really in a list),  alongside some pure function that can transform all of these actions' results into a single result
14:11:41 <tulcod> ugh, that's the most ironic thing people say about haskell. "you don't need to understand category theory to write haskell code"
14:11:45 * monochrom recommands Wadler's "idioms are oblivious, arrows are meticulous, monads are promiscuous" arrows are meticulous, monads are promiscuous
14:11:48 <monochrom> err
14:11:54 <elliott> pharaun: because if you're uncertain of whether to use a typeclass, you probably shouldn't.
14:11:57 * monochrom recommands Wadler's "idioms are oblivious, arrows are meticulous, monads are promiscuous" http://homepages.inf.ed.ac.uk/wadler/topics/monads.html#arrows-and-idioms
14:11:57 <elliott> especially when the alternative is records.
14:12:09 <joelteon> recommends
14:12:10 <elliott> I have learned this lesson by ignoring it, so you might like to as well :)
14:12:25 <pharaun> elliott: haha :) fair enough, i just haven't found *many* use for typeclass yet
14:12:27 <Peaker> benzrf, Applicative composition (<*>) can "look" into both arguments, since they both are wrapped in the "f" constructor which for some instance, is a concrete type that can be analyzed without executing any effect
14:12:30 * monochrom didn't use category theory to learn haskell
14:12:39 <kier> benzrf: I came across a pretty good functor/applicative/monad tutorial today (think it was posted in this channel): http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
14:12:44 <pharaun> elliott: so i keep on pondering if i am *missing* something about them or if i just haven't found the correct usecase for it
14:13:05 <benzrf> gugh
14:13:08 <benzrf> reading
14:13:09 <elliott> pharaun: you'd be pretty sad if Num or Monad weren't in the language. but yes, they should be used sparingly.
14:13:43 <pharaun> elliott: oh i know about those two :) i like them, but i was referring to my own typeclass/usage but yeah, records it is :)
14:13:57 <elliott> pharaun: right. just showing that they can be useful :P
14:14:14 * monochrom knows where the suggestion "abstract before concrete, general before specific" comes from. from over-enthusiastic misguided people
14:14:55 <pharaun> elliott: fair enough :) thanks!
14:15:08 <elliott> pharaun: you might like:
14:15:13 <elliott> @where existential-typeclass
14:15:13 <lambdabot> I know nothing about existential-typeclass.
14:15:15 <elliott> @where existential-typeclass-antipattern
14:15:15 <lambdabot> I know nothing about existential-typeclass-antipattern.
14:15:17 <elliott> :(
14:15:19 <elliott> @where existential
14:15:19 <lambdabot> I know nothing about existential.
14:15:21 <elliott> come on.
14:15:30 <elliott> @google existential typeclass antipattern
14:15:31 <Yaniel> she has an existential crisis
14:15:32 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
14:15:32 <lambdabot> Title: Haskell Antipattern: Existential Typeclass | Luke Palmer
14:16:04 <monochrom> example: a math enthusiasist learns about ring theory, and opines "schools should teach ring theory before actual numbers and actual polynomials! ring theory is more general and explains it all in one go!"
14:16:37 <pharaun> elliott: oh yeah i've read this :) that's what made me ponder if typeclass was the correct thing or if records would be a better one
14:16:40 <nbouscal> You only can see the benefit of the abstract once you've run into the pain of doing everything concretely
14:16:41 <monochrom> I'm sorry, the whole reason you learn ring theory successfully is because you learned actual numbers and actual polynomials before.
14:17:32 <benzrf|afk> pfft
14:17:48 <benzrf|afk> I'm reading http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html, but I'm using an ancient CRT monitor for reasons
14:17:51 <benzrf|afk> and it looks really faded
14:17:55 <benzrf|afk> because of the fuzzing
14:17:56 <benzrf|afk> D:
14:18:16 <nbouscal> benzrf|afk: You might check out the Typeclassopedia for another treatment, and try to do the exercises
14:18:46 <nbouscal> personally I think lyah's treatment of functors and applicatives is really good, but can always benefit from multiple views
14:28:14 <tomato> I FU^^ING HATE IE!!!!
14:29:40 <benzrf|afk> hey did you know that python also has >>=
14:29:53 <benzrf|afk> (it's in-place rshift)
14:29:57 <benzrf|afk> (ba dum psh)
14:29:58 <elliott> @quote bitshiftri
14:29:59 <lambdabot> beaky says: why did they settle on bitshiftrightassign (>>=) for monadic bind?
14:30:01 <ion> Many languages have that.
14:30:04 <benzrf|afk> heheh
14:31:24 <Peaker> ion, what other languages besides C and C++?
14:34:53 <ion> Ruby, Python, JavaScript, PHP, Java, …
14:35:34 <ion> Perl
14:36:36 <benzrf> ok.... hmm
14:36:58 <benzrf> so functor allows you to provide a value with a description of how to apply a function to it
14:37:08 <benzrf> then, once it's applied, it rewraps it with the same context
14:37:25 <benzrf> whereas use monad when you want the function to decide what the new context should be
14:37:27 <ion> “Wrapping” is meaningful for only some types.
14:37:34 <benzrf> instead of assuming that you want to put it into the same context
14:37:42 <benzrf> buh
14:38:03 <Saizan> well, depends on how loose a definition of wrapping you have
14:38:12 <benzrf> vurry loose
14:38:39 <Saizan> anyhow, for monads, the old and new contexts get merged
14:38:46 <benzrf> hmm
14:38:57 <benzrf> what about with Maybe?
14:39:03 <benzrf> not really 'merged'
14:39:12 <tdammers> hmm, is hpaste no longer with us?
14:39:21 <geekosaur> @where hpaste
14:39:21 <lambdabot> http://lpaste.net/new/haskell
14:39:32 <Saizan> benzrf: well, for a loose def. of merged :)
14:39:32 <geekosaur> same paste site, even has old history, just a new domain name
14:39:37 <chrisdone> has anyone written a haskell interpreter in haskell?
14:39:48 <nbouscal> benzrf: Maybe is basically merged by and. Just + Just = Just, everything else = Nothing
14:39:57 <Saizan> benzrf: Nothing >>= (const (Just 1)) == Nothing
14:40:05 <benzrf> chrisdone: ghc is in haskell
14:40:10 <benzrf> hm
14:41:50 <benzrf> ok, when are applicatives useful?
14:41:56 <benzrf> I still don't get them :\
14:42:07 <benzrf> and from there I probably don't really get monads
14:43:17 <chrisdone> i would continue reading your book and learning about the type system
14:43:42 <benzrf> chrisdone: is that @me?
14:43:48 <chrisdone> yeah
14:43:51 <benzrf> ...
14:43:56 <benzrf> I know the type system pretty ok
14:44:21 <timbod> Any successful users of ghc-mod + emacs about?
14:44:35 <nbouscal> benzrf: Always follow the types. So, for example, <*> is f (a -> b) -> f a -> f b. That should indicate where it's useful
14:44:38 <chrisdone> then there's nothing to get about monads. it's just a type-class with a bunch of laws, as long as you can implement an instance of it satisfying the laws, you have a Monad
14:45:03 <Peaker> benzrf, Applicatives are useful when you want your "pipeline"/composed-computation to be observable rather than opaque
14:45:21 <benzrf> chrisdone: BS
14:45:26 <benzrf> chrisdone: Monad the typeclass is just that
14:45:32 <nbouscal> benzrf: Anything Applicative can do, Monad can do also. But Applicative does it a bit more simply
14:45:34 <benzrf> chrisdone: but Monads are meant to represent an abstract idea
14:45:38 <benzrf> and that is also called a Monad
14:45:42 <benzrf> Peaker: explain?
14:45:49 <Peaker> benzrf, for example, if you compose a command-line parser with only the Applicative operators (fmap, pure, (<*>)) -- then you can examine the composed parser to auto-generate the "--help", for example
14:46:02 <chrisdone> benzrf: speaking among those that get monads, i resent your 'BS' and re-teaching. good luck
14:46:11 <benzrf> chrisdone: :)
14:46:11 <Peaker> benzrf, whereas if you use (>>=) to compose the parser, then you inevitably end up with a black-box parser that cannot be examined
14:46:19 <joelteon> you can't join with applicatives only
14:46:22 <benzrf> Peaker: hmmm...
14:46:31 <Peaker> @type (=<<)
14:46:32 <lambdabot> Monad m => (a -> m b) -> m a -> m b
14:46:34 <Peaker> @type (<*>)
14:46:35 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:46:46 <Peaker> benzrf, note the contrast between these 2
14:46:52 <benzrf> yeah, I know...
14:46:56 <benzrf> I mean, I know the typeclasses of both
14:47:08 <benzrf> but I don't understand what kind of program or idea they represent
14:47:09 <Peaker> benzrf, (=<<) gets an value it can examine, and a black-box lambda
14:47:21 <Peaker> benzrf, behind the lambda, hides another value it can examine
14:47:42 <Peaker> benzrf, but it must first "execute" whatever effects the first arg had, before it can see what the lambda hides
14:47:54 <benzrf> ugh
14:47:56 <Peaker> benzrf, so a monad forces execution of effects to figure out what more effects to do
14:47:57 <benzrf> I'm confused :\
14:48:01 <chrisdone> anyway, nobody seen a haskell interpreter entirely in haskell?
14:48:09 <benzrf> chrisdone: ghc[i]
14:48:14 <joelteon> chrisdone: ghci
14:48:18 <joelteon> oh
14:48:21 <joelteon> whoops
14:48:22 <Saizan> benzrf: http://www.haskell.org/haskellwiki/Monads_as_computation
14:48:32 <benzrf> well I kind of get monads
14:48:35 <benzrf> but...
14:48:53 <Saizan> benzrf: the introduction gives a lot of motivation there
14:48:54 <benzrf> basically, how are applicatives useful vs regular functors?
14:49:01 <Peaker> benzrf,    SomeConstructor ... <*> OtherConstructor ... = ...         all the Applicative compositions get to see what the building blocks of the computation are
14:49:19 <benzrf> Peaker: sorry I don't get it :\
14:49:19 <hpaste> tdammers pasted “FromJSON, how?” at http://lpaste.net/91279
14:49:31 <benzrf> I kinda get how monads are useful, and I understand functors a bit more
14:49:33 <Peaker> benzrf, regular Functors cannot compose "effects" at all..  "fmap" has 1 "f" value in its input, and 1 "f" value in its output, and the "f" part is exactly the same
14:49:41 <benzrf> right
14:49:43 <benzrf> go on...
14:49:44 <joelteon> > (,,) <$> Just 1 <*> Just 2 <*> Just 3
14:49:45 <tdammers> anyone help me solve my brain lapse there?
14:49:45 <lambdabot>   Just (1,2,3)
14:49:59 <nbouscal> benzrf: The example that helped me most on understanding applicative is when you have a chain like: (+) <$> [1,2,3] <*> [4,5,6]
14:50:00 <joelteon> > (,,) <$> Just 1 <*> Nothing <*> Just 3
14:50:01 <lambdabot>   Nothing
14:50:02 <Peaker> benzrf, try to use regular Functor to compose two (IO Int) actions to one that sums them
14:50:07 <benzrf> joelteon: the thing is, why not just do that with functors?
14:50:10 <benzrf> wait hm
14:50:11 <joelteon> you can't
14:50:18 <joelteon> how would you do that with functors
14:50:24 <benzrf> ugh hold on let me think
14:50:43 <joelteon> :t fmap (,,) (Just 1)
14:50:44 <lambdabot> Num a => Maybe (b -> c -> (a, b, c))
14:50:53 <Peaker> benzrf, ioA, ioB :: IO Int         fmap (+) ioA :: IO (Int -> Int)   <-- get this so far?
14:50:55 <joelteon> but then how do you get the function back out?
14:50:56 <benzrf> sorry I don't know ,,
14:50:58 <joelteon> you can't
14:51:02 <joelteon> (,,) a b c == (a,b,c)
14:51:05 <benzrf> > 3 ,, 4
14:51:06 <benzrf> oh ok
14:51:06 <lambdabot>   <hint>:1:3: parse error on input `,'
14:51:09 <joelteon> it was the simplest 3-ary function I could think of
14:51:25 <Peaker> why do you need 3-ary functions to explain applicatives?
14:51:25 <benzrf> > 3, 4
14:51:26 <lambdabot>   <hint>:1:2: parse error on input `,'
14:51:27 <tdammers> (,,) 3 4 5
14:51:31 <joelteon> you don't
14:51:34 <tdammers> > (,,) 3 4 5
14:51:36 <lambdabot>   (3,4,5)
14:51:38 <benzrf> > (,) 3 4
14:51:38 <benzrf> ok, not a thing
14:51:39 <lambdabot>   (3,4)
14:51:39 <joelteon> it's teh first 3 a-ry function I thought of, though
14:51:46 <joelteon> 3-ary
14:51:54 <Peaker> joelteon, I think you're overwhelming benzrf with too many examples and no time to think
14:51:57 <tdammers> tuples are kind of weird that way
14:51:57 <joelteon> could've gone with (+) or something, but i digress
14:52:12 <benzrf> aarrrghh my brain hurts
14:52:12 <joelteon> ok (+) is a better exmple
14:52:17 <benzrf> hold on
14:52:20 <benzrf> let me simmer down
14:52:47 <benzrf> Peaker: I wasn't understanding your explanations because I don't think of monads as having to do with 'effects'
14:52:52 <benzrf> and I didn't know what you meant
14:52:53 <benzrf> (still don't)
14:53:04 <Peaker> benzrf, What do you think of a value like "IO Int" ?
14:53:10 <benzrf> well, in that case
14:53:10 <benzrf> :P
14:53:14 <benzrf> ok
14:53:24 <benzrf> it's a computation that results in an Int if executed?
14:53:43 <Peaker> benzrf, "Maybe a" can have a "failure" effect.  [a] can have a "failure" effect as well as a "fork" effect
14:53:57 <Peaker> benzrf, an IO-effectful computation, yes
14:54:31 <Peaker> benzrf, "State s a" has "get current state" and "set current state" effects
14:54:43 <benzrf> I don't know state yet
14:54:44 <benzrf> >_<
14:55:33 <Peaker> benzrf, well, let's stick to IO and Maybe then?
14:55:39 <benzrf> fft
14:55:44 <enthropy> tdammers: where are the FooData and BarData supposed to come from?
14:55:44 <enthropy> are those the same as Value aka. v["data"]?
14:55:45 <benzrf> maybe I'll just come back to this in a few years
14:55:52 <benzrf> when my brain is more fully developed
14:55:55 <benzrf> :S
14:56:12 <Peaker> benzrf, Learning is a difficult experiences...
14:56:27 <benzrf> Peaker: I know, and I've been trying to get this for about two hours now
14:56:30 <benzrf> I have to take a break
14:56:30 <benzrf> @_@
14:56:37 <Peaker> benzrf, Hah, two hours is nothing :)
14:56:43 <benzrf> straight?
14:56:43 <tdammers> enthropy: FooData and BarData can be arbitrary types, but they do have ToJSON and FromJSON instances
14:56:50 <benzrf> on a topic  you barely understand?
14:56:51 <benzrf> <_>
14:57:01 <tdammers> Value is just Data.Aeson.Value
14:57:20 <benzrf> anyway thanks
14:57:21 <benzrf> ttyl
14:57:22 <tdammers> v["data"] is JS syntax, actually
14:58:24 <tdammers> to clarify, if FooData serializes to something like { "food": "apples", "quantity": 123 }, then the entire foo event serializes as { "type": "foo", "data": { "food": "apples", "quantity": 123 } }
14:58:46 <tdammers> so what I need is a parseJSON that first looks at the "type" key to determine which kind of event to create
14:59:04 <tdammers> and then parse the right data type for that event type
15:00:05 <tdammers> the problem being that my mkSomethingEvent functions have different types
15:01:00 <tdammers> so I can't simply match type names with mk functions
15:01:02 <enthropy> supposing you used Read instead of aeson for the parsing, you'd do something like:
15:02:29 <enthropy> strToEvent str = case () of _ | (x,""):_ <- reads str -> mkFooEvent x; (x,""):_ <- reads str -> mkBarEvent x
15:03:03 <enthropy> strToEvent :: String -> Event
15:03:41 <elliott> why the useless case () of there?
15:03:48 <elliott> you can attach the guards to strToEvent
15:04:54 * enthropy thought it was going to be an expression at first
15:05:18 <tdammers> let me try and wrap my head around htat
15:06:26 <tdammers> so you pattern-match against the same pattern twice, and the type signature from the function you're calling inside the case branch is inferred back into the pattern match?
15:07:35 <enthropy> the two x have different types, if that's what you're asking
15:07:40 <tdammers> yeah
15:07:48 <enthropy> so some different code is actually run to do the parsing
15:08:04 <tdammers> yeah, I think I got that part
15:08:22 <enthropy> you don't have to do it with pattern guards
15:08:34 <tdammers> well, actually I don't need this trick at all, really
15:08:43 <tdammers> I can just case-switch on the "type" value
15:08:58 <tdammers> hold on
15:11:54 <tdammers> yeah, this should work
15:12:14 <tdammers> thanks!
15:20:25 <Pegleg> What if stars are just thunks waiting to be computed and the universe is only the illusion of being infinite
15:22:03 <tulcod> Pegleg: and then a black hole is when you evaluate _|_?
15:22:21 <Pegleg> Lool good one
15:23:26 <tulcod> and clearly wormholes would be oracles
15:24:23 <tulcod> and C the kuiper belt: you try to work your way around it, but it's just everywhere around our happy haskell home planet
15:24:30 <tulcod> wow, this actually works pretty well
15:24:41 <tulcod> sun=Hask
15:24:56 <Pegleg> Do you feel like programming changed your view on the world?
15:25:26 <tulcod> to say that that is the case would be an understatement
15:25:43 <tulcod> but i think that's true for all sciences
15:26:51 <Pegleg> Yes, thats very true. Have you ever thought about how you could generate Earth if you had to program it?
15:26:58 <Pegleg> Where would you start
15:27:01 <tulcod> Pegleg: but it's wonderfully connected, too: programming changed my view on the world, my view on the world my view on science, science my view on maths, maths my view on haskell, and haskell my view on programming, etc etc
15:27:32 <tulcod> Pegleg: generate as in simulate?
15:31:05 <Pegleg> Oh man I dont know if I should go this deep
15:32:06 <Pegleg> Say god is a programmer, he created an infinite list of worlds each one ran
15:32:08 <Pegleg> He designed the universe by using a list and filling it with random values. Each value was a seed that generated a specific amount of chemicals based on said seed. Why did the earth end up being the one with life on it? Was it all just random? If you used the same seed with the same amount of time given would the results be the same?
15:32:23 <Pegleg> ignore the first line the buffer didnt clear properly
15:32:57 <tulcod> no.
15:33:02 <Pegleg> just no lol
15:33:14 <tulcod> people misunderstand consciousness
15:33:14 <nbouscal> The seeds wouldn't be amounts of chemicals, they would be the constants in the universal laws.
15:33:27 <tulcod> once i have time, i'll write a book about it or whatever, but it's generally misunderstood
15:33:46 <tulcod> it's not that *because* you experience reality, that it is somehow the only one, or in another way unique
15:34:10 <tulcod> you experience it because that's what your brain's "consciousness process" tells you, roughly speaking
15:34:55 <tulcod> nothing that you feel makes this world unique
15:35:03 <man6>  watch movies while browsing p0rn, most user friendly interface, no spyware, totally FREE - http://www.6play.xxx
15:35:17 <Pegleg> lmao having a deep convo and that happens
15:35:20 <tulcod> wow, that's quite a change of topic
15:35:51 <Pegleg> I can't stop laughing lol
15:35:57 <Pegleg> Too funny
15:36:48 <tulcod> Pegleg: on a related note, here's a nice exercise: define "existence" of a universe
15:37:00 <nbouscal> I've been trying to figure out how to reconcile consciousness with the many-worlds interpretation. In terms of which world you experience. But if we go into that this should really move to haskell-blah :P
15:37:21 <tulcod> okay let's do it
15:37:50 <Pegleg> Alright moving sorry :-X
15:48:18 <Sonarpulse> does that HTTP package not support bytestrings?
15:50:20 <benzrf> are applicatives mostly just for mapping multi-arg functions?
15:50:26 <elliott> Sonarpulse: perhaps see http-conduit
15:50:46 <Sonarpulse> ok
15:50:52 <Sonarpulse> Network.HTTP.HandleStream might work too
15:52:38 <byorgey> benzrf: technically the answer to your question is probably "yes", but that's not how I would describe it, because the ability to "map multi-arg functions" turns out to be quite interesting and non-trivial
15:52:49 <benzrf> huh
15:53:13 <byorgey> so saying it is "just" for mapping multi-arg functions is like saying that cars are "just" for traveling at 100 km/hour
15:54:00 <byorgey> benzrf: the way in which it is interesting and non-trivial is precisely what Applicative encapsulates =)
15:54:11 <benzrf> hmm
15:54:46 <byorgey> basically, instead of needing a Functor you need a "monoidal" functor, that is, a way to combine two values of type  f a
15:55:30 <benzrf> monoids are like things that can be accumulated, right?
15:55:42 <benzrf> (i,e, that's what the typeclass represents)
15:57:00 <byorgey> benzrf: a monoid is a type  m with an associative binary operation (<>) :: m -> m -> m, and a special value  e :: m  which is the identity for (<>), that is,  e <> x = x <> e = x
15:57:07 <sclv> things that have a "join me with more" op
15:57:08 <benzrf> byorgey: I know that :P
15:57:18 <sclv> monoidal functors are sorta different tho
15:57:25 <sclv> they're f a -> f b -> f (a,b)
15:57:27 <benzrf> I meant, the idea they represent, rather than the mechanics
15:57:42 <sclv> so "monoidal" in functorland is closer to "pair"
15:57:46 <byorgey> benzrf: what I just said IS the idea they represent.
15:57:56 <byorgey> benzrf: that structure is often useful for accumulating things.
15:58:06 <sclv> since <> ranges over not a single "a" in haskell but all possible "a" in haskell
15:58:08 <byorgey> but "things that can be accumulated" is not the idea of monoids.
15:58:59 <sclv> also "multimap" under a functor gives rise to a notion of _closedness_
15:59:02 <sclv> ?ty ap
15:59:03 <lambdabot> Monad m => m (a -> b) -> m a -> m b
15:59:22 <elliott> class Functor f => Applicative f where aempty :: Monoid a => f a; aappend :: Monoid a => f a -> f a -> f a is sort of cool.
15:59:25 <sclv> so my functions from f a -> f b are _themselves_ captured under an f
15:59:27 <elliott> as a definition.
15:59:32 <benzrf> byorgey:mu head hurts
15:59:34 <benzrf> oops
15:59:40 <benzrf> not @byorgey
16:00:15 <benzrf> I think that I am probably not trying hard enough to understand
16:00:20 <benzrf> can you start over from the beginning?
16:00:22 <benzrf> I'm sorry :(
16:00:51 <sclv> ?ty liftA2
16:00:52 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
16:01:09 <sclv> ?ty liftA3
16:01:09 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
16:01:30 <sclv> ?ty liftA2 (,)
16:01:31 <lambdabot> Applicative f => f a -> f b -> f (a, b)
16:01:58 <benzrf> > liftA2 (,) $
16:01:59 <lambdabot>   <hint>:1:13:
16:01:59 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
16:02:00 <benzrf> oops
16:02:05 <sclv> ?ty fmap (uncurry ($)) . liftA2 (,)
16:02:06 <lambdabot> lexical error at character '\b'
16:02:27 <benzrf> > liftA2 (,) (Just 1) (Just 2)
16:02:29 <lambdabot>   Just (1,2)
16:02:41 <benzrf> > liftA2 (,) [1] [2]
16:02:42 <lambdabot>   [(1,2)]
16:02:55 <benzrf> > liftA2 (,) [1, 2, 3] [4, 5, 6]
16:02:56 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
16:03:00 <benzrf> :(
16:03:09 <sclv> ?ty liftA2 ($)
16:03:10 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
16:03:16 <benzrf> @src liftA2
16:03:16 <lambdabot> liftA2 f a b = f <$> a <*> b
16:03:26 <sclv> so that demonstrates that liftA2 gives rise to <*>, and <*> gives rise to liftA2
16:03:27 <benzrf> <_>
16:03:28 <benzrf> my brain
16:03:41 <benzrf> @src <*>
16:03:41 <lambdabot> Source not found. Sorry.
16:03:44 <benzrf> oops right
16:03:45 <nbouscal> benzrf: embrace that feeling, it's the feeling of neural pathways being rewritten with better ones
16:03:50 <sclv> so the amazing thing is if you think of liftA2 as "map2"
16:03:52 <benzrf> nbouscal: I know
16:03:56 <benzrf> I've had it enough :p
16:04:02 <sclv> then you get liftA3, liftA4… for free
16:04:44 <benzrf> how can I view instance implementations of typeclass functions
16:04:57 <benzrf> (with lambdabot)
16:05:05 <hpc> @src (->) fmap
16:05:05 <lambdabot> fmap = (.)
16:05:12 <benzrf> ah
16:05:20 <hpc> as with all things @src, things will often be missing or wrong
16:05:23 <hpc> @src sort
16:05:23 <lambdabot> sort = sortBy compare
16:05:23 <benzrf> ?src (.)
16:05:23 <lambdabot> (f . g) x = f (g x)
16:05:23 <lambdabot> NB: In lambdabot,  (.) = fmap
16:05:25 <benzrf> hm
16:05:33 <hpc> @src sortBy
16:05:33 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:05:59 <benzrf> @src Int (+)
16:05:59 <lambdabot> Source not found. I feel much better now.
16:06:01 <sclv> lambdabot's coverage of instances is extremly spotty
16:06:05 <hpc> that sortBy is enormously wrong -- the definition in base is a very nice implementation by augustss which is something like 20 lines long
16:06:06 <benzrf> hm
16:06:33 <benzrf> lambdabot: @src Maybe <*>
16:06:33 <lambdabot> Source not found. That's something I cannot allow to happen.
16:06:36 <benzrf> lambdabot: @src Maybe Int <*>
16:06:36 <lambdabot> Source not found. Abort, Retry, Panic?
16:06:37 <sclv> its barely useful for pedagogic instances even and i'd play with it in privmsg with lambdabot to figure out what i wanted
16:06:43 <sclv> before spamming up the channel
16:06:47 <benzrf> sorry
16:07:10 <hpc> if you need the source of an instance for any real purpose, use hoogle
16:07:10 <elliott>  @src is pretty bad.
16:07:41 <sclv> now we need to figure out who runs lambdabot to harass them to make it better… :-P
16:07:57 <elliott> I hear sclv does that.
16:08:03 <benzrf> @help
16:08:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:08:05 <hpc> oh, it was actually Thomas Nordin
16:08:08 <benzrf> .list
16:08:09 <elliott> actually it would be nice if @src just looked up the actual source.
16:08:12 <benzrf> ?list
16:08:12 <lambdabot> What module?  Try @listmodules for some ideas.
16:08:14 <elliott> and I do wonder how hard that would be.
16:08:16 <benzrf> @list
16:08:17 <lambdabot> What module?  Try @listmodules for some ideas.
16:08:19 <benzrf> @help list
16:08:19 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
16:08:32 <benzrf> @help list command
16:08:33 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
16:08:49 <sclv> benzrf: seriously you can /msg lambdabot to do this off channel
16:08:57 <benzrf> I know I keep forgetting
16:08:59 <benzrf> :S
16:32:09 <Ghoul_> Hi. I was trying to do more advanced cabal stuff so I wrote this config file
16:32:32 <Ghoul_> but when I type something like "cabal build debug" I  get "cabal: unrecognised flags: debug"
16:33:31 <Ghoul_> woops. Here it is: http://lpaste.net/91289
16:36:00 <monochrom> yes, "cabal build debug" is a syntax error. I am not sure what you mean. perhaps you mean "debug" is a flag in the *.cabal file and you want to turn it on? then it has to be done at "cabal configure", and the syntax is still not "cabal configure debug". use "cabal configure --help" to find the syntax.
16:36:24 <Ghoul_> monochrom: thanks
16:36:35 <Ghoul_> the cabal documentation has some links but they are broken...
16:53:55 <lcfrs> In the graph reduction diagrams in SPJ's "Implementation of functional PLs", what do the @-symbols mean?
17:17:59 <cartocor> Anyone out there?
17:22:25 <Gracenotes> cartocor: is it me you're looking for?
17:22:45 <cartocor> not particulary
17:23:06 <jfischoff> ask and you will recieve
17:23:28 <cartocor> I need some advice, which would be a good GUI library to implement Game of Life
17:24:33 <cartocor> I am a newbie and I've never program GUI before
17:24:47 <elliott> perhaps try the gloss library
17:24:48 <cartocor> so I need one that is easy to start with
17:25:29 <b2coutts> cartocor: for the record, you could pretty easily implement the game of life in text
17:25:37 <b2coutts> probably easier than using GUI
17:26:13 <Gracenotes> most GUI libraries will have to be used in the IO monad. For simple abstract shapes (rectancles, circles, etc.), GTK/Cairo is nice.
17:29:49 <byorgey> GTK/cairo can also be quite difficult to install.
17:30:16 <byorgey> oh, cartocor just quit =(
17:30:21 <byorgey> I was going to suggest http://apfelmus.nfshost.com/blog/2013/07/21-threepenny-gui-0-1.html
17:32:20 <Gracenotes> what's a nicer thing to call it besides the IO monad?
17:32:23 <Gracenotes> the IO context?
17:32:26 <Gracenotes> something like that
17:34:40 <cartocor> member:identifier:gracenotes i have to use gtk2hs?
17:35:14 <cartocor> I have already implemented a text version
17:35:14 <tito3> hello, i am hoping that someone can help me with what i want to do in haskell. I have an input list [a]. and i have a worker function [a]->[b]. so i can apply the input to the worker function to get the result of type [b]. however, i am supposed to have multiple workers, each taking one item from the list in turn and producing the result list. how can i do this apart from splitting the list in sublists and passed to the workers. i want the workers to get elem
17:35:54 <Saizan> tito3: you got cut off at "get elem"
17:36:42 <jj515> :k IO
17:36:42 <lambdabot> * -> *
17:36:50 <tito3> get element from the list in turn.
17:37:14 <Gracenotes> cartocor: if you want Cairo, although, byorgey recommended http://apfelmus.nfshost.com/blog/2013/07/21-threepenny-gui-0-1.html which is very lightweight
17:37:24 <Gracenotes> (it uses HTML/JS)
17:38:39 <tito3> any help? so basically i have an input list and several worker functions to do some computation on the items of the list.
17:38:41 <cartocor> Gracenotes: I will try this thank you
17:38:45 <Saizan> ?type \workers input -> concat (zipWith (\w e -> w [e]) workers input)
17:38:46 <lambdabot> [[t] -> [a]] -> [t] -> [a]
17:39:00 <Saizan> tito3: something like that?
17:39:49 <Saizan> ?type let f = \workers input -> concat (zipWith (\w e -> w [e]) workers input) in f [map (+1), map (*2)] [1..]
17:39:50 <lambdabot> (Enum a, Num a) => [a]
17:39:55 <Saizan> > let f = \workers input -> concat (zipWith (\w e -> w [e]) workers input) in f [map (+1), map (*2)] [1..]
17:39:55 <lambdabot>   [2,4]
17:40:05 <Saizan> oh, forgot the cycle
17:40:12 <Saizan> > let f = \workers input -> concat (zipWith (\w e -> w [e]) (cycle workers) input) in f [map (+1), map (*2)] [1..]
17:40:13 <lambdabot>   [2,4,4,8,6,12,8,16,10,20,12,24,14,28,16,32,18,36,20,40,22,44,24,48,26,52,28...
17:41:54 <tito3> Saizan: the worker does the same job but on different part of the list
17:42:26 <tito3> for e.g. worker1 operates on index 0..10, worker2 on 11,,20, etc
17:42:39 <tito3> but it does n't need to be in block
17:43:01 <tito3> workers can take items from the list in any order for e.g. in a round robin fashion
17:44:40 <Saizan> well, you'll have to split the list and feed them one way or another
17:44:54 <Saizan> how you want to do that depends on which slices you want to feed to them
17:45:28 <Saizan> to each
17:45:53 <tito3> i want the whole list processed by the workers, and workers can work on separate section of the list
17:45:59 <Saizan> tito3: i'd say go for the most obvious solution first, then see if it can get prettier
17:46:13 <tito3> yes i have done that
17:46:28 <tito3> the most obvious solution is to split the list into blocks
17:46:56 <tito3> then apply the worker on each block before concat the sublists again
17:46:57 <Saizan> then you should've started this question by pasting the code on lpaste.net :)
17:47:12 <tito3> ok
17:47:18 <Saizan> tito3: btw, there's probably not much to improve on that
17:48:19 <tito3> i don't want to split the list in blocks but rather distribute the item one by one to each worker (round robin)
17:48:54 <Saizan> why?
17:49:29 <Saizan> (but do show the code in the meantime)
17:50:06 <JoeyA> > 2^10
17:50:07 <lambdabot>   1024
17:50:08 <tito3> if i can do this in haskell, i would implement some kind of workers stealing job from a list (i'm sending the code)
17:51:11 <Gracenotes> have you looked at nested data parallelism?
17:51:32 <Gracenotes> work-stealing is a dynamic solution, whereas this is more of a static solution.
17:53:17 <tito3> dowork = concat . (map worker) . splitList
17:53:53 <Saizan> that's just one worker?
17:55:09 <tito3> so splitList returns a list of lists ([a] -> [[a]]), then map worker applies the worker function to each sublists, before the concatenation
17:56:05 <tito3> Gracenotes: how could i implement a dynamic solution?
17:56:31 <Gracenotes> messily
17:56:48 <tito3> and why is it hard to implement in haskell
17:57:00 <tito3> i was thinking it would be easy to express in haskell
17:57:29 <Gracenotes> afaik, it's hard to implement in any language
17:57:47 <Gracenotes> because of essential complexity, not accidental complexity
17:58:48 <tito3> could you be more specific, i still can't see
18:03:59 <zRecursive> > 2 ^^ 10
18:04:00 <lambdabot>   1024.0
18:04:13 <Gracenotes> any formulation of work-stealing seems to involve mutable state and communication across cores. It barely meets correctness requirements (i.e. could screw up if you forget an atomic somewhere)
18:04:54 <zRecursive> > 2 ** 10
18:04:54 <lambdabot>   1024.0
18:05:09 <Gracenotes> it's possible that you could express it nicely in Haskell, for which purity would certainly help make things less complicated, and compile it down to something a bit messier.
18:06:29 <Gracenotes> tito3: hm, this paper does seem to have work-stealing implemented in very few lines in Haskell. http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/monad-par.pdf
18:07:55 <Gracenotes> however, it seems like it might have enough overhead that it would perform better with larger-sized tasks.
18:08:55 <dcoutts_> tito3, Gracenotes: is this for pure evaluation or IO?
18:09:11 <tito3> pure evaluation
18:09:24 <bb010g> liftA3 is missing in lambdabot's @src.
18:09:38 <Gracenotes> SPJ's paper is "pure" (it uses unsafePerformIO to access concurrency primitives)
18:09:45 <tito3> thanks for pointing to the paper, but it seems the implementation uses IO
18:11:05 <dcoutts_> for pure, it's easy in terms of parListChunk n rseq
18:11:59 <dcoutts_> tito3: see http://hackage.haskell.org/packages/archive/parallel/3.2.0.3/doc/html/Control-Parallel-Strategies.html#v:parListChunk
18:12:04 <tito3> right
18:12:24 <tito3> but parListChunk is splitting the list in continuous block
18:12:36 <dcoutts_> you can do your own splitting if you want more control
18:12:43 <dcoutts_> and still use a strategy
18:13:13 <tito3> which i did "manually". but was just wondering if the elements of the list can be distributed to the worker one by one /9round robin)
18:13:39 <dcoutts_> you get that for free anyway
18:13:52 <dcoutts_> well, better, it uses a work stealing queue
18:15:16 <dcoutts_> tito3: you can see the code for parListChunk, it's just a combination of other strategies along with the particular approach to chunking
18:15:25 <dcoutts_> what kind of chunking do you want?
18:15:33 <tito3> well in the case of a list, it's easy to split into equal blocks, so this strategy is fine. but how about a tree? i wouldn't be able to split like list. so i need a way to distribute items as i traverse the tree
18:15:54 <dcoutts_> you mean you want to evaluate a tree rather than a list?
18:16:09 <tito3> yes
18:16:10 <dcoutts_> easy enough to write a strategy for that
18:18:29 <tito3> i could make the tree an instance of traversable, but i want to be able to process multiple items by one worker.
18:18:50 <dcoutts_> tito3: in case you were not aware, the parallel lib builds on the 'par' combinator which is implemented rather efficiently in the RTS (using a work-stealing queue that distributes the work to all idle cores)
18:19:29 <dcoutts_> tito3: see parTraversable
18:19:49 <crdueck> interesting that Control.Parallel.Strategies.runEval is just unsafePerformIO
18:20:33 <tito3> how would i do a chunking strategy on tree?
18:20:51 <dcoutts_> tito3: usual approach is to go down to a limited depth
18:29:18 <Modius> In haskellage is there a GUI lib that is known to work in linux *and* windows?
18:29:22 <Ghoul_> does anyone know how to get the right value out of a pipe from the pipes library if its trapped inside an EitherP?
18:29:30 <Modius> . . . with low grief.
18:29:43 <Ghoul_> the functions all seem to confuse me because they produce more EitherP-wrapped values as an output and not pure pipes..
18:30:13 <dcoutts_> Modius: gtk2hs works on both, though I can't really say it's without grief
18:30:16 <Modius> Maybe I should ask. . . "what's the least orphaned/forgotten Haskell GUI lib that can target windows"
18:30:46 * dcoutts_ supported a commercial app for three years using gtk2hs on windows
18:30:56 <crdueck> Ghoul_: are you using pipes 4.0?
18:31:11 <Ghoul_> 5.1
18:31:49 <Ghoul_> Oooh, sorry, 3.3
18:31:59 <Ghoul_> I have a lot of stuff open on hackage right now :S sorry for the mixup
18:32:03 <Modius> I just kicked myself off irc, if anyone said anything profound about haskell/gui please msg me
18:33:45 <geekosaur> I think the lowest grief cross platform library is one of the opengl interfaces
18:34:26 <Modius> . . . I was thinking for UI wrt dialogs and such - or you mean use OpenGL as a common baseline and build the GUI out of polygons?
18:34:30 <dmwit> Modius: gtk
18:34:52 <dmwit> There's very detailed instructions for building gtk2hs on Windows on the wiki and the official site.
18:35:11 <dmwit> tested by YT on several versions of Windows
18:36:52 <dcoutts_> Modius: here's an example http://www.haskell.org/haskellwiki/ThreadScope#Binary_releases
18:37:03 <geekosaur> GLFW-b is higher level than raw OpenGL but is reportedly easier to get usable on Windows than the other GUI toolits, which can be made to work but often require considerable banging of heads against walls
18:38:13 <geekosaur> (not to fault the gtk2hs and wxhaskell devs, but windows doesn't have the concept of standard places to put build-time libraries)
18:38:47 <dmwit> Yes, Windows is painful.
18:39:07 <dmwit> But it's roses and daisies compared to building gtk2hs on OSX...
18:39:14 <dcoutts_> :-)
18:42:22 <geekosaur> if you're following those so-called gtk build instructions...
18:47:31 <dpwright> If I have a simple function that takes one parameter and uses it twice, for example a square function square x = x * x
18:48:03 <dpwright> and I put that into "pointfree", it tells me I can use "join", ie "square = join (*)"
18:48:43 <dpwright> every reference I can find to "join" on the internet is about monads
18:49:34 <Clint> are you asking a question?
18:49:37 <dpwright> I'm pretty sure this is the same join I'm using
18:49:47 <dpwright> but I don't understand how it works
18:50:02 <dpwright> Clint: Yes, sorry, I got dragged away for a second so there was a big pause
18:50:26 <dpwright> there is no Monad involved in the type definition of my function
18:50:27 <Clint> dpwright: there's a Monad instance for ((->) r)
18:52:28 <augur> :t join
18:52:28 <lambdabot> Monad m => m (m a) -> m a
18:52:53 <augur> @pl \x -> x * x
18:52:53 <lambdabot> join (*)
18:53:12 <augur> :t join (*)
18:53:13 <lambdabot> Num a => a -> a
18:53:30 <augur> aha.
18:53:58 <augur> dpwright: so as clint says, there's a monad instance for ((->) r), so what's going on is
18:54:04 <Modius> You trying to talk me into or out of gtk?  Does it remain the best hope for multiplatform dialog boxes?
18:54:17 <augur> you have (*) :: Num a => a -> a -> a
18:54:26 <augur> which is to say, Num a => a -> (a -> a)
18:55:07 <augur> if m = (a ->)  (normally we have to write ((->) a)), then we have (*) :: Num a => m (m a)
18:55:45 <augur> dpwright: conveniently, monadic join for (a ->) is exactly what you
18:55:50 <augur> 'd expect:
18:55:54 <augur> join f x = f x x
18:57:23 <dpwright> augur, clint: aha!  thanks. Adding the brackets to (*) :: Num a => a -> (a -> a) helps to see it
18:57:33 <augur> :)
18:57:45 <augur> @src join
18:57:45 <lambdabot> join x =  x >>= id
18:57:48 <augur> lol
18:58:03 <augur> @src join :: a -> (a -> b)
18:58:03 <lambdabot> Source not found. Do you think like you type?
18:58:10 <augur> @src (join :: a -> (a -> b))
18:58:10 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:58:13 <augur> :(
19:06:45 <geekosaur> join isn't a class method; there are no optimizations for specific types, unless they take the form of RULES pragmas which @src wouldn't know about anyway
19:09:54 <NemesisD> has anyone sent email with haskell
19:12:35 <Nisstyre> NemesisD: I've looked at the SMTP module...
19:12:41 <Nisstyre> haven't really used it yet
19:12:56 <Nisstyre> did you have an actual question about it?
19:13:53 <startling> NemesisD: probably.
19:15:45 <nexx> he couldn't stand that
19:18:20 <JoeyA> NemesisD: smtp-mail is pretty simple.  It doesn't support TLS, though (it'd be pretty easy to add, but nobody's gotten around to it).
19:18:52 <JoeyA> mime-mail can talk to sendmail.
19:19:13 <JoeyA> But if it's a burden to set up sendmail, you'll need a library that can speak SMTP.
19:19:42 <geekosaur> one would hope it can talk to other MTAs as well
19:20:26 <geekosaur> exim and postfix both provide command line wrappers emulating the old sendmail binary for command line sending
19:20:58 <zRecursive> :t (<*)
19:20:58 <lambdabot> Applicative f => f a -> f b -> f a
19:32:32 <joelteon> why does ghc-mod output null bytes instead of newlines?
19:40:24 <geekosaur> probably so that it can do multiline output in a single "packet"
19:40:52 <joelteon> that's stupid
19:40:57 <dibblego> if you were to ask a student to write a network server, for the purpose of learning (not so much producing an application to deploy), which package(s) would you use?
19:42:12 <zRecursive> WAI
19:43:59 <zRecursive> @where wai
19:43:59 <lambdabot> I know nothing about wai.
19:44:14 <zRecursive> @where Network.Wai
19:44:14 <lambdabot> I know nothing about network.wai.
19:44:23 <zRecursive> @package Network.Wai
19:44:23 <lambdabot> http://hackage.haskell.org/package/Network.Wai
19:46:34 <geekosaur> pith @package isn't actually searchy
19:46:38 <geekosaur> *pity
19:46:43 <geekosaur> http://hackage.haskell.org/package/wai
19:46:58 <geekosaur> (and @hackage really)
19:48:22 <startling> geekosaur: yeah, it's terrible.
19:50:03 * hackagebot test-sandbox 0.0.1 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1 (BenjaminSurma)
19:55:03 * hackagebot test-framework-sandbox 0.0.1 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.0.1 (BenjaminSurma)
19:55:05 * hackagebot test-sandbox-hunit 0.0.1 - HUnit convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-hunit-0.0.1 (BenjaminSurma)
19:55:07 * hackagebot test-sandbox-quickcheck 0.0.1 - QuickCheck convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-quickcheck-0.0.1 (BenjaminSurma)
20:00:22 <lispy> it's hackage upload sunday
20:15:25 * zRecursive hard to pick right package(s) though
20:24:10 <Nisstyre> Has there been any research done on purely Haskell crypto implementations wrt side-channel attacks? I imagine lazy evaluation makes it hard to reason about memory usage sidechannels
20:26:20 <startling> Nisstyre: I've been wondering the same thing.
20:26:50 <nbouscal> I'd be very interested in that too.
20:27:08 <Nisstyre> startling: I'm asking because I was musing about building a file integrity analysis tool
20:27:17 <Nisstyre> but I'd need to make sure the database encryption was secure
20:27:46 <nbouscal> Most crypto stuff in Haskell is probably actually strictly evaluated though, since ByteStrings are strict by default
20:27:53 <Nisstyre> good point
20:28:29 <tswett> "Lag: 134.8 s" – I have no idea whether or not my most recent messages got through, nor whether anyone responded. :D (Don't tell me; by the time I get your response, I'll already know the answer.)
20:29:22 <Modius> Guessing noone's tripping over themselves to get vty and terminfo working on win32 too?  :(
20:29:50 <geekosaur> terminfo can't really work on win32
20:29:54 <startling> nbouscal: that doesn't guarantee that the same things get evaluated for all keys though
20:31:01 <geekosaur> windows isn't very good at replacement terminals, which you would need for terminfo to work because the terminal control stuff isn't escape sequences, it's magic syscalls that don't behave anything like terminfo expects
20:31:26 <geekosaur> and there isn't a properly working pty mechanism for you to write your own replacemnt terminal
20:31:27 <startling> it's too bad escape sequences are the unix way. :(
20:31:43 <Nisstyre> startling: it looks like there was a thread about it on the mailing list but I can't access it because the site is broken
20:33:28 <zRecursive> :t flip id
20:33:29 <lambdabot> b -> (b -> c) -> c
20:33:49 <startling> Nisstyre: :D
20:33:54 <Nisstyre> startling: maybe it'd be best to just push out crypto work to gpg or something
20:35:34 <Nisstyre> even so, might still be possible to analyze sidechannels since the data would go through the Haskell code
20:35:44 <Nisstyre> but then it'd be my responsibility to make sure it doesn't leak anything
20:36:10 <Ghoul_> is there some alternative to this?
20:36:12 <Ghoul_> either (\_ -> " timed out.") (\_ -> " closed.") res
20:38:08 <tswett> Nope, my messages didn't get through. Don't worry, they weren't important.
20:38:13 <nbouscal> Nisstyre: I think "don't build your own crypto" is almost always the recommended/safest path
20:38:25 <Nisstyre> nbouscal: yeah, definitely
20:38:49 <Nisstyre> nbouscal: I think I'll just build a threat model around using something like gpg for encryption
20:50:17 <Sonarpul`> can somebody help me fix a fromJSON instance?
20:50:24 <Sonarpulse> https://github.com/Ericson2314/hasnip
20:50:47 <Sonarpulse> specifically https://github.com/Ericson2314/hasnip/blob/master/src/HaSnip/ServerList/Parse.hs
20:51:48 <Sonarpulse> and I think it's the fromJSON for the SockAddr
20:53:55 <pentace> What's the problem with that?
20:56:06 <Sonarpulse> pentance: reading the severs always returns nothing
20:56:08 <Sonarpulse> try building the program and running it
20:56:36 <Sonarpulse> it will always print []
20:57:28 <orospakr> hey, what is the "." composition syntax element (keyword?) called?  Rather to my surprise, it does not show up on http://www.haskell.org/haskellwiki/Keywords
20:57:32 <Sonarpulse> I tried decode . encode in the REPL, and did some other testes so I am sure the problem is decoding
20:57:36 <Sonarpulse> ^ pentace
20:58:08 <orospakr> I realize that it is effectively ∘ from algebra.
20:58:24 <Sonarpulse> ^ function composition?
20:58:42 <Sonarpulse> also check out Control.Category and Category Theory
20:59:08 <dibblego> orospakr: it is function composition. It is not syntax nor a keyword, just a regular function.
20:59:11 <orospakr> yeah, I know it's function composition, but I'm wondering what the syntax element itself is called.
20:59:30 <dibblego> orospakr: "the identifier name of a function"
20:59:34 <orospakr> mostly so I can find haskell-specific implementation documentation about it.
20:59:54 <Nisstyre> :t (.)
20:59:55 <lambdabot> (b -> c) -> (a -> b) -> a -> c
21:00:03 <orospakr> oho
21:00:07 <Nisstyre> :i (.)
21:00:14 <Nisstyre> oh that doesn't work with lambdabot
21:00:17 <Nisstyre> but yeah
21:00:19 <dibblego> orospakr: :info (.) -- at ghci
21:00:30 <orospakr> it is itself a higher order function. I thought it was a primitive itself.
21:00:32 <orospakr> neat!
21:00:55 <orospakr> thanks, guys. :)
21:00:58 <Nisstyre> > let a . b = a + b in 2 . 4
21:00:59 <lambdabot>   6
21:01:07 <pentace> Sonarpulse: Ah sorry, there are so many package dependencies, I think this would take too much time now
21:01:34 <Sonarpulse> if it makes a difference, it still builds quickly
21:01:48 <Sonarpulse> also chances are you already have most of them installe
21:01:50 <Sonarpulse> d
21:02:13 <Sonarpulse> ByteString, Aeson, Text, at least
21:02:34 <Sonarpulse> Network too
21:12:49 <pentace> Sonarpulse: Why do you drop 5 characters from post?
21:19:31 <Sonarpulse> shold be 6 characters, whoops
21:19:33 <Sonarpulse> pentace
21:19:38 <Sonarpulse> aos://
21:20:08 <pentace> But splitAt already does that, no?
21:20:09 <Sonarpulse> that was it
21:20:17 <Sonarpulse> yeah
21:20:19 <Sonarpulse> split at does that
21:20:30 <Sonarpulse> oh waht
21:20:32 <Sonarpulse> you are right
21:20:35 <Sonarpulse> wow
21:21:06 <pentace> Also, do you get the correct port number in the parsed data?
21:21:07 * Sonarpulse facepalm
21:21:12 <Sonarpulse> I am trying that
21:21:17 <Sonarpulse> endianness issues might arise
21:21:45 <carter> theres no structure to all the num type classes :(
21:21:53 <carter> its driving me mad
21:22:57 <johnw> what is considered to be the alternative to DatatypeContexts?
21:23:08 <carter> johnw aren't those existential types?
21:23:14 <Sonarpulse> functional dependancies says the wiki
21:23:18 <carter> or am I mixing up some nuance
21:23:32 <awruef> hi carter
21:23:42 <johnw> well, I'm defining an ADT which specifies a collection of functions that comprise an interface, where I don't think type classes are necessarily needed
21:23:44 <Sonarpulse> existentials should work too
21:24:21 <johnw> I want them all to return effectively: ErrorT e m a.  I was thinking that instead of forcing ErrorT to be at the top of the transformer stack, I could use MonadError e m => m a instead
21:24:25 <carter> hey
21:24:44 <Sonarpulse> pentace: port numbers not right
21:24:53 <Sonarpulse> but hopefully I can figure that out
21:25:13 <johnw> is there a way to express that constraint over the whole ADT?  (Which is exactly what DatatypeContexts gives me)
21:25:48 <johnw> oh, wait
21:25:54 <johnw> I can just use a constraint on the right-hand side!
21:26:00 <pentace> Sonarpulse: IIRC, you shouldn't use the PortNum constructor directly but fromInteger/toEnum or one of these functions
21:26:01 <johnw> since I'm already using RankNTypes in this module
21:26:07 <Sonarpulse> pentace: ok
21:26:48 <Sonarpulse> johnw: typeclass with explicit dictionary argument for first-class implementations should work
21:27:02 <johnw> Sonarpulse: this type-checked: https://gist.github.com/6102136
21:27:38 <johnw> the real test will be when I try to use one of its inhabitants
21:27:46 <tabemann> is there a term for CPS, except when it's not really CPS because you're really generating new monad values and sequencing with them rather than passing closures and applying them?
21:27:48 <Sonarpulse> that seems fine
21:28:02 <johnw> tabemann: code example?
21:28:02 <Sonarpulse> accumulator passing style?
21:29:04 <tabemann> well I'm not exactly passing *in* actions, but basically the entire control flow of my runtime is basically one function sequencing actions until a final action that it passes off control ti
21:29:39 <Sonarpulse> pentace: perfect! now I just need to add some quickchecks
21:29:46 <Sonarpulse> so this won't crop up again
21:29:47 <hpaste> tabemann pasted “Example (not complete)” at http://lpaste.net/91290
21:29:55 <Sonarpulse> I'll drop your name in the git commit
21:29:58 <Sonarpulse> thanks again!
21:30:22 <pentace> you're welcome :)
21:35:05 * hackagebot test-sandbox 0.0.1.1 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.1 (BenjaminSurma)
21:35:07 * hackagebot test-framework-sandbox 0.0.1.1 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.0.1.1 (BenjaminSurma)
21:35:10 <tabemann> hmm, this style means that certain things become more flexible, i.e. passing on control in a function just becomes >>= nextThingToDo, but it is more error-prone, in that if any native function forgets to pass on control to something else, the runtime will come to a grinding halt - something that should only occur on A) thread termination or B) exception raised with *no* exception handlers, not even those added by the runti
21:35:10 <tabemann> me itself
21:36:43 <Sonarpulse> there is the cont monad in haskell too
21:36:58 <Sonarpulse> I haven't used it, though
21:37:25 <tabemann> never used it myself
21:38:10 <tabemann> I'm notionally passing around control state via my Scheme runtime state (which is basically a set of stacks, including a return stack)
21:42:26 <Sonarpulse> pentace: well I am not quite done
21:42:36 <Sonarpulse> http is returning nothing for some reason
21:43:23 <Sonarpulse> https://github.com/Ericson2314/hasnip/blob/master/src/HaSnip/ServerList.hs
21:50:05 * hackagebot binary-conduit 1.2 - data serialization/deserialization conduit library  http://hackage.haskell.org/package/binary-conduit-1.2 (AlexanderVershilov)
21:50:37 <pentace> Sonarpulse: You mean getBnS?
21:53:20 <Sonarpulse> yeah
21:53:45 <Sonarpulse> well getListing does the work
21:53:53 <Sonarpulse> getBnS jsut builds the URI, which I am sure is valid
21:53:54 <johnw> i use Cont from time to time
21:56:33 <pentace> parseAbsoluteURI works for me
21:56:58 <zRecursive> @hoogle Cont
21:56:58 <lambdabot> Data.Char Control :: GeneralCategory
21:56:58 <lambdabot> Language.Haskell.TH.Syntax ConT :: Name -> Type
21:56:58 <lambdabot> Language.Haskell.TH ConT :: Name -> Type
21:57:23 <zRecursive> @hoogle Control.Cont
21:57:24 <lambdabot> Control.Monad.Trans.Cont type Cont r = ContT r Identity
21:57:24 <lambdabot> Control.Monad.Cont type Cont r = ContT r Identity
21:57:24 <lambdabot> Control.Monad.Trans.Cont cont :: ((a -> r) -> r) -> Cont r a
22:11:48 <johnw> what do people think about the name "pass" for "return ()"?
22:17:30 <Ralith> johnw: why does it need a name?
22:18:46 <c_wraith> johnw: it collides with several libraries that use "pass" to mean mzero
22:18:58 <c_wraith> and that's a *very* bad collision
22:18:59 <johnw> Ralith: just convenience
22:19:02 <johnw> ah, ok
22:21:01 <shachaf> johnw: Hmm... I was thinking const () should have a name (roconnor suggested "obvious"), but pure () is a generalization.
22:21:42 <shachaf> obvious :: Applicative f => f () (or some other name) would be generally nice to have.
22:23:11 <pentace> @hoogle Functor f => f a -> f ()
22:23:12 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
22:23:12 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
22:23:12 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
22:23:25 <pentace> Oh, there's void
22:23:33 <lispy> carter_away: as a teaching moment, you might like the first FAQ entry: http://irc.mzl.fi/
22:24:42 <pentace> not im my base apparently
22:25:04 <shachaf> No, void is something else.
22:25:24 <shachaf> Oh, well, void is the thing you asked for.
22:25:51 <shachaf> It would be nice if void guaranteed in its type that it actually uses its argument (rather than being const (pure ())).
22:26:22 <shachaf> Is there a variation of Functor or something that would make that nicely expressible in Haskell?
22:27:02 <adelbertc> newbie to haskell question: is Real World Haskell still "relevant"? looking for a good introductory book that has exercises in it, i have previous experience with fp a la scala/scalaz
22:27:35 <enthropy> shachaf: const (pure ()) would be  Applicative f => f a -> f ()
22:27:57 <m3ga> adelbertc: 'learn you a haskell' is probably a better intro. its more recent and less dated.
22:28:01 <pentace> shachaf: What do you mean by "use its argument" here?
22:28:40 <m3ga> adelbertc: sorry, i mis-read your 'have previous epxerience' as 'have no ...'
22:29:04 <shachaf> enthropy: Yes, OK, Functor guarantees it.
22:29:04 <m3ga> RWH is good, but a little dated. exceptions have changed as has some other stuff.
22:29:11 <adelbertc> m3ga: :-) does your answer then change?
22:29:22 <shachaf> enthropy: I guess that's actually good enough in this case. It's the same trick lenses use.
22:29:35 <adelbertc> i read a few cahpters of LYAH a few months back, was pretty good but looking for something with exercises. also LYAH was a bit slow for me, but perhaps it picks up later on
22:30:59 <enthropy> adelbertc: some libraries have changed slightly since RWH was written (mtl-1 vs. mtl-2), but I don't think the differences are enough to make the exercises useless
22:31:39 <adelbertc> coolio
22:31:52 <m3ga> enthropy: def. not useless, but a little frustrating. eg exceptions have changed.
22:33:29 <byorgey> adelbertc: if you're looking for exercises, you might like  http://www.cis.upenn.edu/~cis194/
22:33:59 <adelbertc> byorgey: very cool, bookmarked - thanks!
22:34:25 <byorgey> well, in particular, http://www.cis.upenn.edu/~cis194/lectures.html
22:53:07 <zacts> are haskell programs stateless?
22:53:51 <Aorion> Hello
22:53:57 <ezrios> byorgey: wow, I wish my uni offered a course like that
22:54:16 <zacts> ezrios: what course, I've just joined in on the conversation.
22:54:17 <zacts> ?
22:54:19 <Aorion> I am trying without success to pattern match an item in a list, which doesn't seem to be a covered case in most books i've found
22:54:19 <joelteon> zacts: what do you mean by stateless
22:54:24 <ezrios> zacts: http://www.cis.upenn.edu/~cis194/lectures.html
22:55:17 <zacts> neat, thanks
22:55:29 <Aorion> My function is here - http://pastebin.com/8saUARmX
22:55:32 <mauke> The paste 8saUARmX has been copied to http://lpaste.net/91293
22:55:44 <ezrios> ooh, a bioinformatician?
22:55:48 <Aorion> I was reading the "Gentle introduction to haskell" book
22:56:07 <zacts> joelteon: no side effects, sequence, etc.. ? :-) I'm still learning this stuff.
22:56:13 <Aorion> i am certainly not a bioinformatician, i just happen to like the rosalind problem set
22:56:23 <zacts> I mean haskell is impossible without monads right, for practical programs?
22:56:59 <ezrios> Aorion: interesting, thanks for bringing that up
22:57:03 <shachaf> "monads" have nothing to do with state, and Haskell would be a perfectly usable program without them.
22:57:05 <startling> zacts: not really.
22:57:15 <shachaf> Aorion: You should paste your error too.
22:57:17 <ezrios> I am a bioinformatics undergrad (though I lean very heavily towards the compsci side of the spectrum)
22:57:20 <ezrios> rosalind looks neat
22:57:23 <zacts> ok, well. I'll read more about haskell before posting more questions.
22:57:25 <Aorion> ahh. sorry, the error is at the 'do'
22:57:31 <shachaf> zacts: See the FAQ.
22:57:31 <startling> zacts: "Monad" just provides a nice interface for a lot of things.
22:57:34 <shachaf> @where faq
22:57:34 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:57:57 <shachaf> Aorion: That's not an error.
22:58:07 <startling> zacts: IO is an instance of Monad, so we can use that interface to do IO operations. We could do them without Monad, it just wouldn't be as nice to write.
22:58:21 <Aorion> but you can run it at http://ideone.com/S5660J
22:58:21 <startling> e.g. for certain operations we could use Applicative instead.
22:58:39 <Aorion> well, it complains of syntax errors
22:59:17 <zacts> ok, thanks
22:59:35 <shachaf> Aoirio: I know I can run it. I want you to tell us what the error is because that's the good way to ask a question.
22:59:46 <shachaf> But that ideone.com link works, I guess.
22:59:54 <Aorion> Here's my problem - i know the code works, but it returns "Maybe Char". I am trying to fix that by using pattern matching to default to an error if the given char is not a key in the lookup table.
22:59:59 <shachaf> Though that link is saying the error is at line 7.
23:00:01 <startling> zacts, the thing about State is it doesn't do anything magic -- it just abstracts the pattern of "take the state as an argument, output the modified state as part of the return value" and provides a nice interface for it.
23:00:06 * hackagebot test-sandbox 0.0.1.2 - Sandbox for system tests  http://hackage.haskell.org/package/test-sandbox-0.0.1.2 (BenjaminSurma)
23:00:09 * hackagebot test-sandbox-quickcheck 0.0.1.2 - QuickCheck convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-quickcheck-0.0.1.2 (BenjaminSurma)
23:00:09 <ezrios> Aorion: it should be otherwise =
23:00:11 * hackagebot test-sandbox-hunit 0.0.1.2 - HUnit convenience functions for use with test-sandbox  http://hackage.haskell.org/package/test-sandbox-hunit-0.0.1.2 (BenjaminSurma)
23:00:12 <ezrios> not just "otherwise"
23:00:13 * hackagebot test-framework-sandbox 0.0.1.2 - test-sandbox support for the test-framework package  http://hackage.haskell.org/package/test-framework-sandbox-0.0.1.2 (BenjaminSurma)
23:00:14 <startling> State is just functions.
23:00:20 <shachaf> Aorio: You can't know the code works because it doesn't. :-)
23:00:29 <shachaf> AOrio: The syntax for guards is "| ... = ..."
23:00:31 <ezrios> otherwise, for all intents and purposes, just means "true"
23:00:36 <shachaf> You have "| otherwise ...", no =
23:00:41 <shachaf> That's one error.
23:00:58 <shachaf> Another error is that it's "`isInfixOf`", not "isInfixOf".
23:01:16 <zacts> well, I can't wait until I learn scheme because next I'm going to tackle haskell
23:01:33 <Aorion> shachaf: what error is that?
23:01:43 <zacts> and I really can't wait until I learn haskell.
23:01:44 <Aorion> there are no quotes
23:01:45 <shachaf> I mean an error in your code, not an error GHC produces.
23:01:53 <shachaf> No, the quotes were mine.
23:01:54 <ezrios> zacts: I wholeheartedly recommend that you learn scheme
23:02:08 <ezrios> but there's nothing stopping you from learning haskell now, aside from time constraints I guess
23:02:14 <Aorion> ...
23:02:19 <Aorion> something is very fucked, one sec
23:02:24 <shachaf> Actually, there are more errors than non-errors here...
23:02:34 <zacts> cool
23:02:35 <shachaf> The biggest error is that you shouldn't be writing this function in the first place. :-)
23:02:44 <ezrios> is that function even of type Char -> Char?
23:03:18 <Aorion> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#v:isInfixOf
23:03:28 <Aorion> this, what the hell? am I not able to use functions in base?
23:03:47 <shachaf> I cannot help you.
23:04:39 <ezrios> Aorion: why are you using do notation
23:06:01 <Aorion> okay. I made some changes, to reduce my idiocity
23:06:55 <Aorion> http://pastebin.com/15R3ZhtF
23:06:57 <mauke> The paste 15R3ZhtF has been copied to http://lpaste.net/91294
23:07:07 <ezrios> amazing how fast it does that
23:07:20 <Aorion> yes, amazing
23:07:23 <Aorion> should I be using lpaste?
23:07:33 <Aorion> it's a little quieter
23:07:38 <Aorion> visually
23:07:55 <Aorion> anyways, my problem is that i've handled all cases of input, so it shouldn't be maybe
23:07:58 <Aorion> it should be char
23:08:17 <Aorion> but it is Maybe Char, even though there is no way to generate a Nothing value
23:08:39 <Aorion> and so it complains that I can't map it through a string because it is not a char, it is a maybe char
23:10:01 <ezrios> @t lookup
23:10:01 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
23:10:06 <ezrios> uhhh
23:10:12 <ezrios> I forget how to lambdabot
23:10:18 <conehead> @type lookup
23:10:18 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
23:10:25 <ezrios> conehead: thanks
23:10:32 <conehead> I think @ty also works
23:15:56 <Aorion> okay, so I'm out of ideas. How can I use a lookup to map characters in a string to something else, if the result is a maybe? is there a way to suppress the maybe?
23:16:56 <startling> Aorion: what do you want to do if there is no such entry in your map?
23:17:15 <Aorion> startling: that is not an option, it's impossible
23:17:24 <Aorion> for one, the input is sanitized
23:17:39 <Aorion> second, using pattern matching, it will only lookup if the key is available
23:17:45 <Aorion> otherwise, error
23:17:46 <startling> Aorion: that's silly.
23:18:06 <Aorion> how can I know that it's silly? this case is not handled in any of the haskell books I've read
23:18:07 <startling> Aorion: the thing to do is lookup, and then error if it's Nothing.
23:18:32 <startling> (assuming you don't literally mean the function 'error', which is to be avoided at all costs)
23:18:37 <Aorion> well
23:18:44 <Aorion> let me try that.
23:19:24 <startling> the easy way is to use "case"; the nicer way is to use "maybe".
23:19:28 <startling> :t maybe
23:19:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
23:22:57 <Aorion> startling that doesn't work.
23:23:28 <Aorion> http://lpaste.net/91297
23:23:49 <Aorion> if I just use 'else val' then val is still a Maybe Char even though I checked it
23:23:54 <Aorion> so how do I convert Maybe Char to Char?
23:24:15 <startling> Aorion, "val" isn't going to magically change
23:24:18 <Aorion> I mean, my understanding is that Maybe Char is either a char or nothing
23:24:39 <tiffany> you could set a default value to return on Nothing
23:24:42 <startling> Aorion, this isn't something that you can do nicely with "if"
23:24:52 <tiffany> which, as far as you're concerned, will never happen
23:25:02 <Aorion> can you point me in a good direction for materials on this?
23:25:21 <startling> Aorion, you want "case lookup x mylist of Nothing -> ...; Just v -> ...;
23:25:47 <Gracenotes> I like me a case statement. maybe 'maybe' if I'm golfing.
23:26:06 <Aorion> why do i need a case statement?
23:26:11 <Tene> Aorion: fromJust will do what you said you wanted, returning the value if present, and aborting if not.
23:26:12 <Gracenotes> also, what's with the do notation
23:26:15 <startling> Aorion: because you want to deconstruct the Maybe.
23:26:28 <startling> Aorion, also, yes, "do" notation is unnecessary
23:26:38 <startling> Aorion: and I think you don't quite understand how "if" works either.
23:27:23 <Aorion> here's my understanding: a function returning "Maybe Char" returns either a char or Nothing. i've established that it isn't Nothing. So how do I return Char, the subset of Maybe Char that i've narrowed it down to? It's a stupid simple operation with no simple answer
23:27:29 <Gracenotes> the Haskell-y way to do it, honestly, would be to parse the string into a datatype that only allows ATCG. The parsing could fail; the complementation cannot fail.
23:27:32 <startling> Aorion: no
23:27:46 <startling> Aorion: a function returning "Maybe Char" returns "Nothing" or "Just c" for some Char c.
23:28:13 <startling> Aorion: calm down. there's a simple answer, you're just deep in a hole of misunderstanding. Don't worry, you'll get it in a minute.
23:28:16 <Aorion> so how do I extract C from "Just C"?
23:28:34 <startling> Aorion, "case ... of Nothing -> ...; Just c -> ...
23:28:35 <startling> "
23:28:40 <Gracenotes> aren't you worried about runtime errors at all? Things blowing up in your face?
23:29:05 <Aorion> if it's invalid input, error out describing the problem and let the user fix it
23:29:12 <Aorion> garbage in, garbage out
23:29:33 <papyrus> hi, i have a question.
23:29:35 <papyrus> test :: Shape -> Int -- Shape is typeclass
23:29:40 <Aorion> i am not in a habit of writing programs to "make it work", i try to write programs that work correctly
23:29:44 <papyrus> test x = undefined
23:30:00 <papyrus> is not possible ?
23:30:11 <startling> papyrus, you need to read up on typeclasses.
23:30:20 <Gracenotes> no one writes programs that work correctly. not when they get beyond a few lines, and definitely not when they get beyond a few hundred lines.
23:30:45 <papyrus> i think i am understanding typeclass.
23:30:51 <startling> Aorion, OK. The 'error' approach is fine for now, but I'll show you a nicer way to do it in a second if you like.
23:31:07 <Aorion> startling: the error approach isn't working anyways
23:31:08 <startling> papyrus: "test :: Shape -> Int -- Shape is typeclass" is not something that makes sense.
23:31:19 <startling> Aorion, yeah. so have you tried using a "case"?
23:31:19 <Aorion> because apparently I need a special syntax for converting maybe char to char
23:31:26 <Aorion> i am looking up how to do this
23:31:29 <papyrus> ok. thanks a log. startling.
23:31:34 <Gracenotes> garbage out is okay, but don't serve it on a platter before you figure out if it's garbage, essentially.
23:31:37 <papyrus> thanks a lot
23:31:52 <zvrba> Aorion: pattern matching!
23:32:11 <Aorion> zvrba i am doing pattern matching
23:32:18 <Aorion> did at one point
23:32:18 <startling> Aorion: it's not special syntax for Maybe, it's syntax for dispatching on different constructors (which is exactly what you want right now).
23:32:27 <Tene> Aorion: You've already been told three ways to do this.
23:32:42 <Aorion> Tene: give me a second, I'm looking them up
23:32:45 <Aorion> i am not fluent
23:32:48 <Aorion> by a long shot
23:32:50 <Tene> That must be frustrating. :(
23:32:52 <Aorion> that's the whole point
23:33:18 <Tene> One is the 'maybe' function.  Look at its type:
23:33:29 <Tene> :t maybe
23:33:30 <lambdabot> b -> (a -> b) -> Maybe a -> b
23:33:36 <zvrba> anybody reasonably fluent in category theory here?
23:33:52 <Gracenotes> datatype Nucleotide = Adenine | Thymine | Cytosine | Guanine. type DNA = [Nucleotide]. parseDNA :: String -> Maybe DNA. complementDNA :: DNA -> DNA. complementNucleotide :: Nucleotide -> Nucleotide.
23:34:13 <ezrios> Gracenotes: I like that approach.
23:34:15 <Gracenotes> ...another design direction.
23:34:19 <Tene> You give it a default value, a function, a maybe, and it gives you a value; the default if you have Nothing, and the original value run through the function if you had a value.
23:34:31 <Tene> If you don't want to transform it, you can use 'id' of course.
23:35:16 <zvrba> hmm, I'd better join #Math :-)
23:35:30 <startling> the simplest approach is "substitute :: Char -> Maybe Char" and "transform = mapM substitute", I think.
23:35:39 <Gracenotes> zvrba: how complicated category theory?
23:36:20 <PatrickRobotham> zvrba: I know about functors and natural transformations
23:36:21 <zvrba> Gracenotes: hah. depends. i've read the basic axiom for what is needed for a collection of arrows and objects to be a category.
23:36:50 <zvrba> Gracenotes: and I got stumped over one detail: it is nowhere explained what it means for two arrows to be equal. what does it mean?
23:36:55 <zvrba> how is arrow equality defined?
23:36:56 <infina> Trying to install haskell on FreeBSD 9.1, but the GHC port keeps failing on HC [stage 0] compiler/stage1/build/DynFlags.o, anyone know what I can do to fix it?
23:37:10 <zvrba> like in associativity law: f o (g o h) = (f o g) o h
23:37:15 <zvrba> but what does = signify there?
23:37:25 <zvrba> when we cannot "look into" the objects?
23:38:57 <Gracenotes> zvrba: just set-theoretic identity, I think
23:38:58 <startling> "is equivalent to"
23:40:22 <Ezku> zvrba: there's ##categorytheory if you're so inclined
23:41:27 <Aorion> okay
23:41:34 <Aorion> i found the stupid simple answer I was looking for
23:41:50 <Aorion> rather than case, or anything else, just use 'fromJust' to convert Maybe Char -> Char
23:41:58 <Aorion> bam, done, easy
23:42:11 <startling> Aorion: yes, the obvious way is to ignore everything everyone has said here.
23:42:31 <Aorion> how is that any different?
23:43:16 <ezrios> Aorion: your misunderstanding of Maybe will bite you in the ass sooner or later.
23:43:20 <Tene> Aorion: Yes, I already mentioned fromJust.
23:43:33 <Tene> 23:25 < Tene> Aorion: fromJust will do what you said you wanted, returning the value if present, and aborting if not.
23:43:52 <Aorion> you expected me to use a case statement. Case is for when you have a number of cases (greater than 2). what is the benefit of using case when if does the exact same thing?
23:43:59 <Gracenotes> well, people coming from imperative languages are used to code being fragile and exploding around every corner.
23:44:26 <Aorion> Tene: I had like 4 answers and was off in the weeds looking for documentation to support them when you said that
23:44:26 <Aorion> sorry
23:44:32 <Gracenotes> granted, that sounded a bit cargo-cultish. >.>
23:44:49 <ezrios> Aorion: pattern matching.
23:45:30 <Aorion> Gracenotes: how so? I am checking bounds. For the set of all possible inputs of the correct type, either you did it right and it works or you are told that there is invalid input and you need to fix it
23:45:31 <startling> Aorion: "if" does not do the same thing as "case".
23:45:42 <startling> Aorion: it's not the same as case/switch from C-like languages.
23:45:59 <Ezku> zvrba: my very informal understanding is that an arrow is just a statement of there being a way to go from an object in a category to another. An arrow is the same as another, then, if the source and target objects are the same.
23:46:19 <zvrba> Ezku: no, because you can have multiple, different arrows between the same pair of objects.
23:46:46 <Ezku> zvrba: is that true?
23:46:50 <zvrba> yes
23:47:02 <Ezku> cool, I'd like to know why that is :)
23:47:15 <PatrickRobotham> Ezku: Well, do you recall the definition of a category?
23:47:36 <PatrickRobotham> Ezku: Alternatively, do you know about the category of sets or the category Hask?
23:48:10 <roboguy_> Aorion: since there are so few values, I personally wouldn't use lookup. I'd just pattern match on the possibilities
23:48:31 <PatrickRobotham> @type toUpper
23:48:32 <lambdabot> Char -> Char
23:48:41 <Gracenotes> Aorion: parsing logic and complementation logic should by kept separate, I think. Total functions are better than partial ones; they're also optimized a bit nicer.
23:49:04 <Aorion> roboguy: well, I learned how to solve this particular problem, so i'd say it's a win
23:49:11 <zRecursive> > toUpper 'a'
23:49:12 <lambdabot>   'A'
23:49:13 <PatrickRobotham> Ezku: In the category Hask, objects are haskell types and arrows from A to B is a function with type A -> B.
23:49:22 <Aorion> I already knew pattern-matching, now I know those and lookup
23:49:25 <Gracenotes> or, can be. depends on demand analysis.
23:49:38 <startling> Aorion, I might be wrong, but I don't think you really did.
23:49:39 <Aorion> now, I just looked on various haskell wikis and found that... case is basically a string of if then elses
23:49:41 <PatrickRobotham> Ezku: toUpper and id have the same source and target (char), but are clearly different.
23:49:47 <startling> Aorion, it really isn't.
23:49:49 <Aorion> I can't find any indication that that is not the case, from the documentation
23:50:08 <startling> Aorion, "case" lets you deconstruct a value. "if" does not.
23:50:08 <PatrickRobotham> Aorion: You can't do pattern matching with if then else.
23:50:16 <Aorion> there might be some subtle backend trickery that I can't know without stubbing my toe on them
23:50:18 <Gracenotes> Aorion: did you pay any attention to my Nucleotide datatype proposal?
23:50:30 <Aorion> let me look back up...
23:51:05 <Gracenotes> see also: http://www.haskell.org/haskellwiki/Avoiding_partial_functions
23:51:39 <Aorion> Okay. Gracenotes, I like that idea, i will try that next. I am just not up to type definitions yet.
23:51:57 <Gracenotes> honestly, I rest better knowing that it is *impossible* for code to throw exceptions or have bugs. It is possible to design large programs in this way.
23:52:15 <Gracenotes> with not /that/ much pain, I think
23:52:29 <Ezku> PatrickRobotham: Oh, right. So basically what I said would hold if we instead discussed the hom-sets of a-b and c-d respectively?
23:52:42 <Aorion> Gracenotes: but what if you get to a point where some value was not even supposed to get there?
23:52:49 <Aorion> do you want to just roll with it and hope for the best?
23:53:03 <Aorion> do you want to debug bad behavior, or stop and fix bad data before it causes bad behavior?
23:53:12 <PatrickRobotham> Ezku: Um, can you give the statement again in terms of hom-sets?
23:53:49 <Gracenotes> Aorion: assuming there are no solar flares flipping bits, complementDNA can't fail.
23:53:52 <Aorion> I find that if you absolutely know for sure that the data is wrong, then you should stop execution because there's no reason for it. If you get to that point, then it indicates an obvious, reproducible problem that you need to fix
23:54:33 <Tene> Aorion: If you're operating on a datatype that *has* no other values at all, such as Gracenotes' example, then that's really impossible to construct anything else.  You'll detect erroneous input at the initial parsing stage, and the rest of your program can't have those kind of errors.
23:55:09 <Aorion> Tene: yep, it's basically what  I did, just the mechanism by which was not the type system it was a lookup table and bounds checking
23:55:11 <Ezku> PatrickRobotham: two sets hom_C(a,b) and hom_C(c,d) are the same if a == c and b == d (assuming I'm right in that a hom-set would be the set of all arrows between specific objects)
23:55:31 <PatrickRobotham> Ezku: They damn well ought to be! :P
23:55:32 <Ezku> PatrickRobotham: thanks for being patient, btw, my CT is rusty to nonexistent :)
23:55:33 <Gracenotes> failure may occur in parseDNA :: String -> Maybe DNA, and it might seem like extra work to make a new datatype, but you've limited failure to *one* place.
23:55:43 <Aorion> they are identical in function, one just uses the type system so it's more explicit and self-documenting
23:55:51 <PatrickRobotham> Ezku: My pleasure. I get to look good in a channel full of geniuses.
23:55:52 <roboguy_> Aorion: but you want to use the type system. that way, you can catch some errors before the program even runs
23:56:16 <Ezku> PatrickRobotham: making incorrect statements and getting called out for that is a good way to learn, for me - especially in a channel full of geniuses ;)
23:56:23 <shachaf> Ezku: I think you have a fundamental emphasis in category theory backwards, which maybe makes some sense because the usual way of explaining it starts with the wrong thing.
23:56:35 <PatrickRobotham> Ezku: Hom_C(a,b) is the set of all arrows with source a and target b.
23:56:36 <Aorion> right, I understand the reason for it, but I haven't gotten to learning it yet (which is part of my problem).
23:56:39 <Gracenotes> I'm thinking not of the case where you have just complementDNA, but also reverseDNA, segmentDNA, matchDNA, longestCommonDNA, etc. If you had error checking in each one of those, it would be a lot more fragile.
23:56:40 <shachaf> Ezku: Objects aren't the point. Objects almost don't matter -- you can define "category" without ever talking about objects.
23:57:03 <shachaf> Ezku: The arrows are the important thing. They're so important that they ought to have a better name than "arrows".
23:57:11 <Gracenotes> The neat thing about a strong static type system is that it's possible to say exactly what you mean, no more and no less, with very little effort on your part.
23:57:23 <shachaf> PatrickRobotham: Hmm, am I interrupting?
23:57:23 <Gracenotes> I think this makes it both easier to write hard algorithms and easier to get them right.
23:57:32 <PatrickRobotham> shachaf: No.
23:57:34 <Aorion> well, thanks for helping all, goodnight
23:57:50 <Gracenotes> 'helping' :.
23:58:05 * Gracenotes steps down from his pulpit
23:58:09 <PatrickRobotham> shachaf: Objects are conceptually simpler than arrows.
23:59:00 <Ezku> shachaf: could be. Thanks for the reminder.
23:59:02 <shachaf> PatrickRobotham: I'm not sure what that means exactly, but I tend to think that kind of phrase is a big nudge in an unhelpful direction.
23:59:11 <shachaf> Ezku: Do you know what a monoid is?
23:59:28 <Ezku> I think I have a pretty good grasp
23:59:42 <Gracenotes> With my understanding of category theory, I see the focus on arrows as a nuisance that makes you describe thing with one more layer of indirection than you normally would.
23:59:53 <Gracenotes> Of course, it pays off in dividends elsewhere, etc.
