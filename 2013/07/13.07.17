01:32:51 <tomboy64> i need to create bitlists with fixed lengths and all possible combinations of bits
01:33:09 <tomboy64> for example 0,0,0,0; 0,0,0,1; 0,0,1,0 etc.
01:33:36 <tomboy64> which container would you suggest for that?
01:36:22 <Cale> > replicateM 4 [0,1]
01:36:23 <lambdabot>   [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1...
01:36:38 <YoungFrog> impressive
01:36:56 <Lethalman> lol
01:39:32 <tomboy64> indeed :o
01:39:47 <tomboy64> i was about to conjure my own function for that
01:40:06 <tomboy64> but apart form a list of Ints there is no more compact way to store this?
01:41:39 <YoungFrog> why would you store such a list ? (I'm not a haskeller myself, maybe this is irrelevant)
01:43:58 <tomboy64> i need to perform tests with bitlists potentially hundreds of bits long
01:44:52 <tomboy64> with all the combinations that might easily translate into myriads of list elements
01:44:58 <tomboy64> hm
01:45:02 <Lethalman> YoungFrog, you better use an int instead of [....]
01:45:19 <Lethalman> tomboy64, also, it highly depends on what kind of operations you have to do
01:46:31 <tomboy64> basically, each of the bit combinations is taken, operations performed and then it would be discarded, the result collected
01:46:45 <tomboy64> hmm
01:47:00 <tomboy64> combined with lazy evaluation that should work out
01:47:04 <tomboy64> let's try
01:49:58 <tomboy64> >replicateM 3 "abc"
01:50:06 <tomboy64> > replicateM 3 "abc"
01:50:07 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
02:14:29 * hackagebot aivika 0.6 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.6 (DavidSorokin)
02:19:30 * hackagebot aivika-experiment 0.3 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-0.3 (DavidSorokin)
02:19:31 * hackagebot aivika-experiment-chart 0.3 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-0.3 (DavidSorokin)
02:34:30 * hackagebot cassandra-cql 0.3.0.0 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.3.0.0 (StephenBlackheath)
02:50:07 <taylorgb_> Haskell being commonplace can't come soon enough. I'm getting pretty tired of the pain that unconstrained effect propogation has in imperative programming
02:50:49 <Taneb> What would a language like C be like if side-effects were constrained like they are in Haskell
02:51:16 <taylorgb_> usable? ;)
02:52:19 <t7> "using the polynomial 0x11EDC6F41"
02:52:34 <t7> i thought polynomial was an expression
02:53:18 <Tinned_Tuna> t7: depends on the context. Is this something to do with CRC, by any chance?
02:53:51 <t7> yes
02:55:03 <Tinned_Tuna> https://en.wikipedia.org/wiki/Cyclic_redundancy_check#Specification_of_CRC
02:56:31 <Tinned_Tuna> basically, if you take the "polynomial" 0x11, that represents 0b00010001, which represents the polynomial (x^16 + x)
02:56:52 <tulcod> taylorgb_: quite the opposite. the reason haskell is usable because we have all these constsucts to deal with the self-imposed limitations. C does not.
02:57:23 <taylorgb_> Yes, I suppose
02:57:28 <tikhonjelvis> right, but if you take C as is and add constraints, it's going to become even less usable
02:57:45 <tulcod> tikhonjelvis: that's what i tried to say, yes
02:58:01 <tikhonjelvis> the entire language is predicated on wanton mutation everywhere, for everything
02:58:06 <tikhonjelvis> I am very happy to not be using it any more
02:59:25 <merijn> No! That's what makes C great!
02:59:32 <merijn> Just not for very large projects :)
02:59:54 <tikhonjelvis> I'd rather generate C from a Haskell/OCaml eDSL than write it by hand these days
02:59:58 <tulcod> merijn: although curiously, the haskell projects we write are usually smaller than some C projects
03:00:26 <merijn> I'm working on some perversions that are a mix of C and haskell FFI :)
03:00:39 <merijn> C for dirty hacks, haskell to tie the dirty hacks together
03:00:41 <tikhonjelvis> among other things, you can always compensate for language deficiencies with enough manpower
03:01:05 <tikhonjelvis> which Haskell obviously lacks
03:01:10 <merijn> tulcod: Smaller ins scope too?
03:01:13 <taylorgb_> I'm currently suffering somewhat with writing some filesystem replication in C++, and still have some bugs which can be found in our system stress tests and I'm not quite sure how to fix it as I don't even know whether I'm logging the things that would indicate where the problem is. So, looks like I may be stuck just re-reviewing all the code
03:01:36 <taylorgb_> So, the idea of a bright future with Haskell is appealing
03:01:38 <tulcod> merijn: :) true
03:02:06 <tikhonjelvis> yeah, you should try to get an FP job
03:02:25 <merijn> taylorgb_: Do what google did for one of their cluster management programs, write a simple (ignore performance), but correct haskell implementation and verify against that :)
03:02:55 <taylorgb_> merijn: Problem is I have already verified that it is wrong :D
03:03:26 <merijn> taylorgb_: It's easier to take correct haskell and translate part by part to C++ then write correct C++ from scratch
03:04:18 <taylorgb_> I agree, although I'm not sure how I would go about a lot of it yet
03:04:27 <taylorgb_> My Haskell knowledge is still a bit rudimentary
03:04:33 <merijn> taylorgb_: Sounds like an excuse to learn haskell on company time!
03:04:44 <taylorgb_> hehe
03:05:21 <merijn> tell management that it's an experimental prototype for testing/verification anyway, so there's no reason it should be in the languages you currently support and you'll save a lot of time (and thus money!) this way
03:05:47 <merijn> By the time they realise your haskell implementation is better, it's too late to say "no haskell"!
03:05:53 <taylorgb_> Well considering the project has already overflowed by about a year, I don't think I'd have difficulty in explaining that it'd save time
03:06:21 <merijn> Or just don't ask permission in the first place and replace their code with haskell :>
03:07:18 <taylorgb_> Are you working at a FP house, merijn?
03:07:45 <merijn> No, I'm working at uni, so no one cares too much about how things are implemented, as long as they produce publishable results
03:08:05 <taylorgb_> Ah. Any plans for what to do after uni?
03:08:10 <merijn> Actually most of my "for work" haskell code are data munging shell script like things :)
03:08:50 <kryft> merijn: Do you use something like shelly?
03:08:52 <merijn> taylorgb_: I'm not actually studying, I'm just getting paid (a terribly small amount) as assistant researcher
03:08:59 <taylorgb_> Ah I see
03:09:02 <kryft> That's one of my planned use scenarios too
03:09:19 <merijn> kryft: No, that's for writing actualy shell script, I write small haskell scripts that I use inside shell scripts to manipulate data
03:09:34 <kryft> merijn: Ah, I see
03:10:05 <kryft> merijn: Yes that's what I plan to do too; in the past I've used things like python for that, but I think haskell will actually be better once I learn it well enough
03:10:07 <merijn> taylorgb_: And no, no plans for what next, hence why I'm now fighting with my CV design (somehow I only think to do that *after* I've promised to send it to someone)
03:10:10 <jonkri> How outdated would you say the Real World Haskell book (released in November, 2008) is compared to <http://book.realworldhaskell.org/read/>? (And please don't say five years. :-P)
03:10:16 <kryft> Not just better because I like it more but better better!
03:11:08 <benmachine> it is (somewhat regrettably) the case that five years is quite a long time in Haskell
03:11:23 <lpaste> merijn pasted “data munging” at http://lpaste.net/90987
03:11:33 <benmachine> that'll take you back to GHC 6.10 or something
03:11:35 <merijn> kryft: I end up writing things like that
03:11:37 <benmachine> maybe 6.8
03:11:53 <benmachine> which is five or six major revisions
03:12:18 <benmachine> but I don't know anything specific about the two versions of RWWH
03:12:35 <jonkri> benmachine: Yeah, that's what I was worried about too.
03:12:36 <kryft> jonkri: I've been reading RWH, and apparently some things are outdated
03:12:52 <kryft> jonkri: I haven't tried to compile the code mostly, so I don't know the details
03:13:29 <jonkri> kryft: Thanks!
03:14:10 <kryft> jonkri: I don't think it being outdated will be a huge problem though
03:14:39 <merijn> jonkri: It's outdated in the sense that some code examples might not compile immediately, but most fixes should be fairly straightforward and people here can help you with them
03:15:09 <tikhonjelvis> I think RWH also missed some pretty prevlanet trends, like the move to using Applicative far more
03:15:10 <merijn> jonkri: There haven't been any change the majorly obsolete anything in the book though, mostly just minor things
03:15:27 <tikhonjelvis> trends that happened with good reasons behind them, at that
03:15:37 <kryft> jonkri: The big difference between the website and the book is that there are quite a few confusing things in the book that are clarified in the comments left by readers on the website
03:15:54 <kryft> merijn: Is < from Control.Arrow?
03:16:29 <tikhonjelvis> < is less than :P
03:16:56 <kryft> Oh haha
03:17:00 <jonkri> I see. :-)
03:17:28 <jonkri> I see that there is a barcode chapter in the online version of the book. How nice!
03:17:56 <merijn> kryft: :p
03:17:59 <kryft> merijn: Is the startup time long?
03:18:12 <kryft> jonkri: Hmm, I had a barcode chapter in my kindle version of RWH
03:18:29 <kryft> jonkri: But the barcode chapter was one chapter where the comments on the website were quite helpful
03:18:36 <merijn> kryft: I'm trying to filter out values of measurements based on predicates
03:18:44 <merijn> So startup time is fairly irrelevant
03:18:56 <kryft> merijn: Yeah, I meant in general
03:19:09 <kryft> Probably doesn't matter for most data-munging scripts of course
03:19:11 <merijn> Probably <0.5s for runhaskell in general?
03:19:16 <kryft> Ok, so irrelevant :)
03:19:18 <tikhonjelvis> start up times are basically infinitely better than on the JVM
03:19:21 <kryft> For anything that I would do at least
03:19:23 <merijn> So a bit slow, but nothing bad
03:19:38 <tikhonjelvis> and you can compile your scripts ahead of time if you so desire
03:19:39 <merijn> Depends on the script size too, obviously
03:19:47 <kryft> Hmm, do you actually use anything from Control.Arrow in that script you pasted?
03:20:02 <kryft> I don't know anything about arrows, and glancing quickly I can't see anything unfamiliar here
03:20:03 <tikhonjelvis> I wrote a cute little pager in Haskell which gets used for things like psql and git
03:20:05 <kryft> Apart from < ;)
03:20:07 <tikhonjelvis> with runhaskell
03:20:13 <kryft> "what is this strange operator"
03:20:22 <tikhonjelvis> and I've never noticed the start time
03:20:41 <merijn> kryft: oh, no, I just copied the import list from some other scripts
03:20:54 <merijn> kryft: And I tend to use Control.Arrow a bit, mostly for *** and &&&
03:20:59 <kryft> jonkri: Overall I would say that RWH is a great book, but it feels quite unpolished in many ways
03:21:03 <kryft> jonkri: A rough diamond!
03:21:09 <kryft> merijn: Ah
03:21:27 <mr-> :t (***)
03:21:28 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
03:21:34 <kryft> merijn: That's actually why I was confused by '<' because I was trying to look for some strange operator, and my brain found one ;)
03:21:58 <jonkri> kryft: Did you notice much difference in the text and the examples between your PDF and the online version?
03:22:30 <kryft> jonkri: No, there were a few mistakes in the kindle edition that were corrected on the website, but mostly I didn't notice anything
03:22:40 <merijn> mr-: If that type confuses you, mentally replace "a" with "(->)"
03:23:01 <merijn> :t (***) `asAppliedTo` id
03:23:02 <lambdabot> (a -> a) -> (b' -> c') -> (a, b') -> (a, c')
03:23:34 <tikhonjelvis> eh, id has a slightly wrong type for that
03:23:44 <merijn> yeah, but I'm lazy
03:23:56 <kryft> merijn: When I asked you about hmatrix I was actually thinking of trying to use haskell for some things I currently use matlab for, but we'll see how that works out
03:24:00 <mr-> merijn: awesome, I can finally read arrow types :-)
03:24:39 <merijn> mr-: There's other arrows, but that's the most used one
03:24:58 <merijn> mr-: FWIW, the "Generalising Monads to Arrows" paper is very readable
03:25:06 <tikhonjelvis> I think Arrows are pretty overrated
03:25:19 <merijn> mr-: Or rather, the first half is very readable, the second half is rather hard. But just the first one is useful on its own
03:25:39 <merijn> tikhonjelvis: It depends, if you do lots of stream processing type things (like me!) they're a useful abstraction
03:25:44 <kryft> jonkri: I've only read up to chapter 16 though, so if there are differences in the final few chapters, I don't know about them
03:26:00 <mr-> merijn: thanks
03:26:07 <tikhonjelvis> I mostly agree with the people who want Arrow without arr
03:26:34 <tikhonjelvis> because the things I wanted to do with arrows as soon as I heard of them all turned out to be impossible thanks to arr
03:26:46 <tikhonjelvis> and because arr makes arrow things hard to optimize
03:27:07 <jonkri> kryft: Okay. :-)
03:27:22 <benmachine> :t (***) `asAppliedTo` unsafeCoerce
03:27:22 <lambdabot> Not in scope: `unsafeCoerce'
03:27:25 <benmachine> :(
03:27:31 <benmachine> :t (***) `asAppliedTo` Unsafe.Coerce.unsafeCoerce
03:27:32 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
03:27:42 <tikhonjelvis> heh, that was my thought too
03:27:45 <kryft> jonkri: How much Haskell experience do you have so far?
03:27:49 <merijn> :t (***) `asAppliedTo` (const undefined) -- silly people
03:27:50 <lambdabot> (b -> a) -> (b' -> c') -> (b, b') -> (a, c')
03:28:00 <tikhonjelvis> except instead of unsafeCoerce, I thought of const (fix id) :/
03:28:06 <jonkri> kryft: This is not actually for me. I'm thinking about getting the book for a friend.
03:28:30 <merijn> jonkri: I think LYAH makes a better starting book, unless you friend already has some haskell/FP experience
03:28:32 <tikhonjelvis> which is a full character shorter than undefined, I should add
03:28:42 <kryft> jonkri: Ah
03:28:54 <tikhonjelvis> I never got past the fifth or sixth chapter of LYAH
03:29:08 <tikhonjelvis> but I did look at some of the later pictures :P
03:29:15 <tikhonjelvis> pictures make everything better
03:29:17 <jonkri> merijn, kryft: I read this answer here: <http://stackoverflow.com/questions/1012573/getting-started-with-haskell>... So I was thinking to recommend the first chapters of LYAH too.
03:29:19 <t7> whats the advantage of big endian ?
03:29:40 <kryft> jonkri: I would second merijn's recommendation; I had taken a course that covered most of LYAH before I started reading RWH, and I think some things in RWH would have been impossible to understand otherwise
03:29:43 <merijn> jonkri: Why just the first chapters?
03:30:07 <merijn> jonkri: My advice is usually LYAH first, then skip the few chapters of RWH and move on to the advanced/practical bits
03:30:39 <tulcod> i actually found LYAH impossible to understand. i learn by reading code, and in LYAH you only get some of the code... in pieces... at the end... out of order... with refactored code in between
03:30:43 <jonkri> merijn: Just because that was what that SO answer recommended.
03:30:47 <tranceholic> hi, a quick question, Hoogle does not respond. any one knows why?
03:30:57 <tikhonjelvis> the server configuration is messed u
03:30:59 <tikhonjelvis> up
03:31:03 <Tinned_Tuna> merijn: I'm not so sure I would recommend RWH anymore -- most of the libraries it relies on seem to have changed an awful lot these days.
03:31:05 <tikhonjelvis> but you can use FP complete's Hoogle instead
03:31:27 <tikhonjelvis> www.fpcomplete.com/hoogle
03:31:40 <merijn> The good news is, people have admin access to Hoogle's machine, so hopefully it should be resolved within the next couple of hours
03:32:04 <tikhonjelvis> I would be very surprised if *nobody* had admin access to the machine
03:32:29 <tranceholic> Ok, thanx a lot!
03:32:45 <merijn> tikhonjelvis: Well, a lot of the admins are swamped, so some new admins have been added, but not properly setup with access yet
03:33:06 <merijn> tikhonjelvis: And the people able to setup access have had limited availability
03:34:09 <merijn> Actually, scratch that, Hoogle's machine isn't accessible yet
04:03:02 <supki_> Is there any way to pass --force for  cabal sandbox hc-pkg unregister?
04:34:32 * hackagebot transformations 0.1.1.0 - Generic representation of tree transformations  http://hackage.haskell.org/package/transformations-0.1.1.0 (JeroenBransen)
04:51:50 <thoughtpolice> hooray! hoogle is fixed
04:52:21 <merijn> @where ops
04:52:21 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
04:52:21 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
04:52:27 --- mode: ChanServ set +o dcoutts
04:52:31 <merijn> Can one of you fix the topic to indicate that Hoogle is back?
04:52:49 <dcoutts> ok...
04:53:05 --- mode: ChanServ set +o mauke
04:53:06 --- topic: set to 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by mauke
04:53:11 <thoughtpolice> dcoutts: thanks
04:53:23 <dcoutts> oh mauke beat me to it
04:53:25 --- mode: ChanServ set -o dcoutts
04:53:32 <thoughtpolice> the fix is pretty gross, i need to give neil access and talk to him about uploading a new build...
04:53:45 <thoughtpolice> but everything seems to work fine
04:53:51 <dcoutts> thoughtpolice: oh, thanks for the effort
04:54:56 <thoughtpolice> yeah, it was what we speculated
04:55:00 <thoughtpolice> just a missing ExecCGI directive
04:55:06 --- mode: mauke set -o mauke
04:55:53 <thoughtpolice> there are a bunch of things still missing though
05:03:50 <byorgey> thoughtpolice++
05:14:41 <poucet> Hi peeps
05:16:12 <byorgey> hi poucet
05:32:13 <nomeata> Is there an easy way to emulate a --no-dependencies flags to cabal install? I.e. I’d like to call "cabal install foo/ bar/ baz" and it will build and install from these directories, but will not download and install additional libraries?
05:32:58 <merijn> nomeata: How would it build without downloading the libraries those depend on?
05:33:44 <nomeata> merijn: if they are among the foo/ ... or already installed
05:33:56 <benmachine> nomeata: so just fail if there are dependencies unsatisfied?
05:34:01 <nomeata> benmachine: yes
05:34:03 <Kinnison> nomeata: fpcomplete have 'cabal-meta'
05:34:07 <merijn> nomeata: cabal already doesn't download installed dependencies
05:34:10 <Kinnison> nomeata: which, i believe, does a reasonable job
05:34:13 <Maior> benmachine: hello
05:34:20 <benmachine> Maior: hi, have you only just noticed me :P
05:34:25 <Maior> benmachine: yes :P
05:34:38 <nomeata> merijn: bu tit wold download additional once, which I’d like to prevent.
05:34:53 <benmachine> Maior: fair enough. I saw you in here the other day but declined to mention it because I assumed you already knew
05:34:55 <merijn> hmmm, true
05:34:59 <mr-> nomeata: you can look at --dry-run, if it is only information about unmet deps that you want
05:35:27 <nomeata> mr-: yes, only that the foo/ bar/ baz/ list is already 500 packages long and it’d be non-trivial to filter out the additional ones
05:35:39 <benmachine> eep
05:35:51 <nomeata> I guess one easy option is to put an empty 00-list.tar in ~/.cabal :-)
05:36:05 <benmachine> hah
05:36:17 <benmachine> or edit your .cabal/config wrt which repo it uses
05:36:56 <nomeata> benmachine: yes
05:37:19 <benmachine> it seems that cabal doesn't get tooo upset if you have no remote-repo setting at all
05:37:43 <adas> on the mtl package page there is no link to download the docs alone. Is there any other way?
05:39:02 <supki_> build them yourself
05:39:04 <mr-> nomeata: my interactive cabal could help filtering, but unfortunately it is not there yet..
05:39:10 <nomeata> benmachine: oh, that is nice! didn’t think of that
05:39:31 <benmachine> nomeata: haven't confirmed it does the right thing yet but it's plausible
05:39:34 <nomeata> mr-: interactive as in I can inject patches? That wold be great.
05:39:40 <nomeata> benmachine: will try
05:39:56 <mr-> nomeata: no, but it could give you an installplan that would list installed packages as installed
05:40:16 <nomeata> ok
05:44:13 <mr-> nomeata: but what do you mean by "inject patches"? ;-)
05:46:15 <Kinnison> nomeata: Have you looked at cabal-meta ?
05:49:39 <nomeata> mr-: I want to modify some packages before building them, and I thought you were talking about a way to modify the view cabal has on the repository
05:49:55 <nomeata> Kinnison: not in detail, but I think I’m fine with an empty 00-list.tar and cabal-dev for sandboxing.
05:50:21 * Kinnison has grown to love cabal-meta
05:50:41 <Kinnison> mostly because of johnw and gitlib
05:50:41 <mr-> nomeata: ah, I that's on my list too, but only there so far
06:03:48 <benokit> hi, can somebody explain how is it possible to pattern match with the binding opertaor <-, eg.: "Escape" <- eventKeyName
06:04:05 <tikhonjelvis> hmm, that's always possible
06:04:14 <tikhonjelvis> e.g. Just a <- foo
06:04:20 <tikhonjelvis> conceptually, it's like using a lambda
06:04:21 <benokit> but i dont understand why
06:04:25 <tikhonjelvis> foo >>= \ Just a -> ...
06:04:28 <tikhonjelvis> or, in your case
06:04:29 <bitonic> benokit: that desugars to a “case” where “fail” is called when the match fails
06:04:36 <tikhonjelvis> eventKeyName >>= \ Escape ->
06:04:37 <bitonic> so it’s not quite the same as a lambda
06:04:53 <tikhonjelvis> right, yes
06:05:02 <bitonic> > do Just x <- Nothing; return (x + 1)
06:05:02 <lambdabot>   Nothing
06:05:13 <bitonic> > Nothing >>= \(Just x) -> return (x + 1)
06:05:13 <tikhonjelvis> I usually just pretend fail does not exist though
06:05:13 <lambdabot>   Nothing
06:05:14 <supki_> benokit: <- is syntax, not an operator
06:06:12 <bitonic> tikhonjelvis: pretending that “fail” doesn’t exist is delusional ehe
06:06:16 <merijn> "do { Just x <- foo; bar x }" = "foo >>= \x' -> case x' of Just x -> bar x; _ -> fail"
06:06:26 <bitonic> > do let Just x = Nothing; return (x + 1)
06:06:27 <lambdabot>   <hint>:1:40:
06:06:28 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
06:06:34 <benokit> ok, so <- can do binding and pattern matching?
06:06:36 <bitonic> > do let (Just x) = Nothing; return (x + 1)
06:06:38 <lambdabot>   <hint>:1:42:
06:06:38 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
06:06:47 <bitonic> uhu?
06:07:24 <supki_> > do let { (Just x) = Nothing }; return (x + 1)
06:07:25 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
06:07:25 <lambdabot>    arising from a use of `M18711941...
06:07:53 <bitonic> > do let { (Just x) = Nothing }; Just (x + 1)
06:07:54 <lambdabot>   Just *Exception: <interactive>:3:10-27: Irrefutable pattern failed for patt...
06:07:59 <bitonic> there you go.  thanks supki_
06:08:27 <bitonic> benokit: so if you want the pattern match to go boom if it fails, use “let” or “case” when inside a “do”
06:08:48 <bitonic> pretending that “fail” doesn’t exist will cause a lot of confusion
06:09:33 <benmachine> > do Left x <- return (Right 0); Just (x + 1)
06:09:33 <lambdabot>   Nothing
06:09:34 <merijn> hmm, there's not good tutorial explaining do-desugaring?
06:09:51 <bitonic> @where report
06:09:52 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
06:09:52 <benmachine> @undo do Left x <- return (Right 0); Just (x + 1)
06:09:52 <lambdabot> return (Right 0) >>= \ a -> case a of { Left x -> Just (x + 1); _ -> fail ""}
06:10:16 <bitonic> merijn: <http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14> more specifically
06:12:02 <mr-> merijn: there's also some wikibook entry somewhere
06:12:03 <merijn> bitonic: Sure, I meant somewhere newbie friendlier :)
06:12:09 <merijn> mr-: I couldn't find it
06:12:15 <bitonic> merijn: it’s literally 5 lines of translation ehe
06:12:27 <bitonic> 6.
06:12:30 <mr-> http://en.wikibooks.org/wiki/Haskell/do_Notation
06:12:37 <mr-> it's not great, but something
06:12:48 <merijn> I know how desugaring works, I was just hoping for something really explicit like the indentation wikibook that I could link to people like benokit when they ask :)
06:12:58 <bitonic> but that’s super explicit
06:13:08 <bitonic> when the actual thing is so concise you might as well explain the actual thing
06:13:40 <merijn> bitonic: It's super explicit, while still being incomplete, which is why I dislike that one
06:13:43 <merijn> Compare: https://en.wikibooks.org/wiki/Haskell/Indentation
06:13:49 <bitonic> merijn: why is it incomplete?
06:14:10 <bitonic> the layout rule is much more complicated
06:14:34 * hackagebot acme-lookofdisapproval 0.1 - Express your disapproval  http://hackage.haskell.org/package/acme-lookofdisapproval-0.1 (AntonNikishaev)
06:14:38 <merijn> bitonic: The wikibook doesn't mention how let and pattern matches are translated
06:14:41 <merijn> oooh
06:14:42 <merijn> I need that package
06:14:52 <bitonic> merijn: I’m referring to the report
06:15:05 <bitonic> this <http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14>
06:16:01 <merijn> bitonic: That's slightly terser than I'd like to link to newbies
06:16:23 <bitonic> yeah maybe it could to with one or two examples.  but it’s definitely complete, and super simple
06:16:36 <merijn> This is great: https://github.com/llelf/acme-lookofdisapproval/blob/master/Acme/LookOfDisapproval.lhs
06:16:47 <bitonic> but wait, LYAH doesn’t explain that?
06:18:10 <b2coutts> hey, I want to do a pattern match where I split the pattern up into its parts, but also have a reference to the entire pattern (i.e., f @all(Comb a b c) = all should be an identity function)
06:18:26 <b2coutts> I remember lyah teaching me about using @all, but it doesn't seem to work in this context
06:18:34 <merijn> b2coutts: all@
06:18:35 <benmachine> b2coutts: the @ is at the other end
06:18:52 <benmachine> > let f xs@(y:ys) = y:xs in f [1,2,3]
06:18:53 <lambdabot>   [1,1,2,3]
06:18:55 <bitonic> it does, but I guess it’s buried a bit and hard to link <http://learnyouahaskell.com/a-fistful-of-monads#do-notation>
06:19:09 <b2coutts> well that was silly
06:19:14 <bitonic> I think the actual translation with 2 examples is as clear as it gets
06:19:15 <b2coutts> thanks everyone
06:19:50 <benmachine> bitonic: write a wiki page on it?
06:20:14 <benmachine> I mean haskellwiki
06:20:57 <bitonic> I don’t have permission to create a page mhm
06:21:20 <bitonic> “NOTE: New wiki account creation is currently disabled. If you need an account please email "nominolo" (at the email service from Google) or on the haskell-cafe mailing list.”
06:21:28 <bitonic> I guess we don’t have enough moderators to keep the list clean
06:22:31 <merijn> It seems like we would want to consolidate all requests like this using the ticket tracker in the Near Future (TM)
06:25:40 <bitonic> jaspervdj:
06:25:42 <bitonic> oops.
06:25:54 <bitonic> that was meant to be a query :)
06:30:59 <sclv_> @remember knuth To help the reader drowning in a sea of abstraction, the following example may serve as a concrete life preserver
06:30:59 <lambdabot> It is stored.
06:32:19 <tikhonjelvis> a concrete life preserver
06:32:22 <tikhonjelvis> heh, heh
06:35:11 <ignacio> hey there
06:35:33 <ignacio> say I want to define elements of a group G as functions from G to G
06:35:43 <ignacio> causing infinite type nastiness
06:35:51 <ignacio> what's the next cleanest way to do it?
06:36:18 <merijn> newtype, at least, if I understand your question correctly
06:36:43 <ignacio> kind of, newtype lets me define the type of the elements
06:36:59 <ignacio> but defining an element or two blows up
06:37:14 <merijn> Can you actually have an element of that type?
06:37:16 <ignacio> I can define the group's identity just fine (because it's just id)
06:37:18 <merijn> I'm not sure?
06:37:32 <ignacio> but I can't even define Z_2 without infinite type errors
06:37:45 <Hafydd> Yes... how would you pattern-match on functions?
06:38:05 <merijn> Hafydd: I don't see how that is relevant?
06:38:34 <Hafydd> Never mind, I suppose it isn't.
06:38:37 <mr-> ignacio: would G -> G be the multiplication?
06:38:52 <elliott> you won't get much useful done with a representation like that.
06:38:53 <ignacio> mr-: yeah, the group operation
06:39:00 <elliott> actually what you will get is a model of the untyped lambda calculus.
06:39:13 <mr-> ignacio: but that would be G -> G -> G
06:39:19 <ignacio> elliott: it's the same problem I had with a "functional" graph data type
06:39:34 <ignacio> mr-: sorry, an element has type G -> G
06:39:41 <ignacio> the group operation has type G -> G -> G
06:39:59 <ignacio> it's very hard to define the group since you have to tie the know
06:40:15 <ignacio> anyway, question is what's the most practical (if less "functional") way to do this
06:40:36 <ignacio> I was thinking of having a map from labels to group elements, to add a layer of indirection that does away with type errors
06:41:43 <ignacio> really the only reason to have G = G -> G was so I could have pretty syntax like e x = x (without writing the group operation)
06:41:50 <ignacio> and automatic associativity
06:42:15 <ignacio> elliott: could you explain what you said about the lambda calculus?
06:42:41 <ignacio> s/tie the know/tie the knot/
06:43:15 <elliott> you can model it as newtype Value = Value (Value -> Value)
06:43:28 <elliott> e.g. http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=95
06:43:30 <ignacio> indeed, that compiles
06:43:40 <ignacio> but then you can't define elements
06:43:45 <elliott> sure you can.
06:43:55 <elliott> "it" here is "the lambda calculus".
06:45:30 <bitonic> it’s weird that he doesn’t separate neutral values
06:45:40 <ignacio> well, you can define the identity
06:45:51 <ignacio> that's as far as I got
06:45:52 <bitonic> since you can do it so easily in that context
06:46:50 <ignacio> even worse, I can define the identity but it fails to run
06:49:54 <Fuuzetsu> @package xhtml
06:49:54 <lambdabot> http://hackage.haskell.org/package/xhtml
06:50:17 <ignacio> http://lpaste.net/90989 if you run e e you get a type error
06:51:54 <Hafydd> Try defining Z_2. I think you'll find it doesn't really work with function values.
06:52:06 <ignacio> it doesn't
06:52:20 <Hafydd> Well, Z_2 might be a bit easy.
06:52:24 <Hafydd> Z_3, perhaps not.
06:52:36 <ignacio> I just posted the trivial group because it's an even simpler example that doesn't work
06:53:15 <Hafydd> Can you post all of your code?
06:53:29 <ignacio> one sec
06:53:53 <benmachine> ignacio: you'll have to use the newtype constructor
06:54:05 <benmachine> ignacio: e = GroupEl id
06:54:35 <ignacio> I'll try that
06:55:15 <shachaf> thoughtpolice: The website isn't really "fixed" yet...
06:55:34 <ignacio> like this? http://lpaste.net/90991
06:55:40 <shachaf> If nothing else the mailing lists are still messed up.
06:55:47 <shachaf> Which is a bigger deal than Hoogle.
06:55:48 <merijn> shachaf: It's a known issue
06:55:53 <ignacio> (won't compile, infinite type error)
06:55:57 <merijn> I think Ian was looking into it?
06:56:24 <shachaf> merijn: Right, which is why clearing the topic is premature.
06:56:30 <benmachine> ignacio: no, not quite like that; you can't pattern-match agains variables
06:56:33 <shachaf> But oh well. We'll see if someone asks about it.
06:56:46 <merijn> shachaf: oh, that's true
06:56:57 <benmachine> ignacio: this is really the trouble with the GroupEl -> GroupEl representation, is identifying, given some group element, which it is
06:57:00 <merijn> shachaf: as for an update: "Looks like /var/lib/mailman/archives/private/haskell.mbox/haskell.mbox"
06:57:03 <merijn> is OK. The public archive generation must have failed for some reason.
06:57:24 <benmachine> ignacio: even conceptually that's hard to do, never mind in implementation
06:57:39 <shachaf> libraries@ is also messed up.
06:58:03 <elliott> libraries@ is always messed up
06:58:33 <ignacio> benmachine: yeah, if you think of G->G as a subset of GxG then it just doesn't make sense
06:58:55 <benmachine> ignacio: however I think of it I can't make it work
06:59:06 <thoughtpolice> shachaf: i only said hoogle was back :)
06:59:38 <ignacio> well there _is_ a correspondence between group elements and permutations of the group's set
06:59:54 <ignacio> maybe you just need a layer of indirection for everything to make sense
07:00:18 <benmachine> ignacio: but of course G -> G is more than just the permutations
07:00:41 <shachaf> newtype T = T (T -> T) is a good type!
07:01:04 <benmachine> shachaf: it's a valid type, but it's a bit of a difficult one
07:01:16 <benmachine> I have no idea how to interpret it as a set, for starters
07:01:39 <shachaf> benmachine: It's the type of untyped lambda calculus terms, or something like that.
07:02:01 <benmachine> shachaf: I think T -> T might be too big for that
07:02:09 <benmachine> shachaf: well, depends what -> means I suppose
07:02:30 <shachaf> Is it? Hmm.
07:02:35 <shachaf> What do you mean?
07:02:56 <elliott> not terms, values
07:03:04 <elliott> because it equates extensionally equal terms
07:03:19 <elliott> also you have _|_ and const _|_ being different
07:03:24 <elliott> as I know you like to point out shachaf :P
07:03:31 <benmachine> shachaf: well, let's supposed T has more than 2 distinct elements, then T -> Bool is the powerset, right? so if T = T -> T then either T has fewer than 2 elements or T is the same size as its powerset, violating Cantor's theorem
07:03:53 <benmachine> so thinking about stuff as sets doesn't really work
07:05:10 <benmachine> er, by "the same size" I mean "at least as big as", on the assumption that if T is bigger than Bool then T -> T is bigger than T -> Bool
07:05:17 <benmachine> (or at least as big as, in any case)
07:05:58 <benmachine> this all said, it's not perfectly obvious to me how to construct an element of T that is demonstrably not T id
07:06:08 <ignacio> tying the know
07:06:13 <ignacio> fuck
07:06:16 <ignacio> tying the knot
07:06:55 <shachaf> See e.g. http://stackoverflow.com/questions/12651146/why-inductive-datatypes-forbid-types-like-data-bad-a-c-bad-a-a-where-th
07:07:07 <ignacio> at least, that works for making the references, but you still have the infinite type errors
07:07:26 <shachaf> It's a lot like Rec except more restricted.
07:08:51 <ignacio> I can think of one way to get associativity for free, although it's as unwieldy as my original idea
07:09:21 <ignacio> data GroupEl = GroupEl [(GroupEl,GroupEl)]
07:09:34 <ignacio> no infinite type, but you still have to tie the knot
07:10:04 <ignacio> and you don't get the "group operation as function application" syntax
07:10:24 <benmachine> ignacio: I don't think the group-operation-as-function-application syntax typechecks
07:10:27 <benmachine> any way you slice it
07:10:29 <elliott> you don't get that syntax with a newtype either
07:10:34 <benmachine> unless you have a type system that is not haskell's
07:10:49 <benmachine> (I could be wrong)
07:11:02 <ignacio> seems you're right
07:12:08 <tikhonjelvis> OCaml has rectypes, if that's what you're looking for
07:12:38 <tikhonjelvis> I haven't been following your conversation to know if that's actually relevant
07:12:56 <shachaf> rectypes are equirecursive types?
07:13:41 <benmachine> ocaml's rectypes are pretty close to Haskell's, I think
07:13:52 <benmachine> except inasmuch as they'd be least-fixed-points instead of greatest-fixed-points
07:13:57 <benmachine> because strict semantics
07:14:21 <shachaf> In Haskell they're both!
07:14:42 <shachaf> But it looks like ocaml actually has infinite types with -rectypes.
07:14:48 <benmachine> oh, I see
07:14:50 <benmachine> hmm
07:15:02 <benmachine> shachaf: Haskell doesn't have lfps, does it?
07:15:26 <benmachine> I suppose there's !s, I'm not sure if they count
07:15:31 <shachaf> Well, the least fixed point is the same as the greatest fixed point.
07:15:42 <benmachine> shachaf: of what?
07:16:20 <benmachine> shachaf: if you have data ℕ = Z | S ℕ, then the gfp contains fix S but the lfp doesn't
07:16:20 <shachaf> Of a functor.
07:16:56 <shachaf> OK, how are you defining "lfp" here?
07:17:06 <ignacio> S has a fixed point?
07:17:27 <benmachine> ignacio: fix S is a fixed point of S
07:17:31 <elliott> data N = Z | S !N
07:17:46 <benmachine> elliott: see, I'm not sure if that's actually a different datatype, really
07:17:51 <shachaf> I think data Maybe a = Nothing | Just !a is a different functor.
07:17:52 <elliott> (yes you get _|_ -- however your N has S (S (S _|_)) too)
07:17:52 <benmachine> maybe it could be
07:17:53 <shachaf> So it doesn't count.
07:18:01 <elliott> benmachine: well, it is not inhabited by fix S.
07:18:08 <elliott> or rather it is, but not really.
07:18:13 <elliott> not int he same way.
07:18:14 <benmachine> elliott: :P
07:18:19 <shachaf> Yes, but it's a different S.
07:18:23 <benmachine> elliott: but I'm not sure even of that
07:18:41 <benmachine> elliott: I mean, my understanding is that ! just means "you apply the constructor with $! instead of $"
07:18:55 <elliott> right
07:18:56 <shachaf> benmachine: Anyway, the initial Maybe-algebra-thing and the coterminal Maybe-coalgebra thing are isomorphic.
07:19:08 <shachaf> Er, not coterminal.
07:19:11 <shachaf> Just terminal.
07:19:16 <benmachine> shachaf: that's true, but only because both of them are constant functors, that kind of doesn't count :P
07:19:29 <shachaf> ?
07:19:40 <raisdead> I have some code at http://lpaste.net/90979 . I am trying to implement something equilvant to relation in database theory. Can anyone help me solve this problem?
07:19:40 <benmachine> shachaf: hmm, wait
07:19:41 <shachaf> Let's say Mu Maybe and Nu Maybe.
07:19:46 <benmachine> shachaf: ah, I see
07:19:59 <benmachine> shachaf: surely only one of them contains fix Just?
07:20:09 <shachaf> No, because you have recursion/⊥/etc.
07:20:39 <shachaf> @let newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }
07:20:39 <lambdabot>  Parse failed: TypeOperators is not enabled
07:20:42 <benmachine> shachaf: the way I interpret that is, if you have recursion you don't have lfps
07:20:55 <shachaf> elliott: Can you turn on *any* extensions in lambdabot?
07:21:09 <benmachine> shachaf: but I suppose it depends on what fixpoints are allowed, so which ones are least among them
07:21:28 <benmachine> @let x = ?y + 1
07:21:29 <lambdabot>  Parse failed: Parse error: ?
07:21:31 <benmachine> aw
07:21:41 <benmachine> > let x = ?y + 1 in let ?y = 4 in x
07:21:42 <lambdabot>   <hint>:1:9: parse error on input `?'
07:21:47 <benmachine> hmph
07:21:54 <shachaf> benmachine: Well, I mean, a least a fixed point is just an initial object in the category of fixed points, right?
07:22:13 <benmachine> shachaf: I suppose
07:22:17 <shachaf> Without one of those "a "s.
07:22:20 <elliott> shachaf: well, let me work out the mueval timeout issue...
07:22:33 <shachaf> elliott: You've timed out on that.
07:23:04 <shachaf> So if the greatest fixed point is initial then I'd call it the least fixed point.
07:23:25 <benmachine> shachaf: all right, but that's a bit rubbish because then any fixed point can be least by taking a sufficiently small category
07:23:50 <shachaf> What do you mean, "a sufficiently small category"?
07:24:02 <benmachine> shachaf: I'm possibly being silly :P
07:24:31 * benmachine thinks
07:24:57 <shachaf> benmachine: The category of fixed points is the category of F-algebras that are isomorphisms (or F-coalgebras, it comes out to the same thing).
07:25:01 <benmachine> shachaf: I think my objection is that whether or not some thing is initial depends on what category you're thinking of it as living inside, and we were thinking of different ones
07:26:06 <shachaf> Fair enough.
07:26:12 <shachaf> Which category are you thinking of?
07:26:30 <benmachine> I'm actually not sure now :P
07:27:10 <benmachine> but I feel that Mu Maybe ought not to contain fix Just, i.e. Mu Maybe isn't really definable in Haskell
07:27:46 <shachaf> I'm talking about Mu as in the definition I gave above.
07:27:54 <benmachine> ok
07:27:56 <shachaf> I agree that non-Haskell Mu isn't definable in Haskell. :-)
07:28:00 <benmachine> :P
07:28:11 <shachaf> But I think the Mu I gave above is initial, in Haskell?
07:28:31 <benmachine> hmm
07:28:49 * benmachine plays with it a bit
07:29:02 <roconnor> shachaf: I'm told initial = final in DCPOs
07:29:13 <shachaf> roconnor: So am I.
07:29:48 <roconnor> because _|_ is around to get everything started
07:29:54 <benmachine> roconnor: huh, is that initial algebra = final coalgebra?
07:30:01 <roconnor> benmachine: yes
07:30:03 <benmachine> right
07:30:24 <danharaj> I believe in DCPO you also only talk about weakly initial/final objects?
07:35:14 <shachaf> tikhonjelvis: You missed all the f-algebra discussion!
07:36:02 * shachaf likes those now.
07:36:22 <shachaf> benmachine: I need to go but you should tell me if you figure out anything interesting on this.
07:36:36 <benmachine> shachaf: I <3 F-algebras
07:36:44 <benmachine> but also I'm quite busy at the moment :P
07:37:03 <tikhonjelvis> oh, oops
07:37:09 <tikhonjelvis> I was having fun ssh adventures
07:37:25 <tikhonjelvis> in which my home directory decided to disappear for a while
07:37:41 <shachaf> Perhaps it's spending time with the haskell mailing list archives.
07:37:48 <Taneb> benmachine, would you call F-algebras easy?
07:37:59 <tikhonjelvis> F-algebras are *simple*
07:38:05 <tikhonjelvis> whether you find them easy depends on you though
07:38:11 <benmachine> Taneb: no
07:38:21 <shachaf> Taneb: I think T-algebras are the so easy ones.
07:38:58 <benmachine> Taneb: well, you can ask easy questions about them, and you can ask hard ones, it sort of depends what you want
07:39:10 <Taneb> benmachine, shachaf got the joke
07:39:16 <benmachine> oh
07:39:21 <benmachine> I didn't and don't :P
07:39:29 <shachaf> That's OK. It's a bad joke.
07:39:35 <shachaf> Even Taneb would agree, I'm sure.
07:39:49 <Taneb> Yeah, it's awful
07:39:57 <benmachine> what is it :(
07:40:13 <Taneb> A play on "I love monoids, they're so easy"
07:40:14 <tulcod> okay, question on bad practices: what monad (or what method) should i use to return errors? Control.Monad.Error? or just an arbitrary Monad and use 'fail'?
07:40:20 <benmachine> Taneb: oh, right
07:40:24 <shachaf> tulcod: Maybe or Either.
07:40:27 <benmachine> fair enough
07:40:33 <tikhonjelvis> ooh, don't use fail
07:41:15 <tulcod> shachaf: so do i need to make an explicit choice between those?
07:41:30 <shachaf> tulcod: That's probably a good idea. They mean different things.
07:41:42 <merijn> tulcod: Either lets you return an error value, Maybe just lets you return something went wrong
07:41:45 <tulcod> shachaf: and would Nothing be an error, with Just faultless execution?
07:41:50 <merijn> tulcod: Yes
07:42:10 <shachaf> Execution is always faultless, when your program is well-typed. :-)
07:42:11 <tulcod> because my particular function has no return value... in which case the return type would be IO (Maybe ())
07:42:29 <tikhonjelvis> hmm
07:42:37 <shachaf> Well, that sounds OK to me. You could also say MaybeT IO () if you preferred.
07:42:50 <shachaf> But of course Maybe () is isomorphic to Bool.
07:43:09 <tulcod> shachaf: exactly. suggesting i should use Bool. which is rather old-fashioned.
07:43:22 <tikhonjelvis> depending on what exactly the function does, it might make sense to use exceptions
07:43:25 <tikhonjelvis> since you're in IO anyhow
07:43:34 <tulcod> tikhonjelvis: exceptions as in...?
07:43:38 <shachaf> That's also an option...
07:43:45 <shachaf> As in Control.Exception.
07:43:54 <tulcod> okay
07:44:03 <quchen> Maybe () might be preferrable if you want to chain many Maybe computations together using its Monad instance.
07:44:17 <quchen> With Bool you'll have to keep track of previous results.
07:44:24 <tikhonjelvis> hmm, for chaining, MaybeT IO () would probably be best
07:44:25 <benmachine> tulcod: a better alternative to IO Bool could be data MyType = Success | Failure and returning IO MyType
07:44:30 <benmachine> (choosing better names)
07:44:48 <shachaf> Even better might be returning an actual value, if you can manage it. :-)
07:44:51 <tulcod> benmachine: that would suggest there is no existing type which would satisfy my use case
07:44:52 <merijn> benmachine: That doesn't come with a premade monad instance, though
07:45:05 <benmachine> merijn: may or may not be a problem
07:45:12 <tikhonjelvis> it really depends on exactly what your case is
07:45:15 * shachaf softly and suddenly vanishes away.
07:45:20 <tikhonjelvis> ultimately, choosing how to do this is a matter of taste
07:45:28 <benmachine> tulcod: well, the idea is to make your own type so it reflects your specific failures or whatever
07:45:35 <tulcod> use case: this is an FFI to a C library function returning 1 for success and 0 for failure. some other functions might return other codes
07:45:52 <tikhonjelvis> oh, and you don't get any more information about why it failed?
07:45:59 <tulcod> in this case, no
07:46:06 <tikhonjelvis> does the function have side-effects?
07:46:23 <benmachine> I would avoid IO (Maybe ()), since it's not unambiguous that Just = good and Nothing = bad
07:46:23 <tikhonjelvis> I bet it does, for obvious reasons
07:46:30 <benmachine> frequently it's that way, but you can also have Maybe Error
07:46:35 <tulcod> tikhonjelvis: yes
07:46:40 <tikhonjelvis> what does a code of 1 represent?
07:46:44 <shachaf> tulcod: "other codes" for success or failure or what?
07:46:46 <tikhonjelvis> what sort of failure?
07:46:58 <tikhonjelvis> (I'm assuming 0 means success, but you never know...)
07:47:12 <shachaf> "1 for success and 0 for failure" suggests the opposite. :-)
07:47:14 <tulcod> tikhonjelvis: yes, 0 is success in this case
07:47:14 <shachaf> It's possible that you want to make a higher-level FFI binding that gives you an actual Haskell value.
07:47:17 <merijn> tulcod: Might wanna throw an IO error and take an approach like this: https://github.com/merijn/posix-pty/blob/master/System/Posix/Pty.hs#L188
07:47:19 <shachaf> Oh, or not.
07:47:32 <shachaf> that might be what tikhonjelvis is getting at.
07:48:07 <tulcod> benmachine: well in principle i agree that the returned value should be self-explanatory, but i'm not inventing my own type for what cannot be an unsolved problem
07:48:08 <shachaf> tulcod: Did you see these slides? http://www.ugcs.caltech.edu/~keegan/talks/high-level-ffi/
07:48:14 <tulcod> shachaf: nope
07:48:23 <shachaf> Good slides, if you're making an FFI binding.
07:48:32 <shachaf> Not directly relevant to your question.
07:49:07 <tulcod> shachaf: thanks, will def. read them after i solved this :)
07:49:08 <benmachine> tulcod: the whole idea of my approach is that the datatype you define is *not* generic
07:49:17 <benmachine> well, not the *whole* idea
07:49:29 <benmachine> but, like, datatypes are cheap, you shouldn't be upset by the idea of making a new one
07:49:53 <benmachine> tulcod: I think my overall answer would be "there are lots of different ways depending on what kind of failure it is and what you might want to do afterwards"
07:50:02 <tulcod> benmachine: well i agree, but the only thing i want to say is: either the function executed the side-effects successfully, or i have an error code, which i'd like to present
07:50:36 <shachaf> <monochrom> completely useless tautological truism, or words of eternal wisdom, you decide :) : the solution depends on the problem
07:50:41 <tulcod> merijn: ok let me take a look at that :)
07:50:51 <bscarlet> tulcod: I've found ErrorT String to be a decent compromise.
07:50:59 <jonkri> ghc-mod fails installing with the following errors: <http://pastebin.com/H3x6FjUe>. any advice? :> (i have run cabal update)
07:51:00 <shachaf> I don't think an IO exception is a good approach here.
07:51:01 <mauke> The paste H3x6FjUe has been copied to http://lpaste.net/90992
07:51:02 <benmachine> I don't like using String for errors
07:51:12 <jonkri> i'm on ghc 7.4.2
07:51:26 <tulcod> benmachine: hm, that's true, i guess
07:51:32 <tikhonjelvis> how "exceptional" is the error case--do you expect it to come up in normal operation of the function?
07:51:34 <benmachine> I don't think IO Bool is *so* bad
07:51:34 <shachaf> And ErrorT String -- or ErrorT in general -- is pretty evil for something you'll have to detect.
07:51:40 <shachaf> ErrorT still exists?
07:52:05 * benmachine comes around to the MaybeT IO () idea
07:52:06 <jonkri> mauke: Nice, I'll try to remember to use lpaste.net from now on. :-)
07:52:16 <shachaf> I would say if this binding is more or less 1:1 with the C API, then it should also give errors in roughly the same way.
07:52:28 <shachaf> And you can make higher-level bindings on top of it.
07:52:56 <tulcod> what about MaybeT IO () vs. IO (Maybe ()) ?
07:53:09 <merijn> It depends on whether errors should be handled at all, the approach I linked just takes a "die if things go wrong" approach
07:53:12 <tulcod> shachaf: hm, that's also a useful thought
07:53:14 <supki_> jonkri: you are trying to install very old ghc-mod for some reason
07:53:15 <ParahSail1n> :t runMaybeT
07:53:15 <lambdabot> Not in scope: `runMaybeT'
07:53:16 <benmachine> tulcod: I prefer MaybeT IO () because then Just is obviously success and Nothing is obviously failure
07:53:21 <merijn> @unmtl MaybeT IO ()
07:53:21 <lambdabot> IO (Maybe ())
07:53:35 <tulcod> hehe
07:53:36 <tulcod> okay
07:53:36 <benmachine> jonkri: maybe try cabal install ghc-mod --dry-run -v
07:53:54 <supki_> jonkri: try cabal install ghc-mod-2.0.3
07:53:57 <benmachine> tulcod: I mean, IO (Maybe ErrorCode) can have Just as failure and Nothing as success
07:54:04 <supki_> jonkri: the error you'll receive may be helpful
07:54:07 <bscarlet> I dislike using Maybe for errors because when you've got more than one possible cause of error you don't get much information about what went wrong.
07:54:10 <benmachine> tulcod: but with MaybeT that doesn't really make sense
07:54:23 <supki_> jonkri: I'd guess you have weird ghc installation
07:54:31 <tulcod> benmachine: yeah, makes sense
07:55:06 <tulcod> okay, i think i'll stick with MaybeT IO () and introduce new error types as i come across them
07:55:14 <bscarlet> shachaf: what's your objection to ErrorT? I can see some cases would warrant ErrorT ErrorCode instead of ErrorT String...
07:55:15 <tulcod> thanks a lot for all you guys' (/girls') input!
07:55:30 <benmachine> people's :P
07:56:04 <shachaf> bscarlet: Should be EitherT.
07:56:35 <shachaf> Hmm, or maybe ErrorT got fixed. It used to be bad, with a String argument and such.
07:56:53 <quchen> It's now very rank-2-y.
07:57:19 <shachaf> Oh, there. class Error a ...
07:57:20 <quchen> Not exactly nice to work with, but comes much closer to "Either SomeException a".
07:58:09 <quchen> Oh wait, I think I'm mixing up Errors and Exceptions again. Arrrgh
07:58:36 <bscarlet> ErrorT requires that a string (from fail) be convertible to an error. It also makes clear that the Left case is for errors, while EitherT does not.
07:59:09 <quchen> Haskell's exception libraries are probably the best way of convincing someone to write total functions only :P
07:59:46 <roconnor> I'm hoping that prisms improve exception libraries.
07:59:52 <jonkri> SuperNoeMan: Something is indeed weird here. cabal says a newer version of cabal-install is available, even when i have just installed the latest version. Maybe it's the fact that I'm using Fedora's Haskell Platform package.
07:59:56 <shachaf> bscarlet: EitherT certainly does make it clear.
08:00:10 <shachaf> And requiring that a string be convertible to an error is evil.
08:00:19 <jonkri> [jonkri@localhost ~]$ whereis cabal
08:00:20 <jonkri> cabal: /usr/bin/cabal /home/jonkri/.cabal/bin/cabal
08:00:24 <bscarlet> shachaf: how? does EitherT make it clear?
08:00:39 <klrr_> chrisdone: how is lisk going ? is it usuable for a complete program yet?
08:00:55 <shachaf> bscarlet: Because it's impossible to implement EitherT any other way.
08:01:14 <jonkri> (I just realized that I need to prepend the local paths (instead of appending them).)
08:01:19 <bscarlet> shachaf: there are way too many unjustified assumptions of intent in that claim.
08:01:26 <merijn> quchen: Why's that? I kinda like haskel's exceptions, except the fact the not all libraries document which exceptions can be thrown
08:01:27 <supki_> jonkri: oh, Fedora sounds familiar. You probably need to install a fedora package providing ghc API
08:01:34 <shachaf> (Either e) is a monad. (\a -> Either e a) isn't.
08:02:09 <Fuuzetsu> Hm, I didn't know you could do … where foo x y = undefined; bar = undefined x…
08:03:14 <benmachine> shachaf: do you mean (\a -> Either a e)?
08:03:22 <shachaf> benmachine: Er, yes, I do.
08:03:49 <benmachine> I agree, btw, that Either is fine for errors
08:04:09 <benmachine> I mean, good grief, ErrorT uses Either anyway
08:04:34 <quchen> merijn: Well, IO-based exceptions are pretty evil if you throw them from pure code. In an IO setting, I find the "forall e." parts a little fiddly, but maybe it's the best solution there is. ErrorT has these ties to String (I don't get what Error is for in the first place, and I also don't understand why it's required for the Monad instances of ErrorT - probably because of `fail` which I don't want to rant about again). I'm closing my st
08:04:34 <quchen> atement here because I can't remember the beginning anymore ;-)
08:04:55 <merijn> quchen: Which "forall e" part?
08:05:12 <quchen> merijn:  http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception-Base.html#v:SomeException
08:05:16 <bitonic> when is haskell.org coming back up?
08:05:23 <bitonic> like, the mailing list archives and hoogle?
08:05:33 <quchen> Hoogle is up again I think
08:05:52 <merijn> bitonic: Hoogle is up, mailing list is work in progress
08:05:57 <bitonic> oh, it is.
08:05:58 <jonkri> benmachine: "In order, the following would be installed: ghc-mod-0.3.0 (new package)". I have no idea why.
08:06:23 <benmachine> jonkri: maybe try -v2 or -v3 until it starts telling you what it is thinking
08:06:26 <merijn> bitonic: Generation of the public archives failed, I'll take a look when I get home tonight
08:08:30 <lpaste> jonkri pasted “cabal ghc-mod v3” at http://lpaste.net/90993
08:09:35 <dmwit> Has anybody used priority queues? I'd like a recommendation. Currently pqueue and meldable-heap both look good to me.
08:09:52 <tikhonjelvis> is lpaste just hpaste hosted on a different server or something?
08:10:02 <elliott> dmwit: I think edwardk has one. so, you know...
08:10:13 <elliott> http://hackage.haskell.org/package/heaps
08:10:26 <dmwit> tikhonjelvis: yes
08:10:45 <bitonic> dmwit: there was this a while ago <http://thread.gmane.org/gmane.comp.lang.haskell.general/19734>
08:10:48 <tikhonjelvis> and is hpaste on the same server as haskell.org or something?
08:11:00 <dmwit> elliott: cool, thanks
08:11:02 <dmwit> bitonic: you, too
08:11:22 <xplat> is it possible to implement 'forever' using MonadFix methods but no explicit pure recursion?
08:11:51 <elliott> MonadFix isn't really about that kind of loop.
08:11:58 <elliott> it's about tying the knot of the *results* of the actions.
08:12:18 <xplat> ah, but if an action results in an action ...
08:12:25 <dmwit> Okay, the "search" part isn't as important to me.
08:12:29 <bitonic> xplat: a hint would be the type signature of something using “mfix” :)
08:13:00 <xplat> bitonic: i don't mean it to work for all monads, just MonadFix
08:13:21 <bitonic> xplat: OK, so you’d accept a different signature.  then elliott’s answer is better ehe
08:13:45 <bitonic> but the fact that not all Monads are a MonadFixs is a good hint, imo
08:13:45 <elliott> hmm, maybe you can do it.
08:13:59 <elliott> forever m = join $ mfix (\m' -> return (m >> m'))
08:14:01 <elliott> but that's silly.
08:14:06 <elliott> you're basically using mfix as fix.
08:15:29 <xplat> elliott: well, it seems silly, but my use is trying to make loopy monadic code more accessible to optimizers
08:16:22 <jonkri> What does "rejecting: base-3.0.3.2, 3.0.3.1 (global constraint requires installed instance)" mean?
08:16:43 <supki_> jonkri: did you see my suggestion?
08:16:47 <elliott> it means you're trying to install an ancient package
08:16:54 <xplat> elliott: ghc is apparently poor at optimizing code with actual loops
08:17:13 <supki_> jonkri: not having ghc package is almost certainly fedora-related problem
08:17:34 <xplat> (when they don't come from specific fusible patterns like foldr/build anyway)
08:18:45 <elliott> xplat: well, mfix usually involves some kind of value recursion to write...
08:19:16 <jonkri> supki_: Why do you mean by "ghc" package? Is it something that should come with Cabal?
08:19:24 <jonkri> supki_: My Fedora GHC version if 7.4.2, and that's the only GHC version installed on my system.
08:19:43 <xplat> elliott: it's basically because of the pipes-4.0 idea of using iostreams-style consumers and respond composition more, which i think is a terrible idea but i'd like to have some alternative to suggest for how to get the speed benefits
08:19:57 <supki_> jonkri: ghc package should come with ghc
08:21:16 <xplat> elliott: a free MonadFix generated by a functor should allow moving the recursion to places outside the monadic code proper, i hope.  crossing my fingers here.
08:22:31 <benmachine> jonkri: (global constraint requires installed instance) basically means that cabal won't upgrade base under any circumstances (because it can't)
08:22:35 <dmwit> xplat: But if the ultimate goal is just to move the recursion outside the monadic code, you can just use fix. You don't need all these gymnastics...
08:23:38 <xplat> elliott: my hope is that it would be possible to then abuse the constructors in a MonadFix transformer to abstract over pure recursion even when the underlying monad doesn't support mfix
08:24:57 <xplat> dmwit: sure, except that means a lot of explicit knot-tying and extra parameters and (fmap.fmap.fmap) everywhere, it would be good to abstract over that
08:25:22 <elliott> forever m = fix (m >>)
08:25:28 <dmwit> xplat: Does it?
08:26:05 <klrr_> can FRP be applied to IO?
08:26:39 <tikhonjelvis> klrr_: What do you mean? Most practical FRP ends up doing IO stufff.
08:27:27 <klrr_> tikhonjelvis: does it? the stuff ive seen have mostly been graphics stuff like GUIs and games, well, that maybe is IO stuff, i mean rather could it replace lazy IO in haskell?
08:27:43 <xplat> dmwit: try representing a pipe 'map' as \f a -> ((request >>= (respond . f)) >>) and see if you can actually use it for anything
08:27:46 <tikhonjelvis> oh, lazy IO
08:28:03 <tikhonjelvis> I suppose it could, but that seems to be the domain of pipes and friends
08:28:08 <hape01> why is any cabal install only using one (1) cpu?
08:28:09 <tikhonjelvis> which are like limited versions of FRP
08:28:40 <klrr_> i know, but instead of having pipes we could have FRP for all that stuff
08:28:42 <bitonic> hape01: because you haven’t given it the “-j” flag
08:28:47 <xplat> dmwit: er, actually it requires more parameter management already ...
08:28:56 <klrr_> SINGAL! :D
08:28:59 <hape01> bitonic: thx
08:29:05 <klrr_> SIGNALS! :D*
08:29:14 <bitonic> hape01: note that parallel compilation of a single package is not supported, but parallel installation of packages is
08:29:30 <dmwit> xplat: This response definitely went over my head. Then again, I feel like the whole conversation so far has gone over my head, so it may not be worthwhile for you to try to drag me up to your level at the moment. =)
08:29:39 <klrr_> i gonna learn about pipes
08:29:46 <klrr_> and write an irc bot with it
08:29:51 <hape01> bitonic: that's kind of boost now :-)
08:29:56 <klrr_> >HAHHAHAHAHHA i got a project HHAHAHAH :D YEA!
08:30:09 <tikhonjelvis> Hmm, I think using FRP everywhere would be nice from a semantics point of view
08:30:21 <tikhonjelvis> but it turns out to be tricky to implement it efficiently
08:30:32 <tikhonjelvis> which matters for certain select pipes use cases
08:31:13 <xplat> dmwit: okay, try this: the problem with moving recursion outside the monadic code with 'fix' is you can get it outside the 'do' that's in front of you, but then try composing different pieces of code that are organized that way so the 'fix' ends up outside of *all* of it
08:32:17 <conal> tikhonjelvis: which raises a question: is there a semantically sound & elegant foundation that would support those use cases?
08:32:18 <dmwit> Okay, that seems like a difficult and interesting goal.
08:32:30 <conal> tikhonjelvis: (i.e., not necessarily FRP)
08:33:10 <xplat> yeah, i don't think FRP is actually the thing you want for generic IO stuff
08:33:11 <klrr_> tikhonjelvis: Elm got applacative FRP that is effecient and good for concurrency, some of the new imrpovements brought with it might be applied to this "everything FRP" library , here
08:33:31 <tikhonjelvis> hmm, I haven't used Elm, but I wasn't terribly happy with its abstractions
08:33:50 <tikhonjelvis> also, being strict and based on JS means it has very different constraints
08:34:06 <klrr_> tikhonjelvis: well, that's just an implementation detail
08:34:15 <xplat> there are specific things you do with streaming IO that can benefit from FRP (progress monitors, for example) but i don't think everything works well with that metaphor
08:34:20 <klrr_> tikhonjelvis: it havent anything to do with its improvement on the FRP abtraction
08:34:26 <tikhonjelvis> yes, but performance questions are all about implementation details
08:34:43 <klrr_> tikhonjelvis: http://www.testblogpleaseignore.com/wp-content/uploads/2012/04/thesis.pdf
08:35:30 <klrr_> tikhonjelvis: not really, at least from what i understood his improvements to FRP is not related to being compiled to JS AT ALL, JS is not even mentioned in the paper
08:35:44 <tikhonjelvis> it is related to its being strict
08:35:54 <kilo90> hello. will the 3rd and 4th patterns in the monad instance of maybe ever be used? aren’t they already covered by the first two lines? http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Maybe.html#Maybe
08:36:12 <kilo90> never mind
08:36:14 <klrr_> for example singals of singal aint allowed
08:36:38 <kilo90> I didn’t see that it’s the "then"-operator
08:37:05 <tikhonjelvis> hmm
08:37:22 <tikhonjelvis> the Elm demo page is lagging for me, but that might be my computer's fault
08:38:49 <tikhonjelvis> disallowing signals of signals doesn't sound like an improvement to me
08:39:25 <klrr_> tikhonjelvis: read the paper i likmed imstead
08:39:47 <merijn> killy9999: Note that defining >> is optional (you'd usually do it to special case/optimise >>) and not done very frequently
08:39:49 <merijn> eh
08:40:00 <merijn> s/kill9999/kilo90
08:41:17 <applicative> oh kilo90 vanished
08:43:33 <ParahSai1in> how does defining optional class functions work?
08:43:42 <enthropy> is there something for making it easier to derive Data/Typeable instances than http://lpaste.net/90994
08:43:50 <scshunt> ParahSai1in: you just provide a definition
08:44:09 <tikhonjelvis> I hacked together a framework vaguely similar to Elm in OCaml
08:44:11 <scshunt> e.g. class Foo a where { foo :: a -> Int; foo _ = 0 }
08:44:22 <tikhonjelvis> at least in the sense that it compiled down to JS and didn't have continuous time
08:44:28 <ParahSai1in> ah, nevermind http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Base.html#%3E%3E
08:44:36 <ParahSai1in> it gives a default (>>) there
08:45:17 <tikhonjelvis> but forcing things like the mouse position to have discrete changes led to some annoying code
08:45:51 <tikhonjelvis> unfortunately, I have no idea about how to get around that
08:45:54 <applicative> enthropy: that's a Read instance, no?
08:46:08 <Chousuke_> do any frp systems written for haskell use explicit "tick" sources?
08:46:49 <applicative> oh i see you mean http://lpaste.net/90994 enthropy
08:47:03 <enthropy> applicative: there is a Bytestring -> PNM function
08:47:03 <Chousuke_> ie. in order to get mouse updates, you'd have to first combine the signal with an "fps" timer.
08:47:39 <tikhonjelvis> hmm
08:47:51 <tikhonjelvis> I think that's how you would normally do that with something like Reactive Banana
08:47:59 * enthropy could just trust the header instead of using the derived data instance when checking that some images are actually have the same representation / bit depth
08:48:23 <tikhonjelvis> but it ultimately gets the mouse position behavior from a bunch of events generated by wxWidgets (or whatever GUI framework you're using)
08:49:01 <applicative> hm where is this material from enthropy, do you need StandaloneDeriving?
08:49:30 <applicative> i suppose you must, it's not the first thing to cross one's mind
08:50:04 <enthropy> applicative: from http://hackage.haskell.org/packages/archive/netpbm/0.3.0/doc/html/Graphics-Netpbm.html
08:50:23 <enthropy> which has no instances for Data, so I can't use    toConstr in a pattern guard
08:55:44 <applicative> enthropy: I see, I was thinking you were modifying that file
08:56:07 <applicative> enthropy: obviously you should tell him or her to derive (Typeable,Data)
08:58:19 <Sonarpulse> is there anyway I can work with an infinitely list generated from effectful actions?
08:58:32 <Sonarpulse> I am using System.Random.MWC
08:58:54 <Sonarpulse> which generates random numbers from a seed in an ST var
08:59:16 <Sonarpulse> I made a monad from "newtype Rand m out = Rand { unRand :: (Gen (PrimState m) -> m out) }"
08:59:56 <Sonarpulse> now I am trying to get a lazy infinite list with type "Rand [Double]"\
09:00:20 <Sonarpulse> basically if there was a repeatM, not just replicateM, my problem would be solved
09:03:37 <danilo2> Hi! I'm creating a custom language, which compiles to Haskell. I want to use Haskell type system as much as possible (to infer types and let users not to write types explicit) but I've got problem with implementing instances not writing types of functions explicit. I Would love to ask somebody, who knows good haskell for little help, to further introduce the problem :)
09:04:21 <monochrom> Sonarpulse: Control.Monad.ST.Lazy will help. see my http://lpaste.net/63925
09:06:04 <chunkstuntman> I'm having a problem with fractionals in my totient function
09:06:05 <chunkstuntman> http://lpaste.net/90995
09:06:43 <chunkstuntman> I'm not sure how to make 1.0 more fractional than it already is
09:07:07 <monochrom> danilo2: GADTs may help. generalized algebraic data types.
09:07:39 <monochrom> @type fromInteger
09:07:40 <lambdabot> Num a => Integer -> a
09:07:54 <enthropy> chunkstuntman: you should round prod
09:08:03 <enthropy> or truncate or whatever's most appropriate
09:08:33 <chunkstuntman> enthropy: rounding prod defeats the purpose
09:08:43 <monochrom> i is the integer that is not being fractional
09:09:24 <benmachine> fromInteger i * prod
09:09:31 <danilo2> monochrom: I'll look at GADTs - Could you please look here - it is better description of what I'm trying to do: http://stackoverflow.com/questions/17703940/type-inference-in-instance-functions-in-haskell
09:09:55 <Sonarpulse> monochrom: does that do something analogous to unsafeInterleaveIO
09:09:56 <monochrom> "arising from literal 1.0" means that 1.0 is forcing everyone else to be fractional. and this hurts i.
09:10:08 <enthropy> chunkstuntman: well if you don't round prod at some point, you won't get the result of totient to be Integer
09:10:14 <applicative> enthropy: hm, it was a little trouble to add .. Typeable, Data ... because of the TH in the middle
09:10:20 <monochrom> Sonarpulse: FSVO "analogous"
09:10:55 <enthropy> applicative: is this about Graphics.Netpbm?
09:11:26 <Sonarpulse> ok, that looks pretty good
09:11:32 <Sonarpulse> to get it perfect though
09:11:46 <Sonarpulse> anything that is polymorphic over IO, ST, etc?
09:12:15 <applicative> enthropy: yes
09:12:30 <Sonarpulse> PrimMonad m => something ?
09:13:19 <monochrom> danilo2: I don't understand 90% of the stackoverflow post.
09:14:11 <monochrom> for example I don't understand why use type classes and instances and what they have to do with a strongly typed language.
09:14:30 <applicative> shouldn't we just send him something like this patch? its up on github
09:14:47 <applicative> enthropy: ^^ i made a patch but lpaste thinks its spam
09:15:35 <applicative> enthropy: https://gist.github.com/michaelt/890ceba5a399f31d316b
09:15:55 <elliott> a false positive with the spam filter already? :/
09:16:30 <merijn> elliott: I get filtered out occasionally too :(
09:16:35 <merijn> Because I'm a spammer :(
09:17:08 <benmachine> merijn: maybe you should stop spamming so much, huh?
09:17:15 <benmachine> maybe THAT
09:17:15 <applicative> I wonder what it is, its kind of long, https://gist.github.com/michaelt/890ceba5a399f31d316b/raw/be1678a2c879bfea2acea5ced0a716252105ade8/gistfile1.hs
09:17:40 <applicative> sorry, spamming with git hash-y things
09:18:31 <danilo2> monochrom: I'll do everything I can to improove it to be understandable - could you please tell me what is not clear? I'm simply writing a parser: my language -> Haskell. I want to mimic in Haskell classes and methods (known from imperative world). I want to be able to create in Haskell function, which takes as 1st argument an object and computes somethink. Because I want to define such function for each type of this object I have 
09:18:44 <monochrom> I don't understand why use type classes and instances and what they have to do with a strongly typed language.
09:18:46 <enthropy> applicative: right that's one alternative. I was wondering about some TH-based solution which might be as simple as  $(writeOutAllTheStandaloneDerivingsForData ''PpmPixelData)
09:19:09 <danilo2> monochrom: And the problem is - I do NOT want to explicit write type signatures for this functions in the instances - I want typechecker to do it for me
09:19:22 <monochrom> classes and methods from the imperative world do not translate to type classes in haskell. repeat: do not.
09:19:25 <applicative> yeah i just think doing this in a separate module isn't safe
09:19:34 <applicative> enthropy: i mean doing it in you own module
09:20:02 <applicative> of course he's already doing GeneralizedNewtypeDeriving
09:20:03 <enthropy> applicative: if the TH is smart enough not to write instances that already exist, I'm not sure anything would break
09:20:35 <enthropy> if my module was compiled with the current Graphics.Netpbm, or with your addition
09:20:53 <applicative> it's probably a superstition but I believe Typeable derived other than by deriving (Typeable) is dangerous
09:21:49 <applicative> certainly writing one's own Typeable instance is Wrong
09:22:44 <enthropy> applicative: sometimes you have to, if your type has an odd kind like ((* -> *) -> *)
09:23:02 <namor> i'm trying to use portshaker to get the haskell development ports running in a jail for testing purpose currently. problem is i get "warnings" of conflicts and portshaker drops me into interactive mode for six ports (checkrdf,hs-bytestring-show,pure-gen,ghc,hugs,nhc98,hs-frantk). Is this intentional? Any way i dont have to type "i <enter>" multiple times during portshaker updates?
09:23:03 <applicative> yes then you need standalone deriving
09:23:06 <Fuuzetsu> I really feel that there should be an operator for liftA/liftM somewhere in prelude
09:23:21 <applicative> I guess I'm not following, though
09:23:31 <Fuuzetsu> I guess I can use <$> in my case
09:23:33 <enthropy> Fuuzetsu: `fmap` is infix ;)
09:23:34 <applicative> you need standalonederiving for GADTs too
09:24:07 <Fuuzetsu> @src liftA
09:24:07 <lambdabot> liftA f a = pure f <*> a
09:24:16 <namor> okay, wrong channel, sry
09:25:10 <merijn> Fuuzetsu: "pure f <*> a" is just "f <$> a", though
09:25:42 <merijn> All Applicative are guaranteed to be Functors
09:26:00 <klrr_> are there any mutable lists'ish datatype i can use inside the state monad?
09:26:05 <joelteon> a list
09:26:16 <applicative> fmap is in the prelude, but its a little strange theres no liftM2
09:26:50 <Fuuzetsu> merijn: yeah, I know
09:27:04 <applicative> klrr_: do you mean StateT listlike m r ??
09:27:20 <applicative> or do you mean ST s r
09:28:02 <klrr_> applicative: well, i want to use the State monad, but i need some way to remove items from the list, im writing an IRC bot and i will need to be able to remove and add moderators that can use certain actions
09:28:24 <applicative> well why isn't your state a list of moderators
09:28:35 <applicative> or a record with a field for moderators?
09:28:40 <klrr_>  applicative yes but then i cant remove moderators, or can i?
09:28:41 <applicative> or am I making no sense?
09:29:19 <klrr_> well, i can remove it by contructing a new list and use put to make it active, my question makes no sense now try for helpinh though :)
09:29:20 <applicative> klrr_: yes, currentstate <-get; put (removermoderator x currentstate)
09:29:36 <klrr_> yes yes i knwo how to do it now :P
09:29:42 <Sonarpulse> is there no prim monad instance for lazy ST?>
09:30:05 <Chousuke_> klrr_: you can't remove or add anything to a list, but State allows you to simulate that :P
09:30:19 <applicative> maybe rlechinsky didn't think it was worth the trouble? Sonarpulse
09:30:26 <applicative> pardon spelling r.l.
09:31:05 <monochrom> must you use PrimMonad? must you need the generality?
09:31:14 <danilo2> monochrom: I've fixed the question - Is it better now? (http://stackoverflow.com/questions/17703940/type-inference-in-instance-functions-in-haskell)
09:31:24 <monochrom> (what is PrimMonad anyway?)
09:31:32 <applicative> it is a constraint on a lot of Vector functions, PrimMonad m => blah
09:32:44 <Chousuke_> klrr_: also use modify instead of get+put if you just have a function that calculates the new state.
09:32:45 <jhance> monochrom: I think its used to abstract IORef and STRef and their respective monads
09:32:47 <applicative> monochrom: basically it means, 'either IO or ST s'
09:32:59 <klrr_> Chousuke_: ok
09:33:12 <chrisdone> applicative: did you manage to paste that thing that was spam blocked?
09:33:15 <Chousuke_> it basically does get and put anyway, but it's neater :P
09:33:20 <monochrom> danilo2: have you already designed the custom language? repeat: designed, I don't mean implemented. that is, specification.
09:33:39 <applicative> the specification is the hardest part!
09:33:41 <DanielDiaz> what library should I use for colors? Something that contains RGB, RGBA, etc, values. I don't want to rewrite that code.
09:34:21 <elliott> @hackage colour
09:34:21 <lambdabot> http://hackage.haskell.org/package/colour
09:34:22 <elliott> perhaps
09:34:27 <monochrom> especially because "class, object, method" means so many different things. just look at c++ java javascrpt ocaml ruby python. they all disagree.
09:34:53 <danilo2> monochrom: yes I did and right now I'm implementing it.
09:35:04 <monochrom> ok, may I read the specification?
09:35:04 <applicative> it has quite a few de[pendencies http://packdeps.haskellers.com/reverse/colour
09:36:42 <merijn> I don't see why the user not writing type signatures is relevant to the haskell implementation of your language?
09:36:58 <danilo2> monochrom: unfortunatelly it is not yet available to the public :( But if you have any specific question I'll be glad to answer it
09:37:14 <monochrom> I want to see its type system.
09:38:06 <DanielDiaz> elliott, applicative: I am looking at the library, I think it will work. Thank you.
09:38:06 <Sonarpulse> monochrom: primMonad basically lets you write stuff polymorphic over the various controll monads
09:38:15 <hashcat> is there any good reason tusing darcs rather than git?
09:38:24 <Sonarpulse> Control.Monad.Primative
09:38:37 <monochrom> or, if you want a summary of my current thought: I don't think haskell type class is relevant.
09:38:37 <chrisdone> hashcat: mostly for the way patches work with the patch theory
09:38:38 <elliott> DanielDiaz: :)
09:38:53 <chrisdone> hashcat: git cares a lot about the order in which you do things, darcs only cares about the changes
09:39:48 <Gothmog_> which isn't necessarily a good thing...
09:39:53 <Sonarpulse> frankly I think a lot of IO, ST, and STM stuff should be refactored to use them
09:40:02 <hashcat> chrisdone: is that means darcs generates smaller files?
09:40:05 <applicative> there is an elaborate bunch of stuff in juicy-pixels, that takes a different approach DanielDiaz https://github.com/Twinside/Juicy.Pixels/blob/master/Codec/Picture/Types.hs
09:40:28 <monochrom> Sonarpulse: which package has PrimMonad?
09:40:32 <Sonarpulse> base
09:40:34 <chrisdone> hashcat: i'm not sure what darcs's storage format is like
09:40:39 <Sonarpulse> http://hackage.haskell.org/packages/archive/primitive/0.2.1/doc/html/Control-Monad-Primitive.html
09:40:43 <chrisdone> and by not sure, i mean i have no idea
09:40:46 <Sonarpulse> sorry primitive
09:40:59 <applicative> 'primitive' has it monochrom
09:41:03 <DanielDiaz> applicative: but I don't need to deal with images, only colors.
09:41:05 <Sonarpulse> ok i guess it's less official than I thoght
09:41:28 <tony98> ciao
09:41:29 <danilo2> merjin: think about it like that: if the user writes something like (in pseudocode): "class A{def f(x,y){return x+y}};   a = new A(); a.f(5,6) than it is translated to Haskell code (assuming A is a data type) as "a = A; f a 5 6" and some instances, because another "class" can have method "f" also. As you can see in this example - user defines "f" as f(x,y){return x+y) not writing explicit types
09:41:31 <applicative> DanielDiaz: thts what i was wondering; i would think roconnor 's library will have thought that through....
09:41:35 <tony98> !lista
09:41:54 <hashcat> chrisdone: what's highlights of darcs compared to git
09:42:12 <Sonarpulse> still I imagine IORef and STRef could could just be Ref
09:42:34 <Sonarpulse> and the context would added other reistrictions
09:42:36 <danilo2> merijn: think about it like that: if the user writes something like (in pseudocode): "class A{def f(x,y){return x+y}};   a = new A(); a.f(5,6) than it is translated to Haskell code (assuming A is a data type) as "a = A; f a 5 6" and some instances, because another "class" can have method "f" also. As you can see in this example - user defines "f" as f(x,y){return x+y) not writing explicit types
09:42:47 <monochrom> interesting. I suppose a PrimMonad instance for ST.Lazy is possible
09:43:39 <hashcat> chrisdone: or another question, what advantages does patch theory have?
09:43:50 <Sonarpulse> yeah, should be
09:43:52 <Sonarpulse> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Control-Monad-IO-Class.html
09:43:57 <Sonarpulse> sorta overlaps with this too
09:44:19 <danilo2> monochrom: 2 lines up I've written an example for merijn - I would be thanful If you could read it - maybe it will clarify something :)
09:44:34 <monochrom> danilo2: translate A.f to haskell's f_A, B.f to Haskell's f_B. there is no need to overload f on the haskell side.
09:44:39 <applicative> Sonarpulse: people often write Ref typeclasses. there's one in the type families paper for example
09:44:40 * hackagebot monad-products 3.0.1 - Haskell 98 monad products  http://hackage.haskell.org/package/monad-products-3.0.1 (EdwardKmett)
09:44:41 <chrisdone> hashcat: well, for example, why do you have to rebase in git?
09:44:49 <applicative> Sonarpulse: I think they don't catch on too well
09:45:10 <Sonarpulse> I am thinking at some point all the control monads could use a reboot
09:45:14 <Sonarpulse> any plans for something like that?
09:45:20 <monochrom> there is, in fact, still nothing that convinces me that haskell type class is relevant.
09:46:03 <applicative> relevant to what?
09:46:16 <hashcat> chrisdone: I get it.
09:46:50 <elliott> Sonarpulse: a reboot?
09:47:04 <Sonarpulse> big rewrite
09:47:07 <chrisdone> elliott: like Star Trek
09:47:19 <chrisdone> Control.Monad.JJAbrams
09:47:21 <benmachine> Sonarpulse: what for?
09:47:23 <elliott> Sonarpulse: to what end?
09:47:25 <Sonarpulse> there's the whole *Ref vs *Var thing
09:47:43 <Sonarpulse> and now a bunch of non-standard stuff like the libary that is just linked
09:47:52 <danilo2> monochrom: If the user writes: x = fun1(fun2("something")); x.f() then I do NOT know what type is x, so I cannot choose myself if its f_A or f_B :( .
09:47:54 <benmachine> Sonarpulse: there's always going to be nonstandard stuff
09:48:10 <Sonarpulse> sure, but I'd like to see this type of stuff generalized
09:48:17 <Sonarpulse> * standardized
09:48:30 <benmachine> Sonarpulse: eh, that doesn't tend to be too important
09:48:32 <elliott> danilo2: haskell won't be able to choose either.
09:48:38 <elliott> you have to do type checking if you want overloading.
09:48:39 <elliott> or runtime dispatch.
09:49:21 <benmachine> Sonarpulse: I mean, what after all is the advantage of having code that can run in both IO and ST? why wouldn't you just run it in ST?
09:50:22 <Sonarpulse> from a user perspective, yes
09:50:37 <Sonarpulse> but from a libary perspective, annoying to write stuff twice
09:50:46 <benmachine> Sonarpulse: but why not just only write the ST version?
09:50:57 <danilo2> elliott: please look at the code I posted here (http://stackoverflow.com/questions/17703940/type-inference-in-instance-functions-in-haskell) - Haskell IS ABLE to choose - I simply do NOT want to explicit write the signature of f in instances.
09:51:16 <chrisdone> elliott: what's the word on your lambdabot repl replacement?
09:51:18 <Sonarpulse> say you need to do
09:51:25 <Sonarpulse> state -> IO -> state
09:51:25 <chrisdone> repl-acement
09:51:35 <Sonarpulse> if you don't have IO versions of the state stuff
09:51:49 <elliott> chrisdone: haven't gotten around to working on it more, am looking into stopgap things to solve the timeout/lens issues
09:51:50 <Sonarpulse> once you do the IO you are toast
09:51:55 <elliott> but will finish it when I get around to it
09:52:04 <chrisdone> gotcha, just curious
09:52:07 <Sonarpulse> also, all the various IO librarys like conduit would benefit
09:52:34 <applicative> i wonder what `primitive` does with touch :: PrimMonad m => a -> m ()
09:52:49 <benmachine> Sonarpulse: I don't think so. Broadly speaking you have code that can be implemented in ST, in which case it should be used with ST, or code that can't be implemented with ST, so there's no choice
09:53:33 <benmachine> Sonarpulse: I can think of reasons why you might want to write code polymorphic over both, but they're really quite rare
09:54:10 <Sonarpulse> to be honest, I am only starting to use these types of things
09:54:10 <applicative> oh i see touch# is in GHC.Prim
09:54:11 <benmachine> Sonarpulse: the lack of standardisation probably stems from a lack of demand
09:54:44 <Sonarpulse> so sure, I probaly am unaware of stuff that comes of in practice
09:56:40 <danilo2> elliot: If I run "f" function with the first argument of type "A" or "B" Haskell is able to choose right function from right typeclass. I simply dont want to write the signature of "f" in these typeclasses by hand (please look at the example WORING code: http://stackoverflow.com/questions/17703940/type-inference-in-instance-functions-in-haskell)
09:57:09 <pdxleif> I noticed - I have some packages listed by /usr/lib/ghc-7.6.3/package.conf.d, and some by /home/leif/.ghc/x86_64-linux-7.6.3/package.conf.d. When I do "./Setup.hs configure", it doesn't seem to notice the user-installed ones, but when I do "cabal configure", it does.
09:57:16 <elliott> danilo2: yes, haskell can know if the type is statically known
09:57:24 <elliott> if the type is statically known, then you can know it, too
09:57:30 <elliott> so what monochrom said was not wrong
09:57:37 <dcoutts> pdxleif: ./Setup.hs configure --user
09:57:57 <dcoutts> pdxleif: the default for ./Setup.hs is --global you see, for the cabal tool, the default is --user
09:58:15 <pdxleif> dcoutts: Ah, that does it - thanks!
09:59:23 <enthropy> danilo2: you can get some type information from    reify 'f2
09:59:35 <Sonarpulse> :q
09:59:44 <Sonarpulse> ...second time I've done that
10:00:04 <enthropy> provided the f2 is defined above where the template haskell splice that calls reify is actually run
10:01:11 <danilo2> elliott: the type is statically known. But I dont want to write my type checker if i dont have to. In the example I posted link to - Haskell is choosing right function for me. I think I didnt explained te problem well - If I write in haskell function like "f x=x*2" I do NOT need to write its type signature. I do not want to provide type signature in instances (please see the code and comments in the code) - Is it somehow possible?
10:01:32 <danilo2> elliott: If not - why? Could somebody explain me Why Haskell does no allow for such declaration?
10:02:19 <elliott> I think monochrom was more suggesting an alternate approach that he thinks you may find better, than telling you what you want cannot be done.
10:02:22 <elliott> but, for instance, from
10:02:25 <elliott> f _ i = i*2
10:02:31 <elliott> Int -> Int would *not* be inferred.
10:02:42 <elliott> because that works for all numeric types, not just Int (if anything, Integer -> Integer would be inferred thanks to defaulting)
10:03:04 <elliott> so this ambiguity seems to make what you want unfeasible. (consider also f _ i = i)
10:03:58 <danilo2> elliott: it will not, but I can use it as f 5 4. I do not want the Haskell inferencerr to infer thesse types in instances - I simply do not want to provide them by hand - When I will be using the functions later - Haskell will know what are the parameters types
10:04:29 <elliott> then I agree with monochrom, I don't think this is really much like typeclasses at all.
10:05:08 <danilo2> elliott: So is it not possible to have such functions in instances (functions with signature of a->b->c or something like that)?
10:06:23 <danilo2> elliott: hmm, ok so do you have any idea how couldd I translate such pseudocode to Haskell not using typeclasses:"class A{def f(x,y){return x+y}};   a = new A(); a.f(5,6)"
10:06:50 <danilo2> entrophy: I'm looking into reify right now
10:07:10 <elliott> I think you should probably do your own typechecking and then use a simple approach like monochrom's
10:09:45 <jhance> danilo2: When you make a small error you will regret not typechecking.
10:09:45 <danilo2> elliott: so I understand there is no way in Haskell to write in instances functions without specyfying full type by Hand?
10:09:46 * hackagebot Hipmunk 5.2.0.11 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0.11 (SoenkeHahn)
10:09:48 * hackagebot hackage-db 1.6 - provide access to the Hackage database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.6 (PeterSimons)
10:09:50 * hackagebot hackage-db 1.7 - provide access to the Hackage database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.7 (PeterSimons)
10:10:17 <elliott> well, I really don't understand what you're going for. but my best guess of what you want doesn't seem like it would work to me, and is not implemented in any case
10:11:19 <danilo2> jhnce: I know, but I'm talking about a domain psecific language I'm writing and ocmpiling to haskell and the typing in ythis languae will be optional, so I understeand what you mean, but still I have to solve this problem (for more info - see: http://stackoverflow.com/questions/17703940/type-inference-in-instance-functions-in-haskell)
10:12:01 <NiceOneBrah> hey all, could someone take a quick look at this code snippet and tell me how to eliminate the redundant declarations of my movePoint function?
10:12:01 <NiceOneBrah> http://lpaste.net/90997
10:13:25 <mauke> NiceOneBrah: data ColoredPoint = CP Color Int Int
10:13:49 <danilo2> elliott: Last clarification if I could :) I'm trying to write code like this: http://pastebin.com/3FT8PTjx (see the lines 8 and 11) - there are no explicite types - and this code does not compile - I would love to ask haskell to automatically infer these types where possible
10:13:55 <jhance> danilo2: Haskell can't magically infer what type you want to use to create a typeclass instance, though
10:14:11 <elliott> danilo2: like I said, the signature of f _ i = i*2 is not even Int -> Int.
10:14:14 <mauke> The paste 3FT8PTjx has been copied to http://lpaste.net/90998
10:14:21 <elliott> danilo2: and you should consider the other possible implementation f _ i = i
10:14:30 <elliott> given by class A{def f(x){return x}} or whatever.
10:14:36 <elliott> that cannot possibly get inferred like you want.
10:15:42 <danilo2> i know it is not Int -Int - it is a -> a. And thats fine - I dont want to get ocmpilation error and I thouht haskell would now what are these types when it will be using this function later. But as I see it is impossible to do :(
10:16:41 <jhance> :t f _ i = i * 2
10:16:42 <lambdabot> parse error on input `='
10:16:44 <danilo2> jhance: And there is no way to create typeclasses with "template" types - something like: http://lpaste.net/90998 ?
10:17:13 <NiceOneBrah> mauke: ah, of course. That makes sense. Out of curiosity, is there a way to put something like "_" in place of Red / Green / Blue on the left hand side to make the function accept all colors?
10:17:17 <jhance> danilo2, a -> b is completely different than Int -< Int, haskell will infer you want it to work forall. a b
10:17:33 <enthropy> danilo2: you can get those accepted by adding enough unsafeCoerces
10:17:42 <elliott> uh, unsafeCoerce is really not any kind of solution here.
10:17:59 <geekosaur> :t let f _ i -> i * 2 in f
10:18:00 <lambdabot> parse error on input `->'
10:18:03 <geekosaur> iios
10:18:05 <geekosaur> oops
10:18:11 <geekosaur> try sticking tot he same syntax...
10:18:18 <geekosaur> :t let f _ i = i * 2 in f
10:18:19 <jhance> :t let f _ i = i * 2 in f
10:18:19 <lambdabot> Num a => t -> a -> a
10:18:20 <lambdabot> Num a => t -> a -> a
10:18:27 <geekosaur> (started with a lambda, half rewrote into a let)
10:18:35 <jhance> is clearly *not* A -> Int -> Int
10:18:48 <enthropy> elliott: if the goal is typechecking the number of arguments,   f _ s1 s2 = "test"++ uc s1++ uc s2 where uc = unsafeCoerce -- is slightly useful
10:19:04 <danilo2> enthropy: elliot: How (or is it even sutiable to) use unsafeCoerces to solve this problem ?
10:19:20 <benmachine> unsafeCoerce is not going to work
10:19:38 <benmachine> there are very few situations in which it is safe and I don't think this is one of them
10:20:43 <allsystemsarego> Hi all, after some searching on stackoverflow, I still can't figure out what is the minimum amount of code one has to write to get from the JSON string {"mykey": "myvalue"} to a Haskell record. All the examples on stackoverflow seem excessively bloated. Any resources you can point me to?
10:21:49 <josephle> danilo2: just to be clear, are you trying to leverage haskell's type system to typecheck your language?
10:24:30 <danilo2> josephle: not exactly - I'm compiling my language to Haskell code - simply. I'm translating classes to data types and methods to functions of some instances of type classes.
10:25:56 <danilo2> josephle: Doing so, I'm generating Haskell code. The only problem is - I do not want to write my own typechecker. I want to translate something like "class A{def f(x,y){return x+y}};   a = new A(); a.f(5,6)"  to haskell. and when I'm trnaslating function "f" - it takes as the first argument "this" of type "A"
10:26:32 <danilo2> josephle: But as you can see, I want user not to write the types of x and y in function f definition
10:27:00 <josephle> okay
10:32:18 <supki> allsystemsarego: http://lpaste.net/4285999404285952000
10:34:18 <allsystemsarego> supki, thank you, that helps
10:36:21 <Blaine> Haskell newb here, having isues loading scripts into ghci using Mac's terminal. don't really know what I'm doing, this is my first real attempt at learning a language. any help?
10:37:32 <enthropy> danilo2: I gave an example of how you can write those instances you did manually using template haskell
10:38:43 <enthropy> danilo2: generally you'd put/hide the mkInst function in another module
10:39:15 <applicative> Blaine: hi
10:39:22 <applicative> Blaine what editor are you using?
10:39:48 <applicative> in any case in the terminal go to the directory with the file and do ghci Myfile.hs
10:40:04 <applicative> then when you edit file, inside ghci, do :r
10:40:11 <applicative> to reload with the revised definitions
10:41:36 <Blaine> applicative just txteditor. i don't think im navigating to the proper directory correctly, im not very familiar with terminal.
10:42:24 <applicative> is the terminal open?
10:42:39 <Blaine> yes
10:42:45 <applicative> (put it in the desktop thingy )
10:42:59 <applicative> are you in ghci or in the plain bash terminal
10:43:14 <mcstar> shell*
10:43:24 <applicative> thanks mcstar
10:43:30 <Blaine> plain bash right now.
10:43:56 <applicative> you are presumably in the home directory ~ = /Users/Blaine
10:44:04 <applicative> as will show if you type pwd
10:44:27 <applicative> if you saved the file on the desktop the simple thing is then
10:44:32 <applicative> cd Desktop
10:44:35 <applicative> ghci myfile.hs
10:44:45 <danilo2> enthropy: Thank you, I'm reading it right now :)
10:44:54 <supki> allsystemsarego: for such simple JSONs I would use lens-aeson though, it would as simple as  "{ \"key\": \"string\" }" ^? key "key" . _String  then
10:45:01 <applicative> or if its in a director /Users/blaine/haskell
10:45:05 <applicative> then from home,
10:45:08 <applicative> cd haskell
10:45:11 <applicative> ghci myfile.hs
10:46:15 <applicative> (hitting return after those commands)
10:46:27 <Blaine> ok, im definitely in the right directory now, but it's not finding the file.
10:46:40 <applicative> if you do
10:46:41 <applicative> ls
10:46:44 <applicative> does it show the file?
10:47:51 <roconnor> DanielDiaz: Let me know if you have any questions about my colour library.
10:47:56 <chrisdone> applicative: i think your paste was blocked due to all the links
10:48:15 <Blaine> yes. it's baby.hs.txt however. THAT might be a problem, right?
10:48:28 <mcstar> no, just give the full filename
10:49:13 <applicative> chrisdone: oh i see it links the specifications
10:49:38 <applicative> chrisdone: i see, its probably worth the occasional mishap like this
10:50:05 <applicative> Blaine: yes, you can i think tell textedit to save as .hs by insisting
10:50:14 <applicative> Blaine: in that dir
10:50:15 <applicative> do
10:50:22 <applicative> mv baby.hs.txt baby.hs
10:50:24 <applicative> to rename
10:50:37 <applicative> then ghci baby.hs
10:50:51 <applicative> oh, first do
10:51:06 <applicative> open baby.hs to reopen with the new name.  it will default to textedit
10:52:05 <DanielDiaz> roconnor: thank you, I think I managed to do what I needed: to have a datatype for colors from where I can extract the RGBA components.
10:52:25 <applicative> Blaine: i'm having a little trouble separating commands from commentary ;)
10:53:21 <Blaine> applicative: rename worked, loaded fine in ghci. but now it wont open in TxtEdit. (urhfajjashass!!!!)
10:53:34 <applicative> Blaine: are you still in ghci
10:54:03 <applicative> if so you can issue a shell command by prefixing :!
10:54:04 <applicative> thus
10:54:08 <applicative> :! open baby.hs
10:55:04 <chrisdotcode_> hello everyone :)
10:55:26 <chrisdone> hi chris
10:55:32 <Blaine> applicative: "No application knows how to open /Users/Blaine/Desktop/Haskell Test Functions/baby.hs."
10:55:33 <applicative> Blaine: or is the command "open baby.hs" not doing what I thought?
10:56:06 <applicative> hm, right
10:56:41 <geekosaur> open -e
10:56:41 <applicative> well, you should see it in finder, then you can direct to open in textedit, that's what you were using, right
10:56:47 <applicative> there is a command 'tell osa textedit.app blah blah' one could be using but i dont know it
10:57:15 <geekosaur> (forces TextEdit; same as "open -a TextEdit ...")
10:57:16 <applicative> is the default editor textedit, or is that what -e
10:57:26 <geekosaur>      -e  Causes the file to be opened with /Applications/TextEdit
10:57:28 <applicative> oh excellent , geekosaur knows
10:57:34 <Blaine> applicative: also, what's an easy way to leave ghci and go back to bash?
10:57:35 <geekosaur> there's no real concept of default editor
10:57:37 <mcstar> why not just open the file with vi?
10:57:43 <applicative> Blaine :q
10:57:47 <applicative> or :quit
10:58:10 <applicative> mcstar obvioulsy the default should be nano!
10:58:31 <mcstar> i didnt meant to flame
10:58:37 <mcstar> mean*
10:58:37 <applicative> i think if you open the .hs file from above requesting TextEdit it may default to that
10:58:41 <applicative> ha
10:59:05 * applicative used to have a *haskell highlighting* nanorc
10:59:07 <geekosaur> only if you hold option
10:59:21 <applicative> ah
10:59:23 <chrisdotcode_> hey, chrisdone
10:59:24 <geekosaur> "open as..." would change to "always open as..."
10:59:40 <geekosaur> (you can also set the application in the Get Info dialog)
10:59:43 <applicative> Blaine: anyway once you have ghci open in Terminal.app, and the file on the right in TextEdit
10:59:46 * chrisdone ruffles chrisdotcode's hair
10:59:57 <applicative> you can do save and then :r inside ghci to update
11:00:11 <Blaine> ok, dragging baby.hs directly onto the txedit icon allows it to open, but trying to directly open it doesn't... this WORKS, but it's just ridiculous.
11:00:14 <applicative> you can do save in TextEdit and :reload in ghci
11:00:51 <applicative> Blaine: did you see geekosaur 's instructions?
11:01:17 <applicative> open -a TextEdit baby.hs  -- i think
11:01:39 <geekosaur> or just: open -e baby.hs
11:01:41 <applicative> yeah it works here
11:01:51 <Blaine> oh, i see. missed that.
11:02:06 <applicative> bingo yes, works here open -e is your command
11:02:14 <mcstar> what is more important than haskell is to learn an editor, whether emacs or vim
11:02:21 <applicative> you should probably get a copy of texmate or sublime text 2 or whatever
11:02:33 <applicative> unless you want to listen to mcstar who is a Real Programmer
11:03:59 <applicative> if you want to see what emacs vim or nano are like just do nano baby.hs or etc.
11:04:03 <applicative> you'll regret it
11:04:36 <applicative> nano has the advantage that it's just like email circa 1993
11:04:42 <applicative> for nonprogrammers
11:05:20 <Blaine> o god nano... o_o
11:05:24 <applicative> hah
11:05:41 <Fuuzetsu> @pl f x y = x ++ "." ++ y
11:05:44 <monochrom> I used emacs for email and usenet, circa 2000
11:05:45 <lambdabot> f = id (fix (const (flip ((.) . (++)) ("." ++))))
11:05:45 <lambdabot> optimization suspended, use @pl-resume to continue.
11:06:16 <monochrom> I am too cheap to pay money for editors, IDEs, and what-have-you
11:06:21 <byorgey> id (fix (const ..., wat
11:06:36 <elliott> .@pl is "interestingly" broken now
11:06:41 <byorgey> apparently so
11:06:42 <Fuuzetsu> …now?
11:06:43 <elliott> I want to outsource it to the pointfree package
11:06:46 <elliott> which I understand is less broken.
11:06:52 <Blaine> ok. ok. how do i leave nano?
11:06:53 <Fuuzetsu> @pl f x y = x ++ y
11:06:53 <lambdabot> f = (++)
11:06:53 <monochrom> nice, thanks
11:07:01 <monochrom> ctrl-x leaves nano
11:07:04 <applicative> control-x
11:07:27 <monochrom> the bottom of the nano screen shows a lot of keys and what they do
11:07:46 <Blaine> oh duh, THAT'S what ^X means. i din't realize ^==ctrl
11:08:28 <monochrom> :)
11:08:33 <geekosaur> Blaine: somewhat more practical suggestions for editors you might want to look at (although several are commercial): TextWrangler, TextMate, Sublime Text
11:09:02 <Fuuzetsu> wait, isn't there a function in Data.List somewhere that does f x xs = foldr (\a b -> a ++ x ++ b) [] xs?
11:09:14 <Fuuzetsu> :t f x xs = foldr (\a b -> a ++ x ++ b) [] xs
11:09:14 <lambdabot> parse error on input `='
11:09:23 <Blaine> geekosaur: thanks, i'll look at them. this is all a bit overwhelming, but im happy to finally start learning this stuff:)
11:09:33 <Fuuzetsu> :t let foo = foldr (\a b -> a ++ x ++ b) [] xs in foo
11:09:34 <lambdabot>     Not in scope: `xs'
11:09:34 <lambdabot>     Perhaps you meant one of these:
11:09:34 <lambdabot>       `x' (imported from Debug.SimpleReflect),
11:09:40 <Fuuzetsu> :t let foo x xs= foldr (\a b -> a ++ x ++ b) [] xs in foo
11:09:40 <lambdabot> [a] -> [[a]] -> [a]
11:09:56 <Fuuzetsu> @hoogle [a] -> [[a]] -> [a]
11:09:57 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
11:09:57 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
11:09:57 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
11:10:17 <Fuuzetsu> intercalate "..." (map show [1 .. 5])
11:10:21 <Fuuzetsu> > intercalate "..." (map show [1 .. 5])
11:10:22 <lambdabot>   "1...2...3...4...5"
11:10:22 <monochrom> sounds like intercalate with a fence-post (off-by-1) difference
11:10:23 <Fuuzetsu> cool
11:10:44 <monochrom> or maybe I'm the one with the fence-post error
11:11:15 <monochrom> > foldr (\a b -> a ++ "..." ++ b) [] (map show [1..5])
11:11:16 <lambdabot>   "1...2...3...4...5..."
11:11:18 <applicative> Blaine, the main terminal commands become unconscious in a half an hour
11:11:20 <jhance> I'd just like to point out that real programmers use ed, the standard unix text editor.
11:11:25 <applicative> hah
11:11:32 <monochrom> haha, you're the one with the fence-post error :)
11:11:33 <Fuuzetsu> oh
11:11:37 <Fuuzetsu> well, intercalate is what I wanted ;)
11:11:59 <Fuuzetsu> > foldl (\a b -> a ++ "..." ++ b) [] (map show [1..5])
11:12:00 <lambdabot>   "...1...2...3...4...5"
11:12:12 * applicative is trying to think why its called fencepost
11:12:23 <Fuuzetsu> > foldr1 (\a b -> a ++ "..." ++ b) (map show [1..5])
11:12:24 <lambdabot>   "1...2...3...4...5"
11:12:25 <Fuuzetsu> ha
11:12:37 <applicative> I see you need n+1 fenceposts for n panels or whatever
11:12:48 <Blaine> also, as a general question, what's my best bet for making a little $ w/ programming? medium term i want this to be fun & useful for me.
11:12:52 <geekosaur> because too many/not enough fenceposts are the most ready non-computing example
11:13:01 <geekosaur> and used to be quite common
11:13:02 <applicative> Blaine: learn javascript obviously
11:13:24 <jhance> learn cobol and charge the banks big money to fix their bad programs written in it
11:13:35 <josephle> Blaine: learn CSS and design. Most companies already have enough javascript programmers. :P
11:13:37 <Fuuzetsu> s/fix/break them more/
11:13:56 <Blaine> applicative: java has been on my list of "to learn" for awhile.
11:13:56 <monochrom> only you know what is "fun" to you
11:13:59 <geekosaur> (not just fenceposts themselves, but I recall seeing lots of fences with too many or not enough posts a lot as a kid...)
11:14:25 <Fuuzetsu> Blaine: Java ≠ JavaScript
11:14:47 * hackagebot git-monitor 2.0.1.1 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-2.0.1.1 (JohnWiegley)
11:15:05 <mcstar> > compare "Java" "JavaScript"
11:15:06 <lambdabot>   LT
11:15:12 <applicative> Blaine: a little Haskell is worthwhile. It sounds like you will learn a bit about consoles en passant ....
11:15:16 <Blaine> fuuzetsu: oh duh. i've a bit of a way to go, havent i?
11:15:34 <applicative> "Haskell: A great way to learn bash"
11:15:40 <mcstar> o.O
11:15:49 <Yaniel> :D
11:15:57 <monochrom> unless you use winghci
11:16:02 <mcstar> or zsh
11:16:12 <Fuuzetsu> or your editor's bindings
11:16:18 <mcstar> and a console is not a shell, again
11:16:25 <Blaine> Long term goal of mine is personal projects involving powerful AI. functional languages seem good for that.
11:16:32 <monochrom> if you're on mac and with some money, haskell is a great way to learn sublime
11:16:37 <applicative> mcstar: you can see how much learning Haskell has taught me
11:17:03 <Blaine> (aslo, Haskell is just the sexiest name for a language. FACT)
11:17:08 <Yaniel> well if you are on mac you probably do have some money anyways :D
11:17:09 <monochrom> cabal is a great way to learn rm -rf
11:17:20 <applicative> hah
11:17:21 <mcstar> (i wouldnt suggest for a beginner that he could actually earn money with haskell, i think that has a remote chance)
11:17:22 <Fuuzetsu> monochrom: I thought that having a Mac automatically qualified you as a person with too much money to waste?
11:17:26 * Fuuzetsu ducks
11:17:44 <Blaine> ha, some saved up, but if i try and do every project i've got planned i'll run out in no time.
11:17:53 <applicative> well, it turns out they're cheaper than getting the degree necessary to use anything else
11:18:07 <augur_> not satisfied with death defying magic tricks, david blaine has taken up functional programming
11:18:11 <applicative> I mean macs are...
11:18:28 <Fuuzetsu> I forgot that you need a degree to use a computer nowadays. Silly me.
11:18:40 <Fuuzetsu> BSc in Common Sense
11:18:56 <simukis_> Fuuzetsu: Are you sure that's enough?
11:19:07 <Fuuzetsu> A degree or common sense?
11:19:13 <Blaine> degree? ha. i rip txtbooks online whenever i need to. autodidact is fun.
11:19:17 <Yaniel> BullSh*t courses in Common Sense
11:19:21 <applicative> getting a sensible unix on a cheap laptop is an extraordinay commitment
11:19:27 <monochrom> bootstrap problem: you need an online degree to learn how to take online courses
11:19:34 <applicative> anyone who denies this is just silly
11:19:55 <Fuuzetsu> applicative: 1. Pop in a mainstream GNU/Linux distro CD 2. Click ‘Next’ a few times
11:20:03 <monochrom> I am extraordinarily silly
11:20:28 <jhance> Fuuzetsu: Then it won't be sensible, it will be bloated!
11:20:31 <applicative> I think you are forgetting how much you know, this is very commmon especially for computer things
11:20:33 <monochrom> or perhaps you just fudge the criteria for "sensible" and "cheap"
11:20:34 <Blaine> i was gonna learn today, but you guys are more fun than i expected.
11:20:35 * johnw feels like he's in -blah
11:20:36 <applicative> like stupid bash commands
11:20:46 <applicative> johnw yes, right
11:21:32 <Fuuzetsu> applicative: I don't see how OSX lets you stay away from ‘stupid bash commands’ any more than a Linux distro. Let's end the topic though, it's not going to go anywhere nice
11:22:00 <applicative> Fuuzetsu: it doesn't it makes it easy to use 'stupid bash commands'
11:22:04 <jhance> Fuuzetsu: Actually, I think OSX uses zsh not bash
11:22:18 <applicative> you can get all the way to "ls" without a diploma!
11:22:22 <Yaniel> it uses bash by default
11:22:27 <jhance> Oh, it does?
11:22:31 <jhance> Never used one.
11:22:32 <Fuuzetsu> jhance: They are pretty much the same things for anyone doing basic tasks
11:22:33 <Blaine> http://lesswrong.com/lw/kg/expecting_short_inferential_distances/ or http://en.wikipedia.org/wiki/Mind_projection_fallacy *whistles innocently*
11:22:34 <applicative> it says "bash" at the top of this terminal
11:22:37 <monochrom> another bootstrap problem: you need GHC to build GHC :)
11:22:43 <Yaniel> actually IIRC it is a PITA to tell it to use zsh by default
11:22:55 <jhance> Yaniel: No chsh?
11:23:04 <Fuuzetsu> monochrom: I actually had this problem recently, it sucked ;(
11:23:24 <monochrom> yikes. you were building for which platform?
11:23:34 <Fuuzetsu> x86 :P
11:23:37 <Blaine> monochrom: i actually luaghed when i read that getting ghc today.
11:23:45 <geekosaur> OS X uses bash by default (on panther and earlier it used tcsh)
11:23:47 <Yaniel> there is chch
11:23:51 <Fuuzetsu> I just purged my system off GHC so I had to set out to find a binary
11:23:54 <Yaniel> chsh*
11:24:03 <jhance> ghc takes a very long time to compile even once you have a binary to bootstrap off of.
11:24:20 <Fuuzetsu> See, I don't actually find that true.
11:24:26 <applicative> i just set the Grass terminal to use zsh
11:24:28 <Fuuzetsu> I see people claiming horrendous times like 20 hours.
11:24:29 <b52> fpcomplete center broken?
11:24:34 <johnw> if you're not running tests, ghc doesn't take that long to compile
11:24:34 <chrisdone> b52: hm?
11:24:43 <monochrom> "long time" is subjective. mind projection fallacy. etc etc :)
11:24:45 <johnw> for me it's 8.5 hours for "full build + full tests + nofib performance tests"
11:24:52 <johnw> I think the ghc build proper takes <30 mins
11:24:58 <Fuuzetsu> right
11:25:02 <applicative> that fits with my experience
11:25:03 <jhance> It takes me about 1-2 hours for a proper build
11:25:13 <Fuuzetsu> tests don't pass for me by default so I just shrug it off and don't do it
11:25:18 <Blaine> also, tangentially related to haskell, what's a good irc client? webchat works, but... you know.
11:25:19 <jhance> but I'm on a laptop, so its going to be a bit slower
11:25:27 <jhance> Blaine: weechat
11:25:28 <roconnor> It took like a day to build GHC on my raspberry pi
11:25:29 <applicative> brew install irssi
11:25:32 <monochrom> http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml :)
11:25:34 <applicative> ;)
11:25:43 <b52> chrisdone: "Process load failed" all the time I try to run something, it just states it can't load one of my modules but no hint why
11:25:46 <jhance> weechat is sort of like a nicer version of irssi
11:25:54 <FreeFull> I only downloaded GHC so I could look at the source
11:25:56 <applicative> roconnor: I hadn't known you were such a ... hacker
11:25:56 <FreeFull> I never built it
11:25:57 * geekosaur uses xchat from macports. textual is rather up and coming, colloquy is popular
11:26:01 <joehillen> monochrom: why don't you create a ppa?
11:26:15 <roconnor> applicative: It was part of my quest to get GHC into nixos on the pi.
11:26:15 <monochrom> because I don't like creating a ppa
11:26:28 <joehillen> monochrom: oh, nvm, these are tarballs
11:26:31 <FreeFull> Because screw ubuntu
11:26:32 <Fuuzetsu> Is there a reason for such an old dependency on libgmp?
11:26:32 <roconnor> applicative: I need a GHC binary :D
11:26:37 <geekosaur> (textual costs if you get the prebuilt binary, is free w/o support if you build yourself from source. but, if you can do that, you're not a beginner :)
11:26:44 <Fuuzetsu> IIRC I had to do some symlink hackery just for this reason
11:26:47 <jhance> geekosaur: Hexchat is a nice fork of xchat, too (its what I'm using at the moment, actually)
11:26:50 <joehillen> monochrom: I thought you were hosting deb files
11:26:58 <monochrom> and because these tarballs are more flexible re: configure --prefix=wherever-you-want
11:27:01 <jhance> Just to throw out some more names.
11:27:10 <roconnor> applicative: raspian comes with a GHC binary, but it isn't packaged properly for bootstrapping.
11:27:25 <roconnor> I figured it would be easier to build my own GHC binary on raspian.
11:27:43 <roconnor> using the packaged binary of course
11:28:04 <monochrom> Fuuzetsu: yes, the builder of the official binaries use a pretty old debian. (perhaps "pretty old debian" is redundant and can be simplified to "debian")
11:28:43 <Fuuzetsu> monochrom: the builder of the official binaries hasn't been building for weeks
11:28:58 <Fuuzetsu> there was an e-mail out on ghc-devs recently that it's coming back though
11:30:46 <chrisdone> b52: can you report the behaviour on http://support.fpcomplete.com/?
11:31:08 <Fuuzetsu> I wonder if learnyouahaskell.com is going to get renewed
11:31:19 <chrisdone> b52: i'll pm you
11:32:05 <klrr_> chrisdone: do you work at fpcomplete?
11:33:05 <chrisdone> klrr_: yep :-)
11:33:18 <klrr_> cool
11:33:33 <Yaniel> I hope they keep the epic drawings on learnyouahaskell if they change the site
11:33:41 <klrr_> what is fpcomplete? :P tutorial resource / web IDE ?
11:34:49 <chrisdone> all of the above :-)
11:34:55 <byorgey> klrr_: FP Complete is a company.
11:34:59 <Phyx-> kitchen sink?
11:35:05 <roconnor> chrisdone: does FP complete have remote workers?
11:35:19 <klrr_> kinda random still nice, also, why would someone program in the web browser over using their favorite text editor?
11:35:32 <chrisdone> roconnor: yep!
11:35:54 <byorgey> klrr_: those are not mutually exclusive.  What if a web IDE was so great that it became your favorite text editor?
11:36:34 <jhance> oh, that beta ide runs as a webapp?
11:36:34 <klrr_> im not so fond of web stuff
11:36:38 <roconnor> chrisdone: oh!!
11:36:48 <klrr_> jhance: yes
11:36:48 <byorgey> klrr_: noted.
11:36:50 <applicative> roconnor: yes emphatically
11:37:03 <byorgey> does FP complete have non-remote workers?
11:37:29 <byorgey> Does FP Complete have a canonical physical location?
11:37:31 <klrr_> byorgey: are you also working there? also, im not trying to be mean to fpcomplete, im just sceptical that it will succeed, but really cool if it does!
11:37:36 <roconnor> how about foriegn remote workers :D
11:37:47 <klrr_> also, i know many do like web stuff, many haskell people
11:37:53 <applicative> the israel-lebanon border is definitely foreign roconnor
11:37:54 <byorgey> klrr_: nope, I am a PhD student
11:37:55 <klrr_> that might like it
11:37:59 <chrisdone> roconnor: most if not all of us work remote
11:38:04 <klrr_> byorgey: =o
11:38:14 <klrr_> byorgey: what are you researching?
11:38:15 <chrisdone> roconnor: i'm in italy, snoyberg's in israel
11:38:31 <byorgey> klrr_: programming languages, generally speaking
11:38:37 <roconnor> amazing
11:38:54 <chrisdone> byorgey: there is a place in california for the canonical location, but we're very much a remote-working company relying heavily on hangouts/video conferencing
11:39:02 <djahandarie> Wow, didn't know that either you or snoyberg worked there.
11:39:07 <byorgey> ah, california
11:39:09 <byorgey> right, that's what I thought
11:39:18 <klrr_> byorgey: well, that doesnt say much :P can you be more specific?
11:39:32 <byorgey> klrr_: http://www.cis.upenn.edu/~byorgey/
11:41:09 <klrr_> chrisdone: i like the new bootstrap-like UI on the website
11:41:51 <klrr_> byorgey: have you research FRP? :)
11:41:59 <chrisdone> klrr_: cool, we'll be rolling more of that for the school pages in a couple weeks :-)
11:42:24 <Lethalman> oh I can import two qualified modules under the same name
11:42:34 <Lethalman> like import qualified Foo as F; import qualified Bar as F
11:42:35 <klrr_> chrisdone: i will keep an eye on it, fpcomplete news usually come up in haskell subreddit so i guess i wont miss much
11:42:35 <Lethalman> cool
11:43:01 <klrr_> byorgey: could haskell lazy IO be replaced with FRP (streaming'ish) IO? =o
11:43:36 <byorgey> klrr_: No, I haven't, though I have a package called 'active' (currently undergoing a complete rewrite from scratch to be 100% more awesome) which is kind of like FRP without the R.
11:43:43 <monochrom> you can also "import Foo as F; import Bar as F"
11:43:57 <byorgey> klrr_: I have no idea.
11:44:14 <byorgey> though replacing lazy IO with something more principled sounds like a win to me.
11:44:17 <sclv> everything in haskell is FP without the R!
11:44:18 <Lethalman> byorgey, FAP? :P
11:44:19 <sclv> :-P
11:44:22 <monochrom> in fact, you can also "import Data.List as Prelude; import Control.Monad as Prelude"
11:44:39 <fryguybob> sclv: beat me to it :D
11:44:40 <roconnor> I don't know about *replacing* lazy IO.  Lazy IO is a toy and it has it's place.
11:44:52 <byorgey> sclv: despite what the acronyms may suggest, I assure you that FRP - R  and  FP  are not the same =)
11:44:59 <roconnor> persumaly no one uses it for serious programming.  ^_^
11:45:01 <applicative> lazy io is a miracle a human thought
11:45:03 <Lethalman> monochrom, it's a useful feature
11:45:11 <applicative> of human thought
11:45:12 <sclv> or you could just use R for everything and pretend its FP
11:45:13 <monochrom> yes
11:45:23 <byorgey> Lethalman: hahah, Functional Active Programming, right =)
11:45:29 <applicative> which is the non-lazy io that everyone uses?
11:45:48 <sclv> strict
11:45:50 <monochrom> getChar
11:45:50 <roconnor> applicative: hGetChar
11:45:53 <applicative> hah
11:46:03 <klrr_> byorgey: i want to study languages when i go to univ :D
11:46:03 <applicative> hGetSome
11:46:13 <augur_> klrr_: human or prgramming languages
11:46:13 <byorgey> klrr_: sounds great!
11:46:18 <klrr_> programming
11:46:19 <klrr_> ofc :P
11:46:30 <augur_> boring!
11:46:31 <byorgey> haha, augur_ studies the other kind of languages =)
11:46:39 <klrr_> hehe
11:46:56 <klrr_> well, i got a univ which have a lot of haskell and agda people :)
11:47:00 <klrr_> in my city
11:47:04 <byorgey> klrr_: cool, which one is that?
11:47:08 <klrr_> chalmers
11:47:15 <byorgey> ahh, excellent
11:47:54 <klrr_> i just have to study hard in high school , starting it after summer :) although i guess i wont learn much about programming in high school i will take all math courses i can
11:48:11 <merijn> \o/
11:48:15 <merijn> I'm not crazy
11:48:20 <merijn> "so either the semantics are really undefined or there is indeed a bug in reactive-banana."
11:48:40 <byorgey> klrr_: yes, if you are going to be at chalmers studying as much math as you can will be helpful =)
11:48:55 <dgpratt> merijn, I don't see how that proves you aren't crazy
11:49:06 <merijn> dgpratt: Ssshhh
11:49:11 <dgpratt> :)
11:49:19 <applicative> klrr_: study logic away from cs too
11:49:58 <klrr_> applicative: in univ or high school?
11:50:09 <merijn> At least my craziness is not affecting my ability to reason about FRP code, which is good, because at least that means I can still be confident in the fact that I finally "got" FRP :)
11:50:14 <klrr_> not sure if there was any courses about logic in the hgih school im going too
11:50:16 <conal> klrr_: much of what you'd learn about programming in high school (or even college) wouldn't be fundamental anyway and will probably become obsolete soon. math will give you a more enduring background.
11:50:33 <klrr_> i know
11:50:53 <applicative> ah, the wisdom of conal coming as it were from no where or from above.
11:50:54 <klrr_> i got friends who study programming in high school and they say it's basically useless
11:51:03 <klrr_> still, i can get good grades from it :P
11:51:19 <merijn> Let me put it this way, after my masters in CS I'm convinced it would have been a better time investment do take a degree in math and practice systems programming in my spare time
11:51:22 <roconnor> I recommend taking typing in high school
11:51:41 <klrr_> roconnor: what's that?
11:51:48 <roconnor> klrr_: where you learn to touch type.
11:51:57 <monochrom> electric typewriters use static typing :)
11:52:12 <klrr_> touch type?
11:52:12 <roconnor> :)
11:52:17 <klrr_> i dont get it sry
11:52:22 <djahandarie> roconnor, I think all kids know how to touch type these days.
11:52:23 <roconnor> typing without looking at the keyboard.
11:52:28 <roconnor> djahandarie: really?
11:52:29 <dgpratt> I took typing in HS -- I was never very good at it -- I told my teacher by the time I'd have a job, we would all be talking to our computers instead of typing
11:52:36 <dgpratt> me == fail
11:52:38 <djahandarie> roconnor, at least the majority, yeah.
11:52:44 <DanielDiaz> is there any pretty-printer library around using Text instead of String?
11:52:46 <roconnor> djahandarie: I find that hard to beleive.
11:52:47 <applicative> yes typing is very important; I never learned the top row, and somehow it's too late...
11:53:02 <sclv> DanielDiaz: search hackage theres a bunch
11:53:09 <DanielDiaz> sclv: so I am doing
11:53:10 <klrr_> roconnor: lol im sitting in front of computer whole day my typing isnt anything wrong with, although i should start moving by words and not by chars in vi, i would be much faster writing code then :P
11:53:10 <merijn> dgpratt: Unless your unemployed, then there's still time
11:53:16 <sclv> DanielDiaz: http://hackage.haskell.org/package/wl-pprint-text-1.1.0.0
11:53:20 <sclv> is one that i have been told is good
11:53:40 <sclv> and one of my packages uses just fine (someone else patched it to use text instead strings)
11:53:44 <merijn> klrr_: Disable your arrow keys, that's a good way to train going to insert mode to move, which means moving by words/lines/search is much easier
11:53:55 <DanielDiaz> sclv: I will take it a look, thanks.
11:54:06 <dgpratt> merijn, alas I've been paid to type poorly for over 15 years now
11:54:18 <jhance> You can learn how to touchtype just by sitting at a keyboard and moving your fingers, really.
11:54:37 <monochrom> dgpratt: watch Star Trek IV. Scotty picks up a Mac Classic mouse and treats it as a microphone :)
11:54:47 <dgpratt> monochrom, yes, that's a good scene :)
11:54:57 <roconnor> you don't need to touch type in order to program, but it doesn't make using a computer more pleasent.
11:54:59 <monochrom> haha
11:55:13 <dgpratt> monochrom, I get a lot of enjoyment out of how he pronounces "computer"
11:55:21 <klrr_> merijn: already doing that, but im using hjkl to move around, i should start using wjkb instead
11:55:25 <mr-> merijn: you navigate in insert mode? weird
11:55:41 <jhance> klrr_: disable h and l
11:55:42 <klrr_> merijn: also havent learned to copy paste in vi yet :P using X11's pasting
11:55:54 <jhance> klrr_, y
11:56:18 <klrr_> or remap them? so i got moving left and right with chars on wb, and having moving by words on hl?
11:56:24 <roconnor> I isntalled someone's vimrc file and now I can't figure out how to use X11 cutting.
11:56:26 <mr-> klrr_: d for cut, y for copy, p for paste (and select in vidual mode)
11:56:38 <mr-> s/vidual/visual/
11:56:43 <jhance> also P for paste on the next line
11:57:00 <klrr_> roconnor: you only use mouse to select text and click the scroll button to paste
11:57:04 <applicative> DanielDiaz: or https://github.com/mainland/mainland-pretty/blob/master/Text/PrettyPrint/Mainland.hs
11:57:04 <mr-> jhance: awesome! ;-)
11:57:43 <applicative> DanielDiaz: i.e. mainland-pretty
11:59:07 <dgpratt> for anyone who's bad at typing, I would recommend getting a "natural" keyboard and start using the dvorak layout
11:59:30 <DanielDiaz> applicative: they are really similar. why should I use one or the other? where are the differences?
11:59:42 <dgpratt> that way whenever you have to type on someone else's computer, you can blame it on the keyboard/layout
12:00:13 <jhance> dgpratt: Change their layout to dvorak for them and they probably won't know how to change it back
12:01:01 <dgpratt> jhance, :)
12:01:58 <k00mi> there is no evidence that dvorak is actually the better layout, much less the best
12:02:00 <k00mi> SCNR
12:02:14 <jhance> k00mi: Other than the fact that qwerty was designed to be bad
12:02:27 <k00mi> that is a myth
12:02:45 <chrisdone> jhance: designed to not jam, at least
12:02:50 <k00mi> there has been some new research into the origin of qwerty recently
12:02:55 <k00mi> let me search
12:02:56 <Fuuzetsu> k00mi: Have you actually typed in English using Dvorak? It feels much more comfortable and natural (and it well bloody should do)
12:03:02 <Fuuzetsu> It's not a speed contest
12:03:06 <k00mi> i'm typing dvorak right now
12:03:14 <Fuuzetsu> Then what's the problem?
12:03:30 <k00mi> that it isn't the best
12:03:35 <Fuuzetsu> No one said it was
12:03:56 <BeardedCoder> I switched to dvorak around 2-3 years ago, If I could do it again I would probably stick with qwerty
12:03:58 <byorgey> this is off-topic
12:04:16 <k00mi> jhance: http://www.economist.com/node/196071
12:04:21 <Fuuzetsu> There was a cool experiment done a few years ago where a guy coded up a genetic algorithm to pick the best keyboard layout for supplied English text and it pretty much always diverged to Dvorak (with minor changes)
12:04:29 <Fuuzetsu> I think the site that hosted went down months ago though
12:04:55 <Fuuzetsu> yes, offtopic, sorry
12:07:16 <applicative> I wonder if some version of blaze-whatever is the going method of pretty printing with text and bytestring, really
12:09:51 <carter> dcoutts at some point in the next day or so, I'd like to spend some time finding out whats needed to get hackage2 ready for release
12:10:06 <carter> dcoutts I and 1-2 other peole seem to want to help and push that along
12:10:31 * benmachine wonders what dcoutts II thinks
12:10:56 <carter> benmachine eh?
12:11:07 <benmachine> don't worry, I am just being silly
12:11:30 <benmachine> I decided that you meant 2-3 people including one called dcoutts I
12:12:27 <carter> benmachine i've decided it be worth sacrificing a few weekends to help move hackage2 along
12:17:30 <applicative> what is the default fixity of backticked things like `mappend`
12:19:21 <supki> > (0$0`mappend`)
12:19:21 <lambdabot>   The operator `Data.Monoid.mappend' [infixl 9] of a section
12:19:22 <lambdabot>      must have l...
12:19:35 <geekosaur> think it's 5-nonassociative like for any other infix? and fixity declarations work
12:19:43 <benmachine> no it's infixl 9
12:19:51 <benmachine> as supki just demonstrated, rather ingeniously
12:20:00 <geekosaur> yeh
12:20:08 <benmachine> it is however possible to give fixity declarations for backticked stuff
12:20:19 <benmachine> cf. `seq` has very low fixity
12:20:59 <applicative> hah, supki, very clever
12:21:11 <zacts> I want to name my cat haskell
12:21:30 <benmachine> zacts: you wouldn't be the first
12:22:18 <benmachine> http://haskellthecat.tumblr.com/
12:22:31 <applicative> i see, so Data.Monoid.<> is infixr 6 `mappend` is infixl 9
12:22:59 <applicative> so for builders, one should use <> not `mappend`
12:23:39 <FreeFull> <> is more convienient anyway
12:26:33 <FreeFull> benmachine: That cat is the lambda cat
12:26:43 <FreeFull> If you catified lambda
12:26:46 <FreeFull> It'd be that cat
12:28:17 <jhance> benmachine: He looks lazy... just like haskell
12:29:38 <benmachine> FreeFull: http://spl.smugmug.com/Humor/Lambdacats/13227630_eKt46#!i=960526154&k=sQxNwtJ
12:31:41 <benmachine> actually I kinda think most of those are unfunny
12:31:48 <benmachine> but they exist nonetheless
12:32:12 <Lethalman> let's say I have f :: Eq a => Foo a, and I'd like to have something like Foo a = Eq a => a -> a -> Bool
12:32:31 <Lethalman> that would be forall, so it's wrong
12:32:34 <Fuuzetsu> benmachine: c'mon, KittehT is a great joke
12:32:40 <Lethalman> then I tried Eq a => Foo a = a -> a -> Bool but no luck
12:32:44 <Lethalman> is it possible somehow or not?
12:32:45 <chrisdone> benmachine: yeah they're too forced, spontaneous ones are best
12:34:50 * hackagebot atomic-primops 0.2.2.1 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.2.2.1 (RyanNewton)
12:36:14 <dmwit> Lethalman: I object to the assertion that you have f :: Eq a => Foo a.
12:36:29 <Lethalman> dmwit, ?
12:36:35 <dmwit> Except for particularly boring instantiations of Foo.
12:37:11 <Lethalman> dmwit, I have Eq a => [a] -> Matcher a where Matcher a = [a] -> Maybe Score
12:37:16 <dmwit> Lethalman: Your question begins, "suppose I have X". I claim you do not have X, and therefore the remainder of the question isn't useful.
12:37:35 <Lethalman> is that better?
12:37:43 <dmwit> yep, now let's see if I can understand the rest
12:38:20 <dmwit> I'm not really sure how you want us to be reading these equations.
12:38:30 <Lethalman> mh
12:41:03 <dmwit> I mean, are you wishing you could write "type Foo a = Eq a => a -> a -> Bool" as a line in your source or something?
12:42:17 <Lethalman> sorry, looks like I don't need any constraint in Matcher
12:42:35 <Lethalman> dmwit, yes, but apparently I don't need it
12:42:51 <Lethalman> because the Eq a was only needed in the function f
12:43:18 <Lethalman> that is match :: Eq a => [a] -> Matcher [a], type Matcher a = a -> Maybe Score
12:43:18 <benmachine> Lethalman: well, Eq a => [a] -> Matcher a expands to Eq a => [a] -> [a] -> Maybe Score, so you already have Eq there
12:43:35 <Lethalman> benmachine, yes, the trick is the partial application
12:43:43 <Lethalman> whatever needs the Eq is already computed
12:44:02 <benmachine> I'm not sure I understand but if you're happy I'm happy
12:44:11 <benmachine> or at least, I'm happy about the amount of happy that you are
12:44:22 <chrisdone> benmachine: https://plus.google.com/102125020195927401442/posts/5UYTc4N8X2x =p
12:44:35 <Lethalman> benmachine, my explanation doesn't have much theoretical sense, but I understood what's going on :P
12:45:15 <benmachine> chrisdone: :P
12:50:37 <chrisdone> @faq can haskell be used to discover why dogs eat grass?
12:50:37 <lambdabot> The answer is: Yes! Haskell can do that.
12:51:47 <Taneb> chrisdone, apparently it is to settle their stomachs
12:51:55 <carter> @faq will it help my social life? :)
12:51:56 <lambdabot> The answer is: Yes! Haskell can do that.
12:52:05 <Taneb> @unmtl ReaderT cd (State ci) Bool
12:52:05 <lambdabot> cd -> (State ci) Bool
12:52:16 <taylorgb_> I suppose that's the exception that proves the rule
12:52:46 <nexx> @faq can't Haskell do it?
12:52:46 <lambdabot> The answer is: Yes! Haskell can do that.
12:53:24 <Fuuzetsu> …unmtl?
12:53:27 <Fuuzetsu> this sounds useful
12:53:37 <dmwit> ?unmtl cd -> State ci Bool
12:53:38 <lambdabot> cd -> State ci Bool
12:53:42 <dmwit> yeesh
12:53:42 <carter> what is it?
12:53:46 <dmwit> ?unmtl State ci Bool
12:53:47 <lambdabot> ci -> (Bool, ci)
12:54:09 <Taneb> It rather stupidly unwravels mtl Transformer stacks
12:54:15 <Taneb> Except it only does one level?
12:54:18 <dmwit> carter: It used to expand and simplify all the mtl types into plain (->), (,), Either, etc.
12:54:23 <dmwit> Now it just does one level, yeah.
12:54:26 <dmwit> bleh
12:54:32 <carter> thats neat
12:55:45 <dmwit> ?unmtl RWST r w s t lol
12:55:46 <lambdabot> r -> s -> t (lol, s, w)
12:58:19 <NemesisD> hey guys i need some help extricating myself from this disaster of an abstraction. there may be a better way to do it but i first want to get it compiling
12:58:44 <taylorgb_> sounds scary
12:58:51 <lpaste> NemesisD pasted “state machine mess” at http://lpaste.net/91001
12:59:33 <NemesisD> trying to model a user-definable state machine that can run actions on transitions
13:04:24 <NemesisD> btw i hope there's a better way to do this
13:05:38 <taylorgb_> Isn't the nested do-block meant to have type IO a because of the call of runStateMachine?
13:05:54 <taylorgb_> I.e., you don't need to lift the putStrLn
13:09:45 <NemesisD> taylorgb_: i've gotten quite confused, i thought i had to lift those because transition is using features from the reader and writer monads
13:10:22 <NemesisD> but yeah removing those liftIOs seems to produce the equivalent errors so i think you're right
13:11:21 <taylorgb_> See if I can divine the real problem
13:11:22 <tomejaguar> Has comonad.com gone forever?
13:11:31 <taylorgb_> Unless someone with a brain beats me to it
13:12:01 <dmwit> tomejaguar: Nah, just until edwardk (or another interested party) decides to put in the effort required to revive it.
13:12:13 <dmwit> tomejaguar: If you are an interested party, you should volunteer.
13:13:01 <NemesisD> taylorgb_: i'm also pretty perturbed/confused about setting the initial state and that runWriterT $ runReaderT there
13:14:16 <taylorgb_> yeah, that seems to have its own error
13:16:15 <jonkri> Has anyone here seen this Emacs error before: "File mode specification error: (file-error "Cannot open load file" "ghc")"?
13:17:14 <taylorgb_> NemesisD: What is your runStateMachine meant to be doing exactly?
13:19:48 <NemesisD> taylorgb_: so your statemachine defines an onTransition hook that returns value in a monad, the runStateMachine is meant to run that onTransition, move your state forward, and abort if the transition isn't valid
13:20:26 <NemesisD> which i attempt to do with MonadPlus in transition
13:21:35 <taylorgb_> and this 'action' parameter?
13:22:25 <NemesisD> taylorgb_: that's the monadic action starting on line 13 that does the transitions in the aforementioned monad
13:23:36 <NiceOneBrah> when you define a function and you use pattern matching to deconstruct one of the arguments to the function is there a way to refer to that entire argument on the right hand side of the definition?
13:23:51 <taylorgb_> lst@(h:t)?
13:24:55 <NiceOneBrah> taylorgb_: awesome, that was exactly what I was looking for. thanks!
13:25:06 <taylorgb_> np
13:25:09 <NemesisD> taylorgb_: just as a side question, does any of this implementation seem like a reasonable way to do this?
13:25:25 <taylorgb_> I think there are probably easier ways
13:25:51 <sm> hey all
13:25:52 <taylorgb_> I'm a little confused about the two effects though, because the statemachine actually returns this m a, but you also have the m a you pass in
13:25:57 <taylorgb_> so they need to interleaved or something#?
13:26:00 <joachifm> jonkri: that error most likely means you have to add the directory where ghc.el is stored to load-path.
13:26:15 <NemesisD> this initially started as a thought "i bet it would be really easy to write a haskell library for state machines w/ feature parity with the ruby equivalent
13:26:50 <sm> does anyone remember the name of that all-embracing haskell web browser/editor/computing environment that was being actively developed a couple of years back ?
13:27:05 <type_> what would be the best way to run cabal build && cabal test automatically when any .hs file changes?
13:27:20 <elliott> sm: manatee?
13:27:27 <johnw> type_: you could use hobbes I suppose
13:27:33 <johnw> or what was that other package, watcher?
13:27:37 <NemesisD> type_: if you don't mind using ruby i use this https://gist.github.com/MichaelXavier/5847963
13:27:47 <sm> elliott: that's the one, thanks
13:29:09 <taylorgb_> Anyway, I think you need someone with superior brain power
13:29:56 <NemesisD> taylorgb_: i appreciate your efforts
13:30:20 <jonkri> joachifm: Thanks. I had put the files in the wrong place. :-)
13:30:26 <NemesisD> ill try again tonight, looks like my lunch break is over. back to the ruby mines :/
13:30:36 <sm> type_, johnw: shaker apparently does that
13:31:23 <sm> I tend to bypass cabal and use sp (the old searchpath tool)
13:39:04 <tomboy64> for someone who only has a faint grasp of what a Monad is and who has no idea about Applicatives - does it make a difference whether i use replicateM or replicateA?
13:39:48 <hpc> ?hoogle replicateM
13:39:48 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
13:39:48 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
13:39:48 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
13:39:52 <hpc> ?hoogle replicateA
13:39:52 <lambdabot> Data.Sequence replicateA :: Applicative f => Int -> f a -> f (Seq a)
13:39:57 <sm> type_: and now I remember why I still like sp + ghc: I can auto-build code spanning multiple packages. And avoid building unnecessary executables in multi-exe packages. And have more control generally.
13:40:35 <hpc> tomboy64: ...maybe; in theory, the two should be equal
13:41:39 <tomboy64> ^^ sounds promising, hpc
13:42:44 <hpc> hoogle isn't 100% of hackage, but i am still conflazzled by the two queries giving different results
13:43:53 <Fuuzetsu> :t fix (++)
13:43:54 <lambdabot>     Couldn't match type `[a0] -> [a0]' with `[a0]'
13:43:54 <lambdabot>     Expected type: [a0] -> [a0]
13:43:54 <lambdabot>       Actual type: [a0] -> [a0] -> [a0]
13:43:56 <Fuuzetsu> :t fix
13:43:57 <lambdabot> (a -> a) -> a
13:45:07 <benmachine> :t fix ((++) "10")
13:45:07 <lambdabot> [Char]
13:46:03 <Fuuzetsu> > fix ((++) "10")
13:46:04 <lambdabot>   "10101010101010101010101010101010101010101010101010101010101010101010101010...
13:46:15 <Fuuzetsu> > take 6 $ fix ((++) "10")
13:46:16 <lambdabot>   "101010"
13:46:29 <dmwit> > cycle "10"
13:46:31 <lambdabot>   "10101010101010101010101010101010101010101010101010101010101010101010101010...
13:47:09 <benmachine> > fix (take 6 . (++) "10")
13:47:10 <lambdabot>   "101010"
13:47:28 <lelf> > fix show
13:47:29 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
13:48:06 <taylorgb_> NemesisD: I'm not 100% certain but I think that http://lpaste.net/3994602894207746048 might do what you want
13:48:19 <taylorgb_> As I'm not exactly sure of you're requirements I can't be certain
13:49:00 <Fuuzetsu> @pl f x y z = x ++ y ++ z
13:49:03 <lambdabot> f = id (fix (const (flip ((.) . (.) . (++)) (++))))
13:49:03 <lambdabot> optimization suspended, use @pl-resume to continue.
13:49:34 <haskOK> how can I show all functions of a type class in ghci?
13:49:47 <Fuuzetsu> haskOK: :i <class>
13:49:48 <tromp> @instances Monad
13:49:48 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
13:50:04 <haskOK> thx
13:50:08 <roconnor> lambdabot: what, no WrappedMonad?
13:50:23 <benmachine> there are a lot of monads and only one λb
13:50:34 <Fuuzetsu> λ⊥
13:50:44 <hpc> Fuuzetsu: lambdabutt?
13:51:15 <benmachine> that's λω
13:51:16 <Fuuzetsu> I'm not sure where in the world bottom would be pronounced ‘buttom’
13:51:31 <hpc> teehee, you said ω
13:51:49 <Fuuzetsu> (∙ω∙)
13:52:10 <dmwit> ?instances-importing Control.Applicative Monad
13:52:11 <lambdabot> ((->) r), ArrowMonad a, ContT r m, Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
13:52:19 <taylorgb_> By the way does anyone know the idiomatic way of doing x or x >> y, depending on whether y happens to be just or not
13:52:23 <dmwit> roconnor: According to http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html#t%3aWrappedMonad, WrappedMonad isn't an instance of Monad.
13:52:36 <Fuuzetsu> :t fromMaybe
13:52:36 <lambdabot> a -> Maybe a -> a
13:52:43 <Fuuzetsu> hmm
13:52:43 <Eduard_Munteanu> Let command :: String, args :: [String]. Is there a function that safely converts those two into a string that can be executed by system or other unsafe execution functions? Safe wrt bash would be enough.
13:52:46 <Fuuzetsu> :t maybe
13:52:47 <taylorgb_> Oh
13:52:47 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:52:47 <hpc> taylorgb_: x <|> (x >> y)?
13:52:54 <taylorgb_> hpc: yeah
13:53:14 <dmwit> > mconcat [Just (), Nothing]
13:53:16 <lambdabot>   Just ()
13:53:23 <merijn> Eduard_Munteanu: What does "safe wrt bash" mean?
13:53:24 <dmwit> > mconcat [Just (), Just ()]
13:53:25 <lambdabot>   Just ()
13:53:35 <johnw> Eduard_Munteanu: see runProcess
13:53:37 <merijn> Eduard_Munteanu: Doesn't kill your machine? Doesn't produce an error?
13:53:42 <Fuuzetsu> :t maybe x (>> y) y
13:53:43 <lambdabot>     Couldn't match type `m0 b0' with `Expr'
13:53:43 <lambdabot>     Expected type: m0 a0 -> Expr
13:53:43 <lambdabot>       Actual type: m0 a0 -> m0 b0
13:53:54 <roconnor> dmwit: ah of course.
13:53:57 <roconnor> silly me
13:54:04 <Eduard_Munteanu> merijn: no expansion/globbing can happen
13:54:16 <Fuuzetsu> :t let y = undefined in maybe undefined (>> y) y
13:54:16 <lambdabot> Monad m => m b
13:54:17 <roconnor> dmwit: though perhaps it ought to be.
13:54:24 <Eduard_Munteanu> merijn: it should work exactly like exec, IOW
13:54:30 <johnw> Eduard_Munteanu: runProcess
13:54:32 <merijn> Eduard_Munteanu: Why not use exec then?
13:54:44 <hpc> taylorgb_: or (x >> y) <|> x -- this is one of those interesting situations where (<|>) commutes
13:54:51 <merijn> System.Posix has a bunch of wrappers and so does Sytem itself, afaik
13:54:59 <Eduard_Munteanu> merijn: because I want to build a string for xmonad's spawnAndDo without reimplementing it.
13:55:21 <Eduard_Munteanu> johnw: well, I don't just want to run it
13:55:21 <geekosaur> Eduard_Munteanu, did you have a problem with my suggestion yesterday
13:55:23 <geekosaur> ?
13:55:25 <taylorgb_> interesting
13:55:37 <geekosaur> because if you want a *real* one you will have to reimplement spawnAndDo
13:55:37 <merijn> Oh, then you need to manually escape any quoting/globs
13:55:43 <johnw> Eduard_Munteanu: you mean, you want to render a quoted string suitable for shell execution?
13:55:50 <geekosaur> (although I think someone else has been talking about doing so)
13:55:53 <johnw> Eduard_Munteanu: I know that Shelly has the code to do that
13:56:00 <Eduard_Munteanu> geekosaur: quoting every character? I'm not sure that works, I thought maybe there was a function that did that.
13:56:03 <johnw> but it's all based on Text, so you'd have to hack it out
13:56:09 <geekosaur> I assure you it works
13:56:11 <Eduard_Munteanu> johnw: yeah, that's the plan
13:56:54 <geekosaur> unless you men "I'm feeding ti a single string and it should parse it like a shell" (good luck with that. really, stop now.) or "it should magically know which spaces are real and which not" (uhhh)
13:57:21 <johnw> geekosaur: I would like a String -> (String,[String]) shell-style parser
13:57:27 <geekosaur> sigh
13:57:47 <geekosaur> no, I don't think you really do. or rather, you have not thought through what that involves
13:57:48 <lpaste> Quchen pasted “incorrect span implementation” at http://lpaste.net/91002
13:57:55 <johnw> geekosaur: I do, and I have
13:58:04 <geekosaur> it involves either (a) using a shell, or (b) pretending to be a shell and hoping the shell doesnt change
13:58:06 <Eduard_Munteanu> geekosaur: no, I have the args separated already... it should have a type like String -> [String] -> [String]
13:58:10 <Eduard_Munteanu> Err.
13:58:18 <Eduard_Munteanu> String -> [String] -> String
13:58:32 <quchen> Soo a friend of mine just gave me this implementation of span. Is the reason why it fails obvious to you? It kind of surprised me.
13:58:34 <geekosaur> ok, so I ask again, what was wrong with my suggestion?
13:59:11 <quchen> I'm just asking you guys whether I can file this under "laziness you're drunk" in my programming folder :-)
13:59:51 <Eduard_Munteanu> geekosaur: nothing, I may actually do that after all, although I did ask #bash and for some reason they said "no". :)
14:00:02 <Fuuzetsu> @pl f x = (++) . (++ x)
14:00:05 <lambdabot> f = id (fix (const (((++) .) . flip (++))))
14:00:05 <lambdabot> optimization suspended, use @pl-resume to continue.
14:00:12 <Fuuzetsu> useless
14:00:17 * Eduard_Munteanu is trying to think of counterexamples
14:00:21 <geekosaur> well, what i offered was brute force. it is however guaranteed to work
14:00:29 <Eduard_Munteanu> Hm.
14:00:41 <geekosaur> unless you actually want the shell to expand some parts of it, in which case you're in trouble anyway
14:01:18 <geekosaur> purists won't like it. but purists will tell you to reimplement spawnAndDo in terms of safeSpawn, which is apparently what you are trying to avoid
14:01:29 <Eduard_Munteanu> Yeah.
14:01:34 <benmachine> quchen: do you know about understanding foldr in terms of replacing the : with f and the [] with z?
14:01:35 <Eduard_Munteanu> (I don't want any expansion)
14:02:00 <quchen> benmachine: Yes.
14:02:24 <quchen> benmachine: That's not where the error comes from though.
14:02:29 <benmachine> quchen: so it seems to me like what's going to happen here is somewhere near the end of the list something is going to be put into "r"; then everything to the left of it is going to hit the first case
14:02:35 <Eduard_Munteanu> geekosaur: does it matter if I quote just "unsafe" parts or everything? I'm not sure.
14:02:37 <quchen> benmachine: Right.
14:03:14 <quchen> benmachine: It builds up the full thunk just in order to check whether r is empty, and once it hits one element that satisfies the predicate, it unravels the list from the back.
14:03:16 <geekosaur> well, the porblem with "unsafe" --- which i was alluding to when johnw stepped in --- is that what is unsafe depends on the exact shell, and can change on you without warning
14:03:40 <benmachine> quchen: right
14:03:51 <quchen> benmachine: Don't look in the future of foldr's accumulator :-)
14:04:18 <geekosaur> (well, part of what I was alluding to. the rest is that the POSIX shell's quote processing is astoundingly complex to get right)
14:04:56 <geekosaur> (but that wouldn't affect you since you're doing the opposite of what johnw was asking about)
14:05:07 <benmachine> quchen: I'm a little unclear on why you say "that's not where the error comes from", what you mean by that
14:05:35 <benmachine> quchen: from what I said one can conclude that at most one thing ends up in the second element of the tuple, therefore the implementation is wrong
14:07:48 <benmachine> quchen: wait, I'm silly
14:07:53 <quchen> benmachine: What you said was right, but you can actually get multiple elements in the second/first element of the tuple.
14:08:05 <benmachine> quchen: you're right, yeah
14:08:11 <quchen> The "not null" part is just not very practical.
14:08:23 <quchen> Also laziness etc.
14:08:28 <benmachine> well basically what the function is doing is wrong :P
14:08:55 <quchen> Well that's not very hard to find out.
14:09:15 <benmachine> quchen: also, isn't the expected result actually the expected result of span odd?
14:09:16 <quchen> The definition looks like it's right to me though
14:09:18 <benmachine> or break even, equivalently
14:09:24 <benmachine> (no pun intended)
14:10:25 <quchen> No, "span' even [1,4,7,8,9]" should be ([1], [4,...]), but it's ([9],[1,4,7,8])
14:10:39 <quchen> It's not switched or backwards, it's wrong all the way. ;-)
14:10:53 <benmachine> > span even [1,4,7,8,9]
14:10:54 <lambdabot>   ([],[1,4,7,8,9])
14:11:00 <mstksg> is there a simple way to derive "show" for functions?
14:11:01 <c_wraith> that looks right to me
14:11:10 <c_wraith> mstksg: nope.
14:11:46 <benmachine> mstksg: many functions cannot be shown at all; certain types can be, but not often in a way that is useful
14:12:03 <quchen> huh
14:12:06 <mstksg> i guess you could view the thunk or something
14:12:14 <quchen> Oh, so my expectation was wrong as well. Good lord.
14:12:24 <quchen> Anyway, this function is wrong and I need a timeout ;-)
14:12:49 * Eduard_Munteanu is annoyed enough he'll just patch xmonad
14:13:11 <quchen> Eduard_Munteanu: Hatecoding, the driving force of open source software. :P
14:13:22 <Eduard_Munteanu> Heh.
14:13:40 * Eduard_Munteanu goes ragepatch it
14:14:03 <benmachine> quchen: here's how I think about it: go gets passed x and span p xs, and wants to make span p (x:xs)
14:14:27 <kartlos> hey guys, is anyone using the fp complete IDE beta? it seems to be down...
14:14:34 <quchen> benmachine: I just misremembered span I think. span p xs = (takeWhile p xs, dropWhile p xs) or something, right?
14:14:41 <benmachine> quchen: yes
14:14:43 <quchen> Ah.
14:14:53 <quchen> I thought it was along the lines of "break the list once the predicate is true".
14:15:26 <quchen> i.e. a find-based version of the function, as opposed to a take-based one.
14:15:43 <mstksg> i think you're looking for partition
14:15:52 <benmachine> no I think you're looking for... something else
14:15:52 <quchen> That may very well be the case.
14:15:59 <benmachine> possibly findIndex with splitAT
14:16:01 <mstksg> er, wait
14:16:05 <mstksg> no, i misunderstood
14:16:08 <quchen> splitAt is index-based.
14:16:11 <Fuuzetsu> @pl f x y = [x] ++ [y]
14:16:14 <lambdabot> f = fix (const (flip ((.) . (:)) (: [])))
14:16:14 <lambdabot> optimization suspended, use @pl-resume to continue.
14:16:18 <Fuuzetsu> @pl f x y = x : [y]
14:16:21 <quchen> partition categorizes the entire list, so no.
14:16:21 <lambdabot> f = id (fix (const (flip ((.) . (:)) (: []))))
14:16:21 <lambdabot> optimization suspended, use @pl-resume to continue.
14:16:21 <benmachine> right, so findIndex tells you where to split, and splitAt splits there
14:16:38 <benmachine> or maybe you're just looking for something that's nearly span but not
14:16:49 <benmachine> (note that break p = span (not . p)
14:16:50 <dmwit> break
14:16:51 <benmachine> )
14:16:54 <dmwit> yes =)
14:17:24 <quchen> Oh, right.
14:17:40 <quchen> Well. I guess everyone now knows very clearly how often I use Data.List's API.
14:17:48 <benmachine> :P
14:17:53 <benmachine> it's ok, we don't judge
14:18:18 <aristid> at least not when you can hear it
14:18:42 <quchen> aristid: Very nice of you :-)
14:18:54 <Fuuzetsu> :t ((++) . return) <$> (undefined :: Identity Char) <*> (undefined :: Identity Char)
14:18:55 <lambdabot>     Couldn't match type `Char' with `[Char]'
14:18:55 <lambdabot>     Expected type: Identity [Char]
14:18:55 <lambdabot>       Actual type: Identity Char
14:20:17 <lelf> Eduard_Munteanu: you can use smth like arg0 "$(echo <base64-encoded arg1> | base64 -D)" ...
14:20:23 <lelf> but maybe I'm joking
14:26:26 <sssobhan> can i print a [[string]] ?
14:26:55 <gnuvince> sure
14:27:13 <tac> > print [["Hello, "Yes", "you", "can"], ["sssobhan"]]
14:27:14 <lambdabot>   <hint>:1:52:
14:27:14 <lambdabot>      lexical error in string/character literal at end of input
14:27:16 <tac> doh
14:27:21 <tac> > print [["Hello", "Yes", "you", "can"], ["sssobhan"]]
14:27:22 <lambdabot>   <IO ()>
14:27:41 <arkeet> > print "tac"
14:27:42 <lambdabot>   <IO ()>
14:27:55 <quchen> > let print = id in print "tac"
14:27:56 <lambdabot>   "tac"
14:28:20 <luzie> > id "tac"
14:28:21 <lambdabot>   "tac"
14:28:29 <tac> > fix id
14:28:31 <sssobhan> > print
14:28:32 <lambdabot>   <() -> IO ()>
14:28:32 <lambdabot>   mueval-core: Time limit exceeded
14:28:37 <quchen> inb4 fix error
14:28:40 <sssobhan> > print "Hi"
14:28:41 <lambdabot>   <IO ()>
14:28:45 <arkeet> > fix error
14:28:46 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:28:48 <luzie> > fix print
14:28:48 <arkeet> error fixed!
14:28:49 <lambdabot>   <IO ()>
14:29:05 <Eduard_Munteanu> lelf: hm, interesting
14:29:55 <sssobhan> and can i have 2 mapM behind each other ?
14:30:31 <arkeet> :t mapM . mapM
14:30:33 <lambdabot> Monad m => (a -> m b) -> [[a]] -> m [[b]]
14:31:00 <arkeet> :t mapM mapM
14:31:00 <lambdabot> Monad m => [a -> m b] -> [a] -> [m [b]]
14:31:17 <hpc> :t sequence .: mapM mapM
14:31:17 <lambdabot>     Not in scope: `.:'
14:31:17 <lambdabot>     Perhaps you meant one of these:
14:31:18 <lambdabot>       `.' (imported from Data.Function),
14:31:23 <hpc> :(
14:31:34 <arkeet> @let (.:) f g x y = f (g (x y))
14:31:35 <lambdabot>  Defined.
14:31:47 <arkeet> oops
14:31:49 <arkeet> @undefine
14:31:49 <lambdabot> Undefined.
14:31:51 <arkeet> @let (.:) f g x y = f (g x y)
14:31:52 <lambdabot>  Defined.
14:32:05 <arkeet> @let foo = 5
14:32:06 <lambdabot>  Defined.
14:32:07 <arkeet> @undefine foo
14:32:08 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
14:32:17 <arkeet> at least it tells us that now
14:32:24 <sssobhan>   r <- quickQuery' conn "select msg from todo where name = 'sobhan';)" []
14:32:25 <sssobhan>   print (mapM_ . mapM_ fromSql r)
14:33:07 <sssobhan> still gives an error
14:33:36 <luzie> > fix ((+) foo)
14:33:40 <lambdabot>   mueval-core: Time limit exceeded
14:33:55 <sssobhan> > let a = 2+ 5
14:33:56 <lambdabot>   not an expression: `let a = 2+ 5'
14:34:05 <sssobhan> >  2+ 5
14:34:06 <lambdabot>   7
14:34:14 <FreeFull> > let a = 2 + 5 in a
14:34:15 <lambdabot>   7
14:34:52 <benmachine> sssobhan: several reasons why that wouldn't work
14:34:58 <sssobhan> oh
14:35:02 <benmachine> sssobhan: what's the type of fromSql?
14:35:08 <benmachine> and r?
14:35:11 <arkeet> @let instance Num [()] where fromInteger = replicate `flip` (); (+) = (++); (-) = undefined; (*) = liftA2 (const.const $ ()); abs = undefined; signum = undefined
14:35:12 <lambdabot>  .L.hs:123:23:
14:35:12 <lambdabot>      Couldn't match type `Int' with `Integer'
14:35:12 <lambdabot>      Expected ty...
14:35:24 <arkeet> @let instance Num [()] where fromInteger = (replicate `flip` ()) . fromInteger; (+) = (++); (-) = undefined; (*) = liftA2 (const.const $ ()); abs = undefined; signum = undefined
14:35:25 <lambdabot>  Defined.
14:35:39 <sssobhan> benmachine: [[SqlValue]]
14:35:49 <sssobhan> benmachine: and fromSql ->String
14:36:03 <benmachine> sssobhan: you mean SqlValue -> String?
14:36:11 <arkeet> @undefine
14:36:11 <lambdabot> Undefined.
14:36:22 <arkeet> @let instance Num [()] where fromInteger = (replicate `flip` ()) . fromInteger; (+) = (++); (-) = (\\); (*) = liftA2 (const.const $ ()); abs = undefined; signum = undefined
14:36:23 <lambdabot>  Defined.
14:36:29 <sssobhan> benmachine: no r -> [[SqlValue]] and fromSql -> string
14:36:36 <arkeet> > 2 + (3 * 2) :: [()]
14:36:39 <lambdabot>   [(),(),(),(),(),(),(),()]
14:36:48 <benmachine> sssobhan: fromSql is surely a function
14:36:54 <sssobhan> yes i know
14:36:56 <c_wraith> ..  should @let allow defining instances?
14:37:06 <benmachine> sssobhan: so what's the type?
14:37:16 <arkeet> c_wraith: totally
14:37:20 <benmachine> c_wraith: what could possibly go wrong?
14:37:24 <sssobhan> benmachine: fromSql
14:37:26 <sssobhan>   :: Data.Convertible.Base.Convertible SqlValue a => SqlValue -> a
14:37:33 <benmachine> sssobhan: ah, ok
14:37:35 <FreeFull> arkeet: Actually, you can make abs = id and signum = const [()]
14:37:38 <tac> > 2 :: [()]
14:37:41 <lambdabot>   [(),()]
14:37:44 <arkeet> true.
14:37:46 <tac> > (-2) :: [()]
14:37:49 <lambdabot>   []
14:37:53 <luzie> :t (.)(.)
14:37:53 <tac> weird
14:37:54 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
14:37:55 <arkeet> FreeFull: or, signum = const 1
14:38:03 <FreeFull> Sure
14:38:11 <arkeet> @undefine
14:38:11 <lambdabot> Undefined.
14:38:16 <arkeet> @let instance Num [()] where fromInteger = (replicate `flip` ()) . fromInteger; (+) = (++); (-) = (\\); (*) = liftA2 (const.const $ ()); abs = id; signum = zipWith const 1
14:38:17 <lambdabot>  Defined.
14:38:19 <sssobhan> benmachine: so were is wrong ?
14:38:26 <benmachine> sssobhan: well the types just don't fit
14:38:28 <arkeet> > map signum [0,1,2] :: [[()]]
14:38:31 <lambdabot>   [[],[()],[()]]
14:38:40 <FreeFull> arkeet: zipwith? Why?
14:38:46 <arkeet> to make it do the right thing for 0
14:38:48 <FreeFull> :t signum
14:38:49 <lambdabot> Num a => a -> a
14:38:50 <sssobhan> benmachine: but r is a [[SqlValue]]
14:38:51 <FreeFull> Ah
14:39:03 <FreeFull> > signum 0 :: [()]
14:39:06 <lambdabot>   []
14:39:08 <sssobhan> benmachine: :t r
14:39:08 <FreeFull> > signum 1 :: [()]
14:39:11 <sssobhan> r :: [[SqlValue]]
14:39:11 <lambdabot>   [()]
14:39:21 <benmachine> sssobhan: f . g = \x -> f (g x), so mapM_ . mapM_ fromSql r = \x -> mapM_ (mapM_ fromSql r x)
14:39:31 <FreeFull> :t zipWith const 1
14:39:32 <lambdabot> Num [c] => [b] -> [c]
14:39:38 <FreeFull> :t zipWith const
14:39:38 <lambdabot> [c] -> [b] -> [c]
14:39:41 <benmachine> sssobhan: there are too many arguments to the inner mapM_ and too few to the outer one
14:39:43 <FreeFull> Oh, I see
14:40:04 <benmachine> sssobhan: also the arguments are the wrong types and mapM_ might not be what you want anyway, but one step at a time
14:40:14 <FreeFull> > signum 100 :: [()]
14:40:16 <sssobhan> benmachine: so it's impossible to transform r to a string ?
14:40:16 <lambdabot>   [()]
14:40:25 <FreeFull> arkeet: Is slow though
14:40:29 <FreeFull> > signum 1000000 :: [()]
14:40:33 <lambdabot>   mueval-core: Time limit exceeded
14:40:36 <EvilMachine> I just realized that unit tests are just a form of redundance. So shouldn’t there also be one layer of unit tests for the unit tests themselves?
14:40:40 <EvilMachine> I mean because triple redundancy apparently is the standard for everything mission critical.
14:40:40 <benmachine> sssobhan: no it's possible, you just have to use the right functions and in the right ways
14:40:58 <arkeet> > length (1000000 :: [()])
14:41:02 <lambdabot>   1000000
14:41:05 <FreeFull> arkeet: Rather than your weird signum
14:41:06 <hpc> EvilMachine: wrong meaning of "redundancy"
14:41:07 <arkeet> > signum (1000000 :: [()])
14:41:07 <FreeFull> You could just use   take 1
14:41:08 <benmachine> sssobhan: also, there's more than one way to transform r to a string: do you want all the values on separate lines, or all on the same line, etc.
14:41:10 <lambdabot>   [()]
14:41:11 <arkeet> FreeFull: good point.
14:41:14 <arkeet> but this works
14:41:30 <EvilMachine> hpc: English is not my native language. Sorry, can you elaborate?
14:41:35 <arkeet> :t zipWith const [()]
14:41:36 <lambdabot> [b] -> [()]
14:41:47 <arkeet> this is lazier
14:41:55 <arkeet> > signum ([undefined] :: [()])
14:41:57 <lambdabot>   [()]
14:41:59 <arkeet> > take 1 ([undefined] :: [()])
14:42:00 <lambdabot>   [*Exception: Prelude.undefined
14:42:06 <benmachine> EvilMachine: are you saying you should test your tests? what would you test for?
14:42:13 <FreeFull> > signum ([] :: [()])
14:42:16 <lambdabot>   []
14:42:22 <hpc> i mean, instead of extra-verifying that X does Y, they will have multiple systems that do Y that they can switch between
14:42:27 <hpc> and each one is tested individually
14:42:31 <sssobhan> []
14:42:34 <sssobhan> >[]
14:42:39 <benmachine> > (() <$) . take 1 $ [undefined] :: [()]
14:42:40 <lambdabot>   [()]
14:42:46 <Fuuzetsu> :t flip (:)
14:42:47 <lambdabot> [a] -> a -> [a]
14:42:50 <FreeFull> arkeet: You could combine zipwith const 1 with take 1 then =P
14:42:50 <EvilMachine> benmachine: Well, you test their correct behavior. Why would it be different from testing your normal code? :)
14:42:52 <arkeet> > signum (undefined:undefined :: [()])
14:42:53 <FreeFull> For max efficiency
14:42:55 <lambdabot>   [()]
14:43:00 <Fuuzetsu> flip (:) [1, 2] 3
14:43:04 <Fuuzetsu> > flip (:) [1, 2] 3
14:43:05 <lambdabot>   [3,1,2]
14:43:22 <hpc> to make a physical metaphor, when your space rocket is in deep shit, you want an extra gyroscope and not "yep, your gyroscope is gone; we checked twice"
14:43:23 <arkeet> FreeFull: map (const ()) . take 1  would also do it
14:43:24 <tac> > reverse 3 == 3
14:43:25 <lambdabot>   No instance for (GHC.Num.Num [a0]) arising from the literal `3'
14:43:26 <lambdabot>  The type v...
14:43:33 <benmachine> EvilMachine: what behaviour of a test is testable? how would you test that a test tests something?
14:43:35 <tac> > reverse (3 :: [()]) == 3
14:43:38 <lambdabot>   True
14:43:41 <Fuuzetsu> :t ($>)
14:43:42 <lambdabot>     Not in scope: `$>'
14:43:42 <lambdabot>     Perhaps you meant one of these:
14:43:42 <lambdabot>       `$' (imported from Data.Function),
14:43:45 <Fuuzetsu> :t (<$)
14:43:46 <lambdabot> Functor f => a -> f b -> f a
14:43:51 <hpc> benmachine: obviously by testing that the tests pass
14:44:07 <benmachine> EvilMachine: conceivably you could have a setup which deliberately fails the tests, in order to verify that they're not passing spuriously
14:44:09 <cdk> Fuuzetsu: ($> == Control.Applicative.(*>)
14:44:17 <benmachine> EvilMachine: that sounds like it could sometimes be a sensible thing to do
14:44:18 <Fuuzetsu> ah, right
14:44:24 <arkeet> not quite
14:44:37 <EvilMachine> hpc: Ah, I get it. So just implement everything thrice, and use their conflicting results as your tests? ;) Actually that’s nice. ;)
14:44:38 <arkeet> well, maybe
14:44:44 <benmachine> arkeet: how about guard . not . null
14:44:49 <arkeet> maybe
14:45:02 <arkeet> I like that
14:45:04 <arkeet> I suppose
14:45:19 <hpc> EvilMachine: well, you have to know that they work to begin with
14:45:21 <FreeFull> :t guard . not . null
14:45:21 <lambdabot> MonadPlus m => [a] -> m ()
14:45:23 <EvilMachine> benmachine: How would you test that a code does something? -> Every question you might have, can be transformed into a question about normal code. Because after all, units tests are just that: Code.
14:45:38 <benmachine> EvilMachine: absolutely, but they're very *simple* forms of code
14:45:54 <benmachine> EvilMachine: and they sort of naturally test themselves anyway
14:46:43 <benmachine> EvilMachine: the principal thing that might go wrong with a test is that you fail to specify behaviour correctly, but you can't test for that without specifying the behaviour correctly
14:46:55 <EvilMachine> benmachine: I have to disagree with that. It's always said, but tests really aren’t ever trivial.
14:48:10 <EvilMachine> hpc: Btw: No, you wouldn’t test tests, by testing that the test passes. You’d test that it does what you expect it to do. Which is pass if it should, and fail if it shouldn’t pass.
14:48:34 <benmachine> EvilMachine: but how do you determine if a test should pass?
14:48:53 <benmachine> EvilMachine: say I have a test that tests if a function returns 3. how do I know if that's the right thing for that test to test?
14:49:10 <EvilMachine> benmachine: With yet another, third implementation of your specification. (Where the normal tests are/use the second one.)
14:49:12 <arkeet> it's tests all the way down
14:49:50 <FreeFull> > let f ~(Just x) = x; f Nothing = 0; in f (Just 3)
14:49:50 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
14:49:54 <benmachine> EvilMachine: is it really likely that implementing your specification twice is going to make it more reliable? won't you just make the same mistakes both times?
14:50:10 <FreeFull> I just made lambdabot error in a new way!
14:50:14 <EvilMachine> arkeet: lol. Actually, I came up with this all exactly because of this: How would you ever know if the tests themselves also aren’t misbehaving? And so on until forever.
14:50:24 <benmachine> > let f ~(Just x) = x; f Nothing = 0 in f (Just 3)
14:50:25 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
14:50:29 <benmachine> hmm
14:50:29 <arkeet> curious
14:50:31 <roconnor> making two implementations, one efficent and one simple and comparing is quite effective.
14:50:35 <benmachine> > let f ~(Just x) = x in f (Just 3)
14:50:35 <lambdabot>   3
14:50:39 <arkeet> > let f (Just x) = x; f Nothing = 0 in f (Just 3)
14:50:40 <lambdabot>   3
14:50:51 <benmachine> maybe GHC is trying to comment on the overlapping patterns
14:50:54 <arkeet> > let { f ~(Just x) = x; f Nothing = 0 } in f (Just 3)
14:50:55 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
14:50:56 <roconnor> esp when using quickcheck
14:50:57 <arkeet> maybe
14:51:03 <benmachine> > let f x = 2; f y = 3 in f 0
14:51:04 <FreeFull> Lemme try it in pm
14:51:04 <lambdabot>   mueval-core: UnknownError "GHC returned a result but said: [GhcError {errMs...
14:51:26 <elliott> err, what's broken
14:51:27 <elliott> > 123
14:51:28 <lambdabot>   123
14:51:30 <arkeet> nothing
14:51:32 <elliott> ummm
14:51:33 <FreeFull> Yep, overlapping matches
14:51:41 <arkeet> it just complains because there's a warning
14:51:43 <elliott> arkeet: well it's meant to report errors better than that
14:51:51 <elliott> maybe it needs -w
14:51:54 <arkeet> ok
14:51:57 <arkeet> elliott is broken
14:52:01 <elliott> true
14:52:04 <EvilMachine> arkeet: And I realized (and got told by the awesome guys in here) that you can *never* fully know. Basic rule of science. You can only gain confidence by adding more levels/redundancy. (And everything above 3 *seems* to be just a waste, according to mission critical projects)
14:52:43 <Fuuzetsu> :t on
14:52:44 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
14:52:50 <FreeFull> :t off
14:52:51 <lambdabot>     Not in scope: `off'
14:52:51 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
14:53:01 <benmachine> EvilMachine: but of course
14:53:07 <EvilMachine> benmachine: The point of reimplementing your spec is, that you reimplement it as differently from the first one as possible. That’s how you avoid making the same error twice.
14:53:34 <inf-groupoid> EvilMachine: Is that amount of work really worth it?
14:53:39 <benmachine> EvilMachine: I can see that that might work, but it's quite an expensive way to do it
14:53:47 <benmachine> you could just re-read your one code more carefully :P
14:53:55 <benmachine> EvilMachine: also, it doesn't protect against you misunderstanding the spec
14:54:24 <benmachine> or misspecifying it, of course
14:54:43 <benmachine> you might have a program that perfectly competently does something that no-one wants done
14:55:06 <EvilMachine> inf-groupoid: Good point. I think, yes, it depends on if it is worth it. Do lives depend on it? 3+ implementations. One-shot script for your home server? No real need for tests. Like that.
14:55:21 <benmachine> EvilMachine: even if lives depend on it, it may not be the most efficient way to eliminate bugs
14:55:32 <benmachine> EvilMachine: you can write three crappy systems or one good one
14:55:43 * inf-groupoid thinks people should start using types as specifications.
14:55:48 <roconnor> inf-groupoid: Did you see that quickcheck talk earlier this year.  IIRC (which I probably don't) this company was losing thousands of dollars a week due to a rare DB corruption.  The solution was to reimplement it quickly and simply in Haskell and quickcheck it until a difference was found.
14:56:00 <roconnor> "quickly" in Haskell
14:56:05 <roconnor> I think it took a month or two
14:56:11 <inf-groupoid> roconnor: :-O
14:56:24 <roconnor> Then it took a few hours to find the two bugs.
14:56:25 <taylorgb_> There was always that crazy story about the reference implementation for nuclear reactor control systems not really being followed by any of the real ones
14:56:28 <ion> roconnor: Which talk? I’d like to see it.
14:56:34 <taylorgb_> But I'm not sure if that's myth or not
14:56:34 <EvilMachine> benmachine: Another great point. I thought of that earlier when answering you too. I guess one would have to create multiple specs too. So ideally: Pay 3 completely separate companies to come up with the thing. :D
14:56:36 <roconnor> let me try to find it.
14:56:45 <inf-groupoid> roconnor: I would like the link to the talk, too!
14:57:27 <EvilMachine> benmachine: Then the only point of failure is oneself, not knowing what’s actually needed. But I guess there the redundancy is called *natural selection*. ;)
14:57:50 <benmachine> EvilMachine: eh, I'm still not convinced that redundancy is the most efficient approach
14:58:05 <EvilMachine> benmachine: You can also write one crappy system or three good ones. I’m afraid that argument is invalid.
14:58:31 <benmachine> EvilMachine: it's possible for all three systems to fail; the question is, having written one system, are you more likely to eliminate problems by writing another, or improving the first?
14:58:44 <nexx> Is there a notation to integrate a concat into nested list comprehensions? Meaning changing this "concat [[b | b <- bs] | bs <- bss]" to get the same result without the concat function
14:59:34 <tromp> yes, nexx
14:59:44 <hpc> > [x | xs <- [[1,2],[3,4]], x <- xs]
14:59:45 <lambdabot>   [1,2,3,4]
14:59:56 <roconnor> @go "testing the hard stuff and staying sane"
14:59:56 <lambdabot> Maybe you meant: google googleit do
14:59:58 <nexx> oh thanks
15:00:03 <roconnor> @google "testing the hard stuff and staying sane"
15:00:04 <lambdabot> http://vimeo.com/68383317
15:00:05 <lambdabot> Title: John Hughes: Race Conditions, Distribution, Interactions--Testing the Hard St...
15:00:20 <EvilMachine> benmachine: Who said anything about efficiency? :) My goal was to get as close as possible to “guaranteeing” bug-freeness. Efficiency was irrelevant at that point.
15:00:20 <roconnor> ion: inf-groupoid: ^I think that is it
15:00:23 <benmachine> EvilMachine: cf. http://www.catb.org/jargon/html/A/airplane-rule.html "It is correspondingly argued that the right way to build reliable systems is to put all your eggs in one basket, after making sure that you've built a really good basket."
15:00:28 <inf-groupoid> roconnor: Let me see!
15:01:03 <EvilMachine> benmachine: But yeah, if there is a quicker way that has ZERO compromises compared to the complete redundancy solution, I’d like very much to hear it.
15:01:06 <ion> roconnor: Thanks!
15:01:13 <benmachine> EvilMachine: well, the question is whether or not implementing something redundantly is a good idea
15:01:29 <benmachine> EvilMachine: if the resources necessary to doing so could be better spent elsewhere, then the answer is no
15:01:37 <benmachine> EvilMachine: hence efficiency becomes important
15:02:25 <EvilMachine> benmachine: Yes, by the way: You are in fact more likely to eleminate problems by writing multiple implementations. The more of them you write, the more sure you can be. We established that quite clearly in that last discussion some months ago. Based on this being the basis of all scientific research too.
15:02:37 <inf-groupoid> EvilMachine: If the redundancy approach does not offer reasonable guarantees of correctness and/or uses way more resources than the project can afford, then from an engineering point of view you should be looking for other solutions.
15:03:02 <benmachine> EvilMachine: more likely than what?
15:03:15 <benmachine> EvilMachine: I don't question that redundancy can eliminate problems; I just think there are better ways of doing so
15:03:22 <EvilMachine> benmachine: All your eggs in one basket? Then why are there 3 flight computers and 3 sensors for everything on planes and spaceships?
15:03:43 <inf-groupoid> EvilMachine: Because physical devices are susceptible to *physical* failure.
15:03:47 <benmachine> right
15:03:55 <roconnor> The type of redundency I'm talking about isn't redudency.  The "executable spec" is too inefficent to run in practice.
15:03:56 <inf-groupoid> EvilMachine: Computing systems only have one source of errors: human mistakes.
15:04:09 <companion_cube> and cosmic rays
15:04:10 <roconnor> but it can be used to check production against spec.
15:04:11 <monochrom> that's 6 eggs in the same spaceship basket
15:04:12 <inf-groupoid> EvilMachine: And redundancy cannot fix humans being dumb.
15:04:15 <hpc> 3 misprogrammed flight computers are not more useful than 1
15:04:16 <inf-groupoid> companion_cube: lol
15:04:21 <fetter_oml> good evening. on my quest on understanding the compilation process of haskell i've stumbled upon "ghc --show-iface". while I understand the very core concept of those files, I would like to get a better understanding how to interpret that output. can someone point me to a (possible short) tutorial/blogpost/etc about it?
15:04:45 <inf-groupoid> roconnor: Yeah, but that is not the kind of thing EvilMachine is advocating.
15:04:52 <EvilMachine> benmachine: Not disagreeing about the efficiency argument btw. I just want to hear a concrete more efficient yet at least as good solution.
15:05:10 <EvilMachine> benmachine: More likely than having n-1 implementations.
15:05:33 <EvilMachine> benmachine: * n-1 levels of redundancy.
15:05:45 <inf-groupoid> EvilMachine: Types as specifications. Give me a specification in a language that has a semantics that a machine can tell if I am misinterpreting.
15:06:28 <companion_cube> there are alternatives, like logic annotations on functions (see ada-spark for instance)
15:07:06 <benmachine> EvilMachine: well, that's a question that needs to be studied; my expectation would be that merely having a really solid code review process would be better, but I'd hesitate to say until someone went out and actually did it
15:07:37 <EvilMachine> inf-groupoid: No, you can’t just say that software is "non-physical". Both a device and software are very specific patterns (=information) in matter/energy. From a certain standpoint, the only difference that software’s lifespan in that matter configuration is shorter.
15:07:48 <monochrom> dependent types are not the only specification form and definitely far from being the mainstream form
15:08:06 <tac> depedent types are a very "heavyweight" form of verification
15:08:09 <benmachine> EvilMachine: no, that's silly: no matter how well we build a machine we can't stop it being damaged by a physical accident
15:08:29 <EvilMachine> inf-groupoid: Actually, yes, redundancy can fix humans being dumb. If they check on each other, they can see each others’ errors. (With the usual limits, of course.)
15:08:32 <leo_31> i missed a job interview by phone yesterday. i called today and they sort of agreed that there were some technical problems and thats why we couldnt make it. i asked them to rearrange it. today i didnt get an email. where they lying?
15:08:36 <inf-groupoid> EvilMachine: Physical devices have to del with these things called "tolerances".
15:08:41 <inf-groupoid> deal*
15:09:04 --- mode: ChanServ set +o elliott
15:09:16 <inf-groupoid> If analysts can afford to be lazy or careless when writing specifications, why can't programmers afford to be lazy or careless when implementing them? If the user wants a reasonable guarantee of correctness, they must give me a specification that offers reasonable guarantees that there will be no misinterpretation.
15:09:26 --- mode: elliott set +b *!*jswksl@*.12.22.174.dsl.dyn.forthnet.gr
15:09:26 --- kick: leo_31 was kicked by elliott (leo_31)
15:09:38 --- mode: elliott set +b leo_31*!*@*
15:09:44 --- mode: elliott set +b *!*jswksl@*
15:09:53 --- mode: elliott set -b *!*jswksl@*.12.22.174.dsl.dyn.forthnet.gr
15:09:54 <benmachine> elliott: is there some history there I'm not aware of?
15:09:59 <johnw> that was just... odd
15:10:01 <elliott> benmachine: yes, they keep doing this
15:10:05 <benmachine> oh ok
15:10:06 <tac> inf-groupoid: I think most business grade software is more concerned with "ever getting finished" rather than "getting finished correctly"
15:10:20 <elliott> (this is at least their second nick iirc and of course they've been told it's off-topic repeatedly but they just keep asking)
15:10:24 --- mode: elliott set -o elliott
15:10:26 <EvilMachine> inf-groupoid: No machine can tell if you’re misinterpreting something it itself cannon interpret. And since the machine is just a frozen state of a part another human being’s mind… :)
15:10:32 <Rembane> inf-groupoid: Isn't your job to translate an incorrect specification to a more correct program?
15:10:47 <inf-groupoid> tac: Not the programmer's fault that the ones in charge of understanding the business in question don't actually understand it.
15:10:52 <monochrom> thanks elliott
15:11:18 <cdk> @hoogle (Functor f, Monad m) => (m a -> f (m a) -> f (m a)) -> f (m a) -> f (m a)
15:11:18 <lambdabot> No results found
15:11:46 <inf-groupoid> tac: That's the premise under which I'm supposed to accept that they get a higher pay - "they understand the big picture".
15:11:56 <EvilMachine> benmachine: Yes, yes, solid code review (mostly by being redundant about that too, apart from of course doing it properly) can, IMHO, in a way also be considered a form of (more efficient because not actually implemented but just in the reviewers mind) redundancy. :)
15:11:59 <finity> elliott: That's strange, I wonder what it's trying to achieve
15:12:15 <EvilMachine> benmachine: no, that’s silly
15:12:17 <benmachine> EvilMachine: I think that's only something you'd say if you wanted the answer to be redundancy :P
15:12:37 <Pantsu> sounds like they are not interested
15:12:39 <EvilMachine> benmachine: no, that’s silly: no matter how well we build a program, we can’t stop it from being damaged by a physical accident.
15:12:41 <EvilMachine> :)
15:12:54 <inf-groupoid> EvilMachine: Redundancy is a tool for coping with unexpected and unavoidable failures.
15:13:02 <benmachine> EvilMachine: we stand a *much* better chance of protecting information than physical systems
15:13:33 <companion_cube> redundancy is quite used in planes, where physical failures can happen
15:14:09 <tac> fault tolerance is another way of saying unncessary expense
15:14:10 <ParahSai1in> had to google what country code gh was
15:14:20 <EvilMachine> inf-groupoid: You are saying the difference is that software doesn’t have to deal with tolerances because it is digital. And up to a certain level I fully agree. But in practice, hardware tolerances cannot really be ignored by the software running on it. (Just look at race conditions.)
15:14:23 <inf-groupoid> ParahSai1in: And what was it?
15:14:25 <monochrom> what is the purpose of this discussion?
15:14:31 <tac> If you can do the job of one man with a team, why not fire the team and leave it to the one man? :)
15:14:45 <ParahSai1in> ghana
15:14:49 <inf-groupoid> :-O
15:15:17 <EvilMachine> inf-groupoid: Indeed, specs should be made just as careful as the implementations. I don’t think anyone ever disagreed with that one. Let alone in here. :)
15:15:34 <companion_cube> tac: so, if the onboard computer in a plane fails, the plane has to crash \o/
15:15:54 * monochrom asks again
15:15:55 <monochrom> what is the purpose of this discussion?
15:16:00 <inf-groupoid> EvilMachine: No, no. If the one writing a specification is not writing it in a formal system, he is by definition not having to be as careful as a programmer, who is implementing it in a formal system - a programming language.
15:16:23 <tac> monochrom is right. This is probably a #haskell-blah conversation.
15:16:25 <inf-groupoid> as the* programmer
15:16:31 <tac> Let's take it there plz :)
15:16:35 <inf-groupoid> Okay!
15:16:45 <EvilMachine> tac: The idea of the spiral model is, that you have a fixed amount of (time and) resources, and make it as good as you can with those. So yeah. But that would only mean: Do as many implementations as you can in that amount of time. :))
15:18:07 <EvilMachine> benmachine: lol @ “wanted the answer to be redundancy” … evilmachine :: Maybe WantItToBeRedundancy
15:19:15 <EvilMachine> tac: "fault tolerance is another way of saying unncessary expense" -> Please tell me what software you made, so I can avoid it. ;)
15:19:35 <tac> EvilMachine: I'll tell you in #haskell-blah
15:19:38 <merijn> I'm not sure whether I should be happy or sad that my problem is a library bug rather than a bug in my code :\
15:19:52 <benmachine> merijn: depends how good the library maintainers are
15:20:12 <benmachine> merijn: I always like discovering bugs that then get fixed, because then even if my project goes down the pan I've achieved *something* :P
15:20:17 <merijn> benmachine: Well, it's Apfelmus, so that's good, but I think he's a bit busy at the moment, so that's bad :\
15:20:42 <merijn> And I'm completely out of my depth trying to debug the library myself
15:20:44 <EvilMachine> monochrom: The purpose is to find the ideal way to be the most sure of a piece of code (in terms of reliability). (Definitely a Haskell topic. :)
15:21:21 <EvilMachine> monochrom: With the realization that just unit tests actually don’t really mean you can trust your code that much more than without them.
15:22:12 <monochrom> I disagree on the relevance to this channel.
15:22:54 <EvilMachine> inf-groupoid: Yes, you are right. That’s the crux with ”normal” specs: They are by definition too vague. Which is why I don’t even touch UML with a pitchfork. :)
15:24:10 <EvilMachine> monochrom: Yes, this might be a #haskell-blah discussion. Wasn’t intended as one though. Mostly because code reliablility and code quality are things Haskell is usually mentioned for.
15:24:39 * EvilMachine Walks over to #haskell-blah
15:26:10 <merijn> @remember @popltarts Programmers HATE him: try this one weird trick discovered by Oleg for checking your types!
15:26:11 <lambdabot> I will remember.
15:28:41 <orzo> http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map-Lazy.html#v:updateLookupWithKey <-- this api call is a little frustrating.  I need to know whether or not the item was deleted, and there doesnt seem to be a way other than doing another lookup
15:29:50 <orzo> i have a map of reference counts paired with objects, so when i unreference an object, its supposed to decrement the count and remove it from the map if appropriate
15:30:38 <orzo> is there a better way to accomplisht that?
15:31:19 --- mode: ChanServ set +o elliott
15:31:29 --- mode: elliott set +b *!*ssjsj@*
15:31:31 <elliott> that one got lost
15:31:35 --- mode: elliott set -o elliott
15:39:46 <monochrom> orzo: iff you count down to 0, you delete? then updateLookupWithKey gives you (Just 1, new_map) at deletion
15:40:41 <monochrom> oh yikes, no, both deletion and decrease-to-1 gives you (Just 1, new_map)
15:40:59 <orzo> yeah
15:41:06 <orzo> its causing me to cuss in my code
15:41:26 <benmachine> ouch
15:41:43 <benmachine> what an odd thing to do
15:42:19 <EvilMachine> I had the same and other similar problems with that API. It’s not very good, yet still fairly reduntant, IMHO. Reminds me a bit of the time when I had to write PHP…
15:42:24 * EvilMachine cries a little.
15:42:54 <EvilMachine> s/retuntant/redundand/
15:43:34 <benmachine> s/s\/retuntant\/redundand\//s\/retuntant\/redundant\//
15:44:49 <pantsman-> redundand sounds like it could be the name of an archaic typographical form related to the ampersand
15:45:42 <bscarlet> alter doesn't work for you?
15:45:49 <orzo> how would i do it with alter
15:45:57 <orzo> remove from map when refernece count hits zero
15:46:03 <orzo> while detecting the hitting zero case
15:46:36 <orzo> eitehr way i have to do another lookup
15:46:51 <orzo> which seems like the whole reason updateLookupWithKey was made, to avoid doing another lookup
15:46:55 <orzo> but its apparnetly useless for that
15:47:32 <bscarlet> I see now.
15:48:31 <benmachine> it's tricky
15:55:01 * hackagebot air 2013.7.18 - air  http://hackage.haskell.org/package/air-2013.7.18 (JinjingWang)
15:55:03 * hackagebot hack2-contrib 2013.7.18 - Hack2 contrib  http://hackage.haskell.org/package/hack2-contrib-2013.7.18 (JinjingWang)
15:57:51 <EvilMachine> benmachine: I miss your “more efficient than redundancy” argument over in #haskell-blah. :/ I’m still curious about options other than redundancy. Code review was ok, but only an example… I didn’t get your concept/approach/mindset to the problem yet…
15:58:30 <benmachine> EvilMachine: I didn't join you in -blah because I got bored, I'm afraid :P
16:01:32 <SuperNoeMan> cabal what are you talking about?
16:01:35 <SuperNoeMan> I'm lost...
16:13:40 <bb010g> Anybody here familiar with Monatron? Can't seem to find much info on it. (Going through the Typeclassopedia)
16:14:17 <bb010g> (Besides the paper, which is confusing.)
16:14:52 <bb010g> Should I use it?
16:15:34 <bb010g> Anybody here familiar with Monatron? Can't seem to find much info on it. (Going through the Typeclassopedia)
16:15:39 <bb010g> (Besides the paper, which is confusing.)
16:16:22 <tomboy64> i have a list of Maybes - how do i filter out all nothings und just return a list of values without the Justs?
16:16:43 <bgamari> tomboy64, concatMaybes I believe
16:16:54 <benmachine> catMaybes
16:16:58 <benmachine> Data.Maybe
16:17:01 <benmachine> :t catMaybes
16:17:02 <lambdabot> [Maybe a] -> [a]
16:17:02 <bgamari> or that
16:17:20 <bb010g> @src catMaybes
16:17:20 <lambdabot> catMaybes ls = [x | Just x <- ls]
16:18:57 <tomboy64> hehe
16:18:58 <tomboy64> yup
16:19:06 <tomboy64> just for that catMaybes
16:19:08 <tomboy64> thanks :)
16:25:44 <bb010g> Anybody used Monatron?
16:29:01 <bb010g> Anybody?
16:37:20 <lpaste> jpf pasted “libgmp.so.3 and ghc-7.6.3 build” at http://lpaste.net/91006
16:37:44 <jpf> am I doing the configure step correctly?
16:42:00 <jhance> jpf: why not use system gmp?
16:46:08 <Saizan> maybe it's a 32bit vs. 64bit issue?
16:48:46 <jpf> jhance: on fedora 17, libgmp.so is all that's given (and this is provided by openssl), and i'd rather not try a symlink
16:49:50 <monochrom> ok, then maybe LD_LIBRARY_PATH is more reliable than --with-gmp-libraries
16:49:55 <Saizan> i think symlinking libgmp.so.3 to that system libgmp.so is quite likely t
16:49:59 <Saizan> to work
16:50:09 <monochrom> that too
16:51:01 <monochrom> also, consider my http://www.vex.net/~trebla/haskell/I-built-GHC.xhtml :)
16:51:43 <bb010g> monochrom: Link fails.
16:52:07 <monochrom> which link? the exact one I just gave?
16:52:52 <bb010g> Not Found
16:52:53 <bb010g> The requested URL /~trebla/haskell/I-built-GHC.xhtm was not found on this server.
16:53:09 <benmachine> there's an l on the end
16:53:43 <bb010g> derp
16:54:40 <monochrom> you see why you should always be more specific
17:01:40 <jhance> jpf: Ok, I just searched my /usr/lib (I've compiled ghc on this computer) and I don't have a libgmp.so.3
17:02:13 <jhance> jpf: libgmp.so.10 and libgmp.so.10.0.2 should be enough
17:02:23 <jpf> jhance: k
17:03:17 <jhance> jpf: Unfortunately I use gentoo so I don't actually know *how* I compiled it
17:04:22 <jpf> brb
17:07:03 <benzrf> Hey.
17:07:12 <benzrf> I recently saw some kind of package that let you write BASIC in a do-block.
17:07:26 <benzrf> The thing that bugged me was... how the hell do you get line numbers to work?
17:07:53 <benzrf> If you have a line containing '10 PRINT' or something, won't that be interpreted as applying the function 10 to the argument PRINT?
17:08:04 <benzrf> And 10 most certainly isn't a function...
17:08:16 <tij> what is the best way to find all the strings between delimiters? for example: if the delimiter is "~!" then:    func "~!" "asda~!great~!dsad~!fun~!hjhk" should return ["great", "fun"]
17:08:31 <c_wraith> benzrf: numeric literals are polymorphic.  You can make them functions, if you want
17:08:46 <benzrf> tij: why isn't dsad in there?
17:08:52 <benzrf> tij: oh, the delimeters are 'consumed'
17:08:59 <benzrf> c_wraith: how could you do that?!
17:09:24 <tij> benzrf: yeah, though it wouldnt matter either way (just take the odds from list if delimiters arent consumed)
17:09:38 <tij> benzrf: evens actually
17:09:58 <c_wraith> benzrf: instance Num (Foo -> Bar) where ... (and enabling the right compiler flags to allow instances that specific)
17:10:35 <benzrf> c_wraith: ohhhhh, right!
17:11:12 <applicative> benzrf: it has an insane Num instance
17:11:18 <applicative> oh as c_wraith says
17:11:26 <elliott> tij: perhaps try the split package
17:11:29 <elliott> @hackage split
17:11:29 <lambdabot> http://hackage.haskell.org/package/split
17:11:29 <benzrf> c_wraith: wait.
17:11:42 <benzrf> c_wraith: wait never mind again
17:11:48 <applicative> I think you can't build it at the moment benzrf as it used the 'ImpredicativeTypes' extension
17:11:49 <benzrf> blugh my brain hurts
17:12:13 <applicative> benzrf: there used to be a mildly wacky num instance in lambdabot
17:12:14 <applicative> > 1 1
17:12:15 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
17:12:15 <lambdabot>    arising f...
17:12:17 <c_wraith> Couldn't it be switched to do something like the printf trick?
17:12:34 <applicative> the basic dsl?
17:12:35 <c_wraith> instead of ImpredicativeTypes
17:12:41 <benzrf> OK, so '10' can be evaluated as being something of type (a -> b)
17:12:43 <c_wraith> Or maybe it does already
17:12:50 <applicative> probably, its just the whole thing is so darn complicated...
17:13:07 <applicative> benzrf: yes; it isn't recommended
17:13:08 <benzrf> How, exactly, are numeric literals converted into values?
17:13:21 <tij> elliott: can't believe i forgot about that (asked about it a few days ago...). thanks!
17:13:49 <c_wraith> benzrf: with an implicit fromInteger call
17:13:53 <benzrf> OH OK
17:13:56 <c_wraith> benzrf: and fromInteger is part of the Num class
17:13:58 <elliott> tij: :)
17:14:00 <applicative> instance Num (a -> Int) where fromInteger n = const n
17:14:03 <benzrf> right, ok!
17:14:15 <benzrf> k that's fairly clever
17:15:16 <benzrf> ok, thank you!
17:38:30 <NiceOneBrah> does anyone know how to correctly break up a list definition over multiple lines? GHC doesn't seem to like this: http://lpaste.net/91007
17:38:46 <lpaste> CADD pasted “lambdu” at http://lpaste.net/91008
17:39:34 <geekosaur> NiceOneBrah, leave off the backslash; indentation is sufficient
17:41:26 <NiceOneBrah> geekosaur: ah thanks! It looks like that plus a missing comma was the source of my error
17:52:40 <bb010g> I keep on getting a type error on this (for fun) FizzBuzz line that I can't figure out.
17:52:41 <lpaste> bb010g pasted “One-line FizzBuzz” at http://lpaste.net/91009
17:54:22 <b2coutts> bb010g: I for one am not looking at that code until it has been properly formatted :P
17:55:03 <b2coutts> also, maybe formatting the code will make the type error more clear
17:55:17 <bb010g> Fixing
17:56:48 <lingxiao> Hey all: is anyone familiar with Data.Attoparsec.Incremental
17:56:50 <lingxiao> ?
17:57:31 <elliott> that module isn't in the latest attoparsec release
17:57:34 <elliott> are you using an old version?
17:57:54 <lingxiao> I'm using -0.7.2
17:57:59 <elliott> looks like the last release that had it was from january 2009
17:58:09 <elliott> I think you might want to consider upgrading :P
17:58:10 <lingxiao> But mostly for learning how it was impleemented
18:00:28 <lingxiao> elliot: oh thanks for the tip :). My primary goal is to implement an incremental parser, so far the only implementation I found is Attoparsec,
18:00:47 <lingxiao> and this guy here: http://hackage.haskell.org/packages/archive/incremental-parser/0.2.3/doc/html/Text-ParserCombinators-Incremental.html
18:05:04 * hackagebot hsp 0.9.1 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.9.1 (JeremyShaw)
18:06:10 <lpaste> bb010g revised “One-line FizzBuzz”: “One-line FizzBuzz” at http://lpaste.net/91009
18:06:18 <bb010g> With formatting!
18:09:14 <roconnor> Ugh, Coproduct.  Why not :+: ?
18:09:21 <bb010g> Nevermind, I had n and namess swapped.
18:09:48 <lpaste> bb010g revised “One-line FizzBuzz”: “One-line FizzBuzz” at http://lpaste.net/91009
18:10:42 <elliott> roconnor: these days, why not +?
18:11:06 <dmwit> bb010g: You might like
18:11:09 <dmwit> ?hackage data-ordlist
18:11:10 <lambdabot> http://hackage.haskell.org/package/data-ordlist
18:11:14 <roconnor> elliott: because type constructor have to begin with :  ?
18:11:23 <elliott> roconnor: not any more they don't
18:11:32 <joelteon> http://hackage.haskell.org/packages/archive/acme-inator/0.1.0.0/doc/html/Acme-Inator.html i think i'm in love
18:11:38 <roconnor> elliott: then + should be for either
18:11:48 <roconnor> can I newtype this?
18:11:50 <roconnor> er
18:11:51 <roconnor> type this
18:11:58 <elliott> I think type (+) = Either should work
18:13:57 <roconnor> neat
18:14:06 <roconnor> I wonder if I should do that
18:14:14 <bb010g> dmwit: I know, but this works in the Prelude in one line. I copied the ordlist implementation.
18:16:57 <dmwit> > let m `divides` n = n `mod` m == 0; foo n = case (3 `divides` n, 5 `divides` n) of (True, True) -> "fizzbuzz"; (True, False) -> "fizz"; (False, True) -> "buzz"; (False, False) -> show n in map foo [1..]
18:16:59 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
18:18:18 <Peaker> dmwit, you're hired!
18:18:47 <dmwit> \o/
18:19:20 <elliott> > let m `divides` n = n `mod` m == 0; foo n = [show n, "buzz", "fizz", "fizzbuzz"] !! fromEnum (3 `divides` n, 5 `divides n) in map foo [1..]
18:19:22 <lambdabot>   <hint>:1:121: parse error on input `n'
18:19:28 <elliott> > let m `divides` n = n `mod` m == 0; foo n = [show n, "buzz", "fizz", "fizzbuzz"] !! fromEnum (3 `divides` n, 5 `divides` n) in map foo [1..]
18:19:29 <lambdabot>   Could not deduce (GHC.Enum.Enum (GHC.Types.Bool, GHC.Types.Bool))
18:19:29 <lambdabot>    arisin...
18:19:32 <elliott> hmm
18:20:21 <dmwit> 2 * fromEnum (3 `divides` n) + fromEnum (5 `divides` n)
18:20:44 <elliott> > let m `divides` n = n `mod` m == 0; foo n = [show n, "buzz", "fizz", "fizzbuzz"] !! index ((False,False),(True,True)) (3 `divides` n, 5 `divides` n) in map foo [1..]
18:20:45 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
18:20:57 <elliott> > let m `divides` n = n `mod` m == 0; foo n = [show n, "buzz", "fizz", "fizzbuzz"] !! index (minBound,maxBound) (3 `divides` n, 5 `divides` n) in map foo [1..]
18:20:58 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fizz","13","1...
18:21:14 <elliott> heehee
18:21:33 <Ghoul_> could this be done with list comprehensions?
18:21:41 <dmwit> sure, why not?
18:24:06 <monochrom> haskell weekly news \∩/
18:24:19 <nooodl> > zipWith ($) (cycle [show, show, const "fizz", show, const "buzz", const "fizz", show, show, const "fizz", const "buzz", show, const "fizz", show, show, const "fizzbuzz"]) [1..10]
18:24:20 <lambdabot>   ["1","2","fizz","4","buzz","fizz","7","8","fizz","buzz"]
18:24:27 <nooodl> dumb fizzbuzz implementations are at
18:24:29 <nooodl> *art
18:24:36 <bb010g> > let bbFizzBuzz = \words -> let minus xs ys = if tail xs == [] then xs else let case' = compare (head xs) (head ys) in if case' == LT then (head xs):minus (tail xs) ys else if case' == EQ then minus (tail xs) (tail ys) else minus xs (tail ys) in fmap ((\namess n -> let pairs = zip (F.fix (\f (p:xs) -> p : f (xs `minus` [p*p, p*p+2*p..])) $ [3,5..]) namess in let string = concatMap (\x -> if (n `mod` (fst x)) == 0 then snd x else "") pairs in if string =
18:24:38 <lambdabot>   <hint>:1:456: parse error on input `='
18:25:01 <byorgey> bb010g: hehe, nice try, looks like it's longer than the IRC limit =)
18:25:04 * hackagebot HJScript 0.7.0 - HJScript is a Haskell EDSL for writing JavaScript programs.  http://hackage.haskell.org/package/HJScript-0.7.0 (JeremyShaw)
18:25:34 <bb010g> > let bbFizzBuzz words = let minus xs ys = if tail xs == [] then xs else let case' = compare (head xs) (head ys) in if case' == LT then (head xs):minus (tail xs) ys else if case' == EQ then minus (tail xs) (tail ys) else minus xs (tail ys) in fmap ((\namess n -> let pairs = zip (F.fix (\f (p:xs) -> p : f (xs `minus` [p*p, p*p+2*p..])) $ [3,5..]) namess in let string = concatMap (\x -> if (n `mod` (fst x)) == 0 then snd x else "") pairs in if string == ""
18:25:36 <lambdabot>   <hint>:1:457:
18:25:36 <lambdabot>      parse error (possibly incorrect indentation or mismatche...
18:25:43 <elliott> nooodl: come on, you can generate that list
18:25:45 <elliott> don't be lazy
18:26:29 <nooodl> mmm that'd defeat the point imo! because in generating that list you'd actually solve fizzbuzz normally
18:30:52 <bb010g> Is the IRC limit 460 characters?
18:33:02 <lpaste> NemesisD annotated “state machine mess” with “state machine mess (annotation)” at http://lpaste.net/91001#a91012
18:33:18 <NemesisD> could someone take a look at that and help me figure out what's going wrong?
18:34:32 <NemesisD> i feel like there's some lifting i need that i'm not doing
18:35:04 * hackagebot sifflet-lib 2.1.0 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-2.1.0 (GregoryWeber)
18:35:06 * hackagebot sifflet 2.1.0 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-2.1.0 (GregoryWeber)
18:35:08 <bb010g> > let bbFizzBuzz words = let minus xs ys = if tail xs == [] then xs else case (compare (head xs) (head ys)) in of LT -> (head xs):minus (tail xs) ys; EQ -> minus (tail xs) (tail ys); GT -> minus xs (tail ys) in fmap ((\q n -> let pairs = zip (F.fix (\f (p:xs) -> p : f (xs `minus` [p*p, p*p+2*p..])) $ [3,5..]) q in let string = concatMap (\x -> if (n `mod` (fst x)) == 0 then snd x else "") pairs in if string == "" then show n else string) words) [1..]
18:35:09 <monochrom> or runReaderT
18:35:09 <lambdabot>   <hint>:1:107: parse error on input `in'
18:35:37 <NemesisD> monochrom: do you mean i should not be doing that?
18:35:55 <bb010g> > let bbFizzBuzz words = let minus xs ys = if tail xs == [] then xs else case (compare (head xs) (head ys)) of LT -> (head xs):minus (tail xs) ys; EQ -> minus (tail xs) (tail ys); GT -> minus xs (tail ys) in fmap ((\q n -> let pairs = zip (F.fix (\f (p:xs) -> p : f (xs `minus` [p*p, p*p+2*p..])) $ [3,5..]) q in let string = concatMap (\x -> if (n `mod` (fst x)) == 0 then snd x else "") pairs in if string == "" then show n else string) words) [1..]
18:35:56 <lambdabot>   not an expression: `let bbFizzBuzz words = let minus xs ys = if tail xs == ...
18:37:41 <bb010g> > let foo = "foo"
18:37:42 <lambdabot>   not an expression: `let foo = "foo"'
18:37:53 <bb010g> let bbFizzBuzz words = let minus xs ys = if tail xs == [] then xs else case (compare (head xs) (head ys)) of LT -> (head xs):minus (tail xs) ys; EQ -> minus (tail xs) (tail ys); GT -> minus xs (tail ys) in fmap ((\q n -> let pairs = zip (F.fix (\f (p:xs) -> p : f (xs `minus` [p*p, p*p+2*p..])) $ [3,5..]) q in let string = concatMap (\x -> if (n `mod` (fst x)) == 0 then snd x else "") pairs in if string == "" then show n else string) words) [1..]
18:38:10 <bb010g> How do you get lambdabot to assign things?
18:38:17 <bb010g> @help let
18:38:18 <lambdabot> let <x> = <e>. Add a binding
18:38:21 <bb010g> Oh.
18:38:24 <bb010g> @let bbFizzBuzz words = let minus xs ys = if tail xs == [] then xs else case (compare (head xs) (head ys)) of LT -> (head xs):minus (tail xs) ys; EQ -> minus (tail xs) (tail ys); GT -> minus xs (tail ys) in fmap ((\q n -> let pairs = zip (F.fix (\f (p:xs) -> p : f (xs `minus` [p*p, p*p+2*p..])) $ [3,5..]) q in let string = concatMap (\x -> if (n `mod` (fst x)) == 0 then snd x else "") pairs in if string == "" then show n else string) words) [1..]
18:38:25 <lambdabot>  .L.hs:142:24: Not in scope: `F.fix'
18:39:23 <monochrom> ok, I see runReaderT is already done by runStateMachine
18:39:34 <NemesisD> monochrom: the whole stack is getting pretty convoluted but mainly the user-supplied "action" runs in a different monad, but it must support MonadReader and I need to be able to inject that initial reader value
18:39:40 <bb010g> @let bbFizzBuzz words = let minus xs ys = if tail xs == [] then xs else case (compare (head xs) (head ys)) of LT -> (head xs):minus (tail xs) ys; EQ -> minus (tail xs) (tail ys); GT -> minus xs (tail ys) in fmap ((\q n -> let pairs = zip (fix (\f (p:xs) -> p : f (xs `minus` [p*p, p*p+2*p..])) $ [3,5..]) q in let string = concatMap (\x -> if (n `mod` (fst x)) == 0 then snd x else "") pairs in if string == "" then show n else string) words) [1..]
18:39:41 <lambdabot>  Defined.
18:40:24 <bb010g> > take 100 $ bbFizzBuzz ["Fizz","Buzz","Bazz","Bizz","Bazooka","Boomerang"]
18:40:28 <lambdabot>   mueval-core: Time limit exceeded
18:40:43 <bb010g> > take 100 $ bbFizzBuzz ["Fizz","Buzz","Bazz","Bizz"]
18:40:47 <lambdabot>   mueval-core: Time limit exceeded
18:40:54 <bb010g> > take 50 $ bbFizzBuzz ["Fizz","Buzz","Bazz","Bizz"]
18:40:58 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","Bazz","8","Fizz","Buzz","Bizz","Fizz","1...
18:41:03 <bb010g> \o/
18:41:16 <monochrom> well, you have "runStateMachine myStateMachine $ do ...". inside the "...", you are clearly not in just IO, you need liftIO for your putStrLn's
18:41:35 <bb010g> Wait... What happened to the other stuff...
18:43:27 <bb010g> @let bbFizzBuzz words = let minus xs ys = if tail xs == [] then xs else case (compare (head xs) (head ys)) of LT -> (head xs):minus (tail xs) ys; EQ -> minus (tail xs) (tail ys); GT -> minus xs (tail ys) in fmap ((\q n -> let pairs = zip (fix (\f (p:xs) -> p : f (xs `minus` [p*p, p*p+2*p..])) $ [3,5..]) q in let string = concatMap (\x -> if (n `mod` (fst x)) == 0 then snd x else "") pairs in if string == "" then show n else string) words) [1..]
18:43:28 <lambdabot>  .L.hs:130:1: Warning:
18:43:28 <lambdabot>      Pattern match(es) are overlapped
18:43:28 <lambdabot>      In an equat...
18:43:51 <monochrom> bb010g: you will have much better luck conversing with lambdabot in private messages
18:43:54 <bb010g> Ok.
18:44:22 <monochrom> and beyond better luck if you use a real ghc
18:44:51 <bb010g> What's weird is that it's under the limit and it works in my ghci...
18:45:07 <Tekmo> xplat: Are you there?
18:46:22 <NemesisD> monochrom: does it necessarily need to use lifIO? the statemachine instance I define specifies its using IO as the monad its using, i was trying to imbed MonadReader in the IO monad rather than the other way around
18:47:05 <NemesisD> apologies in advance if i'm butchering the terminology. i'm a bit beyond my abilities right now
18:47:17 <bb010g> > take 15 $ bbFizzBuzz ["Fizz","Buzz"]
18:47:20 <lambdabot>   ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","1...
18:47:22 <monochrom> you are asking me: is it "runWriterT (runReaderT (putStrLn "hello")))" or "runWriterT (runReaderT (liftIO (putStrLn "hello")))"? I think the answer is obvious.
18:47:30 <bb010g> \o/
18:48:31 <NemesisD> monochrom: yeah good point. when shrunken down to that it seems pretty obvious
18:51:35 <NemesisD> now i'm down to couldn't match type t1 m1 with IO, expected type IO String actual type t1 m1 String in the calls to transition
18:53:45 <Peaker> NemesisD, sounds like a "lift" misplaced
18:55:57 <lpaste> NemesisD annotated “state machine mess” with “state machine mess (annotation)” at http://lpaste.net/91001#a91013
18:58:55 <NemesisD> ah i see what you mean, maybe a lift too far
19:00:05 * hackagebot papillon 0.0.45 - packrat parser  http://hackage.haskell.org/package/papillon-0.0.45 (YoshikuniJujo)
19:01:50 <roconnor> is there a preadditive category class?
19:05:28 <zRecursive> :t lift
19:05:29 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
19:09:09 <NemesisD> gahhh i'm dumb, i need to put the initial state in the writer
19:10:38 <Peaker> writer doesn't need initial state
19:16:55 <NemesisD> blargh, i think i actually need the state monad
19:17:31 <NemesisD> need to read the current state, set it to the new state
19:18:37 <tabemann> random question - from stuff I've read, apparently doing imperative computations with, say, the ST monad is generally slower than doing the same computation in a garbage-collected imperative language - why (if such is so)?
19:19:18 <tabemann> (same thing with IORefs instead of STRefs and IOArrays instead of STArrays and so on)
19:19:36 <roconnor> w00t, go GeneralizedNewtypeDeriving
19:19:48 <dolio> Where did you read it?
19:19:57 <roconnor> newtype KleeneStore i a = KleeneStore ((Identity :+: StoreT i (KleeneStore i)) a) deriving (Functor, Comonad)
19:19:57 <tabemann> something with the GHC garbage collector not being designed to handle mutation of values well...
19:19:59 <dmwit> Yeah, I was going to say. [citation needed]
19:20:05 * hackagebot husk-scheme 3.11 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.11 (JustinEthier)
19:20:18 <tabemann> I'd give my citation if I remembered where it was
19:20:23 <dolio> deriving Comonad?
19:20:32 <dolio> Oh, right.
19:21:23 <roconnor> dolio: :+: makes comonads from comonads; StoreT makes comonads from comonads, and KleeneStore is a comonad by begging the question.
19:21:26 <geekosaur> tabemann, what I recall is something specific to mutable arrays, and I think it's been worked on since then
19:21:42 <roconnor> dolio: also, god exists because the bible says so
19:22:21 <geekosaur> certainly they redid write barriers for mutable arrays at least once since then
19:23:10 * tabemann is doing a presentation at work on Haskell, particularly on purity and laziness, and is wondering, if asked about "what if I really need mutable state!", whether he should mention the ST monad
19:23:38 <dolio> I can't say I've noticed ST being particularly slow.
19:24:00 <dolio> I actually think it's probably laughable to say it is, considering the performance of a lot of languages people actually use.
19:24:44 <tabemann> the problem with actually testing the performance of, say,  STArray, is it would require an equivalent program in an imperative language, and all the other factors determining differences in performance would likely drown out any actual performance hit from STArray alone
19:25:10 <dolio> Well, I wrote a bunch of sorting algorithms in a package.
19:25:20 <dolio> Many are faster than qsort in glibc.
19:25:20 <ParahSail1n> @ty ((_,q) -> [q])
19:25:21 <lambdabot>     Pattern syntax in expression context: (_, q) -> [q]
19:25:25 <geekosaur> http://ghc.haskell.org/trac/ghc/ticket/650 is the thing I recall (fixed in 6.12)
19:25:38 <dolio> I think qsort isn't that great, but...
19:25:38 <ParahSail1n> that seems like it should be valid?
19:25:56 <tabemann> and you can't directly compare performance against functional code, as the inherent differences in design will have other performance impacts aside from the one being looked for
19:25:57 <geekosaur> -> doesn't make a lambda, \ does
19:26:20 <ParahSail1n> derp
19:26:21 <roconnor> @pl \h -> flip <$> h <*> x
19:26:22 <lambdabot> (flip <$>) . (<*> x)
19:26:36 <ParahSail1n> too tired
19:27:18 <dolio> They aren't really that much slower than the STL equivalents, last I checked (which was really a long time ago).
19:27:18 <daat418> Hi guys...
19:27:31 <dolio> So, I don't think that's slow.
19:28:04 <dolio> So I don't think you can say that ST is slow.
19:29:50 <daat418> Scenario: Someone with no programming experience (save for 'related' experience with unixes, sql, server software configuration, etc.) wants to begin their journey with Haskell. What book or website would you immediately encourage that person to go and read?
19:29:54 <daat418> Please :)
19:30:20 <geekosaur> tabemann, did you look at the bug I cited? does it sound familiar? (it *isn't* the original discussion, which is probably what you ran across)
19:30:34 <tabemann> geekosaur: no, I didn't, and I should
19:31:09 <dmwit> ?where tutorials
19:31:10 <lambdabot> http://haskell.org/haskellwiki/Tutorials
19:31:15 <geekosaur> the upshot is that mutable arrays, most useful in ST (STArrays), *did* interact poorly with gc for a long time. but that was fixed several years ago
19:31:38 <dmwit> Everybody who's about to make a suggestion should go and improve the Tutorials wiki page instead.
19:31:49 <dmwit> Say why you're preferred one is good, and for what audience.
19:31:56 <dmwit> s/you're/your/
19:32:39 <daat418> dmwit: The problem with this suggestion is that I've carefully reviewed the wiki already. Within the context of my question, there is only one link that satisfies my conditions
19:32:53 <geekosaur> daat418, I think that's the point
19:33:00 <dmwit> Sounds to me like you answered your question, then?
19:33:04 <geekosaur> dmwit is pointing out that the wiki needs work :)
19:33:20 <tabemann> geekosaur: that looks like it might be the source of the performance problem I heard people commenting on
19:33:20 <daat418> And that link is a study by a university on why FP is a BAD choice for a first language paradigm.
19:33:43 <erisco> whoa wha? what is this study?
19:34:07 <daat418> erisco: Hold on, I'll find it for you
19:34:15 <dmwit> That doesn't sound like an answer to your question at all.
19:34:20 <daat418> erisco: I'm on my iphone
19:34:34 <dmwit> So I'm not sure why you think that satisfies your conditions.
19:34:36 <erisco> I can't think of how you'd make a meaningful measurement
19:35:26 <daat418> dmwit: The joys of mobile text. My brain wandered dealing with typing like this and i left out the word "remotely"
19:36:29 <dmwit> In that case, just work your way down the tutorials one by one until you have either reached enlightenment or done all the tutorials! =D
19:36:43 <daat418> erisco: http://www.cse.unsw.edu.au/~chak/papers/CK02a.html
19:37:27 <daat418> dmwit: Wouldn't I have more luck with a big tree? At least -that- method is tried and tested :p
19:38:36 <erisco> how do you easily view a postscript file on windows? :s
19:38:53 <dmwit> Or, to put it another way: if none of the available tutorials meet your conditions, change your conditions.
19:39:17 <dmwit> erisco: send it to your printer =P
19:39:26 <dmwit> erisco: More realistically: ghostscript? evince?
19:39:29 * erisco saw that one coming
19:39:35 <erisco> yeah imma try this evince thing
19:40:06 <daat418> erisco: Evince doesn't have a windows port
19:40:13 <dmwit> huh?
19:40:18 <erisco> this abstract doesn't sound convincing because they didn't mention any sort of control
19:40:40 <dmwit> The very first link on evince's download page is a Windows installer.
19:41:18 <daat418> erisco: dmwit: apologies, i must have been thinking of xpdf or something
19:41:37 <erisco> we use FP on first year students at our university, so this is somewhat interesting
19:42:11 <erisco> though, the same course intermingles with grammars and languages, and some things from first order logic
19:42:17 * tabemann wishes the school he went to used FP with first year students...
19:42:34 <dmwit> Our school just switched from Java to OCaml.
19:42:41 * Demos thinks his school uses c++ to weed out the weeklings
19:42:48 <erisco> at the least I'd like them to upgrade from miranda to haskell... but whatever
19:42:52 <dmwit> (for the first-year class)
19:42:59 <tabemann> people are still using miranda? lol
19:43:21 <erisco> tabemann, you might have found the last island :P our one prof has kept it alive
19:43:25 <tabemann> (the only thing I see getting out of miranda vis-a-vis haskell is avoiding the subject of monads)
19:43:48 <erisco> well they have the most obnoxious type variable names is my main complaint
19:43:53 <tabemann> asterisks!
19:43:59 <erisco> indeed ... many of them
19:44:08 <BMeph> tabemann: Yes! I could tell you more, but it's covered by trade secret agreements.... ;þ
19:44:30 <daat418> erisco: I work for a company that specializes in document generation and management solutions for postscript and pdf :)
19:44:46 <erisco> daat418, that makes your response even more embarassing then. ouch :P
19:44:57 <tabemann> remember that Miranda(TM) is a registered trademark of Research Software Ltd.
19:45:33 <daat418> erisco: Indeed. Give me some credit in that Windows users represent 0.5% of our client-base.
19:45:46 <daat418> erisco: :(
19:45:47 <erisco> okay -0.5% karma then
19:45:59 <zRecursive> :t (***)
19:45:59 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
19:46:10 <daat418> erisco: Why does it still sting? D:
19:46:44 <tabemann> dmwit: OCaml is certainly a better choice of languages to teach than *Java* of all things
19:46:49 <daat418> I don't want any negative values hanging over my head :'(
19:47:05 <dmwit> Well. Now they teach both OCaml and Java. =)
19:47:09 <dmwit> They just start with OCaml.
19:47:32 <tabemann> has OCaml just been put in the niche that Scheme has been put in at some schools?
19:47:52 <Demos> well MIT switched to python right?
19:48:00 <daat418> Apparently the newest cool thing is overlaying Java with Lisp...
19:48:15 <tabemann> Clojure is the new Lisp for the cool kids
19:48:16 <NemesisD> is there a better way to do something like this: asks functionAttr <$> applicativeFunctorArg
19:48:17 <Demos> I hear bad things about Scala
19:48:21 <NemesisD> which doesn't work btw
19:48:23 <erisco> wow that is somewhat misleading... finally get the paper open and they undo their title in the first sentence
19:48:49 <erisco> why pick on FP when you're claiming that no programming language is suitable?
19:49:00 <tabemann> (too bad to do generalized tail calls in Clojure you have to use a fucking trampoline, which the compiler isn't smart enough to hide from the user even)
19:49:03 <erisco> furthermore, how in the hell do you conclude that based on feedback from a FP course?
19:49:35 <Demos> fucking trampolines, it is 2013 people lets optimize tail calls
19:49:48 <tabemann> Demos: if one really wants an FP with object orientation, I for one like OCaml's object orientation far better
19:50:49 <NemesisD> the more i hear about scala the more it sounds like a trainwreck
19:50:51 * tabemann tried reading a book on Scala and it did absolutely nothing to help convince him to even try the language
19:50:51 <zRecursive> I like OCaml's fast compiling speed :)
19:51:02 <Demos> well if haskell gets non-stupid record types it would be sorta OO
19:51:44 <Demos> scala seems to combine the brain heavyness of haskell with the abstraction soup and verbosity of java
19:51:52 <tabemann> zRecursive: that is something I always liked about it
19:52:45 <erisco> ... and then they double back and say "purely functional languages are ideally suited for introductory computing classes, but only if the focus is on general concepts rather than the specifics of functional programming"
19:53:34 <erisco> well come on. first FP is right out. then all languages are out. now FP is back in on parole. what will happen next?! I am quaking in anticipation.
19:54:01 <tabemann> Demos: Scala gave me the impression of being overly elaborate while giving relatively little for that elaborateness, and for being all "we're adding FP to Java!" not being very good on FP lines
19:54:34 <dmwit> Haskell needs a good PDF library.
19:55:12 * hackagebot papillon 0.0.46 - packrat parser  http://hackage.haskell.org/package/papillon-0.0.46 (YoshikuniJujo)
19:55:43 <Demos> s/Haskell/Humanity/
19:56:14 <dmwit> I thought about writing one for a little while, until I realized 20 pages into the spec that my scroll bar was still at 3%.
19:56:14 <optimusbrine> my main problem with scala is that I have to think in java to use it, specifically when it comes to libraries.
19:56:42 <Demos> yeah I had the same problem with f#
19:56:53 <tabemann> http://www0.cs.ucl.ac.uk/teaching/3C11/amanda.html < just why did someone feel like (mostly) recreating Miranda, but as free software - and then implementing it only for Windows?
19:57:01 <BMeph> dmwit: Does Haskell have any PDF library?
19:57:19 <tabemann> F# feels like C# pretending to be a functional language, and Scala feels like Java pretending to be a functional language
19:57:26 <Demos> tabemann, wait, that is kinda the goal of haskell, sans the windows part
19:57:50 <Demos> yeah I agree, f# would be good if it had library support though
19:57:51 <tabemann> Clojure at least seems to do a better job of being an FP for a JVM language
19:57:54 <dmwit> BMeph: Sort of. There are some libraries for producing PDFs.
19:57:58 <dmwit> Nothing for reading them, though.
19:58:31 <erisco> then they throw up statistics with no control... this is sillyness. stop it.
19:59:13 <tabemann> Demos: that was kind of the original goal of Haskell, but Haskell went beyond Miranda in many ways, and also fixed things Miranda did wrong
19:59:41 <dmwit> erisco: Get over it. Teachers do their best to design the best course they can, and that's already about as much work as you can do in a semester.
20:00:10 <erisco> dmwit, not all teachers then publish a paper
20:00:41 <dmwit> Kind of my point.
20:01:03 <dmwit> There's nothing out there. Getting *something* out there is an improvement.
20:01:08 <tabemann> schools should have multiple "paths" for first-year students, where students are randomly assigned to classes that teach functional languages or classes that teach imperative languages, so they can make better studies
20:01:25 <erisco> dmwit, well then I can critique their findings :P
20:01:26 <dmwit> tabemann: Doing that in an ethical way is really hard.
20:01:34 <tabemann> dmwit: of course
20:02:38 <erisco> they do have one interesting table (only made it to page 7 thus far) which compares usefulness of different resources for learning Haskell
20:03:35 <erisco> "running examples in ghci" was the most outstanding with 60% ranking it as very helpful
20:03:51 <tabemann> hmm.. as for holdouts still using Miranda, how many holdouts are still using Hugs?
20:04:19 <geekosaur> too many, judging by the questions we get in here at the usual start of a semester :)
20:04:39 <erisco> though they did not detail what "running examples in ghci" means exactly, which is a bit unfortunate, but I imagine that means both demonstrating programs in ghci as part of lecture
20:04:48 <erisco> um, remove the word "both"
20:06:46 <erisco> that is a little odd though... I imagine ghci was just used to display the program output
20:07:25 <erisco> second was 44% very helpful, "stepwise program development in emacs", so I presume that was where the programs were written
20:07:33 <erisco> but, I dunno, they don't say :(
20:08:12 <zRecursive> :t (&&&)
20:08:12 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
20:08:26 <erisco> but they spend most of the paper trumpeting how great FP is, which is exactly what they said shouldn't be done in the outset of their paper :P
20:09:31 <slack1256> the hierarchy of lens is too big, what is the most basic import I should do to play with it.
20:09:39 <Clint> Control.Lens
20:09:44 <slack1256> s/\./?
20:11:03 <slack1256> but that all the modules, it seem to vast to dominate...
20:11:28 <Nisstyre> :t (&&&) `on` ar
20:11:29 <lambdabot>     Not in scope: `ar'
20:11:29 <lambdabot>     Perhaps you meant one of these:
20:11:29 <lambdabot>       `a' (imported from Debug.SimpleReflect),
20:11:36 <Nisstyre> :t (&&&) `on` arr
20:11:37 <lambdabot> Arrow a => (b -> c) -> (b -> c) -> a b (c, c)
20:12:16 <Nisstyre> what does that do?
20:12:31 <NemesisD> i find it remarkable that i have been bashing on this trivial problem in haskell for probably 2-3 hours just today and i haven't yet felt like i've been wasting my time
20:13:32 <Nisstyre> :t ((&&&) `on` arr) (const "a") (const "b")
20:13:33 <lambdabot> Arrow a => a b ([Char], [Char])
20:13:39 <Nisstyre> > ((&&&) `on` arr) (const "a") (const "b")
20:13:40 <lambdabot>   No instance for (Control.Arrow.Arrow a0)
20:13:40 <lambdabot>    arising from a use of `e_1'
20:13:40 <lambdabot>  Th...
20:17:15 <wallmani> new hpmor
20:17:30 <wallmani> oops
20:17:38 <wallmani> wrong channel again, sorry, grr
20:19:22 <NemesisD> uh oh. i've got an infinite type
20:19:28 * monochrom hugs Hugs
20:19:35 <NemesisD> what does one do?
20:19:38 <lpaste> tabemann pasted “Why is randomString producing only ".N"?” at http://lpaste.net/91014
20:19:59 <tabemann> whoops
20:20:00 <tabemann> got it
20:20:11 <tabemann> ignore that
20:24:24 <lpaste> tabemann revised “Why is randomString producing only ".N"?”: “Why is this hanging for test func 100000?” at http://lpaste.net/91014
20:25:12 <monochrom> infinite type is a special case of type mismatch. example: f x = f [x]. suppose x::t. then the RHS "f [x]" says that f's parameter has type [t]. then the LHS "f x" says x::[t]. therefore, x::t and x::[t] at the same time. this is an infinite type.
20:25:14 <frankbro> Is there a way to access old hpaste links?
20:25:45 <elliott> yes, access them at lpaste.net
20:25:48 <elliott> same paste ids
20:26:48 <monochrom> for example hpaste.org/77374 -> lpaste.net/77374  (try it!)
20:27:19 <monochrom> one simply walks into lpaste :)
20:27:22 <elliott> monochrom will do anything to promote his pastes
20:27:34 <elliott> hey monochrom, know any good urls ending in .xhtml?!
20:27:42 <monochrom> hehe, my pastes are superb!
20:28:23 <monochrom> http://www.vex.net/~trebla/weblog/fpbooks.xhtml
20:30:14 <tabemann> that's quite the use of unsafeInterleaveIO there
20:32:50 <Fuuzetsu> Is it fine to just call covariant functors cofunctors?
20:34:52 * tabemann doesn't know category theory, but would worry that "cofunctor" already has a special meaning somewhere
20:35:09 <lpaste> NemesisD pasted “stuck in transform stack, please send help” at http://lpaste.net/91017
20:35:22 <NemesisD> D:
20:35:25 <Fuuzetsu> tabemann: Yes, that is my worry so that's why I'm asking
20:35:52 <Fuuzetsu> my pastes never get announced in the channel ;(
20:36:23 <Fuuzetsu> Oh, I put the author down as Fūzetsu though, this might be the issue
20:37:01 <NemesisD> anyone know what i'm missing here?
20:37:30 <roboguy_> Fuuzetsu: I don't know category theory either, but I have a feeling that they call them "Covariant" in the covariant functor library for a reason
20:37:53 <Nisstyre> Is there any way to get ghc to recognize that f (Just (Foo a)) = ... and f Nothing = ... is exhaustive?
20:37:59 <Nisstyre> I'm guessing not
20:38:08 <Nisstyre> er wait
20:38:13 <roconnor> Fuuzetsu: My understanding is that cofunctors is not a good name to use for anything
20:38:18 <roboguy_> Fuuzetsu: it sounds like the dual of a functor is a functor (from reading the library description), which probably means "cofunctor" doesn't really work
20:38:21 <roconnor> because functors are self dua.
20:38:22 <Nisstyre> yeah I'm stupid, that should be f _
20:38:40 <Nisstyre> which makes it exhaustive
20:39:01 <roconnor> Fuuzetsu: you can call covarient functors ... functors.
20:39:11 <roboguy_> err "Contravariant"
20:39:14 <roconnor> and contravarient functors ... contravarient functors
20:39:37 <Fuuzetsu> roboguy_: but isn't the dual of a functor precisely the covariant functor?
20:39:41 <Fuuzetsu> I haven't checked this.
20:40:24 <roboguy_> Fuuzetsu: oh whoops I thought you were talking about contravariant functors. isn't the usual haskell "functor" a covariant functor?
20:41:25 <roboguy_> since all the arrows go the same way, I thought (a -> b and f a -> f b)
20:41:33 <NemesisD> there's something i'm misunderstanding about MonadState
20:43:00 <Fuuzetsu> roboguy_: apologies, I was supposed to say contravariant functor
20:43:12 <Fuuzetsu> covariant functors are indeed just your plain functors
20:44:13 <Nisstyre> does :set -i ../ only work as expected in 7.6?
20:44:22 <Nisstyre> as in I want to search a directory above for modules
20:45:21 <NemesisD> monochrom: i've gotten myself out of the infinite type by adding some type annotations but i'm stuck
20:45:29 <Nisstyre> I meant :set -i../
20:45:29 <applicative> if you think of categories as coming in pairs opposite to each other, neither being prior, it's clear that covariant vs. contravariant is a purely verbal distinction.
20:46:39 <roboguy_> applicative: I think I sort of see what you mean, but that's still a little confusing. isn't there still some need to distinguish between them?
20:46:54 <DiegoNolan> if i have a data type that is a union with a bunch of constructors but constructers all have some comma type how can i write a function to get the underlying type for all of the constructors
20:47:03 <DiegoNolan> this is going to be difficult to explain
20:47:38 <roboguy_> DiegoNolan: you mean like data SomeType = A (Int, Int) | B (Int, Int) | C (Int, Int)?
20:47:44 <applicative> roboguy_: yes, but i was thinking it's like distinguishing between i and j in the complex numbers ...
20:47:45 <DiegoNolan> yeah
20:47:51 <DiegoNolan> how would i get all the tuples
20:48:00 <Nisstyre> seems like 7.4 makes you list each file passed to -i individually, lame
20:48:18 <Nisstyre> damn you ubuntu for using outdated software
20:48:23 <tabemann> getValue A x = x; getValue B x = x; getvalue C x = x
20:48:47 <DiegoNolan> i tried writing something like that but it seems to not be working
20:48:51 <DiegoNolan> maybe i'm tying something wrong
20:48:55 <DiegoNolan> let me check
20:49:06 <applicative> data Some = A
20:49:10 <dwcook> You need parens around the (A x) and such, no?
20:49:11 <applicative> data Some = A | B | C
20:49:26 <applicative> newtype SomeType = (Int,Int,Some)
20:49:33 <roboguy_> applicative: hmm. so it's like two names for the same thing?
20:49:40 <monochrom> you missed a constructor there
20:49:42 <applicative> diegoNolan (n,m,_) = (n,m)
20:49:49 <applicative> oh yeah, monochrom
20:50:07 <applicative> newtype SomeType = S (Int,Int,Some)
20:50:16 <monochrom> but go for the simplifying fix. change "newtype" to "type" :)
20:50:17 <applicative> diegoNolan (S(n,m,_)) = (n,m)
20:50:47 <applicative> I was thinking of a type synonym, but was just trying to put alternatives on the table for DiegoNolan
20:51:12 <monochrom> software bug fixes need to use more deletive fixes than additive fixes
20:51:57 <DiegoNolan> hmm
20:52:02 <DiegoNolan> it doesn't seem to be working
20:52:09 <DiegoNolan> i think i have to do something with the typeclass
20:52:14 <DiegoNolan> but it doesn't seem correct
20:52:18 <roboguy_> DiegoNolan: maybe you should use the paste site and show us some code
20:52:53 <applicative> DiegoNolan: all the worthwhile type classes have already been declared
20:53:16 <DiegoNolan> applicative: yeah this is with the juicypixels typeclass
20:53:38 <applicative> ah, okay maybe not *all*  of them ...
20:53:45 <DiegoNolan> how do i get the url on lpaste?
20:54:03 <applicative> lpaste.net?
20:54:15 <DiegoNolan> nvm
20:54:16 <DiegoNolan> http://lpaste.net/91018
20:54:29 <tabemann> if you your name on there as your name in here and mark it a public paste, our paste will be automatically advertised in here
20:55:06 <tabemann> (and you mark the channel as #haskell)
20:55:10 <applicative> DiegoNolan: does this typecheck?
20:55:14 <DiegoNolan> no
20:55:26 <DiegoNolan> but removing the type declaration doesn't help either
20:55:29 <applicative> img things are of different types
20:55:38 <DiegoNolan> well they are Image a
20:55:39 <applicative> ah Tekmo was here, didn't say hi
20:55:48 <DiegoNolan> Pixel a
20:55:49 <DiegoNolan> or something
20:55:54 <DiegoNolan> but they are all Image
20:58:04 <roboguy_> DiegoNolan: looking at the docs, it seems like those pixel types aren't instances of PixelBaseComponent
20:58:21 <DiegoNolan> yeah i tried just Pixel a
20:58:24 <DiegoNolan> but that didn't work either
20:58:33 <roboguy_> DiegoNolan: and, in fact, at least one of them is a type synonym (for Word8)
20:58:43 <DiegoNolan> yeah
20:58:51 <DiegoNolan> is you look at Image though
20:59:31 <DiegoNolan> it is Image a = imageWidth :: Int, imageHeight :: Int, Vector (PixelBaseComponent a)
21:00:27 <applicative> It looks like the type you are trying to get out of, is there for a reason.  I think your function is impossible. I wonder what you were going to do next, that's probably where the answer is
21:00:30 <roboguy_> DiegoNolan: hmm, I'm not sure what you're trying to do makes sense
21:00:37 <DiegoNolan> well
21:00:44 <DiegoNolan> i have a function
21:00:47 <DiegoNolan> that squares an image
21:01:12 <lpaste> DiegoNolan pasted “JuicyPixels” at http://lpaste.net/91019
21:01:31 <applicative> the dynamicMap function may be the ticket
21:01:53 <applicative> it shows how to 'get out' of a DynamicImage if I'm following
21:02:01 <DiegoNolan> oh
21:02:07 <DiegoNolan> i didn't see that in the doc
21:02:21 <DiegoNolan> can you link?
21:03:41 <DiegoNolan> oh pixelmap?
21:03:45 <DiegoNolan> yeah possible
21:03:48 <DiegoNolan> possibly*
21:04:15 <DiegoNolan> oh wait no
21:04:21 <DiegoNolan> because that's an Image a -> Image b
21:05:27 <applicative> I was looking at line 294 of https://github.com/Twinside/Juicy.Pixels/blob/master/Codec/Picture/Types.hs
21:05:34 <applicative> but it doesn't seem quite right
21:06:17 <applicative> does squareImage typecheck?
21:08:43 <roboguy_> DiegoNolan, applicative: well, it seems to typecheck for me at least
21:09:04 <applicative> ah, it does, i have juicypixels now ... weighing down .cabal/lib
21:09:16 <DiegoNolan> roboguy_: what typechecks?
21:09:20 <DiegoNolan> what i pasted?
21:09:25 <roboguy_> DiegoNolan: squareImage
21:09:32 <DiegoNolan> roboguy_: oh yeah
21:09:34 <DiegoNolan> that works
21:09:35 <DiegoNolan> but
21:09:38 <DiegoNolan> when you load an image
21:09:43 <DiegoNolan> You get a DynamicImage
21:09:50 <DiegoNolan> which can be an Image of a bunch of pixel types
21:09:56 <DiegoNolan> i want to get to an Image
21:10:00 <DiegoNolan> to i can use that function
21:10:14 <DiegoNolan> can't figure out how to get out of that dynamicImage type
21:10:25 <roboguy_> DiegoNolan: well, what about dynamicMap like applicative said?
21:10:35 <DiegoNolan> roboguy_: i would need to see it
21:10:44 <DiegoNolan> roboguy_: what lmodule is it in?
21:10:45 <roboguy_> DiegoNolan: it's in Codec.Picture.Types
21:10:52 <DiegoNolan> oh dammit
21:11:01 <roboguy_> DiegoNolan: http://hackage.haskell.org/packages/archive/JuicyPixels/3.1/doc/html/Codec-Picture-Types.html#g:6
21:11:57 <DiegoNolan> ahh
21:11:59 <DiegoNolan> thanks
21:12:10 <DiegoNolan> i didn't have that loaded so i couldn't see it in ghci
21:13:55 <DiegoNolan> is stuff like this only possible with existential types?
21:14:27 <applicative> this is a little rough, but I think he's given us all the pieces
21:15:32 <applicative> it sounds like what you really want if pictureMap :: (forall a. Pixel a . Image a -> Image a) -> DynamicImage -> DynamicImage
21:15:56 <applicative> pictureHoist
21:16:29 <applicative> I mean something like that
21:17:26 <DiegoNolan> yeah
21:17:51 <DiegoNolan> applicative:
21:17:56 <DiegoNolan> yeah now i don't know how to go back
21:18:32 <applicative> oh this pixelMap function looks like another piece of the puzzle
21:19:34 <DiegoNolan> applicative: yeah, but  then i have no change to one pixel type
21:19:37 <DiegoNolan> which i guess is fine
21:20:53 <DiegoNolan> applicative: I think i can just write what i want
21:20:57 <DiegoNolan> looking at the source
21:21:16 <DiegoNolan> i may just submit a pull request the guy maintaining it seems pretty nice
21:22:34 <applicative> it does sound that in any case, he can inform you what the intended way of going about this is. Its pretty clear he means to have all the pieces you need.
21:22:56 <applicative> but maybe not, yeah
21:23:06 <applicative> or not yet
21:28:34 <DiegoNolan> Well that failed
21:29:37 <DiegoNolan> nevermind
21:29:39 <DiegoNolan> got it
21:30:46 * tabemann wishes he had invested in 16 or 32 GB of RAM right now
21:32:36 <NemesisD> anyone have a few minutes to help me figure out this error i'm getting? http://lpaste.net/91017
21:33:09 <johnw> yep, you can always use more RAM
21:34:39 <tabemann> basically I just realized that my code is constructing two *huge* sets, which it for every of 1000000 items (aside from constructing those items then hashing them) is A) checking for membership in set A B) inserting into set A C) checking for membership in set B D) inserting in set B
21:36:01 <tabemann> which means horrible performance because, even though for checking for membership and insertion it only has to walk log N nodes in a given set, for insertion it has to replace all of the nodes it walked too, and this is with basically no cache locality at all
21:36:57 <tabemann> and I think I should probably kill the process because it looks like it is starting to eat into swap and thus lose a significant amount of performance from swapping, meaning that I wonder whether it will complete by the time I wake up tomorrow
21:37:33 <tabemann> but then, it seems to be eating more memory than I calculated it should...
21:39:08 <tabemann> and because most of these values aside from nodes in the sets are ByteStrings, they can't take advantage of compacting GC and thus will fragment the heap to no end...
21:39:28 <NemesisD> sounds pretty bad
21:43:11 <lpaste> applicative pasted “juicypixels hoist” at http://lpaste.net/91020
21:43:50 <applicative> DiegoNolan: I wonder if that is reducible to what he give you?  It is a pain in the neck ^^^
21:44:51 <DiegoNolan> applicative: Yeah, that's what i ended up doing
21:44:59 <DiegoNolan> applicative: I don't tihnk so
21:45:15 <DiegoNolan> applicative: I put an issue on the github, have to see what he says
21:45:37 <applicative> it does seem like a patch is in order, or else a reduction to what we are given
21:46:38 <tabemann> random question - is there a hash table implementation for Haskell?
21:46:43 <DiegoNolan> yeah, I mean it is obviously possible but that function seems somewhat useful
21:46:49 <johnw> you mean, like HashMap?
21:46:55 <tabemann> yeah
21:46:56 <johnw> or Hashable?
21:48:07 <tabemann> I really want a HashSet actually
21:48:55 <NemesisD> unordered-containers has that
21:48:57 <applicative> what about the one in unordered-containers
21:49:15 <tabemann> is there any reason to use one or the other?
21:49:28 <ethoma7329> I am trying to figure out why there is such a huge performance difference between these two codes: http://lpaste.net/91022 http://lpaste.net/91021. The C code runs in 7 ms and the Haskell code in 60 ms on my system. Can anyone help
21:49:48 <tabemann> (the main consideration I have is how does it perform with *really* big sets)
21:49:56 <NemesisD> this might be a dumb question: why have i not seen a hashmap in haskell with O(1) inserts
21:50:13 <ethoma7329> I wrote the Haskell code in a C-like style on purpose to try to figure out why there is such a large performance difference.
21:51:05 <tabemann> fuck
21:51:20 <applicative> a regular mutable hash table is attempted here NemesisD https://github.com/gregorycollins/hashtables
21:51:22 <tabemann> Data.HashSet exists in both hashmap and unordered-containers
21:51:58 <elliott> unordered-containers is the standard
21:52:05 <applicative> oh unordered containers is the standard
21:52:39 <tabemann> hmm how do you *remove* a package with cabal?
21:52:47 <applicative> NemesisD: be sure to compile with -funsafe-tricks !
21:52:50 <NemesisD> applicative: why do you say attempted? its released on hackage
21:52:55 <inf-groupoid> tabemann: You can't AFAIK. :-|
21:53:01 <tabemann> fuck
21:53:10 <NemesisD> man this implementation sounds hairy
21:53:27 <applicative> NemesisD: yeah, my impression was he is still working on it, I'm not sure why I say that.  I always link to github because I only believe in source not haddocks
21:54:12 <tabemann> will this break things horribly: rm -rf ~/.cabal/packages/hackage.haskell.org/hashmap
21:54:17 <applicative> tabemann: you remove a package with ghc-pkg unregister package
21:54:23 <NemesisD> hashing is hard
21:54:31 <inf-groupoid> tabemann: Also, if you need predictable performance when dealing with big sets, because, even if they are amortized O(1), they are worst-case O(horrible).
21:54:46 <inf-groupoid> when dealing with big sets, hash tables are horrible*
21:55:14 <tabemann> my tree sets I was using were absolutely horrible
21:55:33 <inf-groupoid> tabemann: Then use someone else's better tree set.
21:55:34 <tabemann> they *should* have O(log N) performance, but that log N seemed too big nonetheless
21:55:58 <inf-groupoid> tabemann: Well, that depends on the hidden constant.
21:56:01 <zRecursive> oh
21:56:23 <inf-groupoid> tabemann: But O(log N) grows slowly, really.
21:56:44 <tabemann> what makes me want to use a hash set is that it should allocate the hash as one big buffer, rather than lots of nodes strewn about memory
21:57:14 <inf-groupoid> tabemann: You are not forced to allocate all nodes individually.
21:58:08 <inf-groupoid> tabemann: You can use a B-tree (or some variant of them) if you want to cluster some values together.
21:59:12 <tabemann> with a hash set, the behavior I expect is for there to be few collisions, because the hash itself will be *big*, so the performance will end up really being O(1) with the constant factor being A) generating a random ByteString and B) hashing it
21:59:30 <tabemann> likewise, insertion should be O(1), and it isn't going to require regenerating a whole path down a tree every time
21:59:39 <roboguy_> ethoma7329: did you profile it? it looks like most of the time and allocation is in randomList
22:00:09 <dolio> Copying an array is O(1) now?
22:00:15 <ethoma7329> roboguy_: That is true - but I am only measuring the time for the actual integration. I am comparing the integration times only.
22:00:22 <inf-groupoid> tabemann: Are binary trees the only trees you have tried?
22:00:52 <tabemann> I'm using whatever Data.Set is using, really
22:01:07 <inf-groupoid> tabemann: Oh.
22:01:11 <tabemann> and I'd prefer to use prewritten data structures before I start coming up with my own
22:05:37 <tabemann> hah
22:05:43 <tabemann> the HashSet version is much faster
22:05:59 <tabemann> much faster
22:06:16 <NemesisD> woop woop
22:07:25 <NemesisD> they never say what the W is in their complexity
22:07:47 <dolio> Word size, probably.
22:08:32 <mm_freak> tabemann: there is one pure data structure that is much faster than HashSet
22:08:39 <mm_freak> by much faster i mean orders of magnitude
22:09:06 <mm_freak> the tradeoff is:  it's query-only
22:09:21 <mm_freak> @hackage quickset
22:09:21 <lambdabot> http://hackage.haskell.org/package/quickset
22:09:22 <tabemann> what is it?
22:09:49 <tabemann> the query-only part means that I can't use it, though
22:10:50 <johnw> quickmap reminds of doing binary searches on fixed arrays in C
22:11:00 <mm_freak> johnw: that's what it does
22:11:05 <mm_freak> well, in principle you can write singleton and union functions for it
22:11:11 <mm_freak> but union would be full-copy
22:11:47 <carter> i just found an old email i wrote from 2007 about module systems for haskell and why thats hard
22:12:15 <carter> i was much cooler nearly a decade ago
22:12:44 <tabemann> module systems for Haskell... they make you wish that Haskell had parameterized modules... but then those leave you wondering about just *how* would they interact with type classes...
22:13:23 <tabemann> at least with type classes you don't *need* parameterized modules, as much as they would be nice
22:13:29 <mm_freak> tabemann: module parameters out of scope in classes and instances, case closed
22:13:58 <mm_freak> it's the only sensible solution
22:14:37 <mm_freak> technically you could even allow parameters in classes, but then you would really have a class family
22:15:24 <zRecursive> :hoogle Data.Set
22:15:35 <mm_freak> @hoogle Data.Set
22:15:36 <lambdabot> Data.Bits setBit :: Bits a => a -> Int -> a
22:15:36 <lambdabot> Data.Set module Data.Set
22:15:36 <lambdabot> Data.Set data Set a
22:17:24 <carter> tabemann mm_freak  i actually sketched out a neat / crazy approach even
22:17:25 <carter> in particular
22:17:25 <carter> i had a nice sketch of how to ground the type class matter in logically coherent way
22:17:56 <shachaf> carter: Come on, you're typing two spaces.
22:18:07 <shachaf> Just use a :. Everyone else does. It's a protocol-level thing.
22:18:14 <carter> oh
22:18:15 <carter> ok
22:19:03 <carter> hows it in the protocol?
22:19:25 <carter> mm_freak tabemann : the idea i had was  to use the logical consistency ideas from Twelf
22:19:42 <carter> for the type class consistentcy check
22:20:15 <carter> twelf has this interesting idea of worlds, which are logically sound collections of related definionts
22:20:26 <carter> plus some of the logic programmingy characteristics
22:20:38 <carter> though no one uses it anymore I think...
22:20:44 <carter> http://twelf.org/wiki/Main_Page
22:21:13 <shachaf> carter: Human-level protocol.
22:21:20 <carter> ah
22:21:21 <carter> k
22:21:35 <carter> stop asking me and it'll be positive reinforcment :)
22:21:39 <carter> k shachaf ?
22:21:44 <carter> shachaf: sound good/
22:21:45 <carter> ?
22:22:17 <zRecursive> Is shachaf a haskell expert  ?
22:22:23 <daat418> A man is cast away on a desert island. This man is a system administrator but has always wanted to (and has very recently made the decision to) actively teach himself programming and to -do it right-. A box washes up on shore and it contains two books - LYAH and "The Scheme Programming Language". Which book should he -study seriously- first and subsequently (and inevitably) which language?
22:22:43 <carter> zRecursive whats the qeustion?
22:22:55 <CADD> carter: twelf isnt used much anymore? thats a shame, it looked interesting
22:22:56 <NemesisD> hey shachaf would you mind helping me debug hopefully the last of the issues i had with my state machine experiment?
22:22:58 <daat418> zRecursive: hello again :)
22:23:08 <daat418> i just got back
22:23:08 <zRecursive> daat418: hello
22:23:13 <zRecursive> me too
22:23:16 <elliott> daat418: a man is cast away on a desert island, and decides to ask #haskell whether to learn Haskell or another language. which answer should he suspect?
22:23:26 <tabemann> lol
22:23:27 <CADD> elliott: LOL
22:23:27 <carter> daat418 SICP is a good book if you're new to computer science
22:23:39 <daat418> elliott: the end result is that he wants to excel at haskell.
22:23:47 <CADD> indeed +1 for SICP
22:23:56 <elliott> I recommend Haskell books over Scheme books for learning Haskell :)
22:24:00 <carter> yes
22:24:00 <shachaf> carter: Sounds good.
22:24:01 <daat418> carter: thank you. searching for it
22:24:11 <shachaf> NemesisD: ?
22:24:12 <Gracenotes> SICP exercises are extremely good, though
22:24:13 <carter> daat418 structure and interpretation of computer programs
22:24:19 <Gracenotes> of course, they can largely be translated to Haskell
22:24:22 <carter> classic
22:24:25 <carter> Gracenotes true
22:24:28 <carter> but first: computer science!
22:24:32 <daat418> elliott: but do you recommend haskell books over scheme books for teaching fundamental computer science principles?
22:24:37 <NemesisD> shachaf: http://lpaste.net/91017
22:24:38 <carter> also racket-lang is a lovely tool
22:24:44 <carter> daat418 its not a scheme book
22:24:48 <carter> it just happens to use scheme
22:24:50 <CADD> daat418: There is no royal road to Haskell. -Euclid
22:24:51 <elliott> daat418: well, you can learn those with any good language.
22:24:51 <carter> its a computer science book
22:25:01 <elliott> daat418: Scheme isn't any "purer" than Haskell in this respect.
22:25:03 <daat418> carter: this... this is -exactly- what I need
22:25:12 <daat418> carter: you have parted the river... thank you very, very much
22:25:19 <daat418> *ocean
22:25:19 <carter> daat418 then for now: SICP  + use racket-lang
22:25:22 <shachaf> Just use a :. Everyone else does. It's a protocol-level thing.
22:25:24 <CADD> carter: omg, i love racket
22:25:28 <NemesisD> ive always wondered what my experience would have been like if i started programming with haskell instead of imperative languaes
22:25:31 <shachaf> Er.
22:25:36 <shachaf> That was a mis-upa-arrow.
22:25:37 <CADD> NemesisD: me too!
22:25:42 <shachaf> NemesisD: Any reason you're asking me?
22:25:47 <carter> shachaf: i'll forgive you this one time
22:25:52 <CADD> NemesisD: im going to teach my kids fp, before they learn anything else
22:26:14 <carter> NemesisD : i had a single summer of c / c++ in high school an di was like "theres got to be something ıetter"
22:26:16 <carter> *better
22:26:18 <CADD> NemesisD: probably specifically scheme
22:26:22 <NemesisD> shachaf: because i know you know what you're doing. i've just been pestering this channel throughout the night and getting this thing a little closer to compile
22:26:24 <carter> then I found scheme / lambda papers end of teh summer
22:26:24 <tabemann> I'm still kicking myself for rejecting learning Haskell because of monads (of all things) years ago, when I could have learned it then rather than now
22:27:00 * tabemann remembers reading the lambda papers
22:27:01 <NemesisD> carter: they started me with c/c++. i don't know why i even wanted to continue learning programming after that
22:27:10 <carter> NemesisD because you wanted nicer things
22:27:33 <NemesisD> carter: school certainly didn't give them to me, it was C++ and Java from there on out. i picked up ruby in my free time
22:27:39 <carter> tabemann: in high school i thought of monads as "algebraic thing with operations that enforce cooties"
22:27:55 <daat418> So...
22:28:14 <carter> granted i was also trying to figure out how to do a call by value CPS transform for depedently typed languages end of high school
22:28:18 <carter> i should revist that project some time
22:28:21 <daat418> Should I believe that you're all... envious of my -lack- of programming knowledge?
22:28:35 * CADD remembers the lambda papers as well..
22:28:43 <carter> daat418: its like a blank slate of future awesome
22:28:48 <carter> no hurry
22:28:50 <carter> enjoy the learning
22:28:53 * tabemann had taught himself OCaml in high school, but is only now just glancing at dependently typed languages...
22:29:15 <carter> tabemann idris is the language I wanted to figure out how to make in 2007
22:29:17 <daat418> carter: I get the concept but I didn't realize it was such a big deal, "I wish I could go back and learn haskell", "I'm teachning my kids Scheme first!"
22:29:22 <NemesisD> daat418: i'm not. i like being a competent programmer now. and haskell is enough of a challenge to me that i still learn new stuff all the time
22:29:30 * CADD thinks http://www.scribd.com/doc/938809/Design-of-a-LISPBased-Microprocessor is the best lambda paper.
22:29:39 <carter> daat418: whats a big deal?
22:29:42 <carter> just enjoy learning
22:29:51 <NemesisD> plus haskell having haskell on my brain a lot helps me to see so many failings in the stuff i do at work that are simply not an issue with haskell
22:30:05 <shachaf> Scheme vs. Haskell is off-topic in this channel, as are deserts, desserts, and islands.
22:30:24 <carter> we're saying both are great
22:30:26 <tabemann> Scheme is a very nice impure language
22:30:28 <carter> we just use haskell :)
22:30:45 <CADD> i want my dessert!
22:30:58 <carter> racket lang rolled out a really nice math lib a few months ago
22:31:00 <tabemann> it's not a very *practical* impure language, but that has more to do with fragmentation in implementations than anything
22:31:01 <carter> really good design
22:31:07 <daat418> carter: let me reiterate - learning code through imperative languages: can it handicap your learning experience with FP languages? is it painful/frustrating/very_difficult to break out of the house you've built with C and Java?
22:31:07 <zRecursive> :t foldl (>>=)
22:31:07 <lambdabot> Monad m => m a -> [a -> m a] -> m a
22:31:17 <carter> daat418 : just learn :)
22:31:22 <carter> learning is good for the brain
22:31:26 <dalaing> daat418: I think they're just different houses
22:31:30 <tabemann> (well, *racket* is quite a practical Scheme, but if you want to program for it, you're stuck programming for it)
22:31:31 <carter> haskell can be wildely imperative
22:31:38 <carter> yes
22:31:40 <carter> racket is nice
22:31:50 <carter> they even have a truely portable gui toolkit
22:32:04 <dalaing> daat418: I've been diving into Haskell / typed-FP for a few years, been coding for work with Java and C++ for the last 11 years, hasn't been a problem
22:32:23 <carter> more styles of thinking = more ways to engineer great things
22:32:51 <carter> ghc haskell is a great imperative language even
22:32:53 <daat418> carter: I'm not afraid of learning. I'm just ADHD/OCD and I would like to be as motivated as possible to focus on ONE thing. Being able to crystalize a decision down to mono is imperative (har har) to people like me. Believe it or not, it will be fatal to my learning experience to do otherwise.
22:33:03 <NemesisD> daat418: it is not impossible, it helps to have FP on your radar, but going with imperative first its easy to not know what you're trading away
22:33:07 <carter> daat418 focus on computer science :)
22:33:28 * tabemann never realized you could treat side effects as first-class values before he started really working with Haskell
22:33:29 <carter> daat418 i'm clinically the first and borderline the latter :) focus on math and cs generally
22:33:32 <zRecursive> IIRC, racket is big and slow
22:33:39 <carter> zRecursive nah, they have  JIT
22:33:40 <daat418> carter: that is why i want to hug you for SICP - my synapses clicked into gear like a Cherry MX Blue
22:33:50 <carter> daat418 make sure you sleep first
22:33:52 <carter> and read bits
22:33:57 <zacts> what are you guys talking about SICP?
22:34:01 <carter> yes
22:34:01 <zacts> I'm doing SICP now..
22:34:03 <NemesisD> daat418: in my experience, lots of software engineering learning materials imply that OOP is the only way people get work done
22:34:05 <carter> its a good book
22:34:07 <zacts> I want to learn haskell next
22:34:11 <daat418> carter: "sleep first" - your degree of intuition is staggering...
22:34:15 <daat418> :o
22:34:29 <carter> sleep = brain can do magically productive things
22:34:31 <tabemann> OOP is overblown and heavily flawed, even if one is going to be writing imperative code
22:34:31 <carter> theres no way around it
22:34:37 <CADD> zRecursive: no, i actually did some benchmarks a while ago. it actually is on par with the JVM on speed and memory use
22:34:44 <carter> oop is 7 different ideas
22:34:47 <carter> that people call the same thing
22:34:49 <zacts> sicp -> haskell -> everything else like python/perl/C/C++/etc...
22:34:51 <CADD> zRecursive: not as great as haskell, but its still very good
22:34:53 <zRecursive> CADD: really
22:34:58 <NemesisD> daat418: because obviously Cat extends Animal, Dog extends Animal is a huge win
22:35:05 <carter> zRecursive: computer science :)
22:35:10 <carter> eerrr
22:35:11 <carter> i mean
22:35:13 <zacts> sicp and haskell will be my foundation
22:35:15 <daat418> NemesisD: Funny, I've already done enough research to know for a fact that the complete opposite is true... and I know nothing...
22:35:16 <carter> zacts: focus on computer science
22:35:21 <CADD> zRecursive: yup. It was clojure vs racket. they both had pretty much exactly the same speed and memory use
22:35:29 <CADD> zRecursive: Plus racket has a JIT now
22:35:31 <zacts> carter: what do you mean by that?
22:35:41 <zacts> isn't focusing on SICP and haskell focusing on comp sci?
22:35:42 <tabemann> subtyping is in practice a liability and not an asset; most things one really wants out of it can be gotten from ADTs, and everything else should be restricted so there is no inheritance of implementation
22:35:46 <carter> yes and no
22:35:50 <carter> learning lots of math will help you
22:35:54 <zRecursive> CADD: any URL to recomend ?
22:36:14 <CADD> zRecursive: you mean benchmarks?
22:36:14 <zacts> yes, I'm a bit lacking in math, but I'm going to be taking lots of math classes in college
22:36:14 <carter> haskell is a great prototyping vehicle for many computer sciencey things
22:36:19 <daat418> carter: May I ask what made you bring up the topic of sleep? I'm truly stunned...
22:36:20 <carter> cool
22:36:24 <NemesisD> daat418: i speak only from my experiences getting a BS CS degree. they gave us imperative C, then slapped it out of our hands, gave us OOP as gospel and said this is how computers are programmed
22:36:28 <zRecursive> CADD: yeah
22:36:32 <carter> daat418 because all i ever do is talk about myself :)
22:36:38 <NemesisD> i'm starting to think i went to some bad schools...
22:36:45 <zacts> NemesisD: yeah, my uni focuses a lot on Java and C.
22:37:04 <carter> daat418: any wisdom i say is strictly of my own experience and combo  of theoretical and empirical knowledge
22:37:20 <tabemann> my school first taught people Java, then *MIPS assembly*, and then C (they didn't teach you C, they expected you to learn it on your own in you spare time)
22:37:20 <carter> and i know little
22:37:21 * zRecursive If you like math, then it is better to learn haskell 
22:37:42 <zacts> MIPS asm? :D
22:37:48 <carter> learn a variety of things
22:37:49 <tabemann> zacts: yes
22:37:53 <carter> and learn some DEEPLY
22:37:53 <zacts> I like math, I just need more experience with it.
22:37:55 <CADD> zRecursive: no, not really. just my own testing
22:38:00 <carter> zacts takes time
22:38:04 <carter> and time management
22:38:05 <CADD> there are the unofficial benchmark games
22:38:10 <carter> and good course/ colleuage
22:38:13 <zRecursive> CADD: ok
22:38:14 <CADD> zRecursive: http://benchmarksgame.alioth.debian.org/
22:38:35 <zacts> my uni offers great math courses, but I feel that their comp sci may be lacking..
22:38:52 <carter> what uni
22:38:57 <daat418> carter: speaking of "empirical knowledge" is not very common...
22:39:01 <dalaing> CADD: if you want to talk about JVM speed and memory usage, you'd do better to use java -server than clojure
22:39:02 <carter> lies
22:39:04 <daat418> carter: we assuredly have a lot in common...
22:39:14 <daat418> carter: by the way - are you ADHD?
22:39:23 <carter> i said yes
22:39:32 <dalaing> CADD: and there's a heap of problems with the shootout to begin with
22:39:34 <carter> though sleep quality and low stress helps A LOT
22:39:47 <CADD> zRecursive: but obviously some of that may be a bit biased. since it is hard to create a benchmark that will really show off the ability for macros to save on code size and that kind of stuff
22:39:51 <CADD> dalaing: ^
22:40:10 <daat418> carter: :) give me a moment to page-up, I've clearly missed part of this conversation
22:40:15 <daat418> carter: well met!
22:40:16 <zRecursive> CADD: sure
22:40:34 <CADD> as well as those benchmarks being all based on entries by people with highly variable skill level
22:40:56 <CADD> and that some languages dont have enough people writing for them
22:40:59 <daat418> carter: I am the same. clinically former, borderline latter.
22:41:00 <CADD> so that skews it as well
22:41:07 <daat418> carter: do you take a prescription?
22:41:11 <NemesisD> love those microbenchmarks
22:41:13 <carter> when it make sense
22:41:16 <carter> i'm not really ocd
22:41:22 <carter> at least in a medical way
22:41:28 <daat418> carter: so you are not on a daily regimen
22:41:31 <dalaing> the main problem with the benchmarks is that the programs aren't constrained to idiomatic usage of the language - you get all kinds of code written in XYZ that looks nothing like any other XYZ out there
22:41:37 <zRecursive> Just found an interesting scheme implementation using Haskell: git://github.com/justinethier/husk-scheme.git
22:41:44 <carter> math / engineering done nicely  isn't medical ocd
22:41:51 <carter> regimen?
22:42:00 <tabemann> dalaing: it seems like a lot of the benchmarks are heavily hand-optimized for speed and not for covering realistic use cases
22:42:23 <daat418> carter: re rx
22:42:23 <carter> well :shachaf: wants us to switch to #haskell-blah all
22:42:24 <CADD> dalaing: oh trust me, the pitfalls of those benchmarks have been well explored. But in a pinch they kinda-sorta work
22:42:45 <daat418> shachaf: apologies.
22:42:45 <carter> daat418 theres medications for ocd?
22:42:52 <daat418> carter: no sir, adhd
22:43:01 <daat418> I'll join blah
22:43:07 <zRecursive> I heard of shachaf many times :)
22:43:18 <shachaf> Actually, I just want the conversation to stop in #haskell. I don't care where it goes, if anywhere.
22:43:32 <zRecursive> ok
22:44:08 <NemesisD> shachaf: i have a legit haskell problem atm ;)
22:44:26 <NemesisD> but my brain is pretty fried after flailing on it for a good 2 or 3 hours
22:46:24 <carter> lpaste it  :)
22:47:48 <NemesisD> http://lpaste.net/91017
22:49:08 <NemesisD> as a reality check, this *began* as an experiment to see how easy it would be to write a generic state machine w/ transition hooks
22:49:17 <carter> NemesisD you have no monadstate instance
22:50:13 <NemesisD> carter: i'm a bit lost on that. i was not expecting to have to write one
22:50:21 <NemesisD> which makes me think i've annotated things incorrectly
22:50:21 <carter> i know nothing
22:52:17 <flebron> Hi. What am I doing wrong here? This is an expression that I'm assigning to some top level binding, i.e. foo = { the paste }. http://ideone.com/UWSm0R . Ignore the spacing on the first line, the "in" and the "let" are aligned on the actual file, ideone just strips the first spaces :|
22:52:34 <flebron> (I'm getting a syntax error on line 15 of that paste.)
22:53:08 <CADD> flebron: holy crap. you should break that function up
22:53:20 <flebron> Why is it a syntax error however?
22:53:35 <shachaf> flebron: What is line 15 trying to accomplish?
22:53:39 <shachaf> It looks like a syntax error to me.
22:53:43 <flebron> shachaf: It's a list comprehension.
22:53:50 <flebron> It starts on line 2.
22:53:57 <shachaf> Hmm.
22:54:00 <shachaf> Did you try indenting it?
22:54:09 <NemesisD> yeah the indentation looks off
22:54:09 <flebron> How much?
22:54:13 <shachaf> More.
22:54:27 <NemesisD> that is the largest list comprehension i've ever seen
22:54:29 <flebron> Ah OK, indenting it up to where "in" in "in case" worked :)
22:54:50 <flebron> Thanks!
22:55:51 <carter> hehe
22:56:07 <carter> i've seen haskelll code in production and its less crazy than that (usualy)
22:56:33 <NemesisD> i don't think i ever use let/in except in quickcheck props
22:56:35 <flebron> It's programming competition code :)
