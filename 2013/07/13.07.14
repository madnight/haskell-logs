00:00:20 <Gracenotes> or add parens
00:00:22 <zRecursive> Gracenotes: besides what you said, "red <- sort <$> (pickNums gr 5 []) ++ (pickNums ([1..33] \\ gr) 1 [])" has error:     Couldn't match type `[]' with `IO' ...
00:00:56 <Ghoul_> is there some kind of Undo monad?
00:01:17 <Ghoul_> or, Diff monad. A state where an evaluation can go forwards and backwards
00:02:50 <Gracenotes> zRecursive: oh, that might be a separate issue. Why are you using <$>?
00:03:22 <Gracenotes> If is pickNums in the monad you're using, you can't use (++) on its return value
00:03:45 <Gracenotes> since (++) only works on lists
00:05:42 <zRecursive> ok, using "<-" to get it
00:06:50 <prophile> Ghoul_: interesting
00:07:02 <prophile> you could presumably do that in the State monad
00:07:20 <prophile> and by presumably I mean you could do that
00:07:28 <prophile> do you envision some kind of 'undo stack'?
00:07:55 <roboguy_> Ghoul_: like for backtracking?
00:08:14 <Ghoul_> well, what I need to keep track of is this
00:08:41 <Ghoul_> who modifies something, how its modified, and what it looks like at the current time.
00:08:53 <Gracenotes> something like applicative would still work, or something like liftM2 ((sort .) . (++))
00:09:09 <Ghoul_> and ideally I'd be able to undo everything a person does, or go back in time for everyone, and stuff like that
00:09:14 <Ghoul_> I'm trying to roll my own, right now :)
00:10:00 <isomorphic> @hpaste
00:10:00 <lambdabot> Haskell pastebin: http://hpaste.org/
00:12:19 <isomorphic> http://lpaste.net/90892  <- does the use of MaybeT seem redundant in this example?  I want IO and Maybe-like properties
00:14:06 <jfischoff> is there anyway to make a more general Monoid class using Polykinds?
00:15:40 <prophile> jfischoff: like Category? :)
00:16:39 <jfischoff> I was thinking of Monad and Applicative
00:16:54 <jfischoff> also Alternative
00:17:25 <jfischoff> so many monoids ….
00:20:56 <shachaf> johnw: If I ran lambdabot, I'd do it.
00:21:25 <johnw> Cale is still the one to ask?
00:22:27 <Taneb> jfischoff, what would that make Just "hi" <> Just "jfischoff"
00:23:17 <shachaf> elliott runs lambdabot.
00:27:41 <mstksg> Ghoul_: you could maybe use Writer and log diffs
00:28:07 <zRecursive> Gracenotes: thx, the 1st working version: http://paste.lisp.org/display/138045
00:28:08 <mstksg> but State seems like a more canonical choice
00:28:14 <jfischoff> Taneb: I'm not sure what you are asking?
00:28:47 <shachaf> jfischoff: You could make Monad a Monoid in a particular category, probably, but I imagine it wouldn't really be all that useful.
00:28:49 <Taneb> If there was a polykinded "instance Monoid Alternative"
00:29:15 <Taneb> It would completely clash with the monoid instance for Monoid a => Maybe a
00:30:11 <jfischoff> Taneb: instance Monoid Alternative?
00:30:38 <Taneb> Wasn't that what you were talking about?
00:30:51 <shachaf> Taneb: I assume jfischoff meant expressing that Monad is a monoid in a particular category, and that Applicative is a monoidal functor, or something like that.
00:30:57 <jfischoff> well that doesn't typecheck
00:31:05 <shachaf> kindcheck :-)
00:31:11 <Gracenotes> zRecursive: looks good... might need some more surgery to make it work efficiently (things like !! are fragile too, etc.), but compiling is good!
00:31:14 <jfischoff> Alternative is type class not a type
00:31:26 <jfischoff> shachaf: sure
00:31:31 <Taneb> I was being somewhat approximate
00:31:36 <jfischoff> ok
00:31:40 <Taneb> I meant a general Monoid instance for Alternatives
00:31:44 <zRecursive> Gracenotes: sure
00:31:47 <jfischoff> ah
00:32:04 <Ghoul_> Originally I was going to do a list of diffs, but after failing to implement that I'm going to try and implement something like Undoable (History b) a { undo :: (a -> b -> b); current :: b; redo :: (a -> b -> b) }
00:32:16 <jfischoff> I am trying to make something useful
00:33:28 <jfischoff> but I think understanding how Applicative is monoidial functor, monad is basically a monoid, MonadPlus/Alternative are monoids is useful. It would be nice if there was a simple way to show this in Haskell.
00:34:03 <jfischoff> err
00:34:13 <jfischoff> not trying to make something useful ;)
00:34:43 * Ralith mumbles something about dependent types
00:39:40 <roboguy_> Ghoul_: what if you had a triple that was something like (Person, Int, Change) where the Int tells you how many commands they entered up until that command, and you could do things like undoAllBy xs person = filter (\(p, _, _) -> p /= person) xs. I'm not sure if that completely makes sense but that's the sort of thing I'd probably think about
00:41:14 <Ghoul_> Yes, I agree, but I may do something with/like MonadUnique so I don't have to store a lot of floating People
00:41:16 <Gracenotes> as far as more efficient algorithms for this, look into operational transformation
00:41:58 <Gracenotes> it's really just a data structures/reasoning problem; making it into an DSL (a la a monad) may be an interesting exercise
00:46:52 <Gracenotes> this algorithm is fairly simple, with correctness proofs: http://dl.acm.org/citation.cfm?id=1180918
00:47:18 <Gracenotes> actually representing the sets of operations in data structures is the most interesting part, I think
00:49:11 <Gracenotes> any revision control system is also going to have opinions on how to do it :)
00:49:38 <Gracenotes> such as "don't"
00:50:18 <Ghoul_> well, still mashing stuff in my head, I think I'll make a typeclass for stuff that can be transformed between future form and past form
00:50:42 <Ghoul_> ie: something to represent that given an Int, the future form might be (+1) and the past form might be (-1) or something
00:51:07 <Ghoul_> then I can easily keep lists of functions rather than lists of objects and just adapt MonadUndo under New Monads on the haskell wiki
00:51:56 <Gracenotes> still, I would advise looking at operational transform literature if you have the opportunity, as it's easy to get little things wrong and not provide some useful operational properties
00:52:35 <Gracenotes> or, alternatively, make a nice extensible system from scratch, and publish a paper!
00:52:40 <Gracenotes> or both :)
00:55:02 <prophile> @hoogle (MonadPlus m) => m a -> m a -> m a
00:55:02 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
00:55:02 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
00:55:02 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
01:10:20 <latermuse> seems hpaste.org is down
01:11:12 <shachaf> See topic.
01:15:19 <latermuse> got it, thanks
01:19:49 <Lethalman> ah hate nested Maybe :S return . join $ fmap unpack <$> fileInfoGetName <$> info
01:20:06 <Lethalman> > join (Just Nothing)
01:20:07 <lambdabot>   Nothing
01:20:12 <Lethalman> > join (Just (Just 3))
01:20:13 <lambdabot>   Just 3
01:20:18 <Lethalman> > join Nothing
01:20:19 <lambdabot>   Nothing
01:21:03 <shachaf> :t return . join
01:21:04 <lambdabot> (Monad m, Monad m1) => m1 (m1 a) -> m (m1 a)
01:21:28 <shachaf> Hm.
01:39:09 <Lethalman> :t ((Just f) <$>)
01:39:10 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `Maybe a1'
01:39:10 <lambdabot>     In the return type of a call of `Just'
01:39:10 <lambdabot>     Probable cause: `Just' is applied to too many arguments
01:39:15 <Lethalman> :t ((Just f) <*>)
01:39:16 <lambdabot> (Show a, FromExpr b) => Maybe a -> Maybe b
01:39:20 <Lethalman> :t fmap f
01:39:22 <lambdabot> (Functor f, Show a, FromExpr b) => f a -> f b
01:39:26 <Lethalman> uhm
01:40:37 * hackagebot GLFW-b 1.0.2 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.0.2 (BrianLewis)
01:45:37 * hackagebot bindings-GLFW 0.0.1 - Low-level bindings to GLFW OpenGL library  http://hackage.haskell.org/package/bindings-GLFW-0.0.1 (BrianLewis)
02:24:36 <tomboy64> could someone help me with this error?
02:24:38 <tomboy64> http://bpaste.net/show/114204/
02:25:45 <tomboy64> i don't get why [0..(...)] could expect something other than Int?
02:27:16 <shachaf> That code looks way too confusing. I can barely match the parentheses.
02:27:54 <shachaf> Can you take the part of the code that's causing the error and make it cause the error by itself?
02:27:57 <tomboy64> heh
02:28:18 <tomboy64> okay, let's see
02:45:47 <ksf> is there some package providing sane syntax to specify static graphs?
02:55:04 <johnw> ksf: why not use a dot-file parser?
02:55:06 <bitonic> ksf: dot is reasonably sane, no?
02:55:10 <bitonic> damnit :P
02:55:13 <johnw> :)
02:55:24 <johnw> took us both 9 minutes to say the exact same thing
02:56:54 <ksf> that's a good idea
03:06:34 <jfischoff> is there a package that given a Template Haskell Exp will infer the type for you?
03:09:44 <mgsloan>  jfischoff: I imagine that something could be hacked up with hint.  I've always wanted to give that a try.  But as far as I know it doesn't exist
03:09:59 <mgsloan> I think I may have tried it before and had issues with running ghci inside ghci
03:10:30 <jfischoff> I've missing with type inference for simple haskell like languages
03:10:30 <mgsloan> so it might have to start up an external "ghci" to do it
03:10:54 <mgsloan> neat!
03:10:57 <jfischoff> I thought it would be fun to try to due something from scratch with TH
03:11:07 <jfischoff> but it wouldn't work exactly the same :p
03:11:16 <jfischoff> still might be useful ...
03:11:19 <ksf> ok. I've got a golf course for you.
03:11:20 <mgsloan> Seems like it ought to be possible to port haskell-type-exts to TH
03:11:35 <ksf> compare lists by position of the first Just element.
03:11:41 <jfischoff> what!
03:11:48 <jfischoff> I had never seen haskell-type-exts
03:12:35 <mgsloan> jfischoff: It was a summer of code project last year
03:12:44 <jfischoff> mgsloan: looks cool
03:13:13 <jfischoff> yeah if it works even partially it would still be better then creating signatures for generated code
03:13:14 <mgsloan> jfischoff: Yup!  Haven't tried it myself
03:13:26 <mgsloan> So all you need to do is invert haskell-src-meta and you'll be good to go ;)
03:13:55 <jfischoff> or port it to work on TH
03:14:08 <mgsloan> jfischoff: Are you working on the "makeClassy" problem?
03:14:13 <jfischoff> no
03:14:35 <jfischoff> Its just a long term project of mine to really understand how Haskell works
03:14:54 <mgsloan> gotcha.  There's this stub function in Control.Lens.TH that's something like --TODO: code up type unification
03:15:04 <jfischoff> ooh
03:16:03 <jfischoff> sounds cool. But I even though I have written a few unification algos I have yet to be able to without reading some else's code. It hasn't really sunk it yet
03:16:19 <jfischoff> although I made a lot of break throughs today in my understanding
03:16:34 <jfischoff> I haven't done type classes yet, but I have read about it
03:16:39 <jfischoff> I get the general idea
03:16:40 <supki> ksf: compare `on` preview (ifolded._Just.asIndex)
03:16:45 <supki> or something
03:17:26 <FreeFull> I need to write a raymarcher again
03:17:44 <FreeFull> It clicked the first time I wrote one, but I think now I forgot
03:18:29 <jfischoff> I would like to write a type checker for a dependently typed language next
03:19:33 <shachaf> jfischoff: cmccann keeps telling me to read this one paper about that.
03:19:47 <jfischoff> do you remember which one?
03:21:45 <shachaf> I think that it's http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf , or perhaps http://strictlypositive.org/Easy.pdf
03:21:51 <shachaf> Those look like two versions of the same paper.
03:21:56 <jfischoff> oh yeah
03:22:06 <Ghoul_> Given `newtype Bar = Bar Int` how do you add a constraint for an instance declaration like `instance Num a => Test (Bar a) Bar .. ?
03:22:20 <jfischoff> I've read the beginning of that one a while ago
03:22:37 <Ghoul_> where Test is some class like `class Test a b where`
03:23:12 <opqdonut> Ghoul_: "Bar a" makes no sense, the Bar type constructor takes no arguments
03:23:36 <opqdonut> as for the Int inside the Bar (value) constructor, the compiler will know that it has a Num instance
03:23:50 <FreeFull> Ghoul_: You don't add a constraint
03:24:07 <Ghoul_> Yeah, sorry, I only just realized I was being pretty dumb
03:24:12 <opqdonut> :)
03:24:17 <bitonic> jfischoff: I have a tutorial ready for that but I need to write some prose about it :P
03:24:33 <jfischoff> bitonic: do it! :)
03:24:41 <bitonic> jfischoff: but yes there is “Simply, Easy” and this <http://augustss.blogspot.it/2007/10/simpler-easier-in-recent-paper-simply.html>
03:24:59 <jfischoff> such a great blog post
03:25:12 <bitonic> jfischoff: this is the code <http://mazzo.li/posts/deplambda.html>, I was writing it mostly to show how to have a nice, type safe term representation
03:25:45 <bitonic> and well mine includes parsing/pretty printing/a repl.  but those are the uninteresting parts
03:26:01 <bitonic> well maybe pretty printing no, since I recover the names used by the user
03:26:31 <bitonic> oh and I also have equality
03:26:39 <bitonic> still have to write the eliminator for that
03:27:07 <jfischoff> bitonic: bookmarked. Just looking at the types is interesting.
03:27:29 <bitonic> I’ll try to do a writeup soon.  I’m always scared that nobody will care :P
03:27:54 <jfischoff> well in the grand scheme of things yes
03:28:12 <jfischoff> but people will read it, just put a link on reddit
03:28:17 <bitonic> well here I’m talking about the difference between 0 and 1, ehe
03:28:47 <jfischoff> what else is good to write for practice. A prolog interpreter?
03:29:17 <bitonic> that’s interesting as well, yes
03:29:27 <mikeplus64> http://quasimal.com/plissken0.ogv <- my haskell game has been pretty good practice. for opengl mostly
03:29:50 <mikeplus64> and i have now a fragmented knowledge of linear algebra (vs having none before :))
03:30:47 <jfischoff> I have more experience with that stuff than I do with PLT. I'm curious about the new llvm bindings. Never actually written a compiler.
03:31:32 <bitonic> well those lambda-calc tutorials are not about compiling really
03:31:45 <bitonic> that’s interesting too
03:32:23 <FreeFull> mikeplus64: 3D worm. Looks cool, but difficult to play
03:34:35 <mikeplus64> FreeFull: very :)
03:34:52 <Xarius> hello, I try to built a function rgb2cmyk converter in haskell with this formular http://pastebin.com/steXVsEn can someone plz give me some hint how to do that?
03:35:07 <mauke> The paste steXVsEn has been copied to http://lpaste.net/90893
03:46:23 <Xarius> no one?
03:47:41 <Cale> Xarius: What part are you having trouble with?
03:50:13 <klrr_> Xarius: what is it rgb2cmyk? is it some kind of color codes?
03:51:20 <klrr_> what is agda, is there any code examples?
03:51:36 <johnw> klrr_: many, just google for it
03:51:49 <klrr_> johnw: if i found some i woudlnt have asked...
03:52:00 <klrr_> http://wiki.portal.chalmers.se/agda/pmwiki.php
03:52:04 <klrr_> i dont find any code ther
03:52:09 <johnw> I just googled for "agda code example"
03:52:11 <shachaf> @google agda code examples
03:52:12 <lambdabot> http://code.haskell.org/Agda/examples/
03:52:12 <lambdabot> Title: Index of /Agda/examples
03:52:24 <johnw> exactly
03:52:34 <klrr_> lol ddg sucks penis anal, it didnt find that link, google ftw
03:52:34 <johnw> just click on one of the .agda files
03:52:36 <Xarius> It should be a red yellow blue to cmyk converter with this formular I took quards for it but I did it wrong I get not in scope errors
03:52:49 --- mode: ChanServ set +o johnw
03:52:52 --- kick: klrr_ was kicked by johnw (Kicked by johnw)
03:53:01 --- mode: johnw set -o johnw
03:54:39 <klrr_> -.-
03:57:38 <Xarius> http://pastebin.com/RzQRZ9N4
03:57:40 <mauke> The paste RzQRZ9N4 has been copied to http://lpaste.net/90894
03:59:13 <klrr_> Xarius: what are you trying to do, what is W,C,M,Y,K? they are supposed to be boolean expressions in that use in gaurds
03:59:58 <klrr_> Xarius: http://pastebin.com/yvditrpv
04:00:00 <mauke> The paste yvditrpv has been copied to http://lpaste.net/90895
04:12:16 <bitonic> klrr_: I wrote this a while ago: <http://mazzo.li/posts/AgdaSort.html>, there is also Ulf’s tutorial
04:12:49 <bitonic> which includes various examples
04:13:45 <Xarius> http://pastebin.com/XZJGp0Gj
04:13:49 <Ghoul_> is it possible to do class specific types
04:13:50 <mauke> The paste XZJGp0Gj has been copied to http://lpaste.net/90896
04:15:03 <Xarius> error on "="
04:15:08 <Ghoul_> Nevermind, typeclass constraints imply.
04:17:41 <Xarius> no one?
04:19:37 <Ghoul_> > drop 4 [1,2]
04:19:38 <lambdabot>   []
04:19:46 <Ghoul_> > drop 1 [1,2]
04:19:47 <lambdabot>   [2]
04:22:32 <statusfailed> Is there a datastructure that lets me look up partial keys?
04:23:09 <johnw> a trie will return the substructure below a prefix
04:23:29 <statusfailed> johnw: problem is if I have a key like (a, b, c) I might want to look up (b, c) or (a, c)
04:23:42 <Ghoul_> is there something I can use to split a list at a certain part without separately doing a drop and a take?
04:23:46 <johnw> you need to pass over the whole structure using a predicate, I think
04:24:04 <Ghoul_> ie: f 3 [1..5] gives ([1,2,3],[4,5])
04:24:12 <johnw> splitAt
04:24:16 <Ghoul_> :t splitAt
04:24:17 <lambdabot> Int -> [a] -> ([a], [a])
04:24:18 <tomboy64> Ghoul_: data.list. splitAt for example. partition as well.
04:24:22 <Ghoul_> thanks
04:24:46 <statusfailed> johnw: that's probably not a problem for me, but I thought maybe there was a better way :)
04:25:18 <statusfailed> actually I might be able to use one of those magic trees from sequence mining algorithms
04:33:33 <v4hn> ok, so I successfully build ghc using the x86_64-unknown-linux binary build to bootstrap
04:35:23 <v4hn> one problem is left though: the install mechanism installs the ghc binary to /usr/bin/x86_64-unknown-linux-ghc (with full platform prefix) instead of /usr/bin/ghc (the same for ghc-pkg haddock-ghc hsc2hs and runghc)
04:36:01 <tomboy64> make a symlink?
04:36:05 <v4hn> Should I create symlinks for the shortcommands myself or did I miss a switch to add them automatically somewhere?
04:37:43 <notdan> oh I like the page design on new-hackage
04:43:14 <Ghoul_> After DatatypeContexts were deprecated, what's the proper way to make this compile : `newtype Monad m => TimeT s m a = TimeT (StateT (History s) m a)`
04:43:56 <supki> remove  Monad m =>
04:43:59 <Ghoul_> (I don't feel like GADT's feel right here)
04:44:10 <Ghoul_> ok
04:51:03 <gabor> Can somebody update lambdabot w.r.t. "lpaste"?
04:51:04 <gabor> ?paste
04:51:04 <lambdabot> Haskell pastebin: http://hpaste.org/
04:51:05 <gabor> [9:54pm] lambdabot: Haskell pastebin: http://hpaste.org/
04:51:06 <gabor> should be http://lpaste.net/
04:53:30 <klrr_> i cant install wx
04:53:44 <klrr_> configuration failed
04:54:35 <tomboy64> klrr_: fix it? :)
04:57:07 <klrr_> tomboy64: if it cant install it probably is a bad library
04:57:13 <klrr_> since they dont even spend time making it installable
04:57:58 <tomboy64> klrr_: if you're talking bout wxwidgets, it works fine with me.
04:58:08 <tomboy64> if config fails, your system fails to meet the requirements
04:58:26 <klrr_> tomboy64: okey, im running ubuntu 13.04
04:58:42 <klrr_> tomboy64: it also wasnet installable in 12.04
04:58:47 <tomboy64> maybe you should paste the actual error and fix it instead of just complain about it
04:58:49 <tomboy64> +ing
04:59:06 <tomboy64> klrr_: ubuntu is a very bad choice for installing software by hand.
04:59:29 <tomboy64> but go ahead, paste the configure error
04:59:46 <klrr_> https://gist.github.com/klrr/5994064
05:00:36 <klrr_> tomboy64: what do you mean with installing software by hand? im used to having a package manager keeping track of my software so im not that experienced with such things
05:01:38 <tomboy64> klrr_: you wrote "klrr_ | configuration failed" - so i assume you executed "./configure"? is that correct?
05:01:53 <klrr_> tomboy64: nope. cabal-install is what im using
05:02:14 <benmachine> klrr_: do you have the required C libraries?
05:02:31 <klrr_> i installed something called "libwxgtk-dev" or sth
05:02:40 <klrr_> so i should have the header files
05:02:42 <klrr_> i think
05:03:09 <tomboy64> klrr_: what is the actual error you got?
05:03:16 <klrr_> https://gist.github.com/klrr/5994064
05:03:55 <benmachine> it sounds like it's not happy with the wx you have installed
05:04:00 <benmachine> maybe check if you have version 2.9 or 2.8
05:04:35 <benmachine> if you have 2.8 you might consider installing an older version of wx
05:04:36 <benmachine> http://hackage.haskell.org/package/wx-0.13.2.3
05:04:46 <benmachine> dunno though, never tried myself
05:04:47 <klrr_> i got 2.8
05:05:41 <klrr_> well, then i cant learn reactive-banana since the examples depend on wx, which is not installable, this leads to reactive-banana being impossible to learn and im forced to learn stupid yampa instead -.-
05:05:41 * hackagebot labyrinth 0.1.5.1 - A complicated turn-based game  http://hackage.haskell.org/package/labyrinth-0.1.5.1 (AlexeyKotlyarov)
05:05:55 <benmachine> klrr_: did you try installing an older version?
05:06:11 <benmachine> klrr_: the Hackage page says the latest version is compatible with 2.9 only
05:06:20 <benmachine> but earlier versions are compatible with 2.8
05:06:32 <klrr_> benmachine: okey, well, i  got no time for that :s
05:06:45 <benmachine> it's not hard
05:06:54 <klrr_> how is it possible?
05:07:05 <benmachine> cabal install wx-0.13.2.3
05:07:24 <klrr_> ok
05:07:41 <benmachine> or just cabal install 'wx < 0.90'
05:08:25 <klrr_> thanks
05:09:06 <Ghoul_> Sorry, one last question. Anyone know why I get these errors/code: http://lpaste.net/90897 ? The code is mostly off the wiki ( http://www.haskell.org/haskellwiki/New_monads/MonadUndo ) but I've attempted to rip out the deprecated extensions and failed. Maybe it's too outdated, or I did something wrong...
05:10:39 <lasticot> Hi, I've got a problem at compilation. Can someone help me through it?
05:10:58 <klrr_> lasticot: show us the stuff
05:11:21 <benmachine> Ghoul_: that's odd, I can't see why you'd get that error
05:11:58 <lasticot> klrr_: that's weird lpste didn't send the link ... http://lpaste.net/90898
05:12:14 <Ghoul_> :( me neither
05:12:22 <lasticot> klrr_: and for the actual code http://lpaste.net/90899
05:12:59 <klrr_> never used State monad sry
05:13:20 <lasticot> klrr_: ok thank you anyway
05:16:40 <benmachine> Ghoul_: ah, got it
05:18:02 <benmachine> Ghoul_: in the implementation of put in the MonadState instance, what's the type of s?
05:18:19 <supki> lasticot: do notation is not inherited by if-then-else
05:18:27 <supki> lasticot: I've added annotation
05:18:33 <lasticot> ok than you
05:19:20 <Ghoul_> (sec thinking)
05:19:48 <Ghoul_> It should be History s, I think
05:20:11 <benmachine> Ghoul_: okay, so what about its past field?
05:20:30 <Ghoul_> oh, woops, I think I see what happened
05:20:33 <supki> lasticot: it probably still not going to typecheck - mc91(mc91(n + l1)) does not look good
05:20:47 <Ghoul_> Yep, thanks for making that obvious :)
05:20:56 <Ghoul_> [Delta] -> [a] fixed it up :)
05:21:06 <benmachine> Ghoul_: the error message was pretty unhelpful, so I don't blame you for not seeing it :)
05:21:32 <lasticot> supki: indeed some remains of imperative programming ...
05:22:21 <lasticot> supki: sry I see the problem
05:22:41 <benmachine> Ghoul_: I suppose you've got to read the error as "I think you were trying to put a History Delta, when I only know how to put a History s
05:22:44 <benmachine> "
05:24:25 <benmachine> and it assumed you were dealing with a History Delta because you were using its present field in a list of Deltas
05:25:11 <Ghoul_> yeah, I kinda see now. the error was really confusing though
05:27:54 <CaptainK> What is the equivalent of /dev/null?
05:28:22 <danr> CaptainK: http://hackage.haskell.org/package/acme-dont ?
05:30:25 <CaptainK> lol " instead of executing the block it controls, it... well... doesn't."
05:31:09 <CaptainK> if then don't
05:38:26 <CaptainK> but if you code it to never have to make that decision then you should never need to not do something :P
05:48:16 <Peaker> Most uses of lists as data structures (As opposed to control flow) are pretty inefficient.  What are some alternatives? I think some List-of-smallish-vectors could often be more efficient in long-term data structures
05:51:28 <Peaker> i.e: instead of a linked list of single items, hold a linked list of arrays of 8 items each or so, to remove the overhead of 7 out of each 8 cons cells.  For storage of X elems in the non-full vector, Y pointers are wasted relatively to lists: X,Y=(1,7),(2,5),(3,3),(4,1),(5,-1),(6,-3),(7,-5),(8,-7).   Modifying a vector by copying it, when it involves just 8 pointers shouldn't cost much (it fits a cache line)
05:51:33 <hpc> Array or Vector is usually a good choice
05:52:16 <Peaker> Well, if we still want the nice attributes of lists (cheap/persistent prepending)
05:52:28 <Peaker> then we can still get most of them in the list-of-vectors approach
05:52:42 <hpc> you don't really have cheap prepending though, unless you insert a chunk at a time
05:52:47 <hpc> see also: bytestring
05:52:57 <Peaker> copying a vector of up to 8 elements should be very cheap
05:53:41 <hpc> Peaker: what if those 8 elements are a wide unboxed data structure? :P
05:54:01 <Peaker> hpc, use a boxed vector, it will only copy up to 8 ptrs
05:54:19 <Peaker> the alternative is list, so it would be unboxed anyway
05:55:34 <Peaker> it would be nice to do the bytestring/text chunking trick with a list of vectors of any value
05:56:16 <Peaker> almost-as-cheap prepend, much lower memory use, much faster iteration (less pointer chasing), probably less GC overhead
05:56:16 <hpc> i wonder if there exists (Storable k, Storable v) => Storable (Map k v)
05:57:13 <Spockz> All of my figures are suddenly moved to the end of my chapter. I've never seen this before in an article documentclass and I can't find a change that triggers the behaviour. Are there flags/packages that force all figures to the end of an chapter? (The figures are 5+ pages away from their definition
05:57:24 <FreeFull> Peaker: Something basically like lazy bytestrings, but for any data?
05:57:30 <Peaker> are there statically-sized arrays anywhere?  i.e: vector whose type restricts it to be size=8?
05:57:44 <FreeFull> Ah, yeah, that's what you said
05:57:50 <Peaker> FreeFull, yeah, but limiting chunk sizes to be small enough that copying isn't expensive
05:58:29 <Spockz> Wait wrong channel. :)
05:58:44 <hpc> random access is still very slow in chunked lists
05:58:54 <Peaker> hpc, the point is to replace linked lists, not arrays/vectors
05:58:56 <hpc> as is post-pend
05:59:12 <Peaker> linked lists sometimes have useful properties as a data structure (mainly, very cheap prepend), but are very sucky in many ways
05:59:32 <Peaker> doing a linked list of smallish vectors gives you a better trade-off for most cases than a list, I believe
06:00:40 <hpc> this would only be useful for stack-like data structures, in any event
06:01:00 <Peaker> or ones where order doesn't matter and you need to add a lot?
06:01:05 <hpc> or for "streaming" like with bytestrings, but that's getting back into "list as control structure" territory
06:01:31 <Peaker> well, even for the list-as-control-structure, if the list has to persist, and can't be fused away, you're still probably better off with Chunky lists
06:04:21 <Eduard_Munteanu> What's a good regexp library these days?
06:04:50 <Eduard_Munteanu> Linux-only is fine.
06:05:46 <Eduard_Munteanu> regex-posix gets some bashing on the wiki for being slow and non-portable
06:06:41 <Peaker> why regex and not attoparsec or such?
06:07:55 <Eduard_Munteanu> Peaker: hm... good question. I'm converting a small bash script, and it seemed straightforward, but attoparsec should also be straightforward.
06:15:56 <aristid> Eduard_Munteanu: attoparsec is just for binary data, no? why not parsec if it's text?
06:16:24 <jhance> aristid: attoparsec is for speed, not for binary data; parsec is for error messages
06:17:01 <aristid> jhance: well, attoparsec is probably also not optimal if you have non-ascii text :P
06:17:12 <aristid> oh nevermind
06:17:17 <aristid> it does support Text
06:17:29 <aristid> sorry for the confusion
06:17:34 <Peaker> attoparsec gave me performance issues when naively parsing comma separated lines (not csv) -- so I shudder to think what parsec is like :)
06:17:50 <Peaker> but attoparsec does the "try" for you which is nicer than parsec - and i'm ok with its error messages
06:18:20 <aristid> oh. having to insert the try manually is indeed annoying with parsec
06:22:20 <mm_freak> breaking news:  javascript just got inductive families and termination checking from ECMAScript 17301
06:22:58 <srhb> What are inductive families?
06:23:11 * Eduard_Munteanu checks 'cal'
06:23:31 <Eduard_Munteanu> Mm, nope, not 1st of April. W-w-w-what? :)
06:24:17 <Eduard_Munteanu> srhb: GADTs I think
06:24:22 <srhb> Oh.
06:24:24 <srhb> Wild.
06:29:45 <ksf> is ghc smart enough to only call a function in a view pattern once?
06:29:58 <elliott> yes
06:30:01 <elliott> the rules are described in the manual
06:30:03 <ksf> \o/
06:33:41 <yitz> mm_freak: brilliant. when you think about it, it's actually not that hard for javascript to predict whether someone is about to be fired.
06:36:29 <yitz> Peaker: but attoparsec's auto-backtracking caused a serious bug
06:36:38 <aristid> i'm still excited that my first non-trivial pipe (pipes-4.0-based) that i wrote yesterday worked as soon as it would compile. :D
06:37:03 <yitz> Peaker: it is now fixed, but the result is that when you have significant backtracking, attoparsec now eats up huge amounts of memory, causing it to be much slower
06:37:32 <jhance> aristid: That happens alot with haskell :D
06:37:33 <yitz> Peaker: there is talk of adding an option for non-backtracking <|>, like parsec, to restore performance
06:38:00 <mm_freak> srhb: inductive families are basically GADTs + dependent types
06:38:14 <aristid> jhance: well there are plenty of ways i could have screwed it up, despite the type system :)
06:38:28 <yitz> mm_freak: how could that make any sense in javascript?
06:38:37 <ksf> parser combinators are hell when it comes to performance, even attoparsec.
06:38:43 <mm_freak> elliott: is it similarly smart for pattern guards?
06:38:51 <ksf> the simple truth is that they just aren't analysable.
06:39:00 <yitz> ksf: i've had good results with attoparsec (until now)
06:39:10 <elliott> mm_freak: don't know
06:39:20 <mm_freak> yitz: it was a joke…  by ES17301 it's a lazy, dependently typed functional language
06:39:22 <ksf> a parser generator can assure you that your grammar is LL(1) or whatever.
06:39:58 <yitz> mm_freak: aha got it. idrisscript i suppose.
06:39:59 <aristid> ksf: well isn't that because they're all monadic?
06:40:07 <mm_freak> idrisscript hehe
06:40:07 <ksf> that and open recursion
06:40:15 <aristid> ksf: a purely Applicative combinator library should be better, no?
06:40:29 <ksf> unless it's infinite, like virtually all are, yes.
06:40:47 <ksf> just have a look at the definition of many etc. you need actual kleene stars to optimise things.
06:40:54 <aristid> ksf: well you could make it impossible to have an infinite one there
06:41:08 <ksf> or at least snatch the fixpoints out of the structure, put them in a graph and then determinise.
06:41:12 <yitz> aristid: are pipes pipes really as performant as conduit pipes, as claimed? and with all the real-life resourse control features?
06:41:52 <aristid> ksf: so it wouldn't be impossible to write a good analysable parsec combinator library, just that none of the popular ones do?
06:41:59 <aristid> yitz: i have not benchmarked it yet
06:41:59 <ksf> that'd be, in the end, regex syntax on steroids. dunno how well determinising and minimising works with an applicative instance, though.
06:42:20 <yitz> aristid: attoparsec is very highly optimised down to the bit-tweaking loop-unrolling level.
06:42:27 <ksf> was matching already a problem, or only backreferences?
06:42:34 <aristid> yitz: my pipe also does not use or need any resource management, so that wouldn't have an effect
06:42:58 <ksf> aristid, but the thing is, people wanting such parsers just use alex and/or happy.
06:42:59 <aristid> yitz: attoparsec is optimised at a low level, but it can't do any high-level optimizations
06:43:06 <yitz> ksf: trifecta is a very nice applicative parser, semantically. but said to be far slower than attoparsec.
06:43:17 <ksf> trifecta is monadic
06:43:26 <ksf> uu-parsinglib is very, very applicative.
06:43:34 <ksf> its monad instance is just an excuse.
06:43:40 <aristid> uu-parsinglib is also not fast though?
06:43:48 <yitz> no i don't think so
06:43:54 <ksf> I've never actually gotten around using it.
06:43:56 <yitz> i doubt it. that wasn't their goal.
06:44:12 <ksf> it has to be rather fast, at least better than parsec
06:44:20 <ksf> ...if you use the applicative interface.
06:44:27 <yitz> it is the product of a lot of research abuot auto-correcting parse errors
06:44:38 <aristid> ksf: does it do any kind of things that depend on static analysis?
06:44:58 <ksf> you don't need to auto-correct, though. if you don't query the correction list the whole thing is free.
06:45:27 <aristid> haha an autocorrecting parser must be an undergraduate's dream
06:45:34 <ksf> aristid, IIRC it does determisation a la ReadP
06:45:43 <yitz> ksf: yes but i'm pretty sure that was their main focus. you don't get attoparsec-like speed for free just because you are applicative.
06:45:56 <ksf> no, of course not.
06:46:06 <ksf> it's not assembly-fast. it's high-level fast.
06:46:11 <yitz> ksf: attoparsec has shoot-out-style really evil low-level optimisations
06:46:34 <ksf> and you have to feed it grammars basically in LR(1) or whatever it likes most.
06:47:02 <yitz> aristid: i think it's more a teaching assistant's dream.
06:47:16 <aristid> yitz: :)
06:47:28 <yitz> aristid: any student who can really figure out how to use it can also do the stupid homework
06:47:57 <aristid> yitz: i meant more like if the compiler used to grade their homework would have that ;)
06:48:06 <yitz> right :)
06:49:05 <ion> Does anyone know offhand how to give args to ghc -e 'do foo <- getArgs; …'?
06:49:14 <ion> The standard -- doesn’t work.
06:49:32 <yitz> ksf: until now, to get attoparsec's speed you also had to feed it grammars that it likes. i.e. grammar that avoid its backtracking bug.
06:49:49 <yitz> ksf: not sure what the relationship is between that space and LR(1) :)
06:50:01 <S_J> > 5 : [] : []
06:50:02 <lambdabot>   No instance for (GHC.Show.Show a0)
06:50:03 <lambdabot>    arising from a use of `M1166929785.sh...
06:50:07 <ksf> applicative, non-recursive parsers don't need to backtrack.
06:50:16 <S_J> > [] : []
06:50:17 <ksf> well, even recursive ones don't.
06:50:17 <lambdabot>   [[]]
06:50:24 <S_J> > [5] : []
06:50:26 <lambdabot>   [[5]]
06:50:29 <ksf> they're equivalent to DFAs with an infinite number of states.
06:50:31 <aristid> ksf: i don't know what "determisation a la ReadP" means and the documentation of ReadP doesn't tell me:(
06:50:33 <ion> > (5 : []) : []
06:50:34 <lambdabot>   [[5]]
06:50:37 <ksf> you can determinise them.
06:50:38 <S_J> > (5 : []) : []
06:50:40 <lambdabot>   [[5]]
06:50:47 <FreeFull> > [5] : [] : []
06:50:48 <lambdabot>   [[5],[]]
06:50:57 <ksf> aristid, a transformation akin to NFA->DFA
06:51:08 <ksf> collect alternatives and match them early. left-factor the whole thing.
06:51:23 <aristid> ksf: oh that thing, and it can be extended to something beyond regular languages?
06:51:25 <ksf> when it comes to fast parsing, there's also alternatives like packrat.
06:51:38 <ksf> well, yes. but it will blowup from time to time.
06:51:59 <aristid> hum
06:52:11 <ksf> If I recall the uulib tutorial paper correctly (and I might not), then the transformation has some borders it can't cross.
06:52:51 <ksf> the thing is, determinising an *infinite* deterministic automaton yields infinite states, again.
06:53:03 <aristid> ksf: perl proves that you can get away with high-level poor parsing :D
06:53:47 <aristid> ksf: might there not be a trick around that? like, get a stack machine or whatever?
06:54:29 <ksf> probably.
06:54:50 <ksf> I'd recommend reading the uu-parsinglib paper, I'm quite sure my memory is sketchy there.
06:55:00 <aristid> sounds like a good idea.
06:55:14 <yitz> Brüggemann-Klein, Anne, and Derick Wood. Deterministic Regular Languages. Universität Freiburg, Institut für Informatik, Bericht 38, Oktober 1991. Extended abstract in A. Finkel, M. Jantzen, Hrsg., STACS 1992, S. 173-184. Springer-Verlag, Berlin 1992. Lecture Notes in Computer Science 577
06:55:19 <ksf> http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
06:55:42 <aristid> i'm surprised that's not from utrecht:D
06:55:50 <jdoles> How can I keep this process running? createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
06:56:25 <ksf> aristid, while you're busy researching, you could also take a look at nested word automata.
06:56:44 <yitz> jdoles: make sure the code you run doesn't have any bugs?
06:57:00 <ksf> which are more powerful than DFAs, as determinisable, minimisable and comparable (but everything more complex and in higher complexity classes) but still not context free
06:57:05 <jdoles> yitz: are you saying that it is supposed to run to completion?
06:57:08 <ksf> they work fine for stuff like xml
06:57:35 <aristid> ksf: they would probably fail horribly for programming languages like haskell?:)
06:58:05 <ksf> haskell is inherently context-dependent due to the operator precedence stuff.
06:58:17 <ksf> but that's usually dealt with in a second pass.
06:59:10 <ksf> ...and O(n) space/ O(n) time operator parsing algorithms exist, after all, so it's not really a complexity explosion. it's tame, but just doesn't fit into the paradigm.
07:00:01 <arnsholt> Yeah. The Chomsky hierarchy isn't the only way to skin that particular cat
07:00:20 <yitz> jdoles: i was not completely serious, sorry. :) what meant was: what do you mean by "keep running"? what kind of stopping are you trying to prevent?
07:00:55 <arnsholt> And pretty much all programming languages are context sensitive in some way, I think. Like C requiring pre-declaration
07:01:05 * ksf realises he should hack up that function call parsing from the traditional shunting rail algorithm before banging his head against generalising the thing to distfix
07:01:15 <ksf> as f(x,y) *is* distfix.
07:01:27 <aristid> arnsholt: right, although that is commonly factored into subsequent passes
07:01:33 <augur> ksf: whats distfix
07:01:34 <ksf> _(_,_)
07:01:37 <ksf> mixfix.
07:01:42 <augur> oh. then use mixfix!
07:01:45 <prophile> arnsholt: I'd imagine quite a few dynamic languages aren't context sensitive
07:01:51 <yitz> ksf: the paper i referenced is the original work for sgml from the early 1990's. james clark's famous parser was based on that.
07:01:54 <prophile> due to the lack of symbol table juggling
07:01:56 <jdoles> yitz: I am observing: $ ./Main RET results in $ being displayed immediately, but it appears that it is working after all.
07:01:57 <augur> also, chart parsers! \o/
07:02:06 <augur> chart parsers are obviously the coolest parsers
07:02:17 <jdoles> yitz: I had expected the command to not return immedidately.
07:02:24 <arnsholt> prophile: Well, I don't know about Python, but I'm pretty sure Ruby isn't easily CFG-parseable, and Perl sure as hell isn't
07:02:30 <yitz> jdoles: ah ok. yes it returns immediately. you are creating a new OS thread.
07:02:48 <yitz> or process actually, not thread
07:02:51 <arnsholt> And Common Lisp is hard to parse as well, due to macros
07:03:59 <prophile> Python isn't context free due to the whitespace indentation
07:04:04 <prophile> but I think once that's preprocessed it is
07:04:09 <osfameron> why would macros make CL hard to parse?
07:04:20 <ksf> *shunting yard
07:04:24 <prophile> Ruby is famously almost impossible to parse
07:04:30 <ksf> though shunting yards involve shunting rails, I guess.
07:04:34 <osfameron> "only perl can parse Perl"
07:05:11 <yitz> osfameron: the first perl 6 parser was written in haskell
07:05:33 <arnsholt> osfameron: (foo ...) can be both a macro call and a function call
07:05:41 <augur> ksf: chart parsing > shunting yard algo
07:05:49 <geekosaur> perl 6 is much more regular than perl 5
07:06:18 <osfameron> arnsholt: sure, but isn't it parsed the same, and then macro-expanded?
07:06:35 <arnsholt> If it's a macro you need to invoke the Lisp code implementing the macro, which means that the rules describing the rest of the form can be completely arbitrary. It's essentially the same as only perl can parse Perl
07:06:40 <osfameron> yitz, geekosaur: yeah.  perl6 can be parsed by many things (including pugs in haskell)
07:07:06 <augur> also, not enough love is given to indexed grammars
07:07:07 <arnsholt> Pugs has a bit of trouble with the more dynamic aspects of Perl 6 parsing though, if memory serves
07:07:17 <ksf> augur, why would I use a polynomial algorithm when I don't need it?
07:07:32 <augur> ksf: cause its cooler, duh
07:07:42 <augur> everyone knows you choose your parsing algorithm by coolth
07:08:10 <aristid> true fact.
07:08:33 <geekosaur> I am not sure if that's because they're harder to do or because they were preliminary specs (most of which got heavily revised) and as such unimplemented
07:09:28 <geekosaur> keep in mind that a number of things got rewired specifically because pugs showed they were difficult in their original form. (but still not implemented, because it seems only one person actually understands pugs' source, sigh)
07:09:51 <aristid> lol.
07:10:20 <arnsholt> geekosaur: It's both I think. Some of the dynamic bits rely on being able to run Perl 6 code while parsing it, which isn't easy with Pugs as it stands (or at least that's my impression of it)
07:11:11 <arnsholt> osfameron: Oh, and you can have reader macros in Common Lisp as well, which means that you have to be able to run arbitrary Lisp code while lexing as well
07:13:33 <Peaker> ironic that Lisp is touted as having "no syntax", when in fact it has an unbounded amount of syntax
07:13:37 <osfameron> arnsholt: ah yes.  crazy stuff
07:13:51 <osfameron> of course that's not necessarily the same as "hard to parse"
07:13:57 <osfameron> more "hard for anything other than Lisp to parse"
07:14:20 * geekosaur hasn't done much CL, but remembers readmacros from maclisp... and yes, crazy stuff
07:17:03 <erisco> @src repeat
07:17:03 <lambdabot> repeat x = xs where xs = x : xs
07:18:06 <arnsholt> Peaker: Oh, definitely. It's superficially simple, but extremely complex when you actually start to dig into the meat of it
07:18:31 <erisco> let foo = 'a' // foo    in http://lpaste.net/90901 and why can't I take the head?
07:18:59 <arnsholt> osfameron: Depends on what you mean by hard to parse, I guess. CL is hard in pretty much the same way Perl is hard. To parse the language you need to also execute smaller programs written in the same language
07:19:41 <erisco> cdk, [(x, s-x) | s <- [0..], x <- [0..s]]   I didn't realize one source could parameterize the other :o
07:22:23 <S_J> > [ (x, x*x) | x <- [0..10]]
07:22:24 <lambdabot>   [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
07:23:38 <banister> is there a liftA3 too?
07:24:03 <banister> seems like it
07:24:07 <banister> what about liftA4 ? :P
07:24:27 <Eduard_Munteanu> Blargh... when is Haskell gonna get placeholders for types? I keep wishing to specify types partially.
07:24:28 <Peaker> banister, use f <$> x <*> y <*> z ... ad infinitum
07:24:39 <banister> Peaker: cool
07:24:44 <banister> of course ;)
07:24:55 <Peaker> Eduard_Munteanu, I use "Char" as a place-holder, then copy the type from the type error to replace Char :)
07:25:12 <Eduard_Munteanu> Hehe.
07:25:26 <elliott> () is a nicer placeholder than Char
07:25:39 <Peaker> elliott, yeah, I should use that :)
07:25:47 <elliott> because if it works your job is done :P
07:25:49 <elliott> and it's shorter, of course
07:26:15 <yitz> instance Applicative Char where .. -- make Peaker crazy
07:26:24 <Peaker> yitz, fortunately that's a kind error :)
07:26:35 <banister> Peaker: does this make sense to you? someone on another channel said this: "the problem with haskell is that monads do not compose, you cannot present a pure interface to the outside world while maintaining side-effectful one inside"
07:26:40 <Peaker> though sometimes I want multiple place holders then I also use: Int, Bool, etc so I can figure out which part of the error is which
07:26:43 <yitz> you're just lucky
07:27:32 <Peaker> banister, monads do not compose in certain ways (that's why we need & have monad transformers).  That has nothing to do with the second point, which is simply wrong (See the ST monad)
07:27:56 <banister> Peaker: so that guy is likely just confused? or is there a valid point in there somewhere just poorly expressed?
07:27:58 <Peaker> banister, we also have unsafePerformIO for presenting a pure interface to the world and having side-effectful one inside, but it's pretty rare
07:28:06 <Peaker> (that you need it)
07:28:21 <elliott> if there is a point in that line, it's buried deep down.
07:29:11 <Peaker> banister, My bet is that the guy is confused, because the former is technically correct in a way that cannot really be seen as a problem with Haskell and the latter is just wrong
07:29:25 <yitz> banister: applicatives compose pretty nicely. if that's not good enough and you really need the monad, then your operations inherently only compose in the way monads do, in any language.
07:29:44 <FreeFull> Well, instead of Monads you could use Effects, which are infinitely composable, but not as powerful as monad transformers
07:30:01 <jhance> Most people who think that monads are a problem with Haskell don't actually know Haskell very well.
07:30:29 <Peaker> FreeFull, but you've only gained convenience, not power -- since you could always use transformers for the same compositions
07:30:40 <banister> what book should one use to upgrade their haskell knowledge after finishing LYAH and RWH ?
07:30:41 <erisco> let foo = "a" // foo   with (//) = http://lpaste.net/90901  and why does  head foo  hang instead of returning 'a' ?
07:31:35 <jhance> banister: Write code
07:31:46 <Peaker> erisco, (//) is strict on both of its arguments
07:31:58 <Peaker> erisco, or rather, it's strict on second, at least
07:32:23 <erisco> Peaker, why doesn't the second also evaluate to 'a':foo  ?
07:32:25 <Peaker> erisco, so  foo = ? // foo     is strict on second arg and recurses infinitely just to try to see if "foo" is the empty list
07:33:14 <Peaker> erisco, basically the first pattern match tries to run "foo" enough to figure out if it's empty or not, so it does the same pattern match it's already in, which loops
07:33:38 <banister> jhance: out of curiosity, when people do async stuff in haskell do they use promises? or does haskell have something even more powerful?
07:33:57 <erisco> Peaker, oh, I see ... rather subtle to me
07:34:16 <yitz> banister: there's stm
07:34:39 <FreeFull> > let foo = 'a' : ("a" // foo) in foo
07:34:41 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
07:34:41 <lambdabot>              with actual ty...
07:35:13 <banister> yitz: ah cool, im very new to stm, but i always wonderd about this. If stm is supposed to roll back actions, how would it roll back actions that do destructive things like modify the file system or send emails etc?
07:35:29 <yitz> banister: exactly
07:35:30 <banister> yitz: o you just have to be careful not to put code like that in a transaction, or does haskell somehow prevent u doing that at all?
07:35:38 <erisco> Peaker, how might I define this function? is it not possible? the implications are too faint for me to rationalize this
07:35:41 <yitz> banister: the type system prevents it
07:35:49 <yitz> @google beautiful concurrency
07:35:51 <lambdabot> http://research.microsoft.com/pubs/74063/beautiful.pdf
07:35:51 <lambdabot> Title: Microsoft Research - Site Down
07:36:29 <yitz> banister: ^ see this paper, it's a great read
07:36:41 <banister> yitz: ah ok, but in a language like scala/clojure that also have stm in that case you have to just be careful?
07:36:54 <elliott> "Title: Microsoft Research - Site Down", hehe
07:37:05 <Peaker> erisco, http://lpaste.net/90901
07:37:18 <banister> yitz: link is broken :(
07:37:25 <yitz> awww]
07:37:27 <Peaker> erisco, that way the function is only left-strict, and not right-strict
07:37:47 <erisco> Peaker, oh, you have to explicitly cons the x before doing anything with the second arg?
07:37:53 <Peaker> erisco, because it only checks to see if left list is non-empty before producing "x : ..." and only then checks the second arg to produce the ...
07:37:58 <Peaker> erisco, exactly
07:38:10 <erisco> Peaker, I was kinda suspicious about that ... was hoping for some ghc magic I guess
07:39:46 <Peaker> erisco, GHC is of the opinion that it should not save your program from over-strictness..
07:39:56 <Peaker> erisco, so even if such magic is available, ghc will explicitly avoid it
07:39:57 <FreeFull> > let foo = 'a' : ("a" \\ foo) in foo
07:40:01 <lambdabot>   mueval-core: Time limit exceeded
07:40:01 <ParahSail1n> @ty (//)
07:40:01 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
07:40:16 <FreeFull> > let foo = 'a' : ("a" \\ foo) in head foo
07:40:17 <lambdabot>   'a'
07:40:25 <ParahSail1n> @ty (\\)
07:40:25 <erisco> Peaker, I suppose that is good if you are actively trying to force evaluation
07:40:25 <lambdabot> Eq a => [a] -> [a] -> [a]
07:40:36 <Peaker> erisco, if foo then [x] else [x,y]      could really be made into a lazier:  x : if foo then [] else [y]    but GHC own't do that
07:40:36 <FreeFull> > let foo = 'a' : ("a" \\ foo) in take 2 $ show foo
07:40:37 <lambdabot>   "\"a"
07:41:23 <Peaker> erisco, yeah, the strictness is part of the meaningful semantics of the program, so GHC doesn't want to get them more refined.. the good reason is that the other side of this coin is that if some optimization breaks, suddenly your program is not slower by a constant factor but less refined and crashes on certain inputs
07:41:40 <Peaker> (or hangs)
07:42:32 <erisco> I ended up writing    (x:xs) // ys = x:ys' where ys' = fst . splitAt 1 $ ys
07:42:39 <Eduard_Munteanu> Mm, this is a bit of a downside to camelcase... one-word names look too local.
07:43:01 <Eduard_Munteanu> Maybe it's just me.
07:43:14 <yitz> Eduard_Munteanu: use theThing instead of thing
07:43:39 <aristid> yitz: ugh :P
07:43:50 <Peaker> erisco, what about the recursive invocation?
07:43:54 <Eduard_Munteanu> yitz: hm, nice, thanks. (Although it may be a bit inconsistent if multi-word stuff doesn't contain the "the")
07:44:21 <erisco> Peaker, oh, durr :)
07:44:30 <Eduard_Munteanu> What do you use for plural stuff... themThings? :)
07:44:38 <erisco> I fell asleep there I guess
07:44:48 <yitz> Eduard_Munteanu: as aristid points out this is all a matter of taste. :)
07:45:08 <yitz> theThings
07:45:18 <yitz> then there is myThing and myThings
07:45:30 <aristid> don't forget yourThing
07:45:32 <yitz> and thing' (not sure if that one helps you)
07:45:46 <aristid> perhaps ourThing? to create a sense of unification with the reader.
07:45:49 <yitz> aristid: as in: do yourThing
07:48:02 <erisco> Peaker, interestingly, a non-strict first argument appears impossible ... left recursion is a bitch =\
07:49:31 <zvrba> what is the "forall a." part in some types?
07:49:45 <zvrba> (e.g. runST(
07:50:11 <erisco> zvrba, variable type scopes ... 'a' becomes a scoped type variable
07:50:39 <aristid> zvrba: whenever you have a type with lower-case letters, there is an implicit forall. but runST needs a different scoping than the default.
07:50:47 <aristid> :t runST
07:50:48 <lambdabot> (forall s. ST s a) -> a
07:50:49 <zvrba> oh, ok.
07:51:07 <zvrba> but s appears only once, why does scoping matter?
07:51:29 <aristid> because the point is that the ST value must not be able to choose the valye of s
07:51:32 <yitz> zvrba: the a can represent any type. it makes it impossible for you to create anything tha will work as that parameter. you are forced to use runST, therefore cannot crash your program.
07:51:36 <aristid> if it could, it could leak resources
07:52:30 <FreeFull> :t newSTRef
07:52:31 <lambdabot> a -> ST s (STRef s a)
07:53:03 <FreeFull> zvrba: The type signature disallows an STRef from existing outside of the ST monad
07:53:34 <aristid> or even in another ST monad
07:53:34 <zvrba> I still don't get it.
07:53:40 <zvrba> what does forall do.
07:53:41 <aristid> it has to be in that particular runST
07:53:51 <zvrba> oh
07:54:31 <aristid> runST (newSTref 4) does not typecheck.
07:54:40 <aristid> :t runST (newSTRef 4)
07:54:41 <lambdabot>     Couldn't match type `a' with `STRef s Integer'
07:54:41 <lambdabot>       `a' is a rigid type variable bound by
07:54:41 <lambdabot>           the inferred type of it :: a at Top level
07:54:57 <zvrba> what would typecheck?
07:55:25 <yitz> zvrba: you can't possibly create anything yourself that will satisfy that type. but the ST library has a private less general version that it uses internally. this prevents you from being able to segfault.
07:55:41 <zvrba> oh
07:55:44 <aristid> zvrba: something that does not return a STRef, basically.
07:55:52 <FreeFull> zvrba: foralls tend to be implicit
07:55:56 <FreeFull> But have to be explicit sometimes
07:56:00 <zvrba> so newSTRef is usable only within the ST monad?
07:56:11 <yitz> exactly
07:56:21 <aristid> the full type of runST, with all foralls made explicit is forall a. (forall s. ST s a) -> a
07:56:29 <Peaker> erisco, is my solution not correct?
07:56:51 <namoamitabuddha> forall?
07:56:53 <namoamitabuddha> coq?
07:57:04 <aristid> namoamitabuddha: ?
07:57:12 <Peaker> erisco, you could be strict on right arg instead of left arg, I think
07:57:18 <namoamitabuddha> aristid: Which type system are you using?
07:57:23 <aristid> namoamitabuddha: haskell.
07:57:36 <aristid> maybe with -XExplicitForall or so
07:57:41 <zvrba> on another note: has anybody successfully used IntelliJ with haskell plugin on Win8 ? (64-bit)
07:57:48 <erisco> Peaker, your solution is fine. I am just pointing out, for interest sake, that a non-strict left arg doesn't seem possible
07:57:55 <Peaker> erisco, let me try
07:57:57 <namoamitabuddha> Well, sorry for my ignorance.
07:58:11 <erisco> Peaker, since the first thing you have to return is the head of the left arg, and if the left arg recurses... you can't find the head
07:58:44 <Peaker> erisco, you can return a (:) before looking at left arg though
07:58:58 <FreeFull> > let x = [head x] in x
07:59:02 <lambdabot>   mueval-core: Time limit exceeded
07:59:05 <erisco> Peaker, I don't know what you mean. I guess you'll have to show me
07:59:10 <yitz> namoamita: you are right that it is not part of haskell 98 or haskell 2010. but ghc uses it all the time.
07:59:24 <Peaker> erisco, but it is inherent that to know the first element of the result you do need to be strict on the left arg.  to know if the list is empty, however, you do not
07:59:38 <prophile> @hoogle (Monad m, Comonad w) => w (m a) -> m (w a)
07:59:39 <lambdabot> Warning: Unknown class Comonad
07:59:39 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
07:59:39 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:59:53 <erisco> Peaker, really? how do you test if it is empty?
08:00:02 <Peaker> erisco, writing it down
08:01:25 <FreeFull> prophile: I don't think a function of that type signature can exist
08:01:48 <Peaker> erisco, http://lpaste.net/90901
08:01:50 <namoamitabuddha> yitz: Is there any "exists"? It's not part of intuitionism.
08:02:00 <Peaker> erisco, this is terribly ugly :-)
08:02:13 <namoamitabuddha> yitz: However, haskell supports for call/cc, which is not part of intuitionistic logic.
08:02:20 <Peaker> erisco, but basically, if you see that right-arg is non-empty, you can know that result isn't empty
08:02:43 <klrr__> what is pipes?
08:02:48 <klrr__> what is pipes?
08:03:02 <aristid> @hackage pipes
08:03:02 <lambdabot> http://hackage.haskell.org/package/pipes
08:03:03 <banister> klrr__: why did you type the same thing twice in a row?
08:03:17 <aristid> klrr__: why did you type the same thing twice in a row?
08:03:19 <Peaker> erisco, so you can return (l : r).  l and r are both strict on left-arg, because knowing the content depends on left arg. But knowing the list is not empty can be left-lazy
08:03:23 <klrr__> banister: i sent the first message before i was connected
08:03:29 <banister> are pipes like go channels?
08:03:30 <klrr__> so i wasent sure if it got to the channel
08:03:38 <banister> i mean, you can build a mechanism like go channels on top of pipes?
08:03:51 <erisco> Peaker, interesting. huh
08:04:05 <Peaker> banister, Control.Concurrent.Chan's are like go channels
08:04:18 <Peaker> banister, pipes-concurrency is supposed to do something like that too
08:04:49 <banister> Peaker: is that the recommended way to solve the kind of problem that go channels solves, or does idiomatic haskell use something else?
08:05:02 <erisco> Peaker, I think I'll be able to use what you've shown me to fix the right-strictness on another function too
08:05:36 <Peaker> banister, I think Control.Concurrent.Chan is roughly the same as a go channel.  Haskell has a lot of tools to solve such problems, whereas Go has only a few
08:05:49 <hpc> and go's tools are baked in
08:05:50 <Peaker> banister, so idiomatic Haskell doesn't dictate a certain solution, I don't think. it allows for use of Chan
08:06:28 <Peaker> erisco, I recently had to do this kind of trickery to fix the "pretty" package. I fixed a bunch of strictness bugs, but didn't have time to solve them all
08:06:55 <FreeFull> Haskell also has STM and some parallel stuff
08:07:00 <erisco> Peaker, is it worth having the left arg be as lazy as possible?
08:07:13 <lelf`> Eduard_Munteanu: ghc7.7+ has -XTypeHoles
08:07:14 <erisco> for the cost of extra code?
08:07:36 <Peaker> erisco, in this case, probably not, since you become more strict on the right arg, and over-all this solution is more strict
08:08:00 <jmcarthur> new idiom i just made up and kind of like.   id $ do {..}  -- to constrain the scope of whatever variables i bind inside, within a larger do block
08:08:16 <Peaker> erisco, and whether extra code/complexity is worth it to gain more laziness is a question of trade-offs.  Also, there's a package called "lub" that lets you get the maximal laziness of two equal functions
08:08:38 <yitz> namoamita: you are right. but having forall is actually enough to be able to get existentials also.
08:08:49 <Peaker> I'm not sure why it's a "least upper bound" or what that wording even means..
08:09:00 <yitz> namoamita: here is a nice explanation: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
08:09:27 <hpc> jmcarthur: at that point i would expect a new function
08:09:42 <erisco> Peaker, hmm, well, hopefully I don't need to go that far because such concepts are still over my head
08:09:43 <bitonic> namoamitabuddha: what do you mean with “‘exists’ is part of intuitionistic logic”?
08:09:46 <bitonic> *is not
08:10:08 <Peaker> erisco, I doubt they're over your head.. the idea is to try to evaluate two things in parallel and take the one that finished successfully, if one did
08:10:08 <jmcarthur> hpc: it has a few free variables and makes the most sense in context (this is using a C lib)
08:10:11 <namoamitabuddha> bitonic: It's.
08:10:23 <hpc> Peaker: it's called lub because bottoms are ordered
08:10:25 * hpc finds a link
08:10:28 <augur> namoamitabuddha: you say it's not part of intuitionism. why do you say this?
08:10:31 <erisco> Peaker, oh, okay. I wasn't sure how different it was from unamb
08:10:31 <yitz> jmcarthur: without the id the variable names can leak out? how?
08:10:34 <bitonic> namoamitabuddha: eh?
08:10:42 <jmcarthur> yitz: oh, maybe just a nested do block is enough
08:10:43 <Peaker> erisco, it's built on top of unamb
08:10:45 <Cale> bottoms are the bottoms of a certain order :)
08:10:48 <jmcarthur> yitz: that's just not something i've ever done
08:10:57 <jmcarthur> yitz: you are right
08:11:07 <jmcarthur> no id is necessary
08:11:16 <namoamitabuddha> bitonic: I mean, nonconstructive existence, maybe. I'm not familiar with that theory.
08:11:23 <Peaker> erisco, basically "flatLub = unamb" and then instance of "HasLub" do the lub'ing recursively on their fields
08:12:07 <hpc> Peaker: http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/ - http://blog.ezyang.com/2010/12/gin-and-monotonic/ - http://blog.ezyang.com/2010/12/getting-a-fix-on-fixpoints/
08:12:10 <bitonic> namoamitabuddha: ?  surely in a constructive logic you’ll have constructive exists
08:12:15 <augur> namoamitabuddha: obviously non-constructive claims are generally not part of contemporary intuitionism, but lots of existential claims are constructive
08:12:27 <Cale> Each type is partially ordered by definedness, the intuition being that x <= y if y can be obtained from x by substitution of appropriate values for each of the occurrences of _|_ in x.
08:12:55 <bitonic> namoamitabuddha: existence is different in an intuitionistic setting, but then negation is too
08:12:55 <Cale> Every definable function preserves this ordering.
08:12:58 <hpc> Peaker: that last link has a good diagram for intuiting why fix finds "least fixed points"
08:13:02 <namoamitabuddha> augur: Yes, so I was certainly wrong. It's not a channel to discuss logic.
08:13:03 <bitonic> or disjunction
08:13:21 <Peaker> hpc, I understand least-fixed-point, I don't understand least-upper-bound
08:13:26 <hpc> you should be able to visualize what a least upper bound would look like (and hopefully also why it somewhat breaks the rules of haskell evaluation)
08:13:26 <augur> namoamitabuddha: we talk about logic plenty :)
08:13:58 <FreeFull> > iterate cos 1
08:13:59 <lambdabot>   [1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.79348035874...
08:14:24 <klrr__> what is pipes used for?
08:14:44 <Cale> That is to say, if y can be obtained from x by substituting occurrences of _|_ in x with certain values, then f y has to be obtainable from f x by substituting certain values for each occurrence of _|_ in f x
08:14:44 <wallmani> > iterate sin 0
08:14:45 <lambdabot>   [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0....
08:14:51 <Peaker> hpc, why is it "least" upper bound, and not "most" upper bound?
08:15:01 <aristid> klrr__: streaming I/O, mostly.
08:15:22 <klrr__> aristid: streaming I/O? have to duckduckgo that
08:15:36 <namoamitabuddha> augur: I think, when there's nothing important carried on, everything somewhat off-topic but related is okay.
08:15:43 <aristid> klrr__: it's inspired by unix pipes.
08:15:44 <hpc> Peaker: an "upper bound" of S is a value greater or equal to all elements of S; the least upper bound is the smallest of those values
08:15:48 <klrr__> what is streaming IO?
08:15:52 <hpc> which in this case, is the maximum of S
08:16:02 <hpc> for lub, S = the parameters you pass to lub
08:16:08 <Peaker> hpc, oh, I understand, thanks
08:16:13 <klrr__> aristid: aah, so how are they useful?
08:16:15 <hpc> (or lubs)
08:16:20 <aristid> klrr__: it's just about streams of data... like a file, or the output of a process, or a random number generator...
08:16:26 <Cale> Evaluation of an expression can be seen as picking a value in a type by starting at _|_ and moving upward along some path which picks out more and more defined values.
08:16:32 <namoamitabuddha> lubs?
08:16:33 <aristid> klrr__: i suggest you read the pipes tutorial.
08:17:07 <aristid> unamb is evil.
08:17:11 <hpc> namoamitabuddha: essentially, (foldr lub undefined)
08:17:18 <klrr__> aristid: before i read it i wanna know if it's even worth learning, it's hard to figure out how it would be useful
08:17:19 <v4hn> Hm, looks like there is no ghc version which got tested with llvm 3.3
08:17:29 <aristid> klrr__: then don't read it *shrug*
08:17:55 <aristid> klrr__: why did you ask about pipes in the first place?
08:18:26 <hpc> this reminds me of why i love that Ordering is a monoid; we should have a Defined monoid that uses lub under the hood
08:18:29 <klrr__> aristid: since i found it, and i wonder what it was, i was told it was like unix pipes, and now im wondering if they're useful, if they are, i might try to learn more about them
08:18:29 <Cale> klrr__: tbh, I haven't seen an iteratee library (of which pipes is an example) which I have actually really liked. Pipes is perhaps the prettiest example, but it's still a somewhat awkward fit for Haskell's type system.
08:18:44 <jmcarthur> klrr__: there are two things to realize in order to see what the use for something like pipes is
08:18:55 <aristid> Cale: pipes 4.0 is a bit better than what is currently on hackage. you should have a look:)
08:19:11 <jmcarthur> klrr__: first, lazy IO is "bad" for some things, such as when you really care about when some effects happen, when resources, are closed, etc.
08:19:17 <Cale> aristid: Where can I find that if not on Hackage?
08:19:20 <aristid> Cale: he got rid of proxy transformers.
08:19:22 <aristid> Cale: github.
08:19:33 <klrr__> aa, pipes are a replacement for the current IO implementation?
08:19:37 <aristid> klrr__: no.
08:19:39 <jmcarthur> klrr__: second, when you switch to strict IO naively, you end up having to write much more imperative looking code and have a lot more trouble making it composable
08:19:49 <aristid> it is a layer on top that makes writing some programs easier.
08:19:56 <klrr__> ok
08:19:59 <jmcarthur> klrr__: libraries like pipes are intended to make strict IO more sane to use by adding some kind of composability
08:20:10 <klrr__> so it's useful for making IO code be written in a better way?
08:20:23 <Cale> Every library I've seen for doing this kind of thing ends up in type parameter hell.
08:20:25 <jmcarthur> that is the intent. whether it achieves this is up for debate
08:20:36 <klrr__> i think this sounds interesting
08:20:43 <hpc> Cale: that's just because edwardk is the one writing those libraries
08:20:44 <hpc> ;)
08:20:44 <aristid> Cale: he also got rid of the silly Proxy typeclass, there is just one implementation now, so ProxyCorrect is gone.
08:20:45 * hackagebot data-ref 0.0 - Unify STRef and IORef in plain Haskell 98  http://hackage.haskell.org/package/data-ref-0.0 (HenningThielemann)
08:20:54 <Cale> I think a dependently typed language would be able to do a much better job
08:21:03 <haasn> the only iteratee library edwardk has written doesn't have type parameter hell
08:21:17 <haasn> it's generalized to the point where you provide the type parameter hell yourself
08:21:20 <haasn> as end user
08:21:20 <aristid> haasn: do you understand it? :)
08:21:27 <jmcarthur> Cale: how do you think dependent types would help?
08:21:27 <hpc> hahaha
08:22:06 <aristid> dependent types clearly add expressiveness, but i think it will take a while until dependently typed languages are actually in usable shape.
08:22:13 <Peaker> aristid, why is unamb evil?
08:22:15 <hpc> jmcarthur: in agda at least, lots of parameter passing can be replaced with implicit type parameters
08:22:26 <jmcarthur> hpc: sure, but that isn't really specific to dependent types
08:22:51 <Peaker> Cale, do you dislike lens because of "type parameter hell" too?
08:23:00 <Cale> Not even if things are implicit, but even just things like type level tuples and various operations on those
08:23:16 <Cale> Peaker: ehh, it doesn't get *quite* as bad
08:23:24 <Peaker> LensLike f s t a b
08:23:25 <aristid> Peaker: i'm not sure, it feels a bit like breaking the language semantics to me
08:23:27 <Cale> Peaker: There are places where it's kind of rough
08:23:47 <elliott> unamb is impure. so there's that.
08:23:49 <hpc> Peaker: you know you are screwed when your type parameters are "a" and "b" ;)
08:23:53 <Peaker> Cale, the naming of the variables and their positions are consistent, so it's not too bad. I haven't used pipes/conduits much but I suspect it can be OK there too
08:24:03 <jmcarthur> aristid: the main reason i dislike unamb is just that there is an unchecked proof obligation to use it
08:24:08 <Cale> (/>/) :: (Monad m, Proxy p) => (a -> p x' x b' b m a') -> (b -> p x' x c' c m b') -> a -> p x' x c' c m a'
08:24:12 <Cale> ^^ this is what I mean
08:24:13 <Peaker> hpc, I disagree, I like lens' naming by now :)
08:24:45 <hpc> Cale: "p x' x c' c m a'" -- that's one type, sweet jebus
08:25:00 <Cale> I *understand* what's going on there, but I still don't like it.
08:25:22 <aristid> well i fear it's not possible to do much better within the confines of haskell
08:25:25 <Cale> We need a more expressive way to represent these collections of types and manipulate them.
08:25:39 <Peaker> Cale, it could probably use a nicer naming scheme to get rid of the irregular apostrophes, that would help a bit
08:26:01 <hpc> Peaker: that doesn't solve the fact that p is taking 6 parameters :P
08:26:34 <aristid> hpc: for common uses, there are type synonyms that could it down to 4 :)
08:26:44 <aristid> Pipe s t m a
08:27:06 <Peaker> another possibility is using type-level phantom-type pairs like:   data Upstream i o   type instance In (Upstream i o) = i ; type instance Out (Upstream i o) = o ;   and same for downstream, and then:   Proxy p => p up down m a
08:27:18 <jmcarthur> one could use some type operators to make some of it more clear, visually
08:27:30 <jmcarthur> Proxy (a <-< b) (c >-> d) m e
08:27:44 <v4hn> Ah, the ghc build also fails with llvm 3.3 ...
08:28:06 <Peaker> jmcarthur, that's a nice idea :)
08:28:15 <Peaker> jmcarthur, Tekmo should do that
08:28:24 <jmcarthur> ^^ a and b flow upstream, b comes in from the right, a leaves to the left. c and d flow downstream, c comes in from the left and d leaves on the right. etc.
08:28:33 <aristid> first he should finish up pipes 4.0 and upload it to hackage tho :)
08:29:27 <Cale> jmcarthur: and then some type-level functions to pick out the components of (a <-< b) perhaps
08:29:35 <jmcarthur> yeah something like that
08:29:50 <Cale> So, TypeFamilies might be able to help some
08:30:44 <elliott> iirc that approach isn't viable atm
08:30:56 <elliott> edwardk wamted it for lens
08:31:25 <S_J> How long does it take to build ghc?
08:31:45 <jmcarthur> S_J: depends on your machines. i think for most people it's around 30 minutes or so
08:31:52 <jmcarthur> *machine
08:32:51 <hpc> mine takes an hour with a gig of ram and a 1.6ghz core2 laptop cpu
08:32:56 <jmcarthur> it's set up to be compatible with -j, so if you have multiple cores you can use that to speed it up considerably
08:34:28 <elliott> hpc: wtf, it takes me three hours with four times the RAM and a better CPU
08:34:49 <elliott> though that was without -j
08:35:07 <aristid> elliott: sounds like you have the mistake right there:)
08:35:44 <hpc> elliott: mine was without -j too
08:35:53 <hpc> that's weird
08:36:46 <aristid> i never measured how long it takes to compile ghc :/
08:36:55 * geekosaur wonders if it could be ld
08:37:05 <ab9rf> don't you instrument everything you do, aristid? :)
08:37:11 <aristid> ab9rf: no! :(
08:39:44 <hpc> geekosaur: possibly; i forget if i was using ld or gold at the time
08:41:40 <Eduard_Munteanu> Damn, async is annoying... API doesn't let me pass the Async to the spawned job itself.
08:42:16 * Eduard_Munteanu should write an MVar wrapper
08:42:29 <Eduard_Munteanu> *MVar-based wrapper for that
08:54:12 <jmcarthur> Eduard_Munteanu: you mean you want the Async to use itself in its own job?
08:54:24 <jmcarthur> Eduard_Munteanu: couldn't you just use mfix/dorec/mdo for that?
08:54:34 <pastello> hi
08:54:50 <applicative> would anything happen if the waiting for the Async was inside itself so to say?
08:54:54 <applicative> hi pastello
08:55:10 <jmcarthur> applicative: it would probably never finish
08:55:19 <jmcarthur> applicative: well...
08:55:37 <jmcarthur> applicative: that's not true. it could spawn another async job that does that waiting or something
08:55:56 <applicative> I was sort of wondering if wait x was what really made things happen. or whatever its called, 'wait'
08:56:30 <jmcarthur> applicative: no, wait doesn't actually trigger anything to happen. it just tries to read the underlying TMVar. the job is already forkIOed
08:56:33 <applicative> so that a <- async blah ; .. wasn't like id_ <- forkIO blah
08:56:45 <applicative> oh okay
08:56:51 * applicative hasn't looked lately...
08:56:53 <jmcarthur> async is where the magic happens
08:56:59 <pastello> :O
08:57:23 <applicative> yes, that was my question, "Is async or wait where the magic happens?'
08:57:58 <jmcarthur> woot! got my first rendering from freetype
09:05:25 <Svedrin> hi there. I'm currently learning haskell using the wikibook, and one of the tasks they give you is writing a run length encoder. as part of the decoder, I'm trying to write a function that turns a string like "a2b4c1" into a list like [('a', 2), ('b', 4), ('c', 1)]
09:05:37 <Svedrin> I got this far currently: http://pastebin.com/aFcXd7bX
09:05:39 <mauke> The paste aFcXd7bX has been copied to http://lpaste.net/90905
09:06:14 <Svedrin> I've had it working before, but storing stuff to /tmp turns out to be not such a good idea™... anyway, what does the compiler try to tell me? :/
09:07:05 <srhb> Svedrin: First off, you seem to say that your function takes a String (or [Char]) as its argument
09:07:32 <Svedrin> srhb, yup
09:07:36 <srhb> Svedrin: However, in the first line of its equation, you have (chr1, chr2) which cannot possibly be a String, because it's a tuple.
09:08:17 <srhb> Svedrin: So you're a liar. :-(
09:08:24 <Svedrin> :D
09:09:07 <Svedrin> okay, so I kinda hoped that something would figure out I wanted to match a string of length 2 there
09:09:16 <Svedrin> how do I do that then?
09:09:26 <applicative> f [a,b] = z
09:09:27 <srhb> [a,b]
09:09:36 <srhb> A list of two elements, (here a list of Char)
09:09:37 <applicative> f (a:b:[]) = z
09:10:04 <applicative> so you really just need the second line, and a decision about singleton and empty cases
09:10:34 <Svedrin> srhb, yup that works :)
09:10:37 <applicative> groups_of_two [] = []; groups_of_two [x] = []
09:11:37 <Xaseron> Warning: Main: could not find link destinations for:
09:11:39 <Xaseron>     GHC.Types.IO
09:11:43 <Xaseron> how can i fix this?
09:11:44 <Svedrin> applicative, I'd have to add proper error checking, at least for the singleton case... that would be malformed input
09:12:17 <applicative> yes there's not much point in deciding all cases while you're using 'read' ...
09:13:09 <srhb> I don't even understand what that read is supposed to do.
09:13:17 <cdk> @src ap
09:13:18 <lambdabot> ap = liftM2 id
09:13:46 <Svedrin> srhb, the input string looks like "a2b5", and the read turns the "5" into 5
09:13:52 <srhb> Ah.
09:14:47 <Xaseron> which parameter does haddock need to find GHC.Types.IO?
09:16:15 <applicative> Xaseron: this is haddock warning, I wonder why it's trying to find GHC.Types; usually it links to System.IO
09:16:35 <applicative> that is, to System.IO.IO
09:16:37 <applicative> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/System-IO.html#t:IO
09:17:08 <S_J> Cooking question: if minced beef is within the date limit but somewhat brown in a few places (underneath), is it ok to cook and eat?
09:17:35 <geekosaur> probably best asked in -blah
09:18:39 <srhb> (Also, yes, the brown color is caused by oxidation of the myosin groups)
09:18:45 <geekosaur> (that said: the bright red outer part is artificial, meat naturally oxidizes to brownish within a couple hours of exposure to air.)
09:19:16 * applicative has the suspicion that all of this is really coded talk about perl
09:19:40 <Croms> Why does a type signature containing [a] fail when you pass it an empty list, but [Int] doesn't?
09:19:46 <srhb> What?
09:19:59 <applicative> it doesn't matter if a list is empty or not
09:20:18 <applicative> @type reverse
09:20:19 <lambdabot> [a] -> [a]
09:20:23 <applicative> > reverse []
09:20:25 <lambdabot>   []
09:20:43 <Eduard_Munteanu> How do you match the start of a line in attoparsec?
09:20:49 <sipa> :t reverse []
09:20:50 <lambdabot> [a]
09:20:50 <applicative> Is something like the monomorphism restriction involved, I wonder, Croms
09:21:11 <applicative> Croms: what is the 'failure' like?
09:22:10 <applicative> > tail [undefined]
09:22:11 <lambdabot>   []
09:23:31 <applicative> grr. i managed to extract the 'idiom brackets' machinery from the she preprocessor, but I mustn't understand how -F -pgmF blah works
09:24:13 <zvrba> how to lift the following into the IO monad: (unlines . map (show . throwDice . parseNM) . lines)
09:24:25 <zvrba> here, throwDice is IO [Int], everything else are regular values
09:24:34 <Croms> applicative: It's a simple replication of the max function. I set its type sig to "(Ord a) => [a] -> a". Giving it an empty list results in "No instance for (Ord a0) arising from a use of `max''". The thing works with "[Int] -> Int".
09:24:37 <applicative> it emits the correctly preprocessed material but then ghci fails with exception 'Prelude.head'
09:25:09 <Eduard_Munteanu> zvrba: start with the inner composition chain... you're feed IO [Int] to show.
09:25:13 <Eduard_Munteanu> *feeding
09:25:28 <applicative> just a sec Croms
09:25:43 <Eduard_Munteanu> zvrba: do you want to show the result [Int]?
09:26:00 <jmcarthur> :t map (show . f)
09:26:01 <lambdabot>     Could not deduce (Show b0) arising from a use of `show'
09:26:01 <lambdabot>     from the context (Show a)
09:26:01 <zvrba> well, I input a list of lines, process them [generate some random numbers] and want to output the results
09:26:01 <lambdabot>       bound by the inferred type of it :: Show a => [a] -> [String]
09:26:04 <zvrba> Eduard_Munteanu: yes.
09:26:09 <jmcarthur> :t \f -> map (show . f)
09:26:09 <lambdabot> Show b => (a -> b) -> [a] -> [String]
09:26:15 <jmcarthur> :t \f -> mapM (show <=< f)
09:26:16 <lambdabot> Show b => (a -> [b]) -> [a] -> [[Char]]
09:26:26 <jmcarthur> derp
09:26:31 <jmcarthur> :t \f -> mapM (liftM show . f)
09:26:32 <lambdabot> (Monad m, Show a1) => (a -> m a1) -> [a] -> m [String]
09:26:33 <sipa> :t ord []
09:26:34 <lambdabot>     Couldn't match expected type `Char' with actual type `[a0]'
09:26:34 <lambdabot>     In the first argument of `ord', namely `[]'
09:26:34 <lambdabot>     In the expression: ord []
09:27:22 <Eduard_Munteanu> zvrba: in general, do you know how given an "IO a" computation you process the result with a pure function?
09:27:33 <geekosaur> Croms: at a guess, since it has nothing witha Num instance defaulting doesn't kick in, so it can't infer a concrete type. (with extended defaulting it'll infer () which IIRC has a (useless) Ord instance)
09:27:46 <zvrba> Eduard_Munteanu: I can put it into do, or use fmap or lift
09:28:06 <Eduard_Munteanu> zvrba: right, same thing here basically
09:28:24 <zvrba> so I should just give up on the composition and spell it out in do maybe..?
09:28:37 <Eduard_Munteanu> fmap show (throwDice . parseNM)
09:28:43 <applicative> Croms: yes, I think inside ghci it should default to [()] if you give it the empty list
09:28:51 <Eduard_Munteanu> Err.
09:29:36 <Eduard_Munteanu> show =<< (throwDice . parseNM) ...
09:29:40 <zvrba> ah, but show cannot under any circumstances show IO a ...
09:29:41 <applicative> Croms: when do you get the error, max' is defined in a file? and max' [] fails in ghci?
09:29:46 <zvrba> it wants a pure value
09:29:47 * Eduard_Munteanu is stupid
09:29:56 <Eduard_Munteanu> return . show =<< (throwDice . parseNM) ...
09:30:26 <zvrba> but can I feed IO [Int] to show ?
09:30:45 <applicative> you want to SEE the action itself
09:30:54 <Eduard_Munteanu> zvrba: nope, you bind it towards show
09:31:06 <zvrba> ah!
09:31:21 <mikeplus64> :t fmap
09:31:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:31:33 <mikeplus64> zvrba: you can also use that, replace the f there with IO
09:31:34 <Eduard_Munteanu> :t (<=<)
09:31:35 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
09:32:07 <Eduard_Munteanu> You can write this stuff with (<=<) and (.)
09:32:54 <zvrba> blargh. it's getting more convoluted than elegant now.
09:32:58 * zvrba writes it out in do
09:33:30 <Croms> applicative: I run it through runghc.
09:34:00 <Croms> applicative: Weird, works fine in ghci.
09:34:24 <geekosaur> ghci has extended defaulting, runghc I think should not
09:34:34 <geekosaur> lthough you can enable it (-XExtendedDefaultRules)
09:34:55 <Croms> Checkin'.
09:36:09 <Croms> Works now in runghc too. Thanks guys, you're awesome.
09:36:53 <mikeplus64> zvrba: each to their own. i usually only go as far as to use fmap - eventually you just find it natural to use (whereas e.g. <=< and >=> i've not often used at all)
09:56:20 <cdk> if you're working with a lot of monads, (>=>) is as natural as (.)
09:56:40 <Demos> I would call that two keystrokes less natural...
09:57:25 <cdk> i wasnt aware we were talking about keystrokes, moreso how succinct and natural it is to read
09:59:10 <Demos> hm I suppose
10:00:51 <cdk> compare "doWork action handler input = action input >>= handler" to "doWork action handler = action >=> handler"
10:01:15 <cdk> i guess in that case, doWork = (>=>) anyways, so its a bit contrived
10:03:14 <notdan> So what pipe/conduit/iteratee library would you recommend if I plan on working with sockets extensively?
10:08:02 <bitonic> da
10:08:06 <bitonic> oops.  sorry
10:09:13 <dwcook> Da, tovarish.
10:32:57 <Demos> OoO that feeling when code typechecks for the first time :D
10:34:56 <FreeFull> Demos: Does it work?
10:34:59 <cjay> it compiles, let's ship it
10:36:37 <Demos> shipit
10:37:13 <Demos> hm anyone know how I can get ghci's tab completion working on windows?
10:38:49 <Demos> yes it seems to work!
10:40:21 <Demos> is never ceases to amaze how often my code is correct when it compiles
10:40:48 * hackagebot zeromq3-haskell 0.5 - Bindings to ZeroMQ 3.x  http://hackage.haskell.org/package/zeromq3-haskell-0.5 (ToralfWittner)
10:45:57 <jozefg> Hello
10:47:16 <mizu_no_oto> I'm currently trying to cabal install uuid on my mac, and I'm getting the error "unix-2.6.0.1 failed during the configure step. The exception was:  ExitFailure 127"
10:53:08 <geekosaur> mizu_no_oto, it should not be trying to build unix if you have the haskell platform installed. (if you absolutely must do this, use cabal-dev or hsenv, and we'd need to see output from cabal install -v)
11:01:57 <jozefg> is Data.Generics.Schemes still a common way to do syb style generic programming?
11:12:28 <Peaker> elliott, reading backlog, why is the (>->) approach not viable?
11:12:46 <elliott> you'd have to ask edwardk
11:12:51 <elliott> I think it was to do with the annoying Any stuff
11:12:58 <Peaker> Monoid.Any?
11:14:35 <elliott> no
11:14:37 <elliott> the GHC Any
11:14:42 <elliott> it inhabits every kind
11:14:47 <elliott> like a _|_ you can pattern match on or whatever
11:15:38 <Eduard_Munteanu> How do you combine two attoparsec Parsers such that they only consume the input and return nothing?
11:15:48 <Peaker> elliott, ah, I don't know "the annoying Any stuff"
11:16:11 <Peaker> Eduard_Munteanu, () <$ (a *> b) ?
11:16:31 <Peaker> or  do { a ; b ; return () } ?
11:16:52 <Peaker> or are you worried about not accumulating memory before returning nothing?
11:17:01 <Eduard_Munteanu> Oh, hm. So there's no Applicative combinator for it?
11:17:18 <Eduard_Munteanu> Nah.
11:18:28 <Peaker> I was worried about that, and disappointed that GHC couldn't optimize things to avoid accumulating memory that nobody ends up using.. And then disappointed that parser libs don't have a combinator to avoid accumulating memory unnecessarily
11:19:18 <Peaker> I remember thinking how it would avoid the need for sequence_ vs sequence, but now I know that this difference is necessary for Foldable vs. Traversable as well (sequenceA vs sequenceA_) so it's not a strong reason anymore
11:20:19 <Eduard_Munteanu> @hoogle (<$)
11:20:19 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
11:20:19 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
11:20:19 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
11:20:49 * hackagebot snap 0.12.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.12.1 (DougBeardsley)
11:21:15 <Peaker> [atto]parsec could have composed a "void" parser alongside the real parser, that doesn't actually accumulate the parsed values so if you use a specialized "void" rather than "void" or ()<$  you don't waste memory
11:21:32 <Peaker> Eduard_Munteanu, ()<$ is void, so:  void $ a *> b    is probably nicer
11:26:21 <S_J> > 6 : [1..10]
11:26:23 <lambdabot>   [6,1,2,3,4,5,6,7,8,9,10]
11:26:58 <S_J> @type (&&&)
11:26:59 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
11:27:15 <Peaker> S_J, usually: (&&&) :: (a -> b) -> (a -> c) -> a -> (b, c)
11:27:51 <S_J> > (&&&) (+1) (*5) 7
11:27:52 <lambdabot>   (8,35)
11:28:32 <S_J> @type (***)
11:28:33 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:31:00 <quchen> :t (***) `asAppliedTo` (undefined :: a -> b)
11:31:00 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
11:31:08 <quchen> ^ Much less scary. :-)
11:33:31 <Peaker> > (+1) &&& (*5) $ 7
11:33:32 <lambdabot>   (8,35)
11:33:55 <Eduard_Munteanu> This is odd... parse ((,) <$> digit <* digit *> digit) (T.pack "123")
11:34:07 <Eduard_Munteanu> It returns  Done "" '3'
11:35:09 <Eduard_Munteanu> There are actually two problems with it. Any idea why?
11:35:37 <Peaker> it parses as ((,) <$> digit) <* digit) *>digit
11:35:53 <quchen> What parser?
11:36:00 <quchen> Ah. Right.
11:36:01 <Eduard_Munteanu> Oh, eww.
11:36:17 <Peaker> ((,) <$> digit) <* digit   ignores the latter digit.   then the (... *> digit)  ignores everything but the last digit
11:36:18 <Eduard_Munteanu> No, wait.
11:36:26 <Peaker> s/latter/second
11:36:51 <Peaker> Eduard_Munteanu, what do you want to return for "123" ?
11:37:09 <Eduard_Munteanu> Peaker: ('1', '3')
11:37:17 <quchen> Parenthesize fmap's second argument and you'll be fine.
11:37:26 <Peaker> Eduard_Munteanu, then:  (,) <$> digit <* digit <*> digit
11:37:47 <Eduard_Munteanu> Ah, I see.
11:38:17 <Peaker> all of the <$, <$>, <*, *>, <*>  operators are all infixl 4, so they're all just left associative with each other
11:38:22 <Eduard_Munteanu> I guess I expected too much of the type system.
11:38:31 <v4hn> ok, now I got ghc bootstrapped. Now I try to get the platform to compile. However, this fails with "Configuring HUnit-1.2.5.2... Setup: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to specify a package database (it can be used multiple times)."
11:38:38 <v4hn> Any ideas what I'm doing wrong?
11:38:44 <Peaker> but an expression that involves both <* and *> but not <*> is likely wrong (or at least misleading)
11:39:01 <v4hn> that's the current ghc as well as the current platform I just downloaded from haskell.org
11:39:01 <quchen> (Wait, parenthesizing the <* *> wouldn't have helped. I need to reboot maybe.)
11:39:06 <Peaker> actually, only if <* is before *>
11:39:22 <Peaker> this is fine:  foo <$> bar *> baz <* quux
11:39:31 <Eduard_Munteanu> :t (<*)
11:39:32 <lambdabot> Applicative f => f a -> f b -> f a
11:39:59 <Peaker> Eduard_Munteanu, you can look at <* as sort of pointing in the direction of the expr that will determine the value
11:40:12 <Eduard_Munteanu> Peaker: that's what I did.. perhaps too much :D
11:40:30 <Peaker> so:  a *> b *> c *> d <* e <* f <* g       makes it clear "d" will be returned.   but if more than one applicative result is to be used, <*> must show up somewhere
11:40:57 <Peaker> bbl
11:40:57 <Eduard_Munteanu> Hm, yeah.
11:41:15 <Eduard_Munteanu> Thanks.
12:09:49 <FreeFull> > a *> b :: Expr
12:09:50 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
12:09:50 <lambdabot>              w...
12:10:18 <FreeFull> > [a] *> [b]
12:10:19 <lambdabot>   [b]
12:10:25 <FreeFull> > [a] *> [b] <* [c] *> [d]
12:10:26 <lambdabot>   [d]
12:10:28 <mauke> > [a,a] *> [b]
12:10:29 <lambdabot>   [b,b]
12:10:35 <FreeFull> Ok, I see the associativity now
12:10:37 <mauke> > [a,a] *> [o]
12:10:38 <lambdabot>   [o,o]
12:10:40 <mauke> acceptable
12:12:46 <banister> when i just use (\x -> return (x + 1)) how does haskell know which definition of 'return 'to use?
12:12:53 <mauke> context
12:12:56 <mauke> always context
12:13:13 <mauke> :t \x -> return (x + 1)
12:13:14 <lambdabot> (Monad m, Num a) => a -> m a
12:13:39 <mauke> someone somewhere will nail down that m
12:13:46 <FreeFull> It will use the only one which makes sense, and if there isn't something like that, it will error
12:13:53 <FreeFull> Although you won't get that kind of error very often
12:14:28 <pentace> > return 1
12:14:30 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
12:14:30 <lambdabot>    arising from a use of `M19297043...
12:17:53 <hape01> What is the most common way to sort a list of "records" by a given attribute? e.g. data Idea = Idea { a :: String, b:: String, c::String}      ideaList :: [Idea]     sort ideaList by "c"?  (e.g.)
12:18:08 <mauke> sortBy (comparing c)
12:18:20 <mauke> it is Intuitively Obvious™
12:18:39 <hape01> mauke: oh this is Haskell syntax, nice :-) thanks
12:21:44 <chreekat> I created a type with 400 records, and oy! GHC has quite the heart attack. Compiling a module with naught but such a type uses a whole lot of memory: <<ghc: 4726807828 bytes, 9003 GCs, ... >>
12:22:20 <mauke> hmm
12:22:42 <chreekat> I'm gonna get rid of the type, but still
12:23:31 <elliott> I have a heart attack too
12:24:10 <chreekat> :)
12:25:30 <zvrba> hm. getAny $ F.foldMap (\x -> Any $ x == 3) testTree [example from LYAH]
12:25:36 <zvrba> checking whether any value equals 3
12:26:18 <zvrba> now, in C and C++ one can use longjmp/exception to abandon the traversal once 3 is found.
12:26:31 <zvrba> what options are there in Haskell, if any?
12:27:15 <ryant50001> zvrba: if you're using pure values, you may find that laziness gives you the behavior you want automatically
12:27:18 <c_wraith> zvrba: it should just happen automatically
12:27:23 <ryant50001> zvrba: it would be worth profiling/tracing to check
12:27:39 <c_wraith> assuming the Monoid instance for Any is implemented correctly
12:27:48 <zvrba> oh. ok.
12:28:22 <ryant5000> zvrba: if you import Debug.Trace, you can use the "trace" function to see when things are actually getting evaluated
12:28:23 <c_wraith> yeah, the any monoid is lazy
12:28:28 <mauke> @src any
12:28:29 <lambdabot> any p =  or . map p
12:28:32 <mauke> @src or
12:28:32 <lambdabot> or    =  foldr (||) False
12:28:42 <mauke> @src foldr
12:28:42 <lambdabot> foldr f z []     = z
12:28:42 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:28:46 <c_wraith> however, I guess foldMap needs to be a right fold
12:28:47 <mauke> ∎
12:29:17 <roconnor> zvrba: check out getAny $ F.foldMap (\x -> Any $ x == 3) (Node 5 (Node 3 EmptyTree EmptyTree) (error "Did I reach this branch?"))
12:29:20 <c_wraith> foldMap is a right fold unless overridden
12:29:55 <edwardk> that'll short-circuit automatically
12:31:40 <DiegoNolan> how can you use the input callback functions in GLFW-b to actually do something useful?
12:35:01 <DiegoNolan> hmm nvm i found a good example
12:38:56 <erisco> Peaker, hm, I seem to be in a pickle for my other function ... with // it was easy, because returning 'x' could be done without knowing what was in ys
12:39:14 <erisco> Peaker, but now I am in the predicament that I have to know that ys is non-empty before returning 'x'
12:39:43 <erisco> Peaker, does that ruin me?
12:42:35 <Peaker> erisco, but my solution did not know to return x or not, it had to case within the const
12:42:38 <Peaker> within the cons, that is
12:43:24 <Peaker> DiegoNolan, https://github.com/Peaker/lamdu/blob/master/bottlelib/Graphics/UI/GLFW/Events.hs#L73
12:43:53 <erisco> Peaker, you can see that 'x' is returned regardless of what ys is: http://lpaste.net/90901
12:44:54 <erisco> Peaker, but I am in a rough spot now because in this case, to return 'x', I have to know that ys is non-empty... and with recursiveness on ys, I have to recursively know that ys is non-empty, which is unsatisfiable
12:45:23 <erisco> it seems like a stubborn problem because I don't care at all what the elements are ... only emptiness
12:45:26 <DiegoNolan> Peaker, you have to do this wierd IORef stuff
12:45:29 <DiegoNolan> ?
12:46:41 <c_wraith> what's weird about IORefs?  They're mutable variables like every other language has.
12:47:06 <b2coutts> does anyone here use vim2hs? I just installed it, but I get these error messages when I try to open a file: http://lpaste.net/90908. I'm not very experienced with vim plugins =/
12:47:40 * JuanDaugherty did c_wraith just troll this channel?
12:48:01 <mauke> b2coutts: could be encoding problems
12:48:14 <mauke> b2coutts: what does ':set enc?' say?
12:48:28 <b2coutts> mauke: encoding=latin1
12:48:33 <mauke> ok, that's not good
12:48:58 <erisco> actually... is a countably infinite cartesian product (ie  a1 x a2 x a3 ....) also countably infinite?
12:49:08 <mauke> b2coutts: what does ':echo $LANG' say?
12:49:12 <elliott> JuanDaugherty: presumably in response to <DiegoNolan> Peaker, you have to do this wierd IORef stuff
12:49:17 <b2coutts> mauke: C
12:49:21 <mauke> b2coutts: !
12:49:32 <mauke> why are you working in the C locale?
12:49:42 <b2coutts> mauke: wait, was that supposed to be in the shell or vim?
12:49:50 <mauke> either
12:50:04 <b2coutts> I'm not explicitly trying to use a weird locale
12:50:16 <b2coutts> I possibly did weird things when I installed my OS a few months ago and forgot about it
12:50:19 <tij_> is there a function :: a -> [a] -> [[a]] where is splits everytime it encounters a specific number/character/etc.
12:50:31 <erisco> tij_, groupBy I think
12:50:32 <erisco> :t groupby
12:50:33 <lambdabot>     Not in scope: `groupby'
12:50:33 <lambdabot>     Perhaps you meant one of these:
12:50:33 <lambdabot>       `BS.groupBy' (imported from Data.ByteString),
12:50:35 <erisco> :t groupBy
12:50:36 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
12:50:47 <mauke> b2coutts: well, it's en_US.UTF-8 here
12:50:57 <tij_> i.e. func 'r' "arbrccrdzr" = ["ar, "br", "ccr", "dzr"]
12:51:19 <erisco> > groupBy (==) [4,3,1,1,5,4,4,1,2,5,4,1]
12:51:20 <tij_> im trying groupBy but I cant get it to work
12:51:20 <lambdabot>   [[4],[3],[1,1],[5],[4,4],[1],[2],[5],[4],[1]]
12:51:31 <chreekat> :t BS.split
12:51:32 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
12:51:33 <erisco> okay so that compares adjacent elements
12:51:52 <chreekat> Though there's no split for lists, that I know of
12:51:59 <BMeph> tij_: Check out "splitBy" in the "split" package.
12:52:17 <tij_> > groupBy (const $ (/='r')) "arbrccrdzr"
12:52:18 <lambdabot>   ["a","rb","rcc","rdz","r"]
12:53:23 <tij_> but the 'r's are on the wrong side
12:53:38 <tij_> should be ["ar", "br", "ccr", "dzr"]
12:54:25 <tij_> BMeph: splitOn might work i think
12:54:31 <tij_> lemme try it
12:54:57 <mauke> > let swap a b x | x == a = b | x == b = a | otherwise = x in (map (swap '\n' 'r' . (++ "\n")) . lines . map (swap 'r' '\n')) "arbrccrdzr"
12:54:58 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'
12:54:58 <lambdabot>  Expected type...
12:55:19 <mauke> > let swap a b x | x == a = b | x == b = a | otherwise = x in (map (map (swap '\n' 'r') . (++ "\n")) . lines . map (swap 'r' '\n')) "arbrccrdzr"
12:55:20 <lambdabot>   ["ar","br","ccr","dzr"]
12:55:28 <erisco> Peaker, yeah I am definitely sunk on that problem. hrm....
12:56:00 <Peaker> erisco, I don't understand -- what function do you want to write?
12:56:04 <erisco> Peaker, the goal is to have   foo = "a" x foo    be equivalent to   repeat 'a'
12:56:30 <tij_> > map (++"r") $ init $ splitOn "r" "arbrccrdzr"
12:56:31 <lambdabot>   ["ar","br","ccr","dzr"]
12:56:34 <Peaker> erisco, are you applying "a" as a function?
12:56:47 <erisco> Peaker, but to return any item from the product, I have to know that no list is empty in the infinite list ... which can't be computed =\
12:57:03 <erisco> Peaker, no it is a character
12:57:28 <b2coutts> mauke: thanks; that seems to have worked
12:57:38 <Peaker> erisco, or do you mean:  foo = "a" `x` foo ?
12:57:38 <Peaker> erisco, I don't understand what you're trying to do
12:57:47 <b2coutts> though unrelatedly, vim2hs is a bit too dark for my liking...
12:58:00 <mauke> > let x = (++); foo = "a" `x` foo in foo
12:58:01 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
12:58:14 <Peaker> erisco, foo = "a" x foo    parses as an application of "a", but "a" isn't a function?
12:58:31 <erisco> Peaker, well sure, I used a bit of pseudo syntax ...  foo = "a" `x` foo   is fine, where x is cartian product
12:58:42 <erisco> cartesian
12:59:22 <erisco> well, it will be  [repeat 'a'] I suppose
12:59:30 <roboguy_> erisco: wouldn't a cartesian product give you a infinitely large tuple (theoretically)?
12:59:43 <erisco> roboguy_, I wouldn't use a tuple to collect the results of course
13:00:36 <erisco> maybe if I start with the assumption that no list is empty, then I can get somewhere ...
13:01:29 <erisco> that could be the secret to success in this one :)
13:06:19 <Peaker> erisco, sorry, currently working on a challenging problem of my own
13:06:55 <erisco> Peaker, that's fine. by talking here I have got past the initial hurdle ... by assuming the infinite list is well-behaved in the sense that it contains no empty lists
13:07:15 <erisco> with that assumption, I can return something without knowing what the right argument is
13:09:08 <augur> erisco!
13:09:19 <augur> i had a thought about CT for you
13:09:26 <augur> but then i forgot!
13:09:28 <erisco> what is CT?
13:09:34 <augur> category theory
13:09:39 <johnw> augur: forgetful functor strikes again!
13:09:45 <augur> johnw: :)
13:10:04 <roboguy_> hmm, I can't figure out how to reduce gc time in this code... it takes up 68% of the run time. maybe this algorithm needs a totally different implementation
13:10:50 <roboguy_> http://lpaste.net/90909
13:11:53 <johnw> roboguy_: try: \(!st, !xs)
13:12:12 <merijn> I'm getting a <<loop>> when using reactive-banana, but I'm not sure why? http://lpaste.net/90910
13:12:12 <johnw> I find tuples to be a notorious place for thunks to accumulate
13:12:15 <augur> erisco: it was probably something about how categories are just special graphs
13:13:01 <zacts> is there a good comparison between haskell and scheme/lisp?
13:14:02 <shapr> zacts: scheme/lisp allow mutation, haskell does not, and the syntax is really different
13:14:09 <johnw> shapr!!!!!
13:14:11 <shapr> zacts: Are there any parts that you are especially interested in?
13:14:11 <b2coutts> zacts: well, to share my personal experience, I learned scheme as my first functional programming language and later learned haskell. I found that haskell took a lot of the ideas I liked in scheme further
13:14:14 <shapr> oh hai johnw!
13:14:15 <johnw> do my eyes deceive me??
13:14:20 * johnw hugs shapr!
13:14:24 * shapr hugs johnw 
13:14:27 * shapr boings cheerfully
13:14:42 <b2coutts> I also like the syntax of scheme/lisp, though, the simplicity of s-expressions can be really nice, and haskell's syntax is much more complicated
13:15:08 <Eduard_Munteanu> Is there type synonym variant for MaybeT? I didn't think it through, but having to wrap stuff in MaybeT is very annoying.
13:15:18 <roboguy_> johnw: hmm, even with that the gc is still taking up 67% of the run time
13:15:39 <b2coutts> I sort of think of haskell as a "more extreme functional programming language" if that makes any sense
13:15:44 <johnw> roboguy_: have you enable profiling?
13:15:50 <roboguy_> johnw: yeah
13:16:13 <ion> zacts: One is statically typed and pure, the other is dynamically typed and impure. One has very little syntactic noise (which is a good thing), the other’s syntax is a data structure, blurring the line between code and data (which is a good thing).
13:16:13 <erisco> augur, well no worries. I am focusing on some other ideas at the moment
13:16:48 <zacts> well I'm trying to decide whether or not I should complete sicp before doing haskell..
13:17:21 <c_wraith> it's worth finishing, but order doesn't matter.  You can do them at the same time, if you like
13:17:27 <b2coutts> zacts: sicp is really good, and I don't like any haskell tutorials I've seen as much as it
13:17:39 <shapr> zacts: They're both good, why not give Haskell an hour and work on SICP an hour, and see which one is teaching you more?
13:17:41 <johnw> roboguy_: what does the heap look like?
13:17:45 <zacts> b2coutts: ok cool! so will haskell expand upon what I learn in sicp?
13:18:02 <zacts> shapr: that's an idea also.
13:19:16 <tij_> is the language extension ScopedTypeVariables considered "safe" to use?
13:19:17 <zacts> haskell's lazy evaluation sounds really neat.
13:19:19 <b2coutts> zacts: for sure; the kinds of things you'll learn when picking up haskell are quite different from what sicp teaches you
13:19:44 <b2coutts> there are a lot of things you're learn in lyah, GIH, or other haskell texts that sicp doesn't go over, and vice-versa
13:19:57 <zacts> ah ok, cool
13:20:14 <b2coutts> one of the things I appreciated a lot after going to haskell was that code was more concise; probably the thing about scheme that bothers me more than anything else is how annoyingly verbose it is
13:20:36 <zacts> well I think I'll start mainly with sicp, and read learn you a haskell for a great good wlong with sicp.
13:20:47 <b2coutts> the fact that things tend to be given names like long-name-description makes it annoying to try to format code to match 80 lines (and that's already difficult to do in lispy languages)
13:21:00 <b2coutts> zacts: doing them both at the same time may also be interesting
13:21:44 <byorgey> tij_: yes.
13:21:56 <b2coutts> I learned scheme at university, and the prof teaching the course mostly used haskell for illustrating things in class. It's a really nice language for expressing ideas
13:22:30 <zacts> neat! well, thanks. /me has got some reading to do.
13:22:35 <byorgey> tij_: it is completely safe.  It just changes the way local type signatures are interpreted.  It can never cause crashes or nontermination or anything like that.
13:22:48 <b2coutts> zacts: you and me both
13:23:10 <b2coutts> I still haven't gotten through lyah due to just wanting to do a lot of things in haskell outside of the tutorial
13:23:18 <b2coutts> not sure if it's a good thing or a bad thing
13:23:39 <tij_> byorgey: alright sweet. thanks!
13:23:50 <byorgey> b2coutts: sounds like a good thing to me.
13:24:20 <roboguy_> johnw: it looks sort of like x=y^2, which I guess is quadratic growth? It reaches about 800k at the end. I could post the heap profile somewhere if you want to take a look at it.
13:24:26 <b2coutts> byorgey: it sort of sounds like a good thing to me too, but maybe my time spent hacking around in haskell would be more efficiently spent after I've properly learned the language
13:25:24 <byorgey> b2coutts: Your experience and book-learning have to stay in sync.  read too much with no hacking and you won't retain it.  hack a lot without reading and you'll just bang your head against a wall.
13:25:51 <b2coutts> byorgey: haha, what do you mean bang my head against a wall?
13:26:14 <johnw> roboguy_: sure
13:26:22 <b2coutts> my main worry is that I'm learning to write bad code in haskell
13:28:23 <johnw> b2coutts: I'll take people who are worried about writing bad code over people who think they write awesome code anyday :)
13:28:29 <roboguy_> johnw: here's the hp file: http://roboguy.net/MoreProjectEuler.hp
13:28:39 <johnw> ok
13:28:41 <b2coutts> johnw: haha I guess
13:28:54 <johnw> because people who worry are willing to learn!
13:29:00 <b2coutts> though I'd still take people who write good code over people who worry about writing bad code and write bad code :P
13:29:11 <byorgey> b2coutts: by "banging your head against a wall" I mean being putting a lot of effort in but not really making any progress
13:29:37 <byorgey> b2coutts: everyone who writes good code started out as someone who worried about writing bad code and wrote bad code.
13:29:49 <byorgey> people who write bad code are the ones who didn't worry.
13:30:01 <johnw> roboguy_: try (!y:!ys) maybe?
13:30:05 <FreeFull> I started out not worrying about bad code and writing bad code =P
13:30:19 <johnw> roboguy_: it looks like the crossOff is creating a lot of thunks
13:30:45 <FreeFull> I hope my code is better now
13:30:56 <FreeFull> I try to put thought into it
13:31:07 <quchen> Why are things like "type Foo = forall a. a" called existential types, and not "universal" or something? Existential sounds a lot like "exists" after all
13:31:20 <elliott> quchen: I think you mean data Foo = forall a. Foo a
13:31:23 <elliott> which _is_ an existential
13:31:31 <elliott> Foo :: forall a. a -> Foo, i.e. Foo :: (exists a. a) -> Foo
13:32:19 <banister> elliott: are you a ruby programmer too?
13:33:09 <quchen> elliott: Ah, `forall a. a -> Foo  ==  forall a. (a -> Foo)` and then CurryHoward it, pull the existential inside the parenthesis and do some implication arithmetic, and you end up with "exists"?
13:33:37 <elliott> banister: no
13:33:46 <banister> elliott: oh, which languages do you use aside from haskell?
13:34:00 <elliott> uh, lots
13:34:04 <elliott> I know Ruby but I never use it
13:34:06 <roboguy_> johnw: hmm, it looks about the same. I was worried about adding too much strictness because of the infinite list, but it doesn't seem to stop it from terminating
13:34:15 <elliott> quchen: sure. the "forall" is on the constructor; what's inside is existential
13:34:22 <johnw> roboguy_: well, ! will only evaluate to WHNF
13:34:27 <banister> elliott: cool,which ones do you use?
13:34:29 <johnw> we're not using deepseq, so we should be ok
13:34:36 <roboguy_> johnw: ah, okay
13:34:44 <ion> I don’t always evaluate values, but when I do, I evaluate to WHNF.
13:35:23 <quchen> elliott: Ah, so I should read `forall a. Foo a` as "for every Foo (data constructor) there exists an a so that the whole thing has type "Foo"?
13:35:33 <elliott> banister: haskell
13:35:39 <banister> elliott: :D
13:36:01 <elliott> and less often, c and c++ and python, but I don't like them. and agda and coq, though my amateur use of them hardly counts.
13:36:23 <elliott> quchen: you should read it as "for every 'a', the constructor Foo has the type a -> Foo"
13:36:23 <banister> what language is haskell written in? C?
13:36:36 <elliott> banister: languages aren't written in other languages
13:36:37 <johnw> banister: in Haskell
13:36:41 <elliott> but GHC is mainly written in Haskell
13:36:49 <elliott> with C and C-- for the runtime system
13:36:54 <tij_> is there a strip all whitespace function?
13:36:55 <ion> Haskell is written in at least HTML.
13:36:57 <aristid> johnw: no, haskell has no formal specification and it's not written in haskell :)
13:37:06 <johnw> doh, you've got me there
13:37:07 <ion> I’m not sure if that’s the source format.
13:37:09 <johnw> GHC is in Haskell :)
13:37:13 <elliott> Hugs is a haskell interpreter written in C
13:37:18 <elliott> (sort of abandoned)
13:37:44 <quchen> elliott: Hm, I think I don't quite understand how `type` works yet.
13:37:57 <elliott> quchen: well, I was talking only about the "data" form.
13:38:04 <quchen> Ah, okay.
13:38:10 <elliott> I don't think anyone calls "type Foo = forall a. a" an existential
13:38:46 <aristid> it'd be kind of the opposite
13:44:36 <byorgey> tij_: if you want to get rid of *all* whitespace you can do   filter (not . isSpace)
13:44:56 <byorgey> > filter (not . isSpace) "   Here\t is   some\n text "
13:44:56 <lambdabot>   "Hereissometext"
13:45:32 <byorgey> tij_: if you just want to get rid of whitespace on the ends of a string you can do  strip = f . f  where  f = dropWhile isSpace . reverse
13:45:54 <byorgey> > let strip = f . f  where f = dropWhile isSpace . reverse   in  strip "   Here\t is   some\n text "
13:45:54 <lambdabot>   "Here\t is   some\n text"
13:46:03 <hpc> or if you want to reduce all whitespace to a single space, strip = unwords . words
13:46:15 <hpc> > unwords . words $ "Here\t is    some\n text"
13:46:16 <lambdabot>   "Here is some text"
13:46:42 <byorgey> tij_: if you are using the 'text' package (as is recommended for any serious/"real-world" programs), there is a 'strip' function provided
13:47:09 <byorgey> OK, that's enough guessing for now.  If I haven't answered your question then you will have to give an example of what you mean.
13:47:31 <tij_> thanks guys!
13:50:11 <Demos> anyone here used the configurator library?
13:51:17 <byorgey> Demos: I have used it, though I did not use many of the advanced features like auto-reloading
13:51:41 <Demos> hm can you tell me what I may have made [String] and instance of Configured?
13:51:55 <Demos> I wrote this code a long time ago...
13:52:14 <zacts> I do have a question, does haskell employ OOP at all?
13:52:24 <zacts> or is it a completely different way of thinking about things?
13:52:29 <LadyAurora> No.
13:52:32 <hpc> yes
13:52:34 <LadyAurora> Yes.
13:52:35 <hpc> (in that order)
13:52:35 <orzo> you can do OOP if you want to
13:52:36 <b2coutts> maybe
13:52:38 <Demos> I mean you can think about objects, when you think about it objects are for controlling state, and haskell does not have any
13:52:53 <orzo> haskell dos have state
13:52:58 <orzo> IORefs and such
13:53:02 <zacts> I'm totally confused now
13:53:03 <jmcarthur> haskell is perfectly capable of implementing objects
13:53:10 <jmcarthur> but objects are not some fundamental language feature
13:53:23 <byorgey> Demos: no idea, sorry
13:53:26 <banister> is it weird to anyone else that >>= composes left-to-right but '.' composes right-to-left ?
13:53:29 <b2coutts> zacts: the short answer is yes, but probably not the kind you might be expected if you're used to java or similar
13:53:32 <Demos> when you think about it closures and objects are very similar
13:53:37 <zacts> ok
13:53:38 <b2coutts> s/expected/expecting
13:53:40 <jmcarthur> banister: yes, which is why you should use (=<<) and (<=<) :)
13:54:00 <johnw> banister: in depends on what you want to emphasize, I find; I use both =<< and >>=
13:54:01 <jmcarthur> banister: (but in all honesty i think (>>=) makes some sense for certain monads, just not all)
13:54:02 <banister> jmcarthur: hehe, seriously? that's idiomatic?
13:54:13 <merijn> banister: No, he's joking :p
13:54:29 <jmcarthur> no, i'm not joking, but you have to take my later parenthetical into account
13:54:53 <orzo> i almost never use =<< and <=<
13:54:57 <johnw> I read "a >>= b" as "do a, then b with its result", and "a =<< b" as "b yields the argument to a"
13:55:04 <jmcarthur> i use them quite often
13:55:04 * roconnor thinks we should use & instead of function application
13:55:14 <banister> roconnor: interesting, what's  & ?
13:55:17 <Demos> well it is the same as :- vs " "
13:55:25 <roconnor> & is flip ($)
13:55:30 <jmcarthur> Demos: :- ?
13:55:38 <Demos> is it :-?
13:55:40 <elliott> jmcarthur: :-?
13:55:44 <Demos> maybe -:
13:55:45 <elliott> jmcarthur: reattached your mouth to your nose for you
13:55:48 <jmcarthur> Demos: what are you talking about?
13:56:06 <merijn> Anyway able to help me figure out why this produces <<loop>>? http://lpaste.net/90910
13:56:10 <Clint> smells like type operator
13:56:34 <Demos> (:-) :: (a -> b) -> b -> a or something like that
13:56:57 <roconnor> @djinn (a -> b) -> b -> a
13:56:57 <lambdabot> -- f cannot be realized.
13:56:59 <hpc> that function can't be implemented
13:57:06 <hpc> (in a way that makes sense)
13:57:35 <roconnor> @type (***id)
13:57:36 <lambdabot> (b -> c) -> (b, a) -> (c, a)
13:57:39 <Demos> you are correct, the point is it works like a pipe
13:57:44 <roconnor> @type left
13:57:45 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
13:57:52 <roconnor> @type first
13:57:53 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
13:57:56 <orzo> are there alternatives to hslogger besides rolling my own?
13:57:59 <jmcarthur> Demos: i don't understand what it is supposed to do
13:58:14 <roconnor> merijn: you can replace (***id) with first
13:59:15 <merijn> roconnor: I just now saw that and fixed it :p
14:01:20 <Eduard_Munteanu> How do you combine parsers sequentially?
14:02:15 <Eduard_Munteanu> I sort of want to say  foo >>> bar  where foo parses the input and hands the result to bar for another round of parsing.
14:02:22 <jmcarthur> Eduard_Munteanu: (>>) or (*>) or (>>=) or (<*>), depending on what you need
14:02:33 <jmcarthur> the first two being basically the same thing
14:02:52 <Eduard_Munteanu> jmcarthur: err, that seems to do something different than I want
14:03:07 <Eduard_Munteanu> jmcarthur: it drops the result of the first action
14:03:07 <jmcarthur> what you just described sounds like bind to me. what's different?
14:03:31 <jmcarthur> sure, but i listed four combinators, not one
14:03:54 <Eduard_Munteanu> jmcarthur: wait, lemme try (>>=) first.
14:04:04 <hpc> what type are you expecting the operator to have?
14:04:16 <jmcarthur> a >>= f  should run a then pass its result to f
14:05:23 <orzo> simple-log package is described "Log library for Haskell with removing unnecessary traces" anyone care to translate to english?
14:05:40 <Eduard_Munteanu> hpc: Parser Text -> Parser b -> Text -> Result b  I think
14:05:48 <JoeyA> I guess that means you can disable logging with a compile-time switch?
14:06:22 <orzo> hm
14:07:43 <jmcarthur> Eduard_Munteanu: there is no function argument, which sounds like it's not going to be what you just described
14:08:19 <JoeyA> Has anyone here made their own "cabal init" variant?  Things I don't like about current cabal init: 1) default package bounds are overly strict (e.g. containers == 0.5 or so).  2) highly inconsistent indentation and trailing whitespace  3) does not set ghc-options: -Wall -fwarn-tabs by default
14:09:01 <hpc> holy crap, #2 drives me nuts as well
14:09:10 <byorgey> Eduard_Munteanu: you want to parse an input stream, resulting in another stream, which is then handed as the input stream to another parser?
14:09:22 <byorgey> i.e. you want to "layer" two parsers?
14:09:45 <byorgey> e.g. in the same way a lexer and parser would traditionally be layered?
14:10:09 <hpc> #3 i don't mind; i haven't ever needed anything above and beyond type errors, and if you use tabs you deserve what you get
14:10:10 <Eduard_Munteanu> byorgey: yes
14:10:23 <JoeyA> My own cabal init would set a github repo URL, but that would only apply to people who host their Hackage projects on github (other people are, by definition, ugly and stupid)
14:10:31 <hpc> #1 you should be doing by hand anyway; depends are a tricky thing to get right, especially automatically
14:10:43 <Eduard_Munteanu> parseOnly (takeText `someCombinator` takeText) (pack "text") = "text"
14:11:02 <byorgey> Eduard_Munteanu: ok.  Then (>>=) is not what you want.
14:11:13 <byorgey> Eduard_Munteanu: I have wanted this before and I don't know of a good way to do it, actually.
14:11:55 <byorgey> JoeyA: I am working on adding automatic github repo URL detection
14:12:00 <JoeyA> cool
14:12:00 <Eduard_Munteanu> I want a (>>>), but it's not really a category instance generally.
14:12:13 <byorgey> JoeyA: as for the other things, why don't you file a feature request or submit a pull request rather than making your own variant?
14:12:20 <JoeyA> But what if you cabal init before you git init?
14:12:33 <byorgey> then it won't work.
14:13:03 <byorgey> a larger issue is that it would be cool if you could run cabal init to incrementally update your .cabal file.
14:13:28 <byorgey> but that would require being able to parse, edit, and pretty-print .cabal files while preserving all whitespace, which we don't currently have
14:13:40 <JoeyA> hpc: I think a reasonable policy is to default to >= foo 1.2, and for the user to add upper bounds manually when they are known to be necessary.  My opinion, at least.
14:14:05 <byorgey> JoeyA: I would certainly be open to having some flags to set the behavior re: generating version constraints
14:14:22 <byorgey> I am not interested in arguing over what the right default would be.
14:14:40 <JoeyA> Good idea
14:15:18 <Eduard_Munteanu> byorgey: what do you mean by "good way" though? The combinator itself should be straightforward, perhaps you mean generalizing it?
14:16:14 <byorgey> Eduard_Munteanu: yeah, I guess you're right that writing the combinator should not be hard.  I just meant there was no easy way to do it other than manually writing a combinator to run both parsers and thread the inputs through
14:17:10 <byorgey> I don't have a lot of time to work on cabal init but I do work on it occasionally, and am happy to help other people who want to get their toes wet adding features
14:17:17 <byorgey> there are lots of ways it could be improved.
14:18:18 <Eduard_Munteanu> Hmmm... I wonder if the two-argument   Parser   is a Category
14:19:45 <Eduard_Munteanu> Parser a b is pretty much like an arrow type.
14:19:46 <byorgey> Eduard_Munteanu: you would have to define   newtype Transducer a b = T (Parser a [b])  or something like that
14:19:57 <byorgey> I think you could make that a Category.
14:19:57 <Eduard_Munteanu> Oh, right.
14:30:04 <Demos> is there any reason to use parsec over attoparsec?
14:30:19 <`Jake`> In gtk2hs there are all of these events which are marked as "depricated", but it seems like most poeple use them anyway. Maybe I'm just looking at old code, though. Should I try to find alternatives?
14:30:20 <danharaj> error messages
14:32:02 <Ralith> that sounds like a reason to use trifecta
14:32:31 <geekosaur> `Jake`: older code, probably. it doesn't help that the gtk+ folks tend to deprecate stuff a lot (and I have seen a lot of fallout in multiple places when they finally remove it, because people keep using the deprecated calls)
14:33:16 <`Jake`> geekosaur: Do then I should search for and use newer alternatives?
14:33:42 <geekosaur> ideally yes, because the gtk+ folks will ultimately remove the deprecated stuff and your code will break
14:34:10 <`Jake`> alright, thanks
14:37:45 <Demos> does trifecta have documentation?
14:39:50 <Peaker> Demos, the hackage docs seem sparse but slightly exist
14:40:30 <Demos> this is a good reason not to use it
14:40:56 <Peaker> It's written by edwardk, which is a good reason to use it.. also parser combinators are quite self-explanatory, given the exposed types
14:42:30 <Demos> but a 5 line code sample would go a long way
14:46:09 <Peaker> Demos, http://hackage.haskell.org/packages/archive/trifecta/1.1/doc/html/Text-Trifecta-Parser.html what do you know, there's an exactly 5 line code sample there
14:46:49 <Demos> ah! I was led to an old version by google
14:47:48 <Peaker> just go to http://hackage.haskell.org/package/<name> manually (my browser completes that with some package name which I replace)
14:49:05 <carter> Demos Peaker  trifecta's core is the parsers lib
14:49:09 <carter> @hackage parsers
14:49:10 <lambdabot> http://hackage.haskell.org/package/parsers
14:49:35 <carter> <@hackage packagename> works when you have a lambda bot handy
14:49:52 <carter> Demos parsec gives a lot more error messages than attoparsec
14:49:56 <carter> they have slightly different semantics
14:50:13 <carter> honestly just pick whichever is easier for you to use for now
14:50:24 <carter> if you really need to port things later, its possible
14:52:10 <Demos> well I asked since attoparsec seems more popular, but my essential problem is that I have configuration files that I need to read and write, and that have functionish things in them
14:52:47 <Peaker> Demos, can you decide what the config file format is? or is it dictated for you?
14:53:08 <johnw> Demos: I would use trifecta
14:53:16 <Demos> I can decide
14:53:35 <Peaker> Demos, then why not use auto-derive of JSON [de-]serializer?
14:53:40 <MitchellSalad> to anyone who has used Yesod: I'm seeing reqGetParams <$> getRequest always return [] even when there are definitely get parameters present, why might this be?
14:54:04 <Demos> that is a good idea, but I would prefer less ""s
14:55:06 <Peaker> Demos, apparently, the yaml package can [de-]serialize a JSON object to YAML (less "")
14:55:33 <Peaker> Demos, and the aeson package can then auto-generate a [de-]serializer for the parsed JSON to your Config type
14:55:51 <nabilhassein> i was refactoring some code and found myself writing a helper function with this type signature:
14:55:52 <nabilhassein> Either e a -> (a -> IO e) -> IO e
14:56:02 <Demos> YAML is so type->JSON->YAML->disk?
14:56:07 <nabilhassein> is there a library function like that? i didn't find anything using hoogle
14:56:18 <Demos> s/YAML is//
14:56:56 <Peaker> Demos, http://hackage.haskell.org/packages/archive/yaml/0.8.3/doc/html/Data-Yaml.html
14:57:00 <erisco> best implementation design... some intuition, but last mile is fingers crossed trial and error :)
14:57:02 <nabilhassein> it's sort of like monadic conversion function
14:57:25 <Peaker> Demos, you can use encodeFile/decodeFile to write/read your configuration into a file in YAML format, and auto-generate the serialization of your config file with TH
14:58:47 <Peaker> @type either return
14:58:48 <lambdabot> Monad m => (b -> m a) -> Either a b -> m a
14:59:08 <Peaker> @type flip (either return)
14:59:09 <lambdabot> Monad m => Either a b -> (b -> m a) -> m a
14:59:26 <Peaker> nabilhassein, ^^ this function doesn't seem interesting enough to get its own name
14:59:36 <nabilhassein> peaker: exactly what i needed
14:59:44 <nabilhassein> either return is perfect
14:59:46 <nabilhassein> thanks very much!
15:00:44 <Peaker> Demos, the aeson package defines a JSON-like ADT: http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson-Types.html
15:00:45 <erisco> Peaker, I think I may have done it :D
15:01:07 <`Jake`> another question about gtk2hs: is it common practice to use the `on' function as infix operator?
15:01:08 <Peaker> Demos, And it has TH to generate code to convert your data types to/from this ADT
15:01:41 <Peaker> Demos, and it has functions to convert the JSON-like ADT to/from actual JSON strings.   But this last part you don't need -- instead you can use functions from the YAML package that translate the same JSON-like ADT into yaml
15:02:02 <Peaker> Demos, so the JSON string format is never used, just the json-like ADT from the aeson package (re-exposed by the yaml package)
15:02:25 <Peaker> `Jake`, it's pretty common in general (not related to gtk)
15:02:41 <`Jake`> Peaker: ok, thanks
15:03:00 <erisco> Peaker, perhaps not :( can't get past the first element darnit
15:03:17 <Peaker> Demos, consider how nice it is that if you ever extend your config data types the YAML format will be automatically extended too
15:03:28 <`Jake`> Peaker: it's not Data.Function.on, though
15:03:39 <Peaker> `Jake`, oh, then I don't know
15:04:25 <Demos> sure, but YAML is somewhat complex, better than XML but still a little much
15:04:55 <Demos> but I think that I will go the YAML route since there is not much better
15:05:20 <erisco> Peaker, might you take a look? http://lpaste.net/90911   let m = qux (++) ["a","b"] m      I can get the head of m, but I think I should be able to get the second element too (rather it hangs)
15:05:51 <erisco> Peaker, not sure how I tripped up... perhaps something to do with baz ... (f x (head yss)) even if yss is infinite, if I skip over the first element surely this part isn't causing the hang
15:06:21 <Peaker> erisco, yuck! head/tail, what's up with that?
15:06:37 <erisco> Peaker, I can't pattern match on the right argument
15:06:45 <erisco> Peaker, I have to keep it all lazy-like
15:06:47 <Peaker> erisco, then use an "irrefutable pattern"
15:07:08 <erisco> sounds facy :o
15:07:12 <Peaker> quz f ~(x:xs) ~(y:ys) = ...  doesn't actually force the args, but assumes they are (:)
15:07:28 <haasn> > case undefined of ~(x:xs) -> ()
15:07:28 <Peaker> and only when x or xs are used, it forces that part, ditto with y/ys
15:07:29 <lambdabot>   ()
15:07:37 <haasn> > case undefined of x:xs -> ()
15:07:38 <lambdabot>   *Exception: Prelude.undefined
15:07:45 <haasn> > case undefined of ~(x:xs) -> x
15:07:46 <lambdabot>   *Exception: Prelude.undefined
15:08:04 <haasn> > case [] of ~(x:xs) -> x
15:08:05 <lambdabot>   *Exception: <interactive>:(3,1)-(4,22): Irrefutable pattern failed for patt...
15:08:44 <Peaker> erisco, also, give good names... I'm in the middle of a challenging problem, so I can take a look but would rather not reverse engineer badly named stuff :)
15:09:17 <erisco> there aren't really reasonable names that I can think of =\ baz does a sort of diagonal thing, but otherwise, *shrug*
15:10:09 <erisco> Peaker, well work on your problem. don't want to disturb
15:11:38 <erisco> I must have spent a lot of effort making the first result lazy but then tripped up on subsequent ones
15:13:14 <chreekat> erisco: what is it you're trying to do?
15:15:03 <erisco> chreekat, a1 x a2 x a3 ... where x is cartesian product
15:15:50 <`Jake`> Is it just me or is haskell.org pretty slow?
15:15:58 <erisco> I've got the cartesian product of two infinite lists down dandy, but it is proving challenging to get likewise for an infinite list of infinite lists
15:16:31 <srhb> erisco: How so? What's the problem?
15:17:08 <erisco> I rewrote my code to give back the first element of the product, by being lazy on the right argument, but it hangs getting the second ... I may have just postponed the inevitable by rolling out the loop once
15:17:59 <srhb> erisco: Can you give an example of the first elements and their products?
15:18:17 <kingugo> anyone know the command to start haskell from terminal in kali?
15:18:25 <kingugo> thanks in advance
15:18:31 <erisco> srhb, yeah I pastbinned the code
15:18:54 <byorgey> kingugo: if you have the Haskell Platform installed, just type  ghci
15:19:01 <byorgey> kingugo: this should be the same on any distribution.
15:19:34 <srhb> erisco: The one with head and tail?
15:19:57 <erisco> srhb, yeah. I am reading on these irrefutable patterns and if I can understand them I will use those instead
15:20:03 <erisco> srhb, http://lpaste.net/90911
15:20:16 <erisco> I annotated with an example usage, which indicates the problem
15:20:20 <kingugo> byorgey: typed ghci aand i saw prelude> is that what am meant tio see?
15:20:34 <byorgey> kingugo: yes.
15:20:44 <srhb> erisco: First, rewrite it without head and tail.
15:20:54 <byorgey> kingugo: is there some particular book or tutorial you are following?
15:21:03 <byorgey> pretty much any tutorial should talk about this.
15:21:05 <erisco> I don't know how yet ... and isn't that purely a cosmetic change?
15:21:29 <kingugo> alright byorgey. thanks. one omere thing, do you know any excellent material on haskell? free or paid
15:21:34 <srhb> erisco: No, functionally they're bad as well
15:21:52 <byorgey> @where lyah
15:21:52 <lambdabot> http://www.learnyouahaskell.com/
15:21:54 <srhb> erisco: Ideally you just pattern match out the head and tail as in (x:xs)
15:21:55 <byorgey> @where rwh
15:21:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:22:02 <byorgey> kingugo: you can start with those ^^^
15:22:17 <`Jake`> I must say that I was glad I started with lyah when I read through rwh
15:22:29 <erisco> srhb, well I need to be lazy on the right argument... so it was advised for me to use  ~(x:xs)  but I don't understand the implications. still looking for docs
15:23:10 <kingugo> alright byorgey, can i contact you if i run into troubles?
15:23:15 <fuzzy_id> hi
15:23:23 <kingugo> and thanks lambdabot
15:23:28 <srhb> erisco: The tilde makes sure the pattern match never fails, ie. the match is deferred
15:23:29 <byorgey> hi fuzzy_id
15:23:32 <erisco> I think I screw up on 24, because I force knowing the tail is null
15:23:40 <byorgey> kingugo: no, just ask any questions you have in this channel
15:23:59 <byorgey> then anyone who is around can answer your questions
15:24:16 <kingugo> ok. thanks. let me get started
15:24:21 <fuzzy_id> is there some library to profile haskell code on the command line?
15:24:24 <Twey> erisco: cartesianOfInfiniteList xs = [map head xs]?
15:24:50 <roboguy_> kingugo: you can profile with ghc
15:24:50 <erisco> Twey, well that might get me the first element
15:24:57 <erisco> Twey, I do want all of them
15:25:05 <`Jake`> roboguy_: That's the wrong guy you're talking to
15:25:13 <fuzzy_id> something like pythons timeit? maybe?
15:25:14 <Twey> Oh, okay, you can evaluate the spine without the elements
15:25:20 <roboguy_> err fuzzy_id
15:25:30 <erisco> Twey, yeah
15:25:43 <fuzzy_id> :)
15:25:48 <byorgey> fuzzy_id: there are lots of tools for profiling Haskell.  do a google search for 'haskell profiling'.  Also see the 'criterion' package for benchmarking
15:26:00 <srhb> erisco: Sorry, I go kinda foo baz bar blind on your code.
15:26:06 <kingugo> dont get roboguy; can you elaborate? pls
15:26:30 <erisco> well I don't really have reasonable names. the logic is a bit opaque certainly, even with better names, I think
15:26:33 <roboguy_> kingugo: sorry, I meant to say that to fuzzy_id
15:26:53 <fuzzy_id> ok, seems my google a bit honky-tonk today
15:26:57 <byorgey> erisco: when you say you need it to be lazy in the right argument, what do you mean?
15:26:57 <fuzzy_id> +is
15:27:11 <kingugo> roboguy: ok. am just starting out. lol. thanks
15:27:13 <byorgey> erisco: can you give an example?
15:27:16 <kingugo> was a bit confused
15:27:17 <erisco> byorgey, I mean that I must yield an element without knowing anything about the right argument
15:27:26 <roboguy_> fuzzy_id: you can enable profiling if you compile with -prof
15:27:30 <erisco> byorgey, if I cannot do this, then I cannot define 'm' as I have
15:27:51 <fuzzy_id> yeah, but i'd love to do something like
15:28:08 <fuzzy_id> let a = "fancy expression" in timeit 1000 a
15:28:18 <fuzzy_id> in the interpreter
15:28:31 <fuzzy_id> i cannot find any library for that
15:28:39 <erisco> ah, I found a description of ~ ... I can use that then, yes :)
15:28:58 <erisco> the "trust me" operator for pattern matching. how cute :)
15:29:05 <byorgey> erisco: I still don't really understand what you're trying to do, but yes, it sounds like irrefutable patterns are what you want
15:29:06 <fuzzy_id> or is that impossible, given the architecture of the interpreter?
15:29:22 <srhb> erisco: If anything I'd think your error lies in line 25, not 24
15:29:36 <roboguy_> fuzzy_id: that I don't know. I've never tried to do anything like that
15:29:42 <byorgey> fuzzy_id: type  :set +s  at the ghci prompt
15:29:43 <erisco> srhb, oh?
15:29:56 <byorgey> fuzzy_id: then it will give you timings for any expressions you evaluate after that
15:30:21 <fuzzy_id> awesome!
15:30:28 <fuzzy_id> wooohooooo :)
15:31:07 <srhb> erisco: I just cannot see how line 24 could ever make anything hang, since it's reducing a list to a singleton
15:31:17 <srhb> oh wait, it's already a singleton.
15:31:19 <srhb> Nevermind me
15:31:27 <erisco> I'll take out the head and tails so it is a bit easier to read. I'll also try and give better names
15:31:41 <srhb> Aye. Or just give example input and output
15:31:49 <erisco> I did in the paste :o
15:31:53 <srhb> Oh?
15:31:59 <erisco> yeah check the annotation
15:32:01 <srhb> By example output I mean: What do you WANT to get.
15:32:19 <erisco> srhb, I want head (tail m) to not hang
15:32:49 <srhb> Well, even head m will hang
15:32:56 <erisco> it doesn't
15:33:11 <erisco> it returns an infinite list of a's
15:33:18 <srhb> Oh, yes, true.
15:34:26 <srhb> I finally understand your problem at least. You want it to not evaluate any element before it is inspected.
15:34:28 <srhb> or, forced.
15:34:53 <erisco> that, and I don't want it to evaluate the rest of the list either
15:34:55 <Peaker> "instance (Functor m, Monad m) => Applicative (MaybeT m)" seems broken and silly :(
15:35:00 <erisco> which I believe is happening
15:35:00 <srhb> So your question is really "where am I forcing the first element"?
15:35:08 <erisco> no I think I am forcing the rest of the list
15:35:16 <Peaker> Demand Monad when Applicative is enough?  OK, if it's for Monad compatibility. But then demand Functor too??
15:36:05 <erisco> maybe I am forcing the first element... I don't see how that would be
15:36:25 <srhb> Stick more ~ in r and see what happens :P
15:36:46 <erisco> which one?
15:37:36 <srhb> Oh, they're all r. baz, the one you suspect
15:37:42 <srhb> I just don't see the obvious forcing.
15:38:36 <Demos> hm I am playing with sexp as an alternitive to the JSON library, I like it
15:40:08 <erisco> this is more readable, hopefully: http://lpaste.net/90913
15:41:20 <srhb> erisco: Much!
15:42:26 <erisco> srhb, if you consider how Cantor listed the rationals, in a table, this does roughly the same. topRight works along the top then down the right-hand-side, and diagonal takes the point topRight is currently at and runs down and left
15:43:15 <erisco> I think ... honestly the logic escapes me here and there and I did some of it on trial and error :P
15:44:05 <srhb> erisco: Don't worry, currently it's way over my head as well. :-)
15:44:50 <erisco> I did one that worked on lists of same length, and included a routine to pad the shorter list
15:45:24 <erisco> trying to work on ragged lists has been more complicated, with the addition of trying to work without forcing the right arg
15:47:49 <erisco> srhb, even if I replace the diagonal rule on line 20 with just = [x] , I still can't get to the second element
15:48:17 <nabilhassein> is there a good synonym for 'Either String'?
15:48:28 <danharaj> Either String seems pretty good.
15:48:30 <srhb> erisco: Time to run it by hand?
15:48:41 <nabilhassein> something like 'perhaps fails with message' except that that fails to be shorter than "Either String"
15:48:49 <nabilhassein> danharaj: haha, you're right that's already pretty descriptive
15:49:03 <danharaj> nabilhassein: That's the beauty of descriptive types :)
15:49:18 <nabilhassein> I'm just wondering if a type Foo = Either String might make my program just a little nicer
15:49:31 <mm_freak> type (+) = Either
15:49:35 <danharaj> I find type synonyms to get in the way a lot in my experience.
15:49:37 <mm_freak> String + Int
15:49:55 <danharaj> Since I need to know what the synonym reduces to in order to reason about the code anyway.
15:49:57 <mm_freak> type synonyms for basic data types like String and Int can be helpful
15:50:05 <mm_freak> but type synonyms for Either are a bad idea
15:50:06 <monochrom> it won't be nicer. when I see your "Foo Int", I have to jump through hoops to discover it's just Either String Int
15:50:10 <danharaj> ^
15:50:48 <nabilhassein> monochrom, danharaj: you're right, i'll leave Either String
15:50:55 <monochrom> you can, of course, argue that the real name is "EitherString". that saves you one space.
15:51:00 <mm_freak> here is one potential application for type synonyms:  Int -> Int -> Int -> Int -> Int -> Int
15:51:22 <companion_cube> or named arguments
15:51:30 <monochrom> no, I wouldn't like a type synonym for that either
15:51:33 <danharaj> or newtypes if you want to be serious business about it.
15:51:57 <danharaj> generalized newtype deriving takes most of the sting out of newtypes
15:52:16 <monochrom> I have to jump through hoops to discover that it is in practice a 5-ary function over Int, for example
15:52:35 <danharaj> monochrom: welcome to the space jam.
15:52:36 <monochrom> unless you choose the name "FiveAryFunctionOverInt"
15:53:31 <mm_freak> monochrom: well, you can choose between a) see immediately what the arguments mean, but not what they actually are made of, b) see immediately what they are made of, but have to open the haddocks to the function to see what they mean
15:53:36 <mm_freak> that's the tradeoff
15:53:40 <`Jake`> I like the type synonym for [Char].
15:53:42 <mm_freak> sometimes a) is better, sometimes b)
15:54:22 <monochrom> I don't understand why (a) and (b) are different
15:54:37 <monochrom> what does "mean" mean? I am serious.
15:54:55 <mm_freak> monochrom: Double -> Double -> Double -> IO ()
15:54:58 <monochrom> (I am fine if you answer "as in conal's denotative")
15:55:01 <mm_freak> f :: …
15:55:12 <mm_freak> now what does f 1 2 3 mean?  you'll have to open the haddocks to find out
15:55:36 <mm_freak> f :: Coord -> Coord -> Radius -> IO ()
15:56:02 <mm_freak> now it's pretty clear what f 1 2 3 means, but you'll have to resolve the type synonyms to find out the types
15:56:09 <mm_freak> that's the tradeoff
15:56:19 <monochrom> what does Coord and Radius mean? I still have to open the haddocks to find out. for example am I sure that Radius mean Double, not Integer?
15:56:57 <mm_freak> monochrom: in both cases it's a matter of which one is easier to memorize
15:57:17 <mm_freak> consider FilePath
15:57:34 <mm_freak> once you found out that it's just String, did you ever look it up again?
15:58:05 <mm_freak> now read the type signature of writeFile:  FilePath -> String -> IO ()
15:58:08 <mm_freak> pretty clear, isn't it?
15:58:30 <`Jake`> writeFile :: [Char] -> [Char] -> IO ()
15:58:38 <monochrom> once I found out it's just String, I replaced it by String in all my own type sigs, all type sigs I have control over.
15:58:59 <mm_freak> if it were String -> String -> IO (), you would have to open the haddocks every now and then
15:59:00 <zRecursive> morning
15:59:06 <monochrom> so, I didn't ever look it up again, because I eliminated looking up
15:59:11 <mm_freak> at least i'm grateful for FilePath =)
15:59:30 <monochrom> no, once I found out it's writeFile "/dev/null" "hello", I didn't look it up again
15:59:46 <mm_freak> then you're probably better at memorizing things than me
15:59:56 <monochrom> my ideal is, in fact, writeFile (FilePath "/dev/null") "hello"
15:59:58 <`Jake`> It does make sense because of currying
16:00:07 <mm_freak> monochrom: i could agree with that
16:00:49 <mm_freak> also maybe some day FilePath will be a tree structure
16:00:57 <monochrom> using Excluded Middle, I always ask: do you want an abstraction or not? answer yes, or answer no
16:01:13 <mm_freak> answer:  it depends
16:01:33 <mm_freak> i don't want an alias for Maybe or Either String
16:01:36 <monochrom> sure. let's take FilePath for example. do you want an abstraction or not?
16:01:43 <mm_freak> yes
16:01:51 <monochrom> then it's a newtype.
16:02:18 <mm_freak> well, the base library wasn't as rigorous
16:02:23 <monochrom> if you don't want an abstraction, then tell me the concrete implementation.
16:02:59 <mm_freak> i understand your point and i agree
16:03:20 <mm_freak> it's just that an abstraction comes with its own tradeoffs
16:03:27 <Bor0> in the definition of category, can it be said for the unit law that it's there so that types "line up"? e.g. A -> B -> C <=> A->C, can we say that this is so because of the unit law?
16:04:00 <Bor0> or that the unit law guarantees that
16:04:33 <mm_freak> Bor0: not really…  the identity morphism doesn't have a meaning by itself
16:04:40 <benmachine> monochrom: would you discard the 'type' keyword altogether?
16:04:53 <monochrom> I don't know yet
16:04:55 <mm_freak> Bor0: it gets its meaning when combined with composition and associativity
16:04:55 <danharaj> I would commandeer the 'type' keyword and pair it with a 'kind' keyword.
16:05:14 <shachaf> Bor0: What?
16:05:31 <shachaf> Bor0: I'm not quite sure what you mean by "unit law"and I'm not at all sure what you mean in your example.
16:05:47 <Bor0> I'm trying to understand why the 2 specific axioms are stated as a rule in the definition of category
16:06:03 <Bor0> that is associativity and identity
16:06:22 <benmachine> Bor0: mostly because there are many examples of structures with such a composition law
16:06:40 <mm_freak> Bor0: also there is a structure called semigrouoid
16:06:45 <danharaj> does anyone know how long ghc takes to build about?
16:06:46 <mm_freak> it's category without identity
16:07:04 <benmachine> you need associativity to make sense of commutative diagrams
16:07:14 <benmachine> I'm not sure what category theory would be without commutative diagrams :P
16:07:33 <mm_freak> i'm not sure what any of abstract algebra would be without associativity
16:07:41 <danharaj> tree arithmetic
16:07:44 <johnw> magmoids
16:07:44 <benmachine> octonions
16:08:54 <mm_freak> associativity is very related to naturality, because it pretty much says:  don't have special cases!
16:10:12 <danharaj> uh oh I am getting errors in stage 1. :<
16:13:41 <lispy> semimagmoids with identity and inverse
16:13:56 <lispy> make not sense of all the things!
16:14:10 <lispy> danharaj: building ghc takes ~1 hour, IIRC
16:14:22 <lispy> obviously depends on the machine specs
16:14:25 <danharaj> lispy: thanks. that's not too bad… unless something goes wrong.
16:14:47 <lispy> danharaj: and it could be much faster than that if you have lots of ram and a fast harddrive
16:14:56 <lispy> I think the build can be parallelized now?
16:15:01 <danharaj> interesting
16:18:42 <carter> danharaj what arch? theres some nightlies depending on your arch / os
16:18:58 <danharaj> carter: building 7.6.3 with a few patches on os x.
16:19:04 <carter> oo
16:19:06 <carter> what patches?
16:19:16 <danharaj> some bug fixes
16:19:20 <danharaj> nothing exciting :)
16:19:26 <carter> which ones
16:19:30 <danharaj> I forget.
16:19:36 <carter> hehe
16:19:39 <danharaj> I was following instructions :P
16:19:48 <carter> zh
16:19:49 <carter> ah
16:26:53 <Peaker> @index evalWriter
16:26:54 <lambdabot> bzzt
16:27:13 <Peaker> This should exist, since "listen" makes Writer useful even for ordinary value generation
16:28:48 <b2coutts> is there a way to get ghci to just print the contents of a string? It doesn't work the way I want with backslashes; I just want it to print one character for each character in the list
16:30:15 <Peaker> b2coutts, putStr theStr
16:30:35 <b2coutts> Peaker: thanks
16:42:46 <Ghoul_> > (flip id) 3 (+3)
16:42:47 <lambdabot>   6
16:49:54 <ezrios> uh oh
16:50:06 <ezrios> what's with hoogle?
16:50:25 <ezrios> I clicked a link from google and then was prompted to download a BIN file?
16:50:39 <shachaf> We decided we didn't want it anymore so we deleted it, I guess.
16:50:43 <shachaf> Nobody liked it anyway.
16:50:58 <shachaf> lispy: Any idea?
16:51:10 <shachaf> Oh, wait, all of haskell.org is gone.
16:51:16 <shachaf> lispy!
16:51:17 <monochrom> yikes
16:51:26 <ezrios> has the site been compromised?
16:51:30 <CADD> wow
16:51:38 <ezrios> this BIN download prompt is kind of sketchy
16:51:42 <CADD> i can confirm on all accounts
16:51:52 <tac> What are the various options for serialization in Haskell?
16:51:59 <bitonic> tac: binary, cereal, Show
16:52:02 <tac> I see there's the Data.Serialize class
16:52:12 <elliott> shachaf: you must be mistaken
16:52:15 <tac> hehe, cereal
16:52:19 <elliott> when I go to http://haskell.org/ it clearly tells me it works
16:52:24 <monochrom> no no, www.haskell.org (the wiki) and hackage are still up
16:52:25 <bitonic> yeah, works here too
16:52:31 <shachaf> Oh.
16:52:36 <ezrios> elliott: try http://haskell.org/hoogle
16:52:37 <shachaf> It's just the redirect for www.
16:52:39 <elliott> uh, I disagree with monochrom
16:52:42 <bitonic> “It works!”
16:52:43 <elliott> oh hm
16:52:45 <bitonic> www.haskell.org works
16:52:47 <elliott> right with the www.
16:52:50 <ezrios> what about hoogle
16:52:51 <shachaf> ezrios: elliott was making a joke.
16:52:59 <ezrios> shachaf: ._.
16:53:01 <ezrios> whoosh
16:53:15 <elliott> ezrios: I was joking about the placeholder page at http://haskell.org/
16:53:22 <lispy> um
16:53:37 <roboguy_> does the hoogle command line program access the internet? that still works for me
16:53:57 <chreekat> Trying to reload a Hoogle tab I had open prompts me for a download as well
16:54:11 <ezrios> odd
16:54:20 <chreekat> a force-reload, anyway
16:54:28 <sclv> we're in the middle of a haskell.org migration
16:54:32 <sclv> not sure of the exact status
16:54:38 <ezrios> ah I see
16:54:43 <CADD> good to hear
16:55:34 <shachaf> The Hoogle issue looks like a misconfigured CGI thing or something.
16:55:45 <volv0x> Hello.
16:55:49 <ezrios> hullo
16:56:00 <pentace> Is there already a function for simultaneously finding the minimum and maximum elements of a list?
16:56:39 <ezrios> pentace: and doing what with them?
16:56:53 <pentace> returning them
16:57:58 <chreekat> > (minimum &&& maximum) [1..10]
16:57:59 <lambdabot>   (1,10)
16:58:01 <monochrom> passing them to the continuation :)
16:58:28 <pentace> chreekat: Will that traverse the list twice?
16:58:30 <shachaf> Unfortunately minimum &&& maximum can lead to bad space usage with big lists.
16:58:40 <elliott> thankfully you can zip folds!!
16:58:41 <monochrom> it will traverse the list twice
16:58:54 <sclv> shachaf: we're in the middle of a haskell.org migration to a new box
16:59:02 <sclv> sorry for the lack of annuncements on this
16:59:11 <sclv> anyway, its going to lead to some odd dislocations for a bit
16:59:16 <shachaf> sclv: Right, I heard.
16:59:31 <shachaf> Any idea how long it should last?
17:00:01 <sclv> unfortunately no idea
17:00:28 <sclv> i'm not quite sure the whole story
17:00:37 --- mode: ChanServ set +o shachaf
17:01:20 --- topic: set to 'haskell.org in the middle of migration; expect turbulence | http://haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by shachaf
17:01:25 --- mode: shachaf set -o shachaf
17:01:37 <shachaf> "thank you for using #haskell"
17:02:08 <ion> coẗurbulence
17:02:15 <ion> “HAND”
17:11:01 * hackagebot free-game 0.9.3.4 - Create graphical applications for free  http://hackage.haskell.org/package/free-game-0.9.3.4 (FumiakiKinoshita)
17:22:48 <erisco> is there a tool to automatically rewrite haskell programs by substitution step by step?
17:23:07 <erisco> such a thing by hand is laborious and error-prone
17:24:58 <shachaf> That's why I pay elliott to do it for me.
17:25:17 <CADD> edwardk: you can check out template-haskell
17:25:22 <CADD> edwardk: ff sorry
17:25:25 <edwardk> ?
17:25:31 <CADD> erisco: you can check out template-haskell
17:25:35 <edwardk> hah
17:25:38 <CADD> edwardk: :)
17:25:51 <erisco> CADD, I thought that was for meta programming?
17:25:52 <shachaf> template-haskell seems completely unrelated to what erisco wants.
17:26:16 <CADD> erisco: isnt that programs writing programs?
17:26:26 <erisco> yes indeed, but that isn't what I want
17:26:34 <CADD> shachaf: it can generate haskell code
17:26:48 <erisco> CADD, I'll show you what I mean.
17:26:57 <CADD> erisco: excellent
17:33:31 <roboguy_> erisco: what about rewrite rules? is that the sort of thing you mean?
17:33:39 <erisco> yeah
17:33:46 <erisco> some program that would give me output like this: http://lpaste.net/90914
17:34:31 <erisco> that would help tremendously with solving some issues I'm having...
17:35:01 <shachaf> No, GHC rewrite rules have almost nothing to do with that also.
17:35:13 <shachaf> There's a website that does the sort of thing you want for a simple language similar to Haskell.
17:35:23 <shachaf> But I can't remember its name.
17:35:29 <geekosaur> (g)hood?
17:35:30 <CADD> erisco: ok, so you are saying that instead of fac, you can pass any arbitrary function?
17:35:36 <erisco> CADD, no
17:35:57 <erisco> CADD, well, yes, I would want to show a trace of more than just fac, if that is what you mean
17:36:07 <CADD> erisco: exactly
17:36:25 <erisco> shachaf, what do you mean ghc has nothing to do with it?
17:36:34 <roboguy_> erisco: ghc rewrite rules
17:36:35 <CADD> erisco: so you wouldnt just be calling fac? you would be passing fac in with its arguments to a "tracer" function right?
17:36:43 <roboguy_> erisco: not ghc in general
17:36:58 <geekosaur> http://www.ittc.ku.edu/csdl/fpg/software/hood.html
17:37:04 <erisco> CADD, probably some interpreter shell would load the program and allow me to evaluate expressions
17:37:07 <geekosaur> @hackage hood
17:37:07 <lambdabot> http://hackage.haskell.org/package/hood
17:37:15 <erisco> roboguy_, yes, I know what he said
17:37:15 <CADD> so line 7 would be more like > trace fac 3
17:37:20 <CADD> erisco: ^
17:37:25 <erisco> um, sure
17:37:52 <tij_> www.haskell.org/hoogle keeps giving me downloads... anyone know why?
17:38:05 <erisco> I don't care how the program works particularly so long as I can see how the evaluation works ... particularly with what is being forced and in what order
17:38:16 <geekosaur> I think someone said haskell.org was being worked on today?
17:38:17 <CADD> erisco: hmm, i see what you are trying to do.
17:38:35 <CADD> erisco: let me see what i can find
17:39:43 <CADD> erisco: although TH does sound pretty close to what you might want. although shachaf may want to chime in
17:39:45 <geekosaur> erisco: so, did you happen to notice *anything* that I just pointed you at?
17:40:01 <erisco> it wasn't highlighted ... sorry no :P
17:40:12 <geekosaur> http://www.ittc.ku.edu/csdl/fpg/software/hood.html
17:40:23 <geekosaur> @hackage hood
17:40:23 <lambdabot> http://hackage.haskell.org/package/hood
17:40:31 <erisco> I see it now :)
17:40:35 <geekosaur> (also ghood which is a gui for it)
17:40:38 <CADD> geekosaur: hey that works much better than what i was thinking
17:43:48 <erisco> geekosaur, hm... I don't know how useful this will be if it expects the observed function to actually return
17:44:02 <erisco> geekosaur, I am trying to work out a problem with my function hanging
17:44:40 <CADD> erisco: maybe just post the problem code?
17:44:46 <geekosaur> oh. then you want :step in ghci
17:44:56 <CADD> geekosaur: exactly
17:45:14 <erisco> I have. it is somewhat complex. I have an idea of what may be wrong, but the most direct way to verify that would be experiment
17:45:53 <erisco> geekosaur, I will try that, I suppose... never made head or tails of what it was telling me last time I used it
17:46:16 <erisco> could follow it for 4-5 steps and then, because you can't see the entire stack together, lost what was happening completely
17:46:19 <geekosaur> possibly :trace instead
17:47:49 <geekosaur> beyond thta, Debig.Trace.trace at strategic spots maybe
17:47:58 <CADD> erisco: also http://hackage.haskell.org/packages/archive/base/latest/doc/html/Debug-Trace.html
17:49:17 <erisco> ah damn... :step tries to show an infinite list -.-
17:49:38 <geekosaur> beyond that, well, debugging haskell is somewhat difficult because its evaluation model is so different
17:50:07 <CADD> geekosaur: if only lispm..
17:52:42 <CADD> erisco: https://en.wikibooks.org/wiki/Haskell/Debugging
17:53:03 <CADD> erisco: there is even fib right there :)
17:55:24 <b2coutts> if commas in lists weren't necessary to separate tokens, should they still be included for readability?
17:55:53 <b2coutts> i.e. ["1" "3" "5"] vs. ["1","3","5"]
17:56:13 <banister> is it best to do myfunc $ length x    or (myfunc . length) x ?
17:56:21 <b2coutts> I think the left representation looks somewhat cleaner, but could easily become convoluted and unreadable for larger expressions
17:56:37 <b2coutts> banister: myfunc $ length x would be the typical way
17:56:49 <erisco> banister, myfunc . length $ x    even :D
17:57:19 <roboguy_> b2coutts: you'd have to change function application syntax too
17:57:28 <b2coutts> roboguy_: yeah, it's not specifically for haskell
17:57:52 <b2coutts> I'm inventing a language for fun, and all functions take a fixed number of arguments
17:58:26 <b2coutts> so the expression [map add1 lst 3 5] unambiguously means [(map add1 lst), 3, 5]
17:58:43 <elliott> like LOGO.
17:58:56 <b2coutts> and I'm debating whether or not to include commas in these lists, as the left one above is confusing
17:59:33 <roboguy_> b2coutts: if those are the choices, I would go with commas
17:59:55 <roboguy_> so you don't need to know the number of arguments of all the functions off the top of your head to read it
17:59:55 <b2coutts> elliott: !
18:00:20 <b2coutts> I hadn't found another language like this, but it _does_ look pretty similar to logo
18:00:32 <Chat9295> u
18:00:44 <elliott> I think maybe also like REBOL? not sure.
18:00:54 <b2coutts> roboguy_: I was leaning toward commas
18:01:01 <b2coutts> it also makes errors a bit less cryptic
18:01:28 <b2coutts> if you accidentally omitted an argument to a function in a list without commas, the resulting error message would probably be terribly confusing
18:01:57 <b2coutts> elliott: this idea for a language is fairly silly, but the language is extremely easy to parse and write a basic interpreter for
18:02:20 <b2coutts> it seems like a good idea for an introductory CS course or something
18:06:16 <b2coutts> actually looking more into it LOGO is pretty different
18:07:06 <b2coutts> it just sort of looked similar because it has a lot of words and not a lot of punctuation
18:11:06 <CADD> b2coutts: they call LOGO "lisp without the parens"
18:11:19 <CADD> b2coutts: for kids..
18:11:33 <b2coutts> CADD: hahaha yeah, this is how I've been explaining my language to people
18:11:50 <CADD> b2coutts: well great!
18:12:52 <CADD> b2coutts: anything else you want to share about your language? There are quite a few PLT nerds in here.
18:15:02 <b2coutts> CADD: it's been a pretty interesting project. A weird/cool side effect of this language is that, despite the fact that it's structurally almost identical to LISP, the code tends to end up looking like imperative code
18:15:42 <b2coutts> i.e., let is a function that takes 3 arguments, evaluating the last argument using a binding created with the first 2 arguments
18:15:57 <b2coutts> so you can put let statements one after another without indentation as if you were writing C code
18:16:23 <b2coutts> and if is just the regular ternary if, but if you define else as the identity function, you can create if/else if/else trees in exactly the same way you'd do it in C
18:17:42 <b2coutts> most of what I've been struggling with is figuring out how lambas should work
18:18:54 <CADD> b2coutts: interesting
18:19:39 <CADD> b2coutts: well, although i dont want to confuse you more. Have you heard of vau? I'm a fan of fexprs and its a bit more conceptually simpler than lambda.
18:19:48 <Ralith> CADD: vau :D
18:19:52 <Ralith> fucking love kernel
18:19:53 <CADD> Ralith: XD
18:19:56 <CADD> Ralith: ikr?
18:20:08 <Ralith> shutt's work is not nearly as well known as it should be
18:20:12 <Bor0> how many times do I have to go across the feeling "I finally get monads" before I actually do?
18:20:18 <CADD> Ralith: tell me about it! :)
18:20:24 <Ralith> though admittedly it's pretty hard to apply to a statically compiled language
18:20:29 <geekosaur> Bor0, it varies :)
18:20:45 <CADD> Bor0: what monad?
18:20:47 <applicative> Bor0: dont worry
18:20:53 <Bor0> I'm right now looking at the Maybe monad and it all looks perfectly fine and makes sense but tomorrow mightn't be that case
18:20:56 <roboguy_> b2coutts: sounds pretty much like a lisp-style let to me
18:20:59 <geekosaur> although really the best approach is kinda zen: don't try to get monads, just use them. eventually you will develop the understanding
18:21:02 <CADD> Ralith: sure sure, there are all those arguments
18:21:25 <applicative> Bor0: people dont too much use the monadic-ness of Maybe
18:21:27 <Ralith> it's not an argument, it's a fact: fexprs need runtime evaluation, and a very smart static optimizer.
18:21:32 <CADD> Ralith: but i enjoy the simplicity and im sure there might be some clever stuff coming out soon
18:21:40 * b2coutts googles about vau
18:21:40 <CADD> Ralith: right
18:21:42 <Ralith> of course if you're writing an interpreted language *anyway* they're a nobrainer.
18:21:56 <b2coutts> roboguy_: it's exactly like a lisp-style let, but without the brackets
18:22:03 <CADD> Ralith: yeah, its nice since they are so simple
18:22:10 <Ralith> outright beautiful
18:22:18 <b2coutts> it's just an interesting side effect that once you remove the side effect, it basically looks like procedural code
18:22:20 <CADD> Ralith: precisely!
18:22:20 <applicative> Bor0: I take it the functor-ness of Maybe isn't a problem?
18:22:27 <ab9rf> geekosaur: tend to agree, i think spending too much time trying to 'get' monads just wastes time you could be spending using monads
18:22:28 <Ralith> though stack depth can get a bit scary
18:22:45 <b2coutts> my language also has a different concept of lambdas from lisp or vau, though
18:22:49 <CADD> Ralith: the great thing is that our machines these days can take it
18:22:52 <Bor0> if you tell me what you mean by functorness :)
18:22:57 <Ralith> CADD: depends what you're doing.
18:23:03 <applicative> > fmap even (Just 2)
18:23:04 <lambdabot>   Just True
18:23:10 <Ralith> I mostly work on stuff that uses our machines these days to their fullest
18:23:13 <Ralith> or tries to, anyway
18:23:16 <b2coutts> the function that multiplies both its arguments is {* ,1 ,2}
18:23:17 <ab9rf> CADD: i want to strangle everyone who says that it's ok that my code is inefficient because computers are so fast anyway
18:23:19 <CADD> Ralith: true enough, but then at that point there are things like forth and such
18:23:30 <Ralith> ah, but why settle for that?
18:23:31 <Bor0> applicative, do you mean the "conversion" between  "x" and "Just x"?
18:23:40 <Ralith> CADD: are you aware of idris?
18:23:45 <CADD> ab9rf: depends on what you are doing
18:23:51 <CADD> Ralith: somewhat
18:23:57 <b2coutts> and tentatively the factorial function is {* ,1 ,0 - ,1 1}
18:23:58 <Ralith> CADD: partial evaluation?
18:24:00 <CADD> Ralith: dependent typing?
18:24:03 <Ralith> that too
18:24:05 <ab9rf> CADD: trying to reduce the amount of power consumed and heat generated by data centers
18:24:08 <applicative> Bor0: with fmap you go inside the Maybe (if it isn't Nothing) and replace x by f x
18:24:08 <CADD> CADD: well yeah
18:24:17 <b2coutts> (which incidentally is also a good example of how incomprehensible this language is without proper spacing/indentation)
18:24:21 <CADD> Ralith: well idris has dep typing, right?
18:24:21 <applicative> Bor0: since you can do this, it's a functor, same as lists
18:24:25 <Ralith> CADD: yes
18:24:27 <applicative> YES
18:24:32 <Bor0> applicative, yeah I think I get that
18:24:33 <Ralith> CADD: what I'm getting at is that partial evaluation and dependent typing and EDSLs are a match made in heaven
18:24:36 <ab9rf> CADD: also, trying to get the battery in my phone to last longer
18:24:46 <ab9rf> CPU is not an unlimited resource
18:24:53 <CADD> ab9rf: i know, that is all there. its not like im advocating understanding of optimizing your code
18:24:56 <Ralith> CADD: you can apply the first futamura projection to compile EDSLs more or less by magic
18:25:09 <CADD> s/understandign/misunderstanding/
18:25:12 <Ralith> all while building incredibly expressive and safe EDSLs
18:25:18 <Ralith> very exciting
18:25:20 <applicative> but suppose I have a function Int -> Maybe Char, and I apply it to Just 2
18:25:24 <Ralith> but altogether incompatible with runtime eval
18:25:51 <Ralith> (the AST of the program must be statically known)
18:25:59 <applicative> Bor0: I go inside, replace 2 with f 2, say Just 'C', and get Just (Just 'C')
18:26:24 <roboguy_> b2coutts: I'm not sure I understand what the numbers mean in that context
18:26:38 <b2coutts> roboguy_: ,N refers to the Nth argument
18:26:49 <b2coutts> and the 0th argument is the function itself
18:27:00 <b2coutts> so recursion can happen in lambdas
18:27:06 <CADD> Ralith: this sounds all really great, do you have anything i could read about futamura projections with EDSLs?
18:27:12 <applicative> Bor0: that its a monad basically means i can collapse this to Just 'C', by doing Just 2 >>= f , rather than fmap f (Just 2)
18:27:22 <b2coutts> (though if I end up using commas in lists I may have to use different notation for this)
18:27:32 <Ralith> CADD: http://www.cs.st-andrews.ac.uk/~eb/writings/icfp10.pdf describes this particular implementation
18:27:49 <Ralith> CADD: the futamura projections are themselves simple, wikipedia will do you fine there; the challenge is in implementing them
18:27:49 <b2coutts> the language could still be unambiguous, but having a list like [,1,,2,,3] might be confusing
18:27:52 <CADD> Ralith: Thanks! I'll take a look!
18:27:52 <Bor0> applicative, yeah. so from what I understood so far basically monad is a few things. it can use side effects and do data types conversion?
18:28:05 <b2coutts> actually wait no it would be ambiguous
18:28:09 <Bor0> applicative, depending on how we define bind and return
18:28:20 <ab9rf> monads "do" all sorts of things
18:28:24 <ab9rf> don't focus on what they do
18:28:28 <applicative> data types conversion I don't get.
18:28:40 <Bor0> applicative, convert Int to Maybe Int?
18:28:47 <applicative> I think the point is, if you think about it in the abstract, it doesn't reall come to much
18:29:22 <Ralith> CADD: in summary, the motivation is to be able to throw together high level DSLs that reduce to efficient--even non-allocating--code all in an expressive functional host langugae
18:29:36 <applicative> Oh i see, Bor0 , return 1 converts Int to Maybe Int
18:29:37 <applicative> yes
18:29:48 <Bor0> great!
18:30:13 <CADD> Ralith: Wow, even non-allocating?
18:30:16 <CADD> Ralith: thats really big
18:30:19 <applicative> but the downward way is just as important, you can collapse Maybe (Maybe Int) to Maybe Int
18:30:21 <roboguy_> b2coutts: hmm, seems like it might be kind of hard to tell how many arguments a function takes by looking at it
18:30:46 <applicative> > join (Just (Just 1))
18:30:47 <b2coutts> roboguy_: currently the idea is that you would just traverse the AST of a lambda and find the largest ,N
18:30:47 <lambdabot>   Just 1
18:31:03 <CADD> Ralith: Its amazing how often you hear about the problem of garbage in fp. This looks amazing.
18:31:03 <roboguy_> b2coutts: well, I mean, for someone looking at the code
18:31:03 <b2coutts> but this has issues such as when you want to make a function that takes two arguments and returns its first argument
18:31:06 <applicative> > concat [[1],[2,3]]
18:31:07 <lambdabot>   [1,2,3]
18:31:10 <Bor0> > Just (Just 3) >>= (\t -> t)
18:31:11 <lambdabot>   Just 3
18:31:24 <applicative> yes, >>= id is join
18:31:42 <CADD> Ralith: Now im guessing the non-allocating is in specific constraints?
18:31:46 <b2coutts> roboguy_: yeah, that too; these lambdas probably wouldn't be too self-descriptive
18:31:50 <applicative> >  [[1],[2,3] >>= id
18:31:51 <lambdabot>   <hint>:1:18:
18:31:51 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
18:31:55 <b2coutts> but they'd be extremely nice for passing to a higher-order function
18:31:56 <applicative> >  [[1],[2,3]] >>= id
18:31:56 <lambdabot>   [1,2,3]
18:32:26 <applicative> so concat is >>= id
18:33:16 <Bor0> neat
18:33:17 <Ralith> CADD: an appropriately designed EDSL may reduce to non-allocating code, yes; 'appropriately designed' approximately meaning that execution of the described program does not inherently require allocation--for example, it might be reducible to code which handles only in-register values
18:33:45 <Bor0> applicative, but if we were to implement our Monad, we define what bind and return do, right?
18:34:03 <applicative> Bor0: >>= for lists is concatMap, flip concatMap rather
18:34:17 <roboguy_> b2coutts: it sort of reminds me of APL and it's predecessors FL and FP, but I don't think you can directly access arguments at all in those languages
18:34:17 <Ralith> CADD: to be clear, this isn't currently available--idris has undergone a full rewrite since that paper and the partial evaluator hasn't yet been reimplemented, and some additional functionality in the vein of ST plus a few new optimization passes would likely be necessary to fully realize nonallocation
18:34:33 <applicative> yes, for list, bind = flip concatMap; return is (:[])
18:34:39 <Ghoul_> is it possible to use magic to have a type which is created as a side effect to making an instance of some class
18:34:41 <applicative> i.e. singleton
18:34:49 <Ralith> CADD: but the potential is absolutely there, and close to realization
18:34:52 <ab9rf> monkey operator
18:34:53 <CADD> Ralith: Interesting.
18:35:03 <CADD> Ralith: gotta love research languages right?
18:35:11 <Ralith> that's why I'm working on one ^^
18:35:15 <Bor0> I see. so now would you suggest to look at the sources and see why some basic monads are implemented as such, that is why would it be natural to define bind/return as it is?
18:35:33 <Bor0> or I shouldn't spend much time on it?
18:35:35 <CADD> Ralith: I havent taken a good look at irdis yes, I'm definatly going to have to take a look now.
18:35:39 <applicative> Ghoul_: I think with something like data families, and the associated types business that comes with TypeFamilies?
18:35:42 <ab9rf> Bor0: spend time on it, you won't learn if you don't
18:35:58 <Ghoul_> I'll take a look at it and see if it's what I need, thanks
18:36:04 <Bor0> okay, thanks. I just need a reassurance that I'm going the right way
18:36:09 <Ralith> CADD: let me know if you have any questions!
18:36:12 <ab9rf> Bor0: there is no right way
18:36:14 <Ralith> CADD: there's also #idris
18:36:19 <CADD> Ralith: will do!
18:36:20 <ab9rf> Bor0: except the one in which you learn things
18:36:23 <CADD> Ralith: Yes!
18:36:29 <Bor0> =)
18:36:50 <applicative> Bor, it's well worth implementing the 'monad' methods for typical types yes
18:36:59 <bel3atar> does hakell run on haswell?
18:37:08 <Bor0> okay, great. thanks applicative and ab9rf
18:37:33 <Ralith> bel3atar: haswell implements x86_64, does it not?
18:37:36 <applicative> Bor0: keep in mind the important point that x >>= f = join (fmap f x) , so that if you have a functor instance the main thing is to define join (concat)
18:37:52 <applicative> Bor0: I mean, it is often easier to see whats up this way
18:38:04 <CADD> Ralith: are there any channels for klisp/fexprs in general?
18:38:30 <applicative> join (Just (Just a)) = Just a ; join Nothing = Nothing; join (Just Nothing) = Nothing
18:38:48 <b2coutts> I think I just realized my idea for a programming language doesn't work
18:39:07 <b2coutts> it's impossible to short-circuit; in order to properly evaluate a program, you have to evaluate every single word
18:39:30 <b2coutts> so `if 1 print "asdf"    print "fdsa"' would print both asdf and fdsa
18:39:49 <b2coutts> (and in general, always running every word in a program is probably not good)
18:39:52 <Ralith> CADD: not to my knowledge, though I haven't been very alert in lispy circles since becoming more interested in type systems
18:40:24 <CADD> Ralith: ok, thanks!
18:41:37 <roboguy_> b2coutts: could you make it lazy?
18:42:14 <Ralith> static typing, I should say, rather than type systems at large
18:43:05 <b2coutts> roboguy_: that was my original intent
18:43:47 <b2coutts> but the essential problem is that you can't necessarily know how many arguments functions have at compile-time
18:44:14 <b2coutts> i.e. `let function   if read-line   {+ ,1 ,2}   {,1}'
18:44:25 <b2coutts> and so the only way to tell when a block of code ends is by evaluating it
18:44:44 <Ghoul_> Hmm, type families may be the go but I don't think it will help me with needing to let the programmer declare instance declarations for the related type. What I need to do is have a `data History a = History a [Deltas]` but have the type Deltas decided on what `a` is. Deltas would look something like this for Int: `data Delta = Increment Int | Decrement Int`
18:44:44 <Ghoul_> and it'd need ie: the instance function `forward (Increment n) x = x + n; forward (Decrement n) x = x - n; ....`
18:45:14 <roboguy_> b2coutts: I was thinking about that, but couldn't you determine it by finding the largest ,N in all the code branches before you evaluate anything?
18:45:45 <roboguy_> since you can't "hide" argument access in a call to another function
18:46:53 <b2coutts> roboguy_: I mean, you could find the largest possible number of arguments for the function, but if read-line evaluated to false in the above example, I'd expect function to take only one argument
18:47:33 <roboguy_> wouldn't that go against the other idea, of each function taking a fixed number of arguments though? wouldn't it have to take 2 either way?
18:48:01 <b2coutts> well you aren't defining a function that takes 1 or 2 arguments, you're defining function such that it is either a function of 1 arguments, or it's a function of 2 arguments
18:48:13 <b2coutts> I suppose this could also be fixed via strict typing
18:49:52 <Anarch> `Lynx www.haskell.org` works, but `Lynx haskell.org` gives a default page that led me to believe haskell.org was not available.  Should I just mail <webmaster@$there>?
18:49:59 <b2coutts> I guess I could also make if take lambas as its second and third arguments
18:50:15 <b2coutts> so both parts are defined, but only one of them is executed
18:51:03 * hackagebot HOpenCV 0.1.2.4 - A binding for the OpenCV computer vision library  http://hackage.haskell.org/package/HOpenCV-0.1.2.4 (NoamLewis)
19:00:11 <optimusbrine> b2coutts, I noticed that a few years ago and I think i sent an email, but there didn't really seem to be anyone interested in fixing it
19:00:13 <relrod> Anarch: see first part of /topic
19:02:21 <optimusbrine> errr, @ Anarch
19:02:49 <elliott> this is a new, temporary problem, afaik
19:03:12 <shachaf> Well, it's new, at least.
19:07:08 <optimusbrine> idk, maybe I made that up. But I seem to remember no-www not even resolving to something with a web server a few years ago. *shrug* nvm
19:09:25 <scshunt> help
19:09:27 <scshunt> template haskell
19:12:56 <CADD> scshunt: what about it?
19:13:04 <scshunt> I'm crashing GHC :(
19:13:16 <CADD> code and error?
19:13:48 <Nisstyre> scshunt: is it panicking?
19:14:42 <scshunt> the problem appears to be putting a splice inside a lambda or a comprehension :(
19:15:39 <scshunt> how do I take a list of Qs and splice them into a list of things?
19:16:17 <CADD> scshunt: homogeneous lists.
19:16:38 <scshunt> CADD: ohhhh
19:16:45 <scshunt> what's the lifting function then?
19:17:27 <CADD> scshunt: http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH.html#g:18
19:17:49 <scshunt> CADD: thanks
19:17:56 <CADD> scshunt: np
19:21:24 <scshunt> CADD: works!
19:21:30 <scshunt> listE was what I needed
19:21:42 <CADD> scshunt: :)
19:21:53 <scshunt> thanks much
19:22:02 <CADD> scshunt: mind if i ask what you are working on? TH is one of my favorite libs.
19:22:10 <CADD> scshunt: youre welcome
19:22:28 <scshunt> CADD: Working on a Yesod system; it uses a lot of TH and I'm trying to go one level deeper by making a plugin architecture
19:22:40 <CADD> scshunt: ah yes yesod.
19:22:58 <scshunt> so rather than loading from one config file, one file splices in a list of plugins, and then the config is spliced in from all of the plugins
19:23:23 <CADD> interesting
19:24:33 <DigitalKiwi> scshunt: create a wordpress killer!
19:24:46 <scshunt> DigitalKiwi: :P
19:24:57 <CADD> XD
19:25:11 * scshunt wonders if it would be worth stashing the project away once the plugin base is done so as to make it reusable, potentailly
19:25:14 <scshunt> *potentially
19:25:35 <CADD> the community would love it
19:25:46 <enthropy> scshunt: does it really count as plugins if it's all done at compile time?
19:26:09 <DigitalKiwi> sure why not?
19:26:11 <scshunt> ^
19:26:19 <scshunt> enthropy: you recompile just to add a page, so I think so, yes
19:26:21 <DigitalKiwi> wordpress plugins are all done at compile time too
19:26:42 <DigitalKiwi> just that compile time and run time are the same ;)
19:27:16 <CADD> DigitalKiwi: if only lispm..
19:27:26 <DigitalKiwi> what's that
19:27:32 <CADD> symbolics
19:28:10 <CADD> DigitalKiwi: https://en.wikipedia.org/wiki/Lisp_machine
19:29:04 <DigitalKiwi> oh
19:29:24 <scshunt> hmm
19:29:32 <CADD> DigitalKiwi: yup, lisp on silicon
19:29:48 <scshunt> I think I will still have to play around with the plugin system enough that making it properly robust will take some time
19:29:55 <tabemann> lisp machines were neat, but ultimately producing compilers that created efficient code for stock hardware was a better idea
19:30:12 <ezrios> scshunt: uwaterloo?
19:30:15 <scshunt> ezrios: yes
19:30:17 <ezrios> :o
19:30:21 <CADD> since we are on the topic of alternative architectures: https://en.wikipedia.org/wiki/Burroughs_large_systems
19:30:24 <ezrios> I thought I recognized your name from somewhere
19:30:52 <CADD> tabemann: The burroughs systems were 100s of times faster than the other archs around at the time
19:31:42 <CADD> tabemann: so i dont think there is really one really "best" idea, its just that setup favored commecialization at the time
19:32:43 <enthropy> scshunt: have you looked at how gitit does things?
19:32:46 <scshunt> no
19:32:47 <DiegoNolan> what does RWS stand for in Control.Monad.RWS.Strict
19:33:10 <danharaj> Reader Writer State
19:33:12 <enthropy> there were some plugin-like things a couple years ago I last looked into it
19:33:25 <CADD> enthropy: gitit is awesome
19:33:56 <optimusbrine> doesn't lambda bot have a plugin system?
19:33:59 <tabemann> CADD: of course the real problem with lisp machines was a matter of that they required commercial support for specialized hardware, whereas free software lisp compilers for stock hardware need none
19:34:05 <DiegoNolan> oh
19:34:35 <tabemann> so when things took a dip in funding for projects using lisp machines...
19:35:11 <scshunt> enthropy: it doesn't appear to be quite the sort of thing I'm looking for, but thanks for me!
19:39:26 <chrisdotcode> hi all :)
19:40:06 <chrisdotcode> so guys, the haskell-platform package isn't in the linux mint 15 repos...
19:40:11 <chrisdotcode> does anyone have a ppa link?
19:41:09 <CADD> chrisdotcode: you would probably want to try: http://community.linuxmint.com/tutorial/view/12
19:41:59 <LordBrain> http://community.linuxmint.com/software/view/haskell-platform
19:43:03 <CADD>  #linuxmint-help
19:43:11 <roboguy_> I wonder what a haskell machine would be like
19:43:27 <zRecursi`> heh
19:43:28 <CADD> roboguy_: omg.
19:43:53 <LordBrain> There was that haskell os
19:43:57 <LordBrain> is it dead?
19:44:07 <elliott> @@ roboguy_: @where reduceron
19:44:07 <lambdabot>  roboguy_: http://www-users.cs.york.ac.uk/~mfn/reduceron/index.html
19:44:07 <CADD> roboguy_: well, you should take a look at this. http://www.greenarraychips.com/
19:44:31 <CADD> elliott: 404
19:45:01 <elliott> @where+ reduceron http://www.cs.york.ac.uk/fp/reduceron/
19:45:01 <lambdabot> It is forever etched in my memory.
19:45:03 <elliott> @@ roboguy_: @where reduceron
19:45:03 <lambdabot>  roboguy_: http://www.cs.york.ac.uk/fp/reduceron/
19:45:53 <chrisdotcode> CADD, LordBrain: Yeah, I was gonna try there next. I wasn't sure if it was anyone in here's fault, or if it was their fault ;)
19:46:23 <nbouscal> When I navigate to Hoogle it attempts to download a 28MB file, anyone experiencing the same problem and/or know what's going on?
19:46:27 <CADD> chrisdotcode: yeah, sounds os specific. good luck and have fun!
19:46:41 <CADD> nbouscal: yup, check topic
19:46:49 <nbouscal> oh, copy that
19:47:09 <nbouscal> thanks
19:47:13 <CADD> nbouscal: np
19:47:19 <roboguy_> that's pretty cool
19:56:39 <Ghoul_> In `class (MonadState s m) => MonadTime s m | m -> s where` what does the | denote?
19:57:20 <CADD> Ghoul_: that is a functional dependency
19:57:27 <enthropy> Ghoul_: it means there's only one `s' for any particular `m'
19:57:41 <CADD> Ghoul_: http://www.haskell.org/haskellwiki/Functional_dependencies
19:57:41 <enthropy> well it separates the -> that means it
19:58:04 <Ghoul_> Uh, okay, I don't really understand that so I'll read up. Thanks for the link
19:58:51 <CADD> Ghoul_: np
19:59:04 <CADD> Ghoul_: best way to learn
20:06:12 <Ghoul_> OK, this is way over my head but I've written this: `class (MonadState s m, Keystone s e) => MonadTime s e m | m -> s where` where `class Keystone s e`, so is this the kind of condition that I should really be letting it know that s -> e since the type of e is dependent on s in instance declarations?
20:07:40 <johnw> you'd use s -> e if you wanted there to be only one possible instance for any s + e pair
20:08:01 <johnw> so, if you had Int Double, you couldn't have Int Char
20:08:06 <Ghoul_> oh, okay
20:15:20 <carter> jfischoff hows things? :)
20:15:24 <mchm> Hi.
20:15:40 <jfischoff> good man how is NYC?
20:16:33 <jfischoff> I am writing a parser for this. http://chadaustin.me/papers/Renaissance%202005.pdf
20:16:35 <mchm> I have stumbled upon this (http://lisperati.com/haskell/) tutorial. I cannot run the code from the second example using the latest GHC under OSX.
20:17:32 <CADD> jfischoff: woah neat
20:17:56 <CADD> mchm: which part?
20:18:03 <mchm> If anybody has the time to check why it doesn't work, thank you!
20:18:21 <CADD> mchm: code and error
20:18:23 <mchm> CADD: the one beginning with "peopl_text"
20:18:31 <CADD> @@ mchm @where paste
20:18:31 <lambdabot>  mchm http://paste.tryhaskell.org/new/haskell
20:18:43 <johnw> and show us the error
20:19:04 <lpaste> mchm pasted “haskell_tut_code” at http://lpaste.net/90918
20:19:05 <carter> jfischoff NYC's decent
20:19:25 <lpaste> mchm pasted “haskell_tut_error” at http://lpaste.net/90919
20:19:36 <carter> jfischoff  neat. targeting gpu?
20:19:55 <ion> carter: The indentation is wrong. Both “people”s should start in the same column.
20:20:17 <carter> ion eh?
20:20:37 <ion> Change it so that it matches the code on the web page exactly.
20:20:37 <mchm> @ion they do
20:20:37 <lambdabot> Maybe you meant: yow wn run nixon join id do
20:21:04 <ion> carter: Sorry, i looked at the wrong line for the nick to respond to.
20:21:42 <mchm> @ion
20:21:43 <lambdabot> Maybe you meant: yow wn run nixon join id do
20:21:49 <ion> mchm: Look at what you pasted in lpaste.
20:22:12 <mchm> @ion wow, this is weird.
20:22:12 <lambdabot> Maybe you meant: yow wn run nixon join id do
20:22:18 <CADD> mchm: you lamdabot thinks any line starting with "@***" is a command to it
20:22:21 <mchm> ok
20:22:31 <ion> mchm: It may help to avoid editors that use an incorrect tab stop width, and to avoid tabs altogether.
20:22:42 <mchm> I work with Sublime Text 2, maybe that's the problem
20:22:50 <mchm> it usually isn't, but I wanted to try it instead of VIM
20:23:17 <mchm> ion: tabs were exactly the problem, I rewrote the code using spaces and it worked
20:23:25 <carter> mchm ST2-3 lets you changes things to spaces
20:23:27 <carter> oh ok
20:23:29 <carter> good :)
20:23:43 <mchm> is there a shortctut for that?
20:24:30 <tabemann> you're best off using an editor with specific haskell support, such as haskell-mode in GNU Emacs
20:24:39 <carter> tabemann ST2/3 does
20:24:45 <carter> mchm you can
20:25:11 <mchm> tabemann: ST2 apparently supports haskell-mode, but I wasn't able to install it.
20:25:12 <carter> mchm lower right  of ST#
20:25:14 <carter> yes
20:25:21 <carter> mchm i'm actually not using haskell mode right now :)
20:25:27 <carter> mchm bottom right bar
20:25:32 <carter> lets you set spaces / tabs, etc
20:25:33 <Anarch> How can I convert a string to a number?  I haven't been able to understand the documentation of Read.  Code like q{ foo "1.1" } that works at the gchi prompt would help.
20:25:48 <elliott> read "1.1" :: Double
20:25:49 <mchm> carter: Aha!
20:25:53 <elliott> (you might not want Double)
20:25:54 <carter> np
20:27:20 <Anarch> elliott: Thanks; a few more years of study and I'll understand why I couldn't figure that out myself from the error message.
20:29:10 <elliott> hehe
20:29:18 <elliott> it doesn't know what you want to read it as
20:29:21 <elliott> so you have to tell it
20:30:25 * tabemann just checked read "1.1" in GHCi, and does have to say that the error message isn't very helpful
20:30:32 <mchm> I'm definitely going back to vim!
20:30:38 <mchm> No indentation troubles there ;)
20:30:54 <mchm> thank you very much for the help, off I go to finish this tutorial!
20:34:20 <Michae___> What are good little (<1000lines) of haskell code to read?
20:35:01 <ezrios> Michae___: right now I've been fiddling around with XMonad, ~1200 LOC
20:38:00 <Anarch> mean xs = sum (xs :: [Double]) / ((length xs) :: Double) barfs "Couldn't match expected type `Double' against inferred type `Int' In the second argument of `(/)', namely `((length xs) :: Double)' In the expression: sum (xs :: [Double]) / ((length xs) :: Double)", and I also tried (length xs)+0.0, getting the same error; I'm missing something Profound, I know it ...
20:38:39 <shachaf> Anarch: Look at the type of (/) and the type of length.
20:39:12 <shachaf> If your big thing isn't working, try finding out which one of its pieces isn't working.
20:39:16 <c_wraith> Anarch: your attempt indicates you know what the problem is - but that's not how you convert types in haskell
20:39:36 <Anarch> shachaf: I see that length foo is an Int
20:39:40 <shachaf> In this case you can try ((length xs) :: Double) on its own, and see that that causes an error too.
20:39:40 <c_wraith> Anarch: there are no implicit type conversions in haskell
20:39:46 <Anarch> c_wraith: That seems likely.
20:40:20 <Anarch> c_wraith: It's not for lack of effort, I promise.
20:40:25 <c_wraith> Anarch: so, you want a function to do the conversion.  What type will it have?
20:40:31 <shachaf> So the question is about converting some value :: Int to a value :: Double.
20:40:35 <shachaf> Oops.
20:40:58 <Anarch> c_wraith: Int -> Double
20:41:04 <c_wraith> @hoogle Int -> Double
20:41:04 <lambdabot> Data.Set elemAt :: Int -> Set a -> a
20:41:04 <lambdabot> Prelude (!!) :: [a] -> Int -> a
20:41:05 <lambdabot> Data.List (!!) :: [a] -> Int -> a
20:41:10 <c_wraith> ...  sometimes I hate hoogle
20:41:12 <shachaf> Yes, well.
20:41:19 <shachaf> Anarch: The function you want is called fromIntegral.
20:41:33 <shachaf> It has a pretty general type, but it can be used for this.
20:41:36 <c_wraith> Often, you can just do a search based on the type of the function you're looking for.
20:41:46 <shachaf> :t fromIntegral
20:41:47 <lambdabot> (Integral a, Num b) => a -> b
20:41:57 <shachaf> > (fromIntegral (5 :: Int)) :: Double
20:41:57 <lambdabot>   5.0
20:42:22 <Anarch> c_wraith: Very cool answer, even though hoogle h00rked.
20:43:03 <c_wraith> In general, if you know the type of a function you're looking for, it's worth seeing if hoogle can find something
20:44:41 <johnw> i'm not sure how you can expect hoogle to find fromIntegral from Int -> Double.  Should it check every class that Int and Double are instances of, and then look for any combination that uses type variables with those constraints?
20:45:04 <Anarch> shachaf: Thanks, I've been reading every word, avidly.
20:45:27 <c_wraith> johnw: it does try that sometimes, actually.  It just needs less polymorphism than that.
20:45:27 <shachaf> johnw: Given that it sometimes finds unsafeCoerce, I don't see why not.
20:45:51 <Hafydd> That's what Anarch needs: unsafeCoerce :: Int -> Double
20:46:31 <Anarch> Hafydd: Why unsafe?
20:46:32 <shachaf> Hafydd: No, it's not. It's just unhelpful to say that.
20:46:46 <c_wraith> I think it was meant to be sarcastic
20:46:51 <shachaf> Anarch: It's a joke. It wouldn't work anyway, it would just give you nonsense.
20:46:53 <c_wraith> But text doesn't convey that well
20:47:33 <Nisstyre> wtf, haskell.org is messed up
20:48:22 <c_wraith> yeah, I noticed hoogle is broken on the site, too
20:48:29 <c_wraith> or I would have linked to a more complete search there
20:48:49 <Hafydd> All my coerces are unsafe, because I like to live on the edge.
20:48:49 --- mode: ChanServ set +o shachaf
20:49:33 --- topic: set to 'haskell.org in the middle of migration; expect turbulence; use www.haskell.org | http://haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by shachaf
20:49:37 --- mode: shachaf set -o shachaf
20:50:08 <Ralith> safeCoerce :: a -> b; safeCoerce = error "well-defined behavior"
20:50:35 <shachaf> safeCoerce :: a -> a
20:50:47 <shachaf> safeCoerce :: (Typeable a, Typeable b) => a -> Maybe b
20:50:51 <mauke> safeCoerce :: a -> Maybe b
20:51:01 <chrisdotcode> guys, how do run ghci with lambdabot?
20:51:08 <chrisdotcode> *lambdabot embedded
20:51:20 <carter> @tell jfischoff ping me when you're back
20:51:21 <lambdabot> Consider it noted.
20:54:25 <shachaf> unsafeCoerce :: Category k => k a b
20:54:31 <shachaf> safeCoerce :: Monoid k => k
20:54:46 <thoughtpolice> lol
20:55:05 <thoughtpolice> shachaf: how many more can you come up with?
20:55:10 <shachaf> thoughtpolice: 0
20:55:14 <thoughtpolice> :(
20:55:21 <mauke> erce :: b -> a
20:55:24 <elliott> riskyCoerce :: Semigroupoid k => k a b
20:55:29 <shachaf> thoughtpolice: It's your turn now.
20:56:54 <carter> heh
20:57:08 <thoughtpolice> shachaf: i don't conform!
20:57:15 <dmj> haskell.org undergoing maintenace?
20:57:17 <thoughtpolice> not so easily, at least
20:57:23 <elliott> dmj: see topic :)
20:57:40 <shachaf> elliott: Eh, you can't trust the topic.
20:57:45 <shachaf> They'll let just anyone write it these days.
20:58:46 <CADD> shachaf: yeah, but the community catches on quickly
20:59:09 <dmj> elliott: What does the migration entail? Just curious
20:59:18 <elliott> moving server, AIUI
20:59:34 <shachaf> To a warmer climate.
20:59:37 <shachaf> It happens every year.
20:59:40 <mauke> three doors down
20:59:44 <CADD> lol
21:00:04 <shachaf> Three doors down, two doors to go.
21:00:07 <carter> to a hetnzer box, full of lots of ram and things
21:00:13 <carter> and cpu
21:00:27 <carter> and no longer at galois, so more open to the community to use
21:00:45 <mauke> hmm
21:01:05 <mauke> I'd make a "to go" joke but I don't know how to say "zum hier essen" in english
21:01:17 <thoughtpolice> carter: er, no
21:01:23 <carter> thoughtpolice no?
21:01:26 <thoughtpolice> hackage is still galois property as it's been IIRC
21:01:29 <carter> ahhh
21:01:35 <thoughtpolice> most of the infrastructure has been on hetzner
21:01:39 <carter> ahh
21:01:47 <carter> aside from hackage
21:02:06 <carter> i only kknow what sclv  has sort of mentioned
21:02:16 <shachaf> mauke: I think in the US it depends on what part of the country you're in.
21:02:23 <shachaf> But anyway that's not on-topic here.
21:03:00 <thoughtpolice> carter: actually, thinking twice i think you were right (from when i got my key added to darcs.haskell.org)
21:03:14 <thoughtpolice> which was also galois. i can't be sure about lambda/nun though
21:03:43 <carter> yeah… the hetzner stuff was planned for a while, but folks had to be wrassled to admin and ops it
21:04:04 <carter> so its only happening now i think
21:04:06 <sclv> thoughtpolice is one of those wrassled :-)
21:04:12 <carter> hello!
21:04:22 <thoughtpolice> sclv: did you get my keys btw?
21:04:36 <carter> also means those empowered folks have far more powers than they could on a galois box right?
21:05:13 <carter> sclv what sort of neat community things can we expect? :)
21:05:16 <carter> or look forward to
21:05:40 <carter> expect is the wrong word
21:06:12 <sclv> carter: just more stable infrastructure
21:06:17 <sclv> and more responsive fixes, eventually
21:06:17 <carter> WOOO
21:06:22 <carter> sounds concrete :)
21:06:25 <sclv> that's a tall order right there :-)
21:08:31 <carter> important tall order too
21:16:21 <CADD> inf-groupoid: HoTT?
21:17:04 <inf-groupoid> CADD: Yes.
21:17:15 <CADD> inf-groupoid: very cool.
21:17:28 <CADD> inf-groupoid: just got the book. :)
21:17:34 <inf-groupoid> CADD: Me too!
21:17:55 <CADD> inf-groupoid: very very interesting.
21:19:28 <inf-groupoid> CADD: Indeed. Since I started reading Dijkstra, I became convinced by his argument that computing science had a lot to teach mathematics, but this is even more than than, this is computing science providing a better foundation for mathematics!
21:19:56 <CADD> inf-groupoid: you are completely right!
21:20:34 <CADD> inf-groupoid: ive always argued that cs is a superset of mathematics, this seems to go with that notion.
21:21:11 <wallmani> quite the unrest in nyc
21:21:15 <wallmani> https://twitter.com/nycarecs
21:22:05 <CADD> wallmani: interesting, is that the extent of the information currently?
21:22:14 <wallmani> oops, wrong channel
21:22:17 <wallmani> but yeah
21:22:25 <wallmani> from what i can tell that is the most up to date story
21:22:31 <CADD> wallmani: what channel?
21:22:50 <wallmani> the #lesswrong one
21:22:58 <CADD> wallmani: cool thanks
21:23:10 <wallmani> no problem
21:23:12 <wallmani> if you live in the city
21:23:19 <wallmani> be a bit careful tomorrow
21:25:06 <carter> what about nyc?
21:25:08 <carter> i live there?
21:25:26 <CADD> wallmani: all the way on the other side in orange county california
21:25:29 <wallmani> there are protests in regards to the law case
21:25:37 <wallmani> CADD: ah, i see
21:25:52 <carter> so its LA thats the issue gotcha
21:26:10 <wallmani> LA seems riot prone
21:26:11 * hackagebot th-orphans 0.7.0.1 - Orphan instances for TH datatypes  http://hackage.haskell.org/package/th-orphans-0.7.0.1 (MichaelSloan)
21:26:15 <shachaf> This is not the channel.
21:28:40 <CADD> wallmani: thanks for the sympathies
21:28:55 <CADD> world wide riots seem prone
21:29:03 <CADD> shachaf: sorry
21:29:23 <ezrios> wallmani: the Zimmerman case?
21:29:26 <wallmani> shachaf: yeah, sorry. honest mistake by posting here
21:29:36 <wallmani> ezrios: yeah, link above
21:29:39 <ezrios> hm :/
21:29:42 <wallmani> i will try not to spam
21:32:33 <Xunie> Let's say I have a function f x I need to apply to a number over 1950390513 times.
21:33:15 <carter> Xunie why
21:33:28 <shachaf> That's a lot of times.
21:33:30 <Xunie> There's a prelude function out there, and I can't remember the name! But it basically applies f to x n times.
21:33:37 <shachaf> Xunie: There isn't.
21:33:48 <shachaf> You might be after foldr (.) id (replicate n f) x
21:33:58 <shachaf> Or iterate f x !! n
21:34:08 <shachaf> But watch out for big thunks etc.
21:34:12 <prophile> @hoogle Int -> (a -> a) -> a -> a
21:34:13 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
21:34:13 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
21:34:13 <lambdabot> Data.IntMap.Strict adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
21:34:25 <carter> yeah theres a LOT of nicer ways you can do things
21:34:30 <carter> tha iterating a few billiontimes
21:34:32 <Hafydd> @pl \x -> iterate f x !! n
21:34:35 <lambdabot> flip ((!!) . iterate f) n
21:34:35 <lambdabot> optimization suspended, use @pl-resume to continue.
21:34:47 <Xunie> replicate! That's it!
21:35:05 <Xunie> Sorry to be such a help vampire, I should've looked in the docs instead.
21:35:06 <Xunie> Sorry...
21:35:24 <shachaf> The documentation is down so we can forgive you. :-)
21:35:24 <Hafydd> I don't think replicate matches your specification alone.
21:35:35 <shachaf> Hoogle is also down.
21:35:39 <shachaf> If it was up you could try
21:35:45 <shachaf> @hoogle Int -> a -> [a]
21:35:45 <lambdabot> Prelude replicate :: Int -> a -> [a]
21:35:45 <lambdabot> Data.List replicate :: Int -> a -> [a]
21:35:45 <lambdabot> Prelude drop :: Int -> [a] -> [a]
21:37:41 <prophile> out of curiosity, is anyone offhand aware of a Free-type monad along the lines of Foo m a = m (a, Foo m a)
21:39:11 <NemesisD> how much testing do you guys do with quickcheck vs hunit
21:39:50 <NemesisD> i'm questioning whether its a good idea to use quickcheck where a single test case of the functionality would do
21:39:52 <carter> depends on the domain
21:40:00 <shachaf> prophile: That sounds more like Cofree to me.
21:40:19 <Hafydd> How could "Int -> [a] -> [a]" be considered to match "Int -> a -> [a]"?
21:40:30 <Hafydd> Does it have no upper bound on fuzziness?
21:40:55 <NemesisD> example from what I'm working on: i wrote a lens to update a row in an in-memory table. the quickcheck test would probably be to take a table with a known element, do an update and then assert that the find on that element always persists that update
21:41:23 <NemesisD> the hunit version would be the same but would not permute the argument i suppose
21:41:36 <prophile> shachaf: sounds like it to me too, but the outer monad means it isn't
21:42:44 <Hafydd> (What would a type for which [a] = a be like?)
21:42:57 <wleslie> I would like to generate some etags for a large project; but it's a cabal project and loading it in ghci is proving difficult
21:43:39 <NemesisD> wleslie: etags or ctags?
21:43:45 <wleslie> specifically, cabal's MIN_VERSION macros which don't specify an include.  is there a way I can get ghci's cpp to have these loaded?
21:43:51 <wleslie> NemesisD: etags
21:44:15 <roboguy_> Hafydd: nonexistent, I think
21:45:26 <wleslie> hmm, maybe I can specify a custom cpp command to ghci
21:45:38 <roboguy_> Hafydd: as far as I know, that would always give you that "cannot construct infinite type" error
21:46:01 <prophile> Hafydd: Void
21:46:05 <Hafydd> roboguy_: I'm sure that's the case in Haskell, but is there a formalism in which it would make sense?
21:46:09 <prophile> oh, no, my mistake
21:46:26 <Hafydd> It would like a "type-level fixed point".
21:48:03 <Hafydd> Apparently someone wrote a blog post about it: http://mainisusuallyafunction.blogspot.co.uk/2010/12/type-level-fix-and-generic-folds.html
21:48:26 <roboguy_> Hafydd: actually, yeah, I was just about to say Fix would be like that
21:51:13 <roboguy_> Hafydd: there's some articles on F-algebras that use Fix
21:51:30 <roboguy_> Hafydd: like this http://bartoszmilewski.com/2013/06/10/understanding-f-algebras/
21:51:39 <shachaf> newtype Mu f = Mu { forall r. (f r -> r) -> r }
21:51:47 <shachaf> data Nu f = forall x. Nu x (x -> f x)
21:51:59 <shachaf> THose are the best fixed points. Fix is boring!
21:52:46 <roboguy_> shachaf: I haven't really seen those before. I've heard people talk about them, but I know nothing about them
21:55:03 <dolio> Those are both the same as Fix.
21:55:18 <dolio> In Haskell.
21:55:20 <shachaf> Yes.
21:55:23 <Hafydd> http://bartosz.com/images/Algebras/FractalExpr.png what a nice ornament.
21:55:28 <roboguy_> hmm
21:55:30 <shachaf> Haskell is also boring.
22:00:19 <CADD> shachaf: indeed it would be great to hear more http://bartosz.com/images/Algebras/FractalExpr.png21:54 < shachaf> Haskell is also boring.
22:00:23 <CADD> oops
22:00:24 <CADD> lol
22:02:00 <Hafydd> I see...
22:02:10 <Hafydd> It makes more sense than I initially thought.
22:02:47 <Hafydd> But not really for [], which is already itself recursive.
22:14:21 <Hafydd> @pl \x y -> f (g x y)
22:14:21 <lambdabot> (f .) . g
22:15:23 <Hafydd> The only problem is that you can't seem to auto-derive Show instances for types constructed with Fix.
22:16:49 <Hafydd> (Well, let's say, "one problem")
22:17:27 <c_wraith> Hafydd: try standalone deriving
22:27:13 <Xunie> What the hell is a 't' in this: arrivesAt :: (Integral a) => t -> a -> a
22:27:41 <mstksg> are case expressions in general not-best-practice?
22:27:50 <mstksg> should i always do pattern mattching if posible?
22:28:09 <Xunie> mstksg, your question is aesthetic, right?
22:28:13 <mstksg> i've heard it said about guards
22:28:20 <mstksg> and that there is some more-than-aesthetic reason to avoid guards
22:28:34 <mstksg> (but i'm not exactly sure what that is)
22:28:40 <shachaf> Xunie: There's no need to be so hostile about it.
22:29:00 <shachaf> mstksg: Hmm, if people said guards are bad they may have been talking about booleans being bad in general.
22:29:16 <Xunie> shachaf, you mean about me saying 'hell'? Sorry. ._.
22:29:18 <shachaf> Guards are fine for what they do and generally nicer than if-then-else.
22:29:53 <mstksg> i don't know, i've just always heard that pattern matching is more idiomatic than guards
22:29:58 <shachaf> Pattern guards are even better, naturally.
22:30:05 <shachaf> mstksg: OK, what you've heard was incomplete.
22:30:11 <shachaf> @where crossroad might explain more.
22:30:12 <lambdabot> http://www.vex.net/~trebla/haskell/crossroad.xhtml
22:30:45 <shachaf> Cargo-culting bits of advice like that can be dangerous in some cases. :-)
22:31:06 <shachaf> mstksg: Anyway, "case" is fine.
22:31:37 <shachaf> It's a very fundamental part of the language, more fundamental than if or guards or pattern-matching in function declarations or other things.
22:31:52 <shachaf> All the rest are sugar for making use of case look nicer. Use it if it helps.
22:31:55 <mstksg> okay  :) is the choice of case/pattern matching down to jsut aesthetics then?
22:32:09 <shachaf> case *is* pattern-matching.
22:32:24 <shachaf> case ... of PATTERN -> ...
22:35:28 <mstksg> oh yeah
22:35:41 <joelteon> case or guard is the choice
22:35:43 <joelteon> guards*
22:35:50 <mstksg> just had a major brain malfunction
22:36:00 <mstksg> i was thinking of creating a helper function for some reason
22:36:03 <mstksg> okay thanks guys :)
22:36:25 <Anarch> I'm trying to use (printf "%f %f\n" 1.1 2.2) as if it were a String, and wondering wtf "(PrintfType (t -> t1), Fractional t) => t1" means; should I keep trying to Zen out printf, or use something else (Not in scope: `sprintf')?  Ultimately I need to take metalists of Complex values and turn them into lists of strings that I can unlines.
22:37:15 <Anarch> Or should I just go back to easy languages like Perl and APL?
22:37:33 <joelteon> i'd say don't use printf
22:38:04 <shachaf> Anarch: printf uses black magic to do "varargs", which you can't strictly speaking do in Haskell in general.
22:38:05 <Anarch> joelteon: Begging the question of what to use instead ...
22:38:29 <joelteon> show?
22:39:04 <Anarch> shachaf: I'd be happy to stick to white magic if I could figure out how.
22:39:21 <Anarch> joelteon: Hmm, show is an interesting idea.
22:39:26 <shachaf> Anarch: It uses similar black magic so that it acts as both printf and sprintf.
22:40:04 <shachaf> Anarch: You can use it without understanding the magic.
22:40:13 <shachaf> > printf "%f %f\n" 1.1 2.2 :: String
22:40:14 <lambdabot>   "1.1 2.2\n"
22:43:17 <Anarch> shachaf: Blerf, I didn't expect it to be that easy.
22:44:42 <ion> like monoids
22:44:51 <shachaf> ion: Don't we all?
22:45:05 <lispy> I accidentally the whole monoid
22:45:52 <ion> I wish base had a type-safe TH printf.
22:46:21 <carter> :t printf
22:46:22 <lambdabot> PrintfType r => String -> r
22:46:23 <lispy> ion: have you seen the extensive articles that oleg has written about making printf type safe?
22:46:29 <lispy> ion: also, why TH?
22:47:02 <shachaf> lispy: Does Oleg's article have a good syntax?
22:47:05 <lispy> The odd thing about printf is that it's an eDSL.
22:47:06 <mauke> lispy: can't do it without TH
22:50:50 <ion> lispy: I don’t think i have. I… thought you can’t do it in a convenient way without TH. But i wouldn’t be too surprised if Oleg showed me wrong.
22:51:17 <shachaf> ion: The usual solution is to redefine "convenient".
22:52:15 <lispy> When I asked "why TH?" I really meant it. Now I understand. You probably are hoping to use the quasiquoter?
22:52:28 <ion> lispy: yes
22:52:37 <carter> ion look at the type
22:52:40 <carter> :t printf
22:52:40 <lambdabot> PrintfType r => String -> r
22:52:57 <lispy> carter: you can still have run-time failures with printf
22:53:00 <carter> true
22:53:13 <carter> anyone here using mac + ghc head?
22:53:17 <carter> or willing to use it
22:53:25 <Ghoul_> How many language extensions am I allowed to use before it becomes a sin
22:53:30 <carter> so that the haskell-game folks can test their new glfw bindings?
22:53:48 <lispy> Ghoul_: it's more about the specific extensions
22:53:50 <ion> ghoul: I’m not sure you can define trigonometric functions that way.
22:53:58 <lispy> Ghoul_: incoherent instances is pretty evil
22:54:15 <carter> actually:  johnw  you def have ghc head on your mac
22:54:32 <Ghoul_> are any of these evil: MultiParamTypeClasses, GADTs, GeneralizedNewtypeDeriving, FunctionalDependencies, FlexibleInstances ?
22:54:37 <carter> @tell johnw  lispy and some of the others need someone to try building and running some tests on a mac with ghci head
22:54:37 <lispy> johnw: oh, be our test subject, please :)
22:54:37 <lambdabot> Consider it noted.
22:54:52 <carter> lispy he build ghc on mac nightly
22:54:56 <carter> so he def has the fu to do it
22:55:01 <carter> pester him
22:55:04 <carter> shame i forgot
22:55:05 <lispy> awesome
22:55:10 <lispy> thanks!
22:56:11 <roboguy_> Ghoul_: I know GeneralizedNewtypeDeriving is supposed to have some pretty (potentially) dangerous effects but I don't fully understand
22:56:37 <Ghoul_> it certainly sounds evil
22:56:59 <ion> What kind of dangerous effects does it have?
22:57:12 <zacts> how long until haskel.org is up?
22:57:17 <ion> Something related to Typeable perhaps?
22:57:39 <roboguy_> ion: I think if you also use GADTs you can make unsafeCoerce
22:57:47 <ion> ok
22:58:24 <scshunt> zacts: try haskell.org
22:58:37 <lispy> zacts: it's actually up it's just that "http://haskell.org" is serving the wrong content. More specific urls work though. Like, www.haskell.org
22:59:01 <zacts> scshunt: typo on irc
22:59:07 <zacts> lispy: still not working for me
22:59:12 <zacts> hopefully up by tomorrow
22:59:31 <lispy> zacts: oh interesting. www.haskell.org was working.
23:00:46 <Hafydd> c_wraith: that did it, thanks.
23:03:35 <zRecursi`> @where xmonad
23:03:35 <lambdabot> #xmonad | http://xmonad.org/
23:13:53 <mmachenry> I'm looking for advice for reading and mixing input audio from wav files and streaming to shoutcast audio in Haskell. I have not been able to find any libraries on line. Does anyone know of anything I could use?
23:14:46 <CADD> mmachenry: if the wiki was up: http://www.haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound
23:14:56 <mmachenry> Actually just streaming to shoutcast is the major issue. I have seen a few reading libraries.
23:15:13 <mmachenry> CADD: That site appears to be down. :(
23:15:19 <CADD> mmachenry: i know
23:15:23 <CADD> mmachenry: see topic
23:15:41 <CADD> mmachenry: http://web.archive.org/web/20130702203636/http://www.haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound
23:15:46 <mmachenry> Ah I see. Well I'll check the link more later.
23:15:47 <CADD> mmachenry: there is an archive of the page
23:15:58 <zRecursi`> mmachenry: That site is NOT built using haskell so not safe enough :-D
23:16:09 <CADD> zRecursi`: lol
23:16:26 <mmachenry> Hm. Doesn't seem to have a shoutcast/icecast library.
23:16:51 <CADD> mmachenry: yeah most of that is music composition.
23:16:52 <mmachenry> GStreamer is capable of this, however, I already wrote a Gstreamer version of my software and it is not the right tool for the job.
23:17:05 <CADD> mmachenry: what are you writing?
23:18:09 <mmachenry> CADD: Simply put, I want to write a program that accepts a list of audio file paths and randomly plays snippets of audio from those files forever to an icecast streaming server. They should be able to overlap so audio mixing would be necessary as well.
23:18:50 <mmachenry> That simple program should demonstrate everything I need to write the actual application, which is not that much more complicated than what I've described.
23:19:32 <mmachenry> I actually wrote this in OCaml already. It's working but I now need to communicate with it. Oh that's write. I need a AMPQ or Pipe communication with the daemon.
23:20:31 <mmachenry> I found stuff like that for OCaml but the AMQP library seemed abandoned and honestly, I get pretty frustrated with the state of documentation of libraries in OCaml.
23:21:30 <mmachenry> Haskell docs are much better, and the AMQP library looks nice. But in OCaml someone wrote a large Internet radio application that gives me all the audio libraries I need. Haskell audio libraries seem a bit lacking.
23:21:48 <lispy> very lacking
23:21:57 <lispy> although there is a nice last.fm binding
23:22:21 <lispy> and a portaudio binding: http://hackage.haskell.org/package/portaudio-0.2.3
23:22:38 <lispy> But portaudio won't help you with the codec
23:23:07 <c_wraith> I was thinking of writing libmad bindings
23:23:15 <c_wraith> But I never got around to it
23:23:29 <mmachenry> portaudio seemed like a device-base audio library when I looked at it.
23:23:31 * lispy hands c_wraith a round tuit
23:23:32 <Anarch> How can I apply a function to a list of args?  I'm not looking for reduce here, but Lisp's #'apply.
23:23:44 <c_wraith> lispy: where did you find one of these?!
23:24:01 <lispy> Anarch: ($)
23:24:04 <lispy> :t ($)
23:24:05 <lambdabot> (a -> b) -> a -> b
23:24:12 <lispy> c_wraith: I know a guy
23:24:35 <lispy> Anarch: if that's not waht you want then look at zipWith
23:24:40 <lispy> :t zipWith (?f $)
23:24:41 <lambdabot> parse error on input `)'
23:24:47 <lispy> :t \f -> zipWith (f $)
23:24:48 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
23:24:59 <lispy> :t zipWith ($)
23:24:59 <lambdabot> [b -> c] -> [b] -> [c]
23:25:23 <lispy> :t \f -> map (f $)
23:25:25 <lambdabot> (a -> b) -> [a] -> [b]
23:25:30 <lispy> take your pick
23:25:41 <mmachenry> c_wraith: Do it :)
23:25:47 <mmachenry> Buy you a beer :)
23:25:56 <c_wraith> Can't drink anymore. :(
23:26:23 <mmachenry> Oh... buy you a pizza then :)
23:26:38 <lispy> c_wraith: pay for your cart lunch :)
23:26:49 <mmachenry> I guess I could write a set of C bindings to the audio libraries I need for this.
23:27:08 <lispy> We need an audio equivalent to JuicyPixels
23:27:17 <c_wraith> I mostly wanted to write the bindings as an experiment in using an ST interface to native code
23:27:27 <lispy> JuicyWaveforms or JuiceAudio
23:27:30 <c_wraith> since libmad guarantees fully deterministic decoding, it'd be correct!
23:27:31 <Anarch> lispy: I don't get it; I don't see how I could turn "(+) 1 2" into something that'd work on [1,2].
23:27:43 <mmachenry> Why an ST interface, c_wraith?
23:27:49 <carter> mmachenry that said, its really really easy to use the haskell c ffi
23:28:04 <lispy> :t zipWith ((+) $) [1] [2]
23:28:04 <lambdabot> Num c => [c]
23:28:08 <lispy> > zipWith ((+) $) [1] [2]
23:28:09 <lambdabot>   [3]
23:28:11 <mmachenry> carter: Yeah I actually wrote some of one once and it was easier than most.
23:28:15 <lispy> Anarch: Like that?
23:28:25 <c_wraith> mmachenry: because it involves mutating a native context object, so it needs to be in a context that guarantees the compiler handles it correctly
23:28:32 <lispy> :t foldr ((+) $)
23:28:33 <lambdabot> Num b => b -> [b] -> b
23:28:40 <lispy> > foldr ((+) $) 0 [1,2]
23:28:40 <c_wraith> mmachenry: but the end result is deterministic, so it doesn't need to be IO
23:28:41 <lambdabot>   3
23:28:42 <mikeplus64> > zipWith (+) [1] [2]
23:28:43 <lambdabot>   [3]
23:28:45 <lispy> Anarch: or like that?
23:28:48 <Anarch> lispy: No, that worked on [1] [2].
23:28:50 <carter> joeyh supporting your git annex coding?
23:29:01 <carter> just saw the link on HN :)
23:29:14 <carter> gl!
23:29:25 <Anarch> The real problem is to apply printf "%f %f\n" to a 2-item list.
23:29:34 <lispy> Anarch: basically, ($) is your application. Now you just need to pick map, zipWith, or fold* to match your need
23:30:19 <lispy> > foldr (printf "%f %f\n" $) 0 [1,2]
23:30:20 <lambdabot>   No instance for (Text.Printf.PrintfArg a0)
23:30:20 <lambdabot>    arising from a use of `e_1012...
23:30:28 <c_wraith> mmachenry: of course, there'd also be some sort of higher-level interface, maybe taking a lazy bytestring and returning a lazy list of of decoded frames
23:30:30 <lispy> doesn't work as well with printf :)
23:30:55 <lispy> :t foldr (printf "%f %f\n" $)
23:30:56 <lambdabot> (PrintfType b, PrintfArg a, PrintfArg b) => b -> [a] -> b
23:31:02 <mmachenry> Anarch: apply f (x:xs) = apply (f x) xs
23:31:04 <zRecursi`> :t zipWith
23:31:04 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
23:31:27 <lispy> > foldr (printf "%f %f\n" $) () [1,2]
23:31:28 <lambdabot>   No instance for (Text.Printf.PrintfArg ())
23:31:28 <lambdabot>    arising from a use of `Text.P...
23:31:42 <lispy> > foldr (printf "%f %f\n" $) undefined [1,2]
23:31:43 <lambdabot>   No instance for (Text.Printf.PrintfArg a0)
23:31:43 <lambdabot>    arising from a use of `e_112'...
23:31:45 <c_wraith> I really should write that library.  It'd be nice to have around.  But there's a ton of busywork involved that gets on my nerves, even with bindings-dsl
23:32:07 <mmachenry> Anarch: I think what you want is (fold ($) f mylist)
23:32:24 <c_wraith> does that even type?
23:33:17 <lispy> mmachenry: I gave an example like that but it doesn't type check for printf
23:33:23 <lispy> > foldr ((+) $) 0 [1,2]
23:33:24 <lambdabot>   3
23:33:27 <mmachenry> oops sorry, one sec
23:34:24 <lispy> > foldr (printf "%s %f %f\n" $) "" [1,2]
23:34:25 <lambdabot>   "*Exception: Printf.printf: bad argument
23:34:32 <lispy> > foldr (printf "%s %f %f\n" $) "test" [1,2]
23:34:33 <lambdabot>   "*Exception: Printf.printf: bad argument
23:34:46 <lispy> I have no idea why that fails
23:35:28 <mmachenry> My example only works in a dynamic language :-\
23:35:28 <Anarch> OK, that foldr call at least works for (+), but I can tell it'll be a while before I figure out /why/ it works, so combining that with the black magic of printf's types is going to be Hard.
23:35:56 <Hafydd> > foldr (printf "%s %f \n" $) "test" [1,2]
23:35:57 <lambdabot>   "*Exception: Printf.printf: bad argument
23:36:37 <lispy> Anarch: the reason it works is pretty simple
23:36:41 <lispy> :t ($)
23:36:42 <lambdabot> (a -> b) -> a -> b
23:36:43 <lispy> :t foldr
23:36:43 <lambdabot> (a -> b -> b) -> b -> [a] -> b
23:36:49 <lispy> :t foldr ($)
23:36:49 <lambdabot> b -> [b -> b] -> b
23:36:59 <lispy> :t \f -> foldr (f $)
23:37:00 <lambdabot> (a -> b -> b) -> b -> [a] -> b
23:37:05 <lispy> :t \f -> (f $)
23:37:06 <lambdabot> (a -> b) -> a -> b
23:37:11 <lispy> that should help you :)
23:37:18 <Hafydd> > foldr (printf "%s %i \n" $) "test" [1,2]
23:37:19 <lambdabot>   "*Exception: Printf.printf: bad argument
23:38:19 <Hafydd> > foldl (printf "%s %i \n" $) "test" [1,2]
23:38:21 <lambdabot>   "test 1 \n 2 \n"
23:41:20 <Anarch> Hafydd: Getting closer, but it's still a fold; printf is invoked twice by your example, once on 1, then on 2, each time combining with "test".  There should be a way to just apply it to [1,2] as if it were q{printf "string" 1 2}.
23:41:25 <Hafydd> And "(f $)" is pretty useless, because it's the same as "f".
23:42:12 <shachaf> Anarch: There is no good way of doing that. Sorry.
23:42:31 <shachaf> Whether there "should" be one is a matter that can be argued. :-)
23:42:38 <shachaf> Like I said, Haskell doesn't have real varargs.
23:43:33 <Hafydd> It would be horrible un-type-safe, anyway.
23:44:56 <kwos> hello!
23:45:13 <lispy> hi
23:45:16 * Clint nods.
23:45:55 <Anarch> shachaf: Hafydd: Then it looks like I need to just catenate strings.  I can do that, and I see that unwords is like Perl's join, but if I needed some other separator than " ", is there a way to get that?  [... thinks ...] Oh ... *THAT* is just a fold, right?
23:46:20 <mauke> :t intercalate
23:46:20 <lambdabot> [a] -> [[a]] -> [a]
23:46:21 <Hafydd> > intercalate ":" ["/bin", ]
23:46:22 <lambdabot>   <hint>:1:26: parse error on input `]'
23:46:29 <Hafydd> > intercalate ":" ["/bin", "/usr/bin"]
23:46:30 <lambdabot>   "/bin:/usr/bin"
23:46:47 <Anarch> Hafydd: Thanks, very nice
23:57:05 <Gracenotes> :t intersperse
23:57:06 <lambdabot> a -> [a] -> [a]
23:58:24 <Hafydd> > intersperse '   ' "HELLO"
23:58:25 <lambdabot>   <hint>:1:17: parse error on input `''
23:58:26 <Hafydd> Er..
23:58:29 <Hafydd> > intersperse ' ' "HELLO"
23:58:30 <lambdabot>   "H E L L O"
23:58:55 <Hafydd> It doesn't work in the case of ' ' ["HELLO", "WORLD"], however.
23:59:10 <Hafydd> @hoogle a -> [[a]] -> [a]
23:59:10 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
23:59:10 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
23:59:11 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
23:59:12 <johnw> lispy: what was this?
