00:08:46 <shachaf> mgsloan: Did you see http://www.reddit.com/r/haskell/comments/1heqty/ideas_on_correctbyconstruction_isomorphisms/ ?
00:08:55 <shachaf> They were asking that question in #-blah earlier, I think.
00:09:06 <shachaf> An odd place to ask it. But maybe it's related to that thing you were doing.
00:09:16 <mgsloan> shachaf: Hey!
00:09:22 <mgsloan> It is quite related
00:09:56 <mgsloan> Linearity was definitely the constraint I settled on for doing isos
00:10:31 <mgsloan> I probably ought to point out the isos bit of lenq (even if it's a bit unfinished), as he might find it interesting
00:10:54 <shachaf> Yes.
00:11:28 <shachaf> And then you should tell me why Mu is an initial fixed point!
00:12:01 <mgsloan> main reason I haven't responded yet is that I'm not really sure about the proof aspects of it.  It really doesn't seem like you'd need to do anything close "embed linear logic" for this, though
00:25:06 <sordina1> Ah nevermind guys. It was grep/sed that turned off line buffering when in a pipeline
00:25:15 <sordina1>  /facepalm
00:53:10 <taylorgb> What would be the best approach for doing some random things like randomly selecting an item from a list, or generating "random" text content? I could imagine it is something that QuickCheck already does rather well, but I'm not sure how easy those parts are to use separate from the rest of QC.
00:55:41 <sm> taylorgb: http://hackage.haskell.org/package/random
00:56:26 <johnw> taylorgb: they are actually fairly easy to separate
00:56:42 <taylorgb> I'm using System.Random already, but I was wondering whether it was necessary to build it up myself.
00:56:50 <johnw> QuickCheck has a Gen monad which is used to generate random inhabitants for some base type
00:57:21 <taylorgb> Hrm, ok. I'll take a look at that, thanks.
00:57:28 <johnw> you can use sample' from quick check to generates a list of sample values for a given Gen a
00:58:14 <dpwright> I am trying to install gnuidn-0.2 using cabal-install, and c2hs gives me a lexical error in file IDNA.chs.h
00:58:36 <dpwright> I'm not sure where cabal keeps its install files, so I don't know where to look at the contents of IDNA.chs.h
00:59:18 <johnw> taylorgb: also, you can use "arbitrary" to create a random generator for a type
00:59:26 <dpwright> just wondering if anybody else has come across the issue, or is aware of some issue (version of c2hs?) that would cause this sort of thing
00:59:27 <taylorgb> Superb
00:59:29 <johnw> > sample' (arbitrary :: Int)
00:59:32 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
00:59:32 <lambdabot>              with actual type ...
00:59:41 <johnw> > sample' (arbitrary :: Gen Int)
00:59:42 <lambdabot>   <IO [Int]>
01:00:05 <johnw> > take 10 <$> sample' (arbitrary :: Gen Int)
01:00:06 <lambdabot>   <IO [Int]>
01:00:11 <johnw> well, that works in GHCI at least
01:00:21 <johnw> I got: [-1,-2,-1,-3,-12,-17,63,88,573,1751]
01:02:13 <dpwright> (or if anybody knows the best place to ask -- I am installing this as a dependency for git-annex)
01:04:53 <b6> dpwright: i'll install it and see what happens here. sec.
01:05:49 <dpwright> b6 --thanks!  I think you need to install c2hs separately first if you don't already have it...
01:09:56 <b6> dpwright: hmm, it installed ok for me with ghc 7.6.3.
01:10:12 <b6> c2hs 0.16.4.
01:11:52 <b6> gnuidn is looking scarily old, though. 2010.
01:13:09 <dpwright> hmm, I am on the same versions
01:13:39 <dpwright> yeah, I'm only installing this because it's a dependency for git-annex, really
01:13:53 <dpwright> maybe there's some (non-haskell) dependency I don't have installed
01:14:12 <b6> alex? happy?
01:14:24 <b6> maybe it's a language-c thing.
01:15:41 <b6> i'm using language-c 0.3.2.1. seems suspect, because there's a newer one.
01:16:48 <dpwright> hmm, I'm also on language-c 0.3.2.1, if the contents of my ~/.cabal/lib is anything to go by
01:20:07 <dpwright> I'll try making sure my system is up to date
01:20:10 <b6> dpwright: did it give any more details? IDNA.chs.h has two lines, just includes. looks perfect to me.
01:21:05 <dpwright> where can I find that file to check it?  It says line 1, column 1, "#" does not fit here
01:21:57 <b6> dpwright: i just went to ~/.cabal/packages/hackage.haskell.org/gnuidn/0.2 and unpacked it and built it.
01:23:10 <b6> and then it was in dist/build/Data/Text/IDN/IDNA.chs.h
01:23:26 <dpwright> ah, right you are
01:25:27 <g3orge> so w8. there is no command to update cabal-installed packages?
01:26:05 <supki> g3orge: no
01:26:24 <g3orge> supki: isn't that.. weird? why?
01:27:06 <b6> i'm not sure, but it's apparently not easy to fix.
01:28:49 <supki> g3orge: because it will likely break your packages if you don't know what you are doing
01:30:04 <supki> g3orge: there is  cabal install --upgrade-dependencies  for a specific package, but that may (will) break other packages too =)
01:31:24 <b6> it seems like cabal can install multiple versions of the same package. i don't get why upgrading dependencies affects anything. download and compile the newer dependencies, recompile the target using those. why does that break anything else?
01:31:54 <g3orge> so.. cabal is stupid. that's the only explanation. why isn't rubygems or other packagers experiencing this problem?
01:32:29 <b6> i really don't understand, but i don't think it's due to anyone being stupid.
01:33:03 <b6> it's been a pain point for as long as i can remember.
01:33:39 <supki> you can install multiple versions of the same package, but that's the problem, not a solution
01:34:02 <path[l]> well atleast in rubygems and npm I know that when you ugrade a package, you also download corresponding versions of other dependencies. But you will have multiple versions of the same package there too
01:34:13 <supki> I'd guess 9 out of 10 problems with cabal in #haskell are because of multiple versions of the same package really
01:34:55 <MasseR> b6: package a depends on b. You upgrade b to b2. a is still linked with the original b. You install c which depends on b2 and a. There's the problem
01:34:58 <MasseR> IIRC
01:35:13 <supki> yes
01:35:56 <supki> well, the problem is when you want to use both a and c in some project
01:37:01 <b6> it only seems like it's a problem if A's version bounds say it can't use B2.
01:37:35 <b6> otherwise the fix is to upgrade A to depend on B2.
01:37:45 <MasseR> b6: And if there's D that depends on A
01:37:48 <mauke> ... which will break all dependencies of A
01:37:50 <MasseR> And B
01:38:12 <mauke> @where sicp
01:38:12 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
01:38:51 <b6> it still seems solvable to me. it just involves more upgrades. only if version bounds prevent something from being upgrades is there really a showstopper.
01:42:12 <b6> The solution we've been discussing for the next major ghc release is to track package ABIs and possibly even to allow slotting packages in their ABI. That would make this problem disappear and generally allow safer and more flexible management of installed packages.
01:42:17 <b6> i wish there was a date on this comment.
01:42:57 <b6> gah, 2009.
01:43:30 <ion> Smoking and Inhaling of Cannabis Plants
01:44:28 <Moggle_> uh
01:44:44 <b6> just .. keep it purely functional.
01:44:49 <quicksilver> b6: they do track package ABIs now
01:44:50 <Moggle_> if you can just use {-#LANGUAGE NoMonomorphismRestriction #-}
01:44:59 <quicksilver> so part of that did get implented
01:44:59 <Moggle_> why does Haskell98 have it...?
01:45:34 <mauke> because H98 is older than LANGUAGE
01:45:40 <quicksilver> Moggle_: because people were worried it would defeat people's intuitions about sharing
01:46:00 <Moggle_> quicksilver: can you go into more detail on that?
01:46:02 <shachaf> That sicp @where entry looks like four separate items.
01:46:23 <shachaf> @where+ sicp http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
01:46:24 <lambdabot> I will remember.
01:46:26 <ion> moggle: foo :: [Integer] can be memoized, foo :: Num a => [a] can’t. It’ll behave more like a function.
01:46:38 <quicksilver> Moggle_: if you have fib :: Num a => [a]; for the fibonacci sequence
01:46:56 <quicksilver> then each time you try to access it you're getting a fresh copy instantiated to the concrete type you chose
01:47:01 <quicksilver> so you get no sharing benefit.
01:47:20 <quicksilver> this is probably an obscure case compared to the confusion it causes.
01:47:27 <quicksilver> so it was probably the wrong decision - but that's the reason.
01:48:07 <quicksilver> it's a particularly strange language choice given that the language doesn't *actually* specify sharing behaviour anyway
01:48:11 <ion> NoMonomorphismRestriction with a warning when the monomorphism restriction *would* have applied might have been a better default.
01:48:23 <Moggle_> quicksilver: thanks. i admit to being unsure WHY there can't be a sharing benefit in that case, though.
01:48:39 <quicksilver> Moggle_: well you can imagine systems and compilers
01:48:41 <Moggle_> this is likely because i dont have an entirely firm grasp of the monomorphism restriction in the first place. ah, well.
01:48:50 <quicksilver> but that doesn't happen to work with the GHCimplementation
01:48:59 <quicksilver> and, there are some fairly good practical reasons
01:49:16 <quicksilver> but certainly you could imagine shared polymorphic literals
01:49:26 <quicksilver> ...but they don't work in our implementations
01:49:49 * hackagebot shakespeare-css 1.0.6 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.6 (MichaelSnoyman)
01:51:59 <Gracenotes> ion: you don't put all of your Integer and Double constants at the top-level?
01:52:15 <Gracenotes> I use 0 and 1 all the time, sometimes even 2
01:52:30 <ion> Now now, there is no two.
02:14:22 <shachaf> So you can defined Free f a = forall r. f r -> (a -> r) -> r
02:14:48 <shachaf> Such that Free (Algebra F) gives you a free monad of F, where Algebra f a = f a -> a
02:15:06 <shachaf> Is there a similar Cofree that can let you define a cofree comonad with an F-coalgebra?
02:17:00 <Saizan> i'd assume so, with the church encoding of Nu, at the lowest level
02:17:59 <shachaf> Saizan: Well, it wouldn't be church encoding, would it?
02:18:27 <shachaf> Anyway, what would that look like?
02:19:00 <shachaf> You can say CofreeComonad f a = exists x. (x, x -> (a, f x))
02:19:35 <shachaf> But that doesn't seem amenable to parameterizing on (/\f x -> (x -> f x))
02:24:50 * hackagebot shakespeare-css 1.0.6.1 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.6.1 (MichaelSnoyman)
02:27:43 <Saizan> true, i must say i don't fully understand why Free (Albegra F) works, except by substitution
02:28:21 <Saizan> Free's definition makes sense as a half of the natural isomorphism with the forgetful functor
02:28:47 <Saizan> especially if you write it like  forall r. (a -> r) -> f r -> r
02:29:36 <Saizan> ..or maybe not, because of the role of f
02:30:23 <merijn> I remember a tool that computed the licenses of the transitive closure of a libraries dependencies, anyone know what I'm thinking off?
02:30:54 <Saizan> right, f is not the generator
02:31:20 <typoclass> merijn: sorry, licenses of the transitive closure? is that a mathematics question or a hackage question?
02:32:52 <merijn> typoclass: hackage
02:33:07 <merijn> i.e. give the set of licenses covering all dependencies
02:33:13 <typoclass> merijn: ok thanks
02:33:29 <xxx-man> I need some help in lambda calculus, can one point me right chanell?
02:33:46 <b6> merijn: maybe http://packdeps.haskellers.com/licenses
02:36:14 <merijn> b6: Thanks, that's what I wanted
02:36:19 <b6> np.
02:39:50 * hackagebot hflags 0.2 - Command line flag parser, very similar to Google's gflags  http://hackage.haskell.org/package/hflags-0.2 (GergelyRisko)
02:42:33 <Saizan> ok, so Free F is the free functor Hask -> C where C has roughly objects of the form (a : *, F a)
02:44:17 <typoclass> oh, this hflags thing seems to offer some new ideas ^^ apparently it'll use TH look at the Main module and walk through all the imports tree, where each module can define its own bunch of switches, which will all be collected
02:48:04 <b6> hmm, interesting.
02:50:31 <alshain> Why does :t 5 :: Num a => a, while "let foo = 5" :t foo :: Integer? Why not ":t foo :: Num a => a" ?
02:50:43 <Saizan> cofree is a right adjoint, so we know that a -> b ~ (a,fa) -> Cofree F b ?
02:50:52 <Saizan> alshain: the monomorphism restriction
02:51:51 <Saizan> alshain: for somewhat arbitrary reasons bindings with not arguments on the left of = can't have a type with a typeclass context inferred
02:51:54 <typoclass> alshain: you can turn that behavior off. (i always do) see here:
02:51:56 <typoclass> @where dmr
02:51:56 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
02:52:01 <xxx-man> I need some help in lambda calculus, can one point me right chanell?
02:52:17 <Saizan> xxx-man: #math?
02:52:56 <Saizan> xxx-man: also, you shouldn't repeat your questions
02:53:02 <alshain> From the page: "All seem to agree that it is evil" Why is it evil?
02:53:33 <Saizan> alshain: because of problems like yours
02:53:59 <merijn> Where was the reverse dependency tool?
02:54:07 <alshain> Ah, I thought disabling the restriction was considered evil, in which case "my problem" would not have occured
02:54:45 <typoclass> merijn: packdeps?
02:54:51 * hackagebot NXTDSL 0.2 - Generate NXC Code from DSL  http://hackage.haskell.org/package/NXTDSL-0.2 (AlexanderThiemann)
02:55:19 <typoclass> merijn: (i.e. one level up from your earlier url)
02:56:39 <shachaf> Saizan: Hi, was away.
02:57:17 <merijn> typoclass: Does that show all of them or just one level?
02:57:18 <Saizan> shachaf: hi, i was mostly thinking aloud anyway
02:57:45 * shachaf reads.
02:59:16 <typoclass> merijn: i'm assuming it's all the dependencies (tm). http://packdeps.haskellers.com/reverse/aeson shows 161 thingies, while http://hackage.haskell.org/package/aeson directly shows 10ish
03:00:31 <merijn> typoclass: Hackage doesn't list reverse dependencies
03:01:08 <merijn> as far as I can tell the reverse thing only lists one level
03:01:56 <merijn> Which is a shame
03:02:54 <typoclass> merijn: right, i just confused reverse dependencies with dependencies :-/ need moar caffeines
03:05:14 <Saizan> it's cool that we derive the eliminator for Free F from the forall a r, (Free F a -> r) ~ (a -> U r) isomorphism
03:05:58 <shachaf> Saizan: Oh, now I see what you mean.
03:06:15 <shachaf> And U r is just written as r, of course.
03:07:45 <Saizan> yeah
03:08:00 <shachaf> So how does Cofree work?
03:11:12 <shachaf> Also, what's the proof that Mu F is initial?
03:11:26 <shachaf> Er, I guess the proof is that delMuF :: F (Mu F) -> Mu F is initial.
03:15:34 <Andrea__> how convert a Just Int to an Int ?
03:16:41 <neolax> Andrea, f ( Just a ) = a
03:17:05 <shachaf> ...And f Nothing = someIntValue
03:17:26 <shachaf> Since a Maybe Int value could be Nothing.
03:17:27 <kryft> Isn't there a function called maybe that does that
03:17:29 <typoclass> Andrea__: an alternative is "case ... of Just i -> ... i ... ; Nothing -> ..."
03:17:38 <typoclass> kryft: yes, that's another possibility
03:17:43 <Ralith> :t maybe
03:17:44 <lambdabot> b -> (a -> b) -> Maybe a -> b
03:17:45 <Ralith> :t fromMaybe
03:17:46 <lambdabot> a -> Maybe a -> a
03:18:32 <kryft> Hmm, I guess I was thinking of fromMaybe
03:18:33 <b6> there's also fromJust, but it's dangerous.
03:18:36 <typoclass> kryft: also, there's fromMaybe (not to be confused with fromJust, which is a whole different story). i think learning case-of first is the way to go, then moving on to maybe and fromMaybe
03:18:44 <Andrea__> a function gives a Maybe , its sure that the result is not Nothing, i want make more calculations with the result
03:19:12 <Ralith> Andrea__: then edit the function to not return a Maybe.
03:19:46 <Andrea__> Ralith, the funtions are from library, e.g lookup or find etc
03:20:06 <Andrea__> i want not write all libraries new
03:20:16 <Ralith> those are not guaranteed to return Just x
03:20:36 <Gracenotes> well, you could call them with constant arguments
03:20:40 <Andrea__> ok, i can check it with the if .. then statement
03:21:05 <Gracenotes> only then, you could be absolutely sure that they didn't return Nothing, given no other context
03:21:10 <Ralith> no, you use a case statement.
03:21:35 <kryft> typoclass: Sure, I'm still very much a newbie myself, so I'm not taking any stances on pedagogy =)
03:22:02 <Gracenotes> or you might have to give a massive context. but if you wanted that, why not just use an imperative language? :)
03:22:14 <typoclass> Andrea__: try "case lookup ... of Just x -> ... (some calculation with x) ...". you can use ghc -Wall if you want a warning that tells you that you matched only on Just, and did not match on Nothing
03:22:35 <Andrea__> > lookup 1 [(1,"hello"),(2,"world")]
03:22:36 <lambdabot>   Just "hello"
03:22:56 <Andrea__> > lookup 1 [(1,"hello"),(2,"world")]  ... * 2
03:22:57 <lambdabot>   <hint>:1:41: parse error on input `*'
03:23:15 <Andrea__> > lookup 1 [(1,"hello"),(2,"world")]  * 2
03:23:16 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe [GHC.Types.Char]))
03:23:16 <lambdabot>    arisin...
03:23:40 <Andrea__> bad example
03:23:42 <Saizan> shachaf: cata is the main component of the proof that Mu F is initial
03:23:59 <typoclass> > case lookup 1 [(1,"hello"),(2,"world")] of Just x -> x ++ " meow" -- Andrea__
03:24:00 <lambdabot>   "hello meow"
03:24:30 <Andrea__> > lookup 1 [(1,"hello"),(2,"world"]  ++ "!"
03:24:31 <lambdabot>   <hint>:1:33: parse error on input `]'
03:24:48 <Gracenotes> though the key is the case statement
03:25:02 <typoclass> Andrea__: have you seen my example? you need "case ... of" as i showed
03:25:27 <Andrea__> if the funktion gives 10000 different intergers i must write 10000 case statements ?
03:25:46 <shachaf> Saizan: What's cata?
03:25:55 <Gracenotes> if it gives 10,000 integers, you probably missed a few thousand
03:26:04 <shachaf> Isn't that Fix f -> (f a -> a) -> a?
03:26:15 <Gracenotes> er, but yes, if there were no accidental null pointer exceptions/segfaults, then it would not be necessary (from a software engineering perspecive) to do explicit case analysis, because everyone would handle everything in their head just fine.
03:26:18 <typoclass> Andrea__: no, you don't have to write 10000 cases. "x" is the name of the integer
03:26:22 <Botje> Andrea__: why do you thnk that?
03:26:46 <Andrea__> typoclass, does the case statement use pattern matching for extracting the x ?
03:27:02 <typoclass> Andrea__: yes, exactly. "Just x" is the pattern match
03:27:06 <Andrea__> ok
03:27:10 <Andrea__> thanks
03:27:21 <Andrea__> thats the solution
03:29:22 <Andrea__> typoclass, the possible cases are Nothing or the used value eg. String or Int so its if  then an alternative ?
03:30:00 <Saizan> shachaf: cata is something that produces a morphism Mu F -> A, given an F-algebra A
03:30:45 <shachaf> Saizan: I'm talking about newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }
03:31:01 <typoclass> Andrea__: no, i don't think you can use if-then-else for your problem
03:31:03 <Saizan> runMu then
03:31:08 <shachaf> Right.
03:31:36 <Saizan> anyhow i think Cofree f b = exists a. (f a, a -> b)
03:32:00 <Saizan> err
03:32:04 <Saizan> anyhow i think Cofree f b = exists a. (a, f a, a -> b)
03:32:32 <Saizan> yeah, that should fit
03:33:05 <shachaf> Oh!
03:33:05 <LordBrain> i see that cabal makes cpp flags like MIN_VERSION_base(3,0,0)  is there somewhere i can see a list of these? Is MIN_VERSION all they provide? what if i want to know if a specific package is installed at all, do i use MIN_VERSION_...(0,0,0) or something?
03:33:07 <shachaf> Saizan++
03:33:40 <shachaf> Saizan: I kept messing with (a, a -> (b, f a)) rather than using a itself.
03:33:52 <shachaf> But of course Free uses r itself so it only makes sense.
03:34:50 <shachaf> Cofree (Coalgebra f) = exists x. (x, x -> b, x -> f x)
03:34:54 <mauke> LordBrain: http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
03:35:11 <LordBrain> i read that mauke
03:35:20 <LordBrain> it seems very tutorial like and not comprehensive
03:35:26 <shachaf> Saizan: Are there other interesting things we can apply Cofree to?
03:35:39 <typoclass> LordBrain: not sure about a list. the final part is the package name, so if you depend on package doodle, you can expect a macro MIN_VERSION_doodle
03:37:20 <LordBrain> ok
03:37:35 <Saizan> shachaf: i'm blanking on them
03:38:44 <LordBrain> so i could do something like  build-depends: haskell98 || haskell2010, and then in the code #ifdef MIN_VERSION_haskell98 ...
03:39:25 <Andrea__> typoclass, i tried your solution, it works fine, thx
03:39:35 <typoclass> LordBrain: yeah i suppose you could do that, or something similar
03:39:42 <Saizan> shachaf: http://ncatlab.org/nlab/show/free+functor#for_cofree_functors_14
03:39:50 <Saizan> (haven't read it)
03:39:53 <LordBrain> maybe supporting haskell98 in 2013 is just a bit too much legacy
03:40:20 <LordBrain> does cabal work with other compilers besides ghc?
03:40:23 <Saizan> http://ncatlab.org/nlab/show/free+functor#cofree_functors_11 <- hah, poor cofree's
03:41:08 <seliopou> LordBrain: yes, run cabal help install to see the list of compilers it supports
03:45:59 <shachaf> What's a good name for the monad "data M a"?
03:47:28 <hpc> shachaf: for lack of more information, M is perfect
03:47:42 <ion> shachaf: Vonad
03:48:17 <shachaf> Wait, I meant comonad.
03:48:24 <shachaf> What's a good name for the comonad "data W a"?
03:49:45 <Saizan> "empty" should be understood
03:50:00 <banister> anyone else find the haskell-mode for emacs does a lot of crazy weird indentation?
03:50:18 <shachaf> Well, "Void" is understood too, but already taken. I was hoping for a name that indicates the kind or something.
03:50:31 <mauke> ConstVoid
03:50:39 <banister> shachaf: what's a comonad?
03:50:51 <mauke> banister: a messed up monad
03:50:55 <banister> cool
03:51:01 <LordBrain> maybe VoidComonad?
03:51:19 <hpc> oh i see, it's an empty data declaration
03:52:22 <mauke> Voldemonad
03:52:29 <LordBrain> lol
03:53:16 <LordBrain> TheComonadWhoseNameWeDoNotSpeak
03:53:19 <shachaf> I'll just call it Void1.
03:53:35 <shachaf> Sounds like GHC needs superpolykinding.
03:53:38 <shachaf> Or maybe kind classes.
03:54:14 <weebl> how do i map a function over all pairs in a list, so [a1,a2,a3] -> f a1 a2 ++ f a2 a3 ++ f a1 a3
03:54:30 <shachaf> Void :: Voidy k => k, with instances for * and Voidy b => (a -> b)
03:55:17 <mauke> > ap zip (tail . cycle) [a,b,c]
03:55:18 <lambdabot>   [(a,b),(b,c),(c,a)]
03:55:21 <LordBrain> weebl, lots of ways.. could use a comprehension [f x y | x <- as, y<-as]
03:55:56 <mauke> :t \f -> concatMap f . ap zip (tail . cycle)
03:55:56 <lambdabot> ((b1, b1) -> [b]) -> [b1] -> [b]
03:55:58 <elliott> shachaf: perhaps you can instance Comonad Any
03:56:21 <kaw_> To follow the example you'd have to be careful to exclude "f a1 a1" and so on, though
03:56:30 <weebl> thanks guys
03:56:38 <LordBrain> oh yeah good point kaw_
03:56:42 <mauke> > (\f -> concatMap f . ap zip (tail . cycle)) (\x y -> [x, y]) [a,b,c]
03:56:43 <lambdabot>   Couldn't match expected type `(Debug.SimpleReflect.Expr.Expr,
03:56:43 <lambdabot>              ...
03:57:07 <LordBrain> weebl, lots of ways.. could use a comprehension [f x y | x <- as, y<-as, x /=y] heh
03:57:07 <mauke> > (\f -> concatMap (uncurry f) . ap zip (tail . cycle)) (\x y -> [x, y]) [a,b,c]
03:57:09 <lambdabot>   [a,b,b,c,c,a]
03:57:27 <LordBrain> sorry for the cut paste
03:58:02 <kaw_> But then you're excluding them by value and not position, right?
03:58:11 <LordBrain> yeah i thought of that after i posted
03:59:03 <weebl> good point
03:59:16 <shachaf> What's this type called? data Foo t a = Foo a (t -> a)
03:59:31 <LordBrain> Foo
03:59:35 <LordBrain> lol
04:05:19 <LordBrain> mauke, your pairs function relies on the list only having 3 elements
04:05:54 <LordBrain> or wait
04:05:59 <LordBrain> i missunderstood the question maybe
04:06:14 <LordBrain> or you did
04:06:17 <LordBrain> heh
04:06:52 <Lethalman> shachaf, that seems function application
04:07:12 <Lethalman> right?
04:07:24 <Lethalman> mh no
04:08:12 <Lethalman> it would have been in case Foo t (t -> a) maybe
04:09:27 <Gracenotes> shachaf: it is called "You better have a t if you want more than one a"
04:09:30 --- mode: ChanServ set +o elliott
04:09:35 --- mode: elliott set +b *!*Adium@*.dcc.fc.up.pt
04:09:35 --- kick: xxx-man was kicked by elliott (ban evasion)
04:09:38 --- mode: elliott set -o elliott
04:11:01 <Gracenotes> seems a bit uninteresting, unless t is related to a somehow
04:11:42 <wallmani> 3 day week
04:11:46 <wallmani> this is so great
04:11:58 <phryk> wallmani: congrats.
04:12:13 <wallmani> thank you
04:13:17 <phryk> Is there a minimal size web framework for haskell? I'm coming from python and like the size flask has… I know of happstack, yesod and snap but none of those seems to be particularly minimalist.
04:13:20 <Gracenotes> I have a 7 day week
04:13:38 <wallmani> Gracenotes: a 7 day work week?
04:13:43 <phryk> I have 5 workdays, 6h each. And am grossly underpaid :F
04:13:51 <Gracenotes> Okay, I have a 0-day week
04:14:10 <AfC> phryk: how minimal do you want? A standards compliant web server is a non-trivial endeavour.
04:14:28 <Gracenotes> Snap is fairly minimal, I thought
04:14:54 <wallmani> ah
04:14:57 <wallmani> i am an intern now
04:14:59 <AfC> Gracenotes: I agree, especially if you're just using the snap-core part.
04:15:09 <wallmani> and we get 1 paid day off, and 4th of july is a holiday
04:15:17 <Gracenotes> yeah, it doesn't even have rendering HTML. :)
04:15:18 <wallmani> so everyone is taking the 5th off
04:15:21 <Lethalman> phryk, minimalist often means it doesn't handle cache, file uploads etc. gracefully
04:15:38 <phryk> AfC: Not as small as only cgi or fastcgi, but I mostly just want url routing and a simple way to return data (headers + content) as well as serving files
04:15:40 <Lethalman> phryk, there's also scotty which is minimalist enough for minimal rest services
04:15:42 <wallmani> and can be subject to slowloris
04:15:58 <phryk> wallmani: slowloris?
04:16:01 <wallmani> yeah
04:16:03 <wallmani> 1 sec
04:16:11 <Lethalman> phryk, try scotty then, but you can't do more than what you asked
04:16:14 <hvr> banister: which indentation mode are you using? :)
04:16:19 <wallmani> http://ckers.org/slowloris/
04:16:32 <wallmani> a more robust framework (sans apache) handles it well
04:16:59 <wallmani> but i had a "friend" slowloris my jekyll website for a week straight and it was hellish
04:17:00 <banister> hvr: i'm just using haskell-mode, say i enter: data Blah = Blah   and then press enter C-j, it'll stick the cursor right under the = on the next line, instead of against the margin
04:17:39 <phryk> wallmani: Interesting, thus far I've only used httperf from time to time to determine how well my stuff copes…
04:17:40 <Gracenotes> a static website?
04:17:53 <wallmani> phryk: ah, slowloris is really mostly annoying
04:18:11 <wallmani> if you are hosting your website on at least 100mbit and you give it enough resources, it will be fine
04:18:13 <banister> hvr: similarly, if i enter: hello :: [a] -> List a   and press C-j, it sticks the cursor under the [ on the next line
04:18:23 <wallmani> if it's on a home connection, you're in a bad position
04:18:34 <phryk> Gracenotes: No, current site is some small lisp thing (only lisp thing I ever wrote and thusly really ugly)
04:18:54 <Gracenotes> ah, at least I mean, the jekyll one.
04:19:10 <hvr> banister: it's just there's 3 different indentation modes
04:19:12 <Gracenotes> hacker news is lisp, though. great success story for lisp. or somethin.
04:19:21 <hvr> banister: see https://github.com/haskell/haskell-mode/blob/master/haskell-mode.texi#L130
04:19:36 <phryk> Gracenotes: Yes, and I do plan to do some more lisp some day, but that day is not today. :P
04:19:43 <hvr> banister: (it's better readable via emacs' Info reader)
04:19:44 <wallmani> :D
04:20:02 <banister> hvr: oh, which one do u use?
04:20:47 <phryk> So, another approach: I haven't really done anything much with haskell thus far. What web framework will most likely enable me to write maintainable code while I'm not very experienced with haskell?
04:20:48 <hvr> banister: does that matter? :) (I currently use 'haskell-indentation')
04:20:52 <startling> Gracenotes: "great success story"
04:21:07 <banister> hvr: well, i assume you have a decent one since you seem to know what youer' doing :)
04:21:37 <Gracenotes> it's a working website
04:21:37 <hvr> banister: well, all 3 modes have their merits; it's just a user preference
04:21:51 <astor> What is a modern way to use Generics to derive some serialization function? I've found cereal-derive, but the package is stale and depends on an out-of-date base.
04:22:23 <bor0> I'm trying to get a grasp of monads.. I read the wikipedia article about it but I don't think I still get it fully. what is the usefulness of it? for example, why do we have an identity monad when we can simply do lambda (\x -> x)
04:23:01 <byorgey> bor0: the identity monad is not actually very useful.  I wouldn't worry about that if I were you.
04:23:11 <ocharles> bor0: some things are generalised to run over arbitrary functors/applicatives/monads, so it's handy to have something when you don't need any side effects
04:23:37 <ocharles> it doesn't "do" anything, but it's a handy construction to have, from time to time
04:23:42 <bor0> how would you explain monads to someone that has experience with C/C++/PHP
04:23:49 <byorgey> ocharles has a good point though.  I guess the identity monad is useful for the same reason that the identity function is useful.
04:23:52 <chrisdone> byorgey: it's useful as a base monad because you know you'll end up needing a monad eventually
04:24:07 <ocharles> it's very useful in transformers, but it has uses on its own
04:24:11 <chrisdone> and you'll hate yourself for not writing your 500 line module in monadic style originally
04:24:23 <ocharles> http://ocharles.org.uk/blog/posts/2013-01-22-deriving-traversals.html I use Identity in that, for example
04:24:43 <ocharles> but mostly for teaching purposes
04:25:01 <byorgey> bor0: I would first teach them about types, and type inference, and kinds, and type classes, and functors, and Applicative.  Then I would tell them the definition of the Monad class and show them lots of examples.
04:25:02 <ocharles> In lenses, Identity gives you a setter, iirc
04:25:18 <ocharles> but what byorgey said :)
04:25:22 <byorgey> bor0: their experience in C/C++/PHP is irrelevant.
04:25:32 <ocharles> Learn/teach it by example, and the rest will eventually come
04:25:43 <bor0> okay. what about functors and Applicative, what are those things?
04:25:57 <byorgey> @where typeclassopedia
04:25:57 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
04:26:00 <byorgey> bor0: ^^^
04:26:12 <Andrea__> byorgey, can you give me a url with easy monad examples ?
04:26:16 <ocharles> I like to teach people (>>=) by not even calling it 'monadic bind' or anything, and I restrict it to be monomorphic - teaching it once for Maybe, and then once for State
04:26:19 <ocharles> and then showing how it generalised
04:27:08 <byorgey> Andrea__: http://www.haskell.org/haskellwiki/All_about_monads
04:27:14 <LordBrain> sounds like you have some experience teaching new haskellers ocharles
04:27:15 <typoclass> bor0: i wouldn't worry about monads too much; it's not really a big deal. it's a typeclass that has 3-4 functions. there's a few commonly used instances, and a number of other instances. there's a tiny bit of syntax called do-blocks which the compiler translates to calls to these functions. a number of functions in the standard library consume a monad, or spit one out. (or both.)
04:27:34 <LordBrain> or did you just assume that it would be easier more concrete?
04:27:45 <shachaf> bor0: I recommend the FAQ entry on the topic:
04:27:47 <shachaf> @where faq
04:27:47 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:27:56 <bor0> thanks for all the links, I'll go through them now
04:28:04 <Gracenotes> Usually a lot of constructs in a language are a single direction to abstract in, and you apply it in circumstances X and Y, etc. Monads provide several directions at once, and flexibly/interchangeably, and often opaquely.
04:28:16 <ocharles> LordBrain: I have occassionaly had to explain monads to people who don't really know Haskell
04:28:21 <Gracenotes> Which is a good thing, for separating out effects and reducing coupling.
04:28:35 <ocharles> So we scribble down the type signatures for (>>=) specialised to Maybe (for example), and see what it would mean to write that
04:29:20 <typoclass> bor0: it's a bit like ... i don't know ... maybe lists? it'll be hard to explain this in the abstract with any precision, but once you've seen some functions that use lists or produce lists, and tried them out in ghci, you get the idea of what lists are good for
04:29:30 <ocharles> I also like to go the opposite direction, and take an expression 'foo >>= bar' and expand it out (substituting the definition of >>= inline)
04:31:23 <LordBrain> maybe it would be better to teach them fmap first, then join, and then explain bind in terms of those..
04:31:43 <bor0> I'm already into haskell, I'm at chapter 7 of LYAH, so lists and lambda and recursion seem to be in vain for now :)
04:32:08 <Andrea__> (>>=)  is an operator for monads but it doesnt explain what a monad is
04:32:15 <Andrea__> :(
04:32:25 <LordBrain> i like the all about monads site
04:33:17 <startling> Andrea__: a monad is a data type that lets you do >>=
04:33:18 <Andrea__> the most tutorials explain monads with "Maybe"
04:33:20 <startling> (and 'return')
04:33:29 <Lethalman> Andrea__, this is the best explanation I've found personally so far about monads: http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
04:33:29 <startling> Andrea__: that's it.
04:33:54 <eikke> startling: actually return comes from Pure or Applicative ;-)
04:33:56 <Lethalman> which essentially tells you the reason behind the concept and how you can do it without using Monad itself
04:34:22 <Andrea__> Lethalman, i know your posted tutorial, but i don't undesrtand it
04:34:29 <Gracenotes> well, a data type which takes another data type as an argument.
04:34:32 <Lethalman> oh well
04:34:34 <startling> eikke, not in haskell it doesn't.
04:34:39 <eikke> yet
04:35:08 <startling> eikke, in any case, a monad is still a thing that lets you >>= an return
04:35:22 <eikke> and fail ;-)
04:35:25 <startling> eikke: it so happens that you can derive an Applicative instance for any monad. that's unrelated
04:36:14 <typoclass> oh neat. hflags supports a pure function to depend on a command line flag. see get :: (a, a) -> a https://github.com/errge/hflags/blob/master/examples/package/Tup.hs
04:36:15 <startling> Andrea__: there's nothing special about >>=, it's just a convenient interface for lots of different things
04:36:23 <bor0> @@src Monad
04:36:30 <bor0> @src Monad
04:36:30 <lambdabot> class  Monad m  where
04:36:30 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
04:36:30 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
04:36:30 <lambdabot>     return      :: a -> m a
04:36:30 <lambdabot>     fail        :: String -> m a
04:37:01 <Andrea__> > (putStr "hello "  >>=  (\x -> putStr "world" )
04:37:02 <lambdabot>   <hint>:1:47:
04:37:02 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
04:37:15 <Andrea__> > putStr "hello "  >>=  (\x -> putStr "world" )
04:37:16 <lambdabot>   <IO ()>
04:38:40 <LordBrain> I remember when i was learning, it was presented to me that there were two ways to think about monads, Monads as containers, and monads as computations, Then later i got into the correlation to category theory version of monads, where haskell functions are morphisms and types are objects.
04:39:22 <Andrea__> > putStr "hello " >>= (\x -> putStrLn "World")
04:39:23 <lambdabot>   <IO ()>
04:39:24 <typoclass> LordBrain: i'm assuming that typeclassopedia was what 'presented' this to you :-)
04:39:34 <Gracenotes> definitely computation. yep.
04:39:41 <byorgey> Andrea__: lambdabot doesn't execute IO actions
04:39:48 <byorgey> Andrea__: for security reasons
04:39:49 <Andrea__> byorgey, ok
04:40:10 <LordBrain> well no, i think i might predate it, but the creators yes, ed and cale
04:40:17 <Andrea__> then a similar example with Maybe or lists
04:40:44 <elliott> edwardk(?) and Cale didn't write the Typeclassopedia...
04:40:54 <LordBrain> i mean at some point i did consume typeclassopedia tho, so yes
04:40:57 <elliott> that was byorgey :)
04:40:58 * typoclass purrs
04:41:10 <Gracenotes> well, the monads as X was
04:41:14 <LordBrain> but edwardk and Cale first
04:41:15 <LordBrain> i think
04:41:27 <LordBrain> and all about monads, and some other tutorials
04:41:36 <byorgey> I'm pretty sure I didn't come up with those ideas myself, but I'd be hard-pressed to tell you exactly where it all came from
04:42:02 <LordBrain> yeah i cant recall all the monad tutorials there have been now
04:44:24 <Mortomes|Uni> It's all burritos, man
04:45:19 <LordBrain> i think getting the connection to the category theory definition of monad isn't really stressed to beginners because they dont want to scare people off, but i'm not so sure that it is so scary as that, and people interested in haskell might not be as adverse to learning some  math as the general population.
04:45:29 <startling> I have a Conduit (actually a Source m ByteString) that I want to parse as Html and also write out to a file. is there a composable way to do this?
04:46:47 <banister> if i have multiple fmap definitions for a variety of type constructors, how come they dont override/conflict with eachother?
04:47:21 <elliott> because the fmap to use is chosen based on the type.
04:47:24 <elliott> that's what typeclasses do
04:47:28 <startling> banister, it doesn't matter, since they allhave the same type signature
04:47:38 <banister> ah, so this is a feature of typeclases, not of functions in general?
04:47:48 <startling> yeah.
04:47:54 <elliott> yes, typeclasses do overloading
04:48:14 <banister> so if i just have a function (that's not part of a typeclass) but provide multiple definitions for it, those definitions *will* conflict?
04:48:28 <startling> yes.
04:48:30 <typoclass> banister: yes, that will be a compiler error
04:48:34 <banister> cool, thanks
04:48:52 <LordBrain> startling, well a very quick and easy solution would be to use Data.Conduit.Binary.conduitFile
04:49:23 <startling> LordBrain, oh, interesting
04:50:01 <Andrea__> in a haskell book i read an example of make logging of function results , is this  a good explanation for monads ?
04:50:02 <startling> how do conduits' return types work? does that that return each chunk, or does it build a big bytestring?
04:50:26 <typoclass> Andrea__: yeah, that's a perfectly good monad. (called Writer in the standard library)
04:51:19 <Andrea__> typoclass, in the book the first step is make function compositions and add the logging
04:51:46 <Andrea__> typoclass, in the last step the help function is replaced with (>>=)
04:52:31 <typoclass> Andrea__: yeah, that's a good description. i remember a similar tutorial online
04:58:47 <KingofFerrets> Uuugh.
04:59:32 <KingofFerrets> Haskell hates my types. ;.;
04:59:42 <Andrea__> what do you think about this ?  : http://learnyouahaskell.com/
04:59:54 <shachaf> Saizan: So given that cata is trivial to write, how do you prove initiality of Mu?
05:00:38 <RichyB> Andrea__: Learn You A Haskell is a very widely-liked Haskell tutorial in a similar kind of style to _why's Poignant Guide to Ruby.
05:01:29 <RichyB> Andrea__: I didn't learn Haskell from it, (it wasn't written yet at the time ☺) so I'm not sure first-hand how effective it is as a tutorial, but it has a good reputation.
05:02:37 <Gracenotes> LYAH gets invited to all of the parties
05:03:18 <Andrea__> in my opinion , this book is incredible difficult:  http://book.realworldhaskell.org/
05:03:37 <Saizan> shachaf: proving it's an homomorphism comes out of the definition fairly directly too: cata alg . In = alg . fmap (cata alg)
05:03:46 <MasseR> Andrea__: I found reading rwh and lyah parallel helped
05:03:47 <Saizan> shachaf: then you have to prove it's initial
05:03:54 <LordBrain> you might like it more when you get more advanced Andrea__
05:03:54 <Saizan> shachaf: err, unique
05:04:05 <LordBrain> i still find it useful
05:04:07 <MasseR> lyah was more theoretical which provided the foundation for rwh. Rwh provided the glue that made things click
05:04:10 <alpounet> Andrea__, i tend to suggest people to read LYAH and then study RWH (even if they do so quicker than usual)
05:04:11 <Andrea__> LordBrain, ok, i hope so
05:05:15 <Hafydd> I wonder how many of the people frequently recommending LYAH have actually learned from it themselves for the first time.
05:05:20 <Hafydd> I'd guess it's close to 0.
05:05:47 <startling> I did.
05:05:50 <banister> aassuming i have a user defined list like this: data List a = Nil | Cons a (List a) deriving (Show)
05:05:59 <banister> how would i write the type signature for the <*> method?
05:06:04 <startling> I got annoyed with it and switched to the gentle introduction about 3/4 through though
05:06:05 <banister> i can't seem to figure it out
05:06:06 <shachaf> Saizan: Wait, which Mu are you talking about here?
05:06:17 <Saizan> shachaf: oh, yeah, sorry
05:06:24 <Andrea__> i own a book in my mother language , but it's not very complete
05:06:44 <startling> :t (<*>) :: [a -> b] -> [a] -> [b]
05:06:50 <lambdabot> [a -> b] -> [a] -> [b]
05:06:57 <startling> banister, ^
05:06:58 <KingofFerrets> I didn't like LYAH that much, personally.
05:07:00 <Saizan> shachaf: well, your In is a function rather than a constructor, i guess it's harder that way
05:07:07 <shachaf> Saizan: Is Fix initial or terminal or "haskell is weird" or what?
05:07:26 <KingofFerrets> Mostly because all of its code examples were absolutely tiny. Things seemed intuitive, and then I tried to write bigger functions and it went badly.
05:07:29 <Saizan> shachaf: it's both
05:07:40 <banister> startling: so: applyFuncs :: (List (a -> b)) -> List a -> List b   ?
05:07:42 <startling> LordBrain: oh, I misread that type signature. I get it now.
05:07:47 <startling> banister, sure
05:07:49 <shachaf> Saizan: Depending on what kind of recursion you allow in defining values?
05:08:00 <Saizan> shachaf: bottom makes Mu and Nu degenerate into each other
05:08:07 <KingofFerrets> Unrelated note: Is there a way to get something out of the State monad and put it in the IO monad instead? x.x
05:08:09 <banister> startling: thanks
05:08:13 <startling> banister, (there's a spare set of parens there though)
05:08:22 <startling> KingofFerrets: give it initial state and run it?
05:08:24 <shachaf> Saizan: Cale and I had a bit of trouble proving the Mu f <-> f (Mu f) isomorphism earlier.
05:08:24 <startling> :t runState
05:08:31 <lambdabot> State s a -> s -> (a, s)
05:08:43 <Gracenotes> shachaf: in agda?
05:08:57 <startling> :t \s -> return . evalState s
05:09:02 <KingofFerrets> ...Oh. Derp. x.x
05:09:03 <lambdabot> Monad m => State a b -> a -> m b
05:09:04 <shachaf> I don't think Agda was involved.
05:09:05 <KingofFerrets> That is a good point.
05:09:13 <Gracenotes> or diagrams.. or Haskell.. or English..
05:09:17 <Gracenotes> in any case
05:09:22 <startling> KingofFerrets: there's no reason that needs IO, anyway
05:09:32 <Saizan> shachaf: http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt <- maybe this draft has the missing details on these encodings
05:09:51 <startling> is lambdabot sick or do I have abnormally high latency?
05:10:16 <KingofFerrets> There isn't, no.
05:11:11 <KingofFerrets> I just wanted to get it into the IO monad because I'm printing out my results... Anyway, now it's just a "let (thingIwant,_) = runState (stateThing) generator" in my IO block. Except with names that are relevant to what I'm doing.
05:11:31 <Saizan> shachaf: parametricity is going to be involved somewhere
05:11:35 <LordBrain> KingofFerrets, the State monad isn't side effecting, it just simulates state. It's generally not so practically useful I find, except in its transfomer form.  It just serves to make pure code have a more imperative look, but not more readable or anything...
05:11:40 <startling> KingofFerrets: you don't need something to be in IO to print it
05:12:24 <startling> :t \s -> print . evalState s
05:12:27 <lambdabot> Show b => State a b -> a -> IO ()
05:12:34 <LordBrain> StateT is useful, don't get me wrong...
05:12:44 <Gracenotes> State is nice if you are threading something through a basically pure computation.
05:12:59 <Gracenotes> iterating through a tree, kind of thing
05:13:32 <KingofFerrets> I'm using it for random number generation. (Technically there's a Random monad, but I've been finding it easier to just use the State monad for it.)
05:14:11 <KingofFerrets> Hm. Didn't know about that... I'm just using putStrLn to print, so I figured I should stick it into IO.
05:14:39 <LordBrain> putStrLn takes a pure value
05:14:53 * hackagebot range 0.1.0.0 - This has a bunch of code for specifying and managing ranges in your code.  http://hackage.haskell.org/package/range-0.1.0.0 (RobertMassaioli)
05:15:03 <KingofFerrets> blah
05:15:05 <LordBrain> you only need it in io if you are binding into it, like something >>= putStrLn
05:15:16 <KingofFerrets> I am
05:15:45 <KingofFerrets> it's the result of a bunch of computation after I read stuff from a config file and then randomly generate stuff and then pull it out and then print it
05:16:20 <banister> does anyone have an implementation on the <*> for lists?
05:17:11 <startling> banister, do you know what it does?
05:17:56 <typoclass> elliott: hai, i have a patch for lambdabot. (i find her insults annoying.) where do i put it? there's at least 2 lambdabot forks on github
05:17:58 <banister> startling: yeah, i think so
05:18:06 <startling> banister, what is it?
05:18:24 <elliott> typoclass: upstream maintainer is mokus0 on github
05:18:34 <typoclass> elliott: excellent, thanks
05:18:56 * typoclass clones
05:18:59 <Gracenotes> all insults? :x
05:19:35 <banister> startling: unlike fmap which just applies a function to a functor (by unwrapping, applying and then rewrapping) <*> seems to be able to apply a function that's wrapped in a functor to a functor
05:19:39 <Gracenotes> I mean, you're bothering her for something that doesn't even exist. what's up with that.
05:19:59 <startling> banister, what does it specifically do for lists?
05:20:39 <banister> startling: oh, afaik if you have an array of functions it applies each of those functions to each element in the list, and then concats the results together
05:20:52 <startling> banister, right
05:21:04 <merijn> banister: There's two possible implementations of <*>, try and find the two that fit the type signature :)
05:21:11 <saep> > [(+1), (+2), (*3)] <*> [1..10]
05:21:12 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,3,6,9,12,15,18,21,24,27,30]
05:21:17 <mauke> _ <*> _ = []
05:21:20 <banister> merijn: recursion still hurts my head :)
05:21:23 <typoclass> Gracenotes: hm? i mean the stuff "you type like a squirrel, monkeybrains" or whatever
05:21:27 <typoclass> @src abcde
05:21:27 <mauke> banister: don't use recursion then
05:21:27 <lambdabot> Source not found. I feel much better now.
05:21:47 <startling> banister, so you have a function. how do you apply it to all of the things in a list?
05:21:59 <banister> startling: good point, i get it
05:22:00 <Hafydd> You're going to remove those? I support this.
05:22:25 <Gracenotes> yeah, abcde doesn't exist. why even ask. really now.
05:22:27 <mauke> @nixon
05:22:27 <lambdabot> Once you get into this great stream of history, you can't get out.
05:22:54 <LordBrain> history is a one way monad then
05:22:58 <LordBrain> heh
05:22:59 <t7> warning C question: is there a function like scanf that reads from a string rather than stdin?
05:23:12 <elliott> ##c
05:23:22 <merijn> t7: fscanf, l2manpage :p
05:23:29 <mauke> t7: sscanf
05:23:36 <Gracenotes> we should have lambdabot give incredibly sarcastic compliments, rather than insults
05:23:36 <merijn> oh, string
05:23:41 <elliott> are we really answering C questions in #haskell? :(
05:23:42 <merijn> I need to learn to read >.>
05:23:49 <startling> we should have lambdabot give recipes, rather than insults.
05:24:15 <LordBrain> i guess we're nicer than the c programmers
05:24:30 <byorgey> elliott: t7 is around here regularly though, it's not quite the same as answering a C question from some random person who just joined
05:24:32 <mauke> I am a C programmer
05:24:40 <LordBrain> I bet they wouldn't answer haskell questions in #c
05:24:45 <startling> haha
05:24:50 <mauke> that's because #c doesn't exist
05:25:07 <Gracenotes> startling: personalized life tips. register your interests with lambdabot, get advice on what you should be doing rather than bugging her.
05:25:19 <shachaf> I have a Haskell question!
05:25:27 <typoclass> shachaf: well done (?)
05:25:30 <LordBrain> mauke, and peopel say the haskell community is small... :P
05:25:45 * shachaf bravely tries to get the channel on-topic.
05:25:59 <shachaf> How do you boehm-berarducci/church/whatever-encode a type with arbitrary sums, products, and functions?
05:26:03 <Andrea__> the haskell community is great, i think
05:26:10 <shachaf> Using only a rank-2 type, not rank-n.
05:26:22 <shachaf> E.g. data Foo s a = Foo (s -> (s,a)) (s -> (s,a))
05:26:27 <mauke> I only know boehm-gc
05:26:45 <shachaf> mauke: You can pretend I said church, I think.
05:26:49 <merijn> shachaf: You forgot Scott encoding!
05:26:52 <shachaf> (Easy to pretend because I did.)
05:27:00 <elliott> shachaf likes getting off scot-free.
05:27:03 <shachaf> merijn: I don't really want Scott encoding.
05:27:08 <Gracenotes> picky
05:27:13 <merijn> Pffft
05:27:22 <shachaf> Though if you gave me Scott encoding that would be OK too.
05:27:23 <typoclass> Gracenotes: my suggestion is for lambdabot to make weird excuses, claiming that she had too much whiskey, too little coffee, etc
05:27:41 <shachaf> But Scott encoding can require recursive types and all sorts of crazy things.
05:27:46 <Gracenotes> typoclass: hardly. it's the fault of the person asking, not lambdabot's
05:27:51 <shachaf> Does someone have an encoding for data Foo s a = Foo (s -> (s,a)) (s -> (s,a)) ?
05:28:09 <Gracenotes> and the person asking should accept that it is their fault for being monkey-brained imbeciles etc.
05:29:42 <Gracenotes> shachaf: to be totally dense, not just ((s -> (s, a)) -> (s -> (s, a)) -> r) -> r, here?
05:29:53 * hackagebot hdocs 0.1.0.0 - Haskell docs daemon  http://hackage.haskell.org/package/hdocs-0.1.0.0 (AlexandrRuchkin)
05:29:55 <LordBrain> maybe lambdabot should get all needy and codependent... he can reassure us that he's trying and ask if we still love him
05:30:23 <Gracenotes> what is wrong about that
05:31:02 <typoclass> LordBrain: please don't refer to her as 'him'
05:31:17 <mauke> ((s -> (s -> a -> r1) -> r1) -> (s -> (s -> a -> r2) -> r2) -> r3) -> r3
05:31:23 <eikke> GHC.NT looks cool/interesting/useful
05:31:36 <Gracenotes> oh. I see that (s, a) is not actually encoded. derp.
05:31:44 <shachaf> mauke: Doesn't that need a rank-3 type?
05:31:46 <elliott> I would rather the insults just be removed if anything is done about them.
05:31:51 <elliott> (personally I don't care either way)
05:31:57 <mauke> shachaf: I don't know, I haven't even started thinking about foralls yet
05:32:20 <shachaf> I guess maybe it doesn't *strictly* need it...
05:32:31 <shachaf> OK, maybe this approach is workable.
05:32:44 <shachaf> Then you just do an optimization for State.
05:33:15 <shachaf> Er, wait, no that doesn't really work, does it?
05:33:52 <shachaf> Or maybe it does.
05:34:22 <shachaf> So for State you have forall r2. ((forall r1. (s -> (s -> a -> r1) -> r1) -> r2) -> r2, and then you're allowed to turn forall q. (T -> q) -> q into T
05:34:54 * hackagebot splitter 0.1.0.0 - Use numerical ranges to split out certain lines from a file.  http://hackage.haskell.org/package/splitter-0.1.0.0 (RobertMassaioli)
05:35:10 <merijn> @tell conal The reactive docs say to contact you about different license terms, I want to use reactive (or at least parts) in a BSD licensed library. Since it has some other contributors, I guess that'd require contacting them. In case tat is to much work, I'd be happy to just reimplement things from the code in the push-pull paper, but I believe that has no explicit license at the moment?
05:35:10 <lambdabot> Consider it noted.
05:35:31 <elliott> I think there is an independent reimplementation of reactive?
05:35:33 <elliott> a recent one
05:36:02 <merijn> elliott: oh?
05:36:31 <elliott> I don't recall the name
05:37:01 <merijn> There's reactive-banana, but that's not really suitable for what I want (or rather, if it is, it's to complicated for me to figure out how)
05:37:19 <merijn> Most of the other FRP libraries seem to be Arrowized FRP, like netwire
05:37:47 <elliott> no, it was specifically related to reactive.
05:38:03 <elliott> though you realise that reactive has known space leak problems and such right?
05:38:09 <elliott> that's why reactive-banana/sodium exist
05:39:33 <Lethalman> elliott, reactive-banana and sodium don't suffer space leaks?
05:39:37 <merijn> elliott: Sure, the API as-is, isn't directly suitable to me anyway. But if I can avoid reimplementing everything from scratch that help
05:39:40 <elliott> Lethalman: in theory.
05:39:47 <elliott> and if used properly.
05:39:54 <elliott> obviously you can just introduce your own space leak if you want with any library.
05:40:01 <luite> you can always space leak if you're not careful
05:40:12 <elliott> it's more that the API doesn't *inherently* leak.
05:40:31 <Lethalman> elliott, in the sense that the internals of the library itself doesn't leak space
05:40:32 <Lethalman> ok
05:40:43 <merijn> elliott: I didn't know about sodium yet, I'll check that out too
05:40:45 <luite> merijn: sodium is pretty simple
05:40:54 <startling> wow monad-loops is cool
05:40:55 <luite> merijn: it automacially updates the frp graph
05:41:05 <luite> merijn: so you don't need to compile it
05:41:41 <luite> merijn: here are some simple examples with input field and mouse inputs: http://weblog.luite.com/wordpress/?p=127
05:41:47 <merijn> luite: That might be more interesting
05:42:33 <luite> merijn: it only implements push frp, but that's often enough for user interfaces
05:42:44 <merijn> aww
05:43:02 <merijn> If I wanted just push FRP I might as well just use netwire
05:43:34 <banister> startling: cool, i think i did it. But where do i import the Applicative class from? i can't seem to actually make an instance of it
05:43:38 <elliott> oh, sodium doesn't have pull?
05:43:42 <merijn> banister: Control.Applicative
05:43:55 <merijn> banister: Also, Hoogle can answer these questions for you
05:44:01 <luite> elliott: it has sample, but no continuous time
05:44:17 <luite> i hope i have the terminology right here :)
05:45:02 <merijn> luite: Are you aware of any documentation other than the haddocks?
05:45:22 <LordBrain> it seems to me, that hoogle's search on types has gotten to loose at some point and just stayed that way, i have a distant memory of that feature once being more useful
05:45:38 <luite> merijn: not really. but i found it not really hard to understand
05:45:53 <shachaf> What is this type? Foo a = forall r. (a -> r) -> Maybe r -> r
05:46:59 <luite> elliott: what's a pull based frp thing that can't be done with push only? (just to check if i'm not totally wrong with my frp terminology) :)
05:47:15 <elliott> luite: I fear I may be totally mixed up too
05:47:19 <merijn> luite: It's not that you can't do things, it's that push can introduce really weird lags
05:47:58 <banister> is there a better way to say that <*> is implemented by applyFuncs here? https://gist.github.com/b1eb18cc544f17a90f5d
05:48:01 <luite> elliott: i meant that everything in the frp network only changes because of some Event or manual change to a Behaviour
05:48:08 <merijn> elliott, luite: Suppose you have a reactive behaviour animating something, in push FRP the animation won't update until the next event is pushed, which might be some seconds after the animation has finished
05:48:27 <banister> im doing: x <*> y = x `applyFuncs` y   but that looks kind of weird, how can i do that point free?
05:48:40 <typoclass> LordBrain: i was impressed with the by-type search recently, but i don't recall why exactly :-) i think it managed to find forM_ when i looked for a whenJust function ... Maybe a -> (a -> m ()) -> m ()
05:48:44 <merijn> banister: "(<*>) = applyFuncs"
05:48:52 <typoclass> LordBrain: do you have a specific problem?
05:49:09 <banister> merijn: ah, thanks
05:49:16 <luite> elliott: with continuous time, you might have things that change continuously (perhaps that can be done with a push framework by pushing Time -> Value functions through the network?)
05:49:18 <startling> banister, the better way would just be to put applyFuncs' definition there
05:50:02 <merijn> elliott, luite: pull FRP is basically, push FRP where you push a new update immediately after finishing with the old event
05:50:23 <LordBrain> typoclass, it almost always gives me a lot of extra "matches", some of which i don't see how they are relevant, like if i search 'a -> Maybe a' among the results i get 'listToMaybe :: [a]->Maybe a'   Why?
05:50:26 <luite> merijn: with sodium you just listen on changes of some of the animation behaviours
05:50:28 <merijn> elliott, luite: The problem is that that triggers a lot of recomputation in some cases, even though that computation isn't necessary
05:50:57 <typoclass> LordBrain: right, seems like a weird result
05:51:08 <LordBrain> it's been this way for years
05:51:50 <luite> merijn: for animation, see the balls example, i just push timestep events to trigger one integration step
05:51:53 <dwcook> The impression I got is that Hoogle performs unification.
05:51:56 <LordBrain> when i first learned about it, years ago it gave fewer and more relevant results
05:52:20 <luite> merijn: and snapshotWith to use the current values of other behaviours
05:52:21 <merijn> elliott: btw, do you have any information on that space leak in reactive that you mentioned?
05:52:37 <luite> merijn: do you know a cleaner way to do that?
05:53:26 <luite> (it works well this way in the browser, since you can use requestAnimationFrame, then push a timestep from there, update all objects, render everything)
05:53:46 <merijn> luite: Well, that was the idea behind reactive, only recompute time varying bits without computing Event results until they happen
05:53:52 <elliott> merijn: it's to do with the Monad instances, the way it does dynamic event switching
05:53:56 <elliott> I used to know the details, now I do not
05:54:02 <shachaf> Saizan: How is Free actually used? I've seen the type-class version before but I don't really know much about it.
05:54:37 <shachaf> Saizan: E.g. a free monoid is forall r. Monoid r => (a -> r) -> r
05:54:41 <luite> ah yeah, if you have a dynamic switch with a behaviour that accumulates values over time, it can build up a huge thunk when it's not used
05:54:48 <merijn> oh, I found some mailing lists
05:54:53 <luite> and then you get a delay when switching back
05:55:14 <shachaf> Would that be Free (Algebra Mon), where data Mon a = Unit | Times a a, and some laws that presumably come from somewhere?
05:55:32 <shachaf> (Where would the laws be expressed, if Haskell allowed us to express laws?)
05:56:23 <luite> merijn: hmm, would it be similar to snapshotWith a continuous time function?
05:56:29 <merijn> elliott: Well, there's some other problems, like the Example using mkEvent, which has been commented out in the source of the library, so there seems to be now such function
05:56:34 <Saizan> you could do Free IsMon, where IsMon a = (empty :: a, (<>) :: a -> a -> a, ..laws..)
05:56:38 <merijn> luite: I have no clue what snapshotWith does
05:56:55 <shachaf> You could do that.
05:57:05 <luite> merijn: snapshotWith :: Event a -> Behaviour b -> Event (a,b)
05:57:15 <shachaf> I'm wondering about where the laws go in the F-Algebra form, though, since that seems so popular and all.
05:57:22 <luite> merijn: it combines the current value of Behaviour b with the event at the time it fired
05:57:27 <Saizan> shachaf: there's no place
05:57:35 <shachaf> :-(
05:57:42 <Saizan> shachaf: for laws you use T-algebras
05:57:55 <merijn> luite: I'm not sure, I'd have to think on that
05:58:05 <shachaf> Saizan: Aha.
05:58:09 * shachaf looks up T-algebras
05:58:10 <luite> i guess i should revisit conal's paper :)
05:58:33 <luite> merijn: what do you want to use this frp for?
05:59:05 <shachaf> Saizan: Hmm, what kinds of laws does this let us express?
05:59:27 <luite> is there a javascript parser/prettyprinter for haskell that's faster than jmacro?
05:59:29 <merijn> luite: UI/widget library, because I'm not happy with what exists atm
05:59:36 <luite> merijn: cool :)
05:59:42 <shachaf> Is it limited to associativity/identity?
05:59:44 <luite> merijn: please make a web front end as well :p
05:59:52 <merijn> luite: Especially in terms of terminal things
06:00:01 <Saizan> shachaf: you should be able to do all the equational stuff
06:00:15 <merijn> luite: Well, I want to have something that generalises over different front ends, then other people can implement those for me!
06:00:17 <shachaf> OK, then I should read this properly, maybe after sleeping.
06:00:26 <Saizan> shachaf: probably not things like existence of inverse elements though
06:00:31 <typoclass> merijn: hm, like ncurses and stuff? faking windows and text fields on the console?
06:00:46 <shachaf> Oh. :-( What do you need for groups etc.?
06:00:46 <luite> merijn: that would be great. i'll try to make sure that the requirements are supported by ghcjs
06:00:52 <merijn> luite: The most important ones (to me) are terminal and opengl, web might be interesting, wx/gtk stuff would be neat, but sounds way to awful to implement
06:00:58 <elliott> merijn: I'd really ercommend giving reactive-banana another chance
06:01:00 <merijn> I have kinda given up on wx/gtk/tcl
06:01:03 <elliott> *recommend
06:01:15 <shachaf> Oh, maybe now I can understand Eilenberg-Moore categories.
06:01:19 <typoclass> merijn: you've given up on all three of them?
06:01:30 <Saizan> shachaf: maybe i'm just misremembering, T-algebras were the motivation for monads, to describe universal algebra
06:01:36 <luite> perhaps i'll add some reactive-banana samples later
06:01:39 <merijn> typoclass: Yeah, to stateful for what I want
06:02:04 <luite> but i'm not sure if it supports dynamic graphs as conveniently
06:02:20 <merijn> elliott: tbh, I'm not smart enough to understand reactive-banana
06:02:39 <elliott> I doubt that. it's pretty simple, really
06:02:45 <luite> hmm, it's probably just a bit tricky getting started
06:02:48 <elliott> have you read the blog posts on it?
06:03:16 <luite> i did some reactive-banana tests with ghcjs a few months ago and they worked... and i'm not the smartest guy either ;p
06:03:22 <Saizan> there's a free group monad afterall..
06:03:31 <merijn> elliott: Modifying the wx-banana stuff seems simple enough, but they're completely different from what I want
06:04:02 <merijn> elliott: Which blog posts? I studied the examples/docs/source, not sure which blog you're referring too
06:04:17 <luite> it's a bit annoying that the source is rather messy
06:04:21 <luite> and examples rather bare bones
06:04:33 <elliott> merijn: apfelmus's
06:05:08 <elliott> http://apfelmus.nfshost.com/blog.html
06:06:31 * shachaf will leave T-algebras for later.
06:07:16 <luite> reactive-banana's testimonials might make me switch to it
06:07:29 <shachaf> So without laws, you might use Free (Algebra Mon)?
06:08:04 <shachaf> Seems a bit suspicious.
06:09:03 <luite> elliott: it looks like reactive-banana doesn't support continuous time either?
06:09:12 <merijn> elliott: It seems reactive-banana has gutted continuous time too
06:09:41 <chrisdone> luite: do you know if there's somewhere in the webkit package to be able to access the dom directly?
06:09:54 <merijn> "My main change to Conal’s semantics is to remove the switcher function and to not implement continuous behaviors."
06:10:18 <luite> ah :)
06:10:39 <shachaf> Poor conal.
06:11:11 <elliott> hmm, when did that happen
06:11:19 <merijn> elliott: Second post in the series
06:11:29 <elliott> oh, well, it has changed a lot since then
06:11:34 <elliott> it now has dynamic event switching, for instance
06:11:34 <merijn> Maybe they've been reintroduced later, but then I haven't gotten there :p
06:11:45 <elliott> see for instance http://apfelmus.nfshost.com/blog/2011/04/28-frp-banana-0-2.html
06:12:09 <luite> chrisdone: i'm sure it's possible, since ghcjs-dom uses it (it uses "foreign import javascript" when compiled with ghcjs, and uses the webkit dom natively)
06:12:29 <luite> so you can write apps that work in browser and native without changes
06:12:31 <chrisdone> luite: i can't find anywhere in the API to access it
06:14:05 * typoclass . o O ( why is continuous time so important? )
06:14:38 <LordBrain> i guess it might be possible to have a leak free pull driven frp stream using conduits
06:14:42 <merijn> typoclass: Because it allows you to define things like "show for 5 minutes/second/whatever" without having to worry about lag/clock ticks
06:15:01 <adimit> ok, this is weird, and I think it's a GHC bug: I'm getting warnings about an unused identifier uid_a4F83, which I have not declared in my code.
06:15:43 <Lethalman> merijn, also animations then?
06:15:44 <adimit> (I can also produce a GHC panic if I alter the line slightly)
06:16:14 <chrisdone> luite: the source is full of stubs
06:16:20 <typoclass> adimit: maybe you're not linking against a c library that you need? (or possibly a haskell library if you have an old compiler and you forgot to say --make)
06:16:42 <typoclass> adimit: ... which obviously doesn't explain any panics or some such :-) paste code and error message?
06:16:42 <mauke> adimit: ghc panics are always bugs
06:16:44 <typoclass> @where hpaste
06:16:44 <lambdabot> http://paste.tryhaskell.org/new/haskell
06:16:45 <chrisdone> luite: all the non-ghcjs is `undefined': https://github.com/ghcjs/ghcjs-dom/blob/master/src/GHCJS/DOM/Attr.hs#L24
06:17:06 <luite> chrisdone: hmm, yeah and the C stubs return 0
06:17:10 <typoclass> merijn: i see. hm. and that's so important?
06:17:25 <adimit> typoclass, mauke, It's within my yesod site, which makes it somewhat harder to distill.
06:17:31 <luite> chrisdone: hamishmack is the person to ask, i think it used to work with the old ghcjs geenrator, but there have been some recent changes
06:18:05 <elliott> is there a nice way to merge two Data.Array.Arrays with disjoint indices?
06:18:14 <chrisdone> luite: yeah, i would ask him but i imagine he's asleep atm =)
06:18:26 <hamishmack> chrisdone: I have not made done the webkit stuff in ghcjs-dom yet.  The bindings are here though… http://patch-tag.com/r/hamish/webkit
06:18:43 <merijn> typoclass: That depends on whether you want to just hack something together that works, or care about making the (programming) world a better place
06:18:54 <luite> chrisdone: he sleeps at crazy hours ;)
06:18:58 <typoclass> merijn: right :-)
06:19:33 <chrisdone> hamishmack: is this a fork of the usual webkit package or a new thing entirely?
06:20:06 <hamishmack> I will be merging it into the main webkit repo
06:20:25 <preflex> http://pastebin.com/NWdyCN6N v
06:20:26 <mauke> The paste NWdyCN6N has been copied to http://paste.tryhaskell.org/3409226382503313408
06:20:50 <mauke> acceptable.
06:21:48 <hamishmack> Plan is to rename the type classes from ElementClass to IsElement for the DOM functions so they match ghcjs-dom
06:22:12 <typoclass> merijn: heh :-) i see
06:22:29 <hamishmack> then export the webkit modules from ghcjs-dom when using GHC as a compile
06:22:31 <luite> chrisdone: do you know what's the fastest javascript parser/prettyprinter for haskell? i tried jmacro, but it takes ~10 seconds to parse/print a 4MB JS file
06:22:38 <mauke> is it me or did hpaste ids use to be shorter?
06:22:48 <elliott> mauke: your script is making private pastes
06:22:49 <elliott> for some reason
06:22:52 <elliott> they're shorter if you make public ones
06:22:57 <chrisdone> mauke: that's a 'secret' url, there're now two buttons
06:23:12 <hpaste> adimit pasted “GHC panic w/ yesod” at http://paste.tryhaskell.org/90631
06:23:15 <Saizan> shachaf: it's in line with "algebras are evaluators for some language specified by F"
06:23:16 <chrisdone> hamishmack: cool =) i have a program i'm using webkit for but would like to work with the dom directly
06:23:20 <hamishmack> the "undefined" functions are just there for GHCJS to make it work without webkit
06:23:33 <mauke> "nice" html ಠ_ಠ
06:23:34 <chrisdone> luite: i tend to use beautifyjs, i don't like any of the haskell pretty printers
06:23:48 <chrisdone> mauke: hm?
06:24:05 <mauke> chrisdone: it's all on one line, making it unreadable
06:24:12 <shachaf> Saizan: What is?
06:24:21 <luite> chrisdone: oh i'm just preparing the source to send to a 'real' minifier/prettyprinter later
06:24:23 <chrisdone> mauke: ah, yeah, update: in this decade we use the inspector feature of browsers
06:24:34 <adimit> typoclass, mauke, that'd be the minimal code I need to make GHC panic. If I remove the call to runDB, I instead just get a warning about an unused identifier (in any case, it always warns about 'i' being unused, but that's natural. It'll only *then* complain about that uid_ ident.)
06:24:51 <luite> or is there a  minifier that you can easily add custom transformations to?
06:24:53 <chrisdone> luite: ah. not sure what's fast, in fay it's a custom printer
06:25:38 <luite> i just want to do a transformation step after linking, renaming many things, rearranging some
06:25:56 <luite> so closure and uglifyjs can do a better job
06:26:17 <Saizan> shachaf: that Free (Algebra Mon) A is the free monoid on A, except for laws, it's syntax for monoid expressions, given an evaluator and an environment you can get a value out
06:26:33 <preflex> http://pastebin.com/5ApUuZAU
06:26:38 <typoclass> adimit: oh. please report it on the ghc trac, including the hpaste link. (ghc bug tracker has an account "guest/guest", if you want)
06:26:38 <mauke> The paste 5ApUuZAU has been copied to http://paste.tryhaskell.org/90632
06:27:07 <Saizan> shachaf: or, what seems suspicious?
06:27:23 <mauke> elliott, chrisdone: thanks
06:27:38 <luite> does anyone btw know what can cause "interrupted system file" errors when saving files over sshfs?
06:27:42 <chrisdone> luite: none of them are particularly trustworthy… i'd say emcascript is most reliable, but i doubt it's that fast tbh… at least it's parsec, so you can maybe parse from bytestring or text?
06:27:47 <luite> err, "interrupted system call"
06:28:01 <elliott> mauke: standard support fee applies
06:28:18 <mauke> elliott: $
06:28:22 <mauke> (standard application)
06:28:23 <luite> chrisdone: perhaps i should just try to improve jmacro, or do binary serialization for the intermediate files
06:28:37 <adimit> typoclass: ok, I'll give it my best to make it a minimal example.
06:28:58 <elliott> mauke: sweet, just two more and I'll have $$$
06:29:04 <luite> but having editable text files is so much friendlier for users
06:29:14 <mauke> > replicate 5 '$'  -- make $$$$$ fast!
06:29:15 <lambdabot>   "$$$$$"
06:29:17 <shachaf> Saizan: Eh, not much, I suppose.
06:29:29 <shachaf> > "$$$$$" -- make $$$$$ faster!
06:29:30 <lambdabot>   "$$$$$"
06:29:35 <merijn> luite: Your program received a signal while blocked on an interruptible system call
06:29:58 <mauke> I was thinking about saying "signals" but that didn't seem very helpful
06:30:02 <merijn> luite: i.e. reading from a fd with no data present and then getting a signal
06:30:15 <merijn> luite: and similar stuff
06:30:39 <typoclass> adimit: right, thanks. if the minimization doesn't work, i think the ghc folks would rather know about the panic anyways. they'd rather be told involving a slightly long code sample, than not be told
06:30:48 <luite> merijn: hmm, why does that happen? (i'm just saving files with emacs on an sshfs mounted fs)
06:30:55 <typoclass> luite: i'm assuming it has to do with EAGAIN or EINTR, but no clue what triggers that for sshfs
06:31:18 <typoclass> luite: reimplement sshfs in haskell. i hear it has good threading support ;-P
06:31:26 <luite> hehe
06:31:49 <luite> i just got ghc-mod working remotely with vado :)
06:31:58 <luite> in emacs
06:32:24 <chrisdone> ghc-mod ghcshmeeshmod
06:32:35 <merijn> luite: It happens because someone forgot to check return values of their system call
06:32:42 <luite> i should try interactive-haskell next
06:32:43 <merijn> luite: i.e. programmer incompetence
06:33:22 <adimit> typoclass: silghtly long in this case means the entire yesod scaffold :-P. Let's see.
06:33:32 <mauke> luite: you could strace emacs maybe
06:34:03 <chrisdone> hamishmack: any ETA on getting your webkit merged in mainline webkit?
06:34:54 <hamishmack> I'll try to spend some time on it this comming weekend
06:34:55 * hackagebot air-spec 2013.7.1 - air spec helper  http://hackage.haskell.org/package/air-spec-2013.7.1 (JinjingWang)
06:36:05 <chrisdone> hamishmack: ah, ok
06:37:28 <hamishmack> I need to test it against the current hackage gtk
06:38:41 <hamishmack> unless dmwit has time to get that updated
06:41:08 <chrisdone> man patch-tag is slow as ass
06:42:51 <merijn> elliott: It seems the latest version had dynamic event switching added, but I'm not sure whether continuous time is in there
06:44:34 <luite> edwardk: what would you recommend for hash consing text symbol names? is `intern' usable, or is there something better?
06:44:49 <edwardk> intern has the problem that it leaks the forever
06:45:22 <elliott> a time leak, eh?
06:46:30 <edwardk> =P
06:46:55 <luite> ah, hmm, it might still be acceptable
06:47:47 <luite> but i doubt i'd be able to convince sclv to switch jmacro to use those then... perhaps it could be parameterizable
06:48:02 <sclv> sure
06:48:40 <luite> sclv: parameter for the type of identifiers?
06:48:45 <sclv> also if you have any other transforms you'd like to see in particular that you think might be reusable i'd be happy to take a whack at integrating them into jmacro directly
06:49:12 <sclv> luite: if you don't mind the extra tag, I recall i have idents as a boring adt?
06:49:24 <sclv> so we could just add an interned constructor
06:49:32 <luite> data Ident = StrI String
06:49:53 <sclv> right -- thats an artifact of my imagining we might want something fancier from the start
06:49:56 <luite> it would be a bit annoying to have multiple identifier types in one AST
06:50:38 <sclv> eh, i suppose a parameter would be ok. probably need to use a type alias and juggle a bit to keep backwards compat
06:50:58 <luite> i guess it could work though, but comparing would be a tad ugly
06:51:09 <sclv> well it only needs to be written once :-P
06:51:18 <luite> that's true
06:52:14 <luite> i'll just do a few more performance tests first :) i wanted to do an extra pass doing variable renaming, after linking, but that takes way too long atm
06:52:21 <luite> ~10 seconds for a 4MB file
06:52:27 <luite> just parsing/printing
06:52:44 <sclv> the cost is the parsing/printing or the traversal?
06:52:56 <bscarlet> suppose I have a homomorphism :: a -> b with inverse :: b -> a. Is there any way/package/trick/toolkit by which I can convert functions in terms of a into functions in terms of b?
06:53:08 <luite> sclv: i'm not doing any renaming yet, just parse then print
06:53:43 <sclv> yeah you can stub out idents with something dull to see the difference in timing
06:53:50 <sclv> i'm sure there's way worse efficiencies than them :-)
06:54:55 <luite> i can hopefully skip the extra parsing step if i let ghcjs generate binary intermediate files
06:55:26 <sclv> in any case, if you have a test case you want to send me that yr unhappy with, i could also try to take a wack at a performance pass over the code
06:55:58 <luite> sclv: tnx
06:56:12 <sclv> np -- always nice to support a library in real world use
06:57:11 <byorgey> bscarlet: the usual answer to that sort of question would be the 'lens' package --- however, the lens package actually makes it a bit annoying to lift isomorphisms through other functions (for some technical reasons)
06:58:12 <elliott> it's ok with lifting isomorphisms
06:58:15 <elliott> as long as you only take one parameter.
06:58:26 <elliott> which is quite common.
06:58:42 <byorgey> elliott: what do you mean by "only take one parameter"?
07:00:13 <elliott> byorgey: as in going from (repr -> ...) to (newtype -> ...) or such.
07:00:53 <elliott> including (repr -> repr) to (newtype -> newtype) -- that's just "oveR"
07:00:53 <elliott> *over
07:01:39 <byorgey> elliott: ah, I was thinking more generally about lifting isomorphisms into e.g. an arbitrary setter --- such a lifting function has to take the isomorphism argument twice (with different types).
07:02:16 <bscarlet> byorgey, elliott: thank you
07:02:20 <byorgey> in any case there's no general way to convert e.g.  (repr -> [repr] -> (repr -> a) -> a)  to  (newtype -> [newtype] -> (newtype -> a) -> a)
07:02:26 <shachaf> byorgey: I'm not sure I understand what you mean, but maybe cloneIso is relevant.
07:03:27 <elliott> byorgey: if only we had HoTT.
07:04:13 <byorgey> elliott: I was going to say that, but decided that would be a completely useless answer to bscarlet's question (as opposed to just mostly useless, like my actual answer =)
07:04:47 <shachaf> I do wish there was a sensible way to pass polymorphic isomorphisms that are used at multiple types.
07:04:57 <elliott> byorgey: I'm proud to be completely useless!
07:06:09 <byorgey> shachaf: try to implement  liftIso :: Setter s t a b -> AnIso' a b -> Iso' s t   and you will see what I mean.
07:06:33 <byorgey> shachaf: yes, I wish that too.
07:06:51 <byorgey> really what we need are types parameterized by type functions.
07:06:53 <shachaf> byorgey: But what you gave isn't an example of what I mean, exactly.
07:07:10 <shachaf> I mean e.g. (forall a. Traversal' (t a) a)
07:07:26 <byorgey> ah.  yes, that would be nice.
07:07:56 <edwardk> speaking of lenses. there may be a nice way out of the current record debate offered by some existing lens machinery
07:08:35 <shachaf> byorgey: Wait, I'm not sure I understand that liftIso type...
07:09:05 <edwardk> if we extend class Get (s :: *) (x :: Symbol) (a :: *) where getFld :: p x -> s -> a     by adding class Set (s :: *) (x :: Symbol) (a :: *) where type Modified s x a :: * setFld :: p x -> s -> a -> Modified s x a
07:09:19 <elliott> wow, edwardk. gross.
07:09:26 <edwardk> where we use the former for the field accessor and the latter for the record update syntax then we can
07:09:55 * hackagebot esqueleto 1.2.3 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.2.3 (FelipeLessa)
07:10:08 <shachaf> byorgey: Oh, hmm.
07:10:29 <byorgey> shachaf: well, it can't be implemented.  But the idea is that if a structure contains a subfield of type a, and you have an isomorphism from a to b, that induces an isomorphism on the entire structure
07:10:44 <edwardk> make an instance (Functor f, fb ~ f b, Get s x a, Set s x b, s2fb ~ (s -> f t)) => Get (a -> fb) x s2ft
07:10:47 <merijn> ugh, why does "cabal haddock" not work without installing all dependencies :(
07:10:57 <edwardk> which means that every field accessor would be legally usable directly a a lens for that field
07:11:09 <byorgey> merijn: because it wants to create links to stuff from dependencies in the output?
07:11:14 <edwardk> its hideous, but it would make every field accessor a valid lens and still allow its current use
07:11:19 <elliott> edwardk......................
07:11:26 <elliott> can't we just make the classes contain Lenses instead??
07:11:42 <merijn> byorgey: I don't care, I just want to browse the haddocks :(
07:11:59 <edwardk> unlikely because it'd change the behavior o the existing accessor machinery beyond recognition. this has the benefit that the prefix use of a field accessor would still work
07:12:13 <byorgey> merijn: try the --idontcare flag
07:12:40 <merijn> byorgey: Right now I can't browse the reactive-banana-wx haddocks, since they don't build on hackage and don't build locally (I'm missing wx)
07:12:56 <edwardk> moreover we can modify the desugaring of setting with the r { x = t } syntax to go through Set, but we could go a little bit farther, and get the 'exposed' machinery we're working on for lens to work with this, so that the desugaring can do simultaneous field assignments to multiple fields
07:13:16 <typoclass> merijn: it also has to do with the (admittedly remote) case that one of your source preprocessors needs to first be installed from hackage. so at least in this case it needs to run cabal configure first
07:13:36 <byorgey> merijn: you should prevail upon apfelmus to use http://hackage.haskell.org/package/standalone-haddock-1.0 and upload the result somewhere
07:13:50 <edwardk> this would work because you can just make the Exposed data type family use the same field accessor names as the unexposed variant
07:13:52 <byorgey> er, but without the -1.0
07:14:03 <typoclass> merijn: but you're right, it'd be better if the docs on hackage were more reliably available
07:14:04 <merijn> typoclass: Yes, but that basically means the source of any haskell package without installing all it's dependencies if it uses something C based
07:14:07 <dcoutts> merijn: it's because haddocking is essentially the same as compiling
07:14:24 <edwardk> and then round tripping through the exposed type would allow you to do type varying assignment to things like data Foo a = Foo { x, y :: a }   with r { x = 12, y = 13 }
07:14:45 <dcoutts> merijn: haddock is based on the ghc front-end, and so runs it through the renamer + typechecker, so all deps have to be installed already just for that
07:14:45 <edwardk> by round tripping through a type data ExposedFoo a b = ExposedFoo { x :: a, y :: b } and doing the steps individually there before coming back
07:14:54 <merijn> dcoutts: :(
07:15:23 <shachaf> byorgey: Oh, I see.
07:15:26 <merijn> Now I need to go yak shave and figure out how the hell to install wx on OSX, just so I can browse some documentation :\
07:15:29 <edwardk> and with that we have almost all of the utility of the existing record syntax. The only thing that breaks is a higher rank field type, where that requires ImpredicativeTypes, and existential field accessors, which mostly don't work now
07:16:00 <edwardk> (right now i think you can still use them in the r { x = … } syntax, just not the prefix form
07:16:23 <elliott> you can yeah
07:16:28 <elliott> also in pattern matching I guess
07:16:50 <edwardk> yep
07:17:44 <edwardk> i find the instance above terrible, but i find it interesting that with such a modest extension to the existing record proposal we get lenses for every field accessor for free
07:17:54 <shachaf> byorgey: That doesn't really sound right, though.
07:18:03 <byorgey> shachaf: what doesn't?
07:18:09 <shachaf> Well, maybe in HoTT-land or something.
07:18:20 <edwardk> a large part of the hideousness above is me making sure to enforce inference as well as i can
07:18:59 <edwardk> tat is also missing a bunch of fundeps (like the existing proposal) that will probably be needed to make it all work in practice. i'm leaving those off in the spirit of the current discussion.
07:19:13 <edwardk> I think if anything will kill this record proposal it'll be that it likely doesn't work all that well for inference.
07:19:33 <elliott> I should get around to writing that toy lens/record language.
07:19:36 <edwardk> but i doubt i can get anyone to listen to me about that until it actually happens
07:19:43 <elliott> so I can just tell everyone to make things like that.
07:22:01 <edwardk> in particular i don't see how they are supposed to chain polymorphically
07:22:24 <edwardk> foo.bar   -- the current types do _not_ constrain the intermediate type unless particular instances are involved.
07:25:57 <typoclass> edwardk: interesting. could you give an example where particular instances are involved?
07:26:17 <typoclass> (i.e. triggering the constraining of the intermediate type)
07:28:35 <edwardk> typoclass: easy. let just pretend we have two classes:
07:28:39 <edwardk> class Foo a b where foo :: a -> b
07:28:43 <edwardk> class Bar a b :: b -> c
07:28:55 <edwardk> now write fooBar = foo.bar -- what is the type offooBar?
07:29:06 <edwardk> fooBar :: (Bar a b, Foo b c) => a -> c
07:29:19 <edwardk> but there is no b in the right hand side of that signature
07:29:26 <edwardk> so you can't do it
07:29:48 <typoclass> edwardk: right, i'm assuming we get that compiler error "occurs more often in the context than in the signature"
07:29:50 <edwardk> in other words compositions of field accessors are a casualty of the current proposal.
07:29:56 <mietek> Opinions on FP Haskell Center?
07:30:03 <edwardk>  Could not deduce (Foo b0 c) arising from a use of `foo'
07:30:04 <edwardk>     from the context (Bar a b, Foo b c)
07:30:54 <edwardk> i should note this rather serious issue on the record debate thread
07:30:59 <edwardk> its been lingering in the back of my brain for a while and i've seen no serious attempt to address it
07:32:02 <elliott> I forget if my toy language had a nice solution to that.
07:34:31 <typoclass> edwardk: alright, thanks for the explanation
07:34:58 <honza> http://learnxinyminutes.com/docs/haskell/ http://i.imgur.com/GUDWYBC.jpg
07:36:38 <tomboy64> how do i "take" from a ordered list up to a specific value?
07:36:47 <merijn> tomboy64: takeWhile?
07:36:56 <tomboy64> hah
07:36:58 <tomboy64> thanks
07:39:56 * hackagebot TCache 0.10.0.9 - A Transactional cache with user-defined persistence  http://hackage.haskell.org/package/TCache-0.10.0.9 (AlbertoCorona)
07:44:41 <Valodim> 	if [ -p "$FILE" ]; then
07:44:41 <Valodim> 		( echo 'dcall' > "$FILE" &
07:44:41 <Valodim> 		 sleep 5 ; kill $! 2>/dev/null ) &
07:44:43 <Valodim> 	fi
07:44:46 <Valodim> damn. sorry, mispaste
07:50:32 <Sculptor> yo
08:03:05 <arnsholt> I've implemented an algorithm in Haskell and I'm contemplating releasing it on Hackage. Are there any namespacing guidelines, or other conventions I should be aware of?
08:04:19 <startling> arnsholt, take a look at the versioning policy if you haven't
08:04:56 * hackagebot llvm-general 3.2.0.8 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.2.0.8 (BenjaminScarlet)
08:05:42 <byorgey> @where pvp
08:05:42 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
08:05:58 <startling> byorgey: thanks, I always forget the short name.
08:05:58 * arnsholt goes to read that
08:06:59 <byorgey> arnsholt: there are no formal conventions though there are some social ones.  But those you can pick up just by picking a few packages on Hackage which you admire and seeing how they do things
08:07:06 <startling> arnsholt: other than that, a lot of people use Data.Whatever/Control.Whatever/System.Whatever but that's not very standardized.
08:07:18 <startling> and kind of silly imo
08:07:19 <arnsholt> Right, so sort of like CPAN
08:07:28 <byorgey> yep
08:07:53 <arnsholt> Is creating a package below an existing package frowned upon?
08:08:03 <mauke> packages aren't stacked
08:08:32 <typoclass> arnsholt: you mean modules? e.g. creating Data.Maybe.Foo where Data.Maybe already exists
08:08:37 <arnsholt> One option I'm contemplating is Data.Tree.EditDistance, since the algorithm is edit distance for trees (using Data.Tree for the trees)
08:08:43 <typoclass> arnsholt: to answer my own question, that seems ok :-)
08:08:45 <arnsholt> Yeah
08:08:54 <byorgey> arnsholt: if you mean there is an existing package which exports a module Foo.Bar, and your package exports  Foo.Bar.Baz: (1) no, it is not frowned upon, and (2) in fact the packages have nothing to do with each other
08:09:12 <arnsholt> Aye, "package below a package" was a terrible choice of words
08:09:32 <startling> you might want to avoid shadowing an existing module name if there's any chance anyone would like to use both packages at once
08:10:00 <arnsholt> It uses Data.Tree to represent the trees, so it won't shadow that, no
08:10:21 <byorgey> arnsholt: if it actually works over the data type defined in Data.Tree, then Data.Tree.EditDistance is a fine name
08:10:22 <arnsholt> But that's more or less just how CPAN does things. That suits me very well =)
08:10:47 <arnsholt> Yeah, I found Text.EditDistance and extrapolated from that =)
08:14:29 <deggis> what's the current advice for (cross-)compiling software for ARM (sheevaplug, raspberry-pi) faster? i set up qemu/debian which eventually does the trick, but is there alternatives to having a VM env?
08:14:57 * hackagebot llvm-general 3.3.0.6 - General purpose LLVM bindings  http://hackage.haskell.org/package/llvm-general-3.3.0.6 (BenjaminScarlet)
08:16:07 <startling> deggis, http://hackage.haskell.org/trac/ghc/wiki/CrossCompilation
08:16:31 <startling> (cross-compilation doesn't really work, afaict)
08:17:01 <startling> oh, wait, at the bottom: "Cross-compiling is working smoothly in at least one setup (Linux/x86_64 to Linux/armv6 unregisterised (Raspberry Pi))"
08:17:55 <deggis> oh, missed that. nice, it seems worth trying
08:18:51 <startling> looks like you're still limited to packages that don't use TH, though
08:22:36 <deggis> at least no mention there of getting TH to work. i'm planning to compile snap apps to arm, i guess no doing that without TH
08:24:57 * hackagebot buildwrapper 0.7.3 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.7.3 (JeanPhilippeMoresmau)
08:31:08 <startling> deggis: yeah. it's kind of bizarre.
08:31:45 <deggis> me building snap apps to arm, TH unsupported issue or both? :-)
08:33:17 <deggis> i guess this qemu env does the trick without even having to add gazillion libs to target machines. building stuff on it is not the fastest thing i've ever done, though
08:33:31 <Banistergalaxy> Deggis you prefer snap to yeseod?
08:33:40 <deggis> snap at the moment
08:34:33 <deggis> Banistergalaxy: oh, misread that. yes :)
08:39:33 <tomboy64> i have a numbers source from Integers and i want to create a list of Ints, since none of them will exceed 10^8
08:39:42 <mauke> fromIntegral
08:40:06 <typoclass> tomboy64: fromIntegral is the universal converter function
08:40:09 <tomboy64> i tried myPrimes = fromIntegral(takeWhile (<=10000000) primes)
08:40:26 <mauke> fail
08:40:32 <mauke> takeWhile doesn't return a number
08:40:33 <tomboy64> ^^
08:40:41 <mauke> fromIntegral takes a number
08:40:58 <tomboy64> so i have to do a list-comprehension
08:41:06 <bscarlet> or map
08:41:53 <tomboy64> hah
08:41:56 <tomboy64> that worked :)
08:43:45 <edvardkk> Anyone, what are some good texts on haskell program design / larger coding decisions? I am interested in questions such as: "when should I introduce a type class?", "how should I proceed when designing/discovering a monad", etc...
08:44:08 <edvardkk> .."how to structure haskell programs".
08:44:34 <bhuemer> I would be interested in such texts as well :D
08:48:45 <typoclass> edvardkk: one random rule of thumb: don't overestimate typeclasses; you don't need them as often as you think, in my opinion. beginners, because of their background in java or whatever reason, sometimes say "first of all, i'll write a lot of typeclasses for everything" and forget that you can go a very long way with plain functions
08:51:47 <edvardkk> typoclass: yes. that is one thing, on the contrary, I feel I seldomly see that type classes are 100% necessary :p
08:54:29 <edvardkk> but, I want to understand where introducting one will improve the code significantly
08:54:38 <b2coutts> typoclass: I see people saying this a lot here, do you mean that you shouldn't overzealously create your own typeclasses, or define instances of standard typeclasses?
08:54:52 <edvardkk> there first sense, I guess ?
08:55:20 <typoclass> b2coutts: the former. creating your own typeclass for everything and the dog. (oh, other people say that as well ...?)
08:55:37 <b2coutts> ok yeah, that make sense to me
08:55:49 <b2coutts> makes
08:56:25 <b2coutts> I'd thought before it was the latter sense, and it seemed like good practice to me to define, for example, an instance of Ord for your datatype if it makes sense
09:00:32 <edvardkk> typoclass: thanks for the advice! seems sound. to follow up, then: when *should/could* the beginner write a type class?
09:01:20 <mcstar> 'there first sense' ? where? what does that mean?
09:02:37 <edvardkk> I brain farted. meant to say "the first sense" (referring to b2coutts question)
09:04:02 <mcstar> ok, np... for a minute i thought you said 'there' instead of 'their', which makes me furious :)
09:05:39 <typoclass> edvardkk: when it makes sense to overload a function. 'makes sense' is partially a subjective thing. in my opinion, if you wrote (or would write) two functions which have identical code except for one function name. you can then simplify this to just one function that calls one function, overloaded with two instances
09:05:59 <edvardkk> mcstar: my grammar isn't *that* bad ;)
09:06:03 <typoclass> edvardkk: ... only that it'll complicate the type signature. so there's a trade-off there
09:06:56 <typoclass> edvardkk: i think it's hard to explain in the abstract (cf. "how can you play the violin well"). but if you put code on hpaste, or sketches of code, folks will tell you where you could simplify :-)
09:07:22 <edvardkk> typoclass: hmm. thanks! so, at least, there should be some clear sense of "*possible* need for overloading"
09:08:02 <edvardkk> typoclass: yes! good strategy :)
09:08:19 <chrisdone> @where hpaste
09:08:19 <lambdabot> http://paste.tryhaskell.org/new/haskell
09:08:34 <typoclass> chrisdone: forgot the url, eh?
09:08:37 <typoclass> :-P
09:09:32 <chrisdone> typoclass: just incase edvardkk did ;)
09:10:08 <edvardkk> thanks. I forget, but luckily google remembers (and lambdabot as well ;)
09:10:54 <typoclass> edvardkk: note that google still finds the old hpaste.org, which is now being replaced
09:11:30 <edvardkk> ah, kk. didn't know
09:12:05 <typoclass> chrisdone: ok i retract my kidding. it made perfect sense that you did @where hpaste. apologies
09:12:56 <chrisdone> typoclass: au contraire, i liked your joke =p
09:15:14 * typoclass retracts the retraction, in that case, protracting the original ... erm ... i give up. irc is an irreversible medium anyway
09:20:40 <merijn> What happened to the old hpaste anyway?
09:20:57 <Clint> apparently bos is awol
09:21:00 <merijn> (i.e. why is the domain no longer functional?)
09:22:23 <typoclass> Clint: hm, how do you mean awol?
09:22:41 <typoclass> merijn: something about switching the server, and not controlling the domain name
09:23:00 <Clint> typoclass: i was paraphrasing "domain contact unreachable" i think
09:39:58 * hackagebot hpaste 0.0.0 - Haskell paste web site.  http://hackage.haskell.org/package/hpaste-0.0.0 (ChrisDone)
09:41:31 <startling> uh
09:41:58 <elliott> chrisdone: suggest giving that a version number >0.3
09:42:03 <elliott> since right now it is showing as an old version
09:42:33 <chrisdone> elliott: yeah i noticed
09:44:58 * hackagebot risc386 0.0.20130701 - Reduced instruction set i386 simulator  http://hackage.haskell.org/package/risc386-0.0.20130701 (AndreasAbel)
09:45:00 * hackagebot snap-app 0.3.2 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.3.2 (ChrisDone)
09:47:22 <josephle> anyone know eta for when comonad.com will be back up?
09:49:59 * hackagebot hpaste 1.0.0 - Haskell paste web site.  http://hackage.haskell.org/package/hpaste-1.0.0 (ChrisDone)
09:50:41 <chrisdone> i would be interested to see if anyone is able to cabal install that in a hsenv/cabal-dev environment
09:50:42 <typoclass> 10 minutes to go from 0.0 to 1.0
09:50:50 <chrisdone> typoclass: i work fast =p
09:50:55 <elliott> chrisdone: I might give it a go in a Cabal HEAD sandbox
09:51:03 <chrisdone> elliott: cool =)
09:51:27 <elliott> though not right now, I don't need the room warmed by my computer fans :)
09:51:32 <elliott> uh. well the fans wouldn't do the warming
09:51:54 <chrisdone> elliott: weren't into physics in school were ya? =p
09:52:44 <chrisdone> apart from one random guy using it in his startup, i think i'm the only guy to build and run this for three years. i'd like to make it easier to build and get running, to encourage people submitting patches/changes they might want. seems strange for only one guy to be working on it when everyone uses it
09:53:09 <arkeet> elliott: no, but they'll help it reach equilibrium faster.
09:53:11 <byorgey> the fans DO actually do some warming, at least the fan motors do =)
09:53:30 <m_hyperbolic> is hpast.org down for everybody? Anybody know why?
09:53:36 <arkeet> well, I suppose they might shift the equilibrium point a bit.
09:53:37 <m_hyperbolic> hpaste.org*
09:53:38 <geekosaur> see topic
09:53:42 <byorgey> @where hpaste
09:53:42 <lambdabot> http://paste.tryhaskell.org/new/haskell
09:53:54 <chrisdone> m_hyperbolic: it's being migrated
09:54:06 <arkeet> how come?
09:54:41 <tomboy64> chrisdone: build what?
09:54:43 <chrisdone> byorgey: my fans chase me down the street. i feel pretty warm after that. they're nice people but i don't like the knives they carry
09:54:55 <chrisdone> tomboy64: http://hackage.haskell.org/package/hpaste
09:55:17 <tomboy64> hm
09:55:26 <byorgey> arkeet: you know, servers migrate in the summer to their ancestral breeding grounds
09:55:31 <byorgey> chrisdone: haha
09:55:34 <luite> hehe
09:55:48 <tomboy64> mhm breeding pastebins
09:55:51 <chrisdone> byorgey: yeah, we all bowed before 0.3 this morning =p
09:55:52 <tomboy64> pastebin porn
09:55:55 <tomboy64> <3
09:55:56 <typoclass> @remember byorgey you know, servers migrate in the summer to their ancestral breeding grounds
09:55:56 <lambdabot> Good to know.
09:56:13 <arkeet> byorgey: I thought african servers were non-migratory.
09:56:38 <luite> byorgey: hmm, i wonder if large companies with multiple data centers shift away computation from the ones in the hottest weather to save cooling costs
09:56:49 * chrisdone tries very hard to remember the rest of the Monty Python dialogue to make a witty addendum
09:57:05 <byorgey> arkeet: well, african servers, maybe, but european servers are, that's my point
09:57:12 <chrisdone> luite: that's an interesting point =)
09:57:19 <benmachine> chrisdone: my cabal-install is failing to recognise the existence of 1.0.0
09:57:26 <chrisdone> luite: i wonder if babies born in summer are happier or sadder
09:57:30 <chrisdone> benmachine: cabal update?
09:57:39 <m_hyperbolic> I have a weird problem. I have a function that find primes (up to 2m at this point). I takes about 30 secs to run. I then want to sum them. I just use sum, but when I run the program just keeps running, and does not terminate. I let it run for a couple of minuts, but nothing happens. When I try to sum larges list in ghci is seem to be pretty snappy. What am I doing wrong? Code here
09:57:41 <m_hyperbolic> http://paste.tryhaskell.org/90633
09:57:42 <benmachine> chrisdone: did twice
09:58:02 <benmachine> hmm
09:58:05 * benmachine fiddles
09:58:05 <chrisdone> benmachine: three time's a charm?
09:58:09 <benmachine> chrisdone: :P
09:59:20 <byorgey> m_hyperbolic: well, for one thing, repeatedly appending ++ [n] to the end of the list is a bad idea, since that takes time proportional to the length of the list
09:59:28 <luite> chrisdone: at least data centers have gotten a whole lot more efficient in recent years, with more outside air and water (from canals/river) cooling
09:59:45 <benmachine> chrisdone: oh, it's because I'm using a mirror
09:59:51 * benmachine faffs
09:59:55 <chrisdone> luite: data centres are using canals/rivers?
10:00:12 <Clint> or arctic air
10:00:13 <chrisdone> luite: haven't they heard of Vanilla Ice?
10:00:21 <byorgey> m_hyperbolic: instead, don't use an accumulating parameter at all, just have dynPrime directly return the list, and you can say  n : dynPrime (n+1) m
10:00:36 <luite> chrisdone: google even has one that uses sea water
10:00:37 <byorgey> you'll have to change the base case too
10:00:46 <chrisdone> luite: that's pretty cool
10:01:29 <m_hyperbolic> byorgey: But even though my prime finder is slow, shouldn't summing over the resulting list be fast? I.e not make the problem run 10x slower
10:01:57 <byorgey> m_hyperbolic: when you say it takes 30 seconds to run, you mean to print out the list of primes?
10:02:04 <benmachine> chrisdone: "The following packages are likely to be broken by the reinstalls: haskell98-2.0.0.2 ghc07.6.2 Cabal-1.16.0 bin-package-db-0.0.0.0 hpc-0.6.0.0"
10:02:05 <chrisdone> i only learned recently that the interwebs between the us and europe goes over a super long cable across the atlantic. like, seriously? that's like some asimov tale
10:02:18 <benmachine> chrisdone: this is me in a cabal-HEAD sandbox
10:02:27 <typoclass> chrisdone: how else would they do it?
10:02:30 <chrisdone> benmachine: hmm. that's rather strange
10:02:33 <chrisdone> typoclass: satellites?
10:02:42 <luite> satellite = long ping time
10:02:52 <chrisdone> luite: dude SUPER SATELLITES
10:02:54 <luite> unless you have low orbit, then you need a lot of sats, and replace them often
10:02:56 * chrisdone runs away crying
10:03:07 <typoclass> chrisdone: yeah but then you have latency. takes time for the signal to reach the satellite. you would have to speed up the speed of light
10:03:11 <benmachine> chrisdone: it wants to install a billion things, but I think the key one is it wants bytestring to go down to 0.9.2.1
10:03:25 <chrisdone> benmachine: hold up. i only have a few hard versions
10:03:26 <typoclass> benmachine: -v3?
10:03:42 <benmachine> typoclass: yeah, already on it
10:04:12 <chrisdone> benmachine: it might be the blaze-html version: blaze-html                == 0.4.3.4
10:04:16 <byorgey> m_hyperbolic: the problem may be that sum is too lazy.  Try compiling with -O2, and/or replace the call to sum with a call to (foldl' (+) 0)  (you'll need to import Data.List for foldl')
10:04:25 <benmachine> chrisdone: yes, looks like it
10:04:28 <byorgey> oh, that's a rather old version of blaze-html
10:04:52 <benmachine> chrisdone: blaze-html wants an older bytestring
10:04:54 <chrisdone> byorgey: yeah, well, all jaspervdj's packages are old the minute you download them
10:04:55 <m_hyperbolic> byorgey: Ah ok. I'll try setting that up.. And fixing up dynPrime too. Thanks for the input
10:04:58 <benmachine> but my unix package wants a newer one
10:05:09 <chrisdone> benmachine: i'll see if i can update it without changing all my code
10:05:41 <byorgey> chrisdone: well, yes, but blaze-html-0.4.3.4 is from April 2012
10:05:47 <benmachine> chrisdone: I'm happy to go grab your github and fight it into submission if you like :P
10:05:51 <luite> chrisdone: those long cables have interesting amplifiers that amplify the optical signal directly, without converting it to an electrical signal
10:06:03 <byorgey> which I guess is not that long ago in an absolute sense but it is quite a while at the speed the Haskell ecosystem is moving these days
10:06:47 <chrisdone> byorgey: sure, i think at the time i'd already done n upgrades with annoying api changes and renames, having to change all my code, for seemingly no reason. at some point i said enough is enough and stopped bothering
10:06:58 <byorgey> fair enough.
10:07:02 <chrisdone> byorgey: seriously that guy changes his apis like hot cakes
10:07:13 <luite> hehe
10:07:33 <typoclass> chrisdone: but man, it's like, we can't do it any other way, because stagnation!
10:07:41 <typoclass> ;-)
10:07:45 <chrisdone> typoclass: other languages call it stability =p
10:07:54 <Clint> api stability is for C programmers
10:07:56 <benmachine> I really wish people kept better changelogs
10:08:30 <taylorgb> It's surprising how many ways one can phrase "did some stuff"
10:08:43 <luite> benmachine: perhaps better tools can mostly replace them
10:08:47 <merijn> Is Heinrich Apfelmus in here occasionally? If so, by which nick does he go?
10:08:55 <tomboy64> :-/
10:09:05 <elliott> preflex: seen apfelmus
10:09:05 <preflex>  apfelmus was last seen on #haskell 363 days, 22 hours, 18 minutes and 19 seconds ago, saying: ping edwardk
10:09:08 <benmachine> luite: mostly. but until they do, it wouldn't hurt if people would write a little bit :P
10:09:08 <luite> there's sometimes someone here with the nickname `apfel', connecting from a german ip
10:09:24 <luite> dunno if that's him
10:09:26 <chrisdone> byorgey: i take your point, though, of course. (that's the only hard version in the cabal file, the rest are up to date)
10:09:30 <typoclass> chrisdone: right sure. i don't agree with that crowd either. "the moment we pay any attention to compatibility, it's all become terrible"
10:09:33 <elliott> preflex: seen apfel
10:09:33 <preflex>  apfel was last seen on ##java 2 years, 46 days, 5 hours, 26 minutes and 55 seconds ago, saying: dreamreal: but maybe that's the way to go though
10:09:39 <typoclass> taylorgb: very good :-)
10:09:41 <elliott> luite: sounds unlikely
10:09:42 <luite> oh huh
10:10:01 <luite> i wonder if it was spelled differently, because i meant, like, last week
10:10:03 <tomboy64> sorry for asking such a bunch of completely newb questions, but now i've got trouble with Maybe. http://bpaste.net/show/111205/
10:10:09 <tomboy64> what am i doing wrong here?
10:10:54 <chrisdone> benmachine: trying it out now
10:10:59 <benmachine> chrisdone: looks like relaxing the constraint doesn't work because snap-app has it too
10:11:18 <chrisdone> benmachine: no worries, that's my package too
10:11:23 <benmachine> :)
10:11:28 <typoclass> @remember taylorgb <benmachine> I really wish people kept better changelogs <taylorgb> It's surprising how many ways one can phrase "did some stuff"
10:11:28 <lambdabot> Good to know.
10:11:29 * chrisdone puts on RATM
10:11:32 * benmachine tries to work out how to add it to the sandbox
10:11:35 <byorgey> tomboy64: please paste the error message too.  Otherwise it's very difficult to help.
10:11:38 <luite> "2012-12-12 09:18:41 +0100 <apfel>hi there, i have to use foldr to find the highest value in an Interger List, how can i do that?" <- hmm, probably not apfelmus
10:11:45 <byorgey> haha
10:12:00 <benmachine> isn't apfel just german for apple, anyway?
10:12:04 <tomboy64> byorgey: http://bpaste.net/show/111207/
10:12:17 <luite> yes, and apfelmus german for apple sauce
10:12:19 <typoclass> luite: an Interger List is an amazing completely new thing he's coming up with
10:12:21 <CaptainK> How can I get this function to read in only 5 character words? http://ideone.com/4KX4h4
10:12:33 * chrisdone looks at the paste links
10:12:37 <chrisdone> ლ(ಠ益ಠლ)
10:12:40 <tomboy64> CaptainK: take 5?
10:12:46 <prophile> tomboy64: any is a good function to use where you're using or (map foo bar)
10:12:56 <merijn> CaptainK: some combination of filter and length
10:13:08 <tomboy64> oh
10:13:08 <byorgey> tomboy64: have you spent some time trying to carefully understand the error messages?
10:13:15 <merijn> :t filter
10:13:15 <lambdabot> (a -> Bool) -> [a] -> [a]
10:13:21 <CaptainK> Don't want to read the whole file into memory, want to read it line by line and discarde lines not 5 in length
10:13:28 <byorgey> tomboy64: for example, the first one is saying that 'lookup' returns a 'Maybe something' but you are treating it like a list
10:13:52 <merijn> CaptainK: If your files are big enough to worry about things being in memory, you should use Text rather than String anyway
10:13:58 <tomboy64> byorgey: i know that allReplacements is a list, containing (Int, [Int])
10:14:00 <chrisdone> hum
10:14:01 <benmachine> chrisdone: I've got a sensible install plan, however cabal sandbox-install --dry-run | wc -l → 72
10:14:10 <chrisdone> does hsenv and cabal update work properly?
10:14:20 <benmachine> chrisdone: so I won't be able to get it done before dinner
10:14:23 <tomboy64> byorgey: and test-runs with lookup give me a Just [Int] ...
10:14:23 <typoclass> benmachine: it's a regular change that ff or pf in certain places morph into pp
10:14:23 <benmachine> maybe another evening
10:14:30 <luite> i thought cabal update itself was never sandboxed
10:14:31 <byorgey> tomboy64: right
10:14:31 <CaptainK> string for now,
10:14:39 <chrisdone> i'm doing a cabal update but apparently blaze-html >= 0.6.1.0 doesn't exist
10:14:57 <chrisdone> benmachine: mmk
10:15:01 <prophile> isn't cabal update never meant to be used?
10:15:09 <tomboy64> byorgey: so i suppose b0 is equalling [Int] - that's why i treat it like a list.
10:15:15 <dcoutts> prophile: you're thinking of cabal upgrade
10:15:17 <byorgey> tomboy64: so what do you expect (map f (lookup blah allReplacements)) to do?
10:15:18 <typoclass> prophile: no, cabal update is fine. (cabal upgrade is likely to break stuff)
10:15:22 <prophile> ah
10:15:27 <elliott> cabal upgrade doesn't even exist any more, I think.
10:15:32 <dcoutts> no, indeed
10:15:36 <byorgey> tomboy64: right
10:15:38 <benmachine> chrisdone: actually, some of these still look suspicious, I'll faff with it more later
10:15:41 <chrisdone> dcoutts: you have a nick highlight on cabal, right? =p
10:15:54 <tomboy64> grrr
10:16:06 <typoclass> prophile: cabal update simply downloads the index file from the hackage servers, telling you which packages exist in which versions. (later you can choose some of them to actually install)
10:16:07 <tomboy64> byorgey: i need to get the list out of the Just first?
10:16:15 <dcoutts> chrisdone: I just appear as if by magic
10:16:21 <byorgey> tomboy64: you cannot treat  Maybe [Int]  as if it is  [Int].  You need to pattern-match to see whether it is Nothing or Just.
10:16:23 <dcoutts> poof!
10:16:26 * dcoutts disappears
10:16:27 <prophile> typoclass: ah yes, I recall
10:16:36 <benmachine> looks like my cabal sandbox is not picking up stuff I already have installed
10:16:37 <luite> hmm, i wonder if i should do the marshalling for 'foreign import javascript' from scratch, atm it uses the same as 'foreign import ccall', but that has some annoyances
10:16:42 <prophile> a simple brain malfunction on my part :D
10:16:46 <benmachine> oh well
10:16:49 <benmachine> to dinner!
10:16:51 * benmachine also disappears
10:16:52 <typoclass> prophile: no worries :-)
10:17:28 <osa1> what are 'strictness' and 'unfolding' fields in output of ghc --show-iface ?
10:17:33 <luite> i'm not too keen on adding an extra module to GHC for this, since that also means that it's hard to change after GHC has been released
10:17:43 <tomboy64> byorgey: thanks. got it now :-|
10:19:10 <m_hyperbolic> Does there exist a takeWhen function? so takeWhen (< 3) [1..10] would give [4,5,6,7,8,9,10] ?
10:19:29 <luite> dropWhile ?
10:19:33 <elliott> > dropWhile (< 3) [1..10]
10:19:33 <lambdabot>   [3,4,5,6,7,8,9,10]
10:19:48 <m_hyperbolic> Ah. Thanks!
10:20:07 <typoclass> m_hyperbolic: you may want (<= 3) instead
10:20:48 <m_hyperbolic> typoclass: I do ?
10:21:31 <geekosaur> you showed starting at 4, not 3
10:21:32 <typoclass> m_hyperbolic: well, you said you wanted [4,5,...]. elliott gave you a solution that gives [3,4,5,...] :-)
10:22:18 <m_hyperbolic> typoclass: Ahh I see. Yes <= 3 :)
10:22:24 <osa1> help, where can I learn more about ghc --show-iface's output
10:22:38 <osa1> specifically I want to know about strictness and unfolding fields
10:23:25 <chrisdone> Module `Text.Blaze' does not export `Html'
10:23:28 <chrisdone> and so it begins
10:23:40 * chrisdone performs the thankless API migration ritual
10:24:12 <tomejaguar> Thank you, chrisdone.
10:24:19 <luite> :)
10:25:38 <tomejaguar> osa1: I guess it will be somewhere in here: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler
10:26:25 <typoclass> thank god we have a powerful type system. this means our migration ritual is simply importing random modules and changing calls to function names that "sound similar", until it compiles ;-)
10:27:47 <tromp_> i'd like to see you find nub by similar sounds:)
10:28:20 <typoclass> @type (nub, reverse)
10:28:21 <lambdabot> Eq a => ([a] -> [a], [a1] -> [a1])
10:28:37 <typoclass> tromp_: signatures look similar. gonna use reverse. where's the problem
10:28:44 <dmwit> And everything worth anything has an Eq instance, amirite?
10:29:06 <prophile> like functions
10:29:08 <typoclass> dmwit: my thing is actually more general now
10:29:13 <dmwit> prophile: HTML was enough for our forefathers
10:29:24 <tromp_> you said similar names, not similar types:)
10:29:49 <typoclass> (note: i am not actually recommending my version of the 'migration ritual', as indicated by the smiley)
10:29:50 <chrisdone> dmwit: that's a cute way to encourage people to strive for equality
10:29:58 <chrisdone> “Everyone deserves an Eq instance, right?”
10:30:18 <typoclass> chrisdone: except functions. those are first-class citizens
10:31:13 <byorgey> everyone deserves equality, except first-class citizens
10:31:14 <chrisdone> one arrow good, zero arrows bad
10:31:26 <dmwit> @@ typoclass: @hackage universe gives functions an Eq instance (and on Ord one, too!)
10:31:26 <lambdabot>  typoclass: http://hackage.haskell.org/package/universe gives functions an Eq instance (and on Ord one, too!)
10:31:28 <tac> I don't see why functions shouldn't have Eq if lists do.
10:31:43 <tac> > [1..] == [1..]
10:31:47 <lambdabot>   mueval-core: Time limit exceeded
10:32:01 <tac> ^ That's a civil rights issue waiting to happen
10:32:07 <dmwit> elliott: By the way, suppose I wanted to lobby for including universe in new-lambdabot. What should I do?
10:32:12 <byorgey> tac: you have to be able to enumerate the domain.
10:32:19 <startling> okay, now that I (maybe) understand conduit a little more: can I await a value, get it, feed it to some other conduit, and do something if it yields anything?
10:32:53 <elliott> dmwit: well, you have to get this form signed in triplicate...
10:33:02 <elliott> dmwit: I'm a bit wary about the Show instances etc. but the actual class seems fine
10:33:03 <arnsholt> tac: Function equivalence is an undecidable problem (halting-problem equivalent)
10:33:05 <dmwit> Perhaps I should add {-# LANGUAGE Safe #-} to all the modules and upload a new version, or...?
10:33:16 <elliott> oh it should be OK from a safety perspective
10:33:19 <elliott> as long as none of the modules do unsafe things
10:33:23 <tac> arnsholt: So is list equivalence ;)
10:33:40 <dmwit> elliott: Well, in previous lambdabot, I conspired with other package authors to get a version of lambdabot that imported all the same things and still didn't have overlapping instances.
10:33:46 <dmwit> I suppose it should be possible to do this again.
10:33:51 <byorgey> arnsholt: the Haskell Eq class actually represents types with a *semi*-decision procedure =)
10:33:55 <startling> that is, I want a "Monad m => Conduit i m o -> Conduit i m (i, Maybe o)". is it possible?
10:34:06 <elliott> dmwit: I mean, there's already a Show instance for functions
10:34:11 <elliott> > length :: [Int] -> Int
10:34:12 <dmwit> elliott: Yes, I know.
10:34:12 <lambdabot>   <[Int] -> Int>
10:34:21 <elliott> dmwit: and I'd rather it not spit out instance errors when you use it on something without your instances
10:34:36 <arnsholt> byorgey: Right. In that case it might be feasible, I guess. I'd still posit that it'd be a bad idea to have an Eq instance for functions =)
10:34:45 <elliott> (i.e., I personally prefer the instance it has currently, at least for Show)
10:34:49 <dmwit> elliott: Also: universe separates the scary instances into their own modules. So not importing a particular instance you don't like should be easy.
10:34:51 <dolio> Functions shouldn't have an Eq instance because it results in better error messages when you accidentally call (==) on functions.
10:34:59 <startling> heh
10:35:02 <elliott> dmwit: right
10:35:05 <dolio> Which is the vast majority of the time.
10:35:23 <typoclass> dolio: good point
10:35:32 <elliott> dmwit: so, how about I import Data.Universe bare, Data.Universe.Helpers as U or something, and leave the rest unimported? works for you?
10:35:53 <elliott> dmwit: btw, you can declare your Finite class in a way that requires it actually be finite
10:36:03 <elliott> though I forget the trick
10:36:07 <dmwit> elliott: probably best to import Data.Universe qualified as U, and D.U.Helpers not at all
10:36:25 <dmwit> elliott: Because apparently lens also defines a value named universe.
10:36:26 <dmwit> =/
10:36:38 <byorgey> @type universe
10:36:39 <lambdabot> Not in scope: `universe'
10:36:42 <dmwit> elliott: And then import whichever instance modules you're comfortable with.
10:36:46 <edwardk> :t Control.Lens.universe
10:36:47 <lambdabot> Control.Lens.Plated.Plated a => a -> [a]
10:36:56 <dmwit> (bare)
10:37:01 <edwardk> < universe [1,2,3]
10:37:09 <dmwit> I don't run goodfellow any more.
10:37:15 <edwardk> > universe [1,2,3]
10:37:15 <startling> hey, edwardk is back
10:37:15 <lambdabot>   Not in scope: `universe'
10:37:21 <elliott> dmwit: ah, here it is: http://hackage.haskell.org/packages/archive/countable/0.1/doc/html/Data-Searchable.html#t:Finite
10:37:25 <startling> I'm so glad, I was tired of the usurper
10:37:31 <edwardk> anyways that is the old uniplate universe combinator
10:37:35 <edwardk> i didn't pick the name
10:37:36 <dmwit> startling: tired? why?
10:37:37 <elliott> ...maybe this package overlaps significantly with yours in other ways too :)
10:37:38 <edwardk> i just inherited it
10:37:58 <dmwit> elliott: indeed it does
10:38:00 <startling> dmwit, he can't answer my lens questions
10:38:04 <edwardk> copumpkin has another one
10:38:09 <dmwit> startling: ...so?
10:38:17 <chrisdone> is textTag the same as preEscapedText? =/
10:38:49 <elliott> dmwit: I think it'd be nice to have the Finite class be "assemble" rather than "universeF"
10:38:49 <dmwit> elliott: But it doesn't separate instances very nicely.
10:38:51 <startling> dmwith, no, not them
10:38:59 <edwardk> the usuper being edvardkk?
10:39:58 <startling> indeed.
10:40:06 <elliott> dmwit: what do you mean?
10:42:22 <sclv_> assemblage
10:42:55 <dmwit> elliott: The orphan instances aren't in their own modules; the Eq instance for functions is based on unreasonable assumptions; and the API is a bit cumbersome.
10:43:08 <dmwit> (In my opinion.)
10:43:12 <elliott> dmwit: right
10:43:16 <startling> dmwit, what unreasonable assumptions?
10:43:23 <dmwit> I should really redo my roundup of the similar packages and the comparisons between them sometime.
10:43:23 <elliott> still, a guarantee about Finite instances is nice :)
10:43:27 <dmwit> startling: compactness
10:43:37 <dmwit> elliott: I'm not sure I've understood what's going on there yet.
10:43:44 <dmwit> elliott: Nor how it makes any guarantee at all.
10:44:20 <elliott> I think koninkje_away had a blog post about it, let me try and dig it up
10:44:30 <startling> dmwit, well, isn't that what Universe is for?
10:44:43 <dmwit> startling: compactness? no, not at all
10:44:56 <startling> maybe I don't understand what compactness means.
10:45:11 <dmwit> startling: google for "seemingly impossible functional programs"
10:45:38 <startling> dmwit, will do, thanks
10:45:39 <edwardk> i love the J monad and its variants
10:45:45 <edwardk> its just so much fun
10:45:49 <elliott> dmwit: http://winterkoninkje.dreamwidth.org/81209.html
10:45:56 <elliott> comments might help there
10:46:16 <dmwit> elliott: thx
10:46:51 <elliott> alternatively, you could use a strict list type from one of the endless libraries that give that
10:46:55 <elliott> of course, nothing can stop _|_
10:47:05 <edwardk> there is a slight generalization of the J monad that i published to hpaste a while back.
10:47:30 <edwardk> but hpaste seems to be down
10:47:50 <chrisdone> edwardk: here temporarily http://paste.tryhaskell.org/
10:48:04 <edwardk> http://paste.tryhaskell.org/69758
10:48:06 <edwardk> thanks
10:48:33 <edwardk> istr we had something going through the haskell.org committee to also alias paste.haskell.org in the meantime as well, but that doesn't seem to have happened yet
10:49:12 <chrisdone> benmachine: tomejaguar: elliott: ok, updated hpaste to latest blaze. should build now
10:49:19 <edwardk> i was rather fond of the notion of using contravariant functors to generalize the signature of j.
10:49:21 <edwardk> newtype Search f a = Search { optimum :: f a -> a }
10:49:40 <edwardk> that can be a Monad for any Contravariant functor f.
10:49:51 <startling> elliott: wow neat
10:49:52 <chrisdone> edwardk: yep, i've setup the virtual host, but waiting for the dns to be updated…
10:49:59 * hackagebot snap-app 0.4.0 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.4.0 (ChrisDone)
10:50:02 * hackagebot hpaste 1.1.0 - Haskell paste web site.  http://hackage.haskell.org/package/hpaste-1.1.0 (ChrisDone)
10:50:04 <edwardk> even ones that have multiple 'functions', etc.
10:50:08 <edwardk> or like compare
10:50:16 <dmwit> :t sequenceA
10:50:17 <lambdabot>     Not in scope: `sequenceA'
10:50:17 <lambdabot>     Perhaps you meant one of these:
10:50:17 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
10:50:19 <elliott> dmwit: oh, and I think you can use Const rather than Writer to get the list... fwiw
10:50:23 <dmwit> :t T.sequenceA
10:50:25 <lambdabot> (Applicative f, T.Traversable t) => t (f a) -> f (t a)
10:50:47 <edwardk> yeah const would be the fold-like version of it
10:50:54 <banister> elliott: do you think it's worth learning about monoids
10:50:57 <edwardk> that would be similar to how the lens construction works
10:51:21 <edwardk> banister: lets turn that around. do you think its worth intentionally crippling yourself by not learning about monoids?
10:51:34 <dmwit> elliott: Oh, you just mean that universeF should loop instead of incorrectly being productive?
10:51:39 <dmwit> elliott: I'm 100% sure I don't agree with that.
10:52:05 <dmwit> elliott: That forces you to have the whole universe in memory before you return any value from it!
10:52:14 <elliott> well, I'm saying that Finite defined with a strict list type would (IMO) be better than Finite defined with the current lazy list type. but, I think the nice Applicative trick is better than both.
10:52:19 <dmwit> For things like Int, etc. that's awful.
10:52:23 <elliott> fair point
10:52:31 <elliott> I think the Applicative-based construction is suitably lazy
10:52:39 <dmwit> doubt it
10:53:24 <dmwit> I mean, what are you imagining it can do to check finiteness at runtime other than enumerate the whole damn thing?
10:55:57 <carter> edwardk welcome back to the internet! :)
10:56:12 <edwardk> =P
10:56:22 <edwardk> i never left. longest netsplit in history ;)
10:56:43 <elliott> dmwit: I'm not sure what you mean
10:58:17 <dmwit> elliott: I have now written counterexample :: Applicative f => (Integer -> f b) -> f (Integer -> b).
10:58:28 <dmwit> Therefore, I conclude that assemble is no better than universeF in this regard.
10:58:32 <edwardk> the nice thing about the applicative trick rather than the list trick is that it can much more readily give back and search results like Stern-Brocot trees, which will make dmwit sad at me.
10:59:08 <dmwit> Now that sounds like a much more reasonable argument.
10:59:30 <elliott> dmwit: is counterexample _|_?
10:59:34 <edwardk> thats why lens went crazy and built all of its complex zipper machinery
10:59:47 <edwardk> ok, thats why i went crazy and built all the complex zipper machinery
10:59:49 <dmwit> elliott: almost certainly
11:00:01 <dmwit> elliott: see: I don't think loops are better than incorrect productivity
11:00:30 <elliott> then I don't see why you had to write counterexample to prove me wrong
11:00:38 <elliott> as nothing can ensure finiteness by that definition
11:00:46 <dmwit> Yes, sort of my point.
11:01:07 <dmwit> Well, I'm not convinced nothing can ensure finiteness.
11:01:15 <dmwit> Perhaps there is something fun we can get the compiler to do.
11:01:18 <dmwit> But I can't think of it. =)
11:02:08 <dmwit> ...that is to say, I wrote counterexample to make sure that I understood exactly what limitations the guarantee had.
11:03:26 <elliott> well, nothing value-level, I mean.
11:03:37 <elliott> as soon as your class is just a value I can write = undefined
11:03:43 <elliott> and by your criteria this means it can't ensure finiteness :)
11:04:10 <dmwit> Yes.
11:04:23 <dmwit> But that's okay. Haskell class implementors are used to checking laws.
11:05:28 <magneticduck> is RealFloat the highest standard Num subclass that contains Float (etc)?
11:05:47 <dmwit> If you want me to phrase it as a law, I'm happy to: exists n. genericDrop n universeF = [] -- ;-)
11:06:17 <dmwit> magneticduck: You could try :i Float in ghci.
11:06:23 <tomboy64> yay
11:06:23 <magneticduck> alright thanks
11:06:26 <tomboy64> my program works
11:06:33 <magneticduck> that's always cool :P
11:06:39 <tomboy64> with O(n^10000)
11:06:46 <tomboy64> -.-
11:06:48 <dmwit> magneticduck: I think I've seen a graphviz rendering of the number classes hierarchy floating around somewhere, too...
11:06:51 <tomboy64> it would be
11:07:01 <tomboy64> if O wasn't that huge
11:07:11 <dmwit> tomboy64: If that's also a lower bound, that's pretty impressive.
11:07:16 <magneticduck> hehe
11:07:21 <tomboy64> ^^
11:07:27 <magneticduck> it's just a polynomial
11:07:29 <dmwit> Hard to write an algorithm whose exponent is so high and still so round.
11:07:30 <magneticduck> pretty good
11:07:45 <tomboy64> just a rough guess
11:07:54 <tomboy64> sheeeesh
11:07:57 <magneticduck> the problem is when it's O(10000^x) :P
11:09:57 <elliott> dmwit: anyway, I do find it a little sad that universe inherently ties your enumeration to [] so it's always going to be inefficient/overly-linear in some ways. but I'll definitely see about adding an import when I rebuild lambdabot
11:10:42 <dmwit> elliott: Well, that seems a reasonable objection.
11:10:54 <dmwit> I haven't really thought about more interesting enumeration orders; what did you have in mind?
11:11:10 <dmwit> edwardk seemed to have thought about it a bit, but he didn't say what he had thought, so...
11:11:21 <dmwit> Oh, he's back. So maybe he will anyway.
11:11:53 <edwardk> that was why i suggested the applicative, because then the shape of the 'tree' of the applicative can follow the domain
11:12:01 <dmwit> I mean, the motivation for universe originally was that I hated writing [minBound..maxBound] all the time. =P
11:12:30 <edwardk> you can view that suggestion as a generalization of the fmlist approach
11:12:43 <edwardk> well, really you could just use an fmlist
11:12:51 <dmwit> edwardk: What is the fmlist approach?
11:13:17 <edwardk> newtype FMList a = FM (forall m. Monoid m => (a -> m) -> m)
11:13:42 <edwardk> that serves as an appropriate representation of a list, but where the 'infinities' can go in other places than at the end
11:13:54 <elliott> well, it's also a bit sad to me that you can't do e.g. efficient succ/pred with the universe API. but I suppose you could argue, just use Enum
11:14:04 <dmwit> no no
11:14:05 <elliott> but yes, FMList would be better than status quo I think
11:14:08 <dmwit> I would never argue "just use Enum"
11:14:34 <edwardk> if you give back the elements on Ord order then you can often implement a log time succ/pred using a good tree layout for the type
11:14:57 <elliott> yeah but I'd prefer constant time :P
11:14:59 <edwardk> current lens zipper if given a map will let you find an element by key in the map in log time, because it can borrow the shape of the map
11:15:38 <elliott> right. but succ :: Int -> Int should be O(1). with an "ideal" Universe API you'd be able to do it with nothing but universe
11:15:43 <dmwit> I'm not sure I see yet how FMList makes pred/succ easier.
11:16:05 <dmwit> ...or anything, for that matter. =P
11:16:21 <dmwit> I am an uneducated slob; lift me up into the wonders of education, please.
11:16:26 <trace30m> in "function ( do ..........)" the function needs a type for its argument, but which of the commandos after the "do" has to have that type? the last?
11:16:29 <typoclass> > lift dmwit
11:16:30 <lambdabot>   Not in scope: `dmwit'
11:16:46 <elliott> dmwit: FMList gives you tree structure
11:16:53 <elliott> because you can take advantage of the nesting of the <>s
11:17:02 <elliott> (with your own Monoid instance)
11:17:12 <dmwit> Not with a correct Monoid instance...
11:17:12 <elliott> just like how foldMap is better than foldr for trees
11:17:14 <monochrom> trace30m: yes, the last one
11:17:17 <elliott> dmwit: it's about speed.
11:17:23 <elliott> laws don't prevent you taking advantage of them for speed
11:17:30 <elliott> them = the things deemed equal by the laws
11:17:34 <trace30m> monochrom: thx
11:17:47 <elliott> dmwit: like, you could implement foldMap for a tree in terms of foldr
11:17:58 <elliott> but using that to do searches would be slower than a foldMap that reflects the tree structuer
11:18:05 <edwardk>  dmwit: correct here is relative. if you think about it a monoid gives you a law that says you can reassociate once. by induction you can then reassociate a finite number of times, but that isn't enough to fully reassociate an _infinite_ tree.
11:18:35 <dmwit> It's not?
11:18:56 <edwardk> no, thats axiom of choice material, we're in a constructive setting
11:19:07 <edwardk> i can't do an infinite number of things in finite time
11:19:37 <edwardk> when i do finally figure out how my productivity will increase dramatically
11:19:37 <dmwit> transfinite induction doesn't require choice, just a well-ordering...
11:20:48 <c_wraith> dmwit: cute
11:21:19 <edwardk> sure. you can get there with weaker stuff, but its still bigger than what we've got.
11:21:47 <edwardk> building the well-ordering usually takes the axiom of choice ;)
11:22:20 <dmwit> not sure I believe this; trees have a lot of structure to abuse
11:22:24 <c_wraith> well-ordering is equivalent to choice.
11:22:43 <c_wraith> The axiom of choice is uncontroversial in countable sets, even the infinite ones.
11:22:47 <edwardk> and you can do any finite reassociation of the tree you want with the monoid laws.
11:23:03 <edwardk> but attempting to do so infinitely will spuriously give you bottoms
11:23:21 <elliott> I'm not sure I agree with edwardk but I don't necessarily believe that you need to agree with him to get the efficiency gains I talked about.
11:23:49 <edwardk> reasoning about them in this manner lets you reason about when it is 'your fault' that a bottom showed up ;)
11:24:13 <c_wraith> It's your fault for using a language with bottom values, clearly.
11:24:42 <edwardk> sure. i can go off in coq and prove that none of the things we use every day exist, because they don't exist.. in a strict sublanguage that happens to be embedded in coq =P
11:24:44 <dmwit> Let's just say that at the moment I'm very uncomfortable about what domain we're doing our mathematics in.
11:24:57 <banister> why do many langauges (python/ruby/smalltalk) have built in support for foldl, but typically not foldr? and why did they likely choose foldl over foldr?
11:25:06 <edwardk> i view Hask as more or less a constructive version of Set.
11:25:28 <startling> banister, because foldl is the "obvious" one
11:25:28 <edwardk> banister: in a strict language foldr usually causes stupid things like the stack blowing itself up
11:25:32 <elliott> foldl is better when all your functions are strict.
11:25:41 <elliott> startling: huh? foldr is more obvious than foldl in Haskell. it's all relative
11:25:41 <c_wraith> banister: foldl is a simple loop with an accumulator.  foldr is more complicated, conceptually - and really most valuable when your language supports codata, which python/ruby/smalltalk don't
11:25:58 <banister> c_wraith: what's codata?
11:26:01 <edwardk> if you have a lazy language then foldr is much much more natural
11:26:16 <dmwit> elliott: Anyway. Suppose for the moment I don't care if you write a Monoid instance that breaks all the laws. Where does that leave us?
11:26:20 <dmwit> How do we get succ and pred?
11:26:35 <edwardk> dmwit: i was giving you that the elements are in Ord order.
11:26:39 <edwardk> then search
11:26:43 <edwardk> you can walk down the tree
11:27:05 <c_wraith> banister: codata supports coinduction...  That is, from the top down.  You don't need to start with well-founded base cases.  That's kind of an abstract way of saying "laziness", but it's also theoretically precise. (and "laziness" is not theoretically precise)
11:27:12 <edwardk> we do it in the lens zipper code to seek for keys in ordered indexed data sources
11:27:50 <edwardk> http://hackage.haskell.org/packages/archive/lens/3.9.0.2/doc/html/src/Control-Lens-Internal-Zipper.html#moveToward does evil things
11:27:54 <edwardk> but it works ;)
11:28:24 <dmwit> I see.
11:28:43 <dmwit> It's not what I was imagining, though I can understand why some people would consider it a bit better.
11:29:13 <edwardk> that way if you _can_ balance the domain you can do things like search it more efficiently
11:29:47 <dmwit> right
11:30:40 <elliott> I think you can do it without going through edwardk's evil type.
11:30:43 <elliott> by having more specialised types.
11:30:48 <elliott> (that do follow the monoid laws)
11:30:49 <dmwit> Seems unrelated to finiteness, though.
11:30:56 <edwardk> sure
11:30:58 <elliott> yes we moved off the topic of finiteness :)
11:31:03 <dmwit> okay, sure
11:31:18 <edwardk> i use this for zippers into infinite structures
11:32:03 <elliott> dmwit: btw -- Bottoms are ignored for this entire module: only fully-defined inhabitants are considered inhabitants.
11:32:15 <elliott> your own documentation implies preferring the Applicative form ;)
11:33:50 <dmwit> elliott: inhabitants of the enumerated type, not inhabitants of the class method
11:34:08 <dmwit> elliott: and again, enumerating all values before returning any is a non-starter
11:34:27 <elliott> right. though the Applicative thing doesn't do that, like I said.
11:34:31 <dmwit> or rather, requiring that behavior is a non-starter
11:34:47 <dmwit> I'm having a pretty tough time believing you.
11:35:38 <dmwit> Or else you could write an instance for Integer that starts returning stuff, and therefore isn't bottom.
11:36:06 <elliott> hmm... I think this is actually the same thing edwardk was arguing about
11:36:08 <elliott> bah
11:36:12 * elliott drops the finite thing again :)
11:36:20 <edwardk> heh
11:36:27 <edwardk> come to the dark side
11:36:57 <dmwit> Anyway, I will think about how to do trees in a way I'm comfortable with a bit.
11:37:06 <dmwit> Perhaps just using Tree why not.
11:37:34 <edwardk> i tend towards just using the monoid that way any law breakage is by your users, not you ;)
11:37:42 <dmwit> (i.e. why go to all this trouble with invalid Monoid instances and whatnot if the goal is just to get a tree?)
11:37:56 <dmwit> edwardk: But why break laws at all?
11:38:05 <edwardk> notice the search isn't actually an illegal monoid
11:38:26 <dmwit> If you want a thing where you can observe (<>) association... why not explicitly allow the observation of (<>) association??
11:38:38 <edwardk> he zipper crap is illegal all over the place because it has to be able to _edit_ the structure
11:39:04 <edwardk> mostly because i don't like paying for the initial encoding and then writing an interpreter when i can get it to mash together my functions for me
11:39:37 <c_wraith> Hmm.  If you don't use structural equality, trees are also free monoids.
11:39:45 <elliott> dmwit: I don't want invalid Monoid instances!
11:39:47 <dmwit> edwardk: don't see why you need Monoid to do that
11:39:54 * elliott would be less happy with just using Tree than the current situation, fwiw.
11:40:23 <edwardk> because conceptually an fmlist is a list. its just dropping the 'hey you can reasonably reassociate the domain entirely to the right' assumption.
11:40:34 <dmwit> edwardk: (I mean, I do see why Tree doesn't do that. I just don't see why you should need to use something with so many laws.)
11:41:14 <elliott> maybe I should write some code to show dmwit rather than letting edwardk convince him you need to break laws to usefully use FMList :P
11:41:19 <edwardk> you can do whatever you like, it is your library =P
11:41:34 <edwardk> you don't need to break any laws to do the stuff you want to do
11:41:53 <edwardk> i was merely pointing out that lists tend to make crap APIs for exploring large (in)finite domains.
11:42:01 <dmwit> But if I also don't need to preserve the laws to do what I want to do... what's the point of them?
11:42:12 <dmwit> s/preserve/use/
11:42:18 <elliott> because you want it to be a bijection with N
11:42:19 <elliott> er
11:42:22 <elliott> with a subset of N
11:42:34 <edwardk> the point is that it gives you the 'canonicity' for your instance.
11:42:37 <elliott> surely you can see that "increasing performance" should not imply "becoming less semantically accurate"?
11:42:44 <elliott> this is #haskell! :)
11:42:47 <edwardk> without it each possible tree shape is distinguishable and none is more canonical than the other
11:42:59 <elliott> all that changes if you make an instance that associates in a worse way is that things are slower
11:43:06 <elliott> and of course we are used to such differences mattering
11:43:13 <dmwit> There's already lots of possible instances.
11:43:14 <edwardk> with it, you are free to choose the best performing one, because they are all equivalent under the monoid laws.
11:43:15 <elliott> like, we tell people not to use left-biased (++) chains all the time! because it's slow!
11:43:23 <elliott> but we appreciate the law that tells us that fixing it to be right-biased doesn't change meaning.
11:44:02 <dmwit> e.g. for Bool both [True, False] and [False, True] are perfectly valid instances.
11:44:08 <edwardk> so it serves as a guide. given that they are all equivalent shapes under the laws pick the one that works best for the tie-breaker reason that its fastest
11:44:11 <dmwit> So there's no canonicity even with [].
11:44:14 <dmwit> which is a monoid
11:44:38 <edwardk> dmwit: sure, but if you want to support the binary search trick you'd want to give them back in Ord order.
11:44:47 <edwardk> for domains that have an Ord instance
11:45:19 <elliott> dmwit: I rather see a Universe instance as *defining* the ordering for a countable type.
11:45:20 <edwardk> so now extra concerns, efficiency, search, etc. start shaping the API a bit
11:45:55 <elliott> dmwit: -- a task which does not involve the structure of the tree at all from a semantic POV, and hence *should* have that quotiented out.
11:46:06 <elliott> (while still benefitting from a prudent choice of it for performance reasons)
11:47:36 * dmwit scratches his head and tries to decide what he believes
11:47:43 <enigmuriatic> on p. 247 of learn you a haskell, why does he use "Pair c" in the Functor definition?
11:48:04 <carter> on a related note:  does anyone have any opinions on high/arbitrary precision libs? eg is http://hackage.haskell.org/package/numbers-3000.1.0.3 a decent choice?
11:48:28 <carter> because Rationals have space safety issues if used naively
11:48:50 <c_wraith> So you specifically mean for non-integral numbers?
11:49:00 <dmwit> I doubt CReal is going to do better than Rational on space.
11:49:09 <carter> dmwit yes, I mean BigFloat
11:49:15 <Luke> when using Conduit, does the monad in the conduit have to be a ResourceT?
11:49:40 <Luke> i'm tryng to use (Conduit i State o) and it's complaining the State is not a ResourceT
11:49:42 <dmwit> edwardk, elliott: In any case, thank you very much for the discussion. I feel that I have a better understanding of some tradeoffs and user wishes, in any case.
11:49:43 <carter> or after a computation, taking a rational values back into big floats as a way of doing roudning
11:49:47 <carter> *founding
11:49:53 <carter> *rounding
11:50:00 <carter> dmwit whats the lib in question for?
11:50:00 <elliott> dmwit: funny. I feel I have less.
11:50:11 <dmwit> carter: fun
11:50:20 <carter> whats it do?
11:50:25 <dmwit> But as a side effect, having users wouldn't suck. =)
11:50:34 <dmwit> carter: It's a better [minBound .. maxBound]
11:50:37 <dmwit> ?hackage universe
11:50:37 <lambdabot> http://hackage.haskell.org/package/universe
11:50:41 <carter> neat
11:51:20 <dmwit> enigmuriatic: Perhaps you could put the relevant code up on hpaste.
11:51:56 <dolio> edwardk: I don't think it's about Coq being strict.
11:51:59 <dolio> It's about totality.
11:52:19 <dolio> Your 'infinite traversals' aren't total for all choices of Applicative and functions.
11:52:28 <enigmuriatic> dmwit, Pair is a newtype for a tuple with two items, and he uses "instance Functor (Pair c) where"
11:52:31 <carter> dmwit yeah, Rationals are probably better behaved wrt space complexity than Creals because i can truncate them if i have to
11:52:45 <dmwit> enigmuriatic: e.g. newtype Pair a b = Pair (a, b) -- ?
11:52:54 <dolio> You need some restriction on the allowed arguments to define them totally.
11:53:22 <dolio> That is why they don't exist in Coq, at least with the same types.
11:53:33 <dmwit> enigmuriatic: If so, I guess the answer to your question is, well... what else would you use?
11:55:28 <elliott> dolio: maybe there's an InfiniteApplicative class you can create in a language with proper codata.
11:55:34 <elliott> that permits infinite traversals.
11:55:35 <enigmuriatic> dmwit, i don't understand why the c is there
11:55:41 <enigmuriatic> i would expect it to just be Pair
11:55:47 <dmwit> enigmuriatic: Okay, so you want "instance Functor Pair where"?
11:55:48 <elliott> Functor takes a type with one argument.
11:55:54 <elliott> Pair takes two. you have to give it the first.
11:55:57 <dmwit> enigmuriatic: Think about what the type of "fmap" would look like, then.
11:56:05 <dolio> Maybe. That may even be too restrictive for what you sometimes want, though.
11:56:15 <dmwit> enigmuriatic: "fmap :: (a -> b) -> (Pair a -> Pair b)". But "Pair a" isn't even a type yet... it needs another argument!
11:58:36 <magneticduck> (Pair Integer) is just a good a wrapper as Maybe
11:58:52 <magneticduck> uh, that makes no sense; but it's the same kind
11:58:55 <enigmuriatic> dmwit, Maybe's functor definition is just "instance Fuctor Maybe where" though
11:59:13 <magneticduck> yeah, that's because Maybe is already of kind * -> *
11:59:25 <magneticduck> it takes a concrete type and returns a concrete type, you could say
11:59:30 <magneticduck> (Maybe does)
12:00:04 <magneticduck> you can substitude Maybe with (Pair Integer) as far as types are concerned
12:00:16 <magneticduck> also, our names have the same length, and that's cool
12:00:48 <Gracenotes> I can't even tell you two apart
12:00:54 <magneticduck> heh
12:01:20 <themagneticduck_> there, maxed out the name length limit
12:01:27 <themagneticduck_> now you can tell us apart
12:02:05 <dmwit> enigmuriatic: Well, "fmap :: (a -> b) -> (Maybe a -> Maybe b)" looks like a good type to me. Notice that "Maybe a" is a type, but "Pair a" isn't, right?
12:02:33 <Gracenotes> you have to watch out, it's an arms race out there
12:03:12 <theMagneticDucky> woohoo
12:03:18 <osa1> I'm planning changing every String in my codebase with Text, is this a reasonable thing to do? I'm wondering if there's a case where using String is better ..
12:03:29 <dolio> Now you're yellow again.
12:03:56 <Luke> chrisdone: hpaste is down. isn't that your site?
12:04:00 <dmwit> String is better when you're interfacing with code that expects a String.
12:04:29 <osa1> dmwit: right. and other than that?
12:04:35 <theMagneticDucky> let's switch from using Strings to using Text as soon as we get around to using base 12 instead of base 10
12:04:42 <osa1> and even in that case I can simply `unpack`
12:04:49 <elliott> theMagneticDucky: wat
12:04:50 <dmwit> It's also a convenient type because many Prelude functions are polymorphic over all lists.
12:05:08 <theMagneticDucky> elliott: lots of changes to make in this world :P
12:05:13 <elliott> osa1: it's also convenient when you're using [Char] as more of a control structure.
12:05:33 <Gracenotes> I mean... that's not too often, I might think...
12:05:38 <dolio> What's base 12 good for? Better lineup for imperial measurements?
12:06:02 <geekosaur> times?
12:06:03 <osa1> elliott: how can I use [Char] as a control structure?
12:06:04 <Gracenotes> reasoning about time in ancient Babylon
12:06:20 <dmwit> osa1: I'm not saying it's impossible to interface between String and Text code, I'm saying String is better than Text when you're interfacing with other String code. Nothing deep there.
12:06:25 <theMagneticDucky> honestly, I don't advocate especially for base 12; a more important change is getting everybody to use Linux instead of Windows
12:06:30 <theMagneticDucky> xl
12:06:34 <osa1> ok
12:06:44 <theMagneticDucky> but this kind of conversation is pretty silly
12:06:55 <tdammers> theMagneticDucky: well, getting everybody to use *anything* instead of Windows would be a start
12:06:57 <elliott> osa1: same way you use lists in general as a control structure :)
12:06:58 <elliott> they're loops
12:06:59 <dmwit> If we're going to switch base, e is the right one to switch to.
12:07:03 * theMagneticDucky is silly today
12:07:03 <Gracenotes> perhaps humans would have a better grasp on most arithmetic if they used base 12
12:07:09 <tdammers> but I think Microsoft is currently dedicated a lot of resources to this goal themselves
12:07:11 <elliott> no OS flamewars, please :p
12:07:19 <tdammers> alright alright
12:07:31 <dolio> I was interested to hear that ByteString is a bad choice from the BazQux guy.
12:07:37 <dolio> Because it causes memory fragmentation.
12:08:16 <dolio> That often gets overlooked in the comparison, I think.
12:08:20 <theMagneticDucky> but honestly, moving to base 12 isn't going to improve the world; it might makes certain unimportant things faster by some small value, but who's to say that faster is better
12:08:22 <Gracenotes> perhaps Americans would have a better grasp on how close they were to boiling, relative to freezing, if they used Celsius
12:09:13 <dolio> What's body temperature? 37?
12:09:19 <theMagneticDucky> perhaps Americans would stop almost electing crazy people as president if they thought in a manner that actually makes sense
12:09:24 <elliott> Gracenotes: that way they'd be more likely to be accurate when saying "I'm boiling hot"?
12:09:26 <dolio> > 32 + 9*37/5
12:09:28 <lambdabot>   98.6
12:09:36 <elliott> theMagneticDucky: plz don't
12:09:46 <theMagneticDucky> xlk
12:09:49 <theMagneticDucky> *xl
12:10:00 <Gracenotes> I actually got my body temperature taken recently, I was at something like 97.8.
12:10:01 * hackagebot azurify 0.3.0.0 - A simple library for accessing Azure blob storage  http://hackage.haskell.org/package/azurify-0.3.0.0 (ArnoVanLumig)
12:10:12 <theMagneticDucky> Azure blobs? I hope that's not a food
12:10:14 <Gracenotes> I'm pretty cool honestly
12:10:23 <S_J> can anyone come up with some good properties of linked lists that are often implemented wrong?
12:10:23 <dolio> Gracenotes: The standard is pretty obviously translated from celsius to fahrenheit.
12:11:07 <Gracenotes> S_J: not a property, but a concise imperative algorithm to reverse a linked list in place is surprisingly hard to get exactly right from scratch
12:11:19 <dolio> > map (\x -> 32 + 9 * x / 5) [36..38]
12:11:20 <lambdabot>   [96.8,98.6,100.4]
12:12:11 <theMagneticDucky> S_J: linked lists? as in, with Pointers / IORef?
12:12:15 <Gracenotes> both the loop version and the recursive version
12:12:41 <theMagneticDucky> k
12:12:44 <byorgey> > 32 + 9*36.5/5
12:12:45 <lambdabot>   97.7
12:13:11 <byorgey> Gracenotes: could be just rounding error =)
12:13:50 <theMagneticDucky> the FTL title theme is awesome for programming, people
12:14:06 <theMagneticDucky> http://www.youtube.com/watch?v=QHDMqWMzBG8
12:14:21 <Botje> I should queue that. I have the OST.
12:15:13 <theMagneticDucky> FTL is seriously great in every way, certainly not excluding the music
12:16:20 <theMagneticDucky> the FTL music is OST, Botje ?
12:19:39 <Botje> you could buy an extended version of FTL with the music separately
12:21:19 <chrisdone> theMagneticDucky: needs moar rammstein
12:21:49 <Gracenotes> the best kind of music for programming is music you're accustomed to
12:22:00 <merijn> TL!!
12:22:03 <merijn> eh
12:22:07 <merijn> Missed an F there
12:22:07 <Gracenotes> or, failing that, something that's more harmonic than melodic
12:22:16 <merijn> Dustfoce soundtrack is good for programming, too
12:23:06 <merijn> I was actually trying to get a collaborative "programming music" playlist going on spotify, but no one in -blah seemed game for that... :\
12:24:11 <theMagneticDucky> I don't like exciting or snappy music to program to though; makes my fingers all jiggly
12:24:15 <theMagneticDucky> for instance, http://www.youtube.com/watch?v=1emSWVcSu8s
12:24:21 <theMagneticDucky> cavestory with lyrics
12:24:51 <theMagneticDucky> I guess it's the linkchecking bot's day off
12:25:03 <elliott> linkchecking bot?
12:25:13 <Gracenotes> ain't none
12:25:17 <theMagneticDucky> mm
12:25:20 <theMagneticDucky> then we need one here
12:25:31 <Gracenotes> cave story is good. also fun to play on piano.
12:25:40 <elliott> lambdabot used to do URL stuff.
12:25:40 <theMagneticDucky> you know, a bot that goes to a link and returns the title text of the page
12:25:41 <elliott> it does no longer
12:25:41 <theMagneticDucky> or something more sophisticated
12:25:44 <theMagneticDucky> sad
12:25:46 <theMagneticDucky> :<
12:25:52 <elliott> well, it's spammy.
12:25:56 <elliott> though I guess you might consider that a positive. :p
12:26:00 <edvardkk> agreed.
12:26:11 <theMagneticDucky> I don't consider spam a negative
12:26:15 <theMagneticDucky> that's how how I work :P
12:26:17 <edvardkk> also, it sucks when the link-checker-bot ruins a good joke
12:26:27 <theMagneticDucky> ah yeah, that's a problem
12:26:31 <elliott> #haskell does ;)
12:26:46 <theMagneticDucky> people are still doing rickrolling?
12:26:47 <Gracenotes> You must convince us to click on some sort of merit not verified by a trusted third party
12:26:57 <Gracenotes> GOOD LUCK
12:27:05 <theMagneticDucky> glhf
12:27:07 <theMagneticDucky> >:)
12:27:13 <theMagneticDucky> game is on
12:28:33 <Cale> I prefer the version without lyrics :P
12:28:41 <theMagneticDucky> sadly, html <link> s are usually the only way you're getting rickrolled, so you have to be waay more crafty on IRC
12:29:06 <theMagneticDucky> is www.g.oogle.com, www.go.ogle.com etc registered? :D
12:29:27 <Cale> http://www.youtube.com/watch?v=n-aitfK7jRE
12:30:10 <theMagneticDucky> cool, somewhat less distracting too
12:30:12 <theMagneticDucky> =P
12:30:21 <Gracenotes> what song is the lyric'd version based off of?
12:30:30 <Gracenotes> I do not have sound-listening capabilities currently
12:30:34 <byorgey> ok, can we take the discussion of programming music to -blah please
12:30:50 <elliott> byorgey++
12:31:13 <Gracenotes> i kno right
12:31:22 <Cale> Gracenotes: See my link
12:31:44 <Cale> Gracenotes: Oh, it's the theme song to a game called Cave Story
12:33:13 <chrisdone> what's apfelmus's nick on here?
12:33:47 <elliott> apfelmus
12:33:49 <elliott> but he doesn't come
12:35:02 * hackagebot module-management 0.10.1 - Clean up module imports, split and merge modules  http://hackage.haskell.org/package/module-management-0.10.1 (DavidFox)
12:40:59 <theMagneticDucky> that looks interesting, module-management
12:41:14 <theMagneticDucky> no docs tho :<
12:42:47 <theMagneticDucky> bb haskellers
12:43:47 <Spockz> kosmikus: what is your opinion on footnotes in code listings, in particular Haskell listings formatted with lhs2tex?
12:45:02 * hackagebot pwstore-purehaskell 2.1.1 - Secure password storage, in pure Haskell.  http://hackage.haskell.org/package/pwstore-purehaskell-2.1.1 (CorentinDupont)
12:48:26 <quchen> How do I know that `fmap f x = pure f <*> x`? The types match and both sides satisfy the functor law(s), but is that sufficient for equality?
12:48:43 <quchen> Similarly, how do I show that `fmap f x = x >>= return . f`?
12:48:59 <ion> “The types match. QED.”
12:49:20 <CaptainK> trying to pattern match x and y, if x == y then print x
12:49:36 <CaptainK> String variables
12:49:41 <quchen> ion: `fmap f x = pure (seq undefined f) <*> x` has matching types as well.
12:50:03 <ion> quchen: (thatwasajoke)
12:50:22 <quchen> ion: (I overlooked the jokation marks)
12:51:02 <roconnor_> quchen: the free theorem for fmap imples there is at most one functor implementation.
12:51:05 <Botje> CaptainK: use a guard.
12:51:06 <merijn> quchen: Substitute by hand to prove that both sides are equal
12:51:24 <Botje> f ... x ... | x == y = ...
12:51:33 <quchen> merijn: Substitute what? I don't want to show it for every instance
12:51:35 <CaptainK> ["123","a","43"] and ["123","f","2343423"]  only match equal  entries
12:51:43 <quchen> roconnor_: Ah, the free theorem again.
12:51:48 <roconnor_> quchen: that said, the free theorem only applies for total functions
12:52:01 <CaptainK> ah ok, need to use guards more
12:53:02 <quchen> roconnor_: Aren't fmap and <*> total?
12:53:17 <ion> captaink: In what context would you like to check for the equality? In a function definition like botje showed or somewhere else?
12:53:53 <Ralith> quchen: fmap on what?
12:54:24 <quchen> Ralith: On anything
12:56:30 <Ralith> quchen: insofar as that it complies with the laws, sure
12:56:36 <CaptainK> to create a new list
12:56:57 <CaptainK> [x| x <- wordsflip, y <- wordsfive, x == y  ]
12:57:01 <quchen> Ralith: Well, I meant a Functor's fmap of course.
12:57:08 <CaptainK> but that does not work
12:57:45 <ion> captaink: Please define “does not work”.
12:58:04 <Ralith> quchen: just making the point that haskell does not actually require that functor instances have total fmaps
12:58:04 <CaptainK> it just spits out the list without matching
12:58:33 <ion> captaink: I suppose you’ll need to provide an actual example of the input, the output and the expected output in hpaste.
12:59:52 <quchen> Ralith: I think it does, because of the Functor laws. With non-total fmap, you won't have `fmap id = id` for example.
12:59:53 <CaptainK> ["aaa","b","a"] + ["aaa","ddd","xd"]  want ["aaa"]
13:00:13 <CaptainK> because they match, so new list is reduced to only entries that match
13:00:19 <Ralith> quchen: haskell, as in the language, does not and cannot enforce compliance with the functor laws
13:00:21 <Gracenotes> intersection?
13:00:40 <ion> captaink: An intersection? Data.List.intersect
13:00:40 <byorgey> > [x| x <- ["aaa","b","a"], y <- ["aaa","ddd","xd"], x == y]
13:00:41 <joelteon> so I have to install imagemagick with --extra-include-dirs=/usr/include --extra-lib-dirs=/usr/lib
13:00:41 <joelteon> uhhh, shouldn't those be defaults?
13:00:44 <lambdabot>   mueval-core: Time limit exceeded
13:00:45 <quchen> Ralith: The compiler cannot enforce compliance. Haskell can.
13:00:55 <merijn> quchen: That makes no sense
13:01:03 <byorgey> CaptainK: that code you wrote should work fine.  But yes, 'intersect' is probably what you want.
13:01:05 <Gracenotes> for a very large collection of words, a Data.Set may be worth it
13:01:12 <ParahSailin> @src intersect
13:01:13 <lambdabot> intersect = intersectBy (==)
13:01:15 <Ralith> quchen: does the spec mandate that a program which specifies a functor-law-incompliant functor instance is not legal haskell?
13:01:16 <ParahSailin> @src intersectBy
13:01:16 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
13:01:20 <merijn> quchen: My remark with subtituting by hand meant, grab a piece of paper and derive the equality by hand like you would do for algebra
13:01:22 <Gracenotes> 'unordered' (or enforced sorted)
13:01:49 <ion> Yeah, Data.Set.intersect should have a much better performance, but for short lists it won’t matter.
13:01:50 <CaptainK> byorgey: ya did that and it just spirts out the last list in this case "y"
13:01:51 <byorgey> Ralith: no
13:02:02 <merijn> quchen: There's not way to encode that law in haskell (at least, not for the normal functor, maybe you can hack something together using GADT and DataKinds type stuff)
13:02:06 <Ralith> quchen: well there you go then.
13:02:14 <Ralith> byorgey: thanks
13:02:18 <byorgey> > [x| x <- ["aaa","b","a"], y <- ["aaa","ddd","xd"], x == y]
13:02:19 <lambdabot>   ["aaa"]
13:02:23 <byorgey> CaptainK: ^^^ like that?
13:02:27 <quchen> Ralith: The Report says "instances for Functor should satisfy the following laws". So yes, something that doesn't follow the laws compiles, but it's not a Functor.
13:03:12 <nabilhas`> hello all, I'm having a problem with modules, importing one source file i've written in another, etc. there are many aspects to this problem but they probably all stem from the same root
13:03:13 <CaptainK> or if the list is longer list ["aaa","fff"...n] create a new list
13:03:14 <byorgey> CaptainK: I don't think you did what you think you did.
13:03:20 <nabilhas`> here's an example of something that goes wrong:
13:03:21 <quchen> And when it satisfies the laws, it seems total to me. (Although I'm not sure how I would prove it.)
13:03:36 <nabilhas`> `ghci test/Test.hs` will load up the file and compile everything just fine
13:03:49 <merijn> quchen: You prove it total the same way you'd prove that it satisfies the laws
13:03:55 <nabilhas`> `runhaskell test/Test.hs` will yield an error that it cannot find a module that I import
13:04:01 <Ralith> quchen: are we using the IETF 'should'?
13:04:09 <nabilhas`> I don't understand why one should be able to import the module, but not the other
13:04:30 <quchen> Ralith: It's the British should, which means "under all circumstances".
13:05:16 * Ralith nudge byorgey 
13:05:18 <merijn> quchen: It doesn't mean that, it means "it is highly desirable that Functor instances satisfy the following laws"
13:05:27 <CaptainK> checked it again, it should work.
13:05:29 <Ralith> sounds like the IETF should to me
13:05:38 <CaptainK> but nope...msut be missing something
13:05:45 <merijn> "violating said laws might result in other programmers coming by your house and kicking you in the crotch"
13:05:50 <quchen> merijn: Hm. Well then I don't have any idea how to do that, because I know of no connection between Functor and Applicative besides what was mentioned (i.e. fmap using <*>)
13:06:35 <elliott> I don't understand Ralith and quchen's disagreement.
13:06:40 <quchen> merijn: Physically being kicked in the crotch is a program error. No compiled program should do that.
13:06:55 <elliott> as far as I know it is ambiguous whether compilers can assume Functor instances satisfy the laws.
13:07:10 <merijn> quchen: http://kurtmedley.com/2013/01/24/proving-functor-laws-for-the-either-type-class/
13:07:11 <Ralith> quchen: so I can't use haskell to run my crotch-kicking robot? :(
13:07:16 <elliott> I think GHC's Array implementation used to segfault if you used an invalid Ix instance.
13:07:24 <elliott> then it was fixed because it was considered a security issue.
13:07:33 <elliott> but RULES still assume laws and stuff, just in less crashy ways.
13:07:37 <startling> quchen, you can derive a functor instance from (<*>) and pure
13:07:59 <startling> :t \f -> (pure f <*>)
13:08:00 <lambdabot> Applicative f => (a -> b) -> f a -> f b
13:08:02 <byorgey> nabilhas`: I don't know why they are different, but if Test.hs imports other modules also in test/, it may not work to call ghci or runhaskell from one directory up.  You might have to  cd test && runhaskell ...
13:08:10 <quchen> startling: I "know" that `fmap f x = pure f <*> x`, but I don't know how to show that that's actually true.
13:08:26 <quchen> startling: Types match, both sides satisfy the Functor laws. And now?
13:08:36 <startling> quchen, isn't that enough?
13:08:57 <merijn> quchen: Algebra, subtitute the fmap symbol in the laws with your implementation, manually simplify until left hand equals right hand by substituting by hand
13:08:57 <byorgey> not a priori.
13:09:06 <merijn> quchen: Repeat for all laws
13:09:15 <quchen> merijn: And each instance individually?
13:09:26 <quchen> startling: I'm not sure. Even if it was enough, then I would like to know how to show that it is.
13:09:27 <merijn> quchen: Yes
13:09:30 <nabilhas`> byorgey: Test.hs only imports a single module from `src`. The project top level has only two subdirectories, `test` and `src`
13:09:34 <roconnor_> @free map
13:09:35 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
13:09:51 <merijn> quchen: Nothing in the type system enforces that "fmap f x = pure f <*> x"
13:09:51 <nabilhas`> if I cd into test, then even `ghci Test.hs` will fail to work
13:09:58 <chrisdone> is there a pprint for TH that prints exactly what was given to e.g. [| foo |] without any qualification?
13:10:04 <nabilhas`> as well as `runhaskell Test.hs` continuing to not work
13:10:06 <byorgey> nabilhas`: test/Test.hs imports something from src/?  That is not going to work
13:10:09 <roconnor_> @free fmap
13:10:10 <lambdabot> Extra stuff at end of line in retrieved type "Functor f => (a -> b) -> f a -> f b"
13:10:34 <roconnor_> quchen: take h = id and f = id  in @free map
13:10:43 <nabilhas`> byorgey: I've written many toy programs but this is my first substantial program.
13:11:02 <nabilhas`> byorgey: so perhaps this is simply my own ignorance, but I thought it was standard to have separate `src` and `test` directories
13:11:10 <NemesisD> i've gotten a bit confused on something guys. i'm trying to combine the list monad to essentially run a monad for every element of a list, but it happens to be in an EitherT so in any permutation i can abort early
13:11:57 <byorgey> nabilhas`: yes, having separate src and test directories is great, but you can't just load up something from test/ in ghci and expect it to magically figure out to find its imports in src/
13:11:59 <NemesisD> however i end up having to do x <- lift $ listOfValues; when (skipThisOne) $ left "nope", it just stops entirely the first time it hits that left
13:12:11 <chrisdone> no TH gurus in the house?
13:12:33 <byorgey> nabilhas`: you probably want to make a .cabal file and create a test suite
13:12:51 <byorgey> then cabal can manage this kind of thing for you
13:13:06 <nabilhas`> byorgey: I tried working around that with a .ghci file for my project that includes ":set -isrc:test"
13:13:08 <byorgey> to do it manually you would have to pass an option to ghc like  -isrc
13:13:31 <byorgey> nabilhas`: ah, well that would explain why it works with ghci but not with runhaskell
13:13:52 <nabilhas`> ah, this is beginning to make sense. is there something analogous i can put in my .cabal?
13:14:23 <byorgey> nabilhas`: there is an hs-source-dirs field
13:14:28 <quchen> roconnor_: Thanks, I'll try to work with that
13:14:52 <chrisdone> =(
13:14:57 <byorgey> nabilhas`: in fact, there is an hs-source-dirs field for each section.  So you can have  hs-source-dirs: src  for your library section and  hs-source-dirs: test, src   for your test suite
13:15:14 <byorgey> nabilhas`: just cd to the root of your project and type 'cabal init'
13:15:47 <nabilhas`> byorgey: i actually have a cabal file already, although i'm fairly sure it's not done well
13:16:02 <nabilhas`> i can send the link to the github page where i have my quite limited progress so far if that would make this easier
13:16:10 <byorgey> nabilhas`: ok, well copy it somewhere else first, then run cabal init
13:16:22 <byorgey> then you can compare and import stuff from your old .cabal file
13:17:00 <byorgey> nabilhas`: why don't you work through cabal init first, then send me a link to github if you are still having trouble figuring out how to set it up
13:17:54 <nabilhas`> byorgey: okay, i started doing `cabal init`. i'm a bit confused by the choice between 'library' and 'executable' a few questions in
13:18:25 <byorgey> nabilhas`: are you creating a program that people can run?  Or a library which others can use in developing their software?
13:18:46 <byorgey> (the answer can actually be 'both', but cabal init doesn't handle that case)
13:18:56 <nabilhas`> right, i guess i'd eventually like it to be both
13:18:59 <byorgey> if 'both' just pick 'library' for now and you can add an executable section later
13:19:04 <nabilhas`> alright
13:19:15 <CaptainK> This just spills out wordsflip [x| x <- wordsflip, y <- wordsfive, x == y]
13:19:50 <byorgey> CaptainK: well, then everything in wordsflip is also contained in wordsfive.
13:20:03 <CaptainK> no it is not
13:20:11 <CaptainK> thats the peoblem
13:20:34 <byorgey> > let {wordsflip = ["aaa", "bc"]; wordsfive = ["aaa", "xy"]} in [x| x <- wordsflip, y <- wordsfive, x == y]
13:20:36 <lambdabot>   ["aaa"]
13:20:57 <byorgey> CaptainK: you are doing something wrong.  but I have no idea what.
13:21:06 <nabilhas`> byorgey: so now under 'library', i should add a section "hs-source-dirs: src"?
13:21:10 <osa1> let's say I have a class 'ToText a where toText :: a -> Text', can I derive it for all instances of show with default implementation of 'toText = pack . show' ?
13:21:14 <CaptainK> ya for sure, I'm missing something
13:21:28 <startling> osa1, no
13:21:30 <byorgey> nabilhas`: if you already have a 'src' directory which contains some .hs files, cabal init should have created that field automatically
13:21:57 <byorgey> well, unless you have a very old version of caba.
13:21:59 <byorgey> *cabal
13:22:05 <osa1> startling: is there anything wrong with that or is it just an unsupported feature, with no fundamental problems?
13:22:17 <nabilhas`> byorgey: the way i copied the files to a new directory was a bit foolish. I think i understand now
13:22:24 <startling> osa1, you could do data Showing a = Showing a; instance Show a => ToText (Showing a) where ...
13:22:27 <byorgey> nabilhas`: in any case, if an hs-source-dirs: field is not already there, then sure, you can add one
13:22:40 <startling> osa1, the problem is that adding an instance could cause a conflict
13:23:01 <tomboy64> why am i getting a parse-error at the second 'where'? http://bpaste.net/show/111241/
13:23:12 <startling> osa1, that is, there could be two instances for the same type
13:23:15 <osa1> startling: ahh, you mean adding a new ToText a instance where a is an instance of Show, right?
13:23:18 <mauke> tomboy64: indent it more
13:23:44 <osa1> startling: what if I enabled UndecidableInstances ?
13:23:51 <osa1> enable*
13:24:04 <geekosaur> this would require OverlappingInstances
13:24:06 <tomboy64> mauke: i gave where and the let below 2 more tabs already, still wrong
13:24:27 <startling> osa1, don't do that. :)
13:24:42 <geekosaur> tomboy64, what's that last line supposed to do?
13:25:17 <byorgey> tomboy64: let a = digits n  is invalid syntax
13:25:19 <mauke> tomboy64: what's the error message?
13:25:23 <tomboy64> geekosaur: let a = digits n? it's just a shorthand so i don't need to write "digits n" a thousand times
13:25:30 <geekosaur> it's wrong
13:25:33 <byorgey> tomboy64: you can just get rid of the 'let'
13:25:44 <tomboy64> prob0425.hs:37:1: parse error (possibly incorrect indentation)
13:25:51 <osa1> so does that mean I have to manually write instances like `intance ToText Int ...` `instance ToText Doulbe ...` etc.
13:25:54 <byorgey> tomboy64: where  replace xs i = .....  ;  a = digits n
13:25:56 <mauke> tomboy64: your paste has no line 37
13:27:02 <tomboy64> mauke: it's not the whole file. and it's actually line 34 with the where correctly placed.
13:27:04 <byorgey> tomboy64: unless it's in a do-block, let ... always has to be followed by 'in ...', i.e.   let x = 3 in x + 7
13:27:54 <tomboy64> mauke: this is the full file: http://bpaste.net/show/111243/
13:28:30 <geekosaur> the where on line 34 still needs to be indented
13:28:36 <mauke> tomboy64: indent it more
13:28:49 <merijn> Can I wrap an Applicative (no Monad instance) in ReaderT and use it as an applicative reader?
13:29:04 <elliott> I think the instance might be Monad m => ...
13:29:06 <tomboy64> okay. now i get a type error. thanks.
13:29:18 <tomboy64> it was indentation after all :-/
13:31:09 <roconnor_> Applicative m => Applicative (ReaderT r m)
13:31:31 <banister> what is  ?
13:31:34 <dropdrive> How might I express a hierarchy of enums in Haskell, e.g. data Region = Pacific | EastCoast | South; data State = CA | AL | NY | MA | ... where a function that takes a Region can (hopefully) transparently take a state?
13:31:34 <banister> _|_
13:31:40 <banister> what is _|_
13:32:03 <hpc> dropdrive: possibly a type class?
13:32:06 <roconnor_> it is the lowest element of a lattice
13:32:18 <hpc> it depends on how it's going to be used
13:32:27 <geekosaur> "bottom", the `least defined` value. one representation of this is `undefined`
13:32:41 <geekosaur> (otherwise known as a non-terminating computation)
13:32:54 <nabilhassein> byorgey: sorry, I got disconnected, but your advice worked! thank you so much
13:33:18 <startling> banister, _|_ a = _|_ a
13:33:27 <startling> (imagine that's valid haskell)
13:34:59 <elliott> I think you want one fewer a there...
13:35:05 <elliott> but not all _|_s are functions.
13:35:09 <byorgey> nabilhassein: great!
13:35:31 <merijn> roconnor_: Ah, thanks, that's great :)
13:35:32 <startling> elliot, why do I want one fewer a?
13:35:39 <elliott> because what you said is _|_ a = _|_ a
13:35:45 <elliott> which has no information content, because equality is reflexive :P
13:35:54 <elliott> in particular it doesn't tell you anything about _|_.
13:35:59 <napping> Is there any code to go with the adjoint recursion schemes paper from ICFP?
13:36:17 <CaptainK> byorgey: ok, its comparing equal length, I want equal bytes
13:36:19 <Hafydd> "_|_ a = _|_, aye?"
13:36:19 <byorgey> elliott: but if you write  f a = f a  in Haskell, that does tell you something about f.
13:36:28 <startling> ^
13:36:42 <byorgey> namely, that it does not terminate.  (assuming there are no other clauses defining f which come before that)
13:36:53 <startling> elliott: but yeah, "not all _|_s are functions" is a good point
13:37:07 <napping> I've written a bit, but it the schemes seem to collapse to having d (c a) -> c a where your data is Mu d
13:37:11 <byorgey> CaptainK: hm? ==  does not compare lengths.
13:37:20 <elliott> byorgey: oh, fair enough. I didn't read it as a definitional = at all because _|_ isn't valid syntax :p
13:37:31 <elliott> but yes, I was expecting _|_ a = _|_
13:37:49 <byorgey> that doesn't even type check!
13:37:57 <startling> :)
13:38:53 <startling> CaptainConst
13:39:06 <geekosaur> CaptainK, perhaps you could pastebin your actual code?
13:39:55 <CaptainK> geekosaur: ok, I'll do some more layh and try to answer the question myself and later post back if stumpted.
13:40:04 <osa1> let's say I'll compare a string and a text for equality, should I pack string? or should I unpack text?
13:40:35 <merijn> If I have a transformer stack, should I just "type" it to a nicer type name in my API or should I wrap it in a newtype and derive all the relevant typeclasses?
13:40:51 <nabilhassein> byorgey: i have a speculative question. i like how `cabal init` inferred the packages and versions to put in my "build-depends". is there a command to have cabal do something similar again as I add dependencies?
13:40:58 <dolio> Actually, all bottoms are functions.
13:41:01 <dolio> And integers.
13:41:06 <dolio> And ...
13:41:20 <elliott> dolio: that's such a set theoretic view. :(
13:41:25 <merijn> nabilhassein: If you try to compile using "cabal build" while using packages not in the cabal file, it will complain and tell you which ones to add
13:41:29 <startling> osa1, shouldn't make much of a difference
13:41:38 <dolio> It is the domain theoretic, semantic view.
13:41:46 <dolio> And the view of ∀ as intersection.
13:41:54 <dolio> Which is quite informative.
13:41:57 <byorgey> nabilhassein: that is an excellent question.  sadly, the answer is currently no.
13:42:33 <byorgey> nabilhassein: the only reason is that we don't yet have a nice way to parse a .cabal file, make edits to it, and pretty-print it back out while preserving things like whitespace, indentation, etc. etc.
13:42:48 <johnw> I guess you could make a copy of the project and run cabal init a second time
13:42:55 <Demos> could you hack something together with rm, cabal init, and diff?
13:43:07 <CaptainK> [x| x <- ["TEN","THREE"], y <- ["TEN","TEN"], x == y]
13:43:08 <byorgey> johnw: yes, but then you have to merge the two resulting .cabal files.
13:43:08 <haasn> byorgey: compromise: print the dependencies that need to be added to stdout
13:43:09 <startling> byorgey: an easy solution would be "cabal print-dependencies"
13:43:12 <merijn> Demos: That doesn't work if your layout differs from the output of cabal init
13:43:23 <merijn> startling: It prints missing ones when you try to compile anyway
13:43:33 <byorgey> haasn, startling: true!  patches welcome =)
13:43:35 <startling> merijn: not all of them, does it?
13:43:41 <startling> just the first one it sees
13:43:56 <merijn> startling: Probably, but I just repeat until I have them all
13:44:04 <startling> merijn, that's annoying to do
13:44:48 <nabilhassein> byorgey: okay. thanks again
13:44:59 <Demos> honestly my approach would be to hack together a perl script, but that is ofc not ideal
13:45:30 <byorgey> ok, you all have inspired me, when I get around to hacking on cabal again next this is what I will work on ;-)
13:45:58 <byorgey> though if someone else wants to work on it before then, be my guest =)
13:46:14 <byorgey> CaptainK: what does that print?
13:46:28 <CaptainK> let {x = ["AAA","xy"]; y= ["AAA", "xyz"]} in [x| x <- ["TEN","THREE"], y <- ["TEN","TEN"], x == y]
13:46:45 <elliott> that definition x and y is pointless
13:46:50 <elliott> they're shadowed in the list comprehension.
13:46:52 <CaptainK> yep
13:47:08 <byorgey> CaptainK: if you prefix these expressions by >  lambdabot will evaluate them for you
13:47:12 <CaptainK> cut and paste blew up with kids typing on keyboard
13:47:28 <CaptainK> \[x| x <- ["TEN","THREE"], y <- ["TEN","TEN"], x == y]
13:47:45 <CaptainK> hows that work with lambdabot?
13:49:15 <elliott> > 2 + 2
13:49:16 <lambdabot>   4
13:49:24 <geekosaur> what was the \ supposed to do there?
13:49:30 <CaptainK> >[x| x <- ["TEN","THREE"], y <- ["TEN","TEN"], x == y]
13:49:43 <geekosaur> the space after > is not optiona;
13:49:45 <geekosaur> *optional
13:50:08 <CaptainK> > [x| x <- ["TEN","THREE"], y <- ["TEN","TEN"], x == y]
13:50:09 <lambdabot>   ["TEN","TEN"]
13:50:25 <CaptainK> ok thats gtk
13:50:44 <CaptainK> > [x| x <- ["TEN","THREE"], y <- ["ZEN","TEN"], x == y]
13:50:45 <lambdabot>   ["TEN"]
13:50:55 <mapreduce> (Ord a) => [a] -> [a] -> (a -> a -> a) -> [a]
13:50:59 <CaptainK> not what I want there
13:51:55 <byorgey> CaptainK: which isn't what you want?  And what do you actually want?
13:52:03 <CaptainK> null
13:52:06 <mapreduce> ignore that, if you didn't already.
13:52:10 <CaptainK> TEN /= ZEN
13:52:20 <byorgey> CaptainK: oh, so you want some sort of zip
13:52:47 <byorgey> a list comprehension is going to consider all possible pairs
13:52:57 <CaptainK> if there is a match exactly, then "TEN" = "TEN"
13:53:28 <CaptainK> otherwise "TEN" /= "ZEN" make no new list entry
13:53:46 <CaptainK> its matching the length
13:53:46 <hpaste> mapreduce pasted “How can I remove the explicit recursion in diff?” at http://paste.tryhaskell.org/90635
13:54:06 <geekosaur> no it is not
13:54:07 <byorgey> others who searched for this function also bought: zip, zipWith, filter, catMaybes
13:54:17 <geekosaur> CaptainK, it's not matching the length
13:54:25 <geekosaur> it's considering all possible matches *regardless of position*
13:54:44 <geekosaur> it is not matching TEN against ZEN, it is matching the TEN in the first list against the TEN in the second
13:54:58 <byorgey> [ (x,y) | x <- ["TEN","THREE"], y <- ["ZEN","TEN"] ]  -- CaptainK, what do you think this will print?
13:55:00 <geekosaur> *regardless of position*, because that is how list comprehensions and the list monad work
13:55:33 <CaptainK> ("TEN","ZEN")
13:55:45 <byorgey> > [ (x,y) | x <- ["TEN","THREE"], y <- ["ZEN","TEN"] ]
13:55:46 <lambdabot>   [("TEN","ZEN"),("TEN","TEN"),("THREE","ZEN"),("THREE","TEN")]
13:56:05 <CaptainK> got it, so this is not where I can compare
13:56:15 <CaptainK> need to do that elsewhere
13:56:16 <byorgey> on the other hand:
13:56:30 <byorgey> > zip ["TEN","THREE"] ["ZEN","TEN"]
13:56:31 <lambdabot>   [("TEN","ZEN"),("THREE","TEN")]
13:56:34 <S_J> http://www.infoq.com/interviews/Erlang-Haskell-John-Hughes <- read about quickcheck and race conditions, very interesting!
13:56:45 <S_J> well it doesnt sya much but the concept is interesting
13:57:02 <CaptainK> ok, will think about this and come back later after I have hopefully a better understanding
13:57:13 <elliott> S_J: you already linked that in here... :)
13:57:18 <CaptainK> thanks!
13:57:52 <hpc> S_J: my favorite part is when the "full page transcript" link doesn't work without javascript
14:06:03 <pentace> Hi! Can anyone tell me what's the difference between the MonadBase and MonadTrans classes (from package transformers-base)?
14:06:31 <mapreduce> I'd like to be able to iterate in order over two sorted lists, somewhat like a full outer join in SQL.. how could I do that?
14:07:11 <napping> why do you say sorted?
14:07:51 <mapreduce> Because doing this over two sorted lists should be cheaper than over unsorted, and I can easily sort my data.
14:08:08 <byorgey> mapreduce: can you give a simple example?  I'm not sure I understand.
14:09:45 <mapreduce> For two lists [1,3,4] and [2,3,5] I'd process (Just 1, Nothing), then (Nothing, Just 2), (Just 3, Just 3), (Just 4, Nothing), (Nothing, Just 5)
14:09:47 <pentace> You can merge them and iterate over the final list, no?
14:10:27 <mapreduce> For the slightly less simple real case each element is actually a key-value tuple, which is why I care about treating the two sides separately.
14:12:06 <Botje> mapreduce: write a merge function that inspects the two list heads and does something sensible
14:12:18 <mapreduce> A custom merge should do the job, yes.
14:12:56 <dropdrive> Is there a GHC extension that enables the use of "mkt" in this piece of code: http://gergo.erdi.hu/blog/2012-12-01-static_analysis_with_applicatives/ (bottom snippet)
14:13:16 <napping> I don't know a library providing that for lists, but Data.Map has some functions like that
14:13:54 <mapreduce> (Ord a) => [(a,b)] -> [(a,b)] -> [(Maybe (a,b), Maybe (a,b))]
14:14:08 <Botje> dropdrive: you mean the mkt which is bound in the do bloc kabove?
14:14:10 <mapreduce> napping: Yeah, I'm not especially tied to lists.  I'll take a look at Data.Map, thanks.
14:14:12 <Botje> dropdrive: I think that's a typo.
14:14:19 <dropdrive> Botje: Yes, okay, thanks.
14:14:41 <napping> mergeWithKey (\_ a b -> Just (Just a, Just b)) (map (\a -> (Just a,Nothing))) (map (\b -> (Nothing,Just b)))
14:19:36 <dropdrive> Botje: Does the use of \mu \alpha in the definition of runP require any GHC extensions?  I'm getting "Not in scope: type variable `a'"
14:20:52 <Botje> dropdrive: i'm not that familiar with GHC extensions, sorry.
14:21:10 <Botje> you can try adding the a to the forall, but i'm not sure if that's correct
14:24:01 <johnw> napping: heh, I've seen that code before
14:24:31 <johnw> napping: for GHC 7.4, you can use this: y
14:24:32 <johnw> https://gist.github.com/5904762
14:25:09 <merijn> StateT requires Monad to be an applicative? :(
14:25:17 <johnw> it does?
14:25:28 <merijn> (Functor m, Monad m) => Applicative (StateT s m)
14:25:34 <johnw> huh
14:25:35 <Gracenotes> o nos
14:25:42 <merijn> Who is responsible for this abomination? :(
14:25:53 <johnw> merijn: you can always use MonadApply
14:25:53 <Taneb> merijn, I think it's necessary
14:26:02 <hpc> the entire mtl assumes that 'm' is another Monad
14:26:05 <startling> merijn, yeah, that bugged me too! pretty sure it's necessary though
14:26:12 <merijn> hpc: ReaderT works with just Applicative
14:26:24 <elliott> it will be fixed once Applicative => Monad
14:26:30 <merijn> WriterT only requires Applicative too
14:26:30 <elliott> as recently passed
14:26:38 <startling> merijn: in any case, I spent an hour trying to figure it out and then asked here and no one cared
14:27:16 <Taneb> @djinn (a -> m a) -> (m (a -> b) -> m a -> m b) -> (s -> m (a -> b, s)) -> (s -> m (a, s)) -> s -> m (b, s)
14:27:16 <lambdabot> -- f cannot be realized.
14:30:05 * hackagebot swish 0.9.0.3 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.3 (DouglasBurke)
14:30:13 <startling> @mtl (a -> m a) -> (m (a -> b) -> m a -> m b) -> (s -> m (a -> b, s)) -> (s -> m (a, s)) -> s -> m (b, s)
14:30:13 <lambdabot> Maybe you meant: url unmtl pl msg
14:30:23 <startling> aw, there's no @mtl?
14:31:21 <startling> @unmtl StateT s m (a -> b) -> StateT s m a -> StateT s m b
14:31:21 <lambdabot> StateT s m (a -> b) -> StateT s m a -> StateT s m b
14:31:38 <startling> aw, @unmtl doesn't do functions?
14:31:39 <Hafydd> We need @ununmtl
14:31:50 <startling> lambdabot is full of disappointments today
14:32:25 <johnw> don't listen to them, lambdabot
14:32:40 <Gracenotes> IdentityT (IdentityT (IdentityT (IdentityT (IdentityT (IdentityT (IdentityT (IdentityT (IdentityT ( ...
14:33:11 <startling> > fix ("IdentityT (" ++)
14:33:12 <lambdabot>   "IdentityT (IdentityT (IdentityT (IdentityT (IdentityT (IdentityT (Identity...
14:33:19 <S_J> whats up with hpaste?
14:33:35 <S_J> any work on porting haskell to some cool platforms like android?
14:33:37 <banister> mauke: do u think Zhivago is a meanie
14:33:50 <startling> S_J, ARM support sucks right now
14:35:04 <Gracenotes> I've wondered, do people want Haskell for game logics and stuff? Or to do top-to-bottom-of-stack mobile development in Haskell?
14:35:15 <Gracenotes> I expect that one is easier than the other.
14:35:51 <startling> I think mostly they don't want to write Java.
14:36:28 <joehillen> you can write android apps in clojure, that's about as good as it gets
14:36:45 <josephle> shouldn't you be able to write android apps in scala?
14:36:54 <josephle> that would be closer to haskell than clojure
14:37:16 <joehillen> maybe, I haven't heard of anyone doing it yet though
14:37:21 <Gracenotes> Dalvik, like JVM, has security models and stuff.
14:37:24 <mapreduce> Yes, that is doable.
14:37:39 <mapreduce> Scala on Android.
14:37:59 <Gracenotes> creating code on the fly was a problem for a while
14:38:12 <joehillen> scala's syntax makes me cry
14:38:21 <startling> I'm surprised no one has played with compiling directly to dalvik bytecode
14:39:02 <merijn> hmm, maybe StateT does require monad...now I'm sad :(
14:39:10 <startling> merijn: yeah. :(
14:39:35 <merijn> I need an Applicative that lets me generate unique names...
14:40:32 <merijn> Surely that should be possible...you can do it in IO and IO is an Applicative...
14:40:42 <johnw> merijn: does the bound library provide that?
14:41:02 <startling> merijn: can you do it with reader and use local?
14:41:40 <merijn> startling: I don't think so? Not without dramatically dirtying up the code, at least
14:42:30 <merijn> johnw: Maybe? I can't tell, it seems to have pre-lens edwardk documentation :p
14:42:46 <startling> merijn: yeah, it'd be ugly
14:42:51 <tgeeky> merijn: nope, bound was the one that started his new docs style
14:43:08 <Demos> by new docs style do you mean having docs?
14:43:11 <S_J> http://ideone.com/YbFFuk <- Do you think that ois to verbose to use? (QuickCheck in C.) It is not finished yet though but the verbosity will probably stay the same.
14:43:27 <merijn> The first few lines of bound say "monad" and awful lot...
14:47:24 <alogic0> @run
14:47:25 <lambdabot>   not an expression: `'
14:48:06 <alogic0> @run let x=4
14:48:07 <lambdabot>   not an expression: `let x=4'
14:49:34 <alogic0> @run 2+5
14:49:35 <lambdabot>   7
14:51:16 <merijn> Bah, looks like State can be used as just an Applicative, but StateT can't
14:51:42 <merijn> I guess that's due to the inability to get the state out through the Applicative
14:52:20 <S_J> isnt generic programming super easy in haskell? why does john hughes say:  If you do generic programming in Haskell, you can write a paper about it.
14:52:59 <alogic0> '>' head "Haskell"
14:53:20 <carter> elliott how do i tell lambdabot to remebmer stuff?
14:53:25 <elliott> > head "Haskell"
14:53:26 <lambdabot>   'H'
14:53:32 <elliott> carter: in what sense?
14:53:36 <elliott> adding a quote?
14:53:38 <carter> ys
14:53:40 <carter> yes
14:53:43 <elliott> "@remember name text"
14:53:46 <carter> k
14:53:57 <elliott> and you have to do it in #haskell if you want it in HWN
14:54:00 <S_J> @remember carter is a haskell guru
14:54:01 <lambdabot> It is forever etched in my memory.
14:54:08 <carter> lies
14:54:12 <S_J> @lambdabot carter
14:54:12 <lambdabot> Unknown command, try @list
14:54:17 <carter> only gave my first haskell talk last month
14:54:19 <merijn> taruti: local won't work either, the local function requires Monad
14:54:20 <elliott> @forget carter is a haskell guru
14:54:20 <lambdabot> Done.
14:54:21 <merijn> eh
14:54:22 <elliott> carter never said that :p
14:54:26 <carter> true
14:54:29 <S_J> how do you query him?
14:54:30 <sipa> he has his owm rather uncommon definoition of forever
14:54:32 <Gracenotes> "Is a Haskell guru" --Carter
14:54:34 <merijn> eh
14:54:43 <merijn> s/taruti/startling
14:54:46 <carter> @quote elliot
14:54:46 <lambdabot> elliott says: <edwardk> elliott: now its almost exactly like one of my packages ;)  <elliott> edwardk: no, i'm writing documentation
14:54:54 <carter> hehehe
14:55:00 <S_J> @quote carter
14:55:00 <lambdabot> No quotes match. I am sorry.
14:55:37 <Gracenotes> S_J: that was also in the context of comparing Haskell to Erlang, yes
14:55:47 <Gracenotes> Erlang is dynamically typed, so you can do what you want
14:56:02 <S_J> @quote Hughes
14:56:02 <lambdabot> blackdog says: <kristnjov> QuickCheck is god * earthy thinks kristnjov has a *weird* religion <kristnjov> it's called hughes-ism <kristnjov> a bit new age <blackdog> this y combinator, which was
14:56:02 <lambdabot> given to you for the recursion of sins <earthy> lead me not into global state <blackdog> yea, though I should walk in the valley of imperative code, I shall fear no evil, for your monad comforts me
14:56:02 <lambdabot> still
14:56:08 <Gracenotes> To do anything interesting in Haskell, you have to structure it in the context of the type system. Doing heterogeneous stuff is hard.
14:56:27 <S_J> @quote SPJ
14:56:27 <lambdabot> SPJ says: will be a legend after his death
14:56:36 <S_J> SPJ ever here?
14:56:41 <carter> nope
14:56:45 <carter> and ttyl all
14:56:50 <merijn> argh
14:56:53 <elliott> @forget SPJ will be a legend after his death
14:56:53 <lambdabot> Done.
14:56:56 <elliott> lotsa non-quotes
14:57:17 <Gracenotes> Suppose you have a tree of handlers; having handlers' types determined by their position in the tree is not so fun
14:57:27 <Gracenotes> this may be common with things like routing in webapps
14:57:38 <merijn> Help me, #haskell, you're my only hope! I need an applicative transformer to do unique name generation, please don't tell me I'm screwed :(
14:57:51 <elliott> merijn: Free ((->) Name)
14:57:54 <elliott> well, FreeT.
14:58:08 <Gracenotes> It is trivial to do in e.g. Python
14:58:10 <elliott> maybe you'll need to write your own version of it if the instance requires Monad but that should be easy.
14:58:30 <merijn> elliott: Where's that from?
14:58:35 <elliott> free package
14:58:38 <elliott> but it's just
14:58:50 <elliott> data Supply s a = Done a | More (s -> Supply s a)
14:59:04 <S_J> Only thing I dont like about haskell is I find most datastructures to be cumbersome to use except for lists
15:00:09 <Gracenotes> you mean, you want to clutter up the language with lots of ad-hoc ways to create data structures? :)
15:00:17 <merijn> elliott: Hmm, the Applicative of that seems to require Monad too
15:00:32 <devth> is there a function that determines if all elements in a list are distinct? looking for [a] -> Bool
15:00:33 <elliott> merijn: ok, well, it shouldn't inherently, at least for Supply, I don't think.
15:00:46 <hpc> @hackage acme-php -- the stringliest-typed package you will find for haskell
15:00:46 <lambdabot> http://hackage.haskell.org/package/acme-php -- the stringliest-typed package you will find for haskell
15:00:53 <elliott> devth: all (== head xs) xs -- this works even if xs is empty because of non-strictness
15:01:13 <devth> elliott: thanks
15:01:15 <Gracenotes> Eq a => [a] -> Bool, ...and also, I'm not sure if that's exactly it elliott
15:01:34 <elliott> ?
15:01:52 <merijn> elliott: I'm not sure how Supply fits into my problem, though? Does it just one extra "s ->" in front for every thing you use?
15:01:59 <Gracenotes> don't you want something more like: any ((>1) . snd) . groupBy fst . map (head &&& length) . sort
15:02:14 <elliott> merijn: yes
15:02:20 <elliott> merijn: you can write supply :: Supply s s
15:02:24 <elliott> and then e.g.
15:02:28 <elliott> liftA2 (,) supply supply
15:02:31 <Gracenotes> hm, not quite that... I used the arrows in the wrong place...
15:02:31 <elliott> gets two names and stuffs 'em in a tuple
15:02:35 <Gracenotes> but you get the drift
15:02:37 <elliott> and you can feed it from a list, IO, etc.
15:02:49 <elliott> Gracenotes: oh wait
15:02:52 <elliott> I misread devth's problem.
15:02:58 <elliott> it's the opposite of the problem I solved.
15:03:09 <mm_freak_> is there a package for spherical geometry?
15:03:13 <devth> just realized that :)
15:03:41 <mm_freak_> ideally with a numerically stable implementation of sphere distance =)
15:04:05 <Gracenotes> change 'groupBy fst . map (head &&& length)' into 'map (head &&& length) . group'
15:04:24 <Gracenotes> or get rid of 'head' altogether
15:05:23 <johnw> elliott: all (== head xs) xs, doesn't that just test that every element of xs is the same as the first element?
15:05:34 <elliott> it tests that all elements of xs are equal. not distinct
15:05:37 <devth> length xs == length (nub xs)
15:05:45 <johnw> ah
15:05:54 <Gracenotes> if you don't like sorting and prefer O(n^2) time, i.e. smaller lists, '(==) <$> nub' will do it for you
15:06:05 <merijn> :t liftA2
15:06:05 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:06:43 <Gracenotes> or length first. whatever you like :) My muttering have no warranty
15:06:55 <merijn> elliott: It seems like it'd be rather convoluted to use Supply, though...unless I'm missing something (which I might be)
15:07:24 <shachaf> I,I (S.toList . S.fromList) xs == sort xs
15:07:28 <Gracenotes> also, s/<$>/<*>/... stuff
15:07:45 <elliott> merijn: well, I'm not sure how. you can think of it as an opaque monad with one operation, supply :: m Name.
15:07:52 <elliott> that's about as simple as an API can get.
15:07:55 <shachaf> Or ((==) `on` length), of course.
15:07:56 <merijn> elliott: Yes, but I don't have a Monad
15:08:03 <elliott> ok, ok, an opaque applicative, sheesh :)
15:08:14 <johnw> shachaf: what does "I,I" ?
15:08:17 <johnw> mean?
15:08:21 <shachaf> It looks like an owl face to me.
15:09:15 <merijn> elliott: I'm not seeing how it fits as a replacement for StateT, but maybe I need to stare at it more...
15:09:17 <johnw> what does the owl signify here?
15:09:24 <Gracenotes> surely the miracle of unicode could produce a more convincing owl
15:09:40 <Gracenotes> ...hth
15:09:41 <elliott> merijn: well, you know, you could use StateT too.
15:09:44 <elliott> you just have to write your own instance.
15:09:48 <elliott> (and newtype wrapper.)
15:10:09 <shachaf> Gracenotes: It's hard to get more convincing than that.
15:10:19 <merijn> elliott: See, I just tried that, I don't think it's possible
15:10:36 <elliott> I find that unlikely... but anyway Supply would be easy to use.
15:10:42 <merijn> Which would explain why ReaderT and WriterT have an Applicative instance, but StateT only has Monad
15:10:50 <elliott> you have an action, newName :: Blah Name; newName = do { foo <- get; ...; put foo'; return name }, right?
15:10:52 <Gracenotes> not: I‸I?
15:10:58 <elliott> and use that all over the place.
15:11:05 <elliott> except not do because it's only an Applicative blah blah blah you get the point
15:11:32 <merijn> @unmtl StateT Int Foo a
15:11:32 <lambdabot> Int -> Foo (a, Int)
15:11:48 <Gracenotes> θ꘍θ
15:11:50 <merijn> elliott: How do you get the Int out of the "Foo (a, Int)" if Foo is not a monad?
15:12:12 <ion> unFoo
15:12:20 <elliott> merijn: with <*>? but hmm.
15:12:20 <hpc> unsafeCoerce
15:12:21 <merijn> ion: Which doesn't exist for Applicative
15:12:23 <elliott> anyway you should use Supply it's great.
15:12:41 <Demos> you pattern match right?
15:13:18 <merijn> Demos: That requires the ability to pattern match
15:14:23 <monochrom> perhaps Foo may be yet another StateT. who knows.
15:14:42 <elliott> perhaps it is StateTs all the way down.
15:14:49 <elliott> oh that sounds interesting.
15:14:54 <monochrom> StateT Int (StateT Bool) a. how do you pattern-match StateT Bool?
15:16:40 <merijn> elliott: "(Monad m, Functor m) => Applicative (SupplyT s m)"
15:16:57 <elliott> merijn: I am not talking about any existing Supply on hackage.
15:17:07 <elliott> I know there is at least one package that gives that name to a stupid type.
15:24:07 <S_J> what is that site where you can publish papers called, where the crazy russian publised his millenium award winning paper
15:24:42 <Gracenotes> arxiv?
15:24:52 <Gracenotes> just making a guess.
15:25:52 <S_J> you cant read a pdf with readFile right?
15:25:54 <merijn> What's the best way to check whether a module name is still free on hackage?
15:26:16 <elliott> sure you can.
15:26:28 <Demos> S_J, you can, but you wont just get the contained text
15:26:37 <geekosaur> S_J, in what sense? it's an ordinary file (except in some cases on OS X) but it's not going to be partiuclarly intelligible; you need a PDF library for that
15:26:52 <Demos> it could also be compressed I think
15:27:02 <geekosaur> yes
15:27:21 <geekosaur> which makes it only slightly less intelligible...
15:27:22 <merijn> Anyone?
15:27:33 <Gracenotes> merijn: google :x
15:27:47 <merijn> Gracenotes: That seems...inefficient
15:27:48 <geekosaur> merijn, try searching for the module name on hayoo?
15:27:55 <merijn> I don't want to accidentally clobber someone's module name
15:27:56 <elliott> isn't hayoo down?
15:28:09 <geekosaur> back up as of yesterday sometime
15:28:19 <elliott> cool
15:28:31 <geekosaur> er, actually this morning sometime. I've used it a couple times today anyway
15:28:36 <Demos> geekosaur, lol, yeah I hear PDF is a mess
15:29:08 <S_J> is there a strip function? Like remove '.' from "essays." ?
15:30:54 <Gracenotes> left strip easier than right strip. singly-linked lists have a directional bias for text processing...
15:36:31 <hxn1248> What about takeWhile?
15:38:55 <S_J> strip c s = filter (/= c) s; stripAll cs s = foldl (\s c -> strip c s) cs s; why does stripAll result in stripAll ".,!?" "!?,essays." -> "" when i want it to return "essays"?
15:39:13 <merijn> elliott: Thanks, I think the Supply approach does indeed work (although I'm not sure how efficient it'll be)
15:39:24 <elliott> merijn: well, it's about as efficient as it can be :p
15:39:30 <elliott> the whole logic is driven by whatever runs the Supply
15:40:09 <merijn> Now I just need to come up with a name and dump it on hackage :p
15:41:16 <elliott> for what?
15:42:54 <merijn> elliott: The implementation of said transformer, I need it in multiple things already, seems silly to reimplement it every time
15:43:17 <S_J> > lower "HelLo"
15:43:18 <lambdabot>   Not in scope: `lower'
15:43:18 <lambdabot>  Perhaps you meant `P.lower' (imported from Text.Pars...
15:43:29 <S_J> > toLower "HelLo"
15:43:30 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:43:31 <lambdabot>              with actual type...
15:43:39 <S_J> > map toLower "HelLo"
15:43:40 <lambdabot>   "hello"
15:43:46 <ion> > Text.toLower . Text.pack $ "HelLo"
15:43:47 <lambdabot>   Not in scope: `Text.toLower'Not in scope: `Text.pack'
15:43:51 <ion> > T.toLower . T.pack $ "HelLo"
15:43:52 <lambdabot>   Not in scope: `T.toLower'Not in scope: `T.pack'
15:43:52 <lambdabot>  Perhaps you meant `BS.pack...
15:44:03 <tabemann> opinion question
15:44:04 <ion> > Data.Text.toLower . Data.Text.pack $ "HelLo"
15:44:04 <lambdabot>   Not in scope: `Data.Text.toLower'
15:44:05 <lambdabot>  Perhaps you meant `Data.Char.toLower' (i...
15:44:08 <ion> le sighe
15:44:31 <tabemann> when writing a reverse routine, is it faster to break out, say, chunks of values to be reversed at a time of, say, 5, or to only reverse one at a time?
15:45:02 <S_J> can you read a file as a bytestring instead? more efficient?
15:45:15 <anshul> i got the following error when I switched from 6.12.3 to 7.6.3 ("user error" (Text.Regex.Posix.String died:(ReturnCode 12, "memory exhausted)))
15:45:19 <anshul> any ideas?
15:45:38 <tabemann> you can write files with bytestrings, and it is faster, but bytestrings do not have proper unicode support and hence should not be used for text
15:48:50 <tomboy64> i want to print a couple of strings with putStr via mapM_ and then have the function return True
15:49:12 <ion> mapM_ …; return True
15:49:15 <ion> True <$ mapM_ …
15:49:17 <tomboy64> i tried to put that in a do block and with >>
15:49:27 <tomboy64> hm
15:50:28 <ion> ByteStrings aren’t supposed to “have Unicode support”, “proper” or not. They are not a representation of text.
15:51:08 <tomboy64>  mapM_ (\x -> putStr((show x) ++ " <-> ")) (init b);
15:51:09 <tomboy64>  >> putStr((show (last b)) ++ "\n")
15:51:11 <tomboy64>  return True
15:51:24 <tomboy64> erm, the 2nd line is commented out
15:51:37 <ion> Paste the full code and the full error message.
15:51:41 <tabemann> ion: I said "proper" because someone created ByteString.Char8, which is "meant" to be used for text, but from what I hear it's deprecated due to not being able to support Unicode
15:51:42 <ion> In hpaste
15:52:06 <tomboy64> line 42-46: http://bpaste.net/show/111266/
15:52:37 <ion> tomboy64: There’s a “do” missing. “then do …”
15:53:30 <tomboy64> ion: when i put the do back, i get http://bpaste.net/show/111268/
15:55:40 <ion> tomboy64: The function’s return type is Bool, but you’re trying to return an IO action. Are you sure you need to print values from within the function?
15:56:23 <tomboy64> ion: actually i am. hm. gonna try debug.trace.
15:56:50 <ion> tomboy64: For temporary debugging, Debug.Trace is fine.
15:57:37 <ion> But if you’re going to leave that code in, either make the entire thing an IO action or just return the information you want to print and print it from the outside.
15:57:50 <ion> The latter is preferable.
15:58:27 <augur> is there a totality checker language extension available?
16:00:49 <Demos> errr, would that not be somewhat problematic? I bet there are some that will output yes/no/maybe though
16:01:42 <Gracenotes> augur: termination?
16:01:49 <augur> Gracenotes: no just totality
16:02:02 <Gracenotes> (checking for bottom in other forms is usually pretty easy... safe haskell etc.)
16:02:04 <augur> i want to ensure my patterns are exhaustive
16:02:34 <Gracenotes> well, Safe Haskell.
16:02:48 <ion> augur: Doesn’t GHC do that with -Wall?
16:02:59 <augur> ion: dunno!
16:03:04 <augur> thats why im asking :)
16:03:08 <c_wraith> it does
16:03:16 <c_wraith> Though it has issues with GADTs
16:03:16 <elliott> merijn: well, a good name would be supply.
16:03:36 <c_wraith> It will tell you about missing cases that the type makes impossible
16:04:02 <c_wraith> Because the exhaustiveness checker just checks for coverage of all the constructors - it doesn't consider the types.
16:04:41 <augur> is there a way to get this as a LANGUAGE option?
16:04:45 <augur> is it just Wall?
16:04:56 <augur> nope, seems not :(
16:05:02 <c_wraith> you could do {-# OPTIONS_GHC -Wall #-}
16:05:13 <c_wraith> But really, that sort of thing belongs in your .cabal file
16:05:29 <ion> Yeah, just use ghc-options: -Wall in your .cabal file.
16:06:08 <augur> c_wraith: that works well for me actually
16:06:24 <augur> im writing this thing in textmate, and using that givesme the right behavior i want :)
16:06:35 <merijn> elliott: I actually don't think Supply works very well for the transformer? As it's a thing that is being supplied, not something that supplies
16:07:06 <elliott> merijn: it's the supply monad in the same way the state monad is the state monad.
16:07:09 <elliott> it gives you a supply
16:07:34 <c_wraith> Hmm.  It doesn't seem like it should be that hard to make the exhaustiveness checker work better with GADTs.  I suppose no one's felt the need to improve it.
16:08:35 <merijn> elliott: There's about a billion different modules/packages with a Supply type, though. Most of them unrelated
16:08:38 <c_wraith> I guess it does involve type-checking logic in the exhaustiveness checker.  I can see that being potentially annoying.
16:08:54 <elliott> merijn: ok, but all of them but this one are wrong.
16:09:12 <elliott> I'm sure State isn't an unpopular name either -- or wouldn't be if the monad didn't exist
16:10:04 <merijn> Data.Supply is already taken :\
16:10:26 <merijn> Time to claim Control.Supply, I guess
16:12:26 <frankbro> http://hastebin.com/luniyadife.vbs anyone can help me figure out whats wrong with line 18 : parse error on input `put'
16:12:39 <Gracenotes> maybe you can get a business partner to Control.Demand
16:12:59 <merijn> frankbro: No do notation inside your then clause
16:13:12 <frankbro> oh so it doesnt spread within?
16:13:13 <merijn> frankbro: You need to start a new do block for the then and else clauses
16:13:19 <merijn> frankbro: Nope
16:13:38 <merijn> frankbro: Good news, in your case just adding " do" after the then and else should be enough
16:13:45 <frankbro> ah perfect, thank you very much
16:14:19 <ion> frankbro: If you’re using RandomState, you shouldn’t need to touch gen values at all. That’s the point of State.
16:15:01 <frankbro> but it's changing, I need to keep it updated within it dont I ?
16:15:28 <ion> Replace each “do { get <- get; let { (a, gen') = runState foo gen }; put gen' }” with “foo”.
16:15:41 <ion> Well, a <- foo
16:16:08 <elliott> frankbro: .vbs??
16:16:13 <frankbro> really? jesus christ thats gonna help readability a lot :I
16:16:18 <elliott> merijn: it should be Control.Monad.Supply, I think.
16:16:21 <elliott> since it's most useful as a Monad.
16:16:38 <frankbro> elliott, hastebin assign a file ending automatically, no idea how its determined but hpaste wasnt loading
16:16:50 <merijn> elliott: No, I think it's actually a bit useless as a Monad
16:16:50 <elliott> hpaste has a new url
16:16:54 <ion> elliott: Didn’t you hear? SPJ got Bill to replace VBScript with Haskell.
16:16:58 <elliott> merijn: uh... I beg to differ
16:17:03 <merijn> If yu have a monad you could just use State...
16:17:08 <frankbro> so its not .org now?
16:17:11 <elliott> yeah and you could just use State instead of Writer too
16:17:21 <elliott> except with Supply you can supply from e.g. an infinite stream, or user input, or an RNG
16:17:28 <elliott> or suspend it and get a continuation etc.
16:20:45 <tomboy64> is someone aware of a module/function that is able to figure out a specific sum, given the summands?  e.g. i have a number 34567 and a list of a dozen terms - and it gives me the terms that (added up) would give that sum?
16:21:56 <Demos> tomboy64, foldl
16:21:59 <Gracenotes> sounds a bit discrete-knapsack-y
16:22:39 <Gracenotes> so, you'd be looking for solvers for the knapsack problem, if any solutions exist for your input.
16:23:03 <Gracenotes> although making it exact rather than maximum might make it more tractable? I'm not sure
16:23:13 <merijn> Since "get" and "ask" are taken, I should just use "beg" :p
16:23:27 <merijn> Or maybe "demand"
16:23:41 <merijn> Actually, I think I like demand...
16:23:42 <elliott> demand is nice if the monad is called Supply.
16:23:49 <elliott> also you should have a MonadSupply class and stuff.
16:23:56 <elliott> all that stuff I was going to do when I wrote my versino.
16:23:57 <tomboy64> Demos: i think you misunderstood my problem
16:23:57 <elliott> on.
16:24:36 <Demos> tomboy64, yes I am, I did not read closely enough
16:24:41 <Gracenotes> tomboy64: http://en.wikipedia.org/wiki/Knapsack_problem#Subset-sum_problem
16:24:41 <tabemann> opinion question: I've got a function named mapToLazy, which maps a strict list over a function to a lazy list - should I just make it work on one cons cell at a time, or should I pattern match it to, say, handle up to five cons cells per "cycle"
16:25:07 * hackagebot GLUtil 0.6.4 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.6.4 (AnthonyCowley)
16:25:09 * hackagebot ty 0.1.2 - Typed type representations and equality proofs  http://hackage.haskell.org/package/ty-0.1.2 (ConalElliott)
16:25:56 <tomboy64> Gracenotes: that is a pretty accurate description, yes
16:26:01 <tomboy64> :-D
16:26:14 <Gracenotes> tabemann: since the lazy list will be built up cons-cell-by-cons-cell as-needed anyway, it would seem beneficial for each closure that produces such a cell be on the smaller side.
16:27:07 <Gracenotes> unrolling does not have the same direct benefits as in some imperative languages; for one, there is no guarantee the loop processing the list will be 'tight' anyway.
16:27:30 <tabemann> Gracenotes: that's what I'm thinking - I've been converting some of my *strict* list-producing functions to group cons cells into fives
16:28:37 <tabemann> particularly my map routine, where I do a stack-consuming iteration over a strict list in fives, particularly doing so then to save stack space while still using it, until I hit a ceiling of the number of iterations I will do that for and switch to produce-a-mapped-strict-list-in-reverse-and-then-reverse it
16:31:33 <merijn> elliott: Right now I'm thinking to have a runSupplyT that takes "s -> s" and an initial 's' and another that takes a list, having a typeclass for it seems overkill? Unless you think there's a use case for that
16:31:50 <elliott> merijn: the typeclass is for "demand". a la MonadState
16:32:07 <merijn> Yeah, that one is "obvious"
16:32:23 <elliott> so you can use it in transformer stacks.
16:32:35 <elliott> btw, another good run one is (m s) for a monad m
16:33:14 <merijn> elliott: Right, I guess maybe a typeclass for that might be good afterall
16:34:14 * elliott is confused about what "that" is
16:34:20 <merijn> i.e. "Source a" so you can have "runSupplyT :: Source src s => SupplyT s f a -> src -> f a"
16:34:25 <elliott> oh. ew
16:34:37 <elliott> that would be ugly. and it'd have awful overlapping instances like (m s)
16:34:56 <elliott> I would just make runSupplyT the field.
16:34:59 <merijn> elliott: Yeah, but there's only so many names based on "runSupplyT" I can come up with :p
16:35:08 <elliott> and then e.g. runSupplyTList, runSupplyTAction, etc.
16:35:46 <merijn> elliott: It's not a newtype atm, since it has two constructors, so having a field seemed silly
16:36:08 <elliott> oh, well... I guess two constructors works
16:36:35 <merijn> I have supply/supplyT to construct values atm
16:36:54 <elliott> the FreeT way to do it would be SupplyT s m a = m (SupplyF s (SupplyT s m) a) where SupplyF s f a = Pure a | Free (s -> f (SupplyF s f) a)
16:36:59 <elliott> or something.
16:37:12 <elliott> actually, no. the two constructor way is totally broken
16:37:12 <merijn> Although I'my not entirely sure I'm happy with those
16:37:19 <merijn> elliott: Oh?
16:37:22 <elliott> because "lift" takes a value off the supply stream
16:37:28 <elliott> or, what are your constructors?
16:37:41 <merijn> data SupplyT s m a = Done (m a) | More (s -> SupplyT s m a)
16:37:54 <elliott> oh.
16:37:57 <elliott> that's wrong in a different way.
16:38:02 <elliott> now you can't interleave actions in "m" with supplies
16:38:18 <elliott> in fact, I don't think you can even do a demand + Monad instance for that...
16:38:28 <shachaf> GHC has this monad.
16:38:31 <elliott> do { a <- supply; lift $ print (); b <- supply; ... }
16:38:39 <merijn> elliott: What would you have in mind then?
16:38:42 <elliott> ^ let's say you're supplying from getLine
16:38:51 <merijn> elliott: Anything else is broken as an Applicative transformer
16:38:52 <elliott> obviously the () should be printed between getting two lines
16:38:55 <shachaf> Wait, no, it has the opposite -- a monad for producing a stream, not consuming one.
16:39:15 <merijn> Well, "anything else" might be a broad statement
16:39:15 <elliott> merijn: well, you could add another constructor for lift, is the simplest way.
16:39:19 <elliott> and remove the m from Done.
16:39:21 <merijn> But I'm curious what you had in mind
16:39:31 <bigs> i know i'm late to the party but this is reminiscnet of an exercise from RWH
16:39:34 <shachaf> It has newtype Stream m a b = Stream { runStream :: m (Either b (a, Stream m a b)) }, which is just FreeT (a,), I guess.
16:40:06 <shachaf> So presumably you could make Foo m a b = Foo { runFoo :: m (Either b (a -> Foo m a b)) }?
16:40:14 <elliott> merijn: precisely FreeT ((->) s)
16:40:16 <merijn> elliott: I could just do "Pure" and use pure/return for whatever you want
16:40:18 <elliott> from the free package
16:40:26 <elliott> ?
16:40:27 <shachaf> Which is FreeT (a ->), yes.
16:40:56 <merijn> Free has Monad baked in everywhere, afaict
16:41:14 <merijn> At least, my very lazy glance at it showed that
16:42:11 <elliott> I am not saying you should copy its instances.
16:44:43 <merijn> elliott: FreeT uses Monad to do that, though...
16:45:01 <S_J> I want to make Markov chain text generator. So I make a Map of words->(word,count). i.e. every word should have a Map of the words that has appeared after it and a count of how many times. Is there some neat fnction for this in Map, i cant figure out if some applies.
16:45:11 <elliott> can't it be done with just an Applicative if you only want an Applicative instance? my intuition says yes but I haven't tried
16:45:17 <merijn> Maybe that's not necessary
16:45:19 <merijn> hmmm
16:46:46 <merijn> Well, free is by edwardk, I can't imagine him providing a less than maximally general instance if one is possible
16:46:59 <elliott> well he prefers Monad constraints for transformers I think
16:47:09 <elliott> since we don't have Applicative => Monad yet
16:47:30 <merijn> "runFreeT :: m (FreeF f a (FreeT f m a))" <- this requires you to have a way to get something out of m to implement <*>
16:47:44 <elliott> yes... that way is (<*>)
16:48:08 <merijn> oh, wait...yeah, maybe?
16:48:12 <merijn> blah
16:48:21 <merijn> That type is completely inscrutable >.<
16:52:04 <Peaker> is there a nice "timeIt" combinator for an IO action that returns how long it took?
16:52:07 <bgamari> S_J, you mean like https://gist.github.com/bgamari/5905709
16:53:17 <bgamari> If Map's Foldable instance weren't so damn broken it would be much nicer
16:53:24 <bgamari> but oh well
16:54:03 <tommd> Peaker: How is what you're asking for different from timeItT? http://hackage.haskell.org/packages/archive/timeit/1.0.0.0/doc/html/System-TimeIt.html
16:54:46 <Peaker> tommd, nope, didn't know about it, thanks
16:55:26 <S_J> cant I fmap on an IO String?
16:56:35 <bgamari> S_J, IO has a Functor instance AFAIK
16:57:28 <Peaker> S_J, of course you can
16:57:52 <S_J> yes we can!
16:58:48 <troydm> > fmap (++"Hello ") getLine
16:58:49 <lambdabot>   <IO [Char]>
17:01:12 <ion> > let id :: (Read a, Show a) => a -> a; id = read . show in id (fmap (++"Hello ") getLine)
17:01:13 <lambdabot>   No instance for (GHC.Read.Read (GHC.Types.IO [GHC.Types.Char]))
17:01:14 <lambdabot>    arising ...
17:01:30 <ion> Someone should totally make a Read instance for that, too.
17:02:08 <S_J> bagamari: yeah exactly.
17:03:22 <merijn> elliott: I can't get it to typecheck, I'll bug edwardk tomorrow to see if he can answer the question whether Monad is necessary
17:03:30 <elliott> hehe
17:03:34 <merijn> FreeT seems to use Monad even for its Functor instance
17:03:39 <merijn> Which seems odd
17:05:22 <c_wraith> merijn: that's often done to get around the Monad not being a superclass of Applicative issue
17:05:40 <merijn> c_wraith: I know
17:06:14 <merijn> But right now I've been messing around for like 20 minutes trying to get a seemingly trivial function to typecheck, with no luck
17:11:15 <merijn> Oh well, maybe things will go better after a night's sleep
17:13:54 <imeredith> it seems like aeson and text.json are the 2 main json libs people use?
17:14:28 <c_wraith> aeson is the most common, these days
17:16:29 <acowley> What's the website that shows you information about a hackage package's dependencies and versions and such… and you can search by username
17:16:43 <acowley> I think it was done by Michael Snoyman
17:17:05 <geekosaur> packdeps.haskellers.org?
17:17:21 <imeredith> c_wraith: yeah thats what i thought - im just not so sure about validaiion and error reporting. I see that you can decode to Either String a but that seems very limited - and i guess you cant validate that a field is valid or anything
17:17:42 <acowley> Ah, I think I'm thinking of this: http://packdeps.haskellers.com
17:17:45 <acowley> yes
17:19:50 <geekosaur> oh suffix. what I get for dredging out of memory instead of checking
17:21:29 <Peaker> I thought I fixed pretty' stack overflows, apparently there are more in it :(
17:22:00 <Peaker> -xc is being useless and not saying where the stack overflow is
17:22:01 <acowley> gotta catch 'em all
17:23:04 <Peaker> For some reason he wraps most of the data constructors with ordinary functions
17:23:09 <Peaker> that do nothing -- and are not exported
17:23:33 <Peaker> "nest_ k p = Nest k p"
17:24:30 <Peaker> debugging stack overflows feels pretty primitive
17:24:36 <Peaker> GHC ought to improve on this front
17:30:50 <CaptainK> how do you take ["TEN","ABC"] and ["TEN","ABC"] and have it create a new list ["TEN"] becuase the first two are equal?
17:31:12 <CaptainK> opps the second ["TEN","CBC"]
17:34:10 <CaptainK> > [x| x <-["TEN","ABC"], y<-["TEN","DEF"], x==y]
17:34:11 <lambdabot>   ["TEN"]
17:34:39 <CaptainK> > [x| x <-["TEN","ABC"], y<-["TNN","DEF"], x==y]
17:34:40 <lambdabot>   []
17:34:47 <c_wraith> imeredith: you could add validation to custom FromJSON instances. It may or may not make sense to do so at that level.
17:37:53 <imeredith> c_wraith: right -ill look into it. In scala i've been using more of a basic interface that extracts fields and combining them with either an applicative or Either depending on if i want all errors or the first error, if everything goes ok the ADT instance is emitted ... was looking for something somewhat similar
17:38:59 <imeredith> although it seems like i could do something similar anyway if i wanted with the ast
17:40:55 <byorgey> CaptainK: I suggested before (maybe you missed it) that you might want to take a look at functions like zip, zipWith, and filter
17:42:26 <c_wraith> imeredith: yeah, that's also an option. If you just get the AST directly out of aeson, you can validate it however you like.
17:42:36 <CaptainK> byorgey: thanks looking
17:43:12 <mdedetrich> Im trying to get my head around DerivceGenerics and classes
17:43:19 <mdedetrich> if I had some type like this
17:43:20 <mdedetrich> data SomeType = SomeType Integer deriving (Model)
17:43:50 <mdedetrich> what is the signature when you instance model for that data type
17:43:57 <mdedetrich> *instance Model
17:44:05 <imeredith> c_wraith: i'll use aeson as they intend for now, i dont have any specific requirements as im just learning haskell - thanks for the help
17:44:20 <byorgey> mdedetrich: what is Model?
17:44:57 <mdedetrich> byorgey: https://gist.github.com/anonymous/58912d9546893ff4619a
17:45:23 <acowley> Is there no way to get a GHC 7.6 build on travis-ci yet?
17:46:22 <mdedetrich> so far I just want it to print something with putStrLn when I run new on a data of type SomeType
17:46:29 <byorgey> mdedetrich: you can't put  deriving (Model)  like that
17:46:35 <byorgey> you can say  deriving (Generic)
17:46:50 <byorgey> and then define a default Model instance using the Generic machinery
17:47:17 <mdedetrich> byorgey: is it possible to do something that would be the equivalent of deriving (Model)
17:47:27 <byorgey> if there already is such a default Model instance, then you can just write  data SomeType = ...  deriving (Generic);  instance Model SomeType
17:47:43 <mdedetrich> essentially I want to do something like this
17:47:43 <byorgey> mdedetrich: ^^^
17:48:00 <mdedetrich> data Car = Car {company :: String, model :: String, year :: Int} deriving (Model) for some database schema
17:48:17 <byorgey> acowley: someone was working on it.  but not yet.
17:48:29 <acowley> byorgey: Okay, thanks.
17:48:32 <acowley> bummer
17:48:40 <byorgey> mdedetrich: as I said above, you have to do   data Car = Car ... deriving (Generic);  instance Model Car
17:48:50 <byorgey> but note you do not need any 'where' after  'instance Model Car'
17:49:09 <byorgey> mdedetrich: for that to work, the Model class must be defined with default implementations for its methods which work in terms of Generic
17:49:20 <byorgey> for help on doing that, see http://www.haskell.org/haskellwiki/GHC.Generics
17:49:39 <mdedetrich> byorgey: yeah that is precisely what I am trying to do
17:50:06 <redline6561> Hi, how do I import the instances of Data.Bits defined in Data.Word?
17:50:09 <mdedetrich> just trying to get my head around it
17:50:37 <byorgey> redline6561: just import Data.Word
17:50:49 <redline6561> Okay, was doing it qualified but will do. Thanks byorgey.
17:50:57 <byorgey> redline6561: qualified is fine.
17:51:14 <byorgey> it doesn't matter how you import a module, you always get all the instances it defines.
17:51:23 <redline6561> Hmm. Okay.
17:51:42 <byorgey> redline6561: if you are encountering a particular error, you could paste the code and the error message
17:51:45 <byorgey> @where hpaste
17:51:45 <lambdabot> http://paste.tryhaskell.org/new/haskell
17:53:30 <hpaste> redline6561 pasted “cpu fiddling” at http://paste.tryhaskell.org/90636
17:54:48 <redline6561> byorgey: ghc alleges the & is not in scope ^^
17:55:15 <ion> Then it probably isn’t.
17:55:40 <byorgey> redline6561: can you paste the full error message as well?
17:56:51 <hpaste> redline6561 annotated “cpu fiddling” with “cpu fiddling (annotation)” at http://paste.tryhaskell.org/90636#a90637
17:56:58 <redline6561> Updated.
17:57:31 <byorgey> redline6561: ah, you have to import Data.Bits.
17:57:46 <byorgey> just because some Bits instances are in scope doesn't mean the methods of the Bits class are in scope.
17:57:55 <redline6561> Hmm. Okay. And the inference will know to use the Word8 instances. Got it.
17:58:00 <byorgey> right.
17:58:04 <redline6561> Thanks.
17:58:05 <shachaf> That doesn't account for -- h6502.hs:22:26: Not in scope: `&'
17:58:12 <byorgey> that looks like a paste-o.
17:58:20 <redline6561> Well, I wasn
17:59:01 <ion> (&) isn’t in Data.Bits. There is (.&.) in it, though.
17:59:31 <redline6561> * It is. All fixed up now.
18:00:09 * hackagebot vinyl-gl 0.1.0.0 - Utilities for working with OpenGL's GLSL shading language and vinyl records.  http://hackage.haskell.org/package/vinyl-gl-0.1.0.0 (AnthonyCowley)
18:00:51 <ion> wat
18:01:31 <ion> k. http://hackage.haskell.org/package/vinyl
18:03:27 * byorgey works on a package for working with CUDA and 8-track tapes
18:04:54 * dolio thinks that implicit parameter-based records are obviously the true solution.
18:05:23 <mm_freak_> "vinyl records"
18:05:26 <mm_freak_> very misleading
18:05:59 <dolio> You know, I didn't actually realize that was the pun until just now.
18:06:47 <c_wraith> ...  really?
18:06:53 <dolio> Yeah.
18:07:08 <mdedetrich> byorgey: https://gist.github.com/anonymous/569ac85bf9f09fe92f7f
18:08:02 <haasn> (&) is way more useful than (.&.)
18:08:11 <mdedetrich> im getting this error on line 23
18:08:18 <mdedetrich> byorgey: https://gist.github.com/anonymous/569ac85bf9f09fe92f7f
18:08:20 <mdedetrich> woops
18:08:38 <mdedetrich> Expecting one more argument to `a'
18:08:40 <mdedetrich>     In the instance declaration for `Model (K1 i a)'
18:10:05 <byorgey> mdedetrich: doesn't K1 take 3 type parameters?
18:10:18 <byorgey> mdedetrich: note, I have never actually used GHC.Generics
18:10:27 <byorgey> I am just reading the documentation
18:10:37 <mdedetrich> byorgey: im getting Expecting one more argument to `a'
18:10:38 <mdedetrich>     In the instance declaration for `Model (K1 i a b)'
18:10:48 <mdedetrich> if I add one more type parameter
18:11:08 <acowley> I feel like I take more abuse for the vinyl records pun than Jon does
18:11:24 <byorgey> oh, I'm sorry, Model :: (* -> *) -> Constraint,  so K1 i a  is right
18:12:05 <byorgey> mdedetrich: oh, well, that's why.  Because you have  Model a => Model (K1 i a)
18:12:16 <byorgey> mdedetrich: because of the  Model a  constraint,  a :: * -> *
18:12:24 <byorgey> but the second argument to K1 must have kind *
18:14:25 <acowley> I'm going to write a computer vision library and call it optical-disc
18:15:05 <mdedetrich> byorgey: so how would I implement this (at this point I just want to get a working example, because then I can get my head around it)
18:15:38 <byorgey> mdedetrich: I don't know, we have reached the limit of my knowledge.  Read that wiki page I linked and find some examples to look at.
18:16:07 <ion> You need a type-level UnsafeCoerce.
18:16:23 <mdedetrich> I sometimes wish haskell had more material
18:16:27 <mdedetrich> I might stackoverflow this
18:19:27 <byorgey> mdedetrich: did you look at the wiki page I posted? http://www.haskell.org/haskellwiki/GHC.Generics
18:19:35 <byorgey> it has a detailed discussion and an example and everything
18:19:43 <mdedetrich> byorgey: yes I am looking at it
18:20:08 <byorgey> ok
18:23:59 <acowley> I actually find the generics stuff pretty inscrutable. It's always a battle to get something basic working after forgetting how it works, then I give up before doing anything interesting with it.
18:24:16 <acowley> The author is sometimes here, though, and quite helpful.
18:24:16 <mdedetrich> well im getting there
18:24:39 <mdedetrich> I understand what K1 was, its meant to define the types for single arguments
18:24:47 <mdedetrich> its still not detecting the record though
18:25:12 <mdedetrich> Cannot derive well-kinded instance of form `Model (Car ...)'
18:25:13 <mdedetrich>       Class `Model' expects an argument of kind `* -> *'
18:25:14 <mdedetrich>     In the data declaration for `Car'
18:25:59 <mdedetrich> https://gist.github.com/anonymous/3468af51edaff7efbafc
18:26:45 <mdedetrich> its still not picking it up
18:27:52 <mdedetrich> acowley: generics in a static functional language like haskell is always going to be painful
18:28:20 <mdedetrich> I mean kinda understand what is going on, what would really help is a nice IDE + fantastic tutorials
18:28:50 <mdedetrich> also is there a reason you can't instance String?
18:29:08 <ion> String = [Char]
18:29:12 <acowley> mdedetrich: I don't really see why, though. It's quite fun to define your own product and sum types then write mappings from a data type to that representation and back. But when I go to use Generics, I drown in the haddocks.
18:33:21 <mdedetrich> acowley: I should have rephrased better, for my usecase its going to be painful in a language like Haskell, since Haskell has no concept of classes or subclassing
18:33:27 <mdedetrich> which is kinda what I am trying to emulate
18:34:04 <acowley> It seems apropos for me to ask whether or not vinyl's subtype relation meets your needs?
18:34:17 <c_wraith> Is there any particular reason you actually need subtyping?
18:34:27 <acowley> It's a structural subtyping relation that lets you upcast
18:35:01 <mdedetrich> acowley: what do you mean by vinyls subtype?
18:35:24 <acowley> mdedetrich: http://hackage.haskell.org/packages/archive/vinyl/0.1.3/doc/html/Data-Vinyl-Relation.html
18:35:54 <acowley> It lets you say, "foo :: (i <: MyRec) => i -> Bool"
18:36:06 <acowley> then, in foo, you can cast the input to MyRec
18:38:01 <mdedetrich> acowleyhaving a read of it now
18:38:36 <mdedetrich> c_wraith: yes, I am trying to do an ORM style of thing (Im curious to see if an idea I have for a web framework is both possible and nice in haskell)
18:38:58 <c_wraith> Where does subtyping show up in an ORM?
18:39:14 <c_wraith> there's no subtyping on the relational side
18:40:10 <mdedetrich> no, but you need to specify, someway, that your "model" is actually part of a database model
18:40:15 <mdedetrich> I mean this is what I am trying to achieve
18:40:26 <mdedetrich> data Car = Car {company :: String, model :: String, year :: Int} deriving (Model)
18:40:29 <c_wraith> Ok, but there are approaches other than subtyping.
18:40:44 <mdedetrich> yes, I looked at persistant, it uses quasi quotation/templating
18:40:53 <mdedetrich> which is a lot less elegant and I consider hacky
18:41:33 <mdedetrich> im sure there are many approaches, but I think mine is the nicest (that is my opinion)
18:41:37 <mdedetrich> im just seeing if its possible
18:41:38 <acowley> Is there a set time that hackage runs haddock on new uploads?
18:42:13 <acowley> mdedetrich: You just want to identify records that have a model field?
18:43:00 <tgeeky> acowley: in my experience (probably less than yours), between 1 and 4 hours
18:43:02 <tgeeky> after upload
18:43:10 <c_wraith> acowley: yeah, it's on a cron job. I think it runs every 6 hours
18:43:26 <mdedetrich> acowley: well yes, in that case it would correspond to a database table called "Car" that has columns make,year and company
18:43:33 <tgeeky> c_wraith: that can't be correct! that invalidates my response, a guess!
18:43:39 <tgeeky> c_wraith: wait, that's not how that works.
18:43:42 <acowley> I was just wondering if it was at a fixed time in some time zone.
18:43:56 <c_wraith> tgeeky: actually, it supports your answer. They're in perfect agreement
18:44:24 <tgeeky> c_wraith: oh, I suppose so.
18:46:12 <mdedetrich> acowley: thanks for vinyl though, I will have a look at it
18:48:10 <acowley> mdedetrich: I've got a gist for you
18:48:47 <acowley> mdedetrich: https://gist.github.com/acowley/5906221
18:58:39 <mdedetrich> acowley: cool, had a look. I think my solution is more elegant for the end user, but I will def need it someplace else
19:00:21 <acowley> mdedetrich: Yeah, vinyl is far from ideal in many cases, but it does what it does really well, imho. I've tried to make sure its performance is reasonable for common use cases, but there's always a risk that perf will be bad for some types.
19:15:46 <DiegoNolan> Peaker, is there a limit to the how long the list can be for the bezierCurve in drawingcombinators?
19:17:34 <lispy> where is the temporary hpaste at ?
19:17:41 <lispy> maybe I'll just use gist
19:21:17 <lispy> @tell carter Do you have a way to rewrite this into fast Haskell? https://gist.github.com/dagit/5906345
19:21:17 <lambdabot> Consider it noted.
19:39:01 <NemesisD> i'm having a hard time deciding whether or not i should use the strict or lazy variant of containers like hashmap
19:44:41 <c_wraith> NemesisD: default to strict for container types, unless you know why you want lazy
19:44:58 <halvorg> Does anyone have a minute to answer a quick question about pattern matching?
19:45:42 <c_wraith> NemesisD: things like hashmap (from unordered-containers) are spine-strict and key-strict either way. The only difference is strictness in the value being stored with each key.
19:45:57 <c_wraith> halvorg: someone will probably help. Just ask the question
19:46:10 <halvorg> ok
19:46:52 <mm_freak_> NemesisD: my default is lazy
19:47:03 <mm_freak_> note that the containers are always strict in keys
19:47:23 <carter> lispy  is that matrix mult with + == or and * = and?
19:47:44 <c_wraith> mm_freak_: you don't find that most common operations end up leaking space with lazy containers?
19:47:52 <mm_freak_> c_wraith: nope
19:49:15 <c_wraith> huh.  Anything I do with maps, they'll leak badly if I don't force the values.
19:50:12 <copumpkin> lispy: pack those matrices and do them bitwise! :P
19:50:35 <mm_freak_> c_wraith: well, i believe in controlling evaluation carefully, and that works better for me
19:50:36 <carter> copumpkin yeah
19:55:37 <c_wraith> mm_freak_: so you never call adjust?
19:56:45 <carter> @tell lispy your boolean mat mult using And and Or has a few bugs
19:56:45 <lambdabot> Consider it noted.
19:57:20 <carter> @tell lispy  but i can happilly make sure i have vectorized dot product for booleans in my vector-vectorized lib i'm doing this week
19:57:20 <lambdabot> Consider it noted.
19:58:31 <halvorg> Is there a simpler way to match against an "inner data type"? see http://pastebin.com/Q624wjDT for a 16 line example.
19:58:36 <mauke> The paste Q624wjDT has been copied to http://paste.tryhaskell.org/90638
19:58:38 <halvorg> a way without numerous _'s
20:00:08 <monochrom> since you have defined fields, you can isGreen OtherType{fieldColor=Green{{}} = ...
20:00:19 <monochrom> err, type
20:00:42 <monochrom> typo. isGreen OtherType{fieldColor=Green{}} = ...
20:01:15 <halvorg> okay thank you, i'll try that
20:03:30 <mm_freak_> c_wraith: indeed, i don't think i've ever used it
20:03:45 <mm_freak_> c_wraith: in fact in most of my applications maps turn out to be query-only
20:04:06 <mm_freak_> c_wraith: but yes, i see your point
20:04:09 <mm_freak_> it depends on the application
20:04:46 <c_wraith> Yeah.  I tend to only use maps for modification-heavy cases.
20:04:47 <mm_freak_> c_wraith: the operations i use the most are singleton, unionWith and lookup
20:05:15 <mm_freak_> i can see how a strict unionWith would be useful
20:05:48 <c_wraith> It's especially important when you're updating a map in terms of previous versions of itself.
20:06:51 <c_wraith> It's easy for the structure to become O(number of times it's been updated) if you don't force values.
20:07:03 <c_wraith> err, in terms of amount of memory it's holding on to
20:07:21 <mm_freak_> well, that's basically unionWith for me
20:07:48 <c_wraith> So if your use case is doing a bunch of modifications, then calling toList, you get the standard space leak memory profile
20:08:02 <c_wraith> And that's my usual use case for maps
20:09:45 <mm_freak_> c_wraith: i may be blinded by the virtues of GHC optimization =)
20:12:00 <orzo> is there a way to announce to the runtime that an IORef should be collected?
20:13:09 <monochrom> that may be an XY problem. but I just have to lose all aliases to it, and it will be GCed. works for me.
20:14:17 <AsgardBSD> carter: Hey you are still there
20:14:23 <carter> AsgardBSD sometimes
20:14:26 <carter> why?
20:14:35 <AsgardBSD> Any book on regular expression?
20:14:38 <c_wraith> orzo: what are you trying to actually solve?
20:14:56 <carter> AsgardBSD what the goal
20:15:07 <AsgardBSD> learn the basic of regular expression
20:15:33 <carter> AsgardBSD have you googled yet?
20:15:41 <AsgardBSD> Anyway, for the algorithm, currently taking a course on coursera
20:15:44 <AsgardBSD> carter: yes
20:15:55 <carter> so whats your goal?
20:16:00 <carter> theres lots of papers on it
20:16:00 <AsgardBSD> but i prefer to have book (or pdf of a book, legally of course)
20:16:11 <carter> AsgardBSD its not worth a book
20:16:14 <carter> theres very good papers online
20:16:16 <carter> read those
20:16:22 <AsgardBSD> and you seem to know what are good resource and what are not
20:16:32 <AsgardBSD> because you recommended me to avoid CLRS
20:17:03 <c_wraith> Really?  I liked CLR.  (First edition.  S joined in the 2nd)
20:17:36 <AsgardBSD> So i tough you also had some special recommendation for regular expression
20:17:40 <carter> oh
20:17:41 <carter> well
20:17:44 <carter> there are two papers
20:17:53 <carter> but try googling for regex papers first
20:18:01 <carter> learning to find the good stuff is valuable!
20:18:06 <carter> try and find 2 good ones
20:18:16 <carter> and then i'll tell you the two i have in mind + the associated code examples :)
20:20:32 <carter> AsgardBSD hint: one is a functional perl a recent ICFP
20:20:43 <carter> the other is the papers related to an associated google regexp lib
20:24:45 <carter> AsgardBSD http://sebfisch.github.io/haskell-regexp/ and  http://code.google.com/p/re2/
20:25:12 * hackagebot cabal-rpm 0.8.2 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.8.2 (JensPetersen)
20:27:48 <tunixman> t AsgardBSD are you looking for a book on regular expressions, or on implementing a regular expression engine?
20:28:04 <AsgardBSD> how to use regular expression
20:28:21 <AsgardBSD> So many tool in *nix, and so many programming language that make use of regular expression...
20:28:34 <AsgardBSD> but i have hard time finding the right ressource to learn it
20:28:59 <Demos> learn the basic syntax then get a tool that will highlight matches in a document for you
20:29:59 <tunixman> Have you looked at the O'Reilly book? http://www.amazon.com/Introducing-Regular-Expressions-ebook/dp/B008K9OGDA%3FSubscriptionId%3DAKIAILSHYYTFIVPWUY6Q%26tag%3Dduckduckgo-z-20%26linkCode%3Dxm2%26camp%3D2025%26creative%3D165953%26creativeASIN%3DB008K9OGDA
20:30:42 <MasseR> AsgardBSD: These resources aren't books nor papers, but I think they might be useful. http://www.regexper.com for visualizing regular expressions, might help you _understand_ them and http://www.regular-expressions.info which has regex tutorials. Like carter mentioned, regular expressions don't warrant a book
20:30:57 <carter> thanks MasseR
20:31:25 <carter> i also pointed him at enough math books to keep anyone busy for a year even if they did it full time
20:31:57 <AsgardBSD> Enough math book?? (there where just 2 math book and 1 algorithm book)
20:32:03 <carter> AsgardBSD yes
20:32:08 <frelux> carter: have you had any luck fixing up your ghc build environment after installing Xcode 5?
20:32:09 <AsgardBSD> I can eat more math :)
20:32:19 <AsgardBSD> carter on mac...
20:32:20 <carter> frelux yes i reinstalled the xcode 4.6 cli tools
20:32:39 <frelux> word, downloaded from the dev site?
20:32:42 <carter> yeah
20:32:44 <carter> theres another way
20:32:53 <carter> but it requires modifying your ghc settings file
20:33:08 <frelux> yeah i saw manuel mention that on ADN
20:33:15 <frelux> I'll go with your way : ) thanks!
20:33:21 <tunixman> t AsgardBSD There's also a simple JIT implementation in pypy that may be useful at http://morepypy.blogspot.com/2010/05/efficient-and-elegant-regular.html and http://morepypy.blogspot.com/2010/06/jit-for-regular-expression-matching.html
20:33:31 <carter> oh pypy is cool
20:33:41 <tunixman> Although I'm questioning the wisdom of pasting in PyPy links to #haskell...
20:34:03 <carter> tunixman AsgardBSD  is an undergrad doing DSP stuff, give him a year worth of learning suggestions, i know you have opinions on DSP things
20:34:07 <carter> :)
20:34:08 <AsgardBSD> well, if we make a pypy implementation in haskell, that would be ok?
20:34:17 <tunixman> Don't tempt me.
20:34:18 <carter> AsgardBSD that'd be a waste of feffort
20:34:21 <carter> *effort
20:34:23 <haasn> but that would be hspy wouldn't it?
20:34:24 <Demos> well that would not be pypy anymore would it?
20:34:28 <tunixman> happy
20:34:35 <haasn> happy's taken
20:34:35 <tunixman> that's what I'd call it.
20:34:45 <carter> Demos we have llvm + edsls, we don't need pypy :)
20:34:48 <tunixman> I'm unsurprised but disappointed.
20:34:57 <AsgardBSD> Well, currently, i have no knowledge of DSP
20:35:02 <carter> AsgardBSD thats ok
20:35:05 <tunixman> huh
20:35:11 <haasn> tunixman: you could use happy to write the parser for hspy
20:35:22 <tunixman> Yeah?
20:35:24 <carter> AsgardBSD then howcome you're planning out yak shaving a computer algebra system for DSP?
20:35:27 <tunixman> STOP GIVING ME IDEAS.
20:35:28 <tunixman> Alright.
20:35:42 <carter> tunixman is trying to get comfy in haskell right now
20:35:43 <tunixman> No more hspy/happy/pypy from me for a bit or I'll get inspired.
20:35:45 <tunixman> yes.
20:35:48 <carter> don't snipe him before he's hatched
20:35:57 <AsgardBSD> I will learn DSP next session
20:36:01 <carter> Project Euler for now :)
20:36:01 <tunixman> And while getting comfy in Haskell by writing a better pypy is one way... welp.
20:36:02 <carter> mwahahahaha
20:36:09 <tunixman> I did the scheme in haskell tutorial.
20:36:12 <carter> oh?
20:36:16 <carter> this week?
20:36:18 <carter> cool!
20:36:21 <AsgardBSD> Well, to resume my situation... i live in Quebec (Canada)
20:36:32 <carter> tunixman did you do a CPS transformation?
20:36:41 <AsgardBSD> In quebec, we have primary, then secondary, then college then university
20:36:47 <AsgardBSD> Im currently at college
20:36:50 <tunixman> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
20:36:55 <tunixman> Hm.
20:37:01 <tunixman> I'm not actually sure anymore.
20:37:07 <AsgardBSD> at college, we have 2 choice: Pre university or a tech
20:37:16 <AsgardBSD> im currently doing a tech in electronics
20:37:18 <carter> is college a funny name for high school?
20:37:27 <GeneralMayhem> only in france
20:37:35 <AsgardBSD> then i will continue at university for either CE, CSE or CS
20:37:46 <carter> GeneralMayhem so also in quebec?
20:38:00 <GeneralMayhem> no, sorry, it was a joke
20:38:06 <tunixman> t carter https://en.wikipedia.org/wiki/College_%28Canada%29#Quebec
20:38:15 <AsgardBSD> primary = 6 years, secondary = 5 years, college (called cegep in french) is either 2 year (pre universitary) or 3 (tech)
20:38:18 <AsgardBSD> then university
20:38:31 <carter> so your'e in high school
20:38:34 <mm_freak_> tunixman: are you looking for a small haskell project?
20:38:47 <carter> mm_freak_ don't snipe him too much, he's a busy man
20:38:50 <tunixman> t carter I'm not sure that's right. I think it's more like "Junior College"...
20:39:04 <carter> hrm
20:39:11 <tunixman> t mm_freak_ I suppose... I'm in the middle of a few things, but depending on the project maybe...
20:39:12 <mm_freak_> carter: he has the liberty to say "no" =)
20:39:19 <AsgardBSD> Yep, college are like high school here
20:39:24 <carter> cool
20:39:29 <AsgardBSD> im starting my second year of my tech in electronics
20:39:33 <carter> cool
20:39:52 <mm_freak_> tunixman: when i have some spare time i enjoy doing the matasano crypto challenges in haskell…  you learn both to solve problems the haskell way and to write real world programs
20:39:56 <AsgardBSD> The reason why i do a tech is because it allow me to skip biology and some chemestry course
20:40:18 <carter> those are worth learning too though
20:40:25 <AsgardBSD> Hate biology (a course where we need to memorize lot of thing)
20:40:26 <tunixman> t mm_freak_ oh? carter was looking at those too, and I mentioned #haskell as a good place to get the haskell submissions evaluated.
20:40:35 <carter> yeah
20:40:38 <AsgardBSD> and for cchemestry, i had a booring teacher...
20:40:57 <AsgardBSD> So for me, my tech is my pre university
20:41:19 <AsgardBSD> And i prepare myself in computing for when i will get to university
20:41:31 <AsgardBSD> Im still unsure if i go CE or CS
20:41:54 <carter> AsgardBSD DSP is pretty sophisticated math
20:42:11 <AsgardBSD> In my tech, we have to make a project on the final year
20:42:16 <AsgardBSD> Big project
20:42:27 <AsgardBSD> i intend to mix some Haskell with some embeded
20:42:29 <carter> took me until dropping out of a phd to really start learning numerical linear algebra
20:42:40 <carter> AsgardBSD tunixman knows embedded
20:42:42 <AsgardBSD> To show that functionnal programming can be useful in embeded
20:42:47 <carter> AsgardBSD it is useufl
20:42:52 <carter> no need to "prove" it
20:42:57 <carter> serious companies spend serious money
20:43:03 <carter> doing verified embedded
20:43:08 <carter> though most embedded is too cheap for such
20:43:18 <AsgardBSD> but my teacher dont know FP
20:43:22 <carter> thats ok
20:43:24 <johnw> this is starting to sound like a -blah discussion...
20:43:26 <carter> they're only high school teachers
20:43:27 <carter> yeah
20:43:35 <johnw> thx
20:43:46 <AsgardBSD> So i intend to use a raspberry PI with haskell communicating with other device
20:43:55 <AsgardBSD> maybe haskell will do the network layer
20:43:55 <carter> AsgardBSD switch to #haskell-blah
20:44:04 <tunixman> Wait, that's a channel?
20:44:10 <carter> tunixman have you stared at Atom much ?
20:44:13 <carter> tunixman yup
20:44:19 <johnw> yeah, it's for lighter and off-topic discussions
20:44:25 <carter> yes
20:44:40 <tunixman> I've started to look at it before getting distracted by the windows driver model.
20:45:00 <tunixman> But I think maybe our "driver" would actually be a decent fit for it.
20:45:26 <lispy> carter: what bugs?
20:45:29 <lispy> johnw: listDirectory: resource exhausted (Too many open files)
20:45:33 <lispy> johnw: shelly :(
20:45:43 <johnw> lispy: can you show me the code?
20:45:55 <johnw> sounds like a lazy I/O problem
20:45:59 <lispy> johnw: not really
20:46:04 <carter> lispy you use + and * instead of || and &&
20:46:06 <johnw> btw, filesystem-conduit is much better for things like that
20:46:07 <carter> somtiems
20:46:33 <lispy> carter: only to compute the index
20:46:49 <carter> lispy oh ok
20:46:52 <carter> i was confused by that
20:47:11 <lispy> it's because my "matrix" is passsed as a linear chunk of memory
20:47:12 <carter> lispy and you 0 out the result matrix before using it
20:47:19 <carter> yeah
20:47:27 <carter> i just do the ixing within the array brackets for my own stuff
20:47:46 <carter> more functional :)
20:47:55 <lispy> carter: the algorithm is from here: http://www.jn.inf.ethz.ch/education/script/P3_C11.pdf
20:48:08 <lispy> Section 11.2
20:48:12 <carter> no, i can totall see how its what it is
20:48:41 <lispy> carter: I use matrix (from hackage) and it was taking minutes before I ^C'd
20:48:51 <lispy> carter: so I rewrote it in C and now it's fast
20:48:56 <carter> matrix?
20:49:01 <carter> what package is that?
20:49:20 <carter> http://hackage.haskell.org/packages/archive/matrix/0.2.1/doc/html/Data-Matrix.html ?
20:49:25 <lispy> basically, data Matrix a = M (Vector (Vector a))
20:49:29 <lispy> yeah
20:49:31 <carter> its terrible
20:49:33 <carter> dont use it
20:49:37 <lispy> I learned that :)
20:49:48 <lispy> I would use hmatrix but I dislike dealing with blas at link time
20:50:03 <carter> lispy i'll be rolling out my basic stuff with a "naivehaskell" backend in the next weekish
20:50:19 <carter> plus a "vector-vectorized" package
20:50:30 <carter> that does simd for storable and unboxed floats
20:50:36 <carter> would be easy to do a boolean thing
20:51:00 <carter> i think the unboxed and storable instances of bool use a word set to 0 or 1  i think
20:51:58 <NemesisD> tunixman: hey man! how's it going. never seen you in here before. i follow you on twitter
20:52:11 <lispy> carter: in my case I have an adjacency matrix and I want the transitive closure
20:52:16 <carter> lispy i know
20:52:17 <carter> hence
20:52:24 <carter> i'll do the bool vector instance
20:52:28 <lispy> cool
20:52:31 <carter> so you can become a user post haste :)
20:52:35 <lispy> :)
20:52:43 <carter> i'l ljust need to check that the storable and unboxed reps are good
20:52:47 <carter> lispy there will be some C codes
20:52:59 <tunixman> t NemesisD Hello!
20:53:00 <carter> but my stupid ones should still be 100x faster than what you did
20:53:04 <carter> NemesisD do i know you too?
20:53:13 <carter> tunixman your t's are showing
20:54:35 <tunixman> t carter oh?
20:54:41 <carter> yes
20:54:43 <carter> exactly
20:54:49 <carter> <tunixman>	 t carter oh?
20:55:12 <tunixman> t carter welp
20:55:21 <tunixman> (t means "tell")
20:55:25 <carter> jah
20:55:44 <carter> i've tried to gchat you and i think the streams are crossed :)
20:57:57 <lispy> johnw: yeah that was a the problem. I guess the find function has to open an fd during it's operation and it was just coincidence that my readFile tripped it up
20:58:36 <lispy> carter: the C code I have is plenty fast, it was the haskell code that was stupidly slow
20:59:42 <lispy> carter: I think using data Matrix a = M (Vector a) would be an improvement over data Matrix a = M (Vector (Vector a))
20:59:50 <lispy> but I'm not sure why it was so slow otherwise
20:59:52 <carter> lispy UNDERSTATEMENT
21:00:10 <carter> lispy also, you'll want to do the transpose of the right hand matrix so it has better locality
21:00:25 <carter> tiny overhead for the copy
21:00:27 <carter> but worth it
21:00:41 <carter> that alone will make like a 100x perf difference
21:00:45 <carter> esp on larger matrices
21:01:09 <MasseR> g
21:02:29 <carter> lispy ok, i think storable matrices use words for bools
21:02:40 <lispy> space isn't really an issue :)
21:02:48 <lispy> I could have used int
21:02:49 <carter> and unboxed uses btes
21:03:24 <carter> lispy it means unboxed + using a C simd thing inside will be FAST :)
21:03:30 <copumpkin> lispy: packing it means you can do 32/64 operations at once. It's like SIMD on steroids ;)
21:03:45 <carter> copumpkin 8 operations in a word64 in this case
21:03:59 <carter> will have to do a scalar tail
21:04:01 <carter> but thats ok
21:04:01 <copumpkin> SIMD that worked all the way back on the very first x86s
21:04:04 <copumpkin> I mean bitwise ops
21:04:08 <carter> yes
21:04:09 <copumpkin> replace || with |
21:04:11 <copumpkin> ok
21:04:17 <carter> copumpkin but i'll be doing the SIMD on top of that :)
21:04:19 <copumpkin> then you're doing 64 bitwise ands and ors
21:04:21 <copumpkin> sure
21:04:41 <carter> might even go as far to check that both vectors have the same alignment
21:04:42 <carter> or not
21:04:57 <carter> and then choose between how to vectorize based upon that
21:05:08 * carter shaves the yaks FAST
21:05:13 <carter> eventually
21:05:13 <NemesisD> carter tunixman dunno. i'm mxavier on twitter
21:05:28 <carter> NemesisD nope, never heard of you, tunixman  is a swell caring dude thoughh
21:05:29 <carter> :)
21:05:54 <NemesisD> definitely if you count caremad towards caring :P
21:06:11 <carter> NemesisD i did snipe him towards haskell
21:06:20 <carter> recursively
21:06:28 <NemesisD> carter: ah cool. did you guys work toogether or something?
21:06:33 <carter> nope
21:06:41 <carter> i'm just loud on the internet
21:07:17 <NemesisD> lol
21:07:22 <tunixman> mxavier, eh
21:08:29 <tunixman> yeah, there you are.
21:10:39 <NemesisD> my twitter feed lately is mostly haskell, retweeting more interesting people than me, and slagging off Go
21:11:02 <carter> NemesisD hehe
21:11:28 <carter> did you see joe damato slagging on go too?
21:11:37 <shachaf> My tweets are maximally interesting.
21:11:47 <tunixman> yeah, man.
21:11:50 <tunixman> go.
21:12:06 <shachaf> Anyway, no language bashing in here, please.
21:12:13 <tunixman> right, sorry.
21:12:20 <carter> k
21:12:30 <carter> i just don't like how they do the math primops
21:13:05 <carter> http://code.google.com/p/go/source/browse#hg%2Fsrc%2Fpkg%2Fmath
21:13:11 <haasn> shachaf: Per character count?
21:13:40 <shachaf> haasn: Per tweet.
21:14:17 <carter> shachaf thats an undefined number
21:14:30 <haasn> I guess so are mine, considering the fact that I have 0 tweets
21:14:30 <carter> if approach it from the the negative size, the limit disagrees
21:14:47 <shachaf> "the negative size" makes no sense here.
21:14:59 <carter> *negative side
21:15:06 <shachaf> Still makes no sense.
21:15:08 <tabemann> opinion question - I'm converting my functions that produce in-order strict lists to ones that, if possible, have a dual-mode system in which they produce in-order up to a certain stack depth, and then change order and produce in reverse order (on the heap) and then reverse again - should I do this to *all* such functions, or just the important ones (map, filter, (++), etc.)?
21:15:15 <shachaf> But OK. I'm the most concise tweeter: I spend the minimal number of tweets to communicate one unit of interesting ideas.
21:15:18 <shachaf> Anyway this is offtopic.
21:15:44 <shachaf> tabemann: It's your library, not ours.
21:16:01 * shachaf thinks this whole strict list library thing is rather misguided.
21:16:13 <johnw> shachaf++
21:16:39 <johnw> tabemann: one of the reasons for using lists instead of, say, vectors, is their non-strictness
21:17:14 <tabemann> I'm doing it mostly because it hasn't been done before, and need some project to work on (which isn't rewrapping OpenGLRaw)
21:17:28 <NemesisD> has anyone got a chance to try the fp complete IDE yet
21:17:36 <johnw> i say spin the wheel again :)
21:17:52 <shachaf> There are other reasons to use lists, many of which are reasonable in strict languages.
21:18:13 <johnw> shachaf: sure, I did say "one of"
21:18:20 <tabemann> I'm not going to throw away what I've done so far, though, considering that there's enough present to be worth cabalizing and releasing
21:19:29 <shachaf> Quantity isn't the only criterion for what's worth putting on Hackage.
21:19:39 <shachaf> Not that I've seen this particular library.
21:20:13 * hackagebot ty 0.1.3 - Typed type representations and equality proofs  http://hackage.haskell.org/package/ty-0.1.3 (ConalElliott)
21:20:21 <Saizan> shachaf: why do you think it's misguided?
21:22:13 <tabemann> probably because in practice the number of use cases in which one *needs* strict lists are relatively limited, I'd guess
21:22:35 <shachaf> I don't think strict lists are fundamentally misguided, but a lot of the things that I've heard about this library have been under false assumptions of how Haskell evaluation works, whether strict or lazy.
21:23:10 <shachaf> I think it would be better to get a good understanding of laziness, and why/how things work the way they do right now, first.
21:23:11 <dolio> I might think strict lists are misguided. :)
21:23:15 <dolio> I'd have to think about it a while, though.
21:24:07 <Saizan> shachaf: any particular example of these false assumptions showing?
21:24:57 <tabemann> shachaf: what I've been seeing is the differences in how to implement things where I have triplets of functions where one produces a strict list (which may or may not use tail recursion), one produces a reversed strict list (which uses tail recursion), and one produces a lazy list (which does not use tail recursion); I've been looking a lot at GHC.List and Data.List to see how they do things, and figured out a lot from that
21:25:18 <tabemann> Saizan: I said a few things that were kind of misguided to shachaf early on this project
21:25:57 <tabemann> e.g. whether there is any value to using a lazy list vis-a-vis a strict list in a reversing accumulator
21:26:16 <shachaf> Saizan: I don't remember the details -- it's only the impression I've gotten from hearing about this project here and there.
21:27:02 <johnw> however, at the very worst tabemann will learn from implementing such a library, even if no one uses it, so I can't quite recommend that he not do it at all
21:28:40 <tabemann> the big thing I get is that the style of programming needed for a lot of this is not typical of normal Haskell code specifically because it is written with strictness in mind, i.e. it is closer to how I would have coded it in OCaml
21:29:10 <shachaf> It's possible implementing a strict list library is a good way to learn about laziness.
21:29:13 <dolio> That is, I suspect, another reason.
21:29:46 <tabemann> and the to-lazy parts of the code are essentially taken from GHC.List and Data.List (after reading over such some to figure out just what they do rather than just copying and pasting)
21:30:18 <shachaf> It's still important to keep GHC's general evaluation model in mind. Haskell is not OCaml, even when you have strict data.
21:30:26 <hpaste> jtbandes pasted “typeclass weirdness” at http://paste.tryhaskell.org/8673435160030478336
21:30:34 <jtbandes> can anyone explain that error to me? ^
21:31:02 <carter> yeah
21:31:06 <dmwit> jtbandes: Well, which instance should it pick?
21:31:15 <dmwit> I bet you're going to say the (a, a) one.
21:31:18 <carter> i write lots of strict code, but its not like what most people think of as strict code
21:31:20 <dmwit> But why shouldn't it pick the a one?
21:31:23 <haasn> jtbandes: ‘(a, a)’ is a subset of ‘a’
21:31:30 <jtbandes> dmwit: I don't see any ambiguity, (Int,Int) doesn't satisfy Integral a
21:31:44 <haasn> jtbandes: the constraint is irrelevant for instance selection
21:31:54 <haasn> this is one of the most common misconceptions I see about instance errors like these
21:31:58 <shachaf> jtbandes: What if someone else makes an Integral instance for it?
21:32:06 <jtbandes> ah, I see
21:32:42 <DiegoNolan> what's the best way to turn a n-tree to a list of all paths
21:33:29 <haasn> some sort of morphism from Tree to [] ?
21:33:40 <haasn> [[]]
21:33:44 <DiegoNolan> like Tree -> [[]]
21:34:03 <DiegoNolan>    2
21:34:08 <jtbandes> then what would you recommend instead, if I want a typeclass that can capture both numbers and tuples of numbers, to use either as arguments to a function?
21:34:10 <carter> @hooogle (&&)
21:34:10 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
21:34:10 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
21:34:10 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
21:34:34 <carter> @hoogle (&)
21:34:34 <lambdabot> Prelude (&&) :: Bool -> Bool -> Bool
21:34:34 <lambdabot> Data.Bool (&&) :: Bool -> Bool -> Bool
21:34:34 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
21:34:50 <DiegoNolan>   2
21:34:51 <haasn> DiegoNolan: the Monad [] instance could come in handy here, aggregating all leaves of each node into a list and then recursing into that with >>=
21:35:20 <DiegoNolan> hmm
21:35:24 <jtbandes> shachaf: also, it seems like this (whether such an instance exists) should be known at compile time?
21:36:15 <shachaf> Well, compile time doesn't happen all at once, it happens in each module separately.
21:36:23 <jtbandes> fair enough
21:36:39 <shachaf> In this particular case maybe GHC could say "hmm, there's no Integral instance for this thing in scope", but that's not how type class resolution works in the first place.
21:37:02 <jtbandes> what do you mean that's not how it works?
21:39:17 <haasn> jtbandes: as for a suggestion on how to get what you want, the general idea would be to add a newtype wrapper for instances that can be had ‘for free’ eg. instance Integral a => Foo (WrappedIntegral a)
21:39:36 <haasn> perhaps with a nicer name
21:42:13 <jtbandes> haasn: then how do I write a function :: Foo a => a -> something else? I would have to say "Foo (Wrapper a) => ..."?
21:42:37 <dacdave> Just installed haskell-platform on new Ubuntu 12.4 install. Any attempt to invoke it (even ghc --version) returns an error that it can't find libgmp.so.3. Sure enough, this file does not exist anywhere. What did I do wrong?
21:42:43 <haasn> I'm not sure why you would need to do that
21:43:01 <haasn> though instead of Foo (Wrapper a) => you could just use Integral a =>
21:43:11 <haasn> since you know every integral a has a Foo instance
21:45:37 <jtbandes> haasn: but that doesn't allow my tuple example above
21:46:15 <dmj> dacdave
21:46:25 <dmj> I am not an ubuntu user, but this might help you.
21:46:26 <dmj> http://stackoverflow.com/questions/6360724/installing-ghc-binaries-on-linux-cant-find-libgmp-so
21:46:29 <haasn> I think you would need to post more concrete code before specific questions can be asked
21:49:55 <Fuuzetsu> Is there any way to get your hands on an extension faster than the scheduled release? I'm thinking about TypeHoles which are scheduled for 7.8.1.
21:50:13 <johnw> Fuuzetsu: you can install GHC HEAD
21:50:46 <Fuuzetsu> …I was about to say that I'm using HEAD already but I think I'd be lying…
21:51:29 <Fuuzetsu> Oh, TypeHoles is present. I should have paid more attention to what I'm doing. Thanks.
21:52:57 <dacdave> dmj: Thanks for the reply. Been there. ldd of ghc shows "libgmp.so.3 => not found" So, I cannot add it to LD_LIBRARY_PATH.
21:53:08 <dacdave> Any other ideas?
21:58:22 <tunixman> dacdave: are you using haskell-platform in apt or the binary from the haskell site?
21:58:50 <dacdave> atp-get install haskell-platform
21:59:18 <dacdave> correction, apt-get install haskell-platform
21:59:39 <tunixman> What does "ls /usr/lib/libgmp*" show?
21:59:59 <dacdave> cabal works - at least cabal update runs without errors, but I cannot invoke ghc or ghci.
22:00:36 <tunixman> what do "which ghc" and "which cabal" show?
22:01:08 <tunixman> i.e. it sounds like maybe there's a ghc/ghci on your PATH masking the system version, but not a cabal.
22:01:10 <dacdave> tunixman: that returns "no such file or directory"
22:01:17 <tunixman> hm.
22:01:25 <tunixman> What if you do /usr/bin/ghci
22:02:34 <dacdave> Yep, /usr/bin/ghci works!
22:02:42 <tunixman> well.
22:03:09 <tunixman> When you ran "which ghci" did you run it without the quotes, i.e. which ghic
22:03:12 <tunixman> which ghci
22:03:13 <dacdave> Also, which ghc returns /usr/local/bin/ghc
22:03:18 <tunixman> Well, there you go.
22:03:25 <jtbandes> haasn: basically, I am trying to write a function that can take an integer, or a tuple of 2 integers, and produce a value based on how the argument behaves when passed to the functions defined in this type class
22:03:37 <tunixman> you have a ghc in /usr/local/bin which will mask the one in /usr/bin
22:03:55 <jtbandes> haasn: as a simple example, say "listOf 3" gives [3] whereas "listOf (3,4)" gives [3,4]
22:04:03 <dacdave> OK, so this is a linux question and not a haskell question. Thank you.
22:04:13 <tunixman> yep, well, sort of, yeah
22:04:15 <tunixman> try sudo chmod -x /usr/local/bin/ghc*
22:04:24 <tunixman> then hash -r
22:04:33 <johnw> jtbandes: what if you have your bar function accept a type like: data MyInts a = MyInt a | MyInts (a,a), and then you can just pattern match to determine which kind it is
22:04:47 <haasn> jtbandes: that one's actually tricky since (a, a) -> [a] and a -> [a] don't follow a very similar pattern
22:05:07 <arkeet> do we have lens now?
22:05:09 <arkeet> :t toListOf
22:05:10 <lambdabot>     Not in scope: `toListOf'
22:05:10 <lambdabot>     Perhaps you meant one of these:
22:05:10 <lambdabot>       `F.toList' (imported from Data.Foldable),
22:05:12 <arkeet> :(
22:05:14 <tunixman> dacdave: I'm not anywhere near official haskell anything, but I reckon if you're struggling to run it and ask for help here you'll find someone who knows something.
22:05:14 <jtbandes> haasn: it doesn't, unless we have a typeclass that can encompass them?
22:05:20 <shachaf> @let import Control.Lens.FOld
22:05:20 <lambdabot>  .L.hs:38:1:
22:05:20 <lambdabot>      Failed to load interface for `Control.Lens.FOld'
22:05:20 <lambdabot>      Perha...
22:05:22 <shachaf> @let import Control.Lens.Fold
22:05:23 <lambdabot>  Defined.
22:05:28 <shachaf> :t toListOf
22:05:29 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
22:05:44 <arkeet> which one contains both?
22:05:50 <haasn> jtbandes: yeah but what would the operation look like? Foo a => a -> [a] -- no go, doesn't match (a, a)
22:05:58 <shachaf> Probably .Traversal?
22:06:00 <haasn> doing this with a typeclass isn't exactly the best idea imo
22:06:06 <haasn> but try lens =D
22:06:07 <arkeet> @let import Control.Lens.Traversal
22:06:08 <lambdabot>  Defined.
22:06:08 <arkeet> :t both
22:06:09 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
22:06:14 <arkeet> > toListOf id 3
22:06:15 <jtbandes> haasn: unless "instance Foo (b,b)"
22:06:16 <lambdabot>   [3]
22:06:17 <arkeet> > toListOf both (4,5)
22:06:18 <lambdabot>   [4,5]
22:06:27 <haasn> jtbandes: then you'd get [(b, b)] not [b]
22:07:02 <arkeet> jtbandes: for what purpose do you want this thing?
22:07:17 <jtbandes> arkeet: my own edification
22:07:24 <arkeet> =(
22:07:28 <shachaf> Sometimes things are hard to do because you shouldn't want to do them.
22:07:35 <arkeet> indede.
22:07:37 <arkeet> or indeed.
22:07:46 <dacdave> tunixman: You may not be official, but you helped me solve the problem. Both ghc and ghci start fine now. Thank you.
22:07:46 <shachaf> GHC, tireless enforcer of good taste.
22:08:36 <jtbandes> shachaf: I am happy to accept that; it is a feature of many software systems (see also: complicated layout in LaTeX)
22:09:10 <jtbandes> however, I can't see any reason that I should want to require typing e.g. "both" or "MyInt" before the actual numbers that I want to pass in
22:10:28 <arkeet> it's possible to make a class C a b | b -> a where foo :: b -> [a]; instance C Integer Integer; instance C Integer (Integer,Integer)
22:10:29 <arkeet> or something
22:10:35 <arkeet> but I'm pretty sure you would run into other issues.
22:10:50 <arkeet> involving numeric literals being polymorphic
22:11:35 <arkeet> and you couldn't try to make your instances more general because then you'd run into issues with overlapping instances.
22:11:53 <arkeet> (what if I wrote a Num instance for (Integer,Integer), say.)
22:12:10 <johnw> jtbandes: you can always create two helper functions: bari = bar . MyInt, and barii = uncurry (bar . MyInts)
22:12:38 <johnw> then you can just write bari 10, barii 10 20
22:12:39 <jtbandes> johnw: yes, but again not ideal since you have to specify one explicitly in order to use them
22:12:47 <arkeet> the best way, I think, would just be two have two functions a -> [a] and (a,a) -> [a].
22:12:55 <arkeet> (possibly with a restricted)
22:12:56 <johnw> that explicitness is actually a good thing
22:13:13 <johnw> it helps you detect misuses at compile-time
22:13:59 <Moggle_> @src liftM2
22:14:00 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:14:03 <johnw> by writing bari or barii, you are in effect requiring that the code fulfill a contract as specified by your types
22:15:56 <jtbandes> johnw: I guess what I am going for is a little weaker, since later code will not care which way it was created, but only that it is the right type in the end
22:16:28 <joelteon> so "pure" is a curiously named function
22:17:35 <johnw> jtbandes: I think the "right type" is MyInts, based on what I understand of your problem description, and not some other entity which plays the role of two different types in various places
22:18:25 <joelteon> oh hi jtbandes
22:18:35 <jtbandes> hi there
22:18:43 <joelteon> i'm incluye
22:19:00 <jtbandes> we ran into each other recently in some other channel, I think?
22:19:05 <joelteon> yeas
22:19:08 <joelteon> yes
22:19:15 <joelteon> glad to see you in #haskell, it's the best language ever
22:20:56 <Demos> haskell is one of the best languages ever, there is some debate over weather it is reasonable for say games or windowing
22:21:16 <joelteon> which it is
22:21:44 <ofan> Demos: windowing refering to gui?
22:22:05 <Demos> yeah, games are a bigger problem I think, simulation as well
22:22:51 <Demos> it is more that less games and simulations have been written in haskell, and thus less mistakes have been made that we can learn from
22:25:21 <byorgey> There is no language which is reasonable for games or windowing.  We don't yet know how to write such programs reasonably.
22:25:49 <byorgey> But I think people working in Haskell have quite a good shot at figuring it out.
22:26:00 <Demos> byorgey, yes this is true
22:26:22 <Demos> component based solutions like unity have come closest imo, but not close enough
22:55:03 <nwf> Hey all; I have a possibly silly question.  Suppose I have a datatype which has a lot of arms which all have arguments 'n all that and is still undergoing a lot of changes as I mutate code.  Is there an easy (standard or Hackage-backed?) way to derive a nonrecursive datatype which just enumerates the constructors of this type?
22:55:07 <mcstar> so there goes my idea, someone already linked haskell with qml....
22:55:49 <shachaf> nwf: Can you give an example?
22:55:54 <nwf> (And ideally also automatically derive the function from the full type down to this enumeration.)
22:55:55 <ofan> mcstar: oh? is it a package?
22:55:59 <mcstar> yes
22:56:13 <kaustuv> Why are the error locations reported by ghci off-by-one according to Emacs?
22:56:14 <ofan> mcstar: what's its name
22:56:24 <johnw> kaustuv: you mean, off by one column?
22:56:27 <mcstar> hsqml
22:56:30 <mcstar> had to search for it :)
22:56:33 <nwf> shachaf: "data Foo = FooA Int | FooB Bool | ..." should derive "data FooConstr = FCA | FCB | ..." and a function ":: Foo -> FooConstr".
22:56:35 <kaustuv> johnw: yes
22:56:40 <johnw> kaustuv: trying setting (setq compilation-first-column 1)
22:56:48 <johnw> in your haskell-mode-hook
22:56:53 <kaustuv> super, thanks
22:56:54 <mcstar> ofan: i havent tested it...
22:56:58 <shachaf> nwf: Ah.
22:57:10 <shachaf> nwf: Depending on what you're doing, maybe something with Data.Data will do what you want?
22:57:20 <ofan> mcstar: i see, it's a binding to QtQuick
22:57:23 <mcstar> but months back, i was interested in a link between functional languages and the declarative qml.. but i simply hadnt had the time..
22:57:29 * nwf look
22:57:48 <Guest55594> Can you guys at #haskell tell me how I would find a leak
22:58:01 <ofan> i'm doing the similar thing, generate bindings to qt libs
22:58:49 <shachaf> > constrType (toConstr (Just "hi")) -- nwf:
22:58:50 <lambdabot>   DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]}
22:59:07 <mcstar> ofan: orly? is it usable?
22:59:13 <Guest55594> like recommend a tool or something?
22:59:16 <nwf> Well, that's a little more... well, dynamic, than I wanted, but I guess I can wrap it in something with a phantom parameter.
22:59:27 <mcstar> ofan: does it require much IO?
22:59:28 <kaustuv> johnw: compilation-first-column was already 1 on this buffer, and setting it to 1 or 0 has no apparent effect
22:59:31 <Guest55594> for some reason my code leaks a ton of memory every time I resize a window, and it's quite small
22:59:39 <ofan> mcstar: no, still under heavy development
22:59:46 <shachaf> nwf: Yes, it's completely at runtime etc., without a whole lot of type safety
22:59:51 <mcstar> ofan: whats the compositional model?
23:00:04 <ofan> mcstar: the goal is integrate it in existing FRP libs
23:00:16 <nwf> Yeah; a ":: a -> Constr a" function would be pretty nice.
23:00:38 <mcstar> ofan: did you work out the functional way of composing widgets and stuff?(replace OO)
23:00:42 <shachaf> nwf: If this is just a thing for development then maybe it'll be good enough. I don't know exactly what you're doing with it. :-)
23:01:23 <ofan> mcstar: yes it's FRP, doing GUI in the functional way
23:01:27 <mcstar> ofan: also, afaics, qt is heavily moving toward this qml stuff, and use c++ only for logic
23:01:30 <nwf> I want my compiler to have a static enumeration of the builtins (with statically-guaranteed arities) of the source language, but sometimes I need the name of the builtin rather than the builtin and all of its arguments.
23:01:59 <shachaf> nwf: Ah.
23:02:00 <Moggle_> this may be a dumb question: is the reader monad really particularly different than the state monad? ask seems to be the equivalent of get, and local seems to be the equivalent of put.
23:02:02 <Fuuzetsu> I'm getting ‘agda: error while loading shared libraries: libHSAgda-2.3.2.1-ghc7.6.3.so: cannot open shared object file: No such file or directory’ even though that file is in ‘/home/shana/.cabal/lib/Agda-2.3.2.1/ghc-7.6.3’. What gives?
23:02:13 <nwf> (esp. in early stages of the compiler, during name resolution, I think this would be handy.)
23:02:44 <nwf> Fuuzetsu: Unfortunately, "cannot open shared object file" doesn't mean "can't read literal bytes from file" but "cannot transitively resolve dependencies", too.
23:02:57 <nwf> As much as I hate to suggest it, you might consider strace.
23:03:12 <shachaf> strace++
23:03:31 <shachaf> nwf: You might be able to use prisms here?
23:03:37 <zvrba> Fuuzetsu: 32/64-bit mismatch? possibly missing dynamic loader?
23:03:52 <zvrba> strace and/or ldd .
23:04:00 <mcstar> just tell ld the path ?
23:04:00 <nwf> shachaf: I think I need something with an Eq instance, and tragically -> isn't one of those yet.
23:04:09 <shachaf> nwf: E.g. data T = Foo Int Char | Bar Bool String; makePrisms ''Foo
23:04:24 <shachaf> Oh, wait, never mind.
23:04:34 <shachaf> It doesn't actually solve your problem, it solves a different one.
23:04:42 <nwf> Yes.  A closely related one, to be sure.
23:05:20 <mcstar> ofan: i hope i didnt bring bad news :D
23:05:55 <Fuuzetsu> I'm not sure what to look for in the strace log. It shows a lot of ‘No such file and directory’.
23:05:55 <nwf> Well, in any case, I think I need to go rewrite a bunch of my code to be increasingly parametric.  (Here's to inlining.)
23:06:05 <Saizan> Moggle_: it's pretty different because if you have "foo >> bar" in the state monad then foo can alter the state bar sees, while with reader it can't
23:06:17 <ofan> mcstar: no, qml is good for the integration actually
23:06:26 <Saizan> Moggle_: you'd have to pass bar as an argument of foo so that it can be called inside a local
23:07:31 <Saizan> (a CPS transform, basically)
23:07:34 <Moggle_> Saizan: perhaps I misunderstand local then? i thought local changes the environment for all the following actions.
23:08:02 <Moggle_> Saizan: I mean, they seem like get  = ask, put s = local (const s)
23:08:07 <shachaf> nwf: I wonder whether GHC.Generics will let you do something like Data.Data but with more safety here.
23:08:35 <shachaf> nwf: In the worst case you could probably write a bit of TH to do it yourself. I don't know that this exists anywhere already.
23:08:58 <Moggle_> Saizan: oh nevermind I derped hard and misread the type signature on local
23:09:02 <Moggle_> Saizan: sorry!
23:09:31 <augur> is it better to define separate types for subtley different variants on the same thing, and thereby reproduce plenty of code, or should i fuse the types and only use the relevant portions in the relevant contexts?
23:09:49 <johnw> augur: I had that same quandary recently
23:09:56 <arkeet> I don't understand the question.
23:10:00 <augur> johnw: in this case its exactly one constructor
23:10:11 <augur> arkeet: im writing a programming language AST type
23:10:18 <augur> but i want to have some pattern matching
23:10:21 <augur> should i write
23:10:27 <johnw> augur: I went with a tagged type, and make as much of the code general as possible by being polymorphic over the tag
23:10:36 <johnw> plus a type class when I needed to access special behavior
23:10:37 <augur> data AST = ...   and   data ASTPattern = ...
23:10:53 <augur> where the only difference is a new PatternVar constructor?
23:11:09 <augur> this is pattern matching for syntactic unification in the metatheory, not internally
23:11:09 <johnw> can you make one of your types be included by the other?
23:11:23 <arkeet> I would use one type, with a type parameter or something to distinguish the two.
23:11:27 <arkeet> probably a GADT
23:11:31 <augur> johnw: you mean a GADT then
23:11:55 <johnw> augur: well, I was thinking that the type with the extra constructor would "wrap" the base type
23:12:02 <augur> i cant make one included in the other because the variables show up everywhere
23:12:10 <johnw> because really you're augmenting a set with an additional operation
23:12:18 <johnw> ah
23:12:41 <augur> johnw: i mean basically like..
23:12:42 <arkeet> so how about that type parameter?
23:12:50 <augur> data AST = AST Name [AST]
23:12:50 <augur> vs
23:13:09 <augur> data ASTPat = ASTPat Name [ASTPat] | ASTVar Var
23:13:23 <augur> close, but not the same. ASTVars show up in recursive positions
23:13:33 <augur> technically ones a subset of the other, but not in a trivial way
23:13:38 <arkeet> data AST a = AST Name [AST a] | ASTVar a
23:13:42 <arkeet> and take a to be Void or Var depending on which
23:13:50 <arkeet> or something
23:14:35 <arkeet> but you might end up wanting a GADT anyway.
23:15:03 <arkeet> I would. I don't like the way Void and Var leak out into the type like that.
23:15:09 <johnw> what about data AST f = AST Name [f]; data ASTPat = AST ASTPat | ASTVar Var?
23:15:12 <augur> my instinct is honestly to just duplicate stuff
23:15:40 <augur> johnw: hm
23:15:49 <arkeet> johnw: that looks unwieldy
23:16:04 <augur> but then i'd need nasty fixes for boring AST
23:16:18 <augur> i guess ..
23:16:34 <johnw> well, that suggested itself to me because your problem started sounding a lot like functor fixpoints
23:16:38 <arkeet> I don't see what's worse about my suggestion.
23:16:55 <augur> data ASTF f = AST Name [f] ; type AST = ASTF AST
23:16:57 <augur> does that work?
23:17:00 <johnw> yes
23:17:00 <augur> probably not
23:17:20 <arkeet> doesn't.
23:17:21 <johnw> any paper on recursion schemes has a pattern just like that :)
23:17:22 <arkeet> that's an infinite type
23:17:28 <johnw> type AST = Fix (ASTF AST)
23:17:30 <augur> johnw: yes but not like this
23:17:40 <augur> you need an actual fix operator
23:17:42 <johnw> true, not just like that
23:17:45 <arkeet> in a type synonym, the thing you're defining can't appear on the right.
23:17:50 <johnw> ah
23:17:59 <johnw> good point
23:18:33 <augur> im just going to duplicate for now
23:18:40 <arkeet> did anyone even see mine. :(
23:18:41 <augur> its only like 10 lines of code anyway >_>
23:21:28 <johnw> augur: https://gist.github.com/5907132
23:22:27 <arkeet> I don't see the point of using Fix for AST but not ASTPat.
23:22:30 <arkeet> that just seems weird.
23:22:33 <augur> johnw: yes i know
23:22:48 <arkeet> augur: did you see what I did
23:22:51 <johnw> arkeet: maybe that's called for
23:23:05 <arkeet> johnw: mostly I don't see the point of using Fix.
23:23:33 <johnw> arkeet: because he wants AST to be recursive on AST, and ASTPat to recurse on ASTPat
23:23:37 <augur> arkeet: its a weird solution
23:23:42 <johnw> so we need a way to parameterize the recursion
23:23:46 <chrisdone> anyone know if it's possible to use the [e|…|] quasiquoter and print out verbatim what string was consumed?
23:23:47 <johnw> if it's going to share a common base type
23:23:51 <arkeet> augur: it's probably a bit better to use a GADT
23:25:29 <arkeet> possibly with some data kind parameter thing.
23:25:36 <augur> arkeet: i think thats probably best :\
23:25:47 <arkeet> why :\ ?
23:28:32 <shachaf> Proofs with diagrams etc. seem confusing because the order in which you draw the diagram matters.
23:30:15 * hackagebot rehoo 0.3.0 - Rebuild default.hoo from many .hoo files in the current directory  http://hackage.haskell.org/package/rehoo-0.3.0 (JohnWiegley)
23:30:18 * hackagebot git-all 1.4.0 - Determine which Git repositories need actions to be taken  http://hackage.haskell.org/package/git-all-1.4.0 (JohnWiegley)
23:31:19 <arkeet> shachaf: how so? you're supposed to wave your hands after you finish drawing it.
23:31:35 <arkeet> maybe.
23:31:39 <arkeet> depends on the kind of thing you're doing I guess.
23:34:50 <shachaf> arkeet: Probably it's less so if you watch someone draw it rather than just looking at the finished diagram.
23:35:15 * hackagebot git-monitor 1.1.0 - Passively snapshots working tree changes efficiently.  http://hackage.haskell.org/package/git-monitor-1.1.0 (JohnWiegley)
23:35:20 <shachaf> arkeet: Anyway it seems that quantification is missing. We have some fixed X, such that for all Y, there exists a Z, ...
23:35:46 <arkeet> ??
23:36:15 <SrPx> Just wondering, don't kill me - why is annotating types considered a good practice? Don't it go against the whole purpose of having such a solid type inference system to remove noise?
23:36:53 <arkeet> types serve as something like a check on your code.
23:37:04 <augur> arkeet: ok, ive done the gadt thing. x.x
23:37:10 <arkeet> maybe you accidentally wrote some thing that gets a different type inferred than what you meant.
23:37:10 <johnw> SrPx: definitely annotate top-level definitions, annotating anything else is only for when clarity is needed/required
23:37:22 <arkeet> yes, I'm talking about top-level things
23:37:47 <SrPx> johnw that's what I mean, top level annotations
23:37:51 <Saizan> SrPx: it's checked documentation, localizes type errors, thinking of types first can help design of implementation, ...
23:38:05 <arkeet> yeah that.
23:38:09 <Saizan> SrPx: but i do often just get emacs haskell-mode to fill in the inferred type for me
23:38:35 <SrPx> Saizan: that's cool, is this possible on VIM?
23:38:51 <Saizan> probably, not a vim user though
23:39:49 <shachaf> > ((((+) :: Int -> Int -> Int) (1 :: Int)) :: Int -> Int) (2 :: Int) :: Int
23:39:50 <lambdabot>   3
23:40:16 * hackagebot afis 0.1.0 - Anti-forensic Information Splitter  http://hackage.haskell.org/package/afis-0.1.0 (VincentHanquez)
23:43:03 <shachaf> ((((+) :: (->) (Int :: *) (((->) :: * -> * -> *) (Int :: *) (Int :: *) :: *)) (1 :: (Int :: *))) :: ((((->) :: * -> * -> *) (Int :: *) :: * -> *) (Int :: *) :: *)) (2 :: (Int :: *)) :: (Int :: *) -- OK, I'm not going to finish it.
23:46:17 <arkeet> oh gee.
23:46:38 <arkeet> shachaf: you forgot to annotate one of the (->)s
23:46:51 <arkeet> and also the partial applications of it
23:47:12 <arkeet> well whatever.
23:47:14 <arkeet> write a program to do it
23:48:28 <shachaf> arkeet: "OK, I'm not going to finish it."
23:48:40 <shachaf> That's as much as I was willing to do by hand. I know it's not done.
