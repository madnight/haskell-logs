00:00:40 <shachaf> Now that you know that a traversal/fold can refer to zero or more values, you know that toListOf, or (^..) (same thing), just gives you a list of all of them.
00:02:31 <MercurialAlchemi> shachaf: right
00:03:09 <shachaf> A lens automatically turns into a traversal/fold/etc. when you use it as one.
00:03:24 <MercurialAlchemi> back in a little while
00:04:51 <mstksg> does anyone know if there is a compiler that can magically parallelize haskell code and stuff on gpu's
00:04:59 <mstksg> like things like map
00:07:13 <Ghoul_> "magically" sounds ineffecient
00:08:29 <mstksg> i mean if there is any language that can, haskell is one where parallizable and non-parallelizable things are inferrable from the type system
00:08:31 <Ghoul_> usually humans can tell if the latency to the GPU and back is worth it or not, but its hard for machines to do that. If you're not looking for a magic compiler though, I think accelerate does something like what you want http://hackage.haskell.org/package/accelerate
00:09:51 <kamatsu> mstksg: Accelerate is the closest thing
00:10:06 <mstksg> thanks :)
00:10:14 <kamatsu> mstksg: but automatic parallelism of any shape is a pipe dream
00:10:52 <Ghoul_> well, intel implemented it nicely in C++ with pragmas
00:11:23 <Gracenotes> the best type of automatic parallelism is parallelism.
00:11:23 <Ghoul_> It's not entirely "automatic" but pragmas are about as automatic as one could wish for without negative side effects.
00:17:33 <alexander__b>  /b 44
00:17:37 <alexander__b> ups
00:37:20 <external-reality> Good morning all. Time for another fine day of Haskell programming!
00:39:20 <kamatsu> it's not morning for me
00:41:47 * Lethalman just released is first haskell lib yesterday!!!
00:41:49 <Lethalman> *his
00:50:28 <Ghoul_> @pl (\x -> x == '\r')
00:50:29 <lambdabot> ('\r' ==)
01:00:45 <Ghoul_> > ord '‚òÉ'
01:00:49 <lambdabot>   mueval-core: Time limit exceeded
01:00:54 <Ghoul_> > ord '‚òÉ'
01:00:58 <lambdabot>   mueval-core: Time limit exceeded
01:01:02 <supki> @pl \x -> x ??? '\r'
01:01:02 <lambdabot> (??? '\r')
01:01:26 <Ghoul_> :t (???)
01:01:27 <lambdabot>     Not in scope: `???'
01:01:27 <lambdabot>     Perhaps you meant `??' (imported from Control.Lens.Combinators)
01:01:54 <supki> I've checked @pl being clever with ==
01:02:11 <shachaf> It's clever with all sorts of things.
01:04:02 <Ghoul_> how big is a Char in bytes?
01:04:16 <Ghoul_> I thought it was 8, but apparently you can ord a snowman
01:04:19 <Ghoul_> :t ord
01:04:20 <lambdabot> Char -> Int
01:04:31 <Ghoul_> Not in this channel though. This lambdabot wont eat a snowman
01:04:37 <Ghoul_> but my other one does.
01:05:07 <external-reality> Good <insert word describing a fuzzy identification of the current time of day for whatever time zone you are currently in> all. It time to program and in Haskell again!
01:05:08 <Ghoul_> /s/8/1/
01:06:04 <Sonderblade> why would it be 8 bytes? that would be wasteful
01:07:24 <quicksilver> well how much space you need to represent a char and how much space it takes up are different questions
01:07:36 <quicksilver> Char is a unicode code point
01:09:09 <quicksilver> in practice I think in current haskell implementations it's only BMP
01:09:17 <quicksilver> so no emoji? but the snowman is in BMP
01:09:29 <shachaf> quicksilver: Hmm? Why only BMP?
01:09:35 <quicksilver> That means it require 4 bytes in at least some cases.
01:09:44 <quicksilver> shachaf: history? I could be wrong.
01:09:59 <shachaf> I'm pretty sure it supports all of Unicode.
01:10:03 <shachaf> > maxBound :: Char
01:10:04 <lambdabot>   '\1114111'
01:10:20 <quicksilver> > ord (maxBound :: Char)
01:10:21 <lambdabot>   1114111
01:11:09 <quicksilver> that's very much BMP, no?
01:11:18 <quicksilver> > 0x10000 > 1114111
01:11:20 <lambdabot>   False
01:11:29 * quicksilver looks confused and rejig head
01:11:35 <quicksilver> clearly not
01:11:42 <shachaf> > 17*2^16
01:11:43 <lambdabot>   1114112
01:11:47 * quicksilver nods
01:12:04 <quicksilver> sorry, no coffee yet
01:12:07 <shachaf> Anyway Char in GHC will be stored as a full machine word (and so will Word8 etc.).
01:12:19 <quicksilver> that was going to be the next part of the explanation
01:12:24 <quicksilver> but I'm not sure anyone is listening any more :)
01:12:24 <Gracenotes> 2 even
01:12:26 <Ghoul_> hmm, okay.
01:12:53 <shachaf> E.g. Text stores codepoints as packed UTF-16 (and *does* handle all of Unicode).
01:12:57 <Ghoul_> then its safe for me to make the unicode predicates with Char -> Bool
01:13:21 <shachaf> Char can even represent some "codepoints" that are invalid Unicode, like 0xD800.
01:13:47 <quicksilver> I'm not sure that ability is guaranteed by the standard, shachaf
01:14:05 <Ghoul_> if wikipedia shows a unicode as U+00A0 is that the same as \160
01:14:08 <shachaf> True enough. I should have qualified that I mean GHC Char.
01:14:12 <Ghoul_> (where 0xA0 == 160)
01:14:26 <shachaf> > chr 0xA0
01:14:27 <lambdabot>   '\160'
01:15:05 <Ghoul_> > char 0x20
01:15:06 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
01:15:06 <lambdabot>    arising from the literal `3...
01:15:12 <Ghoul_> > chr 0x20
01:15:13 <lambdabot>   ' '
01:39:45 <Ghoul_> > chr 0x85
01:39:46 <lambdabot>   '\133'
01:41:32 <b6> i'm not sure i'll ever like octal. there, i said it
01:42:02 <mauke> there's only one use for octal: unix file permissions
01:43:16 * b6 carves own tombstone that says HE DIDN'T LIKE OCTAL
01:43:31 <quicksilver> b6: incidentally, \133 isn't octal. Just in case you thought it was.
01:44:06 <mauke> > ord '\123'
01:44:07 <lambdabot>   123
01:44:15 <b6> oh, you're right. what does \ notation mean there?
01:44:23 <quicksilver> it's a decimal escape
01:44:35 <quicksilver> the code point number is in standard decimal notation
01:44:53 <b6> oh. i thought the world decided on \ublahblabh or something.
01:45:00 <quicksilver> so the way to write chr 1234 in a string is "Foo\1234Blah
01:45:01 <mauke> 1) it didn't  2) that's hex
01:45:14 <b6> mauke: my blahblahb represented numbers.
01:45:20 <quicksilver> haskell's concrete syntax is quite old.
01:45:23 <b6> oh, \u only takes hex?
01:45:25 <mauke> b6: then you're wrong
01:45:37 <b6> mauke: you're a friendly dude. let's talk later. a long time later.
01:45:47 <quicksilver> It might even predate the \u notation although I'm not sure.
01:46:23 <mauke> perl doesn't use \u nor decimal escapes
01:46:37 <mauke> but I think it recently grew \o... for octal
01:48:57 <mauke> I really like decimal escapes by default
01:49:03 <mauke> does any other language do this?
01:49:42 <shachaf> Why do you like it?
01:49:46 <adnap> Hi
01:50:16 <adnap> What is good way to get all combinations of pairs from a list?
01:50:37 <mauke> adnap: can you reuse elements?
01:50:44 <mcstar> depends, finite or infinite list?
01:50:49 <mauke> that is, will [a,b,c] give rise to (a,a)?
01:51:01 <adnap> mauke: No
01:51:05 <mauke> are pairs ordered? i.e. do you want both (a,b) and (b,a)?
01:51:15 <adnap> *combinations*
01:51:22 <adnap> i.e. No
01:52:05 <mauke> shachaf: I think it's nice because it mirrors normal numeric literals. we have 123, 0x123, 0o123, so '\123' should be decimal as well
01:52:05 <adnap> mcstar: Infinite would be good because it would preserve laziness
01:52:30 <mauke> shachaf: and also because I find it easier to think in decimal, and octal is the worst default
01:53:02 <adnap> The only dumb think I can think of is to compute all pairs and then filter (a,a) and one of (a,b) and (b,a)
01:53:06 <adnap> *thing
01:54:08 <mauke> requires equality
01:54:17 <mauke> what should happen with [a,a,b]?
01:54:18 <adnap> Yeah
01:54:27 <adnap> It doesn't matter
01:54:34 <shachaf> mauke: I think it's kind of irritating because I need to know two different values for the important codepoints.
01:54:41 <quchen> adnap: Have a look at the permutation package, it has a "Choose" module for combinations.
01:54:44 <quchen> @where permutation
01:54:44 <lambdabot> I know nothing about permutation.
01:54:45 <shachaf> Not irritating as a fundamental thing, just because everything else uses hexadecimal.
01:54:50 <quchen> @hackage permutation
01:54:50 <lambdabot> http://hackage.haskell.org/package/permutation
01:54:52 <quicksilver> [ (a,b) | a <- xs, b <- xs \\ [a], a < b ]
01:55:01 <mauke> shachaf: but that's easily available with '\x...'
01:55:04 <adnap> mauke: I think ideally it would get rid of duplicates
01:55:12 <quicksilver> adnap: ^^ that's a fairly elementary approach. It will force Eq and Ord.
01:55:14 <mauke> shachaf: also, you could do what perl does and use names instead of numbers :-)
01:55:22 <mauke> '\N{EURO SIGN}' :-)
01:55:34 <adnap> quicksilver: What's wrong with that?
01:55:34 <shachaf> mauke: Yes, but show gives me decimals.
01:55:39 <shachaf> > "Œª"
01:55:41 <lambdabot>   "\955"
01:55:42 <adnap> quicksilver: And why ord?
01:55:46 <adnap> *Ord
01:55:47 <mauke> true
01:55:53 <mcstar> > let comb (x:xs) = map ((,)x) xs ++ comb xs ; comb [] = [] in comb [1..5]
01:55:54 <lambdabot>   [(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
01:56:00 <mcstar> i think this is one way
01:56:43 <mauke> > let comb (x:xs) = map ((,)x) xs ++ comb xs ; comb [] = [] in (2,3) `elem` comb [1..]
01:56:47 <lambdabot>   mueval-core: Time limit exceeded
01:56:52 <adnap> :/
01:57:16 <mcstar> i didnt say it worked for infinite lists
01:58:11 <quicksilver> adnap: Ord for a cheap way to eliminate permuted pairs
01:58:20 <quicksilver> adnap: by forcing a < b
01:58:33 <adnap> Ah, so it's not necessary
01:58:36 <quchen> quicksilver: It will also eliminate (a,a) from the combinations of [a,a,b] though
01:58:46 <mcstar> but you need sorted lists for inputs
01:59:11 <external-reality> I read an article online that explains phantom type through a date validation example. Is it a good idea to use phantom types for statically typing valid data?
01:59:18 <quicksilver> quchen: quite so.
02:00:12 <adnap> Well, none of these solutions are very satisfying
02:00:32 <mcstar> you will just have to write your own then
02:00:42 <quchen> adnap: Are you looking for a nice algorithm or do you just want to get it done?
02:00:43 <mcstar> i dont think it will pose any problems after this
02:00:52 <adnap> I am struggling to come up with an answer
02:01:14 <adnap> quchen: I don't know. I'm torn
02:01:59 <quchen> Every time I worry about algorithms like these I think of TAOCP and that it has an entire volume on the issue.
02:02:11 <quchen> (Combinatorics, that is.)
02:13:03 <Ghoul_> @pl (\x -> a x || b x || c x )
02:13:07 <lambdabot> liftM2 (||) a (liftM2 (||) b c)
02:13:07 <lambdabot> optimization suspended, use @pl-resume to continue.
02:16:28 <prophile> @hoogle (Arrow a) => a b c -> a (r -> b) (r -> c)
02:16:29 <lambdabot> No results found
02:16:39 <adnap> mcstar: It seems to work. I'm trying to understand it now
02:16:54 <mcstar> i know it works, i wouldnt give you non working code
02:17:28 <adnap> It keeps duplicates, which does not seem ideal, but I won't have duplicates for my program
02:20:03 <mcstar> you can put your list into a set to remove duplicates quickly
02:20:15 <mcstar> *turn it into
02:20:53 <adnap> Man, that was awful
02:21:18 <adnap> mcstar: Thank you
02:21:25 <mcstar> np
02:24:02 <quchen> mcstar: You can also write your own nub based on Set. It'll work on infinite lists then.
02:24:06 <Ghoul_> is there a more elegant way to do something like this : http://paste.tryhaskell.org/90755
02:24:25 <Ghoul_> (without complicating it for the compiler and relying on unrolling and such)
02:24:56 <quchen> Ghoul_: isSpace already includes \t, \n, \r, \f, \v
02:25:28 <quchen> "[isSpace] Returns True for any Unicode space character, and the control characters \t, \n, \r, \f, \v."
02:25:31 <Ghoul_> isSpace uses some foreign stuff. I wasn't sure what it included, so I went exactly by the spec and just made my own
02:26:37 <supki> @ty \fs x -> any ($ x) fs
02:26:38 <lambdabot> [a -> Bool] -> a -> Bool
02:26:47 <quchen> If you want to check only for a handful of characters, then you could just pattern-match them, along the lines of  isSpace '\n' = True; isSpace _ = False
02:26:58 <quchen> But I think the built-in isSpace is just what you want.
02:41:12 <ptek> did anyone of you had to ever serialize something like (Maybe Integer) to json? Do you have any good ideas for doing that so one does not loose the Nothing values?
02:44:18 <taylorgb_> Can't you just use an empty object for Nothing?
02:45:16 <MercurialAlchemi> ptek: not really, unless you embed some metadata to say which parts of your data structure is nullable
02:45:32 <prophile> nil?
02:45:41 <prophile> or null or whatever it is
02:46:00 <shachaf> If you use one of those things for Maybe Integer, what do you do with Maybe (Maybe Integer)? :-)
02:46:36 <prophile> point
02:46:41 <prophile> make it an array then
02:46:43 <ptek> hrm
02:46:46 <prophile> with zero or one elements
02:47:15 <arcatan> that's pretty much what Maybe is
02:47:27 <MercurialAlchemi> prophile: well, you can tell when you decode the JSON that null should be Nothing, but there is nothing to tell you that "f": 1 is a Maybe Integer instead of a plain Integer
02:47:47 <mellson> is there a central place with open source projects in Haskell that needs some extra hands?
02:48:59 <MercurialAlchemi> ptek: you could make it an object: { "just": 1 } | { "nothing": null }
02:50:04 <MercurialAlchemi> (of course you gain two magic field values this way...)
02:50:12 <MercurialAlchemi> field names rather
02:50:33 <ptek> MercurialAlchemi: that was my initial idea as well. But now I also like the idea of prophile‚Ä¶ I will try both and report what worked better in the end.
02:51:13 <Hafydd> The array seems pretty elegant, assuming you don't want to tag it with type information.
02:53:03 <MercurialAlchemi> ptek: it depend on your use case, if you want to automatically deduce what kind of data structure it is, you're screwed with an array, because you can't tell the difference with a bona fide array of integers (and it's not particularly apparent when somebody not you looks at the JSON dump)
02:56:22 <ptek> MercurialAlchemi, thats true. And parsing of this field from json using aeson library would work with (.:? "just") pretty well
02:58:40 <ptek> Thanks for now! :)
03:01:01 <mcstar> shachaf: {} | {"just": x}, why would Maybe (Maybe Integer) a problem? {}=Nothing, {"just":{}} = Just Nothing, {"just":{"just":x}}=Just (Just x)
03:01:02 <Ghoul_> When the spec says "any uppercase or title case unicode letter" does it include things like "MATHEMATICAL FRAKTUR CAPITAL F" ?
03:01:28 <shachaf> What does GHC say?
03:01:33 <shachaf> Probably it implements the spec there.
03:01:42 <quicksilver> Ghoul_: you have to check the unicode properties of that character
03:01:52 <quicksilver> unfortunately I don't know any easy way to look them up
03:01:56 <quicksilver> maybe there is some website
03:02:07 <Ghoul_> I have one here titled 'Unicode Characters in the 'Letter, Uppercase' Category'
03:02:13 <Ghoul_> so it would include all these then?
03:02:13 <shachaf> > generalCategory 'ùîâ'
03:02:14 <lambdabot>   UppercaseLetter
03:02:18 <shachaf> It's an uppercase letter.
03:02:23 <Ghoul_> Awesome, thanks.
03:02:33 <shachaf> But the easy way to check would have been to write "data Foo = <yourletter>abc"
03:03:21 <mcstar> btw, doesnt capital mean uppercase?
03:03:26 <quicksilver> I was under the impression that some of the 'MATHMETICAL' ones are not Letters even though they look like them
03:03:34 <quicksilver> but I'm not sure on that.
03:06:21 <Ghoul_> well, lots of these are ?
03:06:25 <Ghoul_> but I'm not gonna argue.
03:06:53 <quicksilver> well, only 'some' not most or all. And I could be wrong anyhow :)
03:07:27 <benmachine> mellson: I don't know of any such place, but possibly there is one; I've a few ideas if there isn't :P
03:08:06 <shachaf> There is such a place.
03:08:11 <shachaf> But I don't remember what it's called.
03:08:18 <shachaf> chrisdone made a website for it.
03:10:43 <benmachine> there's this http://www.reddit.com/r/haskell_proposals/
03:18:42 <mellson> thank you!
03:27:21 <Ghoul_> Is this O1 ? http://hackage.haskell.org/packages/archive/unicode-properties/3.2.0.0/doc/html/src/Data-Char-Properties-GeneralCategoryData.html#getGeneralCategory
03:28:00 <quicksilver> Ghoul_: O1?
03:28:06 <Ghoul_> To me it looks like a list, but I'm pretty sure that'd be O(n) because of the nature of linked lists
03:28:29 <shachaf> What'd be O(n)?
03:28:40 <Ghoul_> Well, see the huge lookup list
03:28:40 <quicksilver> the code there stuffs that list into an array
03:28:47 <quicksilver> and the array is used for actual accesses isn't it?
03:28:53 <Ghoul_> is the list still created?
03:29:00 <Ghoul_> or is there some trick that means no intermediate list
03:29:26 <quicksilver> I would expect that the code for list is present in the exeuctable
03:29:29 <shachaf> It's O(1) because there are < 1114112 code points.
03:29:32 <quicksilver> but it won't stick around in memory
03:29:47 <quicksilver> because it can be GCed since it's no longer referenced
03:30:41 <Ghoul_> however "theArray" creates the array at runtime, right?
03:31:03 <quicksilver> that's a hard question to answer pedantically correctly
03:31:07 <quicksilver> the compiler might be clever
03:31:18 <quicksilver> but to a first naive approximation - yes, it's created the first time it is accessed.
03:31:24 <Ghoul_> so every call would iterate all of the list into the list, so that'd be O(n). Whether the compiler catches this is really what I was wondering
03:31:34 <quicksilver> no, every call doesn't iterate all
03:31:36 <quicksilver> only the first
03:31:40 <quicksilver> after than you have an array
03:31:45 <benmachine> once the work is done it stays done
03:32:35 * shachaf notes that this isn't the implementation GHC uses.
03:33:07 <Ghoul_> Any idea where the GHC one is?
03:33:41 <Ghoul_> Oh, found it. Uses the foreign C calls.
03:36:44 <hpaste> jjohnsson pasted ‚ÄúList of random vectors (not working)‚Äù at http://paste.tryhaskell.org/90757
03:37:18 <jjohnsson> I'm trying to understand how to create a list of random vectors. ^ That is my attempt, but it's not working. Could anyone help me on the right track?
03:38:40 <mauke> "it's not working" is not a problem description
03:39:32 <quicksilver> jjohnsson: what does that code do?
03:39:49 <jjohnsson> Okay. It compiles, but hangs in what seems to be an infinite loop.
03:39:59 <mcstar> gives you a 10 element list of 2 element vectors probably
03:40:24 <quicksilver> I have a feeling you can't generate infinite lists in Mersenne's Rand monad
03:40:34 <mauke> randomList recursively calls randomList
03:40:46 <quicksilver> it probably does work behind scenes which means it can't lazily generate like that
03:41:22 <jjohnsson> mcstar: that's what I wanted it to do, but it doesn't. Haskell noob, btw.
03:41:41 <quicksilver> you should just generate the number of elements you want
03:41:46 <mcstar> how many vectors do you want?
03:41:54 <mauke> :t randoms <$> newStdGen
03:41:55 <lambdabot> Random a => IO [a]
03:42:03 <quicksilver> replicateM is a handy primitive.
03:42:19 <jjohnsson> mcstar: that would depend on the results I get.
03:42:32 <mcstar> cause i have a feeling, you would be better off if you had transposed your vectors
03:42:35 <quicksilver> simplify randomList so it just generates a single vector
03:42:46 <quicksilver> and call it 10 times with replicateM 10
03:43:22 <jjohnsson> perhaps I should generate lists in "chunks", then. Not sure if that is better than just creating the vectors one by one, though.
03:43:33 <jjohnsson> quicksilver: I will try that.
03:43:41 <mcstar> i just dont see the point in 2 element vectors
03:44:16 <mcstar> gsl can generate you arrays of random numbers quickly btw
03:44:24 <jjohnsson> mcstar: this is just the beginning of something bigger. And, honestly, I don't really know what I'm doing. I intend to learn as I go.
03:44:30 <mcstar> idk whether the haskell binding supports that
03:45:20 <mcstar> jjohnsson: while the program 'hangs' does it allocate massively?
03:45:50 <mcstar> (im just curious, the others have already provided you with solutions_
03:46:04 <jjohnsson> mcstar: yes, it does.
03:48:33 <mcstar> data R a = R !a {-# UNPACK #-}!PureMT
03:48:44 <mcstar> this is what makes this random monad strict i guess
03:55:00 <jjohnsson> thanks, all, for your help. I will continue tinkering.
04:17:36 <Ghoul_> if I have an overloaded bytestring
04:17:51 <Ghoul_> is it stored as a C-like string literal in the binary, or does it still create a list when I first use and it get packed into a ByteString ?
04:18:34 <shachaf> Binaries don't have C-like string literals.
04:19:26 <shachaf> Whatever the question is precisely, it sounds like a good candidate for figuring out on your own. :-)
04:20:13 <shachaf> Tools: ghc -ddump-simpl, -ddump-cmm, -S, -c, ..., objdump, ...
04:20:40 <Ghoul_> hmm
04:23:28 <quicksilver> GHC does use literal Addr# values in some cases
04:23:54 <quicksilver> I don't recall if OverloadedStrings instance for Text is one of those.
04:24:02 <quicksilver> Ghoul_: are you sure this really matters, though :)
04:24:15 <quicksilver> in the absence of other information it sounds a bit like premature optimization
04:24:23 <quicksilver> or at least premature worrying about optimization.
04:24:42 <shachaf> I agree with quicksilver.
04:25:24 <shachaf> The answer (probably) doesn't matter, but the skills used for figuring out the answer are very useful. Therefore I recommend the exercise of figuring it out.
04:29:30 <merijn> I think the basic question is "Will GHC convert overloaded strings to constant values", which is a specialised case of "how much constant folding does GHC do?" (not enough! is the answer >.>)
04:30:18 <mauke> inb4 supercompilation
04:31:40 <merijn> I don't think GHC has much support in terms of compiling binary data into your executable, which is a shame
04:32:38 <shachaf> "foo" will get compiled into something different from ['f','o','o']
04:33:29 <shachaf> In particular it'll be stored as a "C string" and unpacked at runtime.
04:34:48 <quicksilver> this ticket - which discusses possible improvements - describes the current behaviour as a side-effect :http://ghc.haskell.org/trac/ghc/ticket/5218
04:36:15 * shachaf vaguely wonders how http://mainisusuallyafunction.blogspot.com/2010/09/executing-bytestring.html works, given a non-executable heap.
04:37:48 <mauke> http://mauke.hopto.org/stuff/haskell/hell.hs
04:37:52 <mauke> why bother with bytestrings?
04:38:33 <shachaf> Well, I'm particularly wondering why that ByteString version works.
04:38:51 <shachaf> Maybe not quite wondering enough to step through the execution. :-)
04:39:31 <shachaf> It should be malloc()ing the ByteString and generating at runtime, right?
04:39:47 <merijn> mauke: I'm impressed if you managed to write that in the timespan of this conversation :p
04:40:10 <mauke> Jun 29  2007 hell.hs
04:40:23 <mauke> three years older than the blog post
04:41:45 <mauke> ghc 6.4 or 6.6 - good times
04:44:30 <merijn> We should organise an Underhanded Haskell Contest...
04:46:37 <quchen> merijn: That would be interesting.
04:47:09 <quchen> On a different level than the C contest though. It's not as easy to forget a comma.
04:47:26 <quchen> But it's very easy to switch arguments or mess up a base case :-)
04:47:45 <Taneb> I would definitely participate
04:48:07 <shachaf> The interesting entries to the underhanded C contest were underhanded logic, not underhanded use of the language, I think.
04:50:12 <merijn> The contest is to make malicious code look like obvious and safe code
04:50:22 <merijn> Whether that's through logic, language features or anything
04:50:58 <shachaf> Yes.
04:51:29 <merijn> The question is, how easy is it to do that in Haskell without raising suspicion. I would consider missing top level signatures a red flag, so then you have to fit your malicious behaviour within the type
04:51:44 <merijn> Although obfuscated haskell contest would be amusing too
04:51:52 <mauke> just move your crucial logic into local functions
04:52:06 <mauke> people usually don't write type signatures for those
04:52:22 <Spockz> When was this page made, or updated: http://www.haskell.org/arrows/index.html ?
04:52:23 <Taneb> merijn: there were a couple of obfuscated haskell competitions
04:52:40 <quchen> merijn: Reminds me of that Haskell question on SO "deobfuscate my code"
04:52:57 <quchen> merijn: I think if you write everything in SKI you can go a long way already
04:53:02 <mauke> http://www.haskell.org/haskellwiki/Obfuscation
04:53:18 <quchen> http://stackoverflow.com/questions/12659951/how-does-this-piece-of-obfuscated-haskell-code-work
04:53:41 <quicksilver> although the underhanded contest requires quite a subtle kind of obfuscation
04:53:57 <Taneb> Heck, I've written some very obfuscated Haskell
04:54:01 <quicksilver> to disguise unexpected behaviour behind what appears to be clear code
04:54:10 <shachaf> The winning entry in the 2008 was a good example.
04:54:14 <shachaf> http://notanumber.net/archives/54/underhanded-c-the-leaky-redaction
04:54:59 <mauke> "Haskell is an obscure, hated and mostly disused esoteric programming language. Its design was greatly influenced by the work of that computer science luminary, Dr. Pointer C. Database."
04:55:00 <shachaf> There isn't really any C trickiness. The code is clear and simple.
04:56:47 <quchen> I love the 2009 winner. http://underhanded.xcott.com/?page_id=22
04:57:16 <quchen> Especially the deniability as a simple bug is great.
04:57:17 <RichyB> quicksilver: I wonder how well you could do by making information leak out of a Monad class implementation that subtly fails to satisfy the laws. :)
05:58:45 <chrisdone> byorgey: i /host/ hpaste. i hosted it on a linode vm for two years, i was paying a lot for linode, i switched to a hetzner dedicated host, moved all the services onto that, and made the linode host be a reverse proxy to the new host. i carefully did this two weeks ahead of the time i would be shutting down the linode: that gave two weeks for the owner of the domain to point it from the old host to the new host (a 5 minute task), and
05:58:45 <chrisdone> hpaste users wouldn't notice a difference. but in two weeks i had no reply on it
05:58:45 <chrisdone> byorgey: rather than be tied to one person, i thought instead i will approach the haskell committee, which represent the community, to own the domain, this will make them more responsive to change and able to migrate to another host if i get hit by a bus. amusingly, the same problem applies now. i've been waiting 11 days so far for galois to make paste.haskell.org. it seems to me that no one really cares much about hpaste, which
05:58:45 <chrisdone> disappoints me
06:01:00 <chrisdone> other domains available are: hspaste.org, hcode.org, pastehs.org, hpaste.it
06:03:27 <chrisdone> also lpaste.* (as in "lambda paste") are available
06:05:19 <benmachine> chrisdone: I care about hpaste!
06:05:56 <mauke> xn--paste-1be.org
06:06:04 <Hugh> hi y'all - I need some guidance advice ...
06:06:09 <chrisdone> hmm. i like lpaste. given that the idris and agda communities also use hpaste, lambda is more generic
06:06:35 <chrisdone> benmachine: well, people who have the ability to effect changes in the domain don't =)
06:06:50 <elliott> but I already updated my local lambdabot to spit out paste.haskell.org links :(
06:07:02 <Hugh> ... the more I delve into Haskell and FP the more I am falling in love with it. I need to convince others of the long term viability of Haskell, industry adoption etc
06:07:03 <chrisdone> lol
06:07:23 <elliott> Hugh: perhaps http://fpcomplete.com/ will interest
06:07:46 <chrisdone> i'm gonna get lpaste. there's also lpaste.la, hehehe
06:08:04 <Hugh> is there any blog articles or recent references to give to the bean-counter decision makers that it is worth our time and is not just a glorified research project?
06:08:38 <Hugh> thanks elliot, will take a look
06:09:21 <Hugh> btw i know it isn't just a glorified research project but the powers that be can be somewhat immutable in their outlook
06:12:14 <mr-> Wow, lint suggests &&& when encountering \x -> (f x , g x) :-)
06:12:57 <yitz> Hugh: we use haskell for some of our major projects here.
06:13:18 <chrisdone> elliott: paste.la is available =p
06:13:22 * elliott thinks "glorified research project" is a good way to describe haskell. keyword glorified. but I don't see research as a negative, or necessarily a barrier to use in practice
06:14:42 <b2coutts> Hugh: I love using haskell, but I couldn't see myself suggesting to a company to use it in almost any situation
06:15:05 <b2coutts> there's not necessarily anything wrong with the language itself, but it's a "niche" language, which has few programmers
06:15:28 <b2coutts> finding haskell developers is much more difficult than finding, say, java developers
06:15:42 <elliott> using java has a price, too.
06:15:54 <yitz> Hugh: we did a major several-year project for an airline technology company, several large components in haskell
06:16:00 <chrisdone> what's better: lpaste.org, lpaste.net, lpaste.la or paste.la?
06:16:06 <Hugh> b2coutts - yeah, that's why I am keen to learn it. Go where the niche is! The world of Java is too crowded now
06:16:08 <b2coutts> also, I imagine the average haskell developer is better than the average java developer. While this may seem like a good thing, it means that often if you're looking to hire a haskell developer, they're qualified to work at better companies
06:16:15 <yitz> Hugh: we have this product, all written in haskell: http://www.suite-sol.com/pages/solutions/suitehelp.html
06:17:05 <yitz> Hugh: there are several other products implemented in haskell not showing yet on our web site but already being purchased by large enterprises
06:17:06 <b2coutts> elliott: true, but for the purposes of most businesses it's easier to just make a shitty bloated codebase and throw a bunch of programmers that just churn out java code than to get quality haskell code developed
06:17:13 <Hugh> thanks yitz
06:17:27 <b2coutts> I like the idea of using haskell for real things, but I find it extremely hard to imagine it being adopted by industry in any meaningful way
06:17:36 <yitz> Hugh: if you want to put someone in touch with me if they have any questions you can do that
06:18:16 <byorgey> chrisdone: "no one really cares much about hpaste": false.
06:18:24 <Hugh> I guess the two most often asked questions by bean-counters is 1) is it quick vs blah and 2) are there enough libraries that we can get leverage
06:18:25 <elliott> b2coutts: maybe the solution is to work at the better company in the first place :p
06:18:28 <b2coutts> Hugh: but yes, I agree. At work, most of the code I write is in perl, C, or python, and it's nice to use languages like haskell for personal projects
06:18:34 <yitz> b2coutts: i highly disagree. it's a general-purpose language, not a niche language. we're using it for major commercial projects at enterprise. we are very satisfied.
06:19:14 <byorgey> chrisdone: we're currently in an awkward state of transition where the people who did server admin etc. have all kind of drifted away without anyone noticing.
06:19:15 <b2coutts> yitz: when I say "niche", I don't mean the language itself is narrow, I simply mean that there are not a lot of haskell programmers, compared to java, python, etc.
06:19:51 <Hugh> thanks yitz, I will remember your offer. For now I am just digging around for general info to bring up rather than a hard sell.
06:20:04 <byorgey> chrisdone: but we have a new volunteer admin team now.  and e.g. the stuff hosted at galois is going to move onto a hetzner server administered directly by haskell.org.
06:20:23 <b2coutts> elliott: I suppose I could see google or similar using haskell for something
06:20:31 <quchen> b2coutts: On the other hand, consider how many Haskell programmers there are that would be very open to working with it. I imagine the supply outnumbers the demand by a great amount, so I'm not sure finding devs would be *that* hard.
06:20:33 <yitz> b2coutts: good programmers jump at the chance of migrating to haskell. bad ones... well if you really want those on your team, then yeah, i guess you're right.
06:20:51 <Hugh> From my prelinary review of FP and Haskell in particular it would appear that modularity and independent dev/test of modules of the whole is elegant...
06:21:41 <Hugh> ... do the design, workout what top-level modules will need which types and then farm out the 'black boxes' to different teams..
06:21:50 <b2coutts> quchen: I mean, I imagine that almost all haskell programmers would rather use haskell for a project at work, but the main issue would probably just be finding these haskell programmers in the first place; if you open a job posting and you get 100 applications, how many of them will be haskell programmers?
06:22:15 <b2coutts> you'd have to filter out a lot of people in order to get them, and they may not be as good a fit for the position as some of the python programmers you turned down for not knowing java
06:22:25 <Hugh> ... no messy UML diagrams and beastly arguments about which package such-n-such interface should belong in and who will be responsible for it etc
06:22:44 <yitz> b2coutts: if the job posting is on haskell-cafe and reddit/r/haskell? i would say quite a high percentage. :)
06:22:49 <b2coutts> yitz: you may be underestimating both how many programmers are against learning new things, and how much industry work can be done by bad programmers
06:23:05 <yitz> b2coutts: nope. we're doing it, and it works.
06:23:10 <byorgey> ok.  sorry for the holdup =(
06:23:14 <quchen> What yitz said.
06:23:16 <byorgey> wrong window
06:23:25 <Hugh> In fact, I have an inkling of a feeling that FP could bring together BDUF and Agile in a rather pleasant fashion...
06:23:34 <CaptainK> there are no bad programmers!  just good obfusicators!
06:23:44 <CaptainK> :P
06:23:59 <yitz> CaptainK: that would be true if obfuscation were the only problem...
06:24:08 <b2coutts> yitz: an issue with internet postings, I suppose, would be that you may want someone who will come to an office and work in person, which severely cuts down on the people who can apply
06:24:10 <merijn> yitz: Hiring? ;)
06:24:21 <b2coutts> granted, I haven't really looked into job postings on haskell-cafe or reddit
06:24:35 <Hugh> ... you do the BDUF in complete abstract, sketching out the black boxes and then take each black box and iterate it using agile sprints
06:24:36 <b2coutts> also, I'd point out that learning haskell is non-trivial
06:24:39 <yitz> merijn: not sure. i could ask. for you - i will strongly suggest it :)
06:24:44 <quchen> I think Haskell makes a pretty bad code monkey language. If you're looking for a code monkey, chances are most Haskellers simply don't want it, Haskell or not.
06:25:11 <quchen> Sometimes having someone write a lot of simple code is enough.
06:25:16 <b2coutts> and it's likely that not every programmer is cut out to learn haskell and become good at using it in a reasonable enough time frame for it to be in the company's best interest
06:25:41 <Hugh> not very well described but I just get the sense that the whole cycle and process of software engineering (as opposed to just programming) could be turned on its head... and that is what we are after.
06:25:49 <b2coutts> what quchen said is basically the point I'm trying to make; a lot (the vast majority?) of industry work is very much compatible with the code monkey paradigm of software development
06:26:09 <AeroNotix> as an outsider looking in on this it's got some overtones of elitism I must say
06:26:31 <Hugh> ... we have a few youngsters who are not contributing much because we can not assign them bite-sized chunks of the whole ...
06:26:45 <AeroNotix> Hugh: so give them more to do?
06:26:49 <AeroNotix> sink or swim
06:27:06 <b2coutts> AeroNotix: it would be difficult to dispute that haskell programmers, on average, are better programmers than java programmers
06:27:21 <b2coutts> what this implies is where there's room for argument
06:27:47 <quchen> AeroNotix: Not so much elitism. I think most people get into Haskell because of curiosity; that it's practical in the end is sort of a coincidence. A naturally curious person won't be satisfied with a simple task, much like I wouldn't like to become a carpenter after studying physics. That doesn't mean physics is better, but it definitely changes your interests.
06:27:48 <b2coutts> personally I think the cause is that being a good programmer makes you more likely to like haskell
06:28:12 <AeroNotix> so am I a good programmer?
06:28:23 <quchen> Correlation vs. causality.
06:28:25 <b2coutts> I don't know, are you?
06:28:26 <CaptainK> on the topic of good programming practices, when making my first project, it became apparent that my "word" choices and layout make a big difference between spagetti code and elegance...Anyone have good info or links to pages with information on making professional code?
06:28:34 <AeroNotix> b2coutts: I like Haskell, therefore I am. Right?
06:28:41 <quchen> A good programmer is much more likely to get into chess than a cleaning lady. This implies nothing.
06:28:59 <yitz> AeroNotix: yeah, like the facebook bootcamp. require them to get a feature live within one month - whatever that takes.
06:29:01 <b2coutts> AeroNotix: well, strictly speaking, I stated the converse, that people who are good programmers tend to like haskell
06:29:08 <b2coutts> and by tend to, I mean are more likely to
06:29:16 <Hugh> ... we are paranoid about the ugly mess we have to deal with and the complexity would mean literally holding hands or pair-programming which we can't do. I want to clearly define a 'function' (there, I used the word!) with clearly defined types in and out and let them wrap their heads around it without needing to parse a gazillion page UML spec
06:29:41 <AeroNotix> Hugh: if you have people like that working for you you have bigger problems than you think.
06:29:46 <elliott> this discussion seems to be about a thousand different things now :p
06:29:51 <AeroNotix> elliott: quite.
06:29:51 <CaptainK> Haskell "thinking" will make good programmers into better ones, that seems to be the case
06:30:05 <elliott> and I wonder if any two participants share a topic ;)
06:30:11 <b2coutts> elliott: haha
06:30:16 <mauke> dueling monologues
06:30:19 <Hugh> I disagree. They are decent coders, just not experienced in the system we have.
06:30:49 <AeroNotix> Hugh: it's their fault you desiged an incomprehensible system?
06:30:54 <b2coutts> I think that learning a functional language (particularly haskell) can be a good way to make you a better programmer, as it opens you up to a new way of thinking
06:31:01 <Hugh> It is also a cost thing (as in pounds and pence).
06:31:06 <AeroNotix> b2coutts: that I can agree with.
06:31:36 <Hugh> ahh - that is the rub, the system is about 15 years old and no one from the original team is around. Legacy is evil.
06:31:49 <AeroNotix> Rip it up and start again :)
06:31:54 <AeroNotix> what do Haskellers think of Clojure?
06:31:55 <CaptainK> no one has a link to where they get their programming standards from in haskell?
06:32:12 <AeroNotix> CaptainK: I just read other people's code. As I usually do with other languages.
06:32:27 <AeroNotix> CaptainK: find a project which is accepted to have 'good code' and follow that.
06:32:28 <b2coutts> CaptainK: well, I get it from some combination of reading other code, writing my own code and figuring out what makes sense to do, and asking here
06:32:44 <CaptainK> lol, ya thats like taking over a painting that is half finished...we all do it and it sucks
06:32:50 <Hugh> A competent coder is cheap, an experienced software engineer is $$$+++
06:33:08 <merijn> AeroNotix: I think Clojure is interesting and probably a good way to go if you have to work on the JVM for business reasons. Rich Hickey seems to be a solid and competent engineer who has some clear and well designed ideas for the language
06:33:14 <Hugh> and egiots around the board table are IQ---
06:33:16 <chrisdone> shachaf: poke
06:33:37 <merijn> AeroNotix: As far as "dynamic" languages go, it seems rather decent. And at least significantly less complex than Scala
06:33:59 <quchen> merijn: Speaking of Clojure, the entire discussion would still be valid if we replaced every occurrence of "Haskell" with "some Lisp".
06:34:02 <AeroNotix> merijn: indeed, I've picked it back up and some of the STM-related stuff seems very nice to use. I need to work on a bigger project before I pass final judgement but so far NICE
06:34:17 <b2coutts> s/haskell/$functional_language/
06:34:34 <AeroNotix> s/$functional_language/$language_I_use/
06:34:37 <merijn> AeroNotix: Basically, with my current knowledge Haskell > Clojure, but I wouldn't troll Clojure users for using it :p
06:34:50 <AeroNotix> But... macros!
06:34:58 <CaptainK> its nice when you get to "rip it out" or start from new...but sadly this is never the case...in a job interview I was asked if I would continue to support the windows visual basic if I received the job...I said "No, I will rip it out and put in a linux and C solution"...didn't get the job
06:35:11 <ChongLi> yeah, Clojure has macros :)
06:35:23 <byorgey> > iterate ((\(n,y) -> recip (fromInteger n + 1 - y)) . properFraction) 1
06:35:25 <lambdabot>   [1.0,0.5,2.0,0.3333333333333333,1.4999999999999998,0.6666666666666665,2.999...
06:35:30 <byorgey> > iterate ((\(n,y) -> recip (fromInteger n + 1 - y)) . properFraction) 1 :: [Rational]
06:35:33 <lambdabot>   [1 % 1,1 % 2,2 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 % 4,4 % 3,3 % 5,5 % 2,2 % 5,5 ...
06:35:40 <ChongLi> and Haskell has lens
06:35:48 <merijn> CaptainK: It depends on how much maintenance the VB code requires
06:35:55 <merijn> CaptainK: If it ain't broke, don't fix it
06:36:16 <HugoDaniel> im reading the parallel and concurrent programming in haskell book
06:36:17 <HugoDaniel> amazing stuff
06:36:18 <AeroNotix> VB code always requires maintainence
06:36:28 <CaptainK> lol
06:36:35 <quchen> With a sledgehammer.
06:36:37 <AeroNotix> I've literally never seen good VB code, NEVER. It attracts dolts.
06:36:39 <byorgey> HugoDaniel: which one is that?
06:36:50 <HugoDaniel> this one: http://ofps.oreilly.com/titles/9781449335946/index.html
06:36:53 <CaptainK> thats what I thought, and it just gets sooooo messy, more so than other languages imho
06:36:55 <byorgey> no language-bashing in here, please.
06:36:58 <AeroNotix> byorgey: ok
06:37:00 <elliott> byorgey++
06:37:04 <quchen> Short intermission, Torvalds recently complimented VB. End of intermission.
06:37:09 <HugoDaniel> i pre-ordered it
06:37:12 <AeroNotix> quchen: link?
06:37:17 <merijn> I would also like to remind everyone of my favorite programming word farpotshket (Yiddish)
06:37:18 <byorgey> HugoDaniel: oh, nice, didn't realize it was out
06:37:21 <HugoDaniel> beautiful book very well written and explained
06:37:24 <HugoDaniel> its not yet finished
06:37:28 <byorgey> ah, ok
06:37:30 <rien> quchen: did he compliement the way it does GUI?
06:37:31 <HugoDaniel> but some chapters are up
06:37:36 <CaptainK> really!
06:37:37 <merijn> "Something that is all fouled up, especially as the result of attempts to fix it‚Äìrepeatedly making something worse while trying to fix it."
06:37:57 <HugoDaniel> i can't wait for my hardcopy to arrive, truly a must have :D
06:38:01 <quchen> AeroNotix, rien: it's pretty OT by now, I'll PM you the link.
06:38:14 <rien> quchen: sorry, thanks :)
06:38:48 <byorgey> HugoDaniel: looks awesome =)
06:40:23 <CaptainK> looks like a good read, AFTER lyah :P
06:40:24 <HugoDaniel> ive been trying to write a simple udp server, but im having some difficulties with it, now im reading the chapters to see if i can make something out of it :)
06:43:42 <quchen> Were there any recent updates on Simon Marlow's book? Is the July release realistic?
06:44:07 * quicksilver wonders where BONUS went
06:44:16 <quchen> What's that
06:44:30 <chrisdone> quicksilver: http://ircbrowse.net/nick/BONUS
06:45:02 <quicksilver> that tells me that he's gone
06:45:08 <quicksilver> but doesn't tell me where it went (does it?)
06:45:46 <chrisdone> it does let you know that he didn't just drop off, he gradually left
06:45:50 * quicksilver nods
06:45:55 <quicksilver> he hasn't tweeted since 2011 either
06:46:01 <chrisdone> hmm!
06:47:21 <chrisdone> i can't decide between lpaste.org, lpaste.net, or lpaste.la
06:47:44 <chrisdone> any preferences?
06:47:48 <quicksilver> I like .net for network services
06:47:51 <elliott> the LYAH site was down for a while and came back up
06:47:58 <elliott> so probably BONUS still exists :P
06:48:00 <quchen> chrisdone: Why the "l"?
06:48:00 <chrisdone> lpaste.la is short to type and is cute ("lambda")
06:48:09 <chrisdone> quicksilver: nod, that's a reasonable heuristic
06:48:11 <quchen> elliott: BONUS is Lipovaca?
06:48:18 <chrisdone> quchen: lambda
06:48:23 <chrisdone> \bot and \paste =)
06:48:31 <elliott> quchen: yes
06:49:25 <merijn> quchen: When I spoke to him in January he said he was aiming for March/April to get the book done before starting at Facebook, so presumably July should be realistic?
06:49:52 <merijn> quchen: That'd give 2 months of editing/typesetting
06:50:11 <quchen> Which isn't that much
06:50:39 <quchen> But he's working for Facebook right now already?
06:50:51 <chrisdone> lpaste.la or lpaste.org? let's have a karma vote. lpaste.la++ or lpaste.org++
06:51:04 <quicksilver> lpaste.net++
06:51:10 <mauke> xn--paste-1be.org
06:51:14 <merijn> paste.ly
06:51:21 <quchen> org > la
06:51:29 <merijn> aww
06:51:33 <merijn> That already exists
06:51:34 <chrisdone> quicksilver: ah, you were for lpaste.net? i was too, but i thought you meant network service as in not an application =)
06:51:48 <elliott> is paste.haskell.org really unworkable? :/
06:51:51 <aa22> past.ed
06:51:51 <quicksilver> chrisdone: I think a hosted paste service qualifies as a network service
06:51:57 <b2coutts> lpaste.net++
06:52:10 <merijn> paste.lambdacats.org++ :p
06:52:25 <chrisdone> elliott: it may be but it seems that it's gonna take a while
06:52:28 <quchen> Ask moot whether you can get a subdomain on 4chan
06:52:31 <merijn> With a randomly selected cat on every paste!
06:52:33 <CaptainK> ideone.com++
06:52:38 <mauke> CaptainK: you're fired
06:52:44 <CaptainK> "P
06:53:10 <chrisdone> elliott: i was given zero response when i asked for ETA
06:53:10 <b2coutts> haha
06:53:10 <quchen> chrisdone: What's wrong with "hpaste" anyway? Why the switch to "lambda*"?
06:53:12 <benmachine> elliott: apparently the haskell.org committee haven't responded in a couple of weeks or so
06:53:15 <maurer> Hey, anyone here know anything about the gentoo haskell overlay?
06:53:23 <maurer> I'm having some troubles with getting things to work with it
06:53:25 <elliott> benmachine: well I'm going by what byorgey said above
06:53:30 <elliott> re the transition in administration
06:53:44 <merijn> quchen: It's been dodgy and the domain owner is unreachable, afaik
06:53:49 <chrisdone> quchen: because that's another domain we don't have control over. plus, lpaste is consistent with lambdabot and other languages spawned from haskell use the service so it's more general =)
06:54:05 <quchen> merijn: Odd.  chrisdone: Okay.
06:54:17 <elliott> bos is the hpaste.org owner right? I'm sure he'd be willing to hand over?
06:54:41 <merijn> elliott: Yes, but he wasn't reachable, afaik?
06:54:42 <mauke> preflex: seen bos
06:54:43 <chrisdone> elliott: if you can get a reply from him =)
06:54:44 <preflex>  bos was last seen on #haskell 3 days, 14 hours, 19 minutes and 39 seconds ago, saying: sclv: it gets filled with spam repeatedly, and it is terribly slow
06:55:10 <quchen>  @tell bos ...?
06:55:13 <ocharles> he's response to tweets
06:55:17 <ocharles> responsive*
06:56:01 <benmachine> hpaste.org++
06:56:09 <benmachine> cool URIs don't change :P
06:57:05 <chrisdone> ok, i'm doing lpaste.net
06:57:19 <chrisdone> if you guys get a response from bryan in a few months, you're welcome to it
06:57:35 <b2coutts> my name's bryan o.o
06:57:50 <b2coutts> does this make me qualified to respond?
06:58:08 * chrisdone is a month into this waiting game already, had enough
06:58:58 <Clint> what does the "l" stand for?
06:59:22 <mauke> logs
06:59:48 <Clint> not my first guess
06:59:53 <b2coutts> lesbians
07:00:03 <quchen> The "l" really isn't a good name.
07:00:12 <quchen> lambdapaste is too long I assume?
07:00:14 <sopvop> is that l or I?
07:00:17 <quchen> 1.
07:00:27 <sopvop> one?
07:00:29 <b2coutts> haha
07:00:31 <mauke> fonts--
07:00:36 <b6> could somebody try to build https://github.com/bsl/bindings-GLFW on windows using just the HP (no msys, etc)?
07:00:49 <b2coutts> I still get mad that arial has precisely the same symbol for l and I, and that it became such a standard font
07:01:21 <b2coutts> couldn't they at least have made one slightly larger than the other or something? Making every symbol unique seems like a pretty obvious property for a font to have
07:01:27 <merijn> sopvop: Time to switch to Monaco :p
07:02:19 <b2coutts> hopefully we'll have direct brain interfaces soon, and won't have to worry about silly things like rendering text
07:02:44 <b2coutts> also hopefully these interfaces won't do terrible things
07:03:06 <Sculptor> yo
07:04:46 <CaptainK> so hpaste is tryhaskell? http://chrisdone.com/posts/hpaste-update
07:05:05 <CaptainK> and where is lpaste?
07:05:27 <CaptainK> sorry in advance for obviously missing something...know for that :P
07:05:31 <quchen> hpaste is the old domain, which was lost. tryhaskell is a temporary domain, lpaste will apparently be the new and permanent one.
07:05:42 <CaptainK> ok, got it
07:06:17 <merijn> Until we get hpaste migrated to a more active maintainer
07:06:47 <quchen> s/permanent/semi-permanant/
07:07:05 <quchen> Semi-permanent is a good word. It could mean anything. Including ponies.
07:07:32 <applicative> the hpaste.org domain name is gone for good?
07:07:36 <b2coutts> ponies.net++
07:07:53 <quchen> applicative: MIA.
07:08:01 <merijn> I just looked at the paste.tryhaskell.org URL, which points at IRC stats and now I feel like I'm wasting my life on here >.>
07:08:20 <applicative> haha, no you do good work
07:08:37 <applicative> there could be something more important, of course
07:08:45 <b2coutts> haha
07:08:58 <sopvop> merijn: you can track the whole "monoids are easy" to the beginning
07:09:00 <b2coutts> I'm not in the top 100
07:09:04 <b2coutts> clearly I need to lower my SNR
07:09:12 <sopvop> trace
07:09:50 <merijn> b2coutts: Or produce more signal!
07:10:09 <b2coutts> or I could
07:10:11 <b2coutts> split up all my messages
07:10:14 <b2coutts> and talk like this
07:10:34 <mauke> chrisdone: the quotes page seems to double backslashes
07:11:00 <quchen> sopvop: Speaking of which, where's Beaky?
07:11:05 <quchen> preflex: seen beaky
07:11:05 <applicative> I still haven't figured out how best to organize a bunch of repositories simultaneously under cabal sandbox.  Someone with a brain should be preparing a tutorial for when it appears officially
07:11:06 <preflex>  beaky was last seen on ##c 1 day, 16 minutes and 12 seconds ago, saying: ah
07:11:51 <b2coutts> hmm, according to the IRC stats thing #haskell is really slow this year
07:12:08 <b2coutts> we're halfway through but only at about 1/5th of 2012
07:12:20 <lpaste> quchen pasted ‚ÄúLPASTE!‚Äù at http://lpaste.net/90758
07:12:25 <b2coutts> unless it's out of date or something
07:13:17 <b2coutts> haha oh man, I'm just 2 lines short of being in the top 100; that's depressing
07:14:56 <ocharles> b2coutts: everyone's moving to agda and idris now, haskell is too boring
07:15:08 <taylorgb_> Maybe it's due to the increasing popularity of LYAH et al., nobody needs help anymore ;)
07:15:45 <b2coutts> I started coming here this year; do you guys notice it being substantially slower nowadays?
07:25:48 <taylorgb_> It did seem like the flow of text was more constant last year
07:26:03 <merijn> Mostly because people kept giving newbie explanations in stereo instead of saying "here's LYAH"
07:26:03 <merijn> That might be a lie, btw
07:26:03 <merijn> I forgot when LYAH was released :p
07:26:04 <quchen> 20011, according to the (c) notice in the book.
07:26:06 <merijn> 18 thousand years in the future?
07:26:06 <quchen> It's way ahead of its time
07:26:07 <b2coutts> haha
07:26:07 <ocharles> instantrimshot.com
07:26:08 <quicksilver> lyah was a commonly referred to resource long before the book was published
07:26:10 <quchen> ocharles: Can't believe that actually exists
07:26:10 <quicksilver> about 2009 I'd think
07:26:13 <quicksilver> 2008-10-12 16:11:51 +0200 <vixey>?where+ LYAH www.learnyouahaskell.com
07:26:13 <b2coutts> do you think haskell is less popular than it used to be?
07:26:13 <quicksilver> no
07:26:14 <ion> shachaf: https://gist.github.com/ion1/5957723
07:26:14 <ion> shachaf: Thachaf for helping me figure this out.
07:26:14 <quicksilver> but I don't have any alternative explanation
07:26:14 <quicksilver> (as to why the channel is quieter)
07:26:14 * CaptainK likes lpaste.net's paste history
07:26:15 <quicksilver> I suspect a few people account for a disproportionate amount of the noise
07:26:15 <quicksilver> and some of them left
07:26:16 <elliott> ouch :p
07:26:16 <ocharles> quchen - it's an oldy :)
07:28:14 <isomorphic> I'm trying to get a (hopefully) simple example with MaybeT going
07:28:21 <isomorphic> I've pasted the code at http://lpaste.net/6073828881830248448
07:28:40 <quchen> ion: What's that? I've seen some talk on Mu/Nu, but it felt like it was way over my head.
07:28:48 <quchen> Seeing this it looks complicated, but understandable.
07:29:04 <erisco> how do you define Applicative for [] if a <*> b doesn't guarantee that a and b are of same length?
07:29:26 <isomorphic> The effect I'd like is to use IO and Maybe in the same do block (hence MaybeT) but I'd like the elements of the returned structure to be Maybe Strings
07:29:27 <b6> isomorphic: please simplify "null s == True"
07:29:29 <mauke> erisco: by not zipping
07:29:39 <quchen> erisco: There are two possible Applicative definitions for lists. LYAH talks about both of them.
07:29:41 <applicative> hm r/haskell has more FUD on whether haskell could possibly manage against C++ in programming competitions; its just as well it isn't allowed in most of them ....
07:29:46 <b2coutts> erisco: well, there's not a single correct answer to that question
07:30:43 <chrisdone> here's the data for activity per year/month: https://docs.google.com/spreadsheet/ccc?key=0Au0duWbkCwJUdEZYRVRjV1lsdS02dmhzNTJFUnY3cGc&usp=sharing
07:31:06 <b2coutts> erisco: you could do things like zipping until the shorter list is empty, or making a list with one element for every pair of elements from a and b
07:31:09 <isomorphic> b6:  Ah yes - I did that quite quickly - the problem I'm doing is something with the FFI and pointers - I've made that example to to be shorter / less dependencies
07:31:38 <quicksilver> chrisdone: that doesn't make 2013 look quieter than 2012
07:31:48 <erisco> b2coutts, cartesian product?
07:31:56 <CaptainK> not many users for spanish #haskell.es
07:31:57 <b2coutts> erisco: exactly
07:32:04 <elliott> "In particular, laziness is an algorithmic transform applied by the compiler - the algorithm you get isn't really the algorithm you specified.
07:32:07 <elliott> "
07:32:10 <quicksilver> I wonder what numbers b2coutts was looking at
07:32:10 <chrisdone> quicksilver: yeah, i think those charts are out of date. doesn't really make sense for 2013 to be so low
07:32:11 <elliott> applicative: pretty wacky thread
07:32:23 <applicative> yes
07:32:24 <chrisdone> gonna check them
07:32:33 <chrisdone> quicksilver: probably the ones at the bottom of here: http://ircbrowse.net/
07:32:45 <applicative> what is the 'activity' measured on this chart?  amount of text?
07:32:45 <erisco> > [(+1), (+6)] <*> [4,2,7,2,4]
07:32:47 <lambdabot>   [5,3,8,3,5,10,8,13,8,10]
07:33:01 <erisco> I see it likes cartesian product
07:33:06 <quicksilver> mostly lines, I think, applicative
07:33:11 <b2coutts> while there is often an "obvious" way to define an instance of Applicative, it's really just a contract that you can fill in with anything
07:33:13 <quicksilver> although there are some stats using word
07:33:25 <b2coutts> quicksilver: http://paste.tryhaskell.org/
07:33:33 <b2coutts> the graphs near the bottom
07:33:51 <Cale> elliott: Yeah, that's bizarre
07:33:52 * quicksilver nods
07:33:59 <quchen> > [f, g] <*> [a, b, c] :: [Expr]  -- erisco
07:34:01 <lambdabot>   [f a,f b,f c,g a,g b,g c]
07:34:24 <CaptainK> anyone using leksah? pros cons?
07:34:28 <benmachine> chrisdone: my hypothesis is that the 2013 bar will "fill up" over the course of the year
07:34:37 <Cale> elliott: Who wrote that?
07:34:43 <elliott> Cale: some random person on reddit :p
07:34:45 <erisco> CaptainK, cons was that I couldn't get it working on Windows
07:35:01 <CaptainK> haha, thats a big con
07:35:02 <chrisdone> applicative: quicksilver: ahh, my bad. those stats are updated in a cached table. it's not been updated since ~feb, i'll pop it in the update cron job
07:35:02 <Cale> gief link
07:35:15 <yesthisisuser> this is not really a Haskell question but can someone give a good intuitive explanation of a monoid morphism?
07:35:42 <Cale> yesthisisuser: I can give you a formal description which is really simple
07:35:43 <applicative> gief link??
07:35:44 <elliott> yesthisisuser: f mempty = mempty; f (x <> y) = f x <> f y
07:35:56 <elliott> so it preserves the structure of the monoid. it's as simple as that
07:36:00 <Cale> applicative: To the reddit post that elliott was reading
07:36:13 <elliott> http://www.reddit.com/r/haskell/comments/1hvymr/what_does_it_takes_to_get_acmicpc_to_allow/
07:36:18 <elliott> link gieffened
07:36:35 <mauke> now someone needs to post a pastebin.com link
07:36:37 <quchen> elliott:  Shouldn't it be homomorphism? And doesn't the second law imply the first?
07:36:47 * CaptainK thinks monoid sounds too close to hemorrhoid.
07:37:12 <elliott> quchen: "monoid morphism" is acceptable to refer to monoid homomorphisms
07:37:18 <yesthisisuser> maybe a concrete example?
07:37:21 <elliott> after all it's a morphism in the category of blah blah blah
07:37:46 <elliott> quchen: second law doesn't imply the first, no; exercise: come up with a counterexample
07:37:49 <ion> quchen: They are isomorphic types to Fix, so it‚Äôs possible to convert between all of them. Exactly how to do that was a bit of a brain twister to me. I don‚Äôt know if i would have ever figured it out without shachaf‚Äôs help with implementing Nat in terms of them (the fixZero ‚Ä¶ nuToInt part in the code).
07:38:06 <elliott> ion: they're not all isomorphic without general recursion though
07:38:09 <Cale> yesthisisuser: You might be familiar with the logarithm
07:38:23 <CaptainK> why are a lot of haskellers in #perl6?
07:38:29 <elliott> ion: it's basically a "coincidence" of Haskell that you have the whole data = codata thing that makes them all the same
07:38:32 <applicative> is there any evidence that the result of ghc's optimizations makes a more radical change than the ones the gcc applies?
07:38:35 <yesthisisuser> Cale: yes
07:38:42 <mauke> CaptainK: why are a lot of perl6ers in #haskell?
07:38:43 <ion> elliott: What‚Äôs codata?
07:38:43 <elliott> CaptainK: the pugs perl 6 implementation was written in haskell
07:38:52 <Cale> yesthisisuser: It can be seen as a monoid homomorphism from the monoid of positive real numbers under multiplication to the monoid of all real numbers under addition.
07:38:57 <CaptainK> thats a good reason
07:38:58 <elliott> CaptainK: so lots of crossover
07:39:04 <elliott> ion: Nu :P
07:39:09 <Cale> yesthisisuser: i.e. log(xy) = log(x) + log(y)
07:39:43 <elliott> ion: e.g. a list type that has to be of finite length is a real data list. a list type that can be infinite is a colist, which is codata. unending streams are codata. naturals don't include infinity, conaturals do (as fix Succ)
07:39:56 <yesthisisuser> Cale: ok. that does make sense
07:40:04 <applicative> CaptainK: it's clear the pugs project got a lot of really good people using Haskell; too bad it vanished.  geeko saur suggested they were regretting this for some reason
07:40:05 <elliott> ion: you can think of it as, data is characterised by its fold, but codata is characterised by its unfold
07:40:11 <ion> elliott: Hmm, okay.
07:40:12 <elliott> which is where Mu/Nu come from
07:40:23 <quchen> elliott: Ah, suppose x = y^{-1}, then the 2nd law reads "f mempty = f x <> f y".
07:40:34 <yesthisisuser> Cale: the only thing is it is not as easy to see the "structure" that it preserves
07:40:36 <Cale> yesthisisuser: Or for example, the function which sums a list of numbers, is a monoid homomorphism from the monoid of lists under concatenation, to the additive monoid on whatever type of numbers you're working with
07:40:37 <applicative> Nu rules!
07:40:38 <elliott> ion: another way of thinking of it is that data is easy to construct but hard to destruct, whereas codata is hard to construct but easy to destruct
07:40:54 <Cale> yesthisisuser: because sum [] = 0, and sum (xs ++ ys) = sum xs + sum ys
07:41:01 <ion> Nu metal?
07:41:08 <yesthisisuser> i mean.. i can see how a map over a tree or a list is "structure preserving"
07:41:10 <elliott> ion: "hard" as in, you need to use something "heavy" like a fold/unfold type thing. "easy" as in, it's just a simple function. but this might be easier to understand if you've played with data types in a type theory context
07:41:13 <applicative> that's why, in haskell we never construct anything, just destruct?
07:41:15 <CaptainK> well pugs sounds great being an ex perl programmer...err hacker.
07:41:23 <ion> elliott: ok
07:41:27 <Cale> yesthisisuser: Well, it's preserving the structure of the operation of the monoid in question.
07:41:44 <elliott> ion: also important -- data Stream a = Cons a (Stream a) isn't proper codata.
07:42:00 <elliott> ion: with codata, you have to be able to peel off another constructor in finite time. this is called "productivity".
07:42:04 <yesthisisuser> Cale: thanks.. i'll write down the examples you mentioned and think about it a bit.. text is scrolling too fast here
07:42:09 <elliott> so Cons 1 (Cons 2 (Cons 3 ...)) is ok. Cons 1 _|_ is not
07:42:36 <yesthisisuser> concrete examples does help when trying to build up some intuition
07:42:44 <ion> elliott: Can‚Äôt i equivalently shove a bottom into Nu?
07:42:54 <ion> elliott: Making it not proper codata?
07:42:59 <elliott> ion: yes. this is why you don't use Haskell to think about the difference between data and codata :P
07:43:06 <ion> heh
07:43:07 <elliott> since they collapse into one big mess with non-strictness
07:43:11 <elliott> and non-termination
07:43:32 <applicative> yesthisisuser: you can find cales immortal words somewhere,  http://tunes.org/~nef/logs/haskell/13.07.09
07:43:55 * CaptainK tried this line to get a girls interest...Hey baby, want to check out my Polymorphic Existential  Recursive Lambda program? She just walked away.
07:44:11 <ion> yesthisisuser++ for the nick
07:45:05 <chrisdone> benmachine: applicative: quicksilver: k, this is more like it: http://ircbrowse.net/ it's still not a lot of conversation. we'll probably just match 2012, seems to me
07:45:57 <CaptainK> that perl 6 logo hurts the eyes...good god.
07:46:09 <b2coutts> CaptainK: augh
07:46:13 <ion> captaink: whoa
07:46:32 <b2coutts> and I'd thought perl 6 was an improvement
07:46:46 <chrisdone> a perl6 user assured me he liked the logo. i know a liar when i see one
07:46:59 <CaptainK> were his eyes bloodshot?
07:47:04 <ion> That‚Äôs even better than many of the ‚Äúnew Haskell logo‚Äù suggestions.
07:47:12 <nabilhassein> hello all, i have a question about a problem i've been having with ghci under emacs
07:47:23 <nabilhassein> for reasons i can't understand it behaves differently from ghci at the command line
07:47:34 <lumo_e> Hi guys, does anyone know why after having changed toInteger $ length list to genericLength list my code takes forever?
07:47:59 <nabilhassein> for example, in one source file which imports another module, under emacs I get the error: "Module `TrackerClient' does not export `getTorrentInfo'
07:47:59 <nabilhassein> Failed, modules loaded: none. "
07:47:59 <applicative> chrisdone: I think there tends to be a spike in the fall when school gets going; the fall in numbers in 2010/9 was from some change in freenode rules.  same as +r took 50 people off the channel who are still off
07:48:11 <nabilhassein> whereas from the command line loading the same module works flawlessly
07:48:29 <CaptainK> lol, http://www.perlfoundation.org/perl6/index.cgi/Perl_6_timeline.png?action=attachments_download;page_name=when_will_perl_6_be_released;id=20071231104947-0-13730
07:48:38 <int-e> lumo_e: does it also gobble up memory?
07:48:41 <b2coutts> applicative: are there schools that teach haskell?
07:48:45 <elliott> CaptainK: bit off-topic? :)
07:48:53 <int-e> lumo_e: it's possible that you lost strict evaluation of the length along the way
07:49:03 <CaptainK> ya, but it is linked to haskell :p
07:49:04 <applicative> b2coutts: universities? yes, a fair number
07:49:04 <chrisdone> applicative: could be
07:49:31 <b2coutts> applicative: cool, I hadn't heard of this
07:49:46 <b2coutts> not that I'm particularly knowledgeable about what other universities do :P
07:49:47 <chrisdone> applicative: i'll make at some point something showing activity by month
07:49:51 <applicative> b2coutts: of course, it accounts for a certain amount of hatred of haskell...
07:49:54 <Sculptor> how come this channel has more users that all my other irc channels combined
07:50:09 <applicative> Sculptor: because Haskell is so excellent?
07:50:12 <quchen> Sculptor: 90 % never said a word.
07:50:14 <b2coutts> Sculptor: because haskell is cooler than all your other channels combined
07:50:24 <Sculptor> cute
07:50:25 <int-e> Sculptor: people are too lazy too leave ... no, it's just a very nice channel to hang around in.
07:50:41 <Sculptor> yeah
07:50:52 <quchen> I paid for a flatrate and I'm going to use it! Come at me, IRC
07:51:04 <lumo_e> int-e: it handles a 100000 elements list
07:51:30 <lumo_e> also I call it for every recursive call so that maybe the problem
07:51:32 <applicative> are people on  #haskell less obnoxious than on other channels in fact?
07:51:34 <circle> with regards to piece-wise functions
07:51:36 <circle> and pattern matching
07:51:56 <circle> are the first patterns always looked at first?
07:51:58 <lumo_e> but I don't understand why genericLength is so slow compared to length + toInteger
07:52:03 <quchen> circle: Yes.
07:52:14 <circle> quchen: Okay, so just functions like 'case of', right?
07:52:42 <quchen> circle: Yes. I think pattern matching is internally converted to case statements even.
07:52:48 <applicative> lumo_e: 'length' presumably enters into the standard optimization machinery that genericLength misses; maybe genericLength could be improved?
07:52:51 <circle> quchen: Ah, okay.
07:53:13 <quchen> circle: I'm not entirely sure about that part. But the general thing holds, patterns are always checked top to bottom.
07:53:36 <RichyB> lumo_e: at a guess, because genericLength :: [a] -> Integer, is summing a large quantity of (1 :: Integer) values together, each of which is an arbitrary-precision integer, whereas length :: [a] -> Int accumulates a single machine integer as it walks the list and then converts it to an arbitrary precision Integer once.
07:54:03 <merijn> I thought genericLength was Num a?
07:54:06 <merijn> :t genericLength
07:54:08 <lambdabot> Num i => [b] -> i
07:54:13 <quchen> applicative: genericLength is the "naive" implementation of length.
07:54:23 <quchen> It's very generic.
07:54:33 <quchen> If you want the length of a list as an Integer, use fromIntegral.length.
07:54:44 <applicative> lumo_e I'm not sure, but length has funny effects when e.g. you are reading a string from a file. certain oleg proofs of the irrationality of 'lazy io' turn on the use of length ; they don't work if you calculate with lazy Nats
07:54:59 <RichyB> merijn: yes, I meant to specifically restrict myself to the Integer specialisation of it.
07:55:28 <quchen> genericLength []        =  0
07:55:28 <quchen> genericLength (_:l)     =  1 + genericLength l
07:55:36 <quchen> ^ Not something you want to use if you don't have to.
07:55:48 <quchen> If you're using lazy nats, then it might be practical.
07:55:50 <RichyB> What, no accumulator?
07:55:53 <quchen> Otherwise probably not.
07:56:26 <nabilhassein> sorry to be a repetitive pest but: anyone have any idea what could cause ghci to behave differently under emacs from the command line? my google-fu can't turn up a single relevant article
07:56:26 <YoungFrog> lambdabot:
07:57:06 <quchen> RichyB: An accumulator doesn't always help.
07:57:39 <quchen> RichyB: In the case of genericLength, the function is automatically rewritten to one that uses an accumulator if the Num you're trying to get is Integer/Int.
07:57:43 <RichyB> Well, it stops a thunk chain getting built up and then forced at the end. The strictness annotator should be able to do well with it.
07:58:11 <chrisdone> benmachine: applicative: quicksilver: this might have a little bit to do with it: http://chrisdone.com/lambdabot-use-over-time.png
07:58:32 <quchen> An accumulator doesn't always get rid of a thunk chain. It just puts it in a different place. If you can make that place strict you're fine.
07:58:43 <chrisdone> benmachine: applicative: quicksilver: i mean, the general "decline"
07:58:51 <quchen> For arbitrary "Num", making things strict may not be so easy.
07:59:04 <quchen> And you don't want to have a NFData constraint on genericLength just to force the accumulator.
07:59:11 <chrisdone> benmachine: applicative: quicksilver: if you can make a better graph‚Ä¶ https://docs.google.com/spreadsheet/ccc?key=0Au0duWbkCwJUdGpUbC00Mm9jSFRrNjVnSmVHc0J4TGc&usp=sharing
07:59:30 <lumo_e> NFData means?
07:59:32 <RichyB> quchen: you don't need an NFData constraint; seq is (a -> b -> b)
07:59:46 <quicksilver> chrisdone: maybe various lambdabot features have been removed/fixed which make it less verbose
07:59:54 <RichyB> Any Num which is actually machine-sized is going to be forced entirely by one seq.
07:59:55 <quicksilver> it doesn't doo seen any more for example
08:00:03 <chrisdone> quicksilver: right. one that springs to mind is the lack of the Title: ‚Ä¶ anymore
08:00:08 <CaptainK> Found a nice code practices page: http://stackoverflow.com/questions/1983047/good-haskell-coding-standards  Any comments or further sugestions?
08:00:11 <chrisdone> (but i guess that wasn't high traffic)
08:00:12 <quchen> RichyB: Right. Any any other Num won't be forced.
08:00:39 <quchen> RichyB: It will just be flooded with "seq" calls.
08:01:40 <lumo_e> at this point my question is, when should I use genericLength?
08:01:42 <quchen> RichyB: Like I said, genericLength is rewritten to a strict version when an Int/Integer is desired. If invoked with an arbitrary Num, nothing will forced.
08:02:05 <quchen> lumo_e: Unless you know exactly that you need genericLength, you don't need it.
08:02:29 <quchen> lumo_e: It's potentially lazy, I think that's the point of the function.
08:02:36 <applicative> I think genericLength is a terrible idea, you should write a length for your number type
08:03:03 <applicative> yes it's lazy, length after all we use to force the spine of a list
08:03:42 <applicative> lumo_e: you know the trick of forcing a file contents completely into memory?
08:03:53 <lumo_e> nope
08:04:02 <lumo_e> I'm quite new to haskell
08:04:21 <applicative> do {lazy_contents <- readFile "a.txt"; length lazy_contents `seq` ....}
08:04:40 <quicksilver> if you're quite new to haskell then the answer to "when should I use genericLength" is "never".
08:04:50 <quicksilver> or maybe it's "not yet".
08:04:52 <lumo_e> cool
08:05:03 <applicative> because length is only in whnf if it is completely evaluated, this means the whole file must be consumed
08:05:04 <quchen> Same thing for that get-out-of-IO function.
08:05:16 <applicative> lumo_e: if I used a lazy length, it would do nothing at all
08:05:48 <quicksilver> but its only real purpose - being able to compare infinite lists to finite lists and get an answer in finite time, given a lazy natural type - is really quite baroque
08:05:54 <quicksilver> and I've never seen it used in practice.
08:06:40 <applicative> if length [] = Zero; length (x:xs) = Succ (length xs) then the 'length' Succ (Succ (Succ ...) ) ) is only evaluated as far as the file c:d:e:f: ... is
08:19:35 <erisco> where can I get a list of common haskell type classes? right now I am looking for something to describe concatenation
08:19:46 <maurer> erisco: Monoid perhaps
08:19:59 <maurer> erisco: more general than concatenation, but encapsulates most of it
08:20:17 <t2ahc> @erisco i found the type classopedia v. helpful
08:20:18 <lambdabot> Unknown command, try @list
08:20:21 <quicksilver> monoid is surely the thing that describes concatenation
08:20:23 <b2coutts> on that note, is there a set typeclass, for things that can contain elements?
08:20:30 <quicksilver> but I was just about to suggest the typeclassopedia
08:20:40 <quicksilver> b2coutts: not really
08:20:45 <t2ahc> erisco : i found the typeclassopedia very helpful
08:20:48 <t2ahc> http://www.haskell.org/haskellwiki/Typeclassopedia
08:20:51 <quicksilver> that's hard to do without associated types / type families
08:21:01 <t2ahc> quicksilver beat me to it !
08:21:03 <quicksilver> although there is a sense in which Foldable/Traversable are that, b2coutts
08:21:07 <erisco> thanks
08:21:33 <b2coutts> quicksilver: wouldn't you only need the associated type to be in (Eq a)?
08:21:47 <b2coutts> er, in Eq, rather
08:21:55 <haasn> maurer: encapsulates all of it, I'd argue
08:22:32 <maurer> haasn: Maybe does, depends on what he means by concatenation. I reccomended it because I'm pretty sure it's what he wants, but I don't want to through the process of discovering what he in particular means by concatenation
08:22:38 <b2coutts> the only thing that would really need to be in the typeclass is set membership
08:23:22 <b2coutts> union, intersection, and set subtraction could also be derived from that
08:23:53 <quicksilver> b2coutts: depends what you think a container is.
08:24:08 <quicksilver> there are quite a lot of different ideas
08:24:25 <erisco> where in blazes do they come up with these names like Monoid?
08:24:25 <quicksilver> should you able to combine them? insert? can they contain the same element more than once?
08:24:27 <b2coutts> quicksilver: I don't understand what you mean
08:24:32 <b2coutts> a
08:24:34 <b2coutts> ah
08:24:40 <quicksilver> b2coutts: I mean there are lots of kinds of operations that containers might support
08:24:44 <Hugh> how do I get the String bit out of an IO String?
08:24:51 <quicksilver> choosing the ones you're interested is the trick.
08:24:57 <Hugh> (I'm guessing this has something to do with monads)
08:24:57 <quicksilver> Hugh: by using <- in do notation, normally
08:24:58 <b2coutts> well, I don't think these things necessarily matter, if the only operation of the typeclass were set membership
08:25:06 <elliott> erisco: mathematics
08:25:07 <geekosaur> @quote /bin/ls
08:25:07 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:25:27 <elliott> erisco: http://math.stackexchange.com/questions/156952/why-the-terminology-monoid
08:25:37 <b2coutts> as for combining and insertion, you could do these things with set union/intersection, which can be derived from membership
08:25:44 <Hugh> ah! thanks. was I correct in assuming it was something to do with monads?
08:25:47 <erisco> elliott, so does that make the integers an instance of monoid? mempty = 0; mappend a b = a + b?
08:26:12 <b2coutts> (provided you have a way of constructing new "sets", but this would be entirely a matter of the class from which the instance is being created)
08:26:20 <merijn> Hugh: The basic answer is, you can't get a String out of an IO String, the more useful answer is "you can get other things into IO"
08:26:25 <erisco> if the only law is there exists an e such that e op x = x and x op e = x
08:26:37 <merijn> Hugh: Think of "IO a" as "a program (fragment) that produces an a"
08:26:37 <elliott> erisco: the other law is associativity
08:26:41 <elliott> but + satisfies that too
08:26:49 <elliott> but there is more than one monoid structure on the integers
08:26:50 <erisco> so does * so how does one choose?
08:26:53 <elliott> for instance, mempty = 1; mappend a b = a * b
08:26:56 <elliott> you don't
08:26:58 <merijn> Hugh: You can't get an a from a program without running it, and you cannot run it in Haskell.
08:27:01 <elliott> you use the newtype wrappers Sum and Product
08:27:06 <elliott> if you want a Monoid instance for a numeric type
08:27:06 <erisco> ah
08:27:14 <merijn> Hugh: Fortunately, Haskell does let you combine smaller programs into bigger ones
08:27:32 <Hugh> merijn that has just confused me!
08:27:35 <erisco> elliott, Haskell has an interesting way of doing some things indeed
08:27:45 <merijn> Hugh: Using, among others, fmap, <*> and >>=. Do notation being just syntactic sugar for >>=
08:28:09 <Hugh> ok, thanks.
08:28:21 <merijn> Hugh: Haskell is pure/referentially transparent, so functions and values must always return the same thing
08:28:35 <merijn> Hugh: Take for example "getLine :: IO String"
08:28:44 <Hugh> got that. which is what I am loving about it!
08:28:45 <merijn> Hugh: What does that type mean?
08:29:08 <Hugh> err... well, to me it says perform an action which return a type IO String
08:29:10 <merijn> Hugh: Clearly getLine can't be a string, because it might return a different String on different occasions
08:29:28 <merijn> Hugh: Ah, but getLine *doesn't* perform the action
08:29:30 <dmwit> Hugh: You don't get a String out of an IO String; instead you teach the part of your program that wants to use a String how to use an IO String instead.
08:29:34 <merijn> Hugh: getLine *is* the action
08:29:55 * dmwit ponders writing a monad tutorial: "The Zen of IO" or something like that
08:30:10 <merijn> Hugh: getLine is an action that produces Strings, suddenly getLine is pure, because it can always return the exact same action
08:30:11 <Hugh> mmm, so getLine is the action which when performed produces a thing of type IO String
08:30:33 <merijn> Hugh: No, it's an action that when performed produces something of type String, and the type of action is IO
08:30:35 <maurer> Hugh: Uh, when performed produces String
08:30:39 <dolio> elliott: Interesting that the terminology may have been pushed by category theory, even though I imagine people had come up with monoids before categories.
08:30:40 <maurer> Hugh: when evaluated produces IO String
08:30:56 <erisco> > id 8 + id 2
08:30:58 <lambdabot>   10
08:30:59 <dmwit> (I think Hugh is just using "action" a different way than you are.)
08:31:06 <merijn> Hugh: Now, how do you write useful programs if you only have actions and can't run them?
08:31:14 <dmwit> Hugh: "action" is an overloaded term in here with a technical meaning.
08:31:16 <Hugh> ummm
08:31:18 <merijn> Let's look at putStrLn
08:31:20 <elliott> dolio: yes, indeed
08:31:41 <Hugh> can I show you what I have been playing with...
08:31:52 <elliott> dolio: a shame we don't call categories monoidoids
08:31:59 <merijn> Hugh: "putStrLn :: String -> IO ()", so putStrLn is a *function* that takes a String and returns an *action* that prints said String
08:32:06 <elliott> maybe categories should be monoids and monoids should be mons
08:32:14 <elliott> I love mons, they are so ea.
08:32:18 <yitz> hi again merijn
08:32:24 <merijn> Hugh: putStrLn is a pure function, because if you pass it the same string, the resulting action will be the same too
08:32:27 <dolio> Yeah, the guy who coined the term obviously didn't anticipate the pattern.
08:32:40 <Hugh> I want to read from stdin handle into a String and then pass that String into 'words' to return a list of the words
08:33:11 <dmwit> Hugh: You can teach "words" how to handle IO String's using fmap.
08:33:12 <dmwit> :t fmap words
08:33:13 <lambdabot> Functor f => f String -> f [String]
08:33:14 <dolio> Actually, it doesn't make a lot of sense, because a monoid is a category with one object, not necessarily a groupoid with one object.
08:33:28 <dmwit> Hugh: (IO is a Functor, so that f can be IO.)
08:33:35 <dmwit> :t fmap words :: IO String -> IO [String]
08:33:36 <lambdabot> IO String -> IO [String]
08:33:36 <dolio> The latter of which would be a group.
08:33:54 <Hugh> wow! that is a whole new thing there! what is a functor?
08:33:58 <yitz> elliott: and if you use the monoid as keys to a map, then we can post lambdamonkeys pics next to the lambdacats
08:34:05 <merijn> dmwit: I'd drop the functor bit for now
08:34:25 <merijn> Hugh: Occasionally we'd like our actions to depend on the result of previous actions, though
08:34:58 <merijn> Hugh: So how can we approach that? With >>=, which has the type "Monad m => m a -> (a -> m b) -> m b"
08:35:04 <dmwit> Yes, mentioning functors was a mistake. I should have given an explicit type ascription. to begin with.
08:35:05 <erisco> > id 8 * id 2
08:35:07 <lambdabot>   16
08:35:17 <Hugh> ok, thanks for the help. I'm going to carry on reading...
08:35:36 <dmwit> The two teachers are "fmap :: (a -> b) -> (IO a -> IO b)" and "(=<<) :: (a -> IO b) -> (IO a -> IO b)".
08:35:54 <erisco> > Just (+2) <*> Just (6)
08:35:55 <lambdabot>   Just 8
08:36:05 <merijn> Hugh: It basically says, given an action of type 'm' that produces as, and a function that makes a 'b' producing action from an 'a', return a 'b' producing action
08:36:06 <dmwit> The only difference between these is in the return type of the argument function: fmap teaches pure functions (ones that don't do IO); (=<<) teaches impure functions (ones that do do IO).
08:36:37 <erisco> bit confused on the syntax here...
08:36:40 * dmwit shuts up
08:36:51 <dmwit> erisco: Why's that?
08:36:56 <Hugh> ok...
08:37:08 <erisco> well I would have expected to need braces for infix on, say,  id 8 + id 1
08:37:22 <dmwit> Function application binds tighter than anything except record syntax.
08:37:32 <ocharles> it's not just that, + has a specific fixity
08:37:42 <erisco> dmwit, then why doesn't + bind to id?
08:38:12 <dmwit> If you want to treat + as a function, you must wrap it in parentheses.
08:38:12 <erisco> why not   ((id 8) + id) 1
08:38:18 <dmwit> > id (+) 8 1
08:38:20 <lambdabot>   9
08:38:25 <dmwit> > (+) 8 1
08:38:27 <lambdabot>   9
08:38:37 <erisco> does it bind right to left?
08:38:42 <dmwit> Without parentheses, it is an infix function; with parentheses it is just a function.
08:38:44 <ziman> erisco, because "id 1" binds tighter than "+ id"
08:38:58 <dmwit> erisco: infixl 6 + according to ghci
08:39:07 <dmwit> erisco: Meaning + associates to the left and has precedence 6.
08:39:18 <dmwit> erisco: Use :i to query your other favorite operators.
08:39:22 <dmwit> e.g. :i *
08:39:24 <yitz> function application binds more tightly than infix n for any n
08:40:07 <dmwit> Also: the answer to why not ((id 8) + id) 1 is because, as I said, function application binds tighter than anything except record syntax.
08:40:23 <dmwit> So the space in (id 1) binds tighter than +.
08:40:50 <lolman> is FRP difficult to learn? :x all tutorials seem very abtract and i dont really get it
08:41:59 <conal> lolman: an accessible (though dated) ftp tutorial: http://conal.net/fran/tutorial.htm
08:42:08 <lolman> conal: thanks
08:42:17 <Chousuke> my biggest problem with FRP libraries is usually how to get from input to an even stream repressenting that input and how to use it properly :P
08:42:39 <Chousuke> and what is "reactimate" supposed to mean?
08:42:42 <lolman> also, i think FRP is really gonna become the new thing, recent elm and there's also a game studio who develop an haskell FRP game engine for mobile phones
08:43:01 <CaptainK> has anyone tried haskell on TinyCore Linux?
08:44:32 <merijn> lolman: I (personally) recommend reading the Push-Pull FRP paper after the FRAN one, thing really clicked when I was studying the code of that
08:44:37 <CaptainK> Price has gone up :), but its worth it
08:44:52 <conal> :)
08:44:57 <lolman> merijn: is the FRAN one the one named "Functional Reactive Animation"?
08:44:58 <dmwit> I also liked Push-Pull FRP very much.
08:45:09 <merijn> lolman: Yes
08:45:11 <lolman> ok
08:45:13 <lolman> thanks
08:46:01 <dmwit> And then I liked looking at the source on Hackage a lot, because I recall being surprised that something could ever work until I saw that the source used unsafeSomethingSomething.
08:46:28 <merijn> dmwit: You mean the unamb/improving values stuff?
08:46:34 <lolman> merijn: have you used FRP in any project? if so, which library did you use?
08:46:37 <conal> lolman: also see http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming/1030631
08:46:43 <dmwit> I don't remember what surprised me any more.
08:46:53 <dmwit> Or what resolved my surprise.
08:47:06 <dmwit> Other than looking at the source. =)
08:47:23 <lolman> conal: are you conal the owner of conal.net?
08:47:36 <conal> lolman: also: http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language
08:47:41 <conal> lolman: yes
08:47:49 <merijn> lolman: I have been trying to design a nicely coherent GUI framework (I'm still messing with it, tbh), the libraries I looked at most were netwire, reactive and reactive-banana
08:47:55 <lolman> nice, you are a researcher in the subkject? :D
08:48:11 <lolman> merijn: okey
08:48:21 <merijn> lolman: netwire is nice, but is based on Arrowised FRP, which means it doesn't deal with continuous time as nicely
08:48:29 <merijn> lolman: He invented the subject
08:48:57 <lolman> WOOOOOOOOOT, it always nice to meet celebrities on IRC :)
08:49:03 <conal> merijn: arrow-FRP originally was continuous time. then strayed, afaict.
08:49:07 <applicative> hey conal happend by. hello conal
08:49:14 <applicative> happened even
08:49:16 <conal> applicative: howdy!
08:49:53 <merijn> conal: I guess the problem is more that AFRP seems to promote a push approach, I guess that with a pull approach it could be made continuous without too much trouble
08:49:54 <lolman> conal: what is the best FRP implementation?
08:50:08 <merijn> lolman: It really depends on your goals
08:50:22 <lolman> so is there different kinds of FRP?
08:50:44 <circle> what the hell is wrong with the pastebin
08:51:58 <conal> lolman: i don't know which. most "ftp" implementations really implement something different but call it "ftp" anyway. (they lack the two key properties mentioned in the second stack overflow link above.)
08:52:43 <circle> can anyone hear me?
08:52:45 <circle> hello?
08:52:49 <circle> HELLO?
08:52:59 <dmwit> We can hear you.
08:53:03 <lolman> circle: hola, como te llamas
08:53:06 <circle> oh okay
08:53:10 <merijn> circle: hpaste you mean?
08:53:12 <circle> I thought I might have been shadowbanned
08:53:18 <circle> locked in a cage of silence
08:53:22 <dmwit> ?where hpaste
08:53:22 <lambdabot> http://paste.tryhaskell.org/new/haskell
08:53:23 <merijn> circle: It's dead, the new paste site is paste.tryhaskell.org/new/haskell
08:53:42 <circle> merijn: try going there
08:53:43 <lolman> conal: did you say FTP as an example, or did we missunderstand and you are the author of "FTP", not "FRP" as in funcitonal reactive programming?
08:53:49 <circle> merijn: it's just a page listing IRC "stats"
08:54:11 <conal> hah. i meant "ftp", not "ftp".
08:54:23 <merijn> circle: append new/haskell
08:54:32 <lolman> o.o
08:54:38 <dmwit> merijn: No, he's right.
08:54:47 <merijn> dmwit: oh, did it break? >.>
08:55:05 <conal> weird. i made that typo twice in one response.
08:55:05 <dmwit> seems so
08:55:58 <dmwit> conal: and three times in two responses!
08:56:37 <conal> :)
08:57:31 <Cale> conal: Perhaps you left your computer unlocked while you were up and someone came along and added a keyboard macro :)
08:57:31 <dmwit> lolman: Anyway, yeah, I'm pretty sure he meant "frp" instead of "ftp" basically everywhere except the second occurrence in his correction.
08:57:51 <circle> I'm having an error I can't figure out
08:57:58 <dmwit> So... who's in charge of paste.tryhaskell.org?
08:58:04 <dmwit> Is that chrisdone still?
08:58:04 <lolman> okey :D
08:58:06 <circle> http://pastebin.ws/2yvx66
08:58:18 <quicksilver> dmwit: yes.
08:58:22 <quicksilver> dmwit: he just set up lpaste.net
08:58:38 <dmwit> yikes, so many URLs!
08:58:43 <dmwit> ?where+ hpaste lpaste.net
08:58:43 <lambdabot> Good to know.
08:59:48 <circle> anyone?
09:00:10 <dmwit> circle: You're trying to take the min (or max) of an Int and a [Int].
09:00:26 <dmwit> Perhaps you will like "minimum" or "maximum".
09:00:26 <circle> dmwit: I thought so. Yet, when I take out the min and max parts, it stills throws the same error.
09:00:43 <dmwit> "take out" how?
09:00:52 <Cale> circle: The type signature of your function also specifies that it produce an Int and not an [Int]
09:01:11 <circle> dmwit: Just remove them. The function isn't being used yet, so I can do that.
09:01:15 <circle> dmwit: Here's an example.
09:01:36 <dmwit> Perhaps you had better post the definition of your tree type, then.
09:01:45 <applicative> max n (maximum (map ffdd xs))
09:01:54 <Cale> dmwit: I think he means just producing the result of the map
09:01:59 <Cale> which will of course be a list
09:02:03 <dmwit> maximum (n:map fbp xs) -- would be my preferred spelling.
09:02:09 <Cale> which won't agree with his given type signature
09:02:13 <applicative> or maximum (n : map blah xs)
09:02:15 <circle> dmwit: http://pastebin.ws/8vslq0
09:02:21 <applicative> right dmwit
09:02:47 <dmwit> circle: You are trying to return a list but announced that you would return an Int.
09:03:17 <erisco> > [1,2,3] <|> [4,5,6]
09:03:19 <lambdabot>   [1,2,3,4,5,6]
09:03:23 <circle> dmwit: am I?
09:03:29 <circle> dmwit: one sec
09:03:35 <erisco> > [1] <|> [4,5,6]
09:03:37 <lambdabot>   [1,4,5,6]
09:04:01 <applicative> circle: that one will work if youi write  empty t = [n] then it gives a list of Ints -- if I'm following the Tree type
09:04:03 <circle> dmwit: I am returning an int though, the minimum of what I find?
09:04:14 <lolman> circle: why do you have "p == Player_A = (map fbp xs)" AND "otherwise = (map fbp xs)" instead of just the latter? also xs is a list of nodes i pressume?
09:04:15 <circle> applicative: tree type is   9 data Tree a = Node a Players [Tree a]
09:04:24 <dmwit> circle: In the second code snippet you pasted, you call "map". "map" returns a list.
09:04:45 <lolman> did i miss anything?
09:04:52 <circle> dmwit: Oh. So same error, different reasons?
09:04:55 <circle> dmwit: Damn!
09:05:00 <dmwit> Correct.
09:05:10 <circle> dmwit: So, regarding the first snippet, what would I do to get it to work?
09:05:16 <bb010g> When working with state, is this pop good form, or can it be optimized some?
09:05:21 <applicative> circle: the second one you paste could be called toList :: Tree Int -> [Int] , then you could do treeMaximum = maximum . toList
09:05:22 <bb010g> http://lpaste.net/90759
09:05:38 <circle> lolman: Yeah, look upwards to my first paste.
09:05:51 <dmwit> circle: The non-spoiler version is that there's a function minimum :: [Int] -> Int; the spoilers version is above.
09:06:07 <lolman> circle: can you please re-link it, i got disconnected?
09:06:12 <dmwit> circle: Independently I have some stylistic concerns. But they wouldn't affect whether it works or not.
09:06:32 <applicative> bb010g: pop seems it could be improved
09:06:54 <bb010g> applicative: I know, but I'm not sure how...
09:07:03 <circle> dmwit: Is what applicative wrote the spoilers version?
09:07:17 <dmwit> applicative and I each gave spoilers versions.
09:07:52 <circle> ah yours makes a lot more sense
09:08:02 <dmwit> bb010g: You could, for example, use pop = do { h:t <- get; put t; return h }
09:08:34 <bb010g> applicative: Oh. I forgot you could pattern match in do blocks.
09:08:55 <dmwit> bb010g: Also, you might like "gets" in the future. "gets f = liftM f get", approximately.
09:09:15 <bb010g> dmwit: Ah.
09:10:13 <dmwit> bb010g: Also, you might like modify. "modify f = gets f >>= put", approximately.
09:10:30 <applicative> oh right forgot about gets; but he shouldn't be using head
09:10:47 <dmwit> Yes, well, that's another concern. =)
09:10:54 <bb010g> applicative: Why?
09:10:57 <dmwit> pop :: State Stack (Maybe Int) might be better.
09:11:44 <bb010g> dmwit: I am going to be emulating a HP35s, which has a persistent 4-long stack. (Normally, they're all zeroes.)
09:11:47 <CaptainK> elediaz: gracius para aduyda en espanol
09:11:51 <elliott> dmwit: only approximately?
09:12:03 <dmwit> elliott: I don't know. So I thought I would be conservative.
09:12:11 <dmwit> If it's exactly equal, it's also approximately equal.
09:12:29 <dmwit> bb010g: Perhaps your stack should be (Int, Int, Int, Int) instead of [Int], then. ;-)
09:12:43 * bb010g facepalms
09:12:58 <bb010g> dmwit: Thanks. :)
09:13:19 <applicative> oh I see.  I was going to do a Maybe on your code bb010g http://lpaste.net/90759
09:14:19 <applicative> with the lens library and state (Int, Int,Int,Int) , wouldn't this be :  "using _1"
09:14:27 <dmwit> That depends.
09:14:32 <bb010g> Side note: Is someone going to change the IRC header to lpaste.net instead of paste.tryhaskell.org?
09:14:38 <dmwit> Maybe popping shifts everything to the left and puts a 0 at the end or something.
09:14:41 <dmwit> I don't really know.
09:14:42 <applicative> i'm not sure what he was doing with putting the tail.
09:14:48 <applicative> ah
09:15:02 <bb010g> It falls off on a push, and a pop duplicates it.
09:15:21 <dmwit> Okay. Well, your current pop definitely wasn't doing that.
09:15:34 <applicative> so it should be get >>= \(a,b,c,d) -> put (b,c,d,0) >> return a
09:15:40 <applicative> or something
09:15:46 <dmwit> ...and your current push wasn't doing the "falls off" behavior, either.
09:15:53 <bb010g> dmwit: I know. I was just trying to get the types working at first.
09:16:15 <dmwit> ok =)
09:16:45 <applicative> push x = get >>= \(a,b,c,d) -> put (n,a,b,c) ?
09:17:04 <dmwit> s/x/n/
09:17:17 <applicative> right, changed my mind in there ....
09:17:28 <applicative> push n = get >>= \(a,b,c,d) -> put (n,a,b,c)
09:18:00 <dmwit> and pop = get >>= \(a,b,c,d) -> put (b,c,d,d) >> return a, yes
09:18:17 <applicative> i see it dups the end, okay, I'm with it
09:19:03 <chrisdone> monochrom: poke
09:19:12 <bb010g> Changed the paste.
09:19:17 <monochrom> good morning
09:20:57 <dmwit> monochrom: Will you put lpaste in the topic instead of tryhaskell?
09:21:58 <monochrom> oh!
09:22:02 --- mode: ChanServ set +o monochrom
09:22:10 <monochrom> err, what's the exact url again?
09:22:28 <applicative> http://lpaste.net/
09:22:45 --- topic: set to 'http://haskell.org | Paste code/errors: http://lpaste.net/ | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by monochrom
09:22:57 <dmwit> Thanks!
09:23:04 --- mode: monochrom set -o monochrom
09:23:19 <chrisdone> \o/
09:23:37 <monochrom> what happened to ipaste, jpaste, and kpaste? :)
09:24:18 <monochrom> "they have been taken by those quaternion people"
09:24:21 <chrisdone> monochrom: \paste ;)
09:24:56 <erisco> dolio, if parserB can't parse, and returns a ParseError, it doesn't have any label, so I can't evaluate the mapping function from parserA for my Applicative implementation
09:25:20 <CaptainK> chrisdone: that would be nice to have a color paste  bin
09:26:08 <erisco> dolio, I would have to change the Parser type to Parser (ListView t -> [n]) but then I can't get any information back from my parse :s
09:26:11 <applicative> bb010g: if you are using something like (Int,Int,Int,Int) it may be well to make a special tuple data Stack = Stack !Int !Int !Int !Int deriving (Show, Eq, Ord, etc.)
09:26:45 <bb010g> applicative: What do the !'s mean?
09:26:53 <applicative> strict fields
09:27:07 <bb010g> applicative: Why do they need to be strict?
09:27:33 <applicative> bb010g: its just generally clearer with State and less disaster prone
09:27:47 <applicative> it's not important, but the tuple types are good and lazy
09:27:53 <bb010g> applicative: Example disasters?
09:28:00 <erisco> dolio, so the type of \> may look like <*> but I don't think the internals match up
09:28:23 <dmwit> bb010g: The example disaster is running an operation that increments the first thing on the stack a million times.
09:28:30 <dmwit> Then when you finally evaluate it, BOOM! stack overflow
09:29:19 <bb010g> Can I just do something like (!Int, !Int, !Int, !Int)?
09:29:42 <applicative> no, there is no such type
09:29:56 <applicative> there is (# Int#,Int# ...#)
09:30:10 <applicative> but you wouldnt be able to use it here.
09:30:14 <bb010g> applicative: And the octothorpes mean...
09:30:25 <applicative> that the fields are unboxed.
09:30:50 <fizbin> (It's a GHC-specific extension)
09:30:51 <applicative> with 'unbox strict fields' the compiler will make the type I mentioned into something like that.
09:30:53 <nabilhassein> the documentation for Network.TCP seems a bit sparse: http://hackage.haskell.org/packages/archive/HTTP/latest/doc/html/Network-TCP.html
09:31:01 <erisco> dolio, maybe I am doing it wrong again :) I'll keep plugging
09:31:10 <nabilhassein> is it better to just use Network's connectTo, etc. for TCP stuff?
09:31:34 <bb010g> applicative: Ok. I'll just do a custom data type then.
09:31:42 <chrisdone> nabilhassein: there's also Network.Socket
09:32:14 <chrisdone> nabilhassein: if you don't care much about controlling the details, Network is fine. otherwise, Network.Socket is also good
09:32:23 <applicative> nabilhassein: http://hackage.haskell.org/packages/archive/network-simple/0.2.1.0/doc/html/Network-Simple-TCP.html ?
09:33:05 <nabilhassein> chrisdone, applicative: thanks. is Network.TCP not widely used? googling around for examples didn't turn up many using it that i saw
09:33:25 <benmachine> the usual choice is the network package
09:33:28 <chrisdone> i've never heard of Network.TCP
09:33:32 <benmachine> but it has some drawbacks
09:33:37 <benmachine> so there are a few alternatives
09:33:48 <applicative> its maintained together with HTTP so it cant be too esoteric.
09:34:10 <applicative> nabilhassein: here's a demo of Network.Simple.TCP https://github.com/k0001/network-simple/tree/master/examples
09:34:50 <applicative> I don't know if it's used much or if he made it in order to link it in with his pipes-network scheme
09:35:33 <nabilhassein> applicative: awesome, thanks very much!
09:37:56 <nabilhassein> benmachine: what kind of drawbacks to network are you referring to?
09:38:36 <dncr> Can I specify -Wall as a pragma line at the beginning of my source files?  Also, should I not do this?
09:38:45 <benmachine> nabilhassein: nothing major, the API is just a bit naff
09:39:01 <chrisdone> monochrom: ah, wait. can you please set the link to this? http://lpaste.net/new/haskell that way, it defaults to #haskell as channel and language. sorry for not noticing earlier!
09:39:10 --- mode: ChanServ set +o monochrom
09:39:17 <benmachine> nabilhassein: e.g. http://stackoverflow.com/questions/14172149/haskell-socks5-refusing-to-connect/14173674#14173674 -- it's easy to use it wrongly
09:39:20 --- topic: set to 'http://haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com' by monochrom
09:39:27 <chrisdone> monochrom: thanks =)
09:39:29 --- mode: monochrom set -o monochrom
09:41:59 <applicative> dncr: {-##OPTIONS_GHC -Wall -}
09:42:01 <dncr> Ah, I was missing a hyphen in: {-# OPTIONS_GHC -Wall #-}
09:42:16 <dncr> Now, is it Bad?
09:42:22 <applicative> woops mine is mistyped
09:42:30 <lolman> http://hackage.haskell.org/package/sodium that FRP library will maybe be used in a game :D
09:42:32 <applicative> bad? how could -Wall be bad
09:42:43 <dncr> idk -Werror probably can be
09:43:02 <lolman> does -Wall stands for "all warnings"
09:43:04 <merijn> dncr: It'd be better to specify -Wall in your cabal file
09:43:04 <applicative> dncr: if you have a cabal file for your project you can put it in there, and make it subordinate to -ftesting or some variable
09:43:09 <merijn> lolman: Yes
09:43:13 <dncr> watching ghc error scroll makes me a haskell expert overnight
09:43:34 <dncr> merijn: why is that superior
09:43:37 <dolio> erisco: Yes, your current implementation does not match up with applicative parsers quite. I think your stuff is a little weird, to be honest.
09:43:50 <dncr> merijn: that does seem to be more common
09:43:56 <applicative> dncr you can control some of the sillier warnings also, e.g. but putting in -fno-warn-missing-do-binds or whatever its called
09:44:13 <dncr> applicative: mm see that may make more sense per-file..
09:44:19 <applicative> yeah
09:44:44 <applicative> it's good to start out with -Wall  the most important thing is of course missing cases.
09:44:56 * dncr not cut out for TMTOWTDI
09:46:03 <benmachine> dncr: the idea is to put flags in your files that are somehow a property of the file itself
09:46:15 <benmachine> so if the file is written in such a way that it generates spurious warnings, disable those warnings
09:46:37 <benmachine> but how many warnings you want /in general/ seems like a property of the developer, instead of a property of the source file
09:47:01 <applicative> you are frequently willfully doing something the warnings warn about.
09:47:13 <erisco> dolio, well, my weird stuff I don't think is important. It just seems to be that my ParseResult is either ParseMatch or ParseError, and with ParseError I have no label
09:47:15 <dolio> erisco: In applicative/monadic parsers, the 'parse result' stuff is encapsulated in the Parser type, and the parsers you write don't deal in it.
09:47:34 <applicative> it should warn about Prelude,head read etc
09:47:42 <erisco> dolio, how does that get encapsulated?
09:47:45 <dolio> You just deal with the labels, which are the things that the parser will eventually return, if successful.
09:48:19 <erisco> dolio, but without extra information about what was actually parsed I can't write the combinators
09:48:31 <erisco> dolio, particularly I can't write \>
09:48:44 <erisco> dolio, not sure what else one would do
09:48:55 <applicative> actually, that would be a good idea.  I think the teachers are against removing things like head, which is admittedly occasionally useful, but why not add it to -Wall
09:49:30 <applicative> then -fno-warn-evil-prelude
09:49:48 <b52> who in here does work for fpcomplete?
09:49:53 <dncr> applicative: i'm not sure, throwing _|_ around seems to be part of a trade-off that haskell designers chose
09:49:54 <dolio> erisco: I'm not exactly sure where your problem is.
09:50:07 <applicative> b52 johnw is frequently around
09:50:14 <dolio> If you have Error <*> whatever, then the result can be Error, which also doesn't need a label.
09:50:20 <erisco> dolio, well if I run parserA, to run parserB in parserA \> parserB, I need to know where parserA left off (I also need to know if it succeeded or not)
09:50:22 <dncr> applicative: i've sometimes restructured to not handle a temporary _|_ and the code was far less readable
09:50:34 <b52> johnw: could you tell me when your going to sort out the PackageImports bug?
09:50:43 <dncr> applicative: it's not ATS afterall
09:51:08 <applicative> dncr: yes, but some things are really a menace.  missing cases are all over the place.
09:51:23 <dncr> applicative: i guess it is similar to missing cases
09:51:28 <erisco> dolio, so to me it would be necesssary for the parser to return such information
09:51:34 <elliott> erisco: you have a Functor instance yes?
09:51:43 <elliott> and (\>) :: Parser t a -> Parser t b -> Parser t (a,b)?
09:51:44 <erisco> elliott, yes
09:51:48 <erisco> yes
09:51:59 <dolio> erisco: Yes.
09:52:01 <monochrom> dncr: have you seen my http://www.vex.net/~trebla/haskell/crossroad.xhtml ?
09:52:01 <elliott> does p <*> q = fmap (\(f,x) -> f x) (p \> q) not obey the Applicative laws?
09:52:18 <erisco> elliott, that rhs is a type error for me
09:52:33 <shafire> z8
09:52:34 <applicative> dncr: anyway, I was just thinking it might be a good warning, one you can turn off, I wonder how hard it would be to add in
09:52:35 <shafire> hi
09:52:38 <elliott> um, are you sure
09:52:49 <dncr> monochrom: i'm seeing it now
09:52:55 <applicative> hi shafire
09:52:56 <erisco> elliott, my Parser type is not what Applicative is expecting ... my type param is "buried"
09:53:01 <shafire> Is it true, that Haskell has the best typesystem?
09:53:12 <dncr> applicative: i suppose totalness is the future
09:53:30 <elliott> erisco: oh, your (\>) still uses the type synonym version?
09:53:45 <elliott> erisco: then I have an exercise: write (\\>), same as (\>), but which uses the data type version.
09:53:47 <erisco> elliott, I don't know what you mean. the type issue is rooted in a couple factors, afaik
09:53:48 <elliott> should be very easy
09:53:49 <applicative> well, idris to be practical has %default partial and %default total
09:53:58 <elliott> alternatively, hpaste your code?
09:54:17 <CaptainK> monochrom: thats a good read for a newbie...thanks
09:54:21 <monochrom> it's lpaste for you now :)  (see topic)
09:54:25 <erisco> sure, I can do that. I think I have the issue fairly clear but maybe there is a fix I'm not seeing
09:54:33 <ParahSailin> @hoogle (\>)
09:54:33 <lambdabot> No results found
09:54:45 <elliott> bah. muscle memory ensures I will call it hpaste forever
09:55:02 <applicative> is lpaste supposed to be Œªpaste ?
09:55:02 <mauke> monochrom: I seem to recall a blog post about booleans as an antipattern
09:55:07 <arkeet> @hpaste
09:55:08 <lambdabot> Haskell pastebin: http://hpaste.org/
09:55:11 <elliott> chrisdone: hm, all paste.tryhaskell.org links are broken? :/
09:55:20 <elliott> @@ mauke: @google boolean blindness
09:55:22 <lambdabot>  mauke:
09:55:22 <lambdabot>  http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
09:55:22 <lambdabot>  Title: Boolean Blindness | Existential Type
09:55:28 <mauke> elliott++
09:55:30 <applicative> mauke: oh yes aweome post of Prof Harper
09:55:31 <erisco> hpaste is down for me
09:55:43 <mauke> erisco: read ^
09:55:43 <arkeet> it's lpaste now
09:55:53 <mauke> @where hpaste
09:55:53 <lambdabot> lpaste.net
09:55:55 <mauke> @where lpaste
09:55:55 <lambdabot> I know nothing about lpaste.
09:55:58 <arkeet> @lpaste
09:55:58 <lambdabot> Haskell pastebin: http://hpaste.org/
09:56:02 <arkeet> =(
09:56:07 <arkeet> blelliot
09:56:08 <erisco> mauke, read what?
09:56:08 <mauke> @where+ hpaste http://lpaste.net/new/haskell
09:56:08 <lambdabot> Good to know.
09:56:11 <mauke> @where+ lpaste http://lpaste.net/new/haskell
09:56:12 <monochrom> yes mauke, but it's too long for too few points. mine is superior. this is biased of course :)
09:56:12 <lambdabot> I will never forget.
09:56:17 <mauke> erisco: what people have been saying in the channel
09:56:29 <mauke> like the stuff about hpaste moving
09:56:44 <elliott> arkeet: hey I already fixed my local lambdabot codebase to link to paste.haskell.org originally
09:56:55 <arkeet> you mean tryhaskell?
09:56:55 <applicative> oh I thought mauke was telling erisco to read Harper on booleans
09:56:59 <mauke> the @hpaste command should be removed
09:56:59 <elliott> no, haskell
09:57:04 <elliott> since the plan was to move it there
09:57:07 <arkeet> oh
09:57:10 <elliott> I figure I give it a week to go through another 100 URLs and then fix it :P
09:57:14 <arkeet> what happened to hpaste.org anyway?
09:57:36 <monochrom> DNS provider feud
09:57:38 <erisco> okay here we are: http://lpaste.net/90765
09:57:42 <nab_> niggers
09:57:43 <erisco> so this doesn't compile
09:57:43 <arkeet> ah
09:57:47 <nab_> FUCK YOU
09:57:48 --- mode: ChanServ set +o monochrom
09:57:49 --- mode: ChanServ set +o mauke
09:57:50 --- mode: ChanServ set +o elliott
09:57:56 <elliott> hmph
09:58:09 --- mode: mauke set +b *!*@204.14.79.61
09:58:26 <shafire> Is it true that Haskell has a good typesystem (like Scala, or Scala copied from Haskell, I don't know at moment)?
09:58:26 <arkeet> mauke: that mask won't work
09:58:34 <mauke> arkeet: are you sure about that?
09:58:37 <dmwit> What DNS providers are they, so I know to avoid them in the future?
09:58:45 <elliott> I believe you need a * after the @. for webirc.
09:58:45 <erisco> so the two factors are: ParseResult might be ParseError, and ParseError has no label, coupled with the fact that a Parser is Segment a -> [ParseResult t n]   instead of something like  Segment a -> n
09:58:46 <arkeet> it doesn't match the hostname or whatever.
09:58:53 <applicative> monochrom: maybe you should add something about how case/pattern matching  advances evaluation ?
09:58:58 <mauke> arkeet: I think it does
09:59:02 <mauke> I'll have to check the docs
09:59:05 <erisco> with \>, I collect ParseResult in the tuples, but the same doesn't happen with Applicative
09:59:22 <arkeet> I'm pretty sure it doesn't, but ok
09:59:30 <monochrom> "if null xs then..." also advances evaluation the same way
09:59:31 <dmwit> shafire: The question is unanswerable as asked. Make it more objective, please.
09:59:46 <mauke> shafire: yes
09:59:57 <applicative> monochrom: yeah, it could advance it more
10:00:00 <dmwit> shafire: One way to figure out how to make it more objective is to consider what you would do if I answered "yes".
10:00:01 <yesthisisuser> shafire: http://www.thesyntacticsugar.com/the-notion-of-a-kind/
10:00:09 --- mode: mauke set -o mauke
10:00:41 <shafire> dmwit: mauke: yesthisisuser: thanks
10:00:41 <applicative> it has to evaluate the boolean, so it might need to analyze the argument more
10:01:17 <mauke> arkeet: docs say "Bans set on IP addresses will apply even if the affected user joins with a resolved or cloaked hostname.", #freenode just confirmed that also applies to webchat
10:01:29 <arkeet> interesting.
10:01:34 <arkeet> must be a freenode thing.
10:01:42 <anddoss> fuck off niggers
10:01:45 <anddoss> FUCKING BITCH
10:01:45 <dncr> monochrom: how would this be handled in a total language?: map head (group [1, 1, 1, 4, 4, 1, 1])
10:01:47 <anddoss> FUCK YOU
10:01:47 <applicative> oh god
10:01:52 --- mode: ChanServ set +o geekosaur
10:01:52 --- mode: ChanServ set +o mauke
10:01:52 --- mode: mauke set +b *!*@gateway/web/freenode/ip.50.117.80.189
10:01:56 --- mode: geekosaur set -o geekosaur
10:02:04 <dmwit> dncr: group would have a different type
10:02:07 <arkeet> dncr: group should specify in its type that it returns a list of nonempty lists.
10:02:13 <dmwit> dncr: group :: Eq a => [a] -> [(a, [a])] or similar
10:02:17 <dncr> ok
10:02:28 <arkeet> (a,[a]) is a nonempty list.
10:02:38 <dmwit> or type NonEmptyList a = (a, [a]) and then group :: Eq a => [a] -> [NonEmptyList a], as shachaf is about to complain
10:02:45 * elliott makes the executive decision to keep the +o on for some minutes
10:02:46 <applicative> dncr you wouldn't do that with a map
10:02:57 <erisco> maybe I can give a sensible label to a parse error... doesn't make a lotta sense but guess I'll try
10:03:11 <dmwit> erisco: I don't think you should try to do that.
10:03:20 <elliott> erisco: have you thought about trying my suggestion of rewriting (\>) to work with the type you were trying to make Applicative?
10:03:26 <arkeet> dmwit: I'd use a data
10:03:29 <elliott> I think being able to define (<*>) like I showed would clear things up a lot.
10:03:45 <dmwit> arkeet: neat
10:03:52 --- mode: mauke set -o mauke
10:04:07 <erisco> elliott, I don't see what is special about that... I'll just scoop the parsing functions out of the Parser type
10:04:38 <elliott> erisco: well, I gave a definition of (<*>).
10:04:47 <erisco> yeah and I said it was a type error
10:04:50 <elliott> all it requires is that you change your existing (\>) to use the data type you defined, not your type synonym.
10:04:54 <erisco> and I pasted the codes :)
10:04:56 <elliott> that's should be a really easy change.
10:04:58 <elliott> oh, I didn't see the paste
10:05:11 <erisco> http://lpaste.net/90765
10:05:30 <elliott> erisco: hm. I asked if (\>) :: Parser t a -> Parser t b -> Parser t (a, b) and you said yes
10:05:34 <elliott> but this is not the case, so yes, my solution does not work
10:05:55 <spiridom> niggers fuck you!
10:05:56 <erisco> elliott, right sorry, I read too quickly
10:05:59 <spiridom> bitchass fags
10:06:00 --- mode: elliott set +b *!*451f67b8@*.69.31.103.184
10:06:00 --- kick: spiridom was kicked by elliott (spiridom)
10:06:01 <hughfdjackson> I just saw https://gist.github.com/quchen/5280339
10:06:11 <hughfdjackson> just want to say, nicely done all involved ^^
10:06:22 <erisco> elliott, but yes that is the problem, it is because the type I'm working on is buried in the parseresult
10:06:27 <monochrom> I'm going to do this:
10:06:33 --- mode: monochrom set +q $~a
10:06:50 <elliott> what does that do?
10:06:57 <mauke> silences all unidentified users
10:07:09 --- mode: elliott set +z
10:07:12 <mauke> i.e. if you're not registered/identified with nickserv, no one can hear you speak
10:07:19 <elliott> (so we can set exceptions for legit people)
10:07:26 <elliott> (assuming I'm remembering how +z works)
10:07:39 --- mode: elliott set +b *!*cc0e4f3a@*.204.14.79.58
10:07:39 --- kick: suse was kicked by elliott (suse)
10:07:53 <mauke> I think that's a yes because I didn't see anything
10:08:01 --- mode: ChanServ set +o mauke
10:08:02 <elliott> great
10:08:03 <CaptainK> some users have terets here?
10:08:33 <elliott> terets??
10:08:42 <erisco> elliott, is that the only kind of signature that is going to work?
10:08:56 <Bor0> can someone suggest me a good and painless article/video material intro to category theory?
10:09:26 <elliott> erisco: well, it's the standard one you can go from a Functor instance to (<*>) with
10:09:30 <elliott> you might still be able to write (<*>) in another way
10:10:55 --- mode: mauke set +q *!*@gateway/web/*
10:11:05 <erisco> elliott, I think regardless of what I do, even with some definition, I won't be able to keep the extra parse information (that stored in ParseResult)
10:11:05 <dolio> erisco: Why does (\>) return a Parser (ParseResult a, ParseResult b) instead of just a Parser (a, b)? Isn't that something like Input -> ParseResult (ParseResult a, ParseResult b)?
10:11:08 <erisco> like I am currently
10:11:20 <dolio> Why the parse result nesting?
10:11:26 --- mode: mauke set -q *!*@gateway/web/*
10:11:49 <elliott> maybe we should remove the $~a +q and just +q webirc instead?
10:11:57 --- mode: mauke set +q *!*@gateway/web/freenode/*
10:12:01 <erisco> dolio, because it allows me to associate what I found back with the source it was derived from
10:12:10 <pmade> Bor0: http://arxiv.org/abs/1302.6946
10:12:15 <elliott> yesthisisuser: (your messages to the channel aren't showing to non-ops because of the temporary antispam +q added just now, sorry); Bor0: <yesthisisuser> Bor0: aah.. this is the one: http://en.wikibooks.org/wiki/Haskell/Category_theory
10:12:24 --- mode: mauke set -z
10:12:27 <mauke> let's see
10:12:43 <erisco> dolio, I feel like if I lose that then I am gimping what I can learn from the parser
10:12:46 <mauke> this change has silenced sclv_ and shafire, btw
10:13:00 <Bor0> thanks
10:13:04 <erisco> dolio, most especially if there is any sort of error
10:13:18 <elliott> mauke: $~a is still +q'd
10:13:22 <mauke> argh
10:13:23 --- mode: mauke set +z
10:13:28 --- mode: mauke set -q $~a
10:13:31 <mauke> brainfart
10:13:56 <ion> I think there‚Äôs a mode to prevent brainfarting.
10:14:03 <kloeri> mauke: you can just voice those people if you want to keep the webchat quiet
10:14:16 --- mode: mauke set +vv sclv_ shafire
10:14:29 <mauke> let's see how it goes
10:14:29 <erisco> it aint applicative, so I'll stop trying :P
10:16:42 <shafire> mauke: which change do you mean?
10:17:05 <mauke> shafire: unsilence unidentified users, silence webchat users
10:17:10 <shafire> why I am + :-(
10:17:14 <mauke> since you're identified but on webchat
10:17:18 <shafire> ah ok
10:17:29 <shafire> I am using always the webchat...
10:17:33 <elliott> mauke: can we set a blanket quiet exception for identified people?
10:17:36 --- kick: sadfasdf was kicked by elliott (sadfasdf)
10:17:47 <byorgey> erisco: by the way, you may be interested in HW assignments #10 and #11 (and the accompanying lecture notes) here: http://www.cis.upenn.edu/~cis194/lectures.html
10:18:19 <shafire> I hate to install software :)
10:18:36 --- mode: mauke set -vv shafire sclv_
10:18:40 <byorgey> there's nothing wrong with using webchat, except that a lot of spammers are using it as well
10:18:50 <dmwit> Software written in Javascript doesn't count, presumably.
10:18:52 <yesthisisuser> how about chatzilla
10:19:11 <CaptainK> elliott:  Tourettes...just a joke about those that are spamming the channel
10:19:15 <dolio> erisco: The usual solution is to collapse that information somewhat. If a parser fails, you can get the first point at which it fails. If it succeeds, you could get the whole substring it used, but probably not the substrings that correspond to each piece.
10:19:17 --- mode: monochrom set -o monochrom
10:19:45 <dolio> You could probably build up an entire tree internally, too. It just wouldn't be interleaved with your actual data type.
10:19:53 <wavewave> hi
10:20:04 <dolio> Instead of smashing the tree flat.
10:20:27 <mauke> shafire: can you still speak?
10:20:47 <erisco> dolio, I don't know what it would mean to build the tree internally
10:21:15 <dolio> Instead of ParseResult storing a ListInput, it'd store a tree of ListInputs.
10:21:25 --- kick: paai was kicked by mauke (paai)
10:21:53 <bb010g> If I want to do all my numeric computations with 12-digit precision (nothing higher), how would I do so?
10:22:09 --- mode: elliott set +b *!*327550c5@*.50.117.80.197
10:22:09 --- kick: paai was kicked by elliott (paai)
10:22:25 <bb010g> Should I just trunicate off the extra digits, or is there a faster way?
10:22:29 <shafire> mauke: test
10:22:29 <dolio> I don't know how well that'd work with an interface like Applicative, though.
10:22:34 <mauke> preflex: seen shafire
10:22:35 <preflex>  shafire was last seen on #haskell 5 seconds ago, saying: mauke: test
10:22:37 <dmwit> bb010g: Use one of the fixed-point types on Hackage.
10:22:44 <mauke> shafire: ok, good
10:23:29 <dmwit> bb010g: e.g. http://www.haskell.org/ghc/docs/7.6.2/html/libraries/base/Data-Fixed.html
10:32:22 <erisco> well it is okay, I learned plenty anyways, so was worth the exercise
10:32:42 <augur_> elliott: who are these people (paai, etc.) you banned? i didnt see them say anything
10:33:17 <elliott> augur_: racist spammers
10:33:25 <elliott> you can only hear their lullabies if you are +o
10:33:49 <augur_> elliott: hah what
10:34:10 <elliott> (because unidentified webchat users are silenced by default to all non-ops right now due to the spamming)
10:37:11 <fryguybob> \
10:38:09 <shafire>  /j #parasail
10:38:13 <shafire> ups sry
10:38:21 <ParahSailin> ?
10:38:32 <shafire> sorry, was my fault
10:41:32 <augur_> elliott: oh right
10:46:32 --- mode: elliott set -q *!*@gateway/web/freenode/*
10:48:12 <haasn> Are you guys still being harassed by the spammers or is it another outbreak?
10:48:27 <elliott> same as before I think, but it seems to have stopped
10:48:32 --- mode: elliott set -o elliott
10:56:58 <chrisdone> elliott: oh, hold up, should be a redirect
10:58:16 <chrisdone> elliott: k, permenant redirect setup. missed that one (there are five)
10:59:22 <elliott> chrisdone: :)
11:08:06 <byorgey> oh, we have lpaste.net now? nice =)
11:12:01 * hackagebot xml-conduit 1.1.0.4 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.1.0.4 (MichaelSnoyman)
11:17:01 * hackagebot rewrite 0.4 - open file and rewrite it with new contents  http://hackage.haskell.org/package/rewrite-0.4 (OmariNorman)
11:23:16 <banister`gym> shachaf: haskell magic in ruby: http://showterm.io/7fab0cd8e50a0e2866620#fast ;)
11:24:51 <mreh> Hi guys
11:25:18 <byorgey> hi mreh
11:25:33 <mreh> I'm running a haskell script using #! /usr/bin/runhaskell
11:25:50 <mreh> can't seem to be able to run it from a different directory because ghc cant find the imports
11:26:12 <mreh> and I can't find a way to specify the directory where the imports live
11:26:28 <byorgey> mreh: -irsc
11:26:37 <mreh> I'm thinking of just running the scripts from my project directory, so all I need to so is supply the directory
11:26:38 <byorgey> oops, I mean -isrc
11:26:38 <mreh> yeah like that
11:26:44 <mreh> relative to my project dir
11:27:06 <mononochrom> testing
11:27:12 <mreh> `#! /usr/bin/runhaskell -iscripts' doesn't work though!
11:27:20 <byorgey> mreh: -isrc scripts
11:27:42 <mreh> really?
11:28:34 <byorgey> uh, now I am not so sure
11:28:52 <mreh> -isrc isn't documented in my man pages, but it does something
11:29:08 <byorgey> hmm, no, the documentation says -i
11:29:10 <mreh> "target `scripts' is not a module name or a source file"
11:29:16 <byorgey> I don't know where I came up with -isrc
11:29:50 <b2coutts> mreh: I assume "src" was being passed as an option to -i
11:29:51 <mreh> okay, suddenly it starts working
11:30:00 <b2coutts> and "scripts" was just being parsed as an argument to runhaskell
11:30:19 <Bor0> can someone briefly explain to me the identity morphism? that is, I can't understand why is g(id_A) = id_B(g) = g from the example on http://en.wikibooks.org/wiki/Haskell/Category_theory
11:31:09 <mreh> they should make an irc with barnstars, cheers guys
11:31:48 <monochrom> you mean g o id_A = id_B o g = g?
11:31:50 <mreh> I've been playing with Shelly :)
11:31:53 <byorgey> Bor0: where is this  g(id_A) = id_B(g) ?  I can't find it
11:31:58 <dncr> is hexpat alive?
11:32:08 <Bor0> monochrom, yes, isn't g o id_A simply g(id_A) ?
11:32:12 <monochrom> no
11:32:31 <byorgey> Bor0: g might not be a function.  Even if it was a function,  f . g  is not the same as  f(g)
11:32:41 <monochrom> and it is a requirement. it is not something read off from the picture.
11:32:50 <Bor0> but.. I was taught that f o g = f(g(x))
11:33:04 <b2coutts> Bor0: f(g) is different from f(g(x))
11:33:09 <mreh> (f o g) x
11:33:12 <monochrom> no, you were taught that (fog)(x) = f(g(x)). but there is no x here.
11:33:14 <byorgey> Bor0: (f . g)(x) = f(g(x)).  That is different than  f . g = f(g).
11:33:30 <mreh> he might have been taught that
11:33:37 <Bor0> I see
11:33:42 <mreh> :)
11:33:48 <LordBrain> I just tried upgrading cabal and got a linker error: /usr/bin/ld: cannot find -lz
11:33:52 <byorgey> Bor0: g . id_A = id_B . g = g   is simply *defining* what it means for id_A and id_B to be identity morphisms
11:33:58 <Bor0> monochrom, I want to understand why is that given as a requirement
11:34:09 <LordBrain> is there a library called simply 'z' ?
11:34:35 <koala_man> LordBrain: zlib, yes
11:35:11 <byorgey> Bor0: do you understand what "identity" means in other contexts? e.g. that 0 is the identity for the + operation?
11:35:23 <byorgey> because 0 + x = x + 0 = x
11:35:59 <Bor0> all I know about identity is that id(g) = g
11:36:30 <byorgey> Bor0: OK, that is the identity function
11:36:40 <LordBrain> koala_man, thanks
11:36:53 <byorgey> but even with the Haskell identity function, it's true that  id x = x, but you can also say that   id . f = f  for any other function f
11:37:36 <monochrom> I want to take several steps back. do you know why you are reading about category theory?
11:37:36 <LordBrain> aha, works now
11:37:38 <Bor0> so id o g = id(g) = g is true?
11:38:11 <dmwit> Those are two different "id" functions. -_-
11:38:15 <byorgey> uh, yes, but saying  id . g = id(g)  makes me nervous.
11:38:24 <Ralith> Is there any way to get the full expansion of a file containing template haskell into a non-template-haskell file, a la gcc -E?
11:38:30 <byorgey> because of what dmwit said.  Those two 'id's are not the same. =)
11:38:49 <dmwit> Suppose "g :: a -> b". Then the first "id" is "id :: b -> b", and the second "id" is "id :: (a -> b) -> (a -> b)".
11:38:50 <Gracenotes> id on what comes out of g, vs id on g itself.
11:38:58 <byorgey> Bor0: it sounds to me like you should spend more time playing with Haskell, learning how function composition works, etc. before tackling category theory.
11:38:59 <Bor0> monochrom, yes and no. I had this same odd feeling when I started with lambda calculus and learning it was fun. I feel the same about category theory. it's the reason I want to get more into Monads I guess
11:39:02 <LordBrain> id:: (a->b) -> a -> b
11:39:27 <Bor0> byorgey, I know function composition. I'm just confused a bit right now
11:39:37 <byorgey> Bor0: ok, that is a good reason to learn category theory (probably the best =)
11:39:57 <LordBrain> well yeah, i guess it is a little clearer with the parenthesis
11:40:28 <dmwit> I put parentheses around the type of (=<<), too. I'm a rogue.
11:40:43 <byorgey> Bor0: ok, so if you know function composition, you can see that  f . id = id . f = f ?
11:41:19 <monochrom> if you truly learn category theory for fun, then my answer to "but why impose this requirement" is the same: for fun. I am serious.
11:41:35 <b2coutts> Bor0: moreover, can you _prove_ that f . id = id . f = f?
11:41:38 <Bor0> id o f = f makes sense but I don't know how f o id = f
11:41:43 <chrisdone> being confused is the first sign you're about to learn something new!
11:41:47 <dmwit> Fun things satisfy this requirement and things that don't satisfy this requirement aren't fun. QED
11:41:52 <b2coutts> if the answer is no, you may not fully understand function composition
11:41:57 <edkk> wise words, chrisdone!
11:42:27 <byorgey> Bor0: well, work it out:  (f . id) x = f (id x) = ...
11:42:56 <byorgey> Bor0: note that  f . id = f  is really shorthand for saying  "for all x,  (f . id) x = f x
11:42:58 <augur_> byorgey: can i prove it by fiat? :)
11:43:32 <augur_> here's my proof: those equations must hold because if they didnt, then id is a stupid name for that thing!
11:43:42 <LordBrain> lol
11:43:47 <byorgey> augur_: I don't see what Italian cars have to do with anything.
11:43:53 <dmwit> ?check \f x -> (f . id) x == f x -- statistical proof
11:43:54 <lambdabot>   <hint>:1:75:
11:43:54 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
11:44:01 <augur_> byorgey: lol
11:44:02 <byorgey> augur_: well, I think that's exactly what Bor0 is trying to figure out.
11:44:06 <dmwit> err?
11:44:08 <monochrom> as for the technicality of working with f o id, f o g etc, I say that as long as you still need to include the "x" and write out "f(g(x))", you are not yet fluent with function composition, and you are not ready for category theory's composition which is abstract and generic.
11:44:16 <augur_> byorgey: ill prove it by ferrari!
11:45:21 <augur_> monochrom: including the x for this is necessary to show that the thing is, indeed, an identity in the relevant category tho, surely
11:45:40 <byorgey> ?check \f x -> (f . id) x == f x
11:45:44 <lambdabot>   mueval-core: Time limit exceeded
11:45:51 <byorgey> guess it doesn't like comments
11:46:19 <monochrom> I agree to disagree.
11:46:32 <Bor0> byorgey, ok so we have (f . id) x = f (id x) = f x = (id . f) x = id (f x). it makes a bit sense now. but why is this required?
11:46:56 <augur_> monochrom: how on earth are you going to prove its an identity without using the non-CT concepts?
11:47:21 <LordBrain> Bor0: id stands for "identity", and indeed if you consider composition as the binary operation, id is the identity for that operation.
11:47:46 <byorgey> Bor0: in Haskell, it is not required, it is simply true.  And this is the property of 'id' which gives it the name "identity"
11:48:00 <byorgey> that is, mathematicians have named things with that kind of property "identities"
11:48:23 <LordBrain> well i suppose if it didn't commute, you could call it a "left identity" or "right identity"
11:48:25 <byorgey> so in category theory we abstract from the specifics of functions to something abstract called "morphisms"
11:48:53 <monochrom> augur_: we are not on the same page. and I am on several pages simultaneously.
11:49:02 <dmwit> monochrom: I think it's reasonable for proofs about arrows in Hask to use points.
11:49:09 <byorgey> and the aspects we want to preserve are (1) there is a way to compose two morphisms together, and (2) there are special morphisms with the same properties as the identity function
11:49:20 <augur_> monochrom: how confusing!
11:49:31 <LordBrain> Bor0, another example, if multiplication is the binary operation, then 1 is the identity for that operation.
11:49:54 <augur_> dmwit: fortunately, you can use points and basically be using tacits!
11:49:57 <LordBrain> because 1*a = a*1 = a
11:50:03 <dmwit> monochrom: Okay, rereading what you actually said, I don't think you contradicted this claim.
11:50:04 * chrisdone never stops finding LordBrain's name funny
11:50:16 <Bor0> LordBrain, cool! thanks for that example
11:50:20 <augur_> dmwit: because we have nice operations on arrows that give us these things
11:50:21 <byorgey> Bor0: but as monochrom hinted earlier, it may not be productive at this point to spend much time worrying about *why* the definitions are the way they are.
11:50:22 <monochrom> suppose you say, you're learning category theory, but you only care about Hask, or only care about the category of all topologies, then sure, you always have "x", feel free to use it, and it's valuable for at least bootstrapping.
11:50:38 <byorgey> Bor0: just accept the definitions for what they are, and try playing with lots of examples
11:50:53 <byorgey> Bor0: eventually you will get a better intuitive sense of "why" these are the "right" definitions
11:51:06 <augur_> also, if you're learning category theory
11:51:08 <augur_> why not try
11:51:11 <augur_> ##categorytheory!
11:51:23 <monochrom> but if you're learning category theory in the abstract generic setting, you don't have "x", and some actual categories don't have "x" either.
11:51:53 <augur_> Bor0: there are also some nice resources for CT, for instance awodey's book and his OPLSS 2012 lecture videos
11:52:00 <Bor0> monochrom, I understand what you are saying. I don't have the "need" to always bind a variable. I've been playing with higher order functions, it's just that I got a bit lost here
11:52:51 <monochrom> hell, s/topologies/point-set topologies/. some people talk about pointless topologies, too
11:54:09 <augur_> Bor0: you shouldnt really think of . as higher order anything in the CT setting
11:54:18 <monochrom> it is thus very important to ask "what are you learning this for". motivations for every definitions and design decisions hinge on that.
11:54:22 <augur_> Bor0: just think of it as an operation on arrows that line up
11:55:07 <Bor0> monochrom, I don't know. I like mathematics in general, and haskell too. I am not learning it for money, I work with C/C++ at work. it's just fun and mysterious. what would your answer be to your question?
11:58:24 <monochrom> I first learned category theory for software organization, architecture, whatever you call it. An object is a module, either specification or implementation or a mixture of both. An arrow is refinement between two modules. pushouts, pullbacks, and generally limits and co-limits are important. adjunctions, which all of you hug so much, is unimportant. look for e.g. Doug Smith
11:59:18 <benmachine> I bet adjunctions secretly are important
11:59:19 <monochrom> a limit or co-limit (I forgot which one) equals composing a lot of modules to get a large task done
11:59:21 <benmachine> they're always important
11:59:56 <Bor0> monochrom, okay, I want to become a better programmer. and check the "different mindset" which all are talking about when learning Haskell
12:00:09 <monochrom> several years later, I saw Hask, and the category of CPOs, etc
12:01:01 <LordBrain> Bor0, by now, you can tell guess what the identity of addition is... and you pretty much get what a monoid is examples: (0,+), (1,*),(id,o) (leaving out the appropriate sets over which the operations are defined).
12:02:31 <monochrom> it seems there are many Doug Smiths. add "kestrel institute"
12:05:56 <yesthisisuser> monochrom: any books or online material?
12:07:12 <monochrom> http://www.kestrel.edu/home/people/smith/
12:07:31 <LordBrain> I think it is often the case in math that the fancy and numerous words we use sometimes mask the fact that the concept in question is more familiar than it's description.
12:07:57 <monochrom> a good place to start is "mechanizing the development of software". scroll down or text-search
12:08:51 <yesthisisuser> interesting
12:10:12 <yesthisisuser> maybe this could be the type of introduction to cat. theory that i am looking for..
12:10:50 <levi> Math gives fancy names to things in order to separate the abstract essence of a mathematical concept from its familiar usage. Usage of a concept in one area might have different properties than usage in another, so if you want to study the concept itself, it's probably best to divorce it (eventually, anyway) from its more concrete usages entirely.
12:10:53 <monochrom> hmm, if you want a newer and shorter one, "software development by refinement" looks good too.
12:11:39 <monochrom> "colimits for concurrent collectors" should be a title that excites many of you. if you further actually read it, you will be further excited that it contains a monad tutorial...
12:11:44 <LordBrain> i agree levi, it pays dividends and folds to expand your vocabulary.
12:18:55 <levi> I think concrete instances of abstract concepts are very useful for learning about the abstract concepts; that mirrors how they were discovered in the first place. I am just defending the mathematical usage of fancy names and notation by mathematicians. They're not trying to make your life hard so much as they are trying to make their lives easier. ;)
12:19:32 <tac> There's a balance to strike, for sure.
12:20:05 <tac> You can think deeper thoughters when you require fewer words.
12:21:52 <LordBrain> its much nicer than philosopohers fancy words levi, i picked up a book by wittgenstein once, and it seemed like i was reading  a technical language except that the terms were not defined anywhere.
12:23:51 <LordBrain> i got the impression there was a lot of differences with if any distinctions to go with them, only in the mind of the author...
12:24:03 <yesthisisuser> sometimes the hardest thing is to understand what there is to understand
12:24:10 <yesthisisuser> that happens if you start from the abstract
12:24:23 <codesoup> what's the predence level of `foo`
12:24:27 <codesoup> er, precedence
12:24:42 <yesthisisuser> starting from the concrete gives you something to really work with immediately
12:25:20 <yesthisisuser> then patterns start to emerge
12:27:47 <monochrom> @quote monochrom premature
12:27:48 <lambdabot> monochrom says: premature generality is the root of OOP
12:28:01 <monochrom> ah, that is not too funny :)
12:28:21 <Cale> codesoup: It depends on any fixity declarations there are for `foo`
12:28:54 <Gracenotes> "Any operator lacking a fixity declaration is assumed to be infixl 9"
12:29:30 <Luke> I'm using Control.Concurrent.forkOn to specify a CPU for my threads but they're still jumping around. I've compiled with -threaded +RTS -N with no luck
12:29:33 <codesoup> oh. i didn't even know that you can declare fixity for `foo`
12:29:43 <Luke> is there a way to keep my thread on one CPU?
12:30:19 <LordBrain> well, in some ways what your brain registers as concrete vs abstract is kind of relative.. If you think of composition as a binary operation and functions as objects in a set that this operation acts on, then that's by definition abstract as you're throwing away the additional information that functions are themselves operations, but if you don't look back, then it's just as concrete as * over the integers or something.
12:30:37 <Cale> Luke: A thread created with forkOn is supposed to stay on the one processor for its entire lifetime.
12:30:41 <Gracenotes> codesoup: er, yes, http://www.haskell.org/onlinereport/decls.html#fixity
12:30:43 <monochrom> how do you know that they are jumping? are you sure you are observing correctly and interpreting correctly?
12:30:52 <Luke> Cale: right. seems it's not though
12:31:30 <Luke> monochrom: top
12:32:12 <monochrom> the doc of forkOn also mentions "+RTS -qa"
12:32:30 <Luke> yeah that's experimental afaik
12:32:39 <Luke> I'd prefer to get forkOn working
12:33:51 <Luke> -qm looks like it might do it though
12:33:55 <Luke> "This option is probably only of use for concurrent programs that explicitly schedule threads onto CPUs with GHC.Conc.forkOnIO."
12:35:23 <Cale> Luke: What are you observing in top?
12:35:46 <Luke> basically I'm pegging a core and I can see the process swap cores a couple times
12:35:52 <Cale> Luke: It might be worth trying to use ThreadScope
12:36:31 <Luke> Cale: good idea. installing
12:37:09 <LordBrain> in other words, if we can spot what is relevant and throw away the irrelevant with reckless abandon, and do that again, then we can get ever more abstract, but not feel it, because the level of abstraction is nowhere to distract us.. maybe the trouble is we fear getting lost in the clouds and so cling to the earth a bit too fondly.
12:37:26 <Luke> just seems weird the default forkOn wouldn't work as expected
12:40:16 <Gracenotes> LordBrain: or maybe people be crazy
12:41:06 <chrisdone> they don't think it be like it is but it do
12:42:02 * hackagebot shelly 1.3.0.4 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.3.0.4 (GregWeber)
12:47:02 <chrisdotcode_> hello everyone :P
12:47:04 <chrisdotcode_> * :)
12:48:09 <chrisdotcode_> :t liftIO
12:48:10 <lambdabot> MonadIO m => IO a -> m a
13:03:29 --- topic: 'http://haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
13:03:29 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Tue Jul 09 09:38:58 2013]
13:06:22 --- mode: calvino.freenode.net set +o mauke
13:06:53 --- mode: calvino.freenode.net set +o ChanServ
13:07:09 * hackagebot git-annex 4.20130709 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-4.20130709 (JoeyHess)
13:25:09 --- mode: calvino.freenode.net set +o mauke
13:25:19 --- mode: calvino.freenode.net set +o ChanServ
13:42:20 --- mode: calvino.freenode.net set +o mauke
13:42:27 --- mode: calvino.freenode.net set +o ChanServ
13:42:31 <b52> :t (.)
13:42:32 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:42:33 <b52> see it?
13:42:36 <fuzzy_id> :t zipWith (*)
13:42:37 <lambdabot> Num c => [c] -> [c] -> [c]
13:43:12 <fuzzy_id> ok
13:43:15 <fuzzy_id> got it
13:43:18 <fuzzy_id> thanks :)
13:43:38 <pentace> :t sum .: zipWith (*)
13:43:39 <lambdabot>     Not in scope: `.:'
13:43:39 <lambdabot>     Perhaps you meant one of these:
13:43:39 <lambdabot>       `.' (imported from Data.Function),
13:44:05 <pentace> :t let (.:) = (.) . (.) in sum .: zipWith (*)
13:44:06 <lambdabot> Num c => [c] -> [c] -> c
13:44:44 <b2coutts> :t (.) . (.)
13:44:45 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:45:16 <startling> :t let (.:) = (.) . (.) in (+ 1) . (+)
13:45:17 <lambdabot> (Num (a -> a), Num a) => a -> a -> a
13:45:25 <startling> er
13:45:33 <startling> :t let (.:) = (.) . (.) in (+ 1) .: (+)
13:45:34 <lambdabot> Num c => c -> c -> c
13:46:46 <fuzzy_id> wow
13:47:51 <b2coutts> :t (.) . (($) . (:))
13:47:52 <lambdabot> a -> (a1 -> [a]) -> a1 -> [a]
13:48:38 <Gracenotes> (f .: g) x y = f (g x y)
13:48:56 <b2coutts> thinking of random strings of infix operators and trying to reason about their effect is a mind-bending exercise
13:49:31 <chrisdone> fuzzy_id: if you ever get stuck figuring out a type, you can get GHC to help you figure out what it's expecting with holes
13:49:45 <chrisdone> > sum . zipWith (*)
13:49:47 <lambdabot>   Couldn't match type `[c1] -> [c1]' with `[c0]'
13:49:47 <lambdabot>  Expected type: [c1] -> [c0]...
13:49:50 <chrisdone> you say, hmm, ok, let's see
13:49:57 <chrisdone> > sum . Hole
13:49:59 <lambdabot>   Couldn't match expected type `a0 -> [c0]' with actual type `L.Hole'
13:50:13 <startling> ((.) . (.)) f g = ((.) (f .)) g = (f .) . g
13:50:18 <chrisdone> ok, so that's what i can compose with sum
13:50:23 <chrisdone> > Hole . zipWith (+)
13:50:25 <lambdabot>   Couldn't match expected type `([c1] -> [c1]) -> c0'
13:50:25 <lambdabot>              with actua...
13:51:08 <startling> :t ((+ 1) .) . (+)
13:51:09 <lambdabot> Num c => c -> c -> c
13:51:09 <chrisdone> :t (sum .)
13:51:10 <lambdabot> Num c => (a -> [c]) -> a -> c
13:51:15 <chrisdone> D:
13:52:35 <startling> ((.) . (.)) f g a b = ((.) (f .)) g a b = ((f .) . g) a b = (f . g a) b = f (g a b)
13:56:08 <Gracenotes> on that note, pure applicative style can hinder your fellow humans sometimes.
13:56:52 <Gracenotes> (except for those of us very fluent in the SK combinator calculus)
13:57:07 <startling> :t (pure <*>) -- pure applicative style
13:57:08 <lambdabot> (a1 -> a) -> a1 -> a1
13:57:31 <Gracenotes> s/pure/entirely/, if you will :)
14:02:17 <mstksg> wh can't i define lift2 = lift . lift
14:02:24 <mstksg> compiler complains about monad instances
14:02:43 <mstksg> can i make this happen while keeping things point-free?
14:04:06 <shachaf> chrisdone: peek?
14:04:19 <Eduard_Munteanu> mstksg: if lift is defined for a particular monad stack, it doesn't mean lift . lift is.
14:04:55 <Eduard_Munteanu> mstksg: the former part of that sentence is provided by MonadTrans instances, but there's no such thing for the latter
14:05:06 <shachaf> ion: Did you figure out the secret of Nu?
14:05:53 <shachaf> ion: In this case, the value of type "Nu Maybe" which has no "Mu Maybe" equivalent.
14:06:38 <fuzzy_id> :t foldl
14:06:39 <lambdabot> (a -> b -> a) -> a -> [b] -> a
14:07:28 <Eduard_Munteanu> Actually, wait, disregard my statements, I didn't think it through.
14:07:59 <mstksg> Eduard so I'd have to define it for each monad stack?
14:08:06 <mstksg> i was hoping currying could take care of everyything
14:08:30 <Eduard_Munteanu> :t lift . lift
14:08:31 <lambdabot> (Monad (t1 m), Monad m, MonadTrans t, MonadTrans t1) => m a -> t (t1 m) a
14:08:51 <Eduard_Munteanu> mstksg: there you go... ^
14:09:26 <mstksg> oh that works, thanks :)
14:09:33 <mstksg> i guess i just had to specify the explicit type
14:10:35 <Gracenotes> "The Secret of Nu: The Terminal Morphism", the highly anticipated novel from James Patterson-matching
14:11:29 <Gracenotes> "The perfect marriage of crime, sex, and category theory"
14:12:00 <Gracenotes> "On the New York Times best-seller list for a coinfinite number of weeks"
14:12:57 <Eduard_Munteanu> mstksg: well, yes, lift . lift is ambiguous
14:13:24 <Eduard_Munteanu> Is there a symbolic CAS using Haskell as a DSL?
14:13:45 <jfischoff> best-seller stream
14:14:03 <mcstar> docon is based on haskell
14:14:08 <CaptainK> You can buy your way to the New York best sellers list : http://tinyurl.com/b8yavdh
14:14:22 <mcstar> but that probably wont do the mentioned problem
14:14:56 <elliott> CaptainK: #haskell-blah, perhaps?
14:16:44 <CaptainK> elliott: yep that worked thanks
14:17:07 <fuzzy_id> ok, next problem:
14:17:33 <fuzzy_id> i have to find all Pythagorean triples
14:17:34 <fuzzy_id> pyths n = [ (x,y,z) | z <- [1..n], x <- [1..z], y <- [1..z], z**2 == x**2 + y**2 ]
14:17:34 <fuzzy_id>  
14:17:44 <fuzzy_id> does the job, but
14:17:46 <fuzzy_id> :t pyths
14:17:47 <lambdabot> Not in scope: `pyths'
14:17:53 <fuzzy_id> damn it
14:18:04 <benmachine> fuzzy_id: maybe you want ^ instead of **
14:18:09 <elliott> fuzzy_id: btw, best to paste (see topic for URL) for stuff more than a couple of lines
14:18:26 <fuzzy_id> it should be of type Int -> [(Int, Int, Int)]
14:18:37 <startling> :t (**)
14:18:38 <lambdabot> Floating a => a -> a -> a
14:18:42 <startling> :t (^)
14:18:43 <lambdabot> (Integral b, Num a) => a -> b -> a
14:18:51 <fuzzy_id> ok, that was easy
14:18:53 <fuzzy_id> :)
14:19:40 <benmachine> fuzzy_id: I think Integer is better than Int
14:19:57 <CADD> indeed, no silet overflows
14:20:00 <CADD> silent*
14:20:08 <fuzzy_id> ok
14:20:23 <benmachine> fuzzy_id: but that's a sidenote; back to your original problem, there are actually three different ways of raising a thing to a power
14:20:39 <benmachine> fuzzy_id: this is because if you've got x^y then what y can be depends on what x is
14:20:51 <benmachine> if x is something you can just multiply, then y has to be a positive whole number
14:20:59 <benmachine> if x is something you can divide as well, y can be negative
14:21:14 <fuzzy_id> ok, that makes sense
14:21:15 <benmachine> if x is something that supports the full exponential function, y can be any real number
14:21:27 <benmachine> this corresponds to (^) and (^^) and (**)
14:21:33 <fuzzy_id> :t (^^)
14:21:34 <lambdabot> (Fractional a, Integral b) => a -> b -> a
14:21:48 <fuzzy_id> :t (^)
14:21:49 <lambdabot> (Integral b, Num a) => a -> b -> a
14:21:55 <fuzzy_id> :t (**)
14:21:56 <lambdabot> Floating a => a -> a -> a
14:22:37 <fuzzy_id> :)
14:23:00 <fuzzy_id> thanks, benmachine
14:23:21 <benmachine> np
14:28:49 <ion> shachaf: I wasn‚Äôt even looking. Nu () Just?
14:29:46 <shachaf> That works. Or Nu () (const (Just ())) or lots of other values.
14:30:05 <shachaf> Nu can represent infinity without recursion.
14:30:09 <shachaf> Well, Nu Maybe.
14:30:36 <shachaf> Other Nu types can represent other infinite (co)data.
14:31:02 <Gracenotes> untying the knot? >.>
14:32:48 <ion> shachaf: Interesting.
14:32:57 <ion> Nu () ('x',)
14:33:06 <shachaf> Right.
14:33:08 * hackagebot shelly 1.3.0.6 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.3.0.6 (GregWeber)
14:33:19 <shachaf> Note that Mu (Char,) is uninhabited, without using recursion etc.
14:34:22 <shachaf> Mu (Maybe . ([a],)) is (finite) lists of a. Nu of the same thing is potentially-infinite (co)lists of a.
14:34:48 <shachaf> By which I just mean of ListF a, where data ListF a b = Nil | Cons a b
14:35:12 <shachaf> In Haskell, of course, you can cheate with recursion to make an infinite Mu value.
14:37:31 <shachaf> ion: Hmm, you should do muNu etc. without without recursion wherever possible.
14:37:56 <ion> shachaf: Ok, will do.
14:38:13 <shachaf> Which is in half the cases, I think.
14:46:02 <Peaker> shachaf, why "Mu" and not "Fix"?
14:46:56 <josephle> Peaker, presumably for historical reasons?
14:46:59 <joelteon> is hlint going to support lambda-case at some point in the near future
14:47:26 <josephle> Mu *is* the standard symbol for the recursive type
14:49:17 <RichyB> ‚Ä¶how do you make a cow recurse? ¬µ.
14:49:21 * RichyB hides.
14:51:51 <Ralith> haha
14:53:20 <startling> there once was a curate from kew / who kept his pet cat in his pew / he taught it to speak / alphabetical greek / but all it responded was "¬µ"
14:53:44 * josephle breaks out into applause
14:54:01 <monochrom> "nu" or "niu" rhymes with the Chinese pronounciation for cow/ox. therefore...
14:54:22 <monochrom> how do you make a Chinese cow recurse? nu
14:55:26 <monochrom> also, see my http://article.gmane.org/gmane.comp.lang.haskell.cafe/91920/
14:56:13 <startling> RichyB: unfortunately it's mew, not moo
14:56:52 * monochrom changes nick to moochrom
14:56:59 <mcstar> they are greek cows, they say mu
14:57:05 <Gracenotes> Peaker: newtype Fix f = Fix (f (Fix f))
14:57:17 <josephle> instead of lambdacats, we should've had lambdacows
14:57:26 <Peaker> Gracenotes, I know.. "Mu" is an awful name IMO
14:57:39 <Gracenotes> fixpoint type recursion by using recursive types >.>
14:57:45 <elliott> shachaf is not talking about Gracenotes's type.
14:57:48 <elliott> he's talking about the actual Mu.
14:57:50 <elliott> as opposed to Nu.
14:57:53 <Peaker> oh
14:57:55 <startling> Gracenotes, how do you make a hipster's bike recurse?
14:58:18 <ion> shachaf: Better? https://gist.github.com/ion1/5957723
14:58:20 <Peaker> so Nu=Fix?
14:58:31 <Peaker> And Mu=?
14:58:39 <elliott> look at ion's gist
14:58:41 <elliott> for the definitions
15:00:49 <Gracenotes> ion: interesting use of currying vs infix constructors vs lambdas
15:01:05 <Gracenotes> they're all the same anyway :o
15:02:35 <monochrom> https://www.dropbox.com/s/4sferqlnqmfhg7g/nu.txt
15:03:56 <radim_> i need better toolkit
15:03:58 <acowley> josephle: I guess I'll point out‚Ä¶ https://www.youtube.com/user/LambdaCow
15:05:32 <shachaf> Peaker: ?
15:05:43 <shachaf> Peaker: Mu, Nu, Fix are all types here.
15:06:28 <shachaf> ion: Looks good (if it type-checks).
15:06:52 <shachaf> ion: If you use runMu instead of pattern-matching they look more obviously "dual" to each other. :-)
15:07:49 <Peaker> shachaf, ignore that, I thought they were just silly aliases
15:08:49 <shachaf> Peaker: "Mu" is usually the name for the least fixed point, and "Nu" for the greatest fixed point.
15:09:25 <shachaf> In Haskell they're all the same, so people call "Fix" "Mu" (maybe by analogy to the value-level fix, which *is* the least fixed point).
15:12:00 <Gracenotes> if Haskell were totally equirecursive they would be even more obviously dual.
15:12:08 <Gracenotes> also everything would be confusing everywhere
15:12:28 <eikke> Gracenotes: that'd be a change? :P
15:12:38 <Peaker> if Haskell were equirecursive I'm speculating it'd probably not survive long enough to make those obviously dual :)
15:13:21 <eikke> we'd have to build an LHC to observe it
15:13:29 <eikke> *grin grin*
15:24:38 <Peaker> Would be really nice to have fine-granularity rebuilds... such that a change in a single definition in a module doesn't rebuild *everything* that depends on that module, but only the definitions that somehow depend on that definition
15:25:04 <Peaker> speed up incremental development of large projects
15:29:00 <ion> shachaf: https://gist.github.com/ion1/5957723#file-fixmunu-hs-L15
15:30:09 <ion> Œª> muSucc muTwo
15:30:11 <ion> fixMu (Fix (Just (Fix (Just (Fix (Just (Fix Nothing)))))))
15:33:20 <alpounet> Peaker, maybe that wouldn't be too hard to handle
15:33:36 <alpounet> i mean it most likely wouldn't be that big a patch
15:33:54 <Peaker> alpounet, patching GHC takes more work than I currently contribute :(
15:34:15 <Gracenotes> you would have to make a new version of the interface file compatible with the old
15:34:29 <Gracenotes> or maybe the current version might already potentially support this
15:34:46 <elliott> could just patch the interface files, maybe?
15:38:40 <shachaf> ion: "evil" might be making a Show instance for Fix that just shows (Just (Just (Just Nothing)))
15:45:44 <wole> @hoogle isSpace
15:45:45 <lambdabot> Data.Char isSpace :: Char -> Bool
15:48:01 <ion> canScream = not . isSpace
16:01:47 <covi> What does "Strict version of" mean in haskell? Context: func, func'.
16:02:06 <Rembane> Non-lazy
16:03:03 <tac> covi: Things in Haskell often come in pairs: lazy is usually the default, and strict versions are there when you need extra performance
16:03:33 <jmcarthur> or, well, strict semantics
16:04:19 <shachaf> let's just strictify everything. turn the performance knob up to 11
16:04:29 <shachaf> jmcarthur: Well, you never really "need" strict semantics.
16:04:33 <tac> That'll teach those lazy lists a lesson.
16:05:04 <troydm> the moar lazier haskell's code is the more slower it runs
16:05:23 <troydm> so you need to do some deepseq sometimes
16:08:13 <Cale> uh, I disagree?
16:08:20 <jfischoff> > length [undefined, undefined]
16:08:21 <lambdabot>   2
16:08:22 <jmcarthur> shachaf: you're right, although you still sometimes care for non-performance reasons sometimes (sometimes you need it just to prevent a stack overflow, for example, although that's still more related to the implementation than to actual semantics)
16:08:28 <jfischoff> > et length' [] = 0; length' (x:xs) = 1 + seq x (length' xs) in length' [undefined, undefined]
16:08:29 <lambdabot>   <hint>:1:15: parse error on input `='
16:08:32 <jmcarthur> troydm: i have never once needed deepseq
16:08:33 <Cale> Sometimes evaluating things needlessly is the cause of bad performance
16:08:34 * shachaf suspects troydm was joking.
16:08:40 <jfischoff> |:
16:08:53 <shachaf> (But it's an unhelpful joke when someone asks a real question about the topic.)
16:08:55 <jfischoff> > let length' [] = 0; length' (x:xs) = 1 + seq x (length' xs) in length' [undefined, undefined]
16:08:56 <lambdabot>   *Exception: Prelude.undefined
16:09:10 <jfischoff> yeah strictness in its full glory
16:09:40 <shachaf> jmcarthur: Maybe you can say that strictness is for when you don't need non-strict semantics. :-)
16:09:49 <shachaf> (Though that's not really accurate either.)
16:16:58 <jfischoff> I would like to turn a cabal package (specifically Cabal HEAD) into a debian package for comsumption by my coworkers. For various reasons the few auto-cabal-to-debian tools are not working.
16:17:24 <jfischoff> is there an easy example of debian package that just builds and installs a library?
16:27:22 <CaptainK> > filter ("alala" `isInfixOf`) ["adala - a first name","domra - a early Russian balalaika","lehel - a first name","ahsha - a first name","alala - a war cry of the ancient Greeks"]
16:27:22 <lambdabot>   ["domra - a early Russian balalaika","alala - a war cry of the ancient Gree...
16:27:42 <Cale> wololo
16:28:01 <CaptainK> How can I get just the "alala" and not the match to "bALALAika"
16:28:54 <Peaker> CaptainK, you mean isPrefixOf rather than isInfixOf?
16:29:15 <sipa> filter ("alala " `isPrefixOf`) ["adala - a first name","domra - a early Russian balalaika","lehel - a first  name","ahsha - a first name","alala - a war cry of the ancient Greeks"]
16:29:20 <sipa> > filter ("alala " `isPrefixOf`) ["adala - a first name","domra - a early Russian balalaika","lehel - a first  name","ahsha - a first name","alala - a war cry of the ancient Greeks"]
16:29:20 <lambdabot>   ["alala - a war cry of the ancient Greeks"]
16:29:28 <CaptainK> yep
16:29:40 <sipa> also note the space after the query string :)
16:29:44 <Cale> > filter (elem "alala" . words) ["adala - a first name","domra - a early Russian balalaika","lehel - a first  name","ahsha - a first name","alala - a war cry of the ancient Greeks"]
16:29:45 <lambdabot>   ["alala - a war cry of the ancient Greeks"]
16:29:54 <sipa> ^ even better
16:29:58 <CaptainK> need to read up on that function....its a hard one to remeber
16:30:13 <sipa> isPrefixOf ?
16:30:20 <CaptainK> is filter part of Prelude?
16:30:27 <sipa> yes
16:31:00 <CaptainK> then I like that better for sure...the less imports for me = beauty
16:37:33 <Peaker> ugliness in imports has no material consequences.. ugliness in code causes bugs and comprehension difficulties
16:37:39 <ezrios> Can anyone recommend a good text on Haskell after completing the Gentle Intro?
16:37:51 <Peaker> ezrios, You read the Gentle Intro?
16:38:13 <ezrios> Peaker: I am a little over halfway through, still a ways to go
16:38:15 <ezrios> just planning ahead
16:38:16 <Peaker> @quote gentle
16:38:16 <lambdabot> vixen says: If you see this, gentle sir, know that you are being trolled by a poorly configured VixenLove program
16:38:19 <Peaker> @quote gentle
16:38:19 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
16:38:29 <shachaf> It's not *that* bad.
16:38:37 <ezrios> It's really not
16:38:46 <Peaker> I remember being frustrated with it when I wanted to learn Haskell
16:38:48 <ezrios> monads are still a mindfuck
16:39:02 <Peaker> And then preferring "Yet Another Haskell Tutorial" but these days "LYAH" is recommended
16:39:27 <Peaker> ezrios, did you find Functors easier?
16:39:41 <ezrios> I actually tried to read the original Haskell Report - that made me appreciate the Intro much better
16:39:53 <ezrios> Functors are not bad
16:40:34 <DanielDiaz> if I want to do some web animations in Haskell... what's the way to go?
16:41:00 <DanielDiaz> any recommended library?
16:42:14 <DanielDiaz> ezrios: the gentle introduction was the first thing I read too
16:43:01 <ezrios> DanielDiaz: it's quite good really, though maybe a bit sparse
16:43:26 <ezrios> which is why I'm looking for a good text to supplement my studies
16:43:39 <shachaf> ezrios: Hutton's _Programming in Haskell_ is a good introduction.
16:43:59 <Cale> ezrios: On monads specifically, have you read my tutorials?
16:44:20 <shachaf> Books that are often recommended in here are _Learn You a Haskell_ (also an introduction) and _Real World Haskell_.
16:44:33 <ezrios> Cale: mayhaps, though your name is not ringing a bell :<
16:44:35 <jfischoff> Cale: you have tutorials?
16:44:35 <Cale> er, is haskellwiki down?
16:44:37 <startling> the gentle introduction is written like a math textbook I think.
16:44:40 <jfischoff> ah
16:44:56 <startling> "here's some stuff, here's some provocative hints towards how they can be used, okay next thing"
16:44:59 <shachaf> Cale: Not for me.
16:45:07 <Cale> Monads as Computation / Monads as Containers / Introduction to IO
16:45:11 <CaptainK> Peaker: kiss principle, if you can do it without an import,  thanks for the help!
16:45:28 <ezrios> startling: Right, which is why I was looking for something maybe more thorough to expand on it
16:45:55 <ezrios> shachaf: I actually just found out about that, flipping through it right now
16:46:05 <CaptainK> sipa: nice an simple...works great!
16:46:07 <Peaker> DanielDiaz, I recommend graphics-drawingcombinators
16:46:16 <Peaker> DanielDiaz, with GLFW-b
16:46:26 <ezrios> Cale: and nope, the wiki is up for me
16:46:34 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
16:46:41 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Containers
16:46:42 <ezrios> Cale: already found it :>
16:46:43 <Peaker> DanielDiaz, it's very easy to use, and pretty easy to get decent performance/smooth animation
16:46:52 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
16:47:08 <DanielDiaz> Peaker: thank you. I am looking to it.
16:47:11 * jfischoff wonders if understanding free monads is the key to monadic enlightment
16:47:12 <Peaker> ezrios, are you trying to learn about the monad *generalization* or about how to do IO/do blocks?
16:47:30 <ezrios> Peaker: the generalization, really
16:47:46 <startling> jfischoff: nah
16:47:53 <Peaker> ezrios, ah, then I recommend first learning the Functor generalization, then Applicative, then Monad
16:47:57 <Cale> It's easiest to understand the generalisation by seeing lots of examples
16:47:57 <startling> jfischoff: those are just the ones you get for free
16:48:09 <startling> jfischoff: I can write up a simple example if you'd like
16:48:13 <Peaker> ezrios, do you know these?
16:48:17 <ezrios> Peaker: that is more or less the same progression I took
16:48:18 <Cale> In particular, I recommend at least understanding lists, IO, and parsers
16:48:25 <jfischoff> startling: of?
16:48:48 <Peaker> ezrios, ah, so you understand what Functors give you, what Applicatives add on top of that, and now want to understand what Monads add on top of that?
16:49:07 <Cale> Maybe skip Applicative
16:49:15 <Cale> (until after Monad)
16:49:23 <Cale> But certainly Functor is important
16:49:32 <shachaf> Functor is the best type class.
16:49:38 <startling> jfischoff: well, take a look at return 12 :: Free [] Int
16:49:57 <startling> oh, maybe I misread the context
16:50:01 <ezrios> Peaker: That's right, though I am maybe still a bit shaky on Applicatives
16:50:23 <Peaker> ezrios, You can follow Cale's suggestion and do Functor,Monad,Applicative last
16:50:49 <Peaker> ezrios, do you understand kinds? i.e: if f is a Functor, what its kind is?
16:51:59 <wole> @hoogle (MonadPlus m) => Bool -> a -> m a
16:51:59 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
16:52:00 <lambdabot> Control.Exception assert :: Bool -> a -> a
16:52:00 <lambdabot> Control.OldException assert :: Bool -> a -> a
16:52:16 <ezrios> Peaker: Can't say I am comfortable with kinds
16:52:23 <wole> @hoogle (Monad m) => Bool -> a -> m a
16:52:23 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
16:52:23 <lambdabot> Control.Exception assert :: Bool -> a -> a
16:52:23 <lambdabot> Control.OldException assert :: Bool -> a -> a
16:52:54 <DanielDiaz> Peaker: I don't see how graphics-drawingcombinators makes /web/ animations. All it seems to do is drawing using OpenGL.
16:52:55 <Peaker> ezrios, ah, IMO it's worth figuring out before diving into Monads.
16:53:04 <Peaker> DanielDiaz, oh, you said web? Sorry! I didn't see that
16:53:17 <jfischoff> ezrios: I agree with Peaker
16:53:37 <ezrios> I guess I will start there then, thanks
16:53:49 <Peaker> ezrios, Note:  class Eq e where (==) :: e -> e -> Bool        "e" is the instance of Eq. "e" is used as the type of values.  Types that have values are of kind "*", so e :: *
16:54:16 <Peaker> ezrios, class Functor f where fmap :: (a -> b) -> f a -> f b        note that "f a" is used as the type of values, as well as "a".  so   a :: *,  f a :: *     that means:   f :: * -> *
16:54:17 <jfischoff> ezrios: use :k in ghci to find out the kind of things. See if you can guess the pattern
16:54:59 <Peaker> ezrios, since "f a" is simple type constructor application, it means f is   ? -> ?    it's being given "a" which is *, so it's   * -> ?    and its result is being used as a type of values, so it's * -> *..  followed that?
16:55:06 <blackdog> somebody must have already made a lambdacat for this one, right? http://cdn.pbh2.com/wordpress/wp-content/uploads/2012/05/funniest-cat-gifs-cat-bully.gif
16:55:29 <Pip> Why are so many people in this channel?
16:55:55 <Peaker> ezrios, for example,  Maybe :: * -> *    is an instance of Functor.   Maybe Int :: *   is of the wrong kind, so "Maybe Int" cannot be an instance of Functor
16:55:55 <blackdog> Pip: haskell is pretty great :)
16:56:09 <Pip> Oh, yeah?
16:56:38 <DanielDiaz> Peaker: it's ok. Looks like a backend for gloss has been done (https://github.com/cdsmith/gloss-web) but maybe a what would be awesome is something that writes de JavaScript code needed to run the animation.
16:57:25 <DanielDiaz> Peaker: sorry, I messed the last sentence a little bit.
16:58:01 <DanielDiaz> Peaker: too many type/erase cycles.
16:58:28 <Peaker> DanielDiaz, I try to stay the hell away from web as much as I can...
16:58:46 <DanielDiaz> Peaker: any particular reason?
16:59:19 <Peaker> DanielDiaz, general terribleness :)
16:59:33 <Peaker> though with GHCJS and a few more advances in some web abstractions, it may become sane, I hope :)
16:59:39 <DanielDiaz> Peaker: I wonder if we could have this conversation without web.
16:59:48 <Peaker> DanielDiaz, on IRC?
17:00:56 <ezrios> Peaker: AH
17:01:03 <ezrios> I think I understand
17:01:09 <ezrios> sorry took me a while to think that over :P
17:01:33 <Peaker> ezrios, it's fine, I think internalizing things is supposed to take time
17:01:49 <Peaker> ezrios, so all Functor instances are "type constructors" of kind *->*
17:01:58 <ezrios> Right
17:02:15 <Peaker> ezrios, similarly, all Monads are also type constructors of kind *->*.   i.e: Maybe can be an instance of Monad, but "Maybe Int" cannot
17:02:49 <Peaker> ezrios, and in the "methods" (definitions inside the class) of the Monad type-class, you'll see "m a" or "m b" used as the type of values, but not "m"
17:02:53 <josephle> I remember being shown kinds in haskell that were not * or (k -> k). What language pragmas give you more kinds?
17:03:10 <Peaker> @src Monad
17:03:10 <lambdabot> class  Monad m  where
17:03:10 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
17:03:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
17:03:10 <lambdabot>     return      :: a -> m a
17:03:10 <lambdabot>     fail        :: String -> m a
17:03:16 <FreeFull> josephle: Something like * -> Nat -> * maybe?
17:03:25 <Peaker> ezrios, ignore (>>) and fail
17:03:37 <josephle> FreeFull: yeah
17:03:47 <Peaker> ezrios, and you can imagine that it is:  class Functor m => Monad m where ...
17:03:49 <jfischoff> josephle: DataKinds
17:03:57 <Peaker> ezrios, (all instances of Monad are also supposed to be instances of Functor)
17:04:06 <ezrios> still with you :P
17:04:11 <josephle> jfischoff: I also remember lists of types, is that also in DataKinds?
17:04:35 <Peaker> ezrios, "return" is easy/simple.   (a -> m a).  For example:   return :: a -> Maybe a ; return = Just          or:   return :: a -> [a] ; return x = [x]
17:05:03 <jfischoff> josephle: you get list syntax with DataKinds
17:05:14 <ezrios> right, I get return
17:05:25 <ezrios> you're just shoving something "into" the Monad
17:05:34 <josephle> jfischoff: thanks!
17:05:42 <pentace> What are the types of kind Nat?
17:05:42 <jfischoff> np
17:05:56 <elliott> pentace: 0, 1, 2, 3, ...
17:06:27 <pentace> And what are values of that types? ;)
17:06:29 <Cale> ezrios: From the perspective that monadic values are computations, return v is an action which does nothing, except to produce the result v.
17:06:44 <Peaker> ezrios, (>>=) :: m a -> (a -> m b) -> m b        can be viewed as involving 3 input entities, and 1 output:    1) left "m a" is the first action.   2) (a -> ...) is the function that can look at the output of the first action  3) m b (result of the function)    and the output is: 4) m b.       the general idea is that the output "m b" is chaining together all 3.  i.e: it "executes" 1, feeds its result to 2. and then "executes" 3.
17:06:45 <Cale> pentace: They have no values.
17:07:05 <pentace> Oh
17:07:33 <byorgey> pentace: it's a good question!  In fact, only types of kind * have values
17:07:48 <Peaker> ezrios, 1 and 3 are "actions" wrapped in "m" so can have effects.    2 is a pure computation.   So in effect, (>>=) lets us interleave monadic actions and pure computations (even if we didn't also have fmap)
17:07:52 <josephle> pentance: I can only imagine the types of Nat are z :: Nat and s :: Nat -> Nat :P
17:08:22 <Peaker> ezrios, also, note that 2 and 3 are both dependent on the result value of 1,  so we can decide what next effect (3) to use based on the result of (1)
17:08:27 <elliott> I don't think you can even say (foo :: 3)
17:08:31 <jfischoff> josephie: That is what people usually do
17:08:45 <elliott> so it's more like the question of whether 3 has values doesn't typecheck :)
17:08:51 <elliott> er, the question of what values 3 has
17:08:53 <josephle> jfischoff: well it is the natural thing to do
17:08:55 <Cale> x >>= f is the same thing as  do v <- x; w <- f v; return w  -- you first run the action x, getting some result v, and then run f v, getting some result w which is the result of the combined action.
17:08:56 * josephle hides
17:09:09 * jfischoff groans
17:09:21 <Cale> Or, more directly, it's the same as  do v <- x; f v
17:10:16 <josephle> now to figure out what I can do with such a ridiculously powerful kind system
17:11:10 <josephle> just to make sure, haskell doesn't have singleton kinds yet, right?
17:11:15 <ezrios> hm :/
17:11:21 <jfischoff> you can make them
17:11:26 <ezrios> I am still not sure that I get this ._.
17:11:27 <jfischoff> they're not built in
17:11:53 <jfischoff> The singleton library is very cool I think
17:12:04 <josephle> jfischoff: so it's possible to embed Fomega into haskell?
17:12:19 <FreeFull> You can implement fmap in terms of >>=
17:12:41 <FreeFull> Well, >>= and return
17:12:55 <pentace> josephle: Singleton kinds do only have a single type?
17:13:11 <Peaker> ezrios, http://lpaste.net/90767
17:13:18 <FreeFull> fmap f a = a >>= return . f
17:13:28 <josephle> pentace: well a single type upto equivalence
17:13:52 <jfischoff> josephle: byorgey can probably answer that, but I can't
17:14:07 <ezrios> I'm still unsure what you mean by "effects" or "actions"
17:14:23 <ezrios> are monads just some means of encapsulating state or something
17:14:30 <FreeFull> ezrios: Anything of type   m a   is an action
17:14:33 <byorgey> pentace: singleton types have only a single value
17:14:39 <wole> @hoogle iif
17:14:39 <lambdabot> Language.Haskell.TH.Syntax MultiIfE :: [(Guard, Exp)] -> Exp
17:14:39 <lambdabot> Language.Haskell.TH MultiIfE :: [(Guard, Exp)] -> Exp
17:14:39 <lambdabot> Language.Haskell.TH.Lib multiIfE :: [Q (Guard, Exp)] -> ExpQ
17:14:42 <Peaker> ezrios, ah, a value of type "m a" can be viewed as having some "effect" described by the "m" part. And a result (described by "a" part).  A value of type "m a" can be described as an "action"
17:14:54 <byorgey> pentace: they provide a link between the type and value levels, because if you have a certain value you know exactly what the type is, and vice versa
17:15:01 <Peaker> ezrios, Lets look at 2 examples:  IO and Maybe
17:15:12 <FreeFull> ezrios: If you look at something like the list monad, it doesn't really "encapsulate state"
17:15:30 <Peaker> ezrios, if m=IO, then "m a" is "IO a".   values of type "IO a" can be described as "IO actions"
17:15:40 <pentace> byorgey: Yes, and it's the same with singleton kinds?
17:15:52 <Peaker> ezrios, a value of type "IO a" describes an effectful program that should eventually yield an "a"
17:15:53 <FreeFull> > [1,2,3] >>= \a -> [2,3,4] >>= \b -> return (a,b)
17:15:54 <lambdabot>   [(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(3,2),(3,3),(3,4)]
17:16:14 <josephle> actually I think it's also the case with singleton kinds
17:16:20 <Peaker> ezrios, the "effect" of IO can be a whole range of things (printing, launching missiles, destructive writes, etc).
17:17:00 <Peaker> ezrios, if m=Maybe, we get a much simpler type.    a value of type "Maybe a" can be seen as having a potential effect of "failure".  a failure effect truncates/stops the computation
17:17:49 <josephle> if t1 == t2, and t1 :: sing(t1), then is t2 :: sing(t1) (where sing is singleton kind promotion)?
17:18:12 <Peaker> ezrios, so the effect of Maybe is failure/truncation.  Monad lets us have both:   Maybe a -> (a -> Maybe b) -> Maybe b  (if either of the input Maybes are Nothing, everything is Nothing, failures propagate),   and:   IO a -> (a -> IO b) -> IO b       (perform side effects of first IO a, then pure function, then effects of IO b)
17:19:01 <Peaker> ezrios, so every type that is an instance of the Monad type-class can be viewed as implementing some kind of "effect" - and the small Monad type-class can be seen as a common way to glue together "effectful computations" together, no matter what effect type is being used
17:19:39 <josephle> pentace: none the less, it should be true that if t1 == t2, then sing(t1) == sing(t2), since we can talk about type and kind equivalences
17:19:42 <ezrios> Peaker: hm, starting to make sense
17:19:55 <ezrios> I think I should pick up some exercises on monads or something :S
17:20:33 <FreeFull> ezrios: All the magic behind a monad rests inside of >>=
17:20:48 <FreeFull> Once you understand >>= for a particular monad, you understand that monad
17:20:58 <josephle> pentace: and with subkinding, then we have that all singleton kinds are inhabited by a single type upto type equivalence
17:21:00 <ezrios> >>= is very magical indeed, I am still trying to pry apart your example
17:21:05 <Peaker> ezrios, http://lpaste.net/90767 -- not sure if helpful, it was helpful for me once
17:21:26 <josephle> okay, that strained my memory of the kind calculus
17:22:14 <pentace> josephle: I don't know subtyping but I think I get the idea
17:22:19 <FreeFull> ezrios: For lists, >>= is implemented using concatMap
17:22:45 <Peaker> *is* concatMap (flipped)
17:22:46 <pentace> pentace: Or rather subkinding
17:23:07 <ezrios> @hoogle concatMap
17:23:07 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
17:23:08 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
17:23:08 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
17:23:29 <ezrios> that is hardly a surprise ._.
17:23:42 <ezrios> maybe I should look up the actual page
17:28:04 <Peaker> ezrios, this is just half the story, by the way.  A very important part of monads are the 3 laws.  the first 2 laws basically say that "return" shouldn't have any "effect". That is:   return x >>= someFunc      should be the same as just giving "x" to someFunc directly (=== someFunc x). i.e: chaining the effects of "return" with the effects of something else is the same as just using the effects of something else
17:28:35 <Peaker> second law says that   someAction >>= return   ===    someAction  ("return" again has no effect)
17:31:03 <FreeFull> Note that all monads are functors and applicatives too, so will obey functor and applicative laws too
17:51:52 <mebaran151> I have a quick question why one thing passes the type checker while the other doesn't: http://pastebin.com/1XF9uFXw
17:51:56 <mauke> The paste 1XF9uFXw has been copied to http://lpaste.net/90768
17:52:18 <mebaran151> I would think the err would simply match everything that the first equation doesn't but maybe I'm missing something
17:54:46 <mebaran151> basically, why can't the instance declaration typecheck with a default case?
17:56:32 <roboguy_> mebaran151: the first thing I see is that the wildcard is for the function argument, not the other one
17:56:49 <roboguy_> oh wait, I see what you're saying
17:58:18 <roboguy_> the type doesn't change
17:58:34 <roboguy_> the function changes the type and if you don't apply it, it doesn't change and so it doesn't fit the type signature
17:59:10 <roboguy_> actually then the other one wouldn't work either, never mind
17:59:23 <mebaran151> roboguy_: the other one works
17:59:28 <mebaran151> the one market as working works
18:00:59 <dwcook> I think roboguy_ is onto something. The type of err is fixed, but if you deconstruct then reconstruct a value using the list of [b], you get something of another type. Just a guess.
18:01:28 <roboguy_> hmm
18:01:36 <dwcook> err :: ObjectCreation b a but needs to be :: ObjectCreation b c
18:01:45 <dwcook> where f :: a -> c
18:03:46 <roboguy_> that sort of makes sense. it also doesn't work if you use "fmap _ i@(Invalid _) = i" etc
18:03:47 <mebaran151> it feels like a waste to deconstruct and reconstruct the object
18:04:12 <mebaran151> also covering every case is wordy: I had to do the same dance for monad and applicative too
18:04:39 <mebaran151> (basically ObjectCreation is a tagged Either with two Lefts and one Right)
18:05:16 <roboguy_> mebaran151: what if you used an Either with a new error type in the Left?
18:05:52 <mebaran151> roboguy_: the code I have works just fine (and I made the datatype to keep from having to constantly deconstruct Either in my code)
18:06:04 <mebaran151> I'm just wondering why the typechecker is so finicky (this is more for my own edification)
18:06:25 <ezrios> >>= is left associative?
18:07:19 <mebaran151> infixl 1 according to ghci (checkout :i (>>=))
18:07:29 <mebaran151> in ghci, the :i command is super useful
18:07:32 <tabemann> it shouldn't matter if it is, as long as a monad follows the monad laws, whereby (x >>= f) >>= g == x >>= (f >>=g)
18:07:43 <ezrios> mebaran151: I was hoping there was such a command, thanks
18:08:12 <ezrios> tabemann: right, I forgot about that, thanks >.<
18:09:32 <mebaran151> I think something about the undeconstructed object makes ghc think that it could be possible be a Valid, even if I already caught that case
18:09:39 <roboguy_> tabemann: that's for >=> isn't it? >>= is similar though
18:10:04 <Cale> roboguy_: yes
18:10:05 <mebaran151> :i (>=>)
18:10:20 <mebaran151> whoops wrong buffer sorry all
18:10:43 <tabemann> whoops
18:11:04 <tabemann> I meant x >>= (\y -> f y >== g)
18:11:18 <tabemann> s/>==/>>=
18:11:57 <asgardBSD> I have some trouble
18:12:13 <asgardBSD> i tried to do : let test = '+' 3
18:12:21 <asgardBSD> to make a function that add + 3
18:12:28 <asgardBSD> but it dont work
18:12:28 <tabemann> you mean (+) not '+'
18:12:41 <asgardBSD> so let test = (+) 3
18:13:04 <asgardBSD> thanks
18:14:32 <asgardBSD> Currently in a philosphy class, the perfect time to play with haskell!
18:15:13 <ActiveAspect> does anyone have an interesting way to refactor this? let traze a = trace `uncurry` (show &&& id) a
18:15:23 <asgardBSD> im in it right now
18:15:34 <asgardBSD> the teacher is saying some booring thing
18:15:49 <ActiveAspect> the goal is to compose in line with other functions using (.)
18:17:00 <dwcook> @pl traze a = trace `uncurry` (show &&& id) a
18:17:00 <lambdabot> traze = (trace `uncurry`) . (show &&& id)
18:17:33 <ActiveAspect> lambdabot: thx
18:18:55 <dwcook> @hug
18:18:55 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:19:00 <dwcook> Heh
18:23:37 <acowley> Anyone know when the upcoming hmatrix-base split will hit hackage?
18:27:37 <ezrios> I don't understandd
18:27:42 <ezrios> is liftM not the same as fmap?
18:27:48 <elliott> yes
18:27:56 <elliott> but Functor isn't a superclass of Monad yet due to historical reasons.
18:28:05 <elliott> so you can't use fmap generically over every Monad, but you can liftM.
18:28:15 <ezrios> ah, I see. Thanks
18:28:30 <dolio> I'm not sure there are reasons. Just history.
18:28:33 <dolio> :)
18:29:08 <ezrios> dolio: what is this, Perl?
18:29:17 <acowley> raisins, of the genus hystericamus
18:30:26 <bscarlet> Is there a way to expand template haskell before building a cabal package, so that the package will build in an environment which doesn't support TemplateHaskell?
18:31:42 <acowley> bscarlet: ping thoughtpolice
18:42:52 <benmachine> bscarlet: no, because template haskell can run arbitrary IO, whose effects may depend on the environment
18:44:17 <geekosaur> there is a preprocessor, I think?
18:44:37 <geekosaur> not 100% the same if it runs arbitrary I/O, but that's kinda discouraged I think
18:45:36 <bscarlet> benmachine: That sounds like an issue of which the package author should be aware, but not a reason no-one should ever do it.
18:46:57 <benmachine> bscarlet: hmm. well, I think my answer is not "that's impossible" but "that doesn't exist, and isn't trivial"
18:48:22 <benmachine> bscarlet: I would kind of expect that it can depend on build-time system configuration in other ways too, but I suppose often it doesn't
18:49:22 <bscarlet> benmachine: thanks
18:49:42 <benmachine> bscarlet: where "that doesn't exist" of course only means "I haven't heard of it"
18:50:04 <benmachine> bscarlet: you could just -ddump-splices and copy and paste them in :P
18:50:15 <bscarlet> benmachine: :P indeed.
18:50:43 <bscarlet> benmachine: The thing is, I think I have this idea rattling around in my head because I have heard of it.
18:50:56 <bscarlet> I'm just not sure where.
18:51:04 <benmachine> ah
18:51:17 <benmachine> in that case I've given you virtually no useful information whatsoever :P
18:51:20 <benmachine> sorry
18:52:02 <bscarlet> Not true. You pointed out issues I might have with the hypothetical tool, which are quite worth thinking about.
18:53:58 <external-reality> I need to do this (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
18:54:01 <dmwit> ?hackage zeroth
18:54:01 <lambdabot> http://hackage.haskell.org/package/zeroth
18:54:14 <dmwit> bscarlet:
18:54:28 <dmwit> ?src (>=>)
18:54:29 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:54:51 <bscarlet> dmwit:
18:55:13 <external-reality> yet I have this: m' (a -> m b)  m' (b -> m c)
18:55:17 <dmwit> bscarlet: Do you not find zeroth helpful?
18:55:19 <bscarlet> ahha!
18:55:21 <geekosaur> ah, that
18:55:22 <geekosaur> yes
18:55:41 <external-reality> How do I do that
18:55:48 <geekosaur> although it occurred to me while looking for that, that I don;t know if it was ever extended to do quasiquoters
18:55:57 <dmwit> :t liftM2 (>=>)
18:55:58 <lambdabot> (Monad m, Monad m1) => m (a -> m1 b) -> m (b -> m1 c) -> m (a -> m1 c)
18:56:24 <external-reality> cool cool
18:56:28 <dmwit> external-reality: But you might want to check if one or the other monad has a transformer version before you go too deep in that rabbit hole.
18:56:28 <geekosaur> right, not updated since 2009
18:56:46 <thoughtpolice> bscarlet: hello. i looked at backlog. i'm think acowley told you to ping me because i do GHC stuff. :P as for your question, there's not an easy way to expand template haskell so it can run somewhere without it i'm afraid
18:57:38 <thoughtpolice> :(
18:57:59 <shachaf> wow, thoughtpolice, no need to be so hostile
18:58:10 <external-reality> dmwit: explain
18:58:14 <elliott> there's non-easy ways though!
18:58:51 <dmwit> external-reality: Have you played with monad transformers?
18:59:02 <dmwit> They're the mildly-more-convenient version of just nesting monads inside each other.
18:59:14 <dmwit> There's plenty of good material on the web.
18:59:22 <dmwit> ...for learning about them.
18:59:34 <external-reality> I know what a transformer is. I still don't know what you mean?
18:59:35 <thoughtpolice> shachaf: clearly i'm doing something wrong
19:00:10 <anon123> I have several functions that take lists of [a] (of fixed runtime length 3), and I want to convert them to take tuples of (a,a,a).  Is there a standard/systematic way to allow the functions to be polymorphic in both argument types (so I can switch back if needed)?
19:00:54 <bscarlet> thoughtpolice: Thanks. dmwit pointed me at zeroth, but I don't think it will work out in my case.
19:00:55 <external-reality> dmwit: It seemed to me that you had a better solution than liftM2 yet it involves transformers.
19:01:20 <external-reality> dmwit: I did not understand that bit.
19:01:23 <dmwit> external-reality: There is probably a transformed monad in which the operation you want is just (>=>).
19:01:59 <anon123> I could define a type data AS a = List [a] | Tuple (a,a,a) and pattern match, but surely there is a simpler way
19:02:36 <b2coutts> anon123: afaik this is one of those things that isn't convenient in haskell because there isn't a good reason to do it
19:03:10 <external-reality> dmwit: I have m ( a -> Maybe b) and m ( b -> Maybe c)
19:03:23 <anon123> b2coutts: my reason is: I'm playing around with performance optimizations and I'd like to switch representations easily
19:03:25 <b2coutts> if you need to encapsulate three things into a single value, a tuple is the correct way to do that
19:03:35 <benmachine> anon123: no, you can't define a function that takes both a list and a tuple and does something sensible
19:03:53 <benmachine> define the function to take three arguments, then pattern match when you want to pass a list
19:03:54 <dmwit> Classes are the way to define a function that takes both a list and a tuple and does something sensible.
19:04:14 <anon123> dmwit: I was thinking of defining some kind of typeclass
19:04:15 <benmachine> dmwit: depends on your criteria for sensible, I suppose
19:04:17 <b2coutts> anon123: you have to think about what the function is supposed to do, and define it. The :: contract is your way of describing your function (i.e. a function that takes a list of integers to an integer)
19:04:27 <benmachine> TakesThreeArguments is a terrible typeclass
19:04:40 <dmwit> I strongly doubt that changing the calling convention is going to significantly impact your performance.
19:04:49 <dmwit> Please profile your code first.
19:05:01 <b2coutts> the contract "takes zero or more of a, or 3 of a, to a" sounds silly, because it is silly
19:05:04 <anon123> I have. 62.4% allocation using lists
19:05:18 <dmwit> external-reality: Then perhaps you will like MaybeT.
19:06:08 <benmachine> anon123: switching to a fixed-length structure may well improve that
19:06:17 <b2coutts> if you want to play around testing the performance of tuples vs. lists, perhaps you should write two separate functions
19:06:34 <dmwit> If you're hoping to switch back to an old version of some code, perhaps version control is the right tool to use.
19:07:08 <b2coutts> as you're essentially defining two entirely different types of functions, and the sensible way to do that is to create two separate functions, rather than trying to glue them together
19:07:20 <anon123> benmachine: yes, I tried it elsewhere (by hardcoding the types) and using -O3 ghc completely eliminated all allocation.  Nice!
19:07:43 <benmachine> I thought -O only went up to -O2
19:07:51 <benmachine> and even that was not always the right thing
19:07:54 <tgeeky> benmachine: I was just about to ask him to try again with -O2.
19:07:58 <anon123> well it didn't complain
19:08:10 <tgeeky> I don't think there's anything that happens with O3 that doesn't happen with O2
19:08:15 <anon123> okay
19:08:42 <b2coutts> O3 optimizes 1.5x more things
19:08:47 <b2coutts> it's simple math
19:09:48 <monochrom> there is no -O3
19:10:45 <benmachine> I want -On
19:10:58 <benmachine> and -Onlogn
19:11:03 <monochrom> yeah!
19:11:39 <monochrom> -fno-warn-p/=np
19:11:45 <ChongLi> how about -O(1)
19:11:56 <ChongLi> compile my program to always run in constant time :)
19:13:04 <b2coutts> ChongLi: in fact, GHC already does this by default
19:13:17 <b2coutts> the running time just may not be constant with respect to the variable you want
19:13:30 <ChongLi> yeah
19:13:42 <ChongLi> just optimize away all the work and return 0
19:14:16 <monochrom> -O(1) ==> main = putStrLn "yes! haskell can do that"
19:17:22 <xunie-laptop> Is it wrong of me to see curried functions as functions that are called at a later time when passed it has gotten all of it's arguments?
19:17:38 <ChongLi> that's partially applied functions
19:17:52 <xunie-laptop> Sorry, excuse me.
19:18:04 <ChongLi> that's ok :)
19:18:30 <xunie-laptop> Everytime I hear/read "curried"? I think of Indian curries.
19:18:40 <ChongLi> haha
19:19:11 <b2coutts> xunie-laptop: all functions, partially applied or otherwise, are called at a later time. It might not be useful to think of functions as "waiting" to get the rest of their arguments, though
19:19:24 <xunie-laptop> Well, I figured.
19:19:33 <xunie-laptop> I know haskell is lazy.
19:19:40 <ChongLi> curried functions are those which take one argument and return a function
19:19:56 <xunie-laptop> I just read up on that! Beat you to it
19:20:10 <ChongLi> that function may in turn take another argument and return another function!
19:20:14 <b2coutts> but even ignoring laziness, you can think of the function as just creating the new function "immediately"
19:20:21 <b2coutts> :t (+) 3
19:20:22 <lambdabot> Num a => a -> a
19:21:01 <b2coutts> the above is not the (+) function waiting for more arguments, the above is an entirely new function that has nothing to do with the (+) function, which adds 3 to its argument
19:21:12 <ChongLi> you can think of an uncurried function as one which takes a tuple of arguments and returns something
19:21:35 <ChongLi> :t uncurry (+)
19:21:36 <lambdabot> Num c => (c, c) -> c
19:21:52 <ChongLi> in many other languages, functions are uncurried by default
19:22:13 <ChongLi> hence calls which look like this: foo(bar,baz);
19:23:59 <ChongLi> > let foo = uncurry (+) in foo(4,5)
19:24:00 <lambdabot>   9
19:24:14 <ChongLi> as you can see, Haskell lets you do both :)
19:29:24 <dmj> since epoll is only available on linux machines (not Darwin) does the ghc runtime use something else instead for OSX?
19:29:37 <shachaf> Yes.
19:32:50 <AsgardBSD> does Haskell currently use GCC or LVM as backend?
19:33:20 <dmwit> You can ask for -fllvm.
19:33:34 <dmwit> If you don't, you get GHC's native codegen.
19:33:40 <dmwit> GCC hasn't been used in a long time.
19:33:52 <shachaf> GHC uses GCC as a backend for compiling C.
19:33:54 <shachaf> Also as a frontend.
19:35:04 <AsgardBSD> so if it can target GCC, it could be possible to modify Glasgow to work with gcc-avr and use haskell for AVR micro controller
19:36:59 <AsgardBSD> But then we would need a special Haskell dialect that would allow us to modify register directly and embeded Assembly inside it (in the impure main function, as IO type)
19:37:17 <bscarlet> asgardBSD: I imagine porting the runtime would be an interesting exercise.
19:38:37 <AsgardBSD> that would be awesome, it would make Haskell explore new horizon, embeded and low level programming in a new way
19:38:52 <AsgardBSD> altought, some already accomplished some low level programming (like house)
19:39:05 <AsgardBSD> house, the operating system
19:40:01 <AsgardBSD> But well, haskell already work with arm
19:40:11 <AsgardBSD> We would just need AVR and MIPS
19:41:36 <bscarlet> asgardBSD: probably want to stick with 32-bit AVR though. 8-bit might be a bit too much fun.
19:42:00 <AsgardBSD> well, i was targetting 8 bit
19:42:12 <AsgardBSD> haskell running on 8 bit would be awesomme
19:46:47 <bscarlet> asgardBSD: A related, more practical project would be using Haskell to implement a compiler or EDSL which targetted AVR.
19:47:36 <roboguy_> it looks like someone got haskell to run on an AVR platform already
19:47:44 <bscarlet> :-)
19:48:42 <roboguy_> using a EDSL called atom: http://leepike.wordpress.com/2010/05/31/twinkle-twinkle-little-haskell/
19:49:07 <arkeet> roboguy_: ajhc?
19:49:39 <bscarlet> roboguy_: That's an instance of my suggested related project, not haskell running on an AVR.
19:50:19 <arkeet> by haskell I hope you mean haskell code compiled to target avr, not a haskell compiler running on avr. :-)
19:51:16 <roboguy_> haha, yeah that's what I mean
19:51:58 <roboguy_> bscarlet: but it does look like he's running it on an AVR based system
19:54:03 <dmj> @unmtl ReaderT Int (Rand StdGen) String
19:54:03 <lambdabot> Int -> (Rand StdGen) String
19:54:07 <dmj> gnarly
19:54:11 <bscarlet> roboguy_: He's running Haskell on a host system to generate C which he compiles on the host to get AVR machine code, then sends the AVR machine code to the AVR, where it runs.
19:54:35 <roboguy_> bscarlet: well, that's what I meant
19:55:22 <bscarlet> roboguy_: That's quite different from haskell code compiled to target AVR.
19:57:06 <roboguy_> bscarlet: the end result is still that he's writing haskell code and running the resulting program on an AVR though
19:59:35 <zRecursive> where is active channel talking about Low Level programming such as C, assembly, etc?
19:59:38 <roboguy_> I guess it is different. is there a compiler that targets avr?
19:59:53 <bscarlet> roboguy_: Well. he's writing his ESDL, which happens to be in Haskell. It's not like he can, e.g. import Parsec and suddenly parse on the microcontroller.
20:00:10 <roboguy_> bscarlet: yeah, that's true
20:00:16 <monochrom> C has ##c. not sure about other low level programming
20:00:24 <arkeet> ##programming can probably direct you somewhere.
20:00:50 <zRecursive> haskell is too abstractive to do low level programming ?
20:00:51 <arkeet> apparently ##assembly exists.
20:01:19 <zRecursive> seems not active as haskell :)
20:01:20 <arkeet> but it only has 1 user.
20:01:23 <arkeet> =)
20:01:28 <monochrom> I guess freenode has a channel for everything. except really profitable occupations like lawyer, doctor, accountant...
20:01:55 <AsgardBSD> ruby and python got thei channel
20:01:56 <bscarlet> expensivenode?
20:01:57 <AsgardBSD> aslo scala
20:02:03 <AsgardBSD> oops
20:02:13 <AsgardBSD> didnt saw you where talking about low level programming
20:02:20 <arkeet> AsgardBSD: those are official channels.
20:02:38 <arkeet> I don't think it's possible to have an "official C|asm channel"
20:12:25 <jozefg> Hello
20:13:51 <jozefg> Does anyone know if language.cil is dead?
20:14:16 <jozefg> it's incomplete and seems unmaintained
20:16:26 <Gracenotes> cil? there's a Haskell version?
20:16:43 <Gracenotes> oh, I thought it was like OCaml's CIL
20:17:44 <jozefg> Gracenotes:  CIL ~ Common Intermediate Language I'm looking for the codegen library.. I was hoping for something like Harpy but it seems like it doth not exist
20:17:46 <Gracenotes> the maintainer might know if it's dead or not
20:17:55 <jozefg> Emailed, no response in a week
20:18:11 <jozefg> Figured I'd ask here before I just write my own :)
20:18:35 <monochrom> you could update it
20:19:09 <jozefg> Is it "nice" to do so? I'm not sure when I can't get ahold of author
20:19:15 <Gracenotes> yeah, if you'd want to extend the library in a way that seems logical from its current state, i.e. not break things, you could take over maintainership.
20:19:56 <Gracenotes> and it doesn't seem like it has any (public) reverse dependencies
20:21:49 <jozefg> Nope it doesn't.. I think adding a monad instance + maybe some additionally typesafety should do it..
20:22:35 <Gracenotes> of course, follow the semantic versioning rules anyway
20:22:55 <Gracenotes> http://semver.org/
20:23:15 <elliott> you should follow the PVP if you want to follow a set of versioning rules.
20:23:17 <elliott> for haskell.
20:23:33 <jozefg> elliott: PVP?
20:23:39 <Gracenotes> er, yes. it's a subset of the broader concept tho
20:23:49 <elliott> jozefg: package versioning policy
20:23:55 <elliott> @google package versioning policy haskellwiki
20:23:56 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
20:23:56 <lambdabot> Title: Package versioning policy - HaskellWiki
20:24:29 <jozefg> Ah cool. thanks
20:26:22 <AsgardBSD> I found out some thing in LYAH hard to understand
20:26:34 <jozefg> AsgardBSD: What's that?
20:26:42 <AsgardBSD> For me, http://www.haskell.org/tutorial/ explain thing better
20:28:28 <monochrom> that's good. I like that tutorial.
20:28:48 <monochrom> it was the tutorial I used. at that time, there was no other tutorial anyway.
20:29:04 <jozefg> I prefered RWH personally
20:29:18 <AsgardBSD> maybe LYAH try to oversimplify thing too much, and we are left with many question with no awnser
20:29:58 <tgeeky> LYAH is written in a style designed to mock LYAR (ruby)
20:30:05 <AsgardBSD> LYAH = explain less, more example, or when it explain, it try to explain it too much oversimplified, and then we dont really understand
20:30:18 <tgeeky> and it's not trying to oversimplify, it's trying to entice you into using haskell more after you're done with LYAH
20:30:40 * tabemann just read both LYAH and RWH, and felt they both didn't give a good model of /how Haskell works/
20:31:05 <tgeeky> just as in, over the past week or two?
20:31:11 <jozefg> tabemann: How haskell works?
20:31:16 <jozefg> How do you mean
20:31:19 <tabemann> no, a few months ago
20:31:23 <monochrom> you are not in a bind to be mutually exclusive. ideally you should be using 3 tutorials/books in parallel. I'm serious.
20:31:24 <tabemann> runtime model
20:31:35 <tabemann> I'm reading about how STG works, and it is much more enlightening in that regard
20:31:37 <tgeeky> monochrom: hehe, I think it's reasonable advice
20:31:46 <AsgardBSD> part of LYAH that are +- well explained are return statement in IO and how to make data type
20:31:52 <AsgardBSD> http://www.haskell.org/tutorial/ explain that better
20:31:54 <tgeeky> tabemann: but that's exactly the part of haskell that's too complicated and not really related to the language design iteslf
20:31:58 <jozefg> Well... yes. The runtime model isn't something you should really care about when you're first learning Haskell though
20:32:00 <copumpkin> tabemann: I think Haskell and its implementation are fairly unrelated
20:32:06 <copumpkin> tabemann: you can learn haskell on paper, basically
20:32:12 <jozefg> The point is that it's reasonably opaque to the user
20:32:14 <copumpkin> STG is one way to implement it
20:32:23 <tgeeky> copumpkin: in sort of the same way that haskell and GHC are unrelated, no?
20:32:33 <copumpkin> haskell is an abstract language
20:32:38 <monochrom> it is derived from an advice to lost calculus students: use 3 calculus books at the same time.
20:32:39 <tgeeky> yeah, exactly
20:32:49 <tgeeky> it has a pie-in-the-sky but precise specification, and the implementation details are left to others
20:33:08 <tabemann> I'm concerned about how Haskell code will behave in space and time, and since I'm using GHC I'm concerned particularly about how it behaves when compiled with it'
20:33:09 <shachaf> copumpkin: You can learn Haskell on paper but I think it's more fun with a computer.
20:33:13 <copumpkin> sure :)
20:33:16 <tgeeky> either way, I don't want to know about this stuff when I sit down with a language.
20:34:03 <copumpkin> tabemann: my basic point is that you don't need to learn about that stuff to "get" haskell. Your interests take you beyond the introductory material and that's good, but I don't think they're wrong for omitting it
20:34:19 <tabemann> LYAH and RWH taught me enough about Haskell the language itself, but little about how the language behaves as implemented
20:34:21 <Gracenotes> Maybe more focus could be given to the idea of GHC having a stack of case statement continuations, to do evaluation.
20:34:29 <AsgardBSD> LYAR?
20:34:33 <AsgardBSD> I cant find that on the web
20:34:39 <arkeet> that's because it's LYAH.
20:34:51 <shachaf> @lyarr
20:34:51 <lambdabot> Get out o' me way, yeh landlubber
20:34:57 <arkeet> @where lyah
20:34:57 <lambdabot> http://www.learnyouahaskell.com/
20:35:01 <AsgardBSD> [23:29:37] <tgeeky> LYAH is written in a style designed to mock LYAR (ruby)
20:35:04 <arkeet> oh.
20:35:10 <Gracenotes> But then you run into the ##c problem: people who refuse to talk about any implementations, but have encyclopedic knowledge of the spec
20:35:11 <tgeeky> i got it partially wrong
20:35:25 <tabemann> Gracenotes: I frankly didn't know that all boxed values are implemented as closures in GHC until I read about STG
20:35:53 <tgeeky> LYAH was written in the style of some Ruby tutorial
20:35:53 <shachaf> It depends on what you mean by "closure"...
20:35:58 <tabemann> (maybe that's changed since the time of the paper, of course)
20:35:58 <Gracenotes> well... again, it is a 20 year old paper... GHC produces frighteningly good assembly in some cases.
20:36:09 * copumpkin trembles
20:36:21 <shachaf> GHC is different in many important ways from what the STG paper says, yes.
20:36:44 <shachaf> Some good papers to get a general idea:
20:36:48 <shachaf> @where eval-apply
20:36:49 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/index.htm
20:36:51 <tabemann> I presume a lot of that is due to lots of strictness analysis
20:36:55 <shachaf> @where ptr-tag
20:36:55 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
20:36:56 <shachaf> @where cpr
20:36:57 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
20:37:00 <tabemann> I've got more papers to read; I saved all of the ones you listed before
20:37:05 <shachaf> Ah, OK.
20:37:27 <tgeeky> now I'm confused and don't know what the progenitor for LYAH was.
20:38:00 <AsgardBSD> the bad thing about Real world haskell is its publication date
20:38:22 <AsgardBSD> 2008
20:38:30 <AsgardBSD> the language surely evolved since
20:38:45 <tabemann> it annoyed me that RWH was written *before* the big changes in the exception system
20:38:46 <AsgardBSD> but most of the thing surely didnt changed
20:38:58 <jmcarthur> tgeeky: you might be thinking of _why the lucky stiff, but iirc, BONUS wasn't intentionally basing LYAH on _why's style anyway
20:39:03 <monochrom> it seems that "learn you a ___ for great good" was a meme at that time. maybe ruby, maybe something else.
20:39:17 <tgeeky> jmcarthur: yes, I was thinking of that guy.
20:39:18 <tabemann> I wondered where the title of LYAH came from
20:39:31 <monochrom> there is, even, "learn you some erlang for great good"
20:39:32 <tgeeky> jmcarthur: I thought it was, but perhaps not. I never read that _why thing.
20:39:38 <arkeet> monochrom: which one is older?
20:39:39 <elliott> monochrom: that book is based on LYAH
20:39:43 <jmcarthur> monochrom: i think the erlang one came later
20:39:49 <monochrom> ah oops
20:39:55 <jmcarthur> i am not aware of any "learn you a _ for great good" before the haskell one
20:39:56 <tgeeky> yep, all of the "learn you a " books I found are after too
20:40:15 <shachaf> Just imagine trying to learn C from a 30-year-old book! Hopeless.
20:40:49 <monochrom> someone erased the history on google. must be the dept of truth.
20:41:05 <jozefg> Simon marlows book should be coming out soon :D I'm looking forward to that
20:41:06 <tabemann> but you can learn it from the ANSI C edition
20:41:23 <tgeeky> monochrom: it just occured to me: 1) this kind of thing (when a phrase was first used) should be the kind of thing google will easily tell you; but, 2) i have no idea how to find it
20:41:28 <monochrom> luckily, when I learned C, I learned it from a merely 20-year old book, not 30-year old :)
20:41:44 <shachaf> Oh, Aug 1. That's soon.
20:41:53 <monochrom> also, I got Kernighan's autograph!
20:41:59 <tgeeky> shachaf: that's like, tomorrow on the appropriate planet!
20:42:04 * tabemann has actually worked on compilers recently that *only* implemented pure ANSI C, no extensions at all
20:42:48 <Gracenotes> jozefg: it seems exciting. I wonder if it'll get dated in the same way RWH has been (inevitable for some cool fast-moving technologies)
20:42:50 <mapreduce> What's wrong with learning C from an old book?
20:42:52 <tgeeky> anyway, the gist of this conversation is that most of us believe that LYAH is indeed a good book, and is appropriate for the level of difficulty.
20:43:08 <tgeeky> and that the person who disagrees with us is plainly wrong and should be taken out back and shot.
20:43:09 <tabemann> mapreduce: the 30-year old book isn the original K&R book, and a *lot* has changed since then
20:43:23 <tabemann> the 20-year old book is the ANSI C edition of the K&R book, which is perfectly good to learn from
20:43:44 <mapreduce> More must have changed than I realised then.
20:43:45 <thoughtpolice> shachaf: where do you see Aug 1 for Simon's book?
20:43:55 <Gracenotes> on the amazons, for me.
20:44:00 <AsgardBSD> C dont change a lot
20:44:06 <shachaf> thoughtpolice: http://www.amazon.com/dp/1449335942
20:44:24 <AsgardBSD> C11 will be the biggest change since ainsi C
20:44:33 <AsgardBSD> Its why we can use 20 year old book to learn it
20:44:43 <Gracenotes> hm. I followed a link on Amazon and it told me "Acc√®s impossible ou refus√©."
20:44:45 <Gracenotes> that's not very nice
20:45:00 <tgeeky> Gracenotes: worked for me
20:45:02 <jozefg> Gracenotes:  undoubtedly, does it talk about cloud haskell even?
20:45:04 <arkeet> ainsi lol
20:45:13 * tabemann for some reason hopes they don't mess with ANSI C too much...
20:45:29 <Gracenotes> jozefg: it seems to hint at it in the description
20:45:41 <AsgardBSD> Gracenotes: in french?
20:46:44 <Gracenotes> To be more clear, linked from the author bio
20:46:55 <AsgardBSD> tabemann: tabemann for some reason hopes they don't mess with ANSI C too much...
20:47:01 <AsgardBSD> mess with AINSI C? Where?
20:47:46 <jozefg> For some reason I really like C..
20:48:20 <jozefg> It's kinda like lisp in that timeless way
20:48:21 <Gracenotes> something something stockholm syndrome etc.
20:48:50 <tabemann> C is nice if you want assembly but don't want to be tied to an instruction set (especially since today we have to deal with x86, amd64, and ARM as our main architectures in use for non-microcontroller systems)
20:49:06 <Gracenotes> nah, it's a very good language if you're really concerned with memory management, or want to be better friends with the hardware.
20:49:34 <Gracenotes> for some values of 'really concerned'
20:49:45 <tabemann> e.g. working on microcontroller systems
20:49:49 <AsgardBSD> i want to be better friend with hardware
20:49:59 <AsgardBSD> i work with micro controller
20:50:12 <jozefg> Gracenotes: I find that 90% of "Really concerned" leads to horrible and more inefficient code tbh..
20:50:44 <tabemann> typically with microcontroller systems static allocation and the stack are all you have, with even malloc() being forbidden, and with your stack being small
20:50:48 <Gracenotes> well, not often inefficient...
20:50:59 <tabemann> most "modern" languages violate that restriction
20:51:32 <jozefg> Gracenotes: For people writing terrible code, yes.
20:51:39 <AsgardBSD> [23:49:51] <jozefg> Gracenotes: I find that 90% of "Really concerned" leads to horrible and more inefficient code tbh.. -> Microsoft's Windows
20:52:24 <jozefg> Example: http://stackoverflow.com/questions/4708105/performance-of-qsort-vs-stdsort
20:52:35 <tabemann> there's little reason to write most general purpose code on general purpose systems in C except for tight inner loops
20:52:35 <AsgardBSD> 10% (yeah, less people use linux) -> Linux and other great open source project
20:53:28 <tabemann> the gains of having to manually manage your memory on such systems are outweighed by the costs
20:53:50 <tabemann> as for Linux itself, it's a kernel, so it doesn't count - of course it has to be in C or a similar language
20:53:53 <Gracenotes> It's true; in some languages, you have to contort yourself into very improbable shapes in order to avoid shooting yourself in the foot.
20:54:27 <jozefg> I'd like to implement some form of dependent & linear types on top of C... that'd be interesting
20:55:17 <tabemann> jozefg: isn't that kind of what the language ATS is?
20:55:28 <arkeet> I don't think manual memory management is the biggest cost of writing in C.
20:55:33 <jozefg> No idea.. Never looked tabemann
20:55:51 <jozefg> I'd more do it for a learning experience
20:55:57 <tabemann> ATS seems like an attempt to make a language that has the power of C but is tied to a theorem-proving, advanced type system
20:56:09 <monochrom> but do take a look for ideas and precautions
20:56:11 <arkeet> does ATS stand for "advanced type system"?
20:56:25 <tabemann> http://en.wikipedia.org/wiki/ATS_%28programming_language%29
20:56:45 <monochrom> www.ats-lang.org
20:56:46 <arkeet> ATS type system
20:56:50 <tabemann> Applied type System
20:57:31 <arkeet> someone needs to make a recursive acronym scheme that has a unique fixed point.
20:57:32 <AsgardBSD> good night
20:58:11 <tgeeky> arkeet: I came up with one, but it starts with 4 letters :o
20:58:22 <arkeet> that's fine
20:58:23 <arkeet> let's hear it
20:58:33 <arkeet> possibly in -blah
20:58:38 <shachaf> arkeet: Dilbert had "The TTP Project"
20:58:38 <tgeeky> can't banned there.
20:58:54 <arkeet> shachaf: that works I suppose
20:59:30 <monochrom> well, I have "automatic ATM teller machine" too...
21:00:51 <tabemann> that'd work if it were "automatic AATM teller machine"
21:00:58 <dolio> I don't really see how ATS is C-like, except that you can just put inline C in it, which won't have the ATS features applied to it.
21:01:18 <dolio> The rest is like a fancy Haskell or ML.
21:01:25 <jozefg> Are there any other nice low-ish level languages with nice type systems?
21:01:52 <Gracenotes> not surprisingly, ATS does pretty well in proglang shootout
21:02:01 <tabemann> dolio: from reading over it it seemed to have lower level access to memory representations and like
21:02:06 <jozefg> Yea it's certainly fast
21:02:13 <monochrom> typed assembly language: http://www.cs.cornell.edu/talc/
21:02:24 <tgeeky> arkeet: let's make sure we're taking about the same thing. I wrote docs and examples for a package called 'macronym' which is a portemeau of macro and acronym. The idea was simple enough:
21:03:15 <monochrom> (to get lower-level than that, you have to ask for "typed microcode" or something :) )
21:03:17 <tgeeky> use replacement-regex style rules to translate an acronym (elide the punctuation) like CERN or LHC or GHC into a (possibly recusrive) fill name
21:03:35 <dolio> According to the wiki page, it doesn't sound like it has memory representation features that GHC doesn't, really.
21:03:44 * tabemann wonders just *how* you would type wide microcode
21:04:14 <tgeeky> the cute example I came up with (I invented a dozen alterate examples for some of these) is RIVE, which is an english word that means to tear asunder
21:04:33 <tgeeky> where it's meaning could just be R RIVE
21:04:37 <tgeeky> to provide an additional r
21:04:52 <tabemann> dolio: tis true, since GHC has all its FFI calls, which basically allow you the power of C (with a garbage collector) if you want
21:05:04 <jozefg> monochrom:  typed binary?
21:05:04 <tgeeky> that's recursive, and a fixed point of some dictionary
21:05:07 <arkeet> I still don't understand how it works.
21:05:17 <arkeet> or rather, how it's an acrony.
21:05:17 <arkeet> m
21:05:57 <monochrom> I don't understand the question. but typed assembly language refers to source code.
21:06:23 <tgeeky> arkeet: I just thought in terms of examples. LHC: LHC; s/L/ Large /; s/H/ Hadron /; s/C/ Collider /
21:07:03 <tgeeky> arkeet: CERN is harder, becuase you have to reorder the acronym to get to the name.
21:07:07 <jozefg> Joke
21:07:15 <tgeeky> arkeet: I suppose you didn't say anything about associations with their meaning :o
21:07:24 <arkeet> I didn't.
21:07:40 <arkeet> although it should expand to something meaningful.
21:07:52 <tgeeky> arkeet: or contract
21:08:01 <arkeet> and it should be an acronym.
21:08:21 <tabemann> monochrom: the closest thing I can think of to a typed machine language is various bytecodes for virtual machines which include typing in them
21:09:16 <tgeeky> the next most complicated example was: CERN -> Center for European Nuclear Research
21:09:27 <tgeeky> which has an extra (lowercase) word, and a reordering.
21:10:14 <arkeet> CERN never expanded to anything with "center" in it.
21:10:18 <shachaf> Hmm, I don't think being banned in #-blah is a good reason to be off-topic in #haskell. :-)
21:10:29 <arkeet> I wonder how you get banned in -blah but not here.
21:10:33 <arkeet> maybe for being too off topic in there.
21:11:14 <tgeeky> arkeet: no, it was personal
21:11:25 <arkeet> k
21:11:37 <shachaf> That, too, is not a good topic for #haskell.
21:11:42 <dolio> Wow, I forgot what the ATS on the shootout looks like.
21:11:55 <dolio> It actually looks like it doesn't use much inline C anymore.
21:12:16 <tgeeky> shachaf: The warning is appreciated, but unnecessary.
21:12:45 <dolio> It just kind of looks like the ATS in it is more verbose C.
21:14:28 <Gracenotes> most C seems to just be parallelizing everything
21:14:32 <Gracenotes> even on single core
21:14:38 <Gracenotes> in the shootout
21:15:13 <shachaf> dolio: Is it also with about as much type safety as C?
21:15:33 <dolio> shachaf: I can't tell by looking at it.
21:15:53 <dolio> I don't know much about ATS.
21:16:49 <dolio> It does extern in a function called "cast" at one point (I was looking at fasta).
21:16:58 <dolio> Not sure if that's a good sign.
21:18:12 <jtbandes> why does this type of thing work? http://lpaste.net/7142566995915964416 it seems like this would require multi-parameter type classes.
21:19:50 <mstksg> is there a standard library function for last $ replicateM ?
21:20:08 <roboguy_> jtbandes: that type class has one parameter
21:20:23 <jtbandes> roboguy_: what is "e" in the class definition?
21:20:33 <tabemann> any type
21:20:42 <tabemann> it's not part of the type class
21:21:11 <Gracenotes> last `fmap` replicateM i m?
21:21:46 <jtbandes> so presumably I could declare something similar using MultiParamTypeclasses, like "class Listlike (l e) where..."; would there be any advantage to doing so?
21:21:54 <geekosaur> not really
21:22:06 <tabemann> you don't want to use multiparameter type classes if you don't have to
21:22:16 <geekosaur> in fact it would probably hurt because you don't really want the container type constraining the element type or vice versa
21:22:21 <arkeet> cu
21:22:21 <tabemann> you usually have to do stuff with FunctionalDependencies to make them work right if you do
21:22:28 <geekosaur> ^^
21:22:36 <shachaf> Or there is no way to make them work right.
21:22:55 <geekosaur> if you don;t use either fundeps or type families then you *must* explicitly state types, because type inference is undecidable IIRC
21:23:10 <carter> Ghoul_ so look inside .ghc
21:23:19 <carter> youll see a file with the ghc version and 32 or 64
21:23:20 <Ghoul_> yeah, its labelled nicely, gotcha ;)
21:23:30 <carter> so you can just leave it there
21:23:32 * hackagebot egison 3.0.9 - An Interpreter for Egison, the world-first programming langugage which realized non-linear pattern-matching with unfree data types  http://hackage.haskell.org/package/egison-3.0.9 (SatoshiEgi)
21:23:34 <geekosaur> ...but in this case, `cons` is the only relevant operation and it uses the same type everywhere, so you don't actually need any magic anywhere, the type is clear
21:23:39 <Gracenotes> mstksg: is there something about the last action's value that makes it more important than the other ones?
21:23:41 <carter> 'cause member you'll wanan switch back
21:24:09 <Gracenotes> even though, well, they're all identical
21:24:38 <Gracenotes> If so, last/replicateM might not be so bad after all, to make it explicit.
21:24:49 <mstksg> Gracenotes: actually I misunderstood replicateM
21:25:01 <mstksg> i need to repeatedly apply a monadic operation tot he result of the last
21:25:07 <mstksg> and return the final result
21:25:14 <mstksg> is there a standard library function for that?
21:26:24 <tabemann> use >>= (foldM ...)
21:26:36 <Ghoul_> take a look at monad-loops
21:26:37 <jtbandes> geekosaur: I guess it seems strange to me that the "element type" shouldn't really be required to exist at all; we only have "Listlike l"
21:26:40 <tabemann> or with foldM_ if you don't care about the final value
21:26:41 <Ghoul_> @where monad-loops
21:26:41 <lambdabot> I know nothing about monad-loops.
21:26:50 <Gracenotes> yes, there's iterateM, but not in the standard libraries
21:27:02 <tgeeky> arkeet: I'm tickled to learn that what we were discussing has an acronym name: RAS, redundant acronym syndrome syndrome
21:27:19 <mstksg> tabemann i'm not sure if foldM is what i want, because there isn't actually a list i am folding over
21:27:33 <Ghoul_> mstksg: if foldM doesn't do what you want, something here will: http://hackage.haskell.org/packages/archive/monad-loops/0.4.2/doc/html/Control-Monad-Loops.html
21:27:58 <Gracenotes> mstksg: so you want to start with an initial value and feed it through a function (a -> m a) some number of times determined by an Int?
21:28:10 <mstksg> Gracenotes: yes, exactly that
21:29:08 <Gracenotes> well, there's not really a thing directly in the library for that, or even in monad-loops I think
21:29:08 <arkeet> tgeeky: I think you mean RAS syndrome.
21:29:10 <jtbandes> geekosaur: or, perhaps what bothers me is that "instance Listlike [] where" means that a type *constructor* (rather than a type, say [a]) is an instance of the typeclass?
21:29:21 <arkeet> oh right, I'm leaving.
21:29:44 <mstksg> is there really? because i've ran into the need for this multiple times
21:30:14 <Gracenotes> the cheap way out might be foldM on [1..n]
21:30:22 <roboguy_> jtbandes: why does it bother you? wouldn't you otherwise need instances to go with specific types, like [Int], [Char], etc?
21:30:25 <jtbandes> sounds like a job for.... church numerals
21:30:32 <geekosaur> jtbandes, why? the compiler can easily determine it's of kind * -> *, and there's no particular reason to parameterize the class on the element type (it's not needed for the definition)
21:30:56 <Ghoul_> mstksg: let { cond = (>= n); act = print } in do { res <- iterateUntilM cond act 0; ... }
21:30:58 <jtbandes> roboguy_: I was thinking "instance Listlike [a] where" ...
21:31:15 <mstksg> Gracenotes i think I've been using that so far
21:31:16 <geekosaur> put it this way: is map strange because it doesn't need to know anything about the type of list elements?
21:31:25 <Ghoul_> Wait, that's not a fold
21:31:25 <Ghoul_> sorry
21:31:27 <Gracenotes> mstksg: oh, or, in monad-loops, I suppose there's concatM (replicate i m) a
21:31:35 <geekosaur> (the thing you pass to it does, but map itself does not)
21:31:47 <jtbandes> geekosaur: "map :: (a -> b) -> [a] -> [b]" ó here a and b are specified as type variables
21:32:02 <roboguy_> jtbandes: what if you have a function like this: fmap :: (a -> b) -> f a -> f b
21:32:03 <geekosaur> yes, but it doesn't *know* anything about them
21:32:07 <geekosaur> the first parameter does
21:32:18 <Gracenotes> and yeah you can always roll your own
21:32:19 <roboguy_> inside a type class
21:32:22 <geekosaur> map just knows how to use it to get from point a to point be
21:32:24 <geekosaur> *b
21:33:09 <jtbandes> roboguy_: that makes more sense
21:33:21 <jtbandes> I think the definition "nil :: l e" is confusing me more than cons
21:33:26 <geekosaur> (in fact, the type there tells you that map can't itself know anything about a or b)
21:33:29 <jtbandes> because e is just a free variable
21:33:33 <roboguy_> jtbandes: then you would have a type class like this: class Functor f where fmap :: (a -> b) -> f a -> f b
21:33:45 <mstksg> i just want a simple version of f >>= f >>= f >>= f... n times
21:33:58 <geekosaur> but that's not unusual either
21:34:00 <geekosaur> :t []
21:34:00 <jtbandes> whereas "cons :: e -> l e -> l e" is more directly analogous to "fmap :: (a -> b) -> f a -> f b"
21:34:00 <lambdabot> [a]
21:34:06 <geekosaur> what's a?
21:34:20 <geekosaur> think about it
21:34:30 <shachaf> :t \n -> foldr (>=>) return . replicate n
21:34:30 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
21:34:31 <arkeet> :t foldr (>=>) return (replicate ?n ?f)
21:34:32 <lambdabot> Not in scope: `?'
21:34:32 <lambdabot> Not in scope: `?'
21:34:35 <arkeet> oh.
21:34:40 <geekosaur> :t Nothing
21:34:41 <jtbandes> mstksg: http://stackoverflow.com/questions/3911060/library-function-to-compose-a-function-with-itself-n-times ?
21:34:41 <lambdabot> Maybe a
21:34:53 <shachaf> hi arkeet
21:34:56 <arkeet> hi
21:34:58 <arkeet> I'm back.
21:35:20 <tabemann> let monadLoop f n a | n <= 0 = return a | otherwise = f a >>= monadLoop f (n - 1)
21:35:56 <arkeet> what's wrong with foldr (>=>) return
21:36:24 <jtbandes> perhaps my point is... why does the definition of nil need to involve e at all? I want something more like "instance Listable l where ... nil :: l ... cons :: a -> l -> l", except this loses information about the relationship between l and a
21:36:42 <Gracenotes> arkeet: that's basically concatM
21:36:53 <geekosaur> jtbandes, exactly
21:37:04 <Gracenotes> so, perhaps better to not use extra dependency
21:37:05 <shachaf> whoa, dude, since when does concatM exist?
21:37:07 <geekosaur> you can;t have that because you have lost the type
21:37:08 <shachaf> Oh, Control.Monad.Loops.
21:37:22 <shachaf> That's a weird name for it.
21:37:25 <arkeet> Gracenotes: I don't see the connection with concat.
21:37:33 <shachaf> [a -> a] -> a -> a is not called concat.
21:37:41 <shachaf> (It's fold, with Endo, but that hardly counts.)
21:38:09 <roboguy_> jtbandes: it does lose that relationship if you do that, which is why it needs to be a type constructor
21:38:32 <Gracenotes> shachaf: with monads, anything is possible
21:39:09 <roboguy_> jtbandes: nil just has a polymorphic type, like [] or even 1
21:39:22 <roboguy_> :t 1
21:39:23 <lambdabot> Num a => a
21:39:32 <Gracenotes> concat is foldr (++) [], in any case; compare to foldr (>=>) return
21:39:44 <Gracenotes> not that comparable, but just squint your eyes a lot
21:39:55 <shachaf> Compare to foldr (.) id
21:40:03 <roboguy_> well, 1 might not be the best example since it uses a type class instead of a type constructor, but [] works
21:40:06 <shachaf> Since that's what foldr (>=>) return is pretending to be.
21:40:45 <Gracenotes> what's the name for that again?
21:41:05 <jtbandes> roboguy_/geekosaur: aha, found an illustrative error: http://lpaste.net/6823898916681940992
21:41:51 <geekosaur> yes, that's what happens when you don't specify the type
21:42:40 <geekosaur> because you haven't specified it in the type signature, every use of it *must* be considered different
21:43:32 * hackagebot egison 3.0.10 - The world-first language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.0.10 (SatoshiEgi)
21:44:50 <roboguy_> jtbandes, geekosaur: I think the only possible implementation for cons, given that type class, is "cons x y = y" (ignoring undefined and things like that)
21:45:07 <shachaf> roboguy_: That sounds pretty bad.
21:45:20 * shachaf mumbles somehting about http://hackage.haskell.org/packages/archive/reducers/3.0.1/doc/html/Data-Semigroup-Reducer.html
21:45:33 <roboguy_> shachaf: yeah that's not really what I think of when I think of cons
21:45:43 <jtbandes> it seems that I should be able to say "cons = (:)" but forgo pattern matching, since the type of the left-hand argument will have no relation (specified by the Listlike typeclass) to the type of the right-hand argument
21:46:24 <jtbandes> (let's ignore the uselessness of forgoing pattern matching)
21:47:23 <tabemann> cons  = (:) is fine if the type class is Listable l and cons is cons :: a -> l a -> l a
21:47:36 <jtbandes> yes, I saw that earlier
21:47:40 <geekosaur> I think you fail to understand the type system.
21:47:47 <jtbandes> apparently
21:47:49 <roboguy_> jtbandes: your 'a' in your type class definition has no restrictions, so we can't make assumptions about it's type. This means we can't actually do any consing and, given that type signature in the type class you linked, we can only ignore that argument
21:47:55 <geekosaur> as you saw fromt he error you got, you lose too much information
21:48:06 <geekosaur> if you do not specify that type in the signatures
21:48:28 <geekosaur> so you can't do *anything* with it
21:49:00 <geekosaur> there is probably some variant type system which works the way you are thinking, but it would lose expressiveness in other areas
21:49:56 <roboguy_> jtbandes: it has to know that the 'a' in the first argument of cons is the same 'a' that is in the list type and the only way you can do that is with a type like: cons :: a -> l a -> l a
21:50:02 <jtbandes> in particular, (:) :: a -> [a] -> [a] is too specific to be able to fit into the definition a -> l -> l in general
21:51:03 <jtbandes> roboguy_: that is why I was saying -- forgoing the ability to cons things -- it seemed that the type of (:) should fit with the type of cons that I declared in the typeclass
21:51:04 <geekosaur> or else it would lose safety, because if it allowed you to do something with those types it would not be able to prevent you from mixing types (what is the type of a ListLike containing a Char and an Int? what happens if you define a fold across it?)
21:51:10 <jtbandes> but no, it's too specific
21:51:59 <jtbandes> geekosaur: yes, that makes sense, because the definition in my typeclass does not prevent "3 `cons` 'x' `cons` nil"
21:54:35 <roboguy_> jtbandes: the original 'a' in the type class definition of cons is a different type variable than the one in the type (:) :: a -> [a] -> [a], which is why ghc calls them 'a' and 'a1'. the scope of the type variable ends at the end of the type signature. the 'a' in the type class doesn't know anything about the 'a' in the instance
21:55:05 <geekosaur> and can't, really
22:07:32 <nan`> tabemann: TRAVIS
22:14:25 <JoeyA> Has anyone made a Bit type?  As in, a numeric variant of Bool.
22:14:45 <JoeyA> So 0 and 1 are valid literals.
22:15:13 <JoeyA> Though I suppose writing an orphan Num instance on Bool would be easy (albeit hacky).
22:15:18 <tabemann> nan`: yeah?
22:16:06 * tabemann had to whois you to see who you were
22:16:21 <JoeyA> (And wouldn't have a Show instance to go with it)
22:18:34 <roboguy_> JoeyA: a Show instance already exists for Bool
22:21:15 <roboguy_> JoeyA: unless you mean make a new type. you could make Bool itself an instance of Num, but that would be a little weird. I feel like that would go against type safety a bit
22:21:22 <JoeyA> I mean a Show instance showing as 0 or 1
22:25:23 <roboguy_> JoeyA: I'm not sure you could make a type that uses the literals 1 and 0 like that. you could make a Show instance that shows it that way, but I don't think you could actually use those literals the way you want
22:26:35 <JoeyA> You could make a type like that (by making a newtype and implementing lots of instances), but there wouldn't be a compile-time overflow check (just like there isn't for Int and other types)
22:26:59 <JoeyA> Also, the compiler wouldn't be able to detect exhaustive patterns
22:27:26 <JoeyA> e.g. foo (0:xs) = ...; foo (1:xs) = ...
22:28:07 <roboguy_> JoeyA: well, I guess you could sort of do it like that, but you'd still have to wrap the literals in a constructor. it seems overly complex and like it would make a new class of runtime errors possible and I'm not really sure what you would use it for
22:29:49 <ezrios> it has begun
22:29:55 <ezrios> I am installing xmonad
22:38:50 <notNicolas> one single word
22:38:53 <notNicolas> WHY? http://ideone.com/xVzOGj
22:39:16 <notNicolas> so sick of fucking with spaces and tabs until my haskell programs compile
22:41:28 <arkeet> notNicolas: never use tabs
22:41:36 <arkeet> then you'll be ok =)
22:41:44 <carter> notNicolas use sublime text3 or textmate
22:41:54 <tabemann> good editor support for Haskell, e.g. haskell-mode in Emacs, won't even try to use tabs
22:41:54 <carter> they let you make all the tabs become spaces
22:42:10 <notNicolas> I still don't even know the proper rules for spaces
22:42:15 <carter> and at least one of ST3 and textmate2 works on whaeever os
22:42:18 <carter> notNicolas thats ok
22:42:32 <carter> you can use {} and ;
22:42:40 <notNicolas> there's no apparent way how to organize spaces and newlines with where and let
22:42:50 <arkeet> there's a good quick explanation of layout in the report
22:42:56 <arkeet> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
22:43:01 <carter> also look at lots of example code too
22:43:14 <carter> we have >1mm LOC of code on hackage
22:43:29 <arkeet> e.g. line 23 is an error because everything inside a let block must have the same indentation level
22:43:48 <arkeet> if you put something less, it thinks the let block ends
22:43:59 <arkeet> if you put something too far to the right, it puts it together with the previous line
22:44:08 <CaptainK> I like that it forces that...take a little getting use to
22:45:05 <arkeet> in short:
22:45:24 <arkeet> you make blocks using where, let, do, or of (as in case-of)
22:45:32 <arkeet> statements in a block must start on the same column
22:45:35 <notNicolas> it's so hard to do anything without visual whitespace
22:45:38 <arkeet> to continue a line, indent
22:45:42 <arkeet> to end a block, deindent
22:45:53 <arkeet> it is?
22:46:19 <arkeet> well, you certainly want a monospace font. and you should never use hard tabs (the '\t' character)
22:46:32 <arkeet> other than that, all that matters is the column where you start things.
22:48:30 <carter> Ghoul_ back here please :)
22:48:51 <monochrom> here is a little secret: |'s don't have to be aligned, don't even have to be on separate lines
22:49:23 <jtbandes> sounds useful mostly for one-liners and ascii art
22:49:27 <notNicolas> is there a version of head/last that return [a] instead of a?
22:49:27 <arkeet> > let f x | x < 0 = -1 | x > 0 = 1 | otherwise = 0 in map f [-2..2]
22:49:29 <lambdabot>   [-1,-1,0,1,1]
22:49:40 <arkeet> notNicolas: take 1
22:49:54 <Ghoul_> carter: a few of r1-r15 should be available
22:49:56 <notNicolas> and last?
22:50:02 <Ghoul_> but it only uses rax
22:50:25 <arkeet> notNicolas: that's a bit harder, but the cheap way is take 1 . reverse
22:50:31 <Ghoul_> I suspect rax is marked as un-used after its used to write and it gets reallocated or something
22:50:37 <notNicolas> oh, nice.
22:50:37 <arkeet> well, take 1 . reverse is fine
22:50:47 <arkeet> I generally don't like using reverse but it works well enough.
22:50:48 <monochrom> [last xs]
22:50:53 <arkeet> haha
22:51:14 <carter> Ghoul_  you don't have any bang patterns on the args of things
22:51:15 <arkeet> maybeToList . teaspoon . last
22:51:17 <notNicolas> even better
22:51:25 <arkeet> [last xs] won't do what you want ;)
22:51:27 <carter> just humor me and cargo cult doing bang patterns on all the args
22:51:32 <arkeet> > [last []]
22:51:33 <lambdabot>   [*Exception: Prelude.last: empty list
22:51:37 <carter> and also try with -fllvm
22:51:38 <shachaf> carter: :-(
22:51:52 <notNicolas> oh really?
22:52:03 <arkeet> [blah] is a 1-element list, no matter what blah is.
22:52:04 <Ghoul_> core says its strict :|
22:52:06 <Ghoul_> but okay
22:52:11 <arkeet> even if it's an error.
22:52:15 <monochrom> [seq xs (last xs)]
22:52:17 <carter> Ghoul_ actually first ‚Ä†ry wiht llvm
22:52:18 <notNicolas> what's the problem with [last xs] ?
22:52:26 <carter> nothing else matters :)
22:52:30 <arkeet> see what I just did iwth lambdabot.
22:52:43 <arkeet> it's the same problem with [head xs]
22:52:46 <carter> *with -fllvm
22:52:52 <notNicolas> there's a problem???
22:53:06 <arkeet> I thought you were asking because you wanted to not blow up when xs is empty.
22:53:17 <carter> Ghoul_ this is exactly code that -fllvm with optimize well
22:53:20 <arkeet> if you want to blow up, [last xs] is fine.
22:53:22 <monochrom> well, I guess I interpreted the specification differently
22:53:28 <Ghoul_> I can't use llvm :(
22:53:29 <carter> because ghc doesn't have any logic for optimizing bit fiddling
22:53:30 <Ghoul_> it wont work
22:53:33 <notNicolas> my code is set up that it won't do [last xs] unless length xs >= 1
22:53:34 <carter> Ghoul_ you have to figure that out :)
22:53:41 <carter> Ghoul_ google around
22:54:13 <carter> Ghoul_ isn't the CLI only version of visual studio still free?
22:54:17 <arkeet> notNicolas: well, have it your way then.
22:54:19 <carter> you can use that to build LLVM i think
22:54:31 <Ghoul_> I dont think those work with ghc
22:54:37 <Ghoul_> then it needs to use link.exe and not ld
22:54:44 <arkeet> what's wrong with mingw?
22:54:58 <Ghoul_> uh, its not actually a problem with llvm
22:55:01 <Ghoul_> ghc just says it can't find it
22:55:08 <carter> Ghoul_ now we're making progress
22:55:10 <Ghoul_> when its on path and I can call it perfectly with llc -version
22:55:15 <carter> paste the error messages
22:55:34 <Ghoul_> let me try something else first.
22:58:01 <Ghoul_> carter: http://lpaste.net/90773
22:58:20 <carter> lispy may be able to help,
22:58:30 <carter> Ghoul_ your ghc will ahve a settings file somewhere
22:59:08 <Ghoul_> hmm
22:59:29 <carter> Ghoul_
22:59:30 <carter> OOO
22:59:32 <carter> better idea
22:59:38 <carter> do you know where your caba/config
22:59:40 <carter> file is?
22:59:43 <Ghoul_> yes
22:59:46 <carter> Ghoul_ ok
22:59:47 <carter> step one
22:59:53 <carter> install cabal-install and cabal head
23:00:17 <Ghoul_> you want me to build cabal head?
23:00:25 <carter> hangon
23:00:29 <carter> need to double check something
23:00:44 <carter> Ghoul_ yes
23:00:54 <carter> install them even
23:01:00 <carter> Ghoul_ actuall
23:01:01 <carter> stop
23:01:09 <carter> first
23:01:26 <carter> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html
23:01:38 <carter> you can pass ghc options by hand http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html
23:01:45 <lispy> I heard my name
23:01:48 <carter> -pgmlo and -pgmc
23:01:50 <lispy> what can I help with?
23:01:58 <carter> lispy you have windows + ghc powers
23:01:59 <carter> right?
23:02:05 <lispy> I has it
23:02:10 <carter> i'm trying to help Ghoul_  use -fllvm
23:02:12 <lispy> it's right here
23:02:19 <lispy> oh, no I've never done that :(
23:02:23 <carter> ah
23:02:24 <carter> ok
23:02:35 <lispy> I've never tried the llvm stuff for ghc
23:02:36 <Ghoul_> it was working fine when I was on win7 with ghc 7.4
23:02:40 <Ghoul_> I just had to have it in the path
23:02:44 <lispy> I've heard it's nice, but eh.
23:03:02 <carter> Ghoul_ ghc main.hs   -pgmlo pathopt -pgmc pathllc
23:03:11 <carter> should work rigt?
23:03:19 <Ghoul_> uh, does it want full path
23:03:22 <carter> sure
23:03:25 <carter> why not
23:03:37 <notNicolas> yes, I did it!
23:03:37 <Ghoul_> not sure how quotes and the shit-tier windows terminal are going to work with that, but okay
23:03:38 <notNicolas> http://ideone.com/WguP4w
23:03:48 <carter> everyone gets to learn!
23:05:27 <silverface> hello world
23:05:55 <silverface> anyone there?
23:05:57 <Ghoul_> Nah, those options didn't help
23:06:19 <carter> Ghoul_ share your error messages
23:06:21 <carter> or we can't help
23:06:22 <carter> :)
23:06:29 <Ghoul_> same as before - it doesn't find it.
23:06:31 <carter> though i am wandering off now
23:06:34 <carter> well
23:06:35 <Ghoul_> http://lpaste.net/90773
23:06:35 <notNicolas> thanks for the help y'all
23:06:48 <carter> Ghoul_ now
23:06:49 <carter> NO
23:06:53 <notNicolas> my first syntax-directed translation scheme in action
23:07:01 <carter> you need the -pgmlo -pgmlc stuff
23:07:16 <Ghoul_> yeah, sec, my terminal went to wierdness
23:07:20 <Ghoul_> I'll copy exactly what I put in
23:08:40 <Ghoul_> http://lpaste.net/90774
23:09:15 <carter> ok
23:09:23 <mstksg> hi all. wanted to finally start a blog and was wondering if anyone knew of any medium-scale web servers written in haskell with source code online
23:09:26 <Ghoul_> Oh, maybe its a path length issue.
23:09:34 <mstksg> i found a lot of cute web frameworks but idk if they are reasonable to make large projects with
23:10:17 <carter> mstksg i know of at least 2 Enterprise size web businesses using Snap, and at least one using yesod
23:11:06 <carter> Ghoul_ why are they quoted?
23:11:08 <Ghoul_> No, not a path length issue. I threw the stuff in C:/MinGW/bin and it didn't help
23:11:20 <Ghoul_> uh, otherwise I have to escape every single space or slash
23:11:31 <CaptainK> >     let dictwords = ["bares - unveils","moons - bares the buttocks; plural of moon, a satellite"]     print $ (filter (elem "bares" . words) dictwords)
23:11:32 <carter> FOR SCIENCE
23:11:33 <lambdabot>   not an expression: `let dictwords = ["bares - unveils","moons - bares the b...
23:11:37 <Ghoul_> and it doesn't show there, but the terminal goes to crap
23:11:38 <carter> no clue :)
23:11:41 <Ghoul_> and starts having redraw issues
23:13:04 <carter> tunixman: can your debugging powers work on windows?
23:13:29 <carter> Ghoul_ has ghc + windows weirdness
23:14:37 <carter> Ghoul_ might be best to ping folks for help during the day
23:14:56 <arkeet> it is the day somewhere in the world! :-)
23:15:00 <carter> it may looyes
23:15:04 <carter> damn
23:15:06 <carter> it may be
23:15:09 <CaptainK> what are the rules for {} and stringing one line together?
23:15:13 <Ghoul_> (4pm here)
23:15:28 <arkeet> CaptainK: ?
23:15:46 <arkeet> inside {}, whitespace doesn't matter.
23:15:51 <CaptainK> { line of code; line of code }
23:16:05 <tgeeky> CaptainK: maybe you just forgot the ;
23:16:25 <CaptainK> thats what I thought, but I'm missing something
23:16:32 <arkeet> paste code and error message?
23:17:35 <CaptainK> > { let dictwords = ["bares - unveils","moons - bares the buttocks; plural of moon, a satellite"]; print $ (filter (elem "bares" . words) dictwords); print $ (filter (elem "bares" . words) dictwords) }
23:17:37 <lambdabot>   <hint>:1:1: parse error on input `{'
23:18:03 <arkeet> I would have preferred a pastebin but ok.
23:18:13 <arkeet> you can't use {} anywhere.
23:18:23 <arkeet> it needs to make up a let/where/do/case-of block.
23:18:36 <CaptainK> do is missing
23:18:41 <arkeet> so, paste complete code?
23:18:49 <tgeeky> CaptainK: I think you are forgetting about @let.
23:18:50 <arkeet> unless that answers it
23:18:59 <tgeeky> @let dictwords = ["bares - unveils","moons - bares the buttocks; plural of moon, a satellite"]
23:19:00 <lambdabot>  .L.hs:135:1:
23:19:00 <lambdabot>      Multiple declarations of `dictwords'
23:19:00 <lambdabot>      Declared at: .L....
23:19:00 <arkeet> tgeeky: I think that's not the problem.
23:19:02 <tgeeky> @uundef
23:19:03 <lambdabot> Unknown command, try @list
23:19:04 <tgeeky> @undef
23:19:05 <lambdabot> Undefined.
23:19:08 <tgeeky> @let dictwords = ["bares - unveils","moons - bares the buttocks; plural of moon, a satellite"]
23:19:08 <lambdabot>  Defined.
23:19:13 <tgeeky> > filter (elem "bares" . words) dictwords
23:19:16 <lambdabot>   ["bares - unveils","moons - bares the buttocks; plural of moon, a satellite"]
23:19:18 <arkeet> or rather, you are answering a different problem.
23:19:22 <roboguy_> CaptainK: maybe you want a do block?
23:19:23 <tgeeky> arkeet: yes, probably so
23:19:29 <CaptainK> yes
23:19:46 <roboguy_> and an "in" after let, probably
23:20:02 <arkeet> roboguy_: not if it's in a do block.
23:20:22 <roboguy_> oh, yeah
23:20:37 <mstksg> anyone here personally built a web app/web server in haskell?
23:21:14 <maurer> mstksg: I've built toys using yesod
23:21:19 <maurer> mstksg: but nothing big
23:23:50 <Spockz> The Arrow module defines a newtype Kleisli and defines instances for Arrow Kleisli; however, it doesn't export the constructor of Kleisli, how am I supposed to use the instance for Kleisli? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Arrow.html#t:Kleisli
23:24:49 <arkeet> yes it does export it.
23:25:06 <jfischoff_> the constructor is listed in the constructor section
23:25:20 <jfischoff_> err Constructors section
23:26:57 <Spockz> arkeet: ah yes I'm not awake, thanks
23:27:16 <arkeet> I'm not asleep =(
23:28:07 <CaptainK> > do { let a=1; print a }
23:28:08 <lambdabot>   <hint>:1:23: parse error on input `}'
23:28:22 <CaptainK> ok what is missing to make that work?
23:29:05 <jfischoff_> another semicolon i think
23:29:21 <jfischoff_> > do { let a=1; print a ;}
23:29:22 <lambdabot>   <hint>:1:23: parse error on input `;'
23:29:29 <Cale> > do { { let a=1 }; print a }
23:29:30 <lambdabot>   <hint>:1:6: parse error on input `{'
23:29:30 <jfischoff_> guess not
23:29:39 <Cale> > do { let { a=1 }; print a }
23:29:39 <lambdabot>   <IO ()>
23:29:43 <Cale> there you go
23:29:46 <amosr> > do { let {a = 1; }; print a; }
23:29:47 <lambdabot>   <IO ()>
23:29:53 <joelteon> does anybody know how to call arbitrary SQL functions on results in esqueleto?
23:29:57 <Cale> you don't need semicolons at the end
23:29:59 <joelteon> all I want to do is lower() so it's not like there are any datatype chanegs
23:30:02 <joelteon> changes*.
23:30:05 <jfischoff_> ah
23:30:07 <Cale> they're separators, not terminators
23:30:33 <amosr> ah right
23:34:12 <CaptainK> doesn't the compiler just make a one liner anyway?
23:34:32 <CaptainK> no matter you have it turns it into a one line submission string
23:36:59 <arkeet> joelteon: sounds like that's what unsafeSqlFunction is for.
23:37:04 <arkeet> if you want to make your own thing.
23:37:18 <joelteon> yeah
23:37:21 <joelteon> guess I'll fork it
23:38:22 <CaptainK> how do you make multiple statements on one line in haskell?  What are the rules for the separators?
23:38:30 <arkeet> CaptainK: in what?
23:38:35 <arkeet> what context
23:38:39 <CaptainK> > do { let a=1; print a }
23:38:40 <lambdabot>   <hint>:1:23: parse error on input `}'
23:38:43 <CaptainK> in that
23:38:51 <arkeet> do { let {a = 1}; print a }
23:38:58 <CaptainK> or anything, just put two line together and spit soemthing out
23:38:59 <arkeet> the problem was that
23:39:11 <arkeet> without the extra braces, it parses as do { let { a = 1; print a } }
23:39:24 <CaptainK> >ah
23:39:36 <CaptainK> >do { let {a = 1}; print a }
23:39:45 <CaptainK> > do { let {a = 1}; print a }
23:39:46 <lambdabot>   <IO ()>
23:39:59 <arkeet> cale said this like 10 minutes ago.
23:40:01 <arkeet> I guess you missed it
23:40:07 <CaptainK> ya, lol
23:40:12 <CaptainK> I was looking for a 1
23:40:28 <CaptainK> guess now I know <IO ()> = 1
23:40:36 <arkeet> lambdabot doesn't execute IO.
23:40:48 <CaptainK> damn you lambdabot!
23:40:49 <arkeet> for reasons which are hopefully obvious.
23:41:00 * CaptainK shakes fist and crushes tinfoil hat
23:41:24 <CaptainK> yes, otherwise skynet takes over today
23:42:53 <CaptainK> thanks for the help on that, now I know how to show the other question, but for long stuff I can see pastebin is better
23:42:55 <arkeet> but if you were using layout, this would be a non-issue.
23:43:05 <arkeet> for anything more than one line, it's usually better.
23:43:44 <CaptainK> starting to understand that...its an important concept to understand what exactly the statement turns into.
23:45:42 <arkeet> CaptainK: http://lpaste.net/90775
23:47:34 <arkeet> I do recommend reading what the report says about layout.
23:48:00 <CaptainK> Have it bookmarked for digestion
23:48:01 <arkeet> before I read that I wasn't all that sure about the rules either.
23:48:02 <CaptainK> :P
23:48:10 <arkeet> but it's pretty simple once you figure it out.
23:48:19 <CaptainK> Here is a problem I'm having filtering
23:48:20 <CaptainK> http://lpaste.net/90776
23:48:54 <arkeet> what's wrong with it?
23:49:58 <mr-> CaptainK: is it that you find bares on both sides?
23:50:44 <CaptainK> yes
23:50:47 <CaptainK> http://ideone.com/bU2t3N
23:51:01 <CaptainK> does not the channel paste bin have output?
23:51:19 <arkeet> it does not run code, no.
23:51:31 <arkeet> it's just a pastebin.
23:51:37 <CaptainK> arkeet: ok gtk
23:52:02 <CaptainK> ya, I want the filter to only give me the first entry, not every entry where there is an instance
23:52:04 <arkeet> anyway, it does exactly what it claims, which is to filter the strings that contain "bares" as a word.
23:52:16 <arkeet> so you just want the first match?
23:52:44 <CaptainK> yes, but if I use !! 0, then I have to account for when there is no index
23:53:07 <arkeet> head is better than !! 0, but dealing with the case when there is no match is something you have to figure out.
23:53:13 <arkeet> we're not psychic. I think.
23:53:16 <CaptainK> my ol basic programming want to inject an if then else
23:53:21 <mr-> CaptainK: have you had a look at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html ?
23:53:25 <arkeet> pattern matching is good.
23:53:43 <arkeet> case blah of (stuff:_) -> do things with stuff; [] -> it's empty
23:53:57 <arkeet> where blah is the filtered list, stuff is the head when it exists
23:54:01 <CaptainK> which haskel does for my sugar, just not so tight code
23:55:12 <CaptainK> arkeet: I'll have to do some reading on case and play with some examples to peg down the syntax
23:55:39 <CaptainK> mr-: not fond of imports but Data.List is a nice one, will look at it
23:55:47 <arkeet> imports are good.
23:56:08 <arkeet> they save you from writing code that's already been written.
23:56:18 <mr-> CaptainK: It does not hurt to at least have a look at how other people split up problems
23:56:25 <arkeet> but sometimes all you need is a simple pattern match.
23:56:44 <CaptainK> yes I would rather pattern match
23:56:44 <arkeet> it also pays to stop thinking in bools
23:57:00 <Gracenotes> imports are better than adding new packages
23:57:05 <Gracenotes> and then importing
23:57:18 <Gracenotes> NIH, what NIH
23:57:20 <arkeet> @where boolean-blindness
23:57:20 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
23:57:44 <amosr> I like qualified imports, so re-reading the code later you know which package it's from
23:58:09 <mr-> amosr: I agree, or at least only import what is needed
23:58:51 <arkeet> the article takes its time getting to the point, though. :(
