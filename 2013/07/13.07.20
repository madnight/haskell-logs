00:01:57 <Gracenotes> lisp may be about processing a list or two, but Haskell is about making trees of lists which you process by deforestation
00:02:50 <mstksg> or is there an expressive way to convert a left-justified three-digit base-60 number with implicit trailing 0's into decimal?
00:02:55 <Gracenotes> yes it's a mixed metaphor that needs some work, but it's a start
00:03:09 <mstksg> for example [8,6] is interpreted as "860" base 60
00:03:24 <Ghoul_> johnw: incase you didn't see it, I sent the link in -blah
00:04:16 <Gracenotes> mstksg: the sensible way to represent numbers, oddly enough, is with the most significant digit at the tail
00:04:30 <Gracenotes> at least as far as making arithmetic operations easy
00:05:11 <Gracenotes> I'm not sure I see the value of lists when it comes to time
00:05:21 <Gracenotes> base 60 works for three values... and only three
00:05:30 <mstksg> i receive the time in a list, and i want to convert it to one integer for seconds
00:05:50 <mstksg> oh i could just use zipWith [60*60,60,0] and find the sum.
00:05:55 <Gracenotes> why do you receive the time in a list? can you programmatically throttle whoever made it into a list?
00:06:10 <Gracenotes> oh, or is it the result of parsing
00:06:18 <Gracenotes> zipWith would work.
00:06:22 <shachaf> Gracenotes: The value of lists may be that Haskell's type system doesn't easily let you express what you want to express here.
00:06:35 <mstksg> it's a parser and the timestamp is "optional seconds", or "optional minutes and seconds"
00:06:53 <shachaf> You might e.g. want parseNThings 3 thingParser :: Parser (Vec 3 Thing)
00:07:01 <shachaf> But you can't do that, you have to use a list.
00:07:27 <shachaf> (But here N is known statically so you *could* do that. But it'd be trouble to do it.)
00:07:47 <Gracenotes> shachaf: I see. Domains which are both over- and under-specified make me nervous, though, at least at first glance.
00:07:58 <mstksg> the thing is that there might only be 1, 2, or even 0 things, and i have to account for it
00:08:01 <mstksg> so i'm using sepBy
00:09:08 <mstksg> it's ok though i already have a rough solution. this is my first parsec project of decent size so i think everything i'm doing is non-idomatic. i'll work through everything later
00:09:11 <mstksg> thanks guys
00:09:42 <Gracenotes> yeah, sorry, I've been a bit non-constructive, in several senses.
00:12:06 <flebron> Say I have two m Bools. How can I (&&) them in a single expression? (For a "while"-like construct.)
00:12:11 <Gracenotes> not just painting bikesheds, painting individual planks...
00:12:24 <Gracenotes> :t liftM2 (&&)
00:12:25 <lambdabot> Monad m => m Bool -> m Bool -> m Bool
00:12:35 <flebron> Oh, I was using liftM. Thanks :)
00:12:46 <shachaf> flebron: It's quite possible that liftM2 (&&) isn't what you want.
00:12:54 <shachaf> In particular it won't short-circuit.
00:12:58 <Gracenotes> ah. yes, it won't quite, yes.
00:13:05 <shachaf> Or, rather, it'll short-circuit the evaluation, but not the execution of the actions.
00:13:20 <shachaf> It just means: do { x <- one; y <- two; return (x + y) }
00:13:26 <flebron> Ah. That's fine for my case. For the record, what's the better option?
00:13:48 <shachaf> There is none. Sorry.
00:14:09 <shachaf> I mean, you can write it yourself. But there's no nice general way of doing this.
00:14:35 <Gracenotes> monad-loops, as ever, has something or another that does it
00:15:26 <shachaf> I really wish you didn't lose "compositionality" like this.
00:15:33 <shachaf> One day someone will come up with a good solution.
00:16:49 <Gracenotes> that is one of the advantages of monads, that you lose compositionality
00:17:37 <shachaf> With comonads, you gain mpositionality. But no one cares about mpositionality.
00:17:50 <flebron> Does line 75 have incorrect indentation? http://ideone.com/QAoxot
00:18:03 <flebron> (An older version of GHC, on a programming contest site, seems to not like it. Mine does.)
00:18:13 <shachaf> Yes.
00:18:21 <shachaf> @google do and if then else haskell
00:18:22 <lambdabot> http://stackoverflow.com/questions/6117711/concise-if-then-else-notation-in-do-blocks-in-haskell
00:18:22 <lambdabot> Title: Concise if-then-else notation in do-blocks in Haskell - Stack Overflow
00:18:29 <shachaf> @google doandifthenelse haskell
00:18:30 <lambdabot> http://ghc.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
00:18:30 <lambdabot> Title: DoAndIfThenElse – Haskell Prime
00:18:39 <flebron> ew ew ew ew ew
00:18:44 <shachaf> One or both of those links should clarify.
00:26:28 <flebron> And just to make sure, the function find_set in the previous paste is efficient, right?
00:28:55 <Gracenotes> it can help, or somethings not maybe, to make type things
00:28:57 <Gracenotes> type Node = Int
00:29:20 <Gracenotes> type Graph = STUArray ...
00:29:58 <flebron> The graph is the STArray s Int Edge, conceptually, an array of edges :)
00:31:35 <applicative> find_set seems fine or am i missing something?
00:32:34 <applicative> oh its recursive maybe that can be helped flebron
00:32:39 <flebron> (Perhaps I was passing around a lot of stuff.)
00:32:49 <Gracenotes> is the writeArray necessary?
00:33:01 <flebron> Well my usual implementation in C is   if (x != parent[x]) parent[x] = find_set(parent[x]); return parent[x]
00:33:47 <flebron> (It's the disjoint forest implementation of disjoint sets)
00:33:56 <flebron> (Also known as union find)
00:36:47 <Gracenotes> ah, I see
00:38:08 * hackagebot bio 0.5.3 - A bioinformatics library  http://hackage.haskell.org/package/bio-0.5.3 (KetilMalde)
00:38:55 <dmj> are the ghc hackathon videos all gone?
00:39:14 <dmj> http://ghc.haskell.org/trac/ghc/wiki/AboutVideos
00:39:40 <dmj> nvm its on youtube
01:34:26 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
01:34:26 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:32 2013]
01:37:12 <danbst> ? lambdabot
01:38:13 <danbst> where does the full IRC lambdabot manual host?
01:39:33 <danbst> ? JOIN
01:40:03 <danbst> index JOIN
01:40:23 <danbst> ? /JOIN
01:41:02 <danbst> how can I create private talk with lambdabot?
01:41:17 <ion> /query lambdabot
01:41:52 <danbst> ion, thanks!
02:08:17 * hackagebot snap-app 0.5.0 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.5.0 (ChrisDone)
02:11:00 <Lethalman> :t findM
02:11:01 <lambdabot>     Not in scope: `findM'
02:11:01 <lambdabot>     Perhaps you meant one of these:
02:11:01 <lambdabot>       `BS.find' (imported from Data.ByteString),
02:18:10 * hackagebot ghci-ng 7.6.3.3 - Extended GHCi fork  http://hackage.haskell.org/package/ghci-ng-7.6.3.3 (HerbertValerioRiedel)
02:21:14 <daat418> d
02:23:39 <diabel23_> where can i find haskell library index?
02:23:50 <diabel23_> most of http://www.haskell.org/haskellwiki/Web
02:23:53 <diabel23_> links are broken
02:23:54 <ion> http://hackage.haskell.org/packages/archive/pkg-list.html
02:25:11 <daat418> Hey - how many of you learned Lisp/Scheme/CL prior to Haskell? Did any of you start programming with Haskell (i.e., first ever language)?
02:25:35 <ion> I had learned Lisp first.
02:25:43 <ion> I mean, before Haskell. Not as my first language.
02:26:31 <daat418> ion: still relevant to me (possibly :) )
02:26:48 <daat418> ion: do you feel as if you Lisp experience directly informed your Haskell learning experience?
02:26:58 <shiona> I had learned only "normal" imperative languages before haskell
02:27:49 <ion> daat418: All the experience in all previous languages affects your $new_language learning experience.
02:28:09 <daat418> shiona: I am a complete beginner. My only credentials are familiary with unix, ability to "code" in transact-sql and reading config files :/
02:28:48 <mstksg> i learned lisp before haskell too but i was lucky to come from a ruby background, which emphasized functional/non-imperative approaches to problems
02:29:20 <daat418> mstksg: i didnt know that...
02:29:23 <mstksg> lisp never became anything too practical for me
02:29:35 <ion> mstksg: Not nearly to the same extent as Haskell, though.
02:30:02 <mstksg> ion: of course, but i was no newcomer to "thinking functional" when approaching haskell
02:30:32 <daat418> mstksg: I've learned that most people are not really using lisp "practically" - all i know is that lisp is easy enough to work with within the context of emacs dotfiles and i happen to find it quite beautiful...
02:30:33 <mstksg> most of the paradigm transitions came from haskell's type system and typeclass abstractions
02:30:36 <ion> I never ended up using a variant Lisp of my “default” language either. But Haskell ended up being that.
02:30:51 <daat418> I'm strongly considering "starting out with programming" with SICP
02:31:09 <ion> The old SICP lectures are great.
02:31:25 <daat418> ion: I have both the book and the lectures :D
02:31:32 <daat418> ion: starting them tomorrow
02:31:59 <ion> But i’m sure starting with Haskell with e.g. LYAH + help from this channel would work as well.
02:32:15 <daat418> ion: I tried Zed Shaw's python book. I've realized - finally - that I have a strong aversion to learning things without: 1) knowing exaclty how it works 2) exactly why i need it
02:32:22 <daat418> brb
02:32:39 <mstksg> in that case, the best thing you can really do is just to begin hammering out scripts
02:33:24 <mstksg> and eventually moving on to larger projects of non-trivial structure
02:33:46 <mstksg> you won't ever have to learn anything without knowing why you are learning it that way
02:34:15 <mstksg> to be fair it's a bit haphazard, but a year or two down the line i don't think you'll be any worse off
02:34:48 <mstksg> as long as you keep on learning about better ways to do things or new possibilities
02:35:36 <daat418> mstksg: ion: how long did it take you guys to feel "comfortable" and "confident" when you started out? (complete beginner)
02:37:41 <ion> I can’t really remember. It did take more time than learning yet another CLispScript would have taken. I do feel comfortable in Haskell nowadays, but i keep learning new things all the time.
02:37:47 <FreeFull> I didn't take that long because I have done functional programming before and don't have too much trouble absorbing new concepts quickly
02:37:56 <FreeFull> I don't have an objective measure of time though
02:37:57 <daat418> mstksg: maybe it's my ADHD - I'm just having -such- a hard time getting the energy to work through the monotony of learning syntax through drills. every book begins the same way... "here are some [math operator drills] things for you try first!"
02:38:37 <daat418> FreeFull: How did you motivate yourself initially?
02:39:01 <mstksg> daat418: that's why i suggested you just write some practical scripts for your own use
02:39:19 <mstksg> daat418: do you mean haskell or programming in general?
02:41:14 <daat418> mstksg: in general
02:41:34 <daat418> mstksg: I don't know any programming languages - I'm a complete beginner.
02:41:54 <daat418> mstksg: I do not have a formal education either.
02:42:05 <daat418> mstksg: formal -tertiary- education
02:42:29 <daat418> mstksg: so zero compsci background outside of self-teaching via neccesity/employment
02:42:57 <Lethalman> @hoogle t a -> (a -> m b) -> m (t b)
02:42:58 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
02:42:59 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
02:42:59 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:43:04 <Lethalman> I knew it
02:43:10 * hackagebot snap-app 0.6.0 - Simple modules for writing apps with Snap, abstracted from hpaste.  http://hackage.haskell.org/package/snap-app-0.6.0 (ChrisDone)
02:43:11 <daat418> Lethalman: O_O
02:43:26 <Lethalman> I was looking for something like maybeDo :: Maybe a -> (a -> m ()) -> m ()
02:43:47 <shachaf> Lethalman: Data.Foldable.for_
02:43:55 <hvr> Lethalman: this is almost a FAQ ;)
02:43:56 <Lethalman> :t Data.Foldable.for_
02:43:56 <lambdabot> (Applicative f, Foldable t) => t a -> (a -> f b) -> f ()
02:44:21 <Lethalman> thanks, let's see
02:44:22 <hvr> Lethalman: ppl usually ask for 'whenM' and get pointed to Foldable.for_
02:44:33 <Lethalman> :t whenM
02:44:33 <FreeFull> daat418: I wanted to know what a modern functional programming language looked like
02:44:34 <lambdabot>     Not in scope: `whenM'
02:44:34 <lambdabot>     Perhaps you meant `when' (imported from Control.Monad.Writer)
02:44:37 <Lethalman> eh eh
02:44:45 <FreeFull> And once I started learning Haskell, I thought "Hey, that's cool"
02:45:00 <FreeFull> In general, I wanted to make computers do stuff =P
02:45:07 <hvr> Lethalman: 'whenM' is getting proposed to be added to the base libraries every year or so :)
02:45:26 <mstksg> daat418: i don't know what people on this channel would say, but i recommend just starting with simple imperative scripts...and you understand the entire idea of everything.  it's just a list of instructions for a computer to do
02:45:35 <mstksg> write simple scripts for your own use.
02:45:46 <shachaf> hvr: Hmm, if I make patches to this thing, would someone else backport them to real ghci?
02:45:56 <mstksg> if you use a web app/site with an open API (like last.fm) maybe learn how to download your data and store it in a text file
02:45:59 <hvr> shachaf: you mean forward-port? :)
02:46:11 <mstksg> if that's too much to start, then make a rock papper scissors game
02:46:18 <shachaf> I don't know about the direction.
02:46:19 <taylorgb_> For someone in daat418's situation, I would be tempted to suggest he find some working haskell programs then play around with them to see what he can do
02:46:25 <taylorgb_> sometimes starting from scratch can be a bit boring
02:46:40 <shachaf> Anyway I have a list of small things I'd want to change in ghci.
02:46:41 <hvr> shachaf: I'd be prepared to port them  GHC HEAD if that's what you mean
02:46:58 <daat418> FreeFull: Yes, I am keen on that too. Very much so. I do it daily in a backhanded, newbie way. I have a very large and self-created autohotkey file. I have a very customized, keyboard-driven minimal environment. I just... can't bring myself to get past the "boring" parts of learning the syntax through what is always disguised as drills. I'm ADHD.
02:47:13 <hvr> shachaf: so feel free to make pull-req's and I'll try to port them to GHC HEAD
02:47:17 <daat418> taylorgb_: I have already loaded pandoc up for this purpose :)
02:47:32 <hvr> shachaf: as I have a full GHC source tree lying around anyway so it's no big deal for me
02:47:34 * shachaf doesn't really do the "pull request" thing but will look into it at one point.
02:47:44 <FreeFull> daat418: Maybe it could help if you used anything you learn straight away as you are learning it
02:47:45 <daat418> taylorgb_: <3 pandoc by the way. I've already converted all my work documentation into orgmode files.
02:47:47 <shachaf> I do too. Maybe I should just figure out how to compile ghci standalone?
02:47:52 <taylorgb_> :)
02:48:11 <mstksg> personally i don't really learn anything lasting until i start actually writing my own code
02:48:16 <hvr> shachaf: it's just annoying to clean/rebuild most of GHC every time you git pull
02:48:23 <mstksg> i'm not really sure what these 'drills' you are referring to are
02:48:40 <mstksg> i don't think i've ever learned a language by practicing syntax in a vacuum
02:48:45 <hvr> shachaf: and ghci-ng is mostly about providing new features to a larger user-base
02:48:57 <daat418> mstksg: Exactly.
02:49:05 <hvr> shachaf: as not many use GHC HEAD's GHCi on a regular basis
02:49:08 <mstksg> do you know how to write pseudocode?
02:49:33 <adnap_> Why is nothing like http://hackage.haskell.org/packages/archive/cgi/latest/doc/html/Network-CGI-Protocol.html#v:replace in Data.List?
02:49:41 <hvr> shachaf: nevertheless, you should try out github's pull-req, just to know what that's about :)
02:49:49 <shachaf> I don't like cloning repositories.
02:49:59 <ion> I don’t think anyone here has learned a language by practicing in a vacuum, since they wouldn’t be alive to tell about it.
02:50:02 <mstksg> imperative programming is just pseudocode with certain structuring rooms
02:50:09 <mstksg> *rules
02:50:16 <taylorgb_> ion: zing
02:50:23 <FreeFull> shachaf: It would be really cool if custom ghci commands could take input from the output of other ghci commands in some easy way
02:50:28 <Xunie> All programming is just pseudocode with certain structuring rules.
02:50:38 <daat418> mstksg: re imperative scripts - this is what is causing me to get brain-paralyzing bordedom. Python feels like the most abstract thing in the world - the whole time I tried learning I got bored because I felt like i was just learning "The python way of saying this simple instruction" - I didn't feel like I was learning how it all worked. I don't want to "learn" computer science by ignoring it via "helpful" abstractions
02:50:43 <shachaf> hvr: I want things like: Semicolon-separated import statements. A variant of "%s" in prompt that only shows the loaded module, not the imported ones. Fixing the tab-completion bug that shows something multiple times when it's imported from multiple modules. A variation of :i that doesn't list instances and thereby flood the terminal with things I don't care about. Various other prompt features. :i to tell me where something was imported from, ...
02:50:47 <Xunie> All language is just pseudocode with structuring rules. <- I'm generalizing here.
02:50:50 <shachaf> ... not just where it was defined. :bro to work an an import-foo-as-M name, rather than just the full original module name. ...
02:50:53 <shachaf> I have a file full of small things like that.
02:51:35 <daat418> mstksg: yes, i know how to write pseudocode. I can very comforably create an autohotkey file for you (or any other macro-based program)
02:51:52 <mstksg> if you can write pseudocode then you can do anything.
02:51:53 <hvr> shachaf: that's very interesting stuff.. indeed, if it helps getting those features out, I'll take patches/rc2822 too :)
02:52:13 <shachaf> I think most of these should be easy.
02:52:16 <mstksg> abstractions are there for a reason
02:52:19 <daat418> FreeFull: I need to find some way to do that ^_^
02:52:20 <shachaf> Ideally by listing them in IRC someone else will implement them.
02:52:24 <shachaf> But usually that doesn't work out.
02:52:30 <Xunie> Daww.
02:52:36 <Xunie> Works for most projects. :P
02:52:37 <hvr> shachaf: I actually need some extension to :info myself, e.g. finding out which package a module belongs too
02:52:46 <shachaf> hvr: Oh, that's good too.
02:52:55 <mstksg> if you want to get rid of as much as you can, program assembly. or C, if you want to keep a semblence of modernity
02:53:01 <ion> daat418: You might want to start at quantum physics then. When you understand it, figure out transistors etc. and move to the electronics abstraction. Then move to the digital circuits abstraction. Then to the memory, processor etc. abstractions. At that point, you should be ready to learn the machine language abstraction. Then move on to to a higher-level language, such as C.
02:53:01 <hvr> shachaf: and what module an 'as'-alias is associated with
02:53:15 <hvr> shachaf: e.g. if I have 'import Foo as F' and can't query about 'F' currently
02:53:23 <mstksg> those abstractions **are** what programming **is**.
02:53:27 <shachaf> hvr: Both good.
02:53:29 <mstksg> in the practical sense
02:53:46 <mstksg> in fact i guess you could generalize and say that all programming is abstraction
02:53:46 <daat418> ion: *wince*
02:53:57 <shachaf> hvr: Oh, it would be great if there was a more useful error when typing in a non-Show value.
02:54:12 <shachaf> E.g. "Unshowable value of type ...", including constraints.
02:54:17 <mstksg> you're abstracting a physical process...how much abstraction is determined by how much control you want and how little you want to be bogged down by
02:54:24 <shachaf> Rather than an annoying no-instance error.
02:54:26 <ion> daat418: Alternatively, just accept happily that there are layers upon layers of abstractions under everything.
02:54:36 <hvr> shachaf: well, only problem is: with ghci-ng you can only do stuff that can be done from the frontend; as other stuff would require modifications to the GHC monad
02:54:43 <shachaf> Yes.
02:54:48 <mstksg> these things that you are discarding as abstractions and not real programming are no more 'fake' than whatever idea of 'real' you have in mind
02:55:01 <shachaf> hvr: Last time I looked at this a lot of these involved at least a little bit of modification to the GHC codebase itself.
02:55:09 <shachaf> So probably this doesn't help me at all. :-)
02:55:09 <daat418> ion: I think I just need to settle down and work through SICP... that is the closest thing to a middle-ground. My problem with Python et al is that I know enough to understand that its not "real" programming and that is causing me to baulk.
02:55:12 <mstksg> this might be an unpleasant revelation
02:55:29 <ion> daat418: How is it not real programming?
02:55:35 <mstksg> there isn't anything 'fake' about programming in python
02:55:46 <hvr> shachaf: well, let's start with those stuff that can be done w/o modifying the rest of GHC :)
02:56:25 <shachaf> hvr: By the way, now that ghci supports e.g. "data X = ...", is there a particular reason not to make "x = ..." valid?
02:56:25 <mstksg> there are times when abstractions might get in the way of what you want to do.  in that case, you only need to go down enough levels to a level of abstraction that doesn't pose the same barriers
02:56:27 <hvr> otoh, the stuff that requires rest-of-GHC mods, should be done asap, as GHC 7.8 freeze is planned for september
02:56:31 <shachaf> hvr: I.e. without let.
02:56:41 <Xunie> Say, uhm. Won't this eventually overflow the stack? http://lpaste.net/1151324232039268352
02:56:45 <Xunie> Or am I too used to... C?
02:56:52 <daat418> ion: because python is built upon so many layers of abstraction, you can effectively ignore how the code is being used by your computer. You just tell the computer - line by line - what you -expect- versus what to -do-
02:57:12 <mstksg> if there's something you need to do that python abstracts over...switch to Java, perhaps.  And if Java's abstractions get in the way of being productive, switch to C.
02:57:15 <mstksg> C++
02:57:31 <hvr> shiona: I've been wondering that myself actually...
02:57:33 <mstksg> if C's abstractions get in the way of what you want to do, switch to assembly
02:57:34 <daat418> mstksg: I refuse to touch Java.
02:57:46 <ion> daat418: If i’m guessing what you mean by “real” programming anywhere correctly, you can’t even do real programming at all with a modern x86-compatible CPU. When you give them machine language to execute, they actually run microcode to translate it to something else that they’ll *actually* run.
02:57:50 <shachaf> I think this whole programming language argument is pretty off-topic for this channel.
02:57:52 <hvr> shachaf: I've been wondering that myself actually...
02:58:04 <shachaf> Xunie: It won't, in this case.
02:59:05 <shachaf> Xunie: I'm going to say that you have a very different mental model of how GHC evaluates code from how it actually does (because almost everyone starts out that way).
02:59:10 <Xunie> shachaf, well. My question is: what is the 'proper' way of looping until something?
02:59:25 <FreeFull> Xunie: Either that, or using forever
02:59:27 <shachaf> People will say things like "tail recursion" that "sound right" but actually aren't.
02:59:32 <shachaf> Xunie: That way is fine.
02:59:55 <ion> daat418: But when you get yourself a trivial CPU you get to program directly, why not complain that you’re not doing *real* electronics because you’re not thinking about how each electrical state changes by your each instruction?
02:59:57 <Xunie> Say. Can I inspect the code of 'forever'?
03:00:05 <shachaf> Xunie: Yes. See Hoogle.
03:00:07 <shachaf> @where hoogle
03:00:07 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
03:00:18 <daat418> ion: excuse my ignorance. I think I am just handling the learning process awkwardly and incorrectly. I'm sure I just need to do what everyone else is doing and just "Read and write code". Maybe the answers will come as a gnosis-type revelation in response to accumulated knowledge and experience.
03:00:18 <shachaf> Search for "forever", click "Source".
03:00:42 <Xunie> Oh, doh. I forgot about hoogle and hayoo. God, I love those names. :3
03:01:19 <daat418> ion: Alright, this is embarassing but...
03:01:56 <daat418> ion: I'm sure the biggest problem I face when it comes to learning new material...
03:02:07 <daat418> ion: ...is that I don't really know how.
03:02:16 <shachaf> daat418 et al.: I think this conversation is pretty off-topic here by now.
03:02:48 <daat418> shachaf: facepalm - I did it again. Apologies. I'm adding #haskell-blah to my irssi config so i don't forget.
03:02:59 <daat418> this is totally my fault
03:03:19 <daat418> goodnight everyone. thanks for the guidance.
03:03:47 <shachaf> Well, maybe all the Haskell conversations died off in the meanwhile.
03:06:19 <ion> @tell daat418 FWIW, i have had good personal success by embracing the abstraction and learning high-level languages before studying what’s going on underneath and also learning about electronics and moving toward higher-level things such as processors, eventually meeting in the middle.
03:06:19 <lambdabot> Consider it noted.
03:07:04 <taylorgb_> So is the 2010 report going to include multi-parameter type classes and things?
03:07:15 <taylorgb_> And other popular extensions, whatever they might be
03:07:30 <ion> I thought the 2010 report was already done.
03:07:39 <shachaf> The 2010 report is already out (the year is 2013) and it doesn't include MPTCs.
03:07:43 <taylorgb_> oh
03:07:55 <taylorgb_> Time just passes you by sometimes
03:08:12 <shachaf> http://www.haskell.org/pipermail/haskell/2009-November/021750.html lists all the changes, I think.
03:08:17 <shachaf> Unfortunately the link is broken.
03:08:18 <ion> taylorgb: especially when you’re a near-c space ship.
03:08:22 <shachaf> thoughtp1lice: ☝
03:08:22 <taylorgb_> No, someone was talking about feedback for the report last night, so was wondering whether it was being worked on sometimes
03:08:26 <taylorgb_> er still
03:08:33 <ion> +in
03:08:51 <shachaf> ion: Time has fun when you're flying.
03:23:13 <chrisbuchholz> hey guys. what would be a good library for monitoring changes to a file/directory? i have looked at hinotify and kqueue but they dont look very used. i know yesod does it some way, but how? havent been able to find it in their source code
03:23:33 <chrisbuchholz> git-annex too
03:23:45 <notdan> @hoogle (a -> b) -> c -> f a -> c -> f b
03:23:45 <lambdabot> Foreign.C.Error throwErrnoIfRetryMayBlock :: (a -> Bool) -> String -> IO a -> IO b -> IO a
03:23:45 <lambdabot> Foreign.C.Error throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
03:23:45 <lambdabot> System.Posix.Error throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
03:23:53 <notdan> @hoogle (a -> b) -> (c -> f a) -> c -> f b
03:23:53 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
03:23:53 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
03:23:53 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
03:24:02 <notdan> Is there a point-free version of <$>?
03:24:06 <shachaf> Maybe #yesod can answer the second question.
03:24:08 <shachaf> @google yesod inotify
03:24:08 <lambdabot> Plugin `search' failed with: user error (https not supported)
03:24:24 <shachaf> The Google result for «yesod inotify» says it just polls.
03:24:33 <shachaf> notdan: (<$>) is a point-free version of (<$>)...
03:24:48 <FreeFull> :t fmap
03:24:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:25:06 <chrisbuchholz> shachaf: polling seems very inefficient
03:25:24 <shachaf> Surely.
03:25:44 <notdan> shachaf: well, ok, I am using the wrong terminology here I guess
03:26:36 <shachaf> Maybe you want fmap . fmap
03:26:41 <shachaf> :t fmap . fmap
03:26:42 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
03:28:17 <yesthisisuser> hmm.. i'm reading this Happstack/SimpleHTTP tutorial.. http://hackage.haskell.org/packages/archive/happstack-server/0.5.0.2/doc/html/Happstack-Server-SimpleHTTP.html
03:28:20 <yesthisisuser> the first example
03:28:26 <yesthisisuser> myAuth, return "Hello World!"
03:28:43 <yesthisisuser> main = simpleHTTP nullConf $ myAuth, return "Hello World!"
03:28:48 <yesthisisuser> what is the ',
03:28:55 <yesthisisuser> the ',' doing there
03:29:12 <notdan> shachaf: oh yeah, thanks
03:29:27 <shachaf> Nothing. It's an error.
03:29:48 <yesthisisuser> its a typo or?
03:30:16 <shachaf> Looks that way.
03:30:38 <yesthisisuser> it really confused me
03:31:05 <shachaf> Well then, don't look at old documentation, I guess.
03:31:16 <yesthisisuser> good point
03:31:23 <shachaf> This is version 0.5.0.2. http://hackage.haskell.org/package/happstack-server says the latest version is 7.3.0.
03:31:38 <shachaf> More than three years apart. :-)
03:32:01 <yesthisisuser> my bad
03:32:37 <bitonic> is there a “data Proxy1 (f :: * -> *) a = Proxy1” somewhere?
03:32:39 <notdan> shachaf: is there a good way to use 'fmap . fmap' in an infix notation?
03:32:49 <bitonic> or something to that effect
03:34:15 <shachaf> notdan: No.
03:34:18 <byorgey> bitonic: no. with KindPolymorphism you only need one Proxy.
03:34:23 <notdan> ok, thanks
03:34:39 <bitonic> byorgey: that Proxy1 has two parameters, Proxy has 1
03:34:57 <byorgey> bitonic: true. I assumed that was an inessential detail.  What do you want two parameters for?
03:35:33 <bitonic> byorgey: well I’ve got this data structure parametrised over things like that, and I need Proxy1 sometimes
03:36:37 <byorgey> ok.  Make your own I guess.
03:36:50 <bitonic> cool, just wanted to make sure it wasn’t something established already
03:38:16 <shiona> hvr: what have you been wondering about?
03:50:01 <hvr> shiona: nevermind, my tab-completion just mixed up 'shiona' & 'shachaf' :)
03:51:51 <ion> hpc: indeed
04:02:52 <Zenol> hi
04:04:29 <Zenol> Probably stupid but, a question. Is it possible to give to a function a "pattern" to match on. ie f p a = case a of p -> ...; _-> ... ?
04:05:32 <elliott> nope
04:05:34 <ion> Alas, Haskell doesn’t have first-class patterns.
04:05:44 <Cale> Zenol: nope. The second p there will be a variable which shadows the first p, and will be bound by the case expression to a.
04:05:49 <elliott> you could make (p :: TypeOfA -> Bool) or such
04:05:55 <elliott> or -> Maybe SomeStuff
04:05:57 <elliott> or use lens's prisms.
04:06:08 <shachaf> Or lens's lenses!
04:06:23 <ion> or prism’s lenses!
04:06:35 <ion> They probably have a copy of lens in prism.
04:06:57 <Zenol> Cale> I know that this won't work, but is there a way of doing something like that?
04:07:06 <ion> ↑
04:08:50 <elliott> Zenol: my answers were to you
04:09:23 <Cale> Zenol: There's no straightforward way. Patterns aren't first class values.
04:09:57 <Zenol> elliot> ohw, sorry. prisms and lenses?
04:10:48 <Zenol> Cale> I wonder if it would be cool to have everything beeing a first class value.
04:11:03 <elliott> Zenol: lens is a library that has a concept called prism that can do something like this. but, my other answers are simpler :)
04:11:22 <elliott> then you'd pass the pattern in as e.g. (\a -> case a of foo -> True; _ -> False)
04:11:29 <elliott> or with LambdaCase, (\case foo -> True; _ -> False)
04:12:30 <Zenol> I was thinking on a good wai to solve that : I would like to bind some functions of type Event -> IO () to some events. And it would be really cool if the fonction is only called if event is one of the event that can be handle. A simple wai would be to have at the beginin of each function callback e = e case PATTERN of -> function core, _ -> do nothing.
04:13:07 <Zenol> But it would be event better if it was possible to write in the function type signature how the event looks like, so that the callback isn't called on a "bad" event.
04:14:13 <Zenol> Something like EventT "hellomsg" (PacketT (UInt8, UInt16, String, UInt8)) -> IO ()
04:14:38 <Zenol> But now, I can't give different callback to the same function since they don't have the same type.
04:15:07 <Zenol> And also, I don't relly know how to handle many Events and convert them to such strange types.
04:16:05 <shiona> hvr: ok (damn this channel is fast)
04:17:00 <Zenol> that's why a TypeOfA -> Bool is no more than having a pattern matching directly in the function. (And actualy even giving the pattern when adding a callback is a bit ugly since you can write a pattern that didn't match what the function really expect.)
04:17:45 <elliott> Zenol: sort of seems like prisms might help you here, but I don't really have any specific advice.
04:20:53 <Zenol> elliot> Seams to be a huge library. Is it the same lens as ones used by snap?
04:21:03 <elliott> yes
04:21:33 <Zenol> elliot> Ok, I never understoud how they are worked and how to use them x)
04:23:28 <diabel23_> im searching a tutorial how to use haddock
04:36:56 <Zenol> diabel23_> The haddock documentation is well writen (http://www.haskell.org/haddock/doc/html/), look at how to invok haddock and documenting whatyouwant.
04:37:14 <diabel23_> thanks
04:37:24 <diabel23_> i just needed to use cabal-dev haddock
05:03:13 * hackagebot aivika 0.6.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.6.1 (DavidSorokin)
05:03:15 * hackagebot aivika-experiment 0.3.1 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-0.3.1 (DavidSorokin)
05:03:17 * hackagebot aivika-experiment-chart 0.3.1 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-0.3.1 (DavidSorokin)
05:12:46 <srhb> Which words should I google to figure out how to generate random, non-overlapping ranges within a range with Haskell?
05:13:16 <srhb> I could generate all possible ranges and select at random, but that seems dangerously inefficient.
05:13:26 <sipa> define random
05:13:35 <sipa> what distribution?
05:13:45 <srhb> "random." <_<
05:14:29 <srhb> I don't know how to answer that question.
05:14:42 <ignacio> pick 2 random reals -> bam, random innterval
05:14:46 <CAP2094> hi
05:14:56 <CAP2094> O.O
05:15:18 <srhb> ignacio: Aye, it's easy to get one random interval, but getting a set number of non-overlapping random intervals within another interval is the problem.
05:17:15 <srhb> And if one of the random intervals within [1..10] is [1..10] itself I can't produce the required, say 3 intervals.
05:17:52 <srhb> Which tells me I do need to do some kind of trial and error, because if that can happen (even improbably) I'll have to discard and regenerate.
05:18:13 * hackagebot directory-layout 0.4.0.1 - Declare, construct and verify directory layout  http://hackage.haskell.org/package/directory-layout-0.4.0.1 (MatveyAksenov)
05:18:36 <srhb> Which again tells me I need to select some kind of probability distribution to the length of a given sequence, or I can end up having to discard a lot of generated sequences.
05:18:39 <banister> what is a 'morphism' ?
05:18:59 <elliott> banister: in the context of Haskell, a function.
05:19:19 <banister> oh ok
05:22:11 <Cale> banister: It's another word used for an arrow in a category.
05:22:27 <Zenol> I understand nothing about how it's working, typing, but (1,2) & _1 .- 42 & _2 .- "hello" looks awesome.
05:23:17 <FreeFull> srhb: You can calculate the maximum size for an interval in any range
05:23:41 <FreeFull> I think it's .~ and not .-
05:24:27 <Zenol> oh, yes, maybe. I'm watching a talk so it's a bit hard to read the screen ^^
05:24:50 <banister> Cale: i was reading ab it about arrows today, can you explain how arrows are generalizations of functions?
05:25:05 <banister> :P
05:25:08 <Cale> Well, which arrows? :)
05:25:21 <banister> Cale: http://www.haskell.org/arrows/
05:25:28 <Cale> Ah, in the sense of Control.Arrow
05:26:01 <FreeFull> Zenol: Basically,   _1 references the first element of a tuple, .~ is used to set something
05:26:03 <Cale> Well, if you replace each of the occurrences of a in the types given there with (->)
05:26:06 <srhb> FreeFull: Right, so given the total interval of [n,m] I need to generate x random intervals within it. Which seems to tell me the chance of the length of the random intervals needs to be higher at (m-n)/x than bigger/smaller. But their position still stumps me, and how to discard intervals in case I run out of "space" stumps me.
05:26:24 <Cale> then  arr :: (b -> c) -> (b -> c)  -- which is just the identity (so it's boring in this case)
05:26:42 <Cale> and  (>>>) :: (b -> c) -> (c -> d) -> (b -> d)  -- which is flipped function composition
05:27:37 <Cale> and  first :: (b -> c) -> ((b,d) -> (c,d)) -- which would be   first f (x,y) = (f x, y)
05:27:43 <FreeFull> srhb: Couldn't you just generate  n*2  numbers, get rid of any repeats, sort them, and group into pairs?
05:28:03 <srhb> FreeFull: Hmm, maybe I could. Let me think on that. Thanks.
05:28:11 <srhb> Wait, why n*2?
05:28:23 <FreeFull> Because each interval has a starting and ending point
05:28:35 <srhb> Within the range n,m - yes.
05:28:52 <Cale> banister: And all the other Arrow combinators are usually pretty straightforward to define in the case of functions
05:29:02 <banister> Cale: cool, thanks
05:29:03 <srhb> FreeFull: Ah but wait, doing so would give me overlaps.
05:29:11 <FreeFull> srhb: No, it wouldn't
05:29:18 <srhb> Oh, you mean group to closest neighbour
05:29:19 <FreeFull> Because you sort the numbers before pairing them
05:29:40 <FreeFull> And you don't allow duplicatrs
05:29:40 <taylorgb_> You could also take an iterative approach, and increment numbers using some probability to either skip the current number, start the range, extend the range, or complete the range
05:29:44 <FreeFull> duplicates*
05:29:58 <FreeFull> Although this wouldn't allow ranges to touch
05:30:00 <srhb> FreeFull: So all I would have to do is generate more numbers if I end up with duplicates.
05:30:06 <FreeFull> srhb: Yeah
05:30:35 <ignacio> srhb: are you working with real?
05:30:42 <srhb> ignacio: No, Int
05:30:45 <ignacio__> k
05:31:05 <srhb> FreeFull: I could allow touching intervals by simply not allowing more than _two_ duplicates per number.
05:31:17 <srhb> Not sure how that affects the overall probability though.
05:31:31 <ignacio> I was just thinking of duplicates
05:31:39 <srhb> taylorgb_: That seems like a lot of work. :D
05:32:37 <taylorgb_> could be
05:32:55 <taylorgb_> I would think it's a one-liner, but maybe it's more complicated in comparison to other approaches
05:33:40 <taylorgb_> I mean, in general isn't it just taking an infinite list, then randomly take or drop, then just convert the sublists to pairs by taking the first and last values
05:34:31 <srhb> taylorgb_: Randomly taking and dropping sounds horribly inefficient.
05:34:56 <srhb> And I'd have to scale it all down to the enclosing interval.
05:35:58 <FreeFull> With integers, you can avoid having duplicates by using smaller ranges for consecutive numbers and slotting them in
05:36:24 <ignacio> what's this for?
05:36:37 <srhb> Just a funny programming challenge.
05:43:35 <mkramer> I'm trying to work through RWH, and I have a code sample that doesn't parse. It's not the first time I've gotten this error, either. https://github.com/cyga/real-world-haskell/blob/master/ch07/toupper-imp.hs
05:43:45 <mkramer> toupper-imp.hs:15:9: parse error on input `if'
05:45:00 <Kinnison> Is lens 3.9.0.2 known broken?
05:45:05 <Kinnison> I get an annoying failure to build
05:46:06 <ignacio> mkramer: compiles for me
05:46:56 <ignacio> I'm using ghc 7.6.3 if it's any help
05:47:10 <Kinnison> Hmm, it compiles in isolation for me
05:47:22 <Kinnison> so it must be breaking on some other dependency being tweaked :-(
05:47:24 <tulcod> ignacio: ditto, compiles for me on 7.6.3
05:47:28 * Kinnison blows his cabal-dev away and tries again
05:48:11 <Kinnison> This is one reason I wish we had better API/ABI stuff on average.  It's a roulette every time I run cabal update as to whether the set of things I need will compile together in any known order
05:53:44 <taylorgb_> srhb: basic approach I was meaning http://pastebin.com/HLR8mRnq
05:53:53 <taylorgb_> But I can't really say how efficient it might be
05:54:05 <taylorgb_> your other approaches could indeed be faster or whatever metric you're wanting
05:54:32 <taylorgb_> and of course depends what kind of randomness you needs
05:54:34 <taylorgb_> -s
05:56:29 <srhb> taylorgb_: How would you fit all those inside an enclosing interval?
05:57:12 <mkramer> ignacio: I found the problem. Thanks for checking
05:58:14 * hackagebot xml-lens 0.1.4 - Lenses, traversals, prisms for xml-conduit  http://hackage.haskell.org/package/xml-lens-0.1.4 (FumiakiKinoshita)
05:59:14 <Zenol> ow, cntravariant do not compile with ghc 7.7 :(
05:59:41 <edwardk> Zenol: patch!
05:59:51 <edwardk> zenol what is the error?
05:59:56 <ignacio> mkramer: what was the problem?
06:00:06 <ignacio> it's odd that you got a parse error, syntax seems fine
06:00:16 <mkramer>   do ineof <- hIsEOF inh
06:00:16 <mkramer>         if ineof
06:00:16 <mkramer> I had an extra space there
06:00:20 <Zenol> Typeable1 do not exist, but there is a Data.Typeable.Typeable type.
06:00:26 <edwardk> ah
06:00:28 <edwardk> then its easy
06:00:49 <Zenol> yeh, it's probably just removing the 1.
06:01:22 <Zenol> But crawling throught .cabal/... do not make me happy :(
06:01:33 <edwardk> zenol: which module is failing?
06:01:59 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
06:01:59 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
06:02:07 <edwardk> because #if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ < 707  guards instance (Typeable1 f, Typeable1 g) => Typeable1 (Day f g) where
06:02:15 <edwardk> which is the only manual Typeable1 i see
06:02:28 <Zenol> in Day.hs line 61.
06:02:48 <Zenol> yap, this one.
06:03:16 <edwardk> ah
06:03:21 <edwardk> i need to rerelease
06:03:28 <edwardk> apparently the version on hackage has <= there =)
06:03:35 <edwardk> the one on github has <
06:03:37 <edwardk> one sec
06:03:37 <Zenol> yes
06:05:15 <edwardk> Zenol: patched, and pushed
06:06:09 <Zenol> installed  \ o /
06:06:41 <edwardk> lemme know if you have any other problems with it
06:06:44 <Zenol> now it's the turn of  generic-deriving :/
06:06:56 <edwardk> ah they broke that?
06:07:00 <edwardk> gah
06:07:11 <edwardk> i'm going to have to make my dependencies on that conditional again =(
06:07:26 <Zenol> hu?
06:07:30 <edwardk> bcause i can't keep having all my packages fail to build on top of 7.7 when i use it to get support for 7.2
06:07:57 <edwardk> i depend on generic-deriving for lens to widen support for ghc generics
06:08:10 <edwardk> but i don't use any of its features really
06:08:14 * hackagebot contravariant 0.4.3 - Contravariant functors  http://hackage.haskell.org/package/contravariant-0.4.3 (EdwardKmett)
06:08:40 <elliott> can we drop 7.2 yet?
06:08:57 <edwardk> but if i make the build dep conditional (and a couple of others) then we start to exceed the backtracking limit of cabal
06:09:02 <edwardk> elliott: probably actually
06:09:22 <edwardk> i think we deliberately dropped support for it and said 3.7 was the supported 7.0 and 7.2 version
06:09:39 <edwardk> so lens could drop the generic-deriving dep if you wanted to patch it out
06:10:16 <Kinnison> I appear to be on 7.4.1 so I'd be okay with that :-)
06:11:28 <elliott> edwardk: what about snap?
06:12:15 <aristid> Kinnison: if you can, upgrade to 7.6.3 :) it's the haskell platform included version
06:12:28 <edwardk> elliott: snap uses wide deps to allow 3.7 when they are on old platforms
06:12:51 <edwardk> that way they have a lens version that offers them the subset of features they use
06:12:54 <Kinnison> aristid: I run with what is packaged in Debian.  I'm on Wheezy
06:13:04 <Kinnison> aristid: I *may* upgrade to Jessie when things calm down a bit
06:13:48 <aristid> if i had to use debian, i'd probably compile my own ghc, but whatever floats your boat.
06:14:07 <Zenol> Actualy I 'should' be using ghc 7.6, but I needed a more recent one to compile haddock. And now installing any packet from hackage is a pain.
06:14:29 <elliott> hm, what were you compiling haddock for?
06:14:43 <Kinnison> aristid: If I can't work with the installed ghc etc, it is harder to write software to be packaged
06:14:59 <Zenol> ... I was thinking I could maybe write an other backend T.T
06:15:05 <aristid> Kinnison: when was wheezy released?
06:15:21 <aristid> june 2013, ok
06:15:57 <aristid> and 7.4.1 was released in february 2012. they did not even ship the bugfix release 7.4.2 instead.</pointless rant about debian>
06:17:27 <Kinnison> aristid: Oh, the wheezy freeze was, as usual, way way too long.
06:18:16 <Zenol> so many packages that won't compile. monadcatchio-transformers, vector, ...
06:18:31 <yesthisisuser> hmm. i wonder how the freebsd version of debian stands against stock debian
06:20:54 <Zenol> Control.Exception.Extensible's bloc/unblock was moved?
06:24:20 <supki> Zenol: more like dropped
06:24:52 <Zenol> they says to use "mask" insted.
06:25:05 <supki> sounds right
06:25:15 <Zenol> mask_ has the same type, but it doesn't means it does the same thing.
06:28:21 <Zenol> ... maybe I could just replace E.block by undefiend and pray for it to not be called...
06:29:37 <supki> you can replace monadcatchio-transformers with exceptions package
06:30:10 <Zenol> not sure that I would be able to do that on lens package...
06:30:20 <supki> oh
06:30:33 <supki> lens HEAD has already switched
06:30:37 <edwardk> Zenol: we're switching to 'exceptions' rather than MonadCatchIO in lens HEAD
06:30:55 <edwardk> but there are other 7.7 issues with lens HEAD
06:31:06 <edwardk> notably the Handler support has a more complicated Typeable issue
06:31:18 <edwardk> I have a workaround but I have yet to fully implement it
06:34:04 <Zenol> hum, issues that makes it not compile or just not works? Because if it's easier to checkout lens head and compile it with cabal, I'd better do that instead of trying to patch uglily  each dependency.
06:34:27 <edwardk> Zenol: currenty lens doesn't compile with ghc 7.7
06:34:39 <edwardk> we have issues tracking each discrepancy and are working through them
06:37:09 <Zenol> so, i'd better replace missing functions with error (all I wan't is just playing with basic functionalities).
06:56:19 <logicalguy> hi, how do I install haskell on scientific linux 6.4?  thanks.
06:57:19 <tulcod> logicalguy: it's probably more relevant to ask in the scientific linux community :)
06:58:03 <tulcod> logicalguy: but it appears to be yum-based, in which case you could try "yum install ghc"
06:58:04 <logicalguy> tulcod, thanks, I am doing so right now in #slforum, but I thought I'd ask here as well
06:58:48 <logicalguy> tulcod, yum search ghc yields no results, hence I am asking..
06:59:40 <yesthisisuser> on http://www.haskell.org/platform/linux.html it says "See also: justhub, for REHL, CentOS, Scientific Linux, and Fedora spport"
07:01:04 <logicalguy> yesthisisuser, is justhub.org opening for you?
07:01:40 <yesthisisuser> it seems to be down :/
07:02:15 <logicalguy> yeah, exactly, yesthisisuser
07:06:07 <yesthisisuser> maybe you could try building from source: http://deltadiaz.blogspot.nl/2013/04/haskell-platform-from-source-in-linux.html
07:07:10 <logicalguy> maybe, yesthisisuser, but then I might as well install in gentoo, which is my preferred distro...
07:07:29 <logicalguy> and installing from source always seems to be hit-and-miss :(
07:08:27 <yesthisisuser> yeah. i haven't tried.. i use debian so i installed from the packages
07:10:19 <logicalguy> cool
07:14:51 <gienah> logicalguy: a possibility is to install gentoo prefix on scientific linux
07:16:42 <logicalguy> oh, how do you do that, gienah
07:17:14 <gienah> logicalguy: like here: http://www.gentoo.org/proj/en/gentoo-alt/prefix/
07:19:16 <logicalguy> thanks, gienah, I am checking it out now
07:19:59 <ignacio> does the 'fail' function correspond to some part of mathematical Monads?
07:20:32 <tulcod> ignacio: error == bottom == 0=1, maybe?
07:20:51 <gienah> logicalguy: there are probably some gentoo pkgs that may not work in prefix, the haskell stuff should, you can ask us in #gentoo-haskell
07:21:18 <tulcod> ignacio: but no, mathematicians don't usually talk about strings
07:22:29 <tulcod> ignacio: additionally, i think most haskell devs wish it wasn't invented in the first place, so i think it can be ignored for most circumstances
07:22:44 <ignacio> interesting, why?
07:24:34 <banister_> ignacio: byorgey calls fail a horrible hack http://www.haskell.org/haskellwiki/Typeclassopedia#Utility_functions
07:26:45 <ignacio> I'll give that a read
07:26:50 <danilo2> Hi! I've got a funny problem in Haskell - Is it possible to define recursive typeclasses? I want to create something like: class A a b where test :: a -> A a b -> A a b
07:30:40 * Zenol give up
07:34:23 <Zenol> hums, seams I can do cabal install lens --with-compiler=ghc-7.6.3.
07:34:37 <elliott> but you won't be able to use it in ghc 7.7
07:35:05 <jozefg> Hello all
07:35:45 <ignacio> hi
07:36:51 <jozefg> What's going on here?
07:37:05 <Zenol> elliott> I'm unable to install vector in ghc-7.7. Don't think I'll be able to use many things with ghc-7.7.
07:37:46 <luite> Zenol: it's probably not hard to patch it or its dependencies so that it works
07:38:02 <luite> we've been using lens and vector for a while for ghcjs, which is based on ghc head :)
07:38:29 <Zenol> luite> Hum, it's the Typeable class implementation for Unboxed vectors that need to be rewrite
07:39:49 <Zenol> Since Typeable1 and Typeable2 was removed and the function isn't typeOfn but now typeRep.
07:40:27 <Zenol> I tried to patch it but it's not as reasy as renaming typeOfn by typeRep.
07:41:02 <jozefg> After 2 weeks of coq haskell feels weirdly dynamic :O
07:41:17 <Zenol> and I haven't the true doc of Data.Typeable/latest on hackkage.
07:43:20 <luite> Zenol: oh right, we have a patched version in the repositories
07:43:31 <jozefg> Zenol: Is there a list of GHC 7.7 breaking changes? I can't find one
07:43:48 <luite> Zenol: https://github.com/ghcjs/ghcjs.github.com/tree/master/packages/cabal-src
07:45:01 <Zenol> ohw, maybe I could tell to cabal to use this package for vector.  *relly don't know how to use cabal*
07:46:07 <luite> Zenol: you could extract it and cabal install ./package1 ./package2
07:46:20 <luite> Zenol: cabal-src also helps, by registering it in a local repository
07:47:50 <Zenol> ouf, lens installed with ghc 7.6. At least I can still use 7.6.
07:52:31 <Zenol> I tried cabal install vector-0.10.0.1.1, and I get Data/Vector/Generic.hs:197:24:, Module ‛Data.Typeable’ does not export ‛Typeable1’. Seems it's the same bug. Or you patched Typeable?
07:53:31 <luite> Zenol: hmm, i'm pretty sure it worked here :)
07:55:29 <Zenol> this package countain import Data.Typeable ( Typeable1, line 197 of Generic.hs. So you might be using another patch somewhere else. Or is it the Vector.10.9 version that I should use?
07:57:25 <Zenol> vector-0.10.9 compile.
08:02:08 <Zenol> luite> I'll stall your generic-deriving patch :)
08:03:30 <tulcod> Zenol: can you talk to people using : instead of > ? uniformity ftw
08:03:38 <tulcod> [/ocd]
08:03:53 <xilo> moar like just tab complete plz k thx?
08:06:16 <banister_> can someone give an example of an 'effectful' monad aside from IO?
08:06:26 <banister_> if you explain how Maybe is 'effectful' that would help :D
08:07:10 <elliott> banister_: you can think of "Nothing" as an action which short-circuits the "execution", in the context of the monad instance.
08:07:24 <tulcod> banister_: Maybe can be used to stop execution on error
08:07:30 <elliott> do { x <- foo; y <- bar; Nothing; z <- quux; return (x,y,z) } gives Nothing
08:07:44 <elliott> like an exception, or just like exiting the program.
08:08:34 <banister_> elliott: out of itnerest why does that feature make it 'effectful' ?
08:08:57 <tulcod> banister_: the Nothing in between affects everything that comes after it
08:09:01 <tulcod> namely, it's not executed
08:09:09 <elliott> that's up for you to decide. "effectful" doesn't mean anything. it is there to get you thinking about the intuition behind that word.
08:09:37 <tulcod> banister_: list comprehensions are basically just monads as well, for a somewhat different example
08:10:52 <klrr> morning
08:11:01 <banister_> tulcod: ah ok, can you explain what is meant by effectful in this context though
08:11:15 <tulcod> banister_: [ a+b | a <- [1,2], b <- [3,4] ] is equivalent to do { a <- [1,2]; b <- [3,4]; return a+b }
08:11:29 <elliott> return (a+b), but yes
08:12:14 <tulcod> oops yep thx
08:12:51 <tulcod> banister_: but it's hard to explain this in terms of side effects, because that's not what this represents
08:13:20 <tulcod> banister_: but you can see how i wrote only one computation (return (a+b)), which represents a whole bunch of additions
08:14:08 <banister_> tulcod: basically im trying to understand this statement: "We often speak of monadic values as “effectful computations”, but this is because some monads allow us to write code as if it has side effects, when in fact the monad is hiding the plumbing which allows these apparent side effects to be implemented in a functionally pure way."
08:14:12 <banister_> tulcod: in a context outside of IO
08:14:50 <tulcod> banister_: yeah. but basically this effectulness is largely about IO.
08:15:07 * elliott doesn't agree with tulcod, FWIW
08:15:09 <taylorgb_> Sounds like a hasty generalization
08:15:41 <tulcod> banister_: also, http://www.chrisstucchio.com/blog/2013/write_some_fucking_code.html
08:16:10 <tulcod> elliott: hm, well i read it differently :)
08:16:46 <elliott> well, I think State is quite obviously "effectful" in a way most people can appreciate.
08:16:55 <ignacio> tulcod: :D
08:17:01 <elliott> and you can read the list monad in terms of a well-known effect: the amb operator
08:17:23 <elliott> http://www.randomhacks.net/articles/2005/10/11/amb-operator
08:17:32 <banister_> elliott: is "Maybe" effectful in an obvious way too or do you have to stretch the metaphor too much in that case?
08:17:44 <elliott> > do { x <- [1, 2, 3]; y <- [4, 5, 6]; if (x*y /= 8) then [] else return (); return (x, y) }
08:17:45 <lambdabot>   [(2,4)]
08:17:48 <elliott> is the equivalent of the Ruby code there
08:17:55 <elliott> (and that if expression is just guard (x*y /= 8))
08:18:00 <scshunt> banister_: it all depends on how much metaphor you're willling to allow
08:18:12 <elliott> banister_: well, I bet you think of exceptions as side-effectful.
08:18:23 <elliott> Maybe is just the monad where you get exactly one exception.
08:18:25 <ignacio> elliott: can you have return () and return (a,b) in the same do ?
08:18:31 <elliott> (Either e is the monad where you have exceptions of type "e".)
08:18:44 <elliott> ignacio: sure. "return" doesn't mean anything like you might expect it to coming from an imperative language.
08:18:46 * monochrom allows no metaphor, except the tautological ones
08:19:04 <ignacio> elliott: but what type does the resulting expression have?
08:19:06 <tulcod> elliott: State, ST and IO are basically the same thing in my head... though maybe that's a bit naive
08:19:20 <scshunt> @t return
08:19:20 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
08:19:27 <scshunt> @type return
08:19:28 <lambdabot> Monad m => a -> m a
08:19:28 <ignacio> is it m () or m (a,b) ?
08:19:36 <scshunt> ignacio: whichever is used last
08:19:44 <int-e> tulcod: State is almost entirely different
08:19:53 <ignacio> ahh, you threw away the first return
08:20:00 <monochrom> fsvo "basically"
08:20:01 <scshunt> yeah
08:20:03 <elliott> tulcod: I suspect people use console IO a lot more than IORefs...
08:20:18 <tulcod> int-e: well yes of course it is, but they're all used for some sequence of computations where some functions depend on the effects of others
08:20:23 <scshunt> do { return (); return (a, b); } is equivalent to (return ()) >> (return (a, b))
08:20:56 <tulcod> elliott: what do you mean?
08:21:07 <elliott> tulcod: ah, you mean they're all monads? I agree :P
08:21:40 <tulcod> here, let's just say we agree, then :P
08:22:13 <int-e> tulcod: but ST and IO have no analogue of 'get' and 'put' :)
08:22:54 <int-e> (it would come in handy ... oldWorld <- get; launchMissiles; put oldWorld ...
08:22:55 <tulcod> int-e: just yesterday i was told about Acme.RealWorld ;)
08:24:04 <tulcod> about that - does Acme.RealWorld cause the RealWorld not to be compiled away?
08:24:11 <tulcod> s/compiled/optimized/
08:24:21 <ignacio> what are these hash symbols called? State# RealWorld -> (# State# RealWorld, a #)
08:24:38 <ignacio> or how do I parse them?
08:24:39 <monochrom> they are called hash. I'm serious.
08:24:52 <ignacio> ok, where can I read about them in a haskell context?
08:24:58 <tulcod> "haskell hash"?
08:25:08 <monochrom> GHC developer wiki
08:25:23 <Clint> ignacio: http://www.haskell.org/haskellwiki/Unboxed
08:25:24 <int-e> ignacio: ghc has an extension that makes them valid parts of identifiers. they're still just hashes. (magic hashes, according to the extension name)
08:25:29 <monochrom> or GHC source code
08:26:02 <ignacio> thanks
08:26:22 <ignacio> even searching "haskell hash -table -hashtable" yielded results on hash tables
08:26:38 <ignacio> might be DDG's fault
08:28:58 <wavewave_> hi
08:31:29 <ignacio> hi
08:31:45 <wavewave_> hi
08:35:07 <allsystemsarego> why are monad tutorials an epidemic phenomaenon, but e.g. arrow tutorials aren't? what's so special about monads?
08:37:20 <geekosaur> monads are mandatory, arrows are avoidable? :p
08:37:22 <dmwit> :complete looks neat
08:37:40 <wavewave_> allsystemsarego: understanding of arrows in haskell community seems to change..
08:37:52 <tulcod> allsystemsarego: monads are good enough for most applications, right?
08:38:10 <tulcod> also, because math
08:40:13 <wavewave_> maybe when comonad is more prevailing, then... resurrect of arrow?
08:41:05 <wavewave_> looks to me that arrow and comonad shared a certain design space.
08:57:50 <alexander__b> dmwit: I've been mostly without net and time to work on my calculator, but now I have a little time and I don't really understand what your f does.
08:59:19 <alexander__b> dmwit: I guess if I hunt through learn you a haskell to remind myself what liftM does, I might be able to piece things together but uh it's preferable to just get an explanation. :-P
08:59:31 <dmwit> You'll have to jog my memory.
08:59:32 <dmwit> ?hpaste
08:59:33 <lambdabot> Haskell pastebin: http://hpaste.org/
08:59:35 <dmwit> oops
08:59:37 <dmwit> ?where hpaste
08:59:37 <lambdabot> http://lpaste.net/new/haskell
09:00:07 <alexander__b> dmwit: http://lpaste.net/91078
09:00:39 <dmwit> um
09:00:51 <dmwit> The only liftM in the definition of "f" was copied from your previous iteration of the code. =)
09:00:54 <alexander__b> dmwit: I also do not understand why everything everywhere is returning Maybe Somethings, nor how I could change this to return a String with the correct answer -- or a string/error with the operator that made it choke.
09:01:04 <dmwit> Anyway, it applies a function to the value contained in a Just (and does nothing to Nothing).
09:01:23 <alexander__b> dmwit: oh right, you weren't the one who suggested liftM. sorry. :-P
09:01:40 <erisco> what does "some" and "many" do from applicative? what is a use of them?
09:02:10 <dmwit> Everything is returning Maybe's because you use Just/Nothing in readMaybe and because we use Nothing in binOp/unOp.
09:02:20 <dmwit> This could be swapped out for Either by using return and fail instead of Just and Nothing.
09:02:36 <dmwit> (Or a similarly class-polymorphic alternative to fail if you're feeling mathematical.)
09:02:43 <alexander__b> dmwit: I was considering using Either, though I'm not certain of how to rewrite everything.
09:03:05 <Cale> erisco: Their names make the most sense in terms of parsers. 'some p' will match one or more copies of the parser p, while 'many p' will match zero or more
09:03:06 <dmwit> erisco: They mean different things for each instance of Alternative.
09:03:25 <erisco> Cale, I get that
09:03:33 <erisco> I guess what I mean is ... how do you make them not just infinitely recurse?
09:03:34 <alexander__b> dmwit: I would like to print the result or an error like "unrecognised operator 'lulz'".
09:03:39 <erisco> I never get a value back
09:03:47 <dmwit> alexander__b: Right. So you should use return and fail instead of Nothing and Just.
09:03:50 <dmwit> uh
09:03:54 <elliott> erisco: they only really work with certain applicatives.
09:03:54 <Cale> erisco: Which Applicative instance are you using?
09:03:55 <dmwit> return and fail instead of Just and Nothing, of course.
09:04:13 <erisco> Cale, is there any applicative instance that works?
09:04:23 <erisco> > some (Just 5)
09:04:26 <alexander__b> dmwit: OK G2G but I'll try it when I get back
09:04:27 <lambdabot>   mueval-core: Time limit exceeded
09:04:27 <Cale> Parsec should
09:04:33 <dmwit> alexander__b: g'luck
09:05:05 <Cale> as will ReadP
09:06:27 <erisco> mm, how would you make them terminate?
09:06:37 <erisco> I mean, at least get one item back from the list
09:07:27 <Cale> readP_to_S (some (char 'a')) "aaabc"
09:07:27 <Cale> [("a","aabc"),("aa","abc"),("aaa","bc")]
09:07:38 <erisco> > fromMaybe (Just 5)
09:07:39 <lambdabot>   <Maybe (Maybe Integer) -> Maybe Integer>
09:08:02 <Cale> On the Maybe and [] instances, some and many will just loop
09:09:10 <erisco> Cale, readP_to_S is unconsing items from the list then?
09:09:28 <erisco> > some (char 'a')
09:09:29 <lambdabot>   Couldn't match expected type `f0 a0'
09:09:29 <lambdabot>              with actual type `Text.Pr...
09:09:48 <erisco> I'm a tad confused
09:10:09 <Cale> erisco: readP_to_S is how you run a ReadP parser
09:10:23 <Cale> You give it a parser of type  ReadP t
09:10:34 <Cale> and it gives you a function  String -> [(t,String)]
09:11:01 <Cale> which takes some input, and returns a list of possible parses for that input (each paired with whatever part of the string was left over when the parser finished)
09:11:11 <erisco> > :t (some (char 'a'))
09:11:12 <lambdabot>   <hint>:1:1: parse error on input `:'
09:11:18 <erisco> :t (some (char 'a'))
09:11:18 <lambdabot>     Couldn't match expected type `f0 a0' with actual type `Doc'
09:11:18 <lambdabot>     In the return type of a call of `char'
09:11:18 <lambdabot>     In the first argument of `some', namely `(char 'a')'
09:11:23 <Cale> ReadP isn't in scope in lambdabot apparently
09:11:33 <elliott> it overlaps with the Doc stuff at least
09:11:41 <Cale> It's in Text.ParserCombinators.ReadP
09:11:44 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadP.html
09:13:16 <erisco> Cale, is this similar to    readP_to_S (pure $ repeat 'a') "aaabc" ?
09:13:37 <Cale> nope
09:14:10 <Cale> some (char 'a') will be a parser which eats one or more 'a's from the start of the input
09:14:25 <erisco> oh, I was confusing 'char' with 'Char'
09:14:26 <Cale> e.g. it'll be like the regular expression aa*
09:14:42 <erisco> so  char :: ReadP Char
09:14:54 <Cale> char :: Char -> ReadP Char
09:15:01 <erisco> well okay yeah
09:15:21 <erisco> (pure 'a') :: ReadP Char   maybe
09:15:26 <erisco> depending on pure
09:15:32 <Cale> Well, yes
09:15:41 <Cale> But that parser won't eat any of the input string
09:15:46 <solrize> simon m's book is up on oreilly, iirc he said it was also going to be on the web but i don't see it now?
09:16:22 <Cale> e.g.  readP_to_S (pure 'a') "aaabc" = [('a',"aaabc")]
09:17:05 <erisco> so ... now that we have ReadP 'a', speaking, 'some' looks like it would do ReadP ('a':'a':'a' ...)
09:17:06 <roconnor> is it possible to eta-contract type synonym declarations with any extension?
09:17:44 <Cale> solrize: http://ofps.oreilly.com/titles/9781449335946/index.html
09:17:59 <solrize> nice thanks
09:18:02 <dmwit> The ReadP constructor does not take a String as argument.
09:18:10 <dmwit> So ReadP ('a':'a':'a':...) doesn't make a lot of sense.
09:18:33 <erisco> I meant ReadP as a type, sorry ... what I meant by "speaking"
09:18:39 <erisco> I don't know what the value constructor names are
09:19:07 <klrr> im starting to to learn how pipes (or rather, proxies) work, they seem really useful and is interesting to learn about :)
09:19:18 <erisco> goes from   'a' :: ReadP Char  to  ('a':'a':'a' ...) :: ReadP String
09:19:36 <solrize> cale can you put that link on reddit if you have an account there?
09:20:08 <erisco> so I am a bit confused why   show (some (Just 5))  doesn't print    Just [5,5,5,5,5,5,5,5,5,5,5,5,5,5 ....
09:20:31 <solrize> it also looks like that's a draft
09:20:54 <dmwit> ?src some
09:20:54 <lambdabot> some v = some_v
09:20:54 <lambdabot>   where many_v = some_v <|> pure []
09:20:54 <lambdabot>         some_v = (:) <$> v <*> many_v
09:21:21 <Cale> Or, deobfuscating slightly, we could just write:
09:21:32 <Cale> some v = (:) <$> v <*> many v
09:21:40 <Cale> many v = some v <|> pure []
09:21:52 <dmwit> erisco: It's building up the [5,5,5,...] in memory, but never reaches a point where it knows it's going to put a Just on front, so it can't start printing.
09:21:55 <erisco> yeah, I'm staring at those definitions on http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
09:22:40 <erisco> dmwit, ah, I understand ... any <*> could receive a Nothing, and so it is undecidable if the result is Just something or Nothing
09:22:47 <dmwit> right
09:22:49 <Cale> So, given a parser p, some p will be the parser which runs p, and then runs many p, and conses the results together
09:23:36 <Cale> and many p will be the parser which either parses as some p does, or if that fails, produces an empty list
09:23:52 <erisco> ?src fromJust
09:23:53 <lambdabot> fromJust Nothing  = undefined
09:23:53 <lambdabot> fromJust (Just x) = x
09:24:05 <erisco> let fromJust2 ~(Just a) = a
09:24:08 <erisco> > let fromJust2 ~(Just a) = a
09:24:09 <lambdabot>   not an expression: `let fromJust2 ~(Just a) = a'
09:24:12 <elliott> that's the same as fromJust
09:24:25 <erisco> elliott, ghc treats that the same?
09:24:30 <elliott> since it desugars to fromJust m = let x = case m of Nothing -> error "oops"; Just a -> a in x
09:24:36 <Cale> In do-notation, some v = do x <- v; xs <- many v; return (x:xs)
09:24:39 <elliott> which simplifies to fromJust m = case m of Nothing -> error "oops"; Just a -> a
09:24:45 <erisco> fromJust (some (Just 5))
09:24:49 <elliott> which then simplifies to those clauses for fromJust.
09:24:49 <erisco> > fromJust (some (Just 5))
09:24:53 <lambdabot>   mueval-core: Time limit exceeded
09:24:57 <erisco> hrm
09:25:08 <erisco> I don't believe :P
09:25:48 <Cale> and  many v = (do x <- v; xs <- many v; return (x:xs)) <|> return []
09:25:51 <erisco> idea was to help the compiler along and assume it was Just
09:26:15 <erisco> but I suppose it still needs to get the result to put into fromJust
09:27:54 <Cale> Since we can get rid of the mutual recursion in the case of many, you might want to try to understand that first
09:29:00 <erisco> dmwit pointed out why no result can be known already, and I am comfortable with that
09:29:09 <Cale> I've been up a long time and I should sleep.
09:29:30 <dmwit> > let some' v = (:) <$> v <*> Just (fromJust (many v)); many' v = some v <|> pure [] in some' (Just 5)
09:29:32 <Cale> If you want, at some point, remind me to explain how to construct a small parser library :)
09:29:34 <lambdabot>   mueval-core: Time limit exceeded
09:29:46 <Cale> This stuff makes more sense once you have that context.
09:29:47 <dmwit> oops
09:29:54 <dmwit> > let some' v = (:) <$> v <*> Just (fromJust (many' v)); many' v = some' v <|> pure [] in some' (Just 5)
09:29:55 <lambdabot>   Just [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
09:29:56 <erisco> so perhaps any Applicative that is not an Alternative will have a printable "some" and "many"
09:30:28 <erisco> Cale, I'm working on a small parsing library but I am well underway. thanks anyways :)
09:30:37 <dmwit> > let some' v = (:) <$> v <*> Just (fromJust (many' v)); many' v = some' v <|> pure [] in some' Nothing
09:30:38 <lambdabot>   Nothing
09:30:44 <dmwit> erisco: What do you think of that? =)
09:30:53 <erisco> black magic? I'm still reading
09:31:14 <erisco> dmwit, ah, I see
09:31:22 <Cale> erisco: Well, the example I'd use is fairly impractical, we'd use  newtype Parser a = P (String -> [(String, a)])
09:31:24 <dmwit> Yes, it's black magic.
09:31:32 <erisco> dmwit, you are explicitly forcing each arg to <*> to be Just
09:31:47 <dmwit> Well, I'm forcing the *second* argument to be Just.
09:31:56 <dmwit> Because the two arguments are either both Just or both Nothing.
09:32:05 <dmwit> (we as programmers happen to know this)
09:32:34 <dmwit> So if the first argument is Nothing, it's okay to force the second one to be Just -- we'll ignore the incorrect forcing.
09:32:44 <erisco> mm right, so when we invoke "some" or "just", we can decern from the argument alone if we will get a Just or Nothing
09:33:19 <dmwit> But really this is all just cheating. It looks like we're using lots of Applicative- and Alternative-polymorphic stuff, but really everything is just Maybe's everywhere and we're using specialized knowledge about that type.
09:33:46 <erisco> well, yes, but it is still insightful to see how such an approach would have to be carried out
09:34:45 <erisco> so any Applicative type which only has one value constructor won't fall into this problem, yeah?
09:35:14 <dmwit> hm
09:35:15 <erisco> any such types lying around?
09:35:17 <dmwit> That's not clear to me.
09:35:49 <dmwit> For example, any Applicative that's just a newtype would only have one constructor, but would fall into this problem if the thing it was wrapping did.
09:36:10 <dmwit> I think the only real characterization is "any type which has this problem has this problem".
09:38:02 <erisco> oh ...
09:38:11 <erisco> some and many are from Alternative not Applicative
09:38:19 <dmwit> yes
09:38:25 <erisco> well then my point is moot :P
09:39:04 <erisco> you can't have an alternative type which doesn't have an empty value constructor
09:39:45 <erisco> or are there such legitimate definitions? your empty definition would be rather strange, no?
09:40:24 <erisco> hmmm lemme try ... maybe just add in a Bool for "is empty"
09:41:04 <dmwit> I dunno. I suppose data Unit a = Unit is Alternative, and only has one constructor.
09:41:33 <erisco> how does it define pure?
09:41:41 <dmwit> pure _ = Unit
09:41:55 <erisco> oh... durr
09:42:19 <dmwit> ?let data Unit a = Unit deriving (Eq, Ord, Show, Read)
09:42:20 <lambdabot>  Defined.
09:42:34 <dmwit> ?let instance Functor Unit where fmap f _ = Unit
09:42:35 <lambdabot>  Defined.
09:42:52 <erisco> some Unit
09:42:55 <dmwit> ?let instance Applicative Unit where pure _ = Unit; _ <*> _ = Unit
09:42:55 <lambdabot>  Defined.
09:42:56 <erisco> > some Unit
09:42:56 <lambdabot>   No instance for (Control.Applicative.Alternative L.Unit)
09:42:57 <lambdabot>    arising from a ...
09:43:11 <roconnor> Constant m is Applicative when m is a Monoid.
09:43:13 <dmwit> ?let instance Alternative Unit where empty = Unit; _ <|> _ = Unit
09:43:14 <lambdabot>  Defined.
09:43:17 <erisco> > some Unit
09:43:21 <lambdabot>   mueval-core: Time limit exceeded
09:43:25 <erisco> hrm
09:43:36 <roconnor> Constant m is Alternative when m is a dioid.
09:43:37 <Gracenotes> lamby is particular about let'd code
09:43:59 <dmwit> ?src some
09:43:59 <lambdabot> some v = some_v
09:43:59 <lambdabot>   where many_v = some_v <|> pure []
09:43:59 <lambdabot>         some_v = (:) <$> v <*> many_v
09:44:03 <erisco> that seems a bit perplexing
09:44:40 <roconnor> many is kinda like a Kleene Star operation
09:44:42 <dmwit> Yes, it does.
09:44:54 <roconnor> some is kinda like a Kleene Plus operation
09:44:56 <dmwit> > some Unit -- maybe just a timing fluke?
09:45:01 <lambdabot>   mueval-core: Time limit exceeded
09:45:36 <roconnor> Arguably many and some should be in their own type class extending Alternative
09:46:07 <dmwit> ghci doesn't agree with lambdabot here.
09:46:33 <dmwit> Oh, it is just a fluke.
09:46:36 <dmwit> > some Unit
09:46:39 <lambdabot>   Unit
09:46:51 <Zenol> hum, is it possible to generate haskell code while compiling. I means, create a haskell macro, written in haskell.
09:47:02 <dmwit> Zenol: Yes, this is what Template Haskell does.
09:47:37 <Zenol> "compile time meta programming" \o/, thanks :)
09:48:14 <Gracenotes> metaprogramming is also accomplished by combinators, sometimes
09:48:26 <Gracenotes> (at least compared to other languages)
09:49:14 <Gracenotes> Zenol: you don't have any other options than TH, by any chance? :)
09:51:42 <Zenol> Gracenotes> I'm just curious on what you can do. So that later I can hask myself how can I do while solving things.
10:20:26 <NemesisD> guys, very important issue: i need a steampunk name with a haskell theme to it
10:20:57 <NemesisD> something with the rank of Ensign I'm thinking
10:22:41 <taylorgb_> What does that even mean?
10:23:26 <Clint> it means that "very important" was sarcasm
10:23:29 * hackagebot geek 1.0.0.7 - Geek blog engine  http://hackage.haskell.org/package/geek-1.0.0.7 (JinjingWang)
10:23:29 <mcstar> Typed Rails
10:23:39 <NemesisD> yeah and that i should probably be asking in #haskell-offtopic
10:25:37 <k0ral_> while working on my project, I wrote a key bindings manager using a tree structure; do you think it might be worth exporting it as a standalone library ?
10:25:56 <erisco> how do you check the fixity -- is it called that? -- of an infix operator and how do you specify the fixity of your own operator?
10:26:32 <erisco> k0ral_, iunno, what cool functions do you have? :)
10:27:45 <k0ral_> nothing fancy, I guess it would just save people the trouble of implementing it; at each key stroke, I move one step further in my key bindings tree until I reach a leaf, in which case I trigger the callback
10:27:54 <sshack> Is there an accepted standard in the haskell community regarding database schema migrations?
10:27:57 <erisco> ah okay :info in ghci tells you that ... how to set then
10:28:42 <erisco> k0ral_, ah so it is for multikey commands?
10:28:59 <k0ral_> erisco: infixl 1 `op`
10:29:06 <k0ral_> erisco: infixr 1 `op`
10:29:11 <klrr> is there a way to add ghc flags in the cabal file for your project?
10:29:32 <supki> klrr: ghc-options:
10:29:45 <klrr> supki: thanks
10:30:02 <klrr> supki: in exectubale block or in the main block?
10:30:13 <k0ral_> erisco: and yes, it aims at supporting multi-key commands
10:30:19 <k0ral_> it also supports modes
10:30:24 <k0ral_> as in vi
10:30:40 <erisco> k0ral_, ah thanks simpler than I thought
10:31:06 <taylorgb_> No harm in preparing it for upload
10:31:08 <supki> klrr: in executable/library blocks
10:31:10 <klrr> is it -Wall or --Wall?
10:31:12 <klrr> supki: okey
10:31:34 <klrr> Wall==Warning all? also is it "--Wall", or "-Wall", or just "Wall"?
10:31:47 <erisco> k0ral_, sounds interesting. if you have time, why not. for games, perhaps it would also be useful, since there are many modes to be in
10:32:46 <roconnor> @pl \st -> StateT $ unwrapMonad . getCompose . l (Compose . WrapMonad . runStateT st . runIdentity) . Identity
10:32:49 <lambdabot> (StateT $) . (unwrapMonad .) . (getCompose .) . flip ((.) . l . (Compose .) . (WrapMonad .) . flip ((.) . runStateT) runIdentity) Identity
10:32:49 <lambdabot> optimization suspended, use @pl-resume to continue.
10:32:57 <roconnor> @pl-resume
10:33:03 <lambdabot> (StateT $) . (unwrapMonad .) . (getCompose .) . flip ((.) . l . (Compose .) . (WrapMonad .) . flip ((.) . runStateT) runIdentity) Identity
10:33:03 <lambdabot> optimization suspended, use @pl-resume to continue.
10:33:04 <singpolyma> Even when I run ghci -i. I cannot seem to import modules in the current directory.  Is there a way around that? (other than :l)
10:38:33 <klrr> why does Proxy functions in the pipe tutorial take a () as input? http://hackage.haskell.org/packages/archive/pipes/3.2.0/doc/html/Control-Proxy-Tutorial.html
10:41:24 <jmcarthur> klrr: because Tekmo is a little crazy about categories and insists on programming with kleisli categories a lot instead of directly with monads
10:41:25 <tulcod> klrr: maybe it's the specific version of something more generic?
10:41:58 <jmcarthur> klrr: but in his defense, it is nice to be able to just use >-> instead of having to worry about whether to use >-> or >>-
10:42:57 <klrr> jmcarthur: okey, what is kleislie category, also, what do you mean with having to worry about the use or >-> or >>- ? tulcod: i dont really understand what you mean, can you explain?
10:43:37 <jmcarthur> klrr: when everything takes an argument you don't have to worry about choosing between (>>=) vs. (>=>), (>>-) vs. (>->), etc.
10:43:49 <jmcarthur> but i want to make sure it'
10:43:51 <jmcarthur> oops
10:44:16 <klrr> jmcarthur: i dont really understand, you never give the functions an argument anyway so what is the point?
10:44:22 <jmcarthur> but i want to make sure it's clear that i don't necessarily endorse coding in this style just to avoid that choice, just that Tekmo might
10:44:36 <jmcarthur> klrr: (>->) and (>=>) do
10:44:42 <jmcarthur> give the function an argument, that is
10:45:49 <jmcarthur> klrr: when everything is a function then everything composes with (.) or (>=>) or (>->) or other associative operations. associativity is nice. that's the gist of Tekmo's obsession as far as i can tell
10:46:29 <klrr> but isnt function data?
10:46:31 <klrr> functions*
10:46:32 <jmcarthur> yes
10:46:33 <chrisdone> ahoy
10:46:37 <klrr> chrisdone: morning
10:46:45 <chrisdone> good evening ;p
10:46:57 <jmcarthur> functions are values, which is precisely why composition is such a reasonable thing to do
10:47:20 <taylorgb_> @where (>->)
10:47:20 <lambdabot> I know nothing about (>->).
10:47:29 <klrr> i still dont get it, is it so that everything gets inputed in right order?
10:47:31 <jmcarthur> taylorgb_: it's in the pipes library
10:47:35 <taylorgb_> ah
10:47:38 <jmcarthur> klrr: no. it's just a stylistic thing
10:47:38 <taylorgb_> thanks
10:47:38 <klrr> requested and sent in right order*?
10:48:18 <klrr> jmcarthur: why would a style force you to put uneccessary arguemensts that you never use? why does he force the reader of the tutorial to understand his style, i wanna understand his library
10:48:30 * hackagebot geek 1.0.0.8 - Geek blog engine  http://hackage.haskell.org/package/geek-1.0.0.8 (JinjingWang)
10:48:44 <jmcarthur> klrr: the style is intended to encourage you to use categories, since they are easy to reason about
10:49:24 <jmcarthur> klrr: as for why he forces you to use them... it's just his belief that it's the right thing to do. i can't really speak for him though.
10:49:48 <klrr> jmcarthur: categories? no you lost me, what is functinos arguments connection to categories? what is categories?
10:49:54 <jmcarthur> s/speak for/represent/
10:50:44 <jmcarthur> klrr: a category is just a collection of objects with composable arrows between them and a few nice properties like identity arrows and that composition of arrows is associative. haskell functions are an example of a category
10:51:18 <klrr> jmcarthur: arrows as in arrow notation like proc?
10:51:18 <jmcarthur> klrr: such that the objects are haskell types and the arrows are the (->)s you would put between types to represent the type of a function
10:51:34 <thoughtpolice> klrr: categories are easy to reason about, because they come equipped with a nice associative operator for composition. in this case, you're using (>->) to compose things.
10:51:38 <klrr> what do you mean with arrows, do you mean the library or tsomething else?
10:51:42 <jmcarthur> klrr: Arrow is related (Category is a superclass of Arrow), but categories are much more general
10:51:52 <thoughtpolice> in the case of pipes, you're not always using () for an argument. a 'Proxy' in the current lingo can take a few forms
10:51:57 <jmcarthur> klrr: i mean an arrow. it's an abstract thing. it just makes one object point to another
10:52:25 <klrr> jmcarthur: yes but does you mean arrow as in http://www.haskell.org/arrows/ , or do you mean (>>=), (<-) etc.?
10:52:42 <jmcarthur> klrr: i mean it's not necessarily any of those things, or it could be
10:52:49 <jmcarthur> klrr: it's more general than that
10:53:08 <klrr> i dont understand anything, an arrow in my head is a sign for what direction to take
10:53:16 <jmcarthur> klrr: (>>=) is not an arrow. i don't know what you mean by (<-). if you mean from do notation, no, that's not an arrow either
10:53:21 <jmcarthur> klrr: that's exactly right
10:53:37 <jmcarthur> klrr: it's a path from one object to another in a category
10:53:55 <jmcarthur> klrr: for a specific example, a haskell function is a path from one haskell type to another haskell type
10:54:07 <klrr> i still dont understand the connection of having useless extra stuff in function arguments has to do with it all?, also, how can it even be correct syntax
10:54:28 <klrr> > (\x -> 2) + (\y -> 3)
10:54:29 <lambdabot>   No instance for (Data.Typeable.Internal.Typeable a0)
10:54:29 <lambdabot>    arising from a use ...
10:54:31 <klrr> error
10:54:44 <thoughtpolice> () is not *always* the argument type though, it just is in some specific cases.
10:54:58 <klrr> but when you do (fooProducer >-> fooConsumer) then you dont get error?
10:55:17 <crdueck> klrr: why do you think you can use (+) to "add" functions? the categorical composition operator for functions is (.)
10:55:24 <jmcarthur> klrr: taking an argument forces it to be a function, which means you can use composition
10:55:29 <jmcarthur> klrr: without the argument there is no arrow
10:55:53 <klrr> jmcarthur: i dont get it, you said functions are values so it shouldnt matter
10:56:13 <klrr> jmcarthur: and you never give it an argument so why pattern match on it?
10:56:28 <jmcarthur> klrr: functions are composable values
10:56:31 <klrr> where does the () get into the functions and where is it used?
10:56:40 <klrr> if it's not used, why is it there?
10:56:41 <jmcarthur> klrr: it's not used
10:56:49 <jmcarthur> you are repeating yourself now
10:56:53 <klrr> yes
10:56:56 <klrr> since i dont understand it
10:57:07 <klrr> i still have to have a reason to have () to have it in the code
10:57:11 <jmcarthur> i think you are looking for something deep that isn't really there
10:57:52 <erisco> is there a type in haskell that wraps a list and keeps track of whether it is finite or infinite?
10:58:02 <klrr> jmcarthur: no im looking for a reason why to even have () in the argument, you said something about arrows, cathegories, and keislie, which i know nothing about
10:58:08 <erisco> I have come to realize that the type I introduced does just that
10:58:19 <jmcarthur> klrr: i gave the reason. if you don't think it sounds like a good reason then i agree
10:58:36 <thoughtpolice> klrr: you should probably just read the tutorial, this point is explained in the bidirectionality section
10:58:54 <thoughtpolice> like i said, () is used in some *specific* cases of Proxy, but not all.
10:58:57 <klrr> jmcarthur: no, i dont arguement against your explaination, i simply dont understand it :s
10:59:20 <jfischoff> Is there consensus on what type Control.Arrow is categorically?
10:59:28 <thoughtpolice> there are generalized versions where () isn't needed, because you can also send arguments upstream if you need to. if you don't, then you just use ()
10:59:29 <jfischoff> err s/type/
10:59:49 <erisco> actually it isn't that simple... I am drawing a distinction between infinite and self-referential
10:59:56 <jfischoff> I think Cale explained it too me once but I forgot :p
11:00:58 <taylorgb_> Are arrows in the Control.Arrow sense not also arrows in the categorical sense?
11:01:30 <jfischoff> yes they are
11:01:41 <jmcarthur> taylorgb_: Arrow in fact requires that it also be an instance of Category
11:02:05 <taylorgb_> Oh good, was thinking I was living a lie
11:02:29 <jfischoff> they are also monodial
11:02:44 <jfischoff> but I forget what else
11:03:22 --- mode: ChanServ set +o shachaf
11:03:35 <erisco> does "self-referential" also imply cyclic dependencies or is it strictly just ... self-referential
11:03:53 --- mode: shachaf set +b *!*klrr@88.129.*
11:03:54 <jmcarthur> erisco: is there a difference?
11:03:57 --- kick: klrr was kicked by shachaf (ban evasion)
11:04:12 <erisco> let a = b ; let b = a    versus let a = a
11:04:30 <jmcarthur> i don't see why those are worth distinguishing
11:04:53 --- mode: shachaf set -o shachaf
11:05:08 <jmcarthur> what about   let (a, b) = (b, a)  ?
11:05:43 <erisco> let a = 1 + 2*b ;  let b = 3 - 5*a    versus let a = 1 + 2*(3 - 5*a)
11:05:50 <erisco> to give something less trivial looking
11:06:07 <jmcarthur> what about   let (a, b) = (1 + 2*b, 3 - 5*a)  ?
11:06:24 <erisco> I don't get why you're saying that
11:06:56 <jmcarthur> i don't see where it fits into your dichotomy
11:07:02 <erisco> are you pointing out that if you put them in a tuple it is more evident that "self-referential" is an applicable term?
11:07:07 <jmcarthur> because i don't even see what the dichotomy is
11:07:26 <jmcarthur> all i see is direct recursion vs. mutual recursion
11:07:27 <erisco> if I give you   let a = 3 - 4*b
11:07:47 <erisco> and don't tell you b, is 'a' self-referential? it is undecidable.
11:08:04 <jmcarthur> b is just a free variable
11:08:24 <erisco> so 'a' is not self-referential?
11:08:27 <jmcarthur> if an expression is closed then this question doesn't come up
11:08:35 <jmcarthur> if it's open then there is no answer
11:09:04 <erisco> hm
11:11:43 <erisco> something feels a bit loosey goosey in my code
11:12:42 <osa1> is there a safe version of (!!) in base?
11:12:46 <erisco> a b = b <*> a
11:13:33 <erisco> a b = A <$> b <*> a
11:13:50 <shachaf> osa1: Alas, no.
11:14:05 <elliott> there is listToMaybe . drop i
11:14:20 <erisco> for my Applicative, I can make that work (as in, it won't hang), but <*> has to know that it's right arg is calling back onto itself
11:14:52 <erisco> so I introduced a second value constructor in my Applicative type so the programmer can indicate this situation
11:15:08 <applicative> funny, what was klrr's crime, besides really lame English
11:15:22 <erisco> I'm just having a hard time describing in English what each value constructor means
11:17:43 <erisco> but I suppose self-referential and non-self-referential describe it adequately
11:19:55 <jmcarthur> applicative: ban evasion
11:20:03 <jmcarthur> applicative: he's been a pretty epic troll recently overall
11:20:10 <applicative> oh really
11:20:36 <applicative> he seemed actually to be learning things too, if i'm thinking of the right guy
11:20:46 <applicative> but i see
11:20:47 <jmcarthur> i agree. he seems inconsistent
11:22:10 <applicative> is the question 'what does --split-objs do?', too complicated to be asked?
11:22:22 <applicative> it certainly takes longer, whatever it is
11:22:56 <jmcarthur> applicative: it splits definitions out into separate object files instead of just one per module so that you don't have to link everything even if you don't use it
11:23:45 <applicative> ah.  I was wondering how it would effect executable size, because of some reddit blather
11:23:55 <applicative> I think I sort of understood correctly then
11:24:15 <jmcarthur> it's kind of like a hacky dead code elimination
11:24:18 <applicative> anyway, the final pandoc executable is just as gigantic, it doesn't matter for that
11:24:35 <applicative> but maybe i would have needed other incantations
11:24:47 <jmcarthur> it helps if all deps are built with it, too
11:24:56 <applicative> that was just occurring to me, yes
11:25:12 <applicative> i refuse to attempt that experiment...
11:25:27 <jmcarthur> i just set it in my cabal config so i don't have to think about it
11:25:39 <applicative> oh you do it?
11:25:52 <jmcarthur> i got used to it, so it doesn't even feel slow anymore ;P
11:26:01 <applicative> what are the plusses and minuses, i see that it's slower
11:26:07 <applicative> compilation is slower I mean
11:26:28 <jmcarthur> the pluses and minuses are basically just what we already said and nothing else
11:26:35 <jmcarthur> slower compilation, smaller executables
11:26:47 <applicative> i see, executable size
11:26:55 <jmcarthur> but i wouldn't say that my choice to use it by default is all that important in the long run
11:27:25 <applicative> wait maybe i'll just make a little sandbox and try it from the ground up.
11:28:23 <applicative> I can't say that the size of pandoc has ever caused me the least worry
11:28:28 <jmcarthur> nor i
11:29:39 <applicative> does the pile of little bits that --split-obj make end up being huge? I mean if I also need the library
11:30:01 <jmcarthur> i don't know. it probably takes up significantly more space, yes
11:37:57 <ohbadiah> Hi there. I'm having trouble thinking how to model multiple implementations of the same type signature.
11:38:03 <ohbadiah> I'm trying to implement a drafting card game, where the type of each choice is something like [Card] -> State -> IO (Card, [Card]). But I want the game code to be agnostic to the particular choice algorithm, whether (say) choosing one at random or emailing a human.
11:38:09 <ohbadiah> I'm afraid I've got in such a cognitive rut that I'm having trouble thinking of how to model this apart from inheritance. Could anyone point me in the right direction?
11:38:44 <applicative> choose :: ChoiceAlgorithm -> [Card] -> State -> IO ....
11:39:40 <applicative> I mean, what about something like that, just to put something on the table...
11:40:05 <Saizan> ohbadiah: make the game code take a function (or many) of that type as argument?
11:40:31 <ohbadiah> Hmm. I'm trying to wrap my mind around that.
11:41:18 <applicative> what is the type 'State' like.  It sounds like this might to well in a state monad
11:41:46 <nk_> Has anyone compiled GHC on a Raspberry Pi or other ARM machine?
11:41:55 <ohbadiah> Yeah, I think a state monad would be useful here. State is probably just an ADT.
11:42:04 <dmj> ohbadiah: I recently wrote the card Game war in haskell, card selection was done by selecting the head, updates were done in a state monad. I can send you the code if you want.
11:42:16 <applicative> people have nk_ but I don't know anything about it
11:42:25 <ohbadiah> dmj: That would be much appreciated!
11:42:29 <applicative> nk_: that roconnor did it suggested there was hope for me figuring it out
11:42:36 <dmj> ohbadiah: https://github.com/dmjio/War/blob/master/Main.hs
11:43:39 <ohbadiah> Hmm, so I guess here a Player can be an ADT that includes a ChoiceAlgorithm
11:44:33 <ohbadiah> Thanks everyone! I'll see if that help gets me farther.
11:44:45 <applicative> nk_: occasionally when the topic comes up, ten people join in with their experiences; seems like this isnt a raspberry pi moment
11:45:16 <nk_> Oh well
11:45:38 <nk_> the details are here: http://stackoverflow.com/questions/17765002/compiling-haskell-on-the-raspberry-pi
11:46:02 <nk_> if someone wants to take a look
11:46:14 <taylorgb_> Sounds a bit scary
11:46:34 <taylorgb_> I remember trying to use ghc on a machine with only 1GB ram and no swap.. couldn't link anything with more than 3 files
11:46:52 <nk_> I just want to play in ghci
11:47:08 <nk_> but v. 7.4 does NOT support ghci on ARM
11:47:13 <dmwit> I mean, I think the standard advice for RPi is to install GHC from the repositories.
11:47:19 <dmj> nk_: did you see this post? http://alenribic.com/posts/2012-08-06-running-haskell-on-raspberry-pi.html
11:47:34 <dmj> it might be old...
11:47:38 <alexander__b> dmwit: you mean using return/fail in readMaybe, right?
11:47:46 <dmwit> alexander__b: I mean everywhere. =)
11:47:50 <alexander__b> dmwit: oh eh
11:48:15 <dmwit> > (fail "foo" :: Maybe (), fail "foo" :: Either String ())
11:48:16 <lambdabot>   (Nothing,*Exception: foo
11:48:25 <dmwit> um
11:48:27 <dmwit> That surprised me.
11:48:35 <nk_> Yes, I 've seen it. But changing to an experimental repo is not a good idea
11:48:56 <applicative> nk_: there may be a couple clues of interest http://tunes.org/~nef/logs/haskell/13.07.17 starting from 11:25:28  for a couple minutes.
11:50:08 <dmwit> > runIdentity . runErrorT $ fail "foo" :: Either String ()
11:50:08 <lambdabot>   Left "foo"
11:50:20 <nk_> thank you, applicative
11:50:25 <dmwit> I wonder...
11:50:37 <dmwit> > fail "foo" :: ErrorT String Identity ()
11:50:38 <lambdabot>   No instance for (GHC.Show.Show
11:50:38 <lambdabot>                     (Control.Monad.Trans.Err...
11:50:42 <dmwit> silly
11:51:02 <dmwit> ?let deriving instance Show (m (Either e a)) => Show (ErrorT e m a)
11:51:02 <lambdabot>  Parse failed: StandaloneDeriving is not enabled
11:51:45 <dmwit> ?let instance Show (m (Either e a)) => Show (ErrorT e m a) where showsPrec n (ErrorT m) = showsPrec n m
11:51:45 <lambdabot>  Parse failed: Malformed context: FlexibleContexts not enabled
11:51:53 * dmwit sticks his tongue out
11:51:59 <elliott> nk_: you may be able to get the .deb from the repository without switching to it
11:53:12 <mikolaj`> Hello. I need advice on learning Haskell. As a person who knows Scheme, should I head to "Real world Haskell", or should I read "Learn you a Haskell" first?
11:53:16 <applicative> probably roconnor was just trying get agda onto his raspberry pi, so he could run it with theorems
11:53:41 <applicative> mikolaj`: maybe both?
11:53:59 <taylorgb_> I guess most would recommend doing LYAH first
11:54:14 <mikolaj`> applicative: I have the impression the "Learn you a haskell" is also an introduction to functional programming.
11:54:16 <applicative> LYAH is surprising good at putting across some of the main abstractions, like Functor and so on
11:54:22 <dmwit> I recommend the Gentle Introduction. LYAH is way too slow.
11:54:37 <applicative> mikolaj`: yes, it is elementary, but one needn't waste much time with the beginning
11:54:55 <applicative> I like LYAH because I feel it captures the right order somehow?
11:55:11 <alexander__b> mikolaj`: I would not recommend LYAH if you know functional programming
11:55:33 <dmj> mikolaj': This is what you need: http://www.haskell.org/haskellwiki/Typeclassopedia
11:55:35 <applicative> alexander__b: but LYAH is all about the types and *->*'s
11:55:39 <alexander__b> i.e. if you know it *well*.
11:56:02 <mikolaj`> alexander__b: I would not say it :D I have actually completed SICP on my own some time ago.
11:56:07 <applicative> if mikolaj` knew ML , lyah would be a waste of time, yes
11:56:17 <applicative> or F# or ocaml or whateve
11:56:34 <nk_> LYAH is fun
11:56:39 <nk_> do not forget this
11:56:59 <mikolaj`> dmwit: The "Gentle introduction" seems to be a bit dated... (I see "Revised 2000")
11:57:05 <applicative> the impression that it is somehow elementary and childish and so is sort of illusory, it's pretty deep in the end
11:57:17 <ignacio> it's got pretty pictures
11:57:37 <alexander__b> the pictures annoy me
11:57:40 <elliott> mikolaj`: scheme is not so similar to haskell that the added philosophical material will be wasted on you
11:57:46 <applicative> but of course many of the deep hard difficult things in haskell *are* idiot simple, they just require the magic touch so you lay hold of the abstraction
11:57:50 <elliott> though many of the similarities are beneficial for learning.
11:57:56 <alexander__b> but the book itself is rather good. to call it elementary would be way off.
11:58:05 <alexander__b> at least it's not elementary stuff to me...
11:58:29 <mikolaj`> Hm, okay then I read LYAH first...
11:58:35 <dmwit> mikolaj`: It's old. But none of the really important stuff has changed.
11:58:35 <mikolaj`> Thanks all for your help.
11:58:58 <dmj> mikolaj': I highly recommend the typeclassopedia as well
11:59:01 <dmwit> Haskell has a lot of really cool, fundamentally different ideas.
11:59:10 <dmwit> The Gentle Intro dives straight into them, and explains them carefully and correctly.
11:59:23 <dmwit> Syntax may have changed a little; the names of a few libraries may have changed a little.
11:59:26 <dmwit> But the core ideas are all the same.
12:00:20 <elliott> at least one of the function names used in Gentle Introduction is wrong too :p
12:03:49 <applicative> it would be nice to have an lyah-length intro to haskell that unrelentingly focussed on io and unconsciously tricked the reader into using modern libraries like bytestring text and vector
12:04:00 <hpc> haha
12:04:19 <hpc> like, tell new users to install the platform, then neglect to mention that the good shit comes from packages other than base?
12:04:20 <applicative> hpc, I'm not making sense?
12:04:38 <applicative> the platform has all the libraries I mentioned no?
12:04:44 <hpc> yep
12:05:02 <applicative> oh true they're not in base except bytestring
12:05:43 <hpc> i am always tickled by the idea of deceiving people into education
12:06:13 <applicative> the platform could do with a good simple not-lazy-io library once one appears, in the 23rd century
12:07:28 <hpc> edwardk could always bring such a package back from whatever planet he comes from ;)
12:07:51 <applicative> hpc, well I was thinking, really people are accustomed to things like bytestring and to arrays and so on
12:08:05 <applicative> why not just drag them into your account of the abcs
12:08:31 * hackagebot GLFW-b 1.2.0 - Bindings to GLFW OpenGL library  http://hackage.haskell.org/package/GLFW-b-1.2.0 (BrianLewis)
12:08:33 * hackagebot xml-types 0.3.4 - Basic types for representing XML  http://hackage.haskell.org/package/xml-types-0.3.4 (JohnMillikin)
12:08:35 * hackagebot parconc-examples 0.2 - Examples to accompany the book "Parallel and Concurrent Programming in Haskell"  http://hackage.haskell.org/package/parconc-examples-0.2 (SimonMarlow)
12:09:04 <applicative> oh, the async library is in the platform too.  why not throw some of that in on page 17 as if it were nothing
12:09:24 <hpc> oooh
12:10:02 <hpc> the haskell platform page now links to hackage2
12:10:17 <alexander__b> dmwit: I'm doing things a bit from scratch to get a better overview. in http://lpaste.net/91079 -- what should f look like?
12:10:39 <alexander__b> dmwit: I would like it to lookup op in ops like the previous code
12:10:50 <alexander__b> dmwit: but I don't want any maybes in here to start with. I need to grok things slowly, heh.
12:11:06 <hpc> attoparsec comes with platform too
12:11:34 <hpc> and Data.CaseInsensitive, which i didn't even realize was a thing
12:13:13 <hpc> and there's me at the bottom of the module list :D
12:13:35 <hpc> Trace.Hpc
12:28:30 <tappi> for a programmer who hasn't yet tried functional languages, is this a good resource to start? http://learnyouahaskell.com/chapters
12:28:32 * hackagebot henet 1.3.8.0 - Bindings and high level interface for to ENet v1.3.8  http://hackage.haskell.org/package/henet-1.3.8.0 (JohnEricson)
12:28:34 * hackagebot hsp 0.9.2 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.9.2 (JeremyShaw)
12:28:36 * hackagebot happstack-hsp 7.2.2 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.2.2 (JeremyShaw)
12:29:38 <alexander__b> tappi: yes
12:29:43 <ion> tappi: yes
12:30:09 <ion> tappi: Also be sure to ask here when something seems confusing.
12:30:27 <tappi> and more than would you suggest that tutorial over other possible tutorials for that purpose?
12:31:08 <jmcarthur> tappi: for beginners to functional programming i think lyah is usually the best bet
12:31:12 <alexander__b> btw if anyone else knows: feel free to help me with http://lpaste.net/91079 -- what should f look like? I have tried a bunch of implementations, but I always get *something* wrong. I want to do lookup op in ops and do the maths... and end up printing a number or "error on operator [operator]"
12:31:19 <alexander__b> tappi: yes.
12:31:26 <tappi> ok, thanks
12:31:38 <nexx> for all tutorials I know, yes
12:32:18 <alexander__b> tappi: the five first chapters are fantastic. the last five get... yawny/confusing. but stick with it.
12:32:20 <cdk> alexander__b: f :: Num a => tring -> a -> a
12:32:32 <cdk> f :: Num a => String -> a -> a
12:33:03 <alexander__b> cdk: wat
12:33:07 <roboguy_> alexander__b: I think you want foldr1
12:33:21 <cdk> alexander__b: thats the type of f
12:33:27 <alexander__b> roboguy_: I guess.
12:33:40 <alexander__b> cdk: I am far too much of a newbie to fill in such huge blanks.
12:33:41 <jmcarthur> alexander__b: i don't think i understand the question. are you asking about the f on line 4?
12:33:52 <alexander__b> jmcarthur: yes
12:33:54 <roboguy_> alexander__b: foldr1 uses the last element of the list for the terminal element, as opposed to (in your code) []
12:34:19 <roboguy_> alexander__b: so, for instance, foldr1 (+) [1,2,3] == 1+2+3 == 6
12:34:20 <alexander__b> jmcarthur: the things I have started to write but failed at have generally been things with fromMaybe "fael" $ lookup op ops
12:34:25 <alexander__b> roboguy_: yes, I know.
12:34:52 <roboguy_> alexander__b: I'm not sure I fully understand what you want though. do you want solve to give you a list or a number?
12:35:08 <alexander__b> roboguy_: solve should give the ready string to print
12:35:20 <alexander__b> roboguy_: so I would use read somewhere in there.
12:35:21 <jmcarthur> alexander__b: it looks to me like you need to match on the first element, apply the resulting function to the tail, then repeat on the result
12:35:52 <roboguy_> alexander__b: why not separate that out of the solve function, so you can focus on applying the operations?
12:36:19 <alexander__b> roboguy_: well it needs to be somewhere. and it's just a matter of doing "read (stuff)" somewhere, so that's not a concern for me.
12:36:30 <jmcarthur> alexander__b: and unfortunately the way you have mixed your operations of various arity, it's hard to tell which of binOp, unOp, or naryOp to use
12:36:41 <alexander__b> jmcarthur: how do you mean?
12:37:03 <jmcarthur> alexander__b: oh i misread it
12:37:06 <jmcarthur> apologies
12:37:12 <jmcarthur> the first thing i said is still true though
12:37:36 <jmcarthur> i think you don't actually want a fold, in any case
12:37:46 <alexander__b> jmcarthur: oh OK
12:37:57 <jmcarthur> it looks to me like you just need some function that does a single step of the computation and then repeat that over and over until it terminates/fails
12:38:07 <alexander__b> jmcarthur: yes, I guess.
12:40:43 <alexander__b> http://lpaste.net/91078  -- here is dmwit's solution
12:41:13 <alexander__b> it's a bit... over my head. so I'm redoing it from scratch to try to wrap my head around it. furthermore, I want to use return/fail, as dmwit suggested.
12:41:44 <aranea> Hi. I've got some quite simple XML documents (no attributes or other complicated stuff) and want to transform them to records. I planned to use Text.XML.Light, but the code it getting a bit annoying to write. Do you have suggestions?
12:43:20 <aranea> The documents aren't nested, just a depth-1 structure
12:43:37 <dmj> aranea: Have you tried parsec or attoparsec?
12:43:37 <aranea> but with 15 fields
12:43:43 <aranea> er, no
12:43:55 <aranea> hmm, you're right
12:44:21 <aranea> maybe it's easier to develop my own simple xml parser...
12:44:30 <Demos> no
12:44:32 <Demos> it is not
12:44:45 <Demos> xml is not easy to parse
12:46:06 <dmj> aranea: Can you show us a sample of what your xml file looks like?
12:46:12 <aranea> Demos: My XML docs don't have attribs or CDATA constructs, they are quite easy
12:47:37 <aranea> the schema is at the end of that doc: https://datatracker.ietf.org/doc/draft-kucherawy-dmarc-base/?include_text=1
12:47:56 <aranea> I'll show you one of my documents
12:48:17 <aranea> I just have to anonymize it first
12:53:15 <aranea> http://dpaste.com/1311819/
12:55:20 <aranea> and these are the target records: http://dpaste.com/1311820/
12:55:46 <dmj> ok, give me a sec. Going to try to use an XML library
12:56:03 <applicative> theres only a limited number of tags, that you know in advance?
12:56:19 <aranea> yes
12:56:42 <aranea> I know the exact schema
12:56:56 <applicative> attoparsec might be just as convenient if it really is like that, but i'm an xml moron
12:57:16 <aranea> me too :)
12:57:42 <Fuuzetsu> anyone know if David Waern hangs out in here/IRC?
12:57:49 <applicative> so this whole document contains something of type 'Feedback'?
12:57:55 <applicative> i mean the example
12:57:57 <Fuuzetsu> @seen waern
12:57:57 <lambdabot> \/\/a3rN
12:58:02 <Fuuzetsu> uhh
12:58:30 <applicative> haha
12:58:38 <applicative> @leet waern
12:58:38 <lambdabot> WA3RN
12:58:59 <applicative> @leet Fuuzetsu
12:58:59 <lambdabot> FUUZET5u
12:59:03 <applicative> not too good
13:00:58 <aristid> @leet applicative
13:00:58 <lambdabot> ApPLi(A7IVe
13:01:02 <aristid> excellent.
13:01:26 <Fuuzetsu> I'd much rather prefer ‘seen’ functionality…
13:01:36 <alexander__b> @leet alexander__b
13:01:37 <lambdabot> 41exANDEr__b
13:01:38 <aristid> applicative: the levenshtein-distance autocomplete is funny
13:01:41 <Fuuzetsu> >2012-02-13 23:44:32 +0100
13:01:44 <Fuuzetsu> ehh ;(
13:01:55 <aristid> no preflex :(
13:02:00 <dmwit> alexander__b: still around?
13:02:22 <alexander__b> dmwit: yes. I have actually had the luxury of sitting down in front of a computer for over an hour now!
13:02:30 <dmwit> =)
13:02:35 <aranea> yes, applicative, the doc is a Feedback
13:02:43 <dmwit> I would say that combining "maybe" and "lookup" is a pretty fine way to start.
13:02:44 <alexander__b> dmwit: still scratching my head about the f, heh
13:02:45 <dmwit> What have you tried?
13:03:13 <Fuuzetsu> Does anyone here ever wanted to use multi-line emphasis in Haddock comments?
13:03:32 <alexander__b> dmwit: I have just completely restarted, like you maybe saw, and then I have just tried various things like using fromMaybe lookup in f, and like implementing Either, but so many type errors that my head exploded and I gave up. =/
13:03:41 <dmwit> Okay.
13:03:45 <dmwit> Let's take it one step at a time. =)
13:03:59 <dmwit> Literally: I suggest you write a function which takes a stack and a single instruction and munges the stack according to that instruction.
13:04:22 <dmwit> e.g. step :: Monad m => String -> Stack -> m Stack
13:04:25 <alexander__b> dmwit: a stack, being e.g. the equation I take?
13:04:30 <dmwit> Dunno what Stack should be, but probably [Double] or so?
13:04:39 <dmwit> err
13:04:51 <dmwit> alexander__b: No, the equation is a sequence of instructions.
13:04:56 <alexander__b> oh
13:05:42 <dmwit> Does the proposed exercise make sense now
13:05:42 <dmwit> ?
13:06:02 <alexander__b> dmwit: is it still too late to ask what a Monad is? :-P
13:06:19 <dmwit> nope
13:06:26 <alexander__b> I must admit I still don't have the theory down with functors, applicative functors and monads.
13:06:26 <dmwit> But I gotta run and deal with the onions, back in a few minutes.
13:06:38 <alexander__b> food is good. have fun.
13:06:52 <ReinH> Hai.
13:07:31 <dmwit> Okay, back for three or four more minutes.
13:07:41 <dmwit> For now, you can think of Monad as a generalization of Maybe.
13:07:57 <dmwit> Where before you used "Just" to say that you succeeded, you now say "return" to say the same thing.
13:08:19 <dmwit> Where before you used "Nothing" to say you failed, you now say 'fail "you suck!"' to say you failed because you suck!
13:08:20 <alexander__b> right and return returns m something
13:08:51 <alexander__b> f = "blah" returns a String but f = return "blah" would return a m String? I guess
13:09:01 <dmwit> right
13:09:09 <alexander__b> yay I understood something
13:09:15 <dmwit> > [return [3], Just [3], fail "you suck!", Nothing] :: [Maybe [Double]]
13:09:16 <lambdabot>   [Just [3.0],Just [3.0],Nothing,Nothing]
13:09:40 <dmwit> The reason using return and fail is slightly better is because you can choose something other than Maybe, of course. =)
13:10:05 <alexander__b> so step takes String -> [Double] -> m [Double]?
13:10:13 <dmwit> > runIdentity . runErrorT <$> [return [3], fail "you suck!"] -- we'll get to runIdentity and runErrorT in a bit
13:10:14 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error e0)
13:10:14 <lambdabot>    arising from a use ...
13:10:29 <applicative> aranea, one thought is to use tagsoup as a primitive quasi-tokenizer, but maybe you lose as much as you gain
13:10:30 <dmwit> > runIdentity . runErrorT <$> [return [3], fail "you suck!"] :: [Either String [Double]]-- we'll get to runIdentity and runErrorT in a bit
13:10:31 <lambdabot>   [Right [3.0],Left "you suck!"]
13:10:42 <dmwit> alexander__b: Right, but with a Monad m constraint.
13:10:45 <alexander__b> dmwit: I'm not really sure what the stack here is. from where do I get this stack?
13:10:49 <alexander__b> dmwit: yes I have that
13:10:50 <dmwit> step :: Monad m => String -> [Double] -> m [Double]
13:10:54 <alexander__b> dmwit: yes exactly
13:10:54 <applicative> aranea: the result of parseTags for you file is a list of these http://sprunge.us/VZde
13:11:00 <dmwit> alexander__b: Your "clac" is munging stacks all over the place!
13:11:17 <alexander__b> dmwit: my current clac is doing nowt :-P
13:11:17 <dmwit> Okay, gotta run and fix up food. Gone for ~1 hour or so. Hopefully somebody else can take over for now.
13:12:09 <alexander__b> dmwit: itadakimasu!
13:12:23 <aranea> applicative: thanks, but that looks like it would require similar boilerplate code as Text.XML.Simple
13:13:27 <applicative> aranea: I dont know, it just requires a function [Tag] -> Maybe Feedback so to say
13:13:41 <applicative> it's that it loses the tree, or serializes it thats the trouble
13:13:55 <aranea> hmm, that would be okay
13:27:18 <haasn> alexander__b: oh hey
13:27:28 <alexander__b> haasn: sup
13:27:40 <dmj> is there an uncurry11?
13:27:42 <alexander__b> I'm eating cheese and crackers over here. should be haskelling though.
13:27:57 <haasn> still working on your calculator? =)
13:28:41 <alexander__b> haasn: I barely have worked on it due to no net and no time
13:28:51 <dmj> zip ['a'..'z'] [1..]
13:29:02 <dmj> > zip ['a'..'z'] [1..]
13:29:03 <lambdabot>   [('a',1),('b',2),('c',3),('d',4),('e',5),('f',6),('g',7),('h',8),('i',9),('...
13:29:12 <aranea> How to do this easily, also for functions with more arguments? (a -> b -> c) -> (d -> a) -> (e -> b) -> d -> e -> c
13:29:24 <haasn> aranea: pointless-fun
13:29:45 <haasn> see the example at the top of http://hackage.haskell.org/packages/archive/pointless-fun/1.1.0.1/doc/html/Data-Function-Pointless.html
13:31:42 <aranea> awful, thanks
13:32:06 <alexander__b> why does my vim do 4 spaces indentation for lol = \n stuff
13:32:23 <alexander__b> softtabstop is 2, and so is shiftwidth.
13:33:09 <alexander__b> also if I try to format "lulz foo \n | lulz" -- it will put | lulz on the same level as lulz.
13:33:13 <alexander__b> so no identation
13:33:20 <aranea> and for (a -> b -> c -> d) -> (x -> a) -> (x -> b) -> (x -> c) -> d ?
13:33:34 <aranea> er, -> x -> d
13:33:37 <ignacio> expandtab on?
13:33:47 <alexander__b> ignacio: ya
13:34:02 <alexander__b> it's really annoying
13:34:20 <ignacio> maybe some hardcoded value in indent/haskell.vim
13:34:40 <alexander__b> I don't have that. I need to figure out what plugin might be doing it
13:35:20 <alexander__b> OK I did mv .vim .vim2 -- it's 100% definitely one of my local plugins, not a global one. so that's a start.
13:35:28 <haasn> alexander__b: I use those two settings, along with expandtab; and it works fine for me; maybe something is overriding your settings language specifically?
13:35:30 <haasn> or some plugin is acting up
13:35:39 <alexander__b> it is probably some plugin, yes
13:35:52 <haasn> got any fancy haskell plugins?
13:36:02 <alexander__b> yes
13:36:05 <alexander__b> the culprit was vim2hs
13:36:07 <BigRonnieRon> n00b question. reading "Learn you Haskell real good", was wondering if there's a good chrestomathy or something online similar someone could refer me to besides Rosetta Code?
13:36:35 <alexander__b> http://bpaste.net/show/115963/
13:36:44 <alexander__b> ^ the haskell.indent is so bare
13:38:19 <aranea> Does someone have a hint for tasks like (a -> b -> c -> d) -> (x -> a) -> (x -> b) -> (x -> c) -> x -> d ?
13:38:31 <alexander__b> oh, yes, it's this: http://bpaste.net/show/115964/
13:38:38 <aranea> er, wrong again
13:38:47 <aranea> (a -> b -> c -> d) -> (x -> a) -> (x -> b) -> (x -> c) -> x -> e
13:39:53 <ReinH> What's the best way to completely clean my cabal packages so I can switch to cabal-dev? I'm tired of shadowed packages and etc issues.
13:40:18 <alexander__b> guards are still not indented though =/
13:40:23 <ReinH> I just want to install the requirements for cabal-dev and do everything else in a sandbox
13:40:29 <haasn> ReinH: well, I'm guessing it should all be in ~/.cabal if you only installed locally
13:40:45 <alexander__b> and now it doesn't outdent "in"
13:40:47 <ReinH> haasn: is it safe to just rm it?
13:40:48 <alexander__b> so let foo = something; bar = something; in blah -- will put in at the same level as foo = and bar = .
13:40:56 <ReinH> I don't know how self-contained it is
13:41:13 <haasn> ReinH: I don't think it should cause anything to break, but ghc-pkg might disagree
13:41:15 <haasn> no idea
13:41:26 <haasn> try mv'ing it out of the way? =)
13:41:27 <ReinH> haasn: right, that's my worry. I'll search around a bit more.
13:41:31 <elliott> ReinH: I do rm -r ~/.cabal ~/.ghc.
13:41:37 <ReinH> elliott: makes sense
13:41:37 <elliott> I am told the ~/.ghc part of this is excessive
13:41:38 <ReinH> thanks
13:41:44 <elliott> but I like burning things.
13:41:57 <ReinH> I'm also updating haskell-platform so it seemed like a good time for house cleaning
13:41:57 <haasn> note to self: keep elliott away from lambdabot
13:41:59 <haasn> oh wait
13:42:03 <ReinH> lmao
13:42:14 <elliott> haha
13:42:26 <ReinH> I miss type inference so much in every langauge that is not Haskell.
13:42:35 <haasn> yeah, like agda
13:42:52 <ReinH> correction: every language *that I use* that is not Haskell
13:43:10 <pentace> @pl \fd fa fb fc x -> fd (fa x) (fb x) (fc x)
13:43:10 <lambdabot> (((ap .) . ap) .) . (.)
13:43:19 <aranea> elliott: I personally had to do rm -r ~/.ghc
13:43:41 <haasn> alexander__b: I just do indenting manually =P
13:43:42 <aranea> there were strange errors before
13:43:47 <ReinH> pentace: throw enough ap and . around and you can make almost anything pointfree... and pointless too.
13:43:57 <haasn> and sometimes inconsistently, depending on the overall look of the code
13:44:11 <alexander__b> haasn: I'm too old to waste time on indenting by hand :-P
13:44:33 <pentace> :t ap
13:44:34 <lambdabot> Monad m => m (a -> b) -> m a -> m b
13:46:11 <pentace> :t \fd fa fb fc x -> fd <*> fa <*> fb <*> fc
13:46:12 <lambdabot> Applicative f => f (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> t -> f b
13:46:39 <pentace> :t \fd fa fb fc x -> fd <$> fa <*> fb <*> fc $ x
13:46:40 <lambdabot> Applicative ((->) t) => (a2 -> a1 -> a -> b) -> (t -> a2) -> (t -> a1) -> (t -> a) -> t -> b
13:47:12 <pentace> aranea: ^ is that what you're looking for?
13:47:26 <aranea> pentace: I guess ;)
13:48:43 <aranea> I completely forgot about Applicatives
13:48:59 <aranea> Haskell is hard to remember after longer breaks
13:49:01 <Fuuzetsu> @pl foo fd fa fb fc x = fd <$> fa <*> fb <*> fc $ x
13:49:05 <lambdabot> foo = (((id .) .) .) . (. (((<*>) .) . (<*>))) . (.) . (.) . (<$>)
13:49:05 <lambdabot> optimization suspended, use @pl-resume to continue.
13:49:09 <haasn> the same can be said of most languages
13:49:10 <Fuuzetsu> it's beautiful ;_;
13:49:26 <haasn> Fuuzetsu: liftAn for some n
13:49:32 <haasn> oh, not quite
13:49:38 <Fuuzetsu> not quite indeed
13:49:52 <haasn> yes quit
13:49:58 <haasn> :t liftA4
13:49:59 <lambdabot>     Not in scope: `liftA4'
13:49:59 <lambdabot>     Perhaps you meant one of these:
13:49:59 <lambdabot>       `liftA' (imported from Control.Applicative),
13:50:00 <haasn> :t liftA3
13:50:01 <Fuuzetsu> :t liftA4
13:50:01 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
13:50:01 <lambdabot>     Not in scope: `liftA4'
13:50:01 <lambdabot>     Perhaps you meant one of these:
13:50:03 <lambdabot>       `liftA' (imported from Control.Applicative),
13:54:46 <aranea> @pl foo fx a b c d e fa fb fc fd fe = fx (fa a) (fb b) (fc c) (fd d) (fe e)
13:54:49 <lambdabot> foo = flip flip (flip id) . ((flip . ((flip . (flip .)) .) . ((((.) .) .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) .
13:54:49 <lambdabot> (((((((((.) .) .) .) .) .) .) .) .) . flip flip (flip id) . (flip .) . ((flip .) .) . ((((.) .) .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . (((((((.) .) .) .) .) .) .
13:54:49 <lambdabot> ) . flip flip (flip id) . (flip .) . (((.) .) .) . ((flip .) .) . (((flip .) .) .) . (((((.) .) .) .) .) . flip flip (flip id) . ((.) .) . (flip .) . (((.) .) .) . (. flip id) . (.)
13:54:49 <lambdabot> optimization suspended, use @pl-resume to continue.
13:54:59 <aranea> @pl-resume
13:55:05 <lambdabot> foo = flip flip (flip id) . ((flip . ((flip . ((flip . (((.) . flip . ((flip . (flip .)) .)) .) . ((((flip .) .) .) .)) .)) .)) .) . (((((((((.) .) .) .) .) .) .) .) .) . flip flip (flip id) . (flip
13:55:05 <lambdabot> .) . ((flip .) .) . ((((.) .) .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . (((((((.) .) .) .) .) .) .) . flip flip (flip id) . (flip .) . (((.) .) .) . ((flip .) .) .
13:55:05 <lambdabot> (((flip .) .) .) . (((((.) .) .) .) .) . flip flip (flip id) . ((.) .) . (flip .) . (((.) .) .) . (. flip id) . (.)
13:55:05 <lambdabot> optimization suspended, use @pl-resume to continue.
13:55:08 <aranea> oh yeah
13:55:17 <luite> urgh, can you do that in private? :p
13:55:27 <elliott> glorious.
13:55:31 <aranea> yes, I guess I'll install pointfree
13:55:57 <simukis_> aranea, how about `/msg lambdabot @pl whatever whatnot`?
13:56:14 <shachaf> Installing pointfree is also good.
13:56:26 <elliott> better than using @pl right now
13:57:00 <aranea> woa, that took 15 seconds to compute
13:57:44 <k0ral_> what's the cleanest way to work with non-empty lists ? I'm thinking about defining a type MyList x = Empty | Element x (MyList x), but it looks a bit overkill
13:58:06 <shachaf> k0ral_: There is Data.List.NonEmpty in semigroups.
13:58:20 <shachaf> k0ral_: Your type isn't very good for working with non-empty lists, since it supports empty lists. :-)
13:58:27 <shachaf> Sometimes you can just use e.g. (a,[a])
13:58:31 <k0ral_> hmmm, actually it would be "type MyList = Element x (MyList' x) with MyList' x = Empty | MyList x
13:59:05 <k0ral_> arrrg, it's wrong again... you got what I meant
13:59:47 <elliott> k0ral_: semigroups has a nice definition
14:00:00 <elliott> http://hackage.haskell.org/packages/archive/semigroups/0.9.2/doc/html/Data-List-NonEmpty.html
14:00:32 <k0ral_> looking at that, thank you
14:01:25 <k0ral_> I tend to think empty lists should never have existed
14:01:39 <haasn> then what do you use to represent an empty list?
14:01:45 <k0ral_> there is already Maybe to say "I might have nothing"
14:01:51 <haasn> tangential
14:01:53 <nexx> "Nothing"?
14:02:18 <shachaf> Empty lists are great.
14:02:22 <haasn> so in your opinion foldr :: (a -> b -> b) -> b -> Maybe [a] -> b -- ?
14:02:32 <nexx> but I think it's nicer to work with empty lists
14:02:40 <shachaf> N things, when N is some natural number, is a useful concept.
14:02:42 <elliott> [] is definitely defined correctly.
14:02:47 <elliott> NonEmpty is far weirder.
14:02:57 <elliott> for instance foldr is a lot more natural, etc.
14:03:05 <shachaf> foldr :: (a -> b -> b) -> (a -> b) -> NonEmpty a -> b
14:03:16 <elliott> which is gross.
14:03:20 <k0ral_> I may have fallen in a specific use case, but it looks like non-empty lists are more often what I need
14:03:37 <elliott> your use-case is weird then :p
14:03:37 --- mode: ChanServ set +o shachaf
14:03:50 <k0ral_> but then I guess lists couldn't be made an instance of Monad ?
14:03:55 --- mode: shachaf set -bb *!*@88.129.148.32 *!*klrr@88.129.*
14:03:58 --- mode: shachaf set -o shachaf
14:04:42 <shachaf> k0ral_: NonEmpty is a monad.
14:05:08 <johnw> k0ral_: empty lists give you the free monoid, but Maybe NonEmpty does not
14:05:08 <shachaf> (A different monad, of course.)
14:05:11 <haasn> but not a monoid! and that is bad
14:05:23 <johnw> (at least, not in current base)
14:05:56 <k0ral_> maybe I should stop thinking out loud :)
14:06:23 <tdammers> I really don't see the problem with empty lists
14:06:51 <tdammers> by extension, one could argue that if a list with zero elements is "wrong", then so is the number zero itself
14:06:58 <k0ral_> empty lists are like NULL pointers
14:07:06 <haasn> yeah, every type has them
14:07:09 <haasn> wait what?
14:07:09 <tdammers> so instead of Integer, we'd use Maybe NonZeroInteger?
14:07:19 <jfischoff> haasn: lol
14:07:22 <johnw> k0ral_: only if you code under the assumption they don't exist; there are many contexts where an empty list is meaningful
14:09:41 <shachaf> k0ral_: If you don't like empty lists, they you should also not like natural numbers (and instead prefer positive naturals).
14:09:47 <k0ral_> I don't think your comparison with NonZeroInteger is relevant
14:10:00 <k0ral_> zero is a piece of information
14:10:10 <johnw> what about empty strings?  is [] bad when it's [Char]?
14:10:20 <k0ral_> an empty list is a computation that is supposed to hold a value... but that doesn't !
14:10:31 <tappi> are lists mutable in haskell?
14:10:32 <shachaf> You are free to use non-empty lists if you prefer.
14:10:35 <shachaf> tappi: No.
14:11:29 <tappi> (hehe :p)
14:12:41 <aranea> Ahem, one last question. (a -> b -> c) -> (x -> a) -> (x -> b) -> x -> c can be done with Applicatives, but what for Monad m => (a -> b -> c) -> (x -> m a) -> (x -> m b) -> x -> m c ?
14:13:44 <k0ral_> johnw: well, to be consistent I would say yes
14:14:26 <k0ral_> johnw: the need for emptiness is captured by Maybe, why not use it there ?
14:14:48 <supki> aranea: that's  liftA2 . liftA2  I think
14:15:21 <b2coutts> does Data.Map sometimes do weird things in terms of forcing strictness?
14:15:41 <supki> aranea: or  liftA2 . liftM2  if you really like Monad =>
14:16:30 <jrh> because using Maybe is ugly?
14:17:54 <k0ral_> jrh: I'm sure we could sugarize it, like we did for monads
14:18:09 <aranea> thanks supki, but I need that for a function with 5 arguments, so something with <*> instead of liftAn would be great
14:19:00 <haasn> aranea: looks like a ReaderT or something could be used as well
14:19:28 <jrh> k0ral_: then aren't you back to where you started? to make it pleasant it would look just as lists do now
14:19:34 <haasn> but that would require a lot of ugly boxing/unboxing of newtypes =(
14:19:47 <johnw> k0ral_: like shachaf said, if you don't want to use empty lists, then don't
14:22:08 <enthropy> darcs is able to do a post-hook make a snapshot tar.gz. In principle I could tell people to "cabal install 'http://code.haskell.org/xmonad/xmonad.tar.gz'", but this doesn't work since there is a complaint (File in tar archive is not in the expected directory)
14:22:09 <k0ral_> johnw: sure, I was more asking for your opinion than stating anything :)
14:22:57 * enthropy would rather not have to guess what version I put in the .cabal file from the shell code that generates the tar.gz
14:23:06 <johnw> people abuse Maybe by using fromJust the same way that they can abuse empty lists.  If your goal is to make abuse impossible, I think it needs a more thorough solution (such as fully dependent types) rather than just eliminating one source of potential problems
14:23:11 <enthropy> can cabal be made more lenient?
14:25:09 <JustAPerson> >length [x / 10 | x <- 1, 3 .. 10]]
14:25:54 <JustAPerson> > length [x / 10 | x <- 1, 3 .. 10]]
14:25:55 <lambdabot>   <hint>:1:28: parse error on input `..'
14:26:12 <k0ral_> what about non-empty maps ?
14:26:26 <haasn> > foldr f z [1..5]
14:26:27 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
14:27:28 <haasn> > foldl f z [1..5]
14:27:29 <gnuvince> :t guard
14:27:30 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
14:27:30 <lambdabot> MonadPlus m => Bool -> m ()
14:27:30 <lingxiao> Hey all
14:27:44 <lingxiao> Does anyone know wht the different between bifunctor and profunctor is?
14:27:54 <gnuvince> Does Plus in MonadPlus mean "addition" or "improved"?
14:28:00 <aa757> h
14:28:05 <jrh> addition
14:28:08 <lingxiao> or a good article that introduce profunctor?
14:28:12 <jrh> but more general, like a monoid
14:28:38 <thoughtpolice> lingxiao: https://www.fpcomplete.com/user/liyang/profunctors
14:28:41 <gnuvince> jrh: so if I want to make a MonadPlus, I need a type that's a Monad and a Monoid?
14:29:05 <lingxiao> thoughtpolice: thanks! i'll read it now
14:29:10 <thoughtpolice> lingxiao: i liked that article. a profunctor is a bifunctor that's just contravariant in its first argument, and covariant in the second
14:29:18 <thoughtpolice> there are good exercises too
14:30:07 <joelteon> yeah, duh
14:30:29 <lingxiao> thoughtpolice: thank you, that's exactly the kind of concise explanation I was looking for. And thanks for the article as well
14:31:41 <jrh> gnuvince: yeah, though it doesn't need to be an instance of Monoid. Google tells me there's some disagreement about what laws they should follow, too...
14:32:37 <orzo> you know it kind of sucks lhow every function search by type on hoogle results in unsafeCoerce
14:33:01 <joelteon> it does
14:33:07 <haasn> yeah that is kind of misleading
14:33:31 <haasn> might be a good idea to unlist unsafe* from hoogle's index
14:34:04 <hpc> perhaps exclude their types from unifying with anything else
14:34:18 <hpc> but let them still be found by name or exact type match
14:34:27 <tulcod> that sounds confusing
14:34:56 <applicative> disagreement about what laws monoids should follow?
14:35:02 <jmcarthur> i asked a variant of this question a day or two ago, but i have modified it since then. suppose you do not have Nu->Mu. if you were stuck on an island with your choice of one or two recursion schemes, what would they be?
14:35:12 <haasn> applicative: law 1: they should be easy
14:35:25 <applicative> Nu, of course jmcarthur
14:35:39 <jmcarthur> Nu is a recursion scheme? wat?
14:35:59 <applicative> oh, i didn't read the last bit
14:36:08 <applicative> I want unfold, ana
14:36:43 <haasn> I would want a catamorphism
14:36:54 <haasn> why? because bananas would be a nice thing to have access to on a deserted island
14:37:24 <jmcarthur> the point is i'm wondering what primitives would be nice to have in the absense of Nu->Mu
14:37:26 <applicative> somehow i think hylo is the Right Answer to this mysterios question
14:37:40 <jmcarthur> hylo kind of *is* Nu->Mu and so is disqualified
14:37:45 <applicative> haha
14:37:56 <applicative> in haskell we have mu -> nu or is that too simple
14:38:07 <jmcarthur> Mu->Nu can be taken as a given
14:38:08 <applicative> damn i meant nu -> mu
14:38:10 <ReinH> Should ghc 7.6.3 take hours to compile on a latest macbook pro? Seems unusually slow.
14:38:10 <JustAPerson> Can someone explain the difference the lists here? http://ideone.com/3PxkRq
14:38:13 <jmcarthur> bah
14:38:23 <luite> ReinH: use -j8 or similar
14:38:24 * applicative votes jmcarthur off the island
14:38:33 <applicative> he's too hard to follow
14:38:35 <JustAPerson> ReinH: it took me like 30 minutes with 6 cores
14:38:37 <jmcarthur> applicative: Nu-Mu requires a recursive definition in haskell
14:38:42 <ReinH> JustAPerson: seems more reasonable
14:38:44 <jmcarthur> *Nu->Mu
14:39:22 <applicative> right, I only ever think of Nu -> Fix , but that is recursive; Fix -> Nu is beautiful
14:39:33 <jmcarthur> right, as is Mu -> Fix
14:39:54 <jrh> applicative: no, about special ones for MonadPlus
14:39:59 <applicative> yea i don't really believe in Mu it's just a church encoded Fix
14:40:01 <jmcarthur> but Nu -> Fix and Fix -> Mu are recursive
14:40:04 <applicative> orsomething
14:40:56 <haasn> > [1, 3 .. 10 :: Double]
14:40:57 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
14:41:23 <haasn> > [1, 3 .. 10 :: Integer]
14:41:24 <lambdabot>   [1,3,5,7,9]
14:41:26 <JustAPerson> haasn: is it because division expects a Floating type?
14:41:39 <haasn> looks like they have inconsistent Enum implementations
14:41:43 <haasn> JustAPerson: yes
14:41:56 <jmcarthur> applicative: Mu seems to be dual to Nu in all the right ways, though
14:42:00 <applicative> jrh, were you talking to me? i cant follow
14:42:26 <applicative> I wonder what you folks have been reading though
14:42:29 <applicative> jmcarthur:
14:42:58 <applicative> my impression was that the canonical way of writing a muF in haskell is 'Fix' as we were calling it
14:43:04 <jmcarthur> i've not been reading much in particular
14:43:12 <jrh> applicative, yeah, it was a reply to your 22:34 post unless I misunderstood :)
14:43:15 <applicative> sorry I mean in Haskell or any like language that can write Fix
14:43:22 <applicative> in haskell Mu ~ Fix ~ Nu
14:43:42 <applicative> in the other languages Mu ~ Fix, but Nu is different, or is my memory all wrong
14:43:45 <jmcarthur> applicative: i think it's interesting to consider what conversions require recursion though
14:44:26 <applicative> since in haskell Mu ~ Fix ~ Nu any can be taken as muF or nuF
14:44:52 <applicative> but in say Idris, muF will have to be Mu F or Fix F; nuF will have to be Nu f
14:44:53 <jmcarthur> applicative: what about in haskell without letrec?
14:45:00 <applicative> oh maybe
14:45:18 <applicative> i haven't studied this since I was figuring out stream fusion !
14:45:23 <jmcarthur> i don't know much about Idris's treatment of this
14:46:01 <applicative> in a strict total language, nu /= mu , mu is the natural thing; for nu you need a
14:46:04 <ReinH> huh. Homebrew explicitly sets -j1 because of an "intermittent race condition". Well let's change that.
14:46:07 <applicative> 'cochurch encoding'
14:46:32 <applicative> jmcarthur: this is a bit of a blur in my mind
14:47:12 <applicative> this is why i find your Mu a distraction, since no body needs it to express mu
14:47:24 <jmcarthur> in haskell
14:47:31 <jmcarthur> i'm thinking of languages that don't exist
14:47:39 <applicative> me too
14:47:59 <applicative> anylanguage than can write your Mu can write your Fix, and they will be isomorphic
14:48:07 <applicative> (I was thinking in the blur)
14:48:16 <ReinH> I like to live dangerously
14:48:25 <jmcarthur> in particular, i'm thinking of a language in which Nu->Mu exists, but only in some Partial monad or something
14:48:49 <jmcarthur> so the exercise is to try to increase the expressiveness of the language without Nu->Mu as much as possible
14:49:00 <applicative> i think i broke my idris the other day just a sec
14:49:38 <jmcarthur> Mu by itself isn't enough for Fix in this language, afaik
14:49:43 <elliott> Nu -> Mu in Partial is quite easy I think
14:49:45 <elliott> in any language with codata
14:50:00 <jmcarthur> elliott: on an implementation level you mean?
14:50:14 <jmcarthur> err, rather, i have no idea what you mean
14:50:24 <elliott> I have no idea what you mean! possibly I have no idea what I mean either
14:50:50 <jmcarthur> in this language, Mu and Nu would be type information about recursive definitions
14:51:13 <jmcarthur> and there could be some   fromCodata :: Nu f -> Partial (Mu f)   or something
14:51:29 <elliott> I was assuming you defined Mu and Nu yourself.
14:51:39 <jmcarthur> i was thinking of them as language primitives
14:51:49 <jmcarthur> there wouldn't be any recursive data type definitions possible without them
14:52:10 <jmcarthur> and perhaps for some cases you could write a definition polymorphic in whether it's Mu or Nu
14:53:10 <Peaker> jmcarthur, in lamdu we plan on using a Fix combinator for recursive types.  Do we want all the Mu/Nu stuff too? What benefits do they have over Fix?
14:53:12 <jmcarthur> and there wouldn't be any recursive let or anything either, so in order to get general recursion you would have to be in Partial
14:53:28 <Peaker> oh, you're talking about totality
14:53:35 <jmcarthur> Peaker: this is a data vs. codata thing
14:54:14 <jmcarthur> i thought lamdu was an IDE. is it also its own language?
14:54:22 <jmcarthur> oh it is
14:54:25 <jmcarthur> i misunderstood it
14:54:36 <dmj> aranea: you there?
14:54:44 <Peaker> jmcarthur, it has its own language too because the trade-offs of a textually-edited language are different from a structurally edited one
14:54:48 <jmcarthur> right
14:54:51 <jmcarthur> makes sense
14:55:49 <dmj> how do I use lambdabot's seen command?
14:56:02 <geekosaur> it doesn't have one any more. try preflex?
14:56:08 <dmj> @seen aranea
14:56:08 <lambdabot> AR4n3a
14:56:18 <jmcarthur> so anyway, to restate... the mental exercise i'm doing is how general the folds/unfolds have to be in order to be able to write most useful code outside of Partial
14:56:18 <geekosaur> preflex: seen aranea
14:56:32 <geekosaur> hm, did preflex go missing?
14:56:43 <geekosaur> yep :(
14:56:55 <dmj> AR4n3a: you there?
14:57:03 <dmj> @dice
14:57:03 <lambdabot> unexpected end of input: expecting number, "d" or "("
14:57:14 <geekosaur> errr
14:57:23 <geekosaur> it seems to have edit-corrected @seen to @elite
14:57:37 <geekosaur> or @leet, one of those
14:58:25 <dmj> @localtime
14:58:25 <lambdabot> Local time for dmj is Sat Jul 20 16:58:04 2013
14:58:28 <aristid> @vixen remember?
14:58:29 <lambdabot> People react to fear, not love; they don't teach that in Sunday School, but it's true.
14:59:27 <dmj> @hoogle uncurry
14:59:27 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
14:59:28 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
14:59:44 <dmj> @poll poll-list
14:59:44 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show roll
14:59:48 <dmj> @poll-list
14:59:49 <lambdabot> ["(++)","ConfusedWithVixenSituation","FlavaOfJRuby","Prelude-(.)?","best-programming-language","best-spoken-language","food","funniest-thing-in-the-whole-world","naming","nethack","president","prove-
14:59:49 <lambdabot> >","remove@src","sleep"]
15:01:24 <dmj> @seen arnanea
15:01:24 <lambdabot> ArnAn3a
15:02:59 * geekosaur tries repeating what he said before
15:03:17 <geekosaur> dmj, you're not getting @seen, the bot doesn't have that plugin any more
15:03:20 <wavewave_> hi
15:03:28 <geekosaur> you're getting @leet
15:03:33 <geekosaur> @list-plugins
15:03:33 <lambdabot> Unknown command, try @list
15:03:51 <dmj> geekosaur: ohhh i see
15:03:55 <dmj> @list
15:03:55 <lambdabot> What module?  Try @listmodules for some ideas.
15:04:01 <dmj> @listmodules
15:04:02 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap
15:04:02 <lambdabot> source spell system tell ticker todo topic type undo unlambda unmtl version where
15:04:17 <dmj> @search aranea
15:04:17 <lambdabot> Unknown command, try @list
15:04:34 <geekosaur> @list search
15:04:34 <lambdabot> search provides: google gsite gwiki
15:04:47 <dmj> @list check
15:04:47 <lambdabot> check provides: check
15:05:04 <dmj> @check aranea
15:05:05 <lambdabot>   Not in scope: `aranea'
15:05:10 <dmj> @help
15:05:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:05:15 <dmj> @help check
15:05:15 <lambdabot> check <expr>
15:05:15 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
15:05:36 <dmj> @help check (5==5)
15:05:36 <lambdabot> check <expr>
15:05:36 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
15:05:51 <haasn> dmj: /msg lambdabot
15:06:22 <dmj> haasn: thanks, sry about the spam
15:06:54 <dmj> haasn: anything starting with back slash isn't seen globally right?
15:07:04 <dmj> haasn: forward slash
15:08:07 <geekosaur> if I understand your question, / is usually your IRC client's command prefix
15:08:46 <geekosaur> some things you prefix with it may still go to the channel (mine for example has /say which lets you send something starting with a slash)
15:09:09 <geekosaur> or you can /msg a channel although most channels ignore such unless you've /join-ed them
15:09:24 <cdk> :t (id &&& f)
15:09:25 <lambdabot> (Show a, FromExpr c') => a -> (a, c')
15:09:28 <haasn> dmj: depends on your client
15:09:42 <elliott> +n is the boringest channel mode
15:09:46 <haasn> dmj: but generally / is reserved for client-side commands. Some clients simply pass anything written after it to the server verbatim
15:09:54 <haasn> in that case you'd want /privmsg lambdabot foo
15:10:06 <haasn> or :foo, or whatever
15:10:09 <haasn> off-topic either way
15:11:53 <dmj> haasn: last q, if I privmsg a user that isn't on will they get it next time they logon?
15:12:00 <applicative> Peaker: oh, I thought lambdu was supposed to be something we could plug various languages into
15:12:08 <geekosaur> no
15:12:08 <Tene> dmj: No.
15:12:14 <applicative> an editor for appropriately typed languages, Peaker
15:12:23 <dmj> Tene: is there anyway to do that?
15:12:24 <geekosaur> you can use memoserv if they're registered
15:12:53 <dmj> geekosaur: ok
15:13:07 <Tene> /msg memoserv help
15:17:23 <Peaker> applicative, lamdu will eventually (hopefully) be able to edit DSLs and other languages just as it will edit rich data types with rich UIs
15:17:26 <Fuuzetsu> guys
15:17:30 <Fuuzetsu> >[1, 3 .. 10] :: (Enum t, Fractional t) => [t]
15:17:33 <Peaker> applicative, but for the shorter term it aims to edit a Haskell-like language
15:17:37 <Fuuzetsu> > [1, 3 .. 10] :: (Enum t, Fractional t) => [t]
15:17:38 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
15:17:55 <Fuuzetsu> Why does it go to 11? Ill-defined enum?
15:18:13 <Fuuzetsu> > [1, 3 .. 10] :: [Integer]
15:18:14 <lambdabot>   [1,3,5,7,9]
15:19:27 <Peaker> > ([1.0,3..10], [1,3..10])
15:19:29 <lambdabot>   ([1.0,3.0,5.0,7.0,9.0,11.0],[1,3,5,7,9])
15:19:37 <Peaker> definitely seems like a bug
15:19:39 <geekosaur> Fuuzetsu, because of the rather dubious definition of Enum for Double (which it will have used defaulting to get from your constraint)
15:20:04 <geekosaur> there was recently (yet another) mailing list discussion/rant about that instance
15:20:19 <Fuuzetsu> Right, I thought so. Wasn't there a discussion recently about changing it?
15:20:20 <Fuuzetsu> yes
15:21:49 <pentace> > succ 1.0 :: Double
15:21:50 <lambdabot>   2.0
15:23:21 <tulcod> dmwit: are you available for some chatting about binding X11-ish stuff? i'm trying to write bindings to libxkbcommon
15:23:42 <applicative> wow that Enum bug is amazing
15:24:11 <jrh> looks like Float and Rational do it too
15:24:39 <geekosaur> "amazing" is not the word I would use (then again the word I would use probably doesn't belong in the channel :)
15:24:40 <applicative> the 'correct' behavior for float and co. is wierd enough ....
15:25:26 <applicative> someone should put it on the trak, for sure
15:25:56 <applicative> enumFromTo (1.0) 10
15:26:05 <applicative> > enumFromTo (1.0) 10
15:26:05 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
15:26:36 <applicative> > enumFromThenTo (1.0) (3.0) 10
15:26:37 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
15:26:40 <applicative> haha
15:27:02 <applicative> pardon ridiculous parentheses.
15:27:48 <jrh> > [1,1.5..10.74]
15:27:49 <lambdabot>   [1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5,6.0,6.5,7.0,7.5,8.0,8.5,9.0,9.5,10...
15:29:08 <jrh> > [7,7.5..10.74]
15:29:09 <lambdabot>   [7.0,7.5,8.0,8.5,9.0,9.5,10.0,10.5]
15:29:11 <jrh> > [7,7.5..10.75]
15:29:12 <lambdabot>   [7.0,7.5,8.0,8.5,9.0,9.5,10.0,10.5,11.0]
15:29:17 <jrh> what?
15:29:39 <geekosaur> pretty much :)
15:30:17 <pentace> @src enumFromThenTo
15:30:17 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:30:58 <geekosaur> pt
15:31:08 <geekosaur> it's an instance function, I believe?
15:31:28 <pentace> right
15:31:39 <geekosaur> yep, so each type that instances Enum has to provide its own
15:31:58 <applicative> yes its under class enum, but I guess there's a default implementation?
15:32:14 <pentace> enumFromThenTo n n' m =  takeWhile (if n' >= n then (<= m) else (>= m)) (enumFromThen n n')
15:32:33 <pentace> > (\n n' m =  takeWhile (if n' >= n then (<= m) else (>= m)) (enumFromThen n n')) 1.0 3.0 10.0
15:32:34 <lambdabot>   <hint>:1:10: parse error on input `='
15:32:44 <pentace> > (\n n' m ->  takeWhile (if n' >= n then (<= m) else (>= m)) (enumFromThen n n')) 1.0 3.0 10.0
15:32:45 <lambdabot>   [1.0,3.0,5.0,7.0,9.0]
15:32:51 <pentace> hmmm
15:34:02 <sobhan> does ghc beats python in speed?
15:34:42 <geekosaur> ISTR from the mailing list discussion that Double, at least, specifically provides a (bogus) enumFromThenTo
15:34:53 <Peaker> sobhan, by far, most of the time
15:34:55 <haasn> python isn't a Haskell interpreter
15:35:27 <Peaker> yes, but if you transliterate a python program into Haskell, as-is, and run it through GHC, it's probably going to run significantly faster
15:35:38 <Peaker> (than CPython, at least)
15:35:45 <applicative> is the enum bug perceptible in numericEnumFromThenTo here https://raw.github.com/ghc/packages-base/9b7c1b1205de7e05b424f20432607c114a679859/GHC/Real.lhs
15:38:12 <jrh> that's the one used by Double
15:39:42 <pentace> > let numericEnumFromThen n m = n `seq` m `seq` (n : numericEnumFromThen m (m+m-n)); numericEnumFromThenTo e1 e2 e3 = takeWhile predicate (numericEnumFromThen e1 e2) where { mid = (e2 - e1) / 2; predicate | e2 >= e1  = (<= e3 + mid) | otherwise = (>= e3 + mid) } in numericEnumFromThenTo 1.0 3.0 10.0
15:39:43 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
15:47:25 <Fuuzetsu> This is pretty dumb:
15:47:36 <Fuuzetsu> > map (* 1.0) [1, 3 .. 10]
15:47:37 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
15:47:56 <Fuuzetsu> > [1, 3 .. 10]
15:47:57 <lambdabot>   [1,3,5,7,9]
15:47:57 <haasn> it's incredibly dumb
15:48:08 <Fuuzetsu> > map (* 1.0) [1,3,5,7,9]
15:48:09 <lambdabot>   [1.0,3.0,5.0,7.0,9.0]
15:48:11 <haasn> I knew Enum was bad, but I thought it was at least consistent in its badness
15:48:11 <dmwit> tulcod: Sure, though despite what it looks like I'm probably not the right person to ask.
15:48:17 <geekosaur> welcome to IEEE floating point
15:48:20 <Fuuzetsu> That is just horrible
15:48:22 <dmwit> tulcod: I'm the maintainer only because nobody else is, not because I know what's going on. =P
15:48:26 <Fuuzetsu> geekosaur: that's not even the problem here right now
15:48:39 <tulcod> dmwit: hm, okay.... well i'll ask either way, at least you're a proper haskell dev :)
15:48:40 <Fuuzetsu> the issue is that it should be [1,3,5,7,9] mapped over
15:48:40 <haasn> geekosaur: no, it's just the bad enumFromThenTo
15:49:04 <tulcod> dmwit: the X11 bindings have this file called Types.hsc which is basically a humongous list of enums and such
15:49:04 <haasn> 9 < 10 < 11 -- even with IEEE floating point =P
15:49:06 <dmwit> Welcome to the Report's attempt to deal with rounding.
15:49:37 <dmwit> s/rounding/rounding errors/
15:49:41 <tulcod> dmwit: libxkbcommon is a proposed replacment of XKB.h, and i want to make clean bindings. do you suggest I do that as well? maybe 'sed' it from the originals?
15:49:47 <ignacio> [1,3..10] :: [Int]
15:49:50 <ignacio> > [1,3..10] :: [Int]
15:49:51 <lambdabot>   [1,3,5,7,9]
15:49:55 <ignacio> > [1,3..10] :: [Double]
15:49:56 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
15:50:22 <elliott> there is a proposal to fix the instances on libraries@ to be a lot better
15:50:31 <tulcod> dmwit: the X11 bindings use simple "type" statements for some option flags, with a note saying "todo convert to newtype". is that an actual improvement, and how would i go about it?
15:50:35 <elliott> last I checked a lot of people were voting against because they hate the fact that Enum exists at all
15:50:45 <elliott> which, you know. that's libraries@ for you.
15:50:54 <Fuuzetsu> > map (* 1.0) ([1, 3 .. 10] :: [Int])
15:50:55 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
15:50:55 <lambdabot>    arising from the lit...
15:50:57 <Fuuzetsu> > map (* 1.0) ([1, 3 .. 10] :: [Integer])
15:50:58 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Type.Integer)
15:50:58 <lambdabot>    arising f...
15:50:59 <Fuuzetsu> :t (*)
15:51:00 <lambdabot> Num a => a -> a -> a
15:51:03 <tulcod> elliott: libraries@?
15:51:07 <elliott> tulcod: the mailing list
15:51:11 <tulcod> ah
15:51:28 <Fuuzetsu> @hoogle Integer -> Double
15:51:28 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
15:51:28 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
15:51:28 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
15:51:31 <dmwit> tulcod: regarding type vs. newtype: newtype is an improvement in the sense that it gives the type system a few hints. So the user doesn't accidentally mix up the new type and the thing it's wrapping.
15:51:41 <Fuuzetsu> > map fromInteger [1,3,5,7,9]
15:51:42 <lambdabot>   [1,3,5,7,9]
15:51:49 <Fuuzetsu> > map fromInteger [1, 3 .. 10]
15:51:50 <lambdabot>   [1,3,5,7,9]
15:51:51 <Fuuzetsu> ah, there we go
15:52:01 <dmwit> tulcod: regarding "should I create a Types.hsc": I'm afraid I don't remember enough details to give advice. What are the alternatives you're considering?
15:52:03 <Fuuzetsu> > map fromInteger [1, 3 .. 10] :: [Double]
15:52:04 <lambdabot>   [1.0,3.0,5.0,7.0,9.0]
15:52:30 <tulcod> dmwit: well basically i can choose between importing a list of keycode #defines, and just rely on the user to import such a list
15:52:52 <tulcod> dmwit: i can imagine many applications in which such a list is not necessary for implementation, and the INT values are just passed along
15:53:07 <tulcod> but eventually someone will have to interpret them
15:53:23 <Fuuzetsu> elliott: They hate that Enum exists for floating point, not all together, right?
15:53:28 <dmwit> Is it reasonable to ask each user to import the #defines?
15:53:49 <dmwit> Fuuzetsu: altogether; Enum is just a weird class in total
15:54:00 <tulcod> dmwit: i don't know, is it? it's a C file you can find on X11 systems which have header files
15:54:08 <elliott> Fuuzetsu: I assume they just hate progress. the proposal has no downsides.
15:54:50 <Fuuzetsu> dmwit: Enum is perfectly reasonable for Integer
15:54:58 <Fuuzetsu> Although I can't think of many other examples
15:54:59 <dmwit> tulcod: I dunno. The point of libraries is code reuse, right? So if you're asking what I would want as a user, the answer is I would not want to have to understand the FFI well enough to import C stuff by hand.
15:55:15 <dmwit> Fuuzetsu: It goes through Int! That's not okay for Integer.
15:55:25 <dmwit> > fromEnum (2^65)
15:55:26 <lambdabot>   0
15:55:29 <dmwit> =/
15:55:45 <Fuuzetsu> :t fromEnum
15:55:46 <lambdabot> Enum a => a -> Int
15:56:01 <Fuuzetsu> well, I was thinking in terms of succ and pred
15:56:05 <tulcod> dmwit: thanks, i'll take that into consideration
15:56:28 <Fuuzetsu> >Convert to an Int. It is implementation-dependent what fromEnum returns when applied to a value that is too large to fit in an Int.
15:56:36 <Fuuzetsu> Why is this an ‘Int’ to begin with…
15:56:48 <tulcod> dmwit: i think this is the final question for now: when should i attract people's attention, and which people specifically? i'm a haskell noob, but i'm confident this library will be the future of linux keyboard handling, and want to get this right
15:59:33 <dmwit> I would say attract people as soon as you have something usable.
15:59:43 <dmwit> Send a mail to the Haskell mailing list or post to the Haskell subreddit.
16:00:40 <tulcod> okay, thanks for your advice :)
16:01:12 <dmwit> Fuuzetsu: Even succ and pred are a bit odd.
16:01:16 <dmwit> > succ ()
16:01:17 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
16:01:19 <dmwit> =/
16:03:11 <Fuuzetsu> :t succ
16:03:11 <lambdabot> Enum a => a -> a
16:03:23 <Fuuzetsu> why is there an Enum for ()
16:03:41 <Fuuzetsu> it's just the fault of whoever thought giving everything an Enum instance was a good idea
16:03:49 <dmwit> > succ True
16:03:50 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
16:03:51 <elliott> it's a perfectly reasonable instance.
16:03:51 <Peaker> > [()..()]
16:03:52 <lambdabot>   [()]
16:04:00 <Fuuzetsu> it's not the fault of the class itself, is it?
16:04:03 <elliott> () is an enumeration with one-element. respect the base cases
16:04:16 <dmwit> > succ (maxBound :: Int)
16:04:17 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
16:04:21 <elliott> if you accept Char is reasonable, then Bool is, and then () is
16:04:31 <dmwit> > succ '\1114111'
16:04:32 <lambdabot>   *Exception: Prelude.Enum.Char.succ: bad argument
16:04:34 <Peaker> Fuuzetsu, why do we need an identity function?  id x = x, just use x...
16:04:49 <Fuuzetsu> Peaker: because it's useful
16:04:51 <Fuuzetsu> :t flip id
16:04:52 <lambdabot> b -> (b -> c) -> c
16:05:03 <jrh> whoosh
16:05:24 <Peaker> Fuuzetsu, the trivial seemingly-useless-on-their-own functions/instances are useful in the grand scheme of things
16:05:30 <dmwit> Fuuzetsu: If you remove Enum instances for all the finite types, you're not left with very much at all.
16:05:45 <elliott> dmwit: and all the things you're left with are wrong, because Int.
16:05:55 <dmwit> ...and all the things you're left with are wrong, because Int.
16:05:56 <dmwit> exactly
16:06:00 <elliott> lol
16:06:02 <Fuuzetsu> dmwit: does this warrant removal of Enum all together, including the instances for infinite types?
16:06:04 <elliott> please tell me you didn't type that independently
16:06:08 <elliott> the exact same way
16:06:10 <dmwit> I didn't. =)
16:06:13 <Fuuzetsu> You should be removing the a -> Int functions
16:06:14 <elliott> ok, good
16:06:23 <elliott> I was worried for a minute.
16:06:27 <dmwit> Fuuzetsu: I think Enum needs to be revamped, yes.
16:06:58 <Fuuzetsu> Right.
16:07:18 <dmwit> (That said, this fact should not stand in the way of fixing existing instances, if that's possible.)
16:07:29 <dmwit> (I don't know much about the proposal or the objections, though, so I won't say more than that.)
16:07:41 <Peaker> Fuuzetsu, Enum () is useful if you want to call a function that needs an enum instance for some "a", and your "a" happens to be () (and the function does more than just enumerate "a", most likely)
16:08:00 <Peaker> Fuuzetsu, just like "id" is useful in many cases, despite not being useful to directly apply on a value
16:08:10 <elliott> the proposal just fixes the instance to be more numerically accurate.
16:08:13 <elliott> because floating point.
16:08:33 <elliott> it goes $tinyamount above the value at most, rather than 1.0 above.
16:08:41 * hackagebot hsp 0.7.3 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.7.3 (JeremyShaw)
16:08:43 <jrh> 1.0?
16:08:49 <elliott> > [1,3..10] :: [Double]
16:08:50 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
16:08:52 <elliott> 1.0
16:08:53 <dmwit> Double's current Enum instance doesn't go 1.0 above...
16:09:08 <elliott> er, wait.
16:09:10 <jrh> > [1.0,11,106
16:09:11 <lambdabot>   <hint>:1:12:
16:09:11 <lambdabot>      parse error (possibly incorrect indentation or mismatched...
16:09:12 <elliott> ok, well, you know what I mean.
16:09:13 <jrh> > [1.0,11,106]
16:09:14 <lambdabot>   [1.0,11.0,106.0]
16:09:20 <jrh> oops.
16:09:26 <elliott> I know, how about I link it: http://www.haskell.org/pipermail/libraries/2013-July/020054.html
16:10:27 <Fuuzetsu> elliott: minimum machine-dependent increment I believe
16:11:23 <Fuuzetsu> Hmm, I don't know if it's really worth the effort just to provide damage control
16:12:36 <dmwit> Why not just roundtrip through the always-correct Rational instance?
16:13:15 <Fuuzetsu> That sounds… reasonable?
16:13:25 <elliott> because the Float/Double instances are more accurate when there is no corresponding Rational, presumably?
16:13:29 <dmwit> I guess because it doesn't really work well for incrementing by 1/3 or similar.
16:13:32 <elliott> also, mumble mumble performance.
16:13:49 <Fuuzetsu> we don't use the ‘p’ word here
16:13:56 <elliott> sure we do. I just did.
16:14:09 <Fuuzetsu> It hasn't happened if I don't acknowledge it!
16:14:24 <Fuuzetsu> it's still a thunk
16:14:26 <tulcod> dmwit: am i right that if, for example, i make keycode a newtype, then i cannot directly make that a C function argument?
16:14:29 <shachaf> Fuuzetsu: You haven't happened if we don't acknowledge you.
16:14:30 <dmwit> Although I don't see how using Double's (*) on Double's approximation of 1/3 can be better than using Rational's (*) on Rational's exact representation of Double's approximation of 1/3.
16:14:39 <shachaf> Fuuzetsu: "thunk" is such an operational word, anyway.
16:14:40 <dmwit> tulcod: No, you are not right.
16:14:42 <Fuuzetsu> shachaf: but you just did~
16:14:57 <shachaf> I don't acknowledge people who end IRC lines with '~'.
16:15:03 <Fuuzetsu> ~okay
16:15:25 <tulcod> dmwit: "Unacceptable argument type in foreign declaration: CKeycode" with "newtype CKeycode = CKeycode #{type xkb_keycode_t}"
16:15:50 <dmwit> Have you exposed (and imported) both the type and the constructor?
16:16:08 <dmwit> If not, do.
16:16:17 <tulcod> dmwit: i put "CKeycode" in the () of the module
16:16:20 <tulcod> without (..)
16:17:02 <evancz> is there a recommended library for serialization?
16:17:21 <dmwit> tulcod: Okay, there's your problem, then.
16:17:27 <dmwit> or
16:17:28 <dmwit> Wait.
16:17:30 <tulcod> dmwit: ah, i have it the wrong way around?
16:17:36 <dmwit> Just wait a second.
16:17:43 <heatsink> I think binary is used a lot.
16:17:54 <dmwit> I'm assuming here that you have "newtype CKeycode = ..." in one module and the error you reported is from a different module. Is this correct?
16:18:02 <heatsink> The "binary" package, I mean
16:18:10 <evancz> heatsink: It appears to be the more cross platform one
16:18:20 <evancz> i.e. tested on ghc and hugs :)
16:18:28 <dmwit> evancz: Do you get to choose the serialization format or do you have to work with a given format?
16:18:31 <tulcod> dmwit: yes
16:18:50 <dmwit> tulcod: Okay. Any module which uses CKeycode as a foreign type must import CKeycode's constructor.
16:18:58 <evancz> dmwit: it is my call.
16:19:04 <tulcod> dmwit: and (..) means DO expose constructor?
16:19:08 <dmwit> tulcod: right
16:19:14 <tulcod> ugh. okay yes, that can make a difference
16:19:16 <tulcod> thx
16:19:26 <evancz> I can even just print plain text because I have parsers for all of these things
16:19:41 <dmwit> evancz: Okay. binary is pretty popular for that, then.
16:19:49 <evancz> okay, cool :)
16:19:57 <elliott> check out cereal too.
16:20:09 <evancz> What is interesting about cereal?
16:20:15 <evancz> this is the one I found first
16:20:41 <Ghoul_> binary and cereal are interchangeable most of the time
16:21:00 <Ghoul_> They have a very similar interface and you can swap them out easily :)
16:21:32 <evancz> so is it a speed thing?
16:21:44 <Ghoul_> I think binary is faster than cereal
16:21:55 <Ghoul_> but dont take my word for it -- hunt down evidence or benchmarks
16:22:26 <tulcod> dmwit: ok great, it compiles :)
16:23:22 <Ghoul_> evancz: cereal has more predictable errors because it uses strict bytestrings
16:23:49 <dmwit> elliott: I don't see objections to the proposal at all, let alone ones that say we should scrap Enum. Every reply I read had a "+1" in it.
16:23:54 <Ghoul_> And there are quirks, like it uses strict bytestrings and not lazy
16:24:12 <dmwit> Screw it, use ReadP.
16:24:20 <elliott> dmwit: hmm. I definitely saw one or two -1s. maybe I was hallucinating.
16:24:25 <elliott> Ghoul_: that's not a quirk, that's a benefit.
16:24:44 <dmwit> I have to say the package description doesn't sell it as a benefit.
16:24:47 <Ghoul_> its a quirk because it makes it unsuitable for certain infinite inputs
16:25:03 <dmwit> It sells it as preventing infinite inputs, which sounds like a detriment to me.
16:25:36 <elliott> well, I don't like lazy IO. and cereal interacts better with iteratee-type stuff IME.
16:25:54 <evancz> So, it looks like binary does not automatically figure things out for custom ADTs..
16:25:54 <elliott> and, you know, being able to handle errors is pretty good.
16:26:00 <evancz> is this true?
16:26:17 <elliott> also IIRC cereal has IEEE float serialisation/deserialisation and binary doesn't (you need another package)
16:26:19 <evancz> I may be misreading
16:26:22 <elliott> (and IIRC that other package is GPL'd(!))
16:26:23 <dmwit> err... do any serialization packages automatically do things?
16:26:40 <dmwit> binary has IEEE float serialization/deserialization
16:26:47 <evancz> I don't know, I have not done this before :)
16:26:49 <dmwit> I know because I tracked it down and was amazed by how it's done.
16:26:51 <dmwit> It's horrible.
16:27:20 <geekosaur> older binary didn't have them
16:27:35 <geekosaur> but as noted, it has them now
16:28:04 <dmwit> It goes through decodeFloat/encodeFloat.
16:28:06 <dmwit> :t decodeFloat
16:28:07 <lambdabot> RealFloat a => a -> (Integer, Int)
16:28:13 <evancz> okay, so for an ADT that ends with strings, it seems like both will work alright
16:28:26 <evancz> in both, i need to do some sort of custom data scheme
16:28:48 <evancz> I am more and more tempted to just use my existing parsing infrastructure for this
16:29:39 <evancz> Is the speed gain supposed to be significant here?
16:29:40 <luite> evancz: there is a Binary instance for Double/Float but it doesn't preserve NaN
16:29:47 <luite> whoops i meant elliott
16:30:12 <luite> which i ran into when serializing the GHCJS AST when i switched to binary intermediate files last month
16:30:25 <elliott> yuck
16:30:37 <elliott> I wanted specifically the IEEE format for network use.
16:30:38 <luite> writing NaN, reading back Infinity or something like that
16:30:56 <luite> right, it uses decodeFloat/encodeFloat
16:31:02 <luite> that doesn't support those values
16:31:02 <dmwit> evancz: binary-derive might float your boat
16:31:42 <dmwit> ...or binary-generic
16:32:10 <evancz> i'll take a look :)
16:32:15 <dmwit> or generic-binary
16:32:20 <evancz> lol
16:32:26 <dmwit> Just grepping Hackage. =)
16:32:38 <evancz> I'm going to start with plain "binary" and see how it goes :)
16:32:44 <evancz> thanks for the advice!
16:33:01 <dmwit> Okay, I'll stop saying the additional libraries I'm finding.
16:33:27 <luite> evancz: so watch out writing Double/Float with it if you expect NaN, Infinity or negative zero values, and want to preserve them
16:35:20 <dmwit> Interesting.
16:35:38 <dmwit> data-binary-ieee754 essentially uses unsafeCoerce to serialize Float and Double. =P
16:37:39 <luite> dmwit: hehe that toFloat is so unsafe, it hurts ;p
16:39:18 <evancz> luite: thanks for the warning. Also, hi!
16:39:18 <dmwit> Well, I mean... what else are you going to do?
16:39:36 <luite> evancz: hi! :)
16:40:10 <dmwit> cereal does basically the same thing.
16:40:40 <dmwit> Don't really know why they play so many games to avoid unsafeCoerce, honestly.
16:40:50 <dmwit> I mean, castSTUArray, who are you kidding?
16:40:59 <luite> probably because Double is in different registers
16:40:59 <elliott> IIRC there's a specific reason for that
16:41:04 <elliott> described on GHC trac somewhere
16:41:14 <luite> by doing it through poke it gets it to the right place
16:41:50 <dmwit> hm
16:41:53 <luite> but that poke writes past the buffer if the word is bigger than the float
16:42:09 <dmwit> unsafeCoerce WFM in ghci...
16:42:22 <luite> hmm, and compiled with -O2?
16:42:29 <dmwit> Let's try it!
16:43:40 <dmwit> yes, seems to work
16:43:44 <elliott> and are you sure it'll *always* work? :)
16:43:57 <luite> i suspect it not being a problem as long as it's read directly from the heap value, but perhaps if it's a result of some unboxed computation it might crash
16:43:59 <lpaste> dmwit pasted “prints 3.0” at http://lpaste.net/91083
16:44:10 <dmwit> elliott: No, not at all. =D
16:44:57 <luite> oh perhaps it optimizes that out?
16:46:04 <heatsink> Double and Word64 are boxed
16:46:52 <dmwit> Seems to preserve +-Infinity and NaN, too, no matter what optimization level I choose.
16:47:08 <dmwit> I'll NOINLINE it to make sure it's not getting optimized away.
16:47:22 <luite> heatsink:  i know, but ghc can unbox them
16:47:51 <dmwit> Anyway, all of this seems sort of crazy.
16:48:05 <dmwit> I mean, sure it reconstitutes the Double okay on my machine. But what if I sent it to another machine?
16:48:06 <heatsink> Unboxing is based on eliminating data constructors and case expressions.
16:48:14 <dmwit> Maybe that's what all the STUArray or peek/poke stuff is about.
16:48:31 <dmwit> Like maybe peek/poke enforces some particular bit order...
16:48:54 <heatsink> Double and Word64 are _always_ boxed.  GHC can maybe extract the unboxed contents, but it won't do that if they've been coerced to a different type.
16:48:55 <dmwit> I remember last time we talked about this, though, we looked it up and the IEEE754 spec explicitly says that any bit order is okay.
16:48:56 <luite> dmwit: hmm, i doubt it
16:49:17 <Xunie> Honestly, why isn't 'hoogle.com' registered and forwarded to haskell.org/hoogle/ ?
16:49:44 <dmwit> I wouldn't be surprised if hoogle.com was kind of an expensive domain.
16:50:55 <b2coutts> we need to get lebanon to get a ccTLD
16:51:00 <b2coutts> so we can register hoog.le
16:51:06 <Xunie> Oh, even better!
16:51:46 <Xunie> dmwit, probably true because the 'g' and 'h' are together on QWERTY keyboards, and people love typo-domains.
16:51:58 <luite> heatsink: hmm, does unsafeCoerce guarantee that? it does sound like it would be rather less useful if it didn't... so perhaps this is harder to break than it looks
16:52:02 <ignacio> web2.0 names clash with that motto, "don't succeed" or whatever it was
16:52:50 <ignacio> "if too popular, add category theory"
16:53:24 <hpc> if still popular, bungle a website migration
16:54:30 <hpc> (i kid; it's really hard to move that many services from one box to another)
16:54:33 <dmwit> How do people serialize Double's in other languages?
16:54:46 <heatsink> unsafeCoerce is an explicit type cast in System F.  I'm pretty sure that most optimizations don't apply to explicit type casting.
16:54:46 <ignacio> too bad the ghc docs don't have local search, the complete index takes some time to load
16:54:56 <Xunie> dmwit, sprintf?
16:55:02 <heatsink> Probably using bit manipulation
16:55:03 <hpc> dmwit: that's easy! coerce to long and then stringify
16:55:03 <ignacio> dmwit: to full precision?
16:55:10 <dmwit> heatsink: I wouldn't be surprised if unsafeCoerce (unsafeCoerce x) could be optimized to unsafeCoerce x.
16:55:28 <hpc> dmwit: i wouldn't be surprised if unsafeCoerce gets compiled away entirely
16:55:34 <dmwit> hpc: As mentioned above, that doesn't seem like it is guaranteed to work with all IEEE 754 implementations.
16:55:37 <Xunie> I sprintf is a really wrong answer, but it's a hack. And hacks work -- most of the time.
16:55:46 <dmwit> ignacio: Yes, bit-accurate.
16:56:06 <ignacio> well, there's binary
16:56:16 <heatsink> dmwit, probably.  Two type casts can be merged together.
16:56:19 <ignacio> for scientific applications, just printf
16:56:25 <ignacio> since you're not using the full precision anyway
16:56:43 <luite> dmwit: it still works if you change the Word64 value (i did +1)
16:56:50 <dmwit> Xunie: Seems wasteful. Double's only have 8 bytes, but sprintf could potentially spit out 15 bytes or so. And it probably doesn't preserve the bits of NaN's or Infinity's or whichever one it is that has multiple representations.
16:57:02 <dmwit> Xunie: And almost certainly doesn't preserve negative zero...
16:57:15 <haasn> ignacio: “Avoid success at all costs”
16:57:18 <FreeFull> wel
16:57:18 <Xunie> I know! Bad, right?! :3
16:57:21 <FreeFull> Well
16:57:22 <ignacio> meh, space is cheap and ascii is very practical for debugging
16:57:33 <Xunie> Baudot > ASCII
16:57:35 <FreeFull> The format for doubles is set in stone
16:57:41 <FreeFull> So serialising shouldn't be too hard
16:57:49 <dmwit> luite: As in w2d . (+1) . d2w?
16:57:57 <dmwit> FreeFull: The bit order is not set in stone.
16:58:11 <luite> dmwit: right
16:58:14 <FreeFull> Well, that's why you keep everything in the same bit order
16:58:24 <ignacio> you could do it in a functional way
16:58:34 <ignacio> just specify the conditions to get that same doule
16:58:37 <ignacio> *double
16:58:40 <dmwit> luite: What does "it works" mean there? idLOLOL doesn't behave like id when I try that.
16:58:42 * hackagebot darcsden 1.1 - Darcs repository UI and hosting/collaboration app (hub.darcs.net branch).  http://hackage.haskell.org/package/darcsden-1.1 (SimonMichael)
16:58:59 <ignacio> "perform _ experiment at _ time with these scientists: [_] "
16:59:01 <dmwit> FreeFull: Two computers could use different bit orders is my point.
16:59:06 <luite> dmwit: no but it gives the expected value i guess :)
16:59:12 <dmwit> oh, okay =)
16:59:16 <luite> dmwit: no weird undefined stuff
16:59:26 <dmwit> I see what you mean, then.
17:02:02 <tabemann> hmm... do IORef and IOArray have safe semantics if multiple threads try to access them simultaneously?
17:02:07 <dmwit> I conclude that it is not binary's fault that it sucks at Double, because there is no right way to do it.
17:02:33 <dmwit> tabemann: You can have races, but not crashes.
17:02:46 <tabemann> dmwit: that's what I was asking about
17:03:01 <RichyB> dmwit, in IEEE754, the infinities have unique representations and there are a lot of different possible NaNs.
17:03:03 <dmwit> Consider MVar and MArray or TVar and TArray as race-free alternatives.
17:03:20 <dmwit> RichyB: Thanks.
17:04:08 <RichyB> The rationale is that +Inf looks reasonable, it's "sign bit zero, maximum values in both mantissa and exponent"
17:04:44 <dmwit> Does IEEE754 specify a way to query particular bits? e.g. sign bit, nth mantissa bit, nth exponent bit
17:05:07 <hpc> the sign bit, certainly
17:05:19 <RichyB> I think that 754 only specifies format and meaning, not any API
17:05:24 <hpc> er, forgot NaN
17:05:39 <dmwit> Oh, I don't believe that.
17:05:43 <dmwit> It has to specify some operations.
17:07:08 <RichyB> and when something produces a NaN value, all but one of the mantissa bits are redundant, so implementations are allowed (but I don't think required) to leave trash in the redundant bits in order to leave evidence about the source of the invalid operation around.
17:07:09 <dmwit> ugh, I keep forgetting it's not free to read the spec
17:07:17 <RichyB> I've never heard of anyone successfully making use of that.
17:07:29 <hpc> what spec?
17:07:29 <ignacio> it specifies fl(a) fl+ fl(b) = fl(fl(a)+fl(b)) and so on for * / - IIRC
17:07:37 <RichyB> The IEEE 754 spec.
17:07:42 <dmwit> hpc: Guess. I'll give you a hint: we've been discussing it for half an hour.
17:07:57 <hpc> i do not remember IEEE charging for specifications
17:08:00 <RichyB> Yeah I agree, it's serious bullshit that these things aren't properly open-access.
17:08:07 <ignacio> it's probably online somewhere
17:08:57 <jrh> 'fl+'?
17:09:06 <hpc> bah, probably been shielded from the costs by silly university stuff
17:09:45 <ignacio> jrh: the sum operator, fl+ :: Double -> Double -> Double
17:09:59 <RichyB> Yeah, if you're in a computer science department they may already have university subscriptions to IEEE xplore.
17:09:59 <ignacio> + being the exact sum of the two numbers
17:10:06 <shachaf> It's figure out Unapplicative time!
17:10:09 <shachaf> class Contravariant p => Unapplicative p where unliftA2 :: (a -> b -> c) -> (p a -> p r) -> (p b -> p r) -> p c -> p r
17:10:51 <jrh> ignacio: ah, i see
17:12:00 <ignacio> it seems I missed today's "flip id const flipout"
17:13:27 <scshunt> ignacio: that doesn't typecheck :(
17:15:11 <dmwit> :t flip id const
17:15:11 <lambdabot> ((a -> b -> a) -> c) -> c
17:15:17 <dmwit> scshunt: type-checks just fine!
17:16:13 <scshunt> :t flip id const flipout
17:16:14 <lambdabot> Not in scope: `flipout'
17:16:47 <dmwit> Seems the spec does *not* include queries for individual bits.
17:18:57 <dmwit> If you were willing to assume that the storage format was some permutation of the bits of the format, I guess you could do it by coercing to Word64 or similar.
17:19:47 <ab777> :load filename gives error  parse error on input '='
17:19:53 <dmwit> ...and also coercing known Doubles to Word64, I mean.
17:19:58 <ignacio> I bet any string of flips, ids and consts yields a valid expression
17:20:19 <ab777> New to haskell
17:20:19 <ignacio> well, valid function
17:20:25 <dmwit> ?where hpaste
17:20:25 <lambdabot> http://lpaste.net/new/haskell
17:20:29 <dmwit> ab777: You'll have to show us your code.
17:21:29 <ignacio> well, maybe with some parentheses or $
17:21:35 <ab777> ok dmwit. How?
17:21:50 <dmwit> Visit the URL lambdabot gave.
17:21:57 <dmwit> Then copy and paste.
17:22:12 <ab777> Ok thanks.
17:23:17 <dmwit> > sqrt (-0)
17:23:18 <lambdabot>   -0.0
17:23:26 <dmwit> amazing
17:23:27 <ignacio> sqrt (-1)
17:23:31 <ignacio> > sqrt (-1)
17:23:32 <lambdabot>   NaN
17:23:34 <kuribas> Why is -3.6e-4 < 1e-7 ?
17:23:47 <ignacio> cause negative
17:23:51 <dmwit> kuribas: All negative numbers are smaller than all positive numbers.
17:23:56 <kuribas> Of course, doh...
17:24:06 * kuribas needs sleep
17:24:12 <ignacio> it's not that obvious
17:24:25 <ignacio> at least I haven't proved it
17:24:54 <kuribas> lol :)
17:27:17 <ignacio> Maths teachers love to make you prove stuff like 1 > 0
17:27:35 <ignacio> s/teachers/profs/
17:30:08 <jrh> by what definition of ordering?
17:30:34 <ignacio> I'd have to get my old folder
17:30:47 <ignacio> don't recall
17:30:57 <shachaf> lightquake: There are lots of other places that need work, too.
17:30:58 <jrh> ah, it would probably be beyond me anyway :p
17:31:14 * ignacio gets his old folder
17:34:23 <ignacio> nope, can't find it
17:35:47 <jrh> ah well
17:37:13 <ReinH> Blowing away the homebrew install and just using the haskell-package binary is much easier
17:44:31 <pentace> Yesterday someone here suggested to use Cartesian trees for an efficient range searching algorithm. However, I'm not sure what data type to use for implementing them in Haskell.
17:45:40 <pentace> It should support finding a node by index and the parent for a node in O(1)
17:49:32 <ReinH> pentace: rangemin includes a cartesian tree impl iirc
17:50:58 <pentace> Unfortunately, I can't use the vector package, I'm not able to compile it :S
17:51:42 <pentace> or primitive rather which is used by vector
17:53:47 <tabemann> hmmm... maybe with safe (i.e. no problems beyond the normal problems of shared state in multithreaded environments) semantics with IORef and IOArray I could actually easily implement multithreading in my Scheme (in Haskell)...
17:54:31 <roboguy_> pentace: what sort of problem is it giving you?
17:55:04 <pentace> roboguy_: Not finding a .h file, IIRC
17:56:06 <pentace> "Missing (or bad) header file: primitive-memops.h"
17:56:06 <roboguy_> pentace: maybe it needs a non-haskell library that isn't installed?
17:56:49 <pentace> It should be part of the package
17:58:24 <xunie-laptop> Hahah: http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html
18:01:10 <jrh> I'm wounded the references to values as 'functors'...
18:02:02 <jrh> but i think i can forgive :p
18:02:53 <shachaf> That article is very misleading. :-(
18:07:22 <jrh> "Conclusion: A functor is a data type that implements the Functor typeclass." *wince*
18:08:00 <elliott> that's true. as long as you add the implied "endofunctor".
18:08:15 <shachaf> That sentence doesn't seem particularly unreasonable.
18:09:01 <jrh> Only if we qualify what it means to 'implement' the Functor class, surely?
18:10:10 <jrh> otherwise type F x = Int, fmap f x = error "haha, nope" would 'be a functor'
18:10:43 <shachaf> Huh?
18:11:46 <jrh> I mean, it seems to suggest that being an instance of Functor is what makes something a functor. Maybe just me?
18:12:39 <shachaf> Your objection is that it doesn't mention the laws?
18:13:40 <roboguy_> shachaf: which parts do you think are most misleading?
18:14:16 <shachaf> I don't really feel like giving section-by-section commentary.
18:14:39 <shachaf> One obvious thing is the whole "wrapped value" business.
18:15:41 <jrh> shachaf: Partly that, but also just a literal reading of that sentence to me suggests that, morally, it's only a functor if you make a Functor out of it.
18:16:38 <roboguy_> shachaf: that's a good point
18:16:52 <shachaf> Would you prefer: "a functor is something that *can* have a Functor instance (that satisfies the laws)"?
18:16:56 <shachaf> Seems like nitpicking.
18:17:15 <tabemann> that sounds better
18:18:53 <jrh> nitpicking maybe, but that sounds much more correct to me
18:19:55 <shachaf> OK. That article is full of much bigger errors/misleading things and that thing is only arguably an error at all. So whatever.
18:20:49 * tabemann really cringes at the monads part
18:21:22 <ignacio> wait, where do the burritos come in?
18:21:23 <blackdog> what's the article?
18:21:42 <tabemann> okay, the first part was bad, but the monads part is definitely worse
18:22:28 <shachaf> jrh: Anyway, your F *is* a functor, by your definition.
18:22:47 <ignacio> nice illustrations
18:23:16 <jrh> shachaf: fmap id x /= id ?
18:23:29 <jrh> oops, x, not id
18:23:47 * tabemann is reading the comments. they are horrible.
18:24:20 <shachaf> The type is a functor. The instance is just wrong.
18:24:38 <ignacio> what's that disease you get for leaving food inside the can?
18:24:57 <hpc> starvation :P
18:25:03 <ignacio> lol
18:25:47 <roboguy_> I'm a little worried, because I'm not sure I fully grasp why this is misleading. I guess there are examples (like functions) where the "wrapping" and "unwrapping" don't make sense and it's misleading to say that all monads (and functors, etc) work by "wrapping" values?
18:26:04 <blackdog> ignacio: botulism?
18:26:16 <blackdog> (hpc's is much funnier though :)
18:26:26 <Clint> also more accurate
18:26:38 <tabemann> roboguy_: for instance, their explanation breaks on things like concurrency and the list monad
18:26:54 <blackdog> Clint: there's always non-canned food.
18:27:29 <jrh> oh, right, of course. but the type itself can't be a functor; a functor is defined by a type and a morphism family. that F with that fmap is not a functor, though F could be a functor with the correct fmap
18:27:33 <roboguy_> tabemann: yeah that's true
18:28:30 <jrh> my point was that making the instance doesn't make a functor; that functors... induce? instances. Let's drop it.
18:29:01 <ignacio> blackdog: probably botulism
18:29:04 <joelteon> yeah i have no idea what's going on
18:29:53 <ignacio> searching the WP article on botulism for 'can' is... very annoying.
18:31:52 <tabemann> roboguy_: for starters... they don't go into that a monad basically represents a context (which may not actually be a set of values but a set of transformations upon context), and that >>= derives a value from that context and gives a new context, which it then sequences with the previous context to produce a new context (but I might be horribly wrong myself on this...)
18:32:16 <tabemann> s/a value/a set of values
18:32:27 <ignacio> using a monad is like making love to a beautiful woman
18:32:37 <ignacio> ie I don't know how to do either
18:33:00 <jrh> haha
18:33:24 <blackdog> ignacio: also similar in that people are afraid of it but it's really not that complicated? :)
18:33:33 <ignacio> this analogy is proving fruitful
18:33:49 <tabemann> the big problem with explaining monads is that some of the analogies for them sort of work with some monads, but break horribly with others once one considers all cases (i.e. all possible things that follow the monad laws)
18:34:11 <tabemann> and explaining even just the IO monad tends to break horribly once one considers concurrency
18:34:33 <jrh> To be honest, I didn't think the monad thing was that complicated when I was learning haskell (except the function monad!) - it was monad transformers that killed me.
18:36:09 <jrh> Hm. not that I'm not still learning haskell...
18:36:10 <tabemann> probably the most accurate explanations of the IO monad I've seen are that it basically does nothing, but simply encapsulates the composition of imperative computations, which are to be evaluated by the runtime... but then this explanation gives Conal Elliott's explanation of just why C is a functional language...
18:36:41 <jrh> Eh?
18:36:45 <blackdog> is there a convention for where to place test files? Ie, if i have Data.List.Foobar, should my test file be in test/Data/List/FoobarSpec.hs ?
18:37:17 <tabemann> jrh: http://conal.net/blog/posts/the-c-language-is-purely-functional
18:37:37 <ignacio> reading programming blogs considered harmful
18:39:21 <roboguy_> I never really got around to monad transformers. I (think) I understand the concept, but I've never actually tried to use them
18:39:59 <applicative> how could reading conal be harmful ignacio.
18:40:37 * applicative puts hand over heart in haskell-patriotic ferver
18:40:41 <applicative> fervor
18:41:07 <blackdog> need a haskell anthem
18:41:51 <blackdog> roboguy_: try yesod, you won't have a choice :)
18:42:06 <jrh> Huh. Never thought of it like that before!
18:42:34 <roboguy_> blackdog: sounds ominous. I've thought about trying yesod. maybe I should go for it and learn something
18:42:41 <carter> or snap
18:42:43 <carter> snap is nice
18:42:45 <carter> or hakyll
18:42:53 <scshunt> I like yesod
18:42:53 <blackdog> roboguy_: i dig scotty
18:42:58 <blackdog> but i am a bear of very little brain
18:43:09 <scshunt> I haven't actually tried to compare though
18:43:30 <roboguy_> that's part of the reason I haven't done web programming with Haskell yet: lots of choices and I'm not really sure how to choose
18:43:51 <blackdog> oh, before i launch into this library - anyone know of any longest-common-substring libraries in haskell? i couldn't find any on hackage
18:44:04 <blackdog> there's lcs, but that's subsequences, not substrings.
18:44:21 <blackdog> (confusingly, apparently subsequences are allowed to skip elements but substrings can't)
18:44:44 <applicative> my revised soviet anthem is a fail: Through days dark and stormy where Great Wadler led us/ Our eyes saw the bright sun of lambda above/ And Simon our leader with faith in the people,/ Inspired us to build up the language that we love.
18:45:01 <blackdog> roboguy_: i would start simply. have a go at something uber-simple like scotty, though carter will continue to argue that snap is just as easy i have no doubt :)
18:45:13 <carter> hakyll is nice for static site gen
18:45:14 <carter> :)
18:45:18 <carter> i need to revisit it soon
18:45:31 <blackdog> applicative: hehe. needs a reference to "unchanging through the years" or something
18:45:40 <blackdog> "our stalwart values"
18:45:54 <carter> hakyll has a clever redesign every 2ish years
18:46:02 <carter> and then i need to redoo my site :)
18:46:06 <roboguy_> I guess it can't hurt to take a look at all of them then come up with a simple project
18:46:31 <blackdog> carter: backwards compatibility is for traitors and counter-revolutionaries
18:46:50 <carter> blackdog : types prevent bit rot
18:46:59 <carter> they force you to fix things :)
18:47:28 <applicative> long live our values, immutable and pure
18:47:42 <blackdog> it's not just that, though. types don't help when you're changing the interface to just flat-out drop stuff
18:47:53 <applicative> something like, ... strong in our purity, tried by ... laziness ...
18:48:50 <applicative> carter, yes, I wrote my feeble profession webpage with hakyll before it was arrowized, now i just emend by hand
18:49:01 <applicative> professional
18:49:38 <blackdog> applicative: write it later when someone wants to sing it
18:49:52 <applicative> yes
18:50:19 <ignacio> laziness is hard to work into an anthem
18:51:25 <applicative> yes, ignacio I was noticing that...
18:51:34 <applicative> hair shirts too
18:52:43 <carter> applicative its no de arroed again right?
18:55:21 <lpaste> stevejb pasted “trouble installing monad-par” at http://lpaste.net/91084
18:55:55 <stevejb> specifically, it seeems like there is a problem with abstract-par-accelerate
18:55:59 <stevejb> has anyone seen this?
18:56:05 <shachaf> I don't know what mega-install is but it sounds fishy.
18:56:07 <applicative> carter, I think there have been one or two revolutions since the one I couldn't face signing on to.
18:56:19 <shachaf> The problem isn't with monad-par itself at any rate.
18:56:22 <Fuuzetsu> @src reverse
18:56:23 <lambdabot> reverse = foldl (flip (:)) []
18:56:30 <applicative> Not that I actually decide no to , carter , it didn't happen.  Maybe now it'll be easier
18:56:38 <ignacio> @src seq
18:56:38 <lambdabot> Source not found. Whoa.
18:56:40 <stevejb> shachaf: the `make mega-install` command comes from the readme of monad-par
18:56:42 <stevejb> https://github.com/simonmar/monad-par
18:56:55 <scshunt> has anyone here experience with both yesod and snap?
18:56:55 <applicative> stevejb: oh, accelerate will have c library dependencies, no?
18:57:08 <shachaf> If you just want monad-par you can `cabal install monad-par`.
18:57:19 <shachaf> This installs a bunch of other packages.
18:57:36 <applicative> scshunt: it turns out you dont need experience with either to have an opinion
18:57:43 <stevejb> applicative: shachaf: I think that what is going on is I already have a version of accelerate installed
18:57:44 <scshunt> applicative: fair enough
18:57:50 <scshunt> applicative: do you have an opinion?
18:58:06 <stevejb> shachaf: what you suggested worked
18:58:08 <shachaf> stevejb: Are you installing this for accelerate or are you just after plain old monad-par?
18:58:14 <applicative> scshunt: just kidding, I was implicitly warning that people get a little passionate
18:58:20 <stevejb> shachaf: just monad-par
18:58:29 <shachaf> There's no reason for you to get git repositories etc. for that.
18:58:31 <applicative> stevejb: that what was wonder, idont have accelerate, or let me check
18:58:46 <carter> applicative nope… the c lib stuff is in a separate package i think
18:58:48 <carter> scshunt I did some work using snap last fall
18:58:48 <carter> and theres a few companies in nyc using snap
18:59:05 <applicative> stevejb: oh wait are you doing some kind make inside the git repo?
18:59:11 <scshunt> carter: and?
18:59:16 <carter> its pretty nice
18:59:30 <carter> its got a really nice extensible design
18:59:35 <carter> needs more docs love
18:59:39 <carter> but the core tools are nice
18:59:53 <stevejb> applicative: yeah that was the idea. I cloned the repo, cloned the submodules, and then did the suggested make
18:59:54 <scshunt> from a brief look, Yesod seems more industrial-scale. More work to get working initially, but also better at complex sites
19:00:05 <stevejb> it may have been overkill
19:00:35 <pentace> Can zippers be used to implement doubly-linked trees?
19:00:56 <ignacio> @src openFile
19:00:56 <lambdabot> Source not found. Just try something else.
19:02:21 <applicative> stevejb: I used the git repo but skipped the accelerate and cuda stuff
19:02:24 <roboguy_> ignacio: it seems to me that seq and openFile would have to be at least partially defined in a non-Haskell language (probably C)
19:02:50 <applicative> stevejb: you can just enter the directories in sequence and do cabal install
19:03:20 <stevejb> applicative: thank you. I am now working on running through the par tutorial code which seemed to compile fine
19:04:10 <applicative> ah so you have monad-par installed
19:04:36 <applicative> stevejb: ah, you mean the code in the other github repo par-examples or whatever
19:04:48 <applicative> I take it saw the book was out, stevejb
19:07:24 <NemesisD> ok i must not understand enough about monadtransformers and MonadReader
19:07:48 <applicative> @unmtl ReaderT conf IO ()
19:07:48 <lambdabot> conf -> IO ()
19:08:36 <NemesisD> i'm trying to specify that m is a monad transformer stack with reader capabilities: transition :: (Monad m, MonadReader (StateMachine s m a) m2) => s -> m2 a
19:08:58 <NemesisD> erm m2
19:10:17 <stevejb> applicative: yes I saw that the book was out. Have it on preorder
19:10:45 <stevejb> I seemed to have just solved 16000 sudoku puzzles in parallel :)
19:12:37 <NemesisD> i'm trying to simplify this state machine experiment i was doing by rethinking the types and leaving everything undfined until i get the types worked out
19:12:37 <ignacio> roboguy_: ghc is written in haskell
19:12:49 <ignacio> so... maybe it just uses openFile
19:12:53 <roboguy_> ignacio: the runtime system is in C
19:12:57 <ignacio> no wait that doesn't make sense
19:13:04 <ignacio> since it produces machine code
19:13:13 <ignacio> ghci could get away with that
19:13:17 <lpaste> NemesisD pasted “monad reader transformer” at http://lpaste.net/91085
19:13:26 <NemesisD> could anyone give me a hand with  that
19:14:07 <ignacio> roboguy_: runtime system = ?
19:14:45 <roboguy_> ignacio: it does the garbage collection, among other things
19:15:05 <roboguy_> it also handles +RTS options given to your executable
19:16:29 <ignacio> is it a library the executables are linked against?
19:16:50 <roboguy_> ignacio: yeah, I think that's how it works
19:17:11 <ignacio> k
19:17:20 <ignacio> see ya
19:18:45 * hackagebot tianbar 0.2.0.0 - A desktop bar based on WebKit  http://hackage.haskell.org/package/tianbar-0.2.0.0 (AlexeyKotlyarov)
19:18:47 * hackagebot data-fin 0.1.0 - Finite totally ordered sets  http://hackage.haskell.org/package/data-fin-0.1.0 (WrenThornton)
19:22:26 <NemesisD> is it just me or are transformers' types way harder to read than mtl's
19:22:38 <carter> some of the RTS is in CMM and there are things that might be RTS in other languages which are haskell level coe
19:22:38 <carter> *code
19:24:21 <applicative> NemesisD: transformers has types, mtl has classes, to put it crudely --no?
19:24:26 <Fuuzetsu> @src foldl1
19:24:26 <lambdabot> foldl1 f (x:xs) = foldl f x xs
19:24:26 <lambdabot> foldl1 _ []     = undefined
19:25:26 <NemesisD> guess i need to hunt for some examples
19:26:00 <roboguy_> carter: oh, I didn't know that
19:26:19 <applicative> i cant figure out how this is supposed to work NemesisD runStateMachine :: Monad m => StateMachine s m a -> m b -> m (b, s)
19:26:28 <roboguy_> carter: do you know if the CMM is generated? is there a reason to hand write CMM?
19:26:42 <carter> roboguy_ both
19:26:53 <carter> look at primops.cmm in the ghc source tree
19:26:56 <carter> for some hand written ones
19:27:25 <applicative> NemesisD: I see the idea, the whole state machine is stored by a map rather than a function s -> m (a,s)
19:27:26 <carter> cmm is also the low level IR for haskell code before code gen (ghc style c minus minus = cmm)
19:27:36 <applicative> NemesisD: or something like that
19:28:38 <roboguy_> carter: hmm, I don't see primops.cmm
19:28:50 <carter> roboguy_ is in the ghc SOURCE tree
19:28:52 <carter> :)
19:28:56 <carter> lemme grab a link
19:29:37 <carter> https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm roboguy_
19:29:38 <roboguy_> carter: oh I see it
19:29:53 <carter> the 7.8 dialect of CMM is much nicer :)
19:30:30 <NemesisD> applicative: its going to stuff a StateT s m a in the stack
19:30:30 <carter> than the <= 7.6 dialects
19:31:28 <applicative> NemesisD: where does StateMachine fit in
19:31:32 <roboguy_> carter: 7.8 isn't publicly available yet, is it?
19:31:37 <carter> nope
19:31:40 <carter> not ready yet
19:31:46 <carter> roboguy_ do you have a mac?
19:31:49 <roboguy_> yeah
19:31:54 <NemesisD> eventually transition is going to utilize a ReaderT for the StateMachine and a StateT for the current state
19:31:56 <carter> if so johnw  has nightlys at ghc.newartisans.com
19:32:23 <carter> or you could learn to build from source
19:32:31 <carter> roboguy_ also: don't install xcode  for a wee while
19:32:36 <roboguy_> carter: cool, thanks. I think I might look through the source sometime
19:32:36 <carter> *xcode 5
19:32:44 <roboguy_> carter: what if I already installed xcode?
19:32:49 <carter> roboguy_ xcode %
19:32:50 <carter> 5
19:32:52 <carter> not 4.6
19:33:01 <carter> the dev preview
19:33:02 <carter> don't
19:33:05 <carter> at least not yet
19:33:10 <roboguy_> oh ok
19:33:12 <carter> "xcode 5"
19:33:19 <roboguy_> it doesn't work on xcode 5?
19:33:21 <carter> theres some up stream patches that clang will be getting
19:33:24 <carter> that haven't landed yet
19:33:28 <carter> roboguy_ dont' worry about it
19:33:34 <carter> i made sure apple knows
19:33:39 <roboguy_> carter: alright, that's good
19:33:49 <applicative> suddenly I can't remember, why isn't (Map k) a monad?
19:33:51 <carter> just for now: dont' install any xcode 5 dev prview
19:34:28 <NemesisD> applicative: it needs to be able to read the statemachine to figure out what transitions are valid and what actions it should execute if it transitions, it will use the StateT on s so it can read the old state on transition and set the new one, kind of convoluted but does that make sense/sound reasonable?
19:34:36 <roboguy_> carter: I wish apple would fix this kernel panic I keep having... apparently the bug has been around a while too. but that's another subject
19:34:44 <carter> roboguy_ have you reported it?
19:34:47 <carter> what triggers it?
19:35:13 <roboguy_> carter: well, I used the "report to apple" button on the crash window. I don't know if that makes much a difference. I haven't submitted an actual report
19:35:38 <applicative> NemesisD: but why not make your Map or maplike thing, Map s (m a, s) so the new state is registered in the Map which doesn't change
19:35:47 <roboguy_> carter: if I close emacs while it's running another process (like ghci) the computer crashes so hard it restarts immediately
19:36:25 <roboguy_> I guess a lot of end users wouldn't see that, but it's kind of a major issue when I forget to close ghci before I close emacs
19:36:36 <carter> bugreport.apple.com
19:36:42 <carter> write a detailed ticket
19:36:49 <NemesisD> applicative: not sure if i understand, but StateMachine is not meant to change at all, it is to specify a reusable specification of a statemachine, running it will have some side effects and produce a final state
19:36:57 <carter> about how to reproduce it / deterministically induce it
19:37:02 <carter> including the versions of all the software
19:37:17 <carter> since its both a SYSTEMS and Language support issue
19:37:39 <roboguy_> carter: yeah, that's a good point. I just haven't gotten around to it. I guess I could do it now. It's actually very consistent and reproducable in my experience, so at least that should help
19:37:46 <NemesisD> applicative: oh wait i think i understand what you're saying. that would be okay except it only allow 1 transition *from* any state
19:37:49 <carter> roboguy_ please take the time to do it
19:37:55 <carter> they're actually really really responsive
19:38:09 <NemesisD> since maps remove duplicates on k (i assume?)
19:38:10 <carter> you may want ot file it as two bugs and have them reference eachother
19:38:14 <applicative> NemesisD: that's what I was thinking, the Map is just referred to, but if its like mine, an initial state s will give a (Maybe) (m a, s2); I run m a, then lookup s2 etc
19:38:20 <carter> well
19:38:22 <carter> 1 bug
19:38:39 <applicative> NemesisD: I dont actually have a brain so there is probably a muddle in this. I make do.
19:39:13 <carter> roboguy_ point being: report it :)
19:39:24 <roboguy_> carter: part of the reason I put it off is that I've heard people have been filing reports for this for a year or more with no apparent fix. but I guess that's a reason *to* file a report
19:39:45 <carter> roboguy_ have you see the sorts of bugs people file?
19:39:48 <carter> most are crap :)
19:39:55 <carter> or are not Apple side ones
19:39:56 <roboguy_> carter: ahhh, well that makes sense then
19:40:00 <NemesisD> applicative: yeah sounds similar to mine, except i need to allow multiple transitions from s1, i.e. s1 to s2, s1 to s3
19:40:03 <applicative> on that picture, effectively, it would be type StateMachine s m = St (Map s (m (),s))
19:40:24 <carter> roboguy_ a dude who does mac dev filed a bug related to the one i filed
19:40:31 <carter> and it was closed as being a duplicate of mine
19:40:44 <applicative> oh i see, I was missing this many transitions bit, ...
19:41:15 <NemesisD> applicative: i've never used ST
19:41:42 <carter> roboguy_ point being: without noise: nothing is heard
19:41:52 <carter> if you can also demonstrate that is OS side
19:41:53 <applicative> oh i didnt mean ST , i just used St as an arbitrary wrapper
19:41:57 <carter> rather than application side being shitty
19:41:58 <NemesisD> ugh why does google's index always prefer GHC 6x documentation
19:42:04 <carter> roboguy_ might also be an emacs bug?
19:42:06 <NemesisD> applicative: oh ok
19:42:39 <applicative> yes, that was a  muddle, it should have been newtype SMach s m = SMach (Map s (m (), s))
19:42:48 <roboguy_> carter: I've heard of other applications having a similar problem. I think it has something to do with running a process in a process or something like that
19:42:55 <carter> ahh
19:43:05 <carter> well if you can do a tiny code sample that can trigger it
19:43:09 <carter> that'd be AMAZING for htem
19:43:13 <NemesisD> applicative: my brain is having a bit of a run about. when I saw SMach the first thing I thought of was the speed of sound
19:43:13 <roboguy_> carter: actually that's a great idea
19:43:16 <roboguy_> I'll have to try that
19:43:22 <carter> they would love you
19:43:38 <carter> first make sure you can deterministically repo it
19:43:47 <carter> (despite the pain)
19:43:50 <roboguy_> haha, yeah
19:43:57 <carter> then do a tiny C or haskell or bash thing to repo ti
19:44:00 <applicative> NemesisD: okay, newtype NemesisD s m = NemesisD {getNemesisD :: Map s (m(), s)}
19:44:08 <carter> what os version?
19:44:14 <roboguy_> carter: do you think they'd prefer C? I can do C if that's better
19:44:23 <carter> might be easier for the engineers there
19:44:23 <roboguy_> carter: 10.8.4
19:44:26 <carter> clang is pretty nice
19:44:38 <carter> I understand C better than shell
19:44:45 <carter> relativley
19:44:49 <NemesisD> lol!
19:44:52 <carter> i can still  probably do more shell
19:44:56 <carter> but i do't understand it
19:45:04 <carter> *do more scripts with shell
19:45:09 <carter> but i undesrtand how c works
19:45:12 <carter> i don't understand how shell works
19:45:39 <NemesisD> applicative: and for my case we've established its gotta be more like Map (s,s) (Maybe m a)
19:46:11 <NemesisD> applicative: i also need the transition hook (which may or may not exist for any valid transition) to be able to return a value into the monad other than ()
19:46:21 <roboguy_> carter: yeah, that's pretty much how it is with me too. I have more experience in C which is probably partly why (well, C++, but I generally understand the differences between the two so I think it counts)
19:46:39 <carter> roboguy_ hav eyou used clang directly?
19:46:40 <carter> its NICE
19:46:53 <carter> like
19:46:56 <roboguy_> carter: I'm even fully sure what that is. I hear people talk about it quite a bit
19:46:57 <carter> the error messages make sense
19:47:07 <carter> roboguy_ eh?
19:47:10 <carter> what what is?
19:47:25 <roboguy_> clang. isn't that the llvm C compiler or am I confused?
19:47:36 <carter> yup
19:47:37 <carter> its NICE
19:47:44 <carter> it give helpful error messages
19:47:51 <carter> the code is human readable ish
19:47:56 <carter> the project lists are "cfe"
19:47:59 <carter> "c for everyone"
19:48:14 <roboguy_> carter: sounds pretty cool. it comes with apple developer tools right?
19:48:17 <carter> ohh
19:48:20 <carter> i mean "c front end"
19:48:22 <carter> yes
19:48:28 <carter> its what xcode uses
19:48:33 <carter> i've been using it from the cli mind you
19:48:52 <carter> roboguy_ if you wanna play with llvm
19:48:55 <carter> you can check out
19:48:59 <carter> @hackage llvm-general
19:48:59 <lambdabot> http://hackage.haskell.org/package/llvm-general
19:49:02 <carter> its NICE
19:49:09 <NemesisD> applicative: i'm thinking i'm specifying the types wrong, i think i need to embed a StateT on s inside of a ReaderT on StateMachine s m a
19:49:16 <carter> the main people using it lurk on #haskell-llvm
19:50:37 <NemesisD> applicative: is the a in ReaderT r m a supposed to be where i put StateT s m a?
19:51:57 <NemesisD> like ReaderT s m (StateT (StateMachine s m a) m a)
19:52:49 <geekosaur> shouldn;t it be the m? or are you up to something unusual instead of a normal monad transformer?
19:53:03 <roboguy_> carter: I've been meaning to take a look at that. I want to make a simple compiler one of these days
19:53:14 <carter> roboguy_ read the llvm-general docs
19:53:16 <carter> you will like it
19:53:18 <carter> LOTS
19:53:26 <carter> now you can have nice things :)
19:53:45 <NemesisD> i don't think i'm up to something unusual, more that i don't know what i'm doing. i'm trying to embed state functionality inside a reader (obviously the read type different from the state type)
19:53:53 <roboguy_> carter: haha, thanks for the tip! I'll look into it
19:56:15 <NemesisD> geekosaur: changed to ReaderT s (StateT (StateMachine s m a) m a) a gives me kind mismatch second arg to ReaderT should have kind * -> * but StateT (StateMachine s m a) m a has a kind *
19:56:57 <NemesisD> do i need to leave the final a off the StateT?
19:57:19 <jrh> yup
19:57:19 <geekosaur> yes, since it comes from the outer one
19:57:26 <geekosaur> compare StateT s IO a
19:57:29 <geekosaur> not (IO a) a
19:59:00 <NemesisD> hmm ok
19:59:30 <NemesisD> whoops i think i need to invert those, state needs to be outside
19:59:37 <NemesisD> since i'm interested in its final state
20:04:54 <NemesisD> holy crap it compiled
20:05:41 <NemesisD> now i have to be coy with GHC and try to get it to tell me what types it decided on the stuff i couldn't annotate
20:10:17 <lpaste> NemesisD annotated “monad reader transformer” with “works now” at http://lpaste.net/91085#a91089
20:11:21 <NemesisD> geekosaur: it works now, but i had to heavily annotate doInterestingStuff. isn't there something i can do to StateMachine's type variables to make sure m is a monad? was it RankNTypes or something?
20:13:00 <NemesisD> oh wait i think it was just because i left off a Monad m constraint on runStateMachine
20:13:35 <geekosaur> yes
20:14:06 <pentace> I'm trying to install the primitive package but it's giving me "Missing (or bad) header file: primitive-memops.h". The file is there and linked form the cabal file. What could be causing this?
20:14:41 * geekosaur is trying to do too many things at once, apparently
20:17:59 <pentace> Or do I need an external package for that?
20:21:46 <pentace> running cabal with -v3 also doesn't yield errors from gcc
20:22:17 <applicative> pentace I dont think you need an external c library
20:22:43 <applicative> pentace: you were installing primitive from inside primitive-0.1.whatever  ?
20:22:57 <pentace> yes
20:23:52 <applicative> pentace, and just did 'cabal install'
20:23:53 <applicative> ?
20:24:29 <pentace> applicative: "cabal configure" first
20:24:43 <applicative> and then cabal build?
20:25:32 <pentace> configure already fails
20:25:43 <applicative> pentace: i take it that this happens if you try 'cabal install primitive' from hackage
20:25:46 <applicative> ?
20:26:10 <pentace> That too, that's why I tried to install it locally
20:26:33 <applicative> maybe something curious about cabal or the Cabal library versions, hm
20:27:04 <applicative> what version of ghc are you using, and what version of cabal -V
20:27:36 <applicative> this seems like it will end up over my head...
20:28:19 <pentace> GHC 6.12.1 and Cabal 1.10.2.0
20:28:54 <geekosaur> those both sound rather old
20:29:20 <pentace> Yeah, but I don't want to update GHC because I had to re-build gtk2hs which is a pain on Windows ...
20:29:27 <applicative> yes this bad, it will be delicate to get versions of primitive etc that work right with them
20:29:44 <NemesisD> @unmtl runStateT
20:29:45 <lambdabot> runStateT
20:29:55 <geekosaur> @unmtl StateT
20:29:55 <lambdabot> Plugin `unmtl' failed with: `StateT' is not applied to enough arguments, giving `/\A B C. A -> B (C, A)'
20:30:10 <applicative> i wonder if, if you specify an older version of primitive it might work
20:30:12 <NemesisD> ohh whoops
20:30:16 <geekosaur> it takes a type, not a function
20:31:59 <applicative> whats the magic for a special version , cabal install primitive-primitive-0.4.1
20:32:07 <applicative> whats the magic for a special version , cabal install primitive-0.4.1
20:32:09 <applicative> rather
20:33:17 <applicative> pentace: try something like that ^^^
20:33:52 <pentace> What do you mean by magic?
20:33:54 <applicative> pentace: right, the syntax
20:34:09 <NemesisD> man its hard to keep nesting these monad transformers straight
20:34:21 <applicative> i just couldnt remember the syntax because i was thinking of more complicated possibilites
20:35:02 <pentace> applicative: The last version on hackage with "built on ghc-6.12" is 0.3.1 which also doesn't compile :S
20:35:04 <NemesisD> if i want the final output to be the result of the state, i need to do runStateT (runReadert ... and have the type be ReaderT (StateT ...
20:35:06 <NemesisD> ?
20:35:07 <applicative> NemesisD: yes its a bit of a trial, if you fix on one systematically you might do well to newtype it and define the main operations
20:35:36 <NemesisD> applicative: i'd be interested to see an example of that
20:35:56 <applicative> pentace: I think that remark 'build with ...' means, the last time we could build this it was with ....
20:36:09 <applicative> but i take it 0.4 doesn't work
20:36:27 <pentace> let me try that ...
20:37:16 <pentace> Oh what, that one compiled! :O
20:37:35 <applicative> pentace: are you trying to install vector?
20:37:44 <pentace> yes
20:37:55 <applicative> so youll probably need to specify for that
20:38:08 <applicative> it would be nice if you hadn't done cabal update for 2 years ...
20:38:35 <pentace> Why is that?
20:39:05 <applicative> then we would know what the going versions for ghc-6.12 were
20:39:26 <applicative> cabal would just install them as if it didnt know about all this more recent stuff
20:40:47 <applicative> pentace: did you get ghc with the haskellplatform?
20:41:00 <pentace> no
20:41:02 <applicative> ah
20:41:06 * geekosaur doesn't think he has time machine backups going that far back any more :(
20:41:36 <applicative> anyway, which exact version of primitive does ghc-pkg list primitive show?
20:42:47 <pentace> primitive-0.4.1 is the one installed now, 0.3 and 0.5 don't work
20:43:00 <applicative> so it looks like um
20:43:26 <applicative> cabal install vector-0.9.1 might work
20:43:50 <pentace> But what exactly is refusing the other versions? I can't see anything in the cabal file that could be causing that
20:44:04 <applicative> refusing the other version of what?
20:44:20 <pentace> of primitive
20:44:20 <applicative> you cant build a recent version of primitive, since it's very close to the compiler
20:44:55 <pentace> But where is that defined which compiler is okay and which is not?
20:45:47 <geekosaur> cabal doesn't easily support that kind of dependency (closest you can get is a dependency on a particular version or range of base) which is probably why primitive doesn't have dependencies that constrain to the right compiler versions
20:46:16 <geekosaur> but primitive is, well, primitive. so it's closely tied to a particular ghc version's internals
20:46:41 <geekosaur> so technically this is a bug in the dependencies of primitive, but it's a difficult thing to get right
20:46:43 <applicative> it should be implicit in the range for base, but I think he needed to update for something better than base > 4
20:46:55 <applicative> right, im thinking like geekosaur
20:48:00 <pentace> Okay, vector compiled fine
20:48:05 <pentace> Many thanks!
20:48:09 <applicative> well there you are
20:48:38 <applicative> I wonder though how terrible the trial will be to get gtk2hs workingwith the new Haskell Platform that just came out
20:48:51 <applicative> it would at least spare you this kind of reasoning...
20:50:10 <applicative> pentace: in any case you now have Data.Vector.Unboxed the best module on Hackage
20:51:14 <pentace> Yeah, that vector package is needed by pretty much every other package I tried to install recently :P
20:51:39 <applicative> yeah think it's finally become standard equipment
20:53:00 <pentace> Aww, rangemin is one of them and fails to build
20:53:18 <pentace> Data\RangeMin\Common\Vector.hs:39:10: Not in scope: `GM.unsafeNewWith'
20:53:38 <tabemann> hmm
20:53:51 <tabemann> how much expense is there computationally to arbitrary monad transfomer stacks?
20:54:01 <shachaf> Arbitrary expense.
20:54:39 <applicative> pentace: I wonder what GM is
20:54:42 <applicative> just a sec
20:55:20 <tabemann> I'm wondering because in my Scheme I'm thinking of being able to embed it in Haskell with *arbitrary* monad transformer stacks, as long as the monad (transfomer) it wraps implements MonadIO, but I need that MonadIO to have extremely fast liftIO, as I have particular operations I'm doing heavily on inner loops, such as reading IOArrays and IORefs
20:56:38 <NemesisD> applicative: i have to call lift ask in a ReaderT (StateMachine s m a) (StateT s m) a, i was under the impression transformers made it so i didn't have to do that explicitly
20:56:54 <NemesisD> or should i be using mtl, or am i mistaken entirely
20:56:57 <geekosaur> hayoo isn't finding unsafeNewWith, but unsafeNew is in a bunch of Data.Vector.*.Mutable modules
20:57:21 <geekosaur> NemesisD, no, transformers make lift *possible*. newtype deriving can then be used to make it automatic
20:57:37 <geekosaur> but you'd have to make a newtype for your monad stack
20:58:10 <NemesisD> geekosaur: hmm, i wonder if that would have any ancillary benefits for readability, not sure what that would look like
20:58:59 <blackdog> hey, any suggestions for naming a longest-common-substring package? i would have taken lcs, but igloo has it for something subtly different.
20:59:11 <blackdog> (currently called string-similarity which i'm not in love with)
20:59:57 <NemesisD> geekosaur: also i'm curious if the MonadBaseControl thing that snoyberg talks up all the time pertains to this
21:00:08 <geekosaur> something along the lines of (but this is probably not correct as is): newtype MyMonad s m a = ReaderT (StateMachine s m a) (StateT s m) a deriving (MonadState, MonadReader)
21:00:22 <applicative> pentace: i see vector-0.7 says DEPRECATED in favour of basicUnsafeReplicate
21:00:32 <applicative> pentace: for unsafeNewWith
21:00:37 <geekosaur> in fact it's almost certainly wrong as you need to specify what MonadState and MonadReader
21:02:01 <geekosaur> if you can work out what it needs to be, it should make things a lot simpler just from reducing the repetition in the stack definition
21:02:11 <geekosaur> and thereby reducing the possible errors
21:03:29 <pentace> applicative: Works, but similar problem in another file
21:04:02 <applicative> oh what is it>
21:04:17 <NemesisD> geekosaur: i'm using transformers instead of mtl, which doesn't seem to have MonadReader/MonadState...
21:04:33 <applicative> the problem with this package is that it is unmaintained. wasserman seems to have been an optimization master who move on to other things
21:05:04 <pentace> applicative: Data.Vector.Unboxed.Mutable.unsafeNewWith
21:05:21 <pentace> also not in scope
21:06:01 <geekosaur> oh, hm, yes
21:06:23 <applicative> deprecated use replicate instead  (of unsafeNewWith)
21:06:24 <tabemann> okay, trivial question - I want to put my Scheme state in a StateT, but I'm not sure if I want to use mtl's StateT or transformers' StateT - is there a reason to prefer one over the other?
21:06:39 <tabemann> (they both have lazy and strict StateTs, and I'm going to use the strict version)
21:07:08 <applicative> roman l put the functions you are changing into the class for Mutable Vectors rather than making it defined, then later omitted it
21:07:10 <NemesisD> that question is remarkably similar to mine
21:07:26 <geekosaur> NemesisD, yes, because transformers can't do it directly while staying compatible with the standard --- you need to pick an extension, either monads-fd or monads-tf
21:07:36 <applicative> pentace: I suspect this will happen with each .Mutable module
21:07:49 <ben_> can someone take a brief look at my newbie, 30 line guessing game and tell me where i can improve it?
21:07:52 <ben_> http://pastebin.com/wLkpmygw
21:07:58 <geekosaur> at the moment monads-fd is probably the way to do, since type families are still evolving and a bit problematic
21:08:06 <pentace> applicative: Where do you see this deprecated?
21:08:17 <applicative> http://hackage.haskell.org/packages/archive/vector/0.7.1/doc/html/src/Data-Vector-Unboxed-Mutable.html
21:08:17 <NemesisD> geekosaur: would it better if i just used mtl then?
21:08:25 <geekosaur> very likely, yes
21:08:31 <applicative> i was looking at the point of deprecation, pentace
21:08:38 <NemesisD> damn
21:08:40 * tabemann is still wondering about mtl versus transformers...
21:09:15 <applicative> pentace: that's probably the last version of vector he compiled with, but e.g. even where it is in deprecation, it is defined as 'replicate'
21:09:18 <geekosaur> tabemann, mtl2 is more or less transformers + monads-fd with slightly different (backward compatible) module paths for the lattyer
21:09:34 <pentace> applicative: And how did you find the correct version?
21:09:47 <applicative> pentace you are basically updating rangemin which is unmaintained
21:09:50 <pentace> applicative: If compiles now, btw
21:09:53 <pentace> *It
21:10:22 <applicative> pentace: i just looked for the most recent version of vector that actually had those functions
21:10:40 <applicative> fortunately they are in later versions with other names
21:10:52 <pentace> But how? :)
21:10:53 <monochrom> tabemann: transformers don't use the type classes MonadState, MonadReader etc. mtl adds those type classes on top of transformers. that is all.
21:11:03 <tabemann> geekosaur: so I should prefer mtl2 out of backwards compatibility (as I want others to be able to wrap their monad transformers in my SchemeContextT...)
21:11:14 <pentace> applicative: Do you have a tool for that or something?
21:11:23 <applicative> pentace on hackage, you can go back through versions of Vector.Generic.Mutable to see what they exported
21:11:36 <pentace> Oh :D
21:11:44 <geekosaur> not exactly backward compatibility so much as "everyone expects the monad type classes to be here"
21:11:47 <applicative> pentace: maybe it's just that i'm accustomed to it, its like breathing
21:12:20 <applicative> pentace you might write to wasserman and tell him youll take over maintenance.
21:12:45 <applicative> since you seem to know what the package is doing :)
21:12:46 <pentace> I don't thing so ;)
21:12:50 <pentace> *think
21:13:33 <applicative> why not? you'd need a copy of a more recent ghc too, to see if it works. hackage is not so scary...
21:13:54 <applicative> wasserman may be scary, dunno
21:14:32 <pentace> I could send him a patch but I'm sure I don't want to take over maintenance
21:14:38 <applicative> good plan
21:15:27 <pentace> First I have to check if it actually works, though
21:15:35 <pentace> But now today
21:15:39 <pentace> *not
21:15:42 <NemesisD> geekosaur: ghc is telling me that MonadReader is not derivable...
21:16:16 <blackdog> hm, is hackage having trouble? Been uploading for five minutes now.
21:16:23 <geekosaur> NemesisD, as I said, it would not work as is
21:17:11 <applicative> pentace: oh he has a github page but rangemin isnt on it https://github.com/lowasser?tab=repositories
21:17:19 <geekosaur> it needs to know what MonadState and MonadReader instances to derive, but I'm not quite sure what to put for MonadReader
21:17:40 <NemesisD> geekosaur: ah ok. it looks like i don't even need to derive those
21:18:02 <NemesisD> *with mtl, i just made a type alias for StateMachineM
21:18:27 <pentace> applicative: Hmm, interesting avatar ...
21:19:17 <geekosaur> oh, hm, that might even make sense. since transformers doesn't even have the concept (without either monads-fd or monads-tf on top)
21:19:37 <applicative> ha, i think he was a newlywed;  i read things on google+ from him he's in the general haskell crowd
21:20:31 <pentace> applicative: Okay, I need some sleep now. Thanks again for your help!
21:20:42 <applicative> okay good luck pentace
21:20:51 <pentace> thanks
21:21:35 <NemesisD> geekosaur: however i do have to lift twice when running the transition
21:22:29 <geekosaur> hm. right, that's the kind of thing the newtype + deriving (and you'd need an extension, come to think of it: GeneralizedNewtypeDeriving) should help with. but I am somewhat weak on details and it's getting late for me
21:23:51 <NemesisD> geekosaur: fair enough. thanks for all the help!
21:23:54 <Ghoul_> are arrows worth learning
21:24:20 <johnw> if you want to use a library that is based on them, sure
21:24:29 <johnw> but to learn just to learn, not much
21:24:57 <Ghoul_> I rarely find a need to roll my own monads
21:25:11 <Ghoul_> is rolling your own arrows the same?
21:25:22 <DiegoNolan> does anyone have an example of getting the last insert id of a sqlite insert using HDBC.Sqlite3?
21:25:24 <Ghoul_> Or do they actually benefit the structure of real world programs
21:25:27 <johnw> I've never used Arrows much, cant' say
21:25:35 <Ghoul_> ok
21:25:37 <NemesisD> applicative: i think i have to change my tactics on the transition callback: either it needs to be m () or it needs to be m (Maybe a) in the case of a valid transition with nothing to do :/
21:25:44 <johnw> Arrows were big before Applicatives appeared on the scene
21:25:44 <geekosaur> seems to me that many of the applications that people had for arrows are now covered by applicative. some FRP libraries are still exploring them but FRP is also still evolving in several different directions
21:26:03 <johnw> and arrow syntax (proc) is always tricky to read
21:26:13 <geekosaur> um, I should disambiguate there, Applicative the class of applicative functors, not applicative the IRC user :p
21:28:48 * hackagebot string-similarity 0.1.0.0 - longest common substring  http://hackage.haskell.org/package/string-similarity-0.1.0.0 (MarkWotton)
21:46:34 <NemesisD> i was using MonadPlus for its early termination semantics, how would a program catch that early termination error?
21:46:41 <NemesisD> specifically early termination
21:48:36 <geekosaur> that's up to the specific MonadPlus, there's no general mechanism (you can't pattern match on mzero)
21:49:21 <geekosaur> (and you can only == mzero if it's Eq)
21:51:09 <NemesisD> geekosaur: so in IO this thing is just gonna crash?
21:51:45 <geekosaur> for IO you can use the stuff in Control.Exception
21:51:49 <shachaf> Applicative is an annoying name for the type class.
21:51:54 <shachaf> It's so long. :-(
21:53:44 <NemesisD> geekosaur: and exception will allow me to catch specifically early termination
21:53:54 <geekosaur> NemesisD, as I understand it, *this* is where you might want to be thinking about MonadBaseControl
21:54:49 <NemesisD> geekosaur: oh really? didnt know it was applicable here. didn't see examples in the package
21:55:34 <elliott> shachaf: Idiom was a better name
21:55:45 <elliott> Functor, Idiom, Monad, done.
21:55:55 <elliott> and then they each have their own letter, f i m
21:56:09 <shachaf> What about the semigroupoid version?
21:56:20 <elliott> Idiot
21:56:38 <elliott> or probably just Apply still. after all, Monad becomes Bind
21:57:03 <geekosaur> NemesisD, as I understand it, MonadBaseControl is specifically about exception handling, and in particular correctly dealing with resource management if you're using exceptions in IO.
21:57:34 <geekosaur> some of the related stuff may address using those exceptions, but it's also possible that you just wanted something like EitherT
21:59:08 <applicative> Map, Apply, Bind
22:00:09 <applicative> I need a Bind tutorial, it's killing me
22:00:14 <tabemann> haha
22:00:32 <tabemann> just remember that a Bind tutorial will only leave you more confused than before
22:01:27 <geekosaur> NemesisD, in general exceptions in IO shouldn't be used for program control, but for actual exceptional conditions. if you're trying to represent an abort-calculation state, you would be better off using either a transformer that lets you represent the aborted calculation or a result type which lets you represent it
22:01:50 <geekosaur> that is, either something like EitherT SomeErrorType IO a, or IO (Either SomeErrorType a)
22:02:08 <geekosaur> which is more appropriate depends on what exactly you are doing
22:02:22 <applicative> would it make no sense to have a type synonym like mechanism for classes, so people who insist something like Append would be better for monoid could have their way
22:02:39 <geekosaur> of course, if your abort condition is based on an actual I/O exception, then you are justified in using IO exceptions
22:03:31 <geekosaur> but if you're short-circuiting based on anything else, you are avoiding problems by avoiding IO exceptions (and the purpose of MonadBaseControl is to try to mitigate those problems)
22:03:45 <geekosaur> (specifically you can leak resources if you're not careful)
22:04:04 <geekosaur> IO exceptions are tricky
22:04:16 <NemesisD> geekosaur: yeah. truth be told i think exceptions are without a doubt the worst part of haskell
22:04:30 <geekosaur> well, they kinda can't help it
22:04:34 <NemesisD> and i'd be a happy man if they were magically removed
22:04:44 <geekosaur> an exception is, by definition, an unpredictable state
22:05:07 <tabemann> exceptions are basically incompatible with lazy code, because they occur where a thunk is finally evaluated, not where it is defned
22:05:21 <geekosaur> there is no way to handle this nicely, not in Haskell, not in C, not in Java
22:06:10 <NemesisD> yeah i can understand why they were added, but i wish they were at least more prevalent in the types
22:06:14 <tabemann> too bad in many languages you have to abuse exceptions because there is basically no other mechanism for non-local control available
22:06:46 <geekosaur> so if you're trying to use abortable computations, exceptions are possibly the worst possible way to handle them (in any language, but especially bad in Haskell)
22:07:45 <tabemann> of course in many languages it is rather painful to have anything equivalent to Either
22:08:17 <tabemann> (e.g. OO languages with their unbounded subtyping...)
22:09:06 <jfischoff> yesod can return successful results using exceptions, i guess for performance
22:09:21 <tabemann> exceptions rarely have good performance
22:09:40 <geekosaur> sure. ask snoyman about what it took to make that work well and not leak resources :)
22:10:09 <NemesisD> i never throw exceptions myself and if i ever am writing something that matters, i try to convert exceptions into things i can actually deal with at the lowest level
22:10:09 <NemesisD> to me it seems like exceptions as they are implemented just throw all the safety you get from the type system out of the window
22:10:11 <johnw> it took him inventing ResourceT :)
22:10:43 <geekosaur> actually I think that was Oleg initially, Snoyman just made it practical
22:10:54 <johnw> ah, the same with conduits I think
22:11:47 <NemesisD> i've never seen snoyman in irc actually
22:11:53 <johnw> he doesn't IRC much
22:12:04 <johnw> he's my co-worker, so we speak every day, but he doesn't really have much time for IRC
22:12:29 <NemesisD> understandable
22:13:15 <NemesisD> johnw: oh btw i saw michael sloan today, we had a haskell meetup out here
22:13:36 <johnw> cool!  i haven't met him in RL yet, just over video chat
22:14:36 <johnw> what did you guys chat about?
22:15:43 <NemesisD> we got into natural transformations and adjoint functors, the latter of which is way above my paygrade
22:16:00 <johnw> nice!  i've been reading a lot about those lately
22:17:07 <NemesisD> i'm gonna see if the meetup host is interested in changing up the location to a space that is better for breakout groups. I like trying to learn theory but i feel like new folks get left in the dust and/or get the impression haskell is a whiteboard theoretical language
22:17:20 <johnw> true
22:21:06 <tabemann> dammit... the contained monad type constructor in my scheme code is absolutely infecting *all* of my scheme types, so just about every scheme type has to be parameterized against it...
22:25:29 <tabemann> all because I need to embed primitives just about anywhere as arbitrary values, and they have type SchemeT b m a, where m is any given monad
22:55:16 <applicative> is there on hackage some sensible attempt to fill the blank in Int : Integer :: Word :: X
22:56:18 <applicative> maybe there's no rational way to do it with the Num class as it is
22:56:53 <tabemann> could you somehow wrap Integer to produce a type that doesn't allow negative values without reimplementing the internals?
22:57:00 <elliott> applicative: plenty attempts, sensibility up to you
22:57:03 <elliott> edwardk has the nats package
22:57:04 <elliott> @hackage nats
22:57:05 <lambdabot> http://hackage.haskell.org/package/nats
22:59:18 <applicative> oh, interesting.  I figured there must be many attempts.
22:59:20 <isomorphic> I have a do block of type - MaybeT IO Foo  - I'm sort of expecting that if I bind a statement with <- , I could treat it as a Foo, but it looks like that's an IO Foo - is that correct?
22:59:36 <applicative> no it's a foo
23:00:08 <applicative> the whole monad (MaybeT IO) here returns a Foo
23:01:10 * applicative passes immediate to 'Numeric.Natural.Internal'
23:02:25 <applicative> hm, wrapped Integer, that's a little too ... obvious
23:04:50 <isomorphic> applicative:  Ok.  So, let's say that within that a do block, I construct a Bar  - say,  g <-   return $ barIO x  - where (barIO :: Int -> IO Bar).  Is it true that g :: IO Bar
23:04:53 <isomorphic> ?
23:07:35 <isomorphic> applicative:  Is X above an arbitrary width binary type?
23:07:48 <isomorphic> s/binary/bitwise
23:08:55 * hackagebot papillon 0.0.56 - packrat parser  http://hackage.haskell.org/package/papillon-0.0.56 (YoshikuniJujo)
23:09:15 <applicative> isomorphic: I guess, i was just thinking it went on forever like Nat or Integer
23:09:34 <applicative> I had thought Integer was a recursive type, or something
23:09:40 <applicative> INTEGER IS A LIE
23:09:43 <applicative> data Integer = S# Int#  | J# Int# ByteArray#
23:09:54 <applicative> how many numbers can I get with that?
23:09:59 <isomorphic> hahahah
23:10:12 <isomorphic> How much memories do you has?
23:10:16 <tabemann> I presume the Int# in J# is the length of the ByteArray#
23:10:20 <applicative> more than with data Nat = Z | S Nat, but there is a question of principle
23:10:41 <applicative> oh, would that be right tabemann not sure
23:11:06 <isomorphic> bitwise stuff is a bit weird, because for a lot of operations, you have to know the maximum
23:11:07 <tabemann> so while that's just an Int#, you shouldn't be able to address any more bytes than you can fit in that value anyways
23:11:17 <isomorphic> eg: rotations, shifts.
23:11:42 <tabemann> so there *is* a limit to what you can put in an Integer, i.e. how much Integer you can fit into your available virtual address space
23:12:43 <applicative> i cant find the link for 7.6 but here's the definition http://www.haskell.org/ghc/docs/7.4.1/html/libraries/integer-gmp-0.4.0.0/src/GHC-Integer-Type.html
23:13:02 <tabemann> applicative: the problem with literally implementing Nat that way is that it isn't terribly efficient, which makes me suspect that the likes of Agda are optimizing Nat behind the scenes... (unless they want to be extra-purity purity pure...)
23:13:59 <zvrba> is there any reason why Data.Vector.Mutable doesn't have the same methods as Data.Vector (e.g. findIndex) ?
23:16:05 <applicative> tabemann: you mean implementing Nat in the usual Nat = Z
23:16:10 <applicative> sort of way
23:16:15 <applicative> yes, it's mildly insane
23:16:37 <tabemann> it's nice for theorem proving, horrible for space and time complexity
23:16:57 <applicative> zvrba: this is systematic for all vector modules, Data.Vector.Blah, Data.Vector.Mutable.Blah
23:17:27 <applicative> zvrba: the mutable ones export less; i think you can sometimes find more in Data.Vector.Generic.Mutable
23:18:16 <applicative> oh that should have been Data.Vector.Blah.Mutable
23:18:54 <applicative> zvrba: you should if possible be using Data.Vector.Unboxed(.Mutable) if possible, or Storable for another purpose
23:20:05 <zvrba> applicative: it's the same thing with unboxed.mutable
23:20:27 <zvrba> (yeah, i'm using d.v.u.(m))
23:20:41 <applicative> zvrba: yes, thats what I was saying; i was just adding the additional would-be wisdom that Data.Vector and Data.Vector.Mutable are basically no good.
23:21:04 <zvrba> ok
23:21:58 <applicative> moving out to Mutable or to 'immutable' is in theory not so grave, since in the underlying representation theyre all mutable
23:22:29 <applicative> or thats my memory of it
23:22:49 <zvrba> d.v.u.modify says that it'll modify the vector in place if it is safe to do so, or copy it otherwise
23:23:29 <applicative> yes, theres a few 'unsafe' things like that in the 'pure' modules
23:23:50 <applicative> you have to make sure you don't re use old references to the vector
23:23:58 <zvrba> i know
23:23:59 <isomorphic> applicative:   If inside my MaybeT IO Foo monad, I have a function that returns MaybeT IO Bar, and the definition of Foo includes a Maybe Bar, what's a sensible way to construct Foo?   I'm toying around with chains of runMaybeT which sort of look crazy.
23:24:08 <applicative> zvrba: yeah its obvious
23:24:32 <tabemann> if you want to use unsafe operations you should have to apply unsafePerformIO yourself rather than having some function implicitly doing it for you...
23:24:59 <zvrba> applicative: there's freeze/thaw which copy the vector, and their unsafe versions
23:25:22 <applicative> if data Bar = Zorg Fool Int, you extract the Blah, newBlah <-  myfun; return (Zorg newBlah 3)
23:25:32 <applicative> for example
23:25:38 <zvrba> it doesn't say whether the conversion is expensive, and it's unclear why d.v.u.mutable doesn't include methods from d.v.u. anyway :S
23:25:56 <applicative> zvrba: yeah. I always use the unsafe ones but in fact never notice the difference if I change over
23:26:06 <zvrba> change over to what?
23:26:55 <applicative> to the corresponding safe ones.  unsafeThaw for example.
23:27:10 <zvrba> and d.v.u.modify doesn't way when it is "safe" to modify the vector in-place
23:27:19 <applicative> I think unsafeThaw costs nil, since it's the same vector, safe thaw in theory copies it
23:27:27 <zvrba> yeah
23:27:48 <zvrba> that's at least what the docs say: that safe thaw/freeze copy the vector
23:33:20 <applicative> i see basicUnsafeNew is a method of the underlying 'Mutable Vector' class basicUnsafeThaw is a method of the associated Pure vector class
23:33:32 <applicative> this is all complicated by type families of course
23:34:27 <zvrba> what are type families?
23:34:41 <applicative> gah not so easy to say
23:34:41 <zvrba> (I couldn't quite figure out the type signatures there...)
23:35:16 <zvrba> hah. ad-hoc overloading of data types.
23:35:20 <zvrba> from haskell wiki
23:35:33 <zvrba> They are the data type analogue of type classes: families are used to define overloaded data in the same way that classes are used to define overloaded functions.
23:35:59 <isomorphic> zvrba:  Check out this - possibly helpful -  https://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/fun-with-type-funs/typefun.pdf
23:36:20 <applicative> zvrba: yes thats the standard ref for type families.
23:36:25 <zvrba> ok
23:36:55 <zvrba> back to coding/reading.
23:37:05 <applicative> in  Data.Vector.Generic.Mutable.Base  there is a type class , ordinary sort
23:37:05 <Gracenotes> is there a page somewhere describing ghci's bytecode format?
23:37:19 <applicative> class MVector v a where   basicLength       :: v s a -> Int etc
23:37:43 <zvrba> yeah, what is "v" there?
23:37:46 <applicative> so the kind of thing fits the v slot takes two arguments,
23:37:56 <applicative> the second is that values in the vector
23:38:04 <applicative> the first is a 'state'.
23:38:18 <zvrba> ah
23:38:41 <applicative> when it is left general we are doing STVector v a; when it is filled with the mysterious RealWorld, we are doing IOVector a
23:38:59 <applicative> that's fancy , but then come type families
23:39:31 <applicative> in Data.Vector.Generic.Base there type family Mutable (v :: * -> *) :: * -> * -> *
23:40:01 <applicative> this associates a vectory type-former (*->*) with a two parameter type former
23:40:13 <zvrba> + there are mutliple MVector classes residing in different subpackages :S
23:40:23 <zvrba> just clicking around gave me a headache
23:40:48 <applicative> but it's a type function, so you just declare what (*->*>*) is Mutable blah, and which is Mutable blip
23:41:09 <applicative> zvrba: yes I'm in Generic
23:41:33 <applicative> the organization of this library is maddening, but makes perfect sense
23:42:05 <applicative> he's torturing the type system to get out of the land of hideous bytearray and so on, and into some beautiful like Data.Vector.Unboxed
23:42:35 <applicative> in any case there we get class MVector (Mutable v) a => Vector v a where
23:42:41 <applicative> and some methods.
23:42:57 <zvrba> and I can't use Mutable methods on ordinary vector
23:43:00 <zvrba> or vice-versa
23:43:05 <zvrba> but they're one and the sam thing!
23:43:20 <zvrba> there's no reason at least why mutable shouldn't have all query methods :S
23:43:26 <zvrba> grrr
23:43:26 <applicative> so here, we can only have v and a under the Vector class, if the condition is met
23:43:37 <applicative> viz MVector (Mutable v) a
23:43:57 <applicative> but here, Mutable v is a function mapping v to could-be-anything
23:45:05 <zvrba> so MVector (Mutable v) a is a type-"function" which deconstructs its argument like ordinary function?
23:45:33 <applicative> Mutable is the type function
23:46:48 <zvrba> I still have not found any explanation of when "modify" deems it is safe to update the vector in-place...
23:47:07 <zvrba> [the main problem with the library is the lack of user-guide]
23:47:36 <applicative> zvrba: yes. there is a tutorial on the wiki but it's out of date i think
23:48:18 <applicative> some revisions lately, not a lot http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial
23:48:31 <zvrba> i've looked at it. it's VERY incomplete.
23:48:45 <zvrba> and it's there where I found the advice abput using Unboxed vectors if possible
23:48:48 <applicative> yes, dons started it and vanished into banking
23:48:58 <zvrba> hah
23:49:09 <zvrba> anyway. have to go now. bbl.
23:49:15 <zvrba> thanks for the help
