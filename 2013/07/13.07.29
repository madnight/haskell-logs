00:00:03 <shachaf> Ezku: OK. So a category is the same thing as a monoid, *except* you can't just "multiply" any old two things together.
00:00:11 <shachaf> Ezku: Each thing has a type, and their types have to match.
00:00:25 <shachaf> The arrows in a category correspond to the elements in a monoid.
00:00:30 <PatrickRobotham> shachaf: Well I mean, you visualize an object as a dot, while you visualize an arrow as an arrow, and dots are easier to draw than arrows.
00:01:13 <shachaf> (Very directly: If you have a category with one object, it means you can compose any two arrows, since there's only one "type". A category with one object is the same thing as a monoid.)
00:01:16 <PatrickRobotham> Gracenotes: Yeah, that's not a helpful way to think about it. The arrows are the whole point of category. You wouldn't view the arcs in a directed graph as a mere nuisance.
00:01:42 <shachaf> PatrickRobotham: Er, OK? Find a better way to draw it, then. :-)
00:02:07 <shachaf> PatrickRobotham: I think this leads to some serious misunderstandings which can take a while to get fixed.
00:02:27 <PatrickRobotham> shachaf: Your wish is my command! https://en.wikipedia.org/wiki/String_diagram
00:02:32 <shachaf> Objects are usually boring and not the point. Arrows are interesting and relevant to whatever you're doing.
00:02:32 <PatrickRobotham> shachaf: Such as?
00:03:03 <Gracenotes> PatrickRobotham: I know that arrows are important but I don't see it as intuitively true.
00:03:06 <Ezku> shachaf: I understand the relevance of a category with only one object, as then you only have identity morphisms, ie. "ways to put two of these things together and arrive at another of the same kind"
00:03:09 <savask> Hello. Are there fast primality tests in Haskell, like AKS or APRT?
00:03:09 <haasn> in the category ℕ, numbers are arrows
00:03:12 <bicgena> The 90-90 rule: "The first 90 percent of the code accounts for the first 90 percent of the development time. The remaining 10 percent of the code accounts for the other 90 percent of the development time." —Tom Cargill, Bell Labs
00:03:18 <shachaf> Such as what's been said above.
00:03:21 <shachaf> Ezku: No.
00:03:23 <Gracenotes> Insufficient generalization, I think.
00:03:34 <Ezku> shachaf: no? :)
00:03:38 <shachaf> Ezku: An arrow isn't "a way of getting from one object to another", not in most cases.
00:03:56 <haasn> An arrow in the category of “ways of getting from one object to another” is a way of getting from one object to another
00:03:57 <zvrba> Ezku: you don't have only identity morphisms.
00:04:12 <PatrickRobotham> Gracenotes: Well what about considering a monoid as a category with one object?
00:04:14 <haasn> An arrow in a different category might be something entirely different
00:04:28 <PatrickRobotham> Gracenotes: I think with that example it's clear that the arrows are important.
00:04:29 <Gracenotes> PatrickRobotham: well, that makes sense. a bit trivial, though.
00:04:30 <Ezku> in a category of only one object, what other morphisms _could_ there be other than identity?
00:04:37 <shachaf> Ezku: An identity arrow is a special arrow, not just because it's from an object to itself, but because of the way it behaves. No other arrow is like an identity arrow.
00:04:47 <shachaf> OK, this channel has too many people talking at once.
00:04:59 <Ezku> oh, I'm focusing on the objects too much again, am I not
00:05:00 <shachaf> I'll let the others take over.
00:05:25 <zvrba> shachaf: for me it was actually a kind of enlightement to realize that ID arrow is defined only through how it interacts with other arrows.
00:05:39 <Ezku> if you excellent people would like to continue this over at ##categorytheory? :o
00:05:39 <zvrba> (as opposed to how we usually define identity _function_)
00:05:50 <haasn> zvrba: and by its existence
00:06:05 <zvrba> haasn: well, existence is postulated.
00:06:23 <shachaf> I usually don't talk in ##categorytheory.
00:06:33 <Ezku> hm, so there's an identity morphism, but what I meant was actually more like endomorphisms, right?
00:06:41 <haasn> eg. in the Haskell sense of Category, you have id :: Category c => c a a -- for every ‘a’
00:06:44 <Ezku> shachaf: I can relate to that.
00:07:17 <shachaf> Maybe I should. I don't know. Maybe when I know more.
00:07:19 <haasn> this property alone is almost what defines the way it interacts with other arrows
00:08:03 <haasn> ie. since it can be composed with anything, the only thing it can do is nothing
00:08:19 <zvrba> :)
00:08:41 <PatrickRobotham> id is the identity natural transformation.
00:08:54 <shachaf> haasn: That doesn't sound right... There's a different identity arrow for every object.
00:09:10 <shachaf> I don't think you can make parametricity arguments here. :-)
00:09:12 <dmwit> haasn: That observation does not extend to category theory, where parametricity is not a thing you can take for granted.
00:09:24 <dmwit> ...as shachaf is pointing out.
00:09:25 <Ezku> shachaf: would my statement hold if I said "endomorphisms" instead of "identity morphisms"?
00:09:30 <PatrickRobotham> What's paramtericity.
00:09:56 <haasn> shachaf: I'm not sure how identity arrows differ across objects. they all interact in the exact same way
00:09:58 <shachaf> Ezku: I've forgotten which statement you mean.
00:10:01 <dmwit> Parametricity is a property that roughly says "this polymorphic thing behaves 'the same way' at all the monomorphic types it can be instantiated to".
00:10:20 <Ezku> shachaf: if you have a category with only one object, then all you can have are endomorphisms
00:10:25 <PatrickRobotham> What's the difference between Parametricity and Naturality?
00:10:31 <PatrickRobotham> Ezku: Yes that's true.
00:10:37 <Ezku> hurrah \o/
00:10:38 <shachaf> Parametricity is certainly related to naturality, though.
00:10:42 <shachaf> Ezku: Yes.
00:10:59 <PatrickRobotham> Ezku: You shouldn't view endomorphisms as a way of putting two things together though.
00:11:07 <PatrickRobotham> Composition does that.
00:11:49 <shachaf> Ezku: To clarify what I meant, here's a category: The object is called A. The arrows are natural numbers, e.g. 0 : A -> A; 1 : A -> A; ...
00:11:51 <Ezku> PatrickRobotham: damn. Yeah, thanks for the correction. That's pretty relevant to my newfound understanding.
00:12:12 <shachaf> Ezku: "composing" two arrows means adding them together So (4 . 5) is 9.
00:13:19 <PatrickRobotham> Ezku: shachaf's example illustrates the fact that the composition rule matters in a category. If you wanted to be totally rigorous you might write ._C
00:13:24 <dmwit> haasn: The point is that I can define a collection of endomorphisms, one for each object, which nevertheless isn't exactly the collection of identities.
00:13:49 <dmwit> haasn: So the "type" forall a. a -> a isn't enough to say "this is the canonical collection that has one identity for each type".
00:14:00 <Ezku> shachaf: Ouch, brainhurt. Why are the arrows and not the objects the numbers?
00:14:29 <dmwit> haasn: Of course, in Haskell it happens to be true that "a -> a" can only be the identity, no matter what type you instantiate it to. But that is because of a special property of Haskell.
00:14:31 <Ezku> and what on earth are the objects then
00:14:33 <shachaf> Ezku: Because you're focusing on the wrong thing. Forget objects. Objects are only there so we can talk about the arrows.
00:14:53 <haasn> dmwit: okay
00:15:31 <haasn> dmwit: well, in a way, ‘identity’ is polymorphic on a sort of meta-level; due to the way categories are defined
00:15:33 <shachaf> Ezku: Go back to the definition of monoid. A monoid M has an identity id :: M, and multiplication (*) :: M -> M -> M, such that the laws hold. Right?
00:15:51 <PatrickRobotham> hom(A,A) = M.
00:15:58 <dmwit> haasn: Yes. But not all polymorphic things of the right type are 'identity'.
00:16:01 <haasn> what type it may have in a category of functions with objects being type, is unrelated
00:16:10 <shachaf> Ezku: Now, a category is *the same thing*, except you have types. You have an identity id :: M a a, and multiplication (*) :: M a b -> M b c -> M a c
00:16:23 <shachaf> Ezku: You can only "multiply" two things if they match.
00:16:58 <shachaf> Ezku: The "elements" here are "M A B"s, for various As and Bs.
00:17:32 <haasn> every category is a partial monoid (not vice versa)
00:17:35 <shachaf> These elements are what's important. A/B/C aren't important -- we just use them to keep track of what we can multiply with what.
00:18:08 <Ezku> shachaf: Thanks. I'll need to meditate on that for a bit. I'm at work and need my brainpower for other kinds of output. I really appreciate the explanation, though. As if my monday wasn't awesome enough as it is. :)
00:18:54 <shachaf> Objects are such a red herring. Someone should come up with a better name for them.
00:19:02 <PatrickRobotham> Types? :P
00:19:09 <shachaf> Not that great either.
00:19:41 <zvrba> shachaf: objects are just a way of _naming_ arrows, I guess. it'd be very impractical theory if you couldn't name things in it.
00:19:41 <dmwit> Someone really should not come up with a better name for them.
00:19:45 <shachaf> Ezku: Anyway, now you can figure out why the monoid thing makes sense. The *arrows* are things like 5 :: M A A
00:19:55 <dmwit> Everything I can think of that has two names causes more confusion than it would if it had one bad name instead.
00:20:21 <shachaf> zvrba: I wouldn't say that. But whatever, it's maybe not an important distinction.
00:20:24 <Sonarpul`> the syntax: instance Category (->) where ...
00:20:36 <shachaf> dmwit: Don't worry, whatever I come up with won't stick anyway. :-)
00:20:40 <Sonarpulse> is (-?) just sure?
00:20:44 <Sonarpulse> *sugar
00:20:47 <dmwit> shachaf: =)
00:20:50 <haasn> shachaf: I still vote Frank
00:20:50 <dmwit> Sonarpulse: no sugar
00:20:51 <Sonarpulse> (->)
00:20:57 <shachaf> (->) is a type constructor.
00:21:09 <Ezku> shachaf: I think I can, yes. At least I have all the pieces of the explanation. Thanks again.
00:21:09 <shachaf> Nothing to do with classes or instances; it stands on its own.
00:21:17 <shachaf> Ezku: Here's one more example for you:
00:21:29 <shachaf> Ezku: You know what matrices are?
00:21:39 <Sonarpulse> so -> is a type constructor with lowest precedence and no associated date constructor?
00:21:50 <Ezku> shachaf: yeah
00:21:59 <shachaf> Ezku: You can't make that idea into a monoid, because you can't multiply any two matrices.
00:22:04 <dmwit> Sonarpulse: I'm not sure the type level has an idea of precedence.
00:22:22 <dmwit> Sonarpulse: Though you are right that there are no constructors visible at the term level.
00:22:29 <shachaf> Ezku: But it's a category. The "objects" are just natural numbers -- the length of the side of the matrix.
00:22:49 <Sonarpulse> Matrix Width Height
00:22:52 <shachaf> Ezku: The arrows are the actual matrices, the thing you care about. You have mult :: M a b -> M b c -> M a c
00:23:18 <shachaf> Ezku: You can multiply a 2x3 matrix with a 3x7 matrix, because you have the same number of rows in one as columns in the other.
00:23:41 <shachaf> You also have identity matrices, which are always square: id :: M a a. All the usual category laws apply.
00:23:56 <shachaf> (Oh, and you get a 2x7 matrix, of course.)
00:24:13 <haasn> shachaf: that's an awesome example of a nontrivial category where the arrows are not “function-like”
00:24:23 <dmwit> The arrows are function like.
00:24:23 <zvrba> mm
00:24:27 <dmwit> They're linear transformations.
00:24:33 <shachaf> haasn: Except this is also the category where the arrows are linear functions and the objects are R^n :-)
00:24:43 <shachaf> dmwit: See, this time you're the one to beat me to it.
00:24:46 <haasn> fair enough :P
00:24:53 <dmwit> yissss
00:25:45 <zvrba> dmwit: well, each arrow is a collection of functions (same arrow = different matrices). so they're not function-like after all.
00:25:54 <dmwit> There's plenty of good non-function-like categories, though.
00:26:05 <shachaf> Hmm, "linear function" sometimes means f x = a*x + b, doesn't it?
00:26:06 <dmwit> e.g. the category of paths in a graph
00:26:14 <zvrba> shachaf: that too.
00:26:21 <Sonarpulse> is the category in haskell exist on the type or value level?
00:26:22 <shachaf> dmwit: That one is free, though!
00:26:27 <zvrba> shachaf: though I think it's strictly named affine transformation.
00:26:30 <haasn> shachaf: that's a ---
00:26:32 <haasn> yeah that
00:26:50 <zvrba> shachaf: linear transformations are a*x, affine are a*x+b
00:26:55 <shachaf> Yes, but people call it that.
00:27:14 <arnsholt> It's a slightly colloquial usage, I think
00:27:18 <shachaf> The point is maybe I should say "linear map" or "linear transformation" instead of "linear function".
00:27:20 <haasn> if you ask people in my old class what a “lineare funktion” is, you'd get y = mx + c
00:27:23 <johnw> <shachaf> obvious :: Applicative f => f () (or some other name) would be generally nice to have
00:27:24 <Ezku> shachaf: I started to ask why objects weren't matrices of specific dimensions and arrows the transformations to go from dimensions to others, but I think I found the reason why you picked that specific example. Still, need to meditate for a bit.
00:27:28 <johnw> sorry, it took me a while to get to this
00:27:30 <johnw> yes, I completely agree
00:27:36 <johnw> and with AMP coming up, that's the better type signature
00:27:45 <Sonarpulse> are the objects actual values in the domain and range (assuming it's a function) or parameters to the category type constructor?
00:27:51 <dmwit> zvrba: Sorry, what do you mean? "same arrow = different matrices"?
00:28:00 <johnw> shachaf: what do you think of "skip" instead of "obvious"?
00:28:10 <johnw> that name comes from the "Just Do It: Monadic Reasoning" paper
00:28:14 <zvrba> dmwit: an arrow 4 -> 5 represents a 4x5 matrix. but there are an infinite number of 4x5 matrices.
00:28:24 <zvrba> dmwit: so arrows in that category are not function-like.
00:28:28 <dmwit> zvrba: eh?
00:28:32 <zvrba> ?
00:28:38 <dmwit> There are an infinite number of functions from R^4 to R^5.
00:28:46 <shachaf> Ezku: The answer is that you're missing the point and focusing on objects. :-) That's exactly why I'm giving these examples.
00:28:59 <haasn> Sonarpulse: in the category Hask of Haskell functions, functions are your arrows; and the objects are types
00:29:17 <zvrba> dmwit: hah!
00:29:28 <zvrba> you're damn right.
00:29:46 <zvrba> "weird" examples like shachaf are actually very helpful to me. :)
00:30:03 <haasn> Sonarpulse: composition is as such: for any haskell functions f :: b -> c and g :: a -> b; there exists a composition (f·g) :: a -> c; which could trivially be implemented in Haskell as (f . g)
00:30:04 <zvrba> thinking about arrows as functions is.. yeah, less than helpful.
00:30:09 <shachaf> Ezku: I was pretty much monologuing the whole monoid -> category deal rather than involving you.
00:30:19 <dmwit> Sonarpulse: The constraint "Category c" indicates that there is a category whose objects are types "c a b" and whose arrows are values of type "c a b".
00:30:21 <shachaf> Good to hear that I'm a "weird" example.
00:30:27 <haasn> Sonarpulse: an identity also exists for every type, trivially written as ‘id’
00:30:45 <Sonarpulse> dmwit: that contradicts
00:31:17 <zvrba> shachaf: 's was missing :-)
00:31:29 <shachaf> haasn: What I like about the matrix example is that it's such good motivation for the definition of a category (*and* gives good intuition, with minimal focus on objects).
00:31:47 <haasn> shachaf: exactly
00:32:00 <shachaf> haasn: Just like you have regular multiplication for monoids, you have typed multiplication for matrices. It's just natural, and makes the entire definition of a category obvious.
00:32:02 <dmwit> Sonarpulse: What does it contradict?
00:32:15 <Sonarpulse> using the hask example
00:32:27 <Sonarpulse> c a b is arrows. so I agree
00:32:36 <shachaf> dmwit: Whose objects are types "c a b"?
00:32:36 <Sonarpulse> but then a and b are objects?
00:32:46 <dmwit> shachaf: Yeah, that doesn't seem right, does it?
00:32:50 <dmwit> Let's try that again.
00:32:52 <haasn> ‘a’ and ‘b’ are indeed objects in Hask
00:32:56 <Gracenotes> does it D:
00:33:06 <dmwit> Sonarpulse: Yes.
00:33:10 <haasn> (so is ‘c a b’, mind; but ‘c a b’ is not arrows; it's the type of arrows)
00:33:11 <Sonarpulse> oh good
00:33:13 <dmwit> Sonarpulse: I was wrong, and I should feel wrong.
00:33:58 <Sonarpulse> interestingly, we say if exists instance Monad m, M is a monad
00:34:09 <Sonarpulse> but with instance Category (->)
00:34:22 <Sonarpulse> -> does NOT feel like a category
00:35:27 <dmwit> So, the corrected statement is that the constraint "Category c" indicates that there is a category whose objects are types and whose arrows are values of type "c a b".
00:35:33 <Sonarpulse> yeah
00:35:42 <dmwit> Specializing to (->): objects are types, arrows are functions "a -> b".
00:35:43 <Sonarpulse> the actual category itself remanes unamed
00:35:55 <dmwit> So, why does this not feel like a category to you?
00:36:12 <Sonarpulse> "objects are types, arrows are functions "a ->
00:36:12 <Sonarpulse> 	b"."
00:36:15 <shachaf> (->) is a good name.
00:36:16 <Sonarpulse> that is all good
00:36:31 <shachaf> dmwit: OK, how about a change from naming categories after their objects to naming them after their arrows?
00:36:38 <Sonarpulse> I just feel like the type constructor -> isn't a category
00:36:42 <shachaf> "the category of functions", "the category of group homomorphisms", etc.
00:36:52 <dmwit> shachaf: I agree with that suggestion whole-heartedly.
00:36:57 <shachaf> "the category of linear maps" is better than "the category of natural numbers"
00:37:09 <shachaf> OK then.
00:37:11 <dmwit> I define my categories by giving their arrows (rather than their objects) in my papers.
00:37:33 <dmwit> Sonarpulse: Yes, the type constructor (->) is not a category.
00:38:16 <dmwit> Sonarpulse: "Category (->)" is shorthand for saying "there is a category whose objects are thus-and-such; whose arrows are thus-and-such; whose identities are thus-and-such; and whose composition is thus-and-such".
00:38:19 <haasn> ‘Category c’ instances give rise to categories, where arrows are values of type ‘c a b’ and objects are still Haskell types. Again, composition is given by the fact that we know for every ‘c a b’ and ‘c b d’ there exists a value of type ‘c a d’; trivially written using Category's (.)
00:38:50 <haasn> (of course, assuming it follows all the laws)
00:38:51 <dmwit> Sonarpulse: So, when giving the "instance Category (->)", you implicitly define the objects (types) and arrows (values of type (->) a b), and explicitly define identities and composition in the methods.
00:38:58 <shachaf> Hmm, (->) is a perfectly good name for the category.
00:39:07 <shachaf> dmwit: I solve the problem by not writing papers in the first place.
00:39:35 <haasn> hmm
00:39:36 <Sonarpulse> -> is the "arrow constructor", at the very least
00:39:59 <haasn> Hask is the category of legal Haskell functions; Haskell itself doesn't actually contain all those functions, only the one in the Prelude
00:40:02 <Ezku> shachaf: appreciate it nonetheless.
00:40:14 <Sonarpulse> defining catebories by their arrow <-> defining categories by their arrow construcor
00:40:22 <dmwit> shachaf: (->) is a perfectly good name for a category, but (->) isn't a category.
00:40:31 * dmwit attempts to channel Lewis Carroll and fails
00:40:55 <shachaf> Do you mean that "(->)" isn't a category? Or what?
00:41:04 <shachaf> haasn: OK, now explain rank-n types.
00:41:29 <haasn> shachaf: what do you mean?
00:41:48 <shachaf> haasn: Nothing useful to the current explanation. :-)
00:42:06 <dmwit> shachaf: http://stackoverflow.com/a/962027/791604
00:42:18 <Sonarpulse> I am agreeing with dmwit here. perhaps * -> * is the category
00:42:32 <Walther> http://www.xkcdb.com/9516 Aww.
00:42:35 <Sonarpulse> matrix would ideally be down with dependant types
00:42:50 <dmwit> Sonarpulse: There's no shortcut. If you want to say what the category really is, you have to do it whole-heartedly: you have to say what the objects, arrows, identities, and composition are.
00:42:54 <shachaf> dmwit: Ah, that.
00:43:05 <dmwit> Sonarpulse: If all you want to do is name the category, (->) is as good a name as any.
00:43:18 <Sonarpulse> sounds good
00:43:41 <Sonarpulse> but kinds -> categories of types, types -> categories of values
00:43:47 <Sonarpulse> that seems proper
00:44:14 <haasn> Sonarpulse: I don't think you need dependent types for type-safe matrices with Category instances
00:44:21 * haasn feels like trying
00:44:33 <Sonarpulse> no, there is the REPA tricks
00:44:33 <dmwit> I'm beyond confused what point Sonarpulse is trying to make here.
00:45:57 <Sonarpulse> I can't really describe it well :)
00:46:16 <Sonarpulse> if type constructor --> category name
00:46:37 <Sonarpulse> since (->) is a type constructor
00:47:15 <Sonarpulse> I was wondering whether kinds represents categorys themselves, not just name them
00:48:16 <dmwit> The question still isn't quite concrete enough to answer, I'm afraid.
00:49:00 <Sonarpulse> Absolutely. Just phrasing it right or learning the terminolgy is half the battle
00:49:05 <dmwit> Perhaps you want to know whether there's a sensible category whose objects are kinds? Or whose arrows are kinds? Or there's a sensible category for each kind? or...?
00:52:13 <Sonarpulse> (->) is just one type constructor of kind * -> *
00:52:31 <zRecursive> :k (->)
00:52:32 <lambdabot> * -> * -> *
00:52:41 <Sonarpulse> oh, my bad
00:52:47 <Sonarpulse> duh
01:13:10 <MedDev> woohoo! Control.Parallel.Strategies and Data.Sequence are my new best friends!
01:14:10 <Martty> that's..just sad
01:14:11 <haasn> hmm given Vec :: Nat -> * -> * -- it's not possible to write replicate :: a -> Vec n a -- is it?
01:14:38 <haasn> Vec defined where VNil :: Vec Z a; VCons :: a -> Vec n a -> Vec (S n) a
01:15:19 * hackagebot monad-extras 0.1.0.0 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.1.0.0 (JohnWiegley)
01:17:36 * shachaf sighs.
01:17:43 <johnw> i knew that was coming
01:18:18 <johnw> these are helper functions that chris and I find ourselves redefining over and over again, so we packaged them.  Don't use if you don't like
01:18:32 <Letchik> Is there some analogue of Purely Functional Data Structures: Chris Okasaki that does not require me to know Standart ML or any other languages except Haskell?
01:19:22 <adnap> .j 皮肉
01:19:32 <adnap> Sorry, wrong channel
01:19:49 <pharaun> johnw: nom? :) cute name
01:23:50 <Moggle> @src (<*)
01:23:50 <lambdabot> (<*) = liftA2 const
01:27:55 <Moggle> @src (<$)
01:27:56 <lambdabot> (<$) = (<$>) . const
01:35:20 * hackagebot monad-extras 0.2.0.0 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.2.0.0 (JohnWiegley)
01:35:49 <supki> johnw: does the name 'obvious' stems from the fact it could be used as :: a -> () ?
01:36:42 <johnw> shachaf said that roconnor suggested the name
01:36:48 <johnw> seemed like a good enough name as any to me
01:40:24 <jdoles> Does anyone know what 8ALPHA means?
01:41:16 <Taneb> 8 bits per colour channel, with an alpha channel?
01:42:16 <jdoles> Taneb: it's used in various HTTP RFCs.
01:42:27 <Taneb> So, probably not what I said
01:42:32 <jdoles> Taneb: but it's never defined.
01:42:39 <arnsholt> 8-bit alphanumeric perhaps?
01:43:14 <Hafydd> jdoles: look where it is defined in the RFCs.
01:43:25 <jdoles> Hafydd: I already did and it isn't.
01:43:43 <Hafydd> I doubt it.
01:43:52 <Ghoul_> Hi, can I please have some help with this : http://lpaste.net/91299
01:44:03 <Ghoul_> I need to lift into SessIO my function with signature IO
01:44:15 <jdoles> ALPHA is referred to.
01:44:16 <Ghoul_> but I tried liftIO $ ... and it gave more errors.
01:44:35 <Ghoul_> even when I break out of partially applied form
01:45:03 <johnw> that code snippet is not enough to go on
01:45:10 <johnw> I don't know what EitherP is
01:45:13 <jdoles> Hafydd: searching for 8ALPHA.*= in all RFCs doesn't return a result.
01:45:36 <jdoles> Perhaps the 8 prefix is some kind of special grammar notation.
01:46:02 <Ghoul_> sorry about that, http://lpaste.net/91300 heres the full thing. EitherP is a thing from pipes
01:46:10 <Ghoul_> It's equivalent to EitherT
01:46:10 <Hafydd> Oh... yes, good point.
01:46:48 <johnw> I still don't know enough about EitherP to know if it implies MonadIO
01:47:17 <Hafydd> primary-subtag = 1*8ALPHA
01:47:18 <Hafydd> subtag = 1*8(ALPHA / DIGIT)
01:47:21 <Ghoul_> It does imply MonadIO
01:47:30 <johnw> (not a pipes user, so maybe someone else should help)
01:47:47 <Ghoul_> http://hackage.haskell.org/packages/archive/pipes/latest/doc/html/Control-Proxy-Trans-Either.html#v:EitherP
01:48:57 <jdoles> Hafydd: it is defined.
01:49:15 <jdoles> Hafydd: it would just be nicer if everyone would use the same grammar notation.
01:51:01 <Ghoul_> if I do liftIO $ socketWriteTimeoutD ... I end up with it wanting an IO () but the actual type is EitherP .... IO r0
01:52:51 <jdoles> They even have repetition in their own grammar description language o.O. What were they smoking?
01:53:37 <johnw> Ghoul_: I think that's because socketWriteTimeoutD is not a function in IO
01:54:22 <Ghoul_> It is, here's the type: socketWriteTimeoutD	:: Int -> Socket -> x -> EitherP Timeout p x ByteString x ByteString IO r
01:54:32 <johnw> i mean
01:54:37 <johnw> it would need to be -> IO r
01:54:43 <johnw> for you to use it with liftIO
01:54:49 <johnw> :t liftIO
01:54:50 <lambdabot> MonadIO m => IO a -> m a
01:54:53 <Ghoul_> Oh yes.. hmm.
01:55:25 <Ghoul_> is there an easy way to get around that?
01:55:33 <johnw> what you want is to use an EitherP _ _ _ _ _ _ IO r in a place where the type is EitherP _ _ _ _ _ _ SessIO r
01:55:41 <johnw> and I have no idea how to do that, since I don't use pipes
02:02:57 <tdammers> I need some library advice
02:03:24 <tdammers> what would I use for the http server part for a RESTful web service?
02:05:18 <johnw> tdammers: I use http-conduit
02:05:41 <tdammers> isn't that for *client*s?
02:05:52 <johnw> yesod uses it for servers :)
02:06:04 <johnw> in fact, use yesod itself
02:06:21 <tdammers> I would prefer something more lightweight
02:06:34 <johnw> well, http-conduit is what yesod is using underneath
02:06:58 <tdammers> is there any documentation on how to do that? the yesod book only describes the client part
02:08:21 <jdoles> What's the best way to make a site multi-lingual? E.g. you can use the content negotiation of an external web-server (and use separate URLs for different languages) or you can just process the language preference every single time.
02:08:40 <johnw> tdammers: you've got a point there
02:08:49 <jdoles> The advantage of the latter approach is that when people change their settings and hit refresh, that it immediately works.
02:09:02 <jdoles> The advantage of the former approach is that it is faster.
02:09:16 <johnw> tdammers: sorry, it's WAI that you want to be using
02:09:28 <johnw> snap is the underlying HTTP server
02:09:57 <johnw> no, it's not snap
02:10:01 <johnw> meh, getting too late for me
02:10:16 <johnw> warp is what I meant to say
02:10:44 <johnw> tdammers: http://steve.vinoski.net/pdf/IC-Warp_a_Haskell_Web_Server.pdf
02:11:53 <tdammers> yeah, I've been googling around myself
02:12:02 <tdammers> this looks promising
02:13:37 <Ghoul_> OK the solution was actually a heap of stuff
02:13:56 <Ghoul_> I had to use the StateP transformer from pipes, and then I had to do copious lifting using the specialized lift liftP
02:14:56 <Ghoul_> It's kind of funny how pipes has all its own transformers, but it does make it really really easy to use so props to whoever made that if they're on here.
02:15:15 <johnw> Tekmo made it
02:15:17 <johnw> he's sometimes here
02:15:38 <Ghoul_> the types alone break my Ruler 80 though by like 10 characters
02:15:42 <Ghoul_> so I'll have to work on that next haha
02:17:04 <merijn> Ghoul_: That means you're achieving the next step in haskell mastery :p
02:17:16 <Ghoul_> hehe :)
02:17:21 <merijn> Real men have to linewrap their types
02:17:58 <haasn> good thing we have type synonyms!
02:19:17 <mstksg> anyone know if there are any haskell podcasts
02:21:20 <jdoles> If you need to build new abstractions for pipes, doesn't that just show that the compiler doesn't work for the the basic language? Wasn't composition supposed to be the same as Unix pipes?
02:21:23 <johnw> Realer men linewrap their type synonyms even
02:22:11 <quchen> johnw: Java is OT
02:22:15 <jdoles> At least, I feel that all these high-performance libraries just make the programming more difficult, because Haskell itself cannot or is not optimized.
02:23:03 <jdoles> When you program in these DSLs, you are really just working around Haskell, not using it, IMHO.
02:23:05 <haasn> but it breaks down when you consider that high-performance haskell programming is still easier and more elegant than high performance programming in many other languages
02:23:16 <quchen> Pipes isn't about primarily performance, it's a useful abstraction to send data around in your program.
02:23:18 <haasn> disagree about DSLs
02:23:21 <haasn> DSLs are part of Haskell
02:25:25 <quchen> Speaking of high performance, I wonder what Intel's Haskell Research Compiler does.
02:25:40 <quchen> The paper should have been released yesterday, but the link still doesn't exist.
02:29:29 <merijn> quchen: What I heard it takes GHC produced Core, optimises that, compiles to C and hands that to gcc
02:29:43 <merijn> Which seems logical, except for the GCC bit
02:29:54 <quchen> Yes, that's what I said on Reddit. :-)
02:30:10 <quchen> (The paper also mentions the Intel C compiler.)
02:30:32 <merijn> icc is pretty impressive
02:30:45 <quchen> "The backend of our compiler generates code in an extension of C called Pillar [1], which is then transformed to standard C code and compiled with the Intel C compiler or GCC."
02:31:23 <jdoles> Call me when Haskell beats Eigen.
02:31:37 <quchen> jdoles:
02:31:41 <quchen> so where were we
02:31:56 <quchen> merijn: Compilers are still somewhat magic to me, so I can't judge impressiveness there.
02:32:13 <jdoles> quchen: what library and what benchmark shows this?
02:32:41 <quchen> jdoles: Just stop.
02:32:53 <quchen> merijn: I find it much easier to imagine Haskell code transformations though, the language seems much more intuitive.
02:32:59 <tdammers> DSLs are a special case of building and applying abstractions
02:33:01 <jdoles> quchen: because you say so?
02:33:03 <tdammers> or maybe it's the other way around
02:33:13 <quchen> jdoles: because it's OT.
02:33:28 <jdoles> quchen: we were talking about high-performance.
02:33:35 <jdoles> quchen: Eigen is high-performance.
02:33:58 <jdoles> quchen: if Haskell was so high-performance and even a bit relevant, it would have something which destroyed Eigen.
02:34:00 <johnw> this channel is about Haskell
02:34:25 <jdoles> johnw: yes, and what I said is also about Haskell. Isn't that nice?
02:34:52 <merijn> jdoles: Not really, it's more about trolling and antagonising people and we would prefer you to either stop or leave
02:35:29 <jdoles> merijn: I didn't talk about people.
02:35:33 <quchen> merijn: I remember this post about how GHC optimizes `case` statements. (It was said to be part of a series, but I don't think it continued, or at least I didn't notice)
02:35:59 <quchen> That was very much like "how could this be any different"
02:36:14 <quchen> On the other hand, when C compilers start flipping loops around, I'm always confused. :-P
02:36:38 <jdoles> merijn: so, perhaps you could apologize for your false accusations?
02:37:30 <quchen> Complaining about false accusations is also OT. Use a private chat.
02:38:10 <merijn> @where ops
02:38:10 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver
02:38:10 <lambdabot>  roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
02:38:15 --- mode: ChanServ set +o johnw
02:38:22 <johnw> you rang?
02:38:49 <jdoles> They made you an op? They must have had a hard time finding ops then.
02:39:05 --- mode: ChanServ set +o johnw
02:39:05 --- mode: johnw set +b *!~jdoles@unaffiliated/jdolesnil
02:39:05 --- kick: jdoles was kicked by johnw (Rudeness)
02:39:08 <merijn> johnw: Yeah, apparently politely asking isn't sufficient
02:39:15 --- mode: johnw set -o johnw
02:40:25 <jdoles> What happened to the whole everyone is so friendly mantra in #haskell?
02:40:39 --- mode: ChanServ set +o johnw
02:40:40 --- kick: jdoles was kicked by johnw (Kicked)
02:41:15 <quchen> Thank you john for being so friendly as to bring friendliness back to this channel.
02:41:37 <quchen> Back on the subject of compilation, does anyone remember the post I was talking about above?
02:41:49 <johnw> quichen: I don't think I've read that one
02:41:52 <quchen> Roughly "what GHC does when compiling case statements"
02:42:06 <quchen> Guess I'll have to dig a little deeper in my history then.
02:42:21 --- mode: ChanServ set +o mauke
02:42:21 --- mode: mauke set -b *!~jdoles@unaffiliated/jdolesnil
02:42:33 <mauke> johnw: "nil"?
02:42:39 <johnw> @deopme
02:42:40 <lambdabot> Unknown command, try @list
02:42:43 --- mode: johnw set -o johnw
02:42:49 <johnw> oh, is my Lisp code broken again?
02:42:56 <johnw> i'll make a note to debug that
02:43:53 <quchen> So he wasn't banned in the first place :-D
02:44:00 <johnw> i guess not
02:44:21 --- mode: mauke set -o mauke
02:44:28 <johnw> kickban functions are difficult to test easily :)
02:44:47 <mauke> should've used a real type system :-)
02:44:49 <quchen> Oh my search for that post I found this post, which is also interesting (and funny): http://www.reddit.com/r/haskell/comments/m7uph/whats_going_on_with_id_id_id_id_0/
02:44:56 <quchen> id id id id id 0  -->  out of memory
02:45:13 <quchen> And this is some generated core from such a program: http://codepad.org/2YrUqs1E
02:45:30 <merijn> Speaking of lisp and types...any of you ever try typed racket?
02:46:32 <quchen> johnw: Ask someone to join some test channel and kickban him? Or write a small beat-me-up bot :-)
02:47:11 <Ghoul_> ahah thats a lot of void
02:49:02 <quchen> Ghoul_: Unit, you mean
02:49:14 <Ghoul_> () is called unit?
02:49:20 <merijn> Ghoul_: Yes
02:49:20 <johnw> yes
02:49:27 <Ghoul_> oh,okay.
02:49:41 <merijn> Ghoul_: It is the unit type, i.e. it has only one possible value
02:50:11 <merijn> There is Void too, which has zero possible values
02:50:26 <merijn> An edwardk package, obviously :)
02:50:31 <quchen> Ghoul_: data Unit = Unit
02:50:34 <quchen> data Void
02:50:39 <johnw> Ghoul_: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
02:50:43 <quchen> (that's it, Void is uninhabited
02:50:43 <quchen> )
02:50:57 <johnw> Chris also has a great video of presenting that material
02:51:38 <johnw> http://www.youtube.com/watch?v=YScIPA8RbVE
02:51:52 <Ghoul_> potential information overload
02:52:44 <johnw> just bookmark it, come back in a few months
02:52:50 <johnw> it'll still be good stuff then too :)
03:07:48 <quchen> Does GHC use the monad laws at all?
03:08:25 <quchen> Although violating the laws is genereally frowned upon, the Report doesn't enforce the Monad laws, it just strongly suggests them.
03:08:40 <merijn> quchen: No, I don't think so
03:08:44 <quchen> So GHC can't optimize "m >>= return" to m?
03:08:56 <merijn> quchen: Maybe there is a RULE for that?
03:09:03 <johnw> it doesn't optimize fmap f . fmap g to fmap (f . g) either, I don't believe
03:09:45 <quchen> Oh.
03:10:10 <quchen> So that's for compatibility with non-complying libraries`
03:10:12 <quchen> ?
03:10:19 <johnw> edwardk explained why to me, but I've forgotten
03:10:25 <johnw> there is a RULE for map, just not for fmap
03:10:47 <johnw> i'm not sure how you'd write a rule for a function with no definition
03:10:49 <quchen> Yes, for lists it's probably rewritten from fmap to fusing map
03:11:18 <johnw> i mean, writing a RULE for a particular definition of fmap is a different thing from having a RULE that automatically applies to every fmap
03:11:34 <johnw> I'm not even sure the latter can even be expressed
03:11:53 <quchen> Oh.
03:12:03 <quchen> It sounds simple enough though
03:12:13 <jfischoff> I'm struggling to get the ghc version number correctly. System.Info.compilerVersion is return [7,6] I was hoping for [7,6,3]. What am I doing wrong?
03:12:40 <mauke> jfischoff: what do you need that for?
03:12:59 <jfischoff> for a build system
03:13:16 <mauke> ?
03:13:53 <jfischoff> um
03:14:18 <jfischoff> So I am using the cabal in HEAD as an exe
03:14:58 <jfischoff> there is a function that creates the package-db based on some compiler and platform info
03:15:11 <jfischoff> I am recreated it. Its a one liner
03:15:12 <quchen> jfischoff: The source of compilerVersion looks somewhat strange (it uses a CPP constant to get the version). Maybe you should look for a more robust alternative.
03:15:32 <mauke> compilerVersion = Version {versionBranch=[major, minor], versionTags=[]} where (major, minor) = compilerVersionRaw `divMod` 100
03:15:40 <jfischoff> quchen: I hope there one ;)
03:15:45 <quchen> mauke: compilerVersionRaw = __GLASGOW_HASKELL__
03:16:00 <mauke> which is obviously something like 706
03:16:29 <jfischoff> mauke: what do I call to get something like 7.6.3?
03:16:43 <mauke> I don't even know if you can
03:16:57 <quchen> jfischoff: Issue a system call to `ghc --version` and parse that?
03:17:07 <quchen> It's dangerous as well, but not as bad as a random constant
03:17:07 <mauke> which is why I'm asking why you need that information
03:17:28 <jfischoff> and yet cabal is definitely is getting 7.6.3
03:17:40 <jfischoff> but I can't figure out what is different :(
03:17:43 <merijn> btw
03:18:07 <merijn> GHC 7.6.3 seems to depend on binary-0.5 is there anyway to upgrade my version of binary without horribly breaking a billion things?
03:18:18 <jfischoff> quchen: that is not terrible
03:18:23 * ocharles wonders where mmfreak is
03:18:35 <jfischoff> it is at least a step forward
03:18:56 <merijn> ocharles: He's been pretty busy I think, his presence has been spotty for a couple of weeks
03:19:02 <ocharles> ah
03:19:17 <startling> merijn: oh, so /that's/ why I was stuck on binary-0.5.
03:19:29 <startling> fwiw upgrading it didn't seem to hurt anything.
03:20:16 <merijn> startling: Did you just --force-reinstall?
03:20:21 <startling> yeah.
03:30:40 <jfischoff> what is the simplest way to call a system command get result as a string?
03:31:51 <quchen> jfischoff: http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html
03:32:22 <quchen> The most generic function there, createProcess, allows you to specify handles for STDOUT etc.
03:32:28 <jfischoff> that can't be the simplest way
03:32:47 <quchen> readProcess seems to be related as well
03:32:55 <quchen> That's probably what you want
03:33:03 <jfischoff> there is no wrapper for that is some popular package i.e. cmd "ls" ?
03:33:33 <jfischoff> that works
03:33:39 <quchen> readProcess "ls" [] ""
03:33:50 <jfischoff> yeah
03:34:12 <jfischoff> thanks :)
03:43:10 <klrr> is there any library that is easy to use and can play ogg files?
03:45:59 <Yaniel> libogg?
03:47:07 <klrr> Yaniel: is there any bindings for haskell i didnt find any on hackage
03:47:08 <klrr> ?
03:47:37 <johnw> how about shelling out to a utility that does such a thing?
03:47:41 <Yaniel> that I do not know
03:47:51 <klrr> johnw: how?
03:47:54 <johnw> runProcess
03:47:57 <johnw> or system
03:48:48 <klrr> isnt that kinda hack'ish solution? :P not sure if it will be approved if i contribute that to a project xD
03:48:48 <Lethalman> Yaniel, hogg? gstreameR?
03:48:48 <johnw> klrr: well, not everything needs to be written in Haskell :)
03:48:48 <Lethalman> klrr, hogg? gstreameR?
03:49:00 <klrr> Lethalman: thanks, gstreamer seems nice too
03:49:04 <Lethalman> with gst it should be as simple as parsing a string pipeline
03:49:17 <Lethalman> parseLaunch .... play pipline and you're done
04:27:48 <tdammers> hey, raw WAI appears incredibly performant... nice...
04:28:32 <donri> do you mean warp
04:32:56 <tdammers> WAI with a warp backend, yeah
04:33:14 <tdammers> 'raw' as opposed to using a full-blown framework like Happstack or Yesod
04:33:20 <tdammers> although those are pretty damn impressive already
04:34:13 <hpc> i don't know about yesod, but happstack is more of a giant collection of libraries than it is an actual framework
04:34:30 <tdammers> sure
04:34:47 <tdammers> they call it a "modular framework", but that's essentially the same
04:34:52 <tdammers> not that I think it's a bad idea
04:35:16 <tdammers> I kind of dislike monolithic frameworks
04:35:17 <Lethalman> tdammers, except "lightweight" starts to fail when you need, caching, file uploads and so on
04:35:38 <hpc> it's certainly better than wordpress ;)
04:35:41 <tdammers> Lethalman: in this particular case, I'm building a REST API for a game
04:35:53 <Lethalman> tdammers, for a rest api I usually use scotty
04:35:54 <tdammers> I'm not sure whether I'll do the frontend in Haskell
04:36:16 <tdammers> it's not really REST, actually
04:36:21 <Lethalman> whatever
04:36:31 <slack1256> tdammers: wait for ghc 7.8 then we will get a new I/O manager and possibly speed-ups on thos benchmarks
04:36:32 <Maior> most things aren't really REST
04:36:42 <Lethalman> for js lately I've been using ghcjs and it works so well it's unimaginable
04:36:43 <tdammers> more like a JSON API where POST requests inject events and GET requests query parts of the server state
04:37:11 <Lethalman> tdammers, services, let's call it services :)
04:37:20 <tdammers> hehe, yeah
04:37:20 <zomg> tdammers: Yesod in my experience is quite nice for building rest stuff since they try to follow that principle
04:37:33 <tdammers> yeah, but Yesod is *huge*
04:37:42 <tdammers> I want something small that compiles in under three minutes :)
04:37:51 <zomg> Yeah that is true, there is a lot of stuff in it
04:38:03 <donri> not much to gain from using yesod if you won't be doing any forms, databases, html etc
04:38:11 <tdammers> indeed, that was my thought
04:38:13 <zomg> It might be nice to have something like in the node-world where you can more easily combine different small libraries together
04:38:31 <tdammers> I think WAI fits my bill nicely
04:38:52 <tdammers> I already have a bare-bones game state and event handling system in place, and everything speaks JSON already
04:38:56 <zomg> Yeah warp is pretty easy to use as well, you'll just need to roll some routing system of your own and such but besides that.
04:39:02 <jfischoff> I want the simplest type safe routing that works with WAI. Haven't found it yet :(
04:39:16 <tdammers> the routing is practically non-existent
04:39:20 <donri> zomg: that's essentially happstack, and to some extent snap
04:39:39 <tdammers> there is only really one endpoint
04:40:01 <tdammers> you just send events there, formatted as JSON objects
04:40:07 <tdammers> and you get a JSON response
04:40:10 <tdammers> no routing required
04:40:23 <tdammers> well, maybe for the GET requests
04:40:31 <tdammers> having the query in the path is kind of nice and idiomatic
04:40:31 <jfischoff> sounds like json rpc
04:40:44 <tdammers> kind of, but not quite
04:41:03 <tdammers> when you send an event, it isn't executed immediately, but rather enqueued
04:41:06 <donri> there is no One True Solution; raw WAI is fine for some cases, full stack frameworks better for other cases
04:41:30 <tdammers> and then another thread keeps pulling events from the queue and applying them to the state
04:41:48 <tdammers> the events also get logged, which is about all the persistence I need
04:42:06 <jfischoff> I don't understand the complexity of routing solutions.
04:42:18 <tdammers> routing is easy, until you want to make it generic
04:43:23 <donri> jfischoff: web-routes-wai?
04:43:54 <jfischoff> still seems to complicated. But that could be just because I don't understand it
04:46:18 <donri> jfischoff: wai-dispatch?
04:48:04 <jfischoff> can you use yesod routes without make a yesod site?
04:48:57 <jfischoff> I was under the impression the two were tied together
04:49:16 <donri> yesod-routes doesn't seem to depend on yesod
04:49:25 <tdammers> from what I recall, happstack's routing system is fairly straightforward
04:50:14 <donri> if you don't care about the routes and just want type safe routing, using web-routes is very easy
04:50:15 <jfischoff> no it doesn't
04:50:50 <donri> it can generate the routing table for you from your route data type
04:51:15 <jfischoff> donri: I meant you are yesod-routes does need more of yesod
04:51:23 <jfischoff> err you are right ;)
04:51:49 <donri> http://hackage.haskell.org/packages/archive/web-routes/0.27.3/doc/html/Web-Routes-PathInfo.html#t:PathInfo
04:54:34 <tdammers> hmm, maybe I'll use scotty after all
04:54:40 <tdammers> looks promising too
05:00:00 <Yaniel> humm so I appear to be confused regarding $ vs .
05:00:14 <Yaniel> this works: solveRpn s = head . foldl foldfn [] $ words s
05:00:24 <Yaniel> but this doesn't solveRpn s = head . foldl foldfn [] . words s
05:00:26 <mauke> a $ b = a b
05:00:31 <mauke> a . b = \x -> a (b x)
05:00:37 <Yaniel> but lyah uses the latter
05:00:45 <mauke> remove s everywhere
05:00:54 <Yaniel> ah
05:01:07 <Yaniel> thanks
05:02:21 <Yaniel> (missed that lyah dropped the argument right after the start)
05:03:50 <Format> Hi all, can someone help me?
05:04:46 <Format> I need some help whit a constructor of a matrix of funtions.
05:06:10 <merijn> Yaniel: Basically (.) is for when you want to end up with a function, ($) is for when you want to end up with a value
05:06:30 <merijn> eh
05:06:33 <ion> yaniel: This should work: solveRpn s = (head . foldl foldfn [] . words) s
05:06:43 <merijn> Functions are values, so I guess that doesn't clarify much...
05:06:49 <ion> yaniel: That’s also equivalent to: solveRpn s = head . foldl foldfn [] . words [] . words $ s
05:07:03 <Yaniel> well, mayke's unwrapping of those helped
05:07:23 <donri> x . y is a function. you can either bind it to a name, or apply it to an argument with $
05:07:35 <magneticduck> quick question: what tools would I use to call a program from haskell in linux?
05:07:37 <ion> apply it to an argument with or without $
05:07:41 <magneticduck> I don't really care about capturing stdout
05:07:44 <magneticduck> or putting anything in stdin
05:07:53 <donri> (or pass it around as a higher order function)
05:08:01 <Format> who to construct a valid array of function like [ (+) , (-) , (>) , (<), ...]
05:08:07 <magneticduck> my question it probably pretty naive, but I@m wondering what kind of tools I'd use to get started
05:08:15 <shiona> Yaniel: so you finally started doing something in haskell?
05:08:45 <Yaniel> shiona: playing around with stuff while reading lyah
05:08:47 <donri> x $ y is the function x applied to the argument y. it's the same as (x) y
05:08:51 <Yaniel> so kind of :D
05:08:55 <magneticduck> Format: you can't construct that list of functions because they all have different types
05:09:15 <magneticduck> > let x = [(+), (<)] in head x
05:09:16 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
05:09:16 <lambdabot>    arising from a use of `GHC....
05:09:35 <magneticduck> because it expects (<) to have type (Num a) => a -> a -> a
05:09:52 <Format> magneticduck : Thanks.
05:10:47 <Format> magneticduck : so, if i want to define just [ (>) , (<)] this has all the same type, this should be posible?
05:10:56 <magneticduck> yes, that's possible
05:11:12 <magneticduck> > map ((
05:11:13 <lambdabot>   <hint>:1:7:
05:11:13 <lambdabot>      parse error (possibly incorrect indentation or mismatched ...
05:11:19 <magneticduck> lol whoops
05:11:33 <magneticduck> > map (($ 5) . ($ 3)) [(<), (>)]
05:11:34 <lambdabot>   [True,False]
05:12:04 <Format> magneticduck : can you help me whit an exsample of a simple one like [(>) , (<)]
05:12:18 <magneticduck> > map (\f -> f 5 3) [(<), (>)] --does the same thing using lambda notation
05:12:19 <lambdabot>   [False,True]
05:12:28 <Format> magneticduck : thanks! working on it.
05:13:11 <magneticduck> awesome; remember, 5 (<) 3 = (<) 5 3 = (($ 5) (<)) 3 = (($3) . ($ 5)) (<)
05:13:17 <magneticduck> haskell is awesome ain't it =P
05:13:46 <magneticduck> call off my question, I found the "spawn" package
05:14:13 <ab9rf> you just gave me a headache
05:14:28 <magneticduck> wait what; why is spawn :: IO a -> IO (IO a))
05:14:31 <magneticduck> O.o
05:15:06 <magneticduck> I thought you could write something along the lines of "spawn "xterm""
05:15:10 <ab9rf> nested IO type?
05:15:19 <opqdonut> magneticduck: spawn is like a promise/future
05:15:29 <magneticduck> ahah, I'm thinking about a different spawn
05:15:37 <magneticduck> I think the spawn I'm thinking of comes from the xmonad package
05:15:39 <magneticduck> :<
05:15:51 <opqdonut> http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Util-Run.html
05:15:55 <Format> magneticduck : if i need just to define a data like matrix = [(<), (>)] to the apply something like you describe there..is it posible or just in funcions like map...flodr.....etc.
05:16:14 <magneticduck> check out Data.Applicative
05:16:21 <magneticduck> I believe it should help?
05:16:25 <augur> magneticduck: i think you'll find
05:16:31 <augur> 5 (<) 3 is a type error
05:16:36 <magneticduck> ah sorry
05:16:42 <magneticduck> > 5 (<) 3
05:16:42 <lambdabot>   Could not deduce (GHC.Num.Num
05:16:43 <lambdabot>                      ((() -> () -> GHC.Types....
05:16:46 <magneticduck> yeah
05:16:55 <quchen> "Spawn" sounds redundant now that we have Async.
05:16:58 <augur> (<) means "use me like a normal symbol"
05:17:07 <augur> magneticduck: you want just 5 < 3
05:17:15 <magneticduck> > 5 $ (const id <) 3
05:17:16 <lambdabot>   Could not deduce (GHC.Classes.Ord (b0 -> a0 -> a0))
05:17:16 <lambdabot>    arising from a use o...
05:17:22 <magneticduck> aw, trying to hurt your brain again
05:17:25 <augur> magneticduck: 5 aint a function!
05:17:27 <magneticduck> > 5 $ 3
05:17:28 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
05:17:28 <lambdabot>    arising f...
05:17:38 <mux> Haskell: For when Perl doesn't give you enough ways to write something
05:17:38 <magneticduck> oh :0 I thought there was a thing in lambdabot...
05:17:43 <magneticduck> > 5 3
05:17:43 <ab9rf> augur: in lambdabot, 5 is a function
05:17:44 <lambdabot>   Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
05:17:44 <lambdabot>    arising f...
05:17:51 <magneticduck> huh.
05:17:57 <mauke> ab9rf: not anymore
05:18:03 <ab9rf> mauke: oh, that was changed?
05:18:03 <magneticduck> awesome
05:18:06 <magneticduck> that was disturbing me!
05:18:07 <augur> ab9rf: well lambdabot is ridiculous and must be ignored :P
05:18:13 <magneticduck> @type 5
05:18:13 <lambdabot> Num a => a
05:18:35 <magneticduck> mux: hehe
05:18:40 <Format> magneticduck : thanks! where is you "like" buttom :P
05:18:43 <ab9rf> mux++
05:19:03 <magneticduck> +magneticduck?
05:19:08 <magneticduck> I think that's the command
05:19:10 <magneticduck> =P
05:19:16 <magneticduck> +Format
05:19:30 <magneticduck> huh, I'm not sure, let me check lambdabot
05:19:43 <augur> Format: dont you fondle his buttom, now
05:19:47 <augur> not without asking first!
05:20:03 <augur> also
05:20:03 <Format> augur: lol
05:20:06 <augur> i think you're looking for
05:20:08 <augur> magneticduck++
05:20:11 <magneticduck> ahah
05:20:14 <augur> or something like that
05:20:31 <magneticduck> omg I have an amazing idea: make your name "Notepad"
05:20:41 <magneticduck> and whenever anybody talks about Notepad++
05:20:44 <magneticduck> you get karma
05:20:49 <ab9rf> haha
05:21:44 <Format> magneticduck: thtat was a reallly geek joke
05:22:24 <magneticduck> I'm a really geek duck
05:22:40 <augur> someone i know insists :V is a duck
05:22:42 <augur> so i guess
05:22:43 <augur> :V
05:23:52 <magneticduck> ROOAAARRRRR <-- sounds that ducks make
05:24:18 <magneticduck> also, stop that terrible duck face; don't make me paste a 10 line ASCII art duck
05:24:35 <magneticduck> ooh, I think this should move to #haskell-blah
05:24:38 <augur> OOAAARRRRR <-- sounds that ducks make before getting hit by oars
05:24:58 <magneticduck> yeah, definitly blah material =P let's go
05:25:05 <augur> magneticduck: it would help if you were there
05:25:16 <magneticduck> I am now there
05:25:56 <magneticduck> serious question: does "spawn" wait until the process finishes? and if it doesn't, how would I do that
05:27:51 <magneticduck> runProcessWithInput?
05:27:55 <jmcarthur_mobile> Check out System.Process
05:28:03 <magneticduck> ahah
05:28:57 <jmcarthur_mobile> There should be more than you need there.
05:29:54 <magneticduck> yeah
05:31:29 <epta>  /win 30
05:31:32 <magneticduck> now, I need to make sure that nothing happens while I'm running the process; is "readProcess" for example capable of that?
05:32:43 <magneticduck> so many decisions
05:32:51 <magneticduck> "system" looks nice
05:32:58 <jmcarthur_mobile> What do you mean by "nothing happens"?
05:33:18 <magneticduck> I mean, no other operations are executed
05:33:23 <magneticduck> in the program
05:33:35 <jmcarthur_mobile> Even in other threads?
05:33:52 <jmcarthur_mobile> You will need to use some concurrency mechanism for that
05:33:55 <magneticduck> yeah
05:34:00 <magneticduck> alright, I should be safe
05:34:23 <Yaniel> mux: I'm going to print that and hang it on my wall
05:35:08 <magneticduck> lol, how do you add a quote into lambdabot's database
05:36:05 <quchen> First, you need something quotable.
05:36:07 <DigitalKiwi> magneticduck: http://i.imgur.com/AT40oPm.jpg
05:36:21 <DigitalKiwi> rawr.
05:37:21 <magneticduck> RPAAARRWRRRR
05:37:59 <magneticduck> mux: "Haskell: For when Perl doesn't give you enough ways to write something"
05:38:05 <magneticduck> that's our quote, quchen
05:38:30 <quchen> Then @remember nick message.
05:39:41 <magneticduck> @remember mux "Haskell: For when Perl doesn't give you enough ways to write something"
05:39:41 <lambdabot> It is stored.
05:39:44 <magneticduck> @quote mux
05:39:44 <lambdabot> mux says: "Haskell: For when Perl doesn't give you enough ways to write something"
05:40:01 <magneticduck> legendary words
05:40:12 <Yaniel> yeeeahhh
05:40:26 <Taneb> @quote Taneb
05:40:26 <lambdabot> Taneb says: I'm doing the thing that every bored haskeller does one day and rewriting Prelude
05:40:36 <magneticduck> so true
05:40:50 <magneticduck> bullet 1) the number system .__.
05:41:10 <quchen> Haskell doesn't have a number system. It has numbers though.
05:41:14 <magneticduck> hehe
05:41:31 <magneticduck> it has numbers, in various.. things. Which together form.. a set of number system things
05:41:50 <Taneb> (+), (*), (-) and negate could be in their own class
05:42:08 <magneticduck> also, the Eq class
05:42:21 <magneticduck> raise of hands, who here thinks that Floats shouldn't really support equality
05:42:23 <magneticduck> :|
05:42:25 <quchen> Taneb: I think most of the current system is unfixable because we don't have a stricly better implementation.
05:42:36 <magneticduck> I mean, it just makes newbies think they can do it when they can't really
05:42:40 <quchen> magneticduck: Floats can be equal therefore Eq makes sense.
05:42:46 <quchen> It's dangerous, yes.
05:42:55 <magneticduck> I don't think that Floats are equatable
05:43:03 <magneticduck> I mean, occasionaly they happen to be the same
05:43:04 <Taneb> quchen, how about we start with a strictly worse implementation then work from there
05:43:06 <magneticduck> but it's no rule
05:43:34 <quchen> Floats are a string of bits specified into great detail by the IEEE standard. If all bits are equal, the floats are equal.
05:43:46 <bcoca> newb here, file i/o question, is readInt the correct way to just read a chunk of a file? using Data.Bitstring.Lazy
05:43:59 <quchen> (Should floats not be multipliable because they're non-associative?)
05:44:13 <startling> quchen: of course!
05:44:20 <startling> that's not multiplication, anyhow.
05:45:54 <quchen> bcoca: Have a look at readFile in Data.ByteString.Lazy.
05:46:15 <quchen> If you want to read a relatively small amount of data, use hGet.
05:46:25 <magneticduck> quchen: but as far as they represent numbers, they don't support numeric equality. I guess if you wanted to make it a rule to make class instances as much as you can, it would make sense
05:46:42 <quchen> (ByteStrings are chunk-based, so if you just need 20 bytes it's pretty wasteful to generate a full chunk, which is a few KiB I think.)
05:46:47 <bcoca> quchen: yes, but what i want to do is read chucks of a file and get a hash on  the chunk
05:46:59 <bcoca> seems like most functions dotn let you specify the size
05:47:04 <magneticduck> the thought of chunks of hash is making me hungry
05:47:17 <bcoca> magneticduck: i see what you did there
05:47:36 <startling> equality on floats isn't even an equivalence relation, is it? :(
05:47:48 <bcoca> quchen: think bitorrent, i want to separate a file in 'set sized' chunks, hash each chunk
05:47:59 <startling> magneticduck, check out -XMagicHash I guess.
05:48:04 <magneticduck> > (sqrt 2) ^ 2
05:48:05 <lambdabot>   2.0000000000000004
05:48:25 <quchen> bcoca: Oh, well that you can do by just reading the full file lazily and then dividing the input up piecewise.
05:48:45 <bcoca> quchen: my question is how do i do that division?
05:49:21 <bcoca>  content < -getContents seems to do the lazy load, but how do i read a 4k chunk, for example?
05:49:45 <bcoca> nvmd, just read get, takes bytes
05:49:58 <bcoca> or hGet
05:50:12 <quchen> bcoca: bracket (openFile "file.foo") hClose (hGet (2^12))
05:50:15 <quchen> Something like that?
05:50:22 <quchen> Open, hGet a certain amount of bytes, close
05:50:24 <bcoca> yes
05:50:31 <bcoca> thnx, that is what i needed
05:51:19 <bcoca> well, looping over hget till end of file, but yes
05:52:03 <quchen> magneticduck: Floats don't have an interpretation really. They're a sort of approximation of the reals, and that's as far as the analogies go.
05:52:21 <quchen> There are even two infinities in there.
05:52:33 <quchen> And 0 isn't necessarily -0
05:52:49 <mux> also, NaN
05:52:58 <quchen> Which is a floating point number :-D
05:54:12 <quchen> I remember that I had to compare timestamps for equality at some point. It was in some message-passing scenario where two queries had to be matched, and the easiest way of filtering out unsuitable ones was by checking whether their timestamp was a different Double.
05:55:36 <magneticduck> lol NaN is a number
05:55:38 <magneticduck> ...
05:55:39 <magneticduck> no it isn't
05:55:42 <magneticduck> NaN is not a number
05:55:46 <Maior> lol
05:55:54 <tdammers> NaN is the number formerly known as Not A
05:56:12 <magneticduck> heh
05:56:27 <quchen> Not a number is a number, according to the IEEE floating point standard, which specifies floating point numbers.
05:56:49 <tdammers> No, it's not. It's a floating-point number. Not an actual number.
05:56:57 <quchen> Not a number therefore is not not a number, therefore (p and not p) therefore ARGH
05:57:15 <tdammers> the fallacy is thinking that "floating-point number" implies "number"
05:57:23 * mux watches quchen disappear in a puff of logic
05:57:46 <quchen> mux: I don't have to puff. I can do anything now! Ex falso etc.
05:58:10 <tdammers> you have to make a choice though - argue about floating-point numbers, or argue about actual numbers
05:58:11 <startling> does the IEEE standard specify a paraconsistent logic too?
05:58:17 <mux> careful, you're going to anger the gods now with such words
05:58:38 <quchen> tdammers: That's a pretty semantic argument now. There's no authority for calling things "number".
05:58:53 <tdammers> quchen: what about math?
05:58:57 * magneticduck is a number
05:59:21 <magneticduck> there is only one of me though
05:59:28 <magneticduck> so math is pretty boring
05:59:45 <quchen> tdammers: Math talks about natural numbers, which is some set with operations on it, and real numbers which is a set with some operations on it, and rationals which is a set with some numbers on it.
06:00:05 <quchen> There's no theorem "P is a number iff ..."
06:00:11 <quchen> Anyway, this leads to nothing.
06:02:32 <tdammers> I'd say that those sets have to be defined somehow, if only by the operations
06:05:53 <tdammers> but yeah, the discussion has turned into -blah material about 15 minutes ago
06:22:28 <`Jake`> Is there something like forever which I can exit with a certain condition or do I have to write such a function myself?
06:24:07 <bergmark> @hackage monad-loops `Jake`
06:24:07 <lambdabot> http://hackage.haskell.org/package/monad-loops `Jake`
06:24:16 <`Jake`> thanks
06:24:54 <neurofonzic> Anyone here done the matasano crypto challenges?
06:25:25 <haasn> johnw: why isn't bind = (=<<) -- ?
06:26:50 <ion> What bind?
06:28:44 <zomg> neurofonzic: I recall looking at some a while back and being like "wtf bbq grass"
06:30:24 <neurofonzic> zomg: Did you end up doing any of them?
06:31:03 <zomg> I thought not making any sense and thus not doing any of them was implied by "wtf bbq grass" ;)
06:31:20 <zomg> it was something that might be interesting if I had the time to learn more abiout it though
06:48:22 <haasn> ion: from monad-extras
06:49:47 <ion> Huh. I would expect it to be (=<<) as well.
06:50:36 <magneticduck> does anybody know how to make an empty .wav file?
06:50:42 <magneticduck> does just touching it work?
06:51:12 <ion> It’ll probably need a header to be a real wave file.
06:51:18 <magneticduck> yeah, that's what I thought
06:51:19 <b2coutts> magneticduck: depends on your definition of '.wav file'
06:51:23 <magneticduck> so maybe trimming it in sox?
06:51:30 <magneticduck> because making a synth file of 0 length..
06:51:32 <magneticduck> makes an infinite file
06:51:37 <magneticduck> -.-
06:51:46 <magneticduck> I guess I'll try trimming
06:53:25 <haasn> magneticduck: ffmpeg should be able to do it either way
06:55:42 <magneticduck> ahah, "sox -n output1.wav synth 1 sine 1000 trim 0 0"
06:55:46 <magneticduck> xl
06:56:19 <ion> I was trying gst-launch filesrc location=/dev/null ! audioparse ! wavenc ! filesink location=foo.wav, but programs didn’t seem to be happy with the length being zero.
06:56:49 <magneticduck> yeah
06:56:52 <magneticduck> nothing to grab onto
06:56:54 <magneticduck> =P
06:56:59 <magneticduck> on to*
06:57:23 <magneticduck> playing with sox is pretty fun
07:00:26 * hackagebot cmdargs 0.10.5 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.5 (NeilMitchell)
07:00:30 <ion> gst-launch filesrc location=/dev/zero blocksize=4 num-buffers=1 ! audioparse ! wavenc ! filesink location=foo.wav
07:01:56 <Lethalman> ion, lol nice
07:05:20 <ion> Interestingly, with blocksize ≤ 3, it dies with: gst_adapter_take_buffer: assertion `nbytes > 0' failed, Caught SIGSEGV accessing address 0x20. But this is offtopic, i’ll stop now.
07:06:04 <haasn> magneticduck: ffmpeg -f s24le -i /dev/zero -t 0 test.wav # should do it too
07:06:13 <haasn> that took me way longer than anticipated =P
07:06:16 <magneticduck> /dev/zero?
07:06:17 <magneticduck> huh
07:06:24 <magneticduck> haha, ffmpeg has lota options
07:06:44 <magneticduck> I got my own solution too: sox -n silence.wav synth 1 sine 1000 trim 0 0
07:06:49 <magneticduck> but thanks for the ffmpeg solution
07:06:51 <haasn> saw that
07:06:55 <magneticduck> k
07:07:12 <magneticduck> yours is certainly more pro =P
07:07:33 <haasn> assuming it produces the correct output
07:07:52 <haasn> my media player doesn't seem to want to play it
07:08:15 <magneticduck> really, huh
07:08:19 <haasn> it plays it fine with durations greater than 0, eg. -t 1
07:08:27 <magneticduck> it crashes?
07:08:28 <magneticduck> what happens?
07:09:28 <ion> Probably the same issue with my initial command, programs don’t seem to be happy with wave files with a length of zero.
07:09:59 <haasn> there's literally not much difference between a 0 second file and a 1 second file, apparently; just two ` characters more
07:10:15 <haasn> magneticduck: av_find_stream_info failed
07:13:08 <haasn> ‘aplay’ plays it successfully
07:15:11 <ion> To make this slightly more on-topic: ghc -e ':m + Data.WAVE' -e 'putWAVEFile "foo.wav" $ WAVE (WAVEHeader 1 8000 8 Nothing) [[0]]'
07:15:30 <ion> [[]] makes an invalid one.
07:16:08 <ion> (as does [] obviously)
07:19:46 <p_l> hello. Is there a way to declare in ~/.cabal/config to pass -optc=-fPIC for all compiled packages?
07:23:38 <JoeyA> In Network.Socket.accept, it allows the socket to be either Connected or Listening (see isAcceptable).  When would someone call accept() on a connected socket (rather than just a listening socket)?
07:33:01 <HugoDaniel> when will a 64-bit ghc be available for windows ?
07:40:32 * hackagebot iCalendar 0.3 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.3 (ChristianRoedliAmble)
07:41:14 <hvr> HugoDaniel: http://www.haskell.org/ghc/download_ghc_7_6_3#windows64
07:43:07 <HugoDaniel> ah yes
07:43:13 <HugoDaniel> thanks :) yes
07:43:23 <HugoDaniel> is there any 64bit haskell platform ?
07:43:30 <hvr> no idea
07:43:47 <ab9rf> haven't seen one yet
07:44:14 <ab9rf> at least for windows
07:44:15 <hvr> I'm actually surprised GHC is used on non-unix platforms anyway :)
07:44:32 <ab9rf> hvr: i use ghc on windows but it is often annoying
07:44:33 <HugoDaniel> why mingw32 if its a 64bit build ?
07:44:45 <ocharles> Ok, I just encountered a seriously painful wtf. Why does changing 'LB.fromString . qName . elName $ element' into 'LB.fromString $ qName . elName $ element' cause my program to go from using 2GB resident memory to 1MB resident memory ?
07:44:56 <hvr> ab9rf: I figure as much, given that most developers don't have a windows system to test their stuff on for compat
07:45:04 <HugoDaniel> i need to use it in windows, but ive been using java because of this 32/64 arch thing :(
07:45:09 <ab9rf> hvr: basically impossible to use with libraries that weren't compiled with mingw
07:45:23 <ab9rf> hvr: and even those that were compiled with mingw are often difficult to get to work
07:45:32 * hackagebot vault 0.3.0.0 - a persistent store for values of arbitrary types  http://hackage.haskell.org/package/vault-0.3.0.0 (HeinrichApfelmus)
07:45:34 <HugoDaniel> mostly odbc access, requires a 64bit build, and i can't access this particular machine from any *nix
07:45:48 <ab9rf> HugoDaniel: you don't need 64 bits to use ODBC
07:45:51 <hvr> HugoDaniel: no idea, according to http://ghc.haskell.org/trac/ghc/wiki/WindowsGhc I'd expect it to have a mingw64 system
07:45:53 <opqdonut> ocharles: wow, is that really the only change?
07:46:04 <ocharles> yea
07:46:04 <ab9rf> HugoDaniel: there is an 32-bit odbc manager
07:46:13 <opqdonut> ocharles: are you compiling with optimizations on?
07:46:20 <ocharles> opqdonut: yes, -O2
07:46:24 <HugoDaniel> ab9rf: the mssql is 64bit
07:46:28 <ocharles> opqdonut: let me paste the program
07:46:29 <ab9rf> HugoDaniel: doesn't matter
07:46:40 <ab9rf> HugoDaniel: you can still access it from 32 bit code running in wow64
07:46:53 <HugoDaniel> ab9rf: m$ doc. says i can only use one version of the odbc driver
07:46:59 <ab9rf> HugoDaniel: ignore it
07:47:01 <hvr> ab9rf: how realiable is the GHC RTS under windows btw?
07:47:05 <ab9rf> HugoDaniel: either it's wrong or you're misreading it
07:47:07 <HugoDaniel> so i can use both versions at the same time ?
07:47:24 <ab9rf> HugoDaniel: the server running in 64 bit has nothing _at all_ to what the client has to run in
07:47:43 <HugoDaniel> i have a butload of other .net apps that "need" the 64bit version of the odbc driver
07:47:47 <HugoDaniel> ok, let me test it then
07:47:47 <ab9rf> HugoDaniel: on the same system, yes.  obviouisly not in the same _application_ but that should be obvious
07:47:50 <HugoDaniel> ill open up the 32bit manager
07:48:01 <HugoDaniel> ok
07:48:06 <HugoDaniel> let me try it then, w8
07:48:07 <HugoDaniel> :D
07:48:20 <ab9rf> HugoDaniel: remember that microsoft manuals are written by microsoft marketing, not by microsoft developers
07:49:10 <ab9rf> HugoDaniel: ghc is not a .net application
07:49:24 <HugoDaniel> i know :(
07:49:32 <ab9rf> i don't know about windows 8, actually.  i've not messed with W8
07:49:34 <HugoDaniel> what i was saying is that i can't just replace the mssql to a 32bit version one
07:49:46 <hpaste> ocharles pasted “./$ wtf” at http://lpaste.net/91303
07:49:50 <ab9rf> in W7, S2K8, and S2K8R2 you can definitely use the 32bit odbc drivers
07:49:55 <ocharles> opqdonut: ^ see that paste
07:50:06 <ocharles> If I change line 38, I go from 1MB res to 1.4GB
07:50:12 <ab9rf> ocharles: haha
07:50:23 <ocharles> which is terrifying
07:51:29 <ab9rf> hvr: i've never had GHC on windows misbehave except when trying to link to external native code libraries
07:51:32 <HugoDaniel> ab9rf: yes amazing i had it connected
07:51:45 <HugoDaniel> now let me run a simple select
07:52:22 <ab9rf> HugoDaniel: it's amazing how much misunderstanding there is about 32 bit emulation on 64 bit machines
07:52:44 <opqdonut> ocharles: I get 30,264 vs 30,632 bytes maximum residency
07:53:09 <ocharles> opqdonut: interesting, I'm on GHC 7.6.3
07:53:11 <opqdonut> oh, that was without -O2
07:53:20 <opqdonut> I'm probably on something ancient, let me check
07:53:21 <ab9rf> HugoDaniel: especially since the WOW64 emulation is actually very good.  many 32 bit apps will run faster and more reliably in WOW32 on a 64-bit machine than they would have on a 32-bit native machine
07:53:27 <opqdonut> oh, 7.4.1
07:53:36 <HugoDaniel> ab9rf: thanks :D this is going to save me a lot of Java code!
07:54:07 <HugoDaniel> this is one of the happiest days of my life
07:54:19 <opqdonut> ocharles: ok, with -O2 I get the same behaviour as you
07:54:31 <ocharles> opqdonut: good to know it's reproducable
07:54:33 <opqdonut> ocharles: you should probably bring this up with #ghc or submit an issue
07:54:46 <ocharles> opqdonut: I'll move over there now and see what they say
07:55:03 <opqdonut> (with -O2 it's 672,141,808 vs 29,960)
07:55:11 <ab9rf> HugoDaniel: you can even mix 32 and 64 in the same "application" if you're using DCOM and the DCOM component can be set to run as "apartment", because that'll cause it to run in a WOW64 svchost container with DCOM IPC, which crosses process boundaries
07:55:39 <HugoDaniel> that is elite :)
07:55:53 <HugoDaniel> i barely know how to move around in windows... :/
07:56:32 <ab9rf> HugoDaniel: i've been a windows sysadmin for a dozen years now :)
07:57:09 <HugoDaniel> allright, thats a good skill to have
07:57:35 <ab9rf> a dying one though
07:57:39 <ab9rf> microsoft has maybe four years left
07:57:50 <b2coutts> you think so?
07:57:59 <ab9rf> although the xbox and MSSQL might last longer
07:58:00 <HugoDaniel> do you actually use powershell ? i dont understand the "power" or even the "shell" part of the name
07:58:04 <b2coutts> I figure there are still a lot of people with windows ingrained into their minds
07:58:16 <ab9rf> HugoDaniel: yes, i use powershell.  it's a weird language.
07:58:25 <b2coutts> I'd have thought xbox was in much bigger trouble than windows
07:58:31 <HugoDaniel> yeah, my boss only uses windows and msaccess
07:58:52 <ab9rf> b2coutts: desktops are dying, so windows is dying with them
07:58:58 <b2coutts> oh, I suppose
07:59:13 * b2coutts is still in denial about desktops dying
08:00:12 <ab9rf> also, as more and more stuff moves to the cloud, the need for havinga  particular OS at the client end is disintegrating
08:00:59 <ab9rf> large companies are moving increasingly to thin clients with application virtualization, and small companies to SaaS delivery using web clients.  neither of these platforms requires windows on the client app; linux (or even android) does fine
08:02:47 <ab9rf> microsoft's failure to produce a meaningful entry in the handheld market combined with people leaving their server applications (except for MSSQL) in droves, is going to doom them
08:03:40 <ab9rf> the exception is SQL: MSSQL looks fairly strong given the way Larry Ellison is murdering both Oracle and MySQL
08:03:40 <HugoDaniel> so android is the future then ?
08:03:58 <ab9rf> HugoDaniel: for the next five years, it is looking more and more like android is the future, yes
08:04:01 <HugoDaniel> yeah, everybody uses mssql where i work :(
08:04:24 <HugoDaniel> then thing in android is java
08:04:36 <HugoDaniel> can't we just get rid of java* ?
08:04:41 <ab9rf> HugoDaniel: indeed.
08:05:12 <HugoDaniel> and the development seem to be quite easy
08:05:19 <HugoDaniel> even for java people
08:05:29 <ab9rf> the thing is, Oracle does not offer a great advantage over MSSQL for most applications, and MSSQL is quite a bit cheaper.
08:06:04 <bcoca> ab9rf: postgresql is even cheaper
08:06:10 <ab9rf> MSSQL EE is about 10% less annually than oracle, and MSSQL SE is less than half
08:06:26 <yitz> people still use powerpoint, word, and excel. they work better on windows and windows phone.
08:06:33 <ab9rf> bcoca: but not nearly as featureful, and its query planner is nowhere near as good
08:06:39 <zomg> Best part of Java: The marketing nonsense in the Java Updater
08:06:49 <zomg> "Experience the rich web content with Oracle Java (tm)!"
08:06:52 <HugoDaniel> yeah, but postgresql is not "enterprise" and it doesn't come with a nice UI and nice templates to build procedures and all, so people with money and microsoft certifications prefer mssql over postgresql
08:06:52 <zomg> or whatever it says
08:06:53 <zomg> =)
08:07:11 <mauke> ab9rf: what features are missing?
08:07:17 <bcoca> ab9rf: what features does mssql have over postgresql? also last i looked their query planners were very much on par
08:07:31 <HugoDaniel> my boss only uses msaccess, and he produces amazing sql queries that look like huge trains of overcomplicated rumble
08:07:35 <bcoca> they do both decsend from postgres (MS trhough a 2nd hop from sybase)
08:07:36 <zomg> in my experience mssql has way better tools for things like profiling queries and such
08:08:09 <ab9rf> bcoca: largely administrative.  also, no OLAP support as far as i know, no reporting services, security is much more opaque
08:08:46 <bcoca> opaque? its a simple role model with a ip acl on top?
08:09:02 <klrr__> http://lpaste.net/91304 hmm, anyone got an idea why i get stack overflow here?
08:09:04 <bcoca> postgresql does have olap, not that i use it, but i know people who do
08:09:19 <bcoca> tools, cmd line is good enough for me, but MS does have much nicer GUIs
08:09:24 <bcoca> but i dont use those
08:09:34 <earthy> mssql seems to have more tooling integrating it into the windows world
08:09:35 <ab9rf> bcoca: that's news to me, but ok.  my main impression is that postgres is much harder to administer and is more rigid in that respect.
08:10:11 <bcoca> i've done both from command line, just as easy as hard as any other DB (xcept mysql which has insane user acl model)
08:10:13 <ab9rf> also, i'm not convinced of the robustness of the engine.
08:10:28 <earthy> postgresql is mighty robust
08:10:31 <ab9rf> and of course backup solutions are not as readily available, especially for live backup
08:10:32 <earthy> in my experience
08:10:35 <HugoDaniel> what i usually do is java code that reads mssql queries from the command line and produces json output, then its a bunch of .cmd files that secure copy that json to some public *nix servers
08:10:43 <yitz> bcoca: when your security is built completely around open directory, it could be that the postgresql model seems opaque
08:10:46 <FreeFull> klrr__: Your code is fine
08:10:53 <FreeFull> klrr__: Or at least, it works for me when I run it
08:10:56 <HugoDaniel> i keep these in the windows scheduler running like one every 2 minutes
08:10:56 <bcoca> yitz: i find AD opaque
08:11:05 <ab9rf> yitz: actually MSSQL's security is not built around AD, it's intergrated with it fairly poorly :)
08:11:07 <HugoDaniel> and then do everything in haskell on the *nix servers
08:11:12 <yitz> bcoca: me too. but i'm not an enterprise it manager.
08:11:32 <yitz> ab9rf: that doesn't stop people from thinking that way
08:11:36 <ab9rf> AD is fairly straightforward when you've been using it for 12 years
08:11:45 <yitz> ab9rf: right :)
08:11:48 <bcoca> mssql security was (havent used in a few) the same as postgres/sybabes/postgresql, role based
08:11:56 <earthy> AD is LDAP plus a few extra bits
08:12:00 <ab9rf> bcoca: it's been role based since SQL Server 7
08:12:01 <earthy> LDAP is not that opaque
08:12:03 <ab9rf> bcoca: which was 2001
08:12:08 <bcoca> earthy: extra bits to break it
08:12:12 <ab9rf> bcoca: no, 1998
08:12:18 <bcoca> ab9rf: before that, it was role based in sybase
08:12:32 <earthy> bcoca: there's a bit of DNS integrated, there's a bit of WINS integrated, there's a bit of Kerberos integrated
08:12:50 <bcoca> earthy: yes, all enough to break all of those standards
08:12:57 <ab9rf> bcoca: could be, my first MSSQL version was 7 although i poked at some 6 servers way long ago
08:13:34 <ab9rf> AD is LDAP, with DNS mainly for locating LDAP servers.  WINS is legacy crap.
08:13:34 <bcoca> ab9rf: mssql was dervived from sybase which was derviced  from postgres (not same as postgresql which was also derived from postgres)
08:13:39 <bcoca> all of them used roles
08:13:53 <bcoca> WINS is MS netbios DNS
08:14:10 <ab9rf> bcoca: both are derived from Ingres, iirc.
08:14:15 <bcoca> yes
08:14:16 <ab9rf> Ingres being ancient
08:14:25 <bcoca> actually its OSS now, really nice DB
08:14:27 <earthy> ab9rf: AD is not just LDAP plus non-standard LDAP schema's
08:14:29 <bcoca> still being updated
08:14:31 <earthy> -'
08:14:45 <ab9rf> earthy: LDAP + Kerberos for the most part
08:14:59 <bscarlet> you guys seem a little off topic.
08:15:03 <ab9rf> earthy: with proprietary extensions to break stuff
08:15:12 <ab9rf> bscarlet: yes sorry
08:15:12 <yitz> bscarlet: i was just noticing that too
08:15:14 <bcoca> bscarlet: true
08:16:11 <earthy> my bad
08:16:18 <earthy> so, haskellDB talks to all of them :)
08:16:24 <bscarlet> :-)
08:16:45 <yitz> earthy: how about persistent?
08:17:14 <ab9rf> i have an old app written with perl in front of postgres, i should rewrite it in haskell :)
08:17:27 <klrr__> http://elm-lang.org/edit/examples/Intermediate/Mario.elm in this example, there's "jump {y} m = .." and "walk {x} m = ..", m is the mario datastruct, but what does {y} and {x} mean? is it just to be able to use the value without prefixing "m." on it? in jump function, what is the diff between y and m.y?
08:17:44 <klrr__> sry for asking here but #elm aint very active
08:18:06 <yitz> klrr__: off topic - what does that have to do with postgres?
08:18:11 <applicative> haha
08:18:29 <Lethalman> haskell wiki down
08:18:32 <applicative> klrr__: maybe it's elm's sexy record system somehow
08:18:52 <klrr__> applicative: i thought that too, but then why does he use m.y and y in the function?
08:18:53 <earthy> yitz: dunno. haven't played with persistent
08:19:14 <earthy> (doing mostly C# these days... damn do I miss a true type system)
08:19:26 <applicative> y can belong to anything with a y field? just guessing, but m.y is the y field of m
08:19:31 <donri> klrr__: because he needs the m for other stuff
08:19:33 <applicative> only that doesn't make sense
08:19:45 <Tinned_Tuna> earthy: yea, I write Haskell in my off time from Java and Python. Good god a real type system is so nice.
08:19:58 <klrr__> applicative: do you know about helm btw? :)
08:20:04 <applicative> helm no
08:20:17 <Maior> Tinned_Tuna: hah same
08:20:29 <ab9rf> Tinned_Tuna: i've been switching between haskell and ruby lately, and that causes mental whiplash on a regular basis
08:20:32 <klrr__> applicative: it's kinda like Elm , but in haskell and is using Cairo for drawing :)
08:20:34 <donri> klrr__: jump {y} m = if y > 0 && m.y == 0 then { m | vy <- 5 } -- how would you write the then clause without m?
08:20:55 <klrr__> donri: that's not my question in the first place
08:20:59 <donri> presumably elm doesn't have at-patterns
08:21:14 <klrr__> donri: i wonder what {y} is and what the diff between y and m.y is
08:21:23 <klrr__> applicative: http://helm-engine.org/
08:21:28 <donri> klrr__: no but i'm suggesting you're probably right when you suspect {y} lifts out the y value :)
08:21:45 <klrr__> donri: aa, okey thank you :)
08:21:47 <applicative> what's it lifting the y value of?
08:22:00 <donri> klrr__: so the difference is that with m.y you get access to the rest of 'm'
08:22:23 <donri> also in this case, y and m.y are the 'y' of two different records, two arguments
08:23:41 <Tinned_Tuna> ab9rf: that sounds... unpleasant. At work I tend to make notes in (effectively) haskell because it's short & quick, then laters translate to java idiomatic code once I've got an algo worked out.
08:23:43 <applicative> so does the function definition foo {y} m = .... have as first argument 'anything with a y field'?
08:24:10 <klrr__> wait the step function in http://elm-lang.org/edit/examples/Intermediate/Mario.elm only gives jump one argument, but it takes two, this is a bit confusing...
08:24:26 <donri> klrr__: but it's part of a composition
08:24:33 <donri> you can only compose functions
08:24:53 <klrr__> donri: okey
08:24:53 <donri> if you give a function all its arguments the result is not a function
08:25:06 <klrr__> donri: i get what you mean but i got hard time apply it to reading the code
08:25:25 <earthy> Tinned_Tuna: java idiomatic? really? from haskell?
08:25:59 <Tinned_Tuna> earthy: it's basically "Get the core of the algorithm worked out, then plug it into a 'nice' Java-OO design"
08:26:16 <donri> klrr__: yeah it's hard to read without type signatures
08:26:25 <donri> i think type signatures are a recent addition to elm
08:26:30 <donri> and the example might predate them
08:26:39 <klrr__> one last question regarding http://elm-lang.org/edit/examples/Intermediate/Mario.elm , why "y > 0 && m.y == 0" and not just "m.y == 0"?
08:26:52 <donri> klrr__: not the same "y"
08:27:02 <klrr__> hmm
08:27:31 <klrr__> donri: isnt the dir argument the mario struct?
08:27:47 <donri> klrr__: i think the first argument is from the Keyboard.arrows signal http://elm-lang.org/docs/Keyboard.elm
08:27:48 <klrr__> donri: does jump takes two different marios?
08:29:14 <donri> klrr__: no it takes a {x:Int,y:Int} and a mario
08:29:21 <klrr__> aaa
08:29:25 <klrr__> now it makes more sense
08:29:31 <klrr__> donri: thanks for helping me out :)
08:29:42 <donri> technically i think it just takes any records that have the fields it uses
08:29:51 <applicative> this elm language could do with more type signatures
08:30:04 <donri> applicative: quite
08:32:12 <applicative> i see what donri means, he is using {x} and {y} in the args because they are associated with keys already
08:33:35 <killy9999> how can I write literals for unboxed Float ?
08:33:42 <applicative> it must make sense -- mario actually jumps
08:34:01 <applicative> 1.22#
08:34:06 <donri> applicative: elm records are nothing like haskell records btw
08:34:36 <applicative> donri: yes i know, i remember discussing their design with him here for example
08:34:39 <kingugo> > True && False
08:34:40 <lambdabot>   False
08:34:41 <killy9999> applicative: thanks
08:34:48 * killy9999 only knows deep elm records
08:34:57 <donri> deep what?
08:35:02 <kingugo> @wiki hoogle
08:35:02 <lambdabot> http://www.haskell.org/haskellwiki/hoogle
08:35:18 <applicative> kingugo: is hoogle down?
08:35:27 <killy9999> donri: deep elm records :)
08:35:33 * hackagebot simple-index 0.1.0.0 - Allows simple indexation on any data type  http://hackage.haskell.org/package/simple-index-0.1.0.0 (HugoGomes)
08:35:35 <donri> yes, what's that
08:35:49 <applicative> is that (deep elm) records or deep (elm records)
08:35:56 <kingugo> applicative: nope
08:36:02 <killy9999> former one :D
08:36:16 <kingugo> just testing lamdsbot that i setup on a channel.
08:36:22 <applicative> ah
08:36:34 <kingugo> to see if it works same way it works here
08:36:50 <kingugo> @msg applicative tesing
08:36:50 <lambdabot> Not enough privileges
08:37:00 <kingugo> did you see that?
08:37:15 <applicative> yes 'Not enough privileges' etc
08:37:20 <kingugo> applicative, it wasnt from me
08:37:35 <Krakarn> sry noob question: Why am I getting "Illegal type signature in instance declaration: fromInteger :: Num a => Maybe Integer -> Maybe a
08:37:41 <kingugo> ye, but it was'nt like that few days back
08:37:44 <applicative> we love noob questions
08:38:12 <mauke> Krakarn: because type signatures are illegal in instance declarations
08:38:13 <applicative> Krakarn: are you declaring a Num instance for Maybe Integer?
08:38:48 <applicative> Krakarn: anyway, as mauke says, it already knows the signature, you need to write the implementaion
08:38:51 <Krakarn> well I'm declaring a Num instance for: Num a => Maybe a
08:39:00 <byorgey> @type fromInteger
08:39:03 <lambdabot> Num a => Integer -> a
08:39:05 <applicative> Num a => Num (Maybe a)
08:39:12 <applicative> you mean ^^^
08:39:29 <Krakarn> yes
08:39:43 <kingugo> applicative: even if you setup a channel and power lambdabot there and make someone and admin, it sitll says not enough previledges when "@msg" is used
08:39:47 <byorgey> Krakarn: also, the signature for fromInteger should be  Num a => Integer -> Maybe a,  not   Maybe Integer -> ...
08:39:51 <mauke> fromInteger = pure; (+) = liftA2 (+); negate = liftA negate; ...
08:39:52 <mauke> boring
08:40:01 <applicative> fromInteger x = Just x
08:40:18 <byorgey> no,  fromInteger x = Just (fromInteger x)
08:40:26 <applicative> bah
08:40:31 <byorgey> or  fromInteger = pure . fromInteger
08:40:31 <applicative> yes
08:40:41 <Krakarn> I was saying: fromInteger = fmap fromInteger
08:40:46 <applicative> does the 'applicative numbers' package do this in general?
08:40:52 <klrr__> elms' record syntax seems very neat :)
08:41:01 <byorgey> Krakarn: that has type   Num a => Maybe Integer -> Maybe a
08:41:10 <byorgey> Krakarn: but that is not the right type for fromInteger
08:41:13 <klrr__> is there any language extension that allows similar record syntax as Elm?
08:41:24 <Krakarn> right
08:42:07 <donri> klrr__: no extension but maybe package, such as HList or has
08:43:04 <Philonous> What's the difference between ByteString's and cereal's Builders ?
08:45:55 <klrr__> donri: okey
08:47:00 <Cale> Philonous: scroll up slightly for the comment http://hackage.haskell.org/packages/archive/cereal/0.3.5.2/doc/html/src/Data-Serialize-Builder.html#Builder
08:47:39 <c_wraith> cereal's builders appear to not do crazy unsafePerformIO stuff internally
08:47:42 <applicative> Cale: which comment
08:47:47 <c_wraith> unlike those in the bytestring-builder package
08:47:50 <applicative> yes it seems pure
08:48:05 <Cale> (Just the comment about the Builder datatype)
08:48:08 <applicative> the bytestring-builder package, you mean, the bytestring package
08:48:24 <applicative> they have the same purpose but are differnet
08:48:26 <c_wraith> oh, nevermind, it does do the unsafeperformIO stuff
08:50:17 <donri> and you should maybe use binary instead of cereal
08:50:39 <applicative> c_wraith: yes, i see, it's buried a little better than in http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/src/Data-ByteString-Builder-Internal.html
08:51:13 <applicative> thank God we have these egg heads figuring out libraries like that
08:51:18 <Philonous> donri:  Why is that?
08:51:29 <applicative> or whatever they are, demonic gnomes
08:51:49 <applicative> subterranean ninja library writers
08:51:56 <Philonous> applicative:  Demi-Simons
08:52:01 <donri> Philonous: it's a core package, and does most things cereal does these days, and likely faster (and plans to make it even faster)
08:52:06 <applicative> Philonous: yes
08:52:15 <applicative> i could do with an army of Demi-Simons
08:57:08 <Philonous> Btw. what's the point of the Put monad? It seems to be a writer, so (>>) would just be a strange way of writing append.
08:58:45 <donri> Philonous: there is no point other than "omg do notation"
09:01:50 <Format> magneticduck : can you remind me pliz the module to create data like test = [(+), (<)]. Thanks
09:03:30 <haasn> oh great, elm-lang doesn't even display anything with js disabled
09:03:47 <haasn> I wonder who thought that was a good idea
09:03:52 <c_wraith> :t [(+), (<)]
09:03:52 <lambdabot>     No instance for (Num Bool) arising from a use of `+'
09:03:52 <lambdabot>     Possible fix: add an instance declaration for (Num Bool)
09:03:52 <lambdabot>     In the expression: (+)
09:04:20 <c_wraith> Hmm.  Sometimes ghci says something like (Num Bool) => Bool -> Bool -> Bool  for that
09:04:26 <donri> haasn: the site is written in elm. elm compiles to js.
09:04:45 <FreeFull> For me ghci errors
09:04:57 <FreeFull> Anyway,  (Num Bool) =>  doesn't make sense
09:05:04 <haasn> why not?
09:05:29 <FreeFull> If you make an instance for  Num Bool, you get   [(+), (<)] :: [Bool -> Bool -> Bool]
09:05:35 <c_wraith> Oh, hmm.  So maybe it only does that when there's a free variable in the type.
09:05:58 <c_wraith> That would make sense
09:06:08 <c_wraith> If there aren't free variables, it just checks for the existence of the instance
09:06:42 <haasn> hmm. If you add a type signature manually (with the appropriate context), it still errors when using :t
09:07:03 <haasn> however I can do ‘let x = [(+), (<)]; x :: Num Bool => [Bool -> Bool -> Bool]’
09:07:08 <haasn> and then :t x errors
09:09:38 <FreeFull> "Non type-variable argument in the constraint: Num Bool  (Use -XFlexibleContexts to permit this)"
09:10:34 <FreeFull> haasn: I can't define x in the first place without an instance for Num Bool
09:10:53 <ksf__> FlexibleContexts is a perfectly fine extension, just enable it.
09:11:10 <ksf__> but a Num Bool => constraint isn't going to help you.
09:11:12 <c_wraith> Hmm.  The example I usually run into didn't work out in ghc 7.6
09:11:25 <ksf__> what you'd want is instance Num Bool where ...
09:11:37 <ksf__> (which seems questionable)
09:11:40 <c_wraith> Because ghc 7.6 has finally made the ((->) a) instance for Monad available without any imports
09:12:22 <c_wraith> there we go..
09:12:24 <FreeFull> So you can join your functions
09:12:30 <FreeFull> :t join join
09:12:31 <lambdabot>     Occurs check: cannot construct the infinite type:
09:12:31 <lambdabot>       m0 = (->) (m0 (m0 a0))
09:12:31 <lambdabot>     Expected type: m0 (m0 a0) -> m0 (m0 a0) -> a0
09:12:35 <FreeFull> :t join join join
09:12:36 <lambdabot>     Occurs check: cannot construct the infinite type:
09:12:36 <lambdabot>       m0 = (->) (m0 (m0 a0))
09:12:36 <lambdabot>     Expected type: (m0 (m0 a0) -> m0 a0) -> (m0 (m0 a0) -> m0 a0) -> a0
09:12:38 <c_wraith> just had to go to ghc 7.4
09:12:41 <c_wraith> Prelude> :t (+1) >>= (*)
09:12:41 <c_wraith> (+1) >>= (*) :: (Monad ((->) b), Num b) => b -> b
09:12:55 <c_wraith> The difference appears to be that there's still a type variable
09:13:08 <joelteon> > (+1) >>= (*) $ 4
09:13:09 <lambdabot>   20
09:16:11 <FreeFull> :t ask
09:16:12 <lambdabot> MonadReader r m => m r
09:21:11 <klrr__> is there any function that converts an Int into a Double?
09:21:17 <klrr__> or is this "unsafe"?
09:21:32 <donri> :t fromIntegral :: Int -> Double
09:21:32 <lambdabot> Int -> Double
09:21:42 <klrr__> oh thanks! :D
09:22:23 <FreeFull> :t round
09:22:24 <lambdabot> (Integral b, RealFrac a) => a -> b
09:22:28 <tulcod> klrr__: a range of integers can be losslessly saved in a floating point type
09:22:34 <FreeFull> :t round :: Double -> Int
09:22:34 <lambdabot> Double -> Int
09:23:21 <mauke> > round (1/0) :: Int
09:23:21 <lambdabot>   0
09:23:24 <mauke> > round (0/0) :: Int
09:23:25 <lambdabot>   0
09:23:33 * haasn cringes
09:24:11 <mauke> > toRational (1/0)
09:24:12 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
09:24:15 <mauke> > toRational (0/0)
09:24:16 <lambdabot>   (-2696539702293473861593957786183537100426965468413459859101451217365990137...
09:24:19 <tulcod> klrr__: i think it's about 10,000,000 max for single-precision floats. i remember lua making use of this by not actually having an int type, and saving things like array indices in doubles
09:24:51 <tikhon> JavaScript also does that, and it certainly makes life more exciting
09:25:05 <mauke> ಠ_ಠ
09:25:43 <mauke> > map properFraction [1/0, 0/0]
09:25:44 <lambdabot>   [(1797693134862315907729305190789024733617976978942306572734300811577326758...
09:26:42 <Philonous> tikhon:  Well, it's not a problem. You can just represent ints as arrays of strings, each string representing a decimal place ;)
09:26:47 <tulcod> @t (1/0)
09:26:47 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
09:26:53 <tulcod> :t (1/0)
09:26:53 <lambdabot> Fractional a => a
09:28:11 <tulcod> Philonous: it's not a problem anyway. you can save integers in the range [-10^16,10^16] as doubles exactly
09:28:28 <tulcod> so as long as you don't start dealing with pointers in javascript it's probably fine
09:30:31 <tulcod> actually, you can do pointer stuff in javascript on a 32 bit machine
09:41:59 * levi reads the recent paper on generalized stream fusion.
09:59:05 <tulcod> if i have something resembling OOP, what are common naming conventions for the functions acting on the object?
09:59:32 <tulcod> e.g., i have an object named Keymap, and a function which updates the keymap, would that be updateKeymap or keymapUpdate?
09:59:49 <Gracenotes> in what way is Keymap an object?
09:59:54 <tulcod> or just update, and put it in a module?
10:00:30 <tulcod> Gracenotes: ugh, bad example. my actual object's type is called KeymapState
10:00:44 <tulcod> since you can press caps lock, and then if you press a, you get an A instead of an a
10:00:45 <Gracenotes> if you're going for the module approach, there are a lot of names here http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Lazy.html
10:01:29 <nadirs> to me "updateKeymap" means "give me an updated keymap", while "keymapUpdate" gives me "some sort of update, generated by the keymap" (not necessarily the keymap itself)
10:01:44 <Gracenotes> note also the order in which the functions take arguments, and what the argument types tell you about what the function does. It's almost like a map-manipulating domain specific language.
10:02:04 <tulcod> nadirs: you don't get to inspect the modified KeymapState since this is an FFI
10:02:13 <tulcod> you can only inspect it using methods
10:02:22 <CaptainK> where can I buy my Haskell Watch?
10:03:37 <tulcod> nadirs, Gracenotes: thanks, i'll keep your suggestions in mind
10:03:55 <Gracenotes> tulcod: one convention used is that the most important parameter goes first, so probably this object would go first
10:04:35 <tulcod> Gracenotes: some functions have four parameters, is that acceptable?
10:04:58 <Gracenotes> I'm not sure if there's anything set in stone for when to use updateKeymap and when to use Keymap.update, but think about how it will be used, I suppose
10:05:14 <tulcod> that's a good suggestions, thanks
10:05:53 <Gracenotes> tulcod: yeah, four parameters is fine if it's what the underlying API has, although are you sure you're not forgetting any? :)
10:06:53 <Gracenotes> (one can also make other helper functions which call the more complex functions with sane defaults. Data.Map also has plenty of this.)
10:08:36 <tulcod> Gracenotes: hm yes, i'll have to think about that a bit
10:10:16 <haasn> I would personally have the ‘object’ or ‘target’ of a function last
10:10:51 <haasn> so you can write something like do { obj & someFun 1 2 3; obj2 & somethingElse a b c }
10:11:23 <haasn> in general, I try to order my arguments in the way that will go most naturally with ($), (&) or partial application
10:22:14 <yitz> CaptainK: read the type signatures in the time library and you'll learn how to generate one.
10:23:27 <CaptainK> ok, very nice...just ran into elm frp, timepiece in 10 lines of code...crazy
10:23:43 <applicative> levi: do you know if there an available version of the vector library that fits with the paper
10:24:12 <yitz> CaptainK: haha
10:24:23 <conal> CaptainK: and almost all of that succinctness was about functional images rather than frp.
10:25:36 <yitz> conal: right :)
10:25:58 <luite> CaptainK: you might be interested in the diagrams library for haskell
10:28:15 <applicative> conal, have you formed a view about elm's approach?
10:28:38 <conal> applicative: afaict, it misses both of my basic frp criteria
10:28:50 * applicative :(
10:29:23 <tikhon> What are the criteria? Continuous time?
10:29:25 <applicative> where do we find these criteria
10:29:59 <conal> http://stackoverflow.com/questions/5875929/specification-for-a-functional-reactive-programming-language?rq=1
10:30:07 <applicative> ah
10:30:19 <conal> and follow pointers from there
10:30:37 <tikhon> ah, makes sense
10:30:38 <yesthisisuser> haskell.org is down? :(
10:30:56 * hackagebot unm-hip 0.2.1.5 - A Library for the manipulation of images  http://hackage.haskell.org/package/unm-hip-0.2.1.5 (JosephCollard)
10:31:39 <tikhon> do you know of any libraries that can run in the browser and meet your criteria?
10:32:00 <applicative> I suppose 'continuous time' is subject to diverse interpretations
10:32:33 <tikhon> I think this post should help with continuous time: http://conal.net/blog/posts/why-program-with-continuous-time
10:32:45 <bcoca> yesthisisuser: yep, down for me also
10:33:38 <mkscrg> is there a common lib that provides (&) ?
10:33:45 <tikhon> lens
10:34:23 <applicative> mkscrg: it's lens, attempts to get it in base have failed so far
10:34:34 <Zenol> Hum, are they a better way than writing mapM_ f =<< d, with d :: m [String] and f :: String -> m () ?
10:34:38 <conal> applicative: the semantic model makes 'continuous time' precise.
10:34:43 <m4b> using emacs-haskell-mode; is not loading anymore with .emacs (load
10:34:43 <m4b>       "haskell-site-file"); if I manually M-x load-library, I get "symbol's
10:34:43 <m4b>       value as variable is void: haskell-font-lock-keywords" after M-x
10:34:46 <m4b>       haskell-mode; i've reinstalled, no effect.
10:34:53 <m4b> sorry
10:35:15 <mkscrg> tikhon applicative: got it, thanks
10:35:16 <elliott> conal: hm your blog seems down
10:35:17 * Gracenotes is iffy on lens-in-base
10:35:27 <conal> elliott: oops. thanks!
10:35:31 <tikhon> I think it was just (&) in base, not all of lens
10:35:32 <elliott> :)
10:35:41 <applicative> conal: yes, I thought 'pre-pixelated time' is what's to be avoided
10:36:32 <applicative> or something like that.
10:36:45 <conal> discrete time and space both make for awkward, complex semantics and thus thwart clean (simple, useful, rigorous) composability
10:37:01 <applicative> of course yes
10:37:18 <conal> elliott: hm. http://conal.net/blog/ looks up for me.
10:37:47 <tac> conal: I'm getting a long long loadtime
10:37:55 <elliott> same as tac
10:37:59 <elliott> perhaps it will eventuallyl oad
10:38:10 <conal> sigh. i don't know what's making it slow. server or software.
10:38:17 <applicative> it took a bit, but then loaded, maybe something goes off in your impatient browser
10:38:20 <elliott> or not: Oops! Google Chrome could not connect to conal.net
10:39:06 <Gracenotes> there is always the design tack of saying 'given this example of a good end behavior, what is the most generalizable way of expressing it at a higher level?'
10:39:13 <applicative>  #haskell DOS attack on conals server!!
10:39:47 <Philonous> m4b:  I have (require 'haskell-mode-autoloads) in my init.el
10:39:49 <Gracenotes> although, this often makes small examples that work great and large examples that work, but not great.
10:40:43 <Gracenotes> or I'm really bad at generalizing -.-
10:42:58 <hvr> m4b: you might want to re-read the current README.md file on GitHub
10:43:38 <hvr> m4b: 'haskell-site-file' has become obsolete w/ newer haskell-mode versions
10:45:28 <Saizan> m4b: (load "haskell-mode-autoloads")
10:46:42 <joelteon> has anybody tried to run a ghc-mod "server"? like with hdevtools?
10:47:03 <c_wraith> joelteon: isn't that what scion is?
10:49:07 <joelteon> oh, possibly
10:49:21 <joelteon> ok, I might mess around with it later, it looks pretty old though
10:49:41 <c_wraith> It's still used by things like eclipsefp
10:49:46 <c_wraith> which is in active development
10:49:58 <joelteon> ok, cool
10:53:34 <joelteon> it doesn't work with GHC 7.6, though
10:53:37 <joelteon> I might just write one of my own
10:56:23 <hvr> joelteon: https://bitbucket.org/nominolo/scionide/overview#followers
10:56:43 <tikhon> heh, scionide is an amusing name
10:56:48 <hvr> joelteon: scionide is a 'reboot' of scion
10:57:23 <hvr> nominolo: ...you are still motivated to finish scionide, right? :)
10:58:21 <m4b> thanks to everyone who answered, (load "haskell-mode-autoloads") solved the problem; was looking in haskell-mode.el for loading hints, should have checked the github site; thanks a lot, everything is purdy again!
11:01:34 <joelteon> hvr: might just be me, but I can't build it
11:01:46 <joelteon> nominolo: where should I get scion-binary? it's not on hackage but make fails because cabal can't find it
11:11:05 <Zenol> There isn't any concatMapM ?
11:12:52 <Zenol> Something (a -> m [b]) -> [a] -> m [b]
11:13:01 <tikhon> wouldn't that just be something like
11:13:02 <byorgey> not in the standard libraries, no
11:13:13 <byorgey> @type \f -> liftM concat . mapM f
11:13:14 <lambdabot> Monad m => (a1 -> m [a]) -> [a1] -> m [a]
11:13:14 <tikhon> :t (liftM concat .) . mapM
11:13:14 <lambdabot> Monad m => (a1 -> m [a]) -> [a1] -> m [a]
11:13:41 <bscarlet> :t \f -> concat <$> mapM f
11:13:42 <lambdabot> (a -> [b]) -> [a] -> [b]
11:14:13 <Zenol> oh, liftM concat . mapM so U.U
11:14:46 <bscarlet> pthea
11:15:57 <Zenol> thank you :)
11:17:04 <glosoli> Where are the preferred tools for using Haskell ?
11:17:37 <bscarlet> glosoli: Preferred by whom for what?
11:17:55 <applicative> glosoli: you mean what editor?
11:18:08 <glosoli> Yeah, I am starting to read some book on haskell, and I am searching for some tool
11:18:22 <tikhon> are you familiar with any text editors?
11:18:36 <glosoli> Yes, VIM, Sublime Text, TextMate mostly
11:18:40 <bscarlet> glosoli: I use emacs. Many use vim.
11:18:49 <jfischoff> glosoli: I use TextMate
11:18:54 <applicative> glosoli: any of those is good; they all have some sort of haskell support
11:19:01 <dmj> glosoli: emacs has haskell-mode
11:19:11 <glosoli> nah Emacs is for smarter people than me, that's for sure
11:19:17 <tikhon> Emacs and Vim can have some pretty fancy IDE-like functionality with a bit of effort
11:19:27 <jfischoff> glosoli:http://stackoverflow.com/a/4547695
11:19:32 <tikhon> there is also a dedicated Haskell IDE called leksah
11:19:39 <tikhon> but it... isn't the best
11:20:00 <jfischoff> I like using ghci and textmate
11:20:27 <tikhon> if you're *really* into IDEs, you could use EclipseFP
11:20:28 <applicative> and the maybe slightly out of date http://stackoverflow.com/questions/5682339/setting-up-textmate-for-haskell-programming-on-mac-os-x?rq=1
11:20:30 <burkaman> is leksah still under development?
11:20:34 <tikhon> but I personally wouldn't recommend it
11:20:36 <tikhon> umm
11:20:51 <tikhon> I think I saw something about it on the mailing list recently
11:20:56 <joelteon> has anybody gotten scionide working successfully?
11:21:03 <tikhon> so it's probably not entirely abandoned
11:21:04 <applicative> scionide!!
11:21:05 <dmj> glosoli: emacs is not for *smarter* people. I'm using it.
11:21:24 <joelteon> I can `make' it, but then the binaries don't go anywhere
11:21:30 <tikhon> Emacs itself, of course, really is smarter than most people :P
11:21:44 <applicative> oh come on.
11:21:52 <glosoli> dmj: I have tried to fight against it for several times, failed hard ;/
11:22:10 <glosoli> Ok Eclipse is out, as I don't like Eclipse as a  whole , might try TextMate, or some VIM Mode
11:22:18 <joelteon> also, scionide doesn't have a readme or anything included, so that's kind of irritating
11:22:23 <dmj> glosoli: Did you make it through the emacs tutorial?
11:22:41 <applicative> what is the best vim support material for haskell?
11:23:23 <dmj> applicative: vim2hs?
11:23:23 <Gracenotes> people say good things about vim2hs
11:23:23 <dmj> https://github.com/dag/vim2hs
11:23:23 <glosoli> dmj: Nah, I have hard time making my self to think like a tool, I prefer when the tool is already how I think, sounds stupid probably, it just did not fit me
11:23:23 <tikhon> you could consider evil mode for Emacs which provides very credible Vim emulation
11:23:24 <paintcan> glosoli: emacs 24 includes a package manager. that plus getting ido, iswitchb and smex setup has changed emacs from something i barely understand to something i can't do without
11:23:25 <burkaman> applicative: there's some good recommendations here http://www.reddit.com/r/haskell/comments/xxxyi/is_there_a_standard_haskell_development_setup_for/
11:23:48 <burkaman> I don't think there's one widely used standard, but any of those answers will work nicely
11:24:08 <applicative> ah yeah that looks pretty informative burkaman
11:26:01 <dmj> glosoli: Yes, the same could be said of haskell as well. It won't do what you expect at first. I would recommend sublime as well. Ghci support is a must.
11:26:22 <glosoli> hmm
11:27:05 <applicative> hey, i even have *cabal sandbox* support in my textmate ...
11:27:26 <c_wraith> Hmm.  Is there a way to get bindings-dsl to handle multidimensional arrays as fields of a struct?
11:27:26 <applicative> i cant think of an emoticon appropriate to ironized smugness
11:27:52 <c_wraith> Or should I be looking at something more advanced than hsc for this?
11:28:01 <dmj> haskell.org?
11:28:13 <tikhon> What cabal sandbox? cabal-dev?
11:28:34 <applicative> tikhon: in the development version of cabal-install
11:28:40 <tikhon> oh
11:28:42 <tikhon> I haven't seen that yet
11:28:45 <glosoli> ok thanks  all for answer, gonna investigate of what would be easiest to setup for a first time :)
11:28:48 <tikhon> is it worth using?
11:28:52 <applicative> tikhon: i installed for the heck of it, and now cant live without it
11:29:04 <tikhon> is it that much better than cabal-dev?
11:29:21 <applicative> on that question , I can't speak, since I never used cabal dev
11:29:27 <applicative> I think it's pretty similar
11:29:28 <tikhon> oh
11:29:30 <tikhon> okay
11:29:36 <tikhon> but better-integrated, I imagine
11:29:50 <tikhon> for now, cabal-dev suffices, but I'll probably switch sooner or later
11:29:57 <applicative> thats what i was thinking, but I really have no reason to 'prefer' it
11:30:07 <dmj> glosoli: if you are at all interested. I found this emacs tutorial video to be very accesible: https://peepcode.com/products/meet-emacs. I get no proceeds from recommending it
11:30:09 <shoret> tikhon: http://blog.johantibell.com/2012/08/you-can-soon-play-in-cabal-sandbox.html
11:30:21 <applicative> oh i never saw that shoret
11:31:03 <klrr__> ?src (,)
11:31:04 <lambdabot> Source not found. Where did you learn to type?
11:31:07 <klrr__> it's a primitive?
11:31:14 <applicative> anyway, tikhon i think if you're using cabal dev there's no rush converting for sure
11:31:15 <tikhon> it's built-int syntax, yes
11:31:28 <klrr__> tikhon: but it works like a funciton?
11:31:32 <tikhon> yep
11:31:37 <applicative> i wasn't using anything, just my local ~./cabal
11:31:46 <tikhon> applicative: oh, I see
11:31:55 <jfischoff> klrr__: TupleSections
11:31:56 <dmj> shoret: how does that compare to hsenv?
11:32:51 <shoret> dmj: i dunno -- i actually use hsenv too
11:33:50 <dmj> shoret: yea i don't get cabal-dev. It'd be nice to see a tutorial on it tho.
11:33:55 <applicative> my impression is that hsenv is more powerful than any of these things
11:34:05 <shoret> there are comparisons to other tools (hsenv, cabal-dev, etc) here: http://hackage.haskell.org/trac/hackage/wiki/PackageEnvironments
11:34:12 <glosoli> dmj: thanks.. :)
11:34:17 <tikhon> hsenv sounds pretty cool
11:34:29 <applicative> if cabal sandbox is perfected people will still want something like hsenv
11:34:35 <byorgey> hsenv is nice. I use it all the time.
11:34:39 <shoret> hsenv is nicer than cabal-dev in my experience
11:35:14 <jfischoff> cabal sandbox will management inter-project dependencies
11:35:17 <applicative> i found it really disturbing, but I think it's because it requires a more advance conception of what I'm doing typing in a terminal than I am inclined to attain
11:35:29 <applicative> advanced conception rather
11:35:35 <tikhon> jfischoff: what do you mean?
11:35:36 <dmj> glosoli: np, I know the feeling... taking the plunge :) leaving the comforts of VS2010.. there's gold on the bottom of the ocean, few go down there though.
11:35:45 <Zenol> Hum, are they a good lib (which compile with ghc 7.7) that allow encoding utf8 strings into url (to ++ on "google.com/search?q=") ?
11:36:07 <tikhon> I actually found the terminal easier to understand than an IDE (mostly Eclipse for me)
11:36:09 <tikhon> much less magic
11:36:13 * hackagebot unm-hip 0.3.1.5 - A Library for the manipulation of images  http://hackage.haskell.org/package/unm-hip-0.3.1.5 (JosephCollard)
11:36:13 <levi> applicative: The tech talk associated with the Generalized Stream Fusion paper noted that the code was available on github somewhere; I'm sorry I don't have an exact URL right now.
11:36:22 <tikhon> in Eclipse I'd just hit the big green button and hope for the best
11:37:12 <hvr> tikhon: maybe they should have made it a big red button then?
11:37:23 <glosoli> dmj: Nah  I never did VS ... just for educational purposes, have basics of Java though, kinda lazy student  of CS, always been demotivated by all the Java, C# and other stuff.. Python was some sort of interesting to me, until recently found about Haskell and Clojure :) Might be easier for me because I don't have proper OOP background, I hadn't had that feeling of "this doesn't look right" for a second :)
11:37:41 <jfischoff> tikhon: if you have a cabal project A and it depends on project B, if B changes and you build A, B will get rebuilt. Assuming you added it to the sandbox as source package
11:38:03 <applicative> levi: I had noticed https://github.com/rleshchinskiy/vector/tree/master/Data/Vector which is different from whats on hackage in some ways like the paper, but wasnt what they were talking about in the paper
11:38:10 <jfischoff> which is the really useful thing about it
11:38:40 <applicative> levi: I don't know why I linked that particular subdirectory
11:39:13 <jfischoff> tikhon: or at least I think that is the idea :p
11:40:28 <danharaj> Is there a way to Show a GHC.Generics Rep of a type?
11:40:36 <dmj> glosoli: cool. keep it fun, that's key. Also, for haskell. Do the typeclassopedia. haskell.org is down, but here's a pdf. http://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf. Tis the true path of enlightenment.
11:40:38 <jfischoff> !kind I think
11:41:09 <byorgey> the PDF version is out of date, but 'twill have to serve until haskell.org returns
11:41:26 <byorgey> jfischoff: perhaps you mean  :kind!
11:41:31 <jfischoff> :)
11:41:37 <jfischoff> yeah I just realized that
11:41:52 <danharaj> Is there a way to do that at runtime? :P
11:42:12 <zinfandel> :q
11:42:42 <glosoli> dmj: so you would recommend to start at that ?
11:42:58 <jfischoff> deriving instance Show (:+:), etc. maybe?
11:43:12 <danharaj> jfischoff: makes me wonder why that isn't already implemented though
11:43:53 <jfischoff> danharaj: I've stopped asking that question about the Haskell ecosystem ;)
11:44:16 <jfischoff> maybe I should ...
11:44:55 <jfischoff> So all of sudden I can't seem to get ghci -package-db=blah to work
11:45:27 <jfischoff> no errors, just can't find my packages, I can see them in database and the libraries are in the right spot, any ideas?
11:48:52 <dmj> glosoli: I would. Highest signal-to-noise ratio. Read all the articles as well. Maybe accompany is with LYAH every now and again. If you really want to get serious, reimplement the prelude, data.list and control.monad. Straight from the source. Put out the type signatures plainly and try to solve the implementation, even if it takes days. Haskell is dense. Read all the haskell wiki articles too, and follow reddit. Don't be afraid to ask
11:48:52 <dmj> dumb questions. Read the IRC logs to see all my dumb questions if in doubt.
11:50:17 <glosoli> Damn this community is amazing, thanks! :)
11:51:04 <dmj> glosoli: constant recall of the types is good. I have a lot of emacs snippets to recall what specific types are. This is why a good editor is important. Like typing $ and TAB. While generate ($) :: (a -> b) -> a -> b; f $ x = f x
11:51:17 <dmj> xb
11:51:38 <glosoli> ok, I will be changing the scenario then
11:51:54 <glosoli> Going for that Emacs link
11:54:36 <dmj> glosoli: That video will explain emacs24 package management (include melpa), which will let you install haskell-mode (M-x package-install haskell-mode). You'll also want to setup yasnippets. Then once you learn a function, add it to your snippets collection :) what I do.
12:00:48 <glosoli> dmj: Ok thanks again, just got the Peepcode order, will start  going through it
12:01:01 <applicative> hm, om nom readFile writeFile "a.txt" makes a file named in a.txt, and writes "a.txt" to it. Incredibly useful, these cookie combinators...
12:01:28 <applicative> that is, if a.txt reads "b.txt"
13:45:28 --- topic: 'http://www.haskell.org | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com'
13:45:28 --- topic: set by mauke!~mauke@p3m/member/mauke on [Wed Jul 17 04:52:43 2013]
13:45:28 --- names: list (clog srh Nahra applicative Neqoxec yyyyy Baughn p_l tommd jfischoff gabor elediaz Dakki WraithM aqil [swift] amathew niklasb jmcarthur_mobile dwcook sclv_ dialelo xcthulhu primitive mellum Kiryx mkscrg Finnfinn mjo SBauer gautamc gdeest Franciman osa1 sellout BobFunk aztek oleo Eduard_Munteanu wolfnn stepkut mizu_no_oto lattenwald iammisc ozataman solrize_ _justjust benprew lcfrs Shin-LaC Okasu c-rog chuzz mceier linduxed resnik Twey kstuart Jayrays Pegleg)
13:45:28 --- names: list (theWinner p\mage mikecaruso zrot manung emmanuelux canar tortrot nooodl_ QinGW`` noplamodo thorkilnaur__ dropdrive nik_89 kaictl kallisti averell ciaranm machisuji nxorg8 BrianHV augur mmathis milessabin_ thirsteh_ mimi_vx_ mlinksva Tesseraction shintah weie_ normanrichards junsuijin NemesisD perspectival roboguy_ mephx gambogi merijn kxra ntus1017_ gmaggior yogert SLi Krakarn-- Shou phischu matheus23 Endy S11001001 bananagram levi Taneb cablehea_ wole zacts)
13:45:28 --- names: list (venice hiptobecubic Earnestly HugoDaniel DoomBoom mirari_ kingugo nadirvar_ raichoo pantsman Bryan792 glosoli ksf path[l] rahul_ redjohn nan` hiroakip shergill Guest35545 ozgura alanz plucas jdoliner ulfdoz leifw jvrmaia Sonderblade yesthisisuser quchen dan_johnsin transfinite SaBer litherum skeet70 tuxit predator117 Jeanne-Kamikaze Noldorin enthropy JaRoel|4d melter Velpoman mrsolo azm neektza1 c_wraith mithsv Apocalisp joehillen gustavn josephle sferry)
13:45:28 --- names: list (pygospa phyrex1an whaletechno latro`a akurei_ trism BitPuffin Mon_Ouie pettter luksow threesome mww tikhon tiffany resttime monochrom dubsg skaczor agumonkey nexx zerokarmaleft SoupEvil bennofs tac burkaman paolino gnuvince hajimeho_ Philonous brianloveswords thunderrd myme1 Icewing nimish cfricke thalassarche paintcan pmade diabel232 tanakh janinge oscar_f paddymahoney EvilPenguin yam _vy roconnor bytbox jssanders torkjak bgilbert shreesh TheFuzzball)
13:45:28 --- names: list (theorbtwo alszar dEPy xilo DexterLB dreixel_ otto_s phienone dgpratt urm3l danharaj Luke eacameron uniquenick dabradley saml klrr__ fridim_ erochester volitek RageOfThou arborist lambdanaut mgile __jay Entroacceptor destiny shesek walter kofno cscorp Trenif ggreg Wizek_ otterdam yacks Jonte c_14 ocharles magneticduck guampa Format Zenol epta bitonic ivan` jlamothe k00mi drdo q66 Rarrikins [[zzz]] copumpkin ysuzuki neurocyte delian66 dschoepe xinming kerrick)
13:45:28 --- names: list (kludge` totos__ tomboy64 klrr donri ccxCZ Reite DolphR aford aess crs_ marr refold morazow t7 spektroskop1 doomlord mikee vehk PHO_ EarlGray^^ saiam duikboot wollw sShintah DrCode iauns hamilyon Sculptor wtw albel727 bogdanp Natch isenmann goldkatze nanothief elgot cschneid BMeph purefn Endeg sclv philipdexter setmeaway2 biscarch shanse troydm Resure dcguru dolio ormaaj hiratara mechairoi RichyB apaku Valodim Modius andares tpsinnem awruef mstksg upgrayeddd)
13:45:28 --- names: list (steshaw akraut ehd tomh- jodaro_ chickenflu bentrevor shennyg bicgena brainwash mawuli nullcone_ Mortomes_ SegFaultAX akahn hackagebot Philippa tsou xrl araujo bscarlet ParahSail1n lunarjar parcs WhereIsMySpoon Tinned_Tuna Svedrin boothead byorgey `bps zebr sepeth Masky Kabaka sec^nd liori pikhq_ FreeFull jobstijl Mowah u_ Cale gienah joaopizani mlh ktosiek mietek ismlages julmac studybot_ ahihi so lenstr stuntaneous asjo Nimatek isomorphic sevvie)
13:45:29 --- names: list (scottschecter preflex mauke kshannon ecube hamishmack brisbin dav vnz crdueck boris`` em xvilka Internet13 ceii h_chiro_ helgikrs goodmanio stiell alexander__b mel- DT` waterlaz cronject obcode chrisbuchholz_ Ycros perlite warpaint int-e f8l JuanDaugherty tg ivan\ tmiw ninegrid adnap burp OlegYch sm dakrone Tribal Ralith leroux ezrios Bynbo7 satshabad `0660 smlgs sleepybug dsfox flux tulcod Excureo Th0mas frontendloader kaw ReinH flowsnake joar bogner_ bogner)
13:45:29 --- names: list (tych0 scottj xymox Raynes Deewiant stepcut jrib tippenein Mayzie noam_ dustinswan zxq9 Kuba s00pcan noddy plhk dmwit floatingman2 saiam^ Phlogistique petermw yano novascorpio solancile Amadiro kav knyppeldynan jlaire Vorpal zugz jmcarthur Darkflux MrRacoon nuttycom1 vw21 joshc bcoca ido nkpart felipe_ cmsd2 ninzine phryk Xorlev Khisanth gemelen Hardolaf peltchu mgsloan akiress_ MasseR wting Guest10475 ssbr` gbluma_ Jimi` Laney mixi thetallguy2 Elision)
13:45:29 --- names: list (mapreduce tero- schlumpi theDon zaphar_p1 kqr1 Gothmog_ kranius_ cow-orke1 b2coutts k0ral pcapriotti johanbev_ deggisv2 Fuco wto javawizard slobo_ SHODAN s4msung morolin bstrie ps-auxw qwandor M-ou-se sordina1 mee hiyakashi banjiewen chirpsalot hape01 JustAPerson mux Heffalump a11235 kloeri xplat ahf Eridius Sunhay bd_ BlastHardcheese geoffh xnyhps sirspazzolot jlewis duairc JPohlmann integral jaimef Brando753 tvaalen Cryovat canta ousado tomprince idoru)
13:45:29 --- names: list (uu1101 tdammers brendan pingveno Adios_ gpampara_off rce bbee koala_man nu11ptr folone bduc n-dolio brandonw brainproxy othiym23 davorak_ aleator_ mantovani suiside udoprog drmegahertz agundry zomg Plex- ent drewr zenzike_ arnsholt Tehnix dixie_ saurik luite Saizan lispy hvr ofan mviljamaa sbahra[] eL_Bart0 Maior thorsten1 rgrinberg demolithion @Igloo jlouis tahu fayden MetaCosm shiona wchun ernst mollerstrand statusfa1led Boreeas ehamberg mami_ tswett)
13:45:29 --- names: list (bholst_ colah_ Yawgmoth_ ChongLi compnaion_cbue [edwtjo] Gracenotes Boney bind tensorpudding doshitan jbauman nitrodex maksbotan stevejb rfw Sourceless gspr shepheb lokydor ethercrow mirsal idnar flori skypers smarter Arnoldz ghorn_ de-Vri-es vobi Zariel Odd_Bloke Kyzza zz_nh2 maoe supki QinGW tomaw guymann liyang Maxdamantus wormphlegm osfameron edkk tavelram_ Ke joachifm bbloom vmeson mrpantoufle briden dwierenga dcoutts joelteon osnr ski_ hiredman)
13:45:29 --- names: list (canissimia jroesch cods Dtgr Ornedan schoppenhauer Raynos _br_ kakos lambdabot sajith mornfall CosmicRay djahandarie hive-mind Soft kaol jackhill threedaymonk quicksilver Enigmagic eyck_ ttm pqmodn_ malorie_ mgregson DigitalKiwi Saeppel dilinger_ td123_ Gilly_ Tekerson_ arkx iteratee_ thoughtpolice clampz YoungFrog Tarential ryanakca dsirenko mr- joneshf-laptop Razz ziman MoALTz farn thetallguy cheezey Licenser Nik05 froztbyte bezik aninhumer pr dju pjstadig)
13:45:29 --- names: list (xenophon zorzar `^_^v raid Edoxile sohum s_quark ClaudiusMaximus peddie hpaste KaneTW nikolah niko ghorn zw01 charlesofarrell_ greymalkin fall_ Nickeeh yan_ stass bartavelle Blkt aformeny Hafydd fxrh sgso anon1231 bgamari Paks args[0] knz ogew zero7 centrinia dsp_ swook` Watcher7 cdidd Fuuzetsu jyyou ejls tudalex tridactyla vpm Yaniel killy9999 MrWoohoo mak` xaimus macron luminous jaspervd1 carter nwf confound_ Zesler etrepum si14 mkrull xorox90_ scshunt hpc)
13:45:29 --- names: list (Eliel Tene dsantiago ft munro Martty palmje earthy anachron SirChurchill honza misv Ezku oldmanstan b_jonas johnw KitB jrslepak kosmikus DrSyzygy almondjelly copton jix popx Riussi_ lahwran adimit_away Fubar^ epsylon mononofu yiannis_1 zvrba pyykkis Liskni_si natte notdan zeiris_ ParahSailin horlicks Draggor lpsmith neena DustyDingo vili dyreshark mikeplus64 talzeus_ fry DarkFox bigs kooga warpy barrucadu marienz ELLIOTTCABLE ggherdov haasn guerrilla robbert)
13:45:29 --- names: list (majoh fergusnoble betawaffle alpounet gds Ptival mxf joeyh tunixman acfoltzer orospakr inarru ab9rf BigEndian geal cajla taylorgb ipuustin Walther electrogeek heath ccasin inr jayne rpenguin go|dfish Reisen bitraten davorb-cellphone drbean ibid Bwild Jaak lpvb lopex CindyLinz aszlig pdxleif zaiste def-lkb_ arcatan Spockz tromp_ cjay jamwt dmp1ce yeltzooo necroyeti willb1 arkeet lightquake Bigcheese kini ByronJohnson gseitz_ Dashkal tylergillies_ fihi09```)
13:45:29 --- names: list (mortberg wilfredh Chousuke davean bobry jang1 nlogax newsham mjrosenb Starfire_ Morgawr mrd_ Ulrar petekaz`` cynick davd tessier fryguybob edunham caligula__ petantik vvein zoktar Vendethiel b52 iulian __main__ petercoulton asante MK_FG dogmaT gbarboza dlundy AntiSpamMeta deavid elliott bergmark gereedy franksh poucet divarvel janne- XMunkki_ Draconx matzo Will| bqp fikusz ericmj pharaun Vq seantallen birkenfeld cruxeternus sp3ctum_ Clint mendez_ Dybber)
13:45:29 --- names: list (mgaare mokus magicman anders^^_ isomorphismes geekosaur wagle sipa bcoppens sg NeatBasis_ pnielsen Kinnison n00dle rhodesd tamiko milli dextrey mmaruseacph2 tomejaguar OrangeDuck Squid_Tamer wavewave @ChanServ dumbhat LeaChim vvv fabjan _flow_ chrra aristid mattp__ lulf Proteumus Counter-Strike relrod brixen Athas robinbb valdyn Rembane machisuj- pfoetchen andrewsw dpwright bz FUZxxl ski prophile sunfun sunnavy_ finnrobi pi8029 xrq FireFly away_sondr3 TML ve)
13:45:29 --- names: list (hpd genisage wereHamster gridaphobe mrshoe klugez Adeon arbn ion dario^CIP adlan joogi ortmage dqd shutdown_-h_now seneca Cerise ljhms_ solirc Khady Rutger`_ cross danr pyrtsa jliikka solarus blakesmith taruti nicoo Jello_Raptor McManiaC jkpl liszt profmakx petanqk Belgarion0 opqdonut stomp SuperNoeMan bxc rs0 Kneiva_ TheSpectre koninkje_away Sagi wunki puzza007 qz kryft sdx23 mike2 \q jml)
13:49:32 <FreeFull> :t ""
13:49:33 <lambdabot> [Char]
13:58:11 <epta> What version of ghc should have this bug fixed? http://ghc.haskell.org/trac/ghc/ticket/7476
14:01:13 <merijn> epta: Looks like it's fixed in HEAD
14:05:31 <Saizan> probably the devel one 7.7 atm, and then 7.8
14:09:34 <yesthisisuser> i don't understand this concept of discharging an assumption in propositional logic. not really haskell related but ...
14:12:01 <Saizan> it's just wrapping your term with a free variable into a lambda, so now it's a bound variable and you get a proof of implication
14:13:07 <Saizan> (term with a free variable) is what gets wrapped, tbc
14:13:20 <opqdonut> yeah, the equivalent type inference rule is: x::t |- e::v ==> \x -> e :: t->v
14:13:55 <yesthisisuser> hmm
14:14:25 <applicative> suppose p. well, then p or q, surely. Thus, p -> p or q
14:14:33 <applicative> suppose p. well, then p or q, surely. Thus, p -> (p or q)
14:14:47 <Saizan> or, in less type-theoretic terms, if you can prove Q by assuming P, then you can prove P -> Q
14:15:30 <monochrom> could you say why you don't understand it?
14:15:59 <applicative> of course he understands it perfectly, its a question of linking jargon up with the obvious
14:16:05 <yesthisisuser> well, i can see how it follows
14:16:28 <yesthisisuser> let me see if i can "paste" the example from the book i'm reading
14:18:01 <yesthisisuser> hmm.. i can use TeX here. i wish i could just copy/paste in TeX from the book
14:18:19 <xico> hi
14:18:20 <yesthisisuser> to lpaste i mean
14:18:46 <monochrom> mathb.in can render TeX :)
14:19:02 <xico> does someone know how to extract a Ptr Cairo to pass a cairo_t* to a c function (that is interfacing gtk2hs’s cairo with other libs)?
14:19:52 <geekosaur> I would think Ptr Cairo *is* a cairo_t*?
14:20:14 <xico> indeed. i mean extract it from the Render monad
14:20:21 <geekosaur> (or at least that's what it is on the C side)
14:20:48 <k0ral> Could you please provide assistance for http://bpaste.net/show/118490/ ?
14:20:51 <yesthisisuser> here is the example: http://lpaste.net/91314
14:21:21 * hackagebot feed 0.3.9 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.9 (SigbjornFinne)
14:21:23 <xico> (which is a ReaderT Cairo IO m)
14:21:23 <monochrom> does Graphics.Rendering.Cairo.Internal have what you want? (I don't know, and hackage is not cooperating)
14:21:33 <xico> monochrom: not sure yet
14:21:35 <yesthisisuser> A B => A ^ B
14:21:51 <geekosaur> new-hackage is working...
14:22:00 <yesthisisuser> (A ^ B) ^ (A ^ B) => C  => C
14:22:05 <yesthisisuser> hmm
14:22:07 <monochrom> cairo_t* may be Cairo itself or Ptr Cairo. be careful with that.
14:22:08 <geekosaur> newtype Render m = Render { runRender :: ReaderT Cairo IO m }
14:22:44 <geekosaur> so ```ask``` should get you the Cairo
14:23:04 <geekosaur> (and come to think of it, that tyupe implies what monochrom just said, sigh)
14:23:59 <supki> k0ral: type variables in type signature and type annotations are unrelated
14:24:01 <xico> monochrom, geekosaur: thanks! :)
14:24:22 <supki> k0ral: you probably want -XScopedTypeVariables or something
14:24:40 <applicative> hm, SigbjornFinne just uploaded something he last uploaded in 2009
14:27:24 <k0ral> supki: I added type annotations to debug, the error arose without then as well
14:27:51 <supki> k0ral: yes, that code is ambiguous
14:28:11 <supki> you _can_ add enough annotations to compile it though
14:28:22 <k0ral> supki: scopedtypevariables doesn't help
14:28:40 <supki> it does, you need explicit foralls
14:28:47 <k0ral> supki: I fail to understand where's the ambiguity
14:29:07 <k0ral> where do these a0/b0 appear exactly ?
14:29:21 <k0ral> is that a consequence of using Lens ?
14:30:25 <applicative> yesthisisuser: oh did you figure that out? i just noticed the lpaste
14:30:29 <supki> it doesn't know which a and b to choose
14:30:34 <geekosaur> the a0 and b0 are not type variables appearing in any source; usually it means ghc renamed some a and b vairables that appeared but which it couldn't prove were the same type as something else already called a and b
14:30:41 <monochrom> yesthisisuser: I am not sure what the example wants to achieve (because I don't have the whole book). but I can guess. it wants to write a proof of: (above the line) A, A∧B⇒C, (below the line) B⇒C.
14:30:56 <supki> k0ral: it's a consequence of using multiparam type classes :)
14:31:00 <geekosaur> because you assumed that a and b would always mean the same thing, but in fact they don't scope
14:31:31 <applicative> yesthisisuser: its completely clear note that the hypothesis (A&B)->C is still undischarged
14:32:01 <applicative> yesthisisuser: as is A
14:32:39 <yesthisisuser> applicative: i think i get it now
14:32:43 <applicative> yesthisisuser: so this is a proof of B -> C on the hypotheses, one, that A, and two, that (A&B)->C
14:32:44 <monochrom> because the desired result B⇒C hinges on ⇒, we must use ⇒-intro, and do "assume B, prove C". this is marked by putting B in square brackets "[B]" and labeling it "1" for reference
14:33:26 * geekosaur sometimes thinks it would be helpful if ghc had the reverse of a shadowing warning: "oh hey, you called this type `a`, and you used another `a` somewhere else, but this `a` isn't that one". except, it would be very noisy in many common cases where you know that it *is* effectively the same (e.g. the common use of "m" for "arbitrary monad")
14:33:35 <yesthisisuser> first they say A B => A ^ B.. thats fine
14:33:42 <geekosaur> hm, effectively the same is not quite what I mean there. where it's irrelevant
14:33:50 <applicative> yesthisisuser: I 'discharged' A for you
14:33:58 <applicative> http://lpaste.net/91314
14:34:04 <k0ral> geekosaur: okay for the scope thing, but that doesn't tell me why, without any annotation, this code didn't compile
14:34:23 <geekosaur> I am not sure I can explain that
14:34:36 <monochrom> so combine A, [B] to get A∧B by ∧-intro. then, this is not shown in the paste but you must do it: combine A∧B, A∧B⇒C by ⇒-elim to get C.
14:34:41 <geekosaur> becuase scope *is* the problem. you see an a, you see another a, yoy think they're the same, ghc doesn't
14:34:43 <klrr__> this http://lpaste.net/91308 compiles and everything but unfourtenly the game is up-side-down , any idea what i did wrong? xD
14:34:46 <yesthisisuser> it's just like saying if B follows from assuming A .. then  A => B.. or?
14:34:58 <yesthisisuser> or if we can prove B by assuming A .. then
14:35:11 <k0ral> geekosaur: I have every reason to believe those a's are the same
14:35:22 <geekosaur> you mauy, but does ghc?
14:35:28 <applicative> yesthisisuser: now i discharged everything http://lpaste.net/91314
14:35:34 <applicative> @type uncurry
14:35:34 <lambdabot> (a -> b -> c) -> (a, b) -> c
14:35:39 <applicative> @type curry --rather
14:35:40 <lambdabot> ((a, b) -> c) -> a -> b -> c
14:35:46 <c_wraith> klrr__: you assumed you're working in quadrant I, but it's actually quadrant IV?  (or vice-versa...)
14:35:53 <k0ral> modify a id => a returns the same a_t, id returns the same a_t
14:36:24 <monochrom> yesthisisuser: no, it says neither.
14:36:28 <k0ral> a :: Lens' X a_t, id :: a_t -> a_t
14:36:40 <k0ral> I can't see any ambiguity here
14:37:25 <applicative> monochrom: what's wrong with what yesthisisuser said, or is there jargon incommensurability
14:38:10 <yesthisisuser> sorry. when i said A B i meant generally.. not referring to the example
14:38:19 <geekosaur> klrr__, I can't quite tell, but some common graphics environments (such as PostScript) are inverted compared to what you're used to; (0,0) is bottom left, not top left
14:38:28 <applicative> yesthisisuser: maybe if you said: one way to prove A => B is to prove B from A as a hypothesis
14:38:33 <monochrom> applicative, the two statements are true but not describing the pasted example.
14:38:41 <applicative> monochrom: oh i see
14:38:58 <geekosaur> (or maybe not what you're used to, and it's top left while you're expecting bottom left... can't tell)
14:39:44 <monochrom> the example lacks context.
14:40:25 <applicative> yesthisisuser: but you do this all the time, reason to something on an assumption A, but then having drawn some conclusion Z you scrap the assumption and affirm "if A then Z" absolutely
14:40:31 <monochrom> I made one guess at the context, but I would be happier if it were a totally wrong guess, to show how important it is to upload the complete book.
14:40:33 <applicative> that is, not on a hypothesis
14:41:20 <applicative> the example is totally clear, the defect of the symbolism was already present in Gentzen, that the discharge is a sort of temporal thing, so at first [B]1 was B
14:41:21 <yesthisisuser> i think this term "discharge" confused me
14:41:33 <applicative> yesthisisuser: yes it's just jargon
14:41:34 <klrr__> geekosaur: that might be the problem thanks
14:41:44 <yesthisisuser> thanks guys.
14:42:02 <geekosaur> a thing that comes up a lot with haskell: it's often much more clever than you are at figuring out ways that something might be (ab)used
14:42:37 <geekosaur> this is one of the reasons we don't like to recommend, say, making random Num instances; the compiler is well known to find unexpected ways to use it to force nonsense to typecheck
14:44:03 <applicative> yesthisisuser: if you look at http://lpaste.net/91314 you see that in the last one we have an argument for a conclusion with no hypotheses, its just proof of 'uncurry' so to say
14:44:23 <FreeFull> My favourite Num instance is ()
14:44:38 <applicative> mine is [()]
14:46:35 <bennofs> Mine is (Monoid m) => Num m
14:47:04 <monochrom> Void
14:47:30 <FreeFull> bennofs: Would   3 <> 4   be addition or multiplication?
14:47:40 <bennofs> addition I think
14:47:48 <monochrom> oh wait, I'll have problems with fromInteger :: Integer -> Void. nevermind.
14:48:20 <FreeFull> monochrom: Just make it bottom
14:48:34 <Sonarpulse> can anybody figure out why https://github.com/Ericson2314/hasnip/blob/master/src/HaSnip/ServerList.hs is getting a 400 bad request?
14:48:41 <Sonarpulse> I have no clue
14:48:59 <monochrom> I don't like to use bottom. it's too easy. :)
14:49:30 <_justjust> {[¬((p∧q)∨p), p]} why does it become {[¬(p∧q),p], [¬p,p]} when  you translate it into clause/conjunctive normal form?
14:52:02 <geekosaur> Sonarpulse, you might want to check what getBnS produces for that input. it looks iffy to me, unless something is bringing nonstandard Show instances into play
14:53:05 <covi> So in 'fmap :: (a -> b) -> f a -> f b', what's the name of the syntax for 'f a'? Why is there a space between them?
14:53:25 <covi> (I understand it means some a in f, but i want to know the formal rules)
14:53:31 <applicative> covi: I'm not sure much can be said there
14:53:34 <byorgey> covi: that is type application
14:54:05 <applicative> right, but that's another word for it
14:54:10 <byorgey> covi: there's a space for the same reason there's a space in 'Maybe Int'
14:54:24 <monochrom> _justjust: it looks wrong
14:54:50 <applicative> covi, the instances make if clear fmap :: (a -> b) -> IO a -> IO b; (a -> b) -> Maybe a -> Maybe b; etc
14:55:01 <monochrom> covi: if you understand "Maybe Int", now let f=Maybe, a=Int.
14:55:50 <_justjust> monochrom: it is the official solution in a book, i'll check the errata
14:55:54 <applicative> 'Maybe' is like a function taking types (like Int) to types (here Maybe Int)
14:56:05 <geekosaur> or mnaybe they're just confused that haskell allows for type variables with more than one letter :)
14:56:47 <applicative> fmap :: (source -> target) -> functor source -> functor target
14:56:48 <applicative> yipe
14:57:29 <Sonarpulse> geekosaur: ok
14:57:40 <Sonarpulse> pretty sure it is good, but I'll double check
14:57:49 <ion> This should make it clear: fmap :: Functor f => LensLike f (f a) (f b) a b
14:57:56 * ion ducks
14:57:56 --- mode: ChanServ set +o elliott
14:58:09 --- mode: elliott set -o elliott
14:58:15 * hpc throws edwardk at ion
14:59:04 <ion> Oh, wait. I’m a bit too tired, that’s not fmap at all.
14:59:49 <applicative> ion: it's okay as long as the implementation is either fmap or id
15:01:14 <applicative> @type either fmap id
15:01:15 <lambdabot> Functor f => Either (a -> b) (f a -> f b) -> f a -> f b
15:01:26 <applicative> shouldn't that have been nonsense?
15:02:28 <applicative> > either fmap id (Left (+1)) [1,2,3]
15:02:29 <lambdabot>   [2,3,4]
15:02:33 <Sonarpulse> geekosaur had it print the requests
15:02:42 <Sonarpulse> URL is certainly correct
15:06:37 <ion> @type \f -> join . (fmap :: Functor f => LensLike f (f a) (f b) a b) (return . f)
15:06:38 <lambdabot>     Not in scope: type constructor or class `LensLike'
15:07:09 <Sonarpulse> anybody else have any ideas?
15:07:25 <edwardk> did you want mapped?
15:07:29 <edwardk> :t Control.Lens.mapped
15:07:30 <lambdabot> (Functor f, Control.Lens.Internal.Setter.Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
15:08:24 <edwardk> :t \f -> Identity . fmap (runIdentity . f)
15:08:25 <lambdabot> Functor f => (a -> Identity b) -> f a -> Identity (f b)
15:08:46 <ion> edwardk: No, i made a brainfart and claimed fmap’s type is the same as Functor f => LensLike f (f a) (f b) a b, then i poked at (fmap :: that) until it became fmap-ish. :-P
15:08:56 <edwardk> k =)
15:17:50 <elliott> edwardk: it's sad we can use traverse directly but not fmap.
15:19:16 <edwardk> well, you can have fmap directly if you give up and go to pure profunctor lenses/semantic editor combinators, but then you lose traverse =P
15:25:54 <tdammers> hmm, shouldn't type aliases just inherit all the instances of the original types?
15:26:06 <monochrom> yes
15:26:32 <elliott> edwardk: yes. we need roconnor to figure out how to formulate Traversable in true profunctor style, clearly :P
15:26:40 <edwardk> =P
15:26:41 <tdammers> e.g. if I do `type FooID = Text`, and then somewhere else I import that type alias and try to use it as a Parsable, it should inherit Text's Parsable instance, right?
15:26:59 <tdammers> (Parsable from Scotty, that is)
15:27:01 <edwardk> sadly since you only have the existing Traversable instances, my 'representable by an applicative functor' interpretation is probably all you have =P
15:27:16 * tdammers scratches head
15:27:30 <elliott> edwardk: well, I hear you're dictator over base now.
15:27:35 <edwardk> tdammers: think of FooId as a short-hand for you.
15:27:38 <elliott> so rewriting Traversable should be no issue
15:27:54 <edwardk> tdammers: it has no reality outside of your head. everywhere the compiler sees it its just going to expand it to Text
15:27:58 <tdammers> edwardk: yes, that's my mental model
15:28:13 <monochrom> but do you really have Text's Parsable instance? do you import the module that provides it?
15:28:17 <edwardk> so it isn't that it inherits Text's instance, it just _is_ Text.
15:28:32 <tdammers> OK, yeah, the word "inherit" was a bad choice
15:29:17 <tdammers> monochrom: hmm, maybe I don't
15:29:31 <tdammers> I thought it was in Web.Scotty, but apparently it is in Web.Scotty.Action
15:31:37 <covi> ok so, f a b = f (a b) in the context of type application?
15:32:31 <blackwolf12333> Hi
15:32:34 <tdammers> let me try this
15:32:47 <covi> byorgey: ^
15:33:00 <geekosaur> covi: State Int Bool
15:33:43 <tdammers> hmm, no... "hidden module"
15:34:31 <monochrom> no no, (f a) b
15:34:49 <blackwolf12333> Okay, so I have a problem, when I use this code: http://hastebin.com/cayuyagoca.coffee I get this error: Monecul.hs:17:14: Not in scope: data constructor `Particle'
15:34:57 <blackwolf12333> And I have no idea why :O
15:35:13 <tdammers> no wait, the Parsable instance is re-exported
15:35:16 <monochrom> for example, using geekosaur's example, f=State, a=Int, b=Bool. (State Int) Bool
15:35:42 <c_wraith> blackwolf12333: because the Particle type has no Particle constructor.
15:35:50 <geekosaur> blackwolf12333, you are using Particle there as a data constructor, but the data constructors for the type Particle are Proton, Electron, and Neutron
15:35:51 <c_wraith> blackwolf12333: you need to pattern-match on constructors, not types
15:36:17 <blackwolf12333> c_wraith: aww, that takes more lines :(
15:36:33 <blackwolf12333> I thought it was nice this way...but haskell thinks otherwise :P
15:37:08 <geekosaur> also, ugh, that hastebin theme is an abuse against eyeballs
15:37:34 <blackwolf12333> lol, I love it
15:38:08 <monochrom> I have a cunning plan for you. "data Particle = Proton {mymass::Mass} | Electron {mymass::Mass} | Neutron {mymass::Mass} deriving (Show)".
15:38:41 <merijn> monochrom is stealing my thunder :(
15:38:49 <monochrom> henceforth, mass (Atom (p:ps)) = mymass p + mass (Atom ps)
15:38:52 <blackwolf12333> oh god, this is gonna be a lot of learning :O
15:40:59 <blackwolf12333> monochrom: shouldn't it be 'mass (Atom (p:ps)) = mymass + mass (Atom ps)' in that case ?
15:41:19 <hpc> blackwolf12333: mymass of what?
15:41:22 <monochrom> no, "mymass p" is exactly right
15:41:29 <blackwolf12333> hmm okay
15:41:39 <tdammers> oh f* it, I'm an idiot
15:41:45 <blackwolf12333> hpc: <monochrom> I have a cunning plan for you. "data Particle = Proton {mymass::Mass} | Electron {mymass::Mass} | Neutron {mymass::Mass} deriving (Show)".
15:42:03 <geekosaur> ```mymass``` there is a function which takes a record and returns a field value from it
15:42:09 <enthropy> if all Protons and so on have the same mass you could also have    data Particle = Proton | Electron | Neutron; mymass Proton = 1.66e-26; mymass Electron = mymass Proton / 1840
15:42:12 <hpc> blackwolf12333: i mean, of which value; it could be p, it could be some mysterious global somewhere else in scope
15:42:12 <monochrom> think of it this way. in Java or C++ or C, it would be "p.mymass"
15:42:35 <blackwolf12333> monochrom: jup
15:42:38 <hpc> and to continue the java/C++ metaphor, there is no 'this' to default to
15:43:39 <enthropy> you could explicitly have a \this -> blahblah, then fix everything before using it :)
15:43:46 <tomboy64> > elemIndices "66430125" (permutations "41063625")
15:43:46 <lambdabot>   [385,386]
15:43:51 <tomboy64> wtf
15:44:10 <monochrom> mass (Atom (this:ps)) = mymass this + mass (Atom ps)  :)
15:44:38 <tomboy64> why does it find that element twice?
15:44:53 <enthropy> tomboy64: you have two digits '6'
15:44:59 <enthropy> @type permutations
15:45:00 <lambdabot> [a] -> [[a]]
15:45:07 <tomboy64> -.-
15:45:14 <monochrom> > permutations "112"
15:45:14 <lambdabot>   ["112","112","211","121","211","121"]
15:45:19 <tomboy64> okay, that explains a lot
15:45:21 <tomboy64> thanks
15:45:29 * tomboy64 starts using nub
15:45:49 <elliott> you may wish to roundtrip through Set instead.
15:45:50 <elliott> nub is slow.
15:46:12 <hpc> :t S.toList . S.fromList
15:46:13 <lambdabot> Ord a => [a] -> [a]
15:46:23 * hackagebot wai-util 0.3 - Collection of utility functions for use with WAI  http://hackage.haskell.org/package/wai-util-0.3 (StephenWeber)
15:46:30 <hpc> as an added side effect, i think the list also comes out sorted
15:46:39 <c_wraith> meh.  S.toList . S.fromList is kinda terrible too.  It destroys ordering and isn't lazy.
15:46:40 <monochrom> but Set is eager. it forces all 7! permutations in memory
15:46:50 <monochrom> > product [1..7]
15:46:51 <lambdabot>   5040
15:47:03 <monochrom> well, I guess 5000 is a small number afterall
15:47:49 <c_wraith> if you want distinct permutations, that can be done much more efficiently than by post-processing the results
15:47:58 <c_wraith> it's much faster to never even generate the duplicates
15:48:38 <monochrom> oh wait, you will apply Set to the result of (elemIndices ...), rather than (permutations ...). that is good.
15:50:51 <zacts> hi. I'm trying to learn how to install a package from hackage, but the haskell wiki page for instructions on how to do this is down for me.
15:50:58 <tdammers> ah
15:51:06 <zacts> are there any other good resources for how to do this?
15:51:11 <Tene> zacts: cabal install packagename
15:51:13 <tdammers> No instance for (Parsable Text) arising from a use of `param'
15:51:19 * zacts wanst to install Yi
15:51:30 <zacts> Tene: wow, simple. thanks.
15:52:04 <Tene> zacts: You can make it more complex with multiple environments by using cabal-dev or hsenv, but that's the basics.
15:54:48 <adnap> Why was Haskell designed to require two colons in a type signature?
15:55:00 <c_wraith> adnap: to not be ML
15:55:20 <Ralith> adnap: for some reason people thought consing lists would be more common than declaring types
15:55:44 <hpc> i prefer :: for types anyway
15:55:50 <merijn> adnap: Why not?
15:55:54 <hpc> a single : is not particularly noticable in code
15:56:22 <merijn> This question is like asking "why are macbooks metallic coloured?"
15:58:29 <xico> is there a clever way of saying: foldM (const . f) (1,1) [1..5]
15:58:46 <edwardk> adnap: back in the day folks thought lists were going to be a hell of a lot more important to haskell
15:59:01 <xico> (where f :: (a,a) -> m (a,a))
15:59:17 <Tene> The considerate reading of the question is "Was there any specific inspiration or reasoning for :: historically, or was it just arbitrary asthetic preference by the first author?"
15:59:18 <edwardk> adnap: so once they gave : to list, you were left with :: for signatures.
15:59:24 <Tene> Which is certainly a valid question.
15:59:48 * tabemann gathered the choice of : for cons and :: for signatures was a historical one influenced by Miranda
16:00:33 <edwardk> keep in mind back in the day lists were used for everything. IO was sending requests out to the runtime system and interpreting responses in another lazy list, etc.
16:00:55 <enthropy> in some fortran :: does about the same as in haskell
16:01:14 <edwardk> but yes, the fact that Miranda was already using : and :: probably pretty much fixed that piece of syntax.
16:01:17 * tabemann remembers reading "why functional programming matters?" and that it was basically all about lazy infinite lists really
16:01:18 <enthropy> but it's a bit backwards, since you can write   integer :: x,y,z
16:01:44 <tabemann> coming from OCaml, I'm used to the opposite ML convention of :: for cons and : for signatures
16:02:04 <edwardk> as i recall from the 'history of haskell' paper, back then there was a committee guideline that if they couldn't come up with consent on something to just 'do it like miranda did'
16:02:33 <tabemann> they basically wanted a free miranda in the first place, before they thought up things like type classes and monadic IO
16:02:34 <Earnestly> enthropy: You mean Ada?
16:02:41 <edwardk> which is part of how haskell got its mishmash of design-by-committee and design-by-architect feel
16:03:00 <tdammers> I really am an incredible idiot
16:03:04 <tdammers> I should have RTFM
16:03:12 <enthropy> Earnestly: maybe it's there too. This is not fortran 77: http://en.wikipedia.org/wiki/Fortran#Code_examples
16:03:17 <tdammers> Data.Text.Text /= Data.Text.Lazy.Text
16:03:20 <tdammers> d'oh!
16:03:41 <Earnestly> enthropy: Oh, fair enough
16:04:07 <tabemann> they *did* decide to break from a few things with miranda, though, such as guard syntax and infix identifier syntax ($foo versus `foo`)
16:05:18 <tabemann> oh, and type variable syntax
16:06:23 <zacts> I just installed happy, but when I try to install another package that depends on it, it is not finding the installed happy package.
16:06:24 <Earnestly> enthropy: I wasn't even aware of a non-upper case form, or maybe cobol is confusing me, anyway thanks for actually pointing this out. o/
16:06:35 <zacts> should I pastebin my errors?
16:06:48 * zacts wishes that the haskell wiki was working for me
16:07:16 <enthropy> zacts: you're using cabal-install?
16:07:21 <zacts> yeah
16:07:35 <enthropy> you might have to add something like  $HOME/.cabal/bin to PATH
16:07:48 <zacts> let me try that..
16:08:51 <zacts> cool, so far so good this time
16:12:37 <roboguy_> zacts: when the wiki is down, I usually use archive.org to look at an archived version
16:14:42 <dpwright> I just got the error, "Couldn't match type `ByteString' with `ByteString'.  Expected type: ByteString -> IO (); Actual type: ByteString -> IO ()"
16:14:57 <zacts> oh ok cool
16:15:09 <dpwright> I have a suspicion this might be related to Char vs Word8 representations of ByteString, but I'm not sure
16:15:25 <geekosaur> usually it's strict vs. lazy
16:15:29 <elliott> hm, GHC usually reports the error better than that
16:15:33 <geekosaur> but ghc is usually somewhat better at reporting those...
16:15:35 <c_wraith> dpwright: .Char8 is the same type
16:15:41 <elliott> but yaeh, there is no Char ByteString.
16:15:47 <elliott> .Char8 just evilly treats Word8 as if it was Char.
16:15:51 <elliott> same underlying type.
16:16:04 <dpwright> right, yeah, that's why I felt unsure -- I thought it was just a representation thing, not an internal storage mechanism
16:16:52 <dpwright> ah -- lazy vs strict sounds like a good call
16:17:08 <dpwright> just looked at the source of one of the libraries I'm dealing with and it's using lazy
16:21:13 <dpwright> great -- that sorted it, thanks!
16:31:01 <zacts> yay! just installed my first hackage program. Yi - the cool haskell editor
16:31:05 <zacts> thanks
16:33:17 <silasm> Is Yi stable right now?
16:36:12 <andrewsw> I have a bit of code that uses ghc api to load a module and run the named function.
16:36:20 <andrewsw> works great for a file in $PWD
16:36:36 <andrewsw> but I cannot figure out the magic to make it work for file/over/here.hs
16:37:15 <andrewsw> appears to fail to load the target, using `load LoadAllTargets`
16:37:40 <andrewsw> a subsequent call to `isLoaded name` returns False
16:40:01 <andrewsw> anyone know the magic for handling module hierarchy in this case?
16:41:29 * hackagebot minioperational 0.3 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.3 (FumiakiKinoshita)
16:42:20 <enthropy> andrewsw: I don't know how, but looking at how ghci does it may help
16:43:20 <andrewsw> enthropy: yeah, probably, so...
16:43:27 <andrewsw> ah, it turns out it's not failing in the load.
16:43:39 <andrewsw> but in setting the context
16:43:43 * andrewsw goes to poke some more
16:48:27 <andrewsw> turns out it's problem w/ names... we load path/to/module.hs, but set the context to just "module"
16:50:10 <radish> hey how do i cast a word as an int?
16:50:29 <Peaker> radish, "cast"?
16:50:33 <radish> typecast
16:50:52 <radish> i'm trying to shift a b where b is type word
16:50:56 <radish> its throwing an error
16:51:05 <Peaker> radish, you can use fromIntegral, but I'm not sure it's well defined for out-of-range values
16:51:06 <radish> can you help me?
16:51:21 <radish> Peaker: that's okay its a word8
16:51:35 <Peaker> > fromIntegral (255 :: Word8) :: Int
16:51:35 <lambdabot>   255
16:51:45 <geekosaur> the other thing is make sure shift takes parmaeaters in the order you are expecting
16:52:07 <radish> Peaker: and here I thought fromIntegral was for going away from Integer stuff
16:52:24 * monochrom no longer argues over what is "cast", what is "convert", what is both, what is neither.
16:52:30 <radish> geekosaur: i've got a lot of experience with "shift" after this project lol
16:52:58 <Peaker> monochrom, C++ has "reinterpret_cast", "const_cast", "dynamic_cast", "static_cast", ...
16:53:10 <Peaker> makes the meaning a bit narrower
16:53:36 <radish> monochrom: i never heard that argument but now that you mention it...
16:53:42 <radish> thanks guys :D
16:53:45 <lelf> is there a neat way to write do { a<-foo; bar; return a } ?
16:53:52 <Tekmo> foo <* bar
16:54:05 <Tekmo> (<*) is from Control.Applicative
16:54:11 <lelf> ough!
16:54:26 <lelf> Tekmo: thanks
16:54:30 <Tekmo> lelf: You're welcome!
16:54:33 <monochrom> the etymology is "cast a magic spell". perhaps the connotation of cargo cult has never changed in programmer's usage
16:56:11 <Peaker> lelf, unfortunately if your "do" block is generalized to any Monad, you're going to need to add an Applicative constraint too
16:56:38 <monochrom> well, or "die cast", with the connotation of forcing a square peg into a circle hole
16:56:38 <radish> Tekmo: wow that is neat lol
16:56:44 <Tekmo> radish: Haha :)
16:56:59 <Tekmo> radish: If you do a lot of parsing you learn all about these neat combinators
16:57:52 <monochrom> die cast: http://this-plt-life.tumblr.com/post/44462204757/simon-peyton-jones-adding-the-io-monad-to-haskell
16:59:38 <radish> hey so i have another question.
17:00:43 <radish> i had misunderstood the type system and defined all my types as tuples ( a, b ) rather than something like { a :: whatever , b :: whatever }
17:00:53 <joehillen> if anyone is looking for a fun networks project, please implement this in haskell: https://github.com/irungentoo/ProjectTox-Core
17:02:23 <monochrom> actually, even {a::Int, b::Bool} is still wrong. you have to invent a new name for the type, and invent a new name for the constructor, and write "data MyType = MyCtor {a::Int, b::Bool}"
17:03:20 <monochrom> however, tuples are just fine, you don't have to regret it.
17:03:49 <Gracenotes> { a : int, b : bool }
17:03:53 <Tekmo> I use tuples all the time when I'm too lazy to define a new type
17:06:08 <Peaker> monochrom, I hate all that ceremony around records
17:07:33 <hpaste> enthropy pasted “c2hs sizeof struct without a typedef?” at http://lpaste.net/91318
17:07:37 <jfischoff> data GThing a = Thing {} doesn't bother me, cause I get use the same constructor over again. Otherwise its annoying
17:08:31 <radish> great :D
17:08:38 <Peaker> enthropy, try: {#sizeof struct Foo #}?
17:08:41 <radish> thought i was being weird
17:08:42 <enthropy> I guess more generally I need a storable instance or something because I need to make copies of a default struct
17:08:45 <Peaker> enthropy, in C, unlike C++, "struct x" is named "struct x".
17:08:50 <Peaker> enthropy, and not "x"
17:09:09 <c_wraith> typedef struct x x;
17:09:33 <c_wraith> I'm working with a library at the moment that has typedef'd some of their structs, and not others.  It confuses me a lot.
17:09:35 <schoppenhauer> it's typedef struct {...} x
17:09:53 <enthropy> Peaker: c2hs doesn't seem to allow that
17:10:11 <Peaker> c_wraith, I use "struct", "union", "enum" without "typedef" to signify a transparent type, and a "typedef" to signify an "opaque"/"abstract" type
17:11:47 <c_wraith> Peaker: this library doesn't.  In fact, it non-named enums in several cases, to my even-greater confusion.
17:11:55 <c_wraith> it *uses* non-named..
17:15:01 <Peaker> enthropy, c2hs seems to be a bit silly about it
17:16:24 <Peaker> enthropy, http://comments.gmane.org/gmane.comp.programming.c2hs/276
17:16:53 <Tekmo> Hmm, lambda bot didn't post the link, but I got this to work with hsc2hs: http://lpaste.net/91321
17:18:16 <Ghoul_> Does anyone know where I can find examples for using pipes-binary ?
17:18:38 <Ghoul_> They seem to come out-of-the-box with a load of transformers and I'm not sure whether its my responsibility to run them ... or what
17:19:02 <Tekmo> Yeah, that's my fault
17:19:06 <Tekmo> That will get simpler soon
17:19:32 <Ghoul_> do you have an example lying around?
17:19:43 <Tekmo> No, but I can show you how to use that API
17:19:51 <Ghoul_> hmm, ok.
17:19:55 <Tekmo> I wrote my own internal serialization API because `cereal` and `binary` were too slow
17:20:07 <Tekmo> That's why I don't have `pipes-binary` examples
17:20:28 <applicative> oh, hi Tekmo
17:20:31 <Tekmo> Hi!
17:20:47 <Tekmo> So I will teach you how to use `pipes-binary` just as long as you remember that things will get simpler really soon
17:21:27 <Tekmo> decode's type is basically (if you squint): Consumer ... (Maybe ByteSTring) m r
17:21:45 <Tekmo> That means you need to supply it with a Producer ... (Maybe ByteString) m r
17:21:46 <Ghoul_> understood
17:21:56 <Tekmo> That you can get easily with the `wrap` function from `pipes-parse`
17:22:07 <Tekmo> You can think of its type as `Producer a m r -> Producer (Maybe a) m r`
17:22:26 <Tekmo> It takes any `Producer` and wraps it so that all outputs are wrapped in a `Just` and it finishes with `Nothing`
17:22:42 <Tekmo> So let's say that you have that `Producer`
17:22:57 <Tekmo> Then all you need to do is connect it to the decoding pipe, which would look something like this:
17:23:20 <Tekmo> decodeStuff () = forever $ do { x <- decode; yield x }
17:23:24 <Tekmo> Customize that as necessary
17:23:52 <Ghoul_> OK I think I can do that. Thanks for your help!
17:23:59 <Tekmo> Wait!
17:24:02 <Tekmo> There's one non-trivial step
17:24:15 <Tekmo> When you are done you have to use `runEitherP` to get rid of that `EitherP` layer in the type
17:24:22 <Tekmo> Then you can use `runProxy` to fully unwrap it
17:24:34 <Tekmo> That's the part that is going away in `pipes-4.0.0`
17:24:44 <Ghoul_> Im not sure that's going to work well for me, I already have an EitherP and a StateP in my type from my pipeline
17:24:51 <Tekmo> It will work
17:24:54 <Ghoul_> do I have to run them again
17:25:02 <Tekmo> No
17:25:12 <Ghoul_> ok
17:25:16 <Tekmo> Compose all your pipes with the `EitherP` layer still on
17:25:24 <Tekmo> YOu only use `runEitherP` and `runStateP` when the whole pipeline is complete
17:25:49 <Ghoul_> Oh, but it's going to loook like StateP SessionState (EitherP Timeout p) ... for the base layer
17:25:54 <Ghoul_> because im using pipes-network which wraps everything
17:25:58 <Ghoul_> and then I have to interleave my state above
17:26:09 <Ghoul_> so I'll probably have to run Either twice over top..
17:26:11 <Ghoul_> no?
17:26:14 <Tekmo> Then wrap the `EitherP` segment of your code using `liftP`
17:26:28 <Tekmo> `liftP` will add on the `StateP` layer for you so that you can compose it with pipes that have `StateP` as the outer layer
17:26:36 <zRecursive> :t liftA2
17:26:38 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
17:26:56 <Tekmo> Oh, and you have to get the two `EitherP` layers to agree on the same error type
17:27:05 <Tekmo> I tried to convince Renzo to make them all use SomeException, but he insisted on that
17:27:12 <Tekmo> I'll explain how to do that
17:27:40 <Tekmo> For `decode`, you can fix the `DecodingError` to use `SomeException` instead by using `fmapL` from Control.Proxy.Trans.Either
17:28:01 <Tekmo> :t fromException
17:28:02 <lambdabot> Exception e => SomeException -> Maybe e
17:28:07 <Tekmo> :t toException
17:28:08 <lambdabot> Exception e => e -> SomeException
17:28:09 <Tekmo> That's the one
17:28:22 <Tekmo> So you would use `fmapL toException` to convert  the type of the left value to a `SomeException`
17:28:27 <Ghoul_> Oh dear, okay. Sounds fun haha
17:28:32 <Tekmo> Then you can do the same thing to the `pipes-network` function, with just one twist
17:28:40 <Tekmo> You would use `hoist (fmapL toException)`
17:28:46 <Tekmo> Sorry, `hoistP`, not `hoist
17:28:53 <Tekmo> `hoistP (fmapL toExcepion)`
17:29:10 <Tekmo> The `hoistP` lifts the `fmapL` over the outer `StateP` layer to target the inner `EitherP` layer
17:29:20 <Tekmo> Then you can use that to modify it to use `SomeException`, too
17:29:40 <Ghoul_> I really appreciate how you tuned pipes for performance :)
17:29:43 <Tekmo> If you do that, then both of your `EitherP` layers will have the same left type, so they can be composed together directly
17:29:47 <Tekmo> You're welcome!
17:29:53 <Tekmo> It will get a bit faster in the next release, but not much
17:30:08 <applicative> I see, k0001 has his own Timeout exception type
17:30:26 <Tekmo> Is there a standard one for that?
17:30:45 <applicative> dunno
17:30:58 <Ghoul_> Timeout works fine for me. I use it like this:
17:31:13 <Ghoul_> let status = either (const " timed out") (const " closed") res; putStrLn $ "Connection from " ++ show addr ++ status
17:31:38 <applicative> nothing looks right inside Control.Exception
17:32:18 <Tekmo> So the things that will become simpler in `pipes-4.0` is that all the proxy transformers are going to become monad transformers in the base monad
17:32:24 <Tekmo> So all that proxy transformer machinery will disappear
17:32:37 <Tekmo> And you would just use `hoist` and `lift` to work with those base monad transformers instaed of `hoistP` and `liftP`
17:32:44 <applicative> that's certainly a massive intelligibility boost
17:32:48 <Tekmo> Yeah, I agree
17:32:56 <Tekmo> You can thank Aleksey Khudyakov
17:33:11 <Tekmo> He basically wrote me an e-mail saying something to the effect of "these proxy transformers are isomorphic to monad transformers in the base monad"
17:33:18 <Tekmo> And that was basically the beginning of `pipes-4.0`
17:35:21 <applicative> the proxy type class had some nice aspects, e.g. one could imagine trying different implementations etc
17:35:26 <Ghoul_> Tekmo: so, pipes-binary is getting a rewrite too to not use Binary?
17:35:33 <Tekmo> Ghoul_: No, not yet
17:35:39 <Tekmo> The plan is that `pipes-binary` will continue to support `Binary
17:35:50 <Ghoul_> is there something else I should use for speed?
17:35:58 <Tekmo> This is the tricky part
17:36:00 <davesque_> haskell.org is down?
17:36:15 <Tekmo> So probably the best published alternative on Hackage is blaze-builder
17:36:21 <Tekmo> I think there's a serialization library based on that
17:36:40 <Tekmo> I use one that is hard-coded to work with `Handle`s directly and it's still about 2x faster than even that
17:36:52 <Tekmo> I can share the code for it with you
17:36:57 <Tekmo> It's really simple, let me just dig it up
17:37:02 <Ghoul_> that would be excellent!
17:37:09 <Tekmo> It doesn't use `pipes`, though
17:38:30 <Tekmo> http://lpaste.net/91322
17:39:06 <Tekmo> I also have high-efficiency instances for Storable `Vector`s, too
17:40:03 <Tekmo> I annotated that lpaste with the `Vector` instances, so you can refresh it to see them
17:41:52 <Ghoul_> I hope it stays fast when I pipe-ify it
17:41:57 <Tekmo> The other nice thing about the instance for lists is that it works in constant memory, unlike the `Binary` and `Serialize` instances for lists
17:42:04 <Tekmo> It should stay fast, don't worry
17:42:33 <Tekmo> The real issue is that it is specialized to `Handle`s, which makes it not so useful for network programming
17:43:15 <Tekmo> But I think you could probably easily modify it to work with `Socket`s since the code is pretty simple
17:43:27 <Ghoul_> thanks :)
17:43:47 <Tekmo> You're welcome! :)
17:43:51 <zzing> @src (/)
17:43:51 <lambdabot> Source not found. Do you think like you type?
17:44:27 <Tekmo> I have to head out now, but if you have any other questions and I'm not in the channel, just e-mail me: Gabriel439 at gmail, or you can e-mail the haskell-pipes mailing list
17:44:36 <zzing> How do I define a function purely but can have undefined parts?
17:44:51 <joelteon> You mean like division by zero?
17:44:57 <zzing> exactly like that
17:45:02 <Ghoul_> sounds good.
17:45:56 <joelteon> zzing: you mean, how do you handle exceptional cases?
17:46:09 <joelteon> because if you wanted to *define* an invariant, you'd just do error "Something has happened!"
17:46:19 <joelteon> > error "this should never happen"
17:46:20 <lambdabot>   *Exception: this should never happen
17:46:44 <pentace> zzing: I'd use a Maybe result type
17:46:45 <joelteon> but if you wanted to define a divide function that never throws an error, you might consider Fractional a => a -> a -> Maybe a
17:46:52 <joelteon> or whatever the num typeclass is
17:46:54 <nbouscal> it would be so nice if error and exception weren't so thoroughly mixed about
17:47:13 <zzing> joelteon, I will give you an example: Say I have a function   w b d u a = …    b + d + u = 1, and b,d,u,a must be within [0,1]  - otherwise it cannot work
17:47:15 <joelteon> :t let safeDivide x y = case y of 0 -> Nothing; y' -> Just (x / y') in safedivide
17:47:16 <lambdabot>     Not in scope: `safedivide'
17:47:16 <lambdabot>     Perhaps you meant `safeDivide' (line 1)
17:47:22 <joelteon> :t let safeDivide x y = case y of 0 -> Nothing; y' -> Just (x / y') in safeDivide
17:47:23 <lambdabot> (Eq a, Fractional a) => a -> a -> Maybe a
17:47:35 <zzing> I suppose I could use Maybe, monads can help me with the inconvenience
17:47:42 <joelteon> zzing: you could use Maybe
17:47:42 <nbouscal> i think for division by zero an exception is a better choice than a maybe or either. you don't want to have to deal with the maybe every time you divide anything
17:48:05 <joelteon> Or you might be able to use ErrorT -- there are a lot of ways to deal with errors in haskell, there's a blog post floating around somewhere
17:48:15 <nbouscal> division by zero is like the textbook example of what an exception is.
17:48:26 <joelteon> zzing: http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/
17:48:38 <zzing> I remember that post well
17:50:09 <zRecursive> :t liftM2
17:50:10 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:50:35 <yyyyy> is there some way to deconstruct the names in lists bound by '<-' in do notation? e.g. given a result of [(a,b,c)] to some action aC, could one avoid having to resort to e.g. ac >>= mapM_ (\(a,b,c) -> f a b)
17:51:28 <zzing> Is there a diagram that shows a sort of relational diagram for the main typeclasses? (hierarchy if I can use that term). For instance, applicative comes before monad
17:51:45 <pentace> @pl mapM_ (\(a,b,c) -> f a b)
17:51:45 <lambdabot> (line 1, column 14):
17:51:45 <lambdabot> unexpected "c"
17:51:45 <lambdabot> ambiguous use of a non associative operator
17:51:45 <tabemann> there is, even though I don't know where it is
17:51:49 <nbouscal> typeclassopedia has it
17:51:55 <tabemann> yeah, that's it
17:52:23 <zzing> "Sorry! This site is experiencing technical difficulties." :-(
17:53:41 <zzing> Using the pdf
17:54:23 <zzing> hmm, I haven't heard of Pointed, I thought Applicative came right after Functor
17:54:29 <zRecursive> maybe (current haskell.org) (constructed by haskell) ?
17:54:37 <nbouscal> pointed is no longer in use
17:55:14 <zRecursive> Functor <- Applicative <- Monad
17:55:37 <zzing> ok, so the diagram is slightly outdated. I believe typeclassopedia is definitely the  resource I have to look at
17:55:39 <zRecursive> :t maybe
17:55:39 <lambdabot> b -> (a -> b) -> Maybe a -> b
17:55:43 <zzing> I need to get better with this
17:55:54 <nbouscal> yes, typeclassopedia is the go-to reference
17:55:57 <nbouscal> the exercises are very useful
17:56:09 <zRecursive> maybe (current haskell.org) (constructed by haskell) (Maybe yesod)   :)
17:56:43 <zRecursive> then haskell.org will be safe enough :P
17:59:21 <zzing> It seems that the last time I tried to access typeclassopedia (last year) it was down as well. Bad luck on my part.
18:01:41 <nbouscal> zzing: http://web.archive.org/web/20130702212548/http://www.haskell.org/haskellwiki/Typeclassopedia
18:04:09 <roboguy_> yyyyy: you mean something like uncurry, but for triples?
18:09:38 <esp> anyone know what the story is with haskell.org? it's been down all day, wondering when we'll get it back
18:10:02 <esp> my bad, it's up now..
18:10:11 <yyyyy> roboguy_: not sure. the example could be a pair as well. given an action aC that results in [(a,b)], how do you refer to a and b on further actions down the do notation. i can only think of avoiding the notation altogether and using e.g. aC >>= mapM_ (\(a,b) -> f a b), where f is some action that takes two parameters.
18:10:42 <yyyyy> roboguy_: not sure if that's clear or if i'm missing something very obvious :p
18:12:43 <nbouscal> yyyyy: lenses?
18:13:15 <nbouscal> little heavy of a solution, but closest thing i can think of
18:13:35 <enthropy> probably there are better lens solutions than:    aC >>= mapM_ (\x -> f (view _1 x) (view _2 x))
18:14:15 <pentace> yyyyy: Or are you asking how to do that using the do-notation?
18:14:56 <yyyyy> pentace: on do notation, yes.
18:15:04 <nbouscal> :t (&&&)
18:15:05 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
18:15:12 <yyyyy> nbouscal: i haven't really checked lenses yet. maybe it's about time
18:15:44 <edwardk> enthropy: what are you trying to do?
18:15:57 <enthropy> edwardk: aC >>= mapM_ (\(a,b) -> f a b)
18:16:05 <enthropy> where the tuple might be bigger
18:16:09 <pentace> yyyyy: "do { [(a,b)] <- action; f a b }" should work
18:16:12 <edwardk> uncurry f
18:16:28 <edwardk> aC >>= mapM_ (uncurry f)
18:16:40 <enthropy> uncurry is monomorphic
18:16:41 <edwardk> oh, for k-tuples
18:16:59 <edwardk> there isn't a k-curry class lying around usable anywhere
18:17:37 <roboguy_> yyyyy: so it needs to work on tuples with an arbitrary number of values in them?
18:18:14 <yyyyy> roboguy_: ideally, yes.
18:18:31 <roboguy_> yyyyy: and you just want to extract the first and second values?
18:18:58 <yyyyy> roboguy_: it depends on the case. in this case, yes, just the first and second.
18:19:22 <nbouscal> yyyyy: why do you need this?
18:19:24 <yyyyy> roboguy_: though a solution that generalises this would be preferred, if at all possible.
18:19:24 <roboguy_> yyyyy: what I mean is, do you want to apply the function to all the values in the tuple?
18:20:13 <yyyyy> roboguy_: again, in this case only to the first two, but i can think of examples where i would want all.
18:20:44 <roboguy_> yyyyy: I meant, given an n-tuple, do you always want to apply all n values? or sometimes just some of them?
18:20:50 <zRecursive> :t uncurry
18:20:51 <lambdabot> (a -> b -> c) -> (a, b) -> c
18:21:16 <roboguy_> if not, I'm really not sure how you could make something that general
18:21:44 <yyyyy> roboguy_: sometimes just some of them, in which case i could do (\(a,b,c,_) -> ...)
18:21:56 <nbouscal> it seems to me like tuple is probably not the right structure to use here, but it's hard to say without knowing more about the problem you're solving
18:23:32 <roboguy_> yyyyy: yeah, I think it would be good if you were more specific about what you're trying to do
18:25:22 <yyyyy> nbouscal, roboguy_: it came when trying to process data out of getEnvironment, but I realised that any case where I would have to pack k-tuples a one-off solution would be needed, hence the general question.
18:26:46 <nbouscal> doesn't getEnvironment always return 2-tuples?
18:26:49 <nbouscal> :t getEnvironment
18:26:50 <lambdabot> Not in scope: `getEnvironment'
18:27:30 <nbouscal> :t System.Environment.getEnvironment
18:27:30 <lambdabot> IO [(String, String)]
18:27:44 <yyyyy> yes, for getEnvironment, it's a key-value that I would get as (\(k,v) -> ...)
18:29:25 <roboguy_> yyyyy: I'm not sure I see the problem with normal pattern matching on tuples... I can't imagine a cleaner solution, especially since you might ignore some of the values
18:30:14 <yyyyy> roboguy_: ah, not a real problem, only that i had to 'escape out' of do notation to achieve it
18:30:39 <roboguy_> yyyyy: you had to escape out of do notation?
18:31:49 <roboguy_> yyyyy: in this particular case, maybe you would find this better: aC >>= mapM_ (uncurry f)
18:33:53 <erisco> ones o = 1 : o     how do you feed 'ones' as 'o'? ones (ones (ones (ones ...
18:35:26 <roboguy_> erisco: fix
18:35:31 <erisco> @src fix
18:35:31 <lambdabot> fix f = let x = f x in x
18:36:09 <erisco> I don't even understand
18:36:32 <nbouscal> erisco: what are you trying to do? Looks like you're re-implementing repeat 1?
18:36:48 <erisco> nbouscal, I was just giving a trivial example of the problem I am having
18:37:05 <yyyyy> roboguy_, nbouscal: thanks for the help. for that case, uncurry will do, and i'll look into lenses in general. :)
18:37:07 <roboguy_> yyyyy: or, in do notation, I think you could write do { acResult <- aC; mapM_ (uncurry f) acResult }
18:37:24 <joelteon> erisco: 1:(1:(1:(1:...)))
18:37:30 <erisco> let x = f x  ... so I take it this means let x = f (f (f (f ...
18:37:43 <joelteon> > let ones = 1 : ones in ones
18:37:44 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:38:45 <ezrakilty> Is there a name for the right-hand operand of (>>=)?
18:39:02 <nbouscal> ezrakilty: we were just talking about that yesterday i think. there was no consensus
18:39:16 <roboguy_> erisco: you can also write the definition as fix f = f (fix f)
18:39:20 <danharaj> lpsmith: are you available for a little chat atm? :)
18:39:29 <ezrakilty> nbouscal :-) funny! I'll check the archives to see what transpired. thx
18:39:54 <erisco> thanks
18:39:58 <nbouscal> ezrakilty: np. not positive it was yesterday but i think so
18:41:31 <lelf> > fix (1:)
18:41:32 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:41:43 <hpaste> enthropy pasted “quasiquoter faking more permissive tuple pattern matching” at http://lpaste.net/91324
18:41:48 <enthropy> yyyyy: ^^
18:51:54 <FreeFull> lambdabot does lenses again, properly!
18:52:38 <FreeFull> The world is saved!
18:54:48 <mstksg> is haskell.org down for anyone
18:54:53 <sclv> yeah
18:54:57 <sclv> we're bumping the ram in the vm
18:55:02 <sclv> expect 2 minutes of turbulence
18:55:06 <mstksg> thanks
18:58:40 <roboguy_> is Void strict so that "fix Void" never terminates?
18:58:56 <danharaj> :t Void
18:58:57 <lambdabot> Not in scope: data constructor `Void'
19:01:03 <roboguy_> danharaj: it's in the void package. maybe lambdabot doesn't have it
19:01:08 <roboguy_> :t Data.Void.Void
19:01:08 <lambdabot> Not in scope: data constructor `Data.Void.Void'
19:01:28 <ion> Depends on the definition. With “data Void” you don’t have anything to fix. With “newtype Void = Void Void”, it is strict indeed.
19:01:42 <roboguy_> ion: well, I meant specifically the one in the void package
19:01:53 <danharaj> It is probably well behaved because edwardk wrote it.
19:01:56 <dmwit> roboguy_: Yes, that is why Void is strict.
19:02:28 <dmwit> roboguy_: Additionally, void is strict so that void x is also bottom whenever x is.
19:03:58 <roboguy_> wait, isn't newtype strict?
19:05:01 <roboguy_> I just tried defining "newtype Void = Void Void" in ghci, but "let f (Void _) = 1 in f $ fix Void" terminates...
19:05:17 <elliott> newtype pattern matches are irrefutable
19:05:19 <sclv> haskell.org is back up for those keeping score
19:05:23 <sclv> with more ram and stabiliy
19:05:28 <danharaj> woo
19:05:45 <roboguy_> elliott: I'm not sure I know what that means
19:05:47 <danharaj> sclv: do you know how blind I am without haskell.org?
19:06:07 <sclv> eh its hackage i rely on for documentation these days
19:06:12 <ion> sclv: Did you install a new RAM module and a new stability module?
19:06:14 <elliott> roboguy_: it means that for f (NewtypeConstr x) = ..., f _|_ is the same as f (NewtypeConstr _|_)
19:06:24 <elliott> (because _|_ is the same as NewtypeConstr _|_ because newtypes don't exist at runtime)
19:08:02 <dmwit> roboguy_: Or, another way to explain it: newtype constructors don't exist at runtime. So at runtime, the source of "f" is "f _ = 1".
19:08:04 <roboguy_> elliott: then it eventually eliminates the unused argument during compilation?
19:08:14 <roboguy_> hmm, ok that makes sense
19:08:15 <roboguy_> thanks
19:08:50 <elliott> you can try:
19:08:53 <elliott> f v = v `seq` 1
19:08:57 <sclv> ion: well we realized the vm had low ram, which led to occasional drive-bys from the oom kilelr
19:08:57 <elliott> this will explode appropriately.
19:09:07 <dmwit> Which is a bit mind-bending, really.
19:09:10 <roboguy_> I guess it's just that before this, I always heard the only (semantic) difference between a data with only one constructor and newtype is that newtype is strict
19:09:10 <sclv> so now we have enough ram that this shouldn't happen
19:09:15 <sclv> plus we'll bump the swap
19:09:33 <dmwit> I sometimes wonder whether the newtype Void = Void Void pattern has a special case in GHC.
19:09:50 <sclv> roboguy_: that is the semantic difference
19:10:06 <sclv> the "fact" that the representation is the same is an operational optimization
19:10:28 <roboguy_> sclv: but "data Void = Void !Void" has different behavior than "newtype Void = Void Void" sometimes
19:10:28 <ion> f !(Void _) = 1 should also work.
19:10:40 <ion> (But i would use seq.)
19:10:43 <dmwit> Well, pattern-matching on newtypes is "lazier" than pattern-matching on data. So it's true that it's not the only semantic difference.
19:10:58 <roboguy_> interesting
19:11:07 <jmcarthur> lazier in some ways, at least
19:11:12 <sclv> ah, true, that's a subtle thing
19:11:16 <dmwit> Yes, hence the scare quotes.
19:11:17 <jmcarthur> pattern matching is lazier, but forcing is not
19:11:30 <enthropy> @where revdeps
19:11:30 <lambdabot> http://packdeps.haskellers.com/reverse
19:11:37 <roboguy_> there can be lots of little details
19:11:42 <sclv> i wonder if thats a good quirk or not
19:11:46 <sclv> could we be uniform?
19:12:05 <sclv> like is it even possible to give newtypes the same semantics, and would we want to?
19:12:06 <jmcarthur> i don't think it can work that way with a sum type
19:12:09 <dmwit> Well. Think about the reason newtype exists.
19:12:12 <jmcarthur> oh you mean the other way
19:12:31 <sclv> like its weird that its nonuniform
19:12:33 <jmcarthur> no i think it's good the way it is
19:12:34 <dmwit> They exist so that there can be an operational behavior that assigns no runtime cost to having another copy of a given type with a different name.
19:12:45 <sclv> it feels like its exposing an implementation detail
19:12:48 <dmwit> It's not non-uniform.
19:12:59 <dmwit> A newtype behaves exactly like the type it's wrapping.
19:12:59 <sclv> right, but can we get that same behavior while giving the same pattern matching semantics as on strict datatypes?
19:13:10 <dmwit> But you have to write an extra constructor *everywhere* (including pattern matches).
19:13:12 <jmcarthur> newtypes exist for the injectivity
19:13:21 <sclv> right
19:13:27 <jmcarthur> if the constructors weren't needed we wouldn't even have them
19:13:37 <sclv> but is the difference in pattern matching behavior necessary is all i mean
19:13:51 <dmwit> I'm saying you're comparing the wrong two things.
19:13:58 <sclv> like could we make them behave _exactly_ like strict data types?
19:14:02 <danharaj> if they matched the same way strict data types did then they wouldn't have newtype semantics.
19:14:03 <dmwit> You're comparing newtype and strict data; you should be comparing newtype and the type that's being wrapped.
19:14:03 <jmcarthur> i think the difference is fundamental to what newtypes are
19:14:09 <dmwit> The behavior of the latter two are identical.
19:14:12 <sclv> hmm
19:14:16 <jmcarthur> right, what dmwit is saying
19:14:51 <sclv> ok, i sorta buy that. plus newtypes are in the spec
19:14:53 <danharaj> a real flaw is that we can't newtype existentials, meaning existential types always have extra bottoms :(
19:14:55 <sclv> unlike strict data types
19:15:10 <jmcarthur> imagine if haskell had ocaml-style type abstraction where you can just say  type t = int  and then hide the representation behind a module. that's the kind of thing newtype gives us, except injective.
19:15:28 <sclv> so can we change strict data types so they act more newtypeish (or have a flag to do so when they're not sum types at least?)
19:15:34 <jmcarthur> danharaj: yeah that's a big shame
19:15:38 <sclv> arguably that's a bad idea too
19:15:41 <sclv> i'm just exploring the space
19:16:20 <jmcarthur> sclv: i think the strict semantics should remain, although the cost of the constructor at runtime needn't
19:16:35 <dmwit> Well, I guess for data Void = Void !Void you can get newtype behavior by case v of ~(Void _) -> ...
19:16:53 <dmwit> or
19:17:02 <dmwit> Yeah, I'm not thinking clearly about the differences here.
19:17:28 <dmwit> The top-level question, I guess, is, "Why do we want both?".
19:17:31 <roboguy_> dmwit: but then it's the responsibility of the area it's used and not the responsibility of the type definition
19:17:33 <dmwit> I'm not sure I know the answer to that.
19:18:32 <dmwit> I guess part of the reason we're getting confused is because we're talking about a newtype wrapper around a value that's strict anyway.
19:18:54 <dmwit> But you can newtype wrap lazy values, too, and you want to preserve that laziness when you unwrap it to pass it to some auxiliary function.
19:19:12 <dmwit> So it makes sense to give the programmer control over whether unwrapping is lazy or strict, I think.
19:19:18 <dmwit> And that is the real answer to the top-level question.
19:19:48 <dmwit> sclv: I sort of buy this new phrasing, and you should tell me whether you agree. =)
19:20:52 <elliott> danharaj: not always.
19:20:56 <elliott> you can just use a bang pattern
19:21:09 <danharaj> elliott: ooh
19:21:14 <elliott> dolio has an argument that newtype existentials are sort of unsound
19:21:16 <elliott> it convinced me.
19:24:30 <sclv> hmm, right. "newtypes are exactly as lazy or strict as their underlying type"
19:25:03 <sclv> while bang patterns are "contained types are exactly as strict as their outer constructors"
19:25:07 <sclv> and thats asymmetric
19:31:11 <lpsmith> danharaj:  I just noticed the IRC alert,  if you'd like to continue part of our email conversation here
19:40:13 <MedDev> Is there any way I can insert events into threadscope so I know which functions are starting when?  Kinda like Debug.Trace, but writes a custom event to the .eventlog?
19:40:20 <johnw> yes
19:40:38 <johnw> traceEvent
19:40:42 <johnw> and traceEventIO
19:40:50 <johnw> see the Haddocks for Debug.Trace
19:41:19 <MedDev> thanks :D
19:45:15 <zRecursive> :t traceEventIO
19:45:15 <lambdabot> Not in scope: `traceEventIO'
19:47:06 <johnw> yeah, lambdabot doesn't have everything in scope :)
20:01:13 <dibblego> how to generalise this function? https://gist.github.com/tonymorris/6109849
20:04:56 <tabemann> what's the function with the type something like: (b -> a -> (a, c)) -> a -> [b] -> (a, [c])
20:05:15 <tabemann> (it's not necessarily exactly that type, but that idea)
20:05:42 <tabemann> basically like foldl + map together (I don't remember the name)
20:05:44 <dibblego> tabemann: traverse almost
20:06:31 <BMeph> mapAndFold, comes in both R and L flavors.
20:06:41 <tabemann> mapAccum{L|R}
20:12:03 <ReinH> edwardk: ping
20:12:14 <hpaste> MedDev pasted “Not logging events?” at http://lpaste.net/6540205426154143744
20:12:25 <MedDev> Adding the -la flag doesn't seem to affect what is logged.  I am compiling with -rtsopts and -eventlog.
20:14:33 <joelteon> :t mapAccumL
20:14:33 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
20:15:27 <tabemann> random question
20:15:38 <tabemann> is fromIntegral a partial function when it is from Integer to Int?
20:15:54 <enthropy> it's also close to (State acc)
20:15:59 <elliott> > fromIntegral 219312312783678454851784514781254782564781547812347812547815234785124851278547812354182547812581542378 :: Int
20:16:00 <lambdabot>   37390826
20:16:06 <elliott> probably not
20:16:42 <enthropy> err, I mean mapM when your Monad is State acc
20:16:51 <dibblego> (x -> State acc y) -> [x] -> State acc [y]
20:17:10 * hackagebot yesod-auth-account 1.2.1 - An account authentication plugin for Yesod  http://hackage.haskell.org/package/yesod-auth-account-1.2.1 (JohnLenz)
20:20:32 <enthropy> dibblego: maybe this is a start: zipAlignG x y = zipAlign (toList x) (toList y)
20:20:45 <dibblego> enthropy: you mean with Foldable?
20:20:50 <enthropy> yes
20:22:24 <edwardk> heya ReinH.
20:23:56 <zRecursive> @djinn (b -> a -> (a,c)) -> a -> [b] -> (a, [c])
20:23:57 <lambdabot> Error: Undefined type []
20:27:01 <roboguy_> dibblego: generalize it in what way?
20:27:08 <roboguy_> oh I see
20:27:18 <dibblego> roboguy_: on []
20:32:02 <roboguy_> dibblego: hmm, it seems like you need to "get back out of" the Functor/Applicative/Monad/etc to return a ZipAlign, so I'm not sure that's possible
20:32:29 <roboguy_> oh wait, I missed the other part
20:32:31 <dibblego> roboguy_: it seems more ComonadApply to me than anything, but I couldn't get it cranking
20:32:55 <dibblego> or ExtendApply rather (since [] has no Comonad)
20:44:29 <lightquake> what's the canonical way to catch exceptions thrown by a value in some MonadIO monad?
20:45:13 <elliott> a pure value?
20:45:20 <elliott> you can just liftIO (evaluate x `catch` ...)
20:45:38 <elliott> if it's an action in your MonadIO monad, then you can't do it with just MonadIO.
20:46:01 <elliott> in essence, it needs a more powerful kind of lifting than MonadIO offers, and one that doesn't have obvious meaning for even monads as simple as State
20:46:13 <lightquake> it's an action in the monad, yeah
20:46:32 <elliott> there are various packages for alleviating this, perhaps try edwardk's new http://hackage.haskell.org/package/exceptions
20:46:55 <elliott> there are also things like monad-control which try to generalise this pattern to handle things like forkIO as well, but I find their approach rather too ad-hoc and the semantics questionable
20:47:15 <lightquake> specifically: http-conduit exposes an interface that gives me a MonadIO m => m L.ByteString, and can throw various kinds of exceptions when I try to evaluate it
20:47:59 <elliott> right. so hope your "m" is an instance of MonadCatch and use the corresponding functions.
20:48:16 <elliott> or, actually.
20:48:20 <elliott> no this is simpler than that
20:48:29 <elliott> because it is polymorphic over all "m" that are MonadIOs, you can pick m = IO
20:48:38 <elliott> and then catch exceptions directly in IO, and then lift the resulting action with liftIO
20:48:54 <lightquake> ah, yeah
20:48:55 <elliott> e.g. liftIO . Control.Exception.try
20:49:09 <lightquake> looking at the implementation (which I have to change a bit anyway) it just uses a liftIO
20:55:53 <tabemann> monad transformer stack + catch question (inspired by the above)
20:56:07 <tabemann> is there any particular general way one handles the following case:
20:56:24 <tabemann> one has one's outside stack, and needs to catch an exception, so one does liftIO $ catch ...
20:56:27 <tabemann> but
20:56:52 <tabemann> one needs access to the state of the stack *outside* the catch from inside, i.e. one wants to basically reenter the stack
20:57:33 <tabemann> and likewise, when one leaves the stack, one wants to transfer the stack's state outside, so one knows what the state of the stack was at the time the code in the catch completed
20:58:23 <tabemann> do you have to basically manually deconstruct the stack's state and then reconstruct it inside, and the same from inside to outside again, to do this, or is there any general pattern for doing this beyond that?
20:58:37 <ihm1> Is there any way to get unification of constraints with constraint variables to occur? In particular, I want to write a function `apply :: c a => (forall t. c t => t -> r) -> a -> r` with the obvious definition apply f x = f x. This typechecks, but I can't really use this function as eg `apply print` is a type error
20:59:44 <enthropy> tabemann: there's this http://hackage.haskell.org/package/MonadCatchIO-mtl
21:01:53 <tabemann> enthropy: that looks like it's still using block/unblock instead of mask...
21:03:07 <tabemann> but it does look like it solves the problem I mentioned
21:07:39 <jekor> The ranks are growing.
21:10:12 <hpaste> jekor pasted “cabal post-install hook” at http://lpaste.net/91325
21:10:22 <zzing> Has anyone ever used scripts to publish literate haskell + markdown to a jekyll blog?
21:11:07 <tabemann> dammit, why doesn't Haskell have it where you can have multiple patterns point to the same code in a case expression...
21:11:25 <jekor> After tracing through 6 or 7 Cabal modules, I'm not sure what I'm doing wrong. I've mostly copied code from the default hooks.
21:15:39 <bscarlet> tabemann: just guessing, but probably because it's relatively easy to use a "let" to dedup the code, and the rules necessary to make sure two different patterns hypothetically pointing at the same code both bound the same variables the same way would be a little ugly.
21:23:50 <carter> bscarlet yup, lets are how its done :)
21:33:17 <enthropy> tabemann: like "or patterns"?
21:33:30 <tabemann> enthropy: yeah
21:33:45 <tabemann> I remember those from OCaml, which is why I miss them in Haskell
21:34:19 <carter> or patterns?
21:34:23 <enthropy> tabemann: there's a quasiquoter for them in here http://ghc.haskell.org/trac/ghc/ticket/3919
21:34:26 <carter> laziness makes sharing really cheap
21:34:36 <enthropy> (disclaimer I wrote it)
21:34:42 <carter> and internally the compiler should do the right thing
21:35:29 <carter> neat
21:37:45 <tabemann> unfortunately they set the milestone for that one to bottom
21:38:39 <roboguy_> tabemann: what does that mean?
21:38:55 <enthropy> well the haskell-src-meta based version is probably going to work just as well as one built into ghc
21:41:48 <tabemann> roboguy_: the milestone set to bottom means "no plans on doing this any time soon"
21:42:48 <carter> it means if someone else does it they're happy to help guide em,
21:42:58 <carter> tabemann theres SO FEW people on ghc core team
21:43:15 <carter> that they have an infinite list of "that'd be cool, but we dont physically have time :( "
21:43:16 <carter> tickets
21:43:22 <enthropy> and there's SO MUCH syntax already
21:43:51 <carter> yeah
21:43:57 <carter> well
21:44:14 <carter> the real problem is  adding it while not making syntax errors harder to undrstand
21:44:38 <enthropy> well normally people won't specify -XOrPatterns
21:45:01 <tabemann> except probably former MLers wo miss them
21:45:04 <tabemann> s/wo/who
21:45:08 <scshunt> "there's a quasiquoter for X" is usually scary :P
21:47:44 <enthropy> dibblego: https://gist.github.com/aavogt/6110301 is a follow up if there was a class for filtering
21:50:53 <tabemann> for some reason I'm tempted to learn Template Haskell, but then there's another part of me that thinks that "if I really need TH to do that, it's probably a bad idea"
21:51:04 <carter> depends on the goals
21:53:08 <tabemann> just the idea that you can actually change syntax without being a Lisp (or doing stuff involving compiler extensions, as in Camlp4 for OCaml)
21:53:56 <liyang> Is xmonad-contrib still Darcs-only or can I submit patches via git these days?
21:54:12 <Ralith> tabemann: that shouldn't be a surprise at all
21:54:22 <carter> ok, i'm off
21:54:24 <liyang> Perhaps I should ask in #xmonad. Nevermind.
21:54:24 <carter> night all
21:54:46 <Ralith> it adequately demonstrates the reason why people like metaprogramming in lisp, too
21:55:18 <scshunt> TH is pretty damn cool and fun
21:56:22 <tabemann> the only thing is that I've seen some uses of TH, and it doesn't always *look* like Haskell syntactically
21:56:49 <scshunt> You've probably seen quasiquoters, which are only one part of TH
21:57:06 <scshunt> things in [|oxford brackets|]?
21:57:17 <tabemann> no, it wasn't that, actually
21:57:28 <scshunt> oh?
21:57:35 <mgsloan> TH is definitely a lot of fun.  I do wish the syntax looked more distinctive / was less error prone
21:57:50 <tabemann> well, it could have been, as I didn't see the TH itself but the code the TH was applied to
21:58:35 <mgsloan> $() is a valid fragment of haskell 98 syntax, and [x| x <- [1..10] |] is one character away from being a list comprehension
21:58:44 <scshunt> hah
21:58:46 <scshunt> true
21:58:47 <mgsloan> and allowing naked expressions to be top level splices is awful
21:58:54 <scshunt> yeah, that's a poor feature
21:58:55 <zRecursive> @where xmonad
21:58:55 <lambdabot> #xmonad | http://xmonad.org/
21:59:27 <mgsloan> In general, TH is awesome sauce that's marred by a few bits of ugly
21:59:53 <enthropy> mgsloan: I disagree. Top level splices don't conflict at all unlike quotes/splices
22:00:30 <mgsloan> enthropy: Sure, but if you accidentally introduce a splice, it splits your file into two compilation units
22:00:41 <mgsloan> So, you can end up with a bunch of scope errors in the first half of your file
22:00:55 <mgsloan> and it's a total mystery that it's due to accidentally introducing a splice in the middle
22:01:34 <tabemann> okay, need to stop implementing Scheme and go to bed now...
22:01:40 <mgsloan> Also, this means that we'll never be able to have any new syntax that would be ambiguous with top level expressions.  E.g. no variants that look like definitionless "data" / "newtype" / "type"
22:02:35 <mgsloan> If "data" were a new thing, then we wouldn't be able to add "data Foo" without the risk of it disallowing some top level splice expression
22:02:40 <SrPx>  <SrPx> I've been so confused the last months. I read so much, yet nothing answers the question. After all, which is The one language? The language in which the universe was programmed in? The truest, purest, cleanest of them all? Is it Scheme, or is it Haskell? Oh life
22:02:50 <mgsloan> Then again, I guess that's just the risk of adding new keywords
22:02:51 <scshunt> mgsloan: what do you mean it splits the file?
22:04:33 <tabemann> SrPx: Haskell obviously. as for Scheme, that's something you implement in Haskell to use as a scripting language
22:04:37 <mgsloan> scshunt: TH splices run after (well, inside) type checking, so they can rely on definitions that come before it in the file
22:05:07 <scshunt> mgsloan: ah
22:05:13 <mgsloan> scshunt: TH quasiquotes, on the other hand, aren't allowed to rely on definitions that come before in the file, and are run in the renamer.  This means that they don't split up the compilation of the file
22:05:27 <scshunt> right, the staging restriction
22:05:30 <SrPx> tabemann: why Haskell? It seems so pure/simple but at the same time so complex
22:05:58 <tac> oh hey SrPx
22:06:00 <SrPx> tabemann: you know? Not being able to metaprogram as much, and all. I mean, genetic algorithms... playing with syntax trees... that sounds so yes
22:06:04 <SrPx> tac:
22:06:08 <SrPx> tac: hey !
22:06:14 <tabemann> SrPx: well, one of the nice things about Scheme *is* that it is simple... except for doing real work with it, where then it often feels too simple
22:06:15 <mgsloan> scshunt: It gets a bit confusing - the staging restriction is instead about whether you can run code from this module in a splice (you can't)
22:06:29 <tabemann> it at least makes it easy to implement in a reasonable amount of time
22:06:34 <tac> (If life was written in Scheme, there'd be a lot more bugs)
22:06:38 <scshunt> mgsloan: oh, I get it, ok
22:07:03 <tabemann> tac: yes, static typing is nice for making sure your code is actually correct
22:07:11 <tabemann> whereas Scheme has the problem that all dynamic languages have
22:07:17 <mgsloan> scshunt: Not sure if there's a good name for the compilation splitting thing.  There probably is one
22:08:09 <tabemann> need to go to bed now though
22:08:09 <SrPx> you are contracting yourself, you just said you would use scheme as a scripting language rather than haskell... which is the same as saying "it is easier to code in, yet not as fast". tabemann
22:08:23 <SrPx> tabemann: more than we have already?
22:08:27 <SrPx> tac: /\ *
22:08:34 <SrPx> tabemann: ):
22:08:59 <Ralith> tabemann: static typing is nice for ensuring your code is less likely to contain certain classes of error
22:09:02 <Ralith> that's different than correct
22:09:07 <tabemann> SrPx: it's more that for a scripting language you want something you can easily load at runtime and embed into the workings of running program; Haskell is a little too static for that
22:09:17 <tabemann> Ralith: well yes
22:10:24 <tac> The difficulty with static languages tends to be reflection. Dynamic languages are typically very good at reflection and metaprogramming compared to statically typed langs.
22:10:48 <SrPx> tabemann: that makes a lot of sense actually
22:11:08 <Ralith> tabemann: it's not that haskell is to static for that; rather, haskell doesn't have refined tools for that.
22:11:10 <SrPx> tac: so my worry about genetic programming on haskell is valid
22:11:41 <tac> genetic programming? Like AI?
22:11:44 <zzing> When I do something like  fromRational (1 % 10)  and it is of type Fractional a => a, what type is a?
22:12:06 <tabemann> I'm largely implementing a Scheme, though, simply because it is a simple language to implement, even with the additions in, say, R7RS-small versus R5RS
22:12:08 <SrPx> tac: but that only makes me think dynamic is more powerful than static. there is no downside to dynamic in relationship to static... other than performance. but I believe performance has too much influence on our current hardware... so... well
22:12:16 <thoughtpolice> zzing: it is a type variable. 'a' can be anything that is an instance of Fractional
22:12:39 <thoughtpolice> zzing: in a similar way, the literal '1' by itself has a type like Num a => a (try it for yourself in GHCi)
22:12:40 <SrPx> tac: in a platonic world maybe scheme is more powerful than haskell, after all
22:12:57 <zzing> thoughtpolice, I know that it is a type variable - I would have assumed it would eventually have a real type
22:13:03 <tabemann> there's some things that static makes simpler, like pattern matching (how can you have an exhaustive pattern match, without lots of catch-alls, if something could be of any type, and any type could be subtyped indefinitely?)
22:13:06 <tac> SrPx: It's a complicated world. Static typing is, in a literal sense, more restrictive to program in. However, that restriction imposed on you is also imposed on people making calls to you, so your restrictions are simultaneously your liberties.
22:13:09 <SrPx> tac: tabemann I'm sending the message to the wrong one of you, damn your nick with the same beginning
22:13:14 <SrPx> tac: but yes, AI
22:13:17 <Gracenotes> @type 0.1  -- the above expression is equivalent to this
22:13:17 <lambdabot> Fractional a => a
22:13:43 <tac> The notable thing about lisps (including scheme) are they are homoiconic. Meaning they are very easy to write, because the parser is a no-brainer.
22:14:03 <thoughtpolice> zzing: it will have a type when you use it at a call site. it's resolved there. like i said, similarly '1 :: Num a => a', and that means that '1' can be used where you need an Integer, an Int, a Word
22:14:13 <tabemann> okay, good night for real now
22:14:14 <tac> Haskell and the ML family focus more on the idea that types are important and help you do your job right.
22:14:21 <SrPx> tac: exactly! But I don't get what you say about "also imposed on people calling you..."
22:14:25 <SrPx> tabemann: night!
22:14:25 <zzing> ok
22:14:53 <tac> SrPx: Have you done much programming before in any language?
22:15:41 <SrPx> tac: many i guess, why
22:15:45 <thoughtpolice> zzing: besides, 'Fractional a => a' is a 'real' type too, just a more general one than you may expect
22:15:53 <zzing> thoughtpolice, true
22:16:11 <tac> SrPx: There's a duality between the programmer who is writing a library or API.... and the programmer who is calling it.
22:16:57 <Gracenotes> (if you make a Fractional type Blah, and say 0.1 :: Blah, then you will take a 1%10 and make it into a Blah)
22:17:04 <SrPx> tac: so you are talking about the fact it makes code more uniform, well I know, but that seems like just something useful for humans
22:17:12 <tac> They "two opponents in a game". The caller (library caller) and the callee (library writer).
22:17:26 <nbouscal> The whole point is being useful for humans, otherwise we'd write in binary
22:17:53 <SrPx> tac yes
22:18:10 <tac> The caller wants to make sure certain things are true of the return value of the API. And his responsibility is that he must provide the correct inputs.
22:18:33 <tac> The callee wants to make sure the caller passed the correct inputs in, and is responsible for providing the correct return value.
22:18:40 <tac> Types help enforce that.
22:18:41 <nbouscal> Basically the idea is that reasoning about code is difficult regardless. When you can provide restrictions that don't limit the expressiveness or power of the language but that do make reasoning about code in that language easier, those restrictions are beneficial. Hence static typing and purity.
22:18:49 <thoughtpolice> is it even sensible to talk about 'restrictive.' how do you formulate something like 'foo :: Bar a => Int -> Bool -> a' in a dynamic language, where the return value depends on the type of the context it is used?
22:18:52 <zzing> Is there any way of enforcing a constraint like given a function base :: Domain -> Ratio Int where Domain is { Infected, NotInfected } that the sum of the base function over all its domains is 1
22:19:04 <dibblego> enthropy: thanks, I will look — partition is recoverable from traverse (fmap) right?
22:19:06 <thoughtpolice> s/return value/return type/
22:20:46 <enthropy> dibblego: I don't think traverse is allowed to filter out elements
22:20:51 <Gracenotes> zzing: hm, well, you can define it for n-1 domains, and require the sum of those to be <=1 (not enforceable, but a bit better)
22:21:11 <dibblego> enthropy: ah good point
22:21:12 <Gracenotes> not computationally friendly for the victim domain
22:21:26 <SrPx> nbouscal: that makes a lot of sense, but I then say I see Haskell as a halfway between Scheme and the true language. Because you can't determine if two functions are equivalent in haskell, which would be the limit of "easiness" to reason about the code
22:21:27 <Gracenotes> Not sure what { Infected, NotInfected } signifies in Haskell terms
22:21:43 <zzing>  > data Domain = Infected | NotInfected
22:21:55 <nbouscal> SrPx: I think it's far, far too early in the history of computer science for us to be anywhere near a 'true language' as you've defined it.
22:21:56 <dibblego> enthropy: I was thinking partition x = (fmap lefts x, fmap rights x)
22:22:05 <SrPx> am I making sense? If you can't determine wether two functions are equivalent then you are missing a ridiculous amount of optimization oportunities
22:22:07 <zzing> Gracenotes, unfortunate :p. I assume I would need to use agda for such a requirement.
22:22:50 <nbouscal> SrPx: You're making sense, though I'd disagree that determining equivalency of functions is anywhere near the limit of ability to reason about code
22:22:57 <nbouscal> We can go a lot farther than that, I think.
22:23:12 <SrPx> nbouscal: ): but then you are saying scheme/lambda calculus will always be what they are... while haskell will be replaced by a more mathematically correct language
22:23:22 <SrPx> nbouscal: what would it be
22:24:05 <SrPx> tac: hi?
22:24:24 <tac> SrPx: Not to throw something too advanced at you, but that's essentially what Coq, Agda, and Idris are. They are languages whose type systems are so powerful, they double as theorem provers.
22:24:25 <nbouscal> You're essentially asking me to predict future developments in mathematics. If I could do that, I would go collect my PhD ;-)
22:25:15 <zzing> tac, and isn't Idris meant to be useful for systems programming?
22:25:35 <SrPx> tac: I've read something about those... maybe it is time to go for it... but I wonder if I'll waste my time just to find a "better haskell" but still not what I'm looking for
22:25:36 <tac> Also, the whole "you can't compare two functions" is only true for arbitrary functions. If you have access to a syntactic representation of your functions (ie: you have the source code), there are lots of partial optimizations you can apply.
22:25:42 <tac> zzing: yep.
22:25:53 <tac> SrPx: What are you looking for?
22:26:04 <nbouscal> SrPx: I think that the Lisp family and the ML family both have a lot to offer. Neither are anywhere near the platonic ideal of a programming language though, we have a long way to go yet.
22:26:17 <SrPx> tac: the truest/purest/cleanest programming language, there is not really a word but I guess you understand what I mean
22:26:31 <tac> Ah. Gotcha
22:27:09 <nbouscal> I'm not necessarily convinced that there is a platonic ideal of a programming language in general, anyway. The argument that different languages are good for different things gets abused to defend bad languages a lot, but there is a lot of truth to it.
22:27:10 <dibblego> enthropy: scratch that, lefts/rights is not sensible
22:27:18 <tac> Well, Scheme is probably the easiest to break into. My personal feeling is that scheme is worth knowing and studying for a bit, but typed programming is where all the interesting research happens.
22:27:29 <SrPx> nbouscal: why
22:27:31 <tac> But for sure, learn to program a Scheme interpreter.
22:27:44 <dibblego> I was thinking Either (f a) (f b) -> f (Either a b)
22:27:44 <SrPx> tac: I have made one actually
22:27:48 <tac> neat
22:27:52 <SrPx> :l
22:28:09 <SrPx> not a great achievement actually but yea
22:28:10 <nbouscal> SrPx: The same reason that there exists specialized jargon in every scientific field. Different disciplines make use of different concepts and categories, and the job of a language is to represent those concepts and categories precisely and efficiently.
22:28:12 <tac> Haskell and ML are good introductions to typed languages. ML is a little easier, IMO, but Haskell is purer, and has a much deeper rabbit hole to go down.
22:28:19 <Gracenotes> zzing: also, if there are a discrete number of domains or whatnot, you can use types to achieve safety
22:28:39 <Gracenotes> 'you may only construct a foo if you pass it through my picky function'
22:28:40 <thoughtpolice> tac: are you talking about PLT research? then sure. otherwise there's been quite a lot of research invested in dynamic languages. hell, Javascript has seen more optimization work in the past like 5 years than most languages ever see
22:29:04 <tac> Agda and Coq are lots of fun, but literally no one programs in them. There's a joke that they never run their programs. (And while I've written a lot of Agda, I have never actually run any of it)
22:29:24 <thoughtpolice> so i don't think it's fair to say the interesting research "only" happens there (granted a lot of the initial JS work was born from the fruits of Smalltalk, Dylan, etc, but this stuff didn't exactly stop)
22:29:29 <tac> thoughtpolice: I'm only giving the half of the story I know how to give :) If you have other opinions, please express them.
22:29:42 <zzing> tac, Agda is missing a few useful things though - I don't think it even has rationals
22:29:43 <enthropy> dibblego: I think with  newtype M f a = M (f (Maybe a)); instance Traversable f => Traversable (M f) -- might be possible & can fake the filtering out of elements
22:29:57 <tac> zzing: I'm sure *someone* has written a rationals lib for it at some point.
22:30:03 <nbouscal> I've never used Agda but rationals are pretty darn easy to implement
22:30:05 <enthropy> as in there will still be a leaf in the tree, but there will be a Nothing
22:30:15 <SrPx> tac: oh, a brief incorrect history of pls ...
22:30:17 <tac> Although I've tried.... without quotient types, writing even the integers is a PITA.
22:30:19 <zzing> tac, now write a real number lib for it :p
22:30:20 <nbouscal> I mean, that was an early assignment in the Coursera programming languages course and that course wasn't even very hard
22:30:39 <SrPx> nbouscal: well i dont know what to thing about htat
22:30:40 <tac> zzing: bakibour in #idris is trying to figure that out right now actually :)
22:30:52 <zzing> tac, a real lib?
22:30:56 <tac> Yeah
22:31:01 <tac> He was asking about it.
22:31:20 <zzing> Couldn't somebody do an IEEE754 lib? I would think it would be well defined enoguh
22:31:31 <thoughtpolice> tac: well, it's a slightly dissenting opinion i guess. even then, the term 'PLT' also somewhat lends itself to thinking 'types types types' IMO, where really it's a bit more broad than that
22:31:35 <nbouscal> SrPx: I've done entirely too much thinking about it, myself :P
22:31:37 <thoughtpolice> i'm as guilty of this as anyone i guess
22:31:52 <tac> thoughtpolice: Like I said. I have a narrow view on the world :P
22:31:56 <nbouscal> SrPx: If your interested in that area of thought, I'm currently reading Hofstadter's latest book, Surfaces and Essences, and it is all about that and quite good.
22:32:03 <tac> For more applied stuff, for sure, there's a lot more research done on languages that see the light of day.
22:32:11 <zzing> Gracenotes, I do have something I would have to write a smart constructor for
22:32:18 <SrPx> nbouscal: hey thanks for that!
22:32:24 <dibblego> enthropy: you mean to recover, partition :: Traversable f => f (Either a b) -> (f a, f b) ?
22:32:42 <tac> Though I think I would stick to saying there hasn't been *as much* on 'language design' in particular.
22:32:50 <SrPx> I'm actually saving the log of this channel today, great stuff
22:33:05 <thoughtpolice> tac: i think PLT stuff does influence 'real world' today, i guess my only critique is the notion "only interesting research happens with types."
22:33:07 <Gracenotes> SrPx: see also topic
22:33:11 <enthropy> dibblego: yes
22:33:18 <enthropy> but let's see if that actually works out
22:33:27 <thoughtpolice> and i know that's not exactly what you were saying, but yeah :P
22:33:48 <SrPx> Gracenotes: (:
22:33:52 <nbouscal> PLT influences real world at a lag of 10 years and through a game of telephone
22:33:54 <tac> (thoughtpolice: knowing me, it probably was :P)
22:34:07 <tac> nbouscal: I like that :P
22:34:38 <nbouscal> like PHP having "closures", aka you can explicitly pass scope into anonymous functions. but only anonymous functions, not named ones.
22:34:39 <thoughtpolice> tac: also, as a case example of the extreme, IMO LuaJIT has got to be worthy of some kind of award in compiler/PLT theory or something, at least.
22:35:11 <nbouscal> and you have to name every variable you want to pass in, otherwise it will just create a new one with the same name and a value of undefined
22:35:40 <tac> Anyway, SrPx, there are lots of beautiful languages. Why pick one?
22:35:45 <nbouscal> hear hear!
22:35:53 <SrPx> thoughtpolice: why people keep saying it is so great?
22:35:57 <nbouscal> Programming in only one language is no fun at all
22:36:05 <tac> (Besides, we all know it will be Homotopy type theory once someone figures out how to compute univalence xD)
22:36:22 <nbouscal> I really need to stop putting off reading that book
22:36:28 <nbouscal> I'm not even through chapter one yet
22:36:53 <zRecursive> in fact C is the most great language. The word is constructed by C
22:36:56 <SrPx> tac: not pick, I don't know... I can absolutely box many language concepts of dozens of languages as just stupid ways to express something which is actually very clever and correct in scheme or haskell, generally
22:37:03 * tac got distracted from reading it by more classical math stuff.
22:37:15 <SrPx> tac: I just want to know which is the language which gets it all right
22:37:18 * hackagebot minioperational 0.4 - fast and simple operational monad  http://hackage.haskell.org/package/minioperational-0.4 (FumiakiKinoshita)
22:37:27 <dibblego> enthropy: I am finding some previous discussion on this
22:37:33 <tac> SrPx: None of them do. All languages have problems.
22:37:41 <nbouscal> Hehe yeah, all languages are written by humans
22:37:41 <SrPx> tac: of today
22:37:45 <tac> Both social and design.
22:38:05 <SrPx> tac: don't care about social problems on this one
22:38:14 <thoughtpolice> SrPx: it's mostly off topic here, but LJ2 has an extremely novel design, it is well implemented, and it basically still sets a benchmark for dynamic languages.
22:38:14 <zRecursive> I donot think any languages can beyond C in the future
22:38:19 <nbouscal> As it turns out social concerns tend to predominate in the success of programming languages
22:38:22 <tac> Haskell has a pretty active community. Obviously, it's (one of) my choices.
22:38:23 <SrPx> zRecursive: :/
22:38:38 <thoughtpolice> it is essentially the cumulative effort of decades of research, done by one individual.
22:38:52 <tac> I'm a big advocate for "dependently typed" languages (Agda, Coq, etc), but they aren't at the maturity yet where you can write useful programs with yet.
22:39:31 <scshunt> I think dependently typed languages are possibly too powerful a tool to be practical generally
22:39:33 <tac> and even with them, there's technical issues that become really annoying
22:39:51 <tac> scshunt: in the grand scheme of things... yeah... you'll never use them at a corporation.
22:39:54 <SrPx> tac: but things such as communities and social problems change with time ... those don't mean anything for the truth
22:40:09 <tac> Maybe for scientific programming though. Certainly for mathematical and CS research.
22:40:09 <SrPx> tac: which?
22:40:19 <SrPx> scshunt: that doesnt make any sense
22:40:21 <scshunt> Haskell is nearly there, and it's only really with  things like template haskell to reduce the boilerplate and a number of other hacks in various cases that the language can be practical
22:40:58 <scshunt> SrPx: the more complex an interface, the harder it is to use correctly
22:41:05 <SrPx> also I don't get how people say some languages are not practical. I have implemented most of the stuff I use in javascript using lambda calculus, and well I'm pretty sure I've developed some practical stuff with js
22:41:09 <enthropy> there's the issue that there are 50 ways to do records and generics
22:41:11 <tac> Haskell is very close to being practical. But I feel there's too much baggage and stigma associated with the language itself. But if someone created an F#-looking language that was just reskinned Haskell.... I think it would do very well.
22:41:24 <scshunt> dependently typed lanugages have an exceedingly complex interface with a corresponding difficulty in use
22:41:28 <tac> SrPx: It doesn't sound like you've ever had to write code with a deadline :P
22:41:48 <nbouscal> tac: I dunno, Haskell has been getting a ton of publicity on places like Hacker News, so it seems like some progress is being made on that front
22:42:01 <scshunt> certainly, modules like "template agda" would certainly help
22:42:03 <SrPx> tac: you are very mistaken ! /copy of megaman3 written in 5 days of lambdas with proud/
22:42:04 <nbouscal> A lot of people still think it's just for mathematicians, but at least a lot of people know about it now, that's better than the prior state of affairs
22:42:06 <scshunt> s/certainly, /
22:42:15 <SrPx> tac: viclib.com/mememan (:
22:42:39 <tac> nbouscal: I'm pretty sure talk of profunctors, monads, and _|_ are more than enough to keep haskell from ever "going mainstream" :)
22:42:49 <scshunt> monads aren't too bad
22:43:05 <tac> No, but they are a lesson in how to butcher something that isn't that hard.
22:43:06 <scshunt> I haven't a clue what a profunctor is and that isn't stopping me
22:43:09 <scshunt> and bottom isn't all that complicated
22:43:15 <scshunt> tac: that they are
22:43:32 <nbouscal> tac: Eh, I'm not sure about that. It's always a sliding scale, used to be recursion and closures were too complicated to ever go mainstream.
22:43:43 <roboguy_> sometimes I wonder how the barrier to entry for haskell could be lowered
22:43:48 <nbouscal> tac: Now it's monads, soon it'll be arrows, then it'll be whatever else
22:43:51 <SrPx> with pride* (i guess)
22:43:54 <tac> You end up with this weird thing where you get to be an architect astronaught *and* an obtuse mathematician __at the same time__~~~!
22:44:01 <dibblego> "mainstream" currently uses ideas that are overwhelmingly more complicated than monads or profunctors
22:44:03 <nbouscal> roboguy_: by getting people to shut up about monads probably :P
22:44:06 <SrPx> u.u
22:44:07 <scshunt> ^
22:44:17 <tac> I hold an unpopular opinion that monads aren't even the "right abstraction" for everyday programming.
22:44:29 <SrPx> tac: tell me more (:
22:44:48 <roboguy_> nbouscal: that would probably help
22:44:51 <tac> No, SrPx. I won't tell you that. If you're a beginner, you don't need to hear my unpopular rant!
22:45:09 <tac> dibblego: true fact!
22:45:15 <dibblego> tac: is it really unpopular? I find it to be a popular opinion among those who are acutely aware of other abstractions and so come to some (same) conclusion
22:45:29 <SrPx> tac: ... a beginner in what? We all are beginners in many things I guess... anyway yes I do
22:45:37 <tac> I'm not in favor of algebraic effects either.
22:45:49 <scshunt> tac: algebraic effets?
22:45:52 <tac> Yeah
22:45:53 <scshunt> *effects
22:45:59 <joelteon> why does usage of ghc-mod from ghci or runghc cause a crash?
22:46:03 <tac> http://math.andrej.com/2012/03/08/programming-with-algebraic-effects-and-handlers/
22:46:04 <joelteon> but not from a compiled program?
22:46:28 <tac> I think what people *really* need most of the time is a simple way to thread their state and nothing more.
22:46:53 <tac> They don't need continuation passing or backtracking or parser effects 95% of the time
22:47:09 <tac> When they do, monads should be an option, for sure!
22:47:12 <tac> monads are a good thing
22:47:28 <SrPx> hmm
22:47:30 <tac> But most mundane programming has much more mundane needs.
22:48:05 <scshunt> tac: ah, yes, I will agree with you in principle there
22:49:07 <tac> ok. Well that was fun, but I should have gone to bed an hour ago
22:49:13 <nbouscal> ugh, ditto
22:49:14 <tac> Have a good night everyone!
22:49:21 <nbouscal> night all
22:49:23 <scshunt> still, I feel that the monad is a solid abstraction for IO (and other magical operations like Q or ST
22:49:27 <scshunt> )
22:49:35 <scshunt> good night
22:49:43 <zRecursive> afternoon
22:51:49 <Hafydd> What is Q?
22:52:04 <Hafydd> instance Monad Ratio where
22:52:25 <roboguy_> shanse: for some IO stuff, Functor or Applicative is enough though. but yeah, Monad can be good for that sometimes
22:53:16 <roboguy_> err, scshunt ^
22:53:43 <SrPx> tac: hey wait!
22:53:47 <SrPx> oh
22:53:48 <SrPx> well
22:53:50 <scshunt> Hafydd: the monad for template haskell
22:54:07 <Hafydd> Ah. Why is it called Q?
22:54:13 <scshunt> for "quote" I believe
22:54:17 <CADD> for quote
22:54:18 <zzing> Hafydd, rationals are called Q
22:54:19 <Hafydd> Ah.
22:54:39 <zzing> If that is related to what you said above
22:54:40 <scshunt> a splice is run in Q; the code can run IO as well as inspect the program at the splice
22:54:44 <scshunt> (declarations in scope, for instance)
22:55:00 <zzing> I must gain an intuitive understanding of these typeclasses and abstract algebra.
22:55:32 <CADD> zzing: http://www.amazon.com/Book-Abstract-Algebra-Edition-Mathematics/dp/0486474178/ref=sr_1_2?ie=UTF8&qid=1375163696&sr=8-2&keywords=abstract+algebra
22:57:03 <zzing> CADD, do you have this book personally?
22:58:04 <zzing> It is definitely a good price. It has more than the Fraleigh book I have
22:58:07 <CADD> zzing: yes
22:58:10 <CADD> my personal favorite introduction on the subject.
22:58:26 <CADD> would recommend hands down
22:58:58 <zzing> I have the fourth edition of this book: http://www.amazon.com/First-Course-Abstract-Algebra-Edition/dp/0201763907/ref=sr_1_1?ie=UTF8&qid=1375163894&sr=8-1&keywords=a+first+course+in+abstract+algebra     although it is borrowed
22:59:09 <zzing> Certainly different prices :P
22:59:21 <johnw> you can get the 6th edition of that, used, for <$10
22:59:23 <CADD> hmm, never heard of it
22:59:26 <johnw> that's what I read
22:59:29 <CADD> nice
22:59:45 <CADD> there is also a wikibook
22:59:55 <johnw> where?
23:00:05 <CADD> https://en.wikibooks.org/wiki/Abstract_algebra
23:00:06 <zzing> If I understood this stuff, would the typeclasses become clearer?
23:00:20 <CADD> no
23:00:38 <CADD> typclasses are a type theoretical construct
23:00:41 <zzing> I feel that I should become better at this stuff anyways
23:00:52 <CADD> although abstract algebra is imperative to understand atleast superficailly
23:02:21 <zzing> I will be looking more at the typeclassopedia tomorrow
23:03:23 <CADD> yes, that is probably the only "monad tutorial" anyone should read. digest that and you will be well on your way.
23:04:08 <zzing> I love literate haskell
23:04:09 <roboguy_> does anyone have a link to that list of libraries that Haskell Center supports?
23:04:46 <CADD> roboguy_: you mean hackage?
23:05:05 <roboguy_> CADD: I don't think Haskell Center supports everything on hackage does it?
23:05:30 <CADD> roboguy_: what is Haskell Center?
23:05:34 <roboguy_> oh wait I found it
23:05:38 <Gracenotes> applicative is just multi-argument functor. both functor and applicative have a fixed computational 'skeleton' based on the particular instance. monads, you choose your own 'skeleton' based on intermediate results.
23:06:03 <Gracenotes> it's not necessary to understand how these things work theoretically... how they work computationally is cooler, anyway, in a lot of cases.
23:06:04 <roboguy_> CADD: it's a web-based IDE for haskell: http://www.youtube.com/watch?v=cyyDmQKcHMs
23:06:14 <CADD> roboguy_: oh cool, thanks!
23:06:29 <zRecursive> what are "bit operations" function in Haskell ?
23:06:39 <roboguy_> CADD: they just opened up the beta recently and I think I'm going to give it a shot. it's an interesting idea
23:06:55 <CADD> roboguy_: ohh, its fpcompletes new ide
23:07:03 <roboguy_> CADD: yeah
23:07:17 <CADD> roboguy_: ok, yeah i heard a tiny bit about that. well best of luck!
23:07:23 <roboguy_> thanks!
23:07:48 <zRecursive> @hoogle bit shift
23:07:49 <lambdabot> GHC.Constants bITMAP_BITS_SHIFT :: Int
23:08:57 <mgsloan> roboguy_: Here's a list: http://haddocks.fpcomplete.com/fp/7.4.2/20130704-120/
23:09:07 <zRecursive> @package Data.Bits
23:09:07 <lambdabot> http://hackage.haskell.org/package/Data.Bits
23:09:21 <roboguy_> mgsloan: cool, thanks!
23:09:34 <mgsloan> welcome!
23:09:39 <zzing> Is there a simpler way to define this?    > data Opinion = Opinion (Ratio a) (Ratio a) (Ratio a) (Ratio a)
23:10:14 <Hafydd> type Opinion = (Ratio a, Ratio a, Ratio a, Ratio a)
23:11:04 <Hafydd> but I suppose you might want the type safety.
23:11:08 <zzing> I do
23:11:17 <Gracenotes> zzing: that's quite a good way. maybe make them strict.
23:11:23 <roboguy_> mgsloan: one thing I was wondering was, does Haskell Center support any GUI libraries? maybe that wouldn't quite make sense for their model, though
23:11:33 <Gracenotes> add names, if they are significantly distinct.
23:11:54 <zzing> Gracenotes, they each are numbers with specific meanings
23:12:00 <zzing> But related to each other
23:12:13 <mgsloan> roboguy_: Not currently.  However, web based UIs are possible
23:12:14 <zzing> For example, belief + disbelief <= 1
23:13:09 <Gracenotes> zzing: also, what's a?
23:13:39 <zzing> Gracenotes, don't really care what it is yet
23:13:49 <zzing> Gracenotes, right now I don't care what the final type of a is, although I would love a shorter way to refer to Ratio a
23:14:22 <Gracenotes> Rational is Ratio Integer
23:14:26 <mgsloan> roboguy_: There's nothing stopping the APIs for UI frameworks being supported - that would at least allow for the IDE to be used to write the code - however, running desktop applications wouldn't be supoprted
23:15:20 <zzing> Not a bad start
23:15:23 <Gracenotes> as long as you're only using it as a rational number (not a real number-y stuff), it should be fine
23:15:56 <zzing> Gracenotes, right now I am using it to avoid real numbers and make it easier to specify stuff that can add up to 1 with certainty
23:16:16 <Gracenotes> data Opinion = Opinion { foo :: !Rational, bar :: !Rational, ... }
23:16:55 <roboguy_> mgsloan: yeah that makes sense. I think the ide is a cool idea overall. still a few issues to work out, but it's pretty nice and it looks like it has a lot of potential
23:17:06 <Gracenotes> (although, avoid the '!' if you're writing more than you're reading)
23:17:24 <zzing> Was the ! for strictness?
23:17:36 <edwardk> preflex: xseen refold
23:17:38 <preflex>  refold was last seen on freenode/#ghc 19 days, 4 hours, 52 minutes and 56 seconds ago, saying: ?
23:18:23 <Gracenotes> zzing: yes... probably safe here, although certainly depends
23:18:33 <roboguy_> Gracenotes: hah, I know some people like that
23:19:19 <mgsloan> roboguy_: Cool, I'm glad you like it!  If you feel like filing some feedback for those issues, that's always appreciated, too!
23:19:43 <enthropy> edwardk: is there a typeclass for structures you can filter? Sort of like     Traversable t => (t :+: Maybe);   newtype (:+:) f g a = Compose {decompose :: f (g a)}
23:19:59 <enthropy> except that it doesn't have to carry around the empty values
23:20:05 <roboguy_> mgsloan: sure, I might do that sometime! are you on the team or just an enthusiast?
23:20:23 <mgsloan> roboguy_: On the team! :D
23:20:39 <roboguy_> mgsloan: cool!
23:22:23 <zRecursive> :t (***)
23:22:26 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
23:22:59 <edwardk> enthropy: i never bothered to bundle one. i have used that kind of class in my own code though: class Functor f => Filterable f where filterMap :: (a -> Maybe b) -> f a -> f b; filter :: (a -> Bool) -> f a -> f a; with default definitions back and forth
23:23:36 <zzing> Haskell doesn't have an if syntax for conditional execution after an expression does it?    (eg.    f x = x^2 if x > 1    -- from miranda :P)
23:24:25 <zRecursive> @let f x | x > 1 = x ^ 2
23:24:27 <lambdabot>  Defined.
23:24:49 <zRecursive> > f 100
23:24:50 <lambdabot>   Ambiguous occurrence `f'
23:24:51 <lambdabot>  It could refer to either `L.f', defined at L.hs:1...
23:35:57 <c_wraith> What's the state of type-level naturals in ghc?
23:49:04 <c_wraith> hmm.  I guess "Kind mis-match    The first argument of a tuple should have kind `*',    but `10' has kind `Nat'    In a type in a GHCi command: (10, 12, 23)" is the current state.
23:49:35 <c_wraith> of DataKinds in general
