00:03:40 <statusfailed> edwardk: well it seems to be a pretty good philosophy, although I've got to admit some of the more arcane stuff is beyond me :)
00:07:51 <edwardk> its admittedly a library you grow into
00:09:01 <otters> what's the best way to take a list (Eq a, Monoid b) => [(a,b)] and merge all the "b"s where the "a"s are identical?
00:09:20 <otters> like foo [(1,"a"),(1,"b"),(2,"c")] == [(1,"ab"),(2,"c")]
00:09:45 <edwardk> :t M.fromListWith mappend
00:09:47 <lambdabot> (Ord k, Monoid a) => [(k, a)] -> M.Map k a
00:09:55 <c_wraith> and then a toList
00:10:01 <edwardk> :t M.toList . M.fromListWith mappend
00:10:03 <lambdabot> (Ord k, Monoid a) => [(k, a)] -> [(k, a)]
00:10:15 <edwardk> :t M.toList . M.fromListWith mappend $ [(1,"a"),(1,"b"),(2,"c")]
00:10:18 <lambdabot> (Num k, Ord k) => [(k, [Char])]
00:10:22 <edwardk> > M.toList . M.fromListWith mappend $ [(1,"a"),(1,"b"),(2,"c")]
00:10:25 <lambdabot>   [(1,"ba"),(2,"c")]
00:10:37 <otters> M is Data.Map?
00:10:40 <c_wraith> yes
00:10:42 <edwardk> > M.toList . M.fromListWith (flip mappend) $ [(1,"a"),(1,"b"),(2,"c")]
00:10:45 <lambdabot>   [(1,"ab"),(2,"c")]
00:10:53 <c_wraith> oh, weird
00:11:02 <c_wraith> Why does fromListWith use that argument order?
00:11:10 * edwardk shrugs
00:11:26 <edwardk> it isn't changing in this lifetime ;)
00:11:43 <c_wraith> It probably makes sense in some contexts
00:19:13 <Maxdamantus> In `let slowid = foldl (.) id [id | _ <- [1..4000000]] in (slowid 4, slowid "4")`, is `slowid` guaranteed to only be calculated once?
00:20:30 <Maxdamantus> Hmm .. seems odd that the monomorphism restriction doesn't appear to apply there.
00:21:42 <Maxdamantus> afk
00:26:22 <adnap> I want to write...
00:26:35 <adnap> > :t not . (&&)
00:26:37 <lambdabot>   <hint>:1:1: parse error on input `:'
00:26:42 <adnap> :t not . (&&)
00:26:43 <lambdabot>     Couldn't match expected type `Bool' with actual type `Bool -> Bool'
00:26:43 <lambdabot>     Expected type: Bool -> Bool
00:26:44 <lambdabot>       Actual type: Bool -> Bool -> Bool
00:27:47 <statusfailed> adnap: (not . ) . (&&)
00:28:23 <basdirks> > let (.:) = (.).(.) in (not .: (&&)) True True
00:28:25 <lambdabot>   False
00:28:46 <basdirks> (not suggesting you use that) =p
00:29:10 <Nisstyre-laptop> > not `on` (&&) $ True True
00:29:12 <lambdabot>   Precedence parsing error
00:29:12 <lambdabot>      cannot mix `Data.Function.on' [infixl 0] and ...
00:29:26 <Nisstyre-laptop> > (not `on` (&&)) True True
00:29:28 <lambdabot>   Couldn't match expected type `GHC.Types.Bool -> c0'
00:29:28 <lambdabot>              with actua...
00:29:38 <Nisstyre-laptop> oops
00:29:43 <adnap> statusfailed: Why do I have to do that? It seems like the problem is associativity
00:29:48 <Nisstyre-laptop> > ((&&) `on` not) True True
00:29:50 <lambdabot>   False
00:29:59 <Nisstyre-laptop> > ((&&) `on` not) False False
00:30:00 <adnap> :t on
00:30:01 <lambdabot>   True
00:30:01 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
00:31:03 <Nisstyre-laptop> adnap: does that solve your problem?
00:31:11 <Nisstyre-laptop> Data.Function.on is useful sometimes
00:31:15 <basdirks> @pl \x y -> not (x && y)
00:31:15 <lambdabot> (not .) . (&&)
00:31:44 <adnap> Nisstyre-laptop: It looks like it takes the second function and uses it to create args for the first, but that's not obvious without looking at the type signature of "on"
00:31:55 <Mortchek> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
00:31:55 <lambdabot> f a b c _ = a (b c) (b c)
00:32:00 <Mortchek> Silly djinn.
00:32:31 <Nisstyre-laptop> adnap: it applies the rhs to both parameters of the lhs
00:32:44 <adnap> Is that right? I guessed f a b c d = a (b c) (b d)
00:32:56 <Mortchek> That's my guess.
00:33:00 <Mortchek> +too
00:33:27 <Mortchek> I was curious if djinn would guess that as well, but evidently not.
00:33:32 <adnap> That's not what I want anyway
00:33:42 <adnap> I want not (a && b)
00:33:54 <adnap> What statusfailed did
00:34:07 <adnap> I don't want (not a && not b)
00:35:17 <Nisstyre-laptop> adnap: then you want (not .) . (&&)
00:38:19 <basdirks> f (g x y) is not (f . g) x y.
00:39:30 <basdirks> the latter is f (g (x y))
00:43:29 <Mortchek> That'd be (f . g) (x y). (f . g) x y is (\w -> f (g w)) x y, or f (g x) y.
00:43:56 <basdirks> yeah
00:48:21 <adnap> When I try to combine all these IO calls into a one liner, it looks kind of gross: join $ (when .) . (&&) <$> (not . (== Press) <$> GLFW.getKey ESC) <*> (GLFW.getParam Opened) <*> (return $ loop es)
00:51:46 <adnap> I could do: die <- (&&) <$> ((== Press) <$> GLFW.getKey ESC) <*> (GLFW.getParam Opened)
00:51:52 <adnap> when (not die) (loop es)
00:52:01 <c_wraith> adnap: one-liners aren't necessary
00:52:52 <adnap> c_wraith: Yeah, but the only reason to break the line up and make temp variables is to make it more readable??
00:53:25 <c_wraith> adnap: sure. you can make almost any expression in haskell a one-liner. The reason not to is always readability
00:57:52 <statusfailed> edwardk: is there a generalised strength function in Control.Lens?
00:58:13 <statusfailed> i.e. strength l x = fmap (set l ?? x) (view l x)
00:58:51 <edwardk> :t \x -> fmap (set ?l ?? x) (view ?l x)
00:58:52 <lambdabot>     Couldn't match type `Mutator' with `Accessor (f0 a0)'
00:58:52 <lambdabot>     In the first argument of `view', namely `?l'
00:58:52 <lambdabot>     In the second argument of `fmap', namely `(view ?l x)'
00:58:53 <SamanthaD> adnap: why do you want to make all your IO thingies one-liners anyway?
00:58:55 <edwardk> :t \x -> fmap (set ?l ?? x) (view ?l' x)
00:58:56 <lambdabot> (?l::ASetter a1 b a2 a, ?l'::Getting (f a) a1 t (f a) b1, Functor f) => a1 -> f b
00:59:08 <statusfailed> edwardk: Lens s t (f a) a -> s -> f t
00:59:13 <statusfailed> is what I got
00:59:29 <statusfailed> (with the same lens)
00:59:45 <edwardk> :t \l x -> fmap (set (cloneLens l) ?? x) (view (cloneLens l) x)
00:59:46 <lambdabot> Functor f => ALens s t (f b) b -> s -> f t
01:00:39 <edwardk> :t sequenceOf
01:00:40 <lambdabot> LensLike (WrappedMonad m) s t (m b) b -> s -> m t
01:00:45 <edwardk> :t sequenceAOf
01:00:46 <lambdabot> LensLike f s t (f b) b -> s -> f t
01:00:53 <adnap> SamanthaD: It just seems silly to make a temp var to only use it once on the next line
01:00:53 <edwardk> there it is
01:00:55 <statusfailed> ooh
01:01:16 <fmap> @ty cloneLens
01:01:17 <adnap> SamanthaD: I would never do that in an imperative language
01:01:18 <lambdabot> Functor f => ALens s t a b -> (a -> f b) -> s -> f t
01:01:39 <edwardk> cloneLens takes a lens in completely monomorphic lens and 'makes it polymorphic again'
01:01:49 <edwardk> er in completely monomorphic form
01:02:02 <adnap> What is a lens?
01:02:21 <SamanthaD> adnap: Just remember that Haskell isn't actually an imperative language. You're not ACTUALLY creating a temporary variable.
01:02:29 <SamanthaD> adnap: You're creating a "thunk"
01:02:53 <edwardk> adnap: lens.github.com has a tutorial. talk: http://youtu.be/cefnmjtAolY?hd=1 slides: http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf
01:03:08 <adnap> SamanthaD: What is a "thunk?"
01:03:11 <edwardk> adnap: but the short version is that a lens is a getter and a setter smashed together into a first class object
01:03:13 <SamanthaD> adnap: ... and while I'm not an expert in how Haskell is compiled I'm 90% sure that thunk is created anyway
01:03:27 <SamanthaD> adnap: It's a promise that a given state will be evaluatable in the future
01:03:30 <edwardk> adnap: the lens package provides lenses and a few other things
01:03:45 <SamanthaD> adnap: sorry, that probably doesn't make much sense... I'll explain it better
01:04:03 <adnap> SamanthaD: Yeah, it doesn't. Can you explain it in the context of the IO code I posted?
01:04:28 * hackagebot language-haskell-extract 0.2.4 - Module to automatically extract functions from the local code.  http://hackage.haskell.org/package/language-haskell-extract-0.2.4 (OscarFinnsson)
01:04:30 <SamanthaD> adnap: It's much easier to explain it in terms of purely functional context and then you can apply it to IO
01:04:31 <statusfailed> edwardk: that's awesome, thanks :D
01:04:44 <statusfailed> and it's more general
01:04:44 <adnap> SamanthaD: You
01:04:44 <edwardk> statusfailed: note you can get the same thing another way
01:04:51 <edwardk> l id
01:04:54 <edwardk> for some lens l
01:04:55 <monochrom> a thunk is a name you use for something you don't understand. "my program is too fast / too slow. I don't know why. it must be thunks."
01:04:56 <edwardk> =)
01:05:00 <statusfailed> ... and the implementation is l id
01:05:01 <adnap> SamanthaD: You're saying x is not a "temp var" in x <- f\n g x
01:05:02 <edwardk> :t both id
01:05:04 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
01:05:12 <edwardk> :t _2 id
01:05:14 <lambdabot> (Functor f, Field2 s t (f b) b) => s -> f t
01:05:14 <monochrom> several hundred years ago, they used "ghost" for the same purpose
01:05:33 <SamanthaD> adnap: what I'm saying is that it's more like a pointer
01:05:37 <edwardk> statusfailed: yeah
01:05:45 <SamanthaD> adnap: sort of...
01:05:46 <statusfailed> that's nuts
01:05:50 <adnap> What about a "closure?"
01:06:00 <edwardk> statusfailed: welcome to lens ;)
01:06:05 <monochrom> I am serious. once you understand how a program works, you have expressions, not thunks.
01:06:22 <SamanthaD> adnap: Consider the expression x = 4 + sqrt 9
01:06:24 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml  no thunk
01:06:28 <adnap> Previously, I thought a "thunk" was just an unevaluated expression
01:06:36 <SamanthaD> adnap: sorry that's a bad example
01:08:13 <SamanthaD> adnap: Basically, the take home lesson is that in Haskell nothing is evaluated until a value is needed. In other words, while it IS a variable the variable doesn't actually CONTAIN anything.
01:08:19 <SamanthaD> adnap: http://book.realworldhaskell.org/read/types-and-functions.html
01:08:38 <SamanthaD> adnap: go down to the section "Understanding evaluation by example."
01:08:47 <adnap> SamanthaD: I think I already knew that
01:09:07 <fmap> @ty [uncurry (liftA2 (,)), both id]
01:09:09 <lambdabot> Applicative f => [(f b, f b) -> f (b, b)]
01:09:13 <fmap> hmm
01:09:56 <adnap> SamanthaD: Does the phrase "expression label" sound better than "temp var?"
01:10:10 <SamanthaD> adnap: Yes, probably. Though the technical term is "thunk"
01:10:40 <adnap> So x is a "thunk" in "let x = 2 in x + x"?
01:11:12 <monochrom> exactly expression label, no more no less
01:11:28 <SamanthaD> adnap: Yes. Until you evaluate it in which case it becomes a value. But, of course, since you're not actually doing any copying of the value you're not taking up any extra memory beyond that which is required to have a thunk in the first place
01:11:39 <kshannon> adnap: The real point is it does't matter whether you give the thunk a name or not.
01:11:49 <kshannon> It still exists at some level.
01:11:49 <SamanthaD> adnap: the catch is that you need to thunk whether you have an "expression label" or not
01:12:05 <SamanthaD> adnap: what kshannon said ;)
01:12:07 <adnap> kshannon: It does for readability. That was what c_wraith and I were talking about
01:12:25 <kshannon> That was going to be my second point :)
01:12:46 <Nereid> :t both id
01:12:47 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
01:12:56 <Nereid> cool
01:12:56 <SamanthaD> adnap: Basically, consider that a variable of any type in Haskell does not contain anything more than a promise until its value is requested.
01:13:30 <SamanthaD> adnap: The only exception to that rule is when a value is called twice in one expression (in which it's only evaluated once)
01:13:45 <SamanthaD> adnap: ... or you're using memoization libraries but that's a whole different ballpark
01:14:38 <hpaste> otters pasted “epic confusing type error” at http://hpaste.org/81303
01:18:18 <fmap> otters: what's the type of `regexToParser'
01:18:20 <fmap> ?
01:18:47 <otters> good question
01:19:08 <otters> I usually write complicated functions without a type signature and then determine the type in ghci
01:19:29 * hackagebot Adaptive-Blaisorblade 0.23 - Library for incremental computing.  http://hackage.haskell.org/package/Adaptive-Blaisorblade-0.23 (PaoloGiarrusso)
01:19:33 <SamanthaD> otters: that only works when your source compiles in GHCi ;)
01:19:45 <otters> right well I don't know the type of regexToParser
01:20:08 <fmap> otters: anyway, did you try with -XNoMonomorphismRestriction?
01:20:09 <otters> it takes Regex a and returns a Parser action that modifies an internal state of Match
01:20:12 <otters> yeah, that's on
01:20:18 <otters> I believe
01:21:13 <franco00> hello folks. I have 'cabal install cma' fail with '
01:21:24 <franco00> Template Haskell splice illegal in a stage-1 compiler'
01:21:47 <franco00> a quick search suggested to compile it with some flags turned off
01:24:11 <c_wraith> that's an odd error message unless you're using ghc on a platform where ghci doesn't work.
01:24:19 <c_wraith> like..  ARM
01:24:21 <franco00> indeed I am
01:24:24 <c_wraith> ah
01:24:36 <c_wraith> Then yes, template haskell isn't supported for you yet
01:24:46 <franco00> I was writing that upon close inspection, it seems that ghci missing is the problem
01:24:48 <c_wraith> You may have to use different libraries to get around that limitation
01:25:23 <franco00> I am trying to install Euterpea, which seems to require cma. Where do I check wheter/how there are alternative paths?
01:26:04 <c_wraith> I don't know anything about either of those packages, so I can't give any advice offhand.
01:26:34 <c_wraith> There's no generic approach for solving it
01:26:35 <SamanthaD> c_wraith: out of curiosity... template haskell works fine when you're running it from, say, an x86 compiler that's targeting ARM, right?
01:26:55 <c_wraith> I don't know that GHC's cross compilation support is good enough for that to work reliably yet.
01:27:03 <c_wraith> But in theory that should work
01:27:21 <SamanthaD> c_wraith: I see. I hadn't realized that GHC had cross compilation problems.
01:27:40 <shachaf> Are covariant proxies ever useful?
01:27:47 <shachaf> Proxy as in data Proxy a = Proxy
01:27:57 <c_wraith> Well, it was designed with the assumption that the platform it's running on is the same platform it was compiling for
01:28:05 <c_wraith> And there's been a lot of work recently to remove that assumption
01:28:09 <fmap> otters: I guess (*>) is too polymorphic then
01:28:12 <c_wraith> But I was under the impression that work isn't done yet.
01:28:44 <fmap> otters: i.e. `lbehind = Lookbehind <$> try ((string_ "(?<" :: ParsecT s u m a) *> regex <* char ')')` compiles
01:28:53 <SamanthaD> c_wraith: I see... I just figured that since the "preferred" way to port GHC is now to cross compile it I figured maybe they'd worked out the kinks. Course, I've never tried it so I could be very wrong.
01:28:54 <otters> ooh
01:28:55 <fmap> (with ScopedTypeVariables and foralls)
01:30:04 <otters> fmap: Could not deduce (Stream s1 m1 Char, Searchable a4)
01:30:58 <otters> wha version of GHC?
01:31:49 <fmap> otters: did you add foralls? :)
01:32:01 <otters> where?
01:32:26 <fmap> `lbehind :: forall s u m a. (Searchable a, Stream s m Char) => ParsecT s u m (Regex a)'
01:33:50 <fmap> and I think you need this for all functions that use `string_'
01:34:36 <fmap> or use something better than (*>)
01:38:22 <otters> yeah
01:39:40 <fmap> otters: and the last error is because you use something of type `a' as argument to `string_' and `string_' wants `String'
01:39:48 <otters> i see
01:40:16 <otters> okay after having added foralls, regexToParser is of type Stream s m Char => Regex String -> ParsecT s (Match a) m (Match String)
01:40:24 <otters> and I can't figure out where the last String is coming from
01:42:04 <otters> wait, found it
01:46:42 <otters> wait, no I didn't
01:46:52 <otters> string_ needs to be polymorphic in the input and output
01:46:54 <otters> it's bedtime anyway
01:59:13 <Taneb> Okay, I'm seeing how difficult to use my Family Tree making library is.
01:59:21 <Taneb> traversePerson etc are really long names
01:59:31 <Taneb> Location should have an IsString instance
02:05:00 <tomw> has anyone noticed timeout on getLine seems to mess up stdin for the next read?
02:05:40 <tomw> not sure where to find bugtrack to see if this is well known or my own problem
02:13:30 <Dodek_> tomw: what timeout on getLine?
02:14:30 * hackagebot hakyll 4.1.3.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.1.3.0 (JasperVanDerJeugt)
02:19:54 <tomw> Dodek: if you want to timeout on user input
02:20:14 <tomw> so use timeout x getLine
02:20:41 <tomw> it times out okay and breaks the blocking read but then doesn't consume the next line
02:22:21 <Dodek> if it timeouts after consuming some portion of data, but before consuming new line, i'd expect it to break like that.
02:24:30 * hackagebot aws-sdk 0.9.3.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.9.3.0 (YusukeNomura)
02:24:32 * hackagebot hakyll 4.1.4.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.1.4.0 (JasperVanDerJeugt)
02:42:57 <tomw> Dodek: I see your point but in my case i'm going back to consume the next line again
02:43:33 <tomw> Dodek: the program is basically a quiz with a time limit on answering the question
02:44:02 <tomw> Dodek: so if someone doesn't answer q3, the timeout breaks the geline and goes to q4
02:45:21 <tomw> Dodek: however in practice it seems that timing out on q3 means you have to type a return for q4, and then getline for q4 will process your input
02:49:46 <basdirks> what's meant with (Applicative) "side-effects" in the usual explanation of Traversable?
02:57:30 <merijn> :t (<*>)
02:57:32 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
02:57:55 <merijn> basdirks: Imagine that f is IO, then clearly the IO has to be run to get that (a -> b) out, no?
02:58:35 <basdirks> ah yes
02:59:25 <chreekat> GHCI's user docs say to use -ghci-script to load config files after the defaults, but that doesn't seem to work. What's the right way?
02:59:31 <merijn> basdirks: Basically, something can happen "in f" when you use Applicative, what (and whether or not it is visible) would depend on which applicative
03:00:04 <basdirks> okay yeah
03:01:11 <basdirks> good explanation, thanks
03:01:29 <basdirks> are there any idiomatic examples?
03:01:53 <merijn> :t Data.Traversable.traverse
03:01:55 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:02:38 <`ramses> > runWriter $ traverse (\a -> tell (show a) >> return a) [1,2,3]
03:02:39 <lambdabot>   ([1,2,3],"123")
03:02:45 <merijn> basdirks: Well, mapM == traverse, so mapM with an IO/State/Writer seems the most obvious examples
03:02:54 <`ramses> writing the log is the side-effect then (boring example)
03:03:06 <basdirks> :t mapM
03:03:07 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
03:03:36 <merijn> basdirks: mapM just has Applicative specialised to Monad and Traversable to []
03:03:55 <basdirks> yeah
03:04:05 <merijn> :t mapM putStrLn ["hey!", "ho!"]
03:04:07 <lambdabot> IO [()]
03:04:11 <merijn> :t traverse putStrLn ["hey!", "ho!"]
03:04:13 <lambdabot> IO [()]
03:04:27 <basdirks> :t fmap
03:04:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:05:20 <Nereid> :t (.) -- :(
03:05:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:05:45 <basdirks> okay merijn I have a better picture of it now, I'll go experiment some, thanks!
03:09:17 <ski> s/side-//
03:09:31 * hackagebot vty 4.7.1 - A simple terminal UI library  http://hackage.haskell.org/package/vty-4.7.1 (CoreyOConnor)
03:49:16 <bartavelle> before I start writing it, is there already some utility somewhere that will display a Rational with infinite precision using a lazy list or ByteString ?
03:51:18 <mm_freak> Rational doesn't have infinite precision in the first place
03:51:29 <mm_freak> CReal has
03:51:36 <mm_freak> > sin pi :: CReal
03:51:38 <lambdabot>   0.0
03:51:39 <`nand`> what does “infinite” precision mean here?
03:51:55 <shachaf> mm_freak: Rational is exactly precise.
03:51:59 <shachaf> So is CReal.
03:52:07 <mikeplus64> mm_freak: why isn't Rational "infinite precision"?
03:52:11 <bartavelle> display 1/3 as '0.33333333333 ... '
03:52:11 <mikeplus64> > sin pi :: Rational
03:52:13 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
03:52:13 <lambdabot>    arising from a us...
03:52:22 <mm_freak> rational has infinite precision for rationals
03:52:30 <bartavelle> yes but I want the "traditional" display
03:52:33 <`nand`> > 1e-100 == (1e-101 :: CReal)
03:52:35 <lambdabot>   True
03:52:39 <bartavelle> not (1 % 3)
03:52:43 <shachaf> Rational has infinite precision for everything it can express.
03:52:50 <mm_freak> > printf "%8.3f" (1/3 :: Rational)
03:52:51 <lambdabot>   No instance for (Text.Printf.PrintfArg
03:52:51 <lambdabot>                     (GHC.Real.Ratio ...
03:52:53 <shachaf> CReal has no precision for imaginary numbers.
03:53:01 <`nand`> > 1e-100 == (1e-101 :: Rational)
03:53:02 <lambdabot>   False
03:53:07 <mm_freak> shachaf: so does Float
03:53:10 <bartavelle> I meant as a potentially infinite String
03:53:34 <bartavelle> or lazy ByteString
03:53:49 <shachaf> mm_freak: No, Float implements fromRational, but rounds.
03:53:58 <shachaf> Things like 0.1 :: Float aren't actually 0.1
03:54:06 <shachaf> On the other hand, you can't take the sqrt of a Rational
03:54:13 <mm_freak> Float has infinite precision for rational numbers, where the exponent is a power of 2 and the mantissa has up to 24 digits
03:54:34 <mm_freak> Word32 has infinite precision for 32 bits nonnegative integers
03:54:37 <shachaf> If Rational implemented sqrt, I would say it doesn't have infinite precision.
03:54:58 <shachaf> If Float didn't implement fromRational, I might have different things to say about it.
03:55:29 <mm_freak> so Rational as a type is less precise, if anyone in the world implements sqrt for it?
03:55:42 <mm_freak> that doesn't sound like a sensible notion of precision
03:56:02 <mm_freak> the precision of a type must be bound to the containing set
03:56:17 <mikeplus64> @hoogle CReal
03:56:17 <lambdabot> No results found
03:56:21 <mm_freak> Rational has infinite precision for ℚ, but not for ℝ
03:56:22 <mikeplus64> where is CReal defined?
03:56:32 <mm_freak> mikeplus64: in the numbers package, i think
03:56:32 <shachaf> Then saying "Rational doesn't have infinite precision in the first place" "CReal has" still makes no sense.
03:56:47 <shachaf> mikeplus64: Data.Number.CReal, in "numbers"
03:56:50 <mm_freak> mikeplus64: but you don't want to do calculations with CReal, unless you really need that kind of precision
03:56:58 <shachaf> There are some numbers CReal can't express either.
03:57:03 <mikeplus64> data CReal = CR (Int -> Integer)
03:57:07 <mikeplus64> huh, interesting
03:57:26 <shachaf> You give it a precision, and it gives you enough bits to be accurate up to that precision.
03:57:43 <shachaf> It's not even a newtype.
03:59:39 <magistr> give ma a book to learn haskell
03:59:52 <osfameron> your mother wants to learn haskell?
03:59:58 <shachaf> @where lyah
03:59:58 <lambdabot> http://www.learnyouahaskell.com/
04:00:05 <shachaf> @google hutton programming in haskell
04:00:07 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
04:00:08 <lambdabot> Title: Programming in Haskell
04:00:12 <Nereid> @where rwh -- this too
04:00:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:00:12 <shachaf> I recommend the latter book but the former is free online.
04:00:16 <magistr> I want to learn haskell
04:00:23 <Nereid> LYAH is a good way to start.
04:00:43 <magistr> osfameron, why do you ask?
04:00:56 <shachaf> Nereid: For someone who knows nothing about Haskell and comes into a channel saying "give me a book to learn haskell"?
04:01:17 <Nereid> well.
04:01:27 <Nereid> yes, it could have been asked more nicely.
04:02:05 <shachaf> ?
04:02:09 <shachaf> I'm not suggesting anything about niceness.
04:02:52 <Nereid> well.
04:04:12 <shachaf> (Or are you saying I could have been nicer? Probably true.)
04:04:23 <shachaf> (This was meant more as metadiscusion.)
04:04:32 <Nereid> no, you were fine.
04:04:33 <maki``> to allocate N WCHAR elements should I just do allocaBytes 2 * N  ?  or is there a better way to reduce the chance of forgetting 2 (which I did earlier and had GHCI randomly crash)
04:05:14 <Nereid> maki``: how about sizeOf (undefined :: CWchar) instead of 2
04:05:38 <shachaf> maki``: alloca will only allocate things for the duration of the block you give it.
04:05:54 <shachaf> I'm not sure if that's clear or not. :-)
04:06:00 <maki``> it is clear
04:06:10 <shachaf> Nereid: Is there such a thing?
04:06:18 <Nereid> such a thing as what?
04:06:18 <shachaf> Oh, there is.
04:06:43 <shachaf> maki``: Keep in mind that wchar_t is not always two bytes.
04:06:52 <shachaf> In fact over here it's 4 bytes.
04:06:54 <maki``> is there nothing similar to allocateObjects N, which would automatically allocat N * sizeOf object
04:06:59 <shachaf> There is.
04:07:04 <maki``> objects
04:07:13 <Nereid> there is, if you write it?
04:07:45 <maki``> shachaf I see. 64 bit OS? I thought it was always 2 bytes
04:07:57 <shachaf> maki``: Are you using Windows?
04:08:05 <Nereid> wikipedia says it varies.
04:08:05 <maki``> yes.
04:08:08 <shachaf> In Microsoftland it's probably always going to be 2 bytes.
04:08:11 <shachaf> In UNIX I think it's more often 4.
04:08:37 <Nereid> The ISO/IEC 10646:2003 Unicode standard 4.0 says that: "The width of wchar_t is compiler-specific and can be as small as 8 bits.
04:09:09 <shachaf> maki``: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-Marshal-Array.html
04:09:19 <Nereid> ah there.
04:09:43 <maki``> allocaArray looks nice
04:09:48 <Nereid> I should familiarize myself more with FFI stuff.
04:09:51 <shachaf> And CWchar.
04:10:12 <Eelis> the problems with wchar_t are the reason char16_t and char32_t were added to the C/C++ standards
04:10:53 <shachaf> maki``: Keep in mind that a 2-byte wchar can't hold a Haskell Char.
04:11:07 <shachaf> (Because a Unicode codepoint can't be stored in 2 bytes.)
04:11:10 <Nereid> right, in windows a wchar holds a utf-16 code unit.
04:11:24 <Nereid> and in unix, utf-32.
04:11:44 <shachaf> A UTF-32 code unit is always the same as a codepoint, though. :-)
04:11:45 <Nereid> hmm, is it utf-16 or ucs-2? :(
04:11:49 <shachaf> UTF-16
04:12:20 <shachaf> They certainly try hard to pretend that everything fits in 2 bytes, though.
04:12:59 <shachaf> http://msdn.microsoft.com/en-us/library/9s91f3by.aspx -- takes a 16-bit "char"
04:13:07 <shachaf> http://msdn.microsoft.com/en-us/library/c2bxftt7.aspx -- the thing you have to use if you actually want to be correct.
04:14:18 <shachaf> unicode is so easy
04:16:23 <maki``> as far as I know haskell doesn't have WChar pointer, there is only one pointer type, correct?
04:16:47 <merijn> maki``: heh, what do you mean by "pointer type"?
04:16:49 <maki``> if so, how can allocaArray know how many bytes to allocate per element if I just send the resulting pointer to the C function?
04:17:05 <maki``> merijn WCHAR *ptr; in C.
04:17:10 <shachaf> maki``: Haskell has "Ptr".
04:17:20 <shachaf> Ptr CWchar ~~ wchar_t *
04:17:22 <merijn> maki``: Haskell has "Ptr a" where a is a Sotrable
04:17:42 <merijn> So you need to figure out which Storable type corresponds to WCHAR
04:17:43 <shachaf> "WCHAR" isn't a standard C type, it's a Microsoftism, so I can't tell you anything about it. :-)
04:17:45 <maki``> ah so Ptr takes a C type, nice
04:17:53 <shachaf> It takes a Haskell type.
04:18:00 <shachaf> But there are Haskell types that correspond to C types.
04:18:01 <maki``> shachaf yeah, wchar_t is
04:18:18 <shachaf> (What's with TYPE NAMES THAT ARE ALL UPPERCASE, anyway?)
04:18:39 <maki``> shachaf I know, windows typedefs are annoying
04:18:40 <merijn> shachaf: TYPES MAKE YOU WANT TO SHOUT
04:23:42 <simpson> I have a type that I'm threading through State. It's a little tricky to populate it at the top (there's some IO to do first), but I saw the idiom of making objects with undefined and then filling them in later. Is this a reasonable thing to do, or is there a better idiom?
04:27:03 <shachaf> You can do it sometimes.
04:27:18 <shachaf> (In other cases you can't -- for example when the field is strict.)
04:27:40 <shachaf> It seems nicer to pass around just the information you have, if you can manage it, and build the record when it's finished.
04:30:01 <simpson> In this case, the things are TextureObjects (from GL), and I can't get them without starting up the entire windowing subsystem.
04:30:37 <simpson> I guess that maybe I should restructure things so that I have a bit of IO time to get things set up in-between starting GL and actually doing my drawing work.
04:56:21 <latermuse> How do i format the getZonedTime from Data.Time to be in the (HH,MM) format?  so like 21:47 would be (21,47)
04:57:58 <Nereid> latermuse: looks like you convert it to a LocalTime and then a TimeOfDay which you can then deconstruct.
04:59:34 * hackagebot gemstone 0.3 - A simple library of helpers for SDL+GL games.  http://hackage.haskell.org/package/gemstone-0.3 (CorbinSimpson)
05:00:34 <latermuse> Nereid, theres no easier way?
05:00:44 <Nereid> I don't see one.
05:01:02 <Nereid> hang on.
05:01:16 <quazimodo> as far as i understand it, we make state changing side effects happen in haskell by (possibly) returning categories, thus remaining properly functional, yes?
05:01:27 <Nereid> what?
05:08:21 <sm> morning all
05:09:16 <sm> what makes regex-tdfa so hard to build I wonder. It really makes my macbook sweat (GHC at 800Mb for an extended period of time)
05:09:35 <shachaf> Add enough -v and you'll find out.
05:09:37 <osfameron> the compiler suddenly realised it had two problems?
05:09:49 <sm> heh
05:14:54 <Taneb> sm, tables is pretty bad too
05:18:10 <sm> regex-tdfa also allocates more and takes longer than regex-compat at least in this small test, so easy choice here
05:18:58 <sm> and both perform much better than regexpr which I was using before
05:22:10 <ski> quazimodo : .. what did categories have to do with it ?
05:22:47 <latermuse> nereid: this is how i wanted it :)
05:22:49 <latermuse> > fmap show getZonedTime >>= (\x -> return $ concat . take 2 . (splitOn ":") . head . tail . words $ x)
05:22:50 <lambdabot>   Not in scope: `getZonedTime'
05:23:07 <Nereid> going via show bleh.
05:23:23 <latermuse> Nereid: Do you know an easier way? I couldnt figure out any other way
05:23:42 <latermuse> show is slow, but its the only way i could figure it out
05:23:47 <shachaf> Easier: Put the show inside the lambda.
05:24:02 <shachaf> Still horrible, but anyway.
05:24:11 <shachaf> Alternatively: Move the whole lambda into the fmap.
05:24:16 <latermuse> im using that fmap to build intuition for fmap
05:24:24 <latermuse> i like your second idea, im going to try that
05:24:34 <shachaf> fmap (concat . take 2 . splitOn ":" . head . tail . words . show) getZonedTime
05:24:41 <shachaf> But please don't do this with show. :-(
05:24:43 <Nereid> also fmap = (.)
05:24:51 <latermuse> shachaf: how can it be done without show?
05:25:02 <Nereid> by converting to a TimeOfDay and deconstructing.
05:25:06 <shachaf> I'm not sure, I don't know the API.
05:25:20 <shachaf> In cases like this I often like to go look at the code for show and see what it's doing.
05:25:31 <shachaf> That might be an extreme measure.
05:25:37 <shachaf> Otherwise I just read the API documentation.
05:25:42 <ski>   head . tail = (!! 1)
05:26:23 <shachaf> That too.
05:26:44 <latermuse> head . tail = (!! 1)  -- forgot about that, thanks!
05:26:53 <Nereid> oh wait, fmap not (.) here
05:26:55 <Nereid> ok.
05:27:31 <Nereid> but really, stuff . localTimeOfDay . zonedTimeToLocalTime
05:27:45 <Nereid> where stuff might involve todHour and todMin
05:27:58 <Nereid> or I guess you could pattern match.
05:28:38 <Nereid> match ZonedTime (LocalTime _ (TimeOfDay h m _)) _ or so
05:28:39 <latermuse> Nereid: is show so bad too warrant doing all that extra work to have it the "correct" way? (honest question here)
05:28:52 <Nereid> it's extra work?
05:29:03 <latermuse> nereid: yes
05:29:19 <Nereid> it's guaranteed to work. you or I might have messed up mucking about with strings and checking that we didn't requires thinking.
05:29:22 <latermuse> will the gains of having it the correct way be much better than using show?
05:29:38 <latermuse> ohh! got it
05:29:44 <latermuse> with show we cant type check the time
05:30:18 <shachaf> The show instance for LocalTime uses showGregorian.
05:30:30 <Nereid> only for the date, not the time.
05:30:31 <shachaf> Oh, wait, I'm looking at the wrong half.
05:30:35 <shachaf> You want the time, not the date.
05:31:14 <shachaf> OK, so there's todHour, todMin, todSec
05:31:34 <shachaf> Looks straightforward.
05:31:42 <shachaf> latermuse: Remember: Strings are evil.
05:31:49 <shachaf> More evil than booleans.
05:31:56 <Nereid> what's wrong with booleans?
05:32:05 <latermuse> Hmm
05:32:14 <shachaf> Nereid: Boolean blindness and all that.
05:32:35 <latermuse> I wasnt sure about how to format the getZonedTime into the proper format to begin dissecting it with "todHour, todMin, etc"
05:32:53 <shachaf> I like to figure this out by reading the code.
05:33:09 <shachaf> More reasonable people might read the API documentation.
05:33:26 <Nereid> shachaf: what do you mean?
05:33:28 <mm_freak> booleans are only useful in storage…  as soon as you load them, you should get away from them as fast as possible
05:33:36 <shachaf> @where boolean-blindness
05:33:36 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
05:36:23 <Nereid> well sure.
05:36:55 <shachaf> So that's what's wrong with booleans.
05:37:10 <danr> nice use of en passant in that article you suggested shachaf
05:37:50 <edwardk> yeah
05:38:13 <ski> @quote stark
05:38:13 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
05:38:40 <shachaf> @quote snark
05:38:40 <lambdabot> No quotes match. stty: unknown mode: doofus
05:39:26 <typoclass> @quote quark
05:39:26 <lambdabot> No quotes match. The more you drive -- the dumber you get.
05:47:50 <edwardk> hah, according to https://gist.github.com/2657075 i'm apparently 21st in commit activity on github for last year
05:48:58 <Taneb> edwardk, out of those with more than 150 followers
05:49:03 <edwardk> sure
05:50:18 <shachaf> I think I linked to that before.
05:54:48 <typoclass> shachaf: you're 2nd on the list of people who linked to that. ed is 1st
05:55:05 <quchen> I have a tuple, and I would like to evaluate its arguments to WHNF. DeepSeq would do, but is a little too deep; I only need to go one layer down. Would "let x = seq a a; y = seq b b; result = (x,y) in seq result result" be a solution? Is there a more idiomatic aproach?
05:55:42 <shachaf> quchen: A tuple doesn't have arguments (it helps to be precise when you're talking about things like this).
05:55:49 <shachaf> (seq x x) is exactly the same thing as (x)
05:55:54 <shachaf> You don't gain anything from it.
05:55:58 <quchen> Oh, right.
05:56:11 <quchen> Silly me
05:56:35 <shachaf> Are you building the tuple or do you have an existing one?
05:57:24 <shachaf> Maybe you want (with bang patterns): strictify t@(!x,!y) = t
05:58:08 <quchen> I'm writing a Scheme interpreter. The problem with defining "(if #t x y) == x" is that Lisp isn't lazy, so I would like to evaluate x and y before I return one of them.
05:58:36 <quchen> BangPatterns would also evaluate if the pattern fails to match. I'm not sure that's what I want.
05:58:37 <shachaf> Hmm, normally Haskell's laziness wouldn't carry over to the language you're interpreting.
05:58:48 <shachaf> Unless you do fancy tricks.
05:58:54 <Nereid> seq doesn't guarantee anything about order of evaluation.
05:58:57 <Nereid> does it?
05:59:02 <quchen> Nereid: Nope. pseq does.
05:59:08 <Nereid> yeah, so.
05:59:11 <shachaf> Right.
05:59:19 <shachaf> I think you want to have more control over evaluation.
05:59:35 * hackagebot fixed-vector 0.1.2 - Generic vectors with fixed length  http://hackage.haskell.org/package/fixed-vector-0.1.2 (AlexeyKhudyakov)
05:59:49 <shachaf> Note that Scheme expressions can have side effects too.
05:59:57 <shachaf> This is important.
06:00:08 <Nereid> I want my type nat solver.
06:00:15 <quchen> shachaf: Right, I should not only evaluate the two, but also makes sure the True case is evaluated first.
06:00:24 <quchen> Hmmm.
06:00:28 <shachaf> quchen: No. You should be using something other than evaluation.
06:00:36 <shachaf> Well, "evaluation" means something different in Haskell and Scheme.
06:00:36 <quchen> ..?
06:00:45 <shachaf> You should not be using Haskell's sense of "evaluation" here.
06:01:14 <shachaf> What do you want to happen for (if #t (print 1) (print 2))?
06:01:21 <quchen> Scheme feels more like reducing.
06:01:35 <quchen> Print 1, print 2, return Scheme's ()?
06:01:49 <shachaf> OK.
06:01:58 <shachaf> But evaluation in Haskell can't print anything.
06:02:45 <solarus> quchen: uhm no
06:02:56 <solarus> isn't if usually defined as a macro
06:03:06 <solarus> where only the branch which is used is evaluated
06:03:12 <shachaf> solarus: We're talking about an "if" function here for whatever reason.
06:03:23 <shachaf> The point stands if you take out "if" and replace it with something else.
06:03:25 <solarus> if it is a function then yes
06:03:51 <quchen> OH! http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.1.5
06:03:58 <quchen> if seems to be lazy! WTF
06:04:06 <Nereid> if is not a function.
06:04:21 <quchen> Nereid: Probably for that reason: laziness
06:04:27 <Nereid> no.
06:04:30 <shachaf> Hmm, maybe you should learn some Scheme before writing an interpreter. :-)
06:04:39 <Nereid> I should probably learn scheme too.
06:05:00 <quchen> shachaf: Yeah, thought of that too. But then I'm trying to write something useful in Haskell.
06:05:04 <shachaf> I should probably too!
06:05:09 <quchen> I'll also be learning scheme on the way somehow ;-)
06:05:52 <quchen> I'm not trying to be productive in the sense that I want a fully featured interpreter as soon as possible. It's more the getting there I'm interested in.
06:06:10 <quchen> It's also a playground for Git for me.
06:06:26 <shachaf> Sure.
06:07:05 <shachaf> But still, reading a bit about the semantics of the language you're implementing will be very helpful.
06:07:48 <quchen> shachaf: That's what I'm doing. I just remembered that sentence (that I've read a little about) saying "everything's evaluated before it's passed in a function".
06:07:55 <shachaf> True.
06:07:58 <Nereid> sure. but if isn't a function.
06:08:17 <quchen> Nereid: I know that now. But who would know that after reading the docs
06:08:33 <merijn> Depends which docs you read...
06:08:44 <merijn> The Racket docs make that quite clear, for example :p
06:08:51 <shachaf> I think every Scheme 101 talks about this.
06:08:55 <shachaf> Hence the recommendation. :-)
06:09:10 <shachaf> Anyway, Haskell evaluation is not going to be enough here.
06:09:15 <shachaf> You'll need to be more explicit.
06:09:20 <shachaf> I'm going to sleep.
06:09:23 <shachaf> Nereid: Go to sleep.
06:09:24 <quchen> What do you mean with th...ok
06:09:25 <Nereid> me too.
06:09:31 <quchen> Thanks anyway.
06:09:42 <Nereid> also, learning scala is a higher priority for me than scheme, I guess.
06:09:45 <shachaf> I bet someone here can help you.
06:10:02 <shachaf> Oh no, Scala.
06:10:25 <Nereid> but people use scala.
06:11:18 <Nereid> and it's looking like a better option than haskell for developing for android.
06:11:32 <Nereid> i.e. I've gotten scala code to run on my phone.
06:11:44 <Nereid> shachaf: let's go to sleep simultaneously.
06:11:47 <merijn> Nereid: Clojure!
06:12:11 <Nereid> I don't feel the need to learn more than one lisp. :(
06:13:00 <shachaf> Nereid: Then we'd never go to sleep.
06:13:05 * shachaf is going now.
06:13:09 * Nereid too
06:13:21 <Nereid> in fact
06:13:25 <shachaf> Nereid: Oh, if you want to do something useful with yourself, you can work on http://hackage.haskell.org/trac/ghc/ticket/7542
06:13:28 <shachaf> Pft.
06:13:32 <shachaf> Ridiculous.
06:14:00 * shachaf needs to write a reply to SPJ explaining why his proposed solution doesn't really help us.
06:16:44 <sm> dang.. how to track down a "parsec: combinator 'many' is applied to a parser that accepts an empty string" that only happens with certain input
06:17:34 <sm> in theory replacing all many with many1 should get rid of that eh ?
06:19:13 <fmap> no
06:20:12 <quchen> sm: That will get rid of the error, but change the semantics of your parser.
06:20:44 <fmap> not really, many1 is defined in terms of many
06:21:00 <quchen> Right.
06:21:04 <quchen> Nevermind. It'll fix nothing.
06:21:30 <sm> hmm. Well anyway, whittling down the input turned out to be a quicker route
06:21:51 <sm> thanks
06:22:40 <typoclass> out of curiosity, would trifecta's improved error messages have caught that?
06:22:58 <edwardk> caught what?
06:23:15 <edwardk> which parser many was applied to?
06:23:31 <edwardk> sadly that one just gets flagged fatal and you get a bad error
06:23:44 <typoclass> edwardk: i see, thanks
06:23:47 <edwardk> since that indicates a broken grammar, not a user parse error
06:24:04 <parcs> shachaf: are you talking about the newtype wrappers proposal?
06:24:31 <sm> is there any reasonably easy way to check the grammar statically to avoid runtime errors ?
06:24:42 <gregori> hello.
06:25:56 <edwardk> sm: by using something like happy instead, basically
06:26:28 <edwardk> sm: parsec style parsers have no way to give you back their 'first' set. so you have no way to know if they'll accept the empty string in general
06:26:40 <edwardk> this is a fundamental limitation of a monadic parser
06:29:36 * hackagebot lens 3.8.5 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.5 (EdwardKmett)
06:30:23 <merijn> edwardk produces new lens versions more frequently than I change clothes...
06:31:05 <edwardk> merijn: been squashing bugs in the test suite that crop up intermittently when building stackage
06:31:16 <edwardk> most of them are caused by a subtle bug in doctests
06:31:28 <edwardk> so i don't get to see them for several hours after they are introduced
06:31:32 <edwardk> until it pops up in a report
06:31:38 <Taneb> merijn, you didn't change clothes between the 7th and the 22nd?
06:31:41 <edwardk> when we can get doctest fixed the frequency will do back down
06:31:46 <edwardk> er will go back down
06:32:05 <edwardk> and yeah the 3.7 to 3.8 gap must have been rough on you ;)
06:32:34 <merijn> You mean rough on my colleagues :p
06:36:59 <Rc43> Hi, guys.
06:38:35 <Rc43> I am trying to install c2hs, but it depends on language-c-0.3.2.1, which fails to build on my machine.
06:38:57 <Rc43> Why it depends on it and how can I workaround problem?
06:39:12 <Rc43> I have already installed language-c of newer version.
06:40:13 <Rc43> Hmm... SUDDENLY reinstalling fresh version of language-c fixed build of previous version, magic.
06:49:05 <merijn> Rc43: language-c is a C parser, so that's why c2hs depends on it
06:49:26 <Rc43> merijn, I mean specific old version
07:07:26 <finnrobi> I want to pick up haskell again after not having touched it for a few years and I was thinking I'm going to write a small unixy command-line utility. Does anyone know a project I can check out that is similar in scope (to get an idea of how the project structure / tooling should be)?
07:10:06 <danr> finnrobi: sounds quite broad :)
07:12:52 <finnrobi> danr: no doubt, but for now it's pretty much just going to be doing something that I do by piping find -exec cat through grep and awk, so I'm going to want to have a sane src/ structure, dependency management of some sort and automated building/testing and not much more
07:12:53 <typoclass> finnrobi: as far as tooling is concerned, i guess you want mainly cabal and an editor. also ghc and ghci, though you probably already have those. hoogle can be accessed via the web or via command line, whatever you prefer
07:13:47 <finnrobi> yeah I'm pretty much set in the editor ways, I don't know much about cabal or what hoogle is (searching source code)?
07:14:12 <bergmark> @where hoogle
07:14:12 <lambdabot> http://haskell.org/hoogle
07:14:30 <finnrobi> ah, that seems pretty cool
07:14:39 <finnrobi> awesome, it's in emacs
07:15:09 <typoclass> finnrobi: right, so cabal (or cabal-dev) does the dependency management (commands you're gonna need are cabal init and cabal install). for testing, i like doctest, since the tests double as documentation
07:15:19 <typoclass> finnrobi: http://www.haskell.org/hoogle/?hoogle=fromMaybe <- hoogle example
07:15:28 <bergmark> i prefer HUnit for testing but whatever :)
07:15:35 <bergmark> and maybe check out shelly
07:15:41 <danr> typoclass: nice! thanks
07:16:19 <typoclass> finnrobi: oh, and be aware, on the haddock pages (e.g. http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Maybe.html ), you can click the 'source' link on the right hand side to have a look at the source code
07:16:22 <typoclass> danr: ;-)
07:17:14 <finnrobi> cool, thanks a lot
07:17:40 <typoclass> bergmark: i couldn't really get used to that because i always need to look stuff up ... test runner, test labels, collections, whatnot ... in doctest, you just add to a haddock comment two lines ">>> succ 42" and "43", then you run "doctest File.hs", and that's it
07:23:24 <tom2221> It seems surprising to me that http://hpaste.org/81309 isn't in Control.Monad or Control.Monad.LoopWhile (LoopWhile can't do what that function does, afaict). Does anybody know of a more idiomatic way to achieve what 'while' does?
07:31:11 <applicat1ve> tom2221: I remember writing this a couple times. I guess there are too many variants for any one of them to win out?
07:34:20 <k00mi> tom2221: it's in Control.Monad.Loops
07:34:29 <k00mi> http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html
07:37:12 <applicat1ve> aha,  monad-loops not loop-while
07:39:22 <tom2221> k00mi: Excellent! Thanks.
07:53:46 <mm_freak> update ev = view cfgDb >>= liftIO . flip Acid.update ev
07:53:54 <mm_freak> any way to express this more concisely with lens?
07:54:01 <hpaste> “Anonymous Coward” annotated “deadpedos” with “speedoadd(annotation)” at http://hpaste.org/81165#a81312
07:54:34 <mm_freak> i guess not
07:55:23 <edwardk>  not really, you might save a few chars with views, but then you have to join
07:56:10 <mm_freak> i take that as "no" =)
07:56:12 <mm_freak> thanks
07:59:32 <mm_freak> i changed it to classic do-notation
07:59:35 <mm_freak> much more readable
08:26:04 <mSSM> I am trying to understand and tweak the performance of my program: right now, I am essentially chaining “sum . scanl (+) 0 <$> (replicateM n $ sum <$> (replicateM l $ foo gen))”, where “foo gen” gives me a `Num a => MTGen -> IO a' (random number).
08:26:32 <mSSM> For example, does the inner replicateM first generate a IO [a], before it's sum'med up?
08:28:39 <mSSM> Profiling tells me for example, that a huge heap with [] is build up.
08:28:55 <mSSM> And that the program only spends about 30% doing effective computations.
08:34:15 <parcs> mSSM: yeah replicateM first generates the entire list and then it gets summed
08:35:12 <Lethalman> mSSM, as a personal experience, use simple do notation with randoms, don't come up with a Rand [a] from a [Rand a] or it will blow the heap
08:35:22 <Lethalman> that is, don't sequence randoms
08:35:38 <k00mi> mSSM: sequence (which replicateM uses) has to build up the entire list because the last element can change the outcome of the entire computation
08:36:00 <mSSM> Ok, those are really good infos!
08:36:10 <mSSM> Essentially since I don't even need to make a list.
08:36:16 <mSSM> It's made, summed, and thrown away.
08:36:27 <mSSM> All the : action seems like a complete waste.
08:37:11 <mSSM> Lethalman: Can you recommend an alternative? I am trying to get rid of boilerplate code, which I have do to explicit recursion.
08:37:48 <Lethalman> mSSM, don't sequence
08:40:32 <k00mi> mSSM: maybe whileM' from monad-loops with the sum monoid
08:43:08 <mSSM> Thank you, I will check that one out.
08:45:45 <parcs> define a replicateM that uses unsafeInterleaveIO :)
08:45:56 <k00mi> mSSM: while is probably not right, rather unfoldrM'
08:53:00 <mSSM> parcs: I wouldn't know where to start with that for now :D
08:53:39 <mSSM> k00mi: I hate that so many of those functions cannot be found with hoogle.
08:53:41 <mSSM> :(
08:55:10 <srhb> mSSM: Do you know of Hayoo_
08:55:13 <srhb> ?
08:57:22 <mSSM> srhb: It tends to load very slowly.
08:57:44 <mSSM> Hm, but it's indeed nice, yes.
08:58:43 <mSSM> Is there a reason why hoogle is not expanded to include more packages?
09:00:32 <merijn> mSSM: Lack of man power/compute power, I guess?
09:05:31 <BlindRadish> hello?
09:05:39 <BlindRadish> hello!
09:05:55 <BlindRadish> :D
09:06:08 <BlindRadish> XD
09:06:50 <srhb> BlindRadish: Hi there.
09:07:19 <Saizan> merijn mSSM: http://www.haskell.org/haskellwiki/Hoogle/Packages
09:22:14 <mSSM> Saizan: Apart from that little discussion, has there been anything done to being able to search all of hackage?
09:24:28 <jmcarthur> mSSM: have you seen hayoo?
09:26:04 <mSSM> Yes :)
09:37:10 <Saizan> mSSM: no idea
09:39:13 <applicative> mSSM: you can set up a local hoogle, e.g., for the things you've installed
09:39:34 * applicative hasn't tried this forever
09:41:25 <applicative> hm, there are six package on hackage for Optimisation, five for Optimization; only one that both does Optimisation and Optimization
09:41:49 <srhb> applicative: Obviously the last one is language agnostic.
09:42:15 <applicative> yes
09:42:22 <monochrom> haha
10:06:37 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/23322/
10:07:22 <typoclass> monochrom: very good
10:10:12 <srhb> Better put in on the profiler too, you get automatic optimizations then. Just have to make some daemon that can incorporate suggestions until it compiles, and otherwise post "no nuderstand plz"
10:17:59 <BlindRadish> hey can i disable these == messages?
10:18:07 <BlindRadish> i'm getting spammed pretty hard.
10:18:13 <Eelis> what messages?
10:18:26 <parcs> join/part?
10:18:38 <BlindRadish> also, we're all just hanging out and talking about haskell programming, right?
10:18:40 <mauke> screenshot?
10:18:41 <parcs> you can disable them in the settings of the webchat client
10:20:15 <parcs> BlindRadish: pretty much
10:20:49 <t7_> 95% of people dont even talk :)
10:20:57 <BlindRadish> So who's in what field?
10:21:15 * mauke is in a radish field
10:21:26 <BlindRadish> lol
10:21:33 * typoclass is an expert in lolcats
10:21:52 <t7_> self proclaimed
10:22:03 <mauke> wolf revok cats
10:22:09 <srhb> BlindRadish: If you want to customize what messages that show up, you probably need to download a real IRC client. You're on some web client, right?
10:22:24 <mauke> srhb: correction: *the* freenode web client
10:22:35 <mauke> (and it can ignore)
10:22:37 <BlindRadish> ah yes, lolcatology.  A friend of mine was interested in pursuing that, but the courseload was too intense.
10:22:51 <typoclass> BlindRadish: very good =)
10:23:06 <BlindRadish> yes web irc
10:23:13 <srhb> mauke: I didn't know that. :)
10:23:19 <BlindRadish> it won't auto scroll i have to scroll down every time.
10:23:47 <t7_> BlindRadish: yeah that plays up sometimes, make sure you are really at the bottom of the page
10:24:02 <BlindRadish> I fixed it by switching pages
10:24:08 <BlindRadish> And switching back.
10:24:12 <BlindRadish> Annoying!
10:24:21 <BlindRadish> google chrome sucks lol
10:24:54 <BlindRadish> hey, can one of you scholars help an pupil?
10:24:59 <BlindRadish> a pupil*
10:25:32 <mauke> don't ask to ask; just ask
10:26:00 <BlindRadish> so its like, common?
10:26:12 <BlindRadish> alright, I'm trying to build a PRNG
10:26:34 <BlindRadish> and i need one variable for the state
10:26:44 <BlindRadish> exclusive to the function
10:26:57 <BlindRadish> so I should use the State monad right?
10:27:15 <BlindRadish> no IORef or anything like that?
10:27:19 <BlindRadish> not*
10:27:34 <typoclass> BlindRadish: yeah State is a popular option for this kind of stuff
10:28:30 <srhb> BlindRadish: Either will work. State is probably the most obvious and cleanest solution, wrt. purity.
10:28:57 <BlindRadish> Okay good, thanks.
10:29:05 <BlindRadish> Next question -  I want to make some types I think, I need a tuple with a mask Bits and a step Bits.  I don't want to mix them but I want to do Bit math on them.
10:29:16 <BlindRadish> how do I do that, then?
10:29:29 <srhb> How you make a type alias for a tuple?
10:29:53 <BlindRadish> yeah, I'm really new to this.
10:30:01 <BlindRadish> I want to do newtype, right?
10:30:23 <BlindRadish> like newtype State MyState Bits?
10:31:05 <BlindRadish> I mistyped that, but I can't really figure out the Bits or the tuple.
10:32:02 <mauke> what's Bits?
10:32:28 <BlindRadish> its from Data.Bits, I'm building a LFSR
10:33:02 <mauke> that's a class, not a type
10:33:21 <BlindRadish> Bits is a Class?  Haskell has Classes??
10:33:33 <mauke> uh, of course?
10:33:57 <geekosaur> it ha classes, but not in the sense you're probably thinking of
10:33:58 <typoclass> BlindRadish: here 'class' means typeclass. it's not like a class in an oop sense
10:34:19 <BlindRadish> I read in Learn You a Haskell that types were /like/ classes, and somewhere else that functional has no classes.
10:34:35 <mauke> those are both wrong
10:34:54 <BlindRadish> okay wait so whats the difference between typeclass and class
10:34:55 <BlindRadish> ?
10:35:02 <mauke> in Haskell? none
10:35:16 <srhb> Does it really say that in LYAH? Hmm.
10:35:17 <typoclass> BlindRadish: if you look for "something like java's classes" in haskell, you won't find it
10:35:21 <BlindRadish> I just want to use (xor bits1 bits2)
10:35:32 <BlindRadish> I must've misread it.
10:35:56 <mauke> how many bits will there be in bits1?
10:36:02 <BlindRadish> It says they're "like classes, but even more powerful/flexible" or something.
10:36:20 <BlindRadish> Was hoping to leave that to a constant.
10:36:32 <mauke> which constant?
10:36:38 <BlindRadish> For testing.  16 bits proves 32 bits a lot faster than 32 bits proves itself.
10:36:52 <mauke> huh?
10:36:55 <BlindRadish> Some bitlength for testing and flexibility.
10:37:37 <BlindRadish> I want to use dynamic masks, which I need to test on 8 bit lfsrs, but ultimately I will use 16 or 32 bit lfsrs.
10:37:49 <mauke> then you could use Word32
10:38:11 <BlindRadish> okay is there a Word16 and a Word8?
10:38:15 <mauke> yes
10:38:22 <mauke> @index Word16
10:38:22 <lambdabot> Data.Word, Foreign
10:38:32 <BlindRadish> and I can use xor on it?
10:38:45 <BlindRadish> what do you mean by Foreign?
10:38:53 <mauke> > 9 `xor` 25 :: Word16
10:38:55 <lambdabot>   16
10:39:15 <mauke> are you talking to the bot?
10:39:16 <BlindRadish> wait you can punch code in here?
10:39:18 <geekosaur> "Foreign" is the old (Haskell98) module, Data.Word is the modern one
10:39:33 <BlindRadish> (+ 1 2)
10:39:40 <BlindRadish> :(
10:39:41 <mauke> > (+) 1 2
10:39:42 <lambdabot>   3
10:39:47 <geekosaur> it doesn't speak Lisp, and that's not how you do it
10:39:58 <typoclass> > 1 + 17 -- BlindRadish: lambdabot evaluates stuff that starts with "> "
10:39:59 <lambdabot>   18
10:40:22 <BlindRadish> oh it's hard to see cuz our names are in <brackets>
10:40:37 <BlindRadish> > 0 + 0 + 0
10:40:39 <lambdabot>   0
10:40:43 <BlindRadish> fascinating.
10:41:07 <BlindRadish> > xor 1 2 :: Word8
10:41:08 <lambdabot>   3
10:41:23 <BlindRadish> Okay so is there a way I can set a constant to Word#?
10:41:30 <srhb> BlindRadish: You can also /msg lambdabot if you want to experiment without flooding the channel.
10:41:40 <BlindRadish> like type MyBits Word32
10:41:53 <mauke> type MyBits = Word32
10:41:54 <BlindRadish> oh sorry :D
10:42:01 <BlindRadish> thanks mauke
10:42:05 <BlindRadish> thanks everyone else
10:42:10 <BlindRadish> brb no doubt ;)
10:42:34 <BlindRadish> oh wait, whats newtype so special for?
10:42:54 <mauke> creating new types that are secretly the same as old types
10:43:00 <BlindRadish> i've read a ton of tutorials on the topic, but it's a little beyond me I guess?
10:44:37 <monochrom> it is.
10:45:27 <geekosaur> newtypes hide details of an existing type so you can do something else with them.  one example:  there are two possible monoids on Integer:  0,(+) and 1,(*).  but you can have only one Monoid instance for a type.  so we have newtypes Sum and Product and declare a separate Monoid instance for each.  The distinction between Integer and the newtypes exists only in the compiler; there is no runtime cost to them, no constructor unwrapping or etc.
10:45:56 <geekosaur> (it's slightly more complicated than that but that's the gist)
10:45:57 <jix> quickcheck question: if I have some 'makeBar :: Foo -> Bar' where some Foos are invalid inputs how can I check that makeBar errors for all of them... I have an Arbitrary for invalid Foos but I can't see a way to check that it errors on _all_ of them... expectFailure only checks that it errors on at least one
10:46:34 <BlindRadish> so a newtype lets the compiler know stuff about a potential use of a type?
10:47:55 <geekosaur> no, just hides something you're doing so you can also do something else with them.  again, the key in the example is that you cannot have a type be two Monoids at the same time, so at least one of them must be "hidden" so it pretends to be a different type
10:48:10 <geekosaur> we chose to hide both so there's no argument over which one gets to be "the" Monoid
10:48:31 <mauke> did you just try to explain newtype in terms of instances to someone who doesn't know what typeclasses are?
10:48:42 <geekosaur> probably, yes
10:48:47 <BlindRadish> you would make a newtype of Foo... that isn't invalid?  and throw an error or whatever if it isn't that newtype?
10:48:54 <geekosaur> huh?
10:48:57 <geekosaur> no
10:49:19 <BlindRadish> lol
10:49:21 <geekosaur> if you have one finger, you can;t stick it in two different holes at the same time
10:49:35 <geekosaur> a newtype "clones" the finger
10:49:50 <BlindRadish> you can if you line them up? ;)
10:50:01 <Hafydd> Now that's an explanation on my level!
10:50:18 <BlindRadish> so a newtype takes a type and makes a... newtype out of it?  and then changes it?
10:50:20 <mauke> you can only stick one finger in one hole. a newtype clones the hole. (hah!)
10:50:43 <geekosaur> you could argue that as well; that's the problem with oversimplified analogies :)
10:50:52 <BlindRadish> why would you clone the hole and not the finger?
10:51:13 <mauke> because now you can't get around the restriction by lining things up
10:51:14 <BlindRadish> nope, you lost me. :)
10:51:42 <mauke> a newtype is like an existing type but wearing glasses and a fake mustache
10:51:49 <mauke> and a sign saying "you've never seen me before"
10:52:04 <elliott> @remember mauke <mauke> a newtype is like an existing type but wearing glasses and a fake mustache  <mauke> and a sign saying "you've never seen me before"
10:52:04 <lambdabot> It is stored.
10:52:05 <jix> having a HUnit Assertion as a QuickCheck Testable would soulve my problem
10:52:17 <andytjoslin> hello!
10:52:32 <BlindRadish> oh so a newtype lets an Int pretend its a product?
10:52:39 <elliott> um...
10:52:39 <BlindRadish> its like a disguise?
10:52:41 <mauke> what's a product?
10:52:53 * elliott thinks these analogies have outlived any usefulness to BlindRadish they may have had
10:52:53 <BlindRadish> not a sum??
10:52:54 <geekosaur> they're referring back to my Monoid example
10:52:59 <typoclass> andytjoslin: hello
10:53:05 <andytjoslin> i'm new - i'm reading learnyouahaskell, and i'm trying to rewrite sum and it's giving me a weird error: http://d.pr/i/oOAX
10:53:05 <mauke> forget monoids
10:53:11 <andytjoslin> i really dunno what that error means
10:53:31 <BlindRadish> hi andy, i'm new too!
10:53:32 <andytjoslin> what am id oing wrong
10:53:34 <andytjoslin> cool :-D
10:53:36 <mauke> andytjoslin: (a ~ b) means "the type a is equal to b"
10:53:46 <mauke> andytjoslin: it's talking about line 40, your type signature
10:54:17 <mauke> given the code in line 42, the types 'a' and 'b' must be the same
10:54:24 <mauke> but in your type signature they're different
10:54:40 <geekosaur> wghat that error means, prctically, is "what the heck is a b?  you didn;t tell me, but you're using it as if it's the same as a"
10:54:47 <andytjoslin> hmm i see
10:54:53 <geekosaur> s/ a b/ b/
10:54:56 <andytjoslin> so i need to say b is a num too
10:55:00 <geekosaur> no
10:55:07 <geekosaur> because you'd still be trying to use it as if it's a
10:55:14 <mauke> andytjoslin: no one said anything about Num b
10:55:29 <andytjoslin> yeah, i thought it would infer b is a num in this case since i'm adding
10:55:38 <andytjoslin> so what's my problem, i still don't understand sorry lol
10:55:41 <mauke> that's true but incomplete
10:55:48 <latro`a> the numerical operations are done on numbers of the same type
10:55:51 <mauke> andytjoslin: it infers b = a since you're adding
10:55:53 <geekosaur> if you're trying to say "magically convert this to whatever the caller wants", you can't do it that way
10:55:57 <latro`a> (+) :: Num a => a -> a -> a
10:56:14 <mauke> sum' (x:xs) = x + sum' xs
10:56:23 <mauke> both arguments of (+) must have the same type
10:56:27 <mauke> x is an element of the input list
10:56:32 <mauke> x :: a
10:56:32 <andytjoslin> right
10:56:33 <andytjoslin> ok i see
10:56:35 <mauke> sum' xs :: b
10:56:41 <andytjoslin> in this case the right side is unknown
10:56:43 <mauke> therefore a = b
10:56:50 <andytjoslin> the sum' xs
10:57:05 <mauke> it's known to be the same type as x
10:57:19 <geekosaur> right, but you can't do that; the compiler needs to know what it is, and in this case it infers a.  but you have this b thing there instead
10:57:24 <typoclass> andytjoslin: just to be sure, when you do "sum' (x:xs) = ...", you're naming the argument to the function (optionally you can leave out the name). when you do "sum' :: ..." you're not naming arguments
10:57:37 <andytjoslin> right
10:57:43 <andytjoslin> top is the type definition
10:57:55 <andytjoslin> ok so i jsut need to make its type of return a
10:57:56 <YayMe`> Is it common or idiomatic to use kleisli composition to create state machine that is executed deferred?
10:57:59 <andytjoslin> because it knows a is a num?
10:58:16 <andytjoslin> that worked!
10:58:18 <latro`a> more because the return type and input types of (+) are the same
10:58:21 <mauke> no, because it knows sum' returns 'a'
10:58:23 <YayMe`> granted everything in haskell is deferred
10:58:38 <typoclass> andytjoslin: yes, first line is the type signature. so because you introduced 'a' and 'b' in the type signature, the compiler thinks you're talking about two separate types, and that causes the error
10:58:38 <andytjoslin> ok
10:58:47 <andytjoslin> yeah, that makes sense
10:58:50 <YayMe`> but with kleisli composition you can create the state machine with none of the values so the values can be handed in later
10:58:54 <andytjoslin> thanks a lot guys, got it to compiole now
10:59:13 <andytjoslin> compile *
10:59:34 <BlindRadish> anyone else use programmer's notepad?
10:59:36 <YayMe`> (if I understand it correctly, is there a different term people use for kleisli bind operator?)
10:59:50 <YayMe`> BlindRadish: emacs isn't programmers notepad?
10:59:56 <YayMe`> :)
10:59:58 <andytjoslin> @BlindRadish vim all the way :-D
10:59:58 <lambdabot> Unknown command, try @list
11:00:00 <BlindRadish> :D
11:00:13 <BlindRadish> emacs and vim confuse me.
11:00:28 <Jaxan> sublime text for me
11:00:31 <YayMe`> they confuse everyone until you use it for a week without letting yourself not use them
11:00:34 <BlindRadish> I like to type and press run and spare me all the goodies cuz its just information overload to me.
11:00:51 <YayMe`> Jaxan: have you found a haskell-mode type behaviour in sublime text?
11:01:03 <andytjoslin> yeah, there's a "my brain hurts" time for a few days when you start emacs or vim
11:01:07 <andytjoslin> but all the hotkeys will save you time
11:01:11 <BlindRadish> I'm sure I'll give it a whirl /after/ I can actually program at all. <3
11:01:25 <andytjoslin> haha, good idea!
11:01:44 <YayMe`> andytjoslin: plus the hotkeys become a part of your brain so instinctively, when I'm at work in visual studio I find myself hitting emacs chords not thinking about it
11:01:54 <BlindRadish> hotkeys is a contact sport.
11:01:55 <andytjoslin> haha yeah
11:01:57 <Jaxan> YayMe`: I have some autocompletion and such, if that's what you mean?
11:02:31 <YayMe`> Jaxan: in emacs ctrl+c ctrl+c loads my current haskell file into GHCi in a window docked below my file
11:02:38 <geekosaur> fwiw there is an extension in the works which would let you say _ there and the compiler will figure out that it has to fill that "hole" with the type a.  at present, you can't do that; if you just stick a random type variable there, the compiler will take that as a statement that it's a different type from any other type mentioned in the signature
11:02:46 <YayMe`> Jaxan: Plus I can hoogle from emacs
11:03:08 <Jaxan> YayMe`: I don't think it exists yet, but of course you could make that ;)
11:03:18 <YayMe`> Jaxan: There's a hand full of other haskellish effects emacs haskell-mode has but those are the ones I mostly use. Also it has syntax highlighting that knows about haskell
11:03:37 <YayMe`> Jaxan: I know you could make it, I was asking if you found some scripts that did it. I quite like sublime-text
11:03:53 <Jaxan> I don't do haskell a lot, so I didn't search for it
11:04:00 <YayMe`> it knows how to tab things for haskell to line them up after where's etc
11:04:04 <YayMe`> ah ok
11:04:16 <BlindRadish> okay I got an error!
11:04:21 <ikarus-> in here completion and argument hints do not work on function I defined. anyone got those working in emacs?
11:05:04 <BlindRadish> "main = (lfsr 1 1) :: Word32" fails - with do or without Word32, but "> lfsr 1 1" succeeds
11:05:07 <ikarus-> it only works for built in functions
11:05:07 <YayMe`> ikarus-: my haskell-mode works fine in emacs but I'm not familiar with the functionality you're referring to. Is it something you tried to put in yourself?
11:05:16 <YayMe`> ikarus-: Did you try to get auto-completion for haskell?
11:05:51 <geekosaur> BlindRadish, main has to be in the IO monad
11:06:08 <BlindRadish> oh it doesn't work if i rename main either
11:06:25 <YayMe`> BlindRadish: Not a programmer? Is Haskell your first language?
11:06:29 <BlindRadish> oh it does work!
11:06:46 <ikarus-> YayMe I am using ghc-complete
11:06:50 <YayMe`> (and if you're not a programmer, start with sublime-text, it's easy to use unlike emacs and vim and very pleasant on the eyes as well as being full featured)
11:06:54 <BlindRadish> I've programmed a bit with C, C++, Java, AS3, Lisp, Lua <3, uh.. Scheme a little bit.
11:07:08 <BlindRadish> I am useless as a programmer though lmao.
11:07:35 <YayMe`> Is this just a hobby?
11:07:37 <BlindRadish> lets see, what else?  Visual Basic.
11:07:37 <typoclass> BlindRadish: don't worry, you're in the right place in here =)
11:07:44 <BlindRadish> Others.
11:08:00 <YayMe`> BlindRadish: Well throw out everything you know about those languages. None of it applies in haskell. Completely different.
11:08:18 <BlindRadish> I couldn't ever learn any of them, so I ended up trying to roll my own.  Learned a lot.  Couldn't learn LLVM though, so I couldn't do anything with the design. Lol.
11:08:21 <YayMe`> BlindRadish: Luckily you don't know those languages well it sounds like so you at least won't be confused why haskell doesn't work like them
11:08:37 <BlindRadish> thats the plan
11:08:46 <BlindRadish> learn the functional first, so I won't be corrupted.
11:08:48 <andytjoslin> i'm learning haskell for my game ai class
11:08:52 <andytjoslin> i want to write ai in haskell
11:08:55 <andytjoslin> because functional seems better for it
11:08:56 <YayMe`> Heh well if you couldn't learn them you may find Haskell even harder
11:09:00 <BlindRadish> I love AI and procedural generation
11:09:26 <BlindRadish> one day I'm going to make ALife simulation games and weather games.
11:09:37 <andytjoslin> they wanted us to use java for it but i started dying after a couple hours of trying it in java <_<
11:09:46 <andytjoslin> nice radish :-)
11:09:51 <BlindRadish> but I'm not going to try to simulate reality, just complex systems that can be visualized and support evolution.
11:09:52 <andytjoslin> haskell is a great way to start for that
11:09:54 <andytjoslin> it seems so far anyway
11:09:56 <BlindRadish> surreality.
11:10:05 <YayMe`> haha yeah, sad that schools are mostly all java organizations
11:10:14 <BlindRadish> Java is so stupid
11:10:24 <BlindRadish> functors!  yay!
11:10:44 <BlindRadish> you're doing the whole "everything is an object" thing wrong. ^^
11:11:17 <andytjoslin> lol
11:11:40 <hayashi> mnn, our uni needs to be less java enterprise drudgery preparation academy
11:12:27 <BlindRadish> like, I get the whole putting up walls so the programmer can't hurt himself thing, but why throw out a pure system for an impure one?
11:12:28 <andytjoslin> yeah.. mine's like that too
11:12:35 <andytjoslin> but i think my current prof will let me use haskell, he seems real chill
11:12:37 <BlindRadish> or at least, improper.
11:12:55 <BlindRadish> run it by him before you get too invested, andy!
11:14:10 <andytjoslin> hehe i'm already invested
11:14:18 <andytjoslin> i got half of the homework done in java though before i switched, and i just emailed him
11:14:22 <andytjoslin> worst case i learn haskellfor fun :p
11:14:31 <andytjoslin> but i love it already
11:15:02 <BlindRadish> this is what confuses me about Haskell: when I say "test = (lfsr 1 1) :: Word32, what am I referring to as Word32?
11:15:21 <andytjoslin> test
11:15:26 <andytjoslin> i think
11:15:31 <andytjoslin> i think = function will run before :: function
11:15:32 <YayMe`> BlindRadish: (lfsr 1 1)
11:15:38 <andytjoslin> yeah
11:16:01 <YayMe`> BlindRadish: You're claiming (lfsr 1 1) _is an element of_ Word32
11:16:13 <YayMe`> remember declarative programming
11:16:16 <BlindRadish> oh that decomposes into a result (namely 1) and then 1 is of the type Word32?
11:16:23 <YayMe`> you're not telling it what to do, you're telling it what something _is_
11:16:44 <BlindRadish> hmm.
11:16:48 <YayMe`> in (lfsr 1 1) :: Word32 you can read the "::" as _is_
11:17:18 <YayMe`> or rather "is a member of the type"
11:18:16 <tac> "is of type"
11:18:20 <tac> "has type"
11:18:27 <tac> "is an element of"
11:18:31 <tac> "is a point in"
11:18:34 <tac> all good translations
11:19:12 <BlindRadish> okay so the next thing I want to do is make two types and a tuple type, Word32, Word32, and (Type1, Type2) which is the actual one I need State of.  How do I do that?
11:20:05 <BlindRadish> I'm gonna test my lfsr+ with the opengl, cuz I actually got that up and running! :D
11:20:14 <BlindRadish> graphs, graphs everywhere!
11:21:25 <andytjoslin> getting another weird type error: http://d.pr/i/dn4N - why can't i compare a when i give a as Num?  i thought Num is always in Ord
11:21:35 <andytjoslin> i tried their suggestion too and it didn't work (since it doesn't know ord is a number for the 1)
11:22:02 <mauke> what do you mean by "tried their suggestion"?
11:22:08 <andytjoslin> in the compile error
11:22:13 <mauke> ...
11:22:15 <andytjoslin> they say to try declaring a of type Ord
11:22:19 <Jeanne-Kamikaze> simply because Num does not imply Ord
11:22:21 <andytjoslin> haskell :: (Ord a) => a -> String
11:22:23 <mauke> YES WHAT DID YOU DO?
11:22:27 <mauke> ok thanks
11:22:45 <mauke> andytjoslin: it says "add (Ord a) to the context", not "replace Num a by Ord a"
11:22:59 <andytjoslin> ah, i can do multiple types in a context?
11:23:10 <mauke> no, multiple constraints
11:23:18 <cmccann> foo :: (Num a, Ord a) => ...
11:23:23 <mauke> each of which involves a class and one or more types
11:23:28 <andytjoslin> ok
11:23:41 <andytjoslin> that works, thanks
11:23:45 <cmccann> you can also remove the type signature and see what gets inferred.
11:23:50 <andytjoslin> ah..
11:23:52 <mauke> yeah, that's probably easiest
11:23:56 <andytjoslin> that may be a good idea for such a simple thing
11:24:11 <andytjoslin> yeah ok, it infers the same thing thanks
11:24:12 <BlindRadish> wait what is =>?
11:24:26 <cmccann> if you're not using really weird GHC extensions, it will figure out basically everything for you.
11:24:32 <cmccann> be lazy, let GHC do the work for you.
11:24:34 <andytjoslin> nice
11:24:40 <andytjoslin> ok
11:24:45 <BlindRadish> I kind of get -> but I never get why function this that :: a -> a -> a
11:25:04 <Jeanne-Kamikaze> the lurking eye will always figure the types for you
11:25:06 <cmccann> BlindRadish: both "::" and "=>" are syntax
11:25:17 <mauke> BlindRadish: the magic word is "currying"
11:25:28 <cmccann> "foo :: bar => baz" means that "foo" has type "baz" with a constraint context "bar"
11:25:35 <BlindRadish> oh so chaining -> lets you curry like a boss?
11:25:59 <mSSM> In my local xmonad sandbox I ran a `cabal-dev update'. I am wondering now how to make an upgrade/install of all the new packages?
11:26:02 <cmccann> and yes, (->) is right-associative, so "a -> b -> c" is "a -> (b -> c)". that is, a function returning a function.
11:26:02 <BlindRadish> could you explain constraint context or do I want to look it up?
11:26:12 <Jeanne-Kamikaze> BlindRadish: more like functions are automatically curried
11:26:13 <cmccann> BlindRadish: stuff like "Eq a".
11:26:28 <Jeanne-Kamikaze> unlike other lesser "functional" languages
11:26:49 <cmccann> so "Eq a => a -> a -> a" means "a -> a -> a" where "a" is some type with an Eq instance
11:26:53 <cmccann> :t (==)
11:26:54 <lambdabot> Eq a => a -> a -> Bool
11:26:55 <BlindRadish> so haskell simply turns everything into a function with 1 parameter?
11:27:01 <Jeanne-Kamikaze> yes
11:27:02 <YayMe`> cmccann: Yeah I've learned I end up with ten times worse results and more wasted time when I try to identify my types myself. I've gotten to the point of being sincerely annoyed whenever I read somewhere that it's good practice to put in your signatures for you. The compiler will let me know if I do something wrong or it needs a hint, otherwise the sigs just end up being something that will need to be changed as I change my code and are
11:27:02 <YayMe`> things I guess wrong most of the time anyway
11:27:09 <Jeanne-Kamikaze> a -> b -> c = a -> (b -> c)
11:27:10 <mauke> BlindRadish: yes. every function in haskell takes exactly 1 argument
11:27:16 <Jeanne-Kamikaze> and so on for more args
11:27:25 <BlindRadish> man haskell is bad ass
11:27:29 <Jeanne-Kamikaze> indeed
11:27:40 <cmccann> YayMe`: that advice applies only when you know what you want better than you know how to write it.
11:27:58 <cmccann> if the type signature is more likely to be correct than the code, writing it will give you better errors messages if you do something wrong.
11:28:02 <YayMe`> cmccann: Interesting thought
11:28:17 <YayMe`> see and I tend to know how more than what
11:28:20 <mSSM> Hm, or put differently: if I want to update my xmonad, xmonad-contrib, xmobar in my local sandbox, do I need to make a new sandbox??
11:28:24 <mSSM> This seems silly.
11:28:48 <cmccann> YayMe`: learning to think in terms of types that way takes some familiarity with the language.
11:29:24 <YayMe`> cmccann: I'm building that but that's more of a memorization over time type of thing i think, like knowing which types and monads are available in the main libraries
11:29:24 <cmccann> YayMe`: it's the kind of advice experts give because it's good advice for experts to follow, not because it always helps beginners.
11:29:39 <BlindRadish> seems to me like types would be something to add before publishing, rather than as you go.
11:30:02 <srhb> BlindRadish: "publishing?" Yes.
11:30:07 <YayMe`> cmccann: Makes sense. Like the things I share with colleagues on C# but would never give to a fresh junior because it would only confuse him and cause him to do things wrong
11:30:23 <cmccann> YayMe`: yes, you need a basic vocabulary to work with before you can get anywhere. that's one reason it's less helpful for beginners.
11:30:25 <srhb> BlindRadish: Not necessarily before writing. I often end up just adding type signatures after I've written my program.
11:30:27 <BlindRadish> errors... gotta catch em all
11:30:57 <srhb> BlindRadish: If there are type errors, GHC will complain none the less. All GHC does with type signatures is really to read your code, determine its type, and then see if you got the type signature right.
11:31:25 <BlindRadish> I guess there's a time to have them and a time to not.
11:31:32 <YayMe`> cmccann: It's interesting how much you can learn from and with haskell with only scratching the surface. I've got a year under my belt but I've not delved into so much as the main libraries with any depth. More studying the mechanics and concepts for that entire time
11:31:53 <YayMe`> and it has taken that entire time to really understand the mechanics and concepts
11:31:57 <cmccann> srhb: the benefit of having type signatures is that it forces the error to be where you made the mistake.
11:32:03 <BlindRadish> like if something is probably complete, confusing, or volatile, then you want types well defined.
11:32:14 <srhb> cmccann: Yep.
11:32:16 <cmccann> if you let GHC infer everything, it can extrapolate a whole bunch of wrong types and then only get stuck somewhere unrelated.
11:33:14 <BlindRadish> okay so a tuple I can just define like = (type1, type2)?
11:33:19 <geekosaur> well, it's rerlated, but often it's not obviously related...
11:33:27 <BlindRadish> and then catch the return as :: TupleType?
11:33:53 <mauke> "catch the return"?
11:33:55 <srhb> BlindRadish: fsvo of "catch" yes.
11:35:40 <BlindRadish> yeah sorry sometimes one of my brains writes half the sentence and the other one handles the ending...
11:35:43 <YayMe`> cmccann: I read the proposal for reforming monadplus into mzero mplus and mor and I totally got it 100%. That's as far as my understanding is on haskell; the mechanics like that, but the only lib I particularly know is attoparsec. Though understanding the mechanics I've found it quite easy to pick up stuff where I need it. Took me all of a couple minutes reading the mmap docs on hackage and some other file stuff to put together
11:35:43 <YayMe`> something that recursively searched directories for files. Had no questions along the way of how to use them to do it. I like learning the mechanics rather than the libs themselves for that reason, but I end up not knowing the available types when I don't study the libs
11:35:54 <Spockz> I'm on OS X (10.8) with HP2012.4.0.0, why doesn't cabal install cabal-install symlink cabal in the ~/Library/Haskell/bin directory?
11:37:11 <Spockz> Okay, disregard that, apparently it did
11:37:24 <YayMe`> I guess I need to actually have a purpose for haskell (other than file search/replace) before I'll ever really learn the libs.
11:37:40 <BlindRadish> lol
11:37:45 <BlindRadish> try openGL!
11:37:47 <YayMe`> I'll take attoparsec any day of the week over regex
11:38:02 <YayMe`> BlindRadish: Yeah, I've been pondering that but I have no idea what I would bother to do with it
11:38:11 <BlindRadish> I love making levels for stuff, I'm working on a 4X
11:38:26 <BlindRadish> The landscape will play a key role, so I can have lots of fun with generation
11:38:36 <srhb> BlindRadish: OpenGL in Haskell is, well OpenGL. So not very interesting.
11:39:03 <BlindRadish> yeah but its fun to try to generate 3D stuff
11:39:12 <geekosaur> Spockz, sometimes shells are too smart; you should "hash -r" after installing new binaries to make sure the shell notices
11:39:26 <Spockz> YayMe`: try to convert Haskell to OpenCL? :)
11:39:30 <YayMe`> srhb: Kind of my thoughts. I'm mildly curious but, open GL has particular APIs so using it in haskell is probably not much different than another language
11:39:32 <Spockz> geekosaur: I noticed indeed, thanks!
11:39:40 <YayMe`> Spockz: What's OpenCL?
11:39:47 <srhb> YayMe`: Indeed.
11:39:49 <YayMe`> is that for cuda?
11:39:55 <Philippa_> cmccann: so I'm a bit odd by local standards, in that I fill in annotations when I need them to think or when there's a type error I don't grok
11:39:55 <BlindRadish> OpenCL is where you use the GPU to crunch numbers
11:39:57 <Spockz> YayMe`: open source variant http://nl.wikipedia.org/wiki/OpenCL
11:39:58 <Philippa_> (or when it's docs time)
11:40:27 <atrika> hello haskell, why is [x | x <- [0..], x < 10] calculating forever ?
11:40:36 <BlindRadish> 0.. i bet
11:40:37 <srhb> atrika: Because [0..] is infinite
11:40:40 <YayMe`> BlindRadish: Yeah, the cuda stuff. Now that is something Haskell would probably be great for because of the mega-parallelism, but there's a specific language used for that
11:40:44 <BlindRadish> ha! knew it.
11:40:58 <BlindRadish> Wasn't my idea!
11:41:07 <geekosaur> and because the list comprehension does not know that (x < 10) will never return True past the 10th element
11:41:13 <srhb> atrika: the boolean expression at the end does not somehow terminate the evaluation, it "picks out" the elements for which it is true.
11:41:19 <atrika> oh
11:41:29 <atrika> i thougth haskell was smarter than that
11:41:38 <BlindRadish> infinite loops should throw an error without IO inside them.
11:41:49 <srhb> atrika: Halting problem?
11:41:51 <srhb> :P
11:42:00 <Spockz> atrika: it should return the first 10 items though
11:42:01 <srhb> But that's just not how list comprehensions are designed
11:42:03 <applicative> atrika: ghc is wondering whether 121992394 < 10
11:42:03 <cmccann> GHC will throw non-termination exceptions sometimes.
11:42:07 <srhb> atrika: use takeWhile, for instance.
11:42:16 <applicative> <loop>
11:42:18 <atrika> it should check the step
11:42:19 <cmccann> if it finds that forcing a thunk requires that same thunk to already be forced.
11:42:19 <geekosaur> sometimes it is.  but (<) is not builtin magic, it's just an operator and it has to be evaluated for all cases
11:42:30 <atrika> if the step is positive and the current number is higher than the condition
11:42:31 <atrika> stop
11:42:32 <BlindRadish> @cmccann nice
11:42:32 <lambdabot> Unknown command, try @list
11:42:33 <srhb> atrika: What if you want to pick out all even numbers of [1..100]
11:42:41 <srhb> atrika: It would be sad if it stopped at 1.
11:42:51 <BlindRadish> lol
11:42:55 <BlindRadish> :(
11:42:58 <cmccann> not all infinite loops will cause a <<loop>> exception of course (blame Turing)
11:43:05 <Lethalman> apropos takeWhile
11:43:08 <applicative> > [n | n <- [1..], even n]
11:43:10 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
11:43:10 <BlindRadish> Turing is a jerk.
11:43:13 <Lethalman> is there a takeWhile that includes the last element?
11:43:45 <BlindRadish> He's like "its impossible" and now everyone believes certain computations are impossible.
11:43:50 <Lethalman> or better, right the successive element
11:43:53 <atrika> srhb, in this case, it cannot detect it
11:44:00 <YayMe`> geekosaur: (<) isn't an operator, it's a function
11:44:05 <atrika> but the
11:44:12 <cmccann> Philippa_: personally I just enable enough extensions that break type inference that I get in the habit of writing signatures often anyway :P
11:44:14 <YayMe`> cmccann: Is it accurate to say haskell doesn't have operators?
11:44:19 <atrika> smaller than 100 when step = 1 is obvious
11:44:27 <geekosaur> YayMe`, there is no difference in Haskell
11:44:29 <cmccann> YayMe`: define "operators".
11:44:32 <srhb> atrika: You want list comprehensions to be defined otherwise. This is not a question of smartness, but use cases.
11:44:38 <geekosaur> any fucntion is an operator with ``, any operator is a function with ()
11:44:42 <srhb> atrika: Haskell can certainly do what you want, see takeWhile.
11:44:52 <fmap> Lethalman: there is a "takeWhile" that includes everything
11:44:54 <lispy> ?faq Can haskell do what atrika wants?
11:44:54 <lambdabot> The answer is: Yes! Haskell can do that.
11:44:55 <cmccann> > 5 `elem` [1..10]
11:44:57 <lambdabot>   True
11:44:58 <fmap> > break (> 5) [1..10]
11:44:59 <applicative> > let takeLethalman pred xs = takeWhile pred (init xs) ++ last xs in takeLethalman (<3) [1,2,3,4,5]
11:45:00 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
11:45:01 <lambdabot>   can't find file: L.hs
11:45:06 <geekosaur> (whether it makes *sense* to do so depends on the type, of course)
11:45:16 <applicative> woops try again
11:45:30 <BlindRadish> hey can I access the named types in a tuple?
11:45:30 <atrika> >[x | x <- [0..], x < 10]
11:45:31 <Lethalman> fmap, ah ok, no thanks
11:45:42 <YayMe`> cmccann: operators are part of a language that execute operations, in haskell there are no parts of the language that do that, that I can think of?
11:45:43 <Lethalman> applicative, of course one can write its own :)
11:46:00 <YayMe`> cmccann: Are there any parts of the haskell language that explicitly execute operations?
11:46:01 <srhb> atrika: You need to include the space after >
11:46:06 <atrika> > [x | x <- [0..], x < 10]
11:46:09 <lambdabot>  Terminated
11:46:11 <atrika> lel
11:46:20 <lispy> lel?
11:46:26 <applicative> > let takeLethalman pred xs = takeWhile pred (init xs) ++ [last xs] in takeLethalman (<3) [1,2,3,4,5]
11:46:29 <lambdabot>   [1,2,5]
11:46:32 <atrika> ta
11:46:41 <cmccann> YayMe`: anyway, sorry I was distracted for a moment there, I did read what you said earlier. I think picking stuff up as you need is a perfectly reasonable approach.
11:46:48 <atrika> > take 3 (repeat "lel")
11:46:50 <lambdabot>   ["lel","lel","lel"]
11:47:06 <cmccann> YayMe`: I'm still not sure how an operator would differ from a function?
11:47:16 <YayMe`> geekosaur: I would say there is a difference always, and that for someone to think of somthing in haskell as an operator is likely to cause incorrect assumptions about code they read perhaps?
11:47:29 <BlindRadish> or do I have to use fst and snd?
11:47:47 <cmccann> operators in either Haskell or most languages are just functions that are written with infix syntax.
11:47:49 <geekosaur> YayMe`, I don't think many people use the definition of operator that you did.  usually an operator is just an infix
11:47:49 <YayMe`> cmccann: Outside of haskell almost every language has operators as a part of the language spec, haskell is the only language that doesn't have them as a part of the language spec
11:48:10 <cmccann> just most languages bake in a handful of specific infix function names and then don't let you add more, only (sometimes) overload the existing ones.
11:48:37 <YayMe`> exactly. which is the behaviour I think most people expect from "operator"s
11:48:51 <cmccann> also, the standard does specify quite a few operators as part of the standard library! but that's not what you mean. :]
11:48:55 <geekosaur> and the reason Haskell doesn't have predefined operators is because any function named with symbol characters behaves as an operator; there isn't a fixed repertoire of predefined operators that you're stuck with
11:49:28 <cmccann> YayMe`: the closest thing in Haskell would be stuff like (==) or (>>=)
11:49:42 <geekosaur> (where "behaves as an operator" pretty much means "is infix and has a fixity/precedence associated with it")
11:49:46 <atrika> > 0 * 10^10000000000000000000000000000000000000000000
11:49:49 <cmccann> which are "operator" functions defined in the standard and used for translating certain syntactic constructs
11:49:51 <lambdabot>   mueval: ExitFailure 1
11:49:51 <lambdabot>  mueval: Prelude.undefined
11:50:01 <YayMe`> geekosaur: No I love it and understand why they're not built in, iduno it's not a big deal just outside of haskell I percieve operator to mean something different than inside, though that may not be the norm
11:50:16 <YayMe`> may just be me who sees them that way
11:50:30 <cmccann> and you can only "overload" those operators, i.e., write instances for the type class involved.
11:50:47 <YayMe`> cmccann: yeah that's true, is (==) defined in the language? If not, how is it defined heh? Pattern matching?
11:50:57 <cmccann> it's magic.
11:51:00 <cmccann> on primitive types, at least.
11:51:07 <BlindRadish> lol
11:51:19 <Spockz> YayMe`: it is part of the Eq class
11:51:24 <BlindRadish> most people think programming languages work through magic
11:51:29 <cmccann> there's no "instance Eq Int where 1 == 1 = True; 2 == 2 = True; ..." anywhere, trust me
11:51:34 <BlindRadish> and under that, more magic
11:51:40 <Spockz> YayMe`: so no, it is not part of the language per se, it is part of the Prelude though
11:51:44 <BlindRadish> hardware? magic.  really small magic.
11:51:52 <cmccann> in fact, integer "literals" in patterns are actually translated to an equality check.
11:51:54 <YayMe`> cmccann: data Pirate a = Arr a | Plank a ... how do manually derive == there?
11:52:15 <cmccann> YayMe`: with pattern matching, and an Eq instance for "a".
11:52:21 <cmccann> that's also what the automatically derived instance does.
11:52:22 <YayMe`> cmccann: Yeah I know, I already had that conversation with someone about how the primitives are defined etc
11:52:28 <geekosaur> YayMe`, you can check the online Haskell report, it specifies precisely how automatic derivation works
11:52:33 <YayMe`> cmccann: So I was right! Pattern matching is the trick
11:52:36 <cmccann> it's only built-in primitives like Int and Char that use magic.
11:52:48 <BlindRadish> hey someone help me with my tuples? :'(
11:53:08 <cmccann> and (==) is defined in the language because of what I said above about translating "literals" in pattern matches.
11:53:14 <Lethalman> let takeW _ [] = []; takeW p (x:xs) = if not $ p x then [x] else x:(takeW p xs)
11:53:15 <geekosaur> the short version for your case is:  see if the constructor is the same, if it is then see if the associated value is the same
11:53:21 <Lethalman> > let takeW _ [] = []; takeW p (x:xs) = if not $ p x then [x] else x:(takeW p xs) in takeW (<=10) [1..]
11:53:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
11:53:33 <Lethalman> applicative, ^^
11:53:34 <cmccann> YayMe`: since "foo 11 = bar" means something like "foo n | n == 11 = bar"
11:53:44 <geekosaur> BlindRadish, I haven't been able to understand what you are asking, tbh
11:54:20 <BlindRadish> I got everything working but Its saying "the function is applied to two arguments, but its type has only one"
11:54:23 <cmccann> YayMe`: similarly, (>>=) is defined in straightforward ways on most types, with only a few built-in types having magic involved, like IO.
11:54:53 <YayMe`> cmccann: Right. Now I'm curious, since pattern matching is used to define Eq; is Eq used to define pattern matching? so Pirate a instance of Eq where _ (==) _ = False (I know that's bad syntax for instance creatino, I can never remember off hand) would you *never* be able to pattern match on a Pirate then?
11:55:46 <BlindRadish> Oh snap son! I got it!
11:55:49 <cmccann> YayMe`: no, pattern matching itself is primitive.
11:56:39 <cmccann> YayMe`: "case" expressions, lambdas, function application, and a handful of other things are the core of the language.
11:56:46 <YayMe`> Ok, that's kind of interesting then if I wanted to have two things recognized as the same in all comparisons I could define an abnormal Eq for them, but pattern matching would't care that those are supposed to be the same
11:56:54 <cmccann> once you desugar things and ignore what's just defined in standard libraries Haskell is a very small language.
11:57:18 <YayMe`> I know
11:57:20 <cmccann> YayMe`: yes, you can have Eq instances that are not structural equality.
11:57:30 <YayMe`> Which is awesome
11:57:43 <YayMe`> err the language being small that is
11:57:47 <geekosaur> YayMe`, withthe caveat that you can't pattern match against a variable ("case a of b -> ..." does not compare against b, it creates a new b shadowing the old)
11:57:50 <cmccann> that's not even unreasonable, especially if you're not exporting constructors and want different representations of the same value to be equal.
11:58:00 <BlindRadish> so how would I fix this line? "test = map (lfsr (37,37)) :: Lfsr [1..255]"
11:58:13 <BlindRadish> test = map (lfsr (37,x)) :: Lfsr [1..255] **
11:58:19 <Lethalman> do you know if any of the gtk2hs authors hang on irc?
11:58:23 <Lethalman> http://code.haskell.org/gtk2hs/AUTHORS
11:58:53 <geekosaur> BlindRadish, map produces a list, not an Lfsr
11:59:51 <YayMe`> cmccann: Yeah I could totally see a purpose for Eq like that, but it could surely cause confusion to someone trying to pattern match it
11:59:56 <BlindRadish> I need to plug the list into the function over and over.
12:00:26 <cmccann> YayMe`: which is why you generally should only do that with a type where the module that defines it doesn't export the constructors.
12:00:34 <BlindRadish> can I just do lfsr (37,[1..255])?
12:00:42 <YayMe`> ah interesting
12:00:43 <BlindRadish> no that's not right.
12:00:47 <cmccann> e.g. think of Data.Set or Data.Map
12:01:13 <geekosaur> also Lfsr [1..255] is not a valid type; what are you trying to say there?
12:01:21 <cmccann> it would be reasonable for their Eq instance to say things are equal even if the internal tree representation differs. in fact, it'd be bad if they didn't.
12:01:34 <BlindRadish> Lfsr is my tuple
12:01:48 <BlindRadish> it expects a mask word32 and a step word32
12:01:54 <BlindRadish> (mask, step)
12:02:09 <BlindRadish> I need to iterate through my steps and print everything.
12:02:21 <YayMe`> BlindRadish: Why do you have a type signature on that line?
12:02:24 <BlindRadish> I guess I should do recursion.
12:02:26 <applicative> Lethalman: dmwit is a principal committer
12:02:36 <Lethalman> applicative, thanks
12:02:45 <BlindRadish> you guys told me to put it there and it fixed it!
12:02:47 <YayMe`> BlindRadish: and [1..255] is a member of a type, not an actual type
12:03:04 <YayMe`> BlindRadish: It doesn't belong in a type signature (to my understanding)
12:03:33 <BlindRadish> ah crap now I broke it somehow.
12:03:38 <geekosaur> right, that was what I was trying to get at
12:03:39 <BlindRadish> aw*
12:03:51 <YayMe`> BlindRadish: hpaste your code
12:03:56 <YayMe`> hpaste.org
12:04:06 <geekosaur> Lsfr [1..255] is not a valid type; it contains values.
12:04:35 <geekosaur> (there are languages where you can do that but Haskell is not one of them; also, the consequences of it are rather complicated)
12:04:42 <YayMe`> geekosaur: Good, I'm not nuts. I see type signatures sometimes thrown around in here I totally do not understand, but was pretty sure that is not valid in a type signature unless you're talking about agda
12:05:04 <hpaste> BlindRadish pasted “lfsr attempt” at http://hpaste.org/81318
12:05:29 <BlindRadish> god that is awesome.
12:05:51 <cmccann> geekosaur: sadly, range syntax doesn't even work with datakinds, type nats, and promoted lists :[
12:06:32 <BlindRadish> lol no idea what any of those things are
12:06:40 <geekosaur> ^^ gets at what I was about to comment:  you *can* use various kinds of type trickery to encode values in types, but even with the latest experimental type-level values there are limits on what you can get away with
12:07:27 <BlindRadish> So should I just say Mask -> Step -> Mask -> Step or what??
12:07:31 <geekosaur> and even with such encoding, a 1 at the type level is not quite the same thing as a 1 at the value level
12:07:48 <YayMe`> BlindRadish: What are you trying to do with test? It doesn't make sense.
12:08:04 <BlindRadish> get it to compile and print something when i hit test lol
12:08:10 <BlindRadish> :D
12:08:13 <YayMe`> print what?
12:08:20 <BlindRadish> oh it still says map.
12:08:25 <YayMe`> @type map
12:08:26 <lambdabot> (a -> b) -> [a] -> [b]
12:08:30 <BlindRadish> ignore the map
12:08:43 <applicative> scrap map
12:08:44 <YayMe`> You're misusing map
12:08:49 <BlindRadish> well I fixed it!
12:08:51 <BlindRadish> lol
12:08:53 <YayMe`> Oh
12:08:56 <YayMe`> You got rid of map?
12:08:58 <applicative> test = (37,55)
12:09:02 <BlindRadish> okay so how do I get it to iterate?
12:09:07 <YayMe`> iterate what?
12:09:09 <applicative> over what?
12:09:19 <YayMe`> you need a list to iterate
12:09:20 <BlindRadish> [1..255]
12:09:23 <applicative> BlindRadish: you all the lfsrs starting from a seed
12:09:35 <applicative> ?
12:09:36 <YayMe`> BlindRadish: lfsr doesn't take a single number, it takes a tuple
12:09:48 <YayMe`> @type take
12:09:49 <lambdabot> Int -> [a] -> [a]
12:10:07 <YayMe`> >take 10 [(1,1),(2,2)..]
12:10:07 <applicative> take 255 $ iterate lfsr (37,37) -- for example?
12:10:22 <BlindRadish> hmm
12:10:34 <BlindRadish> that sounds right, but I'm still confused.  let me play with that
12:10:43 <YayMe`> > [(1,1)..(10,10)]
12:10:44 <lambdabot>   No instance for (GHC.Enum.Enum (t0, t1))
12:10:45 <lambdabot>    arising from a use of `e_111101...
12:10:47 <geekosaur> > [(1,x) | x <- [1..255]]
12:10:48 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
12:11:13 <YayMe`> was curious if I could make the range do it for me, guess not
12:11:27 <geekosaur> > [(x,y) | x <- [1..3], y <- [1..3]]
12:11:29 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
12:11:55 <YayMe`> BlindRadish: lfsr takes a tuple, it can't iterate over [1..255] because that is a selection of numbers not tuples, it needs a list of tuples to iterate over
12:12:01 <koala_man> can I through parsec and foldM make a parser  'sequentially [string "foo", string "bar"]' that is equivalent to 'string "foobar"'?
12:12:22 <BlindRadish> wait so "map lfsr ([(37,x)|x <- [1..255]])"?
12:12:25 <YayMe`> koala_man: Not sure what you need foldM for there
12:12:39 <BlindRadish> I want to produce a list.
12:13:23 <mSSM> k00mi: Earlier you suggested using whileM' or unfoldrM' together with the Sum monoid for solving my replicateM/sequencing problem - can you expand on that? How do I Get the Sum monoid in there?
12:13:37 <glguy> Cale: You around?
12:13:41 <geekosaur> BlindRadish, probably
12:13:46 <YayMe`> BlindRadish: [ (37,x) | x <- [1..255] ] ... in english is: the list of (37,x) for every x in [1..255]
12:14:06 <koala_man> YayMe`: for fun
12:14:08 <YayMe`> BlindRadish: So that will create a list of tuples you can map over with lfsr
12:14:28 <YayMe`> koala_man: I mean, not sure why you need to use foldM for that if you have parsec
12:15:06 <hpaste> applicative annotated “lfsr attempt” with “lfsr attempt -- simplification” at http://hpaste.org/81318#a81319
12:15:07 <k00mi> mSSM: it doesn't work they way i thought. they use MonadPlus instead of Monoid
12:16:40 <koala_man> YayMe`: again, for fun. I made it sort-of-work, but it turned into nested parsers and was generally awful
12:17:21 <mSSM> k00mi: if I'd use `sum <$> whileM' instead of `sum <$> replicateM', wouldn't I get rid of my sequencing problem?
12:17:27 <mSSM> Or is that defined in terms of sequence as well?
12:18:11 <BlindRadish> :D
12:19:02 <glguy> Cale: nevermind :)
12:20:13 <BlindRadish> so is "let" exactly the same as "while" in every way except location?
12:20:30 <YayMe`> koala_man: something *like* (this is surely not correct) foldM1 (>>= id) parseToEnd "foobar" (\x -> [ y | y <- string "foo" <|> string "bar" ])
12:20:46 <sipa> BlindRadish: you mean where?
12:20:52 <k00mi> mSSM: it can't work. consider Maybe as the monad, whileM' can't return anything until the entire list is produced because a Nothing could come up at some point
12:20:52 <BlindRadish> yeah
12:20:53 <BlindRadish> sorry
12:21:03 <geekosaur> location and scoping; if you use multiple patterns, "where" scopes over all of them
12:21:11 <BlindRadish> ah
12:21:20 <sipa> let is part of expression syntax, where is part of declaration syntax
12:21:23 <BlindRadish> so its only the same if I don't use pattern matchin?
12:21:27 <BlindRadish> matching*
12:21:52 <YayMe`> koala_man: does that make any sense at all?
12:22:08 <koala_man> not entirely
12:22:16 <mSSM> k00mi: So if I see this correctly, explicit recursion is the only thing left to me?
12:22:31 <BlindRadish> god thank you guys, you guys are the best. thank you
12:22:37 <YayMe`> > [["foo"],["bar"]] >>= id
12:22:39 <lambdabot>   ["foo","bar"]
12:22:41 <mSSM> Actually, I am not sure if that makes sense either.
12:23:12 <BlindRadish> all the other "helpful people" just yell at me and make me feel stupid lmao
12:23:38 <YayMe`> BlindRadish: stackoverflow is a great place to ask questions on haskell without getting shachaffed
12:23:42 <koala_man> YayMe`: oh, neat, thanks
12:23:45 <k00mi> mSSM: no, you could use unsafeInterleaveIO like parcs suggested earlier, or you could implement something like whileM' but actually using monoids
12:24:04 <YayMe`> @type foldM1
12:24:05 <lambdabot>     Not in scope: `foldM1'
12:24:05 <lambdabot>     Perhaps you meant one of these:
12:24:05 <lambdabot>       `foldl1' (imported from Data.List),
12:24:13 <YayMe`> @type foldM
12:24:14 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
12:24:35 <YayMe`> @type (>>= id)
12:24:37 <lambdabot> Monad m => m (m b) -> m b
12:25:12 <YayMe`> yeah that's not foldable
12:25:17 <k00mi> mSSM: maybe the monoid version already exists somewhere and i don't know about it, entierly possible
12:25:49 <mSSM> k00mi: But just so I am clear what you are talking about: what would be the advantage of using a monoid version of whileM with the sum monoid?
12:27:19 <YayMe`> koala_man: probably more like \y -> [x | x <- (many1 $ string "foo" <|> string "bar") y ]
12:27:41 <BlindRadish> can I create three variables like "a,b,c = tuple"?
12:27:47 <atrika> hey haskell, why is this not merging the two lists ? http://hpaste.org/81320
12:27:50 <k00mi> mSSM: think of it like the whileM that returs a list, but instead of prepending elements to the list you would sum up the values directly
12:28:01 <BlindRadish> NOT "tuple=a,b,c"
12:28:21 <geekosaur> maybe you want:  let (a,b,c) = myTuple in ...
12:28:32 <geekosaur> which uses a pattern match to take the tuple apart
12:28:38 <BlindRadish> is that the only way?
12:28:43 <mSSM> k00mi: That would actually precisely what I want.
12:28:54 <YayMe`> atrika: What are you trying to do there?
12:28:56 <BlindRadish> i need it in b == 1 and otherwise
12:29:03 <atrika> just playing yayme
12:29:03 <mSSM> k00mi: Or at least it sounds like a solution to my troubles :)
12:29:16 <geekosaur> pattern matches also work in where
12:29:27 <atrika> i expected a list with all the elements
12:29:35 <atrika> [0,0,1,1...
12:29:46 <YayMe`> atrika: right but what result do you want? [0..10] ? or [0,0,1,1,..10,10] ?
12:29:50 <YayMe`> oh
12:29:59 <YayMe`> @type zip
12:30:01 <lambdabot> [a] -> [b] -> [(a, b)]
12:30:30 <BlindRadish> geekosaur: i thought that that was the only difference between let and where.
12:30:41 <k00mi> mSSM: do you have the source to whileM'?
12:31:04 <danr> > concat [ [x,y] | x <- [1..5] | y <- [1..5] ]
12:31:06 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
12:31:14 <geekosaur> BlindRadish, different pattern matching, sorry.  I meant that if you declare a function which has multiple patterns, an attached "where" applies to all of those patterns
12:31:30 <geekosaur> a pattern match *inside* a "where" clause is the same as one in a "let"
12:31:48 <BlindRadish> ah right, "guards" isn't that?
12:32:01 <geekosaur> guards are also part of it
12:32:29 <geekosaur> f [] = ...; f [x] = ...; f (x:xs) = ... where ...
12:32:47 <mSSM> k00mi: I am looking at it (via hackage)
12:32:55 <k00mi> ok
12:33:19 <mSSM> k00mi: it looks like MonadPlus and Monoids are very similar?
12:33:36 <byorgey> mSSM: yes
12:33:38 <k00mi> mSSM: conceptually yes
12:33:49 <byorgey> the only difference is the kinds, really
12:34:43 <k00mi> mSSM: second to last line, delete the second return and replace mplus by mappend or <>
12:34:53 <k00mi> mSSM: fix the types and that should be it
12:35:15 <cmccann> > mplus (Just "foo") (Just "bar")
12:35:18 <lambdabot>   Just "foo"
12:35:20 <cmccann> > mappend (Just "foo") (Just "bar")
12:35:22 <lambdabot>   Just "foobar"
12:36:02 <BlindRadish> so i can build a function and pattern match that function, and put where in the function, and in the pattern of a function, and pattern match inside where??
12:36:20 <BlindRadish> seems a bit excessive.
12:36:56 <S11001001> BlindRadish: you're deriving theorems from general language axioms which result from removing utterly arbitrary restrictions
12:37:15 <YayMe`> > foldr (\y -> \x -> fst y:snd y:x) [] $ zip [0..10] [0..10]
12:37:17 <lambdabot>   [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]
12:37:40 <geekosaur> BlindRadish, no more excessive than (((...(1+1)+1)+1)+...)
12:38:33 <S11001001> that arbitrary restriction is putting "term name" anywhere "pattern" makes sense
12:39:02 <luca> > zipWith (\f,x -> f x)
12:39:04 <lambdabot>   <hint>:1:12: parse error on input `,'
12:39:10 <luca> bah
12:39:45 <luca> whats the lambdabot thing to simplify expressions?
12:40:01 <S11001001> luca: by simplify do you mean put a bunch of .s and flips in it?
12:40:07 <mSSM> k00mi: And I need to return mempty, right?
12:40:11 <simpson> @pl \(f,x) -> f x
12:40:11 <lambdabot> ap fst snd
12:40:13 <geekosaur> there isn't one.  @pl can make expressions arbitrarily complex though :)
12:40:25 <k00mi> mSSM: yes, forgot that
12:40:28 <luca> @pl zipWith \(f,x) -> f x
12:40:28 <lambdabot> (line 1, column 9):
12:40:28 <lambdabot> unexpected '\\'
12:40:28 <lambdabot> expecting variable, "(", operator or end of input
12:40:36 <luca> @pl zipWith (\(f,x) -> f x)
12:40:36 <lambdabot> zipWith (ap fst snd)
12:40:39 <luca> hah
12:40:52 <luca> is there a standard function equivalent to zipWith (\(f,x) -> f x) ?
12:41:07 <int-e> @type uncurry id
12:41:08 <startling> zipWith id
12:41:09 <lambdabot> (b -> c, b) -> c
12:41:15 <S11001001> @ty zipWith (\(f, x) -> f x)
12:41:16 <lambdabot> [(t -> b -> c, t)] -> [b] -> [c]
12:41:21 <geekosaur> :t uncurry ($)
12:41:22 <lambdabot> (b -> c, b) -> c
12:41:26 <mSSM> k00mi: how do I tell haskell now to use the Sum monoid? Right now, I simply have “:: (Monad m, Monoid f) => m Bool -> m a -> m (f a)”
12:41:32 <cmccann> pf, ($) is just id anyway.
12:41:42 <mSSM> k00mi: I.e., this is the general case.
12:41:42 <luca> startling, it's not zipWith id
12:41:49 <riley__> is that the same as zip ($)
12:41:51 <riley__> ?
12:42:04 <startling> luca, oh, you have a tuple? weird
12:42:09 <startling> riley__: yes
12:42:13 <luca> well no, i just didn't know how to type it :P
12:42:23 <startling> luca, what's wrong with zipWith id?
12:42:26 <startling> :t zipWith id
12:42:28 <lambdabot> [b -> c] -> [b] -> [c]
12:42:31 <luca> eg: zipWith (\f,x -> f x) [*2, *4] [1, 2] should give [2, 8]
12:42:41 <k00mi> mSSM: you wrap your values in Sum (from Data.Monoid) and haskell will know you want that instance of Monoid :)
12:42:46 <startling> luca, yep, that's what zipWith id does
12:42:50 <startling> (barring syntax errors)
12:43:05 <cmccann> > zipWith id [(*2), (*4)] [1, 2]
12:43:07 <lambdabot>   [2,8]
12:43:09 <luca> ah
12:43:18 <luca> what the.
12:43:22 <startling> luca: haha
12:43:23 <luca> but isn't id just A -> A ?
12:43:28 <cmccann> yes
12:43:31 <elliott> luca: say a = (b -> c)
12:43:31 <startling> think about what id on (a -> b) does
12:43:34 <elliott> then id is (b -> c) -> (b -> c)
12:43:35 <cmccann> > id (* 2) 1
12:43:36 <lambdabot>   2
12:43:40 <elliott> just like if a = Int, id is Int -> Int
12:43:51 <elliott> and (b -> c) -> (b -> c) is (b -> c) -> b -> c
12:43:52 <elliott> aka
12:43:52 <elliott> :t ($)
12:43:53 <luca> so id can also act like 'apply' or something then :P
12:43:54 <lambdabot> (a -> b) -> a -> b
12:43:55 <elliott> :t zipWith ($)
12:43:56 <lambdabot> [b -> c] -> [b] -> [c]
12:44:10 <startling> luca, no, it's not magic
12:44:12 <cmccann> luca: more that function application is the identify function on functions, written infix :P
12:44:19 <luca> hahah
12:44:20 <int-e> > id id id 5 -- figure out the type of the first 'id' here :)
12:44:22 <lambdabot>   5
12:44:22 <cmccann> wow that sounded confusing.
12:44:24 <k00mi> mSSM: also, the type should be (Monad m, Monoid a) => m Bool -> m a -> m a
12:44:45 <mSSM> k00mi: yes, thanks makes sense.
12:45:49 <mauke> :t ?id id id 5
12:45:50 <lambdabot> (?id::(a -> a) -> (a1 -> a1) -> a2 -> t, Num a2) => t
12:45:56 <mauke> do not want
12:47:13 <mSSM> k00mi: Wow, since yesterday I have come to work and make Functors, Applicatives and now Monoids thanks to you. I can almost claim not to be a Haskell greenhorn! :D
12:48:51 <k00mi> mSSM: congrats, monoids are really awesome and quite simple really, just like applicative :)
12:49:32 <parcs> mSSM: did you solve the replicateM issue?
12:49:57 <mSSM> parcs: Nope, but I am getting there.
12:50:20 <mSSM> parcs: k00mi has suggested how to resolve it: I will redefine whileM' in terms of a Monoid.
12:50:45 <mSSM> That should allow me to spit out a IO Sum right away, so that I don't have to sum <$> replicateM
12:52:11 <c_wraith> mSSM: you might also consider writing it in terms of replicate and foldM.
12:53:03 <parcs> mSSM: in this case i think unsafeInterleaveIO is your best choice
12:53:15 <BlindRadish> wait so how do I pattern match from within "where x = [pattern match]"?
12:53:24 <mSSM> parcs: I am really not sure how to do that.
12:53:40 <c_wraith> BlindRadish: ... where [pattern] = expression
12:54:09 <BlindRadish> big "oh"
12:54:11 <parcs> mSSM: http://hpaste.org/81324
12:54:17 <BlindRadish> brain click
12:55:01 <mSSM> parcs: Can you explain the effect that this sequence definition has?
12:55:27 <YayMe`> anyone here who knows OO/SOLID well?
12:55:33 <mSSM> parcs: Also, why would you think that doing what you suggest is a better idea than making a new whileM' ?
12:55:46 <BlindRadish> whats a good word for "number of times I can get away with doing this?"
12:56:02 <BlindRadish> like from the build up of error, for example.
12:56:03 <YayMe`> BlindRadish: politician?
12:56:09 <BlindRadish> :D
12:56:13 <BlindRadish> don't get me started
12:56:20 <YayMe`> filter
12:56:33 <mauke> threshold
12:56:38 <BlindRadish> my president looks suspiciously like a dictator
12:56:38 <YayMe`> gate
12:56:55 <parcs> mSSM: unsafeSequence is like sequence except that the IO actions are only evaluated as needed, not all at once
12:56:58 <mSSM> c_wraith: I am not sure that that will help me; have a look at what I posted earlier today: “sum . scanl (+) 0 <$> (replicateM n $ sum <$> (replicateM l $ foo gen))”, where “foo gen” gives me a `Num a => MTGen -> IO a' (random number).
12:57:56 <c_wraith> wow, that's some crazy nesting
12:57:58 <parcs> mSSM: i can't say whether this solution is better than whileM but it's definitely a simpler solution
12:58:26 <parcs> mSSM: it involves minimal changes to your existing (compositional) code
12:59:08 <mSSM> c_wraith: foo gives me some random numbers, the sum of which is a delta of some property of my system.
12:59:19 * elliott wonders how mSSM's problem is so terrible that unsafeInterleaveIO is the best solution.
13:00:20 <mSSM> c_wraith: now, I need n such deltas, so that the scanl gives me [x0, x0+d1, x0+d2, ...]
13:00:25 <mSSM> oops
13:00:28 <mSSM> I mean
13:00:28 <k00mi> the problem is mainly that he doesn't want a list to build up but process the values directly, if i understood correct earlier
13:00:42 <mSSM> [x0, x0+d1, x0+d1+d2,...]
13:00:56 <mSSM> k00mi: Yes, that would be entirely reasonable.
13:01:03 <YayMe`> No one here who knows OOP/SOLID well to help me think through something?
13:01:37 <c_wraith> well, I was looking at « \n -> foldM (\a b -> do { b' <- b ; return $! a + b' }) 0 . replicate n » as a replacement for « \n -> fmap sum . replicateM n »
13:02:07 <c_wraith> Which doesn't really work as a scanl replacement, though
13:02:20 <mSSM> Now after I have created this list [x0, x0+d1, x0+d1+d2,...], I actually do “sum . map f $ myList”.
13:02:27 <monochrom> Simon Marlow's talk and package "async" is really simple and nice. http://skillsmatter.com/podcast/home/high-performance-concurrency/ac-5258 and also check hackage. async will be in Haskell Platform!
13:03:39 <mSSM> So in the end I want “sum [f x0, f x1, f x2, f x3,....]” and so on.
13:04:39 <BlindRadish> hey how come .&. is infix but xor is prefix?  that's confusing.
13:04:52 <c_wraith> it's just syntactic
13:04:59 <mauke> it's syntactically confusing
13:05:06 <c_wraith> things that are made of symbols are operators, and thus infix.
13:05:14 <c_wraith> things made of letters are functions, and therefore prefix
13:05:26 <mauke> so how come xor is made of letters?
13:05:35 <dmwit> because ^ was already taken
13:05:39 <dmwit> lol
13:05:39 <c_wraith> Good question.  No reason they couldn't have named it .^.
13:05:42 <mauke> dmwit: so was |
13:05:54 <parcs> how come shift[LR] is made of letters?
13:06:09 <mauke> because >> was taken
13:06:19 <parcs> i like .>>. anyway
13:06:21 <cmccann> hm, .^. looks like an upside-down emoticon.
13:06:53 <mauke> ok, but this situtation is more like having .<<. and shiftR
13:07:38 <mSSM> parcs: damn, your unsafeReplicateM has just blown the speed of my simulation out of the water.
13:08:01 <parcs> yay!
13:08:47 <BlindRadish> lol
13:09:53 <mSSM> parcs: C is still faster, but this is really good.
13:10:26 <BlindRadish> yay! i refactored my code! it still looks like crap though.
13:10:30 <BlindRadish> :D
13:10:40 <parcs> mSSM: by how much?
13:11:46 <mSSM> parcs: haskell is 5 times slower
13:11:55 <mSSM> parcs: 35s on haskell vs 7 on C
13:11:59 <parcs> what if you replace sum with sum' = foldl' (+) 0
13:12:11 <acowley> I don't suppose jwiegley on github frequents #haskell?
13:12:31 <byorgey> acowley: yes, as johnw
13:13:14 <byorgey> uh, at least I think so, but it just occurred to me that there might be two John W's =)
13:14:02 <mSSM> parcs: Hm, the sum on the right is actually working on a (Int,Int) tuple, for which I have: sum2 = foldl' (\(x1,y1) (x2,y2) -> (x1+x2,y1+y2)) (0,0)
13:14:35 <mekeor> is there a function 'f :: Double -> String' such that 'f 1 == "1"' (unlike 'show (1 :: Double) == "1.0")
13:14:50 <mekeor> ?
13:14:52 <mSSM> parcs: The sum on the left actually acts on a data structore `data Foo a = a a a a a a a', which I have made an instance of Num, Functor, and Applicative.
13:15:03 <byorgey> mekeor: yes, show . round =P
13:15:16 <mSSM> parcs: I suppose if I make it an instance of Foldable, I should be able to make a sum in terms of foldl' ?
13:15:20 <mekeor> byorgey: yeah, but i don't want it to round 1.5 or so… :P
13:15:26 <parcs> mSSM: ooo, bad
13:15:29 <S11001001> @ty 0
13:15:31 <lambdabot> Num a => a
13:15:35 <byorgey> mekeor: hmm, I don't know then
13:15:43 <mekeor> byorgey: so, 'f 1.5 == "1.5"' ... :) okay, fine
13:15:44 <parcs> mSSM: try foldl' (\(!x1,!y1) (!x2,!y2) -> ..)
13:15:48 <edwardk> uhoh, tekmo has decided lens is too big. the party was nice while it lasted but now i have to split it up into a dozen packages because someone complained.
13:16:05 <byorgey> edwardk: "have to"?
13:16:07 <edwardk> or… not
13:16:07 <parcs> mSSM: you don't even need foldl' anymore, just use foldl
13:16:16 <edwardk> byorgey: https://github.com/ekmett/lens/issues/262
13:16:29 <parcs> mSSM: er sorry, just put bang patterns within the first tuple (x1,y1) not the 2nd
13:16:30 * mekeor might have to do 'f x = if round x == x then show (round x) else show x' or so…
13:16:41 <edwardk> byorgey: sarcasm doesn't come across the internet very well ;)
13:16:41 <S11001001> mSSM: looks like 0 :: Foo Int, 0 :: Foo (Foo (Foo Int)), etc should unify
13:17:07 <mSSM> parcs: Why do I not need strict foldl?
13:17:28 <mSSM> parcs: Ok, the new sum on the tuple is at 31s now.
13:17:32 <parcs> mSSM: because you're already evaluating the accumulator to WHNF by pattern matching on the tuple constructor
13:17:44 <byorgey> edwardk: hehe
13:17:51 <acowley> edwardk: That's why I'm uniformly sarcastic. It's out of respect for others.
13:18:01 <mSSM> S11001001: I have no idea what you are saying. :)
13:18:10 <dwins> byorgey: Text.Printf can help you with that double formatting
13:18:36 <S11001001> @ty foldl' (+) 0
13:18:38 <lambdabot> Num b => [b] -> b
13:19:16 <mSSM> parcs: Oh, that means I don't need to make Foo an instance of foldable?
13:19:36 <parcs> mSSM: does what mean that?
13:19:49 <mSSM> parcs: sorry, wrong person
13:19:52 <mSSM> parcs: I meant S11001001
13:19:55 <mSSM> ^^
13:20:01 * mSSM getting all confused.
13:20:19 <parcs> mSSM: try adding bang patterns to all the 'a's in Foo's constructor definition
13:20:28 <S11001001> mSSM: I assume your Num (Foo a) is just instance Num a => Num (Foo a), right?
13:20:30 <byorgey> dwins: it was mekeor who wanted that, not me
13:20:39 <mSSM> S11001001: yes
13:20:48 <mSSM> parcs: Already did so.
13:20:57 <dwins> oops, sorry about that.
13:21:06 <S11001001> mSSM: therefore (0 :: Foo (Foo Int)) evaluates to Foo (Foo 0) (Foo 0) (Foo 0) (Foo 0) (Foo 0) (Foo 0) (Foo 0)
13:21:16 <S11001001> mSSM: so foldl' (+) 0 works on it
13:21:41 <parcs> mSSM: what is the 'a' in Foo, usually?
13:21:52 <S11001001> (in the above example, where the 0s in the result are Ints)
13:21:54 <mSSM> parcs: Usually it's Int
13:22:01 <mSSM> parcs: until the very end, where it becomes a Double
13:22:41 <mSSM> Too bad S11001001 is gone, I wanted to ask him about that Foo stuff. :(
13:23:14 <parcs> mSSM: for maximum speed you should make 2 data specialized versions for Foo, one for Int and one for Double, whose arguments are unpacked
13:24:49 <lispy> totally off topic, anyone here used spec cpu2006 before?
13:25:13 <acowley> Anyone know if c2hs can have its version constraint on language-c relaxed? (I'm compiling things now and it's taking a while)
13:25:43 <lispy> acowley: I usually try it and find out that way...not the best idea if you're shipping code though.
13:26:22 <edwardk> byorgey: warning: lens internally picked up a (#).
13:26:22 <edwardk> well, its in the public api.
13:26:29 <acowley> lispy: Yeah, I'm trying it out. But there aren't any tests, so if it compiles and then later on something doesn't work, I'll be lost
13:26:30 <mSSM> parcs: what does that actually mean? Should I make a “FooInt” and a “FooDouble” ?
13:26:44 <edwardk> i tried hard to leave that one untouched, but in the end it fell
13:27:52 <monochrom> time to use ♥ ♠ etc :)
13:28:27 <edwardk> monochrom: hrmm =) we already use unicode in the comments.
13:28:42 <edwardk> its only a small step to operators… really nobody would mind...
13:28:53 <parcs> mSSM: yeah, ie data FooInt = FooInt {-# UNPACK #-} !Int {-# UNPACK #-} !Int ....
13:28:57 <monochrom> at least internal ones
13:28:58 <BlindRadish> I wish keyboards weren't limited to ASCII
13:30:06 <BlindRadish> give me hexagonal keys with color coded shift and eight symbols per button! <3
13:30:45 <BlindRadish> or seven... no black keys lol.
13:31:17 <monochrom> the cause-effect relationship is that ASCII simply took what was on the keyboard. therefore, there is no such thing as keyboard limited to ASCII
13:31:51 <monochrom> that is, if the American keyboard had 1000 characters, ASCII would have them too
13:32:09 <cmccann> ah, if only APL had caught on.
13:32:21 <k00mi> the neo layout has a layer for the greek alphabet :)
13:32:34 * `nand` doesn't see the connection between keyboards and encodings
13:33:08 <`nand`> if you want a different keymap, use a different keymap? I guess the only thing you can't readily change is the number of physical keys or their layouts
13:33:22 <mSSM> There are keyboards with ISO layouts.
13:33:25 <mSSM> Therefore BlindRadish is disproven.
13:33:27 <mSSM> :D
13:34:05 <mSSM> parcs: Well, my file looks kinda ugly right now, but let's see if this beast runs faster now. ;)
13:34:06 <`nand`> mSSM: as opposed to..?
13:34:28 <mSSM> `nand`: what?
13:35:15 <mSSM> `nand`: I mean, there are keyboards which obviously have a different layout/other characters - therefore keyboards are not limited to ASCII.
13:35:22 <mSSM> Your point with keymaps remains valid.
13:35:31 <hpaste> jsteel pasted “xmonad.hs” at http://hpaste.org/81327
13:35:42 <BlindRadish> well ASCII is pretty established.
13:35:56 <mSSM> BlindRadish: not in Europe?
13:36:04 <BlindRadish> I GOT IT!  digital keyboards.
13:36:16 <linduxed> if i've got this kind of repo https://github.com/linduxed/progp-molbio
13:36:19 <BlindRadish> customizable pages
13:36:23 <mSSM> Digital keyboards are crap.
13:36:30 <BlindRadish> nah man, science.
13:36:33 <mSSM> BlindRadish: Use fn layers.
13:36:35 <acowley> The answer is: no, c2hs does not work with newer language-c
13:36:38 <linduxed> and the file molbio.hs mostly serves as a file with tests in it, should i rename it to tests.hs?
13:36:48 <linduxed> or is there some more canonical way of doing it?
13:36:52 <BlindRadish> thousands of fn layers
13:36:54 <BlindRadish> customizable
13:37:11 <BlindRadish> with buttons that show you each symbol
13:37:19 <monochrom> the real solution is USB 3.0 port directly to your head
13:37:29 <BlindRadish> plug and play
13:37:31 <mSSM> BlindRadish: Google OptimusMaximus keyboard.
13:37:37 <BlindRadish> i'd hate to get awkward viruses
13:37:41 <DeadPanda> why bother?  it's more efficient for the chinese to encode their language in Pinyin than to mess around with that stuff, and they've got the worst of it
13:38:00 <`nand`> the optimus maximus is most likely among the worst keyboards ever made
13:38:11 <`nand`> actually, this is getting too off-topic for #haskell
13:38:13 <pikhq> DeadPanda: Pinyin kinda sucks as an input method.
13:38:18 <linduxed> bump
13:39:13 <DeadPanda> pikhq, true, but look at the alternative http://static7.businessinsider.com/image/4e72324f6bb3f7ff77000001/chinese-keyboard.jpg
13:39:14 <BlindRadish> oh, we can't just chat?
13:39:20 <DeadPanda> pikhq, good luck fitting that on a smartphone ;)
13:39:33 <BlindRadish> lmao that's epic!
13:39:36 <mauke> monochrom: is the async talk supposed to be a video?
13:39:39 <pikhq> DeadPanda: I was more thinking http://en.wikipedia.org/wiki/File:Keyboard_layout_Zhuyin.svg
13:39:40 <BlindRadish> they'll need a new language
13:39:44 <hpaste> geekosaur annotated “xmonad.hs” with “xmonad.hs (annotation)” at http://hpaste.org/81327#a81328
13:39:47 <monochrom> yes mauke
13:39:51 <pikhq> Sadly, only Taiwanese even *use* Zhuyin.
13:39:59 <mauke> monochrom: I only get a black square
13:40:04 <pikhq> It makes a lot more sense as a phonetic script for Chinese, but whatever.
13:40:17 <monochrom> yes, the black square is where a vimeo player lives
13:40:37 <mauke> https://vimeo.com/51139014 - what do you see here?
13:40:39 <linduxed> bump
13:40:50 <DeadPanda> pikhq, that's true.  i'm learning (very basic) chinese from my fiance, and still don't get why they arbitrarily assign pronunciation to character pairs in pinyin like that
13:40:57 <monochrom> however, the talk is very basic. if you read the source code of async, you may get more information more efficiently
13:41:22 <monochrom> "Permission Denied" "This is a private video"
13:41:24 <k00mi> mauke: i get "permission deneid", private video bla bla
13:41:44 <Eduard_Munteanu> Suppose I send some data to another process and wait for a reply in a loop. However, that process can also send outstanding messages (which aren't triggered by what I send). How do you process all these messages without having them accumulate?
13:41:46 <monochrom> however, using the embedded vimeo player on skillsmaster.com worked
13:41:51 <`nand`> I get that from the iframe as well. Maybe it checks the HTTP referer?
13:42:02 <mauke> k00mi: ok, me too
13:42:13 <BlindRadish> what should i name the state for an instance of a lfsr?
13:42:25 <monochrom> the embedded player could go fullscreen
13:42:30 <BlindRadish> the state represents a specific lfsr, rather than a general one.
13:42:52 <mauke> no video for me :-(
13:43:23 <monochrom> I had to tell flashblock to whitelist player.vimeo.com
13:43:24 <YayMe`> BlindRadish: What is an "lfsr" ?
13:43:35 <BlindRadish> linear feedback shift register
13:43:46 <BlindRadish> i'm using a galois model
13:43:52 <mauke> does http://player.vimeo.com/video/51139014?title=1&byline=0&portrait=0&color=ffffff work for anyone?
13:44:05 <mauke> I get audio but no video
13:44:21 <monochrom> that is a "Sorry" here
13:44:33 <mauke> what the heck
13:44:35 <monochrom> I do say they go out of their way to make it hard
13:44:44 <Eduard_Munteanu> I'm thinking of running a process-accumulated-replies loop before sending any more messages.
13:44:50 <YayMe`> BlindRadish: a single is probably a register
13:45:14 <BlindRadish> not its a pseudo random number generator
13:45:14 <monochrom> skillsmaster clearly absolutely wants you to stay on the skillsmaster website
13:45:16 <BlindRadish> no*
13:45:23 <Eduard_Munteanu> e.g. spawn a thread that gets messages, sends them into a MVar, then I do tryTakeMVar in a loop until I hit Nothing.
13:45:31 <Eduard_Munteanu> Is there a better way to do this?
13:45:36 <DeadPanda> Eduard_Munteanu, that could work, but will the other process block until you read a message?
13:45:52 <BlindRadish> its at least as good as the standard multiply and carry for monte carlo but neither are that good at cryptography
13:46:05 <BlindRadish> but i only need monte carlo for now
13:46:09 <Eduard_Munteanu> DeadPanda: no, but it will eventually if enough messages accumulate.
13:47:01 <Eduard_Munteanu> Since this is a realtime application, I'll probably drop all but the last reply or something like that.
13:47:11 <DeadPanda> Eduard_Munteanu, how "hard" realtime?
13:47:31 <mSSM> parcs: When I make specialized instance of Foo a = Foo a a like “data FooInt = FooInt Int Int”, how can I make this an instance of Functor?
13:47:52 <Eduard_Munteanu> DeadPanda: not really hard. I'm actually controlling mplayer and syncing it to the system clock based on some other things.
13:47:59 <mSSM> parcs: Does that even make sense?
13:48:44 <Eduard_Munteanu> DeadPanda: so I query mplayer on its current position within a file, but mplayer also tells me when a file ended.
13:49:02 <Eduard_Munteanu> (without me asking for it explicitly)
13:49:33 <acowley> I made c2hs compile with new language-c, but the repo isn't on github
13:50:06 <mauke> monochrom: I managed to make it work with the document inspector
13:50:13 <shurikas> I need an easy way to draw some stuff with Haskell
13:50:22 <shurikas> possibly a GUI window
13:50:24 <DeadPanda> Eduard_Munteanu, that's annoying of it.  what you propose sounds fine.  but be careful if you arbitrarily discard messages, there's no guarauntee of the order and discarding all but the last in the queue will bite you in the ass sooner or later.
13:50:26 <shurikas> and pixels with black/white color
13:50:27 <mauke> apparently there's a <div> hiding the video. everything's ok after deleting it from the DOM
13:50:31 <Eduard_Munteanu> shurikas: gtk2hs and cairo should do
13:50:38 <shurikas> I am also on Windows
13:50:50 <shurikas> gtk2hs and cairo still holds?
13:51:02 <BlindRadish> god what a horrible idea i had - learn a functional language using the one thing it can't easily do!
13:51:12 <monochrom> oh haha. yeah, many web programmers have depth order problems especially with flash objects
13:52:18 <Eduard_Munteanu> DeadPanda: I guess I could actually service all messages, and if I get an EOF message then I don't ask for the position again. Maybe I should rethink this.
13:52:46 <monochrom> I'm also happy that now end-users have the tools to screw the web programmers' broken work
13:52:46 <Eduard_Munteanu> (since I could ask for position, get EOF, ask again, get the previous position etc.)
13:53:42 <DeadPanda> Eduard_Munteanu, presuming you need to reuse the same mplayer to show more messages, yes.  draw yourself a petri net or something to figure out the concurrency problems -- good luck
13:54:11 <Eduard_Munteanu> Hm, that's a good idea.
13:54:20 <linduxed> if i've got a few files and the file molbio.hs mostly serves as a file with tests in it, should i rename it to tests.hs or is there some other place where you generally put tests?
13:55:04 <`nand`> I remain impressed by how decidedly hard they make it for people to actually watch their videos
13:55:27 <`nand`> even with the right HTTP referer I still get errors when trying to wget the player page in order to begin to inspect it to figure out how to get the direct video URL
13:55:37 <Eduard_Munteanu> Maybe I should spawn another thread to send/receive the synchronous messages.
13:57:27 <parcs> mSSM: nope
13:59:07 <mSSM> parcs: Yeah, I realize it doesn't make sense.
14:07:19 <BlindRadish> man i got an off by one error on my random number generator's output - what does that even mean???
14:07:44 <BlindRadish> i mean its supposed to be random, how could it be off by one??
14:08:27 <Eduard_Munteanu> Perhaps the expected range was off by one?
14:09:06 <BlindRadish> nah its just input to output
14:09:26 <BlindRadish> i think i caught the problem though
14:09:53 <BlindRadish> lfsrs are supposed to represent x^a + x^b + x^c + x^d + x^0
14:09:59 <BlindRadish> mod 2
14:10:00 <Eduard_Munteanu> Well, then, tells us how you reached the "off-by-one" conclusion.
14:10:01 <adnap> Can I import C++ functions as C functions using the FFI if the function signatures contain only native C types?
14:10:26 <BlindRadish> i flagged the x^0 as mask in the input
14:10:31 <BlindRadish> x^0 = 1
14:10:42 <Eduard_Munteanu> adnap: that's not sufficient, C++ names are usually mangled
14:10:56 <BlindRadish> the period would've been halved or worse, but i'm still not sure how that generates off-by-one
14:10:59 <adnap> Eduard_Munteanu: Oh! Damn
14:11:01 <merijn> Eduard_Munteanu: Also, isn't C++'s calling convention different?
14:11:32 <Eduard_Munteanu> I don't think it's much different, as far as the C "subset" is concerned.
14:11:35 <BlindRadish> they really need to merge those already
14:11:57 <adnap> I'm hosed. There must be a way around this
14:12:21 <BlindRadish> compile it to LLVM and inline LLVM
14:12:24 <BlindRadish> :D
14:12:24 <Eduard_Munteanu> adnap: see extern "C"
14:13:02 <BlindRadish> i think you can do that if you target LLVM with GHC
14:14:20 <johnsonw> Is it just me or is trac down?
14:14:41 <Igloo> which trac?
14:14:42 <lispy> johnsonw: ghc trac is up
14:14:51 <johnsonw> I'm getting 'database locked' errors
14:14:51 <adnap> Eduard_Munteanu: Thanks :D
14:15:29 * lispy also wonders which trac
14:15:45 <johnsonw> ghc trac
14:15:55 <Igloo> Just wait a while and reload
14:15:57 <BlindRadish> i need to do some recursion but I'm stumped. sorry for the impurity: "test = for [..100] (step = lfsr (mask, step); print step)"
14:16:02 <lispy> johnsonw: I tried this url after you said something andit worked for me: http://hackage.haskell.org/trac/ghc/
14:16:08 <Igloo> It just means the system is under load, probably due to the backup program
14:16:15 <lispy> johnsonw: are you trying to do a specific thing with it like search tickets?
14:16:28 <johnsonw> lispy: just view any report, and i get database locked
14:16:30 <Eduard_Munteanu> adnap: also see http://www.haskell.org/haskellwiki/CPlusPlus_from_Haskell
14:16:43 <johnsonw> seems to be working now
14:16:46 <Eduard_Munteanu> (here they reference the mangled names without extern "C" stuff)
14:17:00 <merijn> BlindRadish: I don't understand what that's supposed to do?
14:17:25 <adnap> I have another question. When using the FFI, is the entire object file containing the imported C functions linked into the Haskell program? Could my C++ functions with C signatures reference global C++ data types such as vectors?
14:17:41 <Jeanne-Kamikaze> yes
14:17:46 <mSSM> parcs: well, I implemented those changes, but unfortunately my code is still 5 times slower than C. I suppose this is as good as it gets without starting to use fusion and such
14:17:53 <BlindRadish> merijn: thanks, i'm gonna hold off a bit until everyone else is helped.
14:18:11 <Jeanne-Kamikaze> actually
14:18:21 <Jeanne-Kamikaze> adnap: no
14:18:29 <merijn> BlindRadish: Looks like you want a fold over the index list. probably?
14:18:32 <merijn> :t foldM
14:18:34 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:18:44 <adnap> Jeanne-Kamikaze: Will you explain why not?
14:19:20 <Jeanne-Kamikaze> that's what I was trying to figure out, I don't remember the details
14:19:25 <merijn> BlindRadish: Where does the mask come from?
14:19:38 <BlindRadish> constant
14:19:59 <BlindRadish> that part is working, no worries
14:20:08 <Jeanne-Kamikaze> adnap: in general a C linker cannot link c++ code, for example it'll be missing on the standard lib
14:20:09 <merijn> BlindRadish: And the step part?
14:20:15 <BlindRadish> test = print $ lfsr (46080, 44257)
14:20:28 <Jeanne-Kamikaze> so even if your C++ exports unmangled names, ghc will fail to link with a static lib
14:20:36 <BlindRadish> i want step to change each time i call lfsr, and pass back into lfsr for another go
14:20:46 <BlindRadish> but at that moment i need to print it
14:20:54 <BlindRadish> i want to see all of the steps output
14:20:57 <xil> hello.  I was wondering if anyone here's gotten freeglut to work on Windows lately.  I can't seem to get it to work, and I'm not quite sure how to build the GLUT package from sources so that it uses freglut =/
14:20:59 <merijn> BlindRadish: So step is the result of the previous step, right?
14:21:03 <BlindRadish> and each step just recurses back in
14:21:06 <BlindRadish> yes
14:21:08 <merijn> BlindRadish: Eh, previous lfsr
14:21:17 <merijn> BlindRadish: I think you want foldM + helper
14:21:29 <BlindRadish> helper?
14:22:22 <merijn> BlindRadish: wrap lsfr into: \oldStep -> do { let step = lfsr (mask, oldStep); print step; return step }
14:22:35 <merijn> BlindRadish: Then use foldM with that
14:22:36 <merijn> :t foldM
14:22:38 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:23:13 <BlindRadish> why is it oldStep -> not oldStep =?
14:23:50 <BlindRadish> god this is getting confusing
14:23:51 <merijn> BlindRadish: It's a lambda, without knowing the rest of the code that seemed the simplest option
14:24:19 <BlindRadish> thanks
14:24:27 <geekosaur> I'm not sure why lambdas use -> instead of =, but there is probably some syntactic ambiguity somewhere with the latter
14:24:31 <merijn> BlindRadish: i.e. it's just a function that takes the oldStep as argument, calls lfsr with mask and oldStep, then prints/returns the resulting "step"
14:25:44 <BlindRadish> is that really the right way to do this?
14:25:50 <Jeanne-Kamikaze> adnap: what you can do is make a C shared lib as a wrapper for the C++ code and then have ghc link against that
14:26:04 <merijn> BlindRadish: I'm not sure, without more exact code of what you're doing/what you want it's hard to say
14:26:08 <BlindRadish> i expected to use recursion
14:26:10 <Jeanne-Kamikaze> and by "C shared lib" I mean C++ shared lib with unmangled exports
14:26:17 <BlindRadish> let me post it for you.
14:26:23 <merijn> BlindRadish: Maybe hpaste your code with an example of the function your expect to use
14:27:42 <BlindRadish> i am hang on
14:27:43 <adnap> Jeanne-Kamikaze: But the C++ STL is ruled out
14:27:56 <BlindRadish> uh can i put your code into a function or something?
14:28:00 <Jeanne-Kamikaze> what do you mean ?
14:28:03 <BlindRadish> like text = \...
14:28:07 <BlindRadish> test*
14:28:16 <BlindRadish> or is that wrong?
14:28:27 <merijn> BlindRadish: Yeah, you could just to "test oldStep = do { let step = lfsr (mask, oldStep); print step; return step }"
14:28:28 <BlindRadish> should i do test :: ...?
14:28:30 <merijn> s/to/do
14:28:34 <adnap> Jeanne-Kamikaze: I can't link stuff from the C++ STL in my program, and creating a C wrapper is hopeless
14:28:52 <BlindRadish> ah see that looks like recursion
14:29:03 <BlindRadish> i see now
14:29:11 <Jeanne-Kamikaze> the first is true, the second I don't see why
14:29:19 <adnap> Jeanne-Kamikaze: the STL uses templates
14:29:22 <BlindRadish> still don't know if thats the way, the whole thing doesn't need to be in a monad
14:29:25 <Jeanne-Kamikaze> yeah
14:29:42 <Jeanne-Kamikaze> so ?
14:29:44 <merijn> BlindRadish: It does if you want to print, because print has type "String -> IO ()"
14:29:58 <adnap> Jeanne-Kamikaze: So, how do you wrap vector<T>?
14:30:08 <merijn> BlindRadish: If you don't want to print you could use something like foldr/l or iterate
14:30:09 <Jeanne-Kamikaze> why would you expose vector ?
14:30:10 <BlindRadish> right but print x can be in a monad right?
14:30:11 <merijn> :t iterate
14:30:13 <lambdabot> (a -> a) -> a -> [a]
14:30:16 <BlindRadish> and the rest can be outside?
14:30:29 <merijn> BlindRadish: What would the type of that be?
14:30:30 <adnap> Jeanne-Kamikaze: What if I want to use a vector?
14:30:35 <Jeanne-Kamikaze> you should wrap it with a C struct and hide the details, i.e. an opaque pointer
14:30:41 <BlindRadish> merijn: no clue dude
14:30:45 <Jeanne-Kamikaze> and pass the pointer to/from haskell
14:31:01 <BlindRadish> merijn: let me show you my code hang on
14:31:10 <Jeanne-Kamikaze> and yes, you'd have to do that for every instantiation of the vector
14:31:17 <knz> adnap: I would recommend making a few conversion functions in C++ between standard "C array" types (with size as explicit argument) and a std::vector
14:31:31 <Jeanne-Kamikaze> but I still don't see the point of exporting vector to haskell
14:31:34 <knz> adnap: one per std::vector instance
14:31:52 <knz> adnap: in general you're better off exposing your C++ algorithms with a little C wrapper around them
14:32:04 <knz> not data structures
14:32:11 <knz> and for sure no classes :)
14:32:30 <merijn> Or just use haskell vectors and avoid all the problems entirely...
14:32:40 <Jeanne-Kamikaze> well you can still wrap classes
14:33:03 <BlindRadish> i annotate the old post, right?
14:33:09 <knz> Jeanne-Kamikaze: not really, just the constructor/destructor... all methods need to be wrapped individually, it's as if you had no class at all
14:33:21 <Jeanne-Kamikaze> yeah, but you still can :P
14:33:26 <adnap> I am a little lost. I have some C++ functions, with signatures containing only native C types, which reference a global vector. I use extern "C" to keep their names unmangled. I import these functions into my Haskell program using the FFI. ghc fails to link the object file because it has #include <vector>...
14:33:35 <merijn> BlindRadish: If you like? I didn't see the old post...
14:33:56 <knz> adnap: what is the error exactly?
14:33:59 <BlindRadish> life :: social coding and coffee -> joy
14:34:28 <startling> Not in scope: 'life'
14:34:32 <adnap> knz: I'm not sure what error you're referring to
14:34:41 <knz> adnap: "ghc fails to link the object file"
14:34:44 <knz> how does it fail?
14:34:56 <hpaste> BlindRadish annotated “lfsr attempt” with “lfsr attempt -- updated” at http://hpaste.org/81318#a81334
14:35:07 <adnap> because the object file contains compiled C++ code from vector
14:35:15 <hiptobecubic> @djinn f :: social coding and coffee -> joy
14:35:15 <lambdabot> Cannot parse command
14:35:21 <hiptobecubic> @djinn social coding and coffee -> joy
14:35:21 <lambdabot> -- f cannot be realized.
14:35:50 <knz> adnap: you write "because the object file contains compiled C++ code from vector"; that is your explanation as to a possible cause, not the error itself. What is the error reported by ghc/linker?
14:36:40 <adnap> knz: I haven't tried it yet. I'm going off of what Jeanne-Kamikaze said: "in general a C linker cannot link c++ code, for example it'll be missing on the standard lib"
14:36:45 <Jeanne-Kamikaze> adnap: maybe post the .h file as well
14:36:55 <knz> adnap: Jeanne-Kamikaze likely confused you. :)
14:37:02 <Jeanne-Kamikaze> why ?
14:37:12 <merijn> BlindRadish: Some of that doesn't make a lot of sense
14:37:17 <adnap> Jeanne-Kamikaze answered "no" to my question: "I have another question. When using the FFI, is the entire object file containing the imported C functions linked into the Haskell
14:37:20 <adnap>                program? Could my C++ functions with C signatures reference global C++ data types such as vectors?"
14:37:45 <knz> adnap: your confusion rises from the fact that std::vector is not a "global data type"
14:37:55 <merijn> BlindRadish: For example, you have "type Lfsr = (Mask, Step)" and "lfsr :: Lfsr -> Lfsr", but test calls "let step = lfsr (mask, test)"
14:38:14 <merijn> BlindRadish: i.e. the test there is not a value of type Step
14:38:35 <knz> FTFY (let me fix this for you): "no you cannot use the FFI with C++ signatures using std:: templates. Yes, you can use C++ functions wrapped in a standard C type signature, including functions that use std:: templates *internally*."
14:38:38 <adnap> knz: What I mean in my sentence is that the cpp file containing the imported C++ functions with extern "C" reference a global vector in the same file
14:38:57 <knz> yes, that would work
14:39:02 <adnap> Okay, great!
14:39:04 <BlindRadish> merijn: LfsrWord?
14:39:04 <Jeanne-Kamikaze> knz: internally as well ?
14:39:28 <knz> Jeanne-Kamikaze: I mean "internally" to mean "it does not say so in the function signature"
14:39:40 <adnap> Jeanne-Kamikaze said "a C linker cannot link c++ code"
14:39:44 <geekosaur> note that you may also need to link against -lstdc++ or similar
14:39:52 <Jeanne-Kamikaze> but you can't either, it'll drop a depency on the c++ standard lib
14:39:57 <merijn> BlindRadish: Yes, but the type of test here is "IO Lfsr"
14:40:01 <adnap> I assume that ghc uses a C linker to link the compiled haskell code and compiled C++ code
14:40:12 <Jeanne-Kamikaze> yes
14:40:14 <knz> adnap/ Jeanne-Kamikaze: link with -lstdc++
14:40:21 <Jeanne-Kamikaze> with a C linker ?
14:40:22 <BlindRadish> merijn: not following you, dude.
14:40:25 <knz> yeah
14:40:28 <merijn> BlindRadish: I think you really want iterate here
14:40:33 <merijn> :t iterate
14:40:34 <knz> Jeanne-Kamikaze: there are various tricks to fool a C linker into linking with C++ code
14:40:34 <lambdabot> (a -> a) -> a -> [a]
14:40:44 <Jeanne-Kamikaze> ah wait, is that linking dynamically ?
14:40:47 <knz> depending of how much of C++'s stdlib the code is using
14:41:07 <Jeanne-Kamikaze> knz: but then you're linking dynamically, right ?
14:41:12 <geekosaur> Jeanne-Kamikaze, there isn't actually a distinct "C linker" or "C++ linker" (or even Haskell linker, except within ghci which is why ghci/TH doesn't work on e.g. ARM)
14:41:25 <merijn> BlindRadish: iterate takes your lfsr function (Lfsr -> Lfsr) and an initial Lfsr value an produces a list of Lfsr values by repeatedly applying lfsr to the previous value
14:41:29 <knz> Jeanne-Kamikaze: what? why?
14:41:30 <merijn> BlindRadish: A simple example:
14:41:38 <merijn> > iterate (+1) 0
14:41:40 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:41:46 <Jeanne-Kamikaze> I see
14:41:51 <geekosaur> what there is is a different set of default libraries and such; if you know what those are, you can include them elsewhere
14:41:54 <adnap> Yeah, it's just ld
14:41:57 <knz> geekosaur: there are no separate linkers, but ghc's invocation of ld does not use the same basic flag that a c++ front end would
14:42:03 <BlindRadish> merijn: I was hoping to print over and over instead of [1,2,3...]
14:42:08 <knz> yeah
14:42:20 <BlindRadish> merijn: instead of all at once.  doesn't really matter though.
14:42:23 <Jeanne-Kamikaze> the point is that you cannot statically link c++ code in haskell, or am I mistaken ?
14:42:25 <geekosaur> this can be problematic as sometimes the necessary options vary with compiler versions and such
14:42:28 <merijn> BlindRadish: So you'd want "iterate lfsr (46080, 44257)"
14:42:29 <knz> Jeanne-Kamikaze: why not?
14:42:48 <adnap> Man, I need to set up logging on my IRC client
14:42:51 <merijn> BlindRadish: Remember, haskell is lazy. It doesn't really compute those values until you need them...
14:42:54 <knz> adnap: yeah :)
14:42:56 <adnap> I have to go...
14:43:03 <Jeanne-Kamikaze> well after what geookosaur said I wouldn't know why not
14:43:06 <merijn> > take 10 (iterate (+1) 0)
14:43:08 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
14:43:16 <BlindRadish> i love that
14:43:20 <Jeanne-Kamikaze> hmm
14:43:20 <geekosaur> Jeanne-Kamikaze, not directly as the FFI does nopt do C++ name mangling or understand C++ types.  *but* if you use C++'s own `extern "C"' facility to produce C wrappers for C++ functions, you can FFI link against *thoser*
14:43:23 <knz> Jeanne-Kamikaze: let me blow your mind: chances are great you could even link with fortran code :)
14:43:46 <merijn> BlindRadish: You can just do "take X" or "takeWhile" to get the first N values of your list of Lfsr's and then use "mapM print" on the result to print them
14:43:49 <knz> or anything that uses the standard ABI on your platform, for that matter
14:43:52 <adnap> I'll be back in 5 hours. Will you guys be here?
14:44:03 <knz> adnap: not us, but probably other people who can help as well
14:44:16 <Jeanne-Kamikaze> fantastic then
14:44:23 <merijn> BlindRadish: Make sense?
14:44:27 <adnap> knz: I want to be able to quote you. I guess I will just copy what you said to a file...
14:44:30 <xil> hello.  I was wondering if anyone here's gotten freeglut to work on Windows lately.  I can't seem to get it to work, and I'm not quite sure how to build the GLUT package from sources so that it uses freeglut =/
14:44:54 <adnap> xil: Why are you using GLUT? Have you heard of GLFW?
14:44:57 <lispy> xil: hi
14:45:05 <lispy> xil: I'm the maintainer of GLUT
14:45:06 <BlindRadish> merijn: yeah, i guess so
14:45:20 <BlindRadish> merijn: any way to format that into lines?
14:45:39 <lispy> xil: can you tell me more about what versions of "stuff" you're using? (windows, ghc, haskell platform, GLUT, freeglut)
14:45:45 <merijn> BlindRadish: print should print values on separate lines anyway?
14:45:45 <acowley> GHC's code always terrifies me… today's cause for alarm: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.6.1/GHC.html#t:DynFlags
14:45:54 <merijn> @src print
14:45:54 <lambdabot> print x = putStrLn (show x)
14:46:21 <xil> adnap: didn't know about it
14:46:24 <knz> Jeanne-Kamikaze: (we lied btw: there are some extra "tricky" bits with C++ that are not only a matter of linking extra libraries, namely global constructors: code that needs to be *called* as soon as the object is loaded into memory (either by the dynamic linker or by the stdlib initialization code before "main" is called). This is likely to fail when linking C++ with GHC. But fortunately a global std::vector does not really need run-time initialization.)
14:46:25 <merijn> BlindRadish: Yeah, print already print a line break, so "mapM_ print" will already put everything on it's own line
14:46:29 <merijn> :t mapM_ print
14:46:29 <BlindRadish> merijn: it just prints like this: [0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9,0]
14:46:31 <lambdabot> Show a => [a] -> IO ()
14:46:35 <xil> lispy: hi, lemme get you that info, one minute
14:46:44 <merijn> BlindRadish: Note: "mapM print", not "print"
14:46:55 <merijn> (or mapM_, whichever you like)
14:47:11 <merijn> BlindRadish: The first prints every item in the last, the last prints the list itself
14:47:16 <merijn> s/last/list
14:47:22 <lispy> xil: to echo what adnap said, I always encourage people to use glfw-b (on hackage) instead of glut. I even have example code if you would like that: https://github.com/dagit/nehe-tuts
14:47:43 <BlindRadish> merijn: ah map to print, go it.  why mapM and not map?  and whats with the _?
14:47:50 <Jeanne-Kamikaze> I see
14:47:51 <merijn> :t map
14:47:52 <lambdabot> (a -> b) -> [a] -> [b]
14:47:55 <merijn> :t mapM
14:47:57 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:48:00 <merijn> :t mapM_
14:48:01 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
14:48:03 <Jeanne-Kamikaze> then that changes things a lot
14:48:21 <lispy> BlindRadish: the _ variant is much more efficient when you're going to discard the result
14:48:37 <merijn> BlindRadish: mapM says "given a function that produces a monadic action, perform that action for every item in a list and return an action that produces a list"
14:48:51 <merijn> BlindRadish: mapM_ is just "mapM, but I don't care about the resulting list"
14:48:55 <merijn> :t mapM print
14:48:57 <lambdabot> Show a => [a] -> IO [()]
14:49:19 <acowley> Anyone here familiar with ghc-mod's internals?
14:49:20 <merijn> BlindRadish: mapM print returns a [()} list containing a () item for every item you print, which is a bit useless
14:49:25 <merijn> :t mapM_ print
14:49:27 <lambdabot> Show a => [a] -> IO ()
14:49:49 <xil> lispy: HaskellPlatform 2012.4.0.0, which has GHC 7.4.2 and GLUT 2.1.2.1.  And I was trying to get it working with freeglut 2.8.0
14:49:51 <merijn> BlindRadish: mapM_ just says "print everything in the list an throw away the resulting [()], 'cause I don't care"
14:50:06 <xil> lispy: adnap: why GLFW over GLUT?
14:50:06 <BlindRadish> so it returns nothing?
14:50:18 <merijn> BlindRadish: Well, it returns IO ()
14:50:23 <merijn> :t map print
14:50:24 <lambdabot> Show a => [a] -> [IO ()]
14:50:38 <lispy> xil: ah, that's an unsupported version of GLUT, the latest version is here: http://hackage.haskell.org/package/GLUT-2.3.1.0
14:50:42 <BlindRadish> i'm still confused by all that such
14:50:45 <merijn> BlindRadish: To see what happens, try running these in ghci
14:50:56 <lispy> xil: GLFW is much newer, it's properly open source, and the API is a bit cleaner
14:51:12 <BlindRadish> freeGLUT
14:51:21 <merijn> "map print [1..10] !! 3", "mapM print [1..10] !! 3" and "mapM_ print [1..10] !! 3"
14:51:25 <lispy> xil: the next release of GLFW will not use atexit(), although the current version does use it
14:51:30 <Jeanne-Kamikaze> I don't know about glut, but opening a 3+ context in GLFW is cheese
14:51:33 <xil> lispy: yeah, I downloaded the latest with sources, but I don't know how to build it with freeglut, or do I just need to replace the glut32.dll and it should be fine?
14:51:48 <merijn> BlindRadish: Hopefully the three different results will illustrate the difference
14:52:09 <lispy> xil: try backing up glut32.dll and replacing it with the freeglut dll. They are meant to be binary compatible. So it's worth a shot.
14:52:26 <merijn> BlindRadish: If not, ask here about the "IO as actions/programs" explanation, 'cause I'm going so don't have time to give that one again
14:52:40 <merijn> But I'm sure someone else could explain that one
14:53:20 <BlindRadish> mapM's both fail?
14:53:24 <BlindRadish> :(
14:53:27 <xil> lispy: I'll try GLFW first, I suppose, but otherwise I'll try that with the latest GLUT.  Thanks =)
14:53:34 <lispy> xil: Do you specifically need GLUT or do you just need something to get your opengl context so that you can do graphics/input?
14:53:42 <BlindRadish> thanks marijn
14:53:46 <lispy> xil: check out those examples that I linked from github
14:54:04 <lispy> xil: they should "just work" on your ghc
14:54:43 <xil> lispy: yeah I just need something for the context, so I'll try those tutorials.  Thanks =)
14:55:37 <lispy> xil: the code you'll find goes with the "legacy tutorials" on the right: http://nehe.gamedev.net/
14:56:28 <xil> lispy: cool, that should be perfect =D -- I'd done the NeHe tutorials with C++ once before Haskell =P
14:57:29 <lispy> xil: ah, you're all set then. And if you want to contribute more translations send me a pull request. I stopped around the font stuff and since then I've made a very low level binding to the freetype2 library. So if you get really ambitious you can figure out how to combine that with opengl :)
14:57:46 <dunric> @list
14:57:47 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:58:00 <dunric> @help
14:58:00 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:59:13 <xil> lispy: do you maintain GLFW too?
15:00:11 * hackagebot hspec-meta 1.4.4 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.4.4 (SimonHengel)
15:00:13 * hackagebot hspec 1.4.4 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.4 (SimonHengel)
15:00:48 <lispy> xil: no, but I've sent in a lot of patches to the GLFW-b bindings
15:01:11 <lispy> xil: there are multiple GLFW bindings on hackage but I prefer the GLFW-b package because it is more minimal
15:02:03 <xil> lispy: I'm trying to get it now.  Frankly have no idea how to obtain packages on Windows, haha -- I'm more of a linux guy.  Trying cabal through MSYS
15:03:05 <acowley> I too contribute to GLFW-b. It's the business.
15:03:13 <dunric> > ord 'a'
15:03:15 <lambdabot>   97
15:03:42 <dunric> > foldr ((+) . ord ) 0 $ show . product $ [1..1000]
15:03:45 <lambdabot>   133803
15:06:34 <dunric> >:t (.)
15:08:43 <JoeyA> Has anyone had a problem where Ctrl+Z doesn't stop a busy Haskell program from using CPU?
15:09:17 <JoeyA> I had that earlier today.  The problem went away when I stopped the program and started it again, so it's hard to reproduce.
15:11:16 <xil> lispy: wow, this looks pretty awesome
15:11:20 <Hafydd> JoeyA: Ctrl+Z sends a program to the background in bash.
15:11:34 <BlindRadish> oh my god why am i passing a tuple when i could return the mask!
15:11:37 <JoeyA> Hafydd: Right, and suspends it.  bg lets it continue.
15:11:46 <BlindRadish> *moment of functional clarity*
15:12:04 <JoeyA> But in my case, even after Ctrl+Z, the program continued to be 180% CPU usage (2 worker threads compressing stuff)
15:12:10 <Hafydd> Ah... well, I suppose I don't have anything useful to say.
15:12:40 <JoeyA> Hafydd: Keep fishing.  You'll catch a whopper some day :-)
15:13:45 <BlindRadish> how do i print the first 100 items from a list again?
15:13:55 <BlindRadish> or just get them, whatever
15:14:19 <JoeyA> > take 5 "Repetitivenesses"
15:14:21 <lambdabot>   "Repet"
15:14:43 <BlindRadish> nice
15:14:48 <ion> take 3 . drop 4
15:16:02 * geekosaur has no idea what, if anything, the Haskell threaded runtime does on receipt of SIGTSTP
15:17:45 <BlindRadish> how do i print each item from a list rather than the list?
15:17:52 <ion> mapM_ print
15:18:02 <lispy> xil: yay! :)
15:18:12 <BlindRadish> ah right, thats what merijn was trying to tell me
15:18:55 <BlindRadish> mmm sweet random number generation
15:20:57 <BlindRadish> how do i create a function that owns some State and stores the return of a function over the old state when i call it?
15:21:17 <BlindRadish> type MyState = State Int?
15:21:55 <BlindRadish> and then runState foo bar :: MyState?
15:22:23 <thoughtpolice> :t modify
15:22:24 <lambdabot> MonadState s m => (s -> s) -> m ()
15:22:39 <BlindRadish> whats => again?
15:22:50 <thoughtpolice> foo = modify (+1)
15:23:04 <thoughtpolice> BlindRadish: constraint, it just means the monad 'm' can use get/put, like a state monad
15:23:57 <geekosaur> hm, looks like the (current, which does not necessarily match deployed) RTS does the right thing with SIGTSTP
15:24:20 <geekosaur> modulo the thread system doing so (hello LinuxThreads, I'm looking at you)
15:24:57 <JoeyA> geekosaur: Found it, has nothing to do with GHC
15:25:15 <geekosaur> ok
15:25:47 <JoeyA> I was using the unbuffer command (http://unix.stackexchange.com/a/25375/31202), which doesn't forward the suspend like it should.
15:26:34 <JoeyA> geekosaur: Thanks for looking into it, though.
15:27:59 <mauke> JoeyA++  # learned me about stdbuf
15:28:39 <JoeyA> How new of a Linux do you need for that?  I'm on Ubuntu 10.04, and I haven't stdbuf.
15:29:10 <lispy> I've made some gcc plugins and used the ROSE compiler framework and now I'm looking at the ghc internals. The difference in level/quality of documentation is amazing. Ghc is just amazingly well documented compared to the other two.
15:29:24 <mSSM> Can somebody give me an example of how to use whileM? I don't quite understand how that condition “m Bool” works
15:29:34 <mauke> JoeyA: according to the man page it's part of coreutils
15:29:41 <hiptobecubic> :t whileM
15:29:42 <lambdabot> Not in scope: `whileM'
15:30:17 <mSSM> I mean, how do I write the predicate?
15:30:27 <lispy> mauke: I need that recently, but even with it I couldn't get the underlying program to buffer the way I wanted and ended up requesting that the author change it :(
15:30:29 <mauke> JoeyA: the copyright notice in the file is from 2009/2010
15:30:58 <hiptobecubic> mSSM, I assume the predicate is a function and not just m Bool?
15:31:10 <JoeyA> Apparently I don't have it.  Ubuntu isn't telling me what package it's in.
15:31:19 <acowley> mSSM: Imagine prompting the user and producing a Bool
15:31:40 <hiptobecubic> ah
15:31:42 <mauke> I wrote my own version a while ago
15:31:51 <mSSM> hiptobecubic: I assume so as well... I was just thinking of using whileM instead of replicateM
15:31:52 <mauke> as a shell script / dynamic library pair
15:32:00 <hiptobecubic> Yes i see. Yes the bool will just be a monadic value
15:32:41 <mauke> and I override isatty() instead of calling setvbuf() ... hmm, that means it might actually work for programs that don't go through stdio
15:33:00 <k00mi> mSSM: still the same problem as earlier today?
15:33:19 <geekosaur> assuming they use isatty() instead of going straight to ioctl()
15:33:38 <mauke> yeah
15:34:02 <mauke> the "correct" way to do this is to intercept the syscall with ptrace, but ...
15:34:06 <mSSM> k00mi: working on it; I now wanted to try your idea.
15:34:18 <mSSM> k00mi: using a monoid with unfoldM or whileM
15:34:24 <JoeyA> I may just make my program output to a file.  So much for the great Composability of Unix.
15:34:43 <mSSM> k00mi: I am just not sure how to loop n times.
15:36:19 <geekosaur> JoeyA, there are times when I seriously wish stdio checked an envar to see if it should change the default behavior for buffering on stdout/stderr (and maybe other files)
15:36:36 <k00mi> mSSM: it doesn't work with whileM', only unfoldrM' (note the 'r')
15:37:41 <k00mi> mSSM: but parcs solution is probably a lot faster, more concise and doesn't require you change as much of your code
15:38:18 <mSSM> k00mi: Yeah, I implemented it. It gives me reasonably fast code, but it's still 5 times slower than C.
15:38:33 <mSSM> k00mi: I was thinking yours is faster, but if you think that's not the case, I will not try it.
15:39:27 <k00mi> mSSM: did you profile it?
15:39:41 <mSSM> k00mi: yes :)
15:40:03 <k00mi> any lists in sight?
15:40:45 <mSSM> k00mi: In comparison to my previous code, parcs' modification now makes it spend 98% of its time doing something productive.
15:40:53 <mSSM> k00mi: And memory usage is way down. So that's good.
15:41:08 <k00mi> :)
15:42:56 <k00mi> you can try using unfoldrM', the modifications to make it work on monoids are the same as for whileM', but i don't think it will be faster
15:43:51 <mSSM> k00mi: Alright... I have spent a lot of time trying to make my program go faster.
15:44:07 <mSSM> I am actually pretty sad that I don't seem to be able to make it perform at similar speed as C
15:44:20 <mSSM> At least twice the speed would be nice
15:44:21 <mSSM> I mean
15:44:28 <lispy> mSSM: source?
15:44:28 <mSSM> half speed, double time
15:44:39 <mauke> are you compiling with -O2?
15:44:39 <parcs> mSSM: paste the code and #haskell will crowd-optimize it
15:46:10 <hpaste> mSSM pasted “Ising simulation” at http://hpaste.org/81338
15:46:19 <mSSM> And there it is.
15:46:36 <mSSM> The juicy bit is line 215
15:46:42 <mSSM> This is where it spends most of its time.
15:48:23 <mSSM> So yeah, if you have ideas ... :)
15:48:25 <mSSM> I am all ears.
15:48:42 <mSSM> To give you a rough idea of what
15:50:19 <mSSM> what's happening: I make a mutable vector full of Ints. I flip one element in the vector based on some probability, and record the change.
15:50:36 <mSSM> mauke: compiling with -O2
15:53:03 <quchen> Ehm
15:53:10 <quchen> Maybe this is just a silly question
15:53:19 <quchen> But why is 'writeChan' an IO operation?
15:53:44 <jmcarthur> quchen: because writing to a channel is a side effect
15:54:01 <mauke> :t writeChan
15:54:02 <quchen> jmcarthur: But it's a pure operation, isn't it?
15:54:02 <lambdabot> Not in scope: `writeChan'
15:54:10 <quchen> Doesn't change the program
15:54:14 <mauke> @hoogle writeChan
15:54:14 <lambdabot> Control.Concurrent.Chan writeChan :: Chan a -> a -> IO ()
15:54:15 <jmcarthur> quchen: if you execute it multiple times it performs the effect multiple times
15:54:23 <jmcarthur> quchen: so, no, it's not pure
15:54:25 <mauke> quchen: if you remove the IO bit, it simply returns ()
15:54:30 <quchen> jmcarthur: So that answered the "silly" thing I talked about.
15:54:35 <mauke> quchen: so you never have to call it, because you know the result will be ()
15:54:39 <quchen> Now I'm embarassed. But thanks for answering.
15:54:46 <quchen> writeChan launchMissiles
15:54:48 <quchen> Nevermind
15:54:51 <quchen> It's late. ;-(
15:55:14 <shachaf> mauke: But is it () or is it ⊥?
15:55:23 <quchen> So I guess the code is still pure in itself, but pollutes whatever it's writing to.
15:55:25 <mSSM> lispy, parcs: if either of you cares to have a look, I'd be really grateful. If you don't, it's ok as well. :)
15:55:29 <mSSM> It's a lot to ask.
15:55:38 <lispy> you thought you were embarassed before, now you'll get shachaffed on top of it
15:55:41 <mauke> shachaf: () is _|_
15:55:47 <mauke> by the magic of throwTo
15:56:11 <luca> :t \f -> map (map f)
15:56:12 <lambdabot> (a -> b) -> [[a]] -> [[b]]
15:56:15 <luca> yay
15:56:24 <shachaf> lispy: is that a thing now
15:56:30 <lispy> mSSM: I took look. There is so much to see. My first thought was, "I wonder what ghc is generating for line 215" Figuring that out would require me downloading the code and using ghc-core on it.
15:56:37 <jmcarthur> mauke: wha-?
15:56:42 <jmcarthur> oh i think i get it
15:56:44 <jmcarthur> :t throwTo
15:56:46 <lambdabot> Not in scope: `throwTo'
15:56:50 <lispy> shachaf: yeah, I'm at least the second person to use that verb
15:56:55 <jmcarthur> :t Control.Exception.throwTo
15:56:56 <lambdabot> GHC.Exception.Exception e => GHC.Conc.Sync.ThreadId -> e -> IO ()
15:57:00 <quchen> shachaf: I thought about when you told me that Lisp's evaluation is different from Haskell's, and I think it was a misunderstanding. When I wanted to seq a Lisp object, it was actually an "Either Err Lisp", so calling seq on it does evaluate it deep enough that I could be sure there's no error in there.
15:57:00 <shachaf> I saw the first time.
15:57:01 <jmcarthur> err
15:57:06 <jmcarthur> no, i don't get it
15:57:25 <shachaf> quchen: I think there are more misunderstanding lurking.
15:57:26 <lispy> shachaf: we should just make a @command for it, @shachaffed
15:57:47 <mSSM> lispy: Yeah, I suppose it's not straight forward to debug that beast...
15:57:55 <jmcarthur> something like getshapr?
15:57:58 <jmcarthur> @getshapr
15:57:58 <lambdabot> shapr!!
15:58:15 <mauke> jmcarthur: let's say you're a thread using (), e.g. you're doing 'print ()'
15:58:31 <mauke> jmcarthur: no, let's make that 'let x = () in print x'
15:58:48 <mauke> jmcarthur: now another thread throws you an asynchronous exception
15:59:10 <mauke> this is indistinguishable from x being (error "...") instead of ()
15:59:18 <shachaf> Everything is ⊥ because someone could unplug the computer!
15:59:41 <shachaf> Please leave your semantics at the door. This is the Real World.
16:00:03 <lispy> shachaf: oh noes, unplugging the computer is ⊥ too!
16:00:39 <jmcarthur> mauke: are you sure? how are you to tell whether it's from () or print?
16:00:56 <ion> RealWorld#
16:01:10 <shachaf> Just mask asynchronous exceptions.
16:01:11 <mauke> jmcarthur: you don't
16:01:12 <shachaf> Problem solved.
16:01:19 <ion> Just mask power outages, too.\
16:01:44 <mauke> shachaf: turns out writing async exception safe code is brain bendingly hard
16:02:00 <jmcarthur> mauke: for that matter, if there were no IO actions involved, you wouldn't even get the exception (since it would be running in that thread anyway), so i think saying it's equivalent to () being _|_ is misleading
16:02:04 <shachaf> i love asynchronous exceptions
16:02:06 <shachaf> they are so easy
16:02:12 <jmcarthur> *wouldn't be
16:02:38 <aristid> shachaf: i was tempted to write just that, but decided against it
16:02:44 <monochrom> you may receive ctrl-c
16:02:55 <mauke> jmcarthur: at some point you're going to evaluate it
16:03:07 <monochrom> I love async
16:03:09 <mauke> and that's where throwTo can hit you
16:03:15 <shachaf> monochrom: is it so lazy
16:03:17 <jmcarthur> mauke: furthermore, i could still evaluate x in some other thread and it would succeed, which would not be possible if x = _|_
16:03:25 <monochrom> it is racy
16:03:30 <mauke> I can throwTo all the threads
16:04:09 <jmcarthur> mauke: with no guarantee that it will always raise the exception while evaluating x
16:04:14 <monochrom> http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html#v:race
16:04:16 <monochrom> racy!
16:04:16 <mauke> I'm quite happy to see that async is actually exception safe, unlike the code shown in the slides
16:04:55 <mauke> jmcarthur: it doesn't have to
16:04:58 <jmcarthur> monochrom: i wish that function could be used in unamb. it would just be so easy to write! but unfortunately it uses STM :(
16:05:25 <monochrom> unsafePerformIO . atomically
16:05:58 <aristid> monochrom: STM has unsafePerformIO protection AFAIK
16:06:18 <monochrom> oh, yikes, I remember that now
16:06:19 <jmcarthur> mauke: all i'm saying is that the _|_-ness is only observable from IO anyway. this is kind of a weird argument
16:06:29 <jmcarthur> aristid: ?
16:06:47 <mauke> jmcarthur: ()-ness is also only observable from IO
16:06:52 <jmcarthur> aristid: oh, by protection, you mean "it breaks if you nest one atomically inside another"
16:06:54 <monochrom> STM has a ceiling cat, watching you unsafePerformIO
16:06:57 <aristid> jmcarthur: from the docs of atomically: "You cannot use atomically inside an unsafePerformIO or unsafeInterleaveIO. Any attempt to do so will result in a runtime error. "
16:07:08 <jmcarthur> aristid: that isn't actually true
16:07:16 <jmcarthur> aristid: you can do it
16:07:18 <aristid> jmcarthur: THE DOCS LIE TO ME?!
16:07:28 <monochrom> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg#!i=960526180&k=8gBC6Wb
16:07:32 <mauke> unsafeIOToSTM . atomically
16:07:40 <jmcarthur> aristid: it's just that you can't use atomically from within STM (which is possible if you use unsafePerformIO or unsafeInterleaveIO)
16:07:50 <jmcarthur> or i guess unsafeIOToSTM...
16:08:01 <aristid> jmcarthur: and they protect against the latter with a check?
16:08:05 <jmcarthur> yes
16:08:27 <aristid> STILL! i don't like it when docs lie to me
16:09:23 <jmcarthur> the documentation is sufficient to tell you not to do the dumb thing, at least
16:10:44 <aristid> jmcarthur: well i would never do that, which is the reason why i believed the docs :P
16:11:06 <jmcarthur> should i be ashamed that i've done it
16:11:09 <jmcarthur> ?
16:11:12 <aristid> yes.
16:11:15 <jmcarthur> :(
16:11:30 <aristid> jmcarthur: we can forgive you.
16:11:42 <jmcarthur> i do some awful things
16:12:09 <aristid> jmcarthur: what did you need it for if i may ask?
16:12:34 <BlindRadish> math question!  25 parts per 5 parts, 75 parts per 95 parts, how much of a multiple is the former compared to the latter?
16:12:46 <jmcarthur> i was just experimenting with unamb (knowing this implementation was bad) because i was curious about its performance
16:13:09 <mauke> > (75/95) / (25/5)
16:13:10 <lambdabot>   0.15789473684210525
16:13:18 <mauke> > (75/95) / (25/5) :: Rational
16:13:19 <lambdabot>   3 % 19
16:13:55 <jmcarthur> aristid: i have a package on hackage with a module that has only 90 lines in it, counting non-code, and it has 15 occurrences of "unsafe" in it
16:14:10 <jmcarthur> aristid: a couple of which are unsafeCoerce
16:14:10 <aristid> jmcarthur: that's almost as bad as "lens".
16:14:36 <jmcarthur> aristid: but some of which are just unsafe functions defined in terms of existing unsafe functions that i responsibly named "unsafe"
16:14:59 <aristid> jmcarthur: did you name the whole package "unsafe-*", too?
16:15:08 <jmcarthur> no
16:15:11 <jmcarthur> it's a safe package :)
16:15:19 <aristid> it is?
16:15:28 <jmcarthur> i did not go through the trouble to mark it trustworthy, but i could have
16:15:38 <aristid> what's the name?:)
16:15:46 <jmcarthur> it's actually only two unsafePerformIOs and two unsafeCoerces
16:15:57 <jmcarthur> aristid: http://hackage.haskell.org/package/stable-memo
16:16:16 <aristid> jmcarthur: to be fair that's low-level stuff, isn't it
16:16:23 <jmcarthur> oh yes
16:16:36 <jmcarthur> or at least, it's not meant to be observable in any way
16:17:10 <aristid> does the memoization ever forget?
16:17:26 <jmcarthur> aristid: Data.StableMemo.Weak is allowed to forget
16:17:33 <jmcarthur> Data.StableMemo does not forget
16:17:44 <aristid> jmcarthur: how does the forgetting work?
16:17:51 <jmcarthur> aristid: Data.StableMemo.Weak forgets when the key is GCed
16:18:02 <shachaf> aristid: newtype Forget r a b = Forget (a -> r)
16:18:03 <shachaf> hth
16:18:57 <aristid> shachaf: ForGet
16:19:01 <jmcarthur> aristid: sorry, i misstated
16:19:09 <jmcarthur> aristid: both versions will forget when the key is forgotten
16:19:30 <aristid> jmcarthur: so it depends on the key being in the heap?
16:19:30 <jmcarthur> aristid: the Weak version is allowed to forget if the *result* is GCed
16:19:50 <jmcarthur> aristid: it's an identity-based memo table, so if the key is GCed then the entry is useless anyway
16:19:57 <aristid> jmcarthur: so memoizing a function should be pretty safe in terms of space leaks actually, right?
16:20:21 <jmcarthur> aristid: even the non-weak version is pretty safe, but the weak version is extremely safe
16:20:41 <aristid> jmcarthur: oh, identity based? well makes sense, i guess
16:21:04 <jmcarthur> aristid: jeez, read the description :P
16:21:17 <aristid> jmcarthur: why would i do such a thing
16:21:31 <aristid> jmcarthur: next you'll ask me to read the haddocks and not just part of the source code
16:21:43 <davorak> What is the next step in profiling a piece of code and turning on -prof causes the program to report an error?
16:23:02 <jmcarthur> aristid: i recommend looking at the map example in the description for the kind of usage it is intended for
16:27:04 <aristid> jmcarthur: the fibonacci example memorises the internal recursion, but not for external values because GHC does not coalesce these things, right?
16:27:53 <jmcarthur> aristid: i'm not sure i understand
16:28:06 <jmcarthur> aristid: i'm going to eat dinner. i will be back later. sorry for cutting off mid-conversation
16:28:27 <aristid> jmcarthur: i think i know the answer anyways. have fun
16:39:01 <cmccann> hmm. "data Foo f a = Foo (f a) deriving Functor" doesn't work if PolyKinds is enabled :[
16:39:49 <cmccann> apparently it fails to infer (a :: *).
16:40:02 <monochrom> that is strange. but perhaps it wants you to give kind sigs
16:40:25 <monochrom> (f :: * -> *) somewhere may help
16:40:28 <cmccann> without PolyKinds enabled, it infers (a :: *) and (f :: * -> *) as expected
16:40:46 <cmccann> even though f could otherwise be (* -> *) -> * or something else
16:41:05 <cmccann> monochrom: yes, it's just a failure of inference.
16:41:22 <monochrom> interesting
16:41:30 <cmccann> it says it can't derive a well-kinded instance for Functor (Foo ...).
16:41:51 <monochrom> hold on. "deriving Functor" exists?! :)
16:42:04 <cmccann> e.g., "data Foo f a = Foo a (f a) deriving Functor" works fine
16:42:22 <cmccann> or adding kind signatures in obvious places.
16:42:53 <monochrom> sufficiently powerful GHC extensions are indistinguishable from magic
16:42:56 <Ralith> Is there a standard monad for a state whose only operation is copy-and-increment, such as for generating unique names?
16:43:28 <cmccann> also, "deriving instance (Functor f) => Functor (Foo f)" works, because that also implies (f :: * -> *)
16:44:57 <elliott> Ralith: you can use e.g. Free ((->) Name)
16:45:32 <cmccann> Ralith: so basically a monad that can draw an arbitrary number of items from an input stream?
16:46:02 <Ralith> cmccann: not quite an arbitrary stream, but yeah, basically
16:46:09 <cmccann> well, a special case of that, I mean.
16:46:12 <Ralith> yeah
16:46:23 <Ralith> you thinking reader?
16:46:38 <cmccann> no, reader has a fixed environment.
16:46:44 <cmccann> elliott's suggestion works though.
16:47:26 * Ralith isn't very comfortable with Free yet
16:48:39 <elliott> Ralith: then given an infinite list of names you can do e.g. feed _ (Pure a) = a; feed (n:ns) (Free k) = feed ns (k n)
16:48:46 <elliott> feed :: [name] -> Free ((->) name) a -> a
16:48:54 <elliott> there's also FreeT for the transformer version
16:49:39 <Ralith> seems a bit more abstract than I need
16:49:56 <Ralith> neat, though
16:50:04 <cmccann> elliott: I think any "draw from an infinite input stream" monad would be equivalent to "Free ((->) a)", wouldn't it?
16:51:30 <cmccann> Ralith: anyway, abstract or not it does exactly what you need :P
16:52:06 <Ralith> cmccann: indeed!
16:52:17 <Ralith> unfortunately this has to compile on a stock install of ghc 7.4.1
16:52:47 <Ralith> if I'm rolling my own I might as well roll Free I suppose
16:52:50 <cmccann> could always roll (ha, ha) your own Free.
16:52:54 <cmccann> yeah
16:54:32 <elliott> cmccann: yes
16:54:41 <elliott> cmccann: Free ((->) a) is just the best form of the "supply monad"
16:54:58 <elliott> you can do all the things you might want to like e.g. seed it from a monadic action
16:54:59 <cmccann> elliott: I was trying to figure out if an explicit isomorphism could be constructed or not.
16:55:21 <elliott> feedM m (Pure a) = return a; feedM m (Free k) = m >>= feedM m . k
16:57:03 <Ralith> elliott: it's not immediately obvious to me how to actually *use* this, though
16:57:10 <Ralith> a simple example would be wonderful
16:57:49 <elliott> Ralith: depends in what sense of "use" you mean. do you mean how to run the Free ((->) a) monad? my feed/feedM do that. or do you mean how to construct actions of this type?
16:57:57 <Ralith> the latter
16:58:24 <cmccann> Ralith: just like any other monad
16:58:28 <elliott> supply :: Free ((->) r) r; supply = Free Pure
16:58:53 <elliott> here, Free :: (r -> Free ((->) r) a) -> Free ((->) r) a
16:58:59 <elliott> Pure :: a -> Free ((->) r) a
16:59:07 <elliott> the ugly ((->) r) makes this a bit hard to see admittedly
16:59:09 <elliott> but then you can do
16:59:14 <elliott> do { a <- supply; b <- supply; return (a+b) }
16:59:19 <elliott> which gets two "names" (here numeric names) and adds them
16:59:47 <elliott> (for the record: you can say supply :: MonadFree ((->) r) m => m r; supply = free return, which is a more generic version that works with FreeT too and stuff. but you don't have to care about this)
17:00:00 <Ralith> great, thanks
17:00:18 <Ralith> it's not entirely obvious to me *how* that works, but that's definitely enough to work from
17:01:31 <elliott> Ralith: well, one thing you can do is e.g. work out how (feed [1,2,3] supply) evaluates given my definition
17:01:39 <Ralith> yeah
17:01:57 <xil> hello everyone.  Is this a good way to do an event loop:
17:02:00 <hpaste> xil pasted “Either forever” at http://hpaste.org/81340
17:02:08 <elliott> free (n:ns) (Free f) = free ns (f n), so free (n:ns) (Free Pure) = free ns (Pure n)
17:02:11 <elliott> free _ (Pure a) = a
17:02:16 <elliott> so free (n:ns) (Free Pure) = n
17:02:33 <elliott> so you can see that (Free Pure) is an action which takes one name
17:02:49 <elliott> the trivial eta-expansion Free (\a -> Pure a) might make it more obvious
17:04:15 <Ralith> I think I see!
17:04:21 <Ralith> that is pretty neat
17:04:51 <noteventime> 'convert'ing from a Vector type to itself will still result in a copy being created, or am I wrong? convert is implemented as 'unstream . stream', and unstream seems to allocate a new vector.
17:05:45 <Ralith> yeah, wow, that's twisty but pretty great.
17:06:06 <xil> I could probably actually do it with Maybe, come to think of it, but the same idea applies.  So I guess I'm wondering if this is just a bad idea
17:07:04 <lispy> xil: http://stackoverflow.com/questions/12685430/how-to-implement-a-game-loop-in-reactive-banana
17:07:34 <elliott> Ralith: I'd wondered about how to express the supply monad in a nice general way for quite a while when I stumbled upon this construction, my reaction was pretty much the same :)
17:08:00 <elliott> if you expand it out -- data ... a = Pure a | Free (name -> ... a)
17:08:08 <elliott> you can see it's defined kind of like a list
17:08:29 <elliott> but instead of adding elements on you add a function requesting an element: it consumes rather than produces
17:09:03 <Ralith> yeah
17:09:53 <Ralith> now I want to go find some other uses of Free and get a feel for how it generalizes
17:11:19 <cmccann> Ralith: have you seen the pipes library?
17:11:33 <lispy> xil: I guess it all depends on what you want to get out of the gameloop. If you need it invert control, sigfpe has a blog post that does it using Cont
17:11:37 <xil> lispy: yeah, I'll have to do something like that for the internals, but I'm particularly concerned with the "while( !quit )" part.  I've had problems with "exitWith ExitSuccess" in Haskell so I'm trying for a different approach and I noticed "forever" will autoquit with Maybe and Either
17:12:23 <lispy> xil: http://blog.sigfpe.com/2011/10/quick-and-dirty-reinversion-of-control.html
17:13:36 <Ralith> cmccann: I was aware of it, but I had no idea it was based on Free. Makes sense, though.
17:14:04 <cmccann> Ralith: I'm not sure what the implementation is these days, but it's closely related to be sure
17:14:50 * Ralith nod
17:15:11 <elliott> cmccann: pipes is based on some insane thing unrelated to free these days
17:15:15 <elliott> that makes you put () -> everywhere
17:15:58 <cmccann> Ralith: note that if f and g are Functors, you can have a "sum type" that combines them, either something general like "data (f :+: g) a = LeftF (f a) | RightF (g a)" or just writing a specialized type
17:16:15 <cmccann> the original concept of pipes was a free monad of the sum of several very simple functors
17:17:16 <lispy> :t unfoldr
17:17:17 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
17:17:29 <byorgey> edwardk: thanks for the warning, but you're too late =P  https://github.com/diagrams/diagrams-contrib/issues/9
17:18:09 <lispy> > forever $ Left "what"
17:18:10 <lambdabot>   Left "what"
17:18:21 <lispy> xil: I had never tried that before. Neat.
17:18:55 <cmccann> Ralith: note that if you use something like "Free ((->) i :+: (,) o)" instead of just "Free ((->) i)" you have something that both consumes and produces a stream
17:19:00 <lispy> kind of makes we wish unfoldr works on more generic types than Maybe and [a]
17:19:53 <xil> lispy: haha, yeah I was looking at the GLFW tutorial and it uses forever for the event loop, which is convenient, so I checked on how forever is actually implemented and noticed it could do that.  Although it might be better for me to use Maybe in this case
17:20:05 <cmccann> Ralith: if you inline all the type cruft that's the same as "data StreamTrans i o r = Pure r | Await (i -> StreamTrans i o r) | Yield (o, StreamTrans i o r)"
17:20:30 * Ralith nod
17:20:52 <lispy> xil: yeah, I was actually going to suggest a monadic unfoldr (I think you'd have to write it yourself)
17:21:01 <lispy> but if forever already does the right thing, why bother
17:21:14 <xil> lispy: haha, right
17:21:53 <Ralith> that all made sense with scary rapidity
17:22:02 <lispy> xil: but if you get a chance sigfpe's reinversion of control is a neat hack.
17:22:14 <cmccann> Ralith: this is probably a case where reinventing a few wheels helps you understand them. if you take the StreamTrans type I gave and figure out how to make a stream processor with it, then refactor it to use Free you'll probably get a better intuition for a lot of things.
17:22:49 <Ralith> makes sense
17:24:02 <cmccann> Ralith: with the functor sum style using (:+:) you can even have an extensible version of stream processors, where you can take an input-only version (like the name supply monad elliott gave you) and turn it into a stream processor (that happens to never produce output)
17:24:15 <elliott> (That way is kind of hellish IME though.)
17:24:31 <cmccann> it's fun to toy with though
17:25:13 <elliott> The problem with Free ((->) r) being a nice supply monad is that I don't really have any uses for supply monads now.
17:25:39 <cmccann> elliott: you could write a compiler and use that for a unique name supply!
17:25:44 <cmccann> you love unique name supplies, right?
17:26:27 <xil> lispy: yeah, it looks interesting.  I'll definitely take a look =)
17:26:30 <elliott> cmccann: but I'd use bound!
17:26:31 <shachaf> newtype Stream m a b = Stream { runStream :: m (Either b (a, Stream m a b)) }
17:26:38 <shachaf> "real world application of Free(T)"
17:26:50 <cmccann> elliott: what about unification variables for type inference?
17:27:08 <cmccann> elliott: or even pretty-printing expressions, for that matter.
17:27:20 <elliott> cmccann: I've been trying to convince myself I'll figure some nice way to do the former without a name supply.
17:27:35 <xil> > forever $ Nothing
17:27:36 <lambdabot>   Nothing
17:27:42 <elliott> I'm not terribly optimistic since apparently edwardk stoops to using IORefs for that.
17:27:56 <Nereid> I wish forever had type m a -> m Void
17:27:59 <cmccann> elliott: I actually have a horrible algorithm that does a lot of type inference in a goofy way without using unique names.
17:28:01 <lispy> The hard part about building a name supply is what to name it?
17:28:05 <elliott> Nereid: m a -> m b, you mean
17:28:09 <Nereid> why
17:28:16 <xil> hmmm...just not sure how to mix Maybe with IO -- I know it's possible
17:28:17 <elliott> Nereid: equivalent but more flexible to use
17:28:19 <edwardk> lispy: =)
17:28:20 <cmccann> elliott: with the interesting property of inferring some higher-rank types as well
17:28:25 <Nereid> where would you use that flexibility?
17:28:39 <elliott> cmccann: that sounds exciting
17:28:46 <edwardk> in my case for unification variables i jus use STRefs, and an extra Int to make visited sets easier
17:28:48 <elliott> Nereid: for instance, if you're writing a callback with type IO ()
17:28:51 <shachaf> Nereid: Something expects foo :: m (), and you don't have to fmap over the forever?
17:28:54 <Nereid> bleh
17:28:55 <elliott> or such
17:29:03 <edwardk> then as soon as i can i get out of that ST monad.
17:29:03 <elliott> Nereid: and you recover the original flexibility just by using it at (m Void)
17:29:03 <cmccann> elliott: it works by not actually doing unification directly!
17:29:04 <Nereid> fair enough
17:29:10 <elliott> indeed you can turn (m a -> m Void) into (m a -> m b) just by fmapping absurd
17:29:17 <lispy> edwardk: do you have any partially written Haskell -> C# (or other .NET lang) libraries sitting around?
17:29:22 <elliott> cmccann: I'd like to see that
17:29:28 <cmccann> also, I'm not 100% confident that it actually works in all cases because I don't have a full implementation yet.
17:29:40 <edwardk> lispy: nope. not an itch i ever wanted to scratch
17:30:10 <cmccann> elliott: I'll show you when I have an implementation that uses it. I'm pretty sure it's horribly inefficient, though.
17:30:30 <jmcarthur> aristid: back
17:30:36 <elliott> cmccann: pfft, implementations
17:30:37 <lispy> edwardk: ah, I figured it was worth checking as I know you like to translate between languages for somethings
17:30:38 <elliott> who needs those?
17:31:23 <jmcarthur> aristid: if you meant "does ghc use a single memo table for the whole function or a different one for each external use of the function" the answer is the latter
17:31:53 <lispy> edwardk: and I suppose you have the same answer for Java?
17:31:54 <aristid> jmcarthur: so what i was thinking of: if i invoke fib (Succ (Succ Zero)) and fib (Succ (Succ (Succ Zero))) there will be no memo sharing between those two, right?
17:32:07 <jmcarthur> aristid: that is correct
17:32:26 <jmcarthur> aristid: oh wait
17:32:26 <aristid> jmcarthur: CSE would affect this, however, correct?
17:32:28 <jmcarthur> brb
17:32:38 <jmcarthur> aristid: sorry, thought i had to do something
17:32:53 <jmcarthur> aristid: it's actually just one memo table
17:33:02 <jmcarthur> aristid: i'm not thinking straight right now, apparently
17:33:15 <cmccann> elliott: the gist of it is that instead of creating unification variables it just creates a massive pile of actual foralls for any unknown type
17:33:34 <fragamus> I love Data.Lens
17:33:40 <jmcarthur> aristid: if fib gets inlined then there may be more than one
17:33:51 <jmcarthur> aristid: if you don't want that you could say NOINLINE, of course
17:33:53 <cmccann> elliott: then works outward, alternately generating type equality constraints a la ~ and satisfying any constraints that become trivial
17:34:06 <aristid> jmcarthur: sure it's one memo table but both expressions share a Succ (Succ Zero)
17:34:23 <aristid> jmcarthur: but GHC probably will create two heap values for that, right? :)
17:34:24 <jmcarthur> aristid: oh, you are asking about what makes keys distinct?
17:34:39 <cmccann> elliott: floating foralls into outer scopes as needed and replacing "unification" with type application
17:34:45 <jmcarthur> aristid: if you invoke fib in those ways then they will not share anything with each other, yes
17:35:11 <jmcarthur> aristid: however, if you say this it will share:  let x = Succ (Succ Zero) in (fib x, fib (Succ x))
17:35:25 <Ralith> elliott: what is bound?
17:35:26 <aristid> jmcarthur: ok, so really the point of memo is to help with recursive functions, mostly, right?
17:35:34 <jmcarthur> that's right
17:35:55 <aristid> jmcarthur: do you use it somewhere else, too?:)
17:36:18 <elliott> Ralith: hackage.haskell.org/package/bound
17:36:28 <jmcarthur> aristid: not on hackage
17:36:36 <elliott> Ralith: my current favourite approach to handling name binding
17:36:49 <jmcarthur> aristid: but i've used it mainly for various free monads that have branching
17:37:11 <jmcarthur> aristid: including interpreters (meaning that substitution preserves sharing in the function body)
17:37:41 <jmcarthur> aristid: i used it with bound for a couple experiments, for example
17:37:45 <aristid> jmcarthur: interesting
17:37:53 <Ralith> elliott: looks interesting!
17:38:00 <jmcarthur> aristid: which is the package elliott and Ralith are talking about right now :)
17:38:28 <jmcarthur> <3 bound. just wish the HMonad implementation was included
17:38:35 <aristid> "Succ Less" lol
17:38:41 <jmcarthur> http://hpaste.org/73067
17:38:43 <cmccann> elliott: a nice bonus for that approach is that when everything makes sense using only certain kinds of structural equivalence it can stop floating out foralls and thus infer higher-rank polymorphic types accidentally
17:39:02 <aristid> jmcarthur: tell edwardk to add it :P
17:39:03 <elliott> cmccann: nice
17:39:16 <elliott> cmccann: I hear rank-2 inference is decidable, but I'm not convinced people aren't just playing pranks on me.
17:39:36 <cmccann> elliott: with a few tweaks I can also make it more conservative when floating out foralls so that instead of type errors, it leaves equality constraints that can potentially be satisfied at call sites for more specific types
17:39:50 <jmcarthur> i heard somewhere that Rank2Types is being deprecated in favor of RankNTypes anyway, but it's just hearsay
17:40:02 <elliott> pfft, Haskell
17:40:05 <elliott> who cares about *that*
17:40:16 <jmcarthur> heh
17:40:16 <cmccann> elliott: well, this is a completely unprincipled approach and I wouldn't even be confident in claiming that it can infer any type that H-M infers
17:40:29 <cmccann> so decidability isn't even on the radar
17:40:38 <aristid> jmcarthur: HFunctor is like Functor squared? :D
17:40:57 <jmcarthur> aristid: it's a functor for higher kinds
17:41:02 <cmccann> but having worked several examples by hand I think it should infer things usefully in plausible scenarios
17:41:22 <jmcarthur> aristid: fmap :: (a -> b) -> (f a -> f b); hmap :: (f ~> g) -> (h f ~> h g)
17:41:45 <jmcarthur> aristid: where type (f ~> g) = forall a. f a -> g a
17:41:50 <aristid> jmcarthur: ok i guess its parameter doesn't have to be a Functor so it's not really functor squared
17:42:04 <jmcarthur> right
17:42:10 <jmcarthur> at least with PolyKinds
17:42:25 <elliott> jmcarthur: I once made a hierarchy like that up to Applicative.
17:42:34 <jmcarthur> Applicative is the tough one here
17:42:34 <elliott> (In the end it was not very useful.)
17:42:37 <jmcarthur> Monad is easy
17:42:42 <elliott> Applicative is easy if you express it in the zippy form
17:42:45 <jmcarthur> oh i think it's pretty useful
17:42:50 <elliott> (forall a. f a -> g a -> h a) -> x f -> x g -> x h
17:42:59 <jmcarthur> i tried that, but found that it was not so easy to work with
17:43:01 <elliott> plus f Identity
17:43:08 <elliott> yeah it's horrible to work with
17:43:12 <elliott> how does Monad look like again?
17:43:41 <jmcarthur> you just do return and bind. nothing too unusual
17:43:57 <jmcarthur> return :: a ~> m a; bind :: (a ~> m b) -> (m a ~> m b)
17:44:15 <cmccann> earlier today I was trying to contrive a way to have a poly-kinded (x ~> y) that worked equivalently for "forall a. x a -> y a", "forall a. x a -> y", "forall a. x -> y a", "x -> y", and so on for higher kinds
17:44:39 <cmccann> turns out that implementing that is easy, but having a polykinded apply function is trickier, haha
17:45:36 <jmcarthur> elliott: i did enjoy doing HFoldable. i came up with  hfoldMap :: Alternative m => (a ~> m) -> (f a ~> m)  but i would have preferred to use some sort of FunctorMonoid thing instead of Alternative
17:45:59 <jmcarthur> HTraversable is awful
17:46:09 <jmcarthur> because you also want HApplicative
17:46:18 <elliott> hm, what does join look like
17:46:23 <elliott> just m (m f) ~> m f I guess
17:46:43 <jmcarthur> iirc, i failed to implement join, but i gave up early
17:46:54 <edwardk> jmcarthur: i'm not against putting together a bound-extras package with the hmonad version
17:46:57 <jmcarthur> in terms of hmap, hreturn, hbind, at least
17:46:58 <elliott> well, bind id is presumably id :)
17:47:02 <elliott> *it
17:47:06 <jmcarthur> ah, duh
17:47:16 <jmcarthur> maybe i ran into some trouble. don't remember
17:47:20 <edwardk> jmcarthur: that said, check 'indexed' it has the indexed traversable, etc.
17:47:32 <edwardk> i just never shipped it because product kinds are gimped in ghc
17:48:39 <jmcarthur> edwardk: cool! if i was you i'd only bother if i got a few more requests for it though. it's crazy enough to be a little annoying to maintain for little benefit..
17:49:01 <edwardk> youre the 3rd or fourth
17:49:27 <edwardk> if you want to put in some elbow grease copying stuff over out of indexed, i'm willing to set up a repository, and do build system stuff and flesh it out
17:49:44 <jmcarthur> edwardk: i just may be willing to do that some time
17:49:51 <edwardk> let me know
17:50:01 <jmcarthur> elliott: you're right, and that definition "just works" after all
17:50:05 <bacon1989> So i've been having a really hard time wrapping my had around doing IO in haskell
17:50:14 <bacon1989> is their an article I can read which really clears this stuff up?
17:50:15 <jmcarthur> elliott: with type    hjoin :: HMonad f => f (f a) ~> f a
17:50:31 <elliott> right
17:50:36 * elliott thinks using "a" here is confusing
17:50:41 <elliott> since it's actually a functor
17:51:04 <jmcarthur> elliott: it might not even be a functor
17:51:25 <byorgey> but it has kind  * -> *, right?
17:51:50 <jmcarthur> HMonad :: ((k -> *) -> k -> *) -> Constraint
17:51:58 <elliott> jmcarthur: I guess not always
17:52:11 * elliott doesn't like (~>) for natural transformations much.
17:52:13 <byorgey> oh, (k -> *), cool
17:52:16 <elliott> It looks bad in my font.
17:52:38 <jmcarthur> elliott: it looked bad in my font (terminus) too, but i now have a patched version of it that centers it
17:52:48 <elliott> my font is terminus too
17:52:52 <byorgey> ooh, nice
17:52:53 <elliott> maybe I should use that patched version :)
17:53:00 <jmcarthur> elliott: if you are on arch i have a package on aur for it
17:53:11 <elliott> I am indeed
17:53:17 <byorgey> jmcarthur: link pls
17:53:20 <BMeph> bacon1989: I'm gonna assume that you meant that you're looking to do "I/O in Haskel" which is not the same thing - anyway, is there a specific use case you're looking at, since there are many different write-ups of the different activities?
17:53:23 <byorgey> ~ is a silly character to have in ASCII anyway
17:53:33 * elliott wonders... class HCOntravariant h where hcontramap :: (g ~> f) -> h f ~> h g
17:53:34 <jmcarthur> byorgey, elliott: https://aur.archlinux.org/packages/terminus-font-td1/
17:53:36 <elliott> What does it mean?!?!?!?!?!?!?
17:54:17 <elliott> jmcarthur: I'm not sure that return is right
17:54:41 <jmcarthur> oh?
17:54:47 <elliott> oh, hmm
17:54:56 <jmcarthur> it works out for me, at least
17:54:57 <elliott> what I came up with is not what you came up with
17:55:04 <elliott> yours: (f ~> g) -> h f ~> h g
17:55:04 <jmcarthur> and also matches what edwardk came up with
17:55:08 <elliott> mine: (f ~> g) -> h f -> h g
17:55:12 <elliott> spot the difference :)
17:55:17 <bsrkaditya> Hi,
17:55:17 <jmcarthur> mine looks better ;)
17:55:19 <bsrkaditya>  I need a data structure that supports (0) create from list (1) merge (2) find min (3) remove min
17:55:19 <elliott> so my return ends up being (forall a. f a) -> h f
17:55:21 <bsrkaditya> What are my options? I'd say the ratio of my operations will be 1:1:x:x, 1 <= x <= 300
17:55:37 <elliott> jmcarthur: mine was important because you'd use it with types like this:
17:55:44 <elliott> jmcarthur: data Foo f = Foo (f Int) (f Char) (f [a])
17:55:52 <elliott> which you can't do with your version
17:55:58 <shachaf> bsrkaditya: Data.Set?
17:56:03 <jmcarthur> hmm
17:56:14 <elliott> well, hmm, maybe you can by taking another parameter and just ignoring it. but it wasn't the point
17:56:26 * jmcarthur plays with that type
17:56:27 <bsrkaditya> shachaf: merge is not very efficient with set
17:56:34 <edwardk> byorgey: the nice thing about using k -> * through all that code is 'you only ever have to write it once', since it generalizes to any usecase once product kinds get ungimped
17:56:39 <elliott> jmcarthur: it occurs to me that you could parameterise... map :: (f `p` g) -> (h f `q` h g)
17:56:43 <elliott> jmcarthur: clearly an improvement right?!?!
17:56:46 <byorgey> edwardk: right! awesome
17:57:10 <jmcarthur> elliott: looks like the old categorical functor from category-extras
17:57:14 <elliott> yeah
17:57:33 <byorgey> edwardk: I remember reading a paper by Patricia Johann and Neil Ghani about initial algebra semantics for GADTs, and they end up defining all sorts of ugly HFunctor, HFunctor2, ...
17:57:36 <shachaf> bsrkaditya: What do you mean?
17:57:44 <edwardk> byorgey: yeah this solves that
17:57:50 <elliott> jmcarthur: the actual usecase was lifting a type like "data MyRec = MyRec { foo :: Int, bar :: String, baz :: Char }" to "data MyRec' f = MyRec' { foo :: f Int, bar :: f String, baz :: f Char }"
17:57:53 <shachaf> i love polykinds
17:57:55 <byorgey> even then I knew there would come a day when that was no longer necessary
17:58:00 <bsrkaditya> shachaf: I think there is some ds in purely functional data structures that  can do merge in log(N). I don't have the book with me now though. :-(
17:58:08 <elliott> jmcarthur: then you have runMyRec :: Applicative f => MyRec' f -> f MyRec
17:58:15 <Nereid> bsrkaditya: sounds like a heap
17:58:20 <elliott> jmcarthur: and MyRec' has instances of my hierarchy up to Applicative etc.
17:58:29 <edwardk> byorgey: with polykinds 'initial algebra semantics are enough' finally really becomes true and not a 'design pattern'
17:59:22 <byorgey> =D
17:59:33 <elliott> jmcarthur: in fact I did end up with an analogue to Traversable
17:59:40 <byorgey> that's a pithy way of putting it, I like that a lot =)
17:59:43 <elliott> jmcarthur: though it used Applicative itself
17:59:46 <jmcarthur> elliott: yeah i have one too. i think it's the same as edwardk's
18:00:07 <jmcarthur> elliott: i did have one with my own HApplicative, but...
18:00:20 <sniveling> does anyone know offhand, if the "==" operator full evaluates one side when comparing lists
18:00:26 * byorgey -> back to writing thesis proposal =P
18:00:34 <shachaf> sniveling: Not if they're unequal.
18:00:36 <elliott> jmcarthur: mine is: class Functor' t => Traversable' t where traverse' :: Applicative g => (forall a. f a -> g (h a)) -> t f -> g (t h)
18:00:50 <shachaf> sniveling: It goes element by element until it sees either the end of the list or two unequal elements.
18:01:04 <jmcarthur> elliott: mine is   htraverse :: Applicative m => (forall x. f x -> m (g x)) -> (forall x. t f x -> m (t g x))
18:01:29 <elliott> so: instance Traversable' MyRec' where traverse' f rec = MyRec' <$> f (foo rec) <*> f (bar rec) <*> f (baz rec) -- simple
18:01:35 <sniveling> shachaf: Great. Where do you find info about the implementation of these methods. That is, where is the best/most convenient place to find it?
18:01:47 <elliott> jmcarthur: right. our hierarchies are the same, but you use (~>) and I use (->)
18:01:49 <jmcarthur> yeah, my instances are also pretty simple
18:01:50 <elliott> on the RHS
18:02:00 <jmcarthur> seems the case
18:02:04 <shachaf> sniveling: The Haskell Report has reference implementations of everything.
18:02:20 <sniveling> shachaf: Thanks agin
18:02:24 <sniveling> again
18:02:25 <shachaf> sniveling: Otherwise you can just look at the actual code.
18:02:38 <cmccann> also, on hackage, there are "source" links.
18:02:39 <shachaf> sniveling: Hoogle will probably find something with a source link for any name you type in.
18:02:53 <edwardk> note: i needed IFunctors between differing indices, etc. so make sure any Hfunctor/HTraversable variant you come up with supports that
18:03:00 <cmccann> sniveling: e.g. http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/src/Data-List.html
18:03:17 <shachaf> sniveling: Also you can figure ou the answer to this question without looking at the code.
18:03:28 <shachaf> > [1,2,3] == [1,2,undefined]
18:03:30 <lambdabot>   *Exception: Prelude.undefined
18:03:32 <shachaf> > [1,0,3] == [1,2,undefined]
18:03:34 <lambdabot>   False
18:03:36 <cmccann> sniveling: you can get that from http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Data-List.html by clicking "Source" at the top, or from the link next to specific functions
18:03:40 <edwardk> if we had a usable form of product kind for those, i'd be able to get us 'parameterized' lenses, traversals, prisms, etc.
18:04:04 <edwardk> i've been holding off until 7.6 becomes mainstream enough
18:04:25 <sniveling> Beautiful. Thanks guys.
18:05:29 <bacon1989> BMeph: idk, I wrote a function which opens a file, and parses out a piece of the line
18:05:39 <bacon1989> but then as soon as I think about using the function, it just doens't click
18:05:44 <jmcarthur> edwardk: what do you mean by "between differing indices"?
18:05:56 <bacon1989> I feel as though I need ot write it to produce a parsed list which is then processed
18:06:09 <bacon1989> because I need to keep calling this function, instead of having it passed to the next stage
18:06:23 <elliott> edwardk: Parameterised howso?
18:06:29 <edwardk> (a ~> b) -> (f a ~> f b)   the indexing kind for f a and a can be different.
18:06:46 <edwardk> e.g. one might be a unit kind, the other mine be kind *
18:06:53 <jmcarthur> ah
18:07:38 <edwardk> so while HMonad :: ((k -> *) -> k -> *) -> Constraint    HFunctor :: ((i -> *) -> j -> *) -> Constraint
18:07:46 <edwardk> HTraversable follows the same pattern as HFunctor
18:08:03 <edwardk> see the Vec instance in my Remote paste from back in the day
18:08:03 <jmcarthur> i see
18:08:59 <jmcarthur> when i do ":k HFunctor" in ghci it gives HFunctor :: ((k -> *) -> k -> *) -> Constraint even though i think it should support this kind of use. is ghci just lying to me?
18:09:26 <dyreshark> question - how does the following code get evaluated? c >>= \x -> sequence cs >>= \xs return (x:xs)
18:09:36 <dyreshark> does the first lambda capture everything, or just the "sequence cs"
18:10:01 <jmcarthur> dyreshark: everything to the right of \x -> is in that lambda's body
18:10:32 <dyreshark> alright, thanks
18:10:50 <jmcarthur> dyreshark: c >>= \x -> sequence cs >>= \xs -> return (x:xs)  ==  c >>= (\x -> sequence cs >>= (\xs -> return (x:xs)))
18:12:16 <dyreshark> cool. thanks again jmcarthur :)
18:12:18 <jmcarthur> edwardk: hah, i was slightly confused because i called my own Vec (<$>) instead and then forgot it was ever called Vec in the first place
18:13:15 <edwardk> jmcarthur: i think i had to explicitly give it a kind signature
18:13:29 <jmcarthur> huh
18:13:35 <edwardk> i've kind of blotted out the army of compiler crashes i caused back when i was working on indexed
18:13:48 <edwardk> it was painful
18:13:58 <edwardk> most were caused by my bugs causing the compiler to go nuts
18:14:43 <bacon1989> BMeph: I think that's my problem
18:14:44 <bacon1989> it has to be
18:14:52 <bacon1989> i'm thinking to imperatively
18:14:55 <bacon1989> not being lazy enough
18:15:10 <bacon1989> not enough piping
18:15:28 <bacon1989> I'm gonna raise the roof!
18:15:35 <bacon1989> No parents are going to pipe me down!
18:19:04 <wkoiking> I have some question about gtk2hs
18:19:30 <bacon1989> I was here first
18:19:55 <Eduard_Munteanu> wkoiking: alright, go ahead and ask
18:20:05 <wkoiking> I'm trying Tutorial at http://www.muitovar.com/gtk2hs/app1.html
18:20:29 <wkoiking> Howerver, first code do not compile
18:20:51 <wkoiking> with eroor "Couldn't match expected type `cairo-0.12.3.1:Graphics.Rendering.Cairo.Internal.Render a0' with actual type `Render ()'
18:21:22 <wkoiking> and I can not figure out what wrong with the code?
18:21:56 <Saizan> wkoiking: do you have more than one version of cairo installed?
18:22:29 <wkoiking> I dont know
18:22:52 <Saizan> ghc-pkg list cairo
18:22:57 <Saizan> to see
18:23:41 <wkoiking> seems thera are more than one
18:25:03 <otters> is there a stdlib function :: (a -> Bool) -> a -> Maybe a
18:25:18 <Nereid> @hoogle (a -> Bool) -> a -> Maybe a
18:25:19 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
18:25:19 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
18:25:19 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
18:25:44 <Nereid> find + Identity, heh.
18:25:45 <shachaf> @ty \p x -> x <$ guard (p x)
18:25:46 <lambdabot> (Functor f, MonadPlus f) => (a -> Bool) -> a -> f a
18:25:52 <shachaf> Not really.
18:25:56 <Nereid> why not.
18:26:58 <Nisstyre-laptop> What's the function which is like iterate but just returns the final result?
18:27:11 <Nereid> what final result?
18:27:51 <Nisstyre-laptop> Nereid: I mean which would work up to a given number of iterations
18:27:55 <Nisstyre-laptop> and give the final iteration
18:28:06 <Nisstyre-laptop> I guess there's nothing like that in the stdlib, right?
18:28:10 <otters> :pl \p x -> x <$ guard (p x)
18:28:13 <otters> @pl \p x -> x <$ guard (p x)
18:28:14 <lambdabot> ap (<$) . (guard .)
18:28:20 <Eduard_Munteanu> Nisstyre-laptop: you can use (!!) on the result of iterate
18:28:26 <otters> @pl \x -> x <$ guard (f x)
18:28:26 <lambdabot> ap (<$) (guard . f)
18:28:33 <Nisstyre-laptop> Eduard_Munteanu: I suppose
18:31:21 <jmcarthur> > iterate (*2) 1 !! 10  -- Nisstyre-laptop
18:31:22 <lambdabot>   1024
18:32:25 <jmcarthur> > (`appEndo` 1) . foldMap Endo $ replicate 10 (*2)
18:32:27 <lambdabot>   1024
18:35:10 <BlindRadish> haskell is so weird - i still can't wrap my head around a lot of this stuff, like passing functions around.
18:35:48 <BlindRadish> totally the opposite of imperative.
18:35:52 <mauke> heh
18:36:03 <mauke> passing functions around is basically mainstream nowadays
18:36:08 <pnielsen> lots of imperative languages have first-class functions
18:36:11 <BlindRadish> i know lol
18:36:14 <Nereid> > ala Endo foldMap (replicate 10 (*2)) 1
18:36:17 <lambdabot>   1024
18:36:23 <mauke> see also: lisp, perl, python, and especially javascript
18:36:24 <Eduard_Munteanu> Don't worry, there's weirder stuff, like passing types around. Not in Haskell, though. :P
18:36:37 <jmcarthur> BlindRadish: if you think passing functions around is weird, wait until you get to the weird stuff!
18:36:41 <BlindRadish> perl is crazy
18:36:51 <mauke> no, perl is actually lisp
18:36:59 <BlindRadish> i was just picking the one example i could actually muster words for
18:37:03 <BlindRadish> :D
18:37:07 <jmcarthur> BlindRadish: and just when you think you've seen all there is to see, somebody will mention agda and your head will explode again
18:37:18 <BlindRadish> googling...
18:37:23 <mauke> did someone say zygohistomorphic prepromorphism?
18:37:42 <mauke> hmm
18:37:56 <mauke> if function pointers count, even C lets you pass functions around
18:38:11 <BlindRadish> jmcarthur: lol wtf??
18:38:14 <Eduard_Munteanu> Yeah, partial application and closures are the big deal.
18:38:19 <mauke> we have qsort, bsearch, signal, atexit, ... in the standard library alone
18:39:00 <BlindRadish> you guys just like doing things the hard way.
18:39:04 <BlindRadish> :D
18:39:06 <jmcarthur> BlindRadish: here is an agda type to serve as an example:    foo : (x : Bool) -> if x then String else Nat
18:39:10 <Contorer> Anyone seen @BONUS (Miran Lipovaca) lately?
18:39:25 <Eduard_Munteanu> preflex: seen BONUS
18:39:25 <preflex>  BONUS was last seen on #haskell 1 year, 272 days, 7 hours, 11 minutes and 33 seconds ago, saying: yeah i think that's better as well
18:39:25 <jmcarthur> BlindRadish: note that the *type* depends on the *value* of the argument
18:39:44 <Contorer> thanksn
18:39:51 <Eduard_Munteanu> I haven't seen him either.
18:40:12 <jmcarthur> BONUS wrote a book and then disappeared
18:40:30 <mauke> ... into a book
18:40:33 <BlindRadish> jmcarthur: nice lol
18:40:51 <lispy> Contorer: if you find him, you should let us know :)
18:40:52 <mauke> wait, is this Myst?
18:40:53 <wkoiking> Saizan: Thank you for your advice! it worked fine by unregistering unnecessary version of cairo
18:41:02 <elliott> does BONUS still respond to emails and such?
18:41:06 <lispy> Contorer: AFAICT, he's even disappeared from the twitters
18:41:10 <Eduard_Munteanu> Well, you might be able to reach him otherwise.
18:41:19 <lispy> Contorer: he used to tweet several times a day
18:41:33 <pnielsen> Contorer: he has a LinkedIn profile
18:41:45 <jmcarthur> always a shame when such regulars disappear
18:41:56 <jmcarthur> i still love this quote
18:42:01 <BlindRadish> time spent in the channel 50%, time spent of facebook 30%, time spent on misc pages 17%, time spent actually coding 3%
18:42:01 <jmcarthur> preflex: seen mmorrow
18:42:01 <preflex>  mmorrow was last seen on #ghc 3 years, 9 days, 23 hours, 44 minutes and 24 seconds ago, saying: * mmorrow is rtfm'ing
18:42:18 <lispy> jmcarthur: oh yeah, where is mmorrow
18:42:32 <jmcarthur> reading the f-ing manual
18:42:57 <Eduard_Munteanu> Alright, who misplaced mmorrow's FM, put it back please.
18:43:34 <BlindRadish> still can't figure out how to use modify... :(
18:43:34 <Contorer> lispy: thanks, will try
18:43:41 <Contorer> pnielsen: thanks, will check that now
18:43:46 <BlindRadish> see several examples. google not helping
18:44:00 <jmcarthur> BlindRadish: as in for the state monad?
18:44:13 <BlindRadish> yeah, let me try something
18:44:18 <BlindRadish> i think i gopt it
18:44:39 <jmcarthur> BlindRadish: if functions as values still blows your mind, the state monad is going to be pretty unapproachable, i think
18:44:48 <Contorer> pnielsen: don't see it, link?
18:45:06 <BlindRadish> just need to create a state and use modify on it.
18:45:18 <BlindRadish> not sure struggling
18:45:38 <BlindRadish> do i need to initialize something or something
18:45:39 <BlindRadish> ?
18:45:51 <jmcarthur> BlindRadish: you will need to use runState
18:45:54 <jmcarthur> :t runState
18:45:56 <lambdabot> State s a -> s -> (a, s)
18:45:58 <Eduard_Munteanu> The initial state is given to the run/exec/eval function.
18:46:18 <jmcarthur> :t modify
18:46:19 <lambdabot> MonadState s m => (s -> s) -> m ()
18:46:26 <Eduard_Munteanu> > runState (modify (+ 2)) 3
18:46:28 <lambdabot>   ((),5)
18:46:36 <jmcarthur> > modify (*11) `runState` 42
18:46:38 <lambdabot>   ((),462)
18:46:43 * lispy has to run
18:46:49 <pnielsen> Contorer: hmm, neither. I think he removed/hid it. Swear I remember looking at it a little while ago. I remember being surprised that he didn't work with haskell/in a "lowly" local sysadmin job
18:47:03 <jmcarthur> lispy: drink plenty of fluids!
18:47:08 <BlindRadish> I don't understand why you would have to!
18:47:12 <mauke> > runState (do { modify (+1); modify (*2); modify show }) 20
18:47:13 <otters> I defined the prism null_ as null_ = prism' id (\x -> if null x then Just x else Nothing)
18:47:14 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
18:47:15 <lambdabot>    arising from the literal ...
18:47:15 * Eduard_Munteanu kinda hates the order of arguments for runState and similar stuff.
18:47:24 <mauke> > runState (do { modify (+1); modify (*2); }) 20
18:47:26 <lambdabot>   ((),42)
18:47:30 <jmcarthur> BlindRadish: how would it know what the state to modify is otherwise?
18:47:31 <otters> and I can update empty records of something with null_ .~ newObject
18:47:49 <otters> err...
18:48:08 <Eduard_Munteanu> mauke: looking for the indexed state monad?
18:48:14 <pnielsen> Contorer: FWIW he lists bonus@learnyouahaskell.com as a way to get in touch
18:48:17 <BlindRadish> okay, its now working but returning ((),1)
18:48:23 <jmcarthur> :t execState
18:48:24 <lambdabot> State s a -> s -> s
18:48:25 <jmcarthur> :t evalState
18:48:27 <lambdabot> State s a -> s -> a
18:48:32 <jmcarthur> ^^ alternatives to runState
18:48:41 <mauke> @src execState
18:48:41 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:49:51 <BlindRadish> like this? test = runState (modify (lfsr (46080,1))) 0
18:50:12 <jmcarthur> ugh gtk2hs is such a pain to install
18:50:15 <Eduard_Munteanu> What's the type of lfsr?
18:50:31 <BlindRadish> tuple - (word, word)
18:50:34 <BlindRadish> basically
18:50:50 <BlindRadish> don't ask me for a curry looking type
18:51:02 <BlindRadish> tuple -> tuple thing
18:51:07 <BlindRadish> or something lol
18:51:18 <Eduard_Munteanu> BlindRadish: mind the argument to modify has to be a function
18:51:24 <BlindRadish> does that 0 need to be the intitial state?
18:51:42 <BlindRadish> so like lfsr))) (1,1)?
18:51:45 <Eduard_Munteanu> If you want to set the state to a particular value, use 'put' instead.
18:52:00 <Eduard_Munteanu> No, it can be anything you want.
18:52:27 <jmcarthur> BlindRadish: the 0 is the initial state, yes, but you can override it with put in the monad itself
18:52:47 <BlindRadish> test = runState (modify lfsr) (46080,1) not updating
18:52:49 <jmcarthur> BlindRadish: but you must supply an initial state to runState in order for it to work at all, so you might as well just put it there
18:53:04 <BlindRadish> i can override with put anytime?
18:53:15 <jmcarthur> all put does is replace the state
18:53:15 <mauke> BlindRadish: what is the runState there for?
18:53:24 <BlindRadish> and i can "get" when i want to use whatever is in the state, right?
18:53:33 <mauke> test = ((), lfsr (46080, 1))
18:53:36 <BlindRadish> someone told me to do it that way and I wondered why I needed to.
18:54:08 <Eduard_Munteanu> I guess you want execState here.
18:54:24 <BlindRadish> the output I get is ((),(46080,46080))
18:54:35 <jmcarthur> BlindRadish: if you don't actually want the return value then you want execState as i said earlier
18:54:55 <BlindRadish> Eduard_Munteanu: whats the difference?
18:54:57 <mauke> if you're just using 'modify', you don't want State at all
18:55:16 * hackagebot bifunctors 3.0.4 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0.4 (EdwardKmett)
18:55:18 * hackagebot network-api-support 0.0.2 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.0.2 (MarkHibberd)
18:55:26 <jmcarthur> BlindRadish: also, as i said earlier, i think the state monad is really over your head at this stage. you should probably just be trying to write some normal programs in haskell for a while and just pick up more advanced things as you go
18:55:30 <BlindRadish> its a random number generator, I want to get and set state each time the function is called.
18:55:43 <BlindRadish> I need it to continue my project :'(
18:56:06 <jmcarthur> BlindRadish: i think you misunderstand what the state monad does. it doesn't actually keep a state that persists each time you call some function. it just represents a state transition
18:56:07 <Eduard_Munteanu> BlindRadish: execState f s = snd (runState f s)
18:56:25 <BlindRadish> oh snap
18:56:42 <BlindRadish> i'm building a random number generator
18:56:46 <Eduard_Munteanu> The second component is the state.
18:56:57 <jmcarthur> @unmtl State s a
18:56:58 <lambdabot> s -> (a, s)
18:57:11 <jmcarthur> ^^ see? just a function from a state to a new state and some return value
18:57:47 <BlindRadish> so does that return a tuple?
18:57:52 <Eduard_Munteanu> BlindRadish: one possible way to represent a RNG is to have it produce an infinite list of random numbers, lazily.
18:58:26 <BlindRadish> okay but how can i avoid producing the same number twice?
18:58:50 <BlindRadish> its a requirement of random number generators to know which numbers they've generated so far.
18:59:07 <Eduard_Munteanu> Um, not really.
18:59:43 <BlindRadish> Eduard_Munteanu: dude it's like a thing, if you curry it around you still know where it's been.
19:00:22 <Eduard_Munteanu> What you want instead is some interface to that RNG so you don't reuse the same numbers over and over.
19:01:02 <BlindRadish> thats the idea
19:01:11 <BlindRadish> can you help me out then? :)
19:01:40 <BlindRadish> that interface needs to be monadic?  is that a term or a keyword?
19:01:43 <Eduard_Munteanu> For that, you could build a monad for that RNG, that e.g. uses state.
19:02:17 <BlindRadish> thats what i've been meaning to do lol, but i'm super rookie
19:02:22 <Eduard_Munteanu> But let's just use State for now.
19:02:54 <Eduard_Munteanu> One approach is to have the infinite list of random numbers as your state.
19:03:19 <Eduard_Munteanu> Each time some code requests a random number, you remove the head of the list and return it.
19:03:26 <hpaste> otters pasted “lens question” at http://hpaste.org/81343
19:03:31 <BlindRadish> are you serious?
19:03:38 <BlindRadish> thats so weird lol
19:03:59 <BlindRadish> and how will it remember that there is one list?  recursion?
19:03:59 <edwardk> otters you can use singular
19:04:02 <edwardk> :t singular
19:04:02 <hpaste> otters annotated “lens question” with “lens question (annotation)” at http://hpaste.org/81343#a81344
19:04:03 <lambdabot> (Functor f, Conjoined p) => Over p (Control.Lens.Internal.Bazaar.BazaarT p f a a) s t a a -> Over p f s t a a
19:04:11 <edwardk> you can also use (^?!)
19:04:21 <otters> hmm
19:04:22 <edwardk> (^?!) is like ^? but it asserts the answer will be Just
19:04:24 <otters> I'll look at singular first
19:04:25 <Eduard_Munteanu> BlindRadish: the list is the state
19:04:28 <otters> (^?!) confused me a lot
19:04:30 <edwardk> > Left 4 ^?! _Left
19:04:34 <lambdabot>   4
19:04:38 <edwardk> > Left 4 ^?! _Right
19:04:40 <lambdabot>   *Exception: (^?!): empty Fold
19:04:45 <BlindRadish> Eduard_Munteanu: thanks, that's weird but I'll give it a while.
19:04:53 <edwardk> > Left 4 ^. singular _Left
19:04:55 <lambdabot>   4
19:04:58 <edwardk> > Left 4 ^. singular _Right
19:05:00 <lambdabot>   *Exception: singular: empty traversal
19:05:05 <otters> edwardk: okay so the field itself is of type Maybe
19:05:13 <ion> > "foo" ^? base 36
19:05:15 <lambdabot>   Just 20328
19:05:16 <ion> > "foo" ^?! base 36
19:05:17 <edwardk> sure. you can 'traverse' its contents.
19:05:19 <lambdabot>   20328
19:05:21 <Eduard_Munteanu> BlindRadish: getRandom = do { (x:xs) <- get; put xs; return x }
19:05:34 <edwardk> f^?!a.traverse
19:06:08 <edwardk> > (1,Just 2)^!?_2.traverse
19:06:10 <lambdabot>   No instance for (GHC.Show.Show (m0 (Data.Maybe.Maybe a0)))
19:06:10 <lambdabot>    arising from ...
19:06:20 <edwardk> > (1,Just 2)^?!_2.traverse
19:06:23 <lambdabot>   2
19:06:31 <Eduard_Munteanu> BlindRadish: as for types, getRandom :: State [Int] Int   (assuming you use Int)
19:06:31 <otters> oh, cool
19:06:46 <ion> There’s a (^!?)?
19:07:02 <otters> !!
19:08:15 <Eduard_Munteanu> zomg?!?
19:09:34 <Eduard_Munteanu> BlindRadish: of course you could also have getRandom use a single number as the state
19:10:16 * hackagebot MusicBrainz 0.1.1 - interface to MusicBrainz XML2 web service  http://hackage.haskell.org/package/MusicBrainz-0.1.1 (ClintAdams)
19:10:24 <jmcarthur> BlindRadish: rngs don't need to remember past numbers they've generated
19:10:43 <jmcarthur> BlindRadish: a real rng might even return the same number more than once...
19:12:12 <Eduard_Munteanu> In fact, a real RNG's output must *not* depend on previous outputs.
19:12:43 <Eduard_Munteanu> Pseudo RNGs though need to track some state.
19:13:02 <Eduard_Munteanu> (which is usually the previously generated value)
19:13:08 <edwardk> ion: the other is for previewing an action
19:13:13 <edwardk> :t (^!?)
19:13:14 <lambdabot> Monad m => s -> Acting m (Leftmost a) s t a b -> m (Maybe a)
19:13:26 <edwardk> works well on monadic folds
19:13:31 <edwardk> well, passably well
19:13:34 <c_wraith> Actually, it's a really nice property if the current state doesn't tell you much useful about previous outputs from the PRNG
19:13:38 <edwardk> it has too many effects to be ideal
19:16:41 <BlindRadish> jmcarthur: i know but obviously you need some state of some kind to know where your place is
19:17:30 <BlindRadish> jmcarthur: i have a pure function generate the random number, and i'll need a monoid thing which i actually call.
19:19:40 <BlindRadish> or not if i can get away with a list.
19:22:16 <Eduard_Munteanu> BlindRadish: you'll still need to generate the list
19:22:39 <Eduard_Munteanu> BlindRadish: as I said, an Int state is fine too.
19:22:47 <BlindRadish> i have a function that generates a single random number, which i can easily plug back in.
19:23:14 <BlindRadish> but i have no idea where i would plug it into the code you gave me lol.  still rookie. :(
19:23:41 <BlindRadish> I use word because my lfsr uses xor and shift, so i need it unsigned.
19:24:20 <Eduard_Munteanu> BlindRadish: getRandom = do { s <- get; let new = yourFunction s; put new; return new }
19:26:44 <Eduard_Munteanu> Or more nicely, getRandom = do { modify yourFunction; get }
19:29:22 <BlindRadish> failed on put new, probably because there's no initial value?
19:29:48 <BlindRadish> i like this modify bit, i can use it in /this/ case and still use the others, right?
19:30:16 <Eduard_Munteanu> BlindRadish: what do you mean "failed"? Of course, you do need to run that getRandom somehow.
19:30:32 <Eduard_Munteanu> Actually not getRandom, but the entire thing that uses it.
19:31:05 <Eduard_Munteanu> Yeah, modify doesn't exclude get/put.
19:31:09 <BlindRadish> how do i put a value in the first time?
19:31:36 <BlindRadish> i want to use the modify one
19:31:49 <Eduard_Munteanu> BlindRadish: you supply it to evalState
19:31:50 <BlindRadish> do i literally just put ; get } ?
19:32:11 <BlindRadish> whats evalState?
19:32:28 <Eduard_Munteanu> evalState f s = fst (runState f s)
19:32:36 <Eduard_Munteanu> You don't need get/put.
19:33:10 <BlindRadish> so the first time i call that there's no f?
19:33:14 <Eduard_Munteanu> Say you have some big State action containing multiple getRandom and other stuff. You apply evalState to that big action, supplying the initial state as well.
19:33:16 <M30W> How would you structure a data structure in subsets? data A = B { Q | W | E } | C { T | Y | U } ?
19:33:26 <M30W> I know that's not valid but shows kinda what I am after..
19:33:58 <M30W> Or.. I could just split them up O.o
19:33:59 <ion> data A = B B | C C; data B = Q | W | E; data C = T | Y | U
19:34:03 <M30W> Yea. :)
19:34:06 <BlindRadish> man i'm gonna have to reread all the tutorials :(
19:34:50 <Eduard_Munteanu> BlindRadish: for example,   evalState (do { x <- getRandom; y <- getRandom; return (foo x y) }) 1234
19:35:00 <M30W> Would all the qwertyu match into a ?
19:35:03 <M30W> (typeset)
19:35:40 <BlindRadish> can i do that with runState?
19:35:41 <Eduard_Munteanu> Though normally I'd write that as  flip evalState 1234 $ do  ....
19:35:58 <Eduard_Munteanu> BlindRadish: yes, runState also returns the state
19:36:30 <BlindRadish> so... not like this: ra = do { runState (+1) 1  }
19:38:11 <BlindRadish> and not this? ra = runState ( do { + 1 } 1 )
19:39:47 <BlindRadish> ugh.
19:39:56 <ion> (+1) isn’t a value of type State s a, + 1 is a syntax error.
19:41:13 <BlindRadish> ion: i create a variable to put there?
19:41:44 <ion> blindradish: Do you want to modify the state with (+1)?
19:41:49 <ion> > runState (modify (+1)) 1
19:41:51 <lambdabot>   ((),2)
19:42:25 <ion> modify f = do a <- get; put (f a)
19:42:35 <ion> modify f = state (\a -> ((), f a))
19:43:17 <BlindRadish> I need to call my function lfsr with the state, and store the return, but i also need to use the return
19:44:02 <BlindRadish> i need runState /and/ modify?
19:44:49 <latro`a> runState is to actually run the whole calculation, whereas modify gives you a State value
19:45:12 <YayMe`> haha BlindRadish still trying to open gl something
19:45:26 <BlindRadish> nah, never was
19:45:55 <BlindRadish> opengl'd a few things before i found the forums, trying to build a random number generator all day
19:46:10 <BlindRadish> cant figure out how to do the state
19:46:15 <BlindRadish> i feel like i'm going in circles.
19:46:44 <ion> > runState (do modify (+1); a <- get; return (a*100)) 1
19:46:45 <lambdabot>   (200,2)
19:46:51 <ion> > runState (do a <- id <+= 1; return (a*100)) 1
19:46:53 <lambdabot>   (200,2)
19:47:10 <YayMe`> @type (<+=)
19:47:12 <lambdabot> (Num a, MonadState s m) => LensLike' ((,) a) s a -> a -> m a
19:47:47 <YayMe`> haha some lens thing..
19:48:20 <YayMe`> BlindRadish: How long have you been fiddling with Haskell?
19:48:32 <Nereid> > runState (fmap (*100) $ id <+= 1) 1
19:48:33 <BlindRadish> on and off for a few months
19:48:34 <lambdabot>   (200,2)
19:48:40 <edwardk> += modifies the target of a lens in the current state by adding to it. <operator=   also returns the result of doing so as the result of that monadic action
19:48:43 <edwardk> :t (+=)
19:48:44 <[mth]> Anyone have any clues why even the most basic http-conduit example fails on OSX -> https://gist.github.com/4646166
19:48:44 <lambdabot> (Num a, MonadState s m) => ASetter' s a -> a -> m ()
19:48:50 <edwardk> :t (<+=)
19:48:51 <lambdabot> (Num a, MonadState s m) => LensLike' ((,) a) s a -> a -> m a
19:49:02 <BlindRadish> got stuck on the tutorial with some syntax, i forget which
19:49:15 <BlindRadish> was showing someone where i was stuck and finally got it lol
19:49:17 <edwardk> you can += any setter. but to <+= i need to be able to accumulate a summary of all the writes you made
19:49:20 <YayMe`> edwardk: What are lenses? You guys keep talking about them
19:49:23 <BlindRadish> so i've been doing some coding
19:49:40 <ion> yayme: See the video linked from
19:49:43 <ion> @hackage lens
19:49:43 <lambdabot> http://hackage.haskell.org/package/lens
19:49:45 <YayMe`> edwardk: Or to put it another way, why are they?
19:49:47 <edwardk> YayMe`: a lens is basically a 'getter and a setter' balled up into a first class object you can compose.
19:50:11 <edwardk> YayMe`: this makes it nicer to work with members of members of things, in deep pure nested objects.
19:50:13 <YayMe`> edwardk: Ah. Interesting. Now I'm going to have to figure out how they work
19:50:35 <edwardk> YayMe`: now, the lens package is all about these, and a ton of generalizations of this concept, and making them all compose well.
19:50:43 <Nereid> don't look at the internals, they're scary.
19:50:59 <YayMe`> edwardk: So it's the answer to the fact that the record name access is horrible?
19:51:06 <edwardk> YayMe`:  http://youtu.be/cefnmjtAolY?hd=1 is be talking for ~2 hours giving a crash course, http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf  is the slides from that talk
19:51:12 <edwardk> YayMe`: yes
19:51:42 <edwardk> you can make lenses for a type just by defing     data Foo a = Foo { _bar :: Int, _baz :: Double, _quux :: a } ; makeLenses ''Foo
19:52:00 <edwardk> and then you can read and update them with the lenses, bar, baz, and quux that will be generated by makeLenses.
19:52:07 <Nereid> > ("hello", "world") ^. _1
19:52:09 <lambdabot>   "hello"
19:52:24 <Nereid> > _1 .~ "YayMe`" $ ("hello", "world")
19:52:25 <lambdabot>   ("YayMe`","world")
19:52:30 <Nereid> er, I wanted to _2
19:52:31 <edwardk> > ("hello","world") & _1 %~ length
19:52:33 <lambdabot>   (5,"world")
19:53:03 <ion> > runState (do a <- _2 <+= 1; return (a*100)) ("foo",42)
19:53:05 <lambdabot>   (4300,("foo",43))
19:53:29 <mm_freak> hah!  reactive fibonacci numbers using netwire:  fixW (delay 0 . accum (+) 1)
19:53:30 <mm_freak> =)
19:53:31 <edwardk> the notion of lenses in the lens package push the boundaries in many ways… violating what a lot of people consider good taste in haskell, to try to get a nice internally consistent api for dealing with lenses, traversals, a form of smart constructor we call a prism, etc.
19:53:40 <ion> > runState (do a <- _2._2 <+= 1; return (a*100)) ("foo",("bar",42))
19:53:42 <lambdabot>   mueval-core: L.hs: removeLink: does not exist (No such file or directory)
19:53:46 <ion> > runState (do a <- _2._2 <+= 1; return (a*100)) ("foo",("bar",42))
19:53:49 <lambdabot>   (4300,("foo",("bar",43)))
19:54:05 <Nereid> > ("hello", "world") & _1 . ix 0 .~ 'j'
19:54:07 <lambdabot>   ("jello","world")
19:54:19 <YayMe`> edwardk: That is awesome.
19:54:23 <edwardk> mm_freak: that sounds like https://github.com/ekmett/comonad/blob/master/examples/History.hs#L54
19:54:32 <Nereid> is lambdabot on 3.8 now?
19:54:38 <edwardk> Nereid: yes
19:56:21 <mm_freak> edwardk: except that you can actually bring time into this =)
19:56:23 <mm_freak> hold 0 (fixW (delay 1 . accum (+) 1) . periodically 0.5)
19:56:27 <mm_freak> one fib every 500ms =)
19:56:50 <BlindRadish> okay I don't understand runState.  runState (State) (function)?
19:56:59 <Nereid> :t runState
19:56:59 <BlindRadish> what goes in the boxes?
19:57:00 <lambdabot> State s a -> s -> (a, s)
19:57:16 <Nereid> it takes a State action, and an intial state
19:57:22 <Nereid> and gives you the result of the action, as well as the final state.
19:57:29 <Nereid> also, State s a is actually isomorphic to s -> (a,s)
19:57:41 <mm_freak> i think, i'll stop calling netwire AFRP…  it's nothing like AFRP these days…  it's, well, WFRP
19:57:48 <otters> which is prettier: f $ fromJust (field obj) or f $ obj^?!field.traverse
19:58:03 <mm_freak> otters: (f . fromJust . field) obj
19:58:16 <BlindRadish> Nereid: that makes a bit more sense
19:59:00 <Nereid> so the exercise is to implement the monad operations for newtype State s a = State (s -> (a,s))
19:59:01 <mm_freak> otters: and none of those are pretty…  if you have a Maybe, you should use a prism
19:59:03 <M30W> Lol irc rfc. "YourBannedCreep" XD
19:59:14 <otters> oh
19:59:20 <otters> mm_freak: that's what I thought
19:59:49 * M30W is making his attempt to make a full irc library for haskell. :)
19:59:59 <mm_freak> M30W: take inspiration from fastirc =)
20:00:31 <otters> mm_freak: how would you use a Prism with that
20:00:37 <mm_freak> i'm planning to make a new version for a long time now
20:00:39 <M30W> mm_freak: So far I have 123 lines.... I only have the data Responce = Reply | Error; data Reply = ...; data Error = ... XD
20:00:43 <M30W> SO MANY!
20:01:07 <mm_freak> otters: _just?
20:01:16 <ion> blindradish: This may or may not be helpful: http://heh.fi/state-monad
20:01:20 <otters> ooh
20:01:23 <mm_freak> M30W: it doesn't pay of to differentiate between requests and responses
20:01:26 <mm_freak> they are the same thing in IRC
20:01:32 <mm_freak> off
20:01:35 <otters> obj ^. field._Just
20:02:02 <applicative> has the ?? operator in Control.Lens been used before as flip?
20:02:07 <Nereid> well not ^.
20:02:10 <M30W> mm_freak: I know but would be useful for handeling the errors beter; The messages will be straight turned to type. Then from the types dealt with from there
20:02:15 <edwardk> applicative: not before lens that i know of
20:02:33 <otters> mm_freak: f (obj^.field._Just) ?
20:02:39 <M30W> ^^ Screw the numbers or processing everything; mapping them with data. :D
20:02:45 <Nereid> > (Just 3, "blah") ^?! _1._Just
20:02:47 <lambdabot>   3
20:02:49 <applicative> >> foldr ?? 0 (+) [1,2,3]
20:02:52 <edwardk> otters: obj ^? field._Just    obj^?field.traverse   obj^?field.each   any of those work
20:02:56 <applicative> > foldr ?? 0 (+) [1,2,3]
20:02:57 <lambdabot>   Could not deduce (GHC.Num.Num ((a0 -> a0 -> a0) -> [t0] -> a))
20:02:57 <lambdabot>    arising f...
20:02:59 <Nereid> > (Nothing, "blah") ^?! _1._Just
20:03:00 <applicative> oops
20:03:01 <lambdabot>   *Exception: (^?!): empty Fold
20:03:10 <edwardk> applicative: it only works on the second to last position
20:03:12 <M30W> Also that reminds me.... How should I go for converting the server given string (the number/code) and converting to the fullname?
20:03:12 <otters> right edwardk I'm just trying to figure out the best way to do this
20:03:21 <edwardk> applicative: you can move over more args but you have to chain in a funny way
20:03:36 <otters> because I have to use fromJust a lot in this project in places where, speaking terms of type-safety, parsing can fail, but it won't have
20:03:38 <Nereid> > (foldr ?? 0) (+) [1,2,3]
20:03:40 <lambdabot>   6
20:03:41 <edwardk> >> foldr ?? 0 ?? [1,2,3] ?? (+)
20:03:46 <Nereid> lol
20:03:49 <edwardk> >> foldr ?? 0 ?? [1,2,3] $ (+)
20:03:50 <edwardk> > foldr ?? 0 ?? [1,2,3] $ (+)
20:03:52 <YayMe`> edwardk: So you showed me there's getters and setters for tuples, I presume there's getters and setters for data types as well? Lists too?
20:03:52 <lambdabot>   6
20:04:11 <Nereid> > [0,1,2,3,4] ^. ix 3
20:04:13 <lambdabot>  Terminated
20:04:15 <edwardk> basically if you want to move over more than one argument, you separate the remaining ones with ??'s
20:04:16 <Nereid> > [0,1,2,3,4] & ix 3 .~ 9
20:04:19 <lambdabot>   [0,1,2,9,4]
20:04:34 <edwardk> this actually works out pretty well because they can have spaces between their own applications, etc. and it kills a ton of parens
20:04:39 <edwardk> but its a little weird to read
20:04:58 <edwardk> YayMe`: yes, and maps, and all sorts of things.
20:05:07 <edwardk> @hackage lens
20:05:07 <applicative> > map (takeWhile ?? [1..]) [(< 2),(<20)]
20:05:07 <lambdabot> http://hackage.haskell.org/package/lens
20:05:09 <BlindRadish> ion: thanks.  i've been at this too long today, i'm out of steam.  like a 16 hours straight i've been doing this lmao.
20:05:09 <lambdabot>   [[1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]]
20:05:15 <edwardk> YayMe`: wander around in that for a few minutes
20:05:29 <BlindRadish> good night guys
20:05:35 <BlindRadish> thanks for all the help
20:05:35 <applicative> @type runState
20:05:37 <lambdabot> State s a -> s -> (a, s)
20:05:51 <Nereid> > M.fromList [(1,"a"), (2,"b")] ^. ix 2
20:05:53 <lambdabot>   "b"
20:06:24 <Nereid> > M.fromList [(1,"a"), (2,"b")] ^. at 2
20:06:25 <lambdabot>   Just "b"
20:06:29 <M30W> mm_freak: http://ix.io/48V
20:06:29 <Nereid> > M.fromList [(1,"a"), (2,"b")] & at 2 .~ Nothing
20:06:31 <lambdabot>   fromList [(1,"a")]
20:06:31 <M30W> ♥
20:06:33 <Nereid> > M.fromList [(1,"a"), (2,"b")] & at 3 .~ Just "hello"
20:06:35 <lambdabot>   fromList [(1,"a"),(2,"b"),(3,"hello")]
20:07:01 <BlindRadish> ion: oh thats very helpful
20:07:11 * M30W wonders how to map them to their numbers... Instance from Integer ?
20:07:28 <Nereid> oh I guess I was lucky with ^. on that map because strings are monoids.
20:07:30 <Nereid> er
20:07:33 <Nereid> strings are a monoid.
20:07:43 <BlindRadish> ion: but i only need s -> (s',s'), is there a simpler way?
20:09:00 <BlindRadish> ion: this text is very helpful thanks
20:09:42 <applicative> > let tick = id += 1 in execState ?? 0 $ tick >> tick >> tick
20:09:45 <lambdabot>   3
20:09:52 <M30W> Completions ♥ Now.. Just need to get them into vim (and understanding the imports) XD
20:11:42 <applicative> > let tick = _1 += 1; tock = _2 += 1 in execState ?? (0,0) $ tick >> tock >> tick >> tock >> tick
20:11:44 <lambdabot>   (3,2)
20:12:01 <M30W> Nice
20:12:25 <YayMe`> edwardk: Interesting. So while we've had state of all sorts in our pure bottles all this time, lenses are basically saying we never had a consistent effective way of interacting with that state
20:13:37 <edwardk> YayMe`: lenses give you an effective way to access fields, and parts of a whole. the generalizations of lenses let you do things like edit multiple parts, work like a fake constructor, witness an isomorphism that goes both ways so you can turn it around, lift functions into getters, lift functors into setters, etc.
20:14:00 <edwardk> the nice thing from a user perspective is that all these concepts compose with (.) from the Prelude.
20:14:14 <edwardk> and you can define a lens without depending on the lens package
20:14:41 <edwardk> someone joked that i've now optimized my libraries to the point where you don't even need to depend on them to use them any more.
20:14:54 <Nereid> hehe
20:14:57 <YayMe`> heh
20:15:53 <edwardk> this latter property is important for lens, because it greatly facilitates adoption. completely haskell 98 packages can supply lenses that are usable by this rather megalithic monstrosity that is lens without incurring any dependencies or overhead.
20:18:29 <YayMe`> edwardk: I'm confused, I can use lens functions without importing any lens libraries?
20:18:44 <YayMe`> edwardk: How long have lens been being developed?
20:19:13 <edwardk> YayMe`: you can define a lens using just stuff from the Prelude. to use the lens combinators to _use_ that lens you need to depend on lens or implement a compatible scheme yourself.
20:19:35 <edwardk> YayMe`: i started it in July.
20:20:19 <edwardk> _2 f (a,b) = (,) a <$> f b   is a perfectly legitimate lens. notice it doesn't use anything from my library, just stuff in base
20:20:23 * hackagebot bifunctors 3.1 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.1 (EdwardKmett)
20:23:10 <YayMe`> edwardk: but your library gives that _2 the ability to do a bunch more stuff
20:23:28 <edwardk> YayMe`: sure. but you could write those combinators yourself if you had to
20:23:53 <edwardk> s ^. l = getConst (l Const s)
20:24:16 <edwardk> > let s ^. l = getConst (l Const s); _2 f (a,b) = (,) a <$> f b in (1,2)^._2
20:24:18 <lambdabot>   2
20:24:33 <ion> edwardk: Not using base only, though.
20:25:02 <ion> If you want to make them index-preserving etc.
20:25:29 <edwardk> > let s ^. l = getConst (l Const s); (%~) l f s = runIdentity . l (Identity . f); _2 f (a,b) = (,) a <$> f b in (1,"hello") & _2 %~ length;
20:25:31 <lambdabot>   <hint>:1:137: parse error on input `;'
20:25:44 <edwardk> > let s ^. l = getConst (l Const s); (%~) l f s = runIdentity . l (Identity . f); _2 f (a,b) = (,) a <$> f b in (1,"hello") & _2 %~ length
20:25:45 <lambdabot>   No instance for (GHC.Show.Show ((a0, [a1]) -> (a0, GHC.Types.Int)))
20:25:46 <lambdabot>    aris...
20:25:52 <edwardk> > let s ^. l = getConst (l Const s); (%~) l f s = runIdentity . l (Identity . f); _2 f (a,b) = (,) a <$> f b in (1,"hello") & (_2 %~ length)
20:25:53 <lambdabot>   No instance for (GHC.Show.Show ((a0, [a1]) -> (a0, GHC.Types.Int)))
20:25:54 <lambdabot>    aris...
20:26:03 <edwardk> > let s ^. l = getConst (l Const s); (%~) l f = runIdentity . l (Identity . f); _2 f (a,b) = (,) a <$> f b in (1,"hello") & (_2 %~ length)
20:26:06 <lambdabot>   (1,5)
20:26:09 <edwardk> > let s ^. l = getConst (l Const s); (%~) l f = runIdentity . l (Identity . f); _2 f (a,b) = (,) a <$> f b in (1,"hello") & _2 %~ length
20:26:11 <lambdabot>   (1,5)
20:26:13 <edwardk> there =)
20:26:14 <shachaf> minilens
20:26:43 <YayMe`> edwardk: what is the core idea that makes your getter and setter generalizations better than the way we currently get and set values?
20:26:46 <edwardk> ion: sure. lens goes pretty far above and beyond the call and offers up lots of things you really do need the package for once you've been sucked in by the concept.
20:27:20 <M30W> How would one have an instance of a data strucutre to convert "372" to Motd :: Reply :: Responce ?
20:27:26 <edwardk> > [(1,"hello"),(2,"world"),(3,"yay"),(4,"me")] & traversed._2 %~ length
20:27:29 <lambdabot>   [(1,5),(2,5),(3,3),(4,2)]
20:27:47 <edwardk> YayMe`: you could write that without lens. but it'd be rather ad hoc
20:27:51 <YayMe`> edwardk: Is there some form of consistency across types that makes it better? is it just some more combinators we didn't previously have?
20:28:08 <shachaf> The main thing is composability.
20:28:18 <shachaf> Putting a lot of different types into a common framework so they can interact with each other.
20:28:25 <YayMe`> gotcha
20:28:29 <edwardk> YayMe`: lens is about taking the things you already know how to use Functors, Foldables, Traversables, functions, data constructors, and making it so they all live in a common framework where they can all be composed.
20:28:31 <shachaf> Oops, it's YayMe`.
20:28:33 <YayMe`> giving a base for consistency
20:29:02 <edwardk> _2 there was a Lens. 'traverse' is a "Traversal". when composed they formed a traversal.
20:30:35 <edwardk> he majority of the controversy around it is that it takes a very unhaskelly approach to picking its names, and it takes a lot of them, but i wanted something that gave a nice large _consistent_ vocabulary to the end user for working with lenses, traversals, zippers, etc that the end user could grow into.
20:30:48 <YayMe`> edwardk: where as currently many of the things the combinators in lens do are done as you said; ad hoc frequently in everyone's code differently when they need to do those things; you give a common set for everyone to use for consistency. you want it to act as a base set of utilities for people to write all their libs with which is why adoption is important. like jquery to javascript, lots of it's functions are easy in javascript but it
20:30:48 <YayMe`> gives consistency to the community for doing those things
20:31:24 <edwardk> i'm less concerned with consistency than efficiency and concise expression.
20:31:53 <YayMe`> i mean consistency in the community, that they use your lib for those activities rather than inconsistent ad hoc approaches each time they want to do those things
20:32:07 <edwardk> sure, but to me the consistency i value out of lens is the consistency within lens. that say (^.) does what you mean on a getter, fold, traversal, iso, prism, equality, and on any indexed version of those things, etc.
20:32:25 <edwardk> in most other libraries you'd be faced with 10 versions of one operator or some explicit cast
20:32:33 <YayMe`> right
20:32:38 <YayMe`> that's what I mean with consistency
20:32:47 <YayMe`> heh cool. makes sense.
20:33:06 <edwardk> the video goes into a deeper sales pitch about how it all fits together.
20:33:30 <YayMe`> what makes its names "unhaskelly" they're appropriately obfuscated to the uninitiated, I think that's right in line with haskell heh
20:35:13 <edwardk> well, what i mean is it deliberately tries to take names in under-occupied portions of the namespace. starting with _'s, past tenses, gerunds (nouns ending in -ing), etc.
20:35:49 <edwardk> in practice this has worked out pretty well, it makes the api feel very declarative
20:35:59 <edwardk> > [1..10]^.traverse.filtered even
20:36:01 <lambdabot>   Ambiguous type variable `a0' in the constraints:
20:36:01 <lambdabot>    (GHC.Real.Integral a0)
20:36:01 <lambdabot> ...
20:36:05 <edwardk> > [1..10]^..traverse.filtered even
20:36:07 <lambdabot>   [2,4,6,8,10]
20:36:28 <edwardk> > ([1..10],[11..20])^..both.traverse.filtered even
20:36:30 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
20:37:45 <edwardk> > ("hello","world",["These","are","Strings!"],()) & biplate %~ toUpper
20:37:47 <lambdabot>   ("HELLO","WORLD",["THESE","ARE","STRINGS!"],())
20:38:24 <YayMe`> edwardk: your use of ^. exposes an interesting aspect of GHC's function parsing... I would have expected white space needed between the set of .'s, I mean how does haskell tell ^. from a function ^ and .
20:38:31 <M30W> How would you say response can be either Right Welcome :: Either Reply b and also Left NoMotd :: Either Error b?
20:38:43 <edwardk> > ("hello","world",["These","are","Strings!"],()) & partsOf biplate %~ (reverse :: String -> String)
20:38:45 <lambdabot>   ("!sgni","rtSer",["aeseh","Tdl","rowolleh"],())
20:38:59 <edwardk> > ("hello","world",["These","are","Strings!"],()) & partsOf biplate %~ (reverse :: [String] -> [String])
20:39:01 <lambdabot>   ("Strings!","are",["These","world","hello"],())
20:39:09 <YayMe`> haha
20:39:19 <edwardk> YayMe`: in haskell any sequence of operator characters in haskell is an operator basically
20:39:42 <YayMe`> oh, were you using a function ^.. ?
20:39:53 <edwardk> yeah
20:39:55 <YayMe`> gotcha
20:40:19 <edwardk> ^.. takes a value and any 'Fold' for that value and applies it, getting out all the targets of the fold as a list.
20:40:22 <S11001001> M30W: add another Either?
20:40:38 <shachaf> > ([1..10],[11..20])^..both.traversed.Lens.indices odd
20:40:40 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
20:40:54 <maki`> how do I get more details  about linking errors when loading my package?  right now I am just getting "Loading package XY.. linking .. unable to load package"
20:41:16 <shachaf> maki`: -v?
20:42:00 <M30W> S11001001: How about stripping the Left/Right cause I kinda already have that with my Response = Reply | Error | Response { ... responce :: ???? (Either Reply or Error) ... }
20:42:18 <jollytime> why doesn't flip (:) '1' [] work?
20:42:29 <shachaf> Because (:) 'a' [] does.
20:43:10 <arbn> Has anyone had the problem of not having record constructors scoped when building with cabal, but getting them when loading the module otherwise?
20:43:12 <maki`> shachaf this is odd, I get error when loading a module in ghci, but not when I compile my program with ghc
20:43:35 <arbn> The record itself is a product of a TH QQer, if that makes a difference.
20:43:36 <S11001001> M30W: sure
20:43:37 <jollytime> shachaf, aha :)
20:43:39 <jollytime> thanks
20:43:50 <M30W> S11001001: I mean.. How for the type ?
20:44:29 <jollytime> I love haskell, I want to quit my job just to learn this stuff
20:44:30 <geekosaur> maki`, what platform?  ghc version?
20:44:39 <maki`> it is probably related to my use of FFI.
20:45:01 <maki`> geekosaur windows, 7.4.1
20:45:24 * hackagebot postmark 0.0.1 - Library for postmarkapp.com HTTP Api  http://hackage.haskell.org/package/postmark-0.0.1 (MarkHibberd)
20:45:26 <geekosaur> my any chance is the module compiled as a dll?
20:45:32 <maki`> I am using a couple of windows api functions
20:45:55 <maki`> geekosaur no, it has main. running main in ghci gives me that error. compiling with ghc and runnin the program works fine
20:46:38 <monochrom> maki`, do you have complete instructions for a third party to reproduce your problem?
20:47:42 <maki`> monochrom I will make it, I'll reduce the code to minimum first since it's a relatively large project
20:47:45 <covi> Can  x:_  match both 1 in [1] and [1, 2]?
20:48:26 <S11001001> M30W: Either distributes.  If you have data ctor X a (Either b c), and you want to encode the Either without Either, you have to split X like this: X a b | X' a c
20:48:32 <monochrom> you will likely appreciate that when your users send you sketchy bug reports, it will be your turn to ask them the same question
20:49:38 <S11001001> M30W I would suggest decomposing success and failure cases at type level, so you have a guarantee that funs only knowing how to handle success will only ever be given success.
20:49:50 <shachaf> Isn't it the multiplication that's being distributed here?
20:50:33 <S11001001> shachaf: ah, yeah
20:50:46 <S11001001> M30W: what shachaf said.
20:51:05 <silasm> maki`: I've had the opposite error before. It let me run main for a program that was supposed to take command line arguments and worked somehow. Main has weird behavior in ghci in my (limited) experience. You should probably just runhaskell or compile and run when you want to test it imo.
20:51:51 <geekosaur> silasm, normally you run main in ghci with:  :main [arguments go here]
20:52:06 <geekosaur> (note colon; this is a command to ghci itself, not invoking the function)
20:52:40 <silasm> geekosaur: I see, thanks. I'll do that from now on.
20:53:09 <edwardk> covi: yes
20:53:15 <monochrom> it is documented in the GHC user's guide
20:53:34 <edwardk> covi: [1] = 1:[]    so x:_  matches it
20:53:46 <geekosaur> and in :help
20:56:24 <SamanthaD> getDisks = filter (not issda) . filter (isDisk)        is giving me a type error complaining that it couldn't match expected type String -> Bool to actual type Bool in the return type of not. issda is type String -> Bool
20:56:54 <SamanthaD> oh... I get it...
20:56:59 <M30W> S11001001: Using them seperate for handeling succ/err only functions was as intended.
20:57:03 <monochrom> change "not issda" to "not . issda"
20:57:11 <SamanthaD> monochrom: Thank you!
20:57:27 <M30W> S11001001: I still don't understand what you mean however ?
20:58:16 <M30W> S11001001: http://ix.io/48Y
20:58:20 <M30W> That's what I have so far..
20:58:51 <arbn> Oh. I see. Using the (..) does not export the field accessors. :(
20:58:58 <arbn> I have to list them all manually?
20:59:06 <shachaf> It should.
20:59:22 <S11001001> M30W: reason for not just using Either?
20:59:39 <monochrom> module M(D(..)) where data D = D {field :: Int}  does export field
20:59:45 <M30W> S11001001: I am not 100% sure on how either works? Either = Left | Right ?
21:00:04 <S11001001> @src Either
21:00:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:00:10 <S11001001> what
21:00:29 <S11001001> @hoogle Either
21:00:29 <lambdabot> Prelude data Either a b
21:00:29 <lambdabot> Data.Either data Either a b
21:00:30 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
21:00:56 <monochrom> too bad ghci does not accept "module M ..." :)
21:01:03 <arbn> monochrom: That's not working for me. Could it be because I'm using a Persistent QQer to generate the ADT definition?
21:01:20 <monochrom> I don't know
21:01:21 <S11001001> M30W: note the type args and the function of the same name used for extraction
21:01:42 <monochrom> sounds like fun. I should try it
21:03:21 <M30W> S11001001: So.. data Response a b = Reply Reply a | Error Error b | Response { ... response :: Response ... } ?
21:05:14 <S11001001> M30W: let's take this quote from your comment: " need some either-like type setting between Reply and Error here"
21:06:00 <S11001001> M30W: the "either-like type" you should use here *is* Either.  Just the Either that's already been defined.
21:06:42 <M30W> S11001001: Okay so Either it is.. Now how would I go about having the Either inside this ?
21:07:09 <S11001001> M30W: How do you put a String in your data ctors?
21:07:29 <M30W> S11001001: data ctors ?
21:08:15 <S11001001> M30W: the things separated by |
21:08:24 <M30W> Oh
21:08:33 <maki`> I managed to get ghc to replicate the linking error. problem was the wrapper over C function, defined as foreign import stdcall "wrapper" ...
21:08:40 <maki`> anyone knows how to fix this linking error?
21:09:21 <monochrom> GHC creates a something.o file for that. ghci ...other stuff... something.o
21:09:27 <M30W> S11001001: data A = A { something :: String }
21:10:26 <M30W> S11001001: oh data A x = .. idk. :|
21:10:54 <S11001001> M30W: so you say the type, yeah? How about putting in a function with an Int argument and Int result type?
21:11:12 <M30W> :: Int -> Int
21:11:42 <S11001001> M30W: So you write the type.
21:12:23 * M30W is still confused on how to get this...
21:13:38 <S11001001> M30W: So next, what is it you need to write the type of?  because that's it, there's no adding of type arguments to your own types, or any such thing
21:14:08 <M30W> Reply :: Reply -> Response
21:14:32 <S11001001> M30W: You said "an either-like type"
21:15:10 <M30W> Well Either (Reply -> Response) (Error -> Response) isn't valid so here I am confused.
21:15:45 <S11001001> M30W: why are there functions here?
21:16:01 <M30W> Huh?
21:16:10 <M30W> Oh boy
21:16:17 <M30W> either Reply Error
21:17:36 <S11001001> one beauty of Either is in how obvious it is to read. "either a reply or an error".
21:17:55 <M30W> Hmmm
21:17:56 <shachaf> data a + b = Left a | Right b
21:18:20 <S11001001> whatever shachaf :]
21:18:46 <geekosaur> data Either a b = One a | TheOther b -- :p
21:19:01 <shachaf> data These a b = This a | That b | These a b
21:20:41 <M30W> Hmm
21:21:03 <M30W> let a = BS.empty
21:21:11 <M30W> :t Response a Motd a a
21:21:13 <lambdabot> Not in scope: data constructor `Response'
21:21:13 <lambdabot> Not in scope: data constructor `Motd'
21:21:25 <M30W> Whoops forgot about you lambdabot
21:21:37 <M30W> Couldn't match expected type `Either Reply Error -> Response eith actural type `Reply'
21:23:16 <M30W> S11001001: :|
21:26:55 <maki`> putting .hsc file's module into Exposed-modules in cabal make the linking error go away. but isn't there another way? there's no reason for this module to be exposed
21:28:11 <S11001001> M30W: this makes sense for the same reason that it makes sense that an Int is not also a list of Ints.  A Reply is not an Either Reply Error.
21:28:37 <monochrom> maki`: perhaps Other-modules
21:28:57 <M30W> Hmm
21:29:33 <M30W> S11001001: How would I do this then?
21:30:25 <S11001001> M30W: you really need to take a look at the Prelude haddock and familiarize yourself with the standard functions and data constructors for Either at this point.
21:30:52 <M30W> S11001001: I've been looking at it a bit
21:31:28 <maki`>  thanks.. I need to go through cabal manual again
21:31:54 <masonm> I have heard that !! should be avoided. why is that?
21:32:17 <M30W> masonm: It goes through the entire list til it reaches it's index
21:32:35 <M30W> log(n)
21:33:59 <masonm> just that reason?
21:34:05 <M30W> For what I know
21:35:03 <mikeplus64> masonm: also if an index < 0 or > the number of elements in the list, an exception is raised
21:35:25 <mikeplus64> (some argue it should instead return Maybe a)
21:35:59 <M30W> Ouch.. That would kill a lot of things XD
21:36:37 <feliperosa> Hello guys, night
21:36:58 <M30W> feliperosa: Evening
21:37:04 <feliperosa> :)
21:37:38 <geekosaur> masonm, the main argument is that if you want random access to your list, then you probably want something better suited to it than a list, like a Vector.  singly linked lists are nice for stepping through and lousy for random access
21:38:16 <masonm> geekosaur: sure, but it is often more than fast enough, so who cares
21:38:34 <M30W> Large lists of data
21:38:36 <M30W> Becomes slow
21:39:45 <feliperosa> guys, is it 'wrong' to use the State Monad too much?
21:40:03 <feliperosa> wrong in the sense that it's a bad design thing
21:40:41 <johnw> stateful code in general is harder to reason about, because the behavior of a function no longer depends solely on its arguments
21:41:02 <johnw> with State, you have it depending as well on its context of usage
21:41:26 <johnw> i wouldn't call it "bad", but I'd confine it to where you really need it
21:42:04 <M30W> S11001001: let r = Response e Motd e e where e = BS.empty  -- I still don't see how to get this.. :|
21:43:45 <johnw> M30W: that code is missing an "in" clause, isn't it?
21:44:09 <SamanthaD> feliperosa: On the other hand, sometimes implementing a bit of code in a stateful manner is more terse and therefore easier to hold in your head.
21:44:40 <feliperosa> Well, I trying to put in practice what I've studied. See, I come from an imperative background, mostly OO. But I really like the mathematical vision of things of functional programming.
21:44:56 <feliperosa> I'm trying to get a good design of a game, Pong if you may ask.
21:45:27 <feliperosa> But I'm finding myself thinking in terms of State too often.
21:45:52 <SamanthaD> feliperosa: I'm in a similar situation. I try to avoid state as much as possible even when it makes sense to use state because I'm trying to strengthen my functional programming muscles, as it were.
21:45:58 <S11001001> M30W: Let's say I have a Reply.
21:46:04 <monochrom> arbn: works for me. http://www.vex.net/~trebla/tmp/QQ/
21:46:14 <S11001001> M30W: Is the Reply also a Response?
21:46:39 <johnw> feliperosa: I think even edwardk's Pong example that showcases lens uses State
21:46:48 <M30W> S11001001: Yes
21:47:10 <SamanthaD> feliperosa: Also bear in mind that there's, as I understand it, a pretty heavy performance penalty for using state.
21:47:19 <M30W> johnw: No. let a = something adds it to the environment.
21:47:30 <feliperosa> johnw: Yeah, It does
21:47:36 <S11001001> M30W: So I have the value Welcome.
21:47:39 <feliperosa> SamanthaD: Why is that?
21:47:56 <S11001001> M30W. Can I pass it to a function that accepts a Response?
21:48:07 <SamanthaD> feliperosa: Because when you add state you take away the compiler's ability to perform certain very high-level optimizations to the code.
21:48:11 <johnw> M30W: are you in a Monad?  If so, then example you excerpted up above needed some semicolons.  Since you wrote it on one-line, I gathered it was an expression.
21:48:14 <monochrom> let {r = x+1  where {x = 2+3}} ...  the where belongs to the r=
21:48:43 <johnw> monochrom: that's very cool, I'd never encountered that syntax before
21:48:51 <M30W> S11001001: No hence the Either
21:49:02 <monochrom> "where" can be attached to any "="
21:49:05 <johnw> Haskell syntax: the gift that keeps on giving :)
21:49:12 <monochrom> embrace uniformity!
21:49:15 <SamanthaD> feliperosa: The compiler's really high-level optimizations rely on functions being referentially transparent. When you take that away by introducing state...
21:49:37 <monochrom> only a stupid language would say "'where' is only good for global"
21:49:42 <feliperosa> SamanthaD: Oh, right. But is that true even for a 'function' representation of state? I thought the State Monad was pure in that sense
21:49:55 <monochrom> but of course, stupid languages are a dime a dozen out there
21:50:04 <S11001001> M30W: Ignore the Either. You have data Response, and data Reply. In what way is a Reply also a Response?
21:50:07 <M30W> johnw: \e a -> Response e a e e BS.empty Welcome -- :)
21:50:12 <feliperosa> SamanthaD: Like when you want to generate random numbers. It would be better to go with State than IO.
21:50:19 <johnw> M30W: :)
21:51:00 <SamanthaD> feliperosa: I'm not entirely sure. Maybe one of the other people here can answer that. I do know that GHC isn't nearly as good with stateful data as, say, lists.
21:51:11 <M30W> S11001001: Reply -> Response
21:51:22 <monochrom> "where" can also be attached to "->" in case-of: case blah of { Nothing -> x where {x=1}; Just n -> x where {x=n+1} }
21:51:32 <S11001001> M30W: What is that?
21:51:43 <M30W> S11001001: A Response
21:52:19 <M30W> S11001001: I understand the error; I just don't understand how to work around/with it.
21:52:28 <S11001001> M30W: No, it's the type of functions taking Reply to Response.  It's also not a Respose.
21:52:34 <monochrom> > case 5 of { x -> y where {y=x+1} }
21:52:36 <lambdabot>   6
21:52:36 <S11001001> response
21:52:53 <M30W> It is a Reply -> Response so.. Reply?
21:53:12 <johnw> monochrom: whoa
21:53:26 <lispy> hello
21:53:29 <S11001001> M30W: Reply -> Response is not a Reply, and also is not a Response.
21:53:30 <johnw> lispy: hi!!
21:53:52 <M30W> S11001001: Err. Reply -> Response is just Reply -> Response
21:55:06 <geekosaur> M30W:  is (+) an Int?
21:55:14 <feliperosa> SamanthaD: Yeah, that's something I've been thinking about. When you say 'stateful', the State Monad isn't really 'stateful' is it? It's pure in the sense that it does no IO operations. So I thought that representing stateful computations that way referential transparency would be kept
21:55:45 <M30W> geekosaur: no
21:55:59 <M30W> Integer -> Integer
21:56:07 <lispy> feliperosa: the state monad adds a context to your computations. That context carries around a value. In the state monad case, that value is the 'state' of what you're computing
21:56:16 <M30W> Integer -> Integer -> Integer or something
21:56:19 <geekosaur> so, is it an Integer?
21:56:23 <M30W> Wait no.. Num a => a -> a -> a
21:56:35 <lispy> feliperosa: in a language like C you also have access to a context for your computations
21:57:05 <geekosaur> now, think about why I asked you that, and what it looks liek compared to the thing that you are apparently trying to figure out whether it is a Request or a Reply
21:57:06 <M30W> geekosaur: I understand that it's different, but I don't understand how to work with it..
21:57:16 <SamanthaD> lispy: the question has to do with whether or not state adds a performance penalty.
21:57:16 <geekosaur> er
21:57:20 <geekosaur> Reply or Response
21:57:31 <geekosaur> it's a function.  if you feed it a Reply, it produces a Response
21:57:38 <geekosaur> by itself it is neither
21:57:41 <feliperosa> lispy: Yeah, ok. So my doubt is: Lifting some value to the State Monad is like having what you have in C, for example?
21:57:52 <feliperosa> lispy: At the moment I would say no.
21:58:17 <lispy> feliperosa: right, State is about carrying just one more value around. C is that plus more. It's the C context.
21:58:19 <SamanthaD> lispy: I mentioned that using state tends to have a performance hit in that GHC et al aren't really optimized to handle stateful data structures.
21:58:30 <M30W> geekosaur: I still don't see how to apply the Reply to  :: Either Reply Error -> Response
21:58:40 <cmccann> it's like what you have in C, if the only side effects available in C were reading and writing a single global variable :P
21:59:24 <S11001001> M30W: You have a Reply.  You need an Either Reply Error.  What's the type of the function you need?
21:59:33 <geekosaur> hm, you've been shown the pieces, I think.  what does a value of type (Either Reply Error) look like?
21:59:43 <M30W> : Either Reply Error -> Response
21:59:46 <M30W> :: *
21:59:59 <feliperosa> But to be exactly the same of what you have in C. I guess you would have to do stateful computations using IORef or something, no?
22:00:03 <S11001001> No, I didn't mention Response at all just now.
22:00:27 <M30W> Eh, without -> Response
22:00:43 <S11001001> Either Reply Error is not a function
22:00:56 <geekosaur> M30W: S11001001 meant "what is the type of the thing you need in order to turn a Reply to an Either Reply Error
22:00:57 <M30W> either
22:01:16 <M30W> either Reply Error :: Either Reply Error -> Response
22:01:33 <feliperosa> because in the end, the state monad is referally transparent. Since it does not keep state, it's just a state processor. So passing the same argument as initial state to some State processor will give you the same results.
22:02:00 <feliperosa> Am I wrong thinking like that?
22:02:35 <S11001001> M30W: geekosaur didn't mention Response either. Response doesn't appear at all in the type I'm asking for.
22:03:08 <M30W> S11001001: You have lost me..
22:03:24 <geekosaur> [27 01:00] <geekosaur> M30W: S11001001 meant "what is the type of the thing you need in order to turn a Reply to an Either Reply Error"
22:03:43 <geekosaur> exactly this; you are not, at this time, thinking abotut he next step at all.  one step at a time
22:04:04 <M30W> just Response
22:06:55 <jmcarthur> a free monoid can be generated from some type by applying the list constructor to it. a free monad can be generated from some functor by applying data Free f a = Return a | Roll (f (Free f a)) to it. one could do the same for non-functors with data Free f a = Return a | forall b. Roll (f b) (b -> Free f a). i find it interesting that lists require nothing of the type [] is applied to, but Free requires that
22:06:58 <jmcarthur> f be a functor even though there is the possibility to design it such that it's not even necessary that the type constructor be a functor. does anybody have some insight about this? most likely i'm just imposing some incorrect associations with what it means to be a free object, but it seems weird to require any particular interface for the type or type constructor you are transforming when generating a free
22:06:59 <jmcarthur> object.
22:07:07 <jmcarthur> holy three-line message batman :\
22:08:39 <M30W> S11001001: ?
22:09:09 <M30W> geekosaur: Oh.. a function
22:09:34 <S11001001> M30W: what is the function's type?
22:09:48 <M30W> Either Reply Error -> Response
22:09:57 <S11001001> No, try again.
22:10:20 <geekosaur> M30W, you keep jumping ahead to the next step
22:10:21 <M30W> Reply -> Either Reply Error
22:10:32 <S11001001> Good.
22:10:40 <M30W> geekosaur: Indeed :|
22:10:43 <geekosaur> in many ways, the essence of functional programming is to do small steps and then compose them to get the final answer
22:10:48 <geekosaur> so focus on the small steps initially
22:12:26 <S11001001> M30W: Now *that* function is already written for you; it's in the Prelude.  Obviously it doesn't mention Reply or Error, so look for something that fits the pattern.
22:12:40 <M30W> S11001001: Was already looking :)
22:15:43 <bh> Does anyone have time-http installed? I can't seem to get it to install https://gist.github.com/4646843
22:15:54 <hpaste> adnap pasted “ffi c++” at http://hpaste.org/81351
22:16:06 <M30W> S11001001: In the prelude you say?
22:16:16 <S11001001> M30W: Yes.
22:16:22 <sgronblo> Trying to figure out why I am getting a no instance for ... arising from literal error on an expression that seems fine in ghci when called with a literal...
22:16:32 <adnap> Can I get help with the paste?
22:16:33 <M30W> I am looking through :bro can't find it..
22:17:15 <S11001001> M30W: Ask for the type of different things related to Either.
22:17:33 <sgronblo> So no instance for (Num [a0]) means that the Num class doesn't have a function to return a list?
22:17:53 <geekosaur> adnap, you need to link against C++'s runtime library
22:18:04 <adnap> geekosaur: Oh!
22:18:07 <M30W> S11001001: huh?
22:18:11 <geekosaur> sgronblo, no, it means that ghs doesn;t know how to make a number act like a list
22:19:24 <sgronblo> geekosaur: Thanks, but I don't understand why it's trying to make my literal number act like a list
22:19:35 <bh> or barring time-http working, can anyone recommend another parser for RFC 822 dates?
22:19:44 <geekosaur> sgronblo, what does your code look like?
22:19:45 <geekosaur> @paste
22:19:45 <lambdabot> Haskell pastebin: http://hpaste.org/
22:20:23 <sgronblo> scores = snd (List.mapAccumL (\points chars -> (points - 1, (head chars, points))) 26 (group $ sort s))
22:20:28 <adnap> geekosaur: You said that earlier and I forgot >_<
22:20:38 <sgronblo> The complaint is about the literal 26
22:21:30 <S11001001> M30W: Look more closely.   If your current search strategy isn't turning up anything, try something else.  Your prelude isn't different from mine; the function is there.
22:21:36 <M30W> S11001001: Left
22:22:21 <shachaf> S11001001: I suspect M30W hasn't unlocked the expert prelude yet.
22:22:31 <shachaf> Just a few more achievement points.
22:22:47 <M30W> Left's type is a -> Either a b
22:22:54 <geekosaur> :t mapAccumL
22:22:56 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:23:01 <S11001001> shachaf: nah that defines left as a biased lens on bicomonads
22:23:18 <edwardk> ?
22:23:31 <shachaf> edwardk: Do you have a hilight on "bicomonads"?
22:23:43 <S11001001> hahaha I triggered edwardk
22:24:01 <S11001001> oh lens
22:24:14 <shachaf> I thought he got rid of the lens hilight.
22:24:14 <edwardk> wut, i figure i set up lots of highlights for interesting topics and some of them pop up when i'm around ;)
22:24:15 <M30W> S11001001: http://www.haskell.org/hoogle/?q=a%20-%3E%20Either%20a%20b
22:24:21 <geekosaur> sgronblo, take a look at the above, compare to what you wrote.  (note that ghci will accept that definition happily and throw the error when you try to use it)
22:24:23 <M30W> I am out of methods to search :|
22:24:42 <S11001001> M30W: You've got it; Left is the answer.
22:24:44 <shachaf> M30W: The first result there has type a -> Either a b
22:24:47 <sgronblo> geekosaur: but if i take out the scores = and just stick a string into the place of the s it works fine
22:24:58 <M30W> Oh so I was.. So what now O.o
22:25:08 <M30W> Couldn't match expected type `Either Reply Error -> Response' with actual type `Either Reply b0'
22:25:13 <S11001001> M30W: Use it to fix your type error.
22:25:29 <geekosaur> M30W, small steps.  you have the first step, now you're on to the second...
22:26:08 <M30W> S11001001: I tried and got another type error
22:27:55 <geekosaur> so what do you have now and what error is it producing?
22:28:11 <M30W> 17:24         M30W | Couldn't match expected type `Either Reply Error -> Response' with actual type  `Either Reply b0'
22:28:18 <M30W> (\ e a -> Response e a e e) BS.empty (Left Welcome)
22:28:36 <S11001001> M30W: rest of source?
22:29:05 <M30W> S11001001: Same as I sent you before? Except resposne :: Either Reply Error -> Response
22:29:08 <M30W> ah
22:29:26 <M30W> Hollu crap
22:29:37 <jollytime> page 77 of LYAH : The function \acc x -> x : acc is just like the : function, except that
22:29:37 <jollytime> the parameters are flipped.
22:29:37 <jollytime>                  huh? it IS the (:) function just it's inside a lambda, what are they implying?
22:29:52 <shachaf> jollytime: The (:) is (:)
22:29:56 <hpaste> basdirks pasted “Which is more idiomatic?” at http://hpaste.org/81352
22:30:00 <shachaf> But the whole lambda is also like (:), except flipped.
22:30:03 <basdirks> ^^
22:30:05 <M30W> I put -> Response in my Response { ... response :: Either Reply Error -> Response ... } -- :|
22:30:07 <shachaf> (\acc x -> x : acc) = flip (:)
22:30:12 <geekosaur> jollytime, (\... -> ...) is an anonymous function (a lambda)
22:30:24 * geekosaur slow, apparently
22:30:29 <M30W> Thanks S11001001
22:30:29 <shachaf> basdirks: null is the devil.
22:30:32 <S11001001> M30W: is why I always ask for source :)
22:30:39 <M30W> xD
22:30:48 <basdirks> is it? it does look ugly
22:30:48 <jollytime> and how are the parameters flipped in that lambda? :S
22:30:53 <shachaf> basdirks: If you don't like the repetition, you can pattern-match inside the function body.
22:31:13 <shachaf> basdirks: The issue with null is that it's really easy to get wrong.
22:31:23 <donri> jollytime: because it's not \x acc -> x : acc
22:31:23 <geekosaur> jollytime, by hand.  input is acc x, output is x : acc
22:31:26 <shachaf> @where boolean-blindness
22:31:26 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
22:31:27 <M30W> S11001001: http://ix.io/491 :D
22:31:31 <sgronblo> i am defeated by this literal in mapAccumL
22:31:49 <basdirks> thanks shachaf
22:31:51 <M30W> Now for parsing the raw irc messages and dividing it how I want. Or..
22:32:01 <donri> jollytime: and not \acc x -> acc : x (same thing)
22:32:07 <geekosaur> sgronblo, I have no idea how you got it to work in ghci, but if you look at the type of mapAccumL it expects a list where you have 26
22:32:16 <jollytime> aha, thanks guys :)
22:32:20 <S11001001> have fun with that, 'night all
22:32:26 <geekosaur> at this point I can only assume you have a .ghci that brings into scope a Num instance for lists
22:32:27 <donri> jollytime: (:) is a function, so is a lambda
22:33:04 <basdirks> shachaf: I hate the pattern if p x then "" else f x
22:33:12 <M30W> S11001001: could I use an instance or class to  "371" :: String -> Reply ?
22:33:20 <M30W> Ah he gone D:
22:33:21 <geekosaur> sgronblo, in fact, I am lost as to why you expect a number to work there
22:33:26 <geekosaur> :t mapAccumL
22:33:27 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
22:33:43 <shachaf> basdirks: Well, you could abstract that into a function if you liked.
22:33:47 <sgronblo> Three arguments? A mapper, an accumulator and the list?
22:33:53 <sgronblo> And 26 is my accumulator
22:34:08 <geekosaur> hm, sorry, I'm misreading, yeh
22:34:12 <shachaf> Or maybe you could do something with comprehensions.
22:34:13 <geekosaur> getting late here
22:34:15 <shachaf> > (\x -> [x | all isUpper x]) "hello"
22:34:16 <lambdabot>   []
22:34:17 <shachaf> > (\x -> [x | all isUpper x]) "HELLO"
22:34:19 <lambdabot>   ["HELLO"]
22:34:25 * M30W swapped the error and reply around so Right is succ and Left is err. :)
22:34:44 <sgronblo> I tried breaking up the expression into more sub parts but somehow that stupid 26 is still messing things up
22:34:55 <geekosaur> . . .
22:35:01 <geekosaur> I think I just got irt
22:35:13 <geekosaur> you do have a .ghci file.  it turns off the monomorphism restriction
22:35:26 <sgronblo> snd (List.mapAccumL (\points chars -> (points - 1, (head chars, points))) 26 (group $ sort "abcsa"))
22:35:35 <sgronblo> > snd (List.mapAccumL (\points chars -> (points - 1, (head chars, points))) 26 (group $ sort "abcsa"))
22:35:37 <lambdabot>   Not in scope: `List.mapAccumL'
22:35:37 <lambdabot>  Perhaps you meant one of these:
22:35:37 <lambdabot>    `BSC.map...
22:35:49 <geekosaur> you're also using obsolete Haskell98 flat imports
22:35:58 <geekosaur> it's Data.List in modern Haskell
22:36:25 <sgronblo> Oh, well I only do Haskell now and then in my spare time unfortunately
22:36:32 <basdirks> shachaf: that is a nice pattern in some cases, but I'm not sure if it works well here
22:37:31 <geekosaur> so, you can use that expression as an expression and it does the right thing.  but if you say "second = ...", because you have declared "second" to not take any parameters, the monomorphism restriction comes into play and overly restricts its type
22:37:37 <geekosaur> @where DMR
22:37:37 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
22:37:58 <sgronblo> > snd (Data.List.mapAccumL (\points chars -> (points - 1, (head chars, points))) 26 (group $ sort "abcsa"))
22:37:59 <lambdabot>   [('a',26),('b',25),('c',24),('s',23)]
22:38:05 <geekosaur> and it works in ghci because you have ghci set up to ":set -XNoMonomorphismRestriction"
22:39:02 <sgronblo> Whee never heard of monomorphism restriction before
22:39:24 <geekosaur> so you can use {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your source file, or ask ghci the type of "second" and include the resulr in your source file
22:39:34 <geekosaur> [27 01:37] <geekosaur> @where DMR
22:39:34 <geekosaur> [27 01:37] <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
22:39:51 <geekosaur> (the "D" stands for "dread", and this is a good example of why...)
22:40:00 <geekosaur> well, dreaded
22:40:26 * hackagebot kevin 0.5 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.5 (JoelTaylor)
22:40:28 * hackagebot kevin 0.6 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.6 (JoelTaylor)
22:43:40 <sgronblo> If the cases where this restriction is useful is so rare, wouldn't it have made more sense to make users who really want to be on the safe to explicitly turn it on, instead of the other way round?
22:44:04 * geekosaur thinks it's past time for bed, actually
22:44:12 <geekosaur> sgronblo, there are ongoing arguments about it
22:45:01 <basdirks> shachaf: Hlint like null
22:45:30 * hackagebot machines 0.2.3.1 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.2.3.1 (EdwardKmett)
22:45:31 <sgronblo> I think I'm just gonna turn that crap off for now though
22:45:32 * hackagebot bifunctors 3.2 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.2 (EdwardKmett)
22:46:27 <basdirks> likes*
22:47:00 * M30W now has a much better understanding on Left Right Either :D
22:47:08 <edwardk> Hlint has lots of odd opinions
22:47:35 <basdirks> is there a sane config for it?
22:49:19 <edwardk> i tend to just disable warnings as they pop up and make annoying incorrect suggestions
22:49:30 <edwardk> about 1 in 10 is something i actually act on
22:49:46 <edwardk> the others are usually asking me to do the impossible, like eta reduce something higher rank, etc.
22:52:13 <hpaste> SamanthaD pasted “Clever little type error” at http://hpaste.org/81353
22:53:04 <SamanthaD> I don't understand why it's broken...
22:54:32 <SamanthaD> Is this something I ought to be using a typeclass instance to do?
22:54:40 <shachaf> SamanthaD: Because the second argument isn't a list.
22:54:53 <shachaf> You're pattern matching on it as if it's a list.
22:55:22 <SamanthaD> shachaf: Yeah... I was hoping that maybe it would be smart about it. Ah well, you can't duck type in Haskell I guess...
22:56:08 <shachaf> SamanthaD: Smart?
22:56:12 <shachaf> I'm not sure what you expect it to do.
22:57:43 <SamanthaD> shachaf: I expected it to recurse through y:ys and then, for each y, recurse through x:xs
22:58:09 <SamanthaD> shachaf: I wanted it to match to the first part if you tried to give it a list of y and to the second part if you just gave it a y
22:58:44 <Maxdamantus> What's so bad about infinite types anyway?
22:58:49 <shachaf> Sounds complicated.
22:59:04 <shachaf> Maxdamantus: They make a lot of things type-check.
22:59:21 <arbn> So, I'm getting the error "Unacceptable result type in foreign declaration: IO [CBook]", but CBook is an instance of Storable. What could be the issue?
23:00:19 <kennyd> SamanthaD second argument is either a list or not, it can't be both
23:00:25 <SamanthaD> shachaf: The embarrassing part is that once I figured out the problem I couldn't remember why I wrote the code in the first place!
23:00:49 <Maxdamantus> What things wouldn't type-check with infinite types?
23:01:01 <SamanthaD> kennyd: Mmhm... I see it now. Thank you.
23:02:56 <SamanthaD> kennyd: I got confused because a list is an instance of Eq. But then I figured out that because xs is an instance of Eq, too... the type signature can't fit both.
23:03:28 <SamanthaD> kennyd: Or... I should say a list CAN BE an instance of Eq.
23:03:40 <masonm> comprehension lists combine every element with every element. is there a way to do a single iteration?
23:05:23 <arbn> Oooh. I forgot the marshal the list to an array pointer, I guess.
23:05:35 <Maxdamantus> type List a = Maybe (a, List a)
23:05:44 <masonm> [(x,y) | x <- [1,2,3], y<- [5,5,5]]. I want to get [(1,5), (2,5), (3,5)] instead of all combinations
23:05:52 <shachaf> You want zip.
23:05:56 <shachaf> > zip [1,2,3] [5,5,5]
23:05:57 <lambdabot>   [(1,5),(2,5),(3,5)]
23:06:04 <shachaf> List comprehensions aren't the answer to everything!
23:06:22 <shachaf> (There's a GHC extension for this too, but you should just use zip instead.)
23:06:22 * arbn never uses list comprehensions.
23:06:36 <johnw> i keep forgetting to use list comprehensions
23:06:50 <SamanthaD> shachaf: Bah! I've driven screws with hammers before!
23:07:18 <shachaf> johnw: They're overrated.
23:07:43 <masonm> they are nice when they suit the problem
23:07:50 <johnw> i bet you luuuuuv monad comprehensions :)
23:08:09 <arbn> They're often not even a better syntax than just using >>= with the list.
23:09:33 <johnw> > getZipList $ (,) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
23:09:35 <lambdabot>   [(1,4),(2,5),(3,6)]
23:09:43 <Nereid> > [(x,y) | x <- [1,2,3] | y<- [5,5,5] ]
23:09:45 <lambdabot>   [(1,5),(2,5),(3,5)]
23:09:56 <masonm> huh what
23:10:10 <johnw> that's a nested list comprehension?
23:10:14 <Nereid> no
23:10:21 <Nereid> it's an ordinary list comprehension
23:10:24 <johnw> huh
23:10:30 <johnw> i've learned two bits of haskell syntax today, thanks
23:10:33 <Nereid> lol
23:10:37 <Nereid> what was the other?
23:10:50 <johnw> "where" applies to any "=" or "case ->"
23:10:56 <lewis1711> so this question has been keeping me up at night - why is there no "sequence" typeclass so that immutable vectors could be used with "list" operations like map, fold etc?
23:10:56 <Nereid> ah
23:10:56 <masonm> nice, wish it was standard
23:11:11 <masonm> I will use it anyway :)
23:11:22 <johnw> lewis1711: Foldable, and Traversable
23:11:28 <Nereid> lewis1711: there is a ListLike something or rather.
23:11:41 <Nereid> but for map/fold you have typeclasses like
23:11:43 <Nereid> Functor and Foldable
23:11:49 <M30W> johnw: Or function
23:11:59 <M30W> ah = sorr
23:12:01 <M30W> sorry *
23:12:09 <Nereid> and Traversable
23:12:22 <lewis1711> lambdabot, :t map
23:12:30 <Nereid> :t map
23:12:32 <lambdabot> (a -> b) -> [a] -> [b]
23:12:33 <Nereid> :t fmap
23:12:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:12:50 <masonm> yeah fmap is a generic map
23:12:52 <Nereid> :t foldr
23:12:54 <lambdabot> (a -> b -> b) -> b -> [a] -> b
23:12:56 <Nereid> :t Data.Foldable.foldr
23:12:57 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
23:13:02 <lewis1711> interesting!
23:13:08 <Nereid> (note: you shouldn't use Foldable's foldr usually.)
23:13:10 <lewis1711> given that though, what is the point of having "map" at all?
23:13:18 <lewis1711> why not just have fmap?
23:13:37 <lewis1711> then one could map over sets, etc
23:13:37 <Nereid> sometimes it's ok to have a more restrictive type, I guess. also probably historical reasons.
23:14:16 <Nereid> :t foldMap
23:14:17 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
23:14:19 <johnw> I imagine that for a newcomer, a type error involving map would make a bit more sense than one involving fmap
23:14:20 <arbn> Uh oh. This isn't good, I think my module is causing GHC to leak memory.
23:14:34 <lewis1711> since when has haskell been optimised for newcomers? :)
23:14:47 <Nereid> :t (mconcat .) . map
23:14:48 <lambdabot> Monoid b => (a -> b) -> [a] -> b
23:15:07 <johnw> lewis1711: lol
23:15:16 <johnw> lewis1711: We don't actively deoptimize, honest
23:15:19 <Nereid> :t fold
23:15:21 <lambdabot> (Foldable t, Monoid m) => t m -> m
23:15:22 <Nereid> :t mconcat
23:15:24 <lambdabot> Monoid a => [a] -> a
23:16:09 <Nereid> also in some cases, things with more specialized types can be optimized better. I think.
23:16:28 <lewis1711> really? I thought type-classes made that a null issue
23:16:35 <jmcarthur> lewis1711: haskell is surprisingly optimized for newcomers. there are all kinds of things that i would change if i had the power which are only so for the sake of newcomers
23:16:36 <shachaf> hi Twey
23:16:37 <lewis1711> since you're not deciding at run time..are you
23:16:57 <jmcarthur> lewis1711: type classes may be runtime, may be compile time
23:17:11 <lewis1711> really? so some of them do have a sort of dynamic dispatch? hmm
23:17:18 <Nereid> no
23:17:21 <jmcarthur> lewis1711: in ghc they are implemented with actual dictionary passing, although they may be inlined most of the time
23:17:43 <Nereid> but you can't optimize as well if you don't know what dictionary you're getting.
23:18:04 <Nereid> you = the compiler
23:18:04 <jmcarthur> inlining is a very important part of ghc's optimizer
23:18:57 <jmcarthur> one case where dynamic dispatch *must* happen is when you have an existential type with a type class constraint on it
23:19:28 <lewis1711> well I clearly don't understand typeclasses as well as I thought :)
23:19:34 <jmcarthur> data Foo = forall a. (Show a, Num a) => Foo a a   -- for example
23:20:11 <jmcarthur> since the actual type of a can't in general be known at compile time, that will usually involve an explicit dictionary at runtime
23:20:42 <jmcarthur> lewis1711: all this is just implementation details though. when it comes to using type classes you usually shouldn't concern yourself with this
23:21:21 <lewis1711> jmcarthur, fair point but implementation details are on the mind right now
23:21:24 * M30W wonders why irc sends back only part messages in quotes O.o
23:22:30 <Nereid> M30W: server quirk, then.
23:22:50 <jmcarthur> lewis1711: in that case, a decent intuition for how dictionary passing works is to just mentally replace (=>) with (->) in type signatures
23:23:02 <M30W> Nereid: It's strange to see but freenode/silverirc both do it but I haven't seen anything for that in the rfc.
23:23:14 <jmcarthur> lewis1711: so you would interpret  Eq a  as a record of functions, parameterized on type a
23:23:15 <Nereid> many other servers don't do it
23:23:24 <jmcarthur> lewis1711: and it's just an argument along with everything else
23:23:26 <M30W> Oh lie
23:23:33 <M30W> wait no
23:23:35 <M30W> Hmm
23:23:39 <Nereid> data Eq a = Eq { (==) :: a -> a -> Bool, ... }
23:23:45 <M30W> Strange
23:24:07 <jmcarthur> lewis1711: and it just so happens that, just like with any other value, ghc might inline it (and is very likely to if it's simple enough, which type class disctionaries often are)
23:25:08 <arbn> Hmmm. Has anyone else had GHC hang and leak memory? Very odd.
23:25:35 <M30W> arbn: code to cause?
23:26:40 <arbn> M30W: OK. But... it's very ugly, since I'm writing quickly. :P Just a second.
23:26:48 <M30W> Hehe
23:27:09 <arbn> It's my first time using the FFI, so I probably did something wrong.
23:27:14 <M30W> arbn: I'm quite new with haskell and I'm working on an irc parser :D I don't care if your code is ugly. :P
23:27:18 <M30W> Oh FFI D:
23:27:30 <M30W> FFI -> Cause for your leaks I bet. Haha
23:28:00 <arbn> M30W: How would that be?
23:28:24 <M30W> cause haskell is pretty solid good luck leaking memory. :)
23:28:58 <hpaste> arbn pasted “ugly ffi experiment” at http://hpaste.org/81354
23:29:26 <arbn> I guess it's a GHC bug, even if the code is wrong. Hm.
23:30:38 * M30W hasn't touched ffi yet and a little surprised to see ptr :)
23:30:57 <M30W> (First time seeing a ptr in haskell, whoo!)
23:31:12 <johnw> arbn: always blame your tools last
23:31:20 <c_wraith> Ptr is exactly a C pointer.
23:31:27 <M30W> c_wraith: I know :P
23:31:28 <c_wraith> ForeignPtr is..  more sophisticated
23:32:10 <arbn> johnw: If the compiler won't compile *or* return an error... I don't know. :/
23:32:34 <johnw> arbn: why are you allocating a pointer to point to the CString you allocated?
23:33:35 <johnw> newCString returns a Ptr Char (aka CString); do you really intend to make a Ptr (Ptr Char)?
23:34:36 <arbn> johnw: It's a struct, so I have to use char** to avoid variable length fields in the middle.
23:34:56 <johnw> what is a struct?
23:35:01 <johnw> C'CBook?
23:35:01 <c_wraith> char* isn't variable-width..
23:35:13 <ofan> laziness may cause memory leak :D
23:35:21 <arbn> c_wraith: Oh. Good point. Do you think that's the problem?
23:35:31 <arbn> I can fix that.
23:35:33 <johnw> well, it's just a waste, but I don't see it as a major problem
23:35:38 <johnw> but where do you free this memorY?
23:35:48 <johnw> malloc returns unmanaged memory, the GC will never free it
23:35:54 <arbn> johnw: I haven't run it yet. I'm just trying to get this to compile.
23:35:58 <johnw> ah
23:35:58 <c_wraith> hmm.  C'CBook implies you're using bindings-DSL?
23:36:03 <arbn> c_wraith: Yes.
23:36:21 <arbn> c_wraith: The .hsc does compile, though. This module doesn't.
23:36:24 <c_wraith> I like that library. But it is still fiddly, like all native interfaces
23:37:01 <johnw> arbn: what is the compile error?
23:37:12 <arbn> johnw: There isn't one.
23:37:17 <otters> upload speed to hackage is less than impressive
23:37:19 <arbn> johnw: The compiler leaks memory.
23:37:33 <johnw> arbn: you aren't freeing any memory, in what you posted
23:38:16 <arbn> johnw: Does GHC run my code somehow while it compiles it? I was planning to free the memory in the C code calling this function.
23:38:38 <johnw> arbn: what do you mean by "the compiler leaks memory"?
23:39:04 <arbn> johnw: The ghc process uses up to 5-6 GB and runs for a very long time.
23:39:45 <johnw> i would ask about that in #ghc
23:40:02 <arbn> johnw: Oh. OK. Thanks. I didn't know there was a #ghc.
23:41:53 <ofan> arbn: you can do profiling and see which function uses most of the memory
23:43:00 <arbn> ofan: Oh? How do I run GHC with profiling?
23:43:23 <M30W> Is a data structure what does the ! mean?
23:43:43 <c_wraith> M30W: it means that when the constructor is forced to WHNF, it also forces that field to WHNF
23:43:45 <M30W> In *
23:43:57 <M30W> WHNF ?
23:44:11 <c_wraith> Weak Head-Normal Form.  Think of it as "evaluating the thunk"
23:44:50 <M30W> What does it add?
23:44:57 <Nereid> if you write data Foo = Foo !Bar, then
23:45:13 <Nereid> whenever you evaluate Foo x, x gets evaluated. or rather
23:45:28 * hackagebot kevin 0.6.1 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.6.1 (JoelTaylor)
23:45:31 <Nereid> it's like writing data Foo = Foo Bar and then replacing Foo x with x `seq` Foo x everywhere.
23:46:19 <M30W> So.. Forces the code to be evaluated when defined not when needed?
23:46:29 <ofan> arbn: run the executable with '+RTS -p'
23:46:31 <Nereid> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html look for "Strictness Flags"
23:47:47 <ofan> arbn: http://book.realworldhaskell.org/read/profiling-and-optimization.html , hope this can help
23:49:30 <M30W> Neat
23:49:32 <Nereid> ofan: the issue is that it's GHC that leaks, not his compiled code.
23:49:37 <Nereid> or appears to leak.
23:51:32 <otters> is there any way to make GHCi tell me on what line of my source "head" encountered an empty list
23:52:14 <adnap> How do you convert CFloat to Float?
23:52:17 <ofan> Nereid: yeah, it could be the laziness, but he said it uses 6G mem, and the code uses ffi, i guess it's not likely ghc's problem
23:52:31 <Nereid> ofan: no, it leaks when he's compiling it.
23:52:54 <ofan> oh ok, I missed that point
23:53:20 <Nereid> otters: not really. although generally you should avoid using partial functions like head anyway
23:53:26 <otters> yeah
23:53:29 <otters> fair point
23:53:30 <adnap> nvm. the answer is realToFrac
23:53:38 <knz> adnap: 'morning
23:53:48 <M30W> Parsec... How would I go about taking "371" "MODE" "PRIVMSG"  into a data record. data Response = Response { sender :: BS.ByteString, response :: Either Error Response, target :: BS.ByteString, message :: BS.ByteString }
23:54:15 <M30W> Err.. ":sender response target :message"
23:56:01 <otters> doesn't GHC have an option for spitting out stack traces?
23:56:08 <lispy> otters: yeah
23:56:33 <lispy> otters: -Ewarn?
23:57:49 <adnap> knz: Hey. I successfully compiled Haskell FFI code calling C++ functions which use vectors.
23:58:03 <lispy> otters: oh, n/m -Ewarn is something else. +RTS -xc
23:58:28 <lispy> otters: I think you have to use profiling too
23:58:48 <Nereid> actually
23:59:06 <Nereid> yeah
23:59:24 <otters> how do I make cabal-dev build with -prof
23:59:39 <lispy> --enable-library-profiling --enable-executable-profiling
23:59:40 <otters> I added --enable-executable-profiling to the .cabal file
23:59:43 <otters> oh, both
23:59:53 <lispy> I don't know if you actually *need* both
23:59:58 <lispy> I just do both because I'm paranoid
