00:01:00 <johnw> you need executable profiling
00:01:15 <johnw> library profiling builds both library variants; executable actually uses the profiling variant at link time
00:01:23 <FMKilo-bot> does
00:01:29 <FMKilo-bot> does anyone know how to make me do /me commands?
00:01:47 <FMKilo-bot> I'm written in haskell...
00:02:05 <Nereid> FMKilo-bot: read about CTCP commands, specifically ACTION
00:02:20 <FMKilo-bot> Thank you for your answer
00:02:50 <M30W> FMKilo-bot: privmsg channel :\003ACTION ...\003 iirc
00:03:23 <M30W> Nereid: CTCP?
00:04:30 <Nereid> you can look it up too :v
00:04:45 <FMKilo> client to client protocol
00:04:45 <Nereid> also I thought it was \001
00:05:02 <M30W> Nereid: Yes \1 was about to correct myself
00:05:07 <M30W> \3 is ctrl c XD
00:05:19 <FMKilo> lol
00:05:42 <M30W> Or just type ctrl a :)
00:06:16 <FMKilo> but i'm trying to help a friend code his bot...
00:06:17 <M30W> But generally. it's \1 or graphically ^A
00:06:41 <M30W> FMKilo: privmsg #channel :\1ACTION testing\1
00:07:13 <FMKilo> what's with the double \1
00:07:23 <M30W> test
00:07:33 <M30W> Did that test go through?
00:07:49 <FMKilo> I have to reload...
00:08:07 <M30W> FMKilo: As in at the end? More or less a way to close the action
00:08:58 <M30W> Nereid: Ah you were correct heh. I now understand CTCP :D
00:09:22 * M30W didn't know it was really privmsg. :P
00:10:46 <M30W> FMKilo: I'm working on an irc library right now.. How are you parsing irc messages?
00:11:19 <FMKilo> honestly, I have no idea, I'm just trying to add this to my friend's already functioning bot.
00:11:48 <FMKilo> https://github.com/ProjectOpenCannibal/Hab/commits/
00:12:51 <ofan> M30W: are you using parsec?
00:13:44 <M30W> ofan: Plan/intend to but really lost for how.
00:14:19 <M30W> ofan: http://ix.io/49a
00:14:32 <FMKilo> M30W:     | "!id " `isPrefixOf` x = privmsg (drop 4 x)
00:14:46 <flebron> Perhaps stupid question but, why doesn't this output anything? sequence $ map return [1..] :: [[Int]]
00:14:57 <M30W> FMKilo: That's parsing the user input; also not the cleanest way.
00:15:17 <FMKilo> right, I was told that.
00:15:30 <M30W> FMKilo: https://github.com/ProjectOpenCannibal/Hab/blob/master/Listen.hs
00:15:35 <M30W> Doesn't parse must irc XD
00:16:01 <ofan> M30W: there's a library that parses irc message using parsec: http://hackage.haskell.org/package/irc-0.5.1.0
00:16:44 <M30W> FMKilo: I'm trying to parse the full irc rfc spec :D
00:16:52 <M30W> ofan:  I've seen it.
00:17:18 <M30W> ofan: Did you see my paste? I am after a bit of a differentt output record
00:17:34 <ofan> M30W: yeah, i'm looking at it
00:17:38 <sgronblo> Does Haskell have some built in function that works like python's enumerate?
00:17:40 <FMKilo> I pretty much have no idea what I'm doing here...
00:18:27 <sgronblo> Ie >>> list(enumerate("abc"))
00:18:28 <sgronblo> [(0, 'a'), (1, 'b'), (2, 'c')]
00:18:51 <M30W> zipWith maybe
00:19:58 <M30W> ofan: Any idea on how I could parse the input to the record?
00:20:23 <flebron> > let f = zip [0..] in f "abc"
00:20:25 <lambdabot>   [(0,'a'),(1,'b'),(2,'c')]
00:20:40 <M30W> zip * yea
00:21:22 <sgronblo> Yeah I knew you could zip it but I was just wondering if there was a builtin. Thanks.
00:21:56 <M30W> sgronblo: why bother? :P zip [0..] "string" not short enough?
00:22:26 <flebron> zip is built in
00:22:47 <M30W> flebron: Well base *
00:22:57 <flebron> as built in as it gets
00:23:05 <M30W> not a keyword :P
00:23:17 <sgronblo> M30W: yeah it is pretty short
00:23:24 <`nand`> > itoList "foobar"
00:23:26 <lambdabot>   [(0,'f'),(1,'o'),(2,'o'),(3,'b'),(4,'a'),(5,'r')]
00:23:30 <`nand`> there you go, just one name!
00:23:43 <M30W> @src itoList
00:23:43 <`nand`> generalized, too
00:23:43 <lambdabot> Source not found. Take a stress pill and think things over.
00:23:48 <M30W> @hoogle itoList
00:23:48 <lambdabot> No results found
00:24:09 <M30W> `nand`: Yea for lambdabot :P
00:24:10 <sgronblo> next question: what is a good way to do for e in list: print "an element: " ++ e in haskell?
00:24:17 <otters> :t itoList
00:24:19 <lambdabot> FoldableWithIndex i f => f a -> [(i, a)]
00:24:20 <ofan> M30W: data PrivMsg = PrivMsg Host User Channel Msg, then construct a PrivMsg for every matched message
00:24:41 <flebron> mapM_ ((print "an element") ++) list
00:24:51 <`nand`> > itoList $ M.fromList [("foo",123),("bar",456),("bat",789)]
00:24:53 <lambdabot>   [("bar",456),("bat",789),("foo",123)]
00:25:02 <M30W> ofan: Don't want to just parse privmsg.... Did you see the other couple of hundred lines? XD
00:25:07 <flebron> or something like that
00:25:17 <M30W> well 150+
00:25:27 <flebron> mapM_ (print . ("an element" ++))
00:25:29 <sgronblo> flebron: where's the reference to the element?
00:25:34 <sgronblo> just implicit?
00:25:37 <flebron> yes
00:25:44 <ofan> M30W: yeah I see, but you need to break these giant records into small and more specific ones
00:25:46 <flebron> the function provided to mapM_ is the same as
00:25:50 <sgronblo> ok well what if i want to get more fancy with the string?
00:25:51 <M30W> ofan: I want to parse to my data structure I want.
00:25:56 <flebron> \x -> print ("an element" ++ x)
00:25:59 <M30W> ofan: Oh really?
00:26:08 <flebron> sgronblo, what does that mean?
00:26:23 <hpaste> adnap pasted ‚Äúglfw close fail‚Äù at http://hpaste.org/81356
00:26:48 <flebron> > mapM_ (print . ("an element: " ++)) ["foo", "bar"]
00:26:49 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
00:26:49 <lambdabot>    arising from a use of ...
00:26:59 <flebron> dumb lambdabot :(
00:27:02 <M30W> I see in your data PrivMsg = PrivMsg Host User Channel Msg as my .. data Response = Response { sender, response, target, message }
00:27:14 <applicative> sequence_ $ [putStrLn $ "an element : " ++ str | str <- list]
00:27:18 <adnap> Why does the window in the Haskel program fail to close when you send a close event (such as clicking "x") while the C+ doesn't?
00:27:27 <applicative> sequence_  [putStrLn $ "an element : " ++ str | str <- list]
00:27:28 <M30W> Sender may get sub-parsed too. Good point.
00:27:29 <adnap> *C++
00:27:36 <sgronblo> yeah more like applicative's version
00:27:54 <flebron> sure, that's more explicit
00:28:15 <applicative> mapM_ (putStrLn . ("an element : " ++)) list
00:28:19 <M30W> flebron: lambdabot /= io
00:28:21 <lispy> adnap: are you running it from ghci or compiled?
00:28:23 <flebron> i know
00:28:48 <flebron> or really, io `notElem` (capabilities lambdabot)
00:29:00 <lispy> adnap: if you're using ghci you have to add -fno-ghci-sandbox to the commandline
00:29:02 <adnap> lispy: compiled
00:29:10 <M30W> > mapM ("an element " ++) ["foo", "bar"]
00:29:12 <lambdabot>   ["aa","an","a ","ae","al","ae","am","ae","an","at","a ","ab","aa","ar","na"...
00:29:18 <M30W> Hehe whoops
00:29:33 <sgronblo> By the way is there some good reason that Haskell doesn't do String interpolation?
00:29:53 <adnap> sgronblo: What is string interpolation?
00:30:08 <`nand`> I think it would be useful to define an ‚Äòoutput‚Äô monad in lambdabot, which gives you print and putStrLn and works isomorphically to a Writer String
00:30:17 <flebron> so saying "foo bar baz" would be replaced by "foo 56 baz", when there's some variable bar whose value is 56?
00:30:22 <flebron> that would be quite confusing indeed
00:30:27 <`nand`> which has a Show instance that just returns the accumulated output
00:31:01 <sgronblo> adnap: like ruby's "Hello #{User.name}" syntax for defining strings
00:31:04 <M30W> sgronblo
00:31:11 <sgronblo> I prefer this to concatenation
00:31:14 <lispy> `nand`: as long as it truncated things so that people woludn't spam the channel with it
00:31:30 <M30W> > unlines $ map ("An Element : " ++) ["foo","bar"]
00:31:32 <lambdabot>   "An Element : foo\nAn Element : bar\n"
00:31:42 <`nand`> lispy: wouldn't do anything worse than what lambdabot already does for large outputs, I guess
00:31:45 <flebron> why not "Hello " ++ (name user)
00:31:46 <adnap> sgronblo: I don't know Ruby
00:31:58 <sgronblo> flebron: that just looks nastier
00:32:01 <M30W> sgronblo: ^^^
00:32:04 <flebron> i disagree
00:32:05 <adnap> It must be bad if it's from Ruby
00:32:19 <sgronblo> hehe dont be so mean to ruby
00:32:24 <sgronblo> there are much better targets to pick on
00:32:29 <lispy> You could add string interpolation
00:32:36 <adnap> PHP? Python?
00:32:40 <lispy> look at the implementation of Text.Printf
00:32:41 <sgronblo> Yeah PHP
00:32:46 <sgronblo> Bash scripting
00:32:54 <sgronblo> Python is OK
00:32:55 <adnap> I like bash scripting
00:33:00 <`nand`> lispy: I don't think that's quite the same thing
00:33:15 <`nand`> lispy: with string interpolation (I guess) you need to be able to evaluate an arbitrary string as if it were haskell source code
00:33:17 <`nand`> in that location
00:33:45 <adnap> sgronblo: Can you simply explain what "string interpolation" is, or should I just read about it?
00:33:57 <M30W> adnap: shell scripting can be fun but when you get too experienced you find it easier to make a shell irc/mpd bridge bot then to learn haskell to do the same. XD
00:34:04 <`nand`> heck, haskell code doesn't even know about names, so "foo #{bar}" wouldn't be able to know anything about ‚Äòbar‚Äô currently in scope
00:34:07 <lispy> `nand`: perhaps quasiquoters would work better then
00:34:17 <`nand`> lispy: yes a quasiquoter looks like it would work for this
00:34:50 <applicative> @type printf
00:34:51 <lambdabot> PrintfType r => String -> r
00:34:55 <M30W> sgronblo: you'd probally want to use Text.printf as suggested by lispy
00:35:02 <lispy> [si|"Hello #{user name}"]
00:35:19 <tieTYT2> hi
00:35:20 <adnap> M30W: I'm not too experienced with bash scripting. I don't do much more than simple loops. I don't know what you're talking about regarding bots
00:35:41 <M30W> adnap: with some zsh optimizations it's easy here just a sec
00:35:42 <`nand`> lispy: the " are superfluous
00:35:44 <applicative> > printf "hello %s , welcome\n"
00:35:45 <lambdabot>   Ambiguous type variable `a0' in the constraints:
00:35:45 <lambdabot>    (GHC.Show.Show a0)
00:35:45 <lambdabot>     ...
00:36:05 <applicative> > printf "hello %s , welcome\n" "Louise" :: String
00:36:06 <lambdabot>   "hello Louise , welcome\n"
00:36:20 <tieTYT2> can someone tell me what I'm doing wrong here? http://hpaste.org/81357
00:36:47 <M30W> adnap: Old version but here http://ix.io/49c
00:36:55 <applicative> @type truncate
00:36:57 <lambdabot> (Integral b, RealFrac a) => a -> b
00:37:07 <applicative> @type (/)
00:37:09 <lambdabot> Fractional a => a -> a -> a
00:37:13 <`nand`> adnap: you can't use (/) on Integral types
00:37:19 <lispy> sgronblo: http://stackoverflow.com/questions/1264797/string-interpolation-in-haskell
00:37:27 <tieTYT2> `nand`: did you mean to tell me that?
00:37:29 <lispy> sgronblo: looks like someone already did it as a quasiquoter
00:37:30 <M30W> Current version can do a bit more but I don't have a copy atm. It also deals with opers/kicks/bans etc much nicer and uses a litte txtfile database for things :D
00:37:38 <`nand`> tieTYT2/adnap: sorry, yes
00:37:47 <M30W> adnap: And a hell of a cleanup :P
00:37:53 <lispy> sgronblo: and it even uses ruby syntax
00:37:57 <tieTYT2> `nand`: i figured the fact that I'm truncating the result would put it back into an integral
00:37:58 <adnap> M30W: Oh. Now I understand your original sentence
00:38:04 <lispy> http://hackage.haskell.org/packages/archive/interpolatedstring-qq/0.1/doc/html/Text-InterpolatedString-QQ.html
00:38:15 <tieTYT2> `nand`: oh I get it now.  It's saying x is an integral so you can't use it on /
00:38:22 <tieTYT2> I thought it was saying I wasn't casting correctly
00:38:24 <adnap> M30W: You were saying you are so good at bash scripting that you prefer to write IRC bots using it
00:38:37 <M30W> adnap: Kinda
00:38:46 <M30W> adnap: It was easier to write in shell then to learn haskell :P
00:38:57 <applicative> > let x = 2 in truncate $ fromIntegral x / 2
00:38:59 <lambdabot>   1
00:39:01 <`nand`> tieTYT2: Haskell doesn't have casting
00:39:26 <tieTYT2> i guess I mean converting, then: another question:
00:39:32 <tieTYT2> http://www.haskell.org/haskellwiki/Converting_numbers
00:39:34 <adnap> M30W: Perhaps you would be interested in this: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
00:39:39 <`nand`> tieTYT2: (it's actually slightly different from that; the error message is saying that ‚Äòx‚Äô is /not/ Fractional, so you can't use (/) on it)
00:40:04 <tieTYT2> `nand`: ah
00:40:06 <M30W> But limitations created a bug or two ;) Also lazyless adds a few. For example you could trigger the bot with all this junk :!next (space colon and the bot's escape after the wildcard also allows injection into the mpd stream however will just return with acks cause you can't inject a newline :P
00:40:24 <`nand`> tieTYT2: while you could add (Integral a, Fractional a, RealFrac a) -- and the code would type check and compile, you wouldn't ever be able to use it
00:40:32 <`nand`> because there is no type that is Integral and Fractional
00:40:44 <tieTYT2> another question, if I remove the type and the truncate method, the function compiles but it has a type of (Fractional a, Integral a) => ... Is that something that's impossible to satisfy?
00:40:56 <`nand`> it is impossible to satisfy
00:40:56 <tieTYT2> `nand`: you seem to be one step ahead of my questions :P
00:41:08 <tieTYT2> thanks for the help
00:41:10 <`nand`> there are two solutions to this; the one you really want, and the one that might come in handy some other time
00:41:15 <M30W> limitations, ideal only for few channels cause if it's in several channels the async shell scripting bites cause if two commands are ran; both will set the channel name to a file. If the first command doesn't run before the file was overridden then the shared variable is incorrect for the requested command
00:41:15 <tieTYT2> my book says to use div
00:41:18 <`nand`> what you want is the function div
00:41:20 <M30W> adnap: ^
00:41:20 <`nand`> :t div
00:41:22 <lambdabot> Integral a => a -> a -> a
00:41:34 <`nand`> div divides two integral numbers and.. truncates? the result
00:41:35 <applicative> tieTYT2: you could use divMod or quotRem and scrap /
00:41:41 <`nand`> or at least rounds in some way
00:42:09 <applicative> > quotRem 3 2
00:42:11 <lambdabot>   (1,1)
00:42:35 <tieTYT2> i think I want div.  It's an even number so there won't be remainders
00:42:46 <M30W> adnap: you don't have multi thread variable sharing in a shell script. Sure if you wanna have 20-30 lines or 5 messy lines; you could play with the /proc/process/env easy enough but you'd be creating seperate forks with some sleep delay for their life (also adds a timeout ability) and more messy but doable
00:42:51 <M30W> Not ideal
00:42:51 <M30W> xD
00:43:00 <adnap> `nand`: What are you referencing?
00:43:02 <M30W> MVar - TVar - IORef, god; thank you haskell!
00:43:04 <`nand`> tieTYT2: another solution would be to convert from your integral type to some fractional type (with fromIntegral), divide that, and then round/truncate back to the integral type. HOWEVER: since you're going through some fractional type, which without further annotations most likely will default to Double (which is fairly imprecise), that's less optimal
00:43:22 <adnap> `nand`: I am very confused as to why you are directing statements to me
00:43:30 <`nand`> adnap: it was a mistake
00:43:37 <applicative> collatz x = case quotRem x 2 of (n,0) -> x : collatz n + 1
00:43:44 <sgronblo> Thanks for helping me out, my program finally is producing correct output
00:43:47 <M30W> adnap: you like the shell bot?
00:43:56 <adnap> `nand`: Okay. I thought so, but then M30W said "^"
00:44:02 <M30W> Btw; I sent you 0.0.2 :P
00:44:05 <tieTYT2> ok, thanks for the help `nand`
00:44:13 <adnap> M30W: I just sort of glossed over it. I didn't read it in detail
00:44:16 <M30W> adnap: ^ was for my messages haha
00:44:26 <M30W> adnap: tip <<< is more or less echo :D
00:44:26 <adnap> M30W: The pastebin site you used seems neat
00:45:02 <applicative> let collatz 1 = [1]; collatz x = case quotRem x 2 of (n,0) -> x : collatz n + 1; _ -> x : collatz (3 * x + 1) in collatz 10
00:45:10 <M30W> adnap: Very; ix.io is great you can add a slash to the url and you'll have colour and lines. You can also register and delete your own pastes (python script at the moment, reads the login from ~/.netrc)
00:45:16 <applicative> > let collatz 1 = [1]; collatz x = case quotRem x 2 of (n,0) -> x : collatz n + 1; _ -> x : collatz (3 * x + 1) in collatz 10
00:45:19 <lambdabot>   No instance for (GHC.Num.Num [t0])
00:45:19 <lambdabot>    arising from a use of `e_1112013110'
00:45:19 <lambdabot> ...
00:45:23 <lightquake> anybody have experience with netwire?
00:45:26 <M30W> adnap: I'd like to make a haskell equiv for ix (python) would be awesome. :D
00:45:28 <applicative> hm
00:45:36 <`nand`> applicative: collatz (n + 1)
00:45:42 <M30W> And the password would be secure. :P
00:45:46 <applicative> > let collatz 1 = [1]; collatz x = case quotRem x 2 of (n,0) -> x : collatz (n + 1); _ -> x : collatz (3 * x + 1) in collatz 10
00:45:48 <lambdabot>   [10,6,4,3,10,6,4,3,10,6,4,3,10,6,4,3,10,6,4,3,10,6,4,3,10,6,4,3,10,6,4,3,10...
00:45:56 <lightquake> i'm not sure how to implement discrete events, like entity spawning, collisions, etc.
00:45:59 <applicative> cant be right!
00:46:23 <M30W> applicative: It looks right to me. lambdabot gave the valid response :D
00:46:40 <applicative> hah
00:47:02 <otters> fuck I hate cabal-dev
00:47:08 <`nand`> > let collatz 1 = [1]; collatz x = case quotRem x 2 of (n,0) -> x : collatz n; _ -> x : collatz (3*x+1) in collatz 10
00:47:09 <applicative> is it the same as the pasted collatz? ah well
00:47:09 <lambdabot>   [10,5,16,8,4,2,1]
00:47:10 <M30W> Someone launch lambdabot with -XLambdaCase >_<
00:47:18 <M30W> Be fun :)
00:47:34 <`nand`> in the collatz conjecture one takes x/2 of an even number, not x/2+1
00:48:31 <applicative> ah
00:48:39 <hpaste> otters pasted ‚Äúcabal-dev sux‚Äù at http://hpaste.org/81358
00:48:50 <M30W> ofan: Any suggestions for parsing to my records?
00:50:00 * osfameron hopes tomboy64 isn't counting down to an explosion
00:50:10 * applicative was wondering too
00:50:37 <otters> "the flag -xc requires the program to be built with -prof"
00:50:40 <otters> how do I build the program with -prof
00:50:45 <otters> -prof is in the .cabal file
00:50:48 <lightquake> otters: --enable-library-profiling and --enable-executable-profiling are options to cabal-dev configure
00:51:13 <lightquake> so do cabal-dev configure --enable-library-profiling --enable-executable-profiling, then try it?
00:51:47 <otters> nope
00:52:07 <M30W> tomboy64: What happens when you reach zero?
00:52:09 <lightquake> hm
00:52:49 <Enigmagic> otters: the 'ghc-options: ... +RTS -xc' is passing -xc to ghc
00:53:10 <otters> okay I removed it
00:53:12 <lightquake> ahh
00:53:18 <lightquake> yeah
00:53:26 <otters> there we go
00:53:51 <otters> okay so how do I actually pass RTS opts in
00:54:29 <Enigmagic> otters: GHC-Options: -rtsopts "-with-rtsopts=-qg1 -N"
00:54:32 <Enigmagic> something like that
00:55:29 * hackagebot multipass 0.1.0.2 - Folding data with multiple named passes  http://hackage.haskell.org/package/multipass-0.1.0.2 (EdwardKmett)
00:55:30 <Enigmagic> since you want one that works with -prof only, I'd put it in like this:
00:55:40 <otters> I just want some way to get a stack trace
00:55:43 <otters> I've been up for three hours
00:55:45 <Enigmagic> GHC-Prof-Options: -rtsopts "-with-rtsopts=-xc"
00:55:47 <adnap> Multipass!
00:56:27 <tieTYT2> is there a way to do something like this: length (filter (length > 15) (map (collatz) [1..100]))
00:56:45 <otters> would it affect my chances of getting a stack trace if the exception happens in a thread other than the main thread?
00:56:47 <tieTYT2> collatz is a -> [a].  The problem is I can't pass length > 15 into filter
00:57:09 <Eelis> ((> 15) . length)
00:57:19 <tieTYT2> Eelis: ah, haven't learned that . thing yet
00:57:27 <tieTYT2> but it's good to know it's possible
00:57:37 <Eelis> learning "that . thing" is a good idea :)
00:57:55 <tieTYT2> i'm sure i'll learn it soon, I'm reading learn you a haskell
00:58:17 <Enigmagic> otters: i don't use -xc much, but the default behavior in GHC is (unfortunately) to silently catch exceptions threads except for main.
00:58:30 <otters> how do I change that
00:58:30 <Eelis> tieTYT2: it's just a slightly slicker way of writing  (\x -> length x > 15)
00:58:37 <Enigmagic> otters: hang on.
01:01:24 <tieTYT2> what does !! do?  I'm having trouble googling for this
01:01:29 <Enigmagic> otters: here ya go https://gist.github.com/a628696877dd4248fdf3
01:01:31 <Ralith> :t (!!)
01:01:33 <lambdabot> [a] -> Int -> a
01:01:34 <otters> tieTYT2: hoogle (!!)
01:01:48 <Ralith> look at the type and guess
01:02:04 <Enigmagic> otters: call setDefaultUncaughtExceptionHandler in the first line of your main function, that will disable the silent catching of exceptions..
01:02:18 <tieTYT2> well it takes a list of a and an int, and it returns an element
01:02:55 <tieTYT2> maybe it returns that element in the list
01:04:03 <Ralith> now test it and see!
01:04:11 <tieTYT2> yeah it seems to
01:04:23 <Enigmagic> otters: it will probably eat the stack though, but you can use GHC.Stack.currentCallStack in the exception handler to dump the stack out before aborting the process
01:07:16 <otters> ugh, still no stack trace
01:07:42 <Enigmagic> otters: are you buiding your app with profiling enabled?
01:07:46 <otters> yeah
01:07:50 <otters> well...as far as I know
01:08:14 <Enigmagic> otters: check for profiling info in ./yourApp +RTS -help
01:08:28 <Enigmagic> though if it works with -xc it's got prof enabled
01:09:12 <otters> can I pass those to :main?
01:09:38 <otters> also, the problem is that currentCallStack is returning []
01:09:48 <otters> oh, -fprof-auto
01:11:51 <otters> is -auto-all an RTS option or a GHC option
01:12:05 <Enigmagic> GHC option
01:12:24 <otters> can I pass RTS options to :main or not
01:12:37 <Enigmagic> i'm not sure
01:12:44 <otters> no I can't
01:12:52 <otters> currentCallStack is an empty list
01:12:58 <Enigmagic> if currentCallStack is returning an empty list it sounds like profiling isn't enabled
01:12:58 <otters> what a useful profiling tool
01:13:05 <otters> awesome
01:14:52 <Enigmagic> otters: try nuking your ./dist directory and rerun "cabal configure --enable-executable-profiling --enable-library-profiling"
01:15:25 <otters> hmmm
01:17:36 <otters> okay if I run the executable with +RTS -xc, I get "*** Exception (reporting due to +RTS -xc): (BLACKHOLE), stack trace: GHC.List.CAF" about 8 times
01:17:38 <otters> then a segfault
01:19:44 <Enigmagic> progress at least
01:19:51 <otters> almost
01:20:02 <Enigmagic> it's not an empty list ;-)
01:20:19 <otters> if I export GHCRTS='-xc' and then cabal-dev ghci, I get the error that the program must be built with -prof
01:20:58 <Enigmagic> so it sounds like you have a blackhole exception stemming from a caf
01:21:13 <otters> whatever a caf may be
01:21:27 <Enigmagic> do you know what a blackhole exception is?
01:21:32 <otters> no
01:22:49 <Enigmagic> ok, so a CAF is something like a global value
01:22:56 <otters> the thing that confuses me is once I "cabal install" this project, the exception handler set by setUncaughtExceptionHandler doesn't execute anymore
01:24:05 <Enigmagic> "x :: [Int]; x = x" would be a CAF that would throw an exception like that
01:24:30 <otters> I see
01:24:59 <Enigmagic> if it repros in ghci but breaks after the exception, use -fbreak-on-exception and -fbreak-on-error, then run your app with ":trace main"
01:28:13 <otters> okay, I'm not sure why break-on-exception put me where it put me
01:29:50 <Enigmagic> does :history tell you anything useful?
01:30:43 <Enigmagic> (if it hits compiled code it usually dumps out nothing, but currentCallStack should still work)
01:31:02 <Enigmagic> (not in ghci though...)
01:31:10 <otters> currentCallStack doesn't work
01:31:15 <otters> heh
01:31:35 <otters> hang on
01:32:12 <Enigmagic> i don't use ghci for debugging really ... and gdb isn't super user friendly for debugging haskell over irc ;_)
01:32:51 <Enigmagic> :trace/:history should work if all the code involved is loaded into ghci
01:33:28 <otters> okay, it stopped on an exception
01:33:38 <otters> _exception = SomeException (ErrorCall "Prelude.head: empty list")
01:33:43 <Enigmagic> it gets confused and gives you some misleading error like "did you use :trace?" if the exception is raised in compiled code
01:34:00 <otters> I think this is all interpreted
01:34:06 <Enigmagic> ok good
01:34:38 <Enigmagic> so now: :history, :back, :force <variable> and :print <variable> are your tools now
01:34:56 * shachaf should probably learn to use the ghci debugger.
01:35:41 <Enigmagic> i wouldn't really call ghci a debugger
01:36:43 <Enigmagic> it is useful but it's far from a debugger
01:36:59 <shachaf> Well, those commands are for debugging.
01:37:32 <otters> this sounds like a really dumb question, but will -fbreak-on-error only break when error is called, as opposed to an exception being thrown
01:38:11 <shachaf>        -fbreak-on-exception
01:38:12 <shachaf>               Break on any exception thrown
01:38:27 <Enigmagic> otters: that was my memory of it, yeah. it doesn't break on the same thing as -fbreak-on-exception
01:38:41 <otters> jesus, I think I found it
01:38:45 <Enigmagic> shachaf: it does things that debuggers do, but that doesn't mean it's a debugger
01:40:09 <Enigmagic> otters: something easy to fix? :-)
01:41:34 <otters> yeah
01:41:41 <Enigmagic> sweet
01:44:16 <otters> doh. yeah
01:45:24 <otters> damn logic errors again
01:45:30 * hackagebot network-api-support 0.0.3 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.0.3 (MarkHibberd)
01:46:35 <Enigmagic> common culprit
01:52:43 <otters> only culprit these days
01:52:54 <otters> now it's 5 AM and I'm still up
01:52:59 <otters> all nighter or no
01:57:11 <Enigmagic> i can't do those anymore
01:57:19 <Enigmagic> it's almost 2 here and i'm definitely going to bed
02:05:31 * hackagebot postmark 0.0.2 - Library for postmarkapp.com HTTP Api  http://hackage.haskell.org/package/postmark-0.0.2 (MarkHibberd)
02:05:33 * hackagebot kevin 0.7 - a dAmn î IRC proxy  http://hackage.haskell.org/package/kevin-0.7 (JoelTaylor)
02:05:50 <basdirks> I can append to the list of children of a Data.Tree.Tree with `\t ys -> t & branches <>~ ys', but what's the normal non-lens way? `\(Node x xs) ys -> Node x (xs ++ ys)'?
02:20:26 * fmap is waiting for a bunch of "How to do X without lens" questions on stackoverflow
02:20:53 <basdirks> heh
02:21:05 <lightquake> ?
02:21:10 <lightquake> with*out* lens?
02:21:22 <basdirks> I know how to do this, but not how it's done idiomatically
02:23:24 <mikeplus64> @pl (.) . f
02:23:24 <lambdabot> (.) . f
02:24:42 <fmap> lightquake: yeah, that sounds crazy
02:27:31 <Taneb> Is there a standard file extension for files to be hsc2hs'd?
02:27:55 <shachaf> hsc
02:28:10 <Taneb> Okay, thanks
02:34:52 <Nereid> > (+1) ^. ix 3
02:34:54 <lambdabot>   4
02:34:59 <Nereid> wow nice, that works.
02:35:26 <Nereid> :t (+1) & ix 3 .~ 5
02:35:28 <lambdabot> (Eq a, Num a) => a -> a
02:35:32 <Nereid> wait really.
02:35:35 <shachaf> Yep.
02:35:37 <Nereid> map ((+1) & ix 3 .~ 5) [3,4]
02:35:40 <Nereid> > map ((+1) & ix 3 .~ 5) [3,4]
02:35:43 <lambdabot>   [5,5]
02:35:46 <Nereid> haha.
02:47:12 <Nereid> > (const undefined & ix 3 .~ 5) 3
02:47:14 <lambdabot>   5
02:47:19 <Nereid> > (undefined & ix 3 .~ 5) 3
02:47:21 <lambdabot>   5
02:47:24 <Nereid> brilliant.
02:47:43 <shachaf> It works well with type Set a = a -> Bool!
02:47:51 <Nereid> indeed
02:48:10 <Nereid> or Map a b = a -> Maybe b
02:48:29 <Nereid> > (const Nothing & at 3 .~ Just 5) 3
02:48:31 <lambdabot>   Could not deduce (Control.Lens.At.At (b0 -> Data.Maybe.Maybe a))
02:48:31 <lambdabot>    arising...
02:48:36 <Nereid> aw! make it work.
02:48:41 <shachaf> s/at/ix/
02:48:43 <shachaf> hth
02:48:52 <Nereid> sure.
02:48:55 <Nereid> :p
02:49:00 <shachaf> Oh, I see.
02:49:05 <shachaf> No, I'm not going to make it work.
02:49:07 <Nereid> haha
02:49:23 <Nereid> > (const Nothing & ix 3 .~ Just 5) ^? 3
02:49:25 <lambdabot>   Could not deduce (GHC.Num.Num
02:49:25 <lambdabot>                      (Control.Lens.Getter.Get...
02:49:28 <Nereid> > (const Nothing & ix 3 .~ Just 5) ^? ix 3
02:49:31 <lambdabot>   Just (Just 5)
02:49:38 <Nereid> no.
02:49:55 <Nereid> whatever.
02:49:59 <shachaf> Hmm, we should define an At instance that uses teaspoon.
02:50:10 <Nereid> what's that?
02:50:23 <shachaf> You know, teaspoon :: a -> Maybe a
02:50:33 <Nereid> ah.
02:50:33 <shachaf> teaspoon ‚ä• = Nothing; teaspoon x = Just x
02:50:35 <Nereid> right.
02:50:59 <shachaf> Turing wasn't smart enough to be able to write it.
02:51:04 <Nereid> haha
02:51:05 <shachaf> Fortunately we're more advanced these days.
03:10:24 <srhb> I need to swap a pair of characters in a "string" randomly a large number of times in a genetic-ish algorithm, what "string" structure is most suited for this?
03:10:38 <srhb> I suppose an IntMap would do.
03:10:44 <srhb> Or simply Map, actually.
03:18:02 <basdirks> if I have `data Foo = Bar | Baz | Quux', how do I make an instance for Show Foo where show Bar = "bar", show Baz = "baz", etc.. (without resorting to a String literal on the rhs)?
03:18:20 <shachaf> You don't.
03:18:26 <basdirks> because?
03:18:27 <shachaf> Alternatively, you write some TH for it.
03:18:32 <basdirks> ok
03:18:49 <shachaf> Or you derive Show, and then use a different function on top that lowercases it?
03:18:52 <shachaf> I don't know.
03:19:10 <M30W> how does one define th?
03:19:13 <basdirks> yeah that I had considered, but seems lame
03:21:36 <basdirks> TH is where Haskell programmers go to lose their sanity, afaik
03:22:32 <basdirks> I'll -ddump-derivs and see how I can stir it up
03:24:36 <`nand`> basdirks: you could base your work off http://hackage.haskell.org/packages/archive/derive/2.5.11/doc/html/Data-Derive-Show.html
03:24:37 <EvilMachine> basdirks: IMO, TH should be replaced by the functionality already being available inside Haskell without doing anything even remotely similar to templating (because that‚Äôs just nasty).
03:25:11 <EvilMachine> basdirks: clarification: i meant that it could be new functionality
03:25:54 <basdirks> `nand` thanks
03:26:09 <basdirks> EvilMachine: I'm not sure that's possible, but I am ignorant on the subject
03:27:55 <EvilMachine> basdirks: I‚Äôm not sure either, but templating and having some program create a mess of instantiated code variants seems like the exact opposite of the Haskell philosophy to me.
03:28:06 <basdirks> yep
03:28:56 <EvilMachine> I wonder what the Haskell way would be. I guess new data type features in the compiler‚Ä¶ (?)
03:31:00 <Maxdamantus> What if you were able to write your own `deriving` definitions?
03:31:27 <Maxdamantus> which would just be functions given the `data` declarations in some tokenish form.
03:31:59 <shachaf> Why not just use TH?
03:32:14 <shachaf> E.g. http://community.haskell.org/~ndm/derive/
03:32:16 <Maxdamantus> Because it might be unnecessary.
03:32:33 <basdirks> I guess I have to learn it sometime, so I might as well try my hand at TH
03:32:40 <shachaf> This sounds exactly like TH.
03:33:04 <shachaf> Run some code at compiletime to generate definitions given compiletime information about types etc.
03:34:08 <Maxdamantus> Does it have to be run at compile time though?
03:34:21 <SamanthaD> Is there some accepted way of waiting for an "anykey"? I really don't care what they type, I just want the computer to pause until they poke it.
03:34:35 <shachaf> SamanthaD: getChar, given the right buffering mode.
03:35:16 <SamanthaD> shachaf: So, I guess I just assign getChar to a variable and pass that variable around?
03:35:23 <shachaf> No.
03:35:32 <shachaf> Execute getChar when you want to wait for a thing.
03:35:43 <shachaf> The value getChar gives you is the key that was pressed, which you don't care about.
03:36:01 <SamanthaD> shachaf: Ah, I see. Thank you!
03:36:18 <Maxdamantus> (buffering in the terminal, that is)
03:36:37 <shachaf> GHC conflates terminal buffering and program buffering. :-(
03:36:47 <Maxdamantus> (in POSIX you'd disable or disable canonical mode .. can't remember which)
03:36:53 <Maxdamantus> Ah.
03:37:13 <SamanthaD> Thanks! I'm just beginning to learn IO and what not.
03:37:41 <basdirks> shachaf: what's a good resource for learning basic TH?
03:37:50 <Maxdamantus> disable
03:39:04 <basdirks> hm I found that I can do what I want with Typeable and Data
03:40:45 <srhb> There should be an update operation for vectors where I can change an element at a single index, shouldn't there? I seem to be unable to find one.
03:41:07 <basdirks> http://stackoverflow.com/questions/12820327/how-to-show-a-constructor-in-lower-case
03:41:48 <fmap> srhb: `modify'
03:42:46 <srhb> Oh, its signature looks a little strange. I was expecting Int -> a -> Vector a -> Vector a
03:43:03 <Maxdamantus> 00:40:47 < basdirks> http://stackoverflow.com/questions/12820327/how-to-show-a-constructor-in-lower-case
03:43:06 <Maxdamantus> Ahah!
03:43:15 <Maxdamantus> Nice.
03:43:31 <Maxdamantus> Basically what I was thinking.
03:44:29 <Maxdamantus> Though I was thinking of giving that sort of representation to a function mentioned in the data declaration.
03:44:46 <Maxdamantus> But that'd be odd.
03:45:10 <basdirks> this saves me quite a bit of gymnastics
03:51:00 <SamanthaD> let me make sure I have this right: The only time I can rely on "do" notation to evaluate from top to bottom is in main.
03:52:10 <Maxdamantus> What does it mean to evaluate from top to bottom?
03:53:45 <Maxdamantus> main = do { let e = sum [ 1/product [1..n] | n <- [0..1000] ]; putStrLn "the answer's coming!"; print e }
03:54:17 <SamanthaD> Maxdamantus: Yes, like that!
03:54:35 <shachaf> SamanthaD: No.
03:54:36 <Nereid> nope
03:54:48 <Nereid> that'll print the string before evaluating e
03:54:52 <hpaste> SamanthaD pasted ‚ÄúgetUSB_IO‚Äù at http://hpaste.org/81360
03:54:57 <shachaf> main isn't special, other than the fact that execution starts and ends there.
03:55:02 <Nereid> if you really want to control order of evaluation in IO, use evaluate
03:55:03 <Nereid> :t evaluate
03:55:05 <lambdabot>     Not in scope: `evaluate'
03:55:05 <lambdabot>     Perhaps you meant `evalState' (imported from Control.Monad.State)
03:55:09 <SamanthaD> Madamantus: That's my function that does everything backwards!
03:55:17 <Nereid> bleh, it's from Control.Exception or something.
03:55:31 <SamanthaD> Nereid: Thank you! I do and I will!
03:55:50 <shachaf> SamanthaD: It's not so certain that you do.
03:55:56 <shachaf> evaluate is kind of special-purpose.
03:56:07 <shachaf> SamanthaD: You should read an introduction to IO in Haskell.
03:56:18 <Nereid> @where IO
03:56:18 <lambdabot> Raphael L. Levien's language with continuations as fundamental structure, described in his paper "Io: a new programming notation" (1989-09-10) at <http://dl.acm.org/citation.cfm?id=70931.70934> and
03:56:18 <lambdabot> in chapter 2 of Raphael A. Finkel's book `APLD', implementations `Amalthea',`Ganymede' - (perhaps you were looking for `@wiki Introduction to IO' ?)
03:56:24 <Nereid> afdgh
03:56:27 <shachaf> ski++
03:56:32 <`nand`> IO just enforces the order of /side effects/ (well, barring threading and lazy IO)
03:56:33 <shachaf> good old ski
03:56:44 <`nand`> it doesn't say anything about the order of evaluation
03:56:55 <shachaf> Except when evaluation is an effect.
03:57:13 <`nand`> I'm not sure what that means
03:57:32 <Maxdamantus> Evaluation has few effects.
03:57:51 <Maxdamantus> > fix id
03:57:54 <lambdabot>   mueval-core: Time limit exceeded
03:58:07 <Maxdamantus> That manages to crash saying <<Loop>> or something when in a program .. for some reason.
03:58:37 <Nereid> yeah, because it detected a loop. magic
03:58:39 <`nand`> that's a black hole used by the RTS
03:58:48 <SamanthaD> Thanks for your help. I'm going to go read Real World Haskell's IO chapter and see if that sinks in...
03:58:54 <shachaf> That's not the same thing.
03:58:56 <Maxdamantus> Yeah, so that's an effect evaluation can have.
03:59:00 <shachaf> SamanthaD: Hmm, that may not be the best introduction.
03:59:02 <Maxdamantus> Kind of.
03:59:15 <`nand`> that's something the RTS decides to spit out, not an effect specified by the Haskell code
03:59:15 <shachaf> Maxdamantus: That's the opposite of evaluation being an effect.
03:59:38 <shachaf> And anyway, disregarding evil which isn't quite relevant here, that's as much of an effect as an infinite loop is..
04:00:18 <shachaf> SamanthaD: Did you see the FAQ?
04:00:21 <shachaf> @where faq
04:00:21 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:00:41 <Maxdamantus> shachaf: which is why I said "kind of"
04:00:59 <SamanthaD> shachaf: Of course!
04:01:01 <Maxdamantus> I'd say both are effects.
04:01:18 <Maxdamantus> Same with `error "foo"`
04:01:25 <shachaf> OK, but we're talking about monadic effects here (and in particular IO effects).
04:01:31 <shachaf> You could call heating up the CPU an effect too.
04:02:09 <Maxdamantus> The [ultimate] effects of those aren't produced through evaluation.
04:02:16 <Maxdamantus> (IO ones, that is)
04:02:53 <shachaf> An effect of executing "evalute foo" is evaluating foo.
04:03:21 <Maxdamantus> Yes.
04:03:26 <Maxdamantus> But how do you execute something?
04:03:43 <Maxdamantus> ./Main
04:06:20 <shachaf> ski: https://en.wikipedia.org/wiki/Apartness_relation
04:33:35 <burbul> is it better style to use `ap` instead of liftMn?
04:34:54 <Taneb> burbul, I'd use Control.Applicative.(<*>)
04:35:32 <burbul> no, I'm genuinely in a monad
04:35:55 <burbul> I'm writing functions like
04:35:56 <burbul> mapVariableM :: Monad m => (Variable -> m Variable) -> Variable -> m Variable
04:35:59 <Taneb> Ah
04:36:04 <burbul> -- order of evaluation matters
04:36:10 <Taneb> Then whatever makes the code prettier
04:36:11 <burbul> so it's liftM or ap
04:36:40 <burbul> `ap` seems nicer, except in the n=1 case (where liftM seems nicer)
04:36:46 <burbul> but mixing the two seemed rather ugly...
04:37:38 <burbul> Ah well, I'll just try something.
04:42:22 <burbul> Is there a synonym for  "return a `ap` b" ?
04:42:36 <Taneb> liftM
04:42:56 <Taneb> :t return ?a `ap` ?b
04:42:58 <lambdabot> (?a::a -> b, ?b::m a, Monad m) => m b
04:43:03 <Taneb> :t liftM ?a ?b
04:43:04 <lambdabot> (?a::a1 -> r, ?b::m a1, Monad m) => m r
04:43:07 <burbul> Sorry, yes
04:43:17 <burbul> I suppose I could use that in infix notation
04:43:24 <burbul> a `liftM` b
04:43:49 <shachaf> You could use WrappedApplicative and then all the Applicative operators. :-)
04:44:04 * burbul googles WrappedApplicative
04:44:13 <shachaf> Of course I meant WrappedMonad
04:44:18 <M30W> How can you add to the prelude? As in, load a module or rc into the ghci environment? (ghci only)
04:44:21 <shachaf> newtype WrappedMonad m a = WrapMonad {unwrapMonad :: m a}
04:44:28 <shachaf> instance Monad m => Applicative (WrappedMonad m)
04:44:40 <M30W> Wanna add; clear = putStr "\ESC[H\ESC[J" :)
04:44:54 <burbul> M30W:
04:44:56 <Taneb> M30W, let clear = putStr "\ESC[H\ESC[J"
04:44:57 <esreskkesketske> hi
04:44:58 <esreskkesketske> How to write in english that situation when i make stool/shit from my ass into toilet? not in vulgar way just normal
04:45:00 <burbul> Can't you just type let
04:45:12 <burbul> ... beat me to it
04:45:33 <M30W> Taneb: I mean.. So it's always there
04:46:00 <Taneb> Make a file called ".ghci" with "let clear = putStr "\ESC[H\ESC[J"" in it
04:46:07 <M30W> Thankyou
04:46:36 <shachaf> Or just press ^L
04:47:06 <M30W> shachaf: Omg, keep forgetting about that :|
04:50:12 <tomboy64> M30W: i will let out a massive fart that melts the icecaps
04:51:13 <M30W> tomboy64: Lol delayed reply much xD
04:52:05 <tomboy64> M30W: not my fault if you write to me while i sleep :-P
04:53:16 <M30W> tomboy64: xD
04:53:32 <M30W> Seemingly automated process for ghosting and fixing nick then? :P
04:54:22 <tomboy64> of coursee
04:54:26 <tomboy64> don't you?
04:55:01 <M30W> tomboy64: No.
04:55:26 <M30W> tomboy64: irssi. I haven't yet made a haskell irc client to replace ;)
04:55:50 <M30W> http://ix.io/49a
04:55:52 <tomboy64> i'm using weechat.
04:56:01 <tomboy64> and i'm pretty sure irssi provides a plugin as well
04:56:06 <M30W> This however is as far as I've gotten for getting a full irc library to haskell. :D
04:56:14 <M30W> tomboy64: Yea I think it's keepnick.pl
04:56:38 <tomboy64> install weechat
04:56:42 <tomboy64> programm a haskell plugin
04:56:47 <M30W> I am on my phone atm so I can't really continue with the development of that library atm.
04:56:50 <M30W> tomboy64: xD
04:56:57 <M30W> tomboy64: I am anti-weechat. :)
04:57:34 <tomboy64> well, i am anti-irssi
04:57:43 <M30W> A. Python bloated. B. You can't do simple things like... Split the @+&~ etc from the nickname and display them on the left before the indentation to the nick then chop.
04:57:47 <M30W> tomboy64: Haha
04:58:20 <M30W> (chop if nick too long) :D
04:58:54 <tomboy64> uhm
04:59:01 <tomboy64> weechat supports pelr scripts
04:59:01 <M30W> I am sure weechat can do the chopping but it can't do the spacing bettween the usermode and nick. Which is an eyecandy for irc I don't wanna live without. Yet I tend to talk through netcat......... XD
04:59:03 <tomboy64> *perl
04:59:10 <M30W> I know
04:59:32 <`nand`> tomboy64: I've been interested in a weechat plugin for Haskell
04:59:49 <M30W> `nand`: I am more interested in an irc client written in haskell.
05:00:07 <M30W> with vty not gtk :D
05:00:24 <M30W> Good morning world!!
05:00:26 <M30W> Mon Jan 28 00:00:11 EST 2013
05:00:57 <`nand`> gave it some consideration too, but I've decided that 1. the weechat API is too complicated and 2. I can't seem to figure out how to compile a haskell library and dynamically load it from C
05:01:13 <tomboy64> M30W: india?
05:04:08 <M30W> tomboy64: Try again
05:04:29 <M30W> `nand`: ffi fun
05:06:10 <tomboy64> well, -11GMT
05:06:33 <tomboy64> no clue then :)
05:10:34 <neutrino> hi
05:10:44 <neutrino> if i wanted to simulate a web browser in haskell, what's the best way to do that?
05:12:33 <M30W> tomboy64: Aus
05:13:04 <M30W> neutrino: By simulate a web browser... You mean make conections to a webserver; pull the information and perform automated tasks?
05:19:47 <M30W> neutrino: ping
05:25:47 <duairc> Is it redundant to use a DList with WriterT?
05:25:56 <Nereid> why would it be?
05:26:45 <duairc> Well the idea of using a DList would be that all the appends would be for "free", but I'm wondering if WriterT is lazy enough to give you that anyway
05:26:55 <Nereid> no
05:27:04 <Nereid> Writer doesn't magically reassociate list concatenations.
05:27:44 <duairc> Okay, I'll use a DList then, thanks!
05:28:10 <M30W> What's DList doing in your context usage?
05:28:31 <Botje> neutrino: a web browser is a big piece of software. by 'simulate' do you mean you just want to fetch pages, fill in forms, etc
05:28:35 <Botje> ?
05:28:55 <Botje> or do you actually want to render pages to screen/file/toaster?
05:29:02 <M30W> Botje: I already asked this.
05:29:10 <M30W> Ahh; rendering would be a pain.
05:29:19 <Nereid> neutrino: I dunno if it suits what you want to do, but http-conduit-browser exists.
05:29:36 * M30W looks at it's source
05:30:28 <M30W> Faster N900!!
05:30:47 <Nereid> I used to want a N900.
05:31:27 <M30W> Nereid: Great little device
05:31:40 <M30W> Plays flash while underclocked better than an ipod :D
05:31:52 <M30W> And iPad's.
05:32:17 <M30W> (Never mentioned stock with that)
05:32:47 <augur> are there any parsing techniques that can partially parse and thereby bring new information into the parser to extend the rules used?
05:33:02 <M30W> augur: parsec may help
05:33:06 <M30W> What are you parsing?
05:33:16 <Nereid> any monad-based parser should be able to do that.
05:33:30 <Nereid> parser library.
05:33:33 <Nereid> such as parsec.
05:33:52 * M30W doesn't understand how to use parsec. :|
05:34:04 <Nereid> have you looked at any examples?
05:34:11 <M30W> Nereid: Yes.
05:34:26 <Nereid> exercise: write your own parser monad.
05:35:11 <augur> M30W: mixfix operators :)
05:35:47 <augur> but the real tricky part is, the parser has to be able to read some code and use that to then parse more code
05:35:55 <M30W> Any ideas on taking ... :server.net 372 Nickname :- Motd message into.. Response { sender = "server.net", response = Motd, target = "Nickname", message = "Motd message" } where sender, target and message are bytestrings and response is data Reply = Motd | ...
05:36:04 <M30W> Nereid: ^
05:36:14 <augur> for instance, \ _*_ -> x * x   which is equivalent to  \ f -> f x x
05:36:20 <augur> only using the infix _*_
05:37:23 <Nereid> sure.
05:37:28 <Nereid> you just do it.
05:37:43 <M30W> That helps....
05:37:51 <Nereid> take the result of parsing the first bit, and then use it to decide what parser action to run next.
05:38:22 * M30W never understood any of the parsec examples he saw btw. :)
05:38:45 <augur> Nereid: indeed, but i dont know what parsers can do it!
05:38:51 <augur> or how, really
05:38:57 <Nereid> do you know how to use parsec?
05:39:06 <M30W> Nereid: No
05:39:09 <Nereid> not you
05:39:15 <M30W> Oh
05:39:45 <augur> Nereid: no, nor do i understand it :)
05:39:51 <Nereid> well you should try to learn it then.
05:40:36 <bitonic> augur: I‚Äôm having a hard time believing you don‚Äôt understand parsec :P
05:40:46 <augur> bitonic: why?
05:41:13 <bitonic> because I‚Äôve seen you talk about trickier things ehe
05:41:31 <augur> doesnt mean ive looked at parsec!
05:42:30 <bitonic> augur: if you‚Äôre looking at monadic parsers, you‚Äôve looked at parsec.  it‚Äôs basically a ‚ÄòParser a = String -> [(a, String)]‚Äô
05:42:57 <augur> ive not looked at monadic parsers :D
05:43:18 <bitonic> augur: OK, I‚Äôm sure you‚Äôll get them quickly ehe
05:43:40 * augur . o O ("ehe"...)
05:43:47 <bitonic> I took ‚ÄòI don‚Äôt understand‚Äô as ‚ÄòI‚Äôve looked at it and I can‚Äôt understand it‚Äô
05:44:21 <augur> well i know theres some vague stuff going on wth monads somewhere in parsec somehow
05:44:23 <augur> thats about all i know :)
05:44:41 * M30W found a real good example and is starting to understand them now :D
05:45:10 <bitonic> M30W: there‚Äôs a chapter in ‚ÄòProgramming in Haskell‚Äô about those which is extremely clear.  there‚Äôs also the functional pearl
05:46:54 <M30W> Right now I'm looking at Real World Haskell.
05:47:14 <M30W> Before I found a wiki through the wiki page on haskell.org for parsec
05:47:20 <M30W> (They are aside)
05:47:39 <bitonic> M30W: I‚Äôd say that the resources I have suggested are clearer
05:48:01 <bitonic> but RWH actually teaches you Parsec
05:48:02 <M30W> bitonic: Mind sending a SHORT link ?
05:48:13 <bitonic> M30W: as in short URL or short content :P?
05:48:25 <M30W> ln-s.org
05:49:03 <bitonic> M30W: anyhow, <http://eprints.nottingham.ac.uk/223/1/pearl.pdf>
05:49:06 <M30W> wrong tld
05:49:07 <M30W> .net *
05:49:13 <bitonic> barely 8 pages
05:49:21 <M30W> Too long D:
05:49:37 <M30W> And pdf meh, thankyou maemo for comming with a pdf reader..
05:49:48 <Nereid> pdf is fine
05:49:49 <bitonic> M30W: <http://ln-s.net/+XE5> there
05:49:52 <Nereid> and who doesn't have a pdf reader?
05:50:31 <M30W> Nereid: Other than pdf.js in firefox and my N900. I don't. :P
05:50:42 <bitonic> M30W: pdf.js actually works decently
05:50:57 <M30W> fdp.js is decent but it's slow xD watch maps render :D
05:51:17 <neutrino> Botje, Nereid: i want to be able to log onto youtube and fetch my playlists - that is, the playlist page for each playlist.
05:51:44 <neutrino> so it needs to be something that can fill out forms and keep a session and cookies.
05:51:55 <`ramses> what's the preffered location for defining Arbitrary instances? It seems ugly to put them alongside the production code, but I get "orphan instance" warnings if I put them in amodule of their own
05:52:19 * M30W loves how maemo has true multitasking :D
05:52:24 <sipa> :k Arbitrary
05:52:25 <lambdabot>     Not in scope: type constructor or class `Arbitrary'
05:52:51 <`ramses> sipa: it's the tpye class from quickcheck to generate random values for data types
05:52:57 <sipa> gotcha
05:54:00 <Nereid> @src ap
05:54:00 <lambdabot> ap = liftM2 id
05:54:03 <Nereid> gee thanks
05:54:09 <Nereid> @src liftM2
05:54:09 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:54:12 <Nereid> urgh
05:54:49 <sipa> @pl \x y -> id x y
05:54:49 <lambdabot> id
05:54:53 <neutrino> Nereid: http-conduit-browser sort of looks like what i'm looking for
05:55:00 <`ramses> @undo  do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:55:00 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
05:55:54 <M30W> :t parse
05:55:55 <lambdabot> Not in scope: `parse'
05:55:59 <M30W> :(
06:08:10 <Nereid> or, Parser a = StateT String [] a
06:08:13 <Nereid> making it obviously a monad.
06:20:48 <hpaste> SamanthaD pasted ‚ÄúBackwards IO‚Äù at http://hpaste.org/81366
06:21:11 <SamanthaD> I simply can not figure out why that code is reading a line and THEN printing "Please inputa string: "
06:21:30 <SamanthaD> replacing putStr with PutStrLn makes it work like it's supposed to...
06:22:18 <k00mi> SamanthaD: you need to flush the output buffer or set it to no buffering
06:22:36 <SamanthaD> k00mi: On the terminal or in haskell?
06:23:04 <k00mi> SamanthaD: in haskell: hFlush stdout
06:23:14 <SamanthaD> k00mi: Thank you!
06:23:22 <k00mi> or: hSetBuffering stdout NoBuffering if you need to do it more often
06:23:54 <SamanthaD> k00mi: Much thanks! I'll just put hSetBuffering at the top of main!
06:25:01 <thekind> Hello
06:25:30 <thekind> I'm a C# .Net web developer
06:25:38 <Taneb> Poor you :P
06:25:42 <thekind> I need some advice for learning haskell
06:25:45 <applicative> hi thekind
06:25:48 <SamanthaD> thekind: Welcome!
06:26:01 <SamanthaD> thekind: what kinda advice?
06:26:20 <thekind> how can I benefit from haskell in web development
06:26:37 <thekind> comparing to .net
06:27:26 <thekind> I need to move from .net but I'm not sure about haskell
06:27:33 <SamanthaD> thekind: Well... not to sound cliche but Haskell will really change the way you think about program structure. But, if you mean where can you USE Haskell in web development you might want to look into the Yesod project.
06:28:12 <opqdonut> snap might be simpler than yesod
06:28:15 <shachaf> Yesod is very different from Haskell.
06:28:31 <Iceland_jack> thekind: If you don't know any Haskell then jumping into web development will possible be tricky, I'm not sure I recommend Haskell for web development anyway
06:28:31 <opqdonut> happstack is okay too, but it lacks some features
06:28:36 <k00mi> thekind: i never did any web dev, but the haskell frameworks claim to provide more safety through haskell's strong type system
06:28:39 <shachaf> They build their own crazy languages "on top of" Haskell. You should know Haskell before using it.
06:29:27 <shachaf> (If you use it at all.)
06:29:34 <applicative> My impression was that yesod has had success with 'beginners'
06:29:41 <thekind> what about deployment and hosting?
06:29:49 <SamanthaD> thekind: I agree with what the other people are saying. You should probably learn Haskell in general before trying to do web things with it.
06:30:22 <thekind> I agree with learning Haskell first before web development
06:30:41 <Lethalman> he wants to know whether it's worth learning haskell for web development, not how to learn haskell for web development :)
06:30:58 <thekind> that is right
06:31:07 <SamanthaD> thekind: To be completely realistic, your biggest benefit from Haskell on the web development front is that you'll really have a feel for how a functional program is structured which will help a LOT when it comes to writing Scala or Javascript and what not.
06:31:42 <SamanthaD> thekind: Haskell is also mighty handy for quickly prototyping algorithms!
06:32:21 <raek> I'm trying out FFI for the first time. Can I use the Word8 type in "foreign import ..." like I can with the types in Foreign.C.Types?
06:32:40 <SamanthaD> thekind: That being said... if you can secure yourself a server that actually supports Snap or Yesod then I think you might find that they offer a lot of performance :3
06:33:00 <end3rW> hello. I'm stuck with Exercise 9 from 20 Intermediate Haskell Problems. Anyone who can point me to a place where I can read up on (->)?
06:33:30 <thekind> so the benefit for learning haskell at web is performance right
06:33:32 <SamanthaD> end3rW: could you link the exercise?
06:33:39 <thekind> and prototyping
06:34:04 <end3rW> SamanthaD: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
06:34:17 <SamanthaD> thekind: Well... it's also much easier, in my opinion, to reason about the correctness of your code when you have purely functional programs.
06:34:37 <end3rW> Misty implementation for ((->) t). Looks like a monad, but I'm beginner anyway
06:36:07 <end3rW> I always thought of functors/monads as "boxes containing specific types", but I cannot abstract it to the function level ((->) t).
06:36:17 <shachaf> end3rW: That's because that's not what they are.
06:36:27 <end3rW> (Sorry for improper use of words, neither Haskell nor English is my native language ;))
06:36:47 <shachaf> It's a terrible analogy that is nevertheless very successful at propagating itself. A virus of sorts.
06:36:48 <thekind> Thanks a lot for the information you provide I really interested talking with you have a nice day
06:36:53 <fmap> @quote monads.*containers
06:36:53 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
06:37:11 <shachaf> By the time its hosts clear the confusion, they've spread the meme to dozens of other people.
06:37:49 <shachaf> Occasionally someone writes a monad tutorial with boxes and arrows and space suits and a paragraph on the back of each one, and we get a little epidemic.
06:38:13 <shachaf> end3rW: Functions are a good example of when the "container" intuition just doesn't work.
06:38:23 <SamanthaD> shachaf: Okay, just to make sure I'm not totally confused can I get a confirmation that functors in Haskell are more or less just containers over which a function can be applied to each component while preserving its structure?
06:38:24 <end3rW> Is there an analogy that fits it better or shouldn't I be searching for an analogy at all?
06:38:43 <shachaf> end3rW: Most analogies don't help.
06:38:52 <shachaf> SamanthaD: Not really.
06:39:03 <shachaf> SamanthaD: You're best off abandoning the "container" idea straight off. :-)
06:39:25 <end3rW> How do I go about understanding ((->) t)?
06:39:36 <applicative> end3rW: if you think of a function in ((->) a ) as a Map with keys in (all of) a, then it's a "container"
06:39:40 <shachaf> end3rW: The best way to get an intuition for what Functor/Monad means is to look at a bunch of concrete examples and then figure out the generalization.
06:39:51 <Nereid> it's true.
06:39:59 <shachaf> applicative: Yes, you can stretch the analogy until it tears and fits the words. But why?
06:40:09 <shachaf> end3rW: Which part of ((->) t) is unclear?
06:40:16 <shachaf> Sometimes people get confused by just the syntax.
06:40:19 <raek> can I assume that Word16 uses the same representation as uint16_t?
06:40:21 <shachaf> So that's the first thing to clear up.
06:40:46 <Taneb> raek, I certainly hope so
06:41:06 <applicative> even is a Bool computation, just like doesDirectory exist; a Bool hides in it ...
06:41:28 <shachaf> Yes, and id contains Ints.
06:41:30 <shachaf> "contains"
06:41:30 <applicative> even is a Bool computation, just like doesDirectoryExist "/"; a Bool hides in it ...
06:41:34 <shachaf> This doesn't help anyone.
06:41:45 <applicative> yes, id contains Int indexed Ints
06:41:57 <raek> I saw this in RWH:   foreign import ccall unsafe "lookup3.h hashword2" hashWord2 :: Ptr Word32 -> CSize -> Ptr Word32 -> Ptr Word32 -> IO ()
06:42:08 <SamanthaD> shachaf: What if I said a functor is a category of objects which are relate in a specific way and over which a function can be applied that will transform it into another category?
06:42:11 <applicative> right, and "return () is an action" which gets "executed"
06:42:46 <end3rW> shachaf: The task is to implement (a -> m b) -> m a -> m b. I fail to understand what even the first part means for ((->) t). A function which expects a value of type a and returns a ((->) b) (a partial function?).
06:43:01 <end3rW> Maybe it's just me missing some basic concepts which I'll have to read up on.
06:43:11 <applicative> substiute ((->) t) for m
06:43:14 <shachaf> end3rW: OK. Do you understand what "((->) a) b" means?
06:43:38 <applicative> (a -> (z -> m)) -> (z -> a) -> (z -> b)
06:43:44 <applicative> (a -> (z -> b)) -> (z -> a) -> (z -> b)
06:43:46 <applicative> rather
06:43:47 <end3rW> shachaf: Function application?
06:44:01 <shachaf> end3rW: In particular, ((->) a) b = a -> b
06:44:07 <shachaf> Just like ((+) 1) 2 = 1 + 2
06:44:17 <shachaf> SamanthaD: If you're trying to use category theory terminology, you're not being very precise. :-)
06:44:43 <shachaf> SamanthaD: I recommend not worrying about the general category theory sense of "functor" for now.
06:44:56 <end3rW> shachaf: Yes, that I understood. Infix form
06:45:01 <end3rW> If I'm not mistaken
06:45:02 <shachaf> end3rW: OK.
06:45:02 <SamanthaD> shachaf: Fine... the functor is the transformation of one class of objects and arrows into another class >.>
06:45:21 <Nereid> end3rW: ok, so in (a -> m b) -> m a -> m b, replace "m" with "(->) t" everywhere
06:45:23 <shachaf> SamanthaD: The Haskell meaning is much more specific.
06:45:30 <Nereid> and remember that (->) t a = t -> a
06:45:30 <applicative> > let grr :: (a -> (z -> b)) -> (z -> a) -> (z -> b); grr op f z = op (f z) z in grr (||) not True
06:45:30 <SamanthaD> shachaf: nifty u_u
06:45:32 <lambdabot>   True
06:45:55 <applicative> > let grr :: (a -> (z -> b)) -> (z -> a) -> (z -> b); grr op f z = op (f z) z in grr (||) not False
06:45:55 <shachaf> SamanthaD: For example a Haskell Functor is a category theory "endofunctor" -- i.e. from a category to itself. But you really shouldn't worry about that.
06:45:56 <lambdabot>   True
06:47:11 <shachaf> end3rW: So your type is (a -> m b) -> m a -> m b
06:47:16 <shachaf> And m is what, here?
06:47:34 <end3rW> m b would be t -> b
06:47:40 <Nereid> yes
06:47:45 <shachaf> Right.
06:47:52 <shachaf> So can you expand the type here?
06:47:54 <end3rW> So it takes a value and returns a function
06:48:01 <end3rW> (the first part, I mean)
06:48:17 <shachaf> Right.
06:48:22 <shachaf> Alternatively, it takes two values. :-)
06:48:29 <end3rW> I have a hard time phrasing this :)
06:48:34 <applicative> end3rW: write out the signature with the instantiation to (a -> ...)
06:48:44 <applicative> it takes three values, see grr above...
06:48:45 <applicative> sort of
06:48:59 <SamanthaD> shachaf: I guess... Though is it right to say that a structure of type class Functor isn't a functor in-and-of-itself in the category theory sense but rather a structure that a functor can transform?
06:49:14 <SamanthaD> shachaf: sorry for pestering you with category theory questions, but it really is helping me understand.
06:49:38 <shachaf> SamanthaD: I think the most correct thing to do if your goal is to learn about Haskell Functors is to forget about category theory functors for a bit. :-)
06:49:47 <shachaf> But if you like:
06:50:04 <shachaf> Let's take Maybe. Maybe is a Functor.
06:50:04 <applicative> SamanthaD: don't worry about shachaf's kill-joy advice ...
06:50:19 <shachaf> That means it turns each type into a different type.
06:50:27 <shachaf> For example, it turns the type Int into the type Maybe Int
06:50:37 <shachaf> It also comes with a thing that turns functions into different functions.
06:50:50 <shachaf> For example, it turns the type (Int -> Char) into the type (Maybe Int -> Maybe Char)
06:50:56 <end3rW> (a -> (t -> b)) -> (t -> a) -> (t -> b). So it takes "a function producing a function returning b from a value a" and another "function returning a" and produces yet another "function returning b".
06:51:12 <SamanthaD> shachaf: Oh... I see. Thank you, that helps!
06:51:29 <shachaf> SamanthaD: The first thing is called Maybe. The second thing is called fmap
06:51:43 <applicative> in the sense in which it transforms Int into Maybe Int it transforms Int -> Char into Maybe (Int -> Char)
06:51:59 <end3rW> Which makes me reading up on (.). Thanks so far
06:51:59 <SamanthaD> shachaf: and [] is a functor because it transforms, say, an Int into [Int]?
06:51:59 <shachaf> applicative: "It also comes with a thing"
06:52:06 <shachaf> applicative: I.e. a different thing.
06:52:10 <shachaf> SamanthaD: Right.
06:52:26 <SamanthaD> shachaf: AWESOME! Thank you a million times!
06:52:30 <shachaf> SamanthaD: These also obey some laws. In particular the laws are: fmap id x = x, and one other one that you get "for" free in Haskell (fmap (f . g) x = fmap f (fmap g x))
06:52:39 <SamanthaD> shachaf: I've been stuck on it for so long!
06:52:41 <applicative> yes, but the proper account shouldn't emphasize the completely irrelevant existence of a type (Int -> Char)
06:53:13 <Nereid> man, defining Parser a = StateT String [] a makes a lot of stuff easy.
06:53:18 <applicative> there can be functors between things that don't have 'exponentials'
06:53:37 <Nereid> well, everything is basically free.
06:53:43 <Nereid> except for satisfy
06:54:27 <applicative> @unmtl StateT String [] Int
06:54:27 <lambdabot> String -> [(Int, String)]
06:55:46 <shachaf> applicative: Yes, but not in Haskell.
06:55:47 <Nereid> :t \f -> state (span f)
06:55:48 <lambdabot> MonadState [a] m => (a -> Bool) -> m [a]
06:55:52 <shachaf> There can be lots of weird functors.
06:56:13 <Nereid> :t isDigit
06:56:14 <lambdabot> Char -> Bool
06:56:23 <Nereid> > runStateT (state . span isDigit) "123.45"
06:56:24 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
06:56:24 <lambdabot>        ...
06:56:32 <Nereid> uh?
06:57:01 <Nereid> > runStateT (state $ span isDigit) "123.45"
06:57:02 <lambdabot>   No instance for (GHC.Show.Show
06:57:02 <lambdabot>                     (m0 ([GHC.Types.Char], [...
06:57:13 <Nereid> > runStateT (state $ span isDigit) "123.45" :: [(String,String)]
06:57:14 <lambdabot>   can't find file: L.hs
06:57:17 <Nereid> > runStateT (state $ span isDigit) "123.45" :: [(String,String)]
06:57:19 <lambdabot>   [("123",".45")]
06:57:28 <Nereid> what a silly thing.
06:57:34 <Nereid> I could have just
06:57:36 <Nereid> well whatever.
06:57:40 <Nereid> think of it as a parser I guess.
06:58:32 <shachaf> @ty runStateT.state
06:58:33 <lambdabot> Monad m => (s -> (a, s)) -> s -> m (a, s)
06:58:58 <shachaf> > (return . span isDigit) "123.45" :: [(String,String)]
06:59:00 <lambdabot>   [("123",".45")]
06:59:22 <shachaf> SamanthaD: But I do encourage you not to think of functors as boxes.
06:59:45 <applicative> SamanthaD: Functors are totally boxes
07:00:25 <shachaf> applicative: Are you trying to be deliberately unhelpful?
07:00:26 <applicative> SamanthaD: you should just get rid of the prejudice that the boxes we find things in already had things in them before we found them
07:00:38 <applicative> shachaf: I thought that was your role
07:01:21 <Nereid> @let satisfy f = get >>= \s -> case s of { t:s' | f t -> put s' >> return t; _ -> mzero }; tok = satisfy . (==)
07:01:24 <lambdabot>  Defined.
07:01:30 <applicative> the explanation of LYAH is as good as it gets; a Functor is something that can be mapped over
07:01:35 <applicative> and this is the 'container analogy'
07:01:36 <shachaf> How about instead of redefining boxes (a word which everyone knows and has a commonly-accepted meaning), we re^H^Hdefine functors (a word that has no intuition associated with it)?
07:01:58 <shachaf> "a Functor is something that can be mapped over" is good. But it's not a container analogy.
07:02:06 <applicative> because we need the intuition of mapping over
07:02:11 <applicative> yes it is shachaf
07:02:21 <applicative> it is exactly the container analogy
07:02:22 <Nereid> > runStateT ((,,) <$> state (span isDigit) <*> tok '.' <*> state (span isDigit)) "123.45blah" :: [((String,Char,String),String)]
07:02:24 <lambdabot>   [(("123",'.',"45"),"blah")]
07:02:43 <applicative> you are opposing the wisdom of absolutely everyone else, completely arbitrarily, it seems
07:02:47 <Nereid> > runStateT ((,,) <$> many (satisfy isDigit) <*> tok '.' <*> many (satisfy isDigit)) "123.45blah" :: [((String,Char,String),String)]
07:02:50 <lambdabot>   [(("123",'.',"45"),"blah"),(("123",'.',"4"),"5blah"),(("123",'.',""),"45bla...
07:02:55 <shachaf> @quote kmc container
07:02:55 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
07:03:05 <Nereid> > runStateT ((,,) <$> many (satisfy isDigit) <*> tok '.' <*> many (satisfy isDigit)) "12.3x" :: [((String,Char,String),String)]
07:03:07 <lambdabot>   [(("12",'.',"3"),"x"),(("12",'.',""),"3x")]
07:03:18 <applicative> yes that's probably where you got the completely ridiculous idea
07:03:38 <applicative> a Functor is what can be mapped over
07:03:41 <shachaf> I got the idea in a separate place but I agree with it.
07:03:49 <applicative> i.e., you go in, get the a's and make them b's
07:03:51 <SamanthaD> applicative, shachaf: Okay... so functors have the property that they can be mapped over and also follow a few rules but the part that actually MAKES THEM FUNCTORS is that they take, say an Int and turn it into an [Int] and it's the turning-into bit that is the functor-y bit, right?!
07:04:25 <shachaf> SamanthaD: Well, all of it "is the functor".
07:04:45 <SamanthaD> *whimpers*
07:04:47 <shachaf> But we typically say that Maybe itself is "a functor", and the other things are just associated with it.
07:05:19 <Dodek> SamanthaD: the point is that to describe the functor, we need to tell how it acts on objects, and how it acts on maps
07:05:21 <SamanthaD> shachaf: The thing is, if we're just talking about "Stuff that can be mapped over" it's not really a functor. It's a category!
07:05:32 <shachaf> SamanthaD: Hmm? I think you're confused.
07:05:35 <Nereid> @let _Cons = prism (uncurry (:)) $ \a -> case a of { [] -> Left []; (x:xs) -> Right (x,xs) }
07:05:37 <lambdabot>  Defined.
07:05:43 <Nereid> shouldn't this be in lens>
07:05:43 <Nereid> ?
07:05:44 <SamanthaD> shachaf: I think that would be a fair assessment...
07:05:48 <shachaf> Nereid: It is.
07:05:51 <Nereid> oh
07:05:58 <shachaf> @ty _Cons
07:05:59 <lambdabot>     Ambiguous occurrence `_Cons'
07:05:59 <lambdabot>     It could refer to either `L._Cons', defined at <local>:6:1
07:05:59 <lambdabot>                           or `Lens._Cons',
07:06:01 <merijn> _head and _tail or something?
07:06:02 <Nereid> haha great.
07:06:04 <shachaf> @undefine
07:06:11 <shachaf> @ty _Cons
07:06:12 <lambdabot> Cons p f s t a b => Overloaded p f s t (a, s) (b, t)
07:06:18 <shachaf> It's overloaded to work with Data.Sequence and such.
07:06:30 <Nereid> well then
07:06:34 <shachaf> SamanthaD: I recommend that you forget about categories for a while if your goal is to learn Haskell, and that you foget about Haskell for a while if your goal is to learn categories.
07:07:05 <Nereid> oh, it has its own damn module :s
07:07:45 <SamanthaD> shachaf: Thanks... I'm still trying to work on learning category theory but I'll go and pretend they're different things for the time being...
07:07:48 <applicative> SamanthaD: if you see how the concept of 'map' applies equally to all of these, there really is nothing else to know:
07:08:25 <applicative> (fmap even (Just 1), fmap even [1], fmap even ("SamanthaD",1))
07:08:35 <applicative> > (fmap even (Just 1), fmap even [1], fmap even ("SamanthaD",1))
07:08:37 <lambdabot>   (Just False,[False],("SamanthaD",False))
07:09:50 <elliott> applicative: I don't think the container analogy is good or wisdom either.
07:10:03 <applicative> everyone agrees that it has limits
07:10:06 <`nand`> > fmap even succ 1
07:10:07 <lambdabot>   True
07:10:09 <applicative> the point is to explain it as well
07:10:18 <SamanthaD> applicative: Thanks... I feel comfortable with the concept of fmap and functors as they're implemented it's just that I'm having trouble relating it to category theory.
07:10:30 <applicative> elliott: or do you deny that [] and Maybe are 'containers' too?
07:10:32 <elliott> Yes, I think its limitation is that it is both incorrect and misleading, so it offers neither precision nor useful intuition.
07:10:52 <applicative> it is not incorrect since everyone but an idiot qualifies it immediately
07:11:07 <applicative> elliott: no, the intuitiion of sameness in
07:11:11 <elliott> Sure, I'll call [] and Maybe containers, though I hesitate to without a definition of "container". So I'll agree some functors are containers. Some functors are Identity, too. An "Identity analogy" for functors would be terrible.
07:11:19 <elliott> (Actually lots of people like analogies along those lines... e.g. tainting.)
07:11:23 <applicative> > (fmap even (Just 1), fmap even [1], fmap even ("SamanthaD",1))
07:11:24 <lambdabot>   (Just False,[False],("SamanthaD",False))
07:11:29 <applicative> is requisite to understanding Haskell
07:11:40 <applicative> so it is neither imprecise nor is it possible to do without it
07:11:45 <shachaf> Those are all good functors.
07:11:52 <Nereid> I forget what I was going to do with _Cons.
07:12:03 <elliott> applicative: I don't have this intuition you speak of, and I think I understand Haskell.
07:12:09 <elliott> Actually I don't even know what intuition you mean.
07:12:09 <applicative> yes they are all good containers though
07:12:16 <shachaf> Yes.
07:12:18 <applicative> elliott: you are just denying the obvious
07:12:25 <shachaf> Is (Cont ()) or (CoYoneda IORef) a good container?
07:12:29 <SamanthaD> could someone give me an example of a functor that ISN'T a container then?
07:12:37 <Taneb> Proxy
07:12:40 <Taneb> IO
07:12:47 <`nand`> (->) r is a perfectly fine container as well
07:12:48 <shachaf> SamanthaD: Do you think of (id :: Int -> Int) as a container of Ints?
07:12:48 <elliott> applicative: I don't find anything you're saying obvious. Why are you insistent that it is after multiple people question it?
07:12:59 <applicative> thanks `nand`
07:13:04 <SamanthaD> shachaf: Oh... that is a good point!
07:13:20 <SamanthaD> shachaf: but you can map over id. I see!
07:13:27 <applicative> elliott: I don't insist on it; it is a received part of the pedagogy of our language that can be explained and justified
07:13:44 <Philippa_> *sigh*. Some of us predate that article, y'know
07:13:46 <shachaf> SamanthaD: Well, you can map over functions.
07:13:49 <elliott> If by "received part of the pedagogy" you mean "some people explain it that way while plenty of others disagree that it's a good idea", I agree.
07:13:55 <applicative> we speak for examlpe of replacing the leaves of a tree with fmap
07:14:01 <elliott> But I don't think appeals to "we've always explained it this way" are very convincing, either.
07:14:04 <applicative> and in a different way with (>>=)
07:14:22 <Philippa_> elliott: especially when we haven't!
07:14:26 <applicative> these are the 'container analogy'
07:14:27 <SamanthaD> Okay, I'm going to go ahead and say "functors are structures that can be mapped over and oftentimes they act like containers!"
07:14:34 * shachaf sighs.
07:14:49 <elliott> applicative: I don't see how what you're saying has anything to do with the container analogy at this point, I'm afraid.
07:15:01 <SamanthaD> I had no idea asking about functors would start a flame war u_u
07:15:13 <Philippa_> SamanthaD: don't worry about it, not your fault
07:15:50 <SamanthaD> Philippa_: Don't get me wrong, I appreciate everyone's enthusiasm about my education!
07:15:56 <Philippa_> sometimes you get existing tensions within a community
07:16:03 * elliott doesn't want to flamewar, just objects to people being painted as unreasonable iconoclasts just because they disagree with a controversial (and IMO misleading) explanation.
07:16:04 <applicative> a container of a's means what you can do something with, with your capacity to do something with a's
07:16:13 <Philippa_> mmm. Sometimes it feels like we need #haskell-bad-pedagogy-meta though
07:16:25 <applicative> elliott: the exact of what you think is occurring is occuring
07:16:32 <Philippa_> applicative: the horse is already dead
07:16:58 <`nand`> arguing over semantics and analogies are the two major pastimes of #haskell
07:17:00 <applicative> Philippa_: no it isn't elliott is still thinking it's me that's shachaf
07:17:28 <elliott> I can't even parse your last three statements.
07:17:39 <Philippa_> applicative: I'm pretty sure elliott is trying to wrap this up
07:17:53 <elliott> Yes, let's drop this.
07:17:56 <Philippa_> I mean, I could be wrong and I'm open to corrections?
07:18:12 <`nand`> I can't parse applicative's last three statements either
07:20:25 <applicative> the first of these three statements was obscure and theoretical and could do with elucidation; the other bore on the ridiculous flaming of elliott
07:20:37 * hackagebot distributed-process 0.4.2 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.4.2 (TimWatson)
07:20:50 <elliott> I don't think I've flamed anyone...
07:21:11 <applicative> I'm sure you don't but you emphatically did
07:21:23 <Philippa_> applicative: It might be better to fill in the first as part of a blog post at this stage
07:21:40 <Philippa_> and let's not start metaflaming
07:22:02 <shachaf> I never metaflame I didn't like.
07:22:06 <shachaf> Hmm, no.
07:22:09 <shachaf> I never metaflame I didn't light.
07:22:43 <`nand`> monoids
07:22:55 <`nand`> how do they work??
07:23:41 <merijn> mempty goes in, value comes out, you can't explain that!
07:24:04 <shachaf> /dev/pty/mempty
07:30:19 <merijn> Do we have #haskell-theoretical-jokes-that-we-can't-tell-in-haskell-'cus-it'd-confuse-the-newbies yet?
07:30:46 <`nand`> #haskell
07:31:47 <elliott> merijn: #haskell-lens
07:32:26 <merijn> elliott: I'm still scared of -lens :p
07:32:42 <shachaf> merijn: Then you're not ready for the PROFUNCTOR JOKES
07:32:48 <shachaf> (btw profunctors jokes = the best jokes on earth)
07:32:59 <merijn> Although I think I finally started to grok things after edwardk's talk, but IndexedTraversal and Prism are still mysteries to me :p
07:33:12 <`nand`> and indexed traversal is a traversal with an index
07:33:16 <elliott> Prisms are the bestest.
07:33:18 <elliott> I love them.
07:33:24 <`nand`> think (i -> a -> f b) -> s -> f t
07:33:26 <shachaf> elliott: They are indeed very easy.
07:33:42 <merijn> `nand`: That seemed obvious, prisms seem scarier, though
07:33:54 <shachaf> merijn: Prisms are to sums what lenses are to products.
07:33:56 <shachaf> For example:
07:33:57 <`nand`> prisms are just the duals of lenses
07:33:59 <`nand`> right?
07:34:06 <shachaf> `nand`: Right.
07:34:12 <shachaf> merijn: data Foo a b = Foo { one :: a, two :: b }
07:34:20 <`nand`> so you get intuition about them for free, from lens
07:34:23 <shachaf> Here, we can make "one" and "two" lenses.
07:34:31 <shachaf> data Bar a b = One a | Two b
07:34:32 <`nand`> .. assuming you have intuition of dualization
07:34:37 <shachaf> Here, we can make "One" and "Two" prisms.
07:34:50 <shachaf> `nand`: I suspect that's not going to help merijn too much.
07:35:00 <`nand`> it was a joke
07:35:04 <shachaf> I know.
07:35:20 <shachaf> Nevertheless.
07:35:29 <shachaf> Take the theoretical-jokes-that-we-can't-tell-in-haskell-'cus-it'd-confuse-the-newbies to #haskell-lens
07:36:01 <shachaf> merijn: So prisms let you do two things: "match" on a constructor, and "construct" a value with it.
07:36:19 <shachaf> (Should I keep going?)
07:36:34 <`nand`> the way I like to think of prisms is as providing two things: a 1-or-0-target traversal, eg. from ‚Äòs‚Äô to ‚Äòa‚Äô; together with a way to construct the reverse, ie. ‚Äòa -> s‚Äô
07:36:44 <merijn> shachaf: Yeah, I figured they were the advanced cousins of partial lenses in data-lens
07:36:59 <burbul> Is there somewhere I can find a list of  GHC extensions and  what they do?  . There is a section in the GHC manual, but it doesn't seem to be nearly complete...
07:37:00 <elliott> They're partial lenses you can put back in.
07:37:03 <shachaf> merijn: Right. They're partial lenses that also let you construct a value.
07:37:07 <elliott> You can maybe take an "a" out of Bar a b.
07:37:10 <merijn> shachaf: I can see the lens returning Maybe a if you're lensing into Foo a, but not sure how you'd set it
07:37:11 <elliott> But you can always put an "a" in.
07:37:16 <elliott> One :: a -> Bar a b, after all.
07:37:25 <elliott> merijn: You know about traversals, right?
07:37:30 <elliott> You can use a traversal as a partial lens.
07:37:32 <merijn> elliott: ish
07:37:34 <shachaf> merijn: For Foo the story is different.
07:37:36 <elliott> If it's just a traversal that always returns 0 or 1 values.
07:38:02 <shachaf> merijn: "one" in Foo gives you two operations: get :: Foo a b -> a, and set :: Foo a b -> a' -> Foo a' b
07:38:02 <elliott> trav f (One a) = One <$> f a; trav _ (Two b) = pure (Two b)
07:38:17 <elliott> A prism is that -- a zero-or-one-result traversal -- that also gives you a way to construct a One from an a.
07:38:18 <`nand`> over l f . review l = review l . f -- is a law, right?
07:38:23 <merijn> right
07:38:45 <shachaf> `nand`: I think you can get that from the laws.
07:38:54 <burbul> wait, I'm being stupid -- never mind me.
07:39:28 <shachaf> merijn: But let's talk about either lenses or prisms. :-)
07:40:53 <merijn> shachaf: I hope I've grokked the lens part, at least, so prisms is the more interesting bit
07:41:39 <shachaf> OK, let's see.
07:42:11 <shachaf> > (_Left . _Right) # 5
07:42:13 <lambdabot>   Left (Right 5)
07:42:28 <shachaf> > preview (_Left . _Right) (Left (Right "hi"))
07:42:30 <lambdabot>   Just "hi"
07:42:32 <shachaf> > preview (_Left . _Right) (Left (Left "hi"))
07:42:33 <`nand`> :t (#)
07:42:35 <lambdabot>   Nothing
07:42:35 <lambdabot> parse error on input `)'
07:43:05 <shachaf> merijn: preview takes a prism and uses it to "match" all the way into the nested pattern and see whether there's a value there.
07:43:16 <shachaf> Hmm, I should give an example of a prism that you can't just pattern-match with.
07:43:38 <shachaf> > preview (_Left . prefixed "name: ") (Left "name: merijn")
07:43:41 <lambdabot>   Just "merijn"
07:43:48 <shachaf> > preview (_Left . prefixed "name: ") (Left "channel: #haskell")
07:43:50 <lambdabot>   Nothing
07:43:54 <shachaf> > preview (_Left . prefixed "name: ") (Right 14)
07:43:56 <lambdabot>   Nothing
07:44:07 <merijn> right
07:44:11 <shachaf> So this lets us "match" on a string that starts with a certain prefix.
07:44:20 <shachaf> And we can use it in reverse:
07:44:24 <aristid> yay for prisms.
07:44:30 <shachaf> > (_Left . prefixed "name: ") # "merijn"
07:44:32 <lambdabot>   Left "name: merijn"
07:44:43 <`nand`> > case Left "name: merijn" of Left ('n':'a':'m':'e':':':' ':xs) -> Just xs; _ -> Nothing
07:44:45 <lambdabot>   Just "merijn"
07:44:45 <aristid> those parens should not be necessary IMHO.
07:44:46 <shachaf> So it's like first-class patterns, sort of.
07:45:10 <aristid> > _Left # prefixed "name: " # "merijn"
07:45:11 <lambdabot>   Couldn't match expected type `Control.Lens.Review.AReview
07:45:11 <lambdabot>                  ...
07:45:15 <shachaf> aristid: It's just lambdabot.
07:45:25 <shachaf> I @let-defined # instead of using the real version.
07:45:32 <aristid> shachaf: ah
07:45:47 <merijn> :t (#)
07:45:49 <lambdabot> parse error on input `)'
07:45:53 <aristid> :t ( # )
07:45:55 <lambdabot> MonadReader b m => AReview s t a b -> m t
07:45:59 <aristid> merijn: MAGICHASH MAGICHASH
07:46:00 <merijn> ah
07:46:17 <shachaf> It's confusing it with UnboxedTuple, actually.
07:46:20 <`nand`> :t ( + )
07:46:21 <lambdabot> Num a => a -> a -> a
07:46:25 <`nand`> oh wow, I never realized that works
07:47:05 <aristid> shachaf: oh, but magichash sounds better
07:47:25 <aristid> :t let nand = undefined in ( `nand` )
07:47:27 <lambdabot> parse error on input `)'
07:47:31 <aristid> hmm.
07:47:39 <aristid> :t let nand = undefined in (`nand`)
07:47:40 <lambdabot> parse error on input `)'
07:47:46 <aristid> *shrug*
07:47:53 <aleksandar22> any ideas what to use for game programming 2d?
07:49:13 <elliott> aristid: (`foo`) isn't a thing you can ever do.
07:49:24 <`nand`> @let plus = (+); infixl 6 `plus`
07:49:26 <lambdabot>  Defined.
07:49:29 <`nand`> > 3 * 4 `plus` 5
07:49:30 <aristid> elliott: why not it would be funny
07:49:31 <lambdabot>   17
07:49:33 <`nand`> > 3 * 4 + 5
07:49:35 <lambdabot>   17
07:49:36 <`nand`> so that works
07:49:56 <shachaf> elliott: Sadly.
07:50:38 * hackagebot distributed-process-simplelocalnet 0.2.0.9 - Simple zero-configuration backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.0.9 (TimWatson)
08:02:18 <fubaz> Hi! Let's say that i have: data Mammal = Dog Foo | Cat. I can specify function eg. Mammal -> a but is there any way to "narrow down" the function to only accept (Dog -> a)?
08:02:25 <sm> hey all, what's the standard way to be platform-line-ending-independent when reading and parsing a text file ?
08:02:45 <shachaf> fubaz: Not really. You would need to make a separate type.
08:02:47 <sm> is there a readFile that translates them for me ?
08:02:50 <byorgey> fubaz: the short answer is no.
08:03:00 <sipa> fubaz: no, but why would you want to? you can make function Foo -> a
08:03:01 <shachaf> sm: I think readFile does that.
08:03:12 <sipa> fubaz: as Foo embodies everything specific for Dogs
08:03:38 <shachaf> sipa: Well, that's (potentially) less type-safety.
08:03:48 <fubaz> shachaf, byorgey, ok thanks :)
08:04:02 <fubaz> sipa, because of what shachaf said
08:04:18 <sm> shachaf: ah! http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#g:25 thx
08:04:20 <fubaz> thanks anyway :)
08:04:37 <Philippa_> fubaz: Dog is a data constructor rather than a type. You *could* do it with GADTs, but right now you probably don't want to learn them just yet
08:04:52 <sipa> right, you can wrap it again of course... newtype DogData = DogData Foo; data Mammal = Dog DogData | Cat CatData; and then have a DogData -> a
08:05:33 <merijn> fubaz: Or, you could write "Mammal -> Maybe a" and just return Nothing in the Cat case
08:05:38 <shachaf> Philippa_: In some languages (with subtyping) this sort of thing would be straightforward, so it's a reasonable request.
08:06:18 <Philippa_> shachaf: yeah, didn't say otherwise
08:06:24 <shachaf> Sure.
08:06:25 <sm> I'm reading a DOS text file on unix right now, so it's not selecting the right translation mode. I guess I need to sniff line endings and set the appropriate mode
08:06:30 <Philippa_> was just explaining why it's syntactically nonsense in Haskell
08:06:43 <fubaz> sipa, well that's definately a possibility :) thanks
08:06:46 <shachaf> sm: It selects line endings by platform but I think you can set them yourself.
08:07:14 <fubaz> philippa, yeah, i know, but i was wondering if there was some way to achieve similar stuff :) thanks
08:07:44 <merijn> fubaz: There is, but it's a bit involved and complicated if you're just starting, so best avoid it for now
08:08:32 <sm> oh universalNewlineMode - perfect
08:08:57 <merijn> i.e. Philippa_'s mention of GADTs together with phantom types would let you do something close to this, but that requires first learning GADTs and using phantom types, which is a bit involved for someone just starting :)
08:10:24 <fubaz> merijn, ok :) i'll keep away from it then for now. thanks for help. it's good to know though that there isn't some standard "haskell way" of doing that thing so I'll try to achieve what I'm doing in different way
08:10:38 * hackagebot tls 1.1.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.1.2 (VincentHanquez)
08:12:36 <sipa> well, if anything, i doubt using GADTs should be considered a 'standard haskell way' ...
08:13:04 <`nand`> maybe not for this problem, but for others, surely
08:13:19 <shachaf> GADTs are not standard Haskell. :-)
08:13:26 <`nand`> heh, that too
08:14:23 <`nand`> glasgow haskell, then? :)
08:14:25 <sipa> shachaf: that's what i mean
08:15:12 * `nand` likes to forget interpreters exist which don't implement umpteen languages extensions
08:15:52 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù pasted ‚Äúblaze-html markup‚Äù at http://hpaste.org/81369
08:16:50 <merijn> GADTs *should* be a "standard haskell way", GADTs are awesome!
08:17:31 <mroman> Is there going to be a new haskell report soon?
08:18:32 <Athas> merijn: well, look at the differences between Haskell 98 and Haskell 2010.  Consider that took twelve years, then predict the estimated time until adoption of GADTs. :-)
08:18:51 <shachaf> Athas: That's not how it works.
08:19:14 <shachaf> The rate of improvement of the Haskell standard is unpredictable. Between whenever1.4cameout and 1998 it was actually a negative improvement.
08:19:51 <Athas> What changed?
08:20:13 <Philippa_> shachaf: easy to say that now. Less so in '98
08:20:29 <Philippa_> (or with 1998's hardware and implementation techniques)
08:20:45 <shachaf> Philippa_: Sure.
08:20:50 <shachaf> It was not an entirely serious remark.
08:21:01 <Athas> (Neither was mine, for that matter.)
08:21:18 <mm_freak> merijn: GADTs or ADTs with GADT syntax?
08:21:28 <shachaf> Anyway, now there's ostensibly a process for making regular changes to the report.
08:21:29 <Athas> Still, I predict that a Vulcan will be part of the Haskell committee that approves GADTs in the standard.
08:21:36 <hpaste> stepcut annotated ‚Äúblaze-html markup‚Äù with ‚Äúblaze-html markup (annotation)‚Äù at http://hpaste.org/81369#a81370
08:21:43 <merijn> mm_freak: GADTs, of course
08:21:49 <Philippa_> sure. We get a lot more snark about language evolution than we do honest discussion of the hows and whys though - people forget the pressures at the time, especially for 60s and 70s designs
08:22:00 <shachaf> Except Malcolm Wallace is too busy for Haskell'?
08:22:30 <mikey__> hi?
08:22:35 <Clint> no
08:22:47 <mikey__> yes?
08:24:15 <mroman> no
08:24:49 <neutrino> lol
08:25:56 <mm_freak> merijn: keep in mind that that automatically pulls in some other extensions as well
08:26:01 <mm_freak> like ExistentialQuantification
08:26:28 <mm_freak> since i don't like the way existentials work in GHC, i'm not particularly fond of getting them into the standard
08:26:46 <Taneb> What file extension do Hamlet templates like?
08:26:58 <mm_freak> Taneb: .hamlet
08:27:02 <Taneb> Thanks
08:27:49 <Taneb> Does a emacs hamlet syntax highlighter exist?
08:35:19 <Ste1891> Hi.  Does anyone know where I can find the documentation for bindings to the win32 functions 'defWindowProc' and 'translateMessage'?  I've looked in Hackage in /package/win32 and can't find them.
08:35:39 * hackagebot http-conduit 1.8.7.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.7.1 (MichaelSnoyman)
08:47:31 <Taslem> @pl f = putStr $ concat $ map (\x -> if x `mod` 15 == 0 then "fizzbuzz\n" else if x `mod` 5 == 0 then "buzz\n" else if x `mod` 3 == 0 then "fizz\n" else show x ++ "\n") [1..100]
08:47:33 <lambdabot> f = putStr (ap (flip if' "fizzbuzz\n" . (0 ==) . (`mod` 15)) (ap (flip if' "buzz\n" . (0 ==) . (`mod` 5)) (ap (flip if' "fizz\n" . (0 ==) . (`mod` 3)) ((++ "\n") . show))) =<< [1..100])
08:50:42 <parcs> > unless True [1..10]
08:50:44 <lambdabot>   No instance for (GHC.Num.Num ())
08:50:44 <lambdabot>    arising from the literal `1'
08:50:44 <lambdabot>  Possible ...
08:51:06 <parcs> > [1..10] <$ guard False
08:51:08 <lambdabot>   No instance for (GHC.Show.Show (f0 [t0]))
08:51:08 <lambdabot>    arising from a use of `M871124...
08:56:14 <dflemstr> does someone by any chance have a registerised build of ghc 7.6.1 for armv6l in a build tree i.e. not as a stripped package?
08:57:35 <simpson> Hm. So the atom package only targets C as a backend?
08:58:08 <pzuraq> anyone know a good channel for talking about like
08:58:13 <pzuraq> basic computer engineering?
08:58:21 <pzuraq> like Ripple Carry Adders and such
09:13:57 <`nand`> #haskell-blah ?
09:22:33 <bgamari> I think that vector's filterM is too lazy
09:23:12 <bgamari> I'm not sure how, but it definitely stack overflows on large inputs
09:23:25 <bgamari> even just V.filterM (const $ return True) v
09:25:25 <maki`> can't binding dsl declare a function with stdcall calling convention?
09:25:33 <parcs> bgamari: how large?
09:27:03 <parcs> bgamari: i don't think it's a problem with vector's filterM, but filterM in general: try running 'main = print =<< fmap length (filterM (const $ return True) [1..1000000])'
09:27:33 <bgamari> parcs, 10^7 elements, for instances
09:27:35 <bgamari> instance*
09:28:08 <hpaste> ‚ÄúBen Gamari‚Äù pasted ‚ÄúfilterM stack overflow‚Äù at http://hpaste.org/81372
09:28:09 <geekosaur> maki`, https://bitbucket.org/mauricio/bindings-dsl/wiki/WindowsLibrariesCallingConventions
09:28:17 <bgamari> parcs, ^
09:29:13 <parcs> bgamari: try using lazy State
09:29:13 <bgamari> parcs, ahh, it actually appears to be specific to State
09:29:31 <BlindRadish> :D
09:29:36 <bgamari> parcs, alright, yep. that did it
09:30:02 <bgamari> parcs, Would you mind explaining what exactly was going on?
09:30:57 <bgamari> I apparently still lack an intuition for when to use strict and lazy state
09:31:11 <parcs> bgamari: in a monad that is strict in >>= monad functions like filterM and mapM that are not tail recursive build up a large call stack that is prone to stack overflows
09:31:44 <parcs> bgamari: .Lazy is lazy in its >>= definition
09:33:22 <bgamari> parcs, It would be very nice if there were some language in the transformers/mtl documentation describing in what sense the .Strict and .Lazy monads are strict and lazy
09:33:32 <bgamari> and in what context the two behaviors are useful
09:34:37 <parcs> bgamari: the docs devote a full sentence to describing the sense in which they are strict and lazy, actually
09:34:48 <parcs> .Lazy: "In this version, sequencing of computations is lazy." .Strict: "In this version, sequencing of computations is strict."
09:35:13 <bgamari> well, that explains it all, I suppose ;)
09:35:33 <parcs> yeah that's not nearly enough. and i'd also like to know when to use Strict vs Lazy
09:36:57 <parcs> you should definitely always perform strict modifications of your state, but that is orthogonal to the strictness of sequencing of computations
09:37:17 <parcs> (ok, maybe not always)
09:38:51 <parcs> the Lazy versions are more compositional and may have a better memory profile. i'm not sure what the advantages are of the Strict versions.
09:39:21 <bgamari> parcs, This is an important distinction which was lost on me in the past
09:39:58 <bgamari> parcs, Thanks!
09:40:08 <parcs> np :)
09:42:17 <maki`> geekosaur thanks
09:43:08 <k00mi> doesn't IO use strict state to guarantee correct ordering?
09:43:31 <parcs> yeah, unless you use unsafeInterleaveIO
09:43:56 <shachaf> IO doesn't really use State at all.
09:44:43 * geekosaur wonders if that was misplaced pedanticism
09:44:55 * applicative doesn't
09:44:58 <k00mi> oh so that's what unsafeInterleaveIO does
09:45:21 <k00mi> so all the RealWorld talk is wrong shachaf?
09:45:23 <Taneb> It uses a state-ish thing with unboxed tuples
09:45:58 <shachaf> k00mi: RealWorld is an implementation detail in GHC that has very little to do with Control.Monad.State
09:46:06 <elliott> k00mi: The RealWorld thing is a bit misleading.
09:46:24 <elliott> It's not a value that actually exists at runtime; it's a trick GHC uses to ensure ordering, but it's not really very related to the State monad.
09:46:25 <geekosaur> yeh, it doesn't use the State monad, but arguably "use strict state" does not imply use of the State monad, just of a state-like mecnahnism
09:46:43 <elliott> Well, there's no state-like mechanism in GHC's implementation of IO.
09:46:46 <elliott> It doesn't pass any state at all.
09:46:47 <shachaf> geekosaur: The IO = State World misconception is common enough that I feel like I should clarify it.
09:46:53 <shachaf> There's no actual state, though.
09:47:02 <shachaf> It's a token that gets compiled into nothing.
09:47:08 * elliott is running a program to predict what shachaf will say and then say it before him, clearly.
09:47:08 <Saizan> parcs: if sequencing is strict i can propagate that strictness to the state modifications quite easily, it's more complicated otherwise
09:47:17 <fragamus> I'm trying to decide whether a certain list should go in my state or if I should create a tuple and add it to what I already "return"
09:47:28 <geekosaur> right, it's using the sequential ordering with a baton that disappears after it's done its job
09:49:09 <gspr> Suppose I do a lot of FFI, and use functions  a -> IO CInt  from a C library, each of which can return non-zero to indicate an error (then errno is set accordingly). What's a common way to gracefully handle such errors? Currently I just use error whenever such a function returns non-zero, but obviously that's horrible.
09:49:14 <Philippa_> fragamus: if it behaves in a state-like manner and you're willing to pay the overhead for accessing it that way when you do, put it in state
09:49:26 <Philippa_> fewer opportunities to mess up that way
09:49:38 <Philippa_> (the less you access/update it, the more important it is for it to live there!)
09:49:39 <gspr> (By "from a C library" I mean I call into a C library from Haskell, not the other way around)
09:50:27 <geekosaur> seen http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Foreign-Marshal-Error.html ?
09:50:46 <gspr> geekosaur: Yikes, don't know how I missed that! Thanks!
09:51:27 <k00mi> elliott, shachaf: so i should just forget about State RealWorld?
09:51:28 <geekosaur> this actually looks simpler than the stuff I was looking for; there'ss ome stuff used by the runtime bindings to libc that throws on -1
09:51:49 <gspr> geekosaur: It's just what I needed, so thanks :)
09:51:59 <shachaf> k00mi: That depends. Are you trying to understand voodoo implementation details of GHC?
09:52:22 <k00mi> shachaf: not at all
09:52:27 <shachaf> If so you should pay careful attention to it (for example, it uses a type called State#, but in a completely different way from how State is used).
09:52:52 <shachaf> If you just want to understand the general idea of how IO works in Haskell (as opposed to GHC's implementation of it), you're best off forgetting about State RealWorld, yes.
09:53:11 <k00mi> alright
09:53:12 <gspr> geekosaur: Looking along the same lines, I now also found http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Error.html . It too looks nice.
09:53:42 <geekosaur> right, that's the one I was really looking for
09:53:46 <`nand`> unless of course you're programming with acme-realworld; which offers getWorld :: IO RealWorld and restoreWorld :: RealWorld -> IO ()
09:54:03 <`nand`> very useful for creaing time loops and overcoming apocalypses
09:54:48 <kate_r> hi
09:54:49 <kate_r> in logic, is an intended interpretation of a theory a model of the theory?
09:55:01 <epta> How can I add hashable isntance for Set Int?
09:55:09 <gspr> geekosaur: Do you know if getErrno behaves well with regards to Haskell threads, by the way? The docs say that getErrno "gets the current value of errno in the current thread"; what happens if a Haskell thread is migrated from one OS thread to another after errno is set, but before getErrno accesses it?
09:55:36 <geekosaur> no idea, tbh
09:56:13 <gspr> OK, maybe it's a question suited for SO
09:56:35 <geekosaur> I would hope that thread state migrates; thread safety consideratiions suggest that it should be pulling the C errno immediately and stashing it in Haskell-thread-local storage for later retrieval
09:56:47 <gspr> geekosaur: That would be reasonable, yes
09:56:49 <geekosaur> but I'm not that familiar with the threaded runtime
09:58:08 <parcs> Saizan: how can you make a strict modify if sequencing is Lazy?
10:01:28 <Saizan> parcs: i actually don't know
10:01:57 <geekosaur> gspr: actually I suspect it does exactly that, because the threaded runtime uses a bound thread for FFI calls that aren't marked unsafe, so those *always* migrate
10:02:42 <gspr> geekosaur: Right. If I understand you correctly, what you're saying is if this weren't the case, getErrno would be useless most of the time?
10:03:07 <geekosaur> ("unsafe" there means roughly the opposite of what you might think:  "call it unsafely instead of assuming it needs to be properly wrapped and that it might call back into Haskell"
10:03:17 <gspr> yeah, I know about unsafe
10:03:19 <geekosaur> yeh
10:03:25 <elliott> )
10:03:47 <gspr> OK, thanks for the input. It sounds reasonable. I'll still post it on SO, in case others have the same question
10:03:51 <geekosaur> since unbound threads don't have *any* access to thread state (see discussion of forkOS in Control.Concurrent)
10:03:58 <bgamari> What purpose does the ~ character serve in ~(a,s) <- m
10:04:24 <geekosaur> bgamari, it makes the pattern lazy:  it's not checked immediately but only when you try to use a variable bound by it
10:04:32 <bgamari> ahh
10:04:50 <bgamari> Not sure how I've gone this far without running into this
10:05:13 <geekosaur> it's not actually used that often; most times whe you use a pattern, you actually intend to impose strictness immediately
10:05:43 <geekosaur> and the cases where you don't are largely covered byt he fact that let bindings are all default lazy anyway (as if you'd used ~)
10:06:40 <Shapeshifter> Hi. I'm not sure here; If I were to write a haskell application that uses cairo, do people need to have the haskell bindings installed to run the binary or do they only need the cairo libs?
10:07:03 <srhb> Neither if it's statically linked.
10:07:26 <srhb> (If you're distributing the binary)
10:07:35 <Shapeshifter> srhb: and if it's dynamically linked? Are the haskell bindings necessary?
10:08:06 <srhb> No.
10:08:09 <geekosaur> Shapeshifter, the default on most platforms is still static linking of Haskell libraries, so only the C dynamic libraries are needed.  if you use a dynamic Haskell library then you would need to distribute the shared object somehow; at the moment I don't think we have a nice way to deal with that?
10:08:14 <srhb> Uh, at least I think only the cairo libs are needed then.
10:08:23 <Shapeshifter> I see
10:08:34 <Lethalman> srhb, the cairo bindings are needed if the executable is dynamically linked, no?
10:08:48 <srhb> the _bindings_? Hm. Maybe I've misunderstood.
10:08:49 <Lethalman> H*cairo*.so
10:09:38 <Shapeshifter> So what is the preferred drawing lib for 2D vector drawing for haskell? I'm trying out cairo but it pulls in so many libs (the gtk stuff). Maybe there's something haskell-specific? I just want to write a screen lock application for now.
10:10:55 <Shapeshifter> I realize there are a bunch of them listed on the haskellwiki, but does anyone have specific suggestions?
10:11:49 <crdueck> q
10:11:54 <Taneb> diagrams, possibly, Shapeshifter
10:12:27 <byorgey> Shapeshifter: if you really want to write an application that draws on the screen then you are going to need some kind of gui library anyway
10:12:44 <srhb> GL bindings might have smaller dependencies.
10:12:48 <Lethalman> Shapeshifter, maybe Graphics.Gloss
10:13:05 <srhb> If that's the criterium you want to go by, and then yes, Gloss is great.
10:13:09 <Iceland_jack> Is there a way of specifying a member of a type class without neccessarily giving any arguments? for example getting the type of ‚Äúreturn‚Äù assuming that ‚ÄúMonad m ‚áí m‚Äù refers to [], Either, ...?
10:13:45 <Shapeshifter> thanks
10:13:45 <byorgey> Iceland_jack: unfortunately not
10:14:05 <byorgey> there's no way to specify individual type arguments or give "partial" type signatures and have the compiler infer the rest
10:14:11 <Iceland_jack> Hm, oh well‚Ä¶
10:14:33 <Iceland_jack> That's too bad, sometimes I want to see what the type signature looks like for a given monad ‚Äòm‚Äô
10:15:04 <Iceland_jack> especially for monads of more complicated kinds
10:15:14 <`nand`> hmm
10:15:23 <`nand`> :t return `asTypeIn` ([]>>=)
10:15:24 <aavogt> @ty  return `asTypeOf` (undefined :: a -> [a])
10:15:25 <lambdabot> a -> [a]
10:15:26 <lambdabot> a -> [a]
10:15:30 <Iceland_jack> aah!
10:15:48 <`nand`> aavogt: of course you could just write (return :: a -> [a])
10:16:28 <Iceland_jack> I knew of asTypeOf but not about asTypeIn‚Ä¶
10:16:43 <Iceland_jack> I don't see it on Hoogle
10:17:44 <Lethalman> Iceland_jack, it's defined in lambdabot
10:17:56 <Iceland_jack> a `asTypeIn` f = a where _ = f a?
10:18:07 <Lethalman> yes
10:18:36 <Iceland_jack> how would it work for (>>=)?
10:19:22 <hpaste> jonkri pasted ‚Äúscion dependency problem‚Äù at http://hpaste.org/81376
10:19:57 <jonkri> i'm trying to install scion (see above) with the latest version of the haskell platform, but encounter some dependency problems. any ideas?
10:21:00 <Iceland_jack> for example if I wanted to find the types of return and bind for Either
10:21:33 <Iceland_jack> :t return `asTypeIn` (Right>>=)
10:21:34 <lambdabot> Either a b -> b -> Either a b
10:22:14 <fmap> @ty (>>=) `asAppliedTo` Left undefined
10:22:15 <lambdabot> Either a1 a -> (a -> Either a1 b) -> Either a1 b
10:22:47 <Iceland_jack> I'm guessing asAppliedTo is another lambdabot-defined function‚Ä¶
10:22:56 <fmap> yes
10:23:11 <Iceland_jack> Would there be any value in having this capability built into GHCi?
10:23:15 <fmap> well, that's just undefined with fancy type
10:23:22 <monochrom> jonkri: it may be safe to edit scion.cabal to not depend on network-bytestring altogether. network-bytestring is now folded into network, true since a while ago, definitely true for current haskell platform
10:23:54 <Cale> undefined?
10:23:57 <Iceland_jack> @src asAppliedTo
10:23:57 <lambdabot> Source not found. I feel much better now.
10:24:07 <monochrom> it is also a reason why network-bytestring has not been updated for new base
10:24:17 <fmap> Cale: well, implementation doesn't matter, I mean
10:24:28 <jonkri> thanks monochrom
10:24:29 <Cale> a `asTypeIn` f = a where _ = f a
10:24:48 <Cale> f `asAppliedTo` x = f `asTypeIn` (\f -> f x)
10:25:04 <Iceland_jack> thanks Cale :)
10:25:42 * hackagebot expression-parser 0.1 - Generalization of parsec's expression parser.  http://hackage.haskell.org/package/expression-parser-0.1 (SebastiaanVisser)
10:27:05 <Iceland_jack> When I first started out with type classes I sometimes had trouble realizing the actual type for a given instance, something like: :t (>>=) :: (Monad m ~ Either) ‚áí Either a1 a -> (a -> Either a1 b) -> Either a1 b would've been helpful :)
10:27:10 <Iceland_jack> Thanks!
10:27:32 <fragamus> hey is there a way do remove an element by index from a list?    Data.Lens? How???
10:28:07 <fragamus> @hoogle i->[a]->[a]
10:28:07 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:28:07 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
10:28:07 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
10:28:40 <byorgey> fragamus: lens can't delete things like that
10:29:12 <byorgey> fragamus: it's not a very common operation.  You'll have to write one yourself using splitAt.
10:29:19 <copumpkin> it can delete things from a Map!
10:29:31 <byorgey> and you should also consider whether you are using the correct data structure
10:29:42 <byorgey> lists end up getting used for many things they should not
10:30:00 <fragamus> yeah well that goes for gerbils too
10:30:21 <byorgey> fragamus: if there are gerbils involved, you should DEFINITELY not be using lists
10:30:21 <hpaste> jonkri pasted ‚Äúscion dependency problem‚Äù at http://hpaste.org/81377
10:30:35 <jonkri> what about uniplate and ghc-syb?
10:31:41 <bergmark> jonkri: i think scion is very outdated
10:31:49 <byorgey> copumpkin: that's cheating!  because it's really just altering values in a logical (infinite) Map k (Maybe a)  structure, right?
10:31:57 <bergmark> which is too bad :( it was an awesome package
10:32:27 <jonkri> bergmark: the only reason that i want to use it is to have the features it provides to emacs - http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Scion
10:32:32 <copumpkin> byorgey: yeah, if you assume that that infinite map doesn't have a get function that adds another level of Maybe :)
10:32:36 <byorgey> I think buildwrapper is the modern alternative to scion, right?
10:33:13 <byorgey> copumpkin: well, right, you have to assume there is a mapping for every value of k
10:33:46 <copumpkin> yep
10:33:50 <bergmark> byorgey: cool! haven't seen it
10:34:53 <shachaf> This GHC bug is great.
10:35:09 <shachaf> It's taking the "read" on the command line arguments all the way into the inner loop.
10:35:21 <shachaf> Unless you have an SCC somewhere.
10:36:56 <Shapeshifter> Mh. It's a shame Gloss doesn't have antialiasing...
10:37:23 <fragamus> @pl (\(a,b)->a++b) $ splitAt i xs & _2 %~ tail
10:37:24 <lambdabot> (line 1, column 33):
10:37:24 <lambdabot> unexpected "_"
10:37:24 <lambdabot> expecting space or simple term
10:38:07 <fragamus> well anyhow thats how to delete an item by index
10:45:09 <gspr> Is it in general OK to use foreign ccall unsafe if you know that the function called will return "quickly" (whatever that may mean) and not call back into Haskell?
10:45:47 <monochrom> I say yes
10:46:25 <monochrom> but I don't do it until speed requirements press for it
10:46:36 <gspr> monochrom: Yeah, that's probably sensible.
10:47:31 <shachaf> Is it in general OK to use unsafeCoerce to write my Functor instance if I just can't figure out any other way to make the type checker accept it?
10:47:39 <shachaf> I mean, it kind-checks, and unsafeCoerce always makes things faster.
10:47:57 * shachaf is only joking.
10:48:18 <shachaf> (only)
10:49:44 <noteventime> Is it possible to use GeneralizedNewtypeDeriving for higer order types where one of the parameters has to be constrained (i.e. instances like Num a => Num (Wrapper a))?
10:54:00 * `nand` uses unsafeCoerce :: a -> a -- as a more optimized ‚Äòid‚Äô
10:54:46 <lpsmith> I'm getting the following error when I try to run cabal haddock:
10:54:46 <lpsmith> During interactive linking, GHCi couldn't find the following symbol:
10:54:46 <lpsmith>   postgresqlzmsimplezm0zi3zi0zi0_DatabaseziPostgreSQLziSimpleziSqlQQ_sql_closure
10:54:54 <lpsmith> Any ideas?
10:55:23 <lpsmith> I've never gotten this error before,  and everything compiled ok.
10:56:04 <Igloo> lpsmith: Is that module missing from the exposed-modules list in the .cabal file?
10:57:00 <lpsmith> Igloo, I just confirmed that Database.PostgreSQL.Simple.SqlQQ is still in the exposed-modules list in the .cabal file.
11:15:42 * hackagebot diagrams-contrib 0.6.0.3 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.6.0.3 (BrentYorgey)
11:25:19 <Ste1891> Hi.  I need to coerce x -> Word32 to x -> Int32, but there doesn't seem to be any toInt 32 function (like an equivalent of toInteger).  Anyone know how I should do this?
11:25:37 <Taneb> fromIntegral
11:25:53 <Taneb> > fromIntegral (180 :: Word32) :: Int32
11:25:54 <lambdabot>   180
11:26:10 <lispy> fromIntegral trips everyone up the first time they need it.
11:26:16 <lispy> I wish it was easier to discover
11:26:24 <lispy> ?hoogle Word32 -> Int32
11:26:24 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:26:24 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
11:26:24 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
11:26:53 <lpsmith> :t fromIntegral
11:26:54 <lambdabot> (Integral a, Num b) => a -> b
11:26:55 <opensourcegeek> hello haskellers
11:27:00 <Taneb> Hello
11:27:02 <lpsmith> :-/
11:27:07 <Ste1891> Well, looks like it tripped me up.  I'll give that a try.  Thanks.
11:27:28 <opensourcegeek> I would love to say fellow haskellers, but I'm still a newbie :(
11:28:10 <opensourcegeek> got a question on printing inside recursion
11:28:36 * Clint squints.
11:28:49 <lispy> Ste1891: Yeah, it's normal to be stumped by that one. Sorry it's not better documented.
11:29:01 <lispy> opensourcegeek: welcome!
11:29:02 <opensourcegeek> add :: Int -> Int add n = n + 1   printRecursively :: Int -> IO Int printRecursively n = print n >>         if n < 99             then printRecursively $ add n             else return n
11:29:05 <opensourcegeek> oops
11:29:17 <opensourcegeek> sorry the new lines disappeared
11:29:24 <`ramses> @where hpaste
11:29:25 <lambdabot> http://hpaste.org/
11:29:29 <`ramses> opensourcegeek: ^^
11:29:51 <lispy> opensourcegeek: what is the question?
11:30:37 <basdirks> when is list better than Seq?
11:30:43 * hackagebot esqueleto 1.0.2 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.0.2 (FelipeLessa)
11:30:44 <opensourcegeek> ok I tried a function with printRecursively
11:30:48 <opensourcegeek> it works
11:30:53 <basdirks> (and yes I read the Seq docs)
11:31:32 <basdirks> ((read is a big word))
11:31:40 <opensourcegeek> but when I tried to use it recursively to construct new squares it doesn't work
11:31:59 <byorgey> basdirks: if you just want something simple that you are going to iterate through from beginning to end, and only add things to the beginning
11:32:37 <basdirks> clear enough, thanks
11:32:39 <byorgey> opensourcegeek: "doesn't work" is too vague.  Can you paste the code you tried on hpaste.org, along with the error message (or a description of what you expected it to do & what it does instead)?
11:33:34 <opensourcegeek> sorry I'm trying to post the code with newlines this time
11:34:00 <byorgey> opensourcegeek: OK, but please don't paste it in here
11:34:20 <byorgey> in any case no apologies necessary =)
11:35:39 <opensourcegeek> byorgey: ok - do you want me to email the code?
11:35:50 <opensourcegeek> anyway - I can explain the code I think
11:35:58 <lispy> opensourcegeek: use http://hpaste.org
11:36:17 <lispy> You put the code there and then give us the url
11:37:19 <hpaste> opensourcegeek pasted ‚Äúprinting inside recursion‚Äù at http://hpaste.org/81383
11:37:50 <opensourcegeek> lispy: thats a really nice tool
11:38:35 <byorgey> opensourcegeek: can you also past something about what you mean when you say it "doesn't work"?  Just click "Annotate" on that page and add some information
11:38:44 <byorgey> i.e. if you get an error message you can paste the error message there
11:38:45 <opensourcegeek> what does ">>" symbol mean by the way?
11:39:00 <byorgey> opensourcegeek: intuitively you can think of it as "do this, then do that"
11:39:00 <opensourcegeek> byorgey: sure will do now
11:39:21 <byorgey> opensourcegeek: but more formally it is a method of the Monad type class, so what it means depends on what monad you are using
11:39:32 <byorgey> but with the IO monad it means what I said
11:39:55 <SoleSoul> Hi!, I'm implementing the game of life in Haskell as a way to learn more of language. I don't want an answer, only guidance. I have a clear idea of how to do it in C++ and two dimentional array but I don't know what is the right way to represent the data in Haskell. I think I need random access for that so lists won't be good. Am I wrong?
11:40:41 <lispy> SoleSoul: sounds about right
11:41:08 <SoleSoul> so is there a random access data structure like array in C++?
11:41:16 <Ralith> yes, it's called an Array
11:41:17 <Ralith> :p
11:41:18 <lispy> SoleSoul: We have arrays and Data.Vector
11:41:26 <SoleSoul> :) array
11:41:27 <srhb> SoleSoul: You are right, but you might want to do it with lists anyway if you're only just starting out with Haskell.
11:41:36 <lispy> SoleSoul: if you want a simple multidimensional arra, use Array.
11:42:10 <hpaste> opensourcegeek annotated ‚Äúprinting inside recursion‚Äù with ‚Äúprinting inside recursion (annotation)‚Äù at http://hpaste.org/81383#a81384
11:42:12 <SoleSoul> srhb: why use lists? random access would make the task much simpler as I see it
11:42:15 <lispy> SoleSoul: Data.Vector can usually get better performance but you'll have to make a wrapper around it to simulate the multidimensional stuff.
11:42:32 <hpaste> opensourcegeek annotated ‚Äúprinting inside recursion‚Äù with ‚Äúprinting inside recursion (annotation) (annotation)‚Äù at http://hpaste.org/81383#a81385
11:42:45 <lispy> SoleSoul: lists have (!!) which can simulate random access (it's linear but it does fetch the element)
11:42:56 <lispy> :t (!)
11:42:58 <lambdabot> Ix i => Array i e -> i -> e
11:43:00 <SoleSoul> lispy: good to know. thanks. Although I have no problem in using div and mod to emulate multidimentions
11:43:02 <lispy> :t (!!)
11:43:03 <lambdabot> [a] -> Int -> a
11:43:25 <srhb> SoleSoul: If you're comfortable (or ready!) to use alternative data structures, have a go. I don't know where you are in the process of learning Haskell. :)
11:43:57 <lispy> SoleSoul: with the Array type i is the index type and e is the element type. So yo want something like Array (Int,Int) Cell
11:43:58 <opensourcegeek> so as I put in the hpaste, I get same square printed to console
11:44:03 <SoleSoul> lispy: that would be a bad solution since for each cell I would need 9 times O(n) and that's quite much :)
11:44:09 <fluffynukeit> Hi.  I used >>= to construct an IO action that included hGetContents.  I then reformulated it using >=> and it suddenly uses 10 times less memory, which is the amount I was expecting.  Why would >=> be so much more efficient? In what way does it differ from >>=?
11:44:26 <srhb> fluffynukeit: Show your code, please
11:44:37 <byorgey> opensourcegeek: if createSquareInsideGiven really returns a different square then that ought to work.
11:45:21 <byorgey> opensourcegeek: you will have to paste ALL of your code (including definitions for Square, createSquareInsideGiven, createSquareWithBottomLeftPointAsSeed, etc.) otherwise it's impossible to know what is wrong
11:45:21 <hpaste> fluffynukeit pasted ‚Äú>=> more efficient than >>=‚Äù at http://hpaste.org/81386
11:45:34 <SoleSoul> srhb: I want to learn alternative data types. I have been using Haskell for some time but for very specific stuff and I want to learn some general programming skills. I have read lyah and a few monads articles.
11:45:51 <srhb> SoleSoul: Great, ignore me then. :-)
11:46:00 <SoleSoul> heheh. Thank you!
11:46:18 <hpaste> opensourcegeek annotated ‚Äúprinting inside recursion‚Äù with ‚Äúprinting inside recursion (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/81383#a81387
11:46:22 <SoleSoul> lispy: I'll try array. Thanks!
11:46:44 <srhb> fluffynukeit: And the other one?
11:47:25 <opensourcegeek> byorgey: two secs I will paste Squares module as well
11:47:39 <lispy> SoleSoul: an important consideration with arrays in haskell is what capabalities do you need? We have immutable arrays, mutable arrays, st arrays, and all manner of stuff
11:47:45 <typoclass> SoleSoul: go easy on the monad articles. in my opinion, you're going to learn a great deal more from writing a little code
11:47:57 <lispy> SoleSoul: http://www.haskell.org/haskellwiki/Modern_array_libraries
11:48:15 <hpaste> fluffynukeit pasted ‚Äú>=> more efficient than >>=, pt 2‚Äù at http://hpaste.org/81388
11:48:20 <typoclass> SoleSoul: "a line of code written is better than a dozen monad tutorials read" my grandma used to say
11:48:30 <Rotaerk> interesting grandma
11:48:31 <fragamus> lol
11:48:39 <SoleSoul> typoclass: you have some serious grandma there
11:48:46 <SoleSoul> thanks for the advice
11:48:52 <lispy> SoleSoul: IIRC, life is a stencil type algorithm so you probably want two arrays: An immutable one that you read from, and a new immutable one that you construct from the old one.
11:49:13 <fragamus> man I hate marshaling graphs in haskell
11:49:14 <srhb> fluffynukeit: You've done way more than rewrite wrt. >>= and >=>
11:49:32 <SoleSoul> lispy: I'm going to use a pure function which gets the current state and returns the next state
11:49:35 <lispy> fragamus: because you can't observe sharing?
11:49:52 <hpaste> opensourcegeek annotated ‚Äúprinting inside recursion‚Äù with ‚Äúprinting inside recursion (annotation) (annotation) (annotation) (annotation)‚Äù at http://hpaste.org/81383#a81389
11:50:20 <SoleSoul> lispy: I don't know yet if I need mutable or immutable arrays. I'll see when I read about them
11:50:27 <opensourcegeek> byorgey: got the code in there
11:50:29 <fragamus> lispy: not sure what that means, but I need GC to be working when parts of the graph become disconnected
11:50:54 <fluffynukeit> srhb: in what way? seems to me aside from the `seq` call and the partial application, the only difference is do notation, which desugars to >>=, no?
11:50:55 * lispy wants to tell chrisdone that hpaste should group "(annotation)" into "(annotation)√óN" where N is the number of annotations
11:51:06 <fragamus> so I don't like to keep lists of stuff that would keep it from getting collected
11:51:21 <typoclass> fluffynukeit: your case certainly sounds interesting. i have no clue at all, but i'd first suspect bytestring (instead of >>=) to be funky
11:51:37 <opensourcegeek> my doubts were with my type declaration - I wasn't sure what I have declared is definitely right.
11:52:13 <lispy> fragamus: I'm not following you. What do you mean when you say, "I need GC to be working"? Do you mean, you want to collect the garbage on the Haskell side as you send over bits of the graph?
11:52:37 <fluffynukeit> typoclass: what I suspect is that hGetContents is not reading the bytes on demand, but instead reading until the end of the file.
11:53:14 <Rotaerk> anyone here use Sublime Text for haskell development in windows?
11:53:18 <Rotaerk> if so how do you like it?
11:53:46 <fragamus> lispy: My graph is constantly changing, and If I keep a separate data structure to observe it, then some stuff that should get collected might not get collected
11:53:52 <lispy> ?tell chrisdone t'would be spiffy if hpaste chould group "(annotation) (annotation)" into "(annotation)√ó2" (and apply this transformation inductively)
11:53:52 <lambdabot> Consider it noted.
11:53:54 <SoleSoul> lispy: (I'm still trying to figure out what does "stencil" mean, maybe I'll leave that)
11:54:12 <Rotaerk> and is leksah any good or does it feel too immature to be useful?
11:54:34 <SoleSoul> Rotaerk: I use sublime and I like it
11:54:42 <fluffynukeit> I use leksah and think it's ok.  Not thoroguhlt impressed but useful
11:54:44 <typoclass> fluffynukeit: i wonder if that seq makes any difference
11:54:47 <SoleSoul> on Linux but it's the same
11:54:52 <Rotaerk> k
11:54:58 <lispy> SoleSoul: did you already find this? http://en.wikipedia.org/wiki/Stencil_code
11:55:13 <SoleSoul> no, I didn't
11:55:15 <SoleSoul> thanks
11:55:25 <SoleSoul> scary math? :)
11:55:31 <lispy> fragamus: Hmm...I've never tried to do that and it does sound tricky to get right.
11:55:50 <fluffynukeit> typoclass: I added seq because without it, my code would try to run operations on the file after the handle was closed.  It's true I don't need that seq using the >=> composition
11:56:16 <opensourcegeek> http://hpaste.org/81383#a81389
11:56:23 * typoclass scratches his head
11:56:30 <lispy> Rotaerk: on windows I have gvim/emacs24 installed. I'm happy with them. I tried leksah once. It does seem to be growing a lot still. My biggest complaint is that it's hard to install from source. Have you looked at eclipseFP?
11:56:30 <fragamus> lispy: well man, it sucks and not well
11:56:59 <fluffynukeit> typoclass: I don't get it either.  I'm not familiar with kleisli arrows or how their behavior differs from bind.  That's kind of what I'm trying to learn here
11:57:35 <fluffynukeit> typosclass: bind allows inspection of intermediate results, so that changes how things are evaluated? iono
11:57:42 <SoleSoul> Sublime is great as an editor and it can run small haskell sources with "ctrl+b"
11:57:45 <Rotaerk> lispy: nope haven't tried eclipse since like... freshman year of college, and used it for java
11:58:10 <lispy> Rotaerk: maybe I should ask it this way, What editor would you normally use?
11:58:46 <Rotaerk> lispy, well I don't usually use a text editor except for quick fixes and edits, for which the crappy windows notepad suffices
11:58:49 <k00mi> SoleSoul: a better algorithm for life is to keep track of the living cells in a Set, it's also nicer to do with pure datastructures
11:59:05 <Rotaerk> coding in the past has been done in C++, C#, F#, for which I used Visual Studio
11:59:19 <lispy> SoleSoul: stencils are conceptually simple so don't let the math fool you. You just have a window over an immutable array and you do some computation based on that neighborhood. Sounds like the game of life to me.
11:59:20 <SoleSoul> k00mi: without arrays at all, right?
11:59:27 <k00mi> yes
11:59:41 <srhb> SoleSoul: The idea being "why track empty cells"
11:59:51 <SoleSoul> yeah, nice idea
11:59:55 <fluffynukeit> typoclass, srhb: anyway, thanks for taking a look guys
12:00:07 <srhb> fluffynukeit: I second typoclass' confusion I'm afraid.
12:00:15 <srhb> fluffynukeit: I too would suspect ByteString weirdness.
12:00:15 <lispy> Rotaerk: ah, there have been at least two efforts to make Haskell plugins for visual studio (look up visual haskell) but I think both of them are effectively dead unless you have access to an old version of visual studio.
12:00:17 <k00mi> stencils are also great for game of life, there are some slides floating around that actually use game of life as an example for Repa's stencil capabilities
12:00:20 <SoleSoul> I'll have to think about the performance of both
12:00:25 <Rotaerk> ah
12:00:52 <Rotaerk> yea I'm not really interested in any dead efforts; also I'm not particularly tied to visual studio
12:00:53 <SoleSoul> I was thinking of a way to eliminate the need to check the surroundings of a cell with arrays
12:01:09 <Rotaerk> I'm just not particularly interested in the popular solutions for haskell dev:  vim and emacs
12:01:32 <SoleSoul> Rotaerk: try Sublime as you wanted. It's painless
12:01:36 <opensourcegeek> what are the usual tools to debug haskell?
12:01:42 <Rotaerk> k cool
12:01:42 <fragamus> man I miss pointers
12:01:43 <lispy> SoleSoul: game of life is a great way to meet your goal of learning more haskell. There is the sort of naive approach with arrays, the set based approach mentioned by k00mi, the stencil repa approach, and there is also a comonadic way you can learn :)
12:01:50 <byorgey> opensourcegeek: that Square that keeps being printed has all its corners at (12,12)
12:02:03 <SoleSoul> lispy: comonadic?
12:02:05 <byorgey> opensourcegeek: I would expect createSquareInsideGiven  to return the same square for that
12:02:18 <SoleSoul> lispy: never heard of him :)
12:02:23 <typoclass> fluffynukeit: i'm in no way knowledgeable, but as i understood it the "kleisli" stuff really doesn't matter, >=> is really just a convenience variant of >>= and could be interchanged easily. i *think* the difference must be about sharing
12:02:25 <lispy> SoleSoul: yeah, save that one for last as it requires learning the most theory.
12:02:39 <byorgey> opensourcegeek: also it seems your checkSquareSideIsNotEqualToZero must not be working right
12:02:47 <SoleSoul> lispy: I think I'll keep your last message and try them one by one
12:02:56 <lispy> SoleSoul: a co-monad is the dual of a monad. So it helps to learn what a monad is first (maybe you already know).
12:03:20 <opensourcegeek> byorgey: thanks will check the function in ghci
12:03:23 <shachaf> Sometimes "co"things are simpler than things!
12:03:42 <lispy> SoleSoul: when you get to that point, read this article: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
12:03:44 <typoclass> shachaf: but sometimes also cosimpler
12:03:44 <srhb> Cue: "I love co-things. They are so easy!"
12:03:45 <SoleSoul> lispy: I consider myself "someone who have learned monads quite a few times". I don't know if I can say that I know them
12:03:51 <lispy> SoleSoul: and read sigfpe's other articles too :)
12:04:34 <Philippa_> lispy: some comonads are easier than some monads
12:04:58 <shachaf> Void is pretty easy.
12:05:07 <shachaf> Er, Void1
12:05:12 <Philippa_> and really, I'm not sure the duality helps me all that much in working out what cobind is really up to
12:05:21 <Philippa_> (or cojoin, if we're doing it that way)
12:05:57 <shachaf> @ty conjoined
12:05:57 <opensourcegeek> byorgey: looks like both functions are working in ghci
12:05:58 <lambdabot> Conjoined p => (p ~ (->) => q (a -> b) r) -> q (p a b) r -> q (p a b) r
12:06:01 <lispy> SoleSoul: I think you'll find that while haskell has a nice clean syntax that feels very approachable, the rabbit hole goes very deep.
12:06:18 <opensourcegeek> I can put that code as well in annotation
12:06:31 <lispy> (I think that's why smart people learn haskell and stick with it, you can keep learning new things by using it)
12:07:09 <SoleSoul> lispy: someone just thought way too much when he designed this language
12:07:23 <srhb> Or just enough, some might say.
12:07:27 <SoleSoul> but it's frustrating and exciting in the same time
12:08:08 <Lethalman> .oO(conp is harder than np :P)
12:08:47 <Philippa_> SoleSoul: the language design itself is pretty simple, especially compared to a monster like C++
12:08:57 <lispy> Now, back to where I left off last night. I want my haskell code to run on .NET (natively, not via a bridge). I don't seem to have a lot of options. This makes me sad.
12:09:00 <Philippa_> a lot of thinking's gone into the extensions though
12:09:11 <SoleSoul> Philippa_: but the game of life in C++ is so easy, at least a simple version of it
12:09:26 <Lethalman> SoleSoul, that doesn't mean c++ is easy
12:09:46 <Philippa_> SoleSoul: a simple version isn't that hard in Haskell either
12:09:50 <SoleSoul> Lethalman: didn't say the whole language is easy. I say that it's easier to create simple stuff with it
12:10:07 <SoleSoul> Philippa_: for me it is for now. That's why I want to do it
12:10:08 <larryg> is there a function that returns True if xs is a sublist of ys?
12:10:16 <Philippa_> *nod*
12:10:18 <Lethalman> SoleSoul, your argument was about the language design :)
12:10:19 <fragamus> Jesus tells us to love everyone, even the C++ people
12:10:20 <Philippa_> learning experiences are good, yes
12:10:33 <Philippa_> (I find Haskell makes many things simple that are a PITMFA in C++!)
12:10:40 <Philippa_> (and that's me being polite about C++)
12:10:42 <SoleSoul> and vice versa
12:10:59 <SoleSoul> like a while loop in the IO monad (for a beginner)
12:11:10 <YayMe`> lispy: What is the 'theory' of category theory? It's not all this monad/functor/applicative/monoid/comonad/monadplus stuff is it? I've presumed that stuff is.. haskell stuff (other than monad which is based on the kleisli triple)
12:11:14 <monochrom> haskell syntax is not just nice and clean. it is uniform. new haskellers are still surprised that "where" works for every =, not just = at the top level. this shows you how other languages have long ruined our expectations by inflicting irregularity on us
12:11:19 <Philippa_> for that value of beginner, just about everything in C++ is hard too
12:12:00 <lispy> YayMe`: I'm still learning CT so I'm not sure.
12:12:06 <YayMe`> monochrom: I hate it when I'm irregular. You're telling me C did that to me?
12:12:14 <lispy> heh
12:12:24 <monochrom> oh screw C, doesn't even allow nested function definitions
12:12:28 <lispy> ?remember YayMe`  monochrom: I hate it when I'm irregular. You're telling me C did that to me?
12:12:28 <lambdabot> Nice!
12:13:16 <monochrom> although, I sympathize that they didn't want to spend time supporting it back then
12:13:20 <YayMe`> lispy: so you're not sure if the typeclassopedia is covering category theory or just haskell
12:13:28 <lispy> YayMe`: I think what we consider useful CT-wise is considered a bit pedestrian and simple by the cat. theorists
12:13:37 <YayMe`> monochrom: didn't lisp come before C? lisp supported it
12:14:04 <monochrom> it took more effort back then
12:14:08 <lispy> lisp has evolved drammatically from its first version. I don't know what the pre-C era lisp was like.
12:14:32 <SoleSoul> Lethalman: Just to finish what we were saying, maybe it sounded like that but I was joking. I consider myself an almost beginner so I don't dare challenging any design yet :)
12:14:37 <Philippa_> lispy: like most engineers' maths is by most mathematicians
12:14:48 <monochrom> but yes a language invented after 1990 has no excuse. it takes little effort today
12:15:24 <SoleSoul> lispy: do you use lisp?
12:15:30 <YayMe`> lispy: I don't see how it could have been based on lambda calculus without lexical closures, that's kind of what makes lisp, I would figure that's always been so
12:15:51 <lispy> Philippa_: that's probably true. I've heard physicists don't use much beyond second order things in calculus. But when I was learning calculus we had to understand nth order derivatives and such.
12:16:02 <Hafydd> monochrom: GNU C allows nested functions as an extension.
12:16:08 <Lethalman> SoleSoul, I believe some design of something can be judged from a beginner perspective
12:16:16 <Hafydd> And I'm sure you enjoy many of GHC's extensions to the core language.
12:16:21 <lispy> SoleSoul: I used common lisp and elisp a lot when I started using freenode. Then I discovered Haskell and I've been here ever since :)
12:16:29 <larryg> how do I check if "bar" is a part of "foobarfoo"
12:16:46 <lispy> larryg: isInfixOf
12:16:48 <YayMe`> lispy: I frankly find it creepy that there are brains out there processing all of the typeclassopedia stuff as to be 'pedestrian'
12:16:48 <kennyd> @hoogle "[a] -> [a] -> Bool"
12:16:48 <lambdabot> Parse error:
12:16:48 <lambdabot>   "[a] -> [a] -> Bool"
12:16:48 <lambdabot>   ^
12:16:55 <kennyd> @hoogle [a] -> [a] -> Bool
12:16:55 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
12:16:55 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
12:16:55 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
12:17:26 <larryg> thanks
12:17:57 <SoleSoul> lispy: I started to learn Haskell and then I saw the beauty of lisp so I started to learn it but then I saw that Haskell feels better for me so I came back. I still want to learn a bit of lisp just so I would know what it is like to think in the lisp way.
12:18:17 <monochrom> Hafydd: talking about GNU C, have you seen this? hehehe: https://plus.google.com/u/0/102208456519922110915/posts/DZsZ6mvA4T6
12:18:20 <lispy> larryg: I don't think that algorithm is very fast though. You can probably get better performance if you use a regexp library (I don't know if performance matters to you) or even better use Boyer-Moore string matching
12:18:55 <larryg> lispy really? I would have guessed regex would be slowet
12:19:00 <lispy> SoleSoul: lisp is great for many things, but the lack of static types is what killed it for me.
12:19:01 <larryg> slower
12:19:19 <lispy> larryg: Good point. I haven't benchmarked it.
12:19:30 <lispy> larryg: Often times though, they have optimizations for static string searches
12:19:48 <opensourcegeek> byorgey: thanks for looking into the code, the problem is the data set I start with, it soon reaches 12,12 as you had mentioned and it doesn't move further... I need to check why that's happening
12:20:07 <mauke> monochrom: that's what you get for writing code with UB
12:20:36 <monochrom> sorry, what is UB?
12:20:41 <mauke> undefined behavior
12:20:43 <Hafydd> Hahaha.
12:20:44 * hackagebot singletons 0.8.5 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.8.5 (RichardEisenberg)
12:20:46 <monochrom> OK!
12:20:57 <mauke> nasal demons, etc
12:21:27 <YayMe`> larryg: parseAllOf "foobarfoo" $ (manyTill anyChar $ string "bar") *> string "bar"
12:21:30 <mauke> the correct solution would have been printf("%d\n", INT_MAX); or printf("%u\n", ~0u);
12:21:32 <YayMe`> or something like that
12:22:03 <Iceland_jack> hey [Dima] (:
12:22:10 <YayMe`> lispy: I've frankly found myself thinking anytime I want to use regexp, attoparsec is clearer, easier, and just as quick to put together
12:22:30 <lispy> mauke: what is the UB about that program?
12:22:36 <lispy> (I'm not seeing it)
12:22:42 <mauke> lispy: signed integer overflow
12:23:03 <lispy> mauke: ah
12:23:20 <mauke> YayMe`: how would you write parseLine ((=~ "^# (CONFIG_[[:word:]]+) is not set$") -> [_, c] : _) = ... using attoparsec?
12:23:28 <larryg> :t parseAllOf
12:23:30 <lambdabot> Not in scope: `parseAllOf'
12:23:45 <YayMe`> mauke: I have no idea what that syntax is, maybe if I knew what it said I could tell you
12:23:58 <mauke> it's Haskell :-)
12:24:00 <mauke> which part is unclear?
12:24:15 <YayMe`> oh, I don't know lenses
12:24:21 <mauke> me neither
12:24:29 <srhb> It's not a lens, it's the overloaded =~ matching operator
12:24:31 <larryg> YayMe`: do you generally prefer it over parsec?
12:24:33 <srhb> Or whatever we call it
12:24:33 <lispy> =~ is a regexp thing
12:24:40 <YayMe`> oh
12:25:04 <YayMe`> well I have no idea what that string of jabber does mauke, sorry the category is weak with this one I suppose
12:25:11 <srhb> It's incredibly opaque, so don't worry about it. :P
12:25:15 <mauke> ... category?
12:25:29 <lispy> mauke: my the category be with you
12:25:32 <lispy> may*
12:25:37 <srhb> The deal is something like "thing to match =~ regex :: type to return"
12:25:44 <mauke> for the record, I've never used lenses (except implicitly maybe) and I don't know category theory
12:26:08 <srhb> And supposedly the extreme overloading makes it return What You Want (tm)
12:26:12 <typoclass> YayMe`: it makes a certain fixed string is present at the start, and a certain other string is present at the end, and in between there's one or more letters
12:26:17 <lispy> [[:word:]] is a regexp "macro" that matches things between "word boundary" characters
12:26:23 <YayMe`> larryg: I don't know why to use parsec, attoparsec is identical in usability, identical in poorly documentedness, but much faster
12:26:24 <mauke> lispy: no
12:26:30 <lispy> mauke: no?
12:26:36 <mauke> lispy: it's a character class equivalent to [a-zA-Z0-9_]
12:26:41 <merijn> srhb: With the downside that it's like a genie, if you're not very precise what you ask for might not be what you want ;)
12:26:43 <YayMe`> oh
12:26:59 <typoclass> YayMe`: sorry, s/makes/makes sure/
12:27:06 <srhb> merijn: Yes, What You Want (tm) tends to be magical and fallible. :P
12:27:32 <lispy> mauke: shows how often I use regexps :)
12:28:00 <mauke> it's a pseudo-posix extension to match \w in perl-style regexes
12:28:15 <YayMe`> mauke: anyBetween "foo" "foo" where anyBetween start end = start *> anyTill end
12:28:39 <lispy> mauke: so that thing matches likes that don't look like "# CONFIG_foo is not set\n" ?
12:28:40 <YayMe`> oh and where anyTill = manyTill anyChar
12:28:41 <mauke> YayMe`: that is both wrong and incomplete
12:29:05 <mauke> lispy: no, it matches strings of the form "# CONFIG_FOO is not set"
12:29:14 <mauke> and extracts the CONFIG_FOO bit
12:29:22 <lispy> oh, ^ is an anchor not negation?
12:29:25 <mauke> yes
12:29:27 <geekosaur> yes
12:29:34 <geekosaur> and $ anchors the other end
12:29:35 <mauke> regexes don't really have negation
12:29:39 <typoclass> YayMe`: thanks, good tip, that really only needs the "any char" changed into the alphanumeric stuff that was required
12:29:58 <YayMe`> mauke: string "# " *> manyTill anyChar $ string "is not set"
12:30:03 <lispy> mauke: I think the thing I was thinking of might be something like [^A-Z]
12:30:10 <mauke> YayMe`: that's a type error
12:30:14 <YayMe`> ah
12:30:20 <YayMe`> well I'm not that sharp
12:30:20 <mauke> lispy: that's set complement
12:30:23 <YayMe`> so neener neener
12:30:33 <elliott> mauke: [[:word:]] isn't equivalent to [a-zA-Z0-9_], is it?
12:30:33 <mauke> lispy: i.e. it's still a positive match (but written in a negative way)
12:30:38 <elliott> I thought it respects Unicode properly.
12:30:45 <teneen> why are the instances of each type not listed in this module? http://www.haskell.org/ghc/docs/7.0.4/html/libraries/ghc-prim-0.2.0.0/GHC-Types.html
12:30:46 <mauke> elliott: depends on your regex library!
12:30:56 <elliott> assuming a non-broken one :P
12:31:00 <YayMe`> mauke: how is that a type error?
12:31:03 <teneen> 	why are the instances of each type not listed in this module? http://www.haskell.org/ghc/docs/7.0.4/html/libraries/ghc-prim-0.2.0.0/GHC-Types.html
12:31:11 <YayMe`> mauke: It looks right to me...
12:31:12 <mauke> YayMe`: $ has really low precedence
12:31:17 <byorgey> teneen: because that module does not import any type classes
12:31:22 <lispy> teneen: the instances might be listed where the type classes are defined-
12:31:27 <YayMe`> mauke: Oh, just need parens, then it's doing the right thing, no?
12:31:32 <byorgey> teneen: check the Prelude instead
12:31:42 <byorgey> which re-exports those types along with a bunch of type classes
12:31:48 <lispy> teneen: It's probably better/easier for prim things if you use :info in ghci
12:31:52 <mauke> YayMe`: no, 'anyChar' is wrong and you forgot the CONFIG_ part
12:31:58 <mauke> YayMe`: and the rest of the code
12:32:08 <teneen> byorgey, lispy: ok thanks!
12:32:25 <YayMe`> mauke: why is anyChar wrong? you want anything after config_ (I thought you wanted just the whole config_ part
12:32:27 <lpsmith> Igloo, I've tracked down the offending commit that's breaking haddock
12:32:54 <Igloo> lpsmith: I didn't know haddock was broken
12:33:03 <teneen> Do Int8, Int16 etc. have anything to do with the type Int?
12:33:05 <mauke> YayMe`: no, I don't want anything
12:33:10 <mauke> YayMe`: I only want word characters
12:34:02 <larryg> are packages on hackage review by someone before they are allowed?
12:34:07 <YayMe`> how is this not give you what you want: string "# CONFIG_" *> manyTill anyChar (string "is not set")
12:34:09 * larryg reviewed
12:34:12 <YayMe`> wth are "word characters" ?
12:34:18 <Igloo> larryg: no
12:34:32 <lpsmith> Igloo, same problem that I was having earlier today,  regarding the haddock/ghci interactive link error
12:34:48 <mauke> <mauke> lispy: it's a character class equivalent to [a-zA-Z0-9_]
12:35:06 <YayMe`> oh
12:35:10 <lpsmith> Just curious if I should try to minimize the problem more or if I can just submit a bug on the two git commits
12:36:18 <srhb> mauke: Isn't - in there?
12:36:28 <mauke> srhb: no
12:36:36 <srhb> How odd.
12:36:48 <mauke> it's letters, numbers, and underscore
12:37:09 <srhb> Old standards are weird. :P
12:37:09 <mauke> the exact definition of "letters" and "numbers" may depend on your regex library, locale, and match options
12:37:16 <srhb> Yes. Sigh.
12:37:21 <mauke> ... what standards?
12:37:26 <srhb> Indeed.
12:38:05 <tieTYT2> I think I just created length with this implementation: foldl (\x y -> x + 1) 0 [2,4..100]
12:38:25 <mauke> tieTYT2: yes
12:38:31 <YayMe`> mauke: so wordChar c = satisfy (c >= '0' && c <= '9') || (c >= 'a' && c <='z') || (c >= 'A' && c <= 'Z')
12:38:43 <tieTYT2> I noticed it wouldn't let me pass in (+1) as a function, I had to use a lambda.
12:38:46 <typoclass> YayMe`: thanks for your solution by the way. it's more clear than the regex, and gives better error reporting
12:39:04 <srhb> tieTYT2: (+1) does not take the right number of arguments
12:39:06 <YayMe`> typoclass: Oh? What did I solve? heh
12:39:08 <mauke> YayMe`: you forgot parens there
12:39:15 <tieTYT2> srhb: ok, that's what I figured
12:39:20 <otters> why does -XCPP break multiline strings?
12:39:30 <lpsmith> hmm, let me update cabal-install,  maybe the problem is there
12:39:41 <tieTYT2> thanks for the help
12:40:32 <YayMe`> mauke: ah right. I still think if someone knew what was in your head it should be clearer and as easy to write it using attoparsec compared to what you did, presuming they know attoparsec, or do you think it's easier to write it your way?
12:41:02 <srhb> > foldl (const (+1)) 0 [1..20] -- tieTYT2
12:41:04 <lambdabot>   21
12:41:06 <mauke> wordChar = satisfy (\c -> any (flip inRange c) [('0', '9'), ('a', 'z'), ('A', 'Z')]
12:41:11 <mauke> )
12:41:20 <srhb> hohum.
12:41:24 <mauke> YayMe`: wait, we're not done yet!
12:41:33 <mauke> YayMe`: we still have to replace the 'parseLine ...' line
12:41:44 <YayMe`> eh?
12:41:45 <srhb> Well, almost. :P
12:41:59 <mauke> YayMe`: everything up to this point was just building a parser
12:42:04 <mauke> we still have to run it
12:42:31 <mauke> oh, and make sure it returns the CONFIG_FOO bit
12:43:24 <YayMe`> mauke: oh
12:43:34 <YayMe`> that's <*>
12:43:40 <YayMe`> instead of *>
12:43:48 <mauke> and a few other changes
12:45:01 <mauke> "attoparsec is clearer, easier, and just as quick to put together"  <- I think we've already disproved that
12:45:40 <earthy> as quick to put together aswhat?
12:45:44 * hackagebot vty 4.7.2 - A simple terminal UI library  http://hackage.haskell.org/package/vty-4.7.2 (CoreyOConnor)
12:45:47 <mauke> regexes
12:45:49 <earthy> attoparsec is good in m experience
12:46:13 <YayMe`> case (parseOnly . many1) thatParser "stuff to parse" of Left err -> print err .. Right xs -> print xs
12:46:37 <YayMe`> mauke: I think the just as quick is based on me having any idea what your crazy parser did
12:46:49 <mauke> why many1?
12:46:51 <YayMe`> mauke: there's surely no argueing the clearer part
12:46:56 <mauke> yes, there is
12:47:06 <typoclass> mauke: i think you've only proved so far that you'll always find some reason why you disagree with every statement from everyone
12:47:12 <mauke> unless you want to argue that the regex is clearer, which it is
12:47:24 <srhb> Objective fact!
12:47:53 <mauke> typoclass: I'm not actually disagreeing with YayMe`'s statement
12:47:56 <srhb> You just need to read the manuals, check your locale, implementation and pray to the unix gods
12:48:18 <typoclass> srhb: right. it's so easy, it takes only 25 mins to explain it to #haskell
12:48:28 <mauke> I'm just trying to point out that regexes are still better in some cases
12:48:36 <mauke> (this case taken from real code)
12:48:40 <monochrom> I agree
12:48:45 <srhb> Point not made. But it may be true none the less.
12:49:01 <YayMe`> yeah, it was a bold statement I made, I agree it's likely not always true
12:49:03 <earthy> regexes are *great* for tokenization
12:49:23 <YayMe`> I just have never bothered to learn much regexp other than super basic stuff because it seems the complex stuff is different in every implementation
12:49:49 <mauke> YayMe`: your original statement was not a universal claim; you were just talking about your experience. that's fine!
12:50:05 <sclv> i don't trust regex performance typically
12:50:17 <mauke> hah
12:50:24 <typoclass> mauke: ok, that's actually a reasonable claim, that regexes sometimes are the best tool for the job. i could never get used to parsec myself
12:50:27 <mauke> "I don't trust lazy evaluation performance typically"
12:50:33 <earthy> Some people, when confronted with a problem, think
12:50:34 <earthy> ‚ÄúI know, I'll use regular expressions.‚Äù   Now they have two problems.
12:50:35 <YayMe`> sclv: that's point 1 for attoparsec, but a small matter for the things you typically use regexp for which tend to be ad hoc
12:51:10 <monochrom> @quote monochrom some.people
12:51:10 <lambdabot> No quotes match. It can only be attributed to human error.
12:51:11 * cmccann finds that regexps can be handy for recognizing regular languages.
12:51:11 <lambdabot> cmccann: You have 1 new message. '/msg lambdabot @messages' to read it.
12:51:29 <mauke> YayMe`: I recommend learning regexes
12:51:38 <mauke> they're a very useful tool
12:52:17 <mauke> hmm, but I'm curious what you consider the super basic stuff of regexes
12:52:49 <YayMe`> mauke: match char range/type, single or one char, match string
12:52:51 <cmccann> mauke: I would consider the basic stuff anything that I don't have to look up every time I use a different regexp implementation
12:53:07 <cmccann> (what that entails is left as an exercise for the reader)
12:53:10 <mauke> ah
12:53:14 <YayMe`> single or any char heh
12:53:47 <sclv> basically i mean that good regex performance is about staging
12:53:59 <sclv> so you don't reinterpret/parse/compile the regex itself repeatedly in tight loops
12:54:33 <mauke> that's trivial if regex support is built into your language :-)
12:54:33 <sclv> and that has a larger effect on code structure than just hand-writing a parser, often
12:54:48 <sclv> right -- i should have specified i don't trust it in haskell
12:55:01 <cmccann> also, I think this conversation is an excellent example of what I was talking about here: http://www.reddit.com/r/haskell/comments/16brxd/what_libraries_are_missinglow_qualityincomplete/c7uvlhv :P
12:55:03 <sclv> also going back and forth across marshalling boundaries drives me nuts
12:55:11 <sclv> in terms of the performance cost
12:55:20 <mauke> yeah, I'm using a pure haskell library
12:55:41 <mauke> (this isn't actually performance critical, though)
12:57:03 <YayMe`> cmccann: Well if haskell didn't make it so darn easy! :P
13:00:45 * hackagebot kevin 0.7.1 - a dAmn î IRC proxy  http://hackage.haskell.org/package/kevin-0.7.1 (JoelTaylor)
13:00:48 <YayMe`> > [[1,2]] >>= sequence
13:00:50 <lambdabot>   No instance for (GHC.Num.Num [a0])
13:00:50 <lambdabot>    arising from a use of `e_112'
13:00:50 <lambdabot>  Possib...
13:01:40 <monochrom> @type [[1,2]] >>= sequence
13:01:42 <lambdabot> Num [a] => [[a]]
13:02:00 <YayMe`> what's the function for making a char upper or lower case?
13:02:08 <typoclass> > toUpper 'u'
13:02:10 <lambdabot>   'U'
13:02:15 <srhb> toUpper / toLower, except it's broken for many characters.
13:02:16 <monochrom> Data.Char toUpper, toLower
13:02:22 <YayMe`> oh data.char
13:02:23 <typoclass> monochrom: nice type ...
13:02:27 <sclv> ?hoogle Char -> Char
13:02:27 <lambdabot> Data.Char toLower :: Char -> Char
13:02:27 <lambdabot> Data.Char toTitle :: Char -> Char
13:02:27 <lambdabot> Data.Char toUpper :: Char -> Char
13:02:42 <monochrom> I don't know what that type means or how to get it :)
13:02:49 <YayMe`> I thought that was right, but my ghci was rejecting me, need data.char
13:02:51 <typoclass> srhb: interesting, how do you mean?
13:03:02 <YayMe`> > [1,2] >>= sequence
13:03:03 <lambdabot>   No instance for (GHC.Num.Num [[a0]])
13:03:03 <lambdabot>    arising from a use of `e_112'
13:03:03 <lambdabot>  Poss...
13:03:07 <typoclass> monochrom: yeah, that's what i mean by 'nice' =)
13:03:13 <monochrom> haha nice
13:08:41 <srhb> > [[[1,2]]] >>= sequence
13:08:43 <lambdabot>   [[1],[2]]
13:08:44 <srhb> Third time's a charm
13:09:01 <typoclass> srhb: third time's ... even more confusing!
13:09:09 <srhb> Okay. True. :P
13:09:32 <srhb> anyway that problem is a unicode problem, not specifically toUpper/toLower. Problem of inverses.
13:09:37 <srhb> We had that discussion the other day, I think.
13:09:56 <srhb> (Or I dreamt it. Very vivid dreams these days! Especially about Haskell ._.)
13:10:28 * Hafydd pinches himself.
13:11:59 <srhb> Ideally I guess there would be a shared uppercase "glyph" but different uppercase/lowercase for each letter in the unicode standard, so that inverses are always preserved. Why did they not do that?
13:12:34 <mauke> I don't understand what you mean by that
13:13:32 <srhb> Sorry, I'm tired.
13:15:19 <srhb> > toLower. toUpper . toLower $ 'ƒ∞'
13:15:19 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:15:22 <srhb> Oh, right.
13:15:36 <srhb> And I didn't mean that last toLower.
13:15:56 <mauke> > toUpper (toLower '\x130')
13:15:58 <lambdabot>   'I'
13:16:01 <srhb> What I meant was, why not have upper/lower-relations preserved in the unicode standard.
13:16:09 <mauke> how?
13:16:18 <srhb> By having different letters that look like 'i'
13:16:24 <mauke> hahahaha
13:16:25 <srhb> or codepoints. or whatever they're called
13:17:11 <srhb> If you're to put away your obnoxious personality for a while, could you explain why thats a laughable idea?
13:17:21 <merijn> srhb: Actually, that should work *if* you have the locale set properly
13:17:33 <srhb> But why rely on a locale.
13:17:36 <mauke> srhb: ... why do you think that would be a good idea?
13:17:42 <merijn> srhb: Since lambdabot probably has C/US locale
13:17:45 <srhb> You could have several codepoints that share "glyphs"
13:17:53 <merijn> srhb: Because the proper behaviour depends on locale?
13:18:04 <mauke> surely that would not cause any problems ever
13:18:05 <srhb> I don't understand why that should ever depend on locale.
13:18:09 <typoclass> srhb: anyway i would joke around some more, but i'm now scared of your wizard powers because of [[[1,2]]]
13:18:16 <srhb> typoclass: Sorry. :P
13:18:19 <merijn> i is the proper lowercase for
13:18:21 <mauke> srhb: would 'i' == 'i' be true?
13:18:38 <mauke> how do you enter the different i's?
13:18:41 <merijn> The proper uppercase for i is locale dependent
13:18:53 <Nereid> > 'i' == 'i'
13:18:55 <lambdabot>   True
13:18:59 <mauke> do you remember the paypal.com phishing attack that used cyrillic 'a'?
13:19:01 <srhb> I just dislike the behaviour of toLower/toUpper.
13:19:05 <merijn> (i.e. I in western locales, but dotted I in turkish locale)
13:19:08 <srhb> No, I don't.
13:19:17 <mauke> how do you extend the behavior to multiple characters?
13:19:23 <mauke> remember, the uppercase version of "√ü" is "SS"
13:19:32 <cmccann> unicode is terrible and makes no sense because it exists to describe something that makes no sense
13:19:32 <srhb> Right.
13:19:45 <Nereid> > toUpper '√ü'
13:19:45 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:19:49 <Nereid> :/
13:19:50 <mauke> however, there is also a (separate) "uppercase √ü" that no one uses
13:19:51 <Nereid> > ord $ toUpper '√ü'
13:19:51 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:19:54 <cmccann> the only way to make unicode less terrible is to give up on accurately describing how text should behave
13:19:56 <Rotaerk> case in general is a curse
13:19:58 <Nereid> blaherfhfghgfjgfj
13:20:04 <Rotaerk> it's kind of pointless and just complicates things
13:20:17 <srhb> *nods*
13:20:34 <srhb> I suppose it is a terrible idea.
13:20:36 <typoclass> cmccann: right, but at least the unicode dudes very carefully documented the thing that makes no sense
13:20:39 <mauke> srhb: http://en.wikipedia.org/wiki/IDN_homograph_attack
13:20:56 <lispy> cmccann: I had the impression that unicode doesn't currently accurately describe it anyway. (I thought there were rendudant encodings for things, hence that big library IBM makes that folds canonicalizes those cases)
13:21:09 <mSSM> mauke: Who defnied that SS is the uppercase version of √ü?
13:21:18 <srhb> mauke: Clearly domains should be resolved by glyph instead of codepoint. :P
13:21:19 <mSSM> mauke: there actually is an uppercase version of √ü
13:21:24 <mauke> mSSM: germans, probably
13:21:30 <mauke> mSSM: <mauke> however, there is also a (separate) "uppercase √ü" that no one uses
13:21:44 <mSSM> mauke: IT
13:21:45 <geekosaur> mSSM, I believe that's the declaration of the German language orthography folks
13:21:45 <cmccann> lispy: entirely possible. describing it all accurately is very difficult.
13:21:49 <mSSM> It's a pretty new thing.
13:21:49 <cmccann> shit's complicated.
13:22:01 <mauke> I can actually type ·∫û here
13:22:05 <mSSM> uppercase √ü was made part of some DIN standard only a few yers ago.
13:22:17 <mauke> STRA·∫ûE
13:22:24 <geekosaur> of course, they also IIRC decided to deprecate √ü entirely
13:22:29 <mauke> geekosaur: no
13:22:40 <mSSM> That's not true.
13:22:43 <lispy> germans seem to be pretty good about refactoring their language
13:23:03 <geekosaur> hm, impression I had was they said "don't use √ü" and were ignored
13:23:09 <mauke> the swiss stopped using √ü a long time ago, and germany recently refactored their orthography in a way that happened to remove √ü from a few words
13:23:11 <cmccann> lispy: is "concatenate nouns" a refactoring?
13:23:18 <geekosaur> ah
13:23:28 <lispy> cmccann: Heh. Not what I meant :)
13:23:33 <mauke> e.g. "da√ü" -> "dass"
13:23:54 <derdon> mauke: noone writes da√ü anymore!
13:23:59 <mauke> it's tied to pronunciation now: after a short vowel it's ss, after a long vowel it's √ü
13:24:05 <mauke> >implying
13:24:22 <mSSM> It was actually standardized.
13:24:30 <mSSM> √ü after a short vowel didn't make sense.
13:24:40 <derdon> also √ü after two vowels directly following each other, e.g. "bei√üen" (to bite)
13:25:11 <mauke> diphthongs count as long vowels
13:25:22 <mSSM> I was just about to write that. :D
13:25:30 <mSSM> Just needed to check how diphthong is written ....
13:25:36 <mauke> mSSM: google :-)
13:25:43 <mSSM> I used wiki :S
13:25:53 <mauke> no, you used wikipedia (probably)
13:26:06 <mSSM> mauke: gee, that's what I mean.
13:26:10 <mSSM> context man, context
13:26:16 <mauke> "wiki" already means something else
13:26:18 <mSSM> (no context here, i know..)
13:26:26 <derdon> forgot the term for it, so I described it :) the fastest way
13:26:39 <mSSM> mauke: I was assuming if you use "wiki" out of context, it redirects to Wikipedia. :)
13:26:44 <geekosaur> actually I'[d infer context that there was some wiki dedicated to the German orthography changes :)
13:26:56 <cmccann> or wiktionary.
13:26:59 <cmccann> you know, for looking up words.
13:27:07 <k00mi> that's called duden in germany
13:27:07 <cmccann> but maybe that would make too much sense.
13:27:08 <mSSM> geekosaur: Well, the German wikipedia has info on that, too. :P
13:32:19 <YayMe`> cmccann: reddit == the other good place to find haskellers aside from here?
13:32:53 <Taneb> There's a couple of us (literally about two) on Tumblr
13:32:53 <cmccann> probably the mailing lists would be next.
13:33:08 <c_wraith> stackoverflow also isn't bad
13:33:17 <c_wraith> though there's a lot of overlap in all of those places
13:33:36 <cmccann> though SO is pretty explicitly anti-socializing
13:33:42 <cmccann> but it's great for what it does
13:34:03 <YayMe`> Yeah, SO is very directed
13:34:29 <YayMe`> my work is a corporate lockdown joint so if I have something to discuss I can't pop in here, not sure if reddit is blocked. the mailing lists are pretty slow to respond I presume?
13:35:05 <YayMe`> hell they block outgoing mail anyway
13:35:39 <geekosaur> the lists are often pretty quick to respond
13:37:02 <monochrom> SO need to open a side site SO-blah for socializing :)
13:38:05 <YayMe`> monochrom: They opened Not-Programming-Related for exactly that reason, they hated the content it generated so they renamed it to Programmers and strictly said no off-topic socializy stuff. They explicitly don't want a site like that
13:38:16 <YayMe`> monochrom: Though they have chat-rooms for some of that
13:38:35 <YayMe`> (they tried it and didn't like it basically)
13:38:55 <monochrom> that's strange and interesting
13:40:38 <geekosaur> there's actually a blah-like SO channel on freenode, fwiw
13:41:34 <geekosaur> (SO-type questions are explicitly off topic for it)
13:43:07 <monochrom> that's nice
13:46:09 <b52> how can i flatten list of lists of numbers by adding up all items of the same index? like f [[1,2], [3,4], [5,6]] = [9,12]
13:46:38 <Taneb> :t foldr (zipWith (+))
13:46:39 <lambdabot> Num b => [b] -> [[b]] -> [b]
13:46:40 <noteventime> b52 sounds like you want a combination of fold and zip
13:46:50 <Taneb> :t foldr (zipWith (+)) (repeat 0)
13:46:52 <lambdabot> Num b => [[b]] -> [b]
13:47:10 <mauke> > transpose [[1,2], [3,4], [5,6]]
13:47:12 <lambdabot>   [[1,3,5],[2,4,6]]
13:47:20 <mauke> > (map sum . transpose) [[1,2], [3,4], [5,6]]
13:47:22 <lambdabot>   [9,12]
13:47:26 <Hafydd> Sexy.
13:47:33 <wto> I like that solution!
13:47:43 <Taneb> > foldr (zipWith (+)) (repeat 0) [[1,2], [3,4], [5,6]]
13:47:44 <lambdabot>   [9,12]
13:48:12 <b52> foldr1 would hold
13:53:20 <mSSM> Can somebody explain to me what ‚ÄúO(1). Linear indexing into underlying, row-major, array representation. ‚Äù means exactly (this is taken from repa's linearIndex function).
13:53:44 <mSSM> It's type still is : Shape sh => Array r sh e -> Int -> e, which is the same as for Index.
13:54:02 <mSSM> Oh no, it isn't!
13:54:56 <noteventime> Is there some way to recursively define arrays in Repa?
13:55:28 <noteventime> As in, having the computation that computes the value at some index inspect the already computed values?
13:55:31 <hpaste> Riley__ pasted ‚ÄúBreak on first missing member?‚Äù at http://hpaste.org/81392
13:55:40 <mSSM> noteventime: I suppose you can recurively make your list and then fromList it?
13:55:42 <startling> mSSM: sounds like it's just a raw indexing thing
13:56:09 <riley__> How can I get that method to break out early, or does it do that by default?
13:56:11 <noteventime> mSSM: You loose constant time indexing though
13:56:34 <noteventime> I guess you aren't supposed to be able to care about order of computation
13:56:47 <mauke> :t all
13:56:48 <lambdabot> (a -> Bool) -> [a] -> Bool
13:56:51 <noteventime> And if you do, you should pass to the underlying representation
13:57:17 <noteventime> mSSM: I'm trying to write an efficient scanl for Repa
13:57:30 <mauke> riley__: allMember hs = all (`HS.member` hs) ?
13:57:35 <mSSM> noteventime: Ok, that would be way over my head right now.
13:57:40 <mSSM> noteventime: sounds interesting though!
13:57:58 <noteventime> Apparently it's over my head too :)
13:58:07 <riley__> mauke: yes. I must be overthinking this. Thanks!
13:58:13 <mauke> @src mconcat
13:58:13 <lambdabot> Source not found. stty: unknown mode: doofus
13:58:27 <mauke> riley__: foldl won't exit early
13:58:34 <mauke> :t mconcat
13:58:35 <lambdabot> Monoid a => [a] -> a
13:59:22 <mauke> mconcat = foldr mappend mempty
13:59:53 <mauke> foldr (not foldr1) means it will do the right thing for empty lists and may stop early
14:00:03 <mauke> but in this case 'all' is much simpler
14:00:52 <riley__> Yes. I think I was too excited and tried to use a Monoid where it wasn't needed.
14:02:11 <tac> monoids are quite exciting :)
14:02:42 <copumpkin> the best monoid is my type monoid
14:02:59 <copumpkin> even though dolio likes to shit on my code and say that it isn't a real monoid :(
14:04:39 <mauke> https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs is clearly the best monoid
14:09:38 <mauke>   mempty = a where a = M $ mempty_ (reflect a)  -- line of the day
14:09:40 <hpaste> b52 pasted ‚ÄúMatlab like mean, var‚Äù at http://hpaste.org/81393
14:09:47 <b52> recommendations/
14:10:18 <elliott> copumpkin: what is your type monoid
14:10:49 <copumpkin> I have not one but two monoids in here! https://gist.github.com/2636229
14:10:51 <copumpkin> see if you can spot them
14:11:01 <mauke> pokemonoid
14:11:10 <YayMe`> what is the description of a monoid?
14:11:31 <mauke> @src Monoid
14:11:31 <lambdabot> class Monoid a where
14:11:31 <lambdabot>     mempty  :: a
14:11:31 <lambdabot>     mappend :: a -> a -> a
14:11:31 <lambdabot>     mconcat :: [a] -> a
14:11:54 <mauke> a type that has an associative operation (mappend) with a neutral element (mempty)
14:12:23 <mSSM> mauke: Wouldn't it be better if the default def of mconcat was given there as well?
14:12:48 <mauke> probably, yes
14:13:14 <geekosaur> but I don't think anyone is maintaining @src's database :/
14:13:17 * mSSM knows what Monoids are; always fails to see when to use them.
14:14:01 <mauke> YayMe`: the simplest monoid is [a] with mempty = [] and mappend = (++)
14:14:10 <mauke> (not actually true)
14:14:23 <mauke> ((it's not the simplest monoid))
14:14:31 <ofan> (+) is also a monoid
14:14:38 <mSSM> I always think (+) is a better example
14:14:49 <cmccann> clearly () is the best and simplest monoid.
14:14:53 <mSSM> Because that append and concat in there is bloody confusing.
14:15:03 <confound> (((mauke)))
14:15:04 <mauke> ofan: no, it's not
14:15:23 <geekosaur> (0,(+)) is a monoid.  as is (1,(*))
14:15:27 <mSSM> s/(+)/Sum
14:15:28 <mauke> mSSM: (+) is commutative, so less general
14:15:48 <mauke> Int is a monoid with 0, (+)!
14:15:55 <cmccann> and both are reasonable, so the standard library splits the difference and has no Monoid instance for Int :[
14:16:18 <mauke> there's one for Sum Int
14:16:40 <mauke> also see the url I posted: withMonoid (+) 0 $ mempty <> M 2  ==>  2
14:17:06 <cmccann> for types with greatest/lowest bounds you can also have a Monoid with min/max!
14:17:26 <noteventime> (++) seems like a good choice, considering it's a free one :)
14:18:08 <cmccann> Free Monoid (limit one per customer, some restrictions may apply)
14:19:17 <noteventime> I'm never paying for a monoid again
14:19:19 <elliott> YayMe`: The description of a monoid is that it is so easy.
14:19:28 <elliott> At least if you ask shachaf.
14:19:50 <cmccann> shachaf's descriptions are so easy.
14:20:37 <mauke> {-# LANGUAGE Rank2Types, TypeFamilies, TypeOperators, ConstraintKinds, PolyKinds, FlexibleInstances, MultiParamTypeClasses, ScopedTypeVariables, FlexibleContexts, UndecidableInstances #-}
14:20:42 <mauke> Looks like I picked the wrong week to quit drinking.
14:21:40 <geekosaur> they forgot IncoherentInstances :)
14:22:40 <srhb> Someone in here is named so, so every so is highlighted for me. Always makes shachaf so much more SERIOUS.
14:23:42 <mSSM> mauke: Are there non-commutative Monoids?
14:23:55 <noteventime> mSSM: Lists?
14:23:59 <mauke> mSSM: yes, e.g. []
14:24:11 <mSSM> Oh
14:24:12 <mSSM> haha
14:24:14 <mSSM> yeah
14:24:23 <mauke> or Endo
14:24:35 <derdon> just want to say that I like this topic (monoids, groups, etc.) :)
14:24:49 <mauke> monoid hug, everyone
14:25:05 <mSSM> So ... how do I get into Category theory?
14:25:23 <mSSM> (phycisist with a little background in group theory)
14:25:28 * Eelis starts reading the Implicit Configurations paper hoping to find a "functional pearl", but finds hackery and obfuscation instead
14:25:51 <cmccann> mSSM: read books, hang around in #haskell, ask dumb questions, repeat until it all makes sense?
14:25:56 <srhb> mSSM: Do Haskell, pick it up as you get curious about the names. :P
14:26:06 <mSSM> cmccann: throw me a book?
14:26:16 <mSSM> cmccann: don't make it too theoretical
14:26:19 <noteventime> And don't say Categories for the working mathematician :P
14:26:21 <mSSM> (but not too practical either)
14:26:21 <cmccann> note that if you want to learn actual legit category theory Haskell will be frequently misleading
14:26:29 <Dodek> mSSM: you can either read textbook on category theory, where you will understand most of the thing with some effort, but you'll never see a point
14:26:37 <mauke> Eelis: it's pretty cool hackery, though!
14:26:40 <srhb> Category theory is very theoretical.
14:26:42 <cmccann> since we mostly concern ourselves with special cases of the general concepts
14:26:44 <Eelis> mauke: i don't think so
14:26:56 <noteventime> mSSM: Awodey's Category Theory is a pretty good introduction, I think
14:26:57 <BlindRadish> hey i hate to ask for more help on the same topic but i still can't figure it out.
14:27:01 <cmccann> and sometimes conflate things that ought to be distinct by flattening everything function-ish into just (->)
14:27:03 <mauke> :-(
14:27:14 <srhb> BlindRadish: Ask away. With code, errors etc. :P
14:27:25 <BlindRadish> I actually need teh codez
14:27:30 <Dodek> mSSM: or you can learn haskell, which will teach you the computer science part interpretation of category theory
14:27:43 <cmccann> but yes, Awodey's is a good introduction I think
14:27:44 <BlindRadish> I need a function that returns a number - the number of times it was called.
14:28:09 <BlindRadish> Without any currying, because I'm going to be calling sporadically throughout the code.
14:28:10 <mauke> can't be a pure function, then
14:28:12 <srhb> BlindRadish: You need something with pretty much global state then.
14:28:19 <mauke> ... what does that have to do with currying?
14:28:36 <noteventime> mSSM: Pierce has a really small book called something like Basic Category Theory for Computer Science, which gives you the basics and a little about their relation to programming languages
14:28:36 <srhb> BlindRadish: You probably should not do this in Haskell. Probably.
14:30:25 <srhb> BlindRadish: But if you're okay with it all being in a State computation or manipulate the same IORef, you're fine.
14:30:29 <mSSM> noteventime: thanks
14:30:37 <cmccann> mSSM: one way or another it's probably best to have a goal in mind when jumping into category theory. it's neat stuff, but hard to motivate without some context until you get more familiar with it.
14:31:06 <BlindRadish> I'd like to use State but I can't understand it
14:31:11 <cmccann> mSSM: there are apparently applications of CT in physics but I don't know enough about either to say what :P
14:31:14 <srhb> BlindRadish: What's troubling you with it?
14:31:26 <BlindRadish> Everytime I call the examples I found they return the same value, they're supposed to return +1
14:31:34 <srhb> BlindRadish: What examples?
14:31:48 <mSSM> BlindRadish: Sounds like your state isn
14:31:50 <BlindRadish> Documentation, really.
14:31:51 <mSSM> isn't updated?
14:32:02 <BlindRadish> runState execState
14:32:04 <BlindRadish> don't work
14:32:14 <BlindRadish> I don't understand all these terms, like get and gets
14:32:14 <mauke> BlindRadish: "don't work" is not a problem description
14:32:22 <BlindRadish> why is it this <- get??
14:32:30 * cmccann guesses BlindRadish is running individual "+1" state computations each time.
14:32:40 <BlindRadish> The error I gave you earlier, not keeping state
14:32:52 <cmccann> BlindRadish: understanding these things would be a better start than trying to implement something blindly.
14:32:53 <mauke> BlindRadish: runState doesn't "keep state"
14:32:59 <mSSM> BlindRadish: State is evil.
14:33:04 <BlindRadish> I'd like a simple example to show me how it's done.
14:33:07 <mauke> State is not evil
14:33:09 <srhb> mSSM: That's not helping. :P
14:33:13 <mSSM> BlindRadish: look at the haskell wiki, read the article on State about 20 times.
14:33:15 <BlindRadish> I'm building a lfsr.
14:33:24 <mauke> BlindRadish: forget State; do it manually
14:33:25 <BlindRadish> I can't do it without knowing the last output value.
14:33:28 <mSSM> BlindRadish: then try to use it. Then read it again about 5 times. At that point you will get it.
14:33:44 <mSSM> At least that's how I felt.
14:33:50 <mauke> meh. there's no point in using State just for the heck of it
14:33:51 <BlindRadish> mSSM: That seems more like discussion on the future of haskell lol
14:33:57 <quchen> The cabal manual is kind of overwhelming. Is there a command to just try to build everything in the current directory? I'm not planning on installing all the test programs in my actual .cabal folder.
14:34:08 <mauke> write a version without State first
14:34:12 <mSSM> After you understood State, come to #haskell and have srhb tell you not to use it.
14:34:14 <mauke> you can always refactor later
14:34:21 <dcoutts_> quchen: just configure and build
14:34:23 <mSSM> (because your program is too simple)
14:34:23 <noteventime> BlindRadish: Try writing the code such that you explicitly pass the count around, then read how State can hide the passing around for you.
14:34:27 <dcoutts_> quchen: and don't install
14:34:34 <quchen> dcoutts_: cabal configure && cabal build?
14:34:34 <BlindRadish> mauke: done.
14:34:39 <dcoutts_> quchen: right
14:34:46 <mauke> yay
14:34:58 <BlindRadish> mauke: you were helping me earlier with this i think lol
14:35:04 <BlindRadish> mauke: believe me, I tried.
14:35:08 <dcoutts_> quchen: assuming you mean one package, not several packages
14:35:20 <BlindRadish> mauke: it's always something obvious that I just don't understand.
14:35:31 <quchen> dcoutts_: Oh, that was easy. I've only used cabal install before and watched Hackage/Cabal do everything.
14:35:34 <quchen> Thanks!
14:35:41 <BlindRadish> mauke: people explain it like this (a -> a) -> a, a -> a
14:35:47 * hackagebot hlint 1.8.43 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.43 (NeilMitchell)
14:35:51 <BlindRadish> mauke: I'm not quite there yet lol
14:35:56 <hpaste> otters pasted ‚ÄúParsecT state not updating‚Äù at http://hpaste.org/81394
14:35:56 <quchen> dcoutts_: I've got a makefile right now, and I'd like to migrate to Cabal at some point.
14:36:02 <quchen> dcoutts_: Just playing around a bit.
14:36:35 <JoeyA> Is there a more convenient way to stub functions than to say longFunctionName :: ...; longFunctionName = undefined ?
14:36:37 <BlindRadish> mauke: it works though lol
14:36:43 <JoeyA> It'd be nice if I could just write the signatures and be done with it.
14:36:53 <otters> the function in question is on line 121
14:36:54 <dcoutts_> quchen: in some ways cabal build is a bit weak in comparison to make, but it's fairly convenient, less manual configuration
14:37:02 <otters> starts here: http://hpaste.org/81394#line121
14:37:21 <otters> if I traceShow the result of getState after that block, it's been incremented
14:37:26 <otters> then in the next call to choices, it's back to 0
14:37:35 * dcoutts_ notes that cabal finally gained the ability to specify build targets when doing cabal build
14:37:46 <niteria> what's a good textbook on logic? preferably with a lot of problems with solutions
14:37:55 <otters> I could unsafely modify an IORef if I reall wanted to
14:38:03 <quchen> dcoutts_: It's much more complicated than Makefiles for me right now, but since everyone seems to love it ...
14:38:23 <otters> really don't want to though
14:38:49 <dcoutts_> quchen: it comes into its own once you have to share packages with other people
14:39:17 <quchen> dcoutts_: Is there a standard procedure for finding out the build-depends? I can just write "base >= myVersion", but that's not really a good way to do it, is it?
14:40:26 <dcoutts_> quchen: that's not a bad place to start. Unfortunately to really find out the lowest version takes work, you have to try building it against that older version
14:40:32 <crdueck> @hoogle (Functor f, Monad m) => (a -> m Bool) -> f a -> m (f a)
14:40:33 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
14:40:33 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
14:40:33 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
14:40:47 * hackagebot hbro 1.1.1.0 - Minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-1.1.1.0 (koral)
14:40:49 * hackagebot hbro-contrib 1.1.1.0 - Third-party extensions to hbro.  http://hackage.haskell.org/package/hbro-contrib-1.1.1.0 (koral)
14:40:59 <quchen> dcoutts_: Hm, that's unfortunate, but not unexpected.
14:41:39 <quchen> dcoutts_: I just noticed that while "cabal build" compiled everything correctly, it placed only the Main.hs in the source tarball. Do I have to specify all the files manually somewhere?
14:41:45 <dcoutts_> quchen: another common (but not universal) practice is to use an upper bound of the current major version
14:42:29 <dcoutts_> quchen: yes, all the files need to be listed in other-modules (for exes) (or also exposed-modules for libs)
14:42:53 <otters> alternatively I guess I could update the state in the call to regex
14:42:59 <crdueck> @hoogle Monad m => (a -> m Bool) -> Map k a -> m (Map k a)
14:42:59 <lambdabot> Data.Map updateMax :: (a -> Maybe a) -> Map k a -> Map k a
14:43:00 <lambdabot> Data.Map updateMin :: (a -> Maybe a) -> Map k a -> Map k a
14:43:00 <lambdabot> Data.Map update :: Ord k => (a -> Maybe a) -> k -> Map k a -> Map k a
14:43:46 <quchen> dcoutts_: Oh, so when I publish a lib, I can distribute it in compiled .o/.hi form, but keep some of the source to myself?
14:44:14 <quchen> (I can of course delete the source files by hand too)
14:44:19 <dcoutts_> quchen: no, the non-exposed modules just don't form part of the public API, it's nothing to do with hiding source code.
14:45:53 <dcoutts_> quchen: distributing Haskell libraries (as opposed to executables) as binaries is not very convenient
14:47:31 <mSSM> Is there a repa equivalent to vector's unsafeWrite (for mutable vectors)?
14:47:32 <quchen> dcoutts_: I'm quite lucky in that respect then. Got an executable that's not interesting to anyone but myself. :-)
14:48:28 <dcoutts_> mSSM: repa has unsafe reads, but it doesn't have mutable vectors so I'm not sure that makes sense
14:48:29 <mSSM> Does repa actually provide mutable arrays at all?
14:48:33 <dcoutts_> no
14:48:38 <mSSM> damn
14:49:33 <quchen> dcoutts_: I really can't add something like "other-modules: src/*"?
14:49:44 <dcoutts_> quchen: sorry
14:49:52 <quchen> As in "here's the folder with all the source files, add all the .hs stuff in there?
14:50:42 <srhb> cd
14:50:47 <srhb> Oops, sorry.
15:15:02 <lpsmith> can hs-boot files declare incomplete or empty classes?
15:15:45 <lpsmith> oh right, I see that I can in the documentation
15:16:03 <lpsmith> I can't have incomplete methods though, it's all or nothing.
15:20:48 * hackagebot network-api-support 0.0.4 - Toolkit for building http client libraries over Network.Http.Conduit  http://hackage.haskell.org/package/network-api-support-0.0.4 (MarkHibberd)
15:24:48 <MercuryRising> im trying the 'learn you a haskell' online, and I'm having some trouble with the types
15:24:52 <MercuryRising> when i try to make the
15:24:56 <MercuryRising> removeNonUppercase :: [Char] -> [Char]
15:25:13 <MercuryRising> function, it says it's not in scope
15:25:37 <lpsmith> MercuryRising, that's a function you have to define yourself
15:25:48 * hackagebot esqueleto 1.0.3 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.0.3 (FelipeLessa)
15:26:10 <lpsmith> MercuryRising, LYAH gives a sample definition
15:26:47 <MercuryRising> okay, so i make the function definition then i give it a type? it seems backwards on the website
15:27:11 <lpsmith> MercuryRising, what do you mean?
15:27:22 <lpsmith> You can omit the type,  and GHC will give it one for you.
15:27:32 <YayMe`> i've a ponderance on putting together a crud data model, does it make sense to implement monad directly on it where bind executes validation and returns the original if the original is invalid (like the error monad) or is it more idiomatic to just utilize the error monad
15:27:41 <lpsmith> But it's often a good idea to write down the type,  especially for your own benefit
15:27:42 <MercuryRising> addThree :: Int -> Int -> Int -> Int
15:27:44 <MercuryRising> addThree x y z = x + y + z
15:27:46 <MercuryRising> that's what it says on the tutorial, but it should be the other way?
15:28:07 <lpsmith> no
15:28:20 <lpsmith> though I'm not sure you can type in types in ghci
15:28:29 <lpsmith> you have to put those in a text file that ghci will read for you
15:28:37 <MercuryRising> ahhhhhhhhhh
15:28:57 <MercuryRising> okay, i was confused when it was making me type 'let x = 10' before everything
15:28:59 <lpsmith> MercuryRising, are you using a tryhaskell-like website,  or are you using ghci on your local computer?
15:29:08 <MercuryRising> on my computer
15:29:34 <lpsmith> yeah, try putting those definitions in a text file and then loading the file with ghci
15:29:55 <lpsmith> once you have the file loaded,  you can just use :r   to reload it when you make changes
15:29:59 <MercuryRising> alright that works great!
15:30:34 <MercuryRising> what's the difference between 'prelude' and 'main'?
15:30:52 <c_wraith> Prelude is a module in the standard libraries
15:30:59 <c_wraith> Main is the module you wrote
15:30:59 <lpsmith> Prelude is the module that every module implicitly imports
15:31:18 <c_wraith> The difference at the ghci prompt is that when it lists Main, it's saying it loaded your module
15:31:24 <YayMe`> lpsmith: I find writing types up front especially when playing with something I end up getting them all wrong and spending more time trying to figure out the typing than actually figuring out how the thing I'm playing with works
15:31:50 <lpsmith> YayMe`, I agree =)
15:32:08 <YayMe`> lplsmith: I think that will change as I learn all the types better and the libs in general but I'm not convinced creating types up front is most ideal advice for someone learninh
15:32:48 <lpsmith> YayMe`, I often find writing down a type first helps solidify my thoughts and guides me about how to write what I want to write
15:33:01 <YayMe`> yeah, I could see that if I know what I want up front
15:33:25 <YayMe`> but often times when I'm learning a new lib or something I don't know exactly what the type should be until I play with the lib for a while
15:33:48 <lpsmith> On the other hand,  there are advantages to writing what you want to write and then carefully inspecting what ghc says the type is,  there are some advantages to that as well
15:34:40 <burbul> Is there a way to keep taking elements from a list while they match a certain pattern?
15:34:53 <Eduard_Munteanu> :t takeWhile
15:34:54 <riley__> YayMe`: You are not alone.
15:34:54 <lambdabot> (a -> Bool) -> [a] -> [a]
15:34:55 <burbul> Or do I have to write a  :: X -> Bool function
15:34:56 <YayMe`> filter or takeWhile
15:35:03 <YayMe`> not sure which one you mean
15:35:06 <burbul> I know about those
15:35:08 <burbul> takeWhile
15:35:19 <burbul> But the point is that I want to get away without writing an explicit function of type
15:35:22 <burbul> a -> Bool
15:35:29 <YayMe`> oh you don't know of lambdas?
15:35:33 <burbul> I want to keep taking elements while a certain pattern match works
15:35:35 <YayMe`> @type takeWhile
15:35:37 <lambdabot> (a -> Bool) -> [a] -> [a]
15:35:38 <burbul> I know of lambdas
15:35:44 <burbul> But I didn't know you could use them patterns
15:35:48 <lpsmith> YayMe`, you might enjoy this paper:  http://dl.acm.org/citation.cfm?id=1267228
15:35:50 <YayMe`> > takeWhile (\x -> x < 3) [0..]
15:35:51 <burbul> *use them with patterns
15:35:51 <lambdabot>   [0,1,2]
15:36:00 <YayMe`> or rather...
15:36:08 <YayMe`> > takeWhile (<3) [0..]
15:36:10 <lambdabot>   [0,1,2]
15:36:19 <burbul> So how would I reconstruct e.g. lefts with lambda syntax?
15:36:25 <burbul> :t lefts
15:36:26 <lambdabot> [Either a b] -> [a]
15:36:29 <lpsmith> it gives an example of the advantage of not writing down a type first.
15:36:37 <burbul> I'd want to pattern match against 'Left _'
15:36:44 <burbul> Well, I suppose lefts isn't exactly what I want
15:36:57 <burbul> Say I wanted takeWhile isLeft
15:37:05 <burbul> where isLeft (Left _) = True
15:37:08 <burbul> isLeft _ = False
15:37:09 <lpsmith> crap that's pwaywaned isn't int
15:37:17 <burbul> Is there a way to write that without actually having to define isLeft?
15:37:19 <lpsmith> or not even available on the acm site
15:37:48 <lpsmith> YayMe`, better link:  http://static.usenix.org/publications/library/proceedings/vhll/koenig.html
15:37:52 <carter> lispy : the version you linked me?
15:38:05 <MercuryRising> i have to say, coming from python, there are some breaths of fresh air in haskell so far (at least at first glance)
15:38:11 <chance> i wish i joined this channel earlier into my haskell re-dive
15:38:37 <chance> MercuryRising: indeed. Im a python guy and i've been on and off learning haskell with LYAH, but this weekend I finally sat down
15:38:39 <applicative> MercuryRising: we're not surprised ...
15:38:41 <chance> and decided to read some more of it.
15:38:48 <YayMe`> >  takeWhile (\x -> case x of Left _ -> True; otherwise -> False) [Left 3, Left 4]
15:38:50 <lambdabot>   [Left 3,Left 4]
15:39:09 <applicative> YayMe`: yeah, it needs LambdaCase
15:39:14 <lpsmith> MercuryRising, I found that when I was learning Haskell,  it was a good way for take what I thought I knew about programming get smacked down in the best possible way.
15:39:33 <lpsmith> ugh, that was not well worded
15:39:38 <YayMe`> applicative: Not familiar with LambdaCase ?
15:39:43 <chance> it was fine
15:39:56 <applicative> takeWhile (\case Left _ -> True; _ -> False)
15:39:58 <chance> You can't learn without failure.
15:40:01 <chance> or struggle
15:40:10 <YayMe`> applicative: Does that work?
15:40:14 <applicative> YayMe`: oh, it would look so ^^^
15:40:18 <chance> if your no longer struggling, its time to move to something else to challenge yourself again!
15:40:20 <lpsmith> When I thought I knew something about programming,  Haskell would cut me down a notch in the best possible way.
15:40:26 <lpsmith> It still does that sometimes.
15:40:29 <applicative> YayMe`: I might be making a syntax error just a sec
15:41:27 <applicative> YayMe`: with :set -XLambdaCase ghci accepts takeWhile (\case Left _ -> True; _ -> False) [Left 3, Right 4]
15:42:21 <YayMe`> lpsmith: I thought haskell was invented explicitely to make me feel like an the stupidest smart person alive
15:42:40 <YayMe`> applicative: That is pretty awesome.
15:45:25 <burbul> LambdaCase: thanks!
15:46:49 <bh> Is there an easy way to remove all the packages I've installed with cabal-install?
15:46:58 <johnw> rm -fr ~/.ghc ~/.cabal/lib
15:47:10 <johnw> that way you keep the docs and binaries
15:47:32 <bh> johnw: thanks. I forgot about .ghc!
15:48:03 <lispy> carter: oh, wow. THis is way better than discussing the whole thing on twitter :)
15:48:10 <carter> lispy yeah
15:48:11 <lispy> carter: Sorry, I didn't know your nick previously
15:48:14 <carter> np
15:48:16 <carter> its name name
15:48:20 <carter> hence clearish :)
15:48:22 <lispy> carter: it looks like make still generated a ton of output
15:48:25 <carter> yeah
15:48:26 <carter> thats ok
15:48:35 <carter> its still much less verbose than it otherwise would be
15:48:39 <lispy> ah
15:48:49 <carter> I spent all of last weekend cursing about this
15:48:50 <lispy> So will this get to a point where it's not producing output?
15:48:52 <carter> as you may have noticed
15:48:55 <carter> yes
15:49:05 <carter> you'll see a bunch of the propellers things on adjacent lines
15:49:10 <lispy> ah, okay that's when the propeller script will help
15:49:13 <carter> yes
15:49:15 <burbul> What version of ghc does LambdaCase require?
15:49:26 <johnw> 7.6
15:49:33 <lispy> carter: oh, and it's working now
15:49:34 <burbul> thanks
15:49:44 <carter> lispy: yah
15:49:52 <carter> this is before the kill spot that last happened
15:50:03 <carter> when its building binary  libs or someting
15:50:18 <carter> if you look at the end of the buld log on the previous build
15:50:22 <lispy> bash scripts like this are so lulz-y, but hey it works.
15:50:28 <carter> yeah
15:50:49 <carter> i was a bit "fuck, it'd be too much work to do this as a shelly script, and i'm fuzzy on my fancy shell script"
15:50:58 <carter> so thanks
15:51:26 <lispy> np. I only know bash because I endup automating too much stuff at work :)
15:51:43 <lispy> I've started using Haskell for that thanks to shelly, but I wouldn't have known how to do this script in Haskell
15:51:52 <lispy> at least not as quickly
15:51:53 <carter> if its not automated, i know rage
15:52:08 <chance> automation makes it better - puppetlabs.
15:52:15 <carter> hehe
15:52:48 <lispy> co-workers and I even try to automate the configuration of project specific virtual machines. We have a set of bash scripts that install everything you need.
15:52:59 <carter> lispy I guess when you're rolling lots of semi bespoke tools, those sorts of scripts are what hold them together
15:53:02 <carter> cool
15:53:10 <lispy> Costs a bit of time upfront, but when you suddenly go, "Oh we need a new build environment to test X,Y,Z" you just saved 1+ days of work
15:53:26 <carter> if this doesn't work... i'd rather just figure out a scirpt to make it easy to do a CI thing on your own vm
15:53:36 <carter> with associated web server ux etc :)
15:53:50 <lispy> oh right. I always forget that travis is open source
15:53:54 <carter> which will takem more work, but then i'd control theknnobs
15:53:58 <carter> thats why i was trying it
15:54:27 <carter> because then it gives people who want to play with ghc hacking a sane way to do builds when hacking via a laptop
15:54:30 <carter> withouth doing more setup work
15:54:41 * lispy nods
15:55:02 <carter> but at some point i'll be doing some not github based private code CI
15:55:06 <lispy> If GHC-HQ ever gets to the point of accepting pull-requests on github they could even know whether the pull request passes tests before they accept it.
15:55:25 <lispy> do you know if travis-ci runs on windows servers?
15:55:31 <carter> probs not
15:55:40 <carter> debian looks like
15:55:47 <Igloo> lispy: how could we know that?
15:55:57 <carter> or some buntu variant
15:56:03 <lispy> Igloo: travis-ci can test pull requests
15:56:07 <carter> Igloo: i'm trying to set up some nice CI setup for ghc
15:56:22 <carter> if travisCI doesn't work, i will (in rage) roll my own host yer own CI tool
15:56:30 <carter> in haskell
15:56:42 <Igloo> lispy: Is someone going to run a builder that'll do a full GHC build for every pull request?
15:56:54 <lispy> carter: There have been previous haskell CI tools. scoutess?
15:56:55 <carter> Igloo: travis might not say no :)
15:56:57 <Igloo> Oh, carter is? Neat
15:57:08 <Igloo> carter: travis is the tool?
15:57:09 <lispy> Igloo: travis-ci.org runs free builders
15:57:12 <carter> yes
15:57:16 <carter> https://travis-ci.org/cartazio/ghc/builds/4419145
15:57:21 <carter> is the current attempt to get the build working
15:57:30 <Igloo> Ah, so not just the tool, but also supplies the hardware?
15:57:32 <carter> ghc kind stress tests the VM's on these tools
15:57:37 <carter> yeah
15:57:50 <carter> lispy: even if this works, i may roll my own CI thing
15:58:05 <carter> lispy: i thought scoutess still needed some post summer of code work, right?
15:58:13 * Igloo gets a blank page for that URL
15:58:18 <lispy> carter: http://alpmestan.wordpress.com/2012/03/21/scoutess-continuous-integration-cabal-and-the-google-summer-of-code/
15:58:37 <carter> alpounet where scoutess live now?
15:58:44 <lispy> Igloo: Sometimes the page loads get bogged down when their servers are loaded.
15:58:57 <carter> http://patch-tag.com/r/alpmestan/scoutess
16:00:20 <lispy> Igloo: travis-ci.org doesn't have as many fancy build options as the current ghc build slaves. For example, you don't get to pick the ghc version used in the build. I see travis-ci as a very easy way to get some evidence that my code will build for other people, but if you have specific goals for your build slaves it may not be suitable.
16:00:28 <YayMe`> chance: I'm teaching a colleague at work (C# shop) functional programming techniques for the past few months using C#. It's funny because he has no trouble doing anything normally in C#, but as soon as I ask him to create simple filtering functions in a functional way like haskell's and / or he struggles so much. Funny, reminds me of a year and a half ago when I started doing FP, just shows it was time for him to move on for more
16:00:28 <YayMe`> struggle as you said
16:00:51 <carter> lispy agreed, my aim is to make it easier for new folks to hack on ghc source :)
16:01:20 <chance> yeah, i know, i love it
16:01:36 <chance> im a python guy, and this all isn't too horrible, I get the jist
16:02:02 <chance> I struggle to do the same stuff I do in python, but I could do some euler stuff
16:02:13 <chance> and ive only started this weekend.
16:02:23 <chance> give me a month of using haskell every day and I'd be set!
16:02:57 <YayMe`> haha anybody who goes from no haskell to a month of haskell every day will end that month a mad man (like all haskellers I've learned)
16:03:26 <chance> true. i didnt calculate the end of my progression out all the way..
16:03:28 <carter> YayMe` its a good thing. its the isanity of thinking (somewhat) lgoically
16:03:52 <shachaf> YayMe`: Haskell can change your gender? That sounds dangerous.
16:03:54 <YayMe`> I have an interview this week and I'm genuinely scared of doing something in too haskellish a way without realizing it, effectively making the normals think I'm crazy and turning me down
16:04:02 <lispy> carter: re: scoutess. I heard that too, I was just thinking if you're going to roll your own anyway...
16:04:07 <chance> i imagine it as something day 3..loving it..day 10..getting confused..day 30...dead
16:04:15 <carter> lispy its passed the part where it would get killed by time out!
16:04:16 <YayMe`> shachaf: haskell is very transformative, didn't you know? :)
16:04:22 <lispy> carter: woot!
16:04:36 <chance> i feel like such a hipster :<
16:04:42 <chance> like "I kinda know haskell"
16:04:53 <chance> kinda like when I learned python, considering I feel like my school is pure C# or stupid
16:04:54 <YayMe`> chance: just day 31 alive again, but only in a monadic context
16:04:55 <shachaf> "uve been shachaffed!!"
16:04:56 <chance> or both.
16:05:02 <carter> lispy: maybe, but i kinda feel that unless its clear how to use scoutess to do what i want, making my own tool will beeasier
16:05:09 <carter> i'm friends with alpounet  so i could hassile him
16:05:12 <chance> although we have a lot of stupid..
16:05:16 <carter> but
16:05:56 * lispy realizes he isn't sure what shachaffed means now
16:06:03 <YayMe`> shachaf: So long as you shachaf everyone equally, it's acceptable
16:06:34 <cmccann> lispy: whatever it means,  you can be sure that it is so easy.
16:07:27 <chance> worst part about where im at with haskell, im finally rolling
16:07:33 <chance> and im at like, modules
16:07:33 <shachaf> YayMe`: No, it's mostly just you.
16:07:34 <carter> lispy: anyways, the point being, if the engineering effort to roll exactly what I want is << sorting out how to use the more general tool thats still needing some polish, i'm going to do that
16:07:38 <YayMe`> shachaf: balls.
16:07:42 <chance> and I really want to learn more about monads, and functors !
16:07:45 <chance> >.<
16:07:58 <chance> seems so far away.
16:08:22 <lispy> carter: that's fair, I just like to make sure people have the information to make that trade-off decision (I didn't know if you knew about scoutess)
16:08:30 <carter> i knew of it, but i forgot it
16:12:08 <tac-tics> chance: ##categorytheory
16:12:12 <tac-tics>  /join it :)
16:14:46 <lpsmith> we need recursive modules
16:15:20 <lpsmith> hs-boot files don't seem to cut it for me
16:16:17 <Hafydd> Whom should I speak to if I want to have lambdabot in a channel?
16:17:36 <chance> its probably open source
16:17:45 <applicative> do /query lambdabot Hafydd
16:17:50 <chance> http://www.haskell.org/haskellwiki/Lambdabot
16:17:54 <lpsmith> Hafydd,  I think Cale can do it
16:18:03 <applicative> ah
16:18:21 <lpsmith> I don't know who if anybody else can
16:18:44 <Hafydd> I tried compiling lamdabot once, and it seems to be broken.
16:18:55 <Hafydd> But I suppose that could well be fixed now.
16:18:58 <applicative> oh, I was going to ask if you could compile it...
16:18:59 <bitonic> hpc got it to compile at some point, iirc
16:19:05 <Hafydd> In any case, it seems reasonable to use the same instance.
16:19:10 <shibby> what is the term for the property of an array which describes if the array will increase/decrease its size or not please?
16:20:03 <chance> > map (+1) [1.3]
16:20:05 <lambdabot>   [2.3]
16:20:10 <chance> noice
16:20:22 <riley__> resizable?
16:21:00 <parcs> dynamic array
16:21:21 <hpaste> johnw pasted ‚ÄúBaseSpec.hs‚Äù at http://hpaste.org/81397
16:21:29 <johnw> Can anyone who knows hspec help me with that example?
16:21:50 <johnw> i'm getting "No instance for (Example Expectation)" on line 12, and "Couldn't match expected type [Spec] with actual type Spec" on line 12
16:22:01 <johnw> but this example is taken right off the hspec introduction docs...
16:23:05 <johnw> i wonder if hspec-discover is to blame...
16:24:29 <applicative> johnw: your hspec file doesn't have a line 12
16:24:50 <johnw> argh, bad paste
16:25:04 <johnw> one sec, let me make sure hspec-discover is doing the right thing
16:29:27 <hpaste> johnw pasted ‚ÄúBaseSpec.hs (2)‚Äù at http://hpaste.org/81398
16:29:45 <johnw> ok, I changed it to that, based on the hspec-discover tests, but I get the exact same error
16:29:52 <johnw> so I guess I'm importing something wrongly
16:35:45 <johnw> ah, the answer to one of them was "import Test.Hspec.HUnit ()".  But it is odd this is documented nowhere... I wonder if hspec has been changing a lot lately?
16:37:52 <lpsmith> Ok, I'm getting an error "src/Database/PostgreSQL/Simple/FromField.hs:113:7:
16:37:52 <lpsmith>     Database.PostgreSQL.Simple.FromField.FromField is exported by the hs-boot file, but not exported by the module"
16:38:12 <lpsmith> but the thing is both my FromField.hs and FromField.hs-boot export the FromField class
16:38:18 <lpsmith> the error is very confusing to me
16:39:55 <lpsmith> ok,  I figured something out that works
16:40:40 <lpsmith> It doesn't make sense to me, but it works
16:40:52 <johnw> aha, hspec-discover depends on an old version of hspec.  oh well
16:41:00 <otters> is there a way to make the parser (many1 anyChar >> char '\n') succeed on "foo\n" ?
16:41:04 <otters> in parsec
16:41:33 <shibby> can arrays in haskell be either of fixed capacity, or dynamic?
16:43:34 <nanothief> shibby: http://www.haskell.org/haskellwiki/Modern_array_libraries gives a good reference for immutable and mutable arrays. Obviously you can't have mutable arrays in pure code, but you can use them in the IO or ST monad
16:43:37 <applicative> parseTest (manyTill anyChar $ char '\n') "foo\n" -- this can't be rational
16:43:42 <applicative> otters: ^^^
16:44:04 <shibby> why not mutable in pure code?
16:44:08 <ion> otters: many1 (noneOf "\n") *> char '\n'
16:44:15 <applicative> that's more like it
16:44:19 <otters> ion: I was looking for a more general form
16:44:34 <otters> like how /.*\n$/ would match
16:44:43 <otters> everything until the last \n including other \n
16:44:53 <applicative> ah
16:45:06 <elliott> shibby: because mutable state is impure
16:45:09 <nanothief> shibby: To be more precise you can use mutable ST arrays in pure code, but you can't modify a passed monad in pure code, as that wouldn't be referentially transparent.
16:45:31 <nanothief> but as part of a intermediate calculation you can use them
16:45:34 <ion> ‚Äúthis can't be rational‚Äù You‚Äôre right, it‚Äôs String.
16:45:37 * elliott wonders what "modify a passed monad" means
16:45:42 <shibby> hahaha
16:46:24 <nanothief> lol s/passed monad/passed array
16:46:48 <otters> confession: I'm trying to write a module that can convert a perl-style regex to a Parsec parser
16:47:18 <Eduard_Munteanu> Simple... in Agda, you can pass monads around and modify them. :D
16:47:37 <Eduard_Munteanu> They're just functors and records anyway. :)
16:48:00 <otters> so .*\n would be converted to something like mappend <$> (mconcat <$> many anyChar) <*> (char '\n')
16:48:03 <otters> but of course that fails
16:48:41 <parcs> make your converter smarter :)
16:49:23 <otters> the regex parser creates an AST and the conversion function only looks at one node at a time
16:49:34 <otters> I'd have to know the contents of the next node
16:50:07 <nanothief> the fact that * is greedy will make it more difficult
16:50:13 <otters> yeah, that's the thing
16:50:36 <otters> I'd have to pattern match on Seq (Kleene a) b specifically
16:50:41 <otters> which is possible, but still
16:53:52 <applicative> manyTill anyChar  (try $ char '\n' >> eof) -- even more ham-handed
16:54:02 <otters> that does work
16:54:19 <lpsmith> Do .hs-boot files need to go under the other-files section of the .cabal file?
16:54:25 <lpsmith> or where do they need to be listed?
16:55:11 <dcoutts_> lpsmith: just list the modules normally
17:01:25 <nanothief> otterdam: this monstrosity works: parseTest (fmap (++ "\n") $ fmap (intercalate "\n") $ (many1 $ try $ manyTill (noneOf "\n") (char '\n'))) "th\nthis\nthasdf\n\n388" , outputs "th\nthis\nthasdf\n\n"
17:01:29 <otters> holy crap I did it
17:01:36 <otters> and how horrifying it is
17:01:39 <nanothief> * otters
17:01:46 <nanothief> hah I know :/
17:02:03 <otters> regexToParser n (Seq s@(Kleene a) b) = mappend <$> (mconcat <$> (manyTill (regexToParser n a) $ try (lookAhead rb))) <*> rb where rb = regexToParser n b
17:02:21 <jfischoff> sigfpe wrote an interesting blog post here http://blog.sigfpe.com/2006/11/variable-substitution-gives.html showing how substitution can be implemented with monadic bind.
17:02:33 <otters> now it's time to do lazy matching!
17:03:22 <jfischoff> I would like find something equally elegant if I want to perform more complex substitution.
17:03:25 <otters> "hello\nfoo\n" =~ /(.*)\n/ should be "hello\nfoo" right
17:03:47 <jfischoff> i.e. sub x^2 for 1 in x^4*y
17:03:58 <otters> no, wait, it shouldn't
17:04:00 <otters> thank christ
17:04:31 <jfischoff> so what categorically thing lets me substitute arbitrary sub trees for each other?
17:05:00 <otters> I'm beginning to think this isn't what parsec is best designed for
17:05:27 <nanothief> otters: it depends on whether you are doing multi line matching. If so, \1 should be hello\nfoo and the whole match should be "hello\nfoo\n", otherwise \1 should be hello and the whole match should be "hello\n"
17:05:42 <otters> oh, that's right
17:05:53 <jfischoff> I am teetering on the edge of making a Subbable type class but that seems rather ad hoc
17:05:54 <otters> this "engine" has no concept of non-multiline matching
17:12:32 <nejucomo> I need to pack binary data in little endian, but Data.Binary is explicitly big endian only.
17:12:59 <nejucomo> Any advice?
17:13:01 <jfischoff> really?
17:13:41 <nejucomo> At least in binary-0.5.1
17:14:07 <Eduard_Munteanu> Yeah, I too remember it being big-endian-only.
17:14:27 <shachaf> I don't think Data.Binary is meant for general-purpose encoding of binary data.
17:14:44 <shachaf> It's specifically for encoding Haskell values.
17:15:14 <shachaf> But http://hackage.haskell.org/packages/archive/binary/0.6.4.0/doc/html/Data-Binary-Put.html has a bunch of little-endian primitives.
17:15:24 <jfischoff> perhaps you make newtypes for your primitives and use those ^
17:15:31 <shachaf> ...By "a bunch" I mean three?
17:15:38 <jfischoff> and then use ala
17:15:55 <nejucomo> The types I'm working with are all Data.Word.Word* 's right now.
17:19:44 <nejucomo> Huh...  Weird.  I did "cabal install binary"; got the newer version, hit "reload" on ~/.cabal/share/doc/index.html, saw some new entries...
17:20:02 <nejucomo> -but the table still says the package is "binary-0.5.1.0".
17:20:48 <nejucomo> If I click a link it has the new little-endian apis, but the header still says "binary-0.5.1.0".
17:21:00 <nejucomo> Is this a bug in the doc generation or the binary package metadata?
17:26:05 <shachaf> lispy: Wouldn't you rather generate CIL than C#?
17:29:22 <gertc> https://vimeo.com/17207564 9:25 what was that thing he said about map c?
17:29:52 <dcoutts_> nejucomo: presumably 0.5.1.0 is the last version you installed with documentation enabled
17:30:14 <dcoutts_> nejucomo: note also that that version does have the little-endian apis (they're not very new)
17:30:17 <gnuvince> Given an IO a, is there a combinator to return an infinite list of IO [a]?
17:30:42 <sipa> :t repeat
17:30:43 <lambdabot> a -> [a]
17:30:48 <sipa> :t fmap repeat
17:30:48 <S11001001> shachaf, lispy: I can think of one reason, maybe: monotouch compiles c# to...something, I think.
17:30:49 <lambdabot> Functor f => f a -> f [a]
17:30:51 * hackagebot monad-bool 0.2.0 - This package has been removed.  http://hackage.haskell.org/package/monad-bool-0.2.0 (JohnWiegley)
17:31:27 <gnuvince> sipa: that keeps returning the same result
17:31:51 <gnuvince> e.g.: fmap repeat randomMove >>= return . take 10  ==>  [2B,2B,2B,2B,2B,2B,2B,2B,2B,2B]
17:31:53 <shachaf> S11001001: From what I remember there are a lot of reasons that compiling to CIL makes life easier than C#.
17:32:00 <shachaf> Admittedly I know almost nothing about .NET.
17:32:30 <dcoutts_> gnuvince: how would it ever return a result?
17:32:37 <S11001001> shachaf: I can imagine.  For one, not all CIL programs can be written in C#.
17:33:16 <gertc> does he mean c -> c where -> is function id?
17:33:31 <sipa> :t foreverM
17:33:33 <lambdabot>     Not in scope: `foreverM'
17:33:33 <lambdabot>     Perhaps you meant `forever' (imported from Control.Monad.Writer)
17:33:36 <sipa> :t forever
17:33:37 <lambdabot> Monad m => m a -> m b
17:34:25 <gnuvince> dcoutts_: I don't understand what you mean.
17:34:44 <johnw> gnuvince: m [a], if you intend the list to be infinite, would never return
17:34:49 <dcoutts_> gnuvince: I'm saying that what you're asking for is impossible
17:34:49 <shachaf> S11001001: If I remember correctly it exposes things like tail calls that C# doesn't.
17:34:53 <crdueck> whats the best way to compose a foldrWithKeysM :: Monad m => (k -> a -> b -> m b) -> b -> Data.Map.Map k a -> m b
17:34:59 <johnw> [m a] could return, but that's not the same as what you asked
17:35:16 <dcoutts_> gnuvince: since it'd have to perform an infinite number of IO actions
17:35:30 <dcoutts_> *before* returning the resulting list
17:35:33 <gnuvince> Let me ask more concretely then.
17:36:14 <gnuvince> I have a function randomMove :: IO Move, and I'd like to get a list of moves that I can then filter for incorrect sequences (exemple, I don't want the same move to appear twice in a row)
17:36:18 <nejucomo> dcoutts_: I reloaded the html after cabal finished, with: Installing library in /home/n/.cabal/lib/binary-0.6.4.0/ghc-7.4.1
17:37:08 <dcoutts_> nejucomo: but are you building with documentation enabled, so that newly installed packages will have docs built for them?
17:38:07 <nejucomo> I have "documentation: True" in ~/.cabal/config, and the cabal output says things like "updating documentation index".
17:38:37 <dcoutts_> nejucomo: mm ok, and can you see it calling haddock during the build?
17:39:29 <dcoutts_> gnuvince: I guess you have to decide how many moves ahead you want to look (either a number, or some condition, or check the filter condition incrementally)
17:40:07 <dcoutts_> gnuvince: btw, if all you're doing is randomness then there's no need to use IO, and then you can do it lazily, and have infinite sequences of moves.
17:40:21 <hpaste> Nejucomo pasted ‚Äúcabal install binary - haddock problem?‚Äù at http://hpaste.org/81399
17:40:32 <nejucomo> Ah, there were some warnings...
17:40:48 <nejucomo> Thanks for the help.
17:41:13 <dcoutts_> nejucomo: mm, that looks like it should have worked
17:41:48 <dcoutts_> nejucomo: the warnings are not a problem there really
17:43:03 <gnuvince> dcoutts_: by passing my own StdGen?
17:43:18 <dcoutts_> gnuvince: yes
17:43:25 <gnuvince> I'll look into it, thanks
17:44:20 <dcoutts_> gnuvince: imho, using getStdGen is always bad practice
17:44:38 <nejucomo> dcoutts_: Actually, the index appears inconsistent, unless I have both versions of binary installed and the older version "shadows" the newer.
17:44:47 <dcoutts_> newStdGen to make an initial rng value is fine, but then never use the "global" rng
17:45:27 <nejucomo> There is a single binary-0.6.4.0 link which I think it a new module (Data.Binary.Get.Internal), all the others refer to binary-0.5.1.0.
17:45:32 <dcoutts_> getStdGen/setStdGen is a global mutable variable, so e.g. cannot be used concurrently (sanely)
17:46:07 <dcoutts_> nejucomo: oh, hmm, that's plausible
17:46:31 <tac-tics> Is it "polite" to read from an email account once every 10 seconds via POP3?
17:46:40 <tac-tics> If I want to monitor email, is there a more appropriate way to do it?'
17:47:03 <Clint> tac-tics: IMAP IDLE?
17:47:26 <tac-tics> is that the standard way of doing things?
17:48:05 <Clint> it is the RFC 2177 way of doing what you want
17:48:42 <tac-tics> thank you. I'll look into it
17:49:30 <crdueck> whats the best way to compose a foldrWithKeyM :: Monad m => (k -> a -> b -> m b) -> b -> Data.Map.Map k a -> m b
17:49:52 <dcoutts_> nejucomo: mm, looking at the code, seems we pass all versions to haddock to make the index, rather than e.g. just picking the latest version of each package
18:04:48 <gnuvince> dcoutts: thanks for the tip, the new code is a lot more to my satisfaction than having IO functions everywhere
18:19:22 <YayMe> Does Cale still rove about here occasionally? I recall seeing him more often in the past than recent, also I couldn't find his blog the other day appeared to be gone
18:19:42 <shachaf> Yes, he's still here.
18:19:44 <shachaf> Lots of people are here.
18:21:10 <cmccann> I'm not here, though.
18:21:27 <shachaf> Obviously not. You're busy writing your book.
18:23:29 <cmccann> well, I am doing something that might possibly be tangentially related.
18:23:31 <cmccann> so there's that.
18:24:16 <shachaf> cmccann: Good point.
18:25:01 <cmccann> shachaf: did you read that paper about the stuff?
18:26:08 <shachaf> cmccann: Not yet. :-(
18:26:09 <pnielsen> oh, the paper about the stuff
18:26:16 <shachaf> Other people are also making me read papers about things.
18:26:26 <lispy> shachaf: In an ideal world it would be efficient and that probably means CIL. But I just want to see it work so C# or F# or VB.NET are all fine for that.
18:26:29 <shachaf> and imho things > stuff, so.......
18:26:38 <cmccann> pf, I bet they're not as interesting as the things.
18:26:44 <shachaf> lispy: I suspect CIL will be easier than C#.
18:26:45 <cmccann> er, the stuff.
18:26:56 <shachaf> It's meant to be compiled to, after all.
18:26:57 <lispy> shachaf: and there is a language.cil on hackage.
18:26:57 <cmccann> man, now I'm confusing myself about these things and stuff.
18:27:40 <shachaf> lispy: Did you see dons's thesis on compiling Haskell to Java?
18:27:57 <lispy> shachaf: his honors thesis? Yeah.
18:28:14 <lispy> shachaf: It's been a while, why do you mention it?
18:28:26 <shachaf> Might be relevant if you're compiling to C#.
18:28:27 <shachaf> I don't know.
18:28:28 <lispy> shachaf: David Wakeling and the UHC folks seem to have made the best progress.
18:28:40 * shachaf is very much not up to date.
18:28:54 <lispy> UHC has a CLR backend but I couldn't get the damn thing to compile and their build system is insane.
18:29:14 <shachaf> (I don't mean to suggest I ever was up to date.)
18:29:18 <cmccann> lispy: probably you didn't have enough things lined up in vertical columns.
18:29:18 <lispy> I might end up borrowing from them(?). Their code is BSD3.
18:30:01 <lispy> they wrote some tool called shuffle and then wrote some makefiles that confused me (I'm not a guru with make but I can stomach quite a lot)
18:30:17 <cmccann> lispy: did I ever show you my best makefile ever?
18:30:24 <cmccann> I probably did.
18:30:35 <lispy> I didn't look at it, but it does fractals or something?
18:30:38 <shachaf> lispy: You could always try doing it luite-style rather than messing with GHC code.
18:30:46 <cmccann> yes.
18:30:57 <lispy> what is luite style? parse external core?
18:30:58 <cmccann> mandelbrot makefile: https://github.com/isomorphism/esoteric-fractals/blob/master/Make/Makefile
18:31:10 <shachaf> lispy: Binding to the GHC API.
18:31:16 <cmccann> as you can see drawing fractals with make is in fact so easy.
18:31:19 <shachaf> And then generating JS from STG, or something.
18:31:46 <shachaf> luite would know more than I do about that. :-)
18:32:14 <lispy> shachaf: what does the GHC API give you in this case? The stg?
18:32:50 <shachaf> I think so.
18:32:57 <luite> yes
18:34:12 <lispy> cool
18:34:29 <lispy> I really don't know if STG is the right jumping off point. That seems to be what I'm converging on though.
18:35:05 <lispy> cmccann: that makefile is insane, but I suspect it's less insane than my reading of the UHC make file :)
18:35:27 <cmccann> lispy: it's well-commented and everything!
18:35:31 <cmccann> totally comprehensible.
18:36:12 <lispy> luite: are you the author of ghcjs?
18:36:47 <aristid> lispy: at least he does a lot of hacking on it:)
18:37:16 <lispy> I just assumed ghcjs was a fork of ghc. I didn't realize it's built separately
18:39:38 <luite> lispy: i hack on it, not the original author
18:40:17 <luite> lispy: yeah the "integrated build" is a patched GHC that generates javascript for all haskell that you compile
18:40:52 <luite> lispy: and there is a GHC API version that gives you a separate ghcjs compiler
18:41:00 <lispy> luite: Oh, so it can be built in either way? Either using ghc api to do it or integrated into ghc?
18:41:06 <lispy> cool
18:41:08 <luite> i use and work on the latter more :)
18:41:23 <lispy> any particular reason?
18:41:26 <luite> the problem with the integrated one is that the javascript code is really tied to your host platform
18:41:40 <luite> you can't do conditional compilation, no #ifdef __GHCJS__ or something
18:42:12 <luite> which makes supporting things a lot more annoying ont he javascript side
18:42:28 <lispy> Right. I was wondering about that.
18:42:44 <lispy> Hopefully as ghc becomes a cross compiler that will go away
18:42:51 <amiller_> i have a question about the recursion-schemes package and Applicative: the generalized forms of the schehes, cata, ana, etc., let an (F-distributive) monad or comonad be passed along as well
18:43:14 <amiller_> would it make sense to generalize gana to take an applicative rather than a monad
18:43:23 <fragamus> hey what are you guys using to shuffle a list?
18:43:33 <luite> lispy: might still be tricky, and GHC HEAD will probably need at least some more patches to make that work
18:43:37 * cmccann isn't sure doing anything with recursion-schemes qualifies as making sense
18:43:51 <cmccann> as far as I know edwardk pretty much disowned the whole idea :P
18:44:38 <luite> lispy: but i'd say both methods are kind of a hack, until cross compilation works properly
18:45:55 <luite> hopefully enough cross compilation stuff to support GCHJS on 64 bit will be in 7.8, but i doubt it, got zero replies on the mailing list :/
18:45:56 <amiller_> okay i'm glad i asked
18:46:43 <lispy> fragamus: I've never needed to do that, but IIRC Oleg has an article about it
18:46:58 <lispy> fragamus: http://okmij.org/ftp/Haskell/perfect-shuffle.txt
18:47:10 <amiller_> cmccann, i've found that recursion-schemes matches a bunch of papers i've read, especially this example http://www.kosmikus.org/GenericStorage/wgp10-genstorage.pdf and http://dreixel.net/research/pdf/sbdl.pdf
18:47:40 <cmccann> amiller_: it's neat stuff to be sure but I think the consensus among people who've worked on the concept is that anything beyond the elementary recursion schemes doesn't really carry its weight conceptually
18:47:41 <amiller_> does edwardk have a translation guide or something to what is preferred instead?
18:47:46 <amiller_> hm
18:48:40 <cmccann> anyway, you'll probably need to ask him yourself, it's been a while since I spent any time playing with recursion schemes stuff.
18:49:59 <cmccann> for your original question though I'd say that it probably makes sense if and only if you can implement it in a way that type checks, heh.
18:50:03 <YayMe> lispy: what are you talking about compiling to CIL? haskell?
18:50:33 <Eduard_Munteanu> Oh noes, comonad.com is down. :(
18:51:25 <cmccann> oh noooooo
18:51:33 <lispy> YayMe: yes
18:51:48 <YayMe> lispy: Have you seen ela?
18:51:49 <lispy> YayMe: I'm just learning about it right now.
18:51:54 <lispy> YayMe: link please
18:51:59 <YayMe> http://elalang.net/docs/Article.aspx?p=elaandhaskell.htm
18:52:17 <MercuryRising> what's the -> symbol called?
18:52:19 <YayMe> dynamically typed but many similarities to haskell (thus the name, as in (hask)ela
18:52:25 <YayMe> and compiles to CIL
18:52:39 <YayMe> just some brainy dude's side project
18:52:47 <shachaf> Back to It's called ->
18:52:49 <shachaf> Er.
18:53:04 <YayMe> but his compiler may lend ideas to how to compile haskellness to CIL
18:53:11 <YayMe> open source after all
18:53:40 <lispy> YayMe: cool. Thanks
18:54:12 <shachaf> cmccann: By the way the bug is at http://hackage.haskell.org/trac/ghc/ticket/7354
18:54:18 <YayMe> Can probably get in contact with the guy, all appearances are that no one knows he/it exists and he's done it 100% on his own, including the 60 page manual
18:54:22 <shachaf> (elliott found it.)
18:54:29 <shachaf> (Speaking of recursion-schemes.)
18:56:00 <YayMe> lispy: has somebody actually written a haskell->cil compiler that you're learning about or are you looking into doing it?
18:56:18 <lispy> YayMe: People have done it, but it's hard to find their source code
18:56:33 <lispy> YayMe: UHC has one but I've having trouble with UHC. I thought I would start exploring the GHC internals.
18:56:40 <YayMe> lispy: And you're looking to do it as well, or just use it?
18:56:42 <gertc> functa in category theorie is it the same as functor in haskell?
18:57:01 <lispy> YayMe: I'd like to do as little work as possible, buing a lazy programmer and all :)
18:57:34 <YayMe> then go write perl, that's what everyone says for lazy people right?
18:57:47 <YayMe> I shudder everytime someone throws that credo out there
18:57:53 <YayMe> people need to learn more programming languages
18:58:24 <Saizan> gertc: Functor in haskell is a special case of functor in category theory
18:58:38 <amiller_> i wonder if there is a cataA for an applicative algebra f a -> t a, in the sense that there is a cataM for a monadic algebra  f a -> m a
18:59:28 <Saizan> gertc: assuming Hask is the cateogory with haskell types as objects and functions as morphisms, then Functor f means that f is a category theory functor Hask -> Hask
19:00:12 <cmccann> (though it's also a functor from Hask to a subcategory of Hask whose objects are types of the form "f a")
19:00:15 <otters> turns out somebody has already done regex with parsec
19:00:26 <otters> and it's painfully slow...whoopee
19:00:51 <Eduard_Munteanu> cmccann: assuming the functor is injective, right?
19:01:18 <cmccann> Eduard_Munteanu: type constructors are trivially injective, essentially by definition.
19:01:56 <lispy> YayMe: heh. I find perl hard to read/write. Just like python.
19:02:07 <cmccann> that's also why you can't write a Functor instance for a type family or partially-applied type synonym.
19:02:24 <Eduard_Munteanu> Yeah, I was going to mention type families. :)
19:03:13 <cmccann> even though e.g. "type Rehtie b a = Either a b" is a perfectly reasonable functor, sending a type "a" to "Either a b".
19:03:26 <cmccann> and you can't write a proper identity functor &c. &c.
19:03:47 <cmccann> exploring category theory in haskell quickly becomes an exercise in newtype (un)wrapping
19:03:50 <Eduard_Munteanu> I forget, does LiberalTypeSynonyms save you here?
19:03:51 <gertc> Saizan: https://vimeo.com/17207564 29:10 ok so functa = functor :)
19:04:15 <Eduard_Munteanu> Ah, nevermind, I think not.
19:04:17 <Saizan> Eduard_Munteanu: no
19:04:18 <cmccann> Eduard_Munteanu: nope
19:04:56 <cmccann> first of all, it only helps if things would work when fully expanded, which this wouldn't
19:05:23 <Saizan> gertc: likely :)
19:05:24 <cmccann> second I don't think it works for instance declarations anyway
19:05:24 <Eduard_Munteanu> Yeah, when you right the instance it's still partially applied.
19:05:36 <johnw> cmccann: can Agda or Coq represent a proper identity functor?
19:05:54 <MercuryRising> how would you guys interpret
19:05:55 * hackagebot hArduino 0.2 - Control your Arduino board from Haskell.  http://hackage.haskell.org/package/hArduino-0.2 (LeventErkok)
19:05:56 <MercuryRising> ghci> :t (==)
19:05:58 <MercuryRising> (==) :: (Eq a) => a -> a -> Bool
19:05:58 <Eduard_Munteanu> Wait, what's wrong with the identity functor in Haskell?
19:06:00 <MercuryRising> in english? what does the bottom one say?
19:06:11 <johnw> Eduard_Munteanu: you need to wrap with Identity and unwrap with runIdentity
19:06:20 <cmccann> yeah
19:06:20 <johnw> Eduard_Munteanu: in category theory, the identity functor maps a -> a
19:06:40 <cmccann> if you can't write "fmap = id" it's not a true identity functor
19:06:58 <riley__> (==) takes two equitable "a's" and returns a bool
19:06:58 <Saizan> up to isomorphism!
19:07:09 <cmccann> johnw: also I dunno, ask copumpkin or something. he did a lot of abstract nonsense in agda I think.
19:07:49 <Saizan> johnw: anyhow yes, you can just use id at the right type actually
19:07:57 <Eduard_Munteanu> Isomorphism is equality anyway... yadda yadda :P
19:08:07 <Saizan> to get a function \x -> x of types
19:08:09 <cmccann> isomorphism is only equality up to isomorphism.
19:08:45 <MercuryRising> riley__: what does the chaining of the arrows mean? "a -> a -> bool" is everything before the last arrow an input, and the last one is the output?
19:09:11 <johnw> Eduard_Munteanu: [1,2] and (1,2) are isomorphic, but they are not equal
19:09:13 <Eduard_Munteanu> johnw: I think so
19:09:17 <cmccann> probably the trickier aspect in agda is that you don't have the simple guarantees of parametricity by default
19:09:19 <Eduard_Munteanu> Regarding Agda.
19:09:21 <lispy> a -> a -> Bool associates like a -> (a -> Bool)
19:09:29 <riley__> MercuryRising: I don't think you want to think of it that way.
19:09:42 <Eduard_Munteanu> johnw: I was paraphrasing some HTT stuff :)
19:09:46 <johnw> ah :)
19:09:54 <lispy> So it's a function that takes an 'a' and return a function (a -> Bool).
19:10:04 <lispy> You can also feed an 'a' to that to finally get a Bool
19:10:10 * cmccann should probably figure out wtf HTT is one of these days...
19:10:35 <Eduard_Munteanu> cmccann: you should check dolio's slides, it gives you a taste of what it is.
19:10:59 <cmccann> link?
19:11:04 <Eduard_Munteanu> http://comonad.com/reader/2011/homotopy-and-directed-type-theory-slides/   but check it when it's up
19:11:13 <riley__> MercuryRising: and you can also feed it two 'a' values and go straight to the bool.
19:11:16 <Eduard_Munteanu> Dunno if it's hosted somewhere else.
19:11:18 <Saizan> cmccann: you do have parametricity, you don't have injectivity
19:11:59 * cmccann shakes his fist. what is wrong with the world when websites go down?
19:12:36 <MercuryRising> hmmmm okay. what about one like this - addThree :: Int -> Int -> Int -> Int - you do some operation with three ints ,and get an int out?
19:13:03 <dolio> https://docs.google.com/file/d/0B8Kkr1O1jFwcNWRlMDZlMjctYzU0OS00NzQ4LTkwZjYtMGE4YWM1NDY2NTRl/edit
19:13:14 <Eduard_Munteanu> cmccann: found it via google... https://docs.google.com/viewer?a=v&q=cache:kMrub-a_IwQJ:comonad.com/reader/wp-content/uploads/2011/10/slides.pdf+&hl=en&gl=ro&pid=bl&srcid=ADGEESj16mH1m0iCWiGX5AcGwRtt2WuPD0HBfVluOKtj4ccS33wTWHQT0oKIkdudvEt0FesqmTY5sqxy3jncgmcqSwSJ6ZIfcx_fl9x_FJCRflrwjgzC-NvcQGUfWDzstQQfJhUjRACO&sig=AHIEtbTv3fCbTTPLBiJhrzdF6oZSdM5XMw
19:13:17 <riley__> MercuryRising: Or.. you do the operation with one int and get an operation that takes two ints and gives you an int.
19:13:19 <Eduard_Munteanu> omfg
19:13:57 <MercuryRising> what are these things called?
19:14:04 <riley__> MercuryRising: The key is to understand you can partially apply the function.
19:14:21 <riley__> MercuryRising: and get another function out of it.
19:15:09 <MercuryRising> so you could stop it before it completes?
19:15:55 <cmccann> dolio: thanks! :D
19:16:12 <riley__> MercuryRising: You're on the right track. You can just apply the first part, and then get a function that takes the rest. It's not really stopped, it's partially applied.
19:16:16 <cmccann> Eduard_Munteanu: and also thanks even if he beat you to it ;P
19:16:27 <arbn> johnw: Thanks for your help last night. I changed my FFI and C code to use single and double pointers instead of double and triple pointers, and now GHC no longer leaks memory, and the module compiles. :)
19:16:37 <johnw> arbn: excellent! :)
19:16:38 <Eduard_Munteanu> Oh, I haven't even seen his reply.
19:17:04 <MercuryRising> riley__: thanks, i'll have to smash my head against the table for a while longer before this stuff starts clicking
19:17:12 <riley__> MercuryRising: And you can apply it again and again, but to different inputs.
19:17:24 <riley__> > :t (+3)
19:17:25 <lambdabot>   <hint>:1:1: parse error on input `:'
19:18:38 <riley__> Darn you lambdabot... How do you work?
19:18:58 <Eduard_Munteanu> :t (+3)
19:19:00 <lambdabot> Num a => a -> a
19:19:05 <YayMe> I still remember accurately what Cale taught me one night (took 3-4 hours) a couple months ago about what makes a Group and the laws for it. That was bloody helpful just in starting to understand how to think about all of this math stuff I constantly read in haskell, the idea of an identity an inverse, what makes a set (loosely) and the laws of associativity/laws of commutativity
19:19:16 <riley__> :t +
19:19:18 <lambdabot> parse error on input `+'
19:19:22 <riley__> :t (+)
19:19:23 <lambdabot> Num a => a -> a -> a
19:19:30 <riley__> :t (+3)
19:19:31 <lambdabot> Num a => a -> a
19:19:41 <riley__> :t 3 + 3
19:19:42 <lambdabot> Num a => a
19:19:55 <riley__> MercuryRising: that is what I was going for :)
19:20:20 <MercuryRising> those are partially applied functions?
19:20:33 <YayMe> Helpful dude. Hope he's still about, surprised I still remember and understand what he explained.
19:20:55 <riley__> MercuryRising: To my limited understanding, the middle one is.
19:20:55 <Eduard_Munteanu> Yeah, he is.
19:21:47 <Eduard_Munteanu> (both helpful and about :D)
19:21:58 <riley__> MercuryRising: the interesting part is that you do  >>> let addThree = (+3)
19:22:03 <MercuryRising> okay that actually helps a lot, i was expecting it to go the other way (3 + 3) would be int -> int -> int
19:22:40 <riley__> MercuryRising: then you can do addThree 5 and on the next line addThree 2 and you are using your partially applied function with different inputs
19:32:54 <shachaf> MercuryRising: In Haskell, "partial application" is more a frame of mind than a thing that exists in the language semantics.
19:33:01 <shachaf> There's just "application".
19:35:00 <arbn> Yeah. I think I understood Haskell much better when I realized that all functions have one parameter. :)
19:35:03 * lispy tries to add a new compiler flag
19:35:31 <lispy> I found DynFlags and added a new constructor to HscTarget, does ghc have some magic to automatically parse that?
19:36:01 <luite> lispy: no, see ghc/Main.hs
19:36:13 <lispy> luite: thanks
19:41:02 <mikeplus64> hm, is there a "Stream" class somewhere? e.g. class Stream a b where readStream :: a -> IO a; writeStream :: a -> b -> IO ()
19:41:33 <mikeplus64> it would have instances for Chan and Handle
19:41:56 <shachaf> Sounds like an odd class.
19:43:37 <mikeplus64> also Socket and Connection
19:44:04 <mikeplus64> and the STM stuff if the class were a bit more general
19:44:45 <SamanthaD> I'm looking in hackage at the System.Directory package and it lists a function called findFile but when I load up the module and actually try to USE it it says that findFile is not in scope! (The other commands work fine)
19:45:01 <shachaf> SamanthaD: Maybe you have a different version.
19:45:15 <SamanthaD> shachaf: maybe...
19:45:26 <lispy> mikeplus64: I think tibbe was interested in making a class like that. Dunno if he bothered to work on it.
19:45:41 <shachaf> SamanthaD: Looks like it was only added in the latest version, 1.2.x
19:45:44 <shachaf> So it's probably that.
19:46:10 <mikeplus64> lispy: any idea of where i should look for that?
19:46:12 <Eduard_Munteanu> mikeplus64: is 'a' phantom in readStream?
19:46:15 <SamanthaD> shachaf: Oh! Thanks! Not worth updating. I'll just copy-paste the sourcecode ;)
19:46:30 <Eduard_Munteanu> I can't really tell how that type is useful.
19:46:35 <mikeplus64> Eduard_Munteanu: oops, i didn't mean a -> IO a
19:46:49 <Eduard_Munteanu> IO a ?
19:47:04 <mikeplus64> class Stream source a where readStream :: source -> IO a; writeStream :: source -> a -> IO ()
19:47:18 <Eduard_Munteanu> Ah, makes sense.
19:47:22 <mikeplus64> or even class Stream m source a where readStream :: source -> m a; writeStream :: source -> a -> m ()
19:48:58 <lispy> mikeplus64: sorry, I don't. He said one thing on G+ a few months back.
19:48:58 <mikeplus64> io-streams seems to provide something similar
19:49:26 <YayMe> anyone here into the Agda?
19:49:36 <Eduard_Munteanu> Sure. ;)
19:49:53 <Eduard_Munteanu> YayMe: in case you don't know, there's #agda too.
19:50:06 <YayMe> Oh that makes sense
19:50:33 <jfischoff> So lets say I have a comonad. Can I in general perform a context sensitive substitution, in a analogous way to how a monad lets me perform straightforward substitution?
19:50:52 <Eduard_Munteanu> #haskell ‚à© #agda   is probably the answer to your question :)
19:51:10 * jfischoff still doesn't really understand comonads
19:51:19 <edwardk> comonads are for 'redecoration' not substitution per se
19:51:30 <edwardk> you never change the shape of the structure with extend.
19:52:05 <jfischoff> can you redecorate a tree and then substitute to get more expressive subs?
19:52:08 <jfischoff> for instance
19:52:08 <YayMe> edwardk: I've heard this word "structure" used a few times in reference to applicatives/functors/monads, what exactly is referred to by this?
19:52:27 <Eduard_Munteanu> jfischoff: do you know zippers?
19:52:29 <johnw> YayMe: the list [1,2,3] has three values in it, and a structure of [_,_,_]
19:52:48 <jfischoff> x * x * x * y * y : sub x -> if x * x * x is the context
19:52:49 <johnw> functor/Comonad cannot alter the structure, but Monad can
19:53:20 <jfischoff> Eduard_Munteanu: I do and hear they related
19:53:23 <Eduard_Munteanu> jfischoff: there's a close connection between zippers on certain structure like trees and comonads
19:53:27 <jfischoff> they are
19:53:32 <edwardk> jfischoff: sure, but the relationship between redecoration and substitution for a given monad/comonad pair is rather adhoc
19:53:38 <jfischoff> ah
19:53:48 <edwardk> getting kicked out of the coffee shop. gotta run
19:54:56 <Eduard_Munteanu> jfischoff: see sigfpe's stuff on cellular automata, he implements it with a comonad. Compare to zippers on lists.
19:54:57 <YayMe> haha
19:56:15 <Eduard_Munteanu> jfischoff: there it is... http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
19:56:16 <jfischoff> @tell edwardk I'm curious if there is an well known abstraction that captures complex substitution in monomials (replace x^2 with 1) , of If I need to make my own Subs typeclass
19:56:16 <lambdabot> Consider it noted.
19:56:25 * jfischoff is reading
19:56:31 <Eduard_Munteanu> jfischoff: now don't tell me that doesn't look a lot like a zipper :)
19:56:39 <jfischoff> thanks Eduard_Munteanu:
19:57:54 <YayMe> > Left 4 >>= \x -> Left [x,x]
19:57:55 <lambdabot>   No instance for (GHC.Num.Num [t0])
19:57:55 <lambdabot>    arising from a use of `e_14'
19:57:55 <lambdabot>  Possibl...
19:58:03 * Eduard_Munteanu has to go as well, zzzzz
19:58:18 <YayMe> > Just 4 >>= \x -> Just [x, x]
19:58:20 <lambdabot>   Just [4,4]
19:58:41 <YayMe> johnw: So a monad can change the structure, is that an example?
19:58:47 <johnw> YayMe: yes
19:58:57 <shibby> what is the best word to describe an array which only holds a limited qty of elements? 1) fixed 2) static 3) closed 4)  other: _____ ?
19:59:16 <johnw> > [1,2,3] >>= \x -> [1,2]
19:59:18 <lambdabot>   [1,2,1,2,1,2]
19:59:20 <Eduard_Munteanu> shibby: finite?
19:59:22 <gridaphobe> fixed sounds good
19:59:32 <johnw> the structure has gone from [_,_,_] to [_,_,_,_,_]
19:59:34 <shibby> whoa, finite is good too
19:59:43 <shibby> Eduard_Munteanu: where did you pull from for that?
19:59:52 <YayMe> johnw: a comonad may not? Are there any instances of comonad in haskell?
19:59:56 <Eduard_Munteanu> Although I can't really imagine infinite arrays, plain arrays.
20:00:02 <johnw> YayMe: Store is an excellent comonad
20:00:05 <Eduard_Munteanu> shibby: finite/infinite lists ...
20:00:07 <johnw> YayMe: and no, it cannot
20:00:19 <johnw> YayMe: a mapping which cannot alter structure is called a "homomorphism", if you ever see that word come up
20:00:26 <YayMe> johnw: what does an instance of comonad implement?
20:00:34 <johnw> YayMe: extract, and extend
20:00:37 <johnw> YayMe: see Control.Comonad
20:00:45 <johnw> extract = coreturn, extend = cobind
20:00:51 <shibby> Eduard_Munteanu: i think finite is common for math application
20:01:10 <Eduard_Munteanu> Yeah, it does sound mathy.
20:01:10 <YayMe> johnw: Yeah, I have heard the term
20:01:17 * Eduard_Munteanu goes now
20:01:51 <shibby> what would the opposite of finite be? infinite. but what's the opposite of fixed?
20:01:53 <shibby> dynamic?
20:02:04 <YayMe> :t extract
20:02:06 <lambdabot> Not in scope: `extract'
20:02:08 <shachaf> "dynamic array" is a pretty standard term.
20:02:33 <johnw> YayMe: however, beware of thinking of Functors and Monads in terms of a "structure"
20:03:32 <johnw> that particular analogy may work for things that behave like containers, such as List, but it is not general enough to provide a right intuition for the underlying abstraction
20:04:00 <johnw> many prefer the word "context"
20:04:24 * shachaf doesn't like "context" much, but whatever.
20:04:33 <johnw> shachaf: what do you typically use?
20:04:43 <shachaf> For what?
20:05:09 <shachaf> ("context" is fine for some specific things. Maybe for comonads? I don't know. For a lot of monads it's pretty bad.)
20:05:16 <johnw> to talk about the "f" and "m" in "Functor f => f a" and "Monad m => m a"?
20:05:30 <shachaf> Well, "IO String" is not a String with context.
20:05:48 <johnw> ok, that is a good example
20:05:56 <johnw> i love your /bin/ls quote :)
20:06:16 <YayMe> johnw: so like Just 4 -> Just Left 4 changes "structure" but is a bad understanding of the abstraction of maybe/either etc
20:06:26 <johnw> that doesn't change structure
20:06:30 <johnw> it goes from Just _ -> Just _
20:06:54 <johnw> a structure change would be going from Just 4 -> Right 4
20:06:58 <arbn> I think of it as "computational context", so "IO String" is a string produced as a result of IO. But, this shows the vagueness of the word "context", which suggests it's a poor term to use in explaining. :P
20:07:22 <YayMe> so like you said, bad intuition comes from thinking in structure
20:07:24 <lispy> luite: I found the place to add the flag and I think I found the place where I should branch off from the normal codegen. So I'm doing a build and the place where it should branch calls error. This should allow me to start inserting my code.
20:07:51 <YayMe> johnw: but Just 4 -> Just [4,4] changes structure you said and that's Just _ -> Just _
20:07:59 <johnw> YayMe: note that "structure change" is an operation performed by natural transformations, and that a natural transformation underlies the very heart of what a Monad is (>>= is based on a natural transformation)
20:08:01 <lispy> luite: I think I should have requested just a stage 2 build, but I typed 'make' without thinking that through.
20:08:22 <johnw> YayMe: think of outer structure, not inner structure
20:08:36 <YayMe> johnw: is Just 4 -> Just [4,4] not a structure change?
20:08:39 <johnw> > fmap (\x -> [x,x]) [1,2]
20:08:41 <lambdabot>   [[1,1],[2,2]]
20:08:45 <johnw> that's not a structural change
20:08:54 <johnw> a structure change would be to go from [
20:09:00 <johnw> from [_,_] to [_,_,_]
20:09:12 <shachaf> johnw: Do you think that talking about natural transformations actually helps?
20:09:14 <YayMe> > [[1],[2]] >>= id
20:09:16 <lambdabot>   [1,2]
20:09:23 <YayMe> that is structure change
20:09:26 <YayMe> I presume ?
20:09:38 <johnw> shachaf: I thought it was worth mentioning
20:09:46 <lispy> > concatMap id [[1],[2]]
20:09:47 <lambdabot>   [1,2]
20:09:56 <shachaf> johnw: Even when you define natural transformations in Haskell, you have to stretch things quite a bit before you see them fitting the shape of Monad.
20:09:58 <johnw> > fmap head [[1],[2]]
20:10:00 <lambdabot>   [1,2]
20:10:03 <johnw> not a structure change
20:10:12 <johnw> shachaf: ok
20:10:39 <shachaf> In particular you have one natural transformation from Id to m, and one from Compose m m to m, or something.
20:11:04 <shachaf> But no one talks about monads like that, and probably by the time you're comfortable enough to see the isomorphisms, you already have some intuition for the "simple way".
20:11:05 <johnw> yes, exactly that
20:11:14 <johnw> you have a point there
20:11:28 <johnw> i'm explaining something which, if my explanation were understood, wouldn't need explaining
20:11:36 <jfischoff> Is there a simple way to get the two adjunct functors that make up a monad?
20:11:48 <shachaf> Anyway, functors are a rather different thing from monads, and the intuition you can have about them is relatively limited.
20:11:52 <shachaf> The only real intuition you can have for all Functors in Haskell is covariance, which is a pretty general concept.
20:12:21 <YayMe> johnw: that's sort of the way all this shit seems to work.. If you *can* understand the explanation, you don't need to explain it
20:12:22 <johnw> shachaf: do you mean functors are rather different from monads in terms of Haskell?
20:13:01 <shachaf> I mean there's a lot more you can know about a monad than about a functor.
20:13:05 <johnw> ah
20:13:07 <shachaf> If that's all you know about something.
20:13:08 <Nisstyre> YayMe: in other words, everything is trivial
20:13:12 <Nisstyre> as long as you understand it
20:13:13 <shachaf> So you can have more intuition for it.
20:13:18 <johnw> Nisstyre: lol
20:13:22 <Nisstyre> http://mathworld.wolfram.com/Trivial.html
20:13:43 <YayMe> Nisstyre: I'm curious how people get there. I'm guessing just practice and exposure over time?
20:13:50 <Nisstyre> "There are therefore exactly two types of true mathematical propositions: trivial ones, and those which have not yet been proven. "
20:14:01 <johnw> YayMe: keep writing code, keep asking questions :)
20:14:02 <YayMe> I feel like that alone is getting me closer already on many sides...
20:14:32 <Nisstyre> YayMe: most of it is just learning what people mean by certain words
20:14:42 <Nisstyre> in other words, figuring out jargon
20:14:48 <arbn> YayMe: You have to be induced into the Haskellite Category Theory cult. There's a formal initiation during which you reach enlightenment.
20:14:48 <johnw> yes, a _lot_ of it is getting the terminology right
20:15:00 <johnw> but a fair bit is also building the right intuitions
20:15:17 <jfischoff> also have good examples
20:15:35 <shachaf> johnw: Only if you insist on using all this terminology.
20:15:50 <johnw> shachaf: I mean, even basic terminology, like functor
20:16:11 <Nisstyre> "homomorphism"
20:16:17 <shachaf> They use the word "functor" when you learn C++ too!
20:16:29 <johnw> for which I curse them
20:16:44 <shachaf> I don't think you need to know the word "homomorphism" to learn Haskell, for example.
20:17:11 <johnw> but you will keep seeing it in this channel
20:17:11 <Nisstyre> but it helps
20:17:14 <johnw> that's why I mentioned it
20:17:25 <johnw> especially since we were basically dancing around the word
20:17:52 <YayMe> shachaf: but these things make the higher level behaviours of haskell more intuitive and obvious, it would seem
20:18:00 <shachaf> I wasn't.
20:18:16 <johnw> not everyone explains things the same way that you do, shachaf
20:18:27 <YayMe> I didn't know shachaf explained things
20:18:41 <shachaf> Agreed.
20:20:18 <mikeplus64> tibbe: lispy said something about you working on a "Stream" typeclass (like class Stream m src a where readStream :: src -> m a; writeStream :: src -> a -> m ()), did that get anywhere?
20:20:26 <lispy> It's kind of a shame that teaching theory/math tends to get so hung up on jargon. I realize it's sort of unavoibale as we need a way to communicate.
20:20:36 <tibbe> mikeplus64: thinking about it, not actually working on it
20:21:14 <gertc> enriched category theory are does monad transformers? https://vimeo.com/17207564 1:04:00
20:21:19 <tibbe> gcollins is working on something
20:21:22 <mikeplus64> oh, ok. io-streams seems to get there but isn't released yet :(
20:23:01 <mikeplus64> gcollins?
20:23:40 <mikeplus64> oh, derp
20:26:22 <YayMe> How old is this category theory stuff in mathematics in general? I keep thinking in the math masters or phds I run into I might find someone who had some education in it but so far it hasn't happened, is it not generally taught yet because of how modern it is? That seems to be what people guess when I ask if they've heard of monads/comonads etc
20:27:40 <Nisstyre> shachaf: how would you explain why "f g = (g 1, g True)" is wrong, but "h = let g a = a in (g 1, g True)" is fine to a Haskell newbie?
20:27:51 <Nisstyre> (in case you didn't get that before my connection crapped)
20:28:23 <shachaf> How new are we talkin'?
20:28:27 <alec__> yayme, there is ##categorytheory
20:28:34 <shachaf> Nisstyre: (And what's the context?)
20:28:39 <Nisstyre> shachaf: let's say 3 weeks
20:28:54 <shachaf> Nisstyre: (Are you talking about monomorphism? The word in question was "homomorphism".)
20:29:19 <Nisstyre> I know, I'm just looking at what I consider something in Haskell difficult to explain to new people
20:29:30 <Nisstyre> which is how type inference works
20:29:51 <kurtis> I found some time to start playing around with Haskell and trying to dive into a couple of the web frameworks. Then, I ran into some issues with Cabal. After Googling and reading, it looks like Cabal introduces a bit of "dependency hell". I'm a bit turned off at the moment after trying to install/use both Yesod and Snap with no good results. Is there a light at the end of the tunnel? haha
20:29:59 <shachaf> Nisstyre: Well, this isn't just about type inference.
20:30:07 <shachaf> In Haskell 2010, you actually can't write that type.
20:30:19 <Nisstyre> right
20:30:25 <Nisstyre> it's about typing things in general
20:30:27 <arbn> kurtis: cabal-dev is a nice thing to tuse. Actually, I never do Yesod development without it.
20:30:29 <lispy> shachaf: are you sure?
20:30:33 <Nisstyre> actually
20:30:34 <arbn> to use*
20:30:41 <Nisstyre> can you do it with rankntypes?
20:30:42 <shachaf> lispy: Am I wrong?
20:30:48 <shachaf> Nisstyre: Yes. But that's not Haskell 2010.
20:30:53 <shachaf> Anyway, I think asking people to take some things on faith is reasonable.
20:31:03 <johnw> arbn: same here
20:31:04 <shachaf> I don't think that's the sort of code that someone brand new to Haskell would even try to write.
20:31:05 <shibby> i went with "fixed" to refer to an array which does not resize itself to accomodate added elements
20:31:13 <Nisstyre> shachaf: fair enough
20:31:14 <shibby> thank you everyone for your help with understanding arrays
20:31:18 <YayMe> kurtis: that's interesting, I've found cabal to be genuinely awesome
20:31:32 <lispy> shachaf: why would you not be able to type it in Haskell2010?
20:31:38 <shachaf> lispy: What's the type?
20:31:40 <lispy> shachaf: you mean the type of g?
20:31:41 <Nisstyre> lispy: try it
20:31:46 <shachaf> lispy: Oh, you can type it if instance Num Bool.
20:31:50 <shachaf> But I assume that's not what you mean.
20:32:05 <kurtis> arbn, cool. I'll check that out. Is it pretty mainstream? I don't want to veer too far off the beaten path since I'm sort of evaluating (sub-consciously) Haskell as a production language; not just a toy
20:32:07 <shachaf> Nisstyre: Rank-n rather confused me when I first encountered it. :-)
20:32:13 <Nisstyre> yeah making Bool and instance of Num would work
20:32:35 <Nisstyre> shachaf: I'm still a bit confused with it
20:32:38 <lispy> shachaf: okay. Now I see what you were talking about. Just had to make sure I understood.
20:32:41 <Nisstyre> but I think I understand the general idea
20:33:06 <kurtis> YayMe, yeah. The documents (for Yesod and Snap) make it look easy. In reality; not such a great time with these particular installs and even some run-time linker issues. Googling showed that I'm not alone on this by far
20:33:11 <shachaf> Nisstyre: The most helpful thing for me was to think of types as explicit arguments.
20:33:12 <lispy> > let f g = (g 1, g True) in f id
20:33:13 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Bool)
20:33:13 <lambdabot>    arising from the literal `1...
20:33:15 <arbn> kurtis: It just uses cabal to create an isolate package environment per project. If you've done Python, think of it as sort of like virtualenv.
20:33:24 <shachaf> Like e.g. Agda or Core do.
20:33:32 <shachaf> (Well, they don't do it the same way. But they both do it.)
20:33:36 <YayMe> kurtis: Also did you take time to learn some haskell before fidgeting with Yesod/Snap? Is there a reason you're trying to fiddle in haskell?
20:33:38 <lispy> big lambda
20:33:41 <arbn> kurtis: Among Yesod developers, I know it's very popular.
20:33:51 <shachaf> (By Core I mean System F.)
20:34:11 <shachaf> This also helps you understand existential types, and the correspondence between universals and existentials, and so on.
20:34:16 <kurtis> arbn, Awesome. I definitely appreciate virtualenv's so you made a great comparison ;)
20:34:47 <lispy> shachaf: I agree. Understanding how this stuff maps to System F is actually important at times.
20:35:10 <shachaf> I should read the paper cmccann linked me to.
20:35:19 <cmccann> yes.
20:35:35 <shachaf> Instead I'm procrastinating on this other thing I should be doing by talking in #haskell.
20:35:47 <Nisstyre> shachaf: I read over Cardelli's paper on type checking a while ago which helped me a lot
20:35:54 <Nisstyre> even though it's not system f
20:36:04 <shachaf> I haven't!
20:36:13 <shachaf> I know pretty much nothing about type checkers. :-(
20:36:18 <shachaf> (Except for the things I do know.)
20:36:21 <kurtis> YayMe, I've been reading on Haskell quite a bit. I haven't programmed anything exciting though. I figured I'd start with some web stuff for fun. I could have gone very simple (e.g. CGI) but I wanted to tour the web frameworks (and ecosystem) available. I am trying to take on a functional language and Haskell looks appealing
20:36:47 <shachaf> lispy: You know how encoding existentials in terms of universals is just a form of currying?
20:36:51 <shachaf> That's the best thing.
20:37:16 <cmccann> shachaf: type checkers are the things that you usually don't let you write unsafeCoerce.
20:37:35 <shachaf> cmccann: You mean don't let *other people* write unsafeCoerce.
20:38:07 <cmccann> how many have you written so far?
20:38:22 <shachaf> cmccann: The only reason I use a type checker is that I can feel more satisfied about doing unsafe things.
20:40:05 <YayMe> kurtis: What about functional makes you interested in it though? If you're interested in the functional aspect, I wouldn't start with a web framework/ecosystem stuff. Are you more just curious if there is a good enough ecosystem to make it worth learning?
20:42:00 <Nisstyre_> shachaf: this is the paper I was referring to http://lucacardelli.name/Papers/BasicTypechecking.pdf
20:42:12 <shachaf> Nisstyre_: I didn't know BASIC had types.
20:42:17 <lispy> shachaf: that sounds vaguely familiar.
20:42:32 <lispy> shachaf: I don't recall the transformation right now, but I think I've worked it out in the past
20:42:39 <NegressCounty> lispy  I have your answer regarding the River Laman in Nephi I
20:42:50 <shachaf> lispy: It's pretty simple.
20:42:50 <lispy> shachaf: you put the existential in the negative position?
20:42:54 <shachaf> Right.
20:42:56 <NegressCounty> there wouldn't be any official maps with the name of that river because Lehi named it in passing while camping temporarily
20:43:03 <NegressCounty> along the red sea before the voyage to the americas
20:43:11 <shachaf> lispy: An existential is like (a :: *, Foo a)
20:43:22 <lispy> NegressCounty: sorry, I don't recall what you're talking about.
20:43:31 <shachaf> So you CPS that to get forall r. ((a :: *, Foo a) -> r) -> r
20:43:44 <NegressCounty> remember that the tablets were revealed to Joseph Smith by the Angel Moroni
20:43:54 <NegressCounty> and the record of what happened before the voyage
20:43:54 <shachaf> I.e. (r :: *) -> ((a :: *, Foo a) -> r) -> r
20:43:58 <NegressCounty> stayed with Lehi
20:44:01 <shachaf> Now you can just uncurry the two arguments.
20:44:06 <NegressCounty> and was carried over, so there would be no official naming of that river
20:44:08 * lispy wonders if we're going to need ops
20:44:09 <kurtis> YayMe, Well; primarily I'm a Web Developer although I really appreciate the Science/Art of Computation. I had a bit of exposure to Functional Programming (in Scheme) back when I was in school. The only thing that really draws me into functional coding is the different mindset used to solve problems. I think it will help me become a better developer and problem solver. As far as Haskell; I really like the Strong typed system and GHC's pe
20:44:10 <kurtis> rformance; otherwise I can't make much more of a comparison to other FPLs. And yes, I want to find out if Haskell is something I could integrate in to my own profession or possibly even be a valuable asset in the industry.
20:44:18 <shachaf> (r :: *) -> ((a :: *) -> Foo a -> r)
20:44:24 <shachaf> -> r
20:44:38 <shachaf> Now you don't have any existentials anymore! It's just two universals.
20:44:45 <shachaf> forall r. (forall a. Foo a -> r) -> r
20:45:15 <cmccann> existentials no longer existing. how very zen.
20:45:35 <lispy> shachaf: oh you're talking about translating Haskell existentials to System F
20:46:08 <shachaf> lispy: No, I'm just talking about reasoning about existentials and universals in terms of explicitly passing types.
20:46:10 <lispy> Well, I guess that's not quite right
20:46:18 <shachaf> The thing we ended up with is just Haskell.
20:46:24 <shachaf> (Well, rank-2 Haskell.)
20:46:35 <lispy> That's what I was getting out but after I thought about it more I realized you were actually going for what Haskell does.
20:46:37 <cmccann> hooray, de morgan duality!
20:46:45 <NegressCounty> lispy...
20:46:51 <shachaf> cmccann: Your book is going to talk about things like that, right?
20:46:52 <NegressCounty> you were trying to disprove the book of mormon
20:46:58 <shachaf> @where ops
20:46:58 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
20:46:58 <lambdabot> xerox
20:47:02 <NegressCounty> by saying that there wasn't any historical record of river laman
20:47:10 --- mode: ChanServ set +o copumpkin
20:47:13 <NegressCounty> but the point is that Lehi named it in passing before leaving the area for good
20:47:13 <cmccann> shachaf: which that is this again
20:47:14 --- mode: ChanServ set +o glguy
20:47:21 --- mode: copumpkin set +b *!~NegressCo@207-119-113-235.dyn.centurytel.net
20:47:21 --- kick: NegressCounty was kicked by copumpkin (No. Bad.)
20:47:23 <lispy> glguy: thanks
20:47:34 <lispy> er
20:47:36 <shachaf> Thanks for becoming +o, glguy!
20:47:37 <lispy> copumpkin: thank you :)
20:47:44 * glguy sets mode +highfive copumpkin
20:47:44 --- mode: copumpkin set -o copumpkin
20:47:46 <copumpkin> oh shit
20:47:51 * copumpkin high-fives glguy
20:47:51 <shachaf> cmccann: Any of them.
20:47:53 * lispy thanks all the ops
20:48:14 <copumpkin> :)
20:48:15 --- mode: glguy set +b *!*@207-119-113-235.dyn.centurytel.net
20:48:22 --- mode: glguy set -b *!~NegressCo@207-119-113-235.dyn.centurytel.net
20:48:26 <glguy> :-p
20:48:28 --- mode: glguy set -o glguy
20:48:42 <lispy> ....and back to stealthmode
20:48:57 <lispy> luite: still around?
20:49:04 <Nisstyre-laptop> For some reason my desktop's connection keeps crapping out so I have switched to the laptop
20:49:06 <lispy> luite: I added a file to the ghc tree and now I'm getting make errors.
20:49:06 <kurtis> Did that really just happen? haha
20:49:10 <Nisstyre-laptop> should stop me rejoining every 10 minutes
20:49:25 <YayMe> kurtis: valuable asset in the industry because it'll help you solve problems in new ways, but otherwise don't expect to integrate it into your career unless you really go bananas and become a category theorist so you can get a job at galois or as a quant. That said, the ecosystem is rather complete for whatever you'll want generally. So go ahead and learn yesod if you want to do stuff yourself but won't find jobs doing (unless you're
20:49:25 <YayMe> extremely lucky), otherwise I would suggest playing in a lib to learn haskell for the benefits learning it yields
20:49:35 <cmccann> YayMe: to answer an earlier question, category theory originated somewhere around the 1950s I think
20:49:52 <cmccann> YayMe: but keep in mind that the haskell perspective on it isn't representative of the field as a whole
20:50:29 <YayMe> cmccann: yeah, but someone who learned category theory in school from math would know of a monad / comonad / group etc no?
20:50:36 <YayMe> Or would those not be particularly familiar to them?
20:50:42 <Nisstyre-laptop> YayMe: they'd have a different idea of what it is
20:50:45 <YayMe> (even though haskell's version of them is different)
20:50:46 <cmccann> for instance, if you google for "comonad" most of the hits are haskell-related
20:50:48 <copumpkin> YayMe: they probably wouldn't have any clue how they apply to programming
20:50:49 * lispy added it to the .cabal file but isn't sure where else it must be mentinode
20:50:57 <cmccann> sigfpe and edwardk's blogs, hackage, &c.
20:51:08 <geekosaur> part of the problem is that, even for mathematics, category theory is somewhat "out there"
20:51:09 <tac> YayMe: monads are a pretty standard concept in CT. And groups are childs play compared to categories :o
20:51:26 <YayMe> copumpkin: That's true of most mathematicians compared to software engineers I would guess, hell programmers don't usually know how that stuff relates
20:51:40 <shachaf> If I want to mention a (probably simple) language extension that should be in GHC, what would be the right place to post it?
20:51:51 <shachaf> The GHC Trac? glasgow-haskell-users@?
20:52:05 <YayMe> tac: so again my question of, is CT commonly taught in schools to people studying math these days or is it still too new?
20:52:24 <lispy> luite: n/m. I modified ghc.cabal instead of ghc.cabal.in
20:52:28 <Nisstyre-laptop> YayMe: it doesn't seem like it would be in a typical undergrad's curriculum
20:52:36 <cmccann> YayMe: it's probably also going to depend on the individual, but I'm not sure how much most mathematicians focus on narrow subfields
20:52:38 <YayMe> Nisstyre-laptop: I'm not referring to undergrad
20:52:39 <Nisstyre-laptop> YayMe: my school offers a Haskell course w/ some category theory
20:52:41 <tac> YayMe: CT is advanced mathematics. It wouldn't be taught until late in a college level math cirriculum if at all
20:52:45 <Nisstyre-laptop> and that is undergrad
20:52:48 <Nisstyre-laptop> YayMe: okay
20:53:00 <tac> YayMe: also, category theorists, from what I understand, pissed a lot of mathematicians off back in the 70s
20:53:19 <tac> Because they did what mathematicians really hate.... they tried advocating something that wasn't exactly set theory.
20:53:25 <tac> and talked a lot about foundations
20:53:43 <Nisstyre-laptop> tac: I don't think category theory is *that* hated, is it?
20:53:51 <Clint> shachaf: should it be in ghc before it goes to haskell-prime?
20:53:56 <YayMe> I've spoken to 6 or 7 masters/phds in math in the past year since starting to study haskell and asked each one, and nary a one even heard of the term monad/comonad or knew of lambda calculus
20:54:04 <shachaf> Clint: I think that's the standard path?
20:54:06 <YayMe> I just find that very interesting
20:54:09 <shachaf> Also haskell-prime is dead.
20:54:12 <Clint> ok
20:54:14 <cmccann> lambda calculus is very much a computer science thing.
20:54:18 <tac> Nisstyre-laptop: I would say it's less liked than most areas of math, from what I've seen
20:54:20 <Nisstyre-laptop> YayMe: well combinatory logic isn't something someone who doesn't study mathematical logic or computer science would know
20:54:21 <cmccann> monads are all over the place in CT though.
20:54:28 <shachaf> I'll just make a ticket.
20:54:39 <tac> cmccann: We should make lambda calculus an all-of-math thing some day
20:54:49 <YayMe> cmccann: Ah, I didn't realize lambda calculus wasn't a math thing, it's a calculus so I just assumed
20:54:56 <Nisstyre-laptop> YayMe: it is
20:54:59 <cmccann> it was originally.
20:55:05 <tac> YayMe: calculus is a term borrowed from formal logic
20:55:14 <Nisstyre-laptop> calculus just means a formalized system of logic
20:55:20 <YayMe> but the original form isn't taught in math programs?
20:55:30 <cmccann> combinatory logic and lambda calculus were created before computer science was
20:55:33 <kurtis> YayMe, True. I don't expect to land a job as a Haskell coder; but I believe it might be beneficial to develop custom applications in a FPL. And I agree, solving problems in new ways is my motivation here. I was hoping (and still am) that Haskell might be something I could use predominantly but cabal is making this very difficult. I imagine part of it has to do with my sheer inexperience in using cabal but it sort of appears "immature" (
20:55:33 <kurtis> development-wise). While cabal isn't Haskell, I'm assuming it is very commonly used with Haskell and I'm hoping my experience doesn't represent the overall haskell community
20:55:37 <YayMe> (again, not undergrad, I presume undergrads don't know anything)
20:56:00 <Nisstyre-laptop> the interest in formal systems of logic began in the late 1800s with Frege
20:56:04 <cmccann> also, both lambda calculus and combinatory logic come from formal logic.
20:56:11 <liyang> YayMe: I was taught it in the last year of my maths undergrad during a course of "Logic, Sets and Computation"
20:56:12 <cmccann> if you can find a logician, they'll probably know about them.
20:56:14 <Nisstyre-laptop> then Hilbert/Turing/Goedel/etc...
20:56:25 <YayMe> liyang: ah cool
20:56:31 <tac> then Church :O
20:56:34 <Nisstyre-laptop> read up on Hilbert's program
20:56:39 <YayMe> cmccann: How does a logician differ from a mathematician?
20:56:42 <liyang> YayMe: but it's often omitted in many maths undergrads.
20:57:02 <liyang> YayMe: one is a subset of the other, depending on whom you speak to.
20:57:05 <cmccann> YayMe: some logicians are also philosophers
20:57:09 <tac> YayMe: formal logic is a branch of mathematics. So a logician is a mathematician who studies logics.
20:57:18 <dolio> Most mathematicians don't study logic in much detail.
20:57:21 <tac> also, yeah... there is a philosophy crossover
20:57:22 <dolio> That's the difference.
20:57:36 <Nisstyre-laptop> also there are not many Fields medalists who are logicians
20:57:45 <Nisstyre-laptop> Paul Cohen is the only one who comes to mind
20:57:45 <cmccann> formal logic ends up being a subfield of mathematics and philosophy that nobody outside of it cares much about :P
20:57:47 <tac> Some schools group logic together with the philosophy department.... it's kinda gross
20:58:20 <Nisstyre-laptop> imho logic is the most interesting branch of math
20:58:32 <kurtis> ^^ agreed
20:58:33 <cmccann> tac: why? plenty of philosophers have made worthwhile contributions.
20:58:38 <liyang> tac: while others lump them with computer science.
20:58:48 <cmccann> the stanford encyclopedia of philosophy has nice articles on formal logic, as well.
20:59:40 <Nisstyre-laptop> there were lots of philosophers who were logicians and mathematicians. Frege is sometimes called the father of analytic philosophy, Hilary Putnam was a computer scientist, Russell obviously, etc..
20:59:41 <tac> cmccann: I guess it depends on what kind of philosopher you are. If you're willing to typecheck your claims, then I guess you have some potential to say something worthwhile.
21:01:03 <Nisstyre-laptop> going even further back, Leibniz was a philosopher
21:01:36 <tac> I think everyone should have their own philosophy on the subject, but it should not be anyone's major contribution :P
21:01:42 <geekosaur> that's getting back into an era of different terminology, though, isn't it?  cf. natural philosophy
21:01:57 <Nisstyre-laptop> geekosaur: somewhat, but he did traditional philosophy like metaphysics and ontology
21:02:02 <cmccann> if you look at most of the major figures in logic, they were philosophers as well as mathematicians
21:02:06 <Nisstyre-laptop> not just natural philosophy
21:02:06 <jfischoff> Boolos is good too
21:02:27 <geekosaur> most of them did, though
21:02:47 <geekosaur> modern scientists tend to be a bit aghast at what Newton spent much of his time on...
21:02:52 <Nisstyre-laptop> geekosaur: to a lesser extent. Also the RS was very enlightenment oriented in my opinion
21:03:01 <Nisstyre-laptop> that is, they were dismissive of wishy-washiness
21:03:07 <lispy> kranius: I think you'll find that the community has many very intelligent and self-motivated folks. Sadly, those kind of people often aren't interested in the infrastructure work. So, unlike the, say ruby community, we don't get a lot of people pitching in to help with cabal.
21:03:10 <tac> My philosophy basically goes like this: church-turing is obviously true, axiom of choice is obviously false, LEM only when you can't be bothered
21:03:22 <lispy> kurtis: ^^ oops meant that for you not kranius
21:03:27 <Nisstyre-laptop> they wanted to axiomatize all of natural language ffs
21:04:23 <tieTYT2> as far as I can see, these both have the same result.  Is there a reason to prefer one over the other? http://hpaste.org/81402
21:04:40 <Nisstyre-laptop> geekosaur: wrt Newton's alchemy, it wasn't as bad as people think, and he eventually gave up on ascribing any occult causes to gravity or other phenomena
21:04:44 * Nisstyre-laptop wrote a paper on this
21:04:53 <dolio> Lots of stuff gets grouped into philosophy, and then gets spun off once it becomes well established enough.
21:04:53 <kurtis> My motivation to learn a functional language is to learn to solve problems in new ways, potentially increase my efficiency as a developer, try something new, and apply this experience and knowledge to my field. In your honest opinions; do you think ignoring the other FPLs and landing on Haskell is a good idea? Or are there pros/cons (other than Lazy Eval + Strong Typing) to using other languages and ecosystems given my motivation?
21:05:09 <lispy> tieTYT2: I think the second one is nicer to read, but no I don't see any reason to prefer one over the other
21:05:22 <YayMe> kurtis: Then stop fiddling with yesod and start with the basics
21:05:32 * cmccann points to http://plato.stanford.edu/entries/logic-intuitionistic/ as evidence that at least some philosophers care about logic.
21:05:35 <tieTYT2> lispy: ok, i care a lot about readability so that's good to know
21:05:37 <YayMe> kurtis: Did you read LYAH?
21:05:42 <dolio> That doesn't necessarily mean that it's still appropriate to group it under philosophy after that point.
21:06:06 <kurtis> lispy, haha thanks. And that definitely makes sense. At least there's room in the community for average-IQ people like myself to contribute then :)
21:06:17 <lispy> tieTYT2: My brain sees a $ and says, "this thing on the left goes over all this on the right" but when I see a (.) I just thing, "pipeline here, feeding from the right"
21:06:21 <YayMe> cmccann: You say most everyone outside of logic ignores the subfield, is that a matter of it's a subfield that doesn't actually produce solutions. Like solving physics problems or some such
21:06:42 <tieTYT2> are there ever situations where you can't use $ to replace .  ?
21:06:54 <cmccann> I was mostly being glib about the tendency of people to specialize heavily.
21:06:59 <lispy> kurtis: heh. I didn't mean for that to be an implication about individual preferences or IQ.
21:07:00 <dolio> tieTYT2: Yes.
21:07:02 <tieTYT2> lispy: that's really helpful for me to know how you think about it
21:07:10 <kurtis> YayMe, Actually, I read quite a bit. And it's not so much that I'm trying to fiddle with yesod, it's that I'm leary of investing too much time into learning a language where I won't be able to put it to good use because of things above my head
21:07:18 <geekosaur> kurtis, in some ways knowing a lot is a bad thing when coming to Haskell for the first time; it's different enough that you have to "unlearn" a lot of things...
21:07:30 <wavewave> hi
21:07:42 <dolio> tieTYT2: foo $ bar . baz
21:07:59 <lispy> tieTYT2: if you haven't already noticed, if you're reading haskell source for data flow you need to read left to right and right to left depeding on context. Keeping the flow going in a consistent way can help with readability.
21:08:15 <kurtis> YayMe, like running into these issues with cabal, and any unforeseen issues
21:08:20 <monochrom> > map $ not . even $ [0,1,2,3,4]
21:08:22 <lambdabot>   Couldn't match expected type `a0 -> b0'
21:08:22 <lambdabot>              with actual type `GHC....
21:08:49 <dolio> monochrom: Doesn't work like that, unfortunately.
21:08:49 <monochrom> oh, of course
21:08:54 <lispy> kurtis: maybe you could learn Haskell by working on cabal ;)
21:09:04 <Nisstyre-laptop> > any even [0..4]
21:09:06 <lambdabot>   True
21:09:12 <monochrom> > (map $ not . even) [0,1,2,3,4]
21:09:14 <lambdabot>   [False,True,False,True,False]
21:09:29 <kurtis> YayMe, I think it's sort of breaking down into this. I want to learn a FPL that is both awesome and practical. Hopefully Haskell, and its related toolset/libraries/ecosystem, are practical. That's the factor I'm not sure of
21:09:40 <pro-tip> the difficulty of learning Haskell is greatly exaggerated
21:09:59 <monochrom> the need to eliminate (.) is also overrated
21:10:12 <dolio> Why would you eliminate (.)?
21:10:13 <Nisstyre-laptop> I use (.) in almost every program
21:10:28 <kurtis> lispy, Very true !
21:10:39 <lispy> "monochrom: Enemy of composition!"
21:10:45 <lispy> (not really)
21:11:17 <shachaf> OK, I just filed a feature request.
21:11:26 <shachaf> I think that's the standard way to do it.
21:11:30 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/7633
21:11:31 <tieTYT2> i'm just a little concerned with the way I wrote my code in the paste above that might mean I'm thinking about composition and function application some wrong way.  But maybe the fact that I could write it that way just means it was a bad example for the book to give me
21:12:15 <YayMe> kurtis: Practical for freelance stuff you do on your own absolutely, but you'll likely never get to do it in a company. A little fidgetting though and you'll definitely be able to do stuff for yourself
21:12:57 <kurtis> YayMe, well that's great! Maybe I'll push through these issues with Cabal, try to learn something, and get started. Thanks
21:16:08 <wavewave> haskell is difficult because programming in a correct way is difficult
21:19:47 <wavewave> before I learn haskell, I never thought about safety in programming. once I started to know what's the safety, holy shit! I just got enlightened.. ..... and it's very hard.
21:20:07 <shachaf> monoids are so easy
21:20:10 <shachaf> are they unsafe? :(
21:20:40 <wavewave> monoids are easy. yeah. ...
21:20:51 <shachaf> i love them
21:21:48 <Nisstyre-laptop> wavewave: how long have you been using Haskell?
21:22:11 <Nisstyre-laptop> have you seen Data.Dynamic yet? ;)
21:22:21 <wavewave> Nisstyre-laptop : since 2009
21:22:24 <Nisstyre-laptop> ah ok
21:22:39 <wavewave> I am in ghc-6.10 generation
21:22:52 <Nisstyre-laptop> wavewave: what's your opinion on some of the criticisms of Haskell by Robert Harper?
21:23:04 <pro-tip> I'm in the 5.04 generation
21:23:27 <Nisstyre-laptop> e.g. http://existentialtype.wordpress.com/2012/08/14/haskell-is-exceptionally-unsafe/
21:23:30 <shachaf> Remember GHC 6.6? That was a good release.
21:23:35 <shachaf> I actually started using Haskell after 6.6
21:23:38 <wavewave> Nisstyre-laptop: no opinion. I feel that I don't know enough to say something. ;-P
21:23:42 <shachaf> But I was using very old packages.
21:25:43 <jfischoff> Nisstyre-laptop: http://axisofeval.blogspot.com/2012/07/when-i-read-blog-post-by-robert-harper.html
21:26:14 <wavewave> I guess that Robert Harper has a valid point. judging from his expertise.
21:27:02 <lispy> as bos said, harpers gonna harp
21:27:16 <Nisstyre-laptop> jfischoff: lol
21:27:24 <wavewave> but that haskell is unsafe in his opinion does not mean SML is safe or others are as safe as haskell
21:27:34 <Nisstyre-laptop> jfischoff: I do like his post on concurrency and parallelism though
21:27:47 <Nisstyre-laptop> but Simon Marlow wrote the same post better imo
21:28:16 <jfischoff> I thought his post on the cost estimation of strict verse lazy might be true, but sort of misses the point
21:28:17 <kurtis> cabal-dev seems pretty cool. Of course, snap failed to finish (ran into some weird error in one of its packages). "yesod" finished but I should have installed "yesod-platform"  and it complains about "following packages are likely to be broken by the reinstalls". Are these sorts of issues common?
21:28:28 <geekosaur> sadly
21:28:49 <jfischoff> er strict versus non-strict I mean
21:29:13 <kamatsu> kurtis you probably want to kill off the old yesod install you did, then cabal-dev install yesod-platform
21:29:21 <tieTYT2> why does this work: *Main> :module - Data.List ; *Main> nub [1..100]
21:29:31 <wavewave> ideally, we need to make some good way to elevate strict / non-strictness in type system.. but nobody knows how to do that 'correctly'
21:29:37 <tieTYT2> i'm guessing it's because I loaded a module that imports Data.List
21:29:44 <shachaf> tieTYT2: That's correct.
21:29:46 <tieTYT2> so ghci ignores my :m -
21:29:54 <shachaf> Data.List isn't imported by ghci
21:29:58 <kurtis> kamatsu, thanks. I'll give that a shot.
21:30:01 <shachaf> Notice how the prompt would change if you :m + Data.List
21:30:25 <kurtis> Do you guys happen to know where cabal-dev stores its packages?
21:30:44 <arbn> It's a dot directory in the project folder.
21:30:52 <kurtis> Same place as the normal .cabal install?
21:31:04 <arbn> kurtis: "ls .*" from your project folder. You'll see it.
21:31:04 <kurtis> s/install/packages
21:31:05 <wavewave> whenever I see some partial functions, I feel obligated to eliminate it, but that's fairly hard in many cases.
21:31:36 <Nisstyre-laptop> jfischoff: that blog is awesome
21:31:38 <kurtis> arbn, Yeah. All I have is the .cabal directory
21:32:03 <arbn> kurtis: That's it. Normal cabal puts all packages in the .cabal in ~.
21:32:04 <kamatsu> kurtis, cabal-dev stores the sandbox in the project directory you're running it in
21:32:17 <kamatsu> cabal puts it in ~/.cabal
21:32:17 <jfischoff> Nisstyre-laptop: yeah its fun
21:32:50 <kurtis> kamatsu, you're right! I was looking for a hidden (dot) folder, I didn't realize it just created cabal-dev haha
21:32:52 <kurtis> thanks guys
21:34:58 <wavewave> btw I need to talk about why haskell in front of a bunch of c++ enthusiasts. I have to think about how to attack.
21:35:19 <edwardk> jfischoff: you're probably stuck making something up
21:35:20 <kamatsu> type safety
21:35:25 <shachaf> wavewave: Maybe kmc's slides would help.
21:35:28 <shachaf> @where why-haskell
21:35:28 <lambdabot> I know nothing about why-haskell.
21:35:45 <wavewave> what's kmc's real name?
21:35:46 <shachaf> @where why-learn-haskell
21:35:46 <lambdabot> I know nothing about why-learn-haskell.
21:35:51 <shachaf> Keegan.
21:36:01 <shachaf> @where+ why-learn-haskell http://ugcs.net/~keegan/talks/why-learn-haskell/talk.pdf
21:36:01 <lambdabot> I will remember.
21:36:02 <wavewave> thanx
21:36:21 <shachaf> He made a point of not emphasizing type safety, actually, if I remember correctly.
21:38:02 <wavewave> yeah.. looks like
21:38:30 <wavewave> sometimes type safety is hard to be appreciated
21:38:39 <lispy> "Types catch mistakes but stay out of your way otherwise" <-- I disagree.
21:38:47 <lispy> Types catch mistakes, but they don't stay out of your way.
21:38:58 <lispy> They are a very handy crutch for designing
21:39:19 <lispy> And if you try to ignore them they will certainly feel "in the way"
21:39:21 <shachaf> monoids are so easy
21:39:48 <wavewave> at least I got enlightened only after I started making a big program.
21:40:07 <YayMe> shachaf: monoids are groups sans one law... right? which one is it, associativity or inverse?
21:40:23 <wavewave> associativity.
21:41:02 <quux> > [a],[b],[c] = "abc"
21:41:04 <YayMe> wavewave: I need to start on the big program to really get my haskelling tightened down, but I have no large program to work on.
21:41:04 <lambdabot>   <hint>:1:4: parse error on input `,'
21:41:19 <quux> > [a] [b] [c] = "abc"
21:41:20 <lambdabot>   <hint>:1:13: parse error on input `='
21:41:29 <quux> blah, still green.
21:41:34 <wavewave> YayMe: just do something simple and make it more complex and complex.
21:41:58 <wavewave> there are no 'big' prolem from the beginning
21:42:05 <YayMe> fair enough
21:42:28 <wavewave> for example, start your own build script.
21:42:42 <YayMe> wavewave: wrote a stupid C# parser that grabs some simple info, perhaps I should grow that to create a more complete parse-tree
21:42:54 <wavewave> I can say that within a few month it becomes fairly big problem already.
21:43:14 <wavewave> sounds good
21:43:43 <lispy> YayMe: start working on cabal or ghc :)
21:44:24 <lispy> YayMe: also, http://blog.codersbase.com/2012/12/haskell-community-project-ideas.html
21:44:26 <wavewave> working on ghc is probably not a good idea, because most of your time is spent on compiling.
21:44:36 <wavewave> ;-)
21:44:59 <quux> This might sound silly, but...
21:45:36 <YayMe> lispy: would love to however I can't imagine creating any beneficial contributions to either. A) I probably wouldn't be allowed to commit anything to either and B) any commits I made would likely need reworkin by someone who actually knows what they're doing
21:45:39 <quux> As most of the literature seems to assume a background with imperative languages, is haskell a poor choice for a "first" language?
21:45:57 <quux> (or even "first in a long time")
21:46:01 <wavewave> quux: not at all.
21:46:17 <YayMe> I love the idea of contributing to some open source project to learn, but it just doesn't make sense that you could learn in this way because by definition if you're still learning you are probably only going to harm the software you're contributing to
21:46:24 <YayMe> learners code is garbage, in any language
21:46:45 <quux> Yeah :3
21:47:07 <shachaf> quux: Haskell is probably an OK first language.
21:47:18 <quux> Quite a few have told me "go find a project, learn there", but i'd feel like an idiot submitting changes when I'm not all that experienced with modern languages
21:47:31 <wavewave> quux: haskell si very versatile. actually you will learn all the concepts needed for usual programming through haskell ( and more!)
21:47:34 <YayMe> quux: It's a great first language, it will set you up to do things more correctly in every other language where you will be less likely to have side effect errors than most people brought up in the imperative paradigm
21:47:36 <shachaf> A lot of that literature's goal is to "unteach" you things that aren't applicable to Haskell, for that matter.
21:47:49 <quux> I only have about a year or two of experience in assembly, and that was so long ago
21:48:01 <lispy> YayMe: What if you had a "mentor"?
21:48:13 <lispy> YayMe: someone more experienced that would filter your contributions and give you feedback?
21:48:18 <wavewave> quux: that sounds perfect to me. you even know how bare metal works.
21:48:21 <YayMe> lispy: that would be awesome.
21:48:32 <quux> well, to an extent. i didn't say i was very good at it :P
21:48:47 <lispy> YayMe: are you a student? that's the only eligibility requirement for google summer of code
21:49:10 <YayMe> lispy: 12 years in industry
21:49:16 <wavewave> YayMe: I think starting your own lovable program is more motivating usually.
21:49:39 <lispy> YayMe: in that case, I would do what you think is reasonable and ask for advice on the mailing lists
21:49:40 <wavewave> YayMe : anyway looking at some others' code is quite painful.
21:49:41 <YayMe> wavewave: It's a thought, but the ideas for programs I tend to have aim for the dreadfully simple
21:50:02 <shachaf> lispy: Does that apply to the mentors too? :-)
21:50:07 <sw2wolf> i know haskell through xmonad , now it is my every day desktop
21:50:10 <lispy> shachaf: heh
21:50:20 <YayMe> wavewave: trying to mimic their idioms however...
21:50:28 <YayMe> quite beneficial
21:50:28 <lispy> shachaf: crowd sourced mentoring
21:50:29 <quux> xmonad is amazing.
21:50:54 * lispy wonders why the ghc build takes as long as it does.
21:51:05 <wavewave> YayMe: yeah.. definitely there are some benefit.. it's a little difficult how to jump in..
21:51:06 <hpaste> kurtis pasted ‚ÄúYesod with cabal-dev. Back to dependency hell.‚Äù at http://hpaste.org/81403
21:51:06 <sw2wolf> yes, hacking xmonad code is comfortable
21:51:23 <YayMe> wavewave: that struggle is learning to do things the right way
21:51:24 <kurtis> So ... I gave it another shot with cabal-dev. Still no success
21:51:39 <YayMe> kurtis: What are you struggling with?
21:51:51 <shachaf> kurtis: Maybe ask in #yesod
21:51:54 <kurtis> YayMe, installing and running yesod
21:52:02 <shachaf> They tend to know more about Yesod than people in here.
21:52:03 <kurtis> shachaf, I'll try that out. Did not realize it existed. thanks
21:52:04 <YayMe> kurtis: for me installing yesod was: cabal install yesod, how are you trying?
21:52:04 <lispy> kurtis: what is the failure like?
21:52:11 <quux> I went from cwm to xmonad and while i loved cwm, i realized some of its problems after moving to xmonad, like how cwm uses ctrl modifiers for some commands :/
21:52:26 <quux> and only one workspace
21:52:45 <kurtis> YayMe, It installed correctly. But, it doesn't run. It complains of missing dependencies. I'm just following their quickstart guide and executed "yesod devel"
21:52:56 <kurtis> I should say, it installed without error
21:52:58 <YayMe> what dependencies does it complain are missing?
21:53:05 <quux> i'd like to play with xmonad's source, so, that's sort of what brought me to haskell, though i wanted to learn it earlier.
21:53:08 <lispy> kurtis: if you're on G+ there is a yesod community you can look there as well. Stackoverflow has a lot of haskell tagged questions. You might see if others have run into this there.
21:53:14 <luite> lispy: the ghc cabal stuff is installed with a custom ghc-cabal thing, it might be a bit incompatible with the real cabal
21:53:44 <kurtis> lispy, Read the bottom of this page for a list, if you don't mind (it's multiple lines) http://hpaste.org/81403
21:53:51 <luite> lispy: hm you're jason dagit, right?
21:54:07 <lispy> luite: I was editing the wrong .cabal file. Once I got all of those errors straigtened out, I couldn't do a simple 'cd compiler; make stage=2' so I did a full ./configure; make
21:54:10 <lispy> luite: yes.
21:54:27 <sw2wolf> Ruby is activated by rails, Haskell is activated by xmonad,  just for me :)
21:54:30 <kurtis> lispy, Cool, I'll give those a shot. Thank you.
21:55:23 <wavewave> Haskell is activated by parsec for me! :)
21:55:33 <kurtis> YayMe, simply cabal-dev install yesod-platform; yesod init <answer some questions>; cd project_dir; yesod devel (To put it shortly)
21:55:51 <YayMe> kurtis: did you try cabal install aeson?
21:56:03 <lispy> kurtis: if I had to guess, I would hypothesize that yesod is not tested with cabal-dev.
21:56:05 <kurtis> YayMe, No?
21:56:30 <YayMe> kurtis: it says aeson and unordered containers is missing, try cabal install aesone then cabal install unordered-containers
21:56:44 <YayMe> specifically rather try installing them with the version it specifies
21:56:47 <kurtis> lispy, Well, I ran into the same problem with just cabal. I figured maybe something was old on my end so I gave cabal-dev a shot (sandboxed environment)
21:56:56 <YayMe> so cabal install aeson-0.6.1.0
21:56:56 <shachaf> lispy: They explicitly support it.
21:57:04 <lispy> shachaf: ah, good to know
21:57:16 <lispy> kurtis: I've never tried to use yesod. I may be loading you astray.
21:57:22 <lispy> kurtis: I will stop suggesting things :)
21:57:34 <kurtis> lispy, haha no problem. I appreciate the help though!
21:57:38 <YayMe> It looks to be just missing two packages from the error log he mentioned
21:57:43 <YayMe> install those and should be fine
21:57:55 <shachaf> I've never had Yesod installation troubles. My approach is not to use Yesod.
21:58:08 <YayMe> shachaf: Do you use something else or just not generally do web stuff?
21:58:19 <lispy> shachaf: You should ask them to use monoids. monoids are so easy
21:58:24 <YayMe> lol
21:58:30 <kurtis> YayMe, it states (when using cabal-dev, not cabal like you mentioned) "All the requested packages are already installed" regarding aeson-0.6.1.0
21:58:36 <shachaf> lispy: Are they really?
21:58:49 <lispy> shachaf: I dunno, I just heard that somewhere
21:58:50 <YayMe> kurtis: try and uninstall then reinstall those packages
21:59:00 <YayMe> ...have you tried turning it off and back on again?
21:59:14 <luite> kurtis: what is the problem?
21:59:16 <lispy> cabal install ... --reinstall
21:59:37 <shachaf> Warning: Note that reinstalls are always dangerous.
21:59:46 <kurtis> luite, Dependency issues when installing + running yesod
22:00:13 <lispy> luite: I now have things to the point that I have my custom -fcil flag and calling causes ghc to die with Prelude.undefined that is imported from the module I added. This is enough to get me going.
22:00:20 <arbn> kurtis: After "yesod init", do "cabal install --only-dependencies" in the app folder, and then "yesod --dev devel" to run.
22:00:40 <arbn> kurtis: Err... "cabal-dev install --only-dependencies", in your case.
22:00:50 <luite> lispy: great :p
22:01:06 <arbn> kurtis: If you're using cabal-dev, you need "yesod --dev devel" and not "yesod devel".
22:01:18 <luite> lispy: keep in mind that the generated code, even STG, is going to pretty platform dependent, in particular 64 bit vs 32 bit
22:01:27 <tieTYT2> why can't I write concat' this way?  http://hpaste.org/81405
22:01:28 <kurtis> arbn, ahh I bet that's the problem. I'll give that a try
22:01:49 <arbn> kurtis: This is all in the Yesod book. http://www.yesodweb.com/book
22:02:11 <lispy> luite: Oh hrm. .NET is probably pretty explicit about that.
22:02:21 <lispy> luite: how do you guys handle that in ghcjs
22:02:28 <shachaf> tieTYT2: Because the equations for concat' have different numbers of arguments
22:02:28 <sw2wolf> Are there any real world website using yesod ?
22:02:32 <shachaf> It's not allowed by Haskell.
22:02:37 <shachaf> Are you asking why?
22:02:44 <lispy> sw2wolf: the yesod website uses it :)
22:02:55 <sw2wolf> and more ...
22:03:01 <tieTYT2> shachaf: I believe that if I didn't have the first pattern, it'd compile and work
22:03:14 <luite> lispy: uh well, poorly
22:03:25 <lispy> sw2wolf: I use snap at work. But that's because I had a co-worker that knew snap so if I got stuck i just bugged him.
22:03:25 <wavewave> tieTYT2: function definition should have the same kind.
22:03:27 <tieTYT2> but i wouldn't change the type, so it's a little confusing to me
22:03:44 <luite> lispy: ideally we'd get 32 bit code out of GHC, always, but the integrated compiler can't do that obviously, since it just uses the same STG as the native stuff
22:03:59 <lispy> luite: you probably saw my email to ghc-users. I really don't know what the appropriate "jumping off point" should be
22:04:00 <sw2wolf> lispy: snap is same as yesod ?
22:04:01 <shachaf> tieTYT2: Correct.
22:04:12 <shachaf> tieTYT2: Well, "the equations for concat' have different numbers of arguments"
22:04:12 <luite> lispy: and the standalone compiler also still can't do it because the types of the primops are baked into the GHC API, even in GHC HEAD
22:04:20 <lispy> sw2wolf: no. Snap is a competitor to yesod
22:04:27 <shachaf> tieTYT2: Is the phrasing unclear, or are you asking why that rule exists?
22:04:35 <tieTYT2> shachaf: the latter
22:04:37 <wavewave> tieTYT2: your first definition is in 0-ary data type and second definition has 1-ary function type
22:05:18 <shachaf> tieTYT2: "because" is probably the best answer.
22:05:28 <lispy> sw2wolf: the cool thing about yesod is that there is an o'reilly book on it. The cool thing about happstack is it's what the old-school haskellers prefer. The cool thing about snap is that in my (limited, very limited) experience it just worked.
22:05:29 <tieTYT2> shachaf: hah ok, I'll accept that
22:05:49 <shachaf> tieTYT2: There are some things that supporting it would make more complicated and annoying.
22:06:03 <luite> lispy: I think probably STG
22:06:11 <arbn> lispy: The "cool" thing about Yesod in my mind is the abuse of QQers that allows some admittedly impressive type-checking and embedded DSLs. :P
22:06:22 <sw2wolf> lispy: at least there are 3 choices using haskell to do web stuff, thx
22:06:25 <shachaf> tieTYT2: It's just simpler to add that requirement.
22:06:33 <shachaf> You can always eta-expand.
22:06:53 <luite> lispy: Cmm is quite low level code already, it looks a bit like C but with gotos instead of loops, and an explicit calling convention with registers and stuff
22:06:58 <lispy> luite: in GCC there are a lot of differences between the types. They keep lowering and making things more concrete after each pass. So you get things like high and low gimple, high and low rtl. Does that happen in ghc? Maybe I should use high STG?
22:07:11 <luite> lispy: you pretty much have to do low level machine emulation (pointer tagging etc) if you start with Cmm
22:07:20 <tieTYT2> shachaf: ok
22:07:41 <tieTYT2> the front page of yesod should explain "what?" before it explains "why?"
22:07:48 <luite> lispy: in GHC it's just Haskell -> Core -> STG -> Cmm -> (NCG|LLVM|C)
22:08:04 <mikeplus64> if anyone is interested i've made a small mueval-like library that's much faster than mueval by virtue of using a "ghc server". it supports typeclass,data,type etc declarations as well as type and kind pretty printing. (ie most of what ghci does). it limits the amount of time you can take on something like mueval, but does it differently. i'm running a small bot with it at #dorg
22:08:07 <luite> lispy: Core and STG are very similar, simple lazy functional languages
22:08:16 <tieTYT2> ah i guess it's in the upper right, but it's not he first thing the eye notices
22:08:35 <lispy> mikeplus64: lambdabot needs a maintainer :)
22:08:41 <luite> STG has more annotation stuff that helps the code generator, and always fully saturated (no partial application) primops and datacons
22:08:59 <lispy> luite: right. I've been reading about that so I have a vague notion of those things.
22:09:16 <lispy> luite: GHC is remarkably well documented.
22:09:32 <luite> lispy: you should probably read the "making a fast curry" paper
22:09:36 <luite> if you haven't already
22:09:51 <lispy> I know of it, but I haven't read it. It covers the current STG impl?
22:10:05 <lispy> push/eval, IIRC
22:10:07 <luite> the idea
22:10:27 <luite> push/enter is the one they don't use
22:10:30 <luite> eval/apply is used
22:11:15 <luite> with eval/apply the responsibility for arity checking is with the caller (eval thunk until you get a function for which you can get the arity, then apply to the right number of arguments)
22:11:56 <lispy> That sounds familiar
22:12:01 <luite> if you don't care about speed, you can ignore all of this
22:12:20 <luite> you can just fully curry everything in your code
22:12:30 <luite> so every function really is a one argument function
22:12:38 <luite> but that's slower
22:12:53 <Nereid> you could also make plain values into one-argument functions.
22:12:57 <mm_freak> if you don't care about speed and want a really simple implementation, you can translate everything to SKI
22:13:01 <Nereid> and replace function application with composition.
22:13:10 <mm_freak> it's about the easiest way to write a compiler for a lazy functional language
22:13:25 <lispy> luite: okay. I certainly want to do the simplest thing first. I don't mind having to rewrite it.
22:13:46 <lispy> luite: I figure at some point I'll be writing C# or F# code to implement the RTS
22:13:59 <mm_freak> SPJ wrote a tutorial on how to do that
22:14:16 <luite> lispy: yeah you can do that then. You'll also be writing lots of primop implementations :)
22:14:32 <kurtis> arbn, I followed your instructions while reading the book. I didn't see any references to the yesod --dev devel (particularly, the --dev switch) but it finally worked. Thanks a lot!
22:15:07 <arbn> kurtis: Ah. OK. It might be later in the book. Have fun.
22:15:29 <luite> lispy: https://github.com/ghcjs/ghcjs/blob/gen2/src/Gen2/Prim.hs
22:15:30 <luite> :)
22:15:33 <lispy> mm_freak: link? or are you thinking of his book?
22:16:07 <lispy> luite: interesting /me looks at it
22:16:37 <lispy> luite: that's how you map ghc primOps to js?
22:16:51 <lispy> luite: looks like you made a quasiquoter
22:16:57 <mm_freak> lispy: his book covers it in more detail, and you should probably read it anyway to see how graph reduction execution works
22:17:21 <luite> lispy: i didn't make that one, it's sclv's (although i customized it a bit to allow shorter antiquotes)
22:17:56 <luite> I think i'v eonly implemented inline primops so far
22:17:57 <lispy> luite: still, that's a smart idea. You write it in a js-like syntax and then pretty print the result?
22:18:10 <luite> lispy: yeah
22:18:37 <lispy> the ``  means recrusivly expand it?
22:19:06 <mm_freak> lispy: http://code.google.com/p/ipaper/downloads/detail?name=Implementing%20Functional%20Languages%20a%20tutorial.pdf
22:19:30 <lispy> mm_freak: ah yes. I'm familiar with that.
22:20:01 <mm_freak> the SKI translation allows you to get away with a very slim but also somewhat slow RTS
22:20:10 <sclv> `` is antiquotation
22:20:11 <luite> lispy: the `` contain haskell code again, if you antiquote an `x`, then it will usually insert (toJExpr x) in the AST
22:20:16 <mm_freak> and the translation from haskell is really easy compared to other approaches
22:20:42 <lispy> mm_freak: cool. I hadn't heard that before so I will definitely check that out.
22:21:02 <lispy> mm_freak: I was going to start with STG until I hear otherwise from the GHC team.
22:21:02 <hughfdjackson> is there a `show` equivalent for type signatures?
22:21:20 <lispy> mm_freak: so going to SKI might not make that much sense anymore, but we'll see
22:21:36 <hughfdjackson> or are tuples and lists representations just hard-coded?
22:21:48 <mm_freak> lispy: plus you don't need code obfuscators anymore =)
22:21:57 <mm_freak> the generated code is really really unintelligible for humans =)
22:22:18 <wavewave> hughfdjackson: what do you mean by hard-coded?
22:22:29 <mm_freak> for fast production code you will want to go the STG and/or eval/apply route though
22:22:50 <lispy> mm_freak: right. My plan is to get something working with minimal effort and build on it.
22:22:52 <hughfdjackson> wavewave: i mean sugar defined in the language spec
22:22:59 <wavewave> hughfdjackson: do you need type-level show for some compile-time debugging?
22:23:10 <hughfdjackson> no, i'm just being curious :3
22:23:15 <mm_freak> lispy: going STG will effectively require a complete rewrite of your compiler
22:23:19 <mm_freak> the approaches are very different
22:23:29 <hughfdjackson> haskell has a remarkable amount of 'define a small core language, and bootstrap from there'
22:23:43 <mm_freak> so if you plan to go into production quickly, you may want to start with STG right away
22:23:52 <hughfdjackson> i just wondered if this was part of that :D
22:23:53 <luite> lispy: anyway, your STG will have things that look like: case (PrimOpApp +# x y) of 1# ->   ... 2# -> case (App f y) of (Just z) -> ....
22:24:26 <lispy> luite: so I'll need a suitable definition for +#?
22:24:30 <wavewave> hughfdjackson: I don't understand how the first two questions are related.
22:24:46 <hughfdjackson> :p i'm confused about the confusion
22:25:12 <mm_freak> lispy: the SKI approach is fine for native code or byte code‚Ä¶  the speed isn't that bad, but you do give up a good amount of performance
22:25:13 <hughfdjackson> i want to know if you can define a custom representation for a type within a type signature
22:25:18 <wavewave> hughfdjackson: but anyway making show equivalent as a type class is not difficult at all
22:25:27 <luite> lispy: the strict primop stuff m eans you just generate the x+y inline (PrimInline in what i did), applying a function f  means that you have to jump to it (might even need to force f itself first, you do that by entering its thunk)
22:25:40 <mm_freak> lispy: if you want to target a mid/high level language like C or javascript, SKI is a bad idea
22:25:46 <wavewave> hughfdjackson: aha. I got your point.
22:25:49 <luite> lispy: anyway, you can do that directly, just calling f, use the CIL stack for function calls
22:25:51 <mm_freak> the generated code will be noticably slower than STG
22:26:00 <luite> lispy: or you can do it like GHC and CPS transform the code
22:26:14 <wavewave> hughfdjackson: that's quite hard-coded, but you can define some DIY type-level operators.
22:26:15 <hughfdjackson> :D phew - sometimes i forget how to speak english this early in the morning
22:26:52 <wavewave> hughfdjackson: so it's very limited.
22:27:10 <hughfdjackson> :D okay, thanks
22:27:13 <luite> lispy: yeah the +# implementation is usually hardcoded somewhere, at IntAddOp in mine :)
22:27:14 <hughfdjackson> i shall have a little google around
22:27:19 <wavewave> hughfdjackson: if you don't mind template haskell, you can use Quasi-Quoting.
22:27:59 <lispy> mm_freak, luite: thanks for the pointers :)
22:28:16 <hughfdjackson> i haven't gotten far enough in my haskelling to consider any language extensions atm ;) don't want to break my brain on it
22:28:43 <luite> lispy: non-cps is simplest, i guess you want to try that first, but you'll probably have to swithc over to cps if you want to implement lightweight threads (unless .NET has that stuff built in, in taht case you're much more lucky than the poor javascript guys)
22:29:57 <lispy> luite: .NET has threads, I doubt that they are lightweight by GHC's definition
22:31:01 <luite> lispy: even if you're not going to use Cmm, it can be quite instructive to watch the -ddump-cmm output for various things btw
22:31:24 <lispy> luite: that makes sense and mirrors my experience with gcc plugins.
22:31:44 <lispy> (see what the compiler does with your code and try to mimic that)
22:32:07 <luite> lispy: just remember that the weird +3, +1, -3 stuff is the pointer tagging/untagging
22:33:04 <lispy> a quick survey of google says that .NET threads are not lightweight
22:46:00 * hackagebot heist 0.11.0 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.11.0 (DougBeardsley)
23:02:23 <mikeplus64> Cale: can you upload lambdabot's current code somewhere?
23:08:17 <lispy> mikeplus64: I think this is it: http://code.haskell.org/lambdabot/
23:08:25 <shachaf> lispy: Yes, but that's somewhat old.
23:08:34 <shachaf> If nothing else, Cale is the only one with access to the latest database.
23:08:41 <shachaf> Well, I guess you have that too. :-)
23:11:07 <powergiant> Hey People. Can somebody explain to my why I can't define the type of the factorial function as "Int -> Int" but have to make it "Integer -> Integer" ?
23:11:29 <mikeplus64> anyone know how to "unset" something defined in the Ghc monad? after doing for example runStmt "let x = 0" SingleStep, i'd like to unset x
23:11:43 <capisce> powergiant: what error do you get?
23:12:42 <powergiant> capisce: "Couldn't match expected type "Int" with actual type "Integer""
23:13:14 <shachaf> powergiant: No.
23:13:23 <shachaf> powergiant: Maybe if you pasted your code someone could help. :-)
23:13:39 <shachaf> But otherwise we have no idea. It works for me!
23:13:50 <shachaf> > let fac :: Int -> Int; fac n = [1..n] in fac 5
23:13:53 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
23:13:53 <lambdabot>              with actual type ...
23:14:00 <shachaf> > let fac :: Int -> Int; fac n = product [1..n] in fac 5
23:14:01 <lambdabot>   120
23:16:04 <hpaste> Powergiant pasted ‚ÄúInteger‚Äù at http://hpaste.org/81406
23:16:36 <shachaf> powergiant: Because factorial isn't the same thing as factorial'
23:17:13 <powergiant> shachaf: Ah.. I see. Sorry!. Thanks :)
23:20:14 <functorfun> plhk: help man
23:20:29 <functorfun> s/help/hey/
23:20:48 * functorfun rolls eyes
23:20:51 <Nisstyre> powergiant: because of the constraints that the body of your function impose
23:21:04 <Nisstyre> that is the answer to any "why does this type have to be this?" question
23:21:25 <fmap> @ty productOf folded
23:21:26 <lambdabot> (Num b, Foldable f) => f b -> b
23:23:30 <Nisstyre> powergiant: in this case it looks like factorial is of type "Integer -> Integer", but factorial' is of the type "Int -> Int", so when GHC looks at the return type constraint imposed by the call to factorial in your definition of factorial', it checks to see if that is the same as the return type it knows factorial' should return, Int
23:23:38 <Nisstyre> those aren't the same type, and can't be made the same
23:23:51 <shachaf> Nisstyre: I think powergiant just missed a '
23:23:55 <Nisstyre> yeah
23:23:58 <Nisstyre> I'm explaining why though
23:23:59 <shachaf> This was meant to be a recursive definition.
23:24:07 <Nisstyre> why it gives that error I mean
23:25:07 <powergiant> Nisstyre: It was just a missed ' but a through explanation is always good. Thanks! :)
23:26:01 <powergiant> *thorough
23:26:31 <Nisstyre> powergiant: I do that all the time anyway
23:26:40 <Nisstyre> whenever I "lift" functions to the top level like that
23:26:57 <Nisstyre> I always forget to change the original definition
23:28:22 <powergiant> Nisstyre: "lift" mening going to a more general form of a function ?
23:28:41 <Nisstyre> powergiant: sort of
23:28:59 <Nisstyre> the example most commonly seen is when you want to implement an iterative function with some accumulator parameter
23:29:08 <Nisstyre> but you know ahead of time what that is initialized to
23:29:43 <Nisstyre> you can of course use "let" to do that in the function, but sometimes it's nicer to lift it to the top level
23:29:54 <Nisstyre> or "where"
23:30:23 <powergiant> Nisstyre: Ah ok. I see
23:31:02 <Nisstyre> I tend to use letrec for that in Scheme, idk why I do it this way in Haskell
23:31:09 <Nisstyre> maybe because I can easily write f'
23:43:19 <lightquake> anybody in here have experience with netwire? i'm trying to figure out how i'd maintain a dynamic collection of objects that can interact with each other
23:54:19 <plhk> functorfun: hi
23:56:01 * hackagebot snap 0.11.0 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.11.0 (DougBeardsley)
23:56:36 <SamanthaD> I'm trying to write a program that runs a command with readProcessWithExitCode and then tests to see if it worked or failed but I can't pattern match against the exit code because System.Process doesn't export GHC.IO.Exception.ExitCode ;_;
23:58:12 <SamanthaD> Oooh... nevermind. I get it
23:58:12 <glguy> yay, thanks Doug
23:58:18 <SamanthaD> writing out my question answered it!
23:58:31 <geekosaur> SamanthaD, the haddocks take you to System.Exit...
23:58:32 <tieTYT2> can someone break this down for me, I don't get how this code works: map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
23:59:03 <tieTYT2> to me it makes more sense like this: map (\l@(x:xs) -> (x,length l)) (group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7])
23:59:04 <functorfun> plhk: Hows things?
23:59:52 <tieTYT2> but when I read it the way it is, it seems like it's saying map a list to lambda that ... then group that list then sort that list
23:59:53 <geekosaur> tieTYT2, do you understand (.)?
