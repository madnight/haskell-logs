00:00:27 <covi> Wait, maybe a and either a are not typeclasses, my mistake.
00:02:39 <statusfailed> FYCouch: for motivation, consider this: Often, you want to write functions which only need to know some small facet of a data type, for example how to compare for equality
00:02:55 <statusfailed> So if I want to write a function to tell me if three things are equal, I can write it for any three equatable things:
00:03:10 <statusfailed> threeEqual :: Eq a => a -> a -> a -> Bool
00:03:40 <statusfailed> So now that function will work on any type that is a member of the Eq typeclass
00:24:51 * hackagebot dynamic-object 0.2.1 - Object-oriented programming with duck typing and  singleton classes.  http://hackage.haskell.org/package/dynamic-object-0.2.1 (TakayukiMuranushi)
00:28:50 <FYCouch> statusfailed: like C variants?
00:29:01 <FYCouch> where there's a small subset of type data in common, and the rest is 'type extension' ?
00:31:50 <covi> Mutually recursive modules problem. I have A.hs-boot and a module B which imports A with the SOURCE pragma. A has something like "data DA = V1 B1 | V2 B2", and in A.hs-boot I have the line "data DA". The problem is, in module B, V1 and V2 are not available.
00:37:08 <statusfailed> wow, the Fay IDE is pretty cool
00:41:02 <Fuuzetsu> There seems to be a compromised account with ghc-users in it's contact list... Is there a way to report such occurence?
00:41:07 <Fuuzetsu> its*
00:44:52 * hackagebot biosff 0.3.3 - Library and executables for working with SFF files  http://hackage.haskell.org/package/biosff-0.3.3 (KetilMalde)
00:54:52 * hackagebot persistent 1.1.4 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.1.4 (MichaelSnoyman)
01:08:05 <t7> anyone else using a freenode ssl cert that ran out yesterday ?
01:09:58 <fmap> I want `caseM ma of' sugar for `ma >>= \a -> case a of' in addition to \case :[
01:11:15 <neutrino> fmap: in general, i wish haskell's syntax were much more flexible
01:11:42 <neutrino> fmap: it is the one pain point that seems very anachronic
01:13:17 <covi> @hoogle Floating a => a -> Integer
01:13:17 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
01:13:18 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
01:13:18 <lambdabot> Prelude acos :: Floating a => a -> a
01:13:37 <Enigmagic> :t realToFrac
01:13:38 <lambdabot> (Fractional b, Real a) => a -> b
01:13:50 <Enigmagic> :t floor
01:13:51 <lambdabot> (Integral b, RealFrac a) => a -> b
01:13:58 <Enigmagic> :t ceiling
01:13:59 <lambdabot> (Integral b, RealFrac a) => a -> b
01:14:09 <covi> Enigmagic: thanks
01:14:25 <Enigmagic> covi: not realToFrac... floor, ceiling, truncate should all work
01:16:04 <BobbyMcLiar> if I have (.).(.), isn't that the same as \f -> ((f.).)?
01:16:42 <shachaf> Try it in ghci with :t
01:16:52 <BobbyMcLiar> I did. it isn't
01:17:05 <BobbyMcLiar> But I wonder what's my mistake
01:17:07 <fmap> @pl \f -> ((f.).)
01:17:07 <lambdabot> (.) . (.)
01:17:24 <BobbyMcLiar> oh
01:17:50 <quicksilver> BobbyMcLiar: when I try in ghci I get the same types for those two.
01:17:59 <mrout> @where bnfc
01:17:59 <lambdabot> BNF Converter, http://bnfc.digitalgrammars.com/
01:18:12 <basdirks> @unpl (.).(.)
01:18:12 <lambdabot> (\ i b c f -> i (b c f))
01:18:20 <basdirks> @unpl (.). flip (.)
01:18:20 <lambdabot> (\ l b c i -> b c (l i))
01:18:50 <BobbyMcLiar> but isn't ((f.).) not the same as (.) (.)?.
01:18:52 <mrout> (.).(.) .. boobs
01:19:52 <BobbyMcLiar> uhm no. forget it. thank you for your help :9
01:19:53 <basdirks> mrout if you keep saying it, it will become funny
01:20:05 <mrout> Definitely.
01:20:20 <BobbyMcLiar> no,  ( . ) ( . ) are boobs
01:20:27 <shachaf> No, it wasn't funny then and it's not funny now.
01:20:40 <shachaf> It's best left for some other channel.
01:20:40 <basdirks> shachaf: my point exactly
01:20:56 <mrout> BobbyMcLiar, shachaf: good point
01:21:52 <BobbyMcLiar> but again, people should be more creative about that. Everyone thinks of boobs, so saying it is kind of pointless. show us some alternative point of view.
01:22:11 <srhb> They already have a name, don't they,
01:22:19 <srhb> Context something something.
01:22:34 <basdirks> semantic editor combinators?
01:22:56 <srhb> Ah, yes.
01:24:03 <Nereid> :t fmap.fmap.fmap
01:24:04 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
01:24:32 <basdirks> :t traverse.traverse.traverse
01:24:33 <lambdabot> (Applicative f, Traversable t2, Traversable t1, Traversable t) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
01:25:40 <mrout> http://bnfc.digitalgrammars.com/ <-- the bnfc-2.4b.exe doesn't work, any idea why, anyone?
01:27:15 <mrout> @where parser
01:27:15 <lambdabot> I know nothing about parser.
01:27:17 <mrout> @where parsers
01:27:18 <lambdabot> I know nothing about parsers.
01:27:22 <mrout> :(
01:27:28 <mrout> @where happy
01:27:28 <lambdabot> http://www.haskell.org/happy/
01:27:32 <Hafydd> @where love
01:27:32 <lambdabot> http://en.wikipedia.org/wiki/Where_Is_Love%3F
01:29:52 * hackagebot crypto-numbers 0.1.3 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.1.3 (VincentHanquez)
01:31:29 <jeetu> "a":[]
01:31:45 <jeetu> gives "a" which is same as 'a':[]
01:31:47 <jeetu> why?
01:32:42 <mauke> no, it doesn't
01:32:46 <mauke> > "a":[]
01:32:47 <lambdabot>   ["a"]
01:32:52 <jeetu> But this is giving  'a':[] == "a":[]  False
01:32:58 <mauke> no, it doesn't
01:33:05 <mauke> > 'a':[] == "a":[]
01:33:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
01:33:06 <lambdabot>              with actual type...
01:33:31 <mrout> >['a'] == ["a"]
01:33:36 <mrout> > ['a'] == ["a"]
01:33:37 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
01:33:37 <lambdabot>              with actual type...
01:33:42 <mrout> thought so
01:34:13 <basdirks> > "a":[]
01:34:14 <lambdabot>   ["a"]
01:34:46 <jeetu> so ["a"]  is a list of strings. Got it. Thanks
01:34:49 <basdirks> ["a"] == [['a']]
01:34:53 <basdirks> > ["a"] == [['a']]
01:34:55 <lambdabot>   True
01:35:02 <quicksilver> jeetu: you can't use == on things of a different type, incidentally
01:35:04 <mauke> > 'a':[]
01:35:05 <lambdabot>   "a"
01:35:09 <mauke> > ['a']
01:35:11 <lambdabot>   "a"
01:35:12 <jeetu> Got it. My bad.
01:35:27 <mauke> @let a === b = cast a == Just b
01:35:29 <lambdabot>  Defined.
01:35:45 <mauke> > ['a'] === ["a"]
01:35:46 <lambdabot>   False
01:35:53 <quicksilver> :)
01:36:25 <jeetu> BTW what is the best place to understand Maybe and Just. RWH is not helping much in that.
01:36:39 <mauke> @src Maybe
01:36:39 <lambdabot> data Maybe a = Nothing | Just a
01:36:42 <srhb> jeetu: There's not much to understand. But LYAH mentions them as well
01:36:47 <mauke> now you just need to understand 'data' and you're done!
01:37:02 <srhb> jeetu: Perhaps you just think you don't understand it because the idea is so simple. :)
01:37:19 <jeetu> @src Nothing
01:37:19 <lambdabot> Source not found. I feel much better now.
01:37:30 <Lethalman> jeetu, as a newbie, I started with LYAH rather than RWH
01:37:38 <mrout> LYAH is great.
01:37:56 <mauke> jeetu: that line above was the definition of Maybe, Just, and Nothing
01:38:02 <mikeplus64> :t Nothing
01:38:03 <lambdabot> Maybe a
01:38:07 <mikeplus64> :t Just
01:38:08 <lambdabot> a -> Maybe a
01:38:15 <jeetu> I took LYAH for some chapters and then jumped to RWH. Thought I can take from there.
01:38:31 <srhb> jeetu: RWH doesn't teach you Haskell as much as it shows you practical examples.
01:38:35 <srhb> (IMO)
01:38:57 <liyang> To understand Maybe and Just, you must first understand Nothing. —Unknown Zen master
01:39:02 <srhb> But I guess some people see it as the grown-ups' version of LYAH. ^^
01:39:08 <basdirks> Programming in Haskell -> LYAH -> RWH for me
01:39:53 * hackagebot tamarin-prover-utils 0.8.4.0 - Utility library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-utils-0.8.4.0 (BenediktSchmidt)
01:39:57 <jeetu> Seems like that. I will still go with RWH and "refer" LYAH whenever required :).
01:39:58 <jeetu> Thanks
01:40:10 <mrout> To understand Justice, you must first understand Nothing.
01:41:44 <jeetu> One more thing. On the other day I was reading R and found lazy evaluation of function arguments in it.
01:42:17 <srhb> jeetu: Yes?
01:42:31 <jeetu> Means if your function has 3 argumnents and you pass only 2 and just in case your execution path does not require 3rd arguments, it will run without error
01:42:47 <jeetu> or even warning
01:42:49 <srhb> Weird.
01:43:11 <srhb> (Depending on what you mean by execution path)
01:44:53 * hackagebot tamarin-prover-term 0.8.4.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-term-0.8.4.0 (BenediktSchmidt)
01:44:55 * hackagebot tamarin-prover-theory 0.8.4.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-theory-0.8.4.0 (BenediktSchmidt)
01:44:57 <jeetu> Is that a worthy feature from your point of view/
01:45:12 <mrout> Seems odd.
01:45:18 <srhb> jeetu: Seems confusing and weird.
01:45:28 <srhb> jeetu: And I don't understand how it is lazy anyway.
01:47:44 <jeetu> Lazy in a way that R will not check whether arguments are present unless required
01:48:08 <srhb> Perhaps it's awesome. I don't know. I like that my functions only fully evaluate given all their arguments.
01:48:35 <mrout> Still, function overloading would be a better solution to any problem that that feature solves
01:48:43 <srhb> Indeed.
01:48:45 <mauke> Haskell can do that, kind of
01:48:51 <mauke> foo ~(a, b, c) = ...
01:48:56 <srhb> Eeek
01:48:58 <srhb> :P
01:49:06 <mauke> not really the same thing
01:49:15 <mrout> mauke: what does that ~ do?
01:49:16 <shachaf> foo ~(a, ~(b, c))
01:49:19 <mrout> never seen it before
01:49:23 <srhb> > let foo ~(a, b, c) = a + b
01:49:24 <Nereid> it's a lazy pattern match.
01:49:25 <lambdabot>   not an expression: `let foo ~(a, b, c) = a + b'
01:49:27 <shachaf> mrout: You can find it on Hoogle.
01:49:28 <srhb> > let foo ~(a, b, c) = a + b in foo 1 2
01:49:29 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
01:49:29 <lambdabot>    arising from the ambiguity chec...
01:49:36 <Nereid> srhb: let bindings are lazy by default
01:49:57 * hackagebot tamarin-prover 0.8.4.0 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.8.4.0 (BenediktSchmidt)
01:50:06 <srhb> Hm, why does it fail then?
01:50:15 <srhb> > let foo ~(a, b, c) = a + b in foo 1 2 :: Int
01:50:17 <lambdabot>   No instance for (GHC.Num.Num
01:50:17 <lambdabot>                     (a0 -> GHC.Types.Int, a0 -...
01:50:20 <Nereid> because type checking isn't lazy.
01:50:24 <srhb> Ah, of course
01:50:40 <Nereid> > let foo ~(a, b, c) = 1 in foo undefined
01:50:41 <lambdabot>   1
01:50:46 <Nereid> > let foo (a, b, c) = 1 in foo undefined
01:50:47 <lambdabot>   *Exception: Prelude.undefined
01:50:57 <srhb> Yes, I see the difference
01:51:26 <mrout> Mereid: that's damn cool
01:51:46 <mikeplus64> > let [a,b,c] = [1,2,3,4] in ()
01:51:48 <lambdabot>   ()
01:53:55 <liyang> > let (a : b : c : ~[]) = [1,2,3,4] in (a,b,c)
01:53:57 <lambdabot>   (1,2,3)
02:23:46 <statusfailed> Is hackage accessible in China?
02:24:08 <mikeplus64> it was when i was there iirc (october)
02:24:24 <srhb> http://www.greatfirewallofchina.org/
02:24:32 <HugoDaniel> :D
02:24:46 <mrout> statusfailed: how hard would it be to check?
02:25:29 <srhb> Not hard. You send someone to China with a laptop with a wifi card. If they don't come back, it's blocked in China.
02:25:36 <srhb> (Or use that website)
02:26:22 <mrout> Not hard to check by typing the url into a web browser...
02:26:42 <statusfailed> mrout: but i'm not in china :|
02:26:51 <mrout> statusfailed: then why do you care?
02:26:55 <statusfailed> because I might go to China?
02:27:05 <statusfailed> and I need to figure out how to access hackage
02:27:17 <statusfailed> if it's blocked
02:27:26 <statusfailed> srhb: awesome link, thanks :)
02:27:27 * srhb doesn't understand that this conversation needs to go on after posting that URL
02:27:28 <srhb> :P
02:27:30 <srhb> Welcome.
02:28:19 <statusfailed> awesome, now I just have to check if my bank account supports going to China :D
02:50:21 <quicksilver> I think it's quite awesome that BONUS's text is now being cited as a reference by lecture courses.
02:50:36 <quicksilver> I believe he would have found that quite surprising when he started drawing :)
02:51:30 <Fuuzetsu> Hey, it's a good book.
02:51:32 <Taneb> Even though his description of mtl is out of date
02:51:39 <bitonic> that’s hardly his fault
02:51:53 <bitonic> every book that relies on libraries will be prone to that sadly
02:51:54 <mrout> it's totally his fault he doesn't have prescience
02:52:01 <bitonic> RWH is even more affected
02:52:15 <bitonic> it is an excellent book
02:52:17 <Taneb> I just wish that people'd go back and edit the website
02:52:23 <quicksilver> Fuuzetsu: it is a good book but it was initially just a few cartoons on a webpage :)
02:52:47 <srhb> I hear he's fallen off the map though. So no updates are in sight.
02:54:34 <Fuuzetsu> It's released under Creative Commons so you are free to update it and host the updated version.
02:54:37 <Taneb> Domain name expires this year, I think
02:55:16 <quicksilver> srhb: he's probably got a job or something prosaic like that
02:55:37 <Fuuzetsu>  Expiration Date: 30-Aug-2013
02:55:41 <Fuuzetsu> eww, a job
02:55:43 <srhb> quicksilver: Downfall of everyone. :(
02:56:23 <Fuuzetsu> His address is on whois, you could send him a pretty letter.
03:09:01 <BobbyMcLiar> How do I know from \f g -> ((f.).g) that g takes 2 arguments?
03:09:18 <mauke> by expanding the definition of (.)
03:09:42 <mrout> @src (.)
03:09:42 <lambdabot> (f . g) x = f (g x)
03:09:43 <lambdabot> NB: In lambdabot,  (.) = fmap
03:09:43 <BobbyMcLiar> the one in the middle?
03:09:46 <mrout> @src (f.)
03:09:46 <lambdabot> Source not found. :(
03:09:50 <mrout> didn't think so
03:09:50 <mauke> BobbyMcLiar: all of them
03:09:54 <johnw> (f .) . g means: f is composed with the function returned by g
03:10:02 <mauke> (.) = \a b c -> a (b c)
03:10:21 <mauke> \f g -> (f .) . g  =  \f g -> (.) ((.) f) g
03:10:49 <mauke> = \f g -> (\a b c -> a (b c)) ((\a b c -> a (b c)) f) g
03:11:21 <mauke> = \f g -> (\a b c -> a (b c)) (\b c -> f (b c)) g
03:12:11 <mauke> = \f g -> (\c' -> (\b c -> f (b c)) (g c'))
03:12:40 <mikeplus64> easy for you to say
03:12:56 <mauke> = \f g -> (\c' -> (\c -> f (g c' c)))
03:13:17 <mauke> = \f g \c' \c -> f (g c' c)
03:13:22 <mauke> er
03:13:27 <mauke> = \f g c' c -> f (g c' c)
03:13:29 <HugoDaniel> how do i throw a compile time error in haskell ?
03:14:00 <HugoDaniel> in a guard
03:14:07 <BobbyMcLiar> ugh. thank you
03:14:12 <HugoDaniel> f i | i > 100 = error "blah" ?
03:14:32 <mauke> HugoDaniel: I don't think that makes sense
03:14:42 <typoclass> HugoDaniel: yeah that throws an error, but it's runtime, not compile time
03:15:10 <HugoDaniel> oh yes sorry
03:15:14 <HugoDaniel> i have the dumb today
03:15:17 <HugoDaniel> yes, guards are runtime
03:15:20 <HugoDaniel> sorry
03:15:32 <typoclass> HugoDaniel: for compile-time there's WARNING and DEPRECATED and that stuff http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/pragmas.html
03:16:46 <HugoDaniel> thanks typoclass
03:23:37 <Casca> Hello all
03:23:42 <srhb> Are there any obvious abstractions for handling "sessions" that might expire and require my library to re-login to continue with whatever request failed?
03:23:44 <srhb> Casca: Hi
03:28:57 <srhb> Oh God, I guess what I am talking about is actually a Monad where bind takes care of restarting the session if need be.
03:28:58 <Casca> a couple days ago I came here asking for recommendations on category theory books and someone suggested I should read Steve Awodey's Category Theory. I'm really liking this book so far but I find I'm lacking the basic theoretical background. What's a good beginner's book on abstract algebra that will prepare me to understand and enjoy Steve Awodey's book?
03:29:28 <johnw> i'm reading Fraleigh, but most people seem to hate it with a passion
03:29:32 <srhb> Casca: Have you seen the Wikibook? It's not entirely finished, but it's good for reference.
03:30:03 <Casca> johnw I'll look it up
03:30:22 <johnw> i've heard Algebra: Chapter 0 is really good
03:30:29 <johnw> but you may need a bit more math background for that one
03:30:29 <srhb> Casca: http://en.wikibooks.org/wiki/Abstract_algebra
03:30:31 <johnw> i haven't tried it yet
03:30:32 <Casca> srhb no I haven't.
03:30:43 <srhb> It's very approachable.
03:30:54 <Casca> great, thanks for the link
03:32:39 <Casca> my CS program algebra course covers very basic abstract algebra, just a very brief introduction to groups and rings
03:33:00 <Nereid> sounds like a typical introductory algebra course.
03:33:50 <Nereid> if you're looking for a book, Herstein is nice.
03:33:54 <Casca> there are two opt-in courses on abstract algebra for math grad students that I'd like to take in the future, but in the meanwhile I need something to help me understand the theory behind the Haskell language more deeply
03:34:38 <`nand`> are you talking about the type theory?
03:35:26 <Casca> okay, so it's the Wikibook, Fraleigh, Algebra: Chapter 0 and Herstein. Thanks a lot guys
03:35:30 <Nereid> you won't see all that much abstract algebra proper in haskell though. know what a monoid is? cool, you're done.
03:35:46 <Nereid> what, aluffi?
03:35:53 <Nereid> I dunno if that's a good introductory book.
03:36:15 <Nereid> well I guess it gets into the category stuff pretty early.
03:36:20 <Casca> I'm talking about the theory needed to understand the type classes in the Tupeclassopedia, if I spelled it correctly
03:36:27 <Nereid> typeclassopedia.
03:36:28 <Nereid> :p
03:36:41 <Nereid> I don't think you really need much theory at all.
03:36:44 <mauke> wait, you need theory for that?
03:36:55 <Casca> yes, sorry, I'm on a tablet
03:36:57 <`nand`> you mainly need a intuition of haskell's type system and maybe some of its operational semantics
03:37:00 <johnw> groups, rings, fields, are pretty absent in Haskell
03:37:04 <johnw> unless you're looking at edwardk code
03:37:04 <Nereid> quite.
03:37:11 <`nand`> instead.. we get Nunm
03:37:13 <`nand`> Num*
03:37:19 <Nereid> gross
03:38:31 <`nand`> (Casca: looks to me like you spelled it correctly. I think Nereid was hinting that all you need to understand the typeclassopedia is the typeclassopedia)
03:38:44 <Nereid> no, there was a typo there. :p
03:38:49 <`nand`> oh
03:38:52 <mauke> *tupo
03:38:56 <`nand`> I see it now :)
03:39:08 <srhb> The internet is a series of tubeclasses.
03:39:27 <`nand`> I was directing my attention towards the wrong half of the word, it seems :)
03:39:33 <Nereid> but yeah, I don't think the mathematical theory doesn't really help a lot in understanding how to use monads and stuff.
03:39:43 <johnw> but it will help with reading Awodey
03:39:44 <Casca> johnw, well I don't really have a good reason, it's just that I've enjoyed learning Haskell so far and I really have this itch to study the theory behind the type classes so I can understand where the concepts come from and maybe develop a more deep intuition
03:39:56 <Nereid> sure, that's fine
03:40:04 <johnw> Casca: I'm in the same boat, and enjoying the math learning for its own sake now
03:40:06 <Nereid> I also encourage everyone to learn math
03:40:10 <Nereid> because it's cool
03:40:55 <`nand`> I think a more useful first step is to study the interpretations people have given various things in a Haskell context; rather than studying them in a pure math contexts and then learning how to transfer them to generate useful results in Haskell
03:41:05 <Casca> maybe ill end up despising FP, maybe ill end up writing a master thesis on lambda calculus, who knows :)
03:41:10 <`nand`> like studying what Category is and how it can be useful, rather than studying what a category is
03:42:37 <Casca> nand, how would you go about understanding this in a Haskell context if you were in my position?
03:42:39 <`nand`> that reflects my general approach though; look at things concretely, then learn how to generalize them - instead of learning about some abstraction and then trying to think of ways it can be used
03:43:07 <`nand`> Casca: depends on what ‘this’ is
03:43:20 <Casca> that resonates with me too, I like to first study xo Crete examples and only then generalize
03:43:23 <`nand`> Casca: in general, writing lots and lots of Haskell, looking at lots and lots of other people's Haskell, reading documentation for edwardk packages
03:43:32 <Casca> *concrete
03:43:58 <johnw> until the day when you can snatch the pebbles from edwardk's hand
03:44:05 <`nand`> typeclassopedia gives you some valuable pointers, but hackage documentation is probably the most important resource
03:44:49 <Casca> can you recommend me any edwardk's packages?
03:45:06 <johnw> semigroups, kan-extensions, profunctors, etc.
03:45:09 <`nand`> lens :P
03:45:10 <Casca> that must sound funny to an American ear, I realize now
03:45:18 <johnw> just go to his github.com/emkett page, and browse around
03:45:33 <srhb> github.com/ekmett
03:45:48 <Casca> good idea johnw, I'll do that
03:46:01 <wuttf> It may sound like a stupid question but is it possible to convert a function to a string?
03:46:11 <`nand`> ‘lens’ has, by now, fairly complicated internal workings; but if you're comfortable enough to approach it, understanding it can lead you to a great deal of knowledge
03:46:18 <Casca> any other recommendations guys?
03:46:23 <SLi> I wonder if any of the regexp libraries support regular expressions on non-text lists/arrays (where instead of characters the pattern has arbitrary predicates).
03:46:34 <srhb> wuttf: Not really.
03:46:38 <SLi> Or if that idea even makes sense. It seems to to me :)
03:46:40 <johnw> wuttf: other than a string like "function", no
03:46:40 <`nand`> (I don't know how much Haskell you know, so that's all the stabs into darkness I can provide)
03:47:02 <typoclass> is there any other example haskell code to read, except for edwardk stuff? it seems like most of his things are terribly abstract, and apart from lens i'm not sure if he's traditionally been the best documenter ...
03:47:13 <wuttf> srhb, johnw I see, thanks.
03:47:31 <`nand`> wuttf: what are you trying to do?
03:47:34 <johnw> typoclass: we were given examples of Category Theory stuff encoded in Haskell
03:47:37 <Casca> I'll definitely check out lens
03:47:42 <johnw> not necessarily Haskell for Haskell's sake
03:48:24 <johnw> i think pipes is one of the best documented packages I've come across
03:48:53 <wuttf> `nand`: Well, I am thinking about implementing an ORM-like thingie, and queries would be functions, and I want to analyze those predicates so I can generate more efficient queries.
03:49:04 <wuttf> Crazy idea I know.
03:49:09 * `nand` .oO( ‘seasoned type wrangler’ )
03:49:14 <typoclass> johnw: right, i haven't seen pipes yet. i meant mostly the old edwardk (category-extras era) vs. the new edwardk (lens era)
03:50:02 <Lethalman> johnw, I'm sorry, where's the docs for pipes? :S
03:50:09 <johnw> google for pipes
03:50:12 <`nand`> http://hackage.haskell.org/package/pipes this one?
03:50:15 <johnw> you'll see a series of excellent articles
03:50:17 <johnw> yes, and there
03:50:18 <johnw> the Tutorial
03:50:22 <tdammers> wuttf: you could probably define your own Show instance for a particular type of functions
03:50:28 <johnw> i've started writing Tutorial modules, based on his example
03:50:38 <`nand`> is ‘pipes’ the new iterator library to look at?
03:50:41 <`nand`> I've honestly looked at none of them
03:50:51 <mauke> yes. also the old iterator library
03:51:48 <wuttf> tdammers: I don't think that's what I want.
03:51:57 <Lethalman> this one? http://hackage.haskell.org/packages/archive/pipes/2.1.0/doc/html/Control-Pipe-Tutorial.html
03:51:58 <Lethalman> looks nice
03:52:17 <Lethalman> the latest package has no docs though
03:52:51 * Lethalman is looking at the wrong link maybe
03:52:54 <typoclass> Lethalman: i'm looking at pipes-3.1.0 and there is no module Control.Pipe.Tutorial. there is one called Control.Proxy.Tutorial. who knows
03:53:00 <`nand`> http://hackage.haskell.org/packages/archive/pipes/3.1.0/doc/html/Control-Proxy-Tutorial.html
03:53:02 <`nand`> oh
03:53:10 <`nand`> just noticed that says Proxy and not Pipe
03:53:12 <Lethalman> yes, but seems very different than the 2.1.0 :S
03:53:29 <`nand`> Lethalman: it can only be an improvement! :)
03:53:37 <tdammers> wuttf: then what *do* you want? get the function name at runtime?
03:53:51 <Lethalman> `nand`, hope so, at a first glance it's much harder to understand the new tutorial
03:54:21 <typoclass> which one is edwardk's effort at an iteratee implementation? it was called 'machine' wasn't it?
03:54:37 <srhb> Repeating a question. It seems "client session management" is a somewhat generalized concept in which the handshaking part might be required not just at the beginning of a session, but sometimes because a session is interrupted (by a timeout, connection loss or whatever.) Is there a generalized way to deal with this? The basic seems to be some StateT Session IO thingy, but mashing checkSessionAndContinueOrLogin everywhere seems a bit
03:54:37 <srhb> nasty.
03:54:56 <wuttf> tdammers: Never mind bro I had an epiphany
03:55:10 <`nand`> typoclass: something like that, yes
03:55:14 <tdammers> wuttf: care to share?
03:55:18 <`nand`> I never really understood it
03:55:38 <typoclass> (i misremembered and thought 'pipes' was by edwardk, but of course it's not)
03:56:27 <typoclass> srhb: use moar monads? implement >>= so that it does the checkSessionOrLogin ...?
03:57:05 <wuttf> tdammers: PM?
03:57:05 <srhb> typoclass: That's what I thought, just making sure I wasn't seeing monads where there are none. :P
03:57:09 <wuttf> tdammers: Can I?
03:57:24 <tdammers> you mean /msg?
03:57:26 <tdammers> sure
03:57:57 <typoclass> srhb: "seeing monads where there are none" is a paradoxon anyway
03:58:22 <srhb> Is that German for paradox?
03:58:44 <`nand`> shouldn't (Session -> IO a) work as well? (without needing a full-blown StateT)
03:59:27 <typoclass> srhb: it is fancy-pants smart-ass oh-im-wearing-an-intellectual-little-hat for paradox
04:00:39 <srhb> `nand`: I'm not entirely sure on the design. I'm thinking of writing an XMPP library from scratch for the practice, and I guess StateT has just become a goto for me in so many ways. :P
04:00:40 <mauke> srhb: greek
04:00:49 <elliott> srhb: Careful.
04:01:00 <elliott> srhb: if you intersperse an action like that you may run afoul of the monad laws
04:01:14 <elliott> In particular, (m >>= return) must be the same as m
04:01:21 <srhb> Right..
04:01:56 <srhb> Clearly that's only possible if the Session can always be restored.
04:02:03 <srhb> Okay, I might want to retract that "Clearly"
04:02:05 <`nand`> stick a bool into your newtype that says whether the current action ever queries the session; only check it if the bool is true?
04:02:07 * srhb is unsure
04:02:10 <`nand`> or perhaps something less ugly
04:03:44 <srhb> `nand`: How does that help?
04:04:09 <`nand`> then ‘pure’ actions like return wouldn't invoke any extra side effects in (>>=)
04:04:20 <`nand`> and m >>= return = m could be guaranteed
04:04:29 <elliott> That sounds awful. Why not just embed the logic in the actual action?
04:04:33 <elliott> That's the same thing as the Bool but without the indirection.
04:04:48 <srhb> Because then I'm sprinkling restoreSessionOrDie everywhere
04:04:54 <srhb> Seems like that should be possible to abstract out.
04:05:00 <elliott> yes, but you'd be sprinking "True" with this Bool
04:05:01 <`nand`> that does sound like a better approach
04:05:03 <elliott> Just saying it doesn't help any.
04:05:09 <srhb> Okay. Hmm.
04:05:18 <typoclass> `nand`: i think the plan is that the functions which need an active Session are marked by ":: Session -> ...", or "-> StateT ... Session ..." or some such
04:05:34 <srhb> typoclass: Yes.
04:06:11 <srhb> Hum. Perhaps I'm aiming a bit over my capabilities here.
04:07:19 <psii> srhb: what about generating a stream of IO actions which later gets interspersed with your session restore functionality?
04:08:01 <srhb> That could work. I have to decide how to bail anyway in case a session really cannot be restored.
04:10:22 <MHD> What is the name of the computer science channel?
04:11:21 <srhb> ##compsci I think?
04:11:24 <bitonic> when was the Haskell 2010 published?
04:11:54 <MHD> 2010?
04:11:55 <ion> 2010?
04:11:58 <srhb> bitonic: It was announced at the end of 2009
04:12:02 <MHD> hehehe
04:12:05 <bitonic> srhb: thanks
04:12:07 <srhb> According to this page: http://www.haskell.org/haskellwiki/Haskell_2010
04:12:28 <`nand`> it was released July 2010 (according to wikipedia)
04:12:40 <srhb> `nand`: That sounds wrong: http://www.haskell.org/pipermail/haskell/2009-November/021750.html
04:13:20 <`nand`> funny, wikipedia's source on that is the same link
04:13:34 <ion> srhb: It wasn’t published at that time. The text you linked to: “We will product a revised version … over the next few months”
04:13:47 <ion> produce
04:14:09 <srhb> Ah, thanks.
04:14:35 <typoclass> so probably they decided on the list of extensions to adopt, and then did the work writing it up. which took a few months.
04:14:37 <MHD> What is the Haskell editor of choice?
04:14:48 <srhb> MHD: Most people use Emacs or Vim
04:14:49 <ion> @quote vim.*nano
04:14:49 <lambdabot> ion says: let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
04:16:15 <bitonic> ion: OK, so we settled on 2010 :P?
04:16:19 <MHD> What makes nano awesome? I know EMACS is awesome because of Elisp, and Vim because of home-row centricity, what makes nano cool?
04:16:48 <ion> mhd: It has zero learning curve, and on the flip side zero power.
04:16:59 <MHD> oh
04:17:01 <srhb> bitonic: Yes.
04:17:15 <MHD> ion: and instant startup?
04:18:08 <ion> Vim doesn’t have an instant startup?
04:18:25 <ion> I don’t know about Emacs, i still haven’t got around to learning it (but i should).
04:18:32 <srhb> ion: I have to crank the gear like four times to get my DatorMatic to start Vim.
04:19:08 <zxq9> srhb: Sounds like you need to clean the intake out a bit...
04:23:01 <Fuuzetsu> When reasoning about your programs, what should the functions that use guards should no longer be treated as functions but as relations?
04:23:07 <Fuuzetsu> Might be a silly question.
04:23:45 <srhb> I don't understand the question. Why would they not be considered functions?
04:23:53 <Fuuzetsu> uh, seems I changed my mind about the wording there.
04:23:59 <srhb> :P
04:24:17 <Fuuzetsu> Well, functions are essentially maps and every input has an output
04:24:19 <srhb> I think your wording implies function == relation
04:24:24 <`nand`> guards are just syntax sugar for if/then/else
04:24:44 <Fuuzetsu> yes but you aren't required to have a catch-all guard
04:25:02 <`nand`> if you don't, your program will crash
04:25:08 <`nand`> you could just as well use ‘error’
04:25:11 <Fuuzetsu> Exactly
04:26:07 <quicksilver> not relations, no, Fuuzetsu
04:26:10 <quicksilver> just partial functions
04:26:21 <quicksilver> I mean, obviously, functions and partial functions are both relations
04:26:33 <quicksilver> but by saying relations you imply you're giving up the unique-answer property
04:26:34 <`nand`> they aren't treated differently from other functions in a Haskell context
04:26:37 <`nand`> any function can throw errors
04:26:47 <quicksilver> just giving up the 'always-answer' property is a smaller step
04:27:00 <Nereid> partial functions can be viewed as total functions after including bottom
04:27:41 <srhb> Fuuzetsu: f 1 = "The number one, omg!" <-- also partial, but no guards.
04:27:55 <Fuuzetsu> Yeah, of course
04:28:17 <Fuuzetsu> The question was more along the lines of whether we should give them special consideration when inspecting the program
04:28:29 <Fuuzetsu> as opposed to f x = x + 1 which is valid for all x :: Integer
04:28:59 <Fuuzetsu> would you even call f 1 = blah a proper function
04:29:09 <srhb> I'd call it a partial function.
04:29:46 <srhb> Fuuzetsu: And I would usually eliminate such functions when I am warned about them.
04:31:07 <`nand`> it's a proper function alright. a bit silly, perhaps
04:31:12 <Fuuzetsu> How is a relation different from a partial function? From what I can see on Wiki, they seem the same to me
04:31:21 <Nereid> sure it's a function, that takes 1 to blah, and everything else to _|_
04:31:26 <Fuuzetsu> although partial function is a subset of a relation
04:31:56 <quicksilver> Fuuzetsu: relations may have multiple values for one input
04:31:59 <Nereid> partial functions are relations that relate each thing in the domain to at most one thing in the codomain.
04:32:08 <quicksilver> {(1,2),(1,3)} is a relation but not a partial function.
04:32:09 <`nand`> quicksilver: a nondeterministic partial function? :P
04:32:23 <Nereid> :P
04:32:45 <quicksilver> the semantics of haskell is that all functions are potentially partial, yes
04:32:53 <quicksilver> however that doesn't mean it's not a good idea to try to keep them total where possible
04:33:01 <Fuuzetsu> Of course.
04:33:03 <quicksilver> and certainly when proving things about programs you want to know which ones are total
04:33:08 <Fuuzetsu> I think I got what I wanted~
04:33:12 <quicksilver> (or what the domains of totality are, for partial ones)
04:35:38 * `nand` thinks exceptions are okay for exceptional errors that shouldn't ever happen during normal execution; but never for things that might occur intentionally
04:36:12 <`nand`> of course, that's a subjective property
04:36:23 <quchen> `nand`: You're talking about catchable exceptions, as opposed to Eithers?
04:36:31 <`nand`> quchen: ‘error’ in general
04:36:41 <`ramses> if you seq a list, does that force evaluation of all the elements?
04:36:48 <`nand`> `ramses: no, just the first constructor
04:36:51 <`nand`> ie. [] or (:)
04:37:05 <Taneb> `ramses, see Control.Deepseq
04:37:07 <`nand`> you could seq a list all the way through without even touching the elements
04:37:17 <`nand`> (eg. ‘length’)
04:38:25 <`ramses> I'm trying to see whether an algorithm would be worse if some intermediate lists were not constructed lazily
04:38:38 <`nand`> deepseq forces evaluation of a list and its contents completely
04:38:44 <`ramses> Taneb: ah, I'll have a look :)
04:38:48 <`nand`> > [1,2,3,undefined] `deepseq` ()
04:38:49 <lambdabot>   Not in scope: `deepseq'
04:38:49 <lambdabot>  Perhaps you meant `rdeepseq' (imported from Contro...
04:38:51 <`nand`> :(
04:40:53 <Fuuzetsu> `nand`: are you the /g/ lurker nand?
04:41:43 <`nand`> Fuuzetsu: I used to go by !nandZ23/.6, if that's what you mean
04:41:50 <`ramses> so in a do block I could do "let _ = rnf list" to force evaluation of list?
04:42:01 <`ramses> (with deepseq)
04:42:29 <`ramses> ah, I completely overlooked the deepseq function itself, nvm :)
04:42:30 <`nand`> `ramses: I don't think that would work
04:42:41 <Fuuzetsu> It probably is. I swear I saw your name around few months ago when still lurking so I thought it might be you. I was just curious.
04:42:48 <`nand`> you still need to force evaluation of the () that you conveniently ignored in that binding :)
04:42:55 <`nand`> but yeah, `deepseq` is easier
04:43:16 <`nand`> `ramses: see also ‘force’
04:43:25 <`ramses> ah, but just using deepseq instead of seq would work? I guess that does force the evaluation, or doesn't it?
04:43:35 <`nand`> Fuuzetsu: my last registered post seems to be february 2012
04:44:05 <Fuuzetsu> That's `few months' in my calendar
04:44:47 <`nand`> `ramses: x `deepseq` y, roughly speaking, forces x when you force y
04:45:31 <merijn> `nand`: Isn't it "force x before you force y"?
04:45:35 <`nand`> so if you use it like:  putStrLn $ foo `deepseq` "Hello, world!" <- foo will get evaluated since putStrLn inspects "Hello, world!"
04:46:08 <`nand`> merijn: yes
04:46:24 <`nand`> merijn: but you still need to force the actual expression (which evaluates to y) for that
04:46:26 <`ramses> `nand`: grmblz, so I need to make sure the second argument of the deepseq is actually forced
04:47:03 <`nand`> `ramses: $!! may be useful
04:47:47 <`ramses> if I do "guard (deepseq list bool)" in a do block, would that force the evaluation? or can the guard be lazy as well?
04:48:53 <`nand`> that sounds like it should work, when the do block gets forced
04:48:54 <Taneb> @src guard
04:48:54 <lambdabot> guard True  =  return ()
04:48:54 <lambdabot> guard False =  mzero
04:49:11 <Taneb> Depend how strict everything else is
04:49:48 <`ramses> the do-block is (almost) the toplevel function of which I'm trying to determine the behavior when the strictness changes
04:49:55 <`nand`> in general, due to lazy evaluation, whenever any expression at all gets evaluated, it's because the expression's return value got forced; so you can figure out where the ‘evaluation flow’ is going in your code and place deepseq in the appropriate locations
04:51:40 <`ramses> I'm gonna experiment a little, but I need to change some types because there is no NFData instanc for arbitrary Num instances :(
04:51:56 <Taneb> Which is a good thing
04:51:59 <`nand`> slap (Num a, NFData a) everywhere? :)
04:52:12 <Taneb> Because you can write instance Num String
04:52:19 <Taneb> (but please don't)
04:52:33 <kith> would haskell be suited for mission critical application... like avionics, health etc... kinda what they used ada for?
04:52:38 <`ramses> hah, of course :) I was changing every Num to Integer *facepalm*
04:52:59 <`nand`> kith: I've been under the impression that haskell is already used in fields like that
04:53:08 <kith> oh really?
04:53:10 <srhb> kith: There are differences. Correctness is a good fit for Haskell, realtime probably not. But then you can make Haskell generate realtime programs, which it really is already being used for.
04:53:24 <srhb> <correct> realtime programs.
04:53:34 <`nand`> kith: in general, strong, static typing is desirable for fields like that
04:53:50 <srhb> @faq Can Haskell ensure world domination in all fields?
04:53:50 <lambdabot> The answer is: Yes! Haskell can do that.
04:54:04 <srhb> \o/
04:54:27 <`nand`> kith: another useful property is that pure functions don't have side effects, so you can isolate (potentially dangerous) interactions to small parts of your code
04:54:39 <`nand`> and test/prove/whatever everything else in isolation
04:55:13 <`nand`> kith: the only thing I'd really be worried about when safety is a huge concern is unsafe* and exceptions
04:55:22 <`nand`> Haskell has them, which may or may not be unfortunate
04:55:35 <kith> thats why i got curious about haskell in the first place
04:55:40 <`nand`> you can also define infinite loops in Haskell, which may be bad for some applications that eg. shouldn't ever crash or hang
04:55:51 <`nand`> but on the other hand, is required for turing completeness
04:56:32 <b_jonas> and Foreign stuff. those are not marked with unsafe, even though they naturally are.
04:56:43 <`nand`> yes
04:56:55 <kith> foreign stuff like user input?
04:57:14 <`ramses> kith: like binding with C I think
04:57:35 <`nand`> anyhow, if the fate of the planet is at stack, and you want something even more safe, you could some of the languages like Agda or Idris that are designed specifically to avoid failures like that
04:57:41 <`nand`> s/stack/stake/
04:58:03 <`nand`> s/you could/you could look at/
04:58:19 <`nand`> apart from that, Haskell should do a reasonably good job
04:58:26 <Fuuzetsu> > length [1..]
04:58:27 <`nand`> much more ‘safe’ than something like C, at any rate
04:58:30 <lambdabot>   mueval-core: Time limit exceeded
04:58:36 <kith> hmm
04:58:45 <kith> even more niche than haskell i guess
04:58:51 <Fuuzetsu> You could maybe also look into terminating languages
04:58:53 <`nand`> yeah
04:59:18 <`nand`> kith: the advantage of Haskell compared to those languages is that it has a substantially larger collection of packages, which may help for, yknow, actual real world applications
04:59:26 <srhb> Provably terminating programming can be a bit uncomfortable though
04:59:36 <srhb> At least so far.
04:59:39 <`nand`> Fuuzetsu: like Agda or Idris? :P
04:59:41 <kith> `nand`: yeah quite important
04:59:53 <kith> no fun if a language is just bare minimum
04:59:59 <Fuuzetsu> `nand`: quite, I seem to have missed you saying that
05:00:06 <`nand`> a good Agda program starts with a definition of natural numbers ;)
05:00:11 <kith> eww
05:00:14 * Fuuzetsu still has to learn Agda
05:00:19 <Fuuzetsu> I'll do it after the exams, I swear.
05:00:30 <kith> i still need to figure out what functinal programming really means ;)
05:00:31 <Fuuzetsu> This time I'll surely do it.
05:00:37 <`nand`> kith: programming with functions
05:00:46 <kith> there must be more to it ;)
05:00:48 <`nand`> there's no deeper meaning, it's all semantics :)
05:00:53 <Fuuzetsu> nope
05:01:10 <srhb> kith: It's probably because you forget to understand what a function is.
05:01:17 <`nand`> ‘functional programming’ is mostly a meaningless label word to vaguely mean ‘something like, yknow, those other functional languages’
05:01:20 <srhb> At least, if you come from the procedural/OOP world.
05:01:31 <kith> <--OOP world
05:01:36 <`nand`> oh
05:01:38 <Fuuzetsu> eww
05:01:45 <kith> well *shrugs*
05:01:59 <srhb> So a function cannot change its environment
05:02:00 <Fuuzetsu> @where lyah
05:02:00 <lambdabot> http://www.learnyouahaskell.com/
05:02:05 <srhb> I mean, a real function.
05:02:05 <`nand`> then perhaps a bit of clarity is advisable, ‘function’ here refers to ‘some mapping from input values to (unique) output values’; like a function in mathematics
05:02:08 <typoclass> kith: my rule of thumb -- if the language lets you write functions easily, it's a functional language
05:02:09 <srhb> There is no environment.
05:02:19 <kith> typoclass: then C is too?
05:02:20 <`nand`> not to be confused with a “function” like in C, which can do I/O, assign variables, return a random number, whatever
05:02:35 <`nand`> those are called ‘procedures’ to avoid confusion
05:02:42 <srhb> kith: foo x = launch missiles then return x+2 --is not a function
05:02:46 <kith> oooh
05:02:53 <kith> aaah
05:02:53 <typoclass> > map (\x -> x * 2) [3..7] -- kith, the part inside the parens is a function. in other languages this might have been several lines
05:02:55 <lambdabot>   [6,8,10,12,14]
05:03:04 <`nand`> typoclass: yuck, how verbose
05:03:08 <Fuuzetsu> srhb: foo x = do launch missiles >> return $ x + 2
05:03:15 <Fuuzetsu> uhh, ignore that do
05:03:27 <Nereid> > map (*2) [3..7]
05:03:28 <srhb> Fuuzetsu: Still pure, because of the semantics of monads.
05:03:28 <lambdabot>   [6,8,10,12,14]
05:03:30 <kith> <`nand`> then perhaps a bit of clarity is advisable, ‘function’ here refers to ‘some mapping from input values to (unique) output values’; like a function in mathematics <--okay this is starting to make sense :D
05:03:34 <srhb> Well, by definition actually
05:03:36 <typoclass> `nand`: less verbose than "int tmp(int x) { return x * 2; }" ! :-)
05:03:40 <Fuuzetsu> srhb: still launches missiles~
05:03:48 <`nand`> Fuuzetsu: the function doesn't :)
05:03:51 <srhb> Fuuzetsu: Not really.
05:04:09 <`nand`> Fuuzetsu: the RTS does that, when you name it ‘main’ and run the binary
05:04:11 <srhb> Fuuzetsu: You do get a recipe for launching missiles.
05:04:15 <srhb> But that's all.
05:04:39 <Nereid> someone make a monad tutorial that explains how monadic actions are cooking recipes.
05:04:45 <typoclass> ghc didn't launch missiles. it never does. the haskell runtime is a different story =)
05:04:52 <Fuuzetsu> foo = unsafePerformIO launchMissiles -- check-mate
05:05:00 <Nereid> ok, maybe just IO actions.
05:05:08 <`nand`> Fuuzetsu: haha, okay
05:05:21 <`nand`> Fuuzetsu: and this is why unsafePerformIO has no place in functional programming ;)
05:05:44 <Fuuzetsu> yep
05:05:47 <Fuuzetsu> I'm just joking around
05:05:50 <srhb> :)
05:06:28 <`nand`> joking around is the default state of #haskell except when explicitly declared otherwise
05:07:17 <typoclass> kith: anyway, if you know javascript, that's already a fairly functional language. "function (x) { return x * 2; }" is a little verbose compared to haskell's "\x -> x * 2", but it could be worse ;-)
05:07:17 <dzhus> What could possibly cause "Illegal instruction (core dumped)" error? >_>
05:07:39 <srhb> typoclass: You mean (*2)
05:07:43 <srhb> ;)
05:07:50 <typoclass> srhb: gna gna gna
05:07:54 <typoclass> =)
05:08:15 <dzhus> CoffeeScript might save some typing if you have to write JS by hand
05:08:25 <srhb> But then there's Fay anyway.
05:09:18 <`nand`> typoclass: by your definition, perhaps :)
05:09:45 <`nand`> personally, I think “functional language” doesn't just mean “makes it easy to write functions”, but also encourages the use of functions as a standard practice; if that makes sense
05:10:03 <srhb> Agreed. In other words, it should be hard to write non-functions
05:10:09 <srhb> Or at least harder.
05:10:11 <`nand`> disagree
05:10:14 <typoclass> sure, there's all that. what i meant is that on the functional language spectrum, javascript is not as far away from haskell as java or c are
05:10:20 <`nand`> languages can be multi-paradigm, functional and imperative
05:10:26 <srhb> `nand`: Disagree. :P
05:10:31 <`nand`> look at lens ;)
05:10:40 <`nand`> (okay okay, it's all functions under the hood)
05:11:05 <srhb> You said it yourself, in order to encourage functional programming there must be a difference between how you write functions and procedures and functions are encourages, ie. procedures discouraged.
05:11:10 <srhb> But nevermind the philosophy.
05:11:37 <`nand`> right, discussions like these lead nowhere
05:11:40 <psii> currently i view functional languages as languages which discourage mutation of values. for example, your can write python programs in functional style, but it is seldomly practiced.
05:11:44 <srhb> Indeed.
05:12:07 <psii> discourage variables :p
05:12:13 <typoclass> psii: i'd call that pure or immutable. or 'referentially transparent' if i'm wearing my fancy pants
05:12:19 <int-e> @quote variables
05:12:19 <lambdabot> alexbagel says: i find that my first 26 variables are always easy to name. after that it becomes a bit harder.
05:12:23 <merijn> I've been trying to spread the term "value oriented programming" instead of "functional programming"
05:12:29 <`nand`> best quote :)
05:12:33 <int-e> @quote slowly
05:12:33 <lambdabot> augustss says: So JHC has bad code. GHC had a lot of that a long time ago, and they have slowly been converting to the pure way. It's the only sensible way.
05:12:39 <merijn> I think it makes more sense if you look at what Haskell and ML do
05:12:57 <Lethalman> merijn, value oriented programming doesn't necessarily imply not having side effects
05:12:58 <`nand`> merijn: yes, makes a great deal of sense
05:13:08 <typoclass> merijn: 'value' in the sense of 'immutable value'?
05:13:11 <srhb> It's vague, therefore it works
05:13:20 <int-e> wrong quotes. I'm looking for the one where somebody explains how haskell solves the problem of variables.
05:13:48 <merijn> typoclass: In the sense of think of the data/values you want to manipulate first, then *how* to manipulate them second
05:13:50 <srhb> @quote solve
05:13:50 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
05:13:59 <srhb> @quote cjs.solve
05:13:59 <lambdabot> No quotes match. Just try something else.
05:14:11 <srhb> Hrm.
05:14:23 <`nand`> not what you're looking for but I found this hilarious quote
05:14:26 <merijn> Lethalman: No, it doesn't. I like not having side effects, but I don't think it's the crucial thing
05:14:32 <`nand`> @quote cmccann variables
05:14:32 <lambdabot> cmccann says: multi-letter type variables is an experimental new extension
05:14:40 <srhb> Ha
05:14:41 <int-e> @quote ooooh
05:14:41 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
05:14:41 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
05:15:00 <merijn> Lack of side effects forces you to focus on your data, but it's focussing on the data that's important, not the fact that you have no side effects
05:15:15 <merijn> If all your important bits are data, then that has no side effects anyway
05:15:35 <srhb> Data-driven development / DoomsDay Device
05:15:44 <srhb> I like the acronym.
05:15:47 <merijn> srhb: I do both :>
05:15:58 <`nand`> I would describe ‘imperative programming’ as ‘programming in terms of (a sequence of) commands and operations’; then non-imperative programming would be programming in terms of immutable values
05:15:58 <merijn> srhb: Yeah, I've used that name before as well
05:16:27 <merijn> typoclass: Values are by definition immutable
05:16:47 <merijn> typoclass: Even in imperative systems (well, all sane ones anyway)
05:17:22 <merijn> Two things are the same value iff they are equal in every observable way
05:17:44 <`nand`> “The exact value of pi cannot be represented in decimal notation.” <- what nonsense on the wiktionary page for ‘value’
05:18:06 <merijn> For example, in C 2 is a value, a pointer is a value, a variable is not a value
05:18:07 <typoclass> merijn: right, but don't imperative systems allow stuff like "x = 2 ; x = 7" ?
05:18:15 <typoclass> merijn: hmm
05:18:33 <merijn> typoclass: Variables are not values, they *contain* values
05:18:42 <tdammers> typoclass: yes, they do, but that just assigns a different value to the variable x
05:18:42 <srhb> `nand`: ... in finite time?
05:18:48 <srhb> :P
05:18:53 <tdammers> the values themselves (2 and 7) haven't changed at all
05:19:03 <`nand`> srhb: what does ‘time’ have to do with representation and decimal notation? :)
05:19:13 <srhb> `nand`: It doesn't. I was kidding. :P
05:19:16 <Lethalman> > runIdentity $ do x <- return 2; x <- return 7; return x
05:19:17 <lambdabot>   7
05:19:27 <Lethalman> :P
05:19:37 <`ramses> srhb: not in finite space, rather :)
05:19:50 <srhb> `ramses: Eh, either is a bit nonsense. :P
05:19:57 * hackagebot bitstream 0.2.0.2 - Fast, packed, strict and lazy bit streams with stream fusion  http://hackage.haskell.org/package/bitstream-0.2.0.2 (MasatakeDaimon)
05:19:57 <`nand`> not with a finite number of digits
05:20:01 <ion> Did i make any errors here? http://www.reddit.com/r/haskell/comments/16kf0j/parsing_markdown_with_parsec_how_pandoc_does_it/c7x9v3j?context=1
05:20:23 <typoclass> i wonder about the 'haskell has no variables' claim. i think it's quite ok to call x a variable in "f x = x + x". between several calls to f, x can vary. within one call, it doesn't vary, of course
05:20:37 <typoclass> so maybe it could be phrased in some other clearer way
05:20:38 <tdammers> haskell has variables, just not mutable ones
05:20:48 <typoclass> tdammers: yeah, that's what i'm saying
05:21:03 <`nand`> Haskell has mutable variables too, they're just represented by immutable values :)
05:21:19 <`nand`> and they're not mutable in Haskell. at least, without ST. or something
05:21:32 <tdammers> `nand`: you mean things like MVars and IORefs?
05:21:40 <`nand`> I was thinking of STRef in particular, but yeah
05:21:51 <tdammers> yeah, similar enough ;)
05:22:29 <quchen> Well, how mutable the variable called "x" is is kind of debatable. Implementation-wise it's immutable, however Lethalman's example is practically using a mutable variable.
05:22:42 <tdammers> but calling those mutable Haskell variables is a bit far-fetched, I think
05:22:50 <`nand`> Lethalman's example isn't mutating ‘x’, it's shadowing it
05:23:12 <tdammers> I'd say Lethalman's example implements mutable semantics on top of Haskell's immutable semantics
05:23:28 <quchen> `nand`: That's how it works internally, yes.
05:24:02 <quchen> int main() { int x = 3; x = 4; print x; } could be implemented in some shadowy way as well I guess.
05:25:12 <typoclass> tdammers: i think it's a more benign kind of mutability, because if someone pulled out the old value, he's still seeing a consistent old state. it didn't change sneakily behind his back
05:25:19 <typoclass> ... if that makes sense
05:25:23 <int-e> quchen: how about main() { const int x = 3; { const int x = 4; printf("%d\n", x); } }
05:25:24 <tdammers> yeah, it kind of does
05:25:26 <psii> what about  x=10; for(i=0;i<3;i++) x++; print x; ?
05:25:27 <`nand`> the way I see it, that's not mutating a variable (in a semantic tree sense), because they're not the same variable; you're introducing a new variable that just happens to have the same name.
05:25:38 <kennyd> int main () { int x = 0; { int x = 10; /* would you say x was mutated? */ } }
05:25:44 <quchen> Shadowing even ensures assignments work out properly, i.e. do { let x = 3; let y = x+4; let x = 5; return (x,y) }
05:25:53 <`nand`> int-e: (disclaimer: I don't know C) but if that's shadowing as well, then I don't see that as mutation either
05:25:54 <int-e> psii: that's hard.
05:25:58 <quchen> However, I still think Haskell is a functional language in some respect ;-)
05:26:05 <int-e> `nand`: there is none in that example
05:26:07 <Nereid> do { let x = 3; let x = x + 1; return x }
05:26:15 <typoclass> quchen: no doubt about that =)
05:26:27 <tdammers> psii: foreach (i in [0..2]) { x = 11 + i; print x; }
05:26:33 <`nand`> Nereid: sneaky one, ‘x’ is recursive
05:26:35 <int-e> `nand`: I'm probably missing the point of the discussion, sorry.
05:26:37 <`nand`> the second one, at least
05:26:53 <`nand`> int-e: as I understood it, somebody was making a point that name shadowing could be seen as a form of mutability
05:26:54 <psii> tdammers: print isn't part of the for loop ;)
05:27:02 <`nand`> in that you're changing the value of a variable
05:27:03 <tdammers> hey, in that case
05:27:06 <tdammers> print 12
05:27:12 <tdammers> print 13
05:27:14 <tdammers> whatever
05:27:16 <tdammers> ;)
05:27:18 <psii> =)
05:27:47 <tdammers> but yeah, you'd have to rewrite the loop into something recursive and return the final call's value for x
05:28:20 <int-e> `nand`: ok. that's the same as regarding  let loop 0 x = x; loop i x = loop (i-1) (x+1)  as actual mutation. It makes sense as a model for understanding the code even though nothing is actually mutated.
05:28:33 <tdammers> something like print(function (i,x) { if (i >= 2) return x; else return self(i + 1; x + 1); })
05:28:46 <tdammers> eh
05:28:55 <tdammers> something like print(function (i,x) { if (i >= 2) return x; else return self(i + 1; x + 1); }(0, 10))
05:28:56 <`nand`> int-e: yes
05:29:28 <int-e> (of course a compiler could decide to turn this into a loop with mutable variables :) )
05:29:33 <tdammers> sure
05:29:37 <`nand`> that's another issue altogether :)
05:29:46 <psii> tdammers: yeah, my point was, that it is probably not possible anymore to cheat with shadowing
05:29:59 <tdammers> and it doesn't really matter, just like the fact that type information is removed in JVM bytecode makes Java any less typed
05:30:06 <`nand`> because the target language of the compiler may have mutability which is in no way correlated to any concepts of mutability that the source language may or may not have had
05:30:46 <tdammers> `nand`: that's why my template language is "mosty pure"
05:30:53 <int-e> and when you get down to the details, almost everything a computer does is mutation.
05:31:08 <tdammers> that's not the point though
05:31:20 <`nand`> even ‘purely functional’ graph reduction machines are based on mutation ;)
05:31:31 <tdammers> if the compiler enforces purity, a whole class of dangerous things can't be done, even if it boils down to mutations at the machine level
05:32:02 <`nand`> yes I don't think int-e was saying that means haskell has mutability
05:32:23 <typoclass> i think how powerful or helpful a language is doesn't depend on how closely it reflects some internal low level
05:32:24 <int-e> tdammers: I was trying to say that one shouldn't look too deep into implementations, but rather stick to surface semantics of the source language.
05:32:24 <`nand`> just that if you want to evaluate haskell on some real machine you need mutability
05:32:53 <tdammers> int-e: then we're saying the same thing ;)
05:33:04 <psii> typoclass: depends on what you want to do :)
05:33:04 <typoclass> the cpu itself has little to no idea about types, but still a type system is a powerful thing to have
05:33:20 <quicksilver> let's all agree violently and at great length
05:33:42 <tdammers> quicksilver: I think you're right! Like, totally!
05:33:49 <typoclass> quicksilver: please, no violence. i vote for vigorously
05:33:54 <`nand`> quicksilver: I don't know, man; maybe you could make things more interesting by inserting a counterargument
05:35:20 * `nand` still thinks :: Applicative f => f a -> f b -> f (a,b) is a better abstraction for learning about Applicative
05:35:48 <int-e> heh but then how do you explain the name?
05:35:56 <quicksilver> it overemphasises tupling
05:36:07 <quicksilver> which is the same problem the Arrow methods have
05:36:07 <int-e> (which used to be Idiom but nobody understood that ...)
05:36:29 <quicksilver> although Arrows are really quite a generic structure, their methods somehow given the impression that 2-tuples are important
05:37:15 <int-e> quicksilver: ask any Lisp programmer
05:37:22 <Peaker> edwardk, hey, what was your package for dealing with expression trees?
05:37:30 <`nand`> Peaker: bound
05:37:43 <merk_> does qtHaskell's suggestion to overwrite gcc that haskell on windows ships with still apply even though it is now shipping with version 4.5 instead of 3.xx as before?
05:37:43 <Peaker> `nand`, thanks!
05:37:51 <typoclass> quicksilver: not sure what he is doing, but he might be intending that as a tool for explanation, not an implementation. "we're using tuples for illustration, but it could be other things as well)
05:37:58 <int-e> quicksilver: but what's the alternative?
05:38:17 <quicksilver> int-e: for arrows?
05:38:41 <int-e> quicksilver: yes. you have to be able to "thread" additional values through computations
05:38:44 <`nand`> typoclass: the intended semantic was to present Applicative as a way of “performing two actions and joining the results”
05:38:46 <`nand`> so perhaps
05:38:49 <`nand`> (a -> b -> c) -> f a -> f b -> f c
05:38:59 <quicksilver> I don't know, int-e
05:39:01 <`nand`> ie. categorizing applicative in terms of liftA2
05:39:08 <int-e> quicksilver: and that's what left and right do, fundamentally
05:39:14 <`nand`> (and pure, of course)
05:39:18 <int-e> quicksilver: ouch. first and second
05:39:39 <`nand`> and (&&&) / (***)
05:39:43 <`nand`> those use tuples
05:40:46 <`nand`> well, maybe you could generalize (,) to some other family of applicable types, for at least some of those operations
05:40:52 <int-e> `nand`: those can be implemented in terms of first and second. f *** g = first f >>> second g; f &&& g = arr (\x -> (x,x) >>> (f *** g)
05:40:56 <`nand`> like a Bifunctor or something
05:41:36 <`nand`> int-e: oh, yeah
05:41:41 <int-e> `nand`: so for me (a bit of a programmer perspective here, rather than a category theory one) left and right seem more fundamental.
05:41:51 <quicksilver> int-e: you could, I think, require an arrow to be applicative in its second argument
05:42:02 <quicksilver> int-e: (using the tuple-free definition of applicative)
05:42:12 <quicksilver> and put 'arr' on top
05:42:22 <quicksilver> can't remember what else is required when you do it that way.
05:43:12 <quchen> What's an Applicative seen from mathematics' side? It's more than Functor+return (because `ap`). Is it exactly a monad minus bind/join?
05:44:56 <quchen> Seeing that <*> :: (a -> f b) -> f a -> f (f b), it seems like it's a functor plus return on the other hand. If you could join that, it's a monad.
05:45:13 <quchen> But functor+return doesn't allow an implementation of <*>, right?
05:45:30 <quchen> (Well, otherwise <*> would hardly be a class method of Applicative)
05:45:32 <`nand`> int-e: of course, you can get ‘first’ and ‘second’ from (***)
05:47:39 <`nand`> so really all you need to do is find a replacement for (***) that avoids tuples
05:54:18 <`nand`> maybe something like this?
05:54:29 <hpaste> “`nand`” pasted “Arrow without tuples” at http://hpaste.org/80767
05:55:24 <Nereid> sure, and <*> is equivalent to liftA2 (,)
05:57:11 <`nand`> I guess that's what quicksilver said
05:57:28 <bxc> `nand`: in that case, could you make arr into something more like a constant arrow without losing power?
05:57:35 <Nereid> so
05:57:43 <Nereid> quchen: applicative = lax monoidal functor
05:57:43 <beaky> hello
05:58:10 <srhb> beaky: Hello again.
05:58:32 <`nand`> bxc: you mean something like arr :: b -> a () b -- ?
05:58:39 <quchen> Nereid: Lax? Monoidal? (I shouldn't ask this should I?)
05:58:39 <bxc> yeah maybe
05:58:41 <Nereid> some people like to say it's a strong such functor, but that's kind of not the point, since all functors in Hask are strong
05:58:43 <beaky> I love haskell
05:58:44 * bxc trying to do it all in his head
05:58:53 <Nereid> quchen: http://en.wikipedia.org/wiki/Monoidal_functor
05:59:14 <Nereid> observe:
05:59:16 <Nereid> :t liftA2 (,)
05:59:17 <lambdabot> Applicative f => f a -> f b -> f (a, b)
05:59:20 <Nereid> or better,
05:59:24 <Nereid> :t uncurry $ liftA2 (,)
05:59:25 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
05:59:31 <Nereid> :t pure
05:59:32 <lambdabot> Applicative f => a -> f a
06:00:43 <quchen> What does that teach me?
06:00:59 <Nereid> or rather,
06:01:01 <Nereid> :t \() -> pure ()
06:01:03 <lambdabot> Applicative f => () -> f ()
06:01:12 <Nereid> it doesn't really mean much.
06:02:14 <quchen> I'll just slowly walk away from that Wiki article and pretend I'm happy with my <*> working knowledge
06:02:25 <Nereid> that's probably the right thing to do.
06:02:31 <hpaste> “`nand`” annotated “Arrow without tuples” with “Arrow without tuples (annotation)” at http://hpaste.org/80767#a80768
06:02:37 <`nand`> bxc: this seems to type check
06:03:01 <Nereid> but the point is that the structure maps listed in that article precisely correspond to
06:03:05 <Nereid> :t uncurry (liftA2 (,))
06:03:06 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
06:03:08 <Nereid> :t \() -> pure ()
06:03:10 <lambdabot> Applicative f => () -> f ()
06:03:11 <quchen> Nereid: That implementation of Applicatives using tuples - is there some reference article on that?
06:03:36 <Nereid> well, the exercise is to implement <*> and pure in terms of liftA2 (,) and pure ()
06:03:42 <Nereid> and fmap
06:03:45 <`nand`> bxc: so this, modulo laws, seems to suggest the Arrow is equivalent to (Category a, Applicative (a b))
06:04:01 <quchen> So liftA2 (,) and pure () are sufficient to define Applicative?
06:04:03 <quchen> Interesting.
06:04:03 <Nereid> yes.
06:04:15 <quicksilver> I had this discussion a few years ago
06:04:17 <Nereid> it's a good exercise.
06:04:28 <quicksilver> I have the faint impression that one final thing was also required
06:04:28 <quchen> Nereid: Reminds me on "implement bind with join".
06:04:34 <quchen> of*
06:04:35 <Nereid> it's like that, yes.
06:04:36 <quicksilver> but many not, maybe it's just Category a
06:04:37 <`nand`> quicksilver: probably something related to laws then
06:04:42 <quicksilver> or that
06:05:02 <bxc> i rad paper on Generalized Arrows at some point
06:05:08 <bxc> s/rad/read/
06:05:10 <`nand`> would be an interesting exercise to see if the applicative laws are equal to the (weak) arrow laws
06:06:32 <bxc> that was intersting (to me) to see how they pick apart the bits of Arrow that come from diddling tuples
06:07:03 <`nand`> I bet the version of ‘first’ I gave could be souped up with lenses
06:07:14 <`nand`> something like uh
06:07:29 <srhb> Does anyone know if I can make haskell-mode restart ghci when I switch files?
06:07:48 <srhb> (Because I have it set to launch sh -c "cabal-dev ghci -Wall || ghci -Wall")
06:08:00 <`nand`> Arrow c => Lens s t a b -> a `c` b -> s `c` t
06:08:13 <`nand`> forgive my mangling of type variables
06:09:18 <`nand`> I'm sure you don't even need a lens for that
06:09:20 <`nand`> just a traversal
06:09:29 <`nand`> setter, even
06:10:03 <Nereid> have you seen profunctor lenses?
06:10:16 <Nereid> p a b -> p s t
06:10:17 <`nand`> heck, it's even simpler; (Arrow a, Functor f) => a b c -> a (f b) (f c)
06:10:22 <`nand`> Nereid: vaguely
06:10:27 <Nereid> :p
06:10:43 <Nereid> (with constraints on p)
06:10:52 <merk_> how do we call top level x = "foo" ?
06:11:13 <`nand`> definition?
06:11:32 <thoughtpolice> srhb: i don't think there is, but i imagine it wouldn't be too difficult using kill-buffer-hook if you can grab the external process list (i'm terrible at elisp, mind you.)
06:11:36 <beaky> how is haskell pattern matching implemented? does GHC make a giant branch table?
06:11:41 <typoclass> srhb: isn't there some sort of hook or something? no clue about emacs, but vi has autocommands you can tie to events like "BufEnter", "BufLeave", etc.
06:11:49 <merk_> nand definition of what?
06:12:18 <`nand`> definition of x
06:12:31 <thoughtpolice> beaky: it uses a jump table, yes. so pattern matching is quite fast
06:12:33 <`nand`> x is defined as "foo"
06:12:59 <`nand`> beaky: only for cases large enough for that to be an improvement
06:13:03 <`nand`> thoughtpolice: *
06:13:04 <beaky> ah
06:13:25 <beaky> my game has a function with over 30 cases
06:13:26 <merk_> nand if I did x a = a * a it would be a definition od a function named a. what is earlier x, it is not a function obviously
06:13:35 <typoclass> srhb: wait, is the problem getting hold of the ghci process? maybe you could do add "echo $$ > /tmp/haskell-mode-ghci.pid" inside the sh -c
06:13:36 * merk_ named x
06:13:46 <Nereid> merk_: it's a definition of a function named x.
06:13:49 <quchen> Nereid: So before I try forever and don't have the right initial conditions: The task is precisely "implement <*>, pure, fmap in terms of \() -> pure () and liftA2 (,)"?
06:13:54 <thoughtpolice> i haven't kept up with the backend in a while, last I remembered pattern matching became CmmSwitch which is generally turned into a table
06:14:03 <quchen> ^^ (Plus prelude stuff?)
06:14:07 <Nereid> quchen: no,
06:14:14 <thoughtpolice> i wouldn't be surprised if a lot of this has changed in the past few months
06:14:16 <bxc> merk_: are you asking for the name of that definition, or how to invoke it?
06:14:18 <Nereid> define <*> and pure in terms of pure (), liftA2 (,), and fmap
06:14:29 <Nereid> well, \() -> pure () is the same as pure ().
06:14:34 <`nand`> merk_: definition of a value
06:14:37 <quicksilver> merk_: it's a definition, or an equation, and it defines a name x.
06:14:37 <`nand`> (functions are values too)
06:14:51 <quicksilver> myself I wouldn't call it a function x for the boring reason that it isn't a function.
06:14:53 <merk_> bxc the name. it is not a function. calling it variable is weird as it's value cant change
06:14:59 <`nand`> all top level bindings are definitions of values
06:15:00 <bxc> the profiler calls it a CAF doesn't it?
06:15:08 <sopvop> is there something like `consJust (Just x) xs = x:xs`  in base or platform? (hoogle says no)
06:15:21 <`nand`> bxc: yeah, but wouldn't that be an internal detail?
06:15:34 <Nereid> :t maybe id (:)
06:15:36 <lambdabot> Maybe a -> [a] -> [a]
06:15:49 <bxc> |http://www.haskell.org/haskellwiki/Constant_applicative_form
06:16:12 <sopvop> Oh, that's smart
06:16:13 <Nereid> also see catMaybes
06:16:22 <MaybeCallMe> How do I test a update :: Double -> State A B with quickcheck?
06:16:43 <bxc> that page makes it sound like its stuff that doesn't have a lambda, which is different from partially applied functions
06:16:48 <bxc> so I think CAF isn't the right term
06:16:58 <`nand`> quicksilver: I like to avoid ‘equation’ because equations are, in my mind, supposed to be commutative in nature
06:17:15 <`nand`> which haskell definitions are; you can't write ‘a * a = x a’
06:17:46 <quicksilver> it's a fair point but it's a standard term
06:19:58 * hackagebot MFlow 0.2.0.4 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.2.0.4 (AlbertoCorona)
06:20:31 <quchen> Nereid: I've got something that typechecks: pure = \x -> fmap (const x) (pure ())
06:20:41 <Nereid> you are winner.
06:20:49 <quchen> "Create a dummy applicative and fmap the value over it"
06:20:53 <quchen> Wonderful! :-)
06:20:55 <quchen> Now on to <*>
06:22:17 <Nereid> if you get something that typechecks, it's probably right. ;)
06:22:29 <srhb> typoclass: I guess the problem is mostly detecting whether this is a different file from the one I originally launched ghci for
06:22:46 <Nereid> unless you accidentally swap the order or something, which can happen I guess with <*>
06:22:46 <quchen> Nereid: Yeah I know, but on the other hand that won't teach me much then
06:23:02 <Nereid> see if you can prove that you're right with the applicative laws.
06:25:34 <typoclass> srhb: do you plan to kill and restart ghci, or do ":r"?
06:25:37 <`nand`> Nereid: I used unsafeCoerce and it type checked, but when I try running it it keeps telling me something like “Segmentation fault.” what am I doing wrong? please help
06:25:48 <Nereid> oh you.
06:25:58 <Nereid> unsafeCoerce is not one of liftA2 (,), pure, or fmap.
06:26:00 <Nereid> therefore you lose.
06:26:10 <quchen> Nereid: Do I need uncurry?
06:26:16 <Nereid> that may help.
06:26:23 <Nereid> I forget the solution.
06:26:27 <Nereid> I'd have to write it again/
06:26:33 <srhb> typoclass: Kill. I guess I'll just save the name of the buffer first.
06:26:38 <elliott> `nand`: We have that problem in lens a lot.
06:26:53 <typoclass> srhb: yeah, write it to a file or something
06:26:57 <`nand`> elliott: just catch the segfault with unsafePerformIO and return an empty traversal or something
06:27:04 <elliott> (actually our only unsafeCoerce so far was unsafeCoercing away a newtype that was actually a data, which produced nonsense integers that failed our tests but no crashes)
06:27:06 <`nand`> (can you actually do that?)
06:27:17 <elliott> doubt the RTS can recover from that
06:27:27 <Nereid> quchen: yeah, uncurry is helpful.
06:27:30 <elliott> er *only unsafeCoerce bug
06:27:37 <Nereid> (but of course uncurry is definable from scratch.)
06:27:39 <elliott> well, apart from the bugs where sometimes we exported unsafeCoerce to clients. but those never affected *us*
06:27:58 <quchen> Nereid: as in "just define it yourself as a helper"?
06:28:05 <Nereid> sure.
06:28:12 <Nereid> no need to, though
06:28:17 <`nand`> Nereid: pure x = pure x -- type-checks, what do I win?
06:28:26 <typoclass> can you send a posix signal to a running ghci so that it will do ":reload"?
06:28:36 <Nereid> `nand`: it's not total
06:28:56 <srhb> typoclass: I don't want to reload, I want to run cabal-dev ghci if possible, otherwise default to ghci. :)
06:28:56 <`nand`> oh, did you have that in your requirements? :(
06:29:03 <Nereid> I do now.
06:29:18 <quchen> Why isn't that total?
06:29:18 <`nand`> I submit
06:29:26 <typoclass> srhb: right, that was tangential :-) i was wondering about it the other day, and your questions made me remember that
06:29:34 <quchen> Seems to work for most x.
06:29:45 <Nereid> quchen: total means non-bottom values go to non-bottom values.
06:30:06 <Nereid> in pure x = pure x, pure x is bottom for any x.
06:30:10 <`nand`> elliott: glad to see lens hasn't lost its optimism towards end users
06:30:30 <quchen> Nereid: Oh, so when you're actually writing it like that in Haskell
06:30:36 <Nereid> yeah.
06:30:40 <quchen> As in circular reasoning works because circular reasoning works
06:31:11 <Nereid> I don't even know what the applicative laws are in terms of <*>
06:31:29 <quchen> Neither do I if that helps
06:31:49 <Nereid> well, the second part of the exercise is to prove that what you come up with for pure and (<*>) is equivalent to the original
06:31:57 <Nereid> anyway, I desperately need sleep, so bye.
06:32:05 <`nand`> pure f <*> x = fmap f x; f <*> pure x = fmap ($x) f -- ?
06:32:08 <`nand`> and associativity
06:32:15 <Nereid> yes, associativity.
06:32:19 <Nereid> state it.
06:32:23 <Nereid> and bed.
06:32:24 <Nereid> :p
06:32:24 <Taneb> pure f <*> x = fmap f x; (.) <$> f <*> g <*> x = f <*> (g <*> x)
06:32:34 <`nand`> blah
06:32:36 <`nand`> I wanted to do that
06:32:42 <Taneb> :P
06:34:20 <mm_freak> let's say i have an Email type:  data Email = Email { _user :: Text, _domain :: Text }
06:34:38 <mm_freak> what kind of lens would convert it to a textual representation and back?
06:34:57 <mm_freak> it's not Iso, because "blah" is not valid, but "blah@blubb" is
06:35:47 <mm_freak> you can always go from Email to Text, but going from Text to Email might fail
06:36:23 <psii> mm_freak: maybe an Iso from Email to Maybe Text?
06:36:48 <bxc> Text to Maybe Email?
06:36:55 <mm_freak> psii: isn't there anything that captures this more closely?  is this a prism?
06:37:22 <psii> mm_freak: i don't know the answer, but I'm interested in the solution as well. stumbled upon it myself some time ago
06:38:18 <`nand`> looks like a Prism' Text Email
06:38:22 <psii> always wondered how you can do this Maybe thing with lenses
06:39:02 <`nand`> which is like a Traversal' Text Email (not all are valid) with a Getter' Email Text
06:39:41 <`nand`> oh, not quite a Traversal'
06:39:46 <`nand`> a 0-or-1 target traversal
06:39:49 <`nand`> what was that called again? affine?
06:39:54 <`nand`> relevant?
06:39:58 <`nand`> affine *and* relevant?
06:40:17 <srhb> Success. Sometimes elisp is fantastic. Now I have cabal-dev ghci or ghci, whichever actually launches. ^_^
06:40:19 <`nand`> definitely not the latter
06:40:25 <`nand`> I think it was affine
06:40:40 <Taneb> The one that only needs Pointed, I think
06:41:29 <elliott> affine.
06:42:18 <`nand`> so relevant = 1-or-more, and affine+relevant = lens?
06:42:44 <Taneb> affine+relevant = traversal, I think
06:43:18 <Taneb> affine*relevant (if that makes sense) would be lens
06:43:18 <mm_freak> ok, i short, what i'm looking for is a traversal?
06:43:42 <Taneb> prism, I think
06:43:59 <mm_freak> the problem with prisms and traversals is that i can't invert them
06:44:05 <mm_freak> at least i don't know how
06:45:00 <Taneb> > review _just 5
06:45:01 <lambdabot>   Just 5
06:45:36 <Taneb> > Just 5 ^? _just
06:45:37 <lambdabot>   Just 5
06:45:50 <Taneb> > Left 5 ^? _right
06:45:51 <lambdabot>   Nothing
06:45:58 <Taneb> > review 5 _right
06:45:59 <lambdabot>   Could not deduce (GHC.Num.Num
06:45:59 <lambdabot>                      (Control.Lens.Prism.APri...
06:46:04 <Taneb> > review _right 5
06:46:06 <lambdabot>  Terminated
06:46:08 <Taneb> ...
06:46:10 <Taneb> > review _right 5
06:46:12 <lambdabot>   Right 5
06:46:23 <Taneb> "review" turns a prism around
06:47:43 <mm_freak> let me try
06:47:55 <psii> Taneb: but then it is read only, am i right? if I understand mm_freak correctly, then he wants mutable lenses in both directions?
06:50:15 <merk_> does qtHaskell's suggestion to overwrite gcc that haskell on windows ships with still apply even though it is now shipping with version 4.5 instead of 3.xx as before?
06:50:43 <merk_> qtHaskell's page is a bit outdated
06:51:08 <nunquam> Hi, can anyone briefly explain me what the difference is between pattern matching and guards?
06:51:25 <mauke> guards are normal (boolean) expressions
06:51:33 <geekosaur> patterns match on structure, guards on values
06:51:42 <nunquam> I think that guards are just syntactic sugar for if/then expressions, and pattern matching is used to deconstruct data
06:51:54 <nunquam> oh that's a nice one geekosaur
06:52:13 <mauke> well, if/then/else is syntactic sugar for pattern matching on True/False
06:52:19 <typoclass> nunquam: what you said sounds good
06:52:48 <nunquam> yes I follow you mauke
06:53:05 <nunquam> it's a question from a professor
06:53:19 <nunquam> so I suspect he or she looks for some real difference
06:53:38 <nunquam> given that, I'm liking geekosaur s answer :)
06:54:11 <nunquam> thanks btw @all :)
06:54:24 <mauke> never :)
06:55:17 <nunquam> hang on though, cause I've got some neat questions coming ;)
06:57:21 <nunquam> Ok, here's another one: "What is the function/use of type classes in Haskell?"
06:57:50 <srhb> nunquam: What have you got yourself?
06:57:53 <typoclass> nunquam: do you have any ideas on that?
06:58:03 <nunquam> My answer: It serves as a generic interface that can be implemented by other types grouping common functions and properties
06:58:12 <srhb> Sounds about right.
06:58:32 <nunquam> Ok, feel free to correct, add some important info.
06:58:35 <srhb> "other" types is a bit confusing.
06:58:41 <srhb> Other than what?
06:59:20 <nunquam> i just mean datatypes implementing the typeclass
06:59:36 <mm_freak> "type classes in haskell 2010 serve the purpose of of making type signatures and function application more pleasing"
06:59:45 <typoclass> nunquam: (i think you mean 'instances of the typeclass')
06:59:50 <mm_freak> "type classes in GHC haskell are prolog on the type level"
07:00:03 <nunquam> yes thats a better formulation, thanks mm_freak  :)
07:00:09 <srhb> mm_freak: Okay, now you just HAVE to elaborate on the last one :P
07:00:13 <mm_freak> nunquam: it was a joke
07:00:19 <zomg> mm_freak: haha, you should see some of the yesod type signatures... my god the typeclasses...
07:00:20 <mm_freak> but yeah, it's not wrong =)
07:00:22 <zomg> =)
07:00:32 <mm_freak> zomg: i know them…  i used yesod ;)
07:00:37 <zomg> haha
07:00:45 <zomg> yeah pleasing is not the word I would use
07:00:46 <zomg> :D
07:00:53 <mm_freak> zomg: if you want something scarier, have a look at ChoiceT from my old 'contstuff' library =)
07:01:05 <mm_freak> srhb: ever done type level computation?
07:01:18 <srhb> mm_freak: Only the basic Nats stuff.
07:01:36 <mm_freak> srhb: you can do it with type families, but the classic way is to use type classes, which is essentially type-level prolog =)
07:03:25 <mm_freak> zomg: also a library i haven't released yet implements this type:  newtype Continue e f m a = Continue (m (Either e a, f (Continue e f m a)))
07:03:35 <mm_freak> i love it…  it's scary useful =)
07:06:55 <srhb> Are there any guidelines for choosing between Parsec and Trifecta?
07:07:02 <nunquam> What are for you guys the advantages and disadvantages of Lazy Evaluation?
07:07:10 <nunquam> so far I got:
07:07:14 <nunquam> + less mem usage
07:07:26 <nunquam> + infinite data structures
07:08:00 <zomg> My understanding of lazy eval is not perfect but doesn't it actually cause higher memory usage in certain situations (eg. where you have a long cons chain)
07:08:01 <edwardk> srhb: parsec is well-supported and old, trifecta is neat, gives great diagnostics, syntax highlighting, etc. but is experimental and the API is still radically subject to change
07:08:09 <nunquam> + higher performance (unnecessary computations are avoided)
07:08:11 <srhb> edwardk: Thanks. :)
07:08:24 <int-e> nunquam: + custom control operators (like if)
07:08:36 <nunquam> hmm
07:08:43 <nunquam> could you explain that a bit more int-e?
07:08:57 <parcs> > (any id [], not (all id []), all id [], not (all id []))
07:08:59 <lambdabot>   (False,False,True,False)
07:09:01 <zomg> I think one of the reasons for lazy evaluation for haskell was to allow the implementation of monadic IO in a pure fp language
07:09:14 <nunquam> you mean if then else structure is possible thanks to lazy evaluation?
07:09:18 <zomg> and I think I also read that if spj would get to choose, he'd remove laziness from haskell :P
07:09:42 <int-e> nunquam: if True t f = t; if False t f = f <-- if you do this in a strict language, both t and f will be evaluated when using 'if'.
07:09:56 <typoclass> zomg: was that meant tongue in cheek or srsly?
07:09:57 <sipa> nunquam: in haskell, ifthenelse could be written as a normal function: if cond truecase falsecase = case cond of {True -> truecase; False -> falsecase}
07:10:08 <int-e> nunquam: no, I mean you can actually implement such functionality as a function
07:10:13 <int-e> @src (||)
07:10:13 <lambdabot> True  || _ =  True
07:10:13 <lambdabot> False || x =  x
07:10:15 <zomg> typoclass: seriously I think, sadly I don't have the source of where I read that from though
07:10:18 <nunquam> oh
07:10:22 <koltar> is there a version of takeWhile that returns the first element which failed the test?
07:10:42 <int-e> this is another example - || only evaluates the second argument if the first one is not true.
07:10:42 <koltar> i've written one myself, but i'm wondering if there's one in Base
07:10:47 <zomg> typoclass: I think it had something to do with the fact the way monadic io etc. works could be implemented today without the use of laziness
07:11:15 <typoclass> zomg: hmm
07:11:25 <nunquam> ok thanks
07:11:33 <nunquam> and on disadvantages I have:
07:11:38 <nunquam> - debugging is hard
07:11:56 <nunquam> - IO becomes complicated cause IO needs an order of execution like print this then that ...
07:12:00 <int-e> nunquam: - less performance, - more memory (it really depends on what you're doing, exactly). For Haskell, - hard to predict performance.
07:12:46 <int-e> (the latter point is rooted in aggressive optimization rather than laziness per se)
07:14:26 <mm_freak> ok, what i was looking for is indeed a prism
07:14:28 <mm_freak> thanks
07:14:44 <mm_freak> email :: SimplePrism Text (Text, Text)
07:14:53 <edwardk> prisms pop up all over once you know they exist ;)
07:15:10 <mm_freak> indeed
07:15:27 <nunquam> Then one last question: How does Haskell allow for generic programming
07:15:47 <nunquam> I have: thanks to parametric polymorfism & type constraints
07:16:16 <int-e> nunquam: type classes?
07:16:25 <t7`> morph*
07:17:12 <nunquam> oh, yes
07:21:09 <koltar> edwardk: what are prisms, exactly? the Control.Lens docs are light on explanations
07:21:52 <edwardk> koltar: think of a prism like a first class constructor, you can use it to build or match on the constructor, and it devolves to a traversal of the contents of the constructor
07:22:05 <edwardk> > 5 ^. remit _left
07:22:06 <lambdabot>  Terminated
07:22:08 <edwardk> > 5 ^. remit _left
07:22:10 <lambdabot>   Left 5
07:22:24 <edwardk> > Left 5 & _left +~ 1
07:22:25 <lambdabot>   Left 6
07:22:30 <edwardk> > Right 5 & _left +~ 1
07:22:31 <lambdabot>   Right 5
07:22:42 <edwardk> > Right 4 ^? _left
07:22:44 <lambdabot>   Nothing
07:22:46 <edwardk> > Left 4 ^? _left
07:22:48 <lambdabot>   Just 4
07:23:13 <edwardk> koltar: because its a valid traversal you can do anything you can do to a normal traversal, fold, etc. to a prism as well
07:23:37 <edwardk> and every iso works directly as a prism or a lens, so you can use the prism combinators on those too
07:23:38 <koltar> edwardk: where can i find simple examples of prisms?
07:23:41 <shapr> Levent Erkok's video controlling Arduino from Haskell: http://www.youtube.com/watch?v=aa00_AiwJ7I
07:24:09 <koltar> they sound like something i've been looking for a long time
07:24:11 <edwardk> koltar: well, if you look at lens HEAD there are a ton of example prisms in Control.Exception.Lens where I use them to build a version of the exception hierarchy where you don't need ScopedTypeVariables, one sec
07:24:55 <Taneb> koltar, https://github.com/ekmett/lens/blob/master/src/Control/Lens/Prism.hs#L143
07:25:10 <Taneb> _Left, _Right, and _Just are about the simplest you'll meet
07:25:12 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Exception/Lens.hs provides a lot of prisms, but they are constructed in such a way that they upgrade to equalities on the right type.
07:26:14 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Cons.hs builds _Cons and Snoc as prisms, that lets you use 'cons' as 'the review' side' of the _Cons prism and 'uncons' as previewing/matching.
07:26:35 <edwardk> then
07:26:35 <edwardk> _head = _Cons._1; _tail = _Cons._2
07:26:44 <edwardk> become the traversals of the head and tail of a structure
07:26:52 <edwardk> because they are composing a prism with a lens
07:26:54 <koltar> that brings up another question: what do the leading underscores mean? i know that's a convention of some kind
07:27:15 <edwardk> koltar: _Foo means its an iso or a prism for the constructor Foo
07:27:24 <edwardk> _foo usually means 'foo was taken' ;)
07:27:43 <edwardk> and its an underoccupied portion of the namespace, so nobody else tends to touch it
07:27:57 <edwardk> it was selected originally because
07:28:05 <edwardk> (1,(2,3))^._2._1
07:28:08 <edwardk> > (1,(2,3))^._2._1
07:28:10 <lambdabot>   2
07:28:15 <edwardk> the _'s largely vanish against the .
07:28:29 <koltar> lots of operators i've never seen before
07:29:50 <magicman> _var as a pattern variable will also tell GHC to not issue "unused binding" warnings for that variable.
07:30:07 <magicman> But that's completely unrelated <_<
07:30:35 <magicman> (also, I like how __ is a valid identifier)
07:31:39 <koltar> magicman: when would you use _var in patterns instead of _ if _var is unused?
07:31:53 * quicksilver suspects edwardk is workign up to writing a program which is not only valid haskell but also parses as morse code.
07:32:07 <flux> koltar, when you want to give it a name in order to make it more understandable
07:32:16 <magicman> Mostly as a form of documentation for people who read the code.
07:32:33 <edwardk> quicksilver: http://comonad.com/haskell/remorse-1.0/remorse.hs Malcolm Wallace beat me to it
07:32:38 <koltar> ...i should have thought of that
07:33:52 <srhb> It's almost brainfuck.
07:34:01 <quicksilver> edwardk: hmm. Never underestimate mr wallace.
07:34:03 <parcs> what happens if you do something like mask $ \restore -> forkIO (restore action)
07:34:32 <saeidw> ...what did I just read?
07:34:41 <edwardk> parcs: the world probably ends
07:34:45 <geri> hi does hashkell check type safety at compile time?
07:34:58 <koltar> geri: extensively
07:35:01 <edwardk> geri: yes
07:35:21 <srhb> > putStrLn 9000
07:35:22 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
07:35:22 <lambdabot>    arising from the literal `...
07:35:23 <geri> c++ and javascript does it at runtime?
07:35:53 <koltar> geri: C++ has a mix of compile-time and run-time type-checking
07:36:11 <geri> http://people.mozilla.com/~roc/Samsung/MozillaRustAndServo.pdf ...why they dont use hashkell here, if the want type safety...they go for java script...hmmm!?
07:36:25 <geri> and say c++ is bad too ^^
07:36:32 <srhb> Am I understanding remorse correctly.. It's a Haskell program that looks like morse code that transforms Haskell programs to look like morse code?
07:37:02 <shapr> srhb: Where did you find it?
07:37:18 <shapr> oh it's online!
07:37:26 <srhb> edwardk linked it.
07:37:37 <shapr> Wow, I thought it was lost forever!
07:37:43 <parcs> geri: ask them!
07:37:49 <shapr> I lost all of the IOHCC entries years ago :-(
07:38:05 <geri> parcs, would you go with hashkell? :)
07:39:19 <typoclass> geri: well, if you ask in the #haskell channel, you'll probably get a lot of people who would indeed use haskell for all kinds of things :-)
07:39:35 <geri> typoclass, give me a logical answere :)
07:40:07 <geri> are there haskell browser out there?
07:40:15 <covi> Mutually recursive modules problem. I have A.hs-boot and a module B which imports A with the SOURCE pragma. A has something like "data DA = V1 B1 | V2 B2", and in A.hs-boot I have the line "data DA". The problem is, in module B, V1 and V2 are not available.
07:40:40 <srhb> geri: There is nothing to be gained but subjective reasonings.
07:40:57 <heatsink> You can put the entire data definition in the hs-boot file
07:40:57 <typoclass> geri: as far as i'm concerned, i would use haskell. i've kind of lost interest in javascript, python, c#, etc. since discovering haskell
07:40:59 <geri> srhb, how about speed?
07:41:02 <shapr> geri: Yes, there is a haskell browser, written by ManateeCat
07:41:04 <heatsink> as long as B1 and B2 are also in scope in the hs-boot file
07:41:08 <srhb> geri: Haskell can be fast.
07:41:14 <shapr> geri: and assembly can be slow
07:41:27 <geri> safety?
07:41:30 <geri> security
07:41:34 <srhb> Well, technically languages can't be fast, but you get the point.
07:41:34 <shapr> yes
07:41:39 <geri> hm
07:41:57 <srhb> Why doesn't lambdabot have a @somebodyIsAskingAboutLangAvsLangB :<
07:41:57 <edwardk> srhb: it can also undo the transform
07:42:02 <covi> heatsink: I didn't do that, because B1 and B2 actually are defined in module B
07:42:06 <srhb> edwardk: Ha!
07:42:07 <shapr> geri: There are some real downsides, such as no hard real-time guarantees, and it doesn't run well in less than 128MB of RAM
07:42:13 <edwardk> srhb: http://comonad.com/haskell/remorse-1.0/README
07:42:27 <srhb> edwardk: thanks!
07:42:30 <geri> shapr, in haskell?
07:42:37 <geri> why?
07:42:43 <edwardk> srhb: basically he remorsed remorse before submitting it to the contest
07:42:46 <koltar> geri: i'm using Haskell for a 2D birds-eye-view tactical shooter
07:42:47 <shapr> geri: Because of the runtime system
07:42:54 <srhb> edwardk: Cruel. :P
07:43:20 <geri> shapr, java script is better?
07:43:23 <osfameron> that's fairly common practice for obfu.  See Acme::Eyedrops et al on CPAN too
07:43:29 <geri> for hard realtime stuff
07:43:34 <shapr> geri: no
07:43:50 <shapr> geri: For hard real-time you want something else that's neither javascript or Haskell.
07:44:01 <shapr> geri: Both of those have a runtime system that will get in your way.
07:44:13 <srhb> The superior language for any task is obviously assembly after all!
07:44:43 <geri> shapr, so in this case you need to go for c++?
07:45:01 <shapr> geri: Some people would use C++ for embedded systems, I would prefer C over C++ for that purpose.
07:45:15 <shapr> geri: Because C is a portable assembly language :-P
07:45:21 <geri> because a runtime system makes things unpredictable?
07:45:23 <srhb> geri: http://en.wikipedia.org/wiki/Synchronous_programming_language
07:45:34 <srhb> There's a small overview of some candidates for the task
07:45:44 <geri> yes
07:45:45 <geri> because a runtime system makes things unpredictable?
07:46:00 <shapr> geri: Right, if your computer is driving a fighter jet, a runtime system does not respond fast enough.
07:46:01 <osfameron> embedded systems don't *necessarily* have to be fast
07:46:12 <geri> shapr, a sec
07:46:23 <heatsink> covi, it's going to be awkward to make recursive modules like that work
07:46:23 <osfameron> you can run plenty of industrial and sensor applications with an arduino (running C++) or a raspberry pi (running Python or Javascript or Haskell or whatever)
07:46:27 <geri> check: https://developer.cdn.mozilla.net/media/uploads/demos/a/z/azakai/3baf4ad7e600cbda06ec46efec5ec3b8/bananabread_1348775105_demo_package/index.html
07:46:47 <heatsink> covi, consider putting the data structures into the same file, or parameterizing some data structures to break dependences
07:47:12 <shapr> geri: Looks nice, but doesn't mean javascript is responsive enough for a fighter jet :-)
07:47:34 <geri> not for a real fighter jet? :D
07:47:45 <shapr> geri: In my opinion, Haskell is a very powerful language and is the best choice for 95% of programs written today. But there are situations where Haskell is not the best choice.
07:48:14 <srhb> shapr: (And for that, there are EDSLs for generating the right choice?) :-)
07:48:22 <typoclass> shapr++, good summary
07:48:23 <shapr> srhb: Yes, that too :-)
07:49:00 <srhb> Bottom line: Use Haskell if it's the right choice, otherwise use Haskell to make a program in whatever flavor is the right choice. :P
07:49:01 <shapr> geri: I'm writing Haskell code to run on my Raspberry Pi, what uses do you have in mind for Haskell?
07:49:35 <geri> shapr, no use...just try to understand why they go for java script :)
07:49:50 <covi> heatsink: I know it's awkward.
07:49:55 <koltar> in general, i think Haskell is a better choice than most people think; usually, politics intervenes
07:49:58 <covi> heatsink: but do you know why that fails?
07:50:44 <frerich> koltar: Don't you mean economics, actually? In order for Haskell to be useful you have to have people available who can actually use that language.
07:50:50 <shapr> geri: Haskell is very much worth learning :-)
07:50:57 <t7`> i declare a Fatwā against javascript
07:50:59 <srhb> geri: People like to program in what they do best. There are historical reasons, a lot of religion, taste etc. That's also partially why you'll probably always get "use Haskell!" in here. :P
07:51:03 <heatsink> covi, it fails because A.hs-boot doesn't define V1 or V2
07:51:18 <koltar> frerich: economics can factor in, but politics does so more often IMO
07:51:27 <shapr> frerich: I didn't find Haskell difficult to learn, and I didn't have any math or computer science courses when I started learning Haskell.
07:51:43 <frerich> shapr: Well, that's good for you. :)
07:51:43 <geri> srhb, true :)
07:53:08 <koltar> geri: i'm learning Haskell because it's very different from most languages, which forces me to think differently about problems
07:53:18 <geri> ok
07:53:21 <shapr> frerich: I think that might have made it easier :-) I didn't have to unlearn C++ habits to learn Haskell!
07:53:30 <koltar> in the process, i end up with a better understanding of the problems
07:54:41 <osfameron> it's not only the problem of *unlearning*.  It's also having a way in your head that you can do *fast*, versus having no idea how to do something in Haskell, that can get frustrating if you're learning it from an existing programming background.
07:55:00 <koltar> osfameron: oh yeah
07:55:03 <merijn> General process of Haskell sceptics that actually *try* to learn new things: "Everyone tells me haskell is so different, I should learn it" -> "hey, this is pretty cool" -> "wait, this IO things is total bollocks and why does nothing I'm used to work?" -> "this sucks, I'll keep learning so I can better understand other things and then go back to my old language" ->
07:55:23 <merijn> "hey, this is actually pretty neat" -> "I should use Haskell more often" -> "Haskell is the best thing evar!!"
07:55:47 <Iceland_jack> merijn: → “I can't use Haskell at my job” → unhappiness
07:55:50 <merijn> Some people just bail out during the "IO is bollocks" phase and then write a lot of confused blog posts
07:56:14 <merijn> Iceland_jack: Do what I do, secretly replace their codebase with haskell when people aren't looking ;)
07:56:45 <Iceland_jack> Obviously that is not possible everywhere :)
07:56:56 <merijn> Iceland_jack: If you can't put haskell in your main code base, try sneaking it in by writing small utilities and tools in it that help developing the main code base in language X, to slowly convert colleagues
07:56:58 <koltar> merijn: i kind of skipped the "this sucks" phase; then i realized i was trying to use Haskell idioms in imperative languages
07:57:14 <koltar> and came back to Haskell
07:57:27 <shapr> koltar: That happened to me accidentally!
07:57:51 <shapr> I was writing python, pursuing this picture I had in my head, and my friend Darius said "Why are you writing Haskell in Python?"
07:58:09 <Iceland_jack> A lot of places have strict rules about what you can use for writing utilities as to exactly /not/ end up with 200 utilities written in 50 languages that only the original author knows :P
07:58:14 <merijn> I had a moment of confusion when I was trying to define an ADT like tree in C earlier this week and compiler rejected in
07:58:26 <merijn> s/in$/it
07:58:51 <merijn> Turns out you can't have structs of undefined size in C :\
07:58:59 <covi> heatsink: But the doc says we can omit the part after the '=' sign.
07:59:15 <nyc> merijn: It can be done but is awkward.
07:59:26 <merijn> nyc: Not the way I wanted/wrote it
07:59:37 <koltar> nyc: that's a good description of C in general :P
07:59:55 <hamid> http://news.ycombinator.com/item?id=5050972 i'm gonna say that if you the guy who commented you helped me too :P
08:00:16 <covi> heatsink: well, is there anyway to still achieve such goal by using hs-boot?
08:00:30 <hamid> missed the verb = ...  if you help the  ...
08:00:48 <typoclass> i said "learning haskell makes you a better programmer, whether you use haskell or another language". the coworkers said "learning haskell makes you write incomprehensible gunk, whether you use haskell or another language"
08:00:58 <osfameron> hehe
08:01:33 <koltar> typoclass: you say toMAYto, i say toMAHto
08:01:47 <typoclass> koltar: haha
08:01:51 <Iceland_jack> Since we're on C:
08:01:52 <Iceland_jack> #haskell.log-01:47 < cmccann> C's type system works on the honor system :P
08:02:06 <Hafydd> Heh.
08:02:27 <sipa> so the question is whether programmer quality is measured by the nonreadability of what you write (as measured by the average programmer), or by your the degree of nonreadability (as measured by the average programmer) code you can read can have
08:03:10 <hamid> actually haskell kinda enable weird capabilities in programmers :D
08:03:32 <S11001001> @src fix
08:03:32 <lambdabot> fix f = let x = f x in x
08:03:59 <koltar> HOFs alone can make your code nigh-incomprehensible to the uninitiated, yet they make it so much more readable
08:05:08 <hiptobecubic> operators do, but i don't think well named functions do that
08:05:35 <S11001001> @ty _2
08:05:37 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
08:06:08 <koltar> hiptobecubic: even well-named HOFs confuse quite a few programmers
08:06:59 <hiptobecubic> true, but you can learn them one at a time
08:07:31 <mm_freak> when is a function well-named?
08:07:31 <typoclass> "seems as if lazy-by-default is actually an obstacle for fast programs." <- maybe, but that doesn't mean a naive eager-by-default is better. in my experience you end up manually implementing laziness anyway, "if (thing == NULL) thing = initTheThing(); return thing;" etc.
08:07:56 <mm_freak> fmap maybeMappingFunction = maybe Nothing (Just . maybeMappingFunction)
08:08:10 <koltar> mm_freak: when the name and the type signature together almost completely document its behavior
08:08:12 <mm_freak> in many cases a name like 'f' or 'k' is much more sensible
08:08:30 <typoclass> koltar: you know, that's actually a pretty good rule of thumb
08:08:37 <mm_freak> koltar++
08:12:33 <frerich> koltar: I guess by that definition
08:12:40 <frerich> koltar: 'nub' is not such a well-named function.
08:12:53 <koltar> frerich: it really isn't, i think
08:13:03 * merijn agrees
08:13:37 <typoclass> i think it's not nearly used as often as map, so nub should have a longer more descriptive name
08:13:54 <merijn> :t nub
08:13:55 <n-dolio> I guess map is good with any name?
08:13:55 <lambdabot> Eq a => [a] -> [a]
08:14:06 <frerich> typoclass: IMHO 'uniq' would be fine and just one character more.
08:14:18 <hiptobecubic> nub is a terrible name
08:14:19 <merijn> Yeah, uniq would be better, also matches *nix
08:14:31 <hiptobecubic> usually i rename it
08:15:04 <typoclass> yep. or even 'unique'
08:15:04 <osfameron> you could also create a uniq that requires Ord
08:15:16 <osfameron> as nub only demands Eq, iirc
08:15:32 <hiptobecubic> do you need ord?
08:15:34 <hiptobecubic> i guess you can optimize better
08:15:52 <osfameron> yeah. You could use a Set, instead of a nest of lambdas
08:16:04 <n-dolio> With Eq it's O(n*k), with Ord it's O(n*log k)
08:16:17 <koltar> merijn: uniq is better, but the analogy to *nix falls flat: uniq behaves like (map head . group)
08:16:50 <frerich> koltar: Hm? Doesn't the Unix tool erase subsequent duplicates, too?
08:17:00 <frerich> koltar: I.e. it behaves just like nub.
08:17:07 <frerich> Oh wait, nub doesn't require a sorted range?
08:17:20 * frerich always sorted before passing to nub, heh...
08:17:26 <koltar> frerich: nub removes all duplicates
08:17:27 <typoclass> right, the uniq unix tool only considers the line immediately above. so uniq is different from nub
08:17:28 <hiptobecubic> it's faster if you sort first for some reason
08:18:15 <koltar> hiptobecubic: maybe the comparisons during sorting are memoized?
08:18:28 * koltar knows knothing of GHC's inner workings
08:18:34 <koltar> nothing*
08:18:36 <hiptobecubic> but   nub . sort   is faster than just nub
08:18:46 <merijn> > nub [1,2,3,1,3,2,4,1,2,3,2,2]
08:18:48 <lambdabot>   [1,2,3,4]
08:18:49 <S11001001> @src nub
08:18:49 <lambdabot> nub = nubBy (==)
08:18:49 <hiptobecubic> i think preserving the order costs you time
08:18:53 <S11001001> right.
08:18:55 <merijn> Looks like uniq to me...
08:18:57 <S11001001> @src nubBy
08:18:57 <lambdabot> nubBy eq []             =  []
08:18:57 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
08:19:20 <frerich> merijn: The Unix tool 'uniq' would have given [1,2,3,1,3,2,4,1,2,3,2]
08:19:40 <merijn> Ok, so let's rename it sort-u :p
08:19:42 <typoclass> merijn: no, i'm pretty sure by default uniq looks only at two neighboring lines, not at all the previous lines
08:19:57 <typoclass> (there might be a switch to change that behavior, dunno)
08:20:15 <S11001001> hiptobecubic: doesn't look like you'd gain that much speed
08:20:45 <koltar> uniq is written to work line-by-line, so searching the remaining input for duplicates is out of the question
08:21:16 <nyc> sort -u will do it
08:21:24 <nyc> uniq itself no
08:22:56 <koltar> uniq -u on my box only dropped duplicates of the first line
08:24:07 <koltar> oh, you said sort -u, not uniq -u
08:27:09 <mm_freak> edwardk: i'm missing the 'focus' function from data-lens…  is it there somewhere?
08:28:05 <edwardk> its been so long since i used data-lens that i don't remember what is there ;)
08:28:21 <edwardk> in lens its zoom
08:29:29 <Thomyho> hey@all
08:29:38 <Thomyho> where can i paste a code?
08:29:52 <hiptobecubic> in /topic there is hpaste
08:31:12 <hpaste> Thomyho pasted “solver ^^” at http://hpaste.org/80775
08:31:39 <Thomyho> Parse error in pattern: m+1  85:13
08:32:42 <hpaste> hiptobecubic annotated “solver ^^” with “solver ^^ (annotation) as lhs” at http://hpaste.org/80775#a80776
08:32:59 <hiptobecubic> i guess lhs does nothing really
08:33:09 <hiptobecubic> how disappointing
08:39:23 <beaky> hello
08:43:15 <parcs> > 68 / 103
08:43:16 <lambdabot>   0.6601941747572816
08:44:28 <eacameron> I'm writing a small library but I hate forcing my interfaces to pick between String, Text, and ByteString. How do you write abstract library interfaces that don't force a particular string implementation?
08:47:52 <simpson> eacameron: If it's bytes, ByteString; otherwise if it's Unicode, Text; otherwise, String.
08:48:02 <simpson> eacameron: You just have to care a little more about *what* your data is.
08:48:37 <fmap> eacameron: bytestring isn't a string implementation
08:49:22 <eacameron> fmap: but it gets used as one in many libraries. I can't help that
08:50:08 <eacameron> simpson: care more....i don't like it ;)
08:50:36 <simpson> eacameron: So use String. :3
08:51:44 <eacameron> simpson: yeah I guess that would the way of least caring
09:20:16 <tobias__> Hey mates:), How can i create random Booleans in Haskell?
09:20:26 <Taneb> System.Random
09:20:36 <Taneb> No
09:20:48 <tobias__> no?
09:20:50 <Taneb> Yes
09:21:02 <mm_freak> > randoms (mkStdGen 0) :: [Bool]
09:21:04 <lambdabot>   [True,True,True,False,False,True,True,True,True,False,True,False,False,Fals...
09:21:16 <quicksilver> you could ask here each time and we could generate one for you
09:21:18 <quicksilver> True
09:21:22 <quicksilver> (that's a start)
09:21:24 <tobias__> :D
09:21:29 <tobias__> thank u
09:21:30 <tobias__>  :P
09:22:04 <S11001001> mm_freak: oh dear, now tobias__ is going to do that
09:22:24 <monoidal> note that you should use newStdGen to initialize seed
09:22:40 <mm_freak> S11001001: he didn't ask for cryptographically strong random booleans, nor did he want different booleans for each run =)
09:23:13 <S11001001> > filter (==' ') "well I thought asking IRC would be just as well"
09:23:15 <lambdabot>   "         "
09:23:23 <S11001001> > map (==' ') "well I thought asking IRC would be just as well"
09:23:25 <lambdabot>   [False,False,False,False,True,False,True,False,False,False,False,False,Fals...
09:24:00 <S11001001> just run that over a copy of david copperfield, tobias__
09:24:14 <quicksilver> this is java code, but you could adapt it : http://xkcd.com/221/
09:25:50 <mm_freak> > map (\x -> (2^x `mod` 2147483659) `testBit` 0) [33..]
09:25:51 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
09:26:30 <mm_freak> > map (\x -> (3^x `mod` 2147483659) `testBit` 0) [1000..]
09:26:31 <lambdabot>   [False,False,False,False,True,True,True,True,False,False,False,False,False,...
09:27:16 <mm_freak> > map (`testBit` 0) . iterate (\x -> mod (x^2) 2147483659) $ 2
09:27:18 <lambdabot>   [False,False,False,False,False,True,False,False,True,True,True,False,True,T...
09:28:59 <hpaste> “Ertugrul Söylemez” pasted “aes-cprng benchmark” at http://hpaste.org/80778
09:37:03 <ToBago70>  Ciao a tutti :) un click grazie sul video di Monica Bellucci  http://youtu.be/EZuWHms7N64 
09:37:25 <parcs> que?
09:39:21 --- mode: ChanServ set +o glguy
09:39:38 <eacameron> is there a function like "break" that does NOT include the delimiter? I want to take "a:b" to ("a", "b"), not ("a", ":b")
09:39:39 --- mode: glguy set +b *!xdccMule@*
09:40:33 <glguy> just write: case break f xs of (a,_:b) -> …; _ -> (didn't find delimiter)
09:40:33 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
09:41:39 <monoidal> or second tail . break f
09:43:02 <eacameron> monoidal: yeah, that's pretty clean; thanks. I just thought it was probably out there already
09:44:34 <tobias__> Could not find module `System.Random -----what is that?
09:44:45 <monoidal> eacameron: perhaps the split library http://hackage.haskell.org/packages/archive/split/0.2.1.1/doc/html/Data-List-Split.html might have something interesting for you
09:45:09 <int-e> @hackage random
09:45:09 <lambdabot> http://hackage.haskell.org/package/random
09:45:13 <monoidal> tobias__: try cabal install random
09:49:03 <fragamus> hey fellows I am using Crypto.Hash.SHA1 and I am getting ByteStrings as output and it *appears* that they are allocated outside of Haskell and they are "pinned memory"    I hold on to these ByteStrings and it seems like they come with a TON of baggage. I *think* I need to copy them into Haskell memory. Is there a constructor to copy one of these from outside memory into haskell memory?  My hope is that when I do such,
09:49:03 <fragamus>  GC will clear out the pinned stuff.
09:53:03 <Spockz> Is there a stable/good/standard Raytracer written in Haskell? Or maybe another rendering tool with easy definable scenes?
09:56:05 <tobias__> is this right? getRandomBool = (fst $ random $ mkStdGen 2) :: Bool
09:56:17 <tobias__> for random bool
09:56:21 <monoidal> > (fst $ random $ mkStdGen 2) :: Bool
09:56:22 <lambdabot>   True
09:56:48 <monoidal> tobias__: you need a varying seed
09:57:17 <chreekat> Am I right in my vague recollection that some people have issues with System.Random? [Ha -- I just joined in order to ask that question, and here people are discussing its use...]
09:57:44 <chreekat> "something something not very efficient"? Or am I thinking of some other library
09:57:53 <strebe> sounds right
09:57:55 <kennyd> while we are on the random topic, doesn't it ship with haskell platform?  I don't recall installing it
09:58:00 <kennyd> System.Random
09:58:03 <tobias__> how do i vary it?
09:58:12 <monoidal> tobias__: newStdGen
09:58:43 <tobias__> (fst $ random $ mkStdGen 2000) :: Bool
09:58:48 <geekosaur> System.Random is pretty slow, partly because of "split"
09:59:06 <monoidal> 'split' also gets deterministic very fast when nested
10:00:00 <glguy> kennyd: http://www.haskell.org/platform/changelog.html
10:00:11 <kennyd> thanks glguy
10:00:25 <tobias__> i just need to generate a list with random boolean. What is the best way?
10:01:16 <dmwit> :t randoms
10:01:18 <lambdabot> (RandomGen g, Random a) => g -> [a]
10:01:30 <dmwit> in particular, randoms :: StdGen -> [Bool]
10:01:40 <simpson> tobias__: What are you going to use these random Bools for?
10:02:17 <tobias__> I build a Conways game of Live
10:02:32 <tobias__> just random states
10:02:42 <simpson> Aha. So you probably *do* want the seed to be user-controlled then.
10:02:47 <simpson> Just keep doing what you're doing.
10:06:06 <chreekat> Interesting - I wonder what that means for QuickCheck, which has a split invocation in (>>=) for Gen a.
10:07:21 <monoidal> chreekat: it might cause things like http://hackage.haskell.org/trac/ghc/ticket/3620, fortunately rather rarely
10:14:49 <gonza> "hello world"
11:00:03 * hackagebot wl-pprint-terminfo 3.3.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.3.1 (EdwardKmett)
11:03:05 <mami> yoho
11:03:28 <mami> why does "(filter isLong (map chain [1..10])) where isLong xs = length xs > 15
11:03:31 <mami> " work
11:03:41 <mami> and "(filter (xs = lengtx xs > 15) (map chain [1..10]))
11:03:43 <mami> does not
11:04:05 <Eelis> because the syntax for a lambda expression would be  (\xs -> length xs > 15)
11:04:05 <mami> whats the difference between an "ad hoc" function and a func that i define later with where
11:04:12 <mami> ah okay
11:04:19 <mami> not yet at this chapter ;)
11:04:20 <mami> thx
11:04:32 <Eelis> "isLong xs = bla" is weird shorthand syntax for "isLong = \xs -> bla"
11:04:42 <Eelis> but it only works sometimes
11:05:06 <mami> i see
11:05:37 <monoidal> mami: you can use "x = y" syntax on the "top level" and inside "where", but not inside expressions
11:06:05 <Eelis> except with let
11:06:52 <mami> so i need to use anonymous functions
11:07:43 <monoidal> either use "\xs -> length xs > 15" or add a where clause: "isLong xs = length xs > 15" and then refer to isLong
11:08:28 <S11001001> monoidal: eww
11:09:24 <monoidal> hm?
11:10:00 <shachaf> I think S11001001 is saying that "length xs > 15" is insufficiently lazy.
11:10:06 <shachaf> > length [1..] > 15
11:10:07 <lambdabot>  Terminated
11:10:46 <shachaf> > ((>) `on` void) [1..] (replicate 15 ()) -- this isn't what you should actuallly do.
11:10:48 <lambdabot>   No instance for (GHC.Num.Num ())
11:10:48 <lambdabot>    arising from the literal `1'
11:10:48 <lambdabot>  Possible ...
11:10:50 <monoidal> sure - I was discussing syntax
11:10:59 <shachaf> Hmm.
11:11:11 <S11001001> monoidal: ah
11:11:25 <shachaf> > void [1..] > replicate 15 () -- this isn't what you should actuallly do.
11:11:26 <lambdabot>   True
11:11:28 <monoidal> shachaf: something like not . null . take 15
11:11:34 <monoidal> * drop 15
11:11:36 <shachaf> That works too.
11:12:02 <`nand`> genericLength [1..] > (15 :: LazyNat)
11:12:29 <shachaf> length (take 16 xs) == 16 would work, but would also incur the wrath of S11001001.
11:12:32 <`nand`> arguably identical to shachaf's solution
11:12:48 <shachaf> @arrrr guably
11:12:48 <lambdabot> I'll keel haul ya fer that!
11:12:53 <S11001001> shachaf: yes it would :)
11:13:40 <`nand`> length (drop 16 xs) > 0 -- /me ducks
11:13:54 <S11001001> > take -42 [42]
11:13:56 <lambdabot>   Could not deduce (GHC.Num.Num
11:13:56 <lambdabot>                      ([t0] -> GHC.Types.Int -...
11:14:20 <napping> why ((>0) . length) rather than (not . null)?
11:14:32 <shachaf> @let voided n = replicate n ()
11:14:34 <lambdabot>  Defined.
11:14:39 <`nand`> napping: I am joking, not . null is much better than (>0) . length
11:14:39 <shachaf> > void [1..] > voided 16
11:14:41 <lambdabot>   True
11:14:49 <shachaf> Er, 15.
11:15:01 <`nand`> I thought voided was some lens combinator for a second
11:16:08 <shachaf> > (null &&& void) [1..5]
11:16:09 <lambdabot>   (False,[(),(),(),(),()])
11:16:32 <simpson> I sense a warmup to a pun.
11:18:40 <S11001001> Numbers succ.
11:19:29 <ziman> except zero :)
11:19:31 <mami> ghci> let listOfFuns = map (*) [0..]
11:19:32 <mami> ghci> (listOfFuns !! 4) 5
11:19:36 <mami> 20
11:19:44 <mami> this is one example for currying
11:20:12 <mami> is there some operater kind of like map that does not take functions but simple values and "applies" them?
11:20:32 <`nand`> how do you apply something that isn't a function?
11:20:32 <sclv> how do we apply something that is not a function?
11:20:40 <monoidal> you mean like map ($1) [sin, cos]?
11:20:40 <mami> so i have a list of (*1),(*2),(*3) and i apply "1" to all of them
11:20:47 <`nand`> oh
11:20:48 <mami> yeah thats the question
11:20:50 <`nand`> what monoidal said
11:20:59 <mami> or apply all funcs to the value
11:21:02 <sclv> you're applying them to 1, not applying 1 to them
11:21:10 <mami> yeah thats what i meant
11:21:21 <mami> just mixed it up
11:21:24 <S11001001> @ty Data.Distributive.distribute [sin, cos]
11:21:25 <lambdabot> Floating a => a -> [a]
11:21:26 <mami> "just"
11:21:36 <mami> how would you go about that?
11:21:45 <mami> applying a list of functions to a value
11:21:47 <n-dolio> @type sequence [sin, cos]
11:21:48 <lambdabot> Floating a => a -> [a]
11:21:58 <S11001001> n-dolio: less sharing :P
11:22:04 <`nand`> > [sin,cos] <*> pure 0.3
11:22:05 <lambdabot>   [0.29552020666133955,0.955336489125606]
11:22:25 <Iceland_jack> > [sin, cos] <*> [0.3]
11:22:25 <sclv> > sequence [\x -> x + 1, \x -> x * 2] 4
11:22:26 <lambdabot>   [0.29552020666133955,0.955336489125606]
11:22:27 <lambdabot>   can't find file: L.hs
11:22:28 <`nand`> I like S11001001's though
11:22:38 <sclv> > sequence [\x -> x + 1, \x -> x * 2] 4
11:22:40 <lambdabot>   [5,8]
11:23:45 <Lethalman> :t sequence [\x -> x + 1, \x -> x * 2]
11:23:46 <lambdabot> Num a => a -> [a]
11:24:05 * Lethalman has headache
11:24:27 <sclv> ?ty sequence
11:24:28 <lambdabot> Monad m => [m a] -> m [a]
11:24:37 <sclv> so its just in the unwrapped reader
11:24:40 <`nand`> m = (->) a
11:26:39 <tac> @let sq x = x * x
11:26:41 <lambdabot>  Defined.
11:27:00 <tac> > sum $ [sq, sq] <*> [sin, cos] <*> pure 0.3
11:27:01 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
11:27:01 <lambdabot>    arising from a use of `e_103'
11:27:01 <lambdabot>  ...
11:27:19 <`nand`> we don't have that Num instance anymore
11:27:21 <monoidal> tac: that would be ziplists
11:28:29 <n-dolio> S11001001: Are you sure?
11:28:43 <S11001001> n-dolio: sequence makes ap trees, distribute doesn't
11:29:24 <S11001001> n-dolio: that is, there's just an fmap on the list, not a traverse
11:29:25 <n-dolio> Do you mean, more indirection?
11:29:46 <n-dolio> I can believe more indirection.
11:30:19 <S11001001> n-dolio: you get 1 function instead of n functions.
11:30:23 <tac> > sum $ fmap (sq.) [sin, cos] <*> pure 0.3
11:30:25 <lambdabot>   1.0
11:30:30 <monoidal> > sum $ getZipList $ ZipList [sq,sq] <*> (ZipList [sin,cos] <*> pure 1) -- tac
11:30:31 <lambdabot>   1.0
11:31:56 <`nand`> > sum $ [sq, sq] <*> ([sin, cos] <*> pure 0.3)
11:31:58 <lambdabot>   2.0
11:32:03 <`nand`> > sum $ pure sq <*> ([sin, cos] <*> pure 0.3)
11:32:05 <lambdabot>   1.0
11:32:36 <tac> ah, <*> is not assoc. is it
11:32:47 <tac> @type (<*>)
11:32:48 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:32:53 <tac> (and why would it be)
11:33:24 <monoidal> tac: even when f=id, <*> specializes to ($) which is nonassoc
11:33:31 <n-dolio> There is a sense in which it is associative, but it is not just an associative operator.
11:34:29 * tac goes on living with only a faint idea of what applicative functors are useful for
11:34:31 <monoidal> the operator zip :: (f a, f b) -> f (a,b) is associative in some sense
11:34:31 <`nand`> right, but function application is associative
11:34:51 <monoidal> `nand`: x (y z) /= (x y) z
11:34:52 <tac> function composition, right? Not application.
11:34:53 <`nand`> in that (f.g) $ x = f $ (g $ x)
11:35:06 <`nand`> well
11:35:13 <`nand`> application can only go one way either way
11:50:04 * hackagebot parsers 0.5 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.5 (EdwardKmett)
11:53:03 <quchen> Now that people talk about zip and Applicative again, I can't come up with a way of writing <*> in terms of zip and pure (). Does anyone have the solution handy? I'm at the "brute force every combination until it typechecks" phase and I doubt it's teaching me much.
11:53:35 <quchen> Nereid: if you're here, then yes, I'm totally cheating my way through this. :P
11:53:55 <sipa> :t (<*>)
11:53:57 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:54:10 <sipa> :t zip
11:54:11 <lambdabot> [a] -> [b] -> [(a, b)]
11:54:53 <quchen> sipa: I meant the zip operator monoidal mentioned above, i.e. f a -> f b -> f (a, b)
11:55:07 <quchen> Or the uncurried version of it, (f a, f b) -> f (a, b)
11:55:28 <quchen> For f = List that specializes to Prelude.zip
12:00:19 <byorgey> quchen: f <*> x = fmap (uncurry ($)) (zip f x)
12:06:01 <simpson> Peaker: Howdy. I can't get FTGL to do things. Is your FreeTypeGL stable and usable?
12:09:30 <neutrino_> i just realized, "glorious glasgow haskell compiler" is fairly difficult to pronounce
12:10:06 * hackagebot HarmTrace-Base 1.0.0.0 - Parsing and unambiguously representing musical chords.  http://hackage.haskell.org/package/HarmTrace-Base-1.0.0.0 (BasDeHaas)
12:10:55 <chreekat> I decided to practice some proofs, and worked my way through the left identity law for a particular monad. I made a few intuitive guesses, and I was wondering if someone could double-check that intuition.
12:11:00 <hpaste> chreekat pasted “Monad laws for Test.QuickCheck.Gen” at http://hpaste.org/80784
12:11:56 <quchen> byorgey: Now that I see it it makes so much sense.
12:16:10 <byorgey> quchen: great =)
12:16:58 <byorgey> chreekat: "Assume the law holds. Let's try to prove it."  makes no sense.
12:17:05 <byorgey> You don't assume things you are trying to prove.
12:17:28 <chreekat> Well it does end up being a proof by contradiction, so "it" is that the law *doesn't* hold
12:17:39 <byorgey> OHHH
12:17:43 <byorgey> sorry =)
12:17:53 <chreekat> I know it's unclear :) I started out not actually knowing whether or not the law held
12:18:40 <byorgey> chreekat: the line labeled "eta reduce" is actually beta reduction
12:19:03 <chreekat> K, i did use that term blindly and wasn't 100%
12:19:16 <oio> :q
12:19:28 * chreekat goes to look them up
12:21:53 <fragamus> hey fellows I am using Crypto.Hash.SHA1 and I am getting ByteStrings as output and it *appears* that they are allocated outside of Haskell and they are "pinned memory"    I hold on to these ByteStrings and it seems like they come with a TON of baggage. I *think* I need to copy them into Haskell memory. Is there a constructor to copy one of these from outside memory into haskell memory?  My hope is that when I do such,
12:21:53 <fragamus>  GC will clear out the pinned stuff.
12:21:54 <ijp> chreekat: eta reduction is (\a -> f a) => f (assuming a is not free in f)
12:22:13 <byorgey> chreekat: to answer your questions at the bottom, (1) replacing k a  with MkGen m'  is a bit dodgy because m' is not in scope on the right hand side
12:23:28 <byorgey> but it actually ends up being OK since k and a scope over the whole equation, you could just declare that  k a = MkGen m'
12:23:46 <byorgey> i.e. it's OK to "lift" the scope of m'  outside the let
12:24:22 <fragamus> by baggage I mean that theres a whole shitload of extra memory allocated along with them, as if it allocates a big chunk and pins it and then gives a pointer to a byte string within the big chunk to the little piece that I want
12:24:34 <byorgey> (2) if  f x = f y, can you conclude  x = y?  the answer is yes, IF f is injective
12:24:52 <byorgey> and data constructors are always injective
12:25:07 * hackagebot parsec-parsers 0.1 - Parsing instances for Parsec  http://hackage.haskell.org/package/parsec-parsers-0.1 (EdwardKmett)
12:25:38 <byorgey> so the answer is yes -- in fact you don't even need unGen at all.  Just having  MkGen foo == MkGen bar  implies foo == bar
12:25:48 <chreekat> cool
12:26:06 <byorgey> and if you have an equation you can always apply the same function to both sides
12:26:12 <byorgey> so that's another reason =)
12:26:50 <chreekat> so for (1), you're saying that if you're careful, you could move the "let Mkgen m' = k a" up and out of the foo == bar that is/was the top level equation
12:27:01 <byorgey> right
12:27:05 <chreekat> gotcha
12:27:32 <byorgey> chreekat: re (3), no, it is not sufficient!  r /= r2 does not, in general, imply  m' r2 n /= m' r n
12:27:56 <byorgey> for example  (-1) /= 1  but  f (-1) == f 1   if, say,  f x = x^2
12:28:12 <chreekat> doh, of course
12:28:14 <byorgey> in order to conclude that you would need to know something more specific about m'
12:29:11 <byorgey> however, notice the law is supposed to hold for ALL m and ALL k
12:29:20 <clahey> So you just have to supply an m and a k.
12:29:23 <byorgey> so you can choose specific examples which break the property
12:29:40 <chreekat> aha
12:29:54 <byorgey> you can't say that the law does not hold *in general* (it might hold sometimes) but you can give a specific counterexample.
12:30:04 <clahey> For example, k could be \_ -> (MkGen \r n -> r)
12:30:09 <clahey> For example, k could be \_ -> (MkGen \r _ -> r)
12:30:19 <clahey> I think that might need more parentheses.
12:33:15 <clahey> You still need to prove that r /= r2.  I don't know how StdGen's split function is written.
12:33:18 <quchen> Is (*>) = (>>) for monads?
12:33:37 <Taneb> Yes
12:33:48 <quchen> Thanks
12:34:22 <byorgey> I can't imagine an implementation of split where r == r2.
12:34:47 <byorgey> at least it's interesting to be able to say "the monad laws only hold if split guarantees r == r2".
12:36:21 <clahey> byorgey: Definitely.
12:36:51 <clahey> On the other hand, the monad laws hold in some sort of statistic way, though I don't know how to define it.
12:37:04 <n-dolio> Data constructors are injective _until_ you add existential types (and other stuff).
12:38:00 <clahey> If the statistic distribution of r and snd (split r) are the same, then the statistic distribution of (k a r) and ((return a >> k) r) are the same.
12:38:15 <clahey> Does that sound like a reasonable thing to want to prove?
12:38:23 <Eduard_Munteanu> Or explicit type functions, i guess.
12:38:34 <chreekat> clahey: that's a fun question
12:38:36 <Eduard_Munteanu> E.g. F = const Bool
12:38:47 <parcs> :)
12:39:08 <Eduard_Munteanu> Wait, constructors.
12:39:24 <clahey> chreekat: I think we should use quickcheck to see whether it's true or not.
12:39:32 <chreekat> heh
12:41:31 <chreekat> n-dolio: Just so I understand, that would only matter if the datatype in question (Gen, here) was defined, uh, "existentially".
12:41:56 <clahey> Does it hold that if r and r' are statistically the same then k r and k r' are statistically the same for all k?
12:42:24 <n-dolio> chreekat: Right. It doesn't cause it to fail for data types that have no existential quantification.
12:43:12 <clahey> Is there a shorter name for flip const?
12:43:28 <shachaf> "const id" is shorter.
12:46:41 <clahey> shachaf: I like it.
12:46:50 <clahey> So, const (const id)
12:46:53 <clahey> That's your k.
12:47:08 <clahey> But I'm totally wrong.
12:47:24 <clahey> It's just const (MkGen const)
12:50:27 <clahey> Has anyone done papers about what it would mean to be statistically the same?
12:50:51 <quchen> clahey: seq is shorter and typechecks! ;-)
12:50:57 <clahey> For finite types, I can see how you would define it, but for infinite types, I'm not quite so sure.
12:51:00 <clahey> :t seq
12:51:01 <lambdabot> a -> b -> b
12:51:15 <clahey> @src seq
12:51:15 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:51:33 <quchen> clahey: seq is magical, it's more than just const id
12:51:36 <clahey> quchen: Turns out I wanted const itself anyway.
12:51:47 <clahey> quchen: Oh, that.  Yeah, I don't want that.
12:56:28 <chreekat> byorgey: I think you meant it's supposed to hold for all k and all a. Since we're talking about `return a >>= k` after all. Right?
12:57:10 <clahey> chreekat: Pretty sure that's what he meant.
12:57:22 <clahey> chreekat: Is this for homework or for research or for fun?
12:57:25 <byorgey> yes, sorry
12:57:34 <chreekat> fun
12:57:42 <clahey> Do you like my k?
12:58:51 <chreekat> was just getting there. :)  Which one do you mean? const (MkGen const) ?
12:58:56 <clahey> I think that's the one.
12:59:28 <clahey> Rather, that's the one I meant, I think it types out correctly.
12:59:37 <clahey> type checks correctly.
13:00:11 <clahey> I really am curious about proving that statistically, it's the same.
13:01:30 <clahey> Assuming that r is statistically nice in some describable way.
13:04:57 <chreekat> I do like it
13:05:17 <chreekat> took me longer than necessary to realize it's teh same as my "let k a = MkGen(\r _ -> r)"
13:06:03 <clahey> Yours has more human content though.
13:06:11 <skeet70> I'm in a group that will be using Haskell to write a compiler for Pascal. I have never used/learned Haskell (just Java, Python, C, etc), what resource would you suggest for learning the basics?
13:06:13 <clahey> So, I searched for statistical analysis of haskell.
13:06:19 <clahey> lyah!
13:06:22 <clahey> @lyah
13:06:22 <lambdabot> Unknown command, try @list
13:06:22 <johnw> @where lyah
13:06:23 <lambdabot> http://www.learnyouahaskell.com/
13:06:39 <johnw> it's a fun book
13:06:51 <clahey> So, I searched for statistical analysis of haskell, and it came up with a bunch of statistics libraries to use in haskell.
13:06:58 <clahey> Not papers analyzing haskell itself.
13:07:05 <Lethalman> @hoogle !!
13:07:05 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:07:05 <lambdabot> Data.List (!!) :: [a] -> Int -> a
13:07:05 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
13:07:23 <Lethalman> isn't there an "Indexable" class for which !! is defined?
13:07:27 <Lethalman> like Foldable etc.
13:08:04 <skeet70> johnw alright, I'll take a look through that then. Thanks!
13:08:19 <clahey> Oh, and now I found a statistical analysis of people using haskell.
13:08:29 <edwardk> Lethalman: you can get there with lens ;)
13:08:53 <johnw> edwardk: that would be a great bumper sticker
13:09:07 <edwardk> under lens head you can use ^.ix   as a form of !!
13:09:20 <shachaf> edwardk: Well, indexing will be linear even for arrays/sequences, so it's not really optimal.
13:09:20 <Lethalman> edwardk, mh in the sense that I wanted to implement such class for some collections in the FFI
13:09:23 <edwardk> it might be worth adding (!!) as an alias for it
13:09:33 <shachaf> Oh, you meanix.
13:09:37 <edwardk> shachaf: well, element based indexing will be, but ix based indexing is optimal
13:09:45 <shachaf> I thought you were thinking of element. True.
13:10:12 <edwardk> i wonder if we should add (!!) as an alias for ^.ix
13:10:18 <Lethalman> but maybe there I need an IO
13:10:54 <edwardk> :t (!!)
13:10:55 <lambdabot> [a] -> Int -> a
13:11:03 <edwardk> we also subsume Data.Array.(!) with it
13:11:05 <edwardk> :t (!)
13:11:06 <lambdabot> Ix i => Array i e -> i -> e
13:11:31 <chreekat> I thought I recall seeing a genericAt somewhere
13:11:32 <shachaf> (!) is a better name than (!!), since multiple modules take it and it's not in the Prelude.
13:11:39 <Taneb> I'd rather you take (!) than (!!), yeah
13:11:43 <shachaf> But I don't like the idea of conflicting with things so much.
13:11:56 <monochrom> time to go !!! :)
13:12:22 <monochrom> or perhaps ^.! ?
13:14:38 <edwardk> i'm not a huge fan of conflicting, even when we subsume, but we already do so for uncons ;)
13:15:03 <shachaf> @hoogle uncons
13:15:03 <lambdabot> Data.ByteString.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
13:15:03 <lambdabot> Data.ByteString.Lazy.Char8 uncons :: ByteString -> Maybe (Char, ByteString)
13:15:03 <lambdabot> Data.ByteString uncons :: ByteString -> Maybe (Word8, ByteString)
13:15:14 <shachaf> No one imports ByteString unqualified, though.
13:15:16 <fmap> take both
13:15:24 <edwardk> uncons  :: Cons (->) (Accessor (Leftmost (a, s))) s s a a =>     s -> Maybe (a, s)
13:15:24 <Taneb> (!!!!!)
13:15:26 <edwardk> is clearly superior
13:15:46 <shachaf> By the way, we should revisit Leftmost.
13:16:07 <shachaf> Sometime when I'm feeling less sick of it, but before the release.
13:16:17 <edwardk> sure
13:16:22 <edwardk> its on my release checklist
13:17:48 <clahey> edwardk: Is anyone talking next Wednesday?
13:18:16 <clahey> edwardk: I could give a lightening talk about my stalled microxml parser work.
13:18:18 <edwardk> clahey: not formally, maybe a bunch of short talks if folks want to give something
13:18:24 <edwardk> sounds good
13:20:23 <clahey> edwardk: Do you know of anyone who has done statistical or probabilistic analyses of haskell like I was discussing?
13:21:42 <clahey> Defining what it means to have expressions of random variables in haskell expressions and proving things about the results?
13:24:07 <clahey> Like if r and r' are equal random variables then k r and k r' are equal random variables for all k?
13:27:08 <edwardk> clahey: not off hand
13:27:19 <carter> clahey theres been a bunch of work on probability DSLs, but not on that sort of reasoning
13:27:27 <chreekat> Now I'm curious what things might happen  -- or go wrong -- if left identity doesn't hold for Monad Gen.
13:27:37 <edwardk> i've done some work on probabilistic dsls but no proof of equalities
13:27:50 <edwardk> those strike me as generally intractable in the halting problem sense
13:28:50 <carter> yeah, its easy to know when things are definitionally the same.... proving they'r the same in some sense later is a bit harder / the real of genreal theorem proving
13:29:00 <carter> *realm
13:29:20 <carter> its probably worth playing with some toy model of that problem in agda/idris/coq
13:29:23 <carter> but it'd be HARD
13:29:24 <carter> :)
13:29:27 <carter> possibly fun though
13:33:44 <tac-tics> When aren't dependent types fun?
13:33:55 <chreekat> Could possibly be interesting just to show experimental evidence either way, no?
13:35:14 * hackagebot smtp-mail 0.1.4.2 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.4.2 (JasonHickner)
13:37:29 <johnsipl> If I have some function in the Maybe monad, and then I decide that I also want to consume random numbers through the Rand monad, what do I do?
13:37:56 <johnw> can you show some code of what isn't working for you?
13:38:00 <clahey> I think I basically want to define what it means for two random distributions of values to be equal.
13:38:36 <clahey> And then have expressions of the form a ==== b then c ==== d.
13:38:44 <clahey> if a ==== b then c ==== d
13:41:30 <clahey> I need a symbol for has the same distribution as.
13:42:25 <johnsipl> clahey: do you really need a symbol? if there isn't one in maths, it might be better to just use an english name
13:43:15 <mvj4_> clahey: are you familiar with the SBV module? It provides an easy-to-use DSL for interfacing with an underlying SMT-solver (fancy version of SAT). for example it supports defining unknown types and applying theorems, which might be useful for you.
13:43:16 <clahey> johnsipl: So, I just found X ~ D means that X has the probability distribution D.
13:43:47 <clahey> johnsipl: I think they might just use =.
13:44:08 <clahey> johnsipl: And use capital letters.
13:44:17 <clahey> johnsipl: But capital letters are already taken in haskell.
13:47:08 <bgamari_> clahey, ~ is a pretty common symbol for "drawn from"
13:47:25 <clahey> bgamari_: Makes sense.
13:47:37 <clahey> I was thinking maybe =~= to say that they're drawn from the same distribution.
13:51:47 <SamanthaD> 'allo!
13:59:01 <jaimef> building pandoc and runghc Setup.hs configure is unable to find many packages already installed via cabal
14:02:23 <centrinia_> Are there any recommended raster image libraries for Haskell?
14:03:56 <hpc> there's libraries that read images into pixel arrays and write back again
14:04:03 <hpc> can't recall the name of any
14:04:21 <hpc> not sure if there's anything to manipulate the arrays once read in
14:04:36 <centrinia_>  :(
14:04:56 <tunker32> I'm aware that IO to a console is often buffered until EOL, but surely the buffer is flushed at normal exit? http://hpaste.org/80788 this program prints nothing unless you put \n at the end of the string. That can't be right can it?
14:05:10 <centrinia_> What if I wanted to construct the image from scratch?
14:05:33 <hpc> you'd probably go with cairo outputted to png
14:05:44 <hpc> or diagrams
14:05:47 <blackh> centrinia_: I had success with cairo
14:06:03 <hpc> frustratingly, i am working on exactly what you want at work
14:06:09 <hpc> and it's just not to the point of publishing yet
14:06:29 <tunker32> centrinia_: JuicyPixels is good, but the API makes it hard to parallelise
14:07:28 <blackh> centrinia_: I have some code here that renders text to png files using cairo. Do you want it?
14:07:31 <centrinia_> Nice, thanks tunker32.
14:07:42 <centrinia_> blackdog, no thanks.
14:08:05 <blackdog> centrinia_: blackh, you mean? :)
14:08:10 * blackdog waves at blackh
14:08:17 <centrinia_> blackdog, yeah. :p
14:08:45 <parcs> where is inlinePerformIO?
14:08:56 <blackh> Hi blackdog!!
14:09:02 <centrinia_> I am actually extracting raw texture data from Quake maps and dumping them into PNGs and JSON files for use in a Javascript web page. :p
14:09:36 <hpc> fun!
14:10:07 <centrinia_> Here is the untextured result: http://centrinia.github.com/quake/quake.html :p
14:15:20 <clahey> Unable to use webgl.
14:15:35 <centrinia_> Yeah, that happens. :(
14:16:31 <quchen> Is the networking section of RWH still relevant? Has the API changed significantly, is another package more common now?
14:16:50 <johnw> RWH uses plain sockets, yeah?
14:17:11 <parcs> centrinia_: i think JuicyPixels can do that
14:17:22 <quchen> johnw: Yes
14:17:27 <centrinia_> I just compiled it.
14:17:32 <johnw> then it should still be relevant, although I prefer using network-conduit
14:17:34 <hpc> quchen: System.Network has dead-simple documentation
14:17:44 <hpc> if that's all you are looking for
14:18:05 <quchen> hpc: Sounds like a wrapper around sockets
14:18:19 <quchen> johnw: Any specific advantages of that over System.Network?
14:18:19 <monochrom> System.Network? Network?
14:18:32 <hpc> er
14:18:34 <hpc> System.IO
14:18:34 <monochrom> @hoogle System.Network
14:18:34 <lambdabot> package network
14:18:34 <lambdabot> package network-address
14:18:34 <lambdabot> package network-bytestring
14:19:21 <johnw> quchen: only if you open lots and lots of sockets in sub-threads, in which case it minimizes resource consumption for closed sockets
14:19:51 <johnw> "deterministic resource finalization"
14:20:01 <johnw> but if you are just writing simple code, I'd go with System.Network
14:21:05 <quchen> Alright, thanks guys!
14:21:07 <monochrom> typos are infectious
14:21:27 <fetter_oml> http://img.pr0gramm.com/2013/01/w1vhp.jpg
14:22:59 * geekosaur misreads "types are infectious"
14:23:13 <blackdog> geekosaur: me too! ;)
14:23:26 <blackdog> hm. that was a bit flirtier than i intended
14:23:42 <johnw> lol
14:24:04 <tunker32_> Anyone who's recently come on know about IO buffering behaviour? I can't work out why this program generates no output at all unless you add a \n http://hpaste.org/80788
14:24:31 <geekosaur> platform?
14:24:34 <blackdog> tunker32_: you're probably in line buffering mode.
14:24:47 <ziman> you can hSetBuffering NoBuffering on stdout
14:24:49 <tunker32_> blackdog: but surely buffers are flushed on a clean exit?
14:24:51 <geekosaur> on unix, output to a tty is defautl line-buffered so you won't see anything without either a flush or a newline
14:24:56 <blackh> tunker32_: I believe there is buffering at the Haskell level. ^ What ziman said.
14:25:15 <ziman> but exiting without flushing buffers is definitely weird.
14:25:19 <geekosaur> hm, I don't know if a clean exit flushes haskell's buffrrs thoigh; haskell does not use stdio, it merely emulates some of the behavior
14:25:32 <blackdog> tunker32_: hm, what platform? it works for me.
14:25:35 <tunker32_> whatever it does, that can't be correct hb
14:25:47 <tunker32_> Mac, clean install of haskell platform
14:25:50 <blackdog> tunker32_: it prints "test" on ubuntu, ghc 7.4
14:26:20 <tunker32_> ghc 7.4.2, via homebrew, using runhaskell
14:26:45 <geekosaur> works here fwiw
14:26:53 <tunker32_> This is a clean install of the OS as well, as of last week, and I've not tinkered with any terminal or environment variables or anything like that
14:26:59 <geekosaur> ...what shell?  some of them put a \r before the prompt which will overwrite the output
14:27:03 <blackdog> tunker32_: 7.2.1 on mac works too.
14:27:09 <ziman> ghc-7.0.4, prints "test" both when compiled and from runhaskell
14:27:26 <tunker32_> bash, what can i try to disable that - run in csh?
14:27:55 <tunker32_> aaaah i know what it is... i've set my prompt to always start at the left of the line, so it overwrites it, silly me!
14:27:56 <geekosaur> when running it, append "; echo" in the shell to force a newline from outside the program
14:31:12 <ziman> hm, yeah, does your prompt happen to overwrite whatever is left un-newlined?
14:31:26 <blackdog> i think we can consider this one solved.
14:31:27 <ziman> try printf "looooooooooooooooooooooooooooooooooooooong string"
14:32:19 <ziman> ah, i see
14:37:57 <earthy> hm. maybe I should update my ghc
14:38:04 <earthy> The Glorious Glasgow Haskell Compilation System, version 6.12.3
14:42:56 <hpaste> ulidtko pasted “yet another lists with compile-time length” at http://hpaste.org/80789
14:43:20 <ulidtko> hey guys
14:43:44 <ulidtko> i'm scratching my head with this:     Could not deduce (l2 ~ Sum 'Z l2)    from the context (l1 ~ 'Z)
14:44:21 <glguy> ulidtko: You've implemented Sum by pattern matching on the second argument
14:44:33 <glguy> l2 is a variable, so it can't be reduced any further
14:44:50 <ulidtko> should i add reduction over first argument too?
14:45:19 <ulidtko> well, let me just try
14:45:20 <glguy> You should put the reduction on which ever argument you want to be able to write recursive definitions with
14:45:30 <ulidtko> uh-huh, got it
14:45:37 <glguy> This sort of thing doesn't scale up very well
14:46:00 <glguy> In a language like Agda you could *prove* that Sum 'Z l2 ~ l2 and use that to do the coersion
14:48:07 <ulidtko> ah well, now i'm getting conflicting type family instances
14:48:11 <ulidtko> humm...
14:48:22 <glguy> Yeah, you can't just add more overlapping cases
14:48:37 <hpaste> ulidtko annotated “yet another lists with compile-time length” with “yet another lists with compile-time length (annotation)” at http://hpaste.org/80789#a80790
14:48:39 <glguy> if you want to do recursion in the first argument you need to do the pattern matching in the first argument
14:48:56 <ulidtko> owh
14:49:22 <ulidtko> so i have to choose, say, the first argument, and recurse by it everywhere?
14:49:30 <ulidtko> and nowhere by the second
14:50:10 <napping> that's the main completely compile-time way
14:51:25 <napping> you can also inspect GADTs
14:51:37 <napping> (or open existentials with ~ constraints)
14:51:50 <napping> but those proofs must then be forced at runtime
14:52:54 <napping> Might be worth throwing in some !s and checking the core to see if you can get it to optimize away
14:58:42 <parcs> what is atomicWriteIORef for?
14:58:59 <monochrom> where does it exist?
14:59:03 <parcs> Data.IORef
14:59:16 <parcs> "Variant of writeIORef with the "barrier to reordering" property that atomicModifyIORef has."
15:00:07 <parcs> oh, it's explained in the later section what "barrier to reordering" means
15:00:24 <parcs> "In a concurrent program, IORef operations may appear out-of-order to another thread, depending on the memory model of the underlying processor architecture. For example, on x86, loads can move ahead of stores, so in the following example"
15:03:53 <parcs> that sounds horrible
15:04:57 <glguy> parcs: This is how normal variables work in C, also
15:05:05 --- mode: glguy set -o glguy
15:07:15 <McManiaC> is it somehow possible to get haddock documentation for packages which depend on (C) libraries which arent installed on the hackage server?
15:08:32 <monochrom> yes, use --enable-documentation when you "cabal install"
15:09:19 <glguy> once you set "documentation: True" in your ~/.cabal/config you don't have to worry about forgetting that flag
15:09:21 <McManiaC> monochrom: uhm sorry, I meant on the hackage
15:09:23 <McManiaC> monochrom: uhm sorry, I meant on the hackage server
15:09:24 <monochrom> then enjoy $HOME/.cabal/share/doc/index.html !
15:09:40 <monochrom> then no
15:09:47 <McManiaC> monochrom: http://hackage.haskell.org/package/igraph for example fails because it's missing igraph-library
15:10:49 <edwardk> parcs: every other language on the planet has to deal with it too ;)
15:12:06 <edwardk> at least x86 provides write ordering guarantees out of the box, the old itanium architecture used to give you basically no guarantees
15:12:13 <monochrom> I don't think I have written any program that would rely on "must write v1 then read v2"
15:12:48 <edwardk> i have written some pretty hairy code that relied on happens-before semantics and fencing before
15:13:55 <Ralith> it's the sort of thing you do when you're implementing concurrency primitives that you're really not supposed to (re)implement yourself
15:14:45 <edwardk> well, memory fences are scary expensive
15:15:15 <edwardk> so putting in more than you strictly need to is a gateway to really really ridiculously badly performing parallel code
15:16:44 <napping> it's just full barriers?
15:18:45 <parcs> shouldn't the cpu detect when reordering instructions can cause differences in the behavior of a program?
15:21:05 <monochrom> that is helluva expensive. may as well slap a theorem prover on the cpu?
15:21:07 <mreh> I want to hear PCM with haskell, what do you suggest?
15:21:13 <edwardk> parcs: within a core, they do, across cores the world has moved to much much weaker consistency guarantees than that
15:21:25 <mreh> the pcm library lacks documentation
15:21:47 <parcs> i see
15:22:16 <edwardk> last time i measured it it it cost me something like 2000 cycles to perform any fencing operation and a 1000 or so to do a compare and swap
15:22:43 <edwardk> if you had to pay that for every operation, you'd be giving up 3+ orders of magnitude worth of performance
15:22:59 <edwardk> not to mention all the invalidated/unmaintainable caches
15:24:21 <edwardk> there was talk that they went out of their way to make it about 10x cheaper to fence/cas a while back in some intel chips, but i didn't have one when it happened and moved on to other things since then
15:24:25 <edwardk> so i don't have hard numbers
15:34:00 <parcs> looks like atomicModifyIORef' is ~7 times slower than modifyIORef'. same with atomicWriteIORef and writeIORef
15:34:33 <hpc> sounds about right
15:34:42 <parcs> and modifyMVar 30% slower than atomicModifyIORef
15:35:52 <parcs> though these numbers are all in the nanosecond range..
15:36:54 <parcs> er, microsecond :)
15:39:02 <parcs> > 0.090 / 1000000
15:39:03 <lambdabot>   9.0e-8
15:39:39 <path[l]> ocesses
15:39:48 <path[l]> sorry
15:44:21 <cardamon> Hey.  I'm having trouble with cabal and an unhelpful error message.  Am I in the right place? http://paste.debian.net/225091/
15:44:52 <shachaf> cardamon: You probably shouldn't be using "sudo cabal --global". You can just install things locally to your $HOME.
15:45:10 <shachaf> Anyway, it looks like it needs some libraries.
15:45:30 <shachaf> Probably in Debian it would be packages with names like libxinerama-dev and what not. I don't know.
15:45:35 <shachaf> Probably #xmonad would know more. :-)
15:45:47 <tim_heap> try `apt-get install libxrandr-dev` ?
15:46:10 <tim_heap> It seems you're missing a file from libXrandr, so installing the dev package for that will likely help
15:46:40 <cardamon> shachaf: I specifically wanted to send it to /usr/local.  I don't like having programs in $HOME
15:46:55 <shachaf> You'll be sorry! Eventually.
15:46:59 <shachaf> Or maybe not.
15:47:02 <hpc> isn't xmonad a library?
15:47:05 <shachaf> I used to do it, and I was sorry. But that's just me.
15:47:14 <hpc> your "config" compiles to the actual binary
15:47:20 <cardamon> tim_heap: Yeah, I checked and saw the non-dev package there, so I wasn't sure what it was looking for.  I'll try that.  Thanks.
15:47:25 <shachaf> The real xmonad binary goes in ~/.xmonad no matter what, yes. :-)
15:47:44 <shachaf> But a fake binary goes in /usr/local/bin or ~/.cabal/bin or something.
15:47:55 <tim_heap> cardamon: non-dev packages are just the compiled libraries. If you want to link/compile against them, you need the -dev version of the package as well
15:48:06 <hpc> i would probably be doing cabal-dev then :P
15:48:14 <cardamon> thanks.
15:49:52 <shachaf> So I can write a function :: w (a -> b) -> w a -> w b using just Comonad.
15:49:57 <shachaf> In fact I can write two different such functions.
15:50:03 <edwardk> sure
15:50:09 <shachaf> I suppose neither of them respects some reasonable law?
15:50:16 <edwardk> this is why ComonadApply has the _symmetric_ constraint
15:50:20 <shachaf> Since they just reuse the context from the first or second argument, or something.
15:50:46 <cardamon> Would optimization be worth the added compile time?
15:50:50 <shachaf> Why does Monad not need that?
15:50:51 <edwardk> strong lax _symmetric_ semimonoidal comonad.  the rest comes from Comonad. ;)
15:50:58 <shachaf> cardamon: What optimization?
15:51:25 <shachaf> edwardk: But "ap" from Monad gets the symmetry bit for free?
15:51:27 <edwardk> because the fact that you can write this for comonad is an accident of the way things distribute
15:51:33 <cardamon> I noticed cabal has a option for setting an optimization flag. 0 is no, 1 is some and default, 2 is a lot.
15:51:43 <edwardk> if every functor weren't strong then you couldn't write the two you can
15:51:51 <cardamon> But since I don't know how the compiler works, its a mystery to me.
15:52:00 <edwardk> they both rely on the strength of every functor, and hence every comonad
15:52:17 <edwardk> any relationship of those two to ap is entirely coincidental
15:52:18 <Nereid> cardamon: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-optimise.html#optimise-pkgs
15:52:25 <shachaf> cardamon: Optimization is typically not a big increase in compilation time, and makes a big difference in runtime.
15:52:28 <edwardk> it becomes clearer when you work with an indexed comonad
15:52:33 <cardamon> haskell and functional programming in general is a strange and timorous beastie to me.
15:52:36 <shachaf> cardamon: But on the other hand I typically just use the defaults with Cabal.
15:52:44 <shachaf> I've never changed the optimization settings there.
15:53:03 <edwardk> and compare the operation of ComonadApply on the indexed comonad to IndexedApplicative on an IndexedMonad, the latter uses the indices, the former cannot
15:53:18 <edwardk> they are different operations that happen to coalesce to the same signature
15:53:30 <edwardk> in the unindexed case at least
15:54:43 <shachaf> Comonad is a bit weird compared to Monad because you give (=>>) a "w a" and it also gives you a "w a", so you have two values of the same type in scope that you have to be careful not to confuse.
15:54:56 <shachaf> It looks like IndexedComonad doesn't have that issue, though.
15:55:04 <edwardk> yep
15:55:22 * hackagebot igraph 0.1.1 - Bindings to the igraph C library.  http://hackage.haskell.org/package/igraph-0.1.1 (NilsSchweinsberg)
15:55:30 <shachaf> I guess in Monad you have the opposite thing, where you return an "m a" which is different from the one (>>=) returns.
15:55:41 <shachaf> But with return values it's not as easy to get confused.
15:56:53 <edwardk> jjthe two in scope is a function of strength though
16:01:56 <cardamon> http://hackage.haskell.org/trac/hackage/ticket/331 I just came across this one. At least the ticket helped me figure out what was wrong.
16:03:13 <cardamon> Less of a learning curve and more of a solid cliff.
16:07:08 <fmcauley> hello
16:07:18 <Eduard_Munteanu> fmcauley: hi
16:21:08 <gwern> @quote
16:21:08 <lambdabot> mathewm says: I am playing with (.)
16:21:42 <shachaf> I move to @forget
16:23:08 <gwern> shachaf: you have something against amazons?
16:28:02 <duncankl> I know about minimumBy, that allows one to specify a comparison function. Is there something like minimumUsing, that uses the default comparison function, but applies a function to the values before it compares? I have a list of tuples (a, b), and I'd like to compare only on a, so I'd like to do minimumUsing fst
16:28:20 <shachaf> duncankl: minimumBy (compare `on` foo)
16:28:37 <shachaf> Or minimumBy (comparing foo), where comparing is just an alias for (compare `on`)
16:28:37 <duncankl> shachaf: that looks great
16:28:50 <shachaf> They are in Data.Function and, uh, Data.Ord, I think? Respectively.
16:31:38 <snobbishness> I'm trying to get haxml to get haskell-xmpp running but darcs is complaining about an old repository format :( any tips?
16:32:15 <snobbishness> specifically: darcs get http://code.haskell.org/HaXml => Sorry for the wait! The repository you are fetching is using the DEPRECATED 'old-fashioned' format
16:37:38 <Nereid> snobbishness: it's not an error, it's just telling you it'll take a while because of the old format.
16:40:25 <snobbishness> nereid: thanks but I got a directory with just _darcs in it... anyway I've just invoked "cabal" it seems to be doing its thing
16:40:34 <snobbishness> (instead of fetching the source by hand I mean)
16:45:02 <k00mi>  /quit
17:28:35 <ion> > permutations "motherinlaw" !! 36398980
17:28:38 <lambdabot>   mueval-core: Time limit exceeded
17:29:18 <Nereid> :t select
17:29:19 <lambdabot>     Not in scope: `select'
17:29:19 <lambdabot>     Perhaps you meant `reflect' (imported from Control.Monad.Logic)
17:37:25 <parcs> > take 10 $ map (take 5) (permutations "abcdefghijk")
17:37:26 <lambdabot>   ["abcde","bacde","cbade","bcade","cabde","acbde","dcbae","cdbae","cbdae","d...
17:37:35 <parcs> > take 10 (permutations "abcde")
17:37:36 <lambdabot>   ["abcde","bacde","cbade","bcade","cabde","acbde","dcbae","cdbae","cbdae","d...
17:42:27 <terry1234> If I'm using a pure data structure, such as Data.Set, is there a generic way to turn that into a monad? So I don't have to chain my calls to the functions of Data.Set together, and I so that I can use do notation instead?
17:43:13 <shachaf> No, Data.Set can't be made into an (ordinary) Monad instance.
17:43:21 <Ralith> terry1234: you are probably thinking of state
17:43:22 <shachaf> What are you hoping to accomplish, though?
17:43:46 <shachaf> Even if you could make it into a monad instance, it wouldn't really be about "chaining you calls to the functions of Data.Set together".
17:43:58 <Ralith> shachaf: he is probably thinking of state
17:44:14 <shachaf> Ralith: Could be thinking of lots of different things.
17:44:18 <Ralith> could be
17:44:20 <terry1234> I have a lot of calls like Set.insert foo $ Set.delete bar $ Set.whatever etc, which becomes a mess, especially with intermediate pure values in lets, i thought i could make that into a monad. i know about that state monad, but that just allows me to get and set a value doesn' tit?
17:44:21 <Ralith> but probably isn't
17:44:22 <shachaf> I'm trying to rid myself of the habit of mind-reading.
17:44:32 <shachaf> It's rude and it trains people to ask bad questions.
17:44:54 <Ralith> not mind-reading can have exactly the same problems!
17:44:57 <Ralith> it is a fine line.
17:44:57 <shachaf> terry1234: OK, you could indeed to that with State.
17:44:58 <terry1234> I'd like to    do return myset; Set.insert foo; Set.delete bar
17:45:13 <shachaf> Actually you could even do it with Writer.
17:45:13 <copumpkin> that's not how it would work anyway
17:45:23 <shachaf> terry1234: That's just a "chain" operating over a single value, right?
17:45:41 <terry1234> shachaf: yeah, but with the possibility for lets in the middle for some pure computations, using when, and other stuff like that
17:45:54 <Eduard_Munteanu> @hoogle modify
17:45:54 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
17:45:54 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
17:45:54 <lambdabot> Control.Concurrent.MVar modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
17:46:04 <Eduard_Munteanu> Grr.
17:46:17 <shachaf> > ($ S.empty) $ execState $ do { modify (S.insert 'a'); modify (S.insert 'b') }
17:46:18 <lambdabot>   fromList "ab"
17:46:26 <shachaf> You can do something like that.
17:46:41 <terry1234> ah, so i thought i had to do get and set each time, but of course a modify function makes sense
17:46:51 <shachaf> I suspect a monad would actually only make your code more complicated, though.
17:47:12 <terry1234> shachaf: what does the ($ S.empty) do - i don't recognise $ at the start of parens
17:47:27 <shachaf> > ($ S.empty) $ execState $ do { contains 'a' .= True; contains 'b' .= True }
17:47:29 <lambdabot>   fromList "ab"
17:47:30 <copumpkin> > ($ 5) (+1)
17:47:31 <lambdabot>   6
17:47:58 <terry1234> ok, thanks everyone, i'll give this a go
17:47:58 <shachaf> terry1234: See what copumpkin said -- it just applies a function to a value, but in the opposite of the usual order.
17:48:01 <shachaf> > ($ x) f
17:48:02 <lambdabot>   Ambiguous type variable `a0' in the constraints:
17:48:02 <lambdabot>    (GHC.Show.Show a0)
17:48:02 <lambdabot>     ...
17:48:04 <Eduard_Munteanu> shachaf: what's that, some lens magic?
17:48:07 <shachaf> Bah.
17:48:08 <shachaf> Anywya.
17:48:10 <shachaf> Eduard_Munteanu: Yep.
17:48:13 <copumpkin> > ($x) f :: Expr
17:48:15 <lambdabot>   f x
17:49:09 <shachaf> terry1234: My position is still that this might be more complicated than doing without it. :-)
17:49:26 <terry1234> shachaf: would you just have a long chain of $ ?
17:49:45 <shachaf> No, but maybe a long chain of (.). Or maybe a list of functions. Or maybe something else.
17:49:48 <shachaf> It depends on the code.
17:50:21 <shachaf> ($)/(&)/(.)/whatever isn't very different from ";" as a separator. :-)
17:50:50 * hackagebot bv 0.2.0 - Bit-vectors library  http://hackage.haskell.org/package/bv-0.2.0 (IagoAbal)
17:52:17 <kini> :t [(+1), (-1)]
17:52:19 <lambdabot> (Num (a -> a), Num a) => [a -> a]
17:52:20 <terry1234> shachaf: i've used a list of functions and foldr ($) before
17:52:49 <kini> :t (-1)
17:52:50 <lambdabot> Num a => a
17:52:57 <kini> hmm
17:53:18 <kini> oh haha
17:53:22 <kini> "Num (a -> a)"
18:00:51 <otters> :t [(-1), (+1)]
18:00:52 <lambdabot> (Num a, Num (a -> a)) => [a -> a]
18:10:01 <FYCouch> hello
18:10:14 <FYCouch> does haskell have a built in data type to represent binary data? (sequence of bytes)
18:10:44 <terry1234> FYCouch: at the simplest level, just use a list of bytes
18:11:00 <terry1234> FYCouch: when you work out that's a performance bottleneck, then we can consider other options
18:11:13 <terry1234> FYCouch: a byte being a Data.Word.Word8
18:11:26 <Eduard_Munteanu> FYCouch: there's bytestrings
18:12:01 <parcs> and mutable/immutable arrays
18:12:08 <Eduard_Munteanu> Which is basically a list of chunks of bytes.
18:12:30 <Eduard_Munteanu> (the chunks are some sort of arrays/buffers)
18:13:12 <FYCouch> terry1234: what's next step up from list of bytes?
18:13:29 <FYCouch> list of word8s, then abstracted into: ?
18:13:47 <Eduard_Munteanu> Bytestrings, like I said above.
18:13:52 <terry1234> FYCouch: as other's said, arrays, mutable, then immutable, bytestrings
18:14:12 <terry1234> FYCouch: but i'd write your app first, get it working, then think about what really needs to be optimised
18:14:14 <FYCouch> what is the format of bytestring vis a vis list of word8's?
18:14:28 <monochrom> perhaps by "built in" you mean "efficient". bytestring is efficient and not built in
18:14:43 <FYCouch> ie, what makes bytestring an improvement over list of word8's?
18:14:45 <shachaf> ByteArray# is efficient and built in and most likely not what they want.
18:14:46 <terry1234> FYCouch: there's a specialised version - Data.ByteString.Char8 - google for that
18:14:55 <Eduard_Munteanu> FYCouch: pretty much the same, except you have a lot fewer nodes in the list.
18:14:58 <shachaf> It's built into GHC, that is.
18:15:00 <shachaf> Not into Haskell.
18:15:05 <shachaf> Haskell has no built in byte type.
18:15:11 <FYCouch> Eduard_Munteanu: is the chunk/block size larger?
18:15:18 <shachaf> No, I'm wrong.
18:15:19 <Eduard_Munteanu> FYCouch: yeah
18:15:20 <shachaf> Word8 is in the standard.
18:15:34 <FYCouch> k makes sense
18:15:47 <shachaf> terry1234: Huh?
18:15:55 <shachaf> terry1234: Data.ByteString.Char8 is the same type as Data.ByteString
18:16:06 <FYCouch> same type/
18:16:07 <FYCouch> ?
18:16:14 <shachaf> Well, add .ByteString to the things I said, which were module names.
18:17:29 <FYCouch> "Data.ByteString.Char8 is the same type as Data.ByteString" <- different but the same?
18:18:25 <monochrom> Data.Bytestring.Char8 is not "specialised"
18:18:47 <shachaf> No, it's just broken.
18:20:56 <terry1234> fucking alright i made a mistake
18:21:51 * shachaf intended no hostility toward terry1234.
18:23:00 <monochrom> shachaf already said the erratum. the sentence after erratum: type Data.Bytestring.Bytestring and type Data.Bytestring.Char8.Bytestring are the same type
18:23:53 <shachaf> i love errata
18:23:55 <shachaf> they are so easy
18:24:05 <applicative> terry1234: I dont think it is a mistake to say that Data.ByteString.Char8 is specialized.  Our friends were forcing a particular interpretation on the word.
18:24:28 <monochrom> well, I sure think it is
18:24:35 <monochrom> call me forcing or whatever
18:24:41 <applicative> no one claimed the types were different, for example
18:24:48 <monochrom> Char is not a specialisation of Word8
18:25:22 <applicative> no, but the functions are different, though the type is the same.
18:25:32 <applicative> for example foldr
18:33:22 <FYCouch> in haskell is there like, 1 root type of data?
18:33:30 <monochrom> no
18:33:30 <FYCouch> like some abstract data type universal and root to all others
18:33:36 <FYCouch> hm
18:33:50 <monochrom> every type is a root type
18:34:10 <FYCouch> where do types come from then?
18:34:22 <mauke> data
18:34:26 <Eduard_Munteanu> Haskell also doesn't have subtyping.
18:34:39 <monochrom> types come from built in types, ->, "data", "newtype"
18:34:53 <FYCouch> where may i see a list of built in types?
18:35:04 <monochrom> the Haskell 2010 Report
18:35:09 <Eduard_Munteanu> @where report
18:35:09 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
18:35:19 <monochrom> thanks
18:35:23 <FYCouch> reading http://www.haskell.org/onlinereport/haskell2010/haskellch1.html#x6-120001.3
18:35:24 <FYCouch> ty
18:35:49 <mauke> what is actually built in? (), tuples, (->), []
18:35:51 * hackagebot system-fileio 0.3.11 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.11 (JohnMillikin)
18:35:57 <mauke> the numeric types ... sort of?
18:36:07 <mauke> oh, Char definitely
18:36:10 <FYCouch> man
18:36:11 <monochrom> yes, I consider Int Integer etc built in
18:36:15 <FYCouch> i came up with the exact same system
18:36:18 <FYCouch> this is really cool
18:37:28 <shachaf> Integer is "more built in" than Int.
18:38:06 <applicative> Bool
18:38:18 <mauke> doesn't look very built in
18:38:26 <applicative> must be needed for if .. then ..else?
18:38:30 <napping> shachaf: why do you think so?
18:38:52 <Eduard_Munteanu> Defaulting rules?
18:39:01 <applicative> because maxBound is different on his machine than mine?
18:39:05 <FYCouch> yea, impossible to read through that spec
18:39:14 <FYCouch> it assumes a working knowledge of haskell. pity
18:39:22 <mauke> applicative: integer literals to through fromInteger
18:39:33 <mauke> FYCouch: no, it doesn't
18:39:41 <FYCouch> why wouldn't bool be built in for the support of if else?
18:39:45 <shachaf> napping: What mauke said.
18:39:46 <applicative> yes. so Integer is 'built in'
18:39:46 <FYCouch> k
18:39:47 <Eduard_Munteanu> FYCouch: well, it's a spec... if you're looking for learning material, there's other stuff, like LYAH.
18:39:51 <Eduard_Munteanu> @where lyah
18:39:51 <lambdabot> http://www.learnyouahaskell.com/
18:39:58 <shachaf> napping: "5" means "fromInteger (5::Integer)"
18:40:02 <FYCouch> nah, not looking to learn haskell. curious how it's done some things is all
18:40:07 <napping> I guess there's that, but String also has constants
18:40:08 <FYCouch> there's a difference
18:40:29 <applicative> FYCouch: () is 'built in' I guess
18:40:44 <shachaf> Well, given that we already said that Char and [] are built in, I'm not sure what we gain from saying that String is also built in.
18:41:12 <applicative> if we say 'therefore String also is built in' we gain
18:41:37 <napping> Most of the types mentioned just have some fancy syntax over things you could define yourself
18:41:58 <Eduard_Munteanu> FYCouch: in any case jumping straight into the middle of a spec might seem difficult
18:42:04 <FYCouch> yea
18:42:06 <FYCouch> makes sense
18:42:10 <shachaf> napping: Sure, you can define most anything yourself, other than (->).
18:42:26 <FYCouch> i was just curious if 'binary' was like some root data type in haskell and all others are field images over this one
18:42:28 <FYCouch> but apparently not
18:42:31 <napping> I think CPL let you define ->
18:42:42 <Eduard_Munteanu> FYCouch: you could try reading through the "gentle introduction", it's a quick introduction.
18:42:45 <Eduard_Munteanu> @where gentle
18:42:45 <lambdabot> http://www.haskell.org/tutorial/
18:43:13 <Playground> Would it be techically correct to say that Haskell (minus exotic GHC extensions) is based on System F-omega?
18:43:21 <applicative> I'm not sure how much you can infer from the Haskell Report about how these things are implemented.
18:43:28 <Eduard_Munteanu> Playground: yeah
18:43:36 <Playground> ty Eduard_Munteanu
18:43:40 <applicative> ghc is
18:43:46 <FYCouch> i'm more interested in apl
18:43:59 <Playground> FYCouch: Go to an APL channel, then. :-|
18:44:22 <FYCouch> is none :(
18:44:33 <applicative> haskell is as much like apl, only  more so, as you like
18:45:20 <applicative> especially now that we have Control.Lens, you can practically write everything in all operators, using alphanumeric things for light relief
18:45:22 <FYCouch> applicative: show me this in haskell: https://www.youtube.com/watch?v=a9xAKttWgP4
18:45:41 <monochrom> in what sense is haskell based on system F-omega? I don't see it. in fact I see a lot of features in System F-omega but not haskell. seem to be too different
18:45:50 <edwardk> applicative: =P
18:46:21 <Playground> monochrom: I thought System F-omega was System-F plus type constructors with arbitrarily many parameters.
18:46:22 <geekosaur> Playground, Haskell without extensions is Hindley-Milner.  With extensions is closer to System Fc
18:46:39 <Playground> geekosaur: What is System Fc?
18:46:46 <geekosaur> as I udnerstand it, which could well  be inaccurate
18:47:36 <geekosaur> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/FC which actually mentioned that earlier GHC core was indeed F-omega
18:47:47 <geekosaur> (with extensions)
18:47:53 <monochrom> ok, I see it now, thanks
18:48:17 <applicative> edwardk: I think I will refer to it as Control.L-ns in order to add theological mystery and to avoid waking you up.....
18:48:23 <Eduard_Munteanu> Fc is probably closer, but I don't see why F-omega would be wrong.
18:48:40 <Eduard_Munteanu> What's F-omega got that Haskell doesn't?
18:48:43 <geekosaur> Eduard_Munteanu, see wthe page I linked
18:49:12 <monochrom> C_ntr_l.L_ns has more theological mystery and wheel of fortune :)
18:50:08 <shachaf> Alt.Lens
18:50:20 <FYCouch> .tasteless?
18:50:49 <applicative> hm, the wikipedia F-omega seems to make it a matter of indefinitely high kinds? ((* -> *) -> *) -> *
18:52:24 <Eduard_Munteanu> applicative: I don't think so.
18:52:55 <applicative> yeah, i'm taking it back ... never really studied the versions of System F
18:53:21 <Eduard_Munteanu> It's more like cumulativity there I think.
18:54:42 <applicative> but whats 'cumulating'?  'the kind of functions from types to types ...'  Im having trouble following.
18:55:08 * applicative looks at the ghc wiki page geekosaur mentioned
18:55:56 <crdueck> i need a function indexedUpdate :: Vector a -> (a -> a) -> [Int] -> Vector a, that applys the function to each of the indexes in the list. Can someone come up with a good implementation of this?
18:57:04 <Eduard_Munteanu> applicative: IIRC, TAPL explained this better, you might want to look there
18:57:10 <Eduard_Munteanu> But I have to go now.
18:57:22 <napping> acharles: use create?
18:57:22 <applicative> ah yes TAPL
19:01:24 <monochrom> indexedUpdate v f xs = accum (\a b -> f a) v (zip xs (repeat ())). I do not know how good it is.
19:02:17 <napping> using the plain update methods and computing new values with ! may also work
19:03:26 <edwardk> crdueck: using Data.Vector.Lens and Control.Lens:      \v f is -> over (ordinals is) f v
19:03:38 <monochrom> yeah, that one goes like v // map (\x -> (x, f (v ! x))) xs
19:04:00 <edwardk> if you are willing to flip the args around its over . ordinals ;)
19:04:19 <monochrom> oh god, what is left for us to do? :)
19:04:50 <edwardk> monochrom: =)
19:04:57 <sw2wolf> @hoogle control.lens
19:04:57 <lambdabot> package lenses
19:04:57 <lambdabot> package data-lens
19:04:57 <lambdabot> package data-lens-fd
19:05:10 <crdueck> edwardk: nice, thanks
19:05:16 <edwardk> monochrom: if we switch to pure profunctor lenses then it becomes 'ordinals'
19:05:24 <edwardk> monochrom: because over = id in that scenario
19:06:06 <edwardk> sw2wolf: its the 'lens' package
19:06:21 <sw2wolf> yes
19:06:28 <edwardk> sw2wolf: https://www.youtube.com/watch?v=cefnmjtAolY&hd=1 provides a gentle introduction
19:06:35 <sw2wolf> thx
19:06:37 <shachaf> "a gentle introduction to lens"
19:06:43 <shachaf> Reminiscent of its namesake.
19:06:43 <edwardk> ;)
19:07:14 <monochrom> but who would have thought: it is a video
19:07:45 <shachaf> monochrom: I started writing a gentle introduction to lens, but got distracted by coming up with new kinds of lenses.
19:07:53 <edwardk> likewise
19:07:54 <monochrom> perhaps the next gentle introduction will be a 3D IMAX movie
19:08:06 <edwardk> if you can find me an imax camera, sure
19:08:31 <johnw> we'll do it in 4k 3D like the Hobbit
19:08:32 <shachaf> I have over a dozen different lens representations lying around.
19:08:36 <johnw> edwardk will play the part of the Dragon
19:08:53 <monochrom> I am thinking a gentle introduction to delimited iteratees
19:08:54 <johnw> "Arr, there be lenses here!"
19:09:32 <shachaf> By the way, unlenses compose in getter order rather than setter order.
19:09:58 <edwardk> you mean the a b s t convention?
19:10:09 <shachaf> I mean p t s -> p b a
19:10:13 <edwardk> ah
19:10:18 <shachaf> Changing the argument order won't do anything.
19:10:23 <shachaf> Because composition still happens the same way. :-)
19:10:28 <edwardk> sure
19:10:34 <shachaf> > (fst.snd) ((1,2),(3,4))
19:10:36 <lambdabot>   3
19:10:43 <shachaf> With unlenses that would work for setters etc.
19:11:42 <edwardk> ok, heading home. bbiab
19:12:01 <latermuse> bye
19:12:53 <monochrom> @sláp monochrom
19:12:53 * lambdabot clobbers monochrom with an untyped language
19:12:56 <monochrom> nice
19:13:32 <monochrom> @slït monochrom
19:13:33 <lambdabot> Unknown command, try @list
19:13:39 <latermuse> @list
19:13:39 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:14:02 <shachaf> ciao
19:14:03 <shachaf> !list
19:14:03 <monochrom> shachaf: http://okmij.org/ftp
19:14:15 <shachaf> thx monochrom
19:16:04 <latermuse> @bf +++++>[+++++<->.]
19:16:04 <lambdabot>  Done.
19:16:08 <monochrom> > reverse "live"
19:16:10 <lambdabot>   "evil"
19:16:30 <shachaf> > rot13 "monochrom"
19:16:32 <lambdabot>   "zbabpuebz"
19:16:37 <shachaf> > rot13 "terra"
19:16:39 <lambdabot>   "green"
19:16:49 <dmwit> ?where rot13
19:16:49 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
19:16:54 <monochrom> > rot13 "evil"
19:16:56 <lambdabot>   "rivy"
19:17:16 <latermuse> > reverse "racecar"
19:17:18 <lambdabot>   "racecar"
19:17:22 <latermuse> thats a pretty concise rot13
19:17:36 <shachaf> > rot13 "ravine"
19:17:38 <lambdabot>   "enivar"
19:17:56 <monochrom> > rot13 "haskell"
19:17:57 <lambdabot>   "unfxryy"
19:18:07 <latermuse> > rot64 "meow"
19:18:08 <monochrom> > rot13 "lens"
19:18:09 <lambdabot>   Not in scope: `rot64'
19:18:09 <lambdabot>   can't find file: L.hs
19:18:19 <monochrom> > rot13 "lens"
19:18:21 <lambdabot>   "yraf"
19:18:51 <shachaf> @let rot13d = iso rot13 rot13
19:18:53 <lambdabot>  Defined.
19:19:13 <latermuse> > rot13d "meow"
19:19:15 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]
19:19:15 <lambdabot>                             ...
19:19:29 <cmccann> @let rot26 = rot13 . rot13 -- now it is twice as encrypted
19:19:31 <lambdabot>  Defined.
19:19:46 <johntromp> > rot13 "greenarret"
19:19:48 <lambdabot>   "terraneerg"
19:20:21 <latermuse> > rot26 "meow"
19:20:22 <lambdabot>   "meow"
19:20:59 <latermuse> > rot26 $ "meow" ++ (rot13 "meow")
19:21:01 <lambdabot>   "meowzrbj"
19:21:47 <shachaf> I'm sorry that I started this.
19:22:00 <cmccann> that's ok. you couldn't help it.
19:22:03 <cmccann> rot13 is in your soul.
19:22:36 <latermuse> hahaha ;D
19:23:00 <cmccann> > rot13 "shachaf"
19:23:02 <lambdabot>   "funpuns"
19:23:34 <Tordek> I want to believe.
19:25:35 <m3ga> i have three Ints representing year month and day of month. What's the best way to get that converted to a UTCTime? should I really convert it to a string of "YYYYMMDD" and then parseTime?
19:26:16 <monochrom> haha that may not be too bad
19:26:33 <johnw> m3ga: Data.Time.Calendar has a function for doing pretty much exactly that
19:26:48 <johnw> look for "fromGregorian"
19:27:06 <johnw> takes a year :: Int, Month :: Int, Day :: Int
19:27:16 <johnw> s/^M/m, s/^D/d
19:28:15 <monochrom> that gives you Day. that's cool because UTCTime wants a Day field, and you have it.
19:28:28 <monochrom> now just fill it the DiffTime field. I suggest 31337
19:28:38 <johnw> the most interesting prime evr
19:28:50 <monochrom> "prime time"
19:29:10 * arbn groans.
19:29:21 <papermachine> bleh.
19:30:10 * m3ga sighs
19:30:31 <m3ga> does anyone else find haskell's date libraries a pain to work with?
19:30:40 <monochrom> no. I love it
19:31:04 <arbn> m3ga: "data libraries"? Which do you mean?
19:31:13 <monochrom> dat*e*
19:31:27 <arbn> Ahh. Misread.
19:31:37 <arbn> No, I've never had trouble with them, and I've used them extensively.
19:31:52 <johnw> they aren't as nice as Python's datetime module, that's for sure
19:32:04 <arbn> Is it the IO that bugs people, or something else?
19:32:05 <johnw> i often find myself looking all over for just the right conversion
19:32:06 <monochrom> it is certainly very unlike C's. but, I hate C's.
19:32:17 <johnw> C's is maybe the worst of them all
19:32:23 <shachaf> hi cmccann
19:32:44 <m3ga> monochrom: do you ever actually use dates that can't be represented as 64 bit seconds since 1970?
19:33:11 <cmccann> hi shachaf
19:33:12 <monochrom> I haven't
19:33:35 <m3ga> i must have been using C's for too long because every time i look at haskell's i end up spending a long time saying wtf.
19:33:51 <shachaf> cmccann: Perhaps the reason I don't use SO is people like you!!!
19:34:07 <archeyDevil> > rot26 "This is useless"
19:34:09 <lambdabot>   "This is useless"
19:35:20 <archeyDevil> > rot13.reverse.rot13 $ "This is useless"
19:35:22 <lambdabot>   "sselesu si sihT"
19:35:34 <archeyDevil> :)
19:36:21 <augur> i wonder if there are any cute rot13 sentences where like
19:36:25 <centrinia_> Do rot13 and reverse generate a free group? :p
19:36:36 <shachaf> i love groups
19:36:38 <shachaf> they are so easy
19:36:49 <latermuse> augur: why dont you try all the permutations in this room, and figure it out?
19:36:51 <augur> rot13 "false this is" == "true that was"
19:36:51 <archeyDevil> What groups"?
19:36:54 <augur> or something silly like that
19:37:00 <centrinia_> Free ones.
19:37:12 <latermuse> rot13 $ permutations [every word in the dictionary]
19:37:25 <archeyDevil> Groups?
19:38:01 <cmccann> shachaf: sorry but I was already writing an answer when you posted yours and I wasn't going to just discard it! geez.
19:38:09 <cmccann> gotta be quicker on the draw to play the SO game.
19:38:18 <centrinia_> > map unwords . permutations $ take 5 $ head $ cake
19:38:19 <monochrom> rot13 and reverse do not generate a free group. rot13 is an involution. reverse is an involution.
19:38:20 <lambdabot>   Couldn't match expected type `GHC.Base.String'
19:38:20 <lambdabot>              with actual typ...
19:38:38 <archeyDevil> @where rot13
19:38:38 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
19:38:44 <latermuse> you could try something like this: filter (== [a word from the dictionary]) $ rot 13 $ permutations [every word in the dictionary]
19:38:44 <monochrom> rot13 and reverse generate the V4 group
19:38:46 <shachaf> cmccann: I wasn't sure if yours was first.
19:38:48 <centrinia_> > map unwords . permutations $ words $ head $ cake
19:38:50 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","18.25 One ounce package cho...
19:38:59 <shachaf> I thought it was.
19:39:11 <shachaf> cmccann: I have several half-written answer drafts on various odd questions that I gave up on!
19:39:11 <cmccann> shachaf: no, you were a couple minutes faster than me.
19:39:14 <shachaf> Why can't you be more like me?
19:39:31 <shachaf> (Is there a way to look at a list of all your drafts? There's no way I can find these questions now.)
19:39:40 <cmccann> not that I know of
19:39:57 <archeyDevil> How would one make rot6'5
19:40:04 <latermuse> > map rot13 . unwords . permutations $ words $ head $ cake
19:40:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
19:40:06 <lambdabot>              with actual ty...
19:40:07 <cmccann> I usually either post or discard immediately
19:40:22 <centrinia_> So my Quake thing kind-of uses Canvas: http://centrinia.github.com/quake/quake.html
19:40:26 <shachaf> Playground: Are you using dependent composition?
19:40:33 <shachaf> cmccann: Maybe I'll just write some monad tutorials to relax.
19:40:38 <Playground> shachaf: I want to.
19:40:44 <shachaf> Playground: But are you?
19:40:52 <cmccann> shachaf: monad tutorials are old hat.
19:40:55 <archeyDevil> centrinia_: Does your quake work?
19:40:58 <cmccann> you should write some lens tutorials instead.
19:41:01 <monochrom> write a lens tutorial
19:41:02 <Playground> shachaf: Nope.
19:41:12 <shachaf> Playground: Why not?
19:41:18 <shachaf> cmccann: I accidentally wrote one and it's my highest-voted SO answer. :-(
19:41:18 <monochrom> also, it's like fajitas
19:41:29 <Playground> shachaf: I am just exploring what is possible for the time being.
19:41:47 <centrinia_> M30W, it has half-assed Canvas support but decent WebGL support.
19:41:57 <cmccann> shachaf: that sounds like a good reason to keep participating on SO
19:42:07 <cmccann> to have a less-embarrassing highest-voted post
19:42:09 <M30W> centrinia_: So.. Firefox + Intel /= decent ?
19:42:16 <shachaf> cmccann: elliott's highest-voted answer is also a monad tutorialish thing.
19:42:34 <centrinia_> It really just depends on rather or not you have WebGL enabled on your browser.
19:43:06 <latermuse> shachaf: Im not understanding. Was your lens tutorial or monad tutorial the highest voted SO answer?
19:43:21 <cmccann> shachaf: my highest-voted post is specifically not about monads. so there!!!
19:44:03 <shachaf> cmccann: Hmm, I think my criticism might still apply.
19:44:35 <monochrom> perhaps write an applicative tutorial next
19:45:06 <latermuse> applicative tutorial would be much appreciated
19:45:21 <shachaf> latermuse: applicative = context-free monad
19:45:25 <shachaf> hth
19:45:26 <cmccann> monochrom: yeah well that's pretty much what my highest-voted post is... :T
19:46:06 <shachaf> cmccann: Actually it's about StrongLaxSemigroupalFunctor, isn't it?
19:46:08 <monochrom> many people still haven't written their applicative tutorials
19:46:13 <shachaf> You barely even mention pure.
19:46:37 <latermuse> shachaf: im learning applicative through the functional perl paper, and im totally lost.
19:46:38 <cmccann> it's all about (<*>), man.
19:46:52 <monochrom> deadline is this Friday! all of you must hand in your applicative tutorial or else!
19:47:11 <shachaf> cmccann: Oh, looks like my drafts are gone forever.
19:47:20 <shachaf> You only get one draft for an answer and one for a question. (If you start a new post, the old draft is cleared.)
19:47:24 <pnielsen> what's the recommended way to do DNS lookups? Network.DNS? (dns package) I noticed I hadn't installed it as a dependency already, and wonder if there's another lib people are using
19:47:33 <shachaf> s/(^|$)/"/
19:47:42 <cmccann> latermuse: if you want to read my sorta-kinda-Applicative-tutorial, see here: http://stackoverflow.com/q/3242361/157360
19:47:54 <latermuse> cmccann: great! thanks
19:47:55 <shachaf> i love strong lax monoidal functors
19:47:56 <shachaf> they are so easy
19:48:52 <monochrom> I just use Network.BSD.getHostByName
19:49:18 <monochrom> comes with Haskell Platform
19:49:40 <cmccann> man. writing instances for a monad transformer and MonadFoo class is horribly tedious.
19:49:55 <shachaf> cmccann: Monad Transformers: Horrible or Horriblest????
19:50:09 <cmccann> shachaf: yes
19:50:18 <cmccann> MonadFoo classes are worse yet
19:50:29 <cmccann> but for whatever reason I decided that I wanted one for These
19:50:38 <pnielsen> monochrom: hmm nice, HostEntry could be enough. I do need information like SOA as well, unfortunately
19:50:55 <cmccann> since I decided to fix one of the operations for its monad transformer anyway I started adding missing instances
19:51:10 <shachaf> Tam`: You really ought to pick one nick and stick with it.
19:51:16 <pnielsen> I found http://hackage.haskell.org/package/hsdns which looks like it has better performance
19:51:48 <cmccann> the names I used for that monad transformer are still fun though.
19:52:08 <pnielsen> I might just use UDP directly
19:52:18 <cmccann> hm, the transformer should probably have a Crosswalk instance too and all that
19:52:19 <cmccann> SIGH
19:52:24 <cmccann> this is totally elliott's fault.
19:52:28 <shachaf> Not TheseT or something?
19:52:39 <monochrom> MrT
19:52:54 <cmccann> shachaf: https://github.com/isomorphism/these/blob/master/Control/Monad/Trans/Chronicle.hs
19:53:06 <shachaf> i love monad transformers
19:53:08 <shachaf> they are so easy
19:53:57 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/91920/
19:55:10 <pnielsen> From: Sheldon Cooper
19:55:13 <latermuse> i roll my own transformers
19:55:19 <startling> monochrom: wonderful
19:56:28 <cmccann> shachaf: while I realize that nobody other than me will ever use that monad transformer I still like the names >:I
19:56:39 <startling> what's wrong with UndecidableInstances and "instance (Monad m, MonadTrans t) => MonadFoo (t m)", btw?
19:56:47 <shachaf> cmccann: It's just like working on lens!
19:56:56 <startling> I guess that's ambiguous in some cases
19:57:11 <cmccann> it's ambiguous in quite a lot of overlapping cases, in fact
19:57:25 <cmccann> remember that instance selection looks only at the head, not the context
19:57:33 <startling> ah.
19:57:45 <cmccann> so that's basically "instance MonadFoo (t m)"
19:57:52 <cmccann> plus some other stuff that gets checked after the fact
20:00:29 <latermuse> cmccann: wonderful applicative tutorial, by the way!
20:01:06 <cmccann> latermuse: that seems to be the common consensus, since that's my highest-voted answer by far
20:01:21 <shachaf> cmccann: SO is pretty odd about which answers they vote up.
20:01:35 <startling> latermuse, are you going to apply your new knowledge?
20:02:21 <latermuse> startling: yep, im practicing it now :D
20:02:38 <startling> ;)
20:02:58 <startling> latermuse, would you call it purely academic?
20:03:12 <latermuse> startling: the tutorial? or my practice?
20:03:16 <startling> 8)
20:03:17 <cmccann> startling: that's the nice thing about Applicative, it proves that both the pure and applied side of things can coexist
20:03:35 <latermuse> > (+ 2) <$> [1..5]
20:03:36 <lambdabot>   [3,4,5,6,7]
20:03:48 <shachaf> lambdabot: They're just making puns. Ignore them.
20:03:55 <shachaf> Hmm, I meant latermuse.
20:04:06 <shachaf> But lambdabot can ignore them too. Probably better for everyone if lambdabot ignores puns.
20:04:07 <latermuse> shachaf: I know ;)
20:04:38 <tac-tics> !vixen
20:04:55 <monochrom> vixen no longer exists
20:05:07 <latermuse> could someone give a quick example of the (<$) operator?
20:05:13 <shachaf> @nixon I think the United States has stood still.
20:05:14 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
20:05:18 <shachaf> Hrm.
20:05:18 <monochrom> http://www.vex.net/~trebla/vixen.txt shows you why
20:05:23 <tac-tics> @nixon
20:05:23 <lambdabot> I don't know anything that builds the will to win better than competitive sports.
20:05:32 <tac-tics> :( bye bye @vixen
20:05:35 <tac-tics> @vixen
20:05:35 <lambdabot> I don't want to see this country to go that way.  You know what happened to the Greeks.  Homosexuality destroyed them. Sure, Aristotle was a homo, we all know that, so was Socrates.
20:05:42 <tac-tics> Ah, I just used the wrong sigil
20:05:45 <cmccann> latermuse: http://stackoverflow.com/q/14087881/157360
20:06:01 <monochrom> but don't forget that vixen is now a typo of nixon
20:06:07 <cmccann> (no, I don't actually have every haskell question on SO memorized)
20:06:12 <cmccann> (only most of the ones I answered)
20:06:13 <monochrom> just like stab is a typo for slap
20:06:30 <startling> latermuse: it's like >>
20:06:41 <latermuse> cmccann: Thanks. I have very little bandwith today, so I didnt want to search google. IRC and SSH are about all I can do at the moment.
20:06:43 <startling> > putStrLn "hello" *> putStrLn "latermuse"
20:06:46 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
20:06:46 <lambdabot>    arising from a use of ...
20:07:05 <startling> :t putStrLn "hello" *> putStrLn "latermuse"
20:07:06 <lambdabot> IO ()
20:07:23 <startling> oh, you asked about <$, oops
20:07:30 <latermuse> ah neat! *> looks cool too
20:07:42 <startling> latermuse: the neat thing to do with *> is pass things through
20:07:42 <cmccann> startling: (<$) is handy for making parsers look nicer
20:08:03 <startling> :t getLine <* putStrLn "thanks!"
20:08:03 <latermuse> startling: so its like (>>) but you can pass things through it?
20:08:04 <lambdabot> IO String
20:08:08 <cmccann> it took me an embarrassing amount of time to realize that
20:08:14 <startling> :T (<$)
20:08:20 <startling> :t (<$)
20:08:21 <lambdabot> Functor f => a -> f b -> f a
20:08:36 <startling> oh excellent
20:08:47 <shachaf> lens uses (<$):
20:08:49 <shachaf> 302:  coerce = (<$) (error "coerced PretextT")
20:08:52 <shachaf> 161:  coerce = (<$) (error "coerced BazaarT")
20:09:02 <startling> shachaf, lovely
20:09:03 <cmccann> startling: nice for things like "Foo <$ spaces <* keyword <*> foo <*> bar"
20:09:05 <monochrom> oh tac-tics was in that discussion. @macho haha :)
20:09:29 <startling> cmccann: I see how it's analogous to <$>, yeah. very cool
20:10:10 <startling> latermuse, (<*) is the one that passes things through
20:10:16 <startling> latermuse: but yeah.
20:10:25 <startling> the way I remember it is that it points to the one you want to keep
20:11:13 <latermuse> can you give a quick example of how it might pass something through?
20:11:26 <startling> :t getLine <* putStrLn "thanks!"
20:11:27 <lambdabot> IO String
20:11:34 <latermuse> id 3 <* putStrLn
20:12:10 <latermuse> oh neat! thanks
20:12:10 <cmccann> shachaf: why doesn't Data.These have a padded version of zip for lists of types that are Monoid or MonadPlus or whatever instances?
20:12:17 <cmccann> not that I expect you to know or anything
20:12:35 <cmccann> but I'm blaming elliott and I figure you can make a reason up on his behalf
20:13:00 <shachaf> cmccann: Didn't you write Data.These?
20:13:14 <cmccann> well, elliott helped.
20:13:31 <cmccann> most of the Align stuff ended up being his in the end
20:13:44 <cmccann> @quote elliott thing.of.majesty
20:13:44 <lambdabot> No quotes match. Do you think like you type?
20:13:53 <cmccann> argh what was that
20:14:07 <simpson> @quote majesty
20:14:07 <lambdabot> malcolm says: I don't believe you need to invoke the full awesome majesty of Template Haskell
20:14:10 <shachaf> @quote elliott majesty
20:14:10 <lambdabot> No quotes match. I've seen penguins that can type better than that.
20:14:11 <shachaf> @quote elliott thing
20:14:11 <lambdabot> elliott says: Only two things in the universe are certain: Death, and two of the libraries you've decided to use taking different types of ByteString.
20:14:43 <cmccann> oh that's why
20:14:44 <cmccann> @quote thing.of.majesty
20:14:44 <lambdabot> edwardk says: <elliott> cmccann: the instances list haddock generates is now a thing of majesty  <edwardk> elliott: welcome to my world
20:14:53 <cmccann> figures edwardk would take the credit
20:15:43 <startling> usually two different types of ByteString from different versions of 'bytestring'!
20:19:48 <cmccann> is there any sort of standard term for case filter functions for sum types? e.g. "justLeft :: Either a b -> Maybe a"
20:19:59 <shachaf> preview _Left
20:20:14 <startling> cmccann, that's 'hush'
20:20:16 <startling> in 'errors'
20:20:27 <shachaf> startling: I think cmccann was looking for a generic term.
20:20:32 <cmccann> there's also listToMaybe
20:20:32 <shachaf> Not this one function.
20:20:45 <shachaf> lens sets the precedent "preview" :-)
20:20:51 <startling> shachaf, I think I have poor reading comprehension
20:20:52 <shachaf> I admit it's slightly long.
20:20:59 * cmccann is adding missing haddocks for These
20:21:11 <cmccann> and trying to figure out how to describe three functions of that sort
20:21:20 * shachaf is distrustful of "errors"
20:21:22 <FYCouch> what is a type? or, what do all types have in common?
20:21:50 <shachaf> cmccann: Did you ever see what the BazaarT hack in lens was?
20:21:59 <cmccann> shachaf: do I *want* to see?
20:22:03 <shachaf> Maybe you can make it go away!
20:22:45 <shachaf> BazaarT was my solution to the problem but it's kind of awful.
20:23:26 <sajith> quick question: if I have "data Color = Red | Green | Blue | Orange", how do I test if x is a Color? Or is that a thing?
20:23:41 <shachaf> sajith: You get a type error if it's not. :-)
20:24:19 <shachaf> (However, if it was only Red | Green | Blue, you might have to do a runtime check. The Orange makes it easier.)
20:24:24 <shachaf> (Please disregard previous message.)
20:25:08 <sajith> shachaf: :-)
20:25:13 <applicative> isColor :: Color -> Bool; isColor _ = True
20:26:19 <shachaf> You could say that ⊥ is not a Color.
20:26:31 <shachaf> Then isColor :: Color -> Bool; isColor !_ = True
20:26:40 <applicative> it's just an unusually indefinite Color
20:26:45 <startling> sajith, use something like Either String Color; then your 'isColor' is just 'isRight'
20:27:00 <shachaf> startling: What?
20:27:13 <shachaf> Are you advising sajith to weaken their types just so they can write an unnecessary function?
20:27:38 <applicative> I think we haven't figured out sajith's idea
20:27:41 <shachaf> I think figuring out some more context would be a much better thing.
20:27:42 <cmccann> :t isRight
20:27:43 <lambdabot>     Not in scope: `isRight'
20:27:43 <lambdabot>     Perhaps you meant `isDigit' (imported from Data.Char)
20:27:49 <cmccann> is wrong :[
20:27:50 <startling> cmccann: Data.Either
20:28:03 <startling> oh ugh maybe not
20:28:11 <startling> I know it's somewhere
20:28:17 <startling> shachaf: but yes, agreed
20:28:20 <cmccann> startling: it's in my Prelude replacement I know that much
20:28:28 <shachaf> > has _Right (Right 'a')
20:28:29 <lambdabot>   True
20:28:30 <shachaf> > hasn't _Right (Right 'a')
20:28:32 <lambdabot>   False
20:28:54 <latermuse> mfw "hasn't"  O_o
20:29:11 <sajith> hmm, actually -- isColor is just fine, I think!
20:29:21 <startling> sajith, no, it's completely useless
20:29:27 <latermuse> :D
20:29:49 <shachaf> This is what you get for giving people jokes that look like advice.
20:30:17 <sajith> sniff
20:30:26 <shachaf> sajith: What are you trying to do?
20:30:36 <shachaf> (Concrete examples, code, etc. are useful if you have any.)
20:31:13 * startling paints shachaf bright ⊥
20:32:27 <latermuse> if isColor red then putStrLn "yes" else putStrLn "no"
20:33:06 <simpson> Well, it'll always be a color.
20:33:21 <startling> latermuse: if it's *not* a Color, it's a type error
20:33:41 <Nereid> putStrLn (if isColor red then "yes" else "no")
20:33:43 <sajith> shachaf: some parsing -- some registers are given, and a bunch of code, and I'm trying to make sure that the code refers to registers.
20:33:49 <latermuse> startling: cant there be a "catch-all" defined in the type to prevent type errors?
20:33:50 <Nereid> although
20:33:57 <Nereid> what
20:34:34 <liyang> Are isos defined via profunctors interchangeable with those defined using lens? What about that Isomorphic k bit?
20:34:36 <startling> latermuse: um, sure
20:34:52 <liyang> (disregard that. I suck.)
20:35:00 <Nereid> isomorphic is gone
20:35:03 <edwardk> liyang: 3.7 used Isomorphic. 3.8 uses profunctors
20:35:14 <edwardk> we should be shipping 3.8 in a few days
20:35:21 <liyang> O I C.
20:35:34 <shachaf> Can you believe the masses don't even has, like, has?
20:35:38 <shachaf> have
20:35:40 <edwardk> folks made a herculean effort to prune the bug list today
20:35:40 <shachaf> Whatever.
20:35:41 <liyang> I'm clearly not keeping up with the latest developments.
20:35:59 <shachaf> edwardk: Hmm, maybe I should be part of that effort.
20:36:33 <shachaf> My excuse is that elliott has been draining all my lens energy in 3AM profunctor Gobby experiments.
20:36:39 <edwardk> heh
20:44:34 <johnw> is HaXR still state-of-the-art for working with XML-PRC?
20:45:04 <johnw> ah, if byorgey is maintaining it, that's a good sign
20:45:54 * hackagebot thyme 0.1.1.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.1.1.0 (LiyangHu)
20:50:59 <FYCouch> what is a type? or, what do all types have in common?
20:52:00 <mauke> what is a value? what do all values have in common?
20:52:27 <startling> FYCouch: _|_
20:52:27 <FYCouch> please don't answer a question with a question
20:52:31 <dmwit> Type checking is a form of static analysis aimed at reducing a particularly easy-to-notice class of bugs.
20:52:36 <FYCouch> please provide answer in english
20:52:48 <monochrom> please just don't answer
20:52:48 <mauke> FYCouch: can you answer my question?
20:52:50 <johnw> types are inhabited by values, values have types
20:52:54 <shachaf> What is a mauke answer? What do all mauke answers have in common?
20:53:04 <FYCouch> evasion?
20:53:18 <mauke> your answer will determine the structure of my answer
20:53:30 <monochrom> anyway, my experience: mauke's counter-question always has a point.
20:53:44 <shachaf> Yes, I appreciate mauke's answers.
20:53:58 <dmwit> FYCouch: mauke is a pretty smart guy. You'd do well not to dismiss him just because his answer isn't easy.
20:54:00 <johnw> FYCouch: I think what he means is, your question may be a bit too abstract
20:54:12 <shachaf> I'm not sure about "abstract". :-)
20:54:21 <johnw> :)
20:54:49 <FYCouch> i understand the type:value relationship. and i'm not saying mauke isn't a smart guy. but asking me a question doesn't answer mine
20:55:05 <mauke> FYCouch: correct but irrelevant
20:55:12 <FYCouch> to you
20:55:19 <FYCouch> to me, your question answer was irrelevant
20:55:24 <geekosaur> we have a certain tendency to not so much answe directly as to try to prompt people to work it out for themselves; that way they actually l;earn more (hopefully)
20:55:30 <mauke> FYCouch: it wasn't an answer. it was a question
20:55:38 <johnw> FYCouch: so, what sort of answer are you looking for?
20:55:48 <FYCouch> johnw: what is a type?
20:55:59 <johnw> from all that I've seen so far, the best I can say that is the things all types have in common is that they have a kind; but that just moves the question one level up
20:56:49 <mauke> the way I see it, we've opened a recursive sub-Q/A
20:56:54 <FYCouch> and this is why i'm asking. not because i haven't thought about it. i've spent the past couple of weeks thinking about the nature of types, values, and data
20:56:59 <dmwit> A type is a member of an inductively-defined set. The particular inductive definition varies from system to system.
20:57:01 <shachaf> i love types
20:57:03 <shachaf> they are so easy
20:57:26 <dolio> No, types are not defined inductively.
20:57:57 <johnw> FYCouch: a type is a set of possible values, disjoint from the contents of every other set.  1 :: Int is not the same value as 1 :: Integer
20:57:58 <dmwit> Okay, it's probably true that types are not defined inductively in all systems. Fair point. =)
20:58:19 <mauke> FYCouch: so are you going to answer my question or can I go back to watching zelda speedruns?
20:58:32 <johnw> mauke: link, please!
20:58:39 <dmwit> huehuehue
20:58:44 <monochrom> I say, go watch zelda speedruns
20:58:55 <latermuse> zelda speedruns are pretty awesome
20:58:56 <FYCouch> i don't know what a value is either
20:59:05 <FYCouch> nor data. they are all up in the air to me still
20:59:12 <FYCouch> i have a vague idea, but nothing concrete
20:59:40 <FYCouch> i look at value as data in the context of a type
20:59:47 <dmwit> FYCouch: Perhaps you would enjoy Types and Programming Languages, a wonderful book introducing the motivation and definition of various type systems.
20:59:50 <monochrom> you are not paid for answering. why bother. only a few profs are paid to answer this question, and they are still studying the subject.
20:59:54 <FYCouch> if i were to summarize where my mind currrently is
21:00:09 <mauke> johnw: http://www.reddit.com/r/speedrun/comments/16gcrh/agdq_vods_english_and_french_part_2_thursday/
21:00:57 <FYCouch> monochrom: so there aren't any firm answers yet in the industry?
21:01:09 <mauke> heh, "industry"
21:01:17 <FYCouch> ok, FIELD
21:01:18 <FYCouch> fuck
21:01:19 <dmwit> Anyway, I feel that answering the question "what is a type" begins by choosing a particular type system. Then you can answer what a type is in that system.
21:01:33 <dolio> mauke: Wow, live?
21:01:38 <monochrom> industry does not care "what is". industry cares about "how to use"
21:01:54 <FYCouch> already changed it to field so you're wasting yourself douche
21:02:27 <FYCouch> i answered his question and of course no follow up. so i've asked a question, got no answer, but his question received an answer. just how i figured it would go
21:02:42 <FYCouch> glad i played along
21:02:50 <shachaf> mm_freak: Wait, you have an SO account with three different answers?!
21:02:55 <mauke> FYCouch: was that directed at me?
21:03:02 <FYCouch> also glad to know if the question is so tough noone in here can break it down, i'm not doing half bad
21:03:06 <FYCouch> yes
21:03:22 <mauke> ah, that wasn't really clear
21:03:57 <mauke> I was thinking about formulating a response but I got kind of put off by the "douche" remark
21:04:04 * dmwit squints skeptically at FYCouch
21:04:16 <FYCouch> well i feel like i have 5 pedant bosses all named Bob
21:04:22 <sclv> mu
21:04:52 <dmwit> Your attitude isn't helping, generally, and ignoring me isn't helping your chances of getting a good answer from me, specifically.
21:05:10 <shachaf> In my experience FYCouch is so unpleasant that I've lost any desire to answer their questions.
21:05:18 <shachaf> I tried a few times previously, and then gave up.
21:05:25 <FYCouch> her, not their
21:05:26 <johnw> FYCouch: http://blogs.msdn.com/b/ericlippert/archive/2011/08/29/what-is-this-thing-you-call-a-quot-type-quot-part-one.aspx
21:05:30 <bjchambers> Any suggestions for a SYB or uniplate-like solution, that would allow me to a transform (for instance) between Exp (Maybe Ty) and Exp Ty?  It seems like all the transforms I've seen only work between like-types.
21:05:53 <shachaf> bjchambers: What is Exp?
21:06:00 <shachaf> Do you just want to fromMaybe, or what?
21:06:12 <shachaf> It seems like this might just be fmap or something.
21:07:40 <bjchambers> Exp is the main datatype in a mutually-recursive AST representation.  The parameter is how types are (currently) being represented.  When parsed, they are "Maybe Ty" (depending on if they were present in the code).  Then I want to turn them into STRef (Maybe Ty), so that I can do some type-inference on them, then I want to collapse that to Exp Ty once everythin is figured out.
21:08:26 <shachaf> How do you turn Exp (Maybe Ty) into Exp Ty? is this changing the structure of the Exp itself, or just the value it's parameterized on?
21:09:12 <dmwit> Sounds like it changes the structure itself by going from a possibly-annotated to a fully-annotated term.
21:09:12 <bjchambers> Both.  Specifically, I was planning on going through the STRef first.  Basically,running type-inference to fill in the types that weren't specified (previously Nothing).  So after that stage, all the Types should have been mutated to be Just ty.
21:10:41 <bjchambers> So yes, it takes a bunch of possibly-annotated terms, then (I was thinking) would go to mutable-possibly-annotated-terms, then run type-inference in the ST monad (converting to mutable-fully-annotated-terms), then remove the STRef to go back to the land of pure AST.  (The first and last steps, seemed like they were boilerplate-ish)
21:11:45 <shachaf> It vaguely sounds like fmap/traverse might be enough, but it's quite likely I'm not understanding what's going on here.
21:12:01 <dmwit> :t traverse
21:12:02 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
21:12:06 <shachaf> Can you give an example of a simple Exp and what it would be at each of these stages?
21:12:23 <dmwit> Yeah, traverse looks pretty good to me.
21:12:44 <bjchambers> I *think* traverse would work, but I wasn't able to figure out if it was possible to derive those.
21:12:51 <shachaf> dmwit: Not if you change the shape of the tree. :-)
21:12:52 <dmwit> Of course, implementing Traversable is just asking the same question, sort of: can you get SYB to implement Traversable for you?
21:13:00 <shachaf> GHC can derive Traversable.
21:13:11 <shachaf> Admittedly it's O(n^2) until 7.6.2 :-(
21:13:32 <dmwit> ...ouch
21:13:34 <shachaf> Anyway, writing boilerplate once is better than writing it every time.
21:13:46 <shachaf> dmwit: See http://hackage.haskell.org/trac/ghc/ticket/7436
21:13:55 <shachaf> A nasty place to have performance bugs come from.
21:14:32 <bjchambers> So it might start with something like:ExpCall { func = ExpVar "foo" (Just $ TyArrow TiInt TyInt), args = ExpVar "bar" Nothing }
21:14:55 <bjchambers> hmm... formatting is a pain...
21:15:48 <liyang> shachaf: did that also affect 7.4.2?
21:16:12 <shachaf> liyang: I'm pretty sure it's been that way since the beginning.
21:16:14 <liyang> (Since that's the release on the platform.)
21:16:44 <bjchambers> Then after inference, the Nothing (the type of the variable reference to Bar) would be changed to "Just TyInt".  I think Traversable might work... let me try it
21:16:56 <shachaf> I don't remember whether I tried it out in 7.4 but I think I did.
21:17:27 <shachaf> bjchambers: If you paste some code people can probably give concrete examples. :-)
21:19:59 <shachaf> Also I bet lenses can improve your program somehow.
21:21:21 <shachaf> liyang: It's actually just quadratic in the size of the path, not the entire structure.
21:21:26 <shachaf> To be more precise.
21:21:33 <shachaf> So if you have a balanced tree or something it's not so bad.
21:22:22 <liyang> Probably why no one has noticed until now I guess.
21:23:05 <bjchambers> So here is what I have so far (I haven't started writing the typechecking itself so things are still listed as "error"): https://gist.github.com/72630a1cc0dabe44e503
21:23:09 <shachaf> Well, lots of things aren't balanced.
21:25:28 <FYCouch> it seems the root type is data, because with a series of bits i can build any other type
21:25:41 <shachaf> @ty traverse newSTRef
21:25:42 <lambdabot> Traversable t => t a -> ST s (t (STRef s a))
21:26:07 <shachaf> @ty traverse readSTRef
21:26:08 <lambdabot> Traversable t => t (STRef s b) -> ST s (t b)
21:26:54 <shachaf> I'm not sure what you intend to do about the Maybes.
21:27:06 <bjchambers> From my vague understanding, I agree that lenses may offer another way to accomplish the same thing without the need to go through ST, but I'm not completely sure.  Maybe I should ignore those steps and nail down doTypeChecking first...
21:27:49 <bjchambers> but it does look like traverse has the right type for this
21:28:40 <shachaf> bjchambers: I actually meant traversals as provided by the library "lens" -- but never mind that for now.
21:29:43 <bjchambers> I think with that type, postTypeCheck = traverse (readSTRef . fromJust)
21:31:04 <shachaf> Ugh, fromJust.
21:31:12 <shachaf> OK then. :-)
21:31:34 <johnw> ack, got my first Could not deduce (Functor m) arising from a use of `<$>' from the context (Monad m).  *shakes fist at the Prelude*
21:31:38 <shachaf> @ty Data.Traversable.sequenceA :: Traversable t => t (Maybe a) -> Maybe (t a)
21:31:39 <lambdabot> Traversable t => t (Maybe a) -> Maybe (t a)
21:31:51 <shachaf> bjchambers: ☝ may be relevant.
21:31:56 <shachaf> (Also known as "traverse id".)
21:32:39 <bjchambers> I guess the alternative would be to build up inferred type information in a map and avoid STRefs altogether.  Then filling in the types could actually traverse the structure and use that map to fill things in, avoiding the need for fromJust.
22:09:09 <lispy> can anyone reproduce this? http://hackage.haskell.org/trac/ghc/ticket/7593
22:11:32 * shachaf wonders whether lispy's ghcii.sh is like his alias ghcii.
22:11:38 <monochrom> on ubuntu 12.04 32-bit x86, ghc 7.4.2, ghci, <interactive>:2:1: parse error on input `⇒'
22:11:41 <mauke> lispy: I can't even type that character in the console
22:11:43 <shachaf> Oh, looks like it's not.
22:11:58 <mauke> what is that $ prompt?
22:12:17 <lispy> mauke: bash running inside emacs.
22:12:38 <lispy> mauke: mintty (a mingw program) gives the same behavior
22:12:44 <lispy> So I don't think it's the console
22:12:51 <mauke> ಠ_ಠ
22:12:58 <lispy> plus ghc barfs when the program is input via file
22:13:39 <monochrom> when in windows console, be sure to "chcp 65501" to ensure utf-8
22:13:44 <mauke> lispy: yes, reproduced
22:13:45 <lispy> shachaf: ghcii.sh is a windowsism for ghc. It translates windows signals into signals that ghc can make sense of (Ctrl-C mainly)
22:14:03 <lispy> mauke: on windows?
22:14:14 <mauke> monochrom: Ungültige Codepage.
22:14:15 <mauke> lispy: yes
22:14:27 <lispy> mauke: what version of ghc?
22:14:33 <mauke> 7.4.2
22:14:42 <lispy> ah, cool so it's not 7.6 specific
22:14:56 <mauke> er, 7.4.1
22:15:23 <lispy> monochrom: I'll try that, but I doubt it will fix it
22:16:27 <lispy> monochrom: invalid codepage :(
22:16:44 <monochrom> then I remembered the number wrong
22:17:11 <shachaf> 65001
22:17:15 <monochrom> yeah
22:17:30 <shachaf> i love code pages
22:17:33 <shachaf> they are so easy
22:17:53 <lispy> Hm...if I do that I can paste that char to cmd.exe but not ghci.exe
22:18:12 <lispy> I think ghc's unicode support on windows is in a half-broken state :(
22:18:29 <mauke> try.hs:1:1: parse error on input `ôçÆ'
22:18:33 <mauke> yay?
22:18:48 <lispy> that's different than the behavior I see
22:19:08 <lispy> Foo.hs:1:1: parse error on input `*** Exception: <stderr>: hPutChar: invalid argument (invalid character)
22:19:39 <mauke> that was with the default codepage
22:19:46 <lispy> I found this because my agda crashes when it tries to print unicode
22:19:50 <mauke> with 65001 I get garbled output instead of an exception
22:19:54 <lispy> ah
22:21:20 <lispy> Foo.hs:1:1: parse error on input `⇒��'
22:21:23 <lispy> close!
22:32:08 <lispy> AFAICT, emacs doesn't have a codepage for 65001, but it does have several encodings with utf8 in the name
22:35:20 <lispy> I can confirm that when agda is run under cp65001 it does not crash
22:45:57 * hackagebot kickass-torrents-dump-parser 0.0.1 - Parses kat.ph torrent dumps  http://hackage.haskell.org/package/kickass-torrents-dump-parser-0.0.1 (MichaelXavier)
22:46:43 <monochrom> interesting name
22:46:45 <latermuse> hmmm, that sounds interesting
22:48:01 <glguy> I think that the website that hosts the file format that this package parses is actually called "kickass torrents", it refers to kat.ph as a hostname
22:59:05 <johnw> edwardk: ping
22:59:13 <edwardk> ?
22:59:36 <johnw> edwardk: I want to start playing around with some natural isomorphisms in Haskell; which library of yours is the first one I should start looking at?
23:00:00 <edwardk> other than lens? ;)
23:00:05 <shachaf> i love lens
23:00:07 <shachaf> it is so easy
23:00:13 <edwardk> shachaf =P
23:00:18 <johnw> haha
23:00:28 <johnw> well, let me describe my application
23:01:23 <monochrom> I love shachaf. he is so predictable. :)
23:01:42 <shachaf> i love being predictable
23:01:44 <shachaf> it is so easy
23:01:48 <monochrom> \∩/
23:01:56 <johnw> i've been writing marshalling code to take types to/from XML, JSON, XML-PRC and the C FFI.  It strikes me that not only is nearly all of this code boilerplate and borderline identical, but each of these is just a pair of isomorphic functors expressing type trees with a homomorphic mapping.  So it seems to me I should be able to <insert-edwardk-library-here>, and come up with an abstract for creating this kind of marshalling code so that
23:01:56 <johnw> it only has to be expressed once
23:02:49 <edwardk> i dont really have many natural isos
23:03:03 <johnw> is this something that maybe lens really is the answer to?
23:03:25 <pdxleif> I heard they have like a "scrap your boilerplate" library.
23:03:39 <johnw> that's true
23:03:50 <johnw> i'll take another look at generics too while I'm at it
23:03:52 <shachaf> boilerplate is so easy. i love it
23:03:58 <johnw> lol
23:04:08 <pdxleif> boilerplate your scraps?
23:04:21 <shachaf> pdxleif: That's Bizarro-SYB?
23:04:25 <shachaf> We haven't explored that yet.
23:04:29 <shachaf> I think there are no instances.
23:04:49 <pdxleif> Wouldn't it be nice to explore non-SYB-like solutions first, if at all possible, though?
23:05:02 <johnw> that's why I pinged the man
23:05:23 <johnw> but I think he's in his "lens is the only thing I want to talk about" phase :)
23:05:28 <lispy> glguy: I made some progress on the agda + windows issues I'm having.
23:05:33 <johnw> I have to wait for that pause between obsessions
23:05:38 <lispy> glguy: I think it's a ghc bug with unicode
23:06:20 <johnw> shachaf: the next time someone asks what monads are, I'm just sending them here: http://opusminimax.wordpress.com/2012/03/27/notes-on-haskell-monads-categorically/
23:07:14 <shachaf> johnw: You do too much of that already.
23:07:25 <johnw> not so much anymore, haven't you noticed?
23:07:45 <edwardk> johnw: nah, he's in the 'been up all day staring at code phase' ;)
23:08:30 <johnw> ooh, this is a promising journal article: "Customizing an XML-Haskell data binding with type isomorphism inference in Generic Haskell"
23:09:09 <edwardk> i'm generally not a fan of cookie-cutter bidirectional programming, e.g. parsing + pretty printing in one go, that may change with prisms, we'll see
23:09:31 <johnw> i don't mind splitting the two, so long as I only have to do it once
23:09:39 <johnw> not twice for every representation
23:09:44 <edwardk> in theory if we make each parser an improper prism then we can bake it in its pretty printer, etc.
23:10:00 * shachaf doesn't like that that much.
23:10:09 <shachaf> Too improper for my taste.
23:10:14 <edwardk> johnw: well, there is always the markdown approach of smashing everything into one uber-representation
23:10:30 <johnw> i don't that's necessary
23:10:43 <edwardk> er not markdown, i mean pandoc
23:12:58 <pdxleif> Doesn't Epigram have syntax like that?
23:16:04 <Liebach> Goodmorning.
23:22:42 <lispy> Is there a way to tell a ghc compiled program to not do any encoding autodetection?
23:25:48 <monochrom> the encoding autodetection uses the environment only (os, environment vars, codepage). does not use file content. so, just control the environment to force your desired encoding.
23:31:38 <lispy> at this point I've set LANG, played with all the emacs vars for this that I can find and agda is still not doing what I want when called from agda-mode, but it can do the right thing in a shell.
23:31:54 <lispy> So, I'm going to try modifying the agda source and see what changes
23:33:17 <lispy> emacs, afaict, doesn't have a way to set the code-page.
23:33:32 <lispy> it has ways to change the encoding that it will use but I think code-page is like an env var
23:35:58 * hackagebot publicsuffixlist 0.0.2 - Is a given string a domain suffix?  http://hackage.haskell.org/package/publicsuffixlist-0.0.2 (MylesMaxfield)
23:36:00 * hackagebot publicsuffixlistcreate 0.0.1 - Create the publicsuffixlist package  http://hackage.haskell.org/package/publicsuffixlistcreate-0.0.1 (MylesMaxfield)
23:43:17 * lispy => bed
23:44:52 <shachaf> * lispy ⇒*** Exception <stderr>: hPutChar: invalid argument (invalid character)
23:45:11 <monochrom> haha
23:45:32 <shachaf> monochrom: Have you had any people go to your Haskell meetings yet?
23:45:48 <monochrom> yes. we had 4 last time
23:46:14 <monochrom> which was just last week
23:46:18 <shachaf> Exciting!
23:46:21 <shachaf> Did you talk about lenses?
23:46:58 <edwardk> Next boston haskell is on the 23rd. shachaf should come
23:47:05 <monochrom> no, I talked about parsec: using user state, using input types other than [Char], and using other monads than Identity
23:47:40 <monochrom> part of it is http://hpaste.org/80484
23:47:49 <shachaf> Is that Continuation Parsec Style?
23:47:52 <shachaf> I bet it is.
23:47:54 <monochrom> yes!
23:48:37 <shachaf> edwardk: My east-coast plans are to be in NY in March.
23:48:49 <shachaf> Unfortunately that's neither the 23rd nor Boston.
23:49:25 <edwardk> oh well. still time to change your plans ;)
23:49:33 * cmccann pushes these, now enhanced with lens magic, including the traversals here and there.
23:49:36 <cmccann> these has the best names.
23:50:07 <edwardk> everything is improved by adding traversals here and there
23:50:25 <cmccann> being able to write 'over here' and 'over there' makes it all worthwhile
23:50:46 <edwardk> heh
23:50:55 <shachaf> cmccann: That's forward-compatible with 3.8?
23:51:25 <cmccann> it's sideways-compatible with whatever lens version I have installed
23:51:33 <cmccann> which is probably one I grabbed from github last week
23:51:35 <cmccann> so who knows!
23:51:43 <shachaf> -- (let's all pretend I know how this works ok)
23:51:43 <shachaf> prism bt seta = dimap seta (either pure (fmap bt)) . right'
23:51:47 <shachaf> Sounds right.
23:52:05 <shachaf> It's actually pretty simple if you'd like an explanation.
23:52:17 <cmccann> maybe when it isn't 3am
23:52:23 <shachaf> It's always 3am...
23:53:08 <shachaf> Do you know how Iso works?
23:54:19 <cmccann> maybe
23:54:23 <cmccann> but srsly though
23:54:30 <cmccann> time for me to sleep
23:54:35 <shachaf> i love sleep
23:54:36 <shachaf> it is so easy
23:54:59 <cmccann> ok but how do you feel about things that are not easy
23:56:03 <startling> shachaf has no answer
23:56:24 <shachaf> i love things that are not easy
23:56:27 <shachaf> they are so easy
23:56:33 <cmccann> edwardk: oh I also added a function that aligns using mappend
23:56:36 <startling> shachaf, excluded middle dude
23:56:37 <cmccann> which is potentially useful
23:56:39 <cmccann> but more importantly
23:56:44 <cmccann> I could call it "malign"
23:56:48 <shachaf> startling: Dual-intuitionistic logic, dude.
23:57:12 <shachaf> cmccann: Pun-driven development happens in lens too.
23:57:56 <startling> shachaf: :(
23:58:35 <shachaf> startling: Also I don't think the law you're looking for is LEM.
23:58:37 <shachaf> It's the other one.
23:58:42 <shachaf> cmccann can tell you what it's called.
23:58:47 <startling> the double negation one?
23:58:49 <shachaf> The law of no nonsense or something.
23:59:02 <monochrom> what is dual-intuitionistic logic?
23:59:05 <shachaf> personally i love nonsense though
23:59:17 <shachaf> monochrom: Where you have double-negation elimination but not double-negation introduction
23:59:19 <cmccann> http://en.wikipedia.org/wiki/Law_of_noncontradiction
23:59:26 <shachaf> So ¬¬p is stronger than p
