00:00:00 <SamanthaD> geekosaur: Thank you!
00:00:16 <geekosaur> remember, it works right to left
00:00:21 <tieTYT2> geekosaur: I have a shaky grasp, I guess I don't get what's a parameter to what here
00:00:51 <geekosaur> you have a composed function map(lambda) . group . sort, applied to the list
00:01:06 <tieTYT2> ok that's what I thought it was doing, but
00:01:12 <geekosaur> which you can also write as map (lambda) (group (sort list))
00:01:20 <tieTYT2> oh...
00:01:36 <tieTYT2> nm, I thought it was doing this: map (lambda group sort) (list)
00:02:06 <tieTYT2> i thought the . after the lambda means that the group and sort are part of the function to map
00:02:10 <plhk> functorfun: okay, but let's move this conversation to private
00:02:13 <tieTYT2> can you explain why that isn't the case?
00:03:13 <tieTYT2> or to word it another way, why is there a . after the lambda.  What is that doing?
00:03:41 <geekosaur> do you understand currying and partial application?
00:03:56 <tieTYT2> somewhat
00:04:13 <tieTYT2> i'm reading learn you a haskell.  This is very new stuff to me so I don't have a solid grasp yet
00:05:20 <geekosaur> ok, so (map (fucntion or lambda goes here) is a partial application; it is a function that takes a list and produces a list
00:05:40 <geekosaur> :t map (+1)
00:05:41 <lambdabot> Num b => [b] -> [b]
00:05:50 <geekosaur> :t map
00:05:51 <lambdabot> (a -> b) -> [a] -> [b]
00:05:55 <tieTYT2> what's "partial" about it?
00:06:10 <geekosaur> compare what I just had lambdabot print out
00:06:50 <tieTYT2> ok
00:07:10 <geekosaur> map "wants" two parameters.  we are supplying one of them; this is partial application, and the result is a function that takes the remaining parameter(s) and produces the fiinal result, as if you'd provided all the parameters normally
00:07:58 <geekosaur> so in this case (map (lambda)) takes a list and produces a list; that can then be composed with anything that produces a list
00:07:58 <tieTYT2> ah ok yes I get this part
00:08:18 <geekosaur> > grpup . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
00:08:19 <lambdabot>   Not in scope: `grpup'
00:08:20 <lambdabot>  Perhaps you meant one of these:
00:08:20 <lambdabot>    `group' (imported...
00:08:24 * shachaf thinks "partial application" is a misleading term.
00:08:25 <geekosaur> bah
00:08:34 <geekosaur> > group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
00:08:36 <lambdabot>   [[1,1,1,1],[2,2,2,2,2,2,2],[3,3],[5],[6],[7]]
00:08:40 <tieTYT2> yeah I get this part too
00:08:41 <glguy> shachaf: given that functions have exactly one argument?
00:08:51 <tieTYT2> I think the thing that's confusing me is the period after the lambda and before group
00:08:52 <shachaf> Right.
00:09:02 <geekosaur> it's the same as the period between group and sort
00:09:26 <shachaf> It's just regular application, and as long as you don't have that concept, you'll have trouble understanding anything.
00:09:57 <tieTYT2> well if it's the same, doesn't it mean the function can be rewritten like this:  map ((\l@(x:xs) -> (x,length l)) . group . sort) [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
00:10:14 <geekosaur> no
00:10:26 <geekosaur> application binds tighter than anything else
00:10:54 <geekosaur> so   map (lambda)   is a single "expression" as seen by (.)
00:11:02 * hackagebot crypto-pubkey-openssh 0.1.0 - OpenSSH public keys parser  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.1.0 (FedorGogolev)
00:11:44 <tieTYT2> ok
00:11:56 <tieTYT2> so it's like this: map (\l@(x:xs) -> (x,length l)) ( group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7])
00:12:07 <geekosaur> yes
00:12:12 <shachaf> Yes.
00:12:21 <tieTYT2> i see that that gives the same result in ghci
00:12:33 <geekosaur> it should; you just wrote out what (.) does, differently
00:12:57 <geekosaur> (f . g) x = f (g x)
00:13:17 <geekosaur> (f . g . h) x = f (g (h x))
00:14:11 <geekosaur> so, it's also the same as:  map (\l@(x:xs) -> (x,length l)) (group (sort [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]))
00:15:01 <tieTYT2> but I still don't get why that . isn't making it like this: map ((\l@(x:xs) -> (x,length l))  group . sort)  [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
00:15:24 <geekosaur> but by using (.) we re-group it so it's the functions that go together instead of having stuff wrapped around the list at the center; this means we can take that composed group of functions and use it somewhere else as well
00:15:25 <tieTYT2> sorry, you're being very patient with me
00:15:46 <geekosaur> why would (.) do that?
00:15:53 <geekosaur> again:  application binds tighter
00:16:02 <geekosaur> you apparentlu read that as (.) binds tighter?
00:16:02 * hackagebot keter 0.3.5 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.5 (MichaelSnoyman)
00:16:16 <geekosaur> application is the space in:  map (lambda)
00:17:06 <geekosaur> so   map (lambda)   is the same as   (map (lambda))
00:18:33 <tieTYT2> can you explain why this doesn't work? map (\l@(x:xs) -> (x,length l)) group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
00:18:43 <tieTYT2> Couldn't match expected type `b0 -> c0' with actual type `[b1]'
00:18:45 <geekosaur> because you dropped a (.)
00:18:57 <tieTYT2> right, but what's it trying to do now that I dropped that?
00:19:22 <geekosaur> :t map (\l@(x:xs) -> (x,length l)) group . sort
00:19:24 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `[b1]'
00:19:24 <lambdabot>     In the return type of a call of `map'
00:19:24 <lambdabot>     Probable cause: `map' is applied to too many arguments
00:19:43 <geekosaur> ah, won't give me the right garbage.  but it does tell you why...
00:20:18 <geekosaur> because you have a space (application) instead of (.) (composition), you are passing "group" as an additional parameter to map
00:20:19 <tieTYT2> but group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7] returns a list of list
00:20:22 <tieTYT2> and that map can process that
00:20:37 <geekosaur> again, application binds tightest
00:20:41 <tieTYT2> ohhh
00:20:57 <tieTYT2> ok now I think I am starting to get it
00:20:59 <tieTYT2> let me think more
00:21:33 <tieTYT2> so that's trying to do this: (map (\l@(x:xs) -> (x,length l)) group) . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
00:21:50 <geekosaur> and because this is a functional language, that is not a syntax error; passing a function is exactly what you are doing with the *first* parameter to map...
00:22:21 <geekosaur> in principal, it can make perfect sense to pass the function group as a parameter.  but map doesn't have a compatible type for that...
00:22:25 <geekosaur> right
00:22:31 <geekosaur> er.  "in principle"
00:22:36 <geekosaur> I should be in bed now...
00:22:44 <tieTYT2> sorry, thanks for being patient
00:24:00 <geekosaur> (you have "group" where map expects to see a list; plus the fact that it's being composed means it's also receiving an additional parameter from somewhere.  this does lead to weird errors; recentish ghc deciphers those errors by pointing out that it's probably a missing or extra parameter, as appropriate)
00:25:08 * geekosaur decides to try that elusive sleep thing again
00:25:20 <tieTYT2> oh wow
00:25:25 <tieTYT2> ok I think i get it: (f . g) x = f (g x)
00:25:29 <tieTYT2> like you said above
00:25:48 <tieTYT2> if I just map that to the original thing: map (\l@(x:xs) -> (x,length l)) (group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7])
00:26:12 <geekosaur> right.  all we've really done is move the parens around; but that movement means we've now got a reusable function instead of something with a list buried in its guts
00:27:04 <geekosaur> for an exercise, now do the same with the remaining dot
00:27:16 <tieTYT2> if I just map that to the original thing: map (\l@(x:xs) -> (x,length l)) (group ( sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]))
00:27:34 <geekosaur> yep
00:28:00 <geekosaur> (and the last step is that you can now remove the ($) because it's not really doing anything any more)
00:28:15 <tieTYT2> if I just map that to the original thing: map (\l@(x:xs) -> (x,length l)) (group ( sort [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]))
00:28:27 <geekosaur> (because "sort" and the list cannot be decomposed into smaller things)
00:28:46 <tieTYT2> oh this also does the same thing: map (\l@(x:xs) -> (x,length l)) $ group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
00:28:54 <mm_freak> is there any state of the art in i180ning haskell programs?
00:28:56 <tieTYT2> to me that's waaaay simpler to comprehend
00:29:04 <mm_freak> i18ning
00:29:19 <tieTYT2> if the book wrote it that way I wouldn't even be confused
00:29:23 <geekosaur> ($) is also rather strange.  it;s actually function application with the lowest precedence instead of the highest; as a result, it behaves like inverted parentheses
00:29:31 <XexonixXexillion> mm_freak: I'd hate to see what i180n stands for :p
00:29:47 <mm_freak> > map (liftA2 (,) id length) . group . sort $ "aaabbcdddddddee"
00:29:50 <lambdabot>   [("aaa",3),("bb",2),("c",1),("ddddddd",7),("ee",2)]
00:29:56 <mm_freak> > map (liftA2 (,) head length) . group . sort $ "aaabbcdddddddee"
00:29:57 <geekosaur> big long thing 1 $ big long thing 2    is    (big long thing 1) (big long thing 2)
00:29:59 <lambdabot>   [('a',3),('b',2),('c',1),('d',7),('e',2)]
00:30:06 <mm_freak> XexonixXexillion: yeah =)
00:30:17 <tieTYT2> i see
00:30:44 <mm_freak> or if you prefer arrows…
00:30:50 <mm_freak> > map (head &&& length) . group . sort $ "aaabbcdddddddee"
00:30:52 <lambdabot>   [('a',3),('b',2),('c',1),('d',7),('e',2)]
00:31:02 * hackagebot Pollutocracy 1.0 - An imaginary world  http://hackage.haskell.org/package/Pollutocracy-1.0 (IsaacDupree)
00:31:11 <mm_freak> but i prefer applicative style, even in the rare case when arrow style is shorter
00:31:14 <tieTYT2> to me that original method only makes sense by definition to me.  I know f . g x = f (g x)  When I map that to the original function, it just makes more sense to me
00:31:29 <mm_freak> tieTYT2: (f . g) x = f (g x)
00:31:45 <mm_freak> f . g x is entirely different and likely a type error, when (f . g) x would be correct
00:31:50 <tieTYT2> but I always assumed that composition was composing functions together, so I thought putting it between the lambda and the group would be composing the lambda and group together
00:31:59 <tieTYT2> mm_freak: my bad
00:32:27 <mm_freak> tieTYT2: you may be confused by the usage of ($)
00:32:38 <mm_freak> > (map (liftA2 (,) head length) . group . sort) "aaabbcdddddddee"
00:32:41 <lambdabot>   [('a',3),('b',2),('c',1),('d',7),('e',2)]
00:33:07 <mm_freak> the ($) does the same:  it applies the left side to the right side
00:33:27 <mm_freak> but it makes the code flatter and more confusing for the sake of saving a pair of parentheses
00:33:41 <mm_freak> (if you get the impression that i don't like ($), you are right) =)
00:33:47 * Eelis loves $
00:33:48 <tieTYT2> mm_freak: would you say the same thing about (.)?
00:34:01 <mm_freak> tieTYT2: (.) is a different beast…  it composes functions
00:34:09 <mm_freak> f $ x = f x
00:34:13 <mm_freak> (f . g) x = f (g x)
00:34:15 <tieTYT2> right but it also gets rid of parens
00:34:38 <XexonixXexillion> mm_freak: By state of the art i18n do you simply want proper encoding of characters, or do you want proper sorting and printing of numbers? Data.Text works brilliantly for the former, and I'm not aware of any good libraries for the latter
00:34:48 <mm_freak> tieTYT2: there is a natural reason that makes getting rid of parentheses sensible in this case:  the associativity of (.)
00:35:03 <mm_freak> it's not a bad idea to have flat compositions:  f . g . h
00:35:25 <mm_freak> there is a natural reading direction to function compositions, which isn't true for function application
00:35:43 <Eelis> natural how?
00:35:47 <mm_freak> that's why ($) can make code much harder to read
00:35:52 <mm_freak> Eelis: right to left
00:36:14 <mm_freak> you can disregard any kind of grouping in the composition…  that's the point of the associativity law
00:36:16 <Eelis> you can't read   a $ b $ c  right-to-left ?
00:36:56 <mm_freak> you can't /assume/ that you can read a $ b $ c right-to-left, if 'a', 'b' and 'c' are longer pieces of code
00:37:15 <Eelis> eh?
00:37:18 <mm_freak> XexonixXexillion: i want something like gettext
00:37:52 <XexonixXexillion> mm_freak: hgettext?
00:37:53 <mm_freak> but with a sensible interface =)
00:37:58 <mm_freak> so not hgettext ;)
00:37:59 <XexonixXexillion> ah
00:38:28 * Eelis uses $ liberally and finds that it vastly improves the readability of his code
00:38:50 <mm_freak> Eelis: it improves it /now/, but i noticed that it makes coming back to your code a few weeks/months later much more difficult
00:39:10 <Eelis> i have not noticed that at all
00:39:20 <mm_freak> this is not a weird theory…  i have actually had trouble with it
00:39:48 <Eelis> "trouble" is kinda vague
00:39:48 <mm_freak> the question you should ask yourself is:  it makes code more readable /than what/?
00:40:01 <shachaf> monoids make life easy
00:40:24 <XexonixXexillion> It always bugged me that getText in hgettext is String -> IO String.
00:40:35 <mm_freak> i'm not saying that ($) makes code unreadable…  i'm saying that parentheses are preferable, because they make revisiting your code easier
00:41:08 <mm_freak> a quick glance should immediately reveal the structure of your code
00:41:12 <Eelis> nested parens make my code unreadable. $ makes my code more readable than the unreadable version with nested parens ^_^
00:41:32 <mm_freak> if you have too many nested parentheses, your coding style is broken
00:41:43 <Eelis> i don't, because i have $ :)
00:41:44 <mm_freak> in that case ($) is just a workaround
00:41:51 <mm_freak> and it doesn't fix the issue
00:41:55 <Eelis> it does
00:42:12 <mm_freak> Eelis: are you a commercial haskell programmer?
00:42:20 <tieTYT2> ugh I've confused myself again.  this works exactly how I expect: map ((+)3 . (+)3 . (+)3) $ [1..10]
00:42:30 <Eelis> mm_freak:  are we going to measure hpenis size now?
00:42:41 <tieTYT2> takes all those functions and applies it to the LIST
00:43:02 <mm_freak> Eelis: no…  the point is that commercial code becomes large, and your brain's memory is limited
00:43:02 <tieTYT2> why is it that this one only takes the first function and applies the other 2 to the list immediately? map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
00:43:09 <tieTYT2> i think I'm missing the key difference between these examples
00:43:13 <mm_freak> Eelis: but i take that as a "no"
00:43:38 <mm_freak> haskell doesn't magically make all your readability problems go away
00:43:41 <Eelis> mm_freak: well, if you want to say that your arguments only apply in commercial code and don't apply in non-commercial code, then that's fine by me
00:43:49 <`ramses> tieTYT2: because function application binds stronger then (.)
00:44:04 <mm_freak> Eelis: they apply to large code bases
00:44:05 <`ramses> tieTYT2: you need parens around the function you're mapping in this case
00:44:34 <`ramses> tieTYT2: map a . b = (map a) . b /= map (a . b)
00:45:05 <Eelis> mm_freak: so if i split my large code base up into small neat modules, i have your blessing to use $ ?
00:45:25 <mm_freak> Eelis: that doesn't make the code base small
00:45:58 <mm_freak> there is a threshold for when you actually have to read your code again to understand it, because you can't memorize everything
00:46:09 <Eelis> mm_freak: but then how do you decide whether a given piece of code in a module is part of a large code base or a small code base, when it can be part of both at the same time?
00:46:43 <tieTYT2> `ramses: I know it wouldn't compile, but how wuld I rewrite that map function so it composes the lambda, the group, and the sort as the a?
00:47:02 <`ramses> tieTYT2: put parens around it
00:47:10 <tieTYT2> `ramses: that's the only way?
00:47:14 <mm_freak> Eelis: by establishing a notion of dependence and projects:  a project has a large code base, if it depends on a large volume of non-external code
00:47:38 <`ramses> tieTYT2: or define that thing as a seperate function (would reader nicer as well)
00:47:55 <tieTYT2> map ((\l@(x:xs) -> (x,length l)) . group . sort) ... like this you mean right?
00:48:09 <Eelis> mm_freak: so you're saying that if i use $ in a small self-contained module where it's perfectly readable, that very same use will somehow become unreadable if the module is imported by a large project? this makes *no* sense at all :D
00:48:28 <`ramses> tieTYT2: yeah, but I'd give that a name in a where clause then, because that's ugly :)
00:48:37 <mm_freak> Eelis: you're just twisting my words
00:48:49 <Eelis> mm_freak: no, i'm showing that your arguments make no sense
00:48:55 <tieTYT2> `ramses: sure, I'm just trying to understand this example from the book.  I wouldn't have written it this way to start with
00:49:13 <tieTYT2> so you said application has higher precidence.  The application of what, in this example?
00:49:28 <mm_freak> Eelis: i have no time to establish a formal model for you…  if you don't understand my point or disagree, feel free to keep using ($)
00:49:29 <`ramses> tieTYT2: the application of map to it's first element
00:49:35 <`ramses> tieTYT2: map a . b = (map a) . b /= map (a . b)
00:49:47 <Eelis> mm_freak: thanks, will do. and let me know if you ever get around to establishing that formal model
00:49:56 <`ramses> the map gets applied to the a before the dot is considered in the first expression
00:50:12 <tieTYT2> ahh
00:50:13 <tieTYT2> ok
00:50:17 <tieTYT2> this is becoming more clear
00:50:40 <`ramses> so in your case, map gets applied to the lambda, and then the map (\ ..) gets composed with the other two functions
00:50:42 <mm_freak> Eelis: but to help you understand my point:  print (some very long expression)
00:50:52 <mm_freak> that's better than:  print $ some very long expression
00:51:04 <Eelis> better why?
00:51:17 <mm_freak> a quick glance reveals the structure, while in your variant your eyes have to search for the ($)
00:51:24 <tieTYT2> `ramses: can you define what you mean by composed, in this case?
00:51:27 <Eelis> also, weren't you arguing a few minutes ago that this kind of very long expression is bad?
00:51:41 <Eelis> i find $ quite quick-glance friendly
00:51:41 <`ramses> tieTYT2: the (.), which is called function composition
00:51:41 <mm_freak> Eelis: no
00:52:09 <Eelis> maybe you're just not good at quick glancing $
00:52:14 <Eelis> because you don't like it
00:52:51 <mm_freak> i've used it for years before i switched to parentheses
00:52:58 <mm_freak> i loved it when i started with haskell
00:53:05 <frerich> mm_freak: Maybe '$' in a situation as you sketch could be considered ok if you then wrote a line break and indented the next line a bit? That's what I've been doing all the time...
00:53:10 <derdon> Eelis: no, he doesn't like it because he's not good at quick glancing $ ;)
00:53:18 <Eelis> derdon: :D
00:53:31 <`ramses> tieTYT2: so "map a . b" is the function "map a" composed with the function "b"
00:53:36 <mm_freak> frerich: yeah, that's a valid usage
00:53:48 <derdon> post-hoc ergo prop de hoc
00:53:49 <mm_freak> f $ do {- next line -} …
00:53:59 <mm_freak> Eelis: i think, paul graham's notion of the blub paradox can be extended from languages to coding style…  right now you're suffering from the blub paradox
00:54:01 <Eelis> i find "print $ some long expression" very convenient because i only have to read "print $" to know that the rest of the thing is the argument to print, whereas with "print (" i have to scan for ")" to know if there's going to be more arguments
00:54:09 <`ramses> tieTYT2: while in "map (a . b)" the map function takes as  an argument the composition "a . b"
00:54:17 <frerich> mm_freak: It has the nice benefit that you don't need to indent very much, i.e. chances are that your long expression starts further left than it originally would have.
00:54:28 <mm_freak> Eelis: with ($) you have to scan for the EOL…  same thing
00:54:42 <mm_freak> or rather the end of the expression
00:54:44 <Eelis> rofl, "scanning for EOL"
00:55:10 <mm_freak> frerich: which one?
00:55:31 <derdon> it takes hours for me to see where the end of line is!
00:55:55 <Eelis> mm_freak:  i don't agree that it's the same thing, but if you're now arguing that they're the same, then do i understand correctly that you're no longer arguing that parens are better here?
00:55:58 <mm_freak> Eelis: you know, people start making fun of others, when they are losing the argument…  make a point referring to real work you have done with both approaches
00:56:42 <Eelis> mm_freak: oh, that's funny, i thought when people were losing the argument they said things like "i have no time to establish a formal model for you"
00:56:46 <shachaf> I suspect life would be better for everyone if you both just stopped.
00:56:54 <Walther> Quick question - Haskell and sockets, [y/n]?
00:56:59 <mm_freak> Walther: y
00:57:15 <Walther> (just going through a lecture about networking; has some examples of sockets in C=
00:57:27 <Walther> erm, C )
00:57:49 <frerich> mm_freak: I meant, if you insert a line-break after the ($) in "print $ <some very long expression>" then you have to indent the line for "<some very long expression>" just one character. Which can be nice if the expression is indeed rather long and close to bursting your column limit (78 or 80 or 120 or whatever). Not a biggie, just thought I could contribute this non-subjective aspect. :)
00:58:04 <Walther> Ah, apparently there's "Network.socket"
00:58:56 <mm_freak> Eelis: that's just trolling…  to prove my point correct i have to do a lot of work, and you can't expect me to do it, just to convince you
00:58:58 <tieTYT2> `ramses: So is it currying?  Specifically, is it returning a function with this type: [[a]] -> [(a, Int)]
00:59:01 <mm_freak> that doesn't mean i'm wrong
00:59:03 <Lethalman> Walther, there are a lot of network hackages, just look into the Network category
00:59:06 <mm_freak> it means, that the discussion is tiring
00:59:08 <Eelis> mm_freak: yet you insist that i present elaborate comparisons of use cases
00:59:14 <Walther> Lethalman: Figured.
00:59:18 <Eelis> mm_freak: so you're a hypocrite
00:59:49 <mm_freak> Eelis: i'm not insulting, why are you?
01:00:15 <Eelis> mm_freak: pointing out hypocrisy isn't insulting
01:00:17 <mm_freak> frerich: actually with parentheses you can indent out past the outer expression's indentation, but i don't do that
01:00:25 <`ramses> tieTYT2: yes, if "f :: a -> b", then "map a :: [a] -> [b]"
01:00:32 <`ramses> err, map f
01:00:36 <shachaf> Are you people still going on about this?
01:00:47 <tieTYT2> who are you calling you people?
01:00:47 <shachaf> Can you take it to some other channel, like #haskell-/dev/null?
01:01:04 <Eelis> mm_freak: calling me  troll on the other hand, is
01:01:12 <tieTYT2> `ramses: I think that's what I didn't get, makes it mostly clear to me
01:01:18 <mm_freak> Eelis: it is, but you also made fun of me, which is another form of insult…  but i'll stop now
01:01:23 <Eelis> lol
01:01:25 <Eelis> ok
01:02:17 <tieTYT2> thanks a lot for the help on that, everyone
01:02:33 <`ramses> np :)
01:02:58 <shachaf> tieTYT2: Terminology note: Returning a function isn't the same thing as currying.
01:03:08 <mm_freak> Eelis: just one more thing, i'm the author and maintainer of several large packages on hackage…  i have tried both approaches and not only my own revisiting indicates that i'm right, but also feedback from others…  just switching from ($) to parentheses where appropriate made my code a lot more readable for others
01:03:14 <shachaf> Currying is turning one kind of function into another. It's something that you do relatively rarely.
01:03:26 <Eelis> mm_freak: this is just hpenis+assertions, not argument
01:03:43 <shachaf> mm_freak, Eelis: This means you.
01:03:45 <tieTYT2> oh ok
01:03:45 <basdirks> I have a Seq String, but I sorta wanna concat those strings into one String
01:04:00 <tieTYT2> good night
01:04:14 <basdirks> but I have the feeling that this might be a silly question =[]
01:04:16 <mm_freak> Eelis: i assume that you understand the concept of empirical proof, so i won't go further into this
01:04:24 <shachaf> basdirks: Data.Foldable.concat?
01:04:28 <Eelis> mm_freak: you keep saying that. i hope you mean it this time
01:04:36 <shachaf> Why are you doing this?
01:04:38 <shachaf> Can you stop?
01:04:44 <Eelis> shachaf: i hope so!
01:04:46 <mm_freak> shachaf: sorry =)
01:04:57 <basdirks> cheers shachaf
01:05:42 <shachaf> basdirks: Hmm, note that this might inefficient.
01:06:33 <basdirks> much worse than Prelude.concat [String]?
01:06:38 <shachaf> basdirks: It's possible that e.g. Data.Foldable.foldr (++) [] would have better asymptotics.
01:06:48 <shachaf> Of course you're dealing with Strings anyway, so maybe who cares.
01:07:25 <basdirks> it's not a very performance critical task
01:07:32 <mm_freak> basdirks: F.concat should be fine…  it should be equivalent to concat . F.toList
01:07:53 <shachaf> mm_freak: It's not.
01:08:02 <shachaf> Well, the final value is.
01:08:16 <shachaf> But it'll give you a tree shape, e.g. (a ++ b) ++ (c ++ d)
01:08:21 <shachaf> Rather than a ++ (b ++ (c ++ d))
01:08:58 <mm_freak> indeed…  so i recommend concat . F.toList
01:09:09 <glguy> is it my turn to jump in and tell someone he's wrong yet?
01:09:35 <glguy> (not picking on anyone in particular)
01:10:00 <shachaf> hi glguy
01:10:04 <shachaf> how are monoids
01:10:20 <glguy> practically unusable
01:10:25 <SamanthaD> glguy: Oh oh! me! I'm wrong!
01:10:34 <Nereid> what's wrong with monoids?
01:10:36 <shachaf> SamanthaD: Wrong! You're not wrong.
01:10:42 <shachaf> Nereid: Nothing!
01:10:44 <mm_freak> great <> superb <> perfect <> sensible <> …
01:10:44 <shachaf> They're easy.
01:10:46 <Nereid> I know.
01:10:52 <shachaf> so easy
01:11:13 <SamanthaD> I just finished my first real program in Haskell that I designed myself and executed from start to finish and has IO and everything!
01:11:15 <Nereid> I want hot dogs.
01:11:34 <glguy> I think hackage has those, now.
01:11:52 <Nereid> what doesn't hackage have?
01:11:59 <shachaf> SamanthaD: *Everything*?
01:12:03 <shachaf> That's pretty good.
01:12:09 <shachaf> My programs only have some things.
01:12:18 <glguy> i'll say!
01:12:28 <SamanthaD> I'm kinda lukewarm about it. It's a systems programming script that has a lot of IO in it. It's about 50 LOC of functional goodies followed by about 150 LOC of what looks like butchered Sh
01:12:33 <mm_freak> well, that makes SamanthaD indeed wrong =)
01:12:42 <SamanthaD> shachaf: I meant... it has IO and logic and it works!
01:12:44 <ijp> https://gist.github.com/4654081
01:12:52 <mm_freak> glguy: you have your target…  ready, set, go!
01:12:53 <shachaf> SamanthaD: Haskell logic is awful.
01:12:56 <ijp> How can I assert that xs, and succ xs have the same type there?
01:12:57 <shachaf> You can always prove ⊥.
01:12:58 <SamanthaD> shachaf: I can run it in something other than GHCi
01:13:14 <Nereid> what does it mean to prove ⊥?
01:13:24 <shachaf> ijp: What does it mean to assert that?
01:13:25 <frerich> SamanthaD: And now you pipe it through the #haskell lint checker and you'll end up with  45 lines of pure functions and 8 lines of IO code.
01:13:37 <shachaf> Oh, you're doing a rank-2 thing.
01:13:42 <mm_freak> ijp: you don't have to…  it's guaranteed by the type system
01:13:54 <mm_freak> if you refer to the same 'xs' in both cases
01:13:56 <ijp> mm_freak: it makes more sense if you look
01:14:08 <glguy> Oh, snap!
01:14:15 * glguy might need sleep...
01:14:16 <mm_freak> :t succ
01:14:18 <lambdabot> Enum a => a -> a
01:14:33 <ijp> pretend I wrote sukk instead of succ
01:14:46 <hpaste> SamanthaD pasted “Disk Image Creator” at http://hpaste.org/81409
01:14:54 <mm_freak> ijp: the easiest way is to put them in a list
01:15:04 <mm_freak> > ["blah", length "blah"]
01:15:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
01:15:06 <lambdabot>              with actual ty...
01:15:10 <ijp> I'm trying to explain the predecessor function for the lambda calculus, and so I wanted to have some runable haskell code that someone could paste in and check
01:15:10 <mSSM> Can someone recommend me a package providing a three dimensional, mutable vector/array ?
01:15:17 <glguy> mm_freak: impredicative types?
01:15:35 <shachaf> ijp: Rank-2 types make life hard.
01:15:51 <shachaf> You have impredicativity and all sorts of things going on there.
01:15:52 <merijn_> shachaf: Or easy, if you can't write your code otherwise :p
01:15:54 <mm_freak> glguy: you would need to write an explicit type signature in that case
01:15:55 <ijp> the easy way is to scrap the haskell and rewrite in scheme ;)
01:15:57 <Nereid> mSSM: the only thing I can think of for that is array.
01:16:02 <mm_freak> > ["blah", length "blah"] :: [forall a. a]
01:16:03 <shachaf> ijp: You could make a newtype for Church numbers.
01:16:04 <lambdabot>   Couldn't match type `a' with `[GHC.Types.Char]'
01:16:04 <lambdabot>    `a' is a rigid type vari...
01:16:10 <Nereid> vector is 1-dimensional, repa is immutable, ...
01:16:21 <merijn_> > [] :: [forall a. a]
01:16:23 <lambdabot>   No instance for (GHC.Show.Show (forall a. a))
01:16:23 <lambdabot>    arising from a use of `M11...
01:16:31 <shachaf> Nereid: Array? How quaint!
01:16:32 <merijn_> oh, hah
01:17:16 <mSSM> Nereid: I saw nested vectors like fromList [ fromList [1 .. x] | x <- [1..10] ], but that doesn't seem nice.
01:17:22 <Nereid> quite.
01:17:24 <mm_freak> glguy: i don't see how you could apply impredicative types here
01:17:35 <Nereid> I'd rather use a flat vector and some reindexing function.
01:17:37 <mm_freak> > Just undefined :: Maybe (forall a. a)
01:17:38 <lambdabot>   No instance for (GHC.Show.Show (forall a. a))
01:17:38 <lambdabot>    arising from a use of `M10...
01:17:46 <mm_freak> > Just undefined :: Maybe (forall a. (Show a) => a)
01:17:48 <frerich> SamanthaD : A few random remarks: you can probably replace "isHead" with "isPrefixOf" and "contains" with "elem".
01:17:48 <lambdabot>   No instance for (GHC.Show.Show (forall a. GHC.Show.Show a => a))
01:17:48 <lambdabot>    arising...
01:17:55 <mSSM> Nereid: Yeah, that would be the alternative.
01:17:57 <glguy> mm_freak: I thought they came up when you tried to make a link of rank-2 stuff
01:18:04 <mSSM> Mapping a 3D object onto a 1D representation :D
01:18:15 <Nereid> it's all 1D in memory anyway.
01:18:22 <mm_freak> > const () (Just undefined :: Maybe (forall a. a))
01:18:24 <lambdabot>   ()
01:18:29 <SamanthaD> frerich: Yeah... I noticed that halfway though my coding but I decided to just leave them in because I'd already done a couple hours of testing that I'd have to re-do if I changed it.
01:18:31 <mSSM> hMatrix provides a mutable 2D structure.
01:18:34 <mm_freak> > const () (Just "x" :: Maybe (forall a. a))
01:18:36 <lambdabot>   Couldn't match expected type `forall a. a'
01:18:36 <lambdabot>              with actual type `[...
01:18:40 <Nereid> oh yeah, hmatrix is the other one.
01:18:42 <mm_freak> impredicative types doesn't allow that
01:18:45 <Nereid> but only 1D.
01:18:47 <`ramses> SamanthaD: are you aware that linux might actually change the (partition -> dev node) mapping? /dev/sda might not always be what you think it is
01:18:48 <Nereid> er 2D.
01:19:16 <`ramses> SamanthaD: you should use labels, paths or uids to point to specific partitions
01:19:17 <mm_freak> SamanthaD: meet HUnit =)
01:19:18 <mSSM> It's a shame it's so hard to do numerics on a grid in haskell.
01:19:24 <mSSM> I.e., a mutable grid.
01:19:35 <mm_freak> SamanthaD: perhaps in combination with test-framework
01:19:47 <mm_freak> then to test you just call the tests
01:19:57 <shachaf> ijp: E.g. http://hpaste.org/81411
01:19:58 <frerich> SamanthaD : Another thing which can yield some eye-openers: try running 'hlint' on your code.
01:20:18 <hpaste> glguy pasted “what i was thinking about” at http://hpaste.org/81412
01:20:25 <glguy> mm_freak: That's just what I was thinking about
01:20:36 <SamanthaD> `ramses: Hmm... yeah, you're right. By the way, this program is meant to run on a computer that I set up for a friend of mine but the computer is currently several hundred miles away and she's scared of the command line. So... I write 200LOC so she doesn't have to figure out three lines of Bash. I think she's spoiled.
01:21:09 <shachaf> SamanthaD: Why not write thre lines of bash instead?
01:21:12 <earthy> you're spoiling the friend yourself.
01:21:27 <osa1> does record polymorphism in this page http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/1.0/en/Ch4.S2.xhtml related with row polymorphism ? where can I learn more about those ?
01:21:27 <`ramses> SamanthaD: if you're program writes to the wrong disk, you'll have to write a lot more code to fix it ;)
01:21:34 <`ramses> s/disk/partition
01:21:46 <mm_freak> glguy: oh, so i was answering a different question =)
01:21:48 <Nereid> oh man.
01:21:52 <SamanthaD> `ramses: Point taken. I'll change it then ;)
01:21:53 <Nereid> SamanthaD: you should have a look at the shelly package
01:22:05 <mm_freak> glguy: you can put things into a list to assert that they have the same type
01:22:17 <Nereid> also, don't use error in IO
01:22:23 <shachaf> osa1: You might read http://blog.ezyang.com/2012/04/how-urweb-records-work-and-what-it-might-mean-for-haskell/
01:22:27 <glguy> mm_freak: in this case they'd just both have the same type you didn't want, right?
01:22:40 <`ramses> SamanthaD: I've been bitten hard by that once, a server at work suddenly wouldn't boot after update... So it can really happen, although not very common
01:22:50 <Nereid> or maybe it's fine?
01:22:51 <Nereid> hmm
01:22:57 <mm_freak> glguy: the original question was, "how can i assert that x and succ x have the same type?"
01:22:59 <SamanthaD> shachaf: Well... if I did a shell script I'd still need a good amount of logic. I know her computer pretty well but not well enough to do it without logic to figure out things like exactly which drive needs to be written to.
01:23:15 <SamanthaD> Nereid: I will, thanks!
01:23:20 <mm_freak> > let _ = [x, succ x] in "They have the same type"
01:23:22 <lambdabot>   "They have the same type"
01:23:29 <mm_freak> > let _ = [x, length x] in "They have the same type"
01:23:31 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
01:23:31 <lambdabot>              w...
01:23:46 <glguy> mm_freak: OK. I wasn't sure if you looked at the paste before you wrote that. Doesn't really matter to me :)
01:23:47 <ijp> shachaf: thanks, I'll give it a look
01:23:52 <shachaf> mm_freak: This isn't that succ.
01:24:02 <shachaf> Did you look at the code?
01:24:23 <SamanthaD> `ramses: When I was writing this I was going by the assumption that Linux wouldn't re-map the drives between boots. See, the getUSB function takes the difference of /dev between two points where the user is instructed to plug in the drive to be used.
01:24:56 <mm_freak> shachaf: i didn't really notice any pastes to be honest
01:25:24 <Nereid> mm_freak: https://gist.github.com/4654081
01:26:11 <glguy> goodnight!
01:26:31 <mm_freak> does the question change in that context?
01:26:35 <SamanthaD> Is the general structure of the program decent, though, considering what it needs to do or am I butchering the language?
01:26:40 <Nereid> mm_freak: it's a rank-2 type
01:27:36 <`ramses> SamanthaD: ha, I didn't read all that :) The USB part is probably fine then, I was merely saying that the check to avoid overwriting the system partition was possibly not really preventing breakage
01:28:37 <SamanthaD> `ramses: Indeed. I completely agree with you. It's not there for any real practical purposes. It's there because `dd if=... of=/dev/sda` gives me a cold sweat!
01:28:57 <mm_freak> > let zero :: (a -> a) -> (a -> a); zero = undefined; succ :: (forall a. (a -> a) -> (a -> a)) -> (a -> a) -> (a -> a); succ = undefined in const () [zero, succ zero]
01:28:58 <`ramses> ah, okay, in that case it suffices ;)
01:28:59 <lambdabot>   ()
01:29:06 <mm_freak> Nereid: my suggestion still works
01:29:21 <Nereid> I didn't really notice your suggestion to be honest
01:29:27 <ijp> shachaf: I had tried something similar earlier, but seeing your code pointed out the mistake I had made. Thanks.
01:29:54 <mm_freak> Nereid: that one:  to assert that two things have the same type, put them in a list
01:30:12 <shachaf> ijp: It's also possible to write this program using rank-2 types directly.
01:30:14 <Nereid> or feed them to asTypeOf
01:30:17 <shachaf> ijp: But there'll be some trickiness.
01:30:21 <mm_freak> :t let zero :: (a -> a) -> (a -> a); zero = undefined; succ :: (forall a. (a -> a) -> (a -> a)) -> (a -> a) -> (a -> a); succ = undefined in [zero, succ zero]
01:30:23 <lambdabot> [(a -> a) -> a -> a]
01:31:32 <mm_freak> :t let zero :: (a -> a) -> (a -> a); zero = undefined; succ :: (forall a. (a -> a) -> (a -> a)) -> (a -> a) -> (a -> a); succ = undefined in [zero, succ zero] :: [forall a. (a -> a) -> (a -> a)]
01:31:33 <lambdabot>     Illegal polymorphic or qualified type: forall a. (a -> a) -> a -> a
01:31:33 <lambdabot>     Perhaps you intended to use -XImpredicativeTypes
01:31:33 <lambdabot>     In an expression type signature: [forall a. (a -> a) -> (a -> a)]
01:31:46 <mm_freak> oh, lambdabot doesn't have it
01:32:04 <shachaf> GHC doesn't have it either.
01:32:12 <shachaf> It just pretends.
01:32:51 <mm_freak> just checked…  it works with -XImpredicativeTypes
01:32:54 <mm_freak> shachaf: what do you mean?
01:33:08 <shachaf> GHC's impredicative type support is not very good.
01:33:25 <shachaf> Whether a particular thing works or doesn't work tends to change between versions.
01:34:00 <mm_freak> i've never used it…  somehow impredicative types just don't feel right to me
01:34:37 <mm_freak> i love RankNTypes though =)
01:34:41 <ijp> I think going with the newtype is the best solution for now
01:34:46 <ijp> thanks for your help
01:37:48 <SamanthaD> hlint opened my eyes... Control.Monad would have removed a LOT of that code!
01:44:56 <basdirks> I want this type [Either Int String] for which I want a function f x xs = (wrap x) : xs, so that I can write f 2 [Left 3, Right "cake"] == [Left 2, Left 3, Right "cake"]. Am I dreaming?
01:45:50 <basdirks> basically I want to avoid having to write Left/Right every time I want to do an operation on this type
01:46:26 <shachaf> I'm not sure what f is supposed to do.
01:46:39 <shachaf> What's f 2 [Left 3, Right 4]?
01:46:57 <quicksilver> basdirks: and presumably you also want to be able to write f "bar" to get it to prepend a Right "bar"
01:47:11 <basdirks> yes, but I think I'm just bs'ing
01:47:19 <quicksilver> it's easy enough
01:48:02 <quicksilver> class WrapIntoEither x where wrap :: x -> Either Int String; instance WrapIntoEither Int where wrap = Left; instance WrapIntoEither String where wrap = Right; -- requires FlexibleInstances and TypeSynonymInstances
01:48:31 <quicksilver> then f :: WrapIntoEither x => x -> [Either Int String] -> [Either Int String]; f x xs = wrap x : xs;
01:49:10 <shachaf> You can do that if you're willing to fix everything to String and Int.
01:49:25 <shachaf> I assumed basdirks wanted a more general solution (which I would hope would be impossible).
01:49:42 <quicksilver> I have a feeling basdirks missed it anyway, since that's him reconnecting.
01:49:42 <shachaf> Anyway, what quicksilver said would work, but I'm not sure it's a good idea.
01:49:48 <shachaf> True.
01:49:54 <b__> I saw it yeah
01:50:07 <b__> it might do what I want
01:51:58 <b__> shachaf: if a more general solution is possible, then it sorta seems to beat the purpose of having a type system
01:52:10 <quicksilver> overloaded cons-type operations are quite reasonable
01:52:17 <quicksilver> lots of DSL use them
01:59:04 <b__> hm pretty neat, thanks
01:59:21 <b__> works perfectly for this usecase
02:00:11 <kqr> is there a way to make a type like `MyType [a]' but that will also accept `MyType (a -> b)' (I have a `MyType [a]' but I think I want to make it into an applicative, which would sort of require it to also be `MyType (a -> b)')
02:00:59 <shachaf> It sounds to me like you're confused.
02:01:06 <shachaf> I recommend giving more context.
02:01:11 <kqr> i use it to sort of keep a bunch of information as a single value, where the bunch of information only makes sense as a list. on the other hand, it would be neat to be able to sequence operations if it was an applicative
02:01:37 <kqr> what it essentially boils down to is that I'm playing around to see if I can implement something similar to perls junctions
02:02:02 <kqr> perl supports a construct that looks somewhat like any(2, 3, 4) and all(7, 6, 5) which are values representing any or all of the enclosed values
02:02:33 * typoclass mumbles something about the list monad
02:02:56 <kqr> while I don't see any particular use for it, they look very cool
02:03:15 <kqr> and my thought was to represent them as `data Junction a = Any [a] | All [a]'
02:04:27 <kqr> but then I miss out on applicative, which I thought would be neat to do things like `Any [5, 4, 3] * All [1, 2, 3] == Any [All [5, 10, 15], All [4, 8, 12], All [3, 6, 9]]'
02:04:36 <kqr> (but with a different syntax, of course)
02:05:40 <kqr> (i could of course do that by declaring Junction an instance of Num if a is an instance of Num, but that sounds like a lot of work)
02:05:53 <Eelis> kqr: i'd start by just using regular lists and existing functions like all/any, because i'm not sure what these junctions buy you
02:06:09 <kqr> Eelis, oh, they don't buy me jack shit
02:06:13 <Eelis> oh ok :P
02:06:31 <kqr> Eelis, i just think the concept is really cool and i would like to see if its possible to implement them reasonably easy :)
02:06:44 <Eelis> why do you think they're cool if they're useless?
02:06:49 <kqr> i like useless things.
02:06:54 <Eelis> ok :)
02:07:13 <kqr> no, but in all seriousness its mostly to expand my haskell knowledge
02:07:18 <Eelis> fair enough
02:07:44 <kqr> as soon as i saw them i thought "hey, those are pretty much data types" and i want to confirm/deny that
02:07:54 <Eelis> makes sense
02:08:02 <Eelis> they're even called data types in the manual
02:09:06 <mm_freak> kqr: perhaps you want the list monad and/or the ziplist functor
02:09:48 <mm_freak> for the ziplist functor you can either use ZipList or construct the applicative combinators yourself
02:09:52 <mm_freak> pure = repeat
02:09:54 <typoclass> kqr: i think some of what you're saying would probably be done via the so-called list monad. check out this http://learnyouahaskell.com/a-fistful-of-monads#the-list-monad
02:09:57 <mm_freak> (<*>) = zipWith ($)
02:10:18 <typoclass> (this should help with the "any" part)
02:11:03 <kqr> mm_freak, what type does <*> have for ZipList?
02:11:20 <mm_freak> kqr: ZipList (a -> b) -> (ZipList a -> ZipList b)
02:11:58 <kqr> mm_freak, hm
02:12:22 <mm_freak> kqr: but you can get along without the ZipList wrapper
02:12:36 <mm_freak> it's often much more convenient to use simple list functions
02:12:55 <mm_freak> > let zapp = zipWith ($) in repeat (*) `zapp` [2, 3, 4] `zapp` [10, 100, 1000]
02:12:57 <lambdabot>   [20,300,4000]
02:15:22 <mm_freak> kqr: in many cases it's even much easier just to use zipWith
02:15:38 <mm_freak> > liftA2 (zipWith (\xs ys -> xs ++ 'x':ys)) inits tails "abc"
02:15:40 <lambdabot>   ["xabc","axbc","abxc","abcx"]
02:16:14 <quicksilver> I don't think zipwith/ziplist has anything to do with Any/All.
02:16:17 <mm_freak> zipWith corresponds to liftA2 for ZipLists
02:16:57 <kqr> mm_freak, how can there be a ZipList (a -> b) when the constructor for ZipList a has the type ZipList [a]?
02:17:02 <mm_freak> i don't know perl, but it sounded like monadic and applicative lists could be a solution
02:17:22 <mm_freak> kqr: it doesn't have the type ZipList [a]
02:17:29 <mm_freak> ZipList :: [a] -> ZipList a
02:17:35 <kqr> oh
02:17:50 <mm_freak> :t zipWith ($)
02:17:51 <lambdabot> [b -> c] -> [b] -> [c]
02:18:35 <mm_freak> btw, i propose to add liftA* to the Applicative class
02:19:08 <mm_freak> liftA* can often have a much more efficient implementation than the default in terms of (<*>)
02:19:20 <kqr> mm_freak, but when they deconstruct it with (ZipList fs), isn't fs :: [a -> b] ?
02:19:30 <mm_freak> kqr: yes
02:19:51 <mm_freak> ZipList fs <*> ZipList xs = ZipList (zipWith ($) fs xs)
02:19:57 <kqr> mm_freak, so (ZipList fs) :: Ziplist [a -> b]
02:20:01 <kqr> mm_freak, or am I missing something?
02:20:06 <mm_freak> nope, that's correct
02:20:27 <mm_freak> ZipList :: [a] -> ZipList a
02:20:30 <kqr> right
02:20:32 <kqr> i'm with you
02:20:32 <mm_freak> fs :: [a -> b]
02:20:40 <mm_freak> ZipList fs :: ZipList (a -> b)
02:21:14 <osa1> does anyone here remember pottier's "modern eye on ml type inference" paper ? did he published last 2 chapters of it ?
02:22:39 <mm_freak> kqr: could you give an example of where perl's any/all can express something very concisely?  preferably a simple example i can understand =)
02:22:43 <mm_freak> feel free to use perl syntax
02:23:02 <kqr> mm_freak, no, because i'm not sure it even exists
02:23:11 <kqr> mm_freak, it's just an experiment for myself to learn how haskell works
02:23:24 <mm_freak> i see
02:23:41 <merijn> kqr: I'm not even sure I understand what they're supposed to do, which makes it hard to suggest how to accomplish that...
02:23:45 <quicksilver> mm_freak: http://en.wikibooks.org/wiki/Perl_6_Programming/Junctions
02:23:57 <kqr> mm_freak, by the way, if <*> :: ZipList (a -> b) -> (ZipList a -> ZipList b)
02:24:07 <kqr> mm_freak, how can it accept ZipList [a -> b] as the first argument?
02:24:57 <merijn> kqr: It doesn't, why do you think it does?
02:25:32 <kqr>  11:19:42        kqr | mm_freak, so (ZipList fs) :: Ziplist [a -> b]
02:25:33 <kqr>  11:19:46        kqr | mm_freak, or am I missing something?
02:25:35 <kqr>  11:19:51   mm_freak | nope, that's correct
02:25:37 <kqr> that seemed like it
02:26:04 <mm_freak> kqr: it seems like junctions are really just applications of 'elem'
02:26:32 <mm_freak> kqr: oh, my bad
02:26:41 <mm_freak> ZipList fs :: ZipList (a -> b)
02:26:54 <kqr> not just. they can be used as any regular value and they produce somewhat consistent results under multiplication, string concatenation or whatever
02:26:58 <mm_freak> did i actually write that?
02:27:18 <kqr> basically you can just set up a bunch of requirements and then treat them as a single value for the rest of your program
02:27:26 <kqr> or a bunch of options or whatever
02:27:53 <kqr> it is probably much easier and more readable to accomplish using good old lists, but i'm not doing this because it's particularly useful
02:28:04 <mm_freak> kqr: i take back the "that's correct"…  i misread your type
02:28:32 <mm_freak> kqr: anyway, that sounds a lot like simple list operations to me
02:28:54 <mm_freak> in some cases even list-monadic operations
02:29:12 <mm_freak> > do x <- [1..10]; let y = x^2 + 1; return (x, y)
02:29:14 <lambdabot>   <hint>:1:48: parse error (possibly incorrect indentation)
02:29:21 <mm_freak> > do x <- [1..10]; let { y = x^2 + 1 }; return (x, y)
02:29:22 <lambdabot>   [(1,2),(2,5),(3,10),(4,17),(5,26),(6,37),(7,50),(8,65),(9,82),(10,101)]
02:29:42 <kqr> hm
02:30:37 <mm_freak> the 'x' represents all the values in [1..10] there
02:30:42 <kqr> yeah i know
02:32:16 <kqr> Any [5, 4, 3] * All [1, 2, 3] == Any [All [5, 10, 15], All [4, 8, 12], All [3, 6, 9]]
02:32:23 <kqr> you lose context if you try doing something like that though
02:32:25 <kqr> don't you?
02:33:13 <kqr> but perhaps that's a stupid operation anyway, because it isn't commutative
02:34:09 <mm_freak> i don't understand the operation TBH
02:34:18 <mm_freak> > liftA2 (*) [5,4,3] [1,2,3]
02:34:20 <lambdabot>   [5,10,15,4,8,12,3,6,9]
02:34:50 <mm_freak> you give up structure with that one
02:34:51 <merijn> mm_freak: It applies the * to all of the All's and one of the any's and then repeats that separately for each of the Any's
02:35:43 <kqr> mm_freak, multiplication of two junctions is well-defined and results in a junction of junctions, or so to speak
02:35:44 <mm_freak> it that's well-defined, ok, but i don't see it…  it doesn't seem to be an associative operation
02:36:16 <mm_freak> non-commutativity is fine to me, but non-associativity isn't
02:36:47 <merijn> mm_freak: That's why you write haskell and not perl :)
02:36:52 <mm_freak> =)
02:36:59 <mm_freak> true
02:39:29 <merijn> I might have a stab at implementing this after lunch...
02:40:40 <mm_freak> (^*^) :: (Num a) => Junction a -> Junction a -> Junction (Junction a)
02:41:24 <mm_freak> it seems to be a matter of constructor selection…  in particular, i don't see the value
02:41:44 <mm_freak> All [5,4,3] ^*^ Any [1,2,3] = ?
02:41:54 <merijn> The main problem seems to be that you'd want to generalise Junctions to aribtrary operations, which is a bit hard to do sensibly
02:41:56 <mm_freak> All [5,4,3] ^*^ All [1,2,3] = ?
02:42:19 <mm_freak> i think the whole concept is ad hoc and doesn't make much sense
02:42:20 <merijn> As there's no "function application"-typeclass to overload :p
02:42:45 <merijn> mm_freak: Pfft, that just means you'd make a terrible Lua/Python/Ruby programmer :)
02:42:54 <mm_freak> + perl
02:42:55 <mm_freak> and yes
02:43:17 <merijn> Oh!
02:43:18 <mm_freak> i'm a terrible programmer in most imperative languages…  i tend to haskellize them first before even starting to write code =)
02:43:19 <merijn> Arrows!
02:44:01 <mm_freak> about two years back i implemented iteratees in PHP
02:44:12 <merijn> You just need a way to lift arbitrary functions from "a -> b -> c" to "Junction a -> Junction b -> Junction (Junction c)"
02:44:17 <mm_freak> with some internal hacks to make this somewhat efficient
02:44:32 <merijn> And maybe a nice way to wrap "Junction (Junction a)" to look like "Junction a"
02:44:51 <mm_freak> data Junction a = One a | Any (Junction a)
02:45:21 <merijn> Anyhoo, lunch
02:45:26 <merijn> I'll look into it after that
02:45:35 <tdammers> yay lunch
02:45:40 <mm_freak> that's an applicative functor, but it's really just the tree monad
02:45:49 <mm_freak> where binding means leaf substitution
02:46:33 <mm_freak> uhm, wait
02:46:39 <mm_freak> data Junction a = One a | Any [Junction a]
02:46:40 <mm_freak> there we go
02:48:22 <Hafydd> Don't One x and Any [One x] represent the same thing?
02:48:39 <mm_freak> nope
02:48:45 <mm_freak> liftA2 (*) (Any [One 5, One 4, One 3]) (Any [One 1, One 2, One 3]) = Any [Any [One 5, One 10, One 15], Any [One 4, One 8, One 12], Any [One 3, One 6, One 9]]
02:57:13 <hpaste> “Ertugrul Söylemez” pasted “Junk” at http://hpaste.org/81416
02:57:22 <mm_freak> that's my version of perl junctions =)
02:58:06 <frerich> So, is it intentional that you called it 'Junk' instead of 'Junc'? :)
02:58:16 <mm_freak> oh, did i? =P
02:58:29 <frerich> ;-)
02:59:13 <mm_freak> anyway, that one is basically just a simple tree type and allows structure-preserving combinations
02:59:23 <mm_freak> just run it
03:00:18 <mm_freak> you can actually define a Num instance for it
03:00:45 <mm_freak> a sensible one even…  you just have to be careful about how to implement signum
03:13:58 <merijn> Bah
03:14:10 <merijn> I need type level lambda's for my ugly junction hack :(
03:14:36 <merijn> I want to define "\a b -> Junction a -> Junction b" as a type :\
03:15:57 <merijn> Time to implement "On (a :: * -> *) :: * -> * -> *" :p
03:17:04 <merijn> newtype On a f x y = On { getOn :: a (f x) (f y) }
03:33:12 <merijn> There's no way to write a type that matches "any non-function type", right?
03:33:28 <shachaf> cmccann had a type inequality thing.
03:33:33 <shachaf> Maybe you could adapt it for that.
03:33:38 <shachaf> But it's probably a bad idea.
03:33:59 <merijn> shachaf: I'm implementing something that's a terrible idea, regardless of how it is implemented :)
03:34:20 <merijn> Like...acme-php bad :p
03:34:30 <shachaf> That's pretty bad.
03:34:37 <merijn> I don't think the bad ideaness of type inequality well be an issue :p
03:34:43 <merijn> s/well/will
03:38:18 <merijn> shachaf: Any pointers where I could find that?
03:38:50 <shachaf> @google cmccann type inequality
03:38:51 <lambdabot> http://contemplatecode.blogspot.com/
03:38:54 <shachaf> Hmm.
03:39:17 <shachaf> http://stackoverflow.com/questions/6939043/is-it-possible-to-place-inequality-constraints-on-haskell-type-variables
03:39:19 <shachaf> Also
03:39:21 <shachaf> @google unsaferCoerce
03:39:23 <lambdabot> http://hpaste.org/56741
03:39:23 <lambdabot> Title: unsaferCoerce :: hpaste — Haskell Pastebin
03:42:09 <merijn> Oh, bollocks that won't safe me, I think...
03:42:17 <merijn> s/safe/save
03:42:23 <merijn> I can't have contraints on type funs, right?
03:44:39 <merijn> Why do those family declarations require a ()?
03:44:42 <merijn> eh
03:44:45 <merijn> class declarations
03:46:44 <merijn> Basically, I'm trying to define a type fun on functions, but I need a termination condition for my recursion (which is basically "when a non function type is found")
04:00:37 <wuttf> If I want to parse a String or Text which may contain an Int, Float, or Bool, falling back on String (or Text) if neither is present, how should I approach that?
04:01:06 <shachaf> Check what it contains, then use a parser for that?
04:01:59 <quchen> Why is the inner forall needed in the type signature of 'build'? Why wouldn't a global 'forall a b.' do?  (  build :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]  )
04:02:44 <shachaf> The question is who gets to choose what b is.
04:03:05 <shachaf> If it was "forall a b.", that would mean that the caller gets to choose both a and b.
04:03:19 <shachaf> But with the "forall b." on the inside, that means *build* gets to choose what "b" is.
04:03:34 <shachaf> So you have to provide a function which works for absolutely any b.
04:03:50 <t7> is there an editor written in haskell ?
04:03:58 <quchen> t7: Leksah
04:04:02 <tdammers> wuttf: assuming parsec, sth like value = try float <|> try integer <|> try boolean <|> try string
04:05:08 <quchen> shachaf: What's the difference between the caller and build choosing b? With 'forall a b.', shouldn't build work for "absolutely any" b too?
04:05:27 <tdammers> just try each parser until one of them succeeds
04:06:01 <shachaf> quchen: build gets to pick b here, though.
04:06:16 <shachaf> quchen: Are you familiar with rank-2 types (nested foralls) in general?
04:06:16 <wuttf> tdammers: parsec looks biiig
04:07:16 <quchen> shachaf: No, not at all. I've only seen runST so far.
04:07:23 <t7> maybe i should start work on a generic AST editor
04:07:35 <quchen> Nested foralls are called rank-2 types?
04:07:43 <shachaf> Ah, OK. Then this might be confusing. :-)
04:07:46 <shachaf> Yes.
04:08:00 <tdammers> wuttf: hmm, I assumed you were already using parsec
04:08:03 <shachaf> (Well, they're called a bunch of things. But very often rank-2, or rank-n if they're nested more deeply.)
04:08:20 <shachaf> quchen: Let's take a simpler example.
04:08:27 <quchen> forall a. (forall b. (forall c. a -> b -> c))) = rank 3? Makes sense
04:08:34 <shachaf> No, that's still rank-2
04:08:37 <wuttf> tdammers: Not (newbie here)
04:08:39 <shachaf> Hmm, no, it's rank-1
04:08:43 <shachaf> That's just a regular type.
04:08:52 <shachaf> They have to be nested in the right place. :-)
04:09:04 <shachaf> quchen: Someone asked me today how I'd explain this, so let's see how I do!
04:09:04 <quchen> forall a. (forall b. (forall c. c) -> b) -> a) = rank 3? Makes sense
04:09:20 <quchen> Anyway, I should listen to your simpler example now.
04:09:26 <b__> quicksilver: is this pattern of wrapping a type like Either into a class packaged or generalized somewhere? just curious
04:09:30 <shachaf> Sure.
04:09:47 <tdammers> well, parsec is in haskell-platforn, so unless you're bound to serious constraints, I'd look into it
04:09:48 <shachaf> Let's define a kind of silly function.
04:10:10 <shachaf> foo f = (f 'a', f 'b')
04:10:27 <shachaf> What's the type of foo?
04:10:56 <`ramses> wuttf: http://book.realworldhaskell.org/read/using-parsec.html after reading that, parsec wasn't that difficult to start working with
04:11:36 <quchen> foo :: (Char -> a) -> (a, a)
04:11:38 <quchen> ?
04:11:46 <tdammers> just look out, RWH uses a rather old version of parsec (2, IIRC), there has been quite some API rewriting going on
04:11:56 <merijn> quchen: More specificall "forall a . (Char -> a) -> (a, a)"
04:12:04 <shachaf> quchen: Yep.
04:12:14 <shachaf> > let foo f = (f 'a', f 'b') in foo id
04:12:15 <lambdabot>   ('a','b')
04:12:23 <shachaf> So this is pretty simple.
04:12:33 <shachaf> We can also say let foo f = (f False, f True)
04:12:44 <shachaf> And then it has type (Bool -> a) -> (a, a)
04:12:47 <shachaf> Right?
04:12:49 <wuttf> `ramses: Ohh, thanks, I forgot about that chapter.
04:12:50 <t7> @hoogle Int -> a -> [a]
04:12:51 <lambdabot> Prelude replicate :: Int -> a -> [a]
04:12:51 <lambdabot> Data.List replicate :: Int -> a -> [a]
04:12:51 <lambdabot> Prelude drop :: Int -> [a] -> [a]
04:13:02 <quchen> Type error, no char
04:13:09 <quicksilver> b__: no. I wouldn't describe it that way.
04:13:15 <merijn> quchen: He's defining a new foo
04:13:18 <shachaf> quchen: Er, this is a different foo.
04:13:20 <shachaf> Sorry.
04:13:20 <b__> quicksilver: ok
04:13:26 <shachaf> I should come up with a unique name supply.
04:13:27 <quchen> Oh. Pardon. Yes then.
04:13:28 <quchen> :-)
04:13:35 <quicksilver> b__: the only interesting thing I did is overload a function for two different ypes - that's what typeclasses are for ;)
04:13:39 <shachaf> quchen: But here's the thing.
04:13:41 <shachaf> We can't say
04:13:46 <shachaf> foo f = (f 'a', f True)
04:13:49 <quchen> :t let fooBool f = (f True, f False) in fooBool
04:13:50 <lambdabot> (Bool -> t) -> (t, t)
04:13:52 <shachaf> Because what's the type of f?
04:13:57 <b__> quicksilver: yeah but the wrapped pattern, though I guess our example is too specific
04:14:10 <quchen> Ah, I see.
04:14:30 <shachaf> Right?
04:14:36 <shachaf> So this is kind of a problem.
04:14:47 <shachaf> We can't say let foo f = (f 'a', f True) in foo id
04:14:53 <shachaf> But we *can* say (id 'a', id True)
04:14:59 <quchen> f has one parameter, namely Char or Bool. When f finds that fst is Bool, the type of f is set to "Bool -> a", but then it won't match the snd.
04:14:59 <shachaf> Because id is polymorphic enough to work for both.
04:15:17 <shachaf> Right. You can't give f a simple type that works for both of these.
04:15:40 <shachaf> But id *would* work here, right?
04:15:45 <quchen> Soo if f :: forall a. (forall b. b) -> a
04:15:52 <quchen> ..?
04:15:54 <shachaf> No, that type doesn't work.
04:16:07 <shachaf> The full type of id, though, is id :: forall a. a -> a
04:16:17 <quchen> Anyway, yes, id would work here, conceptually at least.
04:16:23 <shachaf> So if we just substitute that straight in, we might get
04:16:26 <quicksilver> b__: well, certainly data types like data Var = Num Int | Str String are pretty common
04:16:32 <shachaf> foo :: (forall a. a -> a) -> (Char, Bool)
04:16:37 <quicksilver> b__: if you're modelling a file format or a DSL
04:16:50 <shachaf> foo f = (f 'a', f True)
04:16:57 <quicksilver> b__: and an overloaded wrapper for quickly building up data types is an obvious idea.
04:17:05 <quicksilver> b__: but I'm not sure there is a name for it.
04:17:07 <shachaf> quchen: That type probably doesn't make much sense yet. :-)
04:17:12 <b__> quicksilver: it kinda reminds me of another concept I don't quite grasp: GADT's
04:17:31 <shachaf> quchen: What it's saying is: You pass some function "f" to foo. f has to have the type (a -> a).
04:17:36 <shachaf> But *foo* can choose what a is.
04:17:40 <merijn> b__: Oh, where do GADT's lose you?
04:17:42 <shachaf> So it can pick a = Char, and then use it on a Char.
04:17:48 <shachaf> And it can pick a = Bool, and then use it on a Bool.
04:18:03 <b__> merijn I know how to define them more or less, but I just haven't used them yet
04:18:10 <paolo> ciao
04:18:14 <shachaf> !list
04:18:15 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
04:18:17 <quchen> Aaah. "Foo can only pick once."
04:18:34 <shachaf> quchen: With the forall, foo can pick as many times as it likes.
04:18:42 <merijn> b__: Do you know the example of a a typed interpreter using GADTs?
04:18:45 <paolo> !list
04:18:47 <shachaf> Because you have to pass it a function that works "for all" "a"s.
04:18:57 <b__> merijn yeah
04:19:34 <b__> I've seen a short vid by someone with a German accent on them
04:19:44 <quchen> So the type would then be foo :: forall b. (forall a. a -> b) -> (b,b)?
04:19:50 <b__> but so far I've been able to dance around them
04:20:06 <b__> not that I don't want to learn them
04:20:15 <shachaf> quchen: No -- look at what foo has to return when you pass it id.
04:20:28 <shachaf> foo id = (id 'a', id True) = ('a', True) :: (Char, Bool)
04:20:45 <merijn> quchen: One example use I've personally had is a "receive" function that can receive records of different types, which means my functions needed to work with "forall a . Record a", because you can't know before hand what type of record you will receive
04:21:02 <shachaf> By the way I think my explanation isn't going to work.
04:21:17 <shachaf> There are better explanations around but they require some more introduction.
04:21:46 <merijn> Let me try a more applied example
04:21:55 * shachaf will let merijn take over, being tired and all.
04:22:33 <merijn> quchen: I have a Record datatype which can be either "Record Data" or "Record Control" (if you want to see the exact code: https://github.com/merijn/SNet2.0/blob/master/SNet/Types.hs)
04:22:38 <`ramses> it essentially all boils down to scoping of the foralls, doesn't it? I find it quite intuitive when viewed as a logical formula
04:22:38 <quchen> I kind of understand heterogeneous lists already. There, each element can pick its type, whereas in normal lists, the list picks the one type that can be present.
04:22:54 <paolo> come si fa avere la lisa
04:22:56 <quchen> merijn: Alright, go on :-)
04:23:19 * shachaf has the feeling all explanations are doomed.
04:23:27 <merijn> quchen: I'm wrapping these records and sending them over a Chan (readStream: https://github.com/merijn/SNet2.0/blob/master/SNet/Stream.hs)
04:23:31 <quchen> shachaf: Next I'll ask what a monad is. ;-P
04:23:48 <merijn> quchen: Of course, when I call readStream I can't know in advance what type of record I will get, right?
04:24:00 <b__> Monads are just Monoids in the category of endofunctors.
04:24:09 <quchen> b__: What's the problem?
04:24:13 <quchen> merijn: Gotcha.
04:24:19 <merijn> quchen: So the function I'm providing should work with *all* records, and I can't know which when I provide the function
04:24:28 <b__> quchen: precisely
04:24:29 <shachaf> quchen: This rank-2 thing is sort of completely obvious once you get it and very opaque until then.
04:24:35 <shachaf> But I'm not helping right now.
04:24:39 <shachaf> So I'll just be quiet.
04:25:09 <quchen> merijn: My solution to that problem would've been introducing a wrapper type with two constructors.
04:25:16 <merijn> quchen: Which is why the type in readStream says "(forall r . Record r -> m a)", i.e. my function can take *any* record and produce an "m a"
04:25:30 <quchen> shachaf: You helped already. You may be quiet, but you don't have to. :-)
04:25:36 <merijn> quchen: Sure, but I wanted to see if I could be typesafe
04:26:00 <merijn> quchen: i.e. I could have just done "data Record = Data {- stuff here -} | Control {- Stuff here -}"
04:26:35 <merijn> quchen: But I have some functions that *only* work on Data records and some function that *only* work on Control records. I wanted to statically guarantee that I never send the wrong record to the wrong function
04:27:29 <quchen> Ah, with two constructors you would need proper error handling of the type "readStuff | isStream1 = throw; | otherwise = ..."
04:27:35 <merijn> quchen: Yeah
04:27:46 <merijn> quchen: Whereas now you know the type checker won't let you mix them up
04:27:46 <quchen> Whereas your version ensures that errors are caught during compile time due to typechecking?
04:27:52 <quchen> Neat!
04:28:19 <merijn> quchen: imo, Rank2Types quickly become clear when you have to write code that won't work without them ;)
04:28:21 <quchen> I now desire to reach the place where "it's completely obvious and not opaque" shachaf talked about! :-D
04:28:33 <merijn> Without concrete code it's a bit tricky to grok what's going on
04:29:02 <quchen> merijn: Yes, I kind of understand the examples given, but not the general concept.
04:29:19 <quchen> As in "I wouldn't come up with using this myself on my own"
04:29:48 <merijn> quchen: If you want a nice example problem to toy with. Define a list type that encodes whether it is empty or not and then write functions that only work on empty lists, functions that only work on non-empty lists and function that work on both
04:30:15 <merijn> quchen: It took me two days of goofing around to get this stuff to work the first time :p
04:30:53 <shachaf> quchen: Really, if you learned Agda, it would be completely obvious to you.
04:31:04 <shachaf> But that's a bit too much overhead. :-)
04:31:10 <quchen> data List a = Empty | Nonempty a; data Nonempty a = Cons a (List a)
04:31:11 <quchen> ?
04:31:49 <shachaf> quchen: I think merijn means "a list whose type tells you whether it's empty or not".
04:31:54 <merijn> Yeah
04:32:24 <quchen> Hmm. My "List" above doesn't tell whether it's empty or nonempty.
04:32:32 <shachaf> Right.
04:32:34 <quchen> Nonempty says "I'm not empty". But nothing says "I'm empty".
04:32:47 <shachaf> Well, no, that's not what merijn meant, I think.
04:32:49 <shachaf> Oh, maybe it is.
04:33:07 <merijn> Think something like "data Empty; data NonEmpty; data List e a" such that you can use "List Empty Int" or "List NonEmpty Char"
04:33:35 <merijn> (Note, you don't need an implementation for Empty/NonEmpty. Just writing "data Empty" is sufficient)
04:33:53 <merijn> Which defines a type Empty with 0 constructors
04:34:02 <quchen> merijn: Dummy type?
04:34:12 <shachaf> quchen: An easy approach is data EmptyList = Nil; data NonEmpty = End a | Cons a (NonEmpty a)
04:34:12 <merijn> The common name is phantom type, but yes
04:34:23 <shachaf> But then writing a function that works for both of them is annoying.
04:34:31 <shachaf> merijn is unifying them here.
04:34:33 <quchen> merijn: Oh, that's a phantom type too. Greetings to all the GADT tutorials out there
04:34:38 <hpaste> johnw pasted “test.hs” at http://hpaste.org/81417
04:34:39 <merijn> I was thinking of the GADT approach
04:35:04 <johnw> can someone help me understand the type deduction error in that code?  line 61, cannot deduce (t ~ MyTree)
04:35:05 <merijn> quchen: This'd be an excellent scenario for toying with both GADTs and Rank2Types :)
04:35:29 * shachaf thinks that's too much toying for one scenario.
04:36:08 <merijn> Well, start with the GADT approach for implementing the list and defining functions that work on only empty or nonempty, then as next step add Rank2Types for functions that work on both
04:36:50 <shachaf> Those type classes make me sad. What can I do?
04:36:51 <quchen> merijn: Oh, so when I have the GADT, I can have functions that don't typecheck when I apply them to empty lists.
04:36:56 <quchen> i.e. head [] -> type error
04:37:42 <quchen> That works using GADTs alone, and to add functions that work on [] and nonempty lists I have to use Rank2Types?
04:39:14 <quicksilver> johnw: lookupTree and lgLookupTree do not have the same type.
04:39:21 <merijn> quchen: Well, simple functions that work on both you can define without Rank2Types (i.e. "newMap :: (a -> b) -> List e a -> List e b" works)
04:39:51 <quicksilver> johnw: lookupTree works (forall t . Tree t =>) so anyone who instances Repository must provide a lookupTree which works for all Trees t.
04:39:59 <merijn> quchen: But nesting these lists, for example a list of both empty and nonempty lists won't work without Rank2Types
04:40:07 <quicksilver> johnw: lgLookTree only works for one specific tree.
04:40:12 <hpaste> chreekat pasted “Repetitive instance definition” at http://hpaste.org/81418
04:40:22 <chreekat> ^ Is there an easier way to write that?
04:40:50 <shachaf> chreekat: When you have a type like that, not really.
04:40:51 <johnw> quicksilver: I'm not sure I fully understand
04:40:59 <quchen> merijn: Why can't I nest here? newMap specializes to :: (a -> List e b) -> List e a -> List e (List e b), doesn't it?
04:41:03 <shachaf> Well, you can use <> instead of mappend. :-)
04:41:17 <johnw> quicksilver: what does it mean for lookupTree to work "for all trees" and lgLookTree to work "for one specific tree"?
04:41:19 <chreekat> shachaf: heh, good point
04:41:36 <johnw> oh, wait, I see what you mean
04:41:42 <quicksilver> johnw: lgLookupTree is defined to work only the specific type MyTree
04:41:48 <johnw> lgLookupTree is trying to pin the user down to exactly one type of tree
04:41:50 <quchen> chreekat: You could map CC to a tuple and then mappend and rewrap those.
04:41:56 <johnw> ok, thanks quicksilver!
04:41:56 <quicksilver> johnw: Repository is a class of your own design?
04:42:00 <johnw> yes
04:42:04 <merijn> quchen: heh, newMap doesn't specialise to that, it's just mapping over a list of elements (which shouldn't change the emptiness or non-emptiness of the list)
04:42:08 <shachaf> chreekat: What happens to 8-14, by the way?
04:42:25 <quicksilver> perhaps you don't intend users of Repository to need to provide a function which works for all tree types?
04:42:27 <chreekat> shachaf: Is a type like that a smell? Or is it just reality for apps that have lots of little bits of state to pass between components
04:42:33 <quicksilver> perhaps you expect there will only be one tree type
04:42:44 <chreekat> shachaf: I was experimenting with HPaste for vim and didn't select the whole definition
04:42:46 <quicksilver> then you could extend the class so the tree type is part of the class too
04:42:50 <johnw> quicksilver: does that mean adding another type parameter to Repository?
04:42:53 <johnw> ok
04:42:56 <quicksilver> yes
04:42:57 <chreekat> Had I pasted it to the sit emanually there would have been an ellipsis at the end
04:42:58 <quicksilver> possibly with a fundep
04:43:16 <shachaf> chreekat: That type looks a little fishy to me, but who knows.
04:43:25 <merijn> quchen: "(a -> List e b) -> List e a -> List e (List e b)" works, *but* this means "a -> List e b" always produces empty lists when List e a is empty (which is pretty obvious), but it *also* means that "a -> List e b" *always* produces nonempty lists when "List e a" is non-empty
04:43:42 <merijn> quchen: But, just try it and hpaste your code when you get stuck? :p
04:43:52 <chreekat> Yeah, may be a bit of a vague question without context
04:44:07 <hpaste> quchen annotated “Repetitive instance definition” with “Tuples!” at http://hpaste.org/81418#a81419
04:44:27 <quchen> ^ workaround because the monoid tuple instances don't go to 14
04:44:40 <shachaf> 14 is a huge number.
04:45:12 <quchen> shachaf: I can't judge that, I haven't gone over pi in years
04:45:56 <chreekat> quchen: interesting, thanks
04:46:26 <quchen> merijn: I don't have time now for serious coding, but I'll start working on it later when I'm home. Got a text file with the problem statement already :-)
04:46:52 <shachaf> quchen: This is a big tangent from your original question.
04:46:56 <shachaf> But you'll learn something, certainly!
04:47:23 <quchen> shachaf: This feels like a problem you don't grasp by just asking questions. Like monads.
04:47:28 <quicksilver> shachaf: that pretty much sums it up for #haskell I think.
04:47:38 <quchen> Use them and they'll make sense. They'll make so much sense you're surprised about it.
04:48:47 <merijn> quchen: Yeah, the start is only tangential to your original question, but you'll learn something and it'll be a good starting point for continuing with Rank2Types and playing with that
04:49:12 <merijn> And you'll feel smart when you finally go "oooh!" and succesfully implement it ;)
04:50:00 <quchen> shachaf: Agda scares me so I'll push that into the future.
04:50:38 <quchen> Started learning Lisp 3 days ago already as you may remember.
04:50:41 <quchen> Now Rank2Types
04:50:48 <merijn> Agda is starting to look less scary the more I start abusing the type system
04:50:57 <merijn> Agda has proper type level lambda's, right?
04:51:28 <quchen> Haskell never ends! In C++ you're annoyed by the language after a month and think "hell I'll just ignore the volatile keyword", in Haskell it's "oh wow that exists, I have to learn it"
04:51:34 <shachaf> quchen: You don't actually need Agda.
04:51:44 <shachaf> quchen: Oh, this article is good:
04:52:03 <shachaf> @google mainisusuallyafunction forall
04:52:05 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
04:54:15 <quchen> shachaf: Thanks, I'll give it a read. "Map has 4 arguments" wat
04:54:16 <quchen> :-D
04:55:58 <mSSM> I am trying to install “xmonar” with the “all_extensions” flag in my cabal-dev sandbox. It tells me it can't build “alsa-mixer”, due to “c2hs” missing. When I try to “cabal-dev install c2hs“ it is missinv “happy”. However, after a succesful “cabal-dev install happy” it still tells me “cabal: The program happy is required but it could not be found.”
04:56:05 <mSSM> Is it supposed to find happy in PATH ?
04:56:14 <mSSM> s/xmonar/xmobar
04:56:45 <fmap> yes
04:57:43 <mSSM> fmap: Alright, thank you.
04:57:56 <Saizan> merijn: from agda
04:58:13 <Saizan> merijn: from Agda all this abuse looks like c++ does from haskell
04:58:24 <ned> does anyone have a good talk on how to effectively use QuickCheck
04:59:48 <merijn> I guess all Agda people are emacs heretics? Judging by all the stuff about emacs agda mode...
05:00:03 <shachaf> merijn: I don't use Emacs. But when I use Agda I use Emacs.
05:00:06 <shachaf> That's just how it is.
05:00:14 <shachaf> (Note: I don't use Agda either.)
05:00:40 <quchen> I guess I could say "When I use Agda, I use Emacs" too.
05:00:53 <mm_freak> @hoogle a -> IO a
05:00:53 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
05:00:53 <lambdabot> Control.Exception evaluate :: a -> IO a
05:00:53 <lambdabot> Control.OldException evaluate :: a -> IO a
05:00:59 <quchen> "When I use Emacs, then I use Agda."
05:01:15 <quchen> Using political induction I'm an avid Emacs and Agda user. ;-)
05:02:19 <quicksilver> surely the meme is "I don't always emacs, but when I do, I agda"
05:02:22 <quicksilver> or something.
05:03:26 <shachaf> Political induction?
05:03:35 <shachaf> That sounds like a pretty fishy proof.
05:05:47 <quchen> shachaf: Works for all practical purposes though.
05:06:14 <quchen> Read "practical" with an undertone
05:11:15 <tdammers> "Honk iff you like formal logic"
05:13:16 <quchen> Iff is a word I'm jealous of as a German.
05:13:22 <quchen> I wish we had something like it.
05:14:27 <quicksilver> well we don't have it in english either :)
05:14:37 <tdammers> quchen: "Genau dann wenn"
05:15:02 <quicksilver> or just say "<=>" in german :)
05:15:11 <tdammers> "iff" is a formal-logic neologism, short for "if and only if"
05:15:15 <companion_cube> honk
05:15:15 <wuttf> :D
05:15:23 <quchen> tdammers: That's "if and only if".
05:15:37 <quchen> Iff = Wennn :-9
05:18:16 <wuttf> german is neat but that der die das business kills me
05:18:43 <wuttf> how can an object have a gender?
05:19:06 <quchen> wuttf: Even better: why do girls not have gender, but boys do?
05:20:18 <wuttf> quchen: I don't remember that. (Been a long time since I took german lessons)
05:21:28 <nikita-0> It's even better: "das Fräulein (unmarried lady)" is neuter.
05:21:49 <quchen> nikita-0: Same with girl.
05:23:11 <nikita-0> wuttf: but in English, "The moon's an arrant thief, And *her* pale fire *she* snatches, etc."
05:23:36 <nikita-0> So with countries, cities and so on.
05:24:12 <shachaf> Gendered pronouns are nonsense.
05:24:19 <shachaf> For humans and objects alike..
05:24:21 <shachaf> s/.$//
05:24:54 <quicksilver> using a female pronoun for the moon is essentially incorrect, but used for poetic effect.
05:24:57 <nikita-0> This statement implies an extremely restrictive use of language.
05:25:01 <merijn> shachaf: I disagree
05:25:13 <merijn> shachaf: They make back referencing easier
05:25:30 <shachaf> merijn: http://www.cs.virginia.edu/~evans/cs655/readings/purity.html
05:25:44 <nikita-0> Yes, "typed objects are nonsense"! :-)
05:26:01 <merijn> I (like most Dutch and German speakers) have to continually shorten my English writing drastically as back referencing in English is nearly impossible.
05:26:21 <wuttf> nikita-0: That occures less frequently. I am probably unsued to genders because in my language she and he is the same word.
05:26:44 <shachaf> wuttf: Which language?
05:26:46 <shachaf> Oh, Hungarian?
05:26:52 <wuttf> shachaf: Yes.
05:27:31 <quchen> merijn: "Die dem dem ich meinen Regenschirm gab gehörenden Schuhe sind rot" WOOHOO
05:27:40 <nikita-0> merjin: actually, English prose used a good deal of back referencing before 20th century, but modern readers have difficulties to parse this.
05:27:59 <wuttf> We have some weird stuff going on in our language, like thinking in binary (two is one, one is half)
05:28:01 <quchen> English vs German is like Lisp vs Haskell in parentheses density ;-)
05:28:36 <ijp> quchen: though, the opposite way around in word length
05:28:54 <quchen> ijp: That doesn't change the syntax tree.
05:29:10 <ijp> I never claimed it did
05:29:10 <mSSM> quchen: How is that German?
05:29:18 <merijn> awww
05:29:50 <merijn> I figured I should just change my name to "merĳn" in an effort to reduce typo's of my name, but Freenode won't allow me to use unicode in my nick :<
05:30:13 <nikita-0> Sorry.
05:30:26 <tdammers> how about 'meryn'?
05:30:33 <merijn> ijp: You mean like rijkswaterstaatssluisreiningsdienstpersoneelsuitje? :>
05:30:33 <tdammers> give it an afrikaans flavor
05:30:38 <merijn> tdammers: Heresy!
05:30:48 <quchen> 🎂
05:30:53 <quchen> ^ Unicode for "birthday cake"
05:30:53 <merijn> That's an actually valid word, btw
05:30:56 <ijp> merijn: yeah
05:31:03 <mSSM> I have installed xmonad and xmonad-contrib in a cabal-dev sandbox. Now it seems like xmonad doesn't see the library files provided by xmonad-contrib. It simply can't import any of them!
05:31:04 <tdammers> and you mistyped rijkswaterstaatssluisreinigingsdienspersoneelsuitje
05:31:06 <mSSM> Any ideas how to fix this?
05:31:36 <nikita-0> It would be interesting to have a "synthetical" programming language, depending on endings to encode parsing structure rather than on word order as in English.
05:31:36 <merijn> tdammers: The only change is the removal of t after diens, which is wrong
05:31:49 <mm_freak> quchen: that doesn't sound like a valid german sentence
05:31:51 <wuttf> Did you know that the stem of marriage, (marr/mer) in Hungarian means to be brave, and in Sanskrit means to die, and they are all interconnected?
05:32:13 <osfameron> merijn: and changing reining to reiniging
05:32:13 <mm_freak> quchen: "Die Schuhe dessen, dem ich meinen Regenschirm gab, sind rot."
05:32:25 <quchen> mm_freak: Die dem (dem ich meinen Regenschirm gab) gehörenden Schuhe sind rot
05:32:29 <merijn> osfameron: oh, right. Yeah that was a typo :p
05:32:31 <quchen> Die dem Schaffner gehörenden Schuhe sind rot.
05:32:35 <nikita-0> wuttf: Black in English stems from the same root as white in most other Indo-European languages.
05:32:39 <quchen> Now give the Schaffner your Regenschirm.
05:32:40 <merijn> Eh, but I guess we should move this to -blah? :>
05:33:04 <shachaf> I should go to sleep.
05:33:13 <mm_freak> quchen: then you're missing commas, but it's still a very weird way to formulate the sentence
05:33:20 <mm_freak> oh wait
05:33:22 <quchen> merijn: "My language is superior" is always ontopic in #haskell :P
05:33:24 <mm_freak> no commas in that case…
05:33:43 <wuttf> merijn: :DDDD Depends on the language I guess?
05:33:48 <mm_freak> german is like haskell…  even after years you don't really understand it =)
05:33:49 <wuttf> quchen:
05:34:08 <quchen> mm_freak: I've got 25 and Kant still confuses me
05:34:18 * shachaf thinks merijn was right about the -blah thing.
05:34:28 <wuttf> Yea.
05:34:54 <mSSM> jkjasdi
05:34:59 <mSSM> kjkjanhskdjah
05:35:05 <Saizan> mSSM: ?
05:35:10 <mSSM> Saizan: sorry
05:35:18 <mSSM> Saizan: my tmux froze
05:35:31 <mSSM> :(
05:35:47 <Saizan> mSSM: anyhow for xmonad you'd have to tell it to use cabal-dev's package database
05:36:00 <Saizan> mSSM: not sure if there's a way
05:36:07 <tdammers> merijn: reiniging, not reining
05:36:50 <mSSM> Saizan: thanks; I figured something like that
06:07:24 <Philonous> Has the order of arguments to newForeignPtr changed recently? GTK seems to be using it the other way around
06:08:08 <kqr> 14:15:22     quchen | Iff = Wennn :-9
06:08:24 <kqr> quchen, i like that solution. i have many times proposed "omm" for swedish but it just doesn't seem to catch on :(
06:08:51 <quchen> kqr: -> #haskell-blah  (also yes!)
06:09:25 <int-e> Philonous: is that in a conditional block perchance?
06:10:44 <kqr> quchen, oh, right
06:10:50 <Philonous> int-e:  No, it's quite straight-forward. wrapNewGObject has "newForeignPtr objPtr objectUnref"
06:13:19 <int-e> Philonous: anyway to answer the question as asked, no, nothing has changed about the order of arguments; it was the same in base-2.0 (the oldest on hackage) as it is now.
06:14:56 <Philonous> int-e:  How peculiar. Thanks.
06:16:47 <int-e> Philonous: and sigh, I believe I've seen this before (if it results in a type error?), but I forgot all about the circumstances.
06:17:41 <linduxed> hey guys, i need to represent the following tree http://i.imgur.com/WHSilqW.png with this kind of string "((Fly, Mosquito), Fish, (Frog, ((Mouse, Rat), (Human, (Cow, Dog)))));"  Naturally, my first idea was to create some data type for this, but i can't quite figure out what to do. my current attempt looks like this:  "data Tree = EmptyTree | Leaf String | [Tree]"
06:17:57 <linduxed> i know that [Tree] doesn't work, but that's what i'm going for
06:18:03 <linduxed> that's what i need... i think at least
06:18:53 <Cale> linduxed: data Tree a = Leaf a | Branch [Tree a]
06:19:24 <Cale> Or you can use String in place of a, and remove the parameter
06:19:44 <Cale> You left out the constructor in the third case
06:19:59 <Cale> Otherwise, your declaration would have worked
06:20:03 <linduxed> Cale: oh, that sounds good
06:20:31 <linduxed> Cale: btw, i read in learnyouahaskell that it's generally good practise to not have defined types in data types
06:20:37 <linduxed> like "String"
06:20:54 <linduxed> you used a generic type, why is that?
06:20:59 <linduxed> oh wait
06:21:12 <linduxed> sorry, used my brain, answered my own question :-P
06:21:17 <Cale> Well, it depends on the nature of the type in question, but presumably there will be a lot of operations on trees which will not care at all what type of data is being stored in the tree's leaves
06:21:52 <Cale> Or which will be reasonably polymorphic with respect to that type, even if it needs to assume that the type belongs to a certain class (like Ord)
06:22:21 <Cale> and this will result in saving time later when you need to work with trees of integers, for example
06:22:32 <S11001001> or use Free [] :)
06:22:40 <Cale> Also, this Tree is a perfectly good instance of Functor as well as Monad
06:22:52 <Cale> So, it would be a little bit of a shame to pass that up :)
06:23:44 <linduxed> Cale: i've managed to come as far in the book to read about functors, so yeah i get why that would be a shame to pass up on
06:23:50 <linduxed> Cale: haven't gotten to the monads yet
06:24:07 <linduxed> Cale: although i'll take your word for their usefulness :-)
06:24:18 <quicksilver> you could just see it as an example of separating structure from content
06:24:35 <quicksilver> the notion of tree as a structure is a perfectly reasonable one whatever data is stores
06:24:36 <linduxed> quicksilver: yes, that sounds reasonable
06:24:43 <quicksilver> so it's more modular to handle the structure seperately
06:24:49 <Cale> Well, the monad instance comes from the fact that there's a way to "make substitutions of trees for leaves":  (>>=) :: Tree a -> (a -> Tree b) -> Tree b
06:24:57 <wuttf> I will deploy a smallish app next month, written in Haskell, for the government, which will be used by approx half a million people =)
06:25:01 <donri> and foldable and traversable?
06:25:26 <Cale> It takes a tree of values of type a, and a function saying how to get a tree of values of type b for each value of type a, and constructs an expanded tree of values of type b
06:25:30 <quchen> wuttf: Neat! What program?
06:25:32 <linduxed> Cale: well that doesn't mean anything to me yet. i haven't gotten to monads yet so i don't understand those things
06:25:45 <Cale> I'm not assuming you know about monads here
06:26:03 <Cale> I'm explaining what one of the operations that the Monad class defines will do in this special case
06:26:04 <wuttf> quchen: Tiny little CRUD style stuff,
06:26:14 <absence> isn't there a :% constructor for rationals?
06:26:24 <Cale> So, we'll implement this substitution function when we're writing the instance of the Monad class for Tree
06:26:29 <wuttf> quchen: I am kinda excited because it's my first haskell project =)
06:27:00 <linduxed> Cale: oh i think i see
06:27:01 <Cale> absence: It's not exported
06:27:28 <quchen> wuttf: Understandable :-) How much work did you put in it? Is it there to stay?
06:27:44 <Cale> linduxed: So if you had some function which took a name of some animal, and produced, I dunno, a tree of foods which were made from that animal, then you could get a tree of all the foods from the tree of all the animals.
06:28:18 <absence> Cale: ah, so i have to call numerator and denominator instead of pattern matching?
06:29:07 <wuttf> quchen: Well not much yet, I just prepared the grounds for it, today I will receive the complete specification. I estimate it will be a 1-2 week project
06:30:40 <quchen> wuttf: Oh I thought you finished already. In any case, post about it on Reddit when you're done!
06:32:06 <wuttf> quchen: Sure, why not =)
06:36:47 <Cale> absence: yeah
06:37:35 <Cale> absence: It's a little annoying that there isn't a function that does both, and produces a pair, since it's rare that you want one without the other
06:41:10 * hackagebot case-insensitive 1.0 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.0 (BasVanDijk)
06:52:16 <absence> Cale: ok, thanks!
06:53:23 <absence> fromRational = uncurry Div <<< FloatCast . IntC *** FloatCast . IntC <<< numerator &&& denominator <- is there a trick (other than a where clause) that can remove the duplication?
06:54:29 <HugoDaniel> :)
06:54:37 <merijn> absence: Well, I was campainging for "both :: Arrow a => a b c -> a (b, b) (c, c)" on libraries@ recently, but I got only two or so supporters
06:55:03 <shachaf> merijn: If you redid the Arrow hierarchy you'd have more supporters!
06:55:08 <shachaf> It should be profunctor-based.
06:55:28 <elliott> both :: (Representable p, Applicative (Rep p)) => ... -- clearly
06:55:29 <merijn> I think all the profunctor people are lens people who already stole "both"
06:55:43 <elliott> merijn: The profunctorial "both" would be the same as profunctor lens both, though.
06:55:45 <merijn> Bastards!
06:55:54 <elliott> That's why it's good.
06:56:01 <shachaf> merijn: If the hierarchy worked "the right way" it would be compatible.
06:56:09 * merijn has no clue what profunctors even are
06:56:51 <shachaf> merijn: They're types p that suppose dimap :: (a -> a') -> (b -> b') -> p a' b -> p a b'
06:57:18 <hpaste> Thomas2 pasted “Countdown-prog” at http://hpaste.org/81421
06:57:53 <merijn> oh, *of course*, it's all clear now :)
06:58:12 <Thomas2> hey can someone build a main function for me
06:58:36 <Thomas2> http://hpaste.org/81421
06:59:21 <fizbin> Hey, what's the best practice for when you have lots and lots of datastructures and it really makes sense for fields to be names similarly?
06:59:43 <merijn> fizbin: Put them in different modules or nest shared parts?
07:00:40 <fizbin> merijn: How does the nesting shared parts thing work? I'll still have to come up with different names for the shared part, won't I?
07:01:32 <Thomas2> can nobody help me?
07:01:51 <merijn> fizbin: i.e. define "data SharedPart = SharedPart { field1 :: a, field2 :: b }; data Foo = Foo SharedPart Int String; data Bar = Bar SharedPart [Int] Bool"
07:02:11 <merijn> fizbin: What are you doing that gives you many similarly named fields, though?
07:02:39 <fizbin> That is, I'll have data FooBarShared = FBShared {name :: String, version :: Integer} but then data Foo = Foo {sharedF :: FooBarShared, otherstuff} and data Bar = Bar {sharedB :: FooBarShared, otherstuff}
07:03:35 <fizbin> And it seems silly to have two different names there. I guess for the way I'm thinking of it, tiny modules do make more sense.
07:04:52 <merijn> fizbin: I don't encounter these situations with many similar field names that often, and when I see them occur here it's usually due to a wrong approach to the problem. But it's hard to tell without knowing a bit more about what you're doing
07:07:31 <absence> merijn: thanks, i keep forgetting about lens :)
07:07:56 <merijn> absence: If you use lens it becomes "over both", I think
07:14:06 <absence> merijn: ended up with both %~ to avoid parens
07:14:19 <swi> Hello.
07:14:33 <swi> i'm little confused with . operator
07:15:39 <merijn> swi: ok, any specific thing that confuses you?
07:15:51 <fragamus> @pl sequence $ map (getCRandomR . (\x->(0,x)) ) $ reverse [0..maxi]
07:15:51 <lambdabot> sequence (map (getCRandomR . (,) 0) (reverse [0..maxi]))
07:16:55 <swi> i.e. if i change head (tail "some") to head . tail "some" it's doesnt work, but if i write let foo = head . tail and then  call foo "some" it work.
07:17:11 <quicksilver> (head . tail) "some" would work
07:17:28 <quicksilver> what you wrote is read as head . (tail "some")
07:17:33 <quicksilver> which is different
07:17:37 <quicksilver> does that help?
07:18:02 <swi> quicksilver: seems i cant catch 'what' (.) do exactly
07:18:06 <merijn> swi: The short answer that quicksilver is trying to give is "function application always binds tighter than operators"
07:18:55 <ski> swi : `.' composes two functions
07:19:06 <merijn> swi: A simpler example of what's going on would be:
07:19:21 <merijn> > succ 1 * 5
07:19:23 <lambdabot>   10
07:19:27 <merijn> > succ (1 * 5)
07:19:29 <lambdabot>   6
07:19:39 <ski> if you think of the two functions as two pipelines : given some input, some output comes out in the other end, then `.' glues the two pipes together into a longer pipe
07:20:13 <merijn> swi: The succ is applied to 1 before the multiplicaton, the same happens with "head . tail "some"". It first does "tail "some"", which results in "ome"
07:20:43 <merijn> Next it tries to apply (.) to head and "ome", which fails, because "ome" is not a function
07:20:55 <swi> hmmm
07:21:04 <swi> i think i catch up
07:21:58 <merijn> If you put parentheses around (head . tail), it first applies (.) to head and tail and *then* applies the result to "some"
07:22:03 <swi> > head . tail $ "some"
07:22:05 <lambdabot>   'o'
07:22:08 <swi> yep
07:22:21 <merijn> That's a common use case for ($), yes
07:22:58 <merijn> Since it is also an operator, it breaks the tight binding between tail and "some" and because of it's low priority (.) goes first
07:23:32 <tdammers> I tend to use a $ b c over a . b $ c
07:23:47 <merijn> tdammers: Doesn't work so well with long pipelines
07:23:56 <tdammers> I was about to say that
07:24:01 <merijn> f . g . h . i . j $ foo
07:24:05 <tdammers> indeed
07:24:29 <tdammers> foldl1 (.) [ f, g, h, i, j ] $ foo
07:25:05 <merijn> That only works if all functions have the same type, rendering it essentially useless
07:25:06 <elliott> That doesn't work.
07:25:11 <elliott> Also you shouldn't use foldl1 there :)
07:25:22 <merijn> fold (.) id
07:25:33 <swi> merijn: seems i understand. thanks
07:26:49 <S11001001> @pl f o l d r = foldr (o l) d r
07:26:49 <lambdabot> f = (foldr .)
07:27:36 <ski> shachaf :)
07:27:56 <osfameron> witchcraft!
07:28:24 <swi> o my brains
07:28:35 <ski> shachaf : wherefore apartness ?
07:28:37 <geekosaur> foldr-ol?
07:29:05 <shachaf> ski: We were talking about cotransitivity once.
07:29:27 <shachaf> I guess apartness is also commutative, so it's stronger than the type of relation I was looking for.
07:29:29 <swi> > head $ map (+4) sort . tail [1,2,3]
07:29:30 <lambdabot>   Couldn't match expected type `a1 -> a0' with actual type `[b0]'
07:29:35 <swi> ahaa :)
07:29:53 <ski> shachaf : hm, was it cocategories ?
07:29:56 <Taneb> Is there anything like System.FilePath for text?
07:30:21 <ski> > (head . map (+4) sort . tail) [1,2,3]
07:30:23 <lambdabot>   Couldn't match expected type `a0 -> [b0]' with actual type `[b1]'
07:30:35 <ski> > (head . map (+4) . sort . tail) [1,2,3]
07:30:37 <lambdabot>   6
07:30:47 <ski> > ((+4) . head . sort . tail) [1,2,3]
07:30:49 <lambdabot>   6
07:31:04 <ski> because `head . map f = f . head', for all `f'
07:31:10 <shachaf> ski: Yes.
07:31:22 <ski> @free head
07:31:23 <lambdabot> f . head = head . $map f
07:31:37 <ski> swi ^
07:32:13 <Philonous> Why does glib use rts_evalIO for signal callbacks rather than foreign export ccall "wrapper"?
07:37:01 <mm_freak> class (Monad m) => Reactive e m w | w -> e, w -> m where
07:37:13 <mm_freak> types of this class will never define a Functor instance
07:37:17 <mm_freak> instance (Reactive e m w) => Functor (w a) where
07:37:23 <mm_freak> this one is undecidable
07:37:29 <mSSM> I updated my GHC to 7.6.1 along with cabal-install and cabal-dev (from git): how do I best recompile the programs I so far have beein compiling in a cabal-dev sandbox (GHC 7.4.2, cabal-dev 0.9.1)?
07:37:29 <mm_freak> is it safe in this case?
07:37:43 <mSSM> Shall I make a new sandbox/cabalize/cabal-dev install ?
07:39:04 <absence> what does | in type signatures mean?
07:39:10 <mm_freak> i'm very cautious about enabling UndecidableInstances
07:39:25 <mm_freak> absence: where?  could you give an example?
07:39:51 <absence> mm_freak: the one you just pasted for example
07:40:08 <mm_freak> absence: oh, that's not a type signature…  it's a functional dependency in this case
07:40:20 <mm_freak> w -> e means that e follows from w
07:40:58 <mSSM> 2
07:41:29 <absence> mm_freak: so that's what it's called :) there's a page for me to read on haskellwiki, thanks!
07:41:34 <hpaste> ocharles pasted “Cabal error - what is the actual problem?” at http://hpaste.org/81422
07:41:47 <ocharles> Hi, can anyone see what the actual error is that above cabal message?
07:41:59 <ocharles> oh
07:42:01 <ocharles> package is broken
07:43:49 <mm_freak> let me shorten my question:  instance (X a) => Y a…  this is undecidable of course…  is it safe, if an instance of X never defines an instance of Y explicitly?
07:43:55 <dcoutts_> ocharles: and it cannot pick a source version of lens, because it has to use the installed instance of musicbrainz-data-0.0.1
07:44:03 <ocharles> yea
07:44:14 <dcoutts_> ocharles: it could probably find a solution if you would allow it to rebuild musicbrainz-data
07:44:38 <dcoutts_> ocharles: ie. do something like cabal install ./ ../musicbrainz-data/ --dry
07:44:51 <dcoutts_> assuming you have the sources to hand
07:44:54 <ocharles> Well it does reinstall musicbrainz-data from source first
07:44:58 <ocharles> so i'm not sure how it's getting in a pickle
07:45:04 <mm_freak> as a contrived (and not applying to my case) example:  instance (Monad f) => Functor f
07:45:11 <ocharles> but i'll just go into the build server and manually fix things up
07:45:13 <fragamus> HEY!
07:45:21 <mm_freak> is that one safe, as long as no monad ever defines an explicit Functor instance?
07:45:28 <fragamus> my code has a bug!!!
07:45:52 <fragamus> I did not know that haskell code could have a bug!
07:45:54 <dcoutts_> ocharles: but in that call to cabal, cabal don't know how to rebuild musicbrainz-data from source, because it's not on hackage and you've not told cabal where the source version is, so it's forced to use the installed version.
07:46:16 <mm_freak> fragamus: it doesn't…  your types were too permissive
07:46:24 <fragamus> lol
07:46:39 <fragamus> i was wrong it works
07:46:41 <dcoutts_> ocharles: general advice is to ask cabal to install everything at once, not bit by bit
07:47:25 <ocharles> right
07:47:46 <ocharles> how can I specify a directory, and only the dependencies of the current project?
07:47:57 <dcoutts_> ocharles: --only-dep . ../blah
07:47:59 <ocharles> That is, I'm in foo/, and I want to install all dependencies of foo/ and foo/bar
07:48:03 <dcoutts_> ./
07:48:07 <ocharles> that won't install only the dependencies of ../blah?
07:48:14 <dcoutts_> ./  ../blah
07:48:17 <ocharles> it's clever enough to only apply that flag to one cabal file?
07:48:29 <dcoutts_> ocharles: oh, no it applies that flag to them all
07:48:48 <ocharles> ok, so I guess I need to do --only-dependencies . ./blah, and then cabal install ./blah
07:49:07 <dcoutts_> use --dry-run, see what it says
07:49:20 <ocharles> will do
07:49:47 <dcoutts_> ocharles: in future, when we have a good ui in cabal for sandboxes, this would go away since cabal would know where the sources are (when you're working with multi-package projects)
07:49:57 <ocharles> yea, i can't wait for cabal sandbox :)
08:02:15 <fragamus> @hoogle (a->a)->Int->a
08:02:15 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
08:02:15 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
08:02:15 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
08:11:12 * hackagebot ruler 0.4.0.0 - Ruler tool for UHC  http://hackage.haskell.org/package/ruler-0.4.0.0 (JeroenBransen)
08:14:53 <fragamus> is there a way to apply (a->a) a fixed number of times
08:15:21 <Iceland_jack> iterate f xs !! n?
08:15:53 <ski> `\n f -> foldr (.) id . replicateN n f' ..
08:16:47 <applicative_> @type ((!!).) . iterate
08:16:48 <lambdabot> (a -> a) -> a -> Int -> a
08:16:59 <applicative_> not the best argument order
08:17:07 <ski> @type flip . ((!!) .) . iterate
08:17:08 <lambdabot> (c -> c) -> Int -> c -> c
08:17:25 <applicative_> ski is rightly so named
08:17:30 <ski> ?
08:17:40 <applicative_> I was trying to attack flip to one of the elements
08:17:55 * applicative_ was thinking of the combinators S K I
08:18:16 <applicative_> s/attach/attack
08:18:40 <ski> (itym the other way around ;)
08:18:53 <applicative_> @type flip (flip . ((!!) .) . iterate)
08:18:54 <lambdabot> Int -> (c -> c) -> c -> c
08:18:58 <quchen> applicative_: (a -> a) forms a monoid (called Monoid.Endo in Haskell I think). foldr (.) id for this type is foldr (<>) mempty = mconcat.
08:18:58 <applicative_> yeah
08:19:13 <quchen> applicative_: So the fold just concatenates the list of functions given.
08:19:35 <applicative_> @type foldr (<>) mempty
08:19:37 <ski> @type appEndo . mconcat . map Endo
08:19:37 <lambdabot> Monoid b => [b] -> b
08:19:38 <lambdabot> [a -> a] -> a -> a
08:20:17 <applicative_> @type foldr (.) id
08:20:19 <lambdabot> [a -> a] -> a -> a
08:20:45 * ski tends to call this combinator `compose'
08:30:44 <merijn> @quote compose
08:30:44 <lambdabot> Cale says: What we need are monad tutorial transformers. // So that we can compose the features of monad tutorials
08:30:48 <merijn> Blah
08:30:58 <merijn> @quote morose
08:30:58 <lambdabot> bitwize says: The combinator known as compose, Makes me extremely morose; The full stop is better, than writing it in letters, Which makes it uselessly verbose.
08:34:35 <quicksilver> ski: the benefit of using 'appEndo' is that you can pretend you're Harry Potter when you say it.
08:35:48 <frerich> :-)
08:36:22 * ski isn't familiar with the adventures of Mr. Potter
08:37:20 <osfameron> and its oh so elegant magical system, which consists of speaking in Pig Latin
08:39:28 <t7> @msg peaker your freetype lib (on hackage) doesnt build. "Cant find shader.h"
08:39:28 <lambdabot> Not enough privileges
08:40:25 <Botje> try @tell instead
08:58:22 <BlindRadish> hello!
08:58:32 <Taneb> Hey
08:58:43 <BlindRadish> :D
08:58:48 <BlindRadish> Can you help me out?
08:59:02 <Taneb> I don't know, what are you stuck with?
08:59:03 <ion> My crystal ball isn’t certain.
08:59:50 <BlindRadish> I need to curry I think, I want to build a function which plugs a value into an argument in a function and then return the function to call later on
09:00:19 <Taneb> I think that's done by default in Haskell
09:00:27 <BlindRadish> like (A, B) -> (C) and I need to plug in A so I return (B) -> (C)
09:00:39 <Taneb> Okay, use uncurry
09:00:42 <Taneb> :t uncurry
09:00:43 <lambdabot> (a -> b -> c) -> (a, b) -> c
09:00:44 <mauke> did you mean: curry
09:00:50 <Taneb> Yes
09:00:53 <Taneb> :t curry
09:00:55 <lambdabot> ((a, b) -> c) -> a -> b -> c
09:01:03 <BlindRadish> So I just don't plug in all the variables or something?
09:01:04 <Taneb> Yeah, use curry
09:01:13 * hackagebot FreeTypeGL 0.0.4 - Loadable texture fonts for OpenGL.  http://hackage.haskell.org/package/FreeTypeGL-0.0.4 (EyalLotem)
09:01:17 <mauke> BlindRadish: why do you have (A, B) -> C in the first place?
09:01:18 <Taneb> Think about it.
09:01:26 <Taneb> You have (A, B) -> C
09:01:27 <BlindRadish> Its not /really/ like that.
09:01:32 <Taneb> and want A -> (B -> C)
09:01:40 <Taneb> Then what is it like?
09:01:44 <BlindRadish> I pump the value through a mask thing
09:01:50 <BlindRadish> and get a new value but keep the old mask
09:01:59 <BlindRadish> but I need to change it eventually
09:02:12 <BlindRadish> I use it five or six times and then rerun the whole thing.
09:02:19 <BlindRadish> with a new mask*
09:02:34 <Taneb> So, what's the mask?
09:03:00 <applicative_> > let f   =  (au (wrapping Endo) foldMap .) . replicate in f 100 (*10) 1
09:03:02 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
09:03:59 <BlindRadish> well I'm not sure yet, but I create it as I go..
09:04:08 <BlindRadish> and then apply it
09:04:15 <BlindRadish> I'm still kind of new
09:04:44 <Taneb> I've got a feeling you want the reader monad
09:05:04 <Taneb> But that's not a very confident feeling
09:07:00 <applicative_> it sounds like StateT (mask,value) m a , no>
09:07:13 <applicative_> it sounds like StateT (mask,value) m a , no?
09:08:16 <Taneb> value -> ReaderT mask m a, to me
09:09:57 <BlindRadish> thanks
09:10:51 <Taneb> Or just value -> mask -> a
09:11:08 <Taneb> Then sticking in a value gives you mask -> a
09:20:29 <mSSM> If I want to represent a 2D (index (x,y)) structure with a 1D (index i) structure in haskell, what's the cheapest way of getting the index (x,y) in terms of i? Possibility 1: make a “dictionary”, where the vector a is indexed in terms of (x,y) with elements i and vector b is indexed in terms of i with elements (x,y), or Possibility 2: have 2 transformer functions `geti (x,y) n = y*n+x', `getxy i n = (i
09:20:31 <mSSM> `mod' n, i `div` n)' ?
09:21:14 * hackagebot snaplet-sqlite-simple 0.4.1 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.1 (JanneHellsten)
09:24:38 <applicative_> mSSM i wonder what repa does; it is using Vector to represent n-D arrays.
09:25:12 <mSSM> applicative_: Yeah, I was just thinking of using repa
09:25:17 <mSSM> for case 1
09:27:50 <ski> @type divMod
09:27:52 <lambdabot> Integral a => a -> a -> (a, a)
09:28:47 <mSSM> haha
09:34:42 <applicative_> mSSM: it seems repa has you decide the two transformations 	toIndex :: sh -> sh -> Int and fromIndex :: sh -> Int -> sh for any represrentaion of shape
09:35:17 <applicative_> the first sh is the size of the array, the second is the coordinates corresponding to the Int , so to speak
09:36:15 * hackagebot http-types 0.8.0 - Generic HTTP types for Haskell (for both client and server code).  http://hackage.haskell.org/package/http-types-0.8.0 (AristidBreitkreuz)
09:37:26 <mSSM> applicative_: that's pretty cool
09:37:42 <mSSM> applicative_: Now I just got to figure out how to have repa store that in memory.
09:37:47 <bscarlet> Anybody know a clean (e.g. already implemented by somebody else) way to find all capturable variables of a Template Haskell expression?
09:38:24 <mSSM> applicative_: I suppose I could give it a shape of (Z :. n :. n) and a list of Int's [0 .. (n*n)]
09:40:35 * applicative_ had forgotten that repa can use bytestring to represent an n-D array of word8s
09:43:18 <ParahSailin> is there any way to automatically set -XOverloadedStrings when i import a module that has that language pragma?
09:45:11 * applicative_ thinks, good question...
09:45:57 <typoclass> ParahSailin: i've got some vim extension thingy where i hit a key and type "Ove tab" to insert that line at the top of the file. also, you could conceivably put it in the .cabal file under ghc options. other than that, no idea
09:47:11 <ParahSailin> typoclass: i don't really need it though, just want to avoid the :set when im playing around with module in ghci
09:48:14 <typoclass> ParahSailin: that has tab complete, doesn't it?
09:48:56 <applicative_> typoclass: it's the interaction with ghci I think ParahSailin means.  It's not so great just having :set -XOverloadedStrings in one's .ghci
09:50:16 <typoclass> applicative_: right i get it, from the point of view of the module author, you want to offer that to the users
09:50:48 <beaky> hello
09:50:50 <c_wraith> I really think :load should automatically enable all the LANGUAGE pragmas in the source file loaded
09:51:07 <beaky> is there a web framework like ruby on rails for haskell? I wanna develop webapps using haskell :D
09:51:15 * hackagebot texmath 0.6.1.3 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.1.3 (JohnMacFarlane)
09:51:15 <c_wraith> Because it already puts in in the import scope of the loaded file.  Why doesn't it give you the language pragmas, too?
09:51:23 <typoclass> c_wraith: good point
09:51:24 <c_wraith> beaky: there are 3 main options.
09:51:35 <ParahSailin> c_wraith: what if multiple :loaded modules have conflicting language pragma
09:51:37 <typoclass> beaky: the main options are happstack, snap, and yesod
09:51:48 <monochrom> there are snap, happstack, yesod for webapp. they are not like ruby on rails
09:51:54 <c_wraith> ParahSailin: can you :load multiple modules?
09:51:58 <beaky> ah
09:52:15 <c_wraith> ParahSailin: I don't think you can
09:52:19 <beaky> so they are all quite different from rails?
09:52:32 <monochrom> ruby is quite different from haskell
09:52:37 <beaky> right
09:53:43 <typoclass> ParahSailin: in that case, enable the stuff when :loading one file, don't do anything when :loading two files. still a net win for tons of people
09:54:46 <applicative_> ParahSailin: well, I'm trying the expedient of making a little alias for :o, so to speak, with this line in my .ghci    :def o (\_ -> return ":set -XOverloadedStrings")
09:55:31 <mSSM> applicative_: where can I read how repa defines to/fromIndex ?
09:56:37 <gavri> what's the idiomatic way of simplifying (\x y -> (func x) < (func y))       ?
09:56:42 <gavri> something like "comparing"
09:56:59 <glguy> Data.Functon.on (<) func
09:57:01 <glguy> does that
09:57:06 <gavri> glguy: thanks a lot
09:57:26 <EvanR> (<) `on` func
09:57:44 <ski> (you can `:load' multiple modules, yes)
09:57:52 <gavri> also, is there an idiomatic way to do this? (\x y z -> f (f x y) z) ? assuming f is commutative
09:57:58 <gavri> thanks, EvanR
09:58:10 <EvanR> @pl (\x y z -> f (f x y) z)
09:58:10 <lambdabot> (f .) . f
09:58:12 <EvanR> haha
09:58:31 <typoclass> gavri: "foldr1 f" or some such?
09:58:32 <EvanR> `.).`
09:58:34 <applicative_> mSSM: it is done inductively in http://hackage.haskell.org/packages/archive/repa/3.2.3.1/doc/html/src/Data-Array-Repa-Index.html I'm not sure it's worth the trouble on reflection, but maybe?
09:58:47 <schellsan> i'm trying to install cabal-dev to keep from breaking a bunch of libs, but using cabal to install cabal-dev will break a bunch of libs...
09:59:07 <schellsan> has anyone run into that?
09:59:11 <typoclass> applicative_: (out of curiosity, what is :o ?)
09:59:32 <gavri> typoclass: I don't have a list though. just three arguments
09:59:42 <applicative_> mSSM: all dimensions are handled , Z and Z :. Int and Z:. Int :. Int etc
10:00:08 <applicative_> typoclass: it was just an abbreviation inside ghci for :set -XOverloadedStrings
10:00:53 <applicative_> and :no -- :def no  (\_ -> return ":set -XNoOverloadedStrings")
10:01:03 <typoclass> applicative_: ok. i thought "making an alias for :o" means it's some builtin thing i've never heard of. no worries =)
10:01:13 <typoclass> gavri: hm ... i don't know then =)
10:01:22 <mSSM> applicative_: I am just wondering how to best handle this. E.g.: should I make an array of indice's storing shapes?
10:01:27 * applicative_ will regret this soon enough like everything he puts in his .ghci, except :set -XNoMonomorphismRestriction
10:02:05 <applicative_> typoclass: oh sorry, I was thinking what to call it, 'alias' was not too great a choise
10:02:08 <applicative_> choice
10:04:20 <mSSM> applicative_: e.g. map fromIndex [0..(n^2-1)] :: (Z :. (n::Int) :. (n::Int))
10:12:01 <bitonic> is there an emacs mode for Alex files?
10:16:51 <Eduard_Munteanu> Is  runBreakable :: ((m a -> ContT r m b) -> ContT r m (m a)) -> m a   runBreakable = flip runContT id . callCC   used much?
10:18:19 <Eduard_Munteanu> It sounds useful when you don't want to bother writing the runContT bit explicitly.
10:22:18 <glguy> Eduard_Munteanu: It might be more common to see it as > let runBreakable m = either id id `liftM` runExceptionT (m raise) in runBreakable
10:22:26 <mSSM> How come repa doesn't freak out if I give it “fromIndex (Z :. (7::Int) :. (7::Int)) 64” ?
10:22:44 <mSSM> I'd expect it to give me an exception.
10:23:15 <glguy> (which is about the same thing)
10:23:25 <bgamari> mSSM, What does it return?
10:23:26 <Eduard_Munteanu> Hm, right, Either/Exception/Error etc. can do that too.
10:24:05 <bgamari> yikes
10:24:32 <bgamari> mSSM, that is an interesting and not entirely expected behavior
10:24:43 <bgamari> I'm not sure what the right way to handle that would be though
10:24:54 <bgamari> you could either return Maybe, but that's a bit annoying
10:25:02 <bgamari> make fromIndex partial (yuck)
10:25:11 <bgamari> or just do what it does
10:25:22 <mSSM> bgamari: This behaviour freaks me out.
10:25:23 <awgn> frommap
10:25:32 <bgamari> I almost think the current behavior is the least of the evils
10:26:33 <mSSM> bgamari: toIndex (Z:.(8::Int):.(8::Int)) applied to (Z:.(1::Int):.(0::Int)) and (Z:.(0::Int):.(8::Int)) gives the same.
10:26:49 <mSSM> in both cases 8
10:27:32 <mSSM> bgamari: for the thing above: fromIndex (Z :. (7::Int) :. (7::Int)) 57 gives
10:27:35 <mSSM> sorry
10:29:23 <mSSM> “fromIndex (Z:.(8::Int):.(8::Int))” 63 gives (Z :. 7) :. 7; applied to (Z :. 8) :. 0; and then it just keeps on counting.
10:31:08 <mSSM> oh well, I guess this is ok
10:32:11 <ski> @type (`runContT` return) . callCC
10:32:12 <lambdabot> Monad m => ((r -> ContT r m b) -> ContT r m r) -> m r
10:32:38 <parcs> > logBase 2 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875
10:32:40 <lambdabot>   693.0809495831737
10:33:31 <CengAmat> hello
10:33:49 <ski> hello
10:33:50 <applicative_> I guess you could defined myToIndex (Z:. a :. b) x = if abs (a * b) then error (show x ++ "is too big for " ++ show a ++ " " ++ show b) else toIndex  (Z:. a :. b) x -- or maybe something is backward there...
10:34:44 <applicative_> hello CengAmat !
10:34:59 <CengAmat> Who are you?
10:35:26 <applicative_> Who indeed!
10:35:38 <CengAmat> name?
10:36:10 <glguy> That's applicative_
10:36:14 <CengAmat> Im very new to haskell
10:36:25 <CengAmat> It's my lesson in faculty.
10:36:30 <Philippa_> CengAmat: you should generally use someone's nick on IRC. Often even if you know another name for them
10:37:09 <CengAmat> oky
10:37:21 <CengAmat> How can I study haskell?
10:37:31 <Taneb> @where lyah
10:37:31 <lambdabot> http://www.learnyouahaskell.com/
10:37:32 <CengAmat> Which steps I should follow?
10:37:37 <Taneb> CengAmat, that link
10:37:51 <Philippa_> it's a good idea to install the Haskell Platform and have a text editor you're comfortable with. Otherwise, LYAH seems a good place to start
10:38:01 <Philippa_> (can't vouch for it myself: I learned Haskell before it was written)
10:38:52 <CengAmat> LYAH?
10:39:00 <ski> yes
10:39:19 <ski> see the link suggested by lambdabot a few lines up
10:39:21 <bitonic> ‘Programming in Haskell’ is very good too imo
10:39:25 <bitonic> but not free
10:39:44 <CengAmat> readable
10:40:11 <schellsan> learnyouahaskell.com is great and entertaining even
10:40:18 <typoclass> bitonic: is that the thompson book?
10:40:28 <bitonic> typoclass: no, Graham Hutton
10:40:36 <bitonic> thompson is the craft of functional program iirc
10:40:47 <typoclass> bitonic: i see, thanks
10:40:59 <applicative_> CengAmat: do you know other programming langauges?
10:41:05 <Philippa_> I learned from Hutton's lectures a decade back, btw. His style will work better for some people than others, but it's worth reading
10:41:06 <applicative_> languages, rather
10:41:27 <CengAmat> Yes.
10:41:29 <CengAmat> C#
10:41:31 <CengAmat> C++
10:41:32 <CengAmat> C
10:41:35 <CengAmat> Java
10:41:37 <gavri> this is what I've ended up with:  (\x y z -> minimumBy func [x, y, z])
10:41:39 <CengAmat> Prolog
10:41:43 <osfameron> Country *and* Western!
10:41:46 <osfameron> oh, and Prolog ;-)
10:41:46 <gavri> can it be simplified?
10:42:31 <CengAmat> I wanna ask a private question?
10:42:39 <CengAmat> Why shoul we learn Haskell?
10:42:55 <CengAmat> Advantages of it?
10:43:03 <Eduard_Munteanu> @where faq
10:43:03 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
10:43:12 <Philippa_> it's fun, it's different to any of the above, it supports abstractions that are an ungodly pain to write in any of the above...
10:43:15 <applicative_> CengAmat: ah okay, so you need to install the ghc or the 'haskell platform', if you haven't.
10:43:27 <applicative_> CengAmat: everyone should learn some such language as Haskell.
10:43:49 <Philippa_> gavri: you can probably make it pointless, but that looks as simple as it gets
10:43:58 <applicative_> CengAmat: Haskell is 1) unimaginably beautiful; 2) has a miraculous compiler we can hardly be said to deserve.
10:44:15 <CengAmat> My teacher said that Haskell is the moslty used programming language in the world.
10:44:19 <Philippa_> 3) something you can write code in that a non-coder can understand
10:44:23 <CengAmat> Do you think that true?
10:44:31 <typoclass> CengAmat: the compiler (ghc) is extremely helpful. it's hard to get stuff to compile, but when it does, there's usually not many bugs left. in other languages, you spend much more time on finding bugs and other tedious stuff
10:44:31 <applicative_> right
10:44:43 <applicative_> I was sort of including that under the heading of beautiful
10:44:46 <Philippa_> who is your teacher? It might be the most-used functional language in the world, for some values of functional
10:44:48 <gavri> Philippa_: how do I make it pointless?
10:44:55 <Philippa_> it's not the most-used language
10:45:14 <osfameron> gavri: you could just pass in [x,y,z] instead of x y z ?
10:45:16 <c_wraith> It might also be the most-used language in the world with no implicit type conversions at all.
10:45:31 <Philippa_> ooh, good call
10:45:36 <applicative_> Your teacher was right, on condition that he or she is using the word 'programming language' or 'language' in an unusually narrow, but highly beneficial sense.
10:45:48 <gavri> osfameron: can't do that. it's used in a context that can't be changed. thanks
10:45:52 <applicative_> ^^^ CengAmat , sorry didn't signal you
10:45:56 <ski> gavri : not beautifully
10:46:16 <gavri> ski: how do I do it ugly?
10:46:21 <CengAmat> And one more question
10:46:32 <CengAmat> What is "compiler compiler"?
10:46:33 <ski> @pl \x y z -> [x, y, z]
10:46:33 <lambdabot> (. ((. return) . (:))) . (.) . (:)
10:46:43 <Botje> pointalicious
10:46:53 <gavri> ...
10:46:54 <ski> CengAmat : sometimes that term is used for "parser generator"
10:46:57 <typoclass> CengAmat: haskell is used by a fair number of people, but in the big picture, haskell is not very popular. (not that it really matters ... if i write haskell code, and it works, and i'm happy, then i don't really care that haskell overall isn't popular)
10:47:19 <gavri> ...I think I'll leave this unchanged
10:47:20 <ski> gavri : i take it you agree it's ugly ;)
10:47:27 <gavri> ski: yeah :D
10:47:50 <gavri> ski: what do I use locally to get what that bot gives?
10:47:59 <applicative_> CengAmat: "everyone talks about it but no one uses it" is a familiar exaggeration....
10:48:48 <applicative_> CengAmat: it is I suppose much influential on other languages than one would expect
10:48:50 <typoclass> gavri: you can privately talk with lambdabot
10:49:19 <CengAmat> My haskell exam is on 6th February. I have 9 days. Do you think I pass the exam when I study so hard?
10:49:25 <gavri> typoclass: thanks
10:49:30 <applicative_> haha
10:49:40 <Philippa_> CengAmat: that depends a lot on both you and the exam
10:49:46 <applicative_> CengAmat: I think you are in trouble
10:49:52 <Philippa_> it helps if you didn't skip the classes, though
10:50:13 <typoclass> CengAmat: depends on the exam ...
10:50:30 <Philippa_> knowing prolog will help: at least you know how to get your hands dirty with general recursion
10:50:58 <ski> .. and pattern-matching
10:51:08 <typoclass> applicative_: well we have hackage and web frameworks and stuff. for the "no one uses it" category, tons of other things would be better examples than haskell =)
10:51:28 <BlindRadish> is it possible to have two patterns match to the same outcome?
10:51:50 <applicative_> typoclass: yes; I was quoting Simon Peyton Jones exaggerating....
10:51:51 <typoclass> BlindRadish: how do you mean?
10:51:59 <glguy> BlindRadish: If patterns overlap the first one will be chosen. Is that what you mean?
10:52:01 <typoclass> applicative_: sure =)
10:52:19 <BlindRadish> function == function 1
10:52:21 <ski> BlindRadish : if you say `f xs0@(x:xs) = ...' then `xs0' will match the whole list, `x' the first element, and `xs' the list of the rest of the elements
10:52:40 <CengAmat> Thanks for answers. Now, show starts :)
10:52:55 <typoclass> > case "lolcats" of entire@(x:xs) -> (entire, x, xs) -- BlindRadish, here's an example
10:52:56 <lambdabot>   ("lolcats",'l',"olcats")
10:53:22 <Philippa_> CengAmat: I hope you don't have too much else to do in those 9 days! But if you're good at this stuff, you can learn a lot in 9 days
10:53:36 <BlindRadish> typoclass: i don't think that's what i'm asking about...
10:53:49 <ski> BlindRadish : then you need to clarify what you're after
10:54:22 <BlindRadish> function 1 "foo" does exactly the same thing as function "foo"
10:54:40 <BlindRadish> should i just duplicate the outcomes?
10:54:48 <geekosaur> you can't even define that
10:54:54 <geekosaur> patterns have to have the same arity
10:55:03 <BlindRadish> oh that sucks
10:55:06 <ski> BlindRadish : perhaps you should just paste the code you'd want to rewrite, so that we can have a look at it ?
10:55:11 <geekosaur> (it *is* possible to do varargs-ish functions in Haskell, but it's not trivial)
10:55:24 <BlindRadish> i was hoping to assume the value of things i left out
10:55:25 <geekosaur> BlindRadish, what is the type of such a function?
10:55:26 <otters> Text.Printf does it
10:55:32 <typoclass> BlindRadish: you can give them a name and refer to them. that's probably clearer. "foo 1 = common ; flup 10 = common ; common = ..."
10:55:50 <geekosaur> otters: [28 13:54] <geekosaur> (it *is* possible to do varargs-ish functions in Haskell, but it's not trivial)
10:56:03 <otters> I was providing an example
10:56:28 <BlindRadish> i'm not super worried about it, i was just wondering
10:56:41 * ski would still like to see the code in question
10:57:21 <BlindRadish> i'll just explain it since i just started on it and was asking a general question that came to mind...
10:57:56 <BlindRadish> i was building an algorithm for "rolling dice" i wanted to roll n, m sided dice, but if i left n out i wanted to roll 1 dice.
10:58:11 <BlindRadish> roll n m-sided dice*
10:58:22 <typoclass> BlindRadish: in general, every function in haskell has a fixed number of arguments, and it will only give you the final value once you supplied all arguments. in this sense, you can't sometimes call it with 2 arguments and sometimes with 1, and expect the same type of value to come out
10:58:40 <BlindRadish> i didn't want to have to say roll 1 5-sided dice
10:58:55 <BlindRadish> i'll just pass a dice into a roll n times function.
10:59:03 <BlindRadish> thanks guys
10:59:06 <typoclass> BlindRadish: if you need things like that, depending on circumstances, you can use lists, Maybe, records, fancy varargs, implicit params, the Reader monad, possibly other stuff
10:59:38 * ski would probably have defined both `roll' and `rollMany'
11:00:51 <BlindRadish> yeah i'm gonna define a (roll n sided die) and a rollmany which i will put the die into
11:00:58 <BlindRadish> basically iterate would work lol
11:00:58 * merijn would just do it all in the type system ;)
11:01:15 <BlindRadish> i'm not that far along merijn ;)
11:03:24 <typoclass> merijn: been done before, see http://okmij.org/publications/solution-to-the-things-merijn-will-want-to-do-7-years-from-now
11:03:39 <merijn> typoclass: I know
11:03:57 <merijn> Oleg scares me
11:04:06 <monochrom> wait, is that a fake url? :)
11:04:17 <Philippa_> ski: rollGroups as well? :p
11:04:25 <typoclass> monochrom: dude
11:04:30 <Philippa_> (I've played enough board games that warrant it)
11:04:59 <typoclass> merijn: "when the monsters go to sleep, they check under their bed for oleg"
11:05:31 <Eduard_Munteanu> Is there an applicative trick for monadic functions, like foo <$> bar <*> baz, but where foo is some a -> m b?
11:06:14 <Philippa_> join $ foo <$> bar <*> baz
11:06:32 <Philippa_> or possibly the fixity doesn't work out for it, but you call join on the result, anyway
11:06:43 <Eduard_Munteanu> Hm, yeah, I suspect that does. But I wonder if there's an operator that does that.
11:06:46 <Philippa_> >>= is fmap-then-join, "multibind" is apply then join
11:07:40 <schellsan> i think i am in what many call cabal hell?
11:07:43 <Saizan> Eduard_Munteanu: you can define a f <@> x = join $ f <*> x and write foo <$> bar <*> baz <@> quux
11:07:47 <Eduard_Munteanu> I think I want something like   f (a -> f b) -> f a -> f b   instead of (<*>)
11:08:02 <schellsan> how do i completely start over with a clean haskell platform install?
11:08:04 <elliott> Eduard_Munteanu: so a Monad?
11:08:07 <otters> so it's like ap . (>>=)
11:08:11 <typoclass> schellsan: a popular remedy is cabal-dev
11:08:18 <elliott> if you use (<*>) with f (a -> f b) and f a then the result is f (f b)
11:08:30 <elliott> join and you're finished
11:08:33 <Philippa_> Saizan: *nod*. 'tis annoyingly fugly that you have to mark the end, though
11:08:39 <Saizan> schellsan: rm -fr ~/.ghc should be enough, unless you've installed global packages
11:08:40 <elliott> oh, you're looking for a predefined operator, not an abstraction :)
11:08:44 <schellsan> i was trying to use cabal-dev, which led me to this situation
11:08:45 * elliott should read more than five lines of context.
11:08:57 <schellsan> Saizan:i think i have
11:08:58 <Saizan> Philippa_: yeah
11:09:17 <Saizan> schellsan: then do that and reinstall the platform too
11:09:33 <schellsan> Saizan: shoot - i did that
11:09:51 <schellsan> but now when i do a ghc-pkg check it tells me that cabal is broken
11:10:13 <typoclass> schellsan: if you can't figure it out, you could hpaste the output of ghc-pkg list, ghc-pkg check, or the failing cabal commands (don't forget -v3). folks here can usually pretty quickly come up with something
11:10:27 <Saizan> have you reinstalled ghc too?
11:10:38 <Eduard_Munteanu> Saizan: hm, yes, though that's a bit strange, just using it on the last arg.
11:10:51 <Philippa_> Eduard_Munteanu: you have to join the entire expression, alas
11:10:52 <Saizan> (i thought that was incldued in the platform but i might be wrong)
11:11:21 <monochrom> binary Haskell Platform comes with GHC. source code doesn't
11:11:23 <Philippa_> would make for a nice case for regular mixfix
11:11:25 <applicative> schellsan: ghc-pkg list will also tell you where the global package registry is
11:11:41 <applicative> schellsan: or whatever it's called
11:11:50 <Eduard_Munteanu> I wonder if an alternative to <$> can do the joining.
11:11:57 <monochrom> remember: to build GHC, you must first have GHC :)
11:12:08 <Philippa_> it can't, the <*>s have to happen in the middle
11:12:15 <Philippa_> (*syntactically* in the middle)
11:12:26 <Eduard_Munteanu> Hm, yes, it associates the "wrong" way.
11:12:43 <Philippa_> and we can't write the worrying section that'd make it work ;-)
11:13:01 * Philippa_ is reminded of what "sectioning" someone means in the UK
11:13:12 <Saizan> you could have a liftMMn
11:13:21 <Saizan> with enough typeclass hackery
11:13:33 <Philippa_> or join of idiom brackets
11:13:50 <Philippa_> (I so want to rename join to runMonadM!)
11:14:13 <hpaste> “Anonymous Coward” pasted “ghc-pkg check” at http://hpaste.org/81426
11:14:18 <Eduard_Munteanu> Hmmm... perhaps there's some other operator so I could write    f <$'> (bar <*'> baz <*'> boo)  without the parens and "'"s
11:14:29 <schellsan> ha - am i anonymous coward?
11:14:35 <Eduard_Munteanu> I probably need to think this through.
11:14:49 <c_wraith> Philippa_: You know how many terrible questions that would cause to be asked of us? :)
11:14:52 <applicative> hah, http://en.wikipedia.org/wiki/Sectioning
11:15:57 <applicative> schellsan: I take it you tried to install a new cabal-install ?
11:15:58 <Philippa_> c_wraith: of course :-)
11:16:11 <monochrom> Haskell Platform does not come with Cabal-1.16.*.  Repeat: does not.
11:16:16 <startling> I want to cooperatively multitask between a bunch of things organized hierarchically that can send and receive messages among themselves. Eventually, I'd like to have some of these things on a different machine. What should I use?
11:16:27 <schellsan> applicative: a couple times, a while ago
11:16:38 <schellsan> cabal was telling me there was a newer version
11:16:51 <startling> the other thing I want to be able to do is serialize and deserialize each thing's state.
11:16:53 <monochrom> ignore newer version
11:16:53 <applicative> I think that's the problem, if you do ghc-pkg list Cabal does it mention two versions?
11:17:10 <ski> Philippa_ : hm, what would it do ?
11:17:16 <schellsan> Cabal-1.14.0 Cabal-1.16.0.3
11:17:18 <startling> 'pipes' look nice, but maybe this would be better served just by a function in State and existential quantification.
11:17:21 <schellsan> so yes...
11:17:23 <applicative> monochrom is here to bemoan 'cabal install cabal-install'
11:17:27 <applicative> rightly enough
11:17:34 <Saizan> 19:54        ski : BlindRadish : perhaps you should just paste the code you'd want to rewrite, so that we can have a look at it ?
11:17:37 <Saizan> 19:55  BlindRadi : i was hoping to assume the value of things i left out
11:17:40 <Saizan> 19:55     otters : Text.Printf does it
11:17:41 <Saizan> sorry.
11:17:42 <startling> yeah, it should be cabal install cabal install
11:17:42 <schellsan> should i unregister the new one?
11:17:44 <startling> for consistency
11:17:50 <monochrom> haha
11:18:00 <Philippa_> ski: rollGroups? It'd take a list of (sides,count) pairs and return a list of lists of dice rolls
11:18:09 <applicative> schellsan: It might not be too late to ghc-pkg unregister Cabal-1.16.0.3
11:18:17 <ski> ah, ok
11:18:26 <applicative> schellsan: this will tell you what else should be unregistered first
11:18:28 <monochrom> (if you already have sandboxing, you can upgrade cabal-install, then copy out the exe, then throw away the sandbox)
11:18:43 <ski> > let roll = state . randomR . (,) 1; sumMany = foldM (liftM . (+)) 0 .: replicate in (`evalState` mkStdGen 123456) $ roll 6
11:18:43 <applicative> schellsan: yes, unregister it, for sure
11:18:46 <lambdabot>   4
11:18:51 <ski> > let roll = state . randomR . (,) 1; sumMany = foldM (liftM . (+)) 0 .: replicate in (`evalState` mkStdGen 123456) $ replicateM 3 (roll 6)
11:18:53 <lambdabot>   [4,5,2]
11:18:59 <ski> > let roll = state . randomR . (,) 1; sumMany = foldM (liftM . (+)) 0 .: replicate in (`evalState` mkStdGen 123456) $ sumMany 3 (roll 6)
11:19:01 <lambdabot>   11
11:19:07 <ski> BlastHardcheese : ^ that's one variant
11:19:20 <ski> BlindRadish : er, i meant to direct that to you
11:19:22 <schellsan> applicative: seems that executed fine
11:19:28 <applicative> schellsan: I think in the past there was a bit more magic to keep this from happening by accident, but I think it is difficult to make it rational
11:19:43 <applicative> schellsan: does ghc-pkg check look okay>
11:20:11 <schellsan> applicative: yeah, it now just complains about haddock-interfaces
11:20:29 <applicative> schellsan: I mean it is hard to make reinstalling the Cabal library impossible. I think it isn't always chaos, for one thing -- only for most of us.
11:21:03 <monochrom> one package in Haskell Platform has a haddock problem. this is normal.
11:21:16 <applicative> schellsan: that's not important. I wonder if you should put the signal for haddocking in your ~/.cabal/config ?
11:21:17 * hackagebot hs-excelx 0.6.0.0 - HS-Excelx provides basic read-only access to Excel 2007 and 2010 documents in XLSX format.  http://hackage.haskell.org/package/hs-excelx-0.6.0.0 (MarkBaran)
11:21:30 <schellsan> applicative: i think the biggest problem is that i don't understand how it works yet, so i thrash a lot
11:21:52 <applicative> schellsan: yes of course
11:22:16 * applicative has many scars...
11:22:37 <schellsan> hey - just looking at the cabal config file is helpfull...
11:22:41 <monochrom> format your disk to remove all scars
11:22:56 <applicative> schellsan: I don't think you'll be able to install cabal dev without a complex specification that the version of the Cabal library you want is the one you have.
11:23:15 <monochrom> --constraint='Cabal installed'
11:23:38 <monochrom> can also be entered into ~/.cabal/config.  constraint: Cabal installed
11:23:43 <applicative> schellsan: not that it has a profiling libraries bit, this should be checked yes when you first start using cabal-install after getting a new ghc , when you start wanting to profile
11:24:03 <applicative> schellsan: but perhaps that is not for now.
11:24:17 <applicative> monochrom: ah! Cabal installed
11:24:34 <kini> How would you fill in this blank? If f :: a -> b, and x :: Integer, then Integer -> b is the _____ type of f in the expression f x
11:24:34 <schellsan> applicative: yes, i think most of what you are talking about is over my head atm
11:24:37 <monochrom> it is somewhat new
11:24:42 <amiller_> ok, so now i'm going to ask for help with a simple applicative instance, i think - given a binary search tree: data Tree a x = Tip | Bin x a x, and a lookupalgebra :: Ord a => Tree a Bool -> Bool, how can I make an applicative traversal that gives me a trace of the form [Tree a ()]
11:24:53 <kini> computed? reduced? specifized...?
11:25:07 <amiller_> the trace should only correspond to the log N or so nodes visited rather than the whole tree
11:25:15 <monochrom> unfortunately, I can't call it "undocumented" because "cabal install --help" talks about it :)
11:25:29 <startling> how about this: is there something like State that guarantees that the state can be serialized and deserialized losslessly?
11:25:32 <amiller_> i got somewhere close using apomorphisms in recursion-schemes where I needed an Either type in there somewhere to explicitly terminate the recursion
11:25:53 <schellsan> thanks for helping guys
11:26:08 <Eduard_Munteanu> startling: how is that different from a constraint on your state type? Why is this State-specific?
11:26:15 <applicative> schellsan: monochrom is saying you should uncomment the line of .cabal/config that says -- constraint: to make it read thus constraint: Cabal installed
11:26:32 <Eduard_Munteanu> startling: I mean you could ask that of any datatype.
11:26:53 <startling> hmm, I guess I want something with attached initialization and finalization (in IO, maybe?), too
11:27:21 <applicative> schellsan: in the olden days, cabal install was willing to reinstall the base libraries even; that seems to have been taken care of
11:28:01 <schellsan> applicative: k - edited the cabal/config
11:28:34 <monochrom> for each package that comes with GHC or Haskell Platform, add such a line. one line per package, cannot be merged
11:29:14 <monochrom> alternatively, manually type in --constraint='mtl installed' etc at every "cabal install"
11:29:56 <Eduard_Munteanu> startling: maybe ResourceT?
11:29:58 <applicative> schellsan: in general, you want to keep things already installed from being installed in a new form, especially things that came with your compiler, i.e. whatever is globally installed
11:30:05 <Eduard_Munteanu> I'm not entirely sure what you want.
11:30:27 <applicative> schellsan: ah, monochrom is continuing with this advice
11:30:33 <schellsan> monochrom: what are the base packages?
11:31:26 <schellsan> everything that comes with a clean platform install?
11:31:31 <monochrom> yes
11:32:05 <schellsan> but i should leave off the version numbers?
11:32:19 <monochrom> the version number is "installed"
11:32:32 <schellsan> ah, i see
11:34:18 <Eduard_Munteanu> What's a good Haskell interval map?
11:34:19 <ski> kini : perhaps "specialized"
11:34:35 <kini> ski: hmm, that sounds good I guess. Thanks :)
11:35:26 <Eduard_Munteanu> That is, some map where the key is an interval, and lookups match if the value is in the interval.
11:38:55 <hpaste> applicative pasted “sensible constraints” at http://hpaste.org/81428
11:39:46 <monochrom> old, old, time, locale
11:39:48 <applicative> schellsan: I added these to my config file. Immediately, testing it, it proved its worth, cabal install acme-now was trying to reinstall time without it
11:40:12 <schellsan> applicative: mine seems to have more contstraints
11:40:23 <applicative> ah damn monocrom, i cut at - and following
11:40:54 <applicative> schellsan: yeah, the whole platform presumably another pile of libraries.
11:41:00 <schellsan> hey, but cabal-dev is installing
11:41:07 <applicative> schellsan: I have to say, I already think this is a good plan, but experience will tell
11:41:11 <schellsan> wow - that was a fast install
11:42:01 <applicative> monochrom: thanks, I now exclude old-time etc
11:42:30 <schellsan> applicative: so to recap, these constraints are just telling cabal not to reinstall those packages, and to treat the installed as the required version?
11:42:45 <applicative> yes
11:43:33 <schellsan> thanks again
11:43:38 <applicative> schellsan: so somethings won't install. in those cases you will need to reflect, but I think this will either be for super-bleeding edge things, or unmaintained things.
11:43:48 <applicative> or rather, it will tend to be those.
11:44:04 <schellsan> okay, cool. i feel like i leveled up
11:46:18 * hackagebot mime-types 0.1.0.3 - Basic mime-type handling types and functions  http://hackage.haskell.org/package/mime-types-0.1.0.3 (MichaelSnoyman)
11:46:20 * hackagebot wai 1.3.0.2 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.3.0.2 (MichaelSnoyman)
11:46:22 * hackagebot wai-eventsource 1.3.0.2 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-1.3.0.2 (MichaelSnoyman)
11:46:24 * hackagebot wai-extra 1.3.2.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.2.1 (MichaelSnoyman)
11:47:33 <hpaste> applicative annotated “sensible constraints” with “genuinely sensible constraints for ~/.cabal/config ” at http://hpaste.org/81428#a81430
11:49:14 <monochrom> applicative: you have "template" instead of "template-haskell" :)
11:49:29 <applicative> grrrrr
11:49:36 <monochrom> bin is really bin-package-db
11:50:24 <applicative> and integer-gmp, we see why I should be forbidden to use regexen
11:51:33 <hpaste> applicative annotated “sensible constraints” with “even closer to genuinely sensible constraints for ~/.cabal/config  ” at http://hpaste.org/81428#a81431
11:56:18 * hackagebot wai-handler-launch 1.3.1.2 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.3.1.2 (MichaelSnoyman)
11:56:20 * hackagebot wai-test 1.3.0.1 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.3.0.1 (MichaelSnoyman)
11:56:22 * hackagebot warp 1.3.7.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.7.2 (MichaelSnoyman)
12:04:39 <schellsan> okay - one more hurdle
12:05:36 <schellsan> i'm trying to start a new project with cabal-dev
12:06:01 <hpaste> schellsan pasted “benderbot cabal-dev” at http://hpaste.org/81433
12:06:46 <schellsan> i think i just don't understand the requirements of cabal-dev
12:09:16 <hpaste> applicative annotated “benderbot cabal-dev” with “benderbot cabal-dev (annotation)” at http://hpaste.org/81433#a81434
12:09:34 <applicative> schellsan: here's what I use for a model with an executable ^^^
12:10:15 * applicative doesn't use cabal-dev but figures it's the syntax of the cabal file thats at issue
12:14:48 <hpaste> schellsan annotated “benderbot cabal-dev” with “benderbot cabal-dev (annotation) (annotation)” at http://hpaste.org/81433#a81435
12:15:47 <hpaste> schellsan annotated “benderbot cabal-dev” with “benderbot cabal-dev (annotation) (annotation) (annotation)” at http://hpaste.org/81433#a81436
12:16:18 <schellsan> applicative: that's my update and the results - i'm now reading the user's guide...
12:17:32 <applicative> schellsan: is there a cabal-dev init ?
12:17:44 <schellsan> maybe that's it
12:18:08 <schellsan> hah - yeah - there is
12:18:15 <schellsan> like i said, i'm thrashing
12:18:24 <applicative> it will write these things for you, asking obvious questions or maybe you can just do cabal init, getting your present .cabal file out of the way
12:18:43 <schellsan> cabal init was what i did initially
12:18:59 <schellsan> but really, i may not be solving the problem i think i am
12:19:17 <applicative> hm
12:19:25 <merijn> schellsan: I've used cabal init to produce a .cabal file and then cabal-dev for installation, should Just Work
12:19:28 <schellsan> i'm just trying not to run into the dependency problems i have in the past two projects i've taken up
12:19:36 <merijn> Since generating the .cabal file is the only thing cabal init does
12:19:43 <applicative> anyway, for that error you just need to do touch LICENSE or something
12:20:10 <schellsan> huh - wow
12:20:12 <schellsan> that was it
12:20:29 <merijn> Cabal won't let you have an empty license file (and rightfully so)
12:20:32 <ryant5000> does anyone know of a library function to canonicalize a URL?  i.e.: make it all lowercase, deal with unicode, etc.
12:20:33 <schellsan> i didn't think it would refuse to build just because of the license file
12:20:46 <merijn> Unlicensed code is useless to anyone but the owner
12:20:52 <merijn> eh
12:20:54 <merijn> writer, even
12:21:18 <schellsan> well - it works with an empty license file, but not without one
12:21:19 * hackagebot split 0.2.1.2 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.2.1.2 (BrentYorgey)
12:21:37 <merijn> schellsan: Well yeah, it can't really check whether you used an appropriate license
12:21:47 <applicative> schellsan: but of course you should use license:             BSD3
12:21:56 <Heffalump> ryant5000: http://hackage.haskell.org/packages/archive/network/2.1.0.0/doc/html/Network-URI.html#6 ?
12:22:03 <merijn> schellsan: cabal init should include a copy of the license file if you select one of the common ones (i.e. BSD3, etc)
12:22:17 <schellsan> cool - will do next time
12:22:29 <schellsan> thanks again
12:22:42 <applicative> schellsan: like byorgey 's split package http://hub.darcs.net/byorgey/split/browse/LICENSE
12:23:10 <ryant5000> Heffalump: thanks; i was searching for URL, not URI
12:23:18 <applicative> schellsan: as merijn says it will print bsd3 for you
12:24:37 <schellsan> applicative: what do you use to sort out all the dependency problems?
12:25:43 * applicative just calculates and sends patches
12:26:18 <merijn> I don't really run into that many (except maybe Yesod, but I've decided I don't really like Yesod)
12:26:35 <merijn> I always wonder what all these people are doing to run into a billion dependency issues :>
12:27:19 <applicative> schellsan: with experience you avoid most of them. One cause is using ghc+cabal for a bit, and then doing cabal update and using it more a few months later
12:28:30 <applicative> schellsan: when you have a 'fresh install' you should install all your familiar packages together in one command so cabal can reason about the main things you need at once.
12:28:44 <schellsan> hmmm - i've run into it using yesod and then persistent, which is part of yesod - so maybe that's my prob
12:28:51 <applicative> schellsan: in theory cabal install world does this, I guess, but I haven't used it, I'm not sure.
12:29:19 <applicative> schellsan: yesod is an amazingly complicated install, it totally outdoes everything from the past,
12:29:51 <schellsan> why must it be so complicated? #rhetorical
12:30:29 <jfischoff> how hard would it be to add GADT support to fay?
12:30:45 <applicative> schellsan: also, do e..g cabal install yesod --dry-run which may clue you into curiosities
12:31:44 <jfischoff> One of the benefits of the Haskell ecosystem is that packages have a very fine granularity.
12:31:57 <jfischoff> This makes framework install complicated
12:31:59 <applicative> schellsan: I think it isn't all that complicated, or maybe it is, you just habituate to a list of do's and don't do's
12:32:51 <typoclass> applicative: i agree that in the end it's all manageable, but sometimes i wish that list was written down explicitly somewhere
12:33:00 <typoclass> (any links?)
12:33:47 <merijn> schellsan: Yesod uses *a lot* of abstraction to get things done "automatically" behind the scenes. Since a lot of these things are individually useful (as often happens in haskell) they get split off in separate packages. But the dependency bounds on these tons of small packages make Yesod a finnicky animal when it comes to playing nice with other stuff
12:34:08 <merijn> schellsan: The usual approach is "cabal install yesod" (or is it yesod-platform) first, and anything else later
12:35:09 <schellsan> i see, i appreciate the explaination
12:35:18 <jfischoff> All of the complaints about the difficulty of installing yesod are a indication to me that Haskell is growing more than anything.
12:36:14 <applicative> schellsan: I think you should just get rid of the locally installed things periodically, if you do 'cabal update' at all.
12:36:48 <schellsan> with my free time projects i like to do everything correct the first time but i see that (more than other langs) with haskell that means having a deep understanding of what you're doing
12:36:50 <applicative> yesod is supposed to be installed with some sandbox mechanism in theory though, which sort of amounts to the same.
12:37:08 <Philippa_> merijn: that's one reason my current project's reinventing the free monad and cofree comonad for itself, btw
12:37:11 <typoclass> jfischoff: i dunno, last i heard, the cabal folks were working on e.g. the new sandbox thing. i do think they see it as a problem, not just "well it's growing"
12:37:22 <Philippa_> well, that and actually subsequent refactorings are turning them into something else
12:37:30 <merijn> schellsan: Haskell's abstraction leads to much smaller/more ggeneral libraries than many others. Take a look at for example the monad-loops package and try to think of any other language where something like that makes sense
12:37:34 <jfischoff>  Built in sandboxing will be awesome
12:37:44 <jfischoff> but cabal is already awesome
12:37:55 <merijn> @hackage monad-loops
12:37:55 <lambdabot> http://hackage.haskell.org/package/monad-loops
12:38:01 <jfischoff> I'm not saying that it should not be improved
12:38:25 <schellsan-afk> brb
12:38:43 <jfischoff> I am just saying that the rising chorus that cabal is difficult, means two things.
12:39:17 <applicative> merijn: I think most of monad-loops is built into other languages
12:40:17 * applicative is tempted to use `forkAtomLoop` for no good reason
12:43:57 <linduxed> there's fst and snd, but is there a Prelude function for third?
12:44:00 <linduxed> for triplets that is
12:44:29 <typoclass> linduxed: not that i know of. but lens has it, of course
12:45:12 <linduxed> typoclass: ok
12:45:27 <linduxed> not a big deal, will just write a function of my own then
12:45:40 <linduxed> haven't gotten to try lens yet, heard it's handy
12:45:47 <linduxed> don't know what it does though :-P
12:46:05 <edwardk> > (1,2,3)^._3
12:46:07 <lambdabot>   3
12:46:13 <edwardk> there is no prelude function for it
12:46:30 <edwardk> > (1,2,3) & _3 .~ "hello"
12:46:32 <lambdabot>  Terminated
12:46:34 <clahey> linduxed: Note that fst doesn't work for triplets either.
12:46:35 <edwardk> > (1,2,3) & _3 .~ "hello"
12:46:37 <lambdabot>   (1,2,"hello")
12:46:46 <linduxed> clahey: yeah i know
12:47:05 <linduxed> edwardk: that's pretty neat
12:50:14 <fmap> > (1,2,"hello") & _3 id
12:50:16 <lambdabot>   [(1,2,'h'),(1,2,'e'),(1,2,'l'),(1,2,'l'),(1,2,'o')]
12:50:44 <johnw> fmap: that's interesting, I've never seen that usage before
12:50:59 <hpaste> alanz pasted “Control.Lens.Zipper on Tree String” at http://hpaste.org/81438
12:51:18 <applicative> @type _3 id
12:51:20 <lambdabot> (Functor f, Field3 s t (f b) b) => s -> f t
12:51:40 <alanz> Can anyone give some pointers on traversing a Tree String using a zipper?
12:53:07 <startling> alanz: um, what do you want to do?
12:53:40 <alanz> I can go down in the tree, but I don't know how to move the focus through the branches, until I get one I care about
12:54:15 <alanz> I am sure it is something very basic
12:54:59 <alanz> The example is in my hpaste above
12:59:17 <fmap> > sequenceAOf _3 (1,2,"hello")
12:59:19 <lambdabot>   [(1,2,'h'),(1,2,'e'),(1,2,'l'),(1,2,'l'),(1,2,'o')]
12:59:25 <fmap> johnw: that's the same thing ^
13:00:43 <johnw> thanks
13:26:20 * hackagebot pointedlist 0.4.0.4 - A zipper-like comonad which works as a list, tracking a position.  http://hackage.haskell.org/package/pointedlist-0.4.0.4 (JeffWheeler)
13:27:31 <edwardk> so let me get this straight, the pointedlist comonad isn't an instance of comonad.
13:28:09 <edwardk> and breaks on ghc 7.6
13:30:15 <end3rW> good evening
13:31:44 <fmap> fclabels???
13:31:55 <byorgey> hi end3rW
13:32:12 <end3rW> I'm currently implementing bind for a newtype around Either (20 Intermediate Haskell Problems again). Type Signature is (a -> m b) -> m a -> m b. Why can't I write     banana f y@(EitherLeft (Right x))   = y
13:32:23 <ciphergoth> Is there a standard thing that's like an array but pure functional and mutable in log n time?
13:32:42 <ciphergoth> Or should I use a map?
13:32:44 <ijp> a tree
13:33:01 <byorgey> end3rW: y has type m a, but banana needs to output something of type  m b
13:33:11 <ciphergoth> ijp: that's what I'm anticipating will back it, but I don't want to implement it myself
13:33:12 <byorgey> end3rW: you're going to need to use f somehow
13:33:14 <ijp> ciphergoth: maybe you want Data.Sequence
13:33:33 <end3rW> Does it fail because m a is expected to be different from m b?
13:33:53 <end3rW> byorgey: Right is my error case in this instance
13:34:01 <Philippa_> ciphergoth: IntMap?
13:34:02 <srhb> edwardk: It must be _possible_ to return m b
13:34:07 <srhb> oops
13:34:10 <srhb> end3rW: ^^^
13:34:11 <end3rW> banana _ (EitherLeft (Right x)) = EitherLeft . Right $ x works, but why? It is exactly the same type, isn't it?
13:34:13 <edwardk> ?
13:34:26 <ciphergoth> Philippa_, will HOogle that!
13:34:36 <byorgey> end3rW: it fails because m a *could* be different from m b.  A function type  (a -> m b) -> m a -> m b   is a promise that the implementation will work no matter what types are chosen for m, a, and b
13:34:39 <srhb> edwardk: Sorry, not for you.
13:35:11 <edwardk> end3rW: you're changing the type of y. syntactically that substitution makes sense but its changing from m a to  m b
13:35:29 <ijp> ciphergoth: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
13:35:30 <byorgey> end3rW: your implementation does not satisfy that promise because it requires a and b to be the same.
13:35:34 <end3rW> Thanks, byorgey and edwardk. Sounds reasonable
13:35:46 <ciphergoth> ijp: already there :) thanks!
13:36:02 <edwardk> newtype Foo a = Foo Int; I can't write bah :: Foo a -> Foo b; bah = id;
13:36:15 <end3rW> So there's no way to shorten the expression other than applying the value constructor to x?
13:36:27 <edwardk> matching on the constructor feels it off, and you can put it back on
13:36:56 <byorgey> end3rW: banana _ (EitherLeft (Right x)) = EitherLeft . Right $ x   works?   I doubt that.
13:37:22 <byorgey> oh, what's the definition of EitherLeft?
13:37:44 <end3rW> newtype EitherLeft b a = EitherLeft (Either a b)
13:37:44 <end3rW> newtype EitherRight a b = EitherRight (Either a b)
13:38:02 <end3rW> I guess I'm supposed to choose Right as correct case for EitherLeft and the other way round
13:38:15 <end3rW> since Right is the 'valid' case for Either as well
13:38:31 <byorgey> end3rW: ohhh, I see
13:38:53 <end3rW> but I already implemented the functor the other way round so I simply stick to it
13:38:58 <byorgey> end3rW: I was a bit confused
13:39:04 <byorgey> end3rW: no, I think what you have is right
13:39:19 <end3rW> Sorry, should have posted the newtype defs.
13:39:26 <ciphergoth> Data.Sequence is *exactly* what I was looking for I think!
13:39:48 <byorgey> end3rW: it is a bit subtle that banana _ (EitherLeft (Right x)) = EitherLeft . Right $ x  works but  banana _ y@(...) = y  doesn't
13:40:02 <startling> end3rW: you want to have two different Functor instances? might want to take a look at the 'bifunctors' package or, more generally, 'lens'
13:40:29 <byorgey> startling: I doubt it, end3rW is doing "20 Intermediate Haskell Problems"
13:40:32 <end3rW> startling: It's an exercise, implementing type instances
13:40:36 <startling> oh, I see.
13:40:47 <startling> well, if this was real code you would. :)
13:40:53 <c_wraith> Is that the set that's entirely "write these instances"?
13:41:14 <edwardk> > over _Left (+1) (Left 2)
13:41:16 <lambdabot>   Left 3
13:41:19 <end3rW> byorgey: Yes, it is right. I missed that EitherLeft b a wraps around Either a b, flipped parameters
13:41:36 <end3rW> c_wraith: If there's only one, yes I suppose
13:41:37 <byorgey> end3rW: basically Haskell is quite picky about types.  y has the type it has, and no other, even though a different value constructed in exactly the same way could have a different type
13:41:48 <edwardk> also EitherLeft = Flip Either using 'bifunctors'
13:41:56 <byorgey> end3rW: that's why you can't just return y (because it has the wrong type), but have to take it apart and assemble an identical copy
13:42:09 <byorgey> ...an identical copy with a different type
13:42:54 <end3rW> Thanks, byorgey. I understand the reasoning behind the decision now, but have been wondering yesterday
13:43:38 <end3rW> edwardk: So bifunctors are functions operating on type constructors?
13:44:24 <edwardk> a bifunctor is a typeclass. class Bifunctor p where bimap :: (a -> b) -> (c -> d) -> p a c -> p b d
13:44:34 <edwardk> there is a valid Bifunctor instance for Either
13:44:49 <edwardk> instance Bifunctor Either where bimap f g (Left a) = Left (f a); bimap f g (Right b) = Right (g b)
13:44:59 <edwardk> but we can also make up
13:45:07 <edwardk> newtype Flip p a b = Flip { runFlip :: p b a }
13:45:15 <edwardk> and swap the args to bimap
13:45:21 <edwardk> instance Bifunctor p => Bifunctor (Flip p) where
13:45:42 <edwardk> bimap f g = Flip . bimap g f . runFlip
13:46:01 <edwardk> then Flip Either works, Flip (,) works, Flip Const, etc.
13:46:16 <end3rW> edwardk: Nice! :)
13:46:26 <frerich__> Is there some reason other than backwards compatibility because of which 'OverloadedStrings' is not enabled by default? It's always the first extension I enable...
13:46:35 <jfischoff> unsafe
13:46:38 <edwardk> frerich__: is really really screws up type inference
13:46:39 <jfischoff> I guess
13:46:53 <edwardk> frerich__: in particular it was a bad choice the way the default instance for String works.
13:46:57 <frerich__> Hmmm....
13:47:03 <edwardk> as it stands instance IsString String infers very poorly
13:47:13 <edwardk> because if i write length "foo"
13:47:16 <end3rW> Thanks for your explanation. Kind of expected some obscure construct, but it all boils down to type classes, neat
13:47:16 <edwardk> it doesn't figure it out
13:47:27 <jfischoff> it doesn't all save me keystrokes but I still use it
13:47:35 <edwardk> because all it knows is that you have IsString [a]  but it doesn't know what 'a' is
13:48:06 <edwardk> frerich__: if the instance had been written as instance a ~ Char => IsString [a]
13:48:50 <edwardk> then you'd have comparable enough inference to string that it would suck a lot less, but as it is now, turning on that extension causes the vast majority of my code to not compile
13:49:13 <frerich__> Hmm, interesting. Not the kind of answer I expected, reading http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/type-class-extensions.html#overloaded-strings made it sounds rather plausible.
13:49:33 <edwardk> that said, OverloadedStrings still interacts poorly with almost any sort of polymorphic consumption, e.g. traversable, foldable, etc.
13:50:24 <edwardk> and those are far more valuable to me in practice than overloading strings or a few types.
13:51:09 <srruby> can I give a type signature to "let" variables?
13:51:09 <jfischoff> yes I imagine that is true :)
13:51:22 <thoughtpolice> srruby: you sure can!
13:51:30 <thoughtpolice> > let f :: Int -> Int; f = (+1) in f 1
13:51:32 <lambdabot>   2
13:51:55 <edwardk> note this doesn't affect most other overloadings, like the ones we have for integer literals, etc. because those predominantly are applied to things that are valid haskell 98 types.
13:52:13 <thoughtpolice> srruby: you can either seperate with a semicolon, or whitespace. the definition of 'f' just has to vertically align with where the type is. the usual rules
13:52:28 <frerich__> edwardk: Sorry if I'm being dense here, I'm trying to dissect why 'length "foo"' does not compile with the overloaded strings extension enabled...
13:52:30 <edwardk> as it stands the OverloadedStrings uses a FlexibleInstance for String.
13:52:31 <jfischoff> > let a = 1 :: Int
13:52:33 <lambdabot>   not an expression: `let a = 1 :: Int'
13:52:42 <edwardk> frerich__: all it knows is that you want IsString [a]
13:52:46 <edwardk> it doesn't know that a = Char
13:53:11 <frerich__> edwardk: Hold on, what is "it"? Length just want an [a] and the type of "foo" would be, hm, [a] ?
13:53:55 <frerich__> Or maybe the type of 'foo' is actually 'IsString a => a'...
13:53:59 <edwardk> length :: [a] -> Int;    "foo" :: IsString x => x;   length "foo" tells you x ~ [a]. so you wind up needing IsString [a]   -- but we know nothing else about 'a'
13:54:12 <ciphergoth> huh, actually Data.Sequence won't do it - I'd like to be able to do a binary chop in faster than (log n)^2 time
13:54:13 <edwardk> therefore it craps out
13:54:15 <srruby> thoughtpolice: Thanks! I didn't realize about the vertical alignement.
13:54:52 <edwardk> the default declaration doesn't help because we've already refined it. its no longer the IsString x instance we're looking for, its 'a' and defaulting doesn't pick anything sensible for it
13:55:48 <edwardk> it 'almost works' well enough that a lot of people are willing to live with it, but that is hardly a ringing endorsement
13:56:19 <frerich__> edwardk: Hmm, I think I get it now, thanks! Doesn't seem like a terribly contrived example, makes you wonder why this wasn't noticed earlier. I suppose that there was some sort of review on a mailing list or so before the extension was incorporated?
13:56:25 <edwardk> ciphergoth: what are your asymptotic constraints?
13:56:46 <edwardk> frerich__: i think lennart just went ahead and implemented it or something.
13:57:09 <thoughtpolice> that's what i remember, too. lennart just offered a patch and it was accepted, to be more 'in line' with overloaded integer literals IIRC
13:57:14 <edwardk> ciphergoth: i spent a lot of time a few years ago looking at ways to make partitionable trees for load-balancing, splitting
13:57:17 <ciphergoth> edwardk: I want a data structure I can append an element to in log n time, modify at an index in log n time, and binary chop in log n time
13:57:24 <ciphergoth> edwardk: it's not very complex
13:57:31 <ciphergoth> just want to see if someone's done it for me
13:57:53 <edwardk> ciphergoth: Data.Sequence
13:57:57 <edwardk> split is O(log n)
13:58:36 <edwardk> O (log (min (k, n - k))) technically
13:58:44 <ciphergoth> you mean splitAt?
13:58:48 <edwardk> basically you only pay the log of your distance from either side
13:58:49 <edwardk> yes
13:59:25 <ciphergoth> oh yeah, take and drop
13:59:35 <ciphergoth> thank you!
13:59:37 <edwardk> size is O(1). dividing that size in half is O(1), using splitAt is O(log(n)). so you can chop in O(log n)
13:59:41 <ciphergoth> got it
14:00:47 <thoughtpolice> Data.Sequence has got to be at the top of my "underused but well appreciated" module list
14:01:18 <thoughtpolice> edwardk: :O you released trifecta!
14:01:21 * hackagebot Adaptive 0.23 - Library for incremental computing.  http://hackage.haskell.org/package/Adaptive-0.23 (MagnusCarlsson)
14:01:24 <mizu_no_oto> Has anyone ever tried making a genetic algorithm that produces Haskell code, out of curiosity?  It seems to me that the type system might make Haskell a better choice than other languages recently suggested on /r/programming...
14:01:27 <SoleSoul> Hi! Half beginner here. When receiving an Either in an IO do block as a result of an external function call, how do I get the actual result? I don't know the type of the result. I can "case of" on it and assign the resuslt to a varible but I still don't know the type.
14:01:29 <edwardk> just to get it out there
14:01:36 <edwardk> it'd been like 6 months since i shipped a version
14:01:42 <edwardk> and i wasn't going back to the old style
14:02:05 <thoughtpolice> that's... literally an uncountable amount of time as far as you're concerned, right?
14:02:18 <edwardk> thoughtpolice: pretty much
14:02:21 <edwardk> stone age at least
14:02:27 <SoleSoul> (currently I couldn't even come up with a code that can even compile)
14:03:08 <c_wraith> SoleSoul: If you don't know the type, you can't do anything with it. You'll need to specify a type if you want to do something concretely with it. (If you specify a class, that's enough to know certain operations you can do on it without knowing the exact type)
14:03:24 <thoughtpolice> edwardk: heh, a few weeks in -lens is like going back to reading sumerian, so that sounds about right
14:03:40 <edwardk> =)
14:04:12 <SoleSoul> c_wraith: I know the two possible types, i.e. I know what can be "a" and "b" in Left a and Right b, but I don't know which one of them will be returned.
14:04:37 <c_wraith> SoleSoul: ah.  So in each branch of your case statement, you know what type the value is.
14:04:48 <mizu_no_oto> either :: (a -> c) -> (b -> c) -> Either a b -> c
14:04:52 <c_wraith> SoleSoul: the two branches of the case statement will need to have the same type, though
14:05:27 <c_wraith> SoleSoul: since you mentioned you were in IO, it's likely you want the branches to have the type IO (), where the type of the value inside the Either no longer matters
14:05:31 <SoleSoul> c_wraith: yeah. but does that imply that I need to create two separate do blocks, each for a possible result of the either?
14:05:43 <c_wraith> SoleSoul: yes, that's something you'll often want
14:05:44 <monochrom> yes, two blocks
14:06:22 <mizu_no_oto> You can also just use the 'either' function in Data.Either rather than explicitly using a case statement
14:06:28 <SoleSoul> wouldn't that create a nasty indentation? I mean, a few branches and I need to scroll horizontally
14:06:41 <monochrom> yes, use a 16:9 screen
14:06:49 <SoleSoul> lol u serious?
14:06:50 <pnielsen> and/or indent by less spaces
14:06:56 <monochrom> but no, the indentation is not nasty IMO
14:07:03 <pnielsen> 8 space indent and haskell is no-no
14:07:06 <mizu_no_oto> You can put those functions in a where clause...
14:07:21 <SoleSoul> I don't like indentations which do not get unindented after some time
14:07:30 <SoleSoul> but I can get used to that I guess
14:08:01 <monochrom> use explicit {;} if you don't want indentation
14:08:03 <c_wraith> SoleSoul: well, you only need to do the things that actually depend on the Either in those two blocks - after that, you can go back to the previous indentation level
14:08:26 <c_wraith> SoleSoul: it's unusual to have more than 2 or 3 lines in each case, with this sort of thing
14:08:27 <SoleSoul> mizu_no_oto: did you say that to me? because I'm afraid I need some more explanation of a link to an example to understand your suggestion
14:08:56 <monochrom> when you used if-then-else, I didn't hear you worry about extra indentation for the two branches. so why suddenly case-of is different?
14:09:13 <mizu_no_oto> SoleSoul: Do you understand the 'either' function?
14:09:26 <mizu_no_oto> :t either
14:09:28 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
14:09:33 <end3rW> How would one implement join with bind and return for any monad? I wanted to pattern match but that would be a type-specific implementation. :/
14:09:34 <SoleSoul> c_wraith: the function is createImage of a graphics library. the return type is an exception or the image
14:10:04 <mauke> @src join
14:10:04 <lambdabot> join x =  x >>= id
14:10:29 <end3rW> Oh wow. That's simple. Meh
14:10:44 <c_wraith> SoleSoul: You can also bind a value from the case expression, so long as the two branches have the same type.  If the branch doesn't have a normal exit for some reason, it will match any type
14:10:46 <SoleSoul> mizu_no_oto: yes, I do. The problem is that I'm not used to haskell's thinking yet and I use a C++ library with haskell bindings so I'm not sure how to do that.
14:11:00 <byorgey> end3rW: simple, but non-obvious if you've never seen it before =)
14:11:38 <SoleSoul> either_image <- createImage 800 600
14:11:40 <end3rW> byorgey: Yes, this kind of spoiled my aha effect
14:11:43 <SoleSoul> let image = case either_image of
14:12:00 <c_wraith> SoleSoul: what do you want to do if the creation failed?
14:12:17 <SoleSoul> c_wraith: I'm guessing quitting is ok here
14:12:26 <end3rW> *light bulb moment would be the more idiomatic translation.
14:13:02 <monochrom> human craves for complicated solutions to simple problems
14:13:34 <byorgey> end3rW: well, if you want to figure something out yourself, don't mention it in #haskell =)
14:14:15 <end3rW> I should've asked for tips :s
14:14:39 <SoleSoul> *give end3rW 50 cents
14:14:49 <end3rW> *hints
14:14:52 <byorgey> even if you ask for tips someone usually goes and spoils it anyway =P
14:14:52 <SoleSoul> :)
14:15:03 <monochrom> hints are hard to give
14:15:11 <SoleSoul>  but fun
14:15:11 <mizu_no_oto> SoleSoul: {do … ; either_image <- createImage 800 600 ; either dispError continueOn either_image ; … } where dispError = { do … } ; continueOn = {do …} -- use appropriate whitespace
14:15:14 <byorgey> also true
14:15:55 <SoleSoul> mizu_no_oto: thanks, give me a moment to understand it :)
14:16:32 <monochrom> A: "Hi how do I write my own dropWhile?" B: "hint: use recursion".  two hours later, A has code of dailywtf quality
14:17:22 <mizu_no_oto> Basically, dispError and continueOn are functions.  You can declare functions in let or where clauses, so you can use that to help control your indentation depth
14:18:36 <SoleSoul> mizu_no_oto: I don't usually use curly braces. What do they do?
14:18:46 <mizu_no_oto> You might also want to consider fmapping over either_image, where fmap :: (b -> c) -> Either a b -> Either a c
14:19:11 <mizu_no_oto> SoleSoul:  curlybraces and semicolons are equivalent to whitespace
14:19:24 <SoleSoul> ok thanks
14:19:38 <mizu_no_oto> They added it to Haskell's grammar to make generating haskell code programattically easier
14:19:51 <SoleSoul> fmap is mapping over functors, right?
14:20:17 <mizu_no_oto> Yeah.  Either is an example of a functor.
14:20:41 <mizu_no_oto> So you can fmap your image processing functions over the image
14:21:29 <mizu_no_oto> and then finally do something like 'either dispErrorAndQuit dispImage modified_either_image'
14:21:42 <SoleSoul> mizu_no_oto: so basically after each such either value my main function must break to two other functions? that's different than C++ :)
14:22:19 <sipa> main is not a function :)
14:22:22 <Nerp> Are there any books you guys would recommend to someone that has no programming experience but would like to learn Haskell?
14:22:48 <SoleSoul> sipa: mm... is it not? or maybe it won't be smart of me to even ask?
14:22:51 <mizu_no_oto> Nerp: Learn you a haskell for great good
14:23:27 <SoleSoul> Nerp: I would pay for an opportunity to follow someone learning Haskell as a first language
14:23:40 <Nerp> mizu_no_oto: Awesome thank you, I was just looking at picking that up on Amazon.
14:23:52 <Nerp> SoleSoul: lol what do you mean?
14:23:53 <pnielsen> Nerp: it's available for free online, but recommend buying it
14:24:01 <SoleSoul> Nerp: btw, I bought this book and it's good.
14:24:06 <mizu_no_oto> Nerp:  It's free, online.  Also, consider something like How to Design Programs
14:24:19 <pnielsen> Nerp: there's often debate about whether it's as easy to learn a functional language first as an imperative one, but most people have already learned imperative languages, so can't tell
14:24:38 <c_wraith> Nerp: http://www.cs.nott.ac.uk/~gmh/book.html is also a good book
14:24:46 <Nerp> mizu_no_oto: I was also going to read "structure and interpretation of computer programs"
14:24:51 <SoleSoul> Nerp: what pnielsen said
14:25:05 <pnielsen> most imperative programmers think it is very hard to learn functional languages, but total newcomers don't -- or at least, that's the theory
14:25:21 <pnielsen> what's difficult is the difference between imperative and functional, not functional languages
14:25:33 <Nerp> well I will probably be on here asking questions as I learn, so you will probably find out how it goes
14:25:51 <SoleSoul> Good luck :)
14:26:21 <Nerp> is it true that Haskell can approach C++ speed when compiled?
14:26:37 <SoleSoul> about 1/3 of C++ speed I would say
14:26:44 <SoleSoul> I mean, 3 times slower
14:27:02 <Nerp> SoleSoul: That's still pretty good
14:27:05 <SoleSoul> compared to other high level languages that's great
14:27:16 <byorgey> Nerp: yes, if you are sufficiently ninja in the mystical dark arts of Haskell optimization
14:27:35 <pnielsen> Nerp: http://paulspontifications.blogspot.com/2013/01/when-haskell-is-faster-than-c.html
14:27:50 <SoleSoul> byorgey: ninja for same speed or for 1/3 speed?
14:27:51 <pnielsen> tl;dr: unoptimized haskell can often be faster than unoptimized C or C++
14:27:56 <mizu_no_oto> Nerp:  Depends on how both codebases are written.  Sufficiently stupid C++ is slow;  sufficiently smart Haskell is blazing fast.
14:28:16 <Nerp> cool, thank you guys for the info
14:29:04 <SoleSoul> mizu_no_oto: I tried basic tail recursion in haskell vs a simple loop in C++ and the C++ code was 3 times faster. I don't know if it says anything but I was curoius :)
14:29:07 <end3rW> Any HINT on how to apply a function inside a monad on a monadic value to get a monadic value? Hoogle gave me "ap"
14:29:45 <Nerp> Would learning Haskell first and then trying to learn something like c++ pose the same issues that people who started with C++ have with Haskell?
14:30:02 <mauke> end3rW: yes, use ap
14:30:05 <end3rW> I'm really not sure if I should read typeclassopedia/RWH before since I'm missing basic concepts or if I got all at my hands and am simply unable to apply it
14:30:13 <pnielsen> Nerp: maybe
14:30:29 <end3rW> mauke: Well, it isn't exactly a monad, but a reimplementation
14:30:30 <pnielsen> my gut says no, but I wouldn't know :)
14:30:55 <mizu_no_oto> SoleSoul: tail recursion doesn't work the same way in Haskell due to laziness.
14:30:57 <sm> end3rW: fmap, as in x <- purefn `fmap` monadicfn, is easy and available by default
14:31:11 <c_wraith> end3rW: I'd at least skim the typeclassopedia now. Don't worry if you don't understand all of it. You can always go back to it later if you want. But it's helpful to have some idea what information is in it.
14:31:19 <dskippy> Hello. I just installed Haskell on my work machine (Windows) to do some quick file processing stuff. I am trying to call readFile on a path and I am getting "permission denied" in WinGHCi. This file, however, opens just fine in my text editor. Does anyone know what permissions WinGHCi is running on in Windows? This program works fine in Linux.
14:31:23 <mauke> sm: your "monadicfn" is wrong
14:31:41 <mauke> end3rW: well, you know where @src ap is :-)
14:31:42 <ion> sm: “Monadic function” tends to refer to something of type a -> M b.
14:31:50 <SoleSoul> mizu_no_oto: about the code snippet you sent me, in the continueOn function, to get the Right value, do't  I have to do "continueOn x =
14:31:53 <SoleSoul> "?
14:31:58 <end3rW> Haha, thanks guys :)
14:32:14 <end3rW> ion: How's m (a -> b) called?
14:32:31 <sm> perhaps I should stick to a more concrete example: n <- read `fmap` getLine
14:32:43 <mizu_no_oto> SoleSoul:  Yes, unless continueOn is in points-free style
14:32:57 <ion> end3rw: An action that results in a function.
14:33:16 <byorgey> end3rW: values of that type don't really have a special name that I know of
14:33:22 <mizu_no_oto> consider "timesFive = (* 5)" vs "timesFive x = x * 5".
14:33:28 <SoleSoul> mizu_no_oto: I think I get it. The thinking is so different. Thank you. I'll try to continue coding now.
14:33:40 <end3rW> I always thought "action" would imply IO monad, so it doesn't?
14:34:49 <boblehest> Everybody keeps saying "all programmers need to know haskell", so here I am again.
14:34:58 <boblehest> Book suggestions anyone?
14:35:17 <Clint> @where lyah
14:35:17 <lambdabot> http://www.learnyouahaskell.com/
14:35:18 <boblehest> currently looking at http://book.realworldhaskell.org
14:35:33 <avpx> boblehest: I really liked LYAH as a beginner, and RWH is a nice step beyond that
14:36:21 <monochrom> use a universal Turing UTM machine if you want to avoid indentation
14:36:49 <boblehest> So your suggesting I read LYAH first?
14:37:30 <mizu_no_oto> boblehest:  It will help build your intuition for a more haskelly way of thinking
14:38:07 <boblehest> Do you have any opinions on this? http://www.amazon.com/Haskell-Logic-Maths-Programming-Computing/dp/0954300696/ref=sr_1_6?s=books&ie=UTF8&qid=1359412610&sr=1-6&keywords=haskell
14:38:36 <monochrom> yes. it is a very good book. for those who know Haskell and use it to learn logic, maths, and programming
14:38:37 <boblehest> I assume the other tutorials aren't as math oriented, and I wouldn't mind some math
14:40:29 <byorgey> boblehest: it is not a Haskell tutorial
14:40:58 <SoleSoul> mizu_no_oto: it works :). Now I need another hint if that's fine. In continueOn, if I need variable from "main", do I have to explicitly pass them to it? I don't see another way but I want to be sure because this is also very different from C
14:41:00 <SoleSoul> ++
14:41:15 <SoleSoul> *variables
14:42:11 <mizu_no_oto> They're probably out of scope, so yes.  I'm assuming they're declared inside the do block?
14:43:36 <SoleSoul> mizu_no_oto: yes. They are the window, and textures and sprites and what not. It's going to be a long list of arguments.
14:44:09 <S11001001> SoleSoul: put 'em in a box
14:44:44 <boblehest> byorgey: got it
14:44:52 <mizu_no_oto> Or use a let within the do block instead of a where after the do block to declare continueOn
14:45:40 <SoleSoul> S11001001: in Haskell you can never know whether a word is in english or it is a reserved word. maybe, do, either, box?
14:46:34 <boblehest> haha, I googled haskell opengl, and there actually is an opengl library O_o
14:46:39 <boblehest> brb, making a haskell game
14:46:49 <SoleSoul> boblehest: there is also haskell sfml
14:47:11 <mizu_no_oto> Maybe and Either aren't reserved words; they're types declared in a Library
14:47:12 <boblehest> SoleSoul: I'm a glfw fanboy
14:47:48 <SoleSoul> mizu_no_oto: I'm trying to think what's going in the let and what in the "in". will take me a bit
14:48:03 <SoleSoul> mizu_no_oto: sorry, I meant they have special meaning
14:48:25 <mizu_no_oto> ^_^
14:48:53 <SoleSoul> and I think the box thing was a joke, but as I said, you can never know
14:51:03 <fragamus> @pl (Data.List.foldl' (<=<) return (replicate n comp))
14:51:03 <lambdabot> Data.List.foldl' (<=<) return (replicate n comp)
14:53:28 <SoleSoul> and I think the box thing was a joke, but as I said, you can never know
14:53:44 <SoleSoul> oops, sry for this double post ^
14:56:25 <ClaudiusMaximus> SoleSoul: i think by "box", a data type (probably using record syntax) was meant - something like   data Stuff = Stuff{ stuffA :: A, stuffB :: B, ... }   main = do{ a <- ... ; b <- ... ; ... ; let stuff = Stuff{ stuffA = a ; stuffB = b ; ... } ; foo stuff ; bar stuff }
14:58:01 <SoleSoul> ClaudiusMaximus: that's possible. Thanks. Though I wonder if that is what he meant :)
14:59:05 <SoleSoul> For the Either datatype there is the function "either", is there a similar function for Maybe or do I have to "case" over it?
15:00:02 <mauke> if it existed, what would its name be?
15:00:14 <SoleSoul> mm... "maybe"?
15:00:19 <SoleSoul> maybe maybe?
15:00:23 <mauke> :t maybe
15:00:25 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:00:28 <mauke> you win the prize
15:02:21 <SoleSoul> mauke: what does the b stand for? I thought it's supposed to be (a -> b) -> Maybe a
15:02:28 <SoleSoul> mm
15:02:36 <SoleSoul> I didn't write a return type
15:02:49 <tdammers> :t maybe maybe
15:02:51 <lambdabot> (a -> b -> (a1 -> b) -> Maybe a1 -> b) -> Maybe a -> b -> (a1 -> b) -> Maybe a1 -> b
15:02:59 <SoleSoul> :)
15:03:05 <mauke> :t ?maybe maybe
15:03:07 <lambdabot> (?maybe::(b -> (a -> b) -> Maybe a -> b) -> t) => t
15:03:11 <crdueck> I'm getting an "Unrecognized pragma" warning when trying to use OverloadedStrings with ghc 7.6.1, any one know why?
15:03:13 <feliperosa> hello guys, I've got a question... Is Multi-parameter type classes bad? Why weren't they included since the beginning (maybe an implementation issue)?
15:03:52 <mauke> they need fundeps to be useful, and fundeps are hard
15:03:56 <byorgey> crdueck: perhaps you're spelling it wrong?
15:04:17 <crdueck> byorgey: i dont think so, OverloadedStrings
15:04:19 <byorgey> crdueck: perhaps the formatting of the pragma is wrong?
15:04:37 <byorgey> should be  {-# LANGUAGE OverloadedStrings #-}
15:04:39 <feliperosa> mauke: Was that an answer to my question? hehe
15:04:55 <mizu_no_oto> http://www.haskell.org/haskellwiki/Multi-parameter_type_class
15:05:08 <mizu_no_oto> "Naive use of MPTCs may result in ambiguity, so functional dependencies were developed as a method of resolving that ambiguity, declaring that some subset of the parameters is sufficient to determine the values of the others. "
15:05:13 <byorgey> feliperosa: yes, mauke was answering your question
15:05:25 <crdueck> byorgey: i had spelt language wrong... thanks
15:05:41 <end3rW> @src id
15:05:42 <lambdabot> id x = x
15:05:50 <feliperosa> oh, right
15:05:51 <byorgey> crdueck: hehe
15:05:57 <end3rW> Is it possible to incorporate this feautre into EclipseFP?
15:05:57 <feliperosa> so it was an implementation issue?
15:06:10 <feliperosa> they just wanted to 'keep it simple'?
15:06:13 <mizu_no_oto> More or less, yes.
15:06:34 <feliperosa> because I feel so strange like
15:06:55 <mizu_no_oto> Although a common reason things weren't included at the beginning is that noone had thought of it yet
15:07:18 <feliperosa> when I was learning about the State monad I found it so odd that it has kind * -> * -> *
15:07:27 <feliperosa> but Monad expects a type of kind * -> *
15:07:32 <feliperosa> so you must fix one of them
15:07:35 <feliperosa> it's odd
15:07:53 <mauke> it's just currying
15:07:53 <feliperosa> mizu_no_oto: Oh, right. That too hehe
15:08:24 <mizu_no_oto> For example, monadic IO was not the original way Haskell did IO
15:09:09 <feliperosa> Uhum... I got it
15:10:42 <feliperosa> And thinking about it now. It makes some sense that monads expect types of kind * -> *, since just one value is passed between the computations (of that type, I'm not saying you can only pass one value at all)
15:11:32 <amiller_> is anyone familiar with this project, Generic Storage in Haskell? http://vimeo.com/16754709
15:11:36 <feliperosa> You know, you can always use lists and tuples
15:11:51 <amiller_> at the end of this talk i hear some of the complaining about the unwieldiness of recursion schemes
15:15:14 <amiller_> i still don't understand what the alternative to recursion schemes is, especially since this Generic Storage paper uses it to such great effect with annotations
15:15:32 <amiller_> i know of a couple papers with algorithms to automatically generate structural recursion schemes, like this: http://takeichi.dyndns.org/attachments/1996ICFP_73-82.pdf
15:15:44 <sipa> ha amiller_, nice seeing you here :)
15:15:52 <amiller_> hi sipa
15:17:33 <amiller_> believe it or not, i'm still plodding along towards generalized merkle structures :o
15:18:46 <monochrom> > foldl (+) a [b,c]
15:18:48 <lambdabot>   a + b + c
15:19:32 <sipa> amiller_: i certainly believe you :)
15:25:22 <feliperosa> amiller_: My I ask what are recursion schemes (I'm a Haskell beginner)?
15:26:10 <amiller_> recursion schemes are like a generalization of 'fold' that works for datatypes other than lists
15:26:43 <amiller_> http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf this is a classic description of it, the Bananas Lenses and Barbed Wire paper
15:26:53 <alpounet> feliperosa, google for "anamorphism", "catamorphism", you'll see links to the others, most likely
15:27:02 <amiller_> see also http://www.cs.ox.ac.uk/jeremy.gibbons/publications/origami.pdf Origami Programming
15:27:25 <feliperosa> I'll for sure :), thank you for the directions
15:29:19 <feliperosa> From OO to FP there are so many new words x)
15:31:43 <frerich__> Hm, is there a module which can take some relax NG schema and generate a parser out of it, or maybe a code generator which generates Haskell code?
15:32:23 <ski> feliperosa : actually, `State' (which has kind `* -> * -> *') is not a monad. *`State s'* (which *has* kind `* -> *'), however, is a monad, for every type `s' (of kind `*')
15:33:16 <ski> @kind State (Array Int Double)
15:33:18 <lambdabot> * -> *
15:33:21 <ski> @kind Array Int Double
15:33:23 <lambdabot> *
15:35:11 <feliperosa> ski: Oh, I see. What then is a more general concept than monads?
15:35:37 <ski> i'm not sure why you're asking for a more general concept than monads ..
15:35:55 <feliperosa> Just curious about it
15:35:55 <ski> .. but if you must have an example, then (covariant) functors is one
15:36:48 <ski>   fmap :: (a -> b) -> (F a -> F b)  -- a functor `F' only needs to implement this function
15:37:08 <feliperosa> ski: I guess that since I'm just starting to understand such concepts, I yet don't know how to use them properly
15:37:10 <ski> (well, and the function implementation also has to satisfy two simple laws)
15:37:18 <ski> perhaps
15:37:35 <ski> but you'll probably understand them better, by trying to use them ;)
15:37:49 <feliperosa> ski: So, what if I wanted to compose types of kind (* -> * -> *) I wouldn't think of monads =/
15:37:53 <feliperosa> Yeah
15:37:58 <ski> > fmap (2 ^) [0,1,2,3]
15:37:59 <lambdabot>   [1,2,4,8]
15:38:10 <ski> > fmap (2 ^) (Just 3)
15:38:12 <lambdabot>   Just 8
15:38:20 <ski> > fmap (2 ^) Nothing
15:38:21 <lambdabot>   Nothing
15:38:30 <feliperosa> I'm trying to build some libs and more general programs
15:38:32 <ski> > fmap (fmap (2 ^)) (Just (Just 4))
15:38:34 <lambdabot>   Just (Just 16)
15:38:43 <ski> > fmap (fmap (2 ^)) (Just [4,2])
15:38:44 <lambdabot>   Just [16,4]
15:38:54 <ski> feliperosa : can you follow what those examples are doing ?
15:39:08 <feliperosa> Yeah
15:39:37 <ski> well, `[0,1,2,3]' has type `[Integer]', which is sugar for the type `[] Integer'
15:39:44 <ski> and `Just 3' has type `Maybe Integer'
15:40:03 <ski> both `[]' and `Maybe' (which both have kind `* -> *') are functors
15:40:12 <feliperosa> uhum
15:40:37 <ski> in the `fmap (2 ^) [0,1,2,3]' case, the general
15:40:41 <ski>   fmap :: (a -> b) -> (F a -> F b)
15:40:46 <ski> is used in the specific case
15:40:52 <ski>   fmap :: (a -> b) -> ([] a -> [] b)
15:40:56 <ski> iow, with sugar
15:41:01 <ski>   fmap :: (a -> b) -> ([a] -> [b])
15:41:17 <ski> in the `fmap (2 ^) (Just 3)', it's used in the specific case
15:41:24 <ski>   fmap :: (a -> b) -> (Maybe a -> Maybe b)
15:41:44 <ski> well .. in these cases, both `a' and `b' are also `Integer'
15:41:55 <ski> so, i suppose we get
15:42:09 <ski>   fmap :: (Integer -> Integer) -> ([Integer] -> [Integer])
15:42:16 <feliperosa> Yeah
15:42:25 <feliperosa> functors are easier to grasp than monads
15:42:26 <ski>   fmap :: (Integer -> Integer) -> (Maybe Integer -> Maybe Integer)
15:42:47 <ski> oh, so you already understand functors, then ?
15:42:52 <feliperosa> hehe
15:42:56 <feliperosa> yeah
15:43:04 * ski was assuming feliperosa didn't quite understand them, yet
15:43:08 <ski> ok
15:43:13 <feliperosa> x)
15:43:18 <ski> can you state the two functor laws ? ;)
15:43:47 <feliperosa> hum..
15:44:08 <feliperosa> I guess not
15:44:13 <ski> they are :
15:44:16 <feliperosa> I remeber something about identity and composition
15:44:27 <ski>   forall fa. fmap id fa = fa
15:44:57 <ski>   forall h g fa. fmap (h . g) fa = fmap h (fmap g fa)
15:45:10 <ski> but they can also be expressed as :
15:45:12 <feliperosa> right
15:45:15 <ski>   fmap id = id
15:45:23 <ski>   fmap (h . g) = fmap h . fmap g
15:45:46 <ski> which looks slightly prettier (and perhaps is easier to remember) -- but perhaps is slightly more difficult to understand
15:46:01 <feliperosa> prettier
15:46:12 <feliperosa> not so much more dificult to understand
15:46:16 <ski> the first of the laws says that if you use `fmap' to do nothing on all the elements, that's the same as doing nothing on the whole thing
15:46:35 <feliperosa> makes sense
15:47:04 <ski> the second of them says that if you use `fmap' to do one thing, and then another thing, on each element, that's the same as using `fmap' once to do the first thing on each element, and then using `fmap' again to do the second thing on each element
15:47:17 <EvanR> the second one is more familiar if you like algebra
15:47:27 <feliperosa> yeah, EvanR
15:47:30 <feliperosa> ski
15:47:36 <ski> yes ?
15:48:20 <feliperosa> could I say: the first one states that fmap should do nothing more than the function you pass to it does?
15:48:27 <feliperosa> It could be better phrased
15:48:39 <feliperosa> by I guess you'll understand what I'm trying to say
15:48:53 <ski> yes
15:48:58 <feliperosa> right
15:49:02 <ski> i think that's a nice way to think about it
15:49:15 <feliperosa> :)
15:49:37 <ski> (there's perhaps some deep lesson about parametricity hidden here)
15:49:48 <feliperosa> what do you mean?
15:50:00 <ski> i mean that if we have e.g.
15:50:08 <ski>   mysteryFunction :: [a] -> [a]
15:50:30 <ski> then we *know* that this function can't look at the elements of the input list (because of *parametric* polymorphism in Haskell)
15:51:07 <ski> so, the only thing this function can do (ignoring bottoms) is to rearrange, drop, and duplicate the elements of the input list, to get the output list
15:51:42 <ski> and the only information the function can use to decide which of multiple options it'll use is how many elements are present in the input list
15:52:45 <ski> e.g., the function can't do something special if the element type `a' happens to be `Integer' (such as e.g. replacing the list of numbers with a list containing just one number, the sum)
15:53:08 <ski> so, if you now see
15:53:29 <ski>   mapMaybe :: (a -> Maybe b) -> [a] -> [b]
15:53:43 <ski> there's not an awful lot of things this function could sensibly do
15:54:07 <fragamus> one of haskell's greatest strengths is referential transparency… that strength is working against me… I'm trying to serialize my graph without duplication…   : |
15:54:11 <mauke> and mapMaybe (const Nothing) == []
15:54:12 <ski> the only way it'll get any `b's is by calling the argument function `a -> Maybe b' on `a' elements of the input list
15:54:50 <feliperosa> true
15:55:04 <ski> each such call will get it either `Nothing', or `Just b' (with `b' having type `b' (perhaps confusingly named the same))
15:55:19 <feliperosa> nope, named OK
15:55:30 <feliperosa> you have no function to work with b
15:55:38 <feliperosa> nor you know what type is b
15:55:41 <ski> yes
15:56:52 <ski> so, the only way this function could ever depend on the actual values of the `a' elements is by handing them off to the argument function of type `a -> Maybe b'
15:57:30 <ski> getting this guarantee means that it's easier to reason about, and refactor, code
15:58:37 <feliperosa> yeah, that's pretty nice
15:59:06 <feliperosa> fragamus: What do you mean?
15:59:57 <fragamus> I have a graph of records.  There are many many arrows in my graph.  some records are reachable by many different paths.
16:00:35 <fragamus> I have a list of top level graph nodes which have arrows that lead to all of the other nodes.
16:01:10 <msxx> how can I get full path of the executable my haskell code is running in?
16:01:12 <fragamus> If I just serialize, then I get massive duplication.
16:01:34 <feliperosa> ski: And there's one another thing too, I guess. The only things I can imagine (a -> Maybe b) -> [a] -> [b] could do is return all b extrated from the Maybes and exclude the NothingS
16:01:47 <mauke> msxx: how portable does it have to be?
16:02:08 <ski> feliperosa : another extreme is to always return `[]'
16:02:15 <feliperosa> ski: Oh yeah
16:02:22 <msxx> would be nice if it worked on os x, windows, linux
16:02:28 <ski> or only call the function on the `a's with even index number, or something
16:02:49 <ski> however, it *does* limit the options
16:03:19 <feliperosa> Yeah, I guess I was kinda lazy in imagining things x)
16:03:26 <mauke> msxx: System.Environment.getExecutablePath
16:03:31 <feliperosa> but yeah it limits
16:03:56 <feliperosa> fragamus: You duplicate arrows or nodes?
16:04:05 <fragamus> no.
16:04:27 <fragamus> the arrows make many pathways through the graph
16:04:29 <ski> hm, i was about to conjecture that for every `foo :: (a -> Maybe b) -> [a] -> [b]', there is a `reorder :: [a] -> [a]' such that `forall f. foo f = mapMaybe f . reorder' ..
16:04:31 <monochrom> @pl \arg pat1 -> InfixP arg colon pat1
16:04:31 <lambdabot> flip InfixP colon
16:04:37 <ski> .. but i think i already detected a counter-example
16:04:44 <monochrom> oh, it's that simple :)
16:04:54 <fragamus> each node is reachable by a combinatorically explosive number of paths
16:05:01 <msxx> :t getExecutablePath
16:05:02 <lambdabot> Not in scope: `getExecutablePath'
16:05:08 <msxx> @hoogle getExecutablePath
16:05:08 <lambdabot> No results found
16:05:08 <ski>   (`InfixP` colon)
16:05:11 <msxx> did you mistype it?
16:05:17 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/System-Environment.html#v:getExecutablePath
16:05:18 <mauke> no
16:05:35 <geekosaur> :t System.Environment.getExecutablePath
16:05:37 <lambdabot>     Not in scope: `System.Environment.getExecutablePath'
16:05:51 <geekosaur> ...it's also only in fairly recent versions of base
16:06:03 <msxx> ah
16:06:54 <msxx> geekosaur how can you tell? I don't see it in documentation
16:07:06 <feliperosa> ski: That was a bit too much for my understanding hehe
16:07:18 * geekosaur looks at source, aarghs
16:08:04 <geekosaur> ok, who decided that /proc/self/exe was valid on OS X?
16:08:30 <ski> fragamus : i have a feeling something like `Data.IVar' or `Data.Ivar.Simple' could be useful for graph stuff ..
16:08:49 <nejucomo> fragamus: I've run into that issue before also...  I'm curious what the best way to solve it is.
16:08:52 <absence> is it impossible for an AST to be a monad or arrow since pure functions can't be lifted?
16:08:55 <ski> .. in the presence of an `Eq' instance
16:09:04 <ski> @hackage data-ivar
16:09:04 <lambdabot> http://hackage.haskell.org/package/data-ivar
16:09:08 <ski> @hackage ivar-simple
16:09:08 <lambdabot> http://hackage.haskell.org/package/ivar-simple
16:09:21 <nejucomo> I think I ended up tagging each node with a unique Integer then tracking those tags in a set or somesuch.
16:09:32 * nejucomo looks up IVar.
16:09:39 <ski> absence : ASTs can be monads
16:09:47 <fragamus> Well, my brain says that I shall have to radically change the way I handle my graph. And I will lose GC
16:10:16 <ski>   data Expr var = Var var
16:10:28 <ski>                 | Lit Integer
16:10:31 <geekosaur> msxx:  did you follow the link I pasted above?
16:10:36 <ski>                 | Add (Expr var) (Expr var)
16:10:40 <ski>                 | Mult (Expr var) (Expr var)
16:10:46 <msxx> geekosaur yeah I saw it after I asked
16:10:47 <ski> absence : e.g. this is a monad
16:11:42 <geekosaur> ...so I followed its "Source" link for that function, and it's telling me that the OSX version uses /proc/self/exe.  No, it does not; that is a Linux-only mechanism
16:11:52 <msxx> is there a function that tries to build a directory tree if it doesn't exit?  buildIt "/tmp/a/b/c" would create a, b and c directories if they don't already exist
16:12:40 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/libraries/directory-1.2.0.0/System-Directory.html#v:createDirectoryIfMissing
16:12:47 <mauke> geekosaur: you may be misinterpreting the sourcce
16:13:07 <msxx> nice
16:13:32 <absence> ski: hmm, i think i see
16:13:41 <geekosaur> not sure if I am or if haddock did
16:13:49 * ski . o O ( `Data.IVar.JacobSon' )
16:15:37 <ski> absence : if you say `do var <- expr; ..var..', then that means to replace every `Var var' node in `expr' by `..var..'
16:16:11 <ski> (and if the `var' type is e.g. `String', you can replace different variables by different things)
16:16:41 <mauke> geekosaur: https://github.com/ghc/packages-base/blob/master/System/Environment/ExecutablePath.hsc
16:16:46 <Philippa_> ski: example of the latter?
16:16:47 <mauke> my suspicion is confirmed
16:17:18 <Philippa_> oh, just some expression that uses var to eg determine what to substitute it for. lookup env var, etc
16:17:25 <ski> yes
16:17:27 <ski>   subst :: Monad m => (var -> m var) -> (m var -> m a)
16:17:33 <Philippa_> well, a failing-in-the-monad version thereof
16:17:55 <ski>   subst env mv = do v <- mv
16:18:00 <ski>                     subst env (env v)
16:18:16 <absence> ski: so return = Var?
16:18:28 <ski> `subst' will repeatedy substitute in `mv' according to the environment/bindings `env', until there's no `Var var' nodes left
16:18:31 <ski> absence : yep
16:19:03 <ski> and `join :: Expr (Expr var) -> Expr var' replaces every `Var expr' node (in the "outer layer") by just `expr'
16:19:11 <feliperosa> What does it mean to say: "[...]homomorphism from an initial algebra into some other algebra..." (initial ALGEBRA into some other ALGEBRA)?
16:19:12 <Philippa_> now, how easy is the transformer version?
16:19:26 <glguy> shachaf: you're going to miss your chance!
16:19:37 <ski> Philippa_ : yeah, it's a nice strange example of nondeterminism :)
16:19:44 <shachaf> glguy: Can you take over for me?
16:19:50 <shachaf> glguy: It's hard work!
16:20:09 <Philippa_> ski: well, this is stuff I should be remembering how to do for my own project...
16:20:15 <cmccann> stop slacking, shachaf. we're all counting on you.
16:20:19 <Philippa_> wherein I am enacting great syntactic evils ;-)
16:20:31 * ski grins evilly
16:20:55 * ski gets cramps in jaw muscles
16:21:07 * Philippa_ smirks
16:21:07 <geekosaur> oh, so the OS comments are outside the #if blocks so when haddock generates the source it leaves the comment for OS X attached to the implementation for Linux...
16:21:44 * hackagebot pandoc 1.10.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.10.1 (JohnMacFarlane)
16:21:59 <geekosaur> that's ... confusing
16:22:20 <mauke> nothing a bit of mind reading can't fix
16:22:22 <ski> feliperosa : an "Algebra" here consists of a carrier (or sometimes more than one), some operations involving that carrier, and some laws involving the operations
16:22:55 <ski> feliperosa : do you know what a monoid is ? (or a group ? or a ring ? or a vector space ?)
16:23:04 <feliperosa> ski: yeah, all of those
16:23:27 <feliperosa> ski: are they all algebras?
16:23:40 <ski> they are all *kinds* of algebras
16:24:00 <feliperosa> why *kinds*
16:24:02 <feliperosa> OHHH
16:24:04 <feliperosa> right
16:24:21 <feliperosa> I think I understand it now
16:24:23 <absence> ski: bind is harder... got a hint? :)
16:25:04 <ski> well, a monoid is specified by specifying a carrier, say `M', two operations `unit : 1 >---> M',`mult : M * M >---> M', and three laws `mult(unit(),y) = y',`mult(x,unit()) = x',`mult(mult(x,y),z) = mult(x,mult(y,z))'
16:25:14 <ski> feliperosa : ok ?
16:25:17 <mauke> bind = join + fmap
16:25:35 <feliperosa> ski: right
16:25:40 * ski would like to replace the `+' with a `*' there
16:25:49 <feliperosa> its ok
16:25:57 <feliperosa> (N, +, 0)?
16:26:02 <mauke> bind = join × fmap
16:26:38 <ion> @type join .: fmap
16:26:40 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
16:26:46 <ski> feliperosa : the *initial* monoid is the thing you get by `data InitialMonoid = Unit () | Mult (InitialMonoid,InitialMonoid)' -- but where you consider two trees that can be "rewritten into each other using the laws" to be the same
16:26:47 <mauke> bind = join ∴ fmap
16:27:01 <Philippa_> ski: PMs?
16:27:03 <ion> bind = join 卐 fmap
16:27:21 <Eelis> lol
16:28:07 <ski> feliperosa : in this case, this means that *every* such tree is equivalent to to every other, so the initial monoid really has just one element
16:28:14 <absence> okay, so i need a bunch of pattern matches
16:28:28 <feliperosa> ski: Is there are concrete example?
16:29:01 <msxx> is there a nicer way to specify output directory in .cabal file than  ghc-options: -o /path/... ?  doing it like this makes cabal complain about missing executable
16:29:36 <dcoutts_> msxx: cabal controls the layout of the dist/ dir, though you can relocate the whole dist tree
16:29:46 <cmccann> bind = join ☃ fmap
16:30:26 <mauke> msxx: why do you want to specify an output directory in a .cabal file?
16:30:54 <ion> bind = ∀◌. join ◌ fmap
16:31:01 <ski> feliperosa : of initiality, or of initial monoids, or what ?
16:31:27 <feliperosa> ski: A initial monoid?
16:31:52 <feliperosa> ski: I guess by that I can understand 'initial algebra', right?
16:32:02 <ski> there can only be at most one "initial Foo", for any specific `Foo'
16:32:33 <absence> so e.g. Add exp1 exp2 >>= f = Add (exp1 >>= f) (exp2 >>= f) ?
16:32:36 <ski> feliperosa : anyway, let's say we drop the laws from the signature of being a monoid (but keep the carrier and the two operations)
16:32:55 <feliperosa> k
16:33:24 <ski> feliperosa : then the free "whatever we want to call it" is just the tree `data InitialWhatever = Unit () | Mult (InitialWhatever,InitialWhatever)'
16:33:46 <parcs> > logBase 2 ((1 + sqrt 5)/2)
16:33:47 <lambdabot>   0.6942419136306174
16:33:53 <feliperosa> ski: true
16:34:18 <fluffynukeit> hey all.  Can anyone help me out with a garbage collection problem (I think) I am having with lazy bytestring?  Hpaste with description to follow.
16:34:20 <hpaste> fluffynukeit pasted “Need to garbage collect lazy bytestring with Get” at http://hpaste.org/81445
16:34:23 <ski> but, to specify *any* such `Whatever' algebra, we only need to specify a carrier `X', and two functions of types `() -> X' and `(X,X) -> X'
16:34:41 <parcs> > log ((1 + sqrt 5)/2)
16:34:43 <lambdabot>   0.48121182505960347
16:34:48 <fluffynukeit> awe crap, the lines didn't wrap. Sorry.
16:34:53 <mauke> > 0.5 + sqrt 1.25
16:34:54 <lambdabot>   1.618033988749895
16:35:11 <nejucomo> @type join
16:35:12 <lambdabot> Monad m => m (m a) -> m a
16:35:15 <ski> feliperosa : now, the "homomorphism from an initial algebra into some other algebra" here is "just" the fold that replaces the `Unit' and `Mult' constructors in a given `InitialWhatever' tree by the two functions of types `() -> X' and `(X,X) -> X'
16:35:19 <ski> feliperosa : ok ?
16:35:52 <feliperosa> ski: Ok
16:36:08 <feliperosa> ski: Just a question, why one of the functions has type () -> X?
16:36:13 <dcoutts_> fluffynukeit: yes, if you're retaining a small bit of a lazy bytestring, then you'll want to copy it, that's what the copy function is there for
16:37:57 <ski> feliperosa : because in the framework of "universal algebra", each of the operations must have as domain `Foo^n' and codomain `Foo', for some natural number `n', where `Foo' is a disjoint union of all the carriers, together with some "constant types"
16:38:07 <dcoutts_> fluffynukeit: in your example you'll want something like: BS.copy `fmap` getLazyByteString ...
16:38:08 <fluffynukeit> dcoutts: thanks, wow I feel silly for not seeing that before.  In the interest of education, do you see any issue with my code that is causing it not to be GCed?
16:38:20 <feliperosa> ski: Oh, right, thanks
16:38:33 <dcoutts_> fluffynukeit: the getLazyByteString takes a substring of the input, it does not copy
16:38:46 <ski> hm, no that's not quite right .. each operation must be specified by `Foo * Foo * ... * Foo >---> Foo', where each such *instance* `Foo' is actually either one of the carriers, or one of the constant types
16:39:44 <ski> feliperosa : e.g. with vector spaces, the scalar field is already fixed in advance, it's a "constant type"
16:39:54 <fluffynukeit> dcoutts_: ok I will try it out
16:40:03 <feliperosa> ski: right
16:41:36 <ski> feliperosa : and for inner product spaces, we have `(λ (v₀,v₁) ↦ ⟨v₀,v₁⟩) : V × V ➵ K', with `K' in the codomain
16:42:34 <ski> initial algebras have a similar feel as the subalgebra generated by a particular subset (e.g. consider the subgroup generated by a subset)
16:42:40 <joeyh> with http-conduit, if I have a massive request body (ie, a file), what's the right way to feed that into a Request? Seems that the lazy bytestring's length has to be calculated, which bloats memory, so maybe a Builder is the way to do it?
16:43:17 <joeyh> oh, or a Source, I suppose
16:45:11 <ski> (er, with `K' in the codomain being the field, i mean)
16:45:31 <feliperosa> uhum, I got it :)
16:45:48 <ski> feliperosa : of course, in Haskell, we'd typically rephrase `() -> X' and `(X,X) -> X' as `X' and `X -> X -> X'
16:46:27 <feliperosa> ski: Yeah, I wasn't sure which you were mentioning
16:46:28 <ski> feliperosa : btw, "Free `Foo's" also have a similar feel
16:47:00 <ski> the initial vector space is the free vector space on the empty set
16:47:49 <nejucomo> What's a concise way to sequence the same monad N times to produce a list of N results?
16:47:52 <ski> (the free vector space on a set has the elements of that set as basis elements -- claiming that every vector space has a basis amounts to claiming that every vector space is (isomorphic) to a free vector space (on some set))
16:48:03 <ski> @type replicateM
16:48:05 <lambdabot> Monad m => Int -> m a -> m [a]
16:48:14 <nejucomo> So: Monad m => m t -> Int -> m [t]
16:48:22 <nejucomo> Thanks.
16:48:24 <ski> nejucomo : also, not "the same monad", should be "the same monadic action"
16:48:44 <ski> (`m' is the monad, the value of type `m a' is the monadic action)
16:48:52 <ski> (.. aka `m'-action)
16:48:57 <nejucomo> Ok, thanks.  I realized as I was writing that that "a monad" didn't sound right.
16:49:04 <ski> @src replicateM
16:49:04 <lambdabot> replicateM n x = sequence (replicate n x)
16:49:20 <ski> (do you understand that definition ?)
16:49:59 <ski> @type replicateM_  -- there's also this version, for when you don't need/want the results
16:50:00 <lambdabot> Monad m => Int -> m a -> m ()
16:50:17 <nejucomo> Yes.
16:51:10 <sw2wolf> Is it possible to hot update the running haskell code ?
16:51:20 <nejucomo> What I really want, I think, is some kind of dependent type, because I actually want a tuple (or data value) with 8 parameters, and it's known statically I want to repeat the action 8 times...
16:51:31 <sw2wolf> i.e. a 7x24 server applictions
16:51:52 <geekosaur> sw2wolf, if you mean like Erlang, no
16:51:56 <hpaste> Nejucomo pasted “converting list to datatype.” at http://hpaste.org/81446
16:52:13 <ski> `data EightOf a = Eight a a a a a a a a' with a `Functor EightOf' is perhaps not so nice
16:52:22 <sw2wolf> geekosaur: how about like CL ?
16:52:33 <nejucomo> -so I wish I could remove the list pattern match, but I don't know if that's possible.
16:52:34 <fluffynukeit> dcoutts_: Hooray, thanks that worked.  I needed to combine BS.copy with a $! evaluator, but I use 12 MB max instead of 320 MB now.  Thanks again, this had been killing me.
16:53:24 <nejucomo> Actually a lot of this code has that issue, because I'm transliterating C code which uses statically sized arrays, but I don't want variable length types, so I have data T = T W W W W W W W W
16:54:19 <geekosaur> sw2wolf, either way you are relying on a virtual machine / bytecode interpreter setup.  ghc doesn't have an industrial grade one, it has ghci which isn't really designed for that.  compiled code, well, if you wanted to do the work you could probably get hint to do it
16:54:51 <geekosaur> requiring you to make dynamically loadable modules out of your code
16:55:21 <hpc> if i wanted to swap modules at runtime, i think i would go with a "distributed" design
16:55:22 <sipa> sw2wolf: what is CL?
16:55:24 <sw2wolf> same as xmonad's restart function ?
16:55:30 <hpc> multiple programs on the same machine using IPC
16:55:32 <sw2wolf> Common Lisp
16:55:35 <hpc> or plain old sockets
16:55:36 <sipa> oh right
16:56:22 * ski first read "machine" as "abstract machine"
16:56:32 <sw2wolf> geekosaur: thx, maybe i could mimic xmonad's way
16:56:36 <thetallguy> anyone know how to convert old time to new time off the top of their head?
16:56:41 <geekosaur> sw2wolf, xmonad restarts by re-exec()ing itself
16:56:55 <nejucomo> hpc: Agreed...  That approach just seems more general and easier to understand.
16:57:28 <hpc> also, because this is #haskell and i should actually give a good answer...
16:57:40 <hpc> find any patterns in how you modify modules
16:57:56 <hpc> then just swap between them as ordinary data structures
16:58:00 <feliperosa> ski: Thank you for the great lessons today :), good night
16:58:10 <ski> good night
16:58:37 <hpaste> sw2wolf pasted “xmonad restart itself” at http://hpaste.org/81447
16:59:14 <geekosaur> sw2wolf, that's just how another instance signals the running one by sending an X11 client message.
16:59:53 <sw2wolf> yes, then the new modified config is running
17:00:07 <sipa> sw2wolf: this is not the code you're looking for
17:00:19 <sipa> the magic is done by the code that receives the message
17:01:09 <geekosaur> ^^
17:01:10 <sw2wolf> yes, just need to handle the client message in our code
17:01:23 <sipa> i don't think you get it
17:01:37 <geekosaur> "just" need to.  but that's exactly what you've been asking how to do...
17:01:41 <sw2wolf> so i ask here
17:02:28 <sipa> xmonad, when receiving such a "hey dude, restart thyself" message, invokes the haskell compiler on its config file resulting in a new binary, and then does an OS system call exec() on that binary, causing it to be loaded and replacing the current one
17:03:20 <sipa> it's almost the same as if the xmonad program was running in a while loop, and it just exits when it needs updating, and starts over
17:03:26 <sw2wolf> same as POSIX exec* series ?
17:03:41 <hpaste> geekosaur pasted “the actual restart code in xmonad” at http://hpaste.org/81448
17:03:53 <sipa> sw2wolf: no, *the* POSIX exec series
17:04:08 <geekosaur> most of which is not relevant to you; it's the last line that actually matters
17:04:33 <sw2wolf> geekosaur: thx
17:04:58 <geekosaur> ("io" there is actually liftIO)
17:07:29 <geekosaur> also note, you probably do not want to use the same mechanism to restart your 24x7 server unless for some reason it's X11-based
17:07:50 <nejucomo> sw2wolf: So that approach works quite well, except there's no shared state between the old and new processes.
17:07:50 <geekosaur> (xmonad is an X11 window manager, so naturally it uses X11 messages to communicate with itself)
17:08:03 <nejucomo> -except through the filesystem or ipc or some other explicit means.
17:08:17 <sipa> nejucomo: it passes its (little) state on the command line, judging from that code
17:08:21 <geekosaur> it's serialized and passed as a parameter
17:08:47 <sw2wolf> then it is impossible to hot update parts of running haskell code
17:08:51 <nejucomo> If you want to do the "distributed approach", I recommend writing the code as "crash only", then having a tool like daemontools handle restarting for you.
17:09:03 <geekosaur> sw2wolf, as I told youy
17:09:12 <nejucomo> "crash only" meaning whether it is starting fresh or starting from a crash, it behaves the same way.
17:09:21 <glguy> sw2wolf: no, they are not describing "hot update". They are describing "restarting your program"
17:10:12 <sw2wolf> we restart it manually before
17:10:14 <geekosaur> if you want a VM supporting hotswap, use a VM supporting hotswap.  haskell compiles to native code, which is only hotswappable with difficulty in the best of cases... and the way ghc does cross-module inlining and such, it's very far from the best of cases
17:10:26 <nejucomo> Right, sorry if that wasn't explicit.  I'm not aware of any hot-update functionality for haskell.
17:10:55 <monochrom> use hugs for hotswapping
17:11:02 <geekosaur> heh
17:11:04 <startling> sw2wolf: take a look at 'dyre' if you haven't.
17:11:14 <Eduard_Munteanu> How does Hugs help?
17:11:21 <sw2wolf> what's dyre ?'
17:11:37 <monochrom> by being an interpreter
17:11:48 <monochrom> ":reload" is the hotswap command
17:11:49 <startling> @hackage dyre
17:11:49 <lambdabot> http://hackage.haskell.org/package/dyre
17:12:04 <sw2wolf> thx
17:12:14 <monochrom> also...
17:12:21 <monochrom> @quote monochrom hugs
17:12:21 <lambdabot> No quotes match. Just what do you think you're doing Dave?
17:12:39 <monochrom> hugs turns compile-time type errors into run-time type errors
17:12:43 <Eduard_Munteanu> monochrom: well, that's just half way, it should let the program transition to the new version without restarting it.
17:12:43 <geekosaur> (I kinda doubt hugs is really up to it either; proper hotswapping requires some instrumentation in the VM so you can migrate data, and possibly versioned data structures like erlang has)
17:13:27 <geekosaur> the BEAM VM was designed for this; if you truly want hotswappable code, Erlang is probably the best way to go
17:13:47 <crdueck> i want to search a Data.Map.Map, testing each value with a predicate and applying a function to the first value I find that satisfies the predicate. Whats the best way to do this?
17:13:57 <geekosaur> although industrial strength Smalltalk implementations can also do it, but those tend to be spendy
17:14:07 <geekosaur> (likewise, they're fancy VMs)
17:14:12 <shachaf> crdueck: Convert to a list, search the list?
17:14:54 <crdueck> shachaf: i guess Data.List.find would do it
17:15:08 <geekosaur> it would not be impossible for a Haskell implementation to target such a VM, but none currently does
17:18:23 <Jesin> hm...  I'm curious as to whether there's anything analogous to gcc's "-march=native -mtune=native" options for ghc...
17:18:38 <absence> when doing instance Functor, is it possible to apply restrictions to the type variable? e.g. with "data Expr a", instance Num a => Functor (Expr a) doesn't work
17:19:00 <Eduard_Munteanu> Jesin: you can pass those to the GCC backend, e.g. -optc-march=native
17:19:27 <Eduard_Munteanu> I suppose that holds for LLVM to.
17:19:29 <Eduard_Munteanu> *too
17:19:42 <Jesin> hm.
17:20:42 <Eduard_Munteanu> absence: 'Expr a' isn't a functor, Expr might be
17:21:10 <absence> Eduard_Munteanu: yes, but can i somehow say that the implied a is to be Num?
17:21:32 <monochrom> no
17:21:33 <Eduard_Munteanu> You can't.
17:23:05 <Jesin> what's the difference between -fasm and -fvia-C ?
17:23:19 <absence> ok. is there another way to avoid "can't deduce Num b" for fmap f (Add a b) Add (fmap f a) (fmap f b)?
17:23:20 <Jesin> it seems -fvia-C is mentioned in the man page but never explained
17:23:50 <Eduard_Munteanu> Jesin: -fvia-c makes it generate C code and go through gcc.
17:23:55 <shachaf> Jesin: Well, one of them uses the native code generator, and the other one doesn't exist.
17:23:56 <Jesin> k...
17:24:11 <Jesin> shachaf: "doesn't exist"?
17:24:12 <Jesin> umn
17:24:15 <geekosaur> -fvia-C is gone in recent versions
17:24:17 <Jesin> why is it in the manpage
17:24:18 <Jesin> ah
17:24:22 <Jesin> k
17:24:29 <Jesin> so is it just the default behavior or something?
17:24:34 <Jesin> <_<
17:24:51 <geekosaur> the default is what used to be called -fasm
17:24:59 <shachaf> Still called -fasm
17:25:04 <Jesin> ...huh.
17:25:15 <Jesin> so...
17:25:27 <Jesin> <Jesin> hm...  I'm curious as to whether there's anything analogous to gcc's "-march=native -mtune=native" options for ghc...
17:25:30 <Jesin> <Eduard_Munteanu> Jesin: you can pass those to the GCC backend, e.g. -optc-march=native
17:25:30 <Jesin> is that answer wrong now?
17:25:38 <shachaf> That depends.
17:25:57 <absence> Eduard_Munteanu / monochrom : the type constructor is Add :: Num n => Expr n -> Expr n -> Expr n
17:26:00 <Eduard_Munteanu> absence: not sure what you mean by that expression
17:26:01 <geekosaur> if you aren;t running a 7,6 or HEAD then you can still use -fvia-C although it may complain that it's deprecated
17:26:01 <shachaf> GHC can compile C code via GCC.
17:26:16 <geekosaur> (it may even still be in 7.6 but definitely warns)
17:26:27 <geekosaur> (if it is, that is)
17:26:41 <Eduard_Munteanu> absence: you can't really put restrictions on type constructors
17:27:00 <Eduard_Munteanu> Wait, you probably mean data constructors?
17:27:07 <shachaf> GHC has options like -msse2
17:27:29 <Jesin> <shachaf> GHC can compile C code via GCC.
17:27:31 <Jesin> does it, by default?
17:27:32 <absence> Eduard_Munteanu: i'm not quite sure to be honest :) it's a gadt anyway
17:27:49 <absence> Eduard_Munteanu: i guess it's data yes, sorry
17:28:54 <absence> if Expr (in "data Expr a where") is the type constructor
17:29:59 <Eduard_Munteanu> absence: did you mean  fmap f (Add a b) = Add (fmap f a) (fmap f b)  ?
17:30:30 <absence> yes
17:31:08 <Jesin> also, shachaf, according to the manpage, -msse2 is one of only two -m flags...
17:31:50 <shachaf> Jesin: OK?
17:32:14 <absence> Eduard_Munteanu: i tried just using Expr Int directly to test, and get similar errors, can't deduce (b~Int) from the context (a~Int)
17:32:22 <shachaf> Jesin: If you compile via LLVM I bet it gives you a bunch of machine-specific options.
17:32:56 <Eduard_Munteanu> absence: right, f's type is more general
17:33:58 <EvanR2> so all the hype is about database storage getting so big, so fast
17:34:03 <EvanR2> store more and more data
17:34:14 <Jesin> hmm...  is there a way to pass these options through cabal I wonder...
17:34:20 <EvanR2> but we still are settling for our programs runtime being limited
17:34:24 <Eduard_Munteanu> f :: t -> u, but if you give it some Num t, there's no guarantee that Num u   I think
17:35:28 <EvanR2> no one wants an evaluating expression to take up much room, why?
17:35:32 <Eduard_Munteanu> absence: note 'Expr a' isn't inhabited for all a's.
17:35:54 <Eduard_Munteanu> Just those that are Nums.
17:36:18 <absence> Eduard_Munteanu: does that mean one can't make a functor instance for a gadt with different phantom types?
17:36:37 <monochrom> because people hate "stack overflow" and "space leak". but shoving it all to disk is OK.
17:37:31 <EvanR2> it annoys me that there is some operational difference
17:37:32 <Eduard_Munteanu> Mm, let me think, I'm a bit rusty on Haskell GADTs.
17:37:41 <EvanR2> memory is memory
17:43:52 <lispy> Jesin: No and I think get the impression that via-C is getting deprecated in favor of native code gen
17:44:17 <Jesin> k
17:44:32 <Jesin> also I'm curious how the native code gen compares to llvm...
17:44:33 <geekosaur> that and llvm
17:45:06 <geekosaur> llvm can win in a number of cases, but we're not using llvm "right" yet so a number of its optimizations can't currently be done on what ghc feeds it
17:45:38 <geekosaur> this is an area of ongoing work
17:46:36 <jules2> in what sense is it not right?
17:46:36 <lambdabot> jules2: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:47:42 <scooty-puff> has anyone gotten this from cabal: rejecting: ghc-7.6.1/installed-f3c... (package is broken)
17:47:47 <scooty-puff> i have never heard of that package
17:48:46 <geekosaur> as I understand it, there are a lot of annotations one can add to the output to help it generate the best target code.  (you do know that llvm code is more or less a virtual machine bytecode which llvm compiles to the target?)  I am under the impression that many of the annotations that should be attached are currently removed too early from the AST that the LLVM codegen has to work with, befire it gets it
17:49:18 <geekosaur> so it has to generate generic native code when something better would be possible if we preserved and passed throgh the right annotations
17:49:27 <monochrom> that package comes with GHC. it is "GHC API"
17:49:33 <jules2> i see :)
17:50:10 <jules2> you mean things like aliasing information, right?
17:50:35 <geekosaur> one of the things discussed is that you can tell it you are doing CPS and it will generate appropriate code
17:50:47 <monochrom> broken means ghc (the package) depends on some other packages (like Cabal), and these some other packages are shadowed
17:50:50 <Eduard_Munteanu> absence: hm, no, I don't think you can do that. What are you trying to accomplish?
17:51:00 <monochrom> or worse than shadowed
17:51:18 <geekosaur> (IIRC; may have misunderstood something along the way, I'm not expert on either ghc or llvm internals)
17:51:47 <absence> Eduard_Munteanu: typesafe AST
17:51:53 <monochrom> shadowed means you have too many versions
17:52:23 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon . in fact, see the whole thing
17:52:37 <Eduard_Munteanu> absence: what does the type parameter to Expr represent t you?
17:52:53 <geekosaur> jules2, you might want to check the glasgow-haskell-users list archives
17:53:13 <geekosaur> (and there's probably more discussion on the actual compiler development lists which I'm not subscribed to)
17:53:30 <absence> Eduard_Munteanu: a phantom type that describes the type of the expression
17:53:57 <absence> Eduard_Munteanu: e.g. Expr Double is an expression that evaluates to a Double
17:56:47 <Eduard_Munteanu> Damn, I forget the details of GADT syntax :(
17:57:42 <jules2> @geekosaur: thanks i found some interesting threads there. i didn't know ghc does CPS before going to llvm, it makes sense that llvm can't do much with code that contains CPS'ed function calls
17:57:42 <lambdabot> Unknown command, try @list
17:58:10 <monochrom> data E a where { B :: Bool -> E Bool; I :: Int -> E Int; NOT :: E Bool -> E Bool; NEG :: E Int -> E Int }
17:58:38 <monochrom> note how we have forbidden NOT (I 5) and NEG (B False). at the type level!
17:58:47 <Eduard_Munteanu> Eww. :(
17:59:06 <Eduard_Munteanu> I was busy trying to remember if the above was an existential or not.
17:59:19 <monochrom> we have also nicely forbidden a Functor instance. \∩/
17:59:20 <Eduard_Munteanu> (I think it is).
17:59:34 <monochrom> no, no existential in this example
17:59:46 <Eduard_Munteanu> monochrom: the one above with the Num constraint.
17:59:58 <monochrom> still not existential
18:00:25 <monochrom> data E a where { N :: Num a => a -> E a }
18:00:33 <geekosaur> jules2, yeh
18:01:13 <Eduard_Munteanu> How do you declare existentials for GADTs then?
18:01:21 <monochrom> here is an existential example. data E a where { Bah :: Num b => a -> b -> E a }  the b is the existential one
18:01:47 <monochrom> in general, have a type variable that does not show up in "E whatever"
18:02:15 <Eduard_Munteanu> monochrom: oh... is that because in the first one it's the same 'a' as the parameter to E?
18:02:31 <monochrom> yes
18:03:19 <monochrom> "a -> E a" not existential, "b -> E a" existential
18:04:35 <Eduard_Munteanu> And (forall b. b) -> E a would be rank-2 I take it.
18:04:46 <monochrom> yeah
18:06:17 <bacon1989> hello
18:06:22 <Eduard_Munteanu> Anyways, I wonder if a Functor instance even makes sense.
18:06:27 <Eduard_Munteanu> bacon1989: hi
18:06:38 <bacon1989> I seem to be having an issue with types, and I can't seem to sort it out
18:07:55 <hpaste> bacon1989 pasted “Database.HDBC statement execution map” at http://hpaste.org/81449
18:08:17 <bacon1989> http://hpaste.org/81449
18:08:30 <bacon1989> any ideas what i'm doing wrong here?
18:08:39 <bacon1989> I also tried putting it in parenthesis
18:08:45 <bacon1989> , and I get a different error
18:08:56 <bacon1989> but basically, I feel like I shouldn't be using map
18:09:13 <bacon1989> but I have no idea how else I could go about piping these executions through HDBC
18:10:16 <byorgey> bacon1989: the first problem is that catList is a list of lists
18:10:30 <bacon1989> oh
18:10:31 <byorgey> oh, or is it supposed to be like that?
18:10:33 <Eduard_Munteanu> bacon1989: HDBC.execute stmt  expects a SqlValue
18:10:34 <bacon1989> well yeah
18:11:05 <bacon1989> Eduard_Munteanu: I thought it expects a list of SqlValue?
18:11:09 <bacon1989> [SqlValue]
18:11:17 <byorgey> bacon1989: and you want to apply  HDBC.execute stmt  to every element of catList ?
18:11:32 <bacon1989> so I have map (execute stmt) [ [SqlValue] ]
18:11:52 <bacon1989> -> HDBC.execute :: statement -> [SqlValue]
18:11:54 <bacon1989> no?
18:12:25 <bacon1989> i feel like i'm missing something here
18:12:26 <byorgey> bacon1989: well, statement -> [SqlValue] -> ...
18:12:39 <Eduard_Munteanu> The error says 'catList' is a [[SqlValue]].
18:12:41 <byorgey> bacon1989: first, note that  map $ HDBC.execute stmt $ catList  parses as   map (HDBC.execute stmt (catList))  which is not what you want
18:12:49 <bacon1989>  Eduard_Munteanu yeah, I don't understand
18:12:58 <bacon1989> byorgey: blarrg
18:13:08 <byorgey> you want   map (HDBC.execute stmt) catList
18:13:27 <byorgey> bacon1989: the second problem is that you probably want something like  mapM_  instead of map
18:13:33 <Eduard_Munteanu> Ah, I missed that.
18:13:43 * geekosaur was just checking that, actually
18:13:59 <geekosaur> possibly mapM so you get the result
18:14:13 <byorgey> bacon1989: i.e.  execute results in an IO action and you need to run them all in sequence
18:14:13 <absence> Eduard_Munteanu: actually i don't think it does. fmap show would convert the whole thing to Expr String for example
18:14:13 <binroot> Hey guys, how does GHCi differentiate [] and ""? When I type in `tail "h"`, why is my output "" as opposed to []
18:14:30 <byorgey> binroot: by type
18:14:37 <byorgey> binroot: they have different Show instances
18:15:09 <binroot> byorgey: so "" is of type [Char], whearas [] is of type [a]
18:15:09 <binroot> ?
18:15:12 <geekosaur> and it has no idea whether a [Char] is intended to be a String or not; it just assumes it is
18:15:34 <bacon1989> mapM_ is probably what I need
18:15:44 <Philippa_> y'know, I should've spotted that years ago: overlapping instances in the Prelude?
18:15:58 <geekosaur> yep
18:16:15 <geekosaur> has spawned a couple -cafe threads over the years I've been on it
18:16:53 <geekosaur> well, actually, no, they don't use an overlapping instance
18:16:58 <Eduard_Munteanu> absence: yeah, basically you were saying something like "let f :: (a : *), Num a -> (b : *), Num b" etc. though you can't express that in Haskell.
18:17:09 <geekosaur> it's uglier:  Show has a showList
18:17:17 <Eduard_Munteanu> Functors are stuff in * -> *, no restrictions.
18:17:19 <Philippa_> ouch, yes
18:17:26 <geekosaur> specifically so Show Char can be overridden for [Char] by replacing its showList
18:17:30 <bacon1989> thanks guys, the mapM_ and the syntax issue seem to be the problems at hand
18:17:32 <binroot> thanks for your help byorgey and geekosaur
18:17:41 <jollytime> hi guys, how do I make what map ( \x -> randomIO(1,44)) [1,2,3,4] returns into something of Show class?
18:17:45 <geekosaur> which in some ways is uglier
18:17:58 <jollytime> (I am using ghci)
18:18:19 <monochrom> if Num is the only constraint, "myfmap :: (Num a, Num b) => (a -> b) -> Expr a -> Expr b" is possible. but this is still not Functor
18:18:38 <geekosaur> jollytime, you're getting a list of IO actions.  you probably do not intend to do that
18:18:54 <jollytime> I want to store the random numbers into a list
18:18:58 <jollytime> then output it.
18:19:03 <geekosaur> if you use mapM then you should get an IO [Integer] or similar
18:19:05 <monochrom> perhaps a naughty use of unsafeCoerce is in order!
18:19:18 <Eduard_Munteanu> jollytime: you should look at mapM
18:19:21 <Eduard_Munteanu> :t mapM
18:19:23 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
18:19:24 <jollytime> ok :)
18:19:24 <geekosaur> beyond that, well, perhaps you need to learn about working with IO
18:19:36 <jollytime> ah because its for returning monads
18:19:39 <jollytime> sweet
18:19:57 <Eduard_Munteanu> @src mapM
18:19:57 <lambdabot> mapM f as = sequence (map f as)
18:20:01 <Eduard_Munteanu> :t sequence
18:20:02 <lambdabot> Monad m => [m a] -> m [a]
18:20:19 <jollytime> yaaay
18:20:26 <jollytime> mapM is my new friend
18:21:39 <ion> jollytime: Monad isn’t really something you return. Maybe and [] (both types) are instances of Monad, Just 42 and [1,2,3] (both values) are not monads.
18:21:47 * hackagebot kevin 0.7.2 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.7.2 (JoelTaylor)
18:22:42 <Eduard_Munteanu> You could say "monadic <something>", depending on the context.
18:22:47 <monochrom> sometimes, they think "IO Int" is a monad, so "f :: Bool -> IO Int" "returns a monad"
18:26:32 <ski> jollytime : `Just 42' is a monadic action, a `Maybe'-action
18:28:18 <YayMe> Someone told me expand and extract are in... Control.Comonad?
18:28:23 <jmcarthur> one does not simply return a monad
18:28:32 <monochrom> haha
18:28:38 <Eduard_Munteanu> YayMe: expand?
18:28:41 <edwardk> YayMe: extend and extract
18:28:43 <YayMe> oh
18:28:51 * ski grumbles
18:28:51 <YayMe> either way, Control.Comonad?
18:28:59 <monochrom> extract :: m a -> a  the dream of beginners?
18:29:02 <Eduard_Munteanu> edwardk: now you have comonad on highlight? :)
18:29:08 <edwardk> YayMe: yes, the comonad package
18:29:09 <ion> No one can be told what monad is in a tutorial, you have to experience it for yourself.
18:29:14 <edwardk> Eduard_Munteanu: i've always had it on
18:29:19 <bacon1989> alright, I have another issue
18:29:22 <YayMe> edwardk: import Control.Comonad in my ghci is yielding nada.. ?
18:29:30 <edwardk> YayMe: "cabal install comonad"
18:29:30 <bacon1989> my previous list comprehension is not working correctly
18:29:35 <edwardk> YayMe: then try
18:29:44 <edwardk> @hackage comonad
18:29:44 <lambdabot> http://hackage.haskell.org/package/comonad
18:29:56 <monochrom> one simply returns a monad by unsafeCoerceKind
18:30:06 <bacon1989> what's the easiest way to enumerate a list of values?
18:30:08 <YayMe> ion: building a monad was what did it for me truly. Before creating my own (stumbling into the error monad) I understood them and could kinda get the idea, but, not in a true sense
18:30:10 <ski> monochrom ;)
18:30:25 <YayMe> edwardk: Oh, assumed it would be built in. Thanks
18:30:34 <ski> > [2 .. 7]  -- like this ?
18:30:35 <lambdabot>   [2,3,4,5,6,7]
18:30:56 <YayMe> bacon1989: Or do you want to iterate them and do something?
18:31:12 <YayMe> > map (-1) [1,1,1]
18:31:14 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
18:31:14 <lambdabot>    arising from the ambiguity chec...
18:31:22 <YayMe> I'm with the stupid.
18:31:31 <edwardk> > map (subtract 1) [1,1,1]
18:31:32 <lambdabot>   [0,0,0]
18:31:37 <YayMe> smartass.
18:31:38 <ski> > map (\x -> x - 1) [0,0,0]
18:31:40 <lambdabot>   [-1,-1,-1]
18:31:41 <edwardk> (-1) is special in that it doesn't section
18:31:50 <edwardk> er (-) is
18:31:55 <ski> > map (flip (-) 1) [0,0,0]
18:31:57 <lambdabot>   [-1,-1,-1]
18:32:02 <YayMe> edwardk: Yeah, I realized after, though couldn't you just ((-)1) ?
18:32:08 <ski> > map ((-) 1) [0,0,0]
18:32:09 <lambdabot>   [1,1,1]
18:32:17 <YayMe> ok, that's weird
18:32:19 <YayMe> wth
18:32:26 <ski> > map (1 -) [0,0,0]
18:32:28 <lambdabot>   [1,1,1]
18:32:36 <ski> YayMe : `(-) 1 = (1 -)'
18:32:39 <edwardk> YayMe: its on the wrong side, think about this (+) x y = x + y.  (-) x y = (x - y)
18:32:48 <bacon1989> YayMe: well, what I had was x = [ [i,j] | i <- [2,4,6,8], j <- [1..] ]
18:32:58 <YayMe> edwardk: Ahh
18:33:10 <bacon1989> I expected it to produce something like [[2,1], [4,2] ....
18:33:13 <bacon1989> just to 8
18:33:16 <YayMe> edwardk: thus why the flip. doesn't matter for addition, but subtraction is mean
18:33:22 <bacon1989> btu instead it continues on infinitely
18:33:23 <ski> bacon1989 : perhaps you wanted `(i,j)' instead of `[i,j]' )
18:33:38 <ski> bacon1989 : and try flipping the order of the two generators there
18:33:39 <bacon1989> ski: i'm afraid that won't work for what i'm doing
18:33:52 <Eduard_Munteanu> bacon1989: you want zipWith
18:34:18 <Eduard_Munteanu> > zip [2,4,6,8] [1..]
18:34:18 <YayMe> > [ i:[j] | i <- [2,4,6,8], j <- [1..4]]
18:34:21 <lambdabot>   [(2,1),(4,2),(6,3),(8,4)]
18:34:21 <lambdabot>   can't find file: L.hs
18:34:33 <ski> > [2,4,6,8] >>- \i -> [1 ..] >>- \j -> [(i,j)]
18:34:36 <lambdabot>   [(2,1),(4,1),(2,2),(6,1),(2,3),(4,2),(2,4),(8,1),(2,5),(4,3),(2,6),(6,2),(2...
18:34:36 <edwardk> >  [ [i,j] | i <- [2,4,6,8] |  j <- [1..] ]
18:34:38 <lambdabot>   [[2,1],[4,2],[6,3],[8,4]]
18:34:40 <Eduard_Munteanu> > zipWith (\i j -> [i, j]) [2,4,6,8] [1..]
18:34:42 <lambdabot>   [[2,1],[4,2],[6,3],[8,4]]
18:34:53 <edwardk> note the | rather than ,
18:34:55 <YayMe> edwardk: Why didn't his work?
18:34:57 <YayMe> oh
18:34:59 <YayMe> duh.
18:35:08 <edwardk> those are 'parallel list comprehensions'
18:35:15 <ski> bacon1989 : oh, you wanted to join them in "lockstep" ?
18:35:32 * Eduard_Munteanu probably never used those
18:35:38 <Jesin> hmm
18:35:38 <bacon1989> ohhh thanks Eduard_Munteanu
18:35:39 <edwardk> in list comprehensions the , means cross-product basically
18:35:41 <bacon1989> edwardk: *
18:35:54 <Jesin> guys, why does directory-1.2.0.1 break everything?
18:36:17 <ski> > [ [i,j] | i <- "abc", j <- "01" ]
18:36:19 <lambdabot>   ["a0","a1","b0","b1","c0","c1"]
18:36:20 <ski> > [ [i,j] | i <- "abc" | j <- "01" ]
18:36:22 <lambdabot>   ["a0","b1"]
18:36:24 <YayMe> Mostly what I've learned from this channel is you usually don't actually want list comprehensions except in a small number of cases which I'm nto smart enough to deduce, so best to avoid them until your smarter (at least that's my advice to me, you may be smarter than i)
18:36:25 <monochrom> how does it break everything?
18:36:33 <ski> bacon1989 : see ^ for difference
18:36:34 <Jesin> "    Cabal-1.16.0-dd0ce1db6fea670a788547ee85411486 is unusable due to missing or recursive dependencies:
18:36:35 <Jesin>       directory-1.2.0.0-8edf300597b0da609c8eccc9aa6d0cc3 process-1.1.0.2-03ae5757aa509ffbe497f42660cba52c unix-2.6.0.0-fd2d40657485db9e1c33f6fe18603ecb
18:36:35 <Jesin> "
18:36:38 <Jesin> that's how
18:37:18 <monochrom> ok, multiple versions breaks everything. does not have to be directory-1.2.0.1
18:37:21 <ski> YayMe : list comprehensions can be quite nice
18:37:32 <ski> YayMe : of course, it's basically the same as the list monad
18:37:33 <bacon1989> <interactive>:15:35:
18:37:35 <bacon1989>     Unexpected parallel statement in a list comprehension
18:37:36 <Eduard_Munteanu> Is there a so-like versioning policy for Haskell package so you can decide if a new version breaks compatibility?
18:37:37 <bacon1989>     Use -XParallelListComp
18:37:40 <msxx> is there a way to add language feature in ghci without restarting it?
18:37:45 <Jesin> monochrom: I don't have multiple versions
18:37:47 <bacon1989> edwardk: it doesn't seem to be supported
18:37:49 <ski> bacon1989 : `:set -XParallelListComp'
18:37:53 <Jesin> at least, I don't think I do
18:38:02 <monochrom> you have directory-1.2.0.0 and directory 1.2.0.1
18:38:05 <bacon1989> ski: why is that not set by default?
18:38:05 <YayMe> ski: yeah, I do like the syntax, though I find myself stumbling over performance blocks with them more often than not and being told to rewrite them with functions
18:38:14 <ski> bacon1989 : it's a language extension
18:38:16 <Jesin> monochrom: it says "missing or recursive"
18:38:23 <msxx> bacon {-# Language ParallelListComp #-}
18:38:26 <monochrom> the error message is wrong
18:38:32 <ski> bacon1989 : if you want to use it in a file, add `{-# LANGUAGE ParallelListComp #-}' at the top of the file
18:38:33 <Jesin> huh.
18:38:33 <Jesin> So
18:38:34 <YayMe> ski: and I can't tell the difference between when they're going to hit a performance hitch vs. not, so I just avoid them now
18:38:40 <byorgey> Jesin: monochrom is the cabal whisperer, I suggest you pay attention to what he says
18:38:43 <Jesin> if I remove the older one, the error should go away?
18:38:47 <Jesin> byorgey: I will
18:38:53 <bacon1989> ski: ah ok
18:39:03 <monochrom> remove the newer one. remove things that don't come with GHC or Haskell Platform
18:39:18 <edwardk> bacon1989: its an extension to the language that was added. not all compilers support it.
18:39:23 <edwardk> (in fact i think ghc is the only one)
18:39:32 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml
18:39:38 <msxx> is there any other compiler that matters?
18:39:50 <bacon1989> so only ghc supports multiple list comprehensions?
18:39:55 <Eduard_Munteanu> "sicp" sounds like a conference or something.
18:40:03 <centrinia> How would one make Data.Binary.Get.Get an instance of MonadFix?
18:40:08 <msxx> hoogle is dead, what others are there?
18:40:14 <ski> edwardk : Hugs supports it
18:40:15 <msxx> err, hugs even
18:40:19 <ezyang> Hayoo, maybe?
18:40:22 <ezyang> @hoogle a -> a
18:40:22 <lambdabot> Prelude id :: a -> a
18:40:22 <lambdabot> Data.Function id :: a -> a
18:40:22 <lambdabot> GHC.Exts breakpoint :: a -> a
18:40:26 <YayMe> monochrom: the acronym is intentional I presume?
18:40:26 <edwardk> fair enough
18:40:30 <monochrom> yes
18:40:31 <msxx> s/hoogle/hugs
18:40:45 <ski> bacon1989 ^
18:42:12 <Jesin> <monochrom> remove the newer one. remove things that don't come with GHC or Haskell Platform
18:42:14 <Jesin> huh...
18:42:45 <Jesin> monochrom: so does that mean directory-1.2.0.1 does currently break GHC 7.6.1 ?
18:43:31 <YayMe> cmccann: ping
18:43:37 <geekosaur> havuing two versions of any boot library (that is, a library thst comes with the compiler) is pretty certain to break things.  two versions of something in the Platform likewise
18:43:56 <cmccann> YayMe: ?
18:44:01 <monochrom> you are looking at shadowing. you have two versions. one version shadows another. usually, newer shadows older, --user shadows --global. however, existing packages want older, --global versions
18:44:02 <Jesin> monochrom: how do I remove things, besides rm -r ?
18:44:05 <YayMe> Anyone care to answer my SO question that I should have asked on SO instead of P.SE? I'm genuinely curious and the current answer is lacking http://programmers.stackexchange.com/questions/185094
18:44:13 <geekosaur> ghc-pkg unregister
18:44:13 <monochrom> ghc-pkg unregister directory-1.2.0.1
18:44:23 <monochrom> and read my http://www.vex.net/~trebla/haskell/sicp.xhtml
18:44:33 <YayMe> cmccann: Have a look at my P.SE question? :) I should have asked on SO, you would have already seen it heh
18:44:36 <mikeplus64> @hoogle [b -> b] -> b -> b
18:44:36 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
18:44:36 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
18:44:36 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
18:44:37 <monochrom> I spent time typing it all up for a reason
18:44:41 <mikeplus64> @pl foldr (.) id
18:44:41 <lambdabot> foldr (.) id
18:44:49 <Eduard_Munteanu> Are there any plans to fix cabal/ghc's behavior?
18:45:19 <geekosaur> there are plans, yes
18:45:33 <Eduard_Munteanu> All this shadowing, breakage and stuff don't seem to be by design.
18:45:36 <geekosaur> I'm not sure which plan(s) will actually happen, or when, though
18:46:08 <monochrom> it is not breakage per se. not data-loss breakage. it's a data-surplus breakage.
18:46:24 * geekosaur keeps thinking about writing a wrapper for cabal-install which looks at the dependencies in the cabal file and adds --constraint 'foo installed' as appropriate
18:46:33 <monochrom> this is why fewer people understand it
18:46:36 <geekosaur> or whatever the syntax is
18:47:07 <monochrom> you can write in ~/.cabal/config too. constraint: Cabal installed
18:47:21 <monochrom> separate lines for each package
18:47:40 <cmccann> YayMe: don't really have time to write a proper answer right now, sorry :[
18:47:56 <bacon1989> think my code is working
18:47:58 <bacon1989> woop
18:48:18 <YayMe> cmccann: No worries, we all got plenty of shit to do. Somebody else in here might look at it anywho, we'll see.
18:48:26 <YayMe> cmccann: Thanks anyway
18:49:13 <monochrom> shadowing is a GHC choice. cabal cannot change it
18:49:53 <Eduard_Munteanu> Actually shadowing is fine, as long as existing packages can select the older version as well.
18:50:02 <cmccann> YayMe: though probably what I'd do in most cases is have separate types for known-valid vs. not validated, with a validation function "validate :: NotValidated -> Either ErrorMsg Valid"
18:51:05 <cmccann> YayMe: then convert that into an error in some error monad context  if needed, or handle it on the spot, or whatever
18:54:06 <monochrom> perhaps, the time has come to announce "see my http://www.vex.net/~trebla/haskell/sicp.xhtml" every 5 minutes
18:54:20 <jollytime> guys, how do I write a recursive function that will output something n times with pattern matching?
18:54:37 <monochrom> no understand
18:54:48 <jollytime> :)
18:56:47 <Jesin> <monochrom> perhaps, the time has come to announce "see my http://www.vex.net/~trebla/haskell/sicp.xhtml" every 5 minutes
18:57:10 <monochrom> thank you for doing it for me!
18:57:19 <Jesin> ...yeah...  I loved Haskell for the most part; the reason I stopped using it for months was because it gave me worse dependency-management issues than anything else I'd used
18:57:31 <Jesin> <_<
18:57:41 <monochrom> it is the cost of cross-package code optimization
18:58:12 <Jesin> hmm...
18:58:14 <Jesin> I still wonder, though
18:58:16 <monochrom> if you suppressed that, bytestring would not fly at call sites
18:58:41 <cmccann> the ad-hoc nature of hackage uploads and people upgrading at the drop of a hat doesn't help either.
18:58:43 <Jesin> since our dependency-manager contains a mechanism for requiring specific versions or version-ranges,
18:59:19 <Jesin> why doesn't the language itself contain a mechanism for importing from specific versions/ranges?
19:00:03 <HaskellNewbie> Hi everyone! Does anyone know how to make a data type of a data type? (Example: https://gist.github.com/4661347)
19:00:05 <monochrom> you must inline. you must inline across package boundaries. now the mainstream idea of "ABI" goes out of the window
19:01:36 <Jesin> monochrom: well, yes...
19:01:48 <Jesin> why does upgrading packages break everything
19:02:17 <Jesin> I just got rid of every sign of the newer directory package
19:02:44 <Jesin> and reinstalled process, unix, and Cabal
19:02:44 <Jesin> and yet I still get
19:02:45 <Jesin>     Cabal-1.16.0-dd0ce1db6fea670a788547ee85411486 is unusable due to missing or recursive dependencies:
19:02:45 <Jesin>       directory-1.2.0.0-8edf300597b0da609c8eccc9aa6d0cc3 process-1.1.0.2-03ae5757aa509ffbe497f42660cba52c unix-2.6.0.0-fd2d40657485db9e1c33f6fe18603ecb
19:03:06 <Axman6> HaskellNewbie: You'd need to use a new datatype: data Token = Reserved ReservedWords | Error ErrorCodes
19:03:13 <Jesin> hmm
19:03:16 <monochrom> I have an instance of Cabal. it is built against a particular instance of containers, call this instance X. therefore, my instance of Cabal contains internal code of X, by inlining. OK?
19:03:18 * Jesin reads through monochrom's link
19:03:28 <Axman6> HaskellNewbie: you can't just join different types, because they are just that, different types of things
19:03:29 <Jesin> yeah...
19:03:58 <HaskellNewbie> Axman6: I'll give it a try, one sec
19:04:00 <monochrom> therefore, if you add another instance of containers, call it Y. then will Cabal work with Y? likely no. internal X code and internal Y code may do contradictory things
19:04:59 <geekosaur> process and unix are also boot libraries
19:05:05 <Jesin> ah
19:05:13 <monochrom> this is a problem not faced by ruby (it's all interpreter). this is a problem not faced by C (it's no inline)
19:06:12 <monochrom> libcairo.so does not contain code from libgtk.so
19:06:27 <bacon1989> alright
19:06:29 <HaskellNewbie> Axman6: Could you give a little more detail to how you'd set types in Token? As in, a Token should accept a ReserveWord or an Error, but an Error cannot accept a ReserveWord (and vice versa)
19:06:34 <bacon1989> I believe i've run into a brick wall
19:06:35 <monochrom> our cairo package, once compiled, does contain code from our gtk package
19:06:44 <bacon1989> when I run my program, I get "out of memory"
19:06:46 <bacon1989> gg haskell
19:06:55 <geekosaur> you *can* get in trouble with inlines in #include files; a KDE dev has told me about the restrictions they have on those because of what amounts to the same issue
19:07:48 <monochrom> it is good to know that the pasture outside is not greener
19:08:54 <geekosaur> worse, C/C++ doesn't do package hashes so it can't even warn you ahead of time that you're in murky water
19:09:10 <geekosaur> you usually find out at runtime with weird internal errors or core dumps
19:09:56 <monochrom> the true story with C not having this problem is that thousands of distro employees or volunteers iron it out, so you don't see it, but they do
19:10:07 <geekosaur> yep
19:10:35 <monochrom> use hugs to eliminate cabal problems
19:10:42 <monochrom> recall that cabal still supports hugs
19:11:15 <geekosaur> so you get the KDE restreictions on inlining, or various common libraries using internal macros and data signatures so they can detect mismatches and throw sane errors
19:11:18 <monochrom> every time someone says "ruby gems are so much easier", tell them "cabal still support hugs"
19:12:18 <cmccann> I'm pretty sure that if I grabbed the latest stable version from the source repo of everything installed on my desktop and rebuilt it all manually it would work not very well
19:14:09 <cmccann> when installing haskell packages, somewhere in the range "latest stable" through "bleeding edge" seems to be the norm. sometimes I'm surprised things work as well as they do.
19:14:23 <YayMe> cmccann: How do you go from the validated version to the invalidated version then? You just bind a validate method onto an error monad like my option #2?
19:15:49 <liyang> luite: is there an offline version of hdiff?
19:16:31 <hpaste> Hrumph pasted “problem with     $forall (opt,optsel)    <- selOpts line” at http://hpaste.org/81450
19:16:45 <cmccann> YayMe: personally I'm not a fan of using error monads in most circumstances.
19:16:54 <cmccann> so probably I'm not the best person to ask. :P
19:16:56 <hrumph> the line with forall (opt,optsel) won't compile
19:17:06 <luite> liyang: not really. you mean cabal diff x-0.2 x-0.1 or something?
19:17:14 <hrumph> i get "not in scope opt"
19:17:14 <luite> where it would download the two and compare
19:18:09 <YayMe> cmccann: Ah, how do you deal with data that may need to be validated between activities?
19:18:29 <YayMe> manually just validate it in each place?
19:19:02 <liyang> luite: ah, it doesn't do what I imagined. Was hoping it'd just give me a summary of API differences.
19:19:07 <cmccann> validate it where it makes the most sense, and use types that are guaranteed to be valid whenever possible
19:19:24 <liyang> Sometimes I'm not sure which part of the version number I should bump.
19:21:00 <YayMe> cmccann: ah, good advice. Maybe I can alter my data model to be correct more often by default, I'll have to think on that, thanks!
19:21:20 <luite> liyang: oh right, i was thinking of adding that, but it's a lot more complex if you have to compile every package
19:22:01 <hrumph> help me
19:22:32 <shachaf> liyang: Just bump all of them to be on the safe side.
19:23:39 <shachaf> liyang: I recommend the versioning scheme of http://hackage.haskell.org/package/regex-pcre-builtin
19:24:16 <hrumph> ok problem solved don't need help anymore
19:25:49 <liyang> shachaf: omgwtf!
19:26:40 <monochrom> that is quite baffling :)
19:27:35 <monochrom> "Stability: Seems to work, passes a few tests" hahaha
19:28:41 <glguy_> monochrom: what package was that?
19:28:52 <monochrom> regex-pcre-builtin
19:29:05 <monochrom> originally mentioned for its great version numbers!
19:29:47 <monochrom> also, regex-pcre
19:30:10 <monochrom> "Home page: http://hackage.haskell.org/package/regex-pcre"
19:30:25 <monochrom> honestly, I have never thought of that
19:31:07 <Jesin> monochrom: hm, is this a problem?
19:31:09 <Jesin> The following packages are broken, either because they have a problem
19:31:09 <Jesin> listed above, or because they depend on a broken package.
19:31:09 <Jesin> ghc-7.6.1
19:31:09 <Jesin> bin-package-db-0.0.0.0
19:31:28 <liyang> monochrom: I have mutually recursive links between hackage and github.
19:31:28 <Jesin> <_<
19:31:38 <Jesin> it looks like it is, maybe I should recompile ghc?
19:35:28 <monochrom> no. if you don't mind losing --user packages, rm ~/.ghc/<arch-version>. use ls to find the right <arch-version>
19:35:46 <monochrom> if you don't know what "--user packages" means, you should find out now
19:41:34 <YayMe> Can you define a monad in terms of a comonad and vice versa? Or parts of it anyway?
19:41:57 <c_wraith> well, they are both type constructors, and they both have fmap
19:42:02 <c_wraith> so, they're 2/3 the same
19:42:09 <c_wraith> But the remaining 1/3 is entirely different
19:42:18 <edwardk> the answer to this is 'yes and no'. in general they are unrelated, but then i also have a construction that makes a monad transformer out of every comonad.
19:42:18 <YayMe> ah
19:42:35 <edwardk> that construction is rather convoluted though
19:42:48 <jollytime> hmmms
19:43:04 <edwardk> basically you should consider a comonad and a monad (even on the same type!) to be largely unrelated.
19:43:20 <YayMe> edwardk: monad has what; join, return, and a third one I can never remember the name of?
19:43:27 <edwardk> e.g. there is a monad for (,) e    and a comonad for (,) e
19:43:39 <edwardk> return and (>>=)     or return, fmap and join.
19:44:04 <edwardk> (to make the monad for (,) e you need a monoid on 'e'
19:44:27 <edwardk> in the comonad world its extract and extend   or extract, fmap and duplicate
19:45:07 <YayMe> edwardk: ok, I know bind is just a combination of what, fmap and join? in any event, can you define extend or extract using some combination of fmap/return/join ?
19:45:10 <edwardk> YayMe: i have a comonad-transformers package on hackage with analogues to the transformers in the transformers package, and comonads-fd with classes analogous to those in mtl.
19:45:41 <edwardk> YayMe: no in general you cannot define the comonadic operations for a type in terms of monadic ones for the same or vice versa.
19:46:21 <edwardk> (in general that is, liftM and liftW are both admissable definitions for fmap, and in the case of Identity it works, but nothing more complicated)
19:47:28 <YayMe> gotcha
19:47:46 <edwardk> the relationship between (>>=) and join is simple: join m = m >>= id, and m >>= f = join (fmap f m)
19:47:53 <edwardk> :t (>>= id)
19:47:55 <lambdabot> Monad m => m (m b) -> m b
19:48:07 <edwardk> :t extract
19:48:08 <lambdabot> Not in scope: `extract'
19:48:12 <edwardk> aw
19:48:18 <edwardk> :t Control.Comonad.extend id
19:48:19 <lambdabot> Control.Comonad.Comonad w => w a -> w (w a)
19:48:31 <edwardk> this is how we can define duplicate in terms of extend
19:48:54 <edwardk> :t fmap ?f . Control.Comonad.duplicate
19:48:56 <lambdabot> (?f::f a -> b, Control.Comonad.Comonad f) => f a -> f b
19:49:05 <edwardk> :t \f -> fmap f . Control.Comonad.duplicate
19:49:06 <lambdabot> Control.Comonad.Comonad f => (f a -> b) -> f a -> f b
19:49:14 <edwardk> :t extend
19:49:15 <lambdabot> Not in scope: `extend'
19:49:22 <edwardk> :t Control.Comonad.extend
19:49:24 <lambdabot> Control.Comonad.Comonad w => (w a -> b) -> w a -> w b
19:51:49 * hackagebot thyme 0.2.0.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.2.0.0 (LiyangHu)
19:54:57 <shachaf> liyang: Should'vegone with 0͕.̜2̕.̏0̽.͑0͏.͔1͏4̺.͋8̧͈͜.̪̣̈2̸̫͓ͯͣ͋̕6̶̮̹̊ͫ̊ͅ4͚͈͓̯͕̙ͩ7̷͎̜̝ͬ͆̅3͙̙̲̘͖̐ͮ8̴͚̪ͮͥ̋̉.̷̵̰ͨ̽ͪ͗̆͂̀4͈̩͓̠̻̯ͭ̃̕̕6̩̭̻̝ͦ̽̋ͣ̚̚3͈ͯͯ͌̾ͨ̀̔͡͝6̪͎̲̇̍͂̋ͧ̇͝2͍̪̻̯̬̬́́ͨ̚7̟̅ͯ̍̐̉͘͟͠͝6̨̭͕̩͍͇̈̌̔̊4̛̫͖͒ͯ̐̎̍̉̒6͓̤͇̜͈͍ͮͭ̄̚9̨̛̭͈̝̏̈͛ͮ͜2̮̭̤̌̇ͯ̔̆ͤͅ4̭̯̣̗̊̊̉̽̔̾
19:55:16 <jollytime> woah? i just got a cloud of characers with shachaf typed that
19:55:36 <jollytime> it's like this weird alien orthography
19:55:45 <shachaf> I was merely suggesting that liyang might've gone with a version number like 0.2.0.0.14.8͜.̈2̸ͣ̕6̹̊ͫ4͈̯̙7̷ͬ̅3͙̲̘8̴̪ͥ.͈͗͂4̩̃̓6ͣͤ̚3͌̀ͦ6͎͂̅2̯̲́7̡̟͝6̩̔ͫ4͖̐ͧ6͇̜͒9̭̈̎2̭̻̔4̯̗̌
19:55:50 <shachaf> But maybe I took it too far.
19:55:57 <jollytime> s/with/when
19:56:04 <jollytime> doh, I see it again
19:56:19 <edwardk> liyang++ # thyme looks pretty nice.
19:56:54 <liyang> shachaf: just… no.
19:57:17 <edwardk> jollytime: that style was born here: http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
19:57:23 <liyang> edwardk: thanks, been meaning to scratch that itch for far too long. :)
19:57:47 <edwardk> i went to go fix a bunch if the old style 'Simple' links in there, then realized they were probably for 3.7 compatibility
19:57:47 <Jesin> hmm
19:58:02 <Jesin> is there a nice way to compile GHC with newer versions of packages...
19:58:15 <shachaf> @where zalgo
19:58:15 <lambdabot> import Random;main=mapM_((>>(י=<<randomRIO('̀','ͯ'))).י)=<<getContents;י=putChar
19:58:22 <shachaf> Hmm, that's not compatible with H2010
19:58:35 <shachaf> @where+ zalgo import System.Random;main=mapM_((>>(י=<<randomRIO('̀','ͯ'))).י)=<<getContents;י=putChar
19:58:35 <lambdabot> It is forever etched in my memory.
19:58:44 <ion> edwardk: I always assumed that comment just imitated the Zalgo meme.
19:59:18 <edwardk> ion: i stand corrected
19:59:22 <edwardk> http://knowyourmeme.com/memes/zalgo
19:59:45 <Jesin> anyone?
19:59:54 <geekosaur> not generally
20:00:22 <Jesin> geekosaur: was that a response to <Jesin> is there a nice way to compile GHC with newer versions of packages...
20:00:52 <jollytime> edwardk, hehe, nice
20:01:07 <liyang> edwardk: ah, going to upgrade to 3.8 soon…
20:01:30 <geekosaur> Jesin, yes
20:01:38 <Jesin> k.
20:01:52 <shachaf> "establishes a breach between this world and the dread realm of c͒ͪo͛ͫrrupt entities (like SGML entities, but more corrupt) "
20:02:00 <liyang> "formatTime: 12.7× faster; expected 9.0×." https://travis-ci.org/liyang/thyme/builds/4444112/#L1475
20:02:58 <heath> would anyone here be willing to spend 20mins/day with me going through material pertaining to haskell and its concepts?
20:03:10 <edwardk> liyang: somewhat dangerous if there is a lag spike on the machine no?
20:03:37 <amiller_> i'm working through the code in the "Generic Storage in Haskell" paper I like so much this week http://www.andres-loeh.de/GenericStorage/wgp10-genstorage.pdf , but I am encountering an unexpected infinite loop https://gist.github.com/4659219
20:03:47 <amiller_> maybe someome here will recognize the problem or be interested to hear the solution if i resolve it
20:04:08 <luite> oops
20:04:16 <luite> huh
20:04:19 <Jesin> The following is the output of "sudo ghc-package check" on my system: http://ix.io/4bs
20:04:24 <luite> bah my terminal is glitchy
20:04:25 <Jesin> I'm wondering if the stuff at the bottom is a problem
20:04:42 <sinelaw> @hoogle [a] -> [b] -> [(a,b)]
20:04:43 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
20:04:43 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
20:04:43 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
20:04:44 <liyang> edwardk: true. Maybe I should split that off into a benchmark.
20:05:04 <geekosaur> Jesin, that looks like you removed the wrong versions of the packages
20:05:17 <geekosaur> if you thought the right thing to do was keep the newer version... well, you get to reinstall ghc
20:05:22 <Jesin> um.
20:05:30 <Jesin> is that really necessary?  <_<
20:05:34 <geekosaur> yes
20:05:36 <edwardk> Jesin: as a rule of thumb i never run sudo ghc-pkg anything
20:05:59 <Jesin> geekosaur: what's likely to be broken?  GHC still seems to work...
20:07:26 <geekosaur> ghc itself will work if you don't use template haskell, probably.  but you can't simply reinstall the same version of a package to fix it, because ghc does cross-module inlining and such and the result is you're usually dependent on the exact result of a given build.  (this "shouldn't" be the case but usually is)
20:08:48 <Jesin> geekosaur: yeah, monochrom helped me figure that out.  There used to be a lot more packages in that list
20:09:01 <Jesin> now it's down to just ghc-7.6.1 and bin-package-db-0.0.0.0
20:09:19 <Jesin> that apparently have broken dependencies
20:09:34 <Jesin> however, those are apparently not even packages
20:09:37 <geekosaur> I am not sure what actualy breaks with directory; possibly you could actually get away with running that way.  bin-package-db is used by Cabal the library, and while already compiled stuff will be fine, potentially you can run into trouble building new cabal packages
20:09:57 <geekosaur> ghc-7.6.1 is ghc itself, in the form of a library
20:10:16 <geekosaur> again, for simple stuff you'd likely not notice
20:10:22 <geekosaur> since ghc-the-compiler is fine
20:10:38 <Jesin> ah.
20:10:41 <geekosaur> I suppose if you would rather not fix things, you can get by for a while leaving it broken
20:10:43 <Jesin> so...
20:11:06 <geekosaur> but eventually you will probably run into problems and if you keep installing stuff you'll get to throw it all out and start over
20:11:08 <Jesin> I don't suppose it'd be possible for me to rebuild ghc against the newer packages?
20:11:18 <Jesin> or is that an awful idea
20:11:42 <geekosaur> so, do you recall me describing some packages as "boot libraries" before?
20:12:00 <geekosaur> that means they *come with ghc*.  it has them, and builds them, form its own source tree
20:12:27 <geekosaur> *maybe* you could hack ghc's source tree to include the newer versions.  *maybe* it'd work afterward.  you would get zero support if it doesn't though
20:13:01 <geekosaur> they're not merely bundled; ghc needs them to build itself
20:14:57 <geekosaur> again, if you really, really want to do this to yourself, go ahead and do it, but you'd best be ready for problems and know what to do about them yourself since you've branched out into compiler hacking, not just "upgrading packages"
20:16:11 <tieTYT2> i like how elemIndex returns a Maybe.  The java way is to return -1 if it doesn't find anything
20:16:26 <sinelaw> what's a short way to do cartesian product on lists?
20:16:27 <sinelaw> @pl \xs ys -> concat (map (\y -> map (\x -> (x,y)) xs) ys)
20:16:28 <lambdabot> (join .) . map . flip (map . flip (,))
20:17:06 <monochrom> the lisp way returns nil :)
20:17:26 <tieTYT2> is there a nil/null in haskell?
20:17:39 <YayMe> ()
20:17:40 <monochrom> only for list, where it belongs
20:18:00 <tieTYT2> i consider [] to be empty more than null.  But then, maybe i'm thinking about it wrong
20:18:09 <geekosaur> not in the lisp sense, no.  in some contexts you could consider (), Nothing, or [] a "typed nil"
20:18:42 <YayMe> tieTYT2: data Null -- voila, there's a null
20:19:24 <monochrom> I hope one day John McCarthy will give a talk: "the nil atom: a thousand-dollar mistake"
20:19:46 <tieTYT2> he's still alive?
20:20:00 <tieTYT2> he died 2 years ago
20:20:01 <monochrom> oh, yikes, no, haha
20:20:03 <simpson> monochrom: What's wrong with nil, exactly? I'm implementing a Scheme and would love to know.
20:20:40 <monochrom> a function that returns a number of nil. a function that returns a boolean or nil. etc.
20:21:03 <monochrom> this is all "the null reference: a billion-dollar mistake" all over again. or even before that.
20:21:14 <simpson> Ah.
20:21:30 <YayMe> in a declarative language, I just can't imagine why there's a reason for a null
20:21:39 <simpson> Well, that's just people not being total, IMO. I don't feel that that's a problem inherent to the language.
20:21:59 <simpson> I mean, you usually don't berate people in Python for using None, or Haskell people for using Nothing.
20:22:13 <tromp> because Maybe cannot be ignored!
20:22:29 <simpson> :t fromJust -- O RLY?
20:22:31 <lambdabot> Maybe a -> a
20:22:32 <YayMe> simpson: Nothing is a value is the thing
20:22:40 <monochrom> ok, I lift it to the level of: I berate people for using untyped languages! :)
20:22:51 <geekosaur> yeh, None has much the same problem.  Maybe, you at least have to think about it (although you can stillshoot yourself in the foot with fromJust or the equivalent pattern match)
20:22:55 <sinelaw> This is a little shorter, but still looks intimidating:
20:22:57 <sinelaw> (=<<) . flip (map . (,))
20:23:07 <sinelaw> (cartesian product of lists)
20:23:21 <simpson> Maybe doesn't prevent the foot-shooting. The culture of people using the language and the general coding standards prevent the foot-shooting.
20:23:24 <tromp> forcing the programmer to use fromJust  at least makes them stop to think
20:23:26 <YayMe> simpson: null refers to not having a value, even an empty list is a value
20:23:31 <simpson> (Guns don't kill people, people kill people.)
20:24:07 <simpson> YayMe: Are you sure that NULL isn't a value? >:3
20:24:30 <YayMe> simpson: in languages that have the null that most people refer to, yes
20:24:38 <tieTYT2> monochrom: is that null talk avaiable somewhere?  I can only find the abstract
20:24:38 <simpson> 'Cause in most modern C environments, it's totally a value: (void*) 0;
20:24:53 <YayMe> that's a type, not a value
20:24:57 <YayMe> or rather
20:25:03 <YayMe> I don't know what that is heh
20:25:28 <simpson> I suggest you learn C. It's quite elegant in its own way.
20:25:48 <monochrom> http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
20:25:57 <YayMe> I learnedish it 15 years ago
20:26:19 <tieTYT2> monochrom: thanks
20:26:31 <ion> monochrom: Ah, there’s a video of that talk? Thanks for the link.
20:26:48 <tieTYT2> isn't this the guy responsible for database design too?
20:27:30 <tieTYT2> i must be thinking of someone else
20:27:58 <simpson> Is there a link to the video itself? get-flash-videos can't figure out how to download it.
20:28:21 <tieTYT2> i think i'm thinking of http://en.wikipedia.org/wiki/Edgar_F._Codd
20:28:41 <YayMe> simpson: wouldn't void* make it the lack of a value?
20:28:46 <geekosaur> Codd and Date are the database guys
20:28:59 <YayMe> rather a pointer to something that lacks a value
20:29:06 <tieTYT2> i've never heard of Date
20:29:25 <geekosaur> http://en.wikipedia.org/wiki/Christopher_J._Date
20:29:38 <monochrom> Hoare gave you quicksort
20:29:42 <simpson> YayMe: Well, yes, it's a pointer to untyped data.
20:29:57 <tieTYT2> without him, we wouldn't have a flagship algorithm
20:30:01 <tieTYT2> jk
20:30:04 <monochrom> yeah! :)
20:30:07 <YayMe> simpson: that doesn't sound much like null to me :P
20:30:16 <simpson> YayMe: But it's still got a sizeof, and you can still dereference it. The main point of it being void* is that you can assign it to any other pointer type without a cast; that kind of patterned assignment is always legal.
20:30:28 <tieTYT2> man all these amazing programmers are from the UK.  I just found out Fowler is british too
20:30:39 <tieTYT2> i mean computer scientists
20:30:54 <simpson> YayMe: (void*) 42 would be just as legal for NULL, save that it doesn't evaluate to a falsy value, which would break a *lot* of code.
20:30:59 <monochrom> Hoare is both programmer and computer scientist
20:31:11 <simpson> NULL is just a special pointer that you can compare to by value which is never a valid memory location.
20:31:24 <geekosaur> ...any more
20:31:30 * lispy was gonna say
20:31:39 <lispy> "usually isn't a valid memory location"
20:32:04 * geekosaur spent far too much of his younger days fixing old BSD sources assuming there was a null string at (char *) 0
20:32:06 <pikhq> simpson: However, (void*)0 is always NULL. It just isn't necessarily the value 0 in memory then. :)
20:32:33 <simpson> pikhq: Most C compilers have *made* it NULL with #define NULL (void*) 0
20:32:42 <pikhq> Yes.
20:32:52 <YayMe> that is really really ironic that a fellow with the last name Date had so much to do with modern databases
20:33:00 <monochrom> most of you have not actually read C standard docs or materials close to it.
20:33:03 <pikhq> C the spec requires that (void*)0 == NULL.
20:33:06 <simpson> Anyway, I can totally buy the idea that allowing bogus pointers to exist at all was a bad call.
20:33:11 <pikhq> monochrom: I actually have a copy of the spec here. :)
20:33:28 * pikhq sometimes chases bugs on a libc...
20:33:58 <monochrom> the standards say, you can use (void*)0, or even just 0 (if type-checking figures out you want a pointer). compilers may then map this 0 to whatever is right.
20:34:07 <tromp> i had to check the spec several times for my ioccc entry
20:35:18 <YayMe> shrug, I never have interest in being that close to the metal. Not sure what I'd even do down there
20:35:29 <pikhq> monochrom: Yup. That's what I was *trying* to get at.
20:35:36 <lispy> Programming below the level of libc is interesting.
20:35:38 <YayMe> write a compiler I guess is about all that comes to mind
20:35:53 <monochrom> rumours about "#define NULL ((void*)some_other_number)" may be totally false, or may be partly true of some very very old platforms way before standards
20:36:02 <lispy> It's all syscalls and symbols down there.
20:36:12 <Adeon> can I force garbage collection in ghci?
20:36:24 <Jesin> hm
20:36:25 <monochrom> yes. System.Mem.gc
20:36:26 <lispy> Adeon: yeah, performGC I think?
20:36:30 <simpson> People are way too doubting about the Way Back When. They don't even believe in the nine-bit char.
20:36:51 <monochrom> oops, System.Mem.performGC
20:37:19 <Adeon> yes, got it
20:37:22 <Adeon> thank you very much
20:37:29 <monochrom> there was a very popular public FTP server running on a 36-bit computer. I forgot its name.
20:37:35 <lispy> Adeon: you could also force allocations until it runs out of preallocated memory ;)
20:37:36 <YayMe> simpson: lol. I recall hearing stories of a 3-bit byte on some systems back whence...
20:38:08 <geekosaur> there were several big tenex machines around
20:38:40 <YayMe> simpson: the early days of any technology is like that though and kind of neat to look into, like early days of vehicles when there were steam run cars along with all kinds of contraptions, or early guns when the idea of a pepper box seemed reasonable because nobody had come up with a better idea yet
20:38:58 <YayMe> I sometimes wonder if that's where we are in the programming language world right now
20:39:18 <simpson> YayMe: Well, we haven't even had a century of programming yet, have we?
20:39:20 <geekosaur> node.js? :)
20:39:38 <lispy> simpson: some people consider Ada to be the first programmer.
20:39:50 <lispy> when whas she alive?
20:39:53 <YayMe> simpson: My point is more that, will we some day be formalized to a single one or two languages just like the internal combustion engine
20:40:02 <YayMe> or rather, evolve to
20:40:07 <simpson> YayMe: Probably. And probably they won't look a thing like what we currently use.
20:40:08 <lispy> ah, 1815-1852
20:40:47 <YayMe> simpson: perfect. so long as I can tell stories of crazy shit from back in the day
20:40:52 <shachaf> Everyone forgets about Agda Lovelace, the first constructivist.
20:40:56 <lispy> Granted, that wasn't really the same as it was now
20:41:02 <monochrom> hahahaha
20:41:02 <lispy> shachaf: heh
20:41:13 <monochrom> @remember shachaf Everyone forgets about Agda Lovelace, the first constructivist.
20:41:13 <lambdabot> I will remember.
20:42:31 <jollytime> hehe
20:42:45 <monochrom> back in the days, I had to enter programs on a typewriter, and it was the open parenthesis both ways
20:43:13 <YayMe> simpson: imagine this: It's 50 years from now, and it has for decades now been standard that the only programming language everything is done in is java
20:43:20 <YayMe> stuff of nightmares
20:44:08 <geekosaur> hey, we used to have beginning programmers who were trained on old typewriters and habitually used l for 1
20:44:15 <geekosaur> and O for 0
20:44:30 <monochrom> getLine: 10 String
20:44:41 <YayMe> that still wouldn't excuse a javatopian future
20:45:56 <lispy> YayMe: is the JVM written in Java in that future or does it run on the "bare metal"?
20:46:55 <YayMe> lispy: all processors have long since been rewired to have hardware JVM circuits
20:47:20 <YayMe> (I've heard these actually exist though I'm sure I murdered the terminology)
20:47:35 <sinelaw> and cpu's are made of cocoa powder
20:47:35 <hpaste> altmattr pasted “sybish” at http://hpaste.org/81451
20:47:36 <YayMe> I hear DOD use them
20:47:36 <lispy> Someone I work with was talking about them just today
20:48:26 <lispy> YayMe: http://en.wikipedia.org/wiki/Java_processor
20:48:51 <lispy> YayMe: there is a haskell cpu, the reduceron(sp?). It's a sort of graph reduction in hardware.
20:48:51 <altmattr> folks, that sybish paste is the "extT" method from syb, it uses type class magic to decide if a function is applicable to an argument.  However, it fails if the function in question is given a type signature
20:48:53 <shachaf> Someone should invent construcitivist category theory, where co-co-x /= x
20:49:01 <shachaf> s/cit/ct/
20:49:09 <YayMe> lispy: are you effing serious? Somebody got someone to make an actual CPU that runs haskell?
20:49:14 <altmattr> the type class mechanics are too subtle for me, can anyone help me understand what is going on?
20:49:27 <lispy> YayMe: http://www.cs.york.ac.uk/fp/reduceron/
20:49:55 <YayMe> I guess I shouldn't be surprised, there are likely haskellers smart enough to create a circuit to run the shit
20:50:03 <YayMe> you people make me feel so bloody stupid
20:50:03 <shachaf> altmattr: Oh boy. Is your goal here to understand SYB, or to do some thing?
20:50:22 <YayMe> after all, it's just a related school of engineering.
20:50:33 <altmattr> just to understand why `incNN` fails while `incN` works
20:50:39 <altmattr> I already "understand" syb
20:50:47 <shachaf> If your goal is to do some thing, you shouldn't be doing this thing. If your goal is to understand SYB, you should take a simpler example first. :-)
20:50:50 <shachaf> Ah.
20:51:03 <shachaf> I'm not sure what it means that it fails.
20:51:28 <hpaste> altmattr pasted “sybish session” at http://hpaste.org/81452
20:51:58 <altmattr> the pasted session shows `incNN` is not picked up as a function which can apply to `1`
20:52:35 <shachaf> altmattr: It's probably defaulting to Integer.
20:52:42 <altmattr> ultimately, I want to understand the way type classes allow `ext` to work, but that is perhaps further down the road
20:52:55 <shachaf> altmattr: In general with Typeable you need to have concrete types.
20:53:10 <shachaf> In this case, defaulting is happening to make them concrete.
20:53:15 <altmattr> shachaf: right you are!  thanks so much
20:53:30 <shachaf> By the way, this is awful and you should never do it.
20:54:19 <altmattr> shachaf: I get that a lot :) I would love to know why, but I am in fact trying to implement a mini SYB from a recent paper
20:56:03 <altmattr> shachaf: what in particular are you referring to as "horrible"  ? :)
20:56:12 <altmattr> sorry, "awful"
20:56:13 <altmattr> :)
21:03:30 <lispy> YayMe: I have an FPGA but I never play with it (I can't stand the xilinx tools, didn't know they were required when I bought it. Guess I'm an idiot). I always wanted to put the reduceron on there.
21:04:36 <shachaf> Put the reduceron on there, take the reduceroff off there...
21:05:19 <lispy> Someday I will get over my disdane of the xilinx stuff. Actually, maybe the windows version is not so bad and I'm on windows at home...
21:05:29 <isomorphic> A little related - has anybody had a look at these http://www.greenarraychips.com  ?
21:05:39 <simpson> Puttin dat reduceron dere, boss.
21:06:02 <lispy> :t curry
21:06:04 <lambdabot> ((a, b) -> c) -> a -> b -> c
21:07:45 <lispy> "Our measurements of Haskell programs show that on average around 20% of calls are to unknown functions, and on average 40% of those calls (8% of all calls) have more than one argument.."
21:08:20 <lispy> I wonder if that percentage has increased or stayed the same over time.
21:09:08 <shachaf> Is that from "fast curry"?
21:09:17 <simpson> isomorphic: They're nifty.
21:09:19 <lispy> Yes
21:10:10 <isomorphic> simpson:  i'm thinking if you had a bunch of VMs, running on a single, fast clocked machine… with very compromised cache coherency
21:10:26 <pzuraq> can someone explain what Functor does?
21:10:48 <isomorphic> simpson:   you might prefer to switch away from virtualisation and toward something like this…  although, it's an odd use case that would allow you to move away from x86
21:10:51 <shachaf> Classes don't do anything. They just are.
21:11:06 <simpson> isomorphic: I think that it's more along the lines of auto-parallelized map.
21:11:11 <pzuraq> can someone explain what Functor is?*
21:11:12 <shachaf> But if something is an instance of Functor, it means that in some sense or another, it "produces" values that you can map a function over.
21:11:43 <pzuraq> oh
21:11:45 <isomorphic> simpson:  how do you mean?
21:11:48 <shachaf> For example: If I have a function f :: (Bool -> Char), I can "map over" its result
21:11:54 <otters> pzuraq: a Functor is a type f where fmap :: (a -> b) -> f a -> f b
21:12:07 <shachaf> ord :: Char -> Int, so fmap ord f :: (Bool -> Int)
21:12:21 <shachaf> (This is just function composition.)
21:12:30 <shachaf> Another example: You can map a function over a list.
21:12:41 <shachaf> If l :: [Char], fmap ord l :: [Int]
21:12:47 <shachaf> (This is just "map".)
21:12:50 <pzuraq> I get mapping functions over a list using map
21:13:01 <pzuraq> is fmap just a way to apply that more generally?
21:13:05 <shachaf> Yes.
21:13:08 <serialhex> is anybody in here using hakyll 4??
21:13:09 <lispy> very generally
21:13:13 <pzuraq> ok, cool
21:13:17 <shachaf> pzuraq: But look at my example above.
21:13:25 <shachaf> You can "map over" the result of a function
21:13:34 <shachaf> Which is just function composition.
21:13:35 <lispy> > ((+1) `fmap` (*2)) 2
21:13:37 <lambdabot>   5
21:13:43 <simpson> isomorphic: Instructions just kind of "flow" into spare processors.
21:14:04 <shachaf> You can also, for example, "map over" something like Foo a = (a -> Bool) -> Bool
21:14:30 <shachaf> You can also map over a bunch of other types.
21:14:32 <shachaf> @instances Functor
21:14:33 <lambdabot> ContT r m, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
21:14:48 <pzuraq> shachaf: in your example. is it that ord is a function, and it is being passed to another function f
21:14:49 <otters> pzuraq: map is a case of fmap where f a = [a]
21:14:55 <pzuraq> pass wouldn't be the right word
21:14:57 <pzuraq> applied maybe
21:15:05 <pzuraq> and then f is spitting out the result
21:15:06 <pzuraq> ?
21:15:17 <shachaf> pzuraq: fmap ord foo is a lot like fmap ord "hello"
21:15:20 <shachaf> > fmap ord "hello"
21:15:23 <lambdabot>   [104,101,108,108,111]
21:15:44 <shachaf> > let foo False = 'A'; foo True = 'Z' in ((fmap ord foo) False, (fmap ord foo) True)
21:15:46 <lambdabot>   (65,90)
21:16:17 <sw2wolf> @instances Monad
21:16:17 <lambdabot> ArrowMonad a, ContT r m, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
21:16:25 <pzuraq> is ord a function in the standard Prelude?
21:16:51 <shachaf> I don't know.
21:16:53 <shachaf> I guess it's not.
21:16:55 <shachaf> @hoogle ord
21:16:55 <lambdabot> Prelude class Eq a => Ord a
21:16:55 <lambdabot> Data.Ord class Eq a => Ord a
21:16:55 <lambdabot> Prelude data Ordering :: *
21:17:01 <shachaf> Hmph.
21:17:04 <shachaf> @index ord
21:17:05 <lambdabot> Data.Char
21:17:27 <pzuraq> hmm
21:17:30 <pzuraq> can't use it
21:17:41 <shachaf> I'm sorry.
21:17:46 <pzuraq> is cool
21:17:51 <pzuraq> I think I get the concept
21:17:52 <shachaf> Inability to use ord is a rare medical condition.
21:17:55 <pzuraq> :P
21:18:03 <shachaf> You can still live a normal life.
21:18:14 <isomorphic> simpson:  Oh, I hadn't taken that from the site - although I had seen a feature where each processor could listen for instructions.  I kind of figured it would need a compiler / RTS to schedule jobs onto each core individually
21:36:10 <otters> is there a cross-platform way to do signal handlers
21:38:05 <lispy> which way is eta-expansion?
21:38:06 <tieTYT2> this is a little advanced for me, but how do I get the value out of "result" http://hpaste.org/81455
21:38:28 <tieTYT2> I know it's a Maybe.  I figure I can pattern match on Just a or Nothing, but I don't know how to do that in an "in"
21:38:52 <lispy> ah, e => \z -> e z
21:40:59 <otters> actually, I just want to trap SIGHUP and I'm not even sure if that's "cross-platform" or not
21:41:43 <lispy> otters: because ghc on windows uses mingw, it may endup working as expected.
21:42:22 <otters> System.Posix.Signals is in the unix package though
21:42:34 <M30W> How would you not encounter a race condition when you have two tcp connections mutating an IORev or MVar as they are in seperate lightweight threads?
21:43:08 <fmap> tieTYT2: `case result of Just x -> ...; Nothing -> ...'
21:44:02 <M30W> IORef *
21:44:03 <fmap> tieTYT2: although I don't think you can return anything on Nothing case
21:44:47 <tieTYT2> i put an error
21:44:57 <tieTYT2> but i get a compilation error: http://hpaste.org/81457
21:44:57 <fmap> =(
21:45:11 <tieTYT2> oh wait
21:45:13 <tieTYT2> i know what i did wrong
21:45:35 <tieTYT2> forgot to do getValue j
21:48:19 <tieTYT2> ugh, i need help with (.) again :(  Why doesn't this work: findKey 3 . zip [1..10] ['a'..'z']
21:48:36 <tieTYT2> findKey 3 $ zip [1..10] ['a'..'z'] works fine
21:48:54 <tieTYT2> findKey :: (Eq k) => k -> [(k, v)] -> v
21:50:09 * tieTYT2 googles
21:56:07 <tieTYT2> oh i think it's the same problem I was having last night... application binds tighter than (.).  So it was trying to call findKey 3 zip
21:56:49 <sinelaw> what's the lambdabot command for finding what a sequence of number is called
21:57:49 <fmap> @oeis 1 3 6 10 15
21:57:49 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
21:57:49 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
21:58:03 <sinelaw> fmap, thanks
21:58:28 <ski> @help oeis
21:58:28 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
21:58:31 <sinelaw> @oeis 1 2 5 14 42 132 429
21:58:33 <lambdabot>  Catalan numbers: C(n) = binomial(2n,n)/(n+1) = (2n)!/(n!(n+1)!). Also called...
21:58:33 <lambdabot>  [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440,9694845,3...
21:58:46 <sinelaw> awesome^2!
21:58:53 <ninegrid> @oeis 10 9 60
21:58:55 <lambdabot>  Triangle whose (i,j)-th entry is binomial(i,j)*3^(i-j)*10^j.
21:58:55 <lambdabot>  [1,3,10,9,60,100,27,270,900,1000,81,1080,5400,12000,10000,243,4050,27000,900...
21:59:05 <ski> @oeis 5 8 147 151 209
21:59:06 <lambdabot>  Sequence not found.
21:59:07 <ninegrid> nice
21:59:27 <Maxdamantus> @oeis 1 3 5 7
21:59:35 <fmap> tieTYT2: `findKey 3 . zip [1..10] ['a'..'z']' is `(findKey 3) . (zip [1..10] ['a'..'z'])' and the latter argument isn't in form `a -> b' so it doesn't typecheck
21:59:38 <lambdabot>  The odd numbers: a(n) = 2n+1.
21:59:38 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
21:59:55 <ski> (my brother gave me that one as a problem to mull on)
21:59:55 <Maxdamantus> @oeis 0 1 -1 2 -2 3 -3
22:00:05 <msxx> re: function application binding tighter than .
22:00:07 <lambdabot>  Canonical enumeration of integers: interleaved positive and negative integer...
22:00:07 <lambdabot>  [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,1...
22:00:17 <Maxdamantus> Fail.
22:00:22 <sinelaw> heh
22:00:25 <msxx> isn't there a function application between . and show as well? fmap toLower . show 10
22:00:42 <msxx> that should have been map
22:00:48 <msxx> (thought it doesn't matter)
22:00:54 <ski> msxx : `fmap toLower . show 10' is the same as `(.) (fmap toLower) (show 10)', yes
22:01:09 <sinelaw> OEIS says about the Catalan Numbers: " This is probably the longest entry in the OEIS, and rightly so."
22:01:20 <sinelaw> http://oeis.org/A000108
22:02:26 <pzuraq> so
22:02:41 <pzuraq> Monads are like, ways of chaining events together
22:03:00 <ninegrid> events?
22:03:40 <pzuraq> functions
22:03:42 <pzuraq> or
22:03:44 <pzuraq> like
22:03:49 <pzuraq> sorry, I'm tired
22:03:53 <tieTYT2> fmap: I thought  f . g x = f (g x).  If that's so why doesn't findKey 3 . zip [1..10] ['a'..'z']   become   findKey 3 (zip [1..10] ['a'..'z'])  ?
22:04:21 <ninegrid> pzuraq: events usually means asynchronous callbacks
22:04:47 <ninegrid> pzuraq: but yea, monads are for code that is sequentially executed
22:04:54 <gertc> Controle.Lens (peruse) is gone?
22:05:03 <pzuraq> cool
22:05:15 <msxx> ski I meant: ((map toLower .) show) 10  .    (map toLower .) form a function, so I don't see how space following it isn't counted as function application
22:05:18 <pzuraq> my textbook is throwing anonymous functions at me
22:05:27 <pzuraq> and it is destroying my brain right now
22:06:04 <ski> tieTYT2 : not `f . g x' is `f . (g x)' is `(.) f (g x)'
22:06:17 <ninegrid> pzuraq: do functions destroy your brain?
22:06:19 <ski> tieTYT2 : perhaps you meant `(f . g) x'
22:06:47 <gertc> i need it to do this lookupKey k = peruse (from keyValue.at k) ?
22:07:17 <ninegrid> are monads ruining your life? (insert footage of someone haphazardly mashing on a keyboard)
22:07:23 <tieTYT2> ski: that confused me more than clarified :P
22:07:27 <ski> msxx : space at either side of an infix operator is not parsed as application (in any normal sense)
22:07:29 <pzuraq> ninegrid: It's like when my professor in the maths makes a jump from A to Q
22:07:35 <sinelaw> @pl \x y -> if isJust x then fromJust x else y
22:07:36 <lambdabot> liftM2 if' isJust fromJust
22:07:47 <pzuraq> and I'm like "what about all the letters in between?
22:07:50 <ski> tieTYT2 : i.e. `(findKey 3 . zip [1..10]) ['a'..'z']'
22:07:55 <fmap> @ty view
22:07:56 <lambdabot> MonadReader s m => Getting a s t a b -> m a
22:08:02 <fmap> gertc: ^
22:08:08 <pzuraq> also I haven't been to class in a week
22:08:11 <pzuraq> due to sickness
22:08:14 <fmap> also (^.)
22:08:24 <sinelaw> isn't there something like this? "fromJustOrDefault"
22:08:35 <ski> @type fromMaybe
22:08:36 <lambdabot> a -> Maybe a -> a
22:08:42 <sinelaw> cool, thanks
22:08:45 <ski> @type maybe  -- also
22:08:46 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:09:08 <msxx> this is odd, System.Environment.getEnv throws error if variable wasn't found,  while less portable System.Posix.Env returns IO (Maybe String)
22:09:09 <sinelaw> just realized my @hoogle types were wrong..could have found it
22:09:23 <msxx> System.Posix.Env.getEnv
22:09:59 <gertc> why did the lens guy removed it :)
22:10:19 <Maxdamantus> @oeis 1 1 1 1 1 1 1
22:10:22 <ski> edwardk, you mean ?
22:10:30 <shachaf> gertc: peruse is just called use now.
22:10:33 <edwardk> ?
22:10:34 <lambdabot> Plugin `oeis' failed with: thread killed
22:10:43 <tieTYT2> ski: then why is it complaining about too many args to zip instead of too few?
22:10:45 <shachaf> Or am I mixed up>
22:10:52 <shachaf> gertc: Oh, it's just called view.
22:11:05 <edwardk> gertc: or do you mean 'value'?
22:11:09 <ski> tieTYT2 : because  findKey 3 . zip [1..10] ['a'..'z']  is different from  (findKey 3 . zip [1..10]) ['a'..'z']
22:11:12 <edwardk> er keyValue
22:11:17 <edwardk> that got subsumed
22:11:43 <ski> tieTYT2 : i would just write  findKey 3 (zip [1..10] ['a'..'z'])  though
22:12:02 <ski> (which is the same as the latter of the previous two)
22:12:40 <tieTYT2> ski: I would too, but i've noticed I don't know how to use (.) unless it's through trial and error
22:12:46 <gertc> dont know :) lookupKey :: String -> Query KeyValue (Maybe User)
22:12:48 <tieTYT2> i seem to be able to read it ok though (in general)
22:12:56 <gertc> lookupKey k = peruse (from keyValue.at k)
22:13:04 <ski> tieTYT2 : i don't think this is a very natural case to use `(.)' in
22:13:16 <shachaf> gertc: peruse is now called view
22:13:29 <fmap> edwardk: could all Folds be generalized to `MonadReader => blahblah' ?
22:13:56 <gertc> shachaf: ok thx :)
22:14:59 <ski> tieTYT2 : if you must know about the error, it's because  findKey 3 . zip [1..10] ['a'..'z']  is the same as  \arg -> findKey 3 (zip [1..10] ['a'..'z'] arg)  -- note the third `arg'
22:15:11 <tieTYT2> ski: this other example I read yesterday was really confusing me too.  This comes from learn you a haskell: map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
22:15:57 <tieTYT2> to me I feel like I'm using a that first (.) the same way he is in my findKey 3 . zip [1..10] ['a'..'z']
22:16:09 <tieTYT2> to me I feel like I'm using that first (.) the same way he is in my findKey 3 . zip [1..10] ['a'..'z']
22:16:12 <ski> tieTYT2 : read that as `blah . bleh . bloh $ stuff' -- the `blah . bleh . bloh' is a composed function (a "pipeline", if you will)
22:16:27 <ski> tieTYT2 : while the `stuff' is input fed to the pipeline
22:16:38 <kennyd> tieTYT2 you don't have $
22:16:55 <ski> tieTYT2 : another way to say the same thing is `(map (\l@(x:xs) -> (x,length l)) . group . sort) [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]'
22:16:58 <kennyd> findKey 3 . zip [1..10] $ ['a'..'z'] would be the same
22:17:18 <tieTYT2> kennyd: ohhh. I didn't know the $ was having a major effect on that
22:17:32 <ski> .. as would  findKey 3 $ zip [1..10] ['a'..'z']
22:17:44 <kennyd> tieTYT2 it is the same as (findKey 3 . zip [1..10]) ['a'..'z']
22:17:57 <ski> tieTYT2 : `blah . bleh . bloh $ stuff' parses as `(blah . bleh . bloh) $ (stuff)'
22:18:21 <tieTYT2> what's blah . bleh . bloh stuff   parse as?
22:18:48 <ski> `(.)' is an associative operation, so you shouldn't normally be that concerned
22:19:21 <ski> however, `:i .' in GHCi/Hugs replies `infixr 9 .'
22:19:44 <ski> the `r' in `infixr' means that it's "right-associative", meaning it parses as `blah . (bleh . bloh)'
22:20:13 <tieTYT2> hm maybe you missed that I didn't have a $ in my question?
22:20:37 <ski> tieTYT2 : oh, maybe you were asking what `blah . bleh . bloh stuff' parses as ? -- it parses as `blah . bleh . (bloh stuff)' (which then parses as `blah . (bleh . (bloh stuff))', due to `infixr' there)
22:21:13 <ski> tieTYT2 : i read your `stuff' as an english word, probably because you didn't quote :)
22:21:23 <tieTYT2> sorry
22:22:11 <tieTYT2> it looks like `blah . bleh . bloh stuff` is perfectly reasonable a lot of the time (stuff being an argument).  Am I right about that?
22:22:20 <ski> yes
22:22:46 <tieTYT2> but if it's like `blah . bleh . bloh arg1 arg2` is that perfectly reasonable?
22:23:07 <kennyd> only if bloh arg1 arg2 form a function compatibl with the rest of the chain
22:23:13 <ski>   map f . groupBy eq . sortBy cmp  -- e.g., perhaps
22:23:46 <ski> tieTYT2 : yes, if `bloh' takes at least three arguments (and what kennyd said)
22:24:39 <ski> tieTYT2 : note that how things parses is not affected by typing -- you can understand how something parses without having to grasp the types of it yet
22:24:50 <pzuraq> ok, lemme ask
22:24:53 <tieTYT2> ok, and to reiterate `blah . bleh . bloh $ stuff` is for when bloh takes one arg
22:24:57 <pzuraq> why do you need Monads anyways?
22:25:14 <ski> tieTYT2 : s/one arg/at least one arg/, strictly speaking :)
22:25:19 <pzuraq> why can't you just be like h (g (f x))
22:25:21 <ski> (it depends on what you want to do)
22:25:28 <pzuraq> to chain evalutations
22:25:32 <ski> pzuraq : removing boilerplate code
22:25:36 <tieTYT2> ski: in other words it could take more than one arg if i'm doing partial application?
22:25:48 <pzuraq> ski: So it just makes it simpler?
22:26:46 <tieTYT2> pzuraq: not to mention that most of the examples you'll read will use . and $
22:27:02 <pzuraq> damnit
22:27:06 <pzuraq> I don't know what those do
22:27:10 * pzuraq looks this shit up
22:27:28 <ski> pzuraq : see "What the hell are Monads?" by Noel Winstanley in 1999 at <http://www-users.mat.uni.torun.pl/~fly/materialy/fp/haskell-doc/Monads.html> for some simple examples of the kind of boilerplate that is removed
22:28:06 <tieTYT2> pzuraq: I may not have been replying to your question.  I thought you got involved in my convo when I replied
22:28:24 <pzuraq> tieTYT2: is gud, I need to learn those anyways
22:28:31 <pzuraq> $ makes sense
22:28:50 <pzuraq> it does f (g x) => f $ g x
22:28:51 <pzuraq> ?
22:28:55 <ski> tieTYT2 : if `bloh' takes two args, then in `blah . bleh . bloh $ stuff', the function `bloh stuff' that still waits for the second argument will be passed as *argument* to `bleh'
22:29:06 <ski> pzuraq : yes
22:29:10 <pzuraq> sweet
22:29:19 <shachaf> ski: `blog stuff'?
22:29:28 <shachaf> Ah.
22:29:31 <shachaf> I misread.
22:29:33 <ski> no, `bloh stuff' :)
22:29:58 <shachaf> Oh, and I mistyped too.
22:30:09 <ski> (?)
22:30:11 <shachaf> I should get a better keyboard layout.
22:30:21 <shachaf> One that doesn't put h next to g.
22:30:29 * ski suggests moving `0' to the left of `1'
22:31:15 <sinelaw> @pl (sum x) / (length x)
22:31:15 <lambdabot> sum x / length x
22:31:17 <ski> @src ($)
22:31:17 <lambdabot> f $ x = f x
22:31:21 <sinelaw> @pl \x - >(sum x) / (length x)
22:31:21 <lambdabot> (line 1, column 4):
22:31:21 <lambdabot> unexpected " "
22:31:21 <lambdabot> expecting "->"
22:31:23 <pzuraq> . does f (g x) => f.g x ?
22:31:23 <tieTYT2> ski: ok, that's partial application right?  and if I let x = that whole thing, I could call x secondArg and see the result?
22:31:25 <sinelaw> @pl \x - > (sum x) / (length x)
22:31:25 <lambdabot> (line 1, column 4):
22:31:25 <lambdabot> unexpected " "
22:31:25 <lambdabot> expecting "->"
22:31:30 <sinelaw> nvm.
22:31:32 <sinelaw> pm
22:31:59 <ski> @type sum / genericLength
22:32:01 <lambdabot> (Fractional ([a] -> a), Num a) => [a] -> a
22:32:21 <ski> tieTYT2 : yes and no, respectively
22:33:00 <ski> @pl \x -> sum x / length x
22:33:00 <lambdabot> liftM2 (/) sum length
22:33:02 <sinelaw> ski, what's that /
22:33:15 <ski> > (sin / cos) (pi / 8)
22:33:18 <lambdabot>   No instance for (GHC.Real.Fractional (a0 -> a0))
22:33:18 <lambdabot>    arising from a use of `...
22:33:23 <sinelaw> @type (/)
22:33:24 <lambdabot> Fractional a => a -> a -> a
22:33:27 <ski> hm
22:33:48 <sinelaw> you got a Fractional function?
22:33:54 <tieTYT2> why the no?
22:34:06 <sinelaw> :)
22:34:09 <ski> it seems `instance Num n => Num (rho -> n)' and friends have disappeared from lambdabot
22:34:16 <pzuraq> can someone explain the (.) operator?
22:34:52 <c_wraith> pzuraq: f . g = \x -> f (g x)
22:34:54 <ski> tieTYT2 : because "the function `bloh stuff' that still waits for the second argument will be passed as *argument* to `bleh'"
22:35:13 <c_wraith> pzuraq: I mean, that's the definition of it - but it's not too unreadable as an explanation of what it does
22:35:22 <c_wraith> (f . g) x = f (g x)
22:35:38 <ski> tieTYT2 : so, `bleh' will be the one which provides `secondArg' to `bloh stuff' -- `x' will not
22:35:42 <pzuraq> c_wraith: Ah, makes sense
22:35:55 <tieTYT2> ski: and if it doesn't it's a type mismatch?
22:36:00 <ski> right
22:36:08 <tieTYT2> interesting interesting
22:36:31 <tieTYT2> ok knowing me I'll probably have to wrestle with this same thing a few more times until it clicks but I feel like I know more
22:36:38 <pzuraq> so it's an alternate way of chaining the functions together?
22:38:33 <ski> tieTYT2 : if you use my `(.:)', you could say `x = (blah . bleh) .: bloh $ stuff' if you want `x secondArg' to pass `secondArg' to `bloh stuff'
22:38:37 <mm_freak> edwardk: you've done it…  i'm moving to github =)
22:39:00 <ski> .. though in this case, it would be simpler to say `x = blah . bleh . bloh stuff' then
22:39:25 <mm_freak> i've received three requests to put netwire on github now
22:39:51 <tieTYT2> ok, thanks for the help
22:39:55 <ski> np
22:48:09 <NemesisD> is requiring haskell98 discouraged for new projects?
22:48:24 <NemesisD> I need its data Day = Monday | Tuesday .... ADT
22:49:14 <edwardk> mm_freak: hahaha
22:49:51 <edwardk> Nemesis: lots of people write haskell 98. lots of other people think thats silly. its a matter of taste
22:50:07 <edwardk> i tend to write haskell 98 until i can't any more, then i go nuts
22:50:13 <shachaf> Some people write Haskell 98 *and* think it's silly.
22:50:30 <edwardk> true
22:51:03 <NemesisD> edwardk: are the haskell98 package and base mutually exclusive? i'm not planning on writing 98 per se, just want that Day type without reimplementing it myself
22:51:24 <edwardk> NemesisD: the haskell 98 package itself is mutually exclusive with base, yes
22:51:48 <NemesisD> well damn, why'd they get rid of that type
22:52:14 <edwardk> @hackage old-time
22:52:14 <lambdabot> http://hackage.haskell.org/package/old-time
22:52:17 <edwardk> NemesisD: look in there
22:53:11 <edwardk> basically ashley yakeley pretty much gutted and rewrote the time system iirc
22:53:28 <NemesisD> yeah, i don't want to condemn my users to using a deprecated library
22:56:17 <NemesisD> i like the time library but it seems like a step backwards as far as datatypes go
22:56:37 <edwardk> well, its a step forward in terms of correctness
22:57:05 <NemesisD> was the other one incorrect?
22:57:29 <edwardk> old-time had a charmingly naive notion of time
22:57:51 <pzuraq> >wut
22:57:56 <edwardk> ?
22:58:06 <pzuraq> why can't I make a function f :: a -> Maybe b?
22:58:18 <edwardk> :t undefined :: a -> Maybe b
22:58:20 <lambdabot> a -> Maybe b
22:58:23 <pzuraq> oh
22:58:25 <edwardk> :t const Nothing
22:58:26 <shachaf> @ty const Nothing :: a -> Maybe b
22:58:26 <lambdabot> b -> Maybe a
22:58:27 <lambdabot> a -> Maybe b
22:58:31 <pzuraq> because I'm not returning a JUST
22:58:33 <pzuraq> Just*
22:58:34 <shachaf> edwardk: You got it backwards!
22:58:40 <edwardk> shachaf: =)
22:58:53 <edwardk> pzuraq: const Nothing
22:58:57 <edwardk> :t \x -> Nothing
22:58:58 <lambdabot> t -> Maybe a
22:59:13 <shachaf> pzuraq: In general with a question like that, you should mention what you tried and the error you got.
22:59:21 <shachaf> Otherwise questions like that seem rather mysterious.
22:59:35 <pzuraq> now I'm getting
22:59:47 <pzuraq> No instance for (Num a)
22:59:48 <pzuraq>       arising from a use of `*'
22:59:48 <pzuraq>     In the first argument of `Just', namely `(10 * x)'
22:59:49 <pzuraq>     In the expression: Just (10 * x)
22:59:51 <pzuraq>     In an equation for `multMaybe': multMaybe x = Just (10 * x)
23:00:10 <shachaf> That's half of "what you tried and the error you got"
23:00:19 <shachaf> The other half is going to hpaste.org and pasting in the code. :-)
23:00:29 <pzuraq> the code is right there
23:00:41 <pzuraq> multMaybe x = Just (10 * x)
23:00:44 <shachaf> No it's not.
23:00:56 <pzuraq> this is just playing around with Monads
23:00:56 <shachaf> > let multMaybe x = Just (10 * x) in multMaybe 5
23:00:58 <lambdabot>   Just 50
23:01:01 <pzuraq> trying to figure out how they work
23:01:07 <pzuraq> I typed it first
23:01:16 <pzuraq> multMaybe :: a -> Maybe a
23:01:33 <shachaf> OK, that type is wrong.
23:01:40 <shachaf> So GHC is telling you the function doesn't match the type.
23:01:46 <shachaf> Try commenting out the type and asking ghci what it is.
23:02:30 <pzuraq> how do I ask it the type again?
23:02:42 <shachaf> With :t
23:02:56 <pzuraq> ah
23:03:00 <pzuraq> have to specify Num a
23:03:17 <shachaf> And in general please provide the whole code when you ask a question. :-)
23:03:29 <pzuraq> will do
23:03:31 <shachaf> If you knew exactly where the problem was, you wouldn't have the problem.
23:18:00 <zolk3ri> @where Hafydd's_dick
23:18:00 <lambdabot> http://i.imgur.com/gzWevd8.jpg
23:18:27 <zolk3ri> NSFW
23:18:32 <Hafydd> ._.
23:18:35 <Hafydd> Thanks zolk3ri.
23:18:46 <zolk3ri> k it is safe
23:18:48 <zolk3ri> lool
23:19:06 <zolk3ri> leT's just hope everyone is sleeping
23:19:07 <shachaf> @where ops
23:19:07 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
23:19:07 <lambdabot> xerox
23:19:32 --- mode: ChanServ set +o edwardk
23:19:55 --- mode: edwardk set +b *!~Zol1ka@unaffiliated/zolk3ri
23:19:56 --- kick: zolk3ri was kicked by edwardk (Your behavior is not conducive to the desired environment.)
23:29:21 <tieTYT2> is it possible to define a type signature for something between a "let ... in" or after a where?
23:29:32 <shachaf> Yes.
23:29:51 <tieTYT2> how do you do that?
23:29:58 <mm_freak> tieTYT2: just write it like they would be top level definitions, i.e. indent the type signature, too
23:30:11 <tieTYT2> ah ok cool
23:31:42 <tieTYT2> thanks
23:35:11 <msxx> what is the usual naming convention for C define values? FOO_BAR
23:35:30 <shachaf> Some people like a c_ prefix.
23:35:39 <shachaf> That way you can keep the capitalization.
23:35:51 <shachaf> Of course, if you wanted, you could use CPP and the #defines directly. :-)
23:35:58 <msxx> I have seen fOO_BAR and it's fugly
23:36:10 <shachaf> They're all ugly.
23:36:12 <neutrino> ew
23:37:40 <lightquake> msxx: ew
23:38:04 <msxx> I think I like foo_bar the most
23:47:29 <lightquake> I'm looking at haskell-mode and it's a bit scary how much stuff talks about haskell 1.4.
23:49:59 <shachaf> Haskell 1.4 was generally better than Haskell 98.
23:51:17 <mikeplus64> damn haskell report hipsters
23:51:51 <shachaf> mikeplus64: Have you found any exciting new ways to write unsafeCoerce lately?
23:52:11 <lightquake> ?
23:52:17 <lightquake> what's this about unsafeCoerce?
23:52:35 <mikeplus64> shachaf: nope
23:52:39 <shachaf> mikeplus64 wrote a Haskell bot.
23:52:54 <shachaf> We managed to write unsafeCoerce and segfault it three different ways so far.
23:53:03 <shachaf> (Using known bugs.)
23:53:06 <shachaf> (/features)
23:53:08 <lightquake> ah
