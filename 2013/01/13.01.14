00:03:10 <MatthiasGoergens> There is a standard argument order for Haskell functions. E.g. A modifying function should have a type like a -> b –> something –>something.
00:03:25 <MatthiasGoergens> Does anyone have a link to the full recommendations?
00:05:45 <shachaf> There are no full recommendations that I know of.
00:05:58 <shachaf> The rule of thumb is to think about partially applying the function.
00:06:14 <shachaf> E.g. "\xs -> map f xs" is a useful function; "\f -> map f xs" isn't so useful.
00:07:05 <MatthiasGoergens> Yes. I had hoped somebody had written the whole thing down. For pointing a coworker at.
00:09:43 <Ralith> what whole thing
00:10:55 <Valseir> Hi - does anybody know if there is a clean way to write GTK 3.0 apps with Haskell? It seems GTK2HS is still on GTK 2.x
00:13:01 <srhb> Valseir: Porting gtk2hs to GTK3 would be the cleanest way. Probably not a lot of work involved, but I know a few people tried and failed anyway.
00:14:11 <Valseir> srhb: That's what scares me a little bit. I am still a haskell Newbie, but I really want to mess around with the GTK 3 UI stuff also. Any ideas on why they failed?
00:14:48 <srhb> Valseir: It appears I am mistaken. Someone did indeed patch it. I don't think it's in the development version though.
00:15:00 <fmap> leksah guys claim they support gtk3
00:16:26 <Valseir> Oh nice, I see this on leksah group now: https://groups.google.com/forum/?fromgroups=#!topic/leksah/x8Hjj1jCjPA   - thanks for the heads-up, I'll try that patch.
00:17:17 <Valseir> As a 12-year-experienced serious OO programmer (Java) I am so enjoying Haskell's different approach. I'm only about 6 months in, but it's refreshing indeed.
00:20:36 <fmap> I thought we have the same painful approach to GUI as anywhere
00:21:09 <srhb> Yeah, feels like it to me. :P
00:21:30 <FYCouch> any apl channels please?
00:21:44 <FYCouch> i know this is #haskell sorry but you guys also have a clue (but can't do http://www.youtube.com/watch?v=a9xAKttWgP4)
00:21:50 <Valseir> Oh, I meant in the non-GUI aspects. GUI development is indeed still painful, Haskell/GTK or otherwise :-)
00:23:09 <srhb> Valseir: Then I totally agree with you. It's actually almost "enough" of a bonus that we get the rest, even without GUI being as clean
00:23:32 <srhb> (Although I have yet to do much GUI programming in Haskell)
00:23:39 <FYCouch> and yes, the video is amazing
00:24:06 <Valseir> That video is really amazing, thanks for sharing FYCouch. Sorry I can't answer your question though.
00:24:44 <vetoz> Hi!
00:24:50 <FYCouch> you're welcome. have you ever seen haskell be so amazing?
00:25:05 <FYCouch> (even as amazing as it is, it seems APL wipes the floor with it?)
00:25:27 <gdeest_> Hi, I have some very practical question: is there a canonical way to develop a "modular" app ? I've been developing software to collect data from USB weather stations, and would like to allow multiple storage backends. Still, I feel it's stupid to require the user to install _all_ the libraries for _all_ backends if he's only interested in one...
00:25:31 <shachaf> Discussions about which languages wipes the floor with which are not really productive in here.
00:25:47 <Valseir> Well, they are fundamentally different. - APL and Haskell. I agree, no treally worth discussing.
00:25:59 <shachaf> gdeest_: If this is a Cabal question, you can use flags for that, I think.
00:26:11 <FYCouch> oh sorry, wasn't meant as a troll
00:26:28 <FYCouch> genuine interest: how would you say haskell and apl differ?
00:26:39 <shachaf> Completely.
00:27:20 <gdeest_> shachaf: thanks, I'll have a look at that
00:27:41 <xenocons> FYCouch: nice, APL
00:27:48 <gdeest_> (And yes, it /might/ be a Cabal question)
00:27:49 <xenocons> into J?
00:28:02 <FYCouch> into J?
00:28:03 <xenocons> ive scratched the tutorials for J, been meaning to learn more
00:28:08 <FYCouch> ah, url?
00:28:12 <xenocons> http://www.jsoftware.com/
00:28:28 <shachaf> You should ask in #jsoftware or something. :-)
00:28:51 <xenocons> cool, a new channel to add heh
00:29:57 <xenocons> that youtube vid was cool
00:31:52 <xenocons> constantly reminded of how sexy apl is heh
00:32:20 <FYCouch> http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=4&ved=0CEsQFjAD&url=http%3A%2F%2Fmath.postech.ac.kr%2F~sungpyo%2FCalculus1%2FChapter2.pdf&ei=rsHzUOnXIYreiAKV64DADA&usg=AFQjCNHTliuPrulRiWYQhERnx3eoniSP3Q&bvm=bv.1357700187,d.cGE
00:32:24 <FYCouch> what a piece of shit paper
00:32:49 <FYCouch> 2 paragraphs on algebraic functions
00:32:51 <xenocons> if you had said 'what an awesome paper' i might open that link =p
00:33:01 <FYCouch> then 1 paragraph on what trancendental functions *are not*
00:33:05 <srhb> Why would you link a bad paper, which is unrelated to Haskell?
00:33:11 <FYCouch> but no direct explanation of what they *are* (??)
00:33:15 <srhb> Perhaps you meant to post it to #haskell-blah
00:33:18 <shachaf> This is in general not really a channel for talking about how bad things are.
00:33:31 <shachaf> It's meant for talking about Haskell things. :-)
00:33:40 <FYCouch> sorry i was being a human. scratch that, the rest stands
00:33:52 <FYCouch> but trancendental function
00:33:57 <lambdabot> not everyone can be a bot
00:34:07 <FYCouch> where would i find this?
00:34:09 <shachaf> FYCouch: Perhaps I can interest you in #math
00:34:35 <FYCouch> good idea, thanks!
00:35:05 <rohitkav>  Hi team, I am trying to organize a meet in my state in India for Haskell community.  suggestions for the discussion. Kindly share your thoughts
00:35:24 <srhb> inb4 "lens"
00:38:22 <dolio> shachaf: Seems like a good place for him.
00:43:47 <srhb> Seems a bit weird that the gtk3 patches haven't been merged into some devel version of gtk2hs
00:43:54 <simon____> rohitkav, that really depends. monad transformers, web frameworks, parser combinators, literate haskell.
00:45:40 <rohitkav> ok. simon____  We are starting this community so that these discussions do happen in future. This is the first meet, since we never had any community as such so far. We had thought but couldn't meet at place to have a discussion and continue further with new events, so was the question for people who been into Haskell events
00:46:58 <simon____> rohitkav, it depends on the participants. you don't want to start off too boring, too high-level, too theoretical, or too practical. but you'll figure it out easily by talking to the other participants and getting a feeling for what their interests are.
00:46:58 <rohitkav> If in case the coffee meet is successful and people show interests for an event or something like building software by community, I was thinking in this perspective .
00:47:03 <srhb> rohitkav: I guess you should start by getting an idea of your audience - are they new to Haskell, experienced Haskellers, or whatever.
00:47:43 <rohitkav> few know a bit of haskell. Few are learning including myself. so we wanted this community so that learning happens in better pace
00:48:00 <simon____> rohitkav, I once started a writers' club, and what we did was keep the introductory meetings very informal, just to get to know each other.
00:48:39 <rohitkav> Yes simon____  we are just right now trying to hang around in a caffe shop trying to figure out what will be further steps
00:49:07 <simon____> so... I suppose you should probably ask your questions in a coffee shop then =)
00:49:10 <rohitkav> So I wanted to know how was people who did similar community go further , some suggestions so that more people join
00:49:16 <rohitkav> :)
00:49:50 <simon____> I don't think there are any special tricks to Haskell communities when it comes to community building.
00:50:01 <rohitkav> I was bit concerned so just hope we continue doing it :)
00:50:32 <simon____> except maybe some target audience analysis, but you can probably tell even more by looking at the particular individuals that show up
00:50:43 <rohitkav> yes simon____
00:52:08 <rohitkav> We hardly have people who are expert in here, so we need experts in future for more discussions.
00:53:08 <rohitkav> only few are around and hope we get lot of inputs from the Haskell communities around to go further :)
00:53:30 <RawProduce> if we want better quality discussion in here, convince prominent Haskell users to participate
00:53:45 <RawProduce> in the Symfony2 community, we have core devs hanging around in the channel, for example
00:54:04 <srhb> RawProduce: We do.
00:54:11 <srhb> RawProduce: Also that was not what the conversation was about.
00:54:21 <RawProduce> hah, coffee still kicking in
00:54:39 * RawProduce waits 15 minutes before saying anything more...
00:56:43 <rohitkav> What I experienced is Haskell community are great supportive people in here. So I can figure out one or the other people who could join us soon for further events if present one goes good
00:58:32 <srhb> rohitkav: I think what you're asking is very vague, and the answer ends up being "just do it" :P Also, ideally some among your community members will become experts, and at a pace that will keep their presentations relevant to the rest of the community.
00:59:23 <rohitkav> thanks srcerer
00:59:30 <rohitkav> thanks srhb
01:04:01 * hackagebot backward-state 0.1.0.2 - A state monad that runs the state in reverse through the computation  http://hackage.haskell.org/package/backward-state-0.1.0.2 (LukePalmer)
01:08:12 <maki`> is qthaskell.berlios.de the most stable and up-to-date qt bindings for haskell?  it hasn't been updated since 2010
01:09:54 <ion> backward-state, huh? There’s already tardis.
01:13:28 <srhb> ion: Isn't tardis a combination of that and regular State?
01:13:47 <shachaf> ion: I don't know very much about either, but I already like backward-state more.
01:14:45 <simpson> Hm. Build failures.
01:15:38 <srhb> Is it normal to have the main module really named Main for executable projects?
01:15:52 <shachaf> The module should be named Main.
01:15:57 <shachaf> The file can be named whatever you like.
01:16:01 <srhb> Great. :)
01:16:02 <shachaf> Main is a pretty good choice, though.
01:16:34 <gienah_> maki``: yes
01:16:48 <gspr> maki``: It's a shame, imo :/
01:18:02 <gienah_> qthaskell doesn't build with ghc 7.6.1, I'm not sure how to fix that, I don't know where the source code repo is, looked tricky to fix since the errors are in generated code
01:18:09 <gspr> maki``: Every now and then I ponder about what it would take to autogenerate some maintainable "low-level" bindings to Qt, but it seems a daunting task
01:18:25 * gienah_ was not sure what this generated code was generated from 
01:18:35 <srhb> Isn' that what HQK was supposed to be?
01:18:38 <srhb> Or whatever it was called.
01:18:48 <gspr> srhb: Yeah, I think so. I never looked at it, though.
01:19:15 <ion> srhb: It’s a superset of both, yes.
01:21:21 <gspr> Talking of this, does anybody know how usable qthaskell.berlios.de actually was? I mean, how cumbersome was it to work with stuff like inherited classes etc through a direct binding like that?
01:22:29 <gienah_> gspr: it seems to work in simple tests with ghc 7.4.1
01:22:59 <gspr> gienah_: Yeah, I've also done some simple tests, and it certainly worked -- but I can imagine it must be kinda strange to use for anything beyond the simplest examples
01:24:01 * hackagebot data-partition 0.1.0.0 - A pure disjoint set (union find) data structure  http://hackage.haskell.org/package/data-partition-0.1.0.0 (LukePalmer)
01:29:01 * hackagebot webserver 0.6.0.1 - HTTP server library  http://hackage.haskell.org/package/webserver-0.6.0.1 (JohnLato)
01:32:03 <pnielsen> is the site that used to be learnyouanagda available somewhere? https://github.com/liamoc/learn-you-an-agda (apparently not compatible with hakyll anymore)
01:32:11 <pnielsen> used to be learnyouanagda.com*
01:33:12 <Taneb> ha/ha/!
01:34:14 <Taneb> Just got an OpenGL tutorial example working
01:34:25 <Taneb> (the tutorial was written for C, I had to transliterate)
01:34:41 <srhb> Taneb: Grats :P
01:34:51 <srhb> Does the code hurt your eyes yet?
01:35:01 <Stigm> чОрт
01:36:12 <Taneb> The fact that the shaders aren't typechecked annoys me
01:36:44 <Taneb> And I'm annoyed at having to account for global variables
01:39:17 <Taneb> Okay, it gets through Wall and hlint
01:39:52 <bas__work> I have this definition "Tree' f (Just fs) <*> Tree' x (Just xs) = Tree' (f <*> x) (Just $ zipWith (<*>) fs xs)" for some fairy-tale type "data Tree' a = Tree' (Maybe a) (Maybe [Tree' a])", but the "Just fs, Just xs, Just $ zipWith (<*>) fs xs" looks a bit retarded. How would I write it more to the point?
01:40:31 <bas__work> like I wanna write "Tree' f fs <*> Tree' x xs = ..."
01:40:55 <gienah_> maki``: in case its of interest: Haskell binding to the Qt Quick framework http://www.gekkou.co.uk/software/hsqml/
01:48:31 <Saizan> bas__work: use liftA2
01:49:20 <Saizan> bas__work: Tree' f fs <*> Tree' x xs = Tree' (f <*> x) (liftA2 (zipWith (<*>)) fs xs)
01:50:03 <Saizan> bas__work: btw, zipWith is liftA2 for ZipList (though i'd stick to zipWith due to the newtype noise)
01:51:05 <bas__work> Saizan: thanks a lot =]
01:51:23 <maki`> gienah_ thanks I will take a look
01:54:52 <merijn> mornin' #haskell
01:55:00 <Taneb> Morning
01:55:04 <srhb> morning merijn
02:01:55 <gspr> Does anybody know why the ForeignPtr hackage documentation for base 4.6.0.0 gives a 404?
02:02:05 <M30W> Hmm. How do you tell cabal haddock to generate the documentation for the libraries to a package which builds to an execuitable?
02:02:13 <M30W> Just --executables ?
02:02:25 <gspr> Seems to be the case all the way back to 4.4.0.0
02:04:13 <quicksil1er> gspr: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html is 4.6
02:04:16 <quicksil1er> looks OK to me
02:04:51 <Taneb> quicksil1er, the ones on Hackage aren't, though
02:04:51 <gspr> quicksil1er: I mean Foreign.ForeignPtr
02:05:04 <Taneb> Wait
02:05:14 <gspr> quicksil1er: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Foreign-ForeignPtr.html
02:05:23 <Taneb> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/GHC-ForeignPtr.html
02:05:30 <quicksil1er> is Foreign.ForeignPtr even a module, gspr?
02:05:44 <quicksil1er> ForeignPtr is docced at the top level of Foreign : http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign.html
02:05:55 <quicksil1er> (I mean is it even a module *any more*)
02:06:03 <Taneb> It's split into Safe and Unsafe
02:06:10 <gspr> quicksil1er: Oh.. sorry... thanks for enlightening me :)
02:06:24 <quicksil1er> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Foreign.html
02:06:35 <quicksil1er> I think they moved the internal bits into a GHC module
02:06:35 <gspr> Should I report the fact that hackage points to http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Foreign-ForeignPtr.html, which is a 404, as a bug?
02:06:44 <gspr> I see.. that explains it
02:06:44 <quicksil1er> (which is intentionally hidden)
02:06:55 <quicksil1er> where do you see a link to that page, gspr?
02:07:04 <gspr> quicksil1er: http://hackage.haskell.org/package/base-4.6.0.0
02:07:07 <quicksil1er> oh, I see it too
02:07:10 <quicksil1er> well that is most peculiar
02:07:13 <marekw2143> hello
02:07:20 <quicksil1er> yes that seems like a bug, although I don't know what it's a bug in :)
02:07:34 <gspr> quicksil1er: And more importantly the first hit in http://www.haskell.org/hoogle/?hoogle=ForeignPtr
02:07:41 <quicksil1er> it's not linked from here :
02:07:42 <quicksil1er> http://www.haskell.org/ghc/docs/latest/html/libraries/base/index.html
02:07:48 <gspr> Ah.. strange!
02:07:56 <quicksil1er> I"m going to guess that hackage is running an old version of haddock
02:08:03 <gspr> I see
02:08:03 <quicksil1er> where teh main GHC docs use the right (newer) haddock
02:08:04 <hpaste> marekw2143 pasted “sequenceA” at http://hpaste.org/80727
02:08:06 <quicksil1er> that's only a guess though.
02:08:10 <gspr> makes sense
02:08:40 <marekw2143> when evaluating: sequenceA [[1,2],[3,4]]  , why does it makes a product of [1,2] and [3,4] (hpaste.org/80727)
02:08:59 <quicksilver> because that's what the appropriate instances for lists ([]) do.
02:09:23 <Iceland_jack> marekw2143: search for lists and applicative
02:09:24 <marekw2143> I mean it's evaluated like that: ((:)[1,2]) <*>    ((:)[3,4] [])
02:09:32 <marekw2143> Am I right?
02:11:17 <marekw2143> Iceland_jack: so it's lke that: fs <*> xs = [f x| f<- fs, x <- xs]
02:18:37 <marekw2143> Iceland_jack: thanks, just thought that (:) <$> [1,2] would evaluate to (:)[1,2] instead of [(:)1, (:)2]
02:19:18 <Iceland_jack> no problem :) sorry I didn't respond much, am a bit preoccupied
02:32:53 <mrout> @where lyah
02:32:53 <lambdabot> http://www.learnyouahaskell.com/
02:46:25 <mrout> I can't quite get $
02:46:44 <srhb> mrout: What do you mean?
02:46:46 <mrout> is "blah blah blah $ blah blah blah" equivalent to "(blah blah blah) (blah blah blah)"?
02:46:55 <ocharles> mrout: it's blah blah blah (blah blah blah)
02:47:09 <mauke> mrout: yes
02:47:14 <mrout> thanks.
02:47:42 <`nand`> @src ($)
02:47:42 <lambdabot> f $ x = f x
02:48:04 <mrout> @src (.)
02:48:04 <lambdabot> (f . g) x = f (g x)
02:48:04 <lambdabot> NB: In lambdabot,  (.) = fmap
02:48:16 <mrout> good...
02:48:45 <mrout> so "blah blah blah . blah blah blah" is..?
02:49:00 <mauke> @unpl blah blah blah . blah blah blah
02:49:00 <lambdabot> (\ c -> blah blah blah (blah blah blah c))
02:49:09 <mauke> tee hee
02:49:19 <mrout> @unpl blah blah blah $ blah blah blah
02:49:19 <lambdabot> (blah blah blah (blah blah blah))
02:49:23 <mrout> right, right.
02:49:24 <typoclass> mrout: "$" is basically like "space", i.e. function application, but with lower precedence. you can more or less think of "$" as a way to save some typing on parens. replace an opening parens with $, and you can leave off the closing parens
02:49:38 <`nand`> ($) can also be used as a section
02:49:40 <`nand`> eg. ($x)
02:49:45 <`nand`> is the same as (\f -> f x)
02:50:06 <mauke> ($) is also id
02:51:14 <int-e> > ($) 1
02:51:16 <lambdabot>   No instance for (GHC.Num.Num (a0 -> b0))
02:51:16 <lambdabot>    arising from a use of `e_11'
02:51:16 <lambdabot>  P...
02:51:30 <`nand`> right, but since it has a more restricted signature it can be useful in guiding the type system (eg. for clarifying a type signature)
02:51:39 <`nand`> > (view _1 $)
02:51:40 <lambdabot>   Ambiguous type variables `t0', `b0' in the constraint:
02:51:40 <lambdabot>    (Control.Lens.Tup...
02:51:45 <`nand`> err
02:51:47 <`nand`> :t (view _1 $)
02:51:48 <lambdabot> Field1 a t b b1 => a -> b
02:51:51 <`nand`> :t view _1
02:51:52 <lambdabot> (MonadReader s m, Field1 s t a b) => m a
02:52:08 <mauke> (naked reader)++
02:52:54 <mauke> > even `ask` succ 1
02:52:56 <lambdabot>   True
02:53:19 <mauke> > even `asks` succ 1
02:53:20 <lambdabot>   True
02:54:18 <typoclass> ^^ urgh, what has science done ... :-)
02:54:37 <mauke> I have done an art.
02:54:38 <`nand`> heh
02:55:40 <mauke> > fmap fix return `asks` ask ask var "why"
02:55:41 <lambdabot>   why
02:57:35 <absence> is it impossible to fmap an infinite tree since all child nodes have to be fmapped before the current node?
02:57:51 <`nand`> ‘fmap’ has no order
02:57:59 <Taneb> And is lazy
02:58:11 <`nand`> and sure it's possible to fmap an infinite tree
02:58:16 <`nand`> just as it's possible to fmap an infinite list
02:58:21 <`nand`> (which is a special case of an infinite tree, really)
02:58:31 <t7> really... ?
02:58:48 <mrout> well it's just a tree with no branches
02:59:11 <`ramses> mrout: with a branching factor of one, rather
02:59:11 <lambdabot> `ramses: You have 1 new message. '/msg lambdabot @messages' to read it.
02:59:47 <typoclass> s/branches/leaves
02:59:56 <absence> all right, i have to think about this some more :)
03:00:05 <`nand`> data Tree a = Leaf | Branch a [Tree a]; nil = Leaf; cons x xs = Branch x [xs]
03:00:41 <mauke> @let cons x xs = Node x [xs]
03:00:42 <lambdabot>  Defined.
03:00:44 <mauke> :t cons
03:00:46 <lambdabot> a -> Tree a -> Tree a
03:01:20 <`ramses> absence: mapping the child trees is done lazily, so it doesn't matter that they're infinite
03:02:33 <absence> `ramses: yes i think i understand. thinking of it as an infinite list made something click in my head, just have to wade through the confusion and find out what it was ;)
03:04:04 <`ramses> absence: if you fmap (+1) (Branch 2 l r), it wil construct (Branch (2+1) (fmap (+1) l) (fmap (+1) r)) and that's all it does. No more work happens unless you ask for it
03:04:55 <`ramses> and with a list you'd have one tail instead of two subtrees
03:05:34 <mrout> @where hoogle
03:05:34 <lambdabot> http://haskell.org/hoogle
03:07:27 <bas__work> you can't hide instances right?
03:07:58 <fmap> is there typeclass for generalized splitting on head and tail?
03:08:08 <Taneb> bas__work, yeah, you can't
03:09:02 <Taneb> fmap, lens HEAD has one, I think
03:09:08 <Taneb> parsec sort of has one as well
03:09:11 <absence> `ramses: it makes sense when simply spoken (written) like that, i'm sure i'll get the hang of lazily handling infinite data once my intuition gets less imperative :)
03:10:47 <fmap> Taneb: `Cons'?
03:11:43 <fmap> interesting, thanks
03:19:37 <`nand`> Cons seems to be getting close to classy-prelude
03:24:21 <absence> is the reason that this function hangs with an infinite tree that Seq is strict? http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/src/Data-Tree.html#unfoldTreeM_BF
03:24:28 <HugoDaniel> ^^
03:24:33 <socket> hey, a cs theory question, maybe you can help. L = {a^i b^j c^k d^n | i = 1 -> j=k=n } why is that a context free language?
03:27:22 <socket> sorry, why is that not a context free language
03:28:15 <t7> what do you think might be the context there?
03:28:59 <socket> the a in the begining
03:29:21 <t7> why?
03:29:44 <socket> not sure.... i guess the rest must follow it
03:31:09 <socket> t7: can you help?
03:31:43 <t7> i can only help you help yourself
03:33:33 <socket> great
03:41:49 <marekw2143> hmm, if Functor of (->)  is: (\x -> f (g x)), then (:) <$> (+3) would result in: (\x -> (:)  (x+3) ) wgucg is a function of one argument returning function which "makes" a list?
03:42:06 <marekw2143> ^wgucg = which
03:42:33 <mrout> wgucg. your fingers were on the wrong diagonal
03:42:59 <mauke> > ((:) <$> (+3)) 5 [10, 12, 200]
03:43:00 <lambdabot>   [8,10,12,200]
03:44:08 <marekw2143> mauke: so yes?
03:48:17 <marekw2143> mrout: did you just parsed it in your head ? :)
04:00:54 <marekw2143> what about using <$> with 3 arguemnt functions - is it done often?
04:02:46 <saeidw> :t liftA3
04:02:47 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
04:03:41 <marekw2143> wow, all those fmaps seems very hard to use for me
04:03:43 <typoclass> or "abc <$> def <*> ghi <*> jkl <*> ...", depending on what you mean
04:03:48 <marekw2143> is it like that in practice?
04:04:36 <typoclass> marekw2143: if you post your code on hpaste, i'm sure someone can help :-)
04:06:36 <marekw2143> typoclass: nonoo, I'm just wonderign, what will be result of (+_) <$> (+__) <*> (*) - i think it will be +_ (+__ x1 y1) <*> (*) which will be +_ (+__ x2 y2) (* x2 y2)
04:07:01 <marekw2143> assume that +_ has same definition as +__ which has same definition as (+)
04:08:50 <b_jonas> ehwhat?
04:09:21 <b_jonas> is +_ even a single symbol?
04:09:59 <marekw2143> just wrote +_ to indicate where it's used after "evaluation"
04:11:26 <hpaste> marekw2143 pasted “Expression” at http://hpaste.org/80733
04:16:41 <marekw2143> what is result of (+) <$> (*) ?
04:17:19 <mikeplus64> :t fmap (+) (*)
04:17:24 <lambdabot> (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
04:17:31 <kennyd> <$> is infix fmap, (*) is similar to fmap but takes m (a -> b) instead of (a -> b)
04:17:43 <quicksilver> kennyd: no, (*) is multiplication :)
04:17:49 <Mon_Ouie> I think you meant <*>
04:17:54 <kennyd> oops right, I parsed it as <*>
04:18:10 <quicksilver> marekw2143: a type error, normally, since there isn't normally a Num instance for (a -> a).
04:18:10 <srhb> kennyd: Not completely. :P
04:18:16 <quicksilver> there is in lambdabot though.
04:18:27 <mikeplus64> :t fmap (+) (<*>)
04:18:29 <lambdabot> (Num (f a -> f b), Applicative f) => f (a -> b) -> (f a -> f b) -> f a -> f b
04:18:47 <mauke> quicksilver: not anymore
04:18:55 <quicksilver> ah. Good.
04:18:59 <quicksilver> > 1 5
04:19:00 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
04:19:00 <lambdabot>    arising from the ambiguity chec...
04:19:06 <Taneb> :t (.)
04:19:07 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:19:11 <Taneb> :(
04:19:16 <typoclass> what's the lambdabot command to turn (e.g.) "f <*> g" into "\x -> f x (g x)" ?
04:19:17 <mikeplus64> > fmap (+) (<*>) (pure (+100)) (fmap pred) (pure 0) :: Maybe Int
04:19:18 <lambdabot>   No instance for (GHC.Num.Num
04:19:18 <lambdabot>                     (Data.Maybe.Maybe GHC.Type...
04:19:29 <marekw2143> but can we use in practice: fmap (+) (*) ?
04:19:31 <Taneb> @unpl f <*> h
04:19:31 <lambdabot> (f <*> h)
04:19:34 <mauke> typoclass: doesn't exist, I think
04:19:35 <quicksilver> typoclass: if anything was going to do it, it would be unpl
04:19:42 <quicksilver> typoclass: but unpl doesn't know about <*> and <$>
04:20:12 <quicksilver> even if it did, it wouldn't do it on f <*> g since there isn't anything there to force it to the (r->) instance.
04:20:14 <typoclass> right, i asked in here after i tried @run and @unpl in a private window :-)
04:20:26 <typoclass> quicksilver: good point
04:20:41 <maki`> what argument would you feed to (fmap (+) (<*>))?
04:21:06 <marekw2143> maiki`: I didn't want to use <*> but multiplication: (*)
04:21:19 <marekw2143> maki`: similar example would be: fmap (+) (+)  :)
04:21:20 <Fuuzetsu> :t fmap (+) (<*>)
04:21:21 <lambdabot> (Num (f a -> f b), Applicative f) => f (a -> b) -> (f a -> f b) -> f a -> f b
04:21:29 <marekw2143> :t fmap (+) (+)
04:21:30 <lambdabot> (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
04:21:44 <mauke> marekw2143: are you just using random operators in a row?
04:21:45 <mikeplus64> maki`: with an instance for Num (f a -> f b) (which doesn't exist by default)
04:22:10 <marekw2143> random operators?
04:22:13 <maki`> :O
04:22:32 <hiptobecubic> > fmap (+) (+) 3 negate 4
04:22:33 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
04:22:34 <lambdabot>    arising from a use of `e_134'
04:22:34 <lambdabot>  ...
04:22:40 <hiptobecubic> oh right
04:22:52 <hiptobecubic> didn't see the num(a->a)
04:23:27 <marekw2143> my intuition tells me that (fmap (+) (+)) can't feed second argument to first (+)
04:24:10 <marekw2143> because it'd be: fmap (+) (+)    evaluates to:  (\x -> + (+ x1))
04:24:23 <typoclass> marekw2143: are you actually trying to use "fmap (+) (+)", in other words "(+) . (+)" ? or are the (+)es just placeholders?
04:24:29 <typoclass> because i'm having trouble imagining the first could work
04:24:53 <marekw2143> typoclass: I mean:
04:25:03 <marekw2143> let fb = (+)
04:25:07 <marekw2143> fmap fb fb
04:25:19 <marekw2143> so fb is binary two argument function
04:25:34 <marekw2143> brb
04:26:21 <typoclass> > fmap succ (*2) 3
04:26:22 <lambdabot>   7
04:26:30 <mikeplus64> marekw2143: well that requires an instance for Num (f a -> f b), which doesn't exist by default (and not in lambdabot), but with another binary function, you can get sane results
04:26:33 <mikeplus64> :t fmap flip flip
04:26:35 <lambdabot> (b -> a -> c) -> b -> a -> c
04:26:48 <mikeplus64> but flip isn't really binary
04:27:21 <mikeplus64> :t fmap const const
04:27:22 <lambdabot> a -> b -> b1 -> a
04:29:26 <maki`> in gtk, is one prefered over the other?  onDestroy window mainQuit  vs   on window deleteEvent $ do liftIO mainQuit >> return False
04:29:32 <typoclass> marekw2143: what are you planning? i'm pretty sure fmap (+) (+) won't work. do you want a function that takes three arguments and adds them?
04:29:39 <typoclass> > sum [2,4,5]
04:29:41 <lambdabot>   11
04:32:52 <srhb> maki`: The first certainly seems the more concise version
04:40:59 <ricochet> hi, thanks for the wonderfull tryhaskell.org. I'm on my lesson 5, found a strange behavior (bug?) Any developers here to discuss?
04:41:56 <maki`> srhb I know. but the tutorial I am reading mentioned that set<Property> will be deprecated in favor of set [property := value], so I thought maybe similar thing will happen to on<event> vs on event
04:41:57 <merijn> ricochet: What bug?
04:43:41 <ricochet> evaluation of  this expression from lesson #5 "let [a,b,c] = "cat" in (a,b,c)" give unpredicted results
04:44:54 <merijn> ricochet: Seems to work if I try it on the site
04:45:01 <merijn> What happens for you?
04:45:24 <ricochet> may i paste it here?
04:45:32 <srhb> or use hpaste.org if it is long.
04:45:38 <merijn> ricochet: 1 or 2 lines should be fine, otherwise use hpaste.org
04:47:57 <hpaste> ricochet pasted “tryhaskell.org strange behavior (lesson #5)” at http://hpaste.org/80734
04:48:18 <srhb> That is indeed odd.
04:49:03 <merijn> I've seen tryhaskell get confused some times before
04:49:15 <merijn> Usually you can solve the problem by refreshing the page
04:49:35 <merijn> Or switch to using ghci, which is much more robust
04:49:50 <typoclass> > let [a,b,c] = "cat" in (a,b,c)
04:49:52 <lambdabot>   ('c','a','t')
04:50:43 <ricochet> ok. just wanted to let you know...
04:50:45 <typoclass> ricochet: urgh, that surely looks funky :-/ i guess tryhaskell is not a heavy-duty thing. it's just to get a quick impression of haskell and try a few things. maybe some oddness is to be expected
04:51:26 <Sergey_> Hi all
04:51:28 <hiptobecubic> haha
04:51:34 <typoclass> ricochet: if you could let the maintainer of tryhaskell know (mail or similar), that'd be great. it is chris done, if i remember correctly
04:52:19 <ricochet> uhm...i thought he's here. wrong way, ok
04:52:45 <hiptobecubic> Is there a reason not to just have a lambdabot behind tryhaskell?
04:53:12 <mikeplus64> hiptobecubic: it could be a lot of lambdabots
04:53:26 <typoclass> hiptobecubic: i thought tryhaskell used the same library that lambdabot uses (mueval or whatever). who knows.
04:53:34 <hiptobecubic> hm
04:53:37 <mikeplus64> or a lot of temporary ghcs (mueval)
04:58:55 <zhulikas> hmm, this is not very hard, but I'm confused
04:59:04 <zhulikas> I have a [(Integer, Maybe Int)]
04:59:11 <zhulikas> and want to get maximumBy that Maybe Int
04:59:36 <Taneb> maximumBy (comparing snd)
04:59:48 <Taneb> comparing is in Data.Ord
04:59:55 <merijn> :t comparing
04:59:57 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
05:00:31 <zhulikas> oh shit it works
05:00:39 <zhulikas> I assumed it doesn't work with Maybe
05:00:45 <quicksilver> I would prefer maximumBy (compare `on` snd)
05:00:46 <zhulikas> thanks :D
05:01:37 <quicksilver> > Nothing < Just 1
05:01:38 <lambdabot>   True
05:01:45 <quicksilver> > Nothing < Just (-55555)
05:01:46 <lambdabot>   True
05:01:59 <Taneb> > nothing < Just (-1 / 0)
05:02:00 <lambdabot>   Not in scope: `nothing'
05:02:05 <Taneb> > Nothing < Just (-1 / 0)
05:02:06 <lambdabot>   True
05:02:10 <Taneb> > -1 / 0
05:02:11 <lambdabot>   -Infinity
05:02:15 <zhulikas> ok, enough! :D
05:02:18 <zhulikas> I got it!
05:03:22 <ocharles> > Nothing < Nothing
05:03:24 <lambdabot>   False
05:03:36 <quicksilver> ocharles++ # 24 days of haskell
05:03:37 <maki`> is there a way to get typeclasses that a type implements in ghci?
05:03:41 <ocharles> quicksilver: thanks!
05:03:42 <quicksilver> maki`: :info
05:03:49 <maki`> nice thanks
05:04:06 <quicksilver> it only shows you instances you have in scope, though
05:04:12 <quicksilver> might be some in other modules you haven't imported
05:04:15 <quicksilver> normally that's what you want.
05:04:54 <typoclass> maki`: you can use @instances in lambdabot, which is also available privately
05:05:10 <ion> > Nothing `compare` you
05:05:12 <lambdabot>   LT
05:06:01 <typoclass> quicksilver: you mean the recent thing? "24 days of hackage"
05:06:52 <quicksilver> typoclass: that is indeed what I meant, yes :)
05:07:13 <Nereid> :t you
05:07:14 <lambdabot> Not in scope: `you'
05:07:22 <Nereid> :|
05:07:31 <typoclass> quicksilver: thanks :-)
05:14:07 * hackagebot uri 0.1.6.1 - Library for working with URIs  http://hackage.haskell.org/package/uri-0.1.6.1 (JaroslavGridin)
05:17:31 <maki`> if I wanted to keep a counter how many times a button was clicked should I use IORef or something else?
05:17:54 <quicksilver> yes, definitely.
05:17:58 <quicksilver> definitely an IORef or something else.
05:18:31 <maki`> I'm asking for a recommendation. haven't used mutation in haskell beofre
05:18:43 <quicksilver> yes, use an IORef.
05:19:13 <maki`> global IORef? a bit nasty, but no other way I guess
05:19:24 <Taneb> You can pass it around to where needs it
05:19:37 <mikeplus64> maki`: no need for it to be global, just make it where you need it, use it where you need it
05:19:37 <quicksilver> gtk is callback based, and as far as I know the callbacks are IO actions, so if you want the callback to have access to something mutable it's going to be one of the services IO provides, like IORef.
05:20:17 <maki`> quicksilver that's correct, I have type of the callback that is called when a button is pressed is  (ButtonClass o) => o -> IO ()
05:20:22 * quicksilver nods
05:20:31 <maki`> sorry for weird sentence :)
05:21:10 <maki`> mikeplus64 not sure how I could make it non-global and accessible by callback?
05:21:27 <mikeplus64> maki`: you can do something like thing <- newIORef x; setupCallback (do ... blah blah blah something using 'thing')
05:21:33 <quicksilver> define the callback in the same scope and it's there
05:21:46 <quicksilver> alternative, define the callback as a function and pass it the IORef as a parameter
05:23:40 <mSSM> In my program, I have 2 cases of explicit recursion: `foo x t | t <= 0 = return something | otherwise = do { x' <- someOperation x ; foo x' (t-1) }' Is there maybe a more elegant solution than that?
05:23:57 <kennyd> you could also make callback of type IORef -> o -> IO (), then pass (onClick ioref)
05:24:07 * hackagebot rematch 0.1.0.2 - A simple api for matchers  http://hackage.haskell.org/package/rematch-0.1.0.2 (TomCrayford)
05:24:54 <merijn> :t repeatM
05:24:55 <lambdabot>     Not in scope: `repeatM'
05:24:55 <lambdabot>     Perhaps you meant one of these:
05:24:55 <lambdabot>       `repeat' (imported from Data.List),
05:25:30 <merijn> mSSM: Maybe, have you looked at for example monad-loops?
05:25:44 <merijn> :t replicateM
05:25:45 <mSSM> merijn: I haven't :)
05:25:45 <lambdabot> Monad m => Int -> m a -> m [a]
05:25:51 <merijn> oh, there you goo too
05:25:57 <merijn> I think?
05:26:17 <merijn> ah, no, you use your new result
05:26:27 <mSSM> Ok, I will have a look at that, thanks
05:27:41 <mSSM> merijn: replicateM only works if I make my computation stateful, right?
05:27:56 <mSSM> merijn: as in, make the next iteration use the result of the previous iteration
05:28:53 <merijn> mSSM: Yeah, that's why I said it won't work for you (or at least, not without some rewriting)
05:29:13 <merijn> mSSM: But the monad-loops package has a bunch of loops for monadic code, might find something useful there
05:29:47 <elkng> I downloaded ghc-7.4.2-i386-unknown-linux.tar.bz2, what now ?
05:31:00 <bartavelle> elkng, I might arrive a bit late in the conversation, but don't you have something pre-packaged from your distribution ?
05:32:14 <elkng> bartavelle: no
05:32:28 <bartavelle> then you untar it, ./configure and make install
05:32:44 <bartavelle> you might want to configure --prefix=/somewhere/specific though
05:33:09 <bartavelle> (also you might want to make sure you really want the 32 bit versions, and not the latest stable)
05:33:46 <elkng> I also have haskell-platform-2012.2.0.0.tar.gz do I need to install it also ?
05:34:07 <bartavelle> you need to install ghc first
05:34:07 * hackagebot crypto-conduit 0.4.3 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.4.3 (FelipeLessa)
05:34:31 <bartavelle> also you have an outdated version
05:37:15 <absence> is the reason that this function hangs with an infinite tree that Seq is strict? http://hackage.haskell.org/packages/archive/containers/0.5.2.1/doc/html/src/Data-Tree.html#unfoldTreeM_BF
05:37:29 <emias> clahey:
05:37:39 <emias> (Oops, sorry.)
05:38:13 <absence> i imagine the node can't be constructed lazily in this line of unfoldForestQ: return (Node b ts <| tQ')
05:39:01 <absence> or rather, the node can, but not the sequence
05:39:28 <maki`> what is going on in here?  I replaced putStrLn with printf and it's causing gtk2hs haskell program to crash.
05:40:01 <mikeplus64> maki`: you sure that it's the putStrLn -> printf that's making it crash? are you using printf wrong?
05:40:09 <mikeplus64> (what's the error?)
05:40:23 <maki`> trying to paste, moment
05:40:26 <maki`> I am not using printf wrong
05:40:39 <hpaste> maki pasted “printf crashing gtk program” at http://hpaste.org/80736
05:41:36 <mikeplus64> maki`: bizarre...
05:42:16 <Taneb> Can Hugs run GHC?
05:42:44 <maki`> it seems to be related with printf's return value. but if it was not compatible shouldn't it be caught by compiler?  onClick b = printf "Button clicked.\n" >> return ()  worked too
05:42:45 <Taneb> (mild curiousity, I don't actually need to do this)
05:42:55 * typoclass wishes the thingy would show us the exception, instead of only saying "gtk2hs_closure_marshal: uncaught exception"
05:43:12 <mSSM> merijn: as in, make the next iteration use the result of the previous iteration
05:43:21 <mSSM> merijn: sorry, I didn't mean to write that
05:43:23 <typoclass> maki`: it seems to me that the printf works correctly, the string shows up. only afterwards, the uncaught exception happens
05:43:23 <mSSM> wrong window
05:43:45 <typoclass> (but no idea where the exception is coming from)
05:43:55 <typoclass> s/,//
05:43:59 <maki`> typoclass yes printf works
05:44:02 <maki`> could anyone replicate this?
05:44:08 <mikeplus64> maki`: yeah, i just did
05:44:11 <srhb> maki`: http://trac.haskell.org/gtk2hs/ticket/1212
05:44:43 <srhb> Ie. don't use printf.
05:45:01 <mrout> srhb: unless you're writing C.
05:45:16 <typoclass> srhb: holy crap
05:45:18 <typoclass> nice find
05:45:22 <mikeplus64> bizarre that printf returns undefined (and that they write an instance for IO a and not IO ())
05:45:34 <srhb> printf is the devil. :P
05:46:09 <typoclass> mrout: oh sure, printf is notoriously easy to use. not error prone at all. has caused hardly any security problems ever.
05:46:10 <typoclass> =)
05:46:51 <srhb> C is supposed to cause you these problems, it builds C-haracter. Haskell really should not. But the fact that it's strictly evaluated is a bit weird.
05:47:15 <t7> srhb++ punny
05:47:32 <typoclass> maki`: if i'm reading this bug report correctly, you could try fixing it by doing "void $ printf ..." or "printf ... >> return ()" or the like
05:47:58 <mrout> typoclass: uh, can't imagine any errors resulting from printf, unless you're stupid enough to printf(completely_unsanitised_string_derpy_derp);
05:48:07 <mrout> typoclass: uh, can't imagine any errors resulting from printf, unless you're stupid enough to printf(completely_unsanitised_string_derpy_derp, blah, blah);
05:48:31 <mrout> scanf and gets on the other hand? Don't even think about it.
05:49:01 <maki`> typoclass yes already mentioned >> return () made it work. why would printf return undefined though?
05:49:32 <typoclass> maki`: oh right, i didn't catch that message. sorry
05:49:47 <quicksilver> mrout: http://en.wikipedia.org/wiki/Uncontrolled_format_string ; it's a fairly widely known and widely fallen-into trap.
05:50:45 <srhb> maki`: Because it's magical! It has to do with the way it can take an arbitrary amount of arguments, I believe.
05:51:21 <quicksilver> it returns undefined for convenience
05:51:37 <quicksilver> I'm not really sure it's that convenient, but that's why.
05:51:50 <quicksilver> to give it the slightly more general type of IO a.
05:52:28 <srhb> I think this is not the first time it causes trouble. I don't know why it's there.
05:52:29 <typoclass> @remember quicksilver It returns undefined for convenience. I'm not really sure it's that convenient, but that's why.
05:52:29 <lambdabot> Okay.
05:52:51 <mrout> quicksilver: "discovered around 1999". Wut. Is this page seriously saying that people didn't realise that doing printf(unsanitised_user_input); could be dangerous because unsanitised_user_input could contain %d?
05:53:40 <quicksilver> mrout: *shrug* lots of things are obvious but took a while to notice
05:53:50 <typoclass> yeah, seems hard to believe that it's only 13 years old ...
05:53:52 <quicksilver> people were pretty naive about security in the 90s
05:54:13 <mrout> It seems pretty unlikely it took people 30 years to work that one out.
05:54:31 <mrout> I worked that one out reading the first page of a My First C tutorial.
05:54:49 <srhb> Users were obviously smart, nice and with high moral standards before then.
05:55:04 <typoclass> srhb: you forgot 'goodlooking'
05:55:14 <srhb> It was a British "smart"
05:55:36 <mrout> srhb: Nice save.
05:55:46 <srhb> Thanks. anyway, I guess we veered off-topic again. :P
05:56:05 <mrout> Sorry
05:57:26 <srhb> Me too. :P
05:58:15 <mSSM> In a monadic function, how can I collect result in a list, e.g. (not working): `foo x n | x < 0 = return [] | otherwise = do { x' <- bar x ; x' : foo x' (n-1) }'
05:59:09 <typoclass> but yeah, what i hate about c is that you have to think very hard about every line. it's just too many traps. you need too much arcane knowledge and too much discipline, and it's just a matter of time before you'll slip
06:01:23 <typoclass> it feels like the language wants you to write a sloppy program that works sometimes. and doing anything robust goes against the grain of the language
06:01:30 * typoclass is done yelling at clouds
06:01:44 <mrout> I wouldn't say that
06:03:29 <typoclass> mrout: i mean because of stuff like "abc(...)" is easy, and "int r = abc(...); if (r < 0) { ... error handling ... }" is more work. the wrong thing is being made easy. it seems to steer you towards the unsafe thing
06:04:36 <srhb> mSSM: recursively? foo n = if n < 1 then return [] else fmap (n:) (foo n-1) -- is that what you're thinking about?
06:04:51 <mrout> It's weak typed, it has raw pointers. It's certainly not designed to hold your hand.
06:05:06 <mrout> The language assumes that you're not going to be lazy enough to just write abc(...)
06:05:21 <mrout> s/lazy/stupid and lazy/
06:05:40 <mSSM> srhb: I think that makes sense... this would give me a IO [Int], right?
06:06:09 <srhb> mSSM: It could, yes.
06:07:06 <mSSM> srhb: the thing is, that `n' in your example is pure, but I actually have a monadic value which I want to attach, i.e. `IO Int' : foo (n-1)
06:08:00 <mSSM> So I should get a [IO Int]
06:08:26 <srhb> Throw a few returns at it
06:08:45 <mSSM> I don't understand what the basecase should look like.
06:09:53 <srhb> It would be clearer if I knew what you were doing. :)
06:10:02 <typoclass> mrout: right, but in my opinion, even if i'm extra careful and manage to do it right 1000 times, the 1001th time i'll forget it, or the coworker will, or git will do something weird during the merge, etc. you can be as careful as you want, eventually you'll slip
06:10:03 <mrout> @where bnfc
06:10:03 <lambdabot> BNF Converter, <http://www.cse.chalmers.se/research/group/Language-technology/BNFC/>
06:10:19 <mrout> it's now at http://bnfc.digitalgrammars.com/
06:10:32 <mrout> someone that knows how to, please change the @where
06:11:09 <srhb> mSSM: let foo mn = mn >>= \n -> if n < 1 then return [] else fmap (return n:) (foo (return (n-1)) -- it's abominable, I know, but is that what you're asking?
06:11:32 <srhb> (Stuck in the same monad now, of course)
06:11:37 <mauke> @where+ bnfc BNF Converter, http://bnfc.digitalgrammars.com/
06:11:37 <lambdabot> It is forever etched in my memory.
06:11:45 <typoclass> mrout: i wouldn't call it hand-holding, but yes, i do think c should have more of it. i'd prefer to have stuff ensured by the compiler, instead of just hoping the world is perfect and the programmers are all perfect =)
06:11:46 <mrout> lol
06:11:55 <mrout> typoclass: then don't use C.
06:12:24 <mrout> typoclass: C operates under the assumption that you will do the error testing if you think it's necessary.
06:12:44 <typoclass> mrout: i try to not use c as much as possible ... =)
06:13:01 <mrout> And that there are real life cases where you simply don't need to error test, and for your code to be performant you don't want unnecessary error testing.
06:15:03 <typoclass> mrout: right, but i'd still argue that it should default to the 'right' thing and provide some extra button you can push to get the 'sloppy' thing. not the other way round
06:15:33 <mrout> No, it doesn't default to anything. You misunderstand. It doesn't operate under the assumption that every syntactically correct statement should be safe.
06:15:38 <jaam> hii
06:16:13 <mauke> so it defaults to unsafe
06:16:19 <lev_> hello
06:16:47 <mSSM> srhb: Let me rewrite my thing:  `foo n | n < 0 = return [] | otherwise = do { a <- someFunction n ; a : foo (n-1) }' so, `someFunction n' gives me an `IO Int', and in the end I would like to have `[IO Int]' (or alternatively IO [Int] after sequencing)
06:16:48 <srhb> Hi jaam, hi lev_
06:17:12 <mauke> mSSM: needs more return
06:17:17 <mSSM> srhb: yes! :D
06:17:20 <mauke> also, more <-
06:17:37 <mSSM> oh
06:17:40 <mSSM> mauke: yes ^
06:17:43 <srhb> I'm sure my abomination can be made less abominable
06:17:52 <mauke> or less return
06:18:13 <mSSM> So how can I make this into a [IO Int] ?
06:18:25 <mauke> 1) change 'return []' to '[]'
06:18:47 <mauke> 2) change 'a <- someFunction n; a' to 'someFunction n'
06:19:05 <srhb> lift, lift, lift.
06:19:08 <mauke> 3) remove 'do {' '}' (not technically necessary but recommended for sanity)
06:19:18 <srhb> *chants*
06:19:20 <mauke> 4) rewrite the whole thing using 'map'
06:19:54 <mSSM> :(
06:20:28 <mauke> seriously, foo n = map someFunction [n, n-1 .. 0]
06:21:06 <mSSM> mauke: cmon, I know that I can solve the particular problem above in a different way
06:21:15 <mSSM> mauke: but that `n' up there is actually a Double in my program
06:21:33 <mauke> I recommend against that
06:21:41 <mSSM> I have no choice...
06:21:55 <mSSM> There is a physical (non-technical) reason for that.
06:22:14 <mauke> unlikely
06:22:46 <mSSM> mauke: Please suggest how I can simulate different temperatures in the range of 1.00 to 3.00 K in steps of 0.01
06:23:00 <mrout> 0.01K = 1
06:23:06 <mrout> 3.00K = 300
06:23:09 <mrout> success
06:23:12 <mauke> you could use Rational, a fixed precision type, or scale the whole thing up and use integers
06:23:28 <mauke> floating point numbers are basically the worst solution
06:24:00 <mSSM> I'd and up with 10^5 * 300 `fromInteger' calls then
06:24:00 <srhb> anyway, that thing looks a bit like liftM3 scanr to me
06:24:07 <srhb> Or am I talking out my arse?
06:24:11 <mSSM> when calculating an expontential weighing
06:24:27 <srhb> Oh wait, it doesn't use previous things at all. nevermind.
06:24:34 * srhb talks out her arse
06:28:15 <maki`> (newIORef 0 >>= func) every time this action is executed func gets a new IORef, is that right?
06:28:22 <mauke> yes
06:29:30 <maki``> could I get a  `ref <- newIORef 0;  (func ref)' equivalent without assigning the result to a variable first?
06:30:11 <mauke> yes: newIORef 0 >>= func
06:30:37 <maki``> that's not the same.
06:30:38 <mSSM> ok, new try: `foo (v::Vector.Mutable) (t::Double) | t <= 0.0 = return ??? | (changeV v t ) : (foo v (t-0.01))'  ... so, `changeV' does some operation on `v', and returns some result, let's say `IO Double' in this case. I want to collect these results into a list.
06:30:45 <mauke> maki``: yes, it is
06:30:56 <mSSM> Is that at all reasonable what I am trying to do?
06:31:08 <maki``> mauke no. if you run the latter multiple times func will have the same ref. in the former it will get new ref every time
06:31:14 <mauke> maki``: wrong
06:31:30 <maki``> mauke test it, I did
06:31:36 <mauke> your test is wrong
06:32:03 <quicksilver> if you do ref <- newIORef 0; several times than you certainly get several different refs.
06:32:13 <quicksilver> if you only do ref <- newIORef 0; once of course you don't.
06:32:21 <mauke> I don't need to test it. what you're telling me is like saying 4 ^ 3 and 4 * 4 * 4 are giving different results
06:32:33 <maki``> obviously I did that only once. why would anyone assume otherwise
06:32:42 <mauke> maki``: because you said otherwise
06:33:03 <maki``> so you were being unhelpful pedant
06:33:13 <mauke> no, you were lying about your code
06:35:18 <typoclass> mauke: be civil
06:35:42 <mauke> heh
06:36:08 <quicksilver> maki``: mauke was not being pedantic, you quite clearly said that you ran the code multiple times.
06:36:23 <quicksilver> I suspected that's not what you mean, which is why I made the remark I made.
06:36:43 <quicksilver> but really you shouldn't call people unhelpful when they are trying to help you
06:37:54 <maki``> I said I ran action returned by (newIORef >>= func) multiple times, not ref <- newIORef 0; (func ref)
06:38:08 <mauke> you said both
06:38:21 <quicksilver> "if you run the latter multiple times func will have the same ref. in the former it will get new ref every time
06:38:24 <mauke> <maki``> mauke no. if you run the latter multiple times func will have the same ref.
06:38:35 <quicksilver> so you were talking about running the former multiple times.
06:38:37 <mauke> "the latter" being <maki``> could I get a  `ref <- newIORef 0;  (func ref)' equivalent
06:39:02 <maki``> quicksilver, that was already after he intentionally misunderstood me. anyway I'll drop this
06:39:09 <typoclass> quicksilver: i think maki`` didn't phrase it very clearly, but i could tell what he meant. and mauke did tell him only "wrong" without telling him what he thinks is right, and "you were lying" and such. these sorts of responses are easy to read as being abrasive
06:39:50 <mauke> typoclass: I could also tell what he meant, but apparently I was wrong
06:40:01 <srhb> I too thought as mauke did.
06:40:06 <frost_> is there anything monad can do that applicative cant
06:40:07 <hiptobecubic> As did I
06:40:11 <mauke> typoclass: I only said "wrong" after I already explained what's right
06:40:37 <hiptobecubic> frost_, yes. LYAH demonstrates it better than I can explain though.
06:40:38 <mauke> typoclass: and I only said "you were lying" after he called me an "unhelpful pedant"
06:40:47 <quicksilver> maki``: I don't see him intentionally misunderstanding you; I seem him clearly answering each of your questions. Happy to respect your wish to drop it.
06:40:50 <Jaak> frost_: yes. backtracking parsers iirc
06:41:01 <quicksilver> I happen to agree mauke is abrasive, too :)
06:41:09 <quicksilver> but he was abrasive and right and not particularly pedantic.
06:42:12 <Jaak> but I could be wrong
06:42:25 <covi> If I have A.hs that uses stuff in B.hs, which in turn uses things in A.hs, how should I properly put the module and import declarations?
06:42:25 <mauke> frost_: join
06:42:58 <mauke> covi: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
06:43:15 <quicksilver> covi: (it may well seem less hassle just to get rid of the mutual recursion)
06:43:28 <merijn> covi: Split them off into a third module which you import in both A and B or use a boot-hs file
06:45:18 <covi> Cool. Thanks guys!
06:45:20 <typoclass> mauke: if you mean your comment "newIORef 0 >>= func", you said that only after maki had already said "newIORef 0 >>= func". you were telling him things he obviously already knew. i think "intentionally misunderstanding" is a good description for that. a more helpful way would have been to say "no, newIORef 0 >>= func is the same thing as ref <- newIORef 0 ; func ref"
06:45:53 <srhb> He did. :P
06:45:58 <srhb> This discussion is silly.
06:46:17 <mrout> How about you stop nitpicking at each other and help each other instead
06:46:26 <mauke> mrout: with what?
06:46:40 <mrout> I dunno.
06:46:42 <hiptobecubic> etiquette apparently
06:46:48 <mrout> Whatever you started the conversation about
06:46:51 <mauke> mrout: well, that wasn't very helpful
06:47:00 <hiptobecubic> we started it about how maki`` didn't explain his problem well
06:47:08 <hiptobecubic> which led to a civil war
06:47:10 <mauke> this conversation is at its original topic
06:47:56 <hiptobecubic> between the valiant north, that understood him literally, which was apparently wrong. And the terrible south, who are a bunch of ninnies.
06:48:29 <inad922> hello
06:48:33 <hiptobecubic> hi
06:48:52 <mauke> .oO( if you're a programmer and you don't write exactly what you mean, you're going to have a bad time )
06:49:05 <inad922> Is there a way to inspect the code of a builtin function within ghci? Like the code of splitAt
06:49:20 <merijn> mauke: No capital letter and period, you communist hippie!
06:49:42 <merijn> inad922: Not really, you can Hoogle the function and click on the source link there
06:49:46 <hiptobecubic> i think he wrote what he meant. It just wasn't unambiguous. (Also accidentally wrong.)
06:50:04 <typoclass> inad922: not sure about ghci, but the haddocks have "source" links on the right hand side, e.g. http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
06:50:22 <arbn> I have a Haskell record type and I want to make the data inside available to a calling C program. Advice on the easiest way to do this?
06:50:38 <frost_> wht
06:51:30 <arbn> That is, the easiest way to return that kind of data through an exported ccall.
06:51:34 <mauke> arbn: well, you could define a struct in C and make a Storable instance, etc
06:51:34 <merijn> arbn: You need to marshall it using the FFI and various tools like c2hs, c2hsc, etc.
06:52:01 <mauke> in general your function would take a pointer to that struct and fill it
06:52:21 <inad922> typoclass: cool stuff. Thanks!
06:52:30 <inad922> thanks merijn
06:53:08 <covi> I encountered this "Module imports form a cycle"
06:53:22 <saml> circular dependencies
06:53:24 <arbn> OK. So, I write a C header for a struct type, and then use something like c2hs on it. I guess that's an easy way to get started?
06:53:27 <covi> In such case, should I write on the paper to figure out the dependencies first?
06:53:30 <saml> module A imports B which imports C which imports A
06:53:48 <saml> it doesn't show you circular path?
06:54:02 <singpolyma> How do I enable lazy pattern syntax with GHC?
06:54:12 <saml> it's enabled by default
06:54:15 <saml> pattern matching is lazy
06:54:18 <merijn> arbn: Yeah, I'm using that approach in some of my code: https://github.com/merijn/SNet2.0/
06:54:18 <covi> saml: it does
06:54:26 <arbn> merijn: Cool. Thanks.
06:54:48 <singpolyma> saml: I mean the   ~(a, b)   syntax
06:54:51 <dblhelix> saml: I think singpolyma means the use of tildes (~) in patterns
06:54:54 <merijn> arbn: I have a hook in Setup.hs to call c2hsc and then use the storable instance produced by that
06:55:13 <mauke> singpolyma: how do you *disable* ~ in GHC?
06:55:37 <typoclass> singpolyma: not sure, but it could be -XBangPatterns
06:55:38 <singpolyma> oh, is it standard?  I thought it was not because it rejected my code
06:55:48 <mauke> singpolyma: show your code/error message
06:55:58 <bitonic> singpolyma: ~ has always been std haskell
06:56:02 <dblhelix> singpolyma: see §4.4.3.2 in http://www.haskell.org/onlinereport/decls.html
06:56:45 <singpolyma> (bob, joe) <- mfix (\~(bob,joe) -> do         results in         t.hs:22:41: parse error on input `->'
06:57:09 <mauke> that's because you're using the \~ operator
06:57:11 <mauke> try \ ~
06:57:31 <saml> why you use ~pat ?
06:58:04 <singpolyma> mauke: oh, of course.  silly me
06:58:13 <singpolyma> thanks!
06:58:36 <dblhelix> saml: to have (bob, joe) treated as an irrefutable pattern
06:58:59 <saml> http://stackoverflow.com/questions/13185632/is-it-possible-to-use-irrefutable-tilde-patterns-in-lambda-expressions
06:59:00 <dblhelix> saml: hence, evaluation can proceed without first forcing the tuple to whnf
07:00:13 <singpolyma> which is needed for use with things like mfix :)
07:02:59 <drkk> How would one ideally implement the generation of a list of lists with random bools in them?
07:03:48 <frost_> why do we have all this duplicated functionality?  http://hpaste.org/80737
07:03:55 <merijn> drkk: Use randoms
07:04:00 <merijn> :t randoms
07:04:02 <lambdabot> (RandomGen g, Random a) => g -> [a]
07:04:15 <typoclass> drkk: i think you could use the 'randoms' function. it works for Bools. see http://hackage.haskell.org/packages/archive/random/1.0.0.2/doc/html/System-Random.html
07:04:28 <merijn> frost_: For consistency
07:04:38 <mm_freak> why isn't there a lens/prism for Data.Map?
07:04:59 <merijn> frost_: map exists because the fmap type signature was deemed "to confusing" for newcomers, <$> exists because having an infix fmap is nice very often
07:05:28 <merijn> liftA/liftM just exist for consistency with the other liftMx functions, I think
07:05:59 <fmap> mm_freak: `at'?
07:06:08 <fmap> @ty at
07:06:08 <typoclass> i thought it was because they have slightly different type signatures ...
07:06:09 <lambdabot> (Functor f, At k m, Indexable k k1) => k -> k1 (Maybe v -> f (Maybe v)) (m v -> f (m v))
07:06:14 <typoclass> :t liftA
07:06:15 <lambdabot> Applicative f => (a -> b) -> f a -> f b
07:06:18 <typoclass> :t fmap
07:06:18 <frost_> as far as I can see only fmap is necessary?
07:06:19 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:06:45 <fmap> @ty _at
07:06:46 <lambdabot> (Applicative f, At k m, Indexable k k1) => k -> k1 (v -> f v) (m v -> f (m v))
07:07:36 <merijn> typoclass: Well, any applicative must be a Functor and every Monad *should* be a functor, so fmap would be sufficient
07:07:50 <typoclass> frost_: i guess you could say it like that. fmap is the central thing, and the others are variants that are more or less useful in some contexts
07:08:44 <mm_freak> fmap: oh, indeed…  thanks
07:08:58 <edwardk> mm_freak: at gives you a lens that lets you insert/delete/lookup. ix gives you a traversal that updates an element if its already present.
07:09:05 <edwardk> (in 3.7 ix is still _at)
07:09:18 <mm_freak> thanks
07:09:39 <mm_freak> seems like a lot of functionality isn't immediately apparent anymore
07:09:39 <M30W> Prelude Data.Char> let lastMsgs = ["oNe","tWo","thrEE"] in lines . map toLower . unlines . take 2 $ lastMsgs
07:09:55 <M30W> > let lastMsgs = ["oNe","tWo","thrEE"] in lines . map toLower . unlines . take 2 $ lastMsgs
07:09:56 <lambdabot>   ["one","two"]
07:10:20 <M30W> what would be a cleaner way to do such?
07:10:38 <M30W> > let lastMsgs = ["oNe","tWo","thrEE"] in lines . map toLower . take 2 $ lastMsgs
07:10:40 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:10:40 <lambdabot>              with actual type...
07:10:54 <M30W> > let lastMsgs = ["oNe","tWo","thrEE"] in lines . map (map toLower) . take 2 $ lastMsgs
07:10:55 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:10:55 <lambdabot>              with actual type...
07:10:57 <mm_freak> M30W: map (map toLower)
07:11:04 <opqdonut> > let lastMsgs = ["oNe","tWo","thrEE"] in map (map toLower) . take 2 $ lastMsgs
07:11:05 <mm_freak> that also preserves whitespace
07:11:05 <lambdabot>   ["one","two"]
07:11:13 <M30W> mm_freak: just tried that...
07:11:21 <M30W> > let lastMsgs = ["oNe","tWo","thrEE"] in map (map toLower) . take 2 $ lastMsgs
07:11:23 <M30W> ah.
07:11:23 <lambdabot>   ["one","two"]
07:11:27 <M30W> :)
07:11:55 <hiptobecubic> no lens golfers around?
07:12:30 <Eliel> trial & error coding is not a very good fit when writing haskell. You waste a lot of time trying different options until one works.
07:13:21 <edwardk> > let ["oNe","tWo","thrEE"]^..taking 2 traverse.traverse.to toLower
07:13:22 <lambdabot>   <hint>:1:66: parse error (possibly incorrect indentation)
07:13:26 <edwardk> > ["oNe","tWo","thrEE"]^..taking 2 traverse.traverse.to toLower
07:13:28 <lambdabot>   "onetwo"
07:13:33 <Chousuke> At least you only need to try the cases that satisfy the type checker
07:13:47 <M30W> ha
07:13:58 <edwardk> > ["oNe","tWo","thrEE"] & taking 2 traverse.traverse %~ toLower
07:13:58 <M30W> edwardk: wrong out ;)
07:14:00 <lambdabot>   ["one","two","thrEE"]
07:14:07 <M30W> 2....
07:14:22 <edwardk> > take 2 $ ["oNe","tWo","thrEE"] & traverse.traverse %~ toLower
07:14:24 <lambdabot>   ["one","two"]
07:14:25 <hiptobecubic> well that's a more interesting result actually
07:14:29 <M30W> ha
07:14:34 <beaky> hello
07:14:48 <beaky> > mapM_ print [1..3]
07:14:50 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
07:14:50 <lambdabot>    arising from a use of ...
07:14:55 <Chousuke> no shorter form for traverse.traverse?
07:14:58 <M30W> edwardk: but there is zero performance advantage there?
07:15:06 <hiptobecubic> beaky, lambda won't let you launch any ICBMs
07:15:12 <beaky> ah thanks
07:15:38 <edwardk> M30W: lenses are rarely about adding performance to hand tweaked code and more about an easier way to think about the compositions
07:15:42 <M30W> edwardk: yes/no?
07:15:44 <hiptobecubic> :t mapM_ print [1..3]
07:15:45 <lambdabot> IO ()
07:15:50 <beaky> so the way the IO Monad works is that every >>= executes an IO action?
07:15:59 <M30W> fair enough.
07:16:09 <mrout> I thought the IO Monad didn't execute IO.
07:16:13 <hiptobecubic> beaky, not really. >>= works how it always does. The action is executed by main.
07:16:17 <beaky> ah
07:16:20 <hiptobecubic> it's one big action
07:16:24 <hiptobecubic> of type IO ()
07:16:28 <beaky> that's mind blowing
07:16:31 <edwardk> mm_freak: 'at' has been around since around 1.0 in some form, its been a little hard to find since it got loaded into a class though
07:16:32 <hiptobecubic> or maybe it can be IO a, i don't know
07:16:36 <mrout> It's pretty aamzing, Haskell
07:16:52 * M30W shall continue to go lense free. :) just a bunch of macros yea? shouldn't need them. :)
07:17:09 <hiptobecubic> not macros
07:17:11 <hiptobecubic> functions
07:17:19 <hiptobecubic> and you need functions :)
07:17:20 <`nand`> it can be IO a
07:17:36 <M30W> functions in code. but more or less macro/rewriting the code.
07:18:02 <hiptobecubic> in the same way that "drop 3" rewrites code, i guess?
07:18:13 <M30W> in interesting ways. :P
07:18:25 <`nand`> M30W: you make lenses sound like some addictive substance
07:18:30 <`nand`> which, admittedly, isn't far from the truth
07:18:37 <Chousuke> I don't know if it's "rewriting" anything. they're just really weird functions.
07:18:41 <hiptobecubic> M30W, there's no magic to them beyond a bunch of theoretical spiderwebs.
07:18:50 <`nand`> some lens combinators are magic
07:19:10 <`nand`> > "hello" & upon head %~ toUpper
07:19:10 <mrout> about as magic as boost's BOOST_FOREACH macro
07:19:11 <lambdabot>   "Hello"
07:19:34 <mm_freak> btw, how do i refer to all elements of a list through a lens/traversal?
07:19:45 <mrout> Yes, it's about 1000 lines of code, but it's just macros and templates. Clever code isn't magic, and if you treat it as such you'll never be a great programmer.
07:19:51 <mm_freak> i.e. how do i do the equivalent of map (^2) [1..9]?
07:19:52 <M30W> `nand`: fuck you are hard to tab complete on a N900 qwerty keyboard. D:
07:20:09 <`nand`> M30W: ‘traverse’?
07:20:10 <`nand`> err
07:20:12 <`nand`> mm_freak*
07:20:28 <`nand`> > [1..9] & traverse ^~ 2
07:20:30 <lambdabot>   [1,4,9,16,25,36,49,64,81]
07:20:52 <hiptobecubic> :t (^~)
07:20:53 <lambdabot> (Integral e, Num a) => Setting s t a a -> e -> s -> t
07:21:04 <mm_freak> `nand`: that's weird…  (^~) typechecks, but doesn't work
07:21:07 <mm_freak> (%~) works
07:21:10 <M30W> map looks cleaner haha.
07:21:12 <beaky> > [1..3]>>=show
07:21:14 <lambdabot>   "123"
07:21:28 <mm_freak> M30W: not for the nested data structure i have
07:21:30 <`nand`> what do you mean, “doesn't work”?
07:21:33 <elliott> `nand`: upon isn't even in scope by default if you import Control.Lens
07:21:41 <mm_freak> > (traverse ^~ 1) [1..9]
07:21:42 <lambdabot>   [1,2,3,4,5,6,7,8,9]
07:21:44 <tromp> :t (&)
07:21:45 <lambdabot> a -> (a -> b) -> b
07:22:11 <`nand`> (if traverse is too wordy, you can even use each :P)
07:22:24 <mm_freak> `nand`: i would have expected to get replicate 9 1
07:22:28 <M30W> lool
07:22:32 <mm_freak> but it gives me my original [1..9] back
07:22:37 <`nand`> mm_freak: that's (^1) not (1^)
07:22:45 <hiptobecubic> (traverse %~ const 1) [1..9]
07:22:48 <mm_freak> oh…
07:22:52 <hiptobecubic> > (traverse %~ const 1) [1..9]
07:22:54 <lambdabot>   [1,1,1,1,1,1,1,1,1]
07:23:05 <`nand`> > [1..9] & each .~ 1
07:23:06 <lambdabot>   Not in scope: `each'
07:23:06 <hiptobecubic> maybe there's something to just force a value
07:23:09 <`nand`> bah
07:23:11 <`nand`> > [1..9] & traverse .~ 1
07:23:13 <lambdabot>   [1,1,1,1,1,1,1,1,1]
07:23:14 <hiptobecubic> > (traverse .~  1) [1..9]
07:23:16 <lambdabot>   [1,1,1,1,1,1,1,1,1]
07:23:19 <mm_freak> d'oh!
07:23:26 <mm_freak> > (traverse .~ 1) [1..9]
07:23:28 <lambdabot>   [1,1,1,1,1,1,1,1,1]
07:23:29 <mm_freak> there we go =)
07:23:34 <mm_freak> thanks
07:23:35 <simon> :t (.~)
07:23:36 <lambdabot> Setting s t a b -> b -> s -> t
07:23:37 <mrout> what are you doing?
07:23:55 <edwardk> mm_freak: [1..3] & traverse ^~ 1 is    [1^1,2^1,3^1]
07:24:12 <edwardk> mm_freak: [1..3] & traverse .~ 1 is    [1,1,1]
07:24:25 <hiptobecubic> > (traverse +~  1) [1..9]
07:24:26 <mm_freak> yeah, got that just now =)
07:24:26 <lambdabot>   [2,3,4,5,6,7,8,9,10]
07:24:31 <edwardk> each is a 'do what i mean' traversal which generalizes 'traverse'
07:24:32 <M30W> .~ is setter
07:24:38 <`nand`> Cale: when are we getting ‘each’ in lambdabot!?
07:24:41 <mm_freak> what's (&)?  flip ($)?
07:24:45 <mm_freak> :t (&)
07:24:45 <`nand`> mm_freak: yes
07:24:45 <bas__work> ye
07:24:46 <lambdabot> a -> (a -> b) -> b
07:24:46 <typoclass> edwardk: is ^~ one of the thingies that changed sometime recently?
07:24:49 <mm_freak> alright
07:24:56 <edwardk> `nand`: 3.8 isn't released, and i'd rather not waste too much of his time getting 3.7.x ;)
07:24:57 <`nand`> mm_freak: higher precedence too
07:25:15 <edwardk> typoclass: if by recently you mean 3 months ago, yes
07:25:16 <hiptobecubic> op~ looks like a pretty reasonable way to do it
07:25:30 <M30W> you guys talk too fast. i had to make my hilight window smaller -.-
07:25:31 <hiptobecubic> what did ^~ used to be?
07:25:46 <edwardk> hiptobecubic: way back in the dawn of time that was .~
07:25:55 <hiptobecubic> i see
07:25:56 <typoclass> edwardk: hm 3 months already ...? =)
07:25:59 <mm_freak> edwardk: are you adding lenses for Data.Char in the next release?  that would be very useful for text processing
07:26:03 <hiptobecubic> why .~ and not =~ ?
07:26:03 <M30W> edwardk: how many different lenses exist?
07:26:18 <mm_freak> M30W: infinitely many
07:26:22 <`nand`> hiptobecubic: == wouldn't work very well
07:26:22 <edwardk> hiptobecubic: that latter notation doesn't scale well
07:26:32 <M30W> mm_freak: lol!
07:26:35 <edwardk> in lens you can replace ~ with = to get a state combinator
07:26:46 <bas__work> M30W, you probably mean to ask how many operators
07:26:48 <hiptobecubic> i see
07:26:57 <edwardk> that forces a wart on the most primitive operation of all ;)
07:26:59 <bas__work> which is 103 I think
07:27:13 <M30W> bas__work: in code. how many functions are defined *
07:27:16 <edwardk> .~  was chosen because you get .=   which is as close to :=  as i can get and its near invisible
07:27:25 <hiptobecubic> sure
07:27:34 <hiptobecubic> :~ is not legal?
07:27:35 <`nand`> M30W: would that include instances?
07:27:38 <`nand`> hiptobecubic: no
07:27:39 <`nand`> that's a constructor
07:27:43 <edwardk> hiptobecubic: constructor
07:27:50 <bas__work> M30W about 500 functions, but that's not all user-facing
07:27:59 <edwardk> hard to use inside the state monad ;)
07:28:05 <`nand`> bas__work: does that include functions in instances?
07:28:14 <mm_freak> M30W: ghci, :m Control.Lens, :bro
07:28:14 <edwardk> i actually abuse this in my unreleased DAE modeling tool
07:28:22 <`nand`> bas__work: and how many of them are aliases for ‘id’?
07:28:24 <bas__work> I think it doesn't mm_freak
07:28:31 <bas__work> erm `nand` *
07:28:33 <M30W> oh phone but okay haha.
07:28:52 <edwardk> twoPin p = do n <- cap; p^._i + n^._i := 0; return (n, p^._v - n^._v)
07:29:08 <M30W> heh. i still lenseless ;)
07:29:17 <edwardk> resistor r p = basic p $ \u -> r * p^._i := u
07:29:19 <hiptobecubic> this looks terrible
07:29:37 <M30W> I noob can read it. :)
07:29:42 <typoclass> `nand`: they may be aliases for id, but they're inexplicably faster =)
07:29:54 <edwardk> hiptobecubic: *shrug*
07:30:18 <hiptobecubic> what is := constructing?
07:30:30 <edwardk> there its adding constraints to a system of differential-algebraic equations
07:30:39 <M30W> concat
07:30:41 <hiptobecubic> i see
07:31:17 <M30W> > "x" := ["a","b"]
07:31:18 <lambdabot>   Not in scope: data constructor `:='
07:31:18 <lambdabot>  Perhaps you meant one of these:
07:31:18 <lambdabot>    `:+...
07:31:26 <M30W> O.o
07:31:56 <M30W> > "x" :+ ["a","b"]
07:31:57 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:31:57 <lambdabot>              with actual type...
07:32:38 <`nand`> typoclass: it's like a version of ‘id’ that uses unsafePerformIO and knowledge of GHC internals to optimize the Core of whatever argument it was passed
07:33:22 <hpaste> edwardk pasted “A toy DAE model” at http://hpaste.org/80738
07:33:32 <edwardk> hiptobecubic: there is a longer example
07:34:04 <M30W> > "x" :+ ["a","b"]
07:34:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:34:06 <lambdabot>              with actual type...
07:34:07 <edwardk> basically the monad accumulates constraints on signals involving them and their derivatives, and then the trick is to solve them all at the same time or sample from a distribution that includes them
07:34:26 <M30W> O.o
07:34:35 <edwardk> > (1 :+ 3)  * (2 :+ 3)
07:34:36 <lambdabot>   (-7.0) :+ 9.0
07:34:37 * `nand` can't help but think that using getters only to throw them in as x^.y all the time would be cleaner as ‘y x’; until you need the extra functionality lenses provide you with
07:34:49 <M30W> whats wrong with that?
07:34:50 <edwardk> `nand`: i need the extra functionality elsewhere
07:35:04 <elliott> `nand`: our unsafe*s are pretty simple-now
07:35:15 <elliott> it's all just to avoid newtypes apart from Data.Data.Lens which is horrific :)
07:35:36 <`nand`> Data.Data.Lens is quite something
07:35:49 <`nand`> ‘partsOf biplate’ is one of my personal favorites
07:36:24 <mm_freak> edwardk: currently with acid-state + ixset, when i reload the database, all sharing is lost…  does your tables library fix that in any way?
07:36:29 <edwardk> `nand`: with lens head you can use levels biplate.traverse to get a breadth first traversal of anything you want
07:36:56 <mSSM> It was suggested earlier, that instead of using a Double for my loop (i.e. t - 0.01 until t<=0), I use an Int, so that I would have t' = t*100 and steps of -1. Since I use t in a weighing function, exp(-p/t), I would need to coerce the new t :: Int to a Double with `fromInteger'. This would happen about 10^7 times in the course of my program. Does that make sense?
07:37:00 * `nand` updates
07:37:08 <M30W> @hoogle :+
07:37:08 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
07:37:11 <edwardk> mm_freak: i don't magically regain sharing. i do get the fact that when you set rows back in i retain references to the original rows, but i would presume that acid-state will destroy your sharing
07:37:38 <mm_freak> edwardk: i've read a few times about observable sharing
07:37:50 <mm_freak> but i don't know how practical that is
07:38:52 <edwardk> mm_freak: well, such a thing would be out of scope for lens, but perfectly reasonable for acid-state
07:38:52 <mSSM> I mean, is using fromIntegral sufficiently cheap to justify switching my iteration variable from Double to Int ?
07:39:10 <M30W> i have a diff definition in my code lol.
07:39:31 <mm_freak> edwardk: i see…  what about the Data.Char question?  are lenses for that planned?
07:39:56 <edwardk> mm_freak: i have other tricks for getting sharing too, not sure if you've ever seen my compressed library, but thats pretty nice for doing monoidal reductions with extra sharing
07:40:07 <edwardk> what was the question?
07:40:29 <mm_freak> edwardk: rot13 = text.letterOrd +~ 13
07:41:18 <merijn> mSSM: Will probably be unnoticeable with all the inlining and optimisation GHC does, try it and profile?
07:41:24 <mm_freak> i have an alpha-stage project where i would benefit from lenses for Data.Char
07:41:25 <edwardk> that can be constructed but it is you have to admit a bit of a hack =P
07:41:35 <elliott> mm_freak: they exist
07:41:37 <elliott> enum
07:41:46 <edwardk> elliott: that won't do the rot though
07:41:47 <elliott> :t enum
07:41:48 <lambdabot> (Enum a, Functor f, Isomorphic k) => k (a -> f a) (Int -> f Int)
07:41:48 <M30W> > text.letterOrd +~ 13 "test"
07:41:50 <lambdabot>   Not in scope: `letterOrd'
07:41:56 <elliott> well, you'd have to define letterOrd
07:42:00 <elliott> but they do the basic ord/chr
07:42:05 <edwardk> yeah
07:42:19 <elliott> (ugh, old isomorphisms)
07:42:23 <edwardk> > "hello"^..traverse.from enum
07:42:25 <lambdabot>   [104,101,108,108,111]
07:42:51 <mm_freak> :t (^..)
07:42:52 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
07:42:52 <int-e> @type (^..)
07:42:53 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
07:43:18 <mm_freak> anyway, thanks for now
07:43:21 <edwardk> (^..) gets a list of all the targets
07:43:21 <saeidw> "s t a b", that always makes me nervous
07:43:23 <int-e> all this violence and stabbing...
07:44:09 <M30W> how do you define a datatype like Word8? (overflows if you go over max value?
07:45:11 <M30W> saeidw: ?
07:45:21 <M30W> who stap? O.o
07:45:29 <edwardk> :t (^.)
07:45:31 <lambdabot> s -> Getting a s t a b -> a
07:45:40 <edwardk> ^- see Getting a s t a b  -- sounds painful
07:45:42 <int-e> (^..) stabs a list [a] with an arrow ->
07:46:07 <M30W> O.o
07:46:16 <M30W> violense for lists
07:46:25 <edwardk> the lenserati are violent folks
07:46:34 <int-e> violens, that's a good word for it.
07:47:15 <M30W> int-e: thats what i meant haha.
07:48:35 * M30W hopes that "violens" gets into haddock. :D
07:49:42 <M30W> Tue Jan 15 02:49:25 EST 2013
07:50:11 <M30W> early tonight i know but... night guys (not sarcasm, trended truth)
07:51:15 <M30W> Bye world!
07:52:07 <`nand`> time to update my way through kmett dependency hell
07:52:25 <edwardk> `nand`: sorry bout that =)
07:52:49 <`nand`> it's mainly just a tedious procedure of ‘importing the latest hackage version of all edwardk libraries’
07:54:26 <hiptobecubic> how is that EST?
07:54:55 <geekosaur> probably not the EST you're thinking of
07:55:04 <geekosaur> the letter timezones have way too many collisions
07:55:11 <clahey> Man...
07:55:28 <clahey> xchat says someone said my name, but it scrolled off the top.
07:56:12 <geekosaur> [14 08:37] <emias> clahey:
07:56:12 <geekosaur> [14 08:37] <emias> (Oops, sorry.)
07:56:31 <geekosaur> looks like a mis-nick completion
07:56:58 <`nand`> clahey: increase your scrollback limit for #haskell :)
07:58:34 <Saizan> logs
07:58:42 <Saizan> in the topic too
07:59:44 <osfameron> oh, #haskell is automatcially logged?
08:00:10 <clahey> `nand`: To a million lines a day?
08:00:57 <`nand`> I have mine set to 16384 which seems to work fairly well
08:03:23 <zhulikas> I am looking for a right way to parse simple file
08:03:32 <zhulikas> http://projecteuler.net/project/poker.txt
08:03:39 <zhulikas> without using dedicated parsing libraries
08:03:48 <zhulikas> just a simple lines, words, etc
08:03:56 <zhulikas> but I end up having ugly map of multiple levels
08:04:09 <zhulikas> so was wondering if there is a better way to parse it
08:04:30 <`nand`> > read "0x8C" :: Word8 -- /me ducks
08:04:31 <lambdabot>   140
08:04:46 <`nand`> oh
08:04:47 <`nand`> that isn't hex
08:04:54 <`nand`> how misleading
08:05:00 <t7> 2 case statements
08:05:02 <zhulikas> yeah
08:05:04 <t7> in the maybe monad
08:05:11 <zhulikas> I will apply a function of my own on those values
08:05:27 <zhulikas> so that's another level of mapping :)
08:06:15 <t7> babbysPokerParser . unwords . unlines
08:07:21 <earthy> zhulikas: map at the intermediate levels
08:07:27 <earthy> and use function composition
08:07:33 <zhulikas> I am actually thinking about list comprehension
08:07:37 <zhulikas> that doesn't look too ugly
08:08:01 <earthy> map evaluateHands . unlines (each pair of hands is on one line)
08:08:09 <`nand`> :t words <=< lines
08:08:10 <lambdabot> String -> [String]
08:08:19 <zhulikas> huh
08:08:25 <earthy> errr.. lines
08:08:26 <zhulikas> now that's something more useful what `nand` just did
08:08:28 <earthy> my haskell is rusty. ;)
08:08:32 <zhulikas> oh no it isn't
08:08:43 <zhulikas> it should give [[String]] :|
08:08:48 <zhulikas> anyway, let me try compherension
08:08:55 <earthy> what, you want [[String]] from poker.txt?
08:08:56 <zhulikas> resume to your other duties for now :)
08:09:06 <zhulikas> yes. Lines are split for a reason
08:09:06 <earthy> where each element is a card?
08:09:12 <zhulikas> every line is 10 cards
08:09:17 <zhulikas> 5 cards each player
08:09:20 <`nand`> zhulikas: oh, you want the lines to be distinct
08:09:22 * earthy saw the assignment
08:09:24 <zhulikas> yesh :)
08:09:29 <zhulikas> sorry for not posting euler probelm
08:09:32 <zhulikas> thought it was irrelevant
08:09:39 <zhulikas> and may have looked like asking for help
08:09:41 <`nand`> :t fmap words . lines
08:09:42 <lambdabot> String -> [[String]]
08:09:56 <earthy> but fmap words . lines is not what you want, logically
08:10:03 <earthy> as each line is 2 dealt hands that need to be evaluated
08:10:09 <zhulikas> :t fmap ((\_ -> 0) . words . lines)
08:10:10 <lambdabot>     Couldn't match expected type `Char' with actual type `String'
08:10:11 <lambdabot>     Expected type: String -> String
08:10:11 <lambdabot>       Actual type: String -> [String]
08:10:23 * `nand` should stop helping without knowing what the problem is
08:10:30 <zhulikas> I expected it to be [[Int]] O.o
08:10:47 <earthy> :t fmap ((\_ -> 0) . words) . lines
08:10:48 <lambdabot> Num b => String -> [b]
08:11:15 <earthy> :t fmap (fmap (const 0) . words) . lines
08:11:16 <lambdabot> Num b => String -> [[b]]
08:11:24 <earthy> does that help at all? :)
08:11:32 <zhulikas> :t fmap (map (\_ -> 0) . words) . lines
08:11:33 <lambdabot> Num b => String -> [[b]]
08:11:34 <zhulikas> yeah
08:11:36 <zhulikas> that's what I need
08:11:45 <zhulikas> thanks :D
08:11:49 <zhulikas> doesn't look too ugly
08:11:50 <earthy> no. but you don't know that yet. ;)
08:12:30 <zhulikas> yup, it works as expected :}
08:12:57 <ellly> hey guys!
08:13:14 <byorgey> hi ellly!
08:14:05 <`nand`> guess he didn't like the sound of byorgey
08:14:18 <byorgey> =(
08:15:22 <earthy> but byorgey is fun!
08:15:39 <byorgey> =D
08:16:53 <BobbyMcLiar> Is there an easy way to understand (.).(.)? It confuses me extremely.
08:17:04 <mrout> boobs
08:17:35 <BobbyMcLiar> no. ( . ) ( . ) have a different type than (.).(.)
08:17:39 <Eelis> BobbyMcLiar: i think it's reasonable to say that (.).(.) should never occur in a real program anyway
08:17:47 <BobbyMcLiar> oh, ok
08:17:58 <parcs> > length (map (\ !x -> x) [1,2,undefined,3])
08:18:00 <lambdabot>   4
08:18:02 <mvj4_> (f .) . g is okay
08:18:08 <parcs> wat :(
08:18:33 <srhb> @src length
08:18:33 <lambdabot> Source not found. Sorry.
08:18:42 <srhb> Well, anyway, it never inspects each cell
08:18:51 <`nand`> I've used (.).(.) in a real program!
08:18:57 <zhulikas> :D
08:18:59 <parcs> > foldl (\ a !b -> a) () [1,2,undefined,3]
08:18:59 <zhulikas> nice!
08:19:00 <lambdabot>   *Exception: Prelude.undefined
08:19:01 <`nand`> here's how I use it
08:19:15 <zhulikas> :t  (.).(.)
08:19:16 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
08:19:20 <`nand`> given for example foo a b = bar (bat a b)
08:19:30 <`nand`> this can clearly be simplified to:  foo a = bar . bat a
08:19:40 <`nand`> but this still leaves us with one ‘a’
08:19:44 <`nand`> the next step is: foo = bar .: bat
08:19:46 <allsystemsarego> @src Control.Arrow.first
08:19:46 <lambdabot> Source not found. It can only be attributed to human error.
08:20:00 <allsystemsarego> no, that's lambdabot error
08:20:09 <`nand`> allsystemsarego: it's human error
08:20:15 <`nand`> error of the people writing the @src database
08:20:21 <allsystemsarego> oh ok
08:20:26 <allsystemsarego> :)
08:20:35 <`nand`> Control.Arrow.first is a class method either way :)
08:20:41 <`nand`> @src Arrow
08:20:41 <lambdabot> class Arrow a where
08:20:41 <lambdabot>     arr, pure   :: (b -> c) -> a b c
08:20:41 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
08:20:41 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
08:20:41 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
08:20:43 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
08:20:45 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
08:20:46 <`nand`> so there's the source
08:21:00 <allsystemsarego> ahh, makes sense thanks
08:21:15 <parcs> just substitute (.) with its definition
08:21:36 <`nand`> (isn't it class Category a => Arrow a where ...?)
08:21:54 <rio> where do i find definitions like "Data [] a = ..." in a ghc installation on linux?
08:22:08 <BobbyMcLiar> I've tried substituting. Its to hard for me x)
08:22:09 <`nand`> and (>>>) isn't in Arrow
08:22:55 <`nand`> rio: that one can't be defined in Haskell itself because the operators aren't exactly legal
08:23:06 <`nand`> rio: but most Prelude stuff can be found in ‘base’
08:23:32 <`nand`> which would be in /usr/share/doc/... or somewhere probably; or you can just consult hackage
08:24:17 <hiptobecubic> :t first
08:24:18 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
08:24:20 <hiptobecubic> how can that be?
08:24:28 <hiptobecubic> where does it get d?
08:24:31 <`nand`> looks fine to me
08:24:38 <`nand`> does it matter? think of (->) for a
08:24:49 <`nand`> the result would be (b,d) -> (c,d) -- the d is right there
08:25:20 <hiptobecubic> oh, i was misreading this
08:25:46 <clahey> hiptobecubic: Yeah, where does (b -> c) -> (b, d) -> (c, d) get the d?
08:26:02 <gianluka> ciao a tutti
08:26:03 <mrout> THIS LANGUAGE IS FUCKING AMAZING
08:26:12 <gianluka> hello
08:26:14 <mauke> inb4 list
08:26:18 <mrout> Just thought I should mention that.
08:26:23 <clahey> mrout: NO DOUBT
08:26:24 <`nand`> mrout: english?
08:26:37 <quicksilver> clahey: (b -> c) -> ((b,d) -> (c,d))
08:26:52 <clahey> quicksilver: -> is right associative, no?
08:26:52 <hiptobecubic> well there it's an argument, but a b c -> a (b,d) (c,d)  is misleading if you aren't paying attention
08:26:53 <mrout> `nand`: yes
08:27:02 <quicksilver> clahey: given a function from b to c, you create a function from (b,d) to (c,d) which does nothing to the 'd' part
08:27:18 <hiptobecubic> right, that i understand
08:27:19 <clahey> quicksilver: It was a rhetorical question.
08:27:45 <hiptobecubic> I wasn't thinking of a as (->0
08:27:47 <hiptobecubic> )
08:27:52 <`nand`> hiptobecubic: I liked Arrow (~>) for that :(
08:28:05 <mrout> I call ~> the sperm operator
08:28:07 <clahey> hiptobecubic: I don't really have any other arrows in my head.
08:28:11 <`nand`> a ~> b -> (b,c) ~> (a,c)
08:28:29 <clahey> `nand`: It switches the order of a and b?
08:28:30 <quicksilver> clahey: oh, sorry :)
08:28:37 <`nand`> clahey: my mistake
08:28:44 <`nand`> (a,c) ~> (b,c)
08:28:45 <clahey> Which is ~>?
08:28:46 <mrout> @src (~>)
08:28:46 <lambdabot> Source not found. :(
08:28:50 <mrout> @src ~>
08:28:51 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:28:52 <hiptobecubic> it isn't
08:28:57 <`nand`> ~> was just a type variable in that example
08:29:04 <`nand`> but this is no longer possible
08:29:09 <clahey> ?
08:29:12 <hiptobecubic> operator-looking type variables?
08:29:17 <`nand`> yeah
08:29:17 <ski> yes
08:29:24 <`nand`> you can still do something like this:
08:29:33 <`nand`> first :: b `a` c -> (b,d) `a` (c,d)
08:29:38 <clahey> What is the type of Kleisi arrows?
08:29:46 <`nand`> clahey: a -> m b
08:29:48 <clahey> Kleisli?
08:29:48 <`nand`> = Kleisli m a b
08:30:07 <ocharles> any idea wtf is going on with: /home/ollie/.cabal/lib/unordered-containers-0.2.3.0/ghc-7.4.2/HSunordered-containers-0.2.3.0.o: unknown symbol `hashablezm1zi2zi0zi5_DataziHashableziClass_defaultSalt_closure'
08:30:17 <clahey> Monad m => instance Arrow Kleisli m   then?
08:30:18 <ocharles> If I install hashable 1.2.0.5 it works fine, if I install 1.1.2.5 I get that
08:30:24 <ocharles> but I need <1.2 to install snap
08:30:33 <clahey> So, in that case first is:
08:30:40 <ski> @type first :: Arrow ar => a0 `ar` a1 -> (a0,b) `ar` (a1,b)
08:30:41 <lambdabot> Arrow ar => ar a0 a1 -> ar (a0, b) (a1, b)
08:30:43 <`nand`> ocharles: have you tried rebuilding unordered-containers?
08:30:46 <hpaste> seydar pasted “cabal” at http://hpaste.org/80740
08:30:47 <`nand`> after installing 1.1.2.5
08:30:55 <clahey> (a -> mb) -> ((a,d) -> m (b, d))
08:31:00 <ocharles> `nand`: yep, this is after a rm -r ~/.ghc nuke
08:31:15 <`nand`> clahey: guessing you meant ‘m b’ yeah
08:31:21 <ski> @type runKleisli . first . Kleisli
08:31:22 <lambdabot> Monad m => (b -> m c) -> (b, d) -> m (c, d)
08:31:29 <clahey> `nand`: Touché.
08:31:33 <hpaste> seydar annotated “cabal” with “cabal (annotation)” at http://hpaste.org/80740#a80741
08:31:46 <clahey> ski: Thank you.  :)
08:32:03 <clahey> I can see how that would work and why it might be useful.
08:32:03 <hpaste> seydar pasted “cabal” at http://hpaste.org/80742
08:32:13 <ocharles> `nand`: gonna try again constraining to an older version of unordered-containers
08:32:28 <clahey> Are there any other arrows that are common?
08:32:33 <`nand`> Automaton
08:32:52 <`nand`> newtype Auto a b = Auto { runAuto :: a -> (b, Auto a b) }
08:33:24 <clahey> a is the state and b is the output?
08:33:36 <seydar> hey guys. i'm having trouble using cabal to install zlib. i think it's because i upgraded my ghc but not something else http://hpaste.org/80742
08:34:14 <clahey> What is the definition of >>>?
08:34:20 <`nand`> (>>>) is a class method
08:34:25 <`nand`> oh, you mean for Auto?
08:34:27 <clahey> Yes.
08:35:25 <srhb> class "method"? Is that really a term?
08:35:45 <elliott> yes
08:35:57 <elliott> haskell typeclass terminology is chosen specifically to confuse OOP programmers as much as possible
08:36:02 <ocharles> FUUUUUUUUUUUUUU. Loading package lens-3.7.3 ... linking ... ghc: /home/ollie/.cabal/lib/lens-3.7.3/ghc-7.4.2/HSlens-3.7.3.o: unknown symbol `unorderedzmcontainerszm0zi2zi3zi0_DataziHashMapziBase_traverseWithKey_info' ghc: unable to load package `lens-3.7.3
08:36:04 <srhb> What a horrible idea.
08:36:13 <ocharles> that's when I constrain hashable and unordered-containers
08:36:16 <ocharles> cabal, wtf are you doing.
08:36:19 <elliott> ocharles: rm -rf ~/.ghc
08:36:23 <ocharles> i've already done that twice
08:36:26 <n-dolio> I expect that's due to OOP programmers coming over and calling it that.
08:36:29 <elliott> ocharles: not enough
08:36:32 <ocharles> heh
08:36:32 <n-dolio> Not some conscious effort.
08:36:41 <quchen> OOP class terminology is chosen specifically to confuse Haskell programmers as much as possible
08:36:49 <elliott> n-dolio: yeah, "typeclass member" seems the better terminology
08:36:57 <clahey> @hoogle Atomaton
08:36:57 <lambdabot> No results found
08:36:59 <srhb> I don't see why one would ever call it method over function, anyway
08:37:00 <ocharles> i guess cabal install doesn't clean first?
08:37:04 <clahey> @hoogle Automaton
08:37:04 <lambdabot> No results found
08:37:04 <`nand`> clahey: something like this: f >>> g = Auto $ \x -> let (y, f') = runAuto f x; (z, g') = runAuto g y in (z, f' >>> g')
08:37:09 <ocharles> maybe it's cause i previously compiled with different versions, and am now trying to install?
08:37:12 <elliott> but I'm pretty sure I've seen "method" from people I don't think came from OOP, though
08:37:14 <n-dolio> elliott: I don't know. That could mean a type that is an instance of a type class.
08:37:46 <elliott> n-dolio: hmm, perhaps... I don't generally think of typeclasses as sets of types like that
08:37:53 <elliott> "typeclass thing"
08:37:55 <clahey> @hoogle Auto
08:37:56 <lambdabot> package AutoForms
08:37:56 <lambdabot> Graphics.Rendering.OpenGL.GL.Evaluators autoNormal :: StateVar Capability
08:37:56 <lambdabot> package autoproc
08:38:23 <n-dolio> I'm not sure how the terminology could have become the same incidentally.
08:38:25 <`nand`> I'm just going by the haskell report here
08:38:27 <`nand`> http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-750004.3
08:38:33 <`nand`> “A class declaration introduces a new class and the operations (class methods) on it.”
08:38:45 <n-dolio> Although I don't know the origin of the OOP usage.
08:38:55 <elliott> `nand`: now you get to bisect haskell reports until you find the first one that used "method"
08:39:08 <seydar> is ghc 7.6.1 not the version i should be using?
08:39:33 <`nand`> elliott: it's there in haskell 98
08:39:40 <`nand`> I don't know how to go further back than that
08:39:51 <`nand`> seydar: depends
08:39:54 <elliott> http://www.haskell.org/haskellwiki/Definition#Historic_development_of_Haskell
08:39:59 <`nand`> I use GHC 7.6.1, personally
08:40:13 <elliott> some of the early reports are an interesting read for the ways in which they are superior to Haskell 98
08:40:24 <seydar> `nand`: what version of cabal do i need for it? because 1.8.0.4 is failing for me
08:40:38 <geekosaur> I don't think that's cabal's fault
08:40:41 <`nand`> doesn't cabal come with ghc?
08:40:49 <`nand`> anyhow, I have 1.16.0.3 installed
08:42:17 <n-dolio> elliott: Actually, looks like Wadler's original paper used the word "method" even. So I'll assume he just borrowed the terminology from OOP, even though it's not really the same thing.
08:42:23 <`nand`> elliott: aha!
08:42:27 <`nand`> Haskell Report 1.0
08:42:31 <elliott> mm
08:42:45 <`nand`> “..definitions of the overloaded operations - called methods - instantiated on the named type”
08:42:50 <elliott> I like "member" more because "method" seems to require them to be functions to me
08:42:55 <`nand`> same
08:43:02 <`nand`> I'd go with ‘member’ personally
08:43:23 <`nand`> elliott: well, you could consider them as function in a sort of weird denotational dictionary-to-value sense
08:43:33 <elliott> that's a bit operational for my tastes :)
08:43:47 <geekosaur> seydar: that option is coming from bytestring, changing your cabal version will not matter
08:44:04 <geekosaur> zlib requires a version of bytestring that is not compatible with ghc 7.1, apparently
08:44:08 <geekosaur> 7.6 I mean
08:44:28 <`nand`> elliott: but since the terminology is apparently ‘method’, I'm calling it that just to abuse the ‘class method’ OOP pun as much as possible
08:44:51 <`nand`> maybe we should overuse it to a degree that the haskell report will have to be changed!
08:45:21 <geekosaur> actualy it looks like the latest zlib should be compatible with the bytestring that is part of your ghc install
08:45:37 * `nand` has zlib installed on GHC 7.6.1
08:45:39 <n-dolio> You should go around to Java noob forums and ask, "what's a class method? Is it like a type class method in Haskell?"
08:45:41 <`nand`> 0.5.4.0
08:45:53 <geekosaur> but you are getting 0.5.3.1 according to your pasted output
08:46:07 <seydar> geekosaur: thank you. do you recommend moving down to 7.4.1?
08:46:12 <geekosaur> I would wonder if you have run "cabal update" recently
08:46:14 <S11001001> n-dolio: the answer will simply be "yes but easier to understand"
08:46:19 <geekosaur> to get the latest list of packages
08:46:22 <`nand`> n-dolio: “how do I add types in java??”
08:46:32 <n-dolio> S11001001: I think the answer might be, "what's Haskell?"
08:46:50 <seydar> geekosaur: haha, nope, i hadn't. i tried to do `cabal install cabal cabal-install` but that failed miserably
08:46:50 <n-dolio> Or, "Pascal has classes?"
08:46:58 <seydar> geekosaur: gracefully, but still miserably
08:46:59 <`nand`> seydar: 7.4.2 instead of 7.4.1
08:47:15 <`nand`> at any rate, if you want to use GHC 7.6.1, you should be fine as long as you stick to the latest versions of packages
08:47:19 <S11001001> "oh, you're a Delphi user.  Well welcome to modern programming with Java, enjoy"
08:47:29 <geekosaur> seydar:  "cabal update" does not have anything to do with uupdating cabal library or program\
08:47:33 <geekosaur> it updatews rhe *package list*
08:47:52 <geekosaur> cabal is trying to install older versions of things because you haven't had it go out to get the latest list of packages
08:50:32 <seydar> geekosaur: thank you, `cabal update` did the trick. However, I'm worried about having an old version of things and i'm afraid i'm going to die of it all. i'm going to try to update my cabal/cabal-install and i'll get back to you, likely in tears
08:51:22 <geekosaur> the cabal library comes with ghc and should probably not be updated without good reason
08:53:07 <seydar> i downloaded the ghc binary (mac os x). am i still good?
08:53:18 <seydar> also, can you explain where/how haskell does libraries?
08:53:46 <seydar> i come from a Ruby background so while i feel like there's a lot of overlap, i'm worried that there are some gray areas
08:56:06 <geekosaur> "ghc-pkg list"
08:58:25 <hiptobecubic> seydar, also look in you cabal config for the line about profiling and make sure it's turned on
08:58:41 <hiptobecubic> ~/.cabal/config here
08:58:46 <hiptobecubic> library-profiling: True
08:59:30 <hiptobecubic> Otherwise someday you'll want to profile an app and it will complain about not having the profiling libraries installed. Then when you try to install them it will tell you that everything needs to be reinstalled and it's going to break.
09:00:58 <seydar> hiptobecubic: good idea, thank you
09:02:01 <message144> seydar, im a newb, but in my limited experience package management is a nightmare, fwiw
09:02:24 <startling> seydar, cabal install installs things to ~/.ghc which you can nuke at leisure
09:02:41 <hiptobecubic> message144, indeed :(
09:02:58 <hiptobecubic> it really surprised me, actually. Because the rest of the language seems pretty nicely thought out
09:03:17 <startling> package management normally works, but when it doesn't it's a huge pain
09:03:26 <message144> ive been pretty stumped on figuring out how to install hmatrix on ubuntu... i guess thats part of the whole learning curve
09:03:29 <message144> heh
09:04:21 <allsystemsarego> @src Control.Monad.State
09:04:21 <lambdabot> Source not found. I feel much better now.
09:04:38 <allsystemsarego> hm, lambdabot isn't consistent with itself
09:05:30 <startling> allsystemsarego: what are you expecting, the entire module source?
09:05:36 <startling> allsystemsarego: anyway, @src doesn't work and is a hack
09:05:50 <allsystemsarego> startling, no, just the class methods
09:06:02 <startling> allsystemsarego: Control.Monad.State is a module, not a class
09:06:08 <allsystemsarego> ok
09:06:13 <startling> @src MonadState
09:06:13 <lambdabot> Source not found. Take a stress pill and think things over.
09:08:58 <steveku> Can anyone explain this cabal error message to me? http://hpaste.org/80743. I'm trying to cabal install --only-dependencies a local .cabal file, with an executable called foo in it. I have no idea what cabal is trying to tell me!
09:11:51 <bergmark> steveku: it seems foo's version bounds on parallel don't match with deepseq's
09:12:27 <steveku> bergmark: i can be flexible and modify my code to fit a different api - which version of parallel should i use?
09:12:48 <bergmark> you can try to just remove your version bounds and see which one cabal picks for you
09:13:40 <steveku> bergmark: ah, clever, thanks
09:13:45 <erineh_> something seems to be wrong with the readline package
09:13:59 <erineh_> it cant find my readline library, probably a version problem
09:14:12 <erineh_> on mac and on ubuntu
09:14:59 <geekosaur> mac would not be unusual; you need to install a real one from somewhere
09:15:13 <geekosaur> the "readline" apple ships is not actually readline, it's BSD editline and not compatible
09:15:22 <bergmark> steveku: i find that unless you know why you want a specific version, don't specify it, and then maybe add one later if that causes problems
09:15:23 <steveku> erineh_: i've seen a problem like that - are you using homebrew? you need to manually link the readline keg
09:15:33 <erineh_> yeah brew install readline
09:15:38 <erineh_> keg?
09:15:46 <steveku> bergmark: i was worried that a new major api would break my app
09:15:51 <erineh_> ok
09:16:00 <startling> brew link readline
09:16:02 <geekosaur> so you need to install a real readline and then you need to tell the haskell readline package where to find it because it could be in multiple places depending on how you got it/where you installed it
09:16:23 <erineh_> i brew installed readline
09:16:28 <steveku> erineh_: this was where i found the solution i think http://stackoverflow.com/questions/8291137/how-do-you-install-the-haskell-readline-library-on-mac-osx
09:16:29 <beaky> what is an algorithm?
09:16:30 <startling> you can just brew link readline && cabal install whatever && brew unlink readline
09:16:48 <erineh_> interesting
09:17:11 <erineh_> that did not work
09:17:18 <erineh_> same error
09:17:23 <erineh_> configure: error: readline not found, so this package cannot be built
09:17:31 <startling> erineh_: weird
09:17:40 <steveku> startling: i think there are still some subleties to it than that - cabal doesn't find the readline lib unless you manually specify paths as in that SO post
09:17:59 <startling> steveku, bizarre, I remember solving it that way
09:18:07 <erineh_> this is brutal
09:18:11 <startling> beaky: a description of a computational process
09:18:14 <bergmark> steveku: it might! so you might want to specify bounds at some point later on if you want it to be stable, but either way it's a good idea to keep a lookout for newer versions because you probably want to use them
09:18:53 <beaky> startling: so it means the same thing in a functional programming context?
09:19:02 <startling> beaky: yes
09:19:38 <beaky> I used to think it was a finite series of well-defined steps to a solution
09:20:01 <startling> beaky: sure, same thing
09:20:14 <erineh_> i saw the SO post already, and i tried to homebrew version, did not work
09:20:21 <beaky> I guess steps means beta reduction in functional programming
09:21:23 <steveku> beaky: careful not to confuse an algorithm with a way to implement that algorithm - beta reduction is a programming language implementation algorithm, and you normally wouldn't concern yourself with beta reduction when formulating a domain specific algorithm
09:21:53 <beaky> ah
09:21:55 <beaky> right
09:22:03 <startling> beaky: no, "step" is more general
09:22:06 <beaky> I still don't understand what an algorithm is then :(
09:22:17 <startling> beaky: it's like a program, but more vague
09:22:30 <beaky> so it's like unicode codepoints
09:22:35 <startling> ???
09:23:01 <beaky> unicode codepoints are like the platonic concept of a character, while UTF-8 is an implementation
09:23:29 <startling> ummmm okay
09:23:38 <beaky> maybe that was a bad analogy :(
09:23:58 <startling> an algorithm *is* like the platonic ideal of some programs though
09:24:41 <beaky> I guess what exactly an algorithm is is a topic of reearch in CS :D
09:24:42 <beaky> research*
09:24:50 <startling> probably not.
09:24:53 <tac> An algorithm is like a cook's recipe. Only it can contain small copies of itself inside of itself.
09:25:13 <osfameron> are there recursive recipes?
09:25:15 <beaky> cooks recipies are too procedural/imperative
09:25:16 <startling> tac, how to make biscuits: first, make some biscuits
09:25:27 <tac> startling: _|_ biscuits :D
09:25:31 <startling> beaky: there's not a meaninful difference
09:25:36 <startling> tac: ;)
09:26:28 <startling>  beaky, an imperative algorithm is essentially equivalent to a functional one
09:26:33 <beaky> cooking recipes are probably monads
09:26:37 <beaky> ah
09:26:45 <beaky> so they are isomorphic?
09:26:53 <startling> no
09:27:25 <erineh_> i tried putting /usr/local/Cellar/...../include in the cabal install options
09:27:26 <tac> probably in some category.
09:27:34 <erineh_> blarg
09:27:39 <neutrino> osfameron: there exist recursive recipes.
09:27:41 <steveku> beaky: i would sum up by saying that a very precise definition of algorithm is irrelevant in your quest to learn the haskell language
09:27:46 <beaky> ah
09:28:18 <beaky> I was just wondering if all imperative algorithm can be expressed in a purely-functional manner.
09:28:26 <neutrino> osfameron: bread dough is one example.
09:28:27 <beaky> all imperative algorithms*
09:28:30 <startling> sure; it's completely mechanical
09:28:48 <companion_cube> but you don't necessarily keep the efficiency properties
09:29:01 <startling> beaky, an imperative procedure a -> b is just a pure function MachineState -> a -> b
09:29:23 <tac> beaky: That's essentially what the state monad does
09:29:25 <osfameron> neutrino: hmmm, isn't that just "knead until done" ?
09:29:35 <startling> well, MachineState -> a -> (b, MachineState)
09:29:53 <elliott> data Fact a where { X :: Fact Void; Y :: Maybe a -> Fact a -> Fact (Maybe a) } -- too bad the Maybe uglies this up
09:30:10 <erineh_> when it says look in config.log for details, where is config.log?
09:30:15 <startling> you can only recur on structurally smaller recipes
09:30:26 * elliott wonders if that type is actually useful for anything
09:30:38 <startling> or corecipes
09:30:53 <neutrino> to make dough, you use a piece of old dough, to get the same yeast cultures which worked before.
09:31:17 <startling> neutrino: no you don't
09:31:19 <ski> beaky : perhaps "What Is an Algorithm?" by Yiannis N. Moschovakis in 2001 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.7.5576> could be interesting
09:31:27 <osfameron> neutrino: oh.  that's *a* method.  I've seen one person do that ever.
09:31:33 <osfameron> mostly you just use yeast.
09:31:41 <beaky> yeah I was watching that one :D
09:34:56 <neutrino> osfameron: was that in a bakery?
09:35:06 <beaky> so an algorithm is some abstract piece of imperative knowledge, while things like turing machines/FSMs and the lambda calculus are models of computing such algorithms, and C and Haskell are implementations?
09:35:25 <osfameron> neutrino: it was my ex-business partner, making French baguettes.
09:35:47 <neutrino> in a bakery?
09:36:06 <osfameron> no, at his house
09:36:09 <neutrino> what was the setting? obviously you wouldn't keep dough around at home.
09:36:10 <neutrino> oh
09:36:22 <osfameron> he kept some in the fridge
09:36:47 <neutrino> when you say "mostly", did you mean at home, or in a commercial setting?
09:37:07 <osfameron> but it was a crankish idea from a bread book he'd read.  I don't think it's common practice at home
09:37:14 <osfameron> neutrino: I have no knowledge of commercial baking.
09:37:31 <neutrino> oh
09:37:46 <neutrino> i guess it must be more common there, since they always have left-over dough anyways
09:38:03 <neutrino> for example in a pizza bakery
09:38:35 <ski> elliott : where did `Fact' come from ?
09:38:56 <steveku> osfameron: it's normal in ireland, to make soda bread
09:40:53 <elliott> ski: |Fact Void| = 1, |Fact (Maybe a)| = |Maybe a| * |Fact a|
09:41:01 <elliott> ski: fact 0 =1, fact (n+1) = (n+1) * fact n
09:41:29 <ski> beaky : Moschovakis had an interesting chapter in the book "Truth in Mathematics" in 1998 (editors : Garth Dales,G. Oliveri) -- i'm not sure whether it's available online ..
09:41:32 <mm21> neutrino: it's normal here (germany) too
09:41:42 <Philippa> that awkward moment when you realise you need to embed something akin to refinement types in your typeclass
09:42:02 * ski grins
09:42:14 <beaky> ah
09:42:45 <ski> (an interesting chapter on algorithms -- and a critical discussion of other attempts to define what an algorithm is)
09:43:06 <beaky> @src gcd
09:43:06 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
09:43:06 <lambdabot> gcd x y = gcd' (abs x) (abs y)
09:43:06 <lambdabot>    where gcd' a 0  =  a
09:43:06 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
09:43:14 <elliott> ski: it didn't come from anywhere but me trying to write a type-level factorial more or less
09:43:18 <elliott> it is an unsatisfying solution
09:43:21 <ski> > gcd 0 0
09:43:23 <lambdabot>   0
09:43:31 <elliott> I think the product definition might correspond to some nice dependent function type
09:43:49 <elliott> (k : Fin n) -> Fin k or something
09:43:55 <ski> elliott : nicer would be if one could express the type of isomorphisms over `a'
09:44:15 <Philippa> ski: I'm sure having fun with my library, huh? :-)
09:44:22 <ski> (i suppose s/isomorphisms/automorphisms/)
09:44:51 <ski> Philippa : it sounded like that. i haven't recently checked updates
09:45:05 <ski> (anything i should check for ?)
09:45:20 <Philippa> eh. Haven't pushed anything interesting/non-tweaky in a bit
09:45:50 <yitz> urgh gcd still throws error? every year someone proposes to fix that, everyone agrees, and then it never happens. bikeshedding or something.
09:45:54 <zhulikas> @pl (a b) && (a c)
09:45:54 <lambdabot> a b && a c
09:45:57 <zhulikas> ok :|
09:46:03 <ski> yitz : see lambdabot's reply above
09:46:09 <zhulikas> what is the command to give me suggestions for functions?
09:46:15 <zhulikas> @djinn (a b) && (a c)
09:46:15 <lambdabot> Cannot parse command
09:46:26 <ski> > 5 `mod` 0  -- however, :(
09:46:28 <lambdabot>   *Exception: divide by zero
09:46:39 <yitz> ski: ah you mean they just didn't update @src?
09:46:44 <ski> yes
09:46:55 <yitz> ski: whew. a much more minor problem. :)
09:47:00 <ski> zhulikas : `(a b) && (a c)' doesn't look like a type
09:47:25 <zhulikas> I remember there was a monadic function to somehow extract that && and 'a'
09:47:54 <zhulikas> (&&) . a $ magicFunction b c
09:47:55 <zhulikas> sort of like this
09:48:06 <ski> perhaps you could explain what you're looking for ?
09:48:07 <zhulikas> not exactly though...
09:48:13 <zhulikas> eh, nevermind.
09:48:46 <Philippa> ski: so the refinement types thing is my punishment for building what amount to 'meta transformers'
09:49:24 <ski> iirc your "meta" thing was a functor adding meta-variables
09:49:26 <Philippa> (...hah, I might end up channeling /everything/ through Fix or the type that's currently called Id, then)
09:49:41 <Philippa> yeah, it's a thinly disguised free monad :p
09:49:49 <basdirks> zhulikas: you looking for liftM2?
09:49:51 <zhulikas> @type liftM2 (a . b) c d
09:49:52 <lambdabot>     Couldn't match expected type `a0 -> a20 -> r0'
09:49:52 <lambdabot>                 with actual type `Expr'
09:49:52 <lambdabot>     In the first argument of `(.)', namely `a'
09:49:52 <zhulikas> yes!
09:49:53 <Philippa> so annotations are also a useful thing? Cue a cofree comonad
09:49:55 <basdirks> =]
09:49:57 <zhulikas> ok, I failed, but that's the function
09:49:57 <zhulikas> :D
09:50:32 <Philippa> I suspect I will find some other items worth having in that vein
09:50:42 <Philippa> (even if they're specialisations of those two!)
09:50:44 <basdirks> @pf \x -> f x && g x
09:50:44 <lambdabot> Maybe you meant: bf pl
09:50:48 <basdirks> @pl \x -> f x && g x
09:50:48 <lambdabot> liftM2 (&&) f g
09:51:33 <ski> however, `liftM2 (&&) f g' will run both `f' and `g'
09:51:49 <zhulikas> @type liftM2
09:51:51 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:51:54 <basdirks> as opposed to the @unpl'ed version?
09:52:57 <ski> well, it's not clear to be whether zhulikas was looking for something in the `(rho ->)' monad or not
09:53:55 <yitz> > let u x = const False x && undefined x in u 42
09:53:57 <lambdabot>   False
09:54:30 <yitz> > let u = liftM2 (&&) (const False) undefined in u 42
09:54:31 <lambdabot>   False
09:54:44 <yitz> ski? ^^
09:54:56 <beaky> so an algorithm is the essence of a computational process
09:55:02 <ski> yitz : yes
09:55:30 <yitz> ski: the liftM2 version did not run both functions
09:55:45 <ski> (note that i didn't say "evaluate" instead of "run")
09:56:10 <beaky> ah
09:56:13 <yitz> ski: so what did you mean then?
09:58:26 <ski> i meant that `liftM2 (&&) f g' is equal to `do b0 <- f; b1 <- g; return (b0 && b1)' -- and i'd say `f' and `g' is run (/executed) here (regardless of the monad) -- in "strict monads", this means that you'll get the effects of `g' even if the result of `f' is `False'
09:59:41 <yitz> ski: but we're talking about a very specific monad here. apparently, it isn't strict in that sense. so the two forms appear to be exactly equivalent.
10:00:30 <HugoDaniel> how can i know the length of a constant list in compile time ?
10:01:01 <opqdonut> make it a tuple :)
10:01:27 <HugoDaniel> hmmm
10:01:29 <HugoDaniel> could be yes
10:01:31 <HugoDaniel> :)
10:01:40 <ski> yitz : "we're talking about a very specific monad here" -- it wasn't clear to me zhulikas was doing that
10:01:42 <aristid> HugoDaniel: you could use the fancy new dependent typing features ;)
10:01:46 <ski> (and still isn't)
10:02:07 <ski> (and yes, the environment monad isn't "strict")
10:02:12 <aristid> HugoDaniel: should use at least ghc 7.6 for that to make sense though (DataKinds is really buggy in 7.4)
10:02:19 <aavogt> HugoDaniel: template haskell!
10:02:20 <HugoDaniel> im trying to use peano numbers to do safe bounds indexing checked at compile time
10:02:31 <aristid> aavogt: MUST WE BANISH YOU?!
10:02:41 <tac> HugoDaniel: why peano?
10:03:00 <HugoDaniel> tac is there any other way to ensure at compile that im indexing inside the bounds of a constant list ?
10:03:09 <aristid> tac: because that's easiest without DataKinds i guess :)
10:04:09 <HugoDaniel> it should be easy to generate some butload of classes at compile for each peano number and do some comparison checks
10:04:18 <yitz> beaky: i would probably say "an algorithm is the essence of an approach to implementing a computation".
10:05:24 <yitz> beaky: i think that can be simplified some. but anyway, i don't thing it's essential to think of a computation as being a "process" to talk about an algorithm for it.
10:06:19 <beaky> ah
10:07:06 <yitz> beaky: around here, by "computation" we just mean a mathematical function. usually a concrete one, i.e., one that can be represented as a lambda.
10:07:48 <beaky> ah
10:08:11 <beaky> what  is a lambda?
10:08:34 <beaky> it seems a more general concept than an anonymous function
10:08:47 <yitz> beaky: a lambda expression, from church's lambda calculus.
10:11:01 <beaky> so computation in the lambda calculus is just substituting lambdas?
10:11:26 <parcs> how do i tell ghc to write object and interface files in a different directory?
10:11:47 <yitz> beaky: no not really. being representable as a lambda is the same as being turing computable. but turing's definition talks about a hypothetical "machine" that computes the function, whereas church's definition feels more purely mathematical in nature.
10:11:56 <yitz> beaky: right
10:12:18 <parcs> oh, -hidir and -odir
10:12:48 <BobbyMcLiar> I know I've already asked that question, but how does anyone understand what fmap . fmap means? It breaks my head. I've tried to just apply the definition for fmap, but I seem to get it wrong.
10:13:03 <yitz> parcs: oh nice. i always thought it was "cd to that directory, compile, mv the exe back to the original directory".
10:13:07 <`nand`> BobbyMcLiar: fmap into nested functors
10:13:15 <`nand`> (fmap . fmap) f = fmap (fmap f)
10:13:48 <parcs> BobbyMcLiar: fmap . fmap = \f -> fmap (fmap f) = \f x -> fmap (fmap f) x
10:14:17 <BobbyMcLiar> thanks. I'll try to get my head around that
10:14:25 <yitz> > (fmap.fmap) (*2) [[1,2],[3,4]]
10:14:28 <lambdabot>   [[2,4],[6,8]]
10:14:54 <yitz> > (fmap.fmap) (*2) [Just 1,Just 2,Just 3,Just 4]
10:14:55 <lambdabot>   [Just 2,Just 4,Just 6,Just 8]
10:15:08 <BobbyMcLiar> oh thats cool!
10:15:14 <`nand`> > map (map (*2)) [[1,2],[3,4]]
10:15:15 <lambdabot>   [[2,4],[6,8]]
10:15:17 <beaky> besides turing and church's models of computation, what other models are there?
10:15:49 <opqdonut> post systems
10:15:50 <tromp> cellular automata
10:15:54 <tromp> petri nets
10:15:56 <opqdonut> circuits
10:16:02 <yitz> beaky: haskell curry's combinator calculus
10:16:04 <tromp> billiard-ball
10:16:28 <beaky> wow
10:16:28 <opqdonut> context-aware grammars
10:16:35 <`nand`> sticks and stones
10:16:35 <tromp> cyclic tag systems
10:16:36 <yitz> haskell's type system (with a few invasive ghc extensions)
10:16:36 <opqdonut> various automata
10:16:42 <beaky> what abot von-neumann machines?
10:16:46 <opqdonut> those too
10:16:46 <applicative> > (fmap.fmap.fmap) even [("Hi",Just 1), ("Hello", Just 2)]
10:16:48 <lambdabot>   [("Hi",Just False),("Hello",Just True)]
10:17:21 <applicative> > (fmap.fmap.fmap.fmap) ord [("Hi",Just "Hi"), ("Hello", Just "Hello")]
10:17:23 <lambdabot>   [("Hi",Just [72,105]),("Hello",Just [72,101,108,108,111])]
10:17:36 <`nand`> we need to go deeper!
10:18:11 <applicative> > (fmap.fmap.fmap.fmap.fmap) ord ("Tarantula", [("Hi",Just "Hi"), ("Hello", Just "Hello")])
10:18:12 <lambdabot>   ("Tarantula",[("Hi",Just [72,105]),("Hello",Just [72,101,108,108,111])])
10:18:49 <yitz> *-semirings
10:18:59 <`nand`> :t biplate %~ (fmap ord :: Maybe Char -> Maybe Int)
10:19:00 <lambdabot>     Couldn't match expected type `Char' with actual type `Int'
10:19:00 <lambdabot>     Expected type: Maybe Char -> Maybe Char
10:19:00 <lambdabot>       Actual type: Maybe Char -> Maybe Int
10:19:04 <`nand`> :(
10:19:24 <applicative> > (fmap.fmap.fmap.fmap.fmap.fmap) ord [("Tarantula", [("Hi",Just "Hi"), ("Hello", Just "Hello")]),("Black Widow",[])]
10:19:26 <lambdabot>   [("Tarantula",[("Hi",Just [72,105]),("Hello",Just [72,101,108,108,111])]),(...
10:19:37 <`nand`> oh, biplate can't handle type changes
10:26:57 <frost_> is it correct to define a monad as an abstraction of values in some context that allows you to chain operations on those values?
10:28:14 <frost_> someone asked me to define monads and that was the best I could come up with
10:28:19 <`nand`> that's not a definition
10:28:24 <`nand`> merely a description
10:28:52 <frost_> yeah youre right. is it a correct description?
10:28:53 <`nand`> many things allow you to ‘chain operations’, whatever that means
10:29:08 <`nand`> in fact that sounds more like a Category or Arrow
10:31:10 <frost_> what would be a correct, concise definition of monads
10:31:15 <applicative> if operations are things of type X -> m Y , then maybe?
10:31:15 <`nand`> I don't think it's very feasible to present a mental model of monads that will work for all examples, since they're quite varied
10:31:43 <`nand`> applicative: kleisli composition doesn't give rise to monads
10:31:54 <applicative> it's not enough,
10:32:01 <Philippa> `nand`: for monads-in-FP, embedded languages that support 'simple' let-binding and higher-order computations
10:32:04 <applicative> m X and X -> m Y
10:32:11 <Philippa> (oh, and embed the host language into themselves)
10:32:21 <applicative> the are moggi's 'computations' no?
10:32:31 <`nand`> frost_: “a monad is a monoid in the category of endofunctors” <- correct, concise, and completely incomprehensible :(
10:32:48 <applicative> it means, you can chain them
10:33:06 <frost_> a monad is always a monoid?
10:33:17 <applicative> in the category of endofunctors
10:33:22 <BobbyMcLiar> why does (fmap fmap fmap) (*2) [[1,2],[3,4]] not work?
10:33:26 <oio> how i differentiate between a list [1,2,3,4] and a String "1234"
10:33:38 <`nand`> frost_: it's important not to confuse ‘monad’ and ‘monoid’ with ‘Monad’ and ‘Monoid’ here
10:33:39 <`ramses> frost_: a type constructor with a monoidal character, as in there is a binary operation m m a -> m a
10:33:46 <applicative> > (fmap fmap fmap) (*2) [[1,2],[3,4]
10:33:47 <lambdabot>   <hint>:1:35: parse error (possibly incorrect indentation)
10:33:48 <kennyd> oio they are the same thing
10:33:54 <applicative> > (fmap fmap fmap) (*2) [[1,2],[3,4]]
10:33:56 <lambdabot>   [[2,4],[6,8]]
10:34:04 <`ramses> and some other properties too I think but that's what distinguishes them
10:34:10 <applicative> BobbyMcLiar: it does , no? ^^^
10:34:20 <oio> mmm
10:34:21 <oio> ok
10:34:28 <kennyd> oio oh sorry, they aren't.
10:34:34 <BobbyMcLiar> in ghci it doesn :(
10:34:57 <`nand`> oio: types?
10:35:03 <kennyd> oio one is [Int], other String or [Char]
10:35:08 <`nand`> [1,2,3,4] :: Num a => [a]; "1234" :: String
10:35:09 <Philippa> `nand`: yeah, there's a reason I make the disclaimers I do (which're slightly more general than "I'm talking about Monad", but still)
10:35:34 <applicative> frost, see the discussion at the bottom of http://www.haskell.org/haskellwiki/Monad_Laws for one pleasant monoid-monad connection
10:35:55 <`nand`> Philippa: I'll admit, your definition sounds sound
10:35:59 <`ramses> BobbyMcLiar: does work for me...
10:36:04 <`nand`> it captures, in essence, do notation
10:36:08 <frost_> so Monoid in haskell is not the same as monoid in category of endfunctors?
10:36:28 <oio> omen
10:36:54 <`ramses> frost_: a monoid in general is never the same as a monoid in a specific category
10:37:06 <`ramses> frost_: you're comparing apples and oranges
10:37:39 <oio> Write a function that takes a list and conses 8 on to it.
10:37:44 <applicative> frost_: http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem is fairly lucid
10:37:59 <frost_> that is likely. I only know Monoid as defined by haskell
10:38:20 <applicative> the concept of an X in the category of Y's is a a bit of a trial.
10:38:21 <frost_> thanks for the links I will read them
10:38:27 <oio> Write a function cons8 that takes a list and conses 8 on to it. Anyone?
10:38:38 <oio> Write a function that takes a list and conses 8 on to it.
10:39:10 <yitz> oio: can you write the type?
10:39:23 <Iceland_jack> I'd guess probably not…
10:39:32 <`nand`> Hask is not a category of endofunctors. probably.
10:39:40 <yitz> Iceland_jack: if not, let's start there before we write the function.
10:39:52 <croikle> (:) . unsafeCoerce $ 8
10:39:55 <oio> has to work with numbers boleans list
10:40:06 <Iceland_jack> oio: do you know what “consing” means?
10:40:21 <yitz> oio: wait, did you learn about type signatures yet, or are you just writing functions without them?
10:40:23 <S11001001> oio: where is this question?
10:40:35 <oio> let numbers = [1,2,3]
10:40:45 <illusionoflife> @type id
10:40:45 <oio> 12:numbers
10:40:46 <lambdabot> a -> a
10:40:47 <yitz> @slap croikle
10:40:47 * lambdabot loves croikle, so no slapping
10:41:11 <oio> numbers
10:41:28 <applicative> > let numbers = [1,2,3] in 8 : numbers
10:41:30 <lambdabot>   [8,1,2,3]
10:41:31 <`nand`> cons8 = cons 8 -- what do I win?
10:41:46 <johnw> frost_: a monoid is an entity such that I*X=X and X*I=X, along with an associative operator such that X*X=X'.  The Haskell monoids you're used to apply this to values; a monad applies it to (endo)functors.  So if the functor is M, there is I*M=M and M*I=M (where I is the identity functor, rather than an identity value), and M*M=M', which is what 'join' does.
10:41:48 <yitz> @type cons --sorry `nand`
10:41:49 <lambdabot>     Not in scope: `cons'
10:41:49 <lambdabot>     Perhaps you meant one of these:
10:41:50 <lambdabot>       `BS.cons' (imported from Data.ByteString),
10:42:04 <applicative> > let numbers = [1,2,3] ; cons = (:) ; cons8 = cons 8 in cons8 numbers
10:42:06 <lambdabot>   [8,1,2,3]
10:42:15 <`nand`> yitz: http://ekmett.github.com/lens/Control-Lens-Cons.html#v:cons
10:42:19 <`nand`> blame Cale for not keeping his lens up to date
10:42:29 <yitz> ahhh lens has it. hrmph.
10:42:37 <johnw> is it even possible to keep one's lens up to date? :)
10:42:42 <`nand`> yes
10:42:44 <`nand`> be edwardk
10:42:56 <parcs> "class (Profunctor p, Functor f) => Cons p f s t a b | s -> a, t -> b, s b -> t, t a -> s where"
10:43:03 <`nand`> and all of the other contributors I'm blatantly ignoring. at the same time.
10:43:03 <parcs> nope
10:43:24 <applicative> hm, maybe a script that pulls and unregisters and recompiles ...
10:44:32 <oio> just figured out
10:44:33 <oio> f [] = [8] f xs = 8:xs
10:44:50 <croikle> looks good. you don't even need the base case
10:44:53 <applicative> oio: yes, in this case you can do without the [] pattern
10:45:00 <applicative> as croikle sats
10:45:02 <applicative> says
10:46:04 <oio> how could i differentiate between a list of Booleans and a list of Numbers with Guards
10:46:31 <edwardk> parcs: you don't have to use it
10:46:37 <applicative> oio: you can't
10:46:57 <applicative> oio: unless maybe with type mysticism
10:46:57 <frost_> oio: a function ca only accept one or the other, not both
10:47:11 <`nand`> frost_: sure it can, if it's polymorphic
10:47:15 <applicative> a list of booleans cant start with 8
10:47:19 <edwardk> the Cons class unifies a half dozen copies of _head and _tail that were distributed about the lens package before 3.8
10:47:34 <edwardk> now you can use _head, _tail, cons, uncons on any Cons instance
10:47:40 <beaky> you can use data abstracton
10:47:58 <beaky> Eithre [Num] [Bool]
10:48:01 <beaky> Either*
10:48:04 <frost_> 'nand' typeclass thingies are called polumorphic functions?
10:48:05 <applicative> oio oh I see this is not still the cons8 problem
10:48:11 <edwardk> and the flexibility of p and f there are so you can make things that can only be consed or only be unconsed/_head/_tailed, or for which _head/_tail are lenses not just traversals
10:48:15 <`nand`> typeclasses and polymorphism are orthogonal
10:48:23 <geekosaur> but if you make it polymorphic then you still can't distibguish between particular types
10:48:32 <oio> yeah you cant right?
10:48:45 <oio> 8:[True,False] wont work
10:48:58 <oio> thnx
10:49:02 <applicative> oio, is a result of the form [Left 8, Right True, Right False]  okay?
10:49:10 <`nand`> (unless you hire somebody crazy to write your Num instances)
10:49:13 <geekosaur> (well.  there are ways to do so, but usually if you want to do that you're either marshaling/unmarshaling data for a loosely typed environment, or you're doing something wrong
10:49:19 <ski> oio : why would you want to differentiate between them ?
10:49:37 <ski> oio : iow, why don't you already know which of them you'll pass ?
10:49:38 <frost_> what is for example show called, is it a polymorphic function?
10:49:45 <applicative> instance Num Bool where fromInteger 8 = True
10:49:52 <`nand`> frost_: yes
10:49:58 <oio> lol
10:50:09 <oio> it is not necessary i am just learning
10:50:15 <ski> frost_ : `length :: [a] -> Int' is a polymorphic function, `show :: Show a => a -> String' is a (constrained) polymorphic function
10:50:35 <`nand`> semantics time!  would you call :: forall a. (a ~ Int) => a -> a -- polymorphic?
10:50:45 <applicative> @type fromInteger
10:50:46 <lambdabot> Num a => Integer -> a
10:50:59 <applicative> `nand` yes, everything is polymorphic
10:51:04 <ski> oio : it's not a common thing to actually want. if you want it, you can explicitly tell by `Either' or some other datatype with multiple options
10:51:43 <oio> but iwould make sense to add 8 to a boolean list
10:51:59 <ski> beaky : pedantically, `..Either [Num] [Bool]..' is wrong, possibly should be `Num n => ..Either [n] [Bool]..'
10:52:10 <beaky> ski:  right :D
10:52:15 <ski> oio : usually not
10:52:37 <ski> oio : you're typically using lists when all the elements will be "treated in the same fashion", in some sense
10:52:52 <`nand`> [Num] is a kind error :
10:52:54 <`nand`> :P*
10:53:08 <beaky> is there a special name for functions of the form a -> b ?
10:53:09 <ski> e.g. if you use `last' to extract the last element of a list, it would be awkward if you didn't already know what kind (iow type) of value to expect
10:53:26 <applicative> :k '[Num]    '[Num] :: [* -> Constraint]
10:53:28 <lambdabot> parse error on input `::'
10:53:38 <ski> beaky : every function has a type of form `... -> ...', where `...' abbreviates some types
10:53:41 <`nand`> not the same thing!
10:54:22 <beaky> btw, is main a function?
10:54:22 <ski> oio : in Haskell, all the elements of a given list must therefore have the same type
10:54:58 <`nand`> ‘therefore’ being ‘because it's defined that way’?
10:55:01 <ski> oio : if you really want (say) two differenty types, you can encode this as `[Either Double Integer]' (say) -- so, really, the single type of all elements is not `Either Double Integer'
10:55:18 <ski> beaky : `main' is not a function, it doesn't take an argument
10:55:32 <ski> every function takes (exactly) one argument
10:55:37 <beaky> ah
10:55:56 <oio> yup
10:56:07 <applicative> main is a function in the sense of an operation, which is a distraction around here
10:56:14 <beaky> ah
10:56:40 <ski> oio : there are some rare cases where you could want a list with elements of differing types .. e.g. perhaps first element of type `Integer', next of type `[Integer]', next of type `[[Integer]]', next of type `[[[Integer]]]', &c.
10:57:02 <ski> oio : fortunately, you can encode this kind of thing with a new datatype in Haskell, even though you can't use the ordinary list type for it
10:57:14 <oio> yeah
10:57:49 <justicefries> so, to ask the lion's den...
10:57:57 <justicefries> is there any real advantage to erlang over haskell?
10:57:59 <ski> (unless you make a single type of which an element can be either of type `Integer',`[Integer]',`[[Integer]]',&c. -- but doing this would lose you more type-checking, so i wouldn't do it if i could avoid it)
10:58:28 <ski> justicefries : i think live code update is easy in Erlang
10:58:34 <justicefries> ah that's true.
10:58:37 <justicefries> okay, assuming you don't have those needs.
10:58:38 <qwr> justicefries: can be, when you need something that the erlang runtime does well
10:58:47 <`nand`> data MyList f a = Nil | Cons a (MyList f (f a))
10:58:58 <`nand`> does cloud-haskell have live code update?
10:59:02 <justicefries> I've done cursory stuff with both.
10:59:14 <ski> beaky : `main :: IO Blah' is ususally said to be an (`IO'-)action
10:59:19 <ski> same with
10:59:22 <ski> @type getLine
10:59:23 <lambdabot> IO String
10:59:30 <ski> and @type putStrLn
10:59:37 <ski> @type putStrLn
10:59:38 <lambdabot> String -> IO ()
10:59:54 <ski> is a function that takes a `String' and returns an `IO'-action (with result of type `()'
11:00:00 <ski> , iow "uninteresting")
11:00:48 <`nand`> does erlang have monads?
11:01:11 <beaky> why can't I write a function like \x -> case x of { '0' -> 1; 0 -> '1'; _ -> 0};
11:01:31 <croikle> '0' and 0 aren't the same type
11:01:34 <beaky> ah
11:01:49 <beaky> I thought that was a function a -> b
11:01:58 <shachaf> hi beaky
11:02:03 <beaky> hello
11:02:04 <shachaf> how do you feel about monoids
11:02:12 <beaky> monoids are fun
11:02:22 <shachaf> agreed
11:02:43 <`nand`> croikle: you could still write beaky's function; given a Num Char instance :P
11:02:52 <croikle> yes of course :)
11:03:07 <beaky> so haskell's type system isn't strong enough to write that function?
11:03:19 <croikle> :D
11:03:27 <geekosaur> you could say it's too strong to write that function
11:03:30 <beaky> maybe if I stick an unsafeCoerce here and there
11:03:44 <geekosaur> if you want to write perl, haskell's a poor choice :)
11:03:51 <`nand`> beaky: yes, unsafeCoerce is a good choice here
11:03:53 <parcs> haskell's type system isn't stupid enough to let you write that function
11:03:57 <geekosaur> (nancy typing's always fun :)
11:04:00 <beaky> ah
11:04:08 <parcs> or rather, isn't useless enough
11:04:11 <croikle> http://hackage.haskell.org/packages/archive/acme-php/0.0.1/doc/html/src/Prelude-PHP.html
11:04:16 <beaky> I wanna have associative arrays in haskell
11:04:16 <oio> could someone translate this to the lowet cons notation
11:04:17 <oio> [[1,2,3],[]]
11:04:17 <`nand`> nancy typing?
11:04:31 <beaky> aren't associative arrays basically functions a -> b?
11:04:32 <`nand`> (1:2:3:[]):[]:[]
11:04:39 <oio> [[1,2,3],[]] == [1,2,3]:[]:[]
11:04:53 <yitz> beaky: a -> Maybe b
11:05:02 <oio> lowest i can [[1,2,3],[]] == [1,2,3]:[]:[]
11:05:03 <oio> [[1,2,3],[]] == [1,2,3]:[]:[]
11:05:03 <beaky> ah
11:05:06 <yitz> beaky: see: Data.Map from the containers package
11:05:29 <beaky> I wanna implement something like javascript objects in haskell :D
11:06:08 <oio> but why (1:2:3:[]):[]:[] parenthesis ?
11:06:23 <Peaker> justicefries, Erlang probably has less of a learning curve than Haskell
11:06:30 <jozefg> Is there any standards for how hackage packages should be named?
11:06:39 <jozefg> Peaker: In my experiences it does
11:06:43 <sclv> people tend to use lowercase
11:06:49 <applicative> unsafeCoerce (8::Int) : [True] :: [Bool]      -- [False,True]  but where did 8 go?
11:06:55 <geekosaur> oio:  what do you think it would mean without them?
11:07:28 <ski> oio : `[1,2,3]' is `1:2:3:[]'
11:07:34 <applicative> (8::Int) : unsafeCoerce [True] :: [Int] [8,201327803] -- where did True go?
11:07:42 <sclv> jozefg: and unless you really feel comfortable claiming a super-generic name, you're probably better off with something a bit more distinctive
11:08:07 <oio> (1:2:3:[]):[]:[]
11:08:08 <ion> oio: (((1:(2:(3:[]))):[]):[]) vs. (1:(2:(3:([]:([]:[])))))
11:08:21 <c_wraith> applicative: my head hurts. :)
11:08:22 <ski> oio : without round brackets in `(1:2:3:[]):[]:[]', it'd be `1:2:3:[]:[]:[]', which is desugar for `[1,2,3,[],[]]' (which is almost a type error)
11:08:30 <applicative> fitting your modules with the usual Data. Control. etc. is more trouble, jozefg
11:08:31 <croikle> applicative: hmm, True = 201327803. that's going to be hard to remember
11:08:53 <jozefg> applicative: It's simpler in my case but yeah I could see that for most
11:09:13 <oio> na none explain me that they ask me to make things i dont even know how to
11:09:21 <jozefg> sclv: OK thanks!
11:09:37 * applicative dimly remembers a plan to ban obscene package names but it turned out there were already several
11:10:45 <jozefg> applicative: At least its better than CPAN
11:14:03 <`nand`> applicative: just #define TRUE 201327803 and move on with life
11:14:35 <Guest33055> sorry i
11:14:44 <Guest33055> 've been busy in lessons
11:14:56 <Guest33055> whats going on there?)
11:15:13 * applicative though ghc was doing it for me
11:15:28 <Michael_> If I have a function that takes two functions and a history, and passed the history to those two functions, and then appends the result of each function to the history, how can I make an infinite list out of that? I was thinking of using iterate, or recursion, but I couldn't think of a base case for that recursion
11:15:32 <Michael_> Thanks
11:15:48 * applicative though ghc was defining True as 201327803, that is
11:16:05 <`nand`> GHC wasn't doing that, no
11:16:23 <applicative> Michael_: what's a history
11:16:26 <tac> Michael_: If you have an infinite list, you wouldn't have a "base case" would you?
11:16:32 <applicative> unsafeCoerce (True::Bool) :: Int
11:16:42 <applicative> doesn't unsafeCoerce tell me what things REALLY are
11:17:09 <Michael_> the history is just a list of all the previous iterations. This is what I had at first:
11:17:14 <Michael_> play :: [(Bool,Bool)] -> ([(Bool,Bool)] -> Bool) -> ([(Bool,Bool)] -> Bool) -> [(Bool,Bool)]
11:17:14 <Michael_> play history agent1 agent2  = (agent1 history,agent2 history) : history
11:17:15 <Michael_> playAll :: [(Bool,Bool)] -> ([(Bool,Bool)] -> Bool) -> ([(Bool,Bool)] -> Bool) -> [(Bool,Bool)]
11:17:16 <Michael_> playAll history agent1 agent2 = playAll (play history agent1 agent2) agent1 agent2
11:17:38 <Michael_> but take 10 doesn't work on that, never terminating, nor does first or last
11:17:51 <`nand`> no, unsafeCoerce lets you ignore what things REALLY are
11:18:24 <monochrom> haha
11:19:22 <Michael_> tac: you're correct about the base case though, I was mistaken
11:19:59 <`nand`> playAll never terminates because it immediately recurses into itself unconditionally, without ever producing a value
11:20:32 <Michael_> `nand`: how could I make it produce a value?
11:20:51 <`nand`> by writing something different on the right hand side?
11:20:59 <`nand`> (I'm not quite sure what it is you want to do)
11:22:06 <Michael_> `nand`: I'm sorry if I wasn't clear, I'm a little new to haskell. I essentially want a function like iterate, except it applies the function to the entire list, not just the most recent value. Is that possible?
11:22:08 <applicative> Michael_: maybe this would be easier if the functions were [(Bool,Bool)] -> ([(Bool,Bool)],Bool)
11:23:15 <applicative> michael f g xs = ( f xs , g xs): xs
11:23:26 <c_wraith> couldn't you use scanl for this?
11:24:40 <`nand`> Michael_: so something like :: ([a] -> a) -> [a] -> [a] -- ?
11:24:54 <c_wraith> I guess it'd ignore the input list except for the length, which would be silly with scanl
11:25:17 <c_wraith> `nand`: I think ([a] -> a) -> a -> [a]
11:25:32 <c_wraith> that's more like iterate
11:25:41 <Michael_> `nand`: yeah that's the basic type
11:25:53 <Michael_> c_wraith: iterate may have been the wrong comparison
11:26:16 <`nand`> :t let iterate f xs = let n = f xs in n : iterate f (n:xs) in iterate -- like this?
11:26:17 <c_wraith> This sounds familiar.  Is this one of the standard morphisms?
11:26:17 <lambdabot> ([a] -> a) -> [a] -> [a]
11:26:40 <`nand`> that accumulates the input as you go along, passing it to the function in each turn to produce the next
11:26:57 <`nand`> > let iterate f xs = let n = f xs in n : iterate f (n:xs) in iterate sum [2]
11:26:58 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
11:27:22 <ski> Michael_ : should the first produced element be at the start of, or at the end of, the history list ?
11:28:01 <Michael_> I was using end of, because then I could use :, which is cheaper, but I can easily switch to start if it's better
11:28:18 <ski> should the history list contain all the produced elements, or just the previously computed elements ?
11:29:00 <Michael_> I'm sorry ski, I'm not groking the distinction
11:29:19 <ski> let's say the computed list is `[0,1,2,3,...]'
11:29:28 <ski> and the function argument is `f'
11:30:04 <ski> in the former case, `f' would be called on information representing `[0,1,2,3,...]' (and something more), to compute `3'
11:30:25 <ski> in the latter case, it would only effectively be called on `[0,1,2]' (perhaps with a different ordering)
11:31:00 <pzuraq> is there a way to set the type of a variable in ghci?
11:31:20 <Michael_> ski: thanks for explaining, it should contain the produced elements
11:31:25 <erineh_> so i built a mac binary and it is dynamically linking to readline
11:31:25 <ski> pzuraq : you can say `let foo :: Integer; foo = 42'
11:31:26 <geekosaur> let { f :: Foo; f = ... } -- ?
11:31:33 <erineh_> i figured it would statically compiled
11:32:05 <ski> Michael_ : all of them, or just the ones preceding the currently-to-be-computed element ?
11:32:16 <pzuraq> ahhh
11:32:18 <pzuraq> cool
11:32:33 <`nand`> erineh_: only haskell libraries are statically linked in (by default)
11:32:42 <Michael_> the ones preceding the currently to be computed element
11:32:53 <erineh_> mkay
11:33:34 <ski> pzuraq : if you're not talking about defining a new variable, but using (a say polymorphic) one at some specific type, you can use a type ascription, e.g. like `(read "42" :: Integer) * 2'
11:34:40 <ski> Michael_ : so, what ..
11:34:45 * ski sighs
11:34:48 <pzuraq> hmm, also cool
11:36:37 <notthemessiah> Anyone ever use the Ypnos EDSL? It's for Stencil calculations and uses a comonad. I'd like to know how it does performance-wise.
11:38:21 <tromp> o7 would induce bp6
11:38:28 <tromp> oops; ignore
11:39:05 <notthemessiah> alternatively, there's Paraiso for fluid dynamics, which uses a Builder monad to make parallel code in something like CUDA or MPI, and it's made for performance.
11:44:22 <sclv> nothing i read about ypnos indicated to me that it was anything more than a researchy proof-of-concept
11:44:27 <sclv> but then i didn't read that much on it
11:49:42 <parcs> why is extending atomitcModifyIORef to multiple IORefs problematic?
11:54:05 <glguy> parcs: it's probably must modified by doing an atomic compare/swap on the value stored in the ioref, they probably don't do any locking
11:54:14 * glguy speculates
11:54:48 <RichyB> parcs: because if you modify two different IORefs `a` and `b` with it, it's possible that some other thread might (preempt you and) read the new value for `a` but the old value for `b`.
11:54:50 <sclv> yeah its lockless
11:55:07 <sclv> you can use tvars for the other behavior
11:55:10 <RichyB> You can't do atomic modification of multiple addresses in memory together without using something like STM.
11:55:22 <RichyB> Fortunately, transactional memory solves this problem exactly. :)
11:56:27 <parcs> oh, so that's what "Extending the atomicity to multiple IORefs" means in http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Data-IORef.html#v:atomicModifyIORef
11:56:30 <sclv> the compare-and-swap in question in the ghc primitive: https://github.com/ghc/ghc/blob/45740c29b24ea78b885d3b9f737a8bdc00265f7c/rts/PrimOps.cmm#L364
11:56:31 <srhb> Which brings us back to: Is IORef not simply deprecated in favor of MVars and folk?
11:56:39 <sclv> because IORef is faster!
11:56:55 <sclv> look at that beautiful primop
11:57:00 <srhb> Can't be worth mentioning, can it?
11:57:03 <parcs> i thought it meant that it's problematic to use atomitcModifyIORef on different IORefs in eg separate threads, since it shares a lock or something
11:57:48 <c_wraith> atomicModifyIORef doesn't use a lock
11:58:19 <c_wraith> it's implemented in terms of atomic compare-and-exchange, according to simon marlow's presentation on it
11:58:23 <parcs> right, but that's one way the documentation could be interpreted
11:58:25 <sclv> look at the code i posted
11:58:32 <sclv> it shows exactly the implementation
11:58:53 <monochrom> it could mean two things. one: you do your own locking, therefore you may make mistakes. two: GHC gives you an atomicModifyManyIORefsAtOnce, but this is difficult for them and slow for you
11:59:08 <glguy> or three, use one IORef and a record
11:59:21 <glguy> oh, not that they do that, but you could :)
12:00:51 * monochrom does not make mistakes. therefore, he does his own locking or critical section
12:01:21 <monochrom> putMVar; modifyIORef v1; modifyIORef v2; takeMVar  :)
12:01:53 * monochrom is lazy too, however
12:02:38 <monochrom> therefore, if the job is to "wait until v1>v2, then swap them", I go STM :)
12:06:09 <monochrom> whichever interpretation you take, the conclusion is the same
12:06:55 <parcs> compare-and-swap is like a busy loop
12:07:26 <sclv> no. the loop surrounding cas is a busy loop.
12:10:05 <parcs> oh, right
12:10:48 <parcs> and cas is usually a cpu instruction?
12:12:44 <parcs> CMPXCHG
12:15:27 <c_wraith> yeah, though you need to modify it a bit so that it actually has all the necessary memory barriers to remain coherent on multi-processor systems
12:20:33 <basdirks> what's an example of an invariant in Haskell code?
12:20:51 <k0ral> hello, could you please enlighten me about the ins & outs of using MonadBase IO m rather than MonadIO m ?
12:22:48 * Lethalman fears at everything that mutates something in other languages now... \o/
12:24:24 <ski> basdirks : perhaps some condition which is supposed to hold for all representations of values of a subtype ?
12:24:41 <ski> (such as "this tree is sorted")
12:24:42 <johnw> MonadBase IO m is for any transformer stack that has IO at the bottom
12:25:04 <johnw> MonadIO can be implemented in terms of MonadBase IO
12:25:12 <johnw> it's just more general
12:25:26 <johnw> see http://www.haskell.org/haskellwiki/New_monads/MonadBase
12:26:27 <k0ral> johnw: I saw, but I also read a discussion with brilliant haskellers and it didn't seem MonadBase was such a good thing
12:26:58 <johnw> do you recall why they thought it wasn't?
12:27:20 <k0ral> so I hoped someone could sum it up to me humble leaner
12:27:27 <k0ral> learner*
12:29:20 * hackagebot pipes 3.1.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-3.1.0 (GabrielGonzalez)
12:29:22 * hackagebot pipes-safe 1.0.0 - Safety for the pipes ecosystem  http://hackage.haskell.org/package/pipes-safe-1.0.0 (GabrielGonzalez)
12:35:17 <jerojasro> I installed a package using cabal install ... ; how can I remove it?
12:37:22 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
12:37:29 <monochrom> in fact, see the whole thing
12:38:29 <johnspi> Control.Parallel.Strategies and Control.DeepSeq. Are these two modules the same thing? They seem to export some of the same interfaces, but sometimes they're different. They seem to rely on specific versions of each other. Often I see people import the former when they only use features of the latter (eg http://www.haskell.org/haskellwiki/Timing_computations). Is there some history to this?
12:39:36 <geekosaur> there is, yes.  IIRC the former came first, and deepseq was later abstracted out because it was more general
12:42:58 <johnspi> geekosaur: cheers
12:43:59 <jerojasro> monochrom: "Ignorance is not bliss anymore. You will know. You are forced to know."
12:44:02 * jerojasro shudders
12:44:20 * hackagebot git-annex 3.20130114 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20130114 (JoeyHess)
12:51:07 <johnspi> When I use 10^12 in an expression, I get Defaulting the following constraint(s) to type `Integer' warnings, what is the proper way to write 10^12 and to get an Integer value from it?
12:52:29 <shachaf> By specifying that the type is Integer somewhere.
12:52:37 <shachaf> Alternatively, turning off that warning.
12:54:04 <johnspi> shachaf: i tried that - even this gives me the warnings - http://hpaste.org/80745
12:54:11 <johnw> one way is: default (Integer)
12:54:23 <shachaf> johnspi: The defaulting is on the exponent.
12:54:26 <johnw> ah
12:54:26 <shachaf> @ty (^)
12:54:27 <lambdabot> (Integral b, Num a) => a -> b -> a
12:54:30 <johnw> i'm johnspi now, am I
12:54:45 <shachaf> What?
12:55:03 <johnspi> johnw: what do you mean?
12:55:19 <johnw> oh, haha
12:55:23 <johnw> johnspi is actually in the discussion! sorry
12:55:33 <johnw> usually when people talk to other johns, it's a TAB error
12:55:36 <shachaf> johnw: "default (Integer)" is the default, so that's not any use.
12:55:41 <johnw> shachaf: good to know
12:55:55 <johnspi> shachaf: sorry, can you be more specific, should I put another constraint on the value 12 as well?
12:55:56 <monochrom> shachaf does not make tab errors. he uses spaces. perhaps space errors.
12:57:21 <madjestic> What are currently the best options for FFI Haskell-Python?
12:57:34 <simpson> madjestic: Which direction?
12:57:35 <Taneb> Via C
12:58:05 <johnw> madjestic: there is a GSoC for that: http://hackage.haskell.org/trac/summer-of-code/ticket/1547
12:59:00 <madjestic> simpson: preferably this:  python -> haskell -> python
12:59:04 <oio> is this legal ? f [] = "No list" f xs      | length xs > 5 = "Too short"  f xs = head $ tail $ tail $ tail $ tail $ tail xs
12:59:16 <simpson> madjestic: That sounds a little gnarly.
12:59:24 <srhb> oio: Yikes.
12:59:46 <croikle> probably should be "length xs < 5"...
12:59:49 <simpson> madjestic: I'd probably structure the Haskell as a standalone library, using the FFI to export C symbols out of a shared library.
12:59:51 <monochrom> [] is not "no list"
12:59:55 <simpson> And then load that from Python using ctypes.
12:59:58 <srhb> oio: It's legal if the head of the tail of the tail of the tail of the tail of the tail of xs is a String
13:00:11 <croikle> cadddddr xs
13:00:11 <srhb> But other than that, it's both horrible, wrong and nonsensical. :P
13:00:24 <monochrom> length xs > 5 is not too short. length xs < 5 is
13:00:50 <johnw> madjestic: in brief, it's quite possible (since both Haskell and Python have good C APIs), but it's not going to be direct, you'll need to use C as your lingua franca
13:01:03 <madjestic> simpson: did you try http://thrift.apache.org/ ?
13:02:03 <tromp> :t showIntAtBase
13:02:04 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
13:02:34 <tromp> > showIntAtBase 2 intToDigit 229392 ""
13:02:35 <lambdabot>   "111000000000010000"
13:02:50 <tromp> :t showHex
13:02:51 <lambdabot> (Integral a, Show a) => a -> ShowS
13:03:04 <tromp> > showHex 229392 ""
13:03:05 <lambdabot>   "38010"
13:03:31 <ion> > review (base 2) 229392
13:03:33 <lambdabot>   Not in scope: `base'
13:03:48 <ion> No base in lambdabot’s version of lens yet. :-(
13:03:55 <oio>     Couldn't match expected type `String' with actual type `Char'
13:04:14 <madjestic> johnw: are there any good tutorials/resources/books on the subject that you know of? (other than google)
13:04:21 * hackagebot github 0.4.1 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.4.1 (MikeBurns)
13:04:52 <johnw> madjestic: you mean, of the Haskell FFI?
13:05:28 <oio> could someone fix this for me f xs [] = "Nothing" f xs      | length xs < 5 = "Too short"  f xs = head $ tail $ tail $ tail $ tail $ tail xs
13:05:48 <Botje> oio: might want to look at the "drop" function.
13:06:36 <madjestic> johnw: yes, Ideally a tutorial, showing a basic example of hooking up haskell to python through c, or equivalent
13:06:40 <oio> the 'joke' is to use only head and tail
13:06:55 <johnw> madjestic: ah, for that I know of none; google might be able to help
13:07:24 <Botje> oio: oh, in that case.
13:07:33 <monochrom> who required you to use only head and tail? he/she must be still living in the 1970s, when pattern matching did not exist.
13:07:35 <Botje> oio: you probably meant f [] = "Nothing"
13:07:43 <Botje> instead of f xs [] = ...
13:07:48 <oio> yes that
13:07:54 <oio>     No instance for (Num [Char]) when fixed
13:07:59 <Botje> oio: note that returning "Nothing" in this case restricts the type of your input to [String]
13:08:10 <Botje> (and your output to String, or [Char])
13:08:26 <Botje> oio: for such partial functions it's common to use the error function
13:08:27 <Botje> :t error
13:08:29 <lambdabot> [Char] -> a
13:08:43 <madjestic> it seems that if Haskell community ever wants to see haskell used more in a production environment, areas like FFI are essential, do not you think?
13:08:49 <Botje> so f [] = error "List is empty"
13:09:02 <croikle> much better
13:09:03 <johnw> madjestic: you mean, cross-language production environments?
13:09:11 <madjestic> johnw: yes
13:09:23 <johnw> we're using Haskell in a production environment just fine... by only using Haskell
13:10:04 <ciaranm> i'm trying to use haskell with c++ the wrong way around. and it is painful.
13:10:21 <oio> Botje: same
13:10:25 <madjestic> johnw: what I also mean is that for an average company haskell would be a new, exclusive entity.  Availability of ingeration tools is essential for Haskell to succeed in penetrating the established market
13:10:33 <Lethalman> johnw, for what?
13:10:38 <monochrom> FFI is essential. we have good FFI to/from C. that is essential.
13:11:00 <johnw> Lethalman: FP Complete's upcoming learning/development environment
13:11:08 <monochrom> FFI to/from n different languages is unrealistic
13:11:33 <johnw> yes, look at swig; if FFI(n) were that important, swig would be more important
13:12:04 <madjestic> johnw: you are most likely a new company.  An established business with 300+ employees with a pipeline built around C++, C#, Python and alike can not magically switch to Haskell.  That is the reality.
13:12:27 <johnw> madjestic: I'd say that is a problem for time to resolve, not Haskell
13:12:33 <oio> head returns Char
13:12:39 <johnw> Ruby's lack of interoperability with Python never hurt it's adoption
13:13:03 <madjestic> monochrom: I hope there is a good FFI.  However it needs to be better covered.  It's, judging from the scarcity of data, not the best covered topic on Haskell
13:13:20 <johnw> plus, I'd think a JVM/.NET bridge is much higher on the importance scale than a Python one
13:14:12 <madjestic> johnw: time.  It could be C# or Python FFI - it does not matter that much.
13:15:06 <madjestic> anything that can help make haskell easy to use in a foreign non-haskell environment.
13:15:36 <ciaranm> interoperating with python is generally painful, given python's utter inability to be used with threads
13:15:53 <madjestic> ciaranm: you do not need threads all the time
13:15:59 <ciaranm> madjestic: heretic.
13:16:21 <Dashkal> I think I'd be more likely to try that interface over http/localhost than via direct calls.
13:16:21 <Botje> oio: did you also fix the length case in a similar way?
13:16:27 <beaky> how do I interleave two lists together?
13:16:33 <monochrom> you need one of these "all the time": threads or select/poll
13:16:36 <oio> f [] =  "Nothing" f xs      | length xs < 5 = "Too short"  f xs = show $ head $ tail $ tail $ tail $ tail xs
13:16:36 <Botje> oio: if you supply a type signature for your f ghci will tell you where it's wrong.
13:16:54 <Botje> oio: yes, you need to use the error function if you want to provide meaningfull errors there.
13:16:58 <beaky> like [1,2,3] `interleave` [-1,-2,-3] -> [1,-1,2,-2,3,-3]
13:17:01 <monochrom> perhaps python encourages you to go select/poll. but haskell (at least GHC) encourages you to go threads
13:17:04 <beaky> :t interleave
13:17:05 <lambdabot> MonadLogic m => m a -> m a -> m a
13:17:09 <beaky> woah
13:17:22 <Botje> as I told you above; f [] = error "Nothing" , and similarly for the case where length < 5
13:17:29 <beaky> > interleave [1..3] [-1,-2..-3]
13:17:30 <lambdabot>   Not in scope: `..-'
13:17:34 <ciaranm> well python doesn't support parallel computation... so threads and select are basically the same there
13:17:36 <beaky> > interleave [1..3] [-1,-2,-3]
13:17:36 <monochrom> my solution is to go unsafeInterleaveIO :)
13:17:38 <lambdabot>   [1,-1,2,-2,3,-3]
13:17:42 <beaky> wow it works!
13:17:54 <beaky> thanks
13:17:59 <johnw> madjestic: i don't deny that it would help Haskell's uptake today, I'm just saying that prioritizing backwards capability has never been the best road to improving technology, so I'm not ready to accept that it's something Haskell needs to care about more than it already does
13:18:02 <beaky> btw what is MonadLogic
13:18:10 <ciphergoth_> In the list monad, I'm about to write something like foo <- [false, true]; if foo...
13:18:16 <ciphergoth_> is there a better way?
13:18:18 <beaky> @src interleave
13:18:18 <lambdabot> Source not found. There are some things that I just don't know.
13:18:34 <monochrom> anyway, I like johnw's Ruby counterexample
13:18:39 <ion> ciphergoth: What follows that?
13:18:40 <johnw> ciphergoth_: that's one of the prototypical uses of the list monad!
13:18:54 <ski> @let infixr 5 /\/; (/\/) :: [a] -> [a] -> [a]; [    ] /\/ ys =     ys; (x:xs) /\/ ys = x : ys /\/ xs
13:18:56 <lambdabot>  Defined.
13:18:59 <monochrom> hell, even Java. Java adoption went well without FFI to/from python, haha
13:19:15 <ski> > [0,1,2,3] [-1,-2,-3]
13:19:17 <lambdabot>   The function `[0, 1, 2, 3]' is applied to one argument,
13:19:17 <lambdabot>  but its type `[t0]...
13:19:21 * hackagebot hgdbmi 0.2 - GDB Machine Interface: program-driven control of GDB  http://hackage.haskell.org/package/hgdbmi-0.2 (AlexanderBernauer)
13:19:24 <ski> > [0,1,2,3] /\/ [-1,-2,-3]  -- sorry
13:19:26 <lambdabot>   [0,-1,1,-2,2,-3,3]
13:19:33 <cglazner> i have a script to launch ghci in a new terminal window, but it fails if i instead use 'cabal-dev ghci'
13:19:39 <beaky> ah thanks
13:19:49 <beaky> :t (/\/)
13:19:50 <lambdabot> [a] -> [a] -> [a]
13:19:51 <cglazner> does anyone know how to get cabal-dev ghci to behave the same as regular ghci?
13:19:55 <Leif_Bork> Hi! I have an IO question, I'll hpaste it.
13:19:55 <hpaste> “Biff 5.0” pasted “IO question” at http://hpaste.org/80746
13:20:07 <beaky> @src (/\/)
13:20:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:20:21 <ski> beaky : i defined it above
13:20:26 <beaky> ah thanks
13:20:42 <ciphergoth_> ion: want to do something like (x,y) <- [(a,b), (b,a)]; guard y<lim; return (x,y)
13:20:58 <beaky> /\/ is a neat notation
13:21:18 <ski> beaky : iirc, i saw it in "Haskell: The Craft of Functional Programming"
13:21:28 <ion> ciphergoth: guard (y<lim)
13:21:53 <ciphergoth_> ion: I always get that wrong!
13:21:56 <ciphergoth_> with return too
13:21:57 <ciphergoth_> thanks
13:22:14 <ion> ciphergoth: Space (function application) has the highest precedence.
13:22:15 <ski> > fix ((0 :) . tail . \ns -> ns /\/ map succ ns)
13:22:17 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
13:22:24 <eevar> http://pastebin.com/ZCVDU6H7 - should I try to rewrite the getMessages function into something non-recursive? any pointers on how?
13:22:29 <mauke> The paste ZCVDU6H7 has been copied to http://hpaste.org/80747
13:22:40 <ski> > fix (\ns -> repeat 0 /\/ map succ ns)
13:22:42 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
13:24:06 <ski> > map (fix (\loop n -> if odd n then 0 else 1 + loop (n `div` 2))) [1 ..]
13:24:07 <lambdabot>   [0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,...
13:24:14 <ciphergoth_> ion: meaning it always binds most tightly
13:24:59 <ski> > map (fix (\loop n -> case n of 0 -> 0; n -> n `mod` 2 + loop (n `div` 2))) [0 ..]
13:25:00 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
13:25:26 <oio> how would be the type of a function that could return a Char or a String ??
13:25:37 <geekosaur> it wouldn't, usually
13:25:48 <ion> oio: For what purpose?
13:25:54 <oio> f [] =  "Nothing" f xs      | length xs < 5 = "Too short"  f xs = head $ tail $ tail $ tail $ tail xs
13:25:59 <oio> head returns Char
13:26:26 * geekosaur *ow*
13:26:30 <Clint> is xs a string?
13:26:39 <oio> yes
13:26:42 <ion> oio: Either is typically used to distinguish error information from normal results. f :: [a] -> Either String a
13:28:01 <oio>     Couldn't match expected type `Either [Char] a'
13:28:15 <ion> Use the Left/Right data constructors.
13:28:16 <ion> @src Either
13:28:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:28:26 <ion> data Either a b = Left a | Right b
13:28:59 <hpaste> glguy pasted “function for oil” at http://hpaste.org/80748
13:29:54 <hpaste> “☃” annotated “function for oil” with “function for oil (annotation)” at http://hpaste.org/80748#a80749
13:29:57 <ski> @let oio [           ] = Left  "Nothing"; oio (_:_:_:_:x:_) = Right x; oio  _            = Left  "Too short"
13:29:58 <lambdabot>  Defined.
13:30:20 <oio> 'joke is to use head n tail'
13:30:32 <ion> That joke sucks.
13:30:40 <oio> also i could do show on head
13:31:06 <shachaf> head and tail are bad functions.
13:31:24 <shachaf> They'll crash your program if yo use them on an empty list.
13:31:40 <ski> .. s/crash/abort/
13:31:57 <oio> i am not getting this etoher thing
13:31:58 <oio>   f :: [a] -> Either String b = Left a | Right b f [] =  "Nothing" f xs      | length xs < 5 = "Too short"  f xs = head $ tail $ tail $ tail $ tail xs
13:32:02 <oio> *either
13:32:27 <ion> Look at the paste.
13:32:31 <ski> oio : itym `f :: [a] -> Either String a'
13:32:34 <beaky> is there an fmap defined for functions? something like (a -> b) -> (a -> c) -> (b -> c)?
13:32:45 <ion> beaky: yes
13:32:46 <beaky> oh, (.)
13:33:02 <beaky> ah
13:33:04 <ciaranm> something like, but not
13:33:04 <ski> beaky : except that's the wrong way around
13:33:22 <ski> it should be `(b -> a) -> (a -> c) -> (b -> c)'
13:33:35 <oio> f :: [a] -> Either String a
13:33:37 <ion> @type fmap `asTypeIn` \fmap -> fmap undefined (undefined :: a -> b)
13:33:38 <lambdabot> (a -> b) -> (a1 -> a) -> a1 -> b
13:33:44 <beaky> so functions are functors :D
13:33:47 <ski> (or `(a -> b) -> (c -> a) -> (c -> b)', if you wanted to map over the result, rather than over the argument)
13:33:52 <oio>  String a'                 with actual type `[Char]'
13:33:54 <ion> beaky: Also applicative functors and monads.
13:34:06 <ski> beaky : no, `(rho ->)', for any (concrete) type `rho', is a functor
13:34:53 <ski> beaky : `not' (an example function) is not a functor, not are the types `(->)' or `Bool -> Bool' (typically) considered functors
13:35:06 <ski> s/not are/nor are/
13:35:23 <oio> Couldn't match expected type `Either String a'                 with actual type `[Char]'     In the expression: "Nothing"     In an equation for `f': f [] = "Nothing"
13:35:25 <madjestic> johnw: I do not mean backwards compatibility.  I am talking about a well developed FFI infrustructure, essential for any non-native language existence in a foreign environment.
13:35:48 <ciaranm> madjestic: no-one else has one of those...
13:35:54 <ion> oio: See the paste.
13:37:29 <blackdog> hey all. anyone got some experience with SYB? I have this code in Hubris: https://gist.github.com/4533765 and it seems like it could be folded into a more general form over all tuples.
13:37:43 <madjestic> ciaranm: C# and Python work together quite well
13:38:07 <ski> oio : write `Left "Nothing"', not just `"Nothing"'
13:38:17 <fragamus> I wrote a simple program and it eats memory in astonishing amounts
13:39:06 <Saizan> blackdog: probably best to go TH
13:39:29 <blackdog> Saizan: was hoping to avoid it - why do you think SYB is a bad way to go?
13:39:36 <glguy> fragamus: well done
13:39:38 <oio> only use head tail
13:39:46 <fragamus> funny
13:39:49 <blackdog> (forgive the unsafePerformIOs littering the code, i need to clean that up)
13:39:55 <fragamus> my program sucks
13:40:01 <fragamus> and not well
13:40:25 * ski . o O ( `data Vel a b = Sinister a | Dexter b' )
13:40:34 <blackdog> fragamus: it's easy to write code in haskell that has poor memory usage characteristics - it's a skill to be learned. got a gist?
13:40:52 <fragamus> gist?
13:41:00 <ski> @wn gist
13:41:00 <lambdabot> *** "gist" wn "WordNet (r) 3.0 (2006)"
13:41:00 <lambdabot> gist
13:41:00 <lambdabot>     n 1: the central meaning or theme of a speech or literary work
13:41:00 <lambdabot>          [syn: {effect}, {essence}, {burden}, {core}, {gist}]
13:41:00 <lambdabot>     2: the choicest or most essential or most vital part of some
13:41:02 <lambdabot> [6 @more lines]
13:41:42 <ciphergoth_> fragamus, ski, guess you mean this?
13:41:43 <ciphergoth_> http://hpaste.org/new/haskell
13:41:52 <ion> @google gist
13:41:54 <lambdabot> https://gist.github.com/
13:42:06 <ciaranm> the world's second most annoying pastebin
13:42:10 <blackdog> sorry, hpaste is probably more idiomatic here :)
13:42:16 <Lethalman> ciaranm++
13:42:23 <fragamus> well I am generating random numbers and also hashing
13:42:29 <fragamus> cryoto stuff
13:42:57 <fragamus> I have a lot of pinned memory
13:43:03 <ion> ciaranm: What’s a better one (that supports updating pastes obviously)?
13:43:04 <ski> ciphergoth_ : i'm not sure what blackdog meant
13:43:08 <Saizan> blackdog: because with SYB you'll still have to declare each instance manually, unless you want to have a catch-all one, which is bad
13:43:18 <ciaranm> ion: anything that isn't pastebin.com!
13:43:33 <ski> ion : annotations aren't good enough ? :)
13:43:33 <ciaranm> every time someone sends me a gist i find they've moved the "download whole paste" link
13:43:35 <ion> (and multiple files)
13:43:42 <ion> ski: Indeed, they aren’t. :-)
13:43:44 <ciaranm> last time i went there it was disguised as an unprintable unicode character
13:43:52 <blackdog> Saizan: hm, ok. why is the catch-all bad?
13:44:01 <ciphergoth_> ciaranm, shades of the planning dept in HHGG
13:45:22 <Saizan> blackdog: ugly type errors, possibly different behaviour for the same type in different scopes
13:46:33 <neutrino> gist is super-annoying
13:46:36 <Saizan> blackdog: maybe you should use the (relatively) new Generics extension though
13:47:09 <ion> Gist is, like, one of the least annoying pastebins.
13:47:46 <blackdog> Saizan: ok, i'll have a look. my haskell is still relatively Haskell98, i need to start looking into the more sophisticated stuff :) THanks!
13:49:13 <hiptobecubic> ciaranm, there's always raw
13:51:46 <tomh> hey guys, I'm trying to use the -i option to add my directory "src" as search path for the ghc command, am I using the wrong argument for this, because it doesn't work
13:52:00 <acowley> don't put a space between the "-i" and "src"
13:52:49 <tomh> ah ok
13:53:24 <tomh> yeah that seems to work, bit confusing since other things work with a space ;/
13:55:13 <yitz> > (0:).fix$(1:).(=<<)((:)<*>pure.(+1))
13:55:14 <lambdabot>   [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,...
13:56:36 <glguy> tomh: in *nix the space after the flag is only optional when the argument isn't optional
13:58:21 <blackdog> hey, is https://gist.github.com/4533863 a well-known pattern? (poorly named, perhaps, but it appears to crop up a lot in this section of my code)
13:58:50 <jerojasro> anybody here has worked with repa (and repa-devil) recently? I'm getting terrible performance, even with the examples available in the haskell wiki
13:59:09 <jerojasro> and all the hints about optimization are geared towards repa 2 ...
13:59:22 * hackagebot nsis 0.2 - DSL for producing Windows Installer using NSIS.  http://hackage.haskell.org/package/nsis-0.2 (NeilMitchell)
13:59:24 * hackagebot linear 0.6.1 - Linear Algebra  http://hackage.haskell.org/package/linear-0.6.1 (AnthonyCowley)
14:01:38 <tomh> glguy: ah ok makes sense then
14:03:33 <parcs> it would be nice if you can do 'do { foo :: MVar Int; foo <- newEmptyMvar; ... }'
14:04:16 <acowley> tomh: I make that typo all the time
14:04:56 <monochrom> an extension allows (foo :: MVar Int) <- newEmptyMVar, and I forgot which extension, and I forgot whether you need the parentheses
14:05:27 <glguy> You can always write : foo <- newEmptyMVar :: IO (MVar Z)
14:05:53 <glguy> I'd love to have partial, explicit type signatures: foo <- newEmptyMVar :: _ (MVar Z)
14:06:19 <monochrom> in fact, you want _ (_ Z)
14:06:29 <parcs> _ _ _ Z
14:06:30 <glguy> How do *you* know what I want? :)
14:06:37 <ciaranm> i'll tell you what you want
14:06:41 <ciaranm> what you really really want
14:06:50 <monochrom> by a prediction heuristic
14:07:00 <acowley> I don't think that's the right lyric
14:07:28 <parcs> glguy: that'd be awesome
14:08:16 <yitz> @type \g f -> g >>= (>>) <$> f <*> return -- blackdog, just joking :)
14:08:17 <lambdabot> Monad m => m b -> (b -> m a) -> m b
14:08:38 <monochrom> haha
14:09:09 <hughfdjackson> for the sake of practice, and to do something simple and familiar, what's the easiest HTTP server & database to get set up on in haskell-land?
14:09:18 <hughfdjackson> i'm considering snap and yesod for the server-side of things
14:09:47 <yitz> hughfdjackson: yesod runs its own server if you want. so that's easiest - do nothing.
14:10:11 <yitz> hughfdjackson: yesod likes postgresql best for the database
14:11:08 <hughfdjackson> :) thanks yitz
14:11:27 <parcs> happstack + sqlite-simple
14:11:32 <yitz> hughfdjackson: for higher load applications, it also automatically reverse-proxies from nginx
14:11:33 <hughfdjackson> as an aside, i take it there's less love for 'store json as documents' style database in the non-dynamic world?
14:12:09 <hughfdjackson> :p there's no chance of this being higher load; i just want to do something simple and RESTfulish to get my head around haskell in practical applications a bit better
14:13:00 <yitz> hughfdjackson: dunno. people played around with json dbs a lot when it was hot. doesn't seem to be as hot anymore in general now that it's not the latest buzz anymore.
14:13:53 <hughfdjackson> that may well be the case :D
14:16:35 <Leif_Bork> Has anyone used Data.Iteratee?
14:17:24 <glguy> Leif_Bork: Just ask your question and if someone knows the answer he'll help you.
14:17:58 <Leif_Bork> http://hpaste.org/80746
14:18:34 <blackdog> yitz: cheers, that's much more illuminating :P
14:18:48 <yitz> blackdog: ;)
14:22:11 <SoleSoul> Hi. Does anybody know how to run yi on linux with a GUI?
14:30:42 <SwashBuckla> On Ubuntu 12.04, is there a recommended way to completely remove all traces of Haskell from you computer? I have broken it horribly, and want to reinstall it so I can use XMonad again :>
14:31:50 <ion> rm -fr ~/.ghc ~/.cabal and uninstall any Haskell system packages
14:31:52 <yitz> SwashBuckla: how did you install it to begin with?
14:32:42 <SwashBuckla> yitz: I installed ghc with aptitude, but also quite a few packages via cabal
14:33:16 <SwashBuckla> uninstalling and then reinstalling has errors persist even though the same XMonad configuration works on a fresh install on another computer of mine
14:33:23 <yitz> SwashBuckla: so get rid of all of those first using aptitude. then do what ion said.
14:34:52 <yitz> SwashBuckla: i wish i could use aptitude on my precise. the stupid multiarch bug that they still have patch is such a pain.
14:35:05 <yitz> *haven't
14:35:56 <yitz> SwashBuckla: did you apply the debian patch or something? or perhaps you have a 32-bit-only precise?
14:36:24 <rio> how would i define a type that represents integers mod n?
14:36:37 <SwashBuckla> I have the 64-bit one. no debian patch though
14:36:51 <SwashBuckla> s/though//
14:37:06 <yitz> SwashBuckla: so doesn't aptitude constantly offer to delete half of your packages for you?
14:37:43 <yitz> SwashBuckla: or you disabled multiarch?
14:37:54 <johnw> If there are any Emacs users here, you might enjoy: https://github.com/jwiegley/haskell-config/blob/master/helm-hoogle.el
14:38:16 <johnw> makes querying hoogle from Emacs, and refining the results set, quick and easy
14:38:59 <glguy> rio: There was a neat way to implement that type presented in this paper: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
14:39:02 <yitz> johnw: thanks for sharing that. sounds like fun.
14:39:13 <glguy> They also talked about some of the less ideal, but more traditional alternatives
14:39:26 <rio> glguy: thank you very much
14:40:10 <yitz> glguy: hey cool reference! i've implemented that the hard way countless times.
14:40:23 <oio_> could someone explain the diffrence between (.)  ($)
14:40:51 <johnw> (f . g) x = f (g x) = f $ g $ x
14:40:58 <johnw> . composes two functions, making a new function
14:41:07 <johnw> $ is the low-precendence function application operator
14:41:17 <monochrom> (.) and ($) are incomparable
14:41:20 <glguy> rio: and you don't have to reimplement that paper, it looks like. http://hackage.haskell.org/package/reflection
14:42:34 <yitz> monochrom: they are interchangable for all except the last one. but only if you interchange all of them at once.
14:43:04 <SwashBuckla> yitz: yes I think I have disabled multiarch
14:43:06 <oio> input = (unwords . reverse . words) input is equal to unwords $ reverse $ words input
14:43:14 <monochrom> the "but only if" shows that they are not interchangeable afterall
14:43:36 <yitz> SwashBuckla: ah ok. makes sense. well, they're going to backport the patch to precise "any day now". sigh.
14:43:41 <glguy> rio: if you want to make the type for a fixed 'n' you don't need the trickery
14:43:59 <yitz> monochrom: so does the "except the last one".
14:44:01 <rio> glguy: thats exactly what i don't want though ;)
14:44:25 <rio> @type (.)
14:44:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:44:29 <rio> @type ($)
14:44:30 <lambdabot> (a -> b) -> a -> b
14:44:39 <glguy> rio: lambdabot is broken, (.) doesn't have that type on your computer, fyi
14:44:41 <yitz> @type (Prelude..)
14:44:42 <lambdabot> (b -> c) -> (a -> b) -> a -> c
14:44:48 <rio> glguy: noticed that
14:44:50 <rio> (.) :: (b -> c) -> (a -> b) -> a -> c
14:44:58 <rio> right
14:45:09 <monochrom> "(+) and (*) are interchangeable, but only like 2+2 <-> 2*2"
14:46:05 <glguy> monochrom: lots of operators seem to behave the same when applied to undefined
14:46:11 <glguy> maybe there's a lot more fixing to do
14:46:46 <yitz> glguy: yes lots of operators behave the same when applied to fix, too
14:46:56 <monochrom> haha
14:48:14 <johnw> and 0+0 <-> 0*0 :)
14:48:37 <shachaf> But 0^0 /= 0*0
14:48:49 <johnw> you've got me there
14:48:50 <monochrom> yeah, was going to cite 2^2 too :)
14:49:03 <monochrom> "isn't math exciting!"
14:49:05 <johnw> and 2 is prime too, a very cool number
14:49:13 <shachaf> The only even prime!
14:49:24 <shachaf> (That mathematicians have discovered so far.)
14:49:28 <johnw> but not even the only prime!
14:49:28 <monochrom> 41 is the only prime divisible by 41
14:49:42 <sipa> shachaf: i disagree; -2 is also an even prime :p
14:49:48 <rio> and 42 is not a prime at all
14:49:53 <yitz> x*y+z == x+y*z. but only if either y==1 or x==z.
14:49:59 <dmwit> ew, -2 is not a prime
14:50:14 <dmwit> I'll take unique factorizations for 300, please!
14:50:21 <ciaranm> a prime number is one with four distinct integer divisors
14:50:22 <monochrom> -2 is a prime if you go ring theory
14:50:34 <rio> dmwit: unique up to association
14:50:46 <monochrom> which is what rio says
14:52:07 <monochrom> "unit" = has reciprocal, e.g., 1 and -1.  "x is an associate of y" = (x = (some unit)*y), e.g., 2 = (-1)*(-2)
14:53:10 <monochrom> see my http://www.vex.net/~trebla/numbertheory/primes.html and http://www.vex.net/~trebla/numbertheory/gaussian.html
14:53:58 <dmwit> neat!
14:54:29 <ciaranm> now try finding the prime ideals of Z
14:54:31 <ciaranm> and cry
14:54:35 <yitz> hi dmwit. did you ever solve that trac issue?
14:56:01 <dmwit> yitz: No, I haven't looked deeply yet. The logs I thought would help are empty, so I'm going to have to find out what Trac really does.
14:56:23 <dmwit> Well, to be clear: I've solved the permissions problem, but not the email problem.
14:56:32 <yitz> monochrom: you picked 41 for your example. that's an interesting prime.
14:56:46 <tempdos> Hello
14:56:49 <yitz> dmwit: ah ok, progress at least :)
14:57:45 <rio> yitz: whats the smallest non-interesting prime?
14:57:54 <dmwit> yitz: Oh, and also I tested that the SMTP servers are working and the user Trac runs as can send email through them (by speaking SMTP at the server myself).
14:58:02 <yitz> monochrom: it's the smallest non-square integer that has a 10-adic square root
14:58:34 <yitz> rio: oh, they're all interesting, really. especially since rsa came out.
14:58:48 <dmwit> rio: That's easy, the second-smallest non-interesting prime is the smallest interesting prime.
14:59:04 <dmwit> uh
14:59:10 * dmwit fails at jokes
14:59:13 <yitz> dmwit: ok that's good news. so it really is a trac issue, not a server issue.
14:59:22 <dmwit> right
14:59:47 <ciaranm> 65537 is the last interesting prime
15:00:21 <parcs> what is the most interesting prime?
15:00:33 <tromp> 2
15:00:55 <ciaranm> 2
15:00:56 <simpson> ciaranm: Oh, I read that as "least" and was puzzled by that statement.
15:01:23 <monochrom> 31337 is an elite prime
15:02:19 <monochrom> 65537 is the most popular exponent among RSA users
15:02:41 <johnw> is ∞ divisible by itself?  and if so, and it's not divisible by any other natural number, then is it prime?
15:03:07 <parcs> quick, write a paper!
15:03:08 <ciaranm> johnw: which one?
15:03:12 <shachaf> It is a type error to say "divisible by any other natural number".
15:03:25 <johnw> ah, that's true
15:03:47 <nathanfh> shachaf put it better than I was about to.
15:04:16 <ciaranm> you know... if you take your category to be the version of Hask where _|_ is included... then infinity is a natural number
15:04:50 <monochrom> is ⊥::Integer a prime?
15:05:05 <sclv> wait, infinity should be divisible by lots of numbers!
15:05:17 <sclv> all of them, even
15:05:23 <shachaf> Even 0.
15:05:24 <ciaranm> monochrom: well it doesn't have any divisors...
15:05:28 <shachaf> "the best number to be divisible by"
15:05:34 <sclv> infinity / 2 = infinity
15:05:35 <ciaranm> but then, it's not divisible by 1 either
15:05:36 <aristid> monochrom: the answer to this question is ⊥
15:05:36 <sclv> hello people
15:05:43 <yitz> > let isPrime p = all ((/=0).(p`mod`)) $ 2 : [3,5..floor.sqrt$fromIntegral p] in show (head $ filter isPrime [2^64,2^64-1..]) ++ " is now the last interesting prime"
15:05:46 <lambdabot>   mueval-core: Time limit exceeded
15:05:48 <johnw> sclv: hello person
15:05:49 <monochrom> I agree! :)
15:05:50 <yitz> aww
15:06:18 <hpaste> SwashBuckla pasted “Could not find module `XMonad.Util.EZConfig'” at http://hpaste.org/80752
15:06:34 <shachaf> @google XMonad.Util.EZConfig
15:06:36 <lambdabot> http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Util-EZConfig.html
15:06:36 <lambdabot> Title: XMonad.Util.EZConfig
15:06:47 <shachaf> xmonad-contrib-0.11: Third party extensions for xmonad
15:06:52 <shachaf> Do you have that installed?
15:07:08 <shachaf> Also, there's a channel for xmonad, #xmonad
15:07:13 <SwashBuckla> oh, thanks
15:09:21 <SwashBuckla> shachaf: it is working now ;)
15:48:36 <acowley> Is there a sane way to get the linker flags I need to give g++ or clang++ when linking a shared library produced by GHC?
15:49:48 <monochrom> add -v to your ghc command line to discover them. if -v is not enough, -v2, -v3...
15:56:38 <acowley> monochrom: thanks, but will that only work when ghc is being used to link?
15:58:06 <geekosaur> if you're not using ghc to link, the link will probably fail...
15:59:42 <drkk> :q
16:01:10 <geekosaur> acowley, -v will cause gcc / g++ to tell you what it's doing.  in thios case it won't help because it has no idea what to look for.  you'll need to link with ghc once at least to find out what it adds, then copy that into whatever link line you're using.  but the correct way to do it is use ghc for the final link
16:01:24 <acowley> geekosaur: why? I'm building a C++ application with g++ and linking in some Haskell code. The awkwardness I want to improve is the need to pick out a ton of linker flags manually in the Makefile.
16:01:26 <acowley> oops
16:01:35 <acowley> messages passing in the night
16:01:38 <geekosaur> you also need to link in the GHC runtime
16:01:42 <geekosaur> among other things
16:01:57 <geekosaur> it's more than just options, it's libraries
16:01:59 <acowley> Yes, I'm trying to avoid using GHC for the final link
16:02:06 <geekosaur> (which are linked as .o files)
16:02:17 <acowley> Well, mine are linked as .dylib files
16:02:34 <geekosaur> my understanding is that it *is* possiuble to do that but the details may vary between ghc versions
16:02:50 <geekosaur> you really really should find a way to use ghc for the final link, or you are asking for misery
16:03:02 <simpson> Before I spend an afternoon duplicating effort, is there a quality implementation of continued fractions with a Num instance yet?
16:03:18 <acowley> geekosaur: Asking non-Haskellers to use ghc is asking for misery, too
16:03:47 <acowley> geekosaur: What I want is something like pkg-config for a Haskell package that spits out the necessary linker flags
16:04:23 <geekosaur> you can pull that out of the package.conf.d entry for the package.  I don't think that ywill get you the necessary stuff to link in the GHC runtime though
16:04:37 <gertc> i use this package https://github.com/jaspervdj/websockets/blob/master/src/Network/WebSockets/Monad.hs but how can i add deriving (Eq) to the newtype Sink or create a Eq instance in my code using this package?
16:04:38 <acowley> If the rts is the only one I need to manage manually, that's not so bad
16:05:16 <geekosaur> again, you will need to link *once* using ghc and copy out the flags it uses into your Makefile
16:05:30 <geekosaur> and make certain that exactly the same libraries etc. are present on the target system
16:06:09 <gertc> currently is just fork the code and modify it, but then it only work on my pc :)
16:06:12 <blackdog> acowley: i did something like that to get Hubris running. it was a major pain in the arse.
16:06:21 <geekosaur> which probably means copying them into whatever you are trying to build
16:06:41 <acowley> My immediate need is making a build system that won't scare a couple other developers. Some Makefile hackery to call out to shell would go unnoticed, but demanding that they link with GHC will ruffle feathers.
16:07:04 <acowley> blackdog: I come back to this problem every 6 months or so to see if the pain has decreased.
16:07:11 <geekosaur> and having to link against umpteen magic object files / libraries won't?
16:07:28 <geekosaur> nobody is likely to "fix" this because it's not a bug
16:07:57 <acowley> geekosaur: Lots of non-bug things get improved
16:08:27 <geekosaur> your definition of improved is not relevant to the ghc devs
16:08:33 <elliott> gertc: how: by opening an issue asking for it
16:08:35 <elliott> failing that, unsafeCoerce
16:08:38 <elliott> (don't unsafeCoerce)
16:08:44 <blackdog> i still don't really understand the problem, tbh. would have thought it'd be possible to embed all the links to other libraries in the .so ghc produces.
16:09:02 <glguy> gertc: or figure out a solution that doesn't involve comparing Sinks for equality
16:09:27 <blackdog> geekosaur: this stuff matters in polyglot systems, which is basically everything now.
16:09:35 <acowley> geekosaur: Why the hostility? This issue comes up every time someone wants to use GHC with a tool chain for a non-standard platform. e.g. all iOS tutorials have this awkward "you need to copy/paste a bunch of libraries".
16:09:36 <blackdog> if you're not a good citizen you get ignored.
16:10:18 <gertc> elliott: pull request from 2 months ago :(  https://github.com/jaspervdj/websockets/pull/33
16:10:25 <acowley> Some folks have done great work at improving the state of affairs on ARM. I suspect some of them might also improve the way linking is handled.
16:10:53 <elliott> gertc: write a comment to ping the maintainer :P
16:11:05 <gertc> glguy: comparing sink is just waaaay cleaner for me
16:11:19 <geekosaur> the only "fix" for this is to redo the runtime to be the C or C++ runtime
16:11:21 <geekosaur> if you want that, use jhc
16:12:09 <acowley> blackdog: I'm in the same boat regarding your comment about embedding all links in the .so/.dylib/.dll
16:15:08 <gertc> so there is no way to add somthing like this in my code instance Eq (WS.Sink WS.Hybi10) where
16:15:41 <gertc> WS.Sink a == WS.Sink b = a == b
16:16:06 <geekosaur> there is standalone deriving but I don't know if it would work here
16:16:29 <elliott> the constructor isn't exported
16:16:33 <elliott> haskell maintains data abstraction
16:16:39 <elliott> your only option is to use unsafeCoerce
16:16:57 <elliott> and an orphan instance that uses unsafeCoerce is probably something you should never consider writing
16:19:21 <gertc> ok time for bribing a package maintainer :)
16:20:08 <gertc> ps is there anyway performance or any other issue not to derive Eq?
16:20:40 <oio> what is the "enter" symbol in haskell
16:20:52 <elliott> the enter symbol?
16:21:07 <oio> \n \t
16:21:15 <gertc> ^M
16:21:39 <oio> lets say in getLine i get a enter a return
16:21:49 <elliott> > '\n'
16:21:50 <lambdabot>   '\n'
16:21:54 <elliott> > '\010'
16:21:55 <lambdabot>   '\n'
16:22:07 <elliott> oio: But getLine doesn't include the newline.
16:22:33 <gertc> '^M'
16:22:47 <gertc> '\^M'
16:23:02 <mauke> gertc: ?
16:23:06 <gertc> why does the lamdabot ignore me :)
16:23:09 <oio> mm ok
16:25:50 <geekosaur> take a close look at what the others are doing?
16:26:17 <gertc> '\n'
16:26:25 <mauke> gertc: because you're not talking to it
16:26:25 <geekosaur> look again
16:26:41 <geekosaur> hint:  two characters you did not include
16:26:57 <gertc> lambdabot: '\n'
16:27:04 <geekosaur> ...
16:27:17 <gertc> lol :)
16:28:24 <gertc> > '\n'
16:28:25 <lambdabot>   '\n'
16:28:30 <gertc> jaaaaaaa :)
16:29:23 <gertc> > '^M'
16:29:24 <lambdabot>   <hint>:1:2: parse error on input `^'
16:34:26 * hackagebot hsenv 0.3 - Virtual Haskell Environment builder  http://hackage.haskell.org/package/hsenv-0.3 (TaylorHedberg)
16:36:55 <blackdog> hm, someone's taken over hsenv?
16:37:33 <sm> looks like
16:37:34 <oio> can i pattern match a name?
16:37:54 <oio> like nam Simon = putStrlLn "Hey simon"
16:38:22 <lispy> > let nam "Simon" = text "Hey Simon" in nam "Simon"
16:38:23 <lambdabot>   Hey Simon
16:38:59 <oio> great ;D
16:39:05 <BrianHV> does hsenv == virthualenv?
16:39:08 <lispy> > let simon = "Simon"; nam n | n == simon = text "Hey Simon" in nam simon
16:39:09 <lambdabot>   Hey Simon
16:39:11 <blackdog> BrianHV: yeah.
16:39:35 <lispy> oio: if the thing you want to match on has a name you can use the guard thing like in the second example
16:39:44 <blackdog> confusing for a while - original author changed the name but never uploaded to hackage
16:39:57 <oio> i know ;D
16:40:09 <BrianHV> aah. glad there's been an upload now then
16:40:26 <lightquake> help, how do I teach people haskell
16:40:37 <shachaf> lightquake: It's impossible.
16:40:41 <lightquake> oh no :(
16:40:47 <shachaf> Sorry. :-(
16:41:01 <ckcbc> I have a question concerning Lexical analysis with Haskell/Alex is it the right place?
16:41:08 <nathanfh> Haskell has either been living in your brain waiting to be revealed for your whole life, or you'll never learn it.
16:41:47 <shachaf> ckcbc: Even if it's not the right place, you're better off asking your question than asking whether you can ask it.
16:44:02 <gertc> lightquake: http://learnyouahaskell.com is where i started, but it needs way beter index, the key in learning haskell is to make a very very big map where you can look up things quickly
16:44:21 <lightquake> i mean, i'm giving basically a 4-hour presentation broken up over 3 days
16:44:28 <lightquake> and i think just reading off LYAH would be bad form ;)
16:44:43 <gertc> yes it would
16:45:01 <ckcbc> I am trying to lex a file line by line using the context characters ^ and $
16:45:08 <shanse> well, but nobody needs to know that you're just reading off lyah
16:45:09 <gertc> because lyah creates the illusion it is easy but its not
16:46:07 <lightquake> shanse: i'm probably going to structure it after LYAH
16:46:18 <gertc> try to teach them WHY not HOW
16:46:30 <gertc> how they can learn by thme self
16:46:33 <shachaf> lightquake: You can do better than LYAH!
16:46:49 <ckcbc> basically the rule I am using for each type of line is ^Regexp$
16:46:54 <lightquake> also: is beamer a reasonable choice for this?
16:47:11 <shachaf> For what?
16:47:21 <ckcbc> it seems to me that this doesn't include the "\n" character in the lexem I match (which is what I want)
16:47:37 <gertc> for example try to explain WHY monads are useful NOT HOW they work
16:48:16 <shachaf> Try not to take monad advice from random people in #haskell
16:48:20 <shachaf> (Including me, of course.)
16:48:20 <gertc> create like basic programs and try to let the invent monads them self :)
16:48:59 <ckcbc> but if I let it like that of course I have an error when I reach the end of line character
16:50:10 <gertc> and also do allot of comparing with mathematical background
16:50:14 <ckcbc> and if I put a rule to get / ignore end of line it doesn't seem to work either.
16:50:54 <ckcbc> So the question is what rule shoudl I put in Alex  (or actually most lexical analyser).. to get a file line by line (end then just ignore the eol character)
17:04:01 --- mode: ChanServ set +o mauke
17:04:02 --- kick: average_drifter was kicked by mauke (average_drifter)
17:04:02 --- kick: average_1rifter was kicked by mauke (average_1rifter)
17:04:22 --- mode: mauke set +b *!~un_golan@*
17:04:47 <shachaf> mauke: ?
17:04:52 <mauke> shachaf: ban evasion
17:05:39 <mauke> shachaf: $a:spetrea-home is banned. he joined first, then identified afterwards to get into the channel
17:06:22 --- mode: mauke set -o mauke
17:06:28 <hpc> that kind of thing isn't caught automatically?
17:08:47 <gertc_> ghc llvm can it generate portable asembler code? tha you can compile on arm for example with gcc or something?
17:09:11 <gertc_> ? why do i have _ after my name?
17:09:26 <shachaf> gertc_: You've been promoted.
17:09:30 <hpc> gertc_: perhaps you should read up on what exactly llvm is?
17:09:57 <gertc_> its like a compiler :)
17:10:32 <gertc_> that generates some awsome assembler code :)
17:11:14 <gertc_> but i was wondering it that llvm assembler code was portable?
17:12:51 <c_wraith> llvm bytecode is not really very portable
17:13:33 <c_wraith> and ghc's use of it is completely non-portable.  It just uses llvm to generate libraries that are linked with the system-specific runtime.
17:14:27 * hackagebot hsc3-dot 0.13 - haskell supercollider graph drawing  http://hackage.haskell.org/package/hsc3-dot-0.13 (RohanDrape)
17:20:30 <gertc_> c_wraith: ok need to do some more reading on llvm, but i can't figure out why ghc -llvm is more portable then ghc -gcc if you want to run somthing on arm
17:21:08 <geekosaur> ghc doesn't gnerate gcc code any more
17:21:48 <geekosaur> it used to, but it was highly fragile.  these days there are two modes:  a native code backend (which does not exist for ARM), and LLVM bytecode output which LLVM translates to the platform machine code
17:22:13 <gertc_> a ok
17:22:20 <elliott> isn't -fvia-c still around
17:22:26 <elliott> technically
17:22:33 <geekosaur> deprecated in early 7.x, gone in 7.4+, I believe
17:22:47 <elliott> so it is
17:22:53 <elliott> on the commandline: Warning: The -fvia-c flag does nothing; it will be removed in a future GHC release
17:22:56 <elliott> rest in peace
17:22:56 <shachaf> How does GHC compile to ARM?
17:22:58 <geekosaur> there is still unregisterised in theory, but as of 7.4.x it was broken
17:23:01 <elliott> shachaf: llvm, I think
17:23:14 <Playground> Does ghci depend on gcc, though?
17:23:20 <geekosaur> generates llvm code, makes llvm deal with the platform translation
17:23:42 <shachaf> Hmm.
17:23:49 <geekosaur> no, it even uses its own built in linker (which is why it doesn't work on ARM and other platforms where the built-in linker doesn't exist)
17:24:09 <geekosaur> ghc will call out to gcc to compile C sources, I think. which is used with the FFI
17:24:20 <geekosaur> but the old FFI code which relied on gcc has also been removed
17:24:27 * hackagebot sieve 0.1.0.0 - Sieve is an implementation of the Sieve abstract data type.  http://hackage.haskell.org/package/sieve-0.1.0.0 (JohnSingleton)
17:24:39 <geekosaur> (note warnings if you point to a #include file in a foreign import)
17:26:45 <erineh> using the definition of homoiconic "code and data are represented as fundamental data structure in the language" it seems to me that haskell fits the description because code is effectively functions which are first class and pretty fundamental. so this word seems to mean nothing
17:27:03 <erineh> (because haskell is nothing like lisp ;)
17:27:30 <Ralith> what function is 'data'?
17:27:41 <Ralith> what function is '='?
17:28:14 <tim_heap> :t =
17:28:15 <lambdabot> parse error on input `='
17:28:15 <erineh> so a better definition would be '100% all code'
17:28:20 <tim_heap> :t (=)
17:28:21 <lambdabot> parse error on input `='
17:28:32 <Ralith> no, it wouldn't.
17:28:42 <bradleyayers> = isn't a function is it?
17:28:50 <johnw> no, it's syntax
17:29:00 <bradleyayers> yep
17:29:34 <erineh> i dare say lisps usually have some code which is non data
17:29:50 <cmccann> haskell can't be homoiconic because actual code is lovely but working with syntax trees in TH makes me want to stab myself in the brain
17:30:16 <johnw> erineh: Lisp builtins are sometimes of type #<function>, which is not representable as data
17:30:45 <johnw> granted, you can get away with an extremely small set of builtins
17:31:00 <erineh> or none if you suspend disbelief ;)
17:31:04 <Ralith> johnw: which is not representable as code*
17:31:20 <Ralith> except by (type-of whatever) of course
17:31:54 <erineh> at this point id wonder what is meant by 'code'
17:32:07 <erineh> source syntax
17:32:08 <Ralith> but many things aren't representable in direct syntax; one doesn't generally expect them to be.
17:32:32 <erineh> Ralith: right
17:32:57 <erineh> so i have a hard time seeing why anyone would call anything homoiconic, perhaps theres this pissing contest of 'more homoiconic than thou'
17:33:16 <Ralith> what is confusing to you? it's quite clear-cut.
17:33:48 <erineh> not really, except that lisp is called homoiconic just because, where i see lisp as just special syntax on a system that has 'eval'
17:34:08 <Ralith> perhaps you should familiarize yourself with lisp before questioning its terminology :p
17:34:43 <erineh> ive been trying, and i get confronted with explanations that a priori define lisp as things without justification
17:37:25 <johnw> "things without justification".  Lisp has never been more succinctly defined
17:37:33 <erineh> heres another example, code is represented as text, and many languages have strings, so they are thus homoiconic?
17:37:36 <erineh> hahahha
17:37:49 <Nereid> "I know a lisp when I see one"
17:37:50 <elliott> Tcl is homoiconic.
17:37:53 <elliott> By way of strings.
17:38:16 <erineh> and javascript
17:38:18 <erineh> ?
17:38:45 <erineh> suddenly eval implies homoiconicity
17:38:46 <elliott> JavaScript doesn't use strings nearly as fundamentally as Tcl does.
17:39:17 <erineh> how does one use something fundamentally
17:39:30 <erineh> implementation details aside
17:41:00 <cmccann> erineh: are you actually asking for explanations here, or just looking for more ways to nitpick about informal terms?
17:41:19 <cmccann> because you seem to be trying very hard to not understand any of this.
17:41:34 <erineh> im trying to apply this 'informal term' to not lisp
17:42:03 <mauke> >implying "homoiconic" is informal
17:42:16 <erineh> i started with the assumption that its not
17:42:19 <copumpkin> I'm heteroiconic
17:42:26 <Ralith> erineh: why don't you go ask #lisp, I'm sure they'd love to help you.
17:42:37 <erineh> i figured they would ban me for trolling
17:42:47 <erineh> i figured haskell people would have more insight
17:42:51 <Ralith> better to do it in a channel where it's not even on topic, then? :P
17:43:00 <copumpkin> #scheme is fairly tolerant
17:43:23 <cmccann> no, #haskell is where you go to get insight for trolling about Java
17:43:36 <cmccann> if you want insight on trolling lisp you'll probably have better luck elsewhere
17:43:45 <erineh> im not trolling
17:46:55 <elliott> erineh: If you think a channel to which a topic is relevant would ban you for trolling if you asked about it there, then consider that your chances in a channel unrelated to that topic are probably even worse.
17:47:00 <elliott> Then don't do it.
17:48:11 <gertc_> chicken or egg ? http://ghcarm.wordpress.com/2011/12/24/ghc-7-4-1-release-candidate-1-is-out/ its asumes linux ghc gcc llvm is already running on arm right?
18:00:26 <JoeyA> I'm working on a server program to test HTTP clients under various scenarios (e.g. redirect, download hangs midway, etc.).  What's a good name for it?
18:00:54 <johnw> http-stress
18:01:38 <JoeyA> Sounds good.
18:01:41 <gertc_> http-unit
18:03:50 <JoeyA> Thanks.  I think I'll go with http-stress
18:04:32 <gertc_> or hunit-http
18:04:40 <JoeyA> Well, it's not hunit-related.
18:04:50 <JoeyA> It's a standalone server.
18:05:08 <JoeyA> With a homepage that lists all the modes (including one to crash your web browser :-) )
18:05:29 <gertc_> sounts very unit like doh :)
18:05:47 <JoeyA> Test.HTTP.Stress
18:07:37 <jaimef> so when runghc spits out missing dependencies, are those system level? or cabal level?
18:07:39 <JoeyA> (It'll also be available in library form, so it can be used inside of a test suite by forking a thread)
18:07:53 <blackdog> JoeyA: not quite the same thing, but have you looked at pronk?
18:08:10 <blackdog> more like ab and friends
18:08:42 <blackdog> i tend to like the meaningless-but-memorable names better myself, but de gustibus non disputandum est
18:08:56 <JoeyA> Looks like it's for testing HTTP servers.  I want to test an HTTP client, to make sure it doesn't leak when downloads fail repeatedly.
18:09:18 <blackdog> oh, duh. sorry, didn't read it properly.
18:10:28 <JoeyA> blackdog: Non problema est. Gratiae pro input, socius Haskeller!  (switching to Latin since you did :D)
18:10:49 <blackdog> karma++ JoeyA
18:10:58 <blackdog> like haskell, a language for a more elegant age
18:11:03 <blackdog> karma+ JoeyA
18:11:07 <blackdog> no? oh well.
18:11:08 <monochrom> I think the right command est @karma+
18:11:20 <blackdog> @karma+ JoeyA
18:11:20 <lambdabot> JoeyA's karma raised to 4.
18:11:21 <JoeyA> @karma+ is pre-increment, I think
18:11:22 <lambdabot> is's karma raised to 0.
18:11:27 <blackdog> @karma- blackdog
18:11:27 <lambdabot> You can't change your own karma, silly.
18:11:44 <shachaf> @karma+ java
18:11:44 <lambdabot> shachaf's karma lowered to 28.
18:11:51 <JoeyA> lol
18:11:59 <shachaf> I think that feature should be taken out.
18:12:14 <monochrom> @karma+ shachaf
18:12:14 <lambdabot> shachaf's karma raised to 29.
18:12:14 <mauke> I think y'all should use ++ and -- instead of @karma
18:12:42 <shachaf> @karma+ java
18:12:42 <lambdabot> shachaf's karma lowered to 28.
18:12:44 <JoeyA> Or for Haskell, `atomicModiyIORef' (+1)`
18:12:48 <shachaf> monochrom: My karma is fake.
18:12:56 <shachaf> Someone spammed shachaf++ in another channel.
18:12:59 <monochrom> ok!
18:13:01 <JoeyA> err, (`atomicModifyIORef'` (+1))
18:13:16 <JoeyA> err, nevermind
18:13:21 <JoeyA> modifyIORef' *
18:13:30 <Nereid> why are we IORefs
18:13:32 <Nereid> :(
18:13:42 <monochrom> because we are not thunks
18:13:49 <JoeyA> state (\s -> ((), s+1)
18:14:04 <JoeyA> atomicModifyKarma
18:14:29 <yitz> mauke++
18:14:33 <Nereid> :t ?shachaf += 1
18:14:34 <lambdabot> (?shachaf::SimpleSetting s a, Num a, MonadState s m) => m ()
18:14:50 <JoeyA> ?Nereid += 1
18:14:50 <lambdabot> Unknown command, try @list
18:14:54 <monochrom> shachaf is a simple setting? :)
18:14:59 <JoeyA> :t (+=)
18:15:00 <lambdabot> (Num a, MonadState s m) => SimpleSetting s a -> a -> m ()
18:15:03 <shachaf> monochrom: shachaf is getting a stab
18:15:08 <JoeyA> Ah, implicit parameters
18:16:09 <yitz> @karma karma
18:16:09 <lambdabot> karma has a karma of 3
18:16:16 <yitz> @karma is
18:16:16 <lambdabot> is has a karma of 0
18:16:40 <yitz> @karma c
18:16:40 <lambdabot> c has a karma of 1
18:16:56 <cmccann> @karma notshachaf
18:16:56 <lambdabot> notshachaf has a karma of 0
18:17:04 <appamatto> How can I deal with an instance of Failure a?
18:17:22 <Nereid> define "deal with"
18:17:25 <yitz> interesting, c used to have a karma in the thousands. perhaps it is excluded now as a special case.
18:17:44 <appamatto> Hmm, I'm not sure how to "catch" the failure
18:18:09 <Nereid> Failure only specifies how to fail, not how to catch.
18:18:30 <JoeyA> appamatto: you get to decide what failure means.
18:18:30 <appamatto> Oh
18:18:42 <JoeyA> You can use it like Either e, where e is the type of failure.
18:19:06 <yitz> or perhaps there were a lot of recent discussions about ghc's low-level rendering intermediate language, whose name i will not mention for obvious reasons
18:19:42 <JoeyA> Heh
18:19:47 <JoeyA> yitz++
18:20:02 <yitz> JoeyA: :)
18:20:45 <dmwit> ?karma C/C
18:20:45 <lambdabot> C/C has a karma of 364
18:20:53 <monochrom> haha
18:20:55 <yitz> ah there we go :)
18:21:39 <ion> Because c/c++ can be grouped to a single thing.
18:21:58 <yitz> @karma c/c
18:21:58 <lambdabot> c/c has a karma of 365
18:22:21 <monochrom> people love credit cards
18:22:35 <ion> And country codes
18:22:45 <shachaf> i love credit cards
18:22:47 <shachaf> they are so easy
18:22:54 <ion> and secure
18:23:03 <yitz> @karma (
18:23:03 <lambdabot> ( has a karma of 151
18:23:09 <shachaf> @karma-all
18:23:09 <lambdabot>  "nobody"             2000
18:23:10 <lambdabot>  "c/c"                 365
18:23:10 <lambdabot>  "("                   151
18:23:10 <lambdabot>  "g"                   109
18:23:10 <lambdabot>  "+"                   108
18:23:11 <lambdabot> [1903 @more lines]
18:23:16 <shachaf> There. That's all.
18:23:18 <johnw> @karma shachaf
18:23:19 <lambdabot> shachaf has a karma of 28
18:23:23 <shachaf> @karma+ java
18:23:23 <lambdabot> shachaf's karma lowered to 27.
18:23:26 <Nereid> +++
18:23:39 <dmwit> Oh, (, that's subtle.
18:23:44 <Eduard_Munteanu> I wonder who connects through dialup lines to IRC. :)
18:23:59 <johnw> i sometimes tether through my phone...
18:24:07 <ion> +++ATH0
18:24:32 <dmwit> shachaf: funny easter egg =)
18:35:34 <appamatto> JoeyA, I'm not sure what you mean by using it like Either
18:36:50 <JoeyA> appamatto: For example, consider parseUrl :: Failure HttpException m => String -> m (Request m')
18:37:12 <JoeyA> There is an instance Failure e (Either e)
18:37:28 <JoeyA> Here, e is an HttpException
18:38:34 <JoeyA> And (Either e) is the monad
18:39:38 <JoeyA> So substituting e = HttpException and m = Either e, we get: parseUrl :: String -> Either HttpException (Request m')
18:40:40 <JoeyA> Meaning you can say: case parseUrl "http://google.com" of Left err -> ...; Right request -> ...
18:40:55 <JoeyA> appamatto: ^
18:42:58 <appamatto> JoeyA, I see
18:43:00 <appamatto> Thanks!
18:54:55 <jcp> Is there any particular reason Controp.Concurrent.TChan isn't split into two separate types (say, Chan and Port) like SPJ's original paper on STM lays out?
18:55:07 <jcp> It seems to solve a lot of problems
18:55:18 <jcp> * Control
18:55:51 <shachaf> How do those work?
18:56:25 <JoeyA> shachaf: they're basically singly-linked lists implemented with TVars.
18:56:35 <jcp> Chans are the write end, Ports are the read end
18:56:41 <JoeyA> Oh
18:56:50 <jcp> JoeyA: More like queues though
18:56:53 <onlyu> Is there any Haskell compiler that can embed in other applications like lua?
18:57:01 <jcp> multiple-consumer queues
18:59:22 <jcp> But the main problem it solves is the all-too-common memory leak that occurs when writing to a single master chan and only reading from clones of the chan
18:59:42 <JoeyA> http://hackage.haskell.org/packages/archive/stm/latest/doc/html/Control-Concurrent-STM-TChan.html#v:newBroadcastTChan
18:59:57 <JoeyA> jcp: I contributed that ugly workaround to address that very problem.
19:00:55 <jcp> That'd solve it, but why weren't chans written as two separate data types in the first place?
19:01:44 <onlyu> Hi all, Is there any Haskell compiler that can embed in other applications like lua does?
19:02:30 <JoeyA> jcp: I don't know.  It'd be nicer if it were, but note that if you want to switch to, say, bounded channels, the multiple consumer approach doesn't quite work.
19:03:01 <JoeyA> (you'd need to know when a consumer is garbage collected to know if you can write more items)
19:03:05 <jcp> onlyu: GHC can
19:04:01 <c_wraith> onlyu: nothing like lua. the GHC api exists, but practically it's entirely unlike lua, since it requires hundreds of megabytes of supporting libraries, not just a few k of C source
19:04:50 <onlyu> jcp:Does GHC support iOS or Android?
19:05:14 <lispy> onlyu: not officially, but some 3rd parties are working on it
19:05:26 <jcp> onlyu: I'm not that knowledgeable :-P
19:05:30 <lispy> onlyu: if you search github you can find projects that claim to have some stuff working
19:05:45 <jcp> JoeyA: But the current TChan system seems to have that problem too
19:06:11 <JoeyA> Right.  Just pointing it out.
19:06:18 <jcp> Understandablr
19:06:24 <jcp> * Understandable
19:06:27 <lispy> hugs is probably the most embeddable haskell compiler out there, but it's fallen behind
19:06:29 <onlyu> c_wraith: I have a game engine write in C++ embed lua as script, now I want change to haskell, It seems GHC is not good for doing this
19:06:58 <c_wraith> onlyu: no, the GHC api would not work well for that.
19:07:01 <jcp> I've written up a rewrite using separate Chans and Ports that I'll probably throw up on Hackage and see if it gets any usage
19:07:16 <lispy> onlyu: take a look at the Haskell FFI. You can import and export functions.
19:07:43 <luite> onlyu: it would probably add 50-100MB to your executable size if you link statically with the GHC API
19:08:19 <onlyu> lispy: thx!
19:08:58 <blackdog> any ideas why this quasiquoter would be giving me an error about ViewPatterns? I'm a bit stumpde
19:09:01 <blackdog> https://gist.github.com/4535702
19:10:36 <shachaf> Must be some Perl6 thing.
19:10:44 <shachaf> Maybe it's treating that lambda as a pattern?
19:11:08 <lispy> onlyu: you should talk to blackdog about embedding ghc. He was doing that with ruby.
19:11:15 <shachaf> blackdog: The issue is that ->, anyway.
19:11:36 <shachaf> It's being interpreted in pattern context or something?
19:11:41 <lispy> onlyu: I think the project was called hurbris?
19:11:43 <shachaf> Maybe it's the {}s? I don't know.
19:11:47 <shachaf> I don't do Perl 6.
19:12:14 <blackdog> lispy: hubris :)
19:12:20 <blackdog> shachaf: hm, ok. thanks.
19:12:59 <onlyu> I have looked at Hugs, as lispy said It is embeddable, but I can't find how to register my function to haskell, and no document metioned that.
19:13:01 <mauke> er
19:13:05 <mauke> looks pretty obvious
19:13:14 <mauke> qq is a quoting operator. you've got \ in there
19:13:20 <mauke> \ is an escape character in strings
19:13:29 <blackdog> ... dammit
19:13:30 <mauke> \x is turning into ... something, leaving a bare ->
19:13:32 <blackdog> thank you. blindness.
19:13:43 <shachaf> Oh, see, that's why you need to ask Perl people.
19:13:46 <lispy> blackdog: oh right, I meant to type that (stray r)
19:13:49 * lispy heads out
19:13:52 <lispy> good luck onlyu
19:13:59 <appamatto> How can I catch HttpException?
19:14:11 <mauke> shachaf: gist helpfully marked the \ red for me
19:14:21 <blackdog> it does seem to work, but inside the {} is meant to be haskell code that evaluates to a string
19:14:23 <monochrom> > '\x'
19:14:24 <lambdabot>   <hint>:1:4:
19:14:24 <lambdabot>      lexical error in string/character literal at character '\''
19:14:25 <appamatto> It would be great if it were just Maybe instead of an Exception
19:14:38 <shachaf> mauke: That's not how [blah| ... |] works.
19:14:39 <blackdog> (i really wish audrey had chosen #{} instead. oh well.)
19:14:47 <shachaf> It's part of the behavior of qq.
19:15:23 <sw17ch> can some one here give me some help with optparse-applicative?
19:15:23 <lambdabot> sw17ch: You have 1 new message. '/msg lambdabot @messages' to read it.
19:16:10 <mauke> shachaf: ?
19:16:42 <shachaf> mauke: Without knowing about the behavior of qq, it's impossible to know anything about that \x
19:16:48 <shachaf> λ> [s|blah \x blah|] :: String
19:16:48 <shachaf> "blah \\x blah"
19:17:27 <blackdog> onlyu: if you can make your haskell code work with jhc, you may be in better shape
19:17:33 <mauke> but it's possible to make a good guess, given the error message
19:17:46 <shachaf> I assumed it accepted Haskell code and parsed it as is, because that's how blackdog was using it.
19:18:17 <shachaf> mauke: OK, but that has nothing to do with gist's highlighting.
19:19:06 <applicative> blackdog: did you try f foo = [qq| @(ap (\x -> x) foo ) |]
19:19:18 <mauke> shachaf: it pointed to the problem
19:19:26 <mauke> by accident, but I'll take what I get
19:20:44 <blackdog> applicative: compiles, at least. what's the @ operator?
19:20:49 <applicative> no thats nonsense
19:22:34 <applicative> blackdog: f foo = [qq| (map (\x -> x) $foo ) |] ?
19:22:43 <onlyu> blackdog: I have no haskell code allready, so is jhc an option? I'll take a look at it. thx.
19:23:03 <Eduard_Munteanu> Barely.
19:23:22 <blackdog> onlyu: not much on hackage compiles with it.
19:23:28 <Eduard_Munteanu> Sadly, I think only GHC is production-ready.
19:23:49 <Eduard_Munteanu> And Hugs is damn ancient :)
19:24:31 <onlyu> blackdog: Sadly...
19:25:19 <onlyu> blackdog: What's your choose for embed in ruby?
19:25:47 <Eduard_Munteanu> GHC is an option, as long as size doesn't concern you.
19:25:52 <cmccann> it's a pity that there isn't another compiler comparable to GHC. if there was, we could all enjoy the benefits of awkward incompatibilities between them, rather than being stuck with the largely-hypothetical non-portability of much of hackage.
19:27:08 <monochrom> should I laugh?
19:27:18 <blackdog> onlyu: i'm using ghc
19:27:30 <blackdog> it's certainly doable.
19:27:55 <Eduard_Munteanu> monochrom: you could... you could also cry. :)
19:27:59 <cmccann> monochrom: no, laughing requires at least three experimental GHC language extensions
19:28:07 <monochrom> haha
19:28:15 <onlyu> Eduard_Munteanu: Size is a big matter, as a game developer I want my execute as small as possible
19:28:48 <Eduard_Munteanu> I probably wouldn't go for "as small as possible", but sure, GHC is quite big to begin with.
19:29:02 <shachaf> cmccann: I wish there was another hompiler.
19:29:20 <blackdog> onlyu: lua is designed for this sort of thing - is there a reason you don't want to take the obvious path?
19:30:43 <onlyu> blackdog: I have write lua for many years, while I learned haskell recently, I dont like lua any more
19:31:31 <blackdog> onlyu: fair enough.
19:31:49 <E0000_> you can make combinators with lua for stuff, it has first class functions
19:33:20 <applicative> blackdog: i'm baffled; it doesn't seem to work, now that I understand its purpose, but why it doesn't just blow up Idon't see
19:33:31 <blackdog> applicative: the one you sent me?
19:34:03 <onlyu> E0000_: How?
19:34:29 <onlyu> blackdog: Why do you embeded haskell in ruby?
19:34:47 <applicative> no, just the use of { } as intended by the package.
19:34:48 <blackdog> onlyu: good question. Funsies?
19:35:02 <E0000_> onlyu: just like in scheme, javascript
19:35:42 <blackdog> onlyu: more seriously - haskell web frameworks used to be pretty dire, and i thought it was a neat hack to do the computational heavy lifting in Haskell and the web stuff in ruby
19:36:42 <blackdog> the problem is with deployment - the model i chose is optimised for messing around at the command line, less for packaging .so files up into something production-friendly.
19:37:14 <JoeyA> Is there some way to specify conditional dependencies in cabal?  e.g. bytestring >= 0.10 || blaze-builder
19:37:27 <JoeyA> That is, if bytestring >= 0.10 isn't available, we need blaze-builder.
19:37:53 <onlyu> blackdog: Interesting!
19:38:21 <pzuraq> so, indentation with Haskell
19:38:25 <pzuraq> should I use only spaces?
19:38:33 <JoeyA> pzuraq: please do
19:38:36 <m3ga> pzuraq: yes, only spaces
19:38:42 <pzuraq> sweet
19:39:03 <m3ga> pzuraq: if you use ghc -Wall then ghc will complain when you screw up
19:39:31 <JoeyA> No, -Wall doesn't warn about tabs.  You need -Wall -fwarn-tabs
19:39:34 <onlyu> E0000_: I don't known neither scheme nor javascript very well, can u give some example or web page to learn?
19:39:50 <pzuraq> so, should I never use tabs?
19:39:54 <pzuraq> if so I really like that
19:39:58 <pzuraq> makes things simpler
19:40:19 <JoeyA> pzuraq: Well, except when you have to write a Makefile, which requires commands to be tab indented.
19:40:29 <pzuraq> well yeah
19:40:44 <m3ga> pzuraq: consensus is, haskell code uses spaces for indentation.
19:40:49 <mauke> there are ways to use tabs in haskell but it requires a lot of attention to detail and is generally not worth it
19:40:55 <pzuraq> sweet
19:41:02 <HH> Anyone know anything about Data.Packed.Matrix? I have a total newb question.
19:41:05 <pzuraq> I'm liking this language so far, first functional language
19:41:13 <m3ga> HH: a little
19:41:15 <mauke> (because haskell is all about making things line up with other things, rather than indentation levels)
19:41:23 <JoeyA> Not using tabs is liberating.  It lets you align things nicely without worrying as much about others' editor settings.
19:41:35 <shachaf> i love tabs
19:41:37 <shachaf> they are so easy
19:41:45 <HH> Trying to use fromLists to build a matrix.
19:41:53 <m3ga> HH: ok
19:42:03 <HH> Works fine in ghci, but no idea how to declare one in a .hs file.
19:42:08 <pzuraq> I would like tabs if I didn't have sublime text/notepad++/coda/atexteditorbetterthannotepad
19:42:25 <HH> m = fromMatrix [[1,2],[3,4]] fails.
19:42:33 <pzuraq> sublime gets it perfect
19:42:33 <HH> I know I'm not declaring m right.
19:42:35 <pzuraq> love this efitor
19:42:42 <m3ga> hh should be fromLists not fromMatrix
19:42:57 <m3ga> HH: should be fromLists not fromMatrix
19:43:08 <HH> oops, yeah - that's in my .hs file, I typed it wrong here. It is fromLists.
19:43:10 <onlyu> blackdog: What's your project name? I'd like to learn form it, thanks a lot!
19:43:25 <m3ga> HH: what is the error message?
19:43:40 <HH> says Ambiguous type variable `t0' in the constraints:
19:43:47 <HH> blah blah
19:43:49 <blackdog> onlyu: github.com/mwotton/hubris
19:43:57 <mauke> "blah blah"?
19:44:07 <HH> Well it's like 15 lines.
19:44:15 <onlyu> blackdog: thx!
19:44:18 <m3ga> HH: ah, os you may need to add some types like m = fromLists [[ 1, 2], [3, 4::Double]]
19:44:19 * mauke rolls eyes
19:44:49 <HH> AH ok, let me try that...
19:45:39 <pzuraq> are caps reserved for types only?
19:46:01 <mauke> no, constants
19:46:05 <mauke> or atoms
19:46:28 <cmccann> > iterate (("i love '" ++) . (++ "' it is so easy")) "..." -- saving shachaf some effort
19:46:29 <lambdabot>   ["...","i love '...' it is so easy","i love 'i love '...' it is so easy' it...
19:46:42 <m3ga> HH: in ghci, there is a default typing rule that means things like 1 is an Int. in ghc 1 is a 'Num a' so you need to supply a type
19:46:46 <pzuraq> but not functions?
19:46:53 <mauke> pzuraq: huh?
19:47:07 <m3ga> pzuraq: funcions and values need to start with a lower case letter
19:47:08 <mauke> category error
19:47:15 <mauke> m3ga: terrible
19:47:17 <HH> m3ga: ok. Trying various combinations of that. Doesn't like Int.
19:47:17 <mauke> functions are values
19:47:20 <mauke> values don't have names
19:47:23 <shachaf> cmccann: i love iterate. so easy
19:47:31 <m3ga> mauke: sorry :-)
19:47:44 <mauke> 2 + 2 doesn't start with a lowercase letter
19:47:53 <Nereid> + is lowercase
19:48:05 <cmccann> only sometimes!
19:48:10 <Nereid> :(
19:48:15 <mauke> Nereid: 7.6 here
19:48:19 <HH> m3ga: one thing it does say is probable fix is give explicit type sig
19:48:31 <HH> m3ga: or use -XNoMonomorphismRestriction
19:48:39 <pzuraq> muake: Should I refer to a 'function' as a value then?
19:48:52 <m3ga> HH: try explicit typ sig first
19:49:05 <HH> m3ga: ok, thanks
19:50:37 <m3ga> HH: looks like Int is not a valid type for a Data.Packed.Matrix.
19:51:38 <HH> m3ga: just noticed that, it's Double, Float, or Complex.
19:51:51 <m3ga> HH: altough if you add 'instance Element Int' then it works with a warning
19:52:11 <m3ga> about the orphan instance
19:53:07 <Tordek> gah, friggin' wx. I've finally gotten cabal to find wx-config, but now I'm running into this: * Missing C library: wx_gtk2u_media-2.8
19:53:24 <Tordek> anyone (I'm on debian) familiar with the issue?
19:53:25 <HH> m3ga:OK, if I add a type definition to every number it works.
19:53:42 <HH> m3ga: First time on this irc channel, thank you very much!
19:53:47 <m3ga> you shoudl aonly need to do it to a single one
19:54:06 <m3ga> HH: for Matrix all elements have the same type
19:54:34 <HH> m3ga: That makes perfect sense and seems to work just fine. Thanks!
19:55:22 <applicative> Tordek is this on os x? It rings a bell....
19:55:27 <hpaste> m3ga pasted “Int matrix” at http://hpaste.org/80758
19:55:30 <Tordek> applicative: Debian...
19:55:44 <m3ga> HH: http://hpaste.org/80758
19:56:17 <blackdog> is there an idea of prebuild-dependencies in cabal? i need happy to build some things, but it's not a build-dependency as such: it's not linked into the result
19:56:48 <HH> m3ga: Oh, most excellent. Thanks!!!
19:57:29 <applicative> Tordek http://stackoverflow.com/questions/9756088/cabal-install-wx-missing-c-library ?
19:57:48 <Tordek> applicative: yeah, but I'm only missing a single lib
19:58:01 <Tordek> and I do have g++ installed
19:59:10 <applicative> Torek thats the funny part I was associating with osx hm.
19:59:31 * hackagebot sieve 0.1.0.1 - Sieve is an implementation of the Sieve abstract data type.  http://hackage.haskell.org/package/sieve-0.1.0.1 (JohnSingleton)
20:00:26 <heatsink> blackdog, Cabal's build-tools are used for those dependences
20:00:31 <monochrom> blackdog: happy would count as a build tool. perhaps enter it under "build-tools:"
20:00:55 <heatsink> That's a slow stereo.
20:01:40 <blackdog> cheers. that won't actually install happy, though, will it?
20:01:43 <blackdog> just complain if it's not there?
20:01:54 <monochrom> right
20:02:07 <blackdog> monochrom: so basically the same end-result as what i have now :)
20:02:27 <monochrom> the error message may be better and earlier
20:02:49 <monochrom> but haha
20:03:58 <blackdog> it's actually one of my deps that's dragging it in - is entirely possible that they have that set already.
20:04:21 <monochrom> that's true
20:05:13 <monochrom> if your package is not calling happy, if it's rather another package calling happy, let the other package worry about it
20:05:28 <blackdog> scumbag dev: adds a bunch of timeconsuming deps to make his code prettier :/
20:05:49 <blackdog> monochrom: yeah. just been hacking on hubris in a attempt to make it more installable, and i'm going backwards on this one.
20:09:47 <monochrom> hrm! "cabal init" doesn't want to give me the MIT license.
20:10:19 <tim_heap> Say I had something like: data Person = Person { name :: String, age :: Int }
20:10:46 <tim_heap> Which then has the functions name :: Person -> String and age :: Person -> Int
20:11:20 <tim_heap> Is there any way of doing something like [name, age] :: Ord a => [(Person -> a)]
20:11:45 <tim_heap> IE. build an array of functions that takes a Person, and results in a type that is orderable?
20:12:30 <Nereid> I don't understand. can you give an example?
20:12:33 <shachaf> monochrom: I heard mit.edu was being DoSed -- it might have to do with that.
20:13:14 <tim_heap> What I am trying to do is make a `comparingAll` function like the `Data.Ord.comparing`
20:13:41 <tim_heap> In this example, I would like to sort a list of People first on age, and then on name
20:13:54 <Eduard_Munteanu> tim_heap: existentials might do, depending on what you want to accomplish.
20:14:02 <tim_heap> sortBy (comparing age) people works for half of it
20:14:08 <tim_heap> but I was hoping to write something like:
20:14:09 <applicative> [name, show.age]
20:14:22 <tim_heap> sortBy (comparingAll [age, name]) people
20:15:14 <tim_heap> applicative: That works, but only because the ordering of Ints is the same as the ordering of their String representation
20:15:20 <Nereid> why not comparing nameAndAge, where nameAndAge :: Person -> (String, Int)?
20:15:30 <Nereid> tim_heap: except that it isn't.
20:15:58 <Nereid> well, nameAndAge = name &&& age (where &&& is from Control.Arrow)
20:16:03 <applicative> > sort $ map show [0..12]
20:16:04 <lambdabot>   ["0","1","10","11","12","2","3","4","5","6","7","8","9"]
20:16:35 <Nereid> er oh
20:16:38 <Nereid> you want age &&& name
20:16:42 <Nereid> for sorting by age first
20:16:56 <Nereid> sortBy (comparing (age &&& name))
20:17:00 <applicative> if you add 'deriving Ord' to Person, wont this be easier>
20:17:05 <Nereid> that too.
20:17:14 <Tordek> applicative: he's asking for a general method
20:17:40 <Tordek> so he can compare by age &&& name OR name &&& age or name &&& ssn &&& age
20:17:51 <tim_heap> Tordek: correct
20:18:13 <Nereid> well, why not just do that.
20:19:17 <Nereid> :t id &&& id &&& id
20:19:18 <lambdabot> c' -> (c', (c', c'))
20:19:26 <Nereid> ah, infixr.
20:21:32 <tim_heap> &&& seems to do the job, thanks
20:21:49 <Nereid> another way to do it would be to
20:21:59 <Nereid> put comaring age and comparing name together.
20:22:47 <Nereid> :t (liftA2.liftA2) mappend (comparing ?age) (comparing ?name)
20:22:48 <lambdabot> (?age::b -> a, ?name::b -> a1, Ord a1, Ord a) => b -> b -> Ordering
20:24:01 <Tordek> :t comparing
20:24:02 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
20:25:04 <Nereid> @let blah = foldr ((liftA2.liftA2) mappend) ((pure.pure) mempty)
20:25:05 <lambdabot>  Defined.
20:25:07 <Nereid> :t blah
20:25:08 <lambdabot> (Applicative f, Applicative f1, Monoid b) => [f (f1 b)] -> f (f1 b)
20:25:13 <Nereid> :t blah [comparing ?age, comparing ?name]
20:25:14 <lambdabot> (?age::b -> a, ?name::b -> a1, Ord a1, Ord a) => b -> b -> Ordering
20:25:47 <Nereid> I like this.
20:25:56 <Nereid> I don't know of a good name for blah, though.
20:26:05 <Tordek> could you define something like `thenBy :: (b -> b -> Ordering) -> (b -> a) -> b -> b -> Ordering`?
20:26:26 <Tordek> and do "orderBy (name `thenBy` age)"?
20:26:45 <Nereid> uhhhh
20:26:48 <Tordek> I may be utterly failing at that definition
20:26:55 <Nereid> the type doesn't make sense either.
20:27:12 <Tordek> (comparing name) thenBy (comparing age), I meant
20:27:19 <Nereid> yes, see what I wrote above.
20:28:23 <Nereid> because your thenBy = (liftA2.liftA2) mappend
20:31:24 <Nereid> which can have type (a -> a -> Ordering) -> (a -> a -> Ordering) -> (a -> a -> Ordering)
20:31:39 <tim_heap> http://pastebin.com/tqv16aHF
20:31:42 <mauke> The paste tqv16aHF has been copied to http://hpaste.org/80759
20:31:59 <Nereid> Ordering, not Ord.
20:32:21 <tim_heap> Good point
20:32:24 <Tordek> Nereid: yeah, I was thinking of that but totally mixed up my types
20:32:51 <Nereid> tim_heap: anyway, if you use the Monoid instance for Ordering which does exactly the kind of thing you do
20:32:58 <Nereid> @src Ordering mappend
20:32:58 <lambdabot> Source not found. Maybe you made a typo?
20:33:00 <Nereid> aw.
20:33:21 <Nereid> EQ `mappend` b = b; a `mappend` _ = a
20:33:42 <Nereid> then you just take mappend :: Ordering -> Ordering -> Ordering
20:33:45 <Nereid> and liftA2.liftA2 it.
20:34:41 <tim_heap> Nereid: I've not quite got my head around Monoids yet. Ill copy your code down and come back to it when I can actually understand what you have written :P
20:34:56 <Nereid> well you don't need to understand Monoids in general.
20:35:09 <nathanfh> So I want a function that gives true if all elements in a list are unique, and false if there are any duplicates.
20:35:13 <Nereid> just the specific instance for Ordering
20:35:20 <shachaf> i love monoids. they are so easy
20:35:22 <nathanfh> I'm bored and decide to play some golf.
20:35:42 <nathanfh> I came up with : join $ (==) . nub
20:35:46 <Nereid> :t (==)`ap`nub
20:35:47 <lambdabot> Eq a => [a] -> Bool
20:36:09 <nathanfh> Ooh. I always forget ap
20:36:13 <Nereid> :p
20:36:24 <Nereid> :t (==)<*>nub -- 1 character shorter!
20:36:25 <lambdabot> Eq a => [a] -> Bool
20:36:51 <shachaf> Nereid: You can do one shorter than that.
20:37:05 <Nereid> show me.
20:37:22 <shachaf> @ty ap(==)nub
20:37:23 <lambdabot> Eq a => [a] -> Bool
20:37:25 <Nereid> oh damn.
20:38:05 <Nereid> @let ff = ap(==)nub
20:38:06 <nathanfh> Anyway. What I was going to say is that if I tried it in ghci, it inferred the type as [()] -> Bool
20:38:07 <lambdabot>  Defined.
20:38:07 <Nereid> @ty ff
20:38:08 <lambdabot> Eq a => [a] -> Bool
20:38:17 <Nereid> @where dmr -- nathanfh
20:38:17 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
20:39:27 <nathanfh> Bahh.
20:39:51 <monochrom> ghci does special things. this is one of it
20:40:12 <monochrom> see the GHC user's guide
20:40:23 <Nereid> well, ghci isn't special wrt the monomorphism restriction
20:40:48 <shachaf> monochrom may be the only person ever to have read the GHC user's guide
20:40:50 <Nereid> I disable it in my ghci.conf though
20:40:53 <Nereid> lol
20:41:19 <monochrom> have you seen GHC user's guide section 2.4.7 "type defaulting in GHCi"?
20:41:26 <Nereid> oh yeah, defaulting.
20:41:51 <monochrom> ghci goes way beyond monomorphism restriction
20:42:29 <shachaf> @karma
20:42:29 <lambdabot> You have a karma of 1
20:42:31 <shachaf> That's better.
20:43:02 <Nereid> right, normally it just gives an ambiguous type error.
20:46:49 <Eduard_Munteanu> shachaf: yeah, I guess you wouldn't want to be labeled as an over-unity crackpot
20:47:22 <bscarlet> I've been writing fairly vanilla compiler-like monadic code, and wish I could split the execution into separate passes without rewriting all the code (for clarity more than my own laziness). This feels intuitively like it might be doable as a monad transformer. Is this a preexisting something I should know about?
20:48:43 <shachaf> That's a bit of a vague question.
20:49:07 <monochrom> I don't see any relation between "separate passes" and "monad transformer"
20:49:17 <bscarlet> shachaf: Yeah, I know. I think if I had a tighter grasp on the question, I'd be a lot closer to knowing the answer.
20:49:35 <shachaf> Do you have an example of what you mean?
20:51:16 <monochrom> I have only seen separate passes as "stage3 . stage2 . stage1" or "stage1 >=> stage2 >=> stage3" or "stage1 >>> stage2 >>> stage3"
20:52:23 <cmccann> or (stage3 (stage2 (stage1 x))) but that's silly and nobody would ever write code that way
20:52:34 <monochrom> I sometimes write that
20:52:59 <Eduard_Munteanu> hook >=> bait >=> pull... fishing 101 in #haskell
20:53:13 <bscarlet> monochrom: Just as StateT mostly lets me leave my code alone, but gives me new things I can do like get and put and modify, I'm looking for PhasedT which would give me new actions like "wait" and "runPasses" so that runPasses [ do { x; wait; y}, do { x'; wait; y' } ] worked out to be like do { x; x'; y; y' }
20:54:40 <shachaf> You can make something that looks sort of like that sort of work. I'm not sure what it's good at expressing, though.
20:59:29 <bscarlet> shachaf: Well, in my case I've got some simplistic code which iterates (forM) through some definitions of c-like functions. Right now I can handle later functions calling earlier functions, but the earlier functions can't call the later ones, because the appropriate structures haven't been built yet. I want to split the iteration into one pass to set structures up, and another pass to use those structures.
21:04:02 <cmccann> this sounds exactly like the kind of open-ended question that shachaf can suggest using lens for despite not actually being sure what the problem is
21:04:34 <shachaf> bscarlet: You could make some sort of coroutine monad for this sort of thing, but I'm not sure whether it's the right answer.
21:04:37 <shachaf> I doubt lens fits.
21:04:44 <shachaf> cmccann just likes to make fun of me.
21:05:00 <cmccann> it's a hobby.
21:05:08 <monochrom> use lens or callcc. can't be both wrong
21:05:29 <cmccann> @quote shachaf lens.is.the.answer
21:05:29 <lambdabot> shachaf says: I'm not sure what your question is, but maybe lens is the answer.
21:05:36 <monochrom> haha
21:06:04 <monochrom> however, I am not sure whether it is ContT r (YourMonad) or YourMonad (ContT r)
21:06:05 * cmccann is merely a proxy for shachaf to make fun of himself
21:06:39 <shachaf> monochrom: Perhaps FreeT.
21:06:39 <blackdog> anyone know who packages ghc libs for ubuntu/debian? seems odd that there isn't a way of getting dynamic libs...
21:07:39 <monochrom> I don't believe it
21:07:42 <cmccann> ContT is the best way to solve problems without accidentally understanding how your solution works.
21:08:29 <shachaf> monochrom: Why not?
21:08:31 <bscarlet> Certainly the last time I had a vague intuition something ought to be a monad transformer, the answer was ContT.
21:08:45 <bscarlet> Now if only I could remember what the question was.
21:08:53 <shachaf> bscarlet: ContT will do just about anything.
21:09:00 <shachaf> It's rarely the right answer, though.
21:09:28 <monochrom> oh, "ghc-dynamic"
21:10:04 <monochrom> yes I hate linux distros splitting packages too
21:10:14 <cmccann> ContT is not the answer to the question, it's a question to which the original question is the answer.
21:10:16 <blackdog> monochrom: i have that installed - that doesn't mean you get it for other packaged libs though
21:10:25 <shachaf> bscarlet: Ask, uh, who was it?
21:10:27 <shachaf> Tordek?
21:10:36 <Tordek> shachaf: ?
21:11:24 <monochrom> now I believe it
21:11:53 <monochrom> this is because Cabal defaults to skip dynamic
21:12:10 <blackdog> it renders the packages an active hindrance for me.
21:12:12 <shachaf> Tordek: Didn't you do the coroutine thing?
21:12:21 <blackdog> have to make sure they're not installed or everything breaks
21:12:34 <monochrom> and I do mean Cabal. linux distro packages are likely built with calling Setup.hs rather than cabal install
21:12:57 <Tordek> I'm not sure what we're talking about here, but I'm really new to Haskell so I'll guess "no" is the safe answer here
21:13:19 <shachaf> Tordek: Maybe it was someone else.
21:13:54 <cmccann> shachaf: keep guessing, there's a finite number of people in the channel
21:14:00 <Tordek> lol
21:14:02 <cmccann> it's just a matter of time
21:14:16 <shachaf> cmccann: But they keep joining!
21:14:39 <monochrom> worse, they keep joining and refusing to answer you
21:14:40 <Tordek> wx is coing to drive me insane
21:14:46 <cmccann> shachaf: that's because (insert trite overplayed monad joke here)
21:14:53 <Tordek> SEE, it's already making me typo
21:15:04 <shachaf> @quote shachaf monads
21:15:04 <lambdabot> shachaf says: Polykinded Indexed Monads is the name of edwardk's new band.
21:15:07 <shachaf> Hmm.
21:15:13 <monochrom> 5 years ago, I took the wise route and skip wx
21:15:20 <cmccann> I would listen to that band.
21:15:27 <shachaf> @quote shachaf monads
21:15:27 <lambdabot> shachaf says: Polykinded Indexed Monads is the name of edwardk's new band.
21:15:36 <shachaf> @quote shachaf escape.*monad
21:15:36 <lambdabot> shachaf says: You can never escape having learned monads. If you learn two monads, though, you can go back to only knowing one.
21:15:44 <Tordek> monochrom: what should I try?
21:15:44 <Eduard_Munteanu> IIRC gtk2hs is better supported.
21:15:46 <shachaf> That was the bad old days. :-(
21:16:05 <monochrom> I went gtk2hs
21:16:10 <cmccann> shachaf: http://www.reddit.com/r/haskell/comments/16iakr/what_happens_when_a_monad_violates_monadic_laws/c7wcpna
21:16:53 <Eduard_Munteanu> cmccann: when you ask a question like that, one of the answers is bound to be "it goes to monadic jail"
21:17:06 <monochrom> http://www.reddit.com/r/banking/comments/xyz123/what_happens_when_a_banker_violates_banking_laws/123abc
21:17:23 <cmccann> yes, but those puns were above and beyond the call of duty
21:17:43 <monochrom> oh, I know! it goes to monadic fail
21:18:05 <cmccann> a++++++ joke would laugh again
21:26:18 <erineh_> what do you get when haskell channel shuns you for asking about homoiconicity
21:26:34 <erineh_> you get me talking back and forth with c2 wiki
21:26:54 <erineh_> https://docs.google.com/document/d/1chfuudeiEXpjBob7n614gbPC5EB10rv1bXlRn8Dchvc
21:27:39 <erineh_> https://docs.google.com/document/d/1chfuudeiEXpjBob7n614gbPC5EB10rv1bXlRn8Dchvc/edit
21:27:51 <shachaf> "Shun magic, and shun the appearance of magic! Shun everything, and then shun shunning!"
21:28:41 <erineh_> haha
21:29:00 <cmccann> shunpuns
21:31:24 <monochrom> haskell is not homoiconic, and I believe it is a conscious design choice. not to say that I can speak for the designers
21:32:51 <monochrom> suppose I write a function myfun :: (Bool -> Bool) -> Bool. you may use my function as "myfun (\x -> x && x)" or "myfun (\x -> x)"
21:34:06 <monochrom> if I were given the ability to discern the two, for example by giving me a homoiconic language, we would lose a strong sense of referential transparency. because usually we regard (\x -> x && x) and (\x -> x) to be equivalent.
21:35:19 <FYCouch> am i the only person who doesn't see arrays as distinct data types? but rather as qualifiers to other actual types
21:35:53 <erineh_> :t Array
21:35:55 <lambdabot> Not in scope: data constructor `Array'
21:35:57 <shachaf> How you see the word "array" doesn't matter. There is a definition in Haskell, Data.Array. There is also a definition in the C standard, "array". They're different.
21:36:04 <monochrom> the conscious design choice was to prefer a heavy dose of referential transparency. extensionally equal and/or denotationally equal things are considered equal. it leads to much fewer surprises. yes it also means we give up a lot of reflection.
21:36:18 <shachaf> If you want to talk about something, you don't have to call it "array". But arguing about words is pointless.
21:36:44 <FYCouch> i'm not arguing about words, you are
21:36:46 <FYCouch> fag
21:37:01 <FYCouch> i'm talking about looking at values in array as multiple of some data type
21:37:08 <copumpkin> FYCouch: that is not appropriate
21:37:12 <FYCouch> how does Data.Array work?
21:38:10 <copumpkin> FYCouch: you seem to be talking about how arrays take a type parameter
21:38:24 <copumpkin> i.e., you talk about "an array of _"
21:38:28 <copumpkin> or "a list of _"
21:38:36 <erineh_> an IO action of _
21:38:40 <erineh_> >:_
21:38:43 <copumpkin> :)
21:38:45 <monochrom> are we even talking about haskell?
21:38:45 <copumpkin> yep
21:38:50 <copumpkin> I don't know
21:38:55 <pzuraq> how would I make a function only apply to lists of 3 elements or more?
21:38:55 <FYCouch> yea i'm used to thinking about arrays as closed/open with regards to element size and type
21:39:01 <FYCouch> how does Data.Array work?
21:39:10 <copumpkin> FYCouch: that's a very broad question
21:39:22 <monochrom> do you already know some haskell?
21:39:29 <FYCouch> pzuraq: you really want a function to ignore a list with < 3 elements?
21:39:35 <FYCouch> no
21:39:49 <monochrom> ok we are totally on different pages
21:39:49 <shachaf> pzuraq: You can't really do it with the normal [] type.
21:40:04 <shachaf> pzuraq: You can use a different type. A simple one might be (a,a,a,[a]).
21:40:04 <Eduard_Munteanu> FYCouch: are you asking how it's implemented?
21:40:09 <shachaf> There are also lots of other types.
21:40:14 <Eduard_Munteanu> Or how you should use it?
21:40:17 <FYCouch> monochrom: sorry. ok i'll back up. in haskell, are arrays a distinct data type like number and text?
21:40:28 <monochrom> yes
21:40:28 <FYCouch> i'm asking how it's conceptually designed
21:40:32 <copumpkin> in haskell, you say you want an Array of something
21:40:32 <FYCouch> as 'array' in every lang is a lil diff
21:40:38 <copumpkin> so I think your sense
21:40:43 <copumpkin> you can't just say "I want an array"
21:40:52 <FYCouch> what is your point?
21:40:59 <FYCouch> haskell does not allow type open arrays?
21:41:07 <copumpkin> yeah, I guess?
21:41:07 <Eduard_Munteanu> Arrays aren't special things though.
21:41:10 <erineh_> Arrays are not distinct types, its a type constructor
21:41:22 <erineh_> like [] and Maybe
21:41:33 <pzuraq> well, I need to count the sides of a polygon
21:41:38 <FYCouch> so you can take any distinct data type, and flag it as an array?
21:41:43 <copumpkin> yeah
21:41:51 <copumpkin> although we wouldn't describe the process that way
21:41:58 <pzuraq> and for the purposes of the exercise, lines and single points have no sides
21:42:09 <Eduard_Munteanu> FYCouch: you can make an array of anything you want.
21:42:11 <erineh_> [Array (Maybe Char)]
21:42:17 <FYCouch> does this have any material advantages over treating array as just another data type?
21:42:18 <pzuraq> so if there are only two vertices in the array I need to return 0, else return the number of vertices
21:42:20 <copumpkin> Array (Array (Array x))
21:42:25 <copumpkin> FYCouch: we remember what's in it
21:42:42 <erineh_> FYCouch: for more general container type you might want Data.Data
21:42:54 <monochrom> I would say no to "you can take any distinct data type, and flag it as an array?"
21:42:55 <copumpkin> if you put a list into it, it doesn't make sense to expect a number out of it
21:42:55 <FYCouch> what if you wanted an array which could hold data of any type?
21:42:56 <shachaf> Data.Data is not a container type.
21:42:58 <FYCouch> even mixed type
21:43:00 <FYCouch> so a fully open array
21:43:01 <Eduard_Munteanu> FYCouch: it pretty much is just another data type, just its implementation is special.
21:43:15 <erineh_> container class
21:43:19 <copumpkin> FYCouch: how would you operate on the elements of that array if you couldn't assume anything about them>
21:43:21 <Eduard_Munteanu> Not as far as the core language is concerned, but for the runtime.
21:43:23 <blackdog> FYCouch: you'd have to pull in Data.Dynamic or something
21:43:34 <monochrom> and no, "Array Int Bool" is not taking Bool and flagging it as an array
21:44:01 <monochrom> but what do I know? I don't even know the definitions of "qualified", "flag", or even "like"
21:44:02 <copumpkin> FYCouch: we don't have built-in facilities for asking what a value's type is at runtime, by the way
21:44:12 <copumpkin> although we have a library that allows that
21:44:26 <erineh_> > typeOf 9
21:44:27 <lambdabot>   Integer
21:44:38 <copumpkin> so allowing you to put anything into an array would be possible, but not very useful
21:44:38 <erineh_> wee
21:44:40 <simpson> FYCouch: So, uh, what are you trying to build?
21:44:49 <copumpkin> unless you had a chance to ask what you got when pulling things out
21:44:50 <sw2wolf> :t 9
21:44:52 <lambdabot> Num a => a
21:45:08 <FYCouch> hmm
21:45:27 <pzuraq> I was trying to do it like sides (Polygon(v1:v2:vs)) but apparently that doesn't work
21:45:36 <pzuraq> so I'm not sure how to do the branching... I guess if statements?
21:45:51 <FYCouch> ok thanks everyone
21:46:09 <monochrom> sides (Polygon(v1:v2:vs)) should work
21:46:26 <simpson> FYCouch: Sure. Don't use offensive language next time.
21:46:33 <FYCouch> say please
21:47:56 <elliott> FYCouch: Best not push your luck when multiple people request you not to ask a certain way.
21:48:17 <pzuraq> monochrom: It works, but if I put in a line (a list with only two vertices) it will count the line and not go to the second function I've defined
21:48:37 <FYCouch> ok
21:49:19 <monochrom> sides (Polygon (v1:v2:v3:vs)) ensures at least 3 vertices
21:49:53 <pzuraq> oh, need v3...
21:50:02 <monochrom> vs can be []
21:50:45 <pzuraq> right
21:50:53 <pzuraq> ok, works now
21:50:59 <monochrom> good good
21:51:00 <pzuraq> thanks :)
21:51:09 <erineh_> circle = (Polygon (v1:v2:v3:...)) ;)
21:59:43 <pzuraq> would it be possible to add a meaning to the ':' operator?
22:00:05 <monochrom> no. but I don't know what meaning you want to add
22:00:37 <pzuraq> want to make it so I could add a vertex onto a polygon using the same notation as lists
22:01:20 <monochrom> I see. "Polygon" is standing in the way.
22:01:46 <monochrom> don't strive for "same notation". but do strive for "my notation". you can define an operator.
22:02:01 <pzuraq> can I define a similar infix notation?
22:02:22 <Clint> you could define (ː)
22:02:33 * `nand` .oO( exists n. (n ≥ 3) *> Vec Vertex n
22:02:39 <monochrom> I call it "+-+":  v +-+ Polygon vs = Polygon (v : vs)
22:03:12 <monochrom> this prepends v. if you want to append v instead, there is a way too, but slower
22:04:03 <pzuraq> sweet, that works
22:04:06 <pzuraq> I think
22:06:00 <lispy> hello
22:08:29 <johnw> hi lispy
22:09:08 * `nand` .oO( class Countable a where enumerate :: [a] )
22:09:38 <lispy> blackdog: when ghc goes to dynamic-by-default for linking, will that change your packaging for hubris?
22:09:44 <`nand`> much better than (Enum a, Bounded a)
22:09:51 <lispy> johnw: heya. How are /things/?
22:10:14 <lispy> johnw: at one point you asked to help volunteer. Did we get you hooked up with tasks?
22:10:25 <johnw> depends on which thing you mean
22:10:28 <lispy> (I was looking for something else recently and saw your email)
22:11:06 <lispy> johnw: one thing we desperately need is an ssl cert that the haskell.org server can use for https
22:11:24 <lispy> johnw: do you know anything about ssl certs?
22:11:25 <johnw> i'll take this to PM with you
22:11:33 <blackdog> lispy: hm. i don't think it'll change much, tbh - it's more about ubuntu's packaging policy
22:11:44 <lispy> blackdog: ah
22:12:01 <blackdog> i guess if the default becomes dynamic, it'll make it easier
22:12:06 <blackdog> i can use ubuntu packages for more stuff
22:12:56 <monochrom> if ghc defaults to dynamic, there is more incentive for the ubuntu package maker to include dynamic. or more incentive to suppress ghc' default :)
22:13:35 <blackdog> monochrom: yes, that's what i meant :)
22:15:32 <lispy> IIRC, fedora has been packaging ghc-compiled packages in a dynamic way for a while now
22:34:35 * hackagebot hArduino 0.1 - Control your Arduino board from Haskell.  http://hackage.haskell.org/package/hArduino-0.1 (LeventErkok)
22:38:52 <covi> If I have A.hs that uses stuff in B.hs, which in turn uses things in A.hs, how should I properly put the module and import declarations? It looks like the mutual recursion cannot be divided to produce a third module.
22:39:34 <shachaf> You can use .hs-boot
22:39:47 <shachaf> But you're probably better off splitting it up.
22:39:49 <erineh_> you can use type parameters
22:40:25 <pzuraq> sweet
22:40:32 <pzuraq> my tower of hanoi solver works
22:41:02 <covi> shachaf: Do you mind taking a look at the code to suggest ways of splitting it? I've tried but in vain.
22:41:14 <shachaf> Why ask me, rather than the whole channel?
22:41:30 <mauke> also, have you tried the hs-boot method?
22:41:38 <erineh_> A = A B, B = B A
22:41:44 <erineh_> A a = A a
22:41:55 <erineh_> B = B (A B)
22:42:03 <covi> mauke: I should try the hs-boot method first. Although I have heard warnings from the channel and HaskellWiki of just splitting things
22:42:14 <shachaf> erineh_: Are the letters you're typing supposed to make sense?
22:42:23 <erineh_> yes
22:43:09 <erineh_> i forgot the data
22:48:54 <MaybeCallMe> I want to make class Action which run only when dependent Action instances where successful, i.e. their isSuccess method returns true, and each actions have a doIt and and undoIt method to do and undo its effects. Is there a category theoretical thing which has these behaviors?
22:49:32 <johnw> is undoIt . doIt a no-op?
22:49:57 <MaybeCallMe> johnw: yes undoIt . doIt = no-op
22:50:11 <johnw> so, you at least have an Iso
22:50:15 <johnw> i didn't quite follow the first part
22:50:23 <johnw> can you sort of model it in some code?
22:50:34 <johnw> show how you'd like to use this class?
22:51:30 <MaybeCallMe> one of the concrete instances of this class would be a package manager's routine. everything it does will be dependent on previous actions like other packages being installed first before it does something
22:51:52 <MaybeCallMe> previous actions could fail in which cases, they ought to be undone
22:52:04 <MaybeCallMe> in the reverse order they were done
22:52:08 <johnw> sounds like you have a kind of graph
22:52:16 <MaybeCallMe> johnw: yes
22:52:34 <johnw> a graph where every arrow is isomorphic...
22:53:19 <MaybeCallMe> hmm, interesting so i gotta learn arrows and isomorphism property
22:53:49 <johnw> the arrows of a graph are its edges
22:54:02 <MaybeCallMe> modelled as arrows in haskell?
22:54:09 <johnw> no, not necessarily
22:54:15 <MaybeCallMe> ok
22:54:49 <johnw> i would just create your graph, and associate a function with each edge
22:55:08 <johnw> then the composition of any set of edges would yield a composition of transition functions, and it would always be invertible
22:57:02 <MaybeCallMe> so class Action where isSuccess :: RealWorld -> Bool; doIt :: RealWorld -> RealWorld; undoIt :: RealWorld -> RealWorld ?
22:57:24 <MaybeCallMe> and then dependencies :: [Action]
22:57:35 <MaybeCallMe> topologically sorted of course
22:58:25 <johnw> i'd split out a separate Iso class
22:58:39 <johnw> class Iso a b where iso :: a -> b; inv :: b -> a
22:58:43 <johnw> and then make Action depend on Iso
22:58:57 * shachaf is not sure that Iso should be a class.
22:59:06 <MaybeCallMe> cool
22:59:13 <johnw> i'm looking at Control.Lens.Iso as I type this
22:59:17 <MaybeCallMe> thanks for the info Iso class. which learn it up
22:59:20 <johnw> and big E made it a class
22:59:25 <MaybeCallMe> will learn it up
22:59:30 <MaybeCallMe> big E?
22:59:33 <MaybeCallMe> who is that?
22:59:33 <johnw> edwardk
22:59:39 <shachaf> johnw: What?
22:59:45 <johnw> the person who would have answered a question like this instantly
22:59:47 <shachaf> Control.Lens.Iso.Iso isn't a class.
22:59:54 <johnw> I'm reading that Haddock page
23:00:01 <startling> johnw: the iso class is a hack anyway
23:00:07 <johnw> is it?
23:00:13 <shachaf> What, Isomorphic?
23:00:16 <startling> it's just so you can use isomorphisms as ordinary functions
23:00:16 <johnw> yeah
23:00:20 <shachaf> That's, uh, not what you think it is.
23:00:23 <johnw> oh, ok
23:01:00 <johnw> there is this: http://hackage.haskell.org/packages/archive/roundtrip/latest/doc/html/Control-Isomorphism-Partial-Iso.html
23:01:02 <shachaf> An isomorphism in lens is a value, just like a lens is.
23:01:05 <johnw> and you're right, it doesn't make it a class
23:01:08 <startling> MaybeCallMe, data Iso a b = Iso (a -> b) (b -> a)
23:01:31 <shachaf> MaybeCallMe: Why do you want Action to be a class?
23:02:02 <MaybeCallMe> startling: I also need a (b -> Bool) to know if the end state is what i expected
23:02:35 <shachaf> I suspect a class may not be the right answer here.
23:02:44 <shachaf> At any rate the class you gave is an error.
23:03:01 <shachaf> Can you describe what you're trying to accomplish?
23:03:44 <MaybeCallMe> package manager which can undo every change it makes
23:03:59 <johnw> like nix?
23:04:07 <MaybeCallMe> yes
23:04:20 <shachaf> Why does that need a class?
23:04:38 <shachaf> I mean: What is *it* meant to accomplish.
23:04:46 <MaybeCallMe> so it can do more than just install stuff
23:05:06 <MaybeCallMe> it can for example configure software
23:05:16 <MaybeCallMe> without breaking it
23:05:34 <shachaf> I don't understand.
23:05:37 <MaybeCallMe> because everything it does can be undone
23:06:27 <shachaf> What are some instances of the class?
23:06:47 * simpson imagines a Free-style description of actions to be taken
23:06:53 <johnw> yeah, that's what I asked for a while back :)
23:06:53 <MaybeCallMe> imagine a huge software which has a million parameters to be set. common parameter sets, and patterns exist. and we possess such sets., we put them together through composition and when run, this huge software is configured
23:07:26 <MaybeCallMe> with gurantees that everything was configured correctly or not at all
23:07:35 <johnw> if we see some code, even just sample code, we can make much better suggestions
23:08:05 <MaybeCallMe> understood. i will see how i can do that
23:08:25 <shachaf> MaybeCallMe: You haven't answered my question, though. :-)
23:08:30 <shachaf> You have a class. It has some instances, presumably.
23:08:36 <shachaf> Can you name some?
23:09:19 <covi> If module A has  data Data = DataA a | DataB b, and if another module B imports A, will DataA and DataB be usable in module B?
23:10:02 <liyang> MaybeCallMe: Hey, I just met you, and this is crazy, but here's http://hpaste.org/ …
23:10:04 <MaybeCallMe> yes shachaf instance IsoMorphicEffectfulAction PackageInstallation where...
23:10:18 <shachaf> covi: Try it!
23:10:30 <shachaf> (The answer is yes. But you should try it.)
23:11:50 <covi> shachaf: I've tried (well A has a A.hs-boot, and B imports A with {-# SOURCE #-} pragma), but the result says no.
23:12:18 <MaybeCallMe> shachaf: instance IsomorphicEffectfulAction PackageInstallation where... blah blah
23:12:21 <shachaf> Hmm. Instead of listening to the result, you could listen to GHC.
23:12:32 <shachaf> It usually has more informative errors than "no".
23:12:39 <shachaf> MaybeCallMe: Are there other instances?
23:13:21 <lightquake> foldr == foldl . flip, right?
23:13:46 <simpson> lightquake: No, foldr and foldl fold the list from different directions.
23:13:51 <lightquake> the types match, but i'm not sure about strictness
23:13:54 <lightquake> ah
23:13:56 <simpson> foldr is right-to-left and foldl is left-to-right.
23:14:01 <MaybeCallMe> instance IsomorphicEffectfulAction DataEntry where
23:14:06 <fmap> simpson: ?
23:14:10 <shachaf> lightquake: No.
23:14:18 <MaybeCallMe> shachaf: instance IsomorphicEffectfulAction DataEntry where
23:14:31 <fmap> I don't think foldr is right-to-left
23:14:46 <shachaf> lightquake: foldr folds along the list structure; foldl accumulates.
23:14:46 <fmap> (at least that's not that r means)
23:14:52 <Nereid> > foldr (+) 0 [a,b,c]
23:14:53 <MaybeCallMe> liyang: thanks
23:14:54 <lambdabot>   a + (b + (c + 0))
23:14:55 <shachaf> fmap: The "r" means "right-biased".
23:14:56 <Nereid> > foldl (flip (+)) 0 [a,b,c]
23:14:57 <lambdabot>   c + (b + (a + 0))
23:14:58 <johnw> foldr is right associative, not right-to-left
23:15:05 <simpson> Yeah, you're all right. Derp.
23:15:17 <Nereid> > foldl (+) 0 [a,b,c]
23:15:19 <lambdabot>   0 + a + b + c
23:16:03 <CraigSJD> Been trying to learn Haskell, tried creating a "real world" utility.  The goal was to iterate through lines in a file and provide words that meet a criteria (e.x. words that I can type with only my left hand).  Would someone mind doing a code review on my code?  It works but is probably not the best.  Thank you!  http://pastebin.com/MZsy5FiP
23:16:06 <mauke> The paste MZsy5FiP has been copied to http://hpaste.org/80761
23:16:10 <Nereid> almost always one should use foldl' over foldl, though
23:17:10 <johnw> CraigSJD: you don't need to use recursive functions in several of these cases
23:17:40 <Nereid> interactLine = mapM_ processLine
23:17:54 <Nereid> processLine s = when (isValidPassword s p) (putStrLn s)
23:17:58 <CraigSJD> johnw, could you give me some hints so I can look into it?  also, looking at it now I should probably create an instance of my PasswordRequirements in processLine?
23:18:12 <johnw> containsToKeys = map (`elem` "qwertyuiop")
23:18:20 <johnw> TopKeys, that is
23:18:28 <johnw> and find, not map
23:18:29 <johnw> sigh
23:18:50 <Nereid> findIndex (== x) l  =  x `elem` l
23:18:52 <CraigSJD> Nereid, i was thinking i might need to use mapM_ somewhere but was confused on its use
23:18:58 <Nereid> so,
23:19:25 <johnw> containsTopKeys = isJust . find (`elem` "qwertyuiop")
23:19:27 <Nereid> isOnlyLetters l = all (`elem` ['a'..'z'])
23:19:50 <Nereid> containsTopKeys = not . null . filter (`elem` "qwertyuiop')
23:20:00 <glguy> johnw: how about (`elem` "qwertyuiop') ?
23:20:10 <`nand`> not . nu-- yeah that
23:20:13 <Nereid> glguy: did we just make the same typo?
23:20:14 <shachaf> nu++
23:20:30 <glguy> Nereid: I copied with my mouse from what you wrote :)
23:20:34 <Nereid> ok.
23:20:42 <Nereid> listSizeSort = comparing length
23:20:50 <simpson> containsTopKeys = any (`elem` "qwertyuiop") -- why wouldn't this work?
23:20:57 <Nereid> ah yes
23:21:11 <johnw> simpson: thank you!!
23:21:18 <johnw> simpson: i underuse any and all
23:21:32 * glguy sees what he did wrong just now :)
23:21:42 <simpson> johnw: As a Python programmer, they're always in my vocabulary, but I always forget that Haskell's got them too.
23:21:52 <CraigSJD> lol i have a lot more reading to do based on these, but i'm up for it ;)
23:21:58 <Nereid> ...and considering I just used "all" just above
23:22:31 <CraigSJD> though at least i did manage to hack a working program together thus far
23:22:39 <Nereid> isBottomKeysValid s include = include || not (containsBottomKeys s)
23:22:53 <CraigSJD> is my assumption correct that i should create an instance of the parameters (until i make them user enterable), or is haskell smart enough to reuse it in processLine?
23:22:56 <wbruce> Given a list of type [IO (Maybe a)], any tips on how to get the first element that isn't IO Nothing?
23:23:11 <lispy> :t fmap catMaybes
23:23:12 <lambdabot> Functor f => f [Maybe a] -> f [a]
23:23:23 <shachaf> lispy: That won't really help.
23:23:37 <johnw> CraigSJD: yes, I do contgratulate you on that
23:23:42 <johnw> CraigSJD: it's a good beginning
23:23:50 <CraigSJD> johnw, ty
23:23:58 <Nereid> countLeftKeys = length . filter (`elem` "qwertasdfgzxcvb")
23:23:59 <Nereid> etc.
23:24:04 <johnw> CraigSJD: you will find yourself using recursion less and less, as you get familiar with the folds, maps, filters, and other combinators
23:24:14 <`nand`> :t fmap (head . catMaybes) . sequence
23:24:16 <lambdabot> (Monad f, Functor f) => [f (Maybe b)] -> f b
23:24:27 <lispy> shachaf: right, guess I was just thinking outloud
23:24:28 <CraigSJD> johnw, ok ill keep that in mind as i learn about those
23:24:29 <glguy> What problem are we golfing?
23:24:32 <shachaf> `nand`: I doubt that'll help, either.
23:24:37 <johnw> glguy: CraigSJD's program
23:24:40 <shachaf> Unless you want to run all the IO actions.
23:25:08 <shachaf> @ty foldr (\m r -> do { x <- m; case x of Nothing -> r; Just y -> return (Just y) } ) (return Nothing) -- one way
23:25:09 <lambdabot> Monad m => [m (Maybe a)] -> m (Maybe a)
23:25:10 <simpson> Hey, I see that there are Chipmunk and Bullet bindings on Hackage, but are there any pure-Haskell physics libraries?
23:25:35 <wbruce> shachaf: just until I find the first IO Just
23:25:44 <lispy> simpson: not that I know of. I meant to make one, but I never got to it :)
23:25:55 <shachaf> @ty foldr (\m r -> m >>= maybe r (return . Just)) (return Nothing)
23:25:56 <lambdabot> Monad m => [m (Maybe a)] -> m (Maybe a)
23:26:10 <simpson> lispy: I'm building a dozen games this year for a challenge. Maybe I'll port one of the libraries in a month or two.
23:26:26 <simpson> Chipmunk's pretty boring as far as physics goes, as is Box2D.
23:26:33 <lispy> simpson: there are some reasonable books on the subject that you can even find as pdfs online
23:27:14 <wbruce> shachaf: thanks :-) it'll take me a bit to chew on that
23:27:15 <simpson> lispy: Mm. I'm not totally unaware of the general idea, with a bunch of shapes and spatial hashes, and I know it's easy enough for 2D stuff that I was hoping somebody had done the heavy lifting already.
23:28:02 <lispy> simpson: IIRC, I read this book once and thought at the time that it was detailed enough to use as a spec: http://www.amazon.com/Physics-Development-Kaufmann-Interactive-Technology/dp/012369471X
23:28:36 <shachaf> wbruce: It's a bit unfortunate that you "have to" write it like that.
23:28:40 <simpson> lispy: Guh. Nice find. Can't afford it right ATM, but I'll put it on my list and maybe obtain it later.
23:28:42 <shachaf> I don't know a good way to make this sort of thing composable.
23:29:56 <CraigSJD> johnw, Nereid, ty for the review, im going to save all of that off and continue learning/revising
23:33:08 <covi> Mutually recursive modules problem. I have A.hs-boot and a module B which imports A with the SOURCE pragma. A has something like "data DA = V1 B1 | V2 B2", and in A.hs-boot I have the line "data DA". The problem is, in module B, V1 and V2 are not available.
23:54:50 <FYCouch> what is type class?
23:54:55 <FYCouch> http://en.wikipedia.org/wiki/Type_class
23:54:59 <FYCouch> confused
23:56:11 <statusfailed> FYCouch: It's basically just a way of giving a name to a group of types who all have implementations of certain functions
23:56:13 <covi> FYCouch: like "interface" in Java
23:56:30 <statusfailed> or like an interface in java :|
23:56:38 <FYCouch> group of types?
23:57:04 <statusfailed> FYCouch: take Eq: it's a class (set of types) that can be compared for equality
23:57:42 <statusfailed> FYCouch: if you want to make your own type an Eq, you just implement (==)
23:58:29 <FYCouch> can you give an example of type class please?
23:59:21 <covi> FYCouch: functor, monad, maybe a, either a, etc.
23:59:55 <simpson> Eq, Num, Show, Enum, Ord...
