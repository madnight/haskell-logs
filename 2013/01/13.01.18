00:00:33 <M30W> How do you compile xmonad without using xmonad --recompile ? As in, I'd like to compile with -Wall -Werror
00:00:53 <shachaf> Look at what xmonad --recompile does; do that.
00:01:02 <shachaf> (#xmonad might know about xmonad.)
00:02:09 * M30W re-asks here more specfic question
00:02:20 <M30W> How do you tell ghc to compile with a lib directory ?
00:02:28 <M30W> I.e lib/ instead of just ./
00:03:08 <shachaf> I don't know what a lib directory is.
00:03:23 <shachaf> man ghc | grep lib says:
00:03:27 <shachaf>        -llib  Link in library lib
00:03:27 <shachaf>        -Ldir  Add dir to the list of directories searched for libraries
00:03:38 <fmap> M30W: http://hackage.haskell.org/packages/archive/xmonad/0.10/doc/html/src/XMonad-Core.html#recompile
00:03:44 <shachaf> But you're as capable of doing that as I am, so I assume it's a more subtle issue. :-)
00:04:17 <M30W> Thanks
00:06:52 <frerich> Hm is there a good trick or technique to determine the dependencies of a Haskell program (besides the base package)? I'd like to check whether my Cabal build file is complete. Maybe there's an easy way to simulate a fresh installation?
00:07:10 <shachaf> frerich: Cabal does that automatically.
00:07:11 <fmap> frerich: cabal init
00:07:23 <shachaf> Try taking things out of build-depends -- it should stop building.
00:08:27 <fmap> frerich: move .cabal file somewhere, run "cabal init", see "build-depends:", copy that
00:09:35 <frerich> Ah, cabal init does that automatically... funky
00:09:38 <frerich> Thanks! :-)
00:09:48 <shachaf> Maybe I misunderstood. :-)
00:10:14 <fmap> frerich: note that autogenerated version ranges are somewhat silly
00:10:27 <fmap> you probably don't want them as they are :]
00:10:40 <frerich> fmap: My plan is to just drop all version ranges unless I know that a particular version does *not* work. I.e. I will go for opt-out rather than opt-in
00:11:00 <fmap> yeah, that's better
00:11:10 <johnw> now that I have my type class taking a type class as argument, I want to write: foo :: (Foo f, f a) => a, but I'm getting "can not deduce (f b)"
00:11:16 <johnw> err, (f a)
00:12:16 <b_lawver> I've not seen a constraint of that type before :o
00:12:33 <johnw> in my case, I want 'f' to become FromJSON
00:12:36 <b_lawver> the f a part
00:12:39 <johnw> but I don't want to mention that in my library
00:13:11 <johnw> but now that I think about it, I don't see how it would ever find that out
00:13:24 <b_lawver> ye
00:15:04 <johnw> hmmm
00:15:17 <johnw> i'll have to rethink how to get the type I need to make this decision into my library
00:15:52 <FYCouch> f y couch?
00:16:04 <b_lawver> why don't you want to use FromJSON?
00:16:08 <M30W> Is there any flag to get a list of what commands/imports are required ? Like with -Wall -Werror you can see a list of things you may ask for that you don't need.
00:16:28 <M30W> So import Control.Appicative and just get <$> if that's all that is used from the library
00:16:32 <ktosiek> -ddump-minimal-imports
00:16:40 <M30W> Thankyou
00:17:08 <frerich> ktosiek: Cool, I wondered the same. Thanks!
00:18:21 <johnw> b_lawver: because the user may want JSON, XML, or something else
00:18:30 <johnw> my library is just the intermediary, so I don't care
00:18:57 <b_lawver> ok
00:18:58 <johnw> i think I need a functor here to wrap the type, which will carry the knowledge that the type can be marshalled to and/or from
00:19:40 <M30W> Bit fiddely with the imports files. Heh
00:19:51 <M30W> ktosiek: Is there a nice way to make them patch files ? ;)
00:20:19 <ktosiek> M30W: I don't know, but would be handy :-)
00:20:27 <M30W> :P
00:20:39 <M30W> My xmonad configs -> 16 files D:
00:20:59 <ktosiek> as long as it's smaller than xmonad it's ok :-P
00:21:15 <M30W> xD
00:21:18 <johnw> M30W: are they turing complete yet?
00:21:29 <M30W> johnw: Are what ?
00:21:35 <johnw> your xmonad configs
00:21:59 <ktosiek> johnw: well, they are written in Haskell, so configuration language is Turing complete :-)
00:22:06 <M30W> They are heavily based on vodik's so they are complete and have been for many months now.
00:22:20 <M30W> I'm just working on cleaning everything up so it's silent with -Wall -Werror ;)
00:23:08 <M30W> And then I concidered the imports and was like oh god I don't wanna do this manually then was like thank god when ktosiek replied with -ddumb-minimal-imports :D
00:24:30 <wuttf> I have a type  newtype X = X ByteString, how can I convert a value having this type back to ByteString?
00:24:46 <M30W> ktosiek: wc -l Main.imports # 143
00:24:48 <shachaf> Pattern-matching, as always.
00:24:48 <johnw> pattern matching
00:24:51 <M30W> Hehehehe....
00:25:02 <wuttf> No other way?
00:25:15 <johnw> provide a utility function that does the pattern matching ;)
00:25:23 <wuttf> :DDD
00:25:37 <killy9999> hmm... hpaste isn't working?
00:26:08 <killy9999> or is something wrong with my irssi config and I don't see hpastes...
00:26:40 <Botje> hpaste did not say anything.
00:27:06 <killy9999> weird
00:27:19 <hpaste> killy9999 pasted “What does this syntax mean” at http://hpaste.org/80908
00:27:27 <killy9999> ha, now it worked
00:28:08 <M30W> SO MANY
00:28:19 <killy9999> so, is this syntax a form of pattern matching?
00:28:39 <killy9999> I mean this: PipeState{hsc_env}  <- getPipeState
00:29:34 <johnw> yes
00:29:41 <johnw> that's a record pun
00:30:06 <killy9999> I didn't know it could be done this way
00:30:14 <killy9999> reading GHC source code is very enlightening
00:30:22 <M30W> ktosiek: DataStruct(..) This imports none of the internals correct?
00:30:29 <M30W> And without it all together, them all
00:30:29 <johnw> it matches the field "hsc_env" from the PipeState record, and then assign it to a variable named "hsc_env"
00:31:32 <killy9999> johnw: thanks. I'll have to play with this a little bit to see if I can get two fields at once
00:31:38 <johnw> yep
00:31:43 <johnw> PipeState{a,b}
00:31:50 <killy9999> that's what I thought
00:31:52 <killy9999> neat
00:34:23 <frerich> I'm trying to hold URI values in a Set; Set requires that the contained type is an instance of 'Ord' - which is not the case for URI. So I did a trivial instance implementation with 'compare = comparing show' (i.e. I'm borrowing the Ord instance of String) but now I get a warning saying that this is an orphan instance. I googled for it and found http://www.haskell.org/haskellwiki/Orphan_instance which suggests
00:34:23 <frerich>  I should rather ask the author of the (Network) package to add the instance, but I wonder - maybe there is yet another way?
00:34:44 * M30W wonders how people want <80 characters when they write really long lines in haskell. :|
00:35:09 <fmap> there is even worse extension that lets you write `PipeState{..}' and get all fields in scope
00:35:17 <frerich> I.e. a way to not having to define my own instance (which causes this orphan instance warning) but also not waiting for the network package module to get extended?
00:35:43 <shachaf> frerich: Not really.
00:35:54 <shachaf> frerich: You can make your own newtype: newtype Foo = Foo URI; instane Ord Foo where ...
00:36:10 <frerich> shachaf: An idea which just came to my mind: I could have a newtype and then... right!
00:36:11 <shachaf> That lets you avoid an orphan, but it's kind of annoying.
00:36:21 * frerich nods
00:36:44 <shachaf> An orphan would break if the package was upgraded to define an instance, or *any* module you use also defines the same orphan.
00:36:58 <shachaf> (There's no way to import hiding instances.)
00:37:25 <frerich> Yeah, the Wiki page explained that - it makes sense. And even if there *was* a way to import hiding instances, I wouldn't want to do that for all the things I import :-}
00:37:53 <frerich> I would have to expect that any package I import could export the instance at some point in the future.
00:38:32 * M30W thinks he will leave the imports on his xmonad config alone for now.... TOO MANY
00:39:51 <frerich> I wonder, is there some benefit in just importing the bare minimum - other than being more 'namespace clean'? Does it improve linking times or the like?
00:50:40 <Botje> if you accidentally pull in a big library i can imagine you'll feel it.
00:50:40 <merijn> mm_freak: Ping?
00:53:44 <M30W> ktosiek: Pitty it doesn't understand hiding (x) :P
01:01:12 <M30W> Yay
01:01:57 <M30W> Wow....
01:02:13 <M30W> ktosiek: Out of all those files, that import cleanup sure helped the compile time. :D
01:02:18 <ktosiek> :-D
01:02:33 <M30W> And now -Wall time D:
01:02:53 <ktosiek> frerich: here's your answer about many imports slowing the build :-)
01:02:55 <M30W> Lets see how many lines that outputted for me to read through....
01:02:58 <M30W> 553 lines D:
01:03:16 <M30W> Should I even dare .........
01:03:22 <Botje> of course
01:03:29 <Botje> probably small stuff like unused variables.
01:03:45 <M30W> http://ix.io/41U
01:03:56 <M30W> Who knew that haskell looked that much like scheme :P
01:04:42 <zomg> whoa..
01:04:43 <zomg> :D
01:04:49 <zomg> That must be the longest type sig I've seen
01:05:29 <Botje> M30W: KILL IT WITH FIRE
01:05:31 <M30W> positionRationalRect bh (Rectangle _ _ _ sh) = -- First time I've had _ in that context.
01:05:35 <M30W> zomg: xD
01:06:13 <Csharp0_> Hey, I'm applying some sugar to my code, and I was wondering if there's a way to fall-through with either guards, or case, using a pattern match?
01:06:32 <zachk> most likely
01:06:48 <Csharp0_> distinct patterns map to thesame function
01:08:10 <typoclass> Csharp0_: how about "foo 42 = f ; foo 37 = f where f = [common code]" ?
01:08:19 <M30W> zomg: Is it worth going and adding that :: Type ?
01:08:20 <M30W> XD
01:08:32 <ktosiek> oh, funny, the XMonad's "let's put half of the config in type" thingy
01:08:43 <M30W> ktosiek: Yea.
01:09:36 <Csharp0_> typoclass: yea I was thinking about that too, except f requires some parameters from the actual pattern match, I'll try if it works now
01:09:40 <ktosiek> which reminds me, is there any way to partially declare type of function?
01:10:13 <ktosiek> something like "function :: Int -> Monad [go and infer what should be here]"
01:10:23 <bartavelle> function :: Int -> Monad a ?
01:10:33 <merijn> typoclass: That won't work, where doesn't scope over multiple patterns
01:10:35 <Cale> Monad isn't a type constructor
01:10:45 <ktosiek> Cale: sorry, bad example
01:10:46 <bartavelle> true
01:10:52 <typoclass> merijn: urgh, you're right of course. sorry
01:10:58 <bartavelle> (Monad m) => Int -> m a ?
01:10:58 <shachaf> ktosiek: Not really, but sort of.
01:11:03 <Cale> There aren't type holes (yet)
01:11:20 <shachaf> Cale: GHC HEAD has something it calls "type holes" which are actually value holes. :-(
01:11:21 <Cale> It's something that has been attempted and might be attempted again, I don't know
01:11:26 <ktosiek> bartavelle: with "a" you are saying "anything can go here", and I want "guess what can go here"
01:11:40 <shachaf> ktosiek: See: http://okmij.org/ftp/Haskell/partial-signatures.lhs
01:11:41 <Cale> shachaf: Yeah, the plan was actually to implement type holes too
01:11:53 <bartavelle> ktosiek, you mean you want to compiler to output a "type not defined" alert with just the part that you don't know about ?
01:11:54 <merijn> bartavelle: No, he doesn't want polymorphism, he means "I don't know this part of the type signature, so I can't write it, but the other parts should be X"
01:11:56 <Cale> But that turned out to be trickier than expected
01:12:00 <shachaf> Cale: I wish they'd called value holes something else.
01:12:10 <shachaf> They're almost entirely unrelated.
01:12:15 <typoclass> Csharp0_: you could do something like "foo = foo' where foo' 43 x = common x ; foo' 37 y = common y ; common _ = ..."
01:12:33 <ktosiek> bartavelle: what merijn said, I don't want to dump the rest of type - I just don't want to have to specify it
01:12:48 <bartavelle> what is the practical difference with pokymorphism ?
01:12:53 <ktosiek> it would be useful for XMonad :-)
01:12:59 <shachaf> ktosiek: Other than that Oleg article, see also my answer at http://stackoverflow.com/questions/13757883/can-you-partially-constrain-a-type-in-haskell/13758784#13758784
01:13:15 <shachaf> bartavelle: "Int -> IO a" is a different type from "Int -> IO Char"
01:13:21 <bartavelle> yes it is
01:13:36 <shachaf> ktosiek wants the latter type, but doesn't want to type out Char.
01:13:51 <bartavelle> ah so that when you use it twice with distinct types you get an error ?
01:13:59 <Csharp0_> It's about this ugly code: http://pastebin.com/3ru83C1q
01:14:01 <mauke> The paste 3ru83C1q has been copied to http://hpaste.org/80909
01:14:05 <shachaf> Nothing to do with using it tice.
01:14:25 <shachaf> foo :: Int -> Maybe _; foo x = return (chr x)
01:14:39 <shachaf> That _ is definitely a Char.
01:14:49 <bartavelle> ah !
01:15:00 * ktosiek should get back to work now
01:15:08 <hpaste> johnw pasted “Constraint argument question” at http://hpaste.org/80910
01:15:15 <ktosiek> shachaf: thanks for the links
01:15:30 <johnw> does anyone know how I can pass in a phantom type to that restfulGetAndDecode function, which will allow me to resolve "f a" in unwrap?
01:15:58 <M30W> Heh
01:16:23 <johnw> i just need a way for the caller to select which kind of translation they want
01:16:32 <M30W> What should one do when a data structure is defined with names that aren't used in the library it's self but are by someone who would want to use that library ?
01:17:05 <shachaf> johnw: Whatever you're doing, this looks like a way too complicated way of doing it.
01:17:06 <M30W> I.e data A = A { name :: String }; let a = A "this is valid"
01:17:29 <johnw> shachaf: I need a way to let the caller decide what the constraint will be
01:17:38 <shachaf> Do you?
01:17:41 <johnw> I do
01:17:44 <johnw> don't I?
01:17:51 <shachaf> Maybe you do with those type classes, but do you need those classes?
01:18:07 <johnw> i think I do; I don't know ahead of time what kind of translatino will be done
01:19:55 <johnw> i feel like I need a "phantom type constraint argument", except I can't imagine how to write such a thing
01:20:32 <johnw> i guess i need to do this with HOFs after all
01:20:32 <typoclass> johnw: is the issue basically that you want an extra argument for unwrap, but you don't restfulGAD to pass through any extra arguments?
01:21:01 <merijn> Anyone that can tell me where the Store comonad is defined?
01:21:04 <johnw> typoclass: I need the "f" used by unwrap to be decided by the caller of restfulGAD
01:21:32 <typoclass> johnw: right. how about an implicit param?
01:21:34 <johnw> that will end up deciding which TranslatableFrom instance I use
01:21:52 <johnw> typoclass: but how do I pass a constraint?
01:23:15 <typoclass> johnw: not sure
01:23:35 <johnw> ah, I can have: type Foo (f :: * -> Constraint) = forall a. f a => a
01:23:40 <johnw> i wonder if that carries enough information
01:23:51 <fmap> i love passing constraints
01:27:25 <johnw> nope, same problem
01:27:28 <johnw> hrpmh
01:27:38 <johnw> where is Oleg when I need him...
01:27:54 <Botje> furiously writing type signatures, of course
01:29:57 <M30W> split True _  l1 s1 _  _  _  _ r = ... split _    _  _  _  _  l2 s2 _ r = ... split _    _  l1 s1 _  l2 s2 f r =
01:30:01 <M30W> God that's ugly
01:37:51 <johnw> ok, got it
01:38:46 <johnw> instead of parametirizing on FromJSON, I just need to parameterize on Aeson.Value
01:38:59 <johnw> that way i'm dealing with types, not constraints, and it becomes easy
01:41:45 <pyry`> trying to figure out duplicate definition for symbol ___hscore_gettimeofday
01:41:48 <pyry`> googling isn't helping
01:42:06 <pyry`> and i thought i got it down to using missingh, which i've removed imports to, but am still having troubles
01:42:28 <pyry`> is there something i need to know to figure out how to troubleshoot this?
01:42:49 <shachaf> You could paste the full code (if it's small, otherwise just some code) and the full error.
01:43:13 <pyry`> it's not small, but i can paste the imports and th efull error?
01:43:42 <shachaf> I'm not sure that the imports will do much good with a link-time error.
01:44:56 <pyry`> shachaf: ahh
01:45:28 <pyry`> it only happens once i add one import to another module
01:45:37 <shachaf> Oh.
01:45:41 <shachaf> I don't know, then.
01:45:46 <pyry`> mm
01:45:55 <johnw> "___hscore_" means a function defined in the GHC core libraries
01:45:56 <shachaf> How about: Include all the information you reasonable can, rather than waiting for people to ask.
01:46:11 <johnw> it sounds like you aren't linking in a system library that is needed
01:46:26 <pyry`> full error, one moment
01:47:04 <pyry`> http://hpaste.org/80913
01:47:36 <johnw> ah, duplicate definition, I missed that
01:47:47 <johnw> are you using both time and old-time, perhaps?
01:48:09 <johnw> and try this:
01:48:16 <TheRedMood> Hello johnw :)
01:48:28 <johnw> find /Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64 -type f | xargs nm -o | grep hscore_gettimeofday
01:48:32 <johnw> TheRedMood: hi!
01:50:16 <pyry`> johnw: i think that's what's going on, but i'm not sure where time and old-time are coming in, outside of that some package from cabal installed them... but, find is running, moment
01:50:46 <johnw> you may need to add ~/.cabal/lib to that find
01:50:50 <johnw> to get the complete list of occurences
01:51:07 <pyry`> ah, will do
01:51:28 <pyry`> ah, nothing in ~/.cabal/lib ;)
01:51:33 <pyry`> annotated: http://hpaste.org/80913
01:52:06 <pyry`> this is the only version of ghc installed on the system, as well
01:52:16 <shachaf> old-time typically comes with GHC.
01:52:31 <shachaf> Why are you using it?
01:52:44 <pyry`> i installed it from a package on haskell.org
01:52:51 <shachaf> It's deprecated.
01:52:51 <johnw> how are you compiling?
01:53:01 <shachaf> The simplest solution to your problem would be not to use it. :-)
01:53:03 <pyry`> i'm just running with runhaskell
01:53:10 <pyry`> shachaf: i'm new, so i wasn't aware
01:53:12 <johnw> can you add -v, so we can see the link line?
01:53:30 <johnw> not using it is an option, but I'd rather know why it's happening
01:53:34 <johnw> it's not like it should be impossible to use
01:55:13 <pyry`> johnw: http://hpaste.org/80915
01:55:19 <pyry`> johnw: and agreed
01:55:39 <marekw2143> what for is   !   used for in haskell?
01:55:42 <pyry`> i certainly don't mind switching, but it seems like either i should learn what i'm doing wrong, or figure out what the problem is
01:55:48 <johnw> marekw2143: indexing
01:56:00 <johnw> and also strictness annotations on types and parameters
01:56:36 <pyry`> johnw: looks like it's importing it twice for sure, now that i see all the link lines
01:56:54 <pyry`> one from attempt, another because of aeson
01:56:58 <pyry`> ?
01:57:00 <johnw> ah, found it
01:57:07 <johnw> it's loading two different versions of old-time
01:57:15 <johnw> so, how did you get two versions installed, I wonder?
01:57:37 <pyry`> i assume it has either to do with missingh or data-object or data-object-yaml
01:57:49 <pyry`> i reinstalled haskell to see if i could figure it out that way, and installed only the packages i needed
01:57:59 <johnw> are you using the Haskell Platform?
01:58:09 <pyry`> data-object-yaml installs aeson, which also seems to install its own versions of mtl as well
01:58:12 <pyry`> yeah
01:58:19 <johnw> yeah, I would suggest not using it
01:58:24 <johnw> this kind of issue happens to me everytime I do
01:58:26 <pyry`> haha, alright
01:58:33 <pyry`> that's good to know :)
01:58:42 <johnw> i think I've run into this exact same kind of link failure before, even
01:58:44 <pyry`> what's the recommendation for haskell on OSX without the platform then?
01:58:53 <johnw> just install ghc, through homebrew
01:58:56 <pyry`> ah, great
01:58:58 <johnw> then bootstrap cabal from the tarball
01:59:02 <johnw> and then cabal install what you need
01:59:14 <pyry`> i should have just assumed homebrew
01:59:15 <pyry`> heh
01:59:18 <pyry`> sigh
01:59:21 <johnw> http://hackage.haskell.org/packages/archive/cabal-install/1.16.0.2/cabal-install-1.16.0.2.tar.gz
01:59:37 <pyry`> ah, thanks
02:01:01 <pyry`> johnw: i'll get back to you if for some reason issues pop up again
02:01:17 <johnw> with your own cabal you should have good luck
02:01:27 <johnw> i'm able to keep hundreds of packages playing happily together here
02:01:36 <pyry`> ahh
02:01:39 <pyry`> fantastic then
02:01:59 <wuttf> is there a base64 encoding package
02:02:15 <wuttf> sry got it
02:02:18 <pyry`> i believe i used to not use the platform version as well, but for some reason ended up on it this time around
02:02:54 <pyry`> i guess they made it seem like it was all you need, or something.
02:06:51 <johnw> it's a good thing to start with
02:06:55 <johnw> but not the best thing to continue with
02:07:10 <johnw> especially not once you start installing more stuff from Cabal
02:07:14 <johnw> err, from Hackage
02:13:31 <wuttf> How can I convert a Word32 and Word64 to bytestring?
02:14:30 <wuttf> Searched on Hoogle for type signature but nothing popped up.
02:15:06 <ziman> you can use Data.Binary
02:15:09 <ziman> @hackage binary
02:15:09 <lambdabot> http://hackage.haskell.org/package/binary
02:15:16 <wuttf> ziman: Ty, checking
02:16:08 <ziman> but there are more libs, e.g. cereal that works on strict bytestrings, etc.
02:21:20 <spacekitteh> hey, i need halp with scanl. https://gist.github.com/4563629
02:21:45 <spacekitteh> i don't quite understand what the error is telling me - why does it expect a Double?
02:22:43 <mm_freak> merijn: pong
02:22:56 <t7> SpaceCowboy, change SDERHS x x x to SDERHS x x Double
02:23:01 <t7> or one of the other x's
02:23:09 <pyry`> augur: .
02:23:19 <augur> pyry`
02:23:23 <augur> sup
02:23:23 <pyry`> ;o
02:23:27 <t7> errr
02:23:35 <spacekitteh> t7: but i want it to work with Complex Double too
02:23:36 <pyry`> augur: i am awake somehow.
02:23:41 <augur> pyry`: lol ok
02:23:50 <augur> hey you're in #haskell!
02:23:50 <augur> :o
02:23:51 <t7> i think you need to change Double to x then
02:23:52 <augur> \o/
02:23:58 <spacekitteh> where?
02:23:59 <augur> sup hacker pyry`
02:24:00 <pyry`> augur: look at the channel before you reply? :P
02:24:02 <t7> under vector x
02:24:07 <augur> why would i do that
02:24:15 <pyry`> good question :P
02:24:22 <augur> unless you mean we're talking in #haskell
02:24:24 <augur> which is what i meant
02:24:33 <spacekitteh> t7: can't you multiply a Double by a Complex Double?
02:24:45 <pyry`> augur: this is true!
02:24:46 <t7> not with *
02:24:48 <ziman> :t (*)
02:24:49 <lambdabot> Num a => a -> a -> a
02:24:56 <pyry`> augur: i stopped lurking in that other channel once the crazy shit hit the fan
02:25:08 <spacekitteh> i don't use * though, i use scale
02:25:20 <spacekitteh> oh, wait, i see the problem
02:25:30 <spacekitteh> scale is e -> c e -> c e
02:26:03 <augur> pyry`: what crazy shit
02:26:12 <spacekitteh> so if e was Complex Double, i'd have to first cast the timestep to a Complex Double
02:26:14 <pyry`> laurelai et al.
02:26:20 <augur> pyry`: ??
02:26:24 <pyry`> lolololo
02:26:45 <spacekitteh> pyry`: how do you know laurelai?!
02:26:56 <pyry`> spacekitteh: i don't
02:27:01 <pyry`> spacekitteh: at least not personally
02:27:08 <spacekitteh> pyry`: one of my best friends is her ex roommate; another friend dated her
02:27:14 <simpson> Is reusing Data.Complex the right thing to do for polar maths on Cartesian coordinates, or should I find something better?
02:27:18 <pyry`> spacekitteh: but when laurelai flings shit at the fan, it sprays far
02:27:51 <augur> laurelai was a regular in #ranarchism and on r/anarchism
02:27:55 <spacekitteh> lol
02:27:58 <augur> pyry`: i presume you mean redit-lgbt tho?
02:28:01 <pyry`> makes sense
02:28:03 <pyry`> yeah
02:28:11 <augur> i dont know what happened there
02:28:14 <spacekitteh> we used to be pretty good friends
02:28:24 <spacekitteh> until i realised
02:28:28 <pyry`> i remember the last times i was there there was some craziness
02:28:33 <pyry`> and i was just like NOPE
02:28:34 <typoclass> friendly reminder, could you guys keep it slightly more on topic? thanks
02:28:45 <pyry`> typoclass: yep :P
02:28:45 <spacekitteh> yeah. how can i cast a Double to a Complex Double?
02:28:47 <spacekitteh> :p
02:28:51 <t7> can an anarchic society be productive ?
02:29:15 <spacekitteh> :t Element
02:29:16 <lambdabot> Not in scope: data constructor `Element'
02:29:24 <augur> t7: no but co-anarchic co-societies can
02:29:25 <pyry`> :k laurelai
02:29:26 <lambdabot> Not in scope: type variable `laurelai'
02:29:28 <augur> and preferably should be!
02:29:39 <spacekitteh> :ti Element
02:29:43 <spacekitteh> :i Element
02:30:13 <spacekitteh> anyway yeah. how do i multiply a Double with either a Double or a Complex Double?
02:30:38 <spacekitteh> when the second argument is a type variable
02:30:38 <simpson> spacekitteh: realToFrac and polymorphism in the type.
02:30:56 <simpson> :t realToFrac
02:30:58 <lambdabot> (Fractional b, Real a) => a -> b
02:31:14 <spacekitteh> :t Complex Double
02:31:15 <lambdabot> Not in scope: data constructor `Complex'
02:31:15 <lambdabot> Not in scope: data constructor `Double'
02:31:18 <spacekitteh> :<
02:31:23 <simpson> :t Data.Complex Double
02:31:24 <lambdabot> Couldn't find qualified module.
02:31:37 <simpson> Er, actually, Complex isn't the constructor.
02:31:42 <simpson> :t 2 :+ 1
02:31:43 <lambdabot> Num a => Complex a
02:32:13 <quicksilver> Complex is a *type* constructor
02:32:35 <simpson> Yes, I derped.
02:33:11 <quicksilver> > (realToFrac (2.0::Double)) :: Complex Double
02:33:13 <lambdabot>   2.0 :+ 0.0
02:33:18 <spacekitteh> so in https://gist.github.com/4563629 on lines 77-80, what would i replace deltaT with?
02:33:27 <quicksilver> realToFrac will upcast a Double to a Complex Double
02:33:31 <spacekitteh> the second argument of scale could be either a Vector Double or a Vector Complex Double
02:33:38 <spacekitteh> ok
02:34:50 <spacekitteh> wait, hmm.
02:35:34 <spacekitteh> that gives me a bunch of errors
02:40:04 <spacekitteh> so i can't do
02:40:15 <spacekitteh> (realToFrac deltaT)::x
02:42:18 <spacekitteh> how can i do that? :v
02:45:02 <spacekitteh> dT = (realToFrac deltaT) :: x, specifically
02:46:33 <shachaf> What is x?
02:46:40 <spacekitteh> it's either Double or Complex Double
02:46:59 <spacekitteh> deltaT is a Double
02:47:10 <spacekitteh> but i need dT to be type x
02:47:29 <shachaf> Where does x come from?
02:47:38 <shachaf> x doesn't look like either Double or Complex Double to me.
02:47:45 <shachaf> Is it a scoped type variable?
02:48:28 <spacekitteh>  https://gist.github.com/4563629
02:48:58 <spacekitteh> in simulate, lines 66-80
02:51:44 <johnw> shachaf: which Proxy lib do you recommend?  and don't say lens ;)
02:51:55 <johnw> tagged?
02:55:53 <shachaf> tagged is the one lens uses
02:56:00 <johnw> cool
02:56:03 <shachaf> But note that you don't need a library to consume proxies.
02:56:08 <shachaf> You can just make the proxy a variable.
02:56:31 <wuttf> Anyone knows a quick way to convert a hexstring to bytestring?
02:56:58 <shachaf> @ty let foo :: a -> proxy a -> a; foo x _ = x in foo 5 (Nothing :: Maybe Int)
02:56:59 <lambdabot> Int
02:57:11 <srhb> wuttf: http://hackage.haskell.org/packages/archive/hex/0.1.1/doc/html/Data-Hex.html ?
02:57:19 <shachaf> johnw: Here "foo" accepts anything of kind (* -> *) as a proxy, and I'm using Maybe as a makeshift thing to give it.
02:57:39 <johnw> interesting, thanks
02:57:56 <johnw> it's like a type-level "_"
02:57:58 <wuttf> srhb: !!! Thanks
02:58:11 <mSSM> I have a question about the use of the State(T) monad: my state consists of a vector v, and running the stateful computation should take v and give me v'. However, the data I want to pull out from there is not the new v, but a variable depending on the v's elements (e.g. the sum and product of all elements). I am not sure how to do that with a stateful computation.
02:58:30 <marekw2143> I'm going to get familiar with methods of reading from network stream, and foudn many articles by Oleg Kiselyov - should I get familiar with them to be good haskell programmer?
02:58:42 <johnw> haha
02:58:46 <johnw> i would say, no
02:58:47 <johnw> not at this time
02:58:49 <srhb> mSSM: evalStateT and then transform the v to whatever you need?
02:58:52 <johnw> Oleg is a much more advanced read
02:59:07 <fmap> @ty evalStateT
02:59:08 <lambdabot> Monad m => StateT s m a -> s -> m a
02:59:20 <fmap> probably execStateT, not eval
02:59:32 <srhb> Yes, sorry.
02:59:36 <marekw2143> johnw: so what should I read about ?
02:59:45 <srhb> I always feel they should have been named the opposite way. :P
02:59:53 <fmap> no
03:00:04 <johnw> marekw2143: what in particular do you want to know?
03:00:12 <shachaf> marekw2143: Don't be scared of reading Oleg's articles.
03:00:22 <srhb> Actually, I do think it's evalStateT in this case.
03:00:29 <sipa> :t execStateT
03:00:32 <lambdabot> Monad m => StateT s m a -> s -> m s
03:00:39 <srhb> Yep, definitely evalStateT
03:00:40 <johnw> shachaf: yeah, but don't start with Oleg
03:00:41 <marekw2143> johnw: I'm going to write simple HTTP server from scrtatch, and don't know how to write repsonse to clinent.
03:00:57 <johnw> plus, a lot of his articles don't relate to the current state of the art
03:01:06 <johnw> some of his type hackery isn't strictly necessary anymore
03:01:13 <marekw2143> shachaf: but for example do Iterate's described by Oleg are in standard haskell library ?
03:01:20 <mm_freak> marekw2143: see blaze-builder
03:01:22 <shachaf> johnw: You could do worse, certainly.
03:01:27 <johnw> marekw2143: yes, but people don't use them much anymore
03:01:33 <johnw> conduit and pipes have sort of taken over
03:01:40 <shachaf> marekw2143: No, Iteratee is not in the standard library.
03:01:44 <johnw> shachaf: no doubt
03:01:52 <shachaf> There are lots of other libraries that do similar things.
03:02:01 <mSSM> srhb: I was hoping to combine this with replicateM
03:02:12 <shachaf> Most of them aren't great, alas. This is not as fleshed out as you'd hope.
03:02:29 <srhb> mSSM: It's hard to tell you what to do without understanding what you want.
03:02:45 <mm_freak> marekw2143: blaze-builder allows you to build arbitrarily large strings from individual chunks efficiently
03:02:52 <srhb> mSSM: it sounds like you want to compute the result of the stateful computation and then apply various functions to the result.
03:03:02 <mm_freak> marekw2143: you can later extend this with blaze-html to write the full response including HTML in one go
03:04:01 <mSSM> srhb: yes, that sounds right. And finally, I want to collect the values given by the functions applied to the results in a list.
03:04:38 <srhb> mSSM: So map ($ yourResultFromevalStateT) [list of functions to apply to that result]
03:04:54 <mSSM> srhb: 1) make stateful computation, 2) collect f applied to the result of stateful computation, 3) repeat 1 & 2 n times
03:09:13 <marekw2143> but generally how should  I write simple HTTP server using hGetContents? From what I understand Haskell put's stream in "semi-closed" state, so I can't write to it then, so is it possible to write reponse after using hGetContents on stream ?
03:10:30 <mm_freak> marekw2143: you can't write an HTTP server that way
03:10:43 <marekw2143> mm_freak: why not ?
03:10:45 <mm_freak> marekw2143: and to be honest, you've picked quite a complicated task there
03:11:00 <mm_freak> because for sockets the unpredictable nature of hGetContents bites you
03:11:08 <marekw2143> mm_freak: in imperative language like Python it's not difficult task :)
03:11:21 <mm_freak> marekw2143: you don't have hGetContents in python
03:11:30 <marekw2143> mm_freak: what does it mean that hGetContents is unpredictable ?
03:12:01 <mm_freak> marekw2143: lazy I/O is unpredictable
03:12:10 <marekw2143> unpredictable?
03:12:36 <mm_freak> you read the request
03:12:48 <mm_freak> once the full request is read, hGetContents semicloses the file handle
03:13:02 <mm_freak> at the time you want to write the response, it's closed
03:13:08 <mm_freak> chicken/egg problem
03:14:08 <marekw2143> so what to use then ?
03:14:29 <mm_freak> for reading the request i'd use a conduit or an iteratee
03:14:34 <mm_freak> for writing i'd use blaze-builder
03:14:50 <marekw2143> iteratee - that of Oleg?
03:15:08 <mm_freak> nowadays most people use conduits
03:15:52 <mm_freak> anyway, if this is your first haskell project, you might step back a bit and use attoparsec directly
03:16:10 <mm_freak> and note that parsing HTTP is HARD
03:17:30 <marekw2143> mm_freak: hmm, I'll just try write simple web server - I have some experience in imperative prorammign and in SQL :)
03:17:32 <johnw> attoparsec-conduit might be a good idea
03:17:39 * marekw2143 Goes for dinner 
03:21:28 <earthy> parsing HTTP hard?
03:21:48 <johnw> i wonder if he's thinking about supporting the entire specification
03:21:53 <johnw> not just parsing, but semantics
03:21:55 <earthy> ah.
03:21:57 <johnw> because just parsing it isn't hard
03:22:26 <johnw> header block, encoded body block, done :)
03:22:44 <earthy> yup. and the header block is very neatly defined
03:22:47 <Lethalman> johnw, then you have chunks, and pipelining...
03:22:56 <johnw> ah, HTTP/1.1
03:22:59 <johnw> he didn't specify :)
03:23:06 <AfC> and pretty soon you have ... one of about 5 different packages already on Hackage
03:23:22 <Lethalman> johnw, compression, caching...
03:23:37 <johnw> compression is just for the body
03:23:41 <johnw> i did say "encoded" :)
03:23:53 <mm_freak> parsing HTTP is easy, if you assume that web browsers always issue non-chunked HTTP/1.0 requests
03:23:57 <wuttf> LOL! GHCi just randomly crashed on me
03:24:20 <Lethalman> johnw, but all the things sum up, it's obviously easy to parse a simple http/1.0 request without fancy fields
03:24:23 <wuttf> It happened while linking packages I think
03:24:39 <johnw> it's like RFC-822
03:24:42 <johnw> parsing it is easy
03:24:44 <mm_freak> even parsing HTTP/1.0 involves quite a few weird semantical rules
03:24:46 <johnw> until you want to parse the whole spec
03:25:00 <johnw> then you're like, why the heck do I want to spend this much of my life on a spec no one uses ot its full extent
03:25:48 <tech2> johnw: comments in email addresses... yeah, that's a good idea :)
03:27:14 <mm_freak> johnw: apparently you've never written an HTTP parser…  did you know that "Cookie: x\r\nCookie: y\r\n" is equivalent to "Cookie: x, y\r\n"?
03:27:32 <johnw> mm_freak: that's still semantics
03:27:57 <johnw> but yeah, I get your point
03:28:06 <johnw> things are always thornier than they seem at first blush
03:28:33 <mm_freak> yes…  my point is that marekw2143 has picked quite a complicated task there
03:28:52 <mm_freak> i'd suggest not to write an HTTP server, but build on existing servers like happstack-server or snap-server
03:28:59 <Lethalman> marekw2143 certainly wants to do a very simple http server, simple requests
03:29:02 <mm_freak> or WAI, if you really want it low level
03:29:14 <Lethalman> just to get the grasp of writing a server in haskell
03:29:19 <mm_freak> there is no need to go down to the protocol level
03:29:21 <earthy> for a first haskell network task, yeah
03:30:41 <johnw> i like WAI, it's pretty easy to use
03:30:52 <johnw> but it does force you deal with conduit and resourcet right from the get go
03:31:05 <johnw> sometimes the type errors from those drove me nutty in the beginning
03:32:07 <mm_freak> netscape got the HTTP specification wrong when defining their first cookie specification
03:32:14 <typoclass> johnw: you mean stuff like the type variable that Response has?
03:32:25 <mm_freak> you can actually spread a single cookie over several Cookie lines
03:32:38 <johnw> typoclass: yes, exactly
03:32:52 <typoclass> johnw: yeah that's bugged me too :-)
03:33:08 <johnw> typoclass: and sometimse I run into situations where I have a ResourceT (ResourceT IO a) a or something like that
03:33:14 <mm_freak> you know why?  because their stupid cookie spec uses a comma in the date field
03:33:28 <mm_freak> and we still use this cookie spec
03:33:43 <johnw> mm_freak: that was when, like '96?
03:33:54 <mm_freak> johnw: something like that
03:34:00 <mm_freak> but we still use it!
03:34:11 <johnw> yeah, those were the wild and wooly days, for sure
03:34:27 <quicksilver> they also spelt referrer wrong
03:34:32 <johnw> probably jwz hacked it up in a weekend to support some server-side feature he was doing, and it barely got peer-reviewed
03:35:07 <mm_freak> an HTTP server must accept this and treat it as a single cookie:  "Cookie: blah=haha\r\nCookie: hehe"
03:35:16 <mm_freak> the value of the cookie blah is then "haha, hehe"
03:36:07 <mm_freak> unless you write:  'Cookie: blah="haha\r\nhehe"', in which case the cookie 'blah' actually contains \r\n
03:36:15 <mm_freak> do you see why parsing HTTP is complicated?
03:36:17 <johnw> nice!
03:36:38 <mm_freak> remember that you don't want to expose yourself to DoS attacks by accepting arbitrarily long field contents
03:37:53 <johnw> mm_freak: I take it you once wrote HTTP parsers for a living? :)
03:37:59 <mm_freak> i did =)
03:38:04 <johnw> how did I ever guess
03:38:14 <mm_freak> in haskell in fact ;)
03:38:19 <johnw> oh, nice
03:38:28 <mm_freak> at was still incredibly difficult
03:38:35 <mm_freak> even with haskell
03:38:36 <earthy> um. isn't there a max line-size limit on HTTP header lines?
03:38:45 <mm_freak> earthy: by specification
03:39:24 <mm_freak> earthy: but what's a header "line"?  'X: a\r\nb\r\nc\r\nd\r\n…'
03:39:34 <earthy> oh, wait, you're also expanding your code to be liberal in what you accept because e.g. IE sucks balls like a vacuuum?
03:39:34 <mm_freak> that's one field spread over as many lines as you want
03:40:23 <earthy> yah, that'd be a header *field* (X: in this case) over multiple *lines*
03:40:25 <earthy> no problem there
03:40:44 <mm_freak> > "X: \"" ++ cycle "haha!\r\n"
03:40:46 <lambdabot>   "X: \"haha!\r\nhaha!\r\nhaha!\r\nhaha!\r\nhaha!\r\nhaha!\r\nhaha!\r\nhaha!\...
03:40:49 <earthy> but there's no limit on field size...
03:40:52 * earthy nods
03:41:01 <earthy> *nice*. :)
03:41:34 <mm_freak> naturally my first move was to write an enumeratee that splits the stream into lines
03:41:36 <earthy> the spec allows infinitely-sized headers. :)
03:41:49 <mm_freak> that was the first mistake…  you can't do that for HTTP =)
03:42:07 <mm_freak> (btw, i made the same mistake with SMTP)
03:42:31 <mm_freak> you would assume that SMTP is entirely line-based, until you meet the SMTP authentication specification
03:42:39 <mm_freak> baaaaam, have fun redesigning your whole library
03:42:45 <spacekitteh> yay!
03:42:50 <spacekitteh> solved my problem with rewrite rules :3
03:42:55 <earthy> yah, those bolt-ons suck
03:45:58 <mm_freak> nowadays when implementing protocols i never write conduits/enumeratees ;)
03:46:13 <johnw> write a protocolee
03:46:36 <mm_freak> they tend to make you unhappy way later in your project
03:47:10 <marekw2143> well, my browser on debian issues HTTP 1.1
03:50:17 <typoclass> mm_freak: so what would you recommend, pipes? parsec?
03:50:33 <johnw> i'd do it with attoparsec
03:50:37 <johnw> if it were HTTP
03:50:57 <johnw> haven't looked at attoparsec-conduit yet
03:51:52 <TheRedMood> Um
03:52:05 <TheRedMood> Is there a way to install cabal without the haskell platform on osx?
03:52:11 <johnw> absolutely
03:52:18 <TheRedMood> I can't get the platform installed, so I am going to need cabal standalone.
03:52:30 <johnw> download this: http://hackage.haskell.org/packages/archive/cabal-install/1.16.0.2/cabal-install-1.16.0.2.tar.gz
03:52:31 <TheRedMood> Hackintoshes can be a pain sometimes :)
03:52:33 <johnw> and run bootstrap.sh
03:52:34 <TheRedMood> Got it.
03:53:07 <johnw> what is a red mood?
03:53:13 <TheRedMood> haha
03:53:17 <TheRedMood> Here comes the question again.
03:53:22 <TheRedMood> I used to play quite a lot of TF2
03:53:26 <TheRedMood> Mainly as spy
03:53:31 <Walther> Just wondering, would it be completely silly to try to make a CMS with Haskell as a project?
03:53:37 <TheRedMood> The nick at the time was "TheFoxMood"
03:53:52 <johnw> it's funny, my IRC client picks a unique color for every nick, and it has chosen green for you :)
03:53:58 <johnw> Walther: configuraiton, or content?
03:54:21 <TheRedMood> Somewhere along the road, a lot of people wanted me to change it due to it being easier to say or something like that
03:54:26 <TheRedMood> And I just ran with it X3
03:54:32 <johnw> heh
03:56:14 <TheRedMood> what did you think it was?
03:56:23 <johnw> i had really no idea
03:56:33 <johnw> i wasn't sure if "Mood" wasn't welsh slang or something
03:56:44 <TheRedMood> I am norwegian!
03:56:46 <TheRedMood> X3
03:56:54 <johnw> Lilyhammer FTW!
03:57:02 <TheRedMood> Ah, you have seen that series?
03:57:08 <johnw> yes, i love it
03:57:12 <TheRedMood> You probebly know more abnout it than I do.
03:57:18 <johnw> "oh yeah, those youth from Oslo are bad"
03:57:31 <TheRedMood> Haha, I am from a town near oslo
03:57:38 <TheRedMood> I see myself as pretty harmless.
03:58:02 <Walther> johnw: Something along the lines of having a very simple "editor" (perhaps even plain xml) that takes headings, paragraphs, pullquotes etc important elements for an article and then spits out the necessary html according to a preconfigured "template"
03:58:29 <johnw> Walther: dynamically or as a static site generator?
03:58:30 <Walther> and then perhaps make that accessible from a website through login
03:59:03 <Walther> johnw: have a ready site, generate new articles in a simple way
03:59:20 <johnw> sounds like "gitit"
03:59:24 <johnw> no problem for Haskell
03:59:37 <Walther> oh and i'm sure there are plenty of things doing that already :P Just looking for something fun to learn Haskell with
03:59:53 <TheRedMood> johnw, Isen't there a command in here to make some bot say "Haskell can do it!"
03:59:55 <TheRedMood> Or something?
04:01:19 <johnw> @faq Can Haskell answer TheRedMood's question?
04:01:19 <lambdabot> The answer is: Yes! Haskell can do that.
04:02:39 <johnw> Walther: the most fun thing to do is something you actually have a need and desire to use right now
04:02:43 <TheRedMood> ah
04:02:54 <TheRedMood> @faq can haskell be unlazy?
04:02:54 <lambdabot> The answer is: Yes! Haskell can do that.
04:02:57 <TheRedMood> :o
04:03:11 <Walther> johnw: I could use that, actually - I would like to make a blog-esque site but joomla, drupal, etc are horrible
04:03:11 <TheRedMood> @faq can haskell be object oriented ?
04:03:11 <lambdabot> The answer is: Yes! Haskell can do that.
04:03:23 <TheRedMood> O_O
04:03:30 <TheRedMood> Haskell can be object oriented?
04:03:31 <TheRedMood> :o
04:03:35 <mauke> @where OOHaskell
04:03:35 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
04:03:40 <Walther> @faq can haskell import antigravity?
04:03:40 <lambdabot> The answer is: Yes! Haskell can do that.
04:03:42 <Walther> :D
04:03:45 <TheRedMood> :D
04:04:02 <TheRedMood> Hmm
04:04:04 <johnw> @faq Can Haskell prove a false conclusion?
04:04:04 <lambdabot> The answer is: Yes! Haskell can do that.
04:04:15 <Walther> Prelude> :l antigravity
04:04:15 <Walther> target `antigravity' is not a module name or a source file
04:04:17 <Walther> :(
04:04:24 <TheRedMood> @faq can haskell make True == False ?
04:04:24 <lambdabot> The answer is: Yes! Haskell can do that.
04:04:32 <Walther> </spam>
04:04:33 <TheRedMood> O_o
04:04:34 <TheRedMood> Wow
04:04:44 <TheRedMood> This language is truly amazing.
04:04:45 <TheRedMood> X3
04:04:49 <merijn> "instance Eq Bool where True == False = True"
04:04:58 <johnw> note, it didn't say when it would do it, or how
04:05:04 <mauke> > let _ == _ = True in True == False
04:05:06 <lambdabot>   True
04:05:08 <TheRedMood> johnw, Details, Details.
04:05:31 <TheRedMood> Right now that is greek to me.
04:05:38 <TheRedMood> But someday I will understand what you did there
04:05:38 <TheRedMood> X3
04:05:53 <Lethalman> > let true = True; false = False; true == false = True; in true == false
04:05:54 <lambdabot>   True
04:06:00 <merijn> TheRedMood: He defined a function called == which returns True for all inputs
04:06:10 <TheRedMood> ahh
04:06:13 <johnw> mauke: I read a definition of "fix" today that has me puzzled as to why "fix id" is ⊥
04:06:31 <TheRedMood> Well, I am still at types
04:06:31 <johnw> it said that fix f returns a value x such that f x = x
04:06:38 <TheRedMood> Been a hectic week in most aspects.
04:07:00 <johnw> which is true for any x in the case of id, so you'd think fix id could just return ⊥
04:07:08 <johnw> oh
04:07:09 <johnw> duh
04:07:10 <merijn> TheRedMood: "let foo x y = bar in foo 1 2" defines a function foo which takes two arguments (x and y) and returns bar. In his case he named the function == (infix operator) and used _ to ignore the argument and returns True
04:07:55 <johnw> aristid: ping
04:08:57 <Walther> Also, regarding Haskell's performance - I've seen reports about how Haskell code runs n times faster than similar C code... Is that only applicable for the ghci / running from prompt, or does it actually apply to compiled executables?
04:09:02 <johnw> Haskell would be a much different experience without Hoogle
04:09:10 <Walther> Of course, with varying values of n
04:09:19 <TheRedMood> Hoogle?
04:09:26 <johnw> Walther: Haskell can be faster than C, but it can be slower too
04:09:35 <TheRedMood> IS there really any language other than OCamel that outruns C ?
04:09:35 <johnw> it depends on the problem, and the programmer, and the algorithm chosen
04:09:39 <johnw> @where hoogle
04:09:39 <lambdabot> http://haskell.org/hoogle
04:09:43 <Walther> johnw: yes, i know that, and i was trying to avoid that part
04:09:43 <mauke> Walther: er. why do you think it would apply to ghci?
04:09:48 <TheRedMood> If you do the right choices for both languages.
04:10:01 <TheRedMood> O_O
04:10:06 <Walther> i was trying to ask if the fastness applies to the compiled executables as well
04:10:10 <TheRedMood> johnw, thanks so much for this....
04:10:11 <Walther> as in, the end-product
04:10:14 <mauke> Walther: why "as well"?
04:10:18 <mauke> Walther: ghci is notoriously slow
04:10:37 <TheRedMood> mauke, It is interpited, so why not?
04:10:44 <bartavelle> never heard that ocaml would outrun C ?
04:10:58 <johnw> Walther: the compiled executables are quite fast typically
04:11:01 <TheRedMood> bartavelle, I read it in a book somewhere.
04:11:12 <TheRedMood> bartavelle, Let me find the quote.....
04:11:14 <johnw> ocaml does well in the language shootouts
04:12:03 <TheRedMood> Here is one
04:12:04 <TheRedMood> http://www.ffconsultancy.com/languages/ray_tracer/comparison.html
04:12:13 <johnw> http://stackoverflow.com/questions/4308137/whats-really-more-performant-haskell-or-ocaml
04:12:59 <bartavelle> also it should be noted than for almost all C programs ICC does create much faster executables, so it is more a compiler comparison than a language comparison that would make sense
04:13:08 <johnw> icc?
04:13:11 <johnw> intel's compiler?
04:13:17 <TheRedMood> Intel inside!
04:13:19 <TheRedMood> :D
04:13:19 <bartavelle> yes
04:13:22 <johnw> i beg to differ
04:13:35 <johnw> i have a license for icc, and it makes for a slower Emacs
04:13:39 <bartavelle> especially for intrinsics, gcc is really bad at register allocation there
04:13:56 <bartavelle> I suppose it depends on the specific use case, mine is mostly with sse intrinsics, and the difference is huge
04:13:58 <johnw> icc is great for math
04:14:08 <mauke> s/math/arithmetic/
04:14:15 <johnw> i hear it's a godsend for scientific computing
04:14:38 <bitonic> is ICC still that fast compared to gcc/clang?
04:14:40 <TheRedMood> johnw, Well, intel is pretty much amazing at that stuff I have heard, but I can't vounch fofrl it.
04:14:48 <TheRedMood> bitonic, yes.
04:14:52 <bartavelle> also I have no experience with c++, which might be quite another story
04:15:03 <TheRedMood> But it can be funky I hear when taken out of an intel enviroment.
04:15:07 <johnw> clang code generation is still catching up to gcc
04:15:11 <TheRedMood> clang is coming along nicly tho.
04:15:13 <Botje> well, they can tailor their optimizations to intel chips, of course
04:15:19 <TheRedMood> Yeah, that is the thing :)
04:15:36 <bartavelle> clang register allocation for sse intrinsics is also way better than that of gcc in my experience
04:15:37 <merijn> bitonic: ICC is much higher quality than gcc in my experience
04:15:57 <bitonic> merijn: ‘higher quality’?
04:16:07 <johnw> funny that we're discussing C++ compilers all of a sudden..
04:16:17 <johnw> this feels like a channel flashback
04:16:18 <merijn> bitonic: Code generated, default standards compliance
04:16:27 <merijn> johnw: I'm discussing C compilers :p
04:17:08 <TheRedMood> johnw, is it bad to be talking about this? Could we get banned for doing so? D:>
04:17:13 <merijn> Semi-related, Intel is investing money into improving gdb so it'll suck less \o/
04:18:34 <TheRedMood> :o
04:19:15 <spacekitteh> ok i have an on-topic question! :P
04:19:35 <spacekitteh> https://gist.github.com/4563629 is there a better way of doing what possiblyComplex does?
04:20:39 <ion> That’s evil. :-P
04:20:54 <ion> What’s wrong with realToFrac?
04:21:01 <spacekitteh> it doesn't work!
04:21:12 <spacekitteh> i tried it
04:21:19 <mauke> it works fine
04:21:25 <spacekitteh> ...i just tried it again
04:21:26 <spacekitteh> fuck.
04:21:48 <spacekitteh> i had a discussion with simpson about it before too D:
04:22:17 <ion> Btw, your lines are too long.
04:23:05 <spacekitteh> i have a 1920x1080p monitor
04:23:09 <spacekitteh> they fit fine :P
04:23:22 <spacekitteh> how do you split an expression up over multiple lines?
04:25:26 <TheRedMood> now I am setup. time to learn more haskell!
04:26:12 <spacekitteh> yay
04:26:36 <johnw> spacekitteh: just hit Return
04:27:33 <TheRedMood> okay
04:27:41 <TheRedMood> > :t (==)
04:27:42 <lambdabot>   <hint>:1:1: parse error on input `:'
04:27:53 <johnw> no > for a type query
04:27:54 <TheRedMood> Ah I can't do that here.
04:27:58 <TheRedMood> :t (==)
04:27:59 <lambdabot> Eq a => a -> a -> Bool
04:28:07 <TheRedMood> That scares me :(
04:28:17 <johnw> why does that scare you?
04:28:25 <TheRedMood> I don't know...
04:28:27 <TheRedMood> :S
04:28:51 <TheRedMood> Let read about it in the book....
04:29:38 <vanseverk> Ha! I did great on the Haskell part of my declarative programming exam
04:29:44 <vanseverk> three hurrahs for vanseverk
04:30:04 <spacekitteh> huzzah
04:30:23 <TheRedMood> HURRAY!
04:30:24 <TheRedMood> :D
04:30:51 <vanseverk> Prolog went pretty decent too :)
04:32:00 <TheRedMood> HURRAY!
04:32:01 <TheRedMood> :D
04:33:43 <Ziarkaen> I have written this to print ASCII-encoded data e.g. d = "10101100 10100011 11100011": map (chr . sum . map (\(a, b) -> a*b) . zip [2^(7-i) | i<-[0..7]] . map toInt) (words d)
04:33:52 <Ziarkaen> Is there an easier way?
04:34:02 <mauke> what does that do?
04:34:54 <merijn> Ziarkaen: Well, that's mostly incomprehensible to me, but one thing I note is that "(\(a, b) -> a*b)" is just "uncurry (*)"
04:34:57 <merijn> :t uncurry
04:34:58 <lambdabot> (a -> b -> c) -> (a, b) -> c
04:35:02 <merijn> :t uncurry (*)
04:35:03 <lambdabot> Num c => (c, c) -> c
04:35:07 <mauke> how is this ASCII?
04:35:25 <merijn> mauke: I think he wants to turn ascii chars into their binary encoding?
04:35:46 <mauke> unlikely
04:36:19 <Ziarkaen> It converts ASCII-padded, space-separated bits to an ASCII string.
04:36:30 <mauke> wtf is "ASCII-padded"?
04:36:32 <ion> λ> words "10101100 10100011 11100011" ^.. folded . base 2 . to chr
04:36:34 <ion> "\172\163\227"
04:37:30 <ion> or "10101100 10100011 11100011" ^.. to words . folded . base 2 . to chr
04:37:58 <saeidw> this is like magic to me
04:38:18 <saeidw> :t (^..)
04:38:20 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
04:38:27 <k00mi> ion: where is base from?
04:38:30 <merijn> saeidw: ^.. and to or Control.Lens magic
04:38:36 <mauke> it is magic
04:38:39 <merijn> @hoogle base
04:38:39 <lambdabot> Control.Exception.Base module Control.Exception.Base
04:38:39 <lambdabot> Text.Html base :: String -> HtmlAttr
04:38:39 <lambdabot> Text.XHtml.Strict base :: String -> HtmlAttr
04:38:45 <ion> k00mi: It’s in lens master, but alas, not in a released version AFAIK.
04:38:50 <merijn> :t base
04:38:51 <lambdabot> Not in scope: `base'
04:38:59 <saeidw> pretty cool
04:39:03 <k00mi> ion: ok
04:39:19 <ion> https://github.com/ekmett/lens/blob/master/src/Numeric/Lens.hs
04:39:25 <merijn> saeidw: Nice intro to Control.Lens is here: http://www.youtube.com/watch?v=cefnmjtAolY
04:39:40 <ion> &hd=1
04:39:43 <k00mi> thanks ion
04:39:51 <merijn> saeidw: Although that's probably pretty intimidating if you're not completely at home with typeclasses and types yet
04:40:01 <merijn> @where lens
04:40:01 <lambdabot> http://lens.github.com/ https://github.com/ekmett/lens
04:40:04 <saeidw> thanks, I haven't been paying attention to lenses much, I'm gonna watch that video
04:40:16 <merijn> @where+ lens http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
04:40:16 <lambdabot> It is forever etched in my memory.
04:40:20 <merijn> @where lens
04:40:20 <lambdabot> http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
04:40:24 <merijn> hmmm, my bad
04:40:32 <saeidw> I got comfortable with monads only recently, but this stuff is interesting
04:40:40 <merijn> @where+ lens http://lens.github.com/ https://github.com/ekmett/lens http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
04:40:40 <lambdabot> It is stored.
04:40:40 <ion> Also: http://youtu.be/cefnmjtAolY?hd=1
04:41:28 <merijn> saeidw: Lenses are basically getters+setters on steroids, acid and crack :p
04:42:06 <merijn> saeidw: I recommend also downloading the slides and pausing/manually checking the types of what he says
04:42:24 <saeidw> I think "<X> on steroids, acid and crack" can be labelled the Haskell Way by now :)
04:43:35 <nathanel_> can anyone explain what criterion wants to tell me when it aborts with 'user error (took too long to run: seed 4, iters 2)'?
04:47:24 <aristid> hey johnw, you pinged me half an hour ago?
04:47:37 <johnw> aristid: i found the answer in chat logs, but thanks for pinging back
04:47:53 <aristid> johnw: just out of curiosity: what was the matter?
04:48:00 <johnw> couldn't remember StdMethod
04:48:06 <aristid> ah!:)
04:48:18 <aristid> johnw: well StdMethod is documented:P
04:48:43 <aristid> http://hackage.haskell.org/packages/archive/http-types/0.7.3.0.1/doc/html/Network-HTTP-Types-Method.html
04:49:00 <johnw> i couldn't remember the name, or the package :)
04:49:07 <johnw> just that you had mentioned it
04:49:26 <aristid> not remember http-types? *sadface*
04:51:25 <typoclass> nathanel_: the benchmark is running too long?
04:53:01 <RVelez> Hello everyone, although I had heard the name "Haskell" as a programming language before, it really caught my attention after listening to a podcast on the web framework that is based upon it, Yesod. I've been studying and certifying in IT security, and have been recently learning Python. Yet  Haskell has somewhat distracted me by being a language that assists and promotes in writting correct/secure code which is very applicable to my 
04:53:04 <RVelez> I'm curious to know if anyone here has learned Haskell as their first programming lanaguage or if you all mostly started with something simpler like Python?
04:53:23 <mauke> >implying Python is simpler
04:55:01 <RVelez> my implying is totally based on the common notion that Python an easy language and that Haskell is very different to most languages to the point of being challenging even to seasoned programmers, yet I wonder if its just because its different that makes people resisten coming from other languages.
04:55:57 <zomg> RVelez: I think it's because haskell is oddly associated as being more mathy even though you don't really need math to use haskell just like you don't need it for any other language
04:55:57 <b_work> Haskell has a richer set of abstractions to play with
04:56:11 <zomg> and also because things like monads are supposedly hard
04:56:26 <zomg> hard mostly because people teach them using analogies like boxes and whatever
04:56:44 <RVelez> yes zomg, I remember hearing that exactly "monads" as being something that is hard to wrap your head around
04:57:19 <zomg> there are so many monad tutorials around which probably contributes to the perceived image
04:57:33 <b_work> monads are just monads, but they seem to inspire everyone's inner pedagogue
04:57:56 <zomg> yeah it's just a typeclass, I don't see why it needs to be dressed up
04:57:56 <tobias__> how can i get all combinations of two list: e.g. [1..3 [1..3] = [(1,1),(1,2)(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]?
04:58:17 <johnw> > sequence [[1..3],[1..3]]
04:58:18 <lambdabot>   [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
04:58:32 <tobias__> thank u
04:58:37 <johnw> oh,you wanted pairs?
04:58:49 <b_work> > zip [1..3] [1..3]
04:58:51 <lambdabot>   [(1,1),(2,2),(3,3)]
04:58:54 <b_work> oh rite
04:58:56 <johnw> > [ (x,y) | x <- [1..3], y <- [1..3] ]
04:58:57 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
04:59:14 <Maior> ooh that's cute
04:59:35 <fmap> > liftA2 (,) [1..3] [1..3]
04:59:37 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
05:00:06 <RVelez> The thing is that I've barely even started scratching the surface of Python, I can still switch to another language to become the first I really dive into and learn, but from general perception I was concluding that it could be daunting to select Haskell as that first language. Has anyone here learned Haskell as their first programming language though?
05:00:32 <srhb> > (,) <$> [1..3] <*> [1..3] -- pretty!
05:00:33 <johnw> RVelez: i really recommend letting Haskell be that language
05:00:34 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
05:00:46 <johnw> it's nicely suited to an extremely wide range of problems
05:01:01 <johnw> I now use it for what I use to use both C and Python for
05:01:13 <srhb> RVelez: Haskell is the first language I've really dove into. I can do modest Python and PHP (yuck!) hacking, but I never felt like I totally got it.
05:01:21 <wuttf> RVelez: Are you tied to any deadlines or something?
05:01:29 <johnw> > do { x <- [1..3]; y <- [1..3]; return (x,y) }
05:01:30 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
05:01:31 <srhb> RVelez: It's also been easier to motivate myself with Haskell because I've had much fewer "yuck!" moments her e:P
05:01:36 <RVelez> not at all wuttf, just self study
05:03:12 <wuttf> RVelez: Although I am learning Haskell as my zillionth language, I would say go for it. Learning easier languages can make you lazy, learning badly designed languages (PHP) can actually destroy your mind.
05:03:34 <srhb> I completely second that.
05:03:35 <b_work> > (zip [1..3] . repeat) =<< [1..3]
05:03:37 <lambdabot>   [(1,1),(2,1),(3,1),(1,2),(2,2),(3,2),(1,3),(2,3),(3,3)]
05:03:44 <quchen> wuttf: Offense taken, but you're right ;-)
05:04:05 <srhb> The problem is that humans are simple beings and tend to defent their time investment, whether or not it was objectively worth it.
05:04:06 <wuttf> quchen: Are you a PHP guy?
05:04:09 <zomg> wuttf: you get used to php though :p
05:04:11 <wuttf> quchen: Or VB? :D
05:04:17 <saeidw> I've got haskell type annotations as comments in my php source, still helpful :)
05:04:29 <johnw> > [1..3] >>= \x -> [1..3] >>= \y -> return (x,y)
05:04:31 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
05:04:34 <zomg> saeidw: you do know that there's an actual sort of standard for that in php? ;)
05:04:36 <quchen> wuttf: My first language was VB, my first big language was PHP. Haven't touched it years though, except for some command line hacks.
05:04:37 <srhb> I don't want to see what FP looks like in PHP.
05:04:39 <zomg> (which is not haskell style)
05:05:01 <zomg> srhb: it looks verbose
05:05:06 <saeidw> zomg, yeah, but these are just to help me during development
05:05:10 <srhb> Yes, I imagine so.
05:05:17 <saeidw> I wouldn't inflict them on anyone in a commit or anything :p
05:05:36 <zomg> I wrote a PHP parser and evaluator in Haskell for funzies
05:05:37 <zomg> :P
05:05:38 <RVelez> from that podcast I heard on Yesod, I know Haskell can be very capable for web application development which is one of the 2 areas I want to learning programming for. Yet the other is networking applications, I wonder how it fairs in that dept.
05:05:51 <b_work> RVelez: very well
05:05:51 <quchen> wuttf: Now I'm a C++ guy if I have to get stuff done (TM), and otherwise Haskell. I'm getting to the point where I could change that actually.
05:07:01 <wuttf> For me C/C++ and PHP were my firsts, I hate PHP until this day for blurring the architectural lines between template engine and programming language, it took me weeks to grok MVC because of that! I struggled a lot in my youth because the bad habits from PHP.
05:07:44 <quchen> wuttf: I didn't learn bad habits in PHP luckily
05:07:49 <b_work> "I struggled a lot in my youth because the bad habits from PHP." see folks? it destroys lives
05:07:58 <quchen> Probably because I was fiddling around with C++ a bit on the side, which taught me about type safety
05:08:19 <zomg> wuttf: it takes long to grok mvc because at least for php most of the guides are so shit
05:08:26 <quchen> C++ also taught me to overload functions in php (if(is_int($foo)) ...) haha
05:08:28 <zomg> written by people who don't understand it themselves
05:08:28 <wuttf> quchen: I kind of like C++ however baroque and overcimplicated is it. The ability to go ultra low level makes me feel home.
05:08:29 <zomg> :P
05:08:54 <quchen> The nice thing about PHP is that every library is already in it.
05:09:01 <quchen> Wanna paint pictures? It's already in there.
05:09:06 <zomg> yeah
05:09:08 <quchen> The not so nice thing about PHP is that it's full of crap.
05:09:29 <quchen> Gotta go for a bit, would love to start rambling about how all other languages are inferior to Haskell though ;-)
05:09:31 <wuttf> zomg: Thats another thing - the community.
05:09:45 <RVelez> So you guys mostly learned Haskell from what sources?
05:09:52 <srhb> RVelez: LYAH is a great start.
05:09:54 <johnw> @where lyah
05:09:54 <lambdabot> http://www.learnyouahaskell.com/
05:10:00 <RVelez> or what do you recomend for that matter
05:10:00 <wuttf> quchen: myself hate every programming language on Earth
05:10:08 <zomg> wuttf: php community is actually pretty nice
05:10:54 <wuttf> Every programming language is inferior compared to going out, owning a piece of land and breeding pigs or chickens but what can I do, I only have the knowhow to code
05:11:08 <wuttf> Also I own no land.
05:11:16 <RVelez> Oh I remember I saw that book on Amazon., so it is good then eh
05:11:17 <srhb> I think unless this discussion is concrete to the requirements of a "first language" we're about to end up in the usual, tired langX vs. langY talk. :)
05:11:23 <zomg> How is that better than coding? That sounds liek you get dirty in that job!
05:11:24 <zomg> ;>
05:11:24 <srhb> RVelez: Yes, it is.
05:11:29 <johnw> RVelez: it's a great place to start
05:12:39 <srhb> RVelez: It gives you all the basics you need to really get started, after that there are a wealth of options for gaining further knowledge while you're experimenting with your first programs. :)
05:12:48 <wuttf> zomg: I don't know I used to take care of approx 25 chicken I loved that, I guess I am a farmer deep down, but got sucked in by a techno black hole
05:13:05 <RVelez> thanks for the input guys
05:13:07 <zomg> RVelez: if you're interested in doing web stuff with haskell I've been kind of writing some stuff for that purpose, oriented for web developers who want to learn haskell
05:13:26 <zomg> wuttf: heh :)
05:13:42 <zomg> wuttf: go raise chickens in minecraft!
05:13:43 <zomg> :D
05:14:18 <wuttf> zomg: Not the same :D.
05:14:46 <zomg> Probably not. Most I know of such is from playing Sim Farm 10+ years ago =)
05:19:14 <b_work> RVelez: do you have good resources for learning yet?
05:19:27 <RVelez> I'll be heading out now, thanks again guys for the feedback, just stopped by to get input from those who actually use it. I'll be checking out the resource you recommended. Good day everyone
05:20:01 <RVelez> (yes b_work, I will see the book you guys recommended here)
05:20:15 <b_work> RVelez: I can also recommend "Programming in Haskell" by Graham Hutton
05:20:35 <b_work> an apprentice with hardly any programming experience here at work used it to get up to speed =]
05:20:50 <RVelez> alright b_work, I will check that one out.
05:20:55 <RVelez> good day
05:20:57 <b_work> ciao
05:21:45 <Lethalman_> b_work, ita?
05:23:15 <b_work> ita(lian)?
05:24:26 <Lethalman_> b_jonas, yes
05:24:48 <b_work> olandese
05:24:58 <Lethalman_> \o/
05:34:58 <Walther> Okay folks, I need to take a input file and parse through each line, and make a list of those lines as integers
05:35:06 <Adnauseam> also /names
05:35:09 <Adnauseam> err
05:35:27 <Walther> given that it is guaranteed that each line only has one integer, and er, that they indeed are integers
05:36:14 <merijn> mm_freak: Ping?
05:36:32 <quchen> I'm back! Where were we? PHP is awful and we should raise chicken?
05:44:28 <merlin_> Walther: so what problems are you having writing that?
05:47:49 * hackagebot imagemagick 0.0.1 - bindings to imagemagick library  http://hackage.haskell.org/package/imagemagick-0.0.1 (AlexanderVershilov)
05:48:20 <Walther> merlin_: not familiar with haskell IO at all? :P
05:48:49 <Walther> and all the tutorials i've sen so far seem to go a bit too much into semantics and pedantry on "why haskell does it this way", instead of "here's how to do it step by step" :P
05:50:02 <Adnauseam> read real world haskell
05:50:49 <merlin_> input/output chapter in LYAH tutorial is simple enough to follow and has a lot of examples
05:51:29 <merlin_> I guess you havent used do syntax yet?
05:52:50 <merijn> Walther: In my personal experience not learning *why* results in awful confusion later
05:53:34 <merlin_> what you want can be done in a single line, but would probably confuse you more than help you
05:57:45 <MasseR> merijn: True, but many times a quick first look to whet your appetite and/or keep your interest is good too
05:57:46 <Walther> merlin_: Sure, I'm okay with the "why", it's just that - well, there's still not a good tutorial that says "this is how to do it" with a simple example
05:58:08 <Walther> without trying to defend the "why" with half an essay
05:58:25 <MasseR> Many times you are left wondering after 12 pages of paper that is still even what I wanted/needed to know. Is there a proper goal after this
05:58:33 <Walther> for me it is enough that "haskell is functional -> you don't want silly side-effects or something that can change"
05:58:55 <merlin_> did you try http://learnyouahaskell.com/input-and-output ?
05:58:57 <MasseR> Especially since many times if you are a complete beginner on something, the essays could very well be written in latin
05:59:29 <spacekitteh> :t realToFrac
05:59:30 <lambdabot> (Fractional b, Real a) => a -> b
05:59:55 <merlin_> plentry of examples there
06:00:59 <merlin_> the function you want is readFile, and you have examples using it on that page
06:04:18 <frerich> I have a pool of threads all reading URLs from a Chan; at some point I would like to indicate that there will be no more items in the chan, so the worker threads can stop. Right now I do this by writing a 'magic' URL to the chan - if a thread reads this URL, it writes it back to the chan and then returns. This seems a little hacky - is there maybe a way to have a thread reading from a chan *and* from some MVar
06:04:18 <frerich>  - and the threads is unblocked as soon as either data is available or in the chan or the MVar not empty?
06:05:07 <srhb> Walther: (map read . lines) `fmap` readFile "yourfilename" :: IO [Int] -- is that what you want?
06:06:25 <Walther> srhb: sounds very much like what i want, thanks
06:06:58 <TheRedMood> PHEW!
06:07:06 <srhb> Walther: if you know all the individual functions (I don't know if you do) that composition is the first thing that should spring to mind, I think. :)
06:07:09 <TheRedMood> That was pretty awesome :D
06:07:20 <srhb> TheRedMood: What?
06:07:39 <TheRedMood> Iceland_jack helped me with Types in haskell. It was of huge help!
06:07:49 <Iceland_jack> :)
06:07:53 <srhb> Walther: If you want to make it safer (to account for format errors) you could look into reads or readMaybe.
06:09:12 <TheRedMood> johnw, I have a new friend :D His name is Iceland_jack
06:12:38 <marekw2143> when we have Num defined: data Num = Zero | Succ Nat, and Fibbonaci function defined:    F(Zero) = Zero; F(Succ(Zero)) = Succ Zero; F(Succ(Succ n) = F(Succ n) + F n; then how to evaluate: F(Succ (Succ( Succ 0))) ?
06:12:52 <mauke> that's not a valid definition
06:13:01 <marekw2143> mauke: why ?
06:13:11 <mauke> F is not a variable name
06:13:21 <marekw2143> let's assume F is function name
06:13:22 <mauke> Nat is undefined
06:13:25 <mauke> no, let's not
06:13:43 <mauke> + is undefined
06:13:50 <marekw2143> I'ts paraphrased sample from : Introduction to Functional Programming using Haskell
06:14:03 <mauke> maybe you should stop paraphrasing
06:14:27 <mauke> your syntax is inconsistent: F(Zero) vs. F n
06:15:10 <hpaste> marekw2143 pasted “Fibbonaci” at http://hpaste.org/80922
06:15:11 <Walther> srhb: I'm getting complaints from the compiler "couldn't match expected type"
06:15:35 <mauke> Walther: why are you pasting random fragments of error messages? ಠ_ಠ
06:15:44 <marekw2143> mauke: http://hpaste.org/80922 - there's Haskell code
06:15:56 <mauke> marekw2143: + is still undefined
06:17:36 <edwardk> @tell johnw i don't currently have Control.Functor.HigherOrder packaged in anything other than the original category-extras and in my unreleased 'indexed' package.
06:17:36 <lambdabot> Consider it noted.
06:18:01 <hpaste> marekw2143 pasted “Fibbonaci” at http://hpaste.org/80923
06:18:42 <mauke> marekw2143: ok, now where are you stuck?
06:18:51 <marekw2143> why ^^ complaints about ambiguous occurrence of '+' ?
06:19:17 <mauke> because there already is a (+) defined in the Prelude
06:19:19 <absence> how is getSplit from the Random monad meant to be used? call evalRand from the inside of a Random monadic computation?
06:19:41 <marekw2143> but I've defined (+) for Nat type
06:19:44 <marekw2143> didn't I?
06:19:45 <mauke> yes
06:20:25 <marekw2143> hmm, so I doubt sample in book is broken, maybe that sample implicity assumes something?
06:22:29 <t7`> is there a mathematical function for (1 -> 1) (2 -> 2) (0 -> 0) (-1 -> 0) (-2 -> 0)
06:22:45 <t7`> like abs0
06:22:58 <Entroacceptor> t7`: you just defined it?
06:23:10 <t7`> a total function
06:24:00 <mauke> what do you mean by "mathematical function"?
06:24:41 <fmap> edwardk: can I fold a list of strings in`"somefile" ^! act readFile . to lines'?
06:24:48 <Walther> still having problems with getting this right
06:24:48 <Walther> largeSum file = sum $ (map read . lines) `fmap` readFile file :: IO [Integer]
06:24:54 <Walther> > largeSum file = sum $ (map read . lines) `fmap` readFile file :: IO [Integer]
06:24:55 <lambdabot>   <hint>:1:15: parse error on input `='
06:25:07 <srhb> Walther: sum does not take a IO [Integer]
06:25:13 <mauke> Walther: why lines?
06:25:14 <mauke> srhb: ?
06:25:22 <mauke> Walther: oh, I see
06:25:36 <Walther> let's say i have a textfile with a list of integers
06:25:43 <Walther> separated by newlines
06:25:52 <srhb> Walther: (sum . map read . lines) `fmap` readFile file :: IO Integer
06:26:19 <srhb> Walther: If this confuses you, perhaps you need to read up on monadic IO.
06:26:30 <mauke> s/monadic //
06:26:35 <Walther> srhb: yes, i do need to read up on that
06:26:37 <Walther> and everything else
06:26:50 <mauke> people need to stop saying "monad" when they don't mean it
06:27:02 <Entroacceptor> t7`: abs0(x) = H(x)*x; abs0 : R->R, where H is the Heavyside step function?
06:27:02 <fmap> actually I expected `"somefile" ^! act readFile . to lines ^.. folded . to read' to work :[
06:27:02 <srhb> mauke: Whatever. I meant it.
06:27:26 <mauke> your solution uses functorial IO, not monadic IO, though
06:27:28 <fmap> (parenthesized)
06:27:55 <srhb> mauke: The IO monad is certainly relevant, and it is the goto google search for a chapter that explains the topic.
06:28:05 <t7`> Entroacceptor, thats what i need :D
06:28:06 <mauke> no, the IO functor is relevant
06:28:18 <mauke> well, actually IO itself is relevant
06:28:19 <t7`> who needs if statements ?
06:28:34 <mauke> the Monad instance less so
06:29:06 <mauke> t7`: abs0(x) = max(0, x)
06:29:10 <srhb> What's the definition of fmap for IO?
06:29:32 <mauke> probably implementation specific
06:29:32 <t7`> is max allowed ?
06:29:36 <mauke> t7`: what
06:29:50 <t7`> its not on my calculator
06:30:01 <mauke> get a better calculator
06:30:13 <t7`> windows calculator
06:31:37 <frerich> t7`: Does your calculator have an 'abs' function?
06:32:49 <frerich> If so, you could maybe use f(x) = (x + abs(x)) / 2
06:33:21 <marekw2143> mauke: ok, I've added   deriving (Show, Eq, Ord)
06:33:21 <marekw2143> , thanks man!
06:34:10 <t7`> i wonder what the smallest set of operators needed to define every possible (Int -> Int) are
06:34:14 <mauke> marekw2143: ?
06:34:27 <mauke> t7`: none
06:34:27 <marekw2143> data Nat = Zero | Succ Nat
06:34:28 <marekw2143>   deriving (Show, Eq, Ord)
06:34:34 <mauke> t7`: you can just enumerate them
06:34:35 <t7`> can you embed a turing maching tape in an Int?
06:35:02 <frerich> t7`: Your questions are confusing me
06:36:00 <t7`> enumerate them how ?
06:36:01 <edwardk> fmap: ^! act readFile . folding lines
06:36:58 <Walther> Uh, why am i getting "not in scope"? it's like it is not recognizing the filename
06:37:17 <edwardk> fmap: i don't currently have any combinators for extracting multiple targets from a  MonadicFold
06:38:13 <geekosaur> what's not in scope from where?
06:39:13 <Walther> <interactive>:21:10: Not in scope: `problem0013_list'
06:39:55 <Walther> largeSum file =  (sum . map read . lines) `fmap` readFile file :: IO Integer
06:40:21 <srhb> Walther: That name is not mentioned anywhere on that line.
06:40:22 <geekosaur> apparently I need to figure out how to phrase that so you pwill know to provide actually useful information; that means nothing whatsoever to me without context
06:40:42 <Walther> srhb: eh, yes it is, as the variable 'file'
06:40:55 <srhb> Walther: Then file is not a String.
06:40:58 <srhb> :t readFile
06:40:59 <lambdabot> FilePath -> IO String
06:41:01 <Walther> i run the command as "largeSum problem0013_list"
06:41:14 <srhb> Right, problem0013_list is not a String.
06:41:19 <Walther> Ah, helped to run it as "largeSum 'problem0013_list'"
06:41:25 <srhb> What.
06:41:43 <srhb> Presumably you mean largeSum "problem0013_list"
06:41:50 <Walther> that
06:41:55 <srhb> Huge difference.
06:42:01 <mauke> t7`: by listing every argument/result pair
06:42:03 <Walther> just failing at embedded citation
06:42:16 <Walther> er, nested
06:42:17 <t7`> mauke, no pattern matching allowed
06:42:27 <Walther> > largeSum file =  (sum . map read . lines) `fmap` readFile file :: IO Integer
06:42:28 <t7`> only variable abstraction
06:42:29 <lambdabot>   <hint>:1:15: parse error on input `='
06:42:37 <Walther> oh, extra space there
06:42:47 <Walther> > largeSum file = (sum . map read . lines) `fmap` readFile file :: IO Integer
06:42:48 <lambdabot>   <hint>:1:15: parse error on input `='
06:43:14 <mauke> t7`: then I need ==
06:43:44 <TheRedMood> Can anyone read this?
06:43:51 <Botje> yes.
06:43:54 <TheRedMood> Good :D
06:45:10 <srhb> Walther: lambdabot supports neither IO nor definitions of that kind, which is why you get an error on the =. you can do let largeSum file = ... in largeSum "foo"
06:45:45 <johnson_> Morning all. I've often had to write my own function to divide a list into chunks. I always wondered why Haskell doesn't have one. Today I found this page http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/Argument_handling, that uses it as an example, but casually says that leaving it out of the prelude was "semi-intentional". Does anyone know why?
06:46:06 <mauke> johnson_: what's wrong with Data.List.Split?
06:47:12 <johnson_> mauke: goddamnit, i knew it must be in there somewhere. still, know why it was "intentionally" left out of the prelude?
06:47:50 <geekosaur> johnson_, because there are a lot of different ways to do it.  you might look at the number of splitters in Data.List.Split
06:48:21 <typoclass> johnson_: i think it's largely historical. i wouldn't read too much into it
06:49:15 <typoclass> geekosaur: i dunno, i think there is one case that covers "80%" with all the other cases in the remaining 20%
06:50:08 <johnson_> If the committe would, would they get rid of the prelude and have everything in modules? Like why is there a specific version of fmap just for lists?
06:50:17 <mauke> typoclass: show me that one case :-)
06:50:50 <johnson_> typoclass: the Data.List.Split docs do say that one very common case is the simply chunk function
06:50:52 <typoclass> mauke: i thought split ':' "abc:def:ghi" -> ["abc", "def", "ghi"]
06:51:55 <ghorn> anybody know if shared-libraries-by-default is in 7.6.2?
06:52:14 <mauke> typoclass: what are the results for "ab::cd", ":ab:cd", "ab:cd:", "", ":", and ":a:"?
06:53:18 <johnson_> mauke: but there's no questions like that for chunk? apart from the length of the final element
06:54:44 <TheRedMood> Wow
06:54:57 <TheRedMood> So you can also define functions with the ´´syntax ?
06:55:01 <geekosaur> johnson_, there is a tension between generality and usability.  you could just provide (f)map, but then you will get strange errors (or worse, no errors but unexpected results) if you got your types wrong.  si nce list manipulation is very common, it gets a function which will immediately throw a more comprehensible error if you got your types wrong
06:56:05 <typoclass> mauke: i mean splitOn, or something very similar http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html i don't think that splitOn has unsolvable problems with any of the inputs you proposed
06:56:33 <mauke> typoclass: what?
06:56:56 <mauke> I'm asking what exactly you meant. "or something very similar" is not helpful
06:57:12 <mauke> also, splitOn doesn't even have a compatible type
06:57:30 <npl> hello, I have code like this: " ... let x = ... in ... ". I want x to be computed before everything which follows after the "in". I put "{-# LANGUAGE BangPatterns #-}" at the top of the source code and I replaced "let x" with "let !x", but it does not help, did I forget something?
06:58:36 <mauke> npl: why do you want x to be computed before?
06:59:18 <typoclass> mauke: i'm saying that splitOn is the function that you want most of the time, and it'd have been plausible that the Prelude authors had included splitOn. the other variants could remain in D.L.Split. i am aware that i described a function with an "a" argument while splitOn has an "[a]" argument, that's why i said 'or similar'
07:00:40 <npl> mauke: for no specific reason
07:01:48 <patoseghe95> ciao
07:01:51 <patoseghe95> !list
07:01:51 <monochrom> patoseghe95: http://okmij.org/ftp
07:06:36 <npl> mauke: did I make a mistake?
07:06:48 <hpaste> marekw2143 pasted “Pos” at http://hpaste.org/80924
07:07:59 <mauke> npl: how should I know?
07:08:11 <marekw2143> why does pasted ^^ code results in "Ambiguous occurrence `+' when trying to do: showPos ( One + One ) ?
07:08:48 <npl> mauke: I mean my approch above to evaluated x strictly
07:09:18 <mauke> npl: yes
07:09:46 <mauke> marekw2143: <mauke> because there already is a (+) defined in the Prelude
07:09:55 <merijn> monochrom: Do you just link people saying "!list" to Oleg to confuse them? :>
07:10:01 <marekw2143> mauke: but is it defined for "Pos" type?
07:10:12 <mauke> marekw2143: no
07:10:14 <npl> mauke: could you tell me what I did wrong?
07:10:22 <mauke> npl: I don't know whether you did something wrong
07:10:23 <marekw2143> but I've defined (+) for "Pos" type
07:10:31 <mauke> npl: you're refusing to tell me what is going on
07:10:38 <mauke> marekw2143: and?
07:10:41 <geekosaur> not as you wrote it, but that's not the point.  you have two (+)s in scope, you need to specify which one you want.  Haskell does not do C++-style overloading
07:11:08 <marekw2143> mauke: so I thought that haskell will infere which version of "(+)" to use
07:11:13 <geekosaur> you can't just define a new (+) for your type and expect it to be "folded in"
07:11:20 <mauke> marekw2143: you thought wrong
07:12:13 <TheRedMood> Haha
07:12:19 <marekw2143> mauke: :), ok, how can I make so that when using (+) in context of Pos type my definition of (+) would be used, and when using with Num the Prelude's one definition of (+) woudl be used ?
07:12:19 <TheRedMood> Just saw my first recursive function in haskell
07:12:21 <geekosaur> :t (+)
07:12:22 <TheRedMood> That was nice :D
07:12:23 <lambdabot> Num a => a -> a -> a
07:13:07 <beaky> hello
07:13:17 <beaky> does haskell have first class types?
07:13:20 <marekw2143> ohh, so I have to provide so that Pos is instance of Num ?
07:13:22 <hiptobecubic> hi beaky
07:13:51 <aristid> beaky: no.
07:14:00 <hiptobecubic> What would you do with them?
07:14:09 <geekosaur> if you insist on using (+), yes.  note that you have to provide more than just (+) to be an instance of Num, and it will probably lead to other "surprises"
07:14:12 <aristid> beaky: but mostly it depends what "first class types" means to you
07:14:21 <geekosaur> I would not recommend it
07:15:02 <beaky> norvig said first class types replaces the sstrategy pattern
07:15:13 <mauke> norvig doesn't know shit
07:16:08 <jfredett> Lots of things claim to do lots of things, the plain and simple fact is TIMTOWTDI, beaky.
07:16:19 <S11001001> marekw2143: don't implement Num unless you can satisfy the laws. would be best to simply use a different symbol, though
07:16:20 <beaky> TIMTOWTDI?
07:16:26 <beaky> ah
07:16:29 <beaky> there is more than one way to do it
07:16:42 <npl> mauke: for example at the beginning I calculate a lot of vectors and lists and I'd like to know how much RAM this costs if all of them would be fully evaluated
07:18:08 <mauke> npl: then ! wouldn't help you anyway
07:18:19 <mauke> it only evaluates to WHNF, not fully
07:18:58 <jfredett> Random question for any knowers of Data.Aeson -- is there a generic instance for To/From JSON for Data.Map (or some equivalent structure). There's a PR I found  that talks about a couple ways, I guess I'm looking for an external package that provides it, or something.
07:19:05 <npl> for lists it only calcualtes the spine? and for vectors?
07:20:02 <mauke> npl: no, not the spine
07:20:13 <geekosaur> haskell is not c++, neither is it java; trying to pretend it is will only make your life difficult
07:20:15 <mauke> just the first constructor
07:21:00 <jfredett> geekosaur: that's true, but the underlying software patterns do translate, naturally though, they translate to different structures.
07:21:35 <jfredett> Perhaps a better thing to say is "First Class Types are how you say 'Strategy Pattern' in Functional Languages" (it's still wrong, but less so)
07:21:37 <geekosaur> right, my point is you need to do that translation, you can't just pretend they work directly or try to brute-force them into working
07:21:54 <`nand`> would you parse, in the context of natural numbers, x!y as x! * y ?
07:22:06 <jfredett> if anything first-class functions are how you say strategy, but I digress
07:22:09 <jfredett> `nand`: yes.
07:22:43 <npl> mauke: so if the list has at least one element it would evaluate to _ : ... ?
07:22:48 <jfredett> I don't know how else I could parse it, !y doesn't mean anything to me, and ! is unary...
07:23:01 <jfredett> and you said they're all Nats.
07:23:07 <jfredett> so it's not `not`
07:23:09 <mauke> npl: _ : _
07:23:35 <mauke> I'd write it as (:) _ _, actually
07:23:57 <mauke> just like (,) _ _ or any other two-field constructor
07:24:10 <npl> ok thanks =)
07:24:26 <srhb> What does that mean? I thought nothing but (:) was evaluated. Isn't that what "lazy in both arguments" means?
07:25:07 <srhb> Or is that exactly what is meant by (:) _ _ ?
07:25:30 <geekosaur> yes.  we don;t know or care what the _s are (they're wildcards)
07:25:46 <srhb> Ah, okay, good. Then I wasn't as confused
07:26:15 <srhb> > let foo (_:_) = "true" in foo [undefined]
07:26:17 <lambdabot>   "true"
07:26:18 <srhb> Indeed.
07:27:23 <npl> if I want to fully evaluated x before what comes after the "in" I need to use "let !x = deepseq (computingfunction data) in ... "?
07:28:23 <srhb> x `deepseq` (computingFunction x) ?
07:33:04 <Lethalman> > let foo x = x `seq` 1 in foo [undefined]
07:33:06 <lambdabot>   1
07:33:22 <Lethalman> > let foo (x:_) = x `seq` 1 in foo [undefined]
07:33:24 <lambdabot>   *Exception: Prelude.undefined
07:33:30 <Lethalman> srhb, ^^
07:33:54 <Lethalman> so deepseq should work in the first case
07:36:01 <Lethalman> :t deepseq
07:36:03 <lambdabot>     Not in scope: `deepseq'
07:36:03 <lambdabot>     Perhaps you meant `rdeepseq' (imported from Control.Parallel.Strategies)
07:36:10 <Lethalman> ah
07:36:45 * Lethalman didn't want to install deepseq, but ... :P
07:38:04 <yogsototh> Dear Haskell people, is there a way to use the (:) operator for another usage. It is declared in GHC.Types as data [] a = ... | a : [a].
07:38:30 <merijn> yogsototh: Why do you want that?
07:39:30 <yogsototh> Just for fun really. I would like to know whether it is possible to make a DSL using a similar syntax as haml
07:40:13 <fmap> yogsototh: (:) isn't an operator, it's constructor
07:40:54 <yogsototh> This is what I feared. Thanks fmap.
07:43:58 <msxx> why ambiguous error in here?   [undefined] `deepseq` 1
07:44:24 <beaky> http://ideone.com/80QHHv how do I model the fact that eldermages can do everything that the other mages can?
07:45:21 <msxx> nevrmind
07:45:31 <msxx> [undefined :: Int] `seq` 1 :: Int
07:49:39 <yogsototh> beaky: data Spell = Fire | Water | Earth | Air
07:50:09 <yogsototh> beaky: castSpell :: Mage -> [Spell]
07:50:19 <S11001001> yogsototh: Heart
07:50:26 <beaky> ah
07:50:30 <johnson_> I can't get my head around how guard will interact with IO. If I guard, is that like when, or does it cancel the entire operation? Cancel the operation only from that point onwards?
07:50:44 <merijn> johnson_: Only from that point on
07:51:22 <yogsototh> beaky: Just how I would do it, not sure it is the best way thought.
07:51:28 <johnson_> merijn: cheers
07:51:49 <mauke> @src guard
07:51:49 <lambdabot> guard True  =  return ()
07:51:49 <lambdabot> guard False =  mzero
07:51:59 <mauke> @src IO mzero
07:51:59 <lambdabot> mzero       = ioError (userError "mzero")
07:52:09 <mauke> throws an exception
07:52:21 <RichyB> @src [] mzero
07:52:21 <lambdabot> mzero = []
07:53:11 <b_work> a function/map is also referred to as a functor in a book I'm reading, but an endomap (a -> a) is clearly not a Functor right?
07:53:29 <applicative> right
07:53:53 <applicative> b_work: for every Functor, there's a map function, fmap, of course
07:54:00 <b_work> yes
07:54:17 <applicative> b_work: the implemenation of Functor for something is just: defining a function, viz fmap
07:54:43 <b_work> okay yeah, makes sense like that
07:55:31 <applicative> b_work: Endo a = Endo (a -> a) can't be a Functor, since fmap cant be dfined, itd have to be endofmap :: (a -> a) -> (a -> b) -> (b -> b)
07:56:13 <b_work> yeah
07:56:34 <applicative> or endofmap :: (a->b ) -> Endo a -> Endo b as you would write it
07:57:50 <b_work> I had type Endo a = a -> a, but this is incorrect?
08:00:08 <b_work> where `(+ 2) :: Endo Int` would be an endomap from domain Int to codomain Int
08:00:19 <b_work> please do correct me if this makes no sense ^^
08:07:51 <S11001001> I'd suggest keeping the newtype
08:08:00 <S11001001> newtype Endo c a = c a a
08:08:18 <S11001001> instance Category c => Monoid (Endo c a) where...
08:08:56 <S11001001> can you say that without the newtype?
08:09:23 <n-dolio> Not sensibly.
08:09:54 <fragamus> is there a way to modify a list element given an index and a (a->a)     some kind of lens perhaps?
08:11:35 <fragamus> @hoogle [a]->Int->(a->a)->[a]
08:11:35 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
08:11:35 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
08:11:35 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
08:11:45 <merijn> Sounds like something that wants an indexed traversal?
08:11:54 <merijn> But I'm still not yet a lens wizard
08:12:48 <zomg> Harry Potter and the Lens Wizard
08:15:49 <wuttf> As a newcomer these custom monads everywhere seem like a overcomplicated stuff which only serve to raise my blood pressure
08:16:22 <wuttf> I am wrestingling with one for like an hour
08:16:31 <wuttf> wrestling*
08:17:11 <fmap> > [1..10] & element 3 *~ 10
08:17:12 <lambdabot>   [1,2,3,40,5,6,7,8,9,10]
08:17:30 <fmap> fragamus: ^
08:17:38 <fragamus> love it
08:17:47 <fmap> yeah, it's so easy
08:18:19 <bgamari_> In what sense is Control.Monad.Trans.RWS.Strict strict?
08:18:37 <fmap> > replicate 3 [1..10] & (element 1 . element 3) *~ 10
08:18:39 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[1,2,3,40,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10]]
08:18:42 <fragamus> i want to run an arbitrary function on the element
08:18:51 <amiller_> anyone have experience with this paper http://www.cs.ox.ac.uk/people/daniel.james/sorting/sorting.pdf
08:18:57 <Nisstyre> https://www.google.ca/search?channel=fs&q=haskell+%22everything+is+a+function%22
08:19:01 <amiller_> i'm trying to work through the examples using recursion-schemes rather than the code that came with the paper
08:19:08 <Nisstyre> hmm, 989,000 results
08:19:16 <Saizan> bgamari_: >>= is strict over the tuple holding the stuff
08:19:21 <Nisstyre> including ibm.com ...
08:19:23 <fmap> fragamus: (%~) instead of (*~) then
08:19:31 <amiller_> the main question i have is about what's the equivalent of "data (f :*: g) a = As { outl ∷ f a, outr ∷ g a }"
08:19:33 <xlr> where is *~ etc defined?
08:19:41 <fmap> > [1..5] & element 3 %~ succ
08:19:42 <lambdabot>   [1,2,3,5,5]
08:19:42 <merijn> xlr: Control.Lens
08:19:43 <bgamari_> Saizan, ahh, alright, but not the state?
08:19:52 <merijn> xlr: See also
08:19:54 <merijn> @where lens
08:19:54 <lambdabot> http://lens.github.com/ https://github.com/ekmett/lens http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
08:20:04 <fragamus> :t %~
08:20:05 <lambdabot> parse error on input `%~'
08:20:08 <xlr> merijn: ty
08:20:27 <fmap> > [1..5] & over (element 3) succ -- if you don't like (%~)
08:20:28 <merijn> fragamus: Operators should be surrounded with parens
08:20:29 <lambdabot>   [1,2,3,5,5]
08:20:33 <amiller_> i guess it's basically just about a product type
08:20:33 <merijn> :t (%~)
08:20:35 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
08:20:45 <Nisstyre> wuttf: the point of instantiating Monad for your own custom data types is so that you can reduce the amount of dissimilar code, not increase it
08:21:14 <bgamari_> Is a StateT s (Reader r) more strict that RWS?
08:21:16 <amiller_> actually now i think i should be using distPara :: Unfoldable t => Base t (t, a) -> (t, Base t a)
08:21:21 <bgamari_> In that the state will be strict?
08:21:35 <fragamus> :t succ
08:21:36 <lambdabot> Enum a => a -> a
08:22:47 <kyle__> So, doing project eulers to learn haskell, and I'm getting an out of memory error.
08:22:57 <Saizan> bgamari_: nope
08:23:10 <kyle__> Now, while I know that indicates I'm solving it the wrong way, I want to know how to overcome this, because I've got 10GB in this machine, and it didn't even brush a gig of memory usage.
08:24:01 <Nisstyre> kyle__: what was the exact error message?
08:24:02 <ghorn> kyle__: you might also be solving it the right way but without enough strictness
08:24:36 <kyle__> The exact message is: out of memory (requested 1048576 bytes)
08:25:31 <kyle__> If I try and do something like -H4g I get a similar out of memory error just compliing
08:26:40 <ghorn> kyle__: you could try profiling memory usage and find what part is out of control http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
08:27:15 <kyle__> ghorn: I actually boiled it down to just a summation being the problem (triangle numbers).
08:27:33 <kyle__> A very very large summation.
08:27:53 <tromp> @src sum
08:27:54 <lambdabot> sum = foldl (+) 0
08:28:22 <tromp> @src sum'
08:28:22 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:28:47 <tromp> :t foldl'
08:28:48 <lambdabot> (a -> b -> a) -> a -> [b] -> a
08:30:15 <ghorn> kyle__: if you can make a small example you could put it on hpaste.org
08:31:11 <kyle__> ghorn: Even just sum [1..10000000] will do it.
08:31:21 <ghorn> ah
08:31:54 <kyle__> ghorn: The box has swap, in addition to 1GB of ram.  It really should be able to do a simple sum like that, even if it's a memory inefficient way (this is what I boiled the problem down to).
08:33:09 <ghorn> kyle__: it seems tromp is onto the problem
08:33:25 <donri> kyle__: try with foldl' instead
08:33:48 <kyle__> I meant 10GB, not one.  but ok.
08:33:57 <fmap> kyle__: `sum [1..10000000]' defines a huge thunk (..((0 + 1) + 2) ...) and never evaluates it
08:34:02 <ghorn> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
08:34:46 <tromp> would sum be better off being defined as foldl' (+) 0 ?
08:34:48 <fmap> kyle__: if you define `sum' = foldl' (+) 0' that would be a constant memory sum
08:35:00 <kyle__> Right, but it dies out way before it even hits a gig of memory usage.
08:35:12 <fmap> yes
08:36:03 <fmap> kyle__: you can increase stack space with +RTS -KSTACK_SIZE
08:36:04 <kyle__> OK, I've got those bookmarked to read later.  My kids aren't going to let me program anymore this morning :)
08:36:08 <kyle__> Thanks all!
08:38:46 <romildo> In an application I am writing, I need to download a web page from a site that requires user authentication (user/password login). How can it be done from Haskell?
08:39:20 <luite> romildo: use a http client library like HTTP or http-conduit
08:39:23 <SirStean> Can anybody help me find the error
08:39:24 <SirStean> http://hpaste.org/80926
08:39:36 <SirStean>   Couldn't match expected type `IO CAutomata'                 with actual type `CAutomata'     In the return type of a call of `CAutomata'
08:40:02 <luite> romildo: at least the latter has some options to keep cookies around in a browsing session
08:40:36 <geekosaur> SirStean, it's pretty obvious.  if the return type is IO CAutomata then the result can't simply be a CAutomata on line 8
08:41:49 <SirStean> how can i fix it.
08:42:09 <SirStean> when i write IO CAutomata as reutrn type this error came: Cellular.hs:71:42: Not in scope: data constructor `IO'
08:42:30 <geekosaur> :t return
08:42:31 <lambdabot> Monad m => a -> m a
08:42:46 <hpaste> romildo pasted “openURI” at http://hpaste.org/80927
08:43:15 <romildo> luite, I am already using Network.Browser.browse to download pages that does not require authentication: http://hpaste.org/80927
08:43:56 <romildo> luite, how this code can be changed to authenticate with a given user/password before downloading the page?
08:44:06 <b_eating> why is Endo defined `newtype Endo a = Endo { appEndo :: a -> a }`, instead of `type Endo a = a -> a`? to allow CPS?
08:44:06 <bscarlet> Why is sum defined with foldl instead of foldl'?
08:44:22 <b_eating> hm we're not related are we? \o/
08:44:50 <geekosaur> the question is, what kind if authentication?  if it's HTTP basic auth, simply use a URI of the form:  http://user:password@hostname[:port]/...
08:44:59 <geekosaur> if it's something more involved then you'll need actual code
08:45:04 <elliott> b_eating: you can't give a Monoid instance for the latter
08:45:06 <elliott> well you can
08:45:07 <luite> romildo: depends on the auth type
08:45:13 <elliott> but it'll overlap with the Monoid a => Monoid (r -> a) monoid instance
08:45:19 <elliott> and it requires flexible instances
08:45:25 <b_eating> okay
08:45:40 <SirStean> do i have to work with return?
08:46:04 <luite> romildo: is it basic http auth? or do you enter username/pass in a form?
08:46:13 <n-dolio> Monoid a => Monoid (a -> a) used to be the instance that was defined.
08:46:34 <romildo> geekosaur, luite, I do not know much about the http protocol. I enter the username/pass in a form.
08:46:48 <S11001001> what
08:47:24 <geekosaur> then you probably need to write code that does auth the way the form expects.  you'll need to check eith the site on that; it could range from a simple cookie auth to something like openid that will need a lot of client side infrastructure
08:47:32 <elliott> n-dolio: what did it even use the Monoid on the argument for?
08:47:48 <n-dolio> Oh, maybe it wasn't Monoid a.
08:48:03 <n-dolio> Just instance Monoid (a -> a).
08:48:30 <edwardk> yeah that one is more brittle for inference though
08:48:50 <edwardk> instance a ~ b => Monoid (a -> b) would work better, but isn't haskell 98
08:49:00 <geekosaur> SirStean, if you're using randomRIO then it needs to be in IO.  you *could* pass the random seed in from outside but at some point you'll need IO to get a truly random seed unless you want to hardcode an initial seed
08:49:02 <n-dolio> Neither is Monoid (a -> a).
08:49:04 <edwardk> sure
08:49:09 <romildo> geekosaur, luite, one of the sites is http://www.manicomio-share.com/
08:49:38 <n-dolio> And type families didn't exist back then.
08:49:49 <geekosaur> romildo, this is not a haskell-specific issue, even; dealing with non-http auth is always difficult
08:53:14 <SirStean> http://hpaste.org/80928 now with return , but the error ------------Couldn't match expected type `State' with actual type `IO Bool' In the expression: stat----------- comes
08:53:38 <geekosaur> romildo:  so this one is relatively simple, you connect to the site without auth and you manipulate the form to auth to it (and almost certainly need to deal with cookies).  I see a field named "username", a field named "password", and a button with no name but a value of "Login"
08:55:53 <johnson_> When I depend on that module in my cabal file, if its version number is 0.something, I'm going to have to use ==, because the API can change at any point on a 0.something can't it?
08:59:00 <mysticc> Is there something similar to Coq's haskell extraction for agda?
08:59:15 <romildo> geekosaur, I will try that. It would be nice if I could find examples of how to deal of cookies using HTTP.
08:59:29 <SirStean> http://hpaste.org/80929  What i am doing wrong?
09:00:13 <geekosaur> I haven't done a lot of http scripting (in haskell or any other language, aside from a tiny bit of python) so can't help much, sorry'
09:00:27 <tac-tics> mysticc: I don't believe so, but you can actually compile Agda if you're clever.
09:00:30 <djcoin_> mysticc: newbish question but, was does extraction mean in fact ? (never used coq)
09:00:47 <tac-tics> djcoin_: Coq allows you to turn proofs into Ocaml (or Haskell) code.
09:01:08 <tac-tics> djcoin_: (basically, it just translates your program to either language and strips out all the fancy type information)
09:01:14 <djcoin_> Is is really usefull/efficient ?
09:01:18 <djcoin_> useful *
09:01:28 <geekosaur> SirStean, you haven't indicated the error, but at a guess stat is in IO and you need to lift the code.  and, as I suspected from your first question, you;re trying to do this without any understanding of how IO works
09:01:57 <tac-tics> djcoin_: I don't expect it to be particularly efficient if at all
09:02:02 <SirStean> its my first use of IO
09:02:07 <tac-tics> The important thing you get out of it is correctness.
09:02:07 <djcoin_> I guess it can't take advantages of extra librairies and stuff except if you prove them before and even, how would you introduce them to coq
09:02:21 <djcoin_> Yeah I guess
09:02:29 <SirStean> Couldn't match expected type `Bool' with actual type `IO Bool'
09:03:18 <tac-tics> SirStean: Try adding a "return" to the last line of your code
09:03:22 <mysticc> tac-tics: Is there any other way of proving correctness of haskell programs using theorem provers otherthan extracting code?
09:03:25 <tac-tics> (whatever the boolean value you're returning is)
09:03:36 <Eelis> djcoin_: i think coq extraction to ocaml is a lot more mature than coq extraction to haskell. i think coq extraction to ocaml has been used for some things, like a formally verified finger tree implementation
09:04:03 <mysticc> Eelis: There is even a formally verified c compiler
09:04:09 <tac-tics> mysticc: not really. Not through a program at least, afaik
09:04:20 <Eelis> mysticc: yeah, but i don't know if anybody uses that
09:04:38 <Eelis> mysticc: for Clean (which resembles Haskell), there is http://wiki.clean.cs.ru.nl/Sparkle . i don't know if there's a Haskell equivalent
09:05:03 <djcoin_> Eelis: ok, thanks
09:05:16 <mysticc> Eelis: I dont mind if it don't resemble haskell. What I want is to prove correctness of some of my haskell code
09:05:45 <SirStean> a return in the where statement?
09:05:55 <Eelis> mysticc: well, if you want to prove correctness of Haskell code, then if i link to a tool to prove correctness of non-Haskell code, then you kinda /should/ mind the difference between the two languages :P
09:06:42 <tac-tics> mysticc: generally speaking, partial languages are a pain in the ass to do proofs of correction about.
09:07:22 <Eelis> yep. proving partial correctness can still be useful though
09:07:38 <tac-tics> mysticc: because of things like..... in haskell, if I have x :: Int, I can show you an expression where x - x /= 0
09:07:42 <earthy> http://www.cse.chalmers.se/~nad/publications/danielsson-et-al-popl2006.html
09:08:36 <earthy> Sparkle... man...
09:08:41 <earthy> that brings back memories
09:08:45 * tac-tics is skeptical of any useful findings in an article with that kind of extract
09:08:48 <tac-tics> Even though it's totally true
09:08:51 <fragamus> lens is making me very happy
09:09:21 <earthy> (Sparkle's development was started in 1998-ish with Maarten de Mol as my roommate)
09:09:41 <fragamus> oh is that the mpeg decoder
09:09:52 <SirStean> ( [(stat,x,y) | stat <- randomRIO(True,False), x <- [1..size], y <- [1..size]]), isnt the result a IO [(Bool,Int,Int)]??????
09:10:15 <Eelis> earthy: i attended his thesis defense :)
09:10:36 <geekosaur> SirStean, what do you think the type of stat is?
09:10:47 <SirStean> IO Bool
09:11:09 <geekosaur> so why do you expect it to magically become simply Bool?
09:11:35 <SirStean> but i need a IO [(Bool,Int,Int)]
09:11:39 <edwardk> fragamus: oh?
09:11:41 <SirStean> how can i make it?
09:11:51 <edwardk> fragamus: sadly no mpeg decoder in lens yet ;)
09:12:15 <msxx> :t randomRIO
09:12:16 <lambdabot> Random a => (a, a) -> IO a
09:12:18 <edwardk> shachaf and elliott keep insisting it is out of scope ;)
09:12:20 <fragamus> i remember something called sparkle as an mpeg thing   anyhow offtopic
09:12:27 <geekosaur> :t [(stat,x,y) | stat <- randomRIO(True,False), x <- [1..size], y <- [1..size]]
09:12:27 <geekosaur> mm, did we lose a bot?
09:12:27 <geekosaur> anyway I see a [(IO Bool,Int,Int)] there
09:12:28 <lambdabot>     Not in scope: `size'
09:12:28 <lambdabot>     Perhaps you meant one of these:
09:12:28 <lambdabot>       `IM.size' (imported from Data.IntMap),
09:12:41 <fragamus> edwardk you made lens?
09:12:46 <edwardk> fragamus: yes
09:12:59 <fragamus> well you are very insightful
09:13:00 <SirStean> so no way of getting a IO [(Bool,Int,Int)] with random Bools?
09:13:03 <msxx> uhm wouldn't that make stat Bool type
09:13:09 <edwardk> fragamus: did you see the video yet?
09:13:12 <elliott> edwardk: It's not an isomorphism!
09:13:13 <elliott> It's lossy!
09:13:29 <geekosaur> SirStean, there is, but not quite the way you're trying to do it
09:13:54 <fragamus> i saw one but the slides had print that was so small i could not read them
09:14:10 <edwardk> fragamus: the slides are linked from the description of the video
09:14:12 <fragamus> I am just taking my first steps to understanding lens
09:14:18 <fragamus> oh!!!
09:14:36 <edwardk> Talk: http://youtu.be/cefnmjtAolY?hd=1 Slides: http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf
09:14:45 <fragamus> beautiful
09:15:39 <edwardk> if i'm hard to understand, i've close captioned the first half of it by hand
09:16:01 <fragamus> you are not hard to understand
09:16:30 <edwardk> i should get back to closed-captioning the rest of the video eventually
09:16:38 <fragamus> this lens thing is what makes haskell usable
09:16:39 <glguy> Is gnuplot the easiest way to generate simple scatterplot image files?
09:16:48 <wuttf> I use the mongodb driver, I have 4 entries in a collection, when doing nextBatch recursively on a cursor, I always get that 4 entries back and never an empty list, so I go into an inifnite loop. Any ideas?
09:16:50 <edwardk> we're also (barring unforeseen complications) shipping lens 3.8 this weekend
09:16:53 <fragamus> overstated perhaps
09:17:18 <SirStean> How can i get a IO [(Bool,Int,Int)] then?
09:17:19 <elliott> We should probably revert preview or something before releasing 3.8.
09:17:23 <elliott> I guess that doesn't take a weekend.
09:17:53 <edwardk> that will give you a much nicer way to work with isos and prisms, and it adds a bunch of things like Control.Exception.Lens, etc.
09:18:23 <fragamus> very nice i'll look into it
09:18:34 <edwardk> elliott: yeah, i'm kinda tempted to keep it using something with a 'Leftmost' name and then change the implementation of Leftmost and getLeftmost, so that if we ever decide to revert back tot he current behavior users don't have to change dozens of signatures
09:18:45 <fragamus> man I don't want to work in any other language ever again
09:18:59 <edwardk> http://ekmett.github.com/lens/ has the haddocks for the current version
09:19:23 <AtomicStryker> question: putStr $ w !! randomRIO (0, length w) doesnt want to work. w is [String], i just want a randomly selected string.
09:19:30 <edwardk> er for the new version that is
09:20:21 <elliott> Rightmost is kind of bad too. I'm so glad I don't have to care about this stuff when messing with pure profunctor lenses.
09:20:44 <edwardk> heh thats just because we're still ignoring these issues there ;)
09:22:03 <SirStean> How can i get a IO [(Bool,Int,Int)] then?
09:22:03 <bscarlet> SirStean: forM [(x,y) | x <- [1..size], y <- [1..size]] $ \(x,y) -> do s <- stat; return (s,x,y)
09:22:10 <geekosaur> AtomicStryker, randomRIO produces an IO action, not a list element
09:22:28 <geekosaur> (also note that response SirStean)
09:22:44 <AtomicStryker> isnt it supposed to give me a random Int, to be used for !!
09:22:54 * hackagebot yesod-datatables 0.1 - Yesod plugin for DataTables (jQuery grid plugin)  http://hackage.haskell.org/package/yesod-datatables-0.1 (TeroLaitinen)
09:23:17 <geekosaur> no
09:23:17 <geekosaur> :t randomRIO
09:23:18 <lambdabot> Random a => (a, a) -> IO a
09:23:20 <geekosaur> bleh, why does lambdabot not like me
09:23:35 <geekosaur> randomRIO uses IO to get at a saved random seed, so it is an IO action
09:23:53 <AtomicStryker> is there any way to get an Int from that
09:24:06 <geekosaur> Prelude System.Random> :t randomRIO
09:24:06 <geekosaur> randomRIO :: Random a => (a, a) -> IO a
09:24:22 <geekosaur> ... well, that's a bit after the fact...
09:24:28 <geekosaur> no
09:24:55 <AtomicStryker> ok. let me ask differently. is there a way to get a pseudorandom int without writing a 15 line generator thing
09:25:34 <AtomicStryker> any by writing i mean copy pasting off stackoverflow
09:25:36 <parcs> getRandom :: Int; getRandom = 4
09:25:42 <geekosaur> you need to lift what you're trying to do into IO, not try to extract something from the IO
09:25:44 <geekosaur> @quote contains.*ls
09:25:44 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:26:27 <AtomicStryker> parcs: har har. i saw that while googling the issue
09:26:43 <mm_freak> AtomicStryker: randomIO, randomRIO?
09:26:48 <parcs> snarky questions get snarky answers
09:27:23 <AtomicStryker> if i seem a bit pissed its because i am
09:27:32 <AtomicStryker> im too stupid to get a random number
09:27:33 <jfredett> parcs: everyone knows that the ISO-50492-6b standard says that `14` is approved random number
09:27:35 <AtomicStryker> and haskell hates me
09:28:55 <BobbyMcLiar> AtomicStryker: instead of trying to force your way through you should probably try to understand the basics of haskell. I enjoyed 'learn you a haskell' a lot
09:29:00 <Tesseraction_j> parcs / jfredett : reminds me of this old one http://dilbert.com/strips/comic/2001-10-25/
09:29:14 <parcs> AtomicStryker: getRandomRIO is an IO action just like putStr is. in order to compose IO actions you use (>>=)
09:29:37 <parcs> or do notation
09:30:57 <bscarlet> AtomicStryker: e.g. do n <- randomRIO (0, length w); putStr $ w !! n
09:32:51 <AtomicStryker> thank you, and thank you particularly bscarlet
09:32:55 <fryguybob> @undo do n <- randomRIO (0, length w); putStr $ w !! n
09:32:55 <lambdabot> randomRIO (0, length w) >>= \ n -> putStr $ w !! n
09:32:57 <fryguybob> @@ @pl @undo do n <- randomRIO (0, length w); putStr $ w !! n
09:32:57 <lambdabot>  putStr . (w !!) =<< randomRIO (0, length w)
09:35:24 <parcs> @where lyah
09:35:24 <lambdabot> http://www.learnyouahaskell.com/
09:36:05 <bgamari_> Saizan, Well, RWS may not be less strict that ReaderT r (State s), but the Writer accumulating still causes a space leak
09:36:12 <bgamari_> should have seen that earlier
09:36:44 <beaky> hello
09:36:54 <bgamari_> Note to self: `RWST r () s m` is no substitute for `ReaderT r (StateT s m)`
09:37:10 <beaky> what are some imperative/oop things that are done better in fp?
09:37:31 <beaky> i.e. what problems are a better fit for fujnctional programming
09:38:21 <niteria> anyone here with power to create wiki account?
09:38:51 <mm_freak> beaky: pick an application type APPTYPE
09:39:04 <niteria> http://www.haskell.org/haskellwiki/99_questions/Solutions/34 is slightly wrong, you don't need rationals there
09:39:06 <mm_freak> for all APPTYPEs you will hear me saying: "category theory is the best APPTYPE framework"
09:39:12 <beaky> ah
09:39:36 <tac-tics> bgamari_: no. it is not :)
09:39:50 <mm_freak> beaky: in other words, OO is a bad choice for everything
09:39:53 <mm_freak> everything.
09:40:06 <tac-tics> beaky: any kind of tree traversal problem is much easier in FP. Compilers should always be functional.
09:40:12 <beaky> right
09:40:27 <BobbyMcLiar> I have a question. How do I use lenses form the 'lens' package on types with multiple constructors? I've already tried, but if I try to use them, GHC tells me that all the data fields have to be a Monoid and I'm using an Int which isn't a Monoid. What is happening here?
09:40:38 <beaky> what about the canonical oop example of modeling digitsl circuits
09:40:52 <beaky> digital*
09:41:03 <niteria> beaky: example from sicp?
09:41:07 <edwardk> BobbyMcLiar: you have something like data Foo = Foo { fooA :: Int } | Bar { fooA :: Int, fooB :: Double }  ?
09:41:12 <beaky> niteria: yeah that :D
09:41:16 <mm_freak> beaky: http://stackoverflow.com/questions/14327327/dependency-injection-in-haskell-solving-the-task-idiomatically/14329487#14329487
09:41:16 <edwardk> BobbyMcLiar; and when accessing fooB it wants a monoid?
09:41:23 <BobbyMcLiar> edwardk: exactly
09:41:33 <johnson_> mm_freak: 'better' is not an absolute, so you can't say that. unless you have some research to cite about real programmers doing real things, or some kind of scientific theory that can't be falsified, you're talking rubbish
09:41:37 <elliott> you want (^?)
09:41:41 <mm_freak> beaky: that's my answer…  and i can say that about everything OO
09:41:41 <elliott> or (^..)
09:42:02 <tac-tics> johnson_: science has its limits. This is programming, not science.
09:42:02 <glguy> ^.. is a list of values and ^? is the first as a maybe
09:42:15 <edwardk> BobbyMcLiar: what happened is this that lens became a 'traversal' because it may not be present. so you can update it as usual and it'll set it if its there, but you need to use preview/(^?)/(^..) to read it
09:42:25 <johnson_> tac-tics: yeah, so don't make statements that look like facts, when really they're opinion
09:42:32 <edwardk> > preview (element 10) [1..5]
09:42:33 <lambdabot>   Nothing
09:42:35 <mm_freak> johnson_: i have worked in large OO projects using many frameworks in many programming languages…  all of them eventually ran into the problem that something doesn't fit the design, at which point the project became patchwork and unmaintainble
09:42:36 <edwardk> > preview (element 3) [1..5]
09:42:38 <lambdabot>   Just 4
09:42:57 <edwardk> > [1..5]^.element 10
09:42:59 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:42:59 <lambdabot>    (GHC.Enum.Enum a0)
09:42:59 <lambdabot>     ...
09:43:01 <edwardk> that wants a monoid
09:43:02 <mm_freak> johnson_: learning a new OO application/framework takes something between weeks and months…  that's a universal property
09:43:05 <edwardk> > [1..5]^? element 10
09:43:06 <lambdabot>   Nothing
09:43:14 <edwardk> that gives you back Maybe, avoiding the need for the monoid
09:43:32 <tac-tics> johnson_: How does one scientifically test if a statement is an opinion? I'm gonna have to see a peer reviewed paper on that :P
09:43:41 <edwardk> because (^.) always has to give you something, and the only way it can stitch together the potentially multiple (or no) answers from a traversal is to use Monoid.
09:43:57 <mm_freak> johnson_: and to the question why that has to do with OO i have an answer:  OO is a bunch of ad hoc abstractions to solve particular problems tortured to be as general as possible…  at the same time OO does not allow generalization at all
09:44:10 <edwardk> BobbyMcLiar: did that make sense?
09:44:14 <beaky> what about the javascript style of oop
09:44:19 <fmap> > [[]] ^. element 10
09:44:20 <lambdabot>   []
09:44:27 <johnson_> mm_freak: if you know something about OO that the rest of us don't, see if you can get that published as a paper
09:44:28 <mm_freak> that's why OO fails in the real world…  that's why implementing new website features takes weeks instead of hours, etc.
09:44:47 <edwardk> fmap: there its using the monoid for [] to give you a default value
09:44:54 <Lethalman> mm_freak,
09:45:07 <edwardk> ["hello","world
09:45:15 <edwardk> > ["hello","world"]^.element 1
09:45:17 <lambdabot>   "world"
09:45:19 <edwardk> > ["hello","world"]^.element 3
09:45:21 <BobbyMcLiar> edwardk: Thank you! Sadly that's kind of over my head. I'm still trying to find explanationts for the kind of CPS you use. the one in the haskell wiki looks so different
09:45:21 <lambdabot>   ""
09:45:22 <fmap> edwardk: yeah, I didn't mean that as conter-example :]
09:45:22 <TheRedMood> 	Hey
09:45:24 <Lethalman> mm_freak++ the more you add abstraction in an OO project, the more you are in a jail where you can't add new features... that's the feeling
09:45:25 <mm_freak> johnson_: there is too much material out there, and more papers won't change the world…  my approach is to make haskell more accessible and perhaps write a paper/book about that one
09:45:26 <TheRedMood> I need some help with const
09:45:30 <TheRedMood> What is the meaning of it?
09:45:35 <mm_freak> Lethalman: exactly
09:45:47 <TheRedMood> hoogle doesnt help
09:45:54 <edwardk> BobbyMcLiar: lets just write (^.)
09:46:12 <johnson_> mm_freak: changing the subject, what do you mean by more accessible? have you written any blog posts on it or anything like that yet?
09:46:13 <BobbyMcLiar> edwardk: Don't waste too much effort on me for now. I'll copy your explanations and review it someday!
09:46:21 <edwardk> a ^. l = runIdentity (l (Identity . f) a)
09:46:40 <edwardk> er
09:46:42 <elliott> lens isn't really that CPS-y
09:46:48 <edwardk> a ^. l = runIdentity (l Identity a)
09:46:52 <elliott> well it sort of is
09:47:04 <bscarlet> TheRedMood: const x is a function which takes one argument, ignores it, and returns x
09:47:06 <edwardk> :t \a l -> runIdentity (l Identity a)
09:47:07 <lambdabot> t -> ((a1 -> Identity a1) -> t -> Identity a) -> a
09:47:22 <n-dolio> Circuits are a canonical example of OOP?
09:47:26 <TheRedMood> .....
09:47:28 <mm_freak> johnson_: i'm the author of a monad tutorial and an arrow tutorial…  while i can't recommend the former anymore, it seems like my arrow tutorial seems to be the only one to take the mystery out of arrows…  and it isn't even finished =)
09:47:28 <TheRedMood> Like?
09:47:41 <mm_freak> johnson_: i'm also the author of a very practical FRP library, netwire
09:47:43 <n-dolio> Is that because the various circuit components are supposed to be objects or something?
09:47:49 <bscarlet> > const 3 4
09:47:51 <lambdabot>   3
09:47:54 <johnson_> mm_freak: where's your tutorial? i need to read about arrows
09:47:55 <n-dolio> Like, neural networks are OOP because you make each neuron an object?
09:48:02 <edwardk> > let a ^^. l = runIdentity (l Identity a) in (1,2)^^._1
09:48:03 <TheRedMood> > const 3 4 5 6 7
09:48:04 <lambdabot>   can't find file: L.hs
09:48:05 <lambdabot>   (1,2)
09:48:06 <mm_freak> johnson_: http://ertes.de/new/tutorials/arrows.html
09:48:14 <TheRedMood> > const 3 4 5 6 7
09:48:15 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a1 -> a2 -> t))
09:48:15 <lambdabot>    arising from the am...
09:48:18 <edwardk> > let a ^^. l = runIdentity (l Identity a) in (1,2)^^._1
09:48:20 <lambdabot>   (1,2)
09:48:24 <TheRedMood> ..
09:48:26 <edwardk> oh heh Identity
09:48:34 <edwardk> > let a ^^. l = getConst (l Const a) in (1,2)^^._1
09:48:36 <lambdabot>   1
09:48:41 <edwardk> better =)
09:48:41 <TheRedMood> o-o
09:48:46 <johnson_> mm_freak: cheers i'll read it - hopefully not too many unsubstantiated opinions on programming style presented as facts :P
09:49:08 <beaky> ah
09:49:11 <TheRedMood> const 3 4
09:49:11 <edwardk> n-dolio: hah
09:49:17 <TheRedMood> > const 3 4
09:49:18 <lambdabot>   3
09:49:24 <TheRedMood> hmm
09:49:52 <TheRedMood> I don't get it. Why have a function return just one of the paramters?
09:50:19 <edwardk> TheRedMood: because it is a useful building block for bigger things
09:50:23 <TheRedMood> ?
09:50:29 <TheRedMood> Thats what I don't get-
09:50:34 <Mon_Ouie> You could think of it as (const x) = \_ = x -- const x is the constant function
09:50:39 <n-dolio> How long have you been writing Haskell?
09:50:43 <TheRedMood> I have a function which uses it, but I don't know why.
09:50:46 <BobbyMcLiar> edwardk: Oh now I get it! thank you very much :D
09:50:50 <TheRedMood> 3 days I think?
09:51:00 <bscarlet> TheRedMood: think of it like an adapter. Suppose something else needs a function of one parameter, but you don't want to use the parameter.
09:51:20 <TheRedMood> Iceland_jack gave me this example of a length function: len = sum . map (const 1)
09:51:26 <TheRedMood> What does const do here?
09:51:43 <fmap> > map (const 1) [1..10]
09:51:45 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
09:51:51 <edwardk> TheRedMood: const there is saying, 'i don't care what the value is in the list, just replace it with 1.
09:51:59 <edwardk> then add the sum adds the 1s up
09:52:11 <TheRedMood> ....
09:52:17 <bscarlet> TheRedMood: but map must get a function that takes one argument
09:52:24 <TheRedMood> Yeah
09:52:27 <TheRedMood> Oh
09:52:29 <Iceland_jack> > (const "this is what const does") "Ignore me~"
09:52:30 <TheRedMood> It has to?
09:52:30 <lambdabot>   "this is what const does"
09:52:31 <edwardk> you can hand write it
09:52:37 <mm_freak> TheRedMood: there are a bunch of functions like that, including 'id'
09:52:39 <mm_freak> id x = x
09:52:40 <edwardk> len = sum . map (\_ -> 1)
09:52:48 <edwardk> but this is a common enough idiom to get its own name
09:53:13 <mm_freak> TheRedMood: a use case for id is composing a list of functions:  foldl' (.) id
09:53:28 <TheRedMood> I don't know what \_ means
09:53:38 <mm_freak> > foldl' (.) id [sin, (+1), (/2)] 16
09:53:40 <lambdabot>   0.4121184852417566
09:53:41 <edwardk> :t \ a -> a
09:53:42 <lambdabot> t -> t
09:53:45 <Iceland_jack> TheRedMood: Do you know anonymous functions?
09:53:53 <edwardk> :t \ _ -> "hello"
09:53:54 <lambdabot> t -> [Char]
09:54:03 <mm_freak> TheRedMood: \x -> x is an anonymous version of 'id', and _ is just a variable that you don't name
09:54:08 <edwardk> \ a ->    is defining a 'lambda' , a local anonymous function
09:54:11 <mm_freak> const = \x _ -> x
09:54:28 <TheRedMood> You people are scary :s
09:54:31 <TheRedMood> X3
09:54:35 <edwardk> const a b = a    can be rewritten const = \ a b -> a
09:54:35 <mm_freak> > (\x _ -> x) 3 4
09:54:37 <lambdabot>   3
09:54:57 <TheRedMood> Iceland_jack Yeah, functions assigned to a variable
09:55:00 <beaky> \ is notation for an anonymous function
09:55:01 <edwardk> then _ can be used to replace any variable you don't use
09:55:02 <TheRedMood> Oh
09:55:03 <zhulikas> are there any fractional numbers who are in Integral typeclass?
09:55:04 <TheRedMood> Okay
09:55:21 <mm_freak> TheRedMood: remember the 'take' function for lists?  take 0 _ = [];  take n (x:xs) = x : take (n - 1) xs
09:55:27 <TheRedMood> the -> ?
09:55:30 <mm_freak> TheRedMood: in the first equation i'm just ignoring the second argument
09:55:33 <edwardk> :info Integral
09:55:57 <beaky> what comes between the \ and the -> are the parameters for the anonymous function
09:55:59 <edwardk> :t toInteger
09:56:00 <lambdabot> Integral a => a -> Integer
09:56:04 <edwardk> zhulikas: i hope not ;)
09:56:10 <beaky> what follows the -> is the function definition
09:56:21 <zhulikas> ok :D
09:56:55 <beaky> so \a -> a + 1 is the function that takes a single parameter and adds one to it
09:57:02 <mm_freak> TheRedMood: "\a _ c -> …" is a function of three arguments without a name…  the first argument is named 'a', the third is named 'c', the second doesn't get a name (probably because it's not used)
09:57:07 <mm_freak> TheRedMood: the "…" is the function body
09:57:52 <mm_freak> "without a name" as in the function itself does not have a name
09:57:54 <n-dolio> > toInteger (5.5 :: Expr) -- zhulikas
09:57:56 <lambdabot>   *Exception: not a number
09:58:07 <edwardk> n-dolio: heh
09:59:17 <b_eating> @@ @pl @unpl ($)
09:59:17 <lambdabot>  id
10:00:13 <beaky> I love automatic currying and partial function application
10:00:18 <TheRedMood> Ah
10:00:29 <TheRedMood> Okay thanks for the explanation mm_freak :D
10:01:30 <mm_freak> TheRedMood: functions are just regular values in haskell…  just like you can write a literal for an Integer value you can also write a literal for an Integer -> Integer value =)
10:01:39 <mm_freak> 3 :: Integer
10:01:48 <mm_freak> (\x -> x + 1) :: Integer -> Integer
10:02:56 <mm_freak> you can refer to integers by name (x + x) or by literal value (3 + 3)
10:03:16 <AtomicStryker> http://pastebin.com/jd7kha1w if someone could tell me why the last 2 lines are evil and not allowed?
10:03:18 <mauke> The paste jd7kha1w has been copied to http://hpaste.org/80932
10:03:19 <mm_freak> you can refer to functions by name (succ 5) or by literal value ((\x -> x + 1) 5)
10:03:47 <hiptobecubic> AtomicStryker, (++) is used infix there. Meaning it has lower precedence
10:04:06 <hiptobecubic> the code actually says   (putStrLn "foo") ++ whatever
10:04:07 <mm_freak> AtomicStryker: just a precedence issue:  putStrLx x ++ y = (putStrLn x) ++ y
10:05:00 <hiptobecubic> AtomicStryker, try putStrLn $ ....
10:05:02 <hiptobecubic> :t ($)
10:05:03 <lambdabot> (a -> b) -> a -> b
10:05:43 <fragamus> it seems to me that haskell's strength is in orthogonality
10:06:17 <mm_freak> why not putStrLn (x ++ y)?
10:06:25 <fragamus> a small number of well chosen abstractions used in combination can outperform other languages
10:06:33 <mm_freak> that's slightly easier to read than putStrLn $ x ++ y
10:06:51 <mm_freak> fragamus: that's because those abstraction actually have a theoretical foundation
10:07:00 <AtomicStryker> ok, i had to fix the ++ Int to show aswell, thanks
10:07:40 <mm_freak> we know their limits exactly, unlike in OO, where you stumble upon the limitations, at which point you either rewrite the whole application of start doing patchwork =)
10:07:40 <AtomicStryker> oh, now lazy evaluation got me
10:07:50 <mm_freak> fortunately patchwork is impossible in haskell
10:09:32 <AtomicStryker> allright next question ... i want this code to "choose" and save a word string, then for the program to accept a user input string
10:09:46 <AtomicStryker> but when i use x <- getLine now it doesnt wait
10:10:04 <AtomicStryker> it latches onto the closed file handle, apparently
10:10:57 <geekosaur> AtomicStryker, more likely you are being bitten by line buffering
10:11:14 <geekosaur> you read a character, ignore the fact that the user has to hit return, then the next read gets the return
10:11:43 <AtomicStryker> okay, how do i clear the buffer?
10:12:16 <geekosaur> the right thing to do is read lines and then get your input from that.
10:12:46 <geekosaur> (this is not a whole lot different from people trying to read input in C using scanf())
10:15:31 <wuttf> Can anyone tell me from the source code if I issue a nextBatch http://hackage.haskell.org/packages/archive/mongoDB/1.3.1/doc/html/Database-MongoDB-Query.html on a cursor, will that update the cursor?
10:16:33 <AtomicStryker> http://hpaste.org/80935 here thats what i mean
10:16:36 <johnson_> If i want a bi-directional map, should I just use two Data.Map's? or is there a better way?
10:16:38 <AtomicStryker> ... surely this must be possible, somehow
10:17:15 <Lethalman> johnson_, can't you use the same map?
10:17:53 <johnson_> Lethalman: I want to map a to b, and I want to be able to lookup a and find my b, or b and find my a - I don't see an efficent operation for that in Data.Map, is there one?
10:18:03 <Lethalman> ah right, key and value being different :)
10:19:11 <mysticc> What is the meaning of [Unknown] in the installed version in cabal list
10:21:18 <AtomicStryker> getLine turns into hGetLine without me wanting to to ._.
10:23:12 <Lethalman> mm_freak, about OO again, I'm new to haskell, but I was lately realizing the idea that the factory pattern in FP is as simple as partial function application... e.g. a -> b -> c... where in OO you'd have getFactory(...).newInstance(...)
10:23:24 <Lethalman> not sure if that's not really it, but it looks quite similar
10:26:00 <simpson> Lethalman: Well, that's not really OO as much as Java.
10:26:01 <AtomicStryker> ok so getLine uses the "default" input output and somehow i made the file new default ... then how to i set the command terminal back as default
10:26:37 <Eduard_Munteanu> AtomicStryker: getLine uses stdin, whatever it is.
10:26:38 <Lethalman> simpson, why not? it's known as factory pattern in OO
10:26:53 <Lethalman> simpson, maybe it's mostly used in java
10:27:03 <jfredett> Lethalman: the factory pattery is quite a bit more than that.
10:27:06 <AtomicStryker> and how do i get stdin out of the file?
10:27:10 <jfredett> s/pattery/pattern/
10:27:17 <AtomicStryker> and back onto the terminal
10:27:26 <simpson> Lethalman: "object-oriented" is a very icky term. In actual object-based languages, you won't see this pattern.
10:27:34 <AtomicStryker> in the learn you a haskell example, it "just works"
10:27:48 <Eduard_Munteanu> AtomicStryker: http://hpaste.org/80935 ?
10:27:58 <AtomicStryker> yes
10:28:07 <jfredett> simpson: that's not strictly true either -- the Factory pattern is useful in, eg, smalltalk -- Java is just aggressive about using it _everywhere_
10:28:30 <Lethalman> simpson, in what actual OO languages then?
10:28:38 <Lethalman> it's used also outside of java
10:29:35 <Lethalman> jfredett, what's more than that? you have a factory that hides the actual concrete type
10:29:46 <BobbyMcLiar> AtomicStryker: It also "just works" for me :/
10:29:53 <Lethalman> much like from a -> b -> c you get b -> c by applying a
10:30:08 <simpson> jfredett: The patterns were supposed to be descriptive, not proscriptive. Rigid adherence to them is not a good plan.
10:30:48 <simpson> Lethalman: Well, for example, in Python, you don't have to getFactory(), because you can *always* just pass the factory around, and instead of newInstance(), you just call the factory to make a new instance.
10:30:49 <AtomicStryker> ok ... postponed!!
10:30:52 <AtomicStryker> thanks
10:30:53 <simpson> IOW "factories" are just types.
10:30:58 <jfredett> simpson: I'm aware- however, the pattern does 'get used' (in the sense that the effect is "go build a thing that hides implementation and guarantee's properties)
10:31:46 <simpson> jfredett: Sure.
10:31:52 <jfredett> you are unlikely to see the exact java-ism in smalltalk, but there are objects that play the role of factory
10:31:55 <Lethalman> simpson, but that's because of functions being first class objects, which is much of function programming rather than object oriented programming, isn't it?
10:31:58 <jfredett> they may even be called factory
10:32:07 <Lethalman> or maybe it's both
10:32:17 <Lethalman> mah :P
10:32:33 <BobbyMcLiar> I have another question. I think both of these are continuation passing style functions: a -> (b -> r) -> r and (b -> r) -> (a -> r). What is the difference between them?
10:32:43 <simpson> Lethalman: Honestly, the biggest thing there is that types are dynamic in Python, so retaining a name that points to a type is easy. In Java, the type system gets in your way.
10:32:48 <jfredett> the nearest equivalent would be an abstract constructor function in haskell. Eg, a function mkFoo :: Foo a => b -> c -> ... -> a
10:33:06 <jfredett> `mkFoo` guarentee's that the 'right' instance of Foo a is chosen
10:33:12 <jfredett> but I've never seen such code in the wild
10:33:51 <simpson> Smart constructors? They're pretty popular.
10:33:59 <jfredett> simpson: not into TC's though
10:34:09 <jfredett> usually smart constructors for a concrete type
10:34:17 <simpson> Data.Complex does this.
10:34:29 <jfredett> 'tis what I've seen, but my reading is not particularly wide.
10:34:29 <simpson> Well, Data.Complex just puts the constraint on every single function
10:35:23 <glguy> jfredett: How would mkFoo pick the Foo instance?
10:35:39 <jfredett> glguy: very carefully.
10:35:41 <jfredett> :)
10:35:57 <jfredett> (I was spitballing, perhaps it would choose through some known ones, or something)
10:36:24 <glguy> The user of mkFoo gets to pick which type he uses mkFoo at, not the internals of mkFoo
10:36:42 <jfredett> oh- that's true, yah- that wouldn't work.
10:37:59 * frerich_ had to google "spitballing"
10:38:38 <jfredett> that's a little bit rough to translate, then -- since a Factory object will often build something of the correct interface, which may have no relation in terms of type. (eg, the just bear the same interface)
10:38:45 <jfredett> s/eg/ie. stupid latin.
10:40:24 <jfredett> any function I can manage to think of presently would have to constrain to a single type. damnit now I'm going to be thinking about this all day.
10:44:17 <johnson_> I changed my .cabal/config to enable documentation - how do i now go back and install documentation for modules i already have installed?
10:45:44 <elliott> johnson_: recompiling them all. sorry.
10:46:04 <johnson_> elliott: don't mind that - what's the command, or do I have to manually do it?
10:46:10 <elliott> cabal install --reinstall world
10:46:39 <absence> are there any tricks to increasing a profiled program's productivity? it's around 50 % with 23 % gc time, but i don't think there are any huge space leaks left
10:49:20 <Eduard_Munteanu> absence: try increasing the minimum heap size, -H
10:51:22 <beaky> how far can you get by without using typeclasses in code?
10:51:33 <mm_freak> Lethalman: exactly
10:52:17 <Lethalman> mm_freak, :S you're joking me
10:52:20 <Eduard_Munteanu> beaky: depends, the standard libraries use typeclasses anyway
10:52:30 <S11001001> beaky: by "can", you mean...
10:52:35 <beaky> yeah, and lots of the libraries I use use them :D
10:53:17 <beaky> so what are some common abuses of typeclasses with better alternatives?
10:53:25 <mm_freak> Lethalman: unfortunately currently i'm not running a blog, but you may be interested in this answer, too:  http://stackoverflow.com/questions/14327327/dependency-injection-in-haskell-solving-the-task-idiomatically/14329487#14329487
10:53:26 <simpson> beaky: (+)
10:53:34 <Eduard_Munteanu> beaky: perhaps not enough... you can see list functions like map etc.. You have to do qualified imports to use the Bytestring variants for example.
10:53:52 <simpson> beaky: We don't generally think of the common typeclasses as abusive.
10:54:11 <Lethalman> mm_freak, I've just read it before, and used that kind of stuff for my first haskell program (not logging but that's it) :)
10:54:19 <mm_freak> it's a quick summary of why "dependency injection" is not a concept, but just a stupid buzzword
10:54:28 <mm_freak> ok =)
10:55:05 <S11001001> beaky: writing instances of existing classes is fine, if you follow the laws.  Think twice before defining new classes.
10:55:23 <absence> Eduard_Munteanu: thanks, i tried 500 mb but it didn't help much. it only uses 50 mb total when running for half a minute, so i guess heap resizing is a very small part of it :)
10:55:40 <simpson> mm_freak: It's totally a concept, but it only applies in Java. :3
10:56:13 <zhulikas> and C#
10:56:14 <mm_freak> simpson: what's the concept?
10:56:21 <mm_freak> you have a few things, which depend on others
10:56:30 <Eduard_Munteanu> absence: -H500m? Your app must be producing lots of garbage.
10:56:34 <mm_freak> what does it mean for a thing to depend on some other thing?  it's a function of that thing
10:56:44 <mm_freak> then what's "dependency injection"?  it's function application
10:57:11 <c_wraith> "dependency injection" is more the process of making things you depend on parameters instead of using globals
10:57:24 <mm_freak> c_wraith: in other words, it's a buzzword
10:57:27 <c_wraith> yes
10:57:32 <Eduard_Munteanu> absence: AFAIU, what -H does is modify the threshold over which the GC kicks in.
10:57:56 * hackagebot hothasktags 0.3.0 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.3.0 (LukePalmer)
10:58:07 <beaky> what are rank n types/
10:58:12 <mm_freak> the problem is that people actually feel the need to /implement/ dependency injection?  WTF?  you have functions and function application in your language, don't you?
10:58:26 <c_wraith> mm_freak: they like to pretend they're still using globals
10:58:29 <mm_freak> beaky: it's a forall in a higher order function
10:58:42 <c_wraith> mm_freak: mostly because globals are more convenient than passing parameters everywhere
10:58:50 <beaky> ah
10:58:51 <mm_freak> beaky: runST :: (forall s. ST s a) -> a
10:58:56 <beaky> higher-order is a nice word
10:59:01 <absence> Eduard_Munteanu: http://hpaste.org/80938 <- total memory in use increased to 500 with the -H option
10:59:09 <mm_freak> ok, that one is not higher order, but it has a "forall" that can't be moved to the front
10:59:12 <c_wraith> mm_freak: so most dependency injection frameworks are about ways of putting the parameters in scope implicitly
10:59:30 <mm_freak> c_wraith: so it's a buzzword for ReaderT
10:59:44 <c_wraith> haskell's term for it is the "configuration problem"
10:59:56 <mm_freak> well, the "implicit configurations" problem
10:59:59 <typoclass> c_wraith: please, no buzzwords
11:00:00 <typoclass> =)
11:00:01 <mm_freak> and that one is a solved problem =)
11:00:02 <c_wraith> :)
11:00:19 <qwr> mm_freak: use reader monad?
11:00:28 <mm_freak> qwr: not necessarily
11:00:33 <mm_freak> qwr: you can also use reflection
11:00:38 <beaky> typeclasses remind me of CLOS
11:00:55 <qwr> mm_freak: hmm. how or what reflection?
11:01:05 <Playground> beaky: The difference is a type class can group several polymorphic functions.
11:01:05 <Eduard_Munteanu> @hackage reflection
11:01:05 <lambdabot> http://hackage.haskell.org/package/reflection
11:01:17 <mm_freak> beaky: to answer your question, higher rank types are useful to pass generic functionality around
11:01:23 <beaky> ah
11:01:30 <Eduard_Munteanu> Also look at the paper linked there.
11:01:39 <mm_freak> beaky: myFunc :: (Monad m) => (forall a. (Random a) => m a) -> m X
11:01:55 <mm_freak> that effectively means that myFunc wants a random number generator as an argument
11:02:35 <mm_freak> qwr: reflection is the process to lift (reify) a value to the type level and back (reflect)
11:02:50 <absence> Eduard_Munteanu: those 11 gb allocated are "lots of garbage" right?
11:02:58 * hackagebot bitvec 0.1.0.1 - Unboxed vectors of bits / dense IntSets  http://hackage.haskell.org/package/bitvec-0.1.0.1 (JamesCook)
11:03:18 <Eduard_Munteanu> absence: yeah, not sure what you can do about it though. Paste your code perhaps?
11:05:58 <Walther> Is factorial (n!) implemented in haskell somehow or should I just implement it on my own
11:06:14 <gwern> @hoogle factorial
11:06:14 <lambdabot> No results found
11:06:19 <gwern> looks like you're on your own
11:06:29 <Walther> ok, no probs
11:06:31 <absence> Eduard_Munteanu: ok, might do that later. it badly needs some cleanup first ;)
11:06:42 <mm_freak> Walther: product [1..n]
11:06:48 <mm_freak> > product [1..7]
11:06:48 <Eduard_Munteanu> @where evolution
11:06:48 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
11:06:49 <lambdabot>   5040
11:06:56 <Eduard_Munteanu> :)
11:07:05 <gwern> mm_freak: might run into efficiency problems there...
11:07:42 <Eduard_Munteanu> absence: try getting a profile too, maybe it can tell you who's doing the most allocations.
11:08:05 <mm_freak> > let factorial = foldl' (*) 1 . enumFromTo 1 in factorial 10
11:08:06 <lambdabot>   3628800
11:08:10 <hiptobecubic> this dependency injection thing
11:08:16 <hiptobecubic> I feel like this happens constantly.
11:08:56 <hiptobecubic> Some language sucks so they invent some crazy new way to get their language to do whatever it is and then name it something official sounding.
11:09:33 <beaky> like Monads
11:09:34 <hiptobecubic> But then it turns out that 30% of all languages do it just fine in the intuitive way you'd expect
11:09:42 <Lethalman> @let bug = "è"
11:09:45 <lambdabot>  Defined.
11:09:47 <Lethalman> > bug
11:09:49 <lambdabot>   "\232"
11:09:52 <c_wraith> > fix bug
11:09:54 <lambdabot>   Couldn't match expected type `a0 -> a0'
11:09:54 <lambdabot>              with actual type `[GHC...
11:09:59 <c_wraith> darn
11:10:01 <c_wraith> couldn't fix it
11:10:10 <absence> Eduard_Munteanu: seems to be D#, (,), and some monoid coproduct stuff that is probably due to Diagrams. is D# related to Double?
11:10:16 <hiptobecubic> beaky, haskell didn't invent monads actually :)   And if you had purity (which is a good thing) in other languages you'd need them there too.
11:10:23 <beaky> ah
11:10:29 <Eduard_Munteanu> @src Double
11:10:29 <lambdabot> data Double = D# Double#
11:10:30 <c_wraith> absence: D# is the constructor for Double
11:10:31 <mm_freak> IMO you need laziness for monads to be useful
11:10:32 <Walther> Uh, how can I force the output to be Integer? Somehow my function insists on spitting out a float
11:10:42 * Lethalman is not proficient enough with encoding-fu to fix it :S
11:10:47 <hiptobecubic> beaky, compared to say. "We don't have higher order functions because we're losers, so lets write a 300 page book on design patterns that try to emulate them."
11:10:49 <Eduard_Munteanu> absence: sounds like it's a boxing/unboxing issue?
11:10:51 <mm_freak> without laziness you can't define certain combinators like 'forever'
11:10:53 <beaky> hah
11:11:04 <c_wraith> I've got to say, ML's parameterized modules solve the configuration problem better than any of haskell's approaches.
11:11:07 <geekosaur> Walther, pastebin your function?
11:11:10 <geekosaur> @paste
11:11:10 <lambdabot> Haskell pastebin: http://hpaste.org/
11:11:26 <c_wraith> Lethalman: use putStrLn instead of print
11:11:27 <Eduard_Munteanu> absence: do you have some data structure that embeds some Doubles?
11:11:30 <mm_freak> c_wraith: what can a parameterized module do that a function can't do?
11:11:31 <Walther> geekosaur: http://paste.ubuntu.com/1546400/
11:11:32 <beaky> I think I need to get that design pattern book someday
11:11:47 <c_wraith> mm_freak: it gives you implicit globals for free!
11:11:55 <hiptobecubic> beaky, A good exercise is to implement them in haskell :)
11:12:23 <mm_freak> c_wraith: dynamic?
11:12:25 <beaky> I guess visitor pattern is already done
11:12:30 <beaky> thanks to sum types and pattern matching
11:12:32 <hiptobecubic> then you see that things like the "visitor pattern" are pretty lame
11:12:33 <geekosaur> Walther, you are using / which does not produce an Integer.  you may want `div` instead, or promoting from Integer to Double and back down again afterward
11:12:35 <hiptobecubic> right
11:12:51 <Walther> geekosaur: Ah. What is the difference between / and `div` ?
11:12:55 <Eduard_Munteanu> beaky: Visitor is pretty much Functor AFAIU :)
11:12:56 <hiptobecubic> "strategy" also
11:12:58 <tac-tics> mm_freak: Do you have a reference to any papers making a good argument for the thought that monads aren't useful without laziness?
11:12:58 <geekosaur> :t (/)
11:12:59 <lambdabot> Fractional a => a -> a -> a
11:13:03 <geekosaur> :t div
11:13:05 <lambdabot> Integral a => a -> a -> a
11:13:13 <c_wraith> mm_freak: I'm not sure about dynamic, but you can instantiate them with multiple different types simultaneously, which is nice
11:13:20 <tac-tics> mm_freak: (Obviously, you can' define a generic total forever function on monads)
11:13:28 <mm_freak> tac-tics: i don't need a paper, just an example:  main = putStrLn "Hello!" >> main
11:13:29 <absence> Eduard_Munteanu: i have some tuples that i pass around which could cause the (,), but not many Doubles. they're possibly in Diagrams' transformations
11:13:39 <mm_freak> tac-tics: that one inherently relies on the nonstrictness of (>>)
11:14:01 <tac-tics> mm_freak: that's just forever under the covers again :)
11:14:13 <tac-tics> mm_freak: do you know any other examples that don't work?
11:14:15 <mm_freak> tac-tics: yes, but 'forever' has the same requirement
11:14:35 <mm_freak> tac-tics: you certainly want long-running programs without blowing your memory, don't you?
11:15:39 <tac-tics> mm_freak: well, you can have a strict language with coinductive types. IO would be such a type, and you could still have a forever :: IO a -> IO b
11:16:15 <tac-tics> > forever []
11:16:17 <lambdabot>   []
11:16:22 <tac-tics> > forever [1]
11:16:24 <lambdabot>   *Exception: stack overflow
11:16:51 <tac-tics> > forever (Just 0)
11:16:55 <lambdabot>   mueval-core: Time limit exceeded
11:17:02 <Walther> geekosaur: that didn't explain much
11:17:03 <mm_freak> tac-tics: ok, and which commonly used language has codata support?
11:17:05 <tac-tics> forever is broken even in a lazy language :)
11:17:05 <Walther> care to elaborate?
11:17:11 <Eduard_Munteanu> @forever alone
11:17:11 <lambdabot> Unknown command, try @list
11:17:16 <Eduard_Munteanu> > forever alone
11:17:18 <lambdabot>   []
11:17:29 * Eduard_Munteanu misfired
11:17:43 <tac-tics> mm_freak: I'm not talking about "commonly used languages" here. But yer Idris or yer Agda could probably do the job.
11:17:45 <geekosaur> Walther, you probably want to go through a Haskell tutorial.
11:17:49 <absence> Eduard_Munteanu: newtype R2 = R2 { unR2 :: (Double, Double) } <- that's the vector representation and there are tens (hundreds?) of thousands of linear transforms going on ...
11:17:59 <mm_freak> tac-tics: forever is not broken there…  forever requires a monad with nonstrict (>>)
11:18:14 <mm_freak> to support monads with nonstrict (>>), you first need a language that supports nonstrict (>>)
11:18:20 <monochrom> forever is not applicable to some monads
11:18:33 <tac-tics> forever (defined as a generic operation on any monad) is neither productive not terminating
11:18:46 <mm_freak> tac-tics: you need support for nonstrict functions in any case…  you don't need nonstrict semantics /by default/
11:18:47 <tac-tics> nor*
11:18:48 <Eduard_Munteanu> absence: try adding some bangs in there and compile with -O2 -funbox-strict-fields, it might help
11:18:53 <geekosaur> in particular, Haskell will not "automatically cast" numbers for you (except a limited form applicable specifically to numeric literals).  (/) is fractional division, `div` is integer division dropping the remainer (see also "divmod")
11:19:38 <tac-tics> mm_freak: My original question, though.... "forever" aside, do you have any sources that make a good argument that monads aren't as useful in a strict language?
11:19:57 <tac-tics> I've heard that before, but I've never seen it backed up.
11:20:04 <mm_freak> tac-tics: assuming a language with sufficiently lightweight syntax monads are certainly useful
11:20:14 <mm_freak> but they are either hacky or not scaling well
11:20:25 <absence> Eduard_Munteanu: that code is in the diagrams library, but it might be useful for ruling out alternatives :)
11:20:27 <mm_freak> because you need to emulate nonstrict semantics
11:20:40 <Eduard_Munteanu> Oh, hm.
11:20:41 <tac-tics> mm_freak: yes, but why would you need nonstrict semantics?
11:21:16 <mm_freak> tac-tics: because otherwise you first need O(n) time and memory to construct the computation before even starting to run it
11:21:18 <Eduard_Munteanu> absence: maybe reinstall diagrams and tell cabal to use -O2 -funbox-strict-fields?
11:21:43 <Eduard_Munteanu> Or just -O2 actually, not sure if the latter helps or hurts, YMMV.
11:21:43 <mm_freak> tac-tics: haskell has the same requirements, but construction and running are interleaved, past parts of the computation are garbage-collected
11:22:18 <beaky> how do you desugar a list comprehension
11:22:40 <mm_freak> beaky: rewrite it to do-notation and desugar that one
11:22:58 <tac-tics> mm_freak: Would you mind giving an explicit example of a computation that takes O(n) resources to construct? I don't doubt it, but an example would help me understand
11:23:01 <mm_freak> > [ (x, y) | x <- [1..3], y <- "abc" ]
11:23:02 <beaky> ah
11:23:03 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
11:23:19 <mm_freak> > do x <- [1..3]; y <- "abc"; return (x, y)
11:23:20 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
11:23:25 <beaky> @undo [x | x <- [x..100], x /= 3]
11:23:25 <lambdabot> concatMap (\ x -> if x /= 3 then [x] else []) [x .. 100]
11:23:45 <beaky> @undo [x | x <- [x..100], x /= 3, x /= 6]
11:23:45 <lambdabot> concatMap (\ x -> if x /= 3 then if x /= 6 then [x] else [] else []) [x .. 100]
11:23:52 <mm_freak> tac-tics: a >> b >> c for any a, b, c
11:24:07 <mm_freak> if a, b and c are fixed, you may consider that to be O(1)
11:24:13 <mm_freak> but consider something like replicateM
11:24:21 <mm_freak> or replicateM_, to make my point better
11:24:37 <Eduard_Munteanu> concatMap f = join . fmap f = (>>= f)
11:24:49 <jordeon> Offtopic: If I have a function where calculating the nth value requires (n - 1) operations, what's the complexity of that?
11:25:04 <elliott> O(n)
11:25:25 <beaky> does haskell let you write your own syntactic sugar? like your own do-notation?
11:25:34 <beaky> besides operator overloading :D
11:25:48 <mm_freak> beaky: if you really want your own syntax you can use quasiquotes
11:26:07 <jordeon> elliott: thanks, can you help me understand why?
11:26:27 <glguy> beaky: if you really want your own syntax you can [write your own language]
11:26:47 <tac-tics> mm_freak: ah, yes. I could belive that.
11:26:54 <Eduard_Munteanu> Agda has that nifty 'syntax' thingy one can use to define do-notation there.
11:27:19 <tac-tics> hmm
11:27:23 <tac-tics> @type replicateM_
11:27:24 <lambdabot> Monad m => Int -> m a -> m ()
11:27:34 <tac-tics> @src replicateM_
11:27:34 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
11:27:45 <tac-tics> @type replicate
11:27:46 <lambdabot> Int -> a -> [a]
11:28:27 <absence> Eduard_Munteanu: i get Unexpected strictness annotation: !Double
11:29:02 <absence> newtype R2 = R2 { unR2 :: (!Double, !Double) }
11:29:03 <beaky> what is the difference between the Data.Lens and Control.Lens libraries
11:29:12 <elliott> beaky: the latter is the successor to the former
11:29:20 <Eduard_Munteanu> absence: ah, that won't work
11:29:21 <elliott> absence: data R2 = R2 !Double !Double
11:29:35 <beaky> ah so Control.Lens is the one to go for
11:29:49 <tac-tics> @type sequence
11:29:50 <lambdabot> Monad m => [m a] -> m [a]
11:29:58 <beaky> it has so many operators :( I'm scared
11:30:08 <glguy> beaky: you don't have to use the operators
11:30:48 <absence> elliott: ah, it doesn't work for newtypes? so much for a quick hack :)
11:31:03 <edwardk> beaky: most of the operators follow a common pattern
11:31:28 <beaky> so if I learn the more basic ones, I will probably get a hang of it
11:31:35 <edwardk> beaky: exactly
11:32:02 <edwardk> beaky: Talk: http://youtu.be/cefnmjtAolY?hd=1 Slides: http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf
11:32:05 <edwardk> those may help
11:32:56 * hackagebot hecc 0.4.0.1 - Elliptic Curve Cryptography for Haskell  http://hackage.haskell.org/package/hecc-0.4.0.1 (MarcelFourne)
11:36:17 <jordeon> elliott: i don't think it is O(n). I've graphed it and it's not straight, so it can't be linear
11:36:18 <Eduard_Munteanu> Any particular recommendations for a simple data serialization format? Currently I'm using a bunch of lines and doing read/show.
11:36:47 <Eduard_Munteanu> Should I bother using anything else?
11:37:32 <Eduard_Munteanu> (I feel like XML and HXT are way too complex for this, for instance)
11:38:06 <jordeon> Eduard_Munteanu: have you come across a problem or limitation in using read show?
11:38:14 <jordeon> Eduard_Munteanu: i know they can be a tad slow
11:38:29 <Eduard_Munteanu> Not really, just wondering. It's not a lot of data either.
11:39:04 <absence> Eduard_Munteanu: yaml looks nice
11:39:37 <jordeon> Eduard_Munteanu: one of those things you don't need to worry about until it becomes a problem
11:39:55 <Eduard_Munteanu> Hm, I think I've seen Yesod using that. And later on I'll probably want to serialize some data from Yesod, so that seems interesting.
11:40:26 <Eduard_Munteanu> I might need to write it by hand at the moment.
11:43:47 <Eduard_Munteanu> Hm, I might be able to use a YAML parser to parse JSON as well, might come in handy.
11:43:58 <Eduard_Munteanu> Thanks, I'll look into it.
11:58:46 <frerich_> Hm, I think I need to start understanding how I can 'nest' monads. I have a function which yields something in the IO monad, but now I'd like to make use of another monad (STM). This breaks the 'chain' of >>/>>= calls though. I suspect I need to lift something. Somewhere. Am I on the right track?
11:59:18 <elliott> @hoogle atomically
11:59:18 <lambdabot> GHC.Conc.Sync atomically :: STM a -> IO a
11:59:18 <lambdabot> GHC.Conc atomically :: STM a -> IO a
11:59:18 <lambdabot> Control.Monad.STM atomically :: STM a -> IO a
11:59:24 <Eelis> frerich_: you may be interested in the MonadIO type class
11:59:39 <elliott> won't help for STM, but yes
11:59:52 <Eelis> STM is also available in transformer form, right?
11:59:57 <typoclass> Eduard_Munteanu: i'd use Read/Show until you hit some clear limitation. i wouldn't start complicating things with no clear goal
12:00:00 <Eelis> oh wait, i'm confusing STM with RWS
12:00:00 <Cale> frerich_: Apart from being able to turn an STM action into an IO action using atomically, you can also write STM actions which produce IO actions as their result, which can later be run.
12:00:10 <Cale> frerich_: Is that what you mean by "nest"?
12:00:12 <frerich_> elliott: aaaah… that looks perfect, it didn't even occur to me to try hogging for that particular signature!
12:00:33 <frerich_> elliott: Thanks!
12:00:35 <Cale> It's impossible to use STM actions without atomically :)
12:00:42 <elliott> frerich_: Note that (do { atomically a; atomically b }) isn't (do { atomically (a >> b) })
12:00:57 <elliott> As in, "atomically" doesn't just "lift": it denotes the boundaries of your transaction.
12:01:16 <frerich_> Cale: I only learned about the STM module about 20 minutes ago (I'm porting away from plain Chan to TChan because apparently Chan suffers from some known deadlocks)
12:01:28 <Cale> right
12:02:18 <Cale> So yeah, the core of STM is atomically, the operations on TVars, retry, and orElse.
12:02:40 <Cale> (and then the other data structures in terms of those like TChan)
12:02:40 <frerich_> Cale: As for whether I meant having STM actions yielding IO actions when executed - I don't *think* I meant that. I basically wanted to do 'x <- someSTMAction' inside a 'do' block which constructs an IO action (excuse the layman's terms)
12:03:01 <Cale> right, in that case, atomically is the one you want
12:03:17 <frerich_> It didn't compile, so I rewrote it to not use do-syntax, so that I can see what's going on. And then I noticed that the way I want to compose the >>= and >> functions form the two monads can't fit.
12:03:59 <frerich_> I should've realized there needs to be a way to 'run' an STM action, so that I can get something out of it - and then I can stick that into IO (or get it in IO right away)
12:05:48 <unlink> What's the generally accepted best practice for structuring an API which may fail with an error? Should I expose my methods as returning Either? MonadError from mtl? EitherT?
12:08:13 <frerich_> Cale, elliott: I suppose that for performance reasons, it's best to prefer few larger atomic actions than many small ones? I.e. prefer 'x <- atomically $ sequence listOfIOActions' over 'x <- sequence . map atomically $ listOfIOActions'?
12:08:29 <elliott> If listOfIOActions is a list of IO actions, neither of those will type.
12:08:37 <elliott> But it's not really about performance, it's about semantics.
12:08:38 <Cale> frerich_: No, the opposite
12:08:56 <Cale> Also, you mean listOfSTMActions
12:09:03 <frerich_> Err right
12:09:08 <frerich_> listOfSTMActions
12:09:13 <elliott> The former will have the whole thing be atomic.
12:09:19 <elliott> In the latter, only each individual action will be atomic.
12:09:24 <napping> smaller transactions have less chance to collide
12:09:33 <Lethalman> frerich, more code, more conflicts
12:09:35 <frerich_> Yes; it somehow reminded me of SQL transactions.
12:10:08 <Cale> frerich_: The way it works, is that STM actions when executed by 'atomically' are run concurrently, but any reads and writes that they do are written to a log (and writes don't immediately touch shared memory)
12:10:38 <Cale> frerich_: Then, when the STM action is completed, the system takes a lock and checks to see if any of the things it had read along the way have changed
12:10:47 <Cale> and if not, commits the changes
12:10:57 <frerich_> And if something changed - does it retry?
12:11:14 <Cale> yes, if so, it retries once any of the things it had read are updated
12:11:39 <napping> (it's a little more involved if you use `orElse` or retry)
12:11:47 <Cale> yeah, that's true :)
12:11:55 <frerich_> Hmm, I start to remember… I should read up on STM again, I remember that it had this 'optimistic' model of assuming that a "commit" (or whatever the terminology was) works.
12:12:18 <Cale> But more or less, this means that if you have a lot of short-running transactions, they can stomp all over a long-running one, especially if that one reads from a lot of places.
12:12:38 <frerich_> Makes sense.
12:12:49 <Cale> Yeah, this is optimistic concurrency -- it runs everything concurrently, hoping that they don't interfere.
12:13:05 <frerich_> Thanks for explaining this non-Haskell stuff which is interesting nonetheless :-)
12:13:39 <napping> I think if you had a case where combining smaller transactions into a larger one saved overhead, then you could be even more efficient by rewriting the update to use fewer reads and writes
12:13:54 <frerich_> I read about STM years ago (but in the context of C++, I think) and thought that it's futuristic craziness. And now I'm here and actually use it in my little pet project :-)
12:14:38 <napping> It's a lot like both in the context of C++ - lots of trouble to separate local reads and writes from ones that need to be logged
12:15:20 <beaky> http://hpaste.org/80941 should I prefer the first style or the second style?
12:15:24 <napping> hmm, Rust might have a chance
12:16:31 <napping> beaky: type classes look a bit weird, if you just want to associate one value to each type
12:16:45 <fragamus> :t succ
12:16:46 <lambdabot> Enum a => a -> a
12:16:56 <napping> and using just "IO ()" as the description looks weird too
12:17:13 <beaky> napping: yeah, that was a bit of a toy example :(
12:18:05 <Eelis> rust is neat but they have some pretty big challenges they need to tackle before it can be taken seriously as a systems programming language
12:18:18 <Eelis> see matsaki's recent post on destructors, for example
12:18:20 <beaky> like an optimizing compiler?
12:18:24 <beaky> ah
12:18:35 <Eelis> no, i don't mean in terms of tooling, but in terms of how the language actually works :)
12:18:36 <frerich_> napping: I like the second version much better.
12:18:39 <napping> frerich_: one thing you can do is something like do ~(x,y) <- liftM pureFunction (readTMVar v1) (readTMVar v2); writeTMVar v1 x; writeTMVar v2 x
12:19:08 <napping> so the only thing that has to complete before another transaction interferes is building thunks for the result
12:23:30 <quchen> Is there some intuition behind the Env comonad?
12:24:02 <quchen> I'm trying to get a better working knowledge of comonads by playing around with them, but I can't come up with anything useful
12:26:20 <quchen> Docs say it's the coreader, but it seems like it's just carrying around the constant e and doing weird things with the value a
12:26:56 <Walther> If I have an infinite list, i can take n from the list to get the first n elements. Is there a better way of taking nth element than tail take n list?
12:27:08 <quchen> Walther: (!!)
12:27:13 <quchen> [1..10] !! 4
12:27:15 <quchen> > [1..10] !! 4
12:27:16 <lambdabot>   5
12:27:20 <quchen> > [1..] !! 4
12:27:21 <lambdabot>   5
12:27:40 <Walther> ...fourth element of 1.. is 5?
12:27:41 <ziman> note that it's not faster, just syntactically cleaner
12:27:50 <ziman> you index from zero
12:27:52 <unlink> (!!) and other partial list functions are perfect for infinite lists :)
12:27:52 <quchen> Walther: Lists are zero-indexed.
12:28:07 <quchen> [0..] !! 4
12:28:11 <quchen> > [0..] !! 4
12:28:13 <lambdabot>   4
12:28:19 <Walther> k, thanks
12:28:29 <ziman> @check (\i -> [0..] !! i == i)
12:28:30 <lambdabot>   Not in scope: `myquickcheck'
12:28:36 <fmap> > [0..5] !! 10
12:28:37 <lambdabot>   *Exception: Prelude.(!!): index too large
12:28:43 <fmap> > [0..5] ^? element 10
12:28:45 <lambdabot>   Nothing
12:28:56 <quchen> Lens wins again ;-)
12:29:44 <monochrom> clearly, xs!!0 is the 0th element, therefore xs!!4 is the 4th element.
12:32:21 <frerich_> Yay, it works! I managed to parallelize my single-threaded web crawler using forkIO and STM. This is by far the most complex Haskell program I've ever written. :-)
12:32:41 <edwardk> quchen: think of Env as storing something you might discard easily
12:33:05 <edwardk> quchen: in reader i'm usually doing something over the entire program. i have some huge configuration that i want to propagate forward
12:33:09 <edwardk> with Env think smaller.
12:33:22 <edwardk> i have something small i might want to associate with a piece of data
12:33:45 <edwardk> e.g. newtype Named a = Named String a   -- could be a Comonad. you can extract the 'a' from it
12:33:53 <edwardk> you can extend, keeping the Name
12:34:15 <edwardk> its a ComonadEnv which lets you ask for the string as a comonadic action
12:35:07 <quchen> Env = environment?
12:35:09 <edwardk> Snaplet is another example of something that is basically a ComonadEnv, you have the snaplet configuration, which provides access to all sorts of configurator craziness, the path to the snaplet, etc. and some other value.
12:35:27 <edwardk> and you can edit that value using this snaplet configuration, and rewrap it in the snaplet config
12:35:28 <edwardk> yep
12:36:01 <edwardk> ComonadEnv is boring, but then so is MonadReader.
12:36:23 <quchen> And since it's not polymorphic in e (for a given a), I can't change the environment?
12:36:39 <beaky> in what cases are the unsafe functions like unsafePerformIO and unsafeCoerce useful?
12:36:51 <quchen> So it's basically a label, and if I decide I want that label back I have to use runEnvT?
12:37:00 <tac-tics> beaky: when you don't have time to refactor all your code.
12:37:09 <quchen> ... and the default "extract" action is getting rid of the environmental information
12:37:11 <edwardk> quchen: you can construct something like local
12:37:21 <tac-tics> I don't think I've ever found a need for unsafeCoerce... perhaps it's more useful for low-level code.
12:37:24 <edwardk> local :: (e -> e) -> EnvT e w a -> EnvT e w a
12:37:32 <tac-tics> unsafePerformIO, again, is useful when dealing with FFI sometimes.
12:37:39 <edwardk> however for moral reasons i don't have the local equivalent inside of my comonad ;)
12:38:13 <geekosaur> unsafeCoerce can be useful when you can prove that something is a given type but the compiler can't.  unsafePerformIO is mostly used for the FFI, when you know that a given C function is actually pure (which the FFI can't know)
12:38:13 <tac-tics> In actual code, if you think you NEED to use unsafePerformIO (and you're not doing FFI), then you probably just got frustrated, and you don't actually need to
12:38:14 <quchen> What do you mean with that?
12:38:36 <edwardk> quchen: it is more that the MonadReader and MonadWriter are 'too big'. they put too many constraints on the argument
12:38:46 <edwardk> local, pass, listen are somewhat evil
12:39:08 <edwardk> there should be a class that provides a reader with local, and a class that extends a writer with pass and listen
12:39:29 <edwardk> there are plenty of otherwise perfectly good MonadReader/MonadWriter instances that can't be written because they don't support those operations
12:39:41 <quchen> Ah, you meant that although there is a "local" function for Env, it's not part of the typeclass
12:39:47 <edwardk> eg. i can't make a MonadWriter that logs to disk
12:40:14 <edwardk> the same moral objection applies to comonads when it comes to local
12:40:59 <quchen> Hm. Well, coming back to the intuition about Env: "change content, keep label" is fmap.
12:41:12 <edwardk> (and with Traced when it comes to censoring/passing/listening to traced comonads
12:41:15 <quchen> How's extend to be interpreted?
12:41:31 <edwardk> extend is change content, keep label. but the new value can depend on the environment.
12:41:43 <edwardk> consider the simpler form
12:41:58 <edwardk> extend :: ((e, a) -> b) -> (e,a) -> (e,b)
12:42:00 <edwardk> write extend
12:42:17 <edwardk> extract :: (e,a) -> a
12:42:47 <edwardk> Env is a pretty boring comonad
12:42:58 <edwardk> ust like how Reader is a pretty boring monad
12:43:04 <Lethalman> why boring?
12:43:15 <quchen> I don't think so. Everything past the Identity comonad is worth looking at for me right now. :-)
12:43:24 <edwardk> its boring because there is only one 'a' inside of it, and the functions right themselves
12:43:33 <edwardk> @djinn ((e,a) -> b) -> (e,a) -> (e, b)
12:43:34 <lambdabot> f a (b, c) = (b, a (b, c))
12:43:37 <edwardk> literally ;)
12:43:38 <quchen> Maybe was my first monad, Env is my first comonad. (Well no, actually streams were)
12:43:53 <Hafydd> [] was my first monad
12:43:59 <edwardk> @djinn (e,a) -> a
12:43:59 <lambdabot> f (_, a) = a
12:44:05 <Hafydd> Or maybe (r ->), actually
12:44:17 <Hafydd> Wait, that isn't...
12:44:28 <quchen> edwardk: So what comonad would you consider interesting?
12:44:37 <edwardk> quchen: i love Store
12:44:40 <quchen> (Of the standard ones in Comonad.Trans)
12:45:13 <Hafydd> Oh, it is.
12:45:49 <Hafydd> @arrr ->
12:45:49 <lambdabot> Shiver me timbers!
12:45:52 <edwardk> Bazaar is store on steroids, and is used all over the place in lens.
12:46:13 <quchen> Store is kind of like a thing that has a record that you can't access directly, only over the provided function, right?
12:46:27 <edwardk> lets take store apart
12:46:35 <quchen> data Store s a = Store (a -> s) a
12:46:41 <edwardk> data Store s a = Store (s -> a) s
12:46:57 <quchen> Up to isomorphism I was right at least ;-)
12:47:00 <edwardk> heh
12:47:11 <edwardk> so what is extract, how can i get an 'a' out of that?
12:47:24 <quchen> extract (Store f a) = f a
12:47:46 <edwardk> duplicate (Store f a) = Store (Store f) a    is also fairly interesting
12:48:23 <quchen> Duplicate confuses me. The type seems easy, but every implementation does strange things.
12:48:43 <edwardk> it is a fairly hairy thing to get right i admit
12:48:58 <quchen> Join was so easy to grasp on the contrary
12:49:20 <beaky> what is the difference between a statement and an expression
12:49:23 <shachaf> i love join
12:49:26 <edwardk> the problem is due to the strength of every functor in hask you usually have two things in scope that could be used
12:49:26 <shachaf> it is so easy to grasp
12:49:40 <shachaf> quchen: duplicate is just coeasy to grasp. You'll get used to it.
12:50:25 <shachaf> edwardk: By the way, your use of s/a is the opposite of the use in lens.
12:50:30 <quchen> shachaf: That's only cohelpful
12:50:40 <beaky> :t (<*>
12:50:41 <lambdabot> parse error (possibly incorrect indentation)
12:50:42 <edwardk> so lets think about Store as having some function used to generate something like, say an image, where s is the coordinate. and 'a' is the value of each pixel.
12:50:42 <beaky> :t (<*>)
12:50:43 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:50:51 <edwardk> Store (Int,Int) Color
12:51:06 <edwardk> then a Store represents an image with a selected pixel
12:51:14 <edwardk> (here our image is infinite in all directions)
12:51:17 <beaky> should I prefer <$> or <*>?
12:51:20 <edwardk> well, as infinite as an Int gets ;)
12:52:02 <edwardk> so given our Image = Store (Int, Int)   comonad, we can extract to get the color for the current pixel
12:52:44 <edwardk> and we can extend to calculate a new color for our current pixel, where we can look at neighboring pixels, pixels at absolute positions, etc. in the image all simultaneously.
12:52:45 <quchen> So our store has a value (the picture), plus something that lets us extract certain information from it
12:53:00 <fragamus> is there a lens thingy to tack on an additional value at the end of a tuple
12:53:27 <edwardk> when we finish extending it, we have a new image where we generated each pixel by basically focusing the store in on that position and extracting its value, and using your filter
12:53:39 <edwardk> fragamus: in general lenses don't change shapes
12:54:04 <fragamus> ok
12:54:11 <fragamus> ill make a lambda function
12:54:22 <shachaf> quchen: Without the extra types duplicate looks like dup :: (a, a -> t) -> (a, a -> (a, a -> t))
12:54:42 <shachaf> @ty let dup :: (a, a -> t) -> (a, a -> (a, a -> t)); dup (x,f) = (x,\y -> (y,f)) in dup
12:54:43 <lambdabot> (a, a -> t) -> (a, a -> (a, a -> t))
12:54:47 <|||tux||> trying to compile poppler from hackage, but I'm getting "Unacceptable result type in foreign declaration: CULong". How can I fix this?
12:54:47 <edwardk> up :: Store (Int,Int) a -> a; up (Store f (x,y)) = f (x, y + 1)  -- is a 'Store action' in the store comonad.
12:54:58 <edwardk> when you extend it you shift the entire 'picture'
12:55:05 <edwardk> but i could write something like
12:55:43 <mreh> what is different between Int and CInt? CInt is architecture dependent?
12:55:47 <edwardk> vblur :: Fractional a => Store (Int, Int) a -> a; vblur (Store f (x,y)) = (f (x, y - 1) + f (x, y + 1)) / 2
12:56:01 <edwardk> CInt should be the size of an 'int' in C.
12:56:07 <mreh> cool
12:56:11 <`nand`> Int is architecture dependent
12:56:19 <edwardk> mreh: note in haskell on a 64 bit platform Int becomes 64-bits, but CInt remains 32.
12:56:58 <shachaf> Depending on your 64-bit platform. :-)
12:57:04 <quchen> edwardk: That looks nice at least, and reminds me a little about the celluar automaton examples for comonads.
12:57:09 <bscarlet> beaky: prefer seems an odd way to look at it.
12:57:23 <edwardk> haskell effectively follows the ILP64 architecture even on platforms where C follows LP64
12:57:40 <edwardk> quchen: it should, that cellular automata example can be viewed this same way
12:57:50 <edwardk> Store Int a   -- now you have a number line full of a's
12:58:31 <quchen> So that's Store (Int -> a) Int
12:58:47 <edwardk> those are the fields of the data constructor, yes
12:58:52 <hpaste> “|||tux||” pasted “Full error message” at http://hpaste.org/80942
12:59:30 <quchen> That saves a single Int. Extending it gives me Store (Int -> a) (Store (Int -> a) Int)
12:59:38 <quchen> Excuse the mixing of types and code there
12:59:53 <quchen> Wait, that doesn't work.
13:00:04 <geekosaur> |||tux||, you need to modify the sources to import the appropriate module; ghc's FFI used to be lax about enforcement of that part of the spec but as of 7.6 it is scrict about it
13:00:07 <shachaf> dup :: (a, a -> t) -> (a, a -> (a, a -> t))
13:00:20 <quchen> Also by extend I meant duplicate, I keep mixing those up.
13:00:23 <|||tux||> geekosaur: Which module?
13:00:41 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Foreign-C-Types.html#t:CULong
13:01:01 <geekosaur> probably it's not importing anything at all for them and just assuming the right thing willhappen, which it used to
13:01:01 <`nand`> ‘duplicate’ on a Store gives us, for each ‘position’, a new store that is ‘centered on’ that position?
13:01:20 <geekosaur> but it was never correct and ghc now correctly complains about it
13:02:29 <|||tux||> geekosaur: from Types.hs: import Foreign.C.Types (CULong, CUInt)
13:03:14 <|||tux||> In Types.chs, I can only find   {# call fun unsafe poppler_document_get_type #}
13:04:13 <beaky> so Haskell has no such thing as statements, only expressions?
13:04:31 <edwardk> foo a b = … is a statement
13:04:37 <beaky> ah
13:04:37 <edwardk> the … part is an expression
13:04:56 <|||tux||> Ok changing "import Foreign.C.Types    (CULong, CUInt)" to "import Foreign.C.Types    (CULong(..), CUInt(..))" in Types.chs compiles
13:05:01 <geekosaur> I would say it is not a statement but a declaration
13:05:11 <edwardk> fair enough
13:05:12 <johnw> i would say it's a definition... ;)
13:05:12 <lambdabot> johnw: You have 1 new message. '/msg lambdabot @messages' to read it.
13:05:20 <geekosaur> and there are no statements as such in Haskell
13:05:21 <johnw> foo :: ... is a declaration
13:05:22 <edwardk> you might want to call the individual parts of a do block statements
13:05:33 <edwardk> but declaration is a better term for the top level
13:05:48 <johnw> edwardk: i'll take a look at indexed on GitHub then
13:05:56 * `nand` would go for ‘definition’ as well
13:06:02 <johnw> edwardk: my use case won't be released for a little while
13:06:02 <geekosaur> yeh, probably definition is more appropriate there, but declaration is somewhat more general and can encompass definitions
13:06:22 <`nand`> statement/declaration I think I would include everything top level like module export declarations or import statements
13:06:33 <edwardk> indexed will likely be a year+
13:06:33 <`nand`> but definition for definitions of names in particular
13:06:55 <johnw> edwardk: maybe the parts I need would be worth releasing sooner?
13:07:26 <johnw> edwardk: I just want to create a parser GADT using fixed-point recursion and HFunctor, without having to recode it all
13:07:36 <pyry`> johnw: looks like i'm having the same issue with ghc installed from homebrew.
13:07:43 <johnw> i should say, AST GADT
13:07:55 <monochrom> yes, I would use "definition" for "... = ..."
13:07:57 <johnw> pyry`: the link issue?
13:08:06 <johnw> pyry`: did you extirpate the haskell platform?
13:08:39 <pyry`> johnw: yep, link issue. and as far as i can tell i got what mattered-- uninstall-hs, then removed .ghc and .cabal from my home dir
13:08:47 <monochrom> then again, "class X t where ..." defines class X too
13:08:56 <pyry`> johnw: but i'll try find and see if i missed something
13:09:03 <johnw> pyry`: do you still have two version of old-time in ~/.cabal/lib then?
13:09:56 <pyry`> johnw: just one version, but the error is still on oldtime, however the path is now to the local version instead of a system-wide version
13:10:12 <johnw> and runhaskell -v says?
13:10:30 <monochrom> old-time should be in global
13:10:43 <edwardk> johnw: why? =)
13:10:50 <pyry`> johnw: shall i paste? :)
13:10:56 <johnw> edwardk: why do I want to use HFunctor?
13:11:02 <edwardk> johnw: also did you see my Remote.hs example of HFunctor based bound?
13:11:12 <johnw> edwardk: no, not yet
13:11:46 <pyry`> johnw: it appears to be nothing new to me, but http://hpaste.org/80943
13:12:02 <johnw> yep, same conflict
13:12:14 <pyry`> i'm not sure where it's getting the two versions here though
13:12:16 <monochrom> kill everything in local
13:12:22 <johnw> can you do: ghc-pkg list | grep old-time
13:12:29 <johnw> i only have 1.1.0.0
13:12:39 <pyry`> :D
13:12:40 <pyry`> i do not
13:12:40 <pyry`> $ ghc-pkg list | grep old-time
13:12:40 <pyry`>     old-time-1.1.0.0
13:12:41 <pyry`>     old-time-1.0.0.7
13:12:48 <johnw> ghc-pkg unregister old-time-1.0.0.7
13:12:50 <pyry`> is it usually safe to
13:12:53 <pyry`> ah, will do
13:13:09 <johnw> some package is going to fail because of that
13:13:13 <johnw> i'm interested to know which one
13:13:29 <pyry`> heh, unfortunately it list that it is the ones i needed: would break data-object-yaml-0.3.4.2 convertible-text-0.4.0.2
13:13:30 <johnw> one of the things you've installed needs to have its dependency list updated
13:13:34 <johnw> aha
13:13:48 <pyry`> i'll check data-object-yaml quick
13:13:53 <johnw> might I suggest using "aeson" and "yaml" for dealing with YAML?
13:14:20 <pyry`> i can try
13:14:28 <pyry`> maybe what i've learned from data-object-yaml will help me in dealing with aeson now
13:14:35 <johnw> aeson is dead simple
13:14:36 <pyry`> still somewhat new so some things are more of a struggle than others ;)
13:14:55 <johnw> just import Data.Aeson, and qualified Data.Yaml as Y, and then you have Y.decode and Y.encode
13:14:58 <johnw> couldn't be easier
13:15:44 <pyry`> i'll give it a go
13:16:04 <johnw> this is exactly why we are working on stackage
13:16:20 <monochrom> what is stackage?
13:16:23 <johnw> because hackage is a place where be dragons, and newbies go through pain like this when they wake them
13:16:49 <monochrom> what will stackage do to make a difference?
13:16:58 <johnw> monochrom: it's a curated set of packages all guarantee to work together dependency-wise
13:17:05 <pyry`> mm
13:17:11 <johnw> and we build them all together, and run all of their tests, every day
13:17:24 <johnw> things like conflicting package versions just can't happen in stackage
13:17:26 <monochrom> ok that sounds good. but also may miss the real problem
13:17:29 <pyry`> this sounds hopeful!
13:17:56 <johnw> monochrom: http://www.yesodweb.com/blog/2012/11/solving-cabal-hell
13:18:02 <johnw> that's the article which spawned the idea
13:18:30 <elliott> stackage just seems to replace the problems of decentralisation with the problems of centralisation
13:18:58 <johnw> as long as those problems are less hurtful to beginners, that's the point
13:19:09 <johnw> you could say the same about haskell-platform
13:20:08 <monochrom> the real problem is possessing multiple versions. this is at the cabal-install level, or further down. not on the "whose repo to use" level. at least, as long as the repo hosts multiple versions
13:20:10 <pyry`> i suppose now my issue is instead learning things about haskell instead of learning why packages are broken, so you're right there.
13:20:45 <johnw> monochrom: well, the idea is to give haskell-platform users a better repo to use when they are ready to cut their teeth with cabal, before releasing them into the wild that is hackage
13:20:49 <pyry`> now i have to learn how to properly write an instance for FromJSON instead of running a script that fails to give me errors about language ;)
13:21:11 <johnw> pyry`: let me give you two examples
13:21:14 <pyry`> so, this is better than before!
13:21:19 <|||tux||> Does gtk2hsC2hs strip preprocessor commands?
13:21:51 <hpaste> johnw pasted “using deriveJSON” at http://hpaste.org/80945
13:22:00 <pyry`> johnw: i'd actually tried aeson and yaml before, but i couldn't find examples enough to help learn-- not that the documentation is bad, i just have much more to learn before documentation helps me
13:22:00 <johnw> that's the easiest way, using deriveJSON
13:22:10 <monochrom> actually, the repo hosting unique version does not solve the problem either
13:22:18 <beaky> > [(+ 10), (* 20)] <*> [1..10]
13:22:20 <lambdabot>   [11,12,13,14,15,16,17,18,19,20,20,40,60,80,100,120,140,160,180,200]
13:22:29 <hpaste> johnw pasted “using FromJSON” at http://hpaste.org/80946
13:22:39 <johnw> that's the manual way, although I'm only going from JSON, not to it
13:23:09 <pyry`> mm
13:23:23 <johnw> monochrom: doesn't it at least help the problem?  pyry` has spent a whole day banging his head against this old-time dependency problem
13:23:33 <pyry`> johnw: thanks, i'll stare at it for a bit :)
13:23:39 <johnw> when the real answer was, "Just don't mix such an old library with new libraries"
13:24:01 <pyry`> the thing about that problem too is that's something i can understand from other languages
13:24:08 <pyry`> but it's difficult for me to arrive at this as a beginner
13:24:14 <pyry`> and then know where to procede from that problem
13:24:15 <johnw> or to know what the solution is
13:24:18 <johnw> it's hard to google for
13:24:21 <pyry`> yeah
13:24:28 <pyry`> i found nothing clear while googling
13:24:30 <monochrom> on January 18, stackage hosts blah-1.1 uniquely, I cabal-install that, so far so good it seems. on February 1, stackage removes blah-1.1 and hosts blah-1.2 instead, I get the news, I cabal-install that. now I have 2 versions, even though at every point of time stackage has just one version
13:24:47 <monochrom> the real problem is bloody not on hackage or stackage. never has been
13:25:20 <johnw> monochrom: but could you ever be in a situation were cabal install foo _wouldn't_ upgrade every dependency library needed to create a consistent set of installed libs?
13:25:32 <johnw> on hackage, you can have foo fixed at old-time-1.0 and bar fixed at old-time-1.1
13:25:42 <johnw> and there's nothing you can do, if you import both foo and bar
13:25:54 <johnw> now, part of pyry`'s problem is that he didn't build with cabal
13:25:55 <johnw> granted
13:26:04 <johnw> cabal would have told him he had conflicting dependencies
13:26:13 <johnw> instead he just went straight to runhaskell, which gives no indication
13:26:22 <johnw> (and is probably why he couldnt' find many people complaining about this issue)
13:27:59 <pyry`> in addition, if i wanted to try to fix my issue with the broken package, i'm not sure where i might go about updating it's dependency, but that's sort of unrelated
13:28:28 <pyry`> it was looking like it was convertible-text
13:28:54 <gienah> pyry`: you can find the list of broken pkgs with: ghc-pkg check
13:29:33 <pyry`> i meant instead of broken, one causing issues with old dependencies
13:29:45 <pyry`> assuming i wanted to try bumping up the version and running
13:29:58 <johnsonw> I've got some commonly used binary functions in my code, and I'm thinking of using a symbolic name for these for clarity and brevity. I know some people like them, some people not. Is there a guide for what symbols you can use in Haskell, which are a good idea, which are likely to conflict, good ideas, and so on?
13:31:14 <AkoAda> hi, I need some advices with monads
13:31:33 <monochrom> one day you will learn that "ghc-pkg check" misses some problems
13:32:54 <monochrom> to a large extent, "ghc-pkg check" only makes sures that files exist
13:33:25 <johnw> i would really enjoy ghc-pkg fsck
13:34:19 <monochrom> "ghc-pkg check" never knows the multiple-version DLL hell problem. only "ghc -v" knows
13:35:40 <monochrom> to some extent you could argue that multiple-version DLL hell is not "broken package" and therefore not the job of "ghc-pkg check". afterall, it is not a data loss problem. it is a data surplus problem. you have too many packages and files, not too few, no data is missing.
13:35:48 <pyry`> johnw: so, here are the pedagogical stumbling blocks with the examples. i think this is what drove me to try data-object-yaml
13:36:08 <pyry`> johnw: first one leads to template haskell and lenses, which i don't know much about except for the names (heh)
13:37:15 <pyry`> johnw: second one seems to lead to issues with Text and [Char] once i satisfy imports
13:37:25 <pyry`> which i kiiind of get
13:37:33 <pyry`> but here i know it's that there's somthing i don't know about
13:38:14 <gienah> pyry`: I think you can find the list of system deps that depend on a pkg like: cd /usr/lib64/ghc-7.6.1/package.conf.d/; grep pkg-version *.conf
13:38:40 <gienah> pyry`: and there's probably a similar method for checking the user/cabal pkgs
13:39:51 <pyry`> gienah: ahh, thanks
13:39:57 <preyalone> How well does Haskell support Android at this point? I'd really like to write my Android apps in Haskell if possible.
13:40:38 <gienah> pyry`: example of grep pkg-version *.conf: grep -l old-time-1.1.0.1 *.conf
13:40:55 <gienah> pyry`: the -l just lists the filenames
13:41:28 <zxq9> Conflicting advice on the GHC install page. Its says "install GHC before haskell platform" and on the GHC page it says "stop! we recommend installing haskell platform instead of GHC". Does haskell platform pull GHC source in as a configure step?
13:41:29 <epta> What happens with hayoo?
13:42:31 <johnw> pyry`: fear not Text vs. [Char].  pack and unpack are your friends
13:44:52 <bos> zxq9: the platform includes GHC
13:44:53 <Lethalman> zxq9, I just didn't install haskell platform, installed ghc and everything else from cabal :P
13:45:11 <Lethalman> but I believe in a usual installation haskell platform is preferred, don't know
13:45:20 <geekosaur> preyalone, they're still working out build issues on ARM, I believe
13:46:01 <pyry`> johnw: ah, example 2 was overloadedstrings
13:46:09 <johnw> yes
13:46:11 <zxq9> If platform pulls in ghc, then that makes more sense. The install page was just confusing.
13:46:14 <johnw> sorry for omitting that context
13:46:23 <johnw> i basically always use overloaded strings everywhere these days
13:47:03 <geekosaur> zxq9, it's not reallhy conflicting unless you're ignoring some stuff.  if you are doing a source build of the haskell platform instead of downloading a package, you need to start from a ghc install.  source builds of the platform are not usually needed (or a very good idea unless you're bootstrapping a new platform for which there is no package)
13:47:10 <pyry`> johnw: oh, no worries. made me try to think about new things ;)
13:47:31 <pyry`> johnw: i assume there's a reason for the recommendation of these examples so there's probably something worth spending time to figure out here
13:47:38 <geekosaur> haskell platform binary packages include the appropriate ghc
13:48:07 <johnw> pyry`: they are just pretty typical of what you'll find yourself doing over and over again.  Some additional operators, like .:? are nice to know too, but I assume you'll get there soon enough
13:48:08 <pyry`> johnw: now i just set this off with some version of aeson parse?
13:48:12 <zxq9> geekosaur: OK, then I do need to build GHC first. Justhub is broken and the most current Haskell in EPEL (for RHEL/SL 6.x) is two years old.
13:48:24 <johnw> if you are using Yaml, then Data.Yaml.decode
13:48:26 <pyry`> johnw: yeah... those appear at least to be specific to aeson
13:48:43 <geekosaur> you will need some recentish version of ghc to build a later ghc with
13:49:05 <johnw> zxq9: when did justhub break?
13:49:12 <geekosaur> HOWEVER.  the current HP expects ghc 7.4.2; there are a lot fo packages not yet updated to 7.6, so if you want to install the platform, you ant to build ghc 7.4.2
13:49:15 <johnw> zxq9: i installed GHC from there just a few weeks ago
13:49:46 <geekosaur> if you realy want ghc 7,6, there is not yet a Haskell Platform targeting it (and as I just said, a lot of packages still don't support 7.6 so you can't easily port it over)
13:50:14 <zxq9> johnw: I tried the other day (again) and the install works, but updates beyond 7.0 were failing. I forget the error just now.
13:50:33 <pyry`> johnw: is there any way to use overloaded strings in ghci, or are the language settings restricted only to compiling?
13:50:45 <johnw> yes, ghci -XOverloadedStrings
13:50:56 <pyry`> ahh
13:51:02 <pyry`> saw that somewhere. d'oh
13:51:43 <LambdaDusk> Hi... I am trying to re-build this example: http://www.yesodweb.com/book/wiki-chat-example Can anyone tell me where the function "getChat" comes from?
13:52:01 <shachaf> LambdaDusk: Maybe #yesod would know.
13:52:19 <LambdaDusk> shachaf: Would if it wasn't dead.
13:52:33 <johnw> LambdaDusk: it's just a record accessor for the Wiki data type
13:52:45 <shachaf> In this case the answer is line 26.
13:53:00 <johnw> shachaf: how did you know what line it was on?
13:53:08 <pyry`> johnw: fantastic, got it working now
13:53:13 <pyry`> johnw: thanks for the tutelage
13:53:19 <johnw> pyry`: most welcome!
13:53:29 <LambdaDusk> johnw: No, it's for the Chat data type that was built in the first example, but it's not mentioned anywhere
13:53:37 <pyry`> johnw: now i see why this is ridiculously easier than data-object-yaml, but i'm glad i spent time figuring it out anyway
13:53:45 <shachaf> johnw: I'm psychic.
13:53:54 <shachaf> LambdaDusk: The answer johnw gave you is correct.
13:54:03 <LambdaDusk> johnw: I just saw it. Thanks.
13:55:48 <monochrom> it is always line 26 :)
13:59:11 <LambdaDusk> "Not in scope: type constructor or class `Bool'" WTF??
14:03:05 <byorgey> LambdaDusk: you have used Bool in a way that you should not.
14:03:28 <byorgey> I guess Bool is a type constructor though, huh?
14:03:56 <monochrom> it is. but "not in scope" is strange
14:04:03 <monochrom> show actual code
14:05:19 <shachaf> monochrom: Death, taxes, and people not showing actual code.
14:05:25 <LambdaDusk> byorgey: Could it be some trouble with TemplateHaskell?
14:05:50 <byorgey> LambdaDusk: It could be some trouble with squirrels eating your CPU.
14:05:54 <shachaf> LambdaDusk: It could be many things. Are you ignoring what monochrom said?
14:06:06 <byorgey> without seeing your code it's impossible to tell.
14:06:19 <LambdaDusk> monochrom, shachaf: Pasting now...
14:06:20 <monochrom> yesterday we hit a 20-minute record high for time after beginning the question and still not showing actual code
14:06:30 <byorgey> haha
14:06:36 * byorgey is surprised that is a record
14:06:55 <geekosaur> not counting the times where it was never shown...
14:06:59 <shachaf> Presumably that's the record for yesterday.
14:07:28 <monochrom> someone asked why [ blahblah | x <- map fibo [1..foo] , ... ] was both slow and giving wrong answers
14:07:30 <frerich_> Hm, is there some reason why there is no Functor instance for MVar? It seems quite 'natural'.
14:07:55 <shachaf> frerich_: It can't be.
14:08:01 <LambdaDusk> monochrom, shachaf: https://gist.github.com/fc09f847a86beab26182
14:08:13 <shachaf> frerich_: Go ahead and write: (a -> b) -> MVar a -> MVar b
14:08:22 <monochrom> the subsequent 20 minutes were spent on debating over project euler, "you need a better algorithm", "no I am fine with slow", etc etc
14:08:41 <monochrom> the actual code for fibo was never shown
14:08:50 <frerich_> shachaf: Ah, good point. I was thinking of 'apply a pure function to a value in an MVar' but now I realize that this is not what fmap does.
14:09:10 <preyalone> What are my options for Haskell to JavaScript compilation?
14:09:22 <monochrom> I am fine with slow, too. but since you mentioned wrong answers, perhaps something was wrong in fibo?
14:10:02 <geekosaur> LambdaDusk, so now show the complete actual error
14:10:07 <LambdaDusk> preyalone: GHC-js, UHC with js backend, GHC to LLVM and then using emscriptem
14:10:19 <LambdaDusk> geekosaur: Appended in the errors.txt in the gist
14:10:21 <shachaf> geekosaur: It's at the bottom isn't it?
14:10:31 <geekosaur> sorry, missed it
14:10:33 <shachaf> LambdaDusk: Does Yesod do some evil NoImplicitPrelude magic or something?
14:10:52 <shachaf> This can barely be called Haskell code. This is Yesod code.
14:11:00 <LambdaDusk> shachaf: I actually think it could be some TemplateHaskell
14:11:33 <shachaf> A data constructor of the name Bool is in scope, but a type constructor is not?
14:11:41 <LambdaDusk> shachaf: It does, in the .cabal
14:11:48 <shachaf> LambdaDusk: OK then.
14:11:54 <shachaf> This is a Yesod problem, not a Haskell problem.
14:12:00 <LambdaDusk> where do I have to add it, then?
14:12:05 <shachaf> Bool is not in scope; you need to import it, just like anything else that isn't in scope.
14:12:14 <shachaf> I usually take it from Prelude.
14:14:10 <LambdaDusk> thanks...
14:14:57 <LambdaDusk> but i love how once I got past the type errors, all haskell stuff works like a charm
14:15:21 <shachaf> Does Yesod stuff also possess that property?
14:15:46 <johnw> part of yesod's philosophy is to take advantage of static type checking everywhere
14:17:17 <shachaf> I suppose writing your entire program in Template Haskell is one way of doing that.
14:18:00 <johnw> and it gets you into shachaf's good graces as a side benefit!
14:19:37 <hpaste> NihilistDandy pasted “Why is this illegal?” at http://hpaste.org/80950
14:19:51 <johnw> um, what part?
14:19:52 <NihilistDandy> Can someone explain illegal instances of this sort to me?
14:20:13 <johnw> ah, I see, at the end
14:20:24 <johnw> what error do you see, exactly?
14:20:40 <NihilistDandy> "(All instance types must be of the form (T a1 ... an)
14:20:40 <NihilistDandy> ||    where a1 ... an are *distinct type variables*,", etc.
14:20:55 <zxq9> johnw: Looks like justhub is indeed fixed. The initial "cabal install cabal-install" works where it was previously failing. :-) Whew.
14:21:05 <NihilistDandy> It says to turn on -XFlexibleInstances, which I can, I'm just curious what's causing it.
14:21:19 <Cale> NihilistDandy: It's a restriction which was in Haskell 98 to make instance resolution very simple
14:21:34 <monochrom> you're missing T. T is a type or type constructor
14:22:00 <monochrom> example. "instance Euclid Double" is fine
14:22:08 <Cale> It means that when you write an instance of a type class, the type you're writing the instance for has to consist of a single type constructor applied to some distinct type variables
14:22:17 <monochrom> example. "instance (Maybe a)" is also fine. T=Maybe, a1=a
14:22:24 <NihilistDandy> Ah, okay
14:22:27 <NihilistDandy> That makes sense, then
14:23:12 <Cale> You should be aware: instance selection is done *without* reference to constraints on the instance being chosen, and those constraints are checked only *after* which instance to use is decided on.
14:23:48 <Cale> This is because of separate compilation: you can never know for sure while compiling a module that there won't be an instance in a future module of some class.
14:23:56 <monochrom> typo correction. instance Euclid (Maybe a)
14:24:00 <NihilistDandy> So I need to make sure that if an instance is declared for a Euclid Int, all the previous ones need an Int instance as well, yes?
14:24:09 <Cale> yeah
14:24:23 <NihilistDandy> Okay, cool. That clears some things up.
14:24:40 <NihilistDandy> Thanks, all
14:24:42 <Cale> But also, if you write things like  instance Field a => Euclid a -- you can make the compiler accept this instance, but it overlaps with everything
14:25:00 <Cale> i.e. for the purposes of choosing instances, it's as if you wrote   instance Euclid a
14:26:04 <Cale> and then after the instance is chosen, it will add a constraint that will insist that a Field instance is present in the end
14:26:19 <Cale> (but that Field instance is allowed to occur in a future module)
14:26:47 <NihilistDandy> And that's what -XFlexibleInstances gives me
14:27:15 <Cale> Yeah, it lets you write things like that, and also things where the instance has a type constructor applied to specific types
14:27:23 <Cale> or type variables which are not distinct from each other
14:27:33 <Cale> For example,  instance Foo String
14:27:44 <Cale> which is really   instance Foo [Char]
14:27:51 <Cale> or   instance Foo (a,a)
14:28:03 <Cale> (where the type variables aren't distinct)
14:28:11 <NihilistDandy> Wow, really flexible
14:29:22 <Cale> But yeah, the generic instances that you're trying to write will be a pain
14:29:53 <NihilistDandy> Yeah, I just tried FlexibleInstances and now I get a suggestion for UndecidableInstances
14:29:56 <Cale> right
14:30:20 <NihilistDandy> That's a new one. I'll have to read up on that.
14:30:20 <Cale> You can go down that road, but it can result in some surprising behaviour
14:30:30 <NihilistDandy> Oh?
14:31:25 <FreeFull> If I have a binding in ghci, how do I get rid of it? I have accidentally declared overlapping instances, and I had to restart ghci to get rid of them. I then read :r will get rid of all temporary bindings, but that wouldn't be any useful either
14:31:39 <Cale> Because you start to end up in situations where a module will compile and behave one way, and by adding an import, it will still compile, but have different behaviour, for example.
14:32:22 <NihilistDandy> Yeah, I'm reading a Luke Palmer post from '08 that talks about some of the issues with undecidable instances.
14:32:39 <Cale> Or if you get into incoherent instances, you can end up with situations where the polymorphic instance is selected before a more specific one becomes visible.
14:32:57 <monochrom> usually, :load is an even stronger reset than :reload
14:33:14 <Cale> I also recommend reading the GHC user guide on it
14:33:17 <FreeFull> monochrom: What I want to do is get rid of just a single binding though
14:33:43 <Cale> There are a lot of details of these extensions which are hard to remember, but which are worth looking at again whenever this becomes an issue.
14:34:26 <Cale> In general, I tend to just sidestep the whole problem by making a newtype and then writing the general instance for the newtype instead.
14:34:31 <geekosaur> FreeFull, as yet I don't think you can
14:34:51 <NihilistDandy> That's most of what I've seen as a solution, yeah.
14:34:56 <FreeFull> geekosaur: Aww
14:35:01 <monochrom> there may not be a command for removing one single binding or instance or ...
14:35:46 <NihilistDandy> It seems like in this case in particular it will be especially appropriate since Num covers multiple groups and fields.
14:36:10 <NihilistDandy> I'll just have to be specific
14:43:41 <beaky> Is there some kind of correspondence between pattern matching and folds?
14:43:55 <ciaranm> that's a rather deep question
14:44:00 <ciaranm> and yes
14:44:09 <ciaranm> specifically, algebra
14:44:14 <beaky> ah
14:44:26 <beaky> I didn't do too well in algebra back in high school :(
14:44:33 * beaky has bad memories of failing algebra
14:44:51 <FreeFull> beaky: Maybe your teachers were rubbish
14:45:11 <ciaranm> you don't get to do algebra in high school. you just do some mucking around with symbols.
14:45:16 <beaky> ah
14:45:16 <monochrom> that's a different sense of algebra
14:46:36 <monochrom> dear ssbr`: are you interested in a monthly Toronto Haskell user group meeting? the next one is in the second wednesday of february
14:46:37 <`nand`> shachaf: do you love algebras?
14:47:05 <ssbr`> Ach, I've been spotted
14:47:08 * ssbr` ducks for cover
14:47:18 <monochrom> the place is near kensington market
14:47:23 <ssbr`> monochrom: I don't regularly use haskell, so probably not, sorry. :(
14:47:25 <ciaranm> what's that aboot eh?
14:47:29 <FreeFull> "As a single word, "algebra" can mean * Use of letters and symbols to represent values and their relations, especially for solving equations. This is also called "elementary algebra". Historically, this was the meaning in pure mathematics too, like seen in "fundamental theorem of algebra", but not now.  * In modern pure mathematics, a major branch of mathematics which studies relations and operations. It's sometimes called abstract algebra, or
14:47:35 <FreeFull> "modern algebra" to distinguish it from elementary algebra."
14:48:01 * hackagebot yesod-datatables 0.1.1 - Yesod plugin for DataTables (jQuery grid plugin)  http://hackage.haskell.org/package/yesod-datatables-0.1.1 (TeroLaitinen)
14:48:02 <ciaranm> really, the kind of algebra we're talking about is category theory
14:48:14 <ciaranm> but it's not called that for hysterical raisans
14:48:20 <monochrom> ssbr`: you can just come and listen. you don't have to say a thing
14:48:37 <beaky> ah
14:48:38 <monochrom> you don't have to use haskell. you just have to be interested
14:48:53 <FreeFull> Category theory monads confuse anyone who wants to use monads in programming
14:48:55 <monochrom> i.e., you just have to like
14:49:21 <ciaranm> you just need to know your monads from your monoids
14:49:44 <FreeFull> A monoid is something completely different
14:49:57 <ciaranm> a monad is a monoid in the category of endofunctors
14:50:24 <hiptobecubic> where does the monoidal part come in? join?
14:50:27 <FreeFull> Yeah, but there are a lot of things that are monoids but not monads
14:50:50 <ciaranm> hiptobecubic: more or less, yes
14:51:03 <FreeFull> Same how a square is a quadrilateral in the category of rectangles
14:51:37 <cads> ciaranm: that's a reasonable definition, too :)
14:51:37 <cads> makes it easy to remember
14:52:05 <hiptobecubic> FreeFull, i'm not sure that works out the same way
14:52:20 <hiptobecubic> are there monoids in the category of endofunctors which are *not* monads?
14:52:45 <FreeFull> hiptobecubic: You're right
14:52:52 <ciaranm> hiptobecubic: nope. it's effectively a definition.
14:53:04 <hiptobecubic> right
14:53:21 <ciaranm> also it's not obvious how you'd form a category out of rectangles in a useful way
14:53:25 <FreeFull> A square is a regular polygon in the category of rectangles?
14:53:26 <tac-tics> A group is the category of itself.
14:53:53 <ciaranm> possibly something vector-space-ish
14:54:34 <beaky> ah the classic OOP rectangle-square problem
14:54:39 <hiptobecubic> :D
14:54:45 <bergmark> :]
14:55:02 <monochrom> ssbr`: closing remark: our mailing list is a Google group at https://groups.google.com/forum/?fromgroups#!forum/toronto-haskell  you can monitor it or subscribe to it, we announce meeting times there monthly
14:55:02 <hiptobecubic> rectangles are squares. there. done.
14:56:25 <fragamus> is there a logging monad
14:56:27 * monochrom must be a repelling fixed point
14:56:39 <hiptobecubic> fragamus, the easiest to think about is Wrtier
14:57:06 <fragamus> ok so its output only right
14:57:17 <hiptobecubic> what would it read?
14:57:41 <hiptobecubic> presumably writing to the log does not depend on the state of the log
14:58:46 <FreeFull> What about a monad where you can only append data, like Writer, but you can also read the data in?
14:59:43 <simpson> FreeFull: Do you know about State yet?
14:59:51 <monochrom> immutable square is a special case of immutable rectangle. the usual rectangle-square problem is due to a squre mutable to a non-square
14:59:54 <hiptobecubic> ReaderWriter would be State i guess, more or less
15:00:13 <FreeFull> But you can change the state
15:00:33 <FreeFull> The only restriction with the state monad is that the state remains of the same type
15:01:13 <hiptobecubic> so you want to be able to read the log as you go?
15:01:27 <hiptobecubic> but only write to it using the monoidal operator?
15:01:47 <simpson> Wouldn't this largely be equivalent to State? I mean, what's to stop you from altering the log?
15:01:57 <FreeFull> I was just wondering if something like that existed, no use for it
15:02:04 <FreeFull> simpson: Append only
15:03:10 <simpson> FreeFull: Not sure how you'd get there. Reader is r -> a, Writer is (a, w), State is s -> (a, s) and RWS is r -> s -> (a, w, s)
15:03:40 <simpson> r -> (a, w) is close, but if you want to have the types line up so that you can directly alter things, you'd end up with State.a
15:03:46 <simpson> I dunno.
15:05:55 <elliott> you could have w -> (a, w) where the w you result in is mappended to the input
15:06:38 <elliott> return a = const (a, mempty); (f >>= k) w = let (a,w') = f w; (b,w'') = k a (w <> w') in (b, w <> w' <> w'')
15:07:11 <FreeFull> elliott++
15:08:13 <elliott> oh hmm maybe that violates associativity
15:08:15 <elliott> I don't think so though
15:08:52 <qasd> hows haskell for a webserver?
15:08:58 <ciaranm> monadic
15:09:16 <qasd> hows haskell for writing a webserver? bottlenecks != speed of executables right?
15:14:09 <elliott> qasd: Haskell has several very fast webserver libraries.
15:14:10 <beaky> are there more typeclasses we can deriving from besides Show, Read, Eq, Ord, and Enum?
15:14:44 <qasd> define your own typeclass?
15:15:51 <ciaranm> beaky: Functor, Traversable
15:15:56 <beaky> ah
15:16:04 <elliott> (with extensions)
15:16:08 <elliott> Foldable too, given said extensions
15:17:18 <TheRedMood> Testing
15:17:25 <ciaranm> don't test. prove.
15:17:29 <TheRedMood> Haha
15:17:33 <TheRedMood> Just testing the irc client
15:17:42 <frerich_> beaky: Typeable too, I think (with an extension)
15:17:43 <TheRedMood> once again testing
15:17:56 <TheRedMood> Testing
15:17:58 <TheRedMood> There we go
15:18:12 <Ralith> proving
15:18:30 <monochrom> testing is a special case of proving
15:23:32 <johnsonw> Can GHCI tell me the core representation of an expression, or do I have to use GHC?
15:23:50 <johnsonw> Trying to work out how some expressions are desugared
15:24:02 <johnw> that would indeed be an awesome feature
15:24:23 <johnw> but i think core rendering requires a lot more knowledge, doesn't it?
15:24:51 <johnsonw> johnw: i thought GHCI was the basically same code base as GHC
15:24:59 <elliott> -ddump-simpl
15:25:01 <glguy> johnsonw: There is a tool "ghc-core" that helps with reading core
15:25:03 <elliott> you will find the core it gives unhelpful
15:25:08 <elliott> but it works in ghci
15:27:11 <absence> is there a command-line utility for pretty-printing haskell source code?
15:27:34 <monochrom> does "cat" count?
15:27:48 <hiptobecubic> pygmentize :)
15:27:49 <ciaranm> only to three
15:27:54 <AtomicStryker> is there a way to break out of the "forever" Monad? return() doesnt do the trick
15:28:05 <monochrom> what pretty-printing do you want?
15:28:16 <hiptobecubic> "forever" is pretty unambiguous
15:28:28 <AtomicStryker> forever $ do xxx
15:28:34 <AtomicStryker> how do i get out of xxx
15:28:43 <c_wraith> if you got out, it wouldn't be very forever
15:28:49 <monochrom> the "fail" method breaks out of forever
15:28:50 <FreeFull> AtomicStryker: error?
15:28:55 <FreeFull> Ah
15:29:07 <hiptobecubic> also "return()" sounds like you don't know what the code actually does. You should read some more about how monads work probably. LYAH did a good job, I thought.
15:29:19 <monochrom> > forever (fail "bye") :: [Int]
15:29:21 <lambdabot>   []
15:29:22 <absence> monochrom: something like gnu indent
15:29:25 <monochrom> here the monad is []
15:29:41 <hiptobecubic> fail raises an exception most of the time doesn't it?
15:29:48 <ciaranm> fail doesn't exist
15:29:51 <monochrom> yes
15:30:04 <hiptobecubic> > forever (fail "Oh balls.") :: Maybe Int
15:30:05 <AtomicStryker> i realize return() only gives out an empty IO
15:30:05 <lambdabot>   Nothing
15:30:20 <AtomicStryker> but i couldnt google an answer
15:30:20 <ciaranm> AtomicStryker: monads do not work that way!
15:30:34 <absence> monochrom: that can take horribly formatted (but valid) haskell and reformat it into something that looks nice (where "nice" is preferably configurable :))
15:30:54 <hiptobecubic> > forever (fail "Oh balls.") :: IO ()
15:30:55 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
15:30:55 <lambdabot>    arising from a use of ...
15:31:22 <hiptobecubic> can't ghc do that?
15:31:26 <monochrom> absence: I don't think there is any written. but you may be able to cook up one using haskell-src-ext, which has a parser and a printer, the printer may be very customizable
15:32:18 <FreeFull_> > (return ()) :: Maybe Int
15:32:19 <lambdabot>   Couldn't match expected type `GHC.Types.Int' with actual type `()'
15:32:31 <FreeFull_> > (return ()) :: Maybe ()
15:32:32 <lambdabot>   Just ()
15:33:03 <FreeFull_> AtomicStryker: Not an IO here
15:33:16 <ciaranm> > do { return () ; putStrLn "GOAT BALLS" ; }
15:33:17 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
15:33:17 <lambdabot>    arising from a use of ...
15:33:26 <monochrom> there is little market for an indentation changing program because most haskell programmer thinks "my indentation is perfect, why should a computer fiddle with it". in fact, they think "no editor in the world indents my way!"
15:34:17 <FreeFull_> monochrom: As long as it follows haskell's level rules
15:34:37 <monochrom> anyway, I have seen haskell-src-ext used for "put back parentheses everywhere", so it may help
15:34:45 <bergmark> also i think it's much harder to format haskell in a good way compared to other languages, programatically i mean
15:34:48 <absence> monochrom: ok, thanks!
15:35:18 <FreeFull_> AtomicStryker: I don't know if someone said that, but () is basically an empty type
15:35:58 <FreeFull_> Also, return will produce a value in whatever monad you're in, so not necessarily IO
15:36:14 <AtomicStryker> yes im experimenting here, just needed something, anything, to bail out of forever
15:36:20 <AtomicStryker> something that isnt ctrl-c
15:36:32 <ciaranm> or you could not use forever
15:36:36 <monochrom> throw an exception
15:36:40 <AtomicStryker> its poetic.
15:37:02 <monochrom> catch the exception outside the forever
15:37:32 <AtomicStryker> i would have to read up on exceptions and catching first
15:37:32 <AtomicStryker> :D
15:37:49 <fmap> > forever Nothing
15:37:51 <lambdabot>   Nothing
15:37:55 <FreeFull_> Does Haskell even have catching
15:38:04 <FreeFull_> I thought Haskell exceptions were fatal
15:38:09 <tac-tics> FreeFull_: yes. In IO, though
15:38:14 <ciaranm> haskell or ghc?
15:38:14 <monochrom> I have in fact written it at http://www.vex.net/~trebla/tmp/break.hs
15:38:25 <tac-tics> ciaranm: what a blasphemous distinction!
15:38:39 <FreeFull_> ciaranm: Haskell
15:38:58 * ciaranm hugs tac-tics 
15:39:00 <tac-tics> FreeFull_: http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
15:39:17 * tac-tics jhcs ciaranm 
15:39:41 <tac-tics> FreeFull_: that paper is pretty readable and has a nice chapter on exceptions in Haskell
15:39:52 <tac-tics> (although, I wouldn't take any of the code as "modern" or "what people actually use")
15:40:05 <monochrom> yes, the details are old
15:40:28 <FreeFull_> tac-tics: I'm guessing exceptions didn't change between 98 and 2010?
15:40:49 <tac-tics> I dun really know.
15:40:55 <AtomicStryker> im trying to implement a simple game, but i'm running into the issue of not having global variables to save my state with :(
15:41:12 * ciaranm looks at AtomicStryker 
15:41:28 <monochrom> then you should see my simple game at http://hpaste.org/52480
15:41:54 <AtomicStryker> monochrom: glorious!
15:42:02 <bergmark> \o/
15:42:10 <AtomicStryker> i forgot i can put everything behind a var
15:42:14 <monochrom> also, you don't have to use forever
15:42:14 <AtomicStryker> err name
15:42:17 <AtomicStryker> ... whatever
15:42:29 <FreeFull_> monochrom: Teaching people binary search?
15:42:50 <monochrom> I am not sure it counts as teaching binary search
15:43:33 <bergmark> AtomicStryker: you can explicitly pass all state around, then when you realize that it gets tedious you can try looking into State
15:43:33 <FreeFull_> Interesting how it changes the bounds each time
15:43:38 <ciaranm> that's a lot of code in an IO!
15:43:56 <johnsonw> I know I can use [] in do notation, and that's easy if the do is the only thing in the function, but how do I sort of runState a list? so I'd like to say x = runList (do ...) []
15:44:01 <tac-tics> start in IO, refactor until you find yourself in a good place :)
15:44:08 <monochrom> it may count as natural selection for binary search, if we also impose that people who play the game inefficiently should die
15:44:36 <ciaranm> johnsonw: you don't need a runState-like thing for a list
15:44:41 <FreeFull_> johnsonw: What do you want to do? Sort a state where the state is a list?
15:44:44 <monochrom> clearly, natural selection is not teaching
15:44:49 <bergmark> hehe i think that would only weed out the people that can't handle stress well
15:45:03 <FreeFull_> Oh, nevermind
15:45:27 <johnsonw> ciaranm: so what can I do to put a do notation comprehension of a list as an expression? just start a do?
15:45:30 <tac-tics> monochrom: UnsafeKillCoderOnTypeError : * -> *
15:45:50 <ciaranm> johnsonw: do is an expression
15:46:14 <tac-tics> fib :: Nat -> UnsafeKillCoderOnTypeError Nat; fib 0 = 1; fib n = n * fib - 1
15:46:24 <FreeFull_> > do { x <- [3,4]; return (x+1) }
15:46:25 <lambdabot>   [4,5]
15:46:27 <johnsonw> ciaranm: yeah, but when I use the state monad I can't just do and magically get a state monad if the type system isn't there
15:47:08 <ciaranm> johnsonw: roughly speaking, the difference between state and list is that you need to specify something else (the initial state) to get a state monad, but you don't for list
15:47:37 <ciaranm> johnsonw: 'State' isn't a monad. 'State x' is for all x. but [] is a monad.
15:47:42 <FreeFull_> > do { x <- [3,4]; y <- [5,6]; [x*y] }
15:47:43 <lambdabot>   [15,18,20,24]
15:47:58 <johnsonw> ciaranm: perhaps i'll just try doing it and if i find a problem i'll come back
15:48:42 <FreeFull_> This feels a lot like a list comprehension
15:48:57 <ciaranm> comprehensions are overrated
15:49:03 <tac-tics> ^ agreed
15:49:08 <copumpkin> comonad incomprehensions?
15:49:21 <tac-tics> copumpkin: maybe... it might also be
15:49:26 <tac-tics> comonad mprehensions
15:49:31 <FreeFull_> ciaranm: Can't say I've ever used them
15:49:34 <tac-tics> (the co- moves to the other side)
15:49:50 <FreeFull_> I wonder if do notation is cleaner than applicative in certain cases
15:50:00 <monochrom> comonad apprehension. (whatever it means :) )
15:50:00 <FreeFull_> Of course not all applicatives are monads
15:50:16 * monochrom invents: complicatives
15:50:36 <monochrom> A complicative is like... well, it's complicated!
15:50:37 <ciaranm> a complicative is a non-associative functor
15:50:43 <copumpkin> just take the free monad of the applicative and you're good!
15:50:52 <ciaranm> because non-associative is always complicated!
15:51:02 * tac-tics still doesn't know what applicatives are useful for >__>
15:51:10 <ciaranm> tac-tics: parsing
15:51:11 <FreeFull_> instance Complicative Hask where complicate x = complicate (x x)
15:51:45 <monochrom> applicatives are useful for golfing some monadic code
15:51:57 <ciaranm> <* and *> are pretty handy
15:52:19 <monochrom> but yes, there are parsers which are applicatives and not monads
15:53:01 <monochrom> I like <* and *>, but I always mix them up
15:53:06 <FreeFull_> *> looks a lot like >>
15:53:09 <ciaranm> look at which way they're pointing
15:53:15 <ciaranm> <* takes the thing <----- on that side
15:54:15 <tac-tics> I'm also uncomfortable with the way the applicative laws look in Haskell
15:54:16 <monochrom> my mix up is due to mixing up: does < indicate "execution order"? or does it indicate which thing to take?
15:54:30 <FreeFull_> ciaranm: Are *> and <* handy when whatever you are operating on is a monad anyway?
15:54:39 <monochrom> afterall, "x << y" indicates "execution order"
15:54:42 <ciaranm> FreeFull_: yes
15:54:51 <FreeFull_> ciaranm: Example?
15:54:55 <ciaranm> FreeFull_: parsec
15:55:09 <FreeFull_> Simpler example?
15:55:09 <monochrom> many digit <* eof
15:55:37 <cmccann> :t (<<)
15:55:38 <lambdabot>     Not in scope: `<<'
15:55:38 <lambdabot>     Perhaps you meant one of these:
15:55:38 <lambdabot>       `=<<' (imported from Control.Monad.Writer),
15:55:42 <monochrom> many digit <* eof is a replacement for do {x <- many digit; eof; return x}
15:55:59 <FreeFull_> Where would the behaviour of [(<<,<*),(>>,*>)] diverge for monads?
15:56:05 <monochrom> and I hope I have used <* right
15:56:05 <cmccann> anyway, the Applicative operators all have the same sequencing order for "effects"
15:56:37 <cmccann> which order that is depends on the instance (but should be left->right in any cases where you'd be surprised if it wasn't)
15:56:45 <monochrom> ah, "effect order" is a better word than "execution order"
15:56:57 <FreeFull_> Ah, many is only for applicatives
15:57:03 <glguy> FreeFull_: An exception applicative instance could continue executing through (*>) while it could not for (>>)
15:57:05 <FreeFull_> I guess if you're using applicative functions, yeah
15:57:23 <monochrom> FreeFull_, you are not seeing the point of my example
15:57:58 <FreeFull_> Seems << isn't defined by default
15:58:11 <ciaranm> FreeFull_: do { x <- blah ; foo ; return x } is quite common
15:58:14 <monochrom> getLine <* putStrLn "thank you" is a replacement for do {x<-getLine; putStrLn "thank you"; return x}
15:58:51 <monochrom> I started with "many digit <* eof" because it is common when using parsec
15:59:12 <monochrom> also, parsec is not "not simple"
16:00:14 <dolio> Parsec predates applicatives.
16:00:21 <cmccann> monochrom: anyway, varying effect order would be far more confusing than helpful with Applicative, since all the "effects" happen every time anyhow
16:00:22 <FreeFull_> monochrom: Your getline example works fine with << though
16:00:44 <dolio> And thus so does many.
16:00:47 <FreeFull_> Wait, no
16:00:57 <monochrom> not fine if you want the whole thing to return the string rather than ()
16:01:00 <FreeFull_> The order gets reversed
16:01:04 <monochrom> that too
16:01:05 <FreeFull_> With <<, the thank you gets printed first
16:01:23 <cmccann> does (<<) actually exist?
16:01:34 <FreeFull_> monochrom: Well, with << you do get the string
16:01:39 <monochrom> I don't know, but =<< exists
16:01:48 <FreeFull_> cmccann: you have to define it
16:01:55 <FreeFull_> It's just flip (>>)  though
16:02:27 <rhoark> lambdabot gave me a pl result that included if' - what is that?  Hoogle doesn't seem to know about it
16:02:40 <shachaf> rhoark: It doesn't exist. Just a function lambdabot uses.
16:02:41 <shachaf> @src if'
16:02:41 <lambdabot> Source not found. It can only be attributed to human error.
16:02:43 <cmccann> monochrom: well, (=<<) and (>>=) have an intrinsic order of effects
16:02:46 <monochrom> if' b x y = if b then x else y
16:02:47 <shachaf> if' b x y = if b then x else y
16:02:54 <elliott> if' b x y = if b then x else y
16:03:01 <rhoark> thanks
16:03:05 <monochrom> haha
16:03:06 <cmccann> if' b x y = if b then y else x
16:03:14 * cmccann helps
16:03:32 <monochrom> I love haskell
16:03:35 <monochrom> it is so lazy
16:04:23 <merlin_> I am interfacing C library and I am getting frustrated that I have to declare every function and struct I want to use. If I was to write a higher level C wrapper functions what should I use to have it compiled automatically with haskell source codes? I am using make at the moment but that feels odd
16:05:59 <cmccann> monochrom: anyway, my point was just that nothing forces a particular order of effects for Applicative and changing the order doesn't change anything else, so all you need to remember is the heuristic that everything happens in the same direction because it would be stupid otherwise :P
16:07:17 <ace_> hi there
16:09:45 <lispy> merlin_: cabal?
16:09:46 <c_wraith> merlin_: maybe look at bindings-DSL? It is a set of macros for hsc that automate a lot of that sort of thing.
16:09:54 * lispy isn't really sure what's going on
16:10:15 <c_wraith> err, hsc2hs, I suppose, is the name of the program.
16:12:09 <geekosaur> hsc2hs is fairly low level.  you might look at c2hs for higher level
16:12:54 <AtomicStryker> monochrom: if you could take a look http://hpaste.org/80956
16:13:40 <AtomicStryker> its exploding in line 30, 31, where it determines "game.." belong to the line above it
16:13:40 <S11001001> is there a Dual :: (* -> *) -> * -> * around somewhere?
16:13:47 <AtomicStryker> why? o_o
16:20:49 <c_wraith> AtomicStryker: do blocks do not continue inside of if/then/else
16:21:14 <AtomicStryker> ok, that would be a reason
16:21:23 <fmap> elliott: this ReaderWriter monad definition violates `m >>= return = m', doesn't it?
16:21:54 <fmap> @let returnRW a = const (a, mempty);
16:21:55 <lambdabot>  <local>:6:1:
16:21:55 <lambdabot>      Multiple declarations of `returnRW'
16:21:55 <lambdabot>      Declared at: <loc...
16:22:07 <elliott> fmap: I don't think so
16:22:10 <fmap> @let returnRW' a = const (a, mempty);
16:22:12 <lambdabot>  Defined.
16:22:58 <Michael_> Why do I get an error when trying to import a module inside of another module? Where one module is https://gist.github.com/4569818, and when I say import Agent in the second file, after the module definition, ghc still says Agent is not in scope?
16:23:09 <fmap> @let bindRW' f k = \w -> let (a,w') = f w; (b,w'') = k a (w <> w') in (b, w <> w' <> w'')
16:23:11 <lambdabot>  Defined.
16:24:19 <fmap> > let m = (\w -> ((), w <> w)) in (m "hello", bindRW' m returnRW' "hello")
16:24:21 <lambdabot>   (((),"hellohello"),((),"hellohellohello"))
16:37:29 <parcs> c2hs is not much higher level than hsc2hs
16:38:46 <lispy> geekosaur: I prefer hsc2hs because it seems to work in more scenarios. c2hs tries to parse the c and be a little too magical (and ends up brittle)
16:43:41 <S11001001> > Data.Map.fromList [(1, 2), (3, 4)]
16:43:42 <lambdabot>   Not in scope: `Data.Map.fromList'
16:46:09 <geekosaur> > M.fromList [(1,2),(3,4)]
16:46:10 <lambdabot>   fromList [(1,2),(3,4)]
16:46:31 <geekosaur> ...because Map doesn't export other constructors so it uses fromList in its show instance
16:52:37 <S11001001> merci geekosaur
17:08:29 * hackagebot handa-gdata 0.4.1 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.4.1 (BrianBush)
17:08:56 <sw2wolf> :t listToMaybe
17:08:57 <lambdabot> [a] -> Maybe a
17:10:32 <pyry`> johnw: are you around? i have a yaml data structure i'm unsure how to parse, after learning more of how to do it. i can paste question specifics
17:10:50 <johnw> hi
17:10:56 <johnw> paste away
17:10:57 <hpaste> “pyry` ” pasted “yaml parsing quandry” at http://hpaste.org/80958
17:11:07 <pyry`> johnw: there you are
17:11:21 <johnw> I don't know what that "value: " part means
17:11:38 <johnw> ordinarily a Maybe Text would be either "null" or the value
17:12:02 <pyry`> oh, just some miscellaneous key. i suppose i should be clear , it's the keys in theRecordSet, item1, item2, that i expect not to know
17:12:09 <johnw> oh, you just need two FromJSON instances
17:12:13 <johnw> one for RecordSet, and one for Rec
17:12:14 <pyry`> the key named "value" i will always know
17:12:21 <johnw> the recursion will happen automatiaclly
17:12:59 <pyry`> huh, even with keys that could be anything?
17:13:07 <johnw> make them be of type Value
17:13:19 <johnw> not Text
17:13:22 <pyry`> mm
17:13:26 <johnw> a Value matches anything at all
17:13:29 <pyry`> ahhh
17:13:31 <johnw> even substructures
17:13:47 <johnw> you can use aeson-lens to conveniently peer into Value structures
17:14:15 <edwardk> i really need to write a proper version of aeson-lens. maybe after 3.8
17:14:16 <johnw> or, you use FromJSON to marshal Value's into Haskell types
17:14:40 <pyry`> i think i'll try to stick to FromJSON instances just 'cause i understand them a bit more
17:14:43 <pyry`> for now
17:14:44 <johnw> in fact, decode :: Maybe Value is all you actually *need*
17:14:57 <johnw> the rest is interpretaiton
17:14:57 <pyry`> mm
17:17:23 <pyry`> johnw:hah, that really helped
17:17:29 <pyry`> now i can figure the rest out, i think
17:17:52 <pyry`> somehow i thought i absolutely had to be more specific to get anything useful out of decode
17:18:42 <johnw> oh, and there is one reason not to use deriveJson
17:18:50 <pyry`> ah?
17:18:51 <johnw> it doesn't allow for missing fields, either going or coming
17:18:56 <johnw> a missing field is an error
17:19:10 <johnw> with ToJSON/FromJSON, the meaning of missing fields is up to you
17:19:23 <johnw> for example, you can make a Default instance for your type
17:19:33 <johnw> and then use it to supply sensible defaults for missing fields
17:19:57 <johnw> this makes it easier to have one type that represents both directions
17:21:06 <pyry`> ahh
17:21:10 <pyry`> this helps muchly
17:21:10 <pyry`> :)
17:21:16 <pyry`> thanks!
17:21:28 <johnsonw> I'm binding to a variable in a do expression. How can I specify the type of that variable. In a let or where I'd put it on the preceeding line. That doesn't seem to work in do.
17:22:05 <johnsonw> And i can't put it on the RHS because that's the action, not the returned value.
17:32:38 <fmap> johnsonw: either `do x <- ... :: YourMonad VariableType; ...' or `do (x :: VariableType) <- ...; ...' with -XScopedTypeVariables enabled
17:33:31 <fmap> parentheses aren't necessary
17:42:22 <k00mi> i need to traverse through some kind of 2-dimensional array and modify surrounding elements, how would i best go about this?
17:44:31 <k00mi> i really can't find a way other than modifying the array in IO/ST
17:44:36 <c_wraith> k00mi: can you make your operation a stencil convolution?
17:45:08 <c_wraith> k00mi: if so, repa can expose a simple interface for doing that (that even will run in parallel more or less for free)
17:46:05 <k00mi> c_wraith: no, i need to modify the elements surrounding the current one, stencils can only modify the current element depending on the surrounding ones
17:46:16 <c_wraith> are you sure those aren't the same thing?
17:46:45 <c_wraith> (sometimes they are, sometimes they aren't)
17:46:54 <k00mi> pretty sure, yes
17:47:03 <k00mi> yes
17:47:49 <k00mi> this is what i'm trying to do: http://en.wikipedia.org/wiki/Floyd%E2%80%93Steinberg_dithering
17:47:53 <MaybeCallMe> I loaded into ghci my Tester.Main which imported MainTest which imported Main. Both Tester.Main and Main contains main method. When I however called main from ghci, the main from Tester.Main ran. So haskell runs the main in the current module?
17:48:26 <c_wraith> Heh.  Funny how that was my first guess at what you might be doing.
17:48:41 <luite> mine too :)
17:49:38 <k00mi> :)
17:50:54 <c_wraith> Well, for something like that, using an unboxed array (or vector) is probably as good as it gets.
17:59:33 <test__> @pf head xs == last xs && (x $ init $ tail xs)
17:59:33 <lambdabot> Maybe you meant: bf pl
18:00:27 <test__> @pl head xs == last xs && (x $ init $ tail xs)
18:00:27 <lambdabot> head xs == last xs && x (init (tail xs))
18:01:21 <geekosaur> test__: you haven't given it any points to be removed...
18:03:52 <jmcarthur> @pl \xs -> head xs == last xs && (x $ init $ tail xs)
18:03:52 <lambdabot> ap ((&&) . liftM2 (==) head last) (x . init . tail)
18:04:50 <jmcarthur> @pl \x xs -> head xs == last xs && (x $ init $ tail xs)
18:04:50 <lambdabot> ap ((&&) . liftM2 (==) head last) . (. (init . tail))
18:36:36 <thetallguy> I was just reading a set of slides about GADTs and reflection.  closed the browser, went home, can't find it again.
18:37:08 <thetallguy> I pulled it from some feed, twitter, g+, I don't remember.  Seemed very recent.
18:37:51 <thetallguy> Does that pattern match with anyone?  Google keeps giving me articles about muslims reflecting on something at the washington post.
18:42:19 <parcs> have you checked your browser's history
18:45:12 <thetallguy> different browser
18:50:48 <johnw> thetallguy: was it a PDF?
18:51:04 <johnw> and was it a personal blog, or like a wiki or something?
18:51:42 <thetallguy> johnw: I believe so.  It appeared like a PDF in my browser, slides, as if from a recent talk at a research department
18:52:45 <thetallguy> johnw: it was just the kind of thing one would find in twitter, Hey, my recent talk on GADT reflection, compressed link.
18:53:03 <johnw> http://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=2&cad=rja&ved=0CDcQFjAB&url=http%3A%2F%2Fresearch.microsoft.com%2Fpubs%2F64040%2Fgadtoop.pdf&ei=PQr6UPOqLtP82gW2woGIDw&usg=AFQjCNFH96DFYkwKQk_kMPrjUl_tG_Am4w?
18:53:18 <johnw> oh, not slides
18:53:24 <thetallguy> and ages old
18:53:30 <johnw> oh, it's new?
18:54:04 <thetallguy> this was a recent thing, where someone was observing that GADT's could be used to get around the separation of constructors and functions
18:54:17 <johnw> http://sneezy.cs.nott.ac.uk/fun/feb-08/bruno-slides.pdf?
18:54:55 <thetallguy> nope, but closer.  Much less polished set of slides.
18:55:03 <thetallguy> grrr.
18:55:28 <thetallguy> I guess I'll just have someone start up my browser at work
18:56:21 <johnw> when you find it, please let me know
18:57:36 * M30W was just talking to a friend and instead of either something or something else. I wrote something `either` something else.
18:57:39 <M30W> O.o
18:57:48 <johnw> haha
18:58:19 <M30W> Didn't think about the either til after so they wondered why I wrote it like that. :P
18:59:30 <thetallguy> Ahhhh
18:59:39 <thetallguy> not reflection, meta-programming.
18:59:41 <thetallguy> http://michaeldadams.org/talks/mhaskell/mHaskell.pdf
18:59:55 <johnw> nice, thank you
19:00:05 <deus_rex> I had found that! :)
19:00:13 <deus_rex> but didn't see anything about reflection
19:00:26 <johnw> i wonder if Google wonders why they were suddenly hammered by queries about GADT and reflection
19:00:29 <deus_rex> that'll learn me to keep my yap shut
19:00:56 <johnw> yeah, i had come across that presentation yet
19:01:12 <johnw> so adding it to the reading list...
19:01:22 <thetallguy> yeah, sorry, asking people to find something that I could barely remember any details of is kind of cruel
19:01:43 <johnw> it's like a dream where you just can't quite find it, but it's so tantalizingly close
19:02:01 <thetallguy> http://www.washingtonpost.com/blogs/under-god/post/hajj-time-for-muslim-reflection/2012/10/23/1a52c17e-1d70-11e2-9cd5-b55c38388962_blog.html
19:02:19 <thetallguy> They should be wondering why that's the top link in return to a search for 'gadt reflection'
19:02:48 <thetallguy> nothing pisses me off more than google dropping the first search term
19:02:56 <deus_rex> if you put "gadt" in quotes, it won't try to "fix" it
19:03:44 <thetallguy> deus_rex: that pisses me off even more
19:03:57 <thetallguy> I don't mind if they prompt for alternatives
19:04:14 <c_wraith> > fix gadt
19:04:16 <lambdabot>   They're not broken!
19:04:30 <thetallguy> but when I get it right and they go ahead and give me the wrong answers, that's when I go for my rocket launcher
19:04:59 <thetallguy> Hmm...  I wonder if we can write some lenses for google employees
19:05:48 <thetallguy> over mapped . google . search . coders . language =~ "Haskell"
19:06:00 <thetallguy> go,go lambda bot
19:07:46 <startling> c_wraith: haha
19:45:37 <tac-tics> @type replicateM
19:45:38 <lambdabot> Monad m => Int -> m a -> m [a]
19:45:46 <tac-tics> @src replicateM
19:45:46 <lambdabot> replicateM n x = sequence (replicate n x)
19:46:37 <tac-tics> @src sequence
19:46:37 <lambdabot> sequence []     = return []
19:46:37 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:46:37 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
19:47:42 <tac-tics> @src forM
19:47:42 <lambdabot> forM = flip mapM
19:47:51 <tac-tics> @src mapM
19:47:51 <lambdabot> mapM f as = sequence (map f as)
19:48:43 <Hermit> tac-tics: you can interact with lambdabot privately too
19:48:53 <tac-tics> Hermit: no one else is chatting.
19:48:59 <tac-tics> why not talk here :)
19:49:51 <Hermit> well, it dosen't hurt, but still, I'd only use lambdabot in the channel to show a point
19:50:10 <Hermit> for any other use, through PM
19:50:54 <Hermit> and... many folks aren't aware they could use lambdabot in PM, and they spam a lot
19:51:06 <Hermit> so I was saying... just in case
19:52:10 <tac-tics> ah no. I am quite good friends with lambdabot
19:52:14 <tac-tics> @quote
19:52:14 <lambdabot> Bishoy says: hey there i'm new to haskell, but can anybody tell me well haskell make me able to develop a chatterbot... or even a complete virtual world?
19:52:24 <tac-tics> @quote
19:52:24 <lambdabot> #perl says: <tech> who needs saneness
19:52:32 <tac-tics> @quote Hermit
19:52:33 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
19:52:35 <tac-tics> :(
19:52:38 <Hermit> hehe
19:59:01 <shachaf> tac-tics: Hermit's point seems reasonable to me.
19:59:23 <tac-tics> @quote shachaf
19:59:23 <lambdabot> shachaf says: <djahandarie> Group projects are stupid <shachaf> Try a semigroup project sometime. You need to lose your identity.
19:59:35 <tac-tics> heh
20:01:19 <monochrom> haha
20:02:09 <lispy> @quote monochrom
20:02:09 <lambdabot> monochrom says: If you read a haskell book or an FP book, by chapter 5 it's already doing data structures. It's chapter 10 in imperative books.
20:02:31 <tac-tics> @quote tac
20:02:31 <lambdabot> tac says: I guess I'm just living in a fantasy world where the docs tell you how to use such a basic API :P
20:02:42 <lispy> @quote lambdabot
20:02:42 <lambdabot> lambdabot says: Of course i'm female
20:02:51 <lispy> @quote lambdabot
20:02:51 <lambdabot> lambdabot says: mUEv4L-CORE: Tim3 li/\/\IT 3xcE3dEd
20:03:02 <monochrom> I write docs that tell you how to use my API, basic or not
20:03:23 <monochrom> of course, I am brief on the basic ones
20:03:38 <tac-tics> @quote tac-tics
20:03:38 <lambdabot> tac-tics says: CT is a boreofunctor in the category of snoozemorphisms
20:03:52 <lispy> @quote elitism
20:03:52 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
20:04:17 <shachaf> monochrom: i love docs
20:04:27 <monochrom> they're so lazy
20:04:41 <lispy> This is the quote I was looking for: Smugness is just self-righteousness in the category of endoelitism.
20:04:56 <tac-tics> @quote category
20:04:56 <lambdabot> shapr says: hylo! That's the category theorist greeting.
20:06:32 <shachaf> endo-righteousness
20:07:38 <tac-tics> Your functors are full of themselves (and faithful, too).
20:14:01 <hr_> @pl inOrder = foldl (==) True . (\xs -> zipWith (<=) xs $ drop 1 xs)
20:14:01 <lambdabot> inOrder = foldl (==) True . ap (zipWith (<=)) (drop 1)
20:16:38 <hr_> eh? What's that "ap" function?
20:17:10 <johnw> or just isSortedBy (<=), from data-ordlist
20:18:00 <geekosaur> :t ap
20:18:02 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:18:33 * hackagebot hit 0.4.3 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.4.3 (VincentHanquez)
20:18:38 <tac-tics> ap is the big reason why monads are also applicative functors
20:18:44 <tac-tics> @type <$>
20:18:45 <lambdabot> parse error on input `<$>'
20:18:50 <geekosaur> (clear as mud)
20:18:51 <tac-tics> @type (<$>)
20:18:52 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:18:56 <tac-tics> @type ap
20:18:57 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:19:17 <hr_> right, I think I almost understand
20:19:21 <johnw> ap is to Monoid as <*> is to Applicative
20:19:28 <shachaf> What?
20:19:33 <johnw> um, Monad
20:19:33 <geekosaur> Monad, nor Monoid
20:19:44 <shachaf> FSVO "to"
20:19:46 <geekosaur> but even then not quite
20:19:57 <tac-tics> <*> = fmap
20:20:03 <johnw> <*> != fmap
20:20:04 <tac-tics> @src (<*>)
20:20:04 <lambdabot> Source not found. Where did you learn to type?
20:20:08 <tac-tics> isn't it?
20:20:09 <johnw> @t (<*>)
20:20:09 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:20:14 <johnw> :t (<*>)
20:20:15 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:20:16 <johnw> :t (ap)
20:20:19 <lambdabot> Monad m => m (a -> b) -> m a -> m b
20:20:26 <johnw> <$> = fmap
20:20:28 <tac-tics> oh, so it is
20:20:43 <geekosaur> anyway the trick being used here is the primitive reader monad aka ((->) e), which in this case lets us distribute a parameter over multiple functions
20:20:59 <shachaf> All you really need to know is ap x y z = x z (y z)
20:21:09 <hr_> Okay, thanks
20:25:33 <parcs> what happens if an exception is raised in the first computation in 'Control.Exception.bracket' ?
20:26:17 <parcs> wait, never mind. i got it
20:27:49 <kyle__> divisors y = [x|x<-[1..(floor (y/2))],(mod y x)==0]
20:28:02 <kyle__> Damnit, meant to preface that with, "Another stupid newbie question"
20:28:23 <kyle__> What sort of function declaration do I need to make that work?
20:30:12 <johnw> > let y = 24 in [x|x<-[1..(floor (y/2))],(mod y x)==0]
20:30:14 <lambdabot>   [1,2,3,4,6,8,12]
20:30:37 <johnw> > let y = 37 in [x|x<-[1..(floor (y/2))],(mod y x)==0]
20:30:39 <lambdabot>   [1]
20:30:46 <johnw> what's the problem?
20:31:31 <hr_> he called what he was having trouble with "a function declaration" so maybe he meant type?
20:31:45 <noah_> you might want "div" rather then "/"
20:31:56 <noah_> so you don't need floor
20:32:08 <kyle__> johnw: When I compile it it gives me an error about not being able to deduce
20:32:21 <kyle__> Holdon, lemmi give the right error
20:32:28 <johnw> ah, try: y `div` 2
20:32:33 <hr_> it compiles fine with div, yea
20:32:34 <johnw> and you don't need parens around (mod x y)
20:33:09 <noah_> you are using y as a Fractional and a Integral
20:33:17 <kyle__> Ok, I'll try div.  But just since it's bugging the crap out of me :) what would you do to keep that from giving an Ambiguous type variable in constraint error?
20:33:30 <hr_> noah explained ^
20:34:05 <noah_> you can always give the type explicitly to get rid of the error
20:34:41 <kyle__> noah_: I tried to, sorry, using the wrong terminology.  I thought calling it a prototype was too C-ish.
20:34:56 <hr_> type declaration
20:35:09 <johnw> we call it a type annotation, or a type declaration, depending on if it applies to an expression, or in front of a definition
20:35:11 <hr_> divisors :: Integral t => t -> [t]
20:35:46 <hr_> basically just saying that you want it to take something that's an integral
20:36:33 <johnw> otherwise it tries it figure out the type of 'y' from usage, but you're using it in ways that allow for two separate possibilities, and it doesn't know which you meant
20:37:26 <kyle__> johnw: I figured that's what was happening, just was having trouble coming upw ith the right type declaration to make it happy.  `div` is definately the nicer solution, but after long enough fighting with it, I want to see how to make my first hodge-podge work anyway.
20:38:18 <hr_> I suggest writing out the type declaration for anything that's giving you trouble
20:39:57 <noah_> you can also write "divisors y = [x | x <- [0.. floor (fromIntegral y / 2"), y `mod` x == 0]"
20:40:17 <noah_> so its closer to your original
20:41:39 <noah_> well, i meant "[1.." not "[0.." but thats the idea
20:41:47 <kyle__> OK.  Neat, thank you.  I got that part yeah :)
20:41:56 <kyle__> it would give a div by zero error otherwise.
20:42:27 <RichyB> x <- takeWhile ((y*y >) . (\z -> z*z)), might be quicker.
20:43:03 <RichyB> Oh no, that's only applicable if you produce both factors when a division yields zero.
20:45:26 <kyle__> RichyB: There's lots to this that is non-optimal, my number theory is weak.
20:45:33 <hr_> @pl f xs ys = sum $ zipWith (*) xs ys
20:45:33 <lambdabot> f = (sum .) . zipWith (*)
20:45:45 <hr_> thanks, lambdabot
20:45:47 <RichyB> I fouled that expression up six ways to sunday anyway.
20:47:22 <M30W> @pl main = (listenOn . PortNumber $ fromInteger port) >>= runConn
20:47:22 <lambdabot> main = runConn =<< listenOn (PortNumber (fromInteger port))
20:47:27 <M30W> Ah
20:47:54 <shachaf> i love @pl
20:47:56 <shachaf> it is so easy
20:48:00 <M30W> Same :D
20:48:01 <shachaf> (Oops! Sorry!)
20:48:11 <M30W> ?
20:48:17 <shachaf> M30W: You know your expression had no points, right?
20:48:35 <M30W> shachaf: Yea. But I know it can clean things up :P
20:49:04 <M30W> I.e I completly forgot about =<<
20:49:05 <shachaf> (Also that you can /msg lambdabot. But anyway.)
20:49:10 <M30W> Noted
20:50:25 <M30W> Heh.
20:50:27 <M30W> flip flip flip O.o
20:50:29 <M30W> @pl forkIO . handle (eL h) $ randomRIO (lower, upper) >>= \n -> parseIn h n lower upper 0
20:50:29 <lambdabot> forkIO (handle (eL h) (flip (flip (flip (parseIn h) lower) upper) 0 =<< randomRIO (lower, upper)))
20:52:11 <RichyB> @pl \y -> takeWhile ((y>=).(^2)) [0..]
20:52:11 <lambdabot> flip takeWhile [0..] . (. (^ 2)) . (>=)
20:52:39 <RichyB> I can't remember the last time I put something into @pl and it came out more readable rather than less.
20:52:53 <M30W> RichyB: Hehe
20:53:25 <startling> RichyB, you just have to be able to read a certain way
20:54:14 <hr_> riiiiight
20:54:26 <hr_> @pl shuffle (x:xs) (y:ys) = x:y:shuffle xs ys
20:54:27 <lambdabot> shuffle = fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip ((.) . (.) . (.) . (:)) . (flip ((.) . (:)) .))
20:54:30 <hr_> waaaay more readable
20:54:44 <M30W> ...... Totally.
20:54:44 <RichyB> Understanding an expression like ((f .) . g) takes me minutes to puzzle through.
20:54:55 <RichyB> And that's just the simple case!
20:56:09 <startling> RichyB, oh, (f .) . g is just ((.) . (.)) f g
20:56:22 <startling> ((.).(.) is also known as .:)
20:56:51 <startling> it's for composing two-argument functions with one-argument functions
20:57:59 <RichyB> Yes. I might like @pl better if it knew about some of the common combinators like (.:) - and is that in Data.Function yet? :)
20:58:16 <shachaf> No, and I don't think it should be.
20:58:55 <startling> hr_: anyway, that's a good example
20:58:58 <RichyB> Where else should it go?
20:59:03 <startling> it's totally more readable for certain kinds of people.
20:59:05 <startling> like shachaf
20:59:08 <startling> and lambdabot
20:59:22 <Eduard_Munteanu> (.) (.) (.) is definitely kinkier, and what we should use.
21:01:05 <shachaf> @pl shuffle xs ys = concatMap (toListOf both) (zip xs ys)
21:01:05 <lambdabot> shuffle = ((toListOf both =<<) .) . zip
21:01:46 <startling> :t toListOf
21:01:47 <lambdabot> Getting (Endo [a]) s t a b -> s -> [a]
21:02:01 <startling> toListOf _1 (1, 2)
21:02:08 <startling> > toListOf _1 (1, 2)
21:02:10 <lambdabot>   [1]
21:02:22 <startling> is that like firstOf/headOf?
21:02:28 <M30W> Is there a way to pass multiple lines to lambdabot ?
21:02:35 <M30W> I.e tell him to queue
21:02:54 <shachaf> No.
21:02:57 <M30W> :(
21:03:08 <M30W> Exploitable for ram if he did so fair enough. :)
21:03:16 <M30W> it ***
21:03:16 <startling> *she
21:03:23 <M30W> Heh
21:03:28 <shachaf> You have ghci.
21:03:34 * hackagebot pandoc-types 1.10 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.10 (JohnMacFarlane)
21:03:34 <shachaf> lambdabot is an IRC bot, not an IDE.
21:03:47 <M30W> Yea, but I was thinking multiline @pl :)
21:03:56 <Philippa_> shachaf: some of us don't have ghci [on our current machines]!
21:03:57 <Eduard_Munteanu> You can use stuff like @let and normal let expressions to input complex stuff.
21:04:12 <Philippa_> 254 chars max, though
21:04:15 <shachaf> M30W: Get your own @pl without lambdabot.
21:04:22 <Philippa_> well, fewer
21:04:26 <Philippa_> PRIVMSG #haskell ...
21:04:30 <hr_> cabal install pointfree
21:05:13 <startling> ghc-pkg unregister lambdas
21:06:10 * Eduard_Munteanu uses stuff like "stuff" too much
21:06:39 <M30W> shachaf: Where is the pl ?
21:06:51 <kyle__> Philippa_: android tablet?
21:07:05 <Philippa_> ARM-based chromebook running Ubuntu Precise
21:07:29 <Philippa_> I hear the debian/armhf folks have it working, so maybe in the next LTS release
21:07:37 <kyle__> Philippa_: Didn't realize chromebooks ram ARM.  But I'm fairly sure ghci is in ubuntu's apt repository.
21:07:50 <M30W> ah
21:07:53 <kyle__> s/ram/ran/
21:08:09 <M30W> Thanks hr_ didn't see that.
21:08:09 <startling> chrambooks ram arm
21:08:11 <Eduard_Munteanu> kyle__: not necessarily for non-x86 arches
21:08:17 <M30W> Ah compile :|
21:08:32 <Philippa_> kyle__: it's not available for ARM in Precise. And it's at least not entirely trivial to build 7.6 for yourself, either
21:08:34 * kyle__ should boot up his r-pi to see what's in that one.
21:08:40 <kyle__> rasbian that is.
21:10:16 <M30W> pointfree needs a re-write/update. :(
21:11:38 <shachaf> True.
21:12:49 <shachaf> Oh, the version in git works fine.
21:12:55 <shachaf> Just not uploaded to Hackage.
21:12:58 <shachaf> benmachine!!!
21:14:54 <shachaf> Hmm, all of @pl is ~1000 lines.
21:25:41 <johnw> is it less if you @pl it?
21:28:39 <startling> heh
21:30:51 <AfC> Is there a Map implementation floating around that supports duplicate keys [or do I have to do a List of tuples]?
21:31:12 <elliott> Map k (Set a)?
21:32:09 <hr_> ah nuuuu haskell tricked me into staying up late
21:32:27 <Eduard_Munteanu> Me too. :(
21:33:43 <M30W> Whoo this is interesting. :D forkIO main and now I have an interactive way to redefine functions live within my daemon. :D
21:34:18 <M30W> Well kinda.. :(
21:34:48 <M30W> Is there a way to update the functions to new functions ?
21:36:53 <Axman6> not really, that would mean that functions were mutable, and that's not very referentially transparent
21:37:42 <startling> M30W, keep a Map of functions and update that instead?
21:37:47 <M30W> Yea didn't think so. :(
21:37:51 <M30W> O.o
21:38:42 <M30W> Is there a way to kill threads ?
21:39:06 <Axman6> yes...
21:39:12 <Axman6> @hoogle killThread
21:39:12 <lambdabot> Control.Concurrent killThread :: ThreadId -> IO ()
21:39:12 <lambdabot> GHC.Conc.Sync killThread :: ThreadId -> IO ()
21:39:12 <lambdabot> GHC.Conc killThread :: ThreadId -> IO ()
21:39:18 <hpaste> lispy pasted “mtl-2.1 bug, can you spot it?” at http://hpaste.org/80961
21:39:19 <Nisstyre-laptop> Is this a correct definition of the surreal numbers? (I just started reading Surreal Numbers by Knuth): data Surreal = XL (Surreal, ()) | XR ((), Surreal) | Zero
21:39:26 <M30W> :)
21:39:35 <lispy> Took me a minute to figure out the bug with that paste.
21:39:43 * lispy wonders if other people will spot it too
21:39:52 <AfC> elliott: oh. Duh. Any reason not to use Map k [a]?
21:40:00 <elliott> depends if you want a set or a list :P
21:40:02 <shachaf> Nisstyre-laptop: That looks suspicious.
21:40:08 <elliott> lists are ordered, sets might have better performance for some things
21:40:09 <shachaf> What's the point of the ()?
21:40:10 <startling> Nisstyre-laptop, what's the point of ((), ...)?
21:40:14 <Nisstyre-laptop> shachaf: well I didn't want to bring in sets
21:40:23 <Nisstyre-laptop> startling: represents the empty set :P
21:40:29 <shachaf> OK, but you gain nothing from the ()
21:40:40 <Nisstyre-laptop> shachaf: true I guess
21:40:49 <shachaf> I.e. your definition is equivalent (other than ⊥) to data S = XL S | XR S | Z
21:41:05 <Nisstyre-laptop> shachaf: yeah
21:41:06 <shachaf> Which is in turn equivalent to [Bool]
21:41:09 <AfC> elliott: not to mention dealing with ∅ better. Thanks.
21:41:38 <shachaf> Which is in turn equivalent to Nat. :-)
21:41:46 <shachaf> But that's a different sort of equivalent.
21:41:58 <Nisstyre-laptop> shachaf: I understand the surreals give you the reals though, and infinitesmals, right?
21:42:16 <cmccann> lispy: it keeps using that variable "s", I do not think it means what it thinks it means.
21:42:18 <Eduard_Munteanu> lispy: the shadowed 's'?
21:42:28 <shachaf> Anyway, I don't remember what surreal numbers are, but that doesn't look right.
21:42:34 <M30W> Is there a way to step inside of a fork (ghci)
21:42:38 <Nisstyre-laptop> shachaf: http://en.wikipedia.org/wiki/Surreal_number
21:43:34 <startling> shachaf, everything is equivalent to [Bool]
21:43:51 <shachaf> startling: Only computable things!
21:43:55 <otters> @pl \x -> (x + 1) * 2 - 1
21:43:55 <lambdabot> subtract 1 . (2 *) . (1 +)
21:44:01 <cmccann> shachaf: there are other kinds of things?
21:44:03 <startling> shachaf: heh, true
21:44:16 <shachaf> cmccann: Sure! Like dual-computable things.
21:44:41 <cmccann> oh, ok.
21:44:42 <Eduard_Munteanu> Actually I don't think that's the issue.
21:44:45 <cmccann> duality is good.
21:44:52 <oio> is there a way to conver a string of one character "a" to a char 'a' ?
21:45:06 <Eduard_Munteanu> It's probably not something straightforward, if it trips just some apps.
21:45:16 <shachaf> oio: Pattern match on it.
21:45:29 <shachaf> case foo of [x] -> ...; _ -> ...
21:45:58 <oio> mm another way ;D ?
21:46:06 <oio> i tried read
21:46:06 <cmccann> Eduard_Munteanu: which "s" is shadowing which other "s", and what are their respective scopes?
21:46:14 <shachaf> oio: First say what's wrong with this one.
21:46:27 <oio> lol nothing
21:46:49 <Nisstyre-laptop> shachaf: I think "data Surreal = S (Surreal, Surreal) | Z" is more along the lines of what it should be
21:46:58 <Eduard_Munteanu> cmccann: the one in ~(a, s) shadows the one in s <- get
21:47:01 * Nisstyre-laptop will read more though
21:47:19 <shachaf> Nisstyre-laptop: That doesn't look quite right either.
21:47:20 <cmccann> Eduard_Munteanu: right, so ignore the "s <- get" part
21:47:34 <Nisstyre-laptop> shachaf: yeah I know, it's missing the set notion
21:47:37 <cmccann> Eduard_Munteanu: what does "let ~(a, s) = f s" do in that case? :D
21:47:42 <shachaf> A surreal number is made up of two sets of surreal numbers.
21:48:02 <shachaf> Unfortunately sets are hard.
21:48:06 <Nisstyre-laptop> yeah :(
21:48:21 <Eduard_Munteanu> cmccann: grr, oh...
21:48:43 <startling> so data Surreal = Surreal (Surreal -> Bool) (Surreal -> Bool) ?
21:48:52 <oio> head "a"
21:49:00 <oio> let head "a"
21:49:29 <mm_freak> > head "a"
21:49:30 <oio> let "a" in head "a"
21:49:31 <lambdabot>   'a'
21:49:43 <Eduard_Munteanu> cmccann: (a, s) = snd (f s) = snd (f (snd ...)), no?
21:50:04 <Axman6> let "a" in ... makes no sense...
21:50:06 <shachaf> startling: That is unfortunately not of much use in Haskell.
21:50:08 <Nisstyre-laptop> shachaf: found this via google https://gist.github.com/2424975
21:50:20 <shachaf> oio: You shouldn't use head. You should pattern-match like I said.
21:50:25 <mm_freak> > let "a" = "a" in "a"
21:50:27 <lambdabot>   "a"
21:50:33 <startling> shachaf, are the surreal numbers useful in any language?
21:50:47 <cmccann> Eduard_Munteanu: pretty much.
21:50:48 <shachaf> Nisstyre-laptop: That works, but Set is pretty limited.
21:50:49 <cmccann> @src fix
21:50:50 <lambdabot> fix f = let x = f x in x
21:50:50 <oio> tell me what worng with head ?
21:50:53 <shachaf> It can't be infinite.
21:51:01 <mm_freak> haskell is a liar
21:51:06 <mm_freak> > let 3 = 4 in 3 == 4
21:51:07 <lambdabot>   False
21:51:12 <shachaf> oio: Come to think of it, I don't mind if you use head. Go ahead.
21:51:13 <Axman6> oio: you need to put > before any haskell commands
21:51:16 <Axman6> > 1 + 1
21:51:18 <lambdabot>   2
21:51:21 <Axman6> 1 + 1
21:51:25 <Axman6> doesn't work
21:51:27 <mm_freak> Axman6: @ for commands, > for expressions
21:51:41 <Nisstyre-laptop> shachaf: ah, yeah, that's a big problem
21:51:44 <cmccann> > let 1 + 1 = 3 in 1 + 1
21:51:45 <oio> > head "a"
21:51:46 <lambdabot>   3
21:51:46 <lambdabot>   can't find file: L.hs
21:51:57 <Ralith> shachaf: smooth
21:52:06 <Axman6> @undefine
21:52:07 <oio> wut?
21:52:11 <Axman6> try again
21:52:13 <Nisstyre-laptop> shachaf: ideally I'd want to be able to lazily compute numbers up to whatever amount I want
21:52:22 <Eduard_Munteanu> cmccann: I guess nobody uses 'state' that much? :)
21:52:39 <mm_freak> Eduard_Munteanu: 'state' from mtl?
21:52:45 <Eduard_Munteanu> Yeah.
21:52:46 <cmccann> Eduard_Munteanu: or they use it in ways that would happen not to trip over that
21:52:47 <Axman6> > head "a"
21:52:48 <lambdabot>   'a'
21:52:50 <mm_freak> Eduard_Munteanu: i use that one a lot
21:53:00 <cmccann> mm_freak: did you see lispy's hpaste above?
21:53:05 <mm_freak> :t state (randomR (3, 5))
21:53:06 <lambdabot> (Num a, MonadState s m, RandomGen s, Random a) => m a
21:53:16 <mm_freak> cmccann: nope
21:53:43 <cmccann> mm_freak: http://hpaste.org/80961
21:53:53 <shachaf> Nisstyre-laptop: I think you'll have to adapt the definition of surreal numbers to be more constructive.
21:53:57 <shachaf> Well, maybe not.
21:54:04 <shachaf> I guess this one is pretty constructive.
21:54:12 <shachaf> Nisstyre-laptop: I recommend not listening to anything I say.
21:54:12 <mm_freak> cmccann: weird…  it works for me
21:54:16 <mm_freak> cmccann: no <<loop>>
21:54:47 <mm_freak> also that's a very weird definition of 'state'
21:54:53 <cmccann> well, it's not like it wasn't fixed
21:54:58 <cmccann> fixed in the made not-broken sense
21:55:06 <cmccann> it was already "fix"ed in another sense :P
21:55:19 <mm_freak> state f = StateT (return . f)
21:55:48 <cmccann> mm_freak: that's the default definition in MonadState
21:56:00 <cmccann> this is in mtl, not transformers
21:56:14 <S11001001> edwardk: I'm looking at Lookup in keys, which is headed "Safe lookup" in haddock, but has instance Lookup ((->) a) where lookup i f = Just (f i).  I'm not sure that's in the spirit of "safe" lookup...
21:56:24 <mm_freak> cmccann: yes
21:56:34 <Axman6> lispy: spotted the error... interesting
21:56:47 <S11001001> edwardk: and given that wouldn't the relationship between Indexable and Lookup go the other way?
21:57:11 <shachaf> S11001001: Why is that not safe?
21:57:17 <mm_freak> cmccann: perhaps i missed mtl 2.1 on my system
21:57:21 <mm_freak> with mtl 2.1.2 it works
21:57:33 <edwardk> if i can 'definitely look something up' then i can 'possibly look it up'
21:57:34 <cmccann> mm_freak: can't very well use StateT in the default definition, and the actual instances for StateT stuff uses the obvious definitions
21:57:44 <mm_freak> in any case it's a very weird definition of 'state', should they really have implemented it that way
21:57:47 <cmccann> and yes, it was apparently fixed in 2.1.1 a couple weeks later
21:57:47 <shachaf> S11001001: I imagine that that Just (index ...) is a valid implementation for any Indexable.
21:58:02 <mm_freak> weeks!
21:58:05 <mm_freak> wow
21:58:08 <S11001001> hmm, ok
21:58:08 <edwardk> but regardless, keys is old and crufty and like many things subsumed by lens  ;)
21:58:12 <cmccann> mm_freak: how else would you implement it?
21:58:29 <mm_freak> cmccann: ah!  the default definition
21:58:38 <cmccann> ...that's what I said :P
21:58:41 <mm_freak> i've always used StateT anyway =)
21:59:27 <edwardk> mm_freak: is this my embarassing accidental release of a buggy default version of 'state' ?
21:59:33 <cmccann> edwardk: yes
21:59:36 <edwardk> ah
21:59:45 <edwardk> glad to see that folks are still talking about it ;)
21:59:52 <cmccann> edwardk: lispy pasted this: http://hpaste.org/80961
22:00:07 <Eduard_Munteanu> edwardk: does that 'state' ever work?
22:00:12 <cmccann> apparently you broke agda!
22:00:14 <edwardk> Eduard_Munteanu: no
22:00:19 <edwardk> it was a bug
22:00:21 <Nisstyre-laptop> shachaf: http://dl.acm.org/citation.cfm?id=2150520
22:00:43 <mm_freak> edwardk: this actually never happens to me…  if i know that a value is going to be "changed" in some sense, i suffix the original variable with an apostrophe
22:01:11 <mm_freak> state f = do s' <- get; let ~(x, s) = f s'; put s; return x
22:01:33 <edwardk> mm_freak: i was copying some code from transformers to make the default definition and just assumed i had it right and moved on
22:01:36 <cmccann> mm_freak: backwards from everyone else, eh?
22:01:47 <mm_freak> cmccann: yeah
22:01:59 <edwardk> the s'  first s second convention strikes me as strange and unnatural ;)
22:02:03 <mm_freak> cmccann: you'll find that style all over the source code of netwire =)
22:02:26 <shachaf> Nisstyre-laptop: Looks promising. Maybe take inspiration from that. :-)
22:03:00 <mm_freak> edwardk: dunno, got used to that…  you can see immediately which values will be changed
22:03:14 <mm_freak> f a b' c = …
22:03:31 * cmccann can see the appeal of mm_freak's style
22:03:31 <edwardk> anyways that incident is a large part of why i'm more testing-centric these days. not as testing-centric as S11001001, but i don't think anyone else is. ;)
22:04:05 <cmccann> personally I prefer to avoid naming intermediate values at all if I don't have anything more useful to call them
22:04:14 <S11001001> edwardk: was looking for particular typeclasses to illustrate a point I'm making to clojureland, but eh, first principles
22:04:18 <zachk> ed whats a good testing framework, or do you roll your own like everything else?
22:04:23 <mm_freak> cmccann: i use that style even if i never name the new value
22:04:23 <edwardk> mm_freak: note it wouldn't have helped here.
22:04:27 <zachk> ;-)
22:04:33 <edwardk> mm_freak: s' <- get   would still have typechecked
22:04:39 <edwardk> because the problem was shadowing
22:04:45 <mm_freak> zachk: for pure code i like smallcheck…  no idea for IO code
22:04:57 <edwardk> zachk: i use doctests and test-framework
22:05:05 <shachaf> -Wall would've helped. :-)
22:05:10 <mm_freak> edwardk: yes, but i'd never have written "let ~(x, s') = …"
22:05:21 <mm_freak> shachaf: huh?
22:05:26 <edwardk> yeah, -Wall should have been on there. i had expected it to be, hence why i was surprised 2 weeks later by the error
22:05:29 <mm_freak> ah yeah
22:05:37 <mm_freak> unused variable =)
22:05:40 <cmccann> mm_freak: so you'd name something x' even if you never have something else named just x? that seems weird.
22:05:42 <shachaf> No, shadowed.
22:05:50 <mm_freak> cmccann: it's useful
22:05:56 <shachaf> cmccann: I prefer to name it x''''' just in case.
22:06:03 <mm_freak> cmccann: makes it easier to revisit old code, especially in a large code base
22:06:07 <shachaf> (5 mutations ought to be enough for anybody.)
22:06:35 <mm_freak> so far x'' was my maximum =)
22:06:54 <edwardk> cmccann: let me get this straight you are saying that someone who by their very nick admits to being a freak did something freakish?
22:07:06 <mm_freak> lol
22:07:41 <mm_freak> @remember edwardk cmccann: let me get this straight you are saying that someone [mm_freak] who by their very nick admits to being a freak did something freakish?
22:07:42 <lambdabot> Nice!
22:07:42 <cmccann> edwardk: he sticks to informative naming schemes I'll give him that much
22:09:08 <mm_freak> over the years of my haskell experience i've pretty much stabilized a coding style that allows me to revisit old code quickly…  a quick look is often sufficient to understand the overall structure of a definition
22:09:23 <mm_freak> that's also why i hate ($)
22:09:31 <shachaf> ($) is so easy, though
22:09:33 <shachaf> i don't hate it
22:09:55 <cmccann> pf, function application is overrated
22:10:00 <cmccann> pointless all the way
22:10:14 <mm_freak> there are some use cases ("forkIO $ do …"), but i'd never write 'long expression $ other long expression'
22:10:52 <mm_freak> cmccann: weird…  so far i've always /applied/ (.) ;)
22:11:16 <cmccann> pf, implementation details
22:11:39 <cmccann> just wait until I write a QQ'er that lets me describe function composition using ascii art diagrams
22:11:49 <mm_freak> btw, Category alone isn't very powerful
22:12:43 <startling> cmccann: we need one that writes code from repeated one-on-one lessons given on  irc
22:13:12 <shachaf> mm_freak: Category is too powerful. :-(
22:13:24 <shachaf> Most of the Arrow-like classes that we want don't want category.
22:13:30 <mm_freak> shachaf: is that a joke i don't understand?
22:13:43 <edwardk> mm_freak: we're using profunctors very heavily in lens 3.8
22:13:49 <edwardk> moreso possibly in the future
22:13:59 <isomorphic> mm_freak:   How would you write the expression you just mentioned?
22:14:04 <edwardk> the majority of these do not have Category as a superclass
22:14:14 <mm_freak> edwardk: oh, i'm not going to use lens anymore…  you released a bug…  IN HASKELL
22:14:17 <mm_freak> ;)
22:14:32 <mm_freak> isomorphic: ?
22:14:48 <isomorphic> mm_freak:  ong expression $ other long expression
22:15:02 <edwardk> and some of the subtypes of profunctors we're working with resemble things like arrow-choice, etc. sans category, arr, etc.
22:15:02 <mm_freak> isomorphic: (long expression) (other long expression)?
22:15:11 <edwardk> mm_freak: which bug freaked you?
22:15:12 <shachaf> edwardk: If I do the bytestring-0.10 fix could you do 0.9? I don't really want to get everything set up with GHC 7.4.
22:15:21 <mm_freak> edwardk: just a joke…  i was referring to the state bug =)
22:15:23 <isomorphic> mm_freak:  I was guessing brackets, but wasn't sure ;)
22:15:24 <cmccann> mm_freak: don't worry, lens wouldn't bother with such pedestrian bugs. it would have much fancier bugs, probably involving unsafeCoerce and/or something elliott thought was a good idea
22:15:25 <edwardk> shachaf: sounds fair ;)
22:15:28 <shachaf> edwardk: Alternatively I can guess a fix for 0.9 and give it to you so you can try it.
22:15:31 <mm_freak> edwardk: i'm already using profunctors extensively, btw
22:15:40 <shachaf> Since 0.10 is really easy.
22:15:55 <edwardk> i'll test/build whatever you need me to for 0.9
22:16:03 <mm_freak> lol cmccann
22:16:08 <shachaf> edwardk: I'm just going to go with a straightforward "lazy-unpack-then-fold" for 0.10, no fusion.
22:16:13 <shachaf> I think that's the most reasonable approach.
22:16:23 <edwardk> fair nuff
22:16:32 <shachaf> Unfortunately that's in .Internal.
22:16:36 <shachaf> Oh well.
22:16:40 <cmccann> @quote cmccann unsafeCoerce
22:16:40 <lambdabot> cmccann says: someone should implement a dependently-typed unsafeCoerce in Agda, you'd have to provide a proof that the coercion is invalid
22:16:42 <cmccann> @quote cmccann unsafeCoerce
22:16:42 <lambdabot> cmccann says: * cmccann has concluded that lenses are just a category whose objects are english prepositions and whose morphisms are all unsafeCoerce
22:17:00 <mm_freak> edwardk: btw, do you have an Alternative-without-Applicative class somewhere in your package jungle?
22:17:14 <shachaf> cmccann: As you demonstrated, you don't need Agda for that.
22:17:25 <edwardk> mm_freak: http://hackage.haskell.org/packages/archive/semigroupoids/3.0.1/doc/html/Data-Functor-Plus.html
22:17:27 <cmccann> shachaf: no, mine wasn't unsafe enough
22:17:32 <mm_freak> for the lack of sensible names i named it like this:  class (Functor f) => Suspend f
22:17:39 <cmccann> shachaf: it didn't rule out coercing between newtypes or anything
22:17:46 <shachaf> True.
22:18:00 <mm_freak> edwardk: great, thanks
22:19:11 <mm_freak> and it has all the instances i had to write by hand
22:19:12 <mm_freak> great
22:19:19 * cmccann thinks Align is a better sort of Alternative-ish class, pf.
22:19:40 <shachaf> Bicrosswalk is even better.
22:19:48 <cmccann> Bicrosswalk is the best thing ever.
22:19:54 <cmccann> it is so useful.
22:20:11 <shachaf> cmccann: You should rename Crosswalk to Zebra.
22:20:53 <cmccann> no. that would be too silly.
22:21:05 <cmccann> I'm sticking with serious names like "malign".
22:21:12 <mm_freak> is "strong lax monoidal functor" the category theory version of "Applicative"?
22:21:15 <cmccann> and expressions like "over here" and "over there".
22:21:25 <mm_freak> s/functor/endofunctor/
22:21:41 <monochrom> is "over my head" unsafe because of head? :)
22:21:55 <mm_freak> monochrom: surprisingly yes
22:22:09 <monochrom> \∩/
22:22:12 <mm_freak> "over my head" causes many classes of bugs in OO projects
22:22:19 <mm_freak> because of "head"
22:22:19 <monochrom> haha
22:22:36 <shachaf> Is that why GHC HEAD is unsafe?
22:22:37 <cmccann> :t over my head
22:22:38 <lambdabot>     Not in scope: `my'
22:22:39 <lambdabot>     Perhaps you meant one of these:
22:22:39 <lambdabot>       `m' (imported from Debug.SimpleReflect),
22:22:40 <cmccann> :[
22:22:50 <monochrom> I love head. it's so lazy
22:22:53 <shachaf> cmccann: mapThis's name is misleading
22:23:03 <mm_freak> @let my = undefined
22:23:04 <cmccann> it is.
22:23:05 <lambdabot>  Defined.
22:23:06 <shachaf> You should call it overHere.
22:23:07 <mm_freak> > over my head
22:23:08 <lambdabot>   No instance for (GHC.Show.Show (s0 -> t0))
22:23:08 <lambdabot>    arising from a use of `M24226...
22:23:17 <mm_freak> > (over my) head
22:23:18 <cmccann> yeah, I should rename it.
22:23:18 <lambdabot>   No instance for (GHC.Show.Show (s0 -> t0))
22:23:19 <lambdabot>    arising from a use of `M21848...
22:23:20 <edwardk> upon head works in lens, but we need a my combinator. 'be it upon my head'  or 'be it upon your head' would be a great be it code to see some day
22:23:43 <mm_freak> :t upon (my head)
22:23:44 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] k) => k (a -> f a) (s -> f s)
22:24:01 <edwardk> bah, old upon
22:24:11 <oio> can i initialize a list of Ints 	cards = (count card) : cards where caunt card retunr an Int
22:24:15 <cmccann> :t \my -> over my head
22:24:17 <lambdabot> Setting s t [b] b -> s -> t
22:24:22 <shachaf> wow can you believe we even had k (a -> f b) (s -> f t)??
22:24:26 <Walther> What is the max of Int and Integer, respeectively?
22:24:38 <shachaf> Walther: maxBound and maxBound, respectively.
22:24:48 <cmccann> > maxBound :: Integer
22:24:48 <shachaf> The latter is an error because Integer has no max.
22:24:49 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
22:24:49 <lambdabot>    arising from...
22:24:59 <edwardk> maxBound and keep on counting you'll get there eventually, really
22:25:02 <mm_freak> given a sufficiently long preamble, most random ASCII strings would be valid, type-correct haskell code
22:25:18 <mm_freak> probably even worse than perl
22:25:23 <Walther> yeah, i thought there is some knid of a limit you'll hit even with Integer
22:25:32 <shachaf> cmccann: So did you figure out how prism works?
22:25:52 <mm_freak> Walther: you can easily find the maximum Integer
22:25:55 <mm_freak> > last [1..]
22:25:56 <shachaf> Walther: The amount of RAM in your machine is a good start.
22:25:59 <lambdabot>   mueval-core: Time limit exceeded
22:26:03 <mm_freak> Walther: but give it some time
22:26:05 <cmccann> shachaf: virtual memory, though.
22:26:16 <Walther> shachaf: lol, but if we actually skip that
22:26:36 <shachaf> If you skip that you'll run into GMP issues that don't matter.
22:26:41 <Walther> given something random like a scientific computation on a huge cluster or some plausible scenario
22:26:44 <mm_freak> Walther: when your machine crashes before the universe ends, you've found the effective maximum Integer…  in that case try again with more RAM
22:26:52 <shachaf> Walther: Then you have a large virtual machine.
22:27:09 <Walther> ...yes, and what would be the bound of Integer
22:27:22 <kyle__> (possibly) stupid question.  If you have a function that returns an array, in this case primesToN, is there a difference between the lines:1) someprimes=primesToN 1000  2) let someprimes=primesToN 1000
22:27:22 <Walther> the RAM, or is there something you could hit first due some limitation
22:27:27 <shachaf> Walther: Are you still asking seriously or is this a joke now?
22:27:32 <shachaf> 22:24 <shachaf> The latter is an error because Integer has no max.
22:27:56 <shachaf> kyle__: Yes. Only one of them will compile.
22:28:01 <Walther> shachaf: No, I'm actually asking as i faintly recall someone saying that there is some sort of a limit that you would hit at some point
22:28:06 <mm_freak> kyle__: yes…  depending on the context either one or the other will be a syntax error =)
22:28:08 <shachaf> (monochrom or mauke will find a counterexample for me now, no doubt)
22:28:17 <Walther> shachaf: but it being so ridiculously big that it wouldn't matter
22:28:36 <mm_freak> kyle__: where they are valid, they have the same meaning, though
22:28:41 <shachaf> Walther: It only exists if you care enough to go hunting in the source and find it
22:29:17 <kyle__> shachaf: mm_freak: Ah, I see you're right!  I suppose my question could be put: is one of these setting a value to a variable, and one of these acting as an alias to a function?
22:29:25 <kyle__> but they're identical?
22:29:27 <mm_freak> Walther: you can't hit the limit…  your process' address space will be exhausted, before the limit is reached
22:29:35 <mm_freak> Walther: the effective limit is your machine's RAM
22:30:03 <shachaf> kyle__: No.
22:30:07 <mm_freak> kyle__: the latter is valid in specific cases…  in haskell you read "=" as "is equal to"
22:30:12 <shachaf> There's no such thing as "setting a value to a variable"
22:30:14 <mm_freak> kyle__: not "is being set to"
22:30:39 <mm_freak> kyle__: if you write "x = y" in haskell, you're writing an actual mathematical equation
22:30:51 <mm_freak> you're saying that x and y are the same thing
22:31:04 <cmccann> kyle__: both are defining a value, just with different scopes and places they can be used
22:31:07 <kyle__> mm_freak: So in other words, it's _always_ a function, but it's simply storing the result of the function it called, not re-running the function each time?
22:31:21 <mm_freak> kyle__: no, it's always a value
22:31:26 <mm_freak> not always a function
22:31:37 <mm_freak> if you can't apply it, it's not a function…  you can't apply an array
22:32:04 <mm_freak> kyle__: the other thing is about sharing…  when you give values a name, then they won't be recalculated as long as you refer to that name
22:32:21 <mm_freak> > let x = 3^1000000 in mod (x + x) 17
22:32:22 <lambdabot>   2
22:32:24 <S11001001> mostly.
22:32:25 <cmccann> shachaf: anyway no. but also I haven't really tried.
22:32:30 <kyle__> OK.  It's starting to make more sense.  I did myself no favors deciding to learn haskell on my own, while taking a programming language class last semester (which was lisp sml and prolog).
22:32:33 <mm_freak> the value 3^1000000 is only calculated once here
22:32:52 <cmccann> shachaf: but I'm sure that if I stared at prims long enough I would... B] ...see the light.
22:32:56 <mm_freak> SML experience should help with haskell
22:33:00 <mm_freak> the others don't really help
22:33:01 <kyle__> mm_freak: the question of re-calculation was the big one I was worrying about.
22:33:08 <kyle__> mm_freak: I don't think prolog helps anyone.  Ever.
22:33:27 <shachaf> cmccann: Was the first line just for the pun?
22:33:32 <shachaf> I bet it was just for the pun.
22:33:43 <mm_freak> kyle__: there is a simple rule of thumb:  if you want to reuse the value, name it
22:33:48 <cmccann> shachaf: no.
22:33:49 <cmccann> just mostly.
22:33:59 <shachaf> cmccann: Well, do you know how iso works?
22:34:28 <simpson> kyle__: Prolog's pretty great as a thing to have under your belt, even if you never build anything with it.
22:34:30 <mm_freak> kyle__: you name values either by binding (arguments, <-) them or by defining them (=)
22:34:41 <cmccann> I forget what the definition of Iso in lens even is
22:35:13 <shachaf> cmccann: Well, forget about lens isos. Think about profunctor isos. :-)
22:35:16 <shachaf> You know how Profunctor works?
22:35:37 <cmccann> it's the opposite of an amateurfunctor rite
22:35:50 <shachaf> Exactly.
22:35:55 <mm_freak> kyle__: and the technical term for that in haskell is 'sharing'…  when values are reused, they are 'shared'
22:35:58 <oio> can i initilialaze a list inside a function that doestn disappear when the function is over
22:35:58 <edwardk> profunctor isos are easy. type Iso s t a b = forall p. Profunctor p => p a b -> p s t
22:36:06 <edwardk> with lens we bolt an extra Functor in there
22:36:20 <mm_freak> oio: you don't initialize lists, you define them
22:36:24 <edwardk> type Iso s t a b = forall p. (Profunctor p, Functor f) => p a (f b) -> p s (f t)
22:36:30 <edwardk> but that Functor adds no expressive power
22:36:38 <edwardk> it just exists to be compatible with traverse, etc.
22:36:39 <shachaf> If I give you "p a b" and you have to give me "p s t", the only way you can do it is by mapping two functions :: (s -> a) and :: (b -> t) over it.
22:36:46 <shachaf> Since that's all the Profunctor interface lets you do.
22:36:50 <cmccann> yes, profunctors are a pretty simple idea
22:36:53 <shachaf> So therefore that means you have both functions.
22:37:00 <mm_freak> oio: as long as a list isn't proven not to be used anymore, it will stay in memory as far as it has been evaluated
22:37:05 <shachaf> So (forall p. Profunctor p => p a b -> p s t) ~~ (s -> a, b -> t)
22:37:14 <cmccann> makes sense
22:37:26 <kyle__> Awesome.  Thanks guys!  I'm going to crash, and hopefully this will stick well in my head!
22:37:34 <shachaf> cmccann: So now by adding things that you can do to the profunctors, you become able to do more things.
22:37:36 <oio> ok
22:37:36 <edwardk> and since i can pick p and f in the lens case i can pick f = Identity and the same reasoning holds
22:37:44 <oio> i will do some experiments
22:37:56 <cmccann> shachaf: adding things you can do lets you do things, gotcha.
22:38:01 <cmccann> insightful.
22:38:14 <shachaf> cmccann: That's the main idea in lens, really.
22:38:32 <shachaf> And people say lens is scary!
22:38:40 <shachaf> cmccann: For example, for prisms, we add a method :: p a b -> p (Either r a) (Either r b)
22:39:03 <shachaf> Now you can write prism :: (b -> t) -> (s -> Either t a) -> p a b -> p s t
22:39:07 <edwardk> with lens we basically start from the basis that things look like p a (f b) -> q s (f t)   and we put constraints on p and f.        the pure profunctor model is nicer, because you only have p a b -> q s t    with constraints on p and q.
22:39:09 <simpson> Are there any downsides to Data.Complex for storing 2D vectors? I currently have a dx and dy for velocity (and acceleration) over time, and was thinking of using Complex for its useful functions and lenses.
22:39:19 <simpson> I know that it's strict in the constructor, and I don't think I care.
22:39:49 <edwardk> simpson on older ghc's you can't store values that aren't realfloat, and its missing a ton of useful instances as a result, e.g. there is no Functor, Foldable or Traversable instance for Complex which always annoys me
22:40:12 <elliott> Technically you add (Costrong f, Pointed f) => p a b -> p (f a) (f b)
22:40:15 <elliott> Because of reasons.
22:40:18 <simpson> edwardk: It doesn't seem reasonable to have a Functor instance, TBH.
22:40:26 <mm_freak> simpson: what edwardk said…  as an alternative see the vector-space library
22:40:28 <simpson> I mean, it's a pair of numbers that you do math on.
22:40:39 <shachaf> elliott: By Costrong you mean not Costrong but Ellicostrong.
22:40:42 <mm_freak> simpson: it's always useful to have a Functor instance
22:40:53 <elliott> shachaf: I'm confident that all law-abiding instances of Costrong are also an instance of my Costrong.
22:40:55 <edwardk> simpson: convert change to another ring. say you want to take a Complex Float to a Complex Double to do some work then convert back
22:41:02 <simpson> edwardk: Ah.
22:41:08 <isomorphic> Has anybody running ghc on linux noticed a slowdown in linking speed lately?
22:41:13 <shachaf> elliott: OK, but the classes aren't equivalent.
22:41:13 <cmccann> mapping realToFrac over Complex seems pretty reasonable to me
22:41:13 <elliott> I'm pretty sure any way you can use (Either r) beyond (Costrong, Pointed) messes stuff up.
22:41:19 <edwardk> simpson: these instances are useful for lots of things that aren't obvious
22:41:27 <simpson> edwardk: Yeah, I guess so.
22:41:35 <elliott> shachaf: Well, if every Ellicostrong is Costrong (obviously true per specialisation), and every law-abiding Costrong is Ellicostrong, then calling my class Costrong seems perfectly reasonable.
22:41:42 <mm_freak> @hackage vector-space
22:41:42 <lambdabot> http://hackage.haskell.org/package/vector-space
22:41:42 <elliott> Especially since it's being used as a dual to Functor-as-Strong
22:41:47 <mm_freak> @ simpson
22:41:49 <elliott> It's just another expression of the same thing.
22:41:59 <shachaf> Doesn't seem right to me, but whatever.
22:42:12 <edwardk> one of the reasons i tend to wind up writing so many of my own packages is because most of the time when i incur a dependency on someone else's they've left off instances I need =(
22:42:17 <mm_freak> use that one, until edwardk writes a version based on representable functors =)
22:42:25 <shachaf> edwardk: I'm surprised you haven't given up on base.
22:42:29 <edwardk> mm_freak: see linear
22:42:29 <simpson> Hm. I'm loathful of the word "overkill," but vector-space might be overkill for me at this point.
22:42:31 <edwardk> @hackage linear
22:42:31 <lambdabot> http://hackage.haskell.org/package/linear
22:42:36 <mm_freak> ah, nice
22:42:43 <edwardk> mm_freak: http://hackage.haskell.org/packages/archive/linear/0.6.1/doc/html/Linear-Core.html is corepresentable
22:42:43 <cmccann> edwardk: most people don't have enough free time to write all the instances you want all the time
22:42:50 <elliott> shachaf: It's OK to call nil :: f (); zip :: f a -> f b -> f (a,b) Applicative, if you have a Functor superclass, surely?
22:42:59 <elliott> shachaf: Except that's further away because the way you use it is different.
22:43:09 <elliott> Whereas my "costrength" works literally as the Either "costrength".
22:43:12 <edwardk> cmccann: i'd be okay if they even implemented the stock ones from haskell 98 for the most part
22:43:21 <shachaf> elliott: I can write something to convert nil to pure and zip to <*>
22:43:30 <edwardk> cmccann: i went to use ansi-terminal the other day, and needed Eq instances for types it supplies. no dice.
22:43:31 <simpson> Also okay, fine, linear's types look really nice.
22:43:32 <shachaf> I can't convert your methods to Costrong.
22:43:36 <mm_freak> edwardk: what does the Monad instance for V2 do?  zipping?
22:43:42 <simpson> Even if there aren't lenses for it. (Yet.)
22:43:47 <edwardk> mm_freak: takes the trace, and yeah it zips
22:43:49 <elliott> shachaf: What is "your methods" and "Costrong" there?
22:43:53 <mm_freak> great
22:43:53 <cmccann> edwardk: is there a monad instance for "(,) w" anywhere yet?
22:44:00 <edwardk> simpson: um, V2 provides _x and _y which are lenses
22:44:01 <cmccann> speaking of standard instances :P
22:44:04 <shachaf> elliott: n.hs Costrong and the method it has.
22:44:10 <shachaf> preflex: seen dcoutts
22:44:10 <preflex>  dcoutts was last seen on #haskell 8 days, 3 hours, 20 minutes and 29 seconds ago, saying: * dcoutts disappears
22:44:17 <shachaf> Uh oh.
22:44:18 <elliott> shachaf: You can't convert Costrong methods to Costrong?
22:44:22 <elliott> Sure you can.
22:44:28 <shachaf> elliott: I can't convert them to "real" Costrong.
22:44:28 <elliott> That's kind of tautological.
22:44:33 <elliott> shachaf: ...of course you can.
22:44:36 <mm_freak> seems like 'linear' is also lens-ready
22:44:38 <shachaf> Er.
22:44:40 <edwardk> simpson: and its built around using the polymorphic lenses of a type as its representation
22:44:40 <elliott> shachaf: Their type is a generalisation of "real" Costrong.
22:44:45 <shachaf> I can't convert "real" Costrong to them.
22:44:51 <simpson> edwardk: Oh, they're on the class. I see.
22:44:56 <mm_freak> i like it
22:44:57 <edwardk> mm_freak: it had a lens dep until recently, it was cleaned up so it doesn't need the dep but is built around lenses anyways
22:45:06 <elliott> shachaf: OK, granted. (Though I'm not sure it's impossible?)
22:45:16 <shachaf> elliott: If it's possible then I have no real objection.
22:45:18 <mm_freak> edwardk: the R2 class suggested it =)
22:45:21 <simpson> edwardk: Well, after I've gotten this section of code up off the ground and I'm sure the math's right, maybe I'll switch to these.
22:45:27 <elliott> Anyway any name I can think of would be far worse than Costrong, and given the properties I've already enumerated (esp. it being used as a dual to Functor-as-Strong) I think Costrong is a decent name for it.
22:45:33 <johnw> are there more Haskell linters besides hlint and ghc?
22:45:49 <edwardk> linear is in many ways what lens was originally written for. it was originally part of a small physics engine i was writing, and i wrote a one module lens library to go with it because i wasn't happy with anyone else's.
22:46:12 <edwardk> lens has er.. grown a little since those days
22:46:15 <elliott> edwardk: or your own
22:46:47 <edwardk> or my own ;)
22:47:39 <mm_freak> edwardk: i guess the Monad instance is O(n) for Vn
22:47:47 <cmccann> edwardk: speaking of your countably many packages, I was messing with a toy lambda calculus thingie and doing simple typechecking on an expression using bound seemed kind of awkward because of the changing types
22:47:50 <startling> edwardk: this is why we need lens-core, right? :)
22:47:53 <cmccann> am I missing something obvious here?
22:48:24 <mm_freak> cmccann: the changing types is what's great about bound
22:48:29 <elliott> startling: lens-core is called profunctors
22:48:48 <cmccann> I think your examples were all untyped lambda calculus so didn't clarify things
22:48:52 <edwardk> lens-core is unlikely. we're to the point now where you can already define lenses, prisms, isos, traversals, and equalities without depending on lens while remaining entirely haskell 98.
22:48:57 <edwardk> what more do you want in a core?
22:48:58 <startling> elliott: some more categorical nonsense I need to learn? dang
22:49:09 <elliott> startling: it's becoming increasingly fundamental
22:49:31 <elliott> edwardk: well, indexing. but it's only a matter of time until pure profunctor lenses and we can add that profunctor transformer or whatever to profunctors!! :P
22:49:33 <mm_freak> cmccann: where are you stuck and which type system did you use?
22:49:42 <startling> edwardk: eh, that's true.
22:49:49 <startling> mostly I just want the type synonyms
22:49:50 <shachaf> Pure profunctor lenses are terrible.
22:49:53 <elliott> edwardk: I like how you included "equalities" there.
22:49:53 <shachaf> You can't even do indexing.
22:50:12 <startling> and view/set/over
22:50:15 <elliott> FINALLY I can export forall p f. p a (f b) -> p s (f t) without depending on lens.
22:50:33 <elliott> startling: and foldMapOf, and preview, and toListOf
22:50:46 <elliott> startling: and then you start wanting more
22:50:47 <edwardk> startling: i may make a small package with just some type aliases that can sit on top of profunctors, but then i have to deal with two camps of peope who want those aliases, those who want only haskell 98 slavishly and those who want it usable but small
22:50:49 <shachaf> Ugh, bytestring code. :-(
22:50:51 <startling> elliott: no, fuck those guys
22:50:51 <edwardk> startling: so meh
22:50:55 <cmccann> mm_freak: I forget exactly what the stumbling block was, but I even with just STLC I wasn't sure what the best way to handle it was
22:51:04 <elliott> startling: you can build your own one-module lens library that is compatible with lens that has those anyway
22:51:10 <startling> edwardk: understandable
22:51:23 <mm_freak> cmccann: for STLC you wouldn't use Scope for the types AST
22:51:30 <mm_freak> except perhaps for scoped type aliases
22:51:52 <cmccann> mm_freak: that's one of the things I was wondering, should I just blow all that away and get a boring AST to typecheck
22:51:52 <edwardk> lens is hard enough to build and maintain without building and maintaining it another 2 times (in addition to the 8-9 times its been rewritten already) ;)
22:52:02 <elliott> edwardk: fwiw, our current profunctor lenses are H98 + rank-2
22:52:05 <mm_freak> you would only use it for upper case lambda in exactly the same way you use it for lower case lambda
22:52:07 <elliott> + some noise like derivefunctor that could be eliminated
22:52:17 <elliott> in fact the only rank-2 use is in Bazaar
22:52:27 <edwardk> elliott: sure. and the rank-2 use is only used for consumption not construction
22:52:40 <elliott> edwardk: ?
22:52:45 <elliott> the rank-2 is used for implementing "walking" only
22:52:48 <elliott> which is a traversal constructor
22:53:00 <elliott> (maybe we can figure out something faster than Walk that avoids the round-trip and get rid of that rank-2!)
22:53:00 <cmccann> mm_freak: but since I'd probably want polymorphic types and such for anything more interesting that seemed like a dead-end solution
22:53:02 <edwardk> i mean that you don't need rank-2 to define traversals, just to consume them there
22:53:22 <elliott> edwardk: we don't need rank-2 to consume them either afaik?
22:53:28 <elliott> walking :: Walk p => ((a -> Bazaar a b b) -> s -> Bazaar a b t) -> p a b -> p s t
22:53:28 <edwardk> at this time i'm about 60% on the side that Walk is too slow, and representability is needed
22:53:37 <elliott> that's the only function we need rank-2 to implement, because Bazaar needs it
22:53:41 <mm_freak> cmccann: STLC with big-lambda is about as polymorphic as you can get =)
22:53:48 <elliott> edwardk: yeah... I am going to play with stuff and see if I can find something faster/nicer
22:53:56 <edwardk> Bazaar itself is rank-2, thats what i mean. you don't need to expose bazaar to end users to define them
22:53:59 <edwardk> thats all i meant
22:54:02 <elliott> right
22:54:06 <shachaf> elliott: After 3.8!
22:54:06 <elliott> edwardk: have you tried the rank-2 version of walking?
22:54:07 <edwardk> bazaar is an implementation detail for consumption
22:54:15 <elliott> I think that might be faster somehow
22:54:29 <edwardk> the one that looks like compos?
22:54:32 <elliott> the one that's commented out in n.hs
22:54:36 <elliott> walking :: Walk p => (forall f. Applicative f => (a -> f b) -> s -> f t) -> p a b -> p s t
22:54:39 <elliott> walking f = dimap (\s -> Baz (flip f s)) (\(Baz t) -> runIdentity (runBazaar t Identity)) . walk
22:54:40 <cmccann> mm_freak: don't suppose you have an example lying around? :T pretty sure I'm just managing to somehow not see the obvious way to do it.
22:54:47 <elliott> that avoids a "sell" but I don't know if it actually ends up faster :P
22:55:02 <mm_freak> cmccann: just compare haskell's 'id' to agda's 'id'
22:55:05 <edwardk> i don't see that being much faster, you avoid packaging a dictionary by packaging one member of it
22:55:08 <mm_freak> id :: forall a. a -> a
22:55:16 <mm_freak> id : (A : Set) -> A -> A
22:55:34 <cmccann> mm_freak: no, I mean an example of how you'd write a typechecker for it :P
22:55:46 <shachaf> edwardk: Ugh, I have to do .Char8 too, don't I.
22:55:54 <shachaf> Can we just not support Char8? :-(
22:55:54 <edwardk> shachaf: its the same bytestring
22:56:05 <shachaf> edwardk: Yes, but not the same unpack.
22:56:05 <mm_freak> cmccann: ah…  i have no example ready, but there are many ways to do it…  does it help, if i tell you that you need a name supply? =)
22:56:09 <edwardk> true
22:56:16 <edwardk> sadly we have both traversals
22:56:28 <cmccann> bah! names.
22:56:33 <mm_freak> cmccann: the obvious way is to have a type-checking monad that is a StateT with a name supply
22:56:45 <edwardk> who needs names?
22:56:45 <shachaf> Can we rename "chars" to "char8s" or something?
22:56:54 <mm_freak> you need names…  that's one of the caveats of locally nameless…  you need to invent names
22:56:59 <cmccann> but no, that wasn't really the stumbling block. it's not that I couldn't make it work, it's that it felt needlessly obtuse and awkward.
22:57:04 <edwardk> mm_freak: for what walking under lambas?
22:57:21 <mm_freak> edwardk: type-checking in this case
22:57:21 <elliott> We need globally nameless :(
22:57:27 <oio> can a function remember things?
22:57:44 <mm_freak> cmccann: if you write an example, i can tell you how to improve it =)
22:57:58 <mm_freak> a type checker for STLC with explicit type passing should be quite short
22:58:08 <edwardk> mm_freak: i have a perfect namesupply for that. fromScope gives you new names by giving you back Either bound or free, just extend your environment with the new bound variables and move the old logic to the other side of the Either, cps style and carry on
22:58:14 <edwardk> no explicit names are introduced
22:58:16 <cmccann> little stuff like e.g. anything carried along as a state value won't match the type of the expressions inside a lambda
22:58:28 <mm_freak> edwardk: yeah, that's Agency-style
22:58:34 <mm_freak> to be honest, i don't really like it =)
22:58:35 <edwardk> no silly strings or integer ids apply
22:59:00 <edwardk> https://github.com/ekmett/bound/blob/master/examples/Simple.hs#L70
22:59:05 <mm_freak> edwardk: or maybe i get it wrong
22:59:13 <edwardk> i grew my free variable set and polymorphically recursed
22:59:36 <edwardk> and you only need to deal with that when you want to walk under lambdas
22:59:54 <cmccann> really, anything where I wanted to inspect the AST recursively without binding variables seemed to result in headaches somehow
23:00:15 <mm_freak> edwardk: i don't see how you can get along without names in a type checker…  you need a running context, which is basically a map from names to types
23:00:40 <edwardk> mm_freak: comonads are your friends ;)
23:00:57 <mm_freak> to get rid of names or to make names more pleasing? ;)
23:01:01 <edwardk> you can put the type right into the free variable
23:01:13 <edwardk> there is no environment just a comonad for Typed
23:01:18 <mm_freak> ah, i see
23:01:21 <mm_freak> interesting approach
23:01:23 <edwardk> thats just an environment comonad
23:01:32 <edwardk> hence the name ;)
23:01:49 <mm_freak> that's what "moving to the leaves" means then =)
23:03:43 <memand> Hey guys, I'm just starting to learn haskell
23:03:54 <johnw> is there an easy way to tell if my package has unnecessary dependencies?
23:03:57 <johnw> memand: welcome!
23:03:59 <cmccann> trying to get Data/Typeable instances for the AST was also exciting
23:04:07 <memand> thanks :)
23:04:41 <mm_freak> johnw: no, sorry…  but you can find that out by trial and error using an O(log n) algorithm =)
23:04:51 <mm_freak> johnw: hint:  comment out half of your dependencies ;)
23:05:08 <lispy> hello
23:05:33 <oio> can a function do this?
23:05:35 <oio> Prelude> intlist 1 [1] Prelude> intlist (-1) [-1,1] Prelude> intlist 2 [2,-1,1]
23:05:40 <memand> :) I was wondering if you know of any good "n00b" videos on the subject? I'm for the moment following this guide http://learnyouahaskell.com/ but I like to fall asleep to people talking when learning new laguages :)
23:06:05 <mm_freak> oio: what is "this"?  extend a list?
23:06:21 <elliott> memand: if you watch edwardk's lens video you won't learn anything but you'll definitely fall asleep
23:06:27 <cmccann> hahaha
23:06:32 <hpaste> OiO pasted “function” at http://hpaste.org/80962
23:06:32 <memand> elliott: lol
23:06:46 <edwardk> =P
23:06:46 <mm_freak> memand: i recommend watching the amuse-bouche video
23:06:50 <oio> whatch paste
23:06:51 <Walther> memand: there was this one good google talk
23:06:55 <Walther> that one, yeah :D
23:07:00 <Walther> amuse-bouche
23:07:11 <Walther> i've watched it two times, perhaps going for a third now
23:07:13 <cmccann> we need a video of elliott and shachaf explaining lens.
23:07:13 <mm_freak> oio: is that an actual GHCi session?
23:07:21 <cmccann> doubt anyone would learn anything, but it would be entertaining.
23:07:31 <oio> no..
23:07:40 <edwardk> cmccann: they's spend the entire time who's on first style debating about who was going to give the talk.
23:07:40 <elliott> I think putting me and shachaf in the same room would be a terrible idae.
23:07:54 <mm_freak> oio: yes, a function can do that, given that it has a type signature like this:  intlist :: Int -> IO [Int]
23:07:58 <cmccann> elliott, yes that's the idea
23:08:06 <mm_freak> oio: but you really don't want that
23:08:23 <edwardk> they'd get about 10 minutes into it and get bored and start writing another version of lenses
23:08:24 <oio> so where the list gets stored?
23:08:40 <memand> Walther mm_freak: I'll look that one up, the videos I've found so far has mainly been with some indian guy with way too broken english to understand unless I concentrate :P
23:09:03 <elliott> edwardk: re that comonadic name-supply-free typechecking stuff: is there a reason you don't do that in your thingy? you said you did a trick with using IORefs for temporary names instead recently
23:09:06 <edwardk> memand: https://www.youtube.com/watch?v=cefnmjtAolY&hd=1
23:09:07 <mm_freak> oio: depends on the list and on how you use it…  chances are the list doesn't exist at all in memory
23:09:07 <Walther> memand: protip, try to concentrate anyway :P
23:09:12 <elliott> I'm terribly specific today
23:09:16 <cmccann> edwardk: I figure it'd be roughly equal parts abstract nonsense, reinventing wheels, and stand-up comedy
23:09:31 <mm_freak> oio: you're thinkg very operationally…  you should read one of the haskell tutorials and try to forget all of your prior programming knowledge
23:09:32 <edwardk> elliott: thats for unification
23:09:33 <elliott> memand: I suggest not watching edwardk's video until you've at least finished LYAH.
23:09:39 <lispy> edwardk: not really trying to bring up an embarassing software release. Just struck me as an easy mistake to make and one that is hard to spot.
23:09:43 <elliott> edwardk: ah
23:09:51 <edwardk> lispy: no worries ;)
23:10:18 <oio> then how can i keep count of things in list stored on memory
23:10:29 <memand> Walther: I like concentrating, but I like concetrating on a subject not on understanding what they are saying ;)
23:10:37 <elliott> cmccann: probably half-way through shachaf would go "what if we used, like, a type invariant in BOTH arguments?"
23:10:55 <mm_freak> oio: "keep count"?  as in "keep track"?  you can do that by using recursion for starters
23:10:59 <elliott> cmccann: and I'd tell him to shut up and carry on and then he'd show me a file with a one-letter name and I'd be instantly converted and start trying to get edwardk to switch lens over to it
23:11:06 <memand> elliott: I'll try :P
23:11:11 <edwardk> elliott: basically while we're doing inference we use bound, and then instantiate with more classic unification-style meta-variables, and then we can flush those out of the system when we generalize and pack that back into bound
23:11:23 <cmccann> elliott: one-letter names are so easy.
23:11:27 <elliott> edwardk: right
23:11:33 <lispy> memand: look for videos by simon peyton-jones. I dunno if he has any that teach haskell, but he gives great talks.
23:11:36 <elliott> edwardk: is there any way to avoid generating new names "explicitly" there? :(
23:11:40 <mm_freak> oio: lineCounter n = do putStrLn ("You've entered " ++ show n ++ " lines so far."); getLine; lineCounter (n + 1)
23:11:45 <elliott> I want to have faith in bound as the perfect tool for everything
23:11:45 <shachaf> cmccann: Can you believe I once had:
23:11:59 <shachaf> class Isoy g where iso :: Functor f => (s -> a) -> (b -> t) -> (g a -> f b) -> g s -> f t
23:12:02 <shachaf> ?
23:12:15 <elliott> ha ha, symmetric lenses
23:12:19 <elliott> they were so bad
23:12:19 <shachaf> (Exercise: Figure out what g really is.)
23:12:21 <elliott> except for the good parts
23:12:31 <shachaf> elliott: Symmetric lenses helped us figure out Un!
23:12:33 <elliott> but even those were kind of bad
23:12:41 <shachaf> Well, they helped me figure out the thing that led to Un.
23:12:41 <elliott> shachaf: They did?
23:12:51 <memand> lispy: Nice tip, that led me here by google http://www.haskell.org/haskellwiki/Video_presentations
23:12:54 <shachaf> elliott: They're the thing that got us thinking about p t s -> p b a
23:12:57 <shachaf> Sort of.
23:13:11 <oio> but then when the functions exits finish data gets erased?
23:13:12 <elliott> They are?
23:13:19 <shachaf> Yep.
23:13:22 <elliott> howso?
23:13:26 <shachaf> Remember how we were trying to figure out how to make prisms nice?
23:13:26 <mm_freak> oio: if it doesn't return it, yes
23:13:31 <edwardk> #haskell-lens is probably the only forum i actively participate in that i'm the voice for _not_ changing things
23:13:33 <shachaf> And we were thinking in terms of symmetric lenses.
23:13:45 <mm_freak> oio: values in memory get garbage-collected as soon as nothing refers to them anymore
23:13:52 <mm_freak> well, that's not precise
23:13:53 <oio> ok so it returns where can i stored it?
23:13:58 <shachaf> elliott: (By the way we never made prisms nice. :-( )
23:14:00 <edwardk> well, at least for only changing the things i want to change ;)
23:14:06 <mm_freak> oio: what do you mean by "store"?
23:14:14 <memand> edwardk: u Danish?
23:14:22 <oio> keep the list alive to add things later
23:14:34 <mm_freak> oio: in haskell you can't change values, but you can call the same function with different arguments…  in particular a function can call itself with different arguments
23:14:36 <elliott> shachaf: ?
23:14:37 <edwardk> memand: very much an american mutt ;)
23:14:40 <elliott> n.hs prisms are nice.
23:14:56 <mm_freak> oio: that's how you implement changing state…  what i've done with an Int you can do with a list or anything else
23:15:11 <shachaf> elliott: I mean nice as in "don't use Either"
23:15:15 <memand> elliott: gues I just got confussed by your name edwarDK ::P
23:15:22 <edwardk> hah
23:15:30 <elliott> shachaf: Oh, UI-wise.
23:15:35 <shachaf> elliott: You know, the thing we were trying to figure out where you have a g b, and you map your (b -> t) over it, and then you do something else and it's all "implicit".
23:15:37 <oio> @.@
23:15:37 <lambdabot> Maybe you meant: . @
23:15:39 <mm_freak> oio: of course that's the lowest level…  you need to understand that one to use higher level abstractions for state keeping
23:15:40 <elliott> shachaf: Well, you can use not-Either with prismy.
23:15:45 * cmccann still isn't convinced that "km" is a valid consonant cluster.
23:15:48 <shachaf> elliott: I think figuring this out would help us understand more than UI.
23:15:50 <elliott> shachaf: For instance, you can use Maybe.
23:15:55 <shachaf> Sure.
23:16:01 <shachaf> But you have to use a sum.
23:16:08 <shachaf> Whereas in lens you don't really use a product.
23:16:08 <elliott> In fact, can we generalise the prism we have? I think we might be able to.
23:16:22 <elliott> shachaf: Remember when prismatic was either id?
23:16:29 <elliott> prism, like, uses either id, man.
23:16:30 <edwardk> cmccann: i think there are some slovenians and bulgarians who might disagree, but its always weirded me out too ;)
23:16:40 <mm_freak> oio: again, i recommend reading a haskell tutorial like LYAH
23:16:42 <mm_freak> @where lyah
23:16:42 <lambdabot> http://www.learnyouahaskell.com/
23:16:53 <elliott> it's pronounced kuh-met right
23:16:59 <edwardk> elliott: yeah
23:17:14 * cmccann thought the "e" was silent
23:17:25 <cmccann> ;P
23:17:25 <mm_freak> kuh-met has a funny meaning in german
23:17:34 <edwardk> mm_freak: ?
23:18:02 <elliott> Dwrd Kmtt
23:18:12 <mm_freak> kuh = cow, and met is honey wine
23:18:23 <elliott> shachaf: costrength = either (point . Left) (fmap Right)
23:18:28 <elliott> shachaf: Can you derive "either id" from this somehow?
23:18:29 <mm_freak> my translator says that it's called mead in english
23:18:31 <elliott> I bet you can.
23:18:34 <edwardk> iirc in bulgarian its something like slave, and in slovenian, mayor. (or maybe i have those backwards)
23:18:38 <memand> mm_freak: Yah, drunken cows :D
23:18:43 <cmccann> mm, mead.
23:18:45 <mm_freak> =)
23:18:58 <shachaf> Is it really pronoced with two syllables?
23:19:01 <shachaf> That's disappointing.
23:19:01 <elliott> Oh, I think it's easy.
23:19:06 <edwardk> i'll lay off the cow mead for now thank you ;)
23:19:07 <shachaf> u
23:19:30 <mm_freak> memand: i was actually thinking of mead made from cows…
23:19:31 * shachaf was hoping for that km to be a juicy cluster.
23:19:45 <mm_freak> but i agree…  it's a disgusting thought
23:19:46 <oio> lol this is horrible hope you understand
23:19:47 <cmccann> anything can be pronounced as one syllable if you try hard enough.
23:19:52 <memand> mm_freak: hahaha, sound interesting... :P
23:19:53 <hpaste> OiO pasted “@.@” at http://hpaste.org/80963
23:20:24 <shachaf> cmccann: you should /nick cmccnn imo
23:20:32 <mm_freak> oio: i think what you want is a recursive IO action…  see again the example i've written earlier
23:20:54 <startling> kuh-met: the egyptian god of traversals?
23:21:00 <mm_freak> lol
23:21:20 <mm_freak> what is it that is pronoucned like kuh-met?
23:21:28 <mm_freak> i have no idea what you guys are talking about…
23:21:33 <edwardk> startling: iirc KMT is the egyptian name for themselves
23:21:35 <cmccann> mead is fermented honey, honey is made from liquid from flowers, milk comes from cows, ergo cow mead must be fermented milk
23:21:37 <cmccann> mystery solved.
23:21:39 <memand> does kuh-met have a meaning in haskell or are we just facinated by the manny meanings of it?
23:21:46 <edwardk> Kemet = Egypt in egyptian
23:22:00 <startling> edwardk, are you egyptian?
23:22:10 <edwardk> memand: its my last name. i write a rather large amount of haskell code
23:22:18 <alec__> well, edwardk, it's kmt because we don't know what vowels were there; startling, he means ancient egyptian
23:22:21 <edwardk> startling: not to my knowledge ;)
23:22:29 <memand> edwardk: Ah :)
23:22:46 <edwardk> alec__: yes hence why i wrote it KMT the first time ;)
23:22:53 <startling> edwardk, now you know! this is conclusive
23:22:54 <alec__> ah, sorry
23:22:58 * alec__ bows to edwardk
23:23:24 <oio> (-＿-)
23:23:42 <elliott> shachaf: Hmm, you can write "Costrong g => (a -> g b) -> g a -> g b".
23:23:45 <elliott> Isn't that interesting?
23:23:54 <elliott> Wait... that's (>>=).
23:24:05 <elliott> edwardk: help what's going on
23:24:06 <cmccann> :t (>>=)
23:24:07 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:24:11 <memand> edwardk: Do you have a github or some public code to look at?
23:24:11 <cmccann> :t (=<<)
23:24:12 <lambdabot> Monad m => (a -> m b) -> m a -> m b
23:24:26 <elliott> It's isomorphic!
23:24:34 <elliott> So Traversable gives you (>>=) too. What's up with that?
23:24:48 <mm_freak> > kuh-met
23:24:50 <lambdabot>   0
23:25:09 <startling> memand: ∀x. @hackage x
23:25:13 <cmccann> haha
23:25:24 <mm_freak> to answer the question, what's a cow without alcohol…
23:25:37 <mm_freak> unfortunately Nothing - Nothing didn't type-check =)
23:26:11 <mm_freak> @undefine
23:26:54 <memand> startling: The twitter?
23:27:03 <edwardk> alec__: i'll never know if that bow was over my knowledge of ancient egyptian or deference to my status as some ancient cow god of mead or an ironic mocking bow to a poor slovenian slave farmer. ;)
23:27:07 <startling> memand: sorry, it was kind of an obscure joke.
23:27:18 <edwardk> memand: github.com/ekmett
23:27:28 <cmccann> edwardk: why not all of the above?
23:27:49 <memand> edwardk: thanks ;)
23:27:57 <elliott> shachaf: Can you log into the Gobby file? I want Control.Comonad in scope.
23:28:07 <lispy> deja vu sans mono is failing me on some glyphs, but it's still got pretty good coverage
23:28:32 <shachaf> elliott: I'm there.
23:28:34 * lispy notes this glyph is missing: -＿-
23:28:42 <shachaf> elliott: Feel free to import it.
23:28:51 <edwardk> cmccann: knowing alec__  thats the most likely scenario
23:29:50 <startling> memand, edwardk writes lots of packages; @hackage x is a lambdabot command to get a link to the haskell package named 'x'
23:30:45 <lispy> We have these two posts: http://ridiculousfish.com/blog/posts/old-age-and-treachery.html http://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html Who is going to write a haskell version of grep to beat out the C version? (hint: use all the relevant tricks from gnu grep add in an even better regexp compiler)
23:31:53 <memand> startling: Aah, that makes it a litle bit more funny :P
23:32:53 <shachaf> lispy: What regexps?
23:32:57 <shachaf> That post is about searching for strings.
23:33:19 <lispy> shachaf: indeed.
23:33:36 <lispy> shachaf: so, be as fast as grep for strings and faster for regexp
23:34:40 <lispy> I have a windows/ghc question (I think), but it takes a bit to motivate it.
23:35:16 <lispy> Often when using agda from inside emacs, agda will panic because it fails to write a file. I think this is actually a windows or ghc-ism. I think darcs has has similar issues in the past.
23:35:22 <lispy> How can we fix this?
23:35:42 <memand> lispy: Don't use Windoze?
23:35:51 <lispy> I suspect it has to do with windows and the file locking mandated by the Haskell report.
23:36:18 <lispy> But, I lack familiarity with windows to even begin to properly diagnose or debug it
23:36:33 <elliott> memand: Not helpful.
23:36:36 <lispy> memand: if every haskeller ignores windows then windows will contine to be a sucky platform for haskell.
23:36:39 <mm_freak> edwardk: how did you choose the epsilons for Linear.Epsilon?  is there some reasoning for the values?
23:36:57 <memand> elliott: Sry
23:37:04 <lispy> memand: I do empathize with your point. Windows is a bad environment for programmers.
23:37:06 <oio> mm_freak: http://www.cs.cmu.edu/~sleator/papers/fully-persistent-lists.pdf
23:37:57 <oio> oio: _
23:38:18 <memand> lispy: It is, but you are right that there will only be better suport with an increase of hackers using the platform... Sadly I don't see that happening any time soon...
23:38:54 <edwardk> mm_freak: its based on my past experience writing game engines and what constituted close enough to zero for most of those
23:39:32 <lispy> memand: I recently learned that a huge part of it is actually the oddest thing. No ttys or pseudo ttys means that writing a shell or a proper terminal applications requires heavily lifting, deep magic, and arcane knowledge :(
23:39:37 <edwardk> lispy: i patched lens's doctests to support utf-8 doctesting on windows today. almost threw up
23:39:50 <lispy> edwardk: do tell
23:39:56 <lispy> edwardk: or link to patch?
23:40:16 <memand> edwardk: lol
23:40:25 <shachaf> https://github.com/ekmett/lens/commit/0bfda5
23:40:26 <edwardk> lispy: just ugly: https://github.com/ekmett/lens/commit/0bfda5bd37ee5ac69537de363703932b7908d8b8
23:40:35 <lispy> edwardk: I found some telling bugs (utf8/unicode-wise) on the ghc trac that paint an interesting picture of intrigue and misdirection
23:40:50 <mm_freak> oio: ?
23:41:13 <cmccann> lispy: there are easier solutions for making terminal applications work nicely on windows
23:41:17 <lispy> Fixing this windows-specific rough edges is the kind of thing that could earn someone considerable kudos.
23:41:19 <cmccann> running an ubuntu vm, for instance
23:41:26 <edwardk> lispy: one point for haskell is that unlike java it supports the 65001 faux code-page correctly
23:41:36 <cmccann> or... ok I'm not sure of any others
23:41:40 <lispy> cmccann: yeah, and yet that doesn't actually solve the problem it sidesteps it.
23:42:01 <mm_freak> edwardk: congratulations…  the next netwire release will use linear instead of vector-space
23:42:10 <edwardk> mm_freak: =)
23:42:15 <memand> lispy: Almost any kind of computer usage under windows, other than user level stuff is not meant for the human race
23:42:29 <lispy> edwardk: did you know that ghc mangles newlines so in codepage 65001 there is no guarantee that it will actually output correctly?
23:42:57 <cmccann> lispy: unfortunately there are not very many people who understand arcane windows magic and enjoy working with it in their free time for open source projects
23:43:18 <edwardk> mm_freak: the main thing in it that has been heavily used is the quaternion code. i bothered to get all the branch cut craziness right for esoteric trigonometric operators nobody uses, but acowley has been using it quite a bit lately in robotics stuff, so hopefully most of the issues have been shaken out
23:43:28 <lispy> edwardk: http://hackage.haskell.org/trac/ghc/ticket/4471
23:43:47 <edwardk> lispy: you aren't encouraging me ;)
23:44:08 <memand> cmccann: And those that do has likely gone insane or senile in the process of learning :)
23:44:16 <lispy> edwardk: I do what I can :)
23:44:28 <memand> Ok, enough anti windoze rant from my side for now :P
23:44:47 <mm_freak> edwardk: what's the minimal complete definition of Metric?
23:45:34 <lispy> memand: I know where you're coming from, but at the same time wouldn't you like for your colleagues (potential employers?) that use windows to be more willing to embrace haskell?
23:45:34 * cmccann has roughly 0 desire to do any windows development outside of things that are supported out-of-the-box in recent versions of Visual Studio
23:46:01 <lispy> cmccann: speaking of which, I wish ghc could be compiled with visual studio...
23:46:10 <edwardk> lispy: that bug makes me sad
23:46:16 <edwardk> mm_freak: not sure ;)
23:46:20 <mm_freak> edwardk: nevermind, i just got the idea to look at the source code =)
23:46:36 <mm_freak> edwardk: any <<loop>>s i should be aware of, if i don't implement the Metric instance completely?  SCNR ;)
23:46:39 <edwardk> mm_freak: its a bit of a frankenstein class for whatever we needed
23:46:47 <lispy> edwardk: reading that bugs makes me think that the RTS's attempts to do the encoding/decoding are actually part of the problem.
23:46:50 <oio> i think persistent data strcutures in haskell it not for newbies so maybe later ;D
23:47:10 <mm_freak> oio: "persistent" in what sense?
23:47:31 <mm_freak> oio: in-RAM-and-not-garbage-collected?
23:47:44 <oio> yes  Linked lists
23:47:48 <memand> lispy: Well since I don't know anything about haskell as of yet, I can't really answer that... On the other hand, I hope for my future employers to be flexible enough to let me use my own computer for work :)
23:48:48 <lispy> memand: In my experience, it really depends on the type of employer. If they expect everyone to use visual studio it can get tricky :)
23:48:52 <M30W> x -: f = f x  @ lyah. x & f = f x @ lenses
23:48:53 <M30W> Heh
23:49:08 <memand> Hi M30W
23:49:17 <M30W> Hey memand :)
23:49:27 <mm_freak> oio: let's say you want to write a function that asks the user to enter a line on stdin…  it then displays all so far entered lines in reversed order…  is that a helpful example?
23:49:50 <elliott> oio: All standard data structures in Haskell are persistent.
23:49:54 <elliott> (FSVO standard.)
23:50:00 <oio> yes but how?
23:50:12 <mm_freak> oio: did you answer elliott or me?
23:50:35 <edwardk> lispy: M30W : the x -: f definition in lyah doesn't really fit the style of the definitions in lens, its longer, and it doesn't 'read' off the screen well to someone who doesn't already know what it means
23:50:48 <memand> lispy: I don't have any experience in the working field yet (I'm 21 and still learning) but I don't see why they should be that concervative about IDE's
23:50:54 <oio> y ou
23:51:01 <lispy> edwardk: that bug I linked you to, caused me to write a patch for agda that just forces stdout to be utf8 :( It works but it's not what we should be doing.
23:51:16 <edwardk> lispy: filed that on our internal bug tracker just to be safe
23:51:21 <M30W> edwardk: :P Why hasn't lyah been updated to & instead so it makes sense as the lense already exists.
23:51:41 <edwardk> M30W: silly physical books
23:51:46 <mm_freak> oio: let's work this out together…  that program is a function…  the function takes the list of past inputs, prints it and then asks the user for another line…  it then calls itself with that line prepended…  does that make sense conceptually?
23:51:58 <M30W> Indeed, but the online copy could be patched.
23:52:01 <edwardk> i don't see why miran hasn't just issued a recall for all those LYAH books and fixed the problem already
23:52:14 <lispy> edwardk: have you tried using using import System.IO; hSetEncoding stdout utf8 ?
23:52:23 <edwardk> lispy: no
23:52:51 <edwardk> with the doctest stuff it may be harder because we're not the process printing
23:53:06 <lispy> ah, yeah depends on the error
23:53:18 <lispy> agda was throwing an exception for all unicode characters when doing output
23:53:20 <oio> cant the list live in then ram? and new lists are linked?
23:53:27 <mm_freak> never learn linear algebra from physics books!
23:53:28 <edwardk> we were getting that too
23:53:33 <edwardk> this solved both issues for us
23:53:44 <edwardk> but i'll note that possible fix in case this comes back up
23:53:56 <mm_freak> oio: it does live in RAM, but you as the haskell programmer don't care about that!
23:54:07 <lispy> memand: for product based companies the details of the toolchain used really matter. When I worked at a product company we shipped for windows and we had to get everything working in specific (sometimes old!) versions of visual studio.
23:54:36 <mm_freak> oio: in haskell you don't express RAM operations…  you express data relations
23:54:54 <memand> lispy: oh dear
23:55:06 <lispy> memand: my last unsolicited advice for today is: get at least a masters before entering the job search :)
23:55:23 <M30W> Is there any database for haskell that basicly takes any type and stores it in a binary file to be later read from with keys/queries instead of using sql to work with an existing database not written in haskell.
23:55:24 <memand> lispy: I'm working on that ;)
23:55:32 <mm_freak> M30W: acid-state
23:55:33 <lispy> excellent
23:55:36 <oio> oookk so is not possible or what?
23:55:48 <M30W> mm_freak: Ah yes; remember you telling me about that :D
23:55:56 * lispy is glad it's only 5 min till midnight, he feels other unsolicited advice comming on ;)
23:56:02 <mm_freak> oio: what?
23:56:17 <shachaf> lispy: Please, give me some unsolicited advice!
23:56:29 <memand> lispy: :D all ears :D
23:56:32 * shachaf casts the immunity spell.
23:56:51 <edwardk> i think why we haven't seen the 65001 issue is we haven't tried it with a ttf font or something
23:56:57 <pdxleif> Math question: If you have a commutative monoid or semigroup or something, and then you add an inverse for each element - can you assume the group is  abelian, too?
23:57:07 <mm_freak> M30W: interoperability with non-haskell programs could be difficult though
23:57:30 <edwardk> the job search became a lot easier after binging through degrees
23:57:49 <mm_freak> pdxleif: yes
23:58:06 <edwardk> pdxleif: yes, you can do the proof trivially, by commuting in the original monoid
23:58:14 <pdxleif> lispy: Why get a postgrad before entering job search?
23:58:41 <M30W> mm_freak: over tcp? Basicly just parsing/decoding and encoding ?
23:58:53 <M30W> Not too difficult.
23:58:54 <mm_freak> M30W: over TCP it works of course
23:59:03 <mm_freak> i thought you wanted to parse the raw binary files from non-haskell
23:59:23 <M30W> Oh no.
23:59:36 <M30W> But that would be difficult :)
23:59:51 <mm_freak> yes, because you have text formats as well ;)
