00:01:10 * hackagebot algebra 3.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-3.1 (EdwardKmett)
00:01:12 * hackagebot heaps 0.2.3 - Asymptotically optimal Brodal/Okasaki heaps.  http://hackage.haskell.org/package/heaps-0.2.3 (EdwardKmett)
00:03:42 <tac> ReaderT was the way to go
00:05:49 <Moggle> Doing a powerset with monads is black magic and now I have to reread this entire page
00:05:56 <Moggle> because it's obvious I don't understand how it works
00:07:04 <tac> Moggle: it only works because it is equal to a function that obviously works
00:07:07 <tac> and no other reason
00:07:25 <tac> Be angered, not dazzled, by Haskell one-liners
00:08:00 <Moggle> I prefer to by mystified then eagerly figure out why it works :P
00:08:09 <Moggle> > filterM (\x -> [True, False]) [1,2,3]
00:08:10 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
00:08:15 <Moggle> MAGIC.
00:08:52 <tac> @src filterM
00:08:52 <lambdabot> Source not found. Just what do you think you're doing Dave?
00:10:15 <tac> @type filterM
00:10:17 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
00:11:00 <djcoin> tac: why does one should be angered with one liner ? It makes code hard to read ?
00:11:00 <tac> filterM p (x : xs) = do answer <- p x; rest <- filter p xs; if answer then return (x : rest) else return rest
00:11:02 <tac> more or less
00:11:11 * hackagebot representable-profunctors 3.2 - This package has been absorbed into profunctor-extras.  http://hackage.haskell.org/package/representable-profunctors-3.2 (EdwardKmett)
00:11:40 <tac> The trick is in the fact that each <- causes the universe to split
00:12:15 <tac> So you go through a universe where for each element in the input list, you map both True and False to it
00:13:00 <tac> You end up with something like "all possible lists of Bool" of the same length as the input
00:13:10 <Lethalman> > filterM (\x -> [True, True]) [1,2,3]
00:13:11 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
00:13:35 <tac> > filterM (\x -> [True, True, False]) [0, 1]
00:13:36 <lambdabot>   [[0,1],[0,1],[0],[0,1],[0,1],[0],[1],[1],[]]
00:13:41 <Lethalman> \o/
00:14:18 <tac> "filter" is a really bad name for the action in the list monad
00:14:40 <tgehr> why?
00:14:42 <tac> Most monad combinators act very differently on list types
00:15:49 <Lethalman> > filterM (\x -> Just True) [1,2,3]
00:15:51 <lambdabot>   Just [1,2,3]
00:15:58 <Lethalman> > filterM (\x -> Nothing) [1,2,3]
00:15:59 <lambdabot>   Nothing
00:16:13 <sw2wolf> :t (\x -> [True, False])
00:16:14 <lambdabot> t -> [Bool]
00:16:33 <tgehr> > filterM (\x -> [True]) [1,2,3]
00:16:34 <sw2wolf> :t (\x -> [True, False]) 1
00:16:34 <lambdabot>   [[1,2,3]]
00:16:35 <lambdabot> [Bool]
00:16:46 <sw2wolf> > (\x -> [True, False]) 1
00:16:47 <lambdabot>   [True,False]
00:16:51 <tgehr> > filterM (\x -> []) [1,2,3]
00:16:52 <lambdabot>   []
00:16:58 <tgehr> same thing
00:17:47 <tac> It makes total sense if you think about things categorically.
00:18:02 <sw2wolf> the name "filter" is NOT appropriate in such a situation
00:18:15 <tgehr> what name would be appropriate?
00:18:16 <kamatsu> does haskell-src-exts support datakinds?
00:18:18 <tac> However, category theory is full of ways to transport ideas to places their names don't necessarily belong
00:18:21 <Nereid> sure it is.
00:18:28 <Nereid> return . filter f = filterM (return f)
00:18:35 <tgehr> names are insignificant
00:19:01 <sp3ctum> haha
00:19:41 <tac> Names are only insignificant as you still end up with the same results.
00:19:52 <tgehr> ever tried to do beta reduction in a lambda calculus with significant names? :P
00:19:57 <tac> Whether or not it would take a programmer an hour longer to write the code to get those results......
00:20:17 <Nereid> er, filterM (return . f)
00:20:58 <sw2wolf> 1 -> filter -> [True, False]  ambiguous ?
00:22:55 <tgehr> whats a 1 -> filter -> [True,False] ?
00:23:07 <sw2wolf> > filter (> 3) [1..5]
00:23:09 <lambdabot>   [4,5]
00:23:20 <sw2wolf> it is clear
00:24:23 <Nereid> > filterM ((>3) . return) [1..5]
00:24:24 <lambdabot>   Couldn't match expected type `m0 GHC.Types.Bool'
00:24:24 <lambdabot>              with actual t...
00:24:28 <Nereid> I was expecting that.
00:24:33 <Nereid> > filterM (return . (>3)) [1..5]
00:24:35 <lambdabot>   No instance for (GHC.Show.Show (m0 [a0]))
00:24:35 <lambdabot>    arising from a use of `M665703...
00:24:39 <Nereid> that too.
00:24:57 <Nereid> > filterM ((return :: a -> [a]) . (>3)) [1..5]
00:24:59 <lambdabot>   [[4,5]]
00:25:03 <Nereid> > filterM ((return :: a -> Maybe a) . (>3)) [1..5]
00:25:05 <lambdabot>   Just [4,5]
00:26:58 <tgehr> > mapM (\x->[True,False]) [1,2,3]
00:26:59 <lambdabot>   [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[F...
00:34:18 <epta> How can I lift Maybe outside the List? [Maybe a] → Maybe [a]
00:34:40 <Nereid> catMaybes
00:34:44 <srhb> @hoogle [Maybe a] -> Maybe [a]
00:34:44 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
00:34:44 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
00:34:44 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
00:34:46 <Nereid> oh wait.
00:34:47 <Nereid> wrong way.
00:34:55 <srhb> Nope, that's correct.
00:35:03 <Nereid> oh right.
00:35:10 <Nereid> except not Maybe [a].
00:35:14 <srhb> Yeah.
00:35:22 <Nereid> > runWriter (filterM (\x -> let p = odd x in unless p (tell [x]) >> return p) [1..10::Int]) -- I don't know what the point of this is.
00:35:24 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
00:35:44 <epta> srhb: sequence is ok, thanks
00:35:44 <elliott> epta: sequence
00:35:46 <Nereid> it's bad too.
00:36:06 <Nereid> does sequence do what you want?
00:36:13 <Nereid> > sequence [Just 1, Nothing, Just 2]
00:36:14 <lambdabot>   Nothing
00:36:18 <Nereid> > sequence [Just 1, Just 2]
00:36:19 <lambdabot>   Just [1,2]
00:36:24 <srhb> Doubtful.
00:36:28 <Nereid> > catMaybes [Just 1, Nothing, Just 2]
00:36:29 <lambdabot>   [1,2]
00:36:42 <epta> Nereid: yeah, exactly
00:36:50 <Nereid> > fix sequence
00:36:53 <lambdabot>   mueval-core: Time limit exceeded
00:36:55 <Nereid> :v
00:37:11 <Nereid> > iterate sequence [[]]
00:37:12 <lambdabot>   [[[]],[],[[]],[],[[]],[],[[]],[],[[]],[],[[]],[],[[]],[],[[]],[],[[]],[],[[...
00:37:21 <Nereid> > iterate sequence [[1]]
00:37:22 <lambdabot>   [[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[1]],[[...
00:37:27 <Nereid> > iterate sequence [[1,2]]
00:37:28 <lambdabot>   [[[1,2]],[[1],[2]],[[1,2]],[[1],[2]],[[1,2]],[[1],[2]],[[1,2]],[[1],[2]],[[...
00:37:32 <Nereid> aw.
00:37:37 <Nereid> I guess sequence = transpose.
00:37:40 <Nereid> or something.
00:37:46 <srhb> Not quite.
00:37:53 <Nereid> no.
00:38:02 <Nereid> > iterate sequence [[1,2],[3,4]]
00:38:03 <lambdabot>   [[[1,2],[3,4]],[[1,3],[1,4],[2,3],[2,4]],[[1,1,2,2],[1,1,2,4],[1,1,3,2],[1,...
00:38:10 <Nereid> I don't know why I said that.
00:38:23 <srhb> :)
00:38:33 <epta> How can I lift Maybe from  `HashMap Int (Maybe Int)' to `Maybe (HashMap Int Int)' with similar approach?
00:38:50 <srhb> epta: You mean collecting all the justs?
00:39:05 <epta> I mean fail if there even 1 Nothing
00:39:17 <Nereid> use lens.
00:39:23 <srhb> 1) there's probably a lens for that 2) fold.
00:39:36 <Nereid> :p
00:39:57 <epta> Nereid: show me how, this looks like a great example for start using them
00:39:59 <srhb> Lens is becoming this scary monstrosity that is the answer to everything. :P
00:40:27 <edwardk> you can suck a Maybe out of the whole HashMap e.g. Nothing if there are any Nothings in it, just use 'traverse'
00:40:34 <Nereid> yeah.
00:40:35 <edwardk> or rather sequenceA
00:40:43 <edwardk> :t Data.Traversable.sequenceA
00:40:44 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
00:40:44 <Nereid> I forgot it had a Traversable instance.
00:41:08 <edwardk> but yes, there is a lensy way to do all that too, etc.
00:42:06 <Nereid> > sequenceAOf both (Just 1, Just 2)
00:42:08 <lambdabot>   Just (1,2)
00:42:09 <Nereid> > sequenceAOf both (Just 1, Nothing)
00:42:10 <lambdabot>   Nothing
00:43:31 <epta> edwardk: should I continue asking about this «lensy way» here or I'm should continue in #haskell-lens?
01:01:05 <Moggle> oh Learn You A Haskell
01:01:09 <Moggle> "File "best_hs_prog.hs" "main = print (fix error)" "
01:01:11 <Moggle> i laughed :D
01:03:31 <startling> > fix error
01:03:33 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
01:04:49 <tac> @hoogle Control.Monad.Trans.Error
01:04:50 <lambdabot> Control.Monad.Trans.Error module Control.Monad.Trans.Error
01:04:50 <lambdabot> Control.Monad.Trans.Error class Error a
01:04:50 <lambdabot> Control.Monad.Error.Class class Error a
01:06:42 <sp3ctum> lasagna, :D
01:10:20 <tac> Welp, I broke all my ghc
01:10:44 <tac> fucking cabal
01:10:50 <tac> or hackage
01:10:53 <tac> or whoever is to blame
01:14:42 <tac> Probably Yesod....
01:22:11 <gurrdev> do "mu" and "eta" in the CT definition of a monad correspond to anything in the Monad class functions?  Is this a valid angle of approach to understanding Monads?
01:23:38 <c_wraith> yes.
01:24:02 <c_wraith> Not that I know the CT definition of a monad, though.
01:24:05 <c_wraith> IIRC, eta is return
01:24:16 <c_wraith> which part is mu? the natural transformation?
01:24:56 <c_wraith> Oh, there are two natural transformations
01:25:13 <c_wraith> ah.  mu is join
01:25:19 <c_wraith> which isn't part of the type class
01:25:28 <c_wraith> But it can be implemented from (>>=)
01:27:41 <c_wraith> :t return
01:27:42 <lambdabot> Monad m => a -> m a
01:27:46 <c_wraith> :t join
01:27:47 <lambdabot> Monad m => m (m a) -> m a
01:28:07 <tgehr> :t (>>=id)
01:28:08 <lambdabot> Monad m => m (m b) -> m b
01:28:14 <Lethalman> > join [[1,2,3],[4,5,6]]
01:28:16 <lambdabot>   [1,2,3,4,5,6]
01:36:50 <tac> The typeclass is pretty different from the formal definition.
01:37:07 <tac> return and join are the closest to the actual definition
01:37:18 <Nereid> :t \m k -> join (fmap k m)
01:37:19 <lambdabot> (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
01:37:20 <tac> bind is just there to make it look nice for programmers
01:37:31 <tac> oh, and map/fmap/liftM is important there
01:37:39 <gurrdev> @src Maybe.return
01:37:39 <lambdabot> Source not found. Just try something else.
01:37:48 <Nereid> @src Maybe return
01:37:48 <lambdabot> return              = Just
01:38:01 <simpson> Wait, that works?
01:38:07 <gurrdev> @src Maybe join
01:38:07 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:38:19 <Nereid> @src is a pretty dumb thing, it just looks things up in http://code.haskell.org/lambdabot/State/source
01:38:28 <simpson> Ah.
01:38:40 <c_wraith> join isn't a class method anyway
01:38:45 <c_wraith> @src join
01:38:45 <lambdabot> join x =  x >>= id
01:39:00 <startling> Nereid: ugh what
01:39:19 <c_wraith> Or, if you want a more straight-forward version:  join x = do { x' <- x ; x }
01:39:27 <c_wraith> err
01:39:33 <startling> heh
01:39:35 <c_wraith> join x = do { x' <- x ; x' }
01:39:42 <c_wraith> I should have known better than to name it that.
01:40:01 <c_wraith> still, if you desugar that, you'll see why it gets the implementation x >>= id
01:40:17 <Nereid> I wish join was a class method.
01:40:25 <Nereid> it's often easier to implement than >>=
01:42:41 <tac> If I had it my way, it would be all Kleisi categories, everywhere.
01:42:55 <tac> I call it
01:43:08 <Nereid> but kleisli categories are only half the story
01:44:17 <c_wraith> eh?  Which part of being a monad is not captured by kleisli categories?
01:44:52 <Nereid> none, but you're forgetting about the other, equally important category associated to any monad
01:45:05 <Nereid> (the eilenberg-moore category)
01:45:31 <c_wraith> hmm.  I've never heard of it.  can't be equally important, or I'd be ignorant! :)
01:45:56 <Nereid> it's the category of m-algebras. meanwhile, the kleisli category is the category of free m-algebras.
01:50:33 <startling> is there a library somewhere that will let me load separately-compiled plugins?
01:50:55 <c_wraith> depends..  do you have the .hi and .o files around?
01:51:04 <startling> I could.
01:51:35 <c_wraith> the GHC api supports loading them and using them.  The plugins package is nearly that.
01:52:40 <startling> interesting
01:52:47 <c_wraith> I would recommend against using the GHC api directly wherever possible
01:53:08 <c_wraith> Just because it's complex as heck, and changes between ghc versions
01:56:53 <mikeplus64> c_wraith: how would you use the ghc api to e.g. load a function from a .o/.hi?
01:57:08 <mikeplus64> i've only ever seen plugins used, although i could look at its source
01:57:25 <Nereid> exercise: given a kleisli arrow f :: a -> m b, show that g = (>>= f) :: m a -> m b is in fact a m-algebra morphism. (i.e. join . fmap g = g . join)
01:57:41 <Nereid> then show that every such m-algebra morphism arises in this way.
01:58:31 <c_wraith> mikeplus64: I don't know the details.  The GHC api is complex and nearly undocumented.  I'd have to look at the source for ghci and/or plugins
01:59:19 <mikeplus64> hm, ghci sounds like a good start... (plugins works somewhat unreliably for me at least)
02:00:13 <srhb> I'm also interesting in this. I'm pondering writing an IM client in Haskell, but in order for it to be remotely useable, it needs a plugin infrastructure.
02:00:31 <srhb> It seems oddly messy though.
02:01:12 <Lethalman> also, make some dependencies optional
02:01:16 <Lethalman> similar to plugins
02:01:24 <Lethalman> like if package X is available, use it, otherwise not
02:01:26 <Nereid> doesn't using plugins or similar require distributing ghc too? or am I totally mistaken?
02:01:30 <c_wraith> the GHC api is not really a good target for embedded interpreters
02:01:37 <c_wraith> unless your target market is develoeprs
02:01:49 <c_wraith> because it requires all the libraries for GHC be installed
02:01:54 <Lethalman> like loading package X dynamically
02:01:55 <Nereid> yeah
02:01:57 <startling> oh, eh
02:02:15 <Lethalman> is that possible anyhow?
02:02:15 <srhb> Nereid: That sounds plainful.
02:02:27 <srhb> painful*
02:02:41 <startling> someone needs to write a small functional language to embed in haskell.
02:02:59 <srhb> Yeah, I was just about to say that seems like the Haskelly solution. Embed a language.
02:03:29 <Nereid> embed haskell.
02:03:50 <mikeplus64> it would be very cool to be able to write ghc core or very close to it in haskell code, but haskell can get pretty close anyway
02:04:21 <mikeplus64> as close as you'd ever want anyway
02:05:27 <startling> meh, maybe I'll just use lua.
02:05:38 <c_wraith> that's the conclusion everyone reaches
02:05:39 <c_wraith> :)
02:05:50 <mikeplus64> startling: you may as well try plugins
02:06:23 <startling> mikeplus64, I've been staring at the haddocks and I still have no idea how to use it
02:06:57 <mikeplus64> startling: maybe looking at an old version of the haddocks? it has examples
02:07:00 <mikeplus64> http://hackage.haskell.org/packages/archive/plugins/1.5.3.0/doc/html/System-Plugins-Load.html
02:07:30 <mikeplus64> google always seems to find ancient haddocks
02:09:03 <startling> mikeplus64: heh, whoops, missed that one example
02:09:04 <startling> thanks
02:09:18 <srhb> Hackage needs SEO. *nods*
02:09:36 <merijn> I remember some SEO guy offering to help in here, dunno what became of that
02:09:51 <startling> everything other than hackage.haskell.org/package/whatever should be noindex
02:10:31 <startling> or there should be a persistent url to x module from the newest version of y package, with all old versions being noindex
02:11:27 <mikeplus64> i'd have a bad impression of haskell if what i learnt from haddocks was from what google gave me (ie lots of *old* zvon stuff)
02:12:39 <tac> mikeplus64: indeed
02:12:54 <tac> I'm really curious why Hackage isn't #1 result on every search
02:12:54 <tgehr> it is probably a marketing trick to push this 'go' thing
02:13:32 <mikeplus64> surely google would never be ok nevermind koolaid wore off
02:23:05 <srhb> I wonder how many people have written the zvon guy and asked him to take down the Haskell reference.
02:23:08 <srhb> I know I did... :P
02:23:22 <srhb> But mostly I think hackage just needs some optimizations
02:26:16 * hackagebot sym 0.6.1 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.6.1 (AndersClaesson)
02:26:34 <srhb> In the lensy s t a b types, is s source and t target?
02:26:45 <srhb> Or am I jut grasping at straws? ^^
02:29:24 <johnw> s is the source value, from which the 'a' is extracted, I believe
02:29:35 <johnw> and t is the target value, in which the b is embedde
02:29:56 <srhb> Great, something to remember it by. :)
02:30:01 <johnw> so, for a traversal that turns (Int,Int) into (Int,Float), s and t are the tuple types, and a and t are the Int and Float
02:30:16 <srhb> Awesome, thanks.
02:30:22 <johnw> s/a and t/a and b
02:44:17 <lpsmith> Haskell really needs union patterns :-/
02:44:41 <srhb> lpsmith: What are union patterns?
02:45:28 <lpsmith> Patterns that match either case;  and in every language I know of that has them there is also the restriction that all alternatives must bind the same set of variables.
02:45:53 <srhb> Hm, I did not understand that. Can you provide an example?
02:46:12 <mikeplus64> srhb: i think he means something like case x of 1, 2, 3 -> ...
02:46:18 <srhb> Ah.
02:47:05 <lpsmith> E.G.,  I really want to write  case maybe_list of  { Nothing, Just [] -> alt_1;   Just (x:_) -> alt_2 } right now
02:47:48 <srhb> That sounds like redundant use of data structures.
02:47:57 <srhb> If Just [] is no different from Nothing.
02:48:28 <lpsmith> That's what I get back from the API... and no, it just happens that I want to treat them the same in this case
02:48:43 <lpsmith> not that they shouldn't be indistinguishable in all cases
02:49:31 <lpsmith> Another example,   say we have data Exp = Add Exp Exp | Sub Exp Exp | Const Int | Var String
02:49:45 <srhb> Right.
02:49:50 <lpsmith> if you want to find all the variables in an expression,  you might write
02:51:06 <lpsmith> vars exp = case exp of  { Add x y,  Sub x y ->  vars x `union` vars y;  Const _ -> empty;  Var x -> singleton x }
02:51:18 * hackagebot biocore 0.3 - A bioinformatics library  http://hackage.haskell.org/package/biocore-0.3 (KetilMalde)
02:52:18 <tgehr> lpsmith, why don't you just add a mapping to lists of subexpressions and then use filter?
02:52:19 <lpsmith> thus demonstrating the common allowance for binding variables as well,  as long as you bind the same variables with the same types
02:52:41 <srhb> Yep, I understand the issue. I think most of it can be solved by changing what you're casing on, but sure, it would be convenient in some cases
02:52:42 <lpsmith> tgehr, fine
02:52:48 <tgehr> nvm then it helps too
02:52:53 <lpsmith> right :-)
02:52:59 <lpsmith> that's where I was going :)
02:53:19 <tgehr> I didn't get any sleep tonight ;)
02:53:41 <srhb> The proposal is on the Haskell wiki, but not in GHC. You could always throw it in there.
02:53:44 <covi> How can I pattern match a string that starts and ends with a '\\n', and has arbitrary chars in between?
02:53:46 <lpsmith> that's ok,  I've been making silly comments and questions myself lately
02:53:58 <srhb> covi: You can't, if you don't know its length.
02:54:16 <srhb> covi: You'd need at least a guard and a last
02:55:23 <srhb> covi: I assume '\\n' is either '\n' or "\\n"?
02:55:24 <covi> srhb: i see. well, the situation is that, i want to drop the first char and the last char of a string if those two chars are '\\n'. i am very sure, but i nonetheless want to check
02:55:36 <covi> srhb: right, '\n'
02:56:43 <srhb> covi: foo ('\n':t) | last n == '\n' = drop 1 . init $ t
02:56:59 <srhb> covi: Ooops, last t
02:57:26 <srhb> covi: Mind, checking the end of a String is expensive.
02:58:02 <srhb> Urgh, and forget te drop 1
02:58:05 <srhb> Need more coffee.
02:58:19 <srhb> covi: foo ('\n':t) | last n == '\n' = init t
02:58:57 <covi> srhb: cool thanks
03:05:54 <srhb> covi: You really shouldn't use that, but it should give you an idea. :-)
03:08:13 <swi> Hello. I'm a new to haskell and just interested, is there simple way to i.e. replace substring in string with haskell ? Some std library?
03:08:42 <mel-> probably
03:09:13 <swi> i'm sure there is :) but trying to google it i just found some peoples own-written functions
03:09:32 <mel-> swi: http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html
03:09:35 <swi> well, and Data.String.Utls that i can't find in my debian repo :)
03:09:39 <mel-> swi: 'haskell replace substring' got me there
03:09:59 <tgehr> @hoogle String->String->String->String
03:09:59 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
03:09:59 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
03:09:59 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
03:10:03 <mel-> that's probably included in haskell-platform
03:10:04 <srhb> swi: Oftentimes it's easier to just cabal install the relevant package (which will locally install it for your user)
03:10:29 <mel-> srhb: if you have haskell-platform installed, you probably have Data.String.Utils
03:10:57 <swi> oh
03:11:00 <swi> platform!
03:11:05 <srhb> mel-: I don't see it in the platfornm.
03:11:15 <mel-> srhb: have you tried importing it?
03:12:00 <swi> omg how many packages there in platform
03:12:15 <srhb> mel-: You're right. Hm. Why is it not in the docs though...
03:12:21 <srhb> swi: PLenty to get you started. :)
03:12:52 <srhb> swi: It's made to really cover all the basics and then some, and to be a common reference point. It's always good to have.
03:13:13 <swi> while it installing: i'v tried to use HDBC (i.e. with sqlite3) yesterday and dont understand what i must do (in pretty way) with the result of query?
03:13:58 <swi> Perhaps you meant Data.String.UTF8 (from utf8-string-0.3.7)
03:14:00 <swi> hm
03:14:26 <srhb> swi: Are you sure you have the platform installed? I suppose it may be horrible outdated on Debian, but I don't know.
03:14:45 <swi> srhb: i'v installed it from debian sid right now
03:14:49 <srhb> swi: Did you restart ghci?
03:14:52 <swi> UTF string here
03:14:56 <swi> yep
03:15:11 <srhb> Sounds like it's not active then.
03:15:16 <swi> maybe
03:16:56 <srhb> swi: Anyway, you can generally use safeFromSql to convert an SqlValue to a Haskell value.
03:17:23 <swi> srhb: found it. it's in -missingh package :)
03:19:56 <swi> srhb: done with String.Utils. Thanks a lot. About sql  - i mean not how to convert but.. em.. how to process with resultset. I mean in python (i.e.) i do something like 'for row in quary.fetchall(): print row[0], row[1]'
03:20:44 <srhb> swi: So if you have say a list of SqlValues you could map your function that deals with it over that list
03:20:54 <swi> mapM_ ?
03:20:56 <srhb> swi: It would be easier to deal with a concrete example
03:21:02 <srhb> swi: yes, if you just wanted to print.
03:22:02 <swi> and, if i understand right, resultset is a list of lists then i can i.e. map it to some function withc convert to haskell value and do something with them ?
03:22:14 <srhb> That's right.
03:22:18 <srhb> It's all in the types. :)
03:22:26 <swi> oooh
03:22:51 <srhb> For instance, fetchAllRows :: Statement -> IO [[SqlValue]]
03:23:27 <swi> ok :)
03:24:07 <swi> btw, is haskell is good for.. participating with sql at all ?
03:24:48 <srhb> Sure, why not.
03:24:57 <swi> i mean speed, correctness of result's processing and converting data to some formats (ie json, html, xml) ?
03:25:32 <lpsmith> swi:  you might consider sqlite-simple instead
03:25:35 <srhb> Especially correctness is a strength since if you don't do silly stuff, the types generally ensure that you handle all cases.
03:25:51 <srhb> swi: But yes, all of the above, fsvo of them. ;)
03:26:06 <lpsmith> swi, I don't know that it's "good" at this point,  but things have gotten a lot better on the SQL front lately
03:26:10 <swi> lpsmith: i don use sqlite in real work :) mostly mysql,pgsql and sybase
03:26:19 <lpsmith> ahh
03:26:31 <swi> but i saw a -simple too
03:26:43 <lpsmith> well, there is mysql-simple and pgsql-simple,  but unfortunately not an sybase-simple or obdc-simple
03:27:00 <swi> lpsmith: so for sybase i can use hdbc odbc ?
03:27:24 <lpsmith> HDBC seems to be your best option at this point, though there is a lot I don't like about it
03:27:47 <lpsmith> swi, haven't used it myself, but that's what most people use who interface to commercial DB offerings
03:28:09 <swi> well, i just found on internet that haskelldb is not good and droped a little, so may be yes, hdbc my choice
03:28:28 <aristid> swi: haskelldb not good? source?
03:28:28 <lpsmith> I'm not sure that's fair assessment
03:28:52 <srhb> I think HaskellDB is quite awesome. :P
03:28:56 <lpsmith> It probably depends on what you are doing,   but people I respect like HaskellDB a lot
03:29:00 <lpsmith> I haven't used it myself
03:29:21 <swi> aristid: well... livejournal or some blog.. maybe it' not right :)
03:29:36 <srhb> It's surely better than writing SQL statements by hand.
03:29:59 <aristid> i haven't used either, but the way i understand it, the -simple packages are quite low-level, and haskelldb is way more high-level. perhaps it is more problematic in a number of ways, but i think the high-level nature should be appreciable
03:30:03 <swi> srhb: you mean haskelldb is somekind of orm ?
03:30:27 <aristid> swi: no, it's more of a relational-algebra-to-SQL translation thingie
03:30:28 <lpsmith> Not exactly
03:30:30 <srhb> swi: It goes deeper, it actually encodes the relational algebra and allows you to express queries in a type safe manner
03:30:36 <srhb> In Haskell!
03:30:39 * Lethalman disagrees on saying "better than writing statements by hand"
03:30:45 <srhb> Lethalman: Why?
03:30:56 <swi> Lethalman: +1
03:31:03 <swi> sometimes orm's sucks
03:31:14 <srhb> swi: That's not what it is, don't listen to Lethalman just yet. :P
03:31:14 <statusfailed> I have the same problem as this guy (http://hpaste.org/report/75694) when trying to build snap on GHC 7.4 on Ubuntu
03:31:18 <statusfailed> is there an easy way around it?
03:31:18 <Lethalman> writing sql is fine, it's just that input must be sanitized, and people might want to use multiple databases
03:31:19 * hackagebot biocore 0.3.1 - A bioinformatics library  http://hackage.haskell.org/package/biocore-0.3.1 (KetilMalde)
03:31:21 * hackagebot biosff 0.3.2 - Library and executables for working with SFF files  http://hackage.haskell.org/package/biosff-0.3.2 (KetilMalde)
03:31:23 <lpsmith> I've heard that HaskellDB has had some performance problems,  that's in part why esqueleto exists
03:31:31 <Jafet> If your data isn't relational, don't use a relational database.
03:31:33 <srhb> Lethalman: fine, then why use Haskell at all, just go C. :)
03:31:40 <Jafet> Use Microsoft Excel or something.
03:31:41 <Lethalman> srhb, that's another pointless statement
03:31:49 <aristid> lpsmith: as far as i know those particular performance problems are due to mysql sucking tho
03:31:50 <Lethalman> a common place like any other
03:31:53 <srhb> Lethalman: Why would you not opt for extra type safety?
03:32:01 <Lethalman> srhb, never said not
03:32:01 <lpsmith> aristid, that may be
03:32:08 <swi> aristid: mysql is free - that's the answer :)
03:32:16 <aristid> swi: postgresql is free too.
03:32:16 <srhb> Lethalman: That's surely what you are doing if you prefer writing SQL by hand.
03:32:18 <lpsmith> postgresql is free to
03:32:33 <swi> aristid: it's joke - a '42' answer to 'why mysql....' :)
03:32:41 <Lethalman> srhb, you are also 90% of the time limiting the possibilities of a database by not writing sql by hand
03:32:47 <Lethalman> but that depends on the framework of course
03:32:51 <lpsmith> postgresql is by far the least sucky SQL I've personally dealt with
03:32:58 <srhb> Lethalman: We're talking about HaskellDB
03:33:06 <aristid> Lethalman: i think haskelldb especially lacks support for recursive queries
03:33:22 <lpsmith> And SQL has some nice things about it,  but ugh that's buried under a lot of suckiness and incidental complexity
03:33:34 <donri> it's not a very good joke. lots of free software does not suck.
03:33:38 <swi> is haskelldb knows about subquery, joins and unions ?
03:33:51 <Jafet> postgresql is free, mysql is cheap
03:33:58 <donri> lol
03:34:14 <lpsmith> and postgresql performs pretty well, if you know what you are doing
03:34:16 <srhb> I don't see how lacking features means you have to opt out of the entire package.
03:34:26 <srhb> Where it works, it still gives you better safety.
03:34:33 <swi> lpsmith: agree. mysql is good for simple things
03:34:34 <aristid> swi: i believe it does, although it uses different names for them.
03:34:45 <statusfailed> lpsmith: oh, you wrote postgresql-simple, right?
03:34:46 <donri> i read that postgre has comparable performance these days, i think
03:34:50 <lpsmith> I've used mysql, I don't much care for it
03:34:53 <swi> aristid: i mean a resulting sql send to server :)
03:35:04 <lpsmith> statusfailed, as much as any one person has written postgresql-simple
03:35:19 <statusfailed> haha, fair enough :)
03:35:47 <Martty_> sql psh..
03:35:51 <aristid> swi: here's an introduction to haskelldb by chrisdone: http://chrisdone.com/posts/haskelldb-tutorial
03:35:53 * swi .o( a pretty good and kind community, as i'v read )
03:36:03 <Lethalman> srhb, as long as a framework is able to satisfy all the requirements without writing sql statements, that's good... otherwise it's just a mess like in any other language
03:36:08 <swi> aristid: thanks a lot :)
03:36:16 <srhb> Lethalman: I think you're talking out your arse.
03:36:19 <srhb> Lethalman: :P
03:36:25 <lpsmith> Martty_, sql often beats having to manage indexes manually.
03:36:37 <Lethalman> srhb, it's experience, don't know haskelldb though
03:37:12 <srhb> Lethalman: Fine, I just don't think my experience from other languages have carried over very well to Haskell. For instance, I would never mix one Python web framework with another.
03:37:17 <lpsmith> I mean,  seperating data specification from the access method is the big selling point of SQL, and is largely why it's been so successful.
03:37:17 <donri> lpsmith: there's indexed data structures though
03:38:03 <swi> sometimes indexes is the way to slow processing :(
03:38:04 <lpsmith> donri, more than that;  you can add and remove and tweak indexes after the fact without having to change your code that uses it
03:38:06 <Lethalman> srhb, it's just that ORM is a failing concept, and fortunately that may not be the case in haskell...
03:38:16 <Jafet> "Ah got twenny years' experience at them slot machines. Never won ah single time though."
03:38:23 <lpsmith> swi, tis true
03:38:24 <donri> srhb: mixing web frameworks is probably not a great idea in any language...? but mixing their libraries might be fine (in python too)
03:38:28 <Lethalman> I'd be interested in trying to use a database in haskell soon
03:38:46 <srhb> donri: They're ofte extremely closely tied though, and may depend on the "base" library at all times.
03:38:48 <donri> lpsmith: same with indexed data structures (ixset, HiggsSet, data-store, tables)
03:39:08 <swi> lpsmith: i'm working in stock company, so.. they shot our servers like a huricane evey single days
03:39:14 <donri> srhb: depends which web frameworks we're talking about :)
03:39:27 <lpsmith> Persistent is the closest thing Haskell has to an ORM,  HaskellDB isn't really an ORM
03:39:29 <srhb> donri: Sure, just talking about the general experience. Haskell tends to lend more to mix-and-match.
03:39:44 <swi> lpsmith: persistent is a part of yesoda ?
03:40:05 <lpsmith> yep
03:40:16 * swi want to try it.. someday
03:40:25 <donri> srhb: sure. if nothing else, it tends to be easier in haskell to integrate libraries by following the types, etc.
03:40:46 <srhb> donri: Right. That is a big deal. :)
03:41:05 <donri> srhb: haskell code tends to be more reusable by default, but there are strongly decoupled libraries in python etc that can be mix-matched rather well too.
03:41:08 <swi> or, btw. how to do type conversion in haskell ?
03:41:39 <srhb> swi: On a case by case basis
03:41:48 <srhb> swi: To ensure you're doing it safely. :)
03:42:01 <swi> srhb: well. in my case it' most of 'string' to 'float' or 'int' or 'date' conversion
03:42:08 <srhb> swi: Look up reads
03:42:15 <swi> ok
03:42:23 <donri> > read "5" + 5
03:42:24 <lambdabot>   10
03:42:32 <srhb> (But don't do that. :-))
03:42:49 <srhb> > read "foo" + 5
03:42:50 <lambdabot>   *Exception: Prelude.read: no parse
03:42:53 <srhb> Oops.
03:43:09 <donri> fuuu-
03:43:12 <srhb> :D
03:43:18 <srhb> Someone wrote a nice reads demo
03:43:23 <donri> at least the error message is really helpful
03:43:32 <swi> i.e. i need read cvs file, parse it and put values (date,value) to db. but date there is may be in some format not accepted by db and float may use , instead of . as a separator
03:43:41 <mysticc> for hunit, is there a function for [Assertion] -> Assertion ?
03:43:43 <donri> @hackage cassava
03:43:44 <lambdabot> http://hackage.haskell.org/package/cassava
03:43:45 <srhb> That sounds like the job for a csv library or parsec
03:44:18 <donri> mysticc: sequence
03:44:40 <donri> mysticc: sequence_, rather
03:44:43 <swi> srhb: all the things allready done for us :)
03:44:51 <srhb> swi: :)
03:45:05 <donri> mysticc: Assertion is just IO ()
03:45:35 * swi . o( that what love for map and lambda of simple python lovers do -> go to haskell, dude )
03:47:21 <mysticc> donri: Thanks, I found after looking the type of Assertion
03:48:50 <swi> thanks a lot, everyone :) go to read next chapter of RealWorldHaskell :)
04:08:07 <mikeplus64> is there a typeclass to describe a function :: m a -> a?
04:10:06 <mikeplus64> > foldr1 const (Just 1)
04:10:07 <lambdabot>   Couldn't match expected type `[a0]'
04:10:07 <lambdabot>              with actual type `Data.May...
04:10:12 <mikeplus64> > Data.Foldable.foldr1 const (Just 1)
04:10:14 <lambdabot>   1
04:10:15 <mikeplus64> (yes there is!)
04:10:50 <bford> mikeplus64, extract? http://hackage.haskell.org/packages/archive/comonad/3.0.0.2/doc/html/Control-Comonad.html#v:extract
04:11:20 <mikeplus64> aha!
04:11:21 * hackagebot rand-vars 0.1 - Random variable library, with Functor, Applicative and Monad instances.  http://hackage.haskell.org/package/rand-vars-0.1 (RomainEdelmann)
04:11:35 <mikeplus64> bford: thanks
04:12:06 <mikeplus64> my worry is that barely anything uses or has an instance for comonad (or am i mistaken?)
04:14:05 <elliott> as far as comonad packages go, comonad is pretty common :P
04:14:16 <elliott> we use it a lot in lens!
04:19:33 <mikeplus64> is there some way to search for instances on hackage?
04:19:45 <donri> mikeplus64: also Data.Foldable.fold for some cases
04:21:36 <mm_freak_> say i have a list and a set of lists, and i want to display the shortest unique prefix of the list…  i have an O(n) algorithm, where n is the length of the list, to do that
04:21:41 <mm_freak_> what is that tree called?
04:25:42 * Jafet gives mm_freak a sequitur
04:31:30 <epta> How can I update HashMap with list of values [(k,v)] and insertWithKey method?
04:33:21 <fabjan> epta: using fold, see http://www.haskell.org/haskellwiki/Fold
04:33:50 <Jafet> :t foldr (uncurry M.insert)
04:33:51 <lambdabot> Ord a => M.Map a b -> [(a, b)] -> M.Map a b
04:37:14 <donri> or use fromList and union
04:37:25 <srhb> That seems the more declarative way.
04:37:54 <epta> foldl (uncurry $ M.insertWith f) will be enough
04:49:20 <M30W> Hmmmm.
04:52:15 <mercer> > (3, "foo") >>= (\x -> return (1, x))
04:52:16 <lambdabot>   No instance for (GHC.Base.Monad ((,) t0))
04:52:16 <lambdabot>    arising from a use of `e_131'
04:52:16 <lambdabot> ...
04:52:24 <mercer> :t ((3, "foo") >>=)
04:52:25 <lambdabot> (Monad ((,) t), Num t) => ([Char] -> (t, b)) -> (t, b)
04:52:30 <mercer> what is going on in here?
04:52:58 <Taneb> 3 needs to be a monoid
04:53:43 <ceii> no, actually there's no monad instance for pairs
04:53:52 <hpaste> “Anonymous Coward” annotated “converting NFA to DFA with power set construction” with “converting NFA to DFA with power set construction (annotation)” at http://hpaste.org/40461#a80422
04:54:24 <Taneb> Really?
04:54:33 <mercer> what is with the type for ((3, "foo" >>=) then
04:54:49 <mercer> ((3, "foo") >>=) even
04:55:24 <Lethalman> :t return 1
04:55:26 <lambdabot> (Monad m, Num a) => m a
04:55:31 <Taneb> It is saying that if that isa monad it would work
04:55:33 <ceii> > ("aaa",3) >> ("bbb",3)
04:55:34 <lambdabot>   No instance for (GHC.Base.Monad ((,) [GHC.Types.Char]))
04:55:34 <lambdabot>    arising from a u...
04:56:10 <ceii> mercer: the type (a,b) is also written (,) a b, so the constraint in the type says that (,) a needs to be a monad
04:56:13 <Lethalman> > (1,2) >>= return . id
04:56:15 <lambdabot>   No instance for (GHC.Base.Monad ((,) t0))
04:56:15 <lambdabot>    arising from a use of `e_112'
04:56:15 <lambdabot> ...
04:56:32 <Lethalman> > ((1,2) >>= return . id) :: Just a
04:56:33 <lambdabot>   Not in scope: type constructor or class `Just'
04:56:37 <Lethalman> > ((1,2) >>= return . id) :: Maybe a
04:56:39 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe'
04:56:39 <lambdabot>              with actual ty...
04:56:56 * Lethalman gives up :P
04:57:08 <Lethalman> isn't it because there's no monad information in the context?
04:57:34 <Lethalman> > ((1,2) >>= return . id) :: Maybe (Int, Int)
04:57:35 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe'
04:57:35 <lambdabot>              with actual ty...
04:58:14 <tgehr> > (Just (1,2) >>= return . id) :: Maybe (Int, Int)
04:58:16 <lambdabot>   Just (1,2)
04:58:42 <Taneb> > (Sum 1, 2) >>= return
04:58:43 <lambdabot>   No instance for (GHC.Base.Monad ((,) (Data.Monoid.Sum a0)))
04:58:43 <lambdabot>    arising from...
05:01:23 * hackagebot fields-json 0.2.1 - Abusing monadic syntax JSON objects generation.  http://hackage.haskell.org/package/fields-json-0.2.1 (MariuszRak)
05:02:29 <srhb> I don't even know what a tuple monad would be.
05:02:40 <srhb> I mean, you need something more than that.
05:02:52 <Taneb> Kinda like the Writer monad
05:03:09 <srhb> Or the state monad.
05:03:34 <Taneb> State is a different shape
05:03:50 <srhb> Meh, just wrapped a bit. :P
05:04:54 <Taneb> (a, b) >>= f = let (a', b') = f a in (a <> a', b')
05:05:36 <Taneb> return = (,) mempty
05:06:45 <srhb> why the mappend
05:07:31 <Taneb> To make it better. Wrapping it in Last gets the not-monoidy equivalent
05:08:21 <srhb> I can't see that it's a monad, so I guess I'll trust you :P
05:08:57 <Taneb> It is equivalent to the Writer monad
05:14:55 <srhb> Taneb: I must suck, I keep getting (a,b) >>= return = (a <> mempty,a)
05:15:04 <niraj_> best resource to learn haskell
05:15:31 <srhb> niraj_: Are you looking or calling us that? If the former, try LYAH, if the latter, thank you! :-)
05:15:36 * M30W stares at HashSet's docs...
05:16:38 <Taneb> (a, b) >>= return = (a <> mempty, b)
05:16:47 <niraj_> thnks srhb
05:16:54 <srhb> Taneb: I know it SHOULD be that. :P
05:17:00 <niraj_> i have funtion programming in my course
05:17:12 <niraj_> so I want to learn haskell
05:17:18 <srhb> niraj_: Great :)
05:17:20 <niraj_> srry for my bad english
05:21:16 <hpaste> srhb pasted “Where did I fuck up?” at http://hpaste.org/80424
05:21:29 <srhb> Taneb: ^^^ Could you take a quick glance for me? :-)
05:21:33 <M30W> Okay.. I don't really know how to ask this without code so here.. http://ix.io/3TH+3TI+3TJ+3TK/ How would I go about adding the two HashSet's (current and what we're adding)?
05:21:45 <Taneb> Line 5
05:22:17 <Taneb> Should say (,) mempty b
05:23:10 <srhb> Huh...
05:23:31 <srhb> With this definition? (a, b) >>= f = let (a', b') = f a in (a <> a', b')
05:23:33 <johnw> did edwardk update everything of his today?
05:23:42 <srhb> johnw: All signs point to yes
05:23:48 <Taneb> ack, that's my fault
05:23:56 <srhb> Taneb: Thanks, so it wasn't a monad. :P
05:23:57 <johnw> heh, out of 81 package updates, I think his are 98% of them
05:24:02 <Taneb> I gave you a bad definition
05:24:10 <srhb> I was really having trouble with right identity. :P
05:24:49 <srhb> As long as I'm not insane yet, I'm happy. :-0
05:25:10 <M30W> Couldn't match type `H.HashSet File -> H.HashSet File' with `H.HashSet File'
05:25:14 <M30W> Well......
05:25:21 <M30W> I'm getting somewhere :P
05:25:21 <Taneb> My definition of (>>=) should say  let (a', b')= f b
05:25:56 <M30W> johnw: He had quite a few updates last night. ^_^
05:26:19 <srhb> Taneb: Then it makes sense, thanks. )
05:26:21 <srhb> :)
05:26:25 <M30W> Acturally around 23hrs ago :P
05:26:28 <M30W> Maybe
05:26:34 <srhb> M30W: Looks like you forgot an argument.
05:27:38 <M30W> srhb: http://ix.io/3TH+3TI+3TJ+3TK/
05:27:53 <M30W> Lines 62-67 in focus.
05:28:22 <mm_freak_> i'm encouraging everyone to stop suggesting so many ad hoc solutions on stack overflow…  please teach people to use a compositional style
05:28:57 <M30W> mm_freak_: Example of ad-hoc?
05:29:17 <mm_freak_> M30W: i won't mention anyone/any post specifically
05:29:30 <M30W> mm_freak_: Example of code.
05:29:43 <mm_freak_> M30W: basically almost any explicitly recursive formula
05:30:24 <M30W> You don't like recursion?
05:30:37 <mm_freak_> i love it as a last resort =)
05:30:37 <srhb> M30W: Look at the definition of H.insert
05:30:59 <Taneb> explicit recursion is not recursion
05:31:00 <M30W> srhb: insert :: (Eq a, Hashable a) => a -> HashSet a -> HashSet a
05:31:03 <mm_freak_> M30W: let me show you how i would write chunksOf:
05:31:23 <M30W> srhb: What am I missing?
05:31:23 <mm_freak_> > let chunksOf n = takeWhile (not . null) . map (take n) . iterate (drop n) in chunksOf 3 ['a'..'z']
05:31:25 <lambdabot>   ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
05:31:33 <srhb> M30W: Well you're not using your old hashset at all
05:31:41 <srhb> M30W: Nor are you doing some kind of union between it and the new one
05:32:07 <M30W> srhb: Hmm.
05:32:11 <srhb> M30W: Perhaps what you want is a filesUnion
05:32:29 <M30W> Is what?
05:32:49 <M30W> Oh
05:32:50 <M30W> Yea.
05:32:58 <M30W> srhb: Suggestion code wise? :)
05:33:05 <srhb> M30W: A function that takes a new set and does an atomicModifyIORef
05:33:13 <srhb> Well, I would not have coded this at all like you did...
05:33:23 <srhb> But that function would be a simple fix for you.
05:33:54 <M30W> srhb: Acturally the HashSet and IORef I had mixed help in here to get it to where it is.
05:34:02 <M30W> Think you were online?
05:34:12 <srhb> Yes, I told you not to use IORef, but nevermind :P
05:34:25 <M30W> xD
05:34:29 <srhb> But write that function, you'll be fine.
05:34:46 <M30W> "write that function" I have current errors you want me to make more? O.o
05:34:47 <M30W> Hehe
05:34:53 <srhb> Yes
05:34:59 <srhb> It will be obvious once you've made that function.
05:35:25 * M30W doesn't know where to start with this...
05:35:38 <srhb> M30W: Start by defining its type
05:35:50 * M30W .... doesn't even know that.
05:36:10 <srhb> filesSetUnion :: H.HashSet File -> ServerM ()
05:36:15 <M30W> Ah
05:36:24 <M30W> Was close to what I was about to suggest :)
05:37:03 <M30W> srhb: Wait.... I read "serFiles" Same defintion
05:37:22 <srhb> M30W: Yes, they are almost the same
05:37:39 <srhb> M30W: But the new one has to take a HashSet and join it with the current one
05:37:41 <srhb> Ie. take the union
05:38:21 <mikeplus64> > (fmap pure . extract) (Identity (Just 0)) :: Maybe (Maybe Int)
05:38:22 <lambdabot>   Not in scope: `extract'
05:38:24 <M30W> srhb: This would replace setFiles so why not just rewrite it?
05:38:50 <mikeplus64> > (fmap pure . Data.Foldable.foldr1 const) (Identity (Just 0)) :: Maybe (Maybe Int)
05:38:51 <lambdabot>   Just (Just 0)
05:39:02 <srhb> M30W: Suit yourself. If you're not using setFiles and only want a union function, do that.
05:39:06 <M30W> Ahh. I'm confused.
05:40:14 <M30W> IORef + HashSet /= good with beginning with haskell ;)
05:43:32 <johnw> M30W: I have yet to even use IORef
05:45:04 <M30W> Heh. Well I need it (or alike method like TVar, MVar; but I think IORef will work fine; Multi threading shared variable)
05:45:39 <M30W> srhb: I'm still confused.
05:45:56 <srhb> M30W: Did you get started on the function?
05:46:30 <M30W> srhb: Got the definition that you gave me and was staring at the docs for Data.HashSet's union function.
05:46:54 <srhb> M30W: So you need a function that starts by extracting the IORef. Not the HashSet, but the IORef
05:47:54 <M30W> srhb: You're suggesting atomicIOWrite yea?
05:47:59 <M30W> Or whatever it's called
05:48:05 <srhb> M30W: Not yet, no. You need to know which IORef to write to first, after all :)
05:48:27 <M30W> I look at getFiles and I don't see how to get the IORef it's self?
05:48:37 <M30W> Ah
05:48:41 <M30W> serverFiles e
05:48:41 <srhb> M30W: ask >>= serverFiles -- will get you the IORef
05:49:04 <M30W> Okay.
05:49:15 <M30W> Now I have no context to put that with but this definition.
05:50:36 <M30W> srhb: I have a feeling you know the exact code I'm after. :|
05:50:51 <M30W> More like have it already written down haha.
05:51:54 <S11001001> ah, variables
05:52:29 <srhb> M30W: foo newHash = do { ref <- serverFiles <$> ask; liftIO . atomicModifyIORef ref $ (H.union newHash) }
05:52:33 <srhb> M30W: Or something to that extent
05:53:10 <srhb> Or I think you preferred the ReaderT $ \ref -> ... style
05:53:27 <srhb> Which is fine, too.
05:53:38 <srhb> I guess it's even preferable, I don't know.
05:54:13 <M30W> lift IO . ask serverFiles >>= atomicModiftRef $ (H.union)
05:54:18 <M30W> srhb: That valid?
05:54:42 <M30W> ask serverFiles >>= liftIO . atomicModifyIORef $ (H.union)
05:54:43 <M30W> *
05:55:00 <srhb> liftIO (ask >>= atomicModifyIORef (H.union newHash) . serverFiles) -- I think
05:56:17 <M30W> addFiles hs = ReaderT $ \e -> atomicModiftIORef e (H.union hs) . serverFiles -- ?
05:56:33 <srhb> Almost
05:56:48 <M30W> addFiles hs = ReaderT $ \e -> atomicModifyIORef e (H.union hs) . serverFiles -- ?
05:57:00 <srhb> addFiles hs = ReaderT $ \e 0> atomicModifyIORef (serverFiles e) (H.union hs)
05:57:06 <srhb> remember your environment is NOT the IORef
05:57:14 <srhb> That's what you want to extract from e
05:57:21 <M30W> s/0/-/
05:57:32 <srhb> Right
05:57:35 <M30W> Ah
05:59:48 <M30W>     Couldn't match type `HashSet File' with `(HashSet File, ())'
05:59:54 <M30W> Hmmm
06:00:27 <srhb> Oh right, sorry
06:01:54 <srhb> It's because the type of the modifying function must return a tuple
06:02:21 <M30W> So... method to return x (x,_) ?
06:02:27 <M30W> from *
06:02:49 <srhb> \oldHS -> (oldHS `H.union` hs, ())
06:02:58 <srhb> Or something to that extent.
06:02:59 <M30W> O.o
06:03:52 <srhb> o.O
06:04:35 * M30W doesn't think he was ever this clueless for how to continue with code O.o
06:05:17 <srhb> M30W: :P How does the function look now?
06:05:32 <M30W> Incomplete
06:05:41 <M30W> addFiles hs = ReaderT $ \e -> atomicModifyIORef (serverFiles e) (H.union hs)
06:05:44 <M30W> Still got that :P
06:05:56 <srhb> Change H.union hs to what I wrote
06:06:32 <M30W> addFiles hs = ReaderT $ \e -> atomicModifyIORef (serverFiles e) (\oldHS -> (oldHS `H.union` hs, ()))
06:06:35 <M30W> ))) O.o
06:06:37 <srhb> Yes
06:06:42 <M30W> So many parens
06:06:51 <srhb> Well it's not my fault you're using IORef, is it
06:06:53 <srhb> ;)
06:06:58 <M30W> Turple is fine, () empty.
06:06:59 <M30W> Haha
06:07:10 <srhb> anyway, good, leave that alone now
06:07:16 <M30W> For now *
06:07:17 <M30W> :)
06:07:24 <srhb> You should only have to fix your other code now.
06:07:38 <srhb> addCommand, I mean.
06:09:04 <M30W> Yay dummyadd command works. :D
06:09:11 * M30W brb
06:16:38 <M30W> Back
06:16:55 <M30W> But limited to just ssh :P
06:17:26 <M30W> zsh: locking failed for /home/archey/.logs/zhistory: read-only file system: reading anyway
06:18:14 <M30W> Annoying USB seems to have some instability with crypto ;) After about 10 minutes booted it just dies and is safe to remove the usb cause as far as the os is concerned the filesystem no longer exists :P
06:18:23 <M30W> Well; readonly cached
06:19:01 <M30W> srhb: "You should only have to fix your other code now." Hmm... I did haha.
06:20:23 <M30W> srhb: Wanna have a play with the daemon?
06:20:29 <M30W> #add 2
06:20:29 <M80T-6693> ok
06:20:33 <M30W> :)
06:20:47 <M30W> Ahh
06:22:00 <M30W> Now wont spam here with pong's lol.
06:22:07 <M30W> #ping
06:22:07 <M80T-6814> pong
06:22:11 <M30W> or not..
06:22:37 <M30W> Timeout and if you want srhb join #M80T ;)
06:23:05 <srhb> I better not, I should get stuff done too. :P
06:23:10 <M30W> Haha
06:24:26 <M30W> Bot is a simple zshell script I have a tendency to bridge protocoles to IRC ;) MPD, my daemon (Dldr), etc
06:27:54 <M30W> srhb: How about removing files from the HashSet? -- I can't get the docs open atm. D:
06:29:37 <ocharles> ARGGGGGGHHH. I have wasted another two hours just moving modules around to fix cycles
06:29:51 <ocharles> why must you be so perfect, Haskell, except for this one massive pita :(
06:30:20 <shachaf> I think you mean GHC.
06:30:25 <shachaf> Haskell supports recursive modules just fine.
06:30:31 <srhb> M30W: delete?
06:31:18 <M30W> srhb: delete by fileID
06:31:57 <M30W> Also; is it worth setting type FileID = Integer ?
06:32:54 <srhb> M30W: You're using a HashSet, so you can't easily select something by just its fID
06:33:39 <srhb> M30W: You can use filter though. It's horrible, but then again, using a HashSet here is pretty silly. :)
06:34:25 <HaskellNewcomer> https://gist.github.com/de96c813ef0c976e9d2c is what I have so far, but it's giving similar values for a sequence of size N as a sequence of size N/2. I'm completely lost.
06:34:35 <HaskellNewcomer> Hi, I dunno if anyone here can help or even point me in the right direction, but I'm pulling my hair out trying to figure this out. I'm trying to benchmark various functions of Data.Sequence using Criterion, in particular to show the effect of the size of the sequence on the operations.
06:35:37 <opqdonut> HaskellNewcomer: let half = fst (Seq.splitAt (Seq.length full) full)
06:35:45 <opqdonut> it looks like half is just full
06:35:46 <parcs> ocharles: hs-boot files aren't that bad
06:35:52 <opqdonut> you need a /2 there :)
06:36:21 <ocharles> parcs: they aren't, but i'm completely out of the zone I was previously in now
06:36:56 <parcs> ocharles: but it sounds like instead of using hs-boot files you removed the cycles altogether
06:37:17 <ocharles> parcs: no, I still don't have anything that compiles
06:37:45 <ocharles> i'm throwing away my 'shove it all into one file' approach because that was still not complete
06:38:21 <parcs> oh
06:38:32 <M30W> srhb: instance Hashable File where hashWithSalt s f = Data.Hashable.hashWithSalt s (fileID f)
06:38:45 <M30W> srhb: The HashSet knows how File is Hashable.
06:38:56 <M30W> :)
06:39:33 <srhb> M30W: Yes, which means if you can produce a whole File, you can delete it, retrieve it, whatever
06:39:48 <srhb> M30W: If you can produce only the id, you need to go through the whole set.
06:40:12 <srhb> Oh wait, no, you are hashing on fID?
06:40:35 <M30W> srhb: rmFile :: FileID -> ServerM ()
06:40:46 <M30W> srhb: rmFiles :: [FileID] -> ServerM ()
06:40:58 <srhb> M30W: If it's hashed on fID, yeah, it's easy.
06:41:07 <M30W> srhb: Yes
06:41:19 <M30W> fID -> fileID type FileID now :)
06:41:28 * hackagebot xmonad-extras 0.11 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.11 (DanielWagner)
06:41:45 * M30W wants to click that link but can't D:
06:41:57 <M30W> @tell M30W hackagebot xmonad-extras 0.11 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.11
06:41:57 <lambdabot> You can tell yourself!
06:42:01 <M30W> >_<
06:42:07 <BadKitty> @tell M30W hackagebot xmonad-extras 0.11 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.11
06:42:07 <lambdabot> Consider it noted.
06:42:21 <M30W> Lets hope that sits there and it tells me tomorrow :)
06:42:21 <lambdabot> M30W: You have 1 new message. '/msg lambdabot @messages' to read it.
06:42:48 * M30W could have just used memoserv or save that to a file meh Haha
06:43:22 <HaskellNewcomer> opqdonut: thanks! I can't believe I missed that.
06:43:35 <M30W> srhb: "If it's hashed on fileID, yeah, it's easy." Mind sharing the ease? ;)
06:43:48 <srhb> M30W: Well just make a dummy file with everything but the fileID blank
06:44:20 <M30W> srhb: map (delete) xs
06:44:32 <M30W> srhb: List of ID's
06:44:58 <M30W> srhb: I have dummy files, you see addCommand? :P
06:44:59 <srhb> list of dummy Files with the relevant IDs, but yes, otherwise.
06:45:21 <M30W> Just have to tell it to add them to the list. :P
06:45:23 <srhb> My point is.. All the HashSet functions require their argument to be File, not your file ID.
06:45:38 <M30W> Wait..
06:45:49 <M30W> So I have to delete File not delete FileID ?
06:45:56 <srhb> Yes.
06:46:03 <M30W> So it *doesn't* do the lookup. D:
06:46:05 <M30W> Okay.
06:46:08 <srhb> Yes it does!
06:46:21 <srhb> As long as you supply it with a File { fileID = whatever }
06:46:26 <M30W> Well it does; but it's a double lookup
06:46:30 <srhb> How?
06:46:31 <M30W> Ahhh
06:46:33 <M30W> Gotcha
06:47:07 <M30W> I read get the File from the HashSet and tell it to delete it there.
06:47:14 <M30W> Sounds good.
06:47:52 <M30W> srhb: Ah; how to map it?
06:47:57 <M30W> For the list of id's
06:48:10 <srhb> map (\id -> File { fileID = id }) ?
06:48:55 <srhb> I guess that's a type error if there are no defaults.
06:49:44 <srhb> So you actually need to have a dummy file to work with
06:49:44 <M30W> > let xs = ["5","3"] in map (read :: Integer) xs
06:49:45 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
06:49:45 <lambdabot>              with a...
06:50:01 <M30W> Hmmm
06:50:04 <srhb> read certainly doesn't have type Integer
06:50:29 <M30W> > let xs = ["5","3"] in map read xs :: Integer
06:50:30 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
06:50:31 <lambdabot>              with a...
06:50:45 <srhb> [5,3] isn't an Integer either
06:50:56 <M30W> > let xs = ["5","3"] in map read xs :: [Integer]
06:50:57 <lambdabot>   [5,3]
06:50:58 <M30W> Was fixing that lol
06:51:01 <srhb> :)
06:51:15 <srhb> Anyway. Your program is reaching a point where design errors are really starting to show
06:51:19 <M30W> Okay filter to pass user input to real command with error handeling done :)
06:51:29 <srhb> Looking up items by help of a dummy File item is really ugly.
06:52:37 <M30W> Indeed
06:52:46 <srhb> If you want lookups only on file ID, why not have a Map Id File
06:53:03 <srhb> If you want to be able to lookup more things... Well, I guess you need IxSet or something (someone else might know better alternatives)
06:53:05 <M30W> :|
06:53:16 <srhb> Don't be too sad
06:53:17 <M30W> Thought about IXSet
06:53:29 <srhb> Refactoring this can show you how strong the type system is in fixing these things for you
06:53:36 <srhb> You could try with a Map for now. :)
06:53:49 <M30W> Rewriting code -> return "meh"
06:54:07 <srhb> I think it's one of the most fun things in Haskell, but maybe I'm just a simple person :P
06:54:19 <srhb> I love going "and now, the type system says I've done all the necessary changes"
06:54:27 <srhb> -> Warm fuzzy feeling inside.
06:54:59 <johnw> I'm so used to relying on the type system now, I end up feeling a bit let down whenever it lets me write infinitely recursive functions ;)
06:55:09 <M30W> srhb: Moving to Map would mean the `union` method would break and need a re-write other than the qualified H. to M. for Map; Or does Map have the same `union` ?
06:55:12 <martink> When I "cabal install" a library, it installs all the dependencies. How can I get it to "cabal install" all the dependencies of a .cabal file?
06:55:34 * M30W can't access docs atm :(
06:55:38 <johnw> martink: cabal install --only-dependencies
06:55:46 <M30W> @hoogle Data.Map.Union
06:55:46 <lambdabot> Data.Map union :: Ord k => Map k a -> Map k a -> Map k a
06:55:47 <lambdabot> package union-find
06:55:47 <lambdabot> Data.Map unions :: Ord k => [Map k a] -> Map k a
06:56:10 <martink> johnw: thanks very much
06:56:13 <srhb> M30W: :)
06:56:16 <M30W> @hoogle Data.DataSet.union
06:56:16 <lambdabot> package union-find
06:56:16 <lambdabot> package funion
06:56:24 <M30W> Ha
06:56:41 <M30W> srhb: Would that work in the same context?
06:57:00 <srhb> M30W: Data.Map.union?
06:57:03 <srhb> M30W: Yes.
06:57:40 <M30W> O.o what happens if you import x as Y without qualified? It seemingly is implied ?
06:57:47 <M30W> ghc atleast.
06:58:04 <srhb> It's not implied
06:58:16 <srhb> You get both qualified and unqualified versions.
06:58:23 <M30W> Ah
06:58:27 <M30W> Fair enough
06:58:50 <srhb> M30W: If you decide to refactor, start from a working version. :D
06:58:59 * srhb is cpt. Obvious
07:04:43 <M30W>     Expecting one more argument to `M.Map File'
07:04:52 <M30W> srhb: It was working lol
07:05:07 <srhb> M30W: Maps need a key
07:05:15 <M30W> Key ?
07:05:23 <M30W> FileID ?
07:05:43 <srhb> If that is what you want to search by, yes. :)
07:05:51 <M30W> :)
07:06:45 <M30W> type MapFile = M.Map File FileID
07:06:45 <M30W> ;)
07:06:59 <srhb> > fromList [(1,"first item), (2, "second item")] :: Map Int String
07:07:00 <lambdabot>   <hint>:1:65:
07:07:00 <lambdabot>      lexical error in string/character literal at end of input
07:07:06 <srhb> Ow.
07:07:10 <srhb> > fromList [(1,"first item"), (2, "second item")] :: Map Int String
07:07:11 <lambdabot>   Not in scope: type constructor or class `Map'
07:07:11 <lambdabot>  Perhaps you meant `M.Map' (i...
07:07:18 <srhb> > fromList [(1,"first item"), (2, "second item")] :: M.Map Int String
07:07:20 <lambdabot>   Not in scope: `fromList'
07:07:20 <lambdabot>  Perhaps you meant one of these:
07:07:20 <lambdabot>    `IM.fromList' ...
07:07:26 <srhb> *headdesk*
07:07:38 <srhb> You get the idea. :P
07:07:49 <srhb> M30W: Except the other way around
07:07:54 <srhb> M30W: Map Key Value
07:12:23 <M30W> srhb: What?
07:12:30 <M30W> Map FileID File ?
07:12:31 <M30W> XD
07:13:07 <srhb> M30W: Yes. :P
07:13:24 <srhb> M30W: Otherwise you can lookup IDs if you have all the other informations.
07:13:30 <srhb> Probably not what you want.
07:14:40 <M30W> srhb: Haha "probally" :P
07:14:57 <M30W> Atleast I know how to rev that lookup :)
07:15:09 <augur> so ive decided Ord should have a deriving
07:15:29 <simpson> augur: Sounds a little outrageous.
07:15:39 <augur> simpson: im an outrageous kinda guy
07:16:44 <M30W> rmFiles xs = ReaderT $ \e -> atomicModifyIORef (serverFiles e) (map M.delete xs, ())
07:16:47 <M30W> srhb: Hehe
07:16:54 <augur> you might want to condition it on arg types being Ords too, but
07:17:05 <M30W> Couldn't match expected type `MapFile -> (MapFile, ())' with actual type `([M.Map FileID a0 -> M.Map FileID a0], ())'
07:17:20 <M30W> Back to that haha
07:17:40 <srhb> M30W: You forgot to supply the Map
07:17:43 <srhb> M30W: From which to delete.
07:18:06 <augur> a default Ord instance could be generated by using some sort of constructional depth thing
07:18:34 <augur> so that you could always use Map for simple ADTs
07:18:34 <srhb> M30W: And you want to do it in one go
07:18:52 <srhb> M30W: Otherwise you get a list of Map k v each with one key/value removed
07:19:02 <M30W> srhb: Ah.
07:19:12 <M30W> srhb: How?
07:19:49 <srhb> M30W: delete is for removing single items. Use one of the other functions.
07:20:53 <M30W> srhb: "one of the other functions" "no docs" -> hmm
07:20:58 <M30W> ghic tab completion :)
07:21:03 <srhb> M30W: difference, say.
07:21:17 <M30W> "difference" ?
07:21:24 <srhb> "Difference of two maps. Return elements of the first map not existing in the second map."
07:21:47 <M30W> Ah
07:21:50 <M30W> Neat
07:22:37 <M30W> Couldn't match expected type `MapFile -> (MapFile, ())' with actual type `(M.Map k0 b0 -> M.Map k0 a0, ())'
07:22:40 <M30W> Hmmm
07:23:14 <M30W> :t ()
07:23:15 <lambdabot> ()
07:23:19 <M30W> :t _
07:23:19 <augur> im sure theres a way to calculate position in the enumeration tree too
07:23:20 <lambdabot> Pattern syntax in expression context: _
07:23:36 <srhb> M30W: Sounds like some type annotations not quite right. Show?
07:23:53 <M30W> srhb: Show ?
07:24:04 <srhb> M30W: Your code, please. :)
07:24:04 <M30W> remFiles xs = ReaderT $ \e -> atomicModifyIORef (serverFiles e) (M.difference xs, ())
07:24:10 <M30W> srhb: ^_^
07:24:22 * M30W read "Show" not do show ;)
07:24:23 <srhb> M30W: Well, it's missing an argument
07:24:34 <M30W> MapFile ?
07:24:40 <srhb> M30W: Remember, differences takes two maps and produces the difference between them
07:24:51 <srhb> M30W: You're only giving it the first map (in fact, the wrong one)
07:25:03 <srhb> :t atomicModifyIORef
07:25:04 <lambdabot> Not in scope: `atomicModifyIORef'
07:25:31 <M30W> :t Data.IORef.atomicModifyIORef
07:25:32 <lambdabot> GHC.IORef.IORef a -> (a -> (a, b)) -> IO b
07:26:00 <srhb> That's right. So the second argument needs to be of that form. You've forgotten to deal with the a, that is, the old Map
07:26:38 <M30W> srhb: So. M.difference getFiles xs ?
07:26:43 <srhb> Once again, you need something like \oldMap -> (oldMap `M.difference` newMap, ())
07:26:55 <M30W> oh derp
07:26:58 <M30W> Yea just noticed :)
07:27:03 <srhb> Think of it as the function that atomicModifyIORef will use on the current contents
07:27:05 <M30W> Just about to suggest that
07:27:32 <M30W>    47 addFiles hs = ReaderT $ \e -> atomicModifyIORef (serverFiles e) (\ohs -> (ohs `M.union` hs, ()))
07:27:35 <M30W>    50 remFiles xs = ReaderT $ \e -> atomicModifyIORef (serverFiles e) (\ohs -> (ohs `M.difference` xs, ())
07:27:40 <srhb> @pl \om -> (om `foo` nm, ())
07:27:40 <lambdabot> flip (,) () . (`foo` nm)
07:27:42 <M30W> Almost the same :)
07:27:50 <srhb> M30W: Yes
07:28:01 <srhb> M30W: You should consider abstracting this pattern out
07:28:16 <M30W> Closing off the last paren might help haha
07:28:32 <srhb> Also if xs is a list, it won't work.
07:29:20 <M30W> manageFiles a = ReaderT $ \e -> atomicModifyIORef (serverFiles e) (\ohs -> (a, ()))
07:29:23 <M30W> srhb: ?
07:30:06 <srhb> a has to use ohs
07:30:20 <M30W> Ah
07:30:24 <srhb> (And call it f at least)
07:30:31 <M30W> So manageFiles a = ReaderT $ \e -> atomicModifyIORef (serverFiles e) (a,()))
07:30:41 <M30W> Ha okay
07:30:55 <srhb> (a,())) is not a function, so no
07:30:59 <srhb> You were on the right track before
07:32:08 <srhb> Afterward you should convert the IORef to MVar :P
07:32:48 <M30W> So manageFiles f = ReaderT $ \e -> atomicModifyIORef (serverFiles e) f)
07:33:21 <srhb> M30W: manageFiles f = ReaderT $ \s -> atomicModifyIORef (serverFiles e) (\old -> (f old, ()))
07:33:30 <srhb> e, not s
07:33:40 <M30W> without that )
07:33:51 <M30W> O.o where that s come from
07:33:56 <srhb> Error! I meant e
07:34:14 <M30W> Ah
07:34:20 <M30W> I read it as my message haha
07:35:05 <srhb> Hmm. Not sure that's the best abstraction actually.
07:35:53 <srhb> It should be flipped, I think
07:35:58 <ocharles> is there an easy way to turn "Hello" into (Nothing, Nothing, Just "Hello"), perhaps with the _3 lens?
07:36:31 * hackagebot lens 3.7.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.3 (EdwardKmett)
07:37:23 * ocharles asks that in #haskell-lens
07:37:38 <M30W> srhb: I am confused.
07:37:43 <srhb> M30W: Me too.
07:37:48 <M30W> I noticed :P
07:37:50 <M30W> manageFiles f = ReaderT $ \s -> atomicModifyIORef (serverFiles e) (\old -> (f old, ()))
07:37:53 <M30W> Err
07:37:53 <M30W> failpaste
07:38:17 <srhb> Yeah, wrong order, we can't supply "new" then
07:38:33 <srhb> Oh we can, if it's passed sectioned
07:39:07 <srhb> But that's ugly
07:39:25 <srhb> M30W: Scratch the abstraction, wait until you rewrite to MVars.
07:40:24 <M30W> (\o -> (o `M.union` xs, ()))    (\o -> (o `M.difference` xs, ()))
07:40:45 <M30W> Could that be cleaned up to not need the \o -> ( ) ?
07:40:47 <srhb> M30W: Yeah that's possible (except don't call it xs, it's a Map, not a list)
07:41:09 <srhb> @pl \o -> (o `foo` n, ())
07:41:09 <lambdabot> flip (,) () . (`foo` n)
07:41:12 <srhb> See, ugly.
07:41:21 <srhb> It will be fixed once you change to MVars, so forget it for now.
07:41:21 <M30W> srhb: M.fromList xs ?
07:41:31 <M30W> xs :: [FileID]
07:41:33 <srhb> M30W: If you really want to pass lists to the function, yeah
07:41:40 <srhb> Otherwise you convert to Map on the other end
07:43:09 <M30W> srhb: Want lists to go there :)
07:43:10 <augur> byorgey: syn
07:43:38 <M30W> srhb: Makes more sense tho doesn't it? client sends 'rm 1 4' It's a list.
07:43:45 <swi> Hello there again :)
07:44:01 <srhb> M30W: Yeah probably. Not sure intersect is best choice anyway then.
07:44:09 <srhb> or difference.
07:44:12 <johnw> every time I use fromJust, I feel like I'm hurting shachaf
07:44:43 <M30W> srhb: Suggestion?
07:45:01 <swi> i was thinking about 'haskell is free of side effects' and.. i.e. what if haskell app get data from some source, and these daa must be i.e. int, but on some bug haskell app get str, not int. What will happen?
07:45:24 <srhb> M30W: filterWithKey
07:45:44 <M30W> srhb: keys
07:46:03 <M30W> map (filterWithKey m) xs
07:46:05 <M30W> ?
07:46:27 <simpson> swi: How does that happen, though? I mean, data moves into and out of Haskell differently than you are used to, I think.
07:46:31 * hackagebot adjunctions 3.0.1 - Adjunctions  http://hackage.haskell.org/package/adjunctions-3.0.1 (EdwardKmett)
07:47:03 <srhb> M30W: No, again, mapping over the list will produce a Map for each value in the list, that's not what yo want.
07:47:19 <swi> simpson: i mean.. well, someone put wrong data into the src stream i.e.
07:48:25 <simpson> swi: Well, if you're thinking about something like a socket or a file with formatted data, then normally there will be error handling.
07:48:52 <swi> simpson: so in this kind of situation it's like a other languages?
07:48:54 <M30W> srhb: Yea.. :/
07:49:13 <M30W> srhb: Also; I moved that M.fromList outside :)
07:49:14 <swi> s/a/as/
07:49:28 <martink> I'm having trouble using Data.Array. I've imported qualified as Array, then do I write "array `Array.(!)` index" or "array Array.! index" or what? i can't seem to conjure up something that does't syntax error with the import on the front
07:49:41 <srhb> M30W: But it won't really work, will it. I think filterWithKey is better.
07:49:42 <simpson> swi: Reading through those kinds of streams, you'll get bytes, and then you'd parse them into ints or whatever you want.
07:50:23 <simpson> swi: The thing is that the error handling would not be done as a side effect. You would include the possibility of errors in your types.
07:50:39 <M30W> srhb: I don't know.
07:50:47 <M30W> srhb: I'm lost in talk and code.
07:50:53 <swi> simpson: ooh. like a try block in imperatives?
07:50:59 <M30W> And errors with existing code lol
07:51:38 <psii> swi: More like: parseInput :: Input -> Either ErrorDescription SuccessfulParse
07:51:42 <srhb> M30W: \oldMap -> filterWithKey (\k _ -> not . elem k $ xs) oldMap
07:51:47 <simpson> swi: Yeah, but purer. Are you just getting started with Haskell?
07:51:52 <srhb> M30W: Where xs is the list of ids
07:52:11 <swi> simpson: very very started :) just 4th chapter of real work haskell and some googles :)
07:53:05 <swi> s/work/world/
07:53:27 <M30W> srhb: wait. list again?
07:53:50 <srhb> M30W: Yes, since it's filter now. There's no reason to make an entire map, after all. I mean I think we _could_ but.. :P
07:54:09 <swi> simpson: can you point me at some text about error handling in such kind of situation?
07:54:15 <M30W> Yea
07:54:23 <Iceland_jack> swi: look for Maybe and Either
07:54:34 <M30W> Couldn't match expected type `MapFile -> (MapFile, ())' with actual type `(M.Map FileID a0 -> M.Map FileID a0, ())'In the second argument of `atomicModifyIORef', namely `(\ o -> M.filterWithKey (\ k _ -> not . elem k $ xs) o, ())'
07:54:36 <swi> psii: i see
07:54:49 <martink> Can GHC warn me about unused instances of typeclasses? I recently found a redundant one, but wasn't getting any warnings on Wall
07:55:03 <swi> Iceland_jack: thanks. that what i search for (a keyword) :)
07:55:04 <M30W> srhb:
07:55:34 <srhb> M30W: Could you paste that code.
07:55:49 <swi> Iceland_jack: it' from Data.Maybe?
07:55:50 <M30W>    50 remFiles xs = ReaderT $ \e -> atomicModifyIORef (serverFiles e) (\o -> M.filterWithKey (\k _ -> not . elem k $ xs) o, ())
07:55:58 <M30W> 50:linenu
07:56:09 <srhb> M30W: Missing some parens around the tuple I believe
07:56:33 <psii> swi: http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html  for example
07:56:37 <Iceland_jack> swi: Maybe is in the prelude
07:57:11 <swi> psii: Iceland_jack thanks a lot.
07:57:23 * swi feels like a dumb :)
07:57:28 <Iceland_jack> swi: If you need to return a single thing or a failure, use Maybe. if you need to return a single thing or a failure with an explanation, use Either.
07:57:52 <M30W> srhb: No; that's the right count
07:58:17 <Iceland_jack> A made up function `nth': nth 0 "Jane" → Just 'j', nth 25 "Jane" → Nothing
07:58:17 <srhb> M30W: I don't believe you!
07:58:18 <srhb> :P
07:58:22 <M30W> srhb: ?
07:58:37 <M30W> (\o ...())
07:58:40 <swi> Iceland_jack: i see. on the prelude docs it says about monad. maybe it's why i don't understand it yet
07:58:44 <M30W> Even vim tells me they match up
07:58:45 <srhb> M30W: It's not right, no. The first element of the tuple is now a function
07:58:51 <srhb> M30W: Match up does not mean right number
07:58:54 <Iceland_jack> You don't know to know about monads to get Maybe and Either swi
07:59:05 <srhb> M30W: You want a function that returns a tuple. Now you have a tuple with a function in the first place
07:59:06 <Iceland_jack> *need to know
07:59:15 <srhb> M30W: More paranthesis!
07:59:19 <srhb> ;)
07:59:37 <M30W>  (\o -> M.filterWithKey ((\k _ -> not . elem k $ xs) o, ()))
07:59:46 <srhb> What's the type of that?
08:00:02 <M30W>  Couldn't match expected type `(MapFile, ())'
08:00:02 <M30W>                 with actual type `M.Map k0 a0 -> M.Map k0 a0'
08:00:23 <M30W>     Probable cause: `M.filterWithKey' is applied to too few arguments
08:00:45 <srhb> (\o -> (M.filterWithKey (\k _ -> not . elem k $ xs) o, ()))
08:00:47 <srhb> There you go
08:00:48 <swi> psii: aha. not read to that part yet. :) seems to read further :)
08:01:05 <shachaf> johnw: You certainly are.
08:01:18 <augur> @tell byorgey i think i have an idea for generating Ord's for polynomial ADTs
08:01:18 <lambdabot> Consider it noted.
08:02:16 <psii> swi: thought it could be a nice example for demonstrating this parsing thing: you want a value of some type out of a JSON datastructure, but your code must be prepared to get the wrong type. So Maybe gets used.
08:02:54 <M30W> srhb: Hmm
08:03:01 <srhb> M30W: Am I wrong?
08:03:43 <M30W> One typo -> E.InvalidArgument I -> i one error gone ;)
08:03:51 <swi> psii: i see. thanks a lot, psii
08:04:13 <swi> haskell not so 'fast learn and go' but interesting
08:05:42 <M30W> srhb: ix Dldr.hs Network/Dldr/Core/*.hs;ghc --make Dldr |& ix
08:05:47 <M30W> http://ix.io/3TR+3TS+3TT+3TU http://ix.io/3TV
08:06:16 <t7> lines longer than 80 characters :(
08:06:33 <M30W> t7: lol
08:06:49 <M30W> srhb: add / to the end of the first link to get line numbers and colour. :)
08:07:02 <t7> clever
08:07:27 <M30W> or `vim 'http://ix.io/3TR+3TS+3TT+3TU' +ft=haskell`
08:07:53 <M30W> or `vim 'http://ix.io/3TR+3TS+3TT+3TU' +'set ft=haskell'`
08:09:41 <t7> wow vim can use wget :)
08:09:55 <M30W> t7: Curl here ;) But yea :)
08:10:08 <johnw> shachaf: it's only in testing code, where I want the exception if it's not ;)
08:11:14 <M30W> srhb: Any suggestions?
08:11:32 <srhb> M30W: Fix your type errors? ^^
08:12:06 <srhb> M30W: The first ones are pretty trivial if you read them.
08:12:17 <hiptobecubic> when i open that link with links -source i get gibberish. weird
08:12:57 <hiptobecubic> gzipped i assume
08:13:29 <M30W> srhb: Acturally first ones... Still got me :|
08:13:44 <M30W> Ah nvm
08:14:13 <srhb> M30W: I'm guessing you meant to put that xs on remCommand, not listCommand
08:14:26 * M30W should go from up to down for type checking ;)
08:14:29 <M30W> srhb: I noticed
08:14:58 <M30W> Thanks any way ^_^ -- Thanks for everything else too :D :D :D
08:15:03 <srhb> Sure.
08:16:19 <M30W> srhb: vim 'http://ix.io/3TW+3TX+3TY+3TZ+3U0' '+set ft=haskell'
08:16:33 <M30W> Errors are at the bottom
08:17:25 <M30W> s,any way,anyway,
08:17:26 <srhb> Dldr.hs:63:44: Couldn't match expected type `(FileID, File)' with actual type `File' -- should be trivial too
08:17:34 <srhb> Notice what the docs say for fromList
08:17:52 <M30W> srhb: Docs :|
08:17:53 <srhb> @type Data.Map.fromList
08:17:54 <lambdabot> Ord k => [(k, a)] -> M.Map k a
08:18:35 <srhb> M30W: Why don't you have docs? Pretty hard to code without them :P
08:19:48 <M30W> srhb: /dev/dm-0      btrfs      15G   12G  1.7G  88% /
08:20:01 <M30W> Filesystem that doesn't exist anymore ;)
08:20:51 <srhb> You have a browser?
08:21:33 <M30W> 99466.10 192042.11 << uptime and firefox crashed cause crypto or some handeler paniced and I keep losing access to my USB.
08:22:17 <M30W> So now my USB I booted from isn't even in cause it gets rendered useless haha. srhb I tried launching firefox before but it crashes sooner or later and it crashed eariler.
08:22:23 <srhb> o_o well, perhaps you should fix that before trying to proceed. It's a lot easier when you can view the docs.
08:22:30 <M30W> ssh is basicly all I have haha.
08:24:05 <M30W> srhb: reboot fixes but only temp fix lol. My other notebook is falling apart....... Asus EEEPC 1000he 32-bit 2G ram, great little device but screws that were holding the screen hindge in place vanished and now screws are falling out from inside the hindge. Found ... 1 screw. I open the laptop and it'll short hehe.
08:25:05 <M30W> srhb: haddoc is more or less text; does haddoc support text output prefferently with some colour. :)
08:25:12 <M30W> @hoogle haddoc
08:25:12 <lambdabot> package haddock
08:25:12 <lambdabot> package haddock-leksah
08:25:44 <M30W> Heh docK
08:25:57 <srhb> M30W: I don't know.
08:26:23 <M30W> I'll look into that another day..
08:26:26 <M30W> I'll reboot now..
08:27:58 <M30W> Back
08:28:13 <M30W> Slow boot for some reason.
08:29:01 <M30W> FF frozen :(
08:29:24 <roconnor> If I don't export a record updater but do export the field names, does this disable record update notation?
08:29:25 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:29:30 * M30W thinks *this* USB has reached it's limitations haha
08:29:54 <srhb> roconnor: How do you export one but not the other?
08:30:29 <roconnor> srhb: givin data Foo = Foo {bar: Int, baz int} I export Foo, bar, baz
08:30:40 <roconnor> but I do not export Foo(..)
08:31:45 <srhb> M30W: Well, you can browse the module with :browse in ghci or ask lambdabot for specific types.
08:32:01 <M30W> Heh.
08:32:04 <M30W> srhb: I got ff << lol
08:32:14 <martink> I'm getting the warning that "This package indirectly depends on multiple versions of the same package". This is due to libraries. What on earth can I do about that?
08:32:30 <aavogt> roconnor: doesn't that export everything except for the contructor Foo?
08:32:45 <M30W> If it responds and doesn't iospam my USB to death again
08:33:02 <M30W> (clean profile)
08:33:18 <aavogt> so you can look at what's inside Foo, update it, but you can't pattern match on it or make new ones
08:33:35 * M30W updates this usb and sync's it while the filesystem is working :)
08:34:20 <ToranLipse> How do you define a polymorphic type synonym? Would it be type Name a = [a] ? or just type Name = [a]?
08:34:32 <aavogt> ToranLipse: the first one
08:34:37 <ToranLipse> Thank you =)
08:34:48 <startling> martink: use the newer versions of the libraries using the older version of the offending package or use the older versions of the libraries using the newer version of the offending packages
08:35:58 <martink> startling: thanks, but sorry I'm still confused by that - can you rephrase that not so succintly
08:36:29 <beaky> hello
08:36:32 <beaky> hello
08:36:46 <beaky> how do I do OOP with closures?
08:36:59 <johnw> beaky: what does that question mean?
08:37:12 <M30W> srhb: Gave up on that laptop when it decided to kernel panic. Now I'm not in bed but on my computer.
08:37:17 <geekosaur> ghc does aggressive cross-module inlining, so if you compile a program/library against another library it is specific to that exact version (and compile! ghc may inline slightly differently depending on options etc.)
08:37:34 <startling> martink: some-package depends on version 1.2 of bad-library while other-package depends on version 1.3 of bad-library. Either get a newer version of some-package that uses 1.3 of bad-library or an older version of other-package that uses 1.2 of bad-library
08:37:37 <beaky> I can't figure out how to do inheritane with closures
08:37:42 <startling> beaky: that's not really something you do.
08:37:48 <beaky> ah
08:38:07 <geekosaur> so if you install a different library version, youreally want to rebuild everything against that version, or you will eventually end up with one library you use pulling in one version of a library, and something else you use pulling in a different version*, and things Blow Up
08:38:24 <martink> startling: ok, these packages are straight from the newest on hackage, so I guess i may have to manually update them to the newer library and try to get the changes committed
08:38:53 <geekosaur> if cabal doesn;t catch it then you start getting error messages from the compiler whch look like the same type but one or both of them has a package version prepended
08:39:44 <startling> martink: you can do that, but you can also manually look for specific versions that would work together and specify them
08:40:08 <martink> startling: that sounds like an np complete problem :)
08:40:17 <startling> martink: yeah. :(
08:45:17 <beaky> I think I found out how to do inheritance
08:45:58 <beaky> you just invoke the base from the derived closure
08:46:01 <M30W> srhb: 0 -> addFiles $ M.fromList [ (1, File { fileID = 1, size = 5, src = "test", out = "testing", state = Active   }) ]
08:46:16 <M30W> Lol
08:46:26 <Taneb> How well does GHC optimize ((), a)?
08:47:15 <shachaf>  Optimize it to what?
08:47:30 <Taneb> a
08:47:39 <int-e> Taneb: not at all
08:47:44 <Taneb> (that's the type, not the value)
08:47:52 <Taneb> Hmm
08:47:58 <shachaf> It's not the same as a.
08:48:06 <Taneb> Okay
08:48:15 <Taneb> Laziness issue-thingies?
08:48:16 <int-e> note that ((),a) has extra values compared to a: _|_, (_|_,a), ((),a)
08:48:30 <Taneb> Yeah
08:50:52 <shachaf> On the other hand, it can probably do case ((),x) of ((),y) -> ...y...
08:51:12 <M30W> srhb: Would there be a cleaner way to do that add ^ ?
08:52:33 <srhb> M30W: looks right
08:53:22 <M30W> srhb: So when I define each file (in that function) I'm going to have to dub the use for the FileID ?
08:53:25 <epta> Why there is no insertWith for Data.Heap ?
08:53:27 <M30W> Strange.
08:57:04 <M30W> srhb: http://ix.io/3U4
08:57:13 <M30W> Not as simple..
09:01:25 <roconnor> aavogt: you are right.  I was hoping not exporting the field would disallow updates
09:01:32 <roconnor> er not exporting the constructor
09:02:14 <srhb> M30W: I think you mean remFiles . map read $ xs
09:02:30 <srhb> M30W: Or drop the .
09:02:51 <aavogt> roconnor: seems to me you only have to write a bit of boilerplate like:   data F = F { _f :: Int };  f = _f
09:03:07 <aavogt> then avoid exporting _f
09:04:16 <HakellCurious> Hello everyone
09:05:51 <HakellCurious> Anyone knows a good website for Haskell beginners?
09:05:58 <Iceland_jack> @where lyah
09:05:58 <lambdabot> http://www.learnyouahaskell.com/
09:06:03 <Iceland_jack> That one is good HakellCurious
09:06:13 <HakellCurious> great thanks guys
09:06:40 <M30W> srhb: Ha, yea typechecking ♥
09:07:04 <HakellCurious> anyone here involved with using Haskell in finance?
09:07:21 <HakellCurious> for trading e.g.
09:08:07 <beaky> type inference ftw
09:08:19 <Cale> HakellCurious: I know they exist, not sure if any of them are around at the moment :)
09:08:48 <Iceland_jack> Ah the mythical Haskell-in-industry folk :)
09:08:57 <HakellCurious> Thanks Cale
09:09:03 <Cale> Well, I'm a Haskell-in-industry folk myself :)
09:09:15 <HakellCurious> I hear about them but never seen anyone use it in the industry
09:09:31 * osfameron doesn't believe in Cale
09:09:40 <Taneb> The only language I've seen being used in industry is VB 6
09:09:43 <Cale> (We've started using it at skedge.me, we're rewriting the backend of the web application in Haskell because our existing backend is almost unmaintainable)
09:09:53 <Taneb> I'm not in Industry much
09:10:19 <srhb> M30W: All good now?
09:10:37 <srhb> M30W: Refactoring really is a lot easier here, hope I didn't put you off from Haskell now. :)
09:10:45 <HakellCurious> i hear it is being used in HFT and the money being offered for Haskell skills is pretty impressive
09:11:15 <M30W> srhb: Haha, you can't :P
09:11:22 <srhb> @faq Can Haskell make you fat stacks?
09:11:22 <lambdabot> The answer is: Yes! Haskell can do that.
09:11:25 <srhb> Hooray!
09:11:42 <srhb> M30W: Anyway, there are better teachers than me, but I don't think I gave any TOO bad advice this time around. :-)
09:11:43 <zomg> Cale: heh, I've actually considered as a side-thought to build an appointment SaaS though localized for finnish market since there aren't really any big players here
09:11:45 <M30W> srhb: http://ix.io/3U6+3U7+3U8+3U9
09:11:46 <M30W> http://ix.io/3Ua
09:12:10 <M30W> :|
09:12:39 <psii> HakellCurious: found this: http://www.tsurucapital.com/en/jobs.html#devops
09:13:25 <M30W> srhb: http://ix.io/3Ub+3Uc+3Ud+3Ue+3Uf
09:13:32 <M30W> srhb: First was old lol.
09:13:57 <M30W> Those two are .... :|
09:14:29 <HakellCurious> psii: yes i have seen a few...but i hear it is rather secretive part of the finance world so you dont hear much noise about it
09:14:53 <srhb> M30W: I've no idea what you're doing in line 60
09:15:40 <psii> HakellCurious: about using haskell in HFT or HFT in general?
09:15:51 <zomg> psii: if I lived around those parts of the worlds that could be pretty interesting
09:15:58 <HakellCurious> HTF in general
09:16:23 <ToranLipse> Whats wrong with?
09:16:25 <ToranLipse> type Sequence a = [a]
09:16:25 <ToranLipse> naturalSequence :: [Sequence Integer]
09:16:25 <ToranLipse> naturalSequence = [1,2,3]
09:16:40 <M30W> Compiled :D
09:17:10 <zomg> ToranLipse: [Sequence Integer] is same as [[Integer]]
09:17:12 <zomg> See the problem now?
09:17:13 <srhb> M30W: What did you do?
09:17:16 <Cale> HakellCurious: Edward Kmett is working with financial guys in Haskell (and a Haskell-like internally developed language), and he's usually around here as edwardk, but not right at the moment it seems.
09:17:31 <ToranLipse> Ah! Thanks!
09:17:32 <Cale> HakellCurious: I don't think it's HFT though.
09:17:32 <M30W> srhb: I don't know :3 uuuuuuuuuuuuuuuuuuuuuuuuuuuuu patch things and works :D
09:17:33 <M30W> Haha
09:17:36 <hiptobecubic> HakellCurious, I don't think you'll see a huge amount of haskell in HFT directly. It seems to usually play more of a supporting role.
09:17:40 <M30W> Also saving the Server.hs file helped ;)
09:17:52 <hiptobecubic> HakellCurious, writing DSLs for fast prototyping and that kind of thing
09:17:57 <srhb> M30W: Alright.
09:18:09 <zomg> HFT is pretty dirty
09:18:09 <Cale> Yeah, I would imagine that Haskell might be a metalanguage for writing HFT programs, but not something that you'd write them in directly.
09:18:10 <M30W> srhb: :D
09:18:16 <M30W> Thank you srhb ^_^
09:18:22 <zomg> but I wouldn't mind working on HFT stuff, I think it would be interesting despite being dirty
09:18:25 <zomg> =)
09:18:30 <srhb> M30W: You're welcome.
09:18:41 <hiptobecubic> I think finance has some interesting problems to solve
09:18:53 <hiptobecubic> HFT is a whole different game though. I feel like it's barely finance
09:19:18 <HakellCurious> My understanding is that it is being used in HFT execution ...to allow ultra fast execution
09:19:23 <Cale> (i.e. you might go about writing Haskell programs that act as special-purpose compilers to emit HFT programs when run)
09:19:56 <hiptobecubic> HakellCurious, execution meaning? What i said? Or fast running programs
09:20:28 <Cale> GHC tends to compile Haskell pretty well, but if your only goal is execution speed, you may have a frustrating time.
09:20:43 <M30W> srhb: Lets just hope I don't return too quickly ;)
09:21:15 <HakellCurious> execution as in both fast running and performing trade execution (buying and selling in fractions of seconds)
09:21:37 <psii> HakellCurious: i'd imagine that Haskell gets used because of its type system which enables DSL users to write statically checked algorithms with high safety guarantees.
09:21:38 <hiptobecubic> I spoke to someone the other day about it. He uses clojure for making DSLs but the trading engines are exclusively c++
09:21:57 <zomg> HakellCurious: HFT is basically reacting to very small changes in stocks, they buy and sell at very slight differences, but in such large volumes it makes money
09:22:14 <zomg> the reason it's called high frequency is because it needs to be done quickly in order to react in time and correctly
09:22:34 <hiptobecubic> This is also the reason it isn't really finance, in the usual sense
09:22:44 <Cale> HakellCurious: So, to use Haskell for something like that, I would probably want to write a library which would help me write one-shot compilers to generate HFT programs
09:23:05 <Cale> i.e. you run the Haskell program, it emits an actual program to make trades
09:23:07 <hiptobecubic> It's more like applied statistics and machine learning taken to the limit
09:23:19 <HakellCurious> Yes i am aware of all that. In fact i do trade myself but would like to get into HFT , hence my curiosity about Haskell
09:23:45 <HakellCurious> Cale: Exactly that
09:23:47 <Cale> http://hackage.haskell.org/package/atom
09:24:19 <Cale> This library for instance is being used to write realtime control software for hybrid-hydraulic engines.
09:24:51 <Cale> (where correctness is very important because if your software is wrong, a garbage truck ends up inside someone's house)
09:24:58 <HakellCurious> you basically ask a program to execute trades based on certain criteria
09:26:02 <hiptobecubic> HakellCurious, yes but you're talking about writing the trading engine. Cale is talking about writing a DSL to write trading engines.
09:26:02 <HakellCurious> Cale: I am assuming to be able to do that you need to be very good at Haskell?
09:26:59 <HakellCurious> I have no idea how Haskell works to be honest so I am sure Cale is more correct than i am
09:27:44 <hiptobecubic> HakellCurious, it's just a general purpose programming language. It happens to have features which make it good for writing compilers.
09:27:45 <tac> Cale is often more correct than most.
09:28:01 <Cale> HakellCurious: It would certainly help. Haskell is a very different programming language from most of those you're likely to be familiar with. If you are writing code directly in Haskell which needs to perform well, it takes a long time (as long as it took you when you were first learning to program) to learn how to write code which performs well.
09:28:44 <Cale> But for something like HFT where speed is almost the only concern, I wouldn't even recommend using Haskell *directly*, but instead use it as a metalanguage in which to write programs that generate your trading programs.
09:28:51 <hiptobecubic> HakellCurious, what i mean is people typically write their actual engines in a language which is "closer to the metal" to have fine grained control over things like memory.
09:29:08 <srhb> I'm surprised to learn that speed is actually a real concert in HFT.
09:29:19 <srhb> As in, I didn't know it was THAT 'HF'.
09:29:25 <srhb> concern, not concert :P
09:29:36 <HakellCurious> Makes sense
09:30:04 <Cale> That removes the burden of getting good performance from the Haskell code, and puts you in control of how many instructions get generated to do some particular thing, which is probably better.
09:30:22 <Cale> Also, Haskell tends to be really good when it comes to writing compilers.
09:30:41 <hiptobecubic> srhb, they are putting in a fiber optic line from UK to NYC to lower latency by a few ms.
09:30:41 <HakellCurious> Anyone here would like to write a trading engine? or library for trading engine? I have Trading background so together we could make alot of money
09:30:43 <hiptobecubic> srhb, http://www.businessweek.com/articles/2012-03-29/trading-at-the-speed-of-light
09:30:53 <HakellCurious> That is how most trading firms have started
09:31:28 <srhb> (Also, atom looks really interesting!)
09:31:36 * hackagebot direct-sqlite 2.3.3 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.3 (IreneKnapp)
09:31:37 <Cale> hiptobecubic: wow, that page lacked a scrollbar for the first 30 seconds or so, for me
09:31:38 * hackagebot git-annex 3.20130107 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20130107 (JoeyHess)
09:31:41 <HakellCurious> srnb: yes it is all about speed
09:31:45 <Cale> (and it eventually showed up later)
09:31:49 <srhb> HakellCurious: I see :)
09:31:56 <hiptobecubic> Cale, then you see the problem :)
09:32:05 <srhb> hiptobecubic: Sounds like you convert clock cycles to money. Why don't programmers rule supreme? :-)
09:32:27 <hiptobecubic> srhb, people who are good at this get paid serious amounts of money.
09:32:50 <HakellCurious> in fact it is so important that a physical distance from a server will benefit one firm to execute trades faster than other who are a foot further away
09:32:55 <Lethalman> @src liftIO
09:32:55 <lambdabot> Source not found. :(
09:32:59 <srhb> Crazy.
09:33:11 <hiptobecubic> srhb, http://www.wilmott.com/jobsboard/career/25956/C-Software-Engineer-For-High-Frequency-Trading-Ny-Or-La-200k-Bonus-Region-New-York-Los-Angeles
09:33:19 <epta> http://hpaste.org/80428 could someone please help find an error?
09:34:16 <srhb> I'm almost tempted to try my hand at it. Sounds like a serious investment though. And my ethics center is complaining. :P
09:34:24 <HakellCurious> that is why you can get paid 500K for a year if you are good at creating programmers that execute faster
09:34:42 <srhb> But I assume the algorithms are very, very proprietary.
09:34:49 <hiptobecubic> srhb, http://www.wilmott.com/jobsboard/  knock yourself out
09:34:58 <hiptobecubic> srhb, yes. And turnover is ridiculous
09:35:05 <hiptobecubic> srhb, both of algorithms and of programmers
09:35:09 <HakellCurious> it is ethically questionable indeed...because they create so much volatility that hurts other investors
09:35:10 <srhb> hiptobecubic: Holy hells. So many jobs.
09:35:26 <srhb> HakellCurious: Companies, people, societies...
09:35:28 <Cale> epta: Okay, so what type do you expect γ to have?
09:35:53 <nyc> Doesn't matter what or how many I apply to. No one will ever hire me.
09:36:08 <hiptobecubic> it's "competitive"
09:36:15 <HakellCurious> top secret....some russian guy got arrested for trying to steal GS's code and went to prison for a decade or so
09:36:20 <Cale> epta: It will have type  M.HashMap Vertex (M.HashMap Vertex Weight)  because you're using the Reader Graph version of ask, and that's how Graph is defined.
09:36:25 <srhb> HakellCurious: Yikes.
09:36:30 <hiptobecubic> Yeah that was pretty funny
09:37:00 <HakellCurious> even though he created part of it himself
09:37:15 <epta> Cale, yep, that 's what I want to keep in reader monad
09:37:18 <Cale> epta: However, you do: M.lookup minimal_node γ
09:37:33 <Cale> and minimal_node :: (Maybe Weight, Vertex)
09:37:43 <Cale> which is the wrong key type
09:38:41 <Cale> i.e. minimal_node there should be a Vertex, if you want to look it up in γ
09:38:56 <Cale> Perhaps you wanted snd minimal_node?
09:39:29 <epta> Cale: great
09:39:31 <epta> Got it
09:39:39 <HakellCurious> so if anyone person or more like to do try this then please drop me an email on rostaqi@outlook.com...could be the start of something big
09:39:54 <HakellCurious> hope it is okay to post email address here
09:40:11 <hiptobecubic> srhb, tempting though, isn't it?
09:40:19 <epta> Cale: but how find it so fast?
09:40:22 <srhb> hiptobecubic: Horribly.
09:40:26 <Cale> Well, it's okay, but the channel is publically logged, so there's no guarantee that some spammer won't go parsing the logs for emails.
09:40:40 <Cale> epta: I read the error message carefully
09:40:53 <Cale> Couldn't match type `Vertex' with `(Maybe Weight, Vertex)'
09:40:59 <Cale> In a stmt of a 'do' block: γ <- ask
09:41:07 <hiptobecubic> srhb, the guy i talked to described the hours and work in environment as "horrifying"
09:41:08 <Cale> those are the really important bits
09:41:08 <HakellCurious> i get spam anyway so let nothing new
09:41:15 <hiptobecubic> work environment*
09:41:26 <srhb> hiptobecubic: Yeah. I really don't want to do that :P
09:41:43 <HakellCurious> hiptobecubic: stope scaring people...haha
09:41:44 <Cale> So then I asked what's the type of γ and what type does it need to be for the surrounding code?
09:41:49 <hiptobecubic> srhb, maybe for two years or something :D then retire to the beach in costa rica
09:41:59 <srhb> hiptobecubic: :-)
09:42:03 <epta> Cale: how did you get γ type?
09:42:14 <hiptobecubic> Ok Cale is trying to teach. I'll stop clogging up the channel ;)
09:42:15 <Cale> By thinking about the type of ask and looking at the type of step
09:42:44 <Cale> ask will produce a result which has whatever type the MonadReader instance for the current monad gives
09:43:01 <Cale> and since the Reader in the base monad being transformed here is a (Reader Graph)
09:43:10 <Cale> the result of running ask must have type Graph
09:43:37 <Cale> So then I looked at the rest of your code, and I saw where γ was being used
09:43:48 <Cale> and the first thing I found was  M.lookup minimal_node γ
09:44:30 <Cale> I also looked at the definition of Graph and figured out where Vertex or (Maybe Weight, Vertex) was involved in that.
09:44:53 <epta> Awesome detective story
09:44:57 <Cale> type Graph = M.HashMap Vertex (M.HashMap Vertex Weight) -- Vertex is both the key type and part of the result, so the problem is with one of those, somewhere
09:45:18 <monochrom> hi
09:45:25 <monochrom> @bots
09:45:25 <lambdabot> :)
09:45:26 <Cale> hello
09:45:44 <neutrino_> hi cale :)
09:49:25 <nicoo> Hi, Cale, neutrino_, monochrom & lambdabot
09:49:38 <neutrino_> hi nicoo
09:49:43 <neutrino_> hi monochrom
09:50:26 <nicoo> > "Hi"
09:50:28 <lambdabot>   "Hi"
10:18:45 <fmap> is there a concept of the "fold" that has access to the remainder of the "list" on each iteration?
10:19:23 <latro`a> you mean not just the output of fold but the whole list?
10:20:14 <srhb> how about just folding over tails?
10:20:21 <srhb> Seems the simpler encoding.
10:20:35 <startling> fmap: isn't that just a "(a -> b -> b) -> b -> [a] -> b", of which foldr is a special case?
10:21:09 <latro`a> seems like the point is that the function is a -> b -> [a] -> b
10:21:12 <latro`a> oslt
10:21:13 <fmap> well, I want to modify the remainder on each iteration
10:21:36 <srhb> Ah.
10:22:01 <chreekat> Any tips for editing haddocks docs? The one tool I know to use is 'cabal haddock' but that rebuilds the whole project regardless of what has or hasn't changed
10:22:13 <chreekat> (whole project documentation, that is)
10:22:31 <srhb> Some accum thingy?
10:23:23 <chreekat> And I'm not sure when or how informatios taken from the .cabal file to build the package's main index
10:23:45 <chreekat> s/informatios/information is/
10:54:44 <rohitkav> is their anyway I can install the whole haskell package with cabal on to my ubuntu 12.04 machine
10:55:00 <Clint> the whole haskell package?
10:55:44 <rohitkav> yes
10:55:49 <rohitkav> most of it
10:56:46 <rohitkav> since each time I end up having issue with my ubuntu and each time i have to get all the packages installed, and sometimes it doesn't install properly :(
10:58:56 <psii> rohitkav: maybe haskell-platform package?
10:59:15 <rohitkav> yes
11:06:12 <allsystemsarego> lambdabot, what happens if I mistakenly made you generate an infinite list?
11:06:28 <nathanfh> > [1..]
11:06:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:06:40 <allsystemsarego> ok, thanks
11:06:47 <Lethalman> > length [1..]
11:06:50 <allsystemsarego> so I didn't crash it
11:06:51 <lambdabot>   mueval-core: Time limit exceeded
11:07:05 <merijn> allsystemsarego: lambdabot is pretty robust vs exploits
11:07:17 <Lethalman> .oO(the last famous words :P)
11:07:24 <zomg> Oh now I feel smart, I made a list of Maybes that I needed to pad to an arbitrary length
11:07:33 <psii> allsystemsarego: people tried all sorts of things: http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
11:07:37 <zomg> So... concat [myListOfMaybes, repeat mzero]
11:07:38 <zomg> :D
11:07:39 <merijn> Lethalman: Well, lambdabot has been exposed to several years of people trying to crash it
11:07:42 <Cale> If you find a consistent way to crash it, you can let me know, but I may or may not actually do something about it, because lambdabot doesn't actually have a maintainer. I just try to keep this instance running.
11:08:24 <merijn> zomg: Why not "myListOfMaybes ++ repeat mzero"?
11:08:25 <b_______> > fix ($) 2
11:08:30 <lambdabot>   mueval: ExitFailure 1
11:08:30 <lambdabot>  mueval: Prelude.undefined
11:09:05 <Cale> It could probably produce better error messages too, but see above.
11:09:32 * Lethalman runs a lambdabot locally too
11:09:40 <zomg> merijn: because I wasn't *that* clever :D
11:09:46 <Lethalman> Cale, but when it's "cold", I get two errors like that (ExitFailure 1)
11:09:53 <Lethalman> then it starts working
11:10:01 <Lethalman> it's like it takes too much time to load libraries etc.
11:10:09 <Lethalman> Cale, any hints on this issue?
11:10:47 <Cale> I don't know. You can reduce the number of libraries that it's loading, or take a look at how it runs mueval from Plugins/Eval.hs
11:11:06 <Lethalman> Cale, I've already tried to reduce the number of libraries
11:11:48 <Lethalman> :(
11:12:02 <Cale> There should be a commandline flag to mueval to set the time limits. I think there are at least two places where a time limit is enforced though, so you might have to track them both down.
11:12:13 <Cale> It's a bit of a mess.
11:12:51 <Lethalman> Cale, I just wrapped a mueval script :)
11:12:57 <Lethalman> *with
11:13:03 <Lethalman> that passes/filters the arguments, so that's fine
11:13:13 <Cale> If anyone wanted to write me a new lambdabot to run, that would be pretty cool. :)
11:13:31 <Lethalman> what's wrong with this one?
11:13:51 <Cale> The code in this lambdabot is of variable quality.
11:14:04 <Cale> and has undergone years of hackery without much oversight
11:14:37 <Cale> (Don was pretty good about it I think, but it's been a long while since lambdabot had a real maintainer)
11:15:01 <Lethalman> Cale, in Eval.hs it just runs mueval apparently, so I believe the problem is in mueval
11:15:50 <Cale> There are some plugins (I forget which) that use regexes to do things which it doesn't make even a tiny bit of sense to use regexes for.
11:18:02 <neutrino> cale have you seen this one regex package which allows you to use regex with any data type, not just char?
11:18:18 <Cale> neutrino: I think so.
11:18:20 <neutrino> i.e. regex on [a] rather than regex on [Char]
11:18:28 <neutrino> the idea is pretty damn cool, if you ask me.
11:18:29 <Cale> Oh, well, I've written one of those.
11:18:34 <neutrino> have you?
11:18:40 <neutrino> maybe you should talk to the author and contribute :)
11:18:44 <Tecido_Humano> hey you... do you like MUSIC VIDEOS? check out this blog then... http://senaotensmaisnadaparaouvir.blogspot.pt/
11:18:45 <neutrino> he thought it has no uses at all..
11:18:58 <neutrino> but apparently.. there's a need..
11:19:33 <Lethalman> Cale, right now I've executed mueval directly and I get the ExitFailure 1/Prelude.undefined... if I execute it another time it works... so it's not lambdabot, yet I'm clueless :-)
11:19:59 <Cale> neutrino: Well, my library was the least practical regex library ever.
11:20:16 <Cale> I just wrote it to implement a particular algorithm for comparing containment of regular languages.
11:20:39 <Cale> http://cale.yi.org/share/Regular.hs
11:21:08 <mdmkolbe> Question for anyone that got a paper accepted at POPL, what is the time format for the talks?  25min talk + 5min for questions?  (I'm preparing my talk and I can't find it anywhere.)
11:25:06 <Cale> mdmkolbe: I found a TeX document from 1995 which indicates that was their format then, lol
11:25:26 <c_wraith> I'm sure nothing's changed in the last 17 years
11:25:29 <c_wraith> err, 18
11:25:36 * c_wraith hasn't adjusted to the new  year yet
11:25:56 <mdmkolbe> heh, we should suggest someone graph that for the PC Chair's report
11:42:02 <hemmie> Hi all, I'm starting my first nontrivial haskell project and I was wondering if I could get some feedback on whether I'm going about it the right way.. The goal is to write a program that translates an xml document to latex. My plan was to parse the xml yielding a tree structure, and then walk the tree in the state monad, iteratively building the output document. Does that sound like an idiomatic way to
11:42:04 <hemmie> do it?
11:42:25 <Cale> > 1
11:42:27 <lambdabot>   1
11:42:43 <Cale> > sum [1..4]
11:42:44 <lambdabot>   10
11:43:12 <statusfailed> Getting GHC > 7 on ubuntu 10.04 is the most horiffic task ever
11:43:48 <Cale> hemmie: You certainly could do that. I'm not sure I'd *set out* to use the state monad, but it might be sensible for some types of transformation.
11:43:53 <shachaf> hemmie: Sometimes you find that State gives you less than you think it would.
11:44:33 <monochrom> I would just XML -> Output, instead of XML -> State Output ()
11:44:35 <appamatto> Is forkIO strict? What triggers the evaluation of the forkIO argument?
11:44:46 <appamatto> Is forkIO strict? What triggers the evaluation of the forkIO argument?
11:44:59 <shachaf> For example:
11:45:00 <hemmie> Cale: shachaf: interesting...
11:45:04 <shachaf> > (`execState` 0) $ mapM_ (\x -> do { modify (+x) }) [1..100]
11:45:05 <lambdabot>   5050
11:45:09 <Cale> appamatto: Well, executing forkIO will cause execution of its argument, at which point the argument will need to be evaluated.
11:45:20 <appamatto> Is forkIO strict? What triggers the evaluation of the forkIO argument?
11:45:28 <shachaf> That's a reasonable "State"y way of computing the sum of a list, but a fold would be much simpler here.
11:45:30 <Cale> appamatto: But I don't think evaluating forkIO x will cause x to be evaluated.
11:45:46 <Cale> > forkIO undefined `seq` 5
11:45:48 <lambdabot>   Not in scope: `forkIO'
11:45:52 <hemmie> monochrom: but in that scenario you need to keep track of the intermediate output right
11:46:01 <Cale> well, of course :P
11:46:11 <monochrom> that does not imply State
11:46:22 <Cale> ghci> forkIO undefined `seq` 5
11:46:22 <Cale> 5
11:46:38 <hemmie> my thinking was that the state of the output under construction is a State :-)
11:47:01 <shachaf> hemmie: (State Output ()) is the same as (Output -> Output)
11:47:03 <monochrom> allow me to use an analogy. a beginner is to write his own "map" for learning. there are two ways
11:47:15 <shachaf> Oh, just listen to Dr. monochrom.
11:47:21 <Cale> So forkIO is not strict, but execution of the resulting action will force the evaluation of x of course, because execution of an action always demands that action to be evaluated.
11:47:44 <hemmie> shachaf: I see what you mean above though
11:47:56 <monochrom> first way: (a->b) -> [a] -> State [b] ()  "because there are intermediate answers"
11:48:00 <appamatto> Cale, I see.
11:48:13 <monochrom> second way: map f (x:xs) = f x : map f xs
11:48:38 <monochrom> this generalizes to trees such as XML
11:49:12 <statusfailed> Do the GHC binary packages work on Ubuntu?
11:49:27 <statusfailed> or: Is there a simpler way than running a VM to build against an older glibc
11:49:29 <statusfailed> libc*
11:49:47 <hemmie> monochrom: ok, but what about scenarios where arbitrary parts of the input can affect arbitrary parts of the output, ie a certain xml tag buried deep in the tree necessitates an addition to the preamble of the latex document?
11:50:26 <shachaf> Cale: Always with IO, anyway. :-)
11:50:36 <shachaf> (And I guess with any interesting monad.)
11:50:57 <monochrom> then State is for that. State is not for storing the document.
11:52:30 <hemmie> monochrom: I can't reconcile your second sentence with the first, sorry :-) what exactly would you be storing, if not the document?
11:52:56 <monochrom> preamble
11:52:57 <DMcGill> does anybody have experience with linear algebra packages? I only want to define and the compute the det of a matrix. hmatrix needs 3 C libs which looks like a chore, what's Vec like?
11:53:08 <hemmie> aha
11:54:26 <hpaste> statusfailed pasted “Can't install GHC 7.6.1 binary package on Ubuntu 10.04” at http://hpaste.org/80430
11:54:29 <hemmie> thanks monochrom shachaf, I'll let that simmer in mt head for a while
11:54:56 <statusfailed> I don't spose anyone knows how I might fix that error ^ ?
11:55:52 <hemmie> statusfailed: the binaries work fine on my ubuntu 11.10, 10.04 might be a different story
11:56:29 <statusfailed> hemmie: I don't suppose you could tell me what version of libc you have?
11:56:31 <Cale> statusfailed: Could you paste the complete log?
11:56:38 <statusfailed> I'm trying to get stuff running on heroku
11:56:42 <statusfailed> Cale: including the ./configure?
11:56:50 <Cale> Is that the entire output of make?
11:56:54 <statusfailed> Yep
11:56:57 <statusfailed> make install
11:57:02 <Cale> oh, right
11:57:12 <Cale> hmm
11:57:23 <Cale> maybe the package didn't get unpacked fully?
11:57:39 <Cale> I mean, that says that the ghci-7.6.1 binary isn't there.
11:57:44 <statusfailed> would a broken archive be a reason?
11:57:47 <Cale> yes
11:57:51 <statusfailed> ok that's probably it
11:57:57 <statusfailed> I've been having problems with my internet connection again
11:58:13 <statusfailed> I hate captive portals so much ;_;
11:58:31 <hemmie> statusfailed: from apt-cache show libc6: Provides: glibc-2.13-1, libc6-i686
11:59:09 <Cale> If you had the wrong libc it wouldn't work, but that copy command would still succeed, I would hope.
11:59:19 <statusfailed> hemmie: aw darn, heroku are using 2.12
11:59:22 <statusfailed> thanks though :)
11:59:28 <neutrino> uhh
11:59:37 <monochrom> statusfailed: are you 64-bit or 32-bit? I offer to tell you the md5 of the tarball
11:59:54 <statusfailed> 64, I gratefully accept
12:00:10 <statusfailed> 7.6.1
12:00:21 <monochrom> ok, first I have to download it XD
12:00:26 <jochu> statusfailed: I started writing a buildpack for heroku, I never quite finished though. But the prepare/compilation bit should work. https://github.com/jochu/heroku-buildpack-testing/blob/master/prepare/compile.sh
12:00:41 <neutrino> aptitude show god tells me god is written in Ruby
12:00:45 <neutrino> :(
12:01:14 <statusfailed> jochu: i'm trying to upload a binary- buildpacks build on the server, right?
12:02:26 <jochu> statusfailed: Well, that's what I was doing with the buildpack. I'm not sure what exactly you're doing. There's really two ways I see deploying haskell to heroku. You can either make a buildpack and have that compile your things or you run a virtual server, compile locally, and then just push your binary.
12:04:03 <statusfailed> jochu: I managed some success with static compilation before, but as soon as I added postgres I ran into problems
12:04:36 <roadfish> is there an infix "if" operator? for real short items where then/else aren't mentioned. something like (x==3) ? "isThree" "notThree".
12:04:39 <monochrom> statusfailed: 23da3285c5f8fe6716e2795d149c6b96  ghc-7.6.1-x86_64-unknown-linux.tar.bz2
12:05:07 <statusfailed> jochu: I'll stick with this way for now, but i'm
12:05:14 <statusfailed> starring your buildpack
12:05:18 <jochu> statusfailed: Ah, I'm going to guess that were compiling against a different version of postgresql's client.
12:05:25 <monochrom> perhaps put a * before the filename to emphasize "binary file"
12:05:38 <shachaf> monochrom: Wow, is that an md5sum?
12:05:40 <statusfailed> monochrom: that's what I got
12:05:42 <shachaf> Those things are so short.
12:05:44 <statusfailed> cheers
12:05:54 <monochrom> that's an md5sum
12:06:46 <shachaf> Does this function make sense? http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/src/Data-ByteString.html#unpackFoldr
12:06:50 <statusfailed> monochrom: was that "*" comment for me? I didn't really follow
12:06:53 <roadfish> md5sums are short but they are 16^32 combinations
12:07:07 <SamanthaD> shachaf: an md5sum is a type of one-way cryptographic algorithm that's used to verify the integrity of a given plaintext
12:07:10 <shachaf> It seems to me that a tail-recursive foldr is a bizarre thing to do.
12:07:16 <shachaf> SamanthaD: I know what an md5sum is.
12:07:29 <SamanthaD> shachaf: oh, sorry, I misread your question then
12:07:33 <shachaf> SamanthaD: It's just that I haven't seen one for quite a while, and they're so short compared to the sha1sums I'm used to these days.
12:07:41 <monochrom> md5sum likes to use * to indicate "read this file in binary mode". probably unimportant outside Microsoft
12:08:09 <statusfailed> oh ok, well i'm probably ok unless a _massive_ coincidence just happened :D
12:08:51 <statusfailed> bizarre, i'm still getting "cp: cannot stat `ghci-7.6.1': No such file or directory"
12:09:21 <chridi> hi
12:09:42 <SamanthaD> chridi: hi!
12:09:47 <chridi> hi SamanthaD
12:09:53 <shachaf> SamanthaD: (By the way, if you're in the bay area, you should go to bahaskell! Assuming you don't already know about it.)
12:10:08 <monochrom> it is strange. I can understand incompatibilities after you install and try to use GHC. but the install script is just 20-year-old shell script and makefile
12:10:14 <SamanthaD> shachaf: Yes I am and I did not know about it!
12:10:33 <SamanthaD> shachaf: are you a bay arean?
12:10:40 <shachaf> Yep.
12:10:52 <SamanthaD> shachaf: where and when?
12:11:24 <shachaf> SamanthaD: Typically it's on the third Wednesday of the month, though recently we've skipped some meetings due to lack of talks/venues.
12:11:37 <Cale> shachaf: Are you looking at everyone's hostname to try to find people to ask this? :)
12:11:39 <shachaf> There's at least one talk planned. I don't know whether there's currently a venue.
12:11:57 <shachaf> Cale: Well, my IRC client shows people's hostnames when they join a channel.
12:12:03 <thoughtpolice> i should go to another hackathon
12:12:08 <SamanthaD> shachaf: okay, so on the 16th maybe if everything checks out
12:12:12 <shachaf> Cale: In this case it was .ca.comcast.net.
12:12:12 <monochrom> I think shachaf snoops on people's GPS phones :)
12:12:23 <shachaf> SamanthaD: I'd suggest subscribing to the mailing list.
12:12:24 <statusfailed> monochrom: I even used 'find', that file definitely doesn't exist
12:12:29 <shachaf> @google bahaskell
12:12:31 <lambdabot> http://groups.google.com/group/bahaskell
12:12:31 <lambdabot> Title: Bay Area Haskell Users Group | Google Groups
12:12:56 <statusfailed> I do extract the archive with tar -xjf archive.tar.bz2, right?
12:13:03 <monochrom> yes
12:13:14 <SamanthaD> shachaf: found it!
12:13:57 <shachaf> Cale: I also tell people to go to Toronto Haskell meetings sometimes.
12:14:04 <monochrom> heh
12:14:32 <shachaf> thoughtpolice: I hear there are good ones around here.
12:14:59 <SamanthaD> shachaf: I laughed out loud at the capcha... though it's probably the most machine readable capcha I've ever seen!
12:15:06 <statusfailed> wow, what the hell
12:15:16 <statusfailed> I changed folder and it works
12:15:29 <statusfailed> as in the folder I was extracting it into
12:15:32 <shachaf> statusfailed: Did you change it to foldel?
12:15:38 <shachaf> I recommend either folder or foldel'
12:15:42 <tac> I read that as "bah, Haskell"
12:15:52 <statusfailed> recommendation taken under consideration :D
12:15:59 <shachaf> SamanthaD: Is it still to evaluate some Haskell code?
12:16:01 <statusfailed> I think it's virtualbox's fault
12:16:09 <SamanthaD> shachaf: yeah
12:16:13 <statusfailed> it was in a shared directory
12:17:19 <statusfailed> thanks everyone (again!)
12:17:31 <shachaf> SamanthaD: If our spammers are capable of evaluating Haskell code, perhaps their spam will be on-topic.
12:17:43 <SamanthaD> shachaf: HAHA!
12:18:09 <SamanthaD> shachaf: just for that I'm going to write a spambot just for fun
12:18:39 <SamanthaD> shachaf: not to use, of course, that would be horrible!
12:19:29 <roadfish> it's the thought that counts
12:21:04 <shachaf> Hmm, so should this be considered a bug?
12:27:51 <int-e> shachaf: the foldr thing? It's interesting that unpackBytes operates on the bytestring in chunks of size 100; something similar could be done here. (I guess it comes down to this: how expensive is withForeignPtr?)
12:28:49 <shachaf> int-e: I just commented on http://hackage.haskell.org/trac/ghc/ticket/7556
12:33:40 <statusfailed> What's the path to cabal's package DB file?
12:33:50 <statusfailed> I can't download it inside my VM for some reason, eventhough networking is working
12:33:53 <statusfailed> sigh :D
12:35:24 <Nereid> statusfailed: http://hackage.haskell.org/packages/archive/00-index.tar.gz ?
12:36:15 <statusfailed> Nereid: oh, so it's .cabal/packages/hackage.haskell.org/ ?
12:36:21 <Nereid> oh, yes.
12:36:27 <statusfailed> cool, thanks :)
12:37:15 <tom22931> Anyone know what the latest on Simon Marlow's upcoming oreilly book on parallelism/concurrency in haskell is?
12:38:31 <arbn> tom22931: I think the latest news was what he said about it when he quit his MS job.
12:39:11 <tom22931> arbn: Ah, thanks. http://www.haskell.org/pipermail/haskell/2012-November/023566.html
12:40:22 <arbn> tom22931: Yeah. So, the writing will be done in the next couple months. Not sure what that means, in terms of O'Reilly's publishing and review process.
12:40:57 <qUantumSifer> S9ZZ8ZZ
12:43:32 <watermind> how do you usually represent AST's, the kind where you have expressions with vars, vars that you'd like to be able to substitute with expressions?
12:45:06 <watermind> we can parametrise these AST's on the type of the vars, but then the functor instance is not very convenient, because any  element Var x is mapped onto a Var t
12:46:20 <watermind> hmm wait
13:02:38 <DMcGill> So the package hmatrix doesn't support matricies of Ints and the package Vec requires more than 3 language extensions and some type class trickery to support matricies whose size isn't known at compile time
13:02:52 <DMcGill> I just want the determinant of a matrix!
13:02:55 <DMcGill> *cries*
13:04:09 <albakry>  Hello, what is the best reference book to learn `haskell` for newbie programmer or someone who is interested in programming for fun
13:04:15 <DMcGill> @where lyah
13:04:15 <lambdabot> http://www.learnyouahaskell.com/
13:04:24 <shachaf> albakry: Hutton's _Programming in Haskell_ is good.
13:04:40 <shachaf> If you want books that are available for free online, your options are more limited, though. :-)
13:04:54 <c_wraith> DMcGill: if all you want is the determinant, why not just calculate it naively?
13:05:01 <DMcGill> nobody tell him I didn't recommend his book as my first thought!
13:05:44 <neutrino> DMcGill: tell whom?
13:05:55 <DMcGill> c_wraith: determinant by majors is O(n!) and while I could research and implement the better algorithms, I didn't think I'd need to
13:05:55 <srhb> Hutton, presumedly.
13:06:02 <DMcGill> yes, gmh himself
13:06:12 <neutrino> why would he care?
13:06:23 <srhb> His professor?
13:06:27 <srhb> Or father!
13:06:28 <nyc> Um, try Gaussian elimination.
13:06:29 <neutrino> oh ok
13:06:31 <srhb> The plot thickens...
13:06:33 <DMcGill> I'm a student at Nottingham, may well do a PHd with him
13:06:38 <DMcGill> definately not father ;)
13:06:48 <DMcGill> s/defina/defini
13:06:55 <albakry> thank you :) what do you think about http://book.realworldhaskell.org/
13:06:56 <neutrino> "i'm your father, DMcGill"
13:06:59 <DMcGill> noooooo
13:07:24 <srhb> albakry: Not very good if you're just starting to program, probably.
13:07:31 <DMcGill> albakry: rwh is fine, but I prefer lyah and think it's easier to understand
13:07:48 <shachaf> DMcGill: Have you read his book?
13:07:59 <DMcGill> rwh is good to go to if you get bored of/want alternative takes on things from lyah
13:08:04 <c_wraith> albakry: it's really not a book for people learning haskell, despite it's claims.  It's a book for people who want to learn how to move their haskell work from toy problems to real problems
13:08:38 <DMcGill> shachaf: yup, my 3rd year diss used his (although I've no idea if he came up with it in the first place) parsers as a starting point for writing my own parser generator
13:08:58 <shachaf> I think his parser thing is pretty standard.
13:09:03 <shachaf> @src ReadS
13:09:03 <lambdabot> Source not found. I feel much better now.
13:09:06 <DMcGill> basically Parser a b = [a] -> ([a], Maybe b) iirc
13:09:07 <shachaf> type ReadS a = String -> [(a, String)]
13:09:15 <shachaf> DMcGill: He had that rhyme, right?
13:09:26 <shachaf> http://www.willamette.edu/~fruehr/haskell/seuss.html
13:09:27 <DMcGill> s/([a], Maybe b)/Maybe ([a], b)
13:09:39 <DMcGill> or something, it was a while ago
13:09:57 <srhb> Ah, that's cute.
13:09:59 <DMcGill> I used Maybe instead of List because it made things easier and I could start using monad instances!
13:10:45 <DMcGill> there's no "ifEmpty :: ([a] -> b) -> b -> [a] -> b" on lists for example
13:11:14 <albakry> <DMcGill>, <c_wraith>, <srhb> that's help me, thank you very much for your support :)
13:11:30 <srhb> albakry: You're easy to satsify! Next customer!
13:11:49 <albakry> :D
13:11:56 <shachaf> srhb: My turn!
13:12:03 <srhb> shachaf: Aaahhhh!!
13:12:13 <shachaf> srhb: Why does lastOf (folded.folded) :: [Maybe a] -> Maybe a have a space leak?
13:12:40 <srhb> because... er.. traversable.. fusion... timey wimey stuff.
13:12:47 <shachaf> Oh.
13:18:20 * MMOURA New Network joined /server 87.202.109.65
13:22:01 <dysinger> anyone here using Nix or Nixos ?
13:22:26 <dysinger> I can't for the life of me compile anything static with nix using ghc 7.4 or 7.6.  gmp linker errors.
13:26:37 <DMcGill> hmm, do people think it'll be faster to do Gaussian elimination with mutable or immutable arrays? I'm also going to try Repa vs Data.Array
13:26:48 * hackagebot monoid-extras 0.2.2.2 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.2.2.2 (BrentYorgey)
13:30:12 <koltar> is there an analogue to System.IO.print which doesn't print a newline?
13:30:39 <hpc> koltar: putStr . show
13:30:40 <nathanfh> putStr . show
13:30:52 <SamanthaD> quick question... the Haskell type Integral refers to Int and Integer, correct?
13:30:56 <koltar> ah, so no standard function
13:31:00 <koltar> thanks
13:31:03 <hpc> SamanthaD: no
13:31:05 <DMcGill> @info Integral
13:31:05 <lambdabot> Integral
13:31:15 <hpc> SamanthaD: or rather, "all that and more"
13:31:19 <luite> SamanthaD: it's a typeclass, Int and Integer are instances, but there are more
13:31:20 <shachaf> SamanthaD: It's a type class, not a type.
13:31:30 <parcs> SamanthaD: Integral is a type class of which Int and Integer are both instances
13:31:31 <shachaf> Int and Integer are instances, and other types are also instances.
13:31:38 <shachaf> @instances Integral
13:31:38 <lambdabot> Int, Integer
13:31:42 <shachaf> Well, OK.
13:31:50 * hackagebot dual-tree 0.1.0.1 - Rose trees with cached and accumulating monoidal annotations  http://hackage.haskell.org/package/dual-tree-0.1.0.1 (BrentYorgey)
13:31:50 <koltar> ...and there you have it :P
13:31:51 <shachaf> There are a bunch of others like Word, Int8, etc.
13:31:52 * hackagebot active 0.1.0.3 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.3 (BrentYorgey)
13:32:16 <SamanthaD> awesome! I was looking at Integral and thinking calculus and going "this doesn't make much sense..."
13:32:27 <SamanthaD> thanks!
13:33:52 <DMcGill> wait!
13:34:03 <DMcGill> the determiniant of a matrix of ints isn't an int
13:34:04 <DMcGill> I'm stupid
13:34:14 <DMcGill> back to hmatrix then!
13:34:31 <tac> int isn't a field.
13:34:42 <tac> The determinant is an element of the underlying field of the matrix
13:35:12 <kamatsu> hey, i want to flatten a binary tree in breadth-first order.
13:35:18 <kamatsu> i can think of several ugly ways.
13:35:37 <DMcGill> State?
13:35:51 <kamatsu> i consider that ugly, but i'll take it if there are no other options
13:35:55 <c_wraith> Okasaki published a functional pearl on exactly that topic
13:36:08 <c_wraith> well, on doing a BFS of a general graph
13:36:14 <c_wraith> but it's the exact same algorithm
13:36:27 <luite> tac: hm? you don't need a field, if you only have integer coefficients, the deterinant is going to be an integer
13:36:39 <luite> determinant
13:36:50 <c_wraith> http://www.cs.tufts.edu/~nr/cs257/archive/chris-okasaki/breadth-first.pdf
13:36:55 <DMcGill> luite: are you sure? It involved divisions
13:36:59 <DMcGill> involves*
13:37:07 <DMcGill> wait no
13:37:31 <DMcGill> uurgh, I think these multiple stupid mistakes are a sign that I should stop for the night
13:37:37 <kamatsu> c_wraith: thanks, i found it
13:37:46 <DMcGill> det by gaussian elimination needs divisions.
13:38:17 <tac> luite: but it will still be a matrix over R or C or something like that.
13:38:46 <luite> tac: hm not sure what you mean? determinant works if you have a ring, no division needed
13:39:05 <koltar> i thought dets where defined in terms of +,-,* ?
13:39:10 <koltar> were*
13:39:27 <tac> luite: ah, sorry, I'm thinking of taking the inverse!
13:39:37 <luite> tac: oh ok
13:39:54 <tac> where you need the field inverse of the determinant, of course
13:40:19 <DMcGill> I need the determinant of an Integer matrix, any algorithm/library suggestions?
13:40:38 <luite> tac: right, you only have an integral inverse if the determinant is 1 or -1
13:40:58 <alpounet> DMcGill, hmatrix :)
13:41:15 <koltar> DMcGill: http://en.wikipedia.org/wiki/Determinant#Calculation
13:41:16 <DMcGill> hmatrix does Floats and Complex Floats only :(
13:41:47 <alpounet> DMcGill, oh right.
13:42:04 <DMcGill> I'll try LU decomposition from koltar's link
13:42:51 <koltar> be careful when listening to me, i'm a lowly undergrad :P
13:43:25 <DMcGill> well me too (ish)
13:44:03 <DMcGill> I don't know why I didn't just check that page originally - the Integer Matrix page is just a stub
13:46:49 * hackagebot diagrams-core 0.6.0.1 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-0.6.0.1 (BrentYorgey)
13:54:32 <ToranLipse> If you have:
13:54:35 <ToranLipse> type Sequence a = a -> [Int]
13:54:44 <ToranLipse> is foo :: Sequence a
13:54:55 <ToranLipse> the same as foo :: (a -> [Int])?
13:55:29 <glguy> Yes, "type" creates a synonym for a type
13:55:35 <ToranLipse> Thanks =)
13:56:20 <adnap> I have a problem: http://pastebin.com/92wSaFG0 "ghc --version" prints "... 6.12.3"
13:56:24 <mauke> The paste 92wSaFG0 has been copied to http://hpaste.org/80431
13:57:20 <Clint> adnap: what are you running?
14:00:29 <adnap> Clint: Can you be more specific?
14:00:55 <Clint> adnap: what OS
14:01:08 <adnap> Clint: 3.6.11-gentoo
14:01:18 <Clint> you should upgrade to ghc 7
14:01:55 * hackagebot diagrams-lib 0.6.0.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-0.6.0.1 (BrentYorgey)
14:02:21 <glguy> adnap: 6.12.3 was released June 2010 and isn't seeing as much use these days
14:02:26 <DMcGill> right, looks like I'm converting my matrix to one of floats, calling hmatrix and then rounding to the nearest integer
14:02:49 <DMcGill> or even better, since I only care if it's 0 or not, just checking if it's with an eps of 0.
14:03:56 <adnap> Versions 7.04, 7.4.1, 7.4.1-r1, and 7.4.2 are marked as unstable, but perhaps they are just untested. Which ones are safe to install?
14:04:12 <koltar> DMcGill: that sounds error-prone; what if you're dealing with large integers?
14:04:20 <DMcGill> I'm not
14:04:47 <DMcGill> dimensions are probably less than 20x20 and definately less than 50x50
14:04:59 <shachaf> adnap: 7.4.2 should be fine.
14:05:11 <monochrom> how do you pronounce IdentityT? XD
14:05:14 <DMcGill> ditto for the values themselves
14:05:19 <DMcGill> but thanks
14:05:59 <gienah> adnap: you could ask us in #gentoo-haskell
14:06:03 <shachaf> monochrom: I pronounce BazaarT as EvilBazaar.
14:06:12 <monochrom> haha
14:06:43 <shachaf> It's a truly evil type.
14:08:18 <ToranLipse> what does foo :: (a -> [Int]) mean?
14:08:24 <srhb> If I'd made it up I wouldn't have been able to resist naming i Bzaar and pronouncing it bizarre.
14:08:25 <ToranLipse> Does it mean it returns a function?
14:08:44 <srhb> ToranLipse: Well, sure, foo is a function.
14:08:45 <ToranLipse> Or is it the same as: foo :: a -> [Int]?
14:08:50 <srhb> The same indeed.
14:08:53 <ToranLipse> Oh.
14:08:56 <koltar> yes, and yes
14:09:02 <ToranLipse> Confused.com
14:09:24 <koltar> foo is a function from a to [Int]
14:09:46 <ToranLipse> Ok thanks.
14:12:13 <koltar> srhb: i actually pronounce "bazaar" and "bizarre" the same
14:15:11 <plat0> How strange.
14:18:39 <Hafydd> http://howjsay.com/index.php?word=bazaar%3B+bizarre&submit=Submit
14:26:12 <ToranLipse> Can someone please explain what foo :: (a -> [Int]) -> (a -> [Int]) does?
14:26:27 <mauke> what
14:26:37 <mauke> it's a type signature. it doesn't "do" anything
14:26:56 * hackagebot IPv6Addr 0.3 - Library to deal with IPv6 address text representations.  http://hackage.haskell.org/package/IPv6Addr-0.3 (MichelBoucey)
14:26:57 <ToranLipse> But it implies something though.
14:27:09 <mauke> >implying
14:27:17 <ToranLipse> does foo take a function as input and return another function?
14:27:26 <mauke> yes
14:27:50 <madhadron> Are we playing type theory hangman?
14:27:59 <ToranLipse> So you would call it by foo x ?
14:28:01 <roadfish> ToranLipse: right ... it takes a function that converts from some type to a list of Int's
14:28:32 <c_wraith> I would call it eitherIdOrKindaDumb
14:28:51 <roadfish> ToranLipse: but here is the key point ... the repeated "a" means that both functions take in the same type
14:29:18 <ToranLipse> Sorry, im just confused how a function returns a function.
14:29:21 <roadfish> ToranLipse: also that "a" can be any type at all
14:29:36 <ToranLipse> foo returns (a -> [Int]) right?
14:29:37 <c_wraith> ToranLipse: why shouldn't a function return a function?
14:29:42 <madhadron> ToranLipse: It defines a new function in its body that it returns
14:29:45 <negaduck> hi! i'm on mac and i've got and old platform. How to know if it is 32 or 64 bit?
14:29:49 <roadfish> ToranLipse: you sound read up on higher-order functions
14:29:57 <ToranLipse> I have. It's confusing.
14:30:02 <mauke> no, it's not
14:30:03 <ToranLipse> Sorry. I will go have another read.
14:30:05 <c_wraith> negaduck: file `which ghc`
14:30:08 <mauke> :-)
14:30:19 <c_wraith> ...  actually, that'll probably tell you it's a shell script
14:30:23 <madhadron> mauke: If your model of function is a procedure a la C or Pascal, it certainly is.
14:30:36 <mauke> even C can return function pointers
14:30:43 <mauke> f(x)(y); // valid C syntax
14:30:58 <c_wraith> But track down what the actual binary ghc invokes is, and use file on it
14:31:07 <roadfish> ToranLipse: think in terms of math functions like f(x) and g(x) ... the f(g(x)) is another function
14:31:11 <madhadron> mauke: That's certainly true, but it's actually a large conceptual step from that to functions be creatable values
14:31:27 <acowley> negaduck: start GHCi, import Data.Bigs, then see what "bitSize (0:Int)" gives you
14:31:43 <acowley> import Data.Bits
14:31:51 <mauke> then fix the typo
14:32:06 <acowley> Yes, then go back to step 1
14:32:10 <byorgey> anyone have any advice on creating bindings to a web API in Haskell?  Best practices, packages to use, etc.?
14:32:10 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
14:32:27 <madhadron> ToranLipse: If you're coming from C or ALGOL, then it may help to realize that when you say function, we hear procedure, and when we say function, we mean the notion from mathematics of a mapping from domain to range.
14:33:05 <ToranLipse> Im sure I will eventually get my head round it.
14:33:16 <negaduck> acowley: it gives 32. thanks
14:33:24 <madhadron> ToranLipse: The easiest way is to go actually try to write some.
14:33:49 <madhadron> ToranLipse: For example, say I give you a function f that returns integers. Write me a function that takes any such f and returns a new one that returns 2 + whatever f would return.
14:33:56 <flebron> Perhaps it helps to see that returning an -> a -> b, is the same as taking an extra a, and returning a b.
14:34:03 <acowley> negaduck: I think my suggestion had more typos than correct characters, so congrats on decoding it! :)
14:34:21 <flebron> That is, f :: c -> a -> b, is the same as f :: c -> (a -> b).
14:34:23 <shachaf> @let result = sets (.); argument = sets (flip (.))
14:34:25 <lambdabot>  Defined.
14:35:25 <madhadron> flebron: In my anecdotal experience, currying is a bit easier to swallow once you've got the notion of functions as values already figured out
14:35:36 <shachaf> > map ($ 5) $ over (mapped.argument) (*10) [(+1),(^2),(*3)]
14:35:37 <lambdabot>   [51,2500,150]
14:35:46 <flebron> That might be true, yes.
14:37:24 <acowley> > map (($ 5) . (. (* 10))) [(+1), (^2), (*3)]
14:37:26 <lambdabot>   [51,2500,150]
14:38:18 <shachaf> Sure.
14:38:24 <acowley> I find it alarming that multiple compositions of partial applications are so much more obvious to me than lensish code.
14:38:37 <roadfish> ToranLipse: you might like this video: http://www.youtube.com/watch?v=b9FagOVqxmI
14:38:40 <roadfish>  (Haskell Amuse-Bouche)
14:38:47 <shachaf> Well, that's not really typical lensish code.
14:38:49 <shachaf> It's contrived.
14:39:04 <roadfish> ToranLipse: is a 2011 Google Tech Talk
14:39:42 <startling> acowley, imagine doing _2 . _2 . _2 . _2 without lenses
14:40:00 <startling> setting to it, that is
14:40:01 <shachaf> > (snd.snd.snd.snd) (1,(2,(3,(4,5))))
14:40:03 <lambdabot>   5
14:40:09 <glguy> HORROR
14:40:21 <startling> 17:39 <startling> setting to it, that is
14:40:27 <acowley> startling: Sure, setting nested components is lens's strong suit
14:40:33 <shachaf> > (fmap.fmap.fmap.fmap) (const 8) (1,(2,(3,(4,5))))
14:40:35 <lambdabot>   (1,(2,(3,(4,8))))
14:40:45 <startling> ^ my point exactly!
14:40:56 <shachaf> Which point? The const?
14:41:08 <shachaf> > (fmap.fmap.fmap.fmap.const) 8 (1,(2,(3,(4,5))))
14:41:10 <lambdabot>   (1,(2,(3,(4,8))))
14:41:13 <startling> heh
14:41:25 <startling> no, I was being farcical.
14:41:37 <BrianHV> every time I think I'm wrapping my head around haskell, I see something like that.
14:41:38 <shachaf> Hmm, interesting that you can stick const in the chain like that.
14:41:44 <shachaf> Well, it doesn't really fit into the SEC pattern.
14:41:45 <shachaf> @ty (.const)
14:41:46 <lambdabot> ((b1 -> a) -> b) -> a -> b
14:41:57 <shachaf> @ty (fmap.fmap.fmap.const)
14:41:58 <lambdabot> (Functor f2, Functor f1, Functor f) => b -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:42:02 <startling> BrianHV: the repeated fmaps? it's really simple if a little complicated
14:42:02 <roadfish> ghci is just giving me "No instance for (Functor ...)" errors when I try that mulitple fmap
14:42:05 <acowley> startling: It's still unfortunate that things other than Settings are often more verbose in lensish.
14:42:17 <acowley> startling: I want my cake, and I'm hungry.
14:42:19 <shachaf> acowley: You don't have an instance Functor (a,)?
14:42:30 <shachaf> For me it's defined in GHC.Base
14:42:32 <BrianHV> startling: I'm sure if I understood the first fmap, I would understand the rest. playing around with ghci now.
14:42:35 <shachaf> Maybe it has to do with your GHC version.
14:42:46 <acowley> shachaf: I don't think you're talking to me?
14:42:52 <shachaf> BrianHV: fmap f (x,y) = (x,f y)
14:42:58 <shachaf> acowley: Oh, I'm talking to roadfish.
14:43:00 <startling> > fmap (+ 10) ("abc", 12)
14:43:01 <lambdabot>   ("abc",22)
14:43:04 <glguy> shachaf: why not spice it up with some Caleskell
14:43:05 <glguy> > ((.).(.).(.).(.).const) 8 (1,(2,(3,(4,5))))
14:43:06 <lambdabot>   (1,(2,(3,(4,8))))
14:43:07 <startling> BrianHV: ^^
14:43:10 <BrianHV> shachaf: aha
14:43:15 <acowley> acowley and roadfish are right next to each other on the keyboard. Happens all the time.
14:43:58 * flebron has no idea how glguy's snippet works :)
14:44:28 <glguy> flebron: lambdabot is broken, it won't work on your computer :)
14:44:28 <shachaf> > ((.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.).const) 8 (1,(2,(3,(4,5))))
14:44:30 <lambdabot>   (1,(2,(3,8)))
14:44:44 <flebron> What if I replace (.) with fmap?
14:44:51 <shachaf> > ((.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)const) 8 (1,(2,(3,(4,5)))) -- "whoops"
14:44:53 <glguy> flebron: then you'd be in business
14:44:53 <lambdabot>   (1,(2,8))
14:45:36 <shachaf> Oh boy, this runs into an exponential time type checking thing or something.
14:46:07 <acowley> shachaf: You composed too hard and broke something
14:46:21 <roadfish> shachaf: I got one thing to work (fmap.const) 8 [4,5] ... [8,8]
14:46:33 <BrianHV> what's the reasoning behind defining fmap over a two-tuple?
14:46:47 <shachaf> BrianHV: That it satisfies the functor laws?
14:46:53 <shachaf> I mean, why *shouldn't* it have an instance?
14:47:14 <BrianHV> couldn't it satisfy the laws equally well if it fmap f (x,y) = (f x, y)?
14:47:24 <mauke> BrianHV: type error
14:47:34 <mauke> the functor instance is ((,) a)
14:47:34 <shapr> etrepum: y0 y0
14:47:45 <etrepum> shapr: hey
14:48:06 <BrianHV> mauke: ok... but why that rather than (a (,))?
14:48:14 <mauke> BrianHV: what
14:48:19 <mauke> (a (,)) doesn't even mean anything
14:48:23 <acowley> we don't have type-level flip
14:48:26 <mauke> you can't just make up syntax
14:48:32 <glguy> He just did
14:48:32 <flebron> I get "    No instance for (Functor ((,) t0))"
14:48:36 <acowley> haha
14:48:49 <merijn> flebron: I think it's fairly recent (7.6 or something?)
14:48:56 <shapr> etrepum: The problems I had were that Yesod has many dependencies, and their are many versions of those deps. Unless the cabal dependency problem is solved, I think I should port ghclive to scotty in my copious spare time.
14:49:05 <flebron> Oh, I'm 7.0.4
14:49:20 * BrianHV goes back to ghci to figure out what his misunderstanding is
14:50:09 * BrianHV thinks he gets it.
14:50:14 <glguy> BrianHV: you need something of kind *->*. To do tuples the other way you'd need: newtype AltPair b a = AltPair (a,b)
14:50:18 <BrianHV> ok, I'm satisfied with fmap ove two-tuples :)
14:50:26 <mauke> flebron: you need some import
14:50:31 <merijn> flebron: Although defining yourself is pretty trivial, so it's not a big problem
14:50:33 <mauke> where is that instance defined?
14:50:46 <glguy> instance Functor ((,) a) -- Defined in `GHC.Base'
14:50:55 <etrepum> shapr: maybe I'll take a look at doing that, I actually do have copious spare time right now. So you think scotty is the better fit, rather than snap or happstack or whatever else? I don't have any practical Haskell experience yet, still learning
14:51:56 <merijn> flebron: Have you tried importing Data.Functor?
14:52:05 <mauke> instance Functor ((,) a) -- Defined in Control.Monad.Instances
14:52:28 <merijn> mauke: It's also in Data.Functor, according to Hackage
14:52:31 <dmwit> We need an "also available in".
14:52:36 <shapr> etrepum: Yesod gives me flashbacks of developing for Plone/Zope. After years of Plone dev, I reflexively prefer lighter frameworks. Thus I have only anecdotal evidence to support my use of scotty.
14:52:44 <flebron> Yep,  no dice. Must be some more recent version.
14:53:02 <flebron> Oh
14:53:06 <flebron> Control.Monad.Instances did it.
14:53:44 <shapr> etrepum: If you start porting ghclive to scotty, I'll make some time to help out.
14:54:10 <roadfish> shachaf: GHCi, version 7.4.1 and ":i Functor" says class Functor f is defined in GHC.Base. with fmap :: (a -> b) -> f a -> f b. I'm not sure what Functor (a,) means. I know that fmap is a generalization of map for arbitrary structures.
14:54:14 <etrepum> shapr: I'll let you know if I make any progress
14:54:18 <shapr> spiffy
14:54:46 <shachaf> roadfish: You need to upgrade GHC to get it, I guess.
14:54:46 <etrepum> shapr: what I want to have is something like IPython Notebook for Haskell, somewhere between REPL and IDE in a browser
14:54:54 <luite> hehe porting back? :)
14:55:03 <shachaf> roadfish: In this case fmap is "mapping over" the second element of the tuple.
14:55:15 <shapr> luite: Yah, unless you have some ideas on how to fix the build dependencies problem?
14:55:16 <merijn> > fmap (+1) ('a',2)
14:55:18 <lambdabot>   ('a',3)
14:55:31 <luite> shapr: oh i wasn't aware of a problem?
14:55:42 <merijn> > fmap even ('a',2)
14:55:43 <lambdabot>   ('a',True)
14:55:43 <shapr> etrepum: I agree, I want something like luite's wolfgang. ghclive was a stab at a simpler approach.
14:55:47 <Hafydd> > map fmap (+1) [('a',1),('b',2),('c',3)]
14:55:48 <lambdabot>   The function `GHC.Base.map' is applied to three arguments,
14:55:48 <lambdabot>  but its type `(...
14:55:57 <Hafydd> > map (fmap (+1)) [('a',1),('b',2),('c',3)]
14:55:58 <lambdabot>   [('a',2),('b',3),('c',4)]
14:56:00 <merijn> Hafydd: Parens around "fmap (+1)"
14:56:14 <shapr> luite: In short, ghclive is hard to build because Yesod has bunches of dependencies, and cabal doesn't handle that well.
14:56:20 <luite> shapr: i want something like that too!
14:56:32 <absence> which package has the argument function?
14:56:45 <glguy> absence: That was a local #haskell definition
14:56:56 <luite> shapr: hmm, i thought recent cabal versions were relatively ok with yesod
14:57:03 <shapr> If I could get ghclive to build more easily, I'd be able to demonstrate to gwern that ghclive was a success, and was not designed to replace lambdabot's eval quite the way he thinks it should :-)
14:57:18 <absence> glguy: oh, i could have sworn i read about it in some blog
14:57:32 <merijn> roadfish: If you replace "f" with "(c,)", then fmap becomes "(a -> b) -> (c,) a -> (c,) b" or "(a -> b) -> (c,a) -> (c,b)"
14:57:48 <luite> shapr: right
14:57:57 <shachaf> absence: conal defines it in his SEC post.
14:58:04 <shachaf> @google semantic editor combinators
14:58:06 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators
14:58:06 <lambdabot> Title: Conal Elliott » Semantic editor combinators
14:58:06 <shachaf> But argument = (.)
14:58:19 <shachaf> Alterantively, argument = fmap
14:58:22 <shachaf> Wait, no.
14:58:25 <shachaf> argument = flip (.)
14:58:35 <shachaf> Alternatively, argument = lmap
14:58:40 <shachaf> lens also has it in HEAD
14:59:01 <luite> shapr: looks like the most recent ticket isn't caused by yesod though?
14:59:52 <absence> shachaf: right, the change you talked about earlier? someLens . argument %~ f
15:00:29 <shachaf> absence: Yes, I added that the other day.
15:00:59 <shachaf> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Setter.hs#L196
15:01:58 * hackagebot smtp-mail 0.1.4.1 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.4.1 (JasonHickner)
15:02:57 <startling> is that just a change in fixity or what?
15:03:18 <shachaf> Fixity?
15:03:49 <startling> oh, "argument" is new. my mistake.
15:04:08 <startling> thought he was saying x . y %~ f in general should work
15:04:41 <shachaf> Fixity is the...
15:04:52 <startling> fixity i the h8r
15:05:02 <startling> heh, I like the doctests with SimpleReflect.
15:05:24 <shachaf> Yes, they're great.
15:05:55 <shachaf> > let ff = f :: Expr -> Expr; hh = h :: Expr -> Expr -> Expr in (result.argument) f h x y
15:05:56 <lambdabot>   No instance for (Control.Lens.Classes.Settable
15:05:56 <lambdabot>                     ((->) De...
15:06:03 <absence> shachaf: cool, i'll just pinch that line for now :)
15:06:04 <shachaf> > let ff = f :: Expr -> Expr; hh = h :: Expr -> Expr -> Expr in (result.argument) ff hh x y
15:06:06 <lambdabot>   Couldn't match expected type `t0 -> b0'
15:06:06 <lambdabot>              with actual type `Debu...
15:06:23 <shachaf> absence: You can specialize it to flip (.) if you don't care about other profunctors.
15:06:36 <shachaf> Since lens 3.7 doesn't have the Profunctor depdendency yet.
15:06:52 <absence> shachaf: i tried, but it wouldn't compile
15:07:21 <startling> give it a good talking to.
15:07:43 <shachaf> absence: It has to be "sets", since it's a setter.
15:08:00 <shachaf> sets :: SEC -> Setter
15:08:35 <absence> shachaf: oh i see. works now :)
15:09:54 <apokalyptiker> http://windowsphone.bboard.de/board/
15:10:41 <shachaf> @yarrrr
15:10:41 <lambdabot> What be a priate's favourite cheese?
15:10:41 <lambdabot> Yarrlsburg!
15:10:56 <absence> haha
15:11:10 * absence is norwegian
15:47:12 <mikeplus64> there isn't a way to search for typeclass instances, is there?
15:48:46 <shapr> mikeplus64: :info in ghci can do some of that
15:49:08 <shachaf> Well, if the instance isn't orphan, you know where to find it. :-)
15:50:05 <shapr> mikeplus64: ":info FromRow" in my current interactive-haskell buffer gives: instance FromRow TestField \n  -- Defined at /home/shae/build/tyrni/src/Tyrni/GVoice.hs:11:10
15:50:05 <shapr>  
15:50:55 <mikeplus64> shapr: yeah, but i mean like hoogle, so i can find new packages with orphan instances
15:51:50 <mikeplus64> (frankly i'm just looking for an instance of Arrow other than the one hakyll uses)
15:52:24 <ToranLipse> If you have two infinite lists, whats an efficient way of making a new infinite list with alternate elements from either list?
15:52:53 <ToranLipse> [a1,b1,a2,b2....]
15:53:47 <madhadron> ToranLipse: Mutual recursion
15:53:55 <mauke> you may have to write this yourself
15:54:15 <madhadron> f (x:xs) ys = x : (g xs ys)
15:54:23 <madhadron> g xs (y:ys) = y : (f xs ys)
15:54:25 <mauke> weave [] ys = ys; weave xs [] = xs; weave (x : xs) (y : ys) = x : y : weave xs ys
15:54:28 <shachaf> > ($ []) . foldr (.) id $ zipWith (\x y -> (x:) . (y:)) [1..] [-1,-2..]
15:54:29 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
15:54:30 <mauke> why mutual?
15:54:33 <tac> I would go with a weave
15:54:40 <croikle> you just need one function
15:54:41 <shachaf> Or some simpler variation with a zipWith, I guess.
15:54:41 <ToranLipse> Ah! Cool. Thanks.
15:54:53 <mauke> zipWith is different
15:54:57 <croikle> f (x:xs) ys = x : f ys xs
15:54:59 <madhadron> mauke: Ah, you're right, much simpler
15:55:14 <madhadron> croikle: Even nicer.
15:55:31 <Nereid> :t toListOf (folded.both) . zip
15:55:32 <lambdabot>     Couldn't match expected type `(a0, a0)'
15:55:32 <lambdabot>                 with actual type `[(a1, b0)]'
15:55:32 <lambdabot>     Expected type: [a1] -> [b0] -> (a0, a0)
15:55:35 <Nereid> er
15:55:35 <shachaf> > concat $ zipWith (\x y -> [x,y]) [1..] [-1,-2..]
15:55:36 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
15:55:41 <Nereid> :t toListOf (folded.both) .: zip
15:55:42 <lambdabot> [a] -> [a] -> [a]
15:55:50 <mauke> > concat $ zipWith (\x y -> [x,y]) [1..] [-1]
15:55:51 <lambdabot>   [1,-1]
15:55:52 <shachaf> That works too.
15:55:53 <acowley> > take 8 . concat $ zipWith (\x y -> [x,y]) [1,3..] [2,4..]
15:55:55 <Nereid> doesn't quite do the same thing when the lists have different lengths.
15:55:55 <lambdabot>   [1,2,3,4,5,6,7,8]
15:56:00 * madhadron watches this and decides that Ruby has already rotted his brain.
15:56:00 <mauke> >implying zip works
15:56:12 <shachaf> I thought both lists were infinite.
15:56:16 <ToranLipse> They are.
15:56:26 <shachaf> So what's wrong with zip?
15:56:29 <Nereid> > toListOf (folded.both) (zip [1..] [-1,-2..])
15:56:31 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
15:56:50 <hiptobecubic> god damn, people
15:56:54 <Nereid> :t uncurry zip
15:56:55 <lambdabot> ([a], [b]) -> [(a, b)]
15:57:20 <Nereid> :t sequenceAOf both
15:57:21 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
15:57:36 <Nereid> hmmm
15:57:45 <Nereid> > sequenceAOf both ([1,2,3],[4,5,6,7])
15:57:47 <lambdabot>   [(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
15:57:56 <Nereid> oh right, we need the ZipList thing.
15:58:06 <cmccann> copumpkin, you around?
15:58:12 <ski> > [z | (x,y) <- zip [0 ..] [-1,-2 ..] , z <- [x,y]]
15:58:13 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13...
15:58:22 <copumpkin> cmccann: sort of, on phone
15:58:34 <hiptobecubic> > sequenceAOf both (ZipList [1,2,3], ZipList [4,5,6,7])
15:58:36 <lambdabot>   No instance for (GHC.Show.Show
15:58:36 <lambdabot>                     (Control.Applicative.Zip...
15:58:45 <cmccann> copumpkin, I kind of want to delete most of this comment thread http://www.reddit.com/r/haskell/comments/162zea/real_world_haskell_impressions_after_initial/c7s8si4
15:58:45 <hiptobecubic> > getZipList $ sequenceAOf both (ZipList [1,2,3], ZipList [4,5,6,7])
15:58:47 <lambdabot>   [(1,4),(2,5),(3,6)]
15:58:55 <shachaf> > concat $ transpose [[1..],[-1,-2..]]
15:58:57 <lambdabot>   [1,-1,2,-2,3,-3,4,-4,5,-5,6,-6,7,-7,8,-8,9,-9,10,-10,11,-11,12,-12,13,-13,1...
15:59:12 <hiptobecubic> @src transpose
15:59:12 <lambdabot> transpose []             = []
15:59:12 <lambdabot> transpose ([]   : xss)   = transpose xss
15:59:12 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:59:19 <hiptobecubic> ugh
15:59:28 <ski> ToranLipse : more ways above
15:59:29 <cmccann> copumpkin, it is stupid and off topic but I wanted to get a second opinion first, let me know what you think when you have a moment (no rush)
15:59:40 <Nereid> @ty transposeOf both
15:59:41 <lambdabot> ([a], [a]) -> [(a, a)]
15:59:50 <int-e> hiptobecubic: transpose is fun!
16:01:06 <hiptobecubic> well its certainly better than that first monstrosity shachaf offered
16:01:07 <acowley> cmccann: fwiw, I think that kind of off topic sillyness is adequately handled by the voting mechanism
16:01:36 <shachaf> hiptobecubic: I bet my first monstrosity was more efficient!
16:01:46 <ToranLipse> Thank you everyone. Sorry I started a whole debate...
16:02:19 <int-e> ToranLipse: don't worry about it, this is normal #haskell behavior :)
16:02:22 <acowley> golf involving lists and tuples is a primary activity in #haskell
16:02:30 <c_wraith> ToranLipse: we like debating :)
16:02:44 <shachaf> We need ListSections, man.
16:02:45 <int-e> @quote fugue
16:02:45 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
16:02:48 <shachaf> [,] :: a -> a -> [a]
16:02:55 <cmccann> acowley, it's irrelevant clutter that doesn't relate to haskell in any way
16:03:03 <shapr> I am soliticing donations for a 512MB Raspberry Pi and Freescale i.MX53 quickstart board so I can build and maintain ghc 7.6 debian packages for the Raspberry Pi! Student loans budget doesn't pay for hardware :-P
16:03:14 <madhadron> ToranLipse: It's not a debate, it's everyone searching for elegance
16:03:27 <shachaf> shapr: Is there anyone who actually uses GHC on the raspberry pi?
16:03:32 <mikeplus64> acowley: hey, don't forget lenses!
16:03:39 <shapr> shachaf: Several people have tried, or would like to.
16:03:41 <acowley> cmccann: I agree, I'm just wary of mod actions! I emphasize that I don't actually have a vote here and you folks know what you're about better than I.
16:03:50 <shapr> roconnor is the first one who comes to mind.
16:04:12 <startling> how evil is a lens on a bytestring that's only a legal lens if it's replaced with a bytestring of the same length?
16:04:12 <shapr> shachaf: But I've had a few other people ask if it's usable, want twitter names?
16:04:19 <acowley> I need a lensish way of asking @faq questions of lambdabot
16:04:21 <shachaf> roconnor doesn't like profunctors. :-(
16:04:37 <c_wraith> amaturefunctors are better
16:05:00 <shapr> shachaf: oh, bgamari certainly would
16:05:20 <cmccann> acowley, staying usefully on-topic is part of what keeps /r/haskell from being /r/programming
16:05:33 <acowley> cmccann: good point
16:05:38 <shapr> shachaf: I think dysinger might use Haskell on the Raspberry Pi if I start reporting successful results on twitter.
16:05:42 <bgamari> shachaf, all in due time, good sir
16:06:07 <edwardk> shachaf: why not?
16:06:12 <Laguana> I'm trying to write a simple expression parser (for logical formulae), but it seems to take an unreasonably long time to parse formulae when they have a lot of brackets. At the moment I'm doing  something a lot like http://stackoverflow.com/questions/5520940/creating-instance-of-read-type-class-in-haskell-for-custom-data-type but with more options
16:06:15 <cmccann> shapr, how are you receiving the donations?
16:06:17 <acowley> I would use GHC on a Raspberry Pi if I didn't know better from my experience using GHC on a system with 2GB of RAM
16:06:28 <shapr> cmccann: paypal? got other better options/suggestions?
16:06:31 <hiptobecubic> acowley, that was my thought as well
16:06:34 <shachaf> edwardk: I don't know! For some reason he prefers symmetric lenses.
16:06:42 <edwardk> those things are terrible
16:06:42 <startling> acowley: heh
16:06:47 <shachaf> I know.
16:06:53 <edwardk> whoever came up with them, sheesh
16:06:55 <fluffynukeit> hey all.  I have a large binary file that is a collection of archived sub-files.  I want to parse out an individual sub-file.  Right now I read the file, then use Get to skip ahead n bytes to get to the right subfile location.  For n large, this is really slow and lots of ram.  Ideas on how to fix?
16:06:57 <shapr> acowley: I'm hoping I can find some ways to get Haskell dev working smoothly in 512MB of RAM, but no guarantees.
16:07:15 <shapr> acowley: Surprisingly, binaries seem to work fine, it's building the binaries that is painful.
16:07:18 <shachaf> edwardk: If I ever track them down...
16:07:25 <acowley> shapr: I know! You can't sense me cheering you on via twitter?
16:07:37 <edwardk> fortunately, its only one rogue agent and roconnor has a very limited amount of time to stir up trouble ;)
16:08:07 <acowley> The tip someone offered of compiling as a separate step before linking seemed useful
16:08:19 <shapr> Yah, that really does work better.
16:08:25 <cmccann> shapr, partly just curious. for something like this I'm more likely to pitch in if it's 1) easy to do 2) clear how much (further) is needed
16:09:03 <shapr> cmccann: I have 52.5% of a 512MB Raspberry Pi funded (21/40 USD) and 0% of a $150 Freescale i.MX53 quickstart board funded.
16:09:13 <shapr> cmccann: What's the easiest way to donate?
16:09:19 <startling> shapr: kickstart it
16:09:25 <shapr> cmccann: paypal to shae@ScannedInAvian.com ?
16:09:26 <croikle> fluffynukeit: hSeek?
16:09:30 <cmccann> kickstarter is a very nice platform for this kind of thing, yeah
16:09:35 <shapr> hm, ok
16:09:38 <hpaste> Laguana pasted “slow formula parsing” at http://hpaste.org/80437
16:09:52 <startling> I was joking, seems kind of silly at such a small scale.
16:10:21 <fluffynukeit> croikle: that's what I was thinking, using the low level handle stuff directly, but I didn't know what kind of speed up I could expect. Is it usually way faster?
16:10:37 <cmccann> startling, kinda borderline. I think some kickstarter projects are that size.
16:10:50 <croikle> dunno, but it seems like it shouldn't depend on n that way
16:10:53 * shapr reads up on kickstarter costs
16:11:10 <hpaste> “Anonymous Coward” annotated “slow formula parsing” with “slow formula parsing (annotation)” at http://hpaste.org/80437#a80438
16:11:15 <cmccann> for anything much larger it'd be an excellent idea though. seems like kickstarter has a lot of potential for funding little open-source community effort things
16:12:19 <Laguana> any suggestions for why my parser is particularly slow would be appreciated (Or on better ways to implement it in general)
16:12:31 <shapr> I'd be especially happy if I could automatically produce and host Raspberry Pi debs for the latest hackages.
16:13:05 <cmccann> shapr, anyway, the problem with asking on IRC is that during this brief digression about kickstarter your paypal information is already about a third of the way to being lost in backscroll :P
16:13:53 <shapr> cmccann: Yah, I also asked on twitter. Not sure how to best approach this without sounding greedy.
16:14:42 <shapr> Heffalump suggested asking haskell.org for funding, and pointed out that there would be certain restrictions on funding from that source.
16:15:09 <cmccann> shapr, it's something to benefit the community, don't worry too much about it. just something less transient than twitter or IRC would be nice
16:15:36 <luite> shapr: what's your twitter?
16:15:45 <shapr> luite: shapr
16:15:50 <cmccann> how surprising
16:15:55 * cmccann never would have guessed
16:16:01 <shachaf> cmccann: What's yours?
16:16:22 <cmccann> shachaf, ⊥
16:16:22 <luite> :)
16:16:25 <cmccann> :P
16:16:45 <shachaf> cmccann: You should get an account!
16:16:54 <cmccann> bluh, no.
16:16:56 <shachaf> We can compete on follwer/following ratio.
16:17:00 <cmccann> don't like twitter.
16:17:20 <shachaf> Uh oh, did I lose a follower?
16:17:30 <shachaf> I think I was at 20/0 once.
16:17:32 <shachaf> Perhaps not.
16:17:36 <shapr> cmccann: I notice that account name is not taken :-P
16:17:44 <cmccann> haha
16:17:47 <startling> shachaf: hahaha
16:18:02 <startling> shachaf: I don't think you can beat that follower/following ratio
16:18:32 <shachaf> startling: Maybe if you really try.
16:19:16 <startling> > map (> (20 / 0)) [0..]
16:19:17 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
16:19:29 <startling> nope!
16:19:51 <hiptobecubic> have to check the one at the end
16:22:58 <copumpkin> cmccann: will check soon, sorry!
16:23:17 <cmccann> copumpkin, no worries, the thread is several hours old anyway
16:23:26 <shachaf> What thread?
16:24:16 <cmccann> shachaf, the one I linked earlier
16:24:46 <shachaf> Oh, rwhimpressions?
16:25:03 <shachaf> It was only hlf an hour ago. How did I miss it?
16:25:18 <shachaf> Anyway, Reddit threads tend to be horrible.
16:25:28 <shachaf> Why delete it when it's already downvoted past hiding point?
16:25:41 <cmccann> usually /r/haskell is fine. and because it's off-topic and dumb.
16:26:19 <shachaf> So? It got downvoted.
16:26:27 <cmccann> why sweep the floor when you can still walk on it even when it's covered in dirt? :P
16:27:15 <shachaf> Isn't heavenly intereference only for extreme cases?
16:28:14 <cmccann> shrug. that's kind of why I was asking for copumpkin's opinion before doing anything.
16:28:22 <startling> is this lens a bad idea? https://gist.github.com/f772ab7face563cbd2b6
16:29:19 <edwardk> startling: your 'legal' claims aren't sufficient
16:29:20 <`nand`> I don't get why you include a length there
16:29:29 <`nand`> but any way, you have to make sure you never write back a \0
16:29:38 <startling> `nand`: oh, ugh
16:30:12 <`nand`> otherwise it breaks over f . over g = over (f.g) or something
16:30:32 <startling> is the length parameter extraneous? I was thinking it would be a good idea to make it explicit rather than just using the length of the lensed bytestring
16:30:53 <kamatsu> I don't think it's really necessary to delete, although I agree it's pointless and dumb
16:30:58 <kamatsu> but i'm just a guy with an opinion
16:31:35 <shachaf> kamatsu: You may be just a guy with an opinion, but I'm not!
16:33:41 <kamatsu> I'm now up to the point where I have to make a web interface for my project
16:33:49 <kamatsu> (because Haskell has no other decent cross-platform UI story)
16:34:01 <acowley> kamatsu: CLI
16:34:02 <acowley> :P
16:34:17 <shachaf> That's not too cross-platform to Windows.
16:34:18 <kamatsu> yeah, I was going to write a CLI first, but this is eventually designed to be used by my students
16:34:34 <kamatsu> my prototype for this was done with vty, but that's not going to be flexible enough for this
16:35:40 <kamatsu> so anyway, I was wondering, the core model of this is a zipper over a potentially infinite data structure
16:36:01 <kamatsu> there's no way I can magic that over to Fay or GHCJS or something on the client side from the server is there?
16:36:28 <acowley> AJAX callback on every thunk?
16:36:32 <cmccann> haha
16:36:40 <luite> you'd probably want to make it IO
16:36:45 <cmccann> if you can serialize the zipper as a description of the path taken I don't see why not
16:37:07 <kamatsu> another option is to compile the entire theorem prover to JavaScript
16:37:09 <acowley> Yeah, the client can just have a path and the value at the cursor
16:37:36 <kamatsu> Nah, it needs the entire context for visualisation
16:37:58 <cmccann> if you can separate the UI-required stuff from any heavy lifting you could split it up that way
16:38:09 <kamatsu> that was my original intention
16:38:25 <kamatsu> but it's just going to be annoying to transport stuff over the wire when this thing is meant to be run locally anyway.
16:38:34 <kamatsu> I really just want to use the web as a UI library
16:39:17 <luite> hm, that's more or less in line with hamishmacks jsc bindings, where you control webkit+javascriptcore from haskell
16:39:28 <cmccann> if it's expected to run on the same machine as the web server then you can be pretty liberal with sending data back and forth
16:42:40 <monochrom> yikes, theorem prover in javascript, horrendous whether written by hand or generated by compiler :)
16:43:15 <kamatsu> monochrom: yeah, I can't expect much in the way of performance if I do that
16:43:33 <luite> hmm, javascript doesn't have to be so slow
16:43:51 <Eiam> I was thinking, I need a first project to do while learning haskell.  We have this neat web API here and I thought gosh, it would be fun to make a haskell interface into that web api, why not
16:43:52 <luite> 2-3x slower than native code should be doable unless you need lots of low level stuff
16:44:06 <kamatsu> luite: yeah, but theorem provers are slow, memory hungry beasts
16:44:15 <Eiam> so tell me.. any reason 'why not' ? it speaks mostly json, but there is this whole interesting bit where auth is handled via GSSAPI's and I'm betting haskell doesn't have that!
16:44:20 <kamatsu> 2-3x slower would make a difference.
16:44:48 <kamatsu> Eiam: should be reasonably interesting. Aeson is a definite mention for JSON stuff
16:45:15 <luite> kamatsu: i'd probably make it a web server and come up with some simple json protocol
16:45:25 <kamatsu> yeah, I guess I'll have too
16:45:27 <luite> maybe over a websocket
16:45:27 <kamatsu> *to
16:45:32 <kamatsu> still irritating
16:45:48 <luite> not as irritating as compiling haskell to js ;)
16:45:58 <hamishmack> kamatsu: You could try to get cloud haskell working with GHCJS
16:45:59 <Eiam> https://github.com/duboisf/hgssapi
16:46:06 <Eiam> ha looks like someone already did gssapi in haskell!
16:46:14 <cmccann> Eiam: looks like a simple FFI binding
16:46:15 <luite> oh that also sounds like an interesting idea
16:46:27 <Eiam> if i knew what the hell ffi was haha
16:46:27 <kamatsu> I've never used cloud haskell before
16:46:39 <Eiam> ah
16:46:43 <Eiam> plugin for other languages
16:46:46 <kamatsu> I don't want to start yak-shaving though.
16:47:08 <cmccann> Eiam: yeah, a way of calling C libraries from haskell
16:47:33 <kamatsu> luite:  I hate JS and will probably be compiling something to it anyway
16:49:42 <Eiam> cmccann: neat, guess ill use it as a baseline to get started
16:49:47 <kamatsu> It seems like the only way to script a webkit frame directly from Haskell is to use WebkitGTK or similar, which is no good because I use OS X and really dislike the way GTK uses X11.
16:50:05 <kamatsu> it'd be nice if there was a more cross-platform way to do that
16:50:19 <Eiam> kamatsu: have you seen phantom.js ?
16:50:29 <Eiam> kamatsu: http://phantomjs.org/
16:50:35 <kamatsu> JavaScript API, doesn't help me
16:51:16 <Eiam> kamatsu: well, I was more pointing it out to say "look, they are somehow getting acceess to a webkit frame without a browser.."
16:51:31 <Eiam> just because they've exposed it via javascript doesn't mean you have to..
16:51:34 <kamatsu> yeah, we can already do that in Haskell
16:51:58 <Eiam> oh, I must have missed the intial problem, sorry for jumping in!
16:52:10 <kamatsu> but if I want to actually present a webkit frame to the user, I can only do that in the context of GTK at the moment
16:52:52 <kamatsu> so I guess I'll just bite the bullet and make a JSON api, and then write a web-based client.
16:53:35 <copumpkin> cmccann: I wouldn't delete it, but I wouldn't be too opposed to it happening either
16:54:05 <hamishmack> kamatsu: You could write a thin Haskell client that forwards all DOM operations from the server.
16:54:16 <hamishmack> then compile it with GHCJS
16:55:16 <hamishmack> I think Michael Snoyman might already have something like that
16:56:42 <Laguana> Anyone here able to help me write a simple Read instance that doesn't fall over with nested parentheses? At the moment I'm thinking of ditching readsPrec and rolling my own recursive descent parser...
16:57:25 <acowley> Isn't there a Canvas backend to diagrams these days? Perhaps kamatsu could use that to generate graphical widgets.
16:57:29 <`nand`> ‘read’ is not really a replacement for a parser
16:57:42 <luite> or gloss-web
16:57:50 <Laguana> `nand`, oh? So instancing Read isn't the right thing to do?
16:58:07 <acowley> gloss-web is not on hackage
16:58:27 <jochu> Laguana: Isn't there a readParen function?
16:58:29 <`nand`> Laguana: if you want to write a good parser you'd be best off with a parsing library like parsec
16:58:38 <`nand`> Read is designed for very simple stuff
16:58:51 <`nand`> > readMaybe "1234" :: Maybe Integer
16:58:51 <alex20032> What are great haskell server?
16:58:52 <lambdabot>   Not in scope: `readMaybe'
16:58:54 <`nand`> bah
16:58:56 <Laguana> jochu, yes and I'm using it, and with nested parentheses it takes several seconds to read a simple example
16:58:57 <`nand`> > read "1234" :: Integer
16:58:58 <lambdabot>   1234
16:59:13 <Laguana> `nand`, ok I'll look into that then I guess.
16:59:27 <alex20032> Well, on scala, usually, we use tomcat, glassfish, jetty... but to do web development in haskell, i have no clue
16:59:33 <Laguana> I just thought that instancing read was a reasonable thing to do, to convert String -> thing
16:59:57 <`nand`> Read and Show are more programmer/development tools
17:00:01 <croikle> alex20032: maybe Warp, using Wai
17:00:13 <`nand`> eg. to make it possible for GHCi to display values
17:00:37 <Laguana> I'd been thinking of Show as more of a "to string" type of function, is that also inappropriate?
17:01:10 <kamatsu> show is more for showing the actual value of the thing, as in Haskell code
17:01:13 <`nand`> sure, show is a ‘to string’ type of function; but that says nothing about its usage
17:01:15 <kamatsu> for debugging mostly
17:01:34 <`nand`> it's not a replacement for pretty printers either
17:01:43 <alex20032> croikle: nice, a small search for warp gave me a page with 3 other web server for haskell
17:01:55 <alex20032> Does someone know some website realised in haskell?
17:02:03 * hackagebot implicit 0.0.3 - Math-inspired programmatic 2&3D CAD: CSG, bevels, and shells; gcode export..  http://hackage.haskell.org/package/implicit-0.0.3 (ChristopherOlah)
17:02:21 <Laguana> a'ight then, guess I should go find more out about that. I'd been doing things like "p"++(show i) to construct e.g. "p1"
17:03:06 <shapr> debian/experimental has ghc 7.6.1 for armhf with ghci, but it segfaults on my Pi :-( http://packages.debian.org/experimental/armhf/ghc/download
17:03:25 <shachaf> shapr: Well, track the segfault down!
17:04:07 <croikle> alex20032: http://www.haskellers.com/ claims to be built with Yesod. I'm sure there are more, though
17:04:12 <shapr> Which probably involves installing a full debian/experimental for my Pi
17:04:31 <`nand`> Laguana: that should be fine for types like Integer, which do what you expect
17:04:43 <shapr> alex20032: I've used scotty and Yesod recently, they work nicely.
17:05:12 <alex20032> From what i say, people using Scala really love haskell, and people using haskell love scala
17:05:33 <alex20032> from what i see
17:05:40 <shapr> I haven't tried Scala, is it fun?
17:05:54 <alex20032> Well, it look quite nice
17:06:02 <alex20032> I want to learn both
17:06:12 <shapr> That sounds like a good plan.
17:06:23 <alex20032> I will try out haskell maybe this week
17:06:28 <monochrom> soon I may run ghclive on my computer, which is a website realised in haskell!
17:06:40 <monochrom> and shapr you haven't answered my question! :)
17:06:42 <shapr> monochrom: Does it build for you?
17:06:47 <shapr> monochrom: What was your question?
17:07:03 <monochrom> I haven't tried. what safety and security precautions should I take?
17:07:40 <luite> burn your computer after using it
17:07:42 <alex20032> I am still wondering in term of speed...
17:07:50 <shapr> monochrom: Oh, you should distribute your IP and port numbers only to people you trust to run non-sandboxed Haskell code on your system.
17:07:54 <alex20032> Scala VS haskell for webdevelopment
17:08:15 <alex20032> But i guess both should be pretty fast
17:08:18 <shapr> alex20032: I suspect they'll both be fast enough for just about any purpose.
17:08:30 <alex20032> Haskell being compiled, correct me if wrong
17:08:32 <monochrom> that sounds pretty unsafe
17:09:07 <`nand`> languages don't have a speed :(
17:09:10 <shapr> monochrom: It's about as safe as hooking ghci up to a form on a webserver.
17:09:20 <monochrom> does ghclive come with a sandboxing option?
17:09:26 <shapr> monochrom: Nope, wanna write one?
17:09:58 <shapr> Sandboxes are safe, but they prevent you from doing lots of useful things like writing to files.
17:10:15 <`nand`> sandboxed files!
17:10:39 <shapr> ghcLiVE is designed to be as much like a web-enabled ghci as possible.
17:11:44 <shapr> You don't get readLn and putLn because I couldn't figure out how to redirect stdin and stdout that way, but you get everything else.
17:12:32 <cmccann> copumpkin: guess I'll leave the thread alone for now then, may change my mind if it starts collecting more replies. would be nice if people would just downvote and ignore instead of exacerbating nonsense. :I
17:12:43 <copumpkin> yeah :/
17:12:56 <copumpkin> people really feel the need to pound people further into the ground than they already are, for some reason
17:13:37 <cmccann> which is why I'd be happy to delete off-topic rubbish, but oh well
17:13:59 <monochrom> what thread? sounds like fun
17:14:11 <cmccann> it isn't really
17:14:19 * shapr NMUs HaskellNet
17:14:54 <cmccann> monochrom: see http://www.reddit.com/r/haskell/comments/162zea in the downvoted comment thread
17:15:29 <mikeplus64> @hoogle w (a -> b) -> f a -> b
17:15:30 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
17:15:30 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
17:15:30 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
17:17:17 <alex20032> Does Haskell is faster than php, ruby and python for web development?
17:17:46 <roadfish> @hoogle w Bool -> a -> a-> -> a
17:17:46 <lambdabot> Parse error:
17:17:46 <lambdabot>   w Bool -> a -> a-> -> a
17:17:46 <lambdabot>                      ^
17:18:12 <shapr> alex20032: It certainly can be, but it really depends on the program you write. Slow code is slow in many languages, fast code is fast in many languages.
17:18:37 <alex20032> Well, i mean similar piece of cude in those language
17:18:38 <croikle> programmer speed, or application speed?
17:18:49 <Ralith> it's unclear which of the above you are asking about
17:18:49 <alex20032> application speed of course
17:18:55 <Ralith> "of course"
17:19:01 <Ralith> you could write in asm.
17:19:22 <alex20032> ... well i discovered the expression "of course" like 4 year ago
17:19:27 <alex20032> since i like to write it, of course
17:19:38 <alex20032> Well, i am not english native
17:19:42 <kamatsu> alex20032: Generally, I'd say Haskell is faster than ruby or php, but this is a very general statement with many caveats
17:20:08 <kamatsu> certainly it seems like Yesod applications outperform Rails ones by orders of magnitude if Michael Snoyman is to be believed
17:20:09 <alex20032> Anyway, what does people here recommand for learning resource on haskell?
17:20:18 <kamatsu> rwh and lyah
17:20:29 <kamatsu> there's some fancy way to get lambdabot to give links
17:20:30 <acowley> Start with lyah
17:20:31 * shapr reads http://www.haskell.org/haskellwiki/Package_versioning_policy
17:20:42 <acowley> @LYAH
17:20:42 <lambdabot> Unknown command, try @list
17:20:45 <acowley> :(
17:20:46 <shapr> @where lyah
17:20:46 <cmccann> I'd certainly believe snoyman over anybody associated with rails
17:20:46 <lambdabot> http://www.learnyouahaskell.com/
17:20:49 <roadfish> alex20032: I'm still newish to Haskell. But my impression is that Haskell runs faster but coding much slower until you gain skill in Haskell which has a steeper learning curve.
17:20:51 <croikle> warp is a very fast pong server, at least
17:20:52 <kamatsu> @where rwh
17:20:52 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:21:23 <kamatsu> roadfish: Coding in Haskell becomes much, much faster than any other language once you are proficient
17:21:26 <kamatsu> at least in my experience
17:21:56 <kamatsu> but it's the "once you are proficient" bit that is problematic for most people
17:22:03 <roadfish> kamatsu: I'm still working on that hypothesis. There are moments of illumination where it certainly seems true.
17:22:07 <croikle> learning curve is very long
17:22:36 <alex20032_> well, my chat bugged
17:22:52 <alex20032_> what does people said in the last 3 min?
17:22:55 <roadfish> given how many Hackagebot reports, I'm guessing that the learning curve is actually infinite ... and receding at a ever-higher-speed.
17:23:01 <kamatsu> A habit I picked up that I value greatly, is that if something is taking too long for me to do, I will go away and rethink it.
17:23:16 <mauke> alex20032_: logs are linked in the topic
17:23:36 <`nand`> croikle: the ultimate goal of every implementation: to write highly efficient trivial examples
17:23:43 <roadfish> alex20032: summary is: first read learnyouahaskell.com then read realworldhaskell.org
17:24:08 <kamatsu> Erdos once said that you don't have to believe in God, but you do have to believe in the Book. He was referring to this mystical book that contained a super-elegant version of every mathematical proof for every statement that could ever exist.
17:24:21 <croikle> `nand`: a bazillion bogomips!
17:24:23 <kamatsu> you could prove a statement in an ugly way, but there was only ever one "Book" proof
17:24:35 <roadfish> alex20032: these are full books. you can read online or buy the paper versions.
17:24:37 <`nand`> croikle: hehe, exactly
17:24:45 <kamatsu> I try and find the "Book" program, and I'm prepared to take substantial time to do it.
17:25:05 <monochrom> actually, between LYAH and RWH, add the Gentle Introduction
17:25:19 * `nand` thinks beauty is subjective, there cannot be a ‘most beautiful’ program for all humans
17:25:49 <mikeplus64> my programs are all beautiful. on the inside
17:25:51 <roadfish> I think that Book was burned by Godel back in the Thirties
17:25:55 <kamatsu> hah
17:26:14 <alex20032_> Well, i come from
17:26:15 <alex20032_> C
17:26:31 <alex20032_> Functionnal a little disapointing at start
17:26:44 <alex20032_> But im sure i will learn lot of cool thing
17:26:52 <alex20032_> Like writting elegent code
17:26:58 <kamatsu> one of the things i've noticed in the area I work (PLs and type systems) and especially lately as I've been implementing a theorem prover, is that the choices you make representing your terms can have a massive difference on the beauty of your program.
17:27:24 <kamatsu> I don't think people put nearly enough thought into how they represent terms.
17:27:26 <shapr> Representation affects problem difficulty.
17:27:32 <`nand`> so can the dependencies you choose to invoke; case in point: lens :)
17:27:33 <mm_freak_> alex20032_: once you're comfortable in haskell you will be much more disappointed/depressed when having to go back to C
17:27:45 <alex20032_> Not really
17:27:52 * cmccann would rather write C in haskell than in C
17:27:58 <alex20032_> Since i love low level programming....
17:28:05 <mm_freak_> alex20032_: me too
17:28:06 <alex20032_> And low level programming in haskell...
17:28:09 <kamatsu> how low level are we talking?
17:28:12 <mm_freak_> alex20032_: yet i hate C for that
17:28:15 <`nand`> kamatsu: hydrogens, time
17:28:16 <alex20032_> Close to assembly
17:28:18 <`nand`> hydrogen*
17:28:22 <alex20032_> Writting driver
17:28:35 * shapr decides to increment HaskellNet from 0.3 to 0.3.1
17:28:41 <mm_freak_> actually nowadays you can write drivers in haskell
17:28:49 <`nand`> I don't see how ‘writing drivers’ and ‘close to assembly’ are related
17:28:58 <mm_freak_> you just can't put them in the linux kernel
17:29:01 <kamatsu> http://www.haskell.org/haskellwiki/Kernel_Modules
17:29:01 <alex20032_> But does haskell is efficient to represent computer memory?
17:29:16 <`nand`> hell, what does ‘close to assembly’ even mean? What about eg. the reduceron's machine language?
17:29:17 <mm_freak_> alex20032_: it doesn't represent computer memory at all
17:29:18 <shachaf> cmccann: I think C is better for writing C than Haskell is.
17:29:26 <`nand`> Haskell doesn't have a concept of memory
17:29:31 <shachaf> But often not that much of a C program actually needs to be C.
17:29:37 <alex20032_> How to write memory manager, and kernel shelduler in haskell then....
17:29:37 <mm_freak_> alex20032_: however, you can express mappings from haskell values to memory quite elegantly
17:29:55 <kamatsu> those are not drivers, but core parts of an operating system
17:29:59 <kamatsu> even then, it's been done
17:30:08 <mm_freak_> alex20032_: writing kernels in haskell is difficult and requires a lot of work (to port the RTS)
17:30:15 <`nand`> House is an operating system written in Haskell, but it uses a modified RTS to give it some low level primitives
17:30:22 <`nand`> So it's, strictly speaking, not Haskell
17:30:33 <mm_freak_> alex20032_: actually, the writing of the kernel in haskell is easy…  it's all that stuff around it that is hard
17:30:46 <mm_freak_> i.e. once you can actually compile a kernel, you're ready to go
17:31:00 <kamatsu> I work on an operating system for my job, it has an executable specification, but it uses the regular GHC RTS and a bridge through qemu to make it executable. The actual native kernel is written in C, but they're proven to be exactly the same program so it doesn't matter :P
17:31:11 <shapr> Can the source-repository value in a caba file have multiple location values?
17:31:22 <kamatsu> (oh yeah, the spec is Haskell)
17:31:32 <mm_freak_> shapr: i think you can have multiple repository specifications
17:31:38 <mm_freak_> but try it out, i don't know
17:31:43 <shapr> ok, tanks
17:31:45 <shapr> thanks*
17:32:08 <alex20032_> Well, but in C, we have mroe control on exactly what happen, while in haskell, we have more control on the meaning on the code, and the compiler decide how to implement it
17:32:25 <kamatsu> that's true of idiomatic C and idiomatic Haskell
17:32:29 <`nand`> so you define what a driver or kernel is; and let the compiler worry about getting it onto the hardware? :P
17:32:39 <kamatsu> but you can write C-like Haskell that gives you a lot finer control.
17:32:45 <kamatsu> it's just not usually what's done
17:32:52 <mm_freak_> alex20032_: the funny thing is that GHC actually produces more natural code than a C compiler
17:32:53 <alex20032_> Well, what i like is the hardware interface part
17:33:03 <`nand`> well, ‘control’ has a lot of different interpretations here
17:33:31 <mm_freak_> alex20032_: "natural" in that it's also sometimes faster, especially when parallelization comes in
17:33:32 <`nand`> eg., you could get a lot of high level control over how resources are allocated and freed; without ever concerning yourself with control over how the RTS interprets your program
17:34:09 <`nand`> stuff like the ResourceT monad can be powerful abstractions for this purpose
17:34:18 <`nand`> (disclaimer: I've never used ResourceT)
17:34:27 <mm_freak_> ResourceT is really just a hack
17:34:46 <mm_freak_> it can be used, where region-based I/O is difficult/impossible
17:35:14 <`nand`> another example would be stuff like attoparsec and iterators rather than lazy IO
17:35:52 <mm_freak_> alex20032_: btw, hardware access is actually easier to express in haskell
17:36:18 <mm_freak_> wrap a monad around it and you're done…  express hardware access with even less code than in C
17:36:57 <mm_freak_> hypothetical example:  mapM_ (sendTTY mySerialPort) [1..10]
17:37:15 <kamatsu> the only place where Haskell really can't work and C can is in really low-level embedded devices that can't handle the RTS
17:37:25 <mm_freak_> that's why many people say that haskell is the best imperative language =)
17:37:29 <alex20032_> RTS??
17:37:34 <kamatsu> run-time system
17:37:47 <kamatsu> the garbage collector and so on
17:37:57 <`nand`> kamatsu: you can write an EDSL and interpreter that generates a low level friendly version of your high level Haskell description
17:37:59 * shapr reads http://www.haskell.org/cabal/users-guide/developing-packages.html#source-repositories
17:38:07 <kamatsu> `nand`: yes, see atom
17:38:11 <`nand`> or lava
17:38:13 <alex20032_> i wish they would teach haskell at my school instead of visual basic
17:38:23 <Iceland_jack> mm_freak_: “many people”, all of whom are Haskellers ;P
17:38:53 <mm_freak_> Iceland_jack: of course you need to know haskell to say something like that
17:39:00 <kamatsu> Every time I hear someone mention that SPJ quote I imagine Bob Harper boiling over with rage
17:39:03 <kamatsu> it makes me chuckle
17:39:18 <Iceland_jack> Being a Haskeller isn't the same as knowing Haskell, at least that's not what I meant
17:39:35 <Iceland_jack> just saying that here (may) be bias
17:39:35 <mm_freak_> Iceland_jack: what's the difference?
17:39:53 <kamatsu> mm_freak_:  counterexample, bob harper?
17:40:02 <mm_freak_> kamatsu: i don't know bob harper
17:40:10 <kamatsu> he's a PLs academic
17:40:14 <cmccann> and I don't know if bob harper knows haskell
17:40:18 <cmccann> so there you go :P
17:40:19 <kamatsu> he loves SML and has a grudge against haskell
17:40:20 <alex20032_> But anyway, since real programmer are usually on Scala and Haskell channel, its the right place to ask: What are good programming language to learn
17:40:20 <Iceland_jack> Many people may know Python to hack stuff together but it's not among their main languages
17:40:30 <alex20032_> Well, haskell and scala of course, but what else
17:40:43 <Iceland_jack> I wouldn't call them “Pythonistas”
17:40:51 <kamatsu> I'm not much a fan of Scala
17:40:51 <alex20032_> Does people here consider ruby to be a good language?
17:40:52 <mm_freak_> actually i'm not really fond of scala
17:41:23 <kamatsu> although last time I said that I ended up in an argument with some random guy on reddit.
17:41:28 <glguy> I haven't seen much Scala love on #haskell. Most seem to consider it a kuldge.
17:41:35 <glguy> And you'll find even less Ruby love
17:41:46 <shapr> alex20032_: I think different people enjoy different languages. You should try a language yourself to see what you think.
17:41:47 <mm_freak_> alex20032_: i consider the whole object-oriented paradigm (the common one) to be stupid
17:41:57 <mm_freak_> so i can't really say that i like ruby
17:41:58 <cmccann> glguy: I think the complaints about scala only come from people who use it often
17:42:05 * hackagebot HaskellNet 0.3.1 - Client support for POP3, SMTP, and IMAP  http://hackage.haskell.org/package/HaskellNet-0.3.1 (ShaeErisson)
17:42:11 <kamatsu> cmccann: I complain about Scala, and I don't use it often
17:42:14 <kamatsu> :P
17:42:17 <alex20032_> Well, since last few day, i had to remove language from my list to learn
17:42:19 <shapr> yay Shae!
17:42:20 <alex20032_> like php
17:42:31 <alex20032_> some people showed me that php was bad
17:42:38 <mm_freak_> alex20032_: you should have a look at PHP to know why most of us hate it =)
17:42:44 <kamatsu> oh, it's bad. It takes "stringly typed" to a whole new level.
17:42:57 <alex20032_> so now i only have C, Haskell and Scala that will be on my curriculum
17:42:58 <cmccann> php is one of the few languages in actual use that can be described as objectively terrible
17:43:12 <alex20032_> well, asp.net also
17:43:18 <alex20032_> asp.net beign either VB or C#
17:43:20 <zxq9> cmccann: VisualBasic?
17:43:25 <mm_freak_> alex20032_: on the curriculum PHP actually pays off (sadly)
17:43:32 <kamatsu> VB or C# are at least context free to parse.
17:43:36 <cmccann> depends on which VB you mean
17:43:41 <shapr> And I've emailed the imapget author as well! Hurrah for productive Hackage fixing!
17:43:45 <alex20032_> But i mean, what language should i also look after C, Haskell and Scala?
17:43:54 <kamatsu> Agda, Epigram, Coq?
17:44:00 <kamatsu> my biases are showing
17:44:03 <shapr> Erlang and Mercury?
17:44:07 <cmccann> alex20032_: clojure or erlang, if you want to expand your horizons
17:44:09 <shapr> FORTH and Joy and PostScript?
17:44:11 <zxq9> Anyway, writing real programs in horrible languages once or twice will teach you a lot about why languages matter. At least, that's my experience.
17:44:12 <mm_freak_> alex20032_: practical or interesting?  (haskell is the only language i know that has both)
17:44:23 <alex20032_> well, more pratical
17:44:30 <mm_freak_> alex20032_: then also look at haxe
17:44:35 <alex20032_> and a little interesting
17:44:55 <Iceland_jack> alex20032_: Clojure
17:45:09 <alex20032_> Well, clojure and groovy look interesting
17:45:11 <mm_freak_> i only ever recommend statically typed languages
17:45:16 <kamatsu> I'm not sure there's much in Clojure you can't learn by learning Haskell instead
17:45:25 <kamatsu> save macros and lispyness
17:45:25 <alex20032_> statically typed???
17:45:31 <mm_freak_> groovy takes PHP's badness to the JVM
17:45:45 <zxq9> alex20032_: what kamatsu said.
17:46:02 <mm_freak_> alex20032_: a statically typed languages checks types at compile time
17:46:17 <kamatsu> alex20032_: (types like "int" or "bool")
17:46:19 <alex20032_> Is C statically typed?
17:46:27 <kamatsu> ehh… mostly yes, but also no
17:46:27 <mm_freak_> alex20032_: i'd say yes
17:46:28 <ski> yes
17:46:28 <Eduard_Munteanu> Yes.
17:46:30 <jmcarthur> yes, but weakly
17:46:47 <kamatsu> if you peek just a little bit under the hood, everything in C is basically an int
17:46:47 <zxq9> When the time comes that you need to target the JVM, then is the time to worry with Clojure. Learning it isn't hard and its got a great community. It makes Javaland almost bearable.
17:46:53 <alex20032_> Does people here think that python teach good thing?
17:47:03 <mm_freak_> alex20032_: however, in C you can write:  "int x = 3;  x *= 1.5", which is weak typing (implicit conversion)
17:47:29 <kamatsu> python is a bland, uninteresting language.
17:47:32 <kamatsu> which is good for some people
17:47:41 <Iceland_jack> alex20032_: #haskell is not the place to get information about this imho
17:47:48 <kamatsu> I never saw the appeal, and some outlandish statements from its creator turned me off learning it properly.
17:47:59 <mm_freak_> alex20032_: python is a language to Get Stuff Done
17:48:10 <simpson> ^^
17:48:10 <cmccann> C's type system works on the honor system :P
17:48:26 <alex20032_> Well, when i look at python, it make me sad...
17:48:33 <zxq9> cmccann: I'm going to steal that phrase...
17:48:50 <simpson> alex20032_: How so?
17:49:18 <cmccann> zxq9: please do! hoping stuff like that catches on is half the fun :D
17:49:26 <mm_freak_> alex20032_: of all the imperative scripting languages out there python is the only language i can recommend, but i wouldn't use it for anything big
17:50:04 <alex20032_> Well, ruby look better than python
17:50:08 <alex20032_> Anyway, i think i will look out for clojure and haxe
17:50:22 <zxq9> Python's design goals are rather firmly set. Its resulted in a language that meets those goals and rejects everything else. (refusal to optimize tail recursion being one recentish argument I remember particularly well)
17:50:22 <kamatsu> According to some of my forced-to-use-Python friends, most python people can't imagine the programming world beyond python. If it's not python, it may as well not exist. I'm not sure how true that is, but that suggests that the Python community may be a little close-minded.
17:50:52 <alex20032_> by the way, is clojure and haxe used in industry?
17:50:56 <kamatsu> zxq9 the funny thing about that is that for OO modularity to work, you need tail recursion, according to Guy Steele.
17:51:03 <zxq9> alex20032_: Ruby sort of sticks you into the OOP model whether you want it or not -- which isn't good IMO. Not as bad a Java, but still silly.
17:51:07 <simpson> kamatsu: That's completely and totally bogus; I spent a good amount of the last PyCon talking about Haskell and other languages with fellow Python programmers.
17:51:14 <mm_freak_> kamatsu: the python community gets brainwashed a lot
17:51:27 <kamatsu> simpson: maybe it's just where I am, then
17:51:33 <mm_freak_> it's sad, but i guess it's just in the nature of python (as a platform)
17:51:37 <cmccann> the python community tends toward a "This Is The Right Way" mindset, possibly in an effort to be not-perl as much as possible
17:51:49 <zxq9> bingo
17:51:50 <simpson> kamatsu: I mean, if I s/Python/Java/g in your statement, it's just as "true," isn't it? >:3
17:52:04 <cmccann> which need not translate to an insular mindset about languages, but it's not hard to see why that could happen
17:52:08 <kamatsu> alex20032_:  Clojure and Haxe have some limited industry involvement, but not much.
17:52:13 <mm_freak_> simpson: the java guys actually accept new stuff
17:52:18 <mm_freak_> python rejects everything by default
17:52:34 <mm_freak_> just think of generics, introduced actually by a member of our community =)
17:52:44 <simpson> mm_freak_: There's a small subset of the Python community interested in building quality software. We're not sure why people just keep turning it down in favor of crap.
17:52:46 <kamatsu> simpson: true, but the last time I spent time with Java programmers I wasn't impressed either.
17:53:10 <alex20032> I know that Scala got use in twitter... so i tought i could also be surprised by language like haskell, clojure, haxe being used in some important thing
17:53:23 <simpson> mm_freak_: It is seriously disappointing and distressing to some of us that things like gevent, Django, etc. have become popular and even accepted as The Way of doing things.
17:53:25 <zxq9> mm_freak_: Depends on which Python community and which Java community you're talking about. Editorial power must be exercised to keep a language/library/env clean and Python's mostly is. The core Java libs is a wasteland of half-starts.
17:53:33 <cmccann> java is where the lowest common denominator of much of the software industry ends up
17:53:44 <mm_freak_> alex20032_: some of your virtual money probably made it through some haskell systems, because haskell is used in the finance world
17:53:58 <cmccann> that's going to drag the average down no matter how many excellent people also use java
17:54:15 <mm_freak_> you want fast, scalable, safe software in that industry, so haskell is a natural choice
17:54:39 <kamatsu> particularly the "safe" bit, is what attracts people to Haskell over other languages
17:54:56 <mm_freak_> for me "safe" is natural, and speed is the main attraction
17:55:01 <mm_freak_> haskell software is /fast/
17:55:14 <mm_freak_> (talking about GHC)
17:55:29 <kamatsu> fast, but sometimes you have to apply a little black magic
17:55:33 <kamatsu> or use wonderful libraries like repa
17:55:58 <mm_freak_> well, it may seem black magic to non-haskellers to change a single word in the source code and magically get a parallel program =)
17:56:07 <mm_freak_> but other than that i don't think a lot of magic is invovled
17:56:09 <mm_freak_> involved
17:56:18 <kamatsu> i mean stuff like controlling strictness or unboxing
17:56:31 <mm_freak_> honestly i seldomly control it explicitly
17:56:42 <cmccann> it's not really any more magic than other languages need for fiddly optimizing
17:56:43 <mm_freak_> idiomatic haskell is usually fast OOTB
17:56:46 <kamatsu> me too, i usually ignore it and hope for the best, and performance is usually "good enough"
17:57:14 <mm_freak_> but perhaps i just got used to using fast stuff
17:57:32 <mm_freak_> for example i don't start with String and later change to Text =)
17:58:07 <kamatsu> even Slow haskell is usually not horribly slow
17:58:24 <cmccann> pf, String? I represent strings as lists of unicode code points stored as lazy peano nats.
17:58:51 <mm_freak_> can be fast actually =)
17:59:22 <kamatsu> e.g, Agda compiles to Haskell but it puts unsafeCoerce everywhere
17:59:34 <kamatsu> these coercions mean that GHC basically does no optimization at all
17:59:46 <m3ga> i'm looking at http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#select and wondering what the ~ (tilde) does. clues?
17:59:51 <kamatsu> and yet Agda still performs reasonably well
18:00:03 <cmccann> kamatsu: you say that like it generates anything OTHER than huge piles of unsafeCoerces
18:00:10 <cmccann> I thought it somehow implemented everything that way
18:00:25 <kamatsu> m3ga:  it makes the pattern irrefutable
18:00:36 <croikle> runtime error if it fails?
18:00:43 <Eduard_Munteanu> kamatsu: hm, are you sure about the unsafeCoerce?
18:00:55 <kamatsu> Eduard_Munteanu: well, they may have fixed the erasure now
18:01:06 <kamatsu> but for a long time the MAlonzo backend just spammed unsafeCoerce
18:01:23 <mauke> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
18:01:23 <m3ga> kamatsu: thanks, does that mean that pattern match cannot fail?
18:02:00 <kamatsu> yeah, it's kind of complicated
18:02:06 <kamatsu> basically, if you have a pattern (a,b)
18:02:08 <cmccann> irrefutable patterns match everything and will cause a runtime error if it was the wrong pattern
18:02:20 <kamatsu> that will evaluate the input value to see if it matches the pattern (a,b)
18:02:22 <cmccann> if there's only one pattern, like a tuple, it makes things lazier
18:02:39 <kamatsu> if you have a pattern ~(a,b) it will believe you that the pattern matches, and will not evaluate the input value
18:03:04 <kamatsu> but if you evaluate "a" or "b" later, and the pattern did not match (impossible in this case), then you get a runtime error
18:03:27 <Eduard_Munteanu> I wonder, can't irrefutable patterns be default?
18:03:29 <m3ga> kamatsu: thanks. btw i'm erikd of fp-syd :-)
18:03:35 <kamatsu> i know
18:03:38 <kamatsu> i'm liamoc of fp-syd
18:03:39 <kamatsu> :P
18:03:46 <Eduard_Munteanu> Currently it seems like arbitrary strictness.
18:03:46 <m3ga> oh, good. cheers!
18:04:14 <cmccann> Eduard_Munteanu: seems more consistent if matching = forcing?
18:04:22 <kamatsu> Making it default would make reasoning about evaluation a lot harder
18:04:53 <Eduard_Munteanu> I thought it isn't all that common.
18:05:37 <Eduard_Munteanu> Well, and you can't do it unless there's only one case.
18:05:51 <mm_freak_> Eduard_Munteanu: if irrefutable were the default, you would have to write refutability annotations everywhere, where you have a multi-way 'case'
18:06:10 <mm_freak_> also it is actually default for newtypes
18:06:26 <mm_freak_> (because there is no different between refutable/irrefutable for newtypes)
18:06:31 <mm_freak_> difference
18:06:33 <Eduard_Munteanu> mm_freak_: how would irrefutable matching work for multiple cases?
18:06:43 <kamatsu> Eduard_Munteanu: badly, and you probably shouldn't do it
18:06:47 <mm_freak_> Eduard_Munteanu: it wouldn't…  the first case would always match
18:07:24 <Eduard_Munteanu> Erm, I forget... why does the Lazy State even bother about irrefutable patterns then?
18:07:30 <mm_freak_> also you really only need it when you're writing feedbacky code like when implementing mfix or loop
18:07:56 <c_wraith> Eduard_Munteanu: so that the pair isn't forced until it's used
18:08:23 <mm_freak_> is lazy State really implemented that way?  seems pretty stupid to me
18:08:24 <Eduard_Munteanu> Nevermind, I was thinking about newtypes, forgot.
18:08:29 <cmccann> with pairs you could always just use fst and snd
18:08:44 <Eduard_Munteanu> mm_freak_: that's the only difference in Lazy vs Strict, IIRC
18:08:45 <kamatsu> to clarify: case x of ~(a,b) ->  … is the same as let a = fst x; b = snd x; in …
18:09:01 <Eduard_Munteanu> kamatsu: yeah, sure
18:09:19 <c_wraith> or the same as let (a, b) = x in ...
18:09:30 <m3ga> is there a splitWhile function such that : splitWhile p l == (takeWhile p l, dropWhile p l) ?
18:09:32 <mm_freak_> kamatsu: (,) is a bad example
18:09:42 <kamatsu> mm_freak_: yeah, I guess so
18:09:48 <mm_freak_> case mx of ~(Just x) -> … = let x = fromJust mx in …
18:09:50 <kamatsu> m3ga:  yes
18:09:52 <kamatsu> er
18:09:52 <aavogt> > span (<3) [1 ..]
18:09:54 <lambdabot>   ([1,2],[3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
18:09:55 <kamatsu> span
18:09:56 <kamatsu> yeah
18:10:06 <m3ga> thanks!
18:10:33 <Eduard_Munteanu> Well, but for multiple cases you can't really do it unless you're defining a partial function.
18:10:33 <kamatsu> @hoogle (a->Bool) -> [a] -> ([a],[a])
18:10:34 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
18:10:34 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
18:10:34 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
18:10:47 <kamatsu> m3ga:  hoogle is your friend
18:10:48 <mm_freak_> conclusion:  you use irrefutable patterns, when you know what you're going to get, but you don't want to force it just yet
18:10:53 <shapr> hoogle is MY friend too!
18:10:56 * shapr hogs the friends
18:11:03 <kamatsu> hoogle is everybody's friend
18:11:09 <shapr> oh right!
18:11:15 <m3ga> kamatsu: i do use hoogle, often but that one escaped me
18:11:27 <Eduard_Munteanu> mm_freak_: or when you're talking about (,), I guess.
18:11:29 <mm_freak_> i don't need hoogle…  i have lots of imports in my .ghci =P
18:11:33 <m3ga> i also so use it with typ sigs
18:11:56 <mm_freak_> Eduard_Munteanu: i have used it exactly once, for (,) actually
18:12:07 <mm_freak_> it's in the implementation of 'loop' for Wire
18:12:08 <kamatsu> mm_freak_: why does that change anything?
18:12:09 <Eduard_Munteanu> So what's wrong with making it default for (,)?
18:12:12 <kamatsu> mm_freak_:  (about hoogle)
18:12:34 <mm_freak_> kamatsu: :bro, :i, :t, tab key, …
18:12:48 <kamatsu> doesn't let you type-search does it?
18:12:49 <mm_freak_> Eduard_Munteanu: why the special case?
18:12:59 * shapr :bro fists hoogle
18:13:09 <mm_freak_> kamatsu: it doesn't
18:13:10 <Eduard_Munteanu> mm_freak_: or datas with a single constructor etc.
18:13:23 <mm_freak_> Eduard_Munteanu: in most cases you actually want to match strictly
18:13:30 <kamatsu> Eduard_Munteanu: case undefined of (a,b) ->  () would crash before. Your change would break stuff.
18:13:35 <mm_freak_> Eduard_Munteanu: especially for those types
18:13:58 <mm_freak_> you really only want this, when data dependencies force you to do it that way
18:14:13 <mm_freak_> which i encountered exactly once:  mfix/loop
18:14:16 <Eduard_Munteanu> I know, but don't the same semantics arguments hold for laziness in general as well?
18:14:33 <kamatsu> i'm not sure what you mean
18:15:23 <mm_freak_> Eduard_Munteanu: irrefutable patterns don't form a paradigm
18:15:25 <Eduard_Munteanu> I mean one could argue laziness-by-default also seems to break if you're coming from strict languages. Well, I know this change would break stuff, that wasn't the issue.
18:15:52 <kamatsu> so you're proposing to change Haskell's evaluation model? seems like a radical change for what seems like no reason
18:16:04 <Eduard_Munteanu> Heh, no.
18:16:05 <mm_freak_> Eduard_Munteanu: again, practically speaking you would find yourself writing bangs everywhere
18:16:10 <mm_freak_> Eduard_Munteanu: and i mean EVERYWHERE
18:16:20 <Eduard_Munteanu> I was just saying, it is a somewhat arbitrary limitation of laziness as currently implemented.
18:16:22 <mm_freak_> except for the rare case of when you actually want nonstrict matching
18:16:32 <mm_freak_> it's not a limitation
18:16:36 <mm_freak_> it's /the/ way to force values
18:16:42 <kamatsu> it's a consistent semantics: pattern match, force values
18:16:43 <shapr> It is?
18:17:13 <mm_freak_> Eduard_Munteanu: i just don't see the value in arbitrary special cases
18:17:15 <kamatsu> if the pattern match didn't always force values, it'd be really hard to figure out what gets eval'd when
18:17:15 <Eduard_Munteanu> It is consistent, but given non-strict semantics, why not go all the way?
18:17:21 <Eduard_Munteanu> (yes, I know it's too late now)
18:17:41 <mm_freak_> yes, your proposal introduces special cases, they are arbitrary and useless in general
18:17:45 <Eduard_Munteanu> It's already pretty hard.
18:18:11 <kamatsu> it's easy if you stick to the rules: pattern matching on a constructor causes the input to be eval'd
18:18:14 <mm_freak_> i mean your proposal is arbitrary, the current model is not…  there is sound reasoning behind it
18:18:16 <cmccann> a policy of "distinguishing between constructors of a sum type forces evaluation" would also be internally consistent.
18:18:36 <cmccann> where distinguishing primitive values like Int values would be included.
18:18:47 <cmccann> it might not be a good idea, but it would be consistent.
18:18:53 <mm_freak_> construction is nonstrict, destruction is strict
18:18:53 <Eduard_Munteanu> mm_freak_: there's only one reasonable way to do it, and that's when you've got only one constructor. I don't think that's too arbitrary.
18:19:05 <mm_freak_> Eduard_Munteanu: it is arbitrary
18:19:11 <mm_freak_> just imagine you would actually do it
18:19:18 <Eduard_Munteanu> When you have multiple constructors, pattern-matching *has* to force things.
18:19:34 <kamatsu> right, so if I have a working program that depends on the irrefutability of one pattern
18:19:34 <mm_freak_> Eduard_Munteanu: no, it doesn't /have to/ force things
18:19:44 <kamatsu> then I add a new constructor, making the pattern not irrefutable
18:19:46 <mm_freak_> Eduard_Munteanu: the model is this:  construction is nonstrict, destruction is struct
18:19:54 <kamatsu> i would break an unrelated part of my program just because I added a new constructor
18:19:55 <mm_freak_> this is a reasonable model when writing corecursive code
18:19:56 <kamatsu> that's bad.
18:20:21 <mm_freak_> Eduard_Munteanu: again you would be adding a special case (making the language more complicated) for essentially no valid reason
18:20:23 <Eduard_Munteanu> kamatsu: datatypes are closed anyway, you're not supposed to treat them as open
18:20:50 <mm_freak_> theoretical soundness is not a good reason here, because it isn't sound
18:21:20 <mm_freak_> in your model you would have:  construction is nonstrict, destruction is strict, except when …
18:21:50 <cmccann> like I said, it would be "distinguishing cases is strict". :P
18:21:54 <kamatsu> Eduard_Munteanu: the thing is, my program previously depended on the pattern not causing evaluation
18:22:00 <cmccann> it's not any more complicated or arbitrary.
18:22:03 <kamatsu> even if i add another case, suddenly evaluation occurs
18:22:24 <kamatsu> so I'd have to rewrite the body of the first clause when I should only have to add a second clause
18:23:59 <mm_freak_> put differently, just like unnecessary eagerness there is also unnecessary laziness =)
18:24:31 <kamatsu> cmccann: "distinguishing cases" is just "destruction" narrowed to the special case of multiple destructors
18:24:42 <kamatsu> cmccann: still a special case
18:25:02 <mm_freak_> the proposal also requires rewriting most of base
18:25:02 <cmccann> it's a potential control flow decision
18:25:05 <mm_freak_> uncurry f (x, y) = f x y
18:25:10 <mm_freak_> the proposal would kill this function
18:25:24 <mm_freak_> uhm
18:25:30 <mm_freak_> it would kill 'curry'
18:25:39 <mm_freak_> curry f (x, y) = f x y
18:25:50 <kamatsu> @src curry
18:25:50 <lambdabot> curry f x y = f (x, y)
18:25:58 <mm_freak_> hmm…  i'm tired
18:26:05 <kamatsu> so you mean @src uncurry
18:26:09 <kamatsu> @src uncurry
18:26:09 <lambdabot> uncurry f p = f (fst p) (snd p)
18:26:16 <mm_freak_> uh
18:26:19 <kamatsu> oh, but that already uses irrefutable?
18:26:22 <kamatsu> essentially
18:26:24 <cmccann> haha
18:26:26 <mm_freak_> it does, yeah
18:26:41 <mm_freak_> GHC's strictness analysis seems to save us more often than we thought =)
18:26:54 <Eduard_Munteanu> What would be wrong with it?
18:27:23 <mm_freak_> Eduard_Munteanu: unnecessary thunks, even less predictable space behavior
18:28:07 <mm_freak_> unless optimization saves your ass =)
18:28:13 <alex20032> Well, people here say that haskell generate more "natural" code
18:28:25 <alex20032> does this more natural code is harder to reverse engineering?
18:28:39 <kamatsu> i think there's a RULE that has fst (a,b) => a etc.
18:28:55 <mm_freak_> alex20032: well, it generates code that is very different from what a C compiler would generate
18:28:57 <kamatsu> the optimizer probably disintegrates most uncurries.
18:29:04 <mikeplus64> kamatsu: i think that would just be a consequence of inlining it
18:29:14 <kamatsu> oh right, of course
18:29:16 <mm_freak_> alex20032: so you would have to learn to read haskell code first
18:29:48 <mm_freak_> alex20032: for example when you write "f(); g();" in C, f returns and g gets called
18:29:54 <mm_freak_> alex20032: in haskell chances are f just jumps to g
18:30:39 <kamatsu> except "f" and "g" are quite often pieces of one haskell function, too
18:30:46 <mikeplus64> not in IO and many other monads...
18:30:55 <mm_freak_> mikeplus64: especially in IO
18:31:03 <mm_freak_> c1 >> c2
18:31:18 <kamatsu> oh yeah, definitely in IO
18:31:28 <alex20032> But well, was just wondering is haskell is great to prevent reverse engineering...
18:31:55 <mm_freak_> alex20032: REing a haskell program is likely much more difficult
18:31:56 <kamatsu> there aren't mature reverse engineering tools to work with GHC's output
18:32:04 <mm_freak_> alex20032: especially when you compile with -threaded
18:32:10 <alex20032> If its harder, could be great to make fun of challenging friend to RE it
18:32:11 <Eduard_Munteanu> Maybe, as an unintended consequence.
18:32:22 <mikeplus64> mm_freak_: i don't see why >> would evaluate c2 then c1
18:32:46 <alex20032> And even better, haskell could be a great RE learning tool :)
18:32:46 <Eduard_Munteanu> I thought he was arguing about tail calls.
18:33:08 <ski> Eduard_Munteanu : .. i've wondered as well about implications of making tuple matching ("locally") non-strict
18:33:14 <kamatsu> alex20032: to RE haskell would probably be good idea to study GHC
18:33:24 <kamatsu> it goes through several phases of IR.
18:33:29 <mm_freak_> mikeplus64: i was talking about execution, not evaluation
18:33:32 <kamatsu> compile it through LLVM for even more crazy
18:33:33 <alex20032> IR?
18:33:39 <kamatsu> intermediate representation
18:34:04 <ski> (iow, matching on `(a,b)' would not force the tuple, but matching on e.g. `(Nothing,b)' would)
18:34:05 <Eduard_Munteanu> ski: TBH, I concede I'm not arguing about practical value. mm_freak_ / kamatsu might be right about that.
18:34:54 <kamatsu> Haskell gets typechecked, then stripped down into essentially a lambda calculus, called GHC Core, which is heavily optimised and lifted into a fragment of that Core without various features like lambdas, and then is rewritten into a normalised STG machine code, which is compiled to a low-level machinery called Cmm which is compiled to LLVM IR and then optimized some more and then compiled to machine code by LLVM
18:35:22 <mm_freak_> Eduard_Munteanu: i just can't imagineit would be elegant to have to write "f !(Cons x xs) = …" all the time =)
18:35:25 <ski> a nice consequence could be that there's no difference between `_|_' and `(_|_,_|_)'
18:35:28 <mm_freak_> Eduard_Munteanu: and yes, i work a lot with streams =)
18:35:35 <kamatsu> so the code you get at the other end has been transformed multiple times
18:35:47 <kamatsu> it's worth studying each of those transformations, it would help you to reverse engineer it
18:35:52 <ski> mm_freak_ : i thought Eduard_Munteanu was only talking about changing *tuple* matching ?
18:36:09 <mm_freak_> ski: he was talking about changing single-constructor type matching
18:36:11 * cmccann decides that ⊗ and ⊕ should be strict, & and ⅋ should be lazy
18:36:22 <Eduard_Munteanu> ski: ideally everything isomorphic to tuples, so datas with a single constructor too
18:36:26 <ski> mm_freak_ : ok. i don't think that would be a good idea
18:36:38 <mm_freak_> ski: i suppose for non-recursive types it isn't that bad
18:36:41 <kamatsu> oh crap, irrefutable streams would be bad news
18:36:52 <mm_freak_> but it would definitely lead to additional overhead
18:36:55 <alex20032_> Well, what does people here mean when saying use LLVM for backend?
18:37:01 <alex20032_> GHC dont already use it?
18:37:04 <mm_freak_> alex20032: -fllvm
18:37:10 <kamatsu> it does, you have to give it an option though
18:37:18 <mm_freak_> alex20032: it's not the default
18:37:21 <ski> (but we really should have a way to declare actual record types, and then those would work like tuples wrt matching)
18:37:21 <kamatsu> it will eventually become the default, replacing the current native code generator.
18:37:22 <alex20032_> Does using LLVM is better?\
18:37:27 <moben> mm_freak_: Are there switches to get all the  IRs? I think I saw one that gave the core once
18:37:28 <mm_freak_> the native code generator is the default on platforms that support it
18:37:35 <kamatsu> for now
18:37:41 <mm_freak_> moben: no idea
18:37:42 <kamatsu> LLVM is fairly new to GHC and is still being worked on
18:37:48 <mm_freak_> alex20032: mostly yes
18:37:52 <Eduard_Munteanu> ski: hm, like eta rules in Agda
18:37:54 <mm_freak_> not always though
18:38:02 <ski> Eduard_Munteanu ?
18:38:14 <Eduard_Munteanu> Records having eta.
18:38:16 <kamatsu> moben: -fext-core?
18:38:38 <ski> mm_freak_ : hmm, perhaps .. though `Fix'/`Mu'-tricks could be affected, i suppose
18:38:41 <Eduard_Munteanu> TBH, I don't understand why the compiler shouldn't do that for single-constructor datas too.
18:39:03 <ski> kamatsu : why would irrefutable streams be bad ?
18:39:16 <moben> kamatsu: yeah, but I meant all the other steps you mentioned :)
18:39:18 <hrumph> hi
18:39:21 <mm_freak_> ski: streams, not patterns =)
18:39:21 <ski> (i assume you meant infinite ones ?)
18:39:22 <Eduard_Munteanu> hrumph: hi
18:39:30 <hrumph> is there a function that reverses an either, sort of like swap?
18:39:43 <mm_freak_> hrumph: what would its type be?
18:39:51 <hrumph> so left becomes right and right becomes left
18:39:53 <kamatsu> @hoogle Either a b -> Either b a
18:39:53 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
18:39:53 <lambdabot> Data.Graph.Inductive.Basic unlab :: DynGraph gr => gr a b -> gr () ()
18:39:53 <lambdabot> Data.Graph.Inductive.Graph gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d
18:40:01 <kamatsu> hrumph:  doesn't look like it
18:40:07 <Eduard_Munteanu> @djinn Either a b -> Either b a
18:40:07 <lambdabot> f a =
18:40:07 <lambdabot>     case a of
18:40:07 <lambdabot>     Left b -> Right b
18:40:07 <lambdabot>     Right c -> Left c
18:40:12 <cmccann> :t Right ||| Left
18:40:13 <lambdabot> Either b a -> Either a b
18:40:15 <kamatsu> thanks djinn!
18:40:20 <mm_freak_> :t either Right Left
18:40:22 <lambdabot> Either a a1 -> Either a1 a
18:40:32 <mm_freak_> @ hrumph
18:41:12 <ski> Eduard_Munteanu : well, it certainly shouldn't do it for open or extensible sum types
18:41:36 <Eduard_Munteanu> Those would be typeclasses, or at least very much like them, no?
18:42:04 <Eduard_Munteanu> data and record are closed in that sense.
18:42:12 <kamatsu> ski are you referring to something like row polymorphism?
18:42:34 <ski> Eduard_Munteanu : and arguably, in at least some cases, a (closed, inextensible) sum type with just one alternative just "accidentally happens" to have one alternative; if you later decide you need another one, you possibly don't want that radical change
18:42:44 <kamatsu> moben: I'm not sure what the commands are, but I've used them before, so they definitely exist
18:42:51 <kamatsu> moben: they usually look like -ddump-blah
18:43:05 <Eduard_Munteanu> Yeah, probably.
18:43:09 <ski> kamatsu : hm, possibly row polymorphism would fit as well
18:44:03 <ski> mm_freak_ : i thought kamatsu was thinking about stream patterns
18:44:06 <applicative_> Main.hs -ddump-llvm -fllvm
18:44:18 <applicative_> ghc  Main.hs -ddump-llvm -fllvm , rather
18:45:08 <mm_freak_> ski: yeah
18:45:24 <ski> cmccann : hm, i was thinking a little about programming with multiplicative disjunction recently ..
18:45:39 <hrumph> ok so i use "either Right Left" as the function
18:45:46 <ski> yes
18:45:52 <kamatsu> that's the simplest answer, yeah
18:45:54 <Eduard_Munteanu> Incidentally, Agda's copatterns were demonstrated on streams.
18:46:01 <kamatsu> copatterns are nice
18:46:12 <ski> kamatsu : by which you mean ?
18:46:27 <cmccann> ski: how so?
18:46:42 <kamatsu> ski: what? copatterns?
18:46:58 <applicative_> moben: ghc -O -ddump-simpl -dverbose-core2core -dcore-lint for example
18:47:30 <ski> Eduard_Munteanu,kamatsu  : hm, you mean the `head (repeat a) = a',`tail (repeat a) = repeat a' thing (which i have called "message-dispatching" (as opposed to "pattern-matching") in the past) ?
18:47:32 <Eduard_Munteanu> I wonder if there's anything like irrefutable stuff for copatterns.
18:47:43 <Eduard_Munteanu> ski: yeah
18:47:49 <Eduard_Munteanu> http://code.haskell.org/Agda/test/features/Copatterns.agda
18:47:51 <kamatsu> ski: yes, that's a copattern
18:48:11 <Eduard_Munteanu> (I mean, if there's an analog concept)
18:49:06 <applicative_> http://www2.tcs.ifi.lmu.de/~abel/popl13.pdf
18:49:37 <applicative_> 'copatterns: programming infinite structures by observation'
18:50:17 <ski> cmccann : i was thinking about how to prove `n : ℕ , P n ⊢ P Zero , ∃ m : ℕ. P (Succ m) ≻ P m' alt. `n : ℕ , P n ⊢ P Zero ⅋ (∃ m : ℕ. P (Succ m) ≻ P m)'
18:50:32 <ski> applicative_ : ty
18:51:01 <cmccann> hm, the copattern stuff is a neat syntax. I like that better than what I had in mind for something similar...
18:51:20 <ski> cmccann : that being a contraposition of induction on naturals
18:51:45 * ski first saw "copatterns" in some papers by Erik Poll
18:52:08 * hackagebot imapget 0.0.3 - Downloads email from imap SSL servers.  http://hackage.haskell.org/package/imapget-0.0.3 (FacundoDominguez)
18:52:21 <ski> (another interpretation of "copattern" i could make is a pattern for matching on continuations)
18:52:25 * cmccann had been basically putting the "pattern match" on the RHS to express something sorta similar
18:53:28 <Eduard_Munteanu> There is something dubious about them though, at least in my mind... that makes records like that automagically coinductive.
18:54:38 <cmccann> ski: anyway, not sure how to parse that, sorry. I'm not very good with notation that's all proper-like, heh :P
18:55:01 <cmccann> what do the commas mean there?
18:57:03 <ski> @where ErikPoll
18:57:03 <lambdabot> "Subtyping and Inheritance for Inductive Types" in 1997 at <http://www.cs.ru.nl/E.Poll/papers/durham97.pdf>,"Subtyping and Inheritance for Categorical Datatypes" in 1997 at <http://www.cs.ru.nl/E.
18:57:03 <lambdabot> Poll/papers/kyoto97.pdf>,"A Coalgebraic Semantics of Subtyping" in 2000 at <http://www.cs.ru.nl/E.Poll/papers/cmcs00.pdf>,later version of that in 2001 at <http://www.cs.ru.nl/E.Poll/papers/ita01.
18:57:03 <lambdabot> pdf>
18:57:15 <ski> (mostly the second paper there)
18:57:44 <ski> Eduard_Munteanu,kamatsu ^
18:58:46 <ski> cmccann : commas to the left of `⊢' roughly means "and", think `⊗'; to the right they roughly mean "or", think `⅋'
18:58:54 <cmccann> ok, that's what I thought
18:58:57 <cmccann> just wanted to make sure
19:00:42 <ski> cmccann : `≻' is really supposed to look more like `>-', but i'm not sure whether there's an appropriate unicode glyph -- by `A ≻ B' i mean "`A' except/without/minus `B'; it is equivalent to `A ⊗ ¬ B' (`¬' here standing for linear negation)
19:01:11 <cmccann> ah, ok
19:02:11 <cmccann> ski: so that's the same as ¬(A⊸B)
19:02:38 <mikeplus64> @hoogle w (a -> b) -> m a -> f b
19:02:39 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:02:39 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
19:02:39 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
19:02:41 <ski> (some papers write `A - B', calling the connective "subtraction" -- some papers imho unfortunately write it similar to `A ≺ B' (Urbas at least))
19:02:46 <ski> cmccann : yes
19:03:52 <cmccann> ski: I've heard it called pseudo-difference in the context of paraconsistent logic
19:03:58 <ski> yes
19:04:05 <cmccann> well, dual-intuitionistic specifically
19:04:11 <applicative_> Eduard_Munteanu: doesn't data Stream a = Stream {head :: a , tail :: Stream a} seem fated to be automagically coinductive?
19:05:16 <qasd> To do reverberation: Microphone->MicroProcessor doing DSP->Output ?
19:05:21 <cmccann> ski: I was recently mulling over how a programming language built around dual-intuitionistic logic would look
19:08:31 <ski> the reason i write it as `≻' is so that i can have `Γ̄ , A ➸ B , Δ' equivalent to `Γ̄ , A ≻ B ➸ Δ'; cf. how `Γ̄ , A ➸ B , Δ' is similarly equivalent to `Γ̄ ➸ A → B , Δ' (where `➸' is just a "categorical" way of writing `⊢')
19:10:20 <ski> (so `➸' is an arrow with a head and a tail, and connects a conjunctive sequence of formulae to a disjunctive one; while `→' is an arrow with a head but no tail, connecting two single formulae; and `≻' was meant to be an arrow with a tail but no head, also connecting two single formulae)
19:10:34 <cmccann> ski: that seems sensible
19:10:59 <ski> (the idea being that the side of the symbol that is lacking marks the "contravariant/negative end")
19:11:37 <cmccann> when pondering paraconsistent logic I took to writing it as either !> or /> depending on mood to suggest a negated arrow
19:12:06 <cmccann> with -> meaning intuitionistic implication and -o linear implication
19:12:25 <cmccann> but that was mostly to serve the ability to bash things around without having convenient unicode entry :P
19:14:22 <ski> yeah, "Lolli: A Linear Logic Programming Language" <http://www.lix.polytechnique.fr/~dale/lolli/> uses `-o' for linear and `=>' for intuitionistic implication
19:15:49 <cmccann> I use & + * | for the linear connectives when I'm unicode deprived for whatever reason
19:16:46 * cmccann has been considering ideas for adapting a Haskell-ish syntax to a full linear type system
19:17:09 * hackagebot array-forth 0.2.0.5 - A simple interpreter for arrayForth, the language used on GreenArrays chips.  http://hackage.haskell.org/package/array-forth-0.2.0.5 (TikhonJelvis)
19:18:44 <ski> hm, i use `+',`*' for the additives, and `(+)',`(*)' for the multiplicatives
19:19:03 <cmccann> heh
19:19:35 <cmccann> I wanted to keep + and * meaning roughly the same thing as sum and product types in Haskell
19:19:40 <cmccann> which means the positive connectives
19:19:58 <cmccann> and & is the standard symbol for additive conjunction
19:20:04 <ski> (and `+',`×',`⊕',`⊗' when using unicode)
19:20:11 <cmccann> so | is sort of the obvious choice given those three
19:20:29 * cmccann uses & ⊕ ⊗ ⅋ obviously
19:20:46 <ski> well, product acts both additively and multiplicatively in Haskell
19:21:07 <ski> but the additive interpretation corresponds to categorical products, which is written `×'
19:21:09 <cmccann> yeah
19:21:32 <cmccann> but if you naively impose a linearity constraint on Haskell then (,) has to be multiplicative
19:21:58 <ski> hm, how do you mean ?
19:22:30 <alex20032_> Is people that talked to me earlier still here?
19:22:47 <shapr> alex20032_: depends on your question ;-)
19:22:54 <alex20032_> Well, earlier I asked what other language should i learn after Haskell
19:22:58 <alex20032_> Does R is a good language?
19:23:19 <cmccann> ski: if you require that all bound identifiers be used exactly once, modulo some handwaving due to Haskell's convoluted syntax
19:23:20 <shapr> alex20032_: It's popular for statistics.
19:23:40 <ski> (btw, i find it irritating that `⊤' is *additive* true but `⊥' is *multiplicative* false in Girard's notation .. so i use `0',`1' for the additives and `⊥',`⊤' for the multiplicatives)
19:23:42 <cmccann> then (,) and Either behave as the positive-polarity connectives
19:23:46 <alex20032_> It look like it could be a nice addition, but i am asking if its a good language, that wont teach bad thing...
19:24:19 <cmccann> ski: I've actually decided that I care much more about polarity than additive vs. multiplicative
19:24:54 <ski> polarity is certainly important, too
19:25:05 <ski> alex20032_ : how about learning Scheme with SICP ?
19:25:32 <cmccann> ski: and 1 and 0 correspond to () and "uninhabited" types in Haskell in the same way that the positive connectives correspond &c.
19:25:34 <applicative_> http://community.haskell.org/~ndm/temp/EGMitchell-ExperienceReport.pdf --  alex20032_ this discusses using R and Haskell together. R makes nice pictures I gather
19:25:42 <cmccann> this is how that linear logic encoding I wrote works, I think I showed you that
19:25:53 <cmccann> using CPS-y encoding to give a negation
19:26:19 * ski has forgotten the link to it, though
19:26:46 <cmccann> O should probably make a github gist or something instead of just an hpaste, heh
19:26:51 <cmccann> http://hpaste.org/75222
19:26:54 <ski> anyway, the following is my rough proof suggestion for the "dual-induction" on naturals
19:26:55 <cmccann> also I can't type tonight
19:27:09 <ski>   ℕedge : (n : ℕ) → P n → P Zero ⅋ (∃ m : ℕ. P (Succ m) ≻ P m)
19:27:16 <ski>   ℕedge  Zero    pZ  = {pZ,    ̄               }
19:27:35 <ski>   ℕedge (Succ m) pSm = {pz,ps | (m,pSm >-| pm)}
19:27:38 <ski>     where
19:27:42 <ski>     {pz,ps} = ℕedge m pm
19:27:56 <cmccann> ski: might be easier to use hpaste or something
19:28:09 * copumpkin nedges ski
19:28:10 <cmccann> easier for me to read that way, too :P
19:28:12 <ski> (where `>-|' is meant to look like an `↦', except "the other way around")
19:28:32 * applicative_ ℕedges ski
19:28:40 <ski> `{.. , ..}' is notation for proofs of multiplicative disjunction
19:28:47 <alex20032_> ski are you joking? how you write such expression?
19:28:50 <alex20032_> with that "n"
19:29:08 * applicative_ is learning Djest instead of R; " Djest is a purely functional, statically typed language with syntax and semantics similar to Haskell. DJest has built-in automated testing support, but with an extra perk: you don't need to write the code you are testing."
19:29:09 <alex20032_> and that arrow
19:29:15 <ski> alex20032_ : with TeX-mode in Emacs, i type `\bn'
19:29:31 <cmccann> applicative_: haha
19:29:32 <shapr> applicative_: Never heard of it, sounds interesting
19:29:37 <applicative_> "Djest uses a Djinn-like satisfier which searches for functions of a given type." https://github.com/luqui/Djest
19:29:40 <ski> alex20032_ : btw, note that the code above isn't Haskell
19:30:12 <applicative_> "The generated functions are then tested with the test suite until one that passes all the tests is found, at which point that function is taken as its definition. If it uses the wrong function, then clearly your test suite was not comprehensive!"
19:30:25 <cmccann> applicative_: that is awesome, hahaha
19:31:09 <cmccann> applicative_: if djinn was a little less uptight wouldn't be too hard to hack something using quickcheck to do that kinda thing
19:31:52 <ski> cmccann : `  ̄ ' is the "failing expression" (right-weakening), and `.. | ..' is an "ambiguous expression" (right-contraction)
19:32:10 <ski> the latter equation could alternatively be written as
19:32:18 <ski>   ℕedge (Succ m) pSm = {  ̄ , (m,pSm >-| pm) } | ℕedge m pm
19:33:28 <ski> applicative_ : that sounds a bit like Inductive Logic Programming (ILP)
19:34:40 <ski> cmccann : operationally, it starts by boldly claiming the given `n' is an example of an `m' such that `P (Succ m)' is true but `P m' false
19:34:51 <cmccann> hm
19:35:03 * cmccann tries to figure out what all this syntax is doing
19:35:30 <ski> cmccann : if someone later manages to prove `P m' false (calling the bluff), then it goes back, and binds `pm' to that proof, and uses the recursive call to bind `pz' and `ps' as alternative solutions
19:35:54 <ski> if it ever gets down to `Zero', it proves the other alternative directly instead
19:36:08 <cmccann> right, that's basically how stuff using ⅋ works
19:36:46 <ski> yes, but there's implicit `?'s involved in the above as well (weakening and contraction)
19:37:05 <cmccann> yeah, and the assumptions about what's in scope makes me nervous
19:37:06 <flebron> please tell me ⅋ is not some lens operator
19:37:17 <ski> flebron : it's a connective in linear logic
19:37:20 <cmccann> flebron: not yet at least
19:37:31 <cmccann> I couldn't make my linear logic stuff work with lenses properly
19:37:35 <alex20032_> I am currently starting a programming club at my college
19:37:47 <alex20032_> Unfortunately, i will be the only one using Haskell....
19:37:50 <cmccann> (though lenses are closely related to linear implication for obvious reasons)
19:38:01 <flebron> i have enough trouble writing &, ⅋ would just be impossible
19:38:02 <ski> derivationally, a cut makes the `pm' bound by `pSm >-| pm' available in the other `|'-branch
19:38:33 <ski> alex20032_ : at least until you've managed to convince others to try it :)
19:38:35 <flebron> just as impossible as \zeta or \xi
19:39:01 <cmccann> flebron: just write & while standing on your head
19:39:02 <alex20032_> Well, most of people that will join the club will have no programming pior experience, and will be here to learn and do small project
19:39:03 <cmccann> problem solved
19:39:09 <flebron> :p
19:39:24 <cmccann> flebron: or just write ⊗ and then dualize
19:39:32 <alex20032_> Is there any good language to learn FP even good for people that never did programming before?
19:39:40 <cmccann> alex20032_: scheme?
19:39:52 <flebron> i learned haskell as a first language at least in university
19:40:02 <flebron> (i did have experience beforehand, but the first language was indeed haskell)
19:40:23 <alex20032_> well, does scheme is easy enough to teach FP to people that dont have a strong math background, and never writted a line of code before?
19:40:45 <alex20032_> It need to be very easy on syntax
19:41:32 <cmccann> ski: anyway, it sounds plausible but I'm leery of the notation and implicit modal operators so I dunno
19:41:45 <ski> cmccann : anyway, in the above proof, it seems a bit irritating to have to "carry along" `pz' through the recursive calls -- it would be nicer if one could do something similar to "using a non-local variable" .. like :
19:41:46 <Eduard_Munteanu> It's got no syntax, how's that?
19:41:52 <cmccann> I'm too used to writing stuff in a horrid ASCII shorthand for sequent calculus
19:41:53 <ski>   ℕedge n pn = {pZ,loop n pn}
19:41:56 <Eduard_Munteanu> :P
19:41:59 <ski>     where
19:42:07 <ski>     loop : (n : ℕ) → P n → ∃ m : ℕ. P (Succ m) ≻ P m
19:42:16 <ski>     loop  Zero    pZ  =  ̄
19:42:24 <ski>     loop (Succ m) pSm = (m,pSm >-| pm) | loop m pm
19:42:36 <cmccann> (also, I'm not a fan of implicit modal operators if you're trying to work within linear logic)
19:42:47 <Iceland_jack> alex20032_: Are you planning on introducing people with no programming experience to a language that you don't know yourself?
19:42:53 <ski> .. except that this is really "defining a non-local variable" :)
19:43:35 <ski> cmccann : yes, i'll have to think more about the modals -- this is just a dump of what i was thinking up yesteryesterday ;)
19:43:58 <alex20032_> Iceland_jack: no
19:44:06 <ski> (note how the pattern-matching in the base case above binds `pZ' which is used in the first line)
19:44:36 <alex20032_> Iceland_jack: i will wait to have at least 1 year experience before introduction anyone to something
19:44:51 <Iceland_jack> As you wish
19:44:54 <ski> alex20032_ : i think Scheme is reasonaly simple to learn
19:45:27 <ski> alex20032_ : more important initially will probably be finding motivation and interesting examples and problems to read about and work on
19:45:34 <Iceland_jack> Scheme is very minimalistic, quite different syntactically from other languages
19:45:34 <decrement> What about Common Lisp?
19:45:47 <Iceland_jack> but if they have no experience with programming maybe that's not such a barrier
19:46:03 <ski> decrement : i think Scheme is better than Common Lisp, as a first language
19:46:25 <alex20032_> Scheme was developped as teaching language
19:46:59 <ski> cmccann : .. anyway, i've been trying to understand multi. disj. computationally better for some time -- the above is one more step in doing so, i think
19:47:12 <applicative_> scheme has an excellent manual
19:47:24 * ski . o O ( which Scheme ? )
19:47:33 <hpaste> gwern pasted “rot13 finder” at http://hpaste.org/80439
19:47:34 <Iceland_jack> ski: don't start that!
19:47:40 <cmccann> ski: after spending several months pondering that I eventually decided that the good old continuation-y understanding makes the most sense
19:48:08 <ski> Iceland_jack : as in : which Scheme did applicative_ mean had an excellent manual
19:48:25 <Iceland_jack> my bad
19:49:45 <cmccann> ski: i.e. computationally a multiplicative disjunction is a continuation that takes a bunch of continuations as input
19:50:19 <alex20032_> But well, does FP should be taught at university level, or college level is also good to teach FP?
19:50:21 <gwern> the hpaste is anent https://plus.google.com/103530621949492999968/posts/J5TxoMpAcsB fwiw
19:50:45 <shapr> alex20032_: I think primary school is a good place to start.
19:50:54 <gwern> still amused that irk/vex rot13 into each other
19:51:11 <alex20032_> shapr: at primary school, they barely even know what is a function
19:51:36 <shapr> alex20032_: Partially a joke :-)
19:52:21 <luite> shapr: hm, but why not?
19:52:24 <shapr> I do think electronics and programming would be best taught early.
19:52:42 <alex20032_> shapr: yes, but maybe not FP
19:52:48 <luite> i guess many of us here started programming then, or perhaps tinkering with electronics :)
19:52:51 <alex20032_> FP more early, but not too much early
19:53:35 <alex20032_> But yeah, some basic programming & electronics course at 10 year old would be great
19:53:46 <shapr> luite: I started programming at age 11
19:53:52 <alex20032_> programming could even start at 8 year old
19:54:07 <shapr> A guy I knew won a computer in a contest, that's the only reason I was exposed so early.
19:54:10 <luite> shapr: what ages is primary school?
19:54:59 <shapr> 5-12
19:55:06 <luite> ah 6-12 in the netherlands
19:55:14 <alex20032_> FP programming should be taught at 16 year old, considering they had learned programming at 10 year old. At 16 year old, they have enough logical skill to get started
19:55:31 <shapr> alex20032_: So what age will you learn FP? :-)
19:55:43 <shapr> I started learning FP at age 30!
19:55:49 <alex20032_> well, currently 5 year old
19:55:55 <alex20032_> so i am perfect for this
19:55:55 <ski> (btw, the contraposition of strong/complete induction, `(∀ a. (∀ b. b < a → P b) → P a) → ∀ a. P a', is the least number principle `(∃ a. P a) → ∃ a. P a ≻ ∃ b. b < a ∧ P b')
19:56:15 <luite> alex20032_: is that in dog years?
19:56:19 <ski> cmccann : yes, but it's not so clear what the implications of this is for values
19:56:31 <cmccann> ski: what do you mean?
19:56:34 <ski> cmccann : .. and for how to program (exclusively, or mostly) in terms of values
19:56:53 <ski> how to think about *values* in a mult. disj. type ?
19:56:55 <alex20032_> well, right, you won, i am currently 19 year old. but only if they have taught us programming when we where kid...
19:57:14 <alex20032_> everything could be better
19:57:33 <blackdog> anyone tried doing hadoop-y stuff in haskell?
19:57:58 <blackdog> (or near-enough? having a bit of a look at hive and pig, but am not terribly enthused so far)
19:58:03 <ski> shapr : .. we started learning some Logo in first or second class
19:58:05 <shapr> alex20032_: The earliest you can start is now!
19:58:05 <cmccann> ski: computationally I don't think there really are "values" in a multiplicative disjunction as such
19:58:09 <shapr> ski: oh that's cool!
19:58:17 <cmccann> if you want to get a value out of it you have to rule out all the others
19:58:38 <ski> shapr : .. though the computers got stolen, at which point we couldn't continue with that :(
19:58:40 <cmccann> by providing continuations, i.e. negated values &c.
19:58:57 <shapr> :-(
19:59:09 <ski> (it might have been Commodore 64's, or 128's, i'm not sure)
19:59:23 <shapr> My first computer was http://en.wikipedia.org/wiki/Timex_Sinclair_1000
19:59:52 * ski started programming at a programmable calculator which he got around age 6.5
20:00:34 <ski> cmccann : yes
20:02:20 * Iceland_jack started programming when she was 2
20:02:58 <shapr> Iceland_jack: cool!
20:03:04 <Adnauseam> cool parents
20:03:22 <shapr> Now I want to work my way up to the same number of yearly github contributios as tibbe
20:03:28 <shapr> That's my next goal!
20:04:10 <ski> cmccann : i think proving `∀ p : ℕ. Prime p → (p | 1 → ⊥) ∧ (∀ a,b : ℕ. p | a · b → p | a ∨ p | b)' would naturally use multiplicative methods when proving the disjunction
20:04:51 <alex20032_> ski all you are currently writting, all those equation, are like chiness for me
20:05:15 <alex20032_> Where could i learn those thing?
20:05:16 <shapr> alex20032_: That means there's lots of great stuff to learn here!
20:05:17 <ski> and `∀ m,n : ℕ. m ≤ n ∨ m ≥ n' ought to be possible to prove in an unbiased way
20:05:24 <shachaf> alex20032_: China.
20:05:25 <shapr> alex20032_: ∀ means forall
20:05:29 <shapr> shachaf: be nice
20:06:52 <cmccann> ski: sorry, I'm still having a hard time keeping up with your notation :[
20:07:14 <shapr> alex20032_: most of those symbols have to do with logic: http://en.wikipedia.org/wiki/List_of_logic_symbols
20:07:16 <ski> these last things are just normal logic notation
20:07:42 <ski> (`p | n' being the traditional math notation for the proposition tnat `p' divides `n')
20:07:59 <cmccann> ok
20:08:26 <ski> (s/tnat/that/)
20:10:15 <ski> (at least the proof that i've seen of the prime one above starts that subproof by assuming `p | a · b' and the negation of `p | a', and then proves `p | b' -- there is a definite "negative polarity" feel to this, i think)
20:10:55 <cmccann> yeah
20:10:59 <josiah14> I'm having trouble with my xmonad config regarding ResizableTall
20:11:15 <josiah14> Can anyone here help me with this?
20:11:42 <aavogt> josiah14: there's an #xmonad channel too
20:11:42 <josiah14> -- dzen2 plus conky config with urgency for xmonad-0.9* -- uses icons from dzen.geekmode.org import XMonad import XMonad.Core   import XMonad.Prompt import XMonad.Prompt.Shell import XMonad.Prompt.Man   import XMonad.Layout import XMonad.Layout.NoBorders import XMonad.Layout.ResizableTile   import XMonad.Hooks.DynamicLog import XMonad.Hooks.ManageDocks import XMonad.Hooks.ManageHelpers import XMonad.Hooks.UrgencyHook import XMonad.H
20:11:56 <josiah14> aah, didnt copy right
20:11:59 <simpson> josiah14: hpaste.org
20:12:04 <simpson> Please.
20:12:16 <ski> josiah14 : fyi, there's also an #xmonad channel
20:12:35 <josiah14> wasn't mentioned in the wiki, thanks Ski
20:12:43 <bobajett> noob question: how do I write a function smallString that takes a long string and returns the substring of words less than 80 characters long? so for example
20:13:56 <josiah14> I don't have access to hpaste, simpon - using pastebin
20:13:57 <bobajett> smallString "I am a long string ... words past 80 characters" -- would return "I am a long string ... words" where the 80 characters say falls in the middle of the word "past"
20:14:14 <cmccann> ski: so for the second bit you'd have something like ¬(p | a · b) ⅋ (p | a) ⅋ (p | b) I assume
20:14:23 <bobajett> s/where the 80 characters/where the 80th character/
20:14:46 <ski> cmccann : or an implication for the first part
20:14:47 <bobajett> in other words justifying a long line to be within 80 characters long
20:14:53 <cmccann> ski: same difference
20:14:59 * ski nods
20:15:16 * ski idly wonders what "same difference" means exactly
20:15:40 <cmccann> ski: you could have ¬(p | a) ⊗ ¬(p | b) → ¬(p | a · b) instead if you wanted
20:15:58 <cmccann> i.e. if you prove it divides neither, you prove it doesn't divide the product
20:16:00 <josiah14> Simpson -> http://pastebin.com/W445aBbN
20:16:06 <mauke> The paste W445aBbN has been copied to http://hpaste.org/80442
20:16:17 <cmccann> er, prove it doesn't divide each, rather.
20:16:19 <cmccann> or something.
20:16:23 <cmccann> you know what I mean.
20:17:12 <josiah14> error is the first argement of ($) takes one argement, but its type `ResizableTall a0` has none
20:17:13 <ski> you mean what i know
20:17:15 <croikle> > map unwords . inits . words $ "take some words"
20:17:17 <lambdabot>   ["","take","take some","take some words"]
20:18:05 <croikle> > last . filter ((<10) . length) . map unwords . inits . words $ "take some words" -- bobajett
20:18:07 <lambdabot>   <hint>:1:26: lexical error at character '\FS'
20:18:33 <cmccann> ski: I assume the conjunction would be multiplicative as well, no additive connectives at all
20:18:36 <croikle> hm.
20:19:18 <croikle> works on my machine
20:19:30 <bobajett> croikle: thanks! makes total sense.
20:19:41 <croikle> there may be better ways
20:19:46 <croikle> probably using lenses :)
20:20:47 <ski> > (unwords . last . takeWhile ((30 >=) . length . unwords) . inits . words) "I am a long string ... words past 30 characters"  -- not so nice
20:20:49 <lambdabot>   "I am a long string ... words"
20:21:19 <ski> cmccann : in that example, yes
20:22:12 * hackagebot maxent 0.3.0.1 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.3.0.1 (JonathanFischoff)
20:22:28 <shapr> alex20032_: Does that wikipedia link help?
20:23:02 <alex20032_> Yes a little
20:23:09 <alex20032_> i am familiar with some of thing here
20:23:25 <croikle> ski: yeah, takeWhile is more robust there than my filter
20:23:27 <alex20032_> currently reading https://mooculus.osu.edu/textbook/mooculus.pdf
20:23:39 <alex20032_> I took a course on calculus at coursera
20:23:43 <alex20032_> and this is the textbook
20:24:32 <josiah14> my issue got resolved, thanks, ski, for making me aware of the xmonad channel
20:25:12 <alex20032_> Well, does people here have ressource on when we have 2 function that we fuse to do 1 function?
20:25:26 <alex20032_> like f(x) + g(x) = something
20:25:29 <alex20032_> in math
20:25:36 <alex20032_> i think its called composite, not sure
20:26:24 <shapr> function composition?
20:26:24 <bobajett> alex20032_: that would be a composite function, but what is it that you're trying to do?
20:26:25 <croikle> composing is like f(g(x))
20:26:49 <alex20032_> well, i just want to learn how it work
20:26:56 <cmccann> ski: I'm not sure about "∀ m,n : ℕ. m ≤ n ∨ m ≥ n" though, might be troublesome when they're equal
20:27:00 <alex20032_> how to add 2 function, and know what will be the result
20:27:12 <cmccann> feels like one of those places where the two disjunctions are conflated
20:27:15 <croikle> > liftA2 (+) (+1) (*2) 5
20:27:17 <lambdabot>   16
20:30:12 <ski> > (unwords . unfoldr (\(n0,ws) -> case ws of [] -> Nothing; w:ws -> let n1 = n0 + 1 + length w in guard (30 >= n1) >> Just (w,(n1,ws))) . (,) (-1) . words) "I am a long string ... words past 30 characters"  -- hrm
20:30:14 <lambdabot>   "I am a long string ... words"
20:30:43 <ski> josiah14 : yw
20:31:13 <cmccann> ski: anyway sorry I'm not very good with the whole "actually proving stuff" thing :P
20:31:33 <ski> cmccann : yea, it's exactly the case when both are equal that i'm interested in
20:31:46 <ski> i want a proof that isn't biased to the left or to the right
20:32:34 <Eduard_Munteanu> Trichotomous!
20:33:00 <monochrom> when m=n, you can prove both
20:33:03 <bobajett> alex20032_: coming from calculus f(x) + g(x) means just "adding" the result of the two functions together - it doesn't map that well to a general concept in Haskell. You'd have to define what the "+" function was in haskell?
20:33:10 <cmccann> I think you end up with a different value of truth for the case when they're equal
20:33:21 <ski> monochrom : yes, but how do i refrain from having to pick one side ?
20:33:24 <cmccann> because there's nothing you can do with 1⅋1
20:33:26 <Eduard_Munteanu> ∀ m,n : ℕ. m < n ∨ m = n ∨ m > n
20:33:41 <ski> Eduard_Munteanu : doesn't work for reals
20:33:43 <cmccann> 1⅋1 is true but it's not equivalent to 1
20:34:07 <bobajett> ski: I was originally just trying to wrap my head around how I would go about writing that smallString function without even the use of filters - just basic recursion.
20:34:08 <Eduard_Munteanu> ah, missing context
20:34:52 <alex20032_> bobajett: Just adding the result of the 2 function, or does it also mean adding the body of the 2 function?
20:34:57 <ski> (Eduard_Munteanu : though above `m' and `n' were naturals)
20:34:58 <alex20032_> well, if I have f(x) = x+2, and got g(x) = 3x +1, then does h(x) = f(x) + g(x) will be 4x +3?
20:35:47 <bobajett> alex20032_: in calculus yes :-)
20:35:52 <ski> bobajett : ok -- so a worker/wrapper with the worker having an accumulator which count the characters emitted so far, and cuts off when it gets too high ?
20:36:07 <alex20032_> why, there is other math field where it will be no?
20:36:16 <alex20032_> Since you said "in calculus yes"
20:36:28 <bobajett> ski: that sounds promising, I'll try that.
20:37:09 <bobajett> alex20032_: well this being a haskell channel and not a math/calculus channel, I wasn't sure if you were trying to map that to something in haskell.
20:37:13 <hayashi> If you're making a package and it's under the 2-clause BSD licence, would that count as BSD3 for Cabal or would you specify OtherLicense?
20:38:19 <parcs> probably OtherLicense
20:38:26 <monochrom> I don't know. but cabal-install seems to have many licenses memorized.
20:39:01 <cmccann> ski: anyway I'm still tossing ideas around in the back of my head for a linear language, you interested in seeing any of that when I get around to writing stuff up a bit?
20:39:03 <monochrom> so, create a scratch directory, "cabal init" there, select BSD3, then see if the generated LICENSE file suits you
20:40:27 <ski> cmccann : yes
20:40:50 <monochrom> although, BSD3 seems to have 3 clauses, not 3
20:40:55 <monochrom> err, s/not 3/not 2/
20:41:43 <hayashi> http://hackage.haskell.org/trac/hackage/ticket/854 <- ah
20:41:50 <hayashi> OtherLicense it is then~
20:42:48 <hayashi> afaik the main difference between bsd3 and bsd2 is that bsd3 has a clause stating that the names of contributors cannot be used for the purposes of advertising etc
20:43:33 * M30W installs darcs... Versioning error; heh.
20:44:04 <hayashi> though freebsd then add a disclaimer about views and opinions, meh
20:45:01 <cmccann> ski: you'll have to survive without implicit modality though :P
20:47:38 <ski> cmccann : no worry :)
20:48:34 <cmccann> ski: using linear logic connectives to define data types seems potentially interesting
20:50:27 <cmccann> and I think I may steal some ideas from that copattern stuff to get a nicer syntax for some constructions
20:53:35 <ski> yes
20:54:10 <cmccann> much nicer than reverse pattern matching based on the RHS which is what I had most recently
20:54:16 <cmccann> looked really confusing
20:56:45 <bobajett> an even more basic question, how would I write python's join function (without using the std library functions?) for example ["foo","bar","baz"].join("-") => "foo-bar-baz"?
20:57:14 <ski> cmccann : ooc, how did your "reverse pattern matching based on the RHS" look like ?
20:57:15 * hackagebot process-conduit 0.5.0.5 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-0.5.0.5 (HideyukiTanaka)
20:57:36 <cmccann> lemme see if I have an example in my notes
20:59:40 <shachaf> bobajett: Why do you want to do it without standard library functions?
20:59:52 <hpaste> glguy pasted “python join, no std lib” at http://hpaste.org/80444
20:59:59 <glguy_> bobajett: you could do that
21:00:10 <shachaf> glguy_: (++) counts.
21:00:20 <simpson> @src intercalate
21:00:21 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
21:00:29 <glguy_> shachaf: but I wrote about that on line 1
21:00:39 <glguy_> shachaf: ++ is left as an exercise for the lambdabot
21:00:45 <shachaf> @src intercalate
21:00:45 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
21:00:48 <shachaf> @src intersperse
21:00:48 <lambdabot> intersperse _   []     = []
21:00:48 <lambdabot> intersperse _   [x]    = [x]
21:00:48 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
21:00:52 <shachaf> @src concat
21:00:53 <lambdabot> concat = foldr (++) []
21:00:55 <shachaf> @src foldr
21:00:55 <lambdabot> foldr f z []     = z
21:00:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:01:00 <shachaf> There. No standard library functions left.
21:02:07 <bobajett> shachaf: Im just trying to get the hang of writing basic haskell functions :-)
21:02:16 <glguy_> shachaf: you forgot ++!
21:02:30 <shachaf> glguy_: ++ is left as an exercise for the lambdabot
21:02:39 <shachaf> (Didn't we just go through this?)
21:02:55 <monochrom> glguy means that shachaf forgot @src (++)
21:03:08 <shachaf> bobajett: The way to write basic Haskell functions is usually to base them on even more basic Haskell functions.
21:03:18 <monochrom> at which point, it becomes an exercise for the finger
21:03:19 <shachaf> Writing things from scratch all the time is clumsy.
21:03:38 <shachaf> monochrom: I did the equivalent of what glguy_ did, except by using lambdabot instead of writing it myself.
21:04:00 <shachaf> If (++) is allowed, then it's allowed for me.
21:04:02 <shachaf> @src (++)
21:04:02 <lambdabot> []     ++ ys = ys
21:04:03 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
21:04:03 <lambdabot> -- OR
21:04:03 <lambdabot> xs ++ ys = foldr (:) ys xs
21:04:08 <monochrom> anyway, it's basic haskell functions all the down
21:04:11 <Clint> more useful to write useful things instead
21:04:14 <monochrom> err, all the way down
21:04:41 <bobajett> glguy_: thanks, I actually I did manage to stumble my way close to the intersperse implementation myself.
21:05:30 <bobajett> shachaf: I agree it would be clumsy to always try to write from scratch, but Im at a point in my fledgling haskell career where I couldn't even figure out how to write something simple as a "join" using basic haskell :-)
21:05:40 <monochrom> fortunately, "useful" can mean "useful for learning", which is license for re-inventing a few things
21:06:35 <monochrom> and the advantage of writing myconst for learning purpose is that you have const to test against
21:07:35 <shachaf> bobajett: Python's "join" (which is different from the Haskell function by the same name, by the way) isn't all that simple.
21:08:20 <shachaf> You should implement very simple parts of the standard library to learn.
21:08:34 <shachaf> Then you can use these to build up more complicated things like pythonJoin
21:09:00 <simpson> :t concat .: intersperse
21:09:01 <lambdabot> [a] -> [[a]] -> [a]
21:09:09 <simpson> D'oh. Close.
21:09:30 <shachaf> @ty intercalate
21:09:31 <lambdabot> [a] -> [[a]] -> [a]
21:10:12 <simpson> Oh, I guess intercalate is right, isn't it?
21:10:48 <c_wraith> how did that function ever end up with that name, anyway
21:11:00 <cmccann> ski: sorry, got distracted for a bit there
21:12:00 <hpaste> “C. McCann” pasted “fake syntax example for ski” at http://hpaste.org/80445
21:12:05 <cmccann> something like that
21:12:27 <cmccann> I had more interesting examples from when I was experimenting with syntactic styles but couldn't find where I put those :[
21:12:30 <bobajett> shachaf: ah yep agree with you on Python's join. And yep that's a good idea, I got a little intimidated looking at some standard library's source, but I think GHC.List is a good place for me to start.
21:13:29 <cmccann> ski: the idea there being that the equation is chosen based on case analysis of the RHS, i.e., which is demanded
21:13:42 <c_wraith> "C. McCann"?  What a mysterious name.
21:13:57 <c_wraith> I will probably never figure out who that is.
21:14:08 <monochrom> sample code in the Haskell 2010 Report is optimized for human communication. sample code in GHC is optimized for computer bit-pushing
21:14:08 <cmccann> very mysterious, yes.
21:15:35 <bobajett> monochrom: cool, thanks for that tidbit, I was just thinking I'll need to parse out the compiler directives as I read through GHC.List.
21:16:01 <johnw> byorgey: ping
21:16:04 <ski> cmccann : aye, that looks weird
21:16:20 <cmccann> ski: it does make a certain amount of sense
21:16:26 <hrumph> is there an either type where as a functor fmap works on the left field instead of the right?
21:16:55 <hrumph> i.e. where the right field is for errors and so forth and the value is in the left field
21:16:57 <ski> cmccann : would make more sense if you had written `unFst',`unSnd' or something ..
21:17:05 <monochrom> no, or not easily
21:17:12 <ski> :( you use `&' in expressions^Wpatterns
21:17:12 <johnw> hrumph: it's not hard to construct one
21:17:24 <hrumph> johnw: i know but i thought that one might be standard
21:17:32 <cmccann> ski: I ended up ditching several features of that syntax for various reasons
21:17:43 <hrumph> actually it may not be helpful
21:18:16 <hpaste> Hrumph pasted “I came up with this” at http://hpaste.org/80447
21:18:21 * samantha waves
21:18:30 <hrumph> what i pasted is my provisional solution to the problem
21:18:33 * SamanthaD waves
21:18:52 <cmccann> ski: it was worse originally, when I wrote it all on one line and left the choice implicit, e.g. "with (f & g) x = f x & g x"
21:18:57 <shachaf> bobajett: Try the Report instead.
21:19:18 <shachaf> bobajett: It has a "reference" Prelude which is much simpler than a lot of the actual implementations.
21:19:21 * simpson waves back
21:19:25 <cmccann> ski: and the exact same thing with + instead of &, where the dependency went in the other direction
21:19:45 <cmccann> it was madness and it ended up having incomprehensible rules for scope and exhaustive pattern checking
21:19:56 <Clint> hrumph: do you want a bifunctor?
21:19:56 <hrumph> what do y'all think of my operator def?
21:20:03 <hrumph> i don't know what i want
21:20:14 <hrumph> never heard of a bifunctor
21:20:27 <Clint> http://hackage.haskell.org/packages/archive/bifunctors/3.0.3/doc/html/Data-Bifunctor.html
21:20:38 <ski> cmccann : actually, i prefer `with (f & g) x = f x & g x' to the version in the paste :)
21:20:55 <cmccann> ski: yes, it looked much nicer for simple stuff
21:20:55 <hrumph> oh i see so its like a functor but with two alternate fmaps
21:20:57 <shachaf> hrumph: There's surely a simpler implementation, but that operation is reasonable.
21:21:01 <M30W> rejecting: base-3.0.3.2, 3.0.3.1 (global constraint requires installed instance)
21:21:02 <bobajett> shachaf: nice! thanks.
21:21:03 <shachaf> Lots of things provide it, like bifunctor and lens.
21:21:05 <shachaf> @ty over _left
21:21:07 <lambdabot> (a -> b) -> Either a c -> Either b c
21:21:09 <M30W> rejecting: base-4.6.0.0/installed-910... (conflict: darcs-2.8.3:force-char8-encoding => base>=4 && <4.4)
21:21:12 <M30W> Hmmm
21:21:22 * ski is possibly in favor of those "incomprehensible rules for scope and exhaustive pattern checking" ;)
21:21:27 <cmccann> ski: but it didn't scale well. something like that is still on the longer-term wish list for syntactic sugar though.
21:21:39 <SamanthaD> I need help with filter. I have an algorithm that requires me to filter a list based on an algorithm that requires the progressive output of the afforementioned filter as an argument... the problem is a typical filter algorithm doesn't have its output available for its conditional. Is there a standard way of going about this?
21:22:03 <cmccann> ski: I mean incomprehensible rather literally, I could not comprehend the rules it would require and thus could not figure out anything I was confident actually worked :P
21:22:19 <shachaf> SamanthaD: There are lots of ways, depending on what exactly you need.
21:22:27 <M30W> Anyone have any suggestions for getting darcs to install?
21:22:44 <Clint> apt-get install darcs
21:22:50 <SamanthaD> shachaf: here... let me show you the function that need to be called as the filter's conditional.
21:22:53 <cmccann> ski: it mostly got weird when there were multiplicatives involved as well and I tried to make sense of implicitly distributing multiplication over addition
21:22:57 <shapr> M30W: What operating system?
21:22:58 <SamanthaD> shachaf:
21:23:03 <SamanthaD> shachaf: > divPrime :: Integral a => [a] -> a -> Bool
21:23:03 <SamanthaD> > divPrime (d:ds) n | divides d n = False --n is not prime.
21:23:04 <SamanthaD> >                   | d ^ 2 > n   = True  --n is prime.
21:23:04 <SamanthaD> >                   | otherwise   = divPrime ds n
21:23:04 <M30W> cli	Not on debian/ubuntu lol.
21:23:05 <lambdabot>   <hint>:1:19: parse error on input `|'
21:23:05 <lambdabot>   can't find file: L.hs
21:23:05 <lambdabot>   can't find file: L.hs
21:23:12 <M30W> shapr: Archlinux.
21:23:20 <cmccann> ski: of course that definition of "with" is actually doing that in a trivial way
21:23:30 <shachaf> SamanthaD: You should probably either collapse your code into a few lines or paste it on hpaste.org when you're pasting code.
21:24:02 <ski> cmccann : yeah, i've been pondering such things as "implicitly distributing multiplication over addition" myself
21:24:03 <SamanthaD> shachaf: oh, okay... let me try to figure out this hpaste.org thing. Give me a moment.
21:24:24 <alex20032_> Haskell, the perfect language to do fractal!
21:25:06 <refried_> i have a probably-stupid question...
21:25:36 <refried_> If I've got a list l that contains sub-lists a,b,c,d
21:25:52 <refried_> well, i have a list of unknown length, that contains sublists
21:26:35 <M30W> shapr: cabal install darcs |& ix # http://ix.io/3Ux
21:27:26 <hrumph> is bifunctor not part of the standard packages?
21:27:37 <refried_> and i want to create a new list of sublists where each of the sublists contains exactly one element from each of the original a,b,c,d sublists
21:27:40 <refried_> *confusing*
21:27:41 <johnw> hrumph: it's not part of the core libraries, no
21:28:06 <shapr> M30W: whoa, I dunno about that.
21:28:09 <fragamus> I'm having very serious performance problems
21:28:18 <hpaste> “Samantha Davis” pasted “Prime Number Test” at http://hpaste.org/80448
21:28:19 <hrumph> ok i'll stick whith me operator for now. i was going to use bifunctor with the 'second' function but it doesn't matter
21:28:25 <johnw> refried_: you want ([a] -> a) -> [[a]] -> [[a]]?
21:28:26 <fragamus> and no I'm not talking about the bedroom
21:28:28 <shapr> fragamus: You want to make your library larger?
21:28:34 <SamanthaD> shachaf: http://hpaste.org/80448 there you go!
21:28:37 <alex20032_> Is it possible to write some librairie in haskell and call them from C?
21:28:40 <shapr> fragamus: How to produce more Haskell source in a shorter amount of time?
21:28:47 <monochrom> yes
21:28:48 <fragamus> yes
21:28:52 <SamanthaD> shachaf: the relevant part is right at the very bottom.
21:28:55 <fragamus> give this thing to me
21:29:06 <croikle> > do {x <- [1,2]; y <- [3,4]; return [x,y]}
21:29:08 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
21:29:18 <shapr> fragamus: It is simple, surprisingly...
21:29:37 <shapr> fragamus: regular and consistent amounts of exercise, food, and sleep. And no alcohol. And coffee.
21:29:47 <shapr> oh and a serious course of self-study
21:30:02 <refried_> johnw: I think I wanna do like what croikle just did, except where the two lists are passed in as [[1,2],[3,4]] instead of separately
21:30:12 <shapr> fragamus: Is that what you wanted?
21:30:17 <fragamus> um
21:30:54 <refried_> or maybe I pass in [[1,2],[3],[5,6]] and get [[1,3,5],[2,3,5],[1,3,6],[2,3,6]]
21:31:13 <refried_> is that sequence?
21:31:29 <fragamus> well I'm wrote an algorithm and set it to run for 10 iterations it worked fine and scaled linearly to 100 but 1000 did not scale
21:31:41 <refried_> yes it is
21:31:43 <johnw> refried_: what you just said isn't what you asked for
21:31:58 <refried_> johnw: sorry about that — i have no idea what i asked for
21:32:12 <shapr> fragamus: Oh that's something else entirely.
21:32:14 <johnw> you said: and i want to create a new list of sublists where _each of the sublists contains exactly one element_ from each of the original a,b,c,d sublists
21:32:14 <roadfish> croikle:so a list comprehension is monadic because lists are a kind of monad. I guess this is a result of monadic laws wrt to lists. but I don't understand monads enough yet to really grok this.
21:32:19 <bobajett> refried_: can you explain again what exactly you're trying to do with the sublist?
21:32:23 <ski> SamanthaD : you need a base case for `filterPrime'
21:32:26 <johnw> ah, I see
21:32:30 <johnw> i misread it
21:32:39 <johnw> you want a cross-product of all the input sublists
21:32:39 <refried_> johnw: i was pretty confused when i wrote it
21:32:53 <monochrom> it is ambiguous. I certainly read johnw's first reading, too
21:32:54 <johnw> then croikle answered it
21:33:08 <refried_> bobajett: I think i want sequence, but it's my first time
21:33:11 <roadfish> do { x <- [1,2]; y <- [3]; z <- [5,6]; return [x,y,z] }
21:33:13 <croikle> yeah, sequence looks better
21:33:24 <fragamus> yeah man i put in `seq` in a place I thought would help but I feel like a kitten walking through a wolves'  den
21:33:35 <johnw> > sequence [[1,2,3],[4,5]]
21:33:37 <lambdabot>   [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
21:33:49 <refried_> yeah
21:33:55 <spacekitteh> hey, so, i'm trying to figure out how to use type classes and numeric-prelude. can anyone help me with this definition? http://bpaste.net/show/68839
21:34:00 <roadfish> > do { x <- [1,2]; y <- [3]; z <- [5,6]; return [x,y,z] }
21:34:02 <lambdabot>   [[1,3,5],[1,3,6],[2,3,5],[2,3,6]]
21:34:07 <refried_> > sequence [[1,2],[3],[4,5]]
21:34:08 <lambdabot>   [[1,3,4],[1,3,5],[2,3,4],[2,3,5]]
21:34:18 <SamanthaD> ski: in case it ever hits an empty list? It should never do that... I'll add a base case that throws an error but my question was whether passing the xs in that tuple is a good idea performance-wise.
21:34:27 <refried_> > sequence [[1,2],[3],[5,6]]
21:34:29 <lambdabot>   [[1,3,5],[1,3,6],[2,3,5],[2,3,6]]
21:34:36 <ski> SamanthaD : hm .. oh, right
21:34:44 <refried_> yeah.  thanks for trying to help me figure it out :-)
21:34:56 <SamanthaD> ski: thanks though
21:34:58 <ski> SamanthaD : anyway, then you need to output some information before continuing with the recursive call
21:35:36 <ski> SamanthaD : how about both outputting `y' as well as passing it on to the recursive call ?
21:35:48 <roadfish> @hoogle [[a]] -> [[a]]
21:35:48 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
21:35:48 <lambdabot> Prelude concat :: [[a]] -> [a]
21:35:48 <lambdabot> Data.List concat :: [[a]] -> [a]
21:35:53 <SamanthaD> ski: I don't understand... you're suggesting I use something like a monad to record the xs instead of using the tuple?
21:36:22 <ski> i'm not suggesting any monad, no
21:36:49 <roadfish> @hoogle [m a] -> m [a]
21:36:49 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:36:49 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
21:36:49 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
21:36:58 <ski> consider e.g
21:36:59 <ski> @src scanl
21:36:59 <lambdabot> scanl f q ls = q : case ls of
21:36:59 <lambdabot>     []   -> []
21:36:59 <lambdabot>     x:xs -> scanl f (f q x) xs
21:37:19 <SamanthaD> ski: the xs are the prime numbers, the ys are the remaining, unfiltered list...
21:37:23 <ski> this outputs `q' as well as passing `q' (specifically `f q x') on to the recursive call
21:37:30 <ski> SamanthaD : yes
21:39:17 <M30W> shapr: I tried telling cabal that the max version was higher but no luck. :(
21:39:22 * M30W wants darcs -_-
21:40:08 <M30W> Only thing I don't like about haskell; the repos are almost always broken. Cause it's the upstream for MANY packages by source and everything is specfic versioning.
21:40:22 <hpaste> “C. McCann” pasted “more fake syntax for ski” at http://hpaste.org/80449
21:40:28 <cmccann> ski: here's more of my pipe dream syntax
21:40:35 <nus-> M30W, what's wrong with https://aur.archlinux.org/packages/darcs/ ?
21:40:41 <monochrom> eh? I can't reproduce half of the "can't install package" problems reported here
21:40:42 <cmccann> from memory since I can't recall where I put my notes
21:40:55 <M30W> nus: AUR; it's just gonna install through cabal and get the same error haha.
21:41:00 * ski mentions the "Annotate" button to cmccann :)
21:41:01 <monochrom> I just ran "cabal install --dry-run darcs" and no error here
21:41:05 <M30W> AUR, PKGBUILD's gets and compiles from source.
21:41:18 <cmccann> ski: oh yeah forgot about that
21:41:28 <M30W> monochrom: Which os?
21:41:32 <nus> M30W, as in your paste above, you mean? the paste basically says it wants ghc-7.4
21:41:49 <cmccann> ski: anyway you can probably see how my wishful thinking about syntax got out of hand :P
21:41:59 <M30W> nus: That not the newest?
21:42:12 <SamanthaD> skl: hmm... I guess I might be confused but I don't get how scanl makes its output available to a function its using WITHIN itself.
21:42:12 <monochrom> ubuntu 12.04, ghc 7.4.2, haskell platform 2012.4.0.0, clean state
21:42:56 <nus> M30W, http://bugs.darcs.net/patch987
21:42:58 <monochrom> so perhaps you need a clean state. as opposed to "I have already installed a million versions of a million packages therefore there are bound to be conflicts left right and centre"
21:43:11 <SamanthaD> skl: in your example q is still being appended before the recursion which means the recursion gets no access to it...
21:43:16 <M30W> GHC 7.6 Heh
21:43:17 <roadfish> monochrom: that's my set up to. so, if I understand correctly, you can usually install packages ok?
21:43:36 <monochrom> yes!
21:43:37 <M30W> That's the version I have.
21:43:39 <SamanthaD> ski: sorry, I've been accidently calling you skl
21:44:06 <M30W> nus: 7.4 -> 7.6
21:44:12 <M30W> I have 7.6 not 4
21:44:34 <ski> SamanthaD : "the recursion gets no access to it" doesn't follow from "q is still being appended before the recursion" -- in fact, in the `scanl' case, the former is false
21:44:45 <nus> M30W, I gathered that much (your paste said so)
21:45:09 <alex20032_> good night everyone, during the remain of the week, i will start out learning haskell
21:45:15 <M30W> nus: Where does it saw 7.4 ?
21:45:15 <nus> M30W, I mean the darcs package on Hackage wants to be built with ghc-7.4.x
21:45:22 <alex20032_> may the forces be with me!
21:45:23 <SamanthaD> ski: then I guess I don't understand scanl's source code. I'm still learning the language.
21:45:31 <tac> night alex20032_
21:45:33 <roadfish> so if 7.6 is having trouble, I guess that means that older packages in hackage break down after a few upgrades to haskell. does that mean that most (or just a bit) in hackage won't work properly?
21:45:36 <M30W> Ah
21:45:39 <ski> cmccann : i would probably have written `\x.' as `\x. {}'
21:45:44 <M30W> nus: So.... I need the darcs repo for darcs?
21:46:04 <cmccann> ski: yeah I went back and forth on that
21:46:17 <ski> (and your `\().' as `{}')
21:46:18 <monochrom> roadfish: many packages on hackage are still not ready for 7.6. however, I am leaving "many" undefined
21:46:43 <ski> cmccann : type for `apply' seems wrong
21:46:53 <cmccann> trying to find a way to write negation/bottom while still making it clear that it's distinct from 0
21:47:05 <nus> M30W, if you want to stick with ghc-7.6 you might try the patch above, alternatively install ghc-7.4 and build with it
21:47:09 <cmccann> ski: oh yeah looks like I goofed
21:47:18 <ski> (also, `Bang a' is really an approximation of `! a')
21:47:31 <ski> (though i suspect you knew that)
21:47:40 <cmccann> well I wouldn't call it an "approximation"
21:47:56 <roadfish> do many packages provide automated tests that hackage can run to automatically determine if the package still works on new version of haskell? does hackage even have such an auto-test facility?
21:48:30 <ski> cmccann : there's no guarantee that all the copies are actually copies
21:48:37 <SamanthaD> ski: oh, I think I understand now. Thanks! I imagine this is a better way of doing it than I was doing it...
21:48:52 <gienah> roadfish: its a bit spotty, as unfortunately hackage does not run the tests, and often upstream forget to include the tests (or forget to run them)
21:49:04 <ski> SamanthaD : anyway, the `case' in `scanl' is irrelevant to your problem, i think
21:49:17 <ski> SamanthaD : i just mentioned it for the usage of `q' there
21:49:51 <cmccann> ski: in my original notes was also "type Wut a = Bot + a + (Wut a | Wut a)"
21:49:59 <cmccann> or however I was writing bottom at that point
21:49:59 <ski> > scanl (+) 0 [a,b,c]
21:50:00 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c]
21:50:18 * ski nods
21:50:27 <cmccann> also, I don't think it's necessary that they be copies. they're all of the same type
21:50:49 <cmccann> and the exponentials aren't unique, you can't prove two modalities that both behave like ! are the same thing
21:51:29 <cmccann> so I actually ended up being quite happy with describing them that way
21:51:38 <ski> afaiu, the intended semantics uses an "eternal" proof of `A' as many times as desired when `! A' is used
21:51:50 <roadfish> so it's the responibility of upstream to run tests and then tell hackage that it works with new versions of haskell. and if no upstream bothers than a package becomes orphaned. I wonder how other packaging systems carry over to upgrades ... such as Ubuntu 12.10 to 13.04
21:52:10 <ski> e.g. if `A' is `Bool', i'd expect it to be the same boolean value every time i look at it
21:52:14 <roadfish> maybe they just do the compile and if that works, then good enough
21:52:53 <cmccann> ski: yes, and a value with type "Bang a" means you can take as many things of type "a" from it as you like, given the specified shape
21:53:09 <cmccann> it also turns out that just "take one at a time" doesn't work
21:53:25 <cmccann> if you treat it as a data structure in any fashion
21:53:50 <cmccann> you need to be able to split it or extract a single value that way
21:54:11 <roadfish> does ghc do that odd-number dev and even-number stable thing? if so, then are people working on a dev ghc-7.7 right now?
21:54:12 <cmccann> so e.g. you can turn "Bang a" into an infinite stream of "a" but not v.v.
21:54:42 <monochrom> I think so. it has been 7.0, 7.2, 7.4, 7.6
21:54:42 <ski> (though possibly one could have nonstandard semantics that uses a non-trivial comonoid to "split" and "destroy" values, like e.g. <http://en.wikipedia.org/wiki/Coalgebra>)
21:54:42 <shachaf> roadfish: Yes and yes.
21:55:12 <ski> cmccann : *nod*
21:56:27 <cmccann> ski: also the only way you can make something of type "Bang a" for arbitrary "a" is by duplication, obviously
21:56:42 <cmccann> so I think there are potentially some interesting parametricity guarantees possible
21:56:48 <cmccann> but I haven't worked out the details
21:57:01 <roadfish> is there any sense of the %age of packages that make the leap past upgrades like 7.4 to 7.6?
21:58:36 <M30W> application/x-darcs-patch Heh
21:58:58 <cmccann> ski: anyway, expBang is an implementation of the only behavior expected from the exponential that isn't trivial
21:59:26 <cmccann> as far as I can tell that definition of Bang gives something indistinguishable from any other implementation of !
21:59:55 <M30W> nus: Could you patch it and send me an archive? It seems that I need darcs to patch darcs ;)
22:00:38 <nus> M30W, http://darcs.net/Binaries
22:00:48 <M30W> Ah
22:00:57 <M30W> Thanks
22:01:30 <monochrom> you know, darcs is an executable. if you don't insist on building from source, you need not go through a "cabal install --please --please --please" ordeal
22:02:00 <ski> @type System.Random.split  -- cf. this, and linear implicit parameters <http://www.haskell.org/ghc/docs/6.4-latest/html/users_guide/type-extensions.html#linear-implicit-parameters>,<http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/FunWithLinearImplicitParameters>
22:02:01 <lambdabot> RandomGen g => g -> (g, g)
22:02:19 <monochrom> even ubuntu provides a darcs binary. I would be surprised if archlinux didn't. and we are not talking about gentoo
22:03:32 <ski> cmccann : afaics, you can define `foo : Bool -> Bang Bool; foo False = 1 & False & (foo True,foo False); foo True = 1 & True & (foo False,foo True)'
22:05:37 <M30W> I could have sworn that --lazy was meant to be fast ;)
22:05:57 <M30W> 100 to go
22:07:45 <M30W> @ping
22:07:45 <lambdabot> pong
22:08:47 <`nand`> cwiidSetLed wm = c_cwiid_set_led  handle 9 -- set on LED 1 and 4  <- what an extraordinarily useful function
22:09:09 <`nand`> seems these bindings are way too incomplete to be of any real use :(
22:09:26 <`nand`> anybody want to pick up ‘hcwiid’? :)
22:12:55 <M30W> How can you use a dpatch? O.o
22:14:11 <roadfish> just did cabal install hoogle. tsk, don't seem to get a hoogle command after that.
22:15:34 * ski . o O ( "cwiid" ? )
22:16:03 <augur> ski: cwiid pro cwo
22:16:15 <augur> cwiid eest
22:16:31 <ski> quod ?
22:16:37 <augur> cwiidcwaam
22:16:47 <augur> cwood surely
22:17:09 <M30W> @ping
22:17:09 <lambdabot> pong
22:17:22 <augur> D:
22:17:27 <augur> im gonna play a game
22:17:29 <augur> @ping
22:17:29 <lambdabot> pong
22:17:30 <augur> @ping
22:17:30 <lambdabot> pong
22:17:32 <augur> @ping
22:17:32 <lambdabot> pong
22:17:34 <augur> @ping
22:17:34 <lambdabot> pong
22:17:36 <augur> @ping
22:17:36 <lambdabot> pong
22:17:40 <augur> @miss
22:17:40 <lambdabot> Maybe you meant: list msg
22:17:42 <M30W> @undefine ping
22:17:44 <augur> damnit!
22:17:47 <M30W> :(
22:17:48 <augur> you win today lambdabot!
22:17:57 <ski> @botsnack
22:17:57 <lambdabot> :)
22:18:35 <M30W> ski: Thanks for the ctcp loven. :)
22:18:57 <ski> M30W : SYN
22:19:02 <M30W> 17:18 [freenode]  ski is away: Security System Breached
22:19:02 <M30W> Heh
22:19:37 <bobajett> stupid question: is there a way to see a std-library's source in ghci as @src does here?
22:19:38 <ski> "M30W requested unknown CTCP ♥"
22:19:46 <M30W> ski: :)
22:19:50 <bobajett> @src concat
22:19:50 <lambdabot> concat = foldr (++) []
22:20:21 <ski> @where L.hs
22:20:21 <lambdabot> What lambdabot has in scope is at <http://code.haskell.org/lambdabot/State/L.hs>
22:20:22 <M30W> bobajett: :brouse
22:20:44 <ski> @where src
22:20:44 <lambdabot> The fixed database for the `src' lambdabot command is at <http://code.haskell.org/lambdabot/State/source>
22:20:47 <ski> that one
22:20:48 <M30W> :browse Data.Map
22:21:00 <M30W> bobajett: ^
22:21:17 <cmccann> ski: sorry, server issues. :P I'm not sure that works, stuff like that is why the implicit syntax gave me a headache, making sure things weren't actually being used more than they should be &c.
22:21:24 <ski> bobajett : which library did you want to see source of ?
22:21:33 <cmccann> but it sounds ok and I'm sure you can do something similar
22:21:55 <cmccann> at some point I'll finish my half-baked interpreter for a linear lambda calculus with support for data types like that and then worry about syntax eventually
22:22:09 <ski> i don't see any such problems for `foo' above (no variable names except `foo')
22:22:24 <bobajett> ski: nothing in particular, I was aware of :t and :i but didn't know if there was an option to view the source in ghci.
22:23:35 <ski> there's also `source'
22:23:41 <ski> @source Data.List
22:23:41 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
22:25:33 <bobajett> ski: 'source' in ghci?
22:25:48 <ski> yes
22:25:54 <ski> (distinct from `src')
22:26:27 <bobajett> *Main> :source Data.List
22:26:29 <bobajett> unknown command ':source'
22:26:53 <bobajett> GHCi, version 7.4.2
22:27:41 <nus> http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
22:28:14 <ski> bobajett : er .. sorry, when you said "in ghci", i for some reason read that as "in lambdabot" :/
22:28:39 <ski> bobajett : though, iirc, you can get access to a lambabot from GHCi ..
22:28:52 <cmccann> ski: anyway, I need to head to bed
22:29:22 <cmccann> if you have any great ideas for how to make a sensible syntax for this stuff you should definitely leave me a lambdabot message or something ;P
22:29:26 <bobajett> cool! an hour in #haskell and I've learned a boat full of stuff
22:31:45 <ski> cmccann : ok, night -- if i think of any more syntax things, i'll try to recall mentioning them
22:32:00 <ski> bobajett :D
22:32:48 <cmccann> ski: if all else fails I could concoct something like djinn that tries to prove that a definition is legit
22:32:52 <cmccann> but that's not very satisfying
22:35:06 <roadfish> figured out why I didn't get a hoogle command. need to add ~/.cabal/bin/ to my PATH
22:49:47 <gsj1> what's the best way to process command line arguments in a simple haskell utility?
22:50:46 <Hafydd> gsj: for a sufficiently simple utility, Data.List and System.Environment
22:51:00 <bogner_> gsj: GetOpt?
22:51:16 <gsj> Hafydd: so currently i have a main routine that looks like: main = getArgs >>= dispatch, and dispatch just pattern matches on the [String]
22:51:30 <gsj> one annoying thing is that i have to convert strings to ints using read :: Integer
22:51:40 <gsj> bogner_: i'll look at GetOpt
23:00:28 <plat0> Does GHC itself use haskell-src-exts?
23:06:52 <mikeplus64> edwardk: in Control.Comonad, why not have an instance for Applicative (w a) => Comonad ((->) (w a)) ? (or is that invalid, i'll check)
23:07:45 <mikeplus64> i mean Applicative w =>
23:08:16 <mikeplus64> actually oops i mean Alternative w =>
23:11:11 <ozataman> Hey all - what's a good/practical type-level integers library?
23:12:11 <mikeplus64> ozataman: GHC.TypeLits perhaps?
23:12:20 * hackagebot mcmc-synthesis 0.1.1.0 - MCMC applied to probabilistic program synthesis  http://hackage.haskell.org/package/mcmc-synthesis-0.1.1.0 (TikhonJelvis)
23:13:10 <ozataman> mikeplus64: oh, is that part of the new additions in GHC 7.4+?
23:13:27 <mikeplus64> yeah it's in 7.6.1+ i think
23:14:48 <mikeplus64> edwardk: although i suppose that would stop you from writing a MonadPlus instance...
23:15:10 <ski> mikeplus64 : definition ?
23:15:25 <mikeplus64> instance Alternative w => Comonad ((->) (w a)) where
23:15:27 <mikeplus64>     extract   f   = f empty
23:15:29 <mikeplus64>     duplicate f m = f . (<|>) m
23:16:12 <johnw> edwardk: fyi, eq doesn't build with 7.6
23:16:12 <edwardk> mikeplus64: that instance conflicts with the simpler one for using a monoid
23:16:42 <edwardk> johnw: yeah they changed something about the way type injectivity works, oleg's trick no longer does the right thing
23:17:17 <edwardk> mikeplu64: extract f = f mempty; duplicate f m = f . mappend m
23:17:35 <mikeplus64> yeah, i didn't realse that would conflict for a lot of types e.g. Maybe
23:17:36 <edwardk> mikeplus64: if you think about it your suggestion is just that for a particular choice of monoid
23:19:21 <mikeplus64> one day maybe we'll be able to do like (Alternative w, Not (Monoid (w a)) => ...
23:20:04 <edwardk> mikeplus64: that violates the open world assumption ,it'd be a bad idea to allow that sort of thing
23:20:07 <ski> mikeplus64 : hm, is there an `instance Monoid m => Comonad (m ->)' ?
23:20:15 <edwardk> ski: yes
23:20:17 <mikeplus64> because there are definitely things that are Alternative but not MonadPlus but not Monoid or some arrangement of that that could be Comonads
23:20:53 <edwardk> https://github.com/ekmett/comonad/blob/master/Control/Comonad.hs#L123
23:21:11 <mikeplus64> luckily Monoid has the most instances :)
23:21:17 <mikeplus64> as far as i can tell anyway
23:21:39 <edwardk> mikeplus64: you can make a monoid out of (<|>) and empty. just wrap it in a newtype. thats what they are for
23:22:13 <edwardk> https://github.com/ekmett/reducers/blob/master/src/Data/Semigroup/Alternative.hs#L33
23:22:39 <mikeplus64> github is very slow atm
23:22:47 <edwardk> ((->) (Alt w a))   is a comonad
23:23:16 <mikeplus64> neat
23:26:53 <johnw> is there a way to unmangle linker symbols from GHC?
23:27:12 <johnw> i have a symbol that's missing, but only if I build my test with profiling
23:27:45 <Saizan> preflex had zdec
23:50:06 <Enigmagic> johnw: there are various haskell versions floating around, and i have a python one here https://github.com/alphaHeavy/ghc-lldb/blob/master/z_code.py
23:52:10 <johnw> ah, nice
