00:00:42 <Kanisterschleife> mm_freak_: :( I tried to install ghc from source and then haskell-platform from source, but it complains that the ghc installationeems to be wrong ("cannot compile simple program")
00:01:15 <Kanisterschleife> mm_freak_: ok, goes on now...
00:04:19 <fmap> Kanisterschleife: you can just use ghc binaries, no need to compile from source
00:04:35 <fmap> (unless you want to)
00:08:40 <wuttf> If I write class C a b c | a -> b -> c where, compiler whines, what is the proper way to state that?
00:08:57 <wuttf> (That c depends on b and b depends on a)
00:09:14 <shachaf> a -> b, b -> c?
00:09:27 <wuttf> shachaf: Seems legit ;)
00:11:17 <basdirks> I've asked this before but am a bit demented: what's the alternative to haskellmode (for vim) again?
00:18:31 <tertl3> hi hsakell
00:22:30 <M30W> Hmm
00:22:55 <M30W> Does anyone here have any idea why ghci might be segfaulting when I attempt to use the libMPD library ?
00:27:10 <mm_freak_> Kanisterschleife: sorry, i have no experience with doing that‚Ä¶  i've just seen others do it
00:27:24 <startling> M30W: "use"?
00:27:40 <M30W> startling: withMPD $ status
00:27:41 <mm_freak_> M30W: i'm using it successfully
00:27:54 <M30W> mm_freak_: I'm segfaulting..
00:28:08 <M30W> Loading package parsec-3.1.3 ... [1]    18948 segmentation fault (core dumped)  ghci
00:28:11 <mm_freak_> life's a bitch, isn't it‚Ä¶
00:29:14 <M30W> Apparently
00:29:27 <mm_freak_> if it helps, i have GHC 7.6.1
00:31:17 <mm_freak_> > fmap stSongPos <$> withMPD status
00:31:17 <mm_freak_> Right (Just 13)
00:31:18 <lambdabot>   Not in scope: `stSongPos'Not in scope: `withMPD'Not in scope: `status'
00:31:19 <lambdabot>  Per...
00:32:12 <mm_freak_> M30W: (C) libmpdclient 2.7-1, (haskell) libmpd 0.8.0.2
00:32:26 <mm_freak_> (the "-1" is probably arch-specific"
00:32:27 <mm_freak_> )
00:33:22 * M30W wonders how cabal is trying /home/m30w when it is .. /home/archey
00:33:41 <mm_freak_> check your ~/.cabal/config
00:33:51 <Kanisterschleife> mm_freak_: now I installed ghc and hp from source, but when trying to instal xmonad-contrib via cabal, I get "pkg-config version >= 0.9.0 required but could not be found" What can I do here?
00:33:54 <M30W> Yea looks like I borked it. Heh
00:34:11 <M30W> Fixed that and now I guess I have to reinstall a few things..
00:34:16 <mm_freak_> M30W: shouldn't cause segfaults, though‚Ä¶  better report it
00:34:49 <mm_freak_> Kanisterschleife: install pkg-config through apt
00:35:06 <M30W> mm_freak_: I did a cp over sshfs for .cabal;  I will just see if that was the issue (I ctrl-c'd it quick apparently it still did damage) :P
00:35:06 <mm_freak_> Kanisterschleife: on debian you may also need the developer versions of some libraries
00:35:40 <mm_freak_> M30W: i often rsync cabal files, that's fine, but my user name doesn't change between boxes =)
00:35:48 <M30W> Same
00:35:58 <M30W> I did a sshfs cp of .cabal instead of .conkyrc ;)
00:36:25 <mm_freak_> that should make conky kaputt, but not cabal =)
00:36:32 <Henryk> Hello.
00:36:35 <mm_freak_> in fact, cabal is very strict about its syntax =)
00:36:38 <mm_freak_> hi there Henryk
00:36:52 <Henryk> "Kaputt" Yeah? ;D
00:36:59 <M30W> I have a tendency to collect ssh logins around the world. Germany, Ireland, Texas etc.
00:37:02 <M30W> :D
00:37:14 <mm_freak_> me too
00:37:18 <Henryk> like what M30W  ?
00:37:24 <mm_freak_> % wc -l .ssh/config
00:37:24 <mm_freak_> 89 .ssh/config
00:37:31 <Henryk> xD
00:37:34 <M30W> Henryk: Normally starts off with supporting a MEGA NOOB like now.... :|
00:37:49 <M30W> Trying to clone my desktop around the world to ireland right now
00:37:51 <M30W> :P
00:37:51 <Henryk> okay.o√¥
00:38:03 <M30W> It should be working
00:38:14 <Henryk> use teamviewer or something ^^
00:38:33 * M30W pured his ghc and cabal (in home) and re-installs things
00:38:51 <M30W> Thankfully I have xmonad and it's staticly compiled in there :P
00:38:58 <Henryk> has someone programmed a game in haskell?
00:39:15 <mm_freak_> Henryk: i've done some graphics stuff including opengl, but no games yet
00:39:24 <srhb> There are, even commercial ones.
00:39:32 <Henryk> How can i see them? (:
00:39:32 <srhb> What was the name of that platformer?
00:39:38 <M30W> Henryk: Yes
00:40:00 <M30W> Henryk: vim +'set ft=haskell' http://ix.io/44i
00:40:02 <mm_freak_> Henryk: you can't see mine, but you there are a few games on hackage‚Ä¶  and some commercial ones have been written
00:40:14 <srhb> Henryk: http://joyridelabs.de/game/
00:40:16 <Henryk> i need ghc fpr that, right?
00:40:21 <Henryk> for*
00:40:27 <mm_freak_> likely
00:40:37 <mm_freak_> unless you get binaries
00:41:19 <M30W> Henryk: The one I sent you; you just need base, network and random. :)
00:41:57 <M30W> mm_freak_: I bet my parsec libraries just got a little corrupted :P
00:42:50 <Henryk> M30W:  http://ix.io/44i i have it into a new haskell document, what now?
00:43:06 <M30W> Henryk: Read for one; you can save it to say.. Game.hs and build it :)
00:43:25 <Henryk> Build it? S:
00:43:28 <srhb> Henryk: In order to get an executable, you would type ghc yourfile.hs
00:43:50 <srhb> Henryk: In a terminal where GHC is available, of course. :)
00:43:56 <M30W> Henryk: ghc Game
00:44:12 <M30W> Henryk: ghc ‚ô•
00:44:23 <Henryk> i'm installing ghc
00:44:27 <Henryk> Moment
00:44:37 <srhb> Henryk: You should probably get Haskell Platform instead of just GHC
00:44:39 <mm_freak_> you would rather say something like:  ghc -O -o game --make Game
00:45:53 <srhb> M30W: Your code is weird :P Why do you bother to check some exceptions yet throw around read . head elsewhere?
00:46:16 <M30W> srhb: xD
00:46:40 <M30W> srhb: read.head... yea; It works :P I got lazy.
00:46:48 <M30W> srhb: Wanna play without compiling ?
00:46:48 <srhb> :P
00:46:49 <M30W> Henryk: You too
00:47:04 <srhb> No thanks. :P
00:47:11 <mm_freak_> runhaskell Game
00:47:11 <mm_freak_> =)
00:47:25 <M30W> The game comes as an irc bot too ;)
00:47:25 <mm_freak_> it's probably not that bad, though
00:47:49 <M30W> mm_freak_: Give it a port!!
00:48:07 <frerich> Henryk : http://ix.io/44i <-- yours? Any particular reason you don't use nested do-blocks?
00:48:19 <M30W> Henryk: /join #guessit
00:48:27 <M30W> frerich:
00:48:28 <M30W> Mine
00:48:30 <tac> Does anyone have any clue how you would even BEGIN diagnosing such a worthless Cabal error message?
00:48:31 <tac> http://hpaste.org/81216
00:48:42 <mm_freak_> M30W: a port to what?  i could port it to netwire =)
00:48:46 <M30W> Henryk: Why would one use do blocks when there is no need =)
00:49:09 <M30W> mm_freak_: runhaskell Game 6666
00:49:15 <M30W> mm_freak_: runhaskell Game.hs 6666
00:49:28 <M30W> mm_freak_: Or join #guessit lol
00:49:48 <M30W> Ah need to patch it for the bot again
00:49:49 <M30W> lol
00:50:19 <bsrkaditya> Hi,
00:50:22 <bsrkaditya>  When a function x -> y -> z is matched with a -> b, what will be a, and what will be b?
00:50:47 <tac> x -> y -> z means
00:50:50 <tac> x -> (y -> z)
00:50:56 <tac> so x = a
00:50:59 <M30W> mm_freak_: I like to play my tcp guessing game tunneled through freenode =)
00:51:00 <tac> b = (y -> z)
00:51:05 <bsrkaditya> thanks tac!
00:51:07 <tac> np
00:52:47 <mm_freak_> M30W: i'm porting the game to netwire right now =)
00:52:59 <M30W> netwire?
00:54:40 <M30W> Hmm
00:55:05 <johnw> mm_freak_: how do you like writing arrowy code?
00:55:12 * tac wishes he could just settle down and learn some FPR
00:55:22 * tac wishes arrows didn't exist
00:58:12 <Lethalman> mm_freak_, what game? what game? link so I can read the commits? :P
00:58:31 <M30W> Right (Status { stRandom = True }) -- How would I get that not . stRandom? So far I've got fmap (not . stRandom) a which gives Right False. How can I get just False ?
00:59:09 <johnw> M30W: you would have to case analyze the result
00:59:19 <johnw> or use a function like fromMaybe or maybe
01:00:13 <frerich> There's "either" for that.
01:00:26 <johnw> sorry, I meant either
01:00:37 <johnw> I read "just False" at the end as "Just False" :)
01:00:49 <M30W> Ha
01:01:46 * Lethalman crawling github for some easy project I can contribute to
01:02:07 <johnw> what are your interests?
01:02:27 <Lethalman> johnw, no idea, depends on the project
01:02:34 <M30W> Trying to use libmpd to invert the random
01:02:39 <johnw> well, i'd recommend gitlib, but the C FFI is not easy
01:03:08 <shachaf> GHC could use contributors.
01:05:15 <M30W> Noob just complained to me about my xmonad configs for his audio not working ... When the issue was his speakers were turned off
01:05:18 <M30W> LOL
01:06:53 <hiptobecubic> M30W, what would your xmonad config have to do with someone else's anything?
01:08:43 <M30W> hiptobecubic: Cause I installed it on his computer remotely. And he figured that was why he couldn't use his audio
01:12:54 <tac> Is there a way to make cabal *not* start over when there's a build error?
01:15:33 <Fuuzetsu> I don't know of such flag but I'd imagine that it depends on the stage at which it failed.
01:20:15 <wuttf> How can I Interger -> Word32?
01:20:40 <shachaf> What do you want to do with 10000000000000000000000000000000000?
01:21:21 <simpson> wuttf: fromIntegral will provide you with wrapping modulus behavior, if that's what you want.
01:21:34 <shachaf> Hoogle would have told wuttf about fromIntegral.
01:21:38 <wuttf> shachaf: Some library needs a word32 where I use an Integer
01:21:41 <shachaf> So presumably they want something more.
01:22:07 <wuttf> "For coercing between any two integer types, use fromIntegral, which is specialized for all the common cases so should be fast enough. Coercing word types to and from integer types preserves representation, not sign"
01:22:27 <wuttf> I was kinda scared away from fromIntegral because of that
01:22:47 <simpson> What's scary about that?
01:22:52 <shachaf> What do you want to happen with the value -1?
01:22:57 <wuttf> Even if I can't completely comprehend it :D
01:23:13 <wuttf> So positive numbers won't be affected, right?
01:23:56 <shachaf> I think you can experiment as well as I can.
01:24:07 <simpson> > fromIntegral (-1 :: Integer) :: Word32
01:24:09 <lambdabot>   4294967295
01:24:16 <shachaf> It might be that some of it is "undefined" behavior or something -- maybe that's what you're worried about?
01:24:34 <simpson> > fromIntegral (4294967297 :: Integer) :: Word32
01:24:36 <lambdabot>   1
01:26:37 <wuttf> shachaf: Sorry if I am irritating you but sometimes such an obvious thing like typing  fromIntegral (-1 :: Integer) :: Word32 does not cross my mind because I still don't entirely feel at home with Haskell
01:27:10 <shachaf> wuttf: In that case I'm happy to help!
01:27:32 <startling> wuttf, fromInteger -1 :: Word32 might be cleaner
01:27:38 <simpson> wuttf: I'm just making the type annotations extra-obvious. You can let Haskell infer the types if you like.
01:27:45 <shachaf> startling: That's an error.
01:27:59 <srhb> :t fromInteger
01:28:00 <lambdabot> Num a => Integer -> a
01:28:02 <shachaf> wuttf: My goal in that case, though, is to help you learn to figure these things out, not to give you the answer.
01:28:15 <startling> shachaf: oops, dang -
01:28:23 <srhb> Ah, parse..
01:28:24 <shachaf> Figuring these things out is a much more useful skill than converting Integers to Word32s. :-)
01:28:26 <startling> wuttf: I mean "fromInteger (-1) :: Word32"
01:28:41 <wuttf> shachaf: I agree that's better for everyone in the long run.
01:29:19 <startling> I always accidentally think - works how I want it to work. :/
01:29:22 <wuttf> startling, simpson Thank you both
01:30:37 <simpson> wuttf: I'm still not clear on what you're doing, but feel free to talk it out or hpaste some code if you have questions.
01:30:41 <mm_freak_> seems like mfix is implemented using MVars for IO
01:30:59 <shachaf> Correct.
01:31:19 <mm_freak_> johnw: simple, i try to avoid arrowy code and use applicative style where possible =)
01:31:27 <wuttf> simpson: I am transforming some data between libraries and one uses an Integer for representing a value and an other Word32 for the same.
01:31:27 <Henryk> I want to have a list splitted and then putted together in an another configure like [hey] to [ehy] or [eyh] i have a function like this for it        perms :: Int -> a -> [a] -> [a]
01:31:30 <Henryk> perms n x [xs]  =
01:31:34 <Henryk> :c
01:31:36 <mm_freak_> Lethalman: it's just a simple guessing game
01:31:52 <Lethalman> shachaf, I'd be very interested in contributing to ghc, but I still can't write haskell :P since I don't have much time for working on a project, but I'm able to read commits of active and young projects
01:31:53 <mm_freak_> right now i'm trying to figure out how to express such a highly interactiony thing using FRP
01:32:19 <mm_freak_> > permutations "abc"
01:32:21 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
01:32:31 <Lethalman> mm_freak_, ah I'm interested in it, but I believe it's a one-file personal program right? :)
01:32:38 <shachaf> Lethalman: If you want a performance problem that stumped me and a few other people, there's always https://github.com/ekmett/lens/issues/245
01:32:43 <mm_freak_> Lethalman: what's that?
01:32:53 <Henryk> mm_freak_:  thanks but how do i put that in a function?
01:33:06 <startling> shachaf: haha
01:33:08 <srhb> shachaf: That issue is closed.
01:33:08 <Lethalman> mm_freak_, I mean it's nothing to be on github or anywhere else
01:33:20 * hackagebot flock 0.3.1.5 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.3.1.5 (ErikHesselink)
01:33:25 <hiptobecubic> EVERYTHING is to be on github :)
01:33:33 <hiptobecubic> at least as a gist
01:33:34 <Lethalman> shachaf, eheh no that's too much :)
01:33:36 <shachaf> srhb: People keep complaining about that.
01:33:57 <mm_freak_> Lethalman: it's going on hpaste, when it's done
01:33:58 <srhb> shachaf: uh.. Okay, I assumed that meant "fixed" or "unfixable" :P
01:34:06 <Lethalman> ok
01:34:10 <mm_freak_> Henryk: what do you mean?
01:34:16 <shachaf> srhb: It means "edwardk got tired of seeing it in the issue list".
01:34:21 <srhb> lol, how useful. :P
01:34:44 <srhb> "My library is bug-free, all tickets expire after seven days."
01:35:15 <Henryk> I have a list like [Hey] and want to split it with a function in [ehy] and [eyh] with a function like perms n x [xs] = but i dont knoe hoe..
01:35:17 <shachaf> There, I reopened it.
01:35:19 <Henryk> how*
01:35:24 <Henryk> mm_freak_:
01:35:49 <mm_freak_> Henryk: you can use the predefined 'permutations' function
01:35:53 <mm_freak_> it's in Data.List
01:35:57 <mm_freak_> > permutations "Hey"
01:35:58 <lambdabot>   ["Hey","eHy","yeH","eyH","yHe","Hye"]
01:36:15 <mm_freak_> > permutations [1,2,3]
01:36:16 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
01:36:18 <Henryk> mm_freak_:  i know but my goal is to write in on my own
01:36:23 <mm_freak_> ah
01:36:33 <mm_freak_> think of what it means to permute
01:37:09 <Henryk> where is data.list?
01:37:15 <mm_freak_> Henryk: start with a subsequences function first, because that one is easier to write
01:37:23 <mm_freak_> > subsequences "abc"
01:37:24 <lambdabot>   ["","a","b","ab","c","ac","bc","abc"]
01:37:39 <mm_freak_> Henryk: say you have a 'subseqs' function already
01:37:47 <mm_freak_> what's subseqs []?
01:37:52 <Henryk> i have mm_freak_
01:38:01 <mm_freak_> Henryk: you have that one done already?
01:38:33 <Henryk> yes but i dont know why, but i dont know how do a permutation..
01:38:43 <mm_freak_> show me your subseqs solution
01:38:58 <mm_freak_> ideally the same approach can be used to write a permutation function
01:39:18 <mm_freak_> and that one doesn't count:
01:39:23 <shachaf> I bet mm_freak_ is heading toward a "select" solution. :-(
01:39:25 <mm_freak_> > filterM (const [True, False]) "abc"
01:39:27 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
01:39:29 <mm_freak_> =)
01:39:38 <mm_freak_> shachaf: yes, i am
01:39:52 * shachaf likes the opposite one more.
01:40:06 <shachaf> Then again, I like it more because it was the obvious one, when I tried to write "permutations".
01:40:09 <mm_freak_> shachaf: i could also head towards a foldM solution, but then it would probably take a week =)
01:40:35 <mm_freak_> shachaf: i think, the selecting solution is more intuitive as a recursive approach
01:40:48 <shachaf> @let iaep e [] = [[e]]; iaep e (x:xs) = (e : x : xs) : (map (x:) (iaep e xs))
01:40:50 <lambdabot>  Defined.
01:41:06 <mm_freak_> > iaep 'x' "abc"
01:41:08 <lambdabot>   ["xabc","axbc","abxc","abcx"]
01:41:13 <mm_freak_> that's select‚Ä¶
01:41:17 <shachaf> It is?
01:41:23 <mm_freak_> a special case of it
01:41:28 <mm_freak_> that's the one i was going to use =)
01:41:40 <shachaf> I thought select would be the one that would give you "abc" ---> [('a',"bc"),('b',"ac"),('c',"ab")]
01:41:44 <shachaf> That's the one everyone always uses.
01:41:52 <mm_freak_> it's 'select' mapped by (\x y -> x ++ c:y)
01:41:59 <mm_freak_> oh
01:42:07 <mm_freak_> no, that's not the select i meant =)
01:42:15 <mm_freak_> 'select' is probably a bad name for it
01:42:18 <shachaf> Which one did you mean?
01:42:29 <shachaf> Maybe we're spoilering things in here.
01:42:33 <mm_freak_> > liftA2 zip inits tails "abc"
01:42:35 <lambdabot>   [("","abc"),("a","bc"),("ab","c"),("abc","")]
01:42:46 <mm_freak_> yeah, we are =)
01:42:54 <srhb> Yes, it would seem Henryk has been scared speechless now :P
01:43:01 <mm_freak_> hehe
01:43:10 <shachaf> srhb: The bug is reopened.
01:43:13 <shachaf> You can work on it now.
01:43:15 <startling> haha
01:43:23 <srhb> shachaf: Wait, that's not what I meant :P
01:43:38 <startling> shachaf, better give him a commit bit too
01:43:42 <shachaf> Come on, it'll do you good.
01:44:04 <Henryk> im searching guys
01:44:04 <srhb> We both know I don't have the skills to be able to contribute with anything there :P
01:44:10 <shachaf> startling: I'm neither in the commit-bit nor the gender-reassignment business.
01:44:20 <mm_freak_> Henryk: don't search‚Ä¶  just show me your subseqs solution, if you still have it
01:44:26 <startling> shachaf: whoops
01:44:34 <srhb> Oh, me? Yes, let me feel the power!
01:44:42 <Henryk> thats the point mm_freak_  im looking for it.
01:44:46 <mm_freak_> ah =)
01:44:48 <startling> shachaf: better give them a commit bit too
01:44:55 <mm_freak_> Henryk: you could explain it, too =)
01:45:47 <shachaf> srhb: Fixing issues like this is how you *get* the skills!
01:45:57 <srhb> @quote srhb.diving
01:45:57 <lambdabot> No quotes match. My pet ferret can type better than you!
01:46:02 <mm_freak_> Henryk: or we can write it again with the approach i'm thinking of‚Ä¶  then we can move straight to permutations using a very similar approach
01:46:04 <srhb> @quote srhb diving
01:46:04 <lambdabot> srhb says: I think that's going into space rather than diving into the deep end.
01:46:09 <srhb> hackagebot: ^^^
01:46:11 <srhb> oops
01:46:14 <srhb> shachaf: ^^^
01:46:51 <romildo> Are Data.Word.Word64 and Data.Word.Word32 standard?
01:46:53 <Henryk> mm_freak_:  you're french?
01:47:05 <mm_freak_> romildo: they are in the base library, so pretty standard
01:47:18 <mm_freak_> Henryk: i'm in germany, i'm turkish
01:47:18 <simpson> romildo: Data.Word is in base, so it should be available on all compilers.
01:47:33 <Henryk> mm_freak_:  okay ^^
01:47:45 <shachaf> srhb: There is a person who has a lens commit bit despite never having committed anything to lens.
01:48:26 <startling> shachaf, is it edwardk?
01:48:46 <startling> I've got a feeling he's removed more code than he's written.
01:49:08 <srhb> shachaf: I'm trying to really read it now, I feel I would have to be quite deep in lens to understand the various implementations
01:49:37 <srhb> "-- Ideally this would also not crash, but that's not so important."
01:49:37 <srhb>  
01:51:37 <shachaf> srhb: You have to pick your battles.
01:52:39 <`nand`> what does ‚Äúcommit bit‚Äù refer to here?
01:54:07 <lightquake> i assume ability to push to the official repo
01:54:22 <srhb> Yeah.
01:55:02 <dasl> ]/nick TheInfosphere
01:59:06 <hpaste> ocharles pasted ‚ÄúNo instance for (Data.String.IsString                        bytestring-0.9.2.1:Data.ByteString.Lazy.Internal.ByteString)‚Äù at http://hpaste.org/81217
01:59:24 <ocharles> can anyone work out what is going on with that above paste?
01:59:32 <shachaf> ocharles: (a) The version number indicates that you probably have multiple versions of bytestring installed.
01:59:35 <shachaf> "Stop it."
01:59:36 <ocharles> ahh
01:59:38 * ocharles stops that
01:59:43 <shachaf> You can only have one version of bytestring.
01:59:47 <ocharles> nope, only 0.9.2.1
01:59:50 <shachaf> ocharles: (b) ByteStrings aren't strings!
01:59:56 <ocharles> shachaf: they are with OverloadedStrings
02:00:03 <ocharles> at least, there is an IsString instance
02:00:05 <shachaf> No they aren't.
02:00:21 <shachaf> There's an IsString instance but it's not in the main module.
02:00:21 <ocharles> anyway, I only have 0.9.2.1 installed, so it's not that
02:00:24 <shachaf> And it's evil.
02:00:36 <ocharles> I'm alright with a bit of evil in my tests
02:00:37 <johnw> shachaf: you should define what a string is
02:01:25 <shachaf> ocharles: What do you want to happen for the string "¬µ"?
02:01:36 <ocharles> shachaf: that's not going to happen in this test case
02:01:47 <shachaf> You can find the instance in .Char8.
02:01:49 <ocharles> but yes, I should use Text, and encode as bytestring, if I wanted to do this really right
02:02:13 <ocharles> yay, passing tests
02:02:27 <ocharles> thanks shachaf
02:02:36 <ocharles> and not trying to ignore your advice, just doing the easiest thing to get my tests passing again
02:02:39 <latermuse> how do I sum all of the values of a Data.Map hashmap? so fromList [(a, 1),(b,2)] gives me the answer 3
02:02:40 <ocharles> can only change things once that happens :)
02:03:47 <fmap> > sumOf traverse (M.fromList [('a', 1), ('b', 2)])
02:03:48 <lambdabot>   3
02:04:44 <latermuse> thanks fmap ;)
02:05:13 <latermuse> is there any way to do it with fold?
02:05:30 <fmap> > sumOf folded (M.fromList [('a', 1), ('b', 2)])
02:05:32 <lambdabot>   3
02:05:53 <latermuse> which library is sumOf from?
02:05:54 <latermuse> :t sumOf
02:05:56 <lambdabot> Getting (Sum a) s t a b -> s -> a
02:06:01 <latermuse> lens?
02:06:26 <mysticc> Why building haskell-src-exts fails saying require happy >=1.17 and I have to cabal install happy.
02:06:30 <fmap> > M.fold (+) 0 (M.fromList [('a', 1), ('b', 2)])
02:06:32 <lambdabot>   3
02:06:33 <fmap> latermuse: yes
02:06:47 <latermuse> that last one is probably best for what I am doing. Thanks :)
02:06:58 <latermuse> I still havent spent enough time with lens to be comfortable
02:08:08 <shachaf> > Data.Foldable.sum (M.fromList [('a', 1), ('b', 2)])
02:08:10 <lambdabot>   3
02:08:22 <mm_freak_> shachaf: the problem was to get shorter permutations
02:08:26 <M30W> :t either
02:08:27 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
02:08:32 <M30W> :)
02:08:44 <mm_freak_> perms 2 "abc" = ["ab", "ac", "ba", "bc", "ca", "cb"]
02:08:51 <mm_freak_> that one i don't know how to solve without 'select'
02:09:25 <mm_freak_> @let select = liftA2 (zipWith (\xs (y:ys) -> (y, xs ++ ys)) . init) inits tails
02:09:26 <lambdabot>  Defined.
02:09:46 <mm_freak_> > let perms 0 = const [[]]; perms n = concatMap (\(x, xs) -> map (x:) (perms (n - 1) xs)) . select in perms 2 "abc"
02:09:48 <lambdabot>   ["ab","ac","ba","bc","ca","cb"]
02:10:11 <shachaf> @ty select
02:10:12 <lambdabot> [t] -> [(t, [t])]
02:10:13 <mm_freak_> for the normal permutations function you can work prefix-wise‚Ä¶  you can't do that for truncated permutations
02:10:26 <mm_freak_> that's why select is really handy for that one
02:12:13 <M30W> How does one strip the Right from the type ?
02:12:40 <mm_freak_> M30W: what do you mean?  Either e a -> Maybe a?
02:12:58 <mm_freak_> what's the type of the function you want?
02:13:11 <M30W> mm_freak_: How about ... withMPD $ random . not . stRandom =<< status -- Except valid with types ;)
02:13:20 <M30W> Oh wait
02:13:25 <M30W> That works now but didn't before ...
02:14:08 <M30W> Well never mind then mm_freak_ ^_^
02:14:26 <`ramses> > select []
02:14:28 <lambdabot>   []
02:15:22 * M30W now has M-<Esc> mapped to toggle random. Yay :D
02:18:30 <sgk284> hey all, is there any way in ghci to load files without resetting the state of the repl? Everytime I ":l foo.hs", it resets any temporary vars I may have created
02:18:52 <shachaf> Not really.
02:19:15 <sgk284> k, thanks
02:19:17 <shachaf> You can put your interesting variables in the source file.
02:19:55 <sgk284> yea, but it also resets modules that I've added with :m + too
02:20:17 <sgk284> was hoping for a way to leave everything alone (effectively the behavior of a lisp repl)
02:20:27 <sgk284> thanks shachaf
02:20:30 <johnw> sgk284: which editor are you using?
02:20:37 <sgk284> vim
02:20:40 <johnw> hmm
02:20:55 <johnw> i was going to say that Emacs has the capability to update the definitions of individual functions, like with Lisp
02:21:01 <sgk284> if emacs has a SLIME-like environment for haskell though, I'd be willing to pick it up
02:21:04 <johnw> I bet vim can do it too, I just don't know how
02:21:11 <craigInnes> Hi, I'm looking for libraries / tools which would allow me to take some haskell source as a string, parse it, modify the parse tree, then convert the modified version back to source. Can anyone give me an idea of what is available?
02:21:16 <johnw> it's much less polished than SLIME
02:21:28 <sgk284> johnw: still sounds interesting, any pointers?
02:21:36 <sgk284> is this a github project?
02:21:38 <johnw> you want haskell-mode, and ghc-mod
02:21:49 <sgk284> cool thanks, I'll give it a look
02:22:03 <johnw> actually, you don't need ghc-mod for this
02:22:09 <johnw> just "inf-haskell", which comes with haskell-mode
02:22:20 <johnw> C-M-x, on a definition, will send it to ghci
02:22:33 <sgk284> great, thank you!
02:22:49 <johnw> that being said, I never use this feature
02:23:00 <johnw> if I want persistent definitions, I write them in the file while I'm developing, as shachaf suggested
02:23:14 <johnw> sometimes I just comment them out and keep them around for later
02:23:53 <sgk284> johnw: hmm okay. I'll see if I can adapt my workflow as appropriate. that way I get to keep my vim muscle memory too :)
02:27:43 <merlin-> johnw that is neat, I didn't know about it until now
02:27:54 <johnw> merlin-: did you know about C-c C-t?
02:28:15 <johnw> or that haskell-mode can let you set breakpoints on the evaluation of individual expressions?
02:28:25 <merlin-> nope :)
02:29:04 <johnw> one of my most used features is C-c C-m
02:29:24 <johnw> auto inserts the module needed to import an undefined identifier
02:29:51 <merlin-> it is not bound in here
02:29:58 <merlin-> (C-c C-m)
02:30:03 <johnw> ah, it's a ghc-mod feature
02:30:07 <merlin-> what function is it?
02:30:11 <johnw> ghc-insert-module
02:30:19 <johnw> ghc-mod plays together very nicely with haskell-mode
02:30:39 <johnw> and flycheck is now my preferred recommendation for getting background syntax checking
02:30:50 <johnw> it integrates with hdevtools beautifully
02:31:09 <johnw> it highlights the individual expressions causing syntax errors!
02:31:24 <johnw> (well, the first character of them)
02:31:28 <merlin-> great tips. do you have any for smarter indentation?  to avoid toggling them with tab until you find the right one
02:31:44 <johnw> sadly, no
02:31:47 <johnw> i toggle with the rest of them
02:32:19 <quicksilver> haskell-indentation-mode doesn't involve toggling with tab
02:32:41 <quicksilver> it is TAB to go right a stop and BACKSPACE to go back a stop. I find it pretty fast and intuitive.
02:32:51 <johnw> quicksilver: that is the one I'm using
02:32:59 <johnw> it gets it right often enough to be good
02:33:07 <quicksilver> yes. I wouldn't call it toggling.
02:33:14 <johnw> fair enough
02:33:19 <quicksilver> the older haskell-indent-mode cycled through them in contrast
02:33:23 <quicksilver> and got it right much less often
02:33:28 <quicksilver> and didn't have a full parser
02:33:32 <quicksilver> *that* was like toggling :)
02:33:51 <johnw> ghc-complete is better than I realized
02:33:57 * johnw integrates it with auto-complete now...
02:34:10 * quicksilver suddenly recognises johnw's nick.
02:34:36 <johnw> i don't look the same when I'm not in #emacs, do I? :)
02:34:48 <quicksilver> no. This place is much more civilized.
02:34:48 <startling> speaking of which, are you the ledger johnw?
02:34:52 <johnw> yes
02:35:23 <startling> johnw: thanks! your software (or, well, the haskell spin-off) is really helpful to me
02:35:46 <johnw> that's good to hear; I'm currently working on the Haskell code that will become the next generation of C++Ledger
02:35:59 <johnw> i'm hoping for an hledger/ledger merge at some point
02:36:17 <startling> interesting
02:36:35 <startling> it does seem like it's the kind of thing haskell would be better at expressing, anyway.
02:36:54 <johnw> i agree
02:40:30 <johnw> nice, all i needed was: (setq ac-sources (list 'ac-source-words-in-same-mode-buffers 'ac-source-ghc-mod)), and now I get completion for all imported symbols
02:45:20 <latermuse> is there a "notIsInfixOf" command? Say for example I wanted to filter out every member of this list that contains "foo" ->   filter (notIsInfixOf "foo") ["foo","bar","baz"]  will return ["bar","baz"]
02:45:38 <johnw> not . isInfixOf?
02:45:50 <latermuse> johnw: does that actually work?
02:45:53 <mauke> no
02:46:18 <johnw> ah, it is mauke
02:46:35 <mauke> not . isInfixOf "foo" will, though
02:46:36 <latermuse> yeah, the not.isInfixOf doesnt work
02:46:40 <fmap> @ty not .: isInfixOf
02:46:42 <lambdabot> Eq a => [a] -> [a] -> Bool
02:47:00 <latermuse> nice! that did work
02:47:02 <mauke> latermuse: "doesn't work" is not a problem description
02:47:13 <latermuse> not . isInfixOf $ "foo" doesnt work
02:47:21 <latermuse> not . isInfixOf "foo" does work
02:47:30 <latermuse> wonderful. thanks guys :D
02:47:44 <shachaf> latermuse: Please note that "doesn't work" is still not a problem description.
02:47:51 <shachaf> You should listen to mauke and learn how to ask good questions.
02:48:03 <latermuse> Will do.
02:48:12 <johnw> as long as he isn't being caustic to those who try to answer them
02:48:38 <latermuse> I cant imagine coming off as caustic. Sorry if I did.
02:48:44 <johnw> not you
02:48:47 <johnw> mauke
02:49:26 <shachaf> mauke was being reasonable.
02:49:32 <mauke> johnw: as long as you don't give wrong answers three times in a row :-)
02:49:47 <johnw> mauke: I am trying, really I am
02:50:12 <johnw> i'm still at the point where I learn more by trying to answer people's questions here than those people probably get from my attempts
02:51:10 <johnw> shachaf: I was referring to something that happened yesterday anyway, not now
02:51:30 <shachaf> OK.
02:53:10 * startling pours lye over #haskell
02:54:17 <johnw> what would lye do to us?
02:54:26 <johnw> i can imagine it being very painful
02:55:22 <shachaf> I think the way #haskell is headed, I'll have to leave it one of these days.
02:56:29 <johnw> shachaf: you often have some of the most valuable things to say
02:57:48 <shachaf> johnw: If that was true, it would perhaps be a good reason to leave. :-)
02:57:54 <johnw> lol
02:58:16 <bxc> how do people here pronounce *> and <* and <*> out loud?
02:58:19 <johnw> i think of you as #haskell's tough love component
02:58:27 <shachaf> (Fortunately it isn't.)
02:58:29 <mauke> bxc: no
02:59:23 <startling> bxc: I pronounce "<*>" as ap
02:59:28 <startling> never had to pronounce the others
02:59:36 <startling> (or "applied to")
02:59:46 <zomg> There was a stack overflow post about that quite recently I think
02:59:51 <zomg> how to pronounce various haskell operators
02:59:55 <johnw> no human languages approximates my pronunciation of <*>
03:00:06 <zomg> http://stackoverflow.com/questions/7746894/are-there-pronounceable-names-for-common-haskell-operators
03:00:06 <Lethalman> zomg, just >> iirc, it was anonymous bind
03:00:15 <bxc> http://stackoverflow.com/questions/3242361/haskell-how-is-pronounced
03:00:15 <Lethalman> ops
03:00:16 <shachaf> johnw: It didn't use to be that way.
03:00:21 * Lethalman confused with reddit :)
03:00:48 <startling> less-than asterisk greater-than
03:01:08 <johnw> when I read <* in parsec code, I think "I want the left"
03:01:15 <startling> yeah, me too.
03:02:40 <startling> I guess "keeping the left/right" is a reasonable way to pronounce those.
03:02:52 <`ramses> I always stumble on <=< and >=>, I'll have to try the fish stuff from that SO link
03:03:03 <srhb> `ramses: fishy combinators are fun.
03:03:20 <srhb> I've not yet found a use for *> or <* , but I guess that's because I really don't know what they are good for.
03:03:29 <Eduard_Munteanu> I think I produce some sort of "hm" in my head when I read those operators.
03:03:38 <Eduard_Munteanu> Not sure if distinct hms, but still. :)
03:03:39 <`ramses> srhb: when using parsec you use those often
03:03:58 <mauke> srhb: parenthesizedExpr = char '(' *> expr <* char ')'
03:04:04 <zomg> I did some parsec stuff and <|> was pretty much the only one I used
03:04:06 <`ramses> (the <* and *> I mean)
03:04:07 <zomg> :P
03:04:16 <srhb> mauke: Oh, that is nice.
03:04:20 <mauke> exprStatement = expr <* char ';'
03:04:30 <srhb> Right right.
03:04:31 <shachaf> @yarr ';'
03:04:31 <lambdabot> What be a priate's favourite cheese?
03:04:31 <lambdabot> Yarrlsburg!
03:04:39 <`ramses> zomg: then how did you drop unneeded delimiters and such?
03:05:01 <zomg> I may have used do notation and just ignored such things :P
03:05:14 <quicksilver> I've never read *> or <* out line but I think if I was teaching a course or something I'd go for "left star" and "right star"
03:05:26 <johnw> *> and <* are the Applicative forms of >> and <<
03:05:27 <srhb> How cute. :P
03:05:40 <johnw> > print 10 *> print 20
03:05:41 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
03:05:41 <lambdabot>    arising from a use of ...
03:05:51 <johnw> hmm.. that works in ghci...
03:05:51 <quicksilver> johnw: not quite.
03:05:59 <johnw> :t (>>)
03:06:01 <lambdabot> Monad m => m a -> m b -> m b
03:06:02 <johnw> :t (*>)
03:06:03 <lambdabot> Applicative f => f a -> f b -> f b
03:06:07 <quicksilver> johnw: *> is indeed like >>
03:06:12 <quicksilver> however <* is not like <<
03:06:15 <johnw> ah, ok
03:06:23 <johnw> thanks for clarifying that
03:06:24 <quicksilver> it performs the effect left to right
03:06:28 <bxc> you can keep adding more bracketed-with-<* on the edges with more <* and *> as long as the arrows all point inwards to one inner parser
03:06:33 <shachaf> quicksilver: Mostly because there is no (<<).
03:06:43 <johnw> haha
03:06:44 <quicksilver> putStr "a" <* putStr "b" will output "ab"
03:06:45 <johnw> !
03:06:46 <srhb> quicksilver: What does that mean?
03:06:52 <bxc> (well you can do other things as well but then its not so pretty and you have to think about precedence)
03:06:55 <quicksilver> but putStr "a" << putStr "b" would output "ba"
03:07:04 <quicksilver> (if << = flip (>>) was in the standard library)
03:07:08 <srhb> Ah, yes.
03:07:18 <Eduard_Munteanu> cout << "a"
03:07:29 <shachaf> quicksilver: OK, but if (<*) = flip (*>) was in the standard library, then the same would be true for *<
03:07:32 <shachaf> Er, for <*
03:07:45 <quicksilver> shachaf: yes. But it isn't.
03:07:52 <quicksilver> whilst =<< does exist
03:07:54 <shachaf> And (<<) = flip (>>) isn't either.
03:07:55 <bxc> but thatsa a different <* than the <* that is in the std lib
03:07:58 <quicksilver> so << would have to be flip (<<)
03:08:23 <shachaf> I'm not so sure about that, but arguing about hypothetical functions seems pretty pointless.
03:08:50 <bxc> >> point sin the direction of computation, *> points at the result you want to keep
03:09:14 <bxc> "direction of computation" == direction of effect ordering or whatever the right way to describe that is
03:09:28 <srhb> In other words, for things where only the side effects matter, there's no difference between *> and <*?
03:09:44 <mm_freak_> i love how functional maxima is‚Ä¶
03:09:44 <shachaf> They are both left-to-right, yes.
03:09:45 <`ramses> srhb: they influence the output, not the effects
03:09:46 <bxc> yes, i think so
03:09:47 <mm_freak_> wxplot2d(map(rhs, solve(y^2 = x^3 - 2*x + 10, y)), [x, -3, 10]);
03:09:48 <quicksilver> correct
03:09:55 <mm_freak_> the only thing missing is currying
03:09:57 <bxc> you'll end up with a different valu eto discard at the end
03:09:57 <Eduard_Munteanu> Well, Applicatives don't really have a notion of sequencing.
03:10:00 <shachaf> a <* b = do { x <- a; y <- b; return x }
03:10:05 <quicksilver> Eduard_Munteanu: yes, they do.
03:10:05 <mauke> quicksilver: I have defined << before and it was equivalent to <*
03:10:06 <shachaf> a *> b = do { x <- a; y <- b; return y }
03:10:12 <shachaf> (Except Applicative.)
03:10:13 <quicksilver> mauke: fair enough.
03:10:22 <mauke> and then everyone yelled at me
03:10:22 <srhb> shachaf: Right, thanks.
03:10:22 <Eduard_Munteanu> Not as much as monads anyway.
03:10:25 <bxc> Eduard_Munteanu: i disagree.
03:10:33 <johnw> mauke: clearly I would not have yelled :)
03:10:36 <quicksilver> mauke: for me the =<< argument is the stronger one.
03:10:45 <mm_freak_> Eduard_Munteanu: applicatives are /the/ notion of sequencing
03:10:48 <quicksilver> mauke: but shachaf is right about hypothetical functions.
03:10:54 <mauke> quicksilver: I didn't care about =<<, I just wanted to write parsers
03:10:59 <bxc> they have sequencing, but the amount that the earlier things can affect the later things is less in applicative than it is in monads
03:11:04 <mauke> (later on I learned about Applicative)
03:11:05 <quicksilver> Eduard_Munteanu: applicatives have precisely the same notion of sequence as monads.
03:11:46 <mm_freak_> Eduard_Munteanu: Applicative is actually more sequency than Monad
03:12:08 <mm_freak_> if you have a sequence in Applicative, its structure can't depend on individual outcomes
03:12:09 <Eduard_Munteanu> Actually hm... I guess I didn't think this through.
03:12:33 <Eduard_Munteanu> I was thinking of parser-y stuff like above.
03:12:41 <bxc> parsers are still sequenced
03:12:51 <Eduard_Munteanu> (e.g. drop delimiters and give me "that")
03:12:59 <shachaf> quicksilver: Oh, *> will be very useful for testing Bazaars.
03:13:05 <shachaf> I wish I'd thought of it earlier.
03:13:11 <shachaf> (Then again, it's just mappend.)
03:13:20 <mm_freak_> Eduard_Munteanu: applicative parsers are the ultimate in context-freeness, which is basically:  there is a sequence of tokens, and it can't depend on earlier tokens
03:13:28 <mm_freak_> to get the dependency you already need Alternative
03:14:41 <bxc> getting from there via arrows to monads can be quite subtle
03:17:09 <shachaf> Then again, *> and <* for Const are both just mappend.
03:18:48 <srhb> Conceptually, Applicatives are Monads without bind, and therefore(!) you get sequencing, but not control flow?
03:19:06 * bxc nods
03:19:12 <mm_freak_> srhb: Applicatives aren't monads without bind
03:19:20 <bxc> they are to me!
03:19:26 <mm_freak_> they are monads without bind and with 'ap'
03:19:30 <srhb> mm_freak_: Do the haskell squint.
03:19:31 <srhb> :P
03:20:03 <srhb> Right, so that's <*>
03:20:22 <startling> srhb, another way to think of it is that >>= lets you pick a monadic action based on a value
03:20:37 <bxc> you do get some stuff that looks a bit control-flowy without monads, for example, look at "many" for parsers - that uses alternative, not monads
03:20:37 <srhb> That's how I thought of it. :)
03:21:13 <mm_freak_> you can almost everything you get from Monads, if you have ArrowChoice
03:21:54 <mm_freak_> the only thing missing then is the ability to embed computations you have generated as part of the computation
03:22:21 <srhb> Right.
03:22:32 <mm_freak_> and that's not a big loss in most cases
03:23:08 <bxc> i think almost all of my "do" notation use would work in Applicative without monad
03:23:23 <bxc> (i.e. i'm using it as sigar for wiring around return values)
03:23:29 <bxc> maybe not "almsot all" but "lots"
03:23:34 <bxc> s/sigar/sugar/
03:23:48 <mm_freak_> many of the *M functions are actually applicative
03:24:01 <mm_freak_> replicateA, sequenceA, foreverA, ‚Ä¶
03:24:34 <srhb> but you can't have an untilA
03:24:49 <Lethalman> :t untilM
03:24:50 <lambdabot>     Not in scope: `untilM'
03:24:51 <lambdabot>     Perhaps you meant `until' (imported from Prelude)
03:26:34 <bxc> could you do that with Alternative?
03:26:38 <mm_freak_> srhb: you can have untilA, where the A stands for Alternative
03:26:39 <keep_learning> Could some one please tell me how to add compiler pragma in source code. I am compiling file ghc -O2 -threaded -rtsopts -fllvm Filename.hs and want to add -O2 -threaded -rtsopts -fllvm to source file.
03:27:01 <srhb> Hm, I guess I need to read up on Alternative.
03:27:03 <mm_freak_> keep_learning: {-# OPTIONS_GHC -O2 ‚Ä¶ #-}
03:27:03 <bxc> so thats going off in a different direction
03:27:10 <shachaf> -threaded -rtsopts don't generally belong in source files.
03:27:14 <shachaf> They are link-time options.
03:27:20 <mm_freak_> keep_learning: but the better alternative is to use cabal
03:27:32 <shachaf> cabal or a Makefile or something.
03:27:40 <mm_freak_> keep_learning: create a directory, cd to it and type 'cabal init'
03:28:03 <keep_learning> mm_freak_, Thank you!
03:35:08 <shachaf> i love monoids
03:35:10 <shachaf> they are so easy
03:36:05 <keep_learning> I have added the following {-# OPTIONS_GHC  -O2 -rtsopts -threaded   #-} but getting this error  unknown flag in  {-# OPTIONS_GHC #-} pragma: -threaded
03:36:47 <shachaf> keep_learning: Did you read what I said above?
03:37:34 <keep_learning> shachaf, For cabal file , yes but just wanted to know why this -threaded is only throwing error.
03:37:59 <shachaf> I didn't say anything about cabal files?
03:39:47 <keep_learning> shachaf, Oh , Sorry I missed it some how :(.
03:40:25 <keep_learning> shachaf, Thanks again :)
03:57:31 <Henryk_> Hello.
03:57:36 <Eelis> greetings
03:57:43 <Henryk_> fro?
03:57:45 <Henryk_> from?
03:57:49 <Eelis> from me!
03:57:59 <Henryk_> from where?
03:58:01 <Henryk_> :D
03:58:04 <Eelis> i'm from the internets!
03:58:19 <mauke> my hovercraft is full of eelis
03:58:38 <Henryk_> *nomnomnom* eelis!
03:58:44 <Eelis> ^_^
03:59:09 <Henryk_> Welcome,phenom!
03:59:19 <Henryk_> bye, kakashi!
03:59:23 <Henryk_> ^^
03:59:37 <mauke> Henryk_: this is actually a Haskell channel
03:59:59 <Henryk_> Yes.
04:20:32 <krautguy> jeah hi, i got a problem.. the compiler wont take my code, cause it produces (in hugs and ghc) "lexical errors" .. look here http://pastebin.com/XFbvjaCj   its about the ' in "showline"
04:20:36 <mauke> The paste XFbvjaCj has been copied to http://hpaste.org/81218
04:21:15 <mauke> creative
04:21:24 <krautguy> i dont know how to produce the right symbol, so the compiler would accept it
04:21:38 <mauke> ‚Äô is not '
04:21:56 <krautguy> it takes no ` no ¥ and no '
04:22:20 <mauke> ‚Äô is not ¬¥ either
04:22:44 <mauke> also you want " for strings
04:23:05 <krautguy> now i am confused.. in my script (its a pdf) it says í  but it doesn't take it
04:23:29 <mauke> that's because ‚Äô is wrong
04:23:41 <krautguy> lexical error at character '\8217'
04:23:42 <mauke> character literals are written with '
04:23:47 <mauke> exactly
04:25:20 <basdirks> if I have data T a = A a | B a (Maybe [T a]), I know how to go through it with fmap, but how would I remove any T x for which p x == False? What typeclass am I looking for?
04:26:23 <shachaf> Maybe there's no type class for it.
04:26:26 <mauke> what do you mean by 'T x'?
04:26:35 <shachaf> The answer might just be a function.
04:26:36 <shachaf> Also that.
04:26:58 <mauke> this is a curious type
04:27:01 <srhb> Very strange.
04:27:02 <basdirks> erm yes I mean A x etc
04:27:18 <mauke> equivalent to T a = A a (Maybe (Maybe [T a]))
04:27:33 <basdirks> x :: T Sometype
04:27:41 <shachaf> data T a = A a (Either Bool [T a])
04:27:55 <b_jonas> mauke: almost. the one you give is lazier
04:28:40 <shachaf> Hmm, that's a cofree comonad.
04:28:56 <basdirks> in fact, I meant data T a = T a (Maybe [T a]) >_>
04:29:08 <shachaf> That's also a cofree comonad. :-)
04:29:21 <ocharles> must stop reading that as the coffee comonad :(
04:29:52 <`nand`> data Cofree f a = (a, f (Cofree f a)) -- ?
04:30:01 <basdirks> shachaf: where'd I read about that shachaf?
04:30:13 <shachaf> `nand`: Other than the tuple on the outside, yes.
04:30:18 <shachaf> ocharles: Enjoying a cuppa cofree?
04:30:28 <shachaf> basdirks: Hmm, I don't know.
04:30:30 <owst> ocharles: You can extract Coffee from the CoffeePot Comonad, or something
04:31:18 <shachaf> Hmm. Is Maybe [a] isomorphic to ([a],Bool)?
04:31:40 <shachaf> I guess so.
04:31:43 <`nand`> ([1,2,3], True) -> ?  ([1,2,3], False) -> ?
04:31:53 <shachaf> I guess not.
04:32:00 <shachaf> You can't trust my 4AM guesses.
04:32:10 <shachaf> I mixed it up.
04:32:38 <basdirks> I know how to define it with explicit recursion
04:32:46 <basdirks> but I'm pretty sure I'm missing a better way
04:33:04 <shachaf> Explicit recursion would probably be the standard way of doing whatever it is that you're doing.
04:35:15 <`nand`> a viable approach is to use explicit recursion first, then reduce that by going from there (eg. reducing list recursion to maps or folds)
04:35:29 <basdirks> yeah `nand` I'll go that route
04:37:46 <krautguy> okay i found the solutions, thanks...
04:55:31 <ocharles> owst: not only could i extract coffee from the coffee comonad, I can extend it with more coffee!
04:56:19 <owst> :-)
04:56:53 <shachaf> i love coffee commands
04:56:57 <shachaf> they are so easy
04:56:58 <`nand`> don't forget duplicate
04:57:28 <owst> CoffeePots filled with CoffeePots!
04:58:09 <bxc> pis this another monad analogy?
04:58:42 <srhb> Cofree Comonad analogy? They are like coffee pots.
04:58:45 <srhb> Apparently.
05:00:11 <shachaf> i love cofree comonads
05:00:13 <shachaf> they are so easy
05:00:25 <shachaf> srhb: You should learn about them!
05:00:31 <shachaf> ocharles: So should you!
05:00:49 <`nand`> do you like cofree comonads or free monads more?
05:01:29 <srhb> shachaf: I actually just found edwardks slides about them. Wonder if that will do.
05:01:49 <shachaf> srhb: Cofree is not a complicated type.
05:02:07 <srhb> Well, comonad first
05:02:07 <shachaf> (Cofree f) a = (a, f (a, f (a, f (a, ...
05:02:18 <shachaf> Comonad is not a type at all.
05:02:19 <srhb> I assume it's something that has "extract" rather than "return" :P
05:02:29 <shachaf> But I just told you what Cofree is!
05:02:36 <srhb> Okay!
05:02:39 <shachaf> For example, (Cofree Maybe) is non-empty lists.
05:02:49 <shachaf> (Or is that non-empty colists?)
05:02:52 <srhb> What.
05:03:30 <shachaf> srhb: You can use free monads instead, if you prefer.
05:03:31 <`ramses> shachaf: that's nice! :)
05:03:31 * `nand` defaults ConstraintKinds on
05:03:50 <`nand`> Cofree Identity = Stream
05:03:54 * shachaf doesn't listen to people whose nick starts with `
05:03:56 <`nand`> perhaps the simplest
05:04:09 <shachaf> Cofree Null = Identity
05:04:11 <shachaf> simpler??
05:04:13 <`ramses> \me feels left out now..
05:04:23 <`ramses> damn
05:05:01 <Eduard_Munteanu> Um, then Cofree Maybe is just lists.
05:05:07 <`nand`> Eduard_Munteanu: nonempty
05:05:13 <srhb> I have a feeling that people, after a while, have an intuition about what co- actualy means, for whatever follows :P
05:05:41 <Eduard_Munteanu> Oh, yeah, nevermind.
05:06:04 <shachaf> srhb: Maybe some people!
05:06:15 <srhb> shachaf: People, not me. :P
05:06:43 <shachaf> i love monoids
05:06:44 <shachaf> they are so easy
05:08:26 <aleator_> Is there any way from stop blaze-html from indenting the contents of pre tag when the pre tag is inside a div?
05:16:25 <osfameron> isn't that determined by CSS?
05:16:38 <osfameron> and if not, huh?
05:17:00 <`nand`> I think indentation here refers to code indentation
05:18:48 <osfameron> ah
05:19:07 <osfameron> carryon,soldier
05:26:44 <frerich> Hm, just noticed that Intel's upcoming processor generation 'Haswell' features hardware transactional memory (see http://software.intel.com/en-us/blogs/2012/02/07/transactional-synchronization-in-haswell/ ) - made me wonder whether the name 'Haswell' is a pun ;-)
05:26:51 <ocharles> aleator_: pretty sure blaze doesn't produce whitespace like that
05:27:13 <shachaf> frerich: No.
05:28:31 <wuttf> I defined a class C a b c | a -> b, b -> c, and an instance for it  like instance C a' b' c', but 10 lines below when I actually want to use a', b' or c' with the functions of C it says no instance defined. Any ideas?
05:29:05 <shachaf> Why a -> b, b -> c rather than a -> b c?
05:29:41 <wuttf> shachaf: Means the same?
05:30:32 <shachaf> wuttf: You should learn the rule of asking questions.
05:30:41 <shachaf> Say (a) what you did (b) what you expected (c) what you got
05:30:44 <shachaf> This may involve hpaste
05:32:10 <wuttf> shachaf: I don't want to drag anybody into solving my problems I am just curious if there is common newbie mistake which results in this, like not setting the language pragmas (what I did)
05:34:52 <shachaf> wuttf: I appreciate not wanting to drag people into solving your problems.
05:35:15 <Saizan> wuttf: you should also not mangle your actual problem into a form that might not have it anymore
05:35:23 <shachaf> But in practice underspecifying your problems is even worse: You're dragging people into making random guesses about what could be wrong.
05:35:27 <Saizan> wuttf: in general you don't know which details are relevant
05:35:37 <shachaf> Right, what Saizan said.
05:35:49 <shachaf> If you knew exatly what was up with your problem, it wouldn't be a problem anymore. :-)
05:36:25 <wuttf> I see. I will try to reproduce it in as few lines as possible.
05:36:38 <Saizan> many lines are fine
05:37:05 <Saizan> for example the actual instance and the actual error might be sufficient here
05:37:22 <shachaf> Reducing the problem is a great exercise, though. Often you figure out the problem yourself by doing that.
05:37:33 <shachaf> But in general people are OK at skimming.
05:43:29 * hackagebot gemstone 0.2 - A simple library of helpers for SDL+GL games.  http://hackage.haskell.org/package/gemstone-0.2 (CorbinSimpson)
05:46:29 <wuttf> I can't believe it, the 15 line version works perfectly. :D
05:48:30 <Saizan> now you're just teasing us :)
05:50:08 <shachaf> I suggest that you shouldn't have a type class in the first place.
05:53:29 * hackagebot yesod-platform 1.1.7.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.7.2 (MichaelSnoyman)
05:53:31 <Saizan> wuttf: anyhow i think the problem is that type inference can only pin down the b or c parameter to a concrete enough type, so it doesn't know if it should pick that particular instance because the 'a' parameter is not determined by the others
05:53:50 <wuttf> Saizan: Ain't intentional. shachaf : But I like the idea of typeclasses so much!
05:54:10 <shachaf> wuttf: That's exactly the problem.
05:56:41 <srruby> Parsec: Any tips on debugging? How can I inspect what was consumed?
05:57:06 <fmap> wuttf: you only allowed to use typeclasses when you don't like them
05:57:24 <mysticc> why ghc does not have primitive rotate function?
05:57:50 <Saizan> shachaf: you should get rid of typeclasses in lens
05:58:07 <shachaf> Saizan: Agreed.
05:58:16 <shachaf> (Not really agreed.)
05:58:34 <wuttf> fmap: Shit. Is the inverse true too?
05:59:19 <mroman> srruby: Debug.Trace is what I usually used.
05:59:32 <mroman> That, and ghci debugging features like breakpoints etc.
06:00:03 <srruby> mroman: Do you know how I can access what was consumed when the parse failed?
06:00:11 <mroman> or you might want to have a look at <?>
06:01:03 <mroman> srruby: No. @consumed
06:01:36 <mroman> Except what parsec error already states like (error line x, column y)
06:01:55 <srruby> mroman: OK. Thanks
06:01:58 <mroman> But sadly that does not help with non-trivial bugs.
06:02:28 <chrisdone> herp https://dl.dropbox.com/u/62227452/Screenshots/Screenshot%20from%202013-01-24%2014%3A59%3A03.png
06:04:19 <applicative> hugs!
06:04:29 <chrisdone> \o/
06:04:55 <applicative> what are you up to?
06:05:22 <zomg> chrisdone: heh, compiled hugs with ghcjs? :D
06:05:37 <applicative> hugs is a c program
06:05:48 <chrisdone> compiled hugs to javascript with emscripten, just to see if it would work. it does =)
06:05:50 <zomg> ah emscripten then I guess
06:05:54 <zomg> nice
06:06:06 <chrisdone> kinda slow, but i'll upload it anyway as it could be a useful teaching thing
06:08:53 <Singularity12345> Hello
06:10:06 <TorosFanny> hello:
06:10:32 <TorosFanny> whether >>= of IO is strict or lazy?
06:12:55 <quicksilver> it's not strict
06:13:09 <quicksilver> although I very much doubt that's what you really want to ask.
06:13:38 <Eduard_Munteanu> TorosFanny: it shouldn't matter as much as you might think, see evaluation vs execution
06:14:13 <quicksilver> > ((error "left" >>= error "right") :: IO ()) `seq` 1
06:14:15 <lambdabot>   1
06:14:20 <quicksilver> ^^ strict in neither argument.
06:14:26 <TorosFanny> But, when I try "sequence $ repeat getLine" it works fine
06:14:39 <quicksilver> yes, it does.
06:15:15 <TorosFanny> On contrast, wrong = do {fileData <- withFile "test.hs" ReadMode hGetContents;putStr fileData}get nothing
06:15:43 <quicksilver> that's just because hGetContents is broken
06:15:50 <quicksilver> which has nothing to do with strictness or laziness
06:15:50 <TorosFanny> learned from HaskellWiki, a common mistake on lazy IO
06:15:55 <quicksilver> just hGetContents being a stupid thing.
06:16:06 <ion> Lazy IO is a common mistake. ;-)
06:16:25 <quicksilver> Indeed. Also, lazy IO is nothing to do with laziness.
06:16:57 <Eduard_Munteanu> unsafeInterleaved IO
06:17:02 <TorosFanny> you mean IO is lazy is a mistakeÔºü
06:17:32 <quicksilver> TorosFanny: "lazy" IO is quite fiddly and can cause all kinds of trouble if used without proper understanding.
06:17:33 <Eduard_Munteanu> It's a broken model that sometimes works.
06:17:45 <int-e> TorosFanny: for most serious programs, yes, it is.
06:17:46 <quicksilver> it's also not actually the same thing as laziness in the sense of strict-vs-lazy
06:17:56 <quicksilver> so the use of the word "lazy" to describe it leads to further confusion.
06:18:04 <int-e> TorosFanny: but it's highly convenient for simple processing tasks.
06:18:06 <capisce> didn't SPJ say that laziness by default was a mistake?
06:18:24 <quicksilver> no, he said that laziness by default was the most important (correct) decision haskell ever made
06:18:32 <quicksilver> at least, that's the way I remember the talk :)
06:18:49 <int-e> "laziness kept us pure" is what I remember as a key point
06:18:50 <basdirks> is there an idiom for map f . filter p?
06:19:21 <capisce> how do you explain his quote "The next Haskell will be strict"?
06:19:29 <int-e> basdirks: that looks idiomatic already
06:19:31 <int-e> (to me)
06:19:37 <RichyB> basdirks: that.
06:19:43 <Eduard_Munteanu> capisce: where do you get those quotes from?
06:19:54 <Eduard_Munteanu> Uncyclopedia? :)
06:20:09 <capisce> Eduard_Munteanu: well, there's a discussion about it here for instance, with references
06:20:12 <capisce> Eduard_Munteanu: http://news.ycombinator.com/item?id=1924061
06:21:11 <chrisdone> capisce: he's talking about idris :p
06:21:25 <capisce> chrisdone: idris?
06:21:46 <chrisdone> idris ~= haskell - laziness + dependent types
06:22:04 <capisce> chrisdone: right
06:22:35 <capisce> will have to look into that :p
06:22:39 <chrisdone> there's also Disciple, a strict haskell, but its compiler isn't really ready for human consumption
06:22:53 <chrisdone> iirc have to type annotate everything
06:23:10 <capisce> ah, no type inference?
06:23:13 <Eduard_Munteanu> Or look into Agda and strictness won't matter semantically. :P
06:23:51 <TorosFanny> quicksilver  what do you mean by saying  ((error "left" >>= error "right") :: IO ()) `seq` 1
06:24:47 <`nand`> he's calling (>>=) on two values that will throw an exception if forced, then forcing the result of that
06:25:06 <`nand`> if forcing the result of (>>=) were to force its parameters (eg. if it were strict), then one of the exceptions would have triggered
06:25:18 <TorosFanny> only (error "left" >>= error "right") will make mistake
06:25:55 <chrisdone> except seq doesn't run IO actions, so the output will just be 1
06:26:07 <TorosFanny> so (`seq` 1) is non-strict on the left side in contrast with it usually be
06:26:08 <chrisdone> so he's really saying that IO actions are pure values
06:26:41 <chrisdone> > head [] `seq` 1 -- TorosFanny seq is strict in its first argument
06:26:43 <lambdabot>   *Exception: Prelude.head: empty list
06:27:45 <chrisdone> but force an IO a and you get an IO a, just like forcing [1] gets you [1]. the inner computation is only run by main, or other special primops
06:28:12 <chrisdone> > [error "blah"] `seq` 1
06:28:14 <lambdabot>   1
06:28:32 <TorosFanny> so [head []]
06:28:44 <chrisdone> will just return [head []], sure
06:28:45 <TorosFanny> so [head []]  `seq` 1
06:28:46 <TorosFanny> 1
06:28:49 <chrisdone> yup
06:29:09 <TorosFanny> Just $ head[] `seq` 1 is 1
06:29:29 <Eduard_Munteanu> Also, seq only forces to WHNF.
06:29:47 <chrisdone> ‚ÄúJust $ ‚Ä¶‚Äù is Just ‚Ä¶
06:30:01 <arafel> ghci
06:30:01 <TorosFanny> forgive my mistake
06:30:04 <arafel> oops.
06:30:46 <TorosFanny> but the (error "left" >>= error "right") seems really strange,
06:31:35 <TorosFanny> how the error "right" is a (a->m a) function
06:31:47 <Eduard_Munteanu> :t error
06:31:48 <lambdabot> [Char] -> a
06:32:00 <srhb> Isn't it a bit strange that Data.Binary.Get.skip :: Int -> Get () when System.IO.hFileSize :: Handle -> IO Integer ?
06:32:08 <Eduard_Munteanu> let a = x -> m x
06:32:42 <ion> torosfanny: error "something" has any type you want. It doesn‚Äôt matter because it will raise an exception when you try to evaluate it.
06:33:20 <TorosFanny> I understand
06:33:24 <ion> @type error "hai" :: Maybe (Either CReal (IO (a -> Integer)))
06:33:26 <lambdabot> Maybe (Either CReal (IO (a -> Integer)))
06:34:13 <chrisdone> any value you see like x :: a, or f :: String -> a will necessarily throw an exception
06:34:38 <TorosFanny> so the  ((error "left" >>= error "right") :: IO ()) `seq` 1 gives 1 just because the IO () holds error "something" unevaluated?
06:34:44 <ion> chrisdone: Not necessarily. It can also recurse forever.
06:35:11 <chrisdone> TorosFanny: pretty much, one way of thinking about it
06:35:42 <ion> torosfanny: Or to put it another way, evaluating the IO () value in question won‚Äôt evaluate the error "‚Ä¶" values.
06:35:48 <chrisdone> ion: it's all _|_ so in practice it will throw an exception ime
06:36:10 <ion> @type fix id
06:36:11 <lambdabot> a
06:36:12 <ion> > fix id
06:36:16 <lambdabot>   mueval-core: Time limit exceeded
06:36:20 <quicksilver> TorosFanny: ...but that is what 'strict' means technically.
06:36:31 <quicksilver> which is what I meant when you I said I thoguht you were asking the wrong question.
06:36:46 <quicksilver> strict means that evaluating it forces the exceptions in its arguments
06:36:52 <TorosFanny> thanks very much, _|_ gives _|_ always
06:37:05 <quicksilver> so if >>= were indeed strict then error >>= error would raise an error merely by evaluating it.
06:37:21 <quicksilver> I'm not sure that's a very interesting fact, but it was the answer to the question asked.
06:39:01 <chrisdone> the io monad anyway
06:39:06 <TorosFanny> It's time to go bed in my country, thanks
06:40:43 <srhb> Hum, okay, it seems to be a ByteString thing. Why is it every take, drop, etc. takes Int64 when hFileSize is an Integer? It must be theoretically have files that are larger than what ByteStrings can handle then, and doesn't that explicitly defy the purpose of eg. Lazy ByteStrings?
06:43:19 <Eduard_Munteanu> My guess is platform limitations: you have 64bit offsets, and you can't seek more than that. But hFileSize happens to return an integer in that range.
06:43:34 <srhb> Okay.
07:10:24 <edwardk> srhb: re closing that issue, i did so before we realized the perf impact of Leftmost/Rightmost
07:31:44 <mysticc> If I have a dist folder in my cabal package then doing cabal install --force-reinstall do not rebuild the package?
07:32:27 <srhb> @hoogle Monad m => (a -> m a) a -> [b] -> m a
07:32:28 <lambdabot> No results found
07:32:31 <srhb> @hoogle Monad m => (a -> m a) -> a -> [b] -> m a
07:32:32 <lambdabot> No results found
07:32:34 <srhb> Hmm
07:33:13 <srhb> foldM (\a _ -> (a+) <$> getWord64le) -- I feel like I'm abusing foldM here, is there a more obvious candidate?
07:33:43 <srhb> Some.. sequence magic perhaps.
07:33:50 <S11001001> srhb: that'd be ff f a _ = f a
07:33:58 <hpaste> fragamus pasted ‚Äúwhy?‚Äù at http://hpaste.org/81220
07:35:08 <srhb> S11001001: Sorry, not understood?
07:35:16 <S11001001> Monad m => (a -> m a) -> a -> [b] -> m a
07:35:28 <fragamus> > 128 + 64 + 8 + 1
07:35:30 <lambdabot>   201
07:35:56 <S11001001> @ty ($>)
07:35:57 <lambdabot>     Not in scope: `$>'
07:35:57 <lambdabot>     Perhaps you meant one of these:
07:35:57 <lambdabot>       `$' (imported from Data.Function), `$!' (imported from Prelude),
07:36:04 <S11001001> @hoogle $>
07:36:04 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
07:36:04 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
07:36:04 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
07:36:48 <skuggi> > chr 201
07:36:50 <lambdabot>   '\201'
07:36:59 <fmap> fragamus: I don't think you can have partially applied type synonyms
07:37:31 <fragamus> well I can have them
07:37:39 <fragamus> but they won't do me any good
07:37:44 <fragamus> :P
07:38:33 <fragamus> Is there no way to put Gen in there?
07:39:33 <fragamus> It seems like a monad transformer stack would start getting awfully cluttered if there was no way to approach it in baby steps
07:39:49 <fragamus> it already looks cluttered
07:44:00 <mSSM> Just to check if the following makes sense: `sum.(map foo).(scanl (+) (e0,m0)) <$> replicateM n $ sum <$> replicateM l bar'  -- bar gives me a `IO a', and `sum' is supposed to combine the `IO [a]' -> IO a from the inner replicateM. Next, the other replicateM is supposed to give me (pseudo code) `IO [ sum [a] ]', which I then scanl/map/sum over. Does this make sense?
07:44:06 <mSSM> Or is there a nicer way to write this?
07:44:22 <srhb> without the brackets, surely
07:44:27 <srhb> :P
07:44:57 <mSSM> srhb: Don't stop there :P
07:45:14 <mSSM> I am actually not sure if the brackets and fixity is going to bite me in the ass here.
07:45:27 <mSSM> s/is/are/
07:45:43 <hpaste> fragamus annotated ‚Äúwhy?‚Äù with ‚Äúwhy? (annotation)‚Äù at http://hpaste.org/81220#a81221
07:46:34 <mSSM> (funny, #haskell has got to be the only channel, where I see people use unicode like ‚Äú‚Äù all the time)
07:47:02 <Hafydd> Are you sure it isn't just lambdabot and hpaste?
07:47:53 <mSSM> Hafydd: Yeah, I suppose you are right.
07:47:59 <mSSM> ¬ª.¬´
07:48:10 <Eelis> i wish the Haskell ecosystem was more unicode friendly. as it is, even something like Hoogle chokes on ‚Üí
07:49:13 <bscarlet> I'm currently tracking down a bug manifesting as some sort of signal (likely segfault or bus error) inside an FFI call inside an HUnit test inside test-framework. Some layer of my testing stack is semi-helpfully catching the signal, so I get a test-suite failure instead of a core dump. Anybody got any hints as to a practical way to get the information I'd typically get from a core dump - e.g. rough where inside the FFI call
07:49:13 <bscarlet> segfault happened?
07:49:54 <bscarlet> i.e. can I somehow turn off the presumed signal handler?
07:50:40 <mSSM> srhb: where do you think I can lose some brackets?
07:58:31 * hackagebot safeint 0.5.3 - overflow-checked Int type  http://hackage.haskell.org/package/safeint-0.5.3 (AndresLoeh)
08:03:32 * hackagebot graph-wrapper 0.2.4.2 - A wrapper around the standard Data.Graph with a less awkward interface  http://hackage.haskell.org/package/graph-wrapper-0.2.4.2 (MaxBolingbroke)
08:07:47 * hiptobecubic hates unicode text
08:09:03 <Botje> why?
08:09:24 <hiptobecubic> because it is usually unreadable compared to plain ascii
08:09:32 <fmap> mSSM: (map foo) -> map foo, (scanl (+) (e0,m0)) -> scanl (+) (e0,m0)
08:09:47 <hiptobecubic> >> is much easier to see than ¬ª
08:09:59 <Botje> oh, unicode like that.
08:10:07 <Botje> I don't hate it :)
08:10:48 <wmasson> is there a standard function that determines whether all the items in a list are distinct?
08:11:20 <mauke> not . null . drop 1 . group?
08:11:37 <Botje> nub xs == xs
08:12:23 <mSSM> fmap: Is there a typo?
08:12:23 <mauke> Botje: that looks terribly inefficient
08:12:25 <S11001001> > nub [1,2,1]
08:12:27 <lambdabot>   [1,2]
08:12:37 <mSSM> fmap: Oh, sorry; that's not aactual code
08:12:54 <mSSM> fmap: Ok, I understand; so I can safely get rid of those brackets?
08:13:07 <hiptobecubic> mauke, at what scale?
08:13:32 <wmasson> that would work, thanks
08:13:43 <fmap> mSSM: yes, function application binds tighter than infix operators
08:13:51 <Botje> mauke: was this a requirement?
08:14:21 <mauke> Botje: no, but the efficient solution isn't more complicated
08:14:24 <Eelis> maybe   Set.length (Set.fromList xs) == length xs
08:14:25 <bscarlet> > not . null . drop 1 . group $ [1,2]
08:14:28 <lambdabot>   True
08:14:36 <mauke> er
08:14:39 <bscarlet> > not . null . drop 1 . group $ [1,2,1]
08:14:41 <lambdabot>   can't find file: L.hs
08:14:50 <mauke> Botje: I'm sorry, I take back everything I've said
08:15:30 <parcs> http://en.wikipedia.org/wiki/Element_distinctness_problem
08:15:56 <bscarlet> > not . null . drop 1 . group $ [1,2,1]
08:15:58 <lambdabot>   True
08:18:32 * hackagebot ansi-terminal 0.6 - Simple ANSI terminal support, with Windows compatibility  http://hackage.haskell.org/package/ansi-terminal-0.6 (MaxBolingbroke)
08:20:41 <mSSM> Can someone explain to me how `join (***) sum' works again? How is (***) = m (m a)
08:21:25 <parcs> :t (***)
08:21:26 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:21:51 <parcs> mSSM: let m = (->) (a b c)
08:21:57 <quicksilver> given any binary function, join just repeats the argument
08:22:01 <robbe-> I think the wikipedia page could be more complete. It talks about expected linear time, but when the elements can be mapped distinctly to indices of an array, this becomes linear time worst case; think counting sort with a minimal variation.
08:22:03 <quicksilver> > join (+) 3
08:22:04 <lambdabot>   6
08:22:13 <quicksilver> join (+) 3 is just 3 + 3
08:22:22 <quicksilver> so join (***) sum is just sum *** sum
08:22:47 <quicksilver> except less polymorphic.
08:23:13 <parcs> :t join (***)
08:23:14 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
08:23:15 <mSSM> quicksilver: Yes, I understand what the effect is, what I don't understand is how it does it from it definition.
08:23:41 <quicksilver> mSSM: it's the (r->) monad
08:24:13 <mSSM> quicksilver: I don't understand what that even is :(
08:24:24 <quicksilver> well that's hte first thing you need to understand then.
08:24:50 <parcs> mSSM: 'a -> a -> b' is 'a -> (a -> b)' is '(->) a ((->) a b))' is 'm (m b)' where 'm = (->) a'
08:24:55 <quicksilver> the (r->) monad, or the reader monad, is a monad where every action has a common parameter (people call it 'the environment')
08:25:07 <napping> DerivingFunctor and DerivingFoldable are working really nicely for syntax
08:26:06 <mSSM> parcs: yeah, I see that now.
08:26:08 <mSSM> parcs: thanks
08:26:43 <Taneb> Could you make a simple parser as something like type Parser s a = StateT s [] a?
08:26:51 <mSSM> quicksilver: Ok, somebody told me yesterday that I should look at reader; I am not sure how it relates to join
08:26:55 <Philippa> you can do, yes
08:27:15 <Philippa> that won't get you backtracking/lookahead
08:27:18 <quicksilver> mSSM: it doesn't relate to join.
08:27:21 <Philippa> but for LL(1)? Works just fine
08:27:22 <quicksilver> mSSM: join works on all monads.
08:27:29 <quicksilver> mSSM: you happen, here, to be using the reader monad.
08:27:40 <napping> do the fixpoint of a base functor thing, handle boring cases of the free variable computaiton catamorphism by "fold", etc
08:27:49 <quicksilver> mSSM: step 1. understand reader monad. step 2. understand join in general. step 3. understand join in the reader monad.
08:29:20 <Taneb> Philippa, what would you need to get backtracking/look-ahead?
08:29:34 <Philippa> ErrorT around it is probably quickest
08:29:48 <Philippa> (not the fastest-performing approach, but should give you the semantic idea)
08:30:25 <Taneb> I thought the [] would be enough, but I haven't put much thought into it
08:31:33 <mSSM> If I look at hackage docs, where can I see how e.g. `>>=' is implemented for the Reader monad?
08:32:01 <ornicar> event sourcing in haskell - anybody tried that?
08:32:17 <ornicar> I can't find anything about it on the Internet
08:32:21 <otters> mSSM: click on "Source" next to class Monad m => MonadReader r m | m -> r
08:32:29 <otters> wait, never mind
08:32:45 <n-dolio> I don't see what the problem with StateT s [] is, either.
08:32:50 <quicksilver> mSSM: the source for control.monad I suspect
08:33:02 <n-dolio> That was the original naive 'representing failure as a list of successes' approach.
08:33:19 <quicksilver> ah no, annoyingly, those instances are in the prelude now
08:33:29 <quicksilver> which means you have to find which GHC base module they're in
08:33:32 * hackagebot lattices 1.2.1.1 - Fine-grained library for constructing and manipulating lattices  http://hackage.haskell.org/package/lattices-1.2.1.1 (MaxBolingbroke)
08:34:07 <quicksilver> mSSM: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html
08:34:20 <quicksilver> mSSM: (immediately under the definition of the Monad class)
08:37:03 <mSSM> quicksilver: how does: `f >>= k = \r -> k (f r) r' relate to `reader >>= readerGenerator = R $ \r -> runReader (readerGenerator (runReader reader r)) r '?
08:37:16 <mSSM> quicksilver: I can see some similarities, but it's still a bit different.
08:37:42 <quicksilver> they are the same but readers has a newtype "in the way"
08:38:32 * hackagebot ansi-wl-pprint 0.6.6 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  http://hackage.haskell.org/package/ansi-wl-pprint-0.6.6 (MaxBolingbroke)
08:38:33 <quicksilver> f >> k = R $ \r -> runReader (k (runReader f r)) r
08:38:36 <quicksilver> sorry
08:38:39 <quicksilver> f >>= k = R $ \r -> runReader (k (runReader f r)) r
08:38:46 <quicksilver> having renamed reader and readerGenerator.
08:38:49 <mSSM> quicksilver: yeah, precisely.
08:39:10 <quicksilver> then you just have 'runReader' which unpacks the newtype twice (once for f and once for k)
08:39:17 <mSSM> quicksilver: how does haskell automatigally pull `runReader' ?
08:39:18 <quicksilver> and R which packs it up agin
08:39:24 <mSSM> Yeah, I understand that! :)
08:39:24 <quicksilver> it doesn't
08:39:29 <quicksilver> there isn't any magic.
08:39:46 <BobbyMcLiar> Can you recommend any book on theoretical computer science, preferably without any prerequisites?
08:40:09 <hpaste> srhb pasted ‚ÄúOpenSubtitles moviehash -- review?‚Äù at http://hpaste.org/81223
08:40:47 <mSSM> quicksilver: So the link you gave me - it's actually not the definition of `bind' for `reader'?
08:40:52 <srhb> I tried rewriting the Haskell version of the OpenSubtitles moviehas algorithm in a fashion that only uses base, would anyone care to comment? I'd rather not submit it before I know I've not done something incredibly stupid. The hashing itself works, so mostly code style. :)
08:41:17 <quicksilver> mSSM: depends what you think I meant by 'reader' ;)
08:41:26 <quicksilver> mSSM: (r->) is known as the reader monad
08:41:37 <quicksilver> Reader r is also the reader monad, but it's a different one
08:41:43 <mSSM> gah
08:41:44 <quicksilver> you might call it the 'wrapped' reader monad
08:41:51 <quicksilver> they do represent the same thing
08:41:57 <quicksilver> but one has a newtype and one doesn't
08:42:17 <mSSM> quicksilver: how is somebody who is not a member of the inner circle supposed to get that? ;)
08:42:28 <srhb> Conversion, clearly.
08:42:41 <srhb> You will be assimilated.
08:42:49 <mSSM> You don't make it easy. :P
08:43:53 <quicksilver> mSSM: ask and ye shall receive?
08:44:08 <quicksilver> originally it was considered potentially confusing to make (->) into a Monad
08:44:21 <quicksilver> it makes various kinds of natural typos into valid haskell with surprising type signatures.
08:44:38 <quicksilver> so the instance was corralled away into an optional module and generally frowned upon
08:44:50 <quicksilver> but, in the end, people found it so useful to use the basic monad + functor combinators with (->)
08:44:54 <quicksilver> that the decision was changed.
08:45:30 <quicksilver> or the consensus changed, or something.
08:45:48 <otters> quicksilver: what kind of natural typo?
08:46:29 <quicksilver> otters: missing off the final argument of something.
08:46:33 <otters> oh
08:46:38 <otters> yeah I do that all the time
08:46:42 <quicksilver> not really a typo I suppose
08:46:46 <quicksilver> but, an easy mistake
08:46:48 <otters> common mistake
08:47:13 <quicksilver> :t do hPutStr h >> return 5
08:47:15 <lambdabot>     Not in scope: `hPutStr'
08:47:15 <lambdabot>     Perhaps you meant one of these:
08:47:15 <lambdabot>       `BSC.hPutStr' (imported from Data.ByteString.Char8),
08:47:27 <quicksilver> :t do System.IO.hPutStr h >> return 5
08:47:29 <lambdabot>     No instance for (FromExpr GHC.IO.Handle.Types.Handle)
08:47:29 <lambdabot>       arising from a use of `h'
08:47:29 <lambdabot>     Possible fix:
08:47:33 <quicksilver> :(
08:47:39 <quicksilver> :t \h -> do System.IO.hPutStr h >> return 5
08:47:40 <lambdabot> Num b => GHC.IO.Handle.Types.Handle -> String -> b
08:47:53 <quicksilver> ^^ what I did there is miss of the argument to hPutStr
08:48:01 <quicksilver> it was supposed to be in the IO monad, and it was an error
08:48:14 <otters> so what happens to the String that would get passed to that function?
08:48:17 <quicksilver> but with the (->) instance visible it turns into a use of the (->) monad
08:48:30 <quicksilver> which is potentially a strange thing to debug
08:48:35 <quicksilver> not the error message you're expecting.
08:48:54 <otters> is the String the second argument to hPutStr?
08:49:03 <srhb> Yes.
08:49:08 <otters> I mean, that's kinda cool
08:50:47 <edwardk> woot! trifecta head no longer depends on unreleased packages
08:51:14 <srhb> Neat!
08:52:10 <srhb> Would anyone take a look at this? I'm particularly bothered by the foldM: http://hpaste.org/81223 . A blessing to use it this way suffices. :P
08:52:17 <otters> anyone who uses Control.Exception.Lens, how do I translate code that uses catches (multiple Handlers for one exception-causing operation)?
08:56:51 <glguy> otters: You can still use multiple "catch"s
08:57:26 <Saizan> srhb: seems fair but i'd stick a evaluate in there
08:57:33 <srhb> Ie force it?
08:57:55 <mSSM> quicksilver: So essentially `join (***)' = `(***) >>= id', right?
08:58:08 <Saizan> srhb: i.e. you want to force in the step function
08:58:17 <srhb> Saizan: How do I do that?
08:58:44 <glguy> otters: but there isn't a way to easily compose prisms to get the exact same behavior
08:58:48 <edwardk> otters: i don't currently have a notion of those complex handlers
08:58:53 <otters> okay
08:58:55 <Saizan> srhb: i guess the easier way is to (\ !a _ -> (a+) `fmap` getWord64le) with {-# LANGUAGE BangPatterns #-}
08:59:03 <edwardk> i figured i'd release the stuff i could figure out how to do easily
08:59:38 <srhb> Saizan: OK, thanks. :)
08:59:47 <Saizan> srhb: (\ a _ -> getWord64le >>= \ x -> return $! (a + x)) -- might be better though
09:00:00 <edwardk> in theory nothing stops us from making a function to build a handler with a prism though
09:00:03 <edwardk> using the same reasoning
09:00:16 <fragamus> http://hpaste.org/81220
09:00:31 <mSSM> quicksilver: and if I write it out with the definition of >>= : (***) >>= id = \r = id ( (***) r) r   =   \r = (***) r r
09:01:10 <edwardk> oh
09:01:11 <mSSM> quicksilver: I still have not understood where the `(r->) monad comes in, but I think the above makes sense?!
09:01:12 <edwardk> i remember the problem
09:01:27 <edwardk> this doesn't work with prisms
09:01:45 <edwardk> because i can't make a handler that handles an arbitrary getter in a sane way
09:01:51 <Saizan> fragamus: you can't partially apply type synonyms (though there might be an extension for that now)
09:01:54 <edwardk> i might be able to do it with my reflection package though
09:01:56 <edwardk> hrmm
09:01:57 <mSSM> quicksilver: sorry, type: (***) >>= id   =   \r -> id ( (***) r) r   =   \r -> (***) r r
09:01:58 <quicksilver> mSSM: the (r->) monad comes in because that's the definition of >>= you just copied in?
09:02:19 <Saizan> fragamus: in your case you could define "type Gen = CRand HashDRBG GenError" though and it'd work
09:02:20 <mSSM> I am confused ....
09:02:39 <fragamus> Saizan: OK
09:02:45 <geri> i read hashkell supports event-driven programming and multhreading...why cant you just use multireading?
09:02:48 <fragamus> that is more desirable
09:03:12 <srhb> geri: Who says you can't
09:03:26 <geri> why should you use event-driven approach?
09:03:28 <mSSM> quicksilver: oh, ok, I see it.
09:03:38 <srhb> geri: Because your use-case prescribes it, I guess.
09:03:48 <srhb> geri: If not, don't.
09:03:57 <geri> srhb, example?
09:03:58 <mSSM> quicksilver: Ok, how can I tell that in `join (***)' acts on `(r->)' ?
09:04:13 <srhb> geri: Of what? An event-driven use-case? No, I have no idea. But you could if you had one.
09:04:17 <mSSM> And: does that mean that (***) is defined in terms of the (r->) monad?
09:04:25 <mSSM> Is there anything that is not defined in terms of the reader monad?
09:04:34 <geri> event-driven tends to be harder to programm to me
09:04:36 <mSSM> and odes (r->) have anything to do with a lambda?
09:04:46 <srhb> geri: It really depends on what you mean by event, I guess.
09:04:57 <quicksilver> mSSM: by type inference.
09:05:02 <mSSM> is `\r -> crazyFunctionHere r' a monadic computation??
09:05:02 <srhb> geri: I start to think FRP when someone mentions it, and then you have netwire etc.
09:05:08 <geri> srhb, usually this is done via callback functions?
09:05:16 <fragamus> @hoogle ReaderT
09:05:16 <lambdabot> Control.Monad.Reader ReaderT :: (r -> m a) -> ReaderT r a
09:05:16 <lambdabot> Control.Monad.Trans.Reader ReaderT :: (r -> m a) -> ReaderT r m a
09:05:16 <lambdabot> Control.Monad.Trans.Reader newtype ReaderT r m a
09:05:18 <quicksilver> mSSM: the monad acted on by join is determined by the type of its argument
09:05:20 <srhb> geri: That's one way.
09:05:30 <quicksilver> mSSM: join (Right (Right 1))
09:05:35 <geri> srhb, to me thats harder than creating threads...
09:05:51 <quicksilver> mSSM: must be join from the Either monad, because that parameter has type Either a (Either a Int)
09:05:52 <srhb> geri: I don't understand what you are saying. Yes, it is harder to take care of events than spawning threads, obviously.
09:05:59 <mSSM> quicksilver: so now I need to look up the definition of >>= for Either ?
09:06:06 <srhb> geri: If you want to just spawn threads, just spawn threads. What are you really asking?
09:06:13 <quicksilver> mSSM: join [[1]] must be join from the list monad
09:06:21 <quicksilver> mSSM: because [[1]] has type [[a]]
09:06:31 <quicksilver> mSSM: you can look it up if you like but it's not required to understand the point I'm making ;)
09:06:32 <mSSM> quicksilver: so join has to be defined for every instance?
09:06:46 <quicksilver> mSSM: (>>=) has to be defined for every instance.
09:06:53 <quicksilver> mSSM: join is always defined in terms of >>=
09:06:58 <quicksilver> @src join
09:06:58 <lambdabot> join x =  x >>= id
09:07:04 <mSSM> quicksilver: is join not universally defined as `x >>= id' ?
09:07:06 <quicksilver> mSSM: (as you pointed out yourself earlier)
09:07:08 <quicksilver> yes.
09:07:11 <quicksilver> exactly.
09:07:16 <quicksilver> but >>= is defined per instance.
09:07:48 <mSSM> quicksilver: ok, and in the case of `join (***)', I thought the monad it uses is `Arrow', but it turns out that is wrong?
09:07:56 <mSSM> quicksilver: you guys were quick to point out the reader monad
09:08:17 <quicksilver> mSSM: Arrow isn't a monad.
09:08:21 <quicksilver> Arrow is a typeclass.
09:09:00 <tromp> just like Monad isn't a monad:)
09:09:15 <srhb> geri: The reason I'm confused is that you seem to ask "Given that Haskell supports event-driven multithreading, is it harder to do multithreading in Haskell?" If you don't want to do eventful stuff, don't do eventful stuff. I'm betting you have another question hidden underneath there, hence the confusion.
09:09:25 <srhb> (Also, harder than what?)
09:10:00 <geri> srhb, in event-driven programming its hard to handle the control flow...
09:10:19 <srhb> geri: Okay, so?
09:13:25 <srhb> geri: Are you asking whether you are forced to do event-driven programming if you want multithreading in Haskell, or are you asking whether event-driven programming in Haskell is harder/easier than other languages?
09:13:45 <monochrom> I am not sure what "Haskell supports event-driven multithreading" means
09:13:54 <srhb> I have an idea. :P
09:14:17 <monochrom> to some extent, "event-driven multithreading" is an oxymoron
09:14:32 <srhb> How so?
09:15:02 <n-dolio> Because events are the opposite way of looking at concurrency from threads.
09:15:47 <monochrom> usually, you write an event loop and use no threads, or you use threads and don't write an event loop
09:16:54 <monochrom> of course, you must read my "to some extent" and "usually" several times
09:17:30 <srhb> Right.
09:18:41 <hpaste> ‚ÄúBen Gamari‚Äù pasted ‚ÄúPipes strangeness‚Äù at http://hpaste.org/81224
09:19:09 <bgamari> The above is a simple accumulator with pipes
09:19:28 <bgamari> One would think it would accumulate to (Sum 15)
09:19:53 <bgamari> but somehow it results in (Sum 0)
09:19:59 <bgamari> How is this possible?
09:20:37 <bgamari> And, moreover, is it really necessary for me to implement my own fold for WriterP?
09:39:58 <sm> woah, http://packdeps.haskellers.com/licenses is great
09:41:23 <owst> sm: I think you killed it ;-)
09:41:58 <srhb> I wonder how many click links that don't seem to be spam and are not hpaste or something, here :P
09:44:43 <srhb> BSD3 seems to be most prominent.
09:45:20 <Taneb> Yeah, the library I wrote is BSD3 all the way down
09:45:23 <sm> owst: it's a bit flaky
09:45:28 <Taneb> 43 libraries
09:45:54 <sm> packdeps itself also has a nice "deep" option I never noticed
09:46:17 <Taneb> Oh?
09:46:44 <sm> Taneb: eg http://packdeps.haskellers.com/feed?needle=hledger-web -> View outdated dependency for all ancestor packages too
09:46:51 <Taneb> Aha, that
09:50:39 <`nand`> is lmap f . rmap g = rmap g . lmap f ?
09:51:20 <Hafydd> Good nick, shutdown_-h_now
09:51:35 <Taneb> `nand`, profunctors? I think it has to be
09:52:40 <`nand`> lmap f . rmap g = dimap f g; rmap g . lmap f = dimap id g . dimap f id = dimap f . g
09:52:43 <`nand`> seems like it
09:52:45 <`nand`> err
09:52:48 <`nand`> dimap f g
09:55:45 <elliott> @tell cmccann you might want to vote to reopen http://stackoverflow.com/questions/14273235/can-gadts-be-used-to-prove-type-inequalities-in-ghc, it was erroneously closed despite your comment :(
09:55:45 <lambdabot> Consider it noted.
09:57:29 <edwardk> i nominated it for reopening too
09:57:49 <elliott> #haskell voting bloc
09:59:43 <bgamari> If anyone has pipes experience and some free time: http://stackoverflow.com/questions/14507700/writing-a-simple-accumulator-with-pipes-writerp
10:13:01 <fragamus> @hoogle lift
10:13:01 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
10:13:01 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
10:13:01 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:14:57 <hpaste> wuttf pasted ‚ÄúHow can I return a typeclass instead of a concrete type in getABForMe?‚Äù at http://hpaste.org/81229
10:15:16 <fragamus> ooohhhkaayyy‚Ä¶. I added a monad transformer so now I have to go through and lift all my actions?
10:16:30 <tac> they aren't gonna lift themselves
10:16:53 <fragamus> I'm wishing that they would
10:17:03 <`nand`> Is there an option to print types with kind annotations?
10:17:07 <`nand`> in GHC
10:17:12 <`nand`> or, rather, GHCi
10:17:20 <`ramses> fragamus: in many cases, you don't have to lift explicitely
10:17:29 <fragamus> how is that
10:17:45 <`ramses> as long as you don't have multiple State's or Writer's or such
10:17:46 <geekosaur> wuttf, even asking that question suggests that you don't understand Haskell's type system
10:18:05 <wuttf> geekosaur: That may be true.
10:18:07 <geekosaur> in particular:  your function has zero control over the type it returns.  the *caller* decides
10:18:20 <geekosaur> if you're trying to use typeclasses for OOP, stop now
10:18:36 <wuttf> geekosaur: What should I use instead?
10:18:37 <`ramses> fragamus: because for instance "MaybeT (State a) b" will be an instance of MonadState
10:18:40 <geekosaur> they are not OOP, they will not work for OOP, there is no secret trick that will turn them into OOP
10:18:56 <`ramses> fragamus: which gives you put, get, modify, ...
10:19:37 <`nand`> getABForMe can only ever return (B "hey")
10:19:39 <fragamus> the type checker is kicking my ass sending me all over my code to lift stuff
10:19:53 <geekosaur> and the error message is telling uyou that your type signature informs callers that they get to specify a and c, but your actual code fixes them to A and C instead
10:19:57 <TheRedMood> I just wrote a bang function :D
10:20:03 <fmap> fragamus: do you use mtl or transformers?
10:20:06 <TheRedMood> I just found out about foldr
10:20:06 <TheRedMood> :D
10:20:13 <fragamus> i use this:
10:20:14 <fragamus> type Gen = CRand HashDRBG GenError
10:20:14 <fragamus>  30 type ReaderGen r a = ReaderT r Gen a
10:20:18 <mm_freak> the correct thing to do is not to insist on OOP‚Ä¶  one of the best features of haskell is that it doesn't support OOP
10:20:26 <geekosaur> ^^
10:20:29 <fragamus> type Gen = CRand HashDRBG GenErrorype ReaderGen r a = ReaderT r Gen a
10:20:34 <fragamus> ugh sorry
10:20:46 <fmap> fragamus: that's not the answer :[
10:20:48 <fragamus> one more time just so you can see
10:20:49 <wuttf> `nand`, geekosaur Thank you I am going to meditate on those
10:20:54 <`nand`> (of course, Haskell supports OOP. Well, depending on how you define OOP. But that's another can of worms)
10:21:08 <mm_freak> it doesn't support java-style OOP
10:21:13 <`ramses> fragamus: oh, I was thinking of the std mtl transformers, others might not have those nice classes
10:21:25 <fmap> fragamus: mtl will not require explicit lifts most of the time
10:21:30 <wuttf> I never done Java. I want to decouple implementation from interfaces though.
10:21:38 <fmap> fragamus: OTOH transformers will
10:21:45 <fragamus> here's my transformer stack so far:
10:21:46 <fragamus> type Gen = CRand HashDRBG GenError
10:21:46 <fragamus> type ReaderGen r a = ReaderT r Gen a
10:22:06 <fmap> that doesn't matter, they both use same ReaderT
10:22:10 <`nand`> type classes aren't for decoupling implementation from interfaces. That's what every API does
10:22:34 <fragamus> well it makes me lift stuff
10:23:39 * `nand` just discovered -fhelpful-errors
10:25:36 <wuttf> `nand`: I mean, I want to use cars in my code, with methods like turn and stop, but I want to be able to freely swap between package Ferrari /Audi  (dumb idea I know)
10:25:43 <wuttf> dumb explanation *
10:25:58 <wuttf> Hehe, Freud...
10:26:51 <TheRedMood> johnw: I just wrote a bang function, but I am wondering about a type
10:26:58 <`nand`> that's easy, have Ferrari and Audi export the same named functions, then change ‚Äúimport Car.Ferrari‚Äù to ‚Äúimport Car.Audi‚Äù
10:27:00 <TheRedMood> bang :: (Enum b, Num b) => b -> b
10:27:04 <TheRedMood> bang x = foldr (*) 1 [x,x-1..1]
10:27:22 <TheRedMood> Why does it have to be (Enum b, Num b)
10:27:22 <TheRedMood> ?
10:27:32 <`nand`> Num because of ‚Äò1‚Äô and (*)
10:27:39 <`nand`> Enum because of the enumeration syntax
10:27:45 <TheRedMood> enumartion?
10:27:47 <TheRedMood> Oh
10:27:50 <`nand`> > [1, 2 ..10]
10:27:50 <TheRedMood> Like listable?
10:27:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:27:56 <`nand`> :t [1,2..10]
10:27:57 <lambdabot> (Enum t, Num t) => [t]
10:28:04 <`nand`> note also that foldr (*) 1 = product
10:28:14 <TheRedMood> product?
10:28:15 <TheRedMood> Oh
10:28:22 <TheRedMood> is that a function?
10:28:24 <kennyd> > product [2,3,4]
10:28:26 <lambdabot>   24
10:28:26 <`nand`> and product [x,x-1..1] = product [1..x] -- assuming multiplication commutes and your Enum instance is sane
10:29:05 <TheRedMood> ahh
10:29:07 <hiptobecubic> :t [1..10]
10:29:07 <TheRedMood> Thanks a lot!
10:29:08 <lambdabot> (Enum t, Num t) => [t]
10:29:17 <TheRedMood> I learned something new just from this too!
10:29:20 <hiptobecubic> stupid lag
10:29:22 <`nand`> (that's my favorite definition of factorial, incidentally: fac x = product [1..x])
10:30:20 <n-dolio> > let fac n = product [2..n] in map fac [0..]
10:30:22 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
10:30:25 <hiptobecubic> > scanl product $ tails [1..]
10:30:27 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [[a0]]Couldn't match...
10:31:00 <`nand`> > unfoldr ((*).succ) 1
10:31:02 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a0, b0)'
10:31:02 <lambdabot>              with ...
10:31:03 <`nand`> err
10:31:05 <`nand`> > iterate ((*).succ) 1
10:31:06 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
10:31:21 <`nand`> > iterate ((*) <*> succ) 1
10:31:22 <lambdabot>   [1,2,6,42,1806,3263442,10650056950806,113423713055421844361000442,128649386...
10:31:30 <`nand`> oh, oops
10:31:34 <hiptobecubic> > map product $ tails (1:[1..])
10:31:36 <`nand`> I do need an unfoldr it seems
10:31:42 <lambdabot>   mueval: Prelude.undefined
10:32:40 <hiptobecubic> i guess i wanted inits anyway
10:32:52 <`nand`> oh
10:32:57 <`nand`> > scanl (*) 1 [1..]
10:33:00 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
10:33:04 <`nand`> there we go
10:33:53 <hiptobecubic> > map product (inits [1..])
10:33:55 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
10:42:37 <mSSM> So, can I somehow use (***) to sum a `unzip6 [(Int,Int,Int,Int,Int,Int)]' ?
10:42:42 <hiptobecubic> I'm always a little slowed down when I have to think about the ((->) e) instance for Applicative and Monad
10:43:05 <quchen> hiptobecubic: map product . inits is far less efficient than scanl.
10:43:06 <hiptobecubic> mSSM, sum how?
10:43:14 <ion> mssm: Why do you have a (Int,Int,Int,Int,Int,Int)?
10:43:40 <quchen> Mapping product calculates 1, 1*2, 1*2*3, 1*2*3*4, ..., while scanl will calculate 1, 1*2=2, 2*3=6, ...
10:43:42 <hiptobecubic> quchen, yes. repeats a lot of work
10:43:50 <hiptobecubic> quchen, right
10:51:34 <Fifo> Hi folks
10:51:47 <Fifo> > chat
10:51:49 <lambdabot>   Not in scope: `chat'
10:51:49 <lambdabot>  Perhaps you meant one of these:
10:51:49 <lambdabot>    `cat' (imported fr...
10:51:53 <Fifo> >> 23*36
10:51:57 <xenon_> is there a way to just place my .hs files into some directory to be able to import them from everywhere? or do I have to learn cabal?
10:51:58 <Fifo> > 23*36
10:52:00 <lambdabot>   828
10:52:09 <Fifo> > reverse "Hi folks"
10:52:10 <lambdabot>   "sklof iH"
10:52:18 <Fifo> > test
10:52:20 <lambdabot>   Not in scope: `test'
10:52:20 <lambdabot>  Perhaps you meant one of these:
10:52:20 <lambdabot>    `nest' (imported f...
10:52:28 <Fifo> > nest "hello"
10:52:29 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:52:29 <lambdabot>              with actual type ...
10:52:38 <`nand`> Fifo: /query lambdabot
10:52:53 <geekosaur> xenon_, cabal's the easiest way; you can register stuff directly but you need to create a package description which is 95% or so of a cabal config anyway
10:53:20 <Fifo> `nand`: Ok
10:53:22 <`nand`> I used to be scared by cabal then I installed cabal-install and ran ‚Äòcabal init‚Äô and it turned out to be much easier than expected
10:53:38 <`nand`> you should get used to the proper directory structure though for starters
10:54:10 <nart> hi
10:54:42 <nart> i'm having a weird issue with http-conduit
10:54:47 <nart> if i try to run
10:54:48 <nart> main = simpleHttp "http://www.haskell.org/" >>= L.putStr
10:54:58 <nart> i get Main.hs: FailedConnectionException "www.haskell.org" 80
10:55:07 <nart> but i can wget it just fine
10:56:40 <`nand`> (maybe you're behind a HTTP proxy?)
10:57:04 <`nand`> can you `nc www.haskell.org 80` ?
10:57:53 <absence> "Module `Network.Socket.ByteString.Lazy' does not export `send'" <- but it does! why would i get this error?
10:58:14 <nart> `nand` yes i can
10:58:22 <xenon_> anyone knows a quick guide to get started with cabal? I just want to make a very simple library with one module and I am getting a bit lost in haskell.org user guide
10:58:23 <nart> and if i use Network.HTTP.simpleHTTP
10:58:30 <nart> it works
10:59:36 <`nand`> xenon_: just run `cabal init` and edit as needed; maybe look at a few other .cabal files for reference
10:59:57 <mSSM> ion: I have a function that calculates some results (Int,Int,Int,Int,Int,Int) from an input (Int,Int)...
11:00:19 <`nand`> absence: maybe you're doing a partial import?
11:00:22 <byorgey> absence: it exports send' ?
11:00:28 <byorgey> absence: with an apostrophe?
11:00:29 <`nand`> byorgey: `send'
11:00:39 <ion> mssm: Have you considered creating a data type that represents your data better?
11:00:45 <byorgey> oh, I see, sorry
11:00:51 <byorgey> was confused by the closing double quote
11:01:03 <mSSM> ion: I had a datatype `Results' with 6 different fields.
11:01:09 <byorgey> absence: what version of the 'network' package do you have?
11:01:11 <`nand`> GHC's syntax on that is a bit confusing, imo; I would prefer ‚Äòsend‚Äô for distinction
11:01:56 <mSSM> ion: But I didn't see how that helped me any ... calculating that sextuple (?) is one step before printing it and terminating
11:02:36 <`nand`> mSSM: if those ints have specific meanings, you could use a record which names them, for greatly enhanced clarity
11:02:43 <`nand`> of those ints do /not/ have specific meanings, then maybe a list or so would be better?
11:02:48 <`nand`> s/of/if/
11:02:53 <absence> byorgey: 2.3.0.13
11:03:03 <mSSM> `nand`: they do have a meaning, but I thought wrapping/unwrapping them is silly?
11:03:05 <ion> Using a type that doesn‚Äôt replicate six ‚ÄúInt‚Äùs at every use site will be nicer.
11:03:25 <absence> byorgey: http://hackage.haskell.org/packages/archive/network/2.3.0.13/doc/html/src/Network-Socket-ByteString-Lazy.html#send
11:03:30 <`nand`> ion: to be fair, a type alias would work for that
11:04:10 <absence> `nand`: the line that fails is import qualified Network.Socket.ByteString.Lazy as C (send,recv)
11:04:14 <ion> Btw, you can get a sum out of your own type rather easily:
11:04:16 <ion> Œª> data Foo a = Foo a a a a a a deriving (Show, Functor, Fol.Foldable, Tra.Traversable)
11:04:19 <ion> Œª> sumOf traverse (Foo 1 2 3 4 5 6)
11:04:21 <ion> 21
11:04:31 <geekosaur> also, you are still wrapping/unwrapping them, you're just using an anonymous wrapper
11:04:47 <geekosaur> s/still/already/
11:04:49 <nart> but wtf, Network.HTTP works and Network.HTTP.Conduit doesn't
11:05:43 <byorgey> absence: very odd.  You wouldn't happen to have another import of the same module somewhere else, would you? (Say, with a 'hiding' clause?)
11:06:12 <mSSM> ion: sorry for being unclear, but I don't want to sum the fields inside the data type, but given two instances of `Foo', I want to make a new Foo, where each field c_i = a_i + b_i
11:07:04 <mSSM> ion: So a=(a1,a2,a3,a4,a5,6) + b=(b1,b2,b3,b4,b5,b6) = c=(c1,c2,c3,c4,c5,c6)
11:07:55 <absence> byorgey: hmm, no
11:08:06 <`nand`> absence: and an otherwise empty file containing just that line (and a ‚Äòmain = return ()‚Äô to satisfy GHC) compiles fine?
11:09:17 <absence> `nand`: no, same error
11:09:34 <ion> mssm: If they were lists, zipWith (+) as bs
11:09:54 <ion> mssm: It would be helpful to know what the tuples actually represent.
11:10:40 <edwardk> otters: if you want to try to pull lens HEAD it has rudimentary support for working with catches.
11:10:55 <edwardk> if that works for you i can push it out
11:11:45 <mSSM> ion: The tuples represent variables calculated from observables ("measurements" in my simulation). So a tuple contains 6 different variables which I calculated.
11:11:50 <nathanfh> Can anyone explain a case where one would need to use atomicWriteIORef rather than writeIORef?
11:12:06 <ion> mssm: Why 6?
11:12:37 <mSSM> ion: So for example, given an input (e,m), the variables would be (e,e^2,m,abs(m),(abs(m))^2,(abs(m))^4).
11:12:44 <m3ga> nathanfh: when you want read, modify write behavior
11:12:53 <m3ga> to be atomic
11:13:01 <mSSM> ion: I suppose it could be more/less.
11:13:18 <ion> mssm: Ok. Have you considered using lists instead of tuples?
11:13:44 <nathanfh> m3ga: Ah, so for in cases where you can't use atomicModifyIORef, because your function isn't pure?
11:13:53 <ion> They won‚Äôt have a static length check, but you‚Äôd have zipWith (+).
11:14:14 <m3ga> nathanfh: consider an IORef containing counter that needs to be incremented from more than one thread. if you read then write you have a race condition. with atomicModify there can be no race.
11:14:19 <`nand`> is data Diag a = Diag a a -- an Applicative?
11:14:22 <mSSM> ion: Ok, I will check that.
11:14:33 <ion> mssm: Another random idea is to create the appropriate Monoid instance for data Foo a = Foo a a a a a a.
11:14:35 <xenon_> is abal-install different than cabal install ?
11:14:41 <xenon_> +c
11:14:46 <`nand`> pure = join Diag; Diag f g <*> Diag x y = Diag (f x) (g y)
11:15:06 <dcoutts> xenon_: confusingly, cabal-install is the name of the package that contains the 'cabal' program.
11:15:08 <mSSM> ion: Yeah, I was wondering about that: can I somehow make `Foo' an instance of something so that `sum [Foo] = Foo' ?
11:15:08 <monochrom> cabal-install is a name
11:15:31 <nathanfh> m3ga: Yeah. I totally get atomicModify, but not atomicWrite. If the value you're writing isn't dependent on what was already in there, how can you have a race condition?
11:15:35 <dcoutts> xenon_: Cabal is the name of the package that contains the library
11:15:37 <ion> mssm: You could make it an instance of Num, too, yeah.
11:15:43 <`nand`> cabal (not to be confused with Cabal, the library) is a program provided by package cabal-install
11:15:54 <quchen> When parsing a String to Text using Parsec, do I have to pack everything myself? E.g. parsing a Char to Text would be something like "fmap (pack . return) $ char 'x'"
11:16:03 <dcoutts> long term, I plan to rename them: cabal-lib, cabal
11:16:22 <`nand`> you can use Cabal just fine without cabal-install; but then you don't get the benefits of `cabal init` and have to write your own .cabal file from scratch
11:16:26 <ion> instance Num a => Num (Foo a) where Foo a b c d e f + Foo a' b' c' d' e' f' = Foo (a+a') (b+b') (c+c') (d+d') (e+e') (f+f'); fromInteger a = Foo a a a a a a; ‚Ä¶
11:16:28 <`nand`> + some other metadata
11:16:34 <monochrom> atomicWrite prevents re-ordering of "readIORef v1; writeIORef v2"
11:17:14 <mSSM> ion: Cool, this is something I was telling myself to learn. :D
11:17:23 <monochrom> the doc has an example why some depraved people want it
11:17:59 <mSSM> ion: Where can I read up on what definitions I have to make in order to make a type an instance of a class?
11:18:48 <`nand`> mSSM: haddock entries usually give a minimal complete definition
11:19:09 <ion> mssm: ‚Äú:i Num‚Äù in GHCi and the documentation for Num (hoogle Num). Note that some type classes provide defaults for some methods; the former won‚Äôt show that.
11:19:31 <`nand`> mSSM: but failing that, you can just write ‚Äúinstance Num (Foo a) where‚Äù in GHCi and GHC should spit out a bunch of warnings about undefined class methods
11:20:01 <`nand`> the method I gave excludes defaulted definitions
11:20:12 <ion> mssm: For instance, in Num, you‚Äôll only have to define one of negate or (-).
11:20:47 <`nand`> oh, though it has a short-coming: default methods defined in terms of eachother don't get printed at all
11:22:13 <ion> mssm: So, to shorten the answer: the haddocks. :-)
11:23:36 * hackagebot BlogLiterately 0.5.4 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.5.4 (BrentYorgey)
11:24:04 <tsou> can I somehow do something like that?  type Vector = Num a => (a, a)
11:26:52 <mSSM> ion: thank you :)
11:27:36 <tsou> ah, turns out that was not my problem
11:28:46 <tsou> so, my question becomes this:  in ghci, if i do "let u = 3", then ask for the type of u, i get Integer.  If i ask for the type of 3, on the other hand, I get Num a => a.  Why are the two different?
11:29:01 <geekosaur> @where DMR
11:29:01 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:29:11 <ion> tsou: that ‚Üë
11:29:37 <mSSM> tsou: 3 can be Int, Float...
11:29:41 <nart> hi
11:29:57 <elliott> mSSM: So can u, modulo the DMR.
11:30:12 <nart> why http-conduits gives me FaliedConnection when i run it with runhaskell but it works just fine if i compile it ?
11:30:14 <ion> tsou: After :set -XNoMonomorphismRestriction and let u = 3, you‚Äôll see that the type of u is Num a => a.
11:30:32 <tsou> geekosaur, ion: thanks
11:30:58 <tsou> i guess after i'm done reading this page, I'll understand why this is not the default behaviour..
11:31:03 <tsou> thanks for the pointers
11:31:10 <typoclass> tsou: i guess most people have ":set -XNoMonomorphismRestriction" in their ~/.ghci file so that it happens whenever you start ghci
11:31:35 <geekosaur> the brief version is that if you name something that is not a proper function (i.e. has no parameters), you expect to share it.  but a polymorphic value can
11:31:38 <geekosaur> 't be shared
11:31:59 <Maxdamantus> > let e = sum [ 1/product [1..n] | n <- [1..1000] ] in e
11:31:59 <geekosaur> so ghc fixes the type to something that can be shared effectively
11:32:00 <lambdabot>   1.7182818284590455
11:32:12 <tsou> geekosaur: and then hits you with type errors :P
11:32:27 <Maxdamantus> > let e = sum [ 1/product [1..n] | n <- [0..1000] ] in (e, e) :: (Double, Fractional)
11:32:27 <tsou> geekosaur: i guess i'll understand things better after reading that page you sent.  thanks again :)
11:32:29 <lambdabot>   Expecting one more argument to `GHC.Real.Fractional'
11:32:32 <arbn> Is there a version of <$> that associates like $?
11:32:40 <ion> tsou: Basically, ‚ÄúNum a => a‚Äù compiles to something that is more like a function ‚ÄúNum a -> a‚Äù where the latter hypothetical Num a is a dictionary of Num methods. The monomorphism restriction makes sure that things without type signatures that look like non-functions behave like non-functions.
11:33:00 <Maxdamantus> > let e = sum [ 1/product [1..n] | n <- [0..1000] ] in (e, e) :: (Double, Float)
11:33:02 <lambdabot>   (2.7182818284590455,2.718282)
11:33:14 <typoclass> nart: hello. that's indeed weird. have you tried running wireshark (or equivalent) while you're doing runhaskell?
11:33:18 <tsou> ion: so what i'm wondering is when would that flag that you mention NOT be wanted..?
11:33:26 <Maxdamantus> No monomorphism restriction in lambdabot .
11:34:47 <geekosaur> tsou:  when you set it to a complex calculation; if it's made fully polymorphic, it'll have to be recalculated with the appropriate type every time it is used instead of being computed once
11:35:10 <Maxdamantus> (like the one in my >)
11:35:23 <Maxdamantus> It's (possibly unexpectedly) calculating e twice.
11:35:40 <tsou> ah, i see
11:36:03 <geekosaur> whereas the normal expectation when you use a simple name without parameters is you want the same value to be computed once and shared in multiple computations later
11:36:17 <tsou> still it would make more sense to me if the default behaviour was the opposite and to require the flag when you want to apply the monomorphism restriction
11:36:34 <tsou> but that is with the 2 minutes of discussion we've just had.. nothing more than that ;)
11:36:46 <typoclass> tsou: the reason for haskell's default behavior is sometimes historical weirdness, instead of maximal helpfulness
11:36:48 <geekosaur> the monomorphism restriction is the subject of a lot of argument; that should also be discussed on the page I pointed you to
11:36:55 <ion> tsou: Usually you‚Äôll just use NoMonomorphismException in ghci and type signatures in .hs files.
11:37:12 <geekosaur> as was mentioned earlier many people configure ghci to turn it off by default
11:38:14 <typoclass> geekosaur: about the ongoing discussion, i thought most people agreed that it probably shouldn't have been done this way. (i.e. they agree with tsou)
11:38:36 * hackagebot highlight-versions 0.1.2.3 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.2.3 (BrentYorgey)
11:38:58 <geekosaur> typoclass, from what I've seen, many users think it should be off and many people closer to either the standard or the compilers implementing the standard think it should be on by default
11:39:25 <geekosaur> although that's not a hard and fast rule or anything, just my possibly inaccurate observation
11:39:27 <typoclass> geekosaur: i see. thanks. i had only caught the "many users" opinion
11:39:50 <Rc43> Hi, guys.
11:39:52 <tsou> things make more sense now, thanks everyone.. and yeah, i just edited my ~/.ghci ;)
11:40:05 <Rc43> Anybody worked with WinAPI?
11:40:41 <Rc43> I am looking at System.Win32 on hackage, but can't get the way how to get windows attached to a given process.
11:40:49 <Rc43> (Never worked with WinAPI.)
11:42:26 <monochrom> I thought a window is attached to the process who created it
11:48:36 * hackagebot BNFC 2.6.0.0 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.6.0.0 (GregoireDetrez)
11:50:28 <Rc43> monochrom, I am not about it; I have process and I want to get (all) windows attached to it.
11:58:42 <xenon_> what is the purpose of setup.hs in haq example in here? it seems to work without it as well. http://en.wikibooks.org/wiki/Haskell/Packaging
11:59:35 <geekosaur> what do you mean works eithout it?
12:00:08 <xenon_> program builds and installs itself even after removing setup.hs
12:00:55 <glguy> You can use a Setup.hs to build a package without having cabal-install around
12:01:08 <geekosaur> if you're using cabal-install to do the build, it stashed a compiled version under dist/build
12:01:24 <xenon_> yes I am using cabal-install
12:01:46 <xenon_> si Setup.hs is there if one doesnt have it - ok
12:02:07 <typoclass> xenon_: iirc, it has to do with cabal's "build-type" field. if you set it to Simple, it will ignore Setup.hs. if you set it to Custom, it will run Setup.hs. you can also directly compile and run Setup.hs (although i don't know if anyone really still does that these days)
12:03:08 <xenon_> typoclass: I see
12:05:57 <Taneb> If I've got a parsec parser "foo :: Stream s m Char => ParsecT s u m Foo", how can I make it not case sensitive?
12:06:19 <xenon_> so if I got it right, every haskell program or library (except maybe throw away programs) should be a cabal package?
12:07:06 <Taneb> Every library you want to share
12:07:14 <Taneb> Programs I'm not so sure about
12:08:56 <typoclass> xenon_: i don't know of any commandments, but i can say that after a while of developing, i usually end up getting tired of compiling and moving the binary to ~/bin/ or wherever. then i do "cabal init", which really only takes a minute
12:09:14 <dcoutts> xenon_, Taneb: a reason for programs is to make them a bit more future proof, you then know what their deps are, and you have a much better chance of it still working in a few years time
12:09:51 <xenon_> if I have program package Prog that depends on my library package Lib, and I make changes to Lib. will building Prog rebuild Lib as well?
12:10:19 <typoclass> xenon_: right, dcoutts makes a good point. the yourproject.cabal file provides you with a written record of what packages your stuff needs. that's always useful
12:11:40 <xenon_> or how about this, if my Prog depends on a library that is not installes, will cabal automatially download it?
12:11:46 * xenon_ installed
12:12:00 <dcoutts> xenon_: yes it will
12:12:05 <xenon_> that is neat
12:27:44 <fetter_oml> good evening. ive a rather general question about haskell. it does feature algebraic data types (at least everyone tells me those data .... constructs are some)
12:28:13 <fetter_oml> and the question, well
12:28:42 <fetter_oml> out of the perspective of a mathematician who has just heard a lecture about Algebra
12:29:05 <ion> fetter_oml: http://youtu.be/YScIPA8RbVE?hd=1
12:29:08 <fetter_oml> what qualifies an algebraic data type to be called algebraic?
12:29:19 <fetter_oml> wow, that was fast :D
12:31:56 <typoclass> fetter_oml: i just view them as "kind of an enum" and don't worry about any theory that might attach to it. there's a tendency in haskell to give mathy names to everything. not sure why
12:32:16 <fetter_oml> the lecturer had exactly the same question in mind as I have right now
12:32:32 <elliott> they're not really anything like enums, since they are products as well as sums
12:33:10 <ion> typoclass: I bet you‚Äôll find that talk mind-opening.
12:33:13 <fetter_oml> this is bond to be a gread talk, thanks ion :)
12:33:30 <ion> fetter_oml: Yes, i found it great.
12:33:46 <typoclass> ion: hm ok, i guess i'll have a look
12:34:29 <Cale> edwardk: are you around?
12:34:36 <edwardk> yep
12:34:58 <Cale> Which versions of comonad-transformers and distributive should be installed with the latest lens?
12:35:13 <edwardk> the latest of each should work
12:36:13 <Cale> Okay, I'll see what happens when I just install them individually then
12:36:22 <Cale> cabal install lens got stuck:
12:36:23 <hpaste> Cale pasted ‚Äúerror from cabal install lens‚Äù at http://hpaste.org/81232
12:36:33 <feliperosa> Hi guys, Does anyone have papers about Applicative instances of the 'standard' Monads? (I'm particulary insterested in State ones)
12:36:33 <mSSM> elliott: I can be an Int, Float, module the DMR?
12:37:26 <feliperosa> That is, If those are Applicatives
12:37:32 <Cale> feliperosa: The Applicative instance for every monad should have  pure = return  and  (<*>) = ap
12:37:38 <dcoutts> Cale: note that you're using an older cabal with the old dependency resolver
12:37:43 <Cale> dcoutts: okay
12:37:55 <edwardk> if you nuke your old .ghc folder and reinstall it'll go in clean, or if you upgrade to a new cabal, but i stopped releasing the 50 package version bumps to deal with every time i bumped a dependency in my hierarchy. it caused me to lose 8 hours of productivity any time i shipped a new version of anything.a
12:37:56 <ion> cale: Or at least ‚â°
12:38:35 <saeidw> How do I go about mapping an arrow-y thing over a list of things?
12:38:37 * hackagebot BlogLiterately-diagrams 0.1.1.1 - Include images in blog posts with inline diagrams code  http://hackage.haskell.org/package/BlogLiterately-diagrams-0.1.1.1 (BrentYorgey)
12:38:38 <Cale> Yeah, no worries
12:38:50 <feliperosa> Cale: Oh yeah, forgot about that. Thank you
12:38:52 <Henryk> :p
12:38:56 <Taneb> saeidw, I don't think you can in general
12:39:24 <Taneb> If you've got a (a -> m b) you want traverse or mapM
12:39:25 <fetter_oml> damnit, 3 crashes of pidgin in less than a minute (an IM-client in haskell as a holyday-project anyone? :D )
12:39:47 <Cale> saeidw: Some libraries (HXT if I recall correctly), have an ArrowList class with some operations for that
12:40:07 <Cale> But of course, that requires special instances to be written based on the structure of the Arrow in question.
12:40:29 <mSSM> fetter_oml: you use pidgin as an IRC client?
12:40:49 <fetter_oml> im quite ashamed of it already, no need to push further ;)
12:40:56 <saeidw> So, If I have xs :: [x], and r :: Arrow a => a x b, there's no way to somehow get an a [x] [b] out of it?
12:41:10 <ion> Nothing to be ashamed of. If it didn‚Äôt keep crashing, nothing wrong with using it.
12:41:12 <fetter_oml> its usefull for icq n stuff, and i like to use one client for all this IM stuff
12:41:17 <xenon_> in a cabL file can you depend on a specific version of some library?
12:41:26 <mSSM> fetter_oml: Using weechat; but if you like GUIs, check out Konversation/Quassel ?
12:41:47 <Cale> fetter_oml: I use pidgin for everything apart from IRC, but XChat is nicer.
12:42:00 <hpaste> galapago pasted ‚Äúnada‚Äù at http://hpaste.org/81233
12:42:02 <typoclass> ion: do you recall roughly at what time the main part of the talk is?
12:42:17 <ion> typoclass: From about 0:00:00 to about 1:04:35.
12:42:48 <typoclass> ion: er yeah ...
12:43:20 <ion> In all seriousness, you probably won‚Äôt get it by watching just a five-minute clip of it.
12:44:48 <typoclass> ion: yeah ... i'm trying to determine if there's an interesting "it" that i could get
12:45:37 <mSSM> How do I define `fromInteger' for `data Foo a = Foo a a' in `instance Num a => Num (Foo a) where fromInteger a = Foo a a' ?
12:46:15 <edwardk> saeidw: we figured out how to traverse with an ArrowChoice while working on lens, but there isn't anything packaged for it
12:46:39 <ion> typoclass: The laws that apply to algebraic data types have analogies in algebra with integers, sums, multiplication and even derivatives. You get to a step away from zippers by computing a derivative of a type. The talk demonstrates how.
12:47:13 <mSSM> Or `... where fromInteger b = Foo fromInteger(b) fromInteger(b)' ?
12:47:23 <edwardk> e.g. walk :: (Arrow p, Traversable f) => p a b -> p (f a) (f b)
12:47:36 <edwardk> er ArrowChoice p
12:48:12 <saeidw> edwardk, good to know that it's a valid thing to do!
12:48:14 <ion> mssm: Mind the precedences. That would be parsed as (Foo fromInteger) b fromInteger b.
12:48:19 <mSSM> Oh, I got it: `... where fromInteger b = Foo (fromInteger b) (fromInteger b)' is the correc thing :D
12:48:31 <ion> mssm: ‚ÄúfromInteger a = Foo (fromInteger a) (fromInteger a)‚Äù or ‚ÄúfromInteger a = Foo a' a' where a' = fromInteger a‚Äù
12:48:35 <edwardk> saeidw: it requires a painful amount of theory implement though
12:48:37 <typoclass> ion: hm ok ... what kind of code could you write, which before listening to the talk you'd have written in a more awkward way?
12:49:33 <ion> typoclass: It‚Äôs not really about how you write code, it‚Äôs more about how you understand code (or more accurately, types).
12:49:34 <mSSM> ion: Ok, but I can't restrict that `a' beforehand, right? as in `instance Num a => Num (Foo a) where fromInteger a = Foo a' a' where a' = fromInteger a;'
12:50:01 <saeidw> In that case it would just be simpler for me to write an a (f x) (f b) directly
12:50:10 <ion> mssm: I didn‚Äôt get what you mean by restricting it.
12:51:04 <xenon_> ion is knowlesge about algebraic types in math required for that video
12:51:11 <mSSM> ion: probably I don't get it: if you write ‚Äúinstance Num a => Num (foo a) where ...‚Äù, aren't you saying that all ‚Äúa‚Äù have to be of type ‚ÄúNum‚Äù
12:52:21 <mSSM> ion: Nope, it doens't mean that. I checked it. :)
12:52:22 <ion> xenon: You only need to know about 0, 1, + and * to get the majority of it. Knowing about derivatives will be useful in the latter part of it.
12:52:25 <mSSM> ion: thanks
12:53:07 <ion> mssm: The ‚Äúa‚Äù in ‚Äúinstance Num a => Num (Foo a)‚Äù isn‚Äôt even in the same namespace. It is a type; in ‚ÄúfromInteger a = ‚Ä¶‚Äù it refers to a value.
12:53:27 <ion> mssm: But anyway, even if you used ‚Äúa‚Äù as a type in one of the definitions, it would be a different one.
12:54:43 <mSSM> ion: Ok, thanks; I tend to mix these things up.
12:58:38 * hackagebot diagrams-contrib 0.6.0.2 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-0.6.0.2 (BrentYorgey)
13:02:14 <mSSM> ion: Ok, this gets complicated: how do I define the signum of a `data Foo a = Foo a a a' ? Each field can be positive or negative.
13:03:38 * hackagebot enummapset 0.5.2.0 - IntMap and IntSet with Enum keys/elements.  http://hackage.haskell.org/package/enummapset-0.5.2.0 (MichalTerepeta)
13:04:16 <ion> mssm: fooOp1 :: (a -> a) -> Foo a a a -> Foo a a a; fooOp1 f (Foo a b c) = Foo (f a) (f b) (f c) {- or just fooOp1 = fmap if you derived Functor -}; fooOp2 :: (a -> a -> a) -> Foo a a a -> Foo a a a -> Foo a a a; fooOp2 f (Foo a b c) (Foo a' b' c') = Foo (f a a') (f b b') (f c c')
13:04:25 <ion> mssm: signum = fooOp1 signum
13:05:32 <ion> mssm: You can verify that the ‚Äúsignum a * abs a == a‚Äù law holds.
13:06:11 <mSSM> ion: Yeah, you are right. I missed that signum is to give a Foo.
13:08:38 <fetter_oml> ion: trying me luck here ... do you have a more formal approach to the topic on the back of your hand?
13:09:04 <ion> fetter_oml: Alas, nope.
13:12:24 <mSSM> ion: thanks, that's very smart to define things the way you show.
13:13:53 <applicative>   
13:15:46 <yunxing> hi, when i try to use eval in System.Eval.Haskell by    eval "1 + 6 :: Int" [] , it generates this warning: on the commandline:     Warning: -fglasgow-exts is deprecated: Use individual extensions instead Nothing
13:15:52 <mSSM> ion: I suppose, alternatively I could have made `Foo a' an instance of the sum monoid?
13:17:02 <ion> mssm: Sum is not a type class. Sum is an instance of Monoid; Foo could be an instance of Monoid as well.
13:17:37 <ion> mssm: You could have made a Monoid instance for Foo where, say, mempty = 0; mappend = (+)
13:17:44 <ion> (given your Num instance)
13:20:00 * tac thinks it would be nice if there were a syntactic way to distinguish between types and typeclasses in Haskell
13:20:20 * tac always has trouble distinguishing between the two when learning a new API
13:20:31 <EvanR> theres :info
13:20:35 <EvanR> :info Sum
13:20:46 <ion> tac: But there is. The syntax doesn‚Äôt allow you to use one in the place of the other.
13:21:24 <tac> ion: not without context, though
13:23:30 <tac> ion: I mean at a lexical level. In haskell, you can't (for example) tell type-level terms from constructors from typeclasses
13:24:15 <c_wraith> you can at least distinguish type classes from the other two at the syntactic level
13:24:43 <c_wraith> Oh, and if you meant data constructors, all three
13:24:56 <tac> yeah
13:25:02 <tac> it would be problematic if you couldn't distinguish them :)
13:25:12 * c_wraith was thinking of the ambiguity between type constructors and type functions, even at the level of syntax
13:25:15 <tac> Unless you're writing an esoteric language with a focus on high ambiguity
13:25:38 <c_wraith> You need a name lookup to distinguish between a type constructor and a type function
13:26:51 <teneen> how to convert a ByteString to a Vector of Word8?
13:27:08 <teneen> Is there some way to read stdin into a vector of Word8?
13:27:18 <c_wraith> which vector?
13:27:57 <c_wraith> There's a kind of hacky way to convert ByteString to a Storable vector without a copy
13:28:28 <c_wraith> It's safe, but it involves calling functions that aren't in other contexts
13:28:51 <c_wraith> Unless you want a mutable storable vector, in which case it isn't safe
13:29:17 <c_wraith> So..  What kind of vector?
13:30:26 <teneen> c_wraith, Data.Vector.Unboxed
13:32:37 <teneen> Why is there no way to do IO with vectors instead of Strings and ByteStrings?
13:33:26 <c_wraith> because that'd really only make sense for Word8
13:34:05 <teneen> I want to use it with Word8
13:34:12 <c_wraith> and vector is a generic library
13:34:24 <quchen> When using -XOverloadedStrings, is there some way to make "show :: (Show a, IsString b) a -> b"? The obvious workaround would be "fromString . show", but is there a nicer solution?
13:34:24 <c_wraith> it provides no functions specific to vectors of Word8
13:34:27 <c_wraith> or any other type
13:34:37 <Taneb> quchen, that solution is pretty nice already
13:34:55 <Taneb> Although I have to ask "why"
13:35:34 <c_wraith> teneen: fromList . unpack will work.
13:35:53 <quchen> Taneb: I'm working with DList Char right now, and much of the code looks cleaner with overloaded strings. However, I frequently have to include a show-able thing in my DList Char.
13:36:20 <quchen> Well, show' will do.
13:36:41 <Taneb> import Prelude hiding (show); show :: (Show a, IsString b) => a -> b; show = fromString . Prelude.show
13:36:51 <Taneb> (do not recommend)
13:37:24 <teneen> c_wraith: Intermediate lists are an overhead though
13:37:56 <c_wraith> teneen: has profiling showed that it matters?
13:38:08 <quchen> Taneb: Alright, thanks, I'll stick with my show' because it won't mislead me in 3 months :-)
13:38:14 <Taneb> Yeah :)
13:38:23 <teneen> c_wraith: I'm solving online problems which have time limits
13:38:52 <c_wraith> teneen: and has profiling shown that conversion from bytestring to vector is the slow part of your solution?
13:39:23 <quchen> Another question: Why do I need -XFlexibleInstances to define "Instance IsString (DList Char)"? Looks like a pretty legit line to me. Is it because I'm inserting a type already?
13:39:40 <xenocons> http://www.reddit.com/r/programming/comments/176nkr/intimidation_factor_vs_target_audience_rust/c82sqe4 heh
13:39:45 <quchen> Oh. Pardon ^^
13:40:00 <quchen> (Premajure asking)
13:40:33 <n-dolio> Without flexible instances, you're only allowed to declare instances of the form 'instance Foo (C t u v ...)'.
13:40:55 <n-dolio> Where C is a constructor, and t, u, v... are distinct variables.
13:43:38 <quchen> n-dolio: Thanks. That's kind of what the error message said. I should have read it more accurately. I saw "distinct", but not "variables".
13:54:00 <parcs> dcoutts: is there a particular mailing list that would be appropriate to send a patch for cabal to?
13:54:11 <dcoutts> yes, the cabal-devel list
13:54:25 <dcoutts> or if you prefer, open a github pull request
13:55:27 <parcs> ok, thanks
13:55:54 <francois> Lazy eval question. this never "returns": let fibsUnder100 = filter ((flip <) 100) $ map fib [1..].
13:56:09 <francois> I believe it should terminate, since the list is finite in size -- or is it?
13:56:14 <c_wraith> the result is
13:56:19 <mauke> francois: it's not
13:56:20 <c_wraith> but the construction has no way of knowing that.
13:56:31 <francois> Just realized it, yes
13:56:34 <Ralith> francois: filter doesn't know that its input is ordered.
13:56:41 <Ralith> you want takeWhile
13:56:45 <francois> I'm actually doing Project Euler #2
13:56:51 <francois> Oh yes, much better
13:56:53 <francois> Thanks!
13:56:57 <Ralith> np
13:57:01 <mauke> it's 1 : 1 : 2 : 3 : 5 : 8 : 13 : 21 : 34 : 55 : 89 : _|_
13:57:14 <Ralith> heh, indeed
13:57:32 <mauke> :t (flip <)
13:57:32 <lambdabot> Ord ((a -> b -> c) -> b -> a -> c) => ((a -> b -> c) -> b -> a -> c) -> Bool
13:57:39 <mauke> that doesn't even compile
13:57:51 <int-e> mauke: hehe
13:58:10 <int-e> (had to think for a moment why it had a type at all)
14:00:11 * geekosaur notes that it does compile, it's just not very sane
14:00:16 <S11001001> just add class OrdType a b | a -> b, b -> a, define all the instances :)
14:00:51 <geekosaur> mmm, comparing functions
14:04:19 <celery> is there a GHC extension which generalizes defaulting to other classes besides Num?
14:07:51 <S11001001> instance Default a, Default b, Default (a -> b -> c) => Ord ((a -> b -> c) -> b -> a -> c) where
14:10:25 <Rc43> How can I specify generation of 32bit non-unicode executable with ghc?
14:10:47 <Rc43> I need it for portability issue while using System.Win32
14:10:48 <Clint> non-unicode, you say
14:11:34 <fmap> Rc43: ?
14:13:42 <dcoutts> Rc43: there is no separate unicode/non-unicode ghc build. You'll have to explain what you're really trying to do, and what the problem is.
14:14:24 <pmade> Does anyone know of any advanced Haskell classes/courses in the US?
14:14:25 <Rc43> http://hackage.haskell.org/packages/archive/Win32/2.2.2.0/doc/html/src/System-Win32-Process.html
14:14:38 <Rc43> Look at definition of `th32SnapEnumProcesses`.
14:14:59 <Rc43> It uses hardcoded size of structure: `allocaBytes ((296))`
14:15:45 <Rc43> This size depends on 32bit/64bit executable and other parameters.
14:16:28 <Rc43> As one man on #winapi tested for me 296 corresponds to non-unicode 32 bit executable; when 568 works for me (unicode 64 bit)
14:17:03 <Rc43> (If I replace 295 with 568 everything works OK, but by default I get winapi error.)
14:17:47 <Rc43> So I search the way to workaround my problem with generating other executable.
14:19:31 <edwardk> :t iso
14:19:31 <lambdabot> Not in scope: `iso'
14:19:43 <edwardk> thats not a good thing
14:19:55 <edwardk> :t prism
14:19:56 <lambdabot> Not in scope: `prism'
14:20:17 <c_wraith> L.hs has changed again!
14:20:56 <elliott> edwardk: Cale got sick of having to update :P
14:21:11 <c_wraith> actually, I suppose it's be Pristine.hs
14:21:26 <Cale> wat
14:21:30 <Cale> I did update
14:21:36 <edwardk> :t lens
14:21:36 <lambdabot> Not in scope: `lens'
14:21:41 <edwardk> :t (^.)
14:21:41 <lambdabot>     Not in scope: `^.'
14:21:41 <lambdabot>     Perhaps you meant one of these:
14:21:41 <lambdabot>       `.' (imported from Prelude), `^' (imported from Prelude),
14:21:51 <Cale> hmm
14:22:06 <Cale> I installed lens-3.8.1 and didn't touch Pristine.hs
14:22:10 <Cale> @undefine
14:22:16 <Cale> :t iso
14:22:17 <lambdabot> Not in scope: `iso'
14:22:20 <typoclass> ah, lens no longer obeys edwardk. next up: self-awareness, then revolt
14:23:12 <Cale> I have import Control.Lens; import qualified Control.Lens as Lens; import Data.Data.Lens; import Data.Bits.Lens
14:24:16 <shachaf> Control.Lens exports iso
14:24:33 <n-dolio> You know, the first two should be equivalent to import Control.Lens as Lens, I believe.
14:24:52 <Cale> Yeah, it should be :)
14:24:55 <shachaf> Yep.
14:25:16 <Cale> @undefine
14:25:20 <Cale> :t iso
14:25:21 <lambdabot> Not in scope: `iso'
14:25:23 <Cale> odd
14:25:38 <shachaf> @ty lens
14:25:38 <lambdabot> Not in scope: `lens'
14:25:41 <Taneb> Do you need to restart lambdabot
14:25:44 <shachaf> @ty Lens.iso
14:25:44 <lambdabot> Couldn't find qualified module.
14:26:01 <shachaf> Maybe you put the imports in the wrong part of the file or something?
14:26:30 <Cale> I'll unregister the other copies of lens
14:26:37 <Cale> Maybe it's selecting the wrong one
14:26:42 <Cale> :t iso
14:26:42 <lambdabot> Not in scope: `iso'
14:27:06 <Cale> nope, that's not it
14:27:25 <Cale> > iso
14:27:27 <lambdabot>   Could not find module `Numeric.AD.Types'
14:27:27 <lambdabot>  Use -v to see a list of the files...
14:27:34 <Cale> well, that's interesting
14:27:52 <Cale> @undefine
14:27:53 <Cale> > iso
14:27:54 <lambdabot>   Could not find module `Numeric.AD'
14:27:54 <lambdabot>  Perhaps you meant
14:27:54 <lambdabot>    Numeric (from base...
14:28:01 <Cale> wat happen
14:28:09 <Cale> @undefine
14:28:10 <Cale> > iso
14:28:13 <lambdabot>   No instance for (GHC.Show.Show
14:28:13 <lambdabot>                     ((s0 -> a0) -> (b0 -> t0...
14:28:18 <Cale> :t iso
14:28:20 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
14:28:37 <Cale> good?
14:29:19 <Taneb> :t _Just
14:29:23 <Cale> Now I just have to sort out what happened to ad
14:29:34 <lambdabot> thread killed
14:29:39 <shachaf> @ty _Just
14:29:48 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Maybe a) (f (Maybe b))
14:29:48 <Cale> (I'm just rebuilding that)
14:30:45 <feliperosa> Hi guys
14:31:34 <celery> is there a GHC extension which generalizes defaulting to other classes besides Num?
14:31:50 <clahey> In order for iso to return an isomorphism, s = t and a = b, right?
14:32:39 <shachaf> clahey: More or less.
14:32:44 <n-dolio> > (1, 'c') ^. upon snd
14:32:46 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
14:32:46 <lambdabot>    arising from a use o...
14:32:47 <clahey> Actually, that would make it return p a (f a) -> p s ( f s)   Is that right?
14:32:48 <n-dolio> > (1, 'c') ^.. upon snd
14:32:51 <lambdabot>   "c"
14:33:59 <n-dolio> > (1, 'c') & upon snd .~ 4
14:34:00 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
14:34:00 <lambdabot>    arising from the literal `4...
14:34:08 <n-dolio> Awww.
14:34:41 <clahey> I would have thought that would work.  Hmm.
14:34:50 <celery> guys come on
14:34:52 <n-dolio> Can't change the type with that.
14:34:58 <clahey> > (1, 'c') & _2 .~ 4
14:35:00 <lambdabot>   (1,4)
14:35:01 <n-dolio> Apparently.
14:35:20 <shachaf> Given that it uses Data.Data and all.
14:35:28 <clahey> Of course.  Because upon snd is a getter, not a full lens.
14:35:36 <shachaf> No, it's a lens.
14:35:46 <shachaf> > (1,'c') & upon snd .~ 'd'
14:35:48 <lambdabot>   (1,'d')
14:35:52 <clahey> Oh.
14:35:54 <edwardk> :t iso
14:35:56 <lambdabot> (Functor f, Profunctor p) => (s -> a) -> (b -> t) -> p a (f b) -> p s (f t)
14:35:59 <n-dolio> It's a lens'
14:36:00 * edwardk cheers
14:36:10 <clahey> shachaf: Hmm.
14:36:22 <clahey> edwardk: When is the f going to go away?
14:36:36 <edwardk> clahey: we're still on the fence about that
14:37:15 <clahey> edwardk: I thought that was the whole point of switching to profunctor.  Without that, you can just have it be k (a -> f b) no?
14:37:26 <edwardk> mostly when we come up with a compelling usecase for the extra functionality we get from the pure profunctor lenses that trumps the benefits of easy implementation of lenses and traversals in haskell 98 code
14:37:31 <edwardk> no
14:37:41 <edwardk> p a (f b) -> q s (f t) has other benefits
14:37:44 <clahey> Okay.
14:37:46 <elliott> can upon be made to change the type somehow
14:37:48 <edwardk> including that iso and prism compose with (.)
14:37:51 <elliott> seems like it might be sort of possible
14:38:08 <n-dolio> elliott: Can Data do that?
14:38:18 <elliott> not sure
14:38:31 <elliott> I guess not
14:38:33 <n-dolio> I wouldn't be surprised if it can't.
14:38:44 <elliott> perhaps with unsafeCoerce?!?!
14:38:45 <edwardk> i am somewhat doubtful since upon is only interesting when there is more than one 'a' inside the structure
14:39:19 <ParahSailin> @pl flip ($)
14:39:20 <lambdabot> flip id
14:39:32 <edwardk> clahey: a number of the items in the changelog for 3.8 couldn't have been done with the k (a -> f b) (s -> f t) style
14:39:54 <edwardk> and it actually leads to a pretty significant speedup
14:42:10 <simpson> Hey, I'm uploading a library to Hackage with a lot of dependencies, and it's not building on Hackage but it builds for me, probably because of missing bounds on versions of dependencies.
14:42:34 <simpson> Is there a tool that can attempt to build a local package, ignoring already-installed stuff?
14:42:37 <clahey> I thought ($) was flip id.
14:42:54 <shachaf> ($) is id.
14:42:56 <tac> @src ($)
14:42:56 <lambdabot> f $ x = f x
14:42:56 <fmap> simpson: cabal-dev?
14:42:58 <clahey> Oh, okay.
14:43:00 <edwardk> (&) i flip id
14:43:04 <clahey> Oh, I was thinking of &.
14:43:12 <tac> ($) f x = f x
14:43:25 <simpson> fmap: Hm. Maybe, lemme see.
14:43:28 <tac> @type ($) print "Hello world"
14:43:29 <lambdabot> IO ()
14:43:49 <tomoj> is there something about the denotation of List that picks out its Applicative instance over the one ZipList has?
14:44:03 <elliott> tomoj: the [] monad
14:44:06 <elliott> there's no ZipList monad
14:44:12 <elliott> but there is a [] monad, and it agrees with the [] Applicative
14:44:18 <tomoj> ah
14:44:23 <elliott> as in (<*>) = ap
14:44:25 <elliott> pure = return
14:44:29 <tomoj> right, I see
14:46:04 <n-dolio> That has nothing to do with the denotation, though.
14:46:19 <n-dolio> As far as your original question goes.
14:46:20 <edwardk> tomoj: Applicatives should be compatible with the corresponding Monad
14:47:30 <celery> simpson: cabal-dev
14:47:37 <Philippa> tomoj: more fundamentally, the connotation does
14:47:56 <Philippa> (which is why the denotation was fixed with those otherwise unnecessary rules)
14:48:11 <simpson> celery, fmap : Yeah, cabal-dev is definitely what I wanted, thanks.
14:49:18 <tomoj> so Reactive has an Applicative instance for Event which "is unlikely to be very useful", because, I think, conal wants it to agree with the [] Applicative
14:49:56 <tomoj> but why not make it agree with ZipList? maybe that just won't work
14:50:40 <n-dolio> Isn't an Event something at a specific point in time?
14:50:43 <tomoj> oh, and then the Event monad would be inconsistent
14:50:59 <conal> tomoj: right. i was going for Monad/Applicative consistency
14:51:00 <n-dolio> So if you zip them, what do you get?
14:51:20 <n-dolio> Only things where two events happen simultaneously?
14:51:42 <conal> n-dolio: an "event" has multiple occurrences across time
14:51:51 <Philippa> tomoj: the alternative instance need only be a newtype away anyway
14:59:24 <scooty-puff> so... is a Tree with 4 phantom kind parameters perhaps too many?
15:00:06 <scooty-puff> Tree m s a b - (m :: Measure = Some | NonEmpty), (s :: Signedness = Signed | Unsigned), (a, b :: Shape = Closed | Open)
15:08:09 <teneen> I'm trying to solve this problem https://www.interviewstreet.com/challenges/dashboard/#problem/4edb8abd7cacd
15:08:19 <teneen> There is a time limit exception
15:08:36 <teneen> The same algorithm passes with Java
15:09:06 <hpaste> brence pasted ‚Äúinterviewstreet problem‚Äù at http://hpaste.org/81239
15:09:42 <teneen> I trying optimizing constant factors in my algorithm and using different data structures but no success
15:13:22 <hpaste> teneen pasted ‚Äúinterviewstreet problem‚Äù at http://hpaste.org/81240
15:13:51 <clahey> Is there an LR parser combinator library?
15:15:45 <int-e> teneen: this has probably little to do with your problem, but  forM [1..read n] (\_ -> B.getLine)  seems a bad idea: it'll read everything into memory before it can be processed.
15:16:33 <int-e> teneen: (I'd use  replicateM_ (read n) (B.getline >>= print . similar)  instead)
15:17:26 <teneen> int-e: I tried processing it one by one and storing the results in a Vector. The forM solution is faster
15:17:47 <teneen> int-e: this will not work because I have to read all the lines first and then print the results
15:19:11 <int-e> strange requirement. but ok, fine.
15:19:45 <n-dolio> I don't see where it says you h ave to do that.
15:21:52 <teneen> OK I tried your suggestion, and it was accepted. But it also exceeded the time limit
15:22:07 <int-e> teneen: do you know anything about the inputs? will bad cases like "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa..." happen?
15:23:41 <teneen> int-e: Nothing is mentioned about these cases in the problem description.
15:30:26 <clahey> fail "error" <$> x should be the same as fail "error", right?
15:30:41 <ion> Do you mean fail "error" =<< x?
15:30:46 <shachaf> Not in general?
15:30:49 <teneen> int-e: any other suggestions?
15:30:50 <clahey> ion: No.
15:31:02 <shachaf> @ty \x -> fail "error" <$> x
15:31:04 <ion> @type fail "foo" <$> ?x
15:31:04 <lambdabot> Functor f => f a -> f b
15:31:06 <lambdabot> (?x::f a, Functor f) => f b
15:31:38 <clahey> :t fail "error"
15:31:40 <lambdabot> Monad m => m a
15:31:54 <ion> @type fail "foo" `asTypeIn` \f -> f <$> ?x
15:31:56 <lambdabot> (?x::f a, Functor f) => a -> b
15:32:17 <int-e> teneen: I have the nagging feeling that this can be done in linear time; but for constant factors, I'd look at replacing B.index by BytesString.Unsafe.unsafeIndex to avoid range checks. I'm not too hopeful though. I tend to resort to C/C++ for this kind of array-ish code.
15:32:48 <clahey> :t <$>
15:32:50 <lambdabot> parse error on input `<$>'
15:32:55 <clahey> :t (<$>)
15:32:57 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:33:15 <clahey> Oh oh.
15:33:16 <int-e> of course we could tell dons that this is a new shootout problem. :P
15:33:24 <clahey> :t (<*>)
15:33:25 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:33:35 <clahey> :t fail "foo" <*> ?x
15:33:37 <lambdabot> (?x::f a, Monad f, Applicative f) => f b
15:33:45 <clahey> I meant <*>.
15:37:07 <shachaf> Cale: Could you add Numeric.Lens to the import list too?
15:37:26 <edwardk> Control.Exception.Lens is a good prism showcase too
15:38:09 <shachaf> Doesn't help too much in lambdabot.
15:38:51 <tac> > fail "Darn" :: IO a
15:38:53 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO a0))
15:38:53 <lambdabot>    arising from a use of ...
15:39:11 <tac> > print "hello"
15:39:13 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
15:39:13 <lambdabot>    arising from a use of ...
15:39:25 <tac> oh, I think I'm thinking of ST actions
15:39:54 <augur> tac: oi
15:39:56 <augur> get in #ct
15:39:58 <tac> > do r <- newSTRef 'a'; readSTRef r
15:39:59 <lambdabot>   <<ST action>>
15:41:27 <shachaf> > do r <- newSTRef (return ()); writeSTRef r (join (readSTRef r)); join (readSTRef r)
15:41:29 <lambdabot>   <<ST action>>
15:41:30 <shachaf> > runST (do r <- newSTRef (return ()); writeSTRef r (join (readSTRef r)); join (readSTRef r))
15:41:35 <lambdabot>   mueval: ExitFailure 1
15:41:35 <lambdabot>  mueval: Prelude.undefined
15:46:49 <tac> shachaf: Good job. You broke him :(
15:47:41 * tac wanders off to put Set inside of Set.
15:53:42 * hackagebot gemstone 0.2.1 - A simple library of helpers for SDL+GL games.  http://hackage.haskell.org/package/gemstone-0.2.1 (CorbinSimpson)
15:55:35 <fetter_oml> mhm
15:55:58 <fetter_oml> implementing traceroute in haskell: a nice challenge with lots of learning or downright insane?
15:58:44 * hackagebot lzma-conduit 0.5.2.3 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.5.2.3 (NathanHowell)
15:59:33 <tomoj> so then in the Applicative for ZipList, (pure a) has infinitely many occurrences of a at t = minBound, and <*> does what you'd expect
15:59:42 <tomoj> er, ZipEvent
16:01:31 <clahey> :t ZipEvent
16:01:32 <lambdabot> Not in scope: data constructor `ZipEvent'
16:02:22 <tomoj> a hypothetical newtype for Reactive's Event which gets a zippy Applicative
16:02:24 <Cale> @undefine
16:02:36 <Cale> > 1
16:02:38 <lambdabot>   1
16:02:56 <Cale> edwardk: okay, you should have that stuff, and AD should be back
16:02:59 <shachaf> > review (base 16) 12345
16:03:02 <lambdabot>   "3039"
16:03:05 <edwardk> Cale: thanks =)
16:03:05 <shachaf> Yay!
16:03:13 <edwardk> > diff sin x
16:03:15 <lambdabot>   cos x * 1
16:03:17 <shachaf> > preview (base 16) "10000"
16:03:19 <lambdabot>   Just 65536
16:03:52 <edwardk> > catching _NonTermination (throwing _NonTermination ()) $ \_ -> return "caught"
16:03:53 <lambdabot>   Couldn't match expected type `m0 r0' with actual type `()'
16:04:14 <edwardk> > catching _NonTermination (throwingIO _NonTermination ()) $ \_ -> return "caught"
16:04:16 <lambdabot>   Not in scope: `throwingIO'
16:04:16 <lambdabot>  Perhaps you meant one of these:
16:04:17 <lambdabot>    `throwing' (...
16:04:20 <edwardk> oh yeah IO =)
16:04:34 <edwardk> but at least i can use it for :t
16:12:17 <teneen> is there a way to directly read stdin into an unboxed array or vector?
16:12:32 <teneen> or read a file
16:36:37 <hpaste> NihilistDandy pasted ‚ÄúA bit stumped‚Äù at http://hpaste.org/81242
16:36:39 <NihilistDandy> Is there anyway to define multiplicative inverse over the Integers without using Ratio?
16:37:41 <NihilistDandy> I can't think of how one would do it without breaking laws, and it may be altogether impossible. I just would rather not rewrite my instance declarations (I haven't been able to figure how to make it work with Ratio, anyway).
16:38:46 <byorgey> NihilistDandy: you mean you want some (x :: Integer) such that  x * 2 == 1
16:38:50 <byorgey> ?
16:39:03 <NihilistDandy> Right, so clearly not even a thing
16:39:08 <NihilistDandy> Actually, I'm stupid
16:39:18 <NihilistDandy> Z isn't a field, anyway
16:39:26 <byorgey> exactly.
16:39:35 <byorgey> However, I highly doubt you are stupid.
16:39:54 <Hafydd> Yes, for example, it could be much worse:
16:40:01 <NihilistDandy> I was thinking more about the code than about the obvious, at very least :D
16:40:01 <Hafydd> You could be saying that in ##java, for example.
16:40:11 <byorgey> hehe =)
16:40:22 <byorgey> you should be able to make it all work with Rational, however
16:43:12 <NihilistDandy> What would be the right way to write the Monoid instance, for instance? I haven't been able to get Rational to work, I think because it says it's synonymous with the Integer instance.
16:44:20 <byorgey> instance Monoid Rational where (<+>) = (+); zzero = 0
16:44:38 <byorgey> does that not work?
16:44:58 <NihilistDandy> Gives me a suggestion to use TypeSynonymInstances
16:45:12 <c_wraith> oh.  Rational = Ratio Integer
16:45:14 <NihilistDandy> I reworked zzero to be 0 % 1
16:46:05 <byorgey> oh, I see.  You can turn on TypeSynonymInstances, or you can write  Ratio Integer   instead of  Rational
16:46:29 <c_wraith> Or you could write the instance for Ratio a
16:46:30 <byorgey> NihilistDandy: also, it is perfectly valid to just write  zzero = 0, though  zzero = 0 % 1  works too
16:46:58 <NihilistDandy> I had tried Ratio Integer before, but that led down the whole FlexibleInstances -> UndecidableInstances rabbithole
16:47:06 <byorgey> wat
16:47:25 <byorgey> I suppose you might need FlexibleInstances for that, but FlexibleInstances is just fine
16:47:32 <byorgey> you certainly don't need UndecidableInstances.
16:47:55 <NihilistDandy> Oh, you know, you're right. That may have been one of the later instances that called for that.
16:48:06 <byorgey> TypeSynonymInstances is really pretty tame too, you know
16:48:31 <NihilistDandy> I actually don't. I still haven't read through all the LANGUAGE docs. I should really get through more of that. :D
16:48:45 <cmccann> whether to use UndecidableInstances is a tricky question. I can never decide.
16:49:28 <NihilistDandy> haha
16:49:40 <NihilistDandy> Okay, that's working much better now. Thanks for the pointers. :)
16:51:41 <byorgey> NihilistDandy: TypeSynonym and Flexible are very tame.  Undecidable requires careful consideration.  Overlapping should be avoided.  Incoherent is Right Out.
16:52:04 <c_wraith> Flexible*, that is.  Both Instances and Contexts
16:52:14 <byorgey> ah, indeed, I knew I was forgetting one
16:52:42 <Eelis> why should overlapping be avoided?
16:52:46 <NihilistDandy> That's very good to know.
16:53:10 <Eelis> it seems to me overlapping just expresses that sometimes there are multiple ways to skin a cat, which is fine
16:55:02 <c_wraith> Overlapping adds spooky action at a distance for instance resolution
16:55:07 <c_wraith> That's the main problem with it.
16:55:24 <Eelis> spooky how? you mean that the compiler chooses amongst the ways you've specified for how to skin the cat?
16:55:31 <Eelis> *from
16:55:59 <NihilistDandy> Though now with Rational Integer I need to raise the fixity of <+>. Ah, well
16:56:02 <c_wraith> In that code you don't touch can suddenly change meaning by adding a new instance, without changing any existing ones.
16:56:26 <Eelis> that seems perfectly logical to me
16:56:38 <c_wraith> without overlapping instances, it can't happen.
16:56:42 <Eelis> indeed
16:58:02 <c_wraith> Many people think it's a good thing that adding code can't change the behavior of code you don't touch.
16:58:20 <Eelis> oh well
17:00:46 <Eelis> i see instance resolution as lookup into a database of known ways to solve problems. so to me, if you start adding stuff to the database, then sure, the stuff you add may be used. not a big deal
17:08:25 <xenon_> Build-Depends:     base >= 3 && < 5
17:08:38 <xenon_> does this mean it won't compile on future versions of base ?
17:09:07 <geekosaur> it means it doesn't know if it will or not
17:09:24 <glguy> and rather than not be sure, they deicded that it shouldn't
17:09:25 <geekosaur> which, given the kinds of changes that tend to happen in major version bumps of base, is quite sane
17:10:01 <xenon_> geekosaur really? :(. so I can't expect to compile my programs with newest ghc few years from now?
17:11:15 <RichyB> xenon_: http://www.haskell.org/haskellwiki/Package_versioning_policy
17:11:30 <geekosaur> recent breakages include:  changing the exceptions system incompatibly, removing the Show and Eq prerequisites from Num, and most recently removing the IO-error-only exception handling from the Prelude.  each broke a lot of packages
17:11:57 <NihilistDandy> Do you think it would be more correct to leave the definition of degree as fromInteger, or would it be better to generalize it to a -> a and just use id for Integer and Ratio Integer?
17:12:46 <RichyB> The short story is: the major-version of a given library should be bumped when you release changes that are very likely to break all kinds of users. Yes, if base's major version gets bumped, loads of Haskell code gets broken. That's supposed to not happen too often.
17:13:04 <xenon_> geekosaur that is worrying how they are changing things willy nilly from a standard library like that.
17:14:23 <glguy> xenon_: You figure without knowing any of the reasoning behind much less what the changes were a few moments ago that you can now safely cast those changes as "willy nilly"?
17:14:24 <geekosaur> considering how many Java programs only work on particular versions of the JRE, it's not exactly unheard-of behavior
17:17:24 <xenon_> glguy "let's make all Nums show and seq"  "let's no longer do that"  ? That seems willy nilly to me.   at the very least it's hardly a very relevant change, not nearly relevant enough to break old code.. but then I am speaking from a perspective of a user of languages that can compile decade or older programs without problems
17:19:19 <RichyB> geekosaur: ooh, Ord is gone from Num? Yay!
17:19:24 <NihilistDandy> Such as?
17:20:20 <geekosaur> Um?  Num doesn't imply Ord; we have complex numbers already, and Ord is not defined over them
17:20:23 <byorgey> xenon_: There is a tradeoff between making improvements to do things "the right way", and backwards/forwards compatibility.  Haskell has always leaned quite far towards the first.
17:20:29 <byorgey> other languages take a different approach.
17:20:54 <applicative> xenon_: the changes are mostly pretty simple, one corrects them with basically mechanical thought in a few minutes, if it's a library on github or hackage
17:21:08 <geekosaur> Eq and Show used to be implied by Num but aren't any more
17:21:13 <applicative> what byorgey said.
17:21:28 <Ralith> How do I convert an Integer representing a Unicode scalar value to a Char?
17:21:45 <shachaf> @ty chr
17:21:47 <lambdabot> Int -> Char
17:21:47 <byorgey> Ralith: chr ?
17:21:52 <Ralith> kk
17:21:52 <typoclass> > chr 123
17:21:54 <lambdabot>   '{'
17:21:55 <Ralith> wasn't sure what exactly that did
17:22:02 <applicative> is that what a unicode scalar value is?
17:22:03 <Ralith> the docs just say 'toEnum' which isn't helpful
17:22:15 <geekosaur> chr is toEnum specialized to Char
17:22:29 <applicative> > map ord $ "hello Ralith"
17:22:30 <lambdabot>   [104,101,108,108,111,32,82,97,108,105,116,104]
17:22:38 <applicative> map chr  [104,101,108,108,111,32,82,97,108,105,116,104]
17:23:03 <applicative> > map  chr  [104,101,108,108,111,32,82,97,108,105,116,104]
17:23:04 <lambdabot>   "hello Ralith"
17:44:17 <Guest61271> I need some help with a performance bottleneck in my code.
17:46:31 <hpaste> Riley__ pasted ‚ÄúMy bottleneck‚Äù at http://hpaste.org/81243
17:46:58 <Riley___> Code is slow with large input. Any idea how I can speed it up?
17:47:22 <shachaf> @google modular exponentiation
17:47:23 <lambdabot> http://en.wikipedia.org/wiki/Modular_exponentiation
17:47:23 <lambdabot> Title: Modular exponentiation - Wikipedia, the free encyclopedia
17:47:32 <parcs> Riley___: use Int!
17:47:57 <shachaf> If it fits in an Int, maybe...
17:48:01 <blackdog> Riley___: as a meta-answer: checked out the profiling chapter in Real World Haskell?
17:48:02 <Riley___> It's for a prime testing algorithm that has to go up into the thousands of digits.
17:48:21 <shachaf> The page I linked to is probably the first step.
17:48:28 <parcs> Riley___: the bottleneck is in gmp. you probably want to change your algorithm
17:49:05 <shachaf> GMP is just doing what you're telling it.
17:49:36 <Riley___> gmp doesn't use modular exponentiation by default? That sounds like what I want.
17:49:53 <glguy> gmp has a modular exponentiation call
17:49:59 <glguy> but GHC doesn't ever use that
17:50:04 <shachaf> Riley___: How would it do that?
17:50:10 <shachaf> You're exponentiating first and then taking the mod.
17:51:34 <Riley___> shachaf: I usually assume public libraries use the most efficient algorithms by default.
17:51:50 <shachaf> Riley___: I think you misunderstood what I said.
17:52:00 <shachaf> You're calling two functions: (^) and mod.
17:52:18 <shachaf> (^) is behaving as efficiently as possible. mod is behaving as efficiently as possible.
17:52:37 <shachaf> That's not the same as calling some third function, modExp.
17:52:51 <shachaf> The only way GMP could know to do this would be with some Haskell-side support, like a rewrite rule.
17:52:58 <shachaf> (And this rewrite rule doesn't sound like a good idea to me.)
17:53:43 <Riley___> shachaf: I think I understand now. Thank you for the clarification.
17:54:04 <shachaf> I don't know whether GHC exposes GMP's modular exponentiation.
17:55:03 <SirSkidmore> I'm not completely sure what I'm doing wrong: https://gist.github.com/214eeefd03f3c78b33a3 I'm sure it's a simple solution, but for the meantime, I have no clue
17:55:12 <ion> Modular exponentiation https://gist.github.com/4351099
17:55:50 <shachaf> Riley___: You're not implementing cryptography things, by the way, are you?
17:56:36 <Riley___> shachaf: No, Project Euler
17:56:43 <geekosaur> SirSkidmore, you use toInteger there; if you declare the function as Integral b => ... -> b then you are saying the caller gets to decide which Integral instance, not that you are forcing one
17:56:45 * shachaf sighs.
17:56:48 <shachaf> I suppose that's better.
17:57:48 <Riley___> shachaf: Not a fan of Euler?
17:57:55 <geekosaur> also, Num is not good enough to have (/) be available; you need Fractional
17:58:03 <shachaf> Riley___: Euler is great!
17:58:22 <shachaf> "project euler", on the other hand...
17:58:41 <Guest50465> why i can't see my name in the list?
17:58:56 <geekosaur> [24 20:56] * chad is now known as Guest50465
17:59:04 <ion> cale: Ooh, we have Numeric.Lens now? Thanks.
17:59:19 <shachaf> Cale: Thanks!
17:59:20 <geekosaur> you were using someone else's registered nick, and didnt identify properly to NickServ, so it booted you off it
17:59:39 <Riley___> shachaf: What is your preferred source of challenge for learning a new language? I'm always looking for something fun.
18:00:04 <Guest50465> ok, thanks, so i have to quit and re-enter with another nickname?
18:00:17 <geekosaur> likely, yes
18:00:28 <shachaf> "project euler" won't help you learn a new language.
18:00:35 <shachaf> Anyway I shouldn't be talking about this.
18:00:36 <shachaf> Never mind.
18:00:51 <applicative> > 100" ^? base 16
18:00:52 <lambdabot>   <hint>:1:16:
18:00:52 <lambdabot>      lexical error in string/character literal at end of input
18:01:15 <applicative> > "100" ^? base 16
18:01:16 <Riley___> shachaf: I did ask. Specifically because I've used it to learn Python, Java, and C# so far. The C# even landed me a job.
18:01:18 <lambdabot>   Just 256
18:03:02 <SirSkidmore> geekosaur: I took out toInteger and changed it to Fractional, but I still get the error: Cold not deduce (a ~ b)
18:03:07 <dibblego> is it possible to send an arbitrary function over a wire and if not, where is a formal description?
18:04:36 <geekosaur> SirSkidmore, right, because if that's all you did then you have an unspecified b in your type.
18:04:43 <xenon_> > let arbitraryFunction = (+) in arbitraryFunction 10 20
18:04:44 <lambdabot>   30
18:04:50 <xenon_> looks like it's possible!
18:05:13 <geekosaur> either you want it to be a, or you wanted to remove the Integral b constraint and make it produce Integer instead of b
18:05:21 <shachaf> good wire
18:05:42 <Riley___> thanks shachaf
18:05:47 <Riley___> shachaf++
18:06:37 <blackdog> anyone familiar with HINT and the ghc api? need to interrogate a binding to see if it's deprecated at runtime...
18:08:08 <applicative> dibblego: isn't something remotely like that involved in http://hackage.haskell.org/packages/archive/distributed-static/0.2.1.1/doc/html/Control-Distributed-Static.html
18:19:59 <xenon_> is there a function like this one: (\x -> [x])  ?
18:20:18 <ion> pure
18:20:24 <abbe> replicate ?
18:20:30 <ion> (:[])
18:20:48 <abbe> s/replicate/repeat/
18:20:56 <xenon_> thanks!
18:21:31 <xenon_> abbe I meant 'c' -> "c", not "cccc..."
18:21:55 <abbe> xenon_: :D then use what ion mentioned :)
18:22:12 <abbe> seems like chemistry channel :p
18:22:30 <fayden> xenon_: replicate 1
18:22:38 <fayden> but i guess pure is better
18:23:27 <abbe> > :t pure
18:23:28 <lambdabot>   <hint>:1:1: parse error on input `:'
18:23:37 <abbe> :t pure
18:23:38 <lambdabot> Applicative f => a -> f a
18:23:58 <abbe> oh!
18:24:14 <abbe> [] is an instance of Applicative
18:25:44 <xenon_> > pure 'c'
18:25:46 <lambdabot>   No instance for (GHC.Show.Show (f0 GHC.Types.Char))
18:25:46 <lambdabot>    arising from a use o...
18:26:00 <fayden> xenon_: it needs some context
18:26:01 <xenon_> I am getting 'c' in repl, "c" after I do :: String. how come
18:26:20 <xenon_> the first result is what is confusing me
18:26:59 <parcs> xenon_: because pure 'c' can also mean IO Char
18:28:02 <xenon_> ah, so IO Char, which ghci unpacks and prints
18:28:29 <geekosaur> it's a peculiarity of ghci, it looks to see if it was handed an IO action and evaluates it automaticaly.  which si enough for the Applicative to resolve IO
18:28:45 <geekosaur> *resolve to IO
18:28:49 <fayden> ion: you suggested pure, but is return a good choice or is there any reason to prefer pure?
18:28:55 <fayden> (ion or anyone, really)
18:29:10 <ion> pure is shorter :-P
18:29:16 <fayden> ha
18:29:21 <xenon_> but Control.Applicative is longer :)
18:29:29 <ion> Monad m => a -> m a shouldn‚Äôt exist anyway.
18:29:33 <parcs> fayden: i'd probably use replicate 1
18:29:44 <ion> I mean, in the Monad class.
18:29:56 <parcs> fayden: since then it's immediately obvious that you want a singleton list
18:30:06 <fayden> i guess it depends of the context
18:34:37 <intothev01d_m> whats the best way to convert a double or fractional number to an integer/integral type?
18:34:58 <simpson> intothev01d_m: Well, what kind of rounding do you want?
18:34:59 <parcs> intothev01d_m: truncate, round, floor, ceiling
18:35:16 <intothev01d_m> I just want to cut off the decimals to get an int
18:35:29 <parcs> then you want truncate
18:35:37 <intothev01d_m> ah ok
18:35:58 <intothev01d_m> is there a list somewhere of these types of functions? I've found the haskell library. is it part of that?
18:36:08 <jmcarthur> xenon_: more things can be Applicatives than can be Monads
18:36:19 <jmcarthur> xenon_: so pure can be used in more contexts
18:36:29 <applicative> > truncate 34.33
18:36:30 <lambdabot>   34
18:36:39 <jmcarthur> xenon_: so if there is ever a chance that your code will be polymorphic, it's usually nicer to use pure than return
18:36:48 <fayden> intothev01d_m: I think you can use the bot for this kind of things
18:36:50 <applicative> intothev01d_m: truncate is in the Prelude.
18:37:04 <fayden> @hoogle (Fractional a, Integral b) => a -> b
18:37:05 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
18:37:05 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
18:37:05 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
18:37:05 <ion> intothevdm: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:RealFrac
18:37:09 <Riley__> intothevO1d_m: Hoogle is your friend! Just give it the type you have and the type you want.
18:37:20 <intothev01d_m> awesome thanks
18:37:43 <applicative> intothev01d_m: ah ion has found a link.  if you have ghc you have a copy of that html somewhere
18:38:02 <intothev01d_m> nice yea i was trying to figure out where I could find that stuff
18:39:11 <ion> Someone should make a website where you can search for functions based on input and output values. Say, ‚Äú1.25 :: Double‚Äù ‚Äú1 :: Integer‚Äù
18:40:10 <hiptobecubic> ion, "const 1  :: a -> Integer"
18:40:13 <hiptobecubic> there you go
18:40:39 <ion> I suppose that should be among the results. :-)
18:41:09 <ion> ‚Äú1.25 :: Double‚Äù ‚Äú1 :: Integer‚Äù AND ‚Äú2.42 :: Double‚Äù ‚Äú2 :: Integer‚Äù
18:41:38 <hiptobecubic> so you want a webpage that gives you back a huge case statement?
18:41:47 <ion> no
18:42:09 <applicative> ion you saw the sublime https://github.com/luqui/Djest ?
18:42:24 <ion> It should find at least truncate and floor based on the latter query.
18:42:41 <ion> applicative: Nope, i‚Äôll take a look.
18:42:42 <applicative>  Djesture is a purely functional, statically typed language with syntax and semantics similar to Haskell. DJest has built-in automated testing support, but with an extra perk: you don't need to write the code you are testing.
18:43:07 <intothev01d_m> I'm getting a few errors. I guess i keep having trouble understanding the types I need to have I guess (just starting out) anyone care to take a look at this small function I have https://gist.github.com/4631297
18:43:24 <applicative> :succ :: Int -> Int; succ 0 = 1; succ 1 = 2; succ 10 = 11 This is enough to have Djesture deduce that succ x = x + 1.
18:43:28 <ion> applicative: neat
18:44:04 <ion> intothevdm: Try commenting the type signature out and seeing which one GHC comes up with. The problem is that Num doesn‚Äôt include (/) or truncate.
18:44:22 <geekosaur> intothev01d_m, so you're the same one as earlier.  I told you then, you need Fractional for (/)
18:44:26 <ion> @type \d x y z -> truncate (d / (x + y) * z)
18:44:27 <lambdabot> (Integral b, RealFrac a) => a -> a -> a -> a -> b
18:44:47 <geekosaur> or RealFrac, I get those confused *sigh*
18:44:51 <geekosaur> :t (/)
18:44:52 <lambdabot> Fractional a => a -> a -> a
18:45:08 <ion> geekosaur: ‚Äútruncate‚Äù
18:45:17 <geekosaur> yeh
18:45:20 <geekosaur> :t truncate
18:45:21 <intothev01d_m> geekosaur:  my friend I guess was in here. I was talking to him about it
18:45:22 <lambdabot> (Integral b, RealFrac a) => a -> b
18:45:43 <geekosaur> so truncate ,modifies the constraint from Fractional to RealFrac
18:46:51 <xenon_> how close can we get to F#'s units of measure via libraries?
18:48:05 <otters> edwardk: ok
18:48:14 <geekosaur> @ckage dimensional
18:48:14 <lambdabot> http://hackage.haskell.org/package/dimensional
18:50:10 <xenon_> thanks. no examples unfortunately though, and I don't grasp haskell enough to just go by documentation yet
18:50:57 <intothev01d_m> awesome. it works now with those types thanks!
18:53:07 <geekosaur> xenon_, there are examples in the code at the very end (sadly, using the haddock interface to display them fails pretty badly)
18:53:18 <xenon_> ah I see
18:53:25 <xenon_> will check it out
18:54:06 <geekosaur> so you might "cabal unpack dimensional" and then read Numeric/Units/Dimensional.hs in a text editor
18:54:43 <xenon_> I found some examples in here too, looks nice. https://code.google.com/p/dimensional/wiki/GMExample
19:00:47 <xenon_> I am impressed how well this abstraction works. is import Numeric.Units.Dimensional.Prelude replacing all the numerical functions from prelude or?
19:03:11 <geekosaur> looks like it, plus it's providing a Num instance so that numeric literals try to do something sane
19:07:11 <sw2wolf> :t hash
19:07:12 <lambdabot>     Not in scope: `hash'
19:07:12 <lambdabot>     Perhaps you meant `has' (imported from Control.Lens)
19:09:21 <applicat1ve> @type Data.Hashable.hash
19:09:23 <lambdabot> Data.Hashable.Hashable a => a -> Int
19:24:50 <sw2wolf> thx
19:26:38 <xenon_> good night
19:38:40 <otters> edwardk, how do I make kevin depend on lens HEAD? just for testing purposes
19:39:04 <edwardk> otters: the usual way would be to pull it from git, and cabal install it, then go and build kevin
19:39:11 <otters> oh
19:39:13 <otters> ok
19:39:43 <monochrom> don't forget to add the word "sandbox" 4 times to that line :)
19:40:21 * monochrom thinks the world needs transactional file systems badly
19:41:05 <monochrom> or perhaps use git to version-control your .ghc and .cabal
19:41:15 <tieTYT2> ?src max
19:41:15 <lambdabot> max x y = if x <= y then y else x
19:41:45 <tieTYT2> ah cool, that's how I wrote it.  I was wondering if there's a way to do it with pattern matching but I guess not
19:41:56 <monochrom> "git branch lensHEAD; git checkout lensHEAD; cabal install ..."
19:42:28 <cmccann> "GHC internal error: `t' is not in scope during type checking, but it passed the renamer"
19:42:30 <cmccann> oh GHC
19:43:01 <monochrom> oh fun. this does not explode :)
19:51:55 <otters> so if I have lens-3.8.2 installed, but it's not on hackage, can I somehow make cabal-dev install-deps succeed if my .cabal file requires lens-3.8.2
19:52:35 <monochrom> cabal-dev has a "cabal-dev source" command for that. but I don't know more
19:54:29 <otters> monochrom: oh, awesome
20:10:26 <statusfailed> Why does 'decode "null" :: Maybe Value' with Data.Aeson give Nothing instead of Just Null ?
20:10:49 <YayMe`> I realized the then function I wrote in javascript is the kleisli composition monad
20:10:52 <YayMe`> err function
20:11:13 <statusfailed> >=> ?
20:11:23 <YayMe`> yeah
20:11:32 <statusfailed> what's m?
20:11:37 <YayMe`> I had called it then
20:11:51 <YayMe`> Either
20:12:18 <YayMe`> http://codereview.stackexchange.com/questions/20845
20:12:52 <YayMe`> I originally had it called "then" in that code snippet, renamed it to kleisli today when I noticed
20:14:09 <YayMe`> statusfailed: am I right? my kleisli function is >=> ?
20:14:46 <statusfailed> not sure, I find JS hard to read :P
20:14:54 <YayMe`> you're telling me
20:14:58 <YayMe`> but to be fair
20:15:10 <statusfailed> i'm also not sure how monads can be expressed in JS :\
20:15:23 <YayMe`> writing things like this that are so easy in haskell are enormous pains in the arse in most all other languages
20:15:45 <statusfailed> what's the typesignature of kleisli?
20:15:55 <statusfailed> oh, that's the >=>
20:16:08 <statusfailed> right?
20:16:18 <YayMe`> statusfailed: I did it by creating an object that has two members, m and a, m is Success or Failure (Left or Right) a is the value
20:16:26 <YayMe`> statusfailed: Yeah
20:16:44 <geekosaur> turing equivalence implies that you can implemnt monads in any general purpose language.  but for most of them it's a turing tarpit
20:17:03 <Nisstyre> geekosaur: implementing monads is a turing tarpit?
20:17:14 <Nisstyre> I thought being a turing tarpit was a feature of a language
20:17:21 <statusfailed> Nisstyre: most languages it's basically impossible to really implement monads
20:17:34 <YayMe`> statusfailed: That's not really true
20:17:37 <Nisstyre> statusfailed: that depends on what you mean by "monads"
20:17:49 <statusfailed> I mean the Monad typeclass :p
20:17:51 <geekosaur> you can implemnt them, they're just ugly and really hard to use effectively
20:17:53 <YayMe`> statusfailed: It's just considerably uglier implementation than in haskell
20:17:53 <Nisstyre> if you mean an interface that supports the monad members, then yes
20:17:53 <statusfailed> which is a cheap definition :D
20:17:55 <Nisstyre> it is easily done
20:17:56 <geekosaur> hence turing tarpit
20:18:02 <johnw> if Haskell didn't have "do" notation, I'm not sure Monads would be terribly sexy here either
20:18:18 <Nisstyre> of course it's not necessarily useful in those languages
20:18:22 <statusfailed> johnw: Dunno, bind and lambda is still pretty useful, even if it is horribly ugly
20:18:39 <Nisstyre> statusfailed: bind is useful yeah
20:18:49 <geekosaur> enh, >>= and friends are quite useful
20:18:55 <statusfailed> Nisstyre: I meant writing monadic code without do notation
20:19:22 <Nisstyre> statusfailed: you can still get the HOFs that use monad functions
20:19:30 <YayMe`> johnw: the nesting that do notation does is not *necessary*, the way using then and always returning functions I'm able to do monads as bla.bla.bla rather than bla(bla(bla()))
20:19:34 <Nisstyre> and then those functions are nice and generic
20:19:35 <statusfailed> Nisstyre: even without the typeclasses?
20:19:42 <johnw> I guess the first-class nature of functions in Haskell makes a lack of "do" notation a lot less ugly than it could be
20:19:53 <johnw> because you can always factor out functions and write f >>= g >>= h, etc.
20:19:55 <Nisstyre> statusfailed: of course, use whatever mechanism that language has for ad-hoc polymorphism/generic functions
20:20:48 <statusfailed> I've not seen an implementation of the general "Monad" concept that allows stuff like sequence to be written, but I haven't seen that many
20:21:00 <Nisstyre> and then for dynamic languages you only have to treat all possible inputs as being instances of Monad
20:21:12 <Nisstyre> not pretty, but dynamic languages ain't pretty regardless
20:21:12 <YayMe`> johnw: I'm using >=> instead of >>= then having a run function that runs the composed monad, it's much prettier that way when you don't have do notation
20:21:31 <statusfailed> Nisstyre: and doesn't "return" require a type syste?
20:21:43 <statusfailed> type inference*
20:21:51 <Nisstyre> statusfailed: it requires polymorphic return types
20:21:58 <YayMe`> johnw: when you do have do notation though it's better to use >>=
20:23:37 <statusfailed> Nisstyre: i'm not sure how you'd implement it in a dynamic language is all
20:23:51 <statusfailed> anyway, i'm just agreeing with geekosaur :)
20:24:00 <Nisstyre> statusfailed: it's easy, there's just no guarantee that what gets passed to the functions is actually a monad
20:24:12 <Nisstyre> in fact there's no guarantee that an instance of Monad in Haskell is actually a monad
20:24:17 <YayMe`> statusfailed: I wrote it, look at that code in code review. Specifically, look at the test junk at the bottom
20:25:09 <YayMe`> Nisstyre: Yeah, I wish to god I could type check in javascript to verify my bind is getting an (a -> m a) because non-haskellers who use the lib I wrote would really struggle to have any idea why that type signature matters
20:25:36 <Nisstyre> YayMe`: yeah
20:25:44 <statusfailed> YayMe`: but your 'ret' requires an object, right?
20:26:04 <YayMe`> statusfailed: ret just requires whatever
20:26:29 <statusfailed> no I mean you have to call _m.ret, rather than just "ret", because there's no type inference to figure out which monad you're in
20:26:31 <YayMe`> statusfailed: In haskell return can take whatever you want and put it into the monadic context
20:26:40 <Nisstyre> statusfailed: that's right
20:26:53 <Nisstyre> statusfailed: all of the methods are in the object that gets passed to the functions
20:27:19 <Nisstyre> this is how, e.g. Python, does polymorphism
20:27:29 <YayMe`> statusfailed: oh, m_ is just the object I have nested my stuff in so it's not in global scope. But yes without type inference (or in javascripts case basically no type at all) there's no rational way to have ret automatically find the right instance
20:27:30 <Nisstyre> "polymorphism"
20:27:53 <YayMe`> statusfailed: That's a problem of type-classes when you can't have at all when you don't even have types
20:28:13 <Nisstyre> YayMe`: well you have _a_ type
20:28:22 <YayMe`> sort of
20:28:35 <YayMe`> I would have to manually create my own type-class router
20:28:38 <YayMe`> I *could*
20:30:24 <YayMe`> it's just like in haskell how you can't do == without creating an identifier to compare, there's no reference equals. In javascript there's no type system so you have to write your own if you want one by creating your own type identifiers for comparison and routing
20:30:32 <statusfailed> > decode (encode Null) :: Maybe Value
20:30:34 <lambdabot>   Not in scope: type constructor or class `Value'Not in scope: `decode'Not in...
20:30:36 <statusfailed> dangit
20:32:48 <statusfailed> wait, does JSON even allow a single "null" value not inside an object or array?
20:34:10 <YayMe`> statusfailed: What do you mean not inside an object or array?
20:35:12 <statusfailed> i.e. {"key": null}
20:35:31 <statusfailed> Aeson won't decode "null" as Null, but it will encode Null as "null"
20:35:39 <geekosaur> I think the aeson docs say that JSON requires the top level to be a container of some kind?
20:35:42 <geekosaur> Note that the JSON standard only allows arrays or objects of things at the top-level. Since this library follows the standard, calling decode on an unsupported result type will typecheck, but will always "fail":
20:35:55 <statusfailed> geekosaur: ah ok, I couldn't find it in the standard
20:35:56 <geekosaur> (http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson.html at "Pitfalls")
20:35:57 <statusfailed> should've read aeson docs :p
20:36:00 <statusfailed> cheers!
20:36:02 <YayMe`> as much as I dislike javascript, I'm glad there is *one* highly popular functional programming language in industry
20:36:54 <statusfailed> it definitely could have been worse :D
20:37:23 <otters> edwardk: would it be possible to create a Prism for SomeException
20:37:28 <YayMe`> statusfailed: Yeah, we could have zero popular functional languages in industry
20:37:33 <Kallikanzarid> That night, two of us realised
20:37:33 <Kallikanzarid> that we would be left with a lot of curry puns (aside from the spice,
20:37:33 <Kallikanzarid> and the thought of currying favour, the one that truly horriÔ¨Åed us
20:37:33 <Kallikanzarid> was Tim CurryóTIM was Jon Fairbairnís abstract machine, and
20:37:33 <Kallikanzarid> Tim Curry was famous for playing the lead in the Rocky Horror
20:37:33 <Kallikanzarid> Picture Show). So the next day, after some further discussion, we
20:37:35 <Kallikanzarid> settled on ìHaskellî as the name for the new language.
20:37:57 <Kallikanzarid> From https://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf
20:38:09 <Kallikanzarid> pure gold imo 8)
20:41:10 <edwardk> otters: there are lots of prisms for SomeException
20:41:13 <edwardk> :t _NonTermination
20:41:14 <YayMe`> Kallikanzarid: Cool, will have to check it out. I love the history of haskell and erlang: growing up together slideshow. Pretty awesome fun.
20:41:14 <lambdabot> AsNonTermination p f t => Overloaded' p f t ()
20:41:18 <edwardk> :t AssertionFailed
20:41:19 <lambdabot> Not in scope: data constructor `AssertionFailed'
20:41:21 <edwardk> :t _AssertionFailed
20:41:22 <lambdabot> AsAssertionFailed p f t => Overloaded' p f t String
20:41:26 <edwardk> :t exception
20:41:27 <lambdabot> (Applicative f, GHC.Exception.Exception a, Choice p) => p a (f a) -> p GHC.Exception.SomeException (f GHC.Exception.SomeException)
20:41:32 <otters> ...oh
20:41:56 <edwardk> there are about 50 or so different prisms you can use there ;)
20:42:11 <otters> what does exception do
20:42:14 <edwardk> :t catching _AssertionFailed
20:42:15 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => m r -> (String -> m r) -> m r
20:43:04 <edwardk> exception is a nice building block for building those more concrete exception prisms, but you can use it kind of like the old API
20:43:07 <edwardk> :t catching exception
20:43:08 <lambdabot> (GHC.Exception.Exception b, MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m) => m r -> (b -> m r) -> m r
20:43:25 <edwardk> is just effectively 'catch'
20:44:34 <XexonixXexillion> Does anyone know where I can find a recording of edwardk's talk on Lenses, Folds and Traversals that isn't on youtube? (Flash doesn't work on the computer I'm currently on, nor does the html5 player)
20:44:38 <otters> okay, so to create a Handler that catches any exception...
20:45:01 <YayMe`> edwardk: Does exception catching work by catching a Left?
20:45:30 <edwardk> otters: using head?
20:45:34 <otters> yeah
20:45:55 <edwardk> look at 'handled'
20:46:03 <otters> that's what I used for the first one
20:46:09 <otters> I just can't make sense of all these type variables
20:46:18 <otters> I count six
20:46:18 <edwardk> handed :: IsHandler m h => Getting (First a) SomeException s t a b -> (a -> m r) -> h r
20:46:32 <edwardk> in the haddocks there is a simpler sig
20:46:48 <edwardk> 'handled' :: 'Getter'    'SomeException' a -> (a -> 'IO' r) -> 'Exception.Handler' r
20:47:12 <edwardk> you give me any Getter/Fold/Traversal/Prism/Iso and a function from the output type of that to an IO action and i'll give you an exception handler.
20:47:31 <otters> I don't know what the output type is
20:47:38 <edwardk> YayMe`: well, it works by catching whatever the prism matches
20:47:40 <otters> I guess that's my problem
20:47:53 <edwardk> otters: what exception do you want to handle?
20:47:57 <otters> any
20:47:58 <edwardk> lets start there
20:48:02 <otters> any exception
20:48:11 <otters> catch (\(e :: SomeException) -> ...) basically
20:48:19 <otters> because I'm handling more specific cases first
20:48:38 <edwardk> handled id :: IsHandler m h => (SomeException -> m r) -> h r
20:48:57 <edwardk> handled id :: (SomeException -> IO r) -> Handler r   -- in your case
20:49:13 <YayMe`> edwardk: Eh, don't know what a prism is. I wrote a catch like behaviour using 'or' where it tries one function, if it returns left, it tries the next one. It's like try{x}catch(Left){y} written as or(x, y)
20:49:22 <edwardk> if you don't care about the exception itself you can use handled_ id :: IO r -> Handler r
20:49:23 <YayMe`> edwardk: Is it similar?
20:50:19 <edwardk> YayMe`: well, there is 'catching' which uses the prism/traversal/getter/fold to match the exception, and execute the code in question, but then if the first handler throws an exception its caught by the next handler. what otters is doing is working with 'catches'
20:50:25 <edwardk> :t Control.Exception.catches
20:50:26 <lambdabot> IO a -> [Control.Exception.Handler a] -> IO a
20:50:31 <edwardk> which takes a list of handlers
20:50:31 <otters> yeah
20:50:43 <edwardk> and runs them all, but they don't handle each others' leftovers
20:50:44 <otters> so what this code does is rethrow AsyncExceptions and ignore everything else
20:50:51 <otters> I wonder if there's a better way
20:51:28 <edwardk> what i just gave him is a combinator for building a magical handler that is smart enough to work with any Getter/Fold/Traversal/Prism/Iso/etc.
20:51:29 <YayMe`> edwardk: if I wrote my 'or' to take a list of things and try them in order until one returns Right would I be getting basically the same behaviour?
20:51:59 <edwardk> YayMe`: yes. though, this is for the Control.Exception plumbing, which is different than Control.Monad.Error
20:52:00 <YayMe`> basically like alternative
20:52:06 <YayMe`> ahh
20:52:27 <YayMe`> How is control.exception plumbing different? Not familiar with it. Just different types it passes around?
20:53:17 <edwardk> With Control.Monad.Error you make up an explicit type for your errors with Control.Exception they can be basically anything that instantiates the Exception class, and they can be caught on a more open basis, like you'd expect in a language like c++ or java
20:53:49 <edwardk> typically they are used for things like stackoverflows, asyncronous timeouts, and general bad things that you can't recover from in pure code
20:55:24 <msxx> getting errors when attempting to create a cabal package. what am I doing wrong?
20:55:30 <hpaste> msxx pasted ‚Äúerrors when trying to create a cabal package‚Äù at http://hpaste.org/81246
20:56:46 <geekosaur> msxx, you declare an exposed TestModule but your directory hierarchy has it as Data.TestModule
20:57:12 <geekosaur> at least that's what Build did with it
20:57:22 <geekosaur> I think
20:58:12 <geekosaur> hm, actually I'm not sure of that although it seems to go with the ar error
20:59:30 <geekosaur> actually, exactly that.  "module Data.TestModule where"
21:00:09 <geekosaur> if you named it Data.TestModule then that's what you want to have in exposed-modules
21:00:32 <msxx> so what is the proper way, making module TestModule or exposing Data.TestModule
21:01:18 <geekosaur> we tend to prefer the latter but it for a real module it may depend on how you're going to use it
21:03:16 <edwardk> otters: did the handled id thing work?
21:03:21 <otters> yessir
21:03:35 <edwardk> i'll push out a 3.8.2 shortly then
21:03:36 <otters> now I understand a little better, I guess
21:03:42 <otters> oh, well, it typechecked
21:03:48 <otters> let me just make sure it runs as expected
21:03:52 <edwardk> =)
21:04:09 <edwardk> pay no attention to the scary scary way in which handled is implemented ;)
21:06:33 <msxx> getting new error now after exposing Data.TestModule, with everything else remaining the same. cabal: can't find source for Data\TestModule in dist\build\autogen
21:07:04 <msxx> I can paste new dist tree
21:08:11 <otters> edwardk: yep, looks like it works
21:08:19 <otters> both handlers were called when expected
21:08:29 <edwardk> great =)
21:08:35 <donri> i still don't get Typeable 'cast', how is it any different from 'Just'?
21:08:42 <otters> time to make all of kevin's code as lensy as humanly possible
21:08:57 <donri> you can only cast to the same type, not really a cast at all?
21:09:16 <edwardk> donri: what happens when you only know that you have _some_ Typeable.
21:09:39 <edwardk> donri: the point of Typeable is to recover from that loss of type information that comes from an existential context.
21:09:52 <edwardk> data Foo = forall a. Typeable a => Foo a
21:09:53 <donri> oooh i think i get it, thanks =)
21:10:03 <edwardk> when i pattern match on Foo i know nothing about 'a' except that its Typeable.
21:11:09 <copumpkin> which as far as knowledge goes
21:11:10 <copumpkin> is pretty good
21:11:11 <hpaste> msxx annotated ‚Äúerrors when trying to create a cabal package‚Äù with ‚Äúnew errors after exposing Data.TestModule instead of TestModule‚Äù at http://hpaste.org/81246#a81247
21:12:30 <donri> msxx: .cabal should go in the same directory as "Data", not in Data itself
21:12:52 <otters> edwardk: is it a good idea to make my own AsFooException class and define a Wrapped instance for it
21:13:07 <otters> or is there a simpler way to ensure that some handler only catches some custom exception type
21:13:23 <edwardk> otters: its perfectly reasonable to do so. another way would be to just write something like
21:13:37 <edwardk> _FooException :: Prism' SomeException FooException; _FooException = exception
21:13:45 <otters> ooooooooh
21:13:47 <edwardk> since you don't need the full flexibility of it
21:14:06 <edwardk> then you can use handles _FooException
21:14:08 <otters> right
21:14:33 <edwardk> and of course you can mix and match 'handles' with oldschool Handler uses
21:14:56 <donri> msxx: either that or like what you did first but change the "module" declaration to not include "Data."
21:18:02 <msxx> got it working, thanks donri geekosaur
21:20:28 <msxx> is there any difference for the user of library between Data.Foo being exposed vs just Foo?
21:21:16 <geekosaur> no, but we prefer not to have lots of stuff cluttering the top level
21:21:34 <shachaf> geekosaur: What's the difference between cluttering up Data and the top level?
21:21:41 <johnw> Library.Foo is reasonable, if your Library has lots of modules
21:21:47 <geekosaur> if you want to go back to 1998 and have everything in the top level, go nuts.  but expect hackage to be annoyed about it, along with any potential users
21:22:15 <shachaf> What is the advantage of "Control.Monad" or "Data.Functor" vs. "Monad" or "Functor"?
21:22:15 <geekosaur> same answer to you, shachaf.  if you like haskell98 flat namespace, be my guest
21:22:31 <shachaf> geekosaur: Obviously there are some places where hierarchy makes sense.
21:22:49 <shachaf> But does hierarchy for the sake of hierarchy make sense?
21:23:11 <johnw> i sometimes wonder why Data.Functor.Identity isn't just Data.Identity
21:23:17 <geekosaur> you can argue that one with the libraries folks
21:23:40 <johnw> i often try to import Control.Monad.Identity, because I need it as a Monad, only to find it's not there
21:23:40 <geekosaur> I didn't make the rules; I'm just reporting them.  if it offends you, talk to libraries@
21:24:25 <shachaf> The rules are "Don't export any module without a . in its name"?
21:25:38 <geekosaur> excuse me while I read the minds of the library folks to understand their intent, since apparently that's my job...
21:26:15 <geekosaur> the Control vs. Data vs. who knows what has been argued before; you can reopen it.
21:26:32 <geekosaur> no, I'm not interested in being your proxy for libraries@
21:26:40 <shachaf> I thought you were reporting the rules.
21:26:46 <shachaf> I apologize for any apparent hostility.
21:26:57 <geekosaur> so that makes me libraries@ ?
21:27:07 * ijp plans Data.Stupid.Joke.Taken.Too.Far
21:27:27 <geekosaur> I said that hierarchical was preferred but exceptions could make sense.  I didn't say Data was mandatory
21:28:47 <tieTYT2> i just broke a rule I didn't know existed.  I did function :: (Int a) => a -> a and it complained and after googling discovered it's because the thing in the parenthesis has to be a typeclass (EG: Eq, Ord, etc.) and can't be a type.
21:29:15 <shachaf> tieTYT2: The thing to the left of the => has to be a constraint.
21:29:17 <johnw> out of curiosity, what did you intend it to mean?
21:29:27 <shachaf> (Int a) doesn't make sense -- Int doesn't take arguments.
21:29:42 <shachaf> Parentehses aren't related -- "Num a => a -> a" is a fine type.
21:29:52 <tieTYT2> johnw: Actually, I wrote it like this: replicate' :: (Int a) => a -> b -> [b]
21:29:56 <geekosaur> so, when you do that (...) => thing, it quietly becomes an actual additional parameter to the function containing a lookup table for the class constraints.  Int doesn't have a lookup table...
21:30:04 <tieTYT2> what I thought it was, is like casting
21:30:28 <tieTYT2> because in Java, you put parens around something to cast it.  I thought I was saying, "the variable 'a' has to be an int type"
21:30:30 <johnw> you wanted the "a" passed in to be silently cast to an Int?
21:30:46 <shachaf> tieTYT2: There is no casting in Haskell.
21:31:13 * johnw glances at shachaf evilly
21:31:14 <tieTYT2> johnw: not silently casted, I just accidentally fell back to half java logic because that's what I'm familiar with
21:31:18 <johnw> ah
21:31:34 <shachaf> The "additional parameter" view is really implementation detail of type classes.
21:31:40 <mikeplus64> tieTYT2: you can actually do something similar to that. replicate :: a ~ Int => a -> b -> [b]
21:31:49 <tieTYT2> does this mean it would never make sense to have an Int a, Int b => ... (forgive me if that syntax is invalid)
21:31:52 <mikeplus64> where ~ is (somewhat peculiarly) type equality
21:31:54 <shachaf> You can do what mikeplus64 said but I don't recommend it.
21:32:05 <shachaf> It's also not standard Haskell.
21:32:17 <tieTYT2> i haven't learned what ~ is yet
21:32:19 <mikeplus64> tieTYT2: it's best to just do something :: Int -> a -> ... -> whatever
21:32:22 <johnw> mikeplus64: what does that mean in that case?
21:32:27 <mikeplus64> ~ is type equality, like i said
21:32:29 <tieTYT2> oh god, i asked my question with the same issue
21:32:32 <tieTYT2> let me reask it
21:32:40 <tieTYT2> does this mean it would never make sense to have an Eq a, Eq b => ... (forgive me if that syntax is invalid)
21:32:46 <shachaf> tieTYT2: That's fine.
21:33:00 <shachaf> With parentheses, at least.
21:33:03 <geekosaur> you need parens for multiple constraints though
21:33:03 <tieTYT2> shachaf: why wouldn't you just reuse a in both places on the right hand side?
21:33:12 <shachaf> > let foo :: (Eq a, Eq b) => a -> a -> b -> b -> Bool; f a b x y = a == b && x == y
21:33:14 <lambdabot>   not an expression: `let foo :: (Eq a, Eq b) => a -> a -> b -> b -> Bool; f ...
21:33:19 <shachaf> tieTYT2: Because they're two different types.
21:33:20 <geekosaur> because they might not be the same type, just both need Eq constraints
21:33:25 <shachaf> > let foo :: (Eq a, Eq b) => a -> a -> b -> b -> Bool; f a b x y = a == b && x == y in foo 'a' 'a' 3 5
21:33:27 <lambdabot>   The type signature for `foo' lacks an accompanying bindingNot in scope: `fo...
21:33:33 <shachaf> > let foo :: (Eq a, Eq b) => a -> a -> b -> b -> Bool; foo a b x y = a == b && x == y in foo 'a' 'a' 3 3
21:33:35 <lambdabot>   True
21:33:36 <shachaf> > let foo :: (Eq a, Eq b) => a -> a -> b -> b -> Bool; foo a b x y = a == b && x == y in foo 'a' 'a' 3 5
21:33:38 <lambdabot>   False
21:33:52 <shachaf> tieTYT2: I recommend learning more about Haskell without type classes for a while.
21:34:10 <shachaf> They're not nearly as fundamental a feature as other parts of types.
21:34:26 <tieTYT2> shachaf: i'm not sure if I can avoid that, i'm on the recursion chapter of the book http://learnyouahaskell.com/recursion
21:34:46 * shachaf sighs.
21:35:05 <tieTYT2> the previous chapter was about types and typeclasses
21:36:01 <shachaf> Hm.
21:36:55 <tieTYT2> i think I sort of get this though.  the rule is the typeclass variable (eg: 'a') is bound to a very specific type, if you want to allow two different types of Eq implementations in a function you'll need an 'a' and a 'b'
21:37:09 <shachaf> "a" is always the same type.
21:37:11 <shachaf> Type classes or not.
21:37:13 <shachaf> @ty filter
21:37:14 <lambdabot> (a -> Bool) -> [a] -> [a]
21:37:20 <tieTYT2> right
21:37:21 <shachaf> No type classes there, but the same thing applies.
21:37:28 <tieTYT2> oh ok
21:37:33 <shachaf> Type classes let you do more with a type.
21:37:37 <shachaf> @ty find
21:37:39 <lambdabot> (a -> Bool) -> [a] -> Maybe a
21:37:41 <shachaf> Hmm.
21:37:43 <shachaf> @ty lookup
21:37:44 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
21:37:56 <shachaf> For example, that's the same type as a -> [(a, b)] -> Maybe b
21:38:07 <shachaf> But it also says: If you have two "a"s, you can check whether they're equal.
21:38:16 <shachaf> You can't do it without the "Eq a =>"
21:38:30 <shachaf> So what constraints do is give you more operations that you can do with types.
21:38:47 <tieTYT2> makes sense
21:38:52 <tieTYT2> is Maybe a typeclass?
21:38:54 <shachaf> No.
21:39:08 <XexonixXexillion> data Maybe a = Just a | Nothing
21:39:28 <shachaf> Type classes are used in lots of places in Haskell, but understanding them is not nearly as important as understand other parts of the type system.
21:39:30 <Kallikanzarid> YayMe`, growin up together is very nice 8)
21:39:31 <tieTYT2> XexonixXexillion: haven't gotten to that yet.  But i recall it being a datatype or something
21:39:48 <Kallikanzarid> i dig its explanation on how STM is done in haskell
21:39:58 <shachaf> tieTYT2: You've read about types and type classes without reading about how to define types?
21:40:00 <tieTYT2> shachaf: ok, I trust you there, but I feel more confident in my progress by asking these questions anyway
21:40:20 <tieTYT2> shachaf: does that mean to make my own types?
21:40:28 <tieTYT2> shachaf: yeah I haven't learned how to make them yet
21:40:30 <shachaf> Sure. Just remember that type classes are just a "covenience" thing for the most part, at this point.
21:40:35 <geekosaur> that seems odd
21:40:53 <geekosaur> yyou haven't done anything like:  data Foo = ...
21:40:54 <tieTYT2> i'm going to assume the book just need to explain what a type signature meant
21:40:54 <geekosaur> ?
21:40:59 <tieTYT2> geekosaur: no
21:41:07 <XexonixXexillion> shachaf: They aren't just a conveniene thing? What expressiveness do they add?
21:41:19 <ClaudiusMaximus> :t (0 :+ 0) :+ 0
21:41:21 <lambdabot> RealFloat a => Complex (Complex a)
21:41:34 <XexonixXexillion> s/conveniene/convenience/
21:41:38 <tieTYT2> anyway, I'll go back to reading, thanks for the help
21:41:40 <shachaf> XexonixXexillion: Let's see you write Data.Set with the same guarantees without classes.
21:42:08 <XexonixXexillion> shachaf: give me a minute
21:42:10 <ClaudiusMaximus> > ((0 :+ 0) :+ 0) + 1
21:42:11 <lambdabot>   No instance for (GHC.Float.RealFloat (Data.Complex.Complex a0))
21:42:11 <lambdabot>    arising ...
21:43:06 <msxx> dont want to start another flamewar, but as a general guideline should I try to reuse haskell's module top-level hierarchy?  I other languages I would have Msxx top-level module, and then submodules within it
21:43:17 <msxx> In
21:43:34 <ifnspifn> Hey all, I was wondering if anyone could help me out working with TArrays in the STM module. I'm not at all sure how an array of, say, 100 TVar Bool values can be created. newPrimeList :: STM PrimeList
21:43:35 <ifnspifn> newPrimeList = newArray (2, 100) True
21:43:35 <shachaf> You probably shouldn't do Java-style hierarchies like that.
21:43:45 <geekosaur> msxx, only some langiages have you build your own hierarchy by default
21:44:17 <ifnspifn> err, I should point out that: type PrimeList = TArray Int Bool. The above code seems to just make a regular Array of Bools
21:45:09 <shachaf> ifnspifn: I'm not sure a TArray is right for what you're doing.
21:45:15 <ClaudiusMaximus> > 1 :+ 1 * (1 :+ 1)
21:45:15 <msxx> so Data.String.Msxx is prefered over Msxx.String I guess
21:45:17 <lambdabot>   (1.0 :+ 0.0) :+ (1.0 :+ 1.0)
21:45:22 <ClaudiusMaximus> fun stuff
21:45:35 <shachaf> msxx: I think something descriptive rather than your name is even more preferred. :-)
21:45:49 <ifnspifn> shachaf: I'm attempting to make an array which multiple threads can access simultaneously, so an array of TVars seemed natural
21:46:19 <shachaf> ifnspifn: Maybe.
21:46:21 <msxx> shachaf: problem starts when someone else wants to use equally decriptive name
21:46:26 <shachaf> Anyway, what's confusing about TArray's documentation?
21:46:52 <geekosaur> msxx, that's what we have cabal for
21:46:54 <ifnspifn> well, I can't find any :P this is all I've found: http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/Control-Concurrent-STM-TArray.html
21:47:04 <shachaf> geekosaur: That's not a very good answer...
21:47:21 <shachaf> Conflicting modules aren't very nice even with cabal.
21:47:34 <geekosaur> we *have* duplications in the existing tree.  cabal lets you specify which packages to use, so you get the Foo.Bar from the package you want and not some random other package
21:47:39 <shachaf> ifnspifn: OK, what's confusing about that?
21:48:05 <ifnspifn> I suppose I don't understand how to use the MArray interface
21:48:05 <geekosaur> nevertheless, I don't see many people colliding over monads-fd vs. monads-tf...
21:48:24 <quazimodo> my monads bring all the boys to the yard and they're like, its better than yours
21:48:31 <shachaf> geekosaur: It's the case that people will hate you if you name your module Control.Monad.List, even if it's a more correct List transformer than the one in mtl.
21:48:58 <shachaf> Control.Monad.Trans.List, rather.
21:49:09 <shachaf> "hate" is an exaggeration. But they'll be annoyed.
21:49:30 <geekosaur> true, but they won't care as much if you're not shadowing a major library
21:49:42 <quazimodo> mahogny: *hug*
21:49:50 <ifnspifn> I've tried: newArray (2,100) $ newTVar True, but this yields an array of type TArray Int (STM (TVar Bool)) rather than TArray Int (TVar Bool), which I *think* is what I want
21:50:19 <shachaf> ifnspifn: I think that gets you TVars of TVars.
21:50:23 <shachaf> Look at the definition of TArray.
21:50:38 <shachaf> geekosaur: If you're not shadowing a major library, then not as many people will be annoyed. But those people will be just as annoyed. :-)
21:51:19 <geekosaur> will they be as annoyed as the people who want haskell98 flat namespace back?   ...will they matter as much?
21:51:56 <shachaf> Are you making fun of me or something?
21:52:23 <geekosaur> not so much you as your apparent need to play devil's advocate.
21:52:44 <geekosaur> yes, arguments can be made.  no, not usefully here; and most of them have been made, in more appropriate places
21:53:40 <geekosaur> rehashing here just doesn't seem to have much point
21:54:10 <geekosaur> seriously, if someone wants us to switch back to haskell98, or to java style namespaces, or etc., go make your proposal to libraries@
21:55:42 <shachaf> What?
21:55:44 <geekosaur> I don;t denny there are shortcoimings in what we have --- but those shortcomings also exist in other languages that made similar decisions, and somehow they have not collapsed in a heap over it.  likewise, java's namespacing scheme has shortcomings, and flat namespaces have shortcomings, etc.
21:55:59 <geekosaur> if you think you have a better idea, seriously, go propose it
21:56:22 <geekosaur> s/denny/deny/
21:56:29 <mikeplus64> i don't think anyone is arguing against you geekosaur
22:01:05 <geekosaur> you will excuse me but I feel like I'm being told to justify all the decisions made by others over the years.  I'm not in a position to do so.
22:01:30 <hpaste> XexonixXexillion pasted ‚ÄúWho needs typeclasses?‚Äù at http://hpaste.org/81248
22:02:00 <XexonixXexillion> shachaf: sufficient?
22:02:01 <mikeplus64> XexonixXexillion: i need typeclasses... i gotta have my fix man
22:02:13 <shachaf> XexonixXexillion: No.
22:02:20 <shachaf> XexonixXexillion: Write an efficient union, like the one in Data.Set.
22:02:37 <shachaf> (Also, don't call binary trees "BTree"! :-) But that doesn't matter so much.)
22:03:46 <shachaf> XexonixXexillion: union takes two Sets, and relies on the fact that they use the same ordering to merge them efficiently.
22:04:15 <shachaf> Oh, you wrote merge.
22:04:18 <shachaf> -- We'll use the algebra of the first set... hopefully they're the same
22:04:30 <shachaf> This is an example of an extra thing that a type class can give you. :-)
22:04:44 <XexonixXexillion> shachaf: A loss of flexibility?
22:05:01 <shachaf> Hmm, yours generates a valid tree, though. If you had a more efficient representation you wouldn't even get that guarantee.
22:05:34 <shachaf> XexonixXexillion: One person's loss of flexibility is another person's gain of flexibility.
22:06:20 <XexonixXexillion> shachaf: why would an efficient representation change anything? As long as you only use the one algebra for a given type, it should be identical to using type classes, shouldn't it?
22:07:03 <shachaf> This thing lets you make two sets with different orderings.
22:07:42 <shachaf> Given two balanced binary trees with a guarantee that their ordering function is the same, you can merge them efficiently.
22:07:57 <shachaf> (More efficiently than iterating over the elements of one and inserting them into the other.)
22:08:27 <shachaf> Without that guarantee, you'll generate an invalid tree.
22:08:57 <XexonixXexillion> shachaf: So we don't let them define their own algebra, and we only define one for the type
22:09:42 <shachaf> As a user of Data.Set, I can make whatever types I like, and give them whatever Ord instance I like.
22:09:47 <XexonixXexillion> shachaf: or we just tell them to only ever define one algebra for the type, in much the same way we trust them to define monads that meet the monad laws
22:10:34 <shachaf> OK, you might as well say that types don't add any expressiveness, because you might as well write a program that would type-check if you had types -- just don't get it wrong!
22:12:36 <XexonixXexillion> shachaf: They don't add expressiveness, they add safety.
22:13:00 <shachaf> OK, what is expressiveness?
22:13:23 <shachaf> You can compile any Haskell program with type classes to one without type classes.
22:13:51 * hackagebot sizes 2.1.2 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.1.2 (JohnWiegley)
22:15:29 <Nisstyre> Is there a function like Control.Monad.Random.fromList except with [(a,Float)] or [(a,Double)] ?
22:15:48 <shachaf> @hoogle Control.Monad.Random
22:15:48 <lambdabot> package random
22:15:48 <lambdabot> package random-access-list
22:15:48 <lambdabot> package random-extras
22:16:02 <bh> I'm trying to select an appropriate HTTP library to use. All I'm interested in doing is slurping small bits of XML
22:16:17 <donri> bh: hxt-http?
22:16:22 <johnw> Nisstyre: can you composed it with a function [(a, Rational)] -> [(a, Double)]?
22:16:22 <shachaf> Probably not.
22:16:32 <johnw> i mean, the reverse of that
22:16:40 <shachaf> i love covariance
22:16:41 <shachaf> it is so easy
22:16:43 <johnw> haha
22:16:45 <Nisstyre> johnw: yes but it would happen thousands of times
22:16:53 <johnw> ah
22:17:00 <johnw> i see what you mean
22:17:23 <Nisstyre> I *can* use Rationals, but I prefer to use Doubles
22:17:31 <johnw> that fromList function does this: (fromRational (sum (map snd xs))) :: Double -- total weight
22:17:39 <johnw> if I were you, I'd just copy the definition and modify it to suite
22:17:44 <Nisstyre> yeah, good idea
22:18:47 <XexonixXexillion> shachaf: I don't know how to explain what I mean. Perhaps the closest analogy would be that the amount of code I'm writing is bound to the kolmogorov complexity of the concept, but that doesn't make much sense
22:19:04 <Nisstyre> johnw: lol at the comment "- TODO: Do we want to be able to use floats as weights?"
22:19:09 <Nisstyre> they're reading my mind
22:19:29 <johnw> hehe!
22:20:01 <shachaf> XexonixXexillion: OK, then I don't know how to tell whether type classes add expressivity. :-)
22:20:17 <bh> donri: That looks like a very reasonable choice. Thanks
22:23:29 <XexonixXexillion> shachaf: Also, Data.Set doesn't give me the guarantees that you promise; it relies on a sane implementation of Ord, less of a leap of faith than my "Let's just hope they use the same algebra" but still not something you can guarantee
22:34:28 <NemesisD> i'm trying to define foo x = Constructor <$> pure x in points free mode, best i got is fmap Constructor . pure, but i wonder if there's an existing function that does this cleaner
22:35:48 <mm_freak> NemesisD: seems like the whole function is pretty useless
22:36:31 <shachaf> fmap f (pure x) = pure (f x)
22:36:49 <lightquake> is hspec considered the hip new thing for testing?
22:37:00 <NemesisD> lightquake: i'm pretty hip and i use it
22:37:17 <NemesisD> shachaf: so pure . Constructor?
22:37:26 <shachaf> You could do that.
22:37:44 <mm_freak> you could, but that function seems just as useless
22:37:44 <NemesisD> got something better?
22:37:55 <mm_freak> (it's the same function after all)
22:38:40 <mm_freak> you can't get better than that, if you mean "shorter"
22:40:36 <NemesisD> mm_freak: i'm writing a FromJSON instance for aeson, it exposes a function withText that effectively: Text -> Parser a
22:41:30 <NemesisD> newtype Constructor = Constructor { unConstructor :: Text }; instance FromJSON Constructor where; parseJSON = withObject $ pure . Constructor
22:46:16 <fmap> NemesisD: I'd just derive FromJSON instance for newtype
22:47:40 <NemesisD> fmap: don't i need something else for that, like generics?
22:48:43 <fmap> NemesisD: you need -XGeneralizedNewtypeDeriving
22:50:48 <YayMe`> NemesisD: What's aeson?
22:51:31 <donri> json lib
23:03:11 <tieTYT2> wow quicksort in haskell is really elegant
23:03:46 <shachaf> It's also not quicksort.
23:03:55 <capisce> and not practical
23:04:00 <shachaf> It's a different algorithm in most ways that matter. It just happens to look similar.
23:04:37 <tieTYT2> oh
23:04:53 <tieTYT2> what's wrong with it?
23:05:03 <capisce> it's slow
23:05:42 <tieTYT2> but how's it a different algorithm?
23:05:53 <shachaf> What makes on algorithm the same as another one?
23:06:06 <johnw> http://stackoverflow.com/questions/7717691/why-is-the-minimalist-example-haskell-quicksort-not-a-true-quicksort
23:06:31 <tieTYT2> cool i'll read this
23:06:50 <mm_freak> well, i'd still call it quicksort‚Ä¶  nothing specifies that it has to update in-place
23:07:01 <mm_freak> it's just a really inefficient implementation
23:07:01 <johnw> let's call it slowsort
23:07:02 <shachaf> mm_freak: It lacks the quickness property.
23:07:10 <shachaf> Call it "sort".
23:07:19 <shachaf> (Except don't call it that! People might use it if you do that.)
23:07:22 <tieTYT2> the weird thing about this book is it's taught me list comprehensions before it taught me filter
23:07:25 <mm_freak> notReallyQuickSort
23:07:48 <tieTYT2> and when I stopped reading real world haskell it hadn't taught me list comprehensions yet
23:07:51 <johnw> adagiosort
23:08:12 <mm_freak> i don't like that many people quote notReallyQuickSort to demonstrate haskell
23:08:32 <shachaf> What would be a good way to demonstrate Haskell?
23:08:40 <capisce> mm_freak: that was how I was first exposed to Haskell I believe :)
23:08:44 <mm_freak> personally i always show a small echo server
23:08:45 <ahokaomaeha> Actual quicksort? :-|
23:08:50 <mm_freak> capisce: me too
23:09:03 <mm_freak> actual quicksort doesn't look any more pretty than in C, except the syntax is a bit shorter
23:09:12 <capisce> but of course even if it wasn't real quicksort the explanation of how it worked taught me quite a bit about Haskell
23:09:28 <capisce> mm_freak: wonder if we can make it look prettier
23:09:47 <mm_freak> capisce: certainly, but then it's not a beginner-friendly demonstration
23:09:56 <mm_freak> the code will be too opaque
23:10:35 <mm_freak> i mean you can easily praise the conciseness of haskell with a really obscure example
23:10:58 <tertl3> is there an editor out there that can auto format haskell code like visual studio can?
23:11:07 <mm_freak> > filterM(\_->[1<0..]) "abc"
23:11:08 <lambdabot>   ["","c","b","bc","a","ac","ab","abc"]
23:11:15 <capisce> mm_freak: yeah, I had been exposed to lisp and functional languages like Oz before
23:11:15 <ahokaomaeha> tertl3: Emacs' haskell-mode
23:11:36 <mm_freak> if that's not crazy enough, i have more =)
23:11:47 <tertl3> ahokaomaeha, do you know if windows emacs does it too?
23:12:03 <ahokaomaeha> tertl3: no idea, but I guess yes
23:12:31 <tertl3> why not right
23:13:03 <capisce> mm_freak: well, the "quicksort" example doesn't go that far :)
23:14:23 <ahokaomaeha> It would be cool if Haskell provided *safe* means to unfreeze immutable arrays into mutable ones, and freeze mutable ones into immutable ones.
23:14:39 <ahokaomaeha> arrays, vectors, whatever
23:14:42 <Hafydd>  reallyQuickNotSort = id
23:14:49 <mm_freak> > foldM(flip(\y->liftA2(zipWith(\xs->(xs++).(y:)))inits tails))[] "abc"
23:14:52 <lambdabot>   ["cba","bca","bac","cab","acb","abc"]
23:15:26 <mm_freak> haskell craziness gone weltuntergang
23:16:20 <mm_freak> ahokaomaeha: see 'modify' in Data.Vector.*
23:16:45 <ahokaomaeha> mm_freak: lemme see
23:16:48 <mm_freak> if you compose that you may get in-place update
23:17:55 <steve__> hello?
23:18:01 <mm_freak> hello!
23:18:21 <steve__> I have an extremely basic, but possibly slightly time consuming "question"
23:18:31 <mm_freak> go ahead
23:18:39 <steve__> And by question I mean I just keep getting parsing errors
23:18:45 <shachaf> @paste
23:18:45 <lambdabot> Haskell pastebin: http://hpaste.org/
23:19:07 <shachaf> i love hpaste
23:19:07 <shachaf> it is so easy
23:19:34 <mm_freak> shachaf: the only thing missing is a good search function
23:20:03 <mm_freak> it's a shame i have to use google =)
23:20:44 <hpaste> st pasted ‚ÄúAssign1‚Äù at http://hpaste.org/81253
23:21:26 <steve__> alright, if you need the class that is imported let me know
23:21:44 <steve__> and just btw, #5 works alright, I know
23:22:28 <fmap> steve__: you forgot to paste errors
23:22:56 <mikeplus64> when can we expect more-or-less haskell expression syntax for types? it would be neat to say type Append :: a -> b -> c; Append [] xs = xs; Append (y:ys) xs = Append ys (y:ys). or even Append = \ xs ys -> case xs of [] -> ys; ...
23:23:35 <mikeplus64> because that seems to be the direction really -- types becoming like expressions except at compile time, and a bit uglier/more verbose
23:23:40 <mm_freak> mikeplus64: those are functions, not types
23:23:43 <mikeplus64> direction ghc is headed*
23:24:02 <mikeplus64> mm_freak: i mean for that syntax to work as a type family
23:24:16 <mikeplus64> i meant Append :: [a] -> [a] -> [a]
23:24:19 <johnw> mikeplus64: it sounds like you are asking about Agda
23:24:22 <mm_freak> mikeplus64: what's a use case?  did you really think this through?
23:24:30 <mm_freak> mikeplus64: that would mean that Append is a constructor of []
23:24:38 <mikeplus64> '[]
23:24:50 <mm_freak> ah
23:25:04 <mm_freak> well, except for the "type instance" cruft it's like function syntax
23:25:24 <mikeplus64> mm_freak: it's useful if you don't want to declare type families for everything you want kinda-dependently-typed using type families
23:26:04 <mikeplus64> e.g. instead of fun :: a -> b -> Thing a b you might have fun :: a -> b -> case a of ...
23:26:58 <mikeplus64> with the next ghc apparently type families will be able to run like functions in their clauses, without any overlapping instance stuff, going from top to bottom, which seems to me to enable what i said there
23:27:07 <mikeplus64> (case expressions in types)
23:27:13 <mm_freak> mikeplus64: in haskell's type system they are type constructors
23:27:17 <mm_freak> so the syntax makes sense+
23:27:22 <mm_freak> remember that haskell is not dependently typed
23:27:52 <mikeplus64> yes, but it seems well on the way
23:27:56 <mm_freak> what you want requires collapsing the type and kind levels, so you really want something like agda/idris
23:28:02 <mikeplus64> for things like that to be possible i mean
23:28:16 <mikeplus64> i want agda/idris without the agda/idris :(
23:32:10 <TheRedMood> `nand`, you said something yesterday about fractal
23:32:34 <TheRedMood> What did you mean by it? When you told me that [x,x-1..1] is the same as [x..1]
23:32:35 <TheRedMood> ?
23:34:10 <mikeplus64> mm_freak: hell i think that case-expressions-in-types, in the next ghc, could be implemented as just a fairly simple preprocessor thing that would translate into type families
23:34:34 <fmap> TheRedMood: it's the same as [1..x] (given your problem and sane Enum instance)
23:35:39 <fmap> (and it's very different from [x..1])
23:35:39 <TheRedMood> Yeah I know
23:36:10 <mikeplus64> where case x of ... would translate to type family Foo0 (a :: k) :: b; type instance where Foo0 <clause 0 for x> = ...; Foo0 <clause 1 for x> = ...; ...
23:36:29 <TheRedMood> I was talking about factorials
23:36:37 <statusfailed> Is there some function like Traversable t => [a] -> t a ?
23:36:39 <TheRedMood> He/she did a clever trick or something
23:36:40 <TheRedMood> :o
23:37:13 <statusfailed> basically fromList where I don't haveto import the relevant module :D
23:38:12 <shachaf> mjrosenb: You are!
23:38:22 <mjrosenb> indeed, I am!
23:38:31 <shachaf> Glad to be of service.
23:38:39 <statusfailed> O_O
23:38:52 <mjrosenb> shachaf: I figured there was like a 90% chance that you'd ping me after I said that.
23:41:21 <steve73> So I'm using emacs
23:41:23 <TheRedMood> wow
23:41:28 <steve73> and when I try to find my error
23:41:38 <steve73> it only shows the one closest to the end of the code
23:42:11 <steve73> and there happens to be a parsing error at the last character of the comment that ends the code
23:43:00 <johnw> how does it "show" it?
23:43:05 <johnw> are you talking about flymake?
23:43:23 <steve73> haskellmode
23:43:30 <steve73> so basically ghci not really emacs
23:43:32 <johnw> what are you seeing exactly?
23:43:36 <johnw> can you show me a screenshot?
23:44:28 <steve73> ~\Documents\...\start-hw1.hs:83:6:     parse error (possibly incorrect indentation)
23:44:45 <johnw> that often indicates an unmatched ( higher up in your code
23:44:46 <steve73> Failed, modules loaded:
23:45:07 <steve73> oh, that makes sense i will go look thank you
23:45:07 <johnw> type M-x check-parens RET
23:46:13 <steve73> in ghci?
23:46:19 <johnw> no, in Emacs
23:46:24 <johnw> meta x, check-parens, return
23:46:56 <steve73> meta is escape on windows right>
23:47:05 <johnw> escape will work on any platform
23:47:56 <steve73> i cannot put a space in between check-parens and RET
23:48:00 <steve73> was that an accident?
23:48:09 <johnw> type escape, and then x
23:48:10 <steve73> [sole-completion]
23:48:14 <steve73> OH
23:48:16 <johnw> you should see a "M-x" prompt
23:48:16 <steve73> RETURN
23:48:20 <johnw> yes :)
23:48:20 <steve73> wow that was dumb
23:48:39 <steve73> alright i found it
23:48:53 * hackagebot Bookshelf 0.3 - A simple document organizer with some wiki functionality  http://hackage.haskell.org/package/Bookshelf-0.3 (EmilAxelsson)
23:48:55 * hackagebot either 3.1 - An either monad transformer  http://hackage.haskell.org/package/either-3.1 (EdwardKmett)
23:50:49 <steve73> 2 unmatched parens in one expression
23:50:58 <steve73> will be back after i figure this out
23:50:58 <johnw> :)
23:51:05 <johnw> you can tell I've been down this road a few times
23:51:30 <johnw> in fact, I have Emacs trigger an error nowadays if I save a file with unmatched parens
23:51:49 <snowylike> that's a good idea to do
23:52:11 <shachaf> monoids are so easy
23:52:36 <johnw> snowylike: (add-hook 'haskell-mode-hook (lambda () (add-hook 'after-save-hook 'check-parens nil t)))
23:52:47 <snowylike> johnw: thanks
