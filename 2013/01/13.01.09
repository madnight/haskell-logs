00:00:01 <nushio3> Hello, is there any type-level equality that works in (>= ghc 7.6.1)?
00:00:50 <nushio3> I see several libraries as candidates...
00:01:13 <nushio3> TypeNats : math operations still not possible in ghc7.6.1 main branch.
00:01:31 <nushio3> GHC.TypeLits.Symbols : no string operations supported.
00:01:49 <nushio3> HList.Label* : manually need to assign integers.
00:05:05 <hpaste> drbean pasted “cabal error: Distribution.PackageDescription does not export condBenchmarks.” at http://hpaste.org/80489
00:06:20 <nushio3> I'd like something like TypeEq x y b in Data.HList.FakePrelude, for more wider use.
00:06:46 <nushio3> HList first seemed to be promising, but it operates on very limited set of types right now...
00:07:12 <drbean> Is the cabal not exporting of condBenchmarks the reason ghc-mod fails to build?
00:10:14 <Saizan> nushio3: you can write TypeEq as a type family in ghc HEAD
00:10:58 <nushio3> Saisan: Thank you, that's interesting!
00:11:06 <nushio3> Saizan: Thank you, that's interesting!
00:11:16 <nushio3> is there a sample for that?
00:12:10 <nushio3> then, maybe i'll prepare some mock-up for the moment, and I'll wait for ghc7.8 release.
00:12:34 <drbean> Looks like ghc-mod needs to update its cabal requirement.
00:13:36 <Saizan> nushio3: http://typesandkinds.wordpress.com/2012/12/22/ordered-overlapping-type-family-instances/
00:14:34 <nushio3> Saizan: Thank you! I'll read.
00:15:32 <nushio3> ah, "else"for overlapping instances. This will be very useful.
00:18:18 <Saizan> nushio3: Equals a b ~ True doesn't give you a ~ b by itself though, i think
00:20:37 <nushio3> Saizan: Well, what I needed, is to put several types into Data.HList.Record and look them up.
00:20:58 <nushio3> now i'm quite sure that'll be made easy with 7.8.1
00:21:38 <nushio3> so for now, I'll defne TypeEq instances manually and pairwise, and wait 7.8.1 for future extension
00:21:54 <nushio3> also Oleg and folks are working to improve HList
00:22:54 <nushio3> Thanks again!
00:33:47 * hackagebot gitlib 0.5.5 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.5.5 (JohnWiegley)
00:38:44 <drbean> I have to put ~/.cabal/bin in my PATH myself?
00:38:47 * hackagebot angel 0.3.4 - Process management and supervision daemon  http://hackage.haskell.org/package/angel-0.3.4 (JamieTurner)
00:39:28 <pnielsen> drbean: yes
00:39:58 <pnielsen> ./profile -> export PATH=$PATH:/home/foo/.cabal/bin
00:40:09 <mauke> you don't need "export"
00:40:16 <pnielsen> yes you do
00:40:19 <mauke> no
00:42:50 <merijn> PATH is already exported, you don't need to export exported variables
00:43:07 <mauke> also: what if it wasn't already exported?
00:43:12 <pnielsen> fair enough
00:43:16 <pnielsen> mauke: then you would need it
00:43:19 <mauke> pnielsen: no
00:43:20 <merijn> mauke: Depends on how you start your shell
00:43:24 <pnielsen> yes you would
00:43:26 <pnielsen> if it's bash, anyway
00:43:27 <mauke> pnielsen: no
00:43:32 <pnielsen> *sigh*
00:43:52 <pnielsen> I literally have 10 vars, 5 of them without export, and 5 with. echo is blank for the 5 former and complete for the remainder
00:43:55 <merijn> mauke: my .profile starts tmux, which in turn starts bash. unexported variables don't inherit to children, so tmux and bash wouldn't see the non-exported variables
00:44:02 <mauke> there is no reason for you to change the 'exported' status of a variable if you just want to set it
00:44:14 <pnielsen> mauke: if it WASN'T exported
00:44:53 <mauke> merijn: I consider that setup to be The Real WTF(tm)
00:44:58 <merijn> mauke: Why?
00:45:16 <mauke> because .profile is supposed to be read by all shells, including non-interactive ones
00:45:24 <merijn> No it's not
00:45:34 <mauke> you're right.
00:45:50 <mauke> I am completely wrong, dammit
00:46:07 <pnielsen> yes you are
00:46:16 <pnielsen> no cookie because you were so cocksure
00:46:29 <merijn> .bashrc and friends will also be read by non-interactive shells, and some perverse individuals symlink the two to eachother, but that's their problem
00:46:54 <mauke> pnielsen: my retraction only applies to .profile and login shells
00:47:20 <blaenk> http://en.wikibooks.org/wiki/Haskell/Understanding_monads/IO
00:47:22 <blaenk> "The Haskell compiler needs to apply the function only four times"
00:47:35 <blaenk> can anyone please clarify this for me? how is it that it knows it only has to do it four times?
00:47:48 <pnielsen> mauke: no it doesn't. You need export in .profile with bash, at least under Ubuntu
00:48:04 <merijn> blaenk: I think that's just a blatant lie
00:48:07 <mauke> pnielsen: for doing what?
00:48:19 <blaenk> merijn: haha, really? oh ok
00:48:28 <merijn> blaenk: In theory, GHC could do that. In practice I don't think it usually does
00:48:30 <pnielsen> mauke: for exporting the variable. I have foo="foo" and export bar="bar". Only bar is not blank. Can't explain that.
00:48:42 <pnielsen> I do source .profile, and foo is foo
00:48:43 <blaenk> merijn: ah okay, thanks
00:48:44 <mauke> pnielsen: ... yes, you need export for exporting
00:48:52 <pnielsen> mauke: you were refuting this before
00:48:57 <mauke> no, I wasn't
00:49:08 <pnielsen> <mauke> also: what if it wasn't already exported?
00:49:12 <pnielsen> <pnielsen> mauke: then you would need it
00:49:15 <pnielsen> <mauke> pnielsen: no
00:49:23 <mauke> exactly
00:49:34 <pnielsen> are you trolling?
00:49:37 <mauke> no
00:49:51 <pnielsen> whatever, don't have time for this
00:49:54 <mauke> you're making weird assumptions
00:50:00 <merijn> blaenk: i.e. the reasoning why GHC can do that and (for example) gcc can't is correct (GHC knows the function is pure and all that), but I don't think  GHC analyses how many duplicate elements a list has and then optimises based on that. That's not even possible for lists read/constructed at runtime
00:50:03 <pnielsen> you said if it wasn't exported, do you need export in .profile
00:50:05 <pnielsen> I said you do, you said no
00:50:12 <mauke> I didn't say "... for exporintg"
00:50:16 <mauke> *exporting
00:50:26 <elliott> blaenk: If that's the wiki page I think it is please don't read it.
00:50:39 <blaenk> merijn: yeah that was mainly my question, how it can know or whether it checks if there's duplicates etc
00:50:53 <blaenk> elliott: oh ok, so the wikibooks book isn't a good source?
00:51:00 <elliott> Oh, it's not the one I was thinking of. This one looks only slightly wrong.
00:51:01 <merijn> Also, so far I don't like that wikipage
00:51:08 <elliott> blaenk: Some parts of the wikibook are better than others.
00:51:28 <merijn> blaenk: The general recommended source for beginners is Learn You a Haskell (also freely available online)
00:51:33 <elliott> This one seems to commit the IO-monad-is-about-ordering-evaluation sin, but not the others.
00:51:37 <merijn> That and Real World Haskell
00:51:41 <blaenk> elliott: got it, have you seen and can comment on the laziness one? http://en.wikibooks.org/wiki/Haskell/Laziness I used that to get a (I think) better understanding of lazy evaluation
00:52:09 <blaenk> merijn: thanks yeah, I was using that and real world haskell, I just figured I'd check the wikibooks out for more in-depth information, guess not then
00:52:27 <elliott> that page looks good at a glance
00:52:35 <blaenk> cool
00:52:47 <elliott> Better than the average explanation of laziness anyway :)
00:52:57 <pnielsen> mauke: http://hpaste.org/80490
00:53:13 <pnielsen> there is no ambiguity. You claimed you didn't have to include export to export a variable in .profile. You do.
00:53:20 <blaenk> yeah laziness was bothering me a lot, it was generally hand waived everywhere I read (oh thanks to laziness blah blah) and I wanted to understand it a little better
00:53:24 <merijn> blaenk: Minor nitpick is that it says "laziness is how you implement non-strictness", but usually the two terms are used for different things
00:53:26 <pnielsen> anyway, done with this nonsenes for real now
00:53:59 <mauke> pnielsen: I don't understand your point
00:54:03 <mauke> that's just a chat log
00:54:04 <merijn> blaenk: Usually laziness means "expressions are *never* evaluated more than once", whereas non-strict means "expressions are only evaluated when necessary"
00:54:12 <pnielsen> mauke: I just have to assume you are trolling
00:54:15 <elliott> merijn: ?
00:54:24 <elliott> Non-strictness is about semantics; laziness is a non-strict evaluation strategy.
00:54:25 <pnielsen> I can't believe you really don't understand the meaning of those sentences
00:54:28 <mauke> pnielsen: or you could explain the contradiction you see because I don't see it
00:54:39 <Saizan> laziness is a way to implement non-strictness
00:55:05 <merijn> elliott: Hmm, maybe I've been taught the wrong terminology myself >.>
00:55:32 <pnielsen> mauke: you said "what if it [an env var] wasn't already exported?". I said "then you would need it [export]". You said "no". You DO need "export".
00:55:35 <frerich> Are there other ways to implement non-strictness than lazyness?
00:55:38 <elliott> merijn: Call by name is an example of another non-strict evaluation strategy
00:55:43 <frerich> Ah...
00:55:54 <elliott> which is just laziness (call by need) but you re-evaluate (no sharing)
00:55:58 <mauke> pnielsen: that does not follow
00:56:00 <elliott> pretty terrible in practice :)
00:56:00 <mauke> like, at all
00:56:33 <pnielsen> merijn: does this not make sense?
00:56:47 <mauke> "what if this sandwich doesn't come with ketchup?"  "then you would need extra ketchup"  "no"
00:56:57 <mauke> I don't like ketchup
00:56:59 <frerich> elliott: Hm thanks, that's a really good example. It seems really simple to distinguish the two things (lazyness and strictness) now.
00:57:31 <elliott> frerich: In practice Haskellers often mix up the terms and use "laziness" when they mean "non-strict" and vice versa :(
00:58:19 <pnielsen> okay, this is my last attempt. you said, "what if [an exported env var] wasn't already exported? [meaning that an export statement did not precede it]. I said that "then you would need a leading export statement [in order to export it]. You said no, but in fact you do.
00:58:23 <Saizan> pnielsen: you are assuming you want PATH to be exported, mauke doesn't
00:58:26 <elliott> Non-strictness just means you can write non-strict functions (functions f such that (f undefined) isn't undefined) and they'll work properly.
00:58:47 <elliott> Laziness is an implementation strategy that gives non-strictness and also the operational nicety of sharing.
00:58:47 <frerich> elliott: That would certainly explain my confusion, because at some point I thought the two are synonymous but then again somebody said they are not - at which point a long rant emerged and I lost track of things. :-)
00:59:11 <elliott> frerich: generally you won't need to care about the difference, since laziness is the only way we do non-strictness in practice
00:59:18 <srhb> frerich: Don't worry, if you let the channel cool for a few hours you can set off the exact same rant and try to follow it agian. :P
00:59:28 <frerich> srhb: Haha that's so true! :-)
01:00:15 <Saizan> frerich: it's mostly a type error to say non-strict in place of lazyness or vice versa, because one is about denotational semantics and the other is operational
01:00:28 <blaenk> srhb: haha
01:01:33 <mauke> pnielsen: the "... in order to export it" part was only in your head
01:01:49 <pnielsen> we were talking about exporting env vars. rofl.
01:01:53 <mauke> yes
01:02:02 <mauke> or not exporting env vars, in this case
01:02:21 <snowylike> has someone written a scraper or crawler in haskell yet?
01:02:50 <merijn> snowylike: I started working on one at some point, and I refuse to believe no one else has done that\
01:02:51 <Saizan> mauke: i think you could've made more explicit sooner that there was such a hidden assumption in pnielsen's reasoning which you didn't accept
01:03:09 <snowylike> merijin: i haven't found one atleast
01:03:13 <mauke> Saizan: I wasn't sure that was what's going on
01:03:13 <snowylike> that's why i ask
01:03:23 <donri> snowylike: http://adit.io/posts/2012-03-10-building_a_concurrent_web_scraper_with_haskell.html maybe?
01:03:38 <Saizan> mauke: it's worth mentioning if you suspect it might be
01:03:52 <merijn> snowylike: Anything specific you're looking for?
01:03:53 <mauke> Saizan: to me it looked like a non-sequitur, not reasoning-with-hidden-assumption. I was just confused
01:03:55 <snowylike> donri: thanks, i'll take a look at it
01:04:27 <pnielsen> mauke, Saizan: anyway, sorry. This was really silly. Good night :)
01:04:28 <snowylike> merijin: not really, just some very diffuse ideas i can't get to solidify yet
01:04:31 <merijn> http-conduit + html-conduit/xml-conduit makes a good basis for writing a scraper
01:05:03 * merijn is betting $10 snowylike is a native english speaker
01:05:16 <snowylike> well, no
01:05:19 <snowylike> native german
01:05:28 <merijn> That's counter intuitive
01:05:32 <snowylike> why?
01:05:43 <merijn> First time I see a German speaker butcher a ij digraph :p
01:06:05 <mauke> merĳn
01:06:08 <merijn> It's normally the silly Americans or British that get confused :p
01:06:16 <snowylike> well
01:06:19 <snowylike> okay
01:06:21 <Saizan> mauke: that's what non-sequiturs usually are ime, but i guess it's not always easy to imagine what the assumption could be
01:06:30 <snowylike> 80% of what i read is written in english
01:06:43 <snowylike> and it's been that way for about 5 or 6 years, so
01:06:52 <merijn> mauke: Props, I don't even know there was a unicode character for that :p
01:07:14 <merijn> Now I need to update my mail address to make everyone's life impossible...
01:08:47 * hackagebot RefSerialize 0.3.1.0 - Write to and read from ByteStrings maintaining internal memory references  http://hackage.haskell.org/package/RefSerialize-0.3.1.0 (AlbertoCorona)
01:08:49 * hackagebot Workflow 0.8.0.1 - Monad transformer for thread state persistence and workflow patterns  http://hackage.haskell.org/package/Workflow-0.8.0.1 (AlbertoCorona)
01:09:09 <mauke> http://dl.dropbox.com/u/41152078/unicode.html?q=latin+ligature
01:09:40 <mauke> (this isn't even my ARABIC LETTER MEEM FINAL FORM)
01:11:59 <merijn> oh! Now I can use proper ﬀ and ﬁ ligatures in typing!
01:12:43 <snowylike> i like it when people use Unicode
01:13:28 <snowylike> because then all i can see are little boxes
01:13:37 <drbean> I installed ghc-mod-1.11.1, which installs with Cabal-1.10.2.0.
01:13:41 <mauke> I'm using unicode right now
01:13:59 <snowylike> okay, not only boxes
01:14:25 <snowylike> damn my tendency for unnecessary hyperboles
01:15:41 <mauke> and those "boxes" are called pixels :-)
01:20:26 * osfameron hates fl ligatures
01:21:00 <osfameron> they're not pretty *enough* to make it worth all those times when they don't render on e-reader etc.
01:21:57 <t7> if its not in dejavu mono then it aint acceptable
01:29:41 <epta> Is there a library for drawing graphs?
01:33:47 <srhb> epta: Won't dot and graphviz do it for you? It's the standard solution anywhere, I think.
01:34:43 <osfameron> unless you mean charts
01:35:17 <srhb> Then there's plot I guess.
01:36:27 <yitz> diagrams
01:36:56 <srhb> epta: What do you need in your graphs?
01:37:23 <epta> srhb: actually I'm looking for some complete solution like getting pair of connected nodes and return image with this graph
01:37:28 <yitz> (but that's a bit low-level, you need to build graphs on top of it)
01:38:42 <srhb> epta: That's a little vague, but I don't think you'll find a combined solution.
01:42:20 <Lethalman> :t (&&&)
01:42:21 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
01:42:41 <Lethalman> :t arr id
01:42:42 <lambdabot> Arrow a => a c c
01:43:39 <Lethalman> :t arr id >>> arr id
01:43:40 <lambdabot> Arrow cat => cat c c
01:44:14 <Lethalman> :t arr (\x y -> x) >>> arr (\x y -> y)
01:44:16 <lambdabot> Arrow cat => cat a (t -> t)
01:45:13 <Lethalman> :t (\x y -> x) >>> (\x y -> y)
01:45:15 <lambdabot> a -> t -> t
01:48:15 <allsystemsarego> @hackage json
01:48:15 <lambdabot> http://hackage.haskell.org/package/json
01:48:24 <Nereid> @hackage aeson
01:48:24 <lambdabot> http://hackage.haskell.org/package/aeson
01:48:43 <mauke> @hackage reflection
01:48:43 <lambdabot> http://hackage.haskell.org/package/reflection
01:48:49 * hackagebot free-game 0.3.1.0 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.1.0 (FumiakiKinoshita)
01:50:05 <allsystemsarego> So aeson is a better choice than json?
01:52:37 <bitonic> allsystemsarego: aeson is faster, and (because) it works with Text
01:52:51 <mauke> @hackage arson
01:52:51 <lambdabot> http://hackage.haskell.org/package/arson
01:55:56 <srhb> Huh? Aeson, right?
01:55:57 <allsystemsarego> @hackage yaml
01:55:57 <lambdabot> http://hackage.haskell.org/package/yaml
01:56:18 <Nereid> @hackage ..
01:56:18 <lambdabot> http://hackage.haskell.org/package/..
01:56:44 <ozataman> does anyone know of a decent enough concurrent map or hashmap implementation in any package?
01:57:37 <Nereid> @hackage unordered-containers
01:57:37 <lambdabot> http://hackage.haskell.org/package/unordered-containers
01:57:47 <Nereid> concurrent?
01:58:22 <srhb> ozataman: Any data structure can be made concurrent in Haskell by the use of MVars, I guess.
01:58:35 <ozataman> srhb: for sure, I just wanted to see if there's a way around rolling my own
01:58:41 <bitonic> ozataman: I don’t think it exists yet.  there was a GSOC for lock-free concurrent data structures
01:58:43 <bitonic> iirc
01:58:50 * hackagebot free-game 0.3.1.1 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.1.1 (FumiakiKinoshita)
01:58:53 <srhb> It's a bit cheating though :P
01:59:00 <ozataman> guess I'll have to roll my own using stm
01:59:04 <bitonic> well of course you can stick everything into a MVar and access it one-by-one but that’s inconvenient
01:59:29 <ozataman> yeah, I have done TVar (Map k (TVar a))) before
02:00:10 <ozataman> I bet there are implementations buried in various packages
02:00:24 <Lethalman> I see many times that functions like fold, map, scan, length ecc. are rewritten in packages with their own implementations
02:00:36 <Lethalman> is that because those are not defined in any class?
02:00:37 <srhb> No doubt. You should probably release your awesome concurrent Map. ;)
02:01:41 <srhb> Lethalman: There's a foldable class that can be used, in that case each package would make an instance for their data structure.
02:01:52 <Nereid> there's also lens.
02:01:57 <quicksilver> Lethalman: even if they were defined in the class they would still be rewritten in packages with their own implementations
02:02:07 <quicksilver> that is, after all, the point of a class.. that things have their own implementatiosn.
02:02:36 <Lethalman> quicksilver, true, but aren't classes made for that after all?
02:02:40 <quicksilver> no.
02:02:45 <quicksilver> classes are made for overloading.
02:03:10 <quicksilver> so the question is, do you ever want to write "length" and have it automatically deduce which type you wanted?
02:03:15 <Lethalman> srhb, right, what's the main reason why it isn't that way for all packages? Foldable came later?
02:03:26 <quicksilver> in fact, fold + length are basically provided by Foldable
02:03:30 <quicksilver> and map is provided by Functor
02:03:43 <srhb> The fact that you see many foldrs that are not Foldable instances is historical, Prelude isn't very generalized. Some people think it should not be, in order to not confuse newbies.
02:03:44 <quicksilver> not sure about scan, you need traversable for that.
02:04:11 <Lethalman> srhb, ah, and is that limiting somehow?
02:04:19 <srhb> Kind of. It's less general.
02:04:39 <Lethalman> the fact is that you can't write (Foldable f) and expect something not Foldable to work, you have to rewrite the function for that specific type, right?
02:05:01 <quicksilver> or you could just write the instance.
02:05:10 <Lethalman> quicksilver, right
02:05:20 <quicksilver> in practice it doesn't seem to be a very common problem (wishing somethign was an instance of Foldable)
02:05:24 <srhb> Lethalman: It's no difference from the fact that fmap only works on things that have functor instances (ie. a definition of fmap)
02:05:31 <Lethalman> quicksilver, just curious
02:05:35 <jeltsch> karma jeltsch
02:06:11 <jeltsch> ??karma jeltsch
02:06:22 <jeltsch> preflex: karma jeltsch
02:06:28 <srhb> Preflex is gone.
02:06:30 <Jafet> @karma- jeltsch
02:06:30 <lambdabot> jeltsch's karma lowered to -1.
02:06:36 <Nereid> and for the things that aren't/can't be Foldable, you can still write your own Fold. :p
02:06:45 <Nereid> or (better) Traversal
02:06:56 <srhb> Isn't Traversable just Foldable and Applicative?
02:07:10 <jeltsch> Jafet: What was your reason for issuing this command?
02:07:12 <Nereid> I'm talking about lens.
02:07:15 <srhb> Ah.
02:07:36 <srhb> @karma+ jeltsch -- happy? :P
02:07:36 <lambdabot> jeltsch's karma raised to 0.
02:07:39 <Nereid> you can't define a Fold without depending on lens.
02:07:42 <Nereid> but you can define a Traversal.
02:08:17 <srhb> Nereid: can you link an example? I'm suddenly unsure of what a Traversal is.
02:08:27 <jeltsch> srhb: As far as my “karma” is concerned: yes. I still wonder what Jafets reason for lowering it was.
02:08:29 <Nereid> traverse is a Traversal.
02:08:46 <Nereid> :t traverse
02:08:47 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:08:53 <srhb> jeltsch: Showing you your karma and command.
02:09:15 <jeltsch> srhb: But “-” doesn’t just show it, right? It decrements it.
02:09:21 <Nereid> > over traverse (+1) [1..5]
02:09:22 <srhb> jeltsch: Right.
02:09:23 <lambdabot>   [2,3,4,5,6]
02:09:23 <jeltsch> Is there a way to show it?
02:09:28 <srhb> @karma jeltsch
02:09:28 <lambdabot> jeltsch has a karma of 0
02:09:33 <Nereid> but some things that are not traverse are also Traversals.
02:09:35 <jeltsch> Ah, okay. Thanks
02:09:35 <Nereid> :t both
02:09:36 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
02:09:40 <Nereid> > over both (+1) (1,2)
02:09:42 <lambdabot>   (2,3)
02:10:02 <jeltsch> srhb: Seems that http://www.haskell.org/haskellwiki/IRC_channel needs updating (as it mentions preflex and doesn’t mention Lambdabot’s karma command).
02:10:10 <srhb> jeltsch: Yep.
02:10:22 <srhb> :t over
02:10:23 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
02:10:28 <srhb> :t over both
02:10:29 <lambdabot> (a -> b) -> (a, a) -> (b, b)
02:10:32 <srhb> Huh..
02:10:35 <srhb> Okay.
02:10:55 <elliott> over just sets f = Identity, more or less.
02:11:00 <elliott> (a -> f b) -> (a, a) -> f (b, b)
02:11:03 <elliott> get rid of the f:
02:11:06 <elliott> (a -> b) -> (a, a) -> (b, b)
02:11:21 <Jafet> > runIdentity $ both (Identity . succ) (1, 2)
02:11:23 <lambdabot>   (2,3)
02:11:27 <Nereid> srhb: time for you to read about lens, I guess.
02:11:28 <Nereid> @where lens
02:11:28 <lambdabot> http://lens.github.com/ https://github.com/ekmett/lens
02:12:46 <srhb> Nereid: *growl* ;)
02:12:53 <Nereid> :)
02:12:59 <Nereid> oh.
02:13:17 <Nereid> here's that talk about lens. http://youtu.be/cefnmjtAolY?hd=1
02:13:34 <srhb> Yep, watched it yesterday. I need to watch it again.
02:13:38 <Nereid> ah.
02:13:50 <srhb> But I didn't know lens.github.com -- that looks very nice.
02:14:17 * Lethalman let's watch that video
02:14:29 <Lethalman> 2 hours \o/
02:14:58 <srhb> It's quite good. The sound is slightly annoying at times, but it works out.
02:14:58 <Lethalman> :t both
02:15:00 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
02:15:33 <QinGW> it is pity, YouTube can not reach.
02:16:04 <Lethalman> what audience is that video for?
02:16:40 <Nereid> general haskell audience I guess.
02:16:47 <Lethalman> I know what monads, applicatives and arrows are but I'm not very experienced with them
02:17:02 <liyang> Lethalman: living, breathing, and preferably sentient ones.
02:17:12 <Nereid> I don't think you have to worry about those too much.
02:17:31 <Nereid> helps to be familiar with guys like Functor, Foldable and Traversable
02:18:00 <srhb> But it's not necessary. The types are easy to decode in the parts he uses to lead up to each lensy thingamabob
02:20:14 <liyang> It dives deep fast, but in any case, start watching and see how far you get. We're here to help.
02:20:40 <Lethalman> yes, starting now :)
02:22:21 <Nereid> I think I prefer the version of the lens laws that are the setter laws and view l . over l f = f . view l
02:24:52 <osa1> can anyone help me http://hpaste.org/80492 how can I run this st action: `run someAFun` ?
02:25:47 <mauke> :t runST
02:25:48 <lambdabot> (forall s. ST s a) -> a
02:26:11 <Nereid> :t runStateT
02:26:12 <lambdabot> StateT s m a -> s -> m (a, s)
02:27:00 <mauke> why is that not a ReaderT?
02:27:33 <osa1> mauke: there's no reason, I'm just making some tests for learning purposes
02:27:59 <Nereid> I don't think that code can work.
02:28:04 <osa1> Nereid: why ?
02:28:14 <Nereid> where are you going to get the STRef from?
02:28:35 <Nereid> hmm.
02:28:40 <Nereid> maybe it can.
02:28:47 <Nereid> :t newSTRef
02:28:48 <lambdabot> a -> ST s (STRef s a)
02:28:57 <osa1> Nereid: `run someAFun` is well typed
02:29:07 <Nereid> sure, that's not the problem I was thinking of.
02:29:38 <osa1> it's type is `ST s (AState s)` I think I'm missing a forall s. here
02:29:42 <osa1> :t runST
02:29:43 <lambdabot> (forall s. ST s a) -> a
02:30:00 <osa1> otherwise it's same with runST's parameter
02:30:02 <Nereid> :t newSTRef ?x >>= runStateT ?m
02:30:03 <lambdabot> (?x::a, ?m::StateT (STRef s a) (ST s) a1) => ST s (a1, STRef s a)
02:30:28 <Nereid> ok, sure.
02:30:30 <Nereid> this would work.
02:31:05 <osa1> what would work ?
02:31:43 <Nereid> what I just wrote.
02:32:06 <Nereid> inside ST, make your STRef and then use runStateT or whatever.
02:32:36 <osa1> I'm already doing that in `run` ?
02:32:51 <Nereid> right.
02:33:08 <Nereid> should work then, just use runST.
02:33:16 <osa1> Nereid: the problem is `run someAFun` works but `runST $ run someAFUn` doesn't
02:33:40 <Nereid> what about runST (run someAFun)?
02:33:54 <osa1> Nereid: I think I'm missing a forall: `run someAFun :: ST s (AState s)` `runST :: (forall s. ST s a) -> a`
02:34:05 <Nereid> oh.
02:34:05 <mauke> no, you're trying to extract a STRef out of ST
02:34:07 <Nereid> yeah that can't work.
02:34:15 <osa1> mauke: wait
02:34:24 <Nereid> you can't leake the s out.
02:34:27 <Nereid> leak.
02:34:44 <osa1> hmm
02:34:53 <Nereid> to run a ST s a, the a can't have anything to do with s.
02:35:28 <Nereid> so if you could make it like a ST s Int, then that would work.
02:36:22 <Nereid> which means you'd have to modify run. (and its type.)
02:36:49 <Nereid> I should probably read the code properly before answering.
02:37:18 <Nereid> how come AState isn't a newtype (or perhaps even a type synonym)?
02:38:06 <osa1> Nereid: I can make it so, I'm just testing stuff
02:38:14 <Nereid> sure.
02:38:21 <Nereid> how come I'm not in bed? :)
02:38:32 <Nereid> bye.
02:38:39 <osa1> bye and thanks
02:39:02 <osa1> I should leave for 10-15 minutes and I still don't understand how can I get that int out of ST monad and return
02:39:05 <osa1> brb
02:39:19 <Nereid> how about readSTRef.
02:51:06 <HugoDaniel> hi
02:51:45 <fmap> hi
03:02:36 <allsystemsarego> poll: Data.Graph vs. FGL - pros? cons?
03:09:28 <mm_freak_> for some reason happstack still feels like the most practical web framework
03:09:49 <bitonic> mm_freak_: maybe it is?
03:10:08 <srhb> Yeah, it's so easy to dive into.
03:10:17 <srhb> I do hope Yesod gets more approachable given time. I love the safety it gives you.
03:10:34 <saeidw> allsystemsarego, I used Data.Graph a while ago and I found it to be simpler and I think more up-to-date than FGL
03:10:37 <srhb> allsystemsarego: I'd use Data.Graph if it does what I need.
03:10:40 <mm_freak_> srhb: i don't see any additional safety except for compile-time URL overlap matching
03:10:49 <srhb> mm_freak_: Right, but that's a pretty big deal.
03:11:38 <mm_freak_> srhb: the overlap matching?  i don't think i've ever run into serious issues with overlapping URLs
03:11:46 <srhb> allsystemsarego: Data.Graphs is simpler than FGL, but also simpler than FGL. :-)
03:11:49 <srhb> Graph*
03:12:06 <srhb> mm_freak_: Then I guess you're all out of cons for Happstack. :)
03:12:47 <mm_freak_> easy integration of persistent is probably a plus for yesod, but honestly i didn't find persistent practical to begin with =)
03:13:00 <mm_freak_> even in my yesod times i used acid-state or HDBC
03:13:10 <Lethalman> allsystemsarego, Data.Graph doesn't have labels
03:13:39 <Lethalman> so you have to keep a map from Vertex -> label and label -> Vertex manually
03:13:41 <srhb> mm_freak_: Persistent scares me, the TH is a bit too deep for me. I think acid-state is somewhat easier to deal with in my mind.
03:14:13 <saeidw> I remember having a Haskell "aha!" moment reading the 4-line implementation of dijkstra's algorithm in Data.Graph :)
03:14:20 <mm_freak_> that's just because it's opaque…  that would be fine, if you wouldn't hit the ceiling so quickly
03:14:43 <saeidw> also, GraphViz integration!
03:14:50 <srhb> mm_freak_: What do you mean by hitting the ceiling?
03:15:05 <srhb> mm_freak_: But yes, it is indeed because it's opaque. And because TH is scary.
03:15:35 <mm_freak_> srhb: when the opaque interface gets in your way, like when you need to do something the opaque interface doesn't provide or even allow
03:15:42 <srhb> Ah, yes.
03:16:31 <Jafet> I thought that was hitting the stage floor
03:16:33 <mm_freak_> TH isn't that scary though…  i've been thankful for its existence a number of times
03:17:17 <mm_freak_> just imagine having to write SafeCopy instances or lenses by hand =)
03:17:22 <srhb> I think it's a little scary. It doesn't look enough like Haskell, and I don't know if I'm doing something completely unsafe.
03:17:28 <srhb> mm_freak_: Yes, I know. That would be very annoying.
03:17:42 <srhb> I just wish there were a better solution, but I have no idea if it's in any way possible.
03:18:23 <mm_freak_> i think the reflection library proves that this is possible, but you would have to do all the computation at runtime
03:18:45 <mm_freak_> and it would depend on other ugly things like Typeable and Data
03:18:57 <srhb> Isn't Typeable getting less ugly?
03:19:03 <srhb> I thought some things were going on with it.
03:19:39 <mm_freak_> not that i'm aware of…  also Typeable itself isn't that ugly except for its fixed rank
03:20:19 <srhb> Meh. This topic gets too deep for me very quickly. Most of my complaints are "this feels dangerous" and "I don't know what's going on"
03:20:24 <srhb> So not very useful criticism.
03:22:18 <elliott> mm_freak_: not considering snap?
03:23:28 <Jafet> reflection doesn't have Data constraint (any more)
03:24:35 <srhb> Is Data bad? I don't remember hearing about it.
03:24:54 <Jafet> Data reflects the representation of data types into haskell
03:25:21 <Jafet> It's more of a "guns kill people" thing
03:26:09 <srhb> I don't like things that allow me to shoot people without a big fat unsafe* stacked in front.
03:27:02 <Jafet> Data is implemented in plain haskell
03:27:29 <srhb> What's scary about it then?
03:28:16 <Jafet> Nothing. It just makes some abuses more convenient
03:28:39 <srhb> *boggle*
03:28:42 <srhb> Okay.
03:28:52 <Jafet> But Data by itself is type-safe
03:28:55 <srhb> I spend too little time on the type level to understand this, probably.
03:29:28 <elliott> reflection doesn't have Data constraint?
03:29:35 <dextr> hi
03:29:37 <elliott> What does "reflection" refer to there?
03:29:49 <Jafet> Does it?
03:30:06 * elliott doesn't know what you mean by "reflection"; it's a pretty heavily overloaded term.
03:30:12 <Jafet> @hackage reflection
03:30:12 <lambdabot> http://hackage.haskell.org/package/reflection
03:30:35 <elliott> AFAIK no version of that reflection trick has involved Data
03:30:45 <Jafet> Okay
03:30:50 <elliott> both the paper and the package have always been able to reflect arbitrary vlaues
03:31:01 <mm_freak_> elliott: i've been using snap before
03:31:31 <Jafet> I thought the paper had to manually reflect integers by encoding them in binary
03:31:32 <dextr> how do i perform pattern-matching for the Show class, for a tree-like structure? lines 22-24 in http://ideone.com/7asAY1 were my first attempt at it, but huggs says No member "==" in class "Show"
03:31:43 <Jafet> (aka Data)
03:31:48 <elliott> ?
03:31:57 <elliott> I don't see what that has to do with Data, but the paper uses the trick of turning StablePtrs into integers.
03:32:09 <elliott> and you can make a StablePtr for any Haskell value
03:32:35 <Jafet> Clearly I should actually read the paper.
03:32:36 <opqdonut> dextr: your syntax is wrong
03:32:52 <opqdonut> dextr: you should have something like: show (Add a b) = show a ++ " + " ++ show b
03:33:06 <dextr> oh, i see :x
03:33:08 <dextr> thanks
03:33:14 <opqdonut> just normal pattern matching
03:33:16 <mm_freak_> 'reflection' in this context just means that you can derive class instances at run-time
03:33:24 <opqdonut> write the pattern in place of the argument you are trying to match
03:33:27 <opqdonut> no == needed
03:33:36 <opqdonut> now it looks like you're trying to define an operator ==
03:33:40 <mm_freak_> in other words, you could /compute/ the SafeCopy instance when the application starts
03:33:54 * hackagebot crf-chain1-constrained 0.1.2 - First-order, constrained, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-constrained-0.1.2 (JakubWaszczuk)
03:33:54 <mm_freak_> but that requires a Data constraint
03:34:20 <dextr> originally i only had (Value a) = show a, but that failed with "a" multiply defined, so i thought i needed to be more explicit
03:34:45 <opqdonut> dextr: you need to mention the name of the function you are defining, not just the argument
03:35:03 <opqdonut> thus "show (Value a) = show a"
03:35:33 <opqdonut> definitions inside a type class instance are just like definitions of standalone functions
03:43:54 * hackagebot crf-chain2-generic 0.3.0 - Second-order, generic, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-generic-0.3.0 (JakubWaszczuk)
03:43:56 * hackagebot concraft 0.3.0 - Morphosyntactic tagging tool based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.3.0 (JakubWaszczuk)
03:47:38 <dextr> what does "Cannot justify constraints in explicitly typed binding" mean?
03:48:31 <osa1> so IO is not just ST RealWord, right ? I'm wondering if I can call ST functions inside IO functions (by making s variableRealWorld)
03:49:07 <Saizan> dextr: not sure, but if you put the offending code somwhere we might still help
03:49:19 <johnw> edwardk: ping
03:49:20 <Saizan> osa1: i think there's a stToIO function somewhere
03:49:37 <simpson> :t stToIO -- osa1
03:49:37 <dextr> ok, one sec .. but the code is relatively big (it's the i/o part) :x
03:49:38 <lambdabot> Not in scope: `stToIO'
03:49:45 <simpson> Oh, it's not in lambdabot.
03:50:03 <simpson> You can "lift" any ST action to IO.
03:50:53 <osa1> simpson: by stToIO ?
03:51:06 <sepp2k> dextr: I think that's the message that hugs gives if one of your type variables needs to have constraint (like Show a or Num a for example), but you didn't give it one in your explicit type signature.
03:51:11 <simpson> osa1: Yeah.
03:51:39 <simpson> osa1: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-ST-Lazy.html#v:stToIO
03:51:40 <aleator> I need a fast, strict and dense concatenable structure. Which one should I use? Is Data.Sequence still good?
03:53:03 <dextr> http://ideone.com/ufWbEz - the constraint is there i believe, the offending line is the first one (according to hugs)
03:53:50 <sepp2k> dextr: What's the constraint that Hugs says is missing?
03:54:14 <dextr> http://ideone.com/ZLGXdP <- this is the message
03:55:01 <dextr> http://ideone.com/pVx0AX <- this is what ghci (with -XDatatypeContexts) says
03:59:00 <sepp2k> dextr: Assuming the error is actually on line 12, 13 or 14, I think the problem is that you don't give a type to val, so val's type is just "b" and doesn't have a Group constraint.
03:59:09 <johnw> aleator: do you mean that concatenating should also be fast?
04:00:39 <dextr> val is the value that is read in from the console - that does not need to be a Group
04:00:55 <dextr> (in fact it'll be a Double)
04:01:18 <sepp2k> dextr: Of course it does. You try to put it inside a Value.
04:01:35 <sepp2k> And according to your own definition Values can only contain types that are Groups
04:02:03 <dextr> oh
04:02:31 <dextr> so i need to change line 32 to Value Double?
04:03:35 <sepp2k> Maybe, but then how would an  Expr Foo  be different from an  Expr Bar?
04:03:51 <seed419> it's time to learn me a haskell :l
04:04:06 <dextr> what do you men sepp2k ?
04:04:13 <sepp2k> Because if you change it to Double on line 32, there won't actually be any as contained anywhere inside an Expr.
04:04:50 <dextr> well, an expression is a tree, and the leafs are concrete values
04:04:56 <dextr> is that wrong?
04:05:22 <sepp2k> No, but if the leafs are the same type of value no matter which type argument you chose, then why have a type argument at all?
04:06:13 <sepp2k> Or asked differently: How will the value of a affect your Expr?
04:07:23 <dextr> oh, ok - yes, leafs can actually of multiple types
04:07:36 <dextr> but as i first step i wanted to solve this for just one type :x
04:08:10 <sepp2k> Then you need to remove the type parameter. Otherwise you're going to end up with lots of ambiguous type variable errors.
04:09:05 <sepp2k> Of course that also means that you can get of your Group typeclass altogether.
04:09:34 <dextr> hm.. ok then, lets try it all at once (that is without removing the type parameter) ^^
04:10:24 <dextr> how would i express in line 11 that val may only be of a specific type? casting? val::Double?
04:10:35 <sepp2k> Yes.
04:10:45 <sepp2k> You also need to add an instance Group Double.
04:10:59 <sepp2k> Otherwise you won't be allowed to put your Double in an Exp
04:11:14 <dextr> ok
04:11:25 <fmap> dextr: it's not casting: annotations cannot change type
04:11:36 <dextr> what is it then?
04:11:45 <fmap> just annotation
04:11:58 <fmap> you're specifing what type it should be
04:12:13 <dextr> oh, ok
04:13:04 <sepp2k> dextr: Btw: Your calcInteract function doesn't use its argument.
04:13:16 <dextr> hm.. if it's not casting, then what would happen if i wrote val::Group?
04:13:35 <Rembane>  /away
04:13:37 <sepp2k> dextr: You'd get an error that Group is not a type.
04:14:09 <dextr> classes and types are not the same thing?
04:14:55 <dextr> about calcInteract - i shortened the code, to make it more concise, this is the full code: http://ideone.com/6ShgAl
04:14:56 <sepp2k> No. A type can be an instance of a type class (or multiple ones even), but a type class itself is not a type.
04:15:21 <sepp2k> (Group a) => a  is a type, but Group is not.
04:15:37 <dextr> i see
04:16:58 <dextr> what is the proper wy to make  let newExprs = [(Value val)]  generic? that is work with both doubles and other types?
04:17:11 <dextr> *way
04:17:25 <hpaste> marekw2143 pasted “Random” at http://hpaste.org/80496
04:17:42 <marekw2143> hello, why following doesn't compile:^^
04:17:51 <sepp2k> dextr: It would work with other types. The problem is that read needs to know which type to read.
04:17:57 <yitz> dextr: you have to decide which type or types you want it to work with
04:22:34 <fmap> marekw2143: [Num] ?
04:22:35 <dextr> hm.. ok, assuming the appropriate instance Group <A> definitions exist, is there any way to let the runtime system decide automatically which of the specified As it should use?
04:22:54 <marekw2143> fmap: okkok, I just know htat Num is typeclass and not concrete class
04:23:02 <sepp2k> dextr: Automatically based on what?
04:23:06 <marekw2143> but using ([Int], StdGen) produces another error
04:23:31 <dextr> based on what the input (i.e. the read line) is compatible with
04:23:32 <sepp2k> Oh wait... runtime system? No, types are checked at compile time. No typing decisions are made at run time.
04:23:36 <marekw2143> couldn't match expected type 'io t0' with actual type `([Int], ())`
04:23:42 <dextr> e.g. string, double, int, etc.
04:23:46 <sepp2k> dextr: That's not how read works.
04:23:56 * hackagebot MagicHaskeller 0.9.1 - Automatic inductive functional programmer by systematic search  http://hackage.haskell.org/package/MagicHaskeller-0.9.1 (SusumuKatayama)
04:24:13 <srhb> main is an IO action
04:24:23 <srhb> marekw2143: You can't sequence that pure value like that. It doesn't make sense.
04:24:29 <sepp2k> dextr: There are different read functions for different types (some of which accept the same input or overlapping input). The compiler chooses which read function to call at compile time based on the type of the result.
04:24:34 <srhb> (Or non-IO action, rather)
04:24:47 <srhb> marekw2143: If you printed it, it would make sense
04:26:18 <hpaste> marekw2143 pasted “Random” at http://hpaste.org/80498
04:26:37 <dextr> ok, so then for different types, the code needs to be changed? (discadring the possibility that only strings are read in and some self-written function is used to determine types at runtime)
04:26:44 <srhb> marekw2143: It's still not an IO value. <- does not make sense on a non-IO action in the IO monad.
04:27:03 <srhb> marekw2143: you could use let a = ...
04:27:08 <sepp2k> dextr: No, you can make it generic, you just need to decide how.
04:27:48 <sepp2k> dextr: That is, for example you could decide that if the user hits "n", the type the user should enter should be the same one as the type of the exprs list.
04:27:52 <hpaste> srhb annotated “Random” with “Random (annotation)” at http://hpaste.org/80498#a80499
04:28:18 <marekw2143> srhb: thanks
04:28:22 <marekw2143> I'm just haskell newbie
04:28:27 <srhb> marekw2143: Sure. :)
04:28:45 <srhb> marekw2143: It's the same reason that 2 >>= foo -- does not make sense
04:28:53 <merijn> Of course this is just a complicated way of writing "main = return ()" :p
04:28:55 <marekw2143> how long does it take (on average) to be able to write simple web server in haskell, having 3 yr's of imperative experience (incuding python) ?
04:28:58 <srhb> Right.
04:29:06 <srhb> marekw2143: A week or two?
04:29:16 <srhb> I mean, for something very simple.
04:29:20 <dextr> hm.. is there a way of enforcing val to be of the same type as a?
04:29:21 <merijn> srhb: I think he meant "how long does it take to learn haskell well enough to do that"
04:29:31 <srhb> merijn: Am I being optimistic? :P
04:29:35 <merijn> I think so
04:29:38 <srhb> Hm.
04:29:56 <dextr> which i guess is the same thing you suggested sepp2k
04:30:06 <Hafydd> > 2 >>= const $ return 1
04:30:08 <lambdabot>   Could not deduce (GHC.Num.Num (m0 a0 -> b))
04:30:08 <lambdabot>    arising from the ambiguity c...
04:30:10 <merijn> I think it took me about 4-6 months before I was comfortable writing haskell and probably another times that before I really got into the needed stuff to do something like a webserver nicely
04:30:17 <srhb> Hafydd: 2 ain't no monad!
04:30:22 <srhb> Well, Int.
04:30:26 <sepp2k> dextr: You can use the ScopedTypeVariables extension in GHC and then use read line :: a.
04:30:34 <basdirks_> marekw2143: are you talking about actually writing a webserver yourself?
04:30:39 <sepp2k> dextr: Or you can use the asTypeOf function from Prelude.
04:30:40 <merijn> Granted, I was a bit slow, but I'd say 3-6 months before you're capable of writing a semi-decent webserver? (From zero haskell knowledge, that is)
04:30:51 <Hafydd> srhb: it is in ghci.
04:30:56 <srhb> merijn: Ah well, I did not mean semi decent. I meant responds to HTTP requests. :P
04:31:02 <t7> use snap
04:31:08 <Hafydd> Or something like that.
04:31:09 <srhb> Hafydd: What?
04:31:10 <tdammers> use happstack ;)
04:31:10 <marekw2143> basdirks_: yes
04:31:21 <merijn> t7: That's a bit orthogonal to the question, isn't it?
04:31:37 <srhb> Well, I'm sure you could do weird thing with the function instance..
04:31:45 <t7> does he mean write a web server or use a web framework?
04:31:58 <merijn> t7: The question wasn't "what do I use to make web apps" it was "how long does it take to become competent enough to write something *like* a web server"
04:32:10 <Hafydd> Well, nevermind, I suppose it isn't, but this does work:
04:32:13 <Hafydd> do { 2 }
04:32:14 <marekw2143> i mean to write server to handle HTTP requests with assumption that writer knows HTTP protocol
04:32:33 <Hafydd> I suppose that's because of ghci's hacking to make the REPL work.
04:32:49 <Lethalman> :t do { 2 }
04:32:50 <lambdabot> Num a => a
04:32:57 <merijn> marekw2143: I'm gonna go with my original 3-6 month estimate (maybe even more if you're not pushing very hard to learn/get better)
04:33:20 <fmap> Hafydd: `do 2' works because that's how do-notation works
04:33:20 <srhb>  Hafydd: do { e } := e
04:33:30 <srhb> Wrong symbol, but.
04:33:36 <merijn> marekw2143: On the other hand, I'm quite confident saying that I can (now) develop one in haskell in significantly less time than I could in any other language
04:33:43 <dextr> how is asTypeOf different from ::Type?
04:33:52 <srhb> Hafydd: So that introduces no operator from Monad.
04:33:55 <merijn> :t asTypeOf
04:33:56 <lambdabot> a -> a -> a
04:34:11 <srhb> Hafydd: do { e; foo } on the other hand desugars to e >> do { foo }
04:34:31 <merijn> :t 2 `asTypeOf` (+)
04:34:32 <lambdabot> (Num a, Num (a -> a -> a)) => a -> a -> a
04:35:00 <merijn> > 2 `asTypeOf` (+) $ 3 4
04:35:00 <dextr> what does that last line do?
04:35:01 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a))
04:35:01 <lambdabot>    arising from the ambiguity chec...
04:35:20 <Hafydd> That explains it...
04:35:27 <srhb> Hafydd: :)
04:35:28 <merijn> dextr: Mine? Evil, weird and confusing things :p
04:35:30 <mmaruseacph2> :t asTypeOf
04:35:31 <lambdabot> a -> a -> a
04:35:41 <dextr> yes merijn
04:35:42 <mmaruseacph2> :t asTypeOf 2
04:35:43 <lambdabot> Num a => a -> a
04:35:48 <mmaruseacph2> :t asTypeOf 2 3.4
04:35:49 <lambdabot> Fractional a => a
04:35:53 <mmaruseacph2> ah, cool
04:35:53 <sepp2k> dextr: asTypeOf is different from :: in that you don't need an extension to refer to a.
04:35:58 <merijn> dextr: It's abusing the fact that lambdabot has "instance Num a => Num (a -> a)"
04:36:18 <mmaruseacph2> why does it have that instance?
04:36:18 <startling> > 1 2
04:36:19 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
04:36:20 <lambdabot>    arising from the ambiguity chec...
04:36:34 <merijn> mmaruseacph2: Because you can do funny things like "sin^2"
04:36:37 <startling> merijn: didn't that get removed?
04:36:48 <merijn> :t sin
04:36:49 <lambdabot> Floating a => a -> a
04:36:53 <mmaruseacph2> :t sin^2
04:36:54 <lambdabot> (Floating a, Num (a -> a)) => a -> a
04:36:58 <merijn> :t sin^2
04:36:59 <lambdabot> (Floating a, Num (a -> a)) => a -> a
04:37:01 <sepp2k> dextr: That is, without extensions, just writing :: a would not work, because by normal Haskell rules, each type signature has its own scope, so the a in :: a would not be the same a as that in your toplevel type signature.
04:37:06 <mmaruseacph2> > sin^2 .5
04:37:08 <lambdabot>   No instance for (GHC.Real.Integral (f0 b0))
04:37:08 <lambdabot>    arising from a use of `GHC.R...
04:37:15 <merijn> > (sin^2) .5
04:37:16 <lambdabot>   No instances for (GHC.Num.Num (b0 -> b0), GHC.Num.Num (f0 b0))
04:37:16 <lambdabot>    arising f...
04:37:17 <Hafydd> > (sin^2 + cos^2) 0.5
04:37:18 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
04:37:18 <lambdabot>    arising from a use of `e_12205'...
04:37:18 <merijn> > (sin^2) 1
04:37:20 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
04:37:20 <lambdabot>    arising from a use of `e_121'
04:37:20 <lambdabot>  ...
04:37:23 <merijn> hmmm
04:37:26 <merijn> Peculiar
04:37:33 <startling> merijn: NumInstances were removed
04:37:35 <sepp2k> dextr: But  read line `asTypeOf` valueOfTypeA  will work because it simply forces the two arguments to be of the same type.
04:37:48 <merijn> startling: No, because otherwise "sin^2" would be a type error, no?
04:38:05 <startling> merijn: nah, it just has the Num (a -> a) constraint
04:38:09 <merijn> ah
04:38:14 <mmaruseacph2> anyway, it's cool
04:38:31 <startling> it doesn't care if there is some Num (a -> a) or not
04:38:41 <merijn> mmaruseacph2: Anyway, that *used* to work in lambdabot
04:39:01 <merijn> mmaruseacph2: But was horribly confusing to newcomers, which (I guess) is why it got removed
04:39:10 <merijn> You could still implement it yourself, if you want to
04:39:12 <Hafydd> @pl \x -> (sin x)^2 + (cos x)^2
04:39:13 <lambdabot> ap ((+) . (^ 2) . sin) ((^ 2) . cos)
04:39:32 <mmaruseacph2> merijn: thanks, looks good
04:39:46 <mmaruseacph2>  btw, what features do you think are good for a talk given to non-haskellers interested in web design and open source?
04:40:00 <dextr> oh, so i could write newExprs = [(Value (val asTypeOf a) )]? (where a is calcInteract :: (Group a) => [Expr a] -> IO () in the function signature)
04:40:00 <mmaruseacph2> I'm thinking of presenting some Yesod/Snap/Happstack
04:40:20 <merijn> mmaruseacph2: Should it be web related? Or just anything cool and haskell related?
04:40:25 <mmaruseacph2> but I wanted to know if there are some hints on things to focus about
04:40:31 <mmaruseacph2> web related for this edition
04:40:41 <merijn> Then I'm out of suggestions :p
04:40:43 <Hafydd> I think it's quite natural to extend numerical operation to functions on numbers, which are just abstractions of numbers themselves.
04:40:58 <mmaruseacph2> there will be a second one in three months
04:41:02 <merijn> I wouldn't use Yesod though, the TH voodoo in there scares me and I'm used to complicated haskell :)
04:41:27 <mmaruseacph2> :)
04:41:55 <merijn> Hafydd: Oh, sure. It's quite natural, but you have to admit you can see how things like "sin^2" and "1 2 = 1" might be confusing to newcomers trying simple example code that should just produce an error ;)
04:42:43 <Hafydd> I suppose so.
04:42:56 <Hafydd> The former is okay, but the latter is a bit demented.
04:43:21 <merijn> Hafydd: Sure, but Num demands a fromInteger function
04:43:21 <Hafydd> Maybe if there were a Num-like class without fromInteger?
04:43:54 <merijn> There have been many proposed refactorings of the Num hierarchy, but I don't see it changing in the forseeable future
04:44:39 <tdammers> I tried all three - yesod, snap, and happstack
04:45:06 <tdammers> yesod felt huge and took ages to compile
04:45:39 <medfly> hi cale
04:45:41 <tdammers> with snap, I didn't quite feel at home with the philosophy - I know very well how HTTP works, I don't want it hidden from me, I just want convenient access and full control
04:45:59 <tdammers> happstack fits my way of thinking best
05:00:08 <srhb> If bad point-free is point-less style, this is do-not style: double x = (do { (*) } $ do { 2 }) $ do { x }
05:00:49 <dextr> what's the difference between (:) and ++ ?
05:00:59 <srhb> :t (:)
05:01:00 <lambdabot> a -> [a] -> [a]
05:01:02 <srhb> :t (++)
05:01:03 <lambdabot> Monoid m => m -> m -> m
05:01:12 <srhb> Well.. Except the monoid instance
05:01:30 <srhb> dextr: (:) appends one element to a list of those elements, ++ concatenates two lists of the same type of elements
05:01:40 <dextr> ah, ok
05:01:56 <dextr> so (:) appends at the end?
05:02:03 <srhb> No, sorry. Prepends
05:02:08 <srhb> > 1 : [2,3]
05:02:10 <lambdabot>   [1,2,3]
05:02:14 <Lethalman> :t (Data.List.++)
05:02:15 <mmaruseacph2> dextr: a crude way to implement (:) is (\x -> ([x] ++))
05:02:15 <srhb> > [1] ++ [2,3]
05:02:15 <lambdabot> [a] -> [a] -> [a]
05:02:17 <lambdabot>   [1,2,3]
05:02:30 <dextr> searchting for those operators in google seems impossible :\
05:02:35 <srhb> dextr: Use hoogle
05:02:36 <mmaruseacph2> dextr
05:02:39 <mmaruseacph2> use hoogle
05:02:41 <mmaruseacph2> or hayoo
05:02:44 <dextr> oh, ok
05:02:45 <srhb> @hoogle (:)
05:02:45 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
05:02:45 <lambdabot> Test.QuickCheck.Function data (:->) a c
05:02:45 <lambdabot> keyword ::
05:02:53 <srhb> Well, that didn't go very well.
05:02:54 <mmaruseacph2> I still don't know what's the actual difference between the two
05:03:03 <mmaruseacph2> and why there are some things found only by one of them
05:03:04 <srhb> hayoo searches Hackage
05:03:06 <osfameron> is there a Microsoft themed haskell search enging: Hing ?
05:03:08 <srhb> hoogle searches base, I believe
05:03:19 <neutrino_> is it polite to tell the german CEO of a company you're applying to that the english tagline which they have in their logo uses bad grammar?
05:03:21 <startling> hoogle searches base and some other packages iirc
05:03:23 <srhb> osfameron: It's called Hang.
05:03:26 <byorgey> hoogle searches a bit more than base
05:03:27 <srhb> osfameron: (No, sorry, there isn't)
05:03:43 <osfameron> heh
05:03:47 <byorgey> mmaruseacph2: hayoo searches all of Hackage; hoogle searches a more limited subset but it can also search by type (which hayoo can't)
05:03:58 <srhb> byorgey: Hayoo can't search by type? What?
05:04:18 <neutrino_> i thought hayoo could search by type?
05:04:20 <mmaruseacph2> byorgey: thanks
05:04:37 <byorgey> oh, hmm, so it can
05:05:28 <byorgey> ah, but hoogle's type search is better
05:05:32 <byorgey> hayoo only finds exact matches
05:05:40 <neutrino_> yeah
05:05:43 <byorgey> hoogle finds types that are "close", or more specific, etc.
05:05:58 <quicksilver> byorgey: less specific.
05:06:30 <byorgey> perhaps it finds less specific things too, but I stand by what I said.
05:06:47 <quicksilver> what you said is fine
05:06:54 <byorgey> I searched for a -> [a] -> [a]  and it returned (among other things)  drop :: Int -> [a] -> [a]
05:07:14 <quicksilver> I was really just remarking that less specific is often the more useful :)
05:07:22 <quicksilver> since your original search is then an instance of it
05:07:31 <byorgey> fair enough.
05:12:46 <hiptobecubic> Well there goes another 1.5 hours because of mutable data :(
05:13:45 <mmaruseacph2> haskell has changed the way I code
05:14:11 <mmaruseacph2> and I say this by comparing code written three years ago to code written a few weeks ago
05:14:20 <mmaruseacph2> same language, same project
05:14:26 <philed> Changed for the better, I hope!
05:15:20 <yitz> neutrino_: probably better off not if you are applying
05:16:48 <yitz> neutrino_: you can submit it anonymously and then claim credit later after you're hired
05:21:32 <mrvortex> whois amiri
05:21:59 <mrvortex> whois PhiRod
05:22:19 <mmaruseacph2> philed: yup, for the better
05:22:34 <mmaruseacph2> imperative code gets written in more testable way
05:24:09 <neutrino_> yitz: heh
05:24:16 <neutrino_> yitz: i think i'm not applying anyways :p
05:39:08 <srhb> When can we encode laws into classes?
05:40:19 <mysticc> @pl \a -> [a]
05:40:19 <lambdabot> return
05:41:10 <statusfailed> srhb: is it possible to statically check laws?
05:41:43 <statusfailed> I'm guessing in general no?
05:41:43 <srhb> statusfailed: I don't know. Hence the question. Is it possible, and if so, what do we need and when do we get it. :-)
05:41:49 <srhb> In general no, probably, yes.
05:42:54 <statusfailed> srhb: seems like it would make classes more inflexible, which might be a bad idea
05:43:00 <statusfailed> after all, sometimes people do ignore the laws
05:43:07 <startling> statusfailed, depends on the law
05:43:22 <statusfailed> sure, but in general it's not gonna work right?
05:43:34 <byorgey> srhb: for most laws you would need a dependent type system.
05:43:41 <startling> ^ yeah
05:43:48 <fmap> byorgey: why?
05:44:00 <byorgey> Agda and Coq can have structures/classes with statically declared laws.
05:44:06 <statusfailed> I need to pick up agda
05:44:36 <byorgey> fmap: well, I suppose just to *declare* the laws you don't necessarily need dependent types.
05:44:40 <statusfailed> Given dependent types, is it possible to statically check laws?
05:44:47 <statusfailed> (for an arbitrary law)?
05:44:48 <byorgey> but in general it's hopeless to have the laws automatically checked
05:44:53 <byorgey> you need the programmer to provide a proof
05:44:57 <fmap> yes
05:45:07 <srhb> Right, I meant to have automatic checking.
05:45:12 <statusfailed> like QuickCheck?
05:45:23 <srhb> No, real lawfullness.
05:45:30 <byorgey> and the most natural way to do that is to have the law expressed as a *type* where the programmer has to provide a *value* of that type, which by the Curry-Howard isomorphism corresponds to a proof of the law
05:45:54 <byorgey> but in that case such laws-as-types must be dependent, because the need to mention type class methods
05:45:56 <srhb> So you must think of a type representation of your law. That sounds tricky.
05:46:06 <byorgey> not really.
05:46:07 <psii> if the proof is obvious enough, you can let check it automatically.
05:46:16 <srhb> byorgey: can you give an example? If it's not too much to ask.
05:46:22 <byorgey> expressing the laws as types isn't the tricky part, really.
05:46:41 <byorgey> srhb: if you have dependent types then you can include arbitrary value-level stuff in your types.
05:47:03 <byorgey> srhb: it's hard to give a good example in Haskell because it isn't dependently typed =)
05:47:11 <srhb> Pseudo-syntax would work :)
05:47:14 <srhb> (Well, maybe!)
05:47:34 <fmap> yeah, example would be nice
05:48:13 <elliott> ...and also _|_ gums things up.
05:48:23 <elliott> take a look at Agda and Coq if you are interested in this approach though
05:48:33 <fmap> I've done a bit of coq (first 3 chapters of SF) but still don't understand why you need dependent typing there
05:48:53 <srhb> I'm mostly interested in what it would look like for Haskell (in a fuzzy manner)
05:49:02 <byorgey> srhb: here's a link to part of the Agda standard library. take a look at Semigroup: it declares an equality method, a product method, and a field called 'isSemigroup' which is a proof of type  IsSemigroup
05:49:06 <byorgey> http://www.cse.chalmers.se/~nad/listings/lib-0.6/Algebra.html#1
05:49:18 <byorgey> IsSemigroup is here: http://www.cse.chalmers.se/~nad/listings/lib-0.6/Algebra.Structures.html#640
05:49:39 <elliott> fmap: you can imagine e.g. class Monoid a where {mempty :: a; mappend :: a -> a -> a; mappend_mempty :: forall a. mappend mempty a = a; ...}
05:49:45 <byorgey> it has three fields, which are proofs that the equality is an equivalence, that the product is associative, etc.
05:49:56 <elliott> here mappend_mempty is a dependent type: that "a" is not a plain type but instead a value (of type, err, "a")
05:50:15 <byorgey> srhb: meh, ignore me, pay attention to elliott  =)
05:50:20 <ski>   mappendAssociative :: forall (m0 :: m) (m1 :: m) (m2 :: m). mappend (mappend m0 m1) m2 = mappend m0 (mappend m1 m2)  -- perhaps
05:50:35 <frerich> I just tried to come up with some nice answer to the question at http://stackoverflow.com/questions/14235750/contiguous-sublists-from-an-ascending-sequence, but everything I have is really ugly. The task is to write a function 'groupSucc :: [a] -> [[a]]' so that 'groupSucc [1,2,3,4,6,7,9,10,11]' yields '[[1,2,3,4],[6,7],[9,10,11]]'. Does anybody have some nice idea for how to implement this without using folds?
05:51:02 <merijn> frerich: I don't think you can?
05:51:16 <opqdonut> well you can always write out the recursion by hand :)
05:51:27 <frerich> Well yeah, without manual recursion as well, of course. ;-)
05:51:32 <elliott> byorgey: that may be the least wise advice anyone has ever given :)
05:51:43 <opqdonut> I think the straightforward recurse-and-collect-into-accumulator solution is the best
05:51:58 <srhb> *boggle*
05:52:00 <byorgey> elliott: hehehe
05:52:13 <elliott> I see Agda stdlib code is as accessible as ever, though
05:52:22 <elliott> "∙ Preserves₂ ≈ ⟶ ≈ ⟶ ≈". obviously.
05:52:23 <ski> frerich : with what constraints on `a' ?
05:52:25 <srhb> elliott, byorgey: Thanks to you both. Perhaps I really do have to do Agda or something in order to understand this. Neither explanation seemed very enlightening. :P
05:52:26 <tdammers> you can probably do it with some magic from the split package, but that probably boils down to the same thing eventually
05:52:31 <frerich> merijn: One idea I had was to work on 'zip xs (zipWith (-) (tail xs) xs)' so that you have the deltas and then work with that.
05:52:51 <byorgey> srhb: try reading "The Power of Pi"
05:52:54 <elliott> srhb: Well, mappend_mempty is a type that says things about values, because you're giving a law as a type. That's what dependent types are all about.
05:53:05 <elliott> Now, you *could* bolt an unrelated language for stating properties about Haskell code in
05:53:13 <elliott> ...and an unrelated language for proving said properties
05:53:14 <frerich> ski: No particular constraints given, I personally tried to work with just Eq and Enum but if you have some fancy Applicative trick or something, I'd be interested in that as well :)
05:53:22 <ski> srhb : did you see the `mappendAssociative' example ?
05:53:34 <elliott> ...but it'd be an awful waste when you could reuse the type system you already have, especially as you want it to be constructive just like a typed programming language, etc.
05:54:13 <srhb> ski: Yes, I'm looking at it right now.
05:54:50 <frerich> merijn: Somebody on SO just suggested 'map (map snd) . groupBy (\(u, v) (x, y) -> u - v == x - y) . zip [0..]' :-)
05:54:56 <frerich> merijn: So apparently it *is* possible.
05:57:06 <srhb> what does mempty mean in the definition of mapend_mempty
05:57:17 <srhb> normally that just shadows the name, but that's not what's going on here is it
05:57:23 <merijn> frerich: <Obscure technical argument about how you could trivially translate that to a fold>
05:57:30 <ski> srhb : it means the usual `mempty' member of `Monoid'
05:58:13 <srhb> So it's actually a pattern match on whatever mempty is for the specific instance?
05:58:34 <ski> not a pattern-match, but yes, it refers to whatever `mempty' is for the specific instance
05:58:39 <srhb> Okay.
05:58:51 <srhb> Hmm.
05:59:36 <fmap> ski: `=' means they are same type?
05:59:53 <ski> fmap : no, that they are the same value
05:59:59 <ski> > mempty :: Any
06:00:01 <lambdabot>   Any {getAny = False}
06:00:11 <ski>   newtype Any = Any {getAny :: Bool}
06:00:29 <ski> so with `instance Monoid Any' we have `mempty = Any False'
06:01:06 <ski> so in that case `mappend_mempty :: forall (a0 :: a). mappend mempty a0 = a0' really means `mappend_mempty :: forall (a0 :: Any). mappend (Any False) a0 = a0'
06:01:56 <ski> and then it would depend on how `mappend' is defined
06:02:03 <ski> perhaps it's defined as
06:02:18 <ski>   Any b0 `mappend` Any b1 = Any (b0 || b1)
06:02:22 <ski> or perhaps as
06:02:47 <ski>   Any False `mappend` a1 = a1
06:02:56 <ski>   Any True  `mappend` _  = Any True
06:03:14 <Lethalman> > (||) <$> Any True <*> Any False
06:03:16 <lambdabot>   Couldn't match expected type `f0 GHC.Types.Bool'
06:03:16 <lambdabot>              with actual t...
06:03:25 <Lethalman> right
06:03:27 <Lethalman> ofc :S
06:03:46 <ski> in the latter case, `mappend (Any False) a0 = a0' in the law could be simplified by the system to `a0 = a0', which is trivially true
06:04:18 <ski> srhb : does this help any ?
06:04:27 <fmap> that looks like coq really
06:04:49 <srhb> ski: I think so... It's like it's almost within my reach, but not quite. :P
06:05:45 <fmap> ski: so that's value level equations lifted to type level?
06:05:59 <craigInnes> hi there, I recently installed the latest version of ghc (7.6.1) from source, but it doesnt work particularly well with a lot of old packages, so I want to switch back to 7.4.1 (the one provided by ubuntu's package manager). How do I do this? I tried running apt-get remove ghc, then installing ghc via synaptic, but after the install it still shows the version number as 7.6.1
06:06:54 <fmap> ski: what I don't understand is how that relates to "to prove something you need to provide value of that type"
06:07:28 <srhb> mempty?
06:07:34 <srhb> Or what. Maybe I'm still lost :P
06:07:52 <ski> > mempty :: Sum Integer
06:07:53 <lambdabot>   Sum {getSum = 0}
06:07:54 <ski> > mempty :: Product Integer
06:07:56 <lambdabot>   Product {getProduct = 1}
06:08:39 <elliott> srhb: I apologise for the ambiguous syntax, though it's mostly Haskell's fault :)
06:08:42 <ski> fmap : i'm not sure what exactly you mean by "value level equations" here
06:08:51 <srhb> elliott: I know. Thanks for trying. I'm being dense again. :P
06:09:06 <elliott> Haskell hasn't got dependent types -- so it never needs to worry about wanting to reference "mappend" -- so it willy-nilly takes up the namespace of all lowercase sequences for type variables
06:09:15 <srhb> Right.
06:09:16 <mSSM> Is there something that takes [(m a, m b)] and gives me `m [(a,b)]' ?
06:09:28 <elliott> and we have no notion of type-level equality ("=") though you can define it with GADTs: data Equal a b where Refl :: Equal a a
06:09:44 <elliott> -- for this to work for that proof, you need the ability to pass Equal two *values*, not just two types as you can in Haskell
06:09:48 <elliott> (and get a type back)
06:09:55 <ski> fmap : anyway, in case we really have dependent types, rather than a separate language for (stating and) proving laws, then we need to define a value `mappend_mempty' when defining `instance Monoid Any'
06:09:57 <elliott> Haskell is not the ideal setting to explore things like this
06:10:01 <fmap> ski: well, mappend is defined on value level with equations, and we use them on type level
06:10:16 <srhb> elliott: Hmm, okay.
06:11:10 <ski> fmap : the `mappend mempty a0 = a0' in the signature for `mappend_mempty' is not meant to be read as a *defining* equation, but as an equality which may or may not hold (but we need to prove it holds, here)
06:11:32 <ski> anyway, given
06:11:34 <ski>   mappend_mempty :: forall (a0 :: a). mappend mempty a0 = a0
06:11:41 <ski> which in this specific case amounts to
06:11:45 <ski>   mappend_mempty :: forall (a0 :: Any). mappend mempty a0 = a0
06:11:48 <ski> we need to define
06:11:58 <ski>   mappend_mempty = ...
06:12:13 <ski> where `...' is a proof of  `mappend mempty a0 = a0'
06:12:27 <elliott> mSSM: You can separate that problem into [(m a, m b)] -> [m (a,b)] and [m a] -> m [a]
06:12:31 <elliott> the latter is "sequence"
06:12:51 <ski> fmap : how this proof will be written depends on the language we use for proofs
06:12:59 <ski> it might perhaps be written like
06:13:00 <elliott> The former is map f, where f :: (m a, m b) -> m (a, b) = uncurry (liftM2 (,))
06:13:09 <elliott> :t sequence . map (uncurry (liftM2 (,)))
06:13:10 <lambdabot> Monad m => [(m a1, m a2)] -> m [(a1, a2)]
06:13:14 <elliott> :t mapM $ uncurry (liftM2 (,))
06:13:15 <lambdabot> Monad m => [(m a1, m a2)] -> m [(a1, a2)]
06:13:50 <fmap> ski: what's the right term to substituting `mappend mempty a0' with `a0' given `Any False `mappend` x = x' then?
06:14:11 <fmap> s/to/for/
06:14:33 <srhb> Doh, okay, I confused myself. I was trying to understand mappend_mempty as a proof, but of course it's the law. And then the instance provides the proof?
06:14:43 <ski>   mappend_mempty = {= mappend mempty a0
06:14:50 <ski>      ={ DEF mempty }= mappend (Any False) a0
06:14:56 <ski>     ={ DEF mappend }= a0
06:15:00 <ski>                     =}
06:15:22 <osa1> why is getChar strict but getContents not ?
06:15:39 <ski> osa1 : `getContents' is intended to be lazy
06:16:11 <ski> srhb : yes
06:16:36 <ski> perhaps using a syntax like above, perhaps in some other way
06:17:24 <srhb> The syntax makes little sense to me, but I guess that doesn't matter much.
06:17:40 <srhb> The Any False is the dependent bit?
06:17:45 <srhb> Hm, that's a bit vague
06:17:58 <elliott> The equivalent of "mappend_mempty = Refl" should work there in any self-respecting dependent lang, of course
06:18:12 <elliott> but you will have to do something like what ski said (for vague definitions of "something like") for more complex proofs
06:18:15 <ski> the equality proof above has the general structure `{= <left hand side> ={ <reason> }= <expression> ={ <reason> }= ... ={ <reason> }= <right hand side> =}'
06:21:36 <mSSM> elliott: thank you
06:24:11 <craigInnes> hi, I am trying to learn how  to downgrade my ghc version from 7.6.1 to 7.4.1. 7.6.1 is the version i have installed from source, but I want to go back to the version in ubuntu's package manager. Can anyone help?
06:25:53 <ski> srhb,fmap : "Equality proofs in Cayenne" by Lennart Augustsson in 1998 or 1999 at <http://web.archive.org/web/20090426033216/http://www.cs.chalmers.se/~augustss/cayenne/eqproof.ps>
06:26:00 <ski> might perhaps be interesting
06:26:37 <mSSM> craigInnes: So install GHC through Ubuntu's package manager?
06:26:53 <ski> fmap : "what's the right term .." -- hm, not sure, perhaps "(replacement) by definition" ?
06:26:59 <srhb> ski: Thank you :)
06:27:14 <mSSM> craigInnes: You did install GHC 7.6.1 through the package manager as well, right?
06:27:19 <ski> srhb : Cayenne was sortof a predecessor to Agda1, btw
06:27:41 <ski> (see <http://web.archive.org/web/20090426033216/http://www.cs.chalmers.se/~augustss/cayenne/index.html> for more info on it)
06:27:45 <craigInnes> mSSM: No, this is the issue, I installed 7.6.1 from source as it was not available through ubuntu's package manager
06:27:58 <mSSM> craigInnes: That does not make any sense.
06:28:18 <mSSM> craigInnes: You mean 7.6.1 was not available from Ubuntu's repositories?
06:28:34 <elliott> 7.6.1 is pretty new, I wouldn't expect it to be in all the repos yet.
06:28:50 <mSSM> elliott: I think he make configure install'ed it
06:29:04 <elliott> ? Sure, that's what he's saying.
06:29:06 <craigInnes> mSSM: Apologies, I am a bit of a n00b when it comes to linux related things. Ubuntu's apt-get / synaptic shows the latest version as 7.4.1, but you can download the latest version 7.6.1 from ghc website
06:29:30 <craigInnes> to clarify, i did go the configure/make install route
06:29:47 <mSSM> Ok, because if you had installed a .deb package, that would have made things easier. ;)
06:29:48 <elliott> I think the GHC distributions let you "make uninstall".
06:29:54 <elliott> So perhaps try that?
06:31:05 <mSSM> craigInnes: Try what elliot suggests; otherwise track down all files make install put into your system, and delete them by hand.
06:31:12 <mSSM> craigInnes: Then go through apt-get
06:31:32 <mSSM> craigInnes: Note for future reference: never dump anything onto your system unless it's through the package manager.
06:32:19 <craigInnes> mSSM: I am learning this the hard way it seems. I was advised by someone else on this channel to install from source and that it wouldnt really be much trouble.
06:33:08 <craigInnes> mSSM: So it doesnt seem to be able to find a make uninstall command. What files should I be trying to track down? ones in usr/local ?
06:33:11 <mSSM> craigInnes: He should have warned you that you only do that if you really know what you are doing.
06:33:32 <elliott> craigInnes: Are you sure you're in the directory you ran "make install" from?
06:33:43 <elliott> If my recollection is right and there is such an uninstall target then it'll only work from there.
06:34:07 <elliott> (By the way, why are you downgrading? Maybe there is a simpler way to solve your issue)
06:34:43 <craigInnes> elliott: I am the same directory from which I make installed and configured
06:34:53 <mSSM> craigInnes: I honestly don't know. You could check the make-file to see where it puts everything. But usually /usr/ is the correct place to look for.
06:35:08 <elliott> autotools-based systems like GHC's usually default to /usr/local
06:35:21 <mSSM> Well, that's smart and a good thing.
06:35:56 <mSSM> elliott: I'd love to use 7.6.1, but cabal-dev won't work with it.
06:36:00 <craigInnes> elliot: I am downgrading because I am running into errors when installing various libraries which I did not encounter with the old version of ghc. And was told this was because these libraries hadnt caught up to the latest version
06:36:01 <mSSM> Unless I use the git version.
06:36:04 <elliott> craigInnes: http://www.mail-archive.com/haskell-cafe@haskell.org/msg32572.html has a list of locations you probably want to get rid of
06:36:21 <elliott> craigInnes: in fact
06:36:26 <elliott> craigInnes: have you installed anything else from source?
06:36:44 <craigInnes> elliot: No, this is a bit of a first time experience
06:36:46 <elliott> if not, you can probably just blow away everything in /usr/local -- rm -rf /usr/local/* -- please make absolutely sure of this before running that command :P
06:37:09 <elliott> if you do "$ ls /usr/local/bin" then if the output is all GHC-related stuff you should be safe to just nuke it
06:37:14 <elliott> your mileage may vary
06:37:46 <mSSM> and double check your # rm -rf command
06:38:05 <mSSM> you don't want to do something smart like # rm -rf /usr/lib *
06:38:19 * mSSM nuked his $HOME with that once.
06:39:02 <beaky> hello
06:39:07 <srhb> beaky: Hi.
06:39:27 <beaky> I read somewhere that it is possible to replace sum-types with closures. How is this done?
06:40:10 <craigInnes> mSSM: okay, so the usr/local/bin/ was just full of ghc related stuff, so Ive cleared that out. Any further steps I need to take?
06:40:59 <mSSM> craigInnes: Check where else ghc files were put.
06:41:27 <mSSM> craigInnes: IF you are sure that it only put stuff into /usr/local/*, then you are fine.
06:41:40 <mSSM> craigInnes: check elliott's link.
06:42:01 <mSSM> craigInnes: Once you are sure of that, go install 7.4.*
06:42:22 <elliott> note that my link is from 2007 and may be woefully out of date :)
06:42:57 <craigInnes> mSSM: Do i have to change an environment variable or something so it doesnt point to the non existent version anymore or should the package manager be able to figure this out on itself?
06:43:27 <craigInnes> mSSM: Nevermind
06:43:54 <craigInnes> thanks for your help guys
06:44:09 <fmap> ski: hmm, interesting, thanks
06:46:45 <jason1> is "You could have invented monads" a good explanation monads?
06:47:01 <jason1> +of
06:47:20 <srhb> jason1: The only one, I think most agree.
06:47:22 <mSSM> If I have a data structure `data Foo = Foo { a :: Int, b :: MV.Vector Int }', where b is a mutable vector from Data.Vector.Mutable. If I now have a  `ob1 = Foo x1 y' and make a `ob2 = Foo x2 y', the y will be the same between the two, right?
06:47:52 <srhb> You mean the second one will be a copy of the first? yes.
06:48:04 <srhb> Wait, no, what.
06:48:09 <srhb> Depends on your 'y'
06:48:24 <mSSM> srhb: If I now change the y in ob1, will it also be changed in ob2
06:48:27 <mSSM> ?
06:48:29 <srhb> mSSM: No.
06:48:48 <srhb> I mean unless you got y from some other top level definition
06:48:58 <neutrino_> jason1: do not try to "learn monads"
06:49:00 <srhb> It's not quite clear to me what you're doing.
06:49:16 <srhb> jason1: But do do the "You could have invented monads" exercises
06:49:19 <neutrino_> jason1: it's the #1 mistake people make when learning haskell, one day they wake up and think "i want to learn monads"
06:50:00 <srhb> mSSM: If you have y = makeSomeMutableVector -- somewhere, then yes.
06:50:08 <srhb> But of course, then your syntax doesn't hold
06:52:01 <tdammers> neutrino_: why is that a mistake?
06:52:14 <mSSM> srhb: Yeah, I pretty much have that at the start... ok, here is a small explanation.
06:52:36 <tdammers> (other than that it's more a matter of *understanding* rather than *learning*)
06:52:50 <neutrino_> tdammers: it's like learning hammers. you don't wake up one day and go "i'm gonna learn hammers today". you learn how to do things with them: drive nails, peen knives, assemble wood.
06:53:11 <Philippa_> neutrino_: I think it's quite possible for people who are used to language-oriented metaprogramming to learn monads-in-FP
06:53:19 <tdammers> neutrino_: but isn't that the same with everything?
06:53:27 <neutrino_> the thing is, you intuitively know what hammers are for because you've seen people use them all your life, you don't have that advantage with monads
06:53:33 <mSSM> srhb: I had a `data Foo = Foo Int [Int]'; I fill [Int] with random Ints at the start, and this list will stay fixed, but I update one element at every step. The first field in Foo Int [Int] is just the sum of [Int].
06:53:47 <tdammers> imagine a world where hammers don't exist yet
06:53:53 <neutrino_> so you look at this abstract hammer and start coming up with bs to try to explain them to yourself
06:53:56 <Philippa_> but we've been using let bindings or something similar a lot of our lives. Guess what do notation is?
06:53:58 <mSSM> srhb: To make my program faster, I wanted to replace [Int] with a mutable vector.
06:54:07 <neutrino_> and end up trying to drive nails with the handle
06:54:11 <srhb> mSSM: Yes, that much I get.
06:54:14 <jason1> neutrino_: why would it be a mistake to learn something I have poor understanding of?
06:54:14 <Philippa_> really, "don't try to understand monads" was a necessary discussion at the time but it's not the last word
06:54:22 <tdammers> or someone tells you "the wooden part is where you hold it, and then you can use it to beat against things with the metal part"
06:54:37 <neutrino_> and you end up thinking monads are this: http://www.codinghorror.com/.a/6a0120a85dcdae970b017742d249d5970d-800wi
06:54:55 <mSSM> mSSM: so the question is: if I update one element in the mutable vector, and then sum over all the elements, how does haskell handle that?
06:54:57 <mSSM> oops
06:55:01 <mSSM> srhb: ^
06:55:17 <mSSM> srhb: since Foo has a pure and an impure part.
06:55:24 <tdammers> IMO, there's two things you need to understand about monads: how they're really not that special, and what you can do with them in practice
06:56:09 <tdammers> neutrino_: even though the label clearly says "PHP"?
06:56:23 <neutrino_> the part that they're not really special is well ilustrated by learning about things that are monoids or applicative, and seeing how that contrasts with things that are monads
06:56:30 <neutrino_> tdammers: that's the joke.
06:56:41 <tdammers> well
06:56:51 <tdammers> seeing how PHP is basically a huge monad...
06:56:54 <neutrino_> so, again, we're back to learn-by-example
06:56:55 <mSSM> srhb: It would be very silly if it copied the entire mutable vector if I take a `Foo a b', `unsafeWrite b x', a' = sum b, and present `Foo a' b' as the result.
06:57:11 <tdammers> I guess what I'm getting at is that a bit of theory doesn't hurt
06:57:16 <srhb> mSSM: Right. All that's wrong is your syntax.
06:57:23 <Philippa_> neutrino_: they are 'special' in a sense, but so are applicatives, and so are monoids. What's special is that the set of capabilities the signature offers corresponds neatly to something notably more useful than we expect from programming abstractions
06:57:40 <mSSM> srhb: yeah, the syntax is terrible... but do you understand my question?
06:57:43 <Philippa_> (what is an applicative functor? It's a language with function application)
06:57:43 <tdammers> Philippa_: but the same goes for a lot of other abstractions in haskell
06:57:53 <neutrino_> you can look at examples of things that are monads / monoids / applicative / categories / etc and contrast. then, after a lot of examples, i think you can start reasoning on the "understanding monads" level
06:58:15 <neutrino_> but that final step is not something a beginner to haskell or FP should be doing
06:58:20 <Philippa_> hah! I had to "understand monads" before applicative functors were a published thing
06:58:32 <srhb> mSSM: main = do { m <- makeYourMutableVector; let x = Foo 2 m; let y = Foo 4 m; return () }
06:58:32 <neutrino_> since they need that big amount of context
06:58:49 <srhb> mSSM: Something like that?
06:58:49 <mSSM> srhb: does that even make sense to create a data structure holding a mutable vector in addition to some pure variables holding information about that mutable vector?
06:58:54 <Philippa_> eh. They need a moderate amount. Understanding the idea of a "simple let binding" and of an "embedded language"
06:58:58 <srhb> mSSM: No, that's not possible
06:59:28 <srhb> mSSM: That would be like saying that you can know the count of files on the file system without ever reading it.
06:59:52 <Philippa_> now, language embedding is a big deal by programming newbie standards? But not necessarily to all Haskell newbies. Was old news to me when I was first deciphering the quicksort that Graham Hutton showed in the intro FP lecture
07:01:43 <mSSM> srhb: What I have is: `main = do { m <- makeMutableVector; let x = Foo 2 m; unsafeWrite 3 10 m; let y = Foo 4 m; return () }
07:02:16 <mSSM> srhb: But yeah, I suppose your example makes sense.
07:02:40 <Philippa_> amusingly, language embedding is (slightly implicitly) a big deal in OO. A lot of people turn out to have the intuitions to match, too
07:03:01 <mSSM> srhb: Just that instead of let x and let y, I have an iteration which makes x' from x, and then uses x' to make x'', etc...
07:05:17 <srhb> mSSM: But of course the Int in Foo still has no correspondence with the contents of m
07:05:59 <mSSM> srhb: ok, in this case. Let's say in between I have `n = mySum m', and then `let x = Foo n m'
07:06:30 <srhb> mSSM: more like n <- mySum m
07:06:48 <mSSM> srhb: yes, of course.
07:06:58 <srhb> mSSM: As long as you stay in the do block you're fine.
07:07:25 <srhb> mSSM: You'll never be able to return a pure value from that from your function. But you may not need to. I don't know.
07:07:33 <mSSM> srhb: but does haskell now make a complete copy of m?
07:07:41 <srhb> mSSM: No
07:07:49 <mSSM> srhb: good :D
07:07:51 <srhb> Or, well..
07:07:53 <srhb> Actually I'm in doubt
07:07:59 <srhb> I assume it must, in fact.
07:08:19 <srhb> Unless you use an IORef or something. Hm.
07:08:50 <srhb> I think someone else needs to weigh in here, I don't know if mutable vectors are references in that sense. I would not assume so.
07:10:49 <craigInnes> hi guys, I am trying to write a program which is able to compile text that a user enters as if it were a haskell source file and then runs a function within it. I am attempting to use the GHC API to do this but am running into a "cannot find module" error with my current function implementation. Can anyone help? http://pastebin.com/Sz7g1uY5
07:10:53 <mauke> The paste Sz7g1uY5 has been copied to http://hpaste.org/80503
07:11:04 <mSSM> srhb: because at the moment I have `iterate (Foo n m) x | x == 0 = return Foo n m | otherwise do { updateMutableVector; n' <- mySum m; iterate (Foo n' m) (x-1)}
07:11:27 <mSSM> srhb: I think this one actually shows my problem.
07:12:16 <srhb> mSSM: I'm scared to say something wrong now because of my lack of knowledge of mutable vectors. I think you should wait for someone else to respond.
07:13:06 <mSSM> srhb: ok, thank you :)
07:13:26 <mSSM> srhb: you know what - I think my question is silly.
07:13:38 <srhb> mSSM: I have a feeling it is, but yeah... :P
07:13:50 <beaky> how does pattern matching work
07:13:52 <mSSM> srhb: I am essentially trying to use the same algorithm just with a ompletely different representation of my data.
07:13:55 <fmap> craigInnes: did you see hint?
07:14:03 <fmap> @hackage hint
07:14:03 <lambdabot> http://hackage.haskell.org/package/hint
07:14:16 <srhb> mSSM: You probably shoud alter your algorithm, yes.
07:14:18 <mSSM> srhb: It doesn't make sense to pass the mutable vector over and over
07:14:21 <srhb> No.
07:14:31 <mSSM> One pass is enough obviously.
07:14:33 <mSSM> :D
07:14:58 <mercer> what is the point of undefined?  just to test if something is being evaluated?
07:15:10 <mSSM> beaky: http://learnyouahaskell.com/syntax-in-functions
07:15:30 <johnw> mercer: what do you mean?
07:16:25 <fmap> craigInnes: in particular `eval' function: http://hackage.haskell.org/packages/archive/hint/0.3.3.5/doc/html/Language-Haskell-Interpreter.html#v:eval
07:16:25 <beaky> does the implementation compile patterns into vtables/jump tables?
07:16:26 <craigInnes> fmap: thanks for the link. From looking at the api for hint, am I to understand that this essentially does what I was asking for without having to directly use the ghc api at all?
07:16:30 <mercer> is there a use of `undefined' besides checking if something is being evaluated?  eg. True || undefined
07:16:56 <fmap> craigInnes: I'd guess so, haven't use it
07:16:56 <merijn> mercer: Sometimes syntax demands a value, even though you can't provide one
07:16:57 <johnw> mercer: while coding, undefined is a great place-holder, since it always matching the expected type
07:17:36 <merijn> i.e. generating an array but not setting every value yet? undefined as default value (of course this means you need to be *sure* that it'll be updated before use)
07:17:55 <merijn> And, yes, undefined is also a great placeholder for "code I haven't written yet"
07:18:15 <johnw> merijn: every value for an array won't be set anyway, until you evaluate every member
07:18:32 <fmap> craigInnes: you may also want to take a look at mueval, it provides safe sandbox around hint
07:18:38 <fmap> @hackage mueval
07:18:38 <lambdabot> http://hackage.haskell.org/package/mueval
07:18:47 <merijn> mercer: I frequently start projects by writing function names and type signatures and just defining them as "undefined". Then I can do stuff like "map (foo . bar) baz" even though I haven't defined foo, bar or baz yet
07:19:10 <merijn> mercer: And the type checker will guarantee the combinations I wrote are sensible, even if they have no implementation yet
07:19:16 <johnw> merijn: I do that too
07:19:20 <mercer> merijn what is the point of doing that if your code just crashes?
07:19:29 <ziman> seeing whether it typechecks
07:19:31 <johnw> mercer: because it type checks
07:19:41 <johnw> and then you can provide the implementations iteratively
07:19:53 <johnw> by writing tests, and then replacing 'undefined's until every test passes
07:20:09 <merijn> mercer: You don't have to think about *how* you will implement things yet, you can start sketching a top-level view of your code, without worrying about *how* yet
07:20:24 <merijn> mercer: Frequently you know *what* you want a function to, just not yet how to write that
07:20:39 <merijn> mercer: And you can start writing other functions using functions you haven't implemented yet.
07:20:56 <craigInnes> fmap: Thanks. When these libaries talk about "evaluating expressions" does this mean simply that they  can evaluate like a single function from a source listing in isolation, or does it mean they can evaluate it with respect to all the other imports, definitions etc. listed in that particular source file
07:21:18 <merijn> mercer: Of course you need to implement them eventually, but this lets you postpone that while still letting you typecheck whether what you have so far is correct
07:23:45 <mercer> I am asking because argument for Maybe over implicit null references is because Maybe forces you to deal with possibility of null (Nothing), while implicit null references don't, they can sneak in everywhere. but undefined can sneak in everywhere too, I'm not getting why null references are obviously bad but undefined isn't.
07:23:52 <merijn> mercer: For example, you're writing a chess game. It's clear that you want to have, for example, a function "validateMove :: Move -> Board -> Bool", but you don't know yet what the Move and Board datatypes will look like. So you define "data Move; data Board; validateMove = undefined" and then you can write game logic, without having to know what you want Move/Board/validate to be yet
07:24:16 <fmap> craigInnes: the latter, apparently: lambdabot uses mueval and does have imports
07:24:31 <merijn> mercer: undefined *is* bad, it's just a neat tool for prototyping
07:24:52 <mercer> so you would just use undefined to see if your code compiles, if types are matching
07:24:57 <merijn> mercer: Yes
07:25:14 <johnw> think of undefined as importing from the future ;)
07:25:23 <mercer> ok that makes sense
07:25:36 <merijn> If my "selectMove" function type checks using validateMove then I know it'll work, even though validateMove is currently absent.
07:26:00 <johnw> also, if there are function results whose behavior really is "undefined", then you can return undefined
07:26:31 <merijn> johnw: You should just use error in those cases
07:26:41 <johnw> you can, or you can use undefined
07:26:43 <merijn> > error "Whoops, something broke!"
07:26:45 <lambdabot>   *Exception: Whoops, something broke!
07:27:12 <HugoDaniel> is it possible to have ghc do bounds check in compile time for the functions that index a constant list ?
07:27:15 <johnw> for example, if I divide something by zero, is that an error, or is it undefined?
07:27:33 <jason1> so you would use undefined in the place of throwing "Not yet implemented"  exception in other languages?
07:27:41 <johnw> 'error' is just a labeled undefined
07:27:47 <fmap> mercer: undefined isn't like null reference, you can't say "if something == undefined then this else that"
07:27:50 <johnw> jason1: precisely
07:27:52 <merijn> mercer: Anyway, the point is not "null is bad, undefined is good" and more "null bad, undefined bad, but useful"
07:28:14 <srhb> jason1: I would never do that. use error instead, if you must, so that you can say what happened
07:28:16 <fmap> well, you can, but that won't do what you may expect it to do
07:28:21 <mercer> yeah I got it
07:28:53 <srhb> johnw: I don't understand under which circumstances what you are saying would be a good idea.
07:28:55 <merijn> mercer: I think I've only seen 1 or 2 uses of undefined in actual finished code, for some obscure corner-case reason
07:29:03 <johnw> srhb: what, using undefined instead of error?
07:29:18 <srhb> johnw: Yes, like in your division by zero example. Of course error "Division by zero!" is better than undefined.
07:29:19 <merijn> srhb: I'm often to lazy to type a message for error >.>
07:29:21 <wuttf> how can I      [a] -> Either String [b] When I have a function  a -> Either String b
07:29:29 <srhb> merijn: That doesn't make it good practice :P
07:29:39 <srhb> wuttf: map?
07:29:41 <startling> :t sequence
07:29:42 <srhb> oh, no
07:29:42 <lambdabot> Monad m => [m a] -> m [a]
07:29:45 <merijn> srhb: No, look at the type
07:29:49 <srhb> Yep, I saw. :P
07:30:00 <wuttf> srhb: Yes.
07:30:01 <johnw> sometimes a function is generic enough that the error message isn't going to be descriptive enough to matter, but probably you are right
07:30:10 <startling> :t mapM
07:30:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
07:30:12 <johnw> at least you can mention what function the error happened in
07:30:19 <startling> wuttf: ^
07:30:35 <wuttf> startling: =) Neat.
07:30:40 <merijn> :t mapM (undefined :: a -> Either String b)
07:30:40 <srhb> johnw: If you can say something about where or why, then surely it is better than undefined, always. If you can't, sure. I doubt that will ever happen.
07:30:41 <lambdabot> [a] -> Either String [b]
07:30:56 <merijn> mercer: See here another neat use of undefined ;)
07:31:03 <johnw> oh, srhb reminded me
07:31:15 <johnw> you can use undefined to pass type information
07:31:17 <wuttf> OMG you haskellers...
07:31:21 <srhb> johnw: Right :)
07:31:23 <johnw> sizeOf (undefined :: Int)
07:31:39 <srhb> johnw: Though that's a completely different use.
07:31:43 <johnw> yeah
07:31:54 <srhb> Morale: Don't use undefined when you mean error. :P
07:32:08 <johnw> that's something I just did recently, but in this case constructing a value is sometimes a chore, so undefined is the right option
07:32:09 <merijn> wuttf: Embrace the laziness of not writing boilerplate when you can avoid it :)
07:32:22 <johnw> Moral: Don't say morale when you mean moral.
07:32:27 <covi> How can I express "ignore everything from this point to the end of the line" in Parsec?
07:32:45 <srhb> johnw: Thanks, language barrier.
07:32:57 <startling> covi: isn't there skipUntil?
07:32:57 <wuttf> merijn: I do I do.
07:32:59 <merijn> covi: something along the lines of "many (not eol)" (not valid syntax (I think))
07:33:00 <srhb> johnw: (exactly the opposite in mine :P)
07:33:43 <Philippa_> covi: there's a combinator that does something like "many until" in the combinators module, IIRC?
07:33:43 <covi> startling: I didn't see skipUntil in the doc http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
07:33:58 <merijn> wuttf: As a short explanation, "Either String" is the (an) error monad, i.e. monad for potentially failing computation. It behaves kinda like Maybe, but reporting an error String instead of Nothing
07:33:59 <Philippa_> yeah, but you can skip by ignoring the result list
07:34:11 * hackagebot penny-bin 0.6.2.0 - Extensible double-entry accounting system - binary and documentation  http://hackage.haskell.org/package/penny-bin-0.6.2.0 (OmariNorman)
07:34:16 <shachaf> johnw: Proxy seems nicer than undefined for that.
07:34:31 <covi> merijn: `eol' is not defined
07:34:57 <merijn> covi: That was supposed to be pseudo code :)
07:35:11 <wuttf> merijn: I know, thats why I chose it. I am rewriting a package which threw exceptions.
07:35:14 <startling> covi: newline
07:35:24 <johnw> shachaf: for what?
07:35:32 <merijn> wuttf: Oh, also. Similar to mapM, check out the monad-loops package
07:36:13 <shachaf> johnw: foo (undefined :: Type)
07:36:20 <johnw> shachaf: how would you say that with Proxy?
07:36:32 <johnw> and Proxy from which package?
07:36:41 <covi> startling: thanks
07:36:45 <shachaf> johnw: tagged
07:36:50 <shachaf> data Proxy a = Proxy
07:37:03 <Athas> Hm, what's a good way to parse a Haskell module?  I will need to chase imports as well in order to get operator fixity right.
07:37:04 <shachaf> foo (Proxy :: Proxy Type)
07:37:05 <srhb> Oh, neat
07:37:14 <johnw> shachaf: that's better how?
07:37:31 <shachaf> That way you have no ⊥s in your program.
07:37:43 <johnw> and you add a library dependency
07:37:48 <srhb> No.
07:37:48 <Athas> There is a parser in haskell-src-exts, and I could probably use the GHC API to chase library modules, but that will not be sufficient.
07:38:00 <srhb> data Proxy a = Proxy is all it takes
07:38:10 <johnw> ah
07:38:24 <shachaf> johnw: You don't even need the library dependency for consuming Proxy.
07:38:48 <srhb> I didn't know that trick, it's so obvious once you see it. :P
07:39:00 <shachaf> foo :: proxy a -> ... -- Note the lowercase p.
07:39:49 <fmap> oh, tagged defines asProxyOf...
07:39:53 <Athas> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/GHC-TopHandler.html is a 404.  Why might that be?
07:40:09 <elliott> Theoretically you can just define all your functions consuming proxy a -> ... and then use (b -> b) as "proxy b" everywhere.
07:40:20 <elliott> The actual type and functions are just convenience.
07:40:35 <shachaf> elliott: Oh, good point.
07:40:39 <shachaf> (The (b -> b) thing.)
07:41:13 <johnw> shachaf: Proxy, without the lib dependency, doesn't work with siveOf
07:41:18 <johnw> I get No instance for (Storable (Proxy Int))
07:41:37 <johnw> so it's really not adding any convenience, simply to avoid having an undefined
07:41:45 <shachaf> johnw: Yes, sizeOf isn't defined to use Proxy.
07:42:01 <shachaf> It's defined to use undefined.
07:42:12 <shachaf> You can tell that from the type.
07:42:22 <shachaf> It's a bit unfortunate. All I'm saying is that Proxy is nicer.
07:42:33 <johnw> where nicer means shachaf prefers it :)
07:42:48 <covi> startling: How can i implement the skipping part? "skip until newline"
07:43:08 <johnw> covi: often one does manyTill anyChar (try (char '\n'))
07:43:15 <johnw> or something similar
07:43:23 <johnw> i'm surprised that parsec doesn't have skipUntil, like trifecta does
07:43:32 <shachaf> johnw: I think it's pretty common to try to have fewer ⊥s in your program if you can.
07:43:36 <startling> johnw: yeah, me too.
07:43:43 <elliott> shachaf: I've used the id-as-Proxy thing before in actual code, I think.
07:43:47 <startling> covi: manyTill
07:43:48 <elliott> shachaf: The problem is your type gets double the length.
07:43:52 <shachaf> elliott: Right.
07:43:59 <elliott> Is there a better way to do it using only base?
07:44:11 <johnw> shachaf: I type more undefineds, while playing "I like big butts" in the background
07:44:12 <shachaf> (b ~ ...) => b -> b?
07:44:14 <covi> johnw: thanks
07:44:17 <elliott> You can use (Void -> a) as proxy a and then you just use absurd, but then you're depending on an edwardk package again.
07:44:21 <elliott> shachaf: Ew.
07:44:25 <elliott> I mean a better pick for "proxy".
07:44:30 <mauke> covi: many (noneOf "\n")
07:44:42 <johnw> mauke: oh, that's good
07:44:45 <Philippa_> shachaf: I can't help but think we need more than one kind of equality constraint at times
07:45:02 <shachaf> johnw: OK, I'll stop telling you when I think there's a nicer option.
07:45:10 <johnw> shachaf: i'm just teasing you
07:45:19 <edwardk> johnw: did you notice i picked up trifecta development again?
07:45:23 <johnw> shachaf: i prefer hearing what you think are nicer options, over hearing just what you think are bad options :)
07:45:32 <Philippa_> edwardk: cool!
07:45:37 <johnw> edwardk: yes!  i pulled several commits this morning
07:45:45 <startling> everyone in #haskell-lens notices, too! at length
07:45:45 <johnw> had to build lens from Git to build trifecta, though
07:45:46 <shachaf> edwardk: Does "development" mean "documentation"?
07:45:58 <elliott> He added some lenses too!
07:45:58 <shachaf> Or is "It is a cofree comonad" still the only comment?
07:46:03 <ski> Philippa_ : hm, why ?
07:46:04 <Philippa_> (I picked up two-level-constraints dev on the train earlier, not that I've pushed it yet - that, and mostly it was just adding a cofree comonad to go with the specialised free monad)
07:46:09 <startling> shachaf: hahaha
07:46:20 <elliott> Philippa_: good timing with "cofree comonad" there
07:46:38 <elliott> all the rage
07:46:50 <Philippa_> elliott: heh. Well, I was going to add all but extend /anyway/
07:47:23 <Philippa_> (plus it's renamed as Annotation, because I'm taking a domain-specific approach to naming all the functors flying everywhere)
07:47:41 <edwardk> shachaf: yes
07:48:00 <edwardk> shachaf: (yes, i'm adding docs)
07:48:09 <edwardk> johnw: yeah, i'm switching a lot of it over to using lenses
07:48:25 <edwardk> eventually i'll do the same with highlights in parsers
07:48:35 <Philippa_> elliott: it's kinda weird, actually. Most of the lib is abstract syntax gadgetry so far
07:48:35 <edwardk> once they are a prism then we can have an open set of highlights
07:48:55 <ski> Philippa_ : i.e. why more than one kind of equality constraint ?
07:49:12 <johnw> edwardk: is that just to make the code nicer, or will it change the API to?
07:49:27 <Philippa_> ski: to internalise ways of talking about desired solving strategies
07:49:46 <Philippa_> ("this one just exists to desugar let bindings to", say :p)
07:49:51 * ski doesn't follow
07:50:12 <Philippa_> so if you have one that just exists for let desugaring, you may as well just substitute on sight
07:50:22 <Philippa_> these days, GHC has constraints that it chooses to defer
07:51:14 <Philippa_> I figure the more we can talk about how we want things figured out, the more we might be able to get it to figure out the things we want without making a huge mess
07:56:44 <hpaste> Peter pasted “Fasto” at http://hpaste.org/80505
07:56:54 <mercer> > sqrt 9 :+ 4
07:56:56 <lambdabot>   3.0 :+ 4.0
07:56:58 <mercer> > sqrt (9 :+ 4)
07:57:00 <lambdabot>   3.0699232728030927 :+ 0.6514820802585842
07:57:03 <mercer> what is up with this?
07:57:19 <linduxed> hey guys
07:57:41 <mercer> why does sqrt apply only to 9 in the first example?
07:57:45 <merijn> mercer: Function application always binds tighter than operators
07:57:56 <linduxed> i was thinking of starting to do tests for my code, but i'm not familiar with the different frameworks available for haskell
07:58:15 <merijn> mercer: Similarly
07:58:16 <linduxed> i've heard of hunit, but not sure if that's the one i should start with
07:58:24 <merijn> > length [1..5] ++ [1..]
07:58:26 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:58:26 <lambdabot>              with actual type ...
07:58:50 <mercer> ok thanks
07:58:52 <parcs> mercer: sqrt 9 :+ 4 === (sqrt 9) :+ 4
07:59:07 <mercer> I thought 9 :+ 4 is a complex number literal
07:59:12 * hackagebot mcmc-synthesis 0.1.1.1 - MCMC applied to probabilistic program synthesis  http://hackage.haskell.org/package/mcmc-synthesis-0.1.1.1 (TikhonJelvis)
07:59:16 * linduxed is mostly asking because he doesn't know if the testing packages are as numerous as they are in ruby, for instance
07:59:34 <parcs> mercer: no, :+ is a regular infix data constructor, like (:)
07:59:50 <merijn> :t (:+)
07:59:51 <lambdabot> a -> a -> Complex a
08:00:17 <merijn> :t (9 :+)
08:00:19 <lambdabot> Num a => a -> Complex a
08:02:17 <jason1> > fmap (+1) []
08:02:19 <lambdabot>   []
08:03:27 <jason1> > fmap (fmap (+10)) []
08:03:28 <lambdabot>   No instance for (GHC.Show.Show (f0 b0))
08:03:28 <lambdabot>    arising from a use of `M64098079...
08:03:47 <jason1> how come one works but not the other
08:05:09 <merijn> :t fmap (fmap (+10)) []
08:05:10 <lambdabot> (Functor f, Num b) => [f b]
08:05:28 <Wizek> Is there a way I ven reach fn1 from the outside: `fn = fn1 . fn2 where fn1 = foo; fn2 = bar;` ,
08:05:31 <Wizek> ?
08:05:37 <Wizek> *can
08:05:50 <merijn> jason1: Lists are only printable if their contents are printable, since that code doesn't know *which* functor you are using, it doesn't know whether that functor is printable
08:06:07 <shachaf> "reach"?
08:06:18 <merijn> > fmap (fmap (+10)) ([] :: Num a => [Maybe a])
08:06:20 <lambdabot>   []
08:06:37 <Wizek> shachaf: call, invoke?
08:06:46 <merijn> jason1: Saying the list is (for example) Maybe, which is a printable functor makes the result printable too
08:06:53 <Wizek> I don't think I know the proper terminus yet
08:07:01 <merijn> jason1: Still following?
08:07:10 <jason1> yes
08:07:56 <merijn> jason1: In other words, the double fmap is to polymorphic to know how to print without more info, which is why "it doesn't work" (it does, but not if you run it in GHCI/lambdabot as those implicitly try to print any results)
08:08:13 <jason1> I got a bit different error, about ambiguous type, but I guess it boils down to the same thing
08:08:13 <shachaf> Wizek: I was wondering not what the terminus was, but what you were trying to do.
08:08:26 * `nand` .oO( -XDefaultFunctorToIdentity )
08:08:26 <shachaf> Wizek: The answer is not really. fn is its own function, indepdendent of how you built it up.
08:08:47 <merijn> jason1: Yeah, it probably referred to not knowing which Functor to pick
08:09:02 <Wizek> shachaf: so I have to define fn1 outside of fn, right?
08:09:19 <shachaf> Wizek: I have no idea what you have to do.
08:10:34 <Wizek> I think I got the answere I asked for, thanks shachaf
08:26:56 <wuttf> Why can't I catch exceptions outside of IO monad? Because we can't determine if the exception is thrown by a random hardware error or by program logic? That's the only reason I could think of
08:27:20 <S11001001> wuttf: because exceptions are side-effects
08:27:33 <merijn> wuttf: Because they are observable side effects
08:28:11 <LadyAurora> wuttf: because you shouldn't be using them :P
08:28:11 <merijn> wuttf: Suppose I have an expression throwing action foo, then running foo multiple times can produce different results (depending on whether an exception was thrown or not)
08:28:13 <S11001001> wuttf: i.e. don't use exceptions for reporting errors in pure processes
08:28:51 <merijn> LadyAurora: Why not? Exceptions are perfectly sensible, just not for functions
08:29:01 <S11001001> > length [error "boom", error "no really boom"]
08:29:02 <lambdabot>   2
08:29:13 <S11001001> ^^^ because they aren't a reliable error-reporting mechanism
08:29:45 <shachaf> foo() { if(false) { error("boom"); } return 5; }
08:29:52 <LadyAurora> S11001001: that's more like "I don't understand Haskell's evaluation semantics" than "exceptions are not reliable error-reporting mechanism".
08:29:56 <bitonic> S11001001: what’s that supposed to prove?
08:30:18 <LadyAurora> merijn: because IO
08:30:26 <LadyAurora> merijn: if you're already in IO, then fine.
08:30:57 <wuttf> merijn: I don't get it, if the fact that an exception is thrown only depends on arguments, then for same arguments the result will be always the same (either exception or not).
08:31:04 <S11001001> bitonic: that sequence on Either e is a much better choice
08:31:14 <ion> Integers aren’t a reliable number-summing mechanism:
08:31:15 <merijn> wuttf: Not all exceptions depend on arguments
08:31:19 <ion> > let a = 5 + 5 in "nope"
08:31:20 <lambdabot>   "nope"
08:31:28 <wuttf> merijn: Then we should differentiat between them!
08:31:35 <LadyAurora> ion: integers aren't reliable at all:
08:31:39 <LadyAurora> > let 5 = 6 in 5
08:31:41 <lambdabot>   5
08:31:45 <merijn> wuttf: We do, we use Either/Maybe/etc for those that only rely on arguments :)
08:31:47 <shachaf> > set (upon (\l -> l!!0 `seq` l!!1 `seq` undefined)) 5 [1,2,3,4]
08:31:48 <lambdabot>   [5,2,3,4]
08:31:49 <shachaf> > set (upon (\l -> l!!1 `seq` l!!0 `seq` undefined)) 5 [1,2,3,4]
08:31:51 <lambdabot>   [1,5,3,4]
08:32:13 <bitonic> S11001001: that purely depends on how the user uses `error'.  `error' and `Either' are so different that they are hardly comparable
08:32:39 <srhb> shachaf: What!
08:32:51 <merijn> wuttf: If you want pure exception those data types work perfectly fine
08:33:45 <srhb> :t upon
08:33:46 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] k) => (s -> a) -> k (a -> f a) (s -> f s)
08:34:11 <wuttf> merijn: But it would be so handy. And, I am no guru, but if we could differentiate between exceptions caused by hardware (random, nondeterministic ones) and exceptions thrown by program logic, it would be possible to write code, which is referentially transparent, but throws and catches exceptions inside it.
08:34:15 <srhb> o_o
08:34:24 <shachaf> srhb: Oh, you haven't seen upon? It's pretty great.
08:34:25 <S11001001> bitonic: the point is that types will tell you when you need to propagate Either e, they won't tell you to propagate exceptions
08:34:29 <merijn> wuttf: How is that different from returning Maybe?
08:34:34 <ion> > set (upon (fst . (!!1))) 0 [(1,2), (3,4), (5,6)]
08:34:36 <lambdabot>   [(1,2),(0,4),(5,6)]
08:34:56 <bitonic> S11001001: that is still vague.  if you understand `error', you understand your example
08:34:57 <srhb> woah, funky.
08:35:05 <shachaf> > let mylast [x] = x; mylast (_:xs) = mylast xs in set (upon mylast) 'x' "hello there"
08:35:07 <lambdabot>   "hello therx"
08:35:20 <S11001001> bitonic: types check understanding
08:35:47 <wuttf> merijn: I am too lazy (and stupid) to juggle maybes and eithers.
08:35:51 <bitonic> S11001001: `error' is perfectly typesafe.  Haskell is typesafe
08:35:56 <shachaf> wuttf: Exceptions expose evaluation order and all sorts of things that shouldn't be exposed.
08:36:11 <merijn> wuttf: You don't really have to, write all your code pure and then "fmap" it over the place that can return a Maybe
08:36:13 <srhb> shachaf: How is that even possible. o_o
08:36:22 <merijn> wuttf: Otherwise, use do notation + Maybe monad
08:36:24 <shachaf> srhb: It's not. You're dreaming.
08:36:27 <mauke> wuttf: nondeterministic exceptions are thrown by program logic, not hardware
08:36:34 <LadyAurora> If I want to make a global IORef (evil cubed!), is something akin to "foo = unsafePerformIO $ newIORef 0; {-# NOINLINE foo #-}" a proper way to do it?
08:36:42 <merijn> LadyAurora: Yeah
08:36:57 * srhb has another major case of brainsplode
08:37:00 <bitonic> S11001001: note that I don’t advocate using `error' instead of Either, I personally use `error' only for “impossibilities” and unimplemented stuff
08:37:31 <S11001001> bitonic: same here
08:37:42 <shachaf> srhb: It uses unsafePerformIO, if that makes you feel better.
08:37:47 <byorgey> srhb: don't worry, I have no idea how it works either
08:37:55 <LadyAurora> It'd go awry without the NOINLINE pragma, right?
08:37:56 <wuttf> Okay, I will stick to maybe then.
08:38:00 <srhb> shachaf: It does, thanks :P
08:38:02 <byorgey> hahaha
08:38:03 <srhb> byorgey: Phew!
08:38:27 <shachaf> srhb: Also, it uses exceptions. Which is why I brought it up in the middle of the exception discussion.
08:38:45 <srhb> Sounds like a proper abomination :P
08:38:52 <byorgey> haha, that sounds so dirty
08:39:07 <mauke> if it doesn't use brute force, I'm disappointed
08:39:19 * hackagebot PBKDF2 0.3.1.1 - Make password-based security schemes more secure.  http://hackage.haskell.org/package/PBKDF2-0.3.1.1 (ErikHesselink)
08:39:21 <ski> @wiki Global variables
08:39:21 <lambdabot> http://www.haskell.org/haskellwiki/Global_variables
08:39:22 <ski> @wiki Top level mutable state
08:39:22 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state
08:39:27 <ski> LadyAurora : see those ^
08:39:35 <shachaf> What it does is use Data.Data.Data to traverse the structure and replace every part of it with an exception tagged with an index.
08:39:47 <shachaf> Then it evaluates your function and checks which exception was thrown.
08:39:59 <shachaf> Then it traverses the structure again and sets that index to the new value.
08:40:46 <tac> I like proposal 2
08:40:51 <srhb> shachaf: Yeah I actually guessed it was something like that once you said exceptions. You should see me now.
08:41:05 <mauke> > set (upon (!! 1)) 'X' "abcd"
08:41:06 <tac> stick a readerT monad in there and you're golden
08:41:06 <lambdabot>   "aXcd"
08:41:39 <LadyAurora> shachaf: Data.Data.Data is the Haskell equivalent of badger badger badger?
08:41:54 <shachaf> (Actually it does something slightly more involved to make nesting work.)
08:41:55 <mauke> > set (upon (\x -> x !! 1 + x !! 2)) 0 [1, 2, 3, 4]
08:41:57 <lambdabot>   [1,0,3,4]
08:41:58 <byorgey> shachaf: haha, awesome
08:42:08 <shachaf> mauke: Yep, it exposes evaluation order.
08:42:40 <shachaf> I wanted to extend it to set *all* the values that you force, rather than just one.
08:43:07 <shachaf> But on the other hand what's the point.
08:43:19 <shachaf> (It wouldn't be that hard, though.)
08:44:07 <shachaf> Oh, and there's a bug with nested upons.
08:44:08 <basdirks> > :t sqrt 10
08:44:10 <lambdabot>   <hint>:1:1: parse error on input `:'
08:44:14 <basdirks> @ty sqrt 10
08:44:15 <lambdabot> Floating a => a
08:44:18 <shachaf> If you want to be a good citizen you should fix it!
08:44:20 <basdirks> why is this not Float
08:44:27 <shachaf> @ty sqrt
08:44:28 <lambdabot> Floating a => a -> a
08:44:32 <basdirks> yes nvm
08:44:34 <basdirks> =D
08:45:08 <mauke> nothing should be Float
08:45:18 <ski> @type sqrt 10 :: Complex Double
08:45:20 <lambdabot> Complex Double
08:45:59 <srhb> @index upon
08:46:00 <lambdabot> bzzt
08:46:00 <wuttf> Everyone said learn Haskell. It will be fun they said. Now I hate dynamic languages because they do no compile time type check. And hate static languages because they require dumb type annotations.
08:46:02 <mmaruseacph2> :t upon
08:46:03 <srhb> meep.
08:46:03 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] k) => (s -> a) -> k (a -> f a) (s -> f s)
08:46:05 <wuttf> I want my money back.
08:46:06 <srhb> Ah
08:46:13 <shachaf> srhb: Data.Data.Lens
08:46:32 <LadyAurora> wuttf: Haskell is static and doesn't require dumb type annotations.
08:46:43 <shachaf> @ty onceUpon
08:46:44 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f, Indexable Int k) => (s -> a) -> k (a -> f a) (s -> f s)
08:46:51 <neutrino_> i have found that in the glagolitic notation of old church slavonic, there are single-letter words for the quantifiers "exists" and "forall" and they look similar to the ones we use.
08:47:09 <shachaf> > itoListOf (upon (!!4)) "hello there"
08:47:11 <lambdabot>   [([4],'o')]
08:47:16 <shachaf> > itoListOf (upon (tail.tail)) "hello there"
08:47:18 <lambdabot>   [([0,0],"llo there")]
08:47:21 <wuttf> LadyAurora: That's why I want my money back. After this, I can't go back to either of those.
08:47:22 <shachaf> Hmm.
08:47:28 <shachaf> > itoListOf (upon (tail.drop 2)) "hello there"
08:47:30 <lambdabot>   [([0,0,0],"lo there")]
08:47:30 <tac> wuttf: Haskell is able to infer 99% of your type annotations automatically.
08:47:50 <neutrino_> tac: except for the ones where you get fifty pages of type errors
08:47:54 <neutrino_> such as when using lens
08:47:55 <wuttf> tac: see my last msg
08:47:56 <neutrino_> :P
08:47:59 <shachaf> > itoListOf (upon (snd.drop 2)) [(1,2),(3,4),(5,6),(7,8)]
08:48:01 <lambdabot>   Couldn't match expected type `(a0, b0)' with actual type `[a1]'
08:48:19 <tac> neutrino_: I never felt any need for any lenses.
08:48:28 <tac> They seem like fad programming at its finest
08:48:31 <neutrino_> have you spoken to your optometrist about this?
08:48:32 <LadyAurora> wuttf: no refund, since the complaint is invalid. You hate static languages because they require dumb type annotations, but Haskell it one of them and it doesn't require type annotations most of the time.
08:48:36 <shachaf> > itoListOf (upon (snd.head.drop 2)) [(1,2),(3,4),(5,6),(7,8)]
08:48:38 <lambdabot>   [([5],6)]
08:48:46 <shachaf> > itoListOf (upon (snd.head.tail.tail)) [(1,2),(3,4),(5,6),(7,8)]
08:48:49 <lambdabot>   [([5],6)]
08:48:51 <shachaf> Oh, right.
08:48:53 <shachaf> Anyway.
08:49:09 <qasd> whats a nicer way for retarded?
08:49:26 <wuttf> LadyAurora *most static languages, but not Haskell of course. I am too stupid for haskell, but I need a static language with Hindley-Milner.
08:49:32 <neutrino_> qasd: ??
08:50:05 <LadyAurora> wuttf: in this case, I'll gladly return you the $0 you paid me.
08:50:35 <neutrino_> wuttf: prolog
08:50:36 <tac> wuttf: Try Ocaml/F#
08:50:39 <qasd> neutrino_: it sounds kinda harsh, i want to tell a story with a retarded person involved but retarded sounds mean
08:50:48 <tac> wuttf: Same type system. Not as... Haskelly....
08:50:57 <qasd> is there a word for retarded that isnt necessarily condescending
08:51:07 <neutrino_> qasd: oh, you mean what a better word is
08:51:09 <neutrino_> "handicapped"
08:51:10 <ski> qasd : perhaps "retarded" ?
08:51:12 <Eelis> qasd: so you thought "i need another word for 'retarded', where should i go... oh wait, #haskell of course!" ?
08:51:13 <mauke> qasd: you seem to be in the wrong channel
08:51:29 <wuttf> OCaml has no threading support, F#, well I am thinking about that, but I hate Micro$oft. The F# tutorial begins with: "Download SilverLight". Oh, sure...
08:51:32 <basdirks> qasd: mentally challenged
08:51:59 <neutrino_> wuttf: they fund your haskell fun
08:52:00 <tac> wuttf: You're painting yourself into a pretty narrow window.
08:52:01 <ski> qasd : maybe "slow" ?
08:52:12 <wuttf> neutrino_: Is Prolog actually a usable language?
08:52:16 <monochrom> I propose "dailywtf" as a substitute for "retarded", but I am not sure which one is more condescending :)
08:52:23 <S11001001> wuttf: F# works fine on Mono with the github.com/fsharp/fsharp install, join ##fsharp if interested
08:52:31 <psii> qasd: differently gifted :)
08:52:59 <rodrigovidal> wuttf: access the F# Foundation website at http://fsharp.org
08:53:02 <ski> wuttf : i've talked to someone who uses it for Second Life
08:53:29 <monochrom> ocaml has a posix thread library
08:53:31 <wuttf> neutrino_: Well, they have the resources from selling a shit OS for money and spreading FUD abou competitors I guess.
08:53:46 <shachaf> wuttf: This isn't really the channel for that.
08:53:53 <wuttf> tac: Yes, I know that.
08:54:37 <wuttf> shachaf: Sorry.
08:56:18 <wuttf> rodrigovidal: Thank you for that link.
08:58:34 <qasd> ah, special or challenged. much better words
09:14:02 <YoYo_> what is going on
09:14:21 * hackagebot dawg 0.9 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.9 (JakubWaszczuk)
09:15:25 <HugoDaniel> 'sup dawg ? :D
09:15:37 <YoYo_> HugeDaniel?
09:15:49 <cr> hi yoyo
09:16:50 <HugoDaniel> YoYo_: sorry, i just saw this "hackagebot dawg 0.9 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.9 (JakubWaszczuk)"
09:17:11 <HugoDaniel> and remembered the xzibit meme
09:18:24 <YoYo_> that's cool
09:18:39 <cr> there's a meme?
09:19:10 <srhb> Haha!
09:19:15 <ion> i put a meme in your meme so you can have a meme in your meme while you have a meme in your meme
09:21:33 <srhb> Yo dawg, I heard you like currying, so I put a lambda in your lambda so you can apply while you apply... or something to that extent.
09:21:49 <__ashish__> Hi
09:33:29 <Spark> hi, i'm wondering how does the haskell lexer treat x<-1, since one can create an operator called <- in haskell, correct?
09:33:45 <LadyAurora> Spark: no.
09:34:09 <Spark> <- is not allowed?
09:34:17 <glguy> <- is for do-notation and list-comprehension
09:34:24 * hackagebot hashable 1.2.0.4 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.4 (JohanTibell)
09:34:25 <glguy> (and arrow syntax)
09:34:34 <Spark> but you can create operators that end in a -
09:35:26 <Spark> what about a>-1
09:35:37 <glguy> > let (^-) = (+) in 1^-3
09:35:38 <lambdabot>   4
09:35:57 <Spark> > 1>-1
09:35:59 <lambdabot>   Not in scope: `>-'
09:35:59 <lambdabot>  Perhaps you meant one of these:
09:35:59 <lambdabot>    `-' (imported from P...
09:36:15 <Spark> ok the lexer does what i'd exepct then
09:36:20 <Spark> i think that answers it, thanks
09:36:59 <LadyAurora> Spark: maximal munch.
09:37:00 <leksah> Hello, just to test irssi :D
09:37:20 <Spark> LadyAurora: this would suprise people who are used to languages where if (x>-1) is allowed though right
09:37:21 <LadyAurora> leksah: you're a bad program, don't start irssi on your own.
09:37:37 <Spark> this would be a greater issue for non-functional languages that are trying to steal programmers from java and c++
09:38:16 <Spark> i wonder if scala has this problem
09:38:42 <glguy> I don't think people who get turned away by 1>-2 are a coveted adoption group
09:38:43 <LadyAurora> > let a >- b = a > (-b) in 0>-2
09:38:45 <lambdabot>   True
09:56:55 <Spark> scala is the same as haskell
09:57:01 <Spark> fwiw :)
09:57:27 <Spark> hopefully programmers will accept that if you have a larger set of operators, you may need an extra space here and there
09:58:02 <johnw> such as when space is itself an operator ;)
09:58:07 <alec> some really stoned computer 'engineering' student was telling me how scala and haskell were 'the same'
09:58:53 <koala_man> are you referring to Spark?
09:59:37 <Spark> scala is the same as haskell (with respect to the elements of its design that are relevant to the discussion we 20 mins ago)
09:59:41 <Spark> better? :)
10:03:34 <johnw> please, this is #haskell, say "is the same as haskell up to isomorphism"
10:05:40 <leksah> @help
10:05:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:06:11 <HaskellGuy76> hi! trying to learn some haskell here
10:06:17 <HaskellGuy76> can anyone help me out?
10:06:26 <byorgey> HaskellGuy76: you've come to the right place!
10:06:28 <cr> hi HaskellGuy76!
10:06:33 <srhb> HaskellGuy76: Ask, and you shall receive.
10:06:34 <johnw> byorgey: oh, hey!
10:06:41 <YoYo_> I KNOW WHO YOU ARE HaskellGuy76
10:06:47 <byorgey> hi johnw!  were you looking for me the other day?
10:06:49 <srhb> o_o
10:06:50 <cr> hi YoYo_!
10:06:58 * ijp sedates YoYo_
10:07:04 <cr> hi Patrick!
10:07:31 <HaskellGuy76> hello! I am a high school student from texas and we are learning basic Haskell syntax and coding
10:07:43 <cr> due! I live in Texas too!
10:07:56 <HaskellGuy76> howdy from Texas!
10:08:05 <YoYo_> That's cool. I'm up in Iceland over here
10:08:37 <Patrickisgay> hey yall
10:08:53 <Patrickisgay> what
10:09:00 <YoYo_> excuse me but that is innappropriate
10:09:03 <Patrickisgay> man who would choose such a rude name
10:09:09 <Patrickisgay> seriously yonatan not cool
10:09:16 <johnw> HaskellGuy76: you just reminded me, I need to call a co-worker in Texas!
10:09:19 <cr> well...
10:09:22 <Patrickisgay> THANK GOD
10:09:26 <Patrickisgay> you remembered!!!
10:09:34 <YoYo_> Can you please change yur name
10:09:43 <YoYo_> I am deeply offended
10:09:56 <HaskellGuy76> very cool! We have been learning the basics, like texas ranges and list comprehensions, wondering if you have any good resources
10:10:06 <srhb> Texas ranges?
10:10:08 <srhb> What on earth are they?
10:10:21 <linduxed> srhb: learnyouahaskell...
10:10:42 <srhb> linduxed: Huh?
10:10:50 <HaskellGuy76> that's where you can define a list by not stating the whole list, [1..5] gives [1,2,3,4,5]
10:10:58 <linduxed> texas ranges is a playful reference to ranges
10:11:03 <srhb> Ah, ranges.
10:11:12 <HaskellGuy76> [1,3..7] gives [1,3.5.7]
10:11:16 <linduxed> srhb: learnyouahaskell does all kinds of stuff like that
10:11:28 <HaskellGuy76> awesome
10:11:37 <cr> wow sounds like you know your stuff haskellguy76
10:11:38 <equalityforevery> man who was that other guy
10:11:44 <equalityforevery> that's so rude of someone to make their name like that
10:11:53 <linduxed> with that said, at no point does it say that they're *actually* called "texas ranges", HaskellGuy76
10:12:05 <linduxed> HaskellGuy76: they're just "ranges"
10:12:30 <HaskellGuy76> oops sorry for the mishap!
10:12:37 <YoYo_> can i has a fstful of monads
10:12:44 <linduxed> HaskellGuy76: oh no worries
10:13:26 <linduxed> HaskellGuy76: that page does do some of those playful things from time to time, just keep an eye out for them :-)
10:13:27 <srhb> It sort of reminded me of this: http://i.imgur.com/14cYJ.jpg -- I also imagined us being invaded by bald eagles.
10:14:44 <leksah> help disjoin
10:14:58 <equalityforevery> have any of you guys read the book - "a haskell aproach to logical reasoning and maths"
10:15:19 <HaskellGuy76> how useful is Haskell actually? Can it be used like Java, or C? or is it used mostly as a side tool?
10:15:24 <cr> that book is tricky
10:15:29 <equalityforevery> YES
10:15:50 <srhb> HaskellGuy76: It's a general purpose programming language.
10:16:14 <YoYo_> That book doesn;t exist
10:16:29 <YoYo_> It's the Haskell road to logic maths and programming
10:16:45 <startling> equalityforevery: hiptobecubic thinks it's pretty bad
10:16:48 <equalityforevery> okayyyyyy sorry
10:17:01 <equalityforevery> who is hiptobecubic?
10:17:32 <Tehnix> I actually just started on the book, so I'd like if he could clarify on why it's bad :|
10:17:35 <equalityforevery> and yeah my class is using that for our Haskell independent study class it can definitely be a little much at times.
10:17:56 <YoYo_> so I have a question about maps
10:18:02 <srhb> YoYo_: Yes?
10:18:05 <equalityforevery> Tehnix, its very confusing for beginners
10:18:13 <equalityforevery> that's been my experience with it
10:18:36 <hiptobecubic> equalityforevery, it's a logic book really
10:18:39 <hiptobecubic> Not a haskell book
10:18:43 <equalityforevery> plus, if you're actually trying to learn how to implement haskell or its uses, this book is not the right one.
10:18:45 <hiptobecubic> it makes almost no effort to teach haskell
10:18:48 <Tehnix> equalityforevery: hmm, was more interested in if it taught some wrong things or such. The other thing, I'll get past
10:18:58 <Philippa_> most people don't need to know how to implement haskell!
10:19:12 <srhb> "Haskell is a member of the Lisp family" <-- I stopped reading right there :P
10:19:30 <equalityforevery> haha srhb
10:19:44 <Philippa_> so is every language with an if statement? :p
10:19:45 <brosef_stalin> hey guys
10:19:58 <srhb> Philippa_: It's a very weird statement. :P
10:20:05 <leksah> equalityforevery: Thanks a lot for naming such book. I was looking for such a topic in haskell
10:20:28 <hiptobecubic> it's nice if you want to learn logic and proof writing and things
10:20:47 <hiptobecubic> it's not nice if you want to learn haskell from scratch
10:21:02 <equalityforevery> yeah it more uses Haskell as a way of teaching complex math, proofs, and logic (i know, as the title describes) and in doing so it expects the reader to have a solid understanding of haskell previously as it doesn't explain it much, only uses it in demonstrations
10:21:17 <equalityforevery> yeah i agree with you hiptobecubic
10:21:22 <brosef_stalin> do you know of a book great for starting haskell from scratch?
10:21:27 <hiptobecubic> @where lyah
10:21:27 <lambdabot> http://www.learnyouahaskell.com/
10:21:35 <equalityforevery> that^
10:21:59 <equalityforevery> it isn't fantastic but its the best i know of.
10:22:08 <Tehnix> equalityforevery: does it cover monads though? (The road to logic book)
10:22:20 <hiptobecubic> I think it does a pretty decent job. But it's missing practice questions
10:22:23 <equalityforevery> umm im only a little over halfway through it currently
10:22:28 <srhb> Tehnix: You don't need a book to "cover" monads
10:22:32 <Tehnix> oh, k
10:22:33 <YoYo_> It does cover monada
10:22:36 <YoYo_> monads*
10:22:43 <PatrickRobotham> Monads are a special type of functor :P
10:23:02 <srhb> Monads are not even mentioned once in the logic book, I believe.
10:23:17 <Tehnix> It was more to know if it got beyond just using somewhat basic haskell to prove things
10:23:25 <yonatanisdumb> hi everyone!
10:23:33 <equalityforevery> learnyouahaskell has a whole chapter on it though
10:23:36 <hiptobecubic> pdf text search found 0 entries for 'monad'
10:23:46 <YoYo_> sorry wrong book
10:23:48 <srhb> hiptobecubic: My approach as well. :P
10:24:01 <YoYo_> learn you a haskell has monads
10:24:12 <yonatanisdumb> what are monads?
10:24:29 <erkin> Nobody really knows.
10:24:34 <erkin> We all just pretend to know it.
10:24:54 <yonatanisdumb> Ah.
10:24:54 <srhb> Monads are things that define >>= and return and obey certain laws.
10:25:01 <srhb> fsvo. things.
10:25:08 <hiptobecubic> The logic book is really not about haskell
10:25:22 <hiptobecubic> That's why it's not called the "Math and logic road to haskell"
10:25:23 <erkin> If anyone asks, just tell them monads are kinda like burritos but not exactly.
10:25:34 <hiptobecubic> they are like burritos
10:25:41 <srhb> They are so not like burritos.
10:25:45 <srhb> :P
10:25:48 <erkin> Just like that!
10:25:50 <hiptobecubic> Maybe you just make shitty burritos :)
10:26:03 <srhb> How DARE you.
10:26:05 <yonatanisdumb> okayyyyy
10:26:09 <equalityforevery> FIGHT FIGHT FIGHT
10:26:13 <YoYo_> Can we please keep this PG
10:26:17 <yonatanisdumb> woahhhhhhhh
10:26:17 <hiptobecubic> MY burritos can launch missiles
10:26:19 <srhb> Anyway, I think we're letting ourselves be carried off-topic by the slacking Texas compsci class.
10:26:20 <srhb> :P
10:26:36 <equalityforevery> hey thats not nice man
10:26:47 <yonatanisdumb> excuse you
10:27:00 <hiptobecubic> I don't think that even disqualifies a movie from PG anymore
10:27:01 <YoYo_> Very rude sir. We ust accomodate all types of people. Even the stupid ones
10:27:03 <hiptobecubic> kids these days
10:27:18 <equalityforevery> dude not cool
10:27:23 <equalityforevery> have you seen my nickname????
10:27:26 <equalityforevery> EQUALITY
10:27:26 <yonatanisdumb> we didnt start the burrito conversation
10:27:31 <equalityforevery> seriiously.
10:28:29 * hiptobecubic launches a (Burrito b => b Missile)
10:28:49 <YoYo_> Can someone please explain Monads
10:29:13 <hiptobecubic> Absolutely not. It is impossible. Really.
10:29:20 <ijp> YoYo_: they are like comonads without the co
10:29:23 <HaskellGuy76> what's up yall
10:29:25 <hiptobecubic> Your only hope is to play with them and then have an epiphany
10:29:31 * hackagebot shake 0.6 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.6 (NeilMitchell)
10:29:32 <srhb> YoYo_: Look up "you could have invented monads"
10:29:35 <HaskellGuy76> i like to play with stuff
10:29:41 <mirsal> wow... 1029 users, impressive !
10:29:42 <HaskellGuy76> what is computer science?
10:29:44 <hiptobecubic> We can give you some hints like "It's not hard." and "don't over think it"
10:29:55 <Damian_> I've got a function that takes two lists and returns a Bool list, and I can't figure out why I can't composite it with the and function
10:30:01 <hiptobecubic> But you won't "get it" until you play
10:30:09 <Damian_> like: finalResult = and.myfun
10:30:12 <mauke> Damian_: because and takes a list of bools, not a function
10:30:23 <srhb> Damian_: That sounds right. What is the type of myfun?
10:30:25 <mauke> @unpl and.myfun
10:30:26 <lambdabot> (\ c -> and (myfun c))
10:30:28 <HaskellGuy76> bye!
10:30:30 <jason1> does #haskell have most users on freenode?
10:30:32 <YoYo_> WELL SCREW YOU TOO
10:30:37 <Damian_> myfun :: Ord b => [b] -> [b] -> [Bool]
10:30:43 <hiptobecubic> What happened to pg?
10:30:56 <srhb> Damian_: Looks right to me. I think you're doing something other than what you have said.
10:31:03 <shachaf> erkin, hiptobecubic: Saying "monads are like burritos" is completely unhelpful and tired inside jokes are even worse when you give them as answers to people who are actually asking questions.
10:31:05 <Saizan> Damian_: and . f = \x -> and (f x) but you want \ x y -> and (f x y)
10:31:31 <srhb> shachaf: They were not actually asking questions, don't worry.
10:31:35 <hiptobecubic> shachaf, I did tell him the actual way to learn what they were.
10:32:54 <magneticduck> using OpenGL, and having some weird problems not mentioned in the tutorials
10:33:08 <magneticduck> importing Graphics.Rendering.OpenGL and Graphics.UI.Glut
10:33:13 <Philippa_> jason1: nope. Your IRC client may well be able to give you a channel list, that'll show you what does
10:33:17 <magneticduck> and they're having a lot of common functions
10:33:18 <Damian_> Saizan: Correct. Why doesn't the composited functions consume the second argument?
10:33:27 <magneticduck> for instance, $= and "clear"
10:33:29 <magneticduck> O.o
10:33:33 <magneticduck> nobody mentions that
10:33:35 <magneticduck> what's going on
10:33:37 <magneticduck> and what do I use?
10:33:41 <Saizan> Damian_: because that's how it's defined
10:33:51 <mauke> Damian_: because (.) f g = \x -> f (g x)
10:33:51 <Saizan> @src (.)
10:33:51 <lambdabot> (f . g) x = f (g x)
10:33:51 <lambdabot> NB: In lambdabot,  (.) = fmap
10:34:11 * Philippa_ thinks the whole "nobody can tell you what the monad is" bandwagon has gone way too far
10:34:28 <Philippa_> I used to have plenty of success doing exactly that with people in here back in the day
10:34:49 <glguy> simpler times, eh?
10:34:50 <Damian_> ah, now I get it
10:34:56 <Damian_> Thanks
10:35:38 <Saizan> Philippa_: along which lines? embedded languages?
10:35:45 <srhb> Philippa_: I think it helps the least common denominator somewhat... But maybe you are right.
10:35:48 <Philippa_> Saizan: more or less, yeah
10:36:16 <Philippa_> srhb: yeah. I mean, my explanations were /also/ long enough for it to be clear you'd still need a play to go from nominal understanding to grokking
10:36:18 <Saizan> i guess "you could have invented" tries to do that too
10:36:34 <Philippa_> mmm. I should poke at my vaguely WIP tutorial again
10:36:51 <Philippa_> (not actually entitled "Languages I Give A Shit About As Monads")
10:36:59 <hiptobecubic> I guess someone could stick a little spiel in lambdabot to answer that question then
10:37:08 <epta> How can I get minimum of [Maybe Int] without using compare of Maybe's?
10:37:25 <parcs> epta: is Nothing < Just ?
10:37:32 <mauke> I hope so
10:37:37 <epta> No
10:37:41 <epta> Just < Nothing
10:37:45 <mauke> > Nothing < Just ()
10:37:46 <lambdabot>   True
10:38:03 <epta> I wan't to Just < Nothing
10:38:03 <parcs> epta: then minimum . catMaybes
10:38:04 <glguy> minimum . catMaybes
10:38:16 <epta> What about [Nothing]?
10:38:30 <parcs> you'll get an error
10:38:35 <Philippa_> treat it the same as []
10:38:37 <epta> I wanna Nothing
10:38:57 <Philippa_> then you want maybe the minimum, no?
10:39:03 <magneticduck> my question, anyone?
10:39:03 <mauke> :t minimumBy
10:39:04 <lambdabot> (a -> a -> Ordering) -> [a] -> a
10:39:06 <magneticduck> >:|
10:39:12 <cri9210> !list
10:39:12 <monochrom> cri9210: http://okmij.org/ftp
10:39:41 <mauke> magneticduck: extremely vague
10:40:47 <magneticduck> mauke: it's pretty much everything there is to it
10:40:56 <magneticduck> I'm trying to make a simple application using OpenGl and GLUT
10:41:11 <magneticduck> oh wait
10:41:18 <magneticduck> I didn't paste everything
10:41:20 <magneticduck> onc sec..
10:41:20 <glguy> > map (minimumOf (folded.folded)) [[], [Nothing], [Nothing,Just 10,Just 20]]
10:41:22 <lambdabot>   [Nothing,Nothing,Just 10]
10:41:59 <magneticduck> well
10:42:08 <parcs> epta: foldr (min . Just) Nothing . catMaybes
10:42:18 <parcs> i think that works
10:42:22 <glguy> epta: ^
10:42:24 <parcs> :t foldr (min . Just) Nothing . catmaybes
10:42:25 <lambdabot>     Not in scope: `catmaybes'
10:42:25 <lambdabot>     Perhaps you meant `catMaybes' (imported from Data.Maybe)
10:42:28 <parcs> :t foldr (min . Just) Nothing . catmaybes
10:42:29 <lambdabot>     Not in scope: `catmaybes'
10:42:29 <lambdabot>     Perhaps you meant `catMaybes' (imported from Data.Maybe)
10:42:33 <parcs> :t foldr (min . Just) Nothing . catMaybes
10:42:34 <lambdabot> Ord a => [Maybe a] -> Maybe a
10:42:52 <parcs> > (foldr (min . Just) Nothing . catMaybes) [Just 3, Just 6, Nothing]
10:42:54 <lambdabot>   Nothing
10:43:15 <jason1> :t minimum . filter (/= Nothing)
10:43:16 <lambdabot> Ord a => [Maybe a] -> Maybe a
10:43:26 <arthurmaciel> hello!
10:43:45 <epta> For [Just 1, Just 3, Nothing] I want Just 1, for [Nothing] I want Nothing
10:43:51 <hpaste> MagneticDuck pasted “OpenGL hello world problem” at http://hpaste.org/80510
10:43:53 <magneticduck> kk
10:43:57 <magneticduck> all hail hpaste
10:44:00 <magneticduck> any answers NOW?
10:44:01 <opqdonut> > msum [Just 1, Just 3, Nothing]
10:44:02 <lambdabot>   Just 1
10:44:02 <magneticduck> :D
10:44:07 <opqdonut> > msum [Nothing]
10:44:08 <glguy> epta: You saw what I pasted?
10:44:09 <lambdabot>   Nothing
10:44:14 <opqdonut> epta: msum
10:44:15 <Lethalman> > msum [Just 3, Just 1, Nothing]
10:44:16 <lambdabot>   Just 3
10:45:24 <parcs> oh
10:45:41 <epta> msum ok, thanks
10:45:47 <Lethalman> -.-'
10:45:49 <Saizan> > foldl' (maybe (Just $!) (\ x y -> Just $! (min x y))) Nothing . catMaybes $ [Just 4, Just 1, Nothing]
10:45:51 <lambdabot>   Just 1
10:45:55 <Lethalman> epta, msum is not the minimum
10:46:06 <epta> Ow :[
10:46:12 <Saizan> > foldl' (maybe (Just $!) (\ x y -> Just $! (min x y))) Nothing . catMaybes $ [Nothing]
10:46:14 <lambdabot>   Nothing
10:46:31 <parcs> > (\xs -> let xs' = catMaybes xs in minimum xs' <$ guard (not (null xs'))) [Just 4, Just 1, Nothing]
10:46:32 <lambdabot>   No instance for (GHC.Show.Show (f0 a0))
10:46:32 <lambdabot>    arising from a use of `M74985056...
10:46:41 <parcs> > (\xs -> let xs' = catMaybes xs in minimum xs' <$ guard (not (null xs'))) [Just 4, Just 1, Nothing] :: Maybe Int
10:46:43 <lambdabot>   Just 1
10:46:50 <parcs> > (\xs -> let xs' = catMaybes xs in minimum xs' <$ guard (not (null xs'))) [Nothing] :: Maybe Int
10:46:51 <lambdabot>   Nothing
10:46:55 <epta> <$ ?
10:46:57 <magneticduck> anyone?
10:46:59 <magneticduck> :/
10:47:27 <parcs> @src <$
10:47:27 <lambdabot> (<$) = (<$>) . const
10:47:45 <epta> Thanks
10:47:55 <Lethalman> :t (<$)
10:47:56 <lambdabot> Functor f => a -> f b -> f a
10:48:44 <parcs> :t (<$) <$> minimum <*> guard . not . null `fmap` catMaybes
10:48:46 <lambdabot>     Precedence parsing error
10:48:46 <lambdabot>         cannot mix `.' [infixr 9] and `fmap' [infixl 9] in the same infix expression
10:48:46 <Saizan> magneticduck: you could try and see
10:48:55 <parcs> :t (<$) <$> minimum <*> guard . not . null <$> catMaybes
10:48:56 <lambdabot> (Functor f, Ord a, MonadPlus f) => [Maybe a] -> f a
10:49:00 <parcs> lol
10:49:46 <Lethalman> @pl f = foldl' (maybe (Just $!) (\ x y -> Just $! (min x y))) Nothing . catMaybes
10:49:46 <lambdabot> f = foldl' (maybe (Just $!) (((Just $!) .) . min)) Nothing . catMaybes
10:50:11 <latro`a> @pl foldl' (maybe (Just $!) (\ x y -> Just $! (min x y))) Nothing . catMaybes
10:50:11 <lambdabot> foldl' (maybe (Just $!) (((Just $!) .) . min)) Nothing . catMaybes
10:50:13 <Lethalman> @pl f = (\xs -> let xs' = catMaybes xs in minimum xs' <$ guard (not (null xs')))
10:50:14 <lambdabot> f = liftM2 (<$) minimum (guard . not . null) . fix . const . catMaybes
10:50:18 <glguy> > map (minimumOf (folded.folded)) [[], [Nothing], [Nothing,Just 10,Just 20]] -- still the simplest solution :-p
10:50:20 <lambdabot>   [Nothing,Nothing,Just 10]
10:50:34 <Lethalman> ah that's interesting
10:51:38 <parcs> haha, fix . const
10:51:55 <parcs> i've never seen @pl say that
10:52:04 * Lethalman understands only the catMaybes part of all that thing
10:52:08 <Lethalman> :t fix . const
10:52:09 <lambdabot> b -> b
10:52:14 <jason1> :t catMaybes
10:52:15 <lambdabot> [Maybe a] -> [a]
10:52:39 <parcs> Lethalman: fix . const = id
10:52:44 <jason1> > catMaybes [Nothing, Nothing, Just 10]
10:52:45 <lambdabot>   [10]
10:52:46 <Lethalman> parcs, oh
10:52:58 <shachaf> glguy: Hmm, it looks like that can lead to a stack overflow.
10:53:05 <Lethalman> :t liftM2 (<$) minimum (guard . not . null) . catMaybes
10:53:07 <lambdabot> (Functor f, Ord a1, MonadPlus f) => [Maybe a1] -> f a1
10:53:17 <shachaf> Maybe we should define minimumOf/maximumOf with fold{l,r}{,'}?
10:53:30 <shachaf> You know, "one of those".
10:53:32 <parcs> i think my solution is nicer, as long as you know that <$> is left associative
10:53:33 <Saizan> :t minimumOf
10:53:34 <lambdabot> Getting (Control.Lens.Internal.Min a) s t a b -> s -> Maybe a
10:55:45 <epta> <glguy> > map (minimumOf (folded.folded)) [[], [Nothing], [Nothing,Just 10,Just 20]] -- still the simplest solution :-p <--- for what problem?
10:57:04 <Saizan> epta: yours
10:57:40 <epta> Oh, map is here just for get all variants
10:57:45 <epta> Got it
11:03:38 <jason1> am I missing something? is minimum . catMaybes  no good?
11:04:00 <glguy> jason1: minimum . catMaybes $ [Nothing]
11:04:38 <Taneb> > minimumOf (traverse._just) [Nothing]
11:04:40 <lambdabot>   Nothing
11:04:44 <Taneb> > minimumOf (traverse._just) [Nothing, Just 6]
11:04:46 <lambdabot>   Just 6
11:04:51 <Taneb> Lens to the rescue
11:04:54 <Taneb> > minimumOf (traverse._just) [Nothing, Just 6, Just 10]
11:04:56 <lambdabot>   Just 6
11:05:05 <Lethalman> :t traverse
11:05:06 <glguy> Taneb: You're late to the party :-p
11:05:06 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
11:05:11 <jason1> glguy: what should it be instead, Nothing?
11:05:28 <Lethalman> :t _just
11:05:29 <lambdabot> (Applicative f, Prismatic k) => k (a -> f b) (Maybe a -> f (Maybe b))
11:05:33 <Lethalman> \o/
11:05:42 * Lethalman hides scared
11:05:42 <glguy> jason1: Right, the specification for the function was to return a Nothing if no minimum was found
11:05:59 <mauke> Lethalman: correct
11:06:11 <edwardk> It's _just  :: (Applicative f, Prismatic p) => p a (f b) -> p (Maybe a) (f (Maybe b))  now
11:06:12 <glguy> Lethalman: 'traverse' is a pretty normal function. It'll be a good one to understand
11:06:25 <Taneb> glguy, what did I miss
11:06:35 <edwardk> here p = (->) so its not as terrifying
11:06:57 <glguy> edwardk: It's OK, your types are complicated ;)
11:07:07 <edwardk> heh
11:07:09 <Lethalman> glguy, yes not scared by that one in fact :S
11:07:18 <glguy> Taneb: That solution :)
11:07:24 <Taneb> :P
11:08:56 <Taneb> glguy, if more than one person came up with it independently, that means it's good!
11:09:14 <glguy> works for me
11:12:15 <epta> is there a better way to apply some function n times?
11:12:19 <epta> > let f g n = (!! n) . (iterate g) in f (+1) 10 0
11:12:20 <lambdabot>   10
11:13:05 <mauke> I like it
11:14:33 * hackagebot web-plugins 0.2.0 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.0 (JeremyShaw)
11:19:39 <fmap> > (\n -> appEndo . foldMap Endo . replicate n) 10 succ 0
11:19:41 <lambdabot>   10
11:26:07 <nicoo> @pl (\n -> appEndo . foldMap Endo . replicate n)
11:26:07 <lambdabot> ((appEndo . foldMap Endo) .) . replicate
11:26:31 <Taneb> pl is niave sometimes
11:26:37 <Taneb> And I can't spell sometimes
11:27:39 <Taneb> Try "fold(r/l) (.) id"
11:29:11 <startling> Taneb: forgot an a
11:29:34 <nicoo> Taneb: I wanted to see what pl would output ;)
11:29:41 <Taneb> :)
11:34:58 <magic> print "Hello everybody"
11:35:10 <mauke> did you mean: putStr
11:35:26 <magic> :D yes
11:35:56 <Sculptor> it's a kind of magi
11:35:57 <Sculptor> c
11:37:21 <binroot> Hey everyone, I'm teaching a 12-week introductory class on Haskell: http://shuklan.com/haskell
11:37:53 <binroot> and I'm giving my first lecture at the University of Virginia this Tuesday
11:38:04 <binroot> Please check it out!
11:38:55 <parcs> nice!
11:39:30 <Clint> binroot: if you have any particularly talented students who want to intern or work for free on free software, let me know
11:40:01 <cesc> binroot: sweet!
11:40:04 <LambdaDusk> A bug in GHC seems to keep me from installing the text package.. where can I post a message on that so someone can help me?
11:40:07 <luite> whoah 40% for attendance :p
11:40:45 <parcs> LambdaDusk: hpaste.org
11:40:51 <binroot> Clint: I'll keep you in mind
11:41:12 <LambdaDusk> parcs: I thought that was only for haskell pastes
11:41:40 <binroot> Also you guys are invited to enroll in this haskell class
11:42:18 <parcs> LambdaDusk: it's a general purpose purpose pastebin but it's primarily for haskell pastes
11:42:43 <clahey> Clint: What are you working on?
11:43:05 <cesc> any thoughts on Haskell for number-crunching tasks?
11:43:08 <LambdaDusk> parcs: Yes but the ghc devs are not really looking there for bug reports , right?
11:44:02 <mauke> oh, I thought you wanted help
11:44:21 <Clint> clahey: a bunch of different things; timekeeping, contact management, enhancements to hledger, enhancements to gitit, etc.
11:44:42 <Taneb> Solution to earlier problem:
11:44:49 <cesc> binroot: little typo on the slide after "2.statically typed":   I don't know how foo means ----> I don't know what foo means (?).
11:45:03 <Taneb> maximumBy (comparing $ fmap Down)
11:45:44 <Taneb> > maximumBy (comparing $ fmap Down) [Nothing]
11:45:46 <lambdabot>   Not in scope: data constructor `Down'
11:45:51 <Taneb> :(
11:48:43 <shachaf> > maximumBy (flip compare) [Nothing]
11:48:44 <lambdabot>   Nothing
11:48:59 <Taneb> Not quite the same
11:49:28 <Taneb> > maximumBy (flip compare) [Nothing, Just 7]
11:49:29 <lambdabot>   Nothing
11:49:40 <Taneb> With my thing, I think that's be Just 7
11:49:49 <alanz> LambdaDusk: http://hackage.haskell.org/trac/ghc/report
11:50:06 <LambdaDusk> alanz: Thanks
11:55:11 <binroot> Thank you cesc !
11:55:15 <binroot> I'll fix it right away
11:57:12 <cesc> binroot: just a wild question. I am a fortran guy; most of my computational needs are reading in arrays or matrices from files, manipulating them, and writing them back out. , will there be an example on loading numerical data from a file, manipulating them, and writing them back out? I spent quite some time learning Haskell, but I was never confident enough to do these things...
11:57:57 <cesc> C, C++, java and the other OO bollocks are out of the question for me at the moment. Haskell seemed worth a shot :)
11:58:18 <binroot> cesc: Ofcourse! There will be an entire lecture on IO
11:58:43 <binroot> Lecture 8 really focuses on that, just before diving into monads
11:58:59 <cesc> will we have to wait until Mar 5? :))))
11:59:03 <companion_cube> cesc: C is not OO...
11:59:33 <cesc> companion_cube: jupp, sorry didn't proofread. I actually started with C but ended up doing more debugging than number crunching, so Fortran it was! =)
11:59:33 <shapr> binroot: Which lectures?
11:59:41 <binroot> cesc: haha, if you want the secret early version, http://shuklan.com/haskell/lec08.html
11:59:42 <cesc> shapr: http://shuklan.com/haskell/index.html
11:59:57 <shapr> spiffy!
12:00:20 <cesc> binroot: you, sir, are awesome! Thank you very much!!!
12:00:25 <binroot> shapr: We're talking about a class I'm teaching this semester, http://shuklan.com/haskell You guys should enroll :)
12:01:06 <cesc> binroot: do you take Catalan physicists currently in Germany as exchange students? xD
12:01:09 <binroot> cesc: I'm warning you, those slides are currently just a draft. I'll perfect them when the time comes
12:01:12 <shapr> I'm taking five classes at una.edu, but a Haskell class doesn't sound too bad.
12:01:24 <shapr> binroot: Does it cost money?
12:01:32 <binroot> shapr: no money
12:01:38 <shapr> ok, I'm interested.
12:01:39 <cesc> binroot: thx. it's celestial literature already as it is
12:01:59 <binroot> All slides are online, its a free open class
12:02:24 <binroot> Actually the website is even opensourced https://github.com/BinRoot/Haskell-Lectures
12:02:48 <shapr> whoa awesome!
12:02:50 <shapr> binroot++
12:03:33 <cesc> *rejoicing*
12:03:39 <shapr> I'm a third year CS major at una.edu, this course should be fun!
12:03:54 <binroot> Hell yea!
12:04:26 <shapr> Admittedly, I do have some prior experience with Haskell outside of school.
12:05:22 * shapr continues to work on doing imap-ssl from Haskell
12:08:12 <shapr> Oh good choices for reference texts :-)
12:08:36 <Taneb> shapr, how goes the raspberry pi quest?
12:08:49 <binroot> shapr: Those are my favorite 2 books
12:09:36 <Sculptor> Taneb, rpi is yesterday's news
12:09:46 <shapr> Taneb: I'm looking for a place that has a 512MB Pi in stock at the moment, and trying to figure out how best to pay for it with cash in pocket and paypal on internet together.
12:10:04 <shapr> Sculptor: but I'm making new news!
12:10:10 <Sculptor> shapr, save your money
12:10:14 <shapr> Sculptor: why so?
12:11:04 <shapr> I will assume this sudden quietness means there are no reasons someone should not buy a Raspberry Pi!
12:11:32 <shapr> binroot: I'll advertise your online course, maybe you'll get more registrants!
12:11:48 <binroot> Thanks shapr
12:11:52 <binroot> I really appreciate it
12:12:08 <Sculptor> shapr, save your money for this http://www.hardkernel.com/renewal_2011/products/prdt_info.php
12:12:37 <shachaf> binroot: That "qsort" function is a completely different algorithm from the C code.
12:12:40 <shachaf> It's hardly a fair comparison.
12:13:11 <Sculptor> shapr> I will assume this sudden quietness means there are no reasons someone should not buy a Raspberry Pi! - no i was looking for the url
12:13:18 <shapr> Sculptor: Nah, that's significantly more expensive than the Raspberry Pi. $35 is cheap enough to kill through experimentation and replace where $89 is a bit too much for a college student.
12:13:25 <binroot> shachaf: Yea I agree. How should I phrase it instead?
12:13:36 <binroot> shachaf: It's 'similar'
12:13:44 <Sculptor> fine
12:13:46 <shapr> Sculptor: Also, I'm learning lots about how Haskell handles in less than 1GB of RAM
12:14:03 <shapr> Sculptor: Another advantage of the Pi is that there's a huge community behind it.
12:14:21 <Sculptor> i yet have to see a decent rpi project
12:14:28 <shapr> While I agree that the ODROID-U2 is a more powerful platform, it's not as popular.
12:14:38 <shapr> Sculptor: I've seen lots, and I'm making one myself :-)
12:14:47 <Sculptor> k
12:14:57 <shapr> In my opinion the Raspberry Pi is the Arduino of the Linux world.
12:15:08 <shachaf> binroot: I would say it's just misleading. :-)
12:15:17 <shachaf> binroot: If you wanted, you could write a simpler algorithm in C too.
12:15:18 <Rembane> shapr: In a good way?
12:15:18 <Sculptor> i hate tarduino
12:15:42 <shapr> Sculptor: Ah, I'm a fan of the Arduino. What do you think are other good options for the Arduino price/functionality?
12:15:51 <shapr> Rembane: Yah, I'm a fan of both the Arduino and the Raspberry Pi
12:15:56 <binroot> shachaf: Sure. I'll figure out a better example.
12:16:06 <shachaf> You don't need to compare Haskell to C to say that it's good. The languages have mostly different purposes.
12:16:17 <Rembane> shapr: Sweet! :)
12:16:29 <Sculptor> shapr, good options are everywhere
12:16:57 <shapr> Rembane: It's a bit hard to build with GHC on my 256MB Pi, but I've just gotten funding for a 512MB Pi to see if that makes things easier.
12:17:04 <shapr> Sculptor: Got any specific suggestions?
12:17:09 <Sculptor> say, this $15 board http://www.st.com/internet/evalboard/product/252419.jsp
12:17:21 <johnw> shapr: you can't cross-compile?
12:17:31 <shapr> johnw: Does ghc do cross-compiling?
12:17:45 <johnw> well, what I normally do is setup your target environment in a VM
12:17:52 <Rembane> shapr: That sounds really nice. :)
12:17:54 <johnw> build your final executables there, copy them over
12:18:08 <johnw> that way you don't have to install GHC on a tiny platform
12:18:22 <shapr> I've had some problems with that: https://bugs.launchpad.net/qemu/+bug/1042388
12:18:32 <johnw> try VirtualBox?
12:18:49 <shapr> Rembane: It's great, if you get a Pi I have experience using Haskell on it.
12:18:59 <shapr> Not so much experience using the Arduino from Haskell, but it has been done.
12:19:24 <Rembane> shapr: I got it in a box somewhere...
12:19:29 <johnw> shapr: http://www.raspberrypi.org/phpBB3/viewtopic.php?f=9&t=2961
12:21:21 <shapr> Sculptor: I put in a bunch of hours trying to use the msp430 and Renesas RX chips from Linux, but it's a monstrous pain in the butt. The Arduino IDE is beautifully smooth and consistent.
12:21:51 <srhb> binroot: That lecture site is incredibly sleek, wow!
12:22:16 <startling> shapr: I really hate the arduino IDE.
12:22:18 <shapr> Sculptor: One of my requirements is that my entire toolchain be open source.
12:22:24 <shapr> startling: Really? How would you improve it?
12:22:33 <Sculptor> to each their own. supper time
12:22:52 <peddie> shapr: the stm32f4 can be used with gcc for arm, I do it all the time
12:23:03 <Lethalman> anybody used a 3d library here?
12:23:08 <Lethalman> I was looking for something like libclutter
12:23:08 <startling> shapr: Well, I'd love for there to be an officially-supported command-line toolchain.
12:23:22 <Lethalman> there are bindings but they are a bit old and probably not much functiona
12:23:38 <osfameron> what library should I look at for handling graphs?
12:23:51 <startling> osfameron: which kind of graphs?
12:23:54 <shapr> I hung out with David Mellis once in Boston.. he said "You're doing good stuff with #haskell, what do you think would increase the popularity of the Arduino?" I said "The Arduino is already popular."
12:23:54 <Lethalman> for writing a very simple game with simple 3d graphics
12:24:23 <shapr> peddie: Ok, I'm interested.
12:24:24 <osfameron> startling: general graphs, e.g. directional, possibly cyclic
12:24:50 <startling> osfameron: oh, so you don't mean the data visualization kind. :)
12:24:57 <binroot> srhb: Thanks! The source is here https://github.com/BinRoot/Haskell-Lectures so you can learn from it if you want
12:25:04 <shapr> Sculptor: I would like to hear more about which microcontroller boards you like, when you get back from dinner, talk to me on #haskell-blah ?
12:25:08 <Lethalman> startling, that would be chart
12:25:17 <osfameron> startling: heh, no -- I clarified that for someone else earlier, sorry, should've been more specific :D
12:25:20 <stepkut> shapr: HaLVM might be a good (or better) starting point as well -- I'm not too picky. I just want to be able to run Haskell on the Raspberry Pi bare-metal
12:25:23 <osfameron> i think Data.Graph looks like a fair start
12:25:25 <startling> Lethalman: people use "graph" for both
12:25:41 <srhb> binroot: Neat!
12:25:47 <shapr> stepkut: I'm interested. What might be the easiest path?
12:26:08 <stepkut> shapr: no idea :)
12:27:36 <shapr> stepkut: Are there any options other than hOp and HaLVM?
12:27:53 <stepkut> shapr: I tried to install hOp the other day.. but it requires GHC 6.2.. and due to autoconf bitrot, etc, it does not build out of the box... someone updated hOp to GHC 6.8, but the link is dead. I emailed them but have not heard back. I am not sure how HaLVM works.. but it actually sounds closer to what I want and was built around a more modern GHC.. so it seems worth checking out
12:28:03 <stepkut> I only know of hOp and HaLVM
12:28:08 <shapr> stepkut: lighthouse from kenneth graunke
12:28:12 <shapr> lemme get you the git repo
12:28:26 <shapr> stepkut: http://wiki.cs.pdx.edu/gitweb?p=lighthouse.git;a=summary
12:29:15 <stepkut> ah nice
12:29:31 <shapr> stepkut: I asked Rebekah Leslie-Hurd about the L4 kernel work pdx did, but there's no consistent copyright or license assignment.. I should email Mark Jones...
12:29:47 <stepkut> that is probably based on GHC 6.8, so it would take some effort to update. unfortunately, we can't just use GHC 6.8, because we need ARM support ;)
12:29:51 <shapr> right
12:30:00 <stepkut> oh yeah.. there was some Haskell l4 thing..
12:30:04 <shapr> Yah, that's the one.
12:30:07 <stepkut> right
12:30:31 <shapr> stepkut: wasn't there some Linux distro that used Haskell for system stuff? ;-)
12:30:46 <stepkut> :)
12:30:59 <stepkut> there was also a paper on using Haskell to write linux kernel modules :p
12:31:19 <stepkut> of the things.. HaLVM is the only option currently maintained AFAIK
12:31:23 <shapr> I think so.
12:31:23 <stepkut> which is a good argument
12:31:26 <shapr> I agree
12:31:43 <stepkut> and.. it's stated purpose is to allow for bare-metal apps, which is what I want as well
12:32:04 <stepkut> an OS can be nice.. but for embedded projects, bare-metal seems more better
12:32:31 <shapr> and HaLVM designed for/on virtualization, so it would be good for hosting down the line
12:33:16 * startling wonders whether you could write a scheduler on halvm
12:33:21 <stepkut> I guess the first step is to email the HaLVM people and see what they think about the difficulty of ARM/RPi support
12:33:23 <startling> I'd assume so.
12:33:25 <shapr> That is, when the 64-bit ARM chips show up in datacenters doing virtualization you'll have a smooth upgrade path.
12:33:26 <Craig> does anyone have any familiarity with the haskell hint libarary? I am trying to figure out whether you can load a module created from a user created string. I see from the hint examples that you can load modules from saved files, and that you can evaluate string expressions...
12:33:28 <shapr> stepkut: I agree
12:33:42 <shapr> Craig: Yes, you can, want lots and lots of example source?
12:33:50 <stepkut> shapr: are you going to write them, or should I?
12:34:02 <shapr> Craig: dig through the prototypes directory here: https://github.com/shapr/ghclive
12:34:30 <shapr> stepkut: classes just started today and I'm organizing a tech meeting this weekend, and trying to get my funded Pi for more Haskell hacking
12:34:35 <Craig> shapr: Cool thanks. I was struggling to find examples. The hint page has only a single example file
12:34:36 <shapr> stepkut: So if you have time, that would be nice :-)
12:35:05 <shapr> Craig: I used hint LOTS for my google summer of code project this past summer, I can likely help with hint.
12:35:59 <shapr> Craig: What are you trying to do?
12:36:01 <Craig> shapr: Cool. Basically what i am aiming for is a really crude part of and IDE. i.e someone can type a bunch of haskell code into a text box in gtk, and have the program evaluate and run it
12:36:11 <shapr> Craig: You should try to install ghclive :-P
12:36:33 <shapr> Craig: http://i.imgur.com/w5e5D.png
12:36:36 <stepkut> shapr: ah, there is a mailing list, I will check the list first, and then send a post, http://community.galois.com/pipermail/halvm-devel/
12:36:40 <shapr> stepkut: yay!
12:36:44 <Craig> shapr: However, most of the examples i have seen deal only with using the eval function to evaluated an isolated function, rather than a function within the larger context of a piece of source
12:41:12 <srhb> Is there a better place than the Haskell Wiki to go for a beginners intro to xmonad setup? I think I'm about to take the dive...
12:43:01 <beaky> @pl \c -> when c $ action >> while cond action
12:43:01 <lambdabot> ($ action >> while cond action) . when
12:43:55 <beaky> the $ symbol is really ugly :(
12:44:08 <srhb> Oh?
12:44:27 <Eelis> maybe you can do (€) = ($) ?
12:44:38 <beaky> lol
12:44:39 <simpson> beaky: You'll get used to it.
12:45:08 <stepkut> shapr: sent!
12:45:16 <shapr> stepkut: w00t!
12:45:42 <stepkut> shapr: also, links to your KS projects?
12:46:14 <shapr> I didn't create KS projects :-P but I did get 512MB Pi funding from Taneb and opticron and crashcartpro
12:46:29 <beaky> @pl \f -> m a (* f) >> m i (+ 1)
12:46:29 <lambdabot> (>> m i (1 +)) . m a . (*)
12:46:40 <shapr> stepkut: I may create a KS project for an ARM build machine for ghc/debs, but I don't know which hardware is the best choice yet
12:47:24 <shapr> The ODROID-U2 that Sculptor suggested may be the best choice if it'll run Raspbian and produce armhf binaries. 2GB of RAM for $90 is hard to beat.
12:51:19 <stepkut> shapr: nice. Would be cool to run the autobuilder on it.. but we would have to fix the RAM usage first
12:51:39 <shapr> Does the autobuilder use lots of RAM?
12:51:49 <stepkut> shapr: yes.. far more than it should
12:52:05 <stepkut> shapr: it's definitely a bug.. but we usually run it on machines where it doesn't matter :)
12:52:18 <shapr> It would certainly matter on any ARM systems I've seen.
12:52:18 <Lethalman> how would you define the data for a rubik cube?
12:52:40 <stepkut> shapr: yup. would also help on my laptop
12:52:40 <shapr> Lethalman: could you define a zipper for a rubik's cube?
12:52:41 <Lethalman> as a list of faces? but that wouldn't be fixed
12:52:50 <Lethalman> shapr, why whould I need that?
12:52:53 <Lethalman> *would
12:52:59 <stepkut> shapr: just never had enough motivation to investigate
12:53:03 <Lethalman> shapr, I'm not going to have a search space
12:53:25 <Wizek> Why is pBench' faster than pBench? https://gist.github.com/4496832
12:53:33 <stepkut> shapr: but the autobuilder would be a great tool for building deb packages.. it can automatically pull packages from hackage, debianize, and build them
12:54:29 <shapr> stepkut: that sounds perfect for what I want
12:54:35 <kate_r> hi
12:54:41 <Lethalman> shapr, I don't know if to use data Cube = Cube [Face] or = Cube { face1 :: Face, face2 :: Face, ... }
12:54:46 <kate_r> i have a somehow logic related question
12:54:47 <kate_r> does anyone know why the universal quantifier can be encoded as All(P) == (P = (\lambda x. True)) where P is a predicate?
12:54:56 <stepkut> shapr: yup.. we use it to build 300+ packages at work on a regular basis
12:55:19 <stepkut> shapr: and it is written in Haskell :)
12:55:33 <stepkut> shapr: the only major issue I can think of offhand is the RAM thing, which is totally fixable
12:56:11 <shapr> stepkut: Building on the Pi is slow and sometimes requires more memory than it has, so I hope to produce binary debs for most anything on Hackage that can be installed on Raspbian
12:57:01 <shapr> kate_r: At what level are you asking that question? \x -> True means you get True for any input.
12:57:28 <jdahm> I'm getting an error trying to install pandoc: https://pastee.org/wvvy4
12:57:29 <stepkut> shapr: exactly!
12:57:36 <jdahm> anyone seen this and/or know how to fix it?
12:57:43 <jdahm> I'd rather not break packages....
12:57:52 <stepkut> shapr: I can think of no better tool than the autobuilder for that
12:57:55 <jdahm> also sorry, new to haskell
12:58:06 <kate_r> shapr, yeah, so why would All(P) be true iff P is a function returning true for all inputs? how is that universal quantification?
12:58:29 <shachaf> kate_r: ∀x.P(x) means that P is true for any argument you give it (in its domain)
12:58:32 <Hafydd> It is universal quantification over all inputs.
12:58:48 <shachaf> Therefore it's (extensionally) equal to (\x -> True)
12:58:58 <tac-tics> kate_r: You know about Howard-Curry right?
12:59:02 <Lethalman> @djinn (a -> b) -> a -> b
12:59:02 <lambdabot> f a = a
12:59:04 <kate_r> right right
12:59:06 <shapr> jdahm: I usually just do --reinstall and hope nothing breaks, I don't know if there's a better thing to do.
12:59:08 <kate_r> yeah
12:59:09 <stepkut> shapr: in theory, you just add a list of all the hackage targets you want to build to the config file, and then it automatically debianizes and builds them. If you run it again later, it will only rebuild packages that have changed on hackage, or which have updated dependencies.
12:59:10 <Lethalman> ^^ that's not right... right?
12:59:20 <Lethalman> it should be f a = f a
12:59:20 <shachaf> Lethalman: Looks OK to me.
12:59:30 <shachaf> f a = f a is a recursive definition.
12:59:37 <simpson> Lethalman: I think you're thinking of: f a b = a b
12:59:40 <stepkut> shapr: because the config file is actually a Haskell source file (like xmonad) you can even create the list of build targets programmitically
12:59:41 <shapr> stepkut: Right, and they'd all be available on my VPS or wherever I decided to host the apt source.
12:59:42 <shachaf> That's hopefully not what you want.
12:59:42 <kate_r> and the existential quantifier is encoded as Ex(P) == ALL Q. (ALL x. P(x) --> Q) --> Q?
12:59:46 <Lethalman> I'm thinking of ($)
12:59:48 <Lethalman> :t ($)
12:59:49 <lambdabot> (a -> b) -> a -> b
12:59:57 <Nereid> @src ($)
12:59:57 <lambdabot> f $ x = f x
13:00:03 <Lethalman> right
13:00:06 <Nereid> ($) = id
13:00:08 <Lethalman> simpson, ok
13:00:09 <shachaf> kate_r: Makes sense.
13:00:13 <Lethalman> thanks
13:00:18 <Nereid> look at it this way:
13:00:20 <shachaf> kate_r: For example consider Q = Void
13:00:22 <Nereid> ($) :: (a -> b) -> (a -> b)
13:00:24 <stepkut> shapr: yup
13:00:54 <stepkut> shapr: the autobuilder supports uploading to a remote host, and then you use newdist (part of the autobuilder suite) to add the packages to a local apt-get repo
13:01:07 <kate_r> hmm
13:01:19 <saml> hey ladies
13:01:33 <saml> let me write some haskell
13:02:10 <kate_r> shachaf, Q is a boolean value, so if it's True, then (ALL x. P x --> True) --> True, right?
13:02:18 <kate_r> but how is that the existential
13:02:32 <shachaf> kate_r: Try Q = False, not True
13:03:11 <kate_r> shachaf, then ALL x. P x has to be false?
13:03:15 <shachaf> kate_r: You know how ∃x.P(x) = ¬∀x.¬P(x)?
13:03:40 <Nereid> at least classically.
13:03:49 <Wizek> in pBench I tried to implement the "sieve of Eratosthenes", and in paper that would seem to be a more efficient than how pBench' is written. Or does Haskell's compiler optimize the latter in some way?
13:03:50 <saml> gich: command not found
13:03:55 <jdahm> shapr: alternatively I could remove ~/.ghc and ~/.cabal and start over?
13:03:57 <shachaf> Nereid: Right.
13:04:04 <shapr> stepkut: I know someone who purchased an ODROID-U2, I'll see if Raspbian runs on that.
13:04:10 <shapr> jdahm: Yes, I do that myself sometimes.
13:04:14 <jdahm> shapr: never got big into using haskell problems until now
13:04:36 <shapr> jdahm: As far as I can tell, the problem you are experiencing is understood, but the solution is not :-)
13:04:38 <thoughtpolice> shapr: hardkernel only supports android 4x and ubuntu 12.10 (their own custom build, I believe)
13:04:44 <quchen> About this "monads are monoids in the category of endofunctors" - is mappend = (>=>) and mempty = return? If so, how does mappend compose endofunctors (a -> a) when (>=>) takes functions of the type (a -> m b)?
13:04:46 <thoughtpolice> i have an odroid-u2 coming hopefully in a week
13:05:11 <shapr> thoughtpolice: That maybe sooner than my friend can try Raspbian on his, I'd love to know if it'll boot an drun!
13:05:26 <srhb> Since #ubuntu is less than helpful, does anyone know how I make my .xsession show up in the lightDM greeter?
13:05:32 <shachaf> quchen: No.
13:06:04 <shachaf> quchen: You should use the join/fmap/return definition of monads to see how that works.
13:06:23 <shachaf> The monoid associativity law is join . join = join . fmap join.
13:06:29 <kate_r> shachaf, yeah, i've seen that before, but don't quite understand how.
13:07:00 <quchen> shachaf: Ah, join :: m (m a) -> m a is mappend in some sense?
13:07:00 <shachaf> kate_r: Well, take some concrete predicate to get some intuition for it. :-)
13:07:17 <Nereid> that law just says
13:07:26 <Nereid> there are two ways to go from m (m (m a)) to m a
13:07:31 <Nereid> and they are equal
13:07:45 <shachaf> quchen: It's easier if you think about composition of "m"s, i.e. ignoring "a"
13:07:52 <shachaf> You have (m . m . m) a
13:08:06 <shachaf> You can collapse that in two ways: (m * (m * m)) and ((m * m) * m)
13:08:19 <quchen> Ah, I see.
13:08:29 <kate_r> is ¬∀x.¬P(x) parsed as (¬∀x).(¬P(x))?
13:08:39 <Nereid> kate_r: that's not syntactically valid.
13:08:41 <shapr> thoughtpolice: Think you'll have time to try to boot Raspbian?
13:08:45 <Nereid> ¬(∀x.(¬(P(x))))
13:08:48 <johnw> shachaf: how does mempty fit?
13:08:50 <shachaf> kate_r: No. ¬(∀x. (¬(P(x))))
13:08:54 <Nereid> mempty ~ return
13:09:09 <kate_r> right
13:09:13 <johnw> i meant, in shachaf's ignoring-a scenario
13:09:44 <quchen> shachaf: So can a monad in Haskell actually be written as a monoid, or is that something not easily expressible?
13:09:47 <Nereid> johnw: you view mempty as a morphism from the monoidal identity () to your monoid. () -> m
13:09:55 <johnw> ∅ should be the "identity m"
13:09:57 <Nereid> for endofunctors, the monoidal identity is the identity functor.
13:10:15 <Nereid> so return is a natural transformation from identity to m
13:10:20 <johnw> ok, but we're not talking about the Identity functor
13:10:21 <Nereid> i.e. a bunch of functions a -> m a
13:10:23 <Nereid> no.
13:10:27 <Nereid> that's not the identity functor.
13:10:28 <johnw> rather, the identity for m
13:10:39 <Nereid> no, I do mean the identity functor.
13:10:41 <Nereid> the one that takes a to a
13:10:43 <thoughtpolice> shapr: i doubt raspbian will work; the hard-float FPU in the RPi is significantly different than the one in the ODROID (the microarchitectures are significantly different.) ARM doesn't have what you would call 'unified booting' in a sense, so you typically need an image made for the board
13:10:45 <Nereid> (not a to Identity a)
13:10:51 <johnw> ah, i see
13:10:52 <thoughtpolice> so without a significant amount of work, i doubt it
13:11:05 <thoughtpolice> but i will probably be able to get ubuntu on it without too much difficulty i imagine
13:11:09 <shapr> So, the ODROID-U2 wouldn't make a good build machine for Raspbian debs then :-(
13:11:10 <johnw> so, identity functor * m = m, and m * identity functor = m
13:11:24 <Nereid> sure.
13:11:27 <hpaste> saml pasted “maybe fold shortcut?” at http://hpaste.org/80512
13:11:34 <shachaf> I think that's a type error?
13:11:42 <thoughtpolice> shapr: it could! but you'd need to adjust the compiler to emit the correct ARM code, and cross compile
13:11:42 <shachaf> Well, depending on what you mean by "identity functor"
13:11:53 <Nereid> identity a = a
13:12:02 <johnw> shachaf: the one that takes a -> a
13:12:11 <Nereid> the honest identity.
13:12:27 <thoughtpolice> shapr: i think this is how people build the packages now anyway; they just build a copy of GHC for ARM on some more powerful board, and make sure it's properly compiled to run on e.g the rpi
13:12:30 <badri> badri
13:12:36 <badri> hi
13:13:11 <thoughtpolice> shapr: really GHC just needs to become a cross compiler, and it's getting very close i think
13:13:15 <shapr> thoughtpolice: The Raspbian guys build debs with the Freescale i.MX53 quickstart board with 1GB of RAM
13:13:25 <shapr> Hi badri, are you learning Haskell?
13:13:29 <johnw> shapr: why not build it in VirtualBox?
13:13:32 <saml> wha's shortcut of this?  http://hpaste.org/80514
13:13:35 <badri> yeah
13:13:41 <thoughtpolice> shapr: yeah, so you'd need a bit of fiddling to make it work properly, but it's definitely doable
13:13:49 <saml> there are a, b, c, d, .....  list of Maybe
13:13:54 <thoughtpolice> shapr: you just won't be able to boot the raspbian kernel on an odroid, is all
13:13:57 <shapr> johnw: I don't have any reason other than that I haven't tried that yet I'll look at that thread you linked when I have a larger chunk of spare time. The virtualbox image they list is old
13:13:58 <thoughtpolice> johnw: it's an ARM machine
13:14:01 <badri> heard abt it in a technical seminar, wanted to try it
13:14:13 <kate_r> thanks guys, i got it now
13:14:25 <johnw> thoughtpolice: ah
13:14:25 <magic> HsColour makes ghci bad! any good option to colour ghci' life?
13:14:26 <shapr> badri: You could try it with http://tryhaskell.org/
13:14:39 <shapr> badri: Do you have any particular questions about Haskell?
13:14:47 <Nereid> :t maybe id (\a x -> x { getA = a })
13:14:48 <lambdabot>     `getA' is not a (visible) constructor field name
13:14:49 <Nereid> er
13:14:49 <thoughtpolice> shapr: i'm thinking of turning my small set of ARM machines into a build farm for GHC
13:14:59 <shapr> thoughtpolice: that would be awesome :-)
13:15:02 <Nereid> well that would do it.
13:15:03 <thoughtpolice> (i have 3 powerful enough to build GHC)
13:15:05 <startling> saml: (<|>) might be useful
13:15:08 <badri> yes, I am using the interactive tutorial
13:15:16 <saml> startling, oh i see <$> and <*>
13:15:16 <thoughtpolice> well, i will have 3, once the odroid gets here :)
13:15:19 <startling> saml: e.g. whatever <|> Just (getA x)
13:15:33 <Nereid> no that's not it.
13:15:42 <saml> thanks let's see if i can port this to scala
13:16:00 <badri> got some links - http://www.haskell.org/haskellwiki/Tutorials
13:16:15 <badri> is it really good for parallel processing?
13:16:20 <saml> wait.. but i want to modify existing rec instead of creating a brand new one
13:16:32 <badri> code that would work effectively in HPC?
13:16:50 <saml> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:(<|>)  ?
13:16:56 <shapr> badri: What flavor of HPC?
13:17:02 <Nereid> <|> doesn't do what you want.
13:17:08 <Nereid> well I guess it can be made to.
13:17:10 <Nereid> kind of.
13:17:29 <shapr> badri: There's support for array unrolling if you have a bunch of graphics cards in a system.
13:17:50 <shapr> badri: http://www.haskell.org/haskellwiki/Parallel
13:18:12 <badri> ibm
13:19:08 <shapr> badri: You mean distributed computing across multiple blades in a bladecenter?
13:19:11 <badri> thx
13:19:34 <Nereid> @hoogle Maybe a -> (a -> m ()) -> m ()
13:19:34 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:19:34 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:19:34 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:19:38 <shapr> badri: I've heard this will do some of that: http://www.haskell.org/haskellwiki/Cloud_Haskell but I'm not sure how much.
13:19:39 <Nereid> :(
13:19:57 <Nereid> oh there is such a thing.
13:20:00 <badri> great thanks. really helpful links
13:20:01 <saml> how can I make  x { getA = a }  part into a function?
13:20:10 <Nereid> you write a function.
13:20:18 <Nereid> setA x a = x {getA = a}
13:20:42 <saml> meh
13:20:43 <badri> let me get my hands dirty first. thanks
13:20:51 <Nereid> records are sad :(
13:21:00 <Nereid> alternatively, use lens
13:21:00 <Nereid> :D
13:21:19 <saml> i have initial data or record.   I'm parsing user input.. user might only specify some of the fields of the data.. and i want to update the data.
13:21:40 <Taneb> lenses are beautifully ridiculous
13:21:46 <Nereid> :t maybe id (?setA ?x) ?a
13:21:46 <saml> since i'm parsing, missing user input fields will be Nothing
13:21:47 <lambdabot> (?setA::t -> a -> a1 -> a1, ?x::t, ?a::Maybe a) => a1 -> a1
13:21:56 <Nereid> errr
13:22:17 <Nereid> :t maybe id (flip ?setA) ?a
13:22:18 <lambdabot> (?setA::a1 -> a -> a1, ?a::Maybe a) => a1 -> a1
13:22:40 <saml> there's no shorcut to lay user input fields over existing data?
13:22:40 <kini> why does importing a nonexistent module in ghci not cause ghci to display an error?
13:22:54 <Nereid> kini: it does.
13:22:59 <Taneb> kini, because it's an error
13:23:02 <saml> maybe i need to make monad
13:23:10 <saml> RecordUpdateMonad
13:23:18 <Nereid> you can do it with the state monad, sure. lens would be extra helpful here
13:24:14 <Nereid> :t whenJust
13:24:15 <lambdabot> Not in scope: `whenJust'
13:24:28 <Nereid> @let whenJust Nothing f = return (); whenJust (Just a) f = f a
13:24:28 <zl64c> Hey
13:24:29 <lambdabot>  Defined.
13:24:33 <Nereid> :t whenJust ?a (?l .=)
13:24:34 <lambdabot> (?a::Maybe t, ?l::Setting s s a t, MonadState s m) => m ()
13:24:59 <Nereid> wait.
13:25:03 <zl64c> im new in haskell, i have program to write, something operations with matrix
13:25:13 <johnw> Nereid: that argument order seems odd
13:25:19 <johnw> Nereid: a `whenJust` f?
13:25:24 <zl64c> is haskell new decision?
13:25:32 <mephx> is there a cool guide to install hp with ghc 7.6?
13:25:40 <hiptobecubic> zl64c, there are libraries for doing linear algebra. the most famous being hmatrix
13:25:48 <Nereid> johnw: by analogy to when
13:26:06 <Hafydd> What on earth does "new decision" mean?
13:26:07 <Dexter|> can i specify constant functions (in the context of classes/instances)? i.e. something like instance Class Type where myFunction = 3 ?
13:26:12 <Nereid> :t when
13:26:13 <lambdabot> Monad m => Bool -> m () -> m ()
13:26:22 <Nereid> it's not meant to be used infix.
13:26:26 <johnw> but you've defined it like a form of <$> that doesn't discards embedding on the result
13:26:27 <ocharles> Dexteri: you can, but you need to use a little trick
13:26:32 <johnw> s/doesn't//
13:26:48 <Nereid> it's actually Data.Traversable.forM_, if that existed.
13:27:03 <johnw> wouldn't that be in Foldable?
13:27:08 <Dexter|> what trick?
13:27:13 <ocharles> Dexter|: if we have data Tagged a b = a, then we can have class Foo a where someConstant :: Tagged Int a
13:27:16 <glguy> ?index forM_
13:27:17 <lambdabot> bzzt
13:27:20 <Nereid> ah it is.
13:27:25 <glguy> well, it's Data.Foldable, anyway
13:27:30 <Nereid> :t Data.Foldable.forM_ ?a (?l .=)
13:27:31 <lambdabot> (?a::t a, ?l::Setting s s a1 a, Foldable t, MonadState s m) => m ()
13:27:41 <Nereid> handy
13:27:45 <ocharles> Dexter|: now the function in our type class refers to the class introduced in the type class (which is essential)
13:28:06 <johnw> and you can just use for_, you don't need to say forM_
13:28:21 <Nereid> fine.
13:28:22 <Dexter|> ocharles i'm not sure i understand what you did there
13:28:23 <ocharles> Dexter|: and to use it, we do someConstant :: Tagged Int Foo, or someConstant :: Tagged Int Bar
13:28:24 <johnw> :t for_ a f
13:28:25 <lambdabot>     Not in scope: `for_'
13:28:25 <lambdabot>     Perhaps you meant one of these:
13:28:25 <lambdabot>       `Data.Foldable.for_' (imported from Data.Foldable),
13:28:38 <Nereid> doesn't make much difference.
13:28:48 <johnw> it's makes so MMMMMMMMMuch difference
13:28:53 <ocharles> Dexter|: The trick is the 'Tagged' data type, which has a phantom type to mention which type the constant is for
13:29:10 <Nereid> I'd rather use forM_
13:29:18 <Nereid> because then that doesn't add an Applicative constraint on the monad.
13:29:32 <Nereid> :t Data.Foldable.for_ ?a (?l .=)
13:29:33 <lambdabot> (?a::t a, ?l::Setting s s a1 a, Applicative f, Foldable t, MonadState s f) => f ()
13:30:00 <Nereid> :t assign
13:30:01 <johnw> well, for_ needs Applicative and Foldable, and forM_ needs Monad.  pick your poison I guess
13:30:02 <lambdabot> MonadState s m => Setting s s a b -> b -> m ()
13:30:08 <Nereid> but I'm giving it a monad.
13:30:15 <johnw> fair enough
13:30:44 <Nereid> in any case
13:30:46 <Dexter|> ocharles the type of the constant is clear (see http://ideone.com/kY4tnW, line 9) - but i'm not sure about the syntax or even whether somethin like this is possible
13:30:48 <Nereid> use lens, it makes your code pretty.
13:31:39 <Nereid> :t let forM_ = Data.Foldable.forM_ in execState (forM_ ?a (assign _1) >> forM_ ?b (assign _2))
13:31:40 <lambdabot> (?a::t a, ?b::t1 a2, Foldable t1, Foldable t, Field2 s s a3 a2, Field1 s s a1 a) => s -> s
13:31:44 <Nereid> bleh.
13:32:11 <Nereid> > let forM_ = Data.Foldable.forM_ in execState (forM_ Nothing (assign _1) >> forM_ (Just 3) (assign _2)) (0,0)
13:32:12 <lambdabot>   (0,3)
13:32:38 <johnw> i sure hope this is not the prettiness of which you speak :)
13:32:52 <Nereid> what's not pretty about it?
13:33:01 * johnw backs away slowly
13:38:19 <etiam> hi there
13:38:30 <zl64c> heyo
13:39:07 <hpaste> Nereid annotated “maybe fold shortcut?” with “maybe fold shortcut? (annotation)” at http://hpaste.org/80514#a80515
13:39:10 <Nereid> lens
13:39:18 <Nereid> what's not pretty about this.
13:39:44 <Nereid> saml: ^
13:40:17 <saml> Nereid, thanks
13:40:39 <Nereid> it's certainly doable without State too.
13:41:01 <saml> haskell's new forth. every library is own DSL
13:41:26 <Nereid> I don't konw why Data.Traversable doesn't have mapM_ and forM_ and so on.
13:41:26 <Taneb> If State makes your code pretty then use STATE
13:41:32 <Taneb> Sun Tzu said that
13:41:40 <Taneb> Nereid, they're in Data.Foldable
13:41:46 <Taneb> Every Traversable is a Foldable
13:41:57 <Taneb> D.T has mapM and forM etc
13:42:13 <Nereid> so does Foldable
13:42:17 <Nereid> er
13:42:18 <Nereid> no.
13:42:26 <Nereid> ok
13:42:52 <startling> "Every one sees what you appear to be, few really know what you are, and those few dare not oppose themselves to the opinion of the many, who have the majesty of the State to defend them." - Niccolò Machiavelli
13:43:41 <skp> hey
13:43:44 <Taneb> You could neaten it further by saying "for_ a $ assign recA" rather than "mapM_ (assign recA) a"
13:43:57 <johnw> :t assign
13:43:58 <Nereid> I had it like that before, but I like it this way better.
13:43:59 <lambdabot> MonadState s m => Setting s s a b -> b -> m ()
13:44:07 <Nereid> (.=) = assign
13:44:14 <johnw> ah, I was just wondering
13:44:18 <skp> on haskel.org, it’s said that Data.List.Split.splitOn :: (a -> Bool) -> [a] -> [[a]]
13:44:23 <johnw> recA .= a?
13:44:28 <Nereid> not quite.
13:44:29 <skp> in my ghci, it’s [a] -> [a] -> [[a]]
13:44:31 <johnw> or are you using mapM_ because a is a Maybe?
13:44:31 <skp> why?
13:44:34 <Nereid> a is a Maybe.
13:44:34 <Nereid> yes
13:44:38 <skp> I want the pred version! :(
13:44:38 <johnw> ah, gotcha
13:44:45 <johnw> we need recA <.=> a :)
13:45:02 <Taneb> skp, splitWhen
13:45:54 <Nereid> @hoogle (a -> Bool) -> [a] -> [[a]]
13:45:55 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
13:45:55 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
13:45:55 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
13:46:01 <Nereid> unhelpful :(
13:46:57 <skp> Taneb: huh?
13:47:06 <Taneb> skp, use splitWhen
13:47:07 <skp> the haskel.org website is not up to date then?
13:47:12 <Taneb> Presumably
13:47:21 <Nereid> so, whenJust = forM_. I guess I'm ok with this.
13:47:45 <Taneb> Nereid, or for_ if you've just got an Applicative
13:47:51 <Nereid> sure.
13:47:52 <skp> Taneb: thank you very much
13:47:54 <skp> :)
13:47:57 <Nereid> :t forM_ `asTypeOf` whenJust
13:47:58 <lambdabot>     Couldn't match expected type `[a0]' with actual type `Maybe t0'
13:47:58 <lambdabot>     Expected type: [a0] -> (a0 -> m1 b0) -> m1 ()
13:47:58 <lambdabot>       Actual type: Maybe t0 -> (t0 -> m0 ()) -> m0 ()
13:47:59 <Taneb> No problem
13:48:00 <Nereid> :t Data.Foldable.forM_ `asTypeOf` whenJust
13:48:01 <lambdabot> Monad m => Maybe a -> (a -> m ()) -> m ()
13:48:22 <Taneb> :t whenJust
13:48:23 <lambdabot> Monad m => Maybe t -> (t -> m ()) -> m ()
13:48:31 <Nereid> I defined it earlier.
13:48:42 <Taneb> Yeah, you only need an Applicative
13:48:47 <Nereid> of course.
13:49:52 <Dexter|> why does >>simplify (Add (Minus a) a) = (Value (zeroElem a))<< fail with >>Repeated variable "a" in pattern?<< (code on http://ideone.com/4sm7XU)
13:50:16 <Nereid> because you have a repeated variable in your pattern
13:50:22 <Nereid> and you can't do that.
13:50:26 <Taneb> Dexter|, because pattern matching doesn't work like that
13:50:28 <Taneb> Use a guard
13:50:38 <Dexter|> oh, ok
13:50:41 <Taneb> simplifiy (Add (Minus a) b) | a == b = ...
13:51:26 <Nereid> why does zeroElem take an argument?
13:51:49 <Dexter|> because i don't know how to do it argument-free
13:51:51 <Nereid> and the Group Double instance doesn't work.
13:51:55 <Nereid> zeroElem :: a
13:52:17 <Dexter|> why doesn't it?
13:52:35 <Nereid> because 0.0 is not a function, and you said zeroElem is a function.
13:52:50 <startling> :t 0 . 0
13:52:51 <lambdabot> (Functor f, Num (f a), Num (a -> b)) => f b
13:52:52 <Taneb> I'd make Group a subclass of Monoid
13:52:53 <Dexter|> oh, ok, yes, that part of the code doesn't macht the definition
13:53:00 <Dexter|> *match
13:53:11 <Taneb> instance Monoid g => Group g where invert :: g -> g
13:53:14 <Nereid> anyway, you can just write zeroElem :: a
13:53:26 <Nereid> or what Taneb did.
13:53:29 <Dexter|> that is valid?
13:53:36 <Nereid> class, not instance.
13:53:44 <Taneb> instance Num a => Group (Sum a) where invert (Sum a) = Sum (negate a)
13:54:18 <Taneb> instance Fractional a => Group (Product a) where invert (Product a) = Product (recip a)
13:54:24 <Nereid> no need for the Eq, Show, Read constraints on Group either.
13:54:31 <npl> http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed.html#v:accum copies the vector only once, is this correct?
13:54:37 <Nereid> and I'd probably get rid of isZero.
13:54:46 <Nereid> but that's just me.
13:54:54 <Nereid> Taneb: invert 0
13:55:04 <Taneb> Nereid, recip 0
13:55:07 <Dexter|> read/show i need for the io part of the code, and == is used in simplify
13:55:12 <Taneb> Some types may play nice
13:55:16 <Nereid> fine.
13:55:25 <Nereid> > recip (recip 0) :: Double
13:55:27 <lambdabot>   0.0
13:55:32 <Taneb> :P
13:55:36 <Nereid> lucky accident.
13:55:42 <Dexter|> oh
13:55:57 <Taneb> instance Group () where invert = id
13:56:03 <Nereid> Dexter|: but you're only using that for Expr, not an arbitrary Group.
13:56:24 <Nereid> also get rid of that Group constraint on Expr.
13:56:27 <Nereid> it does absolutely no good ever.
13:56:27 <Dexter|> hm?
13:56:42 <Dexter|> expr is the class
13:56:51 <Nereid> it's not a class, it's a data type.
13:56:58 <Nereid> and then you can simplify :: Eq a => Expr a -> Expr a
13:57:02 <Nereid> er
13:57:21 <Nereid> (Eq a, Group a) => ...
13:57:22 <Nereid> I guess.
13:57:36 <Dexter|> what's wrong with expr?
13:57:40 <Nereid> well I don't underestand what simplify is supposed to do.
13:58:09 <Dexter|> symbolic simplification - stuff like a+0 = a, a+(-a) = 0, etc.
13:58:19 <Taneb> instance (Monoid (Endo' c a), Groupoid c) => Group (Endo' c a) where invert (Endo' f) = Endo' (inv f)
13:58:27 <Taneb> Don't know if Endo' is defined anywhere
13:58:38 <shachaf> Is there a name for either of these operations? "p (x,y) b -> Either (p x b) (p y b)", "p b (Either x y) -> Either (p b x) (p b y)"
13:59:40 <Nereid> those operations look weird.
14:00:05 <shachaf> They have to do with opposite lenses.
14:00:12 <shachaf> Everything is weird in opposite lens world. :-(
14:00:19 <Nereid> they must, because the arrows go the opposite way to what I know.
14:00:20 <Nereid> :(
14:00:45 <Taneb> Isn't the former "I promise we only use one of x and y"
14:00:48 <shachaf> Nereid: The arrows are opposite but the variance of the arguments is also opposite.
14:00:54 <Taneb> And the latter "I promise we only result in one of x and y"
14:01:11 <shachaf> @ty (***)
14:01:12 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:01:16 <shachaf> @ty (|||)
14:01:17 <lambdabot> ArrowChoice a => a b d -> a c d -> a (Either b c) d
14:01:28 <shachaf> These are the "opposite" of those arrow operations.
14:02:07 <Taneb> ()
14:02:19 <shachaf> Both of those arrow operations accept products, so both of my operations return sums.
14:02:28 <shachaf> (By products I actually mean two arguments.)
14:03:52 <shachaf> Wait, no, I'm lying.
14:04:09 <shachaf> That's why that didn't make any sense.
14:04:14 <shachaf> The operations that these are opposite to are
14:04:20 <shachaf> diffract :: p a b -> p a c -> p a (b,c)
14:04:23 <shachaf> refract  :: p a c -> p b c -> p (Either a b) c
14:04:39 <roconnor> dysinger: did you get any help with static builds?
14:05:05 * roconnor --> #nixos
14:05:07 <Nereid> @ty (&&&)
14:05:08 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
14:05:16 <Taneb> I can imagine semifract :: p a (b, c) -> (p a b, p a c)
14:05:33 <Nereid> shachaf: what kind of p has such operations?
14:05:48 <Taneb> And profract :: p (Either  a b) c -> (p a b, p a c)
14:05:50 <shachaf> Nereid: * -> * -> *, hth
14:05:55 <Nereid> :(
14:06:00 <Nereid> you know what I meant.
14:06:28 <shachaf> Nereid: Tagged, Monoid r => Forget r
14:06:46 <shachaf> Where Tagged a b = b, Forget r a b = a -> r
14:07:01 <shachaf> Oh, uh, and (->)
14:07:07 <shachaf> Wait, no.
14:07:20 <shachaf> I'm listing off things that have diffract
14:07:30 <shachaf> Just, uh, the opposite of these?
14:07:35 <Taneb> Proxy?
14:07:39 <Taneb> Remember?
14:07:43 <Taneb> (<-)?
14:08:28 <Taneb> Goodnight, guys
14:09:20 <shachaf> Nereid: The main one is Bizarre
14:09:27 <shachaf> Bizarre p a b s t = p t s -> p b a
14:09:33 <Nereid> :(
14:09:55 <shachaf> ?
14:09:58 <Dexter|> why does this approach with guards result in an "infinite" type? http://ideone.com/1Hxt6A
14:11:58 <shachaf> Nereid: I have more weird operations for you if you want them.
14:12:03 <Nereid> no thanks
14:12:46 <shachaf> Not even (p c b1 -> p b a) -> (p b1 a1 -> p b a) -> p c a1 -> p b a ?
14:13:24 <Nereid> nope
14:13:24 <shachaf> Nereid: What's the opposite of a category?
14:13:31 <shachaf> Surely you know things like that.
14:13:32 <Nereid> a category
14:13:43 <Nereid> hmm.
14:13:44 <Nereid> no wait.
14:14:08 <Nereid> well,
14:14:27 <Nereid> the opposite category of a category is a category.
14:14:48 <Nereid> but I bet there's a dual notion to "category"
14:14:49 <shachaf> The question is: What constraints on p do you need to make (Bizzare p a b) a Category instance?
14:15:31 <Nereid> what do you know http://ncatlab.org/nlab/show/cocategory
14:16:29 <shachaf> Nereid: OK, it's p x y -> Either (p x z) (p z y)
14:16:48 <shachaf> Which is to say, uhh, one of its sides is coercible?
14:17:17 <Nereid> that's cocomposition.
14:17:32 <shachaf> OK, what should coidentity be?
14:17:44 <Nereid> or is it.
14:17:44 <shachaf> p a a -> p x y?
14:18:11 <Nereid> p a a -> Void
14:18:15 <Nereid> ??
14:19:02 <Nereid> fuck
14:19:05 <shachaf> Why Void?
14:19:07 <Nereid> I can't gift it back to banana because he already has it
14:19:16 <shachaf> Uh oh.
14:19:21 <Nereid> oops wrong channel.
14:19:26 <Nereid> because.
14:19:26 * shachaf doesn't know who banana is but that doesn't sound good.
14:19:31 <Nereid> Void is dual to ()
14:19:45 <shachaf> Are you sure it wouldn't be p x y?
14:19:48 <shachaf> Hmm.
14:19:53 <npl> sorry, I asked already a time ago, but nobody answered -  http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed.html#v:accum copies the vector only once, is this correct?
14:20:02 <shachaf> I guess void gives you p x y...
14:20:23 <Nereid> npl: based on it being O(m+n) and not O(mn), I'd say so.
14:20:43 <npl> Nereid: ah, that makes sense.. thanks =)
14:22:18 <shachaf> Nereid: Any idea what the oppositism for representable profunctors would be?
14:22:46 <Nereid> what are you trying to do.
14:23:31 <shachaf> Nereid: We came up with this Bizarre thing to let us turn around any profunctor lens.
14:23:40 <shachaf> And get the full power from the inverse lens.
14:23:41 <Nereid> why
14:24:01 <shachaf> Because that way you have from which can turn an iso around, and also turn a prism around?
14:24:07 <shachaf> And every other lens structure.
14:24:21 <Nereid> this is getting too weird.
14:24:52 <shachaf> It's great!
14:25:16 <shachaf> Nereid: What's a Cocategory like?
14:25:23 <shachaf> Do they make any sense in Haskell?
14:25:54 <Nereid> oh wait.
14:26:01 <Nereid> I haven't thought enough about what a cocategory is.
14:27:48 <Nereid> http://ncatlab.org/nlab/show/internal+category take the definition, turn around all arrows, and replace the pullback with a pushout. I guess.
14:28:01 <shachaf> Nereid: New operation: p (b,b') (a,a') -> Either (p b a) (p b' a')
14:28:05 <shachaf> *That's* op-***
14:28:16 <Nereid> :(
14:28:54 <Eiam> http://shuklan.com/haskell/ not sure if anyone saw this
14:29:59 <Nereid> except
14:30:04 <Nereid> hmm
14:30:44 <Nereid> because a Category isn't a category internal to Hask.
14:31:12 <Nereid> because the objects of a Category do not form a type
14:31:19 <Nereid> they're * instead
14:31:22 <Nereid> hmm
14:31:42 <Nereid> ok I don't know what a cocategory would look like in haskell.
14:36:12 <mephx> guys, I'm trying to go haskell 7.6.1, and got to the point of cabal's Setup.hs. I have the env set correctly, but Setup.hs reports unmet dependencies on base whereas ghc-pkg list base correctly outputs base-4.6.0.0. clues? where does the default package-db of ghc-pkg sit?
14:37:21 <Nereid> it's separate for each version of ghc
14:37:33 <Nereid> so...
14:37:35 <mephx> Nereid: I know, where does it sit?
14:37:39 <Nereid> uh
14:38:40 <Nereid> I have global in /usr/lib/ghc-x.x.x and user in ~/.ghc
14:38:52 <Nereid> or something
14:39:42 * hackagebot enummapmap 0.5.0 - Map of maps using Enum types as keys  http://hackage.haskell.org/package/enummapmap-0.5.0 (MatthewWest)
14:44:25 <QinGW> 早上好
14:44:43 * hackagebot MFlow 0.2.0.1 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.2.0.1 (AlbertoCorona)
14:45:06 <tac-tics> QinGW: Early up like!
14:46:08 <m3ga> when porting code from Persistent 1.0 to Persistent 1.1 i'm getting "Couldn't match type `PersistMonadBackend IO' with `Database.Persist.GenericSql.Raw.SqlBackend'". the weird thing is that SqlBackend is an uninhabited type. any clues that might help me understand this and fix it?
14:46:13 <QinGW> good morning
14:47:44 <ThrIce> I want to multiply all elements in one list with all elements in another list, how do i do that? I can't figure it out myself
14:48:44 <QinGW> why hackage are used to so low version number? it means it's far from stable?
14:48:56 <Pseudonym> > zipWith (*) [2,3,4] [2,3,4]
14:48:58 <lambdabot>   [4,9,16]
14:49:06 <Pseudonym> Like that, ThrIce?
14:49:28 <Pseudonym> Also an option, if you don't like that:
14:49:40 <Pseudonym> [ x*y | (x,y) <- zip [2,3,4] [5,6,7] ]
14:49:45 <Pseudonym> > [ x*y | (x,y) <- zip [2,3,4] [5,6,7] ]
14:49:47 <lambdabot>   [10,18,28]
14:50:07 <ThrIce> thank you, i started to get crazy ;)
14:50:11 <Eiam> haha I was just reading that tinking "thats totally not valid Ruby code, what the hell"
14:50:16 <Eiam> then, derp, wrong channel =)
14:50:26 <applicative> > [x*y |  x <- [2,3,4], x <-[5,6,7]]
14:50:28 <lambdabot>   [5 * y,6 * y,7 * y,5 * y,6 * y,7 * y,5 * y,6 * y,7 * y]
14:50:32 <applicative> hah
14:50:38 <applicative> > [x*y |  x <- [2,3,4], z <-[5,6,7]]
14:50:39 <lambdabot>   [2 * y,2 * y,2 * y,3 * y,3 * y,3 * y,4 * y,4 * y,4 * y]
14:50:46 <applicative> > [x*y |  x <- [2,3,4], y <-[5,6,7]]
14:50:48 <lambdabot>   [10,12,14,15,18,21,20,24,28]
14:50:49 <Pseudonym> Awesome.
14:50:52 <applicative> okay,there
14:51:01 <ThrIce> > print "pining ThrIce"
14:51:02 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
14:51:02 <lambdabot>    arising from a use of ...
14:51:08 <ThrIce> lol
14:51:11 <ThrIce> that was a fail
14:51:24 <applicative> @type print
14:51:25 <lambdabot> Show a => a -> IO ()
14:51:50 <Nereid> @type show
14:51:51 <lambdabot> Show a => a -> String
14:51:57 <Pseudonym> Yes, one is the Cartesian product, the other is the vector product.
14:52:08 <Pseudonym> ThrIce, your question could have been interpreted in two ways.
14:52:49 <ThrIce> well, i was trying to calculate [2,3,7] * [1..x]
14:53:11 <Nereid> what is [1,2] * [3,4] supposed to be?
14:53:15 <applicative> Pseudonym is suggesting that more than one thing might count as
14:53:19 <Nereid> is it
14:53:20 <ThrIce> so to get {2 * 1, 2 * 2, …, 3 * 1, 3 * 2, …}
14:53:20 <applicative> *
14:53:22 <Nereid> > zipWith (*) [1,2] [3,4]
14:53:24 <lambdabot>   [3,8]
14:53:29 <Nereid> > liftA2 (*) [1,2] [3,4]
14:53:30 <lambdabot>   [3,4,6,8]
14:53:31 <ThrIce> its supposed to be pseudo code
14:53:37 <Nereid> but what does it mean
14:53:58 <ThrIce> well, calculate 2 * 1, 2 * 2, 2 * 3, …. and then 3
14:54:05 <ThrIce> 3 * 1, 3 * 2 and so on
14:54:11 <Nereid> liftA2 (*), then
14:54:29 <Nereid> > liftA2 (*) [2,3,7] [a,b,c,d]
14:54:31 <lambdabot>   [2 * a,2 * b,2 * c,2 * d,3 * a,3 * b,3 * c,3 * d,7 * a,7 * b,7 * c,7 * d]
14:54:31 <Pseudonym> Or the list comprehension that applicative said.
14:54:35 <Nereid> or that.
14:54:40 <Pseudonym> People should use list comprehensions more.
14:54:58 <Nereid> they're probably easier to have intuition about.
14:55:04 <applicative> > getZipList (liftA2 (*)(ZipList [1,2])(ZipList [3,4]))
14:55:06 <lambdabot>   [3,8]
14:55:23 <applicative> > liftA2 (*) [2,3,7] [a,b,c,d]
14:55:24 <lambdabot>   [2 * a,2 * b,2 * c,2 * d,3 * a,3 * b,3 * c,3 * d,7 * a,7 * b,7 * c,7 * d]
14:55:51 <Nereid> > var "Hello, world!"
14:55:53 <lambdabot>   Hello, world!
14:55:57 <Nereid> excellent
14:56:10 <applicative> > text "Hello world"
14:56:11 <lambdabot>   Hello world
14:56:18 <Nereid> :t text
14:56:19 <lambdabot> String -> Doc
14:56:21 <Nereid> oh ok
14:56:28 <Nereid> > var "Hello, world!" * 2
14:56:31 <lambdabot>   2*Hello, world!
14:56:48 <ThrIce> this is cool
14:56:58 <Nereid> but yeah, why not use a list comprehension.
14:56:59 <applicative> @type var
14:57:01 <lambdabot> String -> Sym a
14:57:05 <ThrIce> Can i ping myself using that bot?
14:57:12 <ThrIce> > var "ThrIce"
14:57:13 <lambdabot>   ThrIce
14:57:16 <ThrIce> yeah
14:57:40 <applicative> > map var $ words "here are some words"
14:57:41 <lambdabot>   [here,are,some,words]
14:57:47 <Nereid> lol
14:57:56 <Lethalman> so I have Constructor a b c d e f g, and I wanted to provide these parameters automatically from a list
14:58:05 <Lethalman> tried with fold but no luck
14:58:13 <Lethalman> it's right telling me it needs an infinite type
14:58:32 <applicative> it thinks the list is the first argument
14:58:49 * Lethalman tries to rewrite it
14:58:57 <Nereid> f [a,b,c,d,e,f,g] = Constructor a b c d e f g
14:59:10 <Nereid> (but then what happens when the given list has the wrong length? etc.)
14:59:13 <ThrIce> > [1..]
14:59:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:59:27 <ThrIce> … disappointed :D
14:59:46 <Nereid> > fix$(0:).scanl(+)1
14:59:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:00:00 <Lethalman> > foldr (\x a -> a x) (\x y z w -> x) [1,2,3,4]
15:00:01 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
15:00:07 <Lethalman> ^^
15:00:07 <Nereid> you can't do that.
15:00:11 <Lethalman> eh :)
15:00:12 <Lethalman> ok
15:00:27 <Lethalman> makes sense
15:01:07 <Nereid> maybe you could do something with polymorphic recursion, I wonder.
15:01:17 <Nereid> or some typeclass trickery.
15:01:20 <mephx> where does Setup.hs look for dependencies in the first place? isn't it supposed to be reported by ghc-pkg? are there any incompatibility issues with Cabal-1.14 with ghc-7.6.1?
15:01:26 <Lethalman> Nereid, you mean with (->) ?
15:01:34 <Nereid> ?
15:01:44 <shachaf> Normal must be the most boring lens type in the world.
15:02:45 <peddie> Lethalman: is this the same question as http://www.haskell.org/pipermail/haskell-cafe/2012-December/105478.html ?
15:03:38 <stepcut> shapr: alas, my message to the Halvm-devel list bounced for some mysterious reason.. hopefully the postmaster email goes somewhere useful..
15:03:56 <Nereid> sure, http://www.haskell.org/pipermail/haskell-cafe/2012-December/105492.html
15:04:17 <Nereid> and also maybe a fundep would help with that.
15:05:00 <Lethalman> peddie, yes, I can't read the solution, is there?
15:05:28 <peddie> Lethalman: it's in the message that Nereid linked -- just follow the "next" link from the original message
15:05:32 <Lethalman> ah ok
15:05:47 <Lethalman> good to know it's somehow possible :)
15:05:59 <Lethalman> maybe all that it's not worth it for 6 arguments eheh
15:06:08 <ThrIce> what about a list where the difference between 2 elements is always 1 greater that the difference between the previous two values? something like [1,2,4,7,11,16…] How would i go about doing that?
15:07:12 <applicative> wait what about oleg http://www.haskell.org/pipermail/haskell-cafe/2012-December/105482.html
15:09:39 <Nereid> sure
15:09:43 <Nereid> more type safe.
15:09:47 <Nereid> wait.
15:09:48 <Lethalman> ThrIce, your list doesn't seem to be valid then, 4,7,11 ... 11 is not greater
15:09:50 <Nereid> never mind.
15:10:10 <Lethalman> sorry the difference not the sum
15:10:10 <Nereid> > scanl (+) 0 [1..]
15:10:12 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,...
15:10:40 <ski> > scanl (+) 1 [1 ..]
15:10:42 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,...
15:10:53 <ThrIce> that's awesome
15:11:02 <Lethalman> \o/
15:11:15 <Nereid> > scanl1 (+) [1..]
15:11:17 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
15:11:19 <Pseudonym> BTW, ThrIce...
15:11:30 <Pseudonym> > let f (x:xs) (y:ys) = x+y : f xs ys in fix (\xs -> 0 : 1 : f xs (tail xs))
15:11:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:11:37 <Nereid> > iterate (scanl1 (+) [0..5])
15:11:37 <ski> > let go n inc = n : go (n + inc) (inc + 1) in go 1 1
15:11:38 <lambdabot>   Couldn't match expected type `a0 -> a0' with actual type `[a1]'
15:11:38 <lambdabot>   can't find file: L.hs
15:11:40 <Pseudonym> That might be a little easier to understand how it works.
15:11:41 <Nereid> > iterate (scanl1 (+)) [0..5]
15:11:43 <lambdabot>   [[0,1,2,3,4,5],[0,1,3,6,10,15],[0,1,4,10,20,35],[0,1,5,15,35,70],[0,1,6,21,...
15:11:56 <ski> > let go n inc = n : go (n + inc) (inc + 1) in go 1 1  -- try again
15:11:58 <lambdabot>   [1,2,4,7,11,16,22,29,37,46,56,67,79,92,106,121,137,154,172,191,211,232,254,...
15:12:06 <startling> is there a genericReplicateM somewhere?
15:12:07 <Nereid> > iterate (scanl (+) 0) (take 6 $ repeat 1)
15:12:07 <ski> ThrIce : do you understand that one ?
15:12:08 <lambdabot>   [[1,1,1,1,1,1],[0,1,2,3,4,5,6],[0,0,1,3,6,10,15,21],[0,0,0,1,4,10,20,35,56]...
15:12:12 <Nereid> aw.
15:12:29 <Nereid> > iterate (scanl1 (+)) (take 6 $ repeat 1)
15:12:31 <lambdabot>   [[1,1,1,1,1,1],[1,2,3,4,5,6],[1,3,6,10,15,21],[1,4,10,20,35,56],[1,5,15,35,...
15:12:46 <sipa> > fix $ (0:) . (\x -> zipWith (+) (head x) x)
15:12:48 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
15:12:52 <Nereid> > transpose . take 6 $ iterate (scanl1 (+)) (repeat 1)
15:12:54 <lambdabot>   [[1,1,1,1,1,1],[1,2,3,4,5,6],[1,3,6,10,15,21],[1,4,10,20,35,56],[1,5,15,35,...
15:13:13 <ski> > iterate (\ns -> zipWith (+) ([0] ++ ns) (ns ++ [0])) [1]
15:13:15 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
15:13:16 <Nereid> oops I accidentally made pascal's triangle.
15:13:47 <Nereid> @let pascal = iterate (scanl1 (+)) (repeat 1)
15:13:47 <sipa> fix $ (0:) . scanl (+) 1
15:13:48 <lambdabot>  Defined.
15:13:52 <sipa> > fix $ (0:) . scanl (+) 1
15:13:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:13:54 <Nereid> > pascal 6 3
15:13:55 <Nereid> er
15:13:55 <lambdabot>   The function `L.pascal' is applied to two arguments,
15:13:55 <lambdabot>  but its type `[[a0]]'...
15:13:57 <Nereid> > pascal !! 6 !! 3
15:13:59 <lambdabot>   84
15:14:06 <ski> Nereid : Pascal's quadrant ?
15:14:14 <Rembane> :t fix
15:14:15 <lambdabot> (a -> a) -> a
15:14:21 <Nereid> close enough.
15:14:31 <Nereid> pascal !! a !! b = (a+b) choose b.
15:14:40 <ski> yes
15:14:46 <ThrIce> ski Yes, thats really great
15:15:12 <sipa> @let choose c b = pascal !! (c-b) !! b
15:15:14 <lambdabot>  Defined.
15:15:27 <sipa> > 6 `choose` 4
15:15:29 <lambdabot>   15
15:15:49 <Nereid> @let pascal' x y | x >= 0 && y >= 0 = pascal !! x !! y | otherwise = 0
15:15:51 <lambdabot>  Defined.
15:16:01 <Nereid> @let choose' a b = pascal' (a-b) b
15:16:03 <lambdabot>  Defined.
15:16:16 <Nereid> map (choose 6) [0..]
15:16:18 <Nereid> > map (choose 6) [0..]
15:16:20 <lambdabot>   [1,6,15,20,15,6,1,*Exception: Prelude.(!!): negative index
15:16:26 <Nereid> oh I did something wrong.
15:16:34 <Nereid> > map (choose' 6) [0..]
15:16:37 <lambdabot>   [1,6,15,20,15,6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
15:17:14 <lpsmith> I discovered a curious phenomenon once upon a time regarding Pascal's Triangle
15:17:24 <Pseudonym> I discovered one too. Yours first.
15:17:34 <lpsmith> lemme think
15:17:37 <ski> Nereid : is it defined when `x + y < 0' ?
15:17:48 <Nereid> sure, as 0
15:17:56 <lpsmith> >  map (flip choose' 6) [0..]
15:17:58 <lambdabot>   [0,0,0,0,0,0,1,7,28,84,210,462,924,1716,3003,5005,8008,12376,18564,27132,38...
15:18:26 <ski> Nereid : but then `choose (-1,0) + choose (0,-1) = choose (0,0)' doesn't hold :/
15:18:50 <Nereid> oh wait, maybe it isn't.
15:19:03 <ski> er, `choose (-1,-1) + choose (-1,0) = choose (0,0)' rather
15:19:08 <Nereid> or maybe it is.
15:19:17 <Nereid> or maybe it isn't.
15:19:29 <ski> (confusing the quadrant formulation with the triangle one)
15:19:30 <mreh> all my trace is being interleaved with all my other trace
15:19:36 <mreh> wat do
15:19:36 <int-e> > let c n 0 = 1; c n k = c (n-1) (k-1) * n `div` k in map (`c` 6) [0..]
15:19:37 <lambdabot>   [0,0,0,0,0,0,1,7,28,84,210,462,924,1716,3003,5005,8008,12376,18564,27132,38...
15:19:38 <Nereid> it's whatever it has to be to make the binomial formula work
15:19:41 <mreh> I'm using traceIO
15:19:42 <Nereid> theorem
15:19:46 <lpsmith> @define f m n = map ((`mod` n) . flip choose' m ) [m..]
15:19:50 <lpsmith> yeah, that's it
15:19:54 <mreh> and then unsafePerformIO
15:20:03 <lpsmith> f 10 20
15:20:09 <lpsmith> > f 10 20
15:20:11 <lambdabot>   Ambiguous type variable `a0' in the constraints:
15:20:11 <lambdabot>    (GHC.Show.Show a0)
15:20:11 <lambdabot>     ...
15:20:13 <mreh> some kind of lock maybe?
15:20:35 <lpsmith> well,  anyway,  the size of the image of every (f m) is a multiplicative function of n
15:20:44 <lpsmith> Pseudonym, that's mine
15:21:04 <int-e> choose n (-1) has no sensible definition.
15:21:06 <Pseudonym> Interesting.
15:21:09 <lpsmith> Pseudonym, oh wait,  I think I told you that one before
15:21:10 <ski> @let lpsmith m n = map ((`mod` n) . flip choose' m ) [m..]
15:21:11 <lambdabot>  <local>:1:37:
15:21:11 <lambdabot>      Not in scope: choose'
15:21:11 <lambdabot>      Perhaps you meant `chosen' (im...
15:21:15 <Pseudonym> Let me try and recreate mine.
15:21:17 <Nereid> int-e: yes it does, choose n (-1) = 0.
15:21:17 <mreh> just describing it to you guys makes me think it's just plain concurrency
15:21:20 <Nereid> for natural n.
15:21:25 <Nereid> choose (-1) n = (-1)^n
15:21:31 <Nereid> or
15:21:38 <Nereid> yeah, if n >= 0
15:21:42 <Nereid> and 0 if n < 0
15:22:07 <Nereid> it has to be, to make the binomial theorem work for (1 + x)^-1
15:22:19 <ski> @let lpsmith m n = map ((`mod` n) . flip choose' m ) [m..]
15:22:20 <lambdabot>  Defined.
15:22:24 <ski> > lpsmith 10 20
15:22:26 <lambdabot>   [1,11,6,6,1,3,8,8,18,18,16,16,6,6,16,0,15,5,10,10,15,5,0,0,0,16,16,16,16,16...
15:23:34 <ski> Nereid : though it breaks the symmetry :/
15:23:41 <Nereid> not really
15:23:55 <Nereid> you want choose a b to be a polynomial in a, for fixed b
15:24:13 <Pseudonym> > [ sum [ choose (n-k) k | k <- [0..n `div` 2] ] | n <- [0..] ]
15:24:15 <lambdabot>   Not in scope: `choose'
15:24:15 <lambdabot>  Perhaps you meant one of these:
15:24:15 <lambdabot>    choose' (line 3)...
15:24:23 <Pseudonym> > [ sum [ choose' (n-k) k | k <- [0..n `div` 2] ] | n <- [0..] ]
15:24:25 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
15:24:28 <Pseudonym> That's the one.
15:24:54 <Pseudonym> Exercise: Prove this.
15:25:29 * ski 's heard about that one
15:25:36 * Nereid too
15:25:59 <Pseudonym> Yeah, I discovered that it was already known about a few years after I discovered it at age 16 or so.
15:26:13 <mreh> is hPutStrLn atomic?
15:26:29 <Nereid> putStrLn isn't
15:26:39 <int-e> Nereid: I agree about choose (-1) k for k >= 0. That wasn't the point. It's k<0 that doesn't make sense.
15:26:46 <mauke> mreh: no
15:26:46 * ski remembers inventing an iterative algorithm for the towers of hanoi at perhaps around age 16
15:27:00 <Nereid> for k < 0, choose n k = 0.
15:27:09 <Nereid> always.
15:27:13 <Nereid> for integer n
15:27:18 <mreh> Nereid, mauke, k
15:28:02 <niteria> it should be for small strings when appending to a file if it had unix semantics
15:29:45 * hackagebot mustache2hs 0.2 - Utility to generate Haskell code from Mustache templates  http://hackage.haskell.org/package/mustache2hs-0.2 (StephenWeber)
15:31:20 <shachaf> > (+1) . do { x <- ask; return (x*2) } $ 5
15:31:22 <lambdabot>   11
15:32:09 <lpsmith> ski:  and since [ flip choose i | i <- [0..] ] is a basis for the Integer Valued Polynomials,  you can use that to demonstrate that the image of all integer valued polynomials (mod n) is a multiplicative function of n
15:32:37 <shapr> binroot: Isn't there a difference between the codomain and the range?
15:32:44 <mreh> niteria, I'm just going to use a global MVar abstracted away in a module
15:32:57 <shapr> binroot: How do I post questions about the lectures?
15:33:00 <Nereid> @ let choose1 a b | b < 0 = 0 | otherwise = product (map (a+1-) [1..b]) `div` product [1..b]
15:33:04 <Nereid> @let choose1 a b | b < 0 = 0 | otherwise = product (map (a+1-) [1..b]) `div` product [1..b]
15:33:05 <lambdabot>  Defined.
15:33:45 <ski> lpsmith : "Integer Valued Polynomials" being defined how ?
15:33:58 <lpsmith> ski, any polynomial that maps integers to integers
15:34:09 <lpsmith> You can prove that they must have rational coefficients
15:34:11 <Nereid> > map (choose1 4) [-1..5]
15:34:13 <lambdabot>   [0,1,4,6,4,1,0]
15:34:15 <Nereid> > map (choose1 (-1)) [-1..5]
15:34:17 <lambdabot>   [0,1,-1,1,-1,1,-1]
15:34:33 <ski> ok, so not only integral coefficients
15:34:37 <lpsmith> right
15:35:04 <ski> interesting
15:35:20 <Nereid> also
15:35:25 <Nereid> it's a very nice basis for such polynomials
15:35:46 <Nereid> forward difference is easily expressed in it, for instance
15:37:11 <mreh> hmm, even with a semaphor and withMVar my function is still interleaving output from several threads
15:38:10 <Nereid> > map (\n -> map (choose1 n) [0..n]) [0..]
15:38:11 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
15:38:24 <ski> "forward difference" ?
15:38:39 <Nereid> diff f n = f (n+1) - f n
15:38:55 <Nereid> or maybe backward difference is nicer, I forget.
15:39:52 <Nereid> and it's useful in practice.
15:40:22 <Nereid> e.g. the (forward? backward? I forget) difference of the hilbert polynomial of an algebraic variety is the hilbert polynomial of its intersection with a generic hyperplane.
15:41:06 <niteria> you mean 'discreete derivative'?
15:41:14 <Nereid> yeah, it's the discrete version of the derivative.
15:41:59 <niteria> using that, you can easily find a polynomial that fits the data point
15:42:12 <niteria> data points*
15:42:28 <Nereid> well, if your data points have x = 0, 1, ..., n
15:42:29 <Nereid> then yes.
15:42:46 <niteria> and find it represented in newton basis
15:42:48 <sipa> > x
15:42:49 <lambdabot>   x
15:42:55 <sipa> > x `div` y
15:42:57 <lambdabot>   x `div` y
15:43:00 <niteria> it generalizes to other x's
15:43:25 <Nereid> well you'd have to use a different basis.
15:43:56 <Nereid> > choose x 3
15:43:57 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:43:57 <lambdabot>              with actual type ...
15:43:59 <Nereid> > choose1 x 3
15:44:01 <lambdabot>   1 * (x + 1 - 1) * (x + 1 - 2) * (x + 1 - 3) `div` (1 * 1 * 2 * 3)
15:44:04 <niteria> http://en.wikipedia.org/wiki/Newton_polynomial see Application > Example
15:44:05 <blue592> hey guys i hope you can help me i want to do this x*y without using * , im trying to use only + - so how can i do it ?
15:44:28 <Nereid> blue592: ??
15:44:47 <niteria> smells like homework
15:45:37 <niteria> are x,y integers?
15:45:42 <blue592> yes
15:45:46 <mreh> repeated addition?
15:45:48 <mreh> there's a clue
15:46:11 <blue592> nop ^^
15:46:22 <Nereid> yes
15:46:24 <Nereid> that is a clue
15:47:01 <blue592> for example 4 * 5 = 20 but im trying to do this 4 + 4 + 4 + 4 + 4 = 20
15:47:23 <Nereid> so compute 4 * n recursively.
15:48:14 <blue592> but i cant use this operator *
15:48:27 <Nereid> we know.
15:48:37 <sipa> blue592: assume you have to multiply by 0
15:48:39 <mreh> it's easy for the naturals
15:48:41 <mreh> I just did it
15:48:42 <sipa> blue592: what is the result?
15:48:54 <blue592> so a recursion is the clue
15:48:54 <mreh> sorry, not helping
15:49:10 <blue592> 0
15:49:19 <sipa> ok, so f x 0 = 0
15:49:34 <blue592> jep
15:49:43 <sipa> for f x y, assume y is not 0
15:49:52 <Nereid> actually, assume y > 0.
15:50:01 <sipa> so you trying to compute x*y where y>0
15:50:10 <sipa> can you write that differently?
15:51:06 <blue592> what do you mean with differently
15:51:08 <niteria> someone gave you x * (y - 1), compute x * y
15:51:23 <sipa> blue592: ok, assume y is 1
15:51:32 <blue592> ok
15:51:44 <sipa> result is x
15:51:48 <sipa> assume y is 2
15:51:50 <sipa> x+x
15:51:53 <sipa> and so one
15:51:58 <sipa> on
15:52:20 <sipa> so, when looking at subsequent values of y, you get: 0, x, x+x, x+x+x, x+x+x+x, ...
15:52:24 <sipa> right?
15:52:42 <blue592> right
15:52:54 <Nereid> let's get #haskell to do some golf for me. if I have an infinite list of infinite lists [[a00, a01, ...], [a10, a11, ...], ...]
15:52:56 <sipa> so, given a list of such values, how do you calculate the next one?
15:53:05 <Nereid> I want to turn that into [[a00],[a01,a10],[a02,a11,a20],...]
15:53:21 <Nereid> ok maybe not quite golf, just something pretty :p
15:53:31 <blue592> [_:xs] maybe
15:53:48 <sipa> blue592: just in words - not haskell code yet
15:53:49 <niteria> same trick as in Q ~ N?
15:53:52 <hpc> Nereid: code synchronized swimming :P
15:54:21 <sipa> niteria: yeah, diagonalization
15:54:31 <Nereid> heh http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/src/Control-Monad-Omega.html#diagonal
15:54:38 <niteria> diagonalization is different
15:54:59 <niteria> or so I thought
15:55:06 <Nereid> stripe is what I want, I think.
15:55:24 <niteria> no, I'm right
15:55:51 <niteria> you use it to prove R !~ N
15:55:51 <sipa> you're right to think what you want?
15:56:05 <schellsan> can anyone recommend a good sqlite package for a novice haskeller?
15:57:46 <Nereid> yes, stripe does what I want. ok
15:57:47 <niteria> monkey operator :D
15:58:52 <sipa> niteria: hmm, how can you use that to show that R is larger than N?
15:59:13 <sipa> (i know it is, just don't see how to use that in proof)
15:59:44 <Nereid> @pl \n -> map ((,) n) xs
15:59:44 <lambdabot> flip map xs . (,)
15:59:51 <niteria> not that, it's just that the classic argument is called diagonal method
16:00:16 <sipa> yes, for showing N^2 ~ N
16:00:37 <niteria> you make a list and take a diagonal, flipped diagonal is not in the list
16:01:01 <sipa> hmm
16:01:06 <Nereid> but I don't want to concat.
16:01:23 <Nereid> that's it.
16:01:33 <beefcube> if I've already defined an Ord instance for a type, why does the compiler complain that I haven't defined Eq (and is there a trick to prevent that?) ?
16:01:51 <Nereid> because Ord has Eq as a superclass.
16:01:57 <Nereid> the trick is to define an Eq instance.
16:02:06 <Nereid> you can cheat: x == y = compare x y == EQ
16:02:29 <Nereid> or maybe it's easier to define == directly.
16:02:38 <beefcube> alright
16:05:00 <beefcube> this also looks like a job for template-haskell :)
16:05:16 <niteria> you can derive Eq
16:05:43 <Nereid> and Ord
16:05:58 <Nereid> hmm, now I want a similarly pretty way of inverting a formal power series.
16:09:09 <Nereid> I got it.
16:09:10 <Nereid> :p
16:14:48 <fmap> If I want to define Iso without lens dependency I need to wait for 3.8, right?
16:14:58 <shachaf> Right.
16:14:59 <fmap> oh, probably wrong channel
16:15:02 <fmap> oh well
16:15:15 <shachaf> Well, you can do it now, you just won't be able to use it. :-)
16:15:46 <shachaf> You still need a profunctors dependency.
16:15:49 <shachaf> Then it'll just be iso sa bt = dimap sa (fmap bt)
16:16:01 <shachaf> (If we had profunctor lenses, it would be iso = dimap)
16:16:17 <fmap> nice, I can live with profunctors
16:16:32 <cmccann> but can profunctors live with you? :O
16:16:45 <shachaf> cmccann: Profunctors can't live with me. :-(
16:17:04 <shachaf> cmccann: I'm wondering if "p a b" means something like "exactly one of {a,b} is inhabited".
16:17:07 <cmccann> they probably got tired of all the puns.
16:17:34 <schellsan> do you guys do any work with sql databases?
16:18:06 <blackdog> hey, anyone know which of virthualenv and hsenv is currently being worked on?
16:18:13 <blackdog> i'm giving up on cabal-dev
16:18:14 <cmccann> shachaf: in what context? your thing with the mpose operation and all?
16:18:20 <shachaf> Yes.
16:18:49 <cmccann> isn't that how I described the dual of implication?
16:19:05 <shachaf> "a AND not b"
16:19:22 <shachaf> That says that a is inhabited and b isn't, right?
16:19:26 <cmccann> oh, right
16:19:31 <shachaf> I'm saying that exactly one is inhabited, but you don't know which one.
16:19:36 <cmccann> misread, sorry.
16:19:42 <shachaf> And mpose tells you which one by coercing the other one.
16:19:47 * hackagebot hsc3-lang 0.13 - Haskell SuperCollider Language  http://hackage.haskell.org/package/hsc3-lang-0.13 (RohanDrape)
16:20:08 <shachaf> And coid takes an absurd value, i.e. (a,Not a), and gives you anything.
16:20:19 <cmccann> that seems to make sense
16:20:30 <ski> @djinn (a,Not a) -> b
16:20:30 <lambdabot> f (a, b) = void (b a)
16:20:52 <cmccann> ah, ski might have some idea about this as well
16:21:01 <shachaf> Well, it's not actually (a,Not a)
16:21:04 <shachaf> It's p a a
16:21:07 * ski isn't sure what shachaf and cmccann is discussing yet
16:21:20 <cmccann> stuff that mysteriously migrated here from #haskell-lens
16:21:44 <shachaf> It happened around the time that cmccann mysteriously migrated here from dinner.
16:21:57 <cmccann> that part isn't mysterious.
16:22:03 * ski doesn't know what a profunctor is
16:22:03 <cmccann> it involved me eating my dinner.
16:22:14 <ski> is #haskell-lens any fun ?
16:22:19 <shachaf> Lots!
16:22:31 <shachaf> ski: I'm trying to figure out "cocategories", which would have something like coid :: p a a -> ?, mpose :: p t s -> Either (p t x) (p x s)
16:22:44 <shachaf> Where ? is either Void or p x y
16:23:37 <ski> hm, perhaps your `?' and `Either' could be some tensor structure on a category
16:23:58 <ski> (which your cocategory is internal to, obviously)
16:24:13 <shachaf> ski: A profunctor has operations "(a -> b) -> p x a -> p x b" and "(a -> b) -> p b x -> p a x"
16:24:14 <cmccann> ski: I mentioned that it seemed to resemble dual-intuitionistic logic
16:24:17 <ski> s/tensor structure/monoidal functor/
16:24:22 <shachaf> I.e. contravariant in the first argument, covariant in the second.
16:24:26 <shachaf> Like (->)
16:24:39 <ski> which ? `p' ?
16:24:47 * hackagebot hsc3-db 0.13 - Haskell SuperCollider Unit Generator Database  http://hackage.haskell.org/package/hsc3-db-0.13 (RohanDrape)
16:24:57 <shachaf> p, yes.
16:25:00 <cmccann> if you take "p" as being the pseudodiference or whatever
16:25:08 <cmccann> which I think we were talking about the other day
16:25:12 <ski> shachaf : a profunctor sounds similar to a difunctor then -- is there any difference ?
16:25:19 <shachaf> What's a difunctor?
16:25:31 <shachaf> http://hackage.haskell.org/packages/archive/compdata/0.5.2/doc/html/Data-Comp-Param-Difunctor.html ?
16:25:36 <ski> exponential is a difunctor
16:25:38 <shachaf> Looks like the same thing.
16:26:13 <shachaf> Apparently it has a bunch of other names, like "distributor" and "bimodule"
16:26:13 <ski> cmccann : "it" being ?
16:26:35 <cmccann> ski: the specific "p" that would allow the coid and mpose operations shachaf mentioned
16:26:44 <cmccann> or a specific such profunctor at any rate
16:26:54 <ski> ok
16:26:55 <cmccann> probably more than one that would work
16:27:00 <shachaf> I don't think this has much to do with profunctors.
16:27:04 <shachaf> Just like categories don't.
16:27:11 <shachaf> There's no mapping over a and b.
16:28:22 <cmccann> anyway, writing pseudo-difference as !>, I think (A !> C) |- (A !> B), (B !> C) is valid
16:28:38 <cmccann> but it's been a little while since I was considering this stuff
16:28:49 <shachaf> Does , on the right side of |- mean disjunction?
16:28:52 <cmccann> yes.
16:29:11 <ski> shachaf : typically a multiplicative disjunction
16:29:30 <cmccann> in dual-intuitionistic logic it ends up conflating both linear logic disjunctions
16:29:35 * ski is reminded of cotransitivity
16:29:43 <cmccann> in exactly the dual of how (,) conflates both conjunctions in Haskell
16:29:57 <cmccann> likewise you have an additive-only conjunction dual to Either
16:30:11 <cmccann> and pseudo-difference gives you a way of encoding multiplicative conjunction
16:30:18 <ski>   ∀ x,y,z : ℝ. x < z ↦ x < y ∨ y < z
16:30:33 <cmccann> so you can have a dual of the CPS encoding and recover classical logic from the other direction
16:30:35 <shachaf> Hm.
16:30:51 <shachaf> ski: That's interesting.
16:31:10 <cmccann> except you end up with (exists r. r !> (r !> A)) I think
16:31:14 <cmccann> or something goofy like that
16:32:01 <ski> shachaf : one can often use that instead of the unprovable `∀ x,y : ℝ. x < y ∨ x = y ∨ x > y' or `∀ x,y : ℝ. x ≤ y ∨ x ≥ y'
16:33:14 <shachaf> This looks very related.
16:33:33 <shachaf> Similarly x < x ↦ Void
16:33:50 <shachaf> Or in this case it might be x < x ↦ ∀ y,z. y < z
16:34:35 <shachaf> Aha, http://www.fnds.cs.ru.nl/ccorn/documentation/doc008.html
16:34:44 <shachaf> "irreflexivity".
16:35:31 <shachaf> I guess antisymmetry would be the opposite of abelian categories?
16:35:55 <shachaf> (x < y) -> Not (y < x)
16:36:23 <shachaf> Or maybe not.
16:36:48 <ski> shachaf : <http://ncatlab.org/nlab/show/linear+order> calls it "comparision"
16:37:22 <shachaf> Hrm.
16:37:22 <ski> shachaf : that's asymmetry, not antisymmetry
16:37:33 <cmccann> speaking of nlab, there's also this: http://ncatlab.org/nlab/show/paraconsistent+logic#dual_intuitionistic_logic_10
16:38:24 <shachaf> I always thought you invented that name.
16:38:41 <cmccann> what name?
16:39:09 <shachaf> Dual intuitionistic logic.
16:39:24 <cmccann> ah. no.
16:39:33 <cmccann> if it was me I'd probably just put a "co-" on it.
16:39:41 <cmccann> less typing.
16:40:10 <cmccann> it's kind of obscure though, not many people seem interested in it.
16:40:10 <shachaf> Cointuitionistic logic, to coin a tutionistic logic.
16:40:17 <shachaf> i
16:40:58 <cmccann> if it was up to me there would also be more puns based on "counter-intuitive"
16:41:05 <ski> shachaf : "Dual-Intuitionistic Logic" by Igor Urbas in 1996 at <http://projecteuclid.org/DPubS?service=UI&version=1.0&verb=Display&handle=euclid.ndjfl/1039886520>
16:41:08 <Hafydd> Fruitionistic logic uses banana brackets heavily in its notation.
16:41:57 * shachaf is off, will be back in $TIME.
16:44:05 <danr> is there a logic monad with unification implemented?
16:44:08 <danr> a'la prolag
16:44:11 <danr> prolog*
16:44:56 <Nereid> >>> 1/(1-2*t) :: FormalPowerSeries Rational'
16:44:56 <Nereid> 1 + 2 t + 4 t^2 + 8 t^3 + 16 t^4 + 32 t^5 + 64 t^6 + 128 t^7 + 256 t^8 + 512 t^9 + 1024 t^10 +...
16:44:57 <Nereid> hooray.
16:45:01 <Nereid> who knows why I was doing this.
16:45:15 <Nereid> (Rational' is Rational with a different Show instance)
16:45:35 <Nereid> (and FormalPowerSeries a is a newtype for [a])
16:46:20 <ski> danr : i implemented one once
16:46:21 <danr> Nereid: nice :)
16:46:53 <Nereid> >>> (1+t)^3
16:46:54 <Nereid> 1 + 3 t + 3 t^2 + t^3
16:46:55 <Nereid> yeah.
16:47:23 <parcs> Nereid: how
16:47:33 <ski> @type (>>-)
16:47:34 <lambdabot> MonadLogic m => m a -> (a -> m b) -> m b
16:47:44 <Nereid> t is [0,1]
16:47:46 <ski> @type ifte
16:47:48 <Nereid> (1+t)^3 is [1,3,3,1]
16:47:48 <lambdabot> MonadLogic m => m a -> (a -> m b) -> m b -> m b
16:47:59 <Nereid> (wrapped in a newtype)
16:48:10 <ski> though iirc, `MonadLogic' doesn't support a logic variable interface
16:52:03 <parcs> Nereid: do t / (1 - t - t^2)
16:52:20 <parcs> i was just learning about generating functions today
16:52:32 <Nereid> >>> t / (1 - t - t^2) :: FormalPowerSeries Rational'
16:52:32 <Nereid> t + t^2 + 2 t^3 + 3 t^4 + 5 t^5 + 8 t^6 + 13 t^7 + 21 t^8 + 34 t^9 + 55 t^10 + 8...
16:53:13 <roconnor> Nereid: did you read that paper on formal power series in haskell?
16:53:17 <Nereid> nope
16:53:27 <hpaste> Nereid pasted “formal power series” at http://hpaste.org/80517
16:53:57 <Nereid> stripe is ripped from Control.Monad.Omega
16:54:46 <Nereid> exercise: figure out why inv' works.
16:54:49 * hackagebot hsc3-unsafe 0.13 - Unsafe Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-unsafe-0.13 (RohanDrape)
16:55:00 <roconnor> Nereid: http://www.cs.dartmouth.edu/~doug/pearl.ps.gz
16:56:14 <parcs> Nereid: how are you computing the coefficients of each term
16:56:28 <Nereid> well, it's from the observation that
16:56:45 <Nereid> (1 + tf)^-1 = 1 - tf + (tf)^2 - ...
16:57:07 <Nereid> which is where powers . map negate comes from
16:57:15 <Nereid> and the rest is some ugly thing to make it work out.
16:57:26 <parcs> right but t / (1 - t - t^2) is not of that form
16:57:39 <Nereid> 1 - t - t^2 = 1 + t (-1 - t)
16:57:55 <Nereid> so we can compute the reciprocal of that.
16:58:00 <parcs> :O
16:59:47 <kate_r> hi
16:59:54 <danr> ski: do you have the implementation on hackage?
16:59:55 <kate_r> in logic, what is a 'preferred model'?
17:00:48 <parcs> what's the generating function of f(n) = f(n-1) + n
17:03:03 <glguy> > map (\x -> (x^2+x)`div`2) [1..10]
17:03:04 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
17:03:11 <glguy> > scanl1 (+) [1..10]
17:03:12 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
17:03:16 <glguy> Is that what you mean?
17:03:19 <Nereid> sure, but what's the generating function.
17:03:20 <Nereid> no.
17:03:24 <glguy> oh :)
17:03:33 <Nereid> the power series whose coefficients are 0, 1, 3, 6, ...
17:03:38 <Nereid> it's a rational function.
17:04:17 <glguy> I just saw what parcs wrote. I haven't seen all that stuff above. Carry on :)
17:05:51 <Nereid> >>> t/(1-t)^3
17:05:51 <Nereid> t + 3 t^2 + 6 t^3 + 10 t^4 + 15 t^5 + 21 t^6 + 28 t^7 + 36 t^8 + 45 t^9 + 55 t^1...
17:06:50 <Nereid> parcs: ^
17:07:01 <Hafydd> What is that, the Taylor series?
17:07:08 <Nereid> it's a formal power series.
17:07:33 <Hafydd> >>> sin t
17:07:39 <Hafydd> Oh.
17:07:50 <Hafydd> I didn't see you pasted that yourself.
17:07:56 <Jafet> Now you have to supply the result, Hafydd.
17:07:59 <Jafet> @goog generatingfunctionology
17:07:59 <lambdabot> Maybe you meant: google googleit
17:08:08 <parcs> it's actually the taylor series too no?
17:08:21 <Hafydd> Well, if you insist.
17:08:24 <Nereid> sure. but formal power series don't have to converge anywhere.
17:08:37 <Jafet> @google generatingfunctionology
17:08:39 <lambdabot> http://www.math.upenn.edu/~wilf/DownldGF.html
17:08:39 <lambdabot> Title: Download generatingfunctionology
17:08:46 <hiptobecubic> @googoogachoo, I am the walrus
17:08:46 <lambdabot> Unknown command, try @list
17:08:47 <Hafydd> t - 1/6 t^3 + 1/120 t^4 - ...
17:08:57 <Hafydd> ICBF to compute the rest.
17:09:10 <Hafydd> And that's t^5
17:13:34 <Nereid> bwahahahaha
17:13:35 <Nereid> >>> fix ((1+) . integrate)
17:13:35 <Nereid> 1 + t + 1/2 t^2 + 1/6 t^3 + 1/24 t^4 + 1/120 t^5 + 1/720 t^6 + 1/5040 t^7 + 1/40...
17:14:57 <Nereid> >>> fix (integrate . (1-) . integrate)
17:14:57 <Nereid> t + -1/6 t^3 + 1/120 t^5 + -1/5040 t^7 + 1/362880 t^9 + -1/39916800 t^11 + 1/622...
17:15:36 <Nereid> Hafydd: :)
17:16:15 <parcs> what's that
17:16:19 <Nereid> sin t
17:16:27 <Nereid> and exp t before it
17:16:40 <parcs> oh right
17:16:43 <parcs> nice
17:19:06 <Hafydd> Heh.
17:19:10 <Hafydd> Nice.
17:19:16 <Jafet> > sum $ scanl div (10^100) [1..100]
17:19:17 <lambdabot>   271828182845904523536028747135266249775724709369995957496696762772407663035...
17:19:30 <kate_r> is \top true in all models?
17:19:31 <Nereid> lol
17:20:05 <pro620> any germans here to help me ^^
17:20:11 <Jafet> In my model, top spins
17:20:13 <Pseudonym> > (!!100) . iterate (\x -> x + sin x) $ 3
17:20:15 <lambdabot>   3.141592653589793
17:21:23 <parcs> wow
17:21:32 <Hafydd> I'd be more impressed if you didn't use sin.
17:21:45 <Hafydd> After all, you can just find its first positive root.'
17:21:55 <Nereid> hmm, now I want to represent fractional powers of t.
17:22:41 <Nereid> or negative
17:22:49 <mauke> pro620: with haskell?
17:23:06 <Nereid> Puiseux series, apparently they're called.
17:25:00 <parcs> oh
17:25:04 <parcs> that's basically x = x + sin x
17:25:21 <Nereid> it's also using Newton's method to approximate a zero of sin near 3.
17:25:25 <Nereid> or wait.
17:25:41 <Nereid> no, not quite. one could do that, though.
17:25:45 <kate_r> in higher-order logic's type theory, what is a first-order function? is it just a term of type a => b?
17:26:30 <Nereid> > (!!100) . iterate (\x -> x - sin x / cos x)) 3
17:26:31 <lambdabot>   <hint>:1:44: parse error on input `)'
17:26:35 <Nereid> > (!!100) . iterate (\x -> x - sin x / cos x) 3
17:26:36 <lambdabot>   No instance for (GHC.Float.Floating [b0])
17:26:36 <lambdabot>    arising from a use of `e_11003...
17:26:45 <Nereid> uh
17:26:46 <pro620> how can add up an value ntimes if i want to use this a function like this func x y
17:26:55 <Nereid> > (!!100) . iterate (\x -> x - sin x / cos x) $ 3
17:26:57 <lambdabot>   3.141592653589793
17:27:01 <Nereid> that's newton's method.
17:27:13 <parcs> what method is the original?
17:27:41 <Nereid> uh
17:27:44 <pro620> for example func 5 4 = 5 + 5 + 5 + 5
17:27:56 <pro620> = 20
17:28:34 <parcs>  > (!!100) . iterate (\x -> x - log x - exp 1) $ 3
17:28:39 <Nereid> iterate (5+) 0 !! 4
17:28:41 <parcs> > (!!100) . iterate (\x -> x - log x - exp 1) $ 3
17:28:41 <Nereid> > iterate (5+) 0 !! 4
17:28:42 <lambdabot>   can't find file: L.hs
17:28:43 <lambdabot>   NaN
17:28:46 <Nereid> > iterate (5+) 0 !! 4
17:28:47 <lambdabot>   20
17:28:49 <parcs> :(
17:28:50 <parcs> > (!!100) . iterate (\x -> x - log x - exp 1) $ 3
17:28:52 <lambdabot>   NaN
17:28:55 <parcs> oh
17:29:08 <parcs> > (!!100) . iterate (\x -> x + log x - exp 1) $ 3
17:29:10 <lambdabot>   NaN
17:29:17 <Nereid> I'm trying to think about why x -> x + sin x works.
17:30:19 <parcs> x = x + sin x = (x + sin x) + sin (x + sin x) = (x + sin x + sin (x + sin x)) + sin (x + sin x + sin (x + sin x))
17:30:31 <Nereid> well it's newton's method for finding a zero of log (csc x + cot x), I suppose.
17:31:05 <Nereid> or is it.
17:31:33 <parcs> > (!!100) . iterate (\x -> x + log (asin x + atan x)) $ 3
17:31:35 <lambdabot>   NaN
17:31:37 <Nereid> no, just csc x + cot x
17:31:39 <liyang> > foldr (++) "Batman!" . take 16 $ show <$> repeat (0/0)
17:31:40 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNBatman!"
17:31:45 <Hafydd> Hahahah.
17:31:49 <parcs> > (!!100) . iterate (\x -> x + asin x + atan x) $ 3
17:31:49 <Nereid> :(
17:31:50 <lambdabot>   NaN
17:32:25 <Nereid> @let newton f f' x0 = (!!100) . iterate (\x -> x - f x / f' x) x0
17:32:26 <lambdabot>  Defined.
17:32:29 <Nereid> > newton sin cos 3
17:32:30 <lambdabot>   No instance for (GHC.Float.Floating [b0])
17:32:30 <lambdabot>    arising from a use of `e_13'
17:32:30 <lambdabot>  ...
17:32:37 <Nereid> did I just
17:32:46 <Nereid> shit.
17:32:50 <Nereid> @undefine
17:32:51 <Nereid> @let newton f f' x0 = (!!100) . iterate (\x -> x - f x / f' x) $ x0
17:32:53 <lambdabot>  Defined.
17:32:54 <Nereid> > newton sin cos 3
17:32:57 <lambdabot>   3.141592653589793
17:33:06 <parcs> http://www.wolframalpha.com/input/?i=y%2Fy%27+%3D+cos+x
17:33:13 <parcs> it's the root of that thing
17:33:14 <Pseudonym> (pi + epsilon) + sin (pi + epsilon) = pi + epsilon + sin pi cos epsilon + cos pi sin epsilon = pi + epsilon - sin epsilon
17:33:26 <Nereid> > newton (\x -> x^2 - 3) (\x -> 2*x) 1
17:33:28 <lambdabot>   1.7320508075688774
17:33:29 <Pseudonym> That's the reason why it works.
17:33:57 <Nereid> sure, you're finding a fixed point of x -> x + sin x
17:34:01 <parcs> Pseudonym: nice
17:34:08 <applicative> pro620: func = (*)
17:34:13 <Nereid> which works, because the absolute value of its derivative is less than 1 near 3.
17:34:17 <Nereid> so it converges.
17:34:33 <Nereid> @let fixpoint f x0 = (!!100) . iterate f $ x0
17:34:35 <lambdabot>  Defined.
17:34:59 <parcs> > (!!100) . iterate (\x -> x + exp (2*atanh(tan(x/2))) $ 3
17:35:00 <lambdabot>   <hint>:1:57: parse error (possibly incorrect indentation)
17:35:05 <parcs> > (!!100) . iterate (\x -> x + exp (2*atanh(tan(x/2)) $ 3
17:35:06 <lambdabot>  Terminated
17:35:25 <Nereid> exercise: prove it converges.
17:35:47 <liyang> shachaf: probably wishful thinking, but do you know if http://hackage.haskell.org/trac/ghc/ticket/7436 is going into 7.6.2?
17:35:47 <applicative> pro620: or maybe you want other things than Int for the first argument
17:36:05 <Nereid> i.e. if |f'(x)| < 1 for x0 - e < x < x0 + e, then iterating f will converge when starting in the interval (x0 - e, x0 + e).
17:36:17 <shachaf> liyang: Not sure. I've wondered myself.
17:36:23 <Nereid> maybe that needs to be a closed interval.
17:36:43 <Nereid> no it should be fine.
17:37:07 <shachaf> liyang: I see an origin/ghc-7.6 branch which doesn't have the patches.
17:37:10 <shachaf> Although they're in HEAD.
17:37:34 <applicative> > let func x n = sum $ take n $ repeat x  in func 5 4
17:37:35 <lambdabot>   20
17:37:47 <applicative> > let func x n = sum $ take n $ repeat x  in func (5.0) 4
17:37:49 <lambdabot>   20.0
17:38:21 <quchen> liyang: Why is the non-eta-reduced example O(n^2)?
17:38:35 <quchen> I would have thought that both examples given are the same except for notation
17:39:02 <parcs> > (!!100) . iterate (\x -> x + sin x) $ pi
17:39:04 <lambdabot>   3.141592653589793
17:39:32 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 0.0
17:39:33 <lambdabot>   0.0
17:39:35 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 0.000000000000000000001
17:39:37 <lambdabot>   3.141592653589793
17:39:39 <Nereid> haha.
17:39:39 <liyang> quchen: the comments explain it…
17:39:44 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 10^(-100)
17:39:46 <lambdabot>   *Exception: Negative exponent
17:39:48 <parcs> > (!!100) . iterate (\x -> x + sin x) $ pi/2
17:39:49 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 10^^(-100)
17:39:50 <lambdabot>   3.141592653589793
17:39:51 <lambdabot>   1.2676506002282291e-70
17:39:58 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 10^^(-300)
17:40:00 <lambdabot>   1.2676506002282286e-270
17:40:00 <Nereid> er
17:40:01 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 10^^(-30)
17:40:03 <lambdabot>   1.2134055551952398
17:40:11 <parcs> uh oh
17:40:12 <Nereid> yeah. 0 is an unstable fixed point of x + sin x
17:40:18 <parcs> > (!!100) . iterate (\x -> x + sin x) $ (pi/2 - 0.01)
17:40:21 <lambdabot>   3.141592653589793
17:40:22 <Nereid> > (!!110) . iterate (\x -> x + sin x) $ 10^^(-30)
17:40:24 <lambdabot>   3.141592653589793
17:40:27 <parcs> > (!!100) . iterate (\x -> x + sin x) $ (pi/2 + 0.01)
17:40:29 <lambdabot>   3.141592653589793
17:40:43 <Nereid> > (!!110) . iterate (\x -> x + sin x) $ -1
17:40:45 <lambdabot>   -3.141592653589793
17:41:05 <Nereid> it has fixed points at multiples of pi. the even multiples are unstable, while the odd multiples are stable
17:41:10 <Nereid> that explains what we are seeing.
17:41:24 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 9
17:41:25 <lambdabot>   9.42477796076938
17:41:27 <Nereid> > 3*pi
17:41:29 <lambdabot>   9.42477796076938
17:41:39 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 2*pi
17:41:41 <lambdabot>   6.283185307179586
17:41:46 <Nereid> heh.
17:41:51 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 6.283185307179586
17:41:53 <lambdabot>   6.283185307179586
17:41:55 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 6.28318530717958
17:41:57 <lambdabot>   3.141592653589793
17:42:00 <Nereid> > (!!100) . iterate (\x -> x + sin x) $ 6.28318530717959
17:42:02 <lambdabot>   9.42477796076938
17:42:07 <Nereid> there you have it.
17:42:13 <parcs> > (!!100) . iterate (\x -> x + cos x) $ 0
17:42:15 <lambdabot>   1.5707963267948966
17:42:25 <Pseudonym> > (2/) . (!!100) . scanl (*) 1 . tail . iterate (\x -> sqrt (2 + 2*x) / 2) $ 0
17:42:27 <lambdabot>   3.141592653589794
17:42:33 <Nereid> :s
17:42:54 <Pseudonym> I like that one.
17:42:55 <Nereid> > fixpoint (2/) 2
17:42:57 <lambdabot>   2.0
17:43:01 <Nereid> er
17:43:05 <Nereid> > fixpoint (\x -> x + 2/x) 1
17:43:06 <lambdabot>  Terminated
17:43:10 <Nereid> hmm.
17:43:22 <Nereid> > fixpoint (\x -> x/2 + 1/x) 1
17:43:24 <lambdabot>   1.414213562373095
17:43:35 <Nereid> > fixpoint (\x -> (x + 5/x)/2) 1
17:43:37 <lambdabot>   2.23606797749979
17:44:52 <parcs> Pseudonym: how does that work?
17:45:06 <Nereid> > scanl (*) 1 . tail . iterate (\x -> sqrt (2 + 2*x) / 2) $ 0
17:45:08 <lambdabot>   [1.0,0.7071067811865476,0.6532814824381883,0.6407288619353766,0.63764357733...
17:45:26 <Nereid> > iterate (\x -> sqrt (2 + 2*x) / 2) $ 0
17:45:28 <lambdabot>   [0.0,0.7071067811865476,0.9238795325112867,0.9807852804032304,0.99518472667...
17:45:48 <parcs> > (!!100) . iterate (\x -> sqrt (2 + 2*x) / 2) $ 0
17:45:50 <lambdabot>   1.0
17:46:08 <Nereid> well the point is that it's an infinite product that converges to 2/pi.
17:46:11 <parcs> oh i didn't see the (/2)
17:46:16 <Pseudonym> Yes.
17:47:05 <parcs> > (!!100) . iterate (\x -> sqrt (2 + 2*x) / 2) $ -0.1
17:47:06 <lambdabot>  Terminated
17:47:53 <sipa> :t fixpoint
17:47:54 <lambdabot> (b -> b) -> b -> b
17:48:22 <Nereid> :t (!!100) . scanl (.) id
17:48:24 <lambdabot> [b -> b] -> b -> b
17:48:26 <Nereid> er
17:48:37 <Nereid> :t (!!100) . iterate
17:48:38 <lambdabot>     Couldn't match expected type `[b0]' with actual type `a0 -> [a0]'
17:48:38 <lambdabot>     Expected type: (a0 -> a0) -> [b0]
17:48:38 <lambdabot>       Actual type: (a0 -> a0) -> a0 -> [a0]
17:48:42 <Nereid> noo.
17:48:46 <Nereid> :t (!!100) .: iterate
17:48:47 <lambdabot> (b -> b) -> b -> b
17:48:49 <parcs> ohhh
17:50:01 <sipa> > fixpoint (+1) 0
17:50:03 <lambdabot>   100
17:50:07 <shachaf> liyang: I asked in #ghc, for all the good that does.
17:50:13 <sipa> riiiight
17:50:35 <Nereid> :p
17:50:42 <liyang> shachaf: I've asked on the ticket. :)
17:50:48 <shachaf> liyang: Oh, even better.
17:51:05 <parcs> > 2 / sqrt (sqrt 2)
17:51:07 <lambdabot>   1.6817928305074292
17:51:55 <parcs> oops
17:52:53 <parcs> i need more paper
17:52:58 <parcs> Pseudonym: i will solve your riddle
17:53:16 <Pseudonym> Which riddle?
17:53:37 <parcs>  > (2/) . (!!100) . scanl (*) 1 . tail . iterate (\x -> sqrt (2 + 2*x) / 2) $ 0
17:53:39 <parcs> > (2/) . (!!100) . scanl (*) 1 . tail . iterate (\x -> sqrt (2 + 2*x) / 2) $ 0
17:53:40 <lambdabot>   3.141592653589794
17:53:57 <Pseudonym> I didn't intend that as a riddle, but okay.
17:55:41 <parcs> i will solve it anyway
17:56:38 <Nereid> apparently that infinite product is due to Viète.
17:57:11 <Nereid> http://en.wikipedia.org/wiki/Vi%C3%A8te%27s_formula
17:57:53 <Nereid> parcs: ^
17:59:53 * hackagebot aws-sdk 0.8.0.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.8.0.0 (YusukeNomura)
18:00:06 <parcs> > (4/) . (!!100) . iterate (\x -> x*sqrt(2 + 2x) - sqrt(2)) $ 0
18:00:08 <lambdabot>   No instance for (GHC.Num.Num (a0 -> a0))
18:00:08 <lambdabot>    arising from a use of `e_141002...
18:00:39 <parcs> > (4/) . (!!100) . iterate (\x -> x*sqrt(2 + 2*x) - sqrt(2)) $ 0
18:00:41 <lambdabot>   NaN
18:02:03 <parcs> Nereid: thanks
18:02:41 <roadfish> @hoogle NaN
18:02:42 <lambdabot> Data.Fixed type Nano = Fixed E9
18:02:42 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Nand :: LogicOp
18:02:42 <lambdabot> package nano-cryptr
18:03:15 <Hello> Hello?
18:03:24 <Pseudonym> Hello, recursive fun!
18:03:37 * ivanm waves idly in Hello's general direction
18:03:50 <Nereid> > fix ("Hello " ++)
18:03:52 <lambdabot>   "Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello He...
18:03:54 <ivanm> kfish: when do you get in to Canberra?
18:04:08 <Nereid> > text (cycle "Hello ")
18:04:12 <lambdabot>   mueval: ExitFailure 1
18:04:13 <lambdabot>  mueval: Prelude.undefined
18:04:15 <Nereid> great.
18:04:17 <ivanm> > fix (text "Hello" <>)
18:04:20 <Nereid> > var (cycle "Hello ")
18:04:21 <lambdabot>   mueval-core: Time limit exceeded
18:04:21 <lambdabot>   Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hello Hel...
18:04:31 <ivanm> @type var
18:04:32 <lambdabot> String -> Sym a
18:04:41 <shachaf> @varrr
18:04:41 <lambdabot> Maybe you meant: arr yarr
18:04:43 <Nereid> > var x^2
18:04:44 <lambdabot>   Couldn't match expected type `GHC.Base.String'
18:04:45 <lambdabot>              with actual typ...
18:04:46 <ivanm> shachaf: heh
18:04:48 <Nereid> oh.
18:04:51 <Nereid> > SimpleReflect.var x^2
18:04:53 <lambdabot>   Not in scope: `SimpleReflect.var'
18:04:59 <Nereid> urgrhhh
18:05:04 <shachaf> > var "x" ^ 2
18:05:05 <Nereid> :t SimpleReflect.var
18:05:06 <lambdabot>   x*x
18:05:06 <lambdabot> String -> SimpleReflect.Expr
18:05:08 <Nereid> oh duh.
18:05:38 <shachaf> Nereid: So type inequality is one example of an uncategory.
18:05:46 <Nereid> haha
18:06:25 <shachaf> p a a -> Void, p x y -> Either (p x a) (p b y)
18:06:37 <kfish> ivanm, change of plans, not coming sorry ... was just in sydney for xmas but back in singapore now
18:07:12 <ivanm> oh; was the heat too much for you? :p
18:09:53 * hackagebot plot 0.1.7.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.7.1 (VivianMcPhail)
18:18:39 <roadfish> :ho fix
18:18:45 <roadfish> @hoogle fix
18:18:45 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
18:18:45 <lambdabot> Data.Fixed module Data.Fixed
18:18:45 <lambdabot> Data.Function fix :: (a -> a) -> a
18:20:28 <roadfish> fix (1 +)
18:20:36 <Nereid> > fix (0:)
18:20:38 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:20:49 <roadfish> > fix (1 +)
18:20:52 <lambdabot>   mueval-core: Time limit exceeded
18:21:18 <Ralith> uhoh
18:21:25 <Nereid> > fix (\f n -> if n == 0 then 0 else n * f (n-1)) 5
18:21:26 <lambdabot>   0
18:21:29 <Nereid> er
18:21:31 <Nereid> > fix (\f n -> if n == 0 then 1 else n * f (n-1)) 5
18:21:33 <lambdabot>   120
18:22:19 <roadfish> Interesting. ghci on my computer is locked up doing "fix (1 +)". But I don't see any CPU activity.
18:22:41 <Pseudonym> Isn't that identifiable as a black hole?
18:22:47 <Pseudonym> > let omega = 1 + omega in omega
18:22:49 <roadfish> what, exactly, is ghci doing with "fix (1 +)" if it isn't using any CPU?
18:22:51 <lambdabot>   mueval-core: Time limit exceeded
18:22:55 <Pseudonym> OK, maybe not.
18:23:02 <Pseudonym> roadfish: It might be stalling.
18:23:05 <Nereid> >>> fix (1+)
18:23:05 <Nereid> *** Exception: <<loop>>
18:23:50 <Pseudonym> It's been a while since I looked at this part of the GHC internals, but it might be assuming that another thread is doing the recursive computation, so it waiting for that.
18:24:05 <Nereid> no cpu usage, no allocations.
18:24:07 <Pseudonym> So what you've actually got is a deadlock.
18:24:20 <hpc> Pseudonym: someone explained it a few months ago
18:24:21 <Nereid> it takes about 5 seconds to output that message though.
18:24:26 <Pseudonym> Right.
18:24:36 <hpc> when you evaluate a thunk, it's changed to a blackhole that does one of two things
18:24:53 <parcs> > (\n -> 2^n * sin (pi / n)) 100
18:24:54 <lambdabot>   Ambiguous type variable `a0' in the constraints:
18:24:54 <lambdabot>    (GHC.Float.Floating a0)...
18:24:55 <hpc> on the unthreaded runtime, it errors because you have clearly looped into the exact same thunk over again
18:25:02 <roadfish> I've been running "fix (1+)" for much longer than 5 seconds. I think it will sit there forever.
18:25:05 <parcs> > (\n -> 2**n * sin (pi / n)) 100
18:25:06 <lambdabot>   3.9817867599013635e28
18:25:06 <hpc> on the threaded runtime, it waits for the "other thread" to finish
18:25:11 <parcs> > (\n -> 2**n * sin (pi / n)) 1000
18:25:12 <lambdabot>   3.3662380313486184e298
18:25:16 <Pseudonym> So I was right? Awesome.
18:26:27 <parcs> > (\n -> 2**n * sin (pi / 2**n)) 1000
18:26:29 <lambdabot>   3.141592653589793
18:26:33 <Nereid> so try something that allocates more thunks.
18:26:34 <parcs> hax
18:26:37 <roadfish> is ghci threaded or unthreaded. I tried "ghci -threaded" and it said "Warning: -debug, -threaded and -ticky are ignored by GHCi".
18:26:37 <Nereid> > fix (\f n -> f n) 0
18:26:41 <lambdabot>   mueval-core: Time limit exceeded
18:26:59 <parcs> roadfish: ghci is threaded
18:27:00 <hpc> ghci is "threaded"
18:27:18 <hpc> (ghci is a very odd thing)
18:27:31 <roadfish> ok, and I'm guessing that I can't request an unthreaded ghci
18:27:53 <hpc> roadfish: you should try compiling your own ghci with the unthreaded runtime
18:27:57 <hpc> just for shits and giggles :D
18:28:09 <roadfish> ok, I'm trying it now
18:28:09 <parcs> roadfish: try -fno-ghci-sandbox
18:28:26 <roadfish> I think that a good 20% of ghc exploration is shits and giggles
18:28:52 <cmccann> if this involved modifying GHC, the other 80% is waiting for it to compile
18:29:26 <parcs> good luck compiling it now. HEAD doesn't build at the moment
18:29:32 <cmccann> haha
18:29:37 <hpc> XD
18:29:50 <hpc> someday i will be a bad enough dude to HEAD ghc
18:30:08 <cmccann> a build that's never broken means you're not doing things that are interesting enough
18:30:33 <hpc> or it means you have developers that don't commit broken stuff
18:30:59 <simpson> It's difficult to keep HEAD unbroken.
18:31:24 <parcs> this is the culprit http://hackage.haskell.org/trac/ghc/changeset/97db0edc4e637dd61ec635d1f9b6b6dd25ad890c
18:31:42 <roadfish> ok, I got "fix: <<loop>>" when I did "ghc fix.hs;./fix"
18:31:46 <Pseudonym> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/965006902_6djpLdS
18:31:56 <roadfish> but I noticed that "runghc fix.hs" just froze up.
18:31:56 <cmccann> parcs: SPJ's fault? :O
18:32:19 <parcs> not segfault, but read this comment http://hackage.haskell.org/trac/ghc/changeset/97db0edc4e637dd61ec635d1f9b6b6dd25ad890c#file2
18:33:36 <parcs> specifically "if a type signature is wrong ,fail immediately." GHC.TypeLits has a "wrong" type signature inside a constructor definition of GADT
18:33:43 <parcs> of a GADT*
18:34:17 <cmccann> nice
18:34:51 <parcs> oh damnit
18:34:55 * hackagebot biofasta 0.0.3 - Library for reading fasta sequence files  http://hackage.haskell.org/package/biofasta-0.0.3 (DanFornika)
18:37:17 <parcs> oh wait, it's actually been fixed: https://github.com/ghc/packages-base/commit/4f27b5710232be868121cce5191c062999107327
18:46:00 <Guest00000> alright, f [Just (), Just ()] => Just ()
18:46:10 <Guest00000> alright, f [Just (), Nothing] => Nothing
18:46:31 <Guest00000> sequence?
18:46:39 <croikle> sequence
18:46:55 <croikle> or not...
18:47:14 <croikle> > sequence [Just (), Just ()]
18:47:16 <lambdabot>   Just [(),()]
18:47:27 <Guest00000> mconcat . sequence
18:49:48 <Hafydd> > foldl1 (>>) [Just (), Nothing]
18:49:49 <lambdabot>   Nothing
18:49:56 <Hafydd> > foldl1 (>>) [Just (), Just ()]
18:49:57 <lambdabot>   Just ()
18:50:51 <Guest00000> > mconcat . sequence $ sequence [Just (), Just ()]
18:50:52 <lambdabot>   Couldn't match expected type `[a0]'
18:50:52 <lambdabot>              with actual type `Data.May...
18:50:58 <Guest00000> oops
18:51:03 <Guest00000> > mconcat . sequence $ [Just (), Just ()]
18:51:04 <lambdabot>   Couldn't match expected type `[a0]'
18:51:04 <lambdabot>              with actual type `Data.May...
18:51:16 <Guest00000> : (
19:08:16 <reltuk> how can I transition a function whose signature is "Monad m => Int -> StateT PlayerWorld m a -> StateT PlayerState m a" to use MonadState instead?
19:11:53 <`nand`> MonadState PlayerWorld m => Int -> m a -> m a
19:13:40 <reltuk> `nand`: seems to imply that the state's type in the second parameter is the same as state's type in the return value
19:14:16 <`nand`> oh
19:14:17 <`nand`> my bad
19:14:18 <reltuk> the method returns a state action that zooms on a particular planet in PlayerState and then executes the PlayerWorld state action
19:14:26 <Guest00000> whats the diff between PlayerWorld and PlayerState
19:14:33 <`nand`> (MonadState PlayerWorld m, MonadState PlayerState m') => Int -> m a -> m' a
19:14:47 <`nand`> oh
19:14:49 <`nand`> but that's not the same
19:14:52 <glguy> reltuk: If you 're using lens, you can use the "zoom" function for that
19:14:53 <`nand`> since it assumes different stacks at the top
19:15:04 <`nand`> or well, doesn't assume the same stack
19:15:07 <glguy> otherwise you just need to get the outer state, run the inner thing , and put part back
19:15:11 <`nand`> and by ‘at the top’ I mean ‘underneath the StateT’
19:15:29 <Nereid> :t zoom
19:15:30 <lambdabot> Zoom m n k s t => SimpleLensLike (k c) t s -> m c -> n c
19:15:35 <`nand`> depending on what your code does, it probably can't be done - if you use runStateT or something, then the former parameter will have to be StateT PlayerWorld m a
19:15:37 <Nereid> heh.
19:16:02 <reltuk> Nereid: lens' types are nuts :-P
19:16:34 <Nereid> wait until 3.8
19:17:19 <glguy> reltuk: transition i m = do s <- get; (x,w) <- lift (runState m (world s)); set (setworld s w); return x
19:17:25 <glguy> otherwise you have to do something like that
19:18:13 <glguy> with lenses you'd have: transition i m = zoom worldLens m
19:18:30 <reltuk> glguy: yeah, it's using zoom currently :-)
19:19:06 <glguy> I didn't read your question correctly
19:19:09 <Nereid> :t zoom _2
19:19:10 <lambdabot> (Functor (k c), Zoom m n k s t, Field2 t t s s) => m c -> n c
19:19:12 <cmccann> lens is an attempt to produce a constructive disproof of the conjecture that type signatures make functions easier to understand
19:19:20 <Nereid> :t zoom (_2 :: SimpleLens (a,b) b)
19:19:21 <lambdabot> (Functor (k c), Zoom m n k s (a, s)) => m c -> n c
19:19:28 <Nereid> blah.
19:19:40 <edwardk> lens is more an attempt to see if i can make a library that is useful enough to force people to learn new abstractions
19:20:04 <shachaf> edwardk: Or useless enough to force people to invent new abstractions!
19:20:09 <cmccann> edwardk: the problem is the library works too well
19:20:17 <`nand`> I don't quite understand Zoom; the type class mentions ‘s’ and ‘t’, but you still have to provide your own LensLike'?
19:20:18 <cmccann> you can use it without understanding it at all
19:20:25 <edwardk> and so they don't need to learn the types to use it?
19:20:25 <edwardk> yeah
19:20:29 <Nereid> > execState (zoom _2 (put 3)) (0,0)
19:20:31 <lambdabot>   (0,3)
19:20:55 <shachaf> cmccann: I think edwardk is in it for the long term.
19:20:56 <edwardk> `nand`: the 's' and 't' are determined by your lens/traversal
19:21:06 <cmccann> edwardk: perhaps you should find ways to make it harder to use.
19:21:07 <shachaf> cmccann: When you start out, lens is easy. You barely need to learn any new abstractions.
19:21:12 <cmccann> well, I guess that's why you keep shachaf around.
19:21:21 <shachaf> But later just plain lenses aren't enough. You start wanting traversals here and there. Maybe a prism.
19:21:23 <edwardk> shachaf: yes, i'm slowly turning the thumbscrews
19:22:02 <hpaste> jwatson pasted “SPOJ 1” at http://hpaste.org/80519
19:22:23 <shachaf> cmccann: Puzzle: Why is Upseta and Unsettle so horrible?
19:22:30 <shachaf> newtype Upseta a t s z w = Upseta { unUpseta :: (w -> Either z a) -> s -> Either t a }
19:22:34 <shachaf> newtype Unsettle t s b z w = Unsettle { unUnsettle :: (w -> s -> z) -> b -> s -> t }
19:22:38 <glguy> A lot of the type craziness comes from wanting to quietly overly things to pass indexes through, to be able to be reversed, etc
19:22:42 <edwardk> i added lenses to both parsers and trifecta the other day, it made a HUGE difference in legibility
19:22:57 <glguy> overly->overload
19:23:11 <edwardk> glguy: yeah, with lens i admit i've been willing to bend over backwards to get little bits of generality
19:23:13 <shachaf> Well, trifecta was already a pile of abstractions.
19:23:20 <`nand`> edwardk: oh, the ‘s’ and ‘t’ are there so they can affect ‘m’ and ‘n’
19:23:23 <Nereid> `nand`: the point of zoom is: if you have a lens into a part of your state, then you can lift a State action on that part to an action on the whole.
19:23:25 <edwardk> usually because after i do that 3-4 times, the new thing is much simpler than what i brute forced to start with
19:23:33 <Nereid> so
19:23:40 <Nereid> one example is
19:23:57 <edwardk> Nereid: even better, if you have a traversal, it'll run your action multiple times, focused in on each target, an stitch together a monoidal summary of each thing it did
19:23:59 <Nereid> zoom :: SimpleLens t s -> State s a -> State t a
19:24:01 <edwardk> you can zoom traverse
19:24:07 <Nereid> really.
19:24:11 <Nereid> that's pretty cool.
19:24:13 <cmccann> shachaf: I dunno, but I'm assuming it's your fault, whatever the reason is.
19:24:14 <`nand`> shachaf: how.. unsettling
19:24:26 <shachaf> cmccann: Uhh, can I blame elliott?
19:24:33 <edwardk> zoom traverse :: Monoid m => State s m -> State [s] m
19:24:37 <shachaf> cmccann: It's at *least* half his fault.
19:24:54 * shachaf thinks we should reconsider index preservation at one point.
19:24:56 <cmccann> no surprised.
19:24:56 <Nereid> > execState (zoom traverse (modify (+1)) [1,2,3]
19:24:58 <lambdabot>   <hint>:1:47: parse error (possibly incorrect indentation)
19:25:07 <startling> shachaf: you're saying he was a coconspirator?
19:25:08 <Nereid> > execState (zoom traverse (modify (+1))) [1,2,3]
19:25:09 <lambdabot>   [2,3,4]
19:25:27 <Nereid> > evalState (zoom traverse (gets Sum)) [1,2,3]
19:25:28 <lambdabot>   Sum {getSum = 6}
19:25:29 <edwardk> > runState (zoom traverse get) ["hello","world"]
19:25:29 <shachaf> cmccann: We were actually working on k2.hs together in a shared editor session.
19:25:30 <lambdabot>   ("helloworld",["hello","world"])
19:26:16 <edwardk> shachaf: i'm planning on reconsidering plumbing the q's out of each function, but probably not the existence of index-preservation as a whole
19:26:17 <Nereid> > evalState (uses Sum) [1,2,3]
19:26:19 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.State
19:26:19 <lambdabot>         ...
19:26:21 <Nereid> er
19:26:29 <Nereid> > evalState (uses id Sum) [1,2,3]
19:26:31 <lambdabot>   Sum {getSum = [1,2,3]}
19:26:37 <edwardk> i'm also down with the idea of dumbing lens and mapped/lifted back to non-preserving
19:26:43 <`nand`> ah, () is a Monoid; I think that's the first time I've seen this instance really come in handy :)
19:26:44 <shachaf> edwardk: Well, index preservation on things that can't be indexed anyway isn't so bad.
19:26:49 <`nand`> (other than monadic folds or w/e)
19:26:52 <shachaf> edwardk: By the way, does index = measure for Isos?
19:27:09 <hpaste> jwatson pasted “SPOJ 1.0” at http://hpaste.org/80520
19:27:19 <shachaf> I wonder whether indexes become measures in oppositeworld or something.
19:27:22 <shachaf> That would be neat.
19:27:27 <john_r_watson> is there a better way? http://hpaste.org/80520
19:27:28 <`nand`> > execState (modify (traverse +~ 1)) [1,2,3] -- of course, this is a much simpler way to do that
19:27:30 <lambdabot>   [2,3,4]
19:27:30 <edwardk> shachaf: i've been using the Indexed class as the Measured type we talked about in testing
19:27:35 <Nereid> of course.
19:27:36 <edwardk> er Indexed data type
19:27:46 <john_r_watson> (form https://www.spoj.com/problems/TEST/)
19:28:14 <glguy> > execState (traverse += 1) [1,2,3]
19:28:16 <lambdabot>   [2,3,4]
19:28:41 <glguy> > (traverse +~ 1) [1,2,3]
19:28:43 <lambdabot>   [2,3,4]
19:28:48 <glguy> > map (+1) [1,2,3]
19:28:49 <lambdabot>   [2,3,4]
19:28:53 <glguy> yay, simple again ;)
19:28:57 <shachaf> > [2,3,4]
19:28:58 <lambdabot>   [2,3,4]
19:29:03 <Nereid> [2..4]
19:29:05 <Nereid> > [2..4]
19:29:05 <`nand`> john_r_watson: you could do something like:  takeWhile ((/= 42) . read) . lines <$> getContents -- or something
19:29:06 <lambdabot>   [2,3,4]
19:29:11 <shachaf> Nereid wins.
19:29:13 <Hafydd> Hahah.
19:29:18 <min|dvir|us> > map (+1) 1:2:3:[]
19:29:19 <lambdabot>   No instance for (GHC.Num.Num [b0])
19:29:19 <lambdabot>    arising from a use of `e_11123'
19:29:19 <lambdabot>  Poss...
19:29:23 <Tordek> dang it, I was typing that, Nereid !
19:29:24 <Nereid> > map (+1) (1:2:3:[])
19:29:26 <lambdabot>   [2,3,4]
19:29:40 <shachaf> @let ha = [2..4]
19:29:41 <lambdabot>  Defined.
19:29:42 <edwardk> there is a deliberate connection between exectState (foo += ..)  and foo +~ ...
19:29:42 <shachaf> > ha
19:29:44 <lambdabot>   [2,3,4]
19:29:50 <`nand`> which would give you an IO [String], which you could then mapM_ putStrLn I guess
19:29:56 <Hafydd> @let h = [2..4]
19:29:57 <lambdabot>  Defined.
19:29:59 <Hafydd> > h
19:30:00 <lambdabot>   Ambiguous occurrence `h'
19:30:00 <lambdabot>  It could refer to either `L.h', defined at <local...
19:30:04 <Hafydd> Damn.
19:30:06 <`nand`> or bind (putStr . unlines), w/e
19:30:06 <Tordek> Ha.
19:30:18 <Hafydd> @unlet
19:30:21 <lambdabot>  Defined.
19:31:20 <john_r_watson> `nand`: thanks!
19:31:54 <edwardk> ha ;)
19:32:33 <Nereid> why can't I feed lambdabot non-ascii stuff :(
19:33:38 <watermind> @let a = 'á'
19:33:40 <lambdabot>  Defined.
19:33:41 <fragamus> do you guys see anything untidy about     newVal <- (foldl' (<=<) f (replicate 1000 f)) val
19:33:43 <watermind> > a
19:33:45 <lambdabot>   Ambiguous occurrence `a'
19:33:45 <lambdabot>  It could refer to either `L.a', defined at <local...
19:34:04 <watermind> @unlet a
19:34:04 <lambdabot>   TemplateHaskell is not enabled
19:34:46 <Nereid> @undefine
19:34:51 <Nereid> > a
19:34:52 <lambdabot>   a
19:34:55 <watermind> oh
19:35:44 <watermind> > concat ["á"]
19:35:44 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
19:42:59 <crclark> Anyone know if there is a way to declare "instance Ord b => Ord (a,b)" in a way that doesn't conflict with the already existing "instance (Ord a, Ord b) => Ord (a,b)"?
19:43:34 <Cale> crclark: No, that definitely conflicts
19:43:40 <copumpkin> crclark: make a newtype for your fst component with a dummy Ord instance :)
19:44:10 <Cale> Yeah, the solution when you want to get an instance with different behaviour is usually just to make a newtype wrapper
19:44:52 <Cale> crclark: When an instance is being selected, the contexts on the instances are *ignored*, and only once the instance is chosen do they get enforced.
19:45:21 <crclark> Hmm. So, there's no fancy extension that lets me say something like "instance (NotOrd a, Ord b) => Ord (a, b)"?
19:45:27 <Cale> crclark: This is because the compiler can never assume that an instance absolutely doesn't exist while compiling a given module, because there might be an instance in a module it hasn't reached yet.
19:45:40 <reltuk> Could not deduce (Zoom n m k0 PlayerWorld PlayerState) arising from a use of `zoom' ...  The type variable `k0' is ambiguous ... Possible fix: add a type signature that fixes these type variable(s)
19:45:46 <crclark> Cale: aha, that answers my question entirely. Thanks.
19:45:51 <Cale> (or which hasn't even been written yet)
19:46:22 <Nereid> reltuk: paste.
19:46:50 <reltuk> i'll try to distill it...it's surrounded by junk :-)
19:48:42 <glguy> reltuk: If you're making a function that is polymorphic in m and n, you're going to need a Zoom constraint on your function
19:52:55 <mephx> how does a Setup.hs look for dependencies? isn't it supposed to be reported by ghc-pkg in PATH? are there any incompatibility issues with Cabal-1.14 with ghc-7.6.1?
19:52:55 <reltuk> glguy: does the zoom constraint have to specify an actual transformer?
19:53:52 <glguy> reltuk: the m and n pick k, you might have to manually thread that through somehow to the first argument of zoom
19:54:19 <Guest00000> Monoid = Semigroup . Maybe ;)
19:56:25 <reltuk> merp...it's gonna leak everywhere if i add that constraint :-P
19:58:15 <ivanm> mephx: do you mean dependencies listed in the .cabal file, or dependencies for the actual Setup.hs module?
19:58:53 <ivanm> the Cabal library uses the dependencies listed in the .cabal file to instruct GHC to only show packages that match the requirements when building
19:59:08 <mephx> ivanm: while running ./Setup configure --prefix=myprefix
19:59:11 <ivanm> it is possible, however, for a custom Setup.hs to require modules that aren't actual package dependencies
19:59:44 <ivanm> mephx: OK, for building the actual package; it grabs the dependencies from the .cabal file, and then tells GHC to hide every package _except_ the ones that match the requirements
20:00:10 <mephx> on Cabal-1.14, says "base >=4 && <3 && >=2 && <5" I have
20:00:16 <mephx> base-4.6.0.0
20:00:49 <gienah> mephx: sounds like silly upper bounds dep on base
20:01:01 <Nereid> <3 ?
20:01:21 <gienah> Nereid: nah, its probably confused by another upper bound
20:02:09 <gienah> although the <5 is seems ok, there might be some flag or something
20:02:16 <mephx> I'm trying cabal 1.16 now
20:02:21 <shachaf> base ♥
20:03:20 <gienah> mephx: oh yeah, cabal 1.16* is required for ghc 7.6.1
20:03:37 <ivanm> and Cabal-1.16.0 should already be installed...
20:03:41 <mephx> Setup: At least the following dependencies are missing:
20:03:44 <mephx> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6
20:03:56 <mephx> I have unix 2.7, and base 4.6 =|
20:04:05 <ivanm> which package is this?
20:04:11 <mephx> Cabal-1.16
20:04:19 <ivanm> why are you trying to install Cabal-1.16?
20:04:23 <ivanm> it should already be there...
20:04:26 <mephx> haskell-7.6.1
20:04:29 <ivanm> ghc-pkg list Cabal
20:04:49 <ivanm> if you mean ghc-7.6.1 ... it comes with Cabal-1.16
20:04:54 <mephx> indeed
20:04:58 <mephx> there he is :|
20:05:00 <ivanm> so why are you trying to install it?
20:05:27 <mephx> ivanm: though that it only came with hp, unnavailable for 7.6.1
20:05:36 <ivanm> huh?
20:05:38 <ivanm> Cabal ships with GHC
20:05:42 <ivanm> cabal-install doesn't
20:05:50 <ivanm> two entirely different things
20:05:57 <mephx> ah, then I'm on the road
20:05:59 <hpaste> reltuk pasted “zoom and MonadState” at http://hpaste.org/80521
20:06:01 <mephx> cabal-install, same error
20:06:26 <ivanm> mephx: if you want to build and install cabal-install (and you don't already have one from a previous install), get the tarbal, unpack it and run the bootstrapping script
20:06:43 <reltuk> basically the question is, can i keep the surrounding functions general in MonadState and still use zoom...probably not
20:06:53 <mephx> the boostrap script throws out the same errors
20:07:04 <mephx> base and unix
20:07:08 <ivanm> which version of cabal-install?
20:07:20 <mephx> 1.16
20:07:55 <ivanm> why not the latest one?
20:08:05 <ivanm> 1.16.0.2
20:08:14 <gienah> ivanm: yeah that one works
20:08:24 <mephx> branch?
20:08:37 <ivanm> why are you wanting a branch?
20:08:44 <ivanm> http://hackage.haskell.org/package/cabal-install-1.16.0.2
20:09:09 <ivanm> there's a tarball link down the bottom
20:09:18 <ivanm> gienah: even 1.16 should work IIUC
20:09:38 * gienah hasn't tried cabal-install 1.16
20:10:15 <cmccann> haha, my quote about blaming shachaf ended up in HWN.
20:10:27 <ivanm> wget http://hackage.haskell.org/packages/archive/cabal-install/1.16.0.2/cabal-install-1.16.0.2.tar.gz && tar xaf cabal-install-1.16.0.2.tar.gz && cd cabal-install-1.16.0.2 && ./bootstrap.sh
20:10:32 <ivanm> mephx: ^^
20:10:37 <mephx> already running
20:10:41 <mephx> thanks for the effor though =)
20:10:51 <shachaf> cmccann: HWwhat?
20:10:59 * shachaf thought that was over.
20:11:02 <mephx> parsec, network, I'm good
20:11:19 <cmccann> he finished moving apparently.
20:14:21 <Nereid> edwardk: can you help reltuk ?
20:14:31 <Nereid> :c
20:14:36 <shachaf> cmccann: Seems to me that elliott is in the lead.
20:14:43 <mephx> done, thanks
20:14:53 <shachaf> cmccann: Also, we're running dangerously low on lens quotes.
20:15:23 <cmccann> shachaf: yeah but half the quotes at least are from #haskell-lens regulars
20:15:45 <cmccann> the HWN quotes section is basically lensketeer comedy hour, this is not a new development
20:17:55 <shachaf> So mirrored first = loop, and mirrored loop = first
20:58:05 <reltuk> stylistically, should i just not be writing these functions against MonadState?
21:14:16 <statusfailed> reltuk: which functions?
21:15:46 <reltuk> statusfailed: sorry, was an older hpaste: hpaste.org/80521
21:18:39 <statusfailed> yay, zoom
21:18:43 <NemesisD> is there some obvious way to map a monadic function over the values in a Data.Map?
21:18:45 <statusfailed> such a useful function
21:19:07 <NemesisD> for some reason foldable has a mapM_ but no mapM
21:20:02 <CodeDmitry> Hello
21:20:17 <CodeDmitry> New haskell user here
21:21:08 <NemesisD> ohh, it looks like that's part of Traversable
21:21:25 <reltuk> NemesisD: you want something (a -> m b) -> Map k a -> m (Map k b) ?
21:21:36 <statusfailed> CodeDmitry: hello!
21:21:57 <reltuk> statusfailed: i'm currently replacing my uses of it because i can't make it type check :-P
21:22:13 <statusfailed> ah :P
21:22:22 <statusfailed> I think that code can be written without state at all right?
21:23:03 <statusfailed> because you know both types in advance
21:23:16 <statusfailed> so it's not like you need to embed the PlayerState in some unknown larger product type
21:24:35 <SamanthaD> hi
21:24:37 <reltuk> the lenses that you use are always going to force the type that is held in the state, right?
21:24:42 <CodeDmitry> Hello :-)
21:25:17 <CodeDmitry> So painful to read haskell documentation
21:25:29 <statusfailed> CodeDmitry: it gets much easier with practice :)
21:25:35 <CodeDmitry> Or to find what u need when u need it
21:25:39 <croikle> what's something that's foldable but not traversable?
21:25:58 <statusfailed> reltuk: Well, you can write a zoomed state function without binding the 'outer' state type, right?
21:26:13 <statusfailed> (as long as you pass in the lens)
21:26:31 <edwardk> crclark: Set
21:26:39 <edwardk> er croikle
21:26:48 <SamanthaD> quick question: does something like: function (x:xs) | test x = x : xs incrue a performance hit?
21:27:23 <reltuk> yeah, the alternative is to write MonadState a m actions that take a (SimpleLens a PlayerWorld) as an argument
21:27:29 <edwardk> SamanthaD: it'll take the cons cell apart and build a new one if thats what you mean
21:27:33 <edwardk> that can cost you sharing
21:27:49 <edwardk> function xxs@(x:_) | test x = xxs    avoids that
21:27:50 <shachaf> SamanthaD: Yes, it does.
21:27:53 <reltuk> but that doesn't seem as natural as writing a MonadState PlayerWorld m action and then zooming on it
21:27:56 <shachaf> I benchmarked it at one point.
21:28:00 <shachaf> You can do what edwardk said, though.
21:28:01 <SamanthaD> edwardk: yes, it is. So it's better to use head in the guard rather than the syntactic sugar.
21:28:15 <edwardk> SamanthaD: or use the as pattern like i did there
21:28:27 <shachaf> SamanthaD: No, don't use head. Use @
21:28:29 <SamanthaD> edwardk: ooh, thanks
21:28:35 <SamanthaD> shachaf: much thanks for the knowledge
21:28:46 <shachaf> Matching on foo@(x:xs) matches x:xs, and also gives the name "foo" to the whole thing.
21:28:55 <SamanthaD> shachaf: I'm afraid I don'kt know how to use @, what's it called?
21:29:02 <SamanthaD> OH
21:29:13 <SamanthaD> shachaf: @ is syntactic sugar for let?
21:29:24 <shachaf> No, it's a special matching sugar.
21:29:26 <CodeDmitry> What does x:xs mean, its everywhere
21:29:34 <shachaf> > let f a@(b:c) = (a,b,c) in f "hello"
21:29:35 <lambdabot>   ("hello",'h',"ello")
21:29:39 <shachaf> SamanthaD: ☝
21:29:46 <SamanthaD> CodeDmitry: it means x cons xs
21:30:06 <CodeDmitry> Whats cons
21:30:45 <croikle> x is the first element in the list, xs is the rest of the list
21:31:03 <edwardk> > 1 : 2 : 3 : []
21:31:04 <lambdabot>   [1,2,3]
21:31:05 <CodeDmitry> Head,tail?
21:31:13 <croikle> > let (x:xs) = [1,2,3] in show x ++ " " ++ show xs
21:31:15 <lambdabot>   "1 [2,3]"
21:31:15 <edwardk> : puts a new element on the front of a list when used as an expression
21:31:23 <SamanthaD> CodeDmitry: Oh, cons is when you take one item and stick it in the head of a list. So what you're doing when you have x:xs is that you're taking the head of a list and the remainder of the list.
21:31:26 <edwardk> when used as a pattern it matches the head and tail
21:31:32 <SamanthaD> CodeDmitry: yes, exactly
21:32:15 <CodeDmitry> Concatenation? Isnt there a function for that?
21:32:18 <SamanthaD> I love how helpful and friendly #haskell is <3
21:32:34 <SamanthaD> CodeDmitry: Yes, there is. But sugar makes your code look sweet.
21:32:37 <statusfailed> reltuk: i'm not sure why that function has to be stateful actually
21:32:43 <CodeDmitry> What sugar
21:32:57 <reltuk> statusfailed: .= ... it's reduced from a larger program, of course
21:33:12 <SamanthaD> CodeDmitry: "sugar" is what you call it when you have more than one way to express something. For example, you can use guards instead of if-then-else.
21:33:17 <CodeDmitry> So much superfluous terminology in this language
21:33:23 <Nereid> no, sugar isn't that.
21:33:34 <Nereid> and guards are more powerful than if-then-else
21:33:48 <shachaf> CodeDmitry: This sort of thing is covered in more detail in most introductions to Haskell. Are there any that you're reading?
21:33:51 <CodeDmitry> What are guards
21:33:56 <lpsmith> well,  function (x:xs) | test x = (x:xs) doesn't necessarily create a new cons cell;  it depends on how much you want to trust common subexpression elimination.
21:34:00 <shachaf> @where lyah -- often recommended in here
21:34:00 <lambdabot> http://www.learnyouahaskell.com/
21:34:20 <reltuk> statusfailed: i got rid of focusPlanet and replaced it with composed lenses and operating on PlayerState...but now I have to rewrite all the stateful functions in that module to actually operate on GameState instead and select the player
21:34:30 <CodeDmitry> I have tried reading many haskell documentations
21:34:30 <Nereid> http://www.haskell.org/haskellwiki/Tutorials
21:34:33 <reltuk> i think sticking with MonadState is the wrong idea
21:34:36 <Nereid> lists some good places tos tart
21:34:39 <Nereid> LYAH is pretty popular
21:34:44 <edwardk> reltuk: you can zoom if you don't want to select
21:34:56 <SamanthaD> CodeDmitry: it's a statement that must return true before the rest of the statement is evaluated. You'll get to them usually near the back of most tutorials.
21:34:56 <reltuk> things work well if I use StateT...
21:35:11 <CodeDmitry> When i hear mathematical terminology in programming when simpler terms could be used, i get confused and angry
21:35:30 <edwardk> reltuk: having trouble zooming around when you have a MonadState constraint?
21:35:35 <reltuk> edwardk: yeah...I could get it to work without concretizing on a state monad type
21:35:52 <reltuk> distilled example: http://hpaste.org/80521
21:36:06 <edwardk> reltuk: yeah, thats the unfortunate downside of lenses is that zooming forces you to a concrete state monad =(
21:36:19 <SamanthaD> CodeDmitry: But... how else would you describe a mathematical concept?
21:36:23 <edwardk> one way around this is to use makeClassy and build big composite states rather than zoom much
21:37:02 <CodeDmitry> There are many ways to describe mathematical concepts with natural analogies, or plain logic
21:37:17 <CodeDmitry> Without resorting to 'deductions'
21:37:46 <edwardk> reltuk: you can solve this in a few ways
21:37:54 <SamanthaD> CodeDmitry: I prefer the mathematical names. Especially when you have a concept like monads. I mean... you don't call arrays "grid like things," do you?
21:37:58 <edwardk> one is to move the State to the outside
21:38:18 <edwardk> so its the outermost thing in the transformer stack, then you can use zoom on it without crazy signatures
21:38:30 <edwardk> just work with StateT s m     where m is a monad transformer stack
21:38:39 <edwardk> and then zoom won't incur any funny dependencies on m
21:38:44 <CodeDmitry> Arrays are standard types that every programmer naturally understands, although lists are simpler
21:38:53 <edwardk> this isn't very satisfying, but it does give you zooming
21:39:05 <statusfailed> reltuk: sorry ,I totally misunderstood the purpose of your question!
21:39:12 <edwardk> and its still less of a restriction than what we used to do have to do with data-lens
21:39:26 <edwardk> the problem with zoomNthPlanet :: (MonadState PlayerWorld n, MonadState PlayerState m) => Int -> n a -> m a
21:39:27 <CodeDmitry> But the ghci errors are incomprehensible
21:39:31 <edwardk> is that m and n are completely unrelated.
21:39:36 <CodeDmitry> Like 'ridgid type'
21:39:40 <statusfailed> CodeDmitry: well not naturally- arrays aren't _that_ easy when you first teach someone to program
21:39:44 <CodeDmitry> Good luck googling it
21:39:44 <SamanthaD> CodeDmitry: Only beacuse most languages take them for granted... Haskell and functional programming are ACTUALLY significantly different than imperative languages so if you're approaching it expecting to only need concepts you're used to from other languages you're going to get very, very frustrated...
21:39:48 <edwardk> n could be IO with missile launches, etc. while m could be just 'State'
21:39:58 <edwardk> Zoom has all those crazy constraints to relate the two types
21:40:48 <basdirks> CodeDmitry: ghci error messages are pretty horrible for beginners, but you seem pretty averse to learning in general
21:40:50 <reltuk> sounds good. are there downsides to StateT being outermost?
21:41:06 <CodeDmitry> Define averse
21:41:09 <edwardk> so thats one solution, another is to do something like what the Lensed monad does inside of the snap framework. they have a custom monad you can move around in which usually lives on the outside
21:41:13 <SamanthaD> CodeDmitry: What I'm saying is that we're not being obtuse just for the sake af it ;)
21:41:28 <amindfv> honestly I never found ghci messages bad -- the nice thing is generally you only hit ~5 of them
21:41:55 <CodeDmitry> I never seen obtuse used in that context
21:42:00 <CodeDmitry> >.>
21:42:06 <edwardk> reltuk: well, it is a pretty reasonable place to put it, there are some ways it interacts with cont but other monads generally don't care
21:42:52 <edwardk> its also probably the most sensible place relative to error for many uses
21:43:41 <slack1256> anybody has had luck with the haskell FFI and Rust (mozilla lang)
21:44:17 <slack1256> has anybody had.. (sorry my engRish is showing)
21:45:24 <SamanthaD> CodeDmitry: I think he's saying that you've barely got your toes wet in a language but you seem to be passing judgement on how the language does things beacues they don't match what you're expecting of it. The thing is, it's significantly different than anything eles you've probably ever seen but it's that way for a reason. Try to give it some time and pretend you don't know how to program at all. That's the best way to approach it.
21:45:27 <CodeDmitry> I spent a few last days just to find a way to turn a string to num
21:45:35 <CodeDmitry> >.>
21:45:43 <reltuk> 'k, we're just gonna do that then.  thanks a bunch edwardk :-)
21:45:50 <edwardk> np
21:46:20 <CodeDmitry> Never seen such a huge learning curve in any language i tried in last 9 years
21:46:28 <CodeDmitry> >.>
21:46:36 <SamanthaD> CodeDmitry: Prolly gonna have to use some kind of string parsing library for that...
21:47:08 <CodeDmitry> I ended up using show mystring::Int
21:47:09 <SamanthaD> CodeDmitry: You know what... Have you ever tried Scheme or any of the other Lisps?
21:47:13 <basdirks> > read "123" :: Int
21:47:15 <lambdabot>   123
21:47:17 <slack1256> CodeDmitry: remember you can always use hoogle and Hayoo
21:47:22 <CodeDmitry> Read*
21:47:40 <basdirks> > read "123" :: Float
21:47:41 <lambdabot>   123.0
21:47:51 <NemesisD> hmm. i've got foo :: FilePath -> IO FilePath, path :: Maybe FilePath, in a do block, i'm trying to do something like: do fooified <- foo <$> path, what am i doing wrong
21:47:52 <CodeDmitry> I used hoogle, go hoogle atoi or toint ... or anything relevant
21:48:05 <CodeDmitry> It wont suggest read a::Int
21:48:17 <CodeDmitry> Oops
21:48:21 <slack1256> CodeDimitry: usually in hoogle you put type signatures
21:48:23 <NemesisD> i'm trying to use the monad instance of maybe and lift it into the IO monad
21:48:32 <reltuk> the one other problem i was having with lenses was returning one from a monad
21:48:40 <reltuk> but i think from the documentation i just need to a loupe
21:48:43 <reltuk> is that correct?
21:48:50 <slack1256> @hoogle Integer -> Num
21:48:51 <lambdabot> Warning: Unknown type Num
21:48:51 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
21:48:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:49:09 <slack1256> @hoogle Num a => Integer -> a
21:49:09 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
21:49:09 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
21:49:09 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:49:20 <CodeDmitry> I dont know why there is no fromintegral function
21:49:53 <CodeDmitry> Tointegral*
21:49:56 <slack1256> @hoogle Integral b, Num a => a -> b
21:49:56 <lambdabot> Parse error:
21:49:56 <lambdabot>   Integral b, Num a => a -> b
21:49:56 <lambdabot>             ^
21:50:08 <basdirks> @ty toInteger
21:50:09 <lambdabot> Integral a => a -> Integer
21:50:10 <slack1256> @hoogle (Integral b, Num a) => a -> b
21:50:10 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
21:50:11 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
21:50:11 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
21:50:23 <SamanthaD> CodeDmitry: wait... you want to transform an integral to a string? That's easy. Use the show function!
21:50:32 <slack1256> CodeDmitry: there you go, ceiling, floor, round
21:51:04 <CodeDmitry> No i just wanted to know how to turn num back to integral
21:51:28 <CodeDmitry> Kinda silly not to have tointegral
21:52:00 <slack1256> not all things that are Num can be Integral
21:52:22 <slack1256> but all the "things" on RealFrac can be approximated, so can be converted to Integral
21:52:38 <SamanthaD> CodeDmitry: floats and doubles, to be exact, can't be integrals.
21:52:56 <slack1256> exactly, that why you have to approximate them
21:53:13 <slack1256> for example 'Complex numbers' are Num but not RealFrac
21:53:17 <slack1256> also not Integral
21:53:23 <CodeDmitry> Integrals can be floats,doubles?
21:53:37 <slack1256> no, but can be approximated
21:53:41 <SamanthaD> CodeDmitry: if you need to turn a Float/Double to an integral you ought to use either ceiling, floor, or round.
21:53:42 <slack1256> > floot 5.5
21:53:43 <lambdabot>   Not in scope: `floot'
21:53:43 <lambdabot>  Perhaps you meant one of these:
21:53:43 <lambdabot>    `floor' (imported...
21:53:49 <slack1256> > floor 5.5
21:53:50 <lambdabot>   5
21:54:00 <slack1256> > ceiling 5.6
21:54:02 <lambdabot>   6
21:54:05 <SamanthaD> CodeDmitry: floats and doubles can NOT be integrals!
21:54:17 <CodeDmitry> Floats,doubles are nums?
21:54:31 <SamanthaD> CodeDmitry: yes, they are... but not all nums are integrals!
21:54:32 <slack1256> Yes.
21:54:50 <CodeDmitry> How curious...
21:54:59 <slack1256> isn't it?
21:55:10 <SamanthaD> CodeDmitry: Integrals refer to int and integer only.
21:55:39 <SamanthaD> CodeDmitry: In other words, only bounded or unbounded integers.
21:55:43 <CodeDmitry> Is there a reason to use integral over int?
21:55:52 <slack1256> CodeDmitry: generality
21:56:09 <basdirks> @lyah
21:56:09 <lambdabot> Unknown command, try @list
21:56:10 <CodeDmitry> Example?
21:56:15 <SamanthaD> CodeDmitry: Yes, you use integral when you want your fuction to be polymorphic. That is, when you want your function to be able to accept both int and integer you can use integral.
21:56:21 <slack1256> what if you developing need an arbitrary large number?, you would have to change signatures just to use Integer
21:56:37 <CodeDmitry> Int is not an integer?
21:56:45 <slack1256> no
21:56:49 <Nereid> > 10^100 :: Integer
21:56:50 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
21:56:52 <Nereid> > 10^100 :: Int
21:56:53 <lambdabot>   0
21:56:57 <Nereid> heh.
21:57:14 <slack1256> > maxBound :: Int
21:57:15 <lambdabot>   9223372036854775807
21:57:18 <slack1256> > maxBound :: Integer
21:57:20 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
21:57:20 <lambdabot>    arising from...
21:57:36 <CodeDmitry> Int is the 32 bit int?
21:57:39 <NemesisD> i think i need to do something like Maybe a -> (a -> IO a) -> IO (Maybe a)
21:57:51 <basdirks> CodeDmitry: depending on your platform, yes
21:57:53 <slack1256> CodeDmitry: on a 32-bit machine, yes.
21:58:01 <slack1256> as basdirks says
21:58:08 <SamanthaD> CodeDmitry: Integer is *UNBOUNDED* it has no upper or lower bound at ALL. It will continue going up till it takes every last byte in your computer's memory and swap!
21:58:10 <CodeDmitry> Integral is an adt?
21:58:24 <slack1256> No, a typeclass
21:58:26 <Nereid> :t \a f -> maybe (return Nothing) f a
21:58:27 <lambdabot> Monad m => Maybe a -> (a -> m (Maybe a1)) -> m (Maybe a1)
21:58:43 <SamanthaD> CodeDmitry: Could I suggest you read Real World Haskell? It really gets into these kinds of details.
21:58:49 <Nereid> er
21:58:49 <basdirks> it's a typeclass, have you learned about those yet?
21:58:54 <slack1256> which is a fancy way to say that every instance of Integral (example Integer, Int) has defined operations for them
21:58:58 <Nereid> :t \a f -> maybe (return Nothing) (liftM Just . f) a
21:58:59 <lambdabot> Monad m => Maybe a -> (a -> m a1) -> m (Maybe a1)
21:59:38 <basdirks> CodeDmitry: both http://learnyouahaskell.com/chapters and http://book.realworldhaskell.org/read/ are pretty good
21:59:39 <NemesisD> Nereid: hmm i thought there was a more succint way to do it
21:59:50 <Nereid> maybe it's not what you want.
22:00:02 <basdirks> and if you have questions about the material you can always ask here
22:00:15 <CodeDmitry> Ill look into it... but i learn better from more assertive claims answered with yes/no , with exceptions
22:00:22 <Nereid> :t Data.Foldable.forM_
22:00:23 <lambdabot> (Monad m, Foldable t) => t a -> (a -> m b) -> m ()
22:00:30 <Nereid> :t Data.Foldable.forM
22:00:32 <lambdabot>     Not in scope: `Data.Foldable.forM'
22:00:32 <lambdabot>     Perhaps you meant one of these:
22:00:32 <lambdabot>       `Data.Foldable.forM_' (imported from Data.Foldable),
22:00:33 <basdirks> CodeDmitry, you probably want both ways
22:00:35 <Nereid> er..
22:00:38 <CodeDmitry> I am
22:00:41 <Nereid> :t Data.Traversable.forM
22:00:42 <lambdabot> (Monad m, Traversable t) => t a -> (a -> m b) -> m (t b)
22:00:49 <SamanthaD> CodeDmitry: I'm afraid Haskell has a lot of new concepts that can't just be given to you in yes/no answers...
22:00:50 <Nereid> yeah.
22:00:52 <Nereid> that's the one.
22:00:56 <Nereid> where t = Maybe
22:00:59 <slack1256> CodeDmitry: well as a teacher, I can tell you only *really* learn by getting your hands dirty
22:01:02 <CodeDmitry> But reading books without knowing the obviousis hard
22:01:04 <Nereid> NemesisD: ^
22:01:14 <basdirks> CodeDmitry: they show you the right questions
22:01:16 <CodeDmitry> Haskell books assert a lot
22:01:19 <basdirks> which we can yes/no to
22:01:45 <basdirks> CodeDmitry: just ask what you don't know =]
22:01:56 <NemesisD> Nereid: weeeird. my brain has a hard time grokking how one "traverses" these datatypes
22:02:04 <CodeDmitry> I am, and you guys are very helpful
22:02:07 <CodeDmitry> :-)
22:02:11 <basdirks> cool
22:02:25 <Nereid> :t traverse
22:02:27 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:03:00 <SamanthaD> CodeDmitry: I want to caution you against what you seem to be doing though... I get the feeling based on the questions you're asking that you're trying to figure out how to translate the way you program now into a new syntax.
22:03:02 <croikle> Data.Traversable.sequence works too, it looks like
22:03:03 <CodeDmitry> I fear recursions due to some error with infinite in it
22:03:03 <Nereid> NemesisD: traverse k x will take all the things in x, run the action k on each of them, and collect the results.
22:03:17 <Nereid> mapM = traverse
22:03:28 <SamanthaD> CodeDmitry: The problem is... Haskell isn't a new syntax. It's a new methodology. You need to re-think the way you structure the program.
22:03:35 <NemesisD> Nereid: the word traverse hints at a collection of things, which is weird since its a Maybe, not a collection
22:03:47 <Nereid> a Maybe is a collection that may contain 0 or 1 things.
22:03:52 <yitz> CodeDmitry: we have come to fear loops due to some errors with state in it
22:03:55 <NemesisD> heh fair enough
22:04:19 <slack1256> CodeDmitry: don't worry, usually we don't do recursion when we can use combinators
22:04:24 <slack1256> although both are pretty easy
22:04:28 <Nereid> so if it's Nothing, then nothing will happen. if it's a Just, then it'll run the action on that one thing.
22:04:44 <Nereid> and put the result back in the Just.
22:05:00 <CodeDmitry> It is, however i am not trying to translate, just polling for ideas on how a normal person would do it
22:05:03 <SamanthaD> yitz: Not to mention that loops are an inheritly imperative concept!
22:05:28 <Nisstyre> slack1256: did you get my last message?
22:05:32 <Nisstyre> my connection is being flaky
22:05:36 <shachaf> inheritance is inheritly inherative.
22:05:40 <CodeDmitry> Im learning haskell for the paradigm, there  is no best pure paradigm
22:05:53 <slack1256> Nisstyre: sorry no. could you repeat. (also my connection is not that good)
22:06:00 <Nisstyre> <Nisstyre> slack1256: Rust is alpha quality atm
22:06:02 <Nisstyre> <Nisstyre> don't expect it to work perfectly
22:06:03 <CodeDmitry> But a lot of concepts are pretty useful
22:06:13 <SamanthaD> CodeDmitry: I would beg to differ but I'm also a lambda zelot ;)
22:06:27 <slack1256> Nisstyre: if it wasn't alpha I wouldn't be so excited!
22:06:31 <CodeDmitry> That, and haskell expresses math pretty well comparedto other languages
22:06:54 <SamanthaD> CodeDmitry: have you read the Structure and Implementation of Computer Programs?
22:06:58 <Nisstyre> CodeDmitry: insofar as math = abstract algebra
22:07:17 * slack1256 cries because his math hasn't had numbers in years
22:07:20 <Nisstyre> which, well, it's a massive amount of math :P
22:07:25 <yitz> SamanthaD: well, not completely. sometimes it is natural to express an algorithm as a series of steps. but imperative programming confuses that with direct commands to a machine.
22:07:28 <CodeDmitry> Is it a book?
22:07:42 <Nereid> it is a book.
22:07:45 <SamanthaD> CodeDmitry: it is, but you can find it on the internet.
22:07:48 <Nisstyre> SICP is a textbook that was used for a number of years at MIT (and is still used at other schools I think)
22:07:55 <Nereid> @where sicp
22:07:55 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
22:07:58 <Nereid> first one.
22:08:25 <CodeDmitry> I took data structures course in my university
22:08:42 <SamanthaD> yitz: it's more declarative to say x is a recursion of x than "loop it" is what I'm saying.
22:08:43 <CodeDmitry> I had so much trouble implementing a trie in c
22:08:45 <slack1256> also there is videos of sicp on openCourseWare at MIT
22:08:54 <yitz> SamanthaD: you can compare it to recipes for cooking. often they are expressed as steps. but a more sophisticated cook will just use that to understand the recipe at a higher level, and then not necessary follow the steps exactly.
22:09:00 <Nisstyre> you can hear the awesome intro tune if you watch the lectures too
22:09:19 <SamanthaD> CodeDmitry: Anyway... SICP is a great stepping stone to functional programming I find. As is Scheme (the language SICP uses).
22:09:32 <CodeDmitry> Generic steps are fine
22:09:39 <SamanthaD> CodeDmitry: Besides... SICP is very valuable to read no matter what.
22:09:50 <Nisstyre> http://youtu.be/ymRyefYC05k?list=FLcBI0SEgnOBJYWN24P3oPbA
22:10:04 <CodeDmitry> Not all series of instructions follow on 1 way to solve a problem
22:10:25 <yitz> SamanthaD: and that's pretty much what the compiler does when you express an algorithm monadically.
22:10:47 <SamanthaD> yitz: I see what you mean. You're saying the experienced cook is doing something like implementing transients (from Clojure). I kinda wish Haskell had a syntax for blocks of imperative code that are, as a whole, referentially transparent.
22:11:00 <AfC> edwardk: watched the video of your talk about Lenses today. Really informative!
22:11:07 <shachaf> SamanthaD: "declarative" is a vague word. Something is "declarative" when it's close to what you want to say, maybe.
22:11:18 <SamanthaD> yitz: point taken... as they say, syntactic sugar rots your teeth ;)
22:11:18 <shachaf> If what you want to say is a loop, then a loop is declarative.
22:11:22 <yitz> SamanthaD: we use monads for that. not familiar with clojure transients, so i don't know how that compares.
22:11:39 <CodeDmitry> What is sugar...
22:11:42 <slack1256> SamanthaD: but it taste soooo good.
22:11:47 <Nisstyre> also Haskell isn't really declaritive because it also includes interrogative statements
22:11:49 <Nisstyre> /pedantry
22:12:18 <CodeDmitry> Define sugar
22:12:26 <edwardk> AfC: =)
22:12:55 <Nisstyre> you kinda need both "this is" and "what is this?" to do programming
22:13:11 <SamanthaD> yitz: transients are like closures only that you're guarateeing that the closure is referentially transparent when it's called. I think it's a neat language feature.
22:13:32 <yitz> Nisstyre: i haven't figured out yet what you are referring to. could you pls explain?
22:13:40 <CodeDmitry> What is sugar
22:13:53 <Nisstyre> yitz: declaritive and imperative, you know what those mean right?
22:14:00 <SamanthaD> Nisstyre: Technically no language is truly declarative because a purely declarative programming language isn't very useful...
22:14:03 <yitz> SamanthaD: well every haskell function is like that.
22:14:10 <Nisstyre> SamanthaD: exactly, it's a bit of a misnomer
22:14:17 <CodeDmitry> Isnt xml declarative?
22:14:24 <Nisstyre> CodeDmitry: it's not a programming language
22:14:26 <yitz> Nisstyre: yeah. i didn't get the interrogative part
22:14:27 <SamanthaD> CodeDmitry: Sugar is just a awy of saying "more than one way of doing the same thing syntactically"
22:14:35 <Nisstyre> yitz: it means asking questions
22:14:57 <CodeDmitry> Tmtowtdi in perl?
22:15:05 <Nisstyre> okay, I'm done philosophizing about programming
22:15:10 <CodeDmitry> Or something like that
22:15:29 <CodeDmitry> I only program to feed my philosophical urges
22:15:29 <yitz> Nisstyre: ok let me try again. what do you mean by saying that haskell "also includes interrogative statements"</interrogative>
22:15:34 <SamanthaD> Nisstyre: Now now! I'm pretty sure what we call a "markup language" is more or less what a math geek would call a purely declarative language!
22:15:58 <Nisstyre> SamanthaD: well it's definitely a language that is declaritive
22:16:08 <CodeDmitry> Does that mean im right_
22:16:10 <CodeDmitry> .
22:16:16 <CodeDmitry> ?
22:16:25 <CodeDmitry> Im never right :-)
22:16:34 <SamanthaD> Nisstyre: After all... about the only thing a purely declarative program can do is interpret itself and that's pretty much what, say, an HTML document does!
22:16:43 <Nisstyre> yep
22:16:55 <SamanthaD> CodeDmitry: Yes, XML is declarative.
22:17:12 <CodeDmitry> Well doesnt all code get interpreted at some point?
22:17:15 <Nisstyre> S-Expressions would also fall under the purely declaritive category if I'm not mistaken
22:17:35 <CodeDmitry> Until then its pretty much declarative
22:18:02 <Nisstyre> CodeDmitry: well yeah, it's decided what each thing is by the parser
22:18:04 <SamanthaD> Nisstyre: how do you figure? I always figured s-expressions were just a very convenient way of imprementing circular reflexion.
22:18:43 <SamanthaD> CodeDmitry: but a declarative programming language cheats just enough to make it useful ;)
22:18:43 <CodeDmitry> I mean even machine code is interpreted by the machine
22:18:47 <Nisstyre> SamanthaD: Well I don't know if I have the same definition of S-Expressions, but I just mean sexprs as you would use them to represent data
22:19:00 <Nisstyre> like sxml
22:19:09 <SamanthaD> CodeDmitry: Oh... yeah... but it's being interpreted by something else (aka, the processor) and not by itself, which is what I meant.
22:19:26 <CodeDmitry> Still xml is pretty odd, you need very high level of maturity to understand a use for it
22:19:33 <jdavis> I want to make a fairly simple web application. I don't want much in the way of a framework; I don't need session handling or form generation or templates or anything like that. What's the difference between snap, yesod, and warp? Is warp a part of yesod?
22:19:45 <SamanthaD> Nisstyre: OH! I was thinking Lisp!
22:19:55 <Nisstyre> SamanthaD: I don't mean all of lisp really
22:20:01 <slack1256> jdavis: sure you don't want a static site generator?
22:20:13 <CodeDmitry> Why do haskell coders refer to lisp so often
22:20:32 <yitz> jdavis: no warp is only written by the same author as yesod, but they are two separate things
22:20:33 <jdavis> Yes, I am just trying to write something to turn PG functions into a web service.
22:20:38 <Nisstyre> CodeDmitry: because many of us learned lisp before Haskell?
22:20:39 <SamanthaD> CodeDmitry: Because Lisp is freaking AWESOME, that's why ;)
22:20:47 <yitz> jdavis: warp is a web server. like a simplified nginix
22:20:52 <Nisstyre> actually, specifically Scheme is what I know
22:20:56 <Nisstyre> I don't have much use for CL
22:20:58 <slack1256> jdavis: http://softwaresimply.blogspot.com/2012/04/hopefully-fair-and-useful-comparison-of.html
22:21:03 <Nereid> I never learned a lisp.
22:21:20 <SamanthaD> Nereid: BLASPHIEMER!
22:21:26 <slack1256> in apple the say "there is an app for that" in haskell "there is a blogpost for that"
22:21:27 <Nisstyre> unhygienic macros make me feel dirty
22:21:35 <slack1256> I also don't know lisp
22:21:52 <slack1256> but I am a full blown pagan so it doesn't matter
22:22:09 <CodeDmitry> I know defun is a keyword, does that qualify as knowing lisp?
22:22:15 <yitz> jdavis: if you just need a static web site, hakyll is really good
22:22:23 <jdavis> Basically, all I want to do is connect to postgres, look at the catalogs and turn each function into a web service of some kind, served by a simple webserver. Does warp sound like a good fit? It looks simple and reliable and fast.
22:22:29 <croikle> jdavis: if you want small, you can use wai directly, or scotty sounds pretty simple
22:22:36 <jdavis> yitz: well, I need to connect to PG, so static won't work.
22:22:38 <croikle> warp is just the webserver part
22:22:51 <slack1256> jdavis: what is a PG?
22:22:54 <Nisstyre> slack1256: you can do things like this: (define-syntax-rule (let ((a exp)) body) ((lambda (a) body) exp))
22:23:03 <jdavis> slack1256: sorry, PostgreSQL
22:23:06 <SamanthaD> I, for one, would consider Scheme to be my one and true love if it wasn't for the fact that I'm scared to leave my beautiful Hindley-Milner type system O.O
22:23:10 <Nisstyre> (not tested, may be syntax errors in that)
22:23:25 <slack1256> jdavis: oh i thought Paul Graham lol
22:23:27 <Nisstyre> SamanthaD: Typed Racket?
22:23:41 <yitz> jdavis: hmm well unless you want to hack directly in a low-level pg lib, you probably do want a framework then
22:23:51 <slack1256> Nisstyre: what does that buy me?
22:23:52 <CodeDmitry> I made a promise to my imaginary girlfriend not to touch lambdas, they are evil
22:23:55 <SamanthaD> Nisstyre: My understanding is that typed racket isn't really all that statically typed...
22:23:58 <Nisstyre> slack1256: let
22:24:08 <Nisstyre> SamanthaD: oh, well I've never used it myself
22:24:08 <slack1256> Nisstyre: oh boy
22:24:19 <Nisstyre> slack1256: a primitive form of let though
22:24:32 <SamanthaD> Nisstyre: The problem with Lisp and static typing is that you can't have static typing when the damn program is writing its own executable code during runtime.
22:24:32 <jdavis> yitz: I'm fine with the low-level binding. I have already worked with it a little bit. I don't want an ORM or anything resembling one. I just want to call functions and process the results.
22:24:40 <Nisstyre> but you can do stuff like (let ((a 12)) (* a a)) with it
22:24:52 <CodeDmitry> Niss, incomprehensible
22:24:55 <Nisstyre> SamanthaD: true enough
22:25:01 <SamanthaD> Nisstyre: So... the one feature that makes Lisp really special is fundamentally incompatible with a static typing.
22:25:16 <Nisstyre> CodeDmitry: equivalent to "let a = 12 in a * a"
22:25:25 <AfC> jdavis: just use Snap. Easy to use, no fuss.
22:25:39 <slack1256> SamanthaD: but i thought that at least SBCL used internally type inference.
22:25:40 <jdavis> AfC: Oh, OK.
22:25:56 <CodeDmitry> I try my best to keep my programs away from self obfuscation
22:26:02 <jdavis> AfC: Thanks.
22:26:05 <CodeDmitry> It has been hard but i manage
22:26:13 <Nisstyre> CodeDmitry: I admit that it is difficult to read lisp at first, but it gets easier
22:26:35 <Nisstyre> especially if you use Racket, because it lets you use [ ] and { } instead of ( )
22:26:53 <Nisstyre> then you can do (let ([a 12]) (* a a)) instead
22:26:55 <SamanthaD> slack1256: I'm not sure... I know Common Lisp and Scheme are strongly typed in that if they hit a type conflict they'll cause a runtime exception... and they might have very limited abilities to do type checking at compile time but...
22:27:00 <yitz> jdavis: yesod has persistent. hapstack has acid-state. snap has a database interface too, not sure that it has name though.
22:27:05 <yitz> *happstack
22:27:32 <jdavis> OK.
22:27:33 <slack1256> yitz: remember that component are pretty much interchangeable on the 3
22:27:37 <AfC> jdavis: you can use snap-core and snap-server directly if you don't need anything higher level. Snaplets are a powerful abstraction, but if you're just doing some simple HTTP handling then you can work directly in the Snap monad and be done with it.
22:27:41 <yitz> slack1256: yep
22:27:44 <SamanthaD> slack1256: I don't think you could have a weakly typed Lisp. If you did, circular reflection would let you make such a huge mess so quickly it would be unbelievable >.<
22:27:49 <Nisstyre> Scheme is definitely strongly typed, but it will try to run a procedure with whatever you give it
22:28:04 <CodeDmitry> Mess is fun, proven by c
22:28:22 <Nisstyre> Racket does a bit better with contracts, but they're still runtime
22:28:34 <yitz> jdavis: snap is fine. yesod is also extremely easy to get started in. it also has a lot of great on-line documentation plus an oreilley "animal" book.
22:28:58 <jdavis> AfC: That sounds like all I need. Route /funcname?arg1=10&arg2=foo to some code that calls the postgres function "foo(10, 'foo')"
22:29:00 <Nisstyre> yitz: how up to date is the OReilly book?
22:29:01 <yitz> jdavis: and happstack is also fine btw.
22:29:02 <slack1256> yitz: which animal? a pig? </runs>
22:29:09 <CodeDmitry> I still believe haskell is perls evil brother
22:29:11 <yitz> @slap slack1256
22:29:11 * lambdabot orders her trained monkeys to punch slack1256
22:29:20 <SamanthaD> Nisstyre: I always write Haskell style contracts in my Scheme code anyway.
22:29:30 <slack1256> sorry sorry, it was too at hand.
22:30:09 <yitz> Nisstyre: came out quite recently actually. definitely usable with current stable yesod versions.
22:30:14 <SamanthaD> CodeDmitry: Haskell is more like an extremely nerdy cultist obsessed with purity.
22:30:28 <jdavis> yitz: thank you.
22:30:43 <CodeDmitry> Arent mathematicians geeks, not nerds?
22:30:57 <Nisstyre> CodeDmitry: other way around
22:31:09 <reltuk> oh, i needed reifiedlens
22:31:15 <slack1256> it's all the same thing geek nerds, nobody cares
22:31:28 <Nisstyre> also some mathematicians really were cultists >.>
22:31:30 <CodeDmitry> I guess that makes me a geek >.>
22:31:45 <CodeDmitry> All mathematicians are cultists
22:31:50 <CodeDmitry> Its a fact
22:31:51 <SamanthaD> slack1256: Yes... and "hacker" is just a knighted nerd!
22:31:55 <Nisstyre> then what was Pythagoras?
22:32:03 <Nisstyre> an ub3r-cultist?
22:32:08 <CodeDmitry> Pythagoras was a logician
22:32:14 <CodeDmitry> Wasnt he?
22:32:16 <slack1256> well only the people who call themselves care about nerd and geek and stuff
22:32:21 <Nisstyre> more like a natural philosopher imo
22:32:48 <Nisstyre> aka physicist
22:33:12 <CodeDmitry> Math is really painful if taught by cultists
22:33:21 <CodeDmitry> Philosophers make better teachers
22:33:46 <SamanthaD> CodeDmitry: I dunno... philosophers really know how to bloviate...
22:33:59 <CodeDmitry> Bloviate?
22:34:09 <SamanthaD> CodeDmitry: babble
22:34:21 <CodeDmitry> Ah
22:34:34 <Nisstyre> except for a select few, who started out as mathematicians :P
22:35:01 <CodeDmitry> There are many mathematicians without any critical thinking skills
22:35:12 <SamanthaD> Nisstyre: Yes, but they're a special breed ;)
22:35:12 <Nisstyre> CodeDmitry: that is true
22:35:31 <Nisstyre> SamanthaD: you have to be to smoke a pipe every day and live to be 97 (Russell)
22:35:58 <SamanthaD> Nisstyre: My trachea is a catalytic converter!
22:38:12 <CodeDmitry> Haskell seems to be more of a challenge than a language though
22:38:25 <Nereid> haskell is a real language.
22:38:28 <CodeDmitry> To think differently
22:38:31 <Nereid> surprising isn't it!
22:38:39 <CodeDmitry> It really is
22:38:51 <Nisstyre> CodeDmitry: premised on the fact that you learned a pl previously
22:38:52 <SamanthaD> CodeDmitry: Haskell is definitely a useful language... it just takes a lot of practice to make the pradigm shift.
22:39:01 <CodeDmitry> Pl?
22:39:04 <Nisstyre> programming language
22:39:37 <CodeDmitry> I believe newcomers will also have issues
22:39:47 <mauke> [citation needed]
22:39:50 <slack1256> but I've seen haskell teached to people with no computer background and they catch pretty quickly
22:39:51 <SamanthaD> CodeDmitry: For example, Haskell has huge potential when your program absolutely positively must do what you intend it to do.
22:39:54 <CodeDmitry>  Its natural to think of a computer as a state machine
22:39:56 <Nisstyre> CodeDmitry: I know of professors who teach Haskell to undergrads with little or no PL experience and it goes over fine generally
22:40:01 <mauke> CodeDmitry: hahahaha
22:40:08 <CodeDmitry> And recursions are far more confusing than loops
22:40:24 <mauke> CodeDmitry: my hair is a bird. your opinion is invalid.
22:40:27 <slack1256> CodeDmitry: [citation needed]
22:40:47 <CodeDmitry> Professors will find haskell an ideal tool for their purposes.
22:40:47 <Nisstyre> CodeDmitry: first define "natural" operationally
22:41:19 <slack1256> CodeDmitry: natural only applies to domains, for other expectation whta is natural there doesn't have to be here
22:41:34 <Nisstyre> what is natural is subjective in casual speech
22:41:38 <SamanthaD> CodeDmitry: I come to Haskell as someone who needs to write scientific programs. I like the fact that I can write proofs about my programs and PROVE that they're doing what I say they are.
22:41:38 <SamanthaD> CodeDmitry: or if I can't absolutely prove it I can get very close.
22:42:05 <slack1256> SamanthaD: what is your major?
22:42:14 <CodeDmitry> Computer science
22:42:19 <shachaf> @quote kmc unless
22:42:19 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
22:42:22 <CodeDmitry> University of ryerson
22:42:32 <Nisstyre> CodeDmitry: you live in Toronto?
22:42:40 <CodeDmitry> Vaughan
22:42:51 <CodeDmitry> 2 hours to get there
22:43:03 <Nisstyre> I see
22:43:05 <CodeDmitry> Worst case
22:43:12 <Nisstyre> I know someone who lives in Toronto and goes to McMaster
22:43:37 <SamanthaD> slack1256: strangely, psychology...
22:43:37 <SamanthaD> slack1256: but you can model people, too ;)
22:43:44 <CodeDmitry> I like ryerson, if i had to choose between it and anthing else, id choose ryerson
22:43:45 <Nisstyre> I can't imagine the busing it must take every other dayt
22:43:47 <Nisstyre> *day
22:44:10 <slack1256> SamanthaD: that's cool!, also you can automate a lot of statistics with programming
22:44:14 <Nisstyre> SamanthaD: I'm majoring in linguistics
22:44:45 * Nisstyre has a psychology lecture in 6 hours though
22:44:59 <Nisstyre> f-ing 8:30 lectures :(
22:45:05 <slack1256> Nisstyre: why are you awake then?
22:45:12 <Nisstyre> slack1256: insomnia I guess
22:45:31 <Nisstyre> could also be because I got up at noon since I had no reason to get up otherwise
22:45:36 <SamanthaD> slack1256: Yes, you can automate a lot of statistics. Though... we already have a very good stats suite so...
22:45:46 <slack1256> go to sleep man, you won't understand anything otherwise
22:45:47 <CodeDmitry> Claim: the amount of haskell that makes sense is directly proportional to how much math terminology you can comprehend
22:46:04 <Nisstyre> slack1256: okay okay, I'll go to sleep soon :P
22:46:16 <Nisstyre> it's on psychoanalysis though (personality course)
22:46:23 <CodeDmitry> And yes, i got no idea what directly proportional means
22:46:25 <Nisstyre> not going to understand it regardless heh
22:46:32 <Nisstyre> CodeDmitry: multiplication
22:46:33 <slack1256> CodeDmitry: wrong, foundation of mathematics (metamathematics / lambda calculus) is very different from math
22:46:34 <SamanthaD> I actually just got out of my undergrad. I want to study biopsychology. What I really want to use Haskell for is modeling learning on a cellular level.
22:47:01 <ed__> how much more powerful is haskell than java?
22:47:08 <CodeDmitry> It isnt
22:47:08 <slack1256> SamanthaD: have you joined the biohaskell list?
22:47:16 <slack1256> ed__: 3.14
22:47:24 <SamanthaD> CodeDmitry: From my experience with the language that's not true...
22:47:38 <Nisstyre> SamanthaD: I'm hoping to eventually do a Masters in computational linguistics, hopefully using Haskell for that
22:47:38 <SamanthaD> CodeDmitry: Directly proportional means that one property is a function of another.
22:47:44 <CodeDmitry> Java library is the largest standard library in any programming language
22:48:03 <SamanthaD> slack1256: I had no idea there was such a thing!
22:48:14 <SamanthaD> ed__: You're kidding, right? It's night and day!
22:48:24 <Nisstyre> is there a ling-haskell mailing list?
22:48:33 <slack1256> slack1256: seems very active
22:48:37 <CodeDmitry> Good luck making portable guis in haskell
22:48:48 <CodeDmitry> Let alone even installing one library
22:49:06 <CodeDmitry> The cabal errors are incomprehensile
22:49:08 <ed__> what about for web dev?
22:49:12 <SamanthaD> CodeDmitry: Sure... but it's also full of bugs. Not to mention that the JVM is full of bugs... the language is poorly designed and obtuse... it's based on what I would say is a poor implementation of an obsolete paradigm...
22:49:12 <slack1256> CodeDmitry: if you use GLUT you are fine, also wxhaskell is portable
22:49:28 <slack1256> ed__: haskell has 3 good frameworks with excellent performance for webdev
22:49:42 <CodeDmitry> I tried setting up wxhaskell, it failed
22:49:52 * shachaf doesn't think saying bad things about Java is a good use of this channel.
22:49:52 <slack1256> ed__: seriously jump in. the worst thing that could happen is that you learn something :-)
22:50:01 <SamanthaD> CodeDmitry: Excuse me! There's plenty of portable gui support in Haskell!
22:50:20 <slack1256> shachaf: sorry.
22:50:31 <basdirks> CodeDmitry: at this point you're just trolling
22:50:33 <CodeDmitry> Setting up the libraries is hell, and you have to do it on each targe platform
22:50:51 <CodeDmitry> Its only a little easier than c++ to port
22:50:56 <CodeDmitry> Which is total hell
22:50:59 <SamanthaD> CodeDmitry: Yeah, wxhaskell is about as close to portable as you can get!
22:51:10 <slack1256> CodeDmitry: you can use static linking and then you are pretty much set
22:51:30 <CodeDmitry> I cant set up wx in cabal, it fails
22:51:49 <SamanthaD> ed__: Well... there's Yesod for server side web apps!
22:51:51 <CodeDmitry> I cant make a user run cabal, and i cant precompile it on each platform
22:52:09 <CodeDmitry> I cant promise no further issues neither
22:52:13 <CodeDmitry> It is an issue
22:52:49 <CodeDmitry> And i pray it statically links, i dont want dll hell
22:52:58 <SamanthaD> ed__: However, I would suggest learning Haskell just becaues it'll teach you concepts and disciplines that are actually applicable in other languages (and will improve the quality of your code). Just don't try to implement tail-call recursion in Java unless you like blowing your stack.
22:53:27 <CodeDmitry> Yeah thats my main reason for learning it
22:53:40 <CodeDmitry> I never backed up from a new way of thinking
22:53:45 <Nereid> you start that way, but then you end up wanting to write everything in haskell.
22:53:50 <ed__> @SamanthaD thanks
22:53:50 <lambdabot> Unknown command, try @list
22:54:09 <Fuuzetsu> Is there a better way to obtaining dependencies to your project to put in .cabal file than sticking some in, seeing if it builds and adding some when it complains?
22:55:01 <SamanthaD> CodeDmitry: Sure... but don't pretend that Java isn't problematic either when it comes to portability.
22:55:01 <SamanthaD> ed__: Yeah... I've never used Yesod though, but I heard it's in a stable release now? I dunno, not really my field.
22:55:02 <SamanthaD> ed__: I know it's BLAZINGLY fast. I'd say the biggest problem with writting a server-side Haskell ap would maybe having trouble finding a server that you can run it on.
22:55:27 <CodeDmitry> Java is problem free in portability...
22:55:52 <sw2wolf> Is prolog FP langauge ? It seems there is no lambda in Prolog ?
22:56:01 <Nereid> no, it's not.
22:56:08 <CodeDmitry> Eh?
22:56:13 <slack1256> Fuuzetsu: how is that? you imported the modules but don't know to to which package belongs?
22:56:14 <Nereid> to sw2wolf
22:56:27 <slack1256> sw2wolf: but it's declarative although not functional
22:56:41 <slack1256> mercury has a interesting approach on joining logic and functional
22:56:42 <sw2wolf> Prolog seems a interesting langauge
22:57:05 <CodeDmitry> I gave up on hating paradigms a long time ago
22:57:20 <sw2wolf> slack1256: thx
22:57:44 <SamanthaD> CodeDmitry: In an idea world the JVM would ensure perfect portability. We don't live in a perfect world.
22:58:11 <CodeDmitry> Jvm insures perfect portability, we live in a perfect world
22:58:38 <mauke> CodeDmitry: are you fucking kidding me
22:58:39 * slack1256 thinks there is always #java for that
22:59:06 <sw2wolf> JVM makes us lose thinking :P
22:59:27 <CodeDmitry> Its much more interesting to hear the reasons for such javaphobia
22:59:40 <mauke> CodeDmitry: no, it's not
22:59:43 <slack1256> CodeDmitry: everything has it's place and time
22:59:46 <SamanthaD> CodeDmitry: Consider that there's at least three major JVM implementations and each of those implementanions have different versions. Now, each of those JVMs (and their different versions) will compile your bytecode slightly differently... Yeah, explain to me how that isn't a recipe for poor cross-platform compatibility.
22:59:58 <basdirks> Like I said; he's now trolling
23:00:23 <CodeDmitry> 3 different implementors? Doesnt oracle have a monopoly?
23:00:31 <slack1256> OK GUYS I WILL GIVE YOU ONCE PIECE OF CANDY EACH OF YOU IF YOU STOP SPEAKING OF JAVA
23:00:32 <Nereid> "no"
23:00:37 <elliott> is an argument actually going on with someone who said "Jvm insures perfect portability, we live in a perfect world"
23:00:37 <lambdabot> elliott: You have 5 new messages. '/msg lambdabot @messages' to read them.
23:00:49 <elliott> and can it stop
23:00:50 <SamanthaD> CodeDmitry: What I said is a verifiable fact!
23:01:02 <mauke> CodeDmitry, SamanthaD: stop.
23:01:32 <basdirks> elliott: he seemed semi-sincere a while earlier
23:01:49 <elliott> well, still doesn't look to be haskell-related to me :p
23:01:50 <SamanthaD> sorry, I'll stop
23:02:07 <CodeDmitry> That is interesting because all code i built on windows ran on mac and ubuntu without any noticible issues
23:02:15 <basdirks> it was about Haskell until he put on troll-mode
23:03:01 <slack1256> remember this is our bible http://www.haskell.org/haskellwiki/IRC_channel#Principles
23:03:09 <CodeDmitry> Alright you do have a point, this is like pouring gas on a fire.
23:03:25 <CodeDmitry> Ill avoid bringing it up n this channel
23:03:57 <Fuuzetsu> slack1256: I do know where they belong; it's just tedious going over every single pretty name (such as Network.URI) and finding the exact package name that it belongs to (network-version) for every single import
23:04:37 <Nereid> doesn't cabal init do that for you?
23:04:54 <Nereid> if you do it in a directory with existing code
23:05:04 <slack1256> that what I thought
23:05:13 <CodeDmitry> I tried setting up wx and gtk with cabal both failed
23:05:24 <slack1256> CodeDmitry: paste the error on hpaste
23:05:25 <CodeDmitry> Its very painful
23:07:09 <SamanthaD> ed__: Did you get your question answered, by the way?
23:07:24 <CodeDmitry> I dont understand why haskell has no simple gui support, not even Tk
23:07:40 <CodeDmitry> Not without cabal
23:07:48 <slack1256> CodeDmitry: well first is a thing of different paradigms
23:08:09 <Fuuzetsu> Nereid: Ah yes, it's done it! I couldn't remember what the command was, thanks!
23:08:11 <slack1256> Guis fits pretty well the OO model (as shown by smalltalk)
23:08:31 <CodeDmitry> Gtk handles guis very well
23:08:40 <CodeDmitry> It is oo c though
23:08:52 <SamanthaD> CodeDmitry: C is not obeject oriented, no...
23:08:56 <slack1256> but on haskell you can't do imperative without the IO monad. as a result too much code on the IO monad
23:09:04 <CodeDmitry> C is capable of oo
23:09:06 <Nereid> you can pretend C is object oriented.
23:09:08 <CodeDmitry> Ao is assembly
23:09:14 <CodeDmitry> So*
23:09:21 <slack1256> CodeDmitry: Glib is a OO abstraction layer on top of C, they use it to make GTK work
23:09:22 <Nereid> but let's not go off topic again.
23:09:32 <SamanthaD> CodeDmitry: Also, Haksell can call foreign code and foreign code can generally call Haskell. If you really want to build your GUI in an object oriented way I might suggest you hybridize your languages?
23:09:37 <CodeDmitry> Oo is essentially structuring sets into trees
23:10:45 <CodeDmitry> In any case, i dont care about oo atm
23:10:57 <CodeDmitry> I care about writing guis in haskell
23:11:24 <slack1256> the tutorial on WXhaskell are pretty straightforward
23:11:37 <SamanthaD> CodeDmitry: Perhaps you should look into the chapter in Real World Haskell on that subject?
23:11:54 <CodeDmitry> Perhaps i should
23:13:11 <CodeDmitry> K got it, 712 ish pages right?
23:13:26 <Nereid> read it online.
23:13:29 <Nereid> @where rwh
23:13:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:13:33 <CodeDmitry> I got the pdf
23:13:42 <Nereid> which is less up to date
23:13:49 <Nereid> I think?
23:14:02 <slack1256> also the comment on the paragraphs are cool
23:14:25 <SamanthaD> Nereid: I don't think so... but I find the HTML version much, much more legible.
23:14:35 <Nereid> perhaps.
23:14:41 <Nereid> easier to copy and paste code too if you're into that
23:14:53 <CodeDmitry> Looks like a pretty good book
23:15:03 <CodeDmitry> :-)
23:15:17 <SamanthaD> CodeDmitry: Indeed! It's the best reference book for Haskell that I know of!
23:16:23 <CodeDmitry> Heh thanks for the advice, ill try to make sense of it
23:17:46 <SamanthaD> CodeDmitry: The way I like to use RWH while learning is to keep it as a reference for when I want to get more details about a particular topic. I tried using it as a primary tutorial but... I dunno, it wasn't my cup of tea.
23:18:18 <SamanthaD> CodeDmitry: A lot of people like Learn You a Haskell as a crash course.
23:18:52 <SamanthaD> CodeDmitry: But... there is no substitute for Real World Haskell.
23:19:04 <Nereid> I don't remember how I learned haskell.
23:19:45 <SamanthaD> Nereid: I'm doing it by reading about five books at once ;)
23:20:19 <slack1256> Nereid: reading?
23:20:30 <Nereid> yes, I must have learned it by reading.
23:20:55 <Nereid> I remember looking at lyah and rwh but I don't think I ever finished going through them.
23:21:00 <slack1256> Nereid: "and suddenly everything was clear, my journey ended and i knew haskell... and he knew me" - Nereid 6 buddah of lambda
23:21:47 <SamanthaD> slack1256: Does that mean Nereid built an AI preprocessor for his code?! That would be pretty awesome!
23:22:49 <Nereid> there should be a haskell platform metapackage on hackage.
23:23:01 <Nereid> or something.
23:23:11 <SamanthaD> Nereid: There isn't?
23:23:18 <Nereid> not that I've seen.
23:25:07 <slack1256> Nereid: either way if you don't have the plataform you can't have cabal
23:25:10 <SamanthaD> Nereid: If you're on linux why don't you just install the haskell platform using your package manager?
23:25:18 <Nereid> because I don't want to.
23:25:28 <SamanthaD> fair enough
23:25:40 <Nereid> slack1256: not true.
23:27:47 <howdy69> hello?
23:27:52 <howdy69> anybody on?
23:27:58 <Nereid> nope
23:27:58 <simpson> howdy69: Sure!
23:28:12 <mauke> howdy69: welcome to the internet
23:28:16 <slack1256> hello howdy69
23:28:16 <SamanthaD> we're hiding
23:28:21 <c_wraith> Nereid: I'm not sure what good a metapackage would be. I mean, if it depends on all of the platform, I won't install it
23:28:21 <howdy69> Where are you from? This is a neat service
23:28:21 <SamanthaD> hi
23:28:36 <simpson> howdy69: Welcome to #haskell. We talk about Haskell here.
23:28:43 <shachaf> c_wraith never metapackage he didn't dislike.
23:28:45 <c_wraith> Nereid: and if a package depends on the metapackage, it's very likely to have extraneous dependencies in its .cabal file
23:28:49 <c_wraith> shachaf: true
23:28:55 <Nereid> you're not supposed to depend on a metapackage.
23:29:01 <c_wraith> people would
23:29:06 <c_wraith> You know it'd happen.
23:29:07 <shachaf> No, it wouldn't help.
23:29:08 <Nereid> true.
23:29:15 <Nereid> alright
23:29:22 <shachaf> Well, OK, maybe people would.
23:29:22 <Nereid> distribute a package that deliberately fails to compile
23:29:37 <Nereid> but installs all the platform packages first
23:29:46 <c_wraith> though if hackage actually distinguished between real packages and metapackages, it could reject uploads of things that depend on metapackages
23:29:46 <mauke> heh
23:30:01 <Nereid> do people depend on yesod-platform?
23:31:54 <mauke> ooh, new firefox
23:32:13 <c_wraith> new firefox supports retina MBP finally
23:33:08 <c_wraith> maybe it has some other features, but after like 4 months of having this computer, that's the one I notice
23:39:46 <SamanthaD> c_wraith: Haskellscript! No? Darn...
23:49:34 <Tordek> why
23:49:38 <Tordek> erp
23:50:36 <Tordek> why's everything about monads always about >>= if <=< makes for prettier (and, imho, clearer) composition?
23:51:07 <ivanm> Tordek: my guess is historical reasons
23:51:13 <ivanm> but I very rarely use >=>
23:51:58 <Tordek> how come?
23:52:14 <simpson> Tordek: do-notation is the reason IIUC.
23:53:38 <Tordek> I was writing a monad tutorial (not, like, to publish or anything, just because explaining something makes it clearer to me), and <=< made everything familiar to .
23:54:40 <ivanm> the very few times I do explicit monadic composition it typically uses >=
23:54:45 <shachaf> Composition of (a -> m b) functions isn't that common.
23:55:48 <elliott> > 1 >= 2  -- monadic composition
23:55:50 <lambdabot>   False
23:57:00 <hpaste> “Samantha Davis” pasted “Prime Generator” at http://hpaste.org/80523
23:57:12 <Tordek> I see. Thanks, guys :)
23:57:49 <shachaf> Tordek: Also: Try writing (>=>) using (>>=).
23:57:52 <shachaf> That's a nice definition.
23:57:58 <shachaf> Now write (>>=) using (>=>)
23:57:59 <SamanthaD> My program's pretty simple... but when I try to run it it seems to just suck up ungodly amounts of memory and generally be extremely slow
23:58:11 * SamanthaD points up at the hpaste
23:58:49 <Tordek> BTW, I wrote this in response to an article about "Nulls are bad; let's use Maybe!": http://www.reddit.com/r/programming/comments/15ymgp/why_weve_banned_null_in_our_codebase/c7su4t3 I wouldn't mind some feedback if someone cares to oppose any of my points?
23:59:48 <SamanthaD> By the way, my test condition was calling take 5 (primes) in GHCi
