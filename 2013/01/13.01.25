00:02:29 <edwardk> otters: 3.8.2 is now on hackage. i changed the API a little bit from what you pushed.
00:02:34 <edwardk> er what you saw
00:03:53 * hackagebot lens 3.8.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.2 (EdwardKmett)
00:04:30 <steve73> Is anyone here good at balancing parenthesis?
00:05:09 <shachaf> Maybe #lisp would know.
00:05:17 <shachaf> (This is a joke. Do not ask in #lisp.)
00:10:55 <steve73> The type signature for `' lacks an accompanying binding
00:11:12 <steve73> english translation?
00:13:54 <Ralith> it is saying that have declared a type for `' but have not declared a value
00:14:23 <Ralith> shachaf: you're such a softy
00:14:27 <steve73> but i have
00:14:36 <steve73> on the next line i gave it an equation
00:14:45 <shachaf> For `'?
00:14:47 <shachaf> What's `'?
00:15:01 <Ralith> clearly, the compiler disagrees
00:15:03 <steve73> Picture -> Picture -> Picture
00:15:08 <shachaf> What? That's not part of the error.
00:15:19 <steve73> thats the type isnt it
00:15:22 <shachaf> When you have a problem, you should say:
00:15:25 <steve73> the input and output
00:15:36 <shachaf> (a) What you did (b) What you expected (b) What happened
00:15:40 <steve73> ok
00:15:41 <shachaf> Preferably in full.
00:15:45 <shachaf> @paste might help. :-)
00:15:45 <lambdabot> Haskell pastebin: http://hpaste.org/
00:16:09 <tieTYT2> is haskell still pure even though there's monads?
00:16:26 <Ralith> is haskell still pure even though there's numbers?
00:16:28 <shachaf> Monads have nothing to do with purity or impurity.
00:16:43 <shachaf> Your question is unanswerable, though, because "pure" is a meaningless word.
00:17:15 <shachaf> My recommendation: Learn Haskell as it is. Don't worry about whether it's pure.
00:17:33 <tieTYT2> i will :)
00:17:34 <shachaf> (Monads are not what you think they are. But you should learn plenty of Haskell before worrying about monads.)
00:19:28 <ahokaomaeha> tieTYT2: heh, monads are for the most part just a library feature, except for the syntactic sugar support for it... and Haskell is the kind of language that is best learnt if you focus on the core language first and only then learn libraries
00:19:53 <shachaf> tieTYT2: Oh: The FAQ is a very good document.
00:19:55 <shachaf> @where faq
00:19:55 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:19:57 <shachaf> Read it.
00:20:01 <shachaf> For example read section 8.
00:22:00 <johnw> "Haskell programs are pure-functional programs which compute imperative programs."
00:22:03 <johnw> that's a great summation
00:23:53 * hackagebot Bookshelf 0.3.1 - A simple document organizer with some wiki functionality  http://hackage.haskell.org/package/Bookshelf-0.3.1 (EmilAxelsson)
00:26:00 <Hail_Spacecake> I'm trying to implement http://www.haskell.org/haskellwiki/Simple_Servers Basic Concurrent Server
00:26:05 <Hail_Spacecake> only as a single-threaded program
00:26:10 <Hail_Spacecake> for my own understanding of haskell
00:26:27 <Hail_Spacecake> and I realize I don't understand how you do that code as a single-threaded program
00:26:52 <Hail_Spacecake> namely, how can you accept multiple handles for multiple connections, and listen in a loop on all possible handles
00:27:10 <shachaf> You would use multiple threads for that.
00:27:21 <tdammers> not necessarily
00:27:37 <shachaf> That would be the simple way to do it.
00:27:43 <tdammers> but if you do it single-threaded, you can only accept a new request when you're done processing the previous one
00:28:02 <shachaf> 00:26 <Hail_Spacecake> namely, how can you accept multiple handles for multiple connections, and listen in a loop on all possible handles
00:28:08 <shachaf> Is what you would do with multiple threads.
00:28:52 <shachaf> Hail_Spacecake: You can also do what's described on that page.
00:28:56 <shachaf> But I don't recommend it.
00:29:02 <shachaf> It's going against the grain of the standard library.
00:29:30 <Hail_Spacecake> well that's what's reccommended on that page, right?
00:29:35 <Hail_Spacecake> forkIO spawns a new thread
00:29:49 <Hail_Spacecake> I mean, maybe there's no reason to not use multiple threads
00:29:51 <shachaf> I see several programs on that page.
00:29:57 <shachaf> Some of them don't fork new threads.
00:30:03 <shachaf> But why don't you want multiple threads?
00:30:10 <shachaf> The network API is designed to be used with threads.
00:30:11 <johnw> hmm.. GHC 6.4 had a section in its manual on "synchronous IO multiplexing"
00:30:16 <johnw> but I don't find it in the 7.x docs
00:30:25 <shachaf> 6.4 is ancient.
00:30:31 <shachaf> That's before GHC even had a threaded RTS.
00:30:49 <Hail_Spacecake> shachaf only because I don't know how you would even go about doing this as a single threaded program
00:30:50 <johnw> ah, so the support was just dropped?  I'm thinking of something like Unix's select function
00:30:53 <Hail_Spacecake> and that bothers me
00:31:05 <tdammers> johnw: that's what I was thinking of, too
00:31:30 <shachaf> Hail_Spacecake: Well, you would read the API documentation for the relevant API, and then use it according to that.
00:31:48 <shachaf> The relevant API is probably lower-level than the thing Network.Socket exposes, though.
00:31:57 <shachaf> So you would have to do a bit of work.
00:32:03 <johnw> ah, here we go: http://www.haskell.org/pipermail/beginners/2009-September/002221.html
00:33:23 <Hail_Spacecake> oh, so forkIO isn't actually a full OS thread?
00:33:30 <Hail_Spacecake> it's a haskell abstraction to that?
00:33:30 <johnw> forkOS is a full OS thread
00:34:21 <shachaf> forkOS is not what you think it is.
00:34:27 <frerich> Really? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:forkOS says "Using forkOS instead of forkIO makes no difference at all to the scheduling behaviour of the Haskell runtime system."
00:34:42 <shachaf> frerich: That's also not really accurate.
00:34:53 <shachaf> You shouldn't use forkOS unless you need to for FFI reasons.
00:35:05 <shachaf> Hail_Spacecake: forkIO is a lightweight Haskell thread.
00:35:07 <`nand`> TheRedMood: commutativity. x·y = y·x; so 5·4·3·2·1 = 5·4·3·1·2 = 5·4·1·3·2 = ... = 1·5·4·3·2 = ... = 1·2·3·4·5
00:35:09 <johnw> shachaf: confirms what you said: "if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using forkOS instead of forkIO"
00:35:26 <frerich> shachaf, johnw: The forkOS documentation continues "It is a common misconception that you need to use forkOS instead of forkIO to avoid blocking all the Haskell threads when making a foreign call; this isn't the case."
00:35:37 <johnw> ok, I'll update my knowledge, thanks
00:35:40 <shachaf> frerich: I didn't say it's about blocking.
00:36:00 <shachaf> Sometime I should write up the exact details of the threading and FFI system, since there's so much misinformation out there.
00:36:01 <Hail_Spacecake> the other problem I had with writing something that uses lightweight threads
00:36:06 <Hail_Spacecake> or, I guess, forkIO
00:36:39 <Hail_Spacecake> is that sometimes I do want something to block until a current task is done
00:36:41 <frerich> shachaf: Hm to be fair, in an earlier paragraph the docs say "However, forkOS creates a bound thread, which is necessary if you need to call foreign (non-Haskell) libraries that make use of thread-local state, such as OpenGL"
00:36:46 <Hail_Spacecake> I don't want to spawn a new thread immediately
00:37:09 <shachaf> frerich: The only real reason you would want to use forkOS is bound threads.
00:37:17 <shachaf> Bound threads are primarily an FFI issue.
00:37:32 <shachaf> Hail_Spacecake: You should read the FAQ on threads.
00:37:33 <`nand`> Hail_Spacecake: you can use something like an MVar () to communicate blocking
00:37:33 <shachaf> @where faq
00:37:33 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:38:12 <shachaf> `nand` gave one answer to your direct question.
00:38:19 <shachaf> But it's more likely that you should be asking a different question.
00:39:28 <frerich> Hm, I just realized that forkIO-based threads can be executed by multiple OS threads (i.e. they are not bound to a particular OS thread), crazy! :-)
00:39:40 <frerich> It starts to make sense - being unbound is find if you have no thread-local storage.
00:39:40 <shachaf> Yes, they can move around.
00:39:50 <frerich> s/find/fine/
00:39:56 <shachaf> It's more subtle than you think.
00:40:01 <`nand`> about as crazy as the idea that OS threads can run on multiple processors cores
00:40:04 <shachaf> Sometime I should write up the details.
00:40:14 <johnw> that's cool; I'd love to read that shachaf
00:40:18 * frerich too
00:40:36 * johnw volunteers to proof-read
00:40:37 <shachaf> lpsmith wrote a bit of it once.
00:40:41 <frerich> I always thought everything is 'bound'
00:40:43 <shachaf> http://blog.melding-monads.com/2011/10/24/concurrency-and-foreign-functions-in-the-glasgow-haskell-compiler/
00:43:23 <shachaf> Oh boy.
00:43:28 <shachaf> fo: sendWakeup: invalid argument (Bad file descriptor)
00:43:38 <shachaf> Is this a bug?
00:44:08 <shachaf> ioManagerWakeup complains too.
00:44:34 <shachaf> Maybe using lots of threadDelays just exhausts file descriptors.
00:45:07 <geekosaur> hm.  threadDelay shouldn't be using file descriptors at all...
00:45:18 <shachaf> This is with -threaded and +N
00:45:28 <mm_freak> with -threaded it probably does
00:45:29 <shachaf> I assume this is cross-OS thread communication or something?
00:45:35 <mm_freak> after all it's epoll waiting for the timeout
00:45:43 <mm_freak> but it might also do some tricks with epoll timeouts
00:46:04 <shachaf> Hmm, if I remember correctly there was some inefficiency in the way GHC did that.
00:46:07 <shachaf> Maybe.
00:46:13 <shachaf> It's not unlikely I'm thinking of something else.
00:46:20 <shachaf> This is my program:
00:46:21 <shachaf> main = replicateM_ 1000000 (forkIO (threadDelay 1))
00:46:33 <shachaf> Compiled with -threaded and run with +RTS -N
00:47:46 <steve73> FUCK
00:47:52 <steve73> emacs just ffroze
00:48:04 <steve73> death
00:48:10 <johnw> C-g
00:48:11 <djcoin> vim power </troll>
00:48:28 <steve73> oh shit
00:48:28 <shachaf> djcoin: Stop it.
00:48:34 <johnw> (please watch the language)
00:48:36 <shachaf> It's not funny even if you put "</troll>" at the end.
00:48:40 <steve73> what did u do johnw
00:49:05 <djcoin> shachaf: sorry, i could not resist :|
00:52:25 <geekosaur> even with threaded and assuming it's using an fd to communicate with the I/O thread instead of something more haskelly, I'd expect a single loopback pipe that exists for the whole time the I/O manager is running, shared across all threads
00:53:04 <shachaf> I'm not arguing this is what should happen. :-)
00:55:37 <johnw> is it true to characterize foldl as recursing on the first argument, and foldr as recursing on the second argument?
00:55:55 <johnw> (argument of the provided f, that is)
00:56:03 <shachaf> I'm not sure what that means.
00:56:05 <shachaf> @src foldr
00:56:06 <lambdabot> foldr f z []     = z
00:56:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:56:07 <shachaf> @src foldl
00:56:07 <lambdabot> foldl f z []     = z
00:56:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:56:13 <johnw> ((((1 + 2) + 3) + 4) + 5) vs. (1 + (2 + (3 + (4 + 5))))
00:56:38 <johnw> foldl "drills down" on the left side of +, foldr drills down on the right, then both fold back up
00:56:59 <johnw> hmm
00:57:01 <Maxdamantus> .wik left and right recursion
00:57:19 <shachaf> I don't really know what recursing on an argument is.
00:57:25 <johnw> shachaf: hmmm, ok
00:57:37 <johnw> it didn't feel truthy enough
00:57:41 <shachaf> At least, in the sense you're saying it.
00:58:05 <`nand`> foldr doesn't necessarily ‘drill down’; foldr const = safeHead
00:58:17 <johnw> thanks for the clarification, guys
00:58:21 <johnw> i love that about this channel
00:58:29 <shachaf> i love monoids
00:58:33 <glguy> I love recursing. It's so easy
00:58:52 <capisce> cursing again?
00:58:59 <shachaf> You can hardly love anything without glguy coming into the channel to say his catchphrase!
00:59:02 <TheRedMood> SafeHead?
00:59:03 <TheRedMood> :o
00:59:33 <Maxdamantus> > foldr const 0 []
00:59:34 <lambdabot>   0
00:59:38 <Maxdamantus> > foldr const 0 [5]
00:59:39 <lambdabot>   5
01:00:23 <hpaste> st pasted “test” at http://hpaste.org/81254
01:00:36 <steve73> Is this a valid way of doing things?
01:01:01 <steve73> is there any way of breaking up a function into multiple equations?
01:01:07 <shachaf> That's probably not a valid way of doing anything.
01:01:10 <johnw> > foldl const 0 [5]
01:01:11 <lambdabot>   0
01:01:12 <shachaf> I doubt GHC would accept the code.
01:01:21 <shachaf> > foldr (flip const) 0 [1,2,3,4,5]
01:01:22 <lambdabot>   0
01:01:24 <shachaf> > foldr (flip const) 0 []
01:01:26 <lambdabot>   0
01:01:26 <shachaf> Er.
01:01:27 <shachaf> Whoops.
01:01:33 <fmap> that's a valid way of looking like lisp probably
01:01:36 <shachaf> Ignore me.
01:01:49 <shachaf> That's a foldr.
01:01:56 <shachaf> > foldl (flip const) 0 [1,2,3,4,5]
01:01:57 <lambdabot>   5
01:02:00 <steve73> so how do you break up functions in haskell?
01:02:00 <shachaf> > foldl (flip const) 0 []
01:02:02 <lambdabot>   0
01:02:25 <johnw> steve73: 'let', 'where' and making new functions, are good ways
01:02:31 <geekosaur> maybe it's just that I'm tired but insomniac, but I have no idea what that paste is trying to say
01:02:39 <TheRedMood> .....
01:02:44 <TheRedMood> How what?
01:02:44 <shachaf> It's not just that.
01:02:47 <TheRedMood> Safehead?
01:02:57 <TheRedMood> I did not undestand that
01:03:07 <TheRedMood> why did that not return 0 ?
01:03:12 <TheRedMood> > foldr const 0 [5]
01:03:14 <lambdabot>   5
01:03:21 <johnw> geekosaur: it's diagonal at least, hence the name :)
01:03:33 <TheRedMood> map (const 0) [5]
01:03:37 <TheRedMood> >map (const 0) [5]
01:03:41 <TheRedMood> > map (const 0) [5]
01:03:42 <lambdabot>   [0]
01:03:53 <TheRedMood> The why doesn't foldr return 0 ?
01:04:09 <johnw> foldr const 0 [5] = foldr const 0 (5:[]); now replace the : with const, and the [] with 0
01:05:12 <TheRedMood> wait
01:05:13 <TheRedMood> ?
01:05:27 <TheRedMood> yes.. ?
01:05:53 <TheRedMood> 0 0
01:06:01 <TheRedMood> Yeah
01:06:02 <TheRedMood> That i get
01:06:04 <TheRedMood> but
01:06:20 <TheRedMood> > foldr const 0 [5]
01:06:22 <basdirks> sentences are nice
01:06:22 <lambdabot>   5
01:06:24 <basdirks> they are so easy
01:06:31 <TheRedMood> Why is that 5 ?
01:06:33 <johnw> basdirks: lol, i was just thinking something similar :)
01:06:38 <alpounet> > foldr const 0 [a, b, c] :: Expr
01:06:40 <lambdabot>   a
01:06:41 <geekosaur> :t const
01:06:42 <lambdabot> a -> b -> a
01:06:48 <johnw> TheRedMood: perform the substitution I mentioned above
01:06:52 <TheRedMood> Sorry, i press enter a lot when i get excited about something :D
01:07:04 <basdirks> press space instead, it works =D
01:07:21 <TheRedMood> Yeah, know, I am working quite hard on getting rid of the habbit :)
01:07:38 <TheRedMood> > foldr const 0 (const 0)
01:07:40 <lambdabot>   Couldn't match expected type `[b0]' with actual type `b1 -> a0'
01:07:46 <basdirks> it's bigger too so you can just bash it in complete extacy and not worry that you might miss.
01:08:04 <steve73> basically i want to take a and b
01:08:04 <TheRedMood> > foldr const 0 (5 const 0)
01:08:06 <lambdabot>   Could not deduce (GHC.Num.Num ((a0 -> b0 -> a0) -> a1 -> [b]))
01:08:06 <lambdabot>    arising f...
01:08:10 <TheRedMood> ?
01:08:12 <steve73> and do 4 functions with them
01:08:20 <johnw> TheRedMood: well, you need `const` if you want to write it like that
01:08:21 <steve73> then return something that uses all 4
01:08:24 <TheRedMood> johnw, I did as you said...
01:08:26 <johnw> 5 `const` 0 = const 5 0
01:08:34 <TheRedMood> > foldr const 0 (const 5 0)
01:08:36 <lambdabot>   No instance for (GHC.Num.Num [a0])
01:08:36 <lambdabot>    arising from a use of `e_1050'
01:08:36 <lambdabot>  Possi...
01:08:39 <johnw> yes
01:08:45 <johnw> now, do you know what const tdoes?
01:08:48 <TheRedMood> that gives an error....
01:08:58 <johnw> oh, I didn't mean to leave the foldr there
01:09:03 <TheRedMood> const returns the first argument regardles of input
01:09:04 <johnw> foldr const 0 [5] = const 5 0
01:09:05 <geekosaur> you misunderstood.  foldr const 0 [5] = foldr const 0 (5:[]) = 5 `const` 0 = 5
01:09:41 <geekosaur> so we took the (5:[]), replaced the : with `const`, replaced the [] with 0
01:09:43 <TheRedMood> ..... So the syntaxtic sugar is the thing making it work?
01:10:01 <johnw> it's not sugar
01:10:01 <shachaf> Perhps this discussion belongs in #haskell-overflow.
01:10:13 <TheRedMood> ? What is that chanell?
01:10:15 <johnw> this is pretty topical for #haskell, I think
01:10:16 <steve73> Hello
01:10:25 <steve73> how do you take one set of input
01:10:30 <steve73> use that in four sub functions
01:10:37 <steve73> and then combine them and return that
01:10:38 <TheRedMood> If I am doing somethign wrong talking about this here, then I will take it to the right channel right away! I am sorry.
01:10:39 <shachaf> johnw: #haskell-overflow is for things that are on-topic in #haskell, but very long.
01:10:39 <johnw> but maybe a long discussion of foldr does belong in #haskell-overflow
01:10:44 <johnw> ah, ok
01:10:46 <shachaf> This has taken up several pages of IRC already.
01:10:54 <shachaf> TheRedMood: This channel is fine.
01:10:56 <TheRedMood> Ah, thanks :D Going there now
01:10:58 <johnw> shachaf: and forkIO didn't?
01:11:06 <shachaf> johnw: Did it?
01:11:48 <johnw> well, maybe not
01:11:55 <johnw> forkIO was 77 lines, this conversation is 122 lines
01:12:11 <shachaf> This conversation is far from over, if your goal is to end up with a good understanding of foldr.
01:12:12 <johnw> but to be fair, my pages are only 23 lines long :)
01:12:24 <TheRedMood> O_O you know how many lines this conversation has taken?
01:12:26 <shachaf> Anyway, no one complained before.
01:12:32 <TheRedMood> What client do you use?
01:12:53 <geekosaur> steve73:  foo a b c d = <combining expression>(newline)  where(newline)    subfn1 = ...(newline)    subfn2 = ...(newline) ...
01:13:04 <johnw> shachaf: it's fine
01:21:06 <merijn> mm_freak: Ping?
01:24:15 <glguy> I'm probably too late, but long conversations are fine in channel, especially when nothing else is going on
01:25:18 <mm_freak> merijn: pong
01:28:59 <merijn> mm_freak: I've been playing a bit with netwire4, but I seem to hit some overall program design walls. Most of the examples I see seem to take an approach of having a single "(WorldState, Input) -> WorldState" wire, which makes sense if you have a single wire running the entire world and don't need to persist, but I'm unsure whether that's the best approach if you want to have your worldstate persist and/or have multiple wires interacting 
01:29:24 <danr> The longest type signature I have ever seen (package Nussinov78)
01:29:55 <mm_freak> merijn: you can persist individual wire states…  in fact, you can make the wires do that by themselves, if you want
01:29:59 <mm_freak> but you can't persist wires
01:30:10 <danr> oops, that was my touchpad pasting titles from reddit :$
01:30:16 <mm_freak> that's a problem i've been trying to solve for a long time, but it appears to be impossible
01:30:36 <mm_freak> there has to be about the same runtime support that cloud haskell needs
01:30:47 <mm_freak> unfortunately the closures wouldn't be static, so i can't use distributed-static
01:30:59 <merijn> Since the wires are Kleisli functions I was thinking it should be possible to have (for example) a acid-state based world state and have the wires update that state. But given such a design I'm not sure it even makes to use FRP?
01:31:10 <TheRedMood> johnw, I got it! :D
01:31:16 <merijn> s/even makes/even makes sense/
01:31:18 <johnw> that's great!
01:31:43 <mm_freak> merijn: i see no problem in combining netwire with acid-state…  in fact that's the approach i would take to persist stuff
01:31:45 <TheRedMood> Now I understand why it becomes 5, i forgot, or just refused to read, the fact that foldr takes to arguments.
01:31:49 <TheRedMood> X3
01:32:57 <merijn> mm_freak: Well, most examples I see use sort of a 1 wire per object, with the creation of new objects just being the creation of extra wires, so I wasn't sure whether duplicating everything (i.e. having object be represented as both values in some sort of worldstate in IO) *and* as a wire made any sense
01:34:15 <mm_freak> merijn: look at it this way:  the object types represent states of objects, and the wire makes that state reactive
01:34:24 <mm_freak> just think of the 'time' wire
01:34:31 <mm_freak> it gives you a Time, which is really just a number
01:34:36 <mm_freak> the wire makes that number reactive
01:34:47 <merijn> Right
01:36:32 <merijn> btw, there's no real reason to restrict yourself to one top level wire, right? i.e. would having a handful of threads running different wires (probably with some STM/IO shared state) be any issues other than the usual mutual exclusion/locking issues you'd expect there?
01:37:07 <mm_freak> merijn: that's totally fine
01:37:30 <mm_freak> in that case it makes sense to use non-IO wires, so that you don't run into the usual side effect issues
01:38:15 <basdirks> can I limit the modules for which documentation is rebuilt when using `cabal haddock'?
01:38:29 <johnw> basdirks: you can mark them hidden
01:38:36 <johnw> {-# OPTIONS_HADDOCK hide #-}
01:39:09 <Jizzday> www.jizzday.com
01:39:17 <basdirks> That's not an option in this case. Is there a command-line equivalent?
01:39:45 <merijn> mm_freak: Well, my main usecae would be a shared acid-state state, which would have to be IO, but should be threadsafe to do concurrently, or STM (has anyone tried combining multiple wires and STM yet, seems interesting but I have no clue how that'd behave...)
01:48:43 <Steven_> What does it usually mean when "The function `b' is applied to one argument,     but its type `Picture' has none"?
01:49:06 <Steven_> I'm not a fan of GHCIs error messages.....
01:49:19 <shachaf> Which part is unclear?
01:49:24 <shachaf> > 'a' True
01:49:26 <lambdabot>   The function 'a' is applied to one argument,
01:49:26 <lambdabot>  but its type `GHC.Types.Char'...
01:49:29 <shachaf> > let b = 'a' in b True
01:49:31 <lambdabot>   The function `b' is applied to one argument,
01:49:31 <lambdabot>  but its type `GHC.Types.Char'...
01:49:38 <shachaf> I'm using b like a function, but it's not a function.
01:49:48 <Steven_> ahhh
01:49:52 <Steven_> so much clearer
01:50:28 <shachaf> How would you improve the error message?
01:50:47 <Steven_> B is not a function blah blah blah
01:50:58 <Steven_> but I don't understand how im using it as a function
01:51:25 <Steven_> let f2 = beside( beside (beside (a b) b) a
01:51:31 <mm_freak> merijn: that suggests that your design may be unfortunate…  i doubt that that will work well
01:51:36 <mm_freak> merijn: what's your application?
01:52:00 <Steven_> you mean what im trying to build or what im using to edit?
01:52:37 <mm_freak> Steven_: i'm talking to merijn
01:52:51 <Steven_> oh
01:53:26 <mm_freak> Steven_: anyway, the expression you just pasted is syntactically incorrect…  maybe it's not complete
01:53:48 <hpaste> st pasted “test” at http://hpaste.org/81256
01:54:17 <Steven_> which part of it needs work you think?
01:54:33 <mm_freak> Steven_: see 'f2'
01:54:42 <mm_freak> or rather 'f1'
01:54:48 <Steven_> well f2 was just one example
01:54:59 <mm_freak> you wrote 'b a'
01:55:10 <mm_freak> which means that you apply b to a, so b has to be a function
01:55:51 <mm_freak> Steven_: as a side note, you can write binary function applications infix
01:55:59 <mm_freak> instead of "beside x y" you can write "x `beside` y"
01:56:14 <mm_freak> which is particularly useful, if you have:  x `beside` y `beside` z
01:56:58 <Steven_> i thought beside was not a standard part of haskell
01:57:24 <shachaf> It's not.
01:57:32 <shachaf> But function application is a standard part of Haskell.
01:57:50 <mSSM> If I have a data type `data Foo a = Foo a a', which I have made an instance of `Num a', how can I make it an instance of fractional, if `a' in `Foo a' is fractional?
01:58:04 <mm_freak> Steven_: you can do that for all binary applications
01:58:06 <Steven_> well that just made life a lot easier
01:58:21 <mm_freak> instead of "hSetBuffering stdout NoBuffering" you can write "stdout `hSetBuffering` NoBuffering"
01:58:27 <shachaf> mSSM: instance Fractional a => Fractional (Foo a) where
01:58:40 <shachaf> mm_freak: You wouldn't really write that, I hope?
01:58:54 <mm_freak> shachaf: no, although sometimes i write sections like that
01:59:05 <mm_freak> mapM_ (`hSetBuffering` NoBuffering)
01:59:11 <mSSM> shachaf: yes, but what happens if `foo :: Foo Int' ?
01:59:13 <shachaf> That's not so bad.
01:59:23 <shachaf> mSSM: You tell me!
02:00:19 <mSSM> shachaf: It will fail with `expected type Float with actual type Int'? And I will have to first convert `Foo Int' to `Foo Float'?
02:00:54 <shachaf> No, you haven't mentioned the type "Float" anywhere.
02:01:02 <shachaf> But you can find out easily by trying it.
02:02:21 <hpaste> st pasted “title” at http://hpaste.org/81259
02:02:26 <mSSM> Does a type have to be an instance of Num first, before it can be an instance of Fractional?
02:02:43 <mSSM> shachaf: ^ Is that how to read “class Num a => Fractional a where”
02:02:44 <mSSM> ?
02:02:46 <shachaf> Steven_: Please read what mm_freak said carefully.
02:02:52 <shachaf> Steven_: Every character counts.
02:02:59 <shachaf> mSSM: Yep.
02:03:14 <shachaf> class Foo a => Bar a means that every instance of Bar is an instance of Foo.
02:04:29 <mSSM> shachaf: Alright...
02:04:35 <Steven_> so is there really a solution to this?
02:06:21 <shachaf> To what?
02:06:47 <shachaf> mm_freak wrote: x `beside` y `beside` z
02:06:51 <shachaf> You wrote: a beside b beside b
02:07:15 <shachaf> Think of it as a game of "find the differences between these two pictures". :-)
02:07:31 <latermuse> is there a quick way to flip a tuple around so that (x,y) because (y,x)?
02:07:34 <shachaf> (I don't mean to be unhelpful. I mean to teach you figure out this sort of thing.)
02:07:35 <latermuse> becomes*
02:07:40 <shachaf> @hoogle (a,b) -> (b,a)
02:07:41 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
02:07:41 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
02:07:41 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
02:07:46 <latermuse> doh
02:07:50 <latermuse> thanks shachaf
02:07:51 <merijn> mm_freak: I'm playing with some networked game stuff, just sort of thinking/toying with how much could be done in parallel or not
02:08:21 <mSSM> Where can I find the definition of the Double instances (e.g. for Fractional)? When I hit source at [1], it throws a `404 Not Found' at me. 1: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Double
02:08:53 <shachaf> Wow, a footnote in one line of IRC.
02:09:06 <mSSM> Inline looks bad...
02:09:06 <shachaf> That must be a new record?
02:09:13 <shachaf> I've never seen it before. :-)
02:09:26 <shachaf> Anyway, I usually download the package and read the source.
02:09:30 <quicksilver> mSSM: the definitions aren't terrible informative becuase they're  GHC-specific instances and they're just in terms of GHC primitives
02:09:32 <shachaf> But be warned: The source will probably not help you.
02:09:36 <Steven_> so if i were to make something like a constant or object idk what it is in haskell that said z = b, could i just say a beside b beside c (=b) beside d (=b)
02:09:37 <Steven_> ?
02:09:41 <shachaf> It's full of GHC implementation details.
02:09:47 <mSSM> I am always trying to make it look nice... E.g. http://www.lookatmysuperlongurlrightinhere/path/more/path/path/path/path is not very readable, is it?
02:10:00 <shachaf> If your Foo is wrapping a numeric type, you can use that type's instance to implement your own operations.
02:10:16 <quicksilver> mSSM: you'll find them here - http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Float.html
02:10:29 <shachaf> That works too!
02:10:46 <Steven_> how do you declare a variable in haskell?
02:10:54 <Steven_> just simple a = d?
02:11:01 <latermuse> Steven_: x = foo
02:11:03 <Steven_> or typed like Picture s
02:11:07 <Steven_> okay
02:11:14 <quicksilver> a :: Picture; a = d
02:11:16 <quicksilver> if you want to type it.
02:11:18 <latermuse> Steven_: it works a bit differently than some other languages, so be careful
02:11:19 <shachaf> Steven_: Are you reading any introduction to Haskell?
02:11:25 <shachaf> You probably should be reading one.
02:11:28 <Maxdamantus> O_o you can write it like that?
02:11:28 <shachaf> @where lyah is popular.
02:11:28 <lambdabot> http://www.learnyouahaskell.com/
02:11:29 <Steven_> x being the value being assigned or assigned to?
02:11:37 <Maxdamantus> Oh, nvm.
02:11:41 <mSSM> lyah lyah pants on fire :D
02:11:41 <quicksilver> x is hte new variable
02:11:45 <Steven_> k
02:11:45 <quicksilver> in latermuse's example
02:11:48 * Maxdamantus read "a :: Picture a = d" :\
02:11:49 <shachaf> There is no assignment.
02:11:50 <quicksilver> and foo is the value you're giving it.
02:11:57 <latermuse> I read many introductions to haskell. As many as I can find :)
02:12:10 <`nand`> isn't a :: Picture = d -- valid
02:12:10 <latermuse> quicksilver: its not so much giving it a value as saying the values are equal
02:12:13 <mSSM> shachaf: ok, I now realize what I asked and what I want is something totally different.
02:12:19 <latermuse> a = b == b = a
02:12:21 <shachaf> mSSM: Often the case.
02:12:23 <Maxdamantus> I'm pretty sure it's not.
02:12:26 <`nand`> oh, it is with -XScopedTypeVariables
02:12:35 <shachaf> `nand`: Yes, but the function version is no longer valid in GHC>
02:12:36 <Maxdamantus> > let a :: Int = 4 in a + a
02:12:38 <lambdabot>   8
02:12:42 <Maxdamantus> O_o
02:12:43 <shachaf> f (x :: Int) :: Int = x + 1
02:12:48 <shachaf> That used to work, but no longer.
02:13:35 <Steven_> so im just gonna make a bunch of "let ... = b" statements and then use x beside y besides z?
02:13:37 <mm_freak> merijn: right now netwire doesn't support parallel processing, but it will
02:14:03 <mm_freak> i have yet to apply a few patches that were contributed by others
02:14:17 <mm_freak> unfortunately i don't have a lot of spare time right now
02:14:18 <jockej> -join #menageatrois
02:14:26 <mSSM> shachaf: I want to be able to do this: `n :: Float' `foo :: Foo a', where `a :: Float'. Is it possible to make `foo/n=foo' :: Float a', where `(/) (Foo a b) n = Foo (a/n) (b/n)' ?
02:14:53 <shachaf> mSSM: I'm not sure what you're asking, but probably not.
02:14:54 <shachaf> @ty (/)
02:14:55 <lambdabot> Fractional a => a -> a -> a
02:15:01 <mm_freak> merijn: anyway, i'm still researching wire persistence, so don't lose hope =)
02:15:02 <shachaf> Look aat how both of its arguments have the same type.
02:15:12 <mm_freak> it's just an incredibly difficult problem
02:15:27 <absence> is anyone familiar with the problem of Network.Socket.ByteString.Lazy not having a send function in windows? http://hpaste.org/48714
02:15:33 <Maxdamantus> :t let (/) = const (fix id) in (/)
02:15:34 <mSSM> shachaf: yeah, that's why making `Foo a' an instance of `Fractional' doesn't make sense: I would be able to divide 2 Foo's, but that's not what I want. :D
02:15:35 <lambdabot> b -> a
02:15:37 <`nand`> wire persistence? as in, across program runs?
02:15:42 <shachaf> mSSM: Correct.
02:15:52 <mm_freak> `nand`: yeah and distributing
02:16:00 <quicksilver> mSSM: "foo :: Foo a" where "a :: Float" makes no sense.
02:16:19 <quicksilver> mSSM: if "foo :: Foo a" then "a" is a type, not a value.
02:16:30 <quicksilver> mSSM: but "a :: Float" says that "a" is a value.
02:16:50 <mSSM> quicksilver: Can't I say `a is of type float'?
02:17:24 <quicksilver> you can say that, but then "Foo a" makes no sense.
02:17:25 <Maxdamantus> Float is the only type that is of type Float.
02:17:30 <`nand`> (quicksilver: unless of course Foo :: Float -> *)
02:17:36 <`nand`> Maxdamantus: that is wrong
02:17:43 <quicksilver> "Foo a" makes sense only if a is a *type* not a value.
02:17:50 <`nand`> Float is not of type Float, because Float does not have a type
02:18:07 <Maxdamantus> Fine.
02:18:12 <Maxdamantus> Float is the only type that is type Float.
02:18:23 <quicksilver> mSSM: did you perhaps mean, foo :: Foo Float?
02:18:36 <mSSM> quicksilver: yes! that's what I tried to express
02:19:00 <quicksilver> mSSM: furthermore, ":: Float a" makes no sense. Float doesnt' take parameters.
02:19:34 <mSSM> ok
02:20:06 <merijn> mm_freak: Of course, most of this is just a bit of me figuring out how far I can reasonably push things. I think my approach will end up being acid-state world state with 1 wire that manipulates it (well, maybe multiple wires if I can find an effective way to "shard" the worldstate so multiple wires don't conflict), I think that as-is it'd be really hard to have multiple wires on shared state without having the ability to do transactions
02:20:16 <quicksilver> mSSM: Are you trying to say "Can I define a custom type Foo which I can still 'divide' by a normal Float" ?
02:20:33 <quicksilver> mSSM: so that a :: Foo and b :: Float and you want to write a/b ?
02:21:15 <mSSM> quicksilver: yes :)
02:21:29 <`nand`> not unless you redefine (/)
02:21:32 <mSSM> quicksilver: so that the result is again of type `a' :: Foo'
02:21:37 <quicksilver> mSSM: Ok. That's a perfectly reasonable thing to want to do.
02:21:46 <quicksilver> but you don't really want to try to use (/) for it.
02:21:55 <quicksilver> (/) already has a type, and it's not compatible with what you want.
02:22:01 <quicksilver> better to choose a new symbol.
02:22:05 <quicksilver> (/.) perhaps.
02:22:24 <quicksilver> plenty of librarys do things like this for, for example, scalar multiplication of matrices
02:22:28 <quicksilver> or scalar multiplication of vectors.
02:22:51 <quicksilver> of course you can rename or hide the normal (/) and then define your own (/) which is somethign completely different within your module
02:22:57 <quicksilver> but that's not normally what you want to do.
02:23:30 <`nand`> depending on what exactly your Foo works like there may be a different solution
02:23:50 <mSSM> quicksilver: What I did just now is: “fooOp1 :: (a -> b) -> Foo a -> Foo b ; fooOp1 h (Foo a b) = Foo (h a) (h b)” and then if I have a `Foo Int' I do “fooOp1 ( (/n).fromIntegral ) myFoo”
02:24:05 <`nand`> if your Foo is a Functor then you could use fmap (/n) :: Foo Float -> Foo Float
02:24:50 <`nand`> your fooOp1 is a perfectly fine ‘fmap’
02:24:56 <`nand`> you just reinvented the Functor
02:24:56 <mSSM> lol
02:25:00 <mSSM> I wasn't aware of that.
02:25:09 <mSSM> :-/
02:25:35 <mSSM> `nand`: Maybe I should read LYAH another 5 times.
02:26:03 <mSSM> `nand`: Alright, so if I make `Foo' an instance of Functor, then I can get rid of the boilerplate?
02:26:50 <`nand`> well, then you can write fmap ((/n).fromIntegral) instead of fooOp1 ((/n).fromIntegral)
02:28:01 <mSSM> `nand`: at the moment, I am defining “(+),(*)” in terms of a similar “fooOp2” and “abs, signum, negate” in terms of that “fooOp1” above.
02:28:30 <`nand`> your Foo should make a perfectly fine Applicative, too
02:28:37 <`nand`> so you could use liftA2 (+) and liftA2 (*)
02:30:26 <`ramses> is there some module in parsec which lets you parse Text without manually having to pack all over the place? So with substitutes for parsers like char and string
02:31:31 <`nand`> that should work out of the box
02:31:38 <`nand`> ‘char’ and ‘string’ work for Text
02:32:23 <mSSM> `nand`: Just to understand how to make `Foo' an instance of Functor: I simply define fmpa in terms of my `fooOp1' up there, right?
02:32:29 <mSSM> fmap*
02:32:41 <`nand`> sure
02:34:15 <`ramses> `nand`: string has a result type of String? I would like that to be Text
02:34:34 <`ramses> or do I have a wrong module imported then?
02:34:41 <`nand`> oh
02:34:54 <`nand`> I see what you mean; I thought you meant parsing a Text
02:34:57 <`ramses> and char has Char, so I need to apply singleton every time
02:35:22 <`ramses> I'd think there would be versions for Text as well, but I can't find thel
02:35:24 <`ramses> them*
02:36:11 <`ramses> I have the parser working for Strings, but I like to change it to parse Data.Text input now, to make it more efficient
02:38:33 <mSSM> `nand`: Is that the usual way to do it? You define a function (like “map” for “[]”), and then you make it an instance of e.g. “Functor” by saying “fmap = map”
02:38:56 * hackagebot Elm 0.7.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.7.1 (EvanCzaplicki)
02:38:59 <`ramses> mSSM: or just directly implement fmap
02:39:10 <`nand`> I'd say the usual way to do it is to write “fmap = ..definition..”
02:39:29 <`nand`> eg. in your case: instance Functor Foo where fmap f (Foo a b) = Foo (f a) (f b)
02:39:37 <mSSM> `nand`: Right, that makes more sense.
02:39:39 <mSSM> Cool!
02:39:46 <`nand`> you can actually refrain from writing that as well
02:39:47 <mSSM> I guess I got what `fmap' is now.
02:40:00 <mSSM> `nand`: Tell me more! :D
02:40:18 <`nand`> data Foo a = Foo a a deriving Functor
02:40:28 <`nand`> (needs DeriveFunctor)
02:41:14 <`nand`> you could also derive Foldable and Traversable for your type and get fmap + a lot of other useful stuff via ‘lens’ (eg. fmap = over traverse)
02:42:46 <mSSM> `nand`: I found something on DeriveFunctor on the ML [1], but nothing on hoogle. Is that it? 1: http://www.haskell.org/pipermail/haskell-prime/2007-March/002137.html
02:43:52 <merijn> `nand`: Don't Traversable/Foldable already provide fmapDefault without needing a dependency on lens?
02:44:00 <`nand`> merijn: yes, that too
02:44:18 <`nand`> but see “a lot of user useful stuff” :P
02:44:48 <mm_freak> merijn: i'd be happy to see the result =)
02:44:53 <mSSM> 1) I don't yet understand what `lens' is. 2) Where can I read up what `over' is? (Nothing on hoogle.)
02:46:50 <Saizan> lens.github.com
02:49:44 <johnw> mSSM: do you know what a "getter" or an "accessor" is?
02:50:00 <shachaf> johnw: Given that those are lens terms, there's no reason they should.
02:50:13 <johnw> i wasn't speaking with the lens meaning of those terms
02:50:15 <mSSM> johnw: get, set methods in e.g. Objects?
02:50:17 <latermuse> is there an "isInfixOf" for maps?
02:50:20 <shachaf> (I think if you're appealing to OOP intuition or something, that's a mistake -- this is subtly different enough to be confusing.)
02:50:22 <johnw> yes, like get methods
02:50:30 <johnw> fst is a getter for the first element of a pair:
02:50:32 <johnw> > fst (1,2)
02:50:34 <shachaf> (Better to explain this in Haskell terms.)
02:50:34 <lambdabot>   1
02:50:39 <shachaf> (Oh well. Do whatever.)
02:50:46 <johnw> so, you also know what a setter is
02:50:53 <typoclass> mSSM: i think this is a good explanation https://github.com/ekmett/lens/wiki/Examples
02:50:54 <johnw> a lens is something that does both
02:51:05 <johnw> so, if I have the _1 lens
02:51:12 <johnw> it will let me access the first element of any tuple
02:51:26 <johnw> and I can use it make a new tuple by replacing the first element of another tuple
02:51:33 <johnw> > view _1 (1,2)
02:51:33 <shachaf> A lens setter is pretty different from what you might expect in an OO setter.
02:51:35 <lambdabot>   1
02:52:24 <johnw> > set _1 3 (1,2)
02:52:26 <lambdabot>   (3,2)
02:52:31 <mSSM> johnw: so a more flexible version of `foo (_,b) a' = (a'.b)' ?
02:52:37 <johnw> in these examples, _1 is what people mean by a lens
02:52:42 <mSSM> alright
02:52:46 <johnw> yes, and it's composable
02:52:51 <johnw> and you can pass it around
02:53:05 <johnw> > view (_1._2) (1,(2,3))
02:53:07 <lambdabot>   Ambiguous type variables `b0', `b1', `t0' in the constraint:
02:53:07 <lambdabot>    (Control.Le...
02:53:13 <johnw> > view (_2._1) (1,(2,3))
02:53:15 <lambdabot>   2
02:53:23 <mSSM> johnw: Can you extend that to tuples of any dimension? E.g. _n for (1,2,3,4,....,n) ?
02:53:27 <johnw> it already is :)
02:53:36 <johnw> i don't know how many n edwardk has provided, though
02:53:46 <johnw> but for lists, you can use "element"
02:53:51 <edwardk> _9
02:53:54 <johnw> > view (element 3) [1..]
02:53:55 <lambdabot>   Ambiguous type variable `a0' in the constraints:
02:53:55 <lambdabot>    (GHC.Enum.Enum a0)
02:53:55 <lambdabot>     ...
02:54:08 <johnw> hmm.. i think element isn't it
02:54:10 <mSSM> johnw: so do you have to make your types instances of lens?
02:54:16 <shachaf> element is it, but you need to preview
02:54:18 <johnw> mSSM: do you mean record types?
02:54:25 <edwardk> > preview (element 3) [1..]
02:54:26 <lambdabot>   Just 4
02:54:35 <johnw> shachaf: why is that?
02:54:42 <typoclass> > map (set _1 `flip` ("all pretty different","setter")) $ words "lens oo irish" -- shachaf
02:54:44 <lambdabot>   [("lens","setter"),("oo","setter"),("irish","setter")]
02:54:45 <edwardk> :t element
02:54:46 <lambdabot> (Applicative f, Traversable t, Indexable Int p) => Int -> p a (f a) -> t a -> f (t a)
02:54:49 <shachaf> johnw: Left as an exercise.
02:54:51 <edwardk> it gives back a traversal of the element
02:54:54 <edwardk> you might not have it
02:55:01 <edwardk> > [1..10] ^? element 20
02:55:03 <johnw> ah, preview is ^?
02:55:04 <lambdabot>   Nothing
02:55:11 <johnw> i didn't recognize the non-operator form
02:55:20 <edwardk> > ["hello","world"] ^. element 1
02:55:22 <lambdabot>   "world"
02:55:23 <johnw> shachaf: some day, you will leave the rest of life to me as an exercise :)
02:55:24 <edwardk> > ["hello","world"] ^. element 2
02:55:26 <lambdabot>   ""
02:55:42 <edwardk> there it needs a monoid to be able to return it when missing
02:56:00 <johnw> ["hello", "world"] ^? element 1
02:56:02 <johnw> > ["hello", "world"] ^? element 1
02:56:04 <lambdabot>   Just "world"
02:56:04 <danr> is it good or bad practice to put -O2 in ghc-options in your .cabal file?
02:56:21 <dcoutts> danr: do it if you know it makes it faster than -O1
02:56:28 <dcoutts> if not, don't bother
02:56:35 <dcoutts> the default is fine most of the time
02:56:44 <mSSM> johnw: I have no idea what I mean! :D I mean, what do I have to do to make my data type usable with a lens?
02:56:50 <danr> and default is -O1?
02:56:55 <dcoutts> danr: yes
02:57:02 <danr> dcoutts: thank you!
02:57:07 <`nand`> (^?) has a name? interesting :)
02:57:20 <johnw> mSSM: there are at least three ways to use your own types with lenses
02:57:37 <dcoutts> danr: which is why it's sometimes handy to use: cabal configure -O0  when just hacking
02:57:45 <johnw> mSSM: using TH to generate lenses for record fields, writing lenses by hand, and using "lens"
02:57:46 <`nand`> mSSM: I think what you mean to be asking is “how do I define a lens for my datatype?”
02:58:02 <johnw> for non-record types, I think only the latter two work
02:58:14 <johnw> unless shachaf has done something crazy with prisms again
02:58:43 <`nand`> isn't there some form of ‘makeLenses’ that lets you provide the names; and thus work for non-records?
02:58:57 * hackagebot shuffle 0.1.0.2 - Shuffle tool for UHC  http://hackage.haskell.org/package/shuffle-0.1.0.2 (JeroenBransen)
02:58:59 <johnw> good question
02:59:13 <shachaf> `nand`: What are the ;s again? Commas?
02:59:24 <edwardk> :t makeLensesFo
02:59:24 <`nand`> shachaf: didn't even notice that one, yes
02:59:25 <lambdabot>     Not in scope: `makeLensesFo'
02:59:25 <lambdabot>     Perhaps you meant one of these:
02:59:26 <lambdabot>       `makeLensesFor' (imported from Control.Lens),
02:59:26 <edwardk> :t makeLensesFor
02:59:27 <lambdabot> [(String, String)] -> Language.Haskell.TH.Syntax.Name -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
02:59:36 <edwardk> makeLensesFor doesn't work without record syntax though
02:59:40 <`nand`> oh
02:59:59 <edwardk> you can makePrisms on non-records
03:00:07 <edwardk> but that just gives you the constructor prisms
03:00:36 <shachaf> Hmm, you could make a version for non-records that looked at a TH pattern, right?
03:00:43 <shachaf> data Foo a = Foo a b c
03:01:00 <shachaf> makeLenses [blah|Foo one two three|] to make one/two/three lenses.
03:01:03 <shachaf> Or something like that.
03:01:11 <shachaf> That's sort of in mgsloan's territory.
03:01:25 <[mth]> Does anyone know if there is a mechanism for including additional info in the generated Paths_$modulename$ file. Specifically I would like to be able to add a unique identifier to each build (build timestamp would be sufficient).
03:03:43 <`nand`> data Foo a = No | Foo a; $(makePrisms ''Foo) -- what should this be defining, exactly?
03:03:56 <edwardk> `nand`: it'll make prisms _No and _Foo
03:04:02 <`nand`> oh
03:04:06 <`nand`> I expected ‘foo’
03:04:18 <Lethalman> about http://hackage.haskell.org/trac/ghc/wiki/Platforms , is that specific to running ghc on the platform, or running ghc cross compiled binaries to the platforms?
03:04:28 <Lethalman> or that applies to both?
03:04:33 <edwardk> we switched prisms to the _Foo convention because it avoided conflicts with lenses and made them look like the constructors
03:04:52 <`nand`> ah, okay
03:05:50 <shachaf> _Left is pretty much equivalent to Left.
03:05:59 <shachaf> In terms of what it lets you do.
03:06:13 <`nand`> like pattern matching on it?
03:06:19 <shachaf> And constructing from it.
03:06:21 <edwardk> you can match and construct with it
03:06:22 <shachaf> That's pretty much it.
03:06:27 <edwardk> > 5^._Left
03:06:29 <lambdabot>   Could not deduce (GHC.Num.Num (Data.Either.Either a c0))
03:06:29 <lambdabot>    arising from th...
03:06:33 <edwardk> > 5^.re _Left
03:06:35 <lambdabot>   Left 5
03:06:43 <edwardk> > Left 5^._Left
03:06:45 <lambdabot>   Ambiguous type variable `a0' in the constraints:
03:06:45 <lambdabot>    (GHC.Num.Num a0)
03:06:45 <lambdabot>      a...
03:06:47 <edwardk> > Left 5^?_Left
03:06:49 <lambdabot>   Just 5
03:07:02 <shachaf> IN AN ALTERNATE UNIVERSE: data Either a b = Left a | Right b defines two prisms.
03:07:34 <`nand`> case/of.. and constructor application is really just syntactic sugar for prisms
03:07:54 <edwardk> well, you still have the issue that prisms don't let you check for overlap, etc.
03:08:11 <shachaf> Overlap?
03:09:17 <johnw> aristid: ping
03:09:33 <edwardk> with real constructors i can check for overlapping patterns and exhaustiveness
03:09:51 <shachaf> Ah, you mean the thing that GHC can do.
03:09:57 <edwardk> even in f# with view patterns, they can check that
03:10:18 <edwardk> because they have a subset of patterns where you enumerate the cases
03:10:31 <shachaf> Hmm.
03:10:33 <adnap> What is the standard way to import C functions with a void return type via FFI? I noticed there is no void type in Foreign.C.Types. http://www.haskell.org/haskellwiki/FFI_Introduction#Complete_example_with_GHC uses CInt for a void return type.
03:10:36 <shachaf> Is there a dual thing that lenses don't give you?
03:10:42 <shachaf> adnap: IO ()
03:10:55 <edwardk> yes, the exhaustive enumeration of fields
03:11:03 <edwardk> this is the bokeh lens concept basically
03:11:04 <edwardk> dualized
03:11:11 <adnap> shachaf: That's simple. I will try it
03:11:11 <shachaf> adnap: CInt is the argument here, not the result.
03:11:26 <shachaf> adnap: "void set_icanon(int fd)" -----> "CInt -> IO ()"
03:11:35 <shachaf> Exhaustive enumeration of fields?
03:11:37 <johnw> haha, are you using bokeh now edwardk?
03:11:37 <adnap> shachaf: Oh, you're right. I misread
03:11:51 <shachaf> I've forgotten what bokeh means.
03:11:57 <edwardk> johnw: yeah thats been the term for the part of an isomorphism lens thats out of focus for a while
03:12:01 <johnw> it's the quality of the blur you see in pictures
03:12:01 <shachaf> Both the English word and the lens word.
03:12:03 <shachaf> Oh, that.
03:12:04 <`nand`> shachaf: Record { foo = a, bar = b } -- Warning: field not defined: bat
03:12:18 <shachaf> Oh, I see.
03:12:36 <johnw> lenses with higher blade apertures have more circular bokeh highlights
03:12:38 <shachaf> right' :: p a b -> p (bokeh,a) (bokeh,b)
03:12:44 <edwardk> remember we went through this horrible hlist solution before finding out that exposed would work?
03:12:51 <shachaf> Well, OK, that's not quite right.
03:12:51 <`nand`> and iirc the bokeh thing was about changing the types of multiple fields at the same time
03:13:26 <edwardk> `nand`: that and exhaustiveness checking and about 'vertical composition'
03:13:37 <`nand`> vertical composition?
03:13:54 <edwardk> e.g. give me 2 lenses that don't overlap and i'll give you a traversal of their targets
03:13:56 <shachaf> `nand`: Wait, that's not a lens's job.
03:14:02 <shachaf> Lenses can't construct records out of nothing.
03:14:03 <edwardk> you need a lens and a lens into the bokeh of the first lens
03:14:17 <shachaf> Come to think of it, why not?
03:14:44 <`nand`> I'd imagine the combined power of prisms and lenses should be able to construct records
03:14:58 <shachaf> If you combine them in one direction, you get an isomorphism.
03:15:09 <shachaf> In the other direction, you get an affine traversal.
03:15:19 <`nand`> it's sort of a shame that prisms work on tuples instead of some potential ‘isolated record’ for that constructor
03:15:42 <`nand`> then you could use the prism for the construction and named lenses for the fields
03:15:45 <`nand`> or something
03:16:00 <edwardk> `nand`: that may be something we revisit as we do makeExposed and work with makeFields
03:16:13 <edwardk> because there we have more things that get the same field names
03:16:32 <edwardk> so making prisms go to a smaller record type that offers up the same field names is quite probably doable
03:17:05 <edwardk> and we can derive Field1 .. n for it so the existing _1.._n behavior would still work
03:17:18 <shachaf> Maybe that sort of thing would work better with structural types.
03:17:44 <Spockz> I hardly dare asking this: How can I handle the exception that rises when something is evaluated that is undefined?
03:17:55 <shachaf> Spockz: You probably shouldn't.
03:18:03 <Spockz> shachaf: I know
03:18:05 <shachaf> But if you want to, you can use Control.Exception to catch it in IO.
03:18:25 <shachaf> You can use the function "teaspoon" from the package "spoon" to catch it outside of IO, but this is usually a bad thing to do.
03:18:28 <edwardk> :t handling _ErrorCall
03:18:30 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => (String -> m r) -> m r -> m r
03:18:37 <edwardk> =)
03:19:04 <Spockz> shachaf: I tried to to it with handle (\ _ -> putStrLn "something")  but then I get a type error
03:19:07 <typoclass> Spockz: it might be more productive to do "grep -r undefined" over your code and fix some of the places where it can originates =)
03:19:07 <shachaf> Or if you're OK with depending on two dozen packages with names like "semigroupoids" and "MonadCatcHIO-transformers", you can use lens.
03:19:19 <mikeplus64> `nand`: the other day i wondered about the efficiency of doing stuff like symbolicallyEmptyOrDefault & field .~ val & field2 .~ val2 ... and it got reduced to just singular normal record construction
03:19:30 <shachaf> Spockz: OK, well, do the usual thing that you do when you get type errors.
03:19:31 <Spockz> shachaf: https://gist.github.com/137e5847fdc31bc1d448
03:19:46 <shachaf> Spockz: You need to specify a type for the exception.
03:19:52 <edwardk> Spockz: you'd need handle (\(_ :: ErrorCall) -> putstrLn "something")   and  and some compiler flags to enable that
03:19:58 <shachaf> Turn on the extension ScopedTypeVariables and then type (\(_ :: ...) -> ...)
03:20:01 <Spockz> shachaf: yes so that's why I asked for the type for the undefined exception
03:20:10 <edwardk> ErrorCall
03:20:19 <edwardk> > error "foo"
03:20:20 <Spockz> edwardk: ah got it :)
03:20:21 <lambdabot>   *Exception: foo
03:20:23 <edwardk> > undefined
03:20:25 <lambdabot>   *Exception: Prelude.undefined
03:20:30 <mikeplus64> it's ugly but you can do Record{} & field .~ val & field2 .~ val2, which will simplify to just Record val val2 (after putting "undefined" in the suitable spots). or just construct the record normally, `nand`
03:20:34 <edwardk> error "Prelude.undefined"
03:20:41 <edwardk> > error "Prelude.undefined"
03:20:43 <lambdabot>   *Exception: Prelude.undefined
03:21:13 <shachaf> This will catch undefined, but not some other things like pattern match errors.
03:21:21 <shachaf> I recommend the Control.Exception documentation.
03:21:26 <shachaf> mikeplus64: Not for a strict type.
03:21:29 <adnap> Can I import  "bool foo(void)" function as IO Bool?
03:21:35 <shachaf> adnap: Try it!
03:21:47 <adnap> Okay
03:21:50 <shachaf> (The answer is yes, I think. But you should try it.)
03:22:08 <adnap> I am writing code now, but I haven't compiled anything
03:22:13 <Spockz> shachaf: that is exactly what I need
03:22:26 <johnw> shachaf: (you are correct)
03:22:26 <shachaf> (It might be that you need CInt or something else.)
03:22:57 <shachaf> @google haskell ffi bool
03:22:58 <edwardk> adnap: yes
03:22:59 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI
03:22:59 <lambdabot> Title: GHC/Using the FFI - HaskellWiki
03:23:10 <shachaf> That example uses Bool.
03:23:17 * `nand` can't help but feel that “try it” might not be the right approach when it comes to the C FFI because its weird semantics can come back to bite you in unexpected ways
03:23:34 <adnap> Also, based on http://www.haskell.org/haskellwiki/FFI_Introduction#Short_version, I'm not clear as to whether "{-# INCLUDE <foo.h> #-}" is needed to support all compilers that implement the FFI
03:23:40 <`nand`> though, admittedly, it's a fairly simple example
03:24:06 <mikeplus64> shachaf: yeah, for a strict type you have to type out undefined n times. i'm not particularly keen on doing emptyThing & foo .~ bar ... stuff, but after 'lensifying' the field names, the actual field names can get quite grotesque :(
03:24:06 <edwardk> adnap: basically ghc doesn't look at it
03:24:11 <edwardk> adnap: others might
03:24:12 <adnap> edwardk: I understand that
03:24:21 <adnap> What does the FFI spec say?
03:24:34 <adnap> I also have the same question about including the C header file name
03:25:08 <edwardk> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-100003
03:25:32 <adnap> I remember this document. It was difficult to understand last time I tried
03:25:48 <typoclass> adnap: just out of curiosity, is that "bool foo(void)" using some newish c standard? it isn't c++, is it?
03:26:01 <adnap> typoclass: No, why?
03:26:26 <typoclass> adnap: i thought traditional c represented booleans with the int type
03:26:43 <quicksilver> bool is a recent addition to C, yes.
03:26:48 <adnap> typoclass: You're right. I forgot about that. I haven't compiled the code yet
03:26:55 <quicksilver> C99
03:26:58 <quicksilver> only 13 years ago
03:27:22 <typoclass> quicksilver: thanks =) you understood me
03:28:12 <statusfailed> how do you pronounce "f a", where f is a functor? A functor of a? A functor over a?
03:28:15 <adnap> If I use gcc on "bool foo() { return 0; }\nint main() { foo(); return 0; }" I get "unknown type name `bool'"
03:28:29 <adnap> "bool foo() { return 0; }\nint main() {  foo(); return 0; }"
03:28:31 <adnap> bah
03:28:42 <adnap> the first "return 0" is supposed to be "return true;"
03:29:11 <adnap> I have gcc 4.6.2
03:29:17 <typoclass> quicksilver: considering that c was invented 800 years ago or some such, i'd say 14 years ago is indeed "newish" =)
03:29:20 <statusfailed> adnap: do you need --std=c99 ?
03:29:41 <adnap> statusfailed: Are you asking if I need it for the error to occur?
03:29:48 <adnap> statusfailed: If yes, then no
03:29:54 <statusfailed> I meant "does it fix the problem"
03:30:16 <adnap> statusfailed: It does not
03:30:25 <typoclass> statusfailed: "functor of a" sounds good to me, but i'm not an authority
03:30:30 <basdirks> statusfailed: f of a?
03:30:36 <statusfailed> adnap: #include <stdbool.h> ?
03:30:54 <adnap> statusfailed: Does that have some typedefs in it or something?
03:30:56 <shachaf> typoclass: "functor of a" sounds wrong.
03:31:04 <statusfailed> adnap: no idea, I just ended up on stack overflow :p
03:31:05 <shachaf> "f of a", sure.
03:31:06 <adnap> shachaf: Of course using typedefs would work
03:31:12 <shachaf> The fact that f is a Functor isn't that important.
03:31:31 <adnap> typedef int bool; #define true 1 #define false 0
03:31:43 <statusfailed> shachaf: I wanted to communicate that f was a functor though, so I will go with "functor of a"
03:32:15 <statusfailed> typoclass: sanity check passed theN :)
03:32:19 <adnap> statusfailed: I guess that's what is in stdbool.h. including it allows gcc to compile the program with no errors
03:32:36 <adnap> (without --std=c99)
03:32:50 <frerich> Hm, I have some code which crawls a set of hypertext documents (which tend to cross-reference each other quite a bit). I now had the idea to model this as some kind of cyclic graph 'CyclicGraph (IO Page)' or so (maybe that would make a good functor?) on which I could then implement all kinds of interesting functions like "count the number of links" or "get me all JavaScript files referenced from the pages" or
03:32:50 <frerich>  "Generate a site map". Does that make sense, or am I totally off here?
03:33:08 <basdirks> statusfailed: "f of a where f is a functor" or something sounds better to me
03:33:33 <frerich> In particular, I wonder if it would be possible to generate this graph lazily, so that I could start working on it as it is being constructed.
03:35:38 <shachaf> :-(
03:38:09 * frerich apologizes for killing the discussion and goes back to his hole :-}
03:38:55 <typoclass> frerich: i don't think you killed anything
03:38:57 * hackagebot BNFC 2.6.0.1 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.6.0.1 (GregoireDetrez)
03:40:16 <quicksilver> typoclass: it's really not, but the reason is seems new is that for many years after C99 came out, nobody used it.
03:41:19 <typoclass> quicksilver: any reason for that? or just generally being conservative?
03:41:49 <`ramses> what's the best way to convert a Double to Text? I guess pack . show is not very efficient
03:41:56 <shachaf> Well, Microsoft will probably never support C99 as such.
03:42:02 <bsrkaditya> Hi,
03:42:04 <shachaf> `ramses: Look at the Text documentation. There's a function.
03:42:04 <bsrkaditya>  I am trying to use @. Somehow I am getting "parse error on input `@'". What mistake am I making?
03:42:13 <shachaf> bsrkaditya: @ is syntax in Haskell.
03:42:21 <shachaf> You can't make it an operator.
03:42:23 <shachaf> See Hoogle.
03:42:47 <bsrkaditya> yeah, I am trying to use it as syntax, not an operator
03:42:54 <shachaf> Oh.
03:43:02 <bsrkaditya> f ((a:as)@as') ((b:bs)@bs')
03:43:02 <shachaf> Well, in that case, delete characters 4 and 6.
03:43:13 <shachaf> Oh, an example! That's helpful.
03:43:15 <shachaf> You're using it backwards.
03:43:19 <geri> does haskell support an async thread libarary?
03:43:21 <shachaf> a@(b:c)
03:43:34 <shachaf> What's an async thread library?
03:43:41 <bsrkaditya> shachaf: why does the order matter?
03:43:53 <Maxdamantus> It does :(
03:43:58 <shachaf> bsrkaditya: @ takes a name and a pattern, not two patterns.
03:44:00 <Maxdamantus> er, misread.
03:44:02 <shachaf> That's how it is.
03:44:09 <`ramses> shachaf: been doing that for a while now.. There are many modules
03:44:30 <shachaf> `ramses: Oh, I might be wrong.
03:44:33 <Maxdamantus> Is there a reason for it not taking two patterns?
03:44:45 <typoclass> bsrkaditya: heh, good question actually. it could be the other way round, but the syntax is defined like that. a name on the left, a pattern on the right
03:44:48 <shachaf> `ramses: Ah, try http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text-Lazy-Builder-RealFloat.html
03:44:54 <geri> does haskell support an async thread libarary?
03:44:56 <Maxdamantus> > _@(a, b) = (4, 5) in a + b
03:44:58 <lambdabot>   <hint>:1:2: parse error on input `@'
03:45:01 <Maxdamantus> > let _@(a, b) = (4, 5) in a + b
03:45:01 <shachaf> geri: 03:43 <shachaf> What's an async thread library?
03:45:03 <lambdabot>   <hint>:1:6: parse error on input `@'
03:45:44 <`ramses> shachaf: ah thanks :) Yet another module thus
03:46:51 <geri> shachaf, sorry asynchronous I/O
03:47:09 <typoclass> geri: haskell has lightweight, very efficient threads, if that's what you mean
03:47:22 <shachaf> geri: What does that mean?
03:47:41 <HugoDaniel> hi
03:47:51 <HugoDaniel> can i use the symbol ← as if it was <- in haskell ?
03:48:14 <HugoDaniel> i get this error: Not in scope: `←'
03:48:24 <shachaf> If you can do it, the extension UnicodeSyntax would enable it.
03:48:28 <shachaf> I don't know whether you can do it.
03:48:35 <geri> shachaf, event-based programming with callbacks
03:48:42 <zomg> HugoDaniel: yeah if you enable the unicodesyntax extension http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
03:48:49 <zomg> I think it should work then
03:48:51 <typoclass> geri: here's some information http://stackoverflow.com/questions/3011668/how-difficult-is-haskell-multi-threading the function "forkIO" might be a good starting point. it's what i use most of the time
03:48:57 <shachaf> geri: That's the opposite of threads.
03:49:05 <shachaf> geri: Read the FAQ:
03:49:06 <shachaf> @where faq
03:49:07 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:49:09 <geri> ok
03:49:10 <shachaf> It talks about this.
03:49:27 <zomg> While that unicode syntax thing is kind of neat I'm not sure if I'd really want to use that though... For one, I haven't got the slightest clue on how to do any of those characters on a keyboard :p
03:49:43 <HugoDaniel> oh thats cool
03:49:55 <HugoDaniel> now i just need to find a fast way to type it with the keyboard
03:49:56 <typoclass> zomg: if you're on linux, i'm kind of a fan of the compose key =)
03:50:02 <johnw> shachaf: yes, that works with UnicodeSyntax
03:50:05 <zomg> typoclass: the what key?
03:50:07 <johnw> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#unicode-syntax
03:50:08 <shachaf> johnw: I know.
03:50:22 <johnw> oh, I misread the sentence, sorry
03:50:24 <frerich> zomg: There are editor plugins which automatically turn e.g. "->" the right-arrow unicode symbol as you type.
03:50:27 <johnw> words :)
03:50:32 <shachaf> johnw: I didn't know it three minutes ago.
03:50:34 <zomg> frerich: yeah I figured that's probably what people would be using
03:50:41 <zomg> sorta like using an IME
03:51:11 <HugoDaniel> great :)
03:51:13 <HugoDaniel> it works in ghci now
03:51:25 <HugoDaniel> do you know how i can type the unicode chars faster ?
03:51:54 <shachaf> HugoDaniel: You should just use <-
03:51:55 <zomg> Well as mentioned by frerich you probably would want a plugin for your editor to convert into the symbols
03:51:56 <shachaf> It's better.
03:52:10 <HugoDaniel> ok
03:52:11 <HugoDaniel> :)
03:52:16 <zomg> but yeah tbh it feels mostly like a gimmick and not really something that's beneficial :D
03:52:36 <typoclass> zomg: it lets you do sequences like "hit compose key, hit <, hit <" to make « . you can designate a key to be the compose key (i'm using the "menu" key between space and right ctrl, it's useless to me otherwise). and there's a table how those 2- or 3-letter sequences map to funky chars
03:53:19 <HugoDaniel> ahah ∀ this is great :D
03:53:46 <shachaf> HugoDaniel: Please don't do it!
03:53:47 <geri> shachaf, asynchronous is non-blocking...
03:53:54 <shachaf> geri: Did you read the FAQ?
03:54:02 <geri> no yet i will!
03:54:06 <zomg> typoclass: ah I see, sounds a bit similar to the feature some keyboard layouts have where you first press one key, then another to produce some special char... forgot what the term for that was though
03:54:09 <shachaf> geri: http://www.haskell.org/haskellwiki/FAQ#Concurrency_and_parallelism
03:54:21 <geri> do you use it?
03:54:32 <shachaf> The FAQ? All the time.
03:54:44 <`nand`> zomg: dead keys
03:54:51 <HugoDaniel> shachaf: ok :)
03:54:56 <zomg> `nand`: ah yeah that was it :)
03:54:58 <HugoDaniel> i wont, but thanks for the info
03:55:02 <typoclass> geri: haskell is really pretty strong in that area. i bet you can find a good solution for what you're trying to do
03:55:05 * `nand` just goes with the old way of mapping ∀ as a regular key
03:55:15 <`nand`> none of this fancy compose key magic :(
03:55:43 <shachaf> `nand`: Maybe you should remap that key to a comma.
03:55:53 <typoclass> right, so i have nodeadkeys (i.e. the ´ key directly produces ´, instead of waiting), and the compose key enabled, so that "compose ´ a" produces á
03:56:04 <adnap> I can't find in http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-100003 where it clearly says the name of the C header is necessary when using import. It only shows examples where the C header is included.
03:56:09 <`nand`> I've been thinking about remapping ; to ,
03:56:13 <shachaf> typoclass: I press AltGr+a to produce á
03:56:24 <`nand`> I press AltGr+a to produce α
03:56:27 <johnw> shachaf: you use a keyboard in the US with AltGr?
03:56:42 <shachaf> typoclass: I always thought the "Gr" in AltGr stood for "German", since they seem popular in Germany. :-)
03:56:45 <shachaf> johnw: Yes.
03:56:47 <adnap> Also, it says nothing about "{-# INCLUDE <foo.h> #-}"
03:57:04 <typoclass> shachaf: =D
03:57:07 <adnap> By the way, I compiled my code and everything seems to work
03:57:31 <shachaf> ·-)
03:57:36 <typoclass> shachaf: related -- alt in german means "old"
03:58:07 <`nand`> I never realized that
03:58:54 * typoclass invents a keyboard that offers an Alt and a Neu key
03:59:21 <shachaf> Today I bound Super-L to →
03:59:43 <`nand`> I have that on AltGr+h, for ‘homomorphism’
03:59:47 <shachaf> Er.
03:59:53 <shachaf> Super-X to →
03:59:56 <shachaf> And Super-S to End
04:00:13 <`nand`> wait, do you mean the right arrow key?
04:00:16 <shachaf> Yes.
04:00:24 <`nand`> I see. I thought you meant the actual → character
04:00:27 <shachaf> Since those keys on my keyboard don't work ever since an incident involving hot chocolate.
04:00:43 <typoclass> shachaf: my layout has that bound to altgr-u and i and thereabouts ... ←↓→. never really used it
04:00:55 <shachaf> typoclass: No, the actual right arrow key.
04:01:20 <typoclass> shachaf: ctrl-e works as 'end' in most applications, terminal and such. ctrl-a is home
04:01:25 <typoclass> shachaf: oh i see
04:01:33 <shachaf> typoclass: Yes, I know.
04:01:38 <shachaf> Not so much in other applications.
04:01:42 <shachaf> For example a web browser.
04:01:49 <typoclass> shachaf: right
04:01:56 <shachaf> typoclass: →
04:02:15 * `nand` uses G and gg for “go to bottom” and “go to top” in his web browser
04:02:15 <merijn> typoclass: You sound like the kind of person who'd be very confused trying to use my terminal :p
04:02:18 <typoclass> shachaf: ⇒
04:02:31 <shachaf> `nand`: That doesn't work for editing a URL.
04:02:39 <shachaf> I bet hjkl don't work there ither.
04:02:49 <merijn> "set -o vi", baby :>
04:02:53 <`nand`> oh wow, you're right
04:03:11 <`nand`> that sounds like a reasonable feature request for pentadactyl, make the input box behave more like a terminal in terms of ^E, ^A, ^U etc.
04:03:24 <merijn> shachaf: ctrl-a/ctrl-e work for URL editing in chrome on OSX :>
04:03:33 <shachaf> Also I don't use Firefox.
04:03:35 <shachaf> merijn: Hooray.
04:03:35 <merijn> So does ctrl-k, apparently
04:03:50 <merijn> I think that might actually be just OSX that supports them for most text inputs, though
04:03:55 <typoclass> merijn: i used the vi mode for shells for a while, but didn't really like it in the end. i do use vim for everything, though
04:03:57 <shachaf> Yes, OS X does that.
04:04:07 <shachaf> i love monoids
04:04:09 <shachaf> they are so easy
04:04:11 <typoclass> merijn: right, osx has the ctrl-something bindings for everything
04:05:38 * typoclass recalls binding ^T to some kind of swap the characters left and right of the cursor, back when he had a mac several years ago
04:07:18 <quicksilver> yes, macs have some of the basic emacs-style keybindings available in text inputs
04:09:04 <johnw> and those keybindings can be extended for the whole UI
04:09:24 <johnw> I have C-a, C-e, C-t, etc., in all text boxes (except pure Carbon or Java apps)
04:10:21 <merijn> I wish it vi mode everywhere too :>
04:10:28 <merijn> s/it/it had
04:13:58 * hackagebot BNFC 2.6.0.2 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.6.0.2 (GregoireDetrez)
04:29:32 <mikeplus64> how can i send a ProcessHandle a signal other than SIGTERM?
04:30:37 <mroman> if you can get the processid of the process
04:30:57 <mroman> then you might be able to use System.Posix.Signal
04:31:28 <mikeplus64> @hoogle ProcessHandle -> ProcessID
04:31:28 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:31:28 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
04:31:28 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
04:31:32 <mikeplus64> :\
04:34:10 <mroman> mikeplus64: data ProcessHandle__ =OpenHandle PHANDLE
04:34:16 <mroman> and PHANDLE is PHANDLE = CPid
04:34:37 <mroman> but I assumse ProcessHandle__ is not exported
04:34:49 <mroman> so you can't extract PHANDLE out of it
04:35:07 <mroman> oh wait.
04:35:09 <typoclass> mikeplus64: check this message and the surrounding thread http://www.haskell.org/pipermail/haskell-cafe/2012-October/104009.html
04:35:10 <mroman> It is exported.
04:35:30 <typoclass> mikeplus64: ... and maybe it's easier if you used forkProcess from here http://hackage.haskell.org/packages/archive/unix/2.5.0.0/doc/html/System-Posix-Process.html
04:35:34 <mroman> #ifndef __HUGS__ ProcessHandle__(...)
04:35:59 <mroman> So yeah. You can extract the PHANDLE out of the MVar and you get the CPid of your handle ;)
04:36:13 <typoclass> ... and yes, it seems to be a weird omission in the api
04:36:20 <mikeplus64> alright
04:37:40 <mroman> It's probably not very portable to use my hacky suggestion as PHANDLE is defined different depening on the system ;D
04:37:49 <mroman> *depending
04:38:45 <mauke> signals aren't portable
04:40:18 <mroman> True.
04:40:58 <mauke> parseLine :: String -> Maybe (String, Maybe String)
04:41:01 * mauke squints
04:42:01 <mikeplus64> if only the for/map/traverse naming convention was the other way around... then you'd be able to do e.g. someFunction `for_` someValue
04:42:49 <mauke> dammit, haskell needs easier regexes
04:43:18 <capisce> mauke: easier?
04:43:59 * hackagebot BNFC 2.6.0.3 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.6.0.3 (GregoireDetrez)
04:44:41 <quicksilver> mauke: readProcess "perl -e ..."
04:44:42 <mauke> something that lets me write foo =~ /^# (CONFIG_\w+) is not set$/ without having to think about it
04:44:50 <mauke> readProcess isn't easy
04:45:05 <quicksilver> yes, it was joke. apart from not being funny.
04:47:14 <basdirks> if I have ie. type X = HashMap Text Text, and I want to specify how to render it, should I use a standalone function :: X -> String, or can I somehow instance it for Show without jumping through too many hoops?
04:47:27 <johncarey> I do a lot of read and show to serialise data in my program (I process data in stages and like to be able to interrupt phases). I'm finding read and show a bottleneck. I've found some libraries like cereal, but not much about them online. What do people normally do for serialisation?
04:48:36 <Botje> basdirks: if you have -XTypeSynonyms you can create a Show instance for X
04:48:36 <mroman> what's wrong with Text.Regex?
04:48:45 <mroman> provided you have the right Text.Regex
04:48:56 <mroman> that's a little bit confusing and sucky.
04:50:25 <mauke> mroman: does Text.Regex provide an implementation? if so, which one?
04:51:45 <mauke> also, what's the least stupid way to get a list of captured substrings?
04:52:01 <basdirks> Botje, ok thanks
04:52:24 <basdirks> TypeSynonymInstances right?
04:52:31 <Botje> basdirks: uh, yes :)
04:52:53 <basdirks> cheers
04:53:38 <`nand`> (=~) is so confusing
04:53:57 <shachaf> i love (=~)
04:54:00 <shachaf> it is so confusing
04:54:34 <`nand`> mauke: (=~) :: String -> String -> [[String]] -- one possible instantiation
04:54:46 <mauke> `nand`: but that will return all possible matches
04:54:49 <mauke> I only want the first one
04:54:59 <`nand`> head?
04:55:06 <mauke> did you mean: pattern matching
04:55:30 <mauke> also, how does it distinguish between an unmatched subgroup and an empty string?
04:55:51 <mauke> answer: it doesn't
04:55:55 <mauke> ಠ_ಠ
04:57:33 <shachaf> @ask Cale Could you import Data.List.Lens too?
04:57:33 <lambdabot> Consider it noted.
04:57:43 <`nand`> hrm
04:57:51 <mauke> also, fuck posix regexes
04:58:08 <`nand`> there's an instantiation (String, String, String, [String]) which goes (text before, matched text, text after, all captures); and only returns the first match
04:58:10 <`nand`> but w/e
04:58:28 <`nand`> there's probably some different convoluted way to do this
04:58:56 <edwardk> strippingSuffix would be … interesting, because you need to know when the suffix starts, and what do you do for infinite suffixes?
04:59:55 <johnw> mauke: I'm not sure if this helps, but have you seen: https://github.com/feuerbach/regex-applicative/wiki/Examples?
05:00:32 <mauke> johnw: no, but it looks horrible
05:00:43 <bsrkaditya> is there a function for (\x -> (f x, x))?
05:00:46 <johnw> then I agree, Haskell needs better regexs
05:00:53 * typoclass implements stripSuffix as something like reverse (stripPrefix (reverse ...)), just to get on edwardk's nerves
05:01:07 <shachaf> bsrkaditya: (f &&& id) if you import Control.Arrow is probably the best you can do.
05:01:09 <mauke> johnw: 33 lines for a "simple expression language"
05:01:21 <edwardk> typoclass: that might be a sane starting point
05:01:22 <bsrkaditya> shachaf : thanks!
05:02:04 <mauke> the "simple url parsing" one is not only not simple, it's also wrong
05:02:10 <fmap> johnw: that looks like parsec with confusing semantics
05:02:29 <mauke> it thinks "http://example.com" is not a url but "http:/// /// /" is
05:02:36 <johnw> fmap: i was starting to think so too
05:03:04 <bsrkaditya> is there a function for (\(a,b) -> (f a, f b))?
05:03:15 <bsrkaditya> fmap!
05:03:17 <johnw> edwardk: http://hackage.haskell.org/packages/archive/plumbers/latest/doc/html/Control-Plumbers.html#v:-42--62--60- might just give lens a run for the money
05:03:31 <johnw> ;)
05:03:36 <typoclass> bsrkaditya: in the lens library there is. i don't think the regular library has it
05:03:47 <shachaf> Gah.
05:03:56 <edwardk> whereas i'm working more towards rolling out a list of how far back to jump for common prefixes because you can compute that lazily as you walk forward over the suffix, and then maintaining a basic boyer moore search table you grow as you go.
05:03:58 <shachaf> bsrkaditya: f *** f, with Control.Arrow
05:04:05 <shachaf> bsrkaditya: With lens you can "over both".
05:04:14 <bsrkaditya> thanks shachaf
05:04:22 <edwardk> johnw: mgsloan autogenerates them
05:06:30 <quchen> I've got a Parsec-based parser that basically gives my String -> MyType. I now want to turn this into a Read instance, but I don't understand readsPrec. Why do I need the operator precedence argument? What's the reason 'read' isn't in the typeclass, but derived in terms of readsPrec?
05:07:07 <mauke> all of these match contexts are crazy
05:07:21 <shachaf> quchen: "read" is evil, and crashes if it doesn't match.
05:07:22 <mauke> a zero-length match is not the same as a match failure, dammit
05:07:31 <shachaf> You can't build composable parsers out of programs that crash.
05:07:47 <quchen> shachaf: You mean it throws?
05:07:57 <shachaf> I mean it crashes with "error".
05:08:14 <quchen> So it throws dirt then.
05:08:17 <shachaf> "throws" might imply you could catch it.
05:08:26 <quchen> You can't? Oh.
05:08:31 <shachaf> Not without evil.
05:08:34 <merijn> shachaf: But having read lets you easily use readMaybe
05:08:44 <quchen> Well, then readMaybe it is.
05:08:46 <shachaf> merijn: ?
05:08:53 <mauke> ooh, I see. monad abuse.
05:08:55 <shachaf> quchen: You can't define your parser in terms of readMaybe either.
05:09:33 <merijn> shachaf: Sure, his type is wrong for a parser using read, but I was just commenting on oyu saying "read is evil"
05:09:35 <quchen> ..? either (const Nothing) Just $ Parsec.parse parser "" EXPRESSION
05:09:41 <quchen> Looks like readMaybe ^
05:10:42 <shachaf> mauke: How do they conflate an empty match with a match failure?
05:10:52 <mauke> in two ways!
05:10:55 <latro`a> either (const Nothing) Just is hush :)
05:11:13 <mauke> *> "a" =~ ".(.)" :: (String, String, String, [String])
05:11:13 <mauke> ("a","","",[])
05:11:28 <mauke> *> "abcd" =~ ".|(.)" :: (String, String, String, [String])
05:11:28 <mauke> ("","a","bcd",[""])
05:11:39 <mauke> the first regex doesn't match at all
05:12:00 <mauke> yet it claims to have matched 0 characters at the end of the string
05:12:16 <mauke> the second regex does match but the capturing subgroup didn't
05:12:24 <mauke> yet I get [""]
05:13:15 <mauke>  | Just (_, _, _, [c]) <- s =~~ "^ (CONFIG_[[:word:]]+) is not set$" :: Maybe (String, String, String, [String])
05:13:22 <mauke> ^ this is ridiculous
05:13:33 <mauke> type annotation required because otherwise instance resolution is ambiguous
05:15:20 <msxx> if I make changes to code in a cabal library package I have to restart ghci for changes to take effect. is there a way  around that?
05:15:40 <otters> edwardk: kevin typechecks without any changes, what was the api change?
05:16:05 <typoclass> anyway, i'd probably write /^# (CONFIG_\w+) is not set$/ as something similar to f (stripSuffix "is not set" -> Just x) = words x !! 1, given a few imports and stuff
05:16:12 <shachaf> mauke: Someone should probably do a better regex library.
05:16:26 <shachaf> I bet it'd become a standard library very quickly if it was good.
05:16:55 <shachaf> Everyone wants regexps but almost no one likes this API.
05:17:04 <shachaf> (You should do it!)
05:17:12 <mauke> I don't even know where to start
05:17:24 <mauke> good regexes are hard
05:17:32 <quchen> latro`a: It's not hush if I want a quick and dirty way of reading a string.
05:17:40 <quchen> Such as a Read instance.
05:17:52 <mauke> typoclass: that doesn't check for "#" or "CONFIG_"
05:18:21 <shachaf> Well, start with "being correct" and "not having crazy overloadings".
05:18:44 <mauke> define "correct"
05:18:45 <typoclass> shachaf: i wonder if something "really functional, really haskellish" could be made for the area "i don't want to bring in parsec or similar big guns, but a simple 'case x of "lolcats" ->' is not enough either"
05:18:51 <latro`a> quchen, just that part is hush
05:19:05 <latro`a> (the hush from Control.Error.Util, to be specific)
05:19:13 <shachaf> mauke: Not having the problems you mentioned above would be a start.
05:19:17 <edwardk> the function changed from handled to handler iirc
05:19:20 <quchen> latro`a: OOOh, I see.
05:19:44 <mauke> shachaf: no, that's a negative goal. it's nothing to build towards
05:20:10 <shachaf> True.
05:21:09 <quchen> shachaf: Why would a Read instance be crazy overloading? I thought it would be just the right thing here.
05:21:19 <shachaf> mauke: Well, I fully approve of you putting effort toward that goal.
05:21:23 <shachaf> quchen: ?
05:21:35 <quchen> 14:18 < shachaf> Well, start with "being correct" and "not having crazy overloadings".
05:21:35 <shachaf> quchen: Oh, I was talking to mauke.
05:21:39 <quchen> Oh.
05:22:19 <quchen> Well then, that brings me back to what readsPrec actually does. Why does reading a value care about operator precedence?
05:22:39 <mauke> general outline so far: 1) no overloading  2) not posix  3) not a binding to a C library
05:22:41 <quchen> Or is it intended to be used on things like reading "1 + (2 + 3)"?
05:22:51 <merijn> quchen: What if you print complex structures?
05:22:51 <mSSM> I am not sure how to make my `data Foo a = Foo a a' an instance of Applicative: I have “instance Functor Foo where fmap f (Foo a b) = Foo (f a) (f b)” I was thinking that the right instance would be “instance Applicative Foo where pure f = Foo f f; ...” But now I am stuck with the definition of <*>
05:23:03 <shachaf> Why not binding to a C library?
05:23:12 <mauke> shachaf: more trouble than it's worth
05:23:14 <mSSM> I am not sure how the right definition of <*> for that should look like :(
05:23:43 <mauke> shachaf: C libraries tend to use C strings (fails on '\0', non-ascii characters)
05:23:49 <quchen> merijn: you mean read . show should be id?
05:23:50 <merijn> quchen: Example: "data Foo a = Foo a deriving (Read,Show)", now should "show (Foo (Foo 1))" print so that it can be read back in?
05:24:05 <shachaf> mSSM: Try defining blah :: Foo a -> Foo b -> Foo (a,b), if that's any better.
05:24:05 <quicksilver> mSSM: Foo f g <*> Foo x y = Foo (f x) (g y)
05:24:06 <msxx> can ghci detect cabal package changes without restarting?
05:24:15 <dcoutts> msxx: no, sorry
05:24:17 <merijn> quchen: Well, really anything where your datatype can have an argument that is more than one part)
05:24:30 <shachaf> mauke: OK, I don't know much about the state of regex C libraries.
05:25:00 <quchen> merijn: So it's important for potentially nested structures? In that case, as Parsec takes care of this for me, can I just insert some dummy value?
05:25:14 <mSSM> quicksilver: oh, ok; I thought I should define it in terms of fmpa.
05:25:15 <mSSM> fmap
05:25:23 <mauke> if you want something good, you basically need perl, which is not available as a freestanding library
05:25:25 <shachaf> mauke: And why not POSIX?
05:25:41 <mauke> shachaf: weird semantics, weird syntax
05:25:44 <shachaf> PCRE is not as PC as one might hope?
05:25:57 <merijn> quchen: How do you know parsec takes care of you for it?
05:26:05 <shachaf> It looks like it's a pretty different thing.
05:26:48 <quchen> merijn: Well, my parser parses an entire string to MyType. That should leave me with (result, nothing else left).
05:27:02 <quchen> result is the correctly parsed data structure.
05:27:11 <merijn> quchen: What if MyType is potentially nested?
05:27:25 <mauke> typoclass++  # reminding me of view patterns
05:27:31 <quchen> It *is* nested. But Parsec can do that too, can't it
05:27:42 <quchen> Actually, I would say my parser does
05:28:16 <shachaf> I would say "usable in a lens context", but probably not such a good idea. :-)
05:28:33 <quicksilver> mSSM: no.
05:28:46 <quicksilver> mSSM: if you could define it in terms of fmap you wouldn't need to define it iat all.
05:29:21 <typoclass> mauke: you're welcome =) i can't quite make it work in my editor at the moment, but i do think that way we could come up with something reasonably elegant. considering the original regex was basically looking for a prefix and a suffix.
05:29:33 <mauke> no, it wasn't
05:29:39 <mauke> it was validating the whole line
05:31:42 <mauke> parseLine ((=~ "^ (CONFIG_[[:word:]]+) is not set$") -> [_, c] : _) = Just (c, Nothing)
05:31:49 <mauke> parseLine ((=~ "^(CONFIG_[[:word:]]+)=(.*)$") -> [_, c, v] : _) = Just (c, Just v)
05:31:59 <mSSM> quicksilver: ok, makes sense
05:32:02 <mauke> oops, forgot the #
05:35:02 <Sagi> is there any recommended way to solve a cabal dependency mess? I installed say three packages and now I cannot install a newer version of one. Is there a virtualenv-like alternative?
05:35:28 <Sagi> I'm running ubuntu 12.{04,10}, the packages are xmonad, hledger, git-annex
05:35:46 <johnw> Sagi: i use cabal-dev to install "tools" like those three
05:35:47 <Sagi> I found ghc-pkg unregister, but it doesn't really help me much at all.
05:36:09 <johnw> that way I can update them later, and nothing I've installed in the meantime will interfere
05:36:17 <shachaf> Sagi: It generally works fine for me.
05:36:26 <shachaf> "cannot" isn't really an issue anyone can help you with, though.
05:36:32 <Sagi> ah, I reminder reading something about cabal-dev, before, it implements some kind of sandboxing, no?
05:36:36 <shachaf> There are some tools like that but most people don't use them.
05:36:37 <mSSM> So after I made Foo an instance of Functor and Applicative, how do I define (+) in terms of it? “(+) foo1 foo2 = pure (+) <*> foo1 <*> foo2”, or is there a better way?
05:36:39 <johnw> correct
05:36:54 <shachaf> (+) = liftA2 (+) might be better?
05:37:13 <Sagi> hmm, let's see if I can install cabal-dev in a satisfactory way,
05:37:17 <mSSM> shachaf: ah, lift! thanks
05:37:54 <johnw> Sagi: here's what I do: cd ~/src/tools/git-annex ; cabal-dev install git-annex.  And then I symlink the cabal-dev/bin/git-annex binary in my ~/bin
05:38:02 <Sagi> ah, funny, cabal tells me that installing cabal-dev breaks almost every other single package on the system
05:38:11 <johnw> yeah, cabal-dev has outdated dependencies
05:38:32 <Sagi> :-\
05:38:35 <johnw> i always have to install it first before anything else, because after you've installed more modern stuff, it's hard to install cabal-dev later
05:38:51 <johnw> Sagi: can you install cabal-dev as another user?  all you need is the binary
05:38:56 <Sagi> so, how do I ``uninstall'' to start fresh over again?
05:39:03 <johnw> rm -fr ~/.ghc ~/.cabal/lib/*
05:39:04 <Sagi> ah, that might be an option
05:39:23 <johnw> I "start over" pretty regularly, I'm sad to say
05:39:30 <mSSM> shachaf: What confuses me: the Applicative class is defined as `class (Functor f) => Applicative f where ...' -- i.e., `f' has to be a Functor before it can become an Applicative. Is that correct? Because hoogle says for `liftA': “Lift a function to actions. This function may be used as a value for fmap in a Functor instance.”
05:39:33 <johnw> in fact, now I have cabal-reset.sh and cabal-bootstrap.sh :(
05:39:36 <mSSM> What comes first? fmap or liftA ?
05:39:40 <dcoutts> Sagi: it's possible to do using something like -package-db=clear -package-db=global -package-db=./somethinglocal.conf
05:40:01 <dcoutts> Sagi: and perhaps also --prefix=
05:40:14 <shachaf> mSSM: If it's an Applicative, it also has to be a Functor.
05:40:18 <shachaf> There's no order in Haskell.
05:40:26 <dcoutts> Sagi: that's more or less what cabal-dev itself does, call cabal with a different install prefix and separate package dbs
05:40:58 <Sagi> ah, that's good to know, thank you
05:41:20 <mSSM> shachaf: yeah, but I cant say “fmap = liftA” can I?
05:41:20 <Sagi> I'll try the cabal-dev approach first
05:41:28 <shachaf> mSSM: Can you?
05:41:37 <shachaf> Try it!
05:41:37 <mSSM> shachaf: I think not, because I first have to define fmap.
05:41:49 <shachaf> > let a = 1 : b; b = 1 : a in a
05:41:51 <johnw> mSSM: I don't think that's what he means
05:41:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:41:56 <shachaf> Er.
05:41:58 <shachaf> > let a = 1 : b; b = 2 : a in a
05:42:00 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
05:42:41 <mSSM> johnw: I mean, I can use liftA instead of fmap if my type is an instance of Applicative. But I can't make `instance Functor Foo where fmap = liftA' ?!
05:43:23 <mSSM> shachaf: what's that magic! :D
05:43:45 <shachaf> mSSM: Did you try it or are you just saying that?
05:43:53 <shachaf> 05:40 <shachaf> There's no order in Haskell.
05:44:35 <mSSM> shachaf: Well, in GHCi I can't.
05:44:50 <johnw> mSSM: did you make Foo an Applicative?
05:45:43 <`nand`> mSSM: sure you can
05:46:23 <shachaf> `nand`: Can you?
05:46:50 <`nand`> instance Applicative Foo where { ... }; instance Functor Foo where fmap = liftA
05:47:02 <`nand`> you can also use multi-line inputs (:{ and :})
05:47:30 <frerich> Heh! Multi-line inputs!
05:47:33 * frerich learned something new
05:47:40 <shachaf> `nand`: Does that actually work?
05:47:41 <`nand`> they're a lot less useful than one would first think
05:47:43 <`nand`> shachaf: yes
05:47:50 <shachaf> Oh, you need {}
05:47:55 <mSSM> shachaf: ok, it works.
05:48:09 <mSSM> shachaf: I have dumped it into a file and had ghci +l it.
05:48:16 <`nand`> shachaf: yeah, otherwise the ; only separates declarations in the ‘where’
05:48:25 <mSSM> It's odd how that works.
05:48:25 <johnw> `nand`: how about :set +m
05:48:41 <shachaf> `nand`: Next up: Can you have two import statements separated by a ;?
05:48:48 <shachaf> I think you can't, which is what confused me here.
05:48:54 <mSSM> An Applicative has to be a Functor, but if I define Applicative it defines Functor for me.
05:49:03 <johnw> shachaf: try it!
05:49:05 <johnw> ;)
05:49:17 <shachaf> johnw: I have.
05:49:18 <`nand`> shachaf: I can't seem to
05:49:21 <`nand`> and that is indeed confusing
05:49:31 <mSSM> I suppose this is injective
05:49:34 <mSSM> Or something like that.
05:49:35 <shachaf> I guess it does support ;s in some contexts, but not others.
05:49:44 <`nand`> shachaf: works in a regular file
05:50:01 <`nand`> shachaf: that's probably a bug in GHCi, then. report it?
05:50:12 <shachaf> `nand`: Could you?
05:52:12 <`nand`> shachaf: I seem to require a username and password
05:52:25 <johnw> i can file the bug for you, `nand`
05:52:33 <`nand`> ah, there's a ‘Register’ form
05:52:43 <johnw> or you can register ;)
05:53:07 <mSSM> If I made something an instance of Applicative, do I also have to make it explicitly an instance of Functor?
05:53:15 <mSSM> Since all Applicatives are Functors, this seems redundant?
05:53:24 <shachaf> Yes, you have to.
05:53:30 <SamanthaD> hey everyone!
05:53:40 <`nand`> I uh, I don't seem to see the confirmation text on the registration form; and none of the requests or scripts on the site have been blocked
05:53:54 <`nand`> I also tried enabling CSS
05:54:04 <shachaf> hi SamanthaD
05:54:29 <`nand`> johnw: well if you want to file the bug I can procrastinate some more
05:54:51 <johnw> ok, i'll do it
05:55:01 <`nand`> thanks :)
05:55:38 <johnw> "Semicolon is not handled between imports at the ghci command prompt"; sounds good?
05:55:47 <SamanthaD> so... I've been thinking about how you could optimize ++ in the compiler but I wanted to make sure I understood cons correctly...
05:56:25 <Botje> go ahead
05:56:35 <`nand`> the thing about semicolons is that GHCi has some really inconsistent behavior here, it doesn't seem to treat declarations the same way as GHC proper does; eg. the special form “let { ... }” to introduce declarations can also not be separated by semicolons with something else
05:56:49 <shachaf> `nand`: I looked at the ghci source handling this once.
05:56:50 <SamanthaD> for a list "ABC" I have A which points to B, which points to C and if I wanted to D:"ABC" I would create a D which points to A. Now... if I had a function which took the original list it would have a pointer that pointed toward A and the new list would be accessed via a pointer to D. Right?
05:56:52 <shachaf> It's pretty ad-hoc.
05:56:58 <`nand`> on the other hand, instance declarations can; which are just as special-cased
05:57:19 <johnw> `nand`: http://hackage.haskell.org/trac/ghc/ticket/7625
05:57:29 <typoclass> we don't have a function like 'guard', but usable in this way, do we? "guard isAlpha =<< {... Maybe monad ...}"
05:57:37 <typoclass> "we" = the standard library
05:57:49 <`nand`> you can also have multiple data declarations, class declarations and instance declarations separated by smeicolons
05:58:10 <merijn> SamanthaD: Essentially, yes
05:58:31 <`nand`> while we're on the topic of GHCi, is it possible to splice a Q [Dec] at the top-level?
05:58:39 <SamanthaD> merijn: I sense an enormous "but" in there...
05:58:54 <shachaf> SamanthaD: It's actually pretty simple.
05:58:56 <`nand`> eg. say I want to makeLenses on some data type I defined in GHCi
05:59:00 <johnw> > Just 0 >>= \x -> guard (x==0)
05:59:01 <lambdabot>   Just ()
05:59:03 <shachaf> It's even simpler if you don't bother thinking about pointers.
05:59:05 <johnw> > Just 0 >>= \x -> guard (x==1)
05:59:07 <lambdabot>   Nothing
05:59:13 <`nand`> $(makeLenses ''Foo) -- just wants to ‘show’ it
05:59:34 <SamanthaD> shachaf: I need to think about pointers for this. I have an awesome data structure that conses equally well on the front and back but it requires pointer fiddling.
05:59:58 <shachaf> SamanthaD: Does it work immutably?
06:00:01 <merijn> SamanthaD: There's no but, haskell doesn't really have a pointer notion, but it matches close enough
06:00:02 <SamanthaD> shachaf: and when I say data structure I'm talking about on the assembler/C layer of abstraction. On the Haskell side it's just a list.
06:00:03 <shachaf> That's the trick here.
06:00:15 <typoclass> johnw: right, that's what i thought. i'll take that as a no
06:00:31 <typoclass> anyway, it's not difficult to write
06:00:34 <SamanthaD> shachaf: Yes and no. It preserves its ancestor but it does so destructively (under the hood, of course)
06:00:34 <shachaf> SamanthaD: You can come up with persistent data structures that let you both cons and snoc efficiently.
06:00:37 <johnw> typoclass: well, just use guard . isAlpha
06:00:58 <`nand`> SamanthaD: do you mean it requires pointer arithmetic?
06:00:59 <shachaf> SamanthaD: Sounds like you're in for more trouble than you think.
06:01:06 <shachaf> But go ahead and work on it. :-)
06:01:23 <typoclass> johnw: yeah but that discards the value and gives Just (). i meant something that lets it pass through (i.e. Just 0)
06:01:33 <merijn> ++ is fusable, right?
06:01:39 <typoclass> ... and nvm, found it, mfilter. thanks.
06:02:06 <`nand`> merijn: I thought it isn't
06:02:51 <SamanthaD> `nand` no... but it requires destructively altering pointers that would be invisible to the layer accessible to the haskell programmer.
06:03:07 <SamanthaD> anyway... here's how it works...
06:03:13 <`nand`> as in, (a ++ b) ++ c -- constructs and immediately unwraps a new cons cell for each element in ‘a’ during the evaluation of ‘a++b’
06:03:21 <SamanthaD> (sort of, I'm leaving out details because they're complex but to just give you a taste...)
06:03:23 * shachaf is too tired to think about data structures.
06:03:25 <`nand`> but I'm not too sure about these things
06:03:48 <shachaf> (But apparently not too tired to solve edwardk's algorithm problems!)
06:04:03 <`nand`> edwardk's algorithm problems are best solved when tired, or drunk
06:04:27 <johnw> typoclass: ah, thanks for reminding me about mfilter
06:04:32 <merijn> `nand`: ++ is a "good producer" i.e. when combined with a "good consumer" it will fuse
06:04:55 <merijn> And ++ is also a good consumer on its first argument
06:05:43 <merijn> `nand`: So it looks like "(a ++ b) ++ c" should actually be fused nicely
06:05:50 <skuggi> merijn: how do you know if soemthing is a good consumer/produver?
06:05:59 <skuggi> producer*
06:06:08 <merijn> skuggi: Well, there's a list of standard ones in the manual: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html
06:06:14 <`nand`> might as well whip out criterion and benchmark foldr (++) vs foldl (++)
06:06:25 <SamanthaD> Anyway, imagine a binary tree where the right-hand always points to the next element in our "list". Now, if we have a list "ABC" and we want to "ABC":D what we do is we destructively alter C's left-hand to point to a copy of C (which has a third branch which points towards A) and who's right hand points toward D. The pointer which points to this new list points toward C' (the copy of C) which contains the instruction to follow t
06:06:26 <SamanthaD> he left-hand once when you reach C instead of going to the right-hand.
06:06:39 <typoclass> johnw: no kidding, after i had sent my question, i dimly remembered a conversation from years ago about exactly this. it came back bit by bit. i think i asked, someone said "not really, i've written that function several times myself", someone mentioned mfilter, and kmc said "ooh nice catch" =)
06:07:11 <SamanthaD> By the way, destructive updates to the left-hand can ONLY be in the form of changing it from nil to something else.
06:07:20 <merijn> skuggi: Might also be a nice question for stackoverflow?
06:07:39 <SamanthaD> Once the left hand points to something other than nil you simply have the copy say "go twice left" or "go three times left" as appropriate.
06:07:40 <typoclass> it's like a senior home. we have the same conversations in the same way with only a dim feeling of deja vu =)
06:07:52 <johnw> typoclass: :)
06:08:23 <SamanthaD> Oh yeah... and if you happen to snoc something at the end of D, it's "home" pointer points to C' instead of A so you can push the appropriate instructions onto your traversing stack.
06:08:38 <SamanthaD> once you get back to A you just start popping instructions to traverse the list.
06:08:48 <SamanthaD> eer... tree
06:09:00 * hackagebot language-guess 0.1.1 - Guess at which language a text is written in using  trigrams.  http://hackage.haskell.org/package/language-guess-0.1.1 (ChristianRoedliAmble)
06:09:49 <SamanthaD> By the way... I'm pretty sure you can implement it without actually having... OH MY GOD I just realized you can do it without ANY destructive stuff!
06:09:52 <SamanthaD> hmm...
06:10:03 <SamanthaD> well, it IS destructive on a conceptual scale...
06:10:52 <SamanthaD> point is, you really don't need any left-hands at all. You just need to have a pointer in the C' thingies ect... that point to the points in which you need to break from the list. You just stuff those pointers into your stack as you traverse back to A and then start poppin!
06:11:50 <SamanthaD> and it's lazy! OH MY GOD! O.O
06:12:07 <SamanthaD> at this point I'm either a crackpot or I'm on to something really awesome >.>
06:12:18 <johnw> SamanthaD: how does it compare to say, a finger tree?
06:12:26 <`nand`> implement it in haskell, share on hpaste
06:12:38 <`nand`> (because I have no idea about any of what you just said without seeing the code)
06:13:13 <shachaf> SamanthaD: I have no idea what you said but you should do it!
06:13:26 <SamanthaD> `nand` will implement soon, definitely! I'm starting to slowly develop a figureing about how you would do it in haskell but I'm not really sure how you would do it EFFICIENTLY in haskell. It's more of a compiler optimization than anything.
06:13:42 <`nand`> start a GHC branch
06:13:52 <shachaf> Maybe I'd understand better if you used 27 8×10 color glossy pictures with circles and arrows and a paragraph on the back of each one explaining what each one was to be used as evidence against us.
06:14:33 <`nand`> http://i.imgur.com/rxec4.png
06:14:36 <`nand`> like this?
06:14:37 <SamanthaD> johnw: It basically IS a finger tree except that you can destructively edit parts of it (under the hood)
06:14:44 <johnw> ah
06:15:00 <shachaf> `nand`: Exactly not like that.
06:15:11 <SamanthaD> johnw: except now that I think of it you don't actually need to destroy anything. You just need some way to directly point at memory registers (because otherwise it's actually quite pointless... I think... maybe)
06:15:39 <SamanthaD> shachaf: I have sharpie-on-cardboard-box diagrams. Slightly less professional but they do the trick!
06:15:40 <shachaf> i love memory registers
06:15:47 <johnw> dont...
06:16:19 <johnw> I love silver paint sharpies
06:16:30 <shachaf> love is the only weapon that can defeat the tyrannical rule of johnw
06:16:45 <johnw> it is true, i am defeated
06:17:26 <shachaf> SamanthaD: That works too!
06:17:39 <shachaf> (Doesn't help me much, but still.)
06:19:52 <SamanthaD> awesome, you guys are great!
06:20:24 <shachaf> i love monoids
06:20:29 <SamanthaD> I'm going to stew this idea in my head for a while and then start scribbling more and then I'll write it up in a paper unless I find out that theres some serious flaw in my logic...
06:21:35 <shachaf> I recommend going to sleep. Unless you've already woken up.
06:22:16 <`nand`> if there's a flaw, trying to implement it will most likely reveal it
06:22:54 <SamanthaD> shachaf: I probably won't be able to sleep for a while. I'm far too excited.
06:23:27 <burbul> what's the precedence of (++)? can;t find it in Prelude or Data.List...
06:23:29 * typoclass lols at nand's picture
06:23:34 <basdirks> SamanthaD: would you come over to explain to my girlfriend how something like that could be awesome please?
06:23:36 <burbul> gah, ignore me
06:23:51 <typoclass> ... i wonder what that is ...
06:23:55 <SamanthaD> `nand` I'm thinking that the best way to implement this as a proof-of-concept is as C code since it really is all about pointers
06:24:20 <SamanthaD> basdirks: How it would be awesome to both cons and concatinate as an O(1) operation, you mean?
06:24:34 <basdirks> oh sure
06:25:37 <SamanthaD> basdirks: Well... for one thing concat wouldn't be an O(n) operation where n is the length of the list-to-be-made-into-the-head
06:37:20 <merijn> burbul: Unspecified precedence == infixl 9
06:37:49 <merijn> burbul: Although it *is* specified for (++), which is infixr 5, apparently
06:38:07 <merijn> burbul: Quick answer is run ":info (++)" in ghci
06:38:43 <Aman_> hi
06:40:07 <burbul> merijn -- thanks for the ghci hinf
06:40:11 <burbul> merijn -- thanks for the ghci *hint
06:40:24 <burbul> I was looking at the place of declaration of the operator rather than at the start of the file
06:41:56 <burbul> hlint keeps telling me to replace liftM with fmap, but
06:42:06 <burbul> When I do I get  Could not deduce (Functor m) arising from a use of ...     from the context (Monad m)
06:42:43 <shachaf> hlint is a bit overzealous sometimes.
06:42:51 <shachaf> If you just have a Monad constraint, liftM is fine.
06:43:34 <burbul> Thank you
06:43:46 <burbul> It also suggests replacing ++ with mappend, which strikes me as rather unreadable...
06:45:04 <shachaf> <> is a more popular name for mappend
06:45:10 <shachaf> But ++ is fine.
06:45:52 <burbul> thanks again
06:49:27 <merijn> heh, hlint suggest mappend over ++? >.<
06:49:37 <merijn> burbul: btw, you can tweak hlint's warnings, I think
06:50:07 <elliott> burbul: where does it suggest that?
06:52:02 <SamanthaD> Yeah... I can definitely code my data structure in Haskell as a library but it really needs to be written in C or assembler to truly shine, unfortunately (so far... still mulling it)
06:53:10 <SamanthaD> The problem with the data structure is that the time and space required to traverse the list ends up being a function of the number of concatinates used to build the list.
06:54:01 * hackagebot creatur 2.0.10 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-2.0.10 (AmyDeBuitleir)
06:54:24 <SamanthaD> actually... how performance taxing is it to transverse a list backwards?
06:55:06 <shachaf> What does it mean to do that?
06:55:40 <SamanthaD> in other words if I have a list "ABC" and I want to read it "CBA"
06:56:11 <Botje> eh, just use reverse and be done with it
06:56:53 <SamanthaD> shachaf: I remember there's a datastructure that is basically a list in reverse. It allows for easy snoc but no cons. My idea would be to use my structure to tie a normal list on the head and one of those thingies in the back
06:56:53 <elemir> Guys, I want to write non-empty list tries. Which library is good for using as basis?
06:57:11 <shachaf> SamanthaD: A list in reverse is called a "list".
06:57:23 <shachaf> You reverse your thinking, instead of changing the data structure. :-)
06:57:44 <SamanthaD> shachaf: Right... but see, in this algorithm there would be some parts of the list that may be stored in memory "backwards"
06:58:42 <SamanthaD> shachaf: it's important because my structure increases in time and space requirements when traversing as a function of the number of concatinations used to build it... which can get nasty quickly
06:59:22 <shachaf> I'm not really sure how your structure goes. :·)
07:01:27 <SamanthaD> shachaf: Say I want to "ABC" ++ "DE" what my structure does is create a list "DE" with a special D that points back to A. The pointer that points to "ABCDE" actually points to the special D and when you go to transverse "ABCDE" you go to the D which throws its memory addy into the stack and then goes on to A. You then transverse it as normal till you reach nil at which point you pop the stack. You continue to transverse the list
07:01:27 <SamanthaD> s and pop-at-nil until the stack is empty.
07:01:57 <SamanthaD> shachaf: the problem is that if you then take "ABCDE" ++ "F" you have a special F that points to the special D (so you can get two things in the stack which you need)
07:02:44 <absence> SamanthaD: sounds like a DList
07:02:53 <SamanthaD> absense: I'll have to look this up...
07:02:56 <johnw> absence: I was thinking that too
07:03:15 <hpaste> HH pasted “Shape.hs” at http://hpaste.org/81266
07:03:29 <elliott> saml: Transverse?
07:03:36 <elliott> Er, SamanthaD:
07:03:43 <saml> yes
07:03:51 <SamanthaD> elliott: sorry, traverse ;)
07:04:12 <HH> I have a real newbie question on types if someone has a minute
07:04:26 <Botje> We have 1440 every day.
07:04:31 <HH> :)
07:04:32 <SamanthaD> I thought DLists were basically just lists that were implemented backwards though...
07:04:56 <HH> I have the code pasted to http://hpaste.org/81266
07:05:15 <absence> SamanthaD: not at all, they're function composition instead of list concatenation
07:05:46 <aristid> johnw: pinging me in this noisy channel is a little problematic :P
07:05:56 <johnw> aristid: but you always answer
07:05:57 <merijn> HH: Quick remark, you can export "Shape (..)" to export all constructors of Shape
07:05:58 <absence> SamanthaD: instead of "ABC" ++ "DE" you get ("ABC" ++) . ("DE" ++), so appending is O(1)
07:06:01 <SamanthaD> absense: I went and loaded the source on my screen. I'm going to have to spend some time really grokking it and if my idea is different I'll write up a thingy.
07:06:01 <HH> If I have a shape that was created as a Polygon, how do I access an individual vertex?
07:06:10 <aristid> johnw: i had to grep my logfile.
07:06:18 <HH> merijn - ok
07:06:19 <johnw> aristid: i need to say what I'm pinging about, because now I don't know :(
07:06:35 <HH> A Polygon is a [Vertex] -> Shape
07:06:42 <aristid> johnw: something related to your generalized rest API thingie perhaps?
07:06:46 <merijn> HH: You can just pattern match
07:06:53 <absence> SamanthaD: in the end you "traverse" (i.e. call) the whole thing to convert it to a list, which costs O(n)
07:07:01 <johnw> aristid: no, it's wasn't that, it was something else that I discovered you were part of
07:07:14 <SamanthaD> absense: OH! I see! That's clever! How about doing a normal cons to it?
07:07:22 <aristid> johnw: http-types?
07:07:32 <johnw> aristid: it'll come to me
07:07:37 <HH> merijn: OK, lemme think on that for a minute. Thanks!
07:07:43 <aristid> johnw: ok :P
07:07:45 <merijn> HH: i.e. if you write a function "foo (Polygon vs) = ..." then in the ... part vs will be the vertices of Polygon
07:08:03 <absence> SamanthaD: you can prepend a string just like appending (just switch the order), but you can't prepend a character to a string like with cons
07:08:05 <HH> merijn: OK, got it. Thanks!
07:08:20 <johnw> `nand`: wow, that ghci bug is already fixed
07:08:34 <johnw> parcs: nice :)
07:08:39 <merijn> HH: Similar how "Maybe Int" lets you write stuff by doing "foo Nothing = ...; foo (Just a) = {- something using a -}"
07:09:14 <shachaf> SamanthaD: DLists are pretty different from lists in terms of what you can do with them.
07:09:39 <shachaf> In one sense "append is O(1)", but that doesn't really tell you everything.
07:10:36 <HH> merijn: Is it possible to "cast" a Polygon to [Vertex] if you're given a Polygon?
07:10:48 <parcs> johnw: :)
07:11:19 <mSSM> Profiling tells me that my program spends only about 20% of its time doing useful stuff. Now I wonder how I can make it perform faster ... are there strict versions of replicateM and scanl ?
07:11:20 <merijn> HH: You can't be given "a polygon", Polygon is a constructor of Shape, so any functions you write will need to be type "Shape -> ?"
07:11:54 <parcs> it was a simple fix and i have some familiarity with the ghci component of ghc. i couldn't resist :P
07:11:57 <HH> merijn: oh, right, Polygon is a type constructor, right?
07:12:09 <merijn> HH: So you'd have to write a "Shape -> [Vertex]" function, but then what do you return for Ellipse/Triangle?
07:12:09 <SamanthaD> absence: I guess you're right though, my thing is pretty much a DList. Oh well, at least I can go to sleep feeling proud that I figured it out.
07:12:38 <HH> merijn: Ok, that makes sense.
07:12:40 <shachaf> SamanthaD: Your think didn't sound like a DList exactly.
07:12:42 <shachaf> But maybe.
07:12:45 <merijn> HH: Alternatively, you could write "Shape -> Maybe [Vertex]" and just do "convert (Polygon vs) = Just vs; convert _ = Nothing"
07:12:49 <shachaf> I didn't understand it so I don't know. :-)
07:12:57 <S11001001> Is there a name for types of kind * -> *?
07:13:07 <johnw> SamanthaD: the creative rush you experienced alone is pretty enviable :)
07:13:34 <SamanthaD> johnw: thank you!
07:13:39 <frerich> S11001001 : Maybe "unary type constructor"?
07:13:46 <HH> merijn: So that's why you'd really need to do a pattern match, to really support that it's polymorphic.
07:13:47 <absence> SamanthaD: the best kind of sleep ;)
07:14:05 <merijn> HH: This is not an example of polymorphism, though
07:14:21 <johnw> frerich: I think it's just "type constructor".  A type of kind * -> * -> * is a type constructor that yields a type constructor.
07:14:24 <shachaf> frerich: Well, (* -> *) -> * is also a "unary type constructor"
07:14:33 <HH> :merijn - oh, right - ok.
07:14:34 <shachaf> So these names aren't right.
07:14:46 <merijn> HH: You just have defined Shape to be a type that consists of 4 different data constructors, so any function working on Shape should work on all of them
07:15:06 <HH> :merijn Got it.
07:15:18 <SamanthaD> absence: My structure is slightly different from a DList though in its implementation. I'm going to investigate further whether or not it has any advantaged to a DList. I know my structure can be easily optimized via a process similar to garbage collection though so maybe that's an avenue for improvement.
07:15:36 <HH> merijn: Thank you very much for your help!
07:15:48 <merijn> HH: You could write a function that only accepts Polygon, but then if you ever use it on an Ellipse by accident your program will crash
07:16:07 <HH> merijn: Right, makes sense.
07:16:12 <merijn> HH: Without more ideas of what you're doing, I'd say that "Shape -> Maybe [Vertex]" would be the nicest approach
07:16:17 <S11001001> frerich, shachaf: hmm. thanks
07:16:55 <HH> merijn: OK. I'm running through the exercises in the "Haskell School of Expression" book.
07:16:57 <shachaf> SamanthaD: A DList is exclusively for building up a structure.
07:17:01 <HH> (Total newbie.)
07:17:09 <shachaf> SamanthaD: Access to any part of it, even just the head, is potentially O(n).
07:17:10 <SamanthaD> absence: Basically, though, they're the same thing. DLists just use lazy evaluation to do their work while my structure relies on traversing a stack. Basically, DList is a Haskell thing and my thing is more of a C/Assembler thing (which is what I designed it as to begin with. It's supposed to be a compiler optimization).
07:17:31 <merijn> HH: Ah, I don't know that one
07:17:44 <SamanthaD> shachaf: Ooooh... Hmm... improvements! I'll know more once I've fully understood the DList library.
07:18:01 <shachaf> SamanthaD: You don't need the library. The idea of DList is very simple.
07:18:20 <shachaf> Instead of [a,b,c], you use the function (\z -> a:b:c:z)
07:18:29 <shachaf> Instead of [], you use the function (\z -> z)
07:18:57 <shachaf> Then instead of (++), you use the function (\f g z -> f (g z)) -- i.e. composition
07:19:33 <shachaf> There are various interesting things that come out of this, but the general idea is just that.
07:19:49 <SamanthaD> shachaf: Yeah... See, my structure has the same access time problems in that you need to traverse a list consisting of all the heads of the component lists back to the "beginning of the list" in order to build up your stack so you have something to follow when you hit a nil.
07:20:11 <shachaf> OK, then maybe your thing winds up being similar to a DList.
07:20:17 <shachaf> I don't know. :-)
07:20:22 <SamanthaD> shachaf: Course... that process can be trivially "garbage collected"
07:20:53 <shachaf> Well, you can flatten out a DList, too.
07:21:10 <shachaf> At potentially O(n) cost.
07:21:19 <SamanthaD> shachaf: in that you can go ahead and say "this is the maximum number of component lists" and start building lists the old fashioned way as you get too many.
07:22:02 * shachaf is too tired to think about anything.
07:22:33 <frerich> 15:03: * shachaf is too tired to think about data structures.
07:22:42 <frerich> Doesn't keep you from doing it, it seems.
07:22:49 <SamanthaD> shachaf: Well, one of the ideas I had was that this structure could be a normal linked-list that is updated destructively PLUS my structure. The mutable linked-list would have a "serial number" that could be checked by a function to make sure it's the right number. If it is, everything is speedy and if not you can rebuild it the "old fashioned" way.
07:22:55 <shachaf> frerich: Did it look like I was thinking?
07:22:58 <shachaf> Maybe I'm good at faking that.
07:23:33 <shachaf> i love monoids
07:23:35 <shachaf> they are so easy
07:23:38 <mSSM> I have this chunk of code: “sum . map f . scanl (+) 0 <$> ( replicateM n1 $ sum <$> ( replicateM n2 (random gen) )”; this code doesn't perform very well: profiling tells me that a huge [] is constructed. Can I do something with strictness here?
07:24:02 * hackagebot creatur 2.0.11 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-2.0.11 (AmyDeBuitleir)
07:24:35 <frerich> shachaf: I seem to recall that you're about nine hours behind, so it ought to be something like 5:23am for you now - makes me wonder what you do during the daytime. :-}
07:24:39 <johnw> I wonder what it looks like when you builder a zipper out of a DList...  would it be a new function that accepts the missing element as an argument?
07:25:05 <SamanthaD> johnw: you hurt my brain ;_;
07:25:09 <johnw> i'll have to play with that and find out
07:26:13 <mauke> johnw: ooh, I think I understand (half of) generic zippers now
07:26:17 <mauke> thanks!
07:26:42 <SamanthaD> Hmm... maybe I should go back to mulling my original plan which was different and apparently too complex to describe in half-lucid IRC ramblings >.>
07:26:44 <johnw> mauke: when you get other half, please do tell :)
07:27:24 <SamanthaD> The thingy people said were like DLists were actually an optimization I came up with (at the expense of some functionality)
07:28:07 <shachaf> mauke: Do you understand Control.Lens.Zipper?
07:28:13 * shachaf doesn't know what a generic zipper is.
07:28:17 <mauke> shachaf: no
07:29:02 * hackagebot gray-extended 1.2 - Gray encoding schemes  http://hackage.haskell.org/package/gray-extended-1.2 (AmyDeBuitleir)
07:29:24 <johnw> mauke: is a generic zipper about data type derivatives?
07:29:34 <mauke> I don't even know, man
07:29:46 <mauke> @where oleg
07:29:46 <lambdabot> http://okmij.org/ftp/
07:29:51 <johnw> i.e.: http://strictlypositive.org/CJ.pdf
07:30:22 <quicksilver> zippers in general are about data type derivatives
07:30:53 <quicksilver> a 'generic' zipper is an attempt to encode in a programming language (e.g. haskell) the general procedure of forming a derivative of an arbitrary type
07:31:02 <quicksilver> so that you can have a zipper for anything (everything)
07:31:29 <johnw> quicksilver: that's such a neat idea.  http://okmij.org/ftp/continuations/zipper.html talks about the same
07:31:33 <SamanthaD> Back in my day we only had zippers on our PANTS!
07:31:35 <shachaf> > zipper ("hello","world") & downward _1 & fromWithin traverse & set focus 'J' & rightmost & set focus 'y' & rezip
07:31:37 <lambdabot>   ("Jelly","world")
07:31:39 <SamanthaD> ... damn whippersnappers
07:32:34 <johnw> shachaf: yeah, & reads really nicely in those kinds of expressions
07:32:53 <johnw> the idea of "and ..." is perfect
07:33:32 <shachaf> I don't like that meaning of &
07:33:34 <shachaf> But whatever.
07:33:37 <johnw> hahah
07:33:41 <johnw> but it is so easy!
07:33:43 <shachaf> It should be composition.
07:34:16 <quicksilver> you could have made every & except the first one into <<< then?
07:34:28 <shachaf> >>>, I think.
07:34:33 <shachaf> Except for fixity or something.
07:34:37 <quicksilver> ah
07:34:44 <shachaf> & is just flip $
07:34:47 <quicksilver> I know.
07:34:53 <quicksilver> but what is _1 ?
07:35:00 <shachaf> A lens for the first element of a tuple.
07:35:06 <quicksilver> ah
07:35:16 <shachaf> Are generic zippers related to the Zipper type in lens?
07:35:21 <shachaf> Probably not.
07:35:26 * quicksilver doesn't know.
07:39:13 <`nand`> you should have written (rezip (set focus 'y' (rightmost (set focus 'J' (fromWithin traverse (downward _1 (zipper ("hello","world")))))))))))))))), clearly
07:39:48 <shachaf> mauke: You should learn about lens!
07:39:51 <shachaf> It's pretty great.
07:40:03 <elliott> shachaf: lens' zipper is related to oleg's final zipper thing
07:40:06 <elliott> they both use traversals
07:40:33 <shachaf> I gathered that much from reading the title.
07:43:49 <linux-user> /help
07:48:59 <mSSM> Could somebody have a look at line 189 and suggest how I can make that code perform faster? http://hpaste.org/81267 Profiling tells me that a huge [] is built up, and I suppose that line is the culprit.
07:49:59 <mSSM> One problem I see: Does `scanl' only start its work after both `replicateM' calls are finished?
07:50:11 <mauke> shachaf: how do I start using lens?
07:51:09 <elliott> mauke: first edwardk gives you commit rights
07:51:30 <mauke> hah
07:51:47 <shachaf> That's how it works. :-(
07:52:16 <favonia> Hi all, I'm wondering why lambdabot is (or becomes) so picky about the Unicode characters. It keeps saying "mueval: recoverEncode: invalid argument (invalid character)". Is this for security?
07:52:28 <shachaf> favonia: No, it's a bug.
07:52:39 <shachaf> It didn't use to have it. Then we upgraded GHC. Now it does.
07:52:53 <shachaf> No one cares enough and/or is foolish enough to try to fix it.
07:52:56 <typoclass> favonia: i think it broke at some point (accidentally). it wasn't choking on unicode in the past
07:53:25 <Taneb> mauke, I'd watch edwardk's video from the NYC thing. It's slightly out of date (hard not to be with lens), but it's good
07:53:39 <mauke> Taneb: I think I've watched it
07:53:53 <shachaf> I think mauke was asking one of his maukey questions.
07:54:27 <shachaf> Or maybe it was an actual question. It's hard to tell.
07:54:36 <shachaf> The answer is that you're already using lens, you just don't know it yet.
07:54:38 <mauke> all of my questions are actual questions
07:54:50 <Taneb> Lenses are kind of like Monads
07:54:53 <favonia> shachaf: typoclass: OK, thanks.
07:55:09 <Taneb> You could have invented lenses!
07:55:39 <srhb> Taneb: "You could have invented lenses, a guide to recreational cannabis cultivation"
07:56:09 <osfameron> the Assyrians invented them
07:56:29 <quicksilver> the best way to start using lenses is to read this paradoxically tagged blog post
07:56:32 <quicksilver> http://twanvl.nl/blog/haskell/overloading-functional-references
07:56:48 <`nand`> I love lenses
07:56:52 <quicksilver> paradoxically tagged because it never uses the word lens, as that word had not been coined in 2007.
07:56:56 <quicksilver> but it's still tagged lens.
07:57:12 <quicksilver> which just goes to show that twanvl had brief glimpses of the future.
07:57:27 <osfameron> oh oh oh, is a lens a generalisation of a zipper?
07:57:35 <quicksilver> no.
07:57:50 <osfameron> oh
07:58:07 <quicksilver> a lens is something like a degenerate case of a zipper which can't move.
07:58:15 <quicksilver> because it's fixed focus.
07:58:24 <shachaf> quicksilver: Really? That post seems confusing from that perspective.
07:58:38 <quicksilver> but it's more useful than that description makes it sound.
07:58:40 <shachaf> It's all about an overloading which is mostly irrelevant since no one really uses it nowadays.
07:58:45 <osfameron> quicksilver: cool, reading post now
07:58:55 <shachaf> I guess you can read it without the last section.
07:59:28 <quicksilver> shachaf: well I view the last section as "you could even use a type class for this if you want, but the problems with that are pretty obvious"
07:59:51 <quicksilver> then again I read it with the first rule of type classes firmly in mind.
08:00:02 <osfameron> what's the first rule of typeclasses?
08:00:19 <frerich> When you think you need a type class, you most likely don't?
08:00:51 <shachaf> Let me guess the rules of type classes: 1. You don't need a type class. 2. (experts only) You don't need a type class yet.
08:01:06 <osfameron> heh
08:01:21 <quicksilver> yes. If you think you need a typeclass, think again.
08:01:31 <merijn> shachaf: True experts: You need multiple typeclasses to encode your properties on the typelevel
08:02:05 <`nand`> true experts use unsafeCoerceConstraint instead of introducing a new typeclass
08:02:26 <sipa> like true experts write their code directly in machine code?
08:03:02 <quicksilver> or butterflies.
08:03:20 <mauke> @where reflection
08:03:20 <lambdabot> I know nothing about reflection.
08:03:25 <mauke> @hackage reflection
08:03:25 <lambdabot> http://hackage.haskell.org/package/reflection
08:08:46 <shachaf> mauke: The first lens to learn is the identity lens, from a value to itself.
08:08:54 <shachaf> The identity lens is called "id".
08:12:30 <SamanthaD> Alright... I have a mostly complete algorithm. Unfortunately, it's implementation is fundamentally mutable but it produces immutable lists!
08:12:40 <SamanthaD> eer, its, not it's
08:12:55 <`nand`> unsafePerformIO!
08:13:06 <`nand`> as long as it doesn't break purity
08:13:10 <SamanthaD> `nand` Indeed!
08:13:13 <parcs> :t _1 -- no, this is the first lens!
08:13:15 <Taneb> ST?
08:13:15 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
08:14:33 <killy9999> does Haskell have PrimOps for botwise operations on unboxed ints?
08:14:46 <applicative> botwise?
08:14:49 <SamanthaD> `nand` All it is is a normal list that traverses much more slowly than a normal list by a factor of O(1) however both cons, ++ and snoc are O(1) operations!
08:14:59 <shachaf> killy9999: Haskell doesn't have PrimOps.
08:15:07 <shachaf> GHC has PrimOps, which are all listed in a big file.
08:15:17 <shachaf> Some of them are for bitwise operations.
08:15:50 <killy9999> of course, I meant GHC
08:15:52 <SamanthaD> `nand` and I think I can optimize it to traverse at normal speed!
08:16:11 * killy9999 is taking a look at The Big File
08:16:22 <parcs> SamanthaD: are you aware of the ST monad? it lets you use local mutability within a pure expression
08:16:26 <applicative> uncheckedIShiftRA# :: Int# -> Int# -> Int#
08:17:54 <SamanthaD> parcs: Of course. Problem is, this is very side-effect-y implementation of immutable lists.
08:18:18 <killy9999> applicatibe: yeah, I noticed the shifts
08:18:30 <killy9999> but I would need bitwise or, and and possibly xor
08:19:03 * hackagebot yesod-core 1.1.7.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.7.2 (FelipeLessa)
08:19:05 * hackagebot hslogstash 0.2.0 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.2.0 (SimonMarechal)
08:19:12 <killy9999> applicative ^^^ (made type in nick, sorry)
08:19:29 <SamanthaD> parcs: Basically, I'm figuring out how to mutate lists in-place without destroying their ancestors
08:20:33 <SamanthaD> parcs: fundamentally it involves referencing the list by the last mutated cell rather than the head of the list. (the cons'd cells have special pointers to the head)
08:20:51 <applicative> hm, yeah killy9999 the 'primitive' xor and or work on Word
08:21:05 <applicative> Word# rather
08:21:29 <SamanthaD> parcs: and if you chop off the head you produce a parallel cell that serves only as a reference to the list as a whole and a pointer to the new head (the traversing as you read though the list goes through the old cell as usual)
08:21:53 <SamanthaD> parcs: it's nifty but it's not a functional concept. It's a compiler hack.
08:22:12 <killy9999> applicative: oh, I didn't notice them, I was looking only on Int#
08:22:15 <killy9999> crap
08:22:32 <SamanthaD> I mean... you could implement it functionally but then it would be stupid
08:23:16 <applicative> killy9999: there's always int2Word# :: Int# -> Word# etc...
08:24:38 <killy9999> I know, but it complicates matters a bit
08:24:54 <killy9999> unless I can get away with int2Word# with rewrite rules...
08:25:01 <killy9999> yeah, this could be good
08:25:10 <killy9999> assuming that rewrite rules work on primops
08:33:32 <ikarus-> how do I link one C library in cabal, and compile and link another?  anyone has examples?
08:36:59 <hpaste> elliott pasted “ST + TypeFamilies = unsafeCoerce” at http://hpaste.org/81269
08:37:14 <elliott> ^ Does anyone want to try this in GHC HEAD?
08:37:16 <elliott> It works in 7.6.1.
08:38:31 <elliott> Actually this seems to be makeGHCPanic, not unsafeCoerce.
08:41:07 <byorgey> elliott: I don't see what that has to do with TypeFamilies
08:41:17 <byorgey> elliott: do you even use STish at all?
08:41:28 <byorgey> oh, you call new, I see
08:41:35 <elliott> byorgey: You don't need the class.
08:41:52 <byorgey> right
08:41:57 <hpaste> elliott annotated “ST + TypeFamilies = unsafeCoerce” with “ST + TypeFamilies = runtime GHC panic” at http://hpaste.org/81269#a81270
08:42:01 <elliott> That's a simplified version.
08:42:28 <elliott> I don't know if you can get non-panic runtime badness from this.
08:42:55 <byorgey> huh, weird
08:42:58 <byorgey> sure looks like a bug
08:43:12 <byorgey> I don't have a good intuition for what's going on though
08:43:19 <shachaf> It doesn't type-check in HEADish.
08:43:29 <elliott> Guess I should report this.
08:43:54 <elliott> It lead me to think my API (which uses rank-2 to hide unsafeCoerce in a similar way to ST) was unsafe until I realised the trick would work for ST too :)
08:46:13 <elliott> Oh, this can be simplified.
08:46:20 <elliott> You don't even need ST.
08:46:44 <elliott> Or rank-2.
08:48:31 <sclv> elliott: this is so perverse
08:48:44 <elliott> I like how it makes no sense.
08:48:55 <sclv> curious about the simplified version
08:49:10 <elliott> I broke it so now it doesn't panic. Let me see if I can fix it.
08:51:46 <elliott> Hmm.
08:51:48 <elliott> It's like it magically fixed itself.
08:52:20 <shachaf> Maybe it was when you got rid of the rank-2 type.
08:52:58 <hpaste> elliott annotated “ST + TypeFamilies = unsafeCoerce” with “TypeFamilies = runtime GHC panic (annotation)” at http://hpaste.org/81269#a81271
08:53:01 <elliott> sclv: ^
08:53:06 <elliott> I think this can be simplified further, though.
08:53:34 <elliott> Because I had a version where runIdentity (runIdentity new) panicked. I just forgot what "new" was then :)
08:54:24 <sclv> i'm stupified by his.
08:54:34 <sclv> this
08:55:02 <elliott> sclv: okay, this is bizarre.
08:55:05 <elliott> sclv: Load my file up into GHCi and try runIdentity (runIdentity new)
08:55:07 <elliott> sclv: then comment out "oops" and load it again
08:55:10 <elliott> note how runIdentity (runIdentity new) *no longer panics*
08:56:16 <sclv> what version ghc?
08:56:31 <elliott> 7.6.1
08:56:36 <elliott> aha, I was right: no rank-2 needed
08:56:41 <sclv> my stodgy 7.4.1 is giving me a type error and refusing to load the file
08:56:53 <sclv>     Couldn't match type `T Identity a0' with `forall a. Identity a'
08:57:20 <hpaste> elliott annotated “ST + TypeFamilies = unsafeCoerce” with “TypeFamilies = runtime GHC panic (annotation) (annotation)” at http://hpaste.org/81269#a81272
08:57:26 <elliott> not going to get simpler than this
08:57:42 <elliott> I like how "oops" is clearly a type error
08:58:46 <parcs> elliott: nothing typechecks with HEAD
08:58:52 <sclv> yeah, now it seems just like an overt bug
09:00:28 <hpaste> elliott annotated “ST + TypeFamilies = unsafeCoerce” with “TypeFamilies = runtime GHC panic (annotation) (annotation) (annotation)” at http://hpaste.org/81269#a81273
09:00:30 <elliott> ok
09:00:35 <elliott> pretty sure this is maximally simple :P
09:00:56 <shachaf> I bet it'd be simpler if you got rid of the >>=
09:01:25 <bacon1989> ping
09:02:15 <elliott> shachaf: What?
09:02:20 <elliott> shachaf: Look at the last one I pasted, there's no (>>=)
09:02:46 <shachaf> Help, I can't keep track of all these.
09:03:03 <shachaf> Oh, that's simpler.
09:03:04 <elliott> shachaf: http://hpaste.org/raw/81273
09:03:40 <sclv> the final form actually looks familiar
09:03:51 <sclv> but i can't recall
09:03:59 <shachaf> Oh, you got rid of rank-2.
09:04:28 <elliott> sclv: I don't think it's the same as the "ambiguous type family" stuff.
09:04:44 <elliott> You can give T a type parameter that you use concretely and say foo = Identity undefined and the same happens.
09:08:13 <glguy> This bug is fixed in HEAD
09:08:51 <hpaste> glguy annotated “ST + TypeFamilies = unsafeCoerce” with “error message” at http://hpaste.org/81269#a81274
09:09:18 <shachaf> Yep.
09:13:30 <`ramses> I get the same error message in 7.6.1
09:14:31 <n-dolio> glguy: Why does that work?
09:15:29 <elliott> `ramses: Really?
09:15:38 <elliott> `ramses: Are you sure it's 7.6.1?
09:15:40 <glguy> `ramses: Load it in GHCi
09:15:51 <glguy> rather than compiling it with GHC
09:16:09 <arbn> So, I'm very confused by all the approaches to marshalling and the FFI. hsc2hs, c2hsc, writing a Storable instance, etc. Is there something I can read that will walk me through it?
09:16:11 <`ramses> elliott: yeah, in ghci, but I have -fdefer-type-errors set, it type checks when I unset that
09:16:20 <elliott> If you compile it as a module with GHC then GHC panics at compile-time.
09:16:29 <elliott> -dcore-lint complains.
09:16:33 <glguy> n-dolio: I'm not sure what you mean.
09:16:52 <arbn> I have an ADT defined in Haskell, and I just want to write the code to enable me to export a function that will return a C struct.
09:16:52 <n-dolio> Well, I was looking at the first thing in there.
09:16:59 <n-dolio> I guess the answer is: type checker has mad bugs.
09:17:11 <glguy> n-dolio: Ah, I think the answer is "types are hard"
09:17:57 * quicksilver doesn't see why the type family changes how 'newSTRef undefined' behaves.
09:17:58 <elliott> n-dolio: Those pastes are mine; it seems like a 7.6-only bug though.
09:18:00 <`ramses> seems that defer-type-errors setting influences the type checker more then it should
09:18:07 <elliott> quicksilver: You should look at that least version rather than that one.
09:18:19 <elliott> It's not really about ST, or rank-2, or anything; it's just a type family bug.
09:18:22 <n-dolio> I looked at all of them. None really make sense.
09:18:23 <`ramses> s/then/than
09:18:46 <n-dolio> Like, I'm not sure what it's even doing.
09:18:55 <elliott> n-dolio: Right. But at least the last one is clear about the kind of sense it doesn't make.
09:18:58 <quicksilver> it should be what ghc 7.0 used to call a 'rigid type variable'
09:19:07 <quicksilver> although I know that lots of people didn't like that term
09:19:09 <elliott> It lets T a ~ () somehow, even though T a is clearly Identity a.
09:19:18 <quicksilver> where, by 'it', I mean the 'a' in Ref m a
09:19:18 <elliott> oops even gets inferred as Identity a if you comment out the type signature.
09:19:49 <elliott> quicksilver: To be clear, http://hpaste.org/raw/81273 is the simplest expression of the bug I have.
09:20:01 <elliott> I think all the rank-2/ST stuff just makes it more confusing.
09:20:21 <shachaf> How about:
09:20:24 <elliott> I think this is the second panic bug I've found in 7.6...
09:20:25 <shachaf> oops = (Id :: a -> T a) undefined
09:20:42 <shachaf> I guess that' just inlining, sort of.
09:20:49 <quicksilver> elliott: *nod* fair enough.
09:20:53 <shachaf> oops = Id undefined :: T a works too.
09:21:08 <shachaf> OK, all I did was inlined it.
09:21:13 * elliott doesn't quite identify simplicity with golfing :P
09:22:56 <elliott> Fun extra: :t (undefined :: T a) :: () in GHCi gives no output.
09:27:04 <parcs> elliott: what's T?
09:29:06 * hackagebot direct-http 0.5.1 - Native webserver that acts as a library.  http://hackage.haskell.org/package/direct-http-0.5.1 (IreneKnapp)
09:29:54 <magneticduck> installing SDL-image for doing some awesome game dev, and I'm having a problem
09:30:02 <magneticduck> cabal install fails
09:30:13 <magneticduck> saying that the 'C compiler cannot create executables'
09:30:20 <magneticduck> seems it's working in the /temp directory
09:30:23 <magneticduck> so that could be it
09:30:31 <magneticduck> is it advisable to chmod on /tmp?
09:30:34 <magneticduck> */tmp
09:30:45 <magneticduck> just wondering
09:30:52 <elliott> parcs: A type family.
09:30:52 <magneticduck> any oponions would be great
09:30:56 <magneticduck> opinions
09:30:58 <magneticduck> whatever
09:31:08 <elliott> parcs: type family T :: * -> *; type instance T = Identity
09:32:15 <parcs> didn't know you can have an instance like that
09:32:55 <elliott> parcs: It works even with a non-weird instance
09:33:03 <elliott> like type family T a :: * -> *; type instance T () = Identity
09:38:14 <magneticduck> darn
09:38:26 <magneticduck> sudo chmod +rwx /tmp didn't work
09:38:46 <elliott> magneticduck: Do you actually have a C compiler installed?
09:38:51 <magneticduck> yeah
09:38:54 <magneticduck> xD
09:39:04 <magneticduck> that's pretty standard on a linux box right
09:39:06 * hackagebot hslogstash 0.2.1 - A library to work with, or as, a logstash server  http://hackage.haskell.org/package/hslogstash-0.2.1 (SimonMarechal)
09:39:08 * hackagebot Craft3e 0.1.0.9 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  http://hackage.haskell.org/package/Craft3e-0.1.0.9 (SimonThompson)
09:41:48 <magneticduck> any ideas?
09:41:50 <magneticduck> :?
09:42:37 <`ramses> magneticduck: have you check that /tmp is not mounted noexec?
09:42:43 <`ramses> checked*
09:42:47 <hpaste> MagneticDuck pasted “installing SDL-image” at http://hpaste.org/81277
09:42:53 <magneticduck> uh
09:42:56 <magneticduck> that would probably do it
09:42:58 <magneticduck> >_>
09:43:00 <magneticduck> thanks
09:43:12 <ion> magneticduck: 1777 root/root are the correct mode and owner for /tmp.
09:43:38 <n-dolio> magneticduck: If you literally ran 'sudo chmod +rwx /tmp' you only changed the permissions for the owner of /tmp.
09:43:40 <n-dolio> I think.
09:43:58 <`nand`> I thought that would be o+rwx or something
09:44:03 <magneticduck> how do I turn it off again?
09:44:04 <`nand`> +rwx affects all three permissions
09:44:05 <magneticduck> yeah
09:44:14 <`ramses> turn what off?
09:44:15 <magneticduck> I don't really care tbh
09:44:17 <magneticduck> :D
09:44:33 <magneticduck> in the unlikely event I get a virus, I can just install everything over again
09:44:44 <magneticduck> besides everything I'm doing is backed up online (github)
09:44:47 <magneticduck> :D
09:44:53 <ion> Why would you get a virus?
09:45:10 <magneticduck> ikr
09:45:29 <magneticduck> well, /tmp is mounted noexec for security
09:45:36 <magneticduck> and my point is that I don't care
09:45:41 <magneticduck> how do I not mount /tmp noexec?
09:45:42 <ion> FSVO security
09:45:51 <ion> Modify /etc/fstab
09:46:24 <magneticduck> kk
09:46:26 <magneticduck> thanks
09:47:50 <magneticduck> I don't see anything there
09:48:09 <magneticduck> except for a lot of things
09:48:11 <magneticduck> :D
09:48:18 <magneticduck> nothing specific to /etc
09:48:20 <magneticduck> arr
09:48:28 <magneticduck> I mean
09:48:33 <magneticduck>  /tmp
09:49:03 <fmap> i love sentences
09:50:10 <magneticduck> how so
09:50:12 <magneticduck> *ahem*
09:50:18 <magneticduck> How so?
09:50:19 <geekosaur> what does "mount | grep tmp" say?
09:51:08 <magneticduck> udev on /dev type devtmpfs (rw,mode=0755)
09:51:10 <magneticduck> tmpfs on /run type tmpfs (rw,noexec,nosuid,size=10%,mode=0755)
09:51:12 <magneticduck> none on /run/lock type tmpfs (rw,noexec,nosuid,nodev,size=5242880)
09:51:14 <magneticduck> none on /run/shm type tmpfs (rw,nosuid,nodev)
09:51:16 <magneticduck> none on /run/user type tmpfs (rw,noexec,nosuid,nodev,size=104857600,mode=0755)
09:51:18 <magneticduck> sorry for abusing the chat
09:51:20 <magneticduck> I was too lazy to use hpaste
09:52:16 <magneticduck> geekosaur?
09:52:21 <magneticduck> any ideas?
09:52:26 <magneticduck> I'm not exactly sure how to read that
09:53:03 <geekosaur> <magneticduck> tmpfs on /run type tmpfs (rw,noexec,nosuid,size=10%,mode=0755)
09:53:12 <geekosaur> iwait, that's not it, sorry
09:53:49 <geekosaur> hm, although it might be.  what does "ls -ld /tmp" say?
09:54:04 <shachaf> What about df /tmp?
09:54:07 <geekosaur> (I have a feeling it will turn out to be a symlink pointing under /run)
09:54:11 <shachaf> Or that.
09:54:40 <magneticduck> drwxrwxrwt 11 root root 4096 Jan 25 17:51 /tmp
09:54:54 <fragamus> OK, so I have a graph of nodes, which benefits from GC when some nodes become disconnected they get collected.  PROBLEM: I need to marshall the graph. Some nodes are reachable by innumerable routes, which leads to massive duplication.
09:55:01 <geekosaur> hm, ok.  now try shachaf's suggestion
09:55:28 <magneticduck> Filesystem     1K-blocks     Used Available Use% Mounted on
09:55:30 <magneticduck> /dev/sda1      474642584 11759796 438772352   3% /
09:55:35 <magneticduck> thanks a lot guys, btw
09:55:38 <shachaf> tmp is not a special filesystem
09:55:40 <shachaf> It's just /
09:55:44 <geekosaur> yeh
09:55:51 <magneticduck> yeah
09:55:59 <shachaf> I'm not sure where you got the idea that /tmp is mounted noexec, but it isn't.
09:56:17 * shachaf has no idea what the original problem was.
09:56:22 <geekosaur> apparently that was inferred from "C compiler cannoit create executables" wich could be any number of issues
09:56:29 <shachaf> Oh.
09:56:35 <SamanthaD> shachaf: /tmp is special because files in /tmp are not assumed to be persistent across reboots/long periods of time.
09:56:38 <geekosaur> actualy, you should go check config.log and see what it has to say about what actually happened
09:56:40 <magneticduck> gcc seems to work usually
09:56:42 <magneticduck> alright
09:56:42 <shachaf> Well, use -v -v -v
09:56:57 <shachaf> and if that doesn't work, use the secret -v option called strace.
09:56:59 <geekosaur> configure will still be hiding those details, I think
09:57:03 <shachaf> Or something.
09:57:06 <shachaf> Or that.
09:57:18 <magneticduck> alright
09:57:21 <geekosaur> hm, is there a way to stop cabal from cleaning up after itself?
09:57:22 <magneticduck> used verbose flag
09:57:26 <magneticduck> shall I hpaste it?
09:57:32 <geekosaur> yes
09:57:36 <magneticduck> kk
09:57:44 <dcoutts> geekosaur: yes, unpack and build there
09:57:51 <SamanthaD> shachaf: Ugh... that's what happens when I drop in the middle of a conversation. Sorry about that.
09:57:52 <shachaf> SamanthaD: I know, but that's not relevant here.
09:57:55 <SamanthaD> Gonna sleep now >.>
09:57:55 <dcoutts> geekosaur: I presume you mean when it'd building from a tarball
09:58:05 <dcoutts> it'd/it's
09:58:19 <SamanthaD> shachaf: Yeah, I just realized. I'm extremely tired from my all night hackfest. Gonna go sleep now.
09:58:20 <basdirks> you said that 3 hours ago as well
09:58:24 <hpaste> MagneticDuck pasted “verbose install” at http://hpaste.org/81278
09:58:37 <shachaf> SamanthaD: But it's time to wake up!
09:58:41 <shachaf> Or not.
09:58:47 <magneticduck> heh
09:58:48 * shachaf might follow suit.
09:59:06 <fragamus> before you go can you ponder my dilemma
09:59:13 <geekosaur> dcoutts, yes, this is from a cabal install and it has created its work area under /tmp
09:59:20 <geekosaur> ohhhh
09:59:23 <geekosaur> SDL-image
09:59:29 <magneticduck> yes
09:59:31 <magneticduck> :D
09:59:35 <magneticduck> btw
09:59:38 <magneticduck> I'm using ubuntu
09:59:42 <magneticduck> latest version
09:59:48 <dcoutts> geekosaur: right, so there's no point us adding a --keep-files flag, as it's exactly the same number of steps as a user doing unpack and building there
09:59:49 <magneticduck> I'm sorry, I know arch linux is better
09:59:53 <magneticduck> but I was too lazy
09:59:55 <magneticduck> ;D
09:59:57 <geekosaur> this is a bug in its configure script; you need to make sure you have the C SDL_image library installed first, configurew does not check and assumes its presence when testing the C compiler
09:59:57 <fragamus> I need to serialize my graph
10:00:12 <geekosaur> so if it's not installed it claims the C compiler is broken
10:00:14 <magneticduck> ah
10:00:16 <magneticduck> yes
10:00:18 <magneticduck> thanks
10:00:21 <magneticduck> I'll do just that
10:04:35 <magneticduck> terrific
10:04:49 <magneticduck> all installed
10:04:51 <magneticduck> thanks
10:05:22 <basdirks> what's the '++' for Text?
10:07:55 <magneticduck> basdirks: Text is a monoid
10:08:00 <magneticduck> so mconcat should work
10:08:58 <basdirks> hm it's not a monad though is it?
10:09:28 <basdirks> I like my (=<<)'s for [Char]
10:09:52 <Eduard_Munteanu> basdirks: [Char] isn't a monad either, [] is.
10:09:58 <basdirks> I know
10:10:09 <magneticduck> [a] is a monad, you mean?
10:10:09 <basdirks> but I like being imprecise
10:10:20 <basdirks> being imprecise is easy
10:10:23 <Eduard_Munteanu> magneticduck: yeah
10:10:26 <magneticduck> kk
10:10:27 <Eduard_Munteanu> :k []
10:10:29 <lambdabot> * -> *
10:10:34 <magneticduck> ah yes
10:10:37 <magneticduck> [] is the constructor
10:10:41 <magneticduck> kk#
10:10:46 <magneticduck> my haskell is a bit rusty
10:10:52 <Eduard_Munteanu> Yeah, the type constructor, I know, it can be confusing.
10:11:03 <basdirks> Because String is [Char], monadic operations work, is what I meant
10:11:31 <basdirks> but spending my working day among PHP programmers, I am very good at being vague
10:11:38 <magneticduck> :D
10:11:51 <arbn> ... the point being, basdirks likes a monadic API for his sequences of characters.
10:12:06 <bartavelle> is there a reason why Data.Aeson works with a ByteString, as it must convert to Text everything anyway ?
10:12:47 <basdirks> arbn is correct
10:13:20 <basdirks> for this project I am sortof confined to ASCII, and it's not performance critical
10:13:40 <basdirks> so I might as well use String
10:14:42 <fmap> bartavelle: because you get ByteStrings from network?
10:15:01 <fmap> also parsing ByteStrings should be faster than parsing Text
10:15:15 <tac> What is the moral difference between ByteString and Text?
10:15:26 <bartavelle> yes but it sucks because if they might be either utf8 or latin1, I have to try to convert them to text first, and put the bytestring into aeson that will try to convert them too
10:15:47 <bartavelle> anyway, this is probably a detail
10:15:52 <arbn> tac: Encoding. Text is always unicode. ByteString could be whatever.
10:16:05 <tac> good to know. Thanks arbn
10:16:19 <`nand`> purpose
10:16:27 <`nand`> Text is a sequence of characters. ByteString is a sequence of bytes
10:16:35 <`nand`> not to be confused
10:16:36 <tac> I gotcha
10:16:38 <tac> Yeah
10:16:47 <tac> A binary blog vs a unicode string
10:16:55 <tac> I don't know why I never figured that out >_>
10:17:16 <arbn> A binary blog? That'd be interesting. Hard to read.
10:17:31 <tac> blob*
10:17:50 <tac> you must have read the g upsidedown or something :P
10:18:01 <schellsan> what's the most popular irc package? fastirc, irc, simpleirc?
10:18:05 * arbn removes his pedant hat.
10:19:25 <Lethalman> schellsan, apart the popularity, you might check the last commit in the respective repository
10:19:38 <Lethalman> schellsan, or the last upload date
10:19:49 <tac> schellsan: I just rewrote my IRC bot with simpleirc. It works well enough :)
10:20:02 <`nand`> or the version number, unless it's an edwardk library!
10:20:24 <arbn> Lambdabot should have a feature to tell us the *best* library matching a given keyword. :P
10:20:29 <shachaf> If one of them is getting commits and uploads all the time, it means it's buggy. Avoid it.
10:20:54 <Lethalman> shachaf, or the others being incomplete ;)
10:21:01 <frerich_> shachaf: So, are you already or still awake?
10:21:02 <`nand`> shachaf: could just be Core optimizations
10:21:09 <tac> arbn: I would like something like that
10:21:23 <tac> You never know when something on Hackage is worthwhile or a total waste of your time
10:21:35 <arbn> tac: Just try all of them.
10:21:50 <tac> It doesn't help that every package is on version 0.0.0.4
10:22:08 <schellsan> tac: thanks, what's your bot?
10:22:21 <tac> and there is a trend for the software to be left alone on github (contrast to python, where many libraries have a full site with documentation and examples with a support form)
10:22:24 <`nand`> look at the type signatures and figure out which one has the nicest API
10:22:28 <schellsan> Lethalman: that's a good tip
10:23:00 <arbn> `nand`: I do tend to do that. Skim the top-levels of the modules and see which is going to save me more time.
10:23:06 <tac> schellsan: He's a little toy in my free time. He can control my roommate's Philip's Hue lights, send emails and texts, and change the topic in my channel
10:23:08 <arbn> It's a nice tip.
10:23:54 <schellsan> okay - i will check them all out ;)
10:24:01 <tac> `nand`: I did that the other day with HJS. It looked, from the type sigs, that it was a moderately well-developed library
10:24:07 * hackagebot Elm 0.7.1.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.7.1.1 (EvanCzaplicki)
10:24:15 <tac> but evaluating 'hello ' + 'world', I get the string 'hello hello '
10:25:13 <arbn> tac: Watch out for the "Experimental" stability. HJS has that on the tin.
10:25:16 <`nand`> let (+) = const . join (++)
10:25:25 <`nand`> makes perfect sense
10:26:06 <tac> I just wanted an IO-safe interpreter I could use to program my roommate's lights to flash in various patterns T____T
10:27:01 <schellsan> I've written a small log bot for my work's channel
10:27:19 <schellsan> looking to clean it up and add some time management tools to it
10:27:35 <schellsan> we have a real problem tracking time here
10:27:51 <Clint> we have a horrible perl bot that tries to do that
10:27:55 <Clint> it should be replaced by a webapp
10:28:00 <`nand`> echo 'USER log log log :log\r\nNICK logbot\r\nJOIN #haskell' | nc irc.freenode.net 6667 > log
10:28:01 <nejucomo> schellsan: Be careful: If you add time tracking tools you may find out how much time you work on the irc bot.  ;-)
10:28:32 <`nand`> the smallest logbot?
10:28:39 <schellsan> haha - last week it was all i thought about
10:28:55 <Clint> `nand`: you're missing some keepalive
10:29:19 <Philippa> yeah, if you don't PONG your PINGs you don't stay on for long
10:29:51 <schellsan> they wanted me to write it in ruby, but the haskell wiki has a nice tut that shows up second on google for "irc bot"
10:29:57 <schellsan> i couldn't resist
10:30:14 <Clint> that bot doesn't work
10:31:38 <applicative> the wiki's bot doesn't work?
10:32:13 <schellsan> it seemed to be a good starting point
10:32:31 <schellsan> i didn't follow it all the way through using State
10:32:37 <`nand`> Clint: I wonder if you can do something like this with an appropriate tuned grep/sed to filter out the PINGs, change them to PONGs and send them back
10:32:44 <tac> schellsan: work bots are some of the best
10:32:49 <Clint> multithreaded shell pipeline
10:33:05 <tac> I had written a bot with automatic SVN and Trac queries whenever you typed r123 or #123
10:33:21 <tac> it made it very easy to collaborate over specific issues on IRC
10:33:36 <schellsan> ooh - that's a good idea
10:33:48 <Clint> i should try out the ircbot library the next time i need a bot
10:33:59 <schellsan_afk> brb
10:34:04 <applicative> pizzabot_works has really bad use of StateT though
10:34:05 <`nand`> Philippa: server keeps timing you out? easy; just `while true; ircbot(); done`
10:35:23 <hpaste> applicative annotated “Pizza-bot v 0.3” with “Pizza-bot v 0.3 (exercize: improve State use)” at http://hpaste.org/51064#a81280
10:35:29 <tac> while true: PONG();
10:37:14 <k0ral> hello guys
10:37:48 <k0ral> would it hurt to rewrite every library replacing "IO" with "MonadBase IO m => m" ?
10:38:09 <k0ral> is it always possible/desirable ?
10:38:56 <Philippa> `nand`: you'd be lucky to get one 9 of proper uptime with that
10:39:04 <Philippa> not to mention to not get akilled
10:39:41 <n-dolio> What's MonadBase from?
10:39:42 <Philippa> really, you don't get to call yourself an /IRC/ logbot unless you can at least PONG
10:40:05 <Philippa> I mean yeah, you probably can do the grep/sed, given that IRC's a line-by-line protocol
10:40:13 <Eduard_Munteanu> Hm, interesting... http://www.haskell.org/haskellwiki/New_monads/MonadBase
10:40:18 <k0ral> transformers-base
10:40:22 <n-dolio> Anyhow, some things aren't doable with just lift.
10:40:24 <k0ral> n-dolio: ^
10:40:34 <n-dolio> Anything handler-y.
10:41:21 <Eduard_Munteanu> n-dolio: it's not plain lift... class (Monad m,Monad b) => MonadBase b m where liftBase :: b a -> m a
10:41:30 <n-dolio> Eduard_Munteanu: Doesn't matter.
10:41:33 <frerich_> Hm, does anybody here happen to work one some freely-accessible Haskell project which would benefit from contributions? I did a few projects myself by now (the most recent one was a multi-threaded web crawler), I think I'm getting closer to being able to contribute something to (and learn something from) a bigger project.
10:41:41 <n-dolio> It's still lifting.
10:42:04 <shachaf> Eduard_Munteanu: n-dolio is probably talking about things like catching exceptions?
10:42:19 <shachaf> And also other things, which is the problem.
10:42:28 <Clint> frerich_: hOpenPGP, dpkg, DAV
10:42:37 <n-dolio> The problem is that lifting from IO -> M doesn't let you deal with combinators that take your monad as arguments.
10:42:50 <k0ral> frerich_: check out hbro
10:42:52 <Clint> frerich_: bindings-sane and MusicBrainz as well
10:42:53 <Eduard_Munteanu> Ah. I was thinking of complex monad stacks where you have to use liftIO instead of say lift.
10:43:10 <n-dolio> It works for things that produce IOs, though.
10:43:12 <k0ral> frerich_: I would really appreciate any help
10:43:33 <n-dolio> And yeah, I'd love it if everything in base were MonadIO m => m watever instead of IO watever.
10:43:42 <sm> does regex-tdfa support replacing occurences of a regexp ?
10:44:17 <Clint> lifted-base
10:44:24 <k0ral> n-dolio: MonadBase is more generic than MonadIO, isn't it ?
10:44:28 <frerich_> k0ral: Technically, I already have code in hero ;-)
10:44:33 <frerich_> k0ral: err, hbro
10:44:50 <n-dolio> k0ral: Sure.
10:44:56 <Eduard_Munteanu> frerich_: you're the author of hbro?
10:45:07 <k0ral> Eduard_Munteanu: I am
10:45:17 <Eduard_Munteanu> Ah.
10:45:18 <k0ral> frerich_: what do you mean ?
10:45:23 <Eduard_Munteanu> I should try it sometime.
10:45:31 <frerich_> Eduard_Munteanu: No, I think k0ral is, but I worked on SVG in WebKit (and I did the XPath support)
10:45:43 <k0ral> well, it's not really usable, there are many problems in the webkit/gtk binding
10:46:01 <Clint> :(
10:46:17 <`nand`> hbro sounds cool but I doubt it's going to replace anybody's browser until it can do the things you'd realistically expect a browser to do, out of the box
10:46:44 <k0ral> `nand`: sure, so what about contributing ? :)
10:46:48 <Clint> webkit needs some competition too
10:47:01 * `nand` is a happy gecko user
10:47:13 <k0ral> Clint: I agree but that is such a big work, I'm not sure it will emerge any time soon
10:47:13 <Clint> where are the haskell gecko bindings
10:47:22 <Clint> k0ral: yes, we live in a sad world
10:48:09 <Eduard_Munteanu> Unlike Gecko I think there are many more UIs for Webkit, so I guess it might be better at that.
10:48:23 <`nand`> ditch webkit and gtk and implement pure haskell HTML renderer and widget libraries. Having a browser would really start catapulting the House project into real-world relevance!
10:49:03 <`nand`> k0ral: my main form of contribution to any sort of project is with feature requests
10:49:06 <Eduard_Munteanu> Browse with House :)
10:49:24 <Lethalman> didn't gecko stop supporting a library for embedding? that's why most of apps have webkit
10:49:57 <uniquenick> has anyone here used the aws package?  is it possible to use it "normally" or do I have to do weird conduit stuff?
10:50:17 <Eduard_Munteanu> I'm not sure, but there used to be other browsers besides Firefox that used it.
10:50:35 <Eduard_Munteanu> Including Seamonkey, a plain GTK UI for it.
10:50:38 <k0ral> it is widely said that gecko's architecture is a big mess
10:51:06 <k0ral> anyone interested in implementing an HTML renderer in Haskell ? :D
10:51:17 <Eduard_Munteanu> That's a bit funny for two reasons.
10:51:36 <`nand`> k0ral: so I've heard as well. Honestly, I don't use it out of choice, I'm just using firefox for firefox's sake; not for gecko's
10:51:38 <schellsan_afk> has there been any good work done on ghc for cross-compilation?
10:51:54 <Eduard_Munteanu> Actually I'm going to say that sounds a lot like 'gcc' and leave it at that. ;)
10:51:56 <schellsan_afk> i've got some raspberry pi's in the mail...
10:52:16 <n-dolio> There's been work on it, but I'm unsure what the status is.
10:53:35 <schellsan_afk> i'm guessing it's a lot more complicated then generating llvm code and then compiling that for ARM...
10:54:11 <Eduard_Munteanu> Hm, here's an interesting thought... using LLVM for Javascript JITing in the browser.
10:54:12 <n-dolio> Well, yes.
10:54:14 <sclv> not terribly much actually
10:54:31 <sclv> the main issue is lots of hardcoded assumptions
10:54:32 <geekosaur> there's a thread in my inbox about arm corss-compilation...
10:54:36 <sclv> about architecture.
10:54:41 <tac> schellsan_afk: my rpi is out for delivery today :D :D
10:54:44 <n-dolio> I mean, I think the big barrier was that GHC was originally written with assumptions that it's always compiling for the platform it's running on.
10:54:51 <n-dolio> So they've been removing those.
10:55:09 <sclv> exactly -- and now simon m says he actually can cross compile for the rpi
10:55:14 <sclv> which is huge
10:55:17 <tac> When you make assumptions you make an ass out of your umptions
10:55:18 <n-dolio> Ah. Is that in 7.8?
10:55:23 <schellsan> haha
10:55:33 <sclv> HEAD I guess
10:55:47 <`nand`> there isn't a 7.8 yet is there?
10:55:49 <n-dolio> Probably one after 7.8 then, I guess.
10:55:50 <gusto> shutdown_-h_now: hey, what a decievable nick!
10:55:51 <sclv> he included all the special build flags for ghc he needed to make it work as a cross-compiler for that arch
10:55:53 <schellsan> it would be really nice to have an article on that...
10:55:56 <geekosaur> looks like it's on glasgow-haskell-users and they are focusing on HEAD
10:56:00 <n-dolio> `nand`: No, but they've got an RC out or something, don't they?
10:56:05 <sclv> I guess you need a special build for xcomp at the moment
10:56:07 <n-dolio> Or a beta?
10:56:07 <`nand`> oh, maybe
10:56:17 <sclv> didn't gcc used to be like that too?
10:56:29 <n-dolio> Oh no, that was 7.6.2 RC.
10:56:34 <sclv> or parts may be still even
10:57:06 <sclv> oh, hey, anyone with strong c++ as well as functional looking for a ny job?
10:57:12 <sclv> a recruiter just hit me up
10:57:41 <sclv> i think the position is mainly c++ but they're building some functional modeling dsl or w/e
10:58:50 <sm> it seems as very few of the regular expression libs on hackage provide a replace/substitute funtion - just regex-compat and regepr as far as I know. Why is that ? What do people do for that ?
10:59:34 <sclv> iirc its because that's a really mutatey operation in the underlying c libs
11:00:33 <sclv> should be simple enough to write a general purpose wrapper layer that uses captures to create the effect
11:04:04 <sm> sclv: thanks.. it seems like something needed
11:04:58 <sm> I will raise it on cafe, shall I quote you ?
11:08:52 <gusto> so
11:08:53 <sclv> sm: if you feel like it? i don't think anyone is going to jump in and do it themselves
11:09:15 <sclv> if you need a replace, you should go ahead and write one
11:12:08 <sclv> sm: cf, this: http://stackoverflow.com/questions/3847475/haskell-regex-substitution
11:12:15 <sm> sure, let's just make certain I'm not overlooking the magic/obvious-to-everyone-but-me solution  first
11:14:04 <sclv> unfortunately the paste there seems to have expired
11:14:11 <sm> yah
11:14:29 <sm> but thanks for the link
11:14:57 <sclv> oh, here's one: http://stackoverflow.com/questions/9071682/replacement-substition-with-haskell-regex-libraries
11:16:18 <spirit123> hi guys
11:16:53 <tac> hi spirit123
11:16:53 <sclv> sm: and here's where chris said he'd improve the documentation, and i guess didn't? http://stackoverflow.com/questions/8042889/is-there-a-version-of-subregex-which-supports-pcre :-)
11:17:24 <sclv> if you figure out a nice solution, maybe a pull request to chris with the improved documentation would be the way to go
11:17:49 <spirit123> this is my first time here and my first time trying out haskell
11:18:07 <schellsan> hi spirit
11:18:26 <schellsan> how are you liking haskell?
11:18:37 <sm> sclv: thx
11:18:50 <spirit123> i am still trying to under stand how functional programming works
11:18:59 <spirit123> sorry understand
11:19:17 <uniquenick> which module is most recommended for a simple "parse an xml file and give me the value of one tag" scenario?
11:19:20 <`nand`> it works using functions
11:19:28 <Ralith> and programming
11:19:47 <schellsan> have you read learnyouahaskell.com?
11:19:59 <spirit123> no
11:20:13 <spirit123> i will heard there right now
11:20:22 <Philippa> spirit123: there's a fair amount to understand, just as with any style of programming
11:20:33 <Philippa> but that's true of anything worth learning, too
11:20:44 <spirit123> ok
11:21:20 * geekosaur imagines half of #haskell checking inboxes and cringing reflexively
11:22:40 <spirit123> i am determined to learn it a friend said it is good
11:23:21 <Philippa> geekosaur: which list should I be glad I'm not reading?
11:23:35 <`nand`> monad-tutorials?
11:24:28 <geekosaur> cafe.  "A regex would have been much nicer..."
11:25:04 <sm> ha
11:25:23 <monochrom> haha
11:25:39 <monochrom> (it's Clark Gaebel's message)
11:25:49 <Hafydd> But a lover would be even more okay!
11:37:44 <spirit123> bye guys will come back later
11:40:27 <Eduard_Munteanu> Weird, why does RWST redefine stuff like ask, local etc. and doesn't have a MonadReader instance?
11:41:56 <monochrom> perhaps because you are looking at Control.Monad.Trans.RWS, as opposed to Control.Monad.RWS ?
11:42:23 <Eduard_Munteanu> monochrom: hm yes...
11:43:05 <Eduard_Munteanu> monochrom: why is the Trans version like that? Legacy stuff?
11:43:19 <Eduard_Munteanu> Seems to belong to transformers instead of mtl.
11:43:32 * Eduard_Munteanu is clueless why we have both in the platform
11:44:32 <monochrom> some people want to avoid MPTC and fundep. some other people want it for the MonadReader convenience
11:45:35 <monochrom> it was therefore decided: RWST is defined in transformers, stays Haskell 98. put the MonadReader layer in mtl
11:45:54 <Eduard_Munteanu> I see.
11:49:07 <elliott> Eduard_Munteanu: mtl depends on transformers
11:49:29 <Eduard_Munteanu> It does? Hm.
11:49:33 <phaer> I am trying to use System.Random, but i can't import it in ghci
11:50:21 <geekosaur> seems to work here.  ghc version, platform?
11:50:21 <phaer> ..in ghci inside a hsenv that is. I can import it outside the hsenv and i can compile code which imports System.Random in the hsenv
11:50:58 <geekosaur> ah
11:51:08 <phaer> geekosaur: GHC 7.4.1 on debian testing (haskell-platform installed)
11:51:46 <Eduard_Munteanu> phaer: what's the error?
11:52:14 <phaer> Eduard_Munteanu: "Could not find module `System.Random'"
11:52:25 <Eduard_Munteanu> :/
11:53:44 <tac> Are there no pop3 libraries for Haskell that support SSL?
11:53:55 <phaer> I guess it has something to do with hsenv. Maybe i should try cabal-devel
11:54:10 * hackagebot hoodle-core 0.9.0 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.9.0 (IanWooKim)
11:54:12 * hackagebot hoodle 0.1.1.0 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.1.1.0 (IanWooKim)
11:55:55 <Eduard_Munteanu> tac: dunno... but if all you want is secure auth, you don't need SSL. Figured it might help to mention this.
12:00:44 <tac> thanks
12:01:05 <tac> In the time it took to get haskellnet installed, I got it working in Python >__>
12:01:20 <BrianHV> anyone know if Tuesdays NY meetup will be recorded and posted again?
12:01:21 <tac> I guess we'll just be ostensibly functional here :)
12:01:36 * BrianHV pokes an apostrophe into that question.
12:01:59 <Eduard_Munteanu> tac: just make sure you don't send the password plaintext, use a challange-response auth method like CRAM-MD5. Although arguably SSL might be better than that.
12:03:04 <tac> Eduard_Munteanu: I think it's probably just safer here to use the well-tested python library
12:03:14 <tac> It's a toy, so if they do steal my password, it's not the end of the world
12:03:52 <monochrom> famous last words :)
12:06:19 <Saizan> copumpkin: we said almost the same things but you get upvotes and i don't!
12:07:42 <Saizan> oops, i thought i was on -blah
12:09:25 <tac> monochrom: Indeed. I'm doing the Right Thing and using Python instead of crappy Haskell lib at version 0.0.0.4
12:14:38 <`ramses> is there some tool to prune garbage from ~/.cabal ? like old versions of packages that are unregistered
12:16:04 <monochrom> yes someone wrote a shell script, but I forgot who and where
12:17:18 <Eduard_Munteanu> Damn, I wish there were wildcards/metavariables (like '_' in Agda) in Haskell.
12:18:02 <Eduard_Munteanu> It'd be especially nice for partially specifying a type.
12:20:53 <`ramses> monochrom: I've been googling for a while but I cannot find it.. Maybe I should write a haskell app for it and put it on hackage :)
12:21:26 <elliott> Eduard_Munteanu: they exist in ghc head
12:21:36 <elliott> implicit params work nicely for the purpose, also, as a hack
12:21:53 <Eduard_Munteanu> elliott: interesting, what's the extension called?
12:23:22 <elliott> Eduard_Munteanu: -XHoles I think
12:23:27 <elliott> I find implicit parameters give better messages though
12:23:46 <Eduard_Munteanu> Hm, thanks, I'll have a look at both.
12:24:26 <Eduard_Munteanu> elliott: also, is that what I think it is? Holes like in Agda?
12:25:05 <elliott> yeah
12:25:08 <elliott> except worse :p
12:25:25 <elliott> with implicit parameters you can just say ?blah instead of your subexpression and you usually get something useful
12:25:49 <Eduard_Munteanu> I think the worst part is this might make me use Emacs more, if things go like in Agda's case. :)
12:25:59 <jackrabbit> Hello. Can I printf an instance of Show, or do I have to show it myself?
12:27:36 <`ramses> jackrabbit: you mean with a format string?
12:27:51 <geekosaur> no, printf does not automatically invoke show, just as other values don't automaticaly get cast
12:28:32 <jackrabbit> geekosaur: is there a good reason why not? I would instantiate PrintfArg but it seems to be delibarely private
12:28:37 <`ramses> ah, like that :)
12:29:05 <geekosaur> is there a good reason why Haskell should ever automatically cast something?
12:29:53 <geekosaur> (there are good reasons for it, but people who come to Haskell looking for automatic casting often do not consider them good reasons)
12:30:05 <jackrabbit> geekosaur: you're just being rude to a beginner now. I've asked a reasonable question politely and you're being sarcastic back.
12:30:44 <monochrom> it is not sarcastic
12:30:46 <geekosaur> sorry, I'm not trying to be sarcastic
12:30:52 <jackrabbit> geekosaur: but being able to printf a Show wouldn't cast - it would be a show when i pass it, and it would be treated as a show, and formatted accordingly
12:31:21 <geekosaur> if you mean that, then you just want to print a String (which is what show gives you); what then is the question?
12:31:25 <elliott> you can't give such a PrintfArg instance anyway
12:31:29 <elliott> so it is academic
12:32:04 <Eduard_Munteanu> For a particular type, it should work.
12:32:08 <elliott> sure
12:32:23 <elliott> ...but not generically for all showable, which seems to be the question.
12:32:24 <Philippa> jackrabbit: geekosaur was being didactic, but then you're the learner. Nothing unreasonable about pointing out that a question can reasonably be reversed
12:32:42 <Philippa> in fact, it's a good way to make discoveries - so it's something of a habit around here
12:33:01 <monochrom> Philippa++
12:33:19 <geekosaur> if you're writing a wrapper function which wants to take something that you can call (show) on and pass it on to printf, then you want to declare it using Show v => ... -> v -> ...
12:33:28 <geekosaur> thus informing the compiler that you can handle any instance of Show, which you do by invoking show on it (which is the only thing you can reasonably do with such a value)
12:33:38 <geekosaur> after which you have a String
12:33:40 <Philippa> or, y'know, just do it and let the compiler work out you're calling show
12:33:56 <Philippa> but the types are often a good guide
12:34:15 <Philippa> and we'd lose that if we did things automatically
12:34:33 <Philippa> (though it's possible to write some, er, daft things using type classes!)
12:34:47 <jackrabbit> But printf is already prioritising being convenient over being elegant isn't it?
12:34:56 <Saizan> jackrabbit: there's a technical reason why you can't have a catch-all instance for all Show-able, it's because it'd require OverlappingInstances
12:35:17 <Philippa> yeah. There's being convenient and then there's asking to break the type system
12:35:21 <elliott> Saizan: IncoherentInstances even
12:35:22 <geekosaur> actually, it's purely didactic; it's an example of how to do a certain kind of complex typeclass manipulation
12:35:29 <elliott> given the instances already defined in PrintfArg
12:35:38 <Philippa> *nod*. I know I can't see myself wanting to use printf
12:35:42 <elliott> geekosaur: I don't think Text.Printf is in base for purely didactic reasons... people certainly use it
12:35:48 <elliott> though I find it distasteful
12:35:59 <Saizan> elliott: why IncoherentInstances?
12:36:00 <geekosaur> unfortunately, the specific kind of trickery it exemplifies probably makes adding the kind of additional trickery that might possibly automate Show ... difficult
12:36:33 <geekosaur> elliott, I'd argue it's like Text.Regex; people use it but many hold their noses while doing so
12:36:51 <jackrabbit> My use case is having a long string that I want to insert lots of show instances into "warning: A has property B which means C and so D", and formatting that is really long winded with ++ show ... ++, and would be really nice with printf if it had a show format specifier
12:36:56 <Philippa> mmm. I'd at least use Text.Regex if I'd got handed a spec in terms of regexes though
12:37:01 <elliott> Saizan: because you have PrintfArg Int, String, etc. but also Show a => PrintfArg a
12:37:04 <monochrom> you cannot support both of the following. so pick only one.  (A) %d for Int.  (B) %somethingelse for "Show v => v"
12:37:12 <Saizan> in fact i think that since PrintfArg is not exported OverlappingInstances wouldn't be too bad here
12:37:23 <elliott> so to actually use it you will need to tell GHC to pick one, no?
12:37:35 <Saizan> though it might have murky semantics wrt the format string
12:37:47 <Philippa> jackrabbit: I never got round to doing this myself, but you could write a function that abstracts that pattern and apply the first two parms using backticks
12:37:56 <Philippa> That could well help
12:38:33 <Philippa> or even just a version of ++ that shows the thing on the RHS
12:38:36 <Saizan> elliott: yeah, OverlappingInstances is about that.
12:39:05 <Saizan> elliott: it picks the more specific instance
12:39:14 <jackrabbit> Could I solve it using template haskell (don't know that yet, so don't jump down my throat)?
12:39:30 <Philippa> yes, you could
12:39:33 <elliott> Saizan: oh, right. one is more specific
12:39:38 <Philippa> I think someone's written it, don't know where
12:39:43 <elliott> Ignore me, it's been too long since I overlapped instances :)
12:39:44 <geekosaur> (+!) :: Show a => String -> a -> String; s +! a = s ++ show a
12:40:22 <Eduard_Munteanu> You don't really need (++) if you're using printf.
12:40:38 <Eduard_Munteanu> Just show your Show-able stuff.
12:40:39 <geekosaur> although I would wonder if maybe ... that, just use %s in the format and show in the parameters
12:40:40 <Philippa> Eduard_Munteanu: of course not, I was proposing an alternative
12:40:56 <Philippa> (but it's more complicated if there're multiple formats per type, of course)
12:41:25 <geekosaur> (then again if you're retrofitting this into existing stuff, maybe adding the parameters that way is more work; depends
12:41:27 <geekosaur> )
12:42:36 <Lethalman> hi
12:42:41 <fragamus> @pl (\bar -> Quux foo bar) <$> baz
12:42:41 <lambdabot> Quux foo <$> baz
12:42:53 <Lethalman> let's say I have [1,2,3,4], I'd like to have for each element, the neighbors
12:43:03 <Lethalman> like: [[1,2], [1,2,3], [2,3,4], [3,4]]
12:43:34 <Lethalman> my current solution involves zip and drop and take
12:43:47 <derdon> show it
12:43:49 <Lethalman> yes
12:43:55 * Lethalman isolates the code
12:45:29 <NemesisD> hi all, i've got to define a specialized case of an instance: data Response a = ...; instance FromJSON (Response a) where ... instance (FromJSON a) => Response a where
12:45:44 <NemesisD> but those instances overlap. am i taking the wrong approach to this?
12:46:04 <hpaste> Lethalman pasted “Neighbors” at http://hpaste.org/81286
12:46:08 <Lethalman> ^^
12:46:15 <elliott> NemesisD: that code is a kind error
12:46:26 <NemesisD> i've already used FlexibleInstances but since () has a FromJSON instance, it is ambiguous
12:46:28 <Lethalman> it's a very ugly code :S
12:46:33 <elliott> more importantly, Response is a data type there
12:46:38 <elliott> so how can you give an instance Response a? it's not a typeclass
12:48:04 <monochrom> instance (FromJSON a) => FromJSON (Response a) ?
12:48:17 <NemesisD> elliott: whoops, typo, yes what monochrom said
12:48:29 <elliott> then yes, you cannot have both those instances
12:48:38 <elliott> you'll have to rethink the structure
12:48:43 <monochrom> and you should never do "instance FromJSON (Response a)". it can't be done
12:49:11 <NemesisD> monochrom: yeah i don't even know what that would mean, just made a mistake
12:49:31 <elliott> monochrom: well, it can for some Responses
12:49:37 <elliott> e.g. one contravariant in a
12:50:01 <Lethalman> mh zip3 is a good idea in the while
12:50:23 <monochrom> of course, I have seen how "instance Show (STM a)" is done
12:50:34 <NemesisD> hmm, maybe there's another way. the issue is that the response will return {"arguments": []), when the expected type is Response (), it should parse the [] there as ()
12:52:00 <NemesisD> so basically, my FromJSON instance, when a :: () should disregard what the value of "arguments" is
12:52:15 <Saizan> when a = ()
12:52:42 <NemesisD> yeah
12:54:16 <NemesisD> is there another way to do it if specializing it to () is out of the question?
12:54:28 <monochrom> hold on, should it be a parse error instead?
12:55:15 <NemesisD> monochrom: if you are trying to parse a Response (), and it gets {"arguments": []} it should parse to Response ()
12:55:41 <NemesisD> in fact, if you are expecting a Response () and it gets {"arguments":a bunch of other stuff} it should still parse as Response ()
12:56:24 <NemesisD> for that specific case, it should be a parser that always pases provided there is an arguments key, then it disregards the value
12:56:35 <Saizan> NemesisD: maybe you could define your own data Unit = Unit and make an instance of FromJSON for it that doesn't actually look at the json input
12:57:01 <Saizan> and use Response Unit rather than Response ()
12:58:00 <NemesisD> Saizan: that's one possibility, maybe i can even newtype Unit so i can declare an instance of FromJSON for it and under the covers i can convert Response Unit -> Response ()
12:58:45 <Saizan> NemesisD: yeah, if you prefer
12:59:11 <NemesisD> i've been doing a lot of glue instances like this with newtypes for this project
13:00:01 <Saizan> well, it's not unusual to have to define your own types (or newtypes)
13:00:29 <hpaste> “`ramses” annotated “Neighbors” with “Neighbors (annotation)” at http://hpaste.org/81286#a81287
13:04:33 <x7a1c0b> I was just wondering… How exactly is the Integer type implemented in Haskell?
13:05:00 <NemesisD> Saizan: i'm learning that. thanks, your suggestion works perfectly!
13:05:14 <Saizan> cheers :)
13:06:05 <Saizan> x7a1c0b: in GHC it's implemented as a machine integer for small ones or using GMP if it gets larger
13:06:15 <uniquenick> if I have a function that returns Maybe (IO a), how do I use it in main to get at the a?
13:06:41 <Saizan> uniquenick: you've to decide what to do in case of Nothing
13:07:19 <uniquenick> right, I was going to use case and on Nothing I putStrLn "some error message"
13:07:23 <Maxdamantus> you'f
13:07:32 <uniquenick> but I don't know what to do for the Just case
13:08:01 <x7a1c0b> (Just a)
13:08:16 <Saizan> uniquenick: so it'd look like "case foo of Nothing -> putStrLn "error"; Just m -> do a <- m; ..use a here.."
13:08:29 <uniquenick> oh, start a new do
13:08:39 <Maxdamantus> @hoogle Maybe a -> a -> a
13:08:40 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
13:08:40 <lambdabot> Prelude asTypeOf :: a -> a -> a
13:08:40 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
13:08:41 <Saizan> yeah, nested in the case
13:09:13 <Maxdamantus> fromMaybe (putStrLn "error") (f x)
13:09:42 <`ramses> uniquenick: maybe (putStrLn "error") (>>= "use a")
13:10:34 <nejucomo> I see many "blaze" packages...  but I can't tell from any descriptions what the core concept or technology is.
13:11:08 <nejucomo> Actually if I could see a graph of package dependencies, I could find the root package with "blaze" in the name, then read it's source/api.
13:11:32 <nejucomo> I think for now I'll use good ol' bytestring.
13:11:36 * ski thinks `fromMaybe' probably doesn't fit well here
13:12:31 <Saizan> nejucomo: it should be blaze-builder
13:12:54 <nejucomo> Actually I should just pose the question here:  What's the best strategy/library/types for decoding and encoding fixed (word) size ints from a byte sequence?
13:13:00 <nejucomo> Saizan: Thanks.
13:13:15 <nejucomo> -especially if I'm concerned about memory and speed.
13:13:19 <Saizan> bytestring has its own Builder built-in now though, it seems
13:13:50 <mreh> nejucomo, could use castPtr
13:13:57 <Saizan> nejucomo: something like "binary"
13:15:12 <nejucomo> Hm.  I'd almost like to see a performance comparison between the myriad binary codec options.
13:15:21 <bgamari> Is the pipes author around?
13:16:29 <Saizan> nejucomo: i think thry are mostly about different features/performance tradeoffs
13:16:54 <Saizan> nejucomo: e.g. binary doesn't have backtracking on the parsing side
13:17:21 <nejucomo> Interesting.
13:18:13 <nejucomo> I want to learn more about haskell performance, so I am thinking of writing multiple implementations of a cryptographic hash function using different libraries, then comparing their performance.
13:18:31 <mreh> how could I combine functions that return differently typed error values (e.g. Either) with a monad?
13:19:28 <nejucomo> mreh: I am not confident about this, but you may be able to use an ErrorT embedded in another ErrorT ?
13:19:38 <Saizan> mreh: http://hackage.haskell.org/package/control-monad-exception
13:19:49 <mreh> ah, yes, I remember
13:19:53 <mreh> ta
13:19:54 <danzat> Hey, I tried implementing an un-LZEXE algorithm in Haskell, and I'm looking for someone to look at it, anyone up for it? (it isn't long)
13:20:43 <danzat> I'm pretty new in this, so there are bound to be obvious mistakes I made
13:21:03 <hpaste> danzat pasted “unlzexe” at http://hpaste.org/81288
13:29:28 <uniquenick> has anyone here used the hS3 module to talk to amazon s3 successfully?
13:36:26 <EvanR> so im trying to generate a random signal using a seed and the point in the signal as inputs
13:36:44 <EvanR> how do i do this without generating a ton of values leading up to that point?
13:36:47 <EvanR> like an RNG does
13:43:41 <nejucomo> EvanR: What is a signal, and what is a point in the signal?
13:44:17 <nejucomo> Do you want a deterministic but high entropy sequence seeded by a small input which takes constant memory?
13:44:55 <nejucomo> If so, I'd look up cryptographic prngs.
13:45:37 <Eduard_Munteanu> Is there any particular idiom for checking whether a TVar/MVar/IORef etc. changed contents?
13:46:25 <Eduard_Munteanu> I suppose I could use tryTakeMVar. Any better ideas?
13:49:57 <x7a1c0b> Does anybody know how Data.Bits.complement works? I managed to implement this function for Int s but i have no idea how to do this for Integer s
13:50:27 <c_wraith> x7a1c0b: it's not really defined for Integer, since Integer is arbitrary-precision
13:50:29 <Eduard_Munteanu> x7a1c0b: you can't
13:51:01 <x7a1c0b> > Data.Bits.complement (2^1912+2^45)
13:51:02 <lambdabot>   -37098103586245758361511665506205066402614246341673873727656623566634830580...
13:51:03 <byorgey> sure you can
13:51:10 <x7a1c0b> how come this works then?
13:51:25 <byorgey> it makes perfect sense if you treat the Integers using 2's complement
13:51:27 <Eduard_Munteanu> Int has a fixed size. For integer, you'd end up with an infinite number of leading 1s no matter what the input is.
13:51:33 <nejucomo> hehe...  I have no idea what that complement represents.
13:51:37 <c_wraith> You have to assume 2's complement
13:51:43 <byorgey> right, in 2's complement, an infinite number of leading 1's corresponds to a negative value
13:52:06 <nejucomo> In order to assume 2's complement, you must also assume all positives are preceded by a single 0 bit?
13:52:22 <byorgey> nejucomo: by infinitely many 0 bits
13:52:22 <c_wraith> nejucomo: no.  All positives start with infinite 0 bits.
13:52:46 <nejucomo> Then what output is lambdabot showing?
13:53:09 <c_wraith> > Data.Bits.complement (0::Int)
13:53:09 <nejucomo> > Data.Bits.complement (0 :: Integer)
13:53:11 <lambdabot>   -1
13:53:11 <lambdabot>   can't find file: L.hs
13:53:22 <byorgey> > Data.Bits.complement (1 :: Integer)
13:53:24 <lambdabot>   -2
13:53:27 <c_wraith> nejucomo: do you know how 2's complement works?
13:53:28 <x7a1c0b> So far i managed to get the bit representation of any Integer, but theres no way to create the complement for that bitstring
13:53:31 <byorgey> @go twos complement
13:53:31 <lambdabot> Maybe you meant: google googleit do
13:53:35 <nejucomo> > Data.Bits.complement ((-1) :: Integer)
13:53:36 <byorgey> @google twos complement
13:53:37 <lambdabot>   0
13:53:38 <lambdabot> http://en.wikipedia.org/wiki/Two's_complement
13:53:54 <nejucomo> c_wraith: Yes.
13:54:06 <byorgey> x7a1c0b: right, you can't do it by directly working with bit strings.
13:54:16 <byorgey> x7a1c0b: read the above wikipedia page.
13:55:12 <byorgey> nejucomo: "Then what output is lambdabot showing?" -- I don't understand your question.  Which lambdabot output are you confused about?
13:55:16 <Eduard_Munteanu> Also, that (-1) doesn't have a bit representation anyway.
13:55:25 <nejucomo> So Integer has some representation trick which means "all preceding bits are 0" or "all preceding bits are 1" ?
13:56:00 <Eduard_Munteanu> nejucomo: equivalently it just has a sign value somewhere
13:56:00 <nejucomo> Where "preceding" means "more significant"?
13:56:04 <byorgey> it really has very little to do with how Integers are actually represented.
13:56:31 <byorgey> for the purposes of the Bits instance, we abstractly think of Integers as half-infinite sequences of bits in two's complement
13:58:01 <x7a1c0b> byorgey i'm assuming you wanted to point me to the mathematical formula: 2^n - |x| ?
13:58:52 <Eduard_Munteanu> That doesn't sound right.
13:59:11 <byorgey> x7a1c0b: that gives the negation, not the complement
13:59:14 <EvanR> nejucomo: i want a sequence, but i want to calculate any point in the sequence without calculating the entire thing
13:59:29 <EvanR> the input (sequence index) is arbitrarily large
13:59:33 <nejucomo> I think this bit from the wiki clarifies my confusion: "One should be cautious when using the term two's complement, as it can mean either a number format or a mathematical operator."
13:59:38 <byorgey> x7a1c0b: I just intended to point you to something explaining how two's complement works.  I didn't have a particular part of the page in mind.
13:59:59 <nejucomo> EvanR: Ah, I see.  Then the kind of prngs I suggested would not help.
14:00:05 <byorgey> EvanR: and how is the sequence defined?
14:00:13 <monochrom> same for "factorial" actually
14:00:23 <EvanR> for the sake of argument, its random
14:00:27 <x7a1c0b> > Data.Bits.complement (2^1912+2^45) + (2^1912+2^45)
14:00:29 <lambdabot>   -1
14:00:32 <EvanR> uniformly distributed between 0 and 1
14:00:39 <x7a1c0b> yeah, this does not make sense
14:00:48 <nejucomo> EvanR: In that case, would a hash function suffice?
14:01:11 <byorgey> EvanR: if it's really random, then just return a random number no matter what index into the sequence is requested (and hash ones you've returned so you can be consistent later)
14:01:14 <c_wraith> x7a1c0b: in a two's complement representation, the complement of 0 is always -1, regardless of the number of bits
14:01:18 <Eduard_Munteanu> Actually complement should be 1's complement.
14:01:25 <EvanR> byorgey: theres also a seed
14:01:26 <Eduard_Munteanu> Not sure why 2s complement was mentioned.
14:01:30 <byorgey> or use a hash of the index like nejucomo suggests
14:01:43 <EvanR> yeah a hash i think thats the answer
14:01:44 <Eduard_Munteanu> 2's complement is negation, 1's complement is inverting all bits.
14:01:55 <x7a1c0b> Eduard_Munteanu 2s complement is used to represent negative numbers
14:02:00 <nejucomo> EvanR: convertBytesToNormalizedReal ( hash( seed ++ index ) )
14:02:00 <byorgey> EvanR: well why didn't you say that in the first place when I asked how the sequence is defined!
14:02:07 <EvanR> then to get a smoothed signal i can apply a filter window
14:02:18 <byorgey> =)
14:02:23 <Eduard_Munteanu> x7a1c0b: not necessarily for Integer though
14:02:33 <nejucomo> I guess seed and index are converted to bytes also.
14:03:00 <c_wraith> Eduard_Munteanu: however, the Bits instance for Integer treats it as if it was 2's complement. (that's the only way for Bits to really make sense with an unbounded type)
14:03:05 <byorgey> Eduard_Munteanu: the 'complement' operation on Integer inverts all bits.  The question is what Integer the result represents.
14:03:13 <Eduard_Munteanu> x7a1c0b: so the only meaningful way to get that complement is to implement it in terms of arithmetic operations and sign.
14:03:19 <EvanR> cooooool
14:04:00 <nejucomo> If you want seed to be secret and you want to guarantee the ability to verify a sequence output as coming only from knowledge of the seed, then hash(seed ++ index) is not sufficient...
14:05:16 <nejucomo> I feel like for two's complement to make sense, you must have knowledge of the representation, so you have to know the Integer representation...
14:05:21 <EvanR> what?
14:05:43 <EvanR> seed doesnt need to be secret
14:05:58 <nejucomo> EvanR: then hash(seed ++ index) is good enough.
14:06:27 <EvanR> i dont think any question about random number generation should instantly escalate to cryptographic security
14:06:31 <c_wraith> nejucomo: no, actually. That's why two's complement is the best. Internal representation is irrelevant, because you can implement the operation with arithmetic. complement n = negate (n + 1)
14:06:42 <Eduard_Munteanu> byorgey: hmmm... I'd say -infinity, since it should be lim n -> inf  -(2^n - x)
14:07:24 <c_wraith> nejucomo: as opposed to a one's complement representation, where the number of leading 0s (not counting the sign bit) change the result.
14:07:28 <Eduard_Munteanu> I guess there's no such Integer.
14:07:40 <nejucomo> EvanR: I don't think any question about random number generation should instantly dismiss cryptographic security - unless you know the intended use cases really well and communicate them really well.
14:08:02 <EvanR> thats silly
14:08:08 <nejucomo> c_wraith: Ah, interesting.
14:08:11 <EvanR> not everything is by default secret
14:08:20 <EvanR> i would say the opposite
14:08:32 <byorgey> Eduard_Munteanu: the answer (as implemented in Data.Bits) is to interpret the resulting infinite bit string using a two's complement representation.
14:08:48 <EvanR> the importance of secrecy is a result of moral social issues and not math
14:09:11 <x7a1c0b> c_wraith Afaik the reason why 2s complement is used is because it's internal representation is so useful (i'm talking about imperative languages)
14:09:40 <x7a1c0b> as in 5 - 5 = 5 + (-5)
14:09:56 <Eduard_Munteanu> byorgey: hm as if the leading bits were sign extended to infinity? (i.e. the sign bit is actually an infinite number of 1s)
14:10:16 <nejucomo> EvanR: Sure, so long as the users of the software understand the secrecy guarantees.  There's no need to consider secrecy if you're certain people won't depend on secrecy.
14:10:20 <c_wraith> x7a1c0b: well, it's more about properties of the representation under sign extension
14:10:22 <Eduard_Munteanu> > Data.Bits.complement (2 :: Integer)
14:10:24 <lambdabot>   -3
14:11:11 <c_wraith> x7a1c0b: which is the exact same reason the representation is a good model for infinite precision - you can sign-extend it trivially whenever you want.
14:11:13 <EvanR> i think people should depend on openness :)
14:11:29 <x7a1c0b> > let complement a = a - 2*a -1 in complement (2^192) == Data.Bits.complement(2^192)
14:11:30 <lambdabot>   True
14:12:02 <nejucomo> Sometimes the needs of users may surprise the developers.  For example, devs of pidgin enable chat logging by default, because it's poor user experience to realize after the fact you've lost something...
14:12:17 <nejucomo> -but there's also an OTR plugin which encrypts chat sessions.
14:12:31 <nejucomo> Users who installed OTR did not realize it did not disable logging.
14:12:35 <c_wraith> @check let complement n = negate (n + 1 :: Integer) in \x -> complement x == Data.Bits.complement x
14:12:37 <lambdabot>   Not in scope: `myquickcheck'
14:12:45 <EvanR> its ok
14:12:46 <c_wraith> ..  who broke the @check command!
14:13:04 <nejucomo> A large flamewar ensued between those who felt usability was more important than privacy.  Hard to evaluate the trade-offs.
14:13:31 <Philippa> heh. It shouldn't disable logging, it /should/ give an option to prevent logging of OTR conversations only
14:13:38 <Philippa> (and it should highlight it!)
14:14:09 <c_wraith> Also, there should be a first-use flag when you use OTR that says "by the way, you're logging this, click to disable..."
14:14:10 <nejucomo> I'm not arguing that secrecy needs to be analyzed all the time, I'm arguing that it should be mentally, intentionally neglected, rather than neglected by lack of awareness.
14:14:21 <nejucomo> Philippa, c_wraith: I totally agree.
14:14:24 <Eduard_Munteanu> Or you could assume the user encrypts his data.
14:14:31 <nejucomo> Sadly, pidgin + otr doesn't do this, last I checked.
14:14:34 <monochrom> I propose the old school way of, at installation time, asking the user a million configuration questions
14:14:34 <schellsan> are there any big differences between haskell platform for debian compared to ubuntu?
14:14:45 <nejucomo> monochrom: hehe...
14:14:47 <c_wraith> schellsan: no differences at all
14:14:52 <EvanR> nejucomo: done
14:14:58 <EvanR> neglected
14:14:59 <nejucomo> ;-)
14:15:02 <nejucomo> Thanks.
14:15:03 <schellsan> c_wraith: coolio, thanks
14:15:15 <Eduard_Munteanu> But yeah, a big warning is a good idea anyway.
14:15:16 <monochrom> but seriously, there is a fundamental contradiction between "don't ask me a million question" and "do what I want"
14:16:01 <monochrom> human user, you have a USB 3.0 port on your head yet? no? then sorry, finding out what you want is going to be a low-bandwidth process
14:16:10 <Eduard_Munteanu> GNOME's gone down that latter path lately.
14:16:25 <nejucomo> I wonder if the designers of Java's Random or python's random explicitly thought: "Well, this should never be used for security purposes.", or just neglected it.
14:16:41 <Philippa> monochrom: yeah, and this one's big enough to warrant asking because encrypted logs are a sensible strategy too
14:17:09 <EvanR> rngs in basically every programming language stdlib are horrible, for way more reasons than crypto security
14:17:14 <Eduard_Munteanu> nejucomo: if it's described as a PRNG, that's enough of a warning :)
14:17:17 <EvanR> their apis suck
14:17:58 <monochrom> I'm pretty sure most prng lib authors explicit have "not for cryptography" in mind
14:18:07 <EvanR> exactly
14:18:12 <danzat> Hey, can anyone here please look at a short program I wrote and give my some improvement suggestions?
14:18:14 <Eduard_Munteanu> Especially Java applets, which might not (shouldn't?) get access to all entropy available.
14:18:19 <c_wraith> The thing is, cryptography isn't the only problem.
14:18:26 <monochrom> and some of them have "statistically adequate" in mind but still fail
14:18:37 <c_wraith> There are issues with *games* and PRNGs
14:18:59 <c_wraith> One of my friends in college abused the crap out of the PRNG in the NAO nethack tournament one year
14:19:00 <Eduard_Munteanu> c_wraith: heh, yeah, I hear they used biased PRNGs to make things seem more fair.
14:19:04 <Philippa> danzat: put it on hpaste?
14:19:05 <Philippa> @hpaste
14:19:05 <lambdabot> Haskell pastebin: http://hpaste.org/
14:19:24 <monochrom> for the most part, the common expectation is "statistically adequate, and fast enough". (this actually implies "not for cryptography", at least in practice most of the time)
14:19:35 <Eduard_Munteanu> The average Joe has a different notion of "random".
14:19:38 <Philippa> Eduard_Munteanu: biasing the distribution is fair enough, that's not the 'problem' in games
14:19:55 <danzat> http://hpaste.org/81290
14:20:02 <c_wraith> He calculated every starting position during the duration of the tournament, isolated the ones that'd leave him a wand of wishing on the first level, and set up a script to start games at those times.
14:20:04 <Philippa> (you should state you've done it, but I've played plenty of board games with intentionally biased dice!)
14:20:16 <Eduard_Munteanu> Philippa: oh, is there some other problem?
14:20:30 <monochrom> oh haha c_wraith that's clever!
14:20:46 <danzat> Philippa, thanks
14:20:57 <hughfdjackson> what's the easiest way to download ghc/ghci + cabal on mac osx 10.8?
14:21:04 <c_wraith> *that* is a problem with just assuming your default PRNG is good enough even in your insecure use case.
14:21:06 <danzat> Philippa, it's supposed to extract data compressed using LZEXE
14:21:09 <hughfdjackson> :/ every angle i attack it, something seems to break
14:21:17 <Eduard_Munteanu> Ah, yeah, I guess you can exploit predictable generators.
14:21:34 <hughfdjackson> (not a useful situation report, i understand - but i'm wondering if anyone has been through it before)
14:21:36 <Philippa> Eduard_Munteanu: and you might want a /repeatable/ generator for network play
14:22:21 <schellsan> hughfdjackson, is the haskell platform .dmg not helping?
14:23:09 <Eduard_Munteanu> Philippa: hm, why? So all players get a consistent state?
14:23:14 <nejucomo> c_wraith: But the nethack tournament was not an "insecure use case", right?
14:23:26 <hughfdjackson> schellsan: http://lambda.haskell.org/platform/download/2012.4.0.0/Haskell%20Platform%202012.4.0.0%2032bit.pkg kept telling me there was a later cabal on cabal update
14:23:45 <c_wraith> nejucomo: the authors of nethack were writing a game that didn't care about security.  Other people came along with other assumptions, and used the same software.
14:23:47 <hughfdjackson> :P then failing on cabal install cabal-install
14:23:53 <Philippa> Eduard_Munteanu: right, without having to communicate all the random details
14:24:02 * nejucomo notices an excessive feeling of soap-boxiness, then realizes his coffee to food ratio has entered the red zone.
14:24:04 <schellsan> ahh - i've gotten that too and i don't recall how i got past it...
14:24:20 <Philippa> c_wraith: hell, the point of nethack is to sploit the hell out of it
14:24:34 <nejucomo> c_wraith: yeah, so the security concern is always contextual with the use....  of to get food.
14:26:40 <hughfdjackson> schellsan: i may just install the 64 bit package - which is actually the 'right one'
14:26:57 <Eduard_Munteanu> Interesting thought... if you had quantum stuff and a good RNG, I suspect you could sell entropy. And the buyer should be able to tell if you tried to clone it, no?
14:27:00 <hughfdjackson> i just had vague memories of it failing a month back
14:27:20 * Eduard_Munteanu envisions entropycoins :P
14:27:49 <schellsan> hugh: what's the harm in that? :)
14:28:19 <Philippa> Eduard_Munteanu: qubitcoins?
14:28:23 <hughfdjackson> schellsan: :D none! just a little impatient to kick off my playing with haskell web frameworks while there's still a weekend to be had
14:28:30 <Eduard_Munteanu> Heh, yeah, that sounds better.
14:28:33 <monochrom> hahaha qubitcoins
14:28:45 <adnap> It seems like Hackage doesn't have a convenient way to browse the source code for a project through the web browser like GitHub. Do you think this is a bad thing? One can always download the source code and look at it.
14:29:08 * monochrom elides "bitcoins in a box" jokes
14:29:19 <Saizan> you get source links from the haddock
14:29:35 <adnap> I am aware of the source links. I wouldn't call them "convenient"
14:30:04 <adnap> The reason is that you cannot easily navigate a directory structure this way
14:30:10 <lispy> If the package lists a github repo I visit that to find out whats in it. Otherwise I look at the source from the haddocks.
14:30:10 <Eduard_Munteanu> Entropy sounds rather valuable and a bit difficult to get. I'm not sure how quantum stuff could make sure it's good quality entropy though.
14:30:12 <Saizan> i guess a directory view wouldn't hurt
14:30:42 <adnap> I think perhaps this feature of GitHub is not necessary
14:31:10 <mreh> would I be able to adapt an imperative API to be used as netwire wires? turn callback results into producers, turn function calls into sinks, that sort of thing
14:31:24 <adnap> It is nice for quick peeks to satisfy small curiousities, but if I am going to work on something, I will download the source code
14:31:26 <lispy> I find that the haddocks are almost always useless and these days I go straight to the source.
14:32:03 <monochrom> I write useful doc in haddock
14:32:05 <adnap> What is the deal with haddocks not always being generated on Hackage? Sometimes a package wont have documentation unless you go back to a really old version
14:32:15 <monochrom> then again, I don't write much lib for you :)
14:32:23 <mauke> adnap: if it doesn't compile, there is no documentation
14:32:35 <mauke> adnap: also, there's some delay because they're compiled in batches
14:32:51 <Nereid> @let zipWith''  f _ _ xs [] = map f xs; zipWith'' _ g _ [] ys = map g ys; zipWith'' f g h (x:xs) (y:ys) = h x y : zipWith'' f g h xs ys
14:32:54 <lambdabot>  Defined.
14:32:56 <adnap> mauke: Is the converse true?
14:32:57 <monochrom> but see my http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html for how I write doc
14:32:59 <Nereid> @let zipWith' = zipWith'' id id
14:33:01 <lambdabot>  Defined.
14:33:17 <Nereid> > zipWith' (+) [a,b] [c,d,e]
14:33:20 <lambdabot>   [a + c,b + d,e]
14:33:25 <monochrom> hmm! the example there should be one of those new-fangled doctest thing!
14:33:27 <Nereid> > zipWith'' id negate (-) [a,b] [c,d,e]
14:33:29 <lambdabot>   [a - c,b - d,negate e]
14:34:02 <Nereid> :t zipWith'' (:[]) id (:) -- zipCons as used in Control.Monad.Omega
14:34:03 <lambdabot> [a] -> [[a]] -> [[a]]
14:34:08 <Nereid> handy.
14:34:34 <Nereid> @let zipCons = zipWith'' (:[]) id (:)
14:34:36 <lambdabot>  Defined.
14:34:44 <Nereid> > zipCons [a,b] [[c,d],[e,f],[g,h]]
14:34:47 <lambdabot>   [[a,c,d],[b,e,f],[g,h]]
14:35:07 <Nereid> everyone should use zipWith''
14:35:40 <mreh> :t zipWith''
14:35:41 <lambdabot> (a -> b) -> (a1 -> b) -> (a -> a1 -> b) -> [a] -> [a1] -> [b]
14:35:54 <mreh> eh
14:36:24 <Nereid> it's kind of like zipWith, but it uh
14:36:31 <Nereid> doesn't cut off the longer of the two lists.
14:36:34 <mreh> i'm trying to parse the definition
14:36:39 <mreh> oh
14:36:51 <Nereid> instead it uses one of the arguments to say what to do with the longer one.
14:37:01 <Nereid> see zipWith' (+)
14:37:06 <Nereid> :t zipWith'
14:37:07 <lambdabot> (b -> b -> b) -> [b] -> [b] -> [b]
14:38:00 <Nereid> I could have defined zipWith' f xs [] = xs; zipWith' f [] ys = ys; zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
14:38:11 <Nereid> zipWith'' is an abstraction of that
14:39:01 <Nereid> because zipWith' (-) doesn't do what you want if you're trying to subtract lists, with the assumption that a finite list should be treated has having infinitely many trailing zeros.
14:39:13 <Nereid> > zipWith' (-) [1,2] [3,4,5]
14:39:15 <lambdabot>   [-2,-2,5]
14:39:22 <Nereid> > zipWith'' id negate (-) [1,2] [3,4,5]
14:39:24 <lambdabot>   [-2,-2,-5]
14:39:36 <Nereid> er, subtract lists entrywise.
14:40:51 <Nereid> :t (,0) -- do we have that?
14:40:52 <lambdabot> Illegal tuple section: use -XTupleSections
14:40:56 <Nereid> nope.
14:41:14 <Nereid> > zipWith'' (flip (,) 0) ((,) 0) (,) [1,2] [3,4,5]
14:41:16 <lambdabot>   [(1,3),(2,4),(0,5)]
14:41:18 <Nereid> > zipWith'' (flip (,) 0) ((,) 0) (,) [1,2,3] [4,5]
14:41:20 <lambdabot>   [(1,4),(2,5),(3,0)]
14:43:44 <hughfdjackson> schellsan: :p back in the loop of cabal upgrade -> cabal install cabal-install
14:46:36 <Nereid> I wish I could have multiple top-level or instance definitions share a where clause.
14:47:10 <monochrom> I do too. I make do with... global definitions! (and good export lists)
14:47:21 <Nereid> that doesn't work here.
14:47:24 <jocolloman> Is there documentation on how to "properly" document with haddock? Is there some kind of standard?
14:47:32 <Nereid> what I want to put in the where clause depends on a type parameter.
14:47:36 <monochrom> then I have a cunning plan!
14:48:16 <Nereid> so there would be no gain at the top level without ScopedTypeVariables I guess.
14:48:21 <monochrom> (f1, f2, f3) = (body1, body2, body3) where this_object_can_be_used_in_all_3_bodies = True
14:48:50 <monochrom> (pun! 3-body problem... :) )
14:49:04 <Nereid> doesn't work in instance
14:49:08 <nejucomo> Nereid: This is horrible, but: (f, g) = (f, g) where ...    ?  (I'm not even sure if this works.)
14:49:13 <monochrom> ok darn, that's too bad
14:49:41 <nejucomo> Ah, I'm behind.
14:50:28 <monochrom> your re-using names also works. (f,g) = (f,g) where {f=body1; g=body2...}
14:50:33 <nejucomo> Are there any drawbacks to ScopedTypeVariables?
14:50:43 <monochrom> I think none
14:50:45 <Nereid> not really
14:51:05 <monochrom> apart from "more work for the compiler writer"
14:51:50 <nejucomo> I guess except for the case when someone really wants to reuse a type parameter name without synonymous meaning.
14:51:57 <Nereid> basically I'm writing an instance for a data type with a parameter of kind Nat, and I want to write a Num instance where the methods use that number.
14:52:07 <monochrom> I am now a bit puzzled. haddock has this ">>> fib 10" markup. what does it really do?
14:52:13 <Nereid> so I have to write ... where n = fromSing (sing :: Sing n) for each method that uses n.
14:52:22 <Nereid> is that a doctest?
14:52:25 <nejucomo> If I didn't want the compiler writer to do much work, I'd use lua or javascript.  :-p
14:52:42 <monochrom> haha
14:53:06 <Maxdamantus> or Brainfuck.
14:53:10 <monochrom> it is not a doctest. I deliberately write a wrong answer in the doc. no error message
14:53:20 <Nereid> well, haddock doesn't run the doctests :p
14:54:00 <monochrom> ah, I guess some other program cares about the answer
14:54:05 <nejucomo> What are the runtime overhead differences for: type A = (S, T) \n newtype A = A S T \n data A = A S T   (ghc-specific is fine.)
14:54:07 <Nereid> nejucomo: I wrote a haskell compiler from scratch the other day.
14:54:13 <Nereid> it has two issues though
14:54:25 <nejucomo> Nereid: Sweet!  That sounds fun.
14:54:27 <Nereid> 1. no IO; 2. also accepts syntactically invalid programs
14:54:33 <Nereid> it compiles very fast though!
14:54:48 <nejucomo> Did you use the standard haskell parser, or write one from scratch?
14:55:06 <Nereid> it's a joke.
14:55:08 <nejucomo> That reminds me...  I need to learn how type checking actually works.
14:55:20 <Nereid> I shouldn't have said syntactically.
14:55:22 <nejucomo> I have "Typing Haskell in Haskell" sitting around here somewhere...
14:55:26 <Nereid> it accepts any invalid (and valid) program.
14:55:54 <nejucomo> Ah, I see.
14:56:05 <monochrom> nejucomo: the newtype is disallowed. (S,T) and data A = A S T have the same cost
14:56:10 <nejucomo> Well, since I don't want you do to much work, maybe I'll use that instead of ghc.
14:56:18 <Nereid> :p
14:56:46 <nejucomo> monochrom: Doh..  Ok, how about: newtype A T \n data A = A T ?
14:56:57 <monochrom> then the newtype costs less
14:57:14 <Nereid> it also has subtly different semantics
14:57:41 <monochrom> yes, it is also different at a corner case. but I hope most people do not use the corner case
14:58:14 <nejucomo> Is the cost difference because there's an extra reduction needed to "reduce past" the A constructor?
14:58:26 <Nereid> I guess you could say that.
14:58:38 <Nereid> a newtype has the same internal representation as the underlying type.
14:58:55 <nejucomo> If both were fully reduced, would they have the same memory size?  (Same layout even?)
14:59:14 <Nereid> the data version still has the constructor lying around.
14:59:18 <monochrom> "data A" spends memory and indirection for the "A" ctor
15:00:02 <nejucomo> Ok, returning to the comparison between a tuple and a datatype, does the tuple have "tuple ctor" overhead?
15:00:19 <monochrom> yes. it's why same cost as your own "data A"
15:00:37 <nejucomo> If I care about performance, can I think of (A, B) and data T = T A B as costing the same?
15:00:48 <Nereid> tuples could be defined, if it were syntactically valid, as data (,) a b = (,) a b
15:00:51 <Nereid> yes
15:00:55 <monochrom> therefore, if your own "data A" makes your code read better for you, go for it
15:00:57 <nejucomo> Ok.
15:01:25 <nejucomo> Can't the ctor overhead be removed in the case there is only one ctor / variant?
15:02:14 * nejucomo thinks about: data T = T (IO ())
15:02:14 <S11001001> which isn't to say that `dimap tToTuple tFromTuple . first' is as cheap as `first'
15:02:25 <monochrom> cannot. haskell semantics requires "case A undefined of A _ -> ()" to be (), not abort. to support that, you must spend the overhead of the ctor
15:03:10 <nejucomo> monochrom: Ah, that helps.  Thanks.
15:03:16 <Ralith> nejucomo: if you care about performance, you should not take action without strong profiling-derived evidence.
15:03:27 <Ralith> especially not at the cost of readability
15:03:33 <nejucomo> Ralith: I'm hunting for heuristics.
15:03:57 <Ralith> heuristics work better on things like computational complexity than microopts.
15:04:50 <nejucomo> Ralith: Ok.  In fact, I wanted to write multiple implementations of a pure computation over a large input, using different designs, then to profile them.
15:05:01 <monochrom> I don't worry about how you use this knowledge. I know that you will use it wisely. :)
15:05:09 <nejucomo> hehe...
15:06:03 <nejucomo> Wait until you see my code which uses newtype A = A (C, B) and explicit continuation parameters everywhere because I believe a bunch of nonsence about microoptimizations.
15:06:05 <merijn> nejucomo: Since no one mentioned it yet and you want to do benchmarking: criterion :)
15:06:19 <nejucomo> Ok, good to know.
15:06:33 <merijn> It has pretty graphs!
15:22:29 <ag90> Suppose I have two predicates isFoo :: a -> Bool and isBar :: a -> Bool. Can I use arrows to make a function that &&s or ||s the two results?
15:22:58 <danr> ag90: you could use the ((->) r) monad and write liftM2 (&&) isFoo isBar
15:23:11 <danr> (or the applicative version (&&) <$> isFoo <*> isBar)
15:23:20 <ag90> Ah! The function monad.
15:23:24 <danr> do you specifically need to do it with arrows?
15:23:35 <ag90> I don't need to. I'm just playing around.
15:23:49 <ag90> I figured there's a more fun way than doing it manually.
15:23:59 <ag90> Thanks!
15:24:27 <danr> ag90: np :)
15:26:44 <monochrom> since the order of evaluation between (isFoo x) and (isBar x) does not matter, I wonder if Applicative helps
15:27:13 <danr> monochrom: in which way do you mean helps?
15:27:42 <monochrom> oh, you have already done  (&&) <$> isFoo <*> isBar, that does it
15:27:47 <danr> but it could matter, right? if isFoo x is _|_ but isBar x is False, you either get False or _|_ depending on which way you commute &&
15:28:08 <monochrom> ah, it matters in that case
15:29:12 <monochrom> > ((&&) <$> id <*> (const undefined)) False
15:29:14 <lambdabot>   False
15:29:16 <monochrom> \∩/
15:29:16 <Nereid> liftA2 (&&) isFoo isBar is better.
15:29:31 <monochrom> yeah
15:31:20 <Nereid> :t uncurry (&&) . ?isFoo &&& isBar
15:31:21 <lambdabot> Not in scope: `isBar'
15:31:22 <Nereid> :t uncurry (&&) . ?isFoo &&& ?isBar
15:31:23 <lambdabot> (?isFoo::a b (Bool, Bool), ?isBar::a b c', Functor (a b), Arrow a) => a b (Bool, c')
15:31:33 <Nereid> :t uncurry (&&) Prelude.. ?isFoo &&& ?isBar
15:31:34 <lambdabot> (?isFoo::b -> (Bool, Bool), ?isBar::b -> c') => b -> (Bool, c')
15:31:43 <Nereid> oh oops
15:31:45 <Nereid> :t uncurry (&&) Prelude.. (?isFoo &&& ?isBar)
15:31:47 <lambdabot> (?isFoo::a -> Bool, ?isBar::a -> Bool) => a -> Bool
15:31:58 <danr> Nereid: ah, nice, I'd forgotten that one
15:32:07 <Nereid> I'd prefer the Applicative version.
15:32:52 <danr> Me too, but I'd express it with <$> and <*>
15:32:58 <Nereid> :(
15:33:03 <danr> be happy :)
15:33:10 <Nereid> I'll only be happy if you use liftA2.
15:33:16 <danr> hm. ok maybe I will once
15:33:27 <ferg> \quit
15:33:34 <Nereid> /quit
15:33:48 <danr> maybe ferg thought we were silly
15:34:05 * Nereid wonders if gusto meant to quit.
15:34:16 <Nereid> whether.
15:35:04 <Philippa> I like <$> and <*> as an idiom in the absence of anything better, FWIW
15:39:15 * hackagebot edit-distance 0.2.1.2 - Levenshtein and restricted Damerau-Levenshtein edit distances  http://hackage.haskell.org/package/edit-distance-0.2.1.2 (MaxBolingbroke)
15:40:16 <Nereid> :t liftA2
15:40:18 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:47:42 <yunxing> hi hi
15:49:27 <yunxing> I wrote something like "let (first, last') = span p list                                  (first, last) = (first, tail last') in", is there any ways to write it more elegant ??
15:51:03 <yunxing> I just wanted to split a list into two part by element... like split c [a,b,c,d,e] into ([a,b], [d,e])
15:51:58 <ag90> yunxing: let (first, last) = second tail (span p list) can do this (import Control.Arrow (second)).
15:52:16 <cmccann> I'd use "second (drop 1)"
15:52:29 <mauke> fmap
15:53:07 <mauke> (first, _ : last)
15:53:55 <ag90> Hah
15:54:08 <ag90> I would go for mauke's solution.
15:54:16 <roSievers> Hi, is there a shorthand for " \x -> [42, x] "?
15:54:35 <Rembane> (42:x)
15:54:42 <mauke> @pl \x -> [42, x]
15:54:42 <lambdabot> (42 :) . return
15:54:42 <monochrom> no, that's wrong
15:55:06 <roSievers> Rembane: but x is not a list, it is just one element
15:55:07 <danr> :t (42:) . (:[])
15:55:08 <lambdabot> Num a => a -> [a]
15:55:25 <danr> maybe you should go for the lambda :)
15:55:29 <monochrom> I say, just write \x -> [42, x]
15:55:29 <mauke> even if it was, (42:x) is not shorter than [42,x]
15:55:32 <Rembane> roSievers: Sorry, got lost there :)
15:56:18 <monochrom> btw, I hate prolog for this: [42, x] in prolog is our 42:x
15:56:41 <frsoares> mauke: "\x -> 42:[x]" is one char shorter
15:56:49 <danr> monochrom: :p why would you hate Prolog for it?
15:56:51 <roSievers> ok, thank you :-)
15:57:07 <mauke> > length "\\x->42:[x]"
15:57:09 <lambdabot>   10
15:57:13 <mauke> > length "\\x->[42,x]"
15:57:15 <lambdabot>   10
15:57:21 <schellsan> what's the best way to install ghc on debian?
15:57:38 <monochrom> I thought the problem was self-evident
15:57:44 <schellsan> apt-get shows only ghc6
15:57:50 <danr> > length "(42:).pure"
15:57:51 <lambdabot>   10
15:57:54 <danr> drat
15:58:59 <yunxing> Ah, thanks!
15:59:01 <monochrom> I have this list literal, [42, 5]. unify with [42, X]. so X is not unified with 5? X is unified with [5]? this is inconsistency
15:59:40 <danr> monochrom: right when you put it that way it's quite stupid
16:00:59 <parcs> schellsan: use the generic ghc binary from haskell.org
16:01:14 <parcs> schellsan: it's built on a debian 6 machine so it should be perfectly compatible
16:01:29 <cmccann> monochrom: so I'll ask the obvious question, how do you express unifying with a list of known length instead?
16:01:51 <danr> I guess [42 | X | []] or something silly
16:02:17 <monochrom> I would just use haskell syntax. or sml syntax
16:02:23 <akoada> hi, can someone help me to write a monad instance of a type, that have an argument?
16:03:27 <schellsan> parcs: thanks
16:03:57 <schellsan> parcs: can the same thing be done with cabal?
16:05:42 <parcs> schellsan: i'd install cabal from debian's repos and then update it locally via 'cabal install cabal-install'
16:05:46 <schellsan> parcs: ah - i see - it's included
16:06:04 <schellsan> or not...
16:06:08 <schellsan> read that wrong...
16:09:46 <quchen> Does Parsec count line numbers somehow, or do I have to increment them manually in the user state? Can't make much sense of Parsec.Pos :-(
16:10:34 <Ralith> iirc it does
16:10:38 <Ralith> I forget how you access it though
16:10:53 <Ralith> (columns, too)
16:10:54 <quchen> Good to know, thanks
16:11:08 <monochrom> parsec counts line numbers. use getPosition, then souceLine
16:11:35 <Ralith> monochrom: dammit I just finished looking that up
16:11:35 <monochrom> sourceLine <$> getPosition
16:11:40 <quchen> Ah, thanks.
16:11:47 <Ralith> souceColumn too.
16:11:52 <monochrom> yeah
16:11:55 <Ralith> and sourceName!
16:11:58 <quchen> Searching for Parsec type sigs never works out for me :-(
16:13:08 <monochrom> if you import Text.Parsec, then you already have all of the above, so don't worry too much about Text.Parsec.Pos
16:18:45 <edwardk> > "hello"^.each.re (base 16 . enum)
16:18:47 <lambdabot>   "68656c6c6f"
16:19:24 <edwardk> > BSC.pack "hello"^.each.re (base 16 . enum)
16:19:27 <lambdabot>   "68656c6c6f"
16:21:06 <parcs> []
16:33:16 <ski> monochrom,danr : `[42,X]' in Prolog is not our `42:x'. `[42,X]' corresponds to `[42,x]' and `[42|X]' corresponds to `42:x'
16:34:05 <ski> (and `[X0,X1,X2|Xs]' corresponds to `x0:x1:x2:xs')
16:34:25 <sipa> and [X0|X1|X2] ?
16:35:01 <ski> illegal syntax
16:35:31 <sipa> ok
16:39:33 <ski> (.. so, unifying `[42, 5]' with `[42, X]', `X' *is* unified with `5', not with `[5]')
16:39:46 <cmccann> prolog syntax is really weird. by which I mean unfamiliar to me.
16:40:08 <ski> list syntax is just syntactic sugar (like in Haskell)
16:40:47 <ski> then there's operators (infix,prefix,postfix), which is also sugar
16:41:02 <danr> ski: ok thanks for clearing that up
16:42:40 <monochrom> thanks ski, but then I don't like the extra [] around 42|X
16:43:05 <monochrom> the reason is nested lists, e.g., haskells [42:x]
16:44:18 <ski> it can sometimes be nice to be able to go from `[A,B,C]' to `[A,B,C|L]' without having to change all the `,'s
16:45:12 <ski> `[ .. | .. ]' is really a mixfix operator on the `..'s
16:45:40 <ski> (with `[ .. , .. | .. ]',&c. being sugar on that)
16:45:47 <dmwit> ?hoogle m (a -> b) -> a -> m b
16:45:48 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
16:45:48 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
16:45:48 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
16:46:43 <cmccann> :t runKleisli . arr
16:46:44 <lambdabot> Monad m => (a -> b) -> a -> m b
16:46:55 <cmccann> clearly, the most sensible approach.
16:47:12 <cmccann> oh, you had another m in there. never mind.
16:47:28 <ski> newbies in Haskell often write `[x:xs]' instead of `(x:xs)' in patterns. i think which version you prefer is mostly a matter of taste, and what you're used to
16:48:11 <cmccann> ski: what seems to confuse people more is []
16:48:20 <ski> the empty list ?
16:48:30 <cmccann> and the list type constructor.
16:48:31 <elliott> I see [x:xs] all the time, yes
16:48:36 <cmccann> :t []
16:48:37 * dmwit swears lightly at data-default's instances for (e -> default) and IO default
16:48:38 <lambdabot> [a]
16:48:39 <elliott> people also like to handle [x] separately
16:48:39 <cmccann> :k []
16:48:40 <lambdabot> * -> *
16:48:41 <elliott> despite handling [] and (x:xs)
16:48:44 <elliott> for no reason
16:49:00 <cmccann> and then the fact that [x] has a wildly different meaning for values vs. types
16:49:05 <ski> yeah, i'm not really that happy of the `[T]' and `(T,U)' type syntax in Haskell
16:49:15 <dmwit> What do people do if *most* of the bits of a type are defaultable, but not all of them?
16:49:17 <ski> (s/of/with/ ?)
16:49:25 <elliott> dmwit: cry?
16:49:33 * dmwit cries
16:49:33 <cmccann> dmwit: what do you expect from data-default? something that makes sense? that's silly.
16:50:09 <monochrom> default :: b -> a
16:50:13 <monochrom> err
16:50:20 <monochrom> default :: a
16:50:24 <cmccann> ski: tuples are one thing, they have the same structure. same goes for ().
16:50:45 <monochrom> default = error "debt exceeds asset, you are bankrupt"
16:50:46 <ski> elliott : because they're not taught not to unfairly discriminate against zero cases
16:51:21 <ski> cmccann : i want to be able to express a tuple of types (very distinct from a tuple type)
16:51:58 <lispy> I found this the other day and I think it is a good resource for teaching how haskell works operationally: http://www.scs.stanford.edu/11au-cs240h/notes/ghc.html
16:52:10 <monochrom> I understand the phenomenon perfectly. people write (prose and programs) by stream of consciousness, not by design or organizing thought
16:52:15 <mikeplus64> ski: '(x,y,z) ?
16:52:35 <ski> mikeplus64 ?
16:52:45 <mikeplus64> is a type level tuple thing
16:52:48 <lispy> ski: data kinds
16:52:49 <cmccann> ski: in the context of Haskell-without-GHC-extensions I don't have a problem with it, since a tuple of types isn't very useful there.
16:53:13 <mikeplus64> >>> :k '(Int,"yes")
16:53:15 <mikeplus64> '(Int,"yes") :: (,) * GHC.TypeLits.Symbol
16:53:34 <mikeplus64> >>> :k '[Int,Double,Double]
16:53:37 <mikeplus64> '[Int,Double,Double] :: [*]
16:54:44 <ski> cmccann : i think it's unfortunate that it uses up the sensible choice for tuples at the record level, if we want to extend the language in that direction
16:55:16 <elliott> (,) working on constraints has caused problems
16:56:29 <ski> er, s/record level/type level/
16:56:30 <cmccann> there's no shortage of ways that various language extensions cause problems or trip over things that are a good idea in standard Haskell
16:57:07 <ski> in this case i'd argue that it's the other way around :)
16:58:13 <ski> mikeplus64 : interesting, ty
17:00:06 <ski> lispy : btw, did you see the tail end of the explanation i attempted the other day
17:01:19 <lispy> ski: sadly no.
17:01:30 <lispy> ski: but I won't be able to focus on it now either
17:01:54 <lispy> ski: I did finish reading one of the prolog in haskell papers and one on constraint logic programming
17:02:57 <lispy> ski: one of the papers explained this library: http://hackage.haskell.org/package/monadiccp
17:05:43 <ski> it's at 19:51:35 in <http://tunes.org/~nef/logs/haskell/13.01.22> if you want to look later (12 lines after you had to leave)
17:06:06 <ski> lispy : which paper was that ?
17:06:24 <lispy> ski: I forgot the author names, but they did the type safe version that used STRefs
17:06:58 <ski> Koen Claessen and Peter Ljunglöf ?
17:07:56 <lispy> ski: thanks for the link, I just saved the whole conversation in a file so I can read it again
17:08:05 <lispy> ski: That sounds right
17:08:53 <ski> (<http://www.cse.chalmers.se/~koen/>,<http://www.cse.chalmers.se/~peb/>)
17:09:33 <lispy> Has anyone here played around with converting Haskell to C# or F#? (basically anything that runs on the CLR)
17:10:08 <lispy> I found a paper phd thesis from the haskell .NET website, but that whole effort seems to have disappeared
17:10:58 <lispy> Getting Haskell to compile to a reasonable .NET-friendly-form would give a path towards mobile devices.
17:11:31 <lispy> monogame claims support on a rather wide variety of platforms and they do that all from C# AFAICT
17:11:41 <lispy> (hence my asking)
17:12:13 <dublisk> you want to convert haskell code to C# or F# code? or compile haskell to run on .net platform
17:12:54 <lispy> dublisk: the latter, possibly using the former as a vehicle
17:13:16 * cmccann would expect the JVM to be a more attractive target
17:13:32 <lispy> I realize it can be made more efficient by going staight there, but I'd be okay with slow code in the beginning
17:14:17 <lispy> cmccann: Kind of. JVM lacks tailcall, which isn't the worst thing ever but .NET would be more efficient and thanks to the mono project probably runs in just as many places
17:14:35 <dublisk> why not just use f#
17:14:46 <cmccann> f# is kinda painfully limited compared to Haskell
17:14:58 <lispy> purity by default comes with some great bonuses
17:15:04 <dublisk> it is? I would have thought the opposite
17:15:26 <cmccann> F# is not very expressive as far as ML-style languages go.
17:16:06 <cmccann> it has a very limited type system compare to Haskell, and also lacks a lot of interesting things available to OCaml, though I forget the details
17:16:24 <dublisk> you give a very compelling argument
17:16:48 <ski> cmccann : module functors
17:16:54 <cmccann> ski: that's the big one yes
17:17:12 <cmccann> I think there's other stuff too, but I'm not very familiar with ocaml at all
17:17:14 <lispy> F# does have one thing that Haskell has to work hard at: unit types
17:17:20 <lispy> At least, I think it has them
17:17:25 <dublisk> what are module functors
17:17:29 <cmccann> yeah, it does have a few interesting features of its own
17:17:47 <lispy> http://msdn.microsoft.com/en-us/library/dd233243.aspx
17:17:47 <ski> dublisk : you can write a module that takes a module as argument
17:17:50 <cmccann> but they're not that persuasive compared to what's missing vs. Haskell or OCaml, the two languages it's most heavily inspired by
17:17:59 <lispy> we have packages like dimensional but I've never tried them
17:18:09 <ski> dublisk : basically, a kind of function, on the module level
17:18:28 <cmccann> in particular, lacking both type classes and ocaml-style modules is pretty crippling from my perspective
17:19:02 <fragamus> what was inspired by haskell (just got here)
17:19:09 <ski> dublisk : e.g. you can make a module implementing something, that takes a module for priority queues as an argument. then you can swap implementations by changing the actual application of the module from passing one PQ implementation into passing another one
17:19:11 <cmccann> fragamus: F#
17:19:12 <lispy> cmccann: oh, so F# has no overloading whatsoever? Not even an OOP inspired variant that it gets from .NET?
17:19:26 <cmccann> lispy: it has... something
17:19:33 <cmccann> trying to recall the details, it's been a while since I played with F#
17:19:46 <lispy> I tried Scala once, but I haven't tried F# yet
17:20:08 <lispy> sticking with familiar abstractions would be nice
17:20:10 <ski> lispy : and "Active Patterns" <http://msdn.microsoft.com/en-us/library/dd233248.aspx>
17:20:53 <cmccann> I think there's something in F# where small inline-able functions can be overloaded on types kinda-sorta like type classes
17:20:56 <dublisk> I'm confused, isn't that just like OOP polymorphism
17:21:14 <cmccann> except less principles and only works in limited situations
17:21:43 <cmccann> anyway, F# is still a nice language.
17:21:46 <dublisk> so f# has polymorphism too, you can have abstract classes
17:21:59 <dublisk> brb
17:22:11 <cmccann> it's just very limited compared to most of the languages it resembles.
17:22:26 <lispy> Seems like using F# as the object language should make compiling haskell much easier than compiling to a traditional object language
17:22:51 <lispy> And yet, I can't find anything on google about it
17:22:54 <cmccann> lispy: by the same argument you could compile Haskell to Scala for the JVM
17:23:03 <lispy> ya
17:23:09 <cmccann> which nobody seems in a hurry to do either
17:23:15 * cmccann shrugs
17:23:28 <monochrom> now we finally understand what "object-oriented programming language" means. it means: makes a great object language!
17:23:34 <cmccann> monochrom: hahaha
17:23:40 <ski> dublisk : btw, "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf> might be interesting, to better understand (various kinds of) polymorphism
17:23:41 <lispy> Seems like a nice way to get the backend support in there and later versions you change the object language for performance reasons
17:23:50 <lispy> monochrom: :)
17:24:30 * cmccann wonders if a "typecheck with GHC, then ignore types and compile to clojure" approach along the same lines as Fay would be easier
17:24:30 <lispy> ?remember monochrom now we finally understand what "object-oriented programming language" means. it means: makes a great object language!
17:24:30 <lambdabot> I will remember.
17:24:55 <monochrom> inspired by both: (A) F# is an ok object language for haskell; (B) most abstractions (e.g., parameterized modules of ml) can be encoded as objects
17:24:58 <lispy> cmccann: js is pretty functional-friendly, as I understand it
17:25:09 <cmccann> clojure seems philosophically closer to haskell in many ways, despite being a lisp dialect
17:27:02 <lispy> I bet core could be translated pretty cleanly to F#
17:27:14 * lispy will have to meditate
17:27:51 <dmwit> Really? Doesn't core have a Pretty Exciting type system?
17:27:59 <lispy> no
17:28:15 <cmccann> also, .NET gives you plenty of ways to cheat the type system if you have to
17:28:23 <lispy> dmwit: http://www.aosabook.org/en/ghc.html
17:28:38 <dmwit> Really? I thought core's type system was roughly Fc, which has all kinds of wacky stuff like coercions.
17:28:50 <cmccann> which is bad for writing code directly, but less an issue for a compiler thing
17:29:19 <fragamus> transpose . (\(a,b) -> [a,b]) . (splitAt i)
17:29:33 <fragamus> any golfers?
17:29:44 <cmccann> lispy: of course, there's still the issue of FFI calls
17:30:14 <dmwit> \xs -> zip xs (drop i xs)
17:30:31 <dmwit> liftM2 zip (take i) (drop i)
17:31:07 <luite> lispy: no tailcalls is annoying, and no integer types
17:32:14 <lispy> I just realized that core is still lazy so maybe STG would still be a better layer to do the translation at
17:32:32 <dmwit> > liftM2 zip (take 10) (drop 10) [1..15]
17:32:34 <lambdabot>   [(1,11),(2,12),(3,13),(4,14),(5,15)]
17:32:37 <dmwit> > liftM2 zip (take 10) (drop 10) [1..30]
17:32:38 <lambdabot>   [(1,11),(2,12),(3,13),(4,14),(5,15),(6,16),(7,17),(8,18),(9,19),(10,20)]
17:32:54 <luite> hm what's the difference in laziness between core and stg?
17:33:06 <dmwit> > transpose . (\(a,b) -> [a,b]) . splitAt 10 $ [1..15]
17:33:08 <lambdabot>   [[1,11],[2,12],[3,13],[4,14],[5,15],[6],[7],[8],[9],[10]]
17:33:09 <lispy> If someone wrote a C-- to C#/Java compiler then the translation would be easy :)
17:33:14 <dmwit> Oh, eww.
17:33:36 <lispy> luite: I was thinking that STG made the push/enter thing explicit
17:33:59 <luite> it uses eval/apply now, but that's only in the STG machine, not explicit in the language
17:34:37 <lispy> luite: http://www.scs.stanford.edu/11au-cs240h/notes/ghc.html this says that laziness in STG is explicit
17:34:45 <dmwit> lispy: The link you gave me seems to confirm that core's type system is Pretty Exciting.
17:35:24 <lispy> dmwit: Doesn't that article says that Core has a simple type system?
17:35:35 <dmwit> No, it says it has a simple type-checking algorithm.
17:35:40 <dmwit> That's not necessarily the same thing. =)
17:35:57 <lispy> dmwit: coercions are the exciting thing here?
17:36:11 <dmwit> Coercions and higher-kinded polymorphism.
17:38:01 <lispy> Does anyone know if lambdavm is completely gone now? I couldn't find the sources anymore
17:38:19 <luite> lispy: hm, allocation does happen in more places with STG as part of the eval/apply mechanism
17:39:16 <luite> lispy: i wonder what other things there are in Core that get translated to let in STG
17:39:43 <luite> data constructors and primops are always fully saturated in STG, not in Core, that helps code generation a lot :)
17:40:17 <lispy> by that logic, translating the C-- would be easier yet :)
17:41:08 <luite> nah Cmm does have the whole calling convention and everything baked in, and also the heap and stack checks, pointer tagging
17:43:53 <JoeyA> When using the DeriveGeneric extension, where am I supposed to import Generic?
17:44:12 <JoeyA> GHC.Generics ?
17:46:42 <lispy> luite: For some reason I thought Cmm was like C but made sure the compiler writer could request things like TCO
17:47:02 <lispy> luite: but you're saying that it has some of the Haskell assumptions baked into the language?
17:47:40 <geekosaur> what I've seen of Cmm suggests that you have to commit to many details of the platform to generate Cmm code
17:48:25 <luite> lispy: nah it's lower level than C. the Cmm you get from GHC, with -ddump-cmm, has all the calling convention and stack stuff baked in. It uses virtual registers that still need to be mapped to actual registers for your architecture
17:48:35 <luite> so it's not baked into the language, but baked into the generated code :)
17:48:45 <geekosaur> ^^
17:49:21 <luite> I think that with GHC HEAD you can get a first pass Cmm that is not yet CPS transformed, but i'm not sure
17:49:41 <luite> otherwise the Cmm you see will only make tail calls
17:49:46 <lispy> luite: Oh, I understand now
17:50:12 <luite> lispy: if you translate Cmm to JavaScript you're pretty much forced to do everything in a huge array
17:50:31 <monochrom> JoeyA: I think so. can't find it in Data.Generics
17:51:50 <wavewave> hi
17:54:25 <wavewave> is it possible to use only dynamic library (especially for ghci) with ghc 7.6?
17:55:32 <parcs> wavewave: what do you mean?
17:55:44 <geekosaur> not with ghci and only on some platforms, as I understand it
17:55:49 <sw2wolf> :t void
17:55:50 <lambdabot> Functor f => f a -> f ()
17:56:21 <sw2wolf> Is void in haskell same as void in C ?
17:56:36 <wavewave> parcs: ghci loads its own static library, so if some package uses dynamically linked library, then it gives an error when loading.
17:56:50 <ski> sw2wolf : no
17:56:54 <wavewave> parcs: not only ghci, but also template haskell.
17:57:19 <sw2wolf> ski: how to use void ?
17:57:53 <wavewave> geekosaur: i see. thank you. I recently move to ghc 7.6 so hoped that this problem had been solved.
17:58:08 <sw2wolf> > void <$> "Hello" (++) "world"
17:58:10 <lambdabot>   The function `"Hello"' is applied to two arguments,
17:58:10 <lambdabot>  but its type `[GHC.Typ...
17:58:28 <sw2wolf> > void <$> "Hello" ++ "world"
17:58:29 <lambdabot>   Couldn't match expected type `f0 a0'
17:58:30 <lambdabot>              with actual type `GHC.Typ...
17:58:35 <ski> sw2wolf : `void (forkIO act)' e.g.
17:58:58 <geekosaur> as I understand it, the bytecode backend (ghci, runhaskell, TH) isdifficult and nobody has gotten dynamic linking working on Windows at all.  OS X has had dynamic linking for a while, and linux I think got it in 7.6
17:59:08 <ski> sw2wolf : it's not clear what you're attempting to do in those examples
17:59:42 <parcs> wavewave: ah you mean attempting to load a dyamically linked haskell library?
17:59:52 <sw2wolf> ski: what's difference between void (forkIO act) and forkIO act ?
18:00:03 * ski also thinks `Control.Monad.void' ought to be called `Control.Monad.ignore', or somesuch
18:00:15 <geekosaur> :t forkIO
18:00:17 <lambdabot> Not in scope: `forkIO'
18:00:20 <geekosaur> bah
18:00:23 <cmccann> heh.
18:00:32 <ski> sw2wolf : the former has `()' as monadic result, the latter a `ThreadId'
18:00:47 <ski> @type Control.Concurrent.forkIO
18:00:48 <lambdabot> IO () -> IO GHC.Conc.Sync.ThreadId
18:00:51 <geekosaur> forkIO produces an IO ThreadID; (void . forkIO) is IO (), discarding the ThreadId
18:01:05 <sw2wolf> ski: then same as C which means no return vaule ?
18:01:26 <ski> the monadic result value is `()'
18:01:39 <wavewave> parcs: yes. and load everything dynamically
18:01:43 <ski> there's no *interesting* return value, though
18:02:03 <sw2wolf> just ignore the return value ?
18:02:08 <ski> yes
18:02:17 <sw2wolf> i see,thx
18:02:36 <cmccann> more like *explicitly* ignoring the value
18:02:42 <cmccann> rather than just implicitly discarding it
18:02:43 <ski> (in SML, one'd write it as `ignore (...)')
18:02:45 <wavewave> geekosaur : linux dynamic linking support imprved in ghc 7.6?
18:02:56 <geekosaur> I think so
18:03:17 <cmccann> (I assume the motivation is to enable better use of compiler warnings for ignored return values)
18:03:38 <parcs> wavewave: ah that's currently being worked on in HEAD. it looks like ghc 7.8 will have it
18:03:43 <sw2wolf> ignore sames better than void ?
18:03:53 <ski> or allow you to pass the action to someone who expects a `()' result
18:04:11 <ski> sw2wolf : imho, yes
18:04:31 <parcs> wavewave: (where dynamic linking will become the default, and ghc itself will be dynamically linked)
18:04:37 <wavewave> parcs: that's a great news!
18:05:08 <wavewave> linking error is very annoying.
18:05:37 <wavewave> I remove all template haskell code from my code base because of linking problem.
18:05:50 <elliott> I hate stuff accepting m ()
18:05:50 <parcs> yeah, the main incentive was to get rid of ghci's custom linker and rely on gcc/dlopen instead
18:05:55 <elliott> it is like accepting Proxy foo
18:06:19 <elliott> contravariant <-> covariant, a <-> (), p <-> Proxy
18:06:44 <cmccann> elliott, variance confuses people
18:06:49 <cmccann> even people who understand how it works
18:06:54 <geekosaur> ok, I'm partially wrong.  I may be talking abitu the support in ghci; looks like basic shared library support was on all platforms by 7.0
18:06:54 <ski> elliott : where does `Void' fit into that ?
18:07:11 <elliott> ski: good question.
18:07:19 <elliott> ski: I guess the equivalent is consuming Void but outputting a
18:07:26 <geekosaur> trying to find the actual details now...
18:07:32 <elliott> but I don't think the rule of thumb applies so well there
18:08:07 <ski> elliott : so `kill :: SystemM a' would be better than `kill :: SystemM Void' ? (`SystemM' is a covariant functor)
18:08:34 <cmccann> Void is basically equivalent to a universally quantified type in this context
18:08:37 <wavewave> geekosaur: yeah.. I was specifically asking about ghci and template haskell any way.
18:08:40 <elliott> ski: right. I guess that is actually true in practice... if you consider something like exitSuccess or whatever, you should be able to substitute that for any IO computation
18:08:45 <elliott> @hoogle exitSuccess
18:08:45 <lambdabot> System.Exit ExitSuccess :: ExitCode
18:08:45 <lambdabot> System.Exit exitSuccess :: IO a
18:08:49 <elliott> and indeed they use IO a rather than IO Void
18:10:58 <fragamus> is there a splitAt that returns a list instead of a tuple
18:11:38 <ski> i actually changed from `SystemM a' to `SystemM Void' here. i wanted to get rid of various `undefined's i had littering the code which i wasn't sure whether they could be entered or not
18:11:42 <cmccann> elliott, actually I think "forall a b. f a -> f b" should end up equivalent to "f () -> f Void"
18:12:11 <elliott> cmccann: right
18:12:22 <elliott> ski: ? you don't need any undefineds
18:12:35 <elliott> ski: "vacuous" (aka "fmap absurd") gets you from the "SystemM Void" implementation to "SystemM a"
18:12:43 <cmccann> elliott: because Void ~ forall a. a, and () ~ exists a. a
18:12:43 <elliott> so if you can implement "SystemM Void", you can implement "SystemM a" without any more undefined
18:12:54 <geekosaur> wavewave, http://hackage.haskell.org/trac/ghc/wiki/DynamicByDefault is what I was misremembering; ghci support is a significant sticking point still
18:12:55 <cmccann> hooray, de morgan duality!
18:12:58 <elliott> unless you count the "undefined"s inside the void library that can only be reached if you pass in _|_ anyway
18:13:04 <hughfdjackson> is it possible to specify a package version with cabal?
18:13:14 <hughfdjackson> i think i may be being slow here
18:13:27 <geekosaur> (and Template Haskell; anything useing the bytecode backend)
18:13:28 <cmccann> hughfdjackson: as in with cabal-install?
18:13:33 <dcoutts_> hughfdjackson: yes, in what context exactly?
18:13:36 <cmccann> like "cabal install foo-0.1"
18:13:51 <hughfdjackson> cmccann: ah, sorry :) with cabal the cli tool for installing packages
18:13:53 <napping> but yes, you can certainly specify versions
18:13:53 <hughfdjackson> not cabal-install
18:14:04 <wavewave> geekosaur : thanks for the link!
18:14:08 <hughfdjackson> i've found it in --help
18:14:11 <napping> that's kinda the whole point of the dependencies, but I do often forget the syntax
18:14:13 <hughfdjackson> i just had to cabal install --help
18:14:19 <hughfdjackson> read the funky manual and all that :3 sorry
18:14:46 <geekosaur> there's a long thread on glasgow-haskell-users but that wiki page should be the current state of things
18:14:54 <geekosaur> without having to dig through the whole thread
18:15:05 <sw2wolf> :t withSocketsDo
18:15:07 <lambdabot> Not in scope: `withSocketsDo'
18:15:18 <ski> elliott : yes, but i wasn't sure whether i had any bugs or not in what i had written
18:15:28 <napping> I'm liking DeriveFunctor and DeriveFoldable - it makes working with the fixpoint of a base functor much more convenient
18:15:37 <sw2wolf> :t Network.Socket.withSocketsDo
18:15:39 <lambdabot> IO a -> IO a
18:15:51 <elliott> ski: how does "fmap absurd" add any more potential bugs?
18:15:53 <napping> well, maybe not *much*, but removes the upfront cost to get started
18:16:11 <elliott> ski: it doesn't add any undefineds
18:16:22 <ski> elliott : it doesn't. the code already being littered with `undefined's does
18:16:37 <elliott> this sounds like a problem unrelated to Void vs. a :P
18:17:16 <ski> i changed to `Void' to convince myself i could remove them
18:17:17 <cmccann> wasn't ski just talking about replacing a bunch of "this can't happen" undefineds with absurd?
18:17:29 <cmccann> as in, the whole purpose of absurd existing? :P
18:18:14 <elliott> I'm not sure we're disagreeing at all here
18:18:43 * cmccann disagrees because of not distinguishing between additive and multiplicative truth values!
18:18:52 <ski> (cmccann : i didn't replace them with `absurd'/`void', though)
18:19:48 <cmccann> ski: oh btw, I cleaned up my linear logic stuff a bit and tossed it on github. it has exponentials now! dunno if you're still interested in that.
18:20:38 <cmccann> cf. https://github.com/isomorphism/Delineate/blob/master/Control/Delineate/Expon.hs
18:20:48 <efiish> hi, I'm trying to modify some files in yi, a haskell editor, every time i change a little, i must to "cabal build" and then run, this workflow is too slow, do you have any suggest?
18:21:19 <cmccann> I haven't decided if there's anything sensible to do for the ? left introduction rule, other than de morganizing ofCourse
18:21:20 <ski> cmccann : ty
18:22:19 <cmccann> efiish: I usually just load stuff in GHCi instead of rebuilding at all, with cabal or otherwise
18:22:22 <sw2wolf> efiish: "cabal build" is necessary
18:22:58 <cmccann> but I've never used yi so I can't speak to how it works.
18:23:00 <sw2wolf> ghc linking is indeed VERY slow if using ld
18:23:28 <efiish> cmccann: If i use ghci, my change not take place
18:23:32 <monochrom> write a shell script or C program that: poll for file change, call cabal build etc, fork, loop back
18:23:48 <monochrom> (the fork is important! bwahahaha...)
18:24:22 <efiish> monochrom: Is there any tools to do these things?
18:24:25 <sw2wolf> maybe add more RAM :P
18:24:52 <wavewave> sw2wolf : if I use gold, then how much can it be faster?
18:25:05 <sw2wolf> i am not sure
18:25:20 <monochrom> gold is usually much faster (because of much less memory pressure)
18:25:34 <monochrom> (and possible less computation too)
18:25:41 <sw2wolf> as gold not works on FreeBSD
18:25:42 <cmccann> ski: I also added some abstract nonsense which somehow resulted in edwardk convincing me that I should add stuff to his categories package
18:25:51 <monochrom> but ghc sometimes doesn't like gold
18:25:51 <efiish> sw2wolf: why "cabal build" is necessary?
18:26:08 <sw2wolf> make your changes effetive
18:26:13 <wavewave> monochrom: how can I switch to gold btw?
18:26:34 <monochrom> that depends on your distro. I can only tell you mine (ubuntu)
18:26:43 <efiish> gold is an other haskell compiler?
18:26:52 <sw2wolf> linker
18:27:09 <wavewave> monochrom: i am using arch and ubuntu.
18:27:10 <efiish> how to change to it, i'd like to have a try
18:27:24 <ski> cmccann : hm ?
18:27:25 <efiish> I'm using macos
18:27:31 <monochrom> on ubuntu, you already have gold  (/usr/bin/ld.gold). /usr/bin/ld is a symlink. change the symlink yourself, or apt-get a package that does it for you
18:27:54 <monochrom> the package name is binutil-gold iirc
18:28:00 <wavewave> monochrom : aha.. good. thanks!
18:28:10 <sw2wolf> hope gold can run on FreeBSD ...
18:28:52 <cmccann> ski: well, I rolled my own category stuff because the categories package couldn't do what I needed, so the obvious solution is for me to add it to categories myself :P
18:28:56 <wavewave> btw is ld.bfd traditional one?
18:29:00 <monochrom> yes
18:29:13 <wavewave> i'll give a try ;-)
18:29:17 <edwardk> the main problem is the lack of polykinding of 'Control.Category' =(
18:29:27 <cmccann> yes.
18:29:53 <cmccann> well, that doesn't really prevent writing any of the classes I need.
18:30:00 <cmccann> I just can't use them for my stuff.
18:30:03 <geekosaur> sw2wolf, looks like it's supported on recent freebsd
18:30:15 <sw2wolf> really !
18:30:29 <sw2wolf> i will googling later
18:31:02 <sw2wolf> but in a future FreeBSD will use clang instead of GCC
18:31:13 <cmccann> edwardk: at the moment I'm still trying to figure out which parts of the bikeshed to repaint while bolting my additions on :P
18:31:25 <ski> cmccann : ok
18:31:35 <monochrom> repaint them all
18:31:46 <monochrom> rename every operator and name
18:32:00 <geekosaur> sw2wolf, there is a gold port, which is ancient and broken.  the supported one is part of the binutils port
18:32:01 <edwardk> cmccann: =)
18:32:04 <monochrom> reverse operator precedence
18:32:04 <cmccann> edwardk: particularly since you use "k" consistently for the category instance, while I use it consistently for kind variables
18:32:13 <edwardk> if need be we can split it out into a separate poly-categories package
18:32:16 <geekosaur> (the other one is from a prerelase version, before it was added to binutils)
18:32:17 <sw2wolf> geekosaur: thx
18:32:47 <edwardk> then you don't have to fight with Control.Category being needlessly mono-kinded
18:32:54 <cmccann> edwardk: turns out few of the modules import Control.Category anyway
18:33:02 <wavewave> hmm.. gold immediately make linker error now :-/
18:33:07 * ski is reminded of non-transitive operator precedence
18:33:09 <cmccann> so I changed the handful that did and added PolyKinds everywhere
18:33:27 <wavewave> --hash-size=31: unknown option
18:33:29 <edwardk> changed them to an in-house category?
18:33:33 <cmccann> yeah
18:33:39 <cmccann> also, made a branch for this
18:33:45 <cmccann> though it's only local right now
18:33:45 <edwardk> *nods*
18:33:55 <cmccann> didn't feel like hassling about Control.Category at the moment
18:34:28 <monochrom> wavewave: when ghc builds an executable, you don't get that error. when ghc builds a lib, you get that error, gold doesn't support that flag. btw do you know the purpose of that flag? to tell conventional ld to be more efficient, ironically :)
18:34:35 <cmccann> was also considering whether other new GHC stuff would be helpful
18:34:47 <cmccann> like, I used default signatures a bit in mine
18:35:31 <cmccann> so that the monoidal unit functions are inter-defined via swap when that exists
18:35:46 <wavewave> monochrom: I see.. I found that this bug is fixed in Aug 2012. so I need to upgrade my ghc.
18:35:49 <cmccann> but I'm not sure that really saves all that much effort in the big picture
18:36:16 <wavewave> http://hackage.haskell.org/trac/ghc/ticket/4862
18:46:02 <parcs> wavewave: you don't have to upgrade at all!
18:46:36 <parcs> wavewave: just edit /usr/lib/ghc/settings and remove the offending command line option
18:47:25 <monochrom> except, the offending flag is not even in that file, here on my computer, GHC 7.4.2
18:47:44 <parcs> monochrom: --hash-size=31 ?
18:47:55 <monochrom> and as said in the ticket comments, the GHC executable does not even care
18:48:21 <parcs> oh, oops
18:48:26 <monochrom> GHC 7.6 cares, 7.4 doesn't
18:48:45 <monochrom> 7.4.3 would care too, if it existed
18:48:56 <parcs> luckily i think wavewave uses 7.6
18:49:10 <monochrom> yeah that should work
18:49:31 <wavewave> parcs: thanks!
18:49:53 <wavewave> parcs: btw, in fact I use both. 7.4 on ubuntu, 7.6 on arch ;-)
18:51:09 <monochrom> kids these days, with their 5 keyboards and 6 monitors displaying 8 computers
18:52:11 <monochrom> and a smartphone that connects to 2 more
18:52:50 <parcs> these days you only need 1 computer to run 8 (virtual) computers
18:53:37 <wavewave> parcs: hmm unfortunately there is no hash-size option in my settings
18:53:39 <monochrom> when I was a kid, we had to cramp 40 users into one computer, and it was uphill both ways!
18:54:14 <haskelln00b> Anyone have any ideas on how to get "cabal install libexpect" to work on gentoo? I installed libexpect and it says "missing C library: expect"... I pointed it to the library location manually with --extra-lib-dirs but it still doesn't work. T_T
18:55:37 <geekosaur> haskelln00b, how about --extra-include-dirs to point to the headers as well?
18:55:49 <monochrom> do you have the headers?
18:55:52 <haskelln00b> it seems to find the headers fine
18:55:55 <geekosaur> (just suggesting; I have no idea)
18:56:31 <haskelln00b> yeah, I have the headers
18:56:35 <haskelln00b> they are in /usr/include
18:57:15 <feliperosa> Hi guys :), does anyone know about a good book/paper about graph reduction?
18:57:23 <geekosaur> hm, do you have the tcl headers and libraries installed?
18:57:29 <haskelln00b> yup
18:57:41 <geekosaur> (if it's checking them in order, expect will fail if tcl devel libs aren't there)
18:58:40 <shachaf> feliperosa: In what context?
18:59:42 <Nereid> haskelln00b: let me have a look.
19:00:06 <crdueck> i have a really simple test program to try out the Network package. If you run main and connect to port 8080, i expect everything that i type to be echoed back. But nothing is getting printed back, i expect I'm overlooking some nuance with lazy IO. could someone take a look? import Control.Monad
19:00:09 <feliperosa> shachaf: I'm trying to learn more about how lazy functional programs are executed. I'm having a feeling that I'm almost always lost when reasoning about programs..
19:00:12 <crdueck> import System.IO
19:00:14 <crdueck> import Network
19:00:17 <crdueck> whoops, code is here: http://sprunge.us/hNDe
19:00:33 <haskelln00b> Nereid: sure, I'll PM you
19:00:41 <shachaf> feliperosa: OK, so you want to learn in the context of evaluating programs like GHC.
19:00:48 <shachaf> feliperosa: You should read the STG paper.
19:00:50 <shachaf> @where stg
19:00:50 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
19:00:57 <shachaf> Other good papers to read:
19:01:05 <shachaf> @where eval-apply
19:01:05 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/index.htm
19:01:14 <shachaf> And, uh, actually, never mind.
19:01:19 <shachaf> Just read the STG paper.
19:01:45 <shachaf> It doesn't quite correspond to what GHC does these days, but at a high level it's good.
19:01:48 <Nereid> haskelln00b: well it's looking for some libexpect.so, which obviously doesn't exist.
19:02:08 <Nereid> I mean I have a /usr/lib64/expect5.44.1.15/libexpect5.44.1.15.so
19:02:11 <monochrom> crdueck: I think you're just missing a few hFlush
19:02:17 <Nereid> but that has the wrong name, so uh
19:02:20 <efiish> Hi all, Does haskell support hotfix?
19:02:27 <haskelln00b> let me make a symlink and see if that works
19:02:38 <monochrom> oh sorry, you already set line-buffering. I'll try again
19:02:42 <feliperosa> shachaf: Alright, thanks!
19:02:49 <Nereid> haskelln00b: yeah that was my thought.
19:03:06 <haskelln00b> yay! it works!
19:03:09 <haskelln00b> you are a god
19:03:15 <haskelln00b> thanks so much
19:03:17 <haskelln00b> :D
19:03:21 <Nereid> np
19:03:33 <haskelln00b> how did you check what it was calling for?
19:03:45 <Nereid> cabal file says extra-libraries: expect, tcl
19:04:27 <efiish> Building project is too slow, I think hotfix is very important
19:04:30 <haskelln00b> the expect package itself doesn't create libexpect.so though
19:04:35 <Nereid> indeed.
19:04:58 <haskelln00b> even the official package, if you manually build it, doesn't create that
19:06:48 <monochrom> crdueck: I cannot reproduce the problem. program echoes fine when I "nc localhost 8080" to it. when I enter "end", it also says goodbye correctly
19:07:13 <otters> is there a lazy alternative for many for attoparsec?
19:07:16 <haskelln00b> Nereid: does that mean that the cabal install file is at fault or the libexpect package?
19:07:42 <crdueck> monochrom: I was using ssh to connect to the port. I guess thats the problem
19:07:51 <monochrom> heheh
19:08:16 <monochrom> you also forgot to hClose eventually
19:08:26 <dcoutts_> otters: attoparsec does not return results lazily (though it can be given input incrementally)
19:09:46 <monochrom> otters: have you seen my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#yield-intro ? :)
19:10:04 <sw2wolf> It seems GHC cannot use clang on FreeBSD
19:10:25 <otters> monochrom: no but I'm about to
19:10:39 <geekosaur> haskelln00b, that's a shortcoming of gentoo's packaging, although there may be some gentoo-flavored alternatives system that can make the symlink
19:11:41 <haskelln00b> ah.. k. Would it be wise to file a bug with gentoo then?
19:12:07 <geekosaur> after cghecking its documentation for the package to see if you're supposed to have dome something else
19:12:19 <monochrom> it would be wise to file a million bugs, one for each package: "you are missing libfoo.so"
19:12:29 <monochrom> or, it would be extremely unwise :)
19:12:42 <Eduard_Munteanu> Nah, it's not a problem in Portage, probably just the ebuild.
19:31:51 <latermuse> are there any good graphing libraries for haskell that can just take a list of graph points and output a .png graph?
19:34:21 * hackagebot lens 3.8.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.3 (EdwardKmett)
19:41:52 <tieTYT2> can someone explain to me how this is legal syntax: flip' f = g where g x y = f y x
19:42:07 <tieTYT2> x and y weren't defined anywhere, not even in pattern matching
19:42:19 <shachaf> They're defined right there.
19:42:24 <shachaf> How is this legal syntax? f x y = x + y
19:42:31 <shachaf> x and y aren't defined anywhere. :-)
19:42:52 <shachaf> (g is ust a plain old function.)
19:43:01 <tieTYT2> hm ok, I kind of get that
19:43:13 <tieTYT2> is this a normal way to write code in haskell?
19:43:20 <shachaf> Which part?
19:43:27 <tieTYT2> i wrote my flip like f x y = f y x instead
19:43:29 <shachaf> I would probably write it as flip f x y = f y x
19:43:40 <tieTYT2> that's the way I naturally thought of it
19:43:41 <shachaf> But that's a perfectly reasonable way of writing it.
19:44:36 <tieTYT2> the more I look at the first way the more it makes sense, but i don't know if I'd ever think of doing it that way
19:44:53 <Nereid> tieTYT2: is this clearer? flip' f = (let g x y = f y x in g)
19:44:59 <shachaf> Careful not to look at it too much, or it'll start to make more sense than your own version.
19:45:03 <Nereid> (the parentheses are not needed, it's just clearer to put them there)
19:45:15 <tieTYT2> Nereid: not really,
19:45:19 <Nereid> oh, well.
19:45:36 <shachaf> tieTYT2: How about: flip f = (\x y -> f y x)
19:45:41 <tieTYT2> i think this is the first time I've seen something with a type of 1 -> 2 -> 3  but the pattern matching only uses 1
19:45:56 <Nereid> :t flip
19:45:57 <lambdabot> (a -> b -> c) -> b -> a -> c
19:46:00 <tieTYT2> i didn't knwo that was legal
19:46:10 <shachaf> "a -> b -> c" really means "a -> (b -> c)"
19:46:14 <Nereid> sure, flip takes f :: (a -> b -> c) and returns a function of type (b -> a -> c)
19:46:20 <napping> wouldn't be first class functions if you couldn't return them
19:46:28 <shachaf> f x y = ... really means: f = (\x -> (\y -> ...))
19:49:42 <tieTYT2> another thing that's blowing my mind is it takes different types.  if it were (a->a->a) -> a -> a -> a i'd get it.  But since they're a->b->c... how does it know it can just flip them like that
19:50:13 <shachaf> how does it know, man
19:50:21 <shachaf> tieTYT2: Start with something like ($)
19:50:26 <shachaf> Do you understand ($)'s type?
19:50:30 <tieTYT2> i haven't learned ($) yet
19:50:33 <shachaf> Oh.
19:50:35 <Nereid> f $ x = f x
19:50:36 <shachaf> ($) :: (a -> b) -> a -> b
19:50:46 <shachaf> You can implement this in two obvious ways:
19:50:47 <shachaf> ($) f = f
19:50:49 <shachaf> ($) f x = f x
19:51:44 <tieTYT2> is the former possible with currying?
19:52:11 <shachaf> None of this is strictly about currying as such (though it's related).
19:53:10 <tieTYT2> now that I read closer, I think my book accidentally put these paragraphs out of order.
19:53:13 <Nereid> :t flip . (flip.) . flip . ((flip.).) . (flip.) . flip
19:53:14 <lambdabot> (a2 -> a1 -> a -> b -> c) -> b -> a -> a1 -> a2 -> c
19:53:52 <parcs> :t flip flip flip flip
19:53:53 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
19:54:02 <parcs> :t flip flip flip flip flip
19:54:03 <lambdabot> (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
19:54:04 <Nereid> I'm glad flip is back to the Prelude version.
19:54:13 <Nereid> :t flip flip flip
19:54:14 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
19:54:23 <Nereid> mhm
19:55:16 <Nereid> :t (`flip` flip)
19:55:19 <lambdabot> (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
19:55:42 <ski> :/
19:55:57 <Nereid> :t (.)
19:55:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
19:56:01 <Nereid> :(
19:56:30 <cmccann> shachaf: you should help me write a book.
19:56:47 <parcs> @oeis 0.6341
19:56:55 <shachaf> cmccann: Sure! Which book?
19:56:55 <lambdabot>  Decimal expansion of sqrt(3).
19:56:55 <lambdabot>  [1,7,3,2,0,5,0,8,0,7,5,6,8,8,7,7,2,9,3,5,2,7,4,4,6,3,4,1,5,0,5,8,7,2,3,6,6,9...
19:57:15 <cmccann> shachaf: the one about stuff. and also things.
19:57:30 <shachaf> cmccann: i love stuff and things
19:57:33 <shachaf> they are so easy
19:57:47 <cmccann> ok, good. we're decided then.
19:58:00 * ski . o O ( is there perchance a functor from stuff to things ? )
19:58:09 <Nereid> I would love to learn about stuff and things. looking forward to it.
19:58:17 <cmccann> ski: http://ncatlab.org/nlab/show/stuff+type ?
19:59:53 <ski> cmccann : cool
19:59:54 <cmccann> shachaf: anyway I was sort of reconsidering whether I'd want to use Haskell as the example language for my hypothetical typeful programming book.
20:00:15 <shachaf> What would you use instead?
20:00:30 <cmccann> a Haskell-ish language devised for the purpose.
20:00:30 <tieTYT2> ohhhhhhhhhhhhh, so this fails: flip' replicate 1 'a'
20:00:35 <cmccann> probably a total language.
20:00:50 <tieTYT2> this is starting to make more sense
20:00:52 <Nereid> yes, that would try to be replicate 'a' 1, which is wrong.
20:01:21 <tieTYT2> Nereid: I was thinking somehow my flip' made that possible.  That's part of the reason I was so confused
20:01:23 <cmccann> shachaf: stuff being "morally correct" is fine in practice but awkward for introducing concepts
20:01:27 <Nereid> heh
20:01:38 <shachaf> cmccann: Oh, OK.
20:01:48 <shachaf> I was thinking you'd say SML or something.
20:01:51 <tieTYT2> so this allows you to generate kinds of runtime exceptions
20:01:54 <cmccann> shachaf: since you either have to hand-wave a bunch of stuff explicitly, gloss over it implicitly, or get bogged down in details that aren't helpful at that point.
20:02:02 <Nereid> tieTYT2: where?
20:02:05 <Nereid> type errors are compile-time.
20:02:18 <tieTYT2> Nereid: oh so if i compiled that line it'd error there?
20:02:20 <Nereid> yes
20:02:24 <shachaf> cmccann: An alternative is to write a really good Haskell introduction and stick it at the beginning of the book!
20:02:24 <tieTYT2> ok well that's awesome
20:02:44 <shachaf> cmccann: By "devised" do you mean you'll write a type checker for it and everything?
20:02:51 <shachaf> Being able to use a real type checker is very useful.
20:03:26 <tieTYT2> my book defined it like this in a revision: flip' f y x = f x y   And I was thinking how the hell is that possible?  How does it know that f can take those arguments in reverse?
20:03:37 <cmccann> shachaf: yes, I mean implementing a simplified language with at least type checking and a REPL and whatnot.
20:03:43 <Nereid> parse it as (flip' f) x y
20:04:03 <shachaf> cmccann: Oh, that's nice, then. Assuming you can make it good and everything.
20:04:04 <Nereid> or even as ((flip' f) x) y
20:04:10 <shachaf> Helium-style, except total and with fancy types.
20:04:33 <fluffynukeit> I am exploring the configurator library for config files.  There are lots of functions for importing a config file.  I want to *write* such a config file, e.g. after the user selects his preferences or to write out a default config.  What is the recommended way to do this? Thanks.
20:04:40 <cmccann> shachaf: the inspiration would be something like this: http://www.andres-loeh.de/LambdaPi/index.html
20:05:01 <cmccann> except with a few more niceties and not necessarily dependently typed (though I wouldn't rule it out either?)
20:05:12 <shachaf> I've never written a type checker or anything. :-(
20:05:15 <shachaf> I should do it sometime.
20:05:22 <cmccann> you should read that paper I just linked to.
20:05:44 <cmccann> they walk through implementing a dependently-typed lambda calculus type checker and interpreter in a few pages!
20:06:00 <cmccann> it's really quite simple at heart.
20:07:28 <tieTYT2> that's saying you pass in a function that takes 2 parameters (it doesn't take them in though).  Then it's saying it takes a function that takes 2 parameters and x is the second parameter to it.  Then it's saying it takes a function that takes 2 parameters, x is the second parameter and y is the first.  How off am i?
20:08:46 <Nereid> I don't know what that's supposed to mean.
20:08:53 <applicative> tieTYT2: you are trying to explain flip f x y = f y x?
20:08:58 <cmccann> shachaf: anyway, I'd probably implement something closer to the core ideas of Haskell's type system and skip the dependent types (since they'd interfere with stuff I'd like to emphasize)
20:09:08 <tieTYT2> no, (((flip' f) x) y)
20:09:12 <shachaf> cmccann: Makes sense.
20:09:37 <shachaf> cmccann: Though I think a thing where you pass types around explicitly as arguments makes a lot of things easier to understand.
20:09:44 <applicative> > flip foldr 0 (+) [1..20]
20:09:45 <lambdabot>   210
20:09:47 <Nereid> flip' takes f as an argument, and returns another function, which we call flip' f.
20:09:48 <shachaf> But that doesn't necessarily have to be part of the language proper.
20:09:56 <cmccann> shachaf: but the main idea would be to prune out the more hand-wavy stuff, make things that I keep self-consistent to start with, and get away with it because of not caring about backcompat or efficient compilation
20:10:01 <Nereid> flip' f takes x as an argument, and returns yet another function, which we call flip' f x
20:10:12 <cmccann> shachaf: explicit type application would probably be a thing
20:10:12 <Nereid> = (flip' f) x
20:10:15 <shachaf> cmccann: Sounds good to me.
20:10:22 <cmccann> in fact, rank-N types would probably be the default
20:10:33 <shachaf> cmccann: Assuming there was enough meat to the book to justify inventing a new language for it. :-)
20:10:36 <Nereid> and then that one takes y as an argument and returns flip' f x y, which is defined to be f y x.
20:10:42 <tieTYT2> Nereid: isn't (flip' f x) more accurate?
20:10:48 <cmccann> shachaf: to be fair there'd be very little inventing going on
20:10:53 <Nereid> tieTYT2: it's the same.
20:10:57 <shachaf> cmccann: True.
20:11:02 <cmccann> just reimplementing well-known ideas for pedagogical purposes
20:11:03 <Nereid> f x y is parsed as (f x) y
20:11:17 <shachaf> cmccann: Maybe you should just make it System F or something????
20:11:22 <shachaf> (Probably not.)
20:11:53 <cmccann> shachaf: that's almost certainly the starting point
20:12:01 <cmccann> the question is what else I'd include
20:12:27 <shachaf> cmccann: Don't you want type inference?
20:12:39 <cmccann> not necessarily.
20:12:47 <shachaf> I guess that simplifies things a lot.
20:12:58 <shachaf> (At the expense of making actually using it really awkward?)
20:13:17 <cmccann> not that awkward.
20:13:23 <cmccann> you can still infer quite a lot of stuff.
20:13:49 <shachaf> I suppose so.
20:14:16 <cmccann> I could probably bang together an ill-conceived version of System F with all kinds of stupid crap that still had better type inference than any mainstream static-typed language.
20:14:37 * shachaf approves of this effort.
20:14:39 <cmccann> again, you should look at that paper.
20:15:03 <cmccann> and in particular, how much type inference they get purely from trivial, local inferences.
20:15:12 <shachaf> Yep, I'll look.
20:16:09 <cmccann> shachaf: the central unifying concept would be the mindset of excluding invalid states, equational reasoning, parametricity guarantees, &c.
20:16:45 <cmccann> with the goal of teaching, even in the intentionally limited setting, a "correct by construction" approach to programming from the ground up
20:17:11 <cmccann> that could then be carried over to programming in Haskell or other languages
20:17:15 <shachaf> Intensionally limited, too!
20:17:52 <Nereid> cmccann: that sounds great. also I should look at that paper.
20:18:01 <cmccann> (which is why I'd probably avoid dependent types, because that can undermine parametricity and simple modes of reasoning)
20:18:33 <cmccann> Nereid: it's a nice paper, and largely unrelated to what I'm talking about. but yes you should read it.
20:18:37 <Nereid> :p
20:18:50 <Nereid> has stuff like parametricity and whatever ever gone into a book, anyway?
20:19:49 <cmccann> I'm sure it gets mentioned at least in passing in some.
20:20:28 <cmccann> but I've only seen it presented as kind of an afterthought. nice properties you get as a bonus.
20:21:50 <cmccann> which is why I've been toying with the idea of writing a book, or something book-like, that starts from "preserving nice properties" and then builds that up to writing useful programs
20:22:59 <ski> stuff like `(∀ S ⊆ ℕ. ∃ n : ℕ. R (S,n)) ⇒ (∃ n : ℕ. ∀ S ⊆ ℕ. R (S,n))' feels vaguely related to parametricity
20:24:17 <cmccann> ski: related, perhaps, but nothing is going to match the straightforward simplicity.
20:24:55 <Nereid> cmccann: sounds like the kind of thing I'd enjoy.
20:24:57 <cmccann> the way stuff like "forall a. f a -> g a" giving you a natural transformation just works.
20:25:44 <tswett> Ahoy.
20:25:51 <ski> @arr
20:25:51 <lambdabot> Drink up, me 'earties
20:26:00 <cmccann> actually, this probably ties into the overall idea of strategically limiting expressive power to gain better guarantees, which is part of what I'd want to deal with.
20:26:21 <tswett> Suppose I have a function [Double], representing a mono sound as a list of samples. What's the easiest way to play it through the speakers?
20:27:09 <cmccann> Nereid: great! I do kinda worry that I'd end up writing something that nobody but myself would want. :P
20:27:35 <shachaf> monoids sound like the kinds of things i'd enjoy
20:27:36 <shachaf> they are so easy
20:28:10 <Nereid> monoids are at least as hard as groups
20:29:48 <Eduard_Munteanu> tswett: what sampling rate?
20:30:03 <Eduard_Munteanu> tswett: writing it to /dev/dsp might do
20:30:30 <tswett> I don't have that on this computer, but let me see if I have it somewhere else.
20:30:37 <Nereid> and groups are hard
20:31:06 <tswett> Has anyone studied the category of types in the simply typed lambda calculus?
20:31:14 <cmccann> Nereid: any thoughts on what you'd like to see in an introduction to programming along those lines?
20:31:15 <cmccann> this whole thing is still kinda loosely structured in my head.
20:31:35 <cmccann> tswett: ncatlab.org/nlab/show/cartesian+closed+category
20:32:01 <Eduard_Munteanu> tswett: sure, a lot of people. :)
20:33:06 <Nereid> cmccann: I dunno. it's not structured at all in my head, so you probably have a better idea
20:33:31 <tswett> What's the initial object in the category of cartesian closed categories? >_>
20:33:52 <shachaf> tswett: "C", obviously.
20:34:07 <shachaf> I mean, Cartesian Closed Categories.
20:34:11 <shachaf> The initial is pretty obvious.
20:35:35 <tswett> Ah, of course.
20:35:40 * tswett searches Google for "carclocat".
20:35:54 <tswett> A surprisingly dirty-sounding word.
20:36:31 <Nereid> you probably want the 2-category of CCCs.
20:36:48 <Nereid> else there's no initial object, just because oops things are only unique up to isomorphism.
20:37:36 <cmccann> the initial object in a category of CCCs is probably just an empty category of some sort.
20:37:40 <Nereid> but the 2-category of CCCs probably has initial (and terminal) object the category with just one object. I think that's cartesian closed right.
20:38:00 <Nereid> cmccann: no, cartesian closed implies you have to have products.
20:38:07 <Nereid> in particular a unit.
20:38:44 <tswett> Lessee. In the category of rings, you can think of the initial object (the integers) as the ring of expressions that make sense in all rings.
20:38:50 <cmccann> right, I meant something like "as empty as possible"
20:40:06 <tswett> What's an "expression that makes sense in all cartesian closed categories"? Like, an object or morphism that can be found in all of them? Is there such a thing?
20:40:14 <cmccann> but I dunno. what are we assuming the morphisms are? functors in general? or functors that preserve some aspect of the CCC structure?
20:40:25 <tswett> What's a cartesian closed category, again? <_<
20:40:28 <cmccann> tswett: expressions in the STLC
20:40:43 <Nereid> cmccann: I dunno, but whatever they are, there's probably a unique one to/from the trivial one
20:40:53 <tswett> cmccann: is that so? That sounds gosh darned convenient.
20:40:59 <tswett> Or neat.
20:41:01 <Nereid> probably (lax?) monoidal functors is enough.
20:41:30 <Nereid> maybe not. I don't know
20:41:32 <tswett> An expression in the STLC would represent a morphism, then, wouldn't it?
20:43:38 <cmccann> tswett: a CCC has products and exponential objects, which basically means fst, snd, (&&&), and curry/uncurry
20:44:15 <cmccann> (though in Haskell that's wrong because of partial functions, alas)
20:44:40 <Nereid> don't forget ()
20:44:44 <cmccann> (...and disclaimers like that are why I'd want to concoct a total language for my hypothetical book)
20:44:56 <cmccann> ah yeah, ().
20:45:12 <xil> hello everyone =D!  I want to make a GUI application in Windows, and while I have experimented with a few GUI libraries, I don't know which is easiest for distributing my application to friends.  For example, I assume they'd need to install GTK+ if I used Gtk2Hs, which I'd like to avoid
20:45:17 <NemesisD> could you destructure a record Foo { fooName :: String} like Foo str
20:45:56 <tswett> NemesisD: if the record is defined as "Foo { fooName :: String }", then fooName (Foo str) = str.
20:46:37 <tswett> Confusingly enough, the type of fooName is not actually String; it's (the record type) -> String.
20:47:14 <NemesisD> tswett: but i mean if you're trying to pattern match to extract fields, usually you would do myFn (Foo { fooName = str}) = ..., but not myFN (Foo str) = ...
20:47:45 <tej> @type (***)
20:47:46 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
20:47:53 <tswett> NemesisD: I guess I don't know the details of the syntax here.
20:48:39 <Nereid> NemesisD: yes you can
20:49:05 <Nereid> I'm assuming you were asking if you can.
20:50:36 <geekosaur> NemesisD, both can be valid; a record is a variant of normal "data Foo = Foo Int Str Char" type syntax and you can use either one.  (you can also use "myFn (Foo {})" with an empty record with any such ADT, even if it wasn't declared with record syntax)
20:51:45 <Nereid> the record {} binds tighter than function application, so you can even myFn Foo{}
20:51:53 <Nereid> or myFn Foo     {} if you like confusing spacing.
20:52:04 <shachaf> myFn Foo
20:52:05 <shachaf> {
20:52:08 <shachaf> hi
20:52:08 <shachaf> }
20:52:16 <Nereid> :(
20:58:28 <applicative> > let f = (<*>) in getZipList $ f ZipList  {getZipList =  [even]}    ZipList   {getZipList = [1..10]}
20:58:30 <lambdabot>   [False]
20:58:47 <applicative> It's kinda disgusting somehow
21:00:16 <Nereid> I try to use no space before the {
21:02:29 <NemesisD> if i have a datatype with 1 field, is there any reason to use record syntax instead of newtype
21:02:46 <Nereid> sure, you can match f Blah{} instead of f (Blah _)
21:03:02 <Nereid> (I've never done this)
21:03:28 <Nereid> oh wait
21:03:31 <geekosaur> Nereid, that special case works even for non-records
21:03:37 <Nereid> yes I know.
21:03:40 <shachaf> Is there any reason to use record syntax instead of a lens/prism/isomorphism.
21:03:40 <Nereid> let's read the question
21:03:45 <hpaste> tac pasted “Why does this happen?” at http://hpaste.org/81300
21:03:49 <NemesisD> data Foo = Foo { unFoo :: String } vs newtype Foo = Foo { unfoo :: String }
21:04:04 <tac> Can anyone help me with this issue in the hpaste?
21:04:05 <Nereid> data and newtype are different things.
21:04:26 <Nereid> tac: wat
21:05:10 <edwardk> shachaf: it can check that you've supplied all the fields
21:05:16 <edwardk> shachaf: and we don't yet have over exposed
21:05:22 <NemesisD> Nereid: well i think internally newtype just uses the native datatype so its more performant, or at least that's what i thought, but i don't know what considerations i should make when choosing
21:05:28 <shachaf> tac: ntohs
21:05:32 <tac> Nereid: Why isn't my PortNum object displaying as 8000? (the port I chose)
21:05:34 <geekosaur> ^^
21:05:46 <tac> Err
21:05:47 <tac> I guess then
21:05:48 <NemesisD> shachaf: i don't have a good reason not to use lens beyond the fact that i haven't learned it yet
21:05:56 <IngCr3at1on> PortNumber (fromIntegral port)
21:06:03 <IngCr3at1on> try that ^ tac
21:06:11 <cmccann> NemesisD: not having learned it yet is in fact an excellent reason to start using it!
21:06:26 <shachaf> IngCr3at1on: Why would that make a difference?
21:06:35 <tac> IngCr3at1on: same issue
21:06:37 <tac> yeah
21:06:40 <cmccann> shachaf: do you have any ideas for my hypothetical book yet?
21:06:43 <IngCr3at1on> it shouldn't but I was curious lol
21:07:07 <shachaf> > ((8000 .&. 0xFF) `shiftL` 8) .|. (8000 `shiftR` 8)
21:07:08 <IngCr3at1on> noone else was suggesting anything :P
21:07:08 <NemesisD> cmccann: i may switch to it before this library is done. i've got a lot of ground to cover with the API
21:07:09 <lambdabot>   16415
21:07:39 <applicative> tac: my portnum 8000 is 16415 too
21:07:44 <tac> ah, I got it
21:07:45 <Nereid> ah, endianness.
21:07:49 <tac> you need to do JUST fromIntegral
21:07:54 <tac> not wrap it in the CTOR
21:07:59 <shachaf> tac: I expect that either something is broken or you're not supposed to use PortNum like that.
21:08:01 <tac> fucking shit API docs >___>
21:08:02 <shachaf> Ah, OK.
21:08:04 <tac> yeah
21:08:09 <shachaf> That sounds like a problem.
21:08:14 <geekosaur> right; network byte order was defined by Sun back in the old days, so it's using 680x0 byte order which is reverse from Intel
21:08:15 <shachaf> They probably shouldn't export the constructor.
21:08:17 <tac> it *used* to be a plain integer, according to the Haskell Wiki
21:08:36 <Nereid> for some reason I thought they *didn't* export the constructor.
21:08:37 <shachaf> cmccann: What sort of ideas?
21:08:48 <edwardk> PortNum doesn't seem to use the default Show. hunting for it
21:08:51 <shachaf> tac: You should file a bug.
21:08:51 <cmccann> shachaf: good ones
21:08:54 <shachaf> edwardk: It uses htons
21:09:00 <edwardk> ah
21:09:03 <shachaf> instance Show PortNumber where showsPrec p pn = showsPrec p (portNumberToInt pn)
21:09:07 <shachaf> portNumberToInt (PortNum po) = fromIntegral (ntohs po)
21:09:20 <tac> shachaf: You know where the GHC bug tracker is?
21:09:22 <shachaf> So they store the number reversed inside the constructor.
21:09:23 <edwardk> yeah exporting the constructor there is kinda dumb if they are going to do that
21:09:42 <shachaf> tac: I don't have the URL memorized, if that's what you mean.
21:09:49 <shachaf> @google ghc bug tracker
21:09:51 <lambdabot> http://hackage.haskell.org/trac/ghc/
21:09:51 <lambdabot> Title: GHC
21:10:00 <shachaf> tac: You might alternatively post to libraries@
21:10:06 <shachaf> I don't remember which one you're supposed to do here.
21:10:58 <shachaf> tac: I appreciate putting effort into reporting the bug and making the library better!
21:11:02 <shachaf> cmccann: Hmm.
21:11:12 <shachaf> cmccann: What is the expected background of readers?
21:11:42 <monochrom> http://www.vex.net/~trebla/haskell/cont-monad.xhtml#yield  yield-style generators using ContT and IORef!
21:12:01 <cmccann> shachaf: a comfortable chair and sufficient free time?
21:12:16 <cmccann> I explicitly do not want to assume any programming background.
21:12:34 <shachaf> I lack a comfortable chair. :-(
21:12:43 <shachaf> Anyway, OK.
21:12:43 <cmccann> well, that part is optional.
21:12:43 <applicative> tac portNumberToInt (PortNum po) = fromIntegral (ntohs po);  foreign import CALLCONV unsafe "ntohs" ntohs :: Word16 -> Word16
21:13:13 <lispy> Hello, World!
21:13:16 <cmccann> shachaf: I really do want to approach this in a "from first principles" way.
21:13:39 <shachaf> It's intended to be "about" programming, though?
21:13:51 <Nereid> what is the expected maturity of readers?
21:14:10 <cmccann> with a side order of logic probably, but yes
21:14:19 <lispy> cmccann: what are you doing? (I don't see an obvious explanation in my scrollback) Writing a book?
21:14:21 <cmccann> Nereid: dunno.
21:14:37 <cmccann> lispy: tossing around ideas for a hypothetical book I've been wanting to write eventually.
21:14:39 <shachaf> lispy: "talking about writing a book" so far.
21:14:54 <lispy> cmccann: I wish you luck.
21:14:55 <shachaf> cmccann is an expert at that.
21:14:57 <lispy> cmccann: what topic?
21:15:08 <lispy> shachaf: Are you discouraging him?
21:15:17 <shachaf> lispy: Not at all!
21:15:22 <lispy> (or her, I don't really know the gender of cmccann)
21:15:59 <cmccann> my first name is amusingly gender-neutral, too.
21:16:10 <tac> goddamnit
21:16:15 <lispy> tac: what?
21:16:31 <lispy> Can we help?
21:16:34 <tac> I dropped into this lowlevel network stuff just so I could set the SO_REUSEADDR socket option
21:16:38 <cmccann> lispy: anyway, the basic premise is a typeful approach to programming from the ground up
21:16:47 <tac> and it still complains that my address is in use T____T
21:17:00 <monochrom> I thought Network already did that
21:17:19 <lispy> tac: There is actually a better solution
21:17:20 <monochrom> so, I would rather bet that you do have an unfinished process
21:17:32 * lispy wonders if he can find it on google again
21:17:51 <hpaste> tac pasted “setSocketOption isn't helping T___T” at http://hpaste.org/81301
21:18:05 <statusfailed> k:w
21:18:13 <statusfailed> whoops
21:18:13 <tac> I appreciate it :)
21:18:14 <monochrom> well, Network haddock definitely says "we set SO_REUSEADDR to true by popular demand" and it happened many years ago
21:18:18 <shachaf> cmccann: I always thought you were named that because you liked pattern matching on sum types.
21:18:48 <statusfailed> cmccann: I'd quite like to see someting along the lines of CodeAcademy, but for Haskell
21:18:49 <cmccann> shachaf: did you spend the last several minutes sitting there trying to come up with a pun on my name?
21:19:03 <statusfailed> an interactive book/tutorial teaching haskell to first-time programmers
21:19:04 <shachaf> cmccann: No, it just came to me.
21:19:04 <statusfailed> would be great
21:19:21 <cmccann> lispy: currently considering concocting a simplified (pure, total) Haskell-ish language to use for examples. the essential unifying theme would be correctness-by-construction, parametricity guarantees, all that kinda stuff.
21:19:58 <tac> cmccann: I had similar plans
21:20:40 <cmccann> statusfailed: I've considered ideas about teaching programming with interactive stuff... that'd be a bigger project though, I think.
21:20:51 <cmccann> tac: oh?
21:21:20 <statusfailed> that's true :)
21:21:27 <lispy> tac: http://flylib.com/books/en/3.223.1.188/1/
21:22:00 <lispy> tac: I've seen better formatted presentations, but that article explains why you get into the state where you think you need SO_REUSEADDR
21:22:12 <lispy> (and consequently why sometimes you *do* need it)
21:22:12 <tac> thanks
21:22:21 <cmccann> statusfailed: actually I've thought more about interactive ways of teaching formal logic or various bits of math, rather than programming
21:22:42 <tac> lispy: any ideas what a quick dirty solution for now would be until I have time to read the whole thing?
21:22:50 <statusfailed> cmccann: You could combine those fairly easily, right?
21:22:57 <cmccann> programming at least has some amount of interactivity inherently involved if you have a REPL to play in
21:23:06 <statusfailed> In fact, a basic text combining mathematics and haskell would be pretty interesting
21:23:11 <tac> cmccann: I think that's an awesome idea
21:23:12 <lispy> tac: IIRC, have the server side initiate the disconnect
21:23:17 <cmccann> statusfailed: yes, there's a lot of overlap, but I'm not sure if I'd want to try to do it all at once.
21:23:28 <shachaf> cmccann: You should talk about a good way of figuring out what type classes "really" are!
21:23:36 <shachaf> (Not that you'll necessarily have type classes.)
21:24:12 <statusfailed> cmccann: I dunno, I think the fact that you can show direct applications of the mathematics you're teaching might make things really interesting
21:24:13 <shachaf> There was a thing elliott and I did in lens a lot, where you start with some class like class Isoy g where iso :: (s -> a) -> (b -> t) -> (g a -> f b) -> g s -> f t
21:24:17 <cmccann> type classes are a formalized notion used for getting statically-checked guarantees of annoying shachaf
21:24:22 <tac> lispy: you mean I just need to exit cleanly with a disconnect every time? Because I usually do that.
21:24:31 <shachaf> And then you reduce the class repeatedly until you figure out what Isoy "really" is.
21:24:35 <tac> I had a bug or something and it broke it though :(
21:24:41 <shachaf> In this case Isoy = Functor
21:24:42 <lispy> tac: Yes, and it also matters which side initiates the disconnect
21:25:08 <shachaf> Or: class Prismy g where prism :: Pointed f => (b -> t) -> (s -> Either t a) -> (g a -> f b) -> g s -> f t
21:25:14 <tac> the server should always be initiating the disconnect
21:25:15 <shachaf> In this case Prismy = Costrong
21:25:20 <tac> unless it crashes, like it did
21:25:28 <lispy> tac: that diagram at the top of the page shows you all the states you can get into. I think you're in one of the FIN_WAIT or TIME_WAIT states
21:25:37 <shachaf> We did a lot of this, and I've never really encountered this sort of process anywhere else.
21:25:42 <lispy> It's been a while since I had to debug something like this :(
21:25:49 <cmccann> statusfailed: I think it would still be working at cross-purposes to try to do both. I agree that'd be a great way to support the logic/math stuff, but not sure I could cover programming in any depth at the same time.
21:26:33 <statusfailed> hm, perhaps you're right
21:26:42 * shachaf mostly agrees.
21:26:42 <cmccann> for teaching logic I'd like some sort of setting that's basically a game-ified version of interactive theorem proving
21:26:56 <tac> lispy: I may have to read through this when I get home
21:26:57 <shachaf> You should talk about linear types!
21:26:57 <tac> thank you though
21:27:09 <cmccann> so it'd actually end up being programming in a sense, via curry-howard
21:27:18 <cmccann> but trying to present it as both would be confusing I think.
21:27:50 <shachaf> What about classical logic? Classical logic is the future.
21:27:50 <statusfailed> cmccann: could always try it out? :)
21:27:53 <tac> thanks again guys.
21:28:20 <cmccann> shachaf: for the hypothetical programming book? I'm considering that. not sure how well it would fit in.
21:28:33 <cmccann> a more limited notion maybe. affine or uniqueness types or whatnot.
21:28:50 <shachaf> I think a lot of people mean affine types when they say linear types.
21:29:23 <cmccann> how much formal logic to include in the hypothetical programming book is something I'm indecisive on.
21:29:48 <monochrom> "Unfortunately it works!" haha
21:30:12 <lispy> tac: oh, here it is: http://hea-www.harvard.edu/~fine/Tech/addrinuse.html
21:30:13 <cmccann> on one hand, it's closely related and useful. on the other hand, cf. what I said above about confusing things by doing too much at once.
21:30:17 <lispy> tac: it says make the client close first
21:30:28 <lispy> tac: aren't you glad I misremembered it? :)
21:31:50 * cmccann also isn't sure what sort of tone and style would be best for such a book.
21:32:07 <lispy> cmccann: have you tried writing a few hours a week on whatever seems like it would go in said bookt and then working with that?
21:32:26 <cmccann> lispy: cf. http://stackoverflow.com/users/157360/c-a-mccann :P
21:32:32 <lispy> kind of like, writing some code to figure out a problem and then refactoring it
21:32:33 <monochrom> use the monochrom poker-face tone
21:32:39 <cmccann> writing is something I have no shortage of :P
21:33:22 <lispy> then refactor it :)
21:34:13 <cmccann> anyway, the default style would pretty much be the tone I use for answers on SO. but that's not entirely the same context as what I have in mind.
21:34:46 <cmccann> monochrom: I'm afraid I'm entirely too prone to colorful turns of phrase to be properly monochrom-atic.
21:35:02 <monochrom> haha
21:35:16 <shachaf> cmccann: You should do it mauke-style.
21:35:31 <lispy> lambda style!
21:35:48 <shachaf> wbruce: Are you the dual of brucem?
21:36:38 <wbruce> shachaf: nope
21:36:54 <lispy> cmccann: http://www.ted.com/talks/derek_sivers_keep_your_goals_to_yourself.html
21:37:24 <shachaf> lispy: That someone said something on ted.com doesn't mean it's true.
21:37:34 <cmccann> keeping things to myself makes it harder to fish for ideas
21:37:43 <monochrom> use the monochrom wake-up-call tone. this tone is exemplified in my sicp article.
21:38:13 <shachaf> cmccann: Do you have concrete problems-to-solve in mind?
21:38:23 <monochrom> "You will run into problems. You may have already run into problems. ...  Ignorance is not bliss anymore. You will know. You are forced to know."
21:38:29 <jollytime> :t read
21:38:31 <lambdabot> Read a => String -> a
21:38:35 <cmccann> shachaf: what do you mean?
21:38:56 <monochrom> "You cannot afford to be unconscious. When you are unconscious, ..." (on --global vs --user)
21:40:01 <shachaf> cmccann: I mean -- well, actually, never mind.
21:40:34 * shachaf isn't making sense.
21:40:45 <ski> shachaf : some people mean uniqueness types
21:41:03 <lispy> shachaf: true. And a quick search of scholar.google.com doesn't turn up the cited study. So it must be false!
21:41:07 <monochrom> "A popular advice suggests you to look for Haskell packages from your Linux distro first, and only if not there use cabal install. That is the most harmful advice ever."
21:41:29 <lispy> monochrom: oy, where is that from?
21:41:38 <monochrom> my sicp article
21:41:43 <cmccann> monochrom: pretty sure I don't have that degree of "apocalyptic doomsday prophet" tone in me, sorry :P
21:41:53 <monochrom> haha
21:42:24 <shachaf> lispy: It's a half-truth at most.
21:42:29 <shachaf> And a strawman.
21:42:32 <shachaf> But anyway.
21:42:45 <shachaf> This is pointless to get into.
21:43:01 <lispy> shachaf: the reasoning was that if you tell someone they give you affirmations right away, "Oh, that's wonderful that you would write a book like that!" And then you get lazy.
21:43:22 <cmccann> if this is still about the "don't talk about your plans" thing, I have an excellent track record of not finishing things I don't tell people about. so there's really little to lose either way.
21:43:23 <lispy> shachaf: but if you keep your goals to yourself you'll do better planning and work towards them more diligently
21:44:04 <cmccann> empirically speaking, I'm more likely to forget about stuff if left to myself than if I mention ideas now and then.
21:44:10 <lispy> shachaf: The reason I linked the video is because I don't think there is a simple do/don't tell rule that works. It's really understanding motivation just a bit better.
21:44:23 <cmccann> for example: shachaf has asked me about whether I'm going to write a book at least thrice.
21:45:01 <cmccann> whereas he's never once reminded me about the projects I've started that he doesn't know about.
21:45:05 <fragamus> @hoogle comparing
21:45:05 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
21:45:09 <lispy> cmccann: yeah, and Hamming's advice is that if you're like him and you want to look good to your friends tell all of them that you'll write a book. That caused him to not want to look like a failure to his friends so he wrote the book.
21:45:54 <cmccann> man, I wish I could be like Hamming
21:46:01 <cmccann> is that from "you and your research"?
21:46:37 <cmccann> (anyone who hasn't read that totally should fyi)
21:46:43 <monochrom> another monochrom wake-up-call tone example, and it is also a fun puzzle! http://article.gmane.org/gmane.comp.lang.haskell.cafe/37154/
21:47:59 <shachaf> "Suppose f 6 is [a,b,c,d,e,f]"
21:48:03 <monochrom> but I do not know whether today's Data.List.sort still produces the same behaviour. anyway, just knowing that it happened once is fun
21:48:04 <cmccann> monochrom: I love the off-hand remark about everyone knowing that floating point addition isn't associative
21:48:18 <monochrom> haha
21:48:19 <lispy> cmccann: yeah, for a while I would re-read it once a year
21:48:33 <monochrom> and yes shachaf, I was not thinking when I re-used the name f
21:49:27 <lispy> cmccann: thinking long and hard about what motivates you historically (and using that to your advantage) might be your tipping point.
21:49:37 <shachaf> @let mon n = take n randoms (mkStdGen 0)) :: [Float]
21:49:37 <lambdabot>   Parse error: )
21:49:46 <shachaf> @let mon n = take n randoms (mkStdGen 0) :: [Float]
21:49:47 <lambdabot>  <local>:2:9:
21:49:47 <lambdabot>      The function `take' is applied to three arguments,
21:49:47 <lambdabot>      bu...
21:49:52 <shachaf> @let mon n = take n (randoms (mkStdGen 0)) :: [Float]
21:49:54 <lambdabot>  Defined.
21:50:00 <lispy> > mon 1
21:50:02 <lambdabot>   [0.74292105]
21:50:09 <lispy> > mon 10
21:50:11 <lambdabot>   [0.74292105,0.2548175,0.2851442,0.35179216,0.15288556,0.88379085,0.6305048,...
21:50:23 <lispy> :t mkStdGen
21:50:26 <lambdabot> Int -> StdGen
21:50:41 <lispy> I was thinking that would need IO but I guess it's using a static seed
21:50:53 <lispy> (the 0 in this case)
21:50:57 <lispy> Why not 42?
21:51:37 <monochrom> because I have slim anecdotal evidence that seed 42 leads to a low quality sequence
21:51:52 <cmccann> historically I have motivation far in excess of persistence. tossing around ideas won't hinder me from starting, the bigger danger is writing three chapters and then getting distracted :P
21:52:11 <monochrom> and because I like starting from 0? :)
21:52:21 <wmasson> if I'm importing a record e.g data Test = { test1 :: String, test2 :: String} is it possible to also import the selectors test1, test2? Test is exported but test1, test2 aren't exported specifically.
21:52:43 <shachaf> wmasson: Well, once you fix the syntax error, you can probably just say Test(..)
21:53:00 <lispy> wmasson: if they are not exported then you cannot import them.
21:53:21 <wmasson> ok thanks
21:53:49 <lispy> wmasson: but they could be implicitly exported
21:54:04 <lispy> data Foo where ... exports everything. data Foo (X) where only exports X
21:54:53 <shachaf> monochrom is so lazy
22:02:17 <lispy> I want to program for the .NET CLR using Haskell. Anyone want to write my compiler?
22:02:45 <shachaf> I think the CLR is a better target than the JVM, at least.
22:02:59 <cmccann> didn't this conversation happen earlier?
22:03:02 <shachaf> But from what I remember it still doesn't fit GHC all that well.
22:03:03 <lispy> yes
22:03:08 <shachaf> Then again, nor does x86.
22:03:11 <lispy> I have a one track mind until the track changes
22:03:22 <shachaf> cmccann knows a lot about the CLR, right?
22:03:27 <cmccann> not really.
22:03:36 <shachaf> About .NET?
22:03:37 <cmccann> I know about as much as can be learned from reading eric lippert's blog.
22:03:44 <cmccann> and using C# in my day job.
22:03:52 <shachaf> I read some of his posts.
22:04:16 <monochrom> main = putStrLn "using System; public class MyClass { ...
22:04:28 <cmccann> he's pretty great. he doesn't work on C# anymore though. :[
22:04:34 <shachaf> What does he work on now?
22:04:51 <cmccann> he got a job at coverity.
22:04:55 <lispy> This looks handy: http://hackage.haskell.org/package/language-cil
22:04:57 <shachaf> cmccann: I think a big conclusion from reading some of his posts was "mutability makes a lot of things hard".
22:05:00 <shachaf> Oh, right.
22:05:27 <Quadrescence> mutability happens to make a lot of things easy, too!
22:05:34 <shachaf> hi Quadrescence
22:05:36 <Quadrescence> hi
22:05:50 <lispy> Quadrescence: examples or your statement didn't happen!
22:05:51 <cmccann> inheriting the legacy of a cheap knockoff of Java and the garbage that entails makes a lot of things hard too.
22:06:03 <shachaf> That too.
22:06:04 <tac> lispy: according to netstat, my program isn't running, but the socket I want to connect to is still in the LISTENING state D:
22:06:07 <cmccann> mutability does make some things easier, though.
22:06:10 <monochrom> mutability makes race conditions easy!
22:06:10 <cmccann> like creating bugs.
22:06:12 <shachaf> Like covariant mutable arrays.
22:06:14 <cmccann> and race con--dammit monochrom
22:06:18 <shachaf> What's with inheriting that?
22:06:29 <monochrom> irc also makes race conditions easy! :)
22:06:33 <cmccann> >:[
22:06:35 <lispy> So, did UHC have a .NET backend? (Why did UHC disappear, did it disappear?)
22:06:56 <shachaf> lispy: You should just write in C#.
22:06:58 <shachaf> I hear it's good.
22:06:58 <Quadrescence> lispy, do i really need to give examples
22:07:00 <lispy> tac: did you see the final link I sent you? I eventually found the article I like
22:07:11 <shachaf> Quadrescence: No.
22:07:15 <Quadrescence> thanks
22:07:30 <cmccann> lispy: anyway, in all seriousness I doubt it would be too hard to compile something that's mostly Haskell into something that runs, perhaps slowly, on the CLR.
22:07:40 <tac> lispy: I got this one: http://flylib.com/books/en/3.223.1.188/1/
22:07:42 <shachaf> Running slowly is easy.
22:07:46 <lispy> shachaf: I'd rather learn/use F# than C#, but yeah, C# is one of the better code monkey languages
22:08:02 <cmccann> C# is remarkably tolerable for a mainstream language, yes.
22:08:07 <shachaf> I think ddarius said he'd rather use C# than F#.
22:08:17 <shachaf> Therefore I assume it must be better.
22:08:21 <monochrom> mutability makes run-time monitoring easy, e.g., count how many times you call a procedure
22:08:35 <lispy> tac: better: http://hea-www.harvard.edu/~fine/Tech/addrinuse.html
22:08:41 <Quadrescence> but surely we can just thread everything thru a counting monad
22:08:42 <tac> oh, it looks like via netstat -anp, there are a few dozen in CLOSE_WAIT
22:08:47 <shachaf> cmccann: Isn't there an x86 emulator for .NET or something? Your job is basically done!
22:08:54 <shachaf> Or maybe it was Java.
22:08:59 <cmccann> shachaf: good point, that's bound to work well.
22:09:46 <shachaf> Quadrescence: I think neither you nor lispy should resort to mild trolliness in here.
22:09:49 <shachaf> That would be best for everyone.
22:10:02 <monochrom> err, wait, an x86 emulator for .NET?! hahaha, God, people do make sure that plausible things exist, no? :)
22:10:18 <Quadrescence> shachaf, yes you're right my last comment was mildly trolly but nothing before that was
22:10:19 <cmccann> shachaf: especially since we all know that pervasive mutability is one of the five worst ideas in programming ever, right?
22:10:42 <shachaf> worst_ideas++
22:10:46 <shachaf> cmccann: What are the other five?
22:10:46 <cmccann> :D
22:10:59 <monochrom> null refereince
22:11:08 <cmccann> yes
22:11:10 <cmccann> also, C++
22:11:13 <monochrom> http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare
22:11:47 <lispy> Quadrescence: I didn't mean to troll. I was just wondered what you have in mind.
22:12:01 <monochrom> just some time ago, a null reference did brought down efnet
22:12:04 <Quadrescence> lispy, i didn't think you were trolling
22:12:11 <monochrom> and damn my English
22:12:22 <shachaf> I'm more confident in lispy's ability to not troll than in Quadrescence's, but I'd rather people were just nice.
22:12:24 <tac> lispy: I think I got it
22:12:24 <shachaf> (I'm excluded here.)
22:12:32 <lispy> heh
22:12:53 <shachaf> monochrom: Your English is wonderful!
22:12:56 <lispy> I've been immutable for a while now. I'm not sure I could explain what I'm missing.
22:12:59 <Quadrescence> shachaf, wait do you think me saying that mutability makes some things easier was a troll comment?
22:12:59 <shachaf> I don't know anyone who speaks English quite like you.
22:13:04 <lispy> shachaf: You're*
22:13:06 <cmccann> anyway, the inability to meaningfully restrict possible behaviors is the biggest problem is basically every language, one way or another
22:13:06 <SamanthaD> Did I just hear that there's an x86 emulator for .NET?!
22:13:22 <shachaf> Quadrescence: No. The "monad" thing sort of was, but never mind it.
22:13:28 <Quadrescence> oh yeah that was
22:13:32 <shachaf> SamanthaD: I know there's one for Java.
22:13:36 <shachaf> I might've been confusing them.
22:13:37 <Quadrescence> though it was supposed to be funny, not trolly
22:14:06 <lispy> shachaf: well, you can run java code on the clr, right?
22:14:15 <shachaf> I guess there might be something for that.
22:14:16 <SamanthaD> shachaf: What joy! Excuse me while I go write a web app in 8086 assembler...
22:14:23 <lispy> I saw some sort of recompilation thing. I just can't recall which direction it want.
22:14:29 <shachaf> http://jpc.sourceforge.net/home_home.html
22:14:45 <lispy> oh, a sf.net url, that will load in a while
22:14:49 * lispy queues it up
22:15:05 <shachaf> There's also an x86 emulator in JavaScript.
22:15:18 <lispy> and emscripten
22:15:19 <shachaf> You could probably connect something up if you cared.
22:15:27 <monochrom> "Doom in an Applet!" "DSL Linux Desktop!"  X|
22:15:35 <cmccann> hahaha
22:15:56 <cmccann> shachaf: I once wrote a mandelbrot renderer in GNU make, did I ever show you that?
22:16:02 <lispy> How about running windows in XEN and then running JPC in Java and then running windows, ad nauseum
22:16:03 <shachaf> cmccann: I believe you did.
22:16:21 <cmccann> and when I say I wrote it in make I mean a makefile that uses nothing but environment variables, echo, and recursive invocations of make.
22:16:26 <shachaf> how about monoids
22:16:27 <shachaf> they are so easy
22:17:01 * lispy pictures the salt&pepper classic "let's talk about sex" rewritten to be about monoids
22:17:04 <thoughtpolice> cmccann: sedtris is definitely one of my favorites
22:17:32 <cmccann> I assume that's exactly what it sounds like
22:18:28 <lispy> huh, so UHC has a java backend: http://www.cs.uu.nl/groups/ST/Projects/ehc/ehc-jazy-doc.pdf
22:18:28 <thoughtpolice> yep
22:18:35 <monochrom> hahaha what?! sed tetris?!
22:18:43 <cmccann> ah here we are: https://github.com/isomorphism/esoteric-fractals/blob/master/Make/Makefile
22:18:49 <cmccann> I am inordinately proud of that.
22:18:53 <cmccann> it was actually quite fun to write.
22:19:06 <cmccann> it's also much faster than you'd expect.
22:19:12 <cmccann> (which is not saying much)
22:19:15 <thoughtpolice> monochrom: yep! it does horrible things to your terminal scrollback, but it does play and everything.
22:20:21 <lispy> and UHC has a partial backend for CLR
22:21:17 <shachaf> cmccann: Is your language going to have structural subtyping?
22:21:25 <shachaf> cmccann: Is your language going to have substructural typing?
22:21:33 <cmccann> haha
22:21:50 <cmccann> well played, shachaf.
22:21:50 <cmccann> also, maybe.
22:21:50 <cmccann> to both.
22:21:59 * lispy clones uhc
22:22:10 <shachaf> lispy: Is it whc now?
22:22:18 <lispy> I don't know, why would that be?
22:22:25 <shachaf> Well, you cloned it.
22:22:35 <lispy> Oh, you think that's punny?
22:22:52 <lispy> You should have to sit in the punelty box
22:23:11 <shachaf> @@ @run (@where rot13) "lispy"
22:23:13 <lambdabot>   "yvfcl"
22:23:15 <shachaf> No wonder.
22:25:12 <lispy> Someday I will change my nick to be my real name
22:25:22 <lispy> But until them...
22:25:24 <lispy> n*
22:25:37 <cmccann> real names are overrated.
22:25:48 <edwardk> yeah
22:26:01 <edwardk> i only have instant name recognition. who wants that
22:26:06 <cmccann> haha
22:26:13 <cmccann> sounds inconvenient.
22:26:48 <lispy> For a while I went as lispy|dagit
22:27:08 <lispy> In the hopes of updating people's mental hashtable
22:27:18 <edwardk> well, its important to be consistent. if you are edwardk in one forum ekmett in another edwardkmett in a third and kmett on a fourth, nobody can tell who you are. and con't get me started on cmccann vs C A.McCann -- clearly different people
22:27:20 <shachaf> > zipWith (\x y -> chr (ord x .|. ord y)) "lispy" "dagit"
22:27:22 <lambdabot>   "liwy}"
22:27:33 <cmccann> edwardk: yes, very true.
22:27:43 <shachaf> Oops.
22:27:45 <edwardk> er don't
22:27:45 <shachaf> Oh.
22:27:51 <shachaf> Hmm.
22:28:03 <shachaf> So given an iso for chr/ord, how can I write that nicely?
22:28:12 <shachaf> chr (ord x `f` ord y)
22:28:20 <cmccann> lispy: clearly you should be "DagiT Lispy" instead. once people get used to it you can swap out the base monad.
22:28:37 <monochrom> hahaha
22:28:57 <monochrom> are we drunk or something!
22:29:33 <statusfailed> Is there a better way to write "flip (set someLens) someRecord" ?
22:29:36 <edwardk> dagiT is the dagi transformer?
22:29:43 <cmccann> obviously.
22:29:43 <monochrom> yeah!
22:29:55 <edwardk> set someLens ?? someRecord
22:30:10 <statusfailed> thanks :)
22:30:11 <edwardk> :t (??)
22:30:12 <lambdabot> Functor f => f (a -> b) -> a -> f b
22:30:28 <edwardk> that is an infix flip we supply so we don't have to supply flipped versions of all the operators ;)
22:30:40 <monochrom> haha smart
22:30:53 <shachaf> Clearly we should have one "set" as in imperative and one "set" as in past tense.
22:30:58 <edwardk> in its common usecase the ?? goes where the argument that is being replaced would go
22:31:04 <statusfailed> oh, where ??? is the "hole"
22:31:07 <shachaf> And Haskell should let you specify the tense of a word when you type it.
22:31:08 <statusfailed> tooslooow
22:31:11 <edwardk> statusfailed: yeah
22:31:16 <statusfailed> I like that!
22:31:24 <edwardk> statusfailed: we wanted ? but too many people complained
22:31:30 <statusfailed> is ? in use elsewhere?
22:31:39 <ski> holes ?
22:31:50 <edwardk> some people like it for local operator names and for things like b ? (t,f)  hacks
22:31:55 <shachaf> ski: (f x ? y) ~~ (\hole -> f x hole y)
22:32:12 <cmccann> or (b ? t $ f)
22:32:13 <statusfailed> shachaf: does that need an extension to use?
22:32:21 <shachaf> No. It's just flip.
22:32:22 <ski> shachaf : <http://hackage.haskell.org/trac/ghc/wiki/Holes>
22:32:24 <edwardk> and yeah there is the problem that ? can't be jammed up against an identifier without it thinking its an implicit param
22:32:27 <shachaf> ski: Yes, not that kind of hole.
22:32:57 * cmccann also has a ?? operator in his fake Prelude >:[
22:32:58 <ski> i was wondering whether that one uses `?'
22:33:16 <shachaf> ski: Oh.
22:33:22 <shachaf> GHC's new "type holes" use _
22:33:27 <shachaf> Unfortunately you can't name them.
22:33:37 <shachaf> (And they're not actually type holes.)
22:33:57 <tac> omg holes
22:34:01 <shachaf> cmccann: Your noble language thing should let you specify partial types!
22:34:05 <edwardk> there was a proposal to permit naming by letting you use _foo whenever _foo wasn't in scope as a hole
22:34:08 * tac wants holes support so bad
22:34:44 <cmccann> shachaf: I'm not sure how that would really add much for the intended purpose.
22:35:02 <lispy> have you folks seen the type change inference?
22:35:12 <shachaf> Depends on what the intended purpose is.
22:35:24 <lispy> You do type inference and while you do that keep track of changes that would make the type incorrect program type correct and then suggest them
22:35:38 <shachaf> Anyway, as Oleg mentioned, Haskell 98 already lets you specify partial types.
22:35:51 <lispy> Oh that Oleg
22:36:15 <shachaf> http://okmij.org/ftp/Haskell/partial-signatures.lhs
22:36:19 <cmccann> shachaf: if you mean the hypothetical language created to go with the hypothetical book the intended purpose is clarity of concepts, not syntactic conveniences :P
22:36:49 <ski> lispy : related to type error slicing ?
22:37:26 <tac> lispy: ahhh. I think I figured out why my program kept screwing up the socket now
22:37:46 <edwardk> ski: its different, but has a similar motivation
22:37:49 <tac> I was opening up a child process and when haskell crashed, the process keeps the sockets open and it becomes an orphan
22:37:58 <ski> see "Skalpel: A Type Error Slicer for SML" <http://www.macs.hw.ac.uk/ultra/skalpel/> e.g.
22:37:59 <shachaf> tac: So monochrom was right all along.
22:38:13 <shachaf> You should've listened to monochrom!
22:38:17 <ski> edwardk : perhaps more like error correcting parsers ?
22:38:25 <lispy> ski: I've not heard of type error slicing
22:38:39 <cmccann> shachaf: I thought oleg generally spelled it as "Haskell 98!"
22:38:46 <shachaf> > product [1..98]
22:38:47 <monochrom> I forgot to mention the netstat command for finding out who hogs the port
22:38:48 <lambdabot>   942689044888324774562618574305724247380969376407895166349423877729470707002...
22:38:50 <lispy> ski: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.5.4267
22:38:51 <edwardk> i actually have been playing with using a simple little approach based on inserting and deleting terminals to get those kind of messages out of inference
22:39:01 <lispy> ski: I have not read that paper yet, but it's on my list
22:39:13 <lispy> tac: ah
22:40:04 <ski> lispy : a type error slicer finds every and only the locations the contribute to the type error in question
22:40:19 <lispy> ski: ah, that's different but interesting
22:40:40 <lispy> ski: the thing I linked actually tries to suggest type correct programs
22:40:46 <ski> at least one of the locations must be changed, and it doesn't include locations that wouldn't help fixing the error
22:41:19 * lispy nods
22:41:43 <edwardk> type error slicing is different, but it can guide this by telling you where you can make syntactic modifications that are relevant to the type error
22:41:48 <ski> (which is the correct one to change depends on what the programmer had in mind -- the system can't read minds)
22:42:12 <shachaf> edwardk: So it can find the minimal number of unsafeCoerces needed to make the program type-check?
22:42:31 <ski> (also, perhaps the programmer determines that more was wrong, and so still wants to change some other location(s) (as well as at least one of the pinpointed ones))
22:42:34 <edwardk> so you can use a type error slicer to find the locations and then use a simple insert/delete token recovery mechanism to try to proceed farther
22:42:40 <edwardk> shachaf: =P
22:42:50 <edwardk> shachaf: if you have unsafeCoerce in scope, yes ;)
22:43:07 * lispy is now building uhc
22:43:24 <cmccann> perhaps shachaf always has unsafeCoerce in scope.
22:43:45 <ski> perhaps shachaf lives in an inconsistent world
22:43:45 <shachaf> cmccann: Well, I just derive it from scratch on the spot.
22:44:18 <cmccann> how's the current project going? gonna let unicode win?
22:44:36 <shachaf> The MD5 thing?
22:44:40 * lispy hits a minor snag in the build system and tries to resume
22:44:45 <shachaf> cmccann: That's your my work not to do now.
22:44:51 <cmccann> oh, ok.
22:44:51 <shachaf> I'm done with not doing it myself.
22:45:03 <cmccann> I don't have time to not do it right now. maybe later.
22:45:08 <cmccann> you'll have to not do it for a while longer.
22:45:16 <shachaf> Hmm.
22:45:26 <shachaf> Maybe lispy can not do it for a bit?
22:45:33 <cmccann> that's a good plan.
22:46:04 <monochrom> or a good not-plan?
22:46:05 <shachaf> cmccann: My conclusion was that the constraints, in particular the UTF32 thing, make it very hard compared to most circumstances in which people have done things like this.
22:46:34 <cmccann> shachaf: pf, "very hard". don't be a quitter, shachaf.
22:46:53 <shachaf> Maybe I should just file a bug report.
22:47:08 * lispy is good at can not doing it
22:47:18 <cmccann> it wouldn't be as entertaining without a proof of concept though. :[
22:47:24 <shachaf> cmccann: Agreed.
22:47:37 <shachaf> It would be such a great proof of concept.
22:48:54 <shachaf> So conal calls CoYoneda "WithCont"?
22:49:05 <edwardk> shachaf: yes
22:49:10 <shachaf> OK.
22:49:12 <shachaf> Too many names.
22:49:38 <cmccann> names are overrated.
22:49:47 <lispy> I've not run into this build problem before. setup.exe keeps trying to find /LICENSE
22:50:07 <shachaf> "I've not run into this build problem before. setup.exe"
22:50:55 <shachaf> In my experience that always leads to trouble.
22:53:40 <lispy>  -fglasgow-exts is deprecated: Use individual extensions instead
22:53:46 <lispy> this does not bode well
22:54:02 <monochrom> yikes. it's probably a bit old
23:01:52 <tac> is there a while loop-like function?
23:06:25 <otters> oh boy
23:06:34 <otters> does anybody have any tips for combining a State monad and attoparsec's Parser monad
23:07:37 <otters> or should I use Parsec instead
23:08:18 <edwardk> crap like that is kind of why i wrote trifecta ;)
23:10:41 <lispy> This makefile is quite tricky
23:11:20 * lispy tries to build uhc without the experimental clr support
23:11:45 <edwardk> otters: sadly i've tried and failed to write an instance for the types in the parsers package for attoparsec. =( bos doesn't expose enough internals to write an instance where type inference doesn't suck. =/
23:12:17 <edwardk> if that worked you could use parsers to write the parser and then just use StateT on your parser directly
23:12:56 <otters> yeah
23:13:02 <otters> Parsec appears to support updating user state
23:18:08 <monochrom> someone asked earlier today: there are so many blaze-* packages, which one is the main one, which one to start with?
23:18:20 <monochrom> I think I now know the answer: trifecta :)
23:18:40 <edwardk> hah
23:19:07 <monochrom> also! when will trifecta depend on lens?!
23:19:34 <edwardk> it does in HEAD
23:19:39 <monochrom> onoes
23:19:53 <monochrom> damn my dream comes true
23:20:13 <monochrom> afterall, if they use JVM to emulate x86, what else will they not do!
23:20:14 <otters> anybody know how to make a parsec Stream from a list
23:20:39 <monochrom> list is already Stream
23:20:41 <edwardk> [a] should be a valid Stream instance
23:20:50 <otters> oh, gotcha
23:21:39 <monochrom> see my http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#token for how to use tokenPrim for arbitrary list!
23:25:12 <tac> I'm tired and not in the mood to write professional bug reports, so here it is: https://github.com/haskell/network/issues/83
23:25:23 <tac> The network PortNum issue from earlier
23:28:01 <tac> night all
23:43:43 <bsrkaditya> Hi,
23:43:46 <bsrkaditya>  Is replicateM strict? I am asking this because I am generating a large number of random numbers using it, and I am getting a stack size overflow because of it
23:47:19 <Nereid> bsrkaditya: that's not really a replicateM issue. it's the StdGen or whatever you're using that's not strict.
23:47:39 <bsrkaditya> yeah I am using StdGen
23:47:52 <bsrkaditya> but how can that be?
23:47:52 <Nereid> bsrkaditya: but if you evaluate the numbers as it generates them then it shouldn't be a problem
23:48:37 <Nereid> otherwise you're building up thunks inside the StdGen.
23:48:42 <bsrkaditya> In this case I can evaluate then as it generates them.. I guess that solves the problem!
23:49:09 <bsrkaditya> thanks nereid!
23:49:13 <Nereid> np
23:53:37 <statusfailed> why does 'view' have a MonadReader constraint?
23:54:17 <edwardk> :t view
23:54:19 <lambdabot> MonadReader s m => Getting a s t a b -> m a
23:54:26 <edwardk> m can be (->) s
23:54:27 * hackagebot lens 3.8.4 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.4 (EdwardKmett)
23:54:29 * hackagebot trifecta 1.0 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.0 (EdwardKmett)
23:54:34 <edwardk> then that is Getting a s t a b -> s -> a
23:54:40 <edwardk> but it also works in monad transformer stacks
23:54:45 <edwardk> foo = do x <- view _2
23:55:19 <edwardk> the haddocks for it describe a bunch of example signatures for it without using MonadReader
23:56:38 <edwardk> it fits the lens philosophy of letting each combinator work in as many contexts as reasonably possible
23:57:10 <statusfailed> oh, cool
23:57:21 <statusfailed> so the idea is "generalise as much as possible"?
23:57:33 <edwardk> well, as much as possible without damaging inference
23:57:55 <edwardk> it is important to me that users not generally have to use signatures on things or ad hoc re-monomorphization combinators
23:59:09 <edwardk> my experience is if i implement enough generality in the right places users end up writing less code and 'what does what' becomes much more obvious.
