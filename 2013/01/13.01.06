00:00:53 <M30W> monochrom: ping
00:10:04 <Nereid> :(((((
00:10:17 <Nereid> Graphics.UI.GLFW.loadMemoryTexture2D takes a String, not a ByteString.
00:10:19 <Nereid> :(
00:10:57 <Nereid> deep sadness
00:11:45 <Ralith> that's very silly
00:11:47 <Moggle> Does <$> have a lower precedence than <*>?
00:12:38 <Nereid> ghci :i will tell you.
00:12:46 <Nereid> they have the same precedence.
00:12:52 <Nereid> infixl 4
00:13:13 <Nereid> (and it better not be lower!)
00:15:20 <Moggle> Ah, thanks.
00:17:45 <mikeplus64> Nereid: i submitted a patch to GLFW-b a while ago but it wasn't accepted because it didn't have tests and i'm too bad at opengl to add them
00:17:56 <mikeplus64> (for loadTexture2D (it took a ByteString))
00:18:06 <Nereid> what.
00:18:57 <Ralith> mikeplus64: couldn't you just copy the tests for the other one?
00:19:09 <mikeplus64> Ralith: other one?
00:19:35 <mikeplus64> oh, i only added loadTexture2D, not loadMemoryTexture2D
00:24:52 <Moggle> What's the best test writing library for Haskell, anyway? To Hackage!
00:26:42 <johnw> writing library?
00:26:52 <simon> library for writing tests, I assume
00:27:43 <Jafet> The bestest writing library
00:28:26 <Eduard_Munteanu> Quickcheck is pretty common.
00:28:55 <johnw> there's hspec, HTF, HUnit (more low-level than those two), QuickCheck, doctest
00:29:03 <johnw> they are all pretty good, suite to your tastes
00:31:53 <Moggle> HSpec looks fantastic.
00:31:59 <Moggle> Modeled after RSpec (and I love RSpec)
00:32:16 <johnw> well, another happy customer then
00:34:02 <tobias_> hi there, can someone help me in installing quickcheck? I dunno where i can get the package
00:35:54 <Moggle> cabal install quickcheck
00:35:54 <M30W> :t data ServerEnvironment = ServerEnvironment { serverFiles :: HashSet [File] }
00:35:56 <Moggle> ?
00:35:56 <lambdabot> parse error on input `data'
00:35:56 <Lethalman> @let foo = "bar"
00:35:58 <lambdabot>  Defined.
00:36:00 <Lethalman> oh
00:36:02 <Lethalman> it works here :(
00:36:11 <M30W> :t serverFiles :: HashSet [File]
00:36:12 <lambdabot> Not in scope: `serverFiles'
00:36:12 <lambdabot>     Not in scope: type constructor or class `HashSet'
00:36:12 <lambdabot> Not in scope: type constructor or class `File'
00:36:14 <Lethalman> on my local lambdabot I get Failed to load interface for `ShowIO'
00:36:19 <Lethalman> any ideas?
00:36:20 <M30W> Oh duh
00:36:47 <Lethalman> > foo
00:36:50 <lambdabot>   "bar"
00:37:14 <M30W> Lethalman: Your lamdabot in a channel on freenode?
00:37:22 <Lethalman> M30W, no
00:37:41 <Nereid> argh
00:37:43 <M30W> Lethalman: Why you want your own? :P
00:37:51 <Lethalman> M30W, because it's another server?
00:37:57 <M30W> Oh fair enough
00:38:15 <Lethalman> looks like newer show package doesn't have ShowIO
00:38:29 <Lethalman> so, in hackage there seems to be an outdated version of lambdabot :(
00:38:39 * M30W would expect asking an operator of the bot to invite it to a second server but okay. ^_^ -- Not even sure if the bot has cap with multi-server
00:39:00 <Nereid> aw, there's no TUIO library on hackage
00:39:09 <Nereid> I should make one.
00:39:09 <Nereid> :)
00:39:15 <M30W> TUIO?
00:39:17 <Lethalman> @hoogle ShowIO
00:39:17 <lambdabot> No results found
00:39:21 <Lethalman> sigh
00:39:47 <Lethalman> @undefine foo
00:39:48 <M30W> Lethalman: Maybe lamdabot has the old show?
00:39:53 <Lethalman> M30W, yes
00:40:02 <Lethalman> it uses old show
00:40:04 <M30W> 19:38    Lethalman | so, in hackage there seems to be an outdated version of lambdabot :(
00:40:12 <M30W> Maybe it's as new as exists ^_^
00:40:31 <Lethalman> M30W, the lambdabot here works, I don't think so
00:40:39 <Nereid> darcs has a newer version
00:40:52 <M30W> Ha
00:41:13 <Nereid> I never managed to compile it though
00:41:26 <Nereid> probably my own fault for using ghc 7.6
00:43:16 <Nereid> ok, cool.
00:43:55 <Nereid> I have a little program that takes multitouch input data from my tablet via TUIO and draws the points on an opengl window.
00:49:16 <Lethalman> mh darcs get very slow
00:54:23 <Lethalman> ah
00:54:34 <Lethalman> old-fashioned format :(
00:55:29 <Nereid> it's slow regardless
00:57:04 <bitonic> it’s not *that* slow...
00:58:08 <Nereid> :p
00:59:11 <Lethalman> Setup: At least the following dependencies are missing: <- a list of all packages but doesn't say which of them sigh
01:03:21 <Lethalman> ok I have all of those dependencies installed
01:04:33 <hpaste> Lethalman pasted “Lambdabot darcs” at http://hpaste.org/80353
01:04:44 <Lethalman> help ^^ :P
01:05:43 <Lethalman> ah, after all there is 4.2.3.3 in hackage, but I thought I installed it.... it's so weird
01:05:59 <Lethalman> i have .cabal/bin/lambdabot but cabal info says it's not installed
01:06:27 * Lethalman so confused
01:06:40 <Nereid> don't ask cabal, it wouldn't know.
01:06:43 <Nereid> cabal isn't a package manager.
01:06:50 <Nereid> ghc-pkg ask ghc-pkg
01:06:53 <Nereid> er
01:06:54 <Nereid> ask ghc-pkg
01:07:12 <Lethalman> Nereid, but cabal info foo says whether a package is installed or not
01:07:21 <Lethalman> if I installed it with cabal
01:07:27 <Lethalman> no?
01:07:31 <Nereid> I guess.
01:07:41 <Nereid> I always use ghc-pkg.
01:08:17 <Lethalman> so ghc-pkg is much like dpkg where cabal is like apt?
01:10:30 <Nereid> perhaps. except cabal is less than that.
01:12:22 <Nereid> cabal doesn't remove packages, nor does it track executables (as opposed to libraries)
01:13:23 <Lethalman> ah
01:13:46 <Nereid> well, cabal doesn't track anything. that's the job of ghc-pkg
01:13:56 <Lethalman> I've just cabal install lambdabot, and cabal info lambdabot still says not installed
01:14:05 <Nereid> yep, that would be why.
01:14:32 <Lethalman> Nereid, but for other packages it says installed
01:14:41 <Nereid> yes, those other packages provide libraries.
01:14:46 <Lethalman> ah
01:14:49 <Lethalman> ok
01:14:57 <Nereid> http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
01:15:17 <Lethalman> anyway, the darcs version doesn't seem to be more up-to-date than the hackage version
01:15:38 <Nereid> oh, perhaps.
01:15:41 <Lethalman> and I can't compile the darcs version
01:15:47 <Lethalman> so now I'm clueless :)
01:15:47 <Nereid> no surprise there. :p
01:16:05 <Lethalman> Nereid, but I can't compile the darcs version because it says I miss dependencies that are rather installed :(
01:16:21 <Nereid> building your own lambdabot is some "you're on your own" adventure. I think.
01:16:36 <Nereid> anyway, time to get some sleep.
01:17:23 <Lethalman> ah!
01:20:06 <davorak> What can I do to debug: "roundTrip: Could not find module `Outputable'", with ghc and/or ghci? I am using the -package ghc flag
01:20:40 <Lethalman> yeah!!!!
01:20:42 <Lethalman> got it working!
01:20:50 <Lethalman> Nereid, deleted State/state file :P
01:21:57 <davorak> congrats
01:24:52 * hackagebot hlint 1.8.40 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.40 (NeilMitchell)
01:25:22 <hpaste> art2art pasted “squash” at http://hpaste.org/80355
01:25:30 <art2art> hello!
01:29:53 * hackagebot http-conduit 1.8.6.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.6.2 (MichaelSnoyman)
01:29:55 * hackagebot http-reverse-proxy 0.1.1.1 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.1.1 (MichaelSnoyman)
01:29:57 * hackagebot network-conduit 0.6.2.2 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.6.2.2 (MichaelSnoyman)
01:37:29 <art2art> Does anyone know how the same function is called 'do-notation' can be glued together into a single function?
01:37:43 <art2art> http://hpaste.org/80355
01:40:20 <Moggle> @src zipWith4
01:40:20 <lambdabot> Source not found. I've seen penguins that can type better than that.
01:40:39 <hpaste> Saizan annotated “squash” with “squash (annotation)” at http://hpaste.org/80355#a80356
01:41:06 <Saizan> art2art: something like that paste should work
01:41:28 <c_wraith> Moggle: it's pretty much identical to the source of zipWith
01:41:42 <Moggle> c_wraith: was just curious if the applicative style was used
01:42:14 <c_wraith> it'd have to use ZipList wrapping
01:42:23 <c_wraith> which is far too heavy to actually use in real code
01:42:32 <c_wraith> (syntactically heavy, that is)
01:42:37 <Moggle> ZipList incurs a performance penalty?
01:42:41 <Moggle> oh, okay :P
01:45:13 <art2art> Saizan: Thanks! I thought there are a built-in function for this case.
02:01:48 <M30W> How do you IORef a HashSet ?
02:02:58 <M30W> data A = { ... }; data X = X { y :: IORef HashSet A }
02:03:50 <M30W> data A = { ... }; data X = X { y :: IORef HashSet [A] } -- *
02:05:14 <Lethalman> M30W, maybe IORef (HashSet A)
02:05:57 <M30W> Lethalman: Thank-you; ha, I tried $ between idk why I didn't try parens.
02:07:28 <bourbaki> Moin
02:07:34 <Lethalman> :k Maybe $ Int
02:07:35 <lambdabot> Not in scope: type variable `$'
02:09:21 <bourbaki> Quick question reguarding some class stuff, does this look ok http://hpaste.org/80357 ? Aim of this is to get around having to add newtypes into the type of the Mo to get Add and Mul working.
02:09:31 <M30W> http://hackage.haskell.org/packages/archive/unordered-containers/0.2.3.0/doc/html/Data-HashSet.html -- How the hell do you define a HashSet ?
02:09:54 * hackagebot yesod-fay 0.2.0.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.2.0.1 (MichaelSnoyman)
02:11:10 <startling> M30W: fromList
02:11:28 <startling> or 'empty' or 'singleton' I guess
02:11:30 <M30W> startling: Oh man seriously!
02:11:31 <M30W> Thanks
02:11:45 <startling> M30W: last function on the page. :)
02:11:51 <M30W> startling: Yea. :P
02:13:19 <bourbaki> edwardk `nand` ping
02:13:53 <startling> > edwardk `nand` ping
02:13:55 <lambdabot>   Not in scope: `edwardk'Not in scope: `ping'Not in scope: `nand'
02:13:55 <lambdabot>  Perhaps yo...
02:13:58 * M30W read bourbaki 's message as code
02:14:03 <M30W> startling: ^5
02:14:08 <bourbaki> ?
02:14:10 <`nand`> pong
02:14:28 <startling> bourbaki: `nand` looks like an infix function. :)
02:14:33 <bourbaki> Hey `nand` remember that you helped me with that math structure stuff the other day?
02:14:38 <M30W> startling: ^_^
02:14:38 <`nand`> no
02:14:42 <M30W> `nand`: yes
02:14:59 <M30W> startling: *
02:15:29 <bourbaki> `nand`: Ok :) you did so though you showed me this Additive and Multiplicative Monoid stuff, i did not really liked this though because i had to extend the types inside the classes.
02:15:59 <bourbaki> I tried to come up with something different so i first build everything with data and it felt like OOP now i have this approach here
02:16:02 <`nand`> oh, that
02:16:10 <`nand`> that was just an idea, I have no idea how viable it'd be in practice
02:16:12 <bourbaki> And would like to get some feedback http://hpaste.org/80357
02:16:22 <covi> My parseRaw function only returns a list of length 1, while the input file has several chunks of text seperated by the delimiter. What's wrong?    http://hpaste.org/80300
02:16:30 <bourbaki> I use that structure type to tag the classes
02:16:47 <bourbaki> And i think it looks not bad to have the operators encoded in the class instances
02:16:47 <M30W> type ServerM a = ReaderT ServerEnvironment IO a
02:17:00 <M30W> Could the a's be removed and have the same functionality?
02:17:32 <bourbaki> Just wanted to get feedback before i hack it down and see that it wont work because someone else tried that already.
02:17:48 <`nand`> that looks like it's less efficient than my approach, at the very least because you pass around extra parameters
02:17:55 <startling> M30W: sure.
02:18:06 <M30W> startling: Good; wasn't sure for types ^_^
02:18:41 <bourbaki> `nand`: But that models the types properly right? In that other case i would have to have something that models a bijection of sum and product types etc.
02:18:42 <`nand`> but apart from that, I don't see any immediate reasons why it shouldn't work
02:18:59 <`nand`> there's no much of a difference between Sum Double and (Double, Add)
02:19:00 <`nand`> not*
02:19:07 <bourbaki> In my approach Add and Mul instances are using the same type.
02:19:56 <bourbaki> Ill just have to see then how it will work out for fields or if i have to use fundeps there also for deriving the types.
02:20:10 <M30W> serverFiles :: IORef (H.HashSet [File]) -- Would that definition be as expected ? IORef, HashSet of File's
02:20:28 <`nand`> I don't think fundeps would be appropriate here
02:20:51 <bourbaki> `nand`: I had to use them in the other approach for the vector space.
02:21:21 <bourbaki> Because i wanted to account for vectors that are not trivially of the same type as the scalar.
02:22:12 <`nand`> that's a different scenario
02:22:20 <`nand`> every vector space has only one scalar type
02:22:47 <bourbaki> The problem in my setup was that he could not derive the scalar type from the vector.
02:22:50 <bourbaki> Sec
02:22:54 <covi> http://hpaste.org/80358 Why is this string causing problem?
02:23:08 <hpaste> bourbaki pasted “S2” at http://hpaste.org/80359
02:23:20 <`nand`> but here it's plausible for a type to have multiple monoids (eg. additive, multiplicative)
02:23:24 <bourbaki> Line 85
02:23:57 <`nand`> I wouldn't even use MPTCs or fundeps for that
02:24:00 <`nand`> I would use an associated type
02:24:16 <bourbaki> `nand`: What is that? :)
02:24:37 <`nand`> class VectorSpace v where type Scalar v; mult :: Scalar v -> v -> v
02:24:48 <M30W> @hoogle ReaderT
02:24:48 <lambdabot> Control.Monad.Reader ReaderT :: (r -> m a) -> ReaderT r a
02:24:48 <lambdabot> Control.Monad.Trans.Reader ReaderT :: (r -> m a) -> ReaderT r m a
02:24:48 <lambdabot> Control.Monad.Trans.Reader newtype ReaderT r m a
02:25:03 <`nand`> eg. see http://hackage.haskell.org/packages/archive/vector-space/0.8.6/doc/html/Data-VectorSpace.html#t:VectorSpace
02:25:14 <bourbaki> `nand`: Then i have a tight coupling again though.
02:25:33 <bourbaki> Cause that vector can only be multiplied by one scalar type.
02:25:37 <`nand`> yes
02:25:43 <`nand`> that's the same as the line 85 in what you showed me
02:26:00 <bourbaki> Yes but that is what i try to get away from, i see the point though.
02:26:21 <hamid> salamkh
02:27:05 <M30W> @hackage Control.Monad
02:27:05 <lambdabot> http://hackage.haskell.org/package/Control.Monad
02:29:15 <`nand`> bourbaki: I'm not exactly sure what you're trying to accomplish
02:30:15 <bourbaki> `nand`: I try to get as close the the real structure as possible, cause then i can have mappings of the structures etc.
02:30:48 <bourbaki> And that is the core of topological categories etc.
02:31:20 <bourbaki> Also i feel that having to extend inner types makes it really hard to extend a library, because it fails to go with the open closed principle.
02:31:29 <bourbaki> Open for extension and closed for modification.
02:32:02 <bourbaki> So eg if i use Sum types i would have to modify that sum type in order to make my additions work.
02:32:24 <bourbaki> This is why data Add and Mul are not in one data like Structures.
02:33:06 <bourbaki> Also i was very concerned about to have this (Sum t) and (Prod t) types because it is really hard to model bijections.
02:33:52 <bourbaki> Also i think that having the Add and Mul as types might make it easier to model something like distributivity since it is a relative to the two structures.
02:35:30 <`nand`> bijections?
02:35:38 <`nand`> can you be more specific?
02:35:43 <bourbaki> I know that it is not getting me one step ahead into the direction of implementing what i want to do but i think that it might be worth the trouble :)
02:36:14 <bourbaki> `nand`: I mean that for a field for example you have to have two operators * and + that are defined using the same type.
02:37:01 <bourbaki> And if you wrap these types into Sum and Prod you would have to show that all elements in Sum and Prod can be mapped to one another with a bijection, to show that it really is the same type.
02:37:35 <bourbaki> I know that this really is the case but if you do not it just does not really model what you need.
02:38:02 <bourbaki> In trivial setups this is not useful i guess but if you want to extend it as far as possible you need to make all this sure.
02:38:27 <bourbaki> Just like with the vectors and the scalars, if i do not do this i can not map one vector field into another etc.
02:39:16 <bourbaki> For example i could have a vector space over R and want to map that into C but still using the same vectors.
02:39:57 <`nand`> I don't know what ‘mapping a vector field into another’ means, but what's wrong with a function :: R -> C ?
02:40:08 <bourbaki> Like in a functor.
02:40:46 <bourbaki> I do not have a good example at hand atm.
02:41:04 <bourbaki> But let us say you have a look at linear functions and search for a way to model them.
02:41:36 <bourbaki> Then you could use matrices to do that, or maybe some other model.
02:41:53 <bourbaki> But you always map elements from one structure into some other structure.
02:41:58 <Moggle> I think I am going to try and make an IRC client in Haskell!
02:42:03 <Moggle> I can't really think of anything more useful.
02:42:17 <Moggle> Anyone have any recommendations for GUI lib-I'll just check Hackage.
02:42:25 <ethercrow> Moggle: patch yi
02:42:31 <bourbaki> And if they are bijections you know that you can use the operators of that other structre to do what you needed to do, that is the core of diagram chasing.
02:42:57 <bourbaki> Actually afaik this is what has been done in topology first and where category theory originates from.
02:43:19 <`nand`> Moggle: I've heard good things about vty-ui
02:43:27 <Moggle> thanks ethercrow and nand!
02:43:33 <`nand`> but I haven't tried it, the examples scare me off
02:44:21 <bourbaki> nand sorry i am bad at explaining this :)
02:45:07 <`nand`> my lack of familiarity with the subject surely doesn't help
02:45:47 <bourbaki> Lets say you can not solve some problem using type a but you can do that with type b.
02:46:12 <bourbaki> Then if there is a bijection from type a to b you know that if you solve the problem with b you have the solution for a as well.
02:46:58 <Jaxan> you need more than just a bijection, right?
02:47:24 <bourbaki> Or let us say you have coordinates (x, y, z) then this can be relative to a matrix or it could be coefficients of polynomials to model a vector space.
02:47:31 <bourbaki> Jaxan: Not that i know of.
02:47:48 <bourbaki> If you have that you get a diagram that commutes.
02:48:12 <Jaxan> bourbaki: for example there is a bijection between C and R, but this doesn't say anything about solving polynomials in R (although you can solve them in C)
02:48:27 <bourbaki> Yes because there is not :)
02:48:28 <`nand`> I guess this depends on what you mean by ‘bijection’
02:48:39 <`nand`> a set bijection? no; what you're looking for is a homomorphism or w/e
02:49:07 <Jaxan> I think bijection always mean set isomorphism, right?
02:49:14 <`nand`> I think so too
02:49:19 <`nand`> maybe there is some overloaded terminology here
02:49:38 <bourbaki> I really mean it in sets , http://en.wikipedia.org/wiki/Bijection
02:50:05 <bourbaki> Bijective relations are always also homomorphisms afaik.
02:50:47 <bourbaki> Ah no sorry, homomorphisms are what i was looking for in mapping the structures
02:53:32 <hpaste> M30W annotated “Need to manage this [File] list and don't know how to start” with “Need to manage this [File] list and don't know how to start (annotation) (annotation) (annotation)” at http://hpaste.org/80347#a80360
02:53:40 <M30W> :|
02:55:06 <M30W> Anyone here mind helping me get these types correct? (addCommand)
02:59:39 <M30W> @ping
02:59:39 <lambdabot> pong
03:11:38 <|||tux||> What types?
03:23:08 <HugoDaniel> hi
03:23:31 <HugoDaniel> maybe ive found out how to store bytestrings in a unboxed vector
03:24:26 <HugoDaniel> a bytestring is just 2 ints and a foreignptr, i can keep them as (Int, Int, Int) by doing a cast to IntPtr on the ForeignPtr
03:28:58 <startling> is there a way to turn a "X -> Y" into a "(forall v. SomeClass v => v) -> Y", given that X is an instance of SomeClass?
03:30:05 <Heffalump> you might need a wrapper type
03:32:27 <startling> with ExistentialQuantification?
03:33:34 <Heffalump> or RankNTypes or something
03:37:57 <Jafet> HugoDaniel: enjoy your segfault
03:54:58 <HugoDaniel> Jafet: why ? :D
03:55:27 <HugoDaniel> maybe i should convert them to safeptr
03:55:34 <HugoDaniel> to make sure gc doesn't mess this up
03:58:31 <HugoDaniel> i love all functions that start with "unsafe"
03:58:50 <zhulikas> :))
03:59:03 <zhulikas> does it make you feel dangerous?
03:59:06 <Taneb> "unsafe that safe! We need it open!"
03:59:43 <HugoDaniel> :D
04:03:46 <mvj4_> 17:58 < cmccann> mvj4_, apply a wrapper function to what? the final result of the computation?
04:03:55 <mvj4_> Given a Cont block like (a >>= b >>= c), all of the a,b,c operations share some initial processing (determining which environment they are evaluated in). Could this be encoded in a concise way?
04:04:53 <mvj4_> @src mapCont
04:04:53 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:05:05 <mvj4_> :t mapCont
04:05:06 <lambdabot> (r -> r) -> Cont r a -> Cont r a
04:05:24 <mvj4_> mapCont only applies a function on the final result.
04:06:57 <Jafet> HugoDaniel: data instance Vector ByteString = Sneaky (Storable.Vector (StablePtr Word8)) (Vector (Int, Int))
04:08:18 <Jafet> Sneaky (StablePtr ByteString)
04:09:15 <mvj4_> hmm.. perhaps I could resolve my issue by simply splitting up a1 and a2 (one of which a calls) into separate modules, then allowing the user to import one which defines a.
04:09:52 <mvj4_> The use case is an eDSL where two different evaluators are defined.
04:10:00 * hackagebot amrun 0.0.0.3 - Interpreter for AM  http://hackage.haskell.org/package/amrun-0.0.0.3 (DanielSeidel)
04:13:17 <Jafet> Er, Sneaky (Storable.Vector ByteString)
04:13:45 <Jafet> Sneaky (Storable.Vector (StablePtr ByteString))
04:13:49 <Jafet> I should probably stop now
04:27:34 <neutrino> hello
04:27:48 <neutrino> are there S and K combinators in haskell?
04:28:30 <Taneb> pure and (<*>) for the reader applicative are s and k
04:28:34 <augur> neutrino: build it? no
04:28:40 <Taneb> > pure <*> pure $ 1
04:28:41 <lambdabot>   Ambiguous type variable `f0' in the constraint:
04:28:41 <lambdabot>    (Control.Applicative.App...
04:28:46 <Taneb> > pure <*> pure $ 1 :: Int
04:28:46 <augur> lol taneb
04:28:48 <lambdabot>   Ambiguous type variable `f0' in the constraint:
04:28:48 <lambdabot>    (Control.Applicative.App...
04:28:55 <Taneb> > (pure <*> pure) $ 1 :: Int
04:28:56 <lambdabot>   Ambiguous type variable `f0' in the constraint:
04:28:56 <lambdabot>    (Control.Applicative.App...
04:28:58 <augur> pure is not k, silly!
04:29:11 <Taneb> > pure 1 2
04:29:12 <lambdabot>   1
04:29:19 <danr> > pure `asTypeOf` const
04:29:20 <augur> pure and (<*>) can be S and K depending on the type
04:29:21 <lambdabot>   No instance for (GHC.Show.Show (a0 -> b0 -> a0))
04:29:21 <lambdabot>    arising from a use of `...
04:29:28 <augur> :t pure
04:29:30 <lambdabot> Applicative f => a -> f a
04:29:38 <danr> > :t pure `asTypeOf` const
04:29:40 <lambdabot>   <hint>:1:1: parse error on input `:'
04:29:45 <danr> :t pure `asTypeOf` const
04:29:46 <Taneb> I did specify the applicative instance I was using when describing it to neutrino
04:29:46 <lambdabot> a -> b -> a
04:29:51 <augur> obviously this is not K unless f is (b ->)
04:29:57 <Taneb> > const <*> const $ 1
04:29:58 <lambdabot>   1
04:30:02 <Axman6> isn't ap S?
04:30:05 <augur> oh sorry, didnt see that Taneb
04:30:10 <Axman6> or is <*> = ap
04:30:13 <augur> ap is S indeed
04:30:13 <Taneb> Yes
04:30:17 <danr> Axman6: both
04:30:27 <augur> but, neutrino, you can define both S and K
04:30:34 <Taneb> > pure (pure <*> pure) (+ 1) 0
04:30:35 <lambdabot>   Ambiguous type variable `f0' in the constraint:
04:30:35 <lambdabot>    (Control.Applicative.App...
04:30:40 <augur> K is const in Prelude
04:30:49 <Taneb> > const (const <*> const) (+ 1) 0
04:30:51 <lambdabot>   0
04:30:59 <augur> :t const
04:31:00 <Taneb> > join fmap (+ 1) 0
04:31:00 <lambdabot> a -> b -> a
04:31:02 <lambdabot>   2
04:31:09 <augur> const x y = x
04:31:24 <Taneb> > (fmap <*> join fmap) (+ 1) 0
04:31:25 <augur> i wonder if theres a prelude S
04:31:25 <lambdabot>   3
04:31:26 <augur> but either way
04:31:30 <Taneb> There isn't
04:31:36 <Taneb> > (fmap <*> fmap <*> join fmap) (+ 1) 0
04:31:37 <EvilMachine> Taneb: You can use ghci too. :)
04:31:38 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = a0 -> t0Occurs check...
04:31:43 <Taneb> EvilMachine, no I can't
04:31:47 <Taneb> It's physically impossible
04:31:50 <augur> s :: (e -> a -> b) -> (e -> a) -> (e -> b)
04:31:50 <Taneb> Anyway
04:31:53 <Taneb> I'll stop now
04:32:07 <augur> s f x e = f e (x e)
04:32:10 <EvilMachine> Taneb: Oh? I’m sorry. Didn’t want to complain. How come?
04:32:30 <augur> !hoogle (e -> a -> b) -> (e -> a) -> (e -> b)
04:32:36 <augur> @hoogle (e -> a -> b) -> (e -> a) -> (e -> b)
04:32:36 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
04:32:36 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
04:32:36 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
04:33:46 <augur> neutrino: so no, there's nothing built in. one of them (K) has a standard library definition tho (const) while the other (S) doesnt
04:34:15 <Taneb> EvilMachine, nah, I'm just being silly
04:34:19 <augur> but the applicative type class for the reader functor *does* have K = pur and S = ap
04:34:21 <Taneb> Don't worry about it
04:34:31 <osa1> after learning working with ST monad (I still don't understand some aspects though) State monad is like somewhat unnecessary when you don't need older version of some state after updating it. am I missing something ?
04:34:42 <augur> actually i guess its S = <*> indeed
04:34:45 <augur> because ap is for monads
04:34:54 <augur> in this case i think they might be identical
04:35:08 <augur> K = pure**   i cant type :(
04:35:14 <Taneb> osa1, State is more nicey-functional-nicey.
04:35:15 <augur> neutrino: does that help at all?
04:35:42 <osa1> Taneb: of course, but who cares if that functionality is not helpful ?
04:35:46 <Taneb> osa1, and means you can get the state out at the end of computation and ignore the result
04:36:06 <osa1> Taneb: you can do that with ST too
04:36:19 <osa1> Taneb: with the help of funtcions like `freeze`
04:36:23 <osa1> functions*
04:36:40 <Taneb> But I'm afraid I haven't used ST enough to find where it stops being nice
04:37:06 <M30W> |||tux||: I'll paste the errors sorry.
04:37:32 <M30W> hpaste | M30W annotated “Need to manage this [File] list and don't know how to start” with “Need to manage this [File] list and don't know how to start (annotation) (annotation) (annotation)” at http://hpaste.org/80347#a80360
04:38:34 <M30W>  http://sprunge.us/dOdL
04:40:01 * hackagebot sym-plot 0.1.0 - Plot permutations; an addition to the sym package  http://hackage.haskell.org/package/sym-plot-0.1.0 (AndersClaesson)
04:40:01 <M30W> What's the way to get the raw link for the hpaste? (No browser atm; in fact no filesystem lol; crypt + sleep = readonly what was already read and cached)
04:43:48 <donri> M30W: http://hpaste.org/raw/id
04:44:39 <M30W> donri: Thanks (rebooted and can now access firefox lol) Thanks anywa ^_^
04:47:36 <|||tux||> addCommand needs the env from the Reader monad too (because setFiles needs env)
04:47:58 <M30W> Ah
04:49:13 <M30W> |||tux||: How would I add that exactly?
04:52:55 <neutrino> augur / Taneb: thanks, reading
04:55:33 <|||tux||> I think "addCommand :: Handle -> [String] -> IO ()" shoud, be "addCommand :: Handle -> [String] -> ServerM()"
04:55:41 <neutrino> augur: yes, thanks a lot, it helped
04:55:59 <neutrino> osa1: the state monad is for making state machines. in particular, finite state machines.
04:56:13 <neutrino> it has nothing to do with "state" as you know if from e.g. OOP.
04:56:30 <neutrino> that is better described as "mutability" and/or "persistence"
04:56:49 <neutrino> you can use STM, IORef, or MVar for mutability
04:56:59 <neutrino> but you almost never need it
04:57:02 <augur> neutrino: no no
04:57:08 <augur> State is not for making state machines
04:57:21 <augur> its for making "global mutable variables", so to speak
04:57:24 <neutrino> how is it not? you pass a state parameter and get out a computation
04:58:04 <augur> State s a is an a-ish computation but where you have a global mutable variable of type s visible to the a-ish computation
04:58:07 <neutrino> and you can uniquely identify your state by the value of your state parameter
04:58:21 <neutrino> oh, i must be thinking of something else then?
04:58:23 <neutrino> sorry
04:58:37 <augur> you can probably use it to make an FSM no doubt
04:58:42 <augur> but thats not what its "for"
04:59:05 <neutrino> ok, sorry about the confusion then
05:00:22 <neutrino> augur: btw, i'm reading the Applicative paper, and they say that S and K are encoded in Applicative..
05:00:53 <augur> yes, like Taneb said
05:01:00 <neutrino> yeah
05:01:08 <augur> with applicative for the reader functor, K = pure, S = (<*>)
05:01:20 <augur> but its a specific applicative for a specific functor
05:01:45 <M30W> |||tux||: should `{ serverFiles :: IORef (H.HashSet [File])` be `{ serverFiles :: IORef (H.HashSet File)` ?
05:02:43 <|||tux||> M30W: If you want a set of files, yes
05:03:02 <M30W> Okay so yes :)
05:03:28 <|||tux||> From what package is the module  Network.Dldr.Core.Error ? I wanted to try it out myself, but can't find this module
05:03:39 <M30W> So many errors :(
05:03:44 <M30W> |||tux||: localhost ;)
05:03:47 <M30W> One sec.
05:04:45 <M30W> |||tux||: http://ix.io/3Sn+3So
05:05:19 <mreh> my FFI callbacks appear to be causing "schedule: re-entered unsafely.   Perhaps a 'foreign import unsafe' should be 'safe'?"
05:05:29 <M30W> |||tux||: That has Error.hs and File.hs ^^
05:05:43 <mreh> Thre are no unsafe calls in the library I am using
05:05:58 <mreh> apart from one function which I'm not using
05:06:53 <M30W> |||tux||: This is my first haskell project and I'm comming from C/php/javascript/shell to Haskell. :)
05:07:23 <M30W> ^More languages; but they main (shell strongest nowdays)
05:08:42 <ijp> poor guy
05:08:56 <M30W> ijp: What?
05:09:14 <ijp> I have a very large anti-shell bias
05:09:42 <mreh> oh, maybe I should have compiled it with -threaded
05:09:57 <mreh> molluscs have rights too you know
05:10:19 * M30W hates PHP btw. And shell is great ( if you're not a noob at writing them ) -- Admitingly my zsh irc mpd bot isn't that readable to the average person but efficiant.
05:10:44 <M30W> |||tux||: You have any idea on what to change now?
05:11:04 <M30W> Too many errors hehe.
05:15:21 <M30W> |||tux||: lines 23,26 -> [File] -> File **
05:15:50 <M30W> s/\[File\]/File/ ^_^
05:16:15 <Moggle> After much reflection
05:16:17 <Moggle> and thought
05:16:21 <Moggle> and several bowls of ice cream
05:16:26 <srhb> Moggle: Mhmm.
05:16:28 <Moggle> I have determined monads are quite literally black magic
05:16:39 <srhb> Moggle: Bingo! No, sorry, not really. :P
05:16:49 <Moggle> > [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n,ch)
05:16:51 <lambdabot>   [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
05:16:54 <Moggle> My mind kind of half melted
05:17:03 <Moggle> I _understand_ it... sort of. Kind of.
05:17:05 <srhb> Moggle: Rewrite it in terms of the definition of >>= :)
05:17:05 <Moggle> It just scares me.
05:17:19 <srhb> Moggle: Referential transparency means you can juts copy paste it in.
05:17:26 <Moggle> srhb: which is <3
05:17:28 <M30W> I (new to haskell) can read that with no issue. :D
05:17:39 <Moggle> M30W: I too am new to Haskell :D
05:17:50 <M30W> Moggle: Great language ^_^
05:17:53 <Moggle> It is! :D
05:17:59 <Moggle> It stretches my brain in many ways.
05:18:05 <Moggle> I wish I hadn't wasted so long doing project euler problems with it.
05:18:12 * |||tux|| is new to haskell to :p
05:18:17 <srhb> Yeah, it doesn't really help a lot.
05:18:23 <Moggle> It helped a bit.
05:18:32 <Moggle> Could have been much better off reading up on monads here
05:18:33 <srhb> With respect to Monads, I must say I really don't use List very often.
05:18:43 <M30W> Moggle: http://ix.io/3Sp+3So+3Sn/ -- My first haskell program; Loads of errors (Types mostly)
05:18:50 <|||tux||> M30W: addCommand :: Handle -> [String] -> ServerM ()
05:18:54 <srhb> My favourite in simplicity must be the Maybe monad.
05:19:08 <M30W> |||tux||: Got that ^
05:19:12 <Moggle> I'm a fan of that one too, srhb.
05:19:16 <Moggle> Lists, though... lists appeal.
05:19:17 <|||tux||> M30W: x (read . head $ xs :: Integer) >> lift hPrint h "ok" -- But i don't know how to get the "catch" in there
05:19:17 <Taneb> I like the Reader monad
05:19:29 <Moggle> Haven't even seen the Reader monad and I am waiting with bated breath
05:19:36 <Moggle> now, to figure out this stupid black magic of lists and oh god
05:19:43 <M30W> |||tux||: the invalidArgument catch?
05:19:47 <|||tux||> yes
05:19:50 <srhb> Moggle: concatMap all the way :P
05:20:02 <M30W> Ah good point
05:20:25 <Moggle> srhb: y...yeah. I understand, like I said, but still...
05:20:35 <srhb> :)
05:20:42 <Moggle> srhb: it's more the do notation version of the code that makes my brain explode
05:20:49 <srhb> Oh, really. How come?
05:21:01 <hpaste> Moggle pasted “D:” at http://hpaste.org/80364
05:21:19 <Moggle> Coming from imperative languages in general
05:21:23 <Moggle> this just... sort of... yeah.
05:21:31 <Moggle> Code is no longer sequential and I'm having a hard time processing it.
05:21:44 <srhb> But you understand the rewrite to using >>= ?
05:21:49 <Moggle> yes :D
05:21:54 <srhb> Ok. :)
05:22:08 <Moggle> at least
05:22:10 <Moggle> I hope I do >_>
05:22:24 <c_wraith> the secret to do notation is that it isn't sequential.
05:22:26 <srhb> foo <- bar becomes bar >>= \foo -> ...
05:22:32 <srhb> That's all about it, isn't it.
05:22:40 <Moggle> do [1,2] >>= (\n -> "ab" >>= \ch -> return (n, ch))
05:22:42 <M30W> > [0..] >>= \a -> ['a'..'z'] >>= \b -> return (a,b)
05:22:44 <lambdabot>   [(0,'a'),(0,'b'),(0,'c'),(0,'d'),(0,'e'),(0,'f'),(0,'g'),(0,'h'),(0,'i'),(0...
05:22:44 <Moggle> or something along those lines
05:22:49 <Moggle> yeah
05:22:49 <M30W> Hmmm
05:22:51 <Moggle> okay I got that then
05:22:53 <Moggle> :D
05:23:01 <Moggle> I blame IO.
05:23:06 <Moggle> It made me have certain expectations
05:23:14 <Moggle> but I see now I barely understood what I was doing with the IO Monad ^_^
05:23:35 <M30W>  Meh, I go back to my problem..
05:24:16 <M30W> |||tux||: Did yours compile or still got errors?
05:25:49 <M30W> |||tux||: Ah, I need to end with IO not ServerM (My case on the commands; it's expecting IO)
05:26:45 <|||tux||> M30W: Somewhere in your code you need to set the ServerEnvironment, don't you?
05:28:06 <M30W> |||tux||: type ServerM = ReaderT ServerEnvironment IO
05:28:14 <M30W> Ah
05:28:18 <M30W> Hmmm
05:28:48 <M30W> |||tux||: No clue how.
05:28:53 <|||tux||> something like newIORef
05:29:31 <M30W> Ah
05:30:20 <M30W> |||tux||: I still don't know how heh.
05:31:45 <srhb> What are those IOrefs needed for?
05:32:06 <M30W> srhb: N clients -> N threads
05:32:23 <srhb> And each thread needs to read from them?
05:32:35 <M30W> Shared variable
05:32:39 <srhb> Right.
05:32:53 <M30W> No; Left (
05:33:00 <M30W> No; Left "Compile error"
05:33:46 <srhb> So somewhere you need a runReader which sets up the serverenvironment
05:34:08 <srhb> It sounds like the IORef ought be an MVar though, not sure.
05:34:12 <M30W> monochrom: was helping me here but then he went afk never to return :(
05:34:54 <M30W> srhb: We had a bit of a discussion about that; IORef won. ( I think; unless it was TVar ) D: I forgot...
05:35:06 <M30W> I think it was IORef + HashSet
05:35:20 <|||tux||> You need runReaderT actually
05:35:23 <M30W> I hope it was * cause that's what I have. :P
05:35:48 <M30W> |||tux||: hmm
05:35:59 <srhb> M30W: easy to change afterwards due to the types, no worries.
05:36:02 <|||tux||> M30W: So that IORef should be shared between all threads?
05:36:13 <srhb> M30W: Anyway, you could start by setting up that new empty IORef somewhere, like in your main
05:36:23 <M30W> |||tux||: Yes
05:36:30 <srhb> M30W: (There can be only one for each instance of the program, so main makes sense)
05:36:55 <M30W> srhb: Indeed.
05:37:39 <srhb> Your runConn confuses me a bit..
05:38:02 <M30W> schovi: Where?
05:38:04 <M30W> srhb: *
05:38:06 <M30W> Sorry schovi
05:38:58 <srhb> Meh nevermind, think I got it.
05:39:11 <srhb> So parseIn is the actual command loop
05:39:13 <M30W> srhb: It just loops as it gets clients and forks out each client and continues. Each client is in it's own loop forever.
05:39:17 <M30W> srhb: Yea
05:39:25 <srhb> It would appear that it needs access to the server environment
05:39:39 <M30W> E.invalidArgument causes ACK 2 Invalid argument
05:39:41 <srhb> so instead of calling parseIn h in runConn, you need to start the reader
05:39:51 <M30W> "ACK 2 Invalid argument" to be sent to the client.
05:41:01 <M30W> srhb: Reader start in main -> runConn. D: Which?
05:41:12 <srhb> M30W: I would start the reader in runConn
05:41:34 <srhb> Where the control loop is forked off
05:41:49 <M30W> srhb: Okay; and how to get the instance of ServerEnvironment ?
05:41:55 <M30W> In main as you suggested ?
05:42:15 <srhb> M30W: Yes.
05:42:32 <M30W> srhb: Okay.. serverE <- newIORef -- ?
05:42:46 <srhb> let serverE = ...
05:43:11 <M30W> let serverEnv = newIORef
05:43:25 <M30W> wait
05:43:28 <M30W> hmmm
05:43:44 <|||tux||> shrb : isn't newIORef of type a -> IO (IORef a)?
05:43:52 <srhb> Yes, but serverE is a record type
05:44:15 <srhb> sFiles <- newIORef -- sure
05:44:20 <srhb> let serverE = ...
05:44:47 <|||tux||> lsFiles <- newIORef $ H.fromList [] ?
05:45:02 <|||tux||> sFiles*
05:45:11 <srhb> Sounds right.
05:45:11 <M30W> let serverEnv = ServerEnvironment { serverFiles = H.empty, serverState = B.pack "....why is this a bytestring, I'm gonna make that a state lol..." }
05:45:51 <|||tux||> B.pack does for some reason not work, you need the pack from Data.ByteString.Char8
05:46:10 <|||tux||> (B.pack wants a [Char8] to pack)
05:46:36 <srhb> M30W: serverFiles = ... has to be the IORef as |||tux|| demonstrated
05:46:57 <M30W> Ah
05:47:19 <srhb> I really think it ought to be an MVar... :P But nevermind
05:48:12 <M30W> Initilizating < Correct spelling?
05:48:19 <srhb> initialization
05:48:24 <M30W> Thanks
05:49:07 * M30W will be right back - afk
05:51:10 <Moggle> Question:
05:51:12 <Moggle> > return "WoM" >>= (\x -> [x,x,x])
05:51:13 <lambdabot>   ["WoM","WoM","WoM"]
05:51:36 <Moggle> Why that, and not ['W', 'W', 'W', 'o', 'o', 'o', 'M', 'M', 'M']
05:51:38 <Moggle> ?
05:51:39 <srhb> > return "WoM" :: ?
05:51:41 <lambdabot>   <hint>:1:17: parse error on input `?'
05:51:50 <srhb> What do you think the type of that is
05:51:55 <Moggle> Depends.
05:51:58 <M30W> Moggle: x = "WoM"
05:52:00 <Moggle> Either [[Char]] or [Char]
05:52:01 <srhb> In your expression
05:52:07 <srhb> First one
05:52:08 <Moggle> I'm not sure what it's parsed as...
05:52:12 <Moggle> oh.
05:52:18 <srhb> [Char] is already what "WoM" is
05:52:21 <Moggle> Well, if it's [[Char]], then I suppose it makes sense.
05:52:34 <M30W> > return ["W","o","M" >>= (\x -> [x,x,x]) -- Doubt this will work
05:52:35 <lambdabot>   <hint>:1:64: parse error (possibly incorrect indentation)
05:52:42 <srhb> Of course it will
05:52:43 <M30W> > return ["W","o","M"] >>= (\x -> [x,x,x]) -- Doubt this will work
05:52:45 <lambdabot>   [["W","o","M"],["W","o","M"],["W","o","M"]]
05:52:53 <M30W> Ha, not as he wanted tho :P
05:52:58 <Moggle> oh, DERRR
05:53:00 <Moggle> the return
05:53:03 <srhb> Yeah.
05:53:04 <Moggle> I am so stupid
05:53:09 <srhb> It just smacks it in another list.
05:53:10 <Moggle> > "WoM" >>= (\x -> [x,x,x])
05:53:11 <lambdabot>   "WWWoooMMM"
05:53:13 <Moggle> Bam.
05:53:14 <srhb> :)
05:53:15 <Moggle> Just as expected.
05:53:17 <M30W> Ha
05:53:20 <Moggle> Okay, today I learned I'm bad at life.
05:53:22 <Moggle> Thanks!
05:53:28 <srhb> Moggle: Yes, and you should feel bad. *nodnod*
05:53:35 <Moggle> shrb: I do feel bad :(
05:53:37 <srhb> :P
05:53:43 <Moggle> :P
05:53:46 <M30W> Moggle: Don't ^_^
05:54:33 <srhb> > concat . map (\x -> [x,x,x]) $ "WoM"
05:54:35 <lambdabot>   "WWWoooMMM"
05:54:46 <srhb> It's so much easier to get what is going on if you do that rewrite
05:54:50 <srhb> Imho. :)
05:55:15 <Jafet> @pl concatMap
05:55:16 <lambdabot> (=<<)
05:55:17 <srhb> > concat . map (\x -> [x,x,x]) $ return "WoM"
05:55:20 <lambdabot>   ["WoM","WoM","WoM"]
05:55:36 <|||tux||> > "WoM" >>= replicate 3
05:55:37 <lambdabot>   "WWWoooMMM"
05:56:07 <Taneb> Wow, I just made GHC panic
05:56:12 <srhb> Oops.
05:56:12 <Taneb> And I wasn't even trying to
05:56:16 <srhb> What did you do?
05:56:43 <Taneb> I'm... not sure
05:56:52 <srhb> :P
05:56:54 <Taneb> Reloading it worked
05:57:33 <Taneb> Of course, my algorithm is still flawed
05:58:58 <M30W> Taneb: infinite loop?
05:59:11 <Taneb> Type messup
05:59:43 <M30W> What would be a good name for being unable to bound to a port?
05:59:59 <M30W> FailedToBind ?
06:00:09 <Taneb> UnableToBind?
06:00:33 <M30W> Taneb: I thought of that but eh. I don't know :|
06:00:55 <srhb> Change it later if you think it's bad :P
06:01:07 * M30W will just not have a state for now ^_^
06:01:21 <M30W> Not that I have any way to deal with it hehe.
06:01:39 <srhb> What do you mean about state?
06:03:38 <M30W> Server state; I.e bound to port, unable to bind, maximum clients connected (if I add a limit), locked (too many auth fails too quickly), etc
06:04:16 <srhb> Oh.
06:04:20 <M30W> Gonna get messy if I do that tho :P
06:04:31 <srhb> Not that messy...
06:07:37 <Jafet> ShitHappened String
06:09:40 <M30W> Jafet: is that your Type ? XD
06:10:02 <M30W> srhb: Could get easily enough
06:10:22 <srhb> M30W: Well.. I really don't think so. But you can always extend it later. :0
06:10:35 <M30W> http://ix.io/3Sq
06:10:37 <M30W> :|
06:10:44 <M30W> srhb: Inded :D
06:10:53 <M30W> When it compiles maybe ;)
06:11:35 <srhb> Think you just need to sprinkle some liftIO, but not sure exactly how far you are
06:11:50 <srhb> Or you could change the types
06:11:58 <|||tux||>  srhb: btw, what is the difference between liftIO and lift?
06:12:12 <srhb> liftIO always lifts to IO no matter how stacked your transformer is
06:12:30 <|||tux||> ah ok, so in this case lift is the same as liftIO?
06:12:33 <srhb> yes
06:12:38 <|||tux||> thx
06:12:39 <M30W> srhb: |||tux|| this far.. http://ix.io/3Sr+3Ss+3St+3Su/
06:12:56 <srhb> |||tux||: But you should always use liftIO anyway, since it makes it clearer and more extensible
06:13:07 <|||tux||>  parseIn :: Handle -> IO () ==>  parseIn :: Handle -> ServerM ()
06:14:55 <M30W> |||tux||: Only one function acturally uses that ServerM atm ;) What to change so the rest don't kill the whole thing?
06:15:05 <M30W> They need to out ServerM now
06:15:45 <|||tux||> you need to use liftIO for things that only do IO
06:16:00 <M30W> Okay
06:16:03 <|||tux||> e.g.  "ack"  -> ackCommand  h xs ==>  "ack"  -> liftIO $ ackCommand  h xs
06:16:17 <srhb> you have to consider which functions need access to the server environment and which do not
06:16:32 <srhb> All those that do now need to end with ServerM
06:17:09 <M30W> Ah
06:18:03 <srhb> Personally I don't start writing type signatures that early into development, preferring to let the compiler deduce them for me while I muck around.
06:18:07 <srhb> But that's a matter of taste.
06:18:14 <srhb> (And you can't always get away with it)
06:18:57 <M30W> |||tux||: You got it to compile?
06:19:14 <srhb> Are you writing the same program?
06:19:28 <M30W> srhb: He took a copy and is trying to fix all the errors.
06:19:33 <srhb> Oh. :)
06:19:36 <M30W> :)
06:19:44 <srhb> Type directed error fixing is such a blessing.
06:19:47 * M30W is very grateful for |||tux|| :-)
06:19:52 <srhb> Often I feel like the compiler is doing more than half the work for me.
06:20:19 <M30W> srhb: :D 'possible fix' -> Thank you. :)
06:20:28 <srhb> Yes. :)
06:20:49 <srhb> But more the fact that I don't end up on some weird sidetrack because I was doing something that doesn't make sense. I get stopped early on.
06:20:51 <M30W> Not always tho lol.
06:21:05 <srhb> Mind I type check every two minutes or something :P
06:21:06 <M30W> Point of type-checking :D
06:22:21 <|||tux||> The function `lift'ghc: panic! (the 'impossible' happened O.O
06:22:57 <M30W> What? O.o
06:23:42 <byorgey> looks like |||tux|| crashed
06:23:55 * M30W is limited to only ssh hehe. "zsh: stale NFS file handle:"
06:24:14 <M30W> Crypto dies on this computer; so boot'
06:24:28 <M30W> n it's safe to remove usb cause it'll ignore it sooner or later haha.
06:24:34 <|||tux||> That file didn't even use any extensions
06:24:57 <M30W> |||tux||: What?
06:25:13 <M30W>  "zsh: stale NFS file handle:" ->  "zsh: stale NFS file handle: htop" *
06:25:18 <|||tux||> M30W: Look at your errors, the last one is actually a ghc crash
06:25:35 <M30W> HEhe
06:25:36 <M30W>     The function `lift'ghc: panic! (the 'impossible' happened)
06:25:59 <M30W> So... We killed ghc? D: Haha
06:26:01 <|||tux||> Laziness at work. It printed the error message till that point
06:26:50 <M30W> Heh.. Pattern emerged.... My commands every second uses liftIO $ xD
06:27:26 <merijn> M30W: Why not have a single big IO block and liftIO that?
06:27:42 <merijn> (not sure if that's relevant)
06:27:49 <M30W> Context is why ^_^
06:28:10 <M30W> "ack"  -> liftIO $ ackCommand h xs
06:28:10 <M30W> "add"  -> addCommand  h xs
06:28:18 <M30W> addCommand -> ServerM ()
06:28:32 <merijn> Why not rewrite ackCommand to be ServerM () too?
06:28:42 <M30W> Cause it's IO
06:28:45 <M30W> :)
06:28:46 <merijn> So?
06:29:02 <M30W> It should stay IO as it IS IO.
06:29:06 <merijn> You can just lift inside the function, no?
06:29:28 <M30W> Yes but why? It defeats a level to the type checking.
06:29:58 <M30W> |||tux||: Any idea on a patch?
06:30:38 <merijn> How does that defeat a level of type checking?
06:30:40 <|||tux||> How do you use handle inside a monad transformer?
06:30:45 * byorgey agrees with M30W 
06:30:49 * M30W fixed the crash
06:30:57 <merijn> If ServerM is MonadIO anyway then lifting earlier doesn't really change anything...
06:31:13 <|||tux||> ServerM = ReaderT ServerEnvironment IO
06:31:17 <merijn> |||tux||: "liftIO $ hGetLine hdl"
06:31:38 <|||tux||> merijn: I mean the "handle" function
06:32:12 <merijn> |||tux||: The same way you would normally use it?
06:32:31 <Lethalman> :t liftIO
06:32:32 <lambdabot> MonadIO m => IO a -> m a
06:32:59 <|||tux||> But handle has type (e -> IO a) -> IO a -> IO a, but I want it to be (MonadIO m) => (e -> IO a) -> m a -> m a
06:33:07 <Lethalman> @hoogle (Monad m, Monad n) => m a -> n a
06:33:08 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
06:33:08 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
06:33:08 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
06:33:26 <merijn> |||tux||: You can just do "liftIO $ handle foo bar"
06:33:31 <M30W> |||tux||: Current -> http://ix.io/3Sw+3Sx+3Sy+3Sz/ -> http://ix.io/3SA
06:33:37 <merijn> :t handle undefined undefined
06:33:38 <lambdabot> Not in scope: `handle'
06:33:42 <M30W> |||tux||: Current -> http://ix.io/3Sw+3Sx+3Sy+3Sz+3SA/
06:33:47 <merijn> :t Control.Exception.handle undefined undefined
06:33:48 <lambdabot>     Ambiguous type variable `e0' in the constraint:
06:33:49 <lambdabot>       (GHC.Exception.Exception e0)
06:33:49 <lambdabot>         arising from a use of `Control.Exception.Base.handle'
06:34:04 <merijn> :t Control.Exception.handle (undefined :: SomeException -> IO a) undefined
06:34:05 <lambdabot>     Not in scope: type constructor or class `SomeException'
06:34:15 <merijn> :t Control.Exception.handle (undefined :: Control.Exception.SomeException -> IO a) undefined
06:34:16 <lambdabot> IO a
06:34:21 <merijn> :t liftIO $ Control.Exception.handle (undefined :: Control.Exception.SomeException -> IO a) undefined
06:34:23 <lambdabot> MonadIO m => m a
06:34:28 <merijn> Presto :)
06:34:53 <byorgey> |||tux||: you can't change   (e -> IO a) -> IO a -> IO a   to  (MonadIO m) => (e -> IO a) -> m a -> m a   using only liftIO, because some of the IO a's  are on the LHS of arrows
06:35:19 <byorgey> you could change it to  (MonadIO m) => (e -> IO a) -> IO a -> m a
06:35:30 <merijn> |||tux||: Oh, I see your issue with that. Yes, that's annoying
06:36:10 <merijn> The two answers are use MonadCatchIO from the lifting library I forgot the name of, or don't catch excpetions thrown in your transformer
06:36:11 <byorgey> I think there are solutions to this kind of problem using things like  monad-peel, but I don't really understand them
06:37:41 <hpaste> “|||tux||” pasted “Only 2 more problems” at http://hpaste.org/80373
06:37:59 <|||tux||> @ M30W that's the version I currently have
06:38:25 <|||tux||> 1 problem is the compile error, 2nd the one with the "handle"
06:39:52 <|||tux||> There is MonadCatchIO-mtl and MonadCatchIO-transformers :p
06:43:46 <M30W> |||tux||: http://ix.io/3SB+3SC+3SD+3SE+3SF
06:44:57 * flebron wonders how M30W went from last night's "Wait, so you seriously can't append an element to a list?" to monad transformers in about 10 hours.
06:45:06 <|||tux||> :p
06:45:42 <|||tux||> M30W: You need a Hashable instance for File
06:45:59 <|||tux||> http://hackage.haskell.org/packages/archive/hashable/1.1.2.3/doc/html/Data-Hashable.html
06:46:19 <M30W> |||tux||: Not using the ByteString's yet, and as for the serverState- I've removed that for now. I might add some real state management; -> failed to bind to the port, can't write to disk, locked down - too many failed auth attempts too quickly; maybe a ban list.
06:46:39 <M30W> |||tux||: I noticed .. deriving Hashable ?
06:47:54 <M30W> flebron: This is my first haskell program. ^_^ And yea; those lists made sense after they sunk into my >100hrs no sleep -now record for me- hehe.
06:49:07 <merijn> At >100hrs (in fact after >18 hours) I'm convince sleeping 6-8 hours will make you exponentially more productive than staying awake
06:49:36 <Taneb> Unless you're trying to be the next Salvador Dali
06:49:43 <Taneb> In which case never ever sleep again
06:49:49 <|||tux||> M30W: You need to make your own instance
06:50:07 <srhb> merijn: Amphetamine.
06:50:26 <M30W> |||tux||: So not data File = File {...} deriving Hashable?
06:50:27 <merijn> srhb: That just makes you feel more awake, it doesnt actually improve your cognitive skills
06:50:33 <|||tux||> M30W: no
06:50:46 <srhb> merijn: I don't think that's right
06:51:19 <merijn> Regardless, I personally don't even want to help, because I feel that'd be encouraging some ridiculously irresponsible and unhealth behaviour...
06:51:35 <M30W> nor `instance Hashable File`
06:51:36 <M30W> Hmm
06:51:50 <hpc> gah
06:52:00 <hpc> "Hashable" <=> "Hashtable"
06:52:11 <|||tux||> instance Hashable file where hash = your implementation of hash
06:52:16 <srhb> merijn: Sort of agree. :P
06:52:22 <merijn> srhb: They might help a little, but I refuse to believe amphetamine can offset the cognitive decline of 100 hours without sleep
06:52:41 <srhb> merijn: Oh, I didn't mean to make such a claim.
06:52:52 <hpc> at that many hours without sleep, you are into brain damage territory
06:53:00 <merijn> hpc++
06:53:11 <hpc> (you will die of lack of sleep before you die of lack of food)
06:53:16 <M30W> |||tux||: My implementation?
06:53:21 <M30W> Hmm..
06:53:26 <Taneb> M30W, sleep. You are not Salvador Dali
06:53:56 <Lethalman> |||tux||, what happens in these case if another module wants to provide an instance of File? is usually better to wrap File in another newtype instead?
06:54:02 <Lethalman> *cases
06:54:02 <srhb> hpc: I'd be more worried about depression. Ruining receptor sensitivity is bad.
06:54:20 <M30W> Mon Jan  7 01:54:03 EST 2013
06:54:27 * M30W got 4hrs last night; next!
06:55:10 * M30W has a feeling he has something wrong. |||tux|| ?
06:56:19 <|||tux||> Lethalman: File is already a "data File"
06:56:39 <Lethalman> |||tux||, maybe I wasn't clear
06:56:56 <Lethalman> |||tux||, what if another module wants to instance Hashable File in another way?
06:57:26 <Lethalman> isn't in general more safe to wrap File and create an instance Hashable of the wrapper instead?
06:58:10 <|||tux||> Yes,  but I don't think it's worth the noise (when there is only one instance. You can still wrap it in a newtype later)
06:58:17 <Lethalman> |||tux||, it was just to know
06:58:25 <Lethalman> ok
06:58:27 <Lethalman> :)
06:58:30 <M30W> |||tux||: I'm lost for what to do with the `where hash = ...` ... -> NoIdea ()
06:58:48 <allsystemsarego> I'd like to build a .so (binary library) with Haskell, then call its functions from within Ruby. Do people do that commonly? Google hasn't yielded anything comprehensible.
06:59:01 <|||tux||> M30W: What is fID?
06:59:13 <M30W> |||tux||: File ID
06:59:15 <merijn> allsystemsarego: Well, it's probably not common, but it shouldn't be that hard
06:59:26 <M30W> id was taken :(
06:59:35 <merijn> allsystemsarego: (Well, I dunno about Ruby's C FFI, but Haskell's C FFI is rather easy)
06:59:37 <Lethalman> allsystemsarego, you can create dynamic .so libraries in haskell with ghc afaik, don't know about using it in another language
06:59:40 <hpc> allsystemsarego: you'd likely end up going with an FFI export of the haskell functions
06:59:58 <hpc> then ruby FFI imports the "C functions" that you intend to use
07:00:22 <Lethalman> or find a way to call haskell from ruby, sort of evaluate_haskell ("......") ?
07:00:25 <hpc> keeping in mind that you do need to start the haskell RTS on your own...
07:00:28 <|||tux||> you could just try instance Hashable file where hash f = hash $ fID x ?
07:00:30 <allsystemsarego> hpc, that sounds interesting, is that documented anywhere?
07:00:38 <hpc> @where ffi
07:00:38 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
07:00:52 <merijn> allsystemsarego: The Haskell FFI is documented quite well, the ruby FFI you'd have to ask in #ruby
07:01:22 <M30W> allsystemsarego: http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries google "ghc compile shared library" ghc -shared -O Foo.so Foo.hs
07:01:23 <merijn> allsystemsarego: Going via 2 C FFI's is rather common for hooking up languages to each other, so it's not an odd thing to do.
07:01:25 <allsystemsarego> merijn, is that the FFI going into or out of Haskell?
07:01:36 <hpc> allsystemsarego: both
07:01:40 <merijn> allsystemsarego: Both, the FFI let's haskell call C and let's C call haskell
07:01:55 <allsystemsarego> oh nice
07:02:02 <allsystemsarego> I'll look into that
07:02:15 <merijn> Ruby's FFI (presumably) does the same, so you just pretend your exported haskell function is a C function called by Ruby's FFI
07:02:16 <M30W> |||tux||: ... hash f = hash $ fID x ?
07:02:24 <M30W> I read... loop for one.
07:02:38 <hpc> M30W: it's a polymorphic recursion
07:02:39 <M30W> f /= x so more confused there.
07:02:49 <hpc> oh, and that...
07:03:29 <|||tux||> M30W: I mean hash f = has $ fID f -- :D
07:03:38 <M30W> :D
07:03:43 <M30W> That makes more sense :D
07:04:42 <|||tux||> Btw, there is a liftCatch
07:05:20 <M30W>     Not in scope: type constructor or class `H.Hashable'
07:05:35 <M30W> |||tux||: What am I missing/doing wrong? I figure wrong module for one ^
07:05:59 <|||tux||> JUst put it in your Core.File module
07:06:05 <M30W> It is
07:06:24 <|||tux||> and import Data.Hashable
07:06:25 <M30W> instance H.Hashable File where hash f = has $ fID f
07:06:31 <M30W> That is what I'm missing :)
07:07:12 <hiptobecubic> This is a pretty interesting discussion: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
07:07:33 <M30W> Not in scope: type constructor or class `Hashable' Perhaps you meant `Data.Hashable.Hashable' (imported from Data.Hashable)
07:07:36 <M30W> O.o
07:07:43 <hiptobecubic> I'm not sure I completely see how the typeclass example reduces to the record one in all cases, but it's something to consider
07:08:03 <hiptobecubic> M30W, Hashable, not Hashable.
07:08:25 <M30W> They are identical to my eyes O.o
07:08:42 <hiptobecubic> One is "Hashable" and the other is just "Hashable"
07:09:05 <M30W> Identical?
07:09:19 <hiptobecubic> Are they?
07:09:26 <M30W> I'm confused
07:09:34 <Taneb> > "Hashable"== "Hashable"
07:09:35 <lambdabot>   True
07:09:42 <hiptobecubic> i'm just playing with you. Maybe you imported qualified somehow?
07:09:49 <M30W> Nope
07:09:52 <byorgey> M30W: perhaps you have Data.Hashable imported qualified?
07:09:57 <M30W> Ah
07:09:59 <M30W> Derp
07:10:07 <M30W> Where did that qualified come form :P
07:10:09 <hiptobecubic> :)
07:10:11 <byorgey> hehehe
07:10:27 <M30W> xD
07:10:34 <M30W> @hoogle has
07:10:35 <lambdabot> Data.HashTable module Data.HashTable
07:10:35 <lambdabot> Data.HashTable hashInt :: Int -> Int32
07:10:35 <lambdabot> System.Mem.StableName hashStableName :: StableName a -> Int
07:11:22 <M30W> O.o
07:11:36 <shapr> Ok, why would "cabal install mime" say that the latest version is installed, but ./Setup configure wouldsay mime 0.3.* is missing?
07:11:36 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
07:12:08 <byorgey> shapr: what does ghc-pkg say?
07:12:34 <shapr> byorgey: ghc-pkg list|grep mime shows mime-0.3.4
07:12:49 <byorgey> in the global or local package DB?
07:12:52 <M30W> What to import to get 'has' |||tux|| ?
07:12:57 <shapr> er, I don't know
07:13:14 * M30W remembers reading it..
07:13:24 <shachaf> shapr: Why are you using ./Setup configure?
07:13:35 <byorgey> I wonder if there is a way to get grep to just highlight matching lines but still print everything
07:13:42 <shapr> shachaf: So iCalendar will actually compile in 256MB of RAM
07:13:54 <shachaf> byorgey: | less, /mime
07:13:57 <shapr> byorgey: Ok, mime is in the global package setup
07:14:03 <shachaf> Not that that's grep. But it works here.
07:14:12 <shapr> er, DB
07:14:19 <byorgey> shachaf: yes, that works, but it's not what I asked =)
07:14:32 <M30W> |||tux||: I'm still confused to why I need to define an instance for the Hashable when HashSet is meant to deal with the hashing ?
07:14:36 <shapr> shachaf: If you have more ideas on getting GHC to compile in 256MB of RAM, I want to hear them :-)
07:14:37 <shachaf> True.
07:14:49 <M30W> List of File's
07:14:56 <byorgey> ah, someone on SO suggests the hack: grep --color -E "pattern|$" file
07:15:05 <byorgey> if the $ matches it has nothing to highlight =P
07:15:13 <shachaf> That works.
07:15:17 <shapr> byorgey: mime is only in the global DB
07:15:33 <|||tux||> M30W: Because HashSet is meant to deal with managing objects that can be hashed. But it doesn't know how your File object can be hashed, so you need to make an instance of Hashable to let it know
07:15:41 <byorgey> shapr: hmm, ok, it should still find it when you do ./Setup configure though
07:15:47 <M30W> |||tux||: Ah.
07:15:55 <M30W> |||tux||: Okay, well what about the 'has' ?
07:16:03 <|||tux||> M30W: it's hash (typo)
07:16:14 <byorgey> shapr: what about if you do ./Setup configure -v (or maybe -v2 or -v3)?
07:16:18 * shapr tries
07:16:32 <HugoDaniel> :D
07:16:47 <M30W> |||tux||: :|
07:16:47 <byorgey> apparently ack can do it, with a --passthru option
07:17:03 <|||tux||> M30W: Also, Your first line of addCommand should become "addCommand h xs = liftCatch catch (x (read . head $ xs :: Integer) >> liftIO (hPrint h "ok")) $ liftIO . E.invalidArgument h" (That includes the handle again)
07:17:36 <|||tux||> M30W: You need to import Control.Monad.Trans.Reader for liftCatch and add catch to the import list from Control.Exception
07:17:37 <M30W> Yay
07:17:39 <hpaste> shapr pasted “./Setup configure -v3” at http://hpaste.org/80375
07:18:16 <HugoDaniel> Jafet: yeah, my problem is that foreignptr keeps the finalizer function, which cannot be serialized or put into a unboxed vec
07:18:21 <shapr> Oh wait, mime is in my user db!
07:18:26 <HugoDaniel> ill just use normal Vector ByteString
07:19:20 <hpaste> shapr annotated “./Setup configure -v3” with “ghc-pkg list” at http://hpaste.org/80375#a80376
07:19:49 <jtootf> why aeson does not have a conduit interface in the same manner xml-conduit has? am I missing something?
07:19:55 <M30W> |||tux||:     `hash' is not a (visible) method of class `Hashable'
07:19:59 <M30W> O.o
07:20:31 <shapr> byorgey: So it won't necessarily see the mime userDB package?
07:20:57 <shapr> I don't mind installing everything globally, except for the multi-hour compile times.
07:21:07 <byorgey> shapr: no, it should, since you're building as user, not as root
07:21:15 <byorgey> shapr: do you have multiple versions of ghc installed?
07:21:19 <shapr> nope
07:21:24 <|||tux||> M30W: :O It surely is: http://hackage.haskell.org/packages/archive/hashable/1.1.2.3/doc/html/Data-Hashable.html. Do you use the right Hashable?
07:21:48 <byorgey> it's not just mime that it isn't finding, a bunch of those other packages it says it can't find are installed too
07:21:48 <shapr> I only have the debian/wheezy ghc installed
07:22:08 <shapr> Yup, I figured focusing on mime would be a good start though :-)
07:22:14 <M30W> |||tux||: O.o
07:22:23 <byorgey> shapr: what happens if you  runhaskell Setup configure?
07:22:27 <|||tux||> M30W: can you upload your code again?
07:22:30 <M30W> Damn firefox died need to reboot to get that back haha. Hmm.
07:22:30 <byorgey> is there a particular reason you compiled Setup?
07:22:45 <shapr> I don't have runhaskell, GHC on ARM doesn't have GHCi
07:22:54 <byorgey> good reason!
07:23:08 <hpc> byorgey: my mind boggles at the cacophany of mess-ups that would be needed to make such a thing matter ;)
07:23:13 <M30W> |||tux||: http://ix.io/3SK+3SL+3SM+3SN/
07:23:29 <byorgey> shapr: oh! I think I figured it out
07:23:36 <shapr> byorgey: I compiled Setup because separating the many steps that happen from "cabal install iCalendar" reduces GHC's memory usage
07:23:54 <byorgey> shapr: by default, ./Setup actually does try installing into the global DB, not the local DB
07:23:58 <byorgey> I have no idea why
07:24:01 <shapr> ohhh
07:24:06 * shapr tries adding --user
07:24:08 <byorgey> shapr: try  ./Setup configure --user
07:24:25 <shapr> yay!
07:24:28 * shapr hugs byorgey 
07:24:33 <byorgey> shapr: what tipped me off was that the -v3 output only says it ran  ("/usr/bin/ghc-pkg",["dump","--global","-v0"])
07:24:43 <byorgey> and it didn't call ghc-pkg again with --user
07:24:50 <shapr> weirdness
07:24:56 <shapr> But now I know!
07:24:56 * M30W joins in on shapr's hug with byorgey. GROUP HUG!!
07:25:01 <byorgey> then I remembered about the Setup default (which is different than the cabal install default)
07:25:03 <shapr> M30W: ha
07:25:04 <HugoDaniel> :)
07:25:07 <byorgey> hugs for everyone!!
07:25:18 * M30W hugs those with hug in their name
07:25:20 <byorgey> uh, I mean, ghci for everyone!
07:25:20 <M30W> Come here HugoDaniel
07:25:23 <HugoDaniel> :D
07:25:24 <M30W> ^_^
07:25:27 <HugoDaniel> i prefer ghc to hugs
07:25:29 <shapr> Ok, so in just a few hours I may be able to parse Google Calendare's ics output!
07:25:34 <M30W> Lol.
07:25:46 <byorgey> shapr: w00t!
07:25:59 <byorgey> but on a tiny $35 computer!
07:26:20 <M30W> |||tux||: Suggestion?
07:26:31 <byorgey> assuming shapr did not randomly give his normal computer the hostname 'raspberrypi'
07:26:33 <hiato> Hey all, I was wondering whether there was something I could add to the deriving clause of a datatype so that it succ/pred was considered modulo the enumeration. That is, type S = Foo | Bar deriving(Qux) such that succ Foo == Bar and succ $ succ Foo == Foo ?
07:26:58 <shachaf> hiato: No, that's not how Enum works anywhere.
07:27:03 <dmwit> hiato: Nope, that breaks the spec for Enum. If you want that, you have to use a different class.
07:27:15 <shapr> byorgey: That's true, this is a tiny $35 computer.
07:27:22 <hiato> Ah, ok, cool
07:27:23 <byorgey> =)
07:27:26 <hiato> I shall do that then
07:27:30 <hiato> ta guys :)
07:28:08 <byorgey> Enumcyclable
07:29:08 <hiato> byorgey: I was thinking EnumMod or something, but I like that :p
07:29:23 <byorgey> hiato: the verb form is 'to enumcyclate'
07:29:37 <byorgey> ;-)
07:29:49 <hpc> enumcyclate-diboundedum
07:29:50 <hiato> :P
07:29:56 <hiato> heh
07:30:58 <yc4891> :)
07:32:37 <dmwit> byorgey: Oh, that's a wonderful idea! hostnames like "droid", "inspiron", "centrino", "geforce"
07:32:47 <byorgey> hahaha
07:32:49 * dmwit cackles madly
07:33:47 <Ziarkaen> IS there a function identical that "adds" a dummy parameter to another function e.g. (a->b) -> c -> b
07:33:48 <byorgey> "80386"
07:34:00 <byorgey> (are numbers allowed in hostnames?)
07:34:14 <shachaf> Ziarkaen: Do you mean (a -> b) -> c -> a -> b?
07:34:16 <Ziarkaen> Currently I'm using (\ _ -> f)
07:34:16 <Taneb> :t const :: (a -> b) -> c -> a -> b
07:34:18 <lambdabot> (a -> b) -> c -> a -> b
07:34:33 <byorgey> @src const
07:34:34 <lambdabot> const x _ = x
07:34:49 <Ziarkaen> shachaf, Yeah, I think so.
07:35:25 <M30W> |||tux||: ping
07:35:50 <Ziarkaen> Taneb, Thanks
07:41:52 <hiato> So hmm, I'm perhaps not getting this whole class inheritance thing. What should I say if I want the effect of (Enum a) => Foo a where \n succ a -> a, without ghc moaning about an ambigous reference to succ in code like baz :: (ECD a) => a -> a \n baz a = succ a ?
07:42:01 <hiato> s/ECD/Foo
07:42:09 <hiato> (one of the more interesting typos I've made)
07:42:20 <hiato> and there is an instance missing
07:42:25 <byorgey> hiato: you can't reuse the name 'succ'
07:42:27 <M30W> |||tux||: ping
07:42:45 <byorgey> hiato: you have to make up a new name
07:42:48 <hiato> byorgey: oooh, so classes that inherit can't extend the functions of other classes?
07:43:01 <elliott> wouldn't really make any sense to
07:43:02 <byorgey> hiato: there is no inheritance.
07:43:15 <hiato> right. Well I guess that's the issue then
07:43:17 <byorgey> hiato: class (Enum a) => Foo a   just means that instances of Foo must also be instances of Enum
07:43:29 <hiato> *duh*
07:43:34 <hiato> Thank you byorgey
07:43:42 <byorgey> you're welcome.
07:43:46 <hiato> I was being rather silly there
07:48:52 <|||tux||> M30W: pong back
07:48:57 <M30W> |||tux||: Yay
07:49:12 <M30W> Any idea on this hash?
07:49:19 <|||tux||> No :/
07:49:47 <M30W> hashable-1.2.0.3
07:49:54 <M30W> That help?
07:49:57 <M30W> |||tux||:
07:50:16 <|||tux||> The doc is from hashable-1.1.2.3, so maybe hash was only added then
07:50:34 <M30W> Hmm
07:50:53 * M30W wants to view link but only got text browsers atm D:
07:51:18 <M30W> |||tux||: It wouldn't make sense to remove.
07:51:24 <M30W> Hense, we need it.
07:51:53 <M30W> Is there a way to see if installed packages are out of date?
07:53:14 <byorgey> M30W: yes, install the highlight-versions package, then do   ghc-pkg list | highlight-versions
07:53:55 <M30W> byorgey: ... Cause hilights are needed ? :P
07:54:09 <M30W>     Default available version: 3.8.7.4                                                                                                                                               │
07:54:13 <M30W>     Installed versions: 3.9.0.0
07:54:13 <M30W> Trippy
07:54:27 <|||tux||> instance Hashable File where
07:54:28 <|||tux||>   hashWithSalt s f = Data.Hashable.hashWithSalt s (fID f)
07:54:31 <|||tux||> Seems to work
07:55:54 <M30W>     No instance for (hashable-1.2.0.2:Data.Hashable.Class.Hashable
07:55:57 <M30W> dahell?
07:56:39 <M30W> |||tux||: What's being salted also?
07:57:19 <dmwit> M30W: ghc-pkg list hashable?
07:57:34 <dmwit> That looks like you have two versions installed and it's trying to do something across versions.
07:57:38 <M30W>    hashable-1.2.0.2
07:57:39 <M30W>    hashable-1.2.0.3
07:57:42 <M30W> O.o
07:57:59 <M30W> Remove old?
07:57:59 <dmwit> Yeah, you should try removing the older version, fixing up any packages that break as a result, and going from there.
07:58:22 <M30W> ghc-pkg: unregistering hashable-1.2.0.2 would break the following packages: unordered-containers-0.2.3.0 (use --force to override)
07:58:23 <dmwit> Yes, though that will undoubtedly break some packages. You can fix them by reinstalling.
07:59:08 <dmwit> You could also try "cabal install --reinstall unordered-containers --constraint 'hashable installed'" before you unregister to make sure it will work.
07:59:08 <|||tux||> M30W: I think you should try to unregister the 1.2.0.3 version
07:59:22 <dmwit> That's another option, yes.
07:59:35 <dmwit> Though you'll still undoubtedly have to fix some packages. =)
07:59:55 <M30W> Yay compiled
08:00:00 <M30W> |||tux||: working lol
08:00:16 * hackagebot fsnotify 0.0.6 - Cross platform library for file creation, modification,  and deletion notification.  http://hackage.haskell.org/package/fsnotify-0.0.6 (MarkDittmer)
08:00:19 <M30W> |||tux||: IT's the only registered now haha
08:00:34 <|||tux||> dmwit: I could remove hashable-1.2.0.3 without breakage
08:01:08 <|||tux||> Is there a way to update all cabal packages?
08:01:24 <M30W> Sigh. Why does hPrint have to tell me "ok" >_<
08:01:39 <M30W> hpaste suggested replacing hPutStrLn . show with hPrint.
08:02:06 <|||tux||> M30W: running gives Prelude.head: empty list hahah
08:02:13 <M30W> > print "ok" >> putStrLn "ok"
08:02:15 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
08:02:15 <lambdabot>    arising from a use of ...
08:02:21 <M30W> |||tux||: pass argument for port
08:02:50 <M30W> |||tux||: http://ix.io/3SR+3SS+3ST+3SU                                                                                                                                                         │
08:02:56 <M30W> Update maybe? ^_^
08:03:30 <dmwit> M30W: hPrint h is the same as hPutStrLn h . show; neither are the same as hPutStrLn. That shouldn't really be surprising...
08:04:15 <M30W> dmwit: not exactly the same
08:04:24 <|||tux||> Ah it works
08:04:36 <M30W> |||tux||: ls ;)
08:05:00 <dmwit> M30W: Yes, exactly the same. See the source: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#hPrint
08:05:16 <M30W> Can't click and hmm...
08:05:52 <M30W> Nvm, was due to context that was written that way. Fixed. :)
08:06:07 <M30W> |||tux||: addCommand h xs = liftCatch catch (x (read . head $ xs :: Integer) >> liftIO (hPutStrLn h "ok")) $ liftIO . E.invalidArgument h -- patch :)
08:06:27 <M30W> hPut was for the ACK's
08:06:33 <M30W> hPrint *
08:07:57 <M30W> |||tux||: nc localhost PORT <<< ls <<< quit
08:08:26 <M30W> if bash -> echo ls$'\n'quit | nc localhost PORT
08:08:29 <M30W> ;)
08:08:36 <M30W> bash sucks lol.
08:09:39 <M30W> |||tux||: Without ls we can't see if everything is working haha.
08:14:31 <hiptobecubic> Is anyone using shake to build anything?
08:16:29 <M30W> |||tux||: Hmm, In attempt to get ls working... instance Show File where show x = unlines [ fID x, size x, src x, out x, state x ] -- :|
08:16:56 <M30W> Ah nvm
08:18:36 <heatsink> I'm using shake.
08:19:30 <|||tux||> What is out?
08:20:30 <M30W> Hmm
08:20:48 <M30W> |||tux||: outfile, will be ondisk.
08:21:16 <M30W> |||tux||: and src will be for example.. https://somewebsite.tld/path/file.ext
08:21:30 <M30W> s/http/protocole
08:21:50 <beaky> hello
08:21:58 <M30W> Hello beaky
08:22:02 <beaky> does haskell have any bitwise operators like C or Python?
08:22:08 <luite> yes, see Data.Bits
08:22:32 <beaky> :D thanks
08:22:34 <|||tux||> M30W: So this is a file download server? :P
08:22:42 <M30W> |||tux||: Yes :)
08:23:21 <beaky> @src popCount
08:23:22 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:23:25 <beaky> :(
08:23:45 <M30W> |||tux||: Interfaced through tcp I'll make a library to interact with it and shove it in my xmonad config ;) Then play with a little gfx to get and show download status with M-<Escape>
08:23:49 <M30W> :D
08:24:07 <beaky> how do I find out the source of any haskell module on my system?
08:24:35 <M30W> Might make firefox and luakit plugins to support adding to the queue. (WOW I SPELT QUEUE RIGHT THE FIRST TIME! :D)
08:25:17 <M30W> |||tux||: Best part to it is. Daemon/server meaning it can run anywhere and still interface easily. :D
08:25:47 <heatsink> Source code doesn't have to be installed with the module.  You can search on hoogle for the package containing a module.
08:25:55 <M30W> ^ It's not gonna serve the files lol; that could get bad. D:
08:26:19 <heatsink> Search on hackage, I mean
08:26:40 <heatsink> If you know the package name, then ghc-pkg will tell you where the HTML documentation is
08:26:45 <M30W> Acturally... Not a bad function; Atleast to be able to build a url or some structure for giving the file's new location to another client.
08:27:03 <heatsink> Depending on how the package was configured, the HTML documentation may include source code.
08:27:31 <M30W> |||tux||: What do you think of it so far?
08:28:00 <M30W>       add an instance declaration for (Show (ServerM (H.HashSet File)))
08:28:06 <M30W> Lies, it's declared!
08:29:20 <M30W> |||tux||: The client library will be highly inspired by libmpd ;) Hehe.
08:29:46 <heatsink> hiptobecubic, did you have a shake question?
08:29:55 <M30W> |||tux||: The protocole I've created is similar to MPD's but with very different use.
08:30:23 * M30W can't get it to work with that printing D:
08:30:28 <hiptobecubic> heatsink, just looking for examples of it in the wild to see what they entail really.
08:31:00 <M30W> Heh
08:31:26 <M30W> |||tux||: Forgot that it's a HashSet and I need to print the whole thing... Need to map it in a way.
08:31:45 <|||tux||> M30W: Just playing with it a bit, for fun :D
08:32:23 <M30W> |||tux||: Ha, most fun command = ack haha
08:32:58 <heatsink> Cabal and Shake https://github.com/cirodrig/triolet/blob/master/SetupSrc/Rules.hs
08:33:41 <M30W> |||tux||: wait for it....
08:33:47 <M30W> #ack 2
08:33:47 <M80T-28079> ACK 2 Invalid argument passed
08:34:07 <M30W> |||tux||: ^^ very simple zsh wrapper to mix with IRC :)
08:34:18 <|||tux||> nice
08:34:31 <M30W> #add 1
08:34:32 <M80T-28079> ok
08:34:35 <M80T-28079> pong
08:34:35 <M30W> Thanks
08:34:40 <M30W> Oh god
08:34:59 <M30W> He'd pong infinitly (he died now) timeout already
08:35:41 <M30W> |||tux||: :)
08:38:42 <hiptobecubic> heatsink, i don't suppose you have any?
08:38:43 <nh2> where are docs for GHC.Arr, e.g. readSTArray, for newer ghc versions? All I find is for ghc 6
08:39:31 <heatsink> hiptobecubic, https://github.com/cirodrig/triolet/blob/master/SetupSrc/Rules.hs
08:40:16 <M30W> |||tux||: Any suggestion for getting it to print the list like this ... unlines [ unwords [ show $ fID x, show $ size x, src x, out x, show $ state x ], unwords [ ... ] ]
08:40:25 <hiptobecubic> heatsink, nice. thanks
08:40:29 <heatsink> sure
08:40:39 <M30W> unlines as in, each be their own line.
08:41:17 <M30W> acturally...
08:41:48 <heatsink> Is the output meant to be human-readable?
08:43:41 <M30W> heatsink: Not required; print gives reasonable ;) TODO: get it to print. xD
08:44:04 <heatsink> > show $ vcat [hsep $ map text xs | xs <- [["a", "b"], ["c", "d", "e"]]]
08:44:05 <lambdabot>   "a b\nc d e"
08:44:23 <heatsink> > vcat [hsep $ map text xs | xs <- [["a", "b"], ["c", "d", "e"]]]
08:44:24 <lambdabot>   a b
08:44:24 <lambdabot>  c d e
08:44:36 <M30W> TREE
08:45:18 <M30W> > vcat [hsep $ map text xs | xs <- [["a"],["b","c"],["d","e","f"]]]
08:45:20 <lambdabot>   a
08:45:20 <lambdabot>  b c
08:45:20 <lambdabot>  d e f
08:45:23 <M30W> :(
08:45:28 <covi> I need some help writing the correct Parsec code. Say my input has the form "TEXT... <*delim*> Some other TEXT... <*delim*>" and so on. How can I put those texts in a list, and ignore the delimiters? many1 anyChar `sepBy1` delimiter  doesn't work, as any one of "<*>" can appear in the texts, and the delimiter pattern would never be considered.
08:45:43 <M30W> > vcat [hsep $ map text xs | xs <- [["a"],[" b","c"],["d","e","f"]]]
08:45:44 <lambdabot>   a
08:45:44 <lambdabot>   b c
08:45:44 <lambdabot>  d e f
08:45:49 <M30W> > vcat [hsep $ map text xs | xs <- [[" a"],[" b","c"],["d","e","f"]]]
08:45:51 <M30W> :D
08:45:51 <lambdabot>    a
08:45:51 <lambdabot>   b c
08:45:51 <lambdabot>  d e f
08:46:02 <M30W> heatsink: ♥
08:47:57 <M30W> |||tux||: ping
08:48:06 <|||tux||> yes?
08:48:28 <M30W> How can I get lsCommand to work?
08:48:33 <M30W> I'm trying things
08:48:38 <M30W> No success D:
08:49:08 <M30W> listCommand *
08:49:09 <|||tux||> listCommand :: Handle -> ServerM ()
08:49:11 <|||tux||> listCommand h = getFiles >>= mapM_ (liftIO . hPrint h) . H.toList
08:49:31 <|||tux||> You also need to remove the liftIO from parseIn
08:49:43 <|||tux||> and a Show instance for your File :)
08:50:09 <M30W> Did them
08:50:19 <heatsink> covi1, Define a parser for non-delimiter text
08:50:23 <M30W> Also, not using Show instance but deriving (Eq, Show)
08:50:32 <M30W> And it's not listening to my commands...
08:50:41 <heatsink> It's a good idea to decide what is legal in ordinary text
08:50:49 <M30W> |||tux||: ^
08:50:57 <|||tux||> Is there a way to apply printf to a list of things?
08:51:07 <M30W> Oh derp nvm.... I fail XD daemon /= client ;)
08:51:11 <covi> heatsink: that's my problem -- i don't know how to correctly do this. how to avoid the delimiter pattern in the standard text?
08:51:27 <heatsink> How should "<*delim*<*delim*><*" be parsed?
08:52:09 <covi> ["<*delim*<*delim*><*"]
08:52:17 <covi> Wait
08:52:28 <covi> ["<*delim*", "<*"]
08:53:17 <heatsink> Okay
08:53:53 <|||tux||> Does anoyone know is there is a way to apply printf (from Text.Printf) to a list of arguments?
08:53:57 <|||tux||> if*
08:54:13 <heatsink> Then you want a parser that reads a character unless it's the beginning of the sequence "<*delim*>"
08:55:07 <covi> What do you mean? I still want to read "<*", but they are the beginning of the sequence.
08:55:53 <heatsink> If the current input starts with '<'
08:56:08 <heatsink> then it needs to see whether the next characters are "*delim*>"
08:56:13 <adimit> How do I derive a functor instance of a GADT which has a type class constraint in one of its type signatures? See hpaste below.
08:56:17 <hpaste> adimit pasted “GADTS & Type Class Constraints” at http://hpaste.org/80378
08:56:24 <srhb> |||tux||: What do you mean to a list of things. When you say it like that it just sounds like fmap.
08:56:25 <heatsink> before it can decide whether to accept the current input as a non-delimiter character.
08:56:27 <geekosaur> |||tux||, I suspect that's a type of fold
08:56:33 <srhb> |||tux||: Or well, map
08:56:35 <adimit> (it's just a minimal example that exhibits the problem. My real-world scenario will hopefully make more sense.)
08:56:41 <geekosaur> depending on what exactly you mean
08:56:47 <covi> heatsink: I see.
08:57:06 <heatsink> adimit, It's not a functor because the type parameter is constrainted by C
08:57:08 <geekosaur> (map / fmap is indeed another possibility)
08:57:35 <M30W> |||tux||: Thank-you very much sir. Maybe thanks to you, this downloader daemon will acturally get somewhere. :D
08:57:39 <covi> heatsink: what are some relevant functions that can help with this sort of "try looking ahead" task
08:57:40 <adimit> heatsink: :-\
08:57:58 <adimit> heatsink: So a functor can only work if its fmap is unconstrained by type classes?
08:58:13 <heatsink> Yes
08:58:42 <|||tux||> > foldl ($) (printf "[%s] %s %s") ["1", "2", "3"]
08:58:42 <heatsink> Your fmap needs type C b => (a -> b) -> A a -> A b
08:58:43 <lambdabot>   Occurs check: cannot construct the infinite type:
08:58:43 <lambdabot>    b0 = [GHC.Types.Char] ...
08:58:47 <adimit> I thought a construct like fmap :: (C a, C b) => (a -> b) -> F a -> F b would make sense, but I guess it doesn't.
08:58:58 <adimit> heatsink: Yeah, I figured.
08:59:04 <heatsink> but fmap has type (a -> b) -> A a -> A b, which is a more general type
08:59:17 <adimit> heatsink. I see.
08:59:22 <adimit> thanks.
08:59:46 <heatsink> covi, you can use call 'notFollowedBy' to check the rest of the input
08:59:48 <adimit> I guess I'll have to write my own "fmap."
09:00:17 <srhb> > map (printf "%c") [2,3,4,5] :: [String]
09:00:19 <lambdabot>   ["\STX","\ETX","\EOT","\ENQ"]
09:00:27 <srhb> > map (printf "%d") [2,3,4,5] :: [String]
09:00:29 <lambdabot>   ["2","3","4","5"]
09:00:41 <covi> heatsink: thanks very much!
09:01:04 <heatsink> covi, I'm looking for the documentation now
09:01:09 <|||tux||> srhb: not really what i want
09:01:22 <srhb> |||tux||: It's not clear to me what you want
09:01:32 <|||tux||> > printf "[%s] %s %s" "1" "2" "3"
09:01:34 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:01:34 <lambdabot>    (GHC.Show.Show a0)
09:01:34 <lambdabot>     ...
09:01:52 <|||tux||> > printf "[%s] %s %s" "1" "2" "3"
09:01:53 <lambdabot>   Ambiguous type variable `a0' in the constraints:
09:01:53 <lambdabot>    (GHC.Show.Show a0)
09:01:53 <lambdabot>     ...
09:02:03 <|||tux||> Why does that work in GHCi and not here?
09:02:20 <|||tux||> > printf "[%s] %s %s" "1" "2" "3" :: String
09:02:22 <lambdabot>   "[1] 2 3"
09:02:40 <|||tux||> Ok, I want it like that, just that I can pass the arguments "1" "2" "3" as a list
09:03:49 <heatsink> covi: So, your parser for a single non-delimiter character would be (notFollowedBy (text "<*delim*>") >> anyChar)
09:04:28 <srhb> |||tux||: That's a bit ugly.
09:04:42 <srhb> then again, printf is a bit ugly.
09:05:01 <heatsink> |||tux||, maybe the monomorphism restriction
09:05:11 <heatsink> @hoogle printf
09:05:11 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
09:05:11 <lambdabot> Text.Printf class PrintfArg a
09:05:11 <lambdabot> Text.Printf class PrintfType t
09:09:07 <|||tux||> What should I use instead?
09:12:18 <dmwit> |||tux||: Okay, you're passing it as a list; so you only have to handle Strings?
09:12:27 <geekosaur> :t \myList -> mapM_ (uncurry printf) (zip myList $ "[%s] " : repeat "%s ")
09:12:28 <lambdabot> (Monad m, PrintfType (m b)) => [String] -> m ()
09:12:48 <srhb> repeat " %s" probably
09:12:59 <geekosaur> yeh, you might want to rearrange the spaces
09:13:37 <geekosaur> I think I did that wrong though
09:13:52 <srhb> Yeah unzip would be nicer
09:15:28 <|||tux||> > (\myList -> mapM_ (uncurry printf) (zip myList $ "[%s] " : repeat "%s ")) $ ["1","2","3"]
09:15:30 <lambdabot>   Could not deduce (Text.Printf.PrintfType (m b0))
09:15:30 <lambdabot>    arising from the ambigu...
09:15:48 <|||tux||> > (\myList -> mapM_ (uncurry printf) (zip myList $ "[%s] " : repeat "%s ")) $ ["1","2","3"] :: IO String
09:15:49 <lambdabot>   Couldn't match expected type `GHC.Base.String'
09:15:49 <lambdabot>              with actual typ...
09:16:08 <|||tux||> > (\myList -> mapM_ (uncurry printf) (zip myList $ "[%s] " : repeat "%s ")) $ ["1","2","3"] :: IO ()
09:16:09 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
09:16:10 <lambdabot>    arising from a use of ...
09:16:20 <dmwit> http://hpaste.org/80379
09:16:27 <dmwit> 100% untested
09:17:40 <dmwit> Yeah, it is a really bad idea after all. I can see at least one very subtle bug.
09:18:24 <srhb> printf is ebil.
09:19:11 <dmwit> Oooo, GHC actually warns me about the bug. ghc++
09:19:43 <|||tux||> Ok, i will try something else to format it.
09:20:22 <gavri> is the fact that functions that take in multiple parameters can only be modelled in haskell as functions that take one parameter and then return a function that takes another a limitation in that it does not allow arbitrary parameters to be partially applied? I'm a haskell newbie and I sometimes am annoyed that I cannot partially apply the leftmost parameter of a function without flipping. should I not be annoyed?
09:20:52 <adimit> gavri: you could also use a lambda.
09:21:07 <dmwit> You could be annoyed by that. Is there another language that does something better?
09:21:17 <dmwit> Also, you may be interested in the "record-of-parameters" pattern.
09:21:19 <zomg> gavri: yeah use a lambda, and as for arbitrary number of arguments, you'd typically give those as a list
09:21:19 <adimit> There have been several proposals to sugar that stuff, but nothing has made it into ghc yet.
09:21:26 <gertc> code <- getLine is there a way to squize a (BS.pack code) in that one line?
09:21:42 <dmwit> BS.pack `fmap` getLine
09:21:51 <dmwit> or BS.pack <$> getLine, or half a dozen other spellings
09:22:03 <adimit> or liftM BS.pack getLine
09:22:11 <srhb> adimit: Except noooo. :P
09:22:26 <gavri> dmwit: I don't know if there's another language that does it better
09:22:26 <adimit> srhb: don't see why not. Care to explain?
09:22:44 <srhb> adimit: I don't think there are often good reasons to use liftM over the more general fmap
09:22:53 <gavri> thanks zomg, adimit, dmwit
09:22:58 <|||tux||> Arbitary arguments, like Text.Printf.printf? :P
09:23:17 <dmwit> gavri: http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
09:23:28 <heatsink> code <- fmap (\line -> do { (return . BS.pack) $ line } ) getLine
09:23:35 <adimit> srhb: yeah, but in this case, it makes sense, and emphasizes that you're in a monadic context.
09:23:40 <heatsink> Oh, forgot a join
09:23:49 <srhb> adimit: If you have a Monad, you have a functor, though.
09:23:50 <Nereid> oh no.
09:23:56 <adimit> srhb: that's a given.
09:24:10 <srhb> adimit: but it's a nitpick yeah, so nevermind me. I just thought liftM had more or less been banned. ;)
09:24:14 <Nereid> I'm starting to think that it's fine that $ is infixr.
09:24:34 <adimit> but you would never have a function like getLine be non-monadic (and still have close to the semantics you'd expect.)
09:24:54 <dmwit> Nereid: what?
09:24:58 <adimit> so I don't mind liftM here at all. And I don't think there's a performance penalty.
09:24:59 <Nereid> I know! :(
09:25:03 <srhb> adimit: I just prefer the generalized solution. Maybe it really just is personal preference. But what when you move up to liftM2 and friends? Then it gets ugly.
09:25:06 <gavri> dmwit: thanks
09:25:09 <dmwit> What's good about infixr $?
09:25:10 <srhb> adimit: (Or at least I think so)
09:25:11 <Nereid> if I'm writing general monadic code, I'd use liftM, only because Functor isn't actually a superclass of Monad. :(
09:25:17 <Nereid> srhb: use liftA2 and friends instead.
09:25:39 <srhb> Which is more general.
09:25:46 <srhb> (Which is what I'm arguing)
09:25:48 <Nereid> dmwit: it's too easy.
09:26:03 <dmwit> ?
09:26:06 <Nereid> like I have a big thing somewhere that's got $ in it.
09:26:12 <adimit> srhb: I think it's a matter of taste. liftM2 is OK, beyond that, it gets a bit ridiculous.
09:26:15 <Nereid> it's easy to just put liftIO $ in front of the whole thing.
09:26:23 <Nereid> or so
09:26:25 <adimit> Nereid: you mean your wallet?
09:26:32 <adimit> (or a safe.)
09:26:38 <srhb> adimit: ok. :) No reason to have a religious war over it.
09:26:46 <adimit> srhb: totally not. It's really a minor point.
09:27:12 <cmccann> the liftM functions are appropriate if you're writing generic combinators for monads and don't want to require the extra constraint
09:27:20 <Nereid> that's what I said.
09:27:24 <dmwit> Nereid: Sticking liftIO . or liftIO $ depending on context is not significantly harder.
09:27:33 <Nereid> sure but
09:27:41 <Nereid> that involves thinking.
09:27:41 <Nereid> :D
09:27:51 * dmwit nods
09:28:06 <Nereid> and then maybe later I decide I don't like the $ on the right anymore.
09:28:48 <dmwit> I don't see how infixr $ helps that situation.
09:29:38 <Nereid> but if I have liftIO . putStrLn $ a ++ b
09:29:49 <Nereid> I can't decide to change putStrLn $ a + b to just putStrLn a
09:29:58 <Nereid> without going all the way over to the . and changing it.
09:30:14 <cmccann> solution: write everything in pointless style
09:30:18 <cmccann> and never need $ at all
09:30:20 <cmccann> problem solved!
09:30:23 <Nereid> lol
09:31:06 <dmwit> Hm. While that's true, I don't (yet) feel like that's a compelling reason to have infixr $.
09:31:18 <Nereid> I want an operator that means . or $ depending on which one makes more sense.
09:31:52 <gertc> heatsink: Couldn't match type `m0 BS.ByteString' with `BS.ByteString'
09:32:04 <Nereid> dmwit: my point is that less thinking for me is good.
09:32:16 <mzero> Nereid: I think that would be a mistake ..... as ugly as I think the $ is, there is an essential difference that . vs. $ signifies, that is important for code readability
09:32:24 <cmccann> (oh, and on the previous subject of liftM vs. fmap &c.: http://stackoverflow.com/a/9509474/157360 )
09:32:38 <Nereid> mzero: I'm not being serious. I probably should have wrote ";)" next to it.
09:32:40 <mzero> (and by ugly, I meant typographically.  The semantics and syntax I like)
09:32:55 <mzero> Ah - that's what I get from coming in in the middle!  :-O
09:33:17 <mzero> and now... back to my horrid POSIX hacking....
09:33:25 <Nereid> ah.
09:33:33 <Nereid> there's never a reason to use liftA, I guess.
09:33:42 <Nereid> unless you're defining a Functor instance where fmap = liftA.
09:34:16 <cmccann> :t liftA
09:34:17 <lambdabot> Applicative f => (a -> b) -> f a -> f b
09:34:21 <cmccann> huh, that exists?
09:34:35 <cmccann> that's silly.
09:35:39 <dmwit> Yeah, it should clearly be liftA1.
09:35:48 <dmwit> And pure is a terrible name, it ought to be liftA0.
09:35:55 <elliott> cmccann: useful for defining fmap!!! sort of
09:36:14 <mzero> ah... get _another_ name for universal (.)
09:36:32 <Nereid> and return = liftM0, by analogy.
09:36:42 <mzero> @msg lambdabot
09:36:42 <lambdabot> Not enough privileges
09:37:03 <elliott> @msg mzero hello!
09:37:10 <mzero> I know.... I always forget
09:37:13 <mzero> anyway....
09:37:15 <mzero> @src .
09:37:15 <lambdabot> (f . g) x = f (g x)
09:37:15 <lambdabot> NB: In lambdabot,  (.) = fmap
09:37:27 * M30W is tempted to put in a backdoor into his daemon for jokes on friend's computers :D
09:37:30 <M30W> Hehe
09:37:37 <monochrom> haha
09:37:45 <M30W> monochrom: Btw; working ^_^
09:37:46 <monochrom> don't make it too devious!
09:37:54 <cmccann> so, how about renaming map to zipWith1?
09:38:07 <srhb> cmccann: Dear lord...
09:38:07 <Nereid> haha.
09:38:11 <monochrom> don't rename. have both names
09:38:18 <|||tux||> xD
09:38:25 <M30W> monochrom: http://ix.io/3T2+3T3+3T4+3T5/
09:38:27 <M30W> :D :D :D
09:38:37 <Nereid> map . const = zipWith 0
09:38:39 <Nereid> zipWith0
09:38:44 <|||tux||> :t Category.(.)
09:38:45 <lambdabot> Not in scope: data constructor `Category'
09:38:57 <cmccann> Nereid, not 'repeat'?
09:38:59 <Nereid> :t (Category..)
09:39:00 <lambdabot> Couldn't find qualified module.
09:39:06 <Nereid> cmccann: oh. yes.
09:39:07 <gertc> dmwit:  code <- BS.pack `fmap` getLine works but witch part of heatsink line added a monad?
09:39:08 <quchen> :t Data.Category.(.)
09:39:09 <lambdabot> Couldn't find qualified module.
09:39:11 <Nereid> :t (Control.Category..)
09:39:12 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
09:39:30 <cmccann> Nereid, since zipWith is basically (<*>) for zipList and repeat is pure
09:39:44 <Nereid> yes I had a small brain fart there.
09:40:20 * hackagebot distributive 0.3 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.3 (EdwardKmett)
09:40:22 * hackagebot free 3.3.0.2 - Monads for free  http://hackage.haskell.org/package/free-3.3.0.2 (EdwardKmett)
09:40:26 <dmwit> gertc: I don't understand the question.
09:41:13 <gertc> dmwit: code <- fmap BS.pack getLine works code <- fmap (\line -> do { (return . BS.pack) $ line } ) getLine does not work
09:41:39 <srhb> Woah.
09:41:41 <dmwit> Why would you try the latter?
09:42:00 <gertc> heatsink told me :)
09:42:03 <dmwit> Methinks somebody was trying to show off and didn't quite make it.
09:42:07 <dmwit> It was probably a joke.
09:42:39 * M30W loves Haskell :D
09:42:57 <srhb> (\ml -> do { line <- ml; return . BS.pack $ line }) getLine -- this would work, I think. Of course, it's stupid. :P
09:43:31 <srhb> getLine >>= return . BS.pack -- would also work. and is stupid. :P
09:43:43 <allsystemsarego> Hi all, I'm getting the error message "Ambiguous module name Prelude: it was found in multiple packages: base haskell98-2.0.0.2" when installing Hubris, a Ruby library that acts as a bridge into Haskell
09:43:47 <|||tux||> BS.pack <$> getLine
09:43:51 <gertc> maybe but once you start a joke i want at least understand it :)
09:44:02 <bxc> (modulo the fact htat the prelude isn't implemented this way) if i've got a type thats a monad (and so really an applicative), and an alternative, I think that gives enough for monadplus - i think there's nothing more than monadplus adds beyond monad+alternative. am i right?
09:44:10 <srhb> gertc: The reason it did not work is because the value was never extracted from its monadic context
09:44:20 <srhb> gertc: You need either do .. <- .. or >>= to do that
09:44:36 <srhb> gertc: Of course, the real solution just uses functors, so you don't need to do all that.
09:45:24 * hackagebot comonad-transformers 3.0.0.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-3.0.0.1 (EdwardKmett)
09:45:26 * hackagebot streams 3.0.0.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-3.0.0.1 (EdwardKmett)
09:45:28 * hackagebot comonad-extras 3.0.0.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-3.0.0.1 (EdwardKmett)
09:45:30 * hackagebot semigroupoid-extras 3.0.0.1 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-3.0.0.1 (EdwardKmett)
09:45:39 <M30W> srhb: I was just about to suggest the getLine >>= return . BS.pack and my ssh lagged and you did haha.
09:47:03 <M30W> edwardk: What percentage of "stocks"/packages have you got in hackage? I think you own it xD
09:47:05 <srhb> M30W: I did that for ages before realizing the virtues of fmap when I began, you're in good shape.
09:47:50 <M30W> srhb: :)
09:48:24 <dmwit> allsystemsarego: Did you get answered yet?
09:48:57 <allsystemsarego> dmwit, no, unfortunately
09:48:58 <dmwit> allsystemsarego: The answer to your problem is almost certainly to modify the cabal file to delete the haskell98 dependency.
09:48:59 <M30W> srhb: http://ix.io/3T2+3T3+3T4+3T5/ -- First haskell program (exc hacking vodik's XMonad config which did bring quite some exp)
09:49:00 <quchen> bxc: Yes. If something's a Monad and an Alternative, it's also a MonadPlus, with mzero = empty and <|> = mplus
09:49:19 <M30W> Admitingly had a fair bit of help form in here ^_^
09:49:33 <quchen> bxc: Basically, MonadPlus is something that's both a Monad and a Monoid. Alternative is the same with Applicative.
09:49:37 <allsystemsarego> dmwit, the culprit is at https://github.com/mwotton/Hubris/blob/master/Rakefile#L37
09:49:40 <dmwit> allsystemsarego: There may be miscellaneous other changes needed as well. We can help you with them if you keep us up-to-date on what's the most recent thing going wrong.
09:49:48 <M30W> Mostly needed with IORef + HashSet ;)
09:49:56 <M30W> srhb: ^_^
09:50:15 <srhb> M30W: Yes, I was helping you a bit earlier with that. :)
09:50:20 * hackagebot algebra 3.0.1.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-3.0.1.1 (EdwardKmett)
09:50:23 <M30W> Oh yes you were :P
09:50:27 <dmwit> allsystemsarego: Right, so, wherever that "Haskell" directory is coming from, look for a file named "foo.cabal" or similar.
09:50:28 <M30W> :D
09:50:47 <gertc> srhb: code <- (\ml -> do { line <- ml; return . BS.pack $ line }) getLine works thx
09:50:48 <allsystemsarego> dmwit, will do, and report back
09:50:53 <quchen> bxc: Just try 'instance MonadPlus foo where mzero = empty; mplus = (<|>)' and see what happens
09:50:59 <dmwit> allsystemsarego: modify this line: https://github.com/mwotton/Hubris/blob/master/Haskell/hubris.cabal#L37
09:51:06 <hpaste> anon pasted “android launch fail” at http://hpaste.org/80380
09:51:17 <M30W> flebron was funny when /s?he/ said about my brainfart last night with lists and then to monad transformations in 10hrs.
09:51:18 <dmwit> uh
09:51:20 <M30W> :P
09:51:26 <srhb> gertc: Yes, and the reason it works is because we extract and put back the value into IO, contrary to the other one. :)
09:51:36 <dmwit> allsystemsarego: hm =P
09:52:09 <srhb> M30W: I think your main advantage is you avoided the dreaded "WHAT IS A MONAD?!?!?!?!" crisis that holds up many people for so long.
09:52:21 <dmwit> allsystemsarego: Are you using Hubris from github or from somewhere else? Is Hubris definitely the package causing cabal to complain, or is it breaking while building a dependency?
09:52:52 <allsystemsarego> dmwit, I'm installing Hubris via the command "gem install hubris"
09:53:17 <dmwit> Is it possible that gem install is getting an outdated hubris?
09:53:22 <allsystemsarego> dmwit, it's not breaking during a dependency installation
09:53:28 <M30W> srhb: Heh
09:53:46 <allsystemsarego> dmwit, that could be a possibility
09:53:54 <dmwit> According to github, dflemstr fixed the problem you're having six months ago. =)
09:53:54 <M30W> srhb: In short what exactly is a "monad"
09:54:46 <dmwit> A monad is one of many maths-inspired design patterns you will encounter in Haskell.
09:54:49 <|||tux||> A monad is just a monoid in the category of endofunctors
09:54:54 <|||tux||> :p
09:55:01 <merijn> |||tux||: Don't say that, it's unhelpful and not funny
09:55:03 <dmwit> It's an interface that some types happen to implement.
09:55:11 <cmccann> @quote nuclear.waste
09:55:11 <lambdabot> dons says: Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
09:55:11 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
09:55:15 <|||tux||> merijn: I know, I just like that it sounds so complex
09:55:29 <hpc> |||tux||: a monad is actually a monad in the 2-category of categories
09:55:31 <merijn> |||tux||: It scares and confuses newbies for no reason
09:55:38 <dmwit> It turns out that the interface is rich enough that there's lots of nice functions you can write that only use that interface, and yet are meaningful across many implementations of that interface.
09:55:51 <merijn> |||tux||: The fact that you find it funny doesn't make it a suitable answer to a question
09:56:11 * M30W 's shell scripting skills are intact after today's Haskell. :D `for k in (${${$(ix -g user/archeydevil | grep -Eo '/[a-zA-Z0-9]{3}/')%/}#/}); ix -d $k`
09:56:13 <|||tux||> Ok, then nvm
09:56:14 <M30W> :D
09:56:17 <dmwit> merijn, |||tux||: Perhaps the rest of this discussion could got to #haskell-meta or something...
09:56:31 <bxc> quchen: well it typechecks...
09:57:55 <quchen> bxc: It's also correct. :-)
09:58:03 <allsystemsarego> dmwit, can you take a look at the .cabal file and say whether you see anything wrong with it? https://github.com/mwotton/Hubris/blob/master/Haskell/hubris.cabal
09:58:39 <dmwit> allsystemsarego: As I said, it looks like dflemstr fixed the problem you're having about six months ago.
09:58:41 <bxc> and there i was hoping the "try it" would reveal some oh so obvious-yet-subtle inconsistency at type checking time...
09:58:53 <bxc> quchen: but thanks for the sanity check.
09:58:54 <dmwit> See the commit linked at the top of that page.
09:59:09 <gertc> can you merge this 2 lines of code ? let Just cb = oauthCallback googleKey  let url = oauthAccessTokenEndpoint googleKey `appendQueryParam` googleAccessToken googleKey code cb
09:59:10 <quchen> bxc: Look at the common instances defined for Alternative and MonadPlus for reassurance: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Applicative.html#Alternative http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad.html#MonadPlus
09:59:36 <dmwit> gertc: Yes, using fromJust; however, I wouldn't recommend either version of this code.
09:59:49 <Yuu-chan> Hello
10:00:16 <dmwit> Howdy, Yuu-chan.
10:00:20 <shachaf> hi dmwit
10:00:20 * hackagebot representable-tries 3.0.1.1 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-3.0.1.1 (EdwardKmett)
10:00:22 * hackagebot representable-functors 3.0.0.3 - Representable functors  http://hackage.haskell.org/package/representable-functors-3.0.0.3 (EdwardKmett)
10:00:24 * hackagebot kan-extensions 3.1.0.2 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.1.0.2 (EdwardKmett)
10:00:27 <dmwit> Hiya, shachaf.
10:00:31 <Yuu-chan> How can I set a function that could be executed when the program is terminated? Something like atexit()
10:01:12 <dmwit> I don't think there is a good way, really.
10:01:22 <shachaf> Maybe an exception handler around main?
10:01:25 <quchen> Yuu-chan: Write it at the end of the main function? Maybe with a catchall in case something crashes in between
10:01:54 <dmwit> You can do that, but beware exitWith.
10:02:03 <dmwit> Possibly also beware signals.
10:02:08 <dmwit> <- not an expert
10:02:11 <shachaf> Why is exitWith different?
10:02:19 <dmwit> It doesn't throw an exception.
10:02:23 <allsystemsarego> dmwit, thanks for the help, I know what to do now
10:02:32 <shachaf> dmwit: Yes it dos.
10:02:39 <shachaf> exitWith ExitSuccess = throwIO ExitSuccess
10:02:59 <quchen> @src exitWith
10:02:59 <lambdabot> Source not found. I feel much better now.
10:03:16 <dmwit> Well, I'll be damned.
10:03:18 <Yuu-chan> When we hit Ctrl-C, how does the program react?
10:03:35 <jeetu> But exceptions from main should be passed to OS. Isn't it?
10:03:39 <shachaf> I think main gets an asynchronous exception?
10:03:45 <shachaf> the main thread, I mean.
10:03:55 <dmwit> Doesn't it depend on what mode your terminal is in?
10:04:09 <shachaf> Well, sure, if you're handling ^C yourself you handle it yourself.
10:04:20 <shachaf> If you get a SIGINT I think it'll turn into an exception, but I'm not sure.
10:04:29 <shachaf> But you can do whatever the normal thing you do for handling ^C is.
10:04:56 <monochrom> SIGINT => main thread gets AsyncException (type) UserInterrupt (value)
10:04:58 <|||tux||> exitWIth code @ (ExitFailure n) = n /= 0 = throwIO code
10:05:26 <monochrom> which key to cause SIGINT depends on terminal settings, but it's ctrl-c
10:05:46 <srhb> |||tux||: What?
10:06:00 <monochrom> no Haskell exception is passed to OS. ever
10:06:04 <dmwit> srhb: That's part of the actual source of exitWith.
10:06:12 <dmwit> with a few typos
10:06:13 <srhb> Isn't there a guard missing or something
10:06:26 <dmwit> exitWIth -> exitWith, and = n /= 0 = -> | n /= 0 =
10:06:36 <srhb> Right.
10:06:42 <|||tux||> and some special stuff for ghc (with ifdef)
10:07:03 <shachaf> darcs has "atexit"
10:07:21 <Yuu-chan> Thank you guys, I'll try to add an exception handler
10:07:31 <shachaf> Looks like it defines a global variable that collects IO actions and then does the same thing.
10:09:35 <parcs> what's the difference between Simple Lens and SimpleIndexedLens
10:09:39 <quchen> Yuu-chan: You have to use Control.Exception to handle it though. From the docs: As an ExitCode is not an IOError, exitWith bypasses the error handling in the IO monad and cannot be intercepted by catch from the Prelude. However it is a SomeException, and can be caught using the functions of Control.Exception.
10:10:05 <shachaf> quchen: catch is no longer in the Prelude as of GHC 7.6
10:10:10 <shachaf> So no problem there.
10:10:49 <parcs> never mind, the documentation is pretty good
10:11:24 <elliott> parcs: one of them is indexed
10:11:31 <shachaf> parcs: One of them is not indexed.
10:11:33 <elliott> indexed lenses are sort of useless
10:11:37 <elliott> you should look at the indexed traversal docs probably
10:11:45 <monochrom> except (pun!) we get the new problem that old code on hackage fails (pun!) to compile because Prelude.catch is missing :)
10:11:48 <quchen> shachaf: Good to know. However, the current platform is GHC 7.4.2, so I think many people still have that one.
10:13:25 <Yuu-chan> Thanks quchen. I use 7.4.2 indeed
10:14:18 <monochrom> "monochrom's concise guide to GHC 7.6 migration!"
10:14:43 <dmwit> I look forward to it!
10:15:16 <monochrom> "1. it is not enough to import CInt (the type name). it has to be CInt(CInt) or CInt(..) (the value ctor name). This is actually a Haskell 2010 rule. About time!"
10:15:49 <dmwit> Oh, that much is 7.4 migration.
10:15:51 <cmccann> monochrom, that one produces a rather nonobvious error message as well if memory serves me
10:16:04 <monochrom> "2. Prelude.catch and System.IO.Error.catch are gone. Perhaps use System.IO.Error.catchIOError"
10:16:12 <monochrom> "THE END"
10:16:24 <dmwit> monochrom: Ah, not the end, though.
10:16:27 <dmwit> There's more.
10:16:37 <monochrom> haha ok
10:16:51 <dmwit> GHC is stricter about what foreign declarations it will allow now -- and it doesn't say so in the release notes =(.
10:17:03 <monochrom> that was 1
10:17:07 <dmwit> For example, you can't leave off arguments you never plan on using.
10:17:10 <dmwit> Nope, not 1.
10:17:22 <dmwit> You can't write foo :: IO a if it's really foo :: Ptr Void -> IO a.
10:17:30 <dmwit> This bit me in gtk2hs.
10:17:44 <dmwit> We do that all the time, since we never use the user-data part of any callbacks.
10:17:46 <monochrom> that's strange
10:18:16 <shachaf> dmwit: Is that for foreign exports or foreign imports?
10:18:16 <dmwit> It's the spec. GHC was just relaxed about it before.
10:18:25 <dmwit> ...don't recall for sure
10:18:36 <shachaf> Either way, how does it know?
10:18:39 <shachaf> I must be misunderstanding.
10:18:49 <dmwit> Ah, yes, I said it wrong.
10:18:54 <monochrom> I was not bit because I was never lax to myself
10:19:21 <Taneb> I wonder if I'm the only person following the #haskell tag on Tumblr
10:19:37 <dmwit> ...is it worth looking up what the real problem was?
10:19:45 <dmwit> If so, I'll do it after lunch and get back to you...
10:19:47 <monochrom> if the C side is "int f(void *)", I would never, never dream of the haskell side being "IO CInt"
10:20:13 <dmwit> monochrom: What if the C side was int f(void *, window *)? Would you dream of Window -> IO CInt?
10:20:39 <monochrom> no. it's clearly logically Ptr Void -> Ptr Window -> IO Int
10:21:07 <dmwit> Hm. Well, I'll have to disagree with you.
10:21:16 <dmwit> The usual use for void* in C is completely subsumed by having real closures. =)
10:21:21 <monochrom> whether I use parameters is orthogonal to logical consistency
10:21:52 <dmwit> I guess the question is more "what should the API be?" than "what should the actual import look like?".
10:22:03 <dmwit> If the API exposed things you would never use, I'd judge that a bit odd.
10:22:09 <putau> hello
10:22:40 <monochrom> I play safe. you play fast and loose
10:23:02 <dmwit> ...
10:23:11 <nicoo> dmwit: I don't understand why you want your imports to be your API; trivial wrappers seem to be enough :o
10:23:20 <dmwit> nicoo: Yes, that is what gtk2hs does now.
10:23:35 <nicoo> 'k
10:23:39 <dmwit> Is it really so evil to hope that the compiler could do some trivial things for me?
10:23:46 <dmwit> I find the value judgments being made here quite surprising.
10:25:13 <hpc> nicoo: there's something to be said for an FFI wrapper package being as thin as humanly possible while still usable
10:25:14 <monochrom> I play safe: the rule says if I match up parameters faithfully, things are guaranteed to work. so I don't deviate from the rule. perhaps the parameters are spurrious. so?
10:25:22 * hackagebot void 0.5.11 - A Haskell 98 logically uninhabited data type  http://hackage.haskell.org/package/void-0.5.11 (EdwardKmett)
10:26:11 <parcs> is there a lens for fromIntegral or something
10:26:29 <edwardk> parcs: not currently. we're considering a prism for up-converting/down-converting
10:26:41 <monochrom> you play fast and loose: you do not match up parameters because you don't use some of them and omitting them happens to still work. but it's fragile. there are calling convention issues.
10:26:42 <nicoo> dmwit: I didn't say anything about whether it's good or not; I would say it's a regression not to keep this, but I will leave the debate to wiser heads :o
10:27:09 <edwardk> fromIntegral can change the value when you round trip through it
10:27:12 <edwardk> so you need to be careful
10:27:38 <monochrom> also, I did not say or imply evil
10:29:19 <parcs> edwardk: hmm, right
10:30:53 <zomg> Are there any common mistakes when writing parsec token stuff that would cause a simple parser for statements like if(foo) { bar } else { baz } start behaving weirdly if you instead have if(foo) { bar } else { baz } else { baz } ? (which obviously isn't valid due to two elses but the parser isn't failing)
10:31:13 <zomg> Just wondering if I'm going to need to pastebin the entire thing or not for anyone to be able to make heads or tails of it =)
10:31:28 <nicoo> zomg: Pastebin anyways
10:31:32 <zomg> (this is using buildExpressionParser)
10:31:40 <zomg> hehe okay =)
10:35:36 <monochrom> @tell dmwit I was talking about what should "foreign import blahblah" should do, not what the API should do
10:35:37 <lambdabot> Consider it noted.
10:41:43 <hpaste> anon pasted “android emulator” at http://hpaste.org/80381
10:43:37 <hpaste> anon pasted “android emulator” at http://hpaste.org/80382
10:46:19 <roconnor> @remember ky3 Indexed monads are just categories in the category of endofunctors, what's the problem?
10:46:19 <lambdabot> Done.
10:46:54 <dolio> Don't think that's correct.
10:48:03 <copumpkin> if it is, I'm sure xplat would like to hear about it
10:48:13 <copumpkin> but I think he looked into it and found that wasn't quite true
10:48:41 <dolio> It becomes pretty dubious when you do the least bit of investigation of it.
10:49:13 <monochrom> perhaps we @remember it for its incorrectness and derived haha value
10:49:18 <neutrino_> let epsilon > 0
10:49:31 <neutrino_> dolio: where is your god now
10:50:24 * hackagebot nats 0.1 - Haskell 98 natural numbers  http://hackage.haskell.org/package/nats-0.1 (EdwardKmett)
10:50:54 <shurikas> something new from edward
10:51:43 <monochrom> interesting, a series of "haskell 98 ____"
10:52:10 <neutrino_> can it be that the standard needs compatibility layers? that's unbelievable.
10:52:20 <monochrom> are we going to have "glasgow-exts 0.1 - Haskell 98 GHC extensions" too? :)
10:53:25 <edwardk> shurikas: splitting it from semigroups
10:53:40 <edwardk> it'll still be a dependency of semigroups for now, but it focuses the semigroups package better
10:53:42 <edwardk> its boring
10:54:08 <shurikas> pretty empty :)
10:54:21 <neutrino_> Zermelo SSSZ Lyf
10:54:36 <edwardk> its there because its needed as a dependency way down in a bunch of other boring stuff
10:54:59 <elliott> edwardk: all the nice package names taken eh
10:55:15 <edwardk> nats?
10:55:27 <edwardk> i was thinking naturals. but that was taken
10:55:33 <elliott> is nonempty splitting off too? :O
10:55:36 <edwardk> no
10:55:40 <edwardk> thats the canonical semigroup
10:55:49 <shachaf> gnats
10:56:05 <dolio> monochrom: Regardless of why it was remembered, what will probably happen is that I or someone else will have to correct it whenever it gets @quoted.
10:56:42 <monochrom> I see
11:00:24 * hackagebot semigroups 0.9 - Haskell 98 semigroups  http://hackage.haskell.org/package/semigroups-0.9 (EdwardKmett)
11:00:26 * hackagebot comonad 3.0.1.1 - Haskell 98 compatible comonads  http://hackage.haskell.org/package/comonad-3.0.1.1 (EdwardKmett)
11:01:02 <shachaf> Is it true that typechecking is guaranteed to terminate in a linear number of steps when you allow infinite types?
11:04:02 <shurikas> hmm
11:04:29 <shurikas> reading Semigroup source code... so this isn't the first time I see people are defining instances for (a, b) (a, b, c) (a, b, c, .., n)
11:04:50 <shurikas> isn't it possible to generate instances for tuples using TH?
11:04:59 <Eelis> sure is
11:05:03 <Eelis> or you can use something like multiplate
11:05:17 <shurikas> then why do people do that?
11:05:24 * hackagebot semigroupoids 3.0.0.2 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-3.0.0.2 (EdwardKmett)
11:05:36 <Eelis> shurikas: my guess is because it's more readable :)
11:05:38 <shachaf> It might have to do with TH being kind of awful.
11:05:45 <zomg> nicoo: sorry got a bit sidetracked, but figured it out. It was just because my main parser didn't actually parse until eof, so an invalid statement in the end would just get ignored
11:05:55 <shurikas> it may include two 'steps' for clarification
11:05:59 <shurikas> and the rest may be TH
11:06:04 <shurikas> that would be totally readable
11:06:15 <shurikas> like, why the hell would you care for definitions of (,,,,)
11:06:27 <shurikas> as long as you know it behaves the same as for (,)
11:06:59 <shachaf> shurikas: If you want to write a patch that makes that code nicer with TH, edwardk might accept it.
11:07:04 <shachaf> Probably not, though, because TH isn't Haskell 98.
11:07:06 <shurikas> ;
11:07:08 <shurikas> :D
11:07:10 <dolio> shachaf: Linear in what?
11:07:13 <shurikas> oh, that's another reason
11:07:35 <dolio> Type chcking Hindley-Milner in the usual way isn't linear.
11:07:48 <shurikas> also TH isn't really THAT awful
11:08:01 <shurikas> it just contains a bunch of obscure names for things
11:08:05 <nicoo> zomg: Ok :)
11:08:10 <elliott> th really is that awful
11:08:23 <shachaf> dolio: Yes, but does it change if you allow infinite types?
11:09:15 <dolio> I'm not sure how it would, because the usual double-exponential example isn't infinite.
11:09:37 <shachaf> I was looking at http://www.haskell.org/pipermail/haskell-cafe/2006-December/020072.html
11:09:41 <dolio> Unless your infinite types are just collections of equations.
11:10:31 <shachaf> What's the usual double-exponential example?
11:10:55 <dolio> f0 x = (x,x) ; f1 = f0 . f0 ; f2 = f1 . f1 ; f3 = f2 . f2 ; ...
11:14:16 <dolio> You can get GHC to check that in linear time by inventing an alias for each of the return types in the same manner as the functions are defined.
11:14:25 <dolio> But it relies on no expansion of those aliases.
11:15:02 <dolio> R0 a = (a, a) ; R1 a = R0 (R0 a) ; R2 a = R1 (R1 a) ; ...
11:15:24 * hackagebot semigroupoids 3.0.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-3.0.1 (EdwardKmett)
11:16:13 <dolio> But I don't see how that would happen automatically if the type system has fix as its only extension for infinite types.
11:16:24 <dolio> You could ask sorear now, though. He's in #haskell-blah.
11:18:55 <epta> Is there a way to tell `ghc-pkg check' do not check package haddocks? http://hpaste.org/80383
11:23:01 <Lethalman> :t T.splitOn
11:23:02 <lambdabot> Couldn't find qualified module.
11:23:10 <Lethalman> :t Data.Text.splitOn
11:23:11 <lambdabot> Data.Text.Internal.Text -> Data.Text.Internal.Text -> [Data.Text.Internal.Text]
11:23:25 <Lethalman> oh
11:23:33 <sm> I get that ghc-pkg warning too, what is that
11:23:46 <Lethalman> this is different on my ghci
11:23:52 <Lethalman> is it because Data.Text has something unsafe?
11:24:11 <epta> sm: this is missing haddocks of some packages
11:25:25 * hackagebot bifunctors 3.0.3 - Haskell 98 bifunctors  http://hackage.haskell.org/package/bifunctors-3.0.3 (EdwardKmett)
11:26:49 <byorgey> Lethalman: different how?
11:27:02 <Lethalman> Data.Text.splitOn :: Text -> Text -> [Text]
11:27:06 <Lethalman> what's that Internal?
11:27:30 <shachaf> It's the same as Data.Text.Text
11:27:36 <Lethalman> ok
11:29:28 <mzero> how come I never knew about Data.Foldable's   mapM_  before? it rocks when used with a Maybe!
11:30:12 <copumpkin> mzero: it was a conspiracy to hide the juicy bits from you
11:30:26 <mzero> :-)
11:30:34 <copumpkin> :)
11:31:00 <shachaf> mzero: See also traverse_ and for_
11:31:17 <byorgey> mzero: you mean like  mapM_ :: Monad m => (a -> m b) -> Maybe a -> m ()  ?
11:31:25 <shachaf> If you use lens, you can traverse arbitrary structures this way!
11:31:44 <shachaf> Actually you can do that without lens too in this case.
11:31:57 <mzero> byorgey: yes!  never do I need to write       maybe (return ()) (( >> return ()) . f)     again
11:32:16 <mzero> I do not use lens
11:32:27 <shachaf> @ty (Data.Foldable.traverse_ . Data.Foldable.traverse_) print :: Show a => [Maybe a] -> IO ()
11:32:28 <lambdabot> Show a => [Maybe a] -> IO ()
11:32:58 <shachaf> Uh oh, mzero is on the other side of the iron curtain.
11:33:29 <mzero> I suppose I am
11:33:41 <byorgey> you can use lens and not even know it
11:33:51 <byorgey> because you can use lens without actually importing it ;)
11:33:57 <edwardk> byorgey: hah
11:34:08 <shachaf> There is no escape.
11:34:26 <byorgey> edwardk: finally got around to watching the video of your lens talk from NY this past week.
11:34:29 <mzero> I don't object to the code of lens being compiled in.... I just don't want its choice of operator and function names to invade my namespace
11:34:34 <edwardk> byorgey: what did you think?
11:34:39 <byorgey> edwardk: it finally all clicked the second time. =D
11:34:43 <edwardk> =)
11:34:43 <byorgey> awesome stuff.
11:34:57 <shachaf> mzero: Function names like "view" and "set" are the issue?
11:35:01 <mzero> I do think the ideas are delightful..... just not the names
11:35:21 <edwardk> mzero: 3.8 adds Control.Lens.Operators so you can import the main Control.Lens qualified if you are in the Peaker camp ;)
11:35:25 <mzero> and all those operators
11:35:33 <shachaf> You don't have to use the operators.
11:35:37 <shachaf> I don't, half the time.
11:35:41 <mzero> They invade my name space
11:35:42 <edwardk> mzero: the operators for the most part follow a consistent schema
11:35:56 <edwardk> but i can't please everyone
11:35:58 <applicative> sm epta ghc-pkg check --simple-output
11:36:02 <mzero> and I dont' think many of them should be there
11:36:03 <edwardk> so i choose to please myself in this regard
11:36:06 <applicative> kinda lame
11:36:40 <mzero> true that - as they say, it's what makes horse racing interesting
11:36:54 <applicative> the operators conflict with your namespace?
11:37:01 <elliott> import qualified Control.Lens as Lens
11:37:03 <elliott> problem solved
11:37:33 * applicative hasn't felt the need for <?=
11:37:37 <thoughtpolice> edwardk: i wish & had made it as flip ($), i end up using that one a lot
11:37:46 <mzero> the operators conflict with my brain space!
11:38:03 <edwardk> thoughtpolice: yeah losing that battle was perhaps inevitable. lens hadn't found its way into enough people's hearts yet ;)
11:38:11 <shachaf> thoughtpolice: Just import lens.
11:38:51 <thoughtpolice> shachaf: yes, luckily i won't have to live without it anyway
11:39:58 <shachaf> @ty preview (traverse._right) :: [Either a b] -> Maybe b -- find the value in the first Right in the list, if any.
11:39:59 <lambdabot> [Either a b] -> Maybe b
11:40:25 * hackagebot charset 0.3.3 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.3 (EdwardKmett)
11:40:27 * hackagebot charset 0.3.4 - Fast unicode character sets based on complemented PATRICIA tries  http://hackage.haskell.org/package/charset-0.3.4 (EdwardKmett)
11:40:39 <shachaf> Just being able to do things like that is nice, operators or not.
11:41:00 <shachaf> 0.3.3 *and* 0.3.4? We are truly blessed.
11:41:04 <shachaf> (Why is PATRICIA capitalized?)
11:41:11 <edwardk> shachaf: i decided to do more work on it
11:41:12 <c_wraith> it's an acronym
11:41:23 <edwardk> its an acronym
11:41:38 <edwardk> "Practical Algorithm to Retrieve Information Coded in Alphanumeric"
11:42:04 <shachaf> Oh, I thought I'd read that it was named after a person.
11:42:05 <shachaf> Perhaps not.
11:42:26 <shachaf> There's nothing alphanumeric about it, though.
11:42:30 <c_wraith> I think it's named after the inventor's daughter - but he made it an acronym
11:42:39 <edwardk> sure
11:42:46 <edwardk> its a crappy acronym
11:43:22 <epta> What should I do to get available haddocks here http://hackage.haskell.org/package/data-memocombinators-0.4.4 ?
11:43:31 <epta> How could I ask Ross to regenerate them?
11:43:41 <epta> Is he available here?
11:43:48 <shachaf> epta: You could click on 0.4.3 to see the 0.4.3 haddocks.
11:43:53 <shachaf> There was a build failure for 0.4.4, so they're not there.
11:44:01 <shachaf> Would that be different now?
11:44:48 <applicative> > [Left 1,Right "hello",Right "goodbye"] ^? traverse._right
11:44:50 <lambdabot>   Just "hello"
11:44:57 <epta> shachaf: yes, version of data-inttrie is different and it is seems to be buildable now
11:45:16 * applicative looked up 'preview' only to find it means (^?)
11:45:48 * applicative hates these alphanumeric expressions
11:46:16 <shachaf> > lastOf (traverse._right) [Left 1,Right "hello",Right "goodbye", Left 4, Right "hmm", Left 8]
11:46:18 <lambdabot>   Just "hmm"
11:47:08 <absence> are lenses required to make this more palatable, or are there simpler tricks? push fc@FlatConfig { fcStack = u } r = fc { fcStack = (r:u) }
11:47:08 <shachaf> Unfortunately GHC generates bad code for that. :-9
11:47:43 <edwardk> absence: that sort of thing is why lenses were invented
11:47:45 <shachaf> absence: Well, this was the original sort of problem lenses were designed to solve. :-)
11:47:57 <shachaf> You can define your own SECy thing if you just want to abstract modification.
11:48:29 <shachaf> overFcStack f fc@FlatConfig { fcStack = u } = fc { fcStack = f u }
11:48:38 <shachaf> Then you can use that in a bunch of different places and compose it and so on.
11:48:41 <shachaf> ...Or you could just use lenses.
11:49:35 <absence> ah, i had a gut feeling this was a lensy problem :) thanks
11:50:12 <shachaf> With lens you might write this as "push fc r = over fcStack (r:) fc"
11:50:24 <shachaf> epta: By the way data-memocombinators should totally use invariant.
11:50:33 <shachaf> Since wrap is just an invariant functor map.
11:50:57 <craigInnes> Hi, I was wondering if someone could help: I have been using the System.Plugins library to programatically compile haskell files using the methods in System.Plugins.Make and System.Plugins.Load. Is there a similar method for compiling and loading a haskell source which arrives as text from a text box instead of from a .hs file?
11:50:58 <absence> shachaf: overFCStack basically amounts to implementing a specific lens without benefits from a general lens module right?
11:51:11 <shachaf> absence: It's something more specialized than a lens.
11:51:12 <edwardk> absence: worse, its not even a full lens
11:51:19 <shachaf> absence: It lets you set/modify but not read.
11:52:13 <edwardk> _fcStack f fc@FlatConfig { fcStack = u } = (\u' -> fc { fcStack = u' }) <$> (f u)     -- would be the lens
11:52:18 <shachaf> a "lens"-style lens would look like this: _fcStack f fc@FlatConfig { fcStack = u } = (\u' -> fc { fcStack = u' }) <$> f u
11:52:26 <shachaf> Curses.
11:52:49 <shachaf> Well, at least my version doesn't have redundant parentheses!
11:52:50 <edwardk> shachaf's correctly avoids the accidental parens i put on the end
11:52:51 <edwardk> yeah
11:53:05 <edwardk> i was refactoring it from <&> and left them in ;)
11:53:10 <epta> shachaf: maybe it is, I'm not a maintainer, sorry. All I wan't is to rebuild last version to having haddocks in 0.4.4 version on hackage
11:53:32 <shachaf> Maybe Hackage 2 will let people do that. :-)
11:53:33 <luite> craigInnes: you can compile some buffer without a file with the GHC API directly, not with hint, and probably not with plugins
11:55:18 <craigInnes> luite: does the GHC have a catch all method for compiling a result from a buffer? Or is it a case of calling several functions in tandem? I have raked around the Ghc api before but found it rather confusing to navigate
11:55:31 <shachaf> Peaker: Oh, I have OpenGL sort of working.
11:55:32 <absence> edwardk / shachaf: so to read f = id?
11:55:50 <shachaf> absence: No, it's a bit more complicated than that.
11:55:59 <shachaf> You have to pick the right functor. In this case the functor is Const.
11:56:03 <shachaf> (Const r)
11:56:10 <shachaf> But lens has a function "view" for this purpose.
11:56:19 <shachaf> view _fcStack = fcStack
11:57:20 <absence> shachaf: gotcha :) guess i'll play with one of the lens libraries, it's about time to learn it
11:59:21 <hpaste> osa1 pasted “bugbugbugbugbug” at http://hpaste.org/80385
11:59:30 <osa1> whoa! is this for real http://hpaste.org/80385 ?
11:59:45 <shachaf> osa1: What's your code?
11:59:51 <shachaf> I think this is fixed in HEAD, if it's the bug I think it is.
11:59:56 <byorgey> edwardk: does 'lens' give any nice ways for doing 'zippy' sorts of operations?  e.g. replace each element of a list with the difference between it and the next element (leaving the last element alone)
12:00:11 <shachaf> byorgey: You can use mapAccumL or something like that for that.
12:00:14 <edwardk> byorgey: thats one thing we don't do well
12:00:37 <shachaf> osa1: I would guess that you have some code like "f a -> t f" or something.
12:00:46 <osa1> shachaf: well it's a bit messy but here you go: http://hpaste.org/80386
12:00:52 <byorgey> oh, wow, I didn't know there was a mapAccumL in Data.Traversable
12:00:59 <alanz> craigInnes: You need to call several functions in GHC  API to compile
12:01:18 <byorgey> edwardk: I mean, it sounds pretty tricky so I didn't really have my hopes set too high =)
12:01:21 <shachaf> byorgey: Well, I meant mapAccumLOf, for the general lens case. :-)
12:01:27 <byorgey> o
12:01:28 <byorgey> ok
12:01:58 <byorgey> yes, I figured there would be a generic lens equivalent
12:02:02 <edwardk> byorgey: in theory you can zip easily with Control.Lens/Representable
12:02:03 <osa1> so should I report this ?
12:02:22 <edwardk> but thats being sucked into a separate package in 3.8
12:02:46 <shachaf> osa1: I suspect it's fixed in HEAD.
12:02:59 <shachaf> If you track it down a bit I can try it in HEAD GHC for you.
12:05:27 * hackagebot reducers 3.0.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.0.1 (EdwardKmett)
12:06:27 <shachaf> OK, I narrowed it down for you.
12:06:41 <applicative> osa1: http://hackage.haskell.org/trac/ghc/ticket/7368 ?
12:07:02 <refried_> What's a good way to decide between:   s -> s    vs.   State s ()  ?
12:07:19 <refried_> I have a mix of both, which I don't really like either
12:07:20 <shachaf> foo :: f a; foo = lift undefined undefined
12:07:30 <shachaf> refried_: Don't forget the third possibility, Endo s. :-)
12:08:12 <refried_> shachaf: ack, I don't even know that one? :-)
12:08:33 <refried_> Endomorphism must mean type to itself huh
12:08:52 <refried_> Yeah, ok, so how does one choose?
12:09:12 <shachaf> osa1: It's fixed in HEAD
12:09:24 <shachaf> refried_: One chooses based on the context.
12:09:36 <osa1> great
12:09:42 <refried_> shachaf How does one choose based on the context? :-)
12:10:20 <refried_> or are there some example contexts you could point me to?  or, an you think of situations where you'd personally choose one over the other (or the other over it)
12:10:23 <simon> @pl \x -> [x]
12:10:23 <lambdabot> return
12:10:26 <refried_> *can
12:10:59 <shachaf> refried_: State s a is good if you actually have values to return sometimes.
12:11:07 <shachaf> If a is always (), there's less of a point.
12:13:10 <refried_> *nod*  I've got a bunch of state changes which sometimes result in a reward.  So it's either State s Double,  or State s () for changes where reward doesn't really enter into it.  and then i was just summing up the rewards in the return
12:13:18 <refried_> Mostly ()
12:13:33 <refried_> but then I realized I could also use Writer Double s ?
12:13:41 <refried_> which, heh.
12:13:54 <shachaf> Double isn't a monoid.
12:13:59 <byorgey> refried_: presumably you want  Writer (Sum Double) s
12:14:05 <shachaf> You can use Writer (Endo Double) (), though. :)
12:14:13 <shachaf> s/:/:-/
12:14:14 <shachaf> Or that.
12:14:23 <refried_> Yeah Sum Double
12:15:01 <refried_> byorgey:  then I started wondering how I would handle logging some strings while doing that — do people ever have writers layered on top of writers?  I don't actually need to, just curious
12:15:28 * hackagebot comonad-transformers 3.0.1 - Comonad transformers  http://hackage.haskell.org/package/comonad-transformers-3.0.1 (EdwardKmett)
12:15:34 <byorgey> refried_: you can do that, though it's annoying because you need a way to disambiguate calls to 'tell' by adding explicit calls to 'lift'
12:15:51 <refried_> byorgey: I figured it would be annoying… ;-)
12:15:59 <byorgey> refried_: you could also use  Writer (Sum Double, [String])
12:16:04 <refried_> Ah
12:16:06 <byorgey> though that comes with its own annoyances
12:16:09 <refried_> yeah
12:16:15 <shachaf> Uh oh, byorgey is in monoid mode now.
12:16:19 <skp> hey!
12:16:20 <byorgey> hehehe
12:16:24 <refried_> Oh yeah, I also considered State (s, Double) ()
12:16:30 <refried_> but it came with its own annoyances too
12:16:33 <skp> I’ve written this: https://gist.github.com/4469853
12:16:47 <skp> now, I wonder if I can use MaybeT here
12:16:49 <skp> or not
12:16:51 <simpson> refried_: At risk of overcomplicating things, RWS is a thing as well.
12:17:06 <skp> I don’t really get what monad transformers really are
12:17:14 <refried_> simpson: *nod* well, I'm really mostly working around State, I think
12:17:15 <skp> and what they’re for
12:17:21 <skp> thanks in advance
12:17:36 <byorgey> skp: yes, you can
12:17:53 <byorgey> skp: monad transformers are for combining the effects of several monads into one
12:18:05 <refried_> Deciding between State (s,Double) () and State s Double was interesting;  I mostly went with the latter because I couldn't immediately figure how to interact nicely with the former
12:18:17 <refried_> s/nicely/neatly/
12:18:28 <skp> byorgey: ok
12:18:28 <skp> then
12:18:29 <skp> here
12:18:48 <skp> since the IO monad *can* fail
12:18:51 <skp> well
12:18:58 <skp> *might* fail
12:19:04 <skp> I can stack a MaybeT on it ?
12:19:16 <simpson> :t do { _1 .= "Hi there!" ; _2 += 4.2 }
12:19:17 <lambdabot> (Fractional a1, MonadState s m, Field2 s s a1 a1, Field1 s s a [Char]) => m ()
12:19:17 <skp> MaybeT IO ([Flag],[String]) ?
12:19:19 <byorgey> you can stack a MaybeT on it, period
12:19:28 <byorgey> it has nothing to do with whether the IO monad can fail
12:19:39 <byorgey> yes
12:19:46 <refried_> Now I kinda wish I'd done State (s,Double) () instead
12:20:22 <byorgey> skp: I left a comment on the gist showing how it would work to use MaybeT
12:20:38 <skp> thanks!
12:20:57 <skp> gosh !
12:20:59 <skp> so nice !
12:21:05 <skp> mt are just nice!
12:21:58 <skp> byorgey: btw
12:22:01 <skp> why mempty ?
12:22:10 <skp> it’s for Monoid
12:23:28 <byorgey> skp: what? I wrote mzero
12:23:44 <byorgey> @type mzero
12:23:45 <lambdabot> MonadPlus m => m a
12:24:02 <byorgey> skp: mzero is a method of MonadPlus, which is the type class for monads which have choice + failure
12:24:08 <byorgey> mzero indicates a failure
12:24:24 <shachaf> mzero: (This is your cue.)
12:24:32 <skp> I see
12:24:34 <skp> and hm
12:24:43 <skp> MaybeT IO a
12:24:43 <byorgey> there is a connection, in essence MonadPlus is for monads with a monoidal structure
12:24:54 <skp> yes
12:25:00 <byorgey> but we can't reuse the type class because the kinds don't match =P
12:25:05 <skp> I always wonder why it’s simply not an instance of Monoid
12:25:22 <byorgey> because of the kinds.
12:25:26 <skp> (some one argues it’s a matter of kinds)
12:25:28 * hackagebot comonads-fd 3.0.1 - Comonad transformers using functional dependencies  http://hackage.haskell.org/package/comonads-fd-3.0.1 (EdwardKmett)
12:25:29 <skp> yeah
12:25:31 <skp> that’s it :D
12:25:45 <byorgey> but you're right, it "should" be an instance of Monoid
12:27:00 <skp> I soo
12:27:02 <skp> see*
12:27:04 <skp> so here
12:27:08 <skp> you return the a type
12:27:19 <skp> but hm
12:27:31 <skp> how that type is injected in the MaybeT ?
12:29:47 <byorgey> skp: in this case   return :: a -> MaybeT IO a
12:29:56 <byorgey> MaybeT IO   is an instance of Monad
12:30:03 <skp> yeah
12:30:06 <skp> just forgot that
12:30:07 <skp> then
12:30:15 <skp> how should I use my function ?
12:30:20 <skp> runMaybeT on it ?
12:30:26 <byorgey> skp: you can combine it with other MaybeT IO things of course
12:30:39 <byorgey> and then yes, you can use  runMaybeT  to turn it back into  IO (Maybe ...)
12:31:13 <skp> I see
12:39:40 <hpaste> Hrumph pasted “My fourth haskell program. Critique this” at http://hpaste.org/80389
12:40:28 * hackagebot comonad-extras 3.0.1 - Comonad transformers requiring extensions to Haskell 98  http://hackage.haskell.org/package/comonad-extras-3.0.1 (EdwardKmett)
12:40:30 * hackagebot keys 3.0.2 - Keyed functors and containers  http://hackage.haskell.org/package/keys-3.0.2 (EdwardKmett)
12:40:54 <zomg> hrumph: I like your error messages
12:43:49 <refried_> Ah ok, see… because I've got some functions that are s -> s, some that are s -> r, and some that are s -> (s,r)
12:44:13 <refried_> where r is a monoid
12:45:10 <mzero> (late to the game) It's true... I *do* indicate failure.... I also indicate the lack of options.... the intentional no result.... the end of the line.... hopelessnesss... dispair... and ultimately oblivion....
12:45:10 <refried_> and that's why I was on the fence on when/whether to compose them as State s ()   vs.   State (s,r) ()  vs.   State s r   vs.  Writer r s
12:45:17 <luite> craigInnes: it's more complicated than a single function call
12:45:19 <mzero> ... on the bright side, I'm fun at party games!
12:45:29 <refried_> *headasplode*
12:45:58 <luite> craigInnes: there are a few examples on the wiki how to use it, the key is setTargets where each Target can contain a StringBuffer with the contents
12:46:16 <alanz> luite: he seems to have disappeared
12:46:51 <luite> alanz: maybe he reads it later :)
12:47:40 <byorgey> mzero: =)
12:48:30 <mzero> is anyone working on hrumph's paste, or shall I have a go?
12:49:03 <absence> what's the difference between data-lens and lenses?
12:49:52 <edwardk> absence: data-lens and lenses are both obsolete. 'lens' is the package you want ;)
12:50:22 <absence> doh ;)
12:50:26 <absence> thanks
12:50:37 <edwardk> lens.github.com has a tutorial. https://www.youtube.com/watch?v=cefnmjtAolY&hd=1 has a 2 hour video describing how it works
12:50:47 <srhb> O_o
12:52:13 <srhb> Brilliant. How did I miss that during Christmas.
12:52:24 <absence> awesome
12:52:30 <hrumph> i won't keep spamming the  channel with my illustrious self conceived excercises after this
12:52:51 <hrumph> this is like the final wrap after doing different things
12:54:12 <osa1> is there a prefix form of =<< function ? (I'm note looking for  (=<<) )
12:54:26 <hrumph> its basically an outline for a trivial parser parsing columnar data and making sure that no two rows have identical key fields at the end
12:54:51 <hrumph> each field can have a list of validator functions supplied
12:55:25 <Lethalman> osa1, maybe you can ask hoogle
12:55:29 * hackagebot kan-extensions 3.1.1 - Kan extensions, the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-3.1.1 (EdwardKmett)
12:55:51 <srhb> What does "prefix form" mean?
12:56:04 <srhb>  (=<<?) ?
12:56:07 <srhb> Woops
12:56:10 <osa1> @hoogle Monad m => (a -> m b) -> m a -> m b
12:56:10 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
12:56:11 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
12:56:11 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
12:56:11 <srhb>  (=<<) ?
12:56:34 <srhb> I don't know what it means otherwise.
12:56:44 <Lethalman> srhb, yes he said that
12:56:51 <craigInnes> luite: Sorry, was afk, but I will check out the wiki and let you know how I get on. Thanks :)
12:57:14 <srhb> myPrefixBackwardsBind = (=<<) ?
12:58:12 <mzero> hrumph: I'm doing a full work over of the paste - expect detailed comments in about 15 min.
12:58:20 <hrumph> ok i'll be ready
12:59:06 <quchen> srhb: Infix form: a `foo` b. Prefix form: foo a b.
13:00:09 <srhb> quchen: Right, exactly, so I don't understand the question when (=<<) is not the answer.
13:00:15 <absence> edwardk: wow. so basically "over _fcStack (r:)" replaces that hideous monstrosity of mine? :D
13:00:52 <shachaf> absence: Yep. Or (_fcStack %~ (r:))
13:01:03 <shachaf> Or you can just call the lens fcStack instead.
13:01:29 <quchen> srhb: What was the question? I can't find it in the immediate logs
13:01:32 <absence> shachaf: nice nice
13:02:05 <absence> shachaf: and the getter of the record _fcStack then? or is there some other convention?
13:02:08 <quchen> Whether (=<<) is the prefix form of =<<? If so, then yes.
13:02:17 <shachaf> absence: That's a common convention.
13:02:39 <shachaf> absence: If you call the selector _fcStack, makeLenses ''TypeName will automatically generate fcStack for you.
13:02:46 <edwardk> absence: you would typically define your record with the field names _fcStack      and then you'd use makeLenses ''FC    and that would make all the fcStack lenses for you
13:02:49 <shachaf> (Of course you can change the convention that it uses.)
13:02:51 <edwardk> then its
13:03:00 <yepyep> is there a function almost like the opposite of intersperse?  I.e. remove every other list element?
13:03:02 <edwardk> fcStack %~ (r:)
13:03:45 <quchen> yepyep: Data.Split may be suitable for that
13:04:07 <edwardk> > elements odd ["hello","to","you"]
13:04:08 <lambdabot>   Couldn't match expected type `a0 -> f0 a0' with actual type `[t0]'
13:04:17 <edwardk> > ["hello","to","you"]^..elements odd
13:04:19 <lambdabot>   ["to"]
13:04:23 <quchen> yepyep: Sorry, it's Data.List.Split
13:04:24 <edwardk> > ["hello","to","you"]^..elements even
13:04:25 <lambdabot>   ["hello","you"]
13:04:45 <yepyep> Thanks guys
13:05:01 <epta> #> grep --perl-regexp --only-matching "(?<=IUSE=\").*(?=\")" `equery which ghc-paths`
13:05:12 <shachaf> What's the new name of iwhereOf?
13:05:20 <elliott> it doesn't have one
13:05:20 <Lethalman> :t (^..)
13:05:22 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
13:05:31 <Lethalman> \o/
13:05:34 * hackagebot pretty-show 1.5 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.5 (IavorDiatchki)
13:05:43 <quchen> > splitOn "x" "axbxc"
13:05:45 <lambdabot>   ["a","b","c"]
13:05:51 <shachaf> elliott: Why not?
13:06:11 <elliott> edwardk killed it
13:06:20 <yepyep> quchen, I just need it for even numbered elements in a list.
13:06:24 <shachaf> I thought it was good?
13:06:27 <shachaf> What happened?
13:06:30 <elliott> it's elements now
13:06:31 <elliott> :t elements
13:06:32 <lambdabot> (Applicative f, Traversable t, Indexable Int k) => (Int -> Bool) -> k (a -> f a) (t a -> f (t a))
13:06:38 <shachaf> elements is Int
13:06:40 <elliott> except it got generalised?
13:06:41 <elliott> or something
13:06:44 <absence> edwardk, shachaf: works great, thanks!
13:06:47 <elliott> oh maybe I'm thinking of another name
13:07:01 <yepyep> I'm trying to extract data from a xml table that really should have been put in separate tags with hxt
13:07:11 <edwardk> shachaf: iwhere became magic in 3.8 it composes
13:07:13 <quchen> yepyep: so you want to drop even-indexed elements?
13:07:31 <shachaf> Magic?
13:07:41 <edwardk> oh we renamed it too
13:07:51 <yepyep> quchen: correct.  I know the field labeling scheme, so I just need to extract the data for each field of a <td>
13:08:04 <yepyep> *even <td> field rather
13:08:10 <edwardk> index :: (Eq i, Applicative f, Indexable i p) => i -> Overloading' p (Indexed i) f a a
13:08:12 <quchen> yepyep: So an example of your data would be "1,2,3,4,5,4,3,2,1"?
13:08:55 <yepyep> no it would be like <td>station</td> <td>stationName</td>
13:09:37 <edwardk> then     indices :: (Applicative f, Indexable i p) => (i -> Bool) -> Overloading' p (Indexed i) f a a   plays the role of iwhereOf but you just compose it rather than pass it a lens
13:09:51 <quchen> yepyep: Ah, I see. I would use Parsec for that, but if what you want really is splitting then the split package is the way to go.
13:09:52 <yepyep> I'm extracting all tds, and so i only need the tds corresponding to actual data entries, not the data labels
13:09:57 <quchen> > splitOn "," . intercalate "," $ ["hello", "world"]
13:09:59 <lambdabot>   ["hello","world"]
13:10:36 <Boreeas> > splitOn "," $ intercalate "," $ ["hello", "world"]
13:10:38 <lambdabot>   ["hello","world"]
13:11:14 <nyc> intercalate?
13:11:25 <quchen> > intercalate "," "hello world"
13:11:26 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:11:26 <lambdabot>              with actual ty...
13:11:40 <quchen> > intercalate "," $ ["hello", "world"]
13:11:41 <lambdabot>   "hello,world"
13:11:59 <Lethalman> > intercalate ',' "hello world"
13:12:00 <lambdabot>   Couldn't match expected type `[a0]'
13:12:00 <lambdabot>              with actual type `GHC.Type...
13:12:00 <quchen> It's basically intersperse that inserts a whole string instead of a char between each element
13:12:02 <yepyep> quchen: I'm already using hxt to parse the xml trees.  It might be a little naive to use list splitting, but it'll work
13:12:19 <quchen> > intercalate "," $ ["hello", "world"]
13:12:20 <lambdabot>   "hello,world"
13:12:28 <quchen> > intersperse ',' $ ["hello", "world"]
13:12:29 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:12:29 <lambdabot>              with actual type...
13:12:36 <quchen> > intersperse ',' $ "hello"
13:12:37 <lambdabot>   "h,e,l,l,o"
13:13:28 * lolcathost wonders why $.
13:13:41 <quchen> Because copy+paste
13:13:43 <lolcathost> > intersperse ',' "ohai"
13:13:44 <lambdabot>   "o,h,a,i"
13:13:50 <lolcathost> quchen: Ah!
13:13:52 <HugoDaniel> copy$paste
13:14:39 <quchen> @src intercalate
13:14:39 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
13:14:44 <quchen> :-)
13:16:12 <lolcathost> > intercalate "," ["ohai", "hello"]
13:16:14 <lambdabot>   "ohai,hello"
13:16:21 <quchen> yepyep: Using split here is a bit hacky though.
13:16:42 <yepyep> what would be a more idiomatic approach?
13:16:59 <quchen> A more robust way would be parsing the table to, well, a Haskell table format I think
13:17:12 <quchen> As in <table>...</table> -> [[String]]
13:17:51 <yepyep> ah
13:17:56 <quchen> Or whatever 2D table representation you want in Haskell, (Vector (Vector String)) etc
13:18:00 <quchen> And then slice that
13:18:13 <yepyep> right
13:18:19 <quchen> The problem with split is that it relies on the integrity off the data in a certain form
13:18:34 <quchen> Suppose you have </td><td> and </td> <td>
13:18:42 <quchen> Then split fails and your data's corrupt
13:19:31 <quchen> You can work around that specific issue with splitOneOf
13:19:33 <quchen> > splitOneOf ";.," "foo,bar;baz.glurk"
13:19:35 <lambdabot>   ["foo","bar","baz","glurk"]
13:19:44 <yepyep> since it's only a two column table, what about using &&& from hxt and taking snd from the table?
13:20:26 <quchen> You mean parse the table to [(String, String)]?
13:20:30 <yepyep> yes
13:20:35 * hackagebot wl-pprint-extras 3.3 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.3 (EdwardKmett)
13:20:46 <quchen> If you can be sure about that data format then that would be a very easy representation of the table that's certainly nice to work with
13:21:17 <quchen> Just don't forget to account for weird-but-correct data and rubbish data
13:22:19 <quchen> I haven't used hxt myself, but maybe you can even make the parser throw away the first column altogether
13:22:22 <thoughtpolice> edwardk: Q. if i have an Algebra f a and Coalgebra f b, then where we can characterize a generic fold by the type 'Functor f => Algebra f a -> Mu f -> a', we can also characterize a generic unfold by 'Functor f => Coalgebra f b -> b -> Mu f' right?
13:22:47 <thoughtpolice> i sort of derived the Coalgebraic definition myself from 'Coalgebra f b = b -> f b', but i did it a week or so ago so i'm a little fuzzy :P
13:23:05 <thoughtpolice> and i wanted to make sure it's correct
13:23:16 <hpaste> bwa pasted “coops-historiccurrents.kml” at http://hpaste.org/80390
13:23:58 <yepyep> ^kml file, if it gives you any better idea about the formatting of the data
13:24:18 <thoughtpolice> edwardk: i also have similar rules for build/unbuild for optimization, and i think of my definition of unfold in terms of Coalgebra is correct, then both of the build/unbuilding rules are correct
13:24:20 <yepyep> PS: I didn't generate it :)
13:26:02 <epta> mzero: are you gonna post comments on Hrumph paste as annotation?
13:26:11 <mzero> yeah - I'm taking longer
13:26:16 <mzero> doing the whole thing - sorry
13:26:25 <mzero> almost there...
13:26:45 <quchen> yepyep: Uuuuugh
13:26:57 <hrumph> mzero: no problem. thanks a lot btw
13:26:57 <quchen> yepyep: XML at its best ;-)
13:27:16 <hrumph> after this i'm going to have another crack at learning yesod
13:28:02 <yepyep> quchen: it was even better before i cleaned it up with some regexs
13:28:53 <yepyep> the tables, tds, etc. were enclosed with &gt; and &lt; elements for starters
13:29:33 <quchen> Well, if all you want is doing stuff with that file split will do.
13:29:52 <quchen> It'll be harder to maintain the code in case the file format changes and you want to parse the entire format, not just a single file obeying it.
13:31:20 <yepyep> luckily this is for a single website and it should more or less obey the same format
13:32:00 <yepyep> Ok, well thanks again.
13:34:11 <yepyep> By the way, I am curious, what is the Haskell community's standard on TMTOWTDI?
13:35:04 <yepyep> It seems, as one example, that there are quite a few ways to generate a list: (i.e. monads, arrows, list comprehensions, etc)
13:35:37 <quchen> TMLOMAWTDT - There's most likely one most awesome way to do things
13:36:18 <yepyep> ok, but that is often not very obvious to a newbie like myself.
13:36:28 <quchen> I think often it's more about readability in many cases.
13:37:03 <chreekat> yepyep: Definitely, it takes some time. Lists in particular have a zillion ways of doing things because they're so often used pedagogically a zillion different ways
13:37:13 <absence> shachaf: is there a less parenthesis heavy way to compose lenses? ((fcStack .~ [r]) . (fcTrans %~ (. t')))
13:37:13 <chreekat> zillion zillions, wow
13:37:44 <edwardk> absence \x & fcStack .~ [r] & fcTrans %~ (.t')
13:37:47 <shachaf> absence: \foo -> foo & fcStack .~ [r] & fcTrans %~ (. t')
13:37:57 <edwardk> er what shachaf said
13:38:04 <shachaf> Hmm, do we have the contramap lens yet?
13:38:06 <edwardk> you can use >>> too
13:38:08 <shachaf> For flip (.)
13:38:19 <edwardk> i don't think so
13:38:25 <shachaf> That way you could say fcTrans.argument %~ t'
13:38:29 <edwardk> heh
13:38:35 <edwardk> toss it in
13:38:53 <edwardk> we've been talking about it for a while
13:39:03 <shachaf> Hmm, we don't depend on contravariant.
13:39:10 <shachaf> Should it just be flip (.)?
13:40:08 <edwardk> add the contravariant dependency. i've been playing with uses for it
13:40:24 <edwardk> but that one should be just flip (.)
13:40:34 <Ziarkaen> I cannot use a variable in a pattern match.  What is te common way around this restriction.  Currently I'm having to maintain myParam = "2" and foo 2 = bar in sync in source.  A preprocessor seems unHaskellish
13:40:36 * hackagebot wl-pprint-terminfo 3.3 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.3 (EdwardKmett)
13:40:40 <edwardk> and we can add contramapped for the other
13:41:01 <shachaf> For the other?
13:41:09 <edwardk> for the contravariant case
13:41:13 <shachaf> (contravariant == 0.2.*?)
13:41:18 <edwardk> since contravariant doesn't help with the first arg of a function
13:41:25 <edwardk> contravariant >= the current contravariant version
13:41:36 <edwardk> i'm stripping upper bounds from my own intra-package dependencies
13:41:43 <shachaf> Hah. OK.
13:41:49 <absence> the >>> one is nice, that way i won't need the \foo -> foo & part :) thanks again!
13:42:01 <shachaf> So >= 0.2.0.2?
13:42:09 <edwardk> yeah
13:43:13 <shachaf> Oh, contramap doesn't work here at all.
13:43:23 <edwardk> hence two setters
13:43:34 <shachaf> Right.
13:43:48 <shachaf> So contramapped and... "argument"? That's kind of common.
13:43:57 <edwardk> sure
13:44:11 <edwardk> lets take the name as a strict generalization of the SEC
13:44:13 <shachaf> Oh, sets lmap would work here.
13:44:23 <edwardk> heh
13:44:30 <yepyep> map head $ splitEvery 2 [1..100]
13:44:31 <edwardk> ok, the profunctor generalization it is ;)
13:44:32 <shachaf> Not sure if that's a good idea.
13:44:38 <edwardk> i like it
13:44:44 <yepyep> > map head $ splitEvery 2 [1..100]
13:44:45 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
13:44:55 <yepyep> :)
13:45:00 <edwardk> we'll just document the function special case
13:46:01 <shachaf> So lmapped? Or argument?
13:46:10 <shachaf> I guess the latter has some precedent, at least.
13:48:32 <yepyep> quchen++
13:48:43 <yepyep> durrrr.  How to give karma?
13:49:01 <shachaf> I guess we should add Wrapped instances for Predicate, too.
13:49:14 <shachaf> Er, for all the Contravariant things, I mean.
13:50:37 * hackagebot vector-instances 3.2.1 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-3.2.1 (EdwardKmett)
13:51:32 <edwardk> shachaf: yeah
13:53:36 <quchen> yepyep: Neat, didn't know about that function. I'll take that as payment :-)
13:53:36 <hiptobecubic> yepyep, splitEvery is deprecated it seems
13:53:57 <hrumph> yo mzero what's happening?
13:54:02 <quchen> hiptobecubic: Hmpf.
13:54:07 <mzero> sorry - kids - but on the last two functions
13:54:09 <mzero> almost there!
13:54:11 <hiptobecubic> quchen, "chunksOf"
13:54:30 <yepyep> quchen: I don't think giving you karma worked
13:54:34 <quchen> hiptobecubic: Ah, wonderfun. Solved!
13:54:40 <quchen> yepyep: I don't even know what Karma is.
13:54:55 <quchen> yepyep: I'll have a delicious beer now. Let's say that was the karma.
13:55:03 <yepyep> ok. thanks for the help!
13:55:09 <yepyep> enjoy
13:55:37 * hackagebot semigroupoid-extras 3.0.1 - Semigroupoids requiring Haskell extensions  http://hackage.haskell.org/package/semigroupoid-extras-3.0.1 (EdwardKmett)
13:58:37 <blackdog> carter: what up dawg
13:58:47 <carter> word blackdog
13:58:58 <blackdog> :) i'm looking forward to your Riemann DSL
13:59:12 <blackdog> i still have no idea what i would use it for, but it looks like a powerful primitive.
13:59:13 <carter> well, the hard bits were already done
13:59:27 <carter> well, it looks like it'd be a really really restricted stream processing dsl
14:00:18 <blackdog> carter: wonder if it could be done as a conduit
14:00:28 <simpson> @src sequence
14:00:28 <lambdabot> sequence []     = return []
14:00:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:00:28 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
14:00:59 <carter> blackdog: i'd rather use pipes or machines i think, wrt that bit
14:01:09 <hpaste> mzero annotated “My fourth haskell program. Critique this” with “My fourth haskell program. Critique this (annotation)” at http://hpaste.org/80389#a80392
14:01:15 <mzero> enjoy!
14:01:52 <hrumph> mzero thanks a lot
14:02:19 <carter> blackdog but yes, some sort of streaming composition abstraction might be a good idea, but no reason to actually make that visible, thats sort of just an implementation detail
14:02:50 <hrumph> mzero that's aweome
14:02:51 <blackdog> hm, maybe. don't you get something out of making it easily pluggable into other things expecting conduits/pipes, though?
14:03:01 <hrumph> mzero awesome i mean
14:03:07 <mzero> thanks
14:03:10 <mzero> you're welcome
14:03:15 <carter> blackdog: nope, I don't think so. i'll have to look into itthough
14:04:32 <hpaste> teneen pasted “GHC not compiling” at http://hpaste.org/80393
14:04:52 <teneen> This small code snippet causes ghc to not terminate while compiling
14:05:01 <teneen> can someone identify the problem?
14:05:32 <teneen> I think it has to do with the vector library, because it was working fine with bytestrings
14:05:43 <simpson> teneen: Which version of GHC?
14:05:52 <teneen> 7.6.1 and 7.4.1
14:06:05 <simpson> Curious. Maybe it's time to file a bug report.
14:06:15 <hrumph> mzero you took out the nasty epithets
14:06:21 <mzero> I did...
14:06:45 <mzero> so, one thing you may not be used to quite yet are things like the validate function I wrote
14:06:58 <hrumph> i;m looking at that very thing right now
14:07:11 <mzero> note that you can pass the "expensive to compute error message string" - and not worry about the cost, as it won't actually get computed if the value validates
14:08:06 <mzero> this is very different than other languages, and actually a big win in Haskell, as a function like validate doesn't have to take a an error message generator
14:08:42 <teneen> simpson: is it a GHC bug or a library bug?
14:08:50 <simpson> teneen: Dunno!
14:09:16 <hrumph> mzero the reason why it compares on emplId is that these are essentially database rows with emplId as the primary key
14:09:51 <mzero> I understand - I'd just not use the Eq/Ord instances on Row for that - I'd use separate functions (and use sortBy and groupBy later on)
14:09:52 <monochrom> perhaps post on the glasgow-haskell-users mailing list so experts can investigate
14:10:09 <hrumph> mzero ok understood
14:10:38 * hackagebot free 3.3.1 - Monads for free  http://hackage.haskell.org/package/free-3.3.1 (EdwardKmett)
14:14:18 <heatsink> You know you're too used to unicode when you try to name your variable x? instead of xs
14:15:00 <shachaf> Is that meant to be a question mark?
14:15:05 <heatsink> No, it's an overline
14:15:27 <heatsink> \overline{x}
14:15:33 <shachaf> I think something's messed up with your encoding.
14:15:35 <hrumph> mzero lot to digest. i'm going to look at it more later. btw thanks again. that's really awesome that you took the time. i'm studying everything you are saying
14:15:35 <shachaf> Speaking of Unicode.
14:15:48 <hrumph> i have to sleep for a few minutes
14:16:04 <heatsink> You must be an efficient sleeper.
14:16:07 <mzero> happy to help - I'll off and on the rest of the day... feel free to ping me with more questions
14:17:59 <elliott> heatsink: I think your encoding might be the one that's messed up?
14:18:18 <srhb> Yep.
14:18:26 <heatsink> ok
14:20:32 <heatsink> Should be set to UTF-8 now
14:20:33 <heatsink> junɪkoʊd
14:20:37 <srhb> Looks right.
14:20:38 * hackagebot streams 3.0.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-3.0.1 (EdwardKmett)
14:20:47 <heatsink> good
14:21:31 <heatsink> x̅
14:21:37 <hrumph> right the validate function makes perfect sense mzero
14:21:44 <mzero> great!
14:21:57 <mzero> (man, that _was_ a short sleep)
14:22:15 <monochrom> yes, I see x overlined now
14:22:44 <hrumph> mzero not sure about where you say will fail if isn't enough fields. its already been established that the line has the right length at that point in the execution
14:23:57 <mzero> you mean in parseLine?
14:24:18 <hrumph> in validate Lin you added the comment  -- this will still fail if there isn't enough fields, consider:
14:24:23 <mzero> ohoh
14:24:25 <hrumph> validateLine i meant
14:24:26 <heatsink> Unicode works!  I have made the first step toward talking about Agda.
14:24:57 <mzero> zip and zipWith have a funny aspect: They silently work to the shorter of the two lists
14:25:22 <mzero> so validateLine won't validate all the fields if the input was short
14:25:23 <heatsink> There really should be a library version of zip that treats non-equal lengths as an error.
14:25:40 * hackagebot streams 3.0.1.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-3.0.1.1 (EdwardKmett)
14:26:40 <mzero> the logic that it has the right number of fields isn't localized to validateLine - so really, validateLine has no reason to presume it does just because the line has the right length
14:26:46 <mzero> I prefer such functions to be defensive
14:27:15 <mzero> heading out for a bit - back later
14:30:39 * hackagebot compressed 3.0.1 - Compressed containers and reducers  http://hackage.haskell.org/package/compressed-3.0.1 (EdwardKmett)
14:38:00 <monochrom> soon, we will have "Haskell 98 compressed air" and "Haskell 98 environmentally friendly refridgerant" too :)
14:45:39 * hackagebot representable-functors 3.0.1 - Representable functors  http://hackage.haskell.org/package/representable-functors-3.0.1 (EdwardKmett)
14:46:28 <edwardk> monochrom: =P
14:46:51 <edwardk> monochrom: i haven't been able to shoehorn them into haskell 98 yet ;)
14:48:13 <elliott> one day me and shachaf will end up making it "haskell 98 lens'
14:48:14 <elliott> "
14:48:27 <edwardk> elliott: its called 'profunctors' ;)
14:48:34 <gwern> @quote
14:48:34 <lambdabot> jfoutz says: There are good abstractions out there waiting to be found. Just because the specification we have now is bad/good/whatever, that dosn't mean there aren't better abstractions just
14:48:34 <lambdabot> waiting to be found.
14:48:48 <elliott> edwardk: yes, and we'll move all the abstractions there eventually!
14:49:51 <otters> what's the opposite of an abstraction
14:50:05 <Heffalump> a mess
14:50:05 <elliott> abstrution
14:50:40 * hackagebot either 3.0.3 - Haskell 98 either monad transformer  http://hackage.haskell.org/package/either-3.0.3 (EdwardKmett)
14:52:03 <elliott> Haskell 98 kitten
14:52:06 <elliott> Haskell 98 implementation of Haskell 98
14:52:11 <elliott> Haskell 98 proof of Haskell 98 correctness
14:52:12 <Jafet> An obstruction
14:52:27 <Jafet> elliott: PARTY HARD IN HASKELL 98
14:53:44 <hpc> PARTY LIKE IT'S HASKELL 98
14:56:48 <gwern> @quote
14:56:48 <lambdabot> ChrisKuklewicz says: Are there little known Haskell idioms for doing math? Is there an undocumented -funleash-fortran parameter?
14:57:30 <totte> What is <+> and/or how is it pronounced?
14:59:41 <mauke> I pronounce it "zerlegungsgleichheit" just because
15:00:02 <Boreeas> @src <+>
15:00:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:00:40 * hackagebot representable-tries 3.0.2 - Tries from representations of polynomial functors  http://hackage.haskell.org/package/representable-tries-3.0.2 (EdwardKmett)
15:00:55 <alpounet> it's "arrow plus", for me
15:01:55 <mauke> ⥅
15:03:18 <cmccann> so is edwardk updating the entirety of hackage or something?
15:03:30 <edwardk> cmccann: more or less
15:03:34 <elliott> cmccann: he flipped and removed all his upper bounds from his own dependencies
15:03:49 <elliott> a new era
15:03:55 <edwardk> also i added an instance to semigroups
15:04:00 <cmccann> hahaha
15:04:00 <edwardk> so i have to push the entire !*#)(* universe
15:04:13 <edwardk> hence flipping out and removing the upper bounds, etc.
15:04:30 <edwardk> its an opportunity to add README.markdown stuff to each package as i go, etc. too
15:04:46 <edwardk> overall its taking a bit longer than i'd like ;)
15:10:59 <simpson> Is there anything in base for normalizing paths? I'm passing paths to a C library and I have to stash them Haskell-side, so I'd like to make sure I don't pass the same path twice.
15:12:16 <shachaf> Look in System.FilePath
15:15:41 * hackagebot machines 0.2.2 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.2.2 (EdwardKmett)
15:18:17 <simpson> shachaf: System.Directory.canonicalizePath from directory looks like the winner.
15:18:25 <sm> go edwardk, go
15:18:31 * simpson misses having that kind of stuff in the standard base
15:19:08 <shachaf> simpson: What about System.FilePath.normalise?
15:19:11 <shachaf> That's pretty base.
15:19:25 <shachaf> Oh, and it doesn't work?
15:19:36 <shachaf> Oh, and it's not in base.
15:20:02 <shachaf> Oh, it works.
15:20:41 * hackagebot algebra 3.0.2 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-3.0.2 (EdwardKmett)
15:20:47 <elliott> Is it in base?
15:20:57 <simpson> It's not in base.
15:21:11 <simpson> Also filepath's docs recommend using directory for some curious reason.
15:29:18 <simpson> For FFI bindings that use IO, is it polite to throw exceptions in IO on error?
15:30:41 * hackagebot categories 1.0.5 - Categories  http://hackage.haskell.org/package/categories-1.0.5 (EdwardKmett)
15:30:51 <mikeplus64> simpson: sure, or wrap it in Either <error type>/Maybe
15:31:32 <simpson> mikeplus64: This is foreign state mutation using filepaths. Basically, this error means "you passed in a file path that doesn't exist."
15:32:15 <mauke> C functions that set errno generally throw exceptions in Haskell
15:32:26 <hpc> in general, it's bad form to throw an exception if you expect someone out there to actually want to catch it
15:32:51 <hpc> (from purely the API standpoint)
15:33:08 <mauke> huh?
15:33:19 <mikeplus64> i don't see what's bad about catching exceptions
15:33:33 <hpc> the exceptions don't show up in the type
15:33:46 <hpc> :t openFile
15:33:47 <lambdabot> Not in scope: `openFile'
15:33:49 <mauke> -> IO
15:34:08 <hpc> still doesn't say what kind of exceptions it throws
15:34:12 <hpc> or if it even throws any at all
15:34:59 <derdon> hpc: you want to have that information in the signature as in java's checked exceptions?
15:35:28 <elliott> mauke: Well, stuff that isn't -> IO can throw exceptions too...
15:35:30 <hpc> or just return what they actually mean
15:35:32 <hpc> :t lookup
15:35:33 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
15:35:41 * hackagebot groupoids 3.0.1 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-3.0.1 (EdwardKmett)
15:35:57 <hpc> rather than returning a 'b' and throwing ElementNotFound exception or something like that, use Maybe
15:36:00 <hpc> or Either
15:36:31 <simpson> hpc: So, I've got this type: loadSF :: Synth -> String -> IO Synth
15:36:35 <derdon> why do exceptions exist then?
15:36:47 <simpson> And you're saying that I should go with Synth -> String -> IO (Maybe Synth) ?
15:37:25 <edwardk> derdon: exceptions in haskell are usually used for _truly_ exceptional events. you cant recover from them in pure code
15:37:38 <hpc> simpson: you would have to decide, is the failure of loadSF considered an "impossible" occurence that should terminate the program
15:37:54 <hpc> simpson: or is there some way to check if it will succeed, similarly to file existence checks
15:38:09 <simpson> hpc: It's considered a serious user error that might be unrecoverable, but it doesn't hose anything inside the library.
15:38:29 <mikeplus64> it's often easier and simpler to throw an exception in some exceptional case than to wrap everything in something, derdon
15:38:34 <simpson> hpc: The file could exist, be readable, and be in a path that is accessbile, and *still* be corrupt. You gotta try to find out.
15:38:52 <hpc> hmm
15:39:15 <simpson> It's more that if this fails, that's kind of it. You can't really do much with that.
15:39:35 <simpson> I mean, yeah, you can go ahead and let your user know that they passed a bad SF, but that's it.
15:39:35 <hpc> i would probably go with IO Synth, then
15:40:06 <tac> In http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/Text-JSON.html#t:JSObject....
15:40:10 <mauke> I wonder what it would take to do Lisp Conditions in Haskell
15:40:12 <mikeplus64> i think it's reasonable to throw an exception in that case. your error could be many things and lives in IO, and fits in with the existing "standard" that functions opening files and (potentially a few reasons) throwing exceptions on failure
15:40:18 <tac> How the heck does JSRational work?
15:40:37 <tac> oops, at the top of the page: http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/Text-JSON.html
15:40:38 <mauke> tac: link's broken, anchor not found
15:40:39 <simpson> Also this doesn't hose the Synth object on the Haskell side, because you could try to load many SFs and ignore failures.
15:40:42 * hackagebot groupoids 3.0.1.1 - Haskell 98 Groupoids  http://hackage.haskell.org/package/groupoids-3.0.1.1 (EdwardKmett)
15:41:03 <mauke> tac: what do you mean?
15:41:12 <tac> JSRational is a constructor for JSValue
15:41:14 <tac> With two parameters
15:41:21 <tac> a Bool and a !Rational
15:41:32 <tac> But it doesn't explain what the heck the Bool parameter does
15:41:46 <hpc> simpson: basically, decide what operations you want people to be able to perform relative to loadSF, then write the type to match
15:42:15 <mikeplus64> tac: it's probably whether it's just an integer or a decimal
15:42:23 <tac> hmm
15:42:26 <tac> which is which :P
15:42:38 <shachaf> tac: | JSRational Bool{-as Float?-} !Rational
15:42:48 <hpc> simpson: and save exception handling for the wizards who write all their code in ContT ;)
15:42:55 <mikeplus64> tac: but you can test it, try showJSON (1 :: Int) and showJSON (0.1 :: Double)
15:42:58 <simpson> hpc: Heh.
15:42:58 <tac> oh... shachaf where did you get that? :O
15:43:02 <mikeplus64> also looking at the source helps
15:43:03 <mauke> tac: are you supposed to use those constructors directly?
15:43:04 <mikeplus64> lol
15:43:04 <tac> @type toRational
15:43:06 <lambdabot> Real a => a -> Rational
15:43:13 <tac> mauke: maybe, maybe not
15:43:28 <tac> but I didn't see where you convert ints to JSValues elsewhere
15:43:32 <shachaf> tac: cabal unpack json; ack JSRational json*/
15:43:42 <tac> yeah
15:43:55 <tac> I guess I'm just living in a fantasy world where the docs tell you how to use such a basic API :P
15:44:03 <mikeplus64> tac: also you can click the "source" button to the right of the thing for JSValue
15:44:13 <mauke> tac: showJSON
15:44:21 <hpc> @remember tac I guess I'm just living in a fantasy world where the docs tell you how to use such a basic API :P
15:44:21 <lambdabot> I will never forget.
15:44:53 <tac> heh
15:44:57 <tac> mikeplus64: ah sou
15:44:59 <tac> thanks all
15:45:05 <tac> I have satisfied ghc for the moment
15:45:13 <mauke> > showJSON 42
15:45:14 <lambdabot>   Not in scope: `showJSON'
15:45:36 <Hafydd> No man can truly satisfy GHC.
15:46:01 <hpc> ghc is like robert ebert...
15:46:03 <Ralith> that is a woman's task?
15:49:12 <hpaste> Hrumph pasted “Compare two splitPlaces functions” at http://hpaste.org/80398
15:49:34 <edwardk> @remember shachaf 3.0 is an edwardk phase, not just a version number. It's like Picasso's Blue Period.
15:49:34 <lambdabot> Good to know.
15:49:41 <hrumph> ok the second one was given to me by mzero as an alternative. i don't understand why its considered better than the first
15:49:52 <hrumph> mzero isn't here to explain it to me
15:50:12 <hpc> hrumph: sadly, he got mplussed
15:53:03 <hrumph> i can see what its doing i think but i don't see why its better
15:54:37 <byorgey> hrumph: it's better because it isn't explicitly recursive.
15:54:54 <byorgey> it's generally better to use existing recursive combinators than writing your own explicitly recursive functions.
15:55:05 <byorgey> it lets you think at a higher level and there's less opportunity for mistakes.
15:55:23 <hrumph> but a big disadvantage is lack of conceptual clarity
15:55:32 <byorgey> I disagree.
15:55:42 <shachaf> It's just a different concepts.
15:55:49 <hrumph> the take drop formulation is dead simple to conceptualise. this left right scan dance thing is a bit more complicated
15:55:56 <byorgey> Once you get used to some of the standard recursive combinators, it's much easier to think in terms of them than to understand an arbitrary explicitly recursive functions.
15:56:00 <hrumph> not drastically more but definitely a bit more
15:56:25 <byorgey> hrumph: yes, in this *particular* case, you don't really gain much in clarity.
15:57:03 <shachaf> Well, this particular case can probably be expressed better.
16:02:10 <shachaf> @ty \s ns -> mapAccumL (\a n -> swap (splitAt n a)) ns s
16:02:11 <lambdabot> [Int] -> [a] -> ([a], [[a]])
16:02:16 <shachaf> How's that?
16:02:32 <shachaf> It looks more complicated than it is due to swapping and flipping noise.
16:04:23 <hrumph> looks really neat
16:04:39 <hrumph> ty i'll use it it think thanx
16:04:48 <shachaf> You can also map with State, probably.
16:04:57 <shachaf> Well, mapAccumL ~ mapM with State
16:05:10 <Ralith> :t swap
16:05:11 <lambdabot> (a, b) -> (b, a)
16:05:13 <Ralith> orite
16:05:42 * hackagebot bound 0.5.1 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.5.1 (EdwardKmett)
16:05:44 * hackagebot profunctors 3.1.3 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-3.1.3 (EdwardKmett)
16:05:46 * hackagebot fluidsynth 0.1.1.0 - Haskell bindings to FluidSynth  http://hackage.haskell.org/package/fluidsynth-0.1.1.0 (CorbinSimpson)
16:06:45 <shachaf> Isn't there a class that has foo :: x a b -> x b a?
16:07:17 <byorgey> shachaf: I don't know of one
16:08:49 <Saizan> Groupoid?
16:13:39 <shachaf> Saizan: Hmm, that has composition too.
16:28:13 <vermeille> Hello all :D !
16:29:31 <vermeille> I'm a new Haskell developper, I wrote a propositional logic theorem prover, and I was wondering if anyone of you could tell me how my code could be improved :)
16:29:44 <vermeille> The url is : https://bitbucket.org/Vermeille/br41n/src
16:30:16 <vermeille> (in terms of Haskell style, obviously ; I'm not talking about algorithms)
16:30:43 * hackagebot profunctor-extras 3.2.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-3.2.1 (EdwardKmett)
16:34:59 <Peaker> shachaf, cool (about OpenGL), so did you get lamdu working?
16:35:00 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
16:35:44 * hackagebot pointed 3.0.2 - Haskell 98 pointed and copointed data  http://hackage.haskell.org/package/pointed-3.0.2 (EdwardKmett)
16:36:29 <Peaker> shachaf, very likely my lensContext can be simplified :)
16:36:52 <Peaker> I'm sure there are also many nice lens idioms I could use to improve the code, if only I knew about them :)
16:40:22 <aninhumer> Hmm, is there any way to show something in ghci without having to derive all the instances?
16:40:25 <applicative_> vermeille: if you import Prelude hiding (lex) you wont need to qualify lex
16:40:56 <quchen> vermeille: Style-wise, it's often nicer to read if you align your "=" signs, http://hpaste.org/80399
16:41:11 <JoeyA> Now that the ByteString package has Builder, what will come of blaze-builder ?
16:42:37 <quchen> vermeille: Also, the code has no comments. Even for very clear code, it's very useful to have some sort of one-line description of what a function does. It often feels silly for you as the coder right now, but is very useful to others (including you in a month).
16:43:20 <applicative_> it will be replaced by a lot of CPP if impl(bytestring < ...)
16:44:13 <JoeyA> applicative_: Is that speculation, or is that what they plan to do?
16:45:21 <applicative_> JoeyA: see  the comment on this https://github.com/meiersi/bytestring
16:45:46 <applicative_> "Fork of 'http://darcs.haskell.org/bytestring' to simplify integrating the blaze-builder work. "
16:46:17 <JoeyA> Ah, okay
16:46:35 <JoeyA> So should new code use ByteString or blaze-builder?
16:47:23 <JoeyA> That might be like asking if new code should use transformers or mtl (before they were made compatible)
16:48:12 <quchen> vermeille: Even worse: your 'isSubsetOf' function does not check for a subset property.
16:48:29 <quchen> That wrong self-evidence, which is quite horrible. That one needs a comment!
16:48:50 <quchen> I think it's best to rename it
16:49:02 <elliott> I think bytestring builder is meant to replace blaze-builder.
16:49:17 <quchen> You have 'isSubsetOf :: Ord a => [[a]] -> [[a]] -> Bool', but subset would be something like '[a] -> [a] -> Bool'
16:50:44 * hackagebot syb-extras 0.2.4 - Higher order versions of the Scrap Your Boilerplate classes  http://hackage.haskell.org/package/syb-extras-0.2.4 (EdwardKmett)
16:51:11 <quchen> LogicSolver line 64 is an inlined version of genPairs
16:51:27 <alex20032> Well, anyone here know some big project written in Haskell?
16:51:40 <quchen> alex20032: GHC for starters
16:52:53 <quchen> Hoodle, a note taking program, http://youtu.be/Z2wzpyxsVSU
16:53:06 <quchen> Cabal, Darcs
16:53:36 <aninhumer> XMonad
16:53:39 <quchen> The backend of Detexify, a Handwriting -> Latex symbol converter
16:54:07 <vermeille> quchen: thx :)
16:54:12 <quchen> And of course Microsoft Windows
16:55:06 <quchen> vermeille: There's a call to trace left in your LogicSolver.hs, which should not appear in a finished program
16:55:29 <quchen> It's like driving with your hood open ;-)
16:58:35 <vermeille> quchen: yes, in fact, my isSubsetOf checks a set of sets, that's why it's a [[a]]
16:58:35 <vermeille> right
16:58:35 <vermeille> what about monads, instances, performances, is everything done correctly ?
16:59:25 <quchen> vermeille: Then call it SubSetSetOf or something :-)
16:59:50 <quchen> I haven't compiled or profiled it so I can't say much about performance
17:00:10 <vermeille> quchen: I'm an experienced C++ developper, so I'm aware about naming, '=' alignment and debug code. This just is just an exercise, but I'd like to have a better understanding of Haskell idioms
17:00:26 <quchen> Monads, hmm. Well, the genPairs function could be written using monads, but I'm not sure whether that's more readable.
17:01:10 <Peaker> vermeille, where is your code?
17:01:29 <quchen> genPairs' xs = filter (uncurry (/=)) $ liftM2 (,) xs xs
17:01:36 <alex20032> quchen: if part of Microsoft windows is written in scala, then i wont use scala...
17:01:47 <quchen> ^ Not much better. But monadic.
17:01:53 <vermeille> Peaker: https://bitbucket.org/Vermeille/br41n/src/
17:02:15 <vermeille> far less readable, I think
17:02:30 <quchen> alex20032: The Windows thing was a joke of course. Although SPJ is somehow supported (employed?) by Microsoft Research.
17:02:44 <quchen> vermeille: Yeah, it's quite awful ;-)
17:03:05 <vermeille> quchen: I'm worried about my solve function and the 'inner' function which is a kind of innerloop
17:03:20 <vermeille> I'm aware that's it's ugly
17:03:37 <vermeille> But I don't know how to do it another way
17:04:46 <Peaker> vermeille, why do you need the Paren thing? For pretty-printing preserving of parens?
17:05:26 <vermeille> I don't really know. I don't even know if I use it
17:06:03 <quchen> vermeille: For that, use HPC to measure how much of your code is actually needed: http://www.haskell.org/ghc/docs/latest/html/users_guide/hpc.html
17:06:07 <Peaker> vermeille, also, I'd add an export list to the module
17:06:55 <vermeille> I followed a paper which defined this constructor
17:07:01 <hpaste> quchen pasted “Free HLint by HPaste” at http://hpaste.org/80402
17:07:22 <quchen> vermeille: see bottom annotation of ^
17:07:59 <Peaker> vermeille, why don't you use parsec or such instead of the tokenizer thing?
17:08:23 <vermeille> *___* amazing tool
17:09:06 <quchen> vermeille: There's also a section on using it in the profiling/testing chapter of RWH
17:09:13 <quchen> Which may be an easier introduction
17:09:42 <vermeille> I am reading RWH, but not finished yet
17:09:48 <Peaker> vermeille, use hlint on your code, you've got some redundant brackets at the very least
17:11:08 <Peaker> vermeille, don't compare with [], use "null", to avoid a redundant Eq constraint
17:11:29 <Peaker> vermeille, prefer guards over "if"s when possible (in your "if" within a "case" expression, it is possible)
17:12:54 <vermeille> Okay
17:13:20 <Peaker> vermeille, run hlint, it will give you many of these hints without human intervention :)
17:13:28 <vermeille> what about this ugly 'inner' not-really-a-function ?
17:13:44 <hpaste> quchen pasted “tidied version of solve” at http://hpaste.org/80403
17:13:59 <quchen> vermeille: What's a not-really-a-function?
17:14:00 <Peaker> what do you mean?
17:14:02 <vermeille> what about using a State Monad or some Haskell's black magic somewhere, for a more idiomatic code ?
17:14:55 <vermeille> quchen: my 'solve' function comes from imperative code. This code contains an inner loop that I translated with this 'inner' function
17:15:03 <hpaste> quchen pasted “tidierer version ;-)” at http://hpaste.org/80404
17:15:04 <vermeille> But semantically, this is NOT a function
17:15:34 <quchen> vermeille: Well, I didn't understand the 'inner' function in the first place. Comments! :-)
17:15:48 <hpaste> “Anonymous Coward” annotated “tidierer version ;-)” with “tidierer version ;-) (annotation)” at http://hpaste.org/80404#a80405
17:16:19 <gwern> @quote
17:16:19 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
17:16:51 <gwern> @quote
17:16:51 <lambdabot> haskell says: Haskell - it's like a Lamborghini in the village. A little jerk - and went to work on the tractor.
17:17:40 * sm scratches his head
17:17:41 <vermeille> quchen: Exactly. Because this is NOT a function, this is an inner loop of the solve function, and it's declared as a function
17:18:10 <vermeille> So, 'inner' is not understandable outside 'solve'
17:18:31 <vermeille> it has no sense
17:18:51 <vermeille> it should no even exist. It's not a function at all.
17:19:06 <quchen> Either delete it or describe what it does
17:19:54 <quchen> And then we can find out how to combine it with solve maybe
17:20:00 <vermeille> I "need" it for the recursion
17:20:11 <vermeille> wait a second :)
17:20:38 <jochu> vermeille: One thing to make it clear that it's only useful in solve, is to make put in a where clause within solve.
17:20:48 <quchen> I get that part, but that doesn't help me understand why it's necessary, so I can't really come up with a better idea
17:20:51 * hackagebot prelude-extras 0.3 - Haskell 98 - higher order versions of Prelude classes  http://hackage.haskell.org/package/prelude-extras-0.3 (EdwardKmett)
17:25:16 <hpaste> Vermeille pasted “algo” at http://hpaste.org/80406
17:26:04 <vermeille> Here you can see that 'inner' is the foreach loop
17:26:23 <quchen> And 'forever' is the outer recursion of 'solve'?
17:26:34 <vermeille> absolutely
17:27:16 <hpaste> applicative annotated “Free HLint by HPaste” with “Free HLint by HPaste (annotation)” at http://hpaste.org/80402#a80407
17:30:45 <quchen> vermeille: If inner just walks over the list of clauses looking at one clause at a time, that smells like a fold
17:31:07 <vermeille> maybe
17:31:14 <hpaste> applicative annotated “Free HLint by HPaste” with “Free HLint by HPaste (annotation) (annotation)” at http://hpaste.org/80402#a80408
17:31:24 <vermeille> I'm really a Haskell beginner
17:31:41 <quchen> Hm, the 'else' part is the problem there. Maybe it's not a fold then
17:32:23 <quchen> You're not just walking over the (c:cs) list, in the else clause the recursion is different from what you would have in a fold
17:32:29 <quchen> Hmm.
17:35:52 * hackagebot bound 0.6 - Making de Bruijn Succ Less  http://hackage.haskell.org/package/bound-0.6 (EdwardKmett)
17:36:05 <neutrino_> carmack's shout-out to the haskell community --> https://twitter.com/ID_AA_Carmack/status/266209432780820480
17:37:11 <vermeille> quchen: any idea ?
17:38:05 <quchen> vermeille: Not really. I'd say implement the suggestions above and repost in a few hours :/
17:38:40 <quchen> If you isolate it into a minimal example you may be able to post it on SE
17:39:00 <vermeille> SE ? Stack Everflow :D ?
17:39:05 <jmcarthur> i'm not sure whether to interpret carmack's tweet as criticism
17:39:27 <jmcarthur> i would be mortified if carmack was reading stuff i wrote :)
17:39:28 <quchen> I always mix up StackExchange and StackOverflow
17:39:42 <vermeille> Oh, okay
17:39:48 <shachaf> jmcarthur: Which?
17:39:51 <quchen> jmcarthur: I read it as "look at those Haskell freaks trying 3D stuff"
17:40:15 <jmcarthur> shachaf: https://twitter.com/ID_AA_Carmack/status/266209432780820480
17:40:27 <jmcarthur> quchen: nah, i know carmack respects haskell and the community
17:40:48 <elliott> Hmm, that tweet is very disappointing.
17:41:11 <shachaf> As far as I know conal is actively involved in industry things related to graphics.
17:41:22 <quchen> jmcarthur: Oh. Well then that post is very odd.
17:43:40 <quchen> Someone should tweet back that Quake 3 didn't benefit the development of computer science much and a little academic exercise would help industrial programmers
17:44:26 <jmcarthur> so adversarial
17:44:31 <vermeille> quchen: thanks you very much :)
17:45:00 <cmccann> if you read the conversation someone says "goes both ways, doesn't it?" and he agreed
17:45:04 <jmcarthur> the divide between academia and industry disappoints me as it is. i would hate to widen it further with hostility
17:45:42 <quchen> vermeille: I'm pretty bad at translating stuff to Haskell, most of the times I finally give up and do the right thing: forget everything imperative and reinvent the wheel. Maybe that's in order here: re-think what the function should do and Haskell it.
17:45:44 <jmcarthur> wow i didn't realize how old it was
17:46:23 <cmccann> so I get the impression that carmack would agree that less divide between academia and industry would be good
17:46:31 <cmccann> not everything needs to be a conflict!
17:46:47 <shachaf> I think there should be more divide.
17:46:56 <shachaf> Eventually academia and industry should go to war with each other.
17:47:01 <elliott> still. his phrasing is dismissive
17:47:02 <jmcarthur> cmccann: yes
17:47:51 <quchen> shachaf: Isn't that what we have right now?
17:47:56 <cmccann> elliott, I didn't really read it that way I guess
17:48:50 * cmccann read it more as a "this is weird but is it crazy enough to work?" sort of thing
17:49:19 <jochu> vermeille: From the algorithm you gave, is inner the same as: inner cs new = let resolvents = map plResolve cs in (nub (new ++ takeWhile (not . null) resolvents), any null resolvents)
17:49:19 <elliott> cmccann: well, the first part. the suggestion that conal needs to learn more from industry tipped it over the edge for me
17:49:31 <elliott> since it suggests it is on the "insane" side of things
17:50:02 * cmccann shrugs
17:52:04 <vermeille> Guys, we all know that Haskell is almost useless on a CV and Haskell is almost never in industry, so, why do you code in Haskell ? (I'm still a student and I love Haskell for the power of expression it has and powerful concepts it owns)
17:52:14 <cmccann> you have to admit conal is about as far to the "semantic correctness before performance" philosophical side as anyone
17:52:31 <flebron> vermeille, the "we all know" part is false :(
17:52:33 <jmcarthur> vermeille: haskell is not useless on a cv, for certain
17:52:37 <cmccann> and if you're not already familiar with his work it wouldn't be immediately obvious that anything he talks about is plausibly implementable
17:52:39 <flebron> the part about industry is somewhat true
17:52:46 <pnielsen> vermeille: definitely the opposite, CV-wise
17:52:55 <shachaf> Hmm, I think Poe's law applies to vermeille's last line of IRC.
17:52:55 <pnielsen> vermeille: Haskell is a very attractive line on a resume
17:52:57 <vermeille> jochu: let me analyze this line of code x)
17:52:59 <shachaf> I honestly can't tell.
17:54:02 <quchen> Haven't tried it yet, but I'd say Haskell in the worst case is useless on a resumee, but if someone knows what "learned Haskell by himself and is proficient in it" means about a person it's most certainly a big plus
17:54:12 <vermeille> Great. Why ? If Haskell isn't widely use, why recruiters cares about it ?
17:54:29 <message144> vermeille, my company doesnt use any haskell, but we certainly give extra consideration to interviewees who have it on their CV.
17:54:55 <cmccann> I would much rather work with a C# programmer who knows Haskell than a C# programmer who doesn't, all else equal
17:54:58 <quchen> message144: Oh, an insider! Care to tell us a little more?
17:55:17 <jmcarthur> mine definitely gives haskellers extra consideration, but we do FP anyway so that might not be a fair point for this discussion
17:55:31 <pnielsen> precisely because it is obscure/you learned it because you were genuinely interested in programming/learning new concepts. Python used to be the same:  http://www.paulgraham.com/pypar.html
17:55:53 * hackagebot logic-classes 1.4.7 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.4.7 (DavidFox)
17:56:18 <message144> quchen, IMO it demonstrates the ability for abstract thinking which is useful for problem solving as a whole. I try to focus on hiring problem solvers, not API-memorizers.
17:56:33 <jfischoff> I would not try an hire a haskell programmer and have him program in php
17:56:49 <jfischoff> even if it is a "signal"
17:56:51 <pnielsen> HR people who just scan keywords may not care, but actual hiring managers at "smart" companies will. Because you are communicating that you are passionate/interested/not just in it for the money
17:56:52 <message144> we hire python programmers, but if they have haskell on the CV, they will def stand out for that reason
17:57:04 <pnielsen> jfischoff: I doubt a Haskell programmer would apply to program in PHP...
17:57:07 <pnielsen> but I speculate :)
17:57:15 <vermeille> But Python is reaaaally mainstream compared to Haskell
17:57:25 <cmccann> vermeille, that was not always the case
17:57:27 <pnielsen> vermeille: hence why I said "used to be"
17:57:32 <vermeille> okay
17:57:35 <vermeille> my bad
17:57:40 <pnielsen> read the post :)
17:57:44 <pnielsen> it's good, and explains the point
17:57:54 <message144> also, because there is so much python work, the fact that a person learned haskell shows that they might be actually interested in learning, not just money
17:58:14 <jmcarthur> vermeille: #python has 1055 people right now. #haskell has 953. pretty close on freenode, at least :)
17:58:16 <pnielsen> message144: precisely
17:58:16 <vermeille> Obviously.
17:58:33 <jmcarthur> of course it's not a very useful comparison
17:58:48 <vermeille> Maybe on IRC. In IRL, I think the ratio isn't the same
17:58:52 <jmcarthur> definitely not
17:59:02 <pnielsen> it is not so much that you know Haskell, but that you have a genuine interest in learning, staying up to date, and doing whatever you'd be doing
17:59:24 <pnielsen> jmcarthur: yeah, that's definitely skewed
17:59:25 <cmccann> there are roughly 15x as many python questions on Stack Overflow as there are haskell questions. for what that's worth, which is little.
17:59:39 <jmcarthur> anyway, if the point is to have marketable skills, it depends on what kind of job you are seeking
17:59:41 <pnielsen> I doubt 15x is enough
18:00:05 <quchen> message144: What would you say about "Haskellers are most likely quickly annoyed with languages that aren't as 'pretty' as Haskell" or "Haskellers care more about the academic exercise than actually getting stuff done"? (Not my opinions by the way.)
18:00:10 <jmcarthur> haskell is definitely a strong bullet point for certain kinds of jobs, and is nonexistent for others like your average java chop shop
18:00:25 <vermeille> So, we could extend this reasoning to, say, C++ metaprogramming too
18:00:37 <craberryace> hello'
18:00:47 <pnielsen> quchen: that is a characterisation of some academics, not of somebody who is interested in all kinds of different things
18:01:04 <craberryace> anyone here knows C#
18:01:23 <pnielsen> sure, if you know a "better" language you might be annoyed to program in a worse one *cough*PHP*cough*. So don't apply for a job like that
18:01:30 <pnielsen> there ARE haskell/FP jobs out there
18:01:33 * cmccann is quickly annoyed by languages that make it harder to get stuff done than Haskell does, which is most of them
18:01:35 <flebron> vermeille, one hint is that knowing Haskell is a useful indicator of the type of thinking you're capable of doing
18:01:42 <message144> quchen, for the work i need, i am more likely to hire a python guy who dabbled in haskell, than the other way around. in my experience, people who are hardcore FP guys have not been the most effective at the line of work i need.
18:01:51 <flebron> this type of thinking often comes in handy in the workplace, if not under the exact guise of Haskell
18:02:28 <cmccann> I ditched python as my language for hobby projects largely because Haskell makes things so much easier to do :P
18:02:38 <quchen> message144: I can see the point there. Although for the record I don't like it of course ;-)
18:02:43 <flebron> i'm in the process of doing the same, cmccann :)
18:03:35 <vermeille> Are you also interested in C++ Metaprogramming :) ?
18:03:41 <message144> quchen, a python programmer who thinks like a haskell programmer is a very effective person in certain fields of software development, in my experience
18:04:19 <quchen> message144: Do you have any specifics about the "[FP guys have] not been the most effective"?
18:04:27 <jmcarthur> message144: i think a lot of the time it's that hardcore FP devs often have trouble integrating with non-FP culture and practices, although they could do the work in a more compatible setting
18:04:31 <craberryace> I know this is a Haskell group but does anyone here no C# at all. I need some help
18:04:49 <jmcarthur> craberryace: this is very much the wrong place
18:04:52 <cmccann> craberryace, if you need some help with haskell, feel free to ask
18:04:54 <quchen> craberryace: This is not an also Haskell group, this is an only Haskell group.
18:05:15 <craberryace> K
18:05:16 <roadfish> craberryace:there is a #csharp channel
18:05:24 <shachaf> As you said: no C# at all.
18:05:30 <jfischoff> After programming primarily in Haskell for a year I find my productivity in imperative dynamic languages to have decreased.
18:05:32 <craberryace> lol
18:05:35 <mauke> I do no C# at all
18:05:48 <jfischoff> I don't think about certain type of mutability errors
18:05:53 <hpaste> jochu pasted “vermeille, if it's right - here's solve” at http://hpaste.org/80409
18:05:56 <jfischoff> and type errors
18:05:59 <simpson> Programming in Haskell has improved my Python.
18:06:00 <message144> quchen, in my work, I need a lot of what you might call "quick and dirty". the "dirty" part is a hard pill to swallow for a lot of FP guys IMO
18:06:28 <cmccann> jfischoff, I mostly find that I end up avoiding mutation and otherwise writing things more Haskell-y
18:06:32 <quchen> jfischoff: I would argue the other way round: I care about purity in C++ now. Less side effects, less annoying bugs.
18:06:46 <cmccann> and forgetting that most compilers/interpreters aren't actually very good at optimizing code
18:07:12 <jmcarthur> i find that i have so much trouble (relatively) reasoning about mutation that working on existing imperative code is a nightmare, but i do okay writing from scratch
18:07:13 <quchen> message144: That surely applies to me :-) May I ask what area you're working in?
18:07:22 <roadfish> whereas Haskell is quite good at optimizing? because of no side-effects?
18:07:36 <message144> quchen, but at the same time, i wont hire somebody who does not have FP experience, although i am not looking for them to be a "FP person"
18:07:45 <jfischoff> cmccann: I think I am writing code that is mutation free, but in fact I am not.
18:07:51 <jmcarthur> roadfish: did i miss some context? what are you responding to?
18:08:05 <cmccann> jfischoff, that's no fun at all, agreed
18:08:16 <message144> quchen, rapid development for early stage internet startups
18:08:21 <vermeille> jochu: Wow. Let me read this carefully
18:08:34 <cmccann> roadfish, GHC is very clever and is good at optimizing the kind of code people write in Haskell
18:08:35 <edwardk> byorgey: i pumped semigroups to 0.9  -- you are the author of about half the packages that have an upper bound affected ;)
18:08:58 <vermeille> jochu: newbie question : why map and not fmap ?
18:09:01 <shachaf> edwardk: semigroups is totally going to make its way into base this time, right?
18:09:03 <cmccann> which is good, because a naive approach to a Haskell-like language would be horrifically inefficient
18:09:07 <vermeille> (in the resolvent definition)
18:09:23 <quchen> shachaf: Why does that sentence sound sarcastic? :x
18:09:31 <pnielsen> message144: I think you could say dirty/simple. From observation, haskellers really enjoy abstracting and abstracting and abstracting, although that is rarely useful/akin to premature optimization
18:09:54 <pnielsen> at least if it isn't potentially useful to a lot of different projects
18:10:18 <jochu> vermeille: map and fmap are equivalent for lists, but map has a type specifically for lists. The benefit of picking map over fmap is mostly better error messages.
18:11:11 <cmccann> pnielsen, fortunately that won't be necessary, since edwardk is in the process of exhaustively enumerating all possible abstractions and uploading them to hackage
18:11:16 <jochu> That line probably should've been: resolvents = [ plResolve (x, y) | x <- clauses, y <- clauses, x /= y ]
18:11:17 <pnielsen> haha, yes
18:11:29 <cmccann> s/be necessary/be necessary in the near future/
18:11:42 <pnielsen> cmccann: I couldn't help but think of his name when writing that sentence
18:12:55 <hpaste> jochu annotated “vermeille, if it's right - here's solve” with “vermeille, if it's right - here's solve (annotation)” at http://hpaste.org/80409#a80410
18:13:42 <jochu> vermeille: Given that resolvents will never contain null, the takeWhile was useless.
18:13:48 <pnielsen> I think lens deserves some kind of abstraction award, but it IS useful in a lot of cases. Some other abstractions seems to have been built simply for recreation
18:14:30 <shachaf> pnielsen: As far as I can tell lens is mostly recreational.
18:14:31 <pnielsen> which is what I was getting at -- that helps exactly 0% in an semi-dirty industry project with deadlines
18:14:44 <pnielsen> s/an/a/
18:14:47 <shachaf> pnielsen: (OK, that's not true.)
18:15:02 <pnielsen> maybe for edwardk
18:16:02 <cmccann> pnielsen, what does help in quick-and-dirty situations is having a pre-existing library of abstractions you know well
18:16:23 <cmccann> and lens is an excellent example of the kind of thing that is useful there
18:16:32 <cmccann> you just don't want to be trying to invent lens in the middle of such a project
18:17:16 <cmccann> being comfortable with parser combinators is another example, being able to bang out a good-enough parser for munging data is thoroughly practical
18:18:28 <pnielsen> agree. I do believe that they can be useful when the abstraction genuinely does apply to different projects/use cases
18:18:30 * elliott thinks a larger number of the "theory" packages on Hackage are use-oriented than pnielsen might expect.
18:19:10 <cmccann> elliott, it's hard to tell with the ones that are largely undocumented, unfortunately
18:19:11 <applicative_> jochu: dont we know that takeWhile (not . null) resolvents is the same as resolvents if the first guard fails?
18:19:13 <pnielsen> cmccann: yep, exactly
18:19:40 <jochu> applicative_: Yeah, hence the annotation :P
18:19:52 <cmccann> like, is this the debris from someone's super-practical project? or is it something they did for fun and isn't useful anywhere? or is it a thesis by-product that's bitrotted but very useful for a very narrow purpose?
18:20:11 <pnielsen> elliott: often for a single project, where the abstraction is mostly redundant (I don't have numbers, but I do get that feeling)
18:20:14 <applicative_> jochu: ah i see, much nicer
18:20:52 <elliott> pnielsen: shrug. I disagree
18:21:18 <alec> what do the backticks do in haskell?
18:21:22 <jochu> applicative_: Yep. Thanks though - it was an artifact from translating things. Then reviewing what it said after translating, I realized it wasn't necessary.
18:21:42 <alec> i'm working through learn you a haskell
18:21:44 <jochu> alec: Convert something to infix notation. a `f` b = f a b
18:22:09 <pnielsen> elliott: then it seems we are at an impasse
18:22:09 <cmccann> it hardly matters though, unfortunately. even the most practical-use-oriented package doesn't help if it's abandoned, bitrotted, undocumented, and whatever else
18:22:42 <alec> so that's true in [x | x <- [50..100], x `mod` 7 == 3], jochu?
18:23:07 <alec> ah it must be
18:23:15 <jochu> alec: Yep, that's equivalent to [x | x <- [50..100, mod x 7 == 3]
18:23:19 <alec> [x | x <- [50..100], mod x 7 == 3]
18:23:22 <alec> yes
18:23:25 <alec> i just tested that myself
18:23:29 <alec> thank you!
18:23:36 <alec> jochu++
18:24:01 <alec> karma jochu
18:24:04 <alec> hmm
18:24:08 <alec> is there no karmabot in here?
18:24:15 <cmccann> try @karma
18:24:17 <shachaf> It works fine.
18:24:20 <alec> @karma jochu
18:24:20 <lambdabot> jochu has a karma of 1
18:24:28 <cmccann> @karma shachaf
18:24:28 <lambdabot> shachaf has a karma of 34
18:24:33 <shachaf> cmccann: Ignore my karma.
18:24:37 <croikle> @karma c
18:24:37 <lambdabot> c has a karma of 1
18:24:43 <pnielsen> @karma pnielsen
18:24:43 <lambdabot> You have a karma of 0
18:24:43 <shachaf> Someone spammed shachaf++ in another channel.
18:24:45 <alec> @karma cmccann
18:24:45 <lambdabot> cmccann has a karma of 16
18:24:48 <pnielsen> what is karma?
18:24:48 <shachaf> @karma+ java
18:24:48 <lambdabot> shachaf's karma lowered to 33.
18:24:50 <alec> cmccann++
18:24:52 <alec> @karma cmccann
18:24:52 <lambdabot> cmccann has a karma of 17
18:24:53 <pnielsen> haha
18:25:08 <pnielsen> ah, ++
18:25:09 <croikle> does it fire when you talk about c++
18:25:14 <croikle> @karma c
18:25:14 <lambdabot> c has a karma of 1
18:25:14 <alec> karma is just a nice way of being nice
18:25:23 <shachaf> It's a nice way of spamming the channel.
18:25:27 <alec> and the original karmabot was written in haskell afaik
18:25:28 <cmccann> pnielsen, a completely meaningless number stored by lambdabot
18:25:29 <pnielsen> definitely
18:25:34 <pnielsen> very useless
18:25:45 <alec> i quite like it
18:25:45 <pnielsen> this is a case of a quick and dirty project that is entirely useless :p
18:25:48 <cmccann> though not the most useless thing lambdabot does
18:25:50 <alec> it's used a lot on #perl6
18:26:07 <alec> people take it more seriously there than it's taken here :P
18:26:19 <pnielsen> i get enough reddit on reddit
18:26:24 <alec> eww
18:26:26 <alec> reddit
18:26:29 <alec> ewwwwwwwww
18:26:30 <vermeille> jochu: Does your implementation "inspired" from mine or from the imperative algorithm ?
18:26:40 <vermeille> :s/Does/Is
18:26:40 <alec> pnielsen--
18:26:46 <pnielsen> :(
18:26:53 <alec> stop using reddit =)
18:27:09 <pnielsen> i don't know of any lambdatheultimate like site with karma :p
18:27:10 <jochu> vermeille: A little of both? I jumped between them.
18:27:11 <cmccann> pnielsen, /r/haskell isn't too bad
18:27:21 <pnielsen> cmccann: yeah I love r/haskell
18:27:39 <cmccann> well, it's occasionally terrible but usually great
18:27:45 <vermeille> jochu: Okay, I was trying to understand why there is no call to 'tautology'
18:28:01 <cmccann> ignore things cross-posted from proggit and links to monad tutorials and you should be fine though
18:28:01 * alec checks r/haskell with one eye held closed and the other just a tad open
18:28:30 * pnielsen waits for alec to click the logo and go "AFK" for 6 hours
18:28:59 <jochu> vermeille: Ah, I must of missed that part. Focused too much on the imperative algorithm.
18:29:26 <alec> lol
18:29:45 <alec> ok, i found a link to a nice study about structured graphs
18:29:48 <Nereid> @karma shachaf
18:29:48 <lambdabot> shachaf has a karma of 33
18:29:50 <alec> that's all right then
18:30:14 <alec> but really, there's something very juvenile about the rest of reddit imo
18:30:19 <vermeille> Okay, I will "study" your implementation, to try to do a perfect adaptation
18:30:44 <shachaf> @karma+ javae
18:30:44 <lambdabot> javae's karma raised to 1.
18:30:45 <shachaf> Er
18:30:48 <shachaf> javae--
18:30:50 <shachaf> @karma+ java
18:30:50 <lambdabot> shachaf's karma lowered to 32.
18:31:05 <cmccann> stuff that ends up on /r/haskell tends to be links to blog posts, interesting projects, or bits of research, questions (incl. links to SO), discussions that could just as well be on -cafe, and a few random bits of utter crap
18:31:19 <pnielsen> cmccann: yeah, some of the posts are a bit jerky
18:32:08 <majuscule> Hello everyone! Forgive my ignorance in advance please :-) but I very much would like to learn. I wrote a small program in haskell (https://aur.archlinux.org/packages/powermate/) that depends on a package haskell-powermate (bindings for a physical input device). Unfortunately, the upstream package is now orphaned and fails to build. I want to fix it myself! But I'm a bit lost. I think that I've isolated the problem down to an ambiguous type error, but I
18:32:27 <cmccann> majuscule, I think that got cut off
18:32:34 <cmccann> at "error, but I"
18:32:37 <vermeille> Hmmm, I think that most of you are in the industry, and since I am a student, I wonder if AI (since it passionnates me) has a place in today's industry
18:32:43 <majuscule> cmccann: yikes, thanks
18:33:25 <jochu> vermeille: I don't know if I'm reading this right, but here's my best guess at where tautology is supposed to be.
18:33:26 <hpaste> jochu annotated “vermeille, if it's right - here's solve” with “vermeille, if it's right - here's solve (annotation) (annotation)” at http://hpaste.org/80409#a80412
18:33:27 <majuscule> error, but I'm not sure how to add the type definition. Here is the code: http://dpaste.com/866663/, and here is the error, http://dpaste.com/866664/. I'll really appreciate any pointers!
18:33:37 <cmccann> vermeille, no, because once a technique works reliably people stop calling it "AI"
18:34:23 <croikle> majuscule: I think you want to label the type of e
18:34:30 <qasd> so haskell must use tailrecursion.
18:34:41 <qasd> ?
18:34:45 <croikle> catch \(e :: WhateverException) -> ...
18:35:01 <flebron> qasd, why?
18:35:15 <vermeille> jochu: I think now it's perfect. Thank you very much!
18:35:17 <qasd> or you could have infinite loops?
18:35:23 <vermeille> cmccann: is that a sarcasm ?
18:35:25 <majuscule> croikle: hmm thank you, I'll try some stuff out!
18:35:36 <cmccann> vermeille, it's an old joke about AI research :]
18:35:45 <cmccann> vermeille, more seriously it's worth noting that one of the most prominent AI textbooks was co-authored by google's director of research
18:35:48 <cmccann> that is not a coincidence
18:35:59 <shachaf> catching ioErr ...
18:35:59 <vermeille> Are you talking about AIMA ?
18:36:03 <cmccann> yes
18:36:04 <vermeille> I'm reading it
18:36:10 <croikle> majuscule: maybe that should be where e is used, not in the lambda variable
18:36:16 <pnielsen> introduction to AI
18:36:19 <pnielsen> Peter Norvig
18:36:26 <flebron> qasd, haskell doesn't have "calls" per se, so the concept of tail recursion optimization is a bit weird
18:36:41 <flebron> typicall there's no need to create an entire stack for each recursion in haskell
18:36:43 <pnielsen> NLP/making sense of large amounts of data is certainly a growing field
18:36:50 <roadfish> can someone give me an example of using "~?".
18:36:50 <flebron> s/stack/stack frame/
18:36:54 <roadfish> I tried: test [ "simple case" ~: (error "myBad") ~? "myBad" ]
18:36:54 <pnielsen> unstructured data*
18:36:57 <cmccann> it's also pretty obvious that google makes heavy use of machine learning techniques and other AI-flavored stuff
18:37:02 <vermeille> cmccann: Yes, but as you noticed, it's *the most prominent author*. For simple guys (like me ?) is there a place in AI ?
18:37:05 <roadfish> and various other permunations ... but keep getting in wrong
18:37:19 <cmccann> so if your question is just "does AI have use in industry" it's hard to argue with that
18:37:36 <pnielsen> vermeille: I think studying and knowing about search algorithms and Bayesian networks/hidden Markov models can be very helpful and useful
18:38:37 <vermeille> Okay, the real question is "Should I continue to learn AI, or is that a waste of time because the industry will never need those skills because there already are gurus ?"
18:39:05 <pnielsen> vermeille: yes you should learn about AI. There are many useful algorithms involved that are useful outside "just AI."
18:39:08 <cmccann> vermeille, industry needs more than just gurus
18:39:23 <roadfish> plus, you will be able to better serve your new masters
18:39:29 <cmccann> but with any specialized subfield you should decide if you want to be seriously involved in it or not
18:39:42 <pnielsen> vermeille: Peter Norvig and Sebastian Thrun's online course, Intro to AI, is very good. Recommend it
18:39:45 <vermeille> I *never* saw the real world. I'm still in school. I'm sorry if my questions sounds like dumb questions
18:40:01 <vermeille> pnielsen: I'll definitely buy it ;)
18:40:02 <pnielsen> vermeille: https://www.ai-class.com/ all the vids and exercises are available
18:40:05 <cmccann> it's still useful to know if you're doing other stuff, but if you want to do mostly AI-related things you want to become very competent at it
18:40:08 <vermeille> Already done :p
18:40:17 <qasd> flebron: is that explainable in a simple way? nhow can it not have calls?
18:40:45 <cmccann> you don't need to be a genius or anything, but it should be something you want to focus on and learn about deeply
18:40:48 <flebron> qasd, because call implies that you want a result now, haskell is lazy, so a "call" needn't actually be run when you declare it
18:41:03 <qasd> but if i do...
18:41:12 <flebron> if you say "int x = f();" in C, f must be run. not so in Haskell. until you actually need the value of x for something, it won't be "call"ed
18:41:27 <pnielsen> what cmccann said, especially if you want to make software for self-driving cars, or flight software :)
18:41:28 <flebron> so haskell works in terms of expanding "thunks", which are conceptually unexpanded pieces of computation
18:42:10 <vermeille> cmccann: correct me if I'm wrong, but, for a "AI-guy" isn't it more difficult to find a job than a "standard" developper ?
18:42:13 <monochrom> example: const True (product [2..100000]) takes constant time
18:42:24 <monochrom> > const True (product [2..1000000])
18:42:25 <lambdabot>   True
18:42:28 <cmccann> vermeille, that's true for any specialty you choose.
18:42:42 <cmccann> but the jobs you find will be more rewarding.
18:42:58 <vermeille> Hum, I do believe that there is more demand for hackers that AI-guys
18:43:12 <roadfish> I remember hearing the same thing about jobs in the nuclear industry. Can be boom or bust depending on what phase industry is in.
18:43:27 <cmccann> vermeille, that's why I said it needs to be something you're really serious about
18:43:31 <tac>     Couldn't match expected type `network-2.3.0.10:Network.URI.URI'                 with actual type `URI'
18:43:37 <tac> ^ any ideas on that?
18:43:54 <tac> (I just updated a bunch of packages on cabal, if that has to do with it)
18:43:58 <cmccann> vermeille, for something like AI you can't just go through, learn the basics, and start sending out resumes
18:44:05 <monochrom> the nuclear missile industry is in a bust ever since Haskell got STM :)
18:44:06 <Nereid> tac: oops.
18:44:12 <Nereid> tac: do you have a bunch of broken packages? ghc-pkg check
18:44:25 <vermeille> cmccann: Okay, so I will definitely need to go in US to find some work, if I decide to get involved in this field. Not an easy decision
18:44:33 <tac> Nereid: I get infinity warnings followed by a list of things
18:44:39 <tac> what am I looking for exactly? :O
18:44:40 <Nereid> wonderful.
18:44:48 <tac> ah
18:44:48 <tac> yes
18:44:53 <tac> it's a long list of broken packs
18:44:56 <Nereid> all of the things in that list of things are broken.
18:45:06 <monochrom> tac, it is not broken package. it is multiple versions of network
18:45:37 <tac> Can I kill packages with Cabal in an easy way?
18:45:39 <monochrom> although you do have broken packages and they will cause other problems later
18:45:46 <Nereid> you can unregister them with ghc-pkg unregister
18:45:47 <monochrom> "ghc-pkg unregister"
18:45:50 <vermeille> cmccann: I get the point: « If you do it, do it well. There is no place for mediocrity in specialized fields »
18:46:05 <tac> it looks like all the problems are coming from Yesod depends
18:46:07 <cmccann> yep. you also want to get involved with people already working in that field.
18:46:12 <monochrom> how many of you have not read my http://www.vex.net/~trebla/haskell/sicp.xhtml ?
18:46:34 <tac> monochrom: I try not to program in Haskell too often :P
18:46:34 <Nereid> I was looking for that.
18:46:49 <Nereid> tac read this.
18:47:44 <monochrom> if you just want to get rid of packages for now, fast forward to "removing packages"
18:49:04 <vermeille> cmccann: I was looking for publications. Do you know some interesting journals/magazines ?
18:49:36 <tac> oh fun, my shell froze -.-
18:50:10 <cmccann> vermeille, nope--I am not one of those people you need to connect with, sorry!
18:50:21 <cmccann> my knowledge of AI extends little beyond owning a copy of AIMA
18:52:40 <vermeille> And reading it :p ?
18:52:41 <tac> Nereid: monochrom: No conflicts now. But same error
18:52:43 <pnielsen> vermeille: www.aaai.org
18:53:11 <vermeille> thx!
18:53:20 <cmccann> vermeille, I read... some of it!
18:53:44 <tac>  is removing the .cabal/lib/<pkgname> dir mandatory?
18:53:58 <monochrom> no, unless you want to save disk space
18:54:37 <tac> hmm
18:54:54 <tac> Well, the broken packages are all unregistered, but I'm still getting the same error
18:54:59 <Nereid> do you have multiple versions of network installed
18:55:00 <Nereid> ?
18:55:11 <tac> it's very possible
18:55:31 <tac> yes
18:55:32 <tac> I do
18:55:41 <monochrom> <monochrom> tac, it is not broken package. it is multiple versions of network
18:55:47 <tac> I gotcha
18:55:56 * hackagebot texmath 0.6.1.2 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.1.2 (JohnMacFarlane)
18:56:21 <monochrom> in general:
18:56:44 <monochrom> 1. "upgrading" what comes with GHC is suicidal. (and there is no "upgrading". you're just adding, not replacing.)
18:56:47 <vermeille> Okay guys, I really need to sleep (4:00 :D), Thanks you very much :) see you !
18:57:02 <monochrom> 2. letting two versions to live is suicidal
18:57:47 <monochrom> 3. the pros disagree with the above, but that's because the pros know how to work around problems. you are not the pros, you are stuck.
18:58:15 <monochrom> in general: pros' advice is the most dangerous, because pros assume that everyone is pros
18:58:33 <cmccann> unlike monochrom's advice, which assumes everyone is monochroms
18:58:36 <flebron> bros assume everyone is bro
18:58:59 <monochrom> I am not a pro. I am just a scientist
19:00:12 <cmccann> I'm more from the hit buttons randomly until something starts working school of troubleshooting.
19:00:43 <tgeeky_> for instance, the above sentence took him 14 minutes to stumble upon.
19:00:52 <monochrom> haha
19:01:27 <flebron> we have a dedicated cluster of monkeys to get cmccann's responses
19:01:28 <cmccann> no, I have a huge list of pre-written sentences. I just keep trying random selections until one makes sense.
19:01:31 <tac> monochrom: Nereid: I managed to succeed. Thank you for the help.
19:01:58 <Nereid> now go check that you don't also have multiple versions of other things too.
19:02:13 <tac> How would I do that quickly?:
19:02:18 <tgeeky_> cmccann: http://www.youtube.com/watch?v=dd0tTl0nxU0 <---
19:02:43 <cmccann> bluh don't like watching videos
19:02:43 <elliott> cmccann: you don't have a very good success rate :(
19:03:11 <cmccann> elliott: or perhaps I have a different definition of "makes sense"
19:03:56 <monochrom> "ghc-pkg list" lists your packages. but I do not have a program that scans for repetitions
19:04:10 <monochrom> perhaps s/repetitions/multiplicity/
19:04:16 <tac> monochrom: So just a simple shell script or something is what I need, I'm guessing?
19:04:26 <cmccann> we need a ghc-monochrom utility that goes through an automatically unregisters all but one version of each package.
19:06:32 <c_wraith> That would break a lot of package installs
19:07:06 <c_wraith> Of course, you could argue they were already broken, and you just didn't know it yet...
19:07:08 <monochrom> there was as GSoC project to modify GHC and Cabal to allow multiple versions without problems. It fizzled.
19:07:30 <c_wraith> There was also a successful project on the topic
19:07:35 <dcoutts_> monochrom: I don't think that's quite fair
19:08:01 <monochrom> well, is it in GHC HEAD and Cabal HEAD yet?
19:08:13 <dcoutts_> no it's not
19:08:15 <liyang> $ ghc-pkg list | sed -ne 's/^ \+\(.*\)-[0-9.]*$/\1/p' | sort | uniq -d
19:08:38 <tgeeky_> $ ghc-pkg list | magic | sort | uniq -d
19:08:39 <dcoutts_> I don't think that's the only criteria
19:08:42 <tac> baaaaah
19:08:44 <pnielsen> what was the project? each package's dependencies in subdirs beneath the package?
19:09:08 <tac> An hour's worth of work to find out that I need ghci to build one of the depends, and that my version of Haskell doesn't support GHCi on ARM, and I'm using ARM
19:09:10 <monochrom> well, methinks if it does not appear in stable released versions, it is fizzled for us end-users
19:09:30 <dcoutts_> monochrom: if it never does, or doesn't for years, then yes
19:09:45 <pnielsen> depends on how old it is
19:09:46 <monochrom> years?
19:09:55 <pnielsen> if it's just in development, then it's not fizzled
19:10:13 <dcoutts_> but if it makes progress towards the goal and that we build on later, then it can still legitimately be called successful
19:10:32 <dcoutts_> especially if the amount of progress was reasonable given the size of the problem
19:10:46 <dcoutts_> or reasonable given the time available for GSoC
19:10:56 <monochrom> is anyone continuing working on it now?
19:11:13 <pnielsen> link please
19:11:39 <dcoutts_> monochrom: not actively, right now, however it's the basis for the kickstarter project we've been discussing
19:12:02 <dcoutts_> because it is the basis for doing things right
19:12:27 <apollonius_perga> can you declare a type to be an instance of a typeclass without specifying all the typeclass functions?
19:12:29 <monochrom> ok, this sounds like a Five Year Plan now
19:13:02 <apollonius_perga> like making something a Num without abs and signup?
19:13:07 <apollonius_perga> bah...signum
19:13:14 <majuscule> I feel silly asking this, but I've been reading all I can about it and it's still not clear. How do I get an exception in scope? I need something like `instance GHC.Exception.Exception  Control.Exception.Base.NonTermination`, I've tried importing Control.Exception.Base, but I always end up with an error `Illegal type signature: `NestedAtomically' and the hint 'Perhaps you intended to use -XScopedTypeVariables' which is what lead me to think it's out of 
19:13:36 <shachaf> majuscule: Perhaps you intended to use -XScopedTypeVariables.
19:13:49 <shachaf> That's what you need to use, for the syntax (\(x::t) -> ...)
19:13:56 <shachaf> It's not valid Haskell syntax.
19:13:57 <elliott> apollonius_perga: Yes, but they'll just error out if you use them with that type.
19:14:00 <elliott> It's kind of evil.
19:14:07 <monochrom> you can omit abs and signum if you have a good reason
19:14:19 <elliott> majuscule: surely NonTermination is already an instance of Exception?
19:14:48 <majuscule> elliott: i'd assume so? i'm not sure your point
19:15:00 <apollonius_perga> well, what would you do when defining finite fields? just make abs the identity and signum=1?
19:15:00 <elliott> oh, you need to import the instance?
19:15:07 <elliott> anyway, don't import Control.Exception.Base
19:15:08 <majuscule> shachaf: i should have paid more attention to that. i wasn't sure what it meant. i'll look that up now and try it
19:15:13 <majuscule> elliott: ok :-)
19:15:13 <Tehnix> Is anyone else having problems with not being able to install hfsevents-0.1.3 via cabal on OS X 10.8?
19:15:15 <elliott> probably hpaste your code
19:15:18 <apollonius_perga> or use a different typeclass than Num?
19:16:19 <shachaf> majuscule: When GHC gives you an error, it's a good idea to read it. :-)
19:18:12 <Nereid> are there any laws relating abs and signum to the other stuff?
19:18:20 <Nereid> in Num
19:18:32 <apollonius_perga> don't think so Nereid...just to each other
19:18:43 <Nereid> because for all the instances I can think of, we have abs x * signum x = x
19:18:57 <apollonius_perga> yes, that law is supposed to hold in Num
19:18:59 <monochrom> and so, it relates to *
19:19:06 <apollonius_perga> oh right :-)
19:19:29 <Nereid> Num is sad. :(
19:19:39 <Nereid> slightly less sad now that it has no Eq or Show superclasses.
19:19:40 <sw2wolf> :t signum
19:19:41 <lambdabot> Num a => a -> a
19:20:06 <monochrom> this is why I am not pedantic about omitting abs and signum
19:20:08 <sw2wolf> signum 1
19:20:17 <sw2wolf> > signum 1
19:20:19 <lambdabot>   1
19:20:29 <sw2wolf> > signum (-1)
19:20:31 <lambdabot>   -1
19:20:31 <Ralith> Nereid: what would you use instead?
19:20:38 <apollonius_perga> so, how would you guys do a finite field? just omit abs and signum?
19:20:42 <monochrom> whereas if you omitted return in Monad I would declare wars :)
19:21:15 <cmccann> pf, don't need return to desugar do blocks
19:21:23 <cmccann> totally optional
19:21:39 <monochrom> This Means War!
19:22:00 <monochrom> @stab cmccann
19:22:00 * lambdabot places her fist firmly on cmccann's jaw
19:22:06 <cmccann> haha
19:22:13 <shachaf> monochrom: Hey, what are you bringing lenses into this for?
19:22:15 <jochu> Tehnix: It installed just fine for me (with a few warnings). What errors are you hitting?
19:22:56 <monochrom> for Global Thermonuclear War :)
19:23:35 <elliott> monochrom: I bet you love blaze-html
19:23:49 * elliott thinks @stab should give lens type signatures.
19:23:53 <monochrom> atomically (launch_missiles >> retry)
19:25:26 <shachaf> elliott: This may be war, but perhaps the Geneva Conventions still apply.
19:25:28 <shachaf> No lens signatures.
19:26:24 <hrumph> mzero gave me other advice that i don't underestand i'll paste what i'm talking about now
19:27:30 <monochrom> (mzero advice would be incomplete without mplus advice  (duck))
19:29:07 <hpaste> Hrumph pasted “explain why the second implementation of mainControlProcessLin is considered an improvement” at http://hpaste.org/80413
19:29:24 <sw2wolf> sometimes those pragma frustrates me: {-# LANGUAGE TypeSynonymInstances, MultiParamTypeClasses, DeriveDataTypeable ... #-}
19:29:35 <hrumph> ok there are two implementationos of mainControlProcessLine
19:29:47 * elliott thinks that last version is strictly worse than the previous one.
19:29:49 <elliott> Except for the indentation.
19:29:53 <hrumph> the second one is mzero's and i don't understand why he changed it
19:30:01 <elliott> Well...
19:30:07 <elliott> I didn't notice your definition of maybeGuard.
19:30:17 <hrumph> yes that's mine
19:30:21 <hrumph> is it bad?
19:30:33 <elliott> I don't really like either version then :)
19:30:43 <elliott> The former is nicer because it's less code, I guess, but I think there's a nicer way of doing it...
19:31:13 <sw2wolf> why are there so many pragma in GHC ?
19:31:15 <hrumph> ok no explanation as to why mzero changed it?
19:31:28 <hrumph> elliott what would you reccommend to improve it?
19:31:43 <monochrom> did mzero say anything else?
19:32:12 <hrumph> no, there was no explanation attached to this change
19:32:20 <elliott> Wait, mzero's version has maybeGuard too.
19:32:34 * elliott thinks mzero's version is strictly worse, then, modulo indentation.
19:32:34 <hrumph> the maybeguard is my idea
19:32:39 <applicative_> hrumph: I think the second is better, but maybe addLineNum should be called something more like addingLineNumIfNeeded
19:32:51 <hrumph> i thought it was a good idea. i just adapted the idea of the guard function to another context
19:33:03 <hrumph> applicative_: why is the second better?
19:33:04 <monochrom> I am wondering why "return (parseLine line x)" vs "parseLine line n"
19:33:32 <byorgey> edwardk: thanks for the heads up re: semigroups, but I was already notified by packdeps =)
19:33:35 <monochrom> that one is no longer the question of "better". they should have totally different semantics
19:33:39 <edwardk> heh
19:33:54 <byorgey> edwardk: I plan to update packages tomorrow or Tuesday
19:34:09 <elliott> the second one seems to inline fmap for no reason
19:34:16 <shachaf> monochrom: No, there is addLineNum $ on the outside.
19:34:27 <elliott> oh, I see what it's doing.
19:34:28 <hrumph> parseLine line is not an either
19:34:39 <elliott> bah, I give up on passing judgement on these
19:34:41 <hrumph> validateLine is used to check that i can parse the line
19:34:45 <shachaf> Anyway I wouldn't write it either of those ways.
19:34:53 <edwardk> byorgey: np. just binging through updates today, so i figured i'd mention it ;)
19:35:12 <monochrom> what is the type of parseLine?
19:35:12 <hrumph> shachaf:  ok whichi s the better of the two ways and how would you do it?
19:35:37 <Tehnix> jochu: a whole lot, i can try and paste the output
19:35:46 <shachaf> hrumph: If you pasted a complete (short, self-contained) code example that people could run on their own, you would probably get better responses.
19:35:48 <hrumph> monochrom parseLine :: String -> Int -> Row
19:35:56 <monochrom> what is Row?
19:35:58 * hackagebot ad 3.3.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.3.1 (EdwardKmett)
19:36:00 * hackagebot ad 3.3.1.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.3.1.1 (EdwardKmett)
19:36:19 <glguy> Could this be called "bikeshed golfing"?
19:36:22 <hpaste> Hrumph pasted “Row definition” at http://hpaste.org/80414
19:36:31 <applicative_> then its a return like the first one.
19:36:52 <monochrom> ok, I fail to understand how "do { ... ; parseLine line n }" type-checks
19:36:54 <hpaste> Tehnix pasted “hsfevents failing to install” at http://hpaste.org/80415
19:37:18 <shachaf> Oh, true.
19:37:37 <Tehnix> jochu: this is what gets thrown at me --> http://hpaste.org/80415 :/
19:37:58 <hrumph> hpaste: that's ebcause he changed the type of the function too saying it might need to return a maybe
19:38:07 <hrumph> hpaste: i mean an either
19:38:13 <hrumph> hpaste: but i don't understand that
19:38:30 <Clint> hpaste: calm down
19:38:39 <hrumph> hpaste: the point of the guard is that everything should be validated before the parsing occurs so there is no need to return an either after parsing
19:39:33 <applicative_> Tehnix: hm, I just built hsfevents without trouble
19:39:35 <hrumph> yes everyone is right i didn't even think about the type change. that's why he seesed using the <*> and <$> idiom
19:39:49 <hrumph> ok that's another thing i don't understand if everything is validated shouldn't the guard work?
19:39:52 <monochrom> um, why are you discussion with hpaste? :)
19:39:59 <hrumph> sorry
19:39:59 <monochrom> s/ion/ing/
19:40:20 <hrumph> when i run the program it runs perfectly with no glitches
19:40:35 <hrumph> so i didn't understand that criticism and i still don't
19:41:48 <monochrom> I go with the first one. this is even if the second one gets its "return" back. in fact, "maybeGuard (addLineNum <$> validateLine line)" should be one single function call "validate line"
19:42:18 <Tehnix> applicative_: hmm, this seems pretty local to me then :/
19:42:24 <monochrom> err, "validate n line" since it needs n
19:42:34 <Tehnix> applicative_: may I ask what OS you're on?
19:42:38 <applicative_> Tehnix: maybe, I also built the test.hs module
19:42:55 <applicative_> Tehnix: oh, I am using the out of date 'leopard'
19:43:29 <applicative_> Tehnix: I am also using a 32 bit ghc but this doesnt seem like that kind of error
19:43:44 <Tehnix> applicative_: Ah, I'm on Mountain Lion.. I can't recall if I've updated XCode recently (I could imagine that it would toy with such files)
19:44:02 <Tehnix> applicative_: I'm also on the 32 bit GHC (afaik)
19:44:18 <applicative_> Tehnix: I'm also using an old  XCode.
19:44:22 <hrumph> monochrom: why should it be a single function call?
19:45:17 <hrumph> monochrom:  ok i'll think about adding n to validate line
19:45:36 <Clint> what does PINNED mean in an .hp file?
19:45:36 <monochrom> checks line content. if content is wrong, "throw an exception with error message"
19:47:00 <monochrom> the second one goes: check line content. if content is wrong, throw an exception with incomplete error message. then, have an outer exception handler to "re-throw the exception but now complete the error message". frankly that's strange to me
19:47:03 <hrumph> monochrom: that's bassically what validate line does except it returns a maybe because no result value is needed at that point. only Nothing for OK and Just errormsg if bad
19:47:09 <Tehnix> applicative_: Think this would be a bug report?
19:47:54 <hrumph> so i'm using the maybe like a boolean that's why i used maybeguard and it makes sense that the line validator doesn't know about the line number since the line number is meta data at that point
19:48:25 <jochu> Tehnix: Hm, I'm on mountain lion with 64-bit ghc. My XCode is up to date, I think. So it could be XCode?
19:49:21 <Tehnix> jochu: Just to check, my XCode is Version 4.5 (4G182), what's yours?
19:50:14 <jochu> Tehnix: Hm, 4.5.2 with latest command line tools.
19:50:48 <Tehnix> jochu: Hmm, seems mines outdated then? I'll try and update it tomorrow, hopefully it'll solve the problem
19:50:56 <Tehnix> thanks for the help so far though! :)
19:51:11 <jochu> Tehnix: Specifically, I'd make sure that command line tools are updated.
19:51:49 <Tehnix> jochu: Yeah, I'd also imagine that that would be the culprit if it were to be any
20:00:50 <applicative_> Tehnix: if you try cabal configure and cabal build --verbose=3 within the source, then I expect the last act before gcc starts complaining will be revealing
20:06:21 <kristof> Is there a project to make Haskell bindings to Wayland yet?
20:06:32 <kristof> Because I'm totally going to start it if there's nothing like that out there.
20:07:01 <hrumph> when is wayland going to be default in fedora?
20:07:04 <hrumph> that could be years
20:07:07 <tgeeky_> @google haskell bindings to wayland
20:07:09 <lambdabot> http://coderedd.net/r/linux/comments/sn3oe/phoronix_adwc_a_tiling_window_manager_for_wayland/
20:07:09 <lambdabot> Title: coderedd.net
20:07:22 <tgeeky_> no!
20:07:39 <kristof> tgeeky_: Been doing some research, couldn't find anything.
20:07:56 <tgeeky_> kristof: I was just going for the cheap embarassment factor, which backfired.
20:08:31 <hrumph> someone needs to make a bitcoin client in haskell if it hasn't been done already
20:09:35 <`nand`> this? http://hackage.haskell.org/package/network-bitcoin
20:09:48 <kristof> tgeeky_: That would have worked, too, if I hadn't gooogled already.
20:14:44 <kristof> So there's nothing out there, huh? :)
20:14:54 <pharaun> that's one pain in the ass page to read
20:15:01 <kristof> Guess I'll be mailing people on the xmonad mailing list to see who's interested
20:15:39 <hrumph> kristof: why is it a good idea?
20:16:08 <kristof> hrumph: Huh?
20:16:16 <hrumph> wayland and haskell
20:16:27 <hrumph> what use cases can you think of?
20:16:48 <kristof> hrumph: Explain to me how you're going to port XMonad to Wayland without Haskell bindings to the Wayland Library.
20:17:11 <hrumph> i thought that wayland could simulate X
20:17:21 <hrumph> mostly anyway
20:17:56 <elliott> you can run an X server that outputs to Wayland
20:18:00 <elliott> not really the same thing
20:18:10 <elliott> (or do I mean X client...)
20:18:14 <elliott> (no, server)
20:22:31 <kristof> hrumph: Yes, it can. But you're stuck with the same X library protocol.
20:22:50 <hrumph> ok maybe it is a good idea
20:23:04 <kristof> hrumph: The goal is to phase out the X Server in all circumstances except for legacy support and network transparency.
20:23:05 <epta> Why there is no mapWithKey function in Data.HashMap.Strict module?
20:23:14 <kristof> Personally, if you're operating a remote system, you should be using a teletype ANYWAY.
20:23:34 <Nereid> epta: because lens can do that.
20:23:55 <Nereid> ;)
20:24:00 <kristof> hrumph: Remember that even though XCB exists, X11 code is sometimes even a decade old.
20:24:01 <epta> O, there is traverseWithKey
20:24:07 <Nereid> oh, that'll do it.
20:24:11 <kristof> It had to be pruned. So that's where Wayland comes in.
20:24:19 <edwardk> epta: given traverseWithKey you can build mapWithKey using Identity
20:24:25 <epta> Uguu
20:24:36 <edwardk> runIdentity . traverseWithKey (\i -> Identity . f i)
20:24:44 <edwardk> thats pretty much what we do in lens ;)
20:25:19 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Indexed.hs#L565
20:25:26 <epta> Lens advertisements are everywere :[
20:25:35 <elliott> lens is everywhere
20:25:36 <edwardk> hah
20:25:57 <Nereid> edwardk: do you have a highlight on lens or something? :)
20:26:00 <edwardk> thats because for some reason most people have problems accessing data, working with containers, or constructing stuff. this is what lens is designed for
20:26:05 <edwardk> Nereid: among others
20:26:11 <Nereid> haha
20:26:26 <edwardk> i toggle it on and off based on spam or abuse, etc.
20:27:05 <tgeeky_> edwardk is so dedicated to lenses that even his glasses are zygohistopremorphism lenses
20:27:06 <elliott> lens lens lens lens lens
20:27:06 <epta> Highlight is overkill, there should be something like hiccup
20:28:19 <hrumph> kristof at any event wayland as mainstream is a long way off and nvidia will never support it
20:34:23 <edwardk> epta: its not as bad as it used to be 95% of the lens chatter has moved to #haskell-lens these days ;)
20:34:44 <hrumph> should i be reading up on lenses?
20:34:52 <hrumph> i haven't read about them yet
20:35:00 <hrumph> they haven't come up in anything i've done
20:35:03 <epta> hrumph: start with video
20:35:12 <Nereid> edwardk: that means there's 19 times as much lens chatter there than here!
20:35:13 <edwardk> hrumph: lens.github.com has a tutorial and https://www.youtube.com/watch?v=cefnmjtAolY&hd=1 provides a 2 hour crash course
20:35:17 <hrumph> epta: are they generally useful?
20:36:27 <tgeeky_> I called the recent work of edwardk et. al "the first lens revolution"
20:37:50 <edwardk> there are still a few holdouts in the hills who haven't yet found out that their side lost.
20:37:54 <elliott> hrumph: probably they have come up in almost everything you've done
20:37:58 <elliott> but you haven't realised you wanted them :)
20:38:06 <edwardk> they come down and ask questions like "what are lenses?"
20:38:14 <epta> @pl \v' w' -> Identity $ l v' w'
20:38:14 <lambdabot> (Identity .) . l
20:39:21 <rntz> @pl \x y z q -> q y z x
20:39:21 <lambdabot> flip (flip . (flip .) . flip . flip id)
20:39:37 <rntz> right. this is why I don't like forth.
20:39:39 <hrumph> i've now played around with monoids, monad transformers, monads. traversals, folds, functors, and applicative functors and other related things. that's enough learning for the time being
20:39:54 <shachaf> rntz: Concatenative languages tend to be better at @pling than Haskell, don't they?
20:39:59 <hrumph> i want to go ahead with building a web site in yesod. i can learn about lenses later
20:40:02 <shachaf> Except they force it on you much more.
20:40:36 <tgeeky_> hrumph: if you're a do-er and not a learn-er first, then do that
20:40:37 <rntz> shachaf: most concatenative primitives can be written as haskell functions, you just end up having to use (.) a lot to use them
20:41:00 <rntz> but yeah, the forcing it on you bit is the bleh
20:41:14 <hrumph> tgeeky_: i've put aside a lot of doing for this haskell learning. i've had enough learning for sure
20:41:30 <rntz> @pl \f x -> f x x
20:41:31 <lambdabot> join
20:41:36 <rntz> ... oh, that's cute
20:41:58 <tgeeky_> @pl \r e p l -> p e r l
20:41:58 <lambdabot> flip (flip . flip id)
20:41:59 <fragamus> does this suck:  newVal <- (foldl' (<=<) f (replicate 1000 f)) val
20:42:06 <edwardk> i don't know that i've ever said "i've had enough learning for sure" ;)
20:43:41 <hrumph> edwardk: its true. i can spend more time learning about more and more things i can try to do something with the limited knowledge that i've got. it will be better for me just to do something then pick up more knowledge later
20:44:01 <tgeeky_> hrumph: it's OK. edwardk isn't one of us.
20:46:16 <elliott> edwardk: isn't that what you say when you engulf the universe
20:46:22 <elliott> or has that not happened yet
20:46:49 <edwardk> elliott: there are still some holdouts in andromeda
20:46:53 <tgeeky_> when edwardk hits his lowest entropy state, we all go supernova
20:47:34 <tgeeky_> lots of crap jokes tonight. I'll try less hard
20:48:27 <lpsmith> is there an easy way to --ddump-minimal-imports for a cabal package?
20:50:13 <shachaf> rntz: The other day I had the opportunity to use the dual!
20:50:19 <shachaf> \f x y -> f (mappend x y)
21:00:45 <Moggle> @src tell
21:00:45 <lambdabot> Source not found. It can only be attributed to human error.
21:00:51 <Moggle> accursed thing
21:01:08 <shachaf> You know about Hoogle, right?
21:01:18 <shachaf> Hoogle has this nice propery where it actually works.
21:01:27 <Moggle> but the lambdabot is so convenient
21:01:28 <Moggle> :(
21:01:34 <Moggle> @where hoogle
21:01:34 <lambdabot> http://haskell.org/hoogle
21:01:37 <Nereid> lambdabot has hoogle
21:06:59 <monochrom> @hoogle tell
21:06:59 <lambdabot> Control.Monad.Trans.RWS.Lazy tell :: (Monoid w, Monad m) => w -> RWST r w s m ()
21:06:59 <lambdabot> Control.Monad.Trans.RWS.Strict tell :: (Monoid w, Monad m) => w -> RWST r w s m ()
21:06:59 <lambdabot> Control.Monad.Trans.Writer.Lazy tell :: (Monoid w, Monad m) => w -> WriterT w m ()
21:07:08 <monochrom> That may be some consolation for you
21:07:52 <davesque_> is there some kind of way to inspect the number of thunks that an expression is generating.  like if you're trying to find appropiate places to force WHNF evaluation in your program?
21:08:11 <monochrom> even if lambdabot were perfect, "@src tell" would be ambiguous. class method, so what you do mean by "@src tell"? which instance do you want?
21:08:11 <davesque_> first sentence lacking question mark :P
21:08:25 <roadfish> @WHNF
21:08:25 <lambdabot> Unknown command, try @list
21:08:50 <roadfish> @list WHNF
21:08:50 <lambdabot> No module "WHNF" loaded
21:09:00 <monochrom> possibly profiling
21:09:03 <shachaf> monochrom: But lambdabot is not perfect, and as such may answer class methods with concrete source.
21:09:24 <shachaf> Also, this particular class method has a natural implementation in terms of another one.
21:09:28 <roadfish> lambdabot: WHNF
21:09:35 <davesque_> what are some of the profiling tools that people use?
21:11:43 <davesque_> i'm asking because i'm often seeing places where people are using bang patterns of the bang function application and i wish i could understand more clearly why its use would be appropriate in those cases.
21:11:54 <davesque_> bang patterns or the bang...
21:13:12 <roadfish> davesque_: do you mean this bang: [2,7,13]!!1
21:13:24 <tgehr> he means f !a = ...
21:13:43 <roadfish> @!
21:13:43 <lambdabot> Maybe you meant: . ? @ v
21:14:06 <roadfish> @hoogle !
21:14:06 <lambdabot> Prelude (!!) :: [a] -> Int -> a
21:14:06 <lambdabot> Data.List (!!) :: [a] -> Int -> a
21:14:06 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
21:14:20 <tgehr> (it means call by value)
21:14:49 <jochu> roadfish: BangPatterns is a GHC extension, http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html
21:16:12 <davesque_> anyone have any thoughts or insights?
21:16:24 <tgehr> @davesque_: GHC has a built-in profiler
21:16:24 <lambdabot> Unknown command, try @list
21:17:01 <davesque_> mkay
21:17:45 <tgehr> http://book.realworldhaskell.org/read/profiling-and-optimization.html <- presumably relevant
21:18:30 <jochu> davesque_: I was just about to say what tgehr said. It's a good resource.
21:19:21 <statusfailed> clckwrks seems pretty cool
21:19:24 <statusfailed> Has anyone used it?
21:20:28 <jnhnum1> does anybody know if there is an implementation of monad views? as in http://users.ugent.be/~tschrijv/Research/papers/icfp2011.pdf
21:20:33 <davesque_> cool, thanks!
21:41:04 * hackagebot lens 3.7.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.7.2 (EdwardKmett)
21:46:04 * hackagebot mcmc-synthesis 0.1.0.5 - MCMC applied to probabilistic program synthesis  http://hackage.haskell.org/package/mcmc-synthesis-0.1.0.5 (TikhonJelvis)
21:53:48 <Moggle> just to be absolutely clear on do notation, every line is basically wrapped in a >>= which goes to the next line, right? If you do something like x <- getLine, then it compiles to "getLine >>= \x" . If you don't have a <- on the line, though, it compiles to "whatever _ ->"?
21:54:13 <Moggle> err, "whatever >>= _ ->
21:54:31 <shachaf> There's a \ there.
21:54:32 <shachaf> But yes.
21:54:46 <shachaf> You can ask lambdabot like this: /msg lambdabot @undo do { x <- y; z }
21:55:01 <Moggle> Thanks!
21:55:08 <Moggle> You're always incredibly helpful shachaf.
21:56:15 <statusfailed> shachaf++
21:56:23 <shachaf> @karma+ java
21:56:23 <lambdabot> shachaf's karma lowered to 32.
21:56:25 <shachaf> @karma+ java
21:56:25 <lambdabot> shachaf's karma lowered to 31.
21:56:25 <shachaf> @karma+ java
21:56:25 <lambdabot> shachaf's karma lowered to 30.
21:56:37 <thoughtpolice> what
21:56:42 <shachaf> Moggle: You can also read the Haskell report, or most introductions, which usually list out the rules exactly.
21:57:23 <shachaf> The report is not as scary as it might sound: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
21:59:20 <Moggle> ohey
21:59:29 <Moggle> this looks vaguely like Bachus-Naur
21:59:31 <Moggle> ... it probably is
21:59:39 <Moggle> I can't even remember how to spell that.
22:00:43 <Moggle> Wikipedia informs me it's Backus-Naur and I'm an idiot.
22:01:17 <startling> [citation needed]
22:09:18 <epta> What parsec combinator should I use to parse list of items without knowing how much they are repeated?
22:09:32 <epta> I used count when number of items was defined
22:09:40 <epta> And now I'm kinda confused
22:09:46 <croikle> many?
22:10:22 <startling> how do you decide how many there are?
22:10:58 <epta> Yeah, many looks fine
22:11:14 <tgehr> startling: that's the combinator's job
22:11:53 <startling> tgehr: no, it's epta's job
22:12:21 <tgehr> startling: epta's job is to write the program
22:12:51 <startling> tgehr: yes, and decide what combinators to use
22:13:12 <startling> anyway, whatever, their problem is solved.
22:13:26 <epta> Yep
22:36:06 * hackagebot array-forth 0.2.0.3 - A simple interpreter for arrayForth, the language used on GreenArrays chips.  http://hackage.haskell.org/package/array-forth-0.2.0.3 (TikhonJelvis)
22:44:15 <jfischoff> how does or doesn't automatic differentiation handle case statements in functions?
22:44:21 <tac> I'm having issues structuring this bit of code
22:44:36 <tac> I have some global state in my application. So I wrap everything in a StateT IO MyState monad
22:44:44 <jfischoff> I imagine it is not converting them to delta functions
22:44:49 <tac> However, I have an XML RPC server running
22:45:11 <Nereid> jfischoff: how would you even use case statements?
22:45:21 <tac> And I don't know how to "promote" the XML RPC server to take a list of (String, StateT IO MyState) handlers instead of (String, IO) handlers
22:45:54 <donri> tac: fmap liftIO
22:46:06 * hackagebot array-forth 0.2.0.4 - A simple interpreter for arrayForth, the language used on GreenArrays chips.  http://hackage.haskell.org/package/array-forth-0.2.0.4 (TikhonJelvis)
22:46:20 <Nereid> I think he wants the reverse.
22:46:31 <donri> oh wait you want the inverse. i guess fmap execStateT?
22:46:32 <tac> Nereid: yeah
22:47:08 <jfischoff> Nereid: its just in a function I am taking the derivative of
22:47:15 <jfischoff> using ad
22:47:17 <tac> I need the RPC server to thread the state, though
22:47:23 <tac> I'm not sure this is possible :(
22:47:24 <Nereid> jfischoff: sure, and doesn't ad need to take a polymorphic function?
22:47:26 <jfischoff> I don't know if they have an effect at all
22:47:36 <jfischoff> yes
22:48:40 <donri> tac: can't you run the rpc server inside the state monad?
22:49:05 <Nereid> jfischoff: but you can't make a polymorphic function that inspects its argument.
22:49:26 <tac> flip runStateT server $ liftIO $ serve 8000 [("bot.start", fun (start)]
22:49:32 <tac> This is my progress so far
22:49:38 <tac> start :: ServerM ()
22:49:38 <jfischoff> Nereid: no not at all
22:49:45 <Nereid> exactly.
22:50:24 <tac> Obviously, it's not a finished line yet (explaining the redundant liftIO)
22:50:41 <jfischoff> will ad always work, regardless of the function is another way of posing my question.
22:50:43 <tac> I feel like I need to "close" over the server somehow
22:50:49 <jfischoff> I am wondering if there are limitations
22:51:03 <jfischoff> that I can hit without realizing it
22:51:32 <jfischoff> now that i think about it case should be a problem
22:51:38 <elliott> automatic differentiation is "general"
22:51:44 <elliott> probably edwardk is better at explaining it than me :P
22:51:57 <Nereid> jfischoff: the type system will prevent you from using a function that uses case
22:52:12 <jfischoff> i think case is okay
22:52:20 <donri> tac: make 'fun' run in the state?
22:52:48 <jfischoff> well...
22:53:02 <jfischoff> i don't know
22:53:14 <Nereid> just try it ;)
22:53:49 <Nereid> well
22:54:06 <tac> @hoogle liftIO
22:54:06 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
22:54:06 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
22:54:06 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
22:55:11 <Nereid> hmm
22:56:00 <jfischoff> it works well enough
22:56:10 <jfischoff> its not the problem I am having
22:56:29 <jfischoff> my problem is my own :p
23:01:40 <tac> I think the best I can do this, I will end up unable to thread my state properly :(
23:02:06 <tac> With StateT at least...
23:08:33 <tac> I think ReaderT State IO makes more sense here
23:08:51 <tac> and my State contains an IORef (Maybe Foo) rather than a Maybe (IORef Foo)
23:11:08 * hackagebot parsers 0.4 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.4 (EdwardKmett)
23:12:59 <startling> edwardk: where does "parsers" fit into the ecosystem?
23:13:56 <edwardk> startling: trifecta is being rewritten to use parsers, but basically parsers provides a pile of parser combinators that are mostly combinator library neutral
23:14:12 <edwardk> and it provides the monad transformer support for them
23:14:38 <c_wraith> Wasn't that sort of your original intention for Trifecta?
23:14:46 <edwardk> so e.g. given a parsers instance for parsec (which i haven't bothered to write) you could apply monad transformers to parsec
23:15:02 <edwardk> c_wraith: its basically the guts of trifecta ripped out so trifecta can focus on error reporting
23:15:03 <startling> edwardk: oh, cool
23:15:19 <edwardk> ripping it out helped me shrink trifecta head by a factor of 10 or so ;)
23:15:25 <c_wraith> nice
23:22:56 <tac> @hoogle installHandler
23:22:56 <lambdabot> System.Posix.Signals installHandler :: Signal -> Handler -> Maybe SignalSet -> IO Handler
23:26:08 * hackagebot parsers 0.4.1 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.4.1 (EdwardKmett)
23:31:08 * hackagebot streams 3.1 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-3.1 (EdwardKmett)
23:36:09 * hackagebot graphs 0.4.1 - A simple monadic graph library  http://hackage.haskell.org/package/graphs-0.4.1 (EdwardKmett)
23:36:49 <AfC> I'm turning a ByteString into an Int. Right now I'm doing
23:36:51 <AfC>    read $ S.unpack x
23:37:18 <AfC> and, *surprise*, it's chewing up allocation. What's a better way to do that parse?
23:37:43 <c_wraith> AfC: http://hackage.haskell.org/package/bytestring-lexing
23:38:29 <AfC> c_wraith: ah. Cheers
23:42:49 <startling> edwardk: going through the dependency chain? better hope it's acyclic
23:43:02 <edwardk> heh
