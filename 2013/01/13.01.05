00:05:30 <glguy_> Osa1: it just prevents values from being returned by runST from referring to that s parameter
00:07:18 <glguy_> E.g. runST (newSTRef ())
00:08:44 <osa1> ok let's say I have a newtype like newtype MyState s a = MyState { runState :: StateT (SomeState s) (ST s) a } deriving (Functor, Monad)
00:09:00 <osa1> here can I mutate SomeState's mutable data structure in MyState () functions ?
00:10:31 <glguy_> Sure,
00:12:22 <Saizan> something of type MyState () Foo can't be converted to something you can pass to runST
00:13:05 <Saizan> because you are going to get a ST () ... out of it
00:13:05 <glguy_> Needs to work for all 's' parameters
00:13:27 <glguy_> I don't think he meant the s was ()
00:13:54 <glguy_> I was guessing he accidentally omitted it
00:13:54 <Saizan> glguy_: well, that's how osa1 defined MyState
00:14:15 <Saizan> ah, i see
00:14:52 <Saizan> osa1: by MyState (), did you mean MyState s () or MyState () SomethingElse ?
00:15:39 <osa1> Saizan: it should be MyState s ()
00:15:51 <glguy_> It'd be slightly tricky to make the initial SomeState since you couldn't populate it with any ST stuff
00:16:39 <glguy_> Have to have either optional stuff or leave our undefined art the start
00:17:14 <glguy_> I'm typing on a touch screen right note, for the record :)
00:17:16 <osa1> ok let me play with this for a while
00:18:52 <glguy_> Or I guess you could do the run state inside a run ST so you could create the initial state value
00:22:02 <johnw> does Haddock do em-dashes, or should I include those as Unicode?
00:22:38 <johnw> Unicode seems to work
00:39:37 <osa1> glguy_: so there's no way to populate MyState without using undefined ?
00:56:58 <orzo> I need to print some haskell source code files to paper for somebody for actually reading on paper...  I have used a2ps before to format text files in printed form, but i'm interested in alternatives.  Anybody got ideas for me?
00:57:18 <orzo> (debian/gnu linux is my platform)
00:57:54 <`nand`> orzo: if you find anything neat, I'd be interested; I need to print out some source code in the near future as well
00:58:31 <orzo> okay
00:58:40 <mm_freak_> orzo: check out pandoc
00:59:00 <mm_freak_> if you have literate haskell code, it can turn it into about anything you want
00:59:25 <mm_freak_> including syntax-highlighted HTML
01:00:04 <orzo> unfurtunately, its not in literate style
01:00:23 <orzo> i just read a description of pandoc and it didn't mention syntax awareness for haskell
01:01:00 <orzo> not that that's a deal breaker or anything
01:01:03 <johnw> orzo: I use pandoc for my blog, and it's aware of several different languages, you just have to indicate it
01:01:27 <johnw> in the case of literate Haskell, you don't have to indicate anything manually
01:01:45 <orzo> oh i see
01:01:52 <johnw> orzo: here's an example: https://github.com/jwiegley/posts/blob/master/Meta-programming%20with%20the%20Free%20Monad/FreeMonad.lhs
01:02:14 <johnw> note that the HIDE and \# stuff are my own private extensions to Pandoc
01:02:29 <slack1256> the strictness analyzer is a set of heuristics or is a cool theory of detecting strictness on functions?
01:03:43 <orzo> does htat link have a pdf or ps output file generated by pandoc?
01:03:58 <orzo> or just an examploe of markup
01:04:05 <johnw> orzo: I only generated HTML from it
01:04:26 <johnw> http://newartisans.com/2012/08/meta-programming-with-the-free-monad/
01:04:41 <johnw> as you can see, the code gets colorized
01:05:52 <orzo> slow link
01:06:03 <johnw> hmm.. i wonder why
01:06:58 <orzo> i'm not sure colorizaiton is a good idea on paper
01:07:12 <orzo> i got the link to load now
01:07:35 <johnw> the server isn't stressed at all
01:07:49 <M30W> Is there a simple way to say `f x` but with x first?
01:07:59 <orzo> who knows, maybe there was congestion somewhere inroute
01:08:07 <hrumph> in ghci how do i simulate an end of file?
01:08:17 <johnw> M30W: there's nothing in the standard Prelude to do that
01:08:19 <hrumph> when entering from the keyboard
01:08:23 <M30W> johnw: Okay
01:08:29 <johnw> M30W: but lately it's being called & by the lens library
01:08:36 <johnw> x & f
01:08:58 <M30W> Ha lenses; watched a video about them the other day; Interesting.
01:09:09 <johnw> hrumph: C-d?
01:09:15 <M30W> Thank-you johnw
01:09:23 <edwardk> :t (&)
01:09:24 <lambdabot> a -> (a -> b) -> b
01:10:09 <hrumph> x -: f = f x according to lyah
01:10:22 <hrumph> try it out
01:10:52 <orzo> :t (-:)
01:10:54 <lambdabot>     Not in scope: `-:'
01:10:54 <lambdabot>     Perhaps you meant one of these:
01:10:54 <lambdabot>       `-' (imported from Prelude), `.:' (line 111),
01:10:58 <orzo> heh
01:11:50 <hrumph> wait its defined in the book
01:11:53 <hrumph> my bad
01:12:05 <hrumph> i never tried it myself
01:12:14 <M30W> edwardk: What's the actural source for that (&) ?
01:12:23 <edwardk> x & f = f x
01:12:31 <M30W> Ha
01:12:40 <M30W> let x & f = f x
01:12:41 <M30W>  ?
01:12:57 <edwardk> M30W: with an appropriate fixity declaration, yes
01:13:01 <M30W> Thankyou
01:13:14 <M30W> edwardk: Fixity ?
01:13:23 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Combinators.hs#L50
01:13:38 <edwardk> infixl 1 &   is a few lines above that
01:13:46 <M30W> Ah yes
01:14:14 <edwardk> the infixl declaration makes it bind 'just slightly tighter than & and with the opposite fixity so it can chain
01:14:50 <edwardk> > ("hello","world") & _1 .~ "no" & _2.traverse %~ toUpper
01:14:51 <lambdabot>   ("no","WORLD")
01:14:54 <M30W> edwardk: Is it encouraged for just using lense pieces (just that one) without the whole library as it doesn't need it. Or is it more suggested to install and have no dup code (Just import the &)
01:15:33 <edwardk> M30W: we tried to get (&) standardized by adding it to Data.Function, but it turned into a disturbing and unnecessarily contentious issue, so we dropped it
01:15:51 <edwardk> M30W: so at this point *shrug*
01:16:00 <edwardk> it soured me on standardization for a while =P
01:16:11 <M30W> Ha
01:16:16 <edwardk> lens is a pretty big dependency, but it brings with it a lot of power
01:16:23 <johnw> edwardk: what is the expiration date on your sourness?
01:16:26 <BMeph> edwardk: 'slightly tighter than '...$...right? ;)
01:16:26 <M30W> So, I'll just add to the code w\o the whole library.
01:16:34 <M30W> Need so little of it ;)
01:16:49 <edwardk> BMeph: 2-3 obsessions usually ;)
01:16:57 <donri> edwardk: and then you see people using it like this http://izbicki.me/blog/nuclear-weapon-statistics-using-monoids-groups-and-modules-in-haskell
01:17:07 <edwardk> BMeph: er yes =)
01:17:51 <edwardk> donri: heh
01:18:03 <edwardk> nuclear weapons, lens, obvious fit.
01:18:20 * M30W is thankful he had vim open XD ran rm instead or 'runhaskell'
01:18:21 <edwardk> donri: not sure quite how they get a group out of gaussians, but hey
01:18:26 <M30W> of *
01:18:56 <edwardk> 'subtraction of gaussians' doesn't work like as i understand it
01:19:10 <donri> edwardk: does http://izbicki.me/blog/gausian-distributions-are-monoids explain it maybe?
01:20:01 <M30W> edwardk: a & f x = f a x -- Is there anything in the lenses that does that? Also, should I change character concidering it's of different use (even tho I don't have lenses here)
01:20:19 <M30W> Ad invalid code too..
01:20:25 <donri> is that (??)
01:20:44 <edwardk> donri: i buy everything through the monoid
01:21:08 <edwardk> :t (??)
01:21:09 <lambdabot>     Not in scope: `??'
01:21:09 <lambdabot>     Perhaps you meant one of these:
01:21:09 <lambdabot>       `^?' (imported from Control.Lens),
01:21:12 <edwardk> shucks
01:21:15 <edwardk> thats not on lambdabot yet
01:21:38 <edwardk> in lens head.   x ?? y $ z = x z y
01:21:46 <edwardk> not quite what you asked for
01:22:04 <edwardk> you can construct a pair of functions that get you it
01:22:07 <edwardk> its a fun exercise
01:22:13 <edwardk> a -: f :- b
01:22:23 <edwardk> well one function and one constructor
01:22:29 <edwardk> another way to do it avoids the constructor
01:22:34 <edwardk> a -| f |- b
01:22:36 <M30W> edwardk: a b c -> b a c -- How could this be done?
01:23:03 <edwardk> M30W: you need two functions or a function and a constructor like that
01:23:07 <M30W> Ah I think I had it right just forgot to fix the definition.
01:23:27 <edwardk> a -: (f :- b)          or (a -| f) |- b
01:23:44 * M30W lost O.o
01:24:12 <edwardk> hrmm
01:24:51 * M30W just orders everything normally instead of reordering with tricks. :)
01:24:58 <edwardk> @ty 1 & (+) $ 2
01:25:00 <lambdabot> Num a => a
01:25:02 <edwardk> > 1 & (+) $ 2
01:25:04 <lambdabot>   3
01:25:16 <edwardk> > [1,2,3] & zip $ [4,5,6]
01:25:18 <lambdabot>   [(1,4),(2,5),(3,6)]
01:25:21 <edwardk> it just works
01:25:34 <edwardk> that has the right fixity to match my -|   |- definition above
01:25:44 <Lethalman> :t (&)
01:25:45 <lambdabot> a -> (a -> b) -> b
01:26:15 <edwardk> (&) flips that around to give you zip [1,2,3]      and then $ applies that to the remaining list
01:26:28 <edwardk> M30W: ^--
01:26:38 <M30W> Hmm interesting issue.. Is it worth using the exceptions to name errors just to send the client (tcp socket) "ACK N"
01:27:14 <Lethalman> :t ($)
01:27:15 <lambdabot> (a -> b) -> a -> b
01:27:49 <edwardk> :t ?x & ?f $ ?y
01:27:50 <lambdabot> (?x::a, ?f::a -> t1 -> t, ?y::t1) => t
01:28:31 <neutrino_> edwardk is quickly burning through every two-character combination
01:28:36 <neutrino_> :)
01:28:43 <edwardk> the ? isn't me ;)
01:28:53 <Lethalman> that ? doesn't work on ghci right?
01:29:05 <`nand`> sure it does
01:29:21 <edwardk> it does. you need :set -XImplicitParams
01:29:22 <`nand`> that is GHCi, even
01:29:26 <Lethalman> edwardk, ah ok
01:30:12 <Lethalman> cool
01:51:24 <orzo> pandoc is giving me a hard time with unicode symbols
02:03:06 <orzo> hm, pandoc is getting frustrating
02:03:11 <orzo> any other recommendations?
02:07:49 <orzo> pandoc does not seem to do well at all with my code heh
02:07:57 <orzo> even after overcoming the unicode issue
02:08:11 <orzo> better off with a2ps i guess
02:08:44 * osfameron is surprised that pandoc would have problems with unicode
02:08:59 <osfameron> given how much haskellites like their crazy unicode symbols instead of -> and \
02:11:01 <orzo> pandoc didnt really have problems when i changed --latex-engine to a more unicode friendly version rather than default pdflatex
02:11:09 <orzo> witht he unicode
02:11:30 <orzo> as the docs advised
02:11:39 <osfameron> ah, so the issue was actually latex?
02:11:52 <orzo> yes, but i figure pandoc should make the othe rengines default
02:11:54 * osfameron reallydoesn't like latex
02:11:56 <orzo> if avail
02:12:11 <orzo> anyway, my code is a messy jumble
02:12:21 <orzo> when run through pandoc
02:12:25 <osa1> where is definition of State# ? I searched base for that but looks like it doesn't have State# ?
02:12:45 <orzo> pandoc must require you to code with knowledge of pandoc or something
02:12:58 <orzo> i wanted something that would just do a reasonable job with arbitrary haskell files
02:13:13 <Lethalman> > T.splitOn
02:13:15 <lambdabot>   Not in scope: `T.splitOn'
02:13:20 <Lethalman> > Data.Text.splitOn
02:13:22 <lambdabot>   Not in scope: `Data.Text.splitOn'
02:13:23 <osfameron> orzo: oh, your input format is .hs files?
02:13:30 <orzo> yes
02:13:32 <osfameron> orzo: doesn't it default to markdown?
02:13:48 * osfameron hasn't looked at pandoc much recently
02:13:52 <orzo> well, its not clear from the manual what options im supposed to give it for .hs
02:14:04 <osfameron> well, I use it in my markdown -> html toolchain, but I haven't reread manpage for ages
02:14:04 <orzo> it looked like that was called "native"
02:14:09 <orzo> but i may be misunderstanding
02:14:55 <osfameron> orzo: front page of http://johnmacfarlane.net/pandoc/ doesn't suggest it will read haskell files
02:14:58 <Cale> osa1: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html#t:State-35-
02:15:10 <orzo> i just used a2ps and it seems to work fine with no options, and apparently it's haskell syntax aware
02:15:23 <Cale> osa1: The definition is just:  data State# s
02:15:23 <osfameron> orzo: if you put everything in a markdown code block, it would work, presumably
02:15:49 <osfameron> as it does "delimited code blocks with syntax highlighting"
02:17:58 <osa1> Cale: aha, so it's not in base. thanks.
02:18:37 <Cale> osa1: Yeah, it's GHC internal nonsense
02:19:13 <osa1> Cale: why do you call it nonsense ?
02:20:27 <Cale> GHC implements IO actions as "functions" which aren't really functions because they have side effects, and uses the State# RealWorld type as a way to keep the order of evaluation the same as the order of execution
02:20:44 <Cale> It's kind of an ugly hack
02:21:13 <Cale> (But it works)
02:22:40 <orzo> hm, a2ps did screw up the unicode, but its more readable than pandoc
02:23:40 <statusfailed> Is there a way to get type-safe tab completion in GHCi?
02:23:43 <statusfailed> that would be sweet
02:23:48 <statusfailed> type-aware*
02:26:33 <orzo> u2ps does unicode, but it lacks haskell syntax
02:40:50 <statusfailed> Where did the Either lenses move to?
02:40:57 <beaky> hello
02:41:05 <beaky> are there any unboxed STRefs?
02:42:54 <elliott> statusfailed: they're Prisms now
02:43:14 <statusfailed> elliott: ooh thanks :D
02:47:11 <beaky> how do you pronounce 'cabal'
02:48:44 <elliott> cabal
02:50:09 <beaky> atm I pronouce it like COBOL, but with an a instead of the first o
02:50:22 <beaky> 'kay-ball'
02:50:49 <Elench> Cat without t baal
02:50:53 <Elench>  Personally
02:50:55 <Yuu-chan> [ka'bal]
02:51:17 <donri> i'm swedish so kah baaaahl
02:51:25 <beaky> ah
02:51:58 <beaky> ghc compiles code pretty fast
02:52:04 <Landarzar> not like: kebel?
02:52:04 <beaky> or is it because my machine is fast
02:52:33 <beaky> it's faster than C++ even on my netbook so I guess ghc is just fast
02:52:47 <donri> ghc defaults to no optimization which is kinda fast to compile
02:53:03 <beaky> oh
02:53:11 <beaky> I thought cabal made GHC compile at -O2
02:53:20 <donri> cabal defaults to -O1
02:54:35 <beaky> how do i set it to -O2?
02:54:54 <beaky> seems i might need to recommpile the world :D
02:55:11 <donri> cabal install -O2
02:55:47 <elliott> beaky: you probably don't want -O2
02:55:56 <elliott> -O is sometimes a lot faster
02:55:59 <beaky> ah
02:56:03 <elliott> the default for cabal used to be -O2 but was changed to -O
02:56:30 <donri> packages that actually benefit from -O2 tend to enable it in their cabal file anyway
02:56:36 <beaky> right
02:58:42 <beaky> my app crashes when I don't use -O2 :(
03:01:22 <elliott> beaky: sounds like a GHC bug
03:01:28 <elliott> or your program is doing something incredibly evil
03:02:51 <beaky> right
03:03:23 <beaky> well, mine crashes with stac space overflow
03:03:26 <beaky> on large inputs
03:03:30 <beaky> when -O2 isn't enabled
03:04:11 <beaky> when no* optimization is made
03:04:22 <donri> does it happen even with -O1?
03:04:31 <beaky> checked and it ran fine with -O1 :D
03:04:49 <elliott> yeah, you should generally always use -O
03:05:05 <elliott> though there's a good chance you could make it not overflow the stack even without -O by adding a strictness annotation or two
03:05:13 <beaky> right
03:09:06 <beaky> does haskell have a standard hasthtable implementation? :D
03:09:55 <jozefg> beaky: No it has a balanced binary tree for map doesn't it? Pure hashtables are slow
03:10:16 <elliott> There is a mutable hash table in the standard libraries.
03:10:18 <elliott> It's not very good.
03:10:28 <elliott> The unordered-containers package is based on hashing (HAMT)
03:10:30 <beaky> ah :(
03:10:38 <elliott> and there's also http://hackage.haskell.org/package/hashtables for mutable hash tables
03:10:57 <elliott> Data.Map is fine, usually Data.HashMap from unordered-containers is more performant
03:11:06 <elliott> but you probably don't want a mutable hashtable most of the time
03:11:24 <beaky> i like Data.Map
03:15:19 <srhb> Are there mutable sets as well?
03:16:15 <elliott> srhb: I doubt it. You can just use a hashtable; it'll be a bit uglier but mutable hash tables are already pretty ugly
03:16:21 <elliott> HashSet is defined in terms of HashMap anyway
03:17:02 <srhb> elliott: Right. :)
03:19:58 <beaky> :t (<|>)
03:20:00 <lambdabot> Alternative f => f a -> f a -> f a
03:23:18 <statusfailed> hmmm, this is probably a dumb question, but how do I get a Foo out of a Form m v Foo using digestive-functors?
03:26:08 <elliott> statusfailed: I think using http://hackage.haskell.org/packages/archive/digestive-functors/0.5.0.4/doc/html/Text-Digestive-View.html
03:26:14 <elliott> maybe https://github.com/jaspervdj/digestive-functors/blob/master/examples/tutorial.lhs will help?
03:26:21 <elliott> you have "postForm :: Monad m => Text -> Form v m a -> Env m -> m (View v, Maybe a)" at least
03:26:43 <statusfailed> I think i've missed the point of the library actually :\
03:27:19 <elliott> statusfailed: well, if a (Form m v Foo) is a form whose final output is a Foo, then you need to give it its input to get a Foo
03:27:31 <elliott> for instance if it has two text fields and constructs a tuple out of them, you need the text
03:27:45 <elliott> and since forms can do validation, there might not be a "Foo" for every input (since it could be invalid)
03:28:04 <jaspervdj> statusfailed: You need an additional library such as digestive-functors-snap or digestive-functors-happstack
03:28:26 <jaspervdj> these provide easy `runForm` combinators for the corresponding webserver
03:28:35 <statusfailed> Can I use it without generating the form template as a View? I just want to validate data
03:29:01 <statusfailed> s/templateHTML
03:30:11 <statusfailed> oh sorry, just checked out those functions- i'm following now
03:30:12 <jaspervdj> statusfailed: sure, it returns a (view, result) tuple and you can just discard the view
03:31:15 <statusfailed> Oh, but I could generate the View with blaze and then splice it in if I wanted to?
03:31:37 <statusfailed> instead of going full-heist, that is :)
03:36:18 <statusfailed> elliott, jaspervdj : thanks for your help :)
03:48:15 <statusfailed> speaking of digestive functors, what's the purpose of the "Maybe a" argument in Formlet?
03:49:27 <latermuse> is the normal data.bytestring library strict or lazy?
03:49:43 <latermuse> i understand it has both, but if i just import Data.Bytestring, will it be the lazy or strict version?
03:49:50 <elliott> strict
03:50:07 <latermuse> ahh gotcha. thanks
03:51:06 <Jafet> > Data.ByteString.pack (replicate (10^6) 0 ++ [undefined]) `seq` ()
03:51:07 <lambdabot>   Not in scope: `Data.ByteString.pack'
03:51:11 <Jafet> > BS.pack (replicate (10^6) 0 ++ [undefined]) `seq` ()
03:51:13 <lambdabot>   *Exception: Prelude.undefined
03:51:15 <Jafet> > BSL.pack (replicate (10^6) 0 ++ [undefined]) `seq` ()
03:51:17 <lambdabot>   ()
04:26:37 <absence> is there a way to "detect" recursion in an edsl, or do i have to add an explicit construct for it?
04:27:50 <elliott> you might be wanting observable sharing
04:29:20 <absence> ah, i have seen that mentioned. is there a good overview online?
04:31:26 <elliott> absence: there's a nice paper
04:31:45 <elliott> http://www.ittc.ku.edu/~andygill/papers/reifyGraph.pdf
04:33:05 <absence> elliott: thanks!
04:34:11 <merk_> is there an 'or' predicate combinator? it would take two predicates and return a function that returns true if either predicate returned true
04:34:53 <shachaf> liftA2 (||)
04:37:06 <merk_> :t liftA2
04:37:07 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
04:37:29 <merk_> :t liftA2 (||)
04:37:30 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
04:38:18 <merk_> I cant see how that is what I asked
04:38:57 <`nand`> what's a ‘predicate’?
04:39:22 <merk_> a -> Bool
04:39:27 <`nand`> then that's fine
04:39:33 <merk_> hmm
04:39:56 <`nand`> (->) r is Applicative
04:41:30 <Jafet> @pl \f g x -> f x || g x
04:41:30 <lambdabot> liftM2 (||)
04:42:06 <shachaf> lambdabot doesn't know that monads are outdated.
04:42:25 <merk_> outdated?
04:42:25 <Jafet> @src Monad
04:42:25 <lambdabot> class  Monad m  where
04:42:26 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
04:42:26 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
04:42:26 <lambdabot>     return      :: a -> m a
04:42:26 <lambdabot>     fail        :: String -> m a
04:42:50 <Jafet> shachaf: neither does base !
04:43:06 <kennyd> > liftA2 (||) isPunctuation isSpace ' '
04:43:07 <lambdabot>   True
04:43:33 <Jafet> > fix fail
04:43:34 <lambdabot>   ""
04:43:50 <merk_> cool. no idea how that works though
04:44:24 <merk_> > liftM2 (||) isPunctuation isSpace ' '
04:44:26 <lambdabot>   True
04:44:45 <`nand`> liftM2 = liftA2 for all legal Monad/Applicative instances
04:45:26 <Jafet> @src (->) Monad
04:45:26 <lambdabot> Source not found. It can only be attributed to human error.
04:45:52 <Jafet> @src Maybe Monad
04:45:52 <lambdabot> Source not found. Wrong!  You cheating scum!
04:45:52 <merk_> any reason to prefer one or the other when both work?
04:46:05 <`nand`> @src Maybe (>>=)
04:46:06 <lambdabot> (Just x) >>= k      = k x
04:46:06 <lambdabot> Nothing  >>= _      = Nothing
04:46:45 <merk_> > fmap (||) isPunctuation isSpace ' '
04:46:46 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
04:46:46 <lambdabot>              with actual type...
04:47:58 <Jafet> liftA2 is the two-argument version of fmap.
04:48:09 <merk_> can you rewrite this with just . and $ ?
04:48:39 <Jafet> Can you see why that is not possible?
04:49:20 <merk_> no. I am not even sure why it works. I have to read again applicative chapter (or monad chapter?)
04:52:59 <merk_> > (&&) <$> isPunctuation <*> isSpace ' '
04:53:01 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> GHC.Types.Bool'
04:53:01 <lambdabot>            ...
04:53:59 * hackagebot data-dword 0.2.2 - Stick two binary words together to get a bigger one  http://hackage.haskell.org/package/data-dword-0.2.2 (MikhailVorozhtsov)
04:54:10 <Lethalman> > ((&&) <$> isPunctuation <*> isSpace) ' '
04:54:12 <lambdabot>   False
04:54:14 <tom22931> Is there any collection in the standard library (?) that provides constant-time tests for element containment (e.g. hashset or bloom filter)
04:54:23 <merk_> Lethalman: thanks
04:54:30 <Lethalman> > (&&) <$> isPunctuation <*> isSpace $ ' '
04:54:31 <lambdabot>   False
04:54:37 <tom22931> I'm aware of solutions available via hackage.
04:54:47 <Lethalman> merk_, np, I'm learning such things as well, so... :)
04:55:07 <Jafet> Every data structure on a computer is technically constant time.
04:55:15 <merk_> so a function is a Functor, Monad and Applicative
04:55:27 <tom22931> Jafet: ?
04:55:50 <tom22931> Jafet: I'm talking about time asymptomtic in the number of elements in the collection.
04:56:09 <Jafet> Well, a computer can store a constant number of things in memory.
04:56:56 <Eelis> tom22931: i think Jafet is being a smartass. probably better to ignore him :)
04:57:28 <Jafet> Unfortunately, I agree
04:58:16 <byorgey> tom22931: no, there is nothing like that in the Haskell Platform
05:00:08 <statusfailed> What does the "name for the form" correspond to in digestive-functors-snap's runForm?
05:00:18 <statusfailed> is it the 'name' attribute on the HTML form?
05:00:51 <bitonic> tom22931: look at `unordered-containers', which really should be in HP
05:01:40 <bitonic> tom22931: everybody is using it so having it as a dependency is not a big deal
05:02:35 <merk_> any ($ '1) [isSpace, isPunctuation, isDigit]
05:02:58 <merk_> > any ($ '1') [isSpace, isPunctuation, isDigit]
05:02:59 <lambdabot>   True
05:03:03 <merk_> :)
05:19:29 <tom22931> bitonic, byorgey: Thanks. My no-hackage constraint was to minimise the cost of running it, for those I was demonstrating the code to.
05:20:05 <bitonic> tom22931: you don’t have to use hackage to use a package, you can simply redistribute it
05:20:58 <tom22931> bitonic: That's still more work than me putting code on a pastebin, and sending an URL. Or irc, for example.
05:21:31 <bitonic> tom22931: sure.  as I said we really should have that package in the platform
05:22:35 <DMcGill> I'm looking for some non-trivial problems to test my implementation of n-dimensional Newton-Raphson method. So far I'm using questions 90.5 and 90.6 from the end of this: http://www.math.chalmers.se/cm/education/courses/0405/ala-b/lectures/lecture1.pdf
05:23:05 <DMcGill> Does anybody have some nice questions (preferably with the Jacobean already calculated) to hand?
05:24:45 <osfameron> huh, is this #englishperioddrama ?
05:27:13 <elliott> yes
05:38:46 <cinimod> @seen byorgey
05:38:46 <lambdabot> Unknown command, try @list
05:38:51 <cinimod> @list
05:38:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:44:49 <cinimod> seen byorgey
05:48:37 <cinimod> byorgey: I am using BlogLiterately but it is ignoring my attempts to use [ghci]
05:55:33 <hiptobecubic> cinimod, @tell
05:55:36 <Lethalman> such a good example of unsafePerformIO, now I got it: http://www.reddit.com/r/haskell/comments/15ur0k/a_question_regarding_unsafeperformio/
05:55:58 <hiptobecubic> cinimod, assuming i guessed right, of course. otherwise ignore me :)
06:03:35 <cinimod> hiptobecubic: thanks
06:03:35 <osa1> does anyone know a virtual machine written in haskell ? can you tell me the name/webpage of it ?
06:04:20 <cinimod> @tell byorgey
06:04:20 <lambdabot> Consider it noted.
06:04:32 <cinimod> @tell byorgey I am using BlogLiterately but it is ignoring my attempts to
06:04:32 <lambdabot> Consider it noted.
06:04:32 <cinimod> 	  use [ghci]
06:10:43 <zomg> osa1: what do you mean a VM written in Haskell? Like a program like virtualbox?
06:11:38 <osa1> zomg: no I mean like JVM, an Erlang VM, a Python interpreter, a NES emulator etc.
06:11:45 <hiptobecubic> cinimod, "use [ghci]" will not be included in that message
06:12:06 <c_wraith> there's pugs
06:12:40 <osa1> c_wraith: great thanks
06:12:43 <osa1> I'm open to any other advices
06:13:09 <osa1> I'm looking for ways to implement a memory model efficiently
06:19:18 <covi> How can I express "parse any character" when using Parsec?
06:20:16 <jix> covi: anyChar in Text.Parsec.Char
06:21:51 <Guest23523> I'm trying to install darcs from hackage. Cabal cannot resolve the dependencies. Any advice?
06:21:59 <covi> jix: Thanks. I encountered this error (not sure which part of my program goes wrong):  *** Exception: fw.1696: hGetContents: invalid argument (invalid byte sequence)
06:22:28 <Guest23523> Also having trouble getting cabal-dev installed too
06:22:36 <mauke> covi: the file you're reading from has encoding errors
06:23:51 <covi> mauke: encoding errors? I am looking at the file, it does contain non-ascii characters. What should I do then
06:24:12 <mauke> fix the file or fix your code
06:24:23 <covi> mauke: right, how to fix my code?
06:24:29 <mauke> that depends on your code
06:24:30 <mauke> and the file
06:24:34 <mauke> and what you're trying to do
06:24:43 <mauke> also, you're not looking at the file. files aren't visible objects
06:24:47 <osa1> omg Text.Printf.printf takes varargs o_O
06:24:59 <covi> mauke: ok, so the incorrect character is displayed in my vim as '<82>'
06:25:21 <mauke> how do you know it's incorrect?
06:25:44 <covi> My program just tries to read *anything*, seperated by a delimiter, and write these anything to seperate files.
06:25:47 <covi> I don't
06:25:59 <mauke> how did you open the file?
06:26:08 <covi> mauke: readFile
06:27:44 <elliott> @hoogle Kleisli
06:27:45 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
06:27:45 <lambdabot> Control.Arrow newtype Kleisli m a b
06:27:45 <lambdabot> package Kleislify
06:28:17 <covi> mauke: can you point me to some other functions that might help?
06:28:44 <mauke> covi: ghc -e 'System.IO.localeEncoding'
06:28:47 <mauke> what does that say?
06:30:07 <covi> mauke: UTF-8
06:30:39 <mauke> ok, so apparently the file isn't valid UTF-8
06:31:01 <covi> mauke: right
06:31:15 <mauke> what do you want to do with such files?
06:32:29 <jix> covi: you can change the encoding using 'hSetEncoding handle latin1' but unless you have no control over the files encoding it's a good idea to just use utf8 everywhere
06:32:31 <covi> mauke: I just want to read anything verbatim in between a constant delimiter, and write these seperated chunks to seperate files, also verbatim (i.e. I don't want to correct the encoding)
06:32:50 <mauke> then you probably want to work with bytes, not characters
06:32:53 <jix> covi: if you are dealing with binary data though it's a better idea to work with bytestrings
06:32:55 <covi> Well, if I have to, I can preprocess the input files too
06:33:06 <mauke> so yeah, bytestring
06:33:26 <covi> ok i will try, thanks
06:34:12 <osa1> how does `bar s x = bar (s >> print x)` works in this code http://stackoverflow.com/questions/7828072/how-does-haskell-printf-work ? it takes one parameter in class declaration but two parameters in one of the instance declarations ?
06:35:00 <mauke> it doesn't take one parameter in the class declaration
06:35:30 <s_kilk> how should the <*> function be pronounced?
06:35:58 <mauke> s_kilk: no
06:36:00 <jix> osa1: the instance is for something like 'a -> b', so if you substitute the r of the class declaration with a -> b you get two parameters
06:36:14 <mauke> osa1: do you understand 'flip id'?
06:37:08 <s_kilk> mauke: do you mean that it is pronounced like the word 'no' , or was that a statement of negation? :
06:37:24 <mauke> s_kilk: the latter
06:37:33 <s_kilk> care to elaborate?
06:37:56 <osa1> ok, got it. thanks
06:38:10 <mauke> <*> should not be pronounced
06:38:17 <osa1> ok so is it safe or it should be considered a bad hack ?
06:38:54 <s_kilk> i see. even so, I'd like to have something to go on for the voice-in-my-head when reading code
06:39:42 <jix> s_kilk: you could go with 'ap' since the 'ap' function is basically the same thing for monads
06:40:39 <s_kilk> jix: thanks, that sounds about right, i had already been pronouncing it to myself as 'applick'
06:41:05 <s_kilk> as in the first part of the word 'Applicative'
06:46:29 <covi> How can I inspect the type of a local variable?
06:47:38 <shachaf> Enable ImplicitParams and then stick a "?help v" somewhere.
07:00:21 <covi> My parseRaw function only returns a list of length 1, while the input file has several chunks of text seperated by the delimiter. What's wrong?    http://hpaste.org/80300
07:07:11 <lennart_> covi: "many anychar" does eager matching i suppose, so the delimiter is never tested
07:08:56 <lennart_> like with regular expressions: ".*x?" on "axa" will match the whole string, because ".*" alone can match all
07:10:30 <covi> lennart_: so what can I do in such situation? The range of characters that appear in the source file definitely excedes ascii chars...
07:22:53 <hiptobecubic> Why does haskell have such a nice community whereas ocaml is almost nonexistant? Obviously there isn't a "right" answer but it's an interesting thought
07:24:20 <zxq9> hiptobecubic: Haskell is on the low end of the Goldilocks point for a community -- which is unusual for a language.
07:24:37 <hiptobecubic> Is it because haskellers (until recently) were exclusively academics or academics-turned-professional so the wizards and pros have a teaching mentality instead of the necessarily competitive professional one?
07:24:42 <hiptobecubic> zxq9, what do you mean?
07:24:58 <covi> @hoogle String -> [Char]
07:24:58 <lambdabot> Data.Data tyconModule :: String -> String
07:24:58 <lambdabot> Data.Data tyconUQname :: String -> String
07:24:58 <lambdabot> Test.QuickCheck.Text bold :: String -> String
07:26:05 <zxq9> hiptobecubic: A too-small project doesn't have the gravity to attract a real community -- a huge one attracts n00bs, b00bs and help vampires in droves and so the smart folks split off into special interest communities of a more ideal size.
07:26:57 <zxq9> hiptobecubic: That's why nobody ever talk about the "C community", but they do talk about the "Linux kernel dev community" or "git dev community"
07:27:23 <hiptobecubic> sure
07:27:47 <zxq9> hiptobecubic: I was making a sort of joke about this effect in a blog post yesterday about the weather on Freenode: http://zxq9.com/archives/763
07:28:29 <Botje> heh
07:28:32 <zxq9> hiptobecubic: The glut of for-real math people in the Haskell core community is a big bonus, though. But often that means they talk way above my head.
07:28:36 <Botje> been a while since I've heard 'help vampire'
07:28:45 <Eelis> hating on other channels while adoring one's own. how mature ;)
07:28:48 <zxq9> Botje: I love the term... intend to revive it.
07:29:11 <zxq9> Eels
07:29:18 <Eelis> not my name
07:29:20 <Eelis> but good try
07:29:25 <zxq9> ;)
07:29:36 <zxq9> slippery, that
07:30:33 <Eelis> even more ironic that your blog has "intellectual" in its title
07:30:47 <zxq9> then you get half of the joke, I see
07:31:54 <Eelis> if you say so :)
07:31:58 <mauke> "#c, #java, and almost all other rooms" stopped reading there ಠ_ಠ
07:32:17 <mauke> how can you cram so many errors into the first few words
07:32:29 <zxq9> its hard, but I manage
07:33:29 <mauke> wrong: "#c", "#java", "rooms"
07:33:40 <mauke> correct: "and almost all other"  (but [citation needed])
07:35:02 <zxq9> If you're going to go that far I'll actually pull the list and re-edit. There's probably plenty of grammar oopses in there as well.
07:35:31 <mauke> it's plain trolling
07:35:45 <mauke> why should you be allowed to stay here?
07:35:49 <beaky> hehe
07:35:53 <Eelis> well, it's his blog, he can troll as much as he wants there
07:36:18 <beaky> everytime I go into #java, I get flamed and told to rtfm and gtfo :(
07:36:25 <mauke> it's ##java
07:36:33 <Eelis> beaky: hm, do you have a problem with reading documentation perhaps? ;)
07:36:34 <beaky> ##java*
07:36:41 <mauke> also, have you tried reading the manual?
07:37:00 <beaky> my system didn't come with a java manual :(
07:37:13 <beaky> ah wait
07:37:13 <hiptobecubic> " #ubuntu and #centos took the first-place poo cake ..."
07:37:15 <Eelis> ah, then i now see the reason for the "gtfo" as well :P
07:37:36 <lolcathost> Manuals are too boring, why can't Java make it easy to just read type signatures and form an informed guess regarding what a method does?
07:37:48 <mauke> when someone tells you to RTFM but you don't know which one, ask them which one they meant / url / whatever
07:37:59 <beaky> hehe
07:38:15 <beaky> if only java came with something like ghci
07:38:26 <covi> @src (=<<)
07:38:26 <lambdabot> f =<< x = x >>= f
07:38:41 <mauke> http://stackoverflow.com/questions/397488/is-there-something-like-pythons-interactive-repl-mode-but-for-java
07:38:52 <covi> Why would someone prefer (=<<) over (>>=)....
07:39:01 <srhb> covi: Because it looks like $
07:39:15 <lolcathost> covi: a =<< b bigRecord { bleeeeeeeergh }
07:39:34 <mauke> covi: main = print . sum . map read . words =<< getContents
07:39:38 <srhb> foo . bar $ baz vs foo . bar =<< mBaz
07:39:40 <beaky> atm I use the scala interactive mode when I want to test java stuff
07:39:57 <covi> Nice, guys, thx
07:43:47 <srhb> Has work on a higher-order module system a la ML been completely given up for Haskell?
07:44:47 <Saizan> has it ever started?
07:45:15 <srhb> Hmm, I thought Oleg at least had it in my at one point, but perhaps it never got beyond that point.
07:45:39 <ceii> AFAIK there was a paper about how it could cohabit and cooperate with Haskell specific type system features, but that was it
07:45:39 <covi> My parseRaw function only returns a list of length 1, while the input file has several chunks of text seperated by the delimiter. What's wrong?    http://hpaste.org/80300
07:46:07 <lolcathost> srhb: Isn't it just a matter of having tagged type class instances? That would allow more than one instance per type / tuple of types.
07:46:09 <Saizan> covi: which one?
07:46:58 <lolcathost> srhb: The only reason against it I can see is it makes infix operators less convenient. But that's a matter of having a single "blessed" default instance per type / tuple of types.
07:47:01 <srhb> lolcathost: Possibly. I don't know. Seems a little opaque though, and not quie as clean.
07:47:26 <covi> Saizan: http://hpaste.org/80300
07:47:45 <Saizan> covi: oh, sorry, i meant ceii
07:47:54 <Saizan> ceii: which paper is that?
07:48:02 <srhb> What with all these Strict/Lazy modules cropping up, it just seems like it would clean up things a lot.
07:48:14 <lolcathost> srhb: Indeed!
07:48:18 <ceii> Saizan: don't know, that was just off the top of my head. I think it was fro the Oleg team.
07:48:24 <ceii> from*
07:49:29 <lolcathost> srhb: Perhaps you should read the slides from "Why Applicative Functors Matter?". (Applicative functors as in OCaml functors, not Haskell's Applicative type class.)
07:49:45 <lolcathost> s/from/from the talk/
07:50:36 <srhb> lolcathost: Will do
07:50:44 <srhb> ceii: http://okmij.org/ftp/Haskell/TranslucentAppFunctor.lhs <-- could that be the one?
07:51:19 <Saizan> that's just an horrible-to-use encoding
07:52:24 <ceii> yes, that's the one I was thinking about
07:55:42 <elliott> lolcathost: There are better reasons against multiple typeclass instances.
07:55:55 <elliott> For instance, it would break Set/Map -- they rightly assume there is only one Ord instance for a type.
07:56:11 <elliott> It'd make "union" inherently slower to allow multiple instances for a type.
07:57:00 <Eelis> inherently? it seems like a bit of inlining/specialization could go a long way
07:57:08 <shachaf> You could choose to make it unsafe, instead.
07:57:26 <lolcathost> elliott: Why do Set and Map assume there is one Ord instance per type? Set would simply be a functor from Ord instances to some other structure.
07:57:38 <Eelis> containers like std::map in C++ have overridable defaults for their Ord equivalent, and it doesn't cost a thing
07:58:25 <elliott> lolcathost: Its hedge-union algorithm doesn't make sense if the two maps can disagree about ordering.
07:58:42 <Eelis> maps using different Ord instances would just have different types
07:58:43 <elliott> Scala does the multiple instances thing. I understand it pays significant costs for it (and has the slower union etc.).
07:58:49 <lolcathost> elliott: What Eelis said.
07:58:58 <elliott> OK, that works.
07:59:01 <elliott> So now you pay the cost in types
07:59:02 <Eelis> that's what C++ does
07:59:05 <lolcathost> elliott: Applyiing the same functor to different structures yields different structures.
07:59:05 <Eelis> eh?
07:59:32 <elliott> And you likely have abstraction problems (you need a way to abstract over multiple instances now)... this sort of thing would work better with dependent types IMO
07:59:42 <lolcathost> Eelis: There's no cost. Sets based on different Ord instances are rightfully different types.
07:59:43 <elliott> lolcathost: by the way, I don't know what you mean by "functor" here
07:59:45 <lolcathost> Eelis: *
07:59:48 <lolcathost> elliott: *
07:59:56 <lolcathost> elliott: ML functors.
08:00:16 * elliott isn't sure these are directly comparable to ML functors
08:00:25 <Eelis> i think the Haskell world can learn lots from the C++ world in terms of making generic programming efficient
08:00:40 <Eelis> abstraction penalties suck
08:01:09 <Eelis> isn't this what killed Parsec 3?
08:01:56 * lolcathost wants a language that combines ML's module system with Haskell's separation of effects. C++-like efficiency would be a nice bonus, and perfectly doable.
08:02:14 <Eelis> i think Rust has potential
08:02:18 <Eelis> but it's very immature
08:02:30 <Eelis> they're still tinkering with the foundations of the language
08:03:04 <zxq9> Eelis: efficient for the programmer or in the execution environment? It isn't obvious to me that Haskell is aimed at either, specifically (but does pretty well in both areas incidentally).
08:03:22 <Eelis> zxq9: execution. and no, from a C++ POV, Haskell sucks in that area :)
08:03:35 <zxq9> Eelis: As far as being killed like Parsec 3, I don't think Haskell is going anywhere -- to the graveyard or skyrocketing to commercial significance next month.
08:03:53 <Eelis> the point wasn't about success. the point was that abstraction penalties are harmful
08:04:39 <latermuse> Is there any difference in functionality between these two compositions?  b >>= (\a -> ...)    and    (b >=> a)
08:04:41 <Eelis> as we can see from the embarrassment that is Parsec 3's "better in every way except that it's now slower because our nicer abstractions came with performance penalties"
08:04:47 <lolcathost> Eelis: C++ first has to replace its template system with something nonbroken. Templates (aka the ability to retain generic programming) are the only reason why I specifically drop down to C++ when I want C-like efficiency. And it hurts that templates suck.
08:05:03 <Eelis> lolcathost: yep, they'
08:05:12 <Eelis> re broken in many ways, but they're still indispensible
08:05:18 <srhb> lolcathost: What do you mean by "efficiency"?
08:05:29 <lolcathost> srhb: Execution efficiency.
08:06:03 <elliott> latermuse: what is "a" on the right hand side?
08:06:14 <Eelis> another true embarrassment is that we have things like IntMap in Haskell, and code that happened to use Map Int a doesn't automatically become efficient
08:06:41 <latermuse> readFile >>= (\x -> doStuff...)    and   (readFile >=> doStuff)
08:07:08 <osa1> `:t someCode` gives me a type but when I try to run that same code I'm getting a type error(in same GHCi session), why is that ?
08:07:27 <mauke> osa1: what is someCode, what is the type, what is the type error?
08:07:38 <elliott> latermuse: that doesn't type
08:07:40 <elliott> readFile >>= that is
08:07:41 <osa1> mauke: I was gonna write that but it's a bit long
08:07:43 <osa1> wait I'll paste
08:07:49 <elliott> do you mean readFile foo >>= ... for some foo?
08:07:58 <latermuse> yeah
08:08:19 <elliott> Eelis: FWIW, HashMap Int outperforms IntMap often, I think.
08:08:27 <osa1> mauke: http://hpaste.org/80303
08:08:52 <Eelis> elliott: if so, that's beside the point ;)
08:09:01 <mauke> osa1: that just means ghci doesn't know how to display the result
08:09:17 <mauke> osa1: you can get the same effect much easier with ':t length', 'length'
08:09:54 <osa1> hmm so that expression is actually well typed ?
08:10:52 <elliott> Eelis: Well, it means it's not true that you have to specialise types to get performance like that.
08:11:13 <elliott> I think ByteString and (Vector Word8) are also not so far off in performance that the latter could not become as efficient as the former with some work.
08:11:41 <lolcathost> Heh, ByteString is actually smarter than C++ std::strings.
08:11:58 <Eelis> C++ std::string is deliberately non-smart because of C compatibility
08:12:27 <lolcathost> Eelis: Then call it std::dumb_string and provide a sane std::string.
08:12:28 <Eelis> elliott: HashMap has very different performance characteristics than IntMap, and they're not universally better, are they?
08:12:57 <elliott> I heard HashMap Int usually outperforms IntMap; I don't know details beyond that.
08:13:04 <Eelis> lolcathost: well, no offense, but the Haskell world with its sixteen different string types hardly gets to lecture the C++ world on standardization :D
08:13:24 <hpc> elliott: that seems... odd
08:13:38 <mauke> sixteen? there's like ... String and Text, no?
08:13:54 <lolcathost> Eelis: I'm by no means a member of the "Haskell world", whatever that is. I just want a sane programming language, and happen to use Haskell (and C++ as well).
08:14:06 * hackagebot statistics-linreg 0.2.3 - Linear regression between two samples, based on the 'statistics' package.  http://hackage.haskell.org/package/statistics-linreg-0.2.3 (AlpMestanogullari)
08:14:37 <Eelis> mauke: add CString, [CChar], UTF-8 encoded ByteStrings, UTF-8 encoded String (using Char to store bytes...)...
08:15:36 <lolcathost> Eelis: ByteStrings are *byte* strings.
08:15:39 <mauke> Eelis: the latter is a bug but not a different type
08:15:41 <Eelis> and then several of these come in lazy and non-lazy forms
08:15:44 <Eelis> it's a nightmare
08:15:56 <mauke> I don't count CString as an actual string
08:16:09 <mauke> actually, I don't use 'CString'. I always write Ptr CChar because that's what it is
08:16:21 <Eelis> mauke: you can call it a bug, but it's what basic libraries like the regex library use
08:16:27 <mauke> ew :-(
08:16:34 <Eelis> i actually got bitten by that
08:16:44 <elliott> Eelis: I don't think anyone has actually used UTF-8 encoded String...
08:16:45 <mauke> well, then that regex library is broken
08:16:53 <Eelis> elliott: think again. look at the regex package
08:17:04 <elliott> there is no "regex" package at least
08:17:07 <elliott> aren't there like fifty?
08:17:20 <Eelis> the one that you get when you import Text.Regex or whatever it's called
08:17:57 <mauke> which one was the good regex module? TDFA?
08:18:01 <hpc> you usually don't want regexes in haskell, anyway
08:18:24 <hpc> other parsing libraries are just so good it's not worth the "my parser is a string" benefit
08:18:47 <Eelis> there are valid use cases for regexes, even in Haskell
08:19:25 <hpc> yeah, but most uses aren't something you couldn't do with parsec
08:19:42 <hpc> the closest thing i can think of is when you want a USER to be the one entering the regex
08:20:08 <Eelis> exactly
08:20:56 <donri> @hackage rex is nice
08:20:56 <lambdabot> http://hackage.haskell.org/package/rex is nice
08:21:33 <Saizan> users ruin everything
08:22:11 <int-e> come to the dark side. join academia.
08:22:30 <Saizan> too many users even there
08:22:48 <Saizan> solipsism is the only solution
08:22:58 <hpc> or government
08:23:16 <hpc> get put on one of those "mission-critical legacy systems" or whatever
08:24:04 <hpc> where you just sit there and make sure it doesn't break, and respond to any change request with a stock email that it would take 20 hours to do and you don't have the time for just one user
08:24:34 <hiptobecubic> that sounds nice :(
08:25:17 <int-e> don't forget that it would break stuff for the other million users out there :P
08:27:28 <hpc> int-e: exactly
08:27:33 <hpc> let your users do the non-work for you
08:39:17 <hiptobecubic> Why are Ints described as 2-adic?
08:40:12 <hiptobecubic> I see that they can all be written as a base_2 expansion
08:42:06 <hiptobecubic> Specifically this sentence: With p-adic numbers, on the other hand, we choose to extend the base p expansions in a different way. Because in the p-adic world high positive powers of p are small and high negative powers are large...
08:42:26 <hiptobecubic> from the wiki page https://en.wikipedia.org/wiki/P-adic_number
08:47:02 <mercury^> Hi. Which module exports (instance Monad (Compose Identity Maybe)) and the like?
08:47:41 <shachaf> I think Compose typically doesn't work that well with monads.
08:48:12 <hpc> you want plain old mtl transformers
08:48:15 <mercury^> But composition with the identity surely preserves monad instances..
08:49:20 <mercury^> hpc: no, I really need exactly that instance. :)
08:49:49 <hpc> oh, hmm
08:50:09 <mercury^> I could just write it myself, but I thought that surely it must be around already!?
08:54:36 <mercury^> Can I import the original Control.Monad.Functor from a replacement Control.Monad.Functor?
08:54:43 <mercury^> Err
08:54:58 <mercury^> Can I import the original Control.Monad.Identity from a replacement Control.Monad.Identity?
08:55:56 <hpc> mercury^: do you mind using package imports everywhere?
08:56:24 <mercury^> hpc: what is that?
08:56:32 <byorgey> @tell cinimod hmm, and are you passing the --ghci flag on the command line?
08:56:32 <lambdabot> Consider it noted.
08:57:39 <mercury^> hpc: I would prefer not to create a whole package for this, if your idea involves that, though.
08:58:04 <hpc> well your entire project is going to be a package, i take it?
08:58:18 <mercury^> hpc: but rather to just create a Contro/Monad/Identity.hs in my current project and to import the original Control.Monad.Functor from that.
08:58:36 <hpc> mercury^: and how do you import your specific Identity.hs?
08:58:41 <shachaf> Contravariant functors should go into Contro/Functor.hs
08:58:59 <mercury^> hpc: import Control.Monad.Identity
08:59:03 <monochrom> the best way is to avoid module name clash in the first place
08:59:04 <hpc> won't work
08:59:09 * hackagebot shake 0.5 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.5 (NeilMitchell)
08:59:18 <mercury^> hpc: how would it work?
08:59:20 <hpc> what monochrom said
08:59:51 <monochrom> since you are writing your own module, why must you clash names with libs you use deliberately?
09:00:41 <hpc> or if someone else uses your package, why must they keep it hidden by default in order to build anything else at all?
09:00:46 <mercury^> Well, what would be a good name? I add functionality that really belongs into the original module.
09:00:57 <hpc> .Extras, maybe?
09:01:13 <monochrom> MyIdentity
09:01:13 <hpc> and if it really needs to be in the original, email the maintainer
09:01:31 <monochrom> (see, I wouldn't even bother with Control/Monad)
09:01:58 <hpc> i rarely bother with module heirarchies at all, myself
09:02:10 <hpc> unless i know a module is exported, i shove it into Lib/Foo.hs
09:03:06 <hpc> mostly i just do that for when cabal makes an executable, though
09:03:36 <monochrom> or Alt.Control.Monad.Identity, Alt.Prelude, Alt.Data.Functor, Alt.Text.Parsec etc if you really have strong conviction on many many libs "done right"
09:04:32 <monochrom> and Alt.Data.Bytestring.Char8.Die.Die.Die
09:04:54 <hpc> Data.Data.Data :D
09:06:09 <monochrom> if you suspect that I drew inspiration from usenet names, you are right :)
09:07:10 <neutrino_> hahaha monochrom.
09:07:24 <elliott> mercury^: is this functionality the Compose Identity monad instance or whatever?
09:07:35 <monochrom> e.g., https://groups.google.com/forum/?fromgroups#!forum/alt.fan.hanson.die.die.die
09:07:36 <elliott> because I personally think that really doesn't belong in the original module :P
09:07:51 <neutrino_> omg, the hansons!
09:08:04 <mercury^> And should I contact edwardk, who maintains Control.Monad.Functor or Ross Paterson, who maintains Data.Functor.Identity.
09:08:09 <neutrino_> i knew a girl who had the whole room covered in their posters. as tapestry.
09:08:16 <mercury^> elliott: yes, it is. But where do you think it belongs?
09:08:34 <elliott> I don't think it belongs at all
09:08:51 <neutrino_> monochrom: do you use Alt.* structure often?
09:09:06 <neutrino_> *the
09:09:20 <statusfailed> What's the corresponding Postgresql type for UTCTime when using postgresql-simple?
09:09:36 <mercury^> elliott: how so? It is an important and useful property of Identity.
09:09:40 <monochrom> I was in alt.algebra.help for a long time. and a star trek group for a bit.
09:10:24 <neutrino_> monochrom: i mean module structure
09:10:29 <elliott> mercury^: it requires e.g. FlexibleInstances, and you can't do both (Compose Identity m) and (Compose m Identity), at least not without completely messing up inference
09:10:31 <monochrom> ah, no
09:10:45 <elliott> (actually, you might need GADTs/TypeFamilies for ~ just to get decent inference in general)
09:11:01 <neutrino_> monochrom: are there good, free ways to post to usenet?
09:11:06 <elliott> and it more generally promotes the use of this instance, which seems nearly useless to me, since you can't Compose monads in general anyway
09:11:27 <monochrom> groups.google.com, gmane
09:11:33 <edwardk> mercury^: what are you looking to contact us about?
09:11:44 <elliott> instance Monad m => Monad (Compose Identity m)
09:11:49 <monochrom> I am actually not sure whether gmane does usenet
09:12:00 <edwardk> mercury^: that instance won't go in
09:12:06 <edwardk> we have IdentityT for that purpose
09:12:26 <edwardk> Compose ha the problem that there are at least 3-4 monad constructions that can use it, so there is no reason to choose one over the others
09:12:59 <neutrino_> monochrom: i thought g.g.c was cancer?
09:13:10 <mercury^> elliott: and moreover, if people start adding it all over the place themselves, there will be conflicts.
09:13:18 <edwardk> the one you have there is based on a distributive law for a pointed functor and a monad. mark p jones noted a much more general construction back around 93, i included it in category-extras but it necessarily went in a different data type
09:13:24 * elliott does not anticipate anyone adding this instance because you don't want to use it :P
09:13:43 <elliott> right I was wondering if it would work with all Pointeds anyway (which is another can of worms)
09:14:00 <edwardk> elliott: its not all pointeds, its pointeds with a distributive law or an absorption law
09:14:06 <elliott> yeah
09:14:07 <elliott> yuck
09:14:55 <edwardk> m (n a) -> n (m a)    or   m (n (m a)) > m (n a)   or m (n (m a)) -> n (m a)   each give rise to different monads.
09:14:59 <shachaf> cmccann: I've mostly stopped with the SO thing, so that's surprising.
09:15:08 <edwardk> for a monad and a pointed functor appropriately
09:15:13 <cmccann> shachaf, aww :[
09:15:24 <shachaf> cmccann: I still look at it!
09:16:05 <shachaf> It's just that I don't see many questions that I care about enough to answer.
09:16:13 <rohan> ← mercury^; my ssh connection is too slow
09:16:14 <shachaf> Maybe I should care more.
09:16:17 <edwardk> mercury^: http://web.cecs.pdx.edu/~mpj/pubs/composing.html is the original 1993 paper on composing monads by mark p jones
09:16:42 <edwardk> that was an early precursor to the thinking that created the mtl in the first place
09:17:14 <edwardk> class (Premonad m, Monad n) ⇒ DComposable m n where
09:17:14 <edwardk> dorp :: m (n (m a))→m (n a)
09:17:16 <rohan> edwardk: That paper explains the problem with a (instance Monad m ⇒ Monad (Compose Identity m))?
09:17:26 <cmccann> shachaf, I figure someone cared enough to ask the question so I should at least give them a chance
09:17:41 <cmccann> not that some questions aren't really terrible but still
09:17:41 <edwardk> rohan: it doesn't explain the problem so much as provide you with an explosion of other constructions that are just as reasonable to privilege as Compose Identity m
09:17:52 <dmwit> Hm, is there logical or for constraints?
09:17:53 <zhulikas> > union [1,2] [2,3]
09:17:54 <lambdabot>   [1,2,3]
09:17:58 <zhulikas> what is the opposite of union?
09:18:00 <dmwit> Not really, I guess.
09:18:03 <shachaf> cmccann: Oh, some of the questions are good, too.
09:18:11 <zhulikas> I want to return only the elements which are found in both lists
09:18:12 <shachaf> It's more my state of mind than the questions.
09:18:13 <edwardk> instances should be for canonical constructions. Compose Identity m isn't canonical
09:18:14 <dmwit> zhulikas: Well, there's symmetric difference, intersection.
09:18:16 <zhulikas> so [2] in this case
09:18:20 <dmwit> zhulikas: intersection, then
09:18:23 <zhulikas> ok, thanks
09:18:26 <dmwit> > intersection [1,2] [2,3]
09:18:28 <lambdabot>   Not in scope: `intersection'
09:18:28 <lambdabot>  Perhaps you meant one of these:
09:18:28 <lambdabot>    `IM.inters...
09:18:36 <srhb> :t (\\)
09:18:37 <lambdabot> Eq a => [a] -> [a] -> [a]
09:18:42 <edwardk> there is no practical purpose that instance serves that IdentityT doesn't also serve
09:18:42 <shachaf> > intersection [1,2] [2,3]
09:18:44 <zhulikas> > intersect [1,2] [2,3]
09:18:44 <dmwit> > intersect [1,2] [2,3]
09:18:44 <lambdabot>   Not in scope: `intersection'
09:18:44 <lambdabot>  Perhaps you meant one of these:
09:18:44 <lambdabot>    `IM.inters...
09:18:45 <shachaf> Er.
09:18:46 <lambdabot>   [2]
09:18:46 <lambdabot>   can't find file: L.hs
09:18:49 * shachaf sighs.
09:18:53 <dmwit> Yeah, it's just called intersect.
09:19:02 <srhb> What's \\ then?
09:19:06 <shachaf> Difference.
09:19:15 <srhb> Ah, yes.
09:19:35 <rohan> edwardk: But Compose is around after all, and in my particular case it seems the most reasonable thing to use.
09:20:35 <edwardk> rohan: i just pointed to a paper that showed 4 other ways to build a monad with 'Compose' why should Identity which is weaker than _all_ of the constructions in that paper win?
09:20:55 <edwardk> monad composition generally doesn't work, this is why we have monad transformers in the first place
09:21:24 <cmccann> shachaf, anyway I'm not really serious about it. I spend a lot less time on SO than I used to, myself.
09:21:28 <edwardk> you can't take m (n a)  for any two monads, you need some kind of distributive law or to sandwich one between an adjunction or an absorption law. these are the very fabric that makes the mtl go.
09:22:06 <edwardk> IdentityT plays the role of the 'Compose Identity' "monad transformer"
09:22:12 <shachaf> cmccann: I once wrote an answer that *40* points!!!!
09:22:22 <shachaf> But then I realized it was a sort of monad tutorial, so it was a good time to stop.
09:22:32 <edwardk> Compose Identity is evil for a lot of reasons. it winds up requiring a flexible instance head so it can't go in transformers, and you can't orphan it elsewhere sanely
09:22:33 <cmccann> shachaf, bwahahaha
09:22:38 <elliott> shachaf: my monad tutorial has 42 points!!
09:22:54 <edwardk> its not that the instance wasn't thought of. it was consciously rejected
09:23:10 <edwardk> IdentityT provides you with all the good without the bad
09:24:27 <edwardk> even ignoring the other instances from there, there is also no real reason why it should win over Monad m => Compose m Identity as a Monad, which is a good sign its a crap abstraction
09:24:55 <cmccann> hm, I think the closest I've come to writing a monad tutorial on SO was a couple explanations of specific monads, a few things about how they relate to the idea in CT, and some stuff about do syntax
09:25:01 <dmwit> shachaf: 5% of my karma comes from one answer.
09:25:36 <cmccann> elliott: you're still #3 on the all-time high-score list for the [monad] tag though :D
09:26:21 <srhb> Urgh, my monad answer only has four points. Sad. :<
09:26:37 <srhb> I obviously should not have written it, which was my gut feeling from the very beginning.
09:27:07 <DMcGill> I need to test my implementation of n-dimensional Newton-Raphson. Does anybody know of a page containing a few examples of simple functions from R^n to R^n along with their Jacobean?
09:27:10 <gwern> @quote gut
09:27:10 <lambdabot> <Berengal> says: I remember I thought about something like facebook some years ago. When it appeared I was both ecstatic and gutted. Ecstatic that I didn't do it after all, and gutted that someone
09:27:10 <lambdabot> else was evil enough to actually do it
09:27:18 <elliott> cmccann: I see dafis has finally knocked me off top-four for [haskell]
09:28:13 <cmccann> elliott, yeah he's been really active lately
09:28:52 <jmcarthur> is there a word for data structures that self-adjust on read-only operations (e.g. splay trees)?
09:28:54 <srhb> The haskell questions on SO have become more and more practical and related to specific libraries, I think. That's a bit boring. But I guess it shows people are really trying to use it,
09:29:36 <beaky> yeah
09:29:44 <dmwit> I wrote a monad tutorial on SO, but pigworker also answered that question, so we all know how that turned out.
09:29:50 <jmcarthur> i'm trying to come up with a name for that class of data structures that is hard to implement efficiently in a pure way without a lot of state passing because they rely on mutation when reading
09:30:08 <jmcarthur> that particular class, i mean. i don't mean to say there are no others
09:30:10 <elliott> srhb: I think that's better.
09:30:20 <elliott> People kept asking the same generic FAQ questions over and over.
09:30:30 <dmwit> jmcarthur: I've seen a name for it and I'm having trouble remembering what it is now.
09:30:40 <srhb> elliott: Of course. But the different wordings were actually very helpful for me when I just started. I guess SO is just saturated now.
09:30:40 <dmwit> But it was in a paper about a pure union-find.
09:30:46 <dmwit> pseudo-pure or something silly like that
09:30:49 <cmccann> elliott, I think that's part of what eventually killed my enthusiasm for SO
09:30:52 <srhb> elliott: Especially on the conceptual questions.
09:30:56 <jmcarthur> thanks. i'm googling around for it
09:31:32 <srhb> (But I'm particularly dense, so that may just be the reason.)
09:32:42 <cmccann> after seeing enough questions for the third time or more I was usually pretty sure that they were duplicates, and searching for a previous question isn't as much fun as writing answers
09:33:08 <int-e> dmwit: do you mean "A persistent union-find data structure", which introduces diff-arrays?
09:33:16 <cmccann> especially since in the time it'd take me to find the previous questions usually a couple people would answer the new one anyway
09:34:41 <int-e> dmwit: (I'm sort of hoping that the answer is "no" :) )
09:36:26 <elliott> cmccann: I usually just wrote the same answer over and over.
09:36:52 <cmccann> elliott, for quick answers I did that a few times
09:36:54 <dmwit> int-e: Yes, that sounds right.
09:37:02 <cmccann> but even that got tiresome
09:37:50 <jmcarthur> that paper (or at least the corresponding slides) calls baker arrays "semi-persistent". is that what you were thinking?
09:38:07 <dmwit> yes, that's it
09:38:12 <cmccann> elliott, a few times I've considered the idea of going through the [haskell] tag and collecting highly-voted answers and recurring questions to make a stand-alone FAQ-ish thing
09:38:27 <jmcarthur> i think that's not exactly what i had in mind, unfortunately, or at least not that kind of behavior
09:38:53 <jmcarthur> well, perhaps it's close
09:40:32 <DrChaos> ok guys, I don't know how you'd finish problem 9 on this page: http://www.haskell.org/haskellwiki/99_questions/1_to_10
09:40:45 <jmcarthur> ah, in another paper the authors define it in the abstract: "This paper introduces a new notion of persistence, call semi-persistence, where only ancestors of the most recent version can be accessed or updated."
09:40:53 <jmcarthur> that is not what i was thinking
09:41:02 <jmcarthur> s/thinking/looking for/
09:41:19 <DrChaos> I've tried implementing the pack functuin, but I haven't been able to get it to work'
09:43:22 <int-e> DrChaos: maybe paste your attempt(s) at http://hpaste.org/ so we get an idea what you tried and where it went wrong
09:43:49 <monochrom> again, explain your logic
09:44:09 <monochrom> or say you give up and want to hear my approach
09:45:36 <DrChaos> monochrom :: I want to check to see if two elements of a list are equal. if they are, stick them into a sublist.
09:46:10 <DrChaos> as soon as two elements are not equal to each other, close the sublist and start again
09:46:48 <watermind> DrChaos: if you're beginning just learn to think inductively... i.e. first implement it for the smallest case(s). It is easy to know what do do if the list is empty or just has one element
09:47:03 <mvj4_> Hi! Is there any way to apply a wrapper function at each step in the continuation monad? I'm trying to parse each "instruction" which is composed in continuation style. This could be realised by writing a custom monad instance but I'm looking for an alternative.
09:47:58 <watermind> DrChaos: then given a list  (x:xs) assume that pack xs works... i.e., you can calculate pack xs. What do you need to do with x and pack xs  to get pack (x:xs)
09:48:01 <shachaf> Each step?
09:48:03 <watermind> DrChaos:  and that's it
09:49:11 <mvj4_> shachaf: I should probably create an example.. will expand on it later.
09:49:44 <hpaste> DrChaos pasted “problem9.hs” at http://hpaste.org/80305
09:53:57 <watermind> are there any interesting applications for the tree monad?  just like with lists we could just forget about the underlying structure and use it for simple non-determinism, but was ondering about examples that take advantage of the implicit partial order
09:54:50 <cmccann> mvj4_, apply a wrapper function to what? the final result of the computation?
09:55:15 <cmccann> since you can't really do anything interesting with the parametric piece in the monad instance, and if you did it would probably break the monad laws anyway
09:55:49 <hpaste> DrChaos annotated “problem9.hs” with “problem9.hs (started pver on pack)” at http://hpaste.org/80305#a80306
09:56:18 <DrChaos> wait, that can't work
09:56:37 <DrChaos> I need to append to the beginning of a list for all items that are the same, and if not close the sublist
09:56:50 <DrChaos> I need to create the sublist two elements at a time, right?
09:57:11 <watermind> DrChaos: you're closer, but
09:57:33 <watermind> DrChaos: the last case, where they are different, that is not the result
09:58:26 <elliott> watermind: (>>=) is substitution, if that helps.
09:58:34 <watermind> DrChaos: the type of the result should be http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a  and your result in that case is of type [a]
09:58:37 <DrChaos> watermind :: yes the result has to be a normal list, e.g. for the input [1,1,2] : [[1,1],2]
09:58:41 <watermind> opss
09:59:02 <DrChaos> watermind :: see the 2 in the first list? that's my normal list case
10:01:30 <watermind> elliott: maybe it does
10:01:46 <watermind> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=a
10:02:01 <DrChaos> watermind :: I don't know what I'd put for the else branch
10:02:04 <watermind> wtf is this ^
10:02:25 <DrChaos> mostly because I don't know haskell very well
10:02:36 <watermind> I wonder if it's my irc client doing this
10:02:46 <watermind> that was supposed to be [ [ a ]  ]
10:03:21 <watermind> DrChaos: if you have [1,2] the result is http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1],[2
10:03:24 <watermind> argh!
10:03:37 <watermind> the result is [ [1], [2]  ]
10:03:59 <DrChaos> watermind :: I have no idea how to get that result
10:04:26 <watermind> DrChaos: you'd werite [ [x], [y] ]
10:04:32 <watermind> write*
10:05:27 <watermind> DrChaos: but in any case that works for two elements, but you don't want just two... the last branch should be  (x:xs) not (x:y:[])
10:05:58 <DrChaos> watermind :: don't you mean (x:y:xs)?
10:07:27 <DrChaos> watermind :: ghc says it cannot countrust the infinite type t0 = [t0] in the expressions x, [x,y], and [[x, y]] but I don't think that error message is current anymore
10:07:56 <hpc> @wn countrust
10:07:56 <lambdabot> No match for "countrust".
10:07:59 <hpc> ;)
10:08:13 <DrChaos> I resaved my source code file, which does not contain the expression [[x, y]] and it still seems that ghc is using an older copy of my source
10:08:50 <zhulikas> so, mutable vectors is a way to sort lists (not necessarily [] lists) in constant memory space, right? what are some other alternatives?
10:08:53 <DrChaos> oh wait, my source code does contain [[x, y]]
10:09:13 <DrChaos> duh...anyways, how would you fix the infinite type error?
10:10:40 <hpc> DrChaos: by writing that expression correctly ;)
10:10:54 <hpc> is there a paste of your code somewhere?
10:11:20 <DrChaos> http://hpaste.org/80305
10:11:52 <hpc> what type do you want pack to have?
10:14:29 <dmwit> DrChaos: Why are you expecting [[x,y]] and [x,y] to have the same type?
10:19:12 * hackagebot git-annex 3.20130105 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20130105 (JoeyHess)
10:19:14 * hackagebot LDAP 0.6.9 - Haskell binding for C LDAP API  http://hackage.haskell.org/package/LDAP-0.6.9 (EdwardYang)
10:19:49 <Ziarkaen> I have a function f :: String -> Maybe String.  The function should work by consuming one or two values from the beginning of the string and generating Nothing of Just fragment.  Then the wntire function should return Nothing if there are any Nothings, or otherwise the fragments concatenated together ina  Jsust.
10:20:13 <Ziarkaen> What's the best way to achive this without having to Just (fromJust stuff)) lots of times?
10:21:06 <shachaf> @ty sequence
10:21:07 <lambdabot> Monad m => [m a] -> m [a]
10:21:13 <shachaf> @ty fmap concat . sequence
10:21:14 <lambdabot> (Monad f, Functor f) => [f [a]] -> f [a]
10:21:22 <shachaf> Er.
10:21:32 <DrChaos> dmwit :: oh great, so my expressions have to have the same type...
10:21:34 <shachaf> Oh, that works.
10:21:49 <DrChaos> well, I don't expect that they'd have the same type
10:21:51 <shachaf> > (fmap concat . sequence) [Just "hello", Just "hi"]
10:21:52 <lambdabot>   Just "hellohi"
10:21:54 <shachaf> > (fmap concat . sequence) [Just "hello", Nothing, Just "hi"]
10:21:56 <lambdabot>   Nothing
10:22:12 <DrChaos> not now that I've read my code again
10:22:20 <shachaf> Ziarkaen: By the way, you should almost never use fromJust. :-)
10:22:30 <shachaf> Pattern matching or fromMaybe or maybe or something else is nearly always better.
10:22:42 <Ziarkaen> shachaf, Perfect, thanks.
10:23:05 <Ziarkaen> shachaf, Yeah, I know it's ugly to use that
10:23:08 <DrChaos> watermind :: you told me to write [[x], [y]] but that does not have the same type as [[x,y]]
10:23:30 <dmwit> DrChaos: yes it does
10:23:43 <jmcarthur> > mconcat [Just "hello", Just "hi"]
10:23:45 <lambdabot>   Just "hellohi"
10:23:47 <dmwit> But you didn't write [[x], [y]].
10:23:49 <jmcarthur> > mconcat [Just "hello", Nothing, Just "hi"]
10:23:50 <lambdabot>   Just "hellohi"
10:23:54 <jmcarthur> ah!
10:24:16 <DrChaos> dmwit :: what?! I did write [[x], [y]]
10:24:18 <jmcarthur> i always forget which monoid is used as the instance for Maybe
10:24:20 <cmccann> > mplus [Just "hello", Nothing, Just "hi"]
10:24:21 <lambdabot>   No instance for (GHC.Show.Show
10:24:21 <lambdabot>                     ([Data.Maybe.Maybe [GHC....
10:24:28 <cmccann> er
10:24:32 <cmccann> > msum [Just "hello", Nothing, Just "hi"]
10:24:33 <jmcarthur> msum?
10:24:34 <lambdabot>   Just "hello"
10:24:40 <jmcarthur> yeah that's just First
10:24:51 <jmcarthur> neither are what is wanted here
10:24:56 <cmccann> indeed
10:25:04 <jmcarthur> it's the applicative lifting that is desired
10:25:31 <cmccann> there are entirely too many useful things to do with some combination of [] and Maybe
10:26:03 <hpaste> DrChaos annotated “problem9.hs” with “problem9.hs (started pver on pack) (annotation)” at http://hpaste.org/80305#a80307
10:26:17 <jmcarthur> usually we don't give an instance to a type which could have more than one of the same instance, but we broke that rule of thumb for Maybe
10:26:18 <shachaf> cmccann: That's why lens lets you do a bunch more!
10:26:27 <DrChaos> dmwit :: there, I wrote [[x]. [y]] in there
10:26:40 <shachaf> cmccann: preview (traverse._just) -- isn't that much nicer than msum?
10:26:58 <dmwit> DrChaos: You also wrote [x] above. Do you expect [x] and [[x,y]] to have the same type? ;-)
10:26:59 <shachaf> :: [Maybe a] -> Maybe a, finds the first Just value in the list.
10:27:19 <dmwit> DrChaos: (If you nail down what type you expect this function to have, you'll get much more informative error messages, by the way.)
10:27:39 <hpaste> DrChaos annotated “problem9.hs” with “problem9.hs (full source + error)” at http://hpaste.org/80305#a80308
10:27:58 <cmccann> jmcarthur, to be fair the Monoid instance is the obvious one that MonadPlus can't use
10:28:22 <DrChaos> dmwit :: I expect the function to have type [[a]]
10:28:25 <int-e> DrChaos: pack (x:[]) = [x] has the same problem as [x,y].
10:29:12 * hackagebot HLearn-algebra 0.1.1.0 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-0.1.1.0 (MikeIzbicki)
10:29:15 <jmcarthur> cmccann: there are two that fit that criteria
10:29:31 <jmcarthur> cmccann: mempty = pure mempty; mappend = liftA2 mappend
10:29:35 <DrChaos> int-e :: I fixed it by writing pack (x:[]) = [[x]]
10:30:54 <jmcarthur> there are at least four valid monoid instances for Maybe :\
10:31:04 <DrChaos> now all I have to write is pack (x:y:xs), right?
10:31:13 <jmcarthur> this is why programming with null is so confusing ;)
10:31:32 <cmccann> jmcarthur, yeah
10:32:15 <int-e> DrChaos: yes.
10:33:47 <DrChaos> hmm...ok, first I need a little tutoring. How do you construct [[a]] with just cons and []? like 1 : 2 : (1 : 2 :[]) : []?
10:34:08 <dmwit> Not quite, but close.
10:34:18 <DrChaos> or rather, (1 : 2 : []) : []
10:34:19 <dmwit> You could, for example, (1 : 2 : []) : (1 : 2 : []) : []
10:34:25 <dmwit> > (1 : 2 : []) : (1 : 2 : []) : []
10:34:27 <lambdabot>   [[1,2],[1,2]]
10:34:29 <hpc> DrChaos: think about how you would construct it as a literal list, then translate it to (:) and []
10:34:33 <zhulikas> @djinn filter a $ filter b
10:34:33 <lambdabot> Cannot parse command
10:34:34 <dmwit> > [1,2] : []
10:34:36 <lambdabot>   [[1,2]]
10:34:38 <zhulikas> how can I reduce this?
10:34:46 <zhulikas> oh, wait
10:34:51 <zhulikas> filter (a . b) maybe
10:34:55 <dmwit> filter (liftM2 (&&) a b)
10:34:57 <zhulikas> oh no.
10:35:00 <zhulikas> yes!
10:35:02 <zhulikas> that!
10:35:02 <zhulikas> thanks
10:35:20 <DrChaos> dmwit :: wow, that's some trick
10:35:21 <dmwit> but filter (\x -> a x && b x) is probably more maintainable.
10:35:58 <zhulikas> nah, I like the first one more :)
10:36:10 <zhulikas> this code will never see the daylight
10:36:14 <dmwit> filter (and . zipWith ($) [a,b])
10:36:18 <zhulikas> so no need to care about maintainability
10:36:41 <dmwit> err
10:36:45 <dmwit> filter (and . zipWith ($) [a,b] . repeat)
10:37:05 <dmwit> zhulikas: famous last words
10:37:37 <zhulikas> what do you mean? :)
10:38:16 <DrChaos> err...again with infinite type problems again, this time I don't know how to rewrite... anyways, it's pack (x:y:xs) | x == y = x : y : pack xs | otherwise = [] : pack xs
10:39:00 <DrChaos> I think it's due to x : y not being a sublist, but I am trying to build one dynamically as soon as we reach x /= y
10:39:06 <Lethalman> DrChaos, maybe otherwise = pack xs
10:39:10 <elliott> zhulikas: liftA2 instead, please!
10:39:11 <zhulikas> actually I may be better off using filter a $ filter b...
10:39:30 <zhulikas> list is quite large, I don't want to check both conditions on every element
10:39:40 <zhulikas> so 'b' is a function which reduces list much more than 'a'
10:39:49 <DrChaos> Lethalman :: no the problem is with the first argument of (:), namely dx
10:39:52 <DrChaos> I mean, x
10:39:53 <zhulikas> and I win some precious milliseconds
10:40:13 <zhulikas> (euler problem, dealing with millions of elements in a list)
10:40:25 <zhulikas> so in this case I am reducing minutes to seconds
10:40:42 <zhulikas> well, not only by clever filtering, but some other parts too
10:43:15 <zhulikas> is there a way to do something similar as list comprehensions in vector directly?
10:43:27 <zhulikas> generating list takes 0.5s, converting it to vector takes 4s
10:46:50 <dmwit> drbean: Did you mean [x, y] : pack xs?
10:47:05 <dmwit> uh, misnick, that was meant for DrChaos who is apparently gone
10:47:38 <dmwit> ?tell DrChaos Perhaps you meant [x, y] : pack xs or (x : y : []) : pack xs instead of x : y : pack xs.
10:47:38 <lambdabot> Consider it noted.
10:48:11 <zhulikas> CPU time:  90.11s
10:48:16 <merijn> zhulikas: You could also do "filter (uncurry (&&) . a &&& b)" if you like comlicating things :p
10:48:16 <zhulikas> this can be greatly optimized...
10:48:19 <merijn> :t uncurry
10:48:20 <lambdabot> (a -> b -> c) -> (a, b) -> c
10:48:37 <zhulikas> I prefer simplifying things :D
10:50:13 <zhulikas> CPU time:   1.73s
10:50:17 <zhulikas> now THAT's a nice optimization
10:50:18 <zhulikas> :DDD
10:50:41 <zhulikas> silly me though
10:50:49 <zhulikas> forgot about gcd function
10:50:55 <zhulikas> so this is how I was calculating it:
10:50:57 <dmwit> Strange, your optimization caused you to grow two extra mouths.
10:51:07 <zhulikas> hfcOne (a, b) = (== 1) . S.size $ S.intersection (divisors a) (divisors b)
10:51:19 <zhulikas> S is qualified Data.Set
10:51:26 <zhulikas> divisors is from Math.NumberTheory.Primes.Factorisation
10:51:35 <zhulikas> jeez, so ineffective
10:51:47 <zhulikas> sorry for flooding, got quite excited :D
10:58:15 <rohan> Is there a ComposeT that composes two monad transformers and makes the result an instance of MonadTrans, and Monad when applied to one?
10:59:56 <dmwit> type ComposeT t1 t2 m a = t1 (t2 m) a
11:00:16 <dmwit> type ComposeT t1 t2 m = t1 (t2 m) -- I mean
11:00:28 <halpliz> What the heck? "Exception when trying to run compile-time code:   Data.Label.Derive: Can only derive labels for datatypes and newtypes." anyone encountered this when trying to use fclabels
11:00:56 <dmwit> I guess that doesn't have the MonadTrans instance you were hoping for, though. =P
11:01:00 <halpliz> I am using it with data types. data Person = Person { ...
11:01:22 <shachaf> Person { ... is not valid Haskell syntax.
11:01:26 <shachaf> So that's probably why.
11:01:39 <srhb> It's not?
11:01:41 <halpliz> shachaf: ?
11:01:46 <dmwit> halpliz: Perhaps you could post enough code that we can reproduce it.
11:01:48 <rohan> dmwit: ah, right, no need for a newtype here I guess.
11:01:55 <dmwit> halpliz, srhb: shachaf is making a silly joke.
11:01:58 <shachaf> Nope. You need to close the }, and also ellipses aren't valid in a record.
11:02:00 <parcs> halpliz: how does your derive statement look like
11:02:09 <srhb> shachaf: Oh, you've been drinking again. :P
11:02:15 <shachaf> I meant more or less what dmwit did. :-)
11:02:25 <parcs> halpliz: you have to use ''Person not 'Person
11:02:31 <dmwit> Right. "Post more code plox".
11:02:40 <halpliz> parcs: deriving (Eq, Show)
11:02:50 <parcs> halpliz: no i mean the lens deriving statement
11:02:56 <parcs> er, labels, in this case
11:03:03 <shachaf> parcs uses mind-reading powers again. :-(
11:03:16 <shachaf> halpliz: You should *really* post the code.
11:03:16 <halpliz> parcs: $(mkLabels ['Person, 'Address])
11:03:23 <halpliz> okay, doing it shachaf
11:03:27 <parcs> halpliz: right. you need 2 apostrophes
11:03:28 <parcs> not 1
11:03:34 <shachaf> halpliz: In this case parcs already answered your question.
11:03:39 <shachaf> But please post code first.
11:03:46 <srhb> To the time machine!
11:03:49 <halpliz> Dohhhhhh'
11:03:58 <parcs> halpliz: 'Person refers to the data constructor. ''Person refers to the type constructor
11:04:10 <halpliz> I've seen one apostrophe in the tut I was reading
11:04:18 <halpliz> parcs: Ohh ty.
11:05:08 <halpliz> parcs: Is that a template haskell thingie? Where can I find more info about this apostrophe bussiness
11:05:59 <parcs> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/template-haskell.html
11:10:35 <DrChaos> hello
11:10:35 <lambdabot> DrChaos: You have 1 new message. '/msg lambdabot @messages' to read it.
11:11:37 <jmcarthur> i have an algorithm with a worst case running time of  (log n + log (n/2) + log (n/4) + log (n/8) + ...).  is that the same as  log n?
11:12:03 <jmcarthur> it *looks* like log n, but i am pretty bad at this kind of math
11:12:22 <jmcarthur> (where by "looks" i mean "appears to be when plotted")
11:12:52 <halpliz> In the fclabels example, the author has record fields starting with an underscore, and fclables give accessors without underscores, What if I don't have underscores to start with?
11:13:11 <shachaf> halpliz: lens lets you do it.
11:13:18 <shachaf> I don't know how flexible fclabels's TH is.
11:13:24 <hpc> jmcarthur: i remember there being a trick to "integrate" a taylor series back into its original function
11:13:33 <hpc> if you can try that, maybe you'll get something meaningful back
11:13:56 <DrChaos> yes dmwit I think I meant x : y : [] : pack x
11:13:56 <halpliz> shachaf: That's an other package, right?
11:14:06 <DrChaos> I mean, x : y : [] : pack xs
11:14:15 <DrChaos> but I still get infinite type error
11:14:21 <shachaf> halpliz: It is.
11:14:37 <dmwit> DrChaos: x : y : [] : pack xs is not the same as (x : y : []) : pack xs.
11:14:40 <jmcarthur> hpc: this isn't a taylor series, although i suppose it may look like it from the way i wrote it. it actually stops adding once the denominator reaches n
11:15:06 <DrChaos> dmwit :: ah
11:15:12 <halpliz> shachaf: Sorry I am just sooo used to other ways of doing things. Even the package naming convention is totally alien for me.
11:15:59 <gnuvince_> I'm having a brain fart; what's the term used to refer to the "cost" of complexity in an application?  It's something like complexity tax or something like that.
11:16:01 <hpc> jmcarthur: ooh, i know how to do it then
11:16:01 <DrChaos> dmwit :: but won't (x : y : []) generate a new sublist every time it is executed?
11:16:10 <DrChaos> I only want to build a new sublist in the case that x /= y
11:16:10 <jmcarthur> hpc: hmm... maybe it is a taylor series? i don't actually know
11:16:19 <hpc> jmcarthur: it's obviously slower than log(n)
11:16:32 <hpc> jmcarthur: but it's also faster than (logn * logn2 * ...)
11:17:02 <hpc> so if you use logarithm magic to make that a single logarithm, i think you'll find that it's both faster and slower than log(n)
11:17:10 <art2art> Hello all, how to do it [*3, +4] `smth_operation` [1, 1] and get [3, 5]?
11:17:33 <shachaf> @ty zipWith ($)
11:17:34 <lambdabot> [b -> c] -> [b] -> [c]
11:17:37 <mauke> > zipWith id [(*3), (+4)] [1, 1]
11:17:38 <lambdabot>   [3,5]
11:17:41 <hpc> > zipWith ($) [(* 3), (+ 4)] [1,1]
11:17:42 <jmcarthur> hpc: that doesn't make any sense :P
11:17:42 <lambdabot>   [3,5]
11:17:45 <dmwit> jmcarthur: lim_{i->\infty} i*log(n) - i*(i+1)/2*log 2 -- odd one
11:17:59 <hpc> jmcarthur: so, log(x) * log(y) = log(x + y), right?
11:17:59 <DrChaos> dmwit :: hello?
11:18:14 <mauke> > getZipList $ ZipList [(*3), (+4)] <*> ZipList [1, 1]
11:18:15 <lambdabot>   [3,5]
11:18:22 <dmwit> DrChaos: I can't help you with the behavior, because I have no idea what you want. I can help you with type errors, but semantics are up to you.
11:18:23 <shachaf> hpc: No. The other way around.
11:18:35 <hpc> oh, damn
11:18:44 <parcs> seems equivalent to n * log n
11:18:54 <hpc> so log(n) + log(n/2) = log(n * n/2)
11:18:59 <art2art> Thanks a lot!
11:19:05 <art2art> =)
11:19:44 <DrChaos> dmwit :: erm...I want for as long as x == y, start a sublist with x and y in them, and when x /= y, create the sublist
11:20:00 <DrChaos> it's complicated to explain
11:20:18 <mauke> you're describing operations, not results
11:20:19 <dmwit> Keep hacking at it. You'll get it.
11:20:23 <hpc> Σ log(n/i) = log(Π n/i) ~~ log(n**n) = nlogn
11:20:28 <hpc> parcs: you seem to be right
11:20:38 <DrChaos> http://www.haskell.org/haskellwiki/99_questions/1_to_10
11:20:44 <DrChaos> I basically want a solution to problem 9 there
11:21:26 <mauke> oh, group
11:21:27 <DrChaos> I want basically for the input list [1,1,1] the result of [[1,1,1]
11:21:33 <DrChaos> I want basically for the input list [1,1,1] the result of [[1,1,1]]
11:22:03 <hpc> parcs: oh, wolfram alpha says different
11:22:04 <hpc> https://www.wolframalpha.com/input/?i=product+of+%28n+%2F+i%29+for+i+from+1+to+n&dataset=
11:22:07 <mauke> > group [1,1,1]
11:22:08 <lambdabot>   [[1,1,1]]
11:22:20 <DrChaos> and for the input list [1,1,1,2,1] the result of [[1,1,1],[2],[1]]
11:22:27 <DrChaos> > group [1,1,1,2,1]
11:22:29 <lambdabot>   [[1,1,1],[2],[1]]
11:22:49 <DrChaos> I'm trying to reimplement the group function, but I don
11:22:58 <hpc> i have no idea how (!) and (** n) compare in big O
11:23:08 <DrChaos> ...don't know how it makes the sublists dynamically
11:23:08 <parcs> wait -- log (n) + log (n/2) + log (n/4) + ... = log (n^n/2^(1/2*n(n+1))) = log (n^n) - log (2^(1/2*n(n+1))) = n * log n - (1/2*n(n+1))log 2 ~~ ??
11:23:34 <alpounet> hpc, remember **n is basically an exponential
11:23:43 <parcs> ~~ n * log n - n(n+1)
11:23:57 <halpliz> I dont have to generate the lenses in every package I want to use the records, do I? I can generate it in the package they are defined in and export from there?
11:23:58 <hpc> alpounet: it... is an exponential
11:24:02 <parcs> ~~ n*log - n^2
11:24:05 <DrChaos> any hints on how to make a sublist dynamically?
11:24:11 <mauke> DrChaos: what does that mean?
11:24:14 <dmwit> parcs: I don't follow that equation. How did you arrive at n^n?
11:24:28 <DrChaos> mauke :: start making the [1,1,1] list in [[1,1,1]]
11:24:34 <mauke> DrChaos: ???
11:24:46 <parcs> dmwit: oh, would it be n^log n ?
11:24:59 <dmwit> I don't know. How did you get n^anything?
11:25:00 <Wizek> How can I install the Haskell Platform on Ubuntu 12.10 from a debian package? I searched for `haskell` in the software center, but I can't seem to find it.
11:25:08 <DrChaos> mauke :: :(. I'd hope you'd get what I meant.
11:25:22 <mauke> :t let pack [] = []; pack (x : xs) = (x : xs') : pack ys where (xs', ys) = span (x ==) xs in pack
11:25:24 <lambdabot> Eq a => [a] -> [[a]]
11:25:33 <hpc> dmwit: by factoring the logs
11:25:34 <mauke> > let pack [] = []; pack (x : xs) = (x : xs') : pack ys where (xs', ys) = span (x ==) xs in pack [1,1,1,2,1]
11:25:36 <lambdabot>   [[1,1,1],[2],[1]]
11:25:40 <hpc> log(x) + log(y) = log(x * y)
11:25:46 <parcs> right
11:25:47 <dmwit> hpc: How do you know there are n such logs?
11:25:51 <dmwit> Looks like an infinite list t ome.
11:25:58 <parcs> list? :P
11:26:00 <hpc> dmwit: you said there were n such logs
11:26:05 <dmwit> I didn't say any such thing.
11:26:06 <jmcarthur> dmwit: i meant n
11:26:09 <dmwit> ah
11:26:14 <hpc> er, jmcarthur said
11:26:15 <dmwit> In that case, things get much simpler, yeah.
11:26:15 <jmcarthur> dmwit: and i think hpc mixed us up ;)
11:26:16 <parcs> dmwit: you say the dominator stops at n right
11:26:27 <jmcarthur> parcs: that's right
11:26:29 <DrChaos> mauke :: the problem there is that the where binding just does the work
11:26:30 <dmwit> Wait, the denominator stopping at n is very different from having n logs.
11:26:32 <parcs> dmwit: so there would be 'log n' logs
11:26:34 <dmwit> So which is it?
11:26:41 <jmcarthur> dmwit: denominator stops at n
11:26:41 <mauke> DrChaos: bindings don't do work
11:26:47 <dmwit> (Either way things get a lot easier.)
11:27:05 <jmcarthur> dmwit: the last one should be  log (n/n)
11:27:05 <dmwit> jmcarthur: Okay, then it's log n * log n - n(n+1)/2 * log 2
11:27:06 <DrChaos> mauke :: then whatever that (xs', ys) = ... is does the work
11:27:14 <mauke> DrChaos: no, it doesn't
11:27:26 <dmwit> uh
11:27:27 <jmcarthur> dmwit: how did you arrive at that?
11:27:36 <dmwit> That doesn't pass my sanity-detection test, so let me check my math again.
11:27:47 <dmwit> But I arrived at it by turning the sum of logs into a log of products.
11:27:56 <DrChaos> mauke :: oh, I failed to see : pack ys
11:27:56 <hpc> dammit wolfram alpha, reduce big-O notation
11:28:06 <parcs> log n + log n/2 + log n/4 + ... = log (n^log n / 2^(1/2*n(n+1)))
11:28:21 <parcs> that is correct nO?
11:28:25 <Wizek> http://www.haskell.org/platform/linux.html says I should be finding in in the package manager. Should I search for in under some different name?
11:28:53 <Clint> Wizek: what is "in"?
11:29:03 <DrChaos> mauke :: first of all I don't want to use the span function because it is simplifying things and doing much of the work
11:29:21 <Wizek> *findinf it in
11:29:26 <Clint> finding what in what
11:29:35 <DrChaos> I want to build the list [1,1,1] item by item and place it in the list here: []
11:29:41 <hpc> parcs: how are you doing that conversion?
11:29:48 <DrChaos> how can I do that?
11:29:52 <dmwit> \sum_{i=1}^{log n} log(n^i/2^i) = log(\product_{i=1}^{log(n)} n^i/2^i) = log((n/2)^{\sum_{i=1}^{log(n)} i}) = log((n/2)^{log(n)*(log(n)+1)/2}) = log(n)*(log(n)+1)/2*log(n/2)
11:29:58 <dmwit> jmcarthur: How does that look?
11:29:59 <mauke> DrChaos: by writing span
11:30:01 <parcs> ahhh inline latex :(
11:30:09 <dmwit> jmcarthur: So it's roughly (log(n))^3.
11:30:15 <hpc> the only step i see from that log series is Σ(log n/i) => log(Π n/i)
11:30:17 <DrChaos> mauke :: I don't know how span works.
11:30:30 <Wizek> Clint: I'm trying to install Haskell Platform on Ubuntu 12.10
11:30:32 <monochrom> I agree about writing your own span
11:30:34 <jmcarthur> hmm
11:30:56 <jmcarthur> dmwit: that result does seem totally crazy
11:30:58 <jmcarthur> *doesn't
11:31:00 <parcs> wait no. it's the product of 2^m from 1 to log n
11:31:01 <dmwit> hpc: It's not log(n/i), it's log(n^i/2^i), isn't it?
11:31:08 <mauke> DrChaos: http://www.haskell.org/hoogle/?hoogle=span
11:31:11 <parcs> so it's 2^(1/2*log n*log n+1)
11:31:18 <hpc> dmwit: you're missing the Π product symbol there
11:31:22 <Clint> Wizek: i don't think you really want haskell-platform, but you should be able to install ghc
11:31:33 <DrChaos> mauke :: let me try writing span manually without looking at it
11:31:35 <dmwit> Am I?
11:31:43 <parcs> so -- log n + log n/2 + log n/4 + ... = log (n^log n / 2^(1/2*log n(log n+1)))
11:31:47 <__StPiere__> what type of applications does haskell the best suit ?
11:31:47 <hpc> log(Π n/i) = log(product of (n/i) from 1 to n)
11:31:48 <DrChaos> it will take hours of work but will pay off in the end
11:32:01 <monochrom> Wizek, http://packages.ubuntu.com/quantal/haskell-platform exists
11:32:10 <dmwit> hpc: Right, but the original question is not about the product of (n/i) for many i's.
11:32:13 <dmwit> I think.
11:32:22 <Wizek> Clint: On a broader perspective, I'm starting out with http://learnyouahaskell.com/ and it was the one which gave me the suggestion
11:32:34 <Wizek> in introduction
11:32:37 <Clint> Wizek: you'll be fine with ghc until you need additional libraries
11:32:42 <hpc> dmwit: question was, big O of...
11:32:43 <hpaste> me pasted “Not in scope” at http://hpaste.org/80309
11:32:52 <jmcarthur> O(log n + log (n/2) + log (n/4) + log (n/8) + ... + log (n/n)) ~ O(?)
11:32:53 <DrChaos> mauke :: unless you have any simpler exercises so that I get used to writing functional code before writing my own span
11:32:55 <hpc> (log n + log (n/2) + ... + log (n/n))
11:32:57 <monochrom> Software Centre is not transparent. I go with aptitude
11:33:10 <dmwit> hpc: Yeah, but your "..."s are wrong. =)
11:33:14 <jmcarthur> hpc: critical that the denominator grows exponentially though
11:33:15 <dmwit> Apparently so are mine.
11:33:17 <dmwit> No n^i.
11:33:26 <hpc> jmcarthur: oh, goddammit
11:33:28 <mauke> DrChaos: have you written your own list type + length/map/sum/filter functions yet?
11:33:30 * dmwit tries yet again
11:33:31 <parcs> log n + log n/2 + log n/4 + ... = sum of log n/2^i from i = 0 to log n
11:33:43 <eggsNBacon> Anyone know what I'm doing wrong? http://hpaste.org/80309
11:33:44 <Wizek> Clint: okay, installing that one then
11:33:52 <DrChaos> mauke :: I think so, let me check...
11:34:00 <hpc> jmcarthur: my misinterpretation is a neat problem too though ;)
11:34:05 <jmcarthur> heh
11:34:05 <dmwit> So, it should be log(n^i/2^{i*(i+1)/2}), right?
11:34:33 <dmwit> where i = log(n), I guess
11:34:36 <jmcarthur> where i is what?
11:34:38 <jmcarthur> ah
11:34:41 <parcs> dmwit: right
11:34:50 <mauke> eggsNBacon: attaching 'where f1 ...' to the wrong equation?
11:34:57 <monochrom> span is a bit advanced, actually
11:35:04 <dmwit> so log(n)*log(n) - log(n)*(log(n)+1)/2*log(n)
11:35:20 <eggsNBacon> oh....
11:35:23 <dmwit> That looks insane, because it's roughly log(n)^2 - log(n)^3...
11:35:30 <parcs> right :(
11:35:32 <Sculptor> it shoudl be log(n*n/2*n/4*n/8*...)=n*log(1*1/2*1/4*1/8..)
11:35:35 <DrChaos> I've implemented (++) head last init null length map intersperse and reverse
11:35:45 <eggsNBacon> clarity is coming...first at a slow pace...then a dead run
11:35:47 <dmwit> Sculptor: Definitely not.
11:35:58 <Sculptor> dmwit, i shoud throw it on paper
11:36:00 <mauke> DrChaos: I'd definitely do sum and filter :-)
11:36:11 <mauke> as well as take, drop, and takeWhile
11:36:35 <jmcarthur> Sculptor: i think that sounds wrong
11:36:53 <mauke> spoilers: span = takeWhile + dropWhile
11:37:01 <dmwit> Ah, I'm crap at math. One of those log(n)'s is a log(2).
11:37:10 <parcs> which one?
11:37:18 <Sculptor> log(a)+log(b)=log(ab)
11:37:43 <DrChaos> mauke :: do you know of a UTF-8 character that is a down arrow?
11:37:50 <dmwit> parcs: The one in the log(n)^3 bit.
11:38:00 <dmwit> > (1-log 2/2)
11:38:02 <lambdabot>   0.6534264097200273
11:38:15 <dmwit> okay, this result passes the sanity test
11:38:18 <dmwit> It at least stays positive. =P
11:38:54 <dmwit> So log(n)*log(n) - log(n)*(log(n)+1)/2*log(2) from above, which reduces to
11:38:57 <Sculptor> log(n^n*(1/2*1/4*1/8...))= log(n^n)*log(1/2*1/4*1.8)= nlog(n)+(log(1/2*1/4*1/8...) ~= n log n
11:39:06 <DrChaos> mauke :: found it, it's U+2304
11:39:11 <dmwit> (1-log 2/2)*(log n)^2 - log 2/2 * log n
11:39:14 * hackagebot openpgp 0.6 - Implementation of the OpenPGP message format  http://hackage.haskell.org/package/openpgp-0.6 (StephenWeber)
11:39:16 * hackagebot hashable 1.2.0.3 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.3 (JohanTibell)
11:39:38 <dmwit> Sculptor: There should be log n terms, so log(n^{log n}*...) to begin with.
11:39:39 <mauke> DrChaos: 2193
11:40:38 <Sculptor> it's -1/2n(n+1)log2, says wolframalpha
11:41:56 <DrChaos> mauke :: sum' (x:xs) = x + sum' xs
11:42:05 <zhulikas> a question.
11:42:18 <zhulikas> looking for a simple way to add two rational numbers
11:42:31 <parcs> Data.Ratio
11:42:38 <zhulikas> ok, thanks
11:42:38 <watermind> so why exactly doesn't this work?  catch (return $ error "ops") (\_-> return "ok")
11:42:44 <byorgey> > (4 % 5) + (19 % 7)
11:42:46 <lambdabot>   Not in scope: `%'
11:42:46 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)Not in...
11:42:46 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:42:52 <watermind> how is lazy eval messing that up ^ ?
11:42:58 <mauke> DrChaos: fails for all lists
11:43:01 <zhulikas> > 4 R.% 5
11:43:02 <lambdabot>   4 % 5
11:43:10 <byorgey> oh, conflicts with lens =(
11:43:21 <byorgey> > (4 / 5) + (19 / 7) :: Rational
11:43:22 <lambdabot>   123 % 35
11:43:26 <byorgey> that's better
11:43:32 <zhulikas> ohh, so it allows adding up
11:43:35 <zhulikas> purrfect
11:43:42 <DrChaos> mauke :: oh, all lists as in any list of any type?
11:43:43 <byorgey> zhulikas: it has a Num instance
11:43:55 <byorgey> so it allows adding, multiplying, and subtracting
11:44:03 <byorgey> and also a Fractional instance which allows division
11:44:34 <jmcarthur> alright, i believe it is log^2
11:44:39 <DrChaos> mauke :: I think I realized that already as I specified this: sum' :: (Num a) => [a] -> a
11:44:55 <mauke> DrChaos: no, I mean you can't use this function because it'll error
11:44:55 <DrChaos> oh wait, duh
11:44:59 <mauke> for all arguments
11:44:59 <parcs> > 1/2 * log 2
11:45:00 <lambdabot>   0.34657359027997264
11:45:06 <mauke> DrChaos: also, http://dl.dropbox.com/u/41152078/unicode.html?q=down+arrow
11:45:18 <parcs> yeah i just got log^2 n as wel
11:45:24 <parcs> and wolfram alpha confirms
11:45:43 <jmcarthur> yup
11:45:49 <jmcarthur> thanks everybody!
11:46:47 <DrChaos> > let sum' [] = 0; sum' (x:[]) = x; sum' (x:xs) = x + sum' xs in sum' [1,2,3]
11:46:48 <parcs> that was an interesting question :)
11:46:48 <lambdabot>   6
11:47:07 <dmwit> Ah, log^2, one of the most ambiguous of notations. Could be log . log, d^2/(dx^2) log, or (^2) . log
11:47:32 <dolio> I wouldn't expect it to be the first.
11:47:37 <dolio> That'd be log^(2)
11:47:38 * byorgey would assume (^2) . log
11:47:43 <parcs> :t \n -> log^2 n
11:47:44 <lambdabot> (Floating a, Integral b, Num (a -> a), Num (t -> b)) => t -> a -> a
11:47:50 <dmwit> I've seen superscripts used for iteration before.
11:47:55 <jmcarthur> log^2 works with NumInstances ;)
11:47:59 <dolio> But log (log n) is a possibility, too.
11:48:04 <jmcarthur> yeah
11:48:14 <dmwit> dolio: Isn't log (log n) the first I wrote?
11:48:21 <dmwit> The one you said you wouldn't expect it to be?
11:48:24 <dolio> Oh.
11:48:30 <dolio> I read past that one.
11:48:30 <monochrom> don't you love unambiguous-to-the-author notation?
11:48:42 <dolio> I only saw the derivative and the (^2) . log one somehow.
11:48:44 <jmcarthur> the operator is well defined in my head
11:48:56 <byorgey> dmwit: indeed, but with things like sin, log, etc. the convention seems to be that superscripts mean the thing they shouldn't
11:49:12 <DrChaos> should take' have this type: take' :: (Integer a) => a -> [b] -> [b]
11:49:15 * hackagebot openpgp-crypto-api 0.6 - Implement cryptography for OpenPGP using crypto-api compatible libraries  http://hackage.haskell.org/package/openpgp-crypto-api-0.6 (StephenWeber)
11:49:15 <parcs> i've only seen log^2 n mean (log n)^2
11:49:26 <monochrom> Integer? Integral?
11:49:38 <dolio> Anyhow, derivatives usually have the number in parentheses, as I recall.
11:49:43 <mauke> :t take
11:49:44 <lambdabot> Int -> [a] -> [a]
11:49:45 <byorgey> DrChaos: looks sensible, assuming you mean Integral instead of Integer
11:49:46 <mauke> :t genericTake
11:49:47 <monochrom> perhaps even Num?
11:49:47 <lambdabot> Integral i => i -> [a] -> [a]
11:49:51 <dmwit> dolio: Ah, yeah, that could be.
11:49:57 <dolio> Which is certainly a clear differentiation.
11:50:17 * dmwit chuckles
11:50:19 <byorgey> har har
11:50:38 <monochrom> haha
11:51:34 <notthemessiah> hiptobecubic: were you talking about this? http://blog.sigfpe.com/2010/05/optimising-pointer-subtraction-with-2.html
11:52:19 <notthemessiah> I only 'learned' about p-adic numbers in my topology class, but didn't look further into them yet
11:52:21 <dolio> Of course, I think f^(n) is also notation for other things, though I can't recall what at the moment.
11:53:56 <jmcarthur> the problem became easier by reexpressing it.   O(log n + log (n/2) + log (n/4) + log (n/8) + ... + log (n/n)) = O(log 1 + log 2 + log 4 + log 8 + ... + log n)
11:56:22 <srruby> I have some global variables that get read from the command line, but should also be able to be set as needed for testing. Do I need to pass them around to every function that needs them?
11:56:49 <Taneb> @hoogle withArgs
11:56:49 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
11:56:54 <parcs> jmcarthur: how is that the same?
11:56:56 <Taneb> srruby, try that?
11:57:07 <jmcarthur> parcs: reverse the order of the original
11:57:09 <srruby> Thanks
11:57:37 <DrChaos> take' 0 xs = xs
11:57:39 <DrChaos> take' n (x:xs) | n < 0     = error "n cannot be negative"
11:57:41 <DrChaos>                | otherwise = x : take (n-1) xs
11:57:43 <parcs> jmcarthur: oh
11:58:17 <mauke> srruby: yes, but there are ways to semi-automate it
11:58:40 <mauke> e.g. you can use a monad to pass them around for you
11:58:50 <mauke> or you can use black magic (reflection)
11:59:11 <mauke> DrChaos: that looks like it does nothing
11:59:15 * hackagebot openpgp-Crypto 0.5 - Implementation of cryptography for use with OpenPGP using the Crypto library  http://hackage.haskell.org/package/openpgp-Crypto-0.5 (StephenWeber)
11:59:37 <DrChaos> erm...so why does a type signature of "(Integral a) => a -> [b] -> [b]" make ghci not able to deduce (a ~ Int) from the context (Integral a) in the first argument of `(-)', namely `n' in the first argument of take, namely `(n - 1)'?
12:00:06 <dolio> :t take
12:00:07 <lambdabot> Int -> [a] -> [a]
12:00:10 <hpaste> me pasted “Non-exhaustive” at http://hpaste.org/80311
12:00:14 <DrChaos> but Int is a member of Integral, I don't get it
12:00:37 <mauke> DrChaos: what's your code? what's the error message?
12:00:40 <dolio> There are things that aren't Int that are members of Integral.
12:00:47 <mauke> DrChaos: oh, I see
12:00:53 <mauke> DrChaos: you're calling take
12:01:03 <eggsNBacon> http://hpaste.org/80311 <-- Don't see the problem here. "ys" is never reduced, so I don't see what other pattern there is to catch other than an empty "xs" list
12:01:53 <mauke> eggsNBacon: 'p' /= 'P'
12:02:02 <DrChaos> shapr :: hpasteit needs to have a longer timeout for connecting to hpaste.org on slow connections
12:02:12 <srruby> I installed hoogle on my system and from the command prompt typed  hoogle withArgs      ; I got the function signature but not the docs. How can I get the docs? The online version gives me the documentation not just the signature
12:02:18 <byorgey> oooh, nice catch mauke
12:02:27 * byorgey was scratching his head over that one
12:02:50 <monochrom> oh haha nice
12:03:05 <DrChaos> I'm able to send pastes to vpaste.net with the script on vpaste.net [calls curl] but could not send pastes to hpaste.org with hpasteit
12:03:10 <monochrom> well, that's what you get for camel case
12:03:17 <DrChaos> mauke :: here's my code: http://vpaste.net/OBakZ
12:03:35 <mauke> <mauke> DrChaos: you're calling take
12:03:53 <monochrom> ByteString? Bytestring? cartprod? cartProd? etc etc. or etC?
12:04:05 <DrChaos> mauke :: OH
12:04:08 <DrChaos> hahah
12:04:10 <eggsNBacon> mauke: what does 'p' /= 'P' have to do with this -> http://hpaste.org/80311 ?
12:04:35 <monochrom> eggsNBacon, cartprod vs cartProd
12:04:44 <monochrom> and that's what you get for camel case
12:05:03 <eggsNBacon> the horror....
12:05:07 * BMeph corrects: camelCase
12:05:11 <mauke> caMelcase
12:05:13 <eggsNBacon> Time to hang it up for the day when I get errors like this
12:06:46 <BMeph> Did anyone else find it hilarious that "eggsNBacon" is a camel case-style name? :)
12:07:24 <monochrom> I didn't notice. but haha
12:07:39 <DrChaos> mauke :: wait, my take' function isn't working properly
12:07:46 <DrChaos> the problem is with take' 0 xs = xs
12:08:04 <monochrom> clearly, that is wrong
12:08:14 <srruby> hoogle (installed via cabal) only gives me function signatures. How do I get full docs?
12:08:15 <DrChaos> that doesn't make any sense, it means that take 0 = <the whole rest of the list>
12:08:30 <DrChaos> which reduces down to the whole list, non zero argument or not
12:08:49 <DrChaos> simplest case: take' 0 [1,2] returns [1,2]
12:09:01 <osfameron> some APIs have 0 as a degenerate "everything" case...
12:09:14 <osfameron> I can't see that a) being very haskellish or indeed b) working for a recursive algorithm ;-)
12:11:45 <monochrom> srruby: hackage has docs. "cabal install" may also put docs in your hard disk. but you have to find them by module name and function name
12:12:21 <DrChaos> mwahahahah, the simplest fix: take' 0 xs = []
12:12:29 <simpson> DrChaos: Yep.
12:13:17 <min|dvir|us> Can you redefine a function?
12:13:23 <monochrom> no
12:14:21 <min|dvir|us> How does Haskell know if a function is defined?
12:14:25 <min|dvir|us> If it has a catchall clause?
12:15:00 <simpson> min|dvir|us: Haskell's compilation is module-at-a-time, so there's no ambiguity over whether a module has a given function.
12:15:35 <monochrom> there is no need for a catchall clause. just look at the whole file.
12:15:45 <min|dvir|us> simpson: so if the function has any definition at all within a module, it is assumed to be local?
12:16:13 <mauke> what do you mean by "local"?
12:16:42 <DrChaos> mauke :: I just implemented take and drop
12:16:54 <min|dvir|us> mauke: Say I'm making a new function called "head". Theoretically, that would shadow the built-in head, for the module it's in, yes?
12:16:55 <monochrom> perhaps I should just suggest http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1070005.5 ?
12:16:59 <DrChaos> drop' 0 xs = xs
12:17:01 <DrChaos> drop' n (x:xs) = drop' (n-1) xs
12:17:07 <min|dvir|us> > let head (x:xs) = x in head 'test'
12:17:09 <lambdabot>   Syntax error on 'test'
12:17:09 <lambdabot>  Perhaps you intended to use -XTemplateHaskell
12:17:13 <min|dvir|us> > let head (x:xs) = x in head "test"
12:17:15 <lambdabot>   't'
12:17:22 <min|dvir|us> > let head (x:xs) = xs in head "test"
12:17:24 <lambdabot>   "est"
12:17:39 <DrChaos> min|dvir|us :: only inside of a let expression, I think
12:17:44 <monochrom> yes there is shadowing. try "let 2+2=5 in 2+2"
12:17:45 <mauke> min|dvir|us: no
12:17:55 <DrChaos> it would only shadow the built in head inside of a let expression
12:18:19 <min|dvir|us> > let 2+2=5 in 2+2
12:18:20 <DrChaos> or a where expression, for that matter
12:18:21 <lambdabot>   5
12:18:25 <min|dvir|us> Wow, that's crazy.
12:18:29 <|||tux||> Yes
12:18:47 <Eelis> lol
12:18:59 <monochrom> but if you write at the top level "head (x:xs) = xs" the story is a bit different
12:19:12 <min|dvir|us> How is the story different?
12:19:16 <DrChaos> mauke :: now I have to implement takeWhile and filter
12:19:17 <|||tux||> > let _+_ = 42 in 3+4
12:19:18 <lambdabot>   42
12:19:21 <|||tux||> lol
12:19:41 <min|dvir|us> Oh, I get it.
12:19:43 <mauke> > let _ + _ = 42 in "hello" + ()
12:19:44 <lambdabot>   42
12:19:45 <min|dvir|us> It's pattern matching for +.
12:19:57 <monochrom> Prelude has head. the full name is Prelude.head. head is short form.
12:20:36 <monochrom> your top level definition creates Main.head (or replace Main by your module name). Main.head is the full name. head is short form.
12:20:41 <DrChaos> mauke :: how would you define a function that takes another function whose result must be Bool?
12:21:04 <monochrom> so if you then speak like "Prelude.head" and "Main.head", that's fine. but if you say "head", now it's ambiguous
12:21:35 <min|dvir|us> But isn
12:21:41 <min|dvir|us> But isn't . compose?
12:21:55 <monochrom> not always, apparently
12:22:23 <monochrom> afterall, if 3.14 meant (\x -> 3 (14 x)), life would really suck, wouldn't it?
12:22:38 <mauke> DrChaos: a b = ...
12:22:39 <min|dvir|us> That's true.
12:23:09 <DrChaos> mauke :: no, in a function's type signature
12:23:11 <Lethalman> DrChaos, func :: (a -> Bool) -> Something
12:23:14 <monochrom> let me try something
12:23:16 <DrChaos> ah
12:24:12 <parcs> DrChaos: hpasteit frequently times out for you?
12:24:16 * hackagebot punycode 2.0 - Encode unicode strings to ascii forms according to RFC 3492  http://hackage.haskell.org/package/punycode-2.0 (MylesMaxfield)
12:24:20 <monochrom> > (length.Data.List.sort) [1,2,3]
12:24:22 <lambdabot>   3
12:24:24 <monochrom> haha
12:24:43 <monochrom> all three dots are different there!
12:25:04 <min|dvir|us> monochrom: what are the 2nd and 3rd ones doing?
12:25:04 <mauke> > Left.Right
12:25:06 <lambdabot>   Not in scope: data constructor `Left.Right'
12:25:25 <min|dvir|us> > Data.List.sort
12:25:27 <lambdabot>   No instance for (GHC.Show.Show ([a0] -> [a0]))
12:25:27 <lambdabot>    arising from a use of `M4...
12:25:29 <mauke> min|dvir|us: Data.List is the name of a module
12:25:40 <monochrom> we have hierarchical module names, like in java. so, a module name could be Data.List, that's one single module name
12:25:54 <min|dvir|us> I see. Then what's .sort?
12:26:18 <|||tux||> The sort function from that module
12:26:25 <min|dvir|us> Whta does the . mean, I mean?
12:26:27 <monochrom> but of course we also support the syntax Module.variable to refer to the variable in the Module
12:26:27 <min|dvir|us> *What
12:26:33 <min|dvir|us> I see.
12:27:02 <monochrom> Prelude.head is of that same form, Module.variable
12:27:17 <mauke> > 2 Prelude.+ 3
12:27:19 <lambdabot>   5
12:27:26 <monochrom> yeah!
12:27:36 <monochrom> > let 2+2=5 in 2 Prelude.+ 2
12:27:38 <lambdabot>   4
12:27:46 <DrChaos> erm...a little help please? http://vpaste.net/04aLr
12:28:16 <DrChaos> it seems my takeWhile' function is not applying the function "f x" properly, or wrong type signature
12:28:31 <Nereid> what is the f in the type signature?
12:28:32 <mauke> your type signature is wrong. it claims f takes two arguments
12:29:28 <DrChaos> doesn't (==) take two arguments?
12:29:33 <monochrom> yeah, what is "f -> a -> Bool" doing there?
12:29:39 <min|dvir|us> DrChaos: yes.
12:29:40 <mauke> DrChaos: it does, yes
12:29:43 <srruby> hoogle (installed via cabal) only gives me function signatures. How do I get full docs?
12:29:43 <DrChaos> > takeWhile (== 5) [5,5,5]
12:29:45 <lambdabot>   [5,5,5]
12:29:51 <mauke> > takeWhile (==)
12:29:53 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
12:29:53 <lambdabot>              with actual type...
12:29:53 <monochrom> (== 5) takes one argument
12:30:00 <DrChaos> awesome
12:30:38 <DrChaos> so what should the type signature be? (f -> Bool) -> [a] -> [a]?
12:30:44 <monochrom> why f?
12:31:01 <DrChaos> f for function
12:31:05 <mauke> wat
12:31:20 <DrChaos> might as well call it b
12:31:25 <|||tux||> What's about (a -> Bool) -> [a] -> [a] ?
12:31:26 <min|dvir|us> (a -> Bool) -> [a] -> [a]
12:31:28 <mauke> yeah, but it would still be wrong
12:31:43 <min|dvir|us> Because a is the same type for all of those places.
12:32:31 <DrChaos> *Main> takeWhile' (== 5) [5,5,4,5]
12:32:34 <DrChaos> [5,5]
12:32:38 <DrChaos> it's verking!
12:33:06 <srruby> Here is the answer to my question:  from the command line:    $ hoogle search --info withArgs
12:33:07 <mauke> now all that's missing is dropWhile, I think
12:34:01 <monochrom> thanks srruby
12:34:54 <Nereid> > let take' n = map snd . takeWhile ((< n) . fst) . zip [0..] in take' 3 [a,b,c,d,e,f]
12:34:56 <lambdabot>   [a,b,c]
12:35:02 <Nereid> awful
12:35:22 <monochrom> heh
12:36:10 <Nereid> > let take' n = zipWith (const id) (replicate n ()) in take' 3 [1..]
12:36:11 <lambdabot>   [1,2,3]
12:36:17 <Nereid> better.
12:38:04 <fmap> > let take' n xs = xs ^.. taking n folded in take' 3 [1..]
12:38:06 <lambdabot>   [1,2,3]
12:38:30 <monochrom> @type (^..)
12:38:31 <lambdabot> s -> Getting (Endo [a]) s t a b -> [a]
12:39:02 <monochrom> oh! "taking n folded" is not English!
12:39:02 <Nereid> :t \n -> toListOf (taking n folded)
12:39:03 <lambdabot> Foldable f => Int -> f b -> [b]
12:39:55 <monochrom> I was imagining: let blah = blahblah ^.. this is a comment :)
12:40:10 <Nereid> @let takeOf l n = toListOf (taking n l)
12:40:12 <lambdabot>  Defined.
12:40:16 <Nereid> > takeOf folded 3 [1..]
12:40:19 <lambdabot>   [1,2,3]
12:40:24 <mauke> > takeOff
12:40:26 <lambdabot>   Not in scope: `takeOff'
12:40:26 <lambdabot>  Perhaps you meant `takeOf' (line 12)
12:40:43 <Nereid> > takeOf each 3 (1,2,3,4,5)
12:40:44 <lambdabot>   Not in scope: `each'
12:40:47 <Nereid> argh
12:44:17 * hackagebot hpasteit 0.3.1 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.3.1 (PatrickPalka)
12:44:37 <johnw> joeyh: ping
12:45:12 <byorgey> parcs: what's new in 0.3?
12:47:04 <parcs> byorgey: a few things. there's a changelog on the hackage page
12:48:43 <parcs> ...and i just uploaded 0.3.2. yay for 'release first, test later'
12:49:00 * min|dvir|us doesn't always test, but when he does, he tests on production.
12:49:18 * hackagebot hpasteit 0.3.2 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.3.2 (PatrickPalka)
12:49:19 <monochrom> just call it "clinical test" :)
12:51:21 <parcs> hehe
12:52:16 <johnw> the best thing about production is that it often lets you know really quickly if there are problems
12:52:38 <johnw> deploying to a test server is like, "well, so that happened"
12:53:40 <monochrom> yes of course, but problems at production are also very costly
12:54:45 <monochrom> not to say that there is any crystal ball to foresee all problems
12:56:45 <hpaste> Anonymous pasted “just a test” at http://hpaste.org/80314
12:56:52 <hpaste> johnw pasted “just a test” at http://hpaste.org/80315
12:56:59 <johnw> nifty
12:58:43 <parcs> > 0.003 :: Micro
12:58:44 <lambdabot>   0.003000
12:58:56 <parcs> > toInteger (0.003 :: Micro)
12:58:58 <lambdabot>   No instance for (GHC.Real.Integral Data.Fixed.Micro)
12:58:58 <lambdabot>    arising from a use ...
13:01:48 <parcs> would it be a good idea to use 'HasResolution a => Fixed a' instead of just 'Integer' for units of time?
13:03:04 <srruby> is it wrong to use unsafePerformIO getArgs to grab command line parameters?
13:03:22 <parcs> it really sucks that you can't tell what unit of time is expected for eg threadDelay by just looking at its type
13:03:53 <zomg> srruby: I don't think it's a good idea to use unsafePerformIO unless you want to cheat the limitations on where you can do IO, which at least to me seems like a questionable practice =)
13:04:03 <simpson> parcs: Only in that it has a stupidly high resolution. I expected it to be ms the first couple times I used it. :T
13:04:10 <shachaf> srruby: Yes, don't use unsafePerformIO.
13:04:27 <shachaf> srruby: It's called unsafe for a reason. Just use getArgs normally, unless you have some good reason not to?
13:04:31 <geekosaur> srruby, I *think* it will actualy work, but there's no particular reason a haskell compilr couldn't take apparent purity as meaning "precompute this and compile in the result" which would be Bad in this case
13:05:35 <srruby> I need a magic number from the command line in a few deeply nested functions. Otherwise I'm having to pass them all around the program...
13:05:54 <mauke> geekosaur: you can setArgs
13:06:08 <geekosaur> huh, I must have missed that
13:06:14 <johnw> srruby: that's something the Reader monad is good for
13:06:14 <mauke> :t withArgs
13:06:16 <lambdabot> Not in scope: `withArgs'
13:06:20 <mauke> @hoogle withArgs
13:06:21 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
13:08:54 <Clint> is there some kind of caching layer i can put on top of persistent?
13:17:32 <knrafto> okay, i get the following error when trying to use attoparsec: http://hpaste.org/80316. do I have to reinstall bytestring with a lower version?
13:18:15 * knrafto
13:19:37 <srhb> knrafto: Could you include the code that causes the error.
13:20:13 <hpaste> “ByteString dependencies” annotated “knrafto” with “knrafto (annotation)” at http://hpaste.org/80316#a80317
13:20:45 <srhb> knrafto: And the imports, at least. It probably is some version conflict though.
13:21:01 <geekosaur> that looks like you have two versions of bytestring installed and different dependencies are pulling in different versions
13:21:29 <hpaste> “ByteString dependencies” annotated “knrafto” with “knrafto (annotation) (annotation)” at http://hpaste.org/80316#a80318
13:22:00 <srhb> Yep. Version conflict.
13:22:25 <knrafto> should I uninstall one of the versions?
13:22:32 <knrafto> how do i do that?
13:22:44 <srhb> But is it necessary to pull in those two versions of ByteString?
13:22:51 <srhb> Oh, nevermind me
13:22:54 <srhb> One is the Char8 one
13:23:48 <srhb> knrafto: The easier thing is probably clearing your packages altogether
13:24:58 <knrafto> is there a cabal command for that?
13:25:38 <srhb> knrafto: I think you just fry ~/.cabal -- but save anything you might want to keep
13:25:52 <srhb> (You might also want to wait for someone more knowledgeable than me to confirm that)
13:27:32 <Nereid> srhb: the important stuff is in ~/.ghc
13:28:32 <Nereid> is there ever a reason to do an unqualified import X as Y?
13:29:38 <hpc> Nereid: if you only ever refer to overlaps by qualified name and can't be arsed to do a full explicit import?
13:29:49 <hpc> import Data.Set as S
13:29:53 <hpc> import Data.Map as M
13:30:00 <knrafto> Nereid: i think i used attoparsec's "take" which is in Prelude, and i didn't feel like qualifying every other attoparsec funtion
13:30:01 <Nereid> so why not import qualified?
13:30:04 <knrafto> function*
13:30:08 <hpc> now you can use lookup and get a compile error, or use M.lookup and S.lookup
13:30:09 <Nereid> oh.
13:30:11 <Nereid> hmm
13:30:16 <hpc> but you can still use Map and Set unqualified
13:30:27 <hpc> and other stuff like mapIndices or whatever is in those modules
13:31:03 <hpc> yeah, overlapping name errors are deferred to when they actually happen
13:31:23 <pdxleif> What's the state of the art in formlet-y lens-y stuff?  digestive functors, reform, fresnel, boomerang, ...?
13:31:54 <edwardk> pdxleif: interestingly we've been talking about formatting in the #haskell-lens channel for the last day or so ;)
13:32:31 <edwardk> not sure how it fits to formlets yet, but so far the new ideas are interesting but under-formed
13:32:39 <srhb> I still find it oddly perverse that there's a -lens channel now, but I probably just haven't seen the light yet. :P
13:32:52 <shachaf> srhb: The light is in #-lens!
13:32:55 <shachaf> Come and see!
13:32:57 <byorgey> hpc: and you also have to use Prelude.map etc.
13:33:04 <srhb> shachaf: But the types, oh God the types...
13:33:14 <shachaf> It's not so bad.
13:33:24 <byorgey> the types are really beautiful once you know the right way to squint at them.
13:33:36 <hpc> byorgey: heh yeah, those modules cause a whooooole lot of clashing :P
13:33:39 <srhb> It's impressive how often that expression is used in complicated haskelly stuff
13:33:50 <edwardk> srhb: Think of it from a Nietzsche-esque perspective. That which doesn't kill you and all that. ;)
13:33:55 <srhb> Right :P
13:34:19 <edwardk> i don't think we've killed anyone with the types yet
13:34:19 <simpson> There's a running tally of unsafeCoerces in the /topic.
13:34:23 <edwardk> i could be wrong
13:34:33 <edwardk> simpson: its down by a factor of 10 ;)
13:34:33 <srhb> Absense of proof is not proof of absense. :P
13:34:44 <simpson> edwardk: Are you attempting to get them all out? :3
13:34:58 <edwardk> simpson: no. we outsourced a bunch to 'profunctors' recently
13:34:59 <pdxleif> Maybe I was thinking that, as this this language calls bi-directional mappings defined between models and views "lenses": http://www.seas.upenn.edu/~harmony/
13:35:07 <shachaf> edwardk: "outsourced"
13:35:16 <shachaf> We're still completely vulnerable to accidentally exporting unsafeCoerce
13:35:44 <edwardk> shachaf: i'm open to fixes. we could bring back NewtypeComposition, etc. not sure its worth it.
13:35:44 <c_wraith> That seems like a bad thing to export
13:35:54 <edwardk> c_wraith: we don't currently export it
13:36:03 <edwardk> c_wraith: its more the risk being there if we let our attention lapse
13:36:15 <shachaf> For example, define something as a prism instead of a newtype.
13:36:20 <shachaf> Er, as a data instead of a newtype
13:36:25 <shachaf> But who would do *that*, right?
13:36:29 <edwardk> shachaf: =P
13:36:35 <edwardk> it was caught by the test suite =P
13:37:05 <edwardk> anyways, you can go back and spend time getting back the safety of -fsafe if you want
13:37:09 <Ziarkaen> I have f :: IO String and I want to have an infinite list of the values returned by sucessive calls to f i.e. g :: IO [String]
13:37:15 <edwardk> i'd rather play with formats for the moment
13:37:29 <shachaf> Ziarkaen: Infinite lists + IO are tricky.
13:37:32 <Ziarkaen> (application: f is random choice and I want infintie list of random choices)
13:37:45 <shachaf> Because that gets you lazy IO, which can be all sorts of unpredictable.
13:37:52 <shachaf> Oh, if you have randomness that's not so bad.
13:37:54 <Hafydd> Why not [IO String]?
13:37:57 <shachaf> But you can also use a pure RNG.
13:38:05 <Hafydd> Nevermind, that's silly.
13:38:06 <shachaf> Hafydd: That would defeat the purpose, presumably.
13:38:22 <srhb> This conversation perfectly illustrated my concern; I'm not able to effectively rule out that your ramblings are those of men who dove too deep into the chasm and lost their sanity on the journey.
13:38:37 <shachaf> > randoms (mkStdGen 0)
13:38:38 <lambdabot>   [-117157315039303149,-8854136653200549331,-2598893763451025729,-21049421333...
13:39:19 <croikle> @hoogle m a -> m [a]
13:39:19 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
13:39:19 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
13:39:19 <lambdabot> Test.QuickCheck.Gen listOf :: Gen a -> Gen [a]
13:39:49 <shachaf> You can also do this with a function called unsafeInterleaveIO
13:39:58 <shachaf> But you should be sure that you understand the consequences first.
13:40:07 <shachaf> @let now a k b = k (b <> a); later f k m a = k (m <> f a); run l = l id mempty
13:40:09 <lambdabot>  Defined.
13:40:27 <shachaf> > run (now "x = " . later show . now ", y = " . later show) 2 4
13:40:29 <srhb> Getting a single random seed from IO seems a fair use case for unsafePerformIO doesn't it?
13:40:30 <lambdabot>   "x = 2, y = 4"
13:40:34 <edwardk> > run (now "hello " . later show . now " there") 12
13:40:37 <lambdabot>   "hello 12 there"
13:40:37 <srhb> I mean, you should only need it once anyway
13:40:42 <srhb> (For many use cases)
13:40:47 <shachaf> srhb: You don't need unsafePerformIO here, only unsafeInterleaveIO
13:41:01 <shachaf> Er, you were talking about something else.
13:41:01 <srhb> Hmm, I don't know the difference. *reading up*
13:41:07 <shachaf> Ziarkaen wanted a random stream, not a random seed.
13:41:10 <srhb> Ay
13:41:12 <srhb> Ah*
13:41:15 <Nereid> f m = unsafeInterleaveIO (f' m) where f' m = do { x <- m; xs <- f' m; return (x:xs) }
13:41:15 <Nereid> :c
13:41:34 <shachaf> Nereid: I think you'll have to use f m inside there.
13:41:35 <Nereid> ... = liftM2 (:) m (f' m)
13:41:39 <Ziarkaen> It seems too complicated. I can implement the functionality using a loop :)
13:41:39 <Nereid> eh
13:41:41 <Nereid> maybe.
13:41:41 <shachaf> Or a second unsafeInterleaveIO
13:41:50 <shachaf> Otherwise you don't get an actual lazy list. :-)
13:42:05 <Nereid> yeah
13:45:53 <mikeplus64> Ziarkaen: someone suggested [IO String], why not IO [IO String]? worst of both worlds ;)
13:46:14 <Ziarkaen> Haa
13:46:15 <hpc> mikeplus64: there can be only one option!
13:46:19 <hpc> Mu (Compose [] IO)
13:46:32 <Nereid> :po
13:46:38 <Nereid> fsfd
13:46:38 <hpaste> twopoint718 pasted “Github gists” at http://hpaste.org/80319
13:46:39 <Nereid> r
13:46:40 <Ziarkaen> I only considered usign an infinite list because it seemed more idiomatic.  My first thought was: just use a loop.
13:46:48 <shachaf> mikeplus64: You could always add on another IO.
13:47:00 <mikeplus64> certainly never hurts, shachaf
13:47:12 <hpc> Ziarkaen: don't worry, your mind will soon be tainted with infinite data structures
13:47:20 <shachaf> (IO (IO a) is a very different thing from IO a.)
13:47:33 <chris___> So I had a question about the above paste. I have an HTTP POST that I wish to make but I'm unsure of the URL-encoded body to set.
13:47:35 <hpc> Ziarkaen: about a month ago, i totally forgot that you could do [x, y .. z]
13:47:42 <hpc> and thought you could only do [x, y ..]
13:54:03 <simpson> This might be a bit obscure, but what's the point of an irrefutable pattern match?
13:54:44 <byorgey> the short answer is to introduce extra laziness
13:55:05 <hpc> > let f ~(x,y) = 5 in f undefined
13:55:06 <lambdabot>   5
13:55:09 <hpc> > let f (x,y) = 5 in f undefined
13:55:13 <lambdabot>   *Exception: Prelude.undefined
13:55:51 <hpc> it has less contrived uses than that, where a strict match would be undefined and a lazy one evaluates
13:55:58 <hpc> i just can't remember one off the top of my head
13:56:14 <byorgey> f (x:xs) = ...  will evaluate its argument to see whether it is [] or a cons before evaluating the ... part
13:56:16 <simpson> Hm. So the annotation's purpose is to defer the evaluation until absolutely needed, then?
13:56:39 <byorgey> whereas  f ~(x:xs) = ...   will immediately start evaluating ... and only evaluate the argument when it becomes necessary to use x or xs.
13:56:46 <hpc> it's the same as saying f z = let (x,y) = z in undefined
13:56:56 <hpc> er, in 5
13:56:58 <simpson> Interesting.
13:57:17 <simpson> Well, that makes sense. Now I know. Thanks!
13:57:36 <hpc> the haskell wiki should have an example or two
13:58:07 <byorgey> simpson: note, however, if you call  f ~(x:xs) = ...   on the empty list, it will crash at some time later when it tries to use x or xs.
13:58:25 <byorgey> that is, it can also be used to defer evaluation until after it's too late.
13:59:18 <simpson> Aha.
13:59:34 <aavogt> it's somewhat useful with @ too
14:00:27 <aavogt> > let f (list @ ~ (x:xs)) = if null list then 1 else x in (f [], f [4,2])
14:00:28 <lambdabot>   (1,4)
14:01:21 <shachaf> aavogt: If you're doing "if null list" *anyway*, you might as well pattern-match then.
14:03:33 <mauke> > let pack [] = []; pack (x : xs) = case span (x ==) xs of (xs', ys) -> (x : xs') : pack ys in pack [1,1,1,2,1]
14:03:35 <lambdabot>   [[1,1,1],[2],[1]]
14:03:40 <mauke> > let pack [] = []; pack (x : xs) = case span (x ==) xs of (xs', ys) -> (x : xs') : pack ys in pack [0 ..]
14:03:41 <lambdabot>   [[0],[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16]...
14:03:58 <nh2> is this a GHC bug? http://hpaste.org/80320
14:04:12 <aavogt> shachaf: yeah it's a useless contrived example
14:04:24 <nh2> I get a linker error and that weird low-level output
14:04:33 <hpc> nh2: that's awesome; what's the source?
14:04:34 <nh2> after a cabal clean && cabal build
14:04:45 <mauke> @zdec hopfieldzm0zi1zi0zi0_HopfieldziClusterExperiments_T2_closure
14:04:45 <lambdabot> Unknown command, try @list
14:05:01 <shachaf> hopfield-0.1.0.0_Hopfield.ClusterExperiments_T2_closure
14:05:09 <shachaf> What version of GHC is that?
14:05:33 <nh2> hpc: closed until some guy publishes some paper :( I just want to know in what cases GHC will actually pass through linker errors, if we can't find out the source will be up in 2 months
14:05:52 <hpc> oh fun
14:06:05 <hpc> nh2: can you make a small reproduction?
14:07:07 <nh2> hpc: yep I will, but that will take a while
14:07:08 <mauke> > let spam _ [] = ([], []); spam p ys@(x : xs) | p x = case spam p xs of (ls, rs) -> (x : ls, rs) | otherwise = ([], ys) in spam (< 3) [1, 2, 3, 2, 3, 1]
14:07:10 <lambdabot>   ([1,2],[3,2,3,1])
14:07:23 <mauke> > let spam _ [] = ([], []); spam p ys@(x : xs) | p x = case spam p xs of (ls, rs) -> (x : ls, rs) | otherwise = ([], ys) in spam (< 3) [1, 1 ..]
14:07:25 <lambdabot>   *Exception: stack overflow
14:07:32 <mauke> > let spam _ [] = ([], []); spam p ys@(x : xs) | p x = case spam p xs of ~(ls, rs) -> (x : ls, rs) | otherwise = ([], ys) in spam (< 3) [1, 1 ..]
14:07:34 <lambdabot>   ([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:07:43 <mauke> irrefutable patterns, ladies and gentlemen
14:07:58 <neutrino> hello
14:08:21 <mauke> does this count as a useful example?
14:08:29 <Nereid> yes
14:08:50 <Nereid> > let spam _ [] = ([], []); spam p ys@(x : xs) | p x = case spam p xs of ~(ls, rs) -> (x : ls, rs) | otherwise = ([], ys) in snd $ spam (< 3) [1, 1 ..]
14:08:54 <lambdabot>   mueval-core: Time limit exceeded
14:10:27 <aavogt> > let spam _ [] = ([], []); spam p ys@(x : xs) | p x = let (ls,rs) = spam p xs in (x : ls, rs) | otherwise = ([], ys) in spam (< 3) [1, 1 ..]
14:10:28 <lambdabot>   ([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
14:11:03 <nh2> hpc: seems to happen when I have a main in a module that is not listed in my cabal file
14:11:31 <Nereid> hmm
14:13:05 <nh2> so it might also cabal be doing something weird
14:14:47 <DrChaos> hello
14:14:59 <DrChaos> mauke :: I implemented filter just now
14:15:10 <DrChaos> *Main> filter' (== 5) [1,2,3,4,5,5,1,5]
14:15:12 <DrChaos> [5,5,5]
14:16:42 <parcs> > exp 1 ** (1/exp 1)
14:16:43 <lambdabot>   1.444667861009766
14:16:47 <parcs> > sqrt 2
14:16:49 <lambdabot>   1.4142135623730951
14:17:03 <DrChaos> except, how do I filter this: x / 2 == 0
14:17:15 <DrChaos> where x is a number from the list
14:17:22 <Nereid> use a lambda
14:17:30 <Nereid> @ty \p -> foldr (\a -> if p a then (a:) else id) []
14:17:31 <lambdabot> (a -> Bool) -> [a] -> [a]
14:17:59 <shachaf> @ty \p -> toListOf (traverse.filtered p)
14:18:00 <lambdabot> Traversable t => (b -> Bool) -> t b -> [b]
14:18:11 <Nereid> @ty \p -> toListOf (folded.filtered p)
14:18:12 <lambdabot> Foldable f => (a -> Bool) -> f a -> [a]
14:18:23 <DrChaos> *Main> filter' (\_ -> `mod` 2 == 0) [1..10]
14:18:30 <DrChaos> <interactive>:22:16: parse error on input ``'
14:18:32 <Nereid> what
14:18:54 <shachaf> f a -> [a], not f a -> f a
14:19:16 <Nereid> no, what to DrChaos.
14:19:22 <hpc> DrChaos: \x -> x `mod` 2 == 0
14:19:27 <Nereid> yes
14:19:28 <DrChaos> oh
14:19:31 <parcs> > iterate (** sqrt 2) (sqrt 2) !! 1000
14:19:33 <lambdabot>   Infinity
14:19:41 <parcs> > iterate (sqrt 2 **) (sqrt 2) !! 1000
14:19:41 <roadfish> I can define add5 = (+ 5) so that add5 3 is 8. But sub5 = (- 5) is the number -5. sub5 8 doesn't give 3. Can I define a points-free sub5?
14:19:43 <lambdabot>   2.0000000000000004
14:19:44 <Nereid> > iterate (** sqrt 2) (sqrt 2)
14:19:45 <lambdabot>   [1.4142135623730951,1.632526919438153,2.0000000000000004,2.665144142690226,...
14:19:52 <DrChaos> *Main> filter' (\x -> x `mod` 2 == 0) [1..10]
14:19:53 <DrChaos> [2,4,6,8,10]
14:19:55 <DrChaos> wow
14:19:58 <mauke> roadfish: sub5 = subtract 5
14:20:02 <parcs> > let x = e**(1/e) in iterate (x **) x !! 1000
14:20:04 <lambdabot>   (e**(1 / e))**(e**(1 / e))**(e**(1 / e))**(e**(1 / e))**(e**(1 / e))**(e**(...
14:20:07 <parcs> fak
14:20:14 <parcs> > let x = exp 1**(1/exp 1) in iterate (x **) x !! 1000
14:20:15 <mauke> DrChaos: filter' even [1 .. 10]
14:20:15 <Nereid> > filter even [1..10]
14:20:15 <lambdabot>   2.7128782418434283
14:20:16 <lambdabot>   [2,4,6,8,10]
14:20:35 <parcs> amazing isn't it
14:20:41 <Nereid> no :p
14:21:20 <parcs> > exp 1 ** (2/exp 1)
14:21:21 <lambdabot>   2.087065228634533
14:21:30 <parcs> > let x = exp 1**(2/exp 1) in iterate (x **) x !! 1000
14:21:31 <lambdabot>   Infinity
14:21:32 <DrChaos> mauke :: why does (\x -> x `mod 2 == 0) run slower?
14:21:48 <DrChaos> erm...put a ` after the d in `mod
14:21:59 <parcs> Nereid: in ##math we were discussing for what values of x does x^x^x^x^x^.. converge to a nonzero value
14:22:04 <mauke> DrChaos: oh, does it?
14:22:09 <parcs> Nereid: the upper bound is e^(1/e), i think
14:22:11 <jix> is there a library that provides a something that is like a Seq (k, v) and a Map k v at the same time?
14:22:15 <DrChaos> mauke :: yes
14:22:22 <mauke> DrChaos: how did you test it?
14:22:34 <DrChaos> mauke :: exiting ghci, typing filter' even [1..10
14:23:06 <parcs> > let x = 0.999 in iterate (x **) x !! 1000
14:23:08 <lambdabot>   0.9990009985023294
14:23:27 <elliott> display :: (Applicative' t, Traversable' t, Applicative m) => t (Display e i m) -> t (Status e) -> m (t (Const i))
14:23:30 <elliott> display td ts = traverse' getCompose $ ap' (\d -> Compose . fmap Const . runDisplay d) td ts
14:23:33 <elliott> oops, wrong window
14:23:34 <DrChaos> mauke :: exiting ghci, running it again and typing "filter' even [1..10]". that executes in under a second. then I typed "filter' (\x -> x `mod` 2 == 0) [1..10]" and it took about 1.5 seconds to run
14:23:48 <mauke> 1.5 seconds?!
14:23:49 <elliott> nobody look at my awful code
14:23:52 <cmccann> elliott: that type signature is too readable, you need to make it worse
14:24:05 <DrChaos> oh wait, it's not any slower
14:24:09 <elliott> cmccann: perhaps you would change your mind if you saw the definitions of Applicative' and Traversable'
14:24:18 <DrChaos> @src even
14:24:19 <lambdabot> even n = n `rem` 2 == 0
14:24:27 <hpaste> elliott pasted “for cmccann” at http://hpaste.org/80322
14:24:49 <Nereid> why rem?
14:25:26 <Nereid> > let x = 0.999 in iterate (x **) x !! 1000 :: CReal
14:25:29 <lambdabot>   mueval-core: Time limit exceeded
14:25:33 <Nereid> heh.
14:25:43 <cmccann> elliott: looks pretty reasonable to me
14:25:49 <cmccann> I mean all the type signatures fit on a single line
14:25:52 <elliott> cmccann: it can be pretty annoying to use :(
14:25:52 <roadfish> elliott: Does the "'" on the Applicative' mean anything special? Or do you just have a second type called Applicative'?
14:25:54 <cmccann> it's like you're not even trying
14:26:00 <elliott> I'd like to get rid of the intermediate Compose there but I don't know how nicely
14:26:07 <elliott> cmccann: hey I got GHC to panic while working on this, twice
14:26:09 <elliott> though the same bug
14:26:09 <Nereid> roadfish: ' is just another character.
14:26:14 <parcs> > 3**(1/3)
14:26:16 <lambdabot>   1.4422495703074083
14:26:24 <elliott> roadfish: it means I defined Applicative' which is like Applicative lifted to stuff that takes a functor instead
14:26:41 <cmccann> elliott, to be fair if I was a compiler your code would make me panic too
14:27:20 <elliott> cmccann: this makes GHC 7.6.1 panic:
14:27:21 <elliott> foo :: f a -> t f
14:27:21 <elliott> foo = undefined
14:27:21 <elliott> ouch :: () -> ()
14:27:21 <elliott> ouch = foo ()
14:27:26 <elliott> doesn't even need any extensions!
14:27:34 <cmccann> wow.
14:27:39 <elliott> I thought the rank-2ness was to blame but no
14:27:44 <shachaf> It's fixed in HEAD
14:27:44 <elliott> 7.6 is just really bad at kind errors
14:28:28 <elliott> cmccann: the context of all this is vaguely related to formlets btw
14:29:00 <elliott> I think the worst type signature I've had is process :: (Applicative' t, Traversable' t, Applicative m) => t (Form2 e i) -> t (Display e i m) -> Result e m t
14:29:10 <cmccann> that is nicely cryptic.
14:29:29 <shachaf> elliott: You'll have to do better than that if you want to catch up with edwardk.
14:29:35 <elliott> it's called Form2 because I wrote it wrong the first time
14:29:53 <shachaf> Is that why it's called Haskell 2010?
14:30:33 <roadfish> Any idea why Ctrl-d doesn't work in emacs shell-mode for ghci? Work in other apps such as the python interpreter.
14:32:10 <roadfish> hmm, I am using 7.4.1. not sure if this is considered and "old" ghci
14:32:22 <roadfish> an old ghci
14:32:45 <hpc> ghci 7.4.1 accepts ^D on my machine
14:32:53 <hpc> but i am not using emacs
14:33:54 <roadfish> right, ^D works in ghci for me in other apps. eg when I run ghci in konsole, then ^D works. just not in emacs shell-mode. quite odd.
14:35:41 <roadfish> also, if I'm in shell-mode and I do ^D _then_ :q then I get an odd message. ghci says <interactive>:2:1: lexical error at character '\EOT'
14:36:00 <roadfish> but then I do a second ":q" and ghci quits properly
14:36:42 <roadfish> I guess this a clue about something getting accumulated in the ghci input buffer. But I'm not sure what.
14:36:43 <hpc> > ord '\eot'
14:36:44 <lambdabot>   <hint>:1:7:
14:36:44 <lambdabot>      lexical error in string/character literal at character 'e'
14:36:53 <hpc> > ord '\EOT'
14:36:55 <lambdabot>   4
14:36:59 <hpc> huh
14:37:21 <Nereid> emacs is passing a literal ^D instead of eof
14:38:05 <hpc> python must just be seeing the literal ^D character and going "well, time for me to vanish"
14:38:27 <roadfish> huh, so that means that konsole is passing eof and not 4
14:38:40 <hpc> that's what most terminals do
14:39:02 <roadfish> I guess the right fix is to have emacs send an eof. more of an #emacs issue I guess.
14:39:21 <nh2> hpc: I have code for the weird low-level warning: http://hpaste.org/80320
14:41:00 <Nereid> yes, that is what python does.
14:41:40 <hpc> nh2: aha! your problem is that it is catching the non-exhaustive patterns in core
14:41:50 <hpc> but the patterns are really non-exhaustive in your top-level program
14:41:57 <hpc> and it's being kind of dumb about it
14:42:02 <hpc> you should report that
14:42:15 <roadfish> I noticed the same thing with Haskell apps running in shell-mode. I couldn't use Ctrl-d to end stdin reading.
14:42:19 <hpc> and for your code, the fix is to just have
14:42:22 <hpc> case expName of
14:42:25 <hpc>   .......
14:42:30 <hpc>   _ -> undefined
14:42:46 <hpc> that makes the cases exhaustive and ghc quiets up
14:43:02 <parcs> > exp 1 ** (- exp 1)
14:43:04 <lambdabot>   6.598803584531256e-2
14:43:14 <elliott> nh2: the error is unrelated to the warning
14:43:17 <Nereid> exp 1 ** a = exp a
14:43:27 <elliott> hpc: does this really have anything to do with core?
14:43:34 <elliott> GHC has given warnings like this for unexhaustive patterns since forever
14:43:42 <hpc> elliott: the problem is it giving a context in core code
14:43:51 <hpc> rather than giving the context in lines of the actual source
14:44:03 <elliott> hm? it's not giving core context
14:44:06 <elliott> it's giving a list of unhandled patterns
14:44:10 <elliott> albeit in a somewhat obtuse form
14:44:10 <parcs> Nereid: oh right
14:44:17 <hpc> oh
14:44:19 <elliott> the indented snippet isn't code at all
14:44:25 <elliott> it's a list of expression schemas
14:44:37 <elliott> (schemata???)
14:44:40 <mauke> yes
14:45:03 <hpc> elliott: then that's one nasty-ass error message
14:45:14 <elliott> hpc: well, yes. but it's also useful
14:45:18 <elliott> the notElem stuff
14:45:21 <elliott> the boxing noise can go
14:46:52 <hpc> nh2: and the link errors were caused by a missing module in your cabal file, as you said earlier?
14:47:02 <hpc> if so, that hpaste is solved :D
14:50:46 <gdeest_> > pl  (\a c -> a + fromIntegral (fromEnum c))
14:50:47 <lambdabot>   Not in scope: `pl'
14:50:47 <lambdabot>  Perhaps you meant one of these:
14:50:47 <lambdabot>    `pi' (imported from ...
14:50:59 <gdeest_> > pf  (\a c -> a + fromIntegral (fromEnum c))
14:51:00 <lambdabot>   Not in scope: `pf'
14:51:01 <lambdabot>  Perhaps you meant one of these:
14:51:01 <lambdabot>    `f' (imported from D...
14:51:09 <nh2> hpc: I do not follow exactly - why does it not show me the missing case in high-level code as usual?
14:51:10 <nicoo> gdeest_: @pf
14:51:12 <gdeest_> Hum, what's the syntax for pointfree refactoring, by the way ?
14:51:15 <gdeest_> thanks :)
14:51:17 <nicoo> @pf (\a c -> a + fromIntegral (fromEnum c))
14:51:17 <lambdabot> Maybe you meant: bf pl
14:51:22 <nicoo> @pl (\a c -> a + fromIntegral (fromEnum c))
14:51:22 <lambdabot> (. (fromIntegral . fromEnum)) . (+)
14:51:27 <nicoo> Ha !
14:51:31 <gdeest_> quite ugly :P
14:51:45 <nicoo> gdeest_: I seem to know you from somewhere
14:51:48 * nicoo whistles
14:52:05 <gdeest_> From the chan next door, perhaps ?
14:52:15 <gdeest_> *next server
14:52:25 <nicoo> :P
14:54:25 <hpc> nh2: read what elliott said
14:56:33 <nh2> hpc: not sure if "obtuse form" means "the error message should be way better"
14:56:46 <hpc> nh2: it's exactly that
14:56:48 <nh2> also I do not know what expression schemas are
14:57:02 <nicoo> @unpl (. (fromIntegral . fromEnum)) . (+)
14:57:02 <lambdabot> (\ d j -> d + (fromIntegral (fromEnum j)))
14:58:05 <|||tux||> @unpl \d -> (d +) . fromIntegral . fromEnum
14:58:05 <lambdabot> \ d e -> d + (fromIntegral (fromEnum e))
15:02:29 <shapr> DrChaos: Who maintains hpasteit L
15:02:29 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
15:02:54 <shapr> Cale: What will you be using iCalendar to do?
15:02:57 <neutrino> hi
15:03:03 <mauke> @check (==)
15:03:05 <lambdabot>   Not in scope: `myquickcheck'
15:04:00 <DrChaos> ok guys, if I implemented all that in this paste here, what is my next step? http://vpaste.net/77xjW
15:04:45 <srhb> DrChaos: Off to do some IO? Really depends what you're aiming for.
15:05:38 <srhb> DrChaos: If you just want more type exercises, there's typeclassopedia
15:06:09 <Cale> shapr: I'm working at skedge.me and we're rewriting the entire backend of the application in Haskell.
15:07:19 <Cale> shapr: and Google Calendar import is something we'll have to do at some point.
15:07:28 <shapr> Cale: awesome!
15:07:33 <nicoo> @pl pl \f g (a,b) -> (f a, g b)
15:07:33 <lambdabot> (line 1, column 4):
15:07:33 <lambdabot> unexpected '\\'
15:07:33 <lambdabot> expecting variable, "(", operator or end of input
15:07:39 <nicoo> @pl \f g (a,b) -> (f a, g b)
15:07:39 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
15:07:49 <nicoo> @unpl flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
15:07:49 <lambdabot> (\ aa f -> (\ p w -> ((,)) (aa (fst p)) (f w)) >>= \ af -> snd >>= \ ae -> return (af ae))
15:07:57 <nicoo> @pl (\ aa f -> (\ p w -> ((,)) (aa (fst p)) (f w)) >>= \ af -> snd >>= \ ae -> return (af ae))
15:07:57 <lambdabot> flip flip ((snd >>=) . (return .)) . ((>>=) .) . flip . (((.) . (,)) .) . (. fst)
15:08:08 <srhb> nicoo: You can send lambdabot private messages.
15:08:10 <shapr> Cale: That's part of the goal for my code. Do you already have some sort of notification framework?
15:08:21 <shapr> @tell nicoo /query lambdabot
15:08:21 <lambdabot> Consider it noted.
15:08:25 <nicoo> srhb: True; sorry for the nois
15:08:25 <lambdabot> nicoo: You have 1 new message. '/msg lambdabot @messages' to read it.
15:08:28 <adek05> How can I tell cabal which ghc version to use (I've got ghc-7.4.1 (default aliased to ghc) and ghc-7.6.1 which I want to use). And I want packages to go to correct install-dirs: ghc-7.6.1/libs...
15:08:30 * shapr smiles
15:08:43 <mreh> :)
15:08:51 <shachaf> adek05: -w
15:11:39 <merk_> anyp preds = \x -> all ($ x) preds
15:11:59 <DrChaos> srhb :: I'm looking for exercises that will help me learn programming
15:12:02 <merk_> beem trying to write this without lambda but without success
15:12:19 <mreh> shouldn't that be "one" not "all"?
15:12:25 <mreh> :t one
15:12:26 <lambdabot>     Not in scope: `one'
15:12:27 <lambdabot>     Perhaps you meant one of these:
15:12:27 <lambdabot>       `once' (imported from Control.Monad.Logic),
15:12:36 <merk_> it should be any
15:12:38 <elliott> merk_: it'll be really ugly point-free
15:12:42 <mauke> @pl anyp preds = \x -> any ($ x) preds
15:12:42 <lambdabot> anyp = flip (any . flip id)
15:12:45 <mreh> yeah, any
15:12:49 <elliott> anyp preds x = all ($ x) preds -- write this instead though
15:13:36 <mreh> you can partially apply a function to get the same result
15:13:45 <mreh> a function that returns a function
15:14:14 <roadfish> :t any
15:14:15 <lambdabot> (a -> Bool) -> [a] -> Bool
15:14:27 <roadfish> :t all
15:14:29 <lambdabot> (a -> Bool) -> [a] -> Bool
15:16:45 <mreh> it's a shame quickcheck can't generate functions
15:18:59 <fmap> @ty (or .: sequence) `asTypeOf` \preds x -> all ($ x) preds
15:19:00 <lambdabot> [a -> Bool] -> a -> Bool
15:19:40 <mreh> has anyone any idea how alsa-pcm works? I just want to push PCM to a sound device :(
15:20:17 <mreh> quite what alsaStart and alsaStop do in addition to aslaWrite on a SoundSink do I don't know
15:22:25 <Jafet> writeFile "/dev/snd"
15:22:27 <Cale> shapr: I'm not quite sure about all the stuff we have so far -- most of the work has been done by Ryan up to this point, I've mostly just been working on the solver for solving various types of scheduling problems.
15:23:26 <mreh> Jafet, hmm
15:23:52 <mreh> I could use a Chan to buffer the sound too
15:23:59 <mreh> woop
15:28:26 <shapr> Cale: Sounds nifty.
15:29:07 <epta> Is there some shorthand for `\n → zip (zip [0,0..] [0,1..n]) [0,0..]' ?
15:30:09 <quchen> epta: Do you need the nested tuples? Otherwise zip3 would be suitable.
15:30:37 <quchen> > zip3 [0,0..] [0..5] [0,0..]
15:30:41 <lambdabot>   [(0,0,0),(0,1,0),(0,2,0),(0,3,0),(0,4,0),(0,5,0)]
15:30:52 <epta> quchen: oh, nice
15:30:54 <shapr> quchen: Did you ever figure out why genericLength isn't tail recursive?
15:31:22 <parcs> epta: usually people do 'repeat 0' instead of [0,0..]
15:31:26 <quchen> shapr: No, I thought the laziness argument brought up here was what I would get on SE as well
15:31:26 <shachaf> quchen: Are you asking why or do you know why and are asking quchen?
15:31:46 <parcs> epta: also [0,1..n] is identical to [0..n]
15:31:50 <parcs> (i think)
15:31:53 <quchen> shachaf: I was asking why genericLength uses the naive "1 + length rest" implementation here
15:32:13 <shachaf> Ah.
15:32:14 <quchen> And the argument was basically "so it can be lazy"
15:32:19 <shachaf> Yes, it's almost certainly because of laziness.
15:32:23 <shachaf> For example lazy nats.
15:32:40 <shachaf> It's not that great for other uses.
15:32:48 <quchen> Yes, that was the example given to me then, lazy nats.
15:33:00 <quchen> However, I couldn't come up with a practical application.
15:33:22 <quchen> It sure sounds nice on paper, but when would that actually be useful in a program? Is there anything that currently uses it?
15:33:32 <shachaf> Lazy nats can use it.
15:33:48 <nh2> I have this weird profile output: http://hpaste.org/80330
15:33:50 <shachaf> That way you can say if genericLength l < 5 ...
15:33:55 <quchen> The main reason for using genericLength for me was as a shortcut to fromIntegral . length so far. However, when looking through the docs, I realized that its implementation looked weird.
15:33:56 <shachaf> And it'll only check 5 elements no matter what.
15:34:00 <nh2> can somebody explain me what the syntax ".\" means in there?
15:34:07 <shachaf> Yes, you're better off not using it.
15:34:12 <nh2> does it mean "a lambda"?
15:34:28 <shapr> I've used genericLength recently.
15:34:28 <quchen> Aaaah, that makes sense! When everyone said "lazy nats" I thought about "lazy integers" all the time. For lazy nats it makes sense of course
15:35:08 <nh2> also, there is a function "computeH_.cs" although I do not have any symbol "cs" in that code. http://hpaste.org/80330
15:35:30 <shachaf> quchen: It makes some sense, but it's a terrible implementation for almost any other number type.
15:35:51 <shachaf> Fortuantely every list you're goint o deal with is shorter than 2^64, so you can just use fromIntegral . length :-)
15:36:01 <shachaf> (This may not be true on a 32-bit GHC.)
15:36:06 <quchen> shapr: My main problem was that length uses a nice worker wrapper tail recursion call, while genericLength just built up a large thunk.
15:36:25 <quchen> ^ That was meant to be shachaf
15:37:11 <shachaf> quchen: Agreed.
15:37:19 <quchen> I wonder how many programs it would break to have length return Integer.
15:38:00 <quchen> I mean the implementation of 'length' is very efficient (unboxed etc), but very often I want it to return an Integer.
15:38:11 <quchen> Or at least an Integral.
15:38:29 <merk_> if they started from scratch today would length return Integer, Integral or Num?
15:38:41 <otters> Integral
15:38:48 <srhb> quchen: Isn't Int Integral?
15:38:53 <otters> Num includes fractionals and you can't have a fractional length
15:38:55 <cmccann> if there was any sanity in the world length would return a natural number type
15:39:04 <DrChaos> OK, how do you do I/O in Haskell?
15:39:13 <otters> put it in main
15:39:21 <DrChaos> I want to write a function that generates a random number and use it in a number guessing game
15:39:29 <srhb> main = putStrLn "foo" -- tadaa
15:39:52 <quchen> srhb: What I mean is that length right now is [a] -> Int, and what I would prefer would be (Integral b) => [a] -> b.
15:39:53 <srhb> DrChaos: But if you're just getting started, maybe you'll want to read the IO chapter in one of the popular books
15:40:00 <srhb> quchen: Ah.
15:40:36 <cmccann> quchen, you'd want Num there, not Integral
15:41:16 <elliott> Integral there is pointless
15:41:18 <quchen> cmccann: I want Integral. If I wanted Num, there would already be genericLength.
15:41:27 <cmccann> then you want Integer
15:41:37 <cmccann> using Integral accomplishes nothing
15:41:42 <elliott> @src Integral
15:41:42 <lambdabot> class  (Real a, Enum a) => Integral a  where
15:41:42 <lambdabot>     quot, rem, div, mod :: a -> a -> a
15:41:42 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
15:41:42 <lambdabot>     toInteger           :: a -> Integer
15:41:51 <elliott> nothing there is useful for length
15:42:15 <cmccann> though actually that implies Num anyway, doesn't it?
15:42:23 <cmccann> so it would just be needlessly restricted
15:42:25 <quchen> Well, maybe I want Enum then.
15:42:28 <cmccann> instead of completely useless
15:42:29 <merk_> if you would want length to return Num, does that mean you would return Num everywhere?
15:43:01 <cmccann> anything that returns an integral value could use Num instead
15:43:06 <quchen> I'm just saying that the return type of length would often be more practical if it was polymorphic. Any by more practical I mean would save me sprinkling the code with "fromIntegral $".
15:43:12 <cmccann> anything that takes an integral value as an argument could use Integral instead
15:43:29 <srhb> Is length really needed that often? Seems like an evil function many times.
15:43:49 <quchen> It's certainly one of the most common evil functions ;-)
15:43:52 <elliott> quchen: well, genreicLength is polymorphic
15:43:58 <elliott> you just want a differently-implemented genericLength
15:44:01 <cmccann> quchen, yes, and Num is the most polymorphic useful thing to have there
15:44:14 <cmccann> given the standard type classes at least
15:44:31 <Jafet> genericLength :: Enum a => [b] -> a
15:44:33 <monochrom> it's strange. you want polymorphism. then when polymorphism is offered to you, you want less polymorphism.
15:44:36 <Jafet> (obviously)
15:45:15 <quchen> Yeah, but genericLength builds up a large thunk of "1+". So that's basically where my question came from. (I'm just answering what led up to my question here.)
15:45:56 <monochrom> alright, write a second genericLength that is based on foldl or perhaps foldl'. but it is still going to be Num
15:46:06 <Jafet> That is the correct implementation of genericLength
15:46:12 <quchen> ... then someone told me about lazy nats and I began to understand why genericLength isn't tail recursive.
15:46:18 <Jafet> Perhaps it should be called lazyLength
15:46:57 <cmccann> :t fromIntegral . length
15:46:58 <lambdabot> Num b => [a] -> b
15:47:05 <cmccann> that's basically what you want, right?
15:47:08 <monochrom> also, "builds up a large thunk" is not true for all Num instances
15:47:40 <quchen> For Int(eger) it is, isn't it?
15:47:43 <Jafet> monochrom: genericLength is required to do that
15:47:44 <monochrom> yes
15:48:27 <monochrom> but if you're so obsessed with polymorphism, you are not going to be obsessed with Integer
15:48:33 <Jafet> If you mean large unproductive thunks, then yes, there is (pretty much one?) Num instance
15:48:46 <monochrom> ok, you can be obsessed with both, and be a self-contradictory person.
15:49:03 <quchen> Well, I've used genericLength extensively in some (toy) programs to save a few characters over "fromIntegral . length", and upon reading the implementation I thought that the worker-wrapped version would most certainly be better in some way.
15:49:16 <monochrom> I mean what was I thinking? you are not a computer, you are entitled to cognitive dissonance
15:50:08 * Jafet presses the large red button on monochrom
15:51:02 <quchen> He's still annoyed because I didn't bow to him in a discussion before. Smile and wave, no need to be offended.
15:51:07 <cmccann> quchen, just do this: "import Prelude hiding (length); import qualified Prelude as P; length = fromIntegral . P.length"
15:51:09 <cmccann> problem solved
15:51:12 <monochrom> wait, buttons on monochrom are coloured? :)
15:51:24 <cmccann> monochrom, it's a monochromatic red I'm sure
15:51:50 <quchen> cmccann: That solves the problem for all practical purposes, yes. But this is Haskell after all! ;-)
15:52:06 <Jafet> All the buttons are illuminated by lasers, to ensure coherency.
15:52:08 <cmccann> quchen, I'm not sure what the problem even is at this point
15:52:54 <quchen> cmccann: I'm pretty sure we solved it.
15:53:02 <quchen> Also "yea same here"
15:54:39 <hrumph> how do i open a file like inh <- openFile "input.txt" ReadMode except in stead of "input.txt" i want to use stdio
15:54:58 <Jafet> let inh = stdin
15:55:17 <hrumph> i think i can just call getContents for now
15:55:31 <hrumph> that was what i was after so i'll do that then i'll think about actual file input
15:55:43 <Jafet> hGetContents inh
15:55:55 <hrumph> yep but if using stdin i can just call getContents
15:56:09 <hrumph> i didn't know about getContents until one second after asking about stdio
15:56:29 <hrumph> i'd only seen hGetContents
15:56:35 <monochrom> you can use "hGetLine stdin" etc
15:56:56 <hrumph> it sholdn't be necessary to use getLine or hGetLine because of lazy evaluation
15:57:20 <hrumph> if everything is done right i should be able to use getContents or hGetContents
15:57:35 <kristof> I'm not really sure how to install darcs.
15:57:40 <monochrom> ok, but I'm saying that "handle" does not mean "cannot be stdio"
15:57:48 <kristof> cabal install darcs-2.8.2 is giving my conflicts.
15:57:48 <hrumph> ok got it
15:58:09 * Jafet pushes the large red button labelled "unsafeAntiInteleaveIOBrigade"
15:58:44 <Jafet> unsafeAntiInteleaveIOBrigrade
15:58:58 <monochrom> Jafet: more unsafeInterleaveIO for you! http://hpaste.org/77374
15:59:25 <cmccann> unsafeInterleaveIO is perfectly sensible in many use cases, and fine if you understand what those use cases are
15:59:36 <cmccann> I still don't like it being the default >:[
16:01:03 <monochrom> kristof: "cabal install --dry-run darcs" does not give me any conflict. both 2.8.2 and 2.8.3. but I'm starting from a pretty clean state, Haskell Platform
16:01:32 <kristof> monochrom: http://sprunge.us/BeAE
16:01:44 <hrumph> when i use stuff like getContents will it autoconvert the end of lines to '\n" in windows
16:02:02 <hrumph> so i don't have to worry about how end of lines are done differently in different environments?
16:02:58 <Jafet> It will also autoconvert standard input to a String
16:04:00 <DrChaos> does Haskell have anything like Scanner scan = new Scanner(System.in); int x = scan.nextInt();?
16:04:34 <Jafet> ghc -XCaffeine
16:04:38 <DrChaos> what that does is set up a reader that looks for tokens in the standard input stream, and then assigns x to the next integer token in the input stream
16:04:52 <DrChaos> Jafet :: mmm caffiene
16:07:29 <monochrom> reads is like scanner. read my http://www.vex.net/~trebla/haskell/reads.xhtml
16:10:53 <Tommmy> At PTC Bank, you get paid to click on ads and visit websites. The process is easy! You simply click a link and view a website for a few seconds to earn money. You don't need any skills. All you need to do is visit the sites we provide you with. You can earn even more by referring friends. Payment requests can be made every 15 days and are processed through Paypal, Payza. The minimum payout is
16:10:53 <Tommmy> $100. Registration: Earn money in seconds !!! http://www.ptcbank.net/?r=puddd
16:11:06 <pharaun> no
16:11:12 <Zamarok> Is there a built-in way to do this? (\(x,y) -> (y,x))
16:11:20 <min|dvir|us> @src swap
16:11:20 <lambdabot> Source not found.
16:12:09 <shachaf> Zamarok: Data.Tuple has swap
16:12:31 <shapr> @hoogle (a,b) -> (b,a)
16:12:31 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
16:12:31 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
16:12:31 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
16:12:48 <Zamarok> Why thank you.
16:15:23 <kristof> Damn it, there's no darcs package in [extra]? Sigh.
16:16:10 <kristof> And the AUR package is out of date
16:16:14 <kristof> 6 months ago
16:16:15 <kristof> sigh
16:16:27 <gienah> kristof: you could update it
16:16:41 <kristof> gienah: Eh. I'm going to use cabal instead.
16:16:46 <kristof> But I keep getting this error: http://sprunge.us/BeAE
16:16:57 <hrumph> what's the operator for neq?
16:17:06 <c_wraith> /-
16:17:08 <c_wraith> err, /=
16:17:14 <kristof>  /=
16:17:33 <c_wraith> kristof: looks like you're combining globally and locally installed packages.  That is *always* a recipe for disaster
16:17:35 <Jafet> not .: (==)
16:17:50 <kristof> c_wraith: ...what do I do? :C
16:18:06 <kristof> I've been using Haskell for a couple of months now but I've never bothered to use cabal or hackage
16:18:08 <c_wraith> my preferred approach is to install everything, including GHC, locally.
16:18:22 <Jafet> rm -rf, it's the only way to be sure.
16:18:27 <simon> :t foldM
16:18:28 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:18:47 <hpc> kristof: a good thing to do is install cabal-dev upfront
16:18:53 <gienah> kristof: darcs requires patching for ghc 7.6.1, you could look here for hints on how to update the AUR pkg: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-vcs/darcs/darcs-2.8.3-r1.ebuild
16:19:37 <quchen> Jafet: Where does .: come from? Is it in some standard packages? lambdabot won't answer me :-(
16:19:54 <Jafet> :t (.:)
16:19:55 <parcs> .: is defined in the 'functors' package
16:19:55 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
16:20:22 <Jafet> Actually
16:20:31 <Jafet> :t not ?.: (==)
16:20:32 <lambdabot>     Not in scope: `?.:'
16:20:32 <lambdabot>     Perhaps you meant `.:' (line 111)
16:20:37 <Jafet> Poo
16:20:43 <Jafet> :t ?f not (==)
16:20:44 <lambdabot> (?f::(Bool -> Bool) -> (a -> a -> Bool) -> t, Eq a) => t
16:21:03 <Jafet> Nevermind, that's too unified
16:21:24 <quchen> parcs: Thanks
16:21:57 <Jafet> (.:) = (.) (.) (.)
16:23:00 <quchen> Ah, the dotdotdot from ekmett's talk :-)
16:23:29 <Jafet> @@ @pl @djinn (c -> d) -> (a -> b -> c) -> a -> b -> d
16:23:29 <lambdabot>  f = (.) . (.)
16:23:44 <heatsink> (?)
16:27:18 <lightquake> how painful is getting hsakell setup on windows?
16:27:33 <lightquake> *haskell
16:28:17 <Nereid> not very
16:28:24 <Nereid> step 1: install haskell platform.
16:28:27 <Nereid> step 2: you're done.
16:28:58 <Nereid> :t not `?f` (==)
16:28:59 <lambdabot> parse error on input `?f'
16:29:01 <Nereid> aw.
16:29:03 <|||tux||> @pl \x y -> head $ drop x $ reverse y
16:29:03 <lambdabot> (head .) . (. reverse) . drop
16:29:56 <Nereid> @pl \x -> head . drop x . reverse
16:29:56 <lambdabot> (head .) . (. reverse) . drop
16:31:10 <Nereid> :t let dropFromEnd n xs = zipWith (const id) (drop n xs) xs in \n -> last . dropFromEnd n
16:31:11 <lambdabot> Int -> [b] -> b
16:31:30 <lightquake> @type const id
16:31:31 <lambdabot> b -> a -> a
16:31:39 <lightquake> ah-ha
16:31:49 <|||tux||> nice
16:32:26 <lightquake> i wonder if that's faster or slower than the 'keep a pointer to the first element and the nth element, then advance them in parallel' approach
16:32:34 <Nereid> it's equivalent
16:33:11 <lightquake> true
16:33:43 <Jafet> zipWith const xs (drop n xs)
16:34:15 <Nereid> fine.
16:34:43 <|||tux||> zipWith (uncurry snd) (drop ns xs) xs
16:34:45 <Nereid> zipWith const `ap` drop n
16:35:18 <Nereid> :t ap (zipWith Const) . drop
16:35:20 <lambdabot>     Couldn't match expected type `b0 -> c0'
16:35:20 <lambdabot>                 with actual type `Const a0 b1'
16:35:20 <lambdabot>     Expected type: a0 -> b0 -> c0
16:35:21 <Nereid> :t ap (zipWith const) . drop
16:35:23 <lambdabot> Int -> [b] -> [b]
16:45:17 <hrumph> i'm using getContents and it reads one line then it quits
16:45:55 <hrumph> shoulddn't it wait until i hit CTRL^D?
16:46:10 <shachaf> getContents is lazy.
16:48:56 <Sintendo> so I wrote a bunch of functions that use putStr to display something
16:49:10 <Sintendo> now it turns out i need all that output as a string
16:49:33 <quchen> Jafet: Have this delayed "thank you" because of that comment above I finally understood what (and how) (.).(.) works. (And now I don't understand anymore how I didn't understand it.)
16:49:33 <byorgey> Sintendo: well, now you know not to do that next time.
16:49:59 <Sintendo> so there's no convenient way to generate the string while keeping the do notation?
16:50:03 <byorgey> Sintendo: never have a function that prints something on the screen when you could instead have a function that returns a String.
16:50:51 <mauke> Sintendo: Writer
16:50:53 <byorgey> Sintendo: I mean, I guess you could change it to use the Writer String  monad, and change 'putStr' to 'tell'
16:51:06 <byorgey> not sure whether that would be worth it.
16:51:06 <mauke> and maybe a better monoid
16:51:17 <byorgey> true, if efficiency is a concern.
16:51:40 <Sintendo> yeah, that's why I was thinking of
16:51:41 <hrumph> why does laziness mean assuming i'm done even when i'm not?
16:52:13 <shachaf> hrumph: Unfortunately GHC has a special case where it checks if your username is "hrumph" and behaves erratically if it is.
16:52:17 <DrChaos> what is haskell's equivalent to readNextTokenFromStdinAsInt()?
16:52:28 <hrumph> shachaf: are you implying i have a bug?
16:52:32 <mauke> DrChaos: "no"
16:52:46 <DrChaos> or does anybody know a little Java?
16:52:49 <shachaf> I'm implying that no one has any idea what's going on based on the information you're giving.
16:53:00 <shachaf> It's unlikely that the behavior you're describing is the intended behavior of getContents.
16:53:03 <DrChaos> I want to read the next token that could be a integer into an integer variable
16:53:21 <hrumph> shachaf: ok i am using hGetContents now on stdin
16:53:21 <shachaf> It's unlikely that getContents has such an obvious bug, since people use it quite often.
16:53:27 <mauke> DrChaos: define "token"
16:53:32 <hrumph> the idea is that i will feed in multiple lines
16:53:35 <shachaf> hrumph: This is not how you ask a question.
16:53:45 <mauke> @src getContents
16:53:45 <lambdabot> getContents = hGetContents stdin
16:53:47 <hrumph> hitting enter each time. however i enter in one line then its done
16:53:59 <shachaf> hrumph: When you encounter behavior you don't expect, please provide: (a) what you did (b) what you expected (c) what happened
16:54:07 <shachaf> In this case (a) is your code.
16:54:09 <DrChaos> mauke :: erm...token would be a word delimited by space, tab, or newline
16:54:10 <elliott> (d) what the weather is
16:54:16 <shachaf> That's good too.
16:54:28 <mauke> DrChaos: I don't think that's a useful thing to do
16:54:38 <hrumph> i expect that it will keep processing until i hit CNTRL^D or something that signified end of input
16:54:49 <mauke> hrumph: what is "it"?
16:54:55 <DrChaos> mauke :: but I want a word that happens to be a integral number to be read into an integer variable
16:55:00 <mauke> DrChaos: no
16:55:06 <hrumph> ok i will post the code. its a learning excercise i'm doing for myself
16:55:51 <hpaste> Hrumph pasted “ok it only reads one line then that's it” at http://hpaste.org/80332
16:55:53 <DrChaos> mauke :: so there is nothing like Scanner scan = new Scanner(System.in); x = scan.nextInt()?
16:56:04 <DrChaos> I mean, int x = scan.nextInt();
16:56:15 <mauke> DrChaos: again, I don't see how that is a useful thing to do
16:56:18 <monochrom> we need a periodically updated top-10 billboard for: how many minutes between the beginning of a question and the eventual showing of actual code
16:56:54 <DrChaos> mauke :: if not, then how would I read in a list of numbers from the user each into their own variables?
16:56:59 <shachaf> hrumph: There's a lot of stylistic advice at the bottom of that page, by the way. Most likely you should follow most of it. :-)
16:57:04 <mauke> hrumph: you're only processing the first line
16:57:15 <mauke> DrChaos: in what format?
16:57:48 <DrChaos> mauke :: 1\n2\n4\n\
16:58:11 <hrumph> mauke how come though?
16:58:14 <DrChaos> just numbers delimited by newlines
16:58:30 <mauke> DrChaos: something like ns <- map read . lines <$> getContents
16:58:55 <mauke> hrumph: mainControl s = mainControlProcessLine line
16:58:56 <srhb> DrChaos: Forget about the fancy parsing for a bit. try this main function out for size: main = readLn >>= print . (+2) >> main -- try if you understand what is going on
16:59:05 <monochrom> line = takeWhile (\x -> (x /= '\n')) s
16:59:55 <monochrom> s is from hGetContents stdin. and you just wrote code to say: use only what comes before the first \n
17:00:30 <hrumph> ouch i see it
17:00:36 <hrumph> that was silly
17:01:08 <hrumph> i'm recursing in the wrong spot
17:01:29 <hrumph> my bad i've been learning haskell for hours and hours and hours now
17:01:29 <monochrom> see how productive we are with the scientific method
17:01:33 <shachaf> hrumph: Do you see why the way you asked the question initially wasn't productive?
17:01:37 <shachaf> This is why we ask for code. :-)
17:02:21 <monochrom> see why we need a top-10 billboard for: how many minutes between the beginning of a question and the eventual showing of actual code
17:02:29 <hrumph> yes i see thanks a lot btw
17:03:25 <DrChaos> srhb :: the first thing I will try is to see what that main function does if I try to pass in the letter A as input
17:03:34 <srhb> DrChaos: Crash.
17:03:57 <srhb> DrChaos: That's not the point though. Try entering only numbers. Don't overcomplicate things yet, you're having trouble grasping how to do the REPL-like functionality.
17:04:08 <mauke> REPL?
17:04:17 <mauke> I thought this was to be non-interactive
17:04:42 <DrChaos> mauke :: it will be interactive. it's a guess the number game
17:04:52 <mauke> uh
17:05:01 <mauke> so why were you asking for tokens then?!
17:05:12 <DrChaos> srhb :: huh? where's the loop?
17:05:20 <srhb> DrChaos: Just try the code
17:05:22 <mauke> that's pretty much the opposite of what you actually need
17:06:14 <DrChaos> I tried it, it keeps on prompting me for an input number and adding 2 to that and printing the result and repeating ad infinium
17:06:43 <srhb> DrChaos: Right. So that's what you want to do. The trick is to have a function that does your "repeating behaviour" and you just keep recursively calling that (until you get the desired result)
17:07:09 <DrChaos> srhb :: is there a random number generator for haskell?
17:07:11 <srhb> DrChaos: Next make it into a guessing game, but with a set number.
17:07:20 <srhb> DrChaos: Don't try to do it all at once.
17:07:29 <srhb> DrChaos: (But yes, System.Random)
17:07:33 <DrChaos> srhb :: ok, I'll use a static number, say 5
17:09:06 <mauke> :t randomRIO
17:09:07 <lambdabot> Random a => (a, a) -> IO a
17:09:59 <DrChaos> srhb :: so erm...what does >> main mean? send input to the main function?
17:10:15 <DrChaos> and how about >>=?
17:10:38 <DrChaos> it's all so mysterious, it's as if >>= is acting as some invisible variable x
17:11:36 <mauke> @src (>>)
17:11:36 <lambdabot> m >> k      = m >>= \_ -> k
17:11:37 <srhb> DrChaos: You should read about those two operators, or about how do syntax work, which is essentially the same. It would help to read a chapter on IO somewhere.
17:11:45 <mauke> main is not a function, btw
17:11:51 <srhb> What?
17:12:07 <monochrom> "IO ()" does not look like a function type, does it?
17:12:24 <srhb> Why not?
17:12:26 <monochrom> (unless you believe in that FSM->(a,FSM) story)
17:12:51 <mauke> I don't!
17:12:52 <monochrom> a function type has ->
17:13:05 <srhb> Ah, in that sense.
17:13:06 <srhb> Sure.
17:13:09 <srhb> Doesn't matter though.
17:13:26 <lu7dfv> Nite all, greetings from Argentina
17:13:33 <merijn> dm;hm (doesn't matter; have monads)
17:13:46 <srhb> merijn: ^^
17:13:54 <cmccann> terminological precision always matters, especially when talking to people learning the material
17:14:12 <srhb> main is such an edge case. I disagree, it's muddying the waters.
17:14:14 <cmccann> the fewer opportunities for confusion the better
17:14:14 <mauke> maybe I'll start calling strings functions
17:14:20 <srhb> Bleh. Fine. :P
17:14:21 <mauke> 'the "hello world" function'
17:14:30 <monochrom> to me it is not being pedantic. I hate "function" being hijacked for procedures. so even in C, with "int f(double)", I don't want to say "function" either.
17:14:54 <srhb> Henceforth, main shall be named a Gobbledook.
17:15:53 <HugoDaniel> hi
17:16:01 <monochrom> then again who am I to argue against Wirth
17:16:32 <srhb> No, I agree, I just think sometimes deferring it ever so slightly until some other concepts have been understood is more pedagogical.
17:16:52 <DrChaos> srhb :: so err...I want to recursively call the mkGuess function with my number I got from the user as input
17:16:53 <srhb> On the other hand, this is the right point to actually start understanding what is really going on.
17:17:40 <srhb> DrChaos: If the user got the wrong number, recurse, otherwise end
17:17:47 <hrumph> i'm still don't know how to close the input it is really CTRL^D?
17:18:02 <hrumph> it seems to just treat it as another char when i enter it
17:18:15 <monochrom> windows? linux? bsd?
17:18:21 <hrumph> linux
17:18:26 <hrumph> in ghci
17:18:32 <hrumph> wait i need o try it in ghv
17:18:35 <hrumph> ghc
17:18:47 <hrumph> works in ghc!
17:18:58 <monochrom> after ctrl-d, press enter. but no guarantee. and ghci is different (clearly)
17:19:14 <hrumph> its fine in ghc
17:19:35 <hrumph> ok i got it to go
17:19:43 <monochrom> ghci is a REPL and therefore must do intrusive things to stdin etc
17:19:56 <monochrom> this is what you get for REPL
17:20:12 <hrumph> it doesn't matter its only one thing i can't test
17:20:31 <hrumph> when using ghci i can always hit CTRL^C and achieve almost the same effect.
17:20:40 <monochrom> ghci does other funny things. they will bite you a bit at a time. have fun.
17:21:11 <srhb> hrumph: Might want to use runhaskell for testing things like that.
17:21:34 <hrumph> what is runhaskell?
17:21:43 <monochrom> an alias to runghc
17:21:48 <DrChaos> srhb :: is "if x = mkGuess number" a valid boolean expressioN?
17:21:52 <hrumph> ok
17:22:15 <monochrom> "runghc f.hs" uses the interpreter but is not REPL
17:22:30 <mauke> DrChaos: it's not an expression
17:23:09 <monochrom> "x == mkGuess number" may be a boolean expression, pending further type-checking
17:23:19 <DrChaos> @let mkGuess 1 = True; mkGuess 0 = False in if x = mkGuess 1 then print "Hello" else print "Fail"
17:23:19 <lambdabot>   Parse error: in
17:23:27 <hrumph> what do you think of my innovation of the maybeGuard function?
17:23:38 <DrChaos> monochrom :: oh
17:24:20 <hrumph> its like the guard function for booleans but it works in a an ErrorT and it uses Maybe's instead of booleans
17:26:22 <hpaste> Hrumph pasted “maybeGuard” at http://hpaste.org/80334
17:29:07 <DrChaos> is there an IO function that all it does is output a newline to the screen>
17:29:09 <Moggle> Out of curiosity, are there any IDEs for Haskell?
17:29:11 <DrChaos> ?
17:29:17 <srhb> DrChaos: putStrLn ""
17:29:23 <hrumph> how can i see all of those warnings that pastebin produced without actually pasting if i just want to see them myself?
17:29:29 <Moggle> I can't see myself using one, but stuff like holding the mouse over a function name and seeing its type declaration could be neat.
17:29:44 <srhb> DrChaos: (Although that is not a function!)
17:30:13 <elliott> DrChaos: putChar '\n'
17:30:57 <DrChaos> ok I want you guys to look at this
17:31:08 <DrChaos> numberGuess.hs:8:38:
17:31:09 <DrChaos>     Couldn't match expected type `IO ()' with actual type `Bool'
17:31:24 <DrChaos> http://vpaste.net/tnsGi
17:31:36 <srhb> DrChaos: You're trying to do boolean comparison on an IO Action.
17:31:46 <srhb> DrChaos: Boolean comparison works only between two Bools
17:31:57 <Jafet> Moggle: emacs
17:32:04 <Jafet> (with flymake)
17:32:13 <elliott> Moggle: there is leksah
17:32:24 <srhb> DrChaos: Well, ok, not quite.
17:32:32 <srhb> DrChaos: replace True with return ()
17:32:37 <DrChaos> srhb :: ah
17:32:55 <fmap> hrumph: cabal install hlint
17:33:13 <srhb> DrChaos: also mkGuess is identical to (==5)
17:33:48 <DrChaos> srhb :: ah, i see
17:33:55 <srhb> DrChaos: You should also start using hpaste.org instead, it will give you hlint suggestions
17:34:09 <DrChaos> but this is strange, I'm not getting the Number: prompt before the numbers
17:34:28 <DrChaos> Hello, this is my guessing game. Enter a number.
17:34:29 <DrChaos> 1
17:34:48 <srhb> DrChaos: Running in ghci? Weird things happen then.
17:35:05 <DrChaos> the Number: prompt appears when the program exits, and duplicated n times depending on how many wrong guesses you made
17:35:48 <DrChaos> srhb :: I'm running it in compiled form
17:35:58 <srhb> DrChaos: Oh, must be buffering then.
17:36:08 <DrChaos> srhb :: how do I set it to non buffered?
17:36:30 <fragamus> hey I have a data constructor and i want to add a field that is derived from the other fields because the computation to derive it comp intensive and I want to avoid doing that more than once.  Can one make a constructor that does that?
17:36:30 <DrChaos> stderr is non buffered...I wonder how you set stdout to non buffered
17:36:31 <srhb> DrChaos: for now just print Number: on its own line to keep things simple, replace putStr with putStrLn
17:36:47 <srhb> @hoogle hSetBuffering
17:36:47 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
17:36:47 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
17:37:01 <srhb> hSetBuffering stdin NoBuffering
17:37:04 <srhb> err, out
17:37:05 <srhb> not in.
17:39:53 <DrChaos> srhb :: there's a problem with adding a message to the user on a won game, see: http://vpaste.net/uCeLj
17:40:26 <srhb> DrChaos: hpaste.org and add the error message
17:40:26 <DrChaos> it's treating putStrLn "..., hooray!" and return () as one statement
17:40:31 <DrChaos> ok
17:40:51 <srhb> DrChaos: In this case, you can sequence them with >> or add a do block to the then-part
17:42:22 <hpaste> DrChaos pasted “numberGuess.hs + error” at http://hpaste.org/80336
17:43:25 <srhb> DrChaos: Notice the return type of putStrLn
17:43:37 <DrChaos> srhb :: it's return type is IO()
17:43:45 <srhb> DrChaos: And the return type of return ()
17:43:51 <DrChaos> :t return ()
17:43:52 <lambdabot> Monad m => m ()
17:44:35 <srhb> DrChaos: in the IO monad, so IO () -- they are identical. That means the return () is redundant. But you COULD sequence them by putStrLn "..." >> return () or with a do block
17:44:35 <DrChaos> oh, the expressions inside of an if statement have to have the same return types
17:44:45 <srhb> DrChaos: Yes, and they are.
17:45:17 <srhb> DrChaos: Either remove return () or sequence the two actions correctly
17:45:42 <DrChaos> srhb :: I did so
17:45:45 <DrChaos> works perfectly
17:45:49 <srhb> DrChaos: Great. >(
17:45:51 <srhb> :)*
17:49:18 <DrChaos> srhb :: I'm trying to show my friend who is a Java programmer my program
17:49:51 <srhb> DrChaos: :)
17:51:17 <DrChaos> I replaced that if mkGuess number statement with if number == 5
17:51:24 <DrChaos> and I also removed the mkGuess function
17:51:34 <srhb> DrChaos: Right, it was quite superfluous.
17:51:57 <srhb> DrChaos: In the end your loop function will probably take the correct number as an argument (passed from the main IO action)
17:57:44 <bgamari> shapr, I've been chipping away at the ARM situation
17:58:03 <bgamari> Sadly ghc seems to crash during building vector
17:58:19 <shapr> :-(
17:58:46 <bgamari> assert in the garbage collector fails
17:58:58 <shachaf> @arrrm
17:58:58 <lambdabot> I want me grog!
17:59:01 <shapr> I can't get iCalendar to build in 256MB at the moment. I think adding swap will probably fix that.
17:59:22 <shachaf> @brain Are you thinking what I'm thinking?
17:59:22 <lambdabot> I think so, Brain, but isn't that why they invented tube socks?
17:59:51 <shapr> bgamari: So that means ghc 7.6.1 still needs some bug fixes on ARM?
18:00:01 <bgamari> Seems likely
18:00:21 <bgamari> I'm working on chipping away at testsuite failures at the moment
18:02:01 <shapr> I discovered that the ghcarm.wordpress guy is actually Karel Gardas
18:03:48 <Moggle> @src foldl'
18:03:48 <lambdabot> foldl' f a []     = a
18:03:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:04:09 <nyc> shapr: Who's Karel Gardas?
18:05:03 <shapr> nyc: no idea
18:07:21 <Moggle> Question: for doing an infinite loop sort of thing in Haskell, you'd do something like main = putStrLn "eee" >> main
18:07:37 <Moggle> Does GHC optimize that to not actually keep going deeper into the stack?
18:07:52 <Moggle> ie. will it eventually hit a maximum memory limit somewhere?
18:07:52 <shachaf> That will use a constant amount of stack space.
18:07:59 <shachaf> Whether that's an optimization or not is a different matter.
18:08:32 <Moggle> Is there any way to take a look at the C code GHC makes?
18:08:37 <Moggle> C-- or whatever it is, I guess.
18:08:38 <shachaf> GHC does not make C code.
18:08:44 <shachaf> Try ghc -ddump-cmm
18:08:50 <shachaf> Alternatively, cabal install ghc-core
18:08:51 <Moggle> Thanks!
18:09:10 <shachaf> (That does not currently dump the cmm without being asked; but it will "when I get to it".)
18:10:26 <Moggle> I wonder if it abuses gotos or not!
18:10:52 <shachaf> It probably calls them "jumps".
18:11:01 <shachaf> However, the sort of code GHC generates is very different from what you think.
18:11:12 <hpc> the ghc core is a much more interesting language than anything c-- could do
18:11:29 <hpc> plus it has types!
18:12:17 <shachaf> Fancier types than Haskell, in fact.
18:12:21 <Moggle> Oh sweet.
18:12:28 <Moggle> What fascinating generated code.
18:13:01 <hpc> there's a nice article somewhere about the reasoning behind a typed core language
18:13:19 <Moggle> Aha!
18:13:21 <shachaf> For understanding it, you may be better off looking at -ddump-simpl and -ddump-stg.
18:13:23 <Moggle> It does abuse the heck out of gotos
18:13:24 <Moggle> :D
18:13:41 <shachaf> It is not "abuse" for a compiler that compiles Haskell to x86 to use gotos.
18:13:48 <shachaf> It is the only way.
18:13:50 <Moggle> My apologies :P
18:13:54 <Moggle> I concur, it _is_ the best way.
18:14:11 <Moggle> Unlike the vast majority of programmers (or so it seems from my few courses) I do not hate gotos
18:14:13 <shachaf> Also the only way, I think.
18:14:29 <shachaf> Moggle: Using gotos in generating code and hating gotos are not really related.
18:14:30 <Moggle> and find them to be wonderful things, to be used in moderation (and particularly in loops-within-loops)
18:15:01 <Moggle> The difference seems to be one of fine-grained semantics to me, shachaf!
18:15:18 <Moggle> All code becomes a series of jump instructions in the end.
18:15:47 <shachaf> Yes. Therefore people who "hate gotos" clearly don't mind generated code that contains gotos.
18:15:51 <shachaf> Unless they hate all code.
18:16:12 <cmccann> most code is easy to hate.
18:16:16 <shachaf> At any rate, if you want to learn about how GHC generates code, you can read
18:16:17 <shachaf> @where stg
18:16:17 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
18:16:19 <Moggle> I would assume they would and purposefully live in a self-delusional world, shachaf.
18:16:19 <heatsink> But there are different explanations for why various control flow transfers produce meaningful behavior.
18:16:24 <Moggle> Oooh, thanks.
18:16:40 <Moggle> Haskell is made of fascinating and <3
18:16:59 <shachaf> @where fast-curry
18:16:59 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/index.htm
18:17:10 <shachaf> @where ptr-tag
18:17:10 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
18:19:26 <srhb> Wow, core looks fancy.
18:21:25 <shachaf> srhb: Advice: Add -dsuppress-all to your GHC command line.
18:22:05 <srhb> shachaf: Doesn't exist as an option, it seems.
18:22:32 <srhb> shachaf: Oh, you're talking about ghc, not ghc-core
18:22:45 <shachaf> srhb: For ghc-core, add it after the file name, rather than before.
18:23:03 <srhb> Thanks :)
18:23:06 * shachaf should really clean up ghc-core sometime.
18:37:46 <Moggle> @src seq
18:37:46 <lambdabot> Source not found. Where did you learn to type?
18:37:57 <Moggle> :(
18:37:59 <Moggle> jerk bot
18:38:02 <Moggle> @src foldl'
18:38:02 <lambdabot> foldl' f a []     = a
18:38:02 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:38:07 <Moggle> >:OOO
18:38:10 <Moggle> ITS RIGHT THERE damnit
18:38:57 <mikeplus64> Moggle: seq is too magical to be defined in haskell unless you use bangpatterns which seem to be described in terms of seq anyway
18:39:10 <mikeplus64> where seq !x y = y probably
18:39:47 <Moggle> thanks mikeplus!
18:40:44 <Jafet> You can define seq for any type, though
18:41:23 <Jafet> (By analogy to NFData)
19:02:01 <Moggle> @src fix
19:02:01 <lambdabot> fix f = let x = f x in x
19:02:21 <min|dvir|us> ?
19:02:26 <min|dvir|us> What is the point of fix?
19:02:33 <Moggle> Infinite recursion.
19:02:51 <cmccann> > fix (1:)
19:02:52 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:03:03 <zomg> sounds more like break than fix, at least in any other language than haskell
19:03:04 <zomg> =)
19:03:12 <min|dvir|us> > fix (+1)
19:03:16 <lambdabot>   mueval-core: Time limit exceeded
19:03:21 <min|dvir|us> Nice.
19:03:21 <cmccann> > fix error
19:03:22 <hpc> zomg: it certainly doesn't fix errors, that's for sure
19:03:22 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:03:24 <hpc> > fix error
19:03:25 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:03:31 <hpc> dammit cmccann
19:03:32 <cmccann> too slow!
19:03:32 <Jafet> @quote metastereo
19:03:33 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
19:03:47 <message144> > fix fix
19:03:48 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
19:04:31 <Moggle> > fix (\fact n -> if n == 0 then 1 else n * fact (n - 1)) 5
19:04:32 <lambdabot>   120
19:04:33 <Sintendo> I ended up making my own Logger monad to work around my putStr problem
19:04:37 <Sintendo> thanks everyone
19:05:16 <Jafet> Logger sounds less environmentally friendly than Writer.
19:06:58 <message144> I have decided to spend a few months going through the Euler problems in Haskell before moving on to learning monads... is that a sensible idea?
19:07:26 <zomg> if you like solving euler problems instead of studying haskell, certainly.
19:07:28 <zomg> =)
19:07:38 <Jafet> Yes, but you can learn haskell in a week.
19:08:10 <JoeyA> I'm thinking "a few months" would be a long time to do rudimentary practice, unless you don't spend much time at it.
19:08:27 <message144> i have about 30 mins a day to allocate to it
19:08:28 <Moggle> Jafet: I don't think you can...
19:08:53 <Moggle> Jafet: Haskell keeps surprising me with a million little things. I can learn other languages in a week, but not Haskell.
19:08:58 <message144> so, i guess it is going to be a long slow process for me
19:09:14 <Moggle> It's part of being a functional language, I think.
19:09:41 <Jafet> Well, you can, but you might not.
19:09:53 <zomg> message144: well if you're that busy then yeah, though I would still consider just picking some project I'd want to do and try implementing it, learning more about haskell (like monads or whatever) when I run into them and can't proceed
19:09:54 <hpc> Moggle: you can learn some other functional languages in a week
19:10:44 <Moggle> hpc: I'll look into those once I have satisfied myself that I am not completely incompetent in Haskell :P
19:10:53 <Moggle> I suspect learning Haskell to take another month or so.
19:11:03 <Moggle> will take*
19:11:16 <hpc> it took me a month to go from zero to "i have an irc bot with no features"
19:11:28 <hpc> and that was... 3 years ago
19:11:40 <Moggle> that sounds pretty reasonable!
19:11:41 <DrChaos> my friend says Haskell is worthless because you can't get a job programming in Haskell
19:11:41 <lambdabot> DrChaos: You have 1 new message. '/msg lambdabot @messages' to read it.
19:11:43 <Jafet> Moggle: ok, most people can learn haskell in a week, but some experienced programmers might take longer.
19:12:01 <Moggle> Jafet: I suspect the problem is what it means to 'learn' a language. :P
19:12:15 <hpc> Jafet: icwydt
19:12:48 <cmccann> Jafet, very true, that
19:12:52 <Moggle> DrChaos: I don't care if I ever get a job programming in it, it's more about opening your mind to different ways of doing things and such.
19:13:10 <DrChaos> Moggle :: ok, I'm all for that
19:13:18 <Jafet> DrChaos: that bait line is getting old. Try another
19:13:24 <DrChaos> it's just ... I will have to learn Java too
19:13:28 <Moggle> But there _are_ industry applications from my understanding
19:13:29 <Moggle> ew java
19:13:42 <DrChaos> which is not very good...I'd rather program in C
19:13:56 <Moggle> DrChaos: yeah, but I'd rather use Ruby than C.
19:14:10 <Moggle> depends on what you're doing though
19:14:16 <Moggle> ruby kind of fails in a lot of areas even though I love it
19:14:37 * hackagebot sym 0.6 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.6 (AndersClaesson)
19:15:00 <cmccann> one benefit of using Haskell is that the people who dislike it are usually people I would want to avoid anyway
19:16:17 <DrChaos> cmccann :: heheh, you can say that again
19:16:44 <cmccann> a fact I am reminded of every time I look at /r/programming
19:17:05 <cmccann> (a mistake I make every month or two)
19:17:26 <hpc> heh
19:17:47 <heatsink> I have difficulty understanding how non-Haskellers conceptualize programs.
19:18:01 <Jafet> echo 127.0.0.1 reddit.com >> /etc/hosts
19:18:09 <hpc> funny story: my boss is totally incapable of reading python code
19:18:09 <flebron> the standard material after finishing LYAH is RWH, correct? isn't RWH a bit... dated by now?
19:18:17 <hpc> he can read and write C, perl, etc all just fine
19:18:26 <cmccann> Jafet, that would interfere a bit with being a moderator on /r/haskell unfortunately
19:18:27 <hpc> but he can't even read python
19:18:34 <hpc> i show him some haskell code
19:18:45 <hpc> he can make perfect sense of it, without knowing the language
19:19:03 <hpc> haskell: easier for non-fluent programmers than python
19:19:10 <cmccann> heatsink, a surprising number of programmers do not, actually, conceptualize code in any coherent way
19:19:27 <Jafet> The number is not surprising to programmer
19:19:28 <Jafet> s
19:19:37 <cmccann> heh
19:19:41 <heatsink> That's a little disturbing, cmccann
19:19:52 <Jafet> flebron: yes
19:20:02 <shachaf> cmccann: I mostly just hammer on the keyboard until it type checks.
19:20:08 <shachaf> cmccann: That's how lens turned out this way.
19:20:26 <Jafet> shachaf is of the civilized sort. Most use their faces.
19:20:29 <shachaf> I think edwardk does the same thing, except he doesn't stop when it type checks.
19:20:35 <cmccann> hahahaha
19:20:37 <hpc> flebron: rwh is dated, and mostly just a library reference anyway
19:20:41 <BMeph> shachaf: Really? I thought lens way born that way... ;)
19:20:49 <hpc> you use it to get started on the conceptual sticking points of parsec or something
19:20:51 <JoeyA> @quote perl
19:20:51 <lambdabot> olsner says: hmm, so perl basically has all harmful features ever invented?
19:20:53 <flebron> so after LYAH the next step is to... start coding?
19:20:58 <hpc> then it's straight to hackage for how to really use it right
19:21:07 <JoeyA> So did the lambdabot quotes get purged recently?
19:21:08 <cmccann> flebron, that sounds reasonable to me
19:21:18 <Jafet> @quote perl
19:21:18 <lambdabot> acowley says: Good haskell code is 20 LANGUAGE pragmas, 40 imports, then one line of perl.
19:21:24 <JoeyA> That's what I was looking for.
19:21:29 <flebron> heh
19:21:40 <shachaf> @quote pearl
19:21:40 <lambdabot> No quotes match. stty: unknown mode: doofus
19:21:53 <shachaf> @brain are you thinking what i'm thinking?
19:21:53 <hpc> the best haskell code is 900 lines of type classes with no main function
19:21:54 <lambdabot> Oooh, I think so Brain, but I think I'd rather eat the Macarena.
19:22:01 <hpc> somehow it still produces an executable
19:22:19 <hpc> at the top: {- Author: Oleg -}
19:22:35 <srhb> Magic.
19:22:57 <shachaf> {-# AUTHOR Oleg #-}
19:23:05 <shachaf> That turns on GHC expert mode.
19:23:22 <Jafet> No, it turns off GHC expert mode. Two experts is one too many.
19:23:41 <hpc> haha
19:23:44 <cmccann> what does {-# AUTHOR elliott #-} do? import Unsafe.Coerce automatically?
19:24:07 <shachaf> cmccann: It actually just changes the type of id.
19:24:13 <cmccann> haha
19:24:31 <hpc> {-# AUTHOR edwardk #-} turns on an entirely separate monomorphism restriction that forbids you from writing monomorphic functions
19:24:35 * shachaf is actually to blame for most of the unsafeCoerces in lens.
19:24:40 <edwardk> =P
19:24:49 <cmccann> hpc, I've been suggesting -XPolymorphismRestriction for years now I think
19:24:49 <shachaf> Well, most at one point.
19:24:55 <shachaf> It's gotten better since then.
19:25:10 <edwardk> hpc: you forgot. it also turns off MultiLetterVariableNames
19:25:14 <cmccann> hahaha
19:25:19 <hpc> oh yes, that too
19:25:27 <shachaf> Isn't that off by default in H2010?
19:25:53 <hpc> i shudder to think what people will think of my code if i upload a popular package
19:26:16 <cmccann> hpc, what, none of your existing packages are popular?
19:26:19 <cmccann> can't imagine why not.
19:26:21 <shachaf> cmccann: But you weren't the first!
19:26:23 <hiptobecubic> i'd be delighted if anyone took the time to think about my code
19:26:27 <hpc> cmccann: :)
19:26:49 <heatsink> has concatMap stream fusion been improved since the Stream Fusion paper?
19:27:05 <JoeyA> "cmccann> hpc, I've been suggesting -XPolymorphismRestriction for years now I think"  GHC has that, you just have to change the file extension from .hs to .c
19:27:52 <shachaf> No, that's a monomorphism restriction.
19:31:11 <hrumph> how does either behave as an applicative functor?
19:31:17 <hrumph> i don't know where to look it up
19:31:38 <shachaf> Do you know how it behaves as a monad?
19:31:48 <Jafet> @src Either fmap
19:31:48 <lambdabot> fmap _ (Left x) = Left x
19:31:48 <lambdabot> fmap f (Right y) = Right (f y)
19:31:50 <hrumph> i found it
19:32:00 <Jafet> @src Either (<*>)
19:32:00 <lambdabot> Source not found. There are some things that I just don't know.
19:32:03 <mauke> @djinn a -> Either e a
19:32:03 <lambdabot> f = Right
19:32:09 <hpc> hrumph: some instances are really hard to find, sadly
19:32:18 <hrumph> shachaf yes and i know exactly how i want it to behave as an applicative
19:32:27 <hrumph> it turns out its doing what i want
19:32:39 <shachaf> hpc: I rarely have trouble.
19:32:43 <mauke> @djinn Either e (a -> b) -> Either e a -> Either e b
19:32:43 <lambdabot> f a b =
19:32:43 <lambdabot>     case a of
19:32:43 <lambdabot>     Left c -> Left c
19:32:43 <lambdabot>     Right d -> case b of
19:32:43 <lambdabot>                Left e -> Left e
19:32:45 <lambdabot>                Right f -> Right (d f)
19:32:49 <shachaf> I type :i Either in ghci, and it tells me which module the instance is defined in.
19:32:55 <hrumph> since i'm just doodling i keep wanting to change my code around trying out one thing then another
19:33:00 <hpc> shachaf: you and your knowing how to find things...
19:33:00 <shachaf> Then I look up that module.
19:33:08 <hpc> my first reflex for everything is hoogle
19:33:19 <hpc> which i even have set as a firefox keyword
19:33:33 <shachaf> mauke: To be fair, there are two valid (<*>)s for Either.
19:33:34 <hpc> "hoogle a -> a" in the url bar instantly brings up hoogle's search results
19:33:51 <shachaf> djinn's solution isn't unique.
19:34:23 <Jafet> (<*>) = ap
19:34:28 <hpc> shachaf: it can pick either of the two errors, yes?
19:34:41 <shachaf> Something like that, yes.
19:34:43 <hpc> in the event of two Lefts
19:34:47 <hrumph> when i look up applicative and it shows me the instances why not links to documentation for the instances?
19:34:52 <hrumph> in hoogle
19:35:08 <shachaf> hpc: The second instance is available in (Backwards (Either e))
19:37:41 <M30W> Is there a way to tell ghc that two seperate data types can have the same values ? I.e AErrors = FileNotFound BErrors = FileNotFound both in different context.
19:38:02 <heatsink> no
19:38:20 <heatsink> The usual solution is to have different data constructors for the two data types
19:38:26 <hpc> unsafeCoerce
19:38:26 * M30W expected that the type-set would cleanly know that it's after AError and get the FileNotFound from AError
19:38:27 * hpc ducks
19:38:55 <shachaf> hpc: Unhelpful answers are unhelpful even if you type "/me ducks" after giving them.
19:39:05 <M30W> heatsink: So. I define FileNotFound before both instances?
19:39:15 <heatsink> data A = AFileNotFound | ...
19:39:20 <heatsink> data B = BFileNotFound | ...
19:39:25 <M30W> Eh
19:39:30 <shachaf> M30W: It works in the reverse direction: From "FileNotFound" it figures out that your type is "AError".
19:39:38 <shachaf> You can't have both directions.
19:40:04 <hpc> you could with a type class, but it's not worth it for such a minor thing
19:40:05 <M30W> Okay
19:40:27 <manju> I know this is the wrong channel to ask this question, but people are really nice here :-). So here goes.
19:40:44 <manju> Does anyone know where I can find the eclipse java compiler ?
19:40:56 <heatsink> I think eclipse is just an IDE
19:41:01 <Jafet> manju: fuck off
19:41:05 <Jafet> There, fixed
19:41:17 <manju> Jafet, Haha...
19:41:23 <M30W> data ACK = FileNotFound; data FileErr = FileNotFound; shachaf You're suggesting adding type FileNotFound before both?
19:41:34 <heatsink> FileNotFound isn't a type
19:41:41 <heatsink> it's a data constructor
19:41:48 <shachaf> M30W: I'm not suggesting anything, and FileNotFound is not a type.
19:41:54 <heatsink> the types are ACK and FileErr
19:41:57 <manju> Jafet, This is for haskell actually. I am trying to see if I can get Frege working on Android. But I don't know anything about Java.
19:41:58 <shachaf> I'm explaining why it's not so easy as you might think.
19:42:15 <M30W> shachaf: 14:39          hpc | you could with a type class, but it's not worth it for such a minor thing
19:42:18 <M30W> Ah wrong nick
19:42:21 <M30W> hpc: ^^
19:42:27 <M30W> Sorry shachaf
19:42:31 <DrChaos> manju :: what is Frege?
19:42:34 <shachaf> M30W: A type class is the wrong solution to this problem.
19:42:36 <Jafet> To work with java on android, you probably need the android sdk.
19:42:42 <manju> DrChaos, it is a subset of Java.
19:43:08 <M30W> shachaf: What would be the desirable solution?
19:43:14 <DrChaos> manju :: :(
19:43:17 <manju> Jafet, yes, but there is a problem. I want to compile Frege source on Android itself.
19:43:35 <manju> DrChaos, Sorry, I meant it is a subset of Haskell which runs on JVM.
19:43:40 <shachaf> To what problem?
19:44:15 <manju> I learnt from the internet, that the eclipse compile runs on android.
19:44:23 <manju> compiler*
19:44:32 <manju> So trying to find the eclipse compiler.
19:44:32 <Clint> is there a way to have mapM action [1,1,2,1] only execute action twice but produce the corresponding four elements?
19:44:49 <M30W> shachaf: The conflict between both data structures having FileNotFound
19:45:02 <shachaf> Solution: Give them different names.
19:45:19 <M30W> Ah. What about import qualified ? (Seperate files)
19:45:23 <DrChaos> manju :: OH WOW
19:45:28 <DrChaos> That makes me more happy
19:45:48 <manju> DrChaos, it doesn't work yet, I mean Frege does, but not Android.
19:46:40 <manju> DrChaos, not on Android.
19:46:49 <JoeyA> Clint: You could implement such a combinator yourself, that caches results.
19:47:24 <shachaf> M30W: Foo.A and Bar.A are different names.
19:47:33 <M30W> I know.
19:47:36 <JoeyA> Clint: I think the type signature would be: mapMCached :: (Ord a, Monad m) => (a -> m b) -> [a] -> m [b]
19:48:14 <Jafet> dedup :: Ord a => (a -> b) -> [a] -> [b]
19:48:32 <Clint> JoeyA: and run State inside?
19:49:15 <JoeyA> Clint: Right.
19:49:18 * M30W qualified only one of them; the other is more used. In fact the second may not even be required in the main.hs Heh. (Modulating the project)
19:49:30 <Moggle> @src isEOFError
19:49:31 <lambdabot> Source not found. My mind is going. I can feel it.
19:49:32 <JoeyA> (though coding the state passing manually wouldn't be that hard)
19:49:39 <Moggle> curses
19:49:47 <Moggle> should have guessed that would have been too easy
19:49:47 <Clint> i guess that'll work
19:49:49 <Clint> thanks
19:50:01 <JoeyA> Clint: is this for a strict monad or a lazy monad?
19:50:25 <JoeyA> In a strict monad (like IO), you may want to deviate a bit from the usual mapM, which has a stack overflow problem.
19:50:44 <Clint> JoeyA: SqlPersist
19:51:14 <JoeyA> Probably a strict monad, I don't know.
19:51:32 <Clint> how would I find out?
19:52:00 <M30W> How do you make a global variable ? Accessable by all functions and modifications stay consistant. Wrapper ?
19:52:31 <Clint> JoeyA: newtype SqlPersist m a = SqlPersist { unSqlPersist :: ReaderT Connection m a } deriving (Monad, MonadIO, MonadTrans, Functor, Applicative, MonadPlus)
19:52:44 <JoeyA> Depends on the m you use, then.
19:53:00 <Clint> m is IO
19:53:14 <JoeyA> IO is a strict monad, so SqlPersist IO should be, too.
19:53:17 <Clint> ok
19:53:47 <Moggle> Is it possible to do something like reverse on a type constructor?
19:53:50 <JoeyA> Clint: feel free to hpaste your mapMCached implementation, and I'll review it.
19:54:11 <Clint> JoeyA: ok, thanks
19:54:13 <hpaste> heatsink pasted “Class context problem” at http://hpaste.org/80342
19:54:21 <Moggle> Or would you just create a wrapper for it in a new class?
19:54:30 <heatsink> I think this should typecheck, but I'm getting an error
19:54:41 <Moggle> err, type. Data. Whatever Haskell calls it.
19:55:08 <heatsink> M30W, You can use an IORef
19:55:47 <heatsink> M30W, the usual practice is to define a global data structure that's passed to all the functions that need it, then use a monad to make the passing implicit
19:56:39 <M30W> heatsink: Could you link me to a real world example? I just did a quick search just found the haddoc.
19:56:48 <JoeyA> hpaste: Maybe because normalize doesn't use the first argument, so TM t m doesn't apply?
19:57:11 <Jafet> :t let nubMap f xs = g f xs M.empty where g _ [] _ = []; g f (x:xs) m = case M.lookup x m of Just r -> r : g f xs m; _ -> let y = f x in y : g f xs (M.insert x y m) in nubMap
19:57:12 <lambdabot> Ord k => (k -> a) -> [k] -> [a]
19:58:06 <M30W> JoeyA: ... hpaste is the paste bot heatsink pasted that
19:58:38 <JoeyA> Oh
19:58:39 <Jafet> hpaste was supposed to tell heatsink, but didn't. Bad hpaste.
19:58:50 <JoeyA> Whoops, meant to say heatsink
19:59:08 <M30W> JoeyA: It did
19:59:18 <M30W> hpaste | heat﻿sink pasted
19:59:21 <heatsink> Hmm
19:59:31 <hrumph> how do i do multiple where clauses at the same level of indentation?
19:59:58 <shachaf> You just do.
20:00:11 <hrumph> getting parse error
20:00:13 <hpc> same way as any other layout-introducing thing
20:00:15 <hrumph> let me look at this
20:00:26 <shachaf> hrumph: Please recall the steps I listed before. :-)
20:00:27 <JoeyA> hrumph: why do you need to?  You can put multiple definitions inside a single where clause.
20:00:28 <hpc> @src sort
20:00:28 <lambdabot> sort = sortBy compare
20:00:31 <hpaste> heatsink annotated “Class context problem” with “Class context problem (annotation)” at http://hpaste.org/80342#a80343
20:00:33 <hpc> @src sortBy
20:00:34 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:00:46 <hpc> well fine lambdabot, don't show the huge version
20:00:55 <hrumph> ok the multiple definitions seemed to work
20:01:01 <heatsink> No, it still happens if I change it to 'normalize x = get x' and adjust types accordingly
20:01:02 <hrumph> it didn't like where repeated
20:01:20 <hpc> you don't repeat the 'where'
20:01:26 <hpc> just align the definitions
20:01:36 <hpc> where foo = bar
20:01:38 <hrumph> ok so its one where clause
20:01:39 <hpc>       bar = baz
20:01:41 <hpc> ...
20:03:16 <JoeyA> heatsink: Oh, I see it.  TM t m does not imply EM m
20:03:37 <JoeyA> It would if you said class EM m => TM t m, but you say instance instead.
20:04:27 <heatsink> M30W: An example is the X monad in XMonad.  The monad manages a global state of type XState. http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html
20:04:36 <parcs> > let x = -sqrt 2 in zipWith (!!) (iterate (x **) x) [100000..100003]
20:04:37 <lambdabot>   No instance for (GHC.Float.Floating [c0])
20:04:37 <lambdabot>    arising from a use of `e_12100...
20:05:16 <parcs> > let x = -sqrt 2 in zipWith (!!) (repeat (iterate (x **) x)) [100000..100003]
20:05:17 <lambdabot>   [NaN,NaN,NaN,NaN]
20:05:23 <parcs> yay
20:06:12 <heatsink> There could be a m such that TM T m, but not EM m?
20:06:44 <heatsink> I see
20:07:22 <M30W> heatsink: Would this work with a persistant list of say [File]
20:08:04 <JoeyA> heatsink: I don't think such an instance could exist (since it would overlap with the instance TM T m you have), but GHC can't get the dictionary of EM from TM based on this existential argument.
20:08:17 <hrumph> woohoo
20:08:24 <hrumph> got my program to go now with an applicative
20:08:47 <hrumph> so i worked with monad, monad transform, and now an applicative
20:09:01 <hrumph> and a monoid
20:09:22 <hrumph> that's enough groundwork for me now to work on bigger projects
20:09:23 <heatsink> M30W, what do you mean by persistent?
20:09:35 <M30W> heatsink: Changes stick accross the program
20:09:57 <heatsink> You have to manage persistence on your own by loading and saving files at appropriate times.
20:10:23 <M30W> Oh that persistance idk about *yet* heh. I mean while it's running.
20:10:40 <heatsink> Looks like I need to reorganize my class hierarchy, then.
20:10:57 <hpaste> Hrumph pasted “Example” at http://hpaste.org/80344
20:10:58 <M30W> Different functions changing the list, adding, getting, modifying, removing etc.
20:11:08 <hrumph> ok i'm wondering if what i did is a good use of an applicative
20:11:24 <heatsink> M30W, to make it mutable, put the data in an IORef, and put the IORef in the state that's managed by the monad
20:11:24 <hrumph> in the opinion of the experts or is there a better method
20:12:05 <M30W> heatsink: I'm confused and I don't know where O.o
20:12:12 <shachaf> hrumph: It may be better expressed as "traverse"
20:12:14 <shachaf> Or it may not.
20:12:16 <shachaf> Who knows.
20:12:21 <hrumph> it seems that in order to use (:) efficiently i end up with output in the reverse order of the input. is there a way around that?
20:12:26 <JoeyA> hrumph: the parens around mainControlProcessLine line are redundant.  Function application binds more tightly than any operator.
20:12:28 <heatsink> @hoogle IORef
20:12:28 <lambdabot> Data.IORef module Data.IORef
20:12:28 <lambdabot> Data.IORef data IORef a
20:12:28 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
20:12:40 <shachaf> Probably preprocessing the list and then traversing it would be more natural.
20:12:41 <hrumph> ok i will look up traverse
20:13:18 <heatsink> M30W, http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Data-IORef.html
20:14:32 <hrumph> shachaf: i can't preprocess the list i'm doing lazy evaluation
20:14:49 <shachaf> hrumph: OK then, apply a function to the list to get a new list.
20:15:22 <M30W> heatsink: I'm still confused on how to implement it?
20:15:40 <M30W> In the context of [File]
20:16:47 * M30W goes back to libmpd's source learnt a lot there. :)
20:19:58 <Fuuzetsu> @pl id x = x
20:19:58 <lambdabot> id = id
20:20:13 <Fuuzetsu> @pl f x = x
20:20:13 <lambdabot> f = id
20:20:45 <Fuuzetsu> @src id
20:20:46 <lambdabot> id x = x
20:20:56 <Fuuzetsu> so is there a way to write id point-free?
20:22:44 <nh2_> when I define my own (!!!) = (Data.Vector.Unboxed.!), why does everything become 4 times slower?
20:23:27 <M30W> nh2_: Large list?
20:23:59 <nh2_> M30W: I'm just making a local alias for the vector access function for stylistic changes
20:24:05 <nh2_> but it changes performance :(
20:24:17 <nh2_> Is it because I have -auto-caf -auto-all on?
20:25:03 <hrumph> oh i see traverse may indeed be the most succinct way to do this
20:25:12 <quchen> Is there some easy way of specializing :t queries in GHCi? For example, how would I use it to find the type of (>=>) for the Maybe monad?
20:26:08 <M30W> Ah, how do you append to a list without making it just recursion?
20:26:19 <hrumph> shachaf: thanks for the tip
20:27:06 <fmap> Fuuzetsu: `fmap fix return'
20:27:20 <flebron> M30W, x ++ [y]?
20:27:28 <shachaf> Fuuzetsu: In terms of what?
20:27:48 <M30W> flebron: I thought x:y but it doesn't store back into the list and let y = x:y just loops
20:28:13 <flebron> M30W, given a list x, and a list y, the concatenation of x and y can be written x ++ y
20:28:47 <M30W> flebron: one list, one element to add; how to add that element into that list?
20:28:50 <Jafet> :t ap const const `asTypeOf` id
20:28:52 <lambdabot> b -> b
20:28:57 <flebron> M30W, x ++ [y]
20:29:10 <M30W> flebron: That doesn't go back into the list.
20:29:21 <flebron> "go back into"?
20:29:51 <monochrom> lists are immutable. most data types are.
20:29:52 <M30W> > let xs = [] in 5:xs; 6:xs; xs
20:29:54 <lambdabot>   <hint>:1:20: parse error on input `;'
20:30:05 <flebron> you do not alter things in haskell
20:30:33 <M30W> flebron: Wha..?
20:30:47 <M30W> flebron: Adding to a list; should be easy.
20:30:56 <flebron> you can get a new list with the element added
20:31:04 <flebron> but there is no notion of "changing" a list to be something else
20:31:17 <fmap> @ty (>=>) `asAppliedTo` const Nothing
20:31:18 <lambdabot> (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
20:31:20 <M30W> O.o
20:31:26 <flebron> that's part of what being purely functional means
20:31:36 <monochrom> I am sorry it is contrary to your expectation
20:32:12 <M30W> So I have to make a new list every time?
20:32:13 <Moggle> M30W: you _can_ have things like arrays with IO stuff
20:32:20 <flebron> M30W, yes
20:33:41 <M30W> How can that make things ideal? O.o
20:33:57 <Moggle> Lazy evaluation
20:34:10 <Moggle> and internally the code that's running doesn't copy and make an entirely new list
20:34:13 <Moggle> :P
20:34:18 <monochrom> I thought it was obviously ideal. but I will explain
20:34:26 <quchen> fmap: Looks good. Where's 'asAppliedTo' from though? Can't hoogle/hayoo it.
20:34:41 * hackagebot mcmc-synthesis 0.1.0.4 - MCMC applied to probabilistic program synthesis  http://hackage.haskell.org/package/mcmc-synthesis-0.1.0.4 (TikhonJelvis)
20:35:22 <monochrom> suppose I have "x=5". then "x=5" stays true. true to "equal", it's really equal. there is no "suddenly x=5, oh suddenly x=6, therefore 5=6?" nonsense
20:35:54 <monochrom> and I don't see why list has to be different from numbers in this regard of what "=" means
20:36:43 <M30W> How would one append to a list then if they can't store it back into the original list ?
20:36:58 <Moggle> By making a new list?
20:37:09 <monochrom> the same as how to obtain 6 from 5
20:37:19 <M30W> :|
20:37:36 <M30W> Haskell problem for me; lists haha. Only issue I have with it now.
20:37:37 <flebron> perhaps you should read an introduction to functional programming
20:37:45 <monochrom> you have 5. but later you want 6. what do you do? "create" a "new" number. 6 is a different number from 5. 6 is "newly created", it's different.
20:37:45 <M30W> @where lyah
20:37:45 <lambdabot> http://www.learnyouahaskell.com/
20:37:58 <flebron> yes, that's the usual recommendation
20:38:00 <Moggle> learn you a haskell is pretty good :D
20:38:18 <monochrom> now is there as reason you accept creating a new number but not creating a new list? both are just data.
20:38:36 <monochrom> also, you do not have to use list
20:38:39 <fmap> quchen: I would guess it's just const
20:39:14 <M30W> monochrom: a number is a single element. a list is well a list of elements. Int != [Int]
20:39:19 <Jafet> This capitalist-industrialist nonsense, creating new numbers all the time. Our old numbers are perfectly serviceable but they are thrown out as garbage in the name of productivity.
20:39:26 <monochrom> then, don't use list
20:39:33 <quchen> fmap: Haha, indeed.
20:39:46 <quchen> @ty (>=>) `const` (const Nothing)
20:39:47 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
20:39:48 <monochrom> also, you do not have to base your algorithm on "append"
20:40:00 <Moggle> Append is slow anyways.
20:40:08 <fmap> quchen: well, you need to restrict type
20:40:08 <Moggle> Prepend is where all the cool kids are.
20:40:17 <fmap> @ty (const :: (a -> b) -> a -> (a -> b)) (>=>) (const Nothing)
20:40:18 <lambdabot> (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
20:40:24 <quchen> More like asTypeOf then
20:41:11 <quchen> Hmm. Well, in that case it might be easier to just replace m with whatever.
20:41:40 <fmap> @ty asAppliedTo
20:41:41 <lambdabot> (t -> b) -> t -> t -> b
20:41:47 <Moggle> Question: a while back someone did something similar to fix (\(a, b, c) -> (c + 2, a*2, 3)) which ended up being (5, 10, 3)
20:41:53 <monochrom> apart from computational cost, there is no reason to make a distinction on "single element, not single element"
20:41:53 <Moggle> does anyone happen to know how one makes fix do that
20:42:02 <quchen> @src asAppliedTo
20:42:02 <lambdabot> Source not found. My pet ferret can type better than you!
20:42:16 <Jafet> > fix (\(a, b, c) -> (c + 2, a*2, 3))
20:42:19 <lambdabot>   mueval-core: Time limit exceeded
20:42:27 <copumpkin> quchen: the source isn't really very important
20:42:33 <monochrom> while I respect your possible concern on computational cost, since you are a beginner, logically you should not make judgement on computational cost as though you knew
20:42:50 <copumpkin> Jafet, Moggle: lazy pattern
20:42:51 <M30W> monochrom: Oh damn, I really need to stop thinking C xD Forgot that with haskell you're passing everything around.
20:43:02 <Moggle> copumpkin: was that the ~ nonsense?
20:43:02 <fmap> @ty (undefined :: (a -> b) -> a -> (a -> b)) (>=>) (const Nothing)
20:43:03 <copumpkin> > fix (\(~(a, b, c)) -> (c + 2, a*2, 3))
20:43:03 <lambdabot> (a -> Maybe b) -> (b -> Maybe c) -> a -> Maybe c
20:43:04 <lambdabot>   (5,10,3)
20:43:08 <copumpkin> Moggle: yep
20:43:15 <Moggle> Thanks :D
20:43:20 <Jafet> Moggle: in haskell, recursive definitions are actually defined using fix
20:43:43 <Moggle> I remain convinced that fix is witchcraft even though I can do things with it
20:43:45 <Moggle> :P
20:44:29 <Jafet> > let a = c + 2; b = a * 2; c = 3 in (a, b, c)
20:44:30 <lambdabot>   (5,10,3)
20:44:37 <copumpkin> Moggle: it's the one ingredient you need to make something turing-complete that wasn't before!
20:44:41 <Jafet> This is formally defined in terms of fix
20:44:42 * hackagebot array-forth 0.2.0.2 - A simple interpreter for arrayForth, the language used on GreenArrays chips.  http://hackage.haskell.org/package/array-forth-0.2.0.2 (TikhonJelvis)
20:44:43 <quchen> fmap, copumpkin: Thanks, should've seen that setting its implementation tu undefined works out.
20:44:49 <monochrom> x++[y] is expensive, yes. so don't use x++[y]. think up a different algorithm.
20:45:00 <quchen> Time to put that thing into GHCi :-)
20:45:02 <quchen> .conf
20:45:19 <M30W> monochrom: x:xs is that not the fastest?
20:45:35 <monochrom> yes
20:45:55 <M30W> xs ++ [x] ?
20:46:02 <monochrom> no
20:46:21 <M30W> How is x:xs expensive?
20:46:39 <flebron> x:xs is fine
20:46:41 <Moggle> It's not.
20:46:47 <flebron> xs ++ [x] is expensive
20:46:47 <Moggle> @src (++)
20:46:47 <lambdabot> []     ++ ys = ys
20:46:47 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
20:46:47 <lambdabot> -- OR
20:46:47 <lambdabot> xs ++ ys = foldr (:) ys xs
20:46:50 <M30W> 15:45         M30W | monochrom: x:xs is that not the fastest?
20:46:50 <M30W> 15:45    monochrom | yes
20:47:00 <M30W> is NOT fastest -> yes
20:47:04 <flebron> ...
20:47:09 <flebron> "is it not X?" "yes" means X
20:47:11 <monochrom> ok you don't know English. "yes" to that question means "yes is fastest"
20:47:30 <flebron> "Are you not entertained?" "Yeah" means "We're entertained"
20:47:31 <M30W> monochrom: Acturally yes to that exact question was it's not the fastest.
20:47:39 <M30W> I was asking if it's not the fastest.
20:47:40 * Jafet throws a yes at monochrom
20:47:41 <flebron> (and then you throw your sword at the caesar)
20:47:42 <Moggle> M30W: (++) is O(n) because it has to go through the entire first list to find its last element to prepend it to the second list.
20:47:52 <Moggle> (:) is O(1).
20:48:12 <M30W> monochrom: Also I never said x++[y] I think that was you. I always had x:xs
20:48:19 <flebron> M30W, that's not how English works, unfortunately. "Didn't you have fun?" "Yeah!" means "I had fun."
20:48:22 <shachaf> fromJust is O(no)
20:49:05 <M30W> flebron: Good example.
20:49:10 <Jafet> let _ = fromJust in Bieber
20:49:27 <flebron> fromJust in case
20:49:43 <flebron> (of fail?)
20:50:36 <monochrom> ok, so use x:xs. but it does not modify xs.
20:50:48 <quchen> flebron: gotta fit 'fix error' somewhere in there as well
20:51:06 * M30W still reads "x:xs is not the fastest?" as yes it's not the fastest, not yes it IS the fastest as I was asking IF it was not. And your question flebron seems more like it's suggesting a yes. Didn't you kinda suggests you did.
20:51:10 <M30W> Atleast how I see it.
20:51:49 <flebron> that's just how English works, "Yes" to "is x:xs not the fastest?" means "yes, it's the fastest"
20:51:59 <Jafet> > "x:xs is not the fastest?" == "x:xs is that not the fastest?"
20:52:01 <lambdabot>   False
20:52:04 <shachaf> 1+5 does not modify 5. If x=5, 1+x does not modify x.
20:52:16 <Jafet> That wasn't grammatical, anyway.
20:52:16 <shachaf> The same applies when x = [1,2,3]
20:53:30 * M30W is stuck on implementing a way to deal with a list of files. (Too much C exp D:)
20:53:55 <monochrom> yes you have a lot of unlearning to do. or cultural shock
20:54:36 <Jafet> Most people learn haskell in a week. Experienced programmers take longer.
20:54:42 * hackagebot forth-hll 0.1.0.0 - A simple eDSL for generating arrayForth code.  http://hackage.haskell.org/package/forth-hll-0.1.0.0 (TikhonJelvis)
20:54:45 <Moggle> M30W: I'm still trying to unlearn imperative things
20:54:54 <Moggle> I'm kind of bad at life :(
20:54:55 <min|dvir|us> Jafet: that's interesting. What makes you say that?
20:55:03 * M30W too used to C/php/javascript/shell scripts. D:
20:55:05 <Jafet> mind: experience
20:55:36 <roconnor> @src flip
20:55:36 <lambdabot> flip f x y = f y x
20:55:44 <M30W> Experience in C like languages gets you thinking C; not how you're meant to be.
20:55:47 <M30W> Sadly. :(
20:56:15 <monochrom> actually imperative programming is fine, C is fine, other languages are fine. I certainly still know them. you do not have to denounce them. you need to open your mind.
20:56:44 <quchen> Jafet: I'd be thrilled to know how Haskell does as a first language. My guess would be it's not very suitable. Is there something to Haskell what Python is to C++?
20:56:53 <Moggle> M30W: as an example, it was like three days ago I learned that you could use foldr on infinite lists
20:57:13 <Moggle> i thought that foldr f a l = foldl f a (reverse l)
20:57:15 <Moggle> turns out nope
20:57:17 <Moggle> > foldr (const) 0 [1..]
20:57:18 <monochrom> heh, when did you find out about infinite list itself? :)
20:57:18 <lambdabot>   1
20:57:31 <Moggle> that was my introduction to haskell, monochrom :D
20:57:38 <Moggle> I saw the infinite fibbonacci series and _had_ to learn more
20:57:41 <M30W> monochrom: from x+=("string") to not being able to. x[]="string" for php.
20:57:50 <Moggle> and then it all kind of spiraled and here I am
20:58:02 * M30W mostly used to shell.
20:58:03 <Moggle> i blame wikipedia
20:58:06 <Jafet> Not sure if quchen should be told to ask the universities who teach programming in haskell, or should be asked what Python is to C++
20:58:25 <Jafet> Moggle: you fell for the bait and switch, too bad.
20:58:30 <Moggle> yeah :(
20:58:52 <Jafet> Most of real haskell work is spent figuring out how many lifts you need to chain
21:00:07 <quchen> Jafet: Python is imperative programming with most (modulo array pointers) difficult things stripped. I don't think the average person wants to read about monadic IO in their first programming experience.
21:00:18 <hrumph> thanks again shachaf. i'm using traverse now and i split the list before calling it. its much cleaner now
21:00:27 <Jafet> Ah, more lies
21:01:17 <Moggle> I learned Visual Basic first. I, uh, thought it was okay really (at the time).
21:01:20 <hrumph> the best thing about haskell code is that it means somehitng when you look at it
21:01:20 <monochrom> perhaps you accept Scheme for beginner purposes?
21:01:23 <hrumph> compare with php
21:01:23 <Moggle> Nowadays it kind of makes me squirm.
21:01:36 <quchen> monochrom: Same here. On both statements
21:01:39 <hrumph> my biggest objection to php is that no one can read someone else's code
21:01:41 <quchen> ^ Moggle
21:01:49 <Jafet> quchen: python is utterly confused and designed by a committee of megalomaniacs
21:01:56 <quchen> It is? Oh.
21:02:08 <Jafet> Now C++ is too, but that ends the list of similarities
21:02:14 <hrumph> i wanted to program in php and i started learning zend and everything then i said screw it
21:02:19 <hrumph> i hated it so much
21:02:23 <Moggle> php is a horrific language :(
21:02:33 <Moggle> any language that needs $ before the variable name should be shot (I'm looking at you too Perl)
21:02:38 <quchen> I always thought Python was the crazy simplifiedest language we currently have.
21:02:49 <Jafet> quchen: and the "learning haskell is all about learning monads" troll bait is getting old. Try another one
21:02:54 <simpson> quchen: It's got lots of warts. It was meant to be easy to learn, not simple.
21:03:16 <shachaf> Moggle: That's a lot of languages used by a lot of people.
21:03:22 <quchen> Jafet: I just meant to illustrate that in Haskell you have to do a lot of learning to actually do and understand stuff. At least that's my experience.
21:03:27 <shachaf> It would be faster to shoot the people who complain instead, I imagine.
21:03:33 <M30W> Hmm
21:03:41 <quchen> Jafet: The feeling of success however is accordingly large.
21:03:47 * cmccann thinks that anyone worried about Haskell being too difficult as a first language should read http://cdsmith.wordpress.com/2011/08/16/haskell-for-kids-week-1/ and the following posts 
21:04:05 <hrumph> quchen: yes its been several weeks now and i'm just writing my third mini-program (variation of the first two) its a slog but its an amazing language that lures you in and keeps you fixated
21:04:12 <Moggle> shachaf: I don't think the horribleness of a language corresponds to the number of people using it
21:04:24 <Jafet> cmccann: no, they are actually correct. Haskell is too difficult for *them*
21:04:38 <quchen> hrumph: That's what got me as well :-)  cmccann: That link looks interesting, thanks
21:04:48 <Moggle> shachaf: After all, C++ is, I think, regarded almost universally as overcomplicated as terrible, but the _speed_ makes it very attractive. Not to mention coding inertia.
21:05:07 <cmccann> Jafet, no, that's still bullshit. it's not too difficult, people just convince themselves it is and refuse to try.
21:05:20 <Jafet> Well, people make it difficult for themselves. I think that still counts.
21:05:21 <hrumph> most speed issues occur only at critical points, which anyone can tell you
21:06:14 <hrumph> most languages will let you wrap C functions for critical cases. (i hope haskell does but i haven't inquired)
21:06:16 <quchen> cmccann: I don't agree. I started with LYAH, the first chapters were easy and I was surprised how logical everything is, but boy when he started with kinds and the Applicative instance of (r ->).
21:07:00 <Moggle> hrumph: Haskell has a FFI which is fairly nice to use
21:07:18 <monochrom> then skip the Applicative instance of (r->). I don't use it anyway. pay more attention to other Applicative instances like []
21:07:45 <monochrom> therefore the complaint is on LYAH not Haskell
21:07:50 <cmccann> Jafet, I refuse to take seriously anyone who claims to be a programmer finding "too difficult" a language that someone could teach to a bunch of kids
21:08:16 <monochrom> Functor, Applicative, Monad instances of (r->) tend to be overblown by over-enthusiastic authors
21:08:22 <hrumph> jafet i wouldn't try teaching haskell at community college. this isn't a joke
21:08:35 <Moggle> cmccann: I don't think Haskell is difficult, but I think functional languages are sufficiently different from imperative languages that it _seems_ hard to those of us who are well-steeped in imperative languages.
21:08:43 <Jafet> You're not obliged by anyone to try anything.
21:09:02 <quchen> monochrom: As a beginner, you're not in the position to judge that. Skipping a chapter means going to IO, where the Monad instance of (r ->) greets you at some point, and then you're like "oh damn gotta go back because he insists that Monads are Applicatives".
21:09:10 <cmccann> Moggle, then what's hard is letting go of preconceived notions, not haskell.
21:09:17 <cmccann> see things for what they are.
21:09:18 <Moggle> cmccann: I concur!
21:09:20 <hrumph> Jafet: quibbling with the notion that it isn't difficult. it is relatively more difficuly then imperative languages. someone told me that was because the human brain operates in iterative mode most of the time
21:09:32 <hrumph> not specifically about haskell. about functional languages in general
21:09:35 <cmccann> hrumph, that's also bullshit.
21:09:42 <monochrom> quchen, I agree, therefore the complaint is on LYAH not Haskell
21:09:50 <Jafet> Hmm, the "brains are imperative" troll is so old and neglected that it just might work again.
21:09:50 <cmccann> the human brain operates in unstructured nonsense mode by default.
21:09:52 <Jafet> Let's see.
21:10:00 <Jafet> I guess not
21:10:11 <monochrom> if I wrote a Haskell tutorial, I would not talk about (r->)
21:10:19 <shachaf> @arrrr ->
21:10:20 <lambdabot> Keelhaul the swabs!
21:10:26 <cmccann> imperative programming is difficult to learn as well. I tutored other students when I was in college, trust me, it's no easier.
21:10:36 <monochrom> or maybe I would talk about it at the end
21:10:46 <quchen> monochrom: Well, the alternative is starting with RWH, which isn't as good of an introduction in the first few chapters compared to LYAH. The last alternative is what you had to do before LYAH/RWH and is not an alternative.
21:11:01 <shachaf> I learned Haskell without reading LYAH or RWH.
21:11:10 <monochrom> again, therefore the problem is with LYAH, not Haskell
21:11:17 <Jafet> Maybe one of these people should stop complaining and write a book which addresses their complaints
21:11:25 <quchen> In the beginning you can't judge whether it's the book or the language that's weird. You can try changing the parameters (book) and see if that helps. In Haskell's case I doubt it.
21:11:37 <cmccann> half the students had as much trouble grasping the idea of *lexical scope* as people seem to have understanding monads or whatever in Haskell.
21:11:39 <Jafet> If they write it well, there might even be a market for it
21:11:40 <hrumph> its a good book. i haven't read all of it but it introduced me to a lot of stuff
21:11:57 <shachaf> cmccann: That's why I use dynamic scope.
21:12:07 <cmccann> shachaf, you are an inspiration to us all.
21:12:23 <Hafydd> That's because humans encountered the wild are almost all intensely stupid.
21:12:23 * cmccann neglects to mention exactly what shachaf inspires.
21:12:34 <Jafet> :t ?shachaf
21:12:36 <lambdabot> (?shachaf::t) => t
21:12:38 <monochrom> quchen, you started by asserting that Haskell is hard on beginners, and at the end your evidence is something in LYAH that trips you. but LYAH is not Haskell
21:13:38 <quchen> So what is Haskell when you've never been exposed to it? Reading Wikipedia? I think LYAH for many *is* Haskell for the first couple of weeks.
21:14:24 <cmccann> I think I mostly learned haskell by feeding nonsense to GHC and then trying to figure out why it didn't work. :T
21:14:31 <shachaf> Perhaps Haskell is Hutton's book, _Programming in Haskell_
21:14:36 <quchen> cmccann: Good point hehe
21:14:50 <Jafet> @quote haskell.is
21:14:51 <lambdabot> blackh says: Haskell is great because of all the wonderful things you can't do with it.
21:14:55 <monochrom> Bird's book talks about monad, the State monad, the Error monad, a parser monad, and monad transformers. and it doesn't talk about (r->)
21:15:04 <b__> Hutton's book is a good start
21:15:08 <monochrom> I would write a Haskell book, but Bird already wrote it
21:15:16 * cmccann tends toward the "push buttons until you figure it out or something explodes" style of learning
21:15:22 <shachaf> When I learned Haskell, nobody talked about Applicative functors. The wikibook still had picures of astronauts or nuclear waste (I don't recall which).
21:15:41 <b__> this was in which decade?
21:15:54 <shachaf> 1930s.
21:16:19 <hrumph> is there a generic mergesort function in hasksell somewhere that works on lists of ords?
21:16:19 <Jafet> The schonfinkel wikibook certainly didn't have any of that nonsense.
21:16:21 <b__> yesbutno, when did you learn Haskell?
21:16:32 * cmccann and shachaf should collaborate on writing a haskell book. the result would probably be... interesting.
21:16:33 <shachaf> I don't know.
21:16:57 <quchen> cmccann: Haskell by Monte Carlo - learn :: String -> IO [Maybe something]
21:17:07 <cmccann> quchen, works for me!
21:17:29 <monochrom> quchen, "Haskell is hard on beginners" is very broad. you are only thinking of self-learners, who have a very high probability of using LYAH, sure. but what about a prof teaching a Haskell class in a college? that is more likely to use something else.
21:17:45 <shachaf> cmccann: I once tried to write something that could have been an introduction to Haskell, or to parts of Haskell.
21:17:48 <shachaf> It turns out that writing is hard.
21:18:00 <shachaf> Unfortunately I've not found a good solution to that problem.
21:18:00 <cmccann> monochrom, judging by some of the questions on SO that something else is often much worse than LYAH :[
21:18:08 <quchen> monochrom: You've got a point there. I was kind of biased from how I learned it there.
21:18:14 <Jafet> monochrom: if you are lucky, there will be slides
21:18:15 <Moggle> shachaf: Have you considering coding a general AI to write the book for you?
21:18:16 <b__> I was not aware that LYAH was bad
21:18:31 <cmccann> shachaf, I've probably written a book's worth of stuff combined on stack overflow. pretty sure I could handle that part.
21:18:44 <shachaf> cmccann: That's much easier, though.
21:18:54 <shachaf> I like SO because you can write an introduction on some specific topic in response to a specific question.
21:19:02 <shachaf> I like IRC for the same reason.
21:19:05 <Jafet> b__: people demand instant mind transfer
21:19:30 <quchen> LYAH is great.
21:19:32 <monochrom> if you skip (r->) in LYAH, it is good
21:19:37 <M30W> What year was haskell started to be created?
21:19:38 <shachaf> I find it difficult to start from scratch.
21:19:47 <shachaf> monochrom: Wow, you really hate (r->), don't you.
21:19:49 <quchen> I would have finished it even if I had hated Haskell just to make sense of the doodles :-)
21:19:50 <monochrom> there may also be a bit of outdated stuff
21:20:05 <monochrom> perhaps because I hate Cale's (.)
21:20:07 <b__> I find LYAH to be brilliantly written
21:20:07 <M30W> Which year was the haskell language first created *
21:20:09 <M30W> ?
21:20:14 <b__> 1987 I thikn
21:20:23 <M30W> Wow
21:20:31 <shachaf> cmccann: Didn't you already start writing a Haskell book?
21:20:32 <Jafet> Haskell was created by decree of the late Hal Selassie
21:20:34 <shachaf> What happened to that?
21:20:43 <Moggle> quechen: Wait, the doodles are meant to make sense?
21:20:46 * shachaf would rather recommend cmccannook than LYAH
21:20:47 <thoughtpolice> the haskell 1.0 standard came out in 1990, IIRC
21:21:08 <cmccann> shachaf, no, I only started talking about how should start writing a haskell book.
21:21:11 <Jafet> Then Ethiopia was invaded and it went underground for half a century
21:21:11 <cmccann> important difference.
21:21:33 <shachaf> cmccann: It's more or less the same, isn't it?
21:21:41 <shachaf> Maybe *that's* where I've gone wrong with all my everything.
21:21:48 <monochrom> I don't hate (r->). but I don't support introducing it early. the very notation is advanced.
21:21:56 <quchen> Moggle: they're always somewhat related to the text, or contain some very unrelated nonsense. (Read the tree in the zipper chapter line by line for example)
21:22:17 <Moggle> quchen: I... I didn't know. D:
21:22:20 <gwern> @quote
21:22:20 <lambdabot> TomMD says: c.h.o should move to ARM... then a distributed system would be needed.
21:22:22 <cmccann> shachaf, well I suppose neither involves having a completed book so there's that at least
21:22:24 <quchen> Moggle: There's no middle between. There are no "just unrelated" doodles.
21:22:35 <zomg> Jafet: we had an ethiopian immigrant working as a cleaner in our old office.. Her shirt had a picture of haile selassie, and I obviously didn't know who it was but it looked like Chuck Norris
21:22:45 <flebron> i liked (->) in lyah
21:22:46 <zomg> She had absolutely no idea who Chuck Norris was...
21:22:47 <jfischoff> /me wants to see the "Haskell for Evil Geniuses" book
21:22:48 <zomg> lol
21:22:55 <jfischoff> :p
21:23:01 <flebron> it was interesting to see that the reader monad was "things that expect a value to be what they are"
21:23:20 <Jafet> zomg: does it make a difference which one is worshipped?
21:23:26 <flebron> (so "+2" is actually a number, as soon as you give it what it wants :p)
21:23:28 <cmccann> jfischoff, not sure if that's enough of a gimmick to get a whole book out of
21:23:44 <cmccann> could probably make it work but you'd need a bit more of a premise I think
21:23:49 <hrumph> when i call "sort"how do i know what algorithm will get used?
21:23:59 <M30W> jfischoff: I predict that book be about network hacking w\ great use of haskell's performance. :D
21:24:07 <zomg> Jafet: I think worshipping chuck norris should be implicit
21:24:08 <zomg> =)
21:24:36 <Jafet> hrumph: a fast one
21:24:38 <jfischoff> I could see it going a lot of ways
21:24:49 <M30W> jfischoff: Yea. List a few ^_^
21:24:54 <Moggle> Is there even like, a comparison of basic Haskell speeds vs C anywhere? I know Java is like 70% the speed of C or some such thing.
21:25:06 <Jafet> @quote einstein
21:25:06 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
21:25:11 * M30W 's greatest interest is networking so yea. ^_^
21:25:16 <hrumph> looks like its using a version of mergesort in the source
21:25:33 <Moggle> Jafet: yeah, but I suspect it is slightly slower due to massive use of thunks
21:25:46 <Moggle> Jafet: Maybe around the speed of Java?
21:26:07 <Jafet> How do you measure the speed of Haskell, C, or Java?
21:26:12 <Jafet> I am curious
21:26:35 <hrumph> when i sort a list of tuples or constructs, can i be sure that only pointers are being moved around and that the no time is being wasted copying entire structs?
21:26:47 <cmccann> Jafet, turn them on, time it with a stopwatch, see how far they move
21:26:59 <shachaf> hrumph: You can be sure of nothing.
21:27:00 <cmccann> my results so far are that all languages move at roughly 0 m/s
21:27:01 <shachaf> Why do you care?
21:27:05 <Moggle> Jafet: Code similar algorithms, compare. That's unfair for a functional vs imperative language (since you don't really do modifiable data structures in a functional language) but it wouldn't be too hard to get a rough guess.
21:27:07 <Jafet> @google java continental plate movement
21:27:08 <lambdabot> http://en.wikipedia.org/wiki/Geology_of_Indonesia
21:27:08 <lambdabot> Title: Geology of Indonesia - Wikipedia, the free encyclopedia
21:27:33 <hrumph> shachaf: if i  eventually manage to do what i want to do, i am talking about what could be a critical stage of the program.
21:27:46 <hrumph> sorting a lot of data can be the make or break part of a program
21:28:21 <Jafet> Moggle: what does "code similar algorithms, compare" mean
21:29:06 <monochrom> code-similar algorithm is the dumbest comparison. why should a haskell solution be code-similar to a prolog solution?
21:29:24 <Jafet> Because prolog is a subset of haskell, man
21:29:30 <Jafet> Everybody knows that
21:29:35 <Moggle> monochrom: Pattern matching is basically Prolog.
21:29:40 <cmccann> it's like fundeps with backtracking, right
21:29:42 <cmccann> totally the same thing.
21:29:46 <monochrom> problem-based do-your-best-algorithm comparison is the only rational comparison
21:29:46 <Nereid> @hoogle Maybe a -> [a]
21:29:46 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
21:29:46 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
21:29:46 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
21:29:50 <quchen> Code-similar comparison is like translating English to German word by word and then comparing which of the results expresses the original meaning better.
21:30:09 <Jafet> Translating english to german is id, isn't it
21:30:55 <Moggle> quchen: Perhaps it is, but if you measure sum [1..10000] compared to for(i=1;i<=10000;i++)sum+=i;
21:31:17 <Moggle> and say, Haskell takes 10 seconds whilst C takes 0.01 seconds it might be important to know
21:31:24 <monochrom> ok fine, haskell solution vs php solution. there.
21:31:41 <cmccann> haskell vs. brainfuck
21:31:52 <monochrom> or that, yeah
21:31:54 <Moggle> oh god brainfuck
21:32:05 <Moggle> i should implement a brainfuck interpreter in haskell for fun
21:32:10 <Moggle> wouldnt be too hard
21:32:13 <Jafet> x86-64 microcode
21:32:24 * cmccann figures monochrom was already suggesting comparison to joke languages
21:32:26 <Mortchek> Moggle, the other way around would be way cooler
21:32:39 <Moggle> Mortchek: More impressive, yeah.
21:32:54 <Jafet> cmccann: why did you suggest brainfuck, then
21:33:10 <cmccann> because PHP seemed a bit too extreme
21:33:17 <Mortchek> Moggle, that said, good luck not going insane after a few weeks of attempting that
21:33:25 <quchen> Moggle: In an ideal scenario, you're comparing the solutions of many relatively simple problems (as in problems a person, not a computer, has) in two languages. I don't think it'll get better than that.
21:34:39 <Moggle> quchen: I don't understand why it's so hard just seeing some basic comparisons of the speed of generated code between haskell/C/whatever.
21:34:43 <monochrom> sum [1..10000] is more fair than "the haskell version must use IORef because it must be code-similar to the C version"
21:34:44 * hackagebot text-format 0.3.1.0 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.1.0 (BryanOSullivan)
21:35:12 <Moggle> quchen: I'm hardly looking to mathematically say "Haskell is super slow compared to everything"
21:35:25 <monochrom> in fact, sum [1..10000] is code-dissimilar to for(i=1;i<=10000;i++)sum+=i;. therefore the example proves the point. denounce code-similarity
21:35:31 <Moggle> It's no matter, I found some good answers on stack overflow comparing some Project Eueler problems. ^_^
21:35:35 <Jafet> Moggle: I don't understand why it's so hard for you to search the web for basic comparison of the speed of generated code between different languages
21:35:38 <Moggle> Haskell is just behind C.
21:35:49 <Moggle> Jafet: I was just curious if it was a common number!
21:36:08 <Jafet> Look up the numbers and see if they are the same
21:36:21 <Jafet> Google is so hard.
21:36:36 <Moggle> @src rem
21:36:36 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:36:51 <Moggle> @src mod
21:36:51 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:36:56 <quchen> Moggle: Summing up X numbers is not something you write a program for. You write a program to query a database, aggregate results and print that. You also have to take into account how long it takes you to finish the program, i.e. the time between the idea and the solution, not just execution time.
21:37:33 <monochrom> rem and mod are class methods
21:37:35 <Moggle> quchen: For sure. I have no problems with that. I was just curious about execution time.
21:37:40 <quchen> Moggle: PE is often about finding an efficient Brute Force algorithm. For that use ifortran.
21:37:51 <quchen> Then link that in Haskell :>
21:38:28 <Jafet> project euler is for bragging that you know a little bit of number theory to your peers who don't know any number theory
21:38:32 <simpson> ^^
21:38:45 <quchen> Comparing the speed of two languages really resembles comparing the expressivity of spoken languages. There's too many parameters and too many debatable things.
21:38:45 <monochrom> I would s/number theory/numerology/
21:39:29 <monochrom> let's compare the speed of English and Chinese too
21:40:05 <Axman6> well, you can always do micro benchmarks on spoken languages too :{P
21:40:08 <Moggle> quchen: And yet, you can say speaking Entish (from lord of the rings) is far slower than speaking whatever their English equivalent is.
21:40:24 <Jafet> Both travel at about 330 m/s
21:40:43 <Moggle> Jafet: Entish has a way higher latency.
21:41:05 <Axman6> only if spoken by an ent
21:41:09 * cmccann isn't sure this conversation even makes sense anymore, if it ever did.
21:41:09 <Mortchek> Ha, my language, eyebrow-waggle, is way faster than your language
21:41:18 <Mortchek> It travels at the speed of light. Beat that!
21:41:39 <Moggle> quchen: I realize that asking if X language is faster than Y language is a ridiculous question in general. But for basic, specific things, I was curious.
21:41:51 <simpson> I have a new strategy for finishing projects. First, I upload them to Hackage, and then I guilt myself into finishing them since they're public.
21:42:01 <Moggle> I think it would have been fine if you had said "It's roughly on par with C"
21:42:15 <quchen> Mortchek: I communicate using entangled states. Ha
21:42:28 <Jafet> Moggle: we do give that answer, to people who aren't obviously using it to troll
21:42:40 <simpson> Moggle: It is *incredibly* important to remember that C might not be the fastest tool for the problem.
21:43:12 <Moggle> Jafet: I'm confused at your accusations of trolling :/
21:43:20 <Mortchek> quchen, out of curiosity, pardon my lack of knowledge of quantum mechanics, but isn't it supposed to be impossible to get information from those?
21:43:51 <Moggle> simpson: I never said that and agree with the statement.
21:43:56 <Jafet> Mortcheck: it does not violate causality. Think about it carefully
21:44:01 <cmccann> Mortchek, you can get information that way. you just can't decode it without other information transmitted at lightspeed :P
21:44:19 <zomg> isn't quantum computing mostly about probabilities instead of hard values
21:44:24 <monochrom> Moggle, if I knew that answer with good evidence, I would give that answer. but I don't. but note I did not complain about the question, I think it's fine, it's just hard to have good data to answer it. I only spoke against code-similar
21:44:44 * hackagebot lye 0.1.0.0 - A Lilypond-compiling music box  http://hackage.haskell.org/package/lye-0.1.0.0 (CorbinSimpson)
21:44:48 <Axman6> this whole conversation sounds like good fodder for #haskell-blah
21:45:25 <Moggle> monochrom: that's reasonable
21:46:50 <Jafet> I wonder if this lye thing can sound better than midi{}
21:47:27 <simpson> Jafet: TBH It's a port of the original Python version, and isn't quite yet up to snuff.
21:47:42 <simpson> But I'm workin' on it!
21:47:44 <zomg> haha, wtf is the Acme category on Hackage...
21:47:50 <zomg> for joke-modules? :P
21:48:07 <Jafet> As in, does it just output midi or what
21:48:08 <simpson> zomg: Inspired by the Acme namespace in Perl, probably.
21:48:22 <Jafet> acme is clearly for the best modules
21:48:23 <Jafet> @wn acme
21:48:24 <lambdabot> *** "acme" wn "WordNet (r) 3.0 (2006)"
21:48:24 <lambdabot> acme
21:48:24 <lambdabot>     n 1: the highest level or degree attainable; the highest stage
21:48:24 <lambdabot>          of development; "his landscapes were deemed the acme of
21:48:24 <lambdabot>          beauty"; "the artist's gifts are at their acme"; "at the
21:48:26 <lambdabot> [9 @more lines]
21:49:02 <simpson> Jafet: It currently outputs MIDI files. In a day or two, it'll also support live output to Fluidsynth, through my fluidsynth package. The goal is to be able to compose a large piece of music in Lilypond and have a minimum of effort required to output an entire session.
21:49:15 <simpson> Like, the original target is video game background music.
21:49:46 <Jafet> Yes, midi{} is useless and annoying
21:52:22 <epta> http://hpaste.org/80346 I have installed unordered-containers package but could not import Data.HashMap.Strict in ghci. What am I doing wrong?
21:53:31 <heatsink> It might be a hidden package
21:53:45 <heatsink> try :set -package unordered-containers
21:54:12 <epta> heatsink: it's not hidden
21:54:28 <monochrom> did you install anything after you had installed unordered-containers?
21:55:07 <mikeplus64> try ghc-pkg check, maybe something is haywire in your cabal/ghc setup
21:55:41 <epta> cannot satisfy -package unordered-containers:
21:55:41 <epta>     unordered-containers-0.2.3.0-cb8d9e3870018672eb2ce565efe4afbe is unusable due to missing or recursive dependencies:
21:55:44 <epta>       hashable-1.2.0.3-b4f67b246e5dc5229c87fa3ef245baab
21:56:09 <epta> That means that I should install hashable first and then unordered-containers?
21:56:23 <monochrom> no, it means something else
21:56:47 <monochrom> I want the outputs of "ghc-pkg list -v" and "ghc -v"
21:57:26 <monochrom> my money is on "you have too many packages" not "you have too few packages". the outputs will be my proof.
21:57:48 <hpaste> M30W pasted “Need to manage this [File] list and don't know how to start” at http://hpaste.org/80347
21:57:56 <hrumph> is there a library function to tell me if a sorted list is a set?
21:57:58 <M30W> ^_^
21:58:36 <hrumph> i can write my own i guess for now
21:59:04 <hrumph> i saw a nub function bits it works on unsorted lists to identify duplicate elements or something and it O(n^2)
21:59:15 <monochrom> yes, it will be slow
22:00:23 <Jafet> all (null . drop 1) . group . sort
22:00:24 <heatsink> When using -XTypeFamilies and -XConstraintKinds, I should be able to say "type family T a :: Constraint", right?
22:00:42 <cmccann> heatsink, sure
22:01:01 * M30W stares at his code he just added some documentation to.
22:01:02 <cmccann> heatsink, unless you forget to import GHC.Prim or something :P
22:01:15 <shachaf> Please. GHC.Exts.
22:01:24 <cmccann> oh, is that where it is?
22:01:26 * cmccann can't recall
22:01:31 <shachaf> It's defined in .Prim
22:01:31 <hrumph> jafet that's awsome
22:01:36 <cmccann> oh, ok.
22:01:38 <shachaf> But .Exts is for things that GHC "officially" exports.
22:01:41 <cmccann> ah
22:01:46 <shachaf> @ty GHC.Exts.the
22:01:46 <cmccann> ok, listen to shachaf then.
22:01:47 <lambdabot> Eq a => [a] -> a
22:01:57 <heatsink> Oh, so I needed to import that
22:02:01 <heatsink> thanks
22:02:22 <cmccann> heatsink, yeah, for mysterious reasons just enabling the extension doesn't mean Constraint is in scope
22:02:55 <epta> monochrom: "you have too many packages" was a right answer
22:03:06 <M30W> Could someone suggest how I can go with this little daemon?
22:03:33 <M30W> -- | Source is in hpaste link 'M30W pasted “Need to manage this [File] list and don't know how to start” at http://hpaste.org/80347
22:05:16 <ceii> M30W: you want to be able to modify the file list in response to commands, is that it?
22:05:34 <M30W> ceii: For now that.
22:05:43 <ceii> in that case you need to create an IORef for it, you can't modify globals
22:06:05 <M30W> Why hpaste telling me to use hPrint instead of hPutStrLn ? O.o
22:06:24 <hrumph> once aagain that was a nice little function. i was going to do essentially the same thing with pairs using zip but this is way neater
22:06:26 <M30W> Oh nvm, fair enough
22:06:45 <ceii> because hPrint h is hPutStrLn h . show
22:08:00 <hpaste> M30W annotated “Need to manage this [File] list and don't know how to start” with “Need to manage this [File] list and don't know how to start (annotation)” at http://hpaste.org/80347#a80348
22:08:13 <M30W> ceii: Yea, I noticed.
22:08:20 <M30W> :)
22:09:06 <ctc> where can I get the binary (x86 Ubuntu) for GHC head?
22:09:10 <Jafet> :t liftA2 (==) (S.size . S.fromList) length
22:09:11 <lambdabot> Ord a => [a] -> Bool
22:09:22 <Jafet> ctc: do you know what HEAD means?
22:09:31 <M30W> Ha, missed half the corrections :P
22:09:34 <monochrom> M30W, do not modify. instead, in your next recursive call, pass a different parameter. see my http://hpaste.org/52480 for a concrete example. I do not "modify" lo and hi, I pass in new values in the recursive call
22:09:41 <ctc> the latest development version I mean
22:09:45 <ceii> ctc: http://www.haskell.org/ghc/dist/current/dist/
22:09:55 * cmccann is amused when hlint suggests he replace "concat . map f" with "concatMap f"
22:10:40 <Jafet> Those are nightly builds, if that's what you want.
22:10:48 <Jafet> (Why are they called nightly builds, not daily builds?)
22:11:15 <cmccann> because they happen at night?
22:11:16 <monochrom> they are built at night, when the Dark Knight works
22:11:32 <ceii> Jafet: because the big old single-user mainframe is booked during the day? :)
22:11:36 <monochrom> (we do not call him Daily Knight either :) )
22:11:37 <hpaste> heatsink annotated “Need to manage this [File] list and don't know how to start” with “Need to manage this [File] list and don't know how to start (annotation) (annotation)” at http://hpaste.org/80347#a80349
22:12:20 <heatsink> There's an example.
22:12:28 <heatsink> I defined a monad ServerM in which server computations should run.
22:12:50 <heatsink> This monad manages the server's global state.
22:13:16 <heatsink> The functions 'getFiles' and 'setFiles' read and write the file list.
22:13:42 <M30W> monochrom: Heh; played your game, took... 1 guess !
22:13:48 <heatsink> This is all wrappers around using readIORef and writeIORef to read and write mutable refrerences in the IO monad.
22:14:06 <Jafet> ReaderT (IORef a)
22:14:08 <Jafet> Hmm
22:14:32 <M30W> monochrom: I also have a different issue there; I have not just one loop but two. Each client would find them selves in a different environment.
22:14:59 <M30W> So, I can pass it through parseIn as you suggested but I can't get it like that for EACH client.
22:15:02 <M30W> ?
22:15:17 <monochrom> you have two clients?
22:15:49 <M30W> monochrom: Not this second (testing) but it's expected for the end use.
22:16:26 <M30W> monochrom: So.. Back to IORef ?
22:16:30 <monochrom> ah I see forkIO, you will have N threads for N clients
22:16:38 <M30W> Exactly.
22:17:28 <monochrom> you will have N threads running N instances of parseIn for N clients. therefore, passing parameters to parseIn is thread-local
22:17:38 <ceii> M30W: actually you want an MVar, which is an IORef with locking
22:17:58 <monochrom> unless you mean, you actually want single global instance
22:18:12 <monochrom> err
22:18:44 <M30W> monochrom: I know how it's working; They need to share the [File] list.
22:18:54 <M30W> ceii: MVar, Thank-you.
22:18:56 * M30W searches
22:19:37 <heatsink> I still suggest using a monad wrapper as in the code I annotated
22:19:42 <heatsink> But with MVar instead of IORef
22:20:07 <monochrom> I see, yeah MVar is one. IORef is also suitable if you use atomicModifyIORef
22:20:18 <ctc> I grabbed a nightly build, unpacked it and when execute ./configure in the root I get this error: "configure: error: cannot determine current directory "
22:20:24 <M30W> heatsink: Ah, didn't see that annotate
22:20:41 <monochrom> atomicModifyIORef may be simpler for this task
22:20:53 <Axman6> i was about to suggest that
22:21:10 <Axman6> atomicModifyIORef can be extremely fast
22:21:40 <monochrom> MVar is fine for this task provided that you strictly adhere to the discipline "takeMVar, then putMVar". otherwise you have troubles
22:22:49 * M30W 's first haskell program; Getting confusing.
22:23:33 <johnw> M30W: it gets better, trust em
22:24:38 <monochrom> I think it's fair to say "believe me, correctly behaving shared variable takes more learning in other languages, haskell already makes it easy to pick up"
22:24:53 <M30W> Oh I know it's getting better. :)
22:25:19 <M30W> Shared variables w\ multiple threads *
22:25:32 <ctc> any wiki page on how to install the nightly builds/ binaries?
22:25:48 <heatsink> Well, when language learners write code that doesn't work, they know it's their fault
22:26:04 <heatsink> But when they can't write code in the first place, they often blame the language
22:26:34 <monochrom> I am skeptical of the first one
22:27:35 <M30W> I never blamed the language but did mention that it was a bit strange not being able to modify a list which acturally makes sense as the variables would just be passed with recursion or stored in a MVar
22:29:05 <M30W> monochrom: Which do you think would suit better (More information will exist in the data structure like progress etc) MVar or IORef w atomicModifyIORef
22:29:26 <cmccann> some people blame themselves, some people blame the language, but the people who really know what they're doing blame shachaf.
22:29:54 <Nereid> I thought IORef wasn't supposed to be used with concurrency stuff.
22:30:05 <M30W> cmccann: Please tell me a bot in here has some sort of !grab or @remember :D
22:30:17 <M30W> @remember
22:30:17 <lambdabot> Incorrect arguments to quote
22:30:20 <M30W> :D
22:30:21 <Nereid> @remember cmccann some people blame themselves, some people blame the language, but the people who really know what they're doing blame shachaf.
22:30:21 <lambdabot> I will remember.
22:30:28 <M30W> Nereid: Just beat me to it.
22:30:41 <Nereid> @quote cmccann shachaf
22:30:41 <lambdabot> cmccann says: some people blame themselves, some people blame the language, but the people who really know what they're doing blame shachaf.
22:30:57 <cmccann> @quote cmccann
22:30:57 <lambdabot> cmccann says: Haskell shares many of Lisp's best features. Not being Java, for instance.
22:30:58 <ctc> I also get this error when executing ./configure on ghc-7.7.20121213-x86_64-unknown-linux.tar.bz2: "./configure: line 2138: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd-bindist: No such file or directory" any solution?
22:31:03 <cmccann> @quote cmccann
22:31:03 <lambdabot> cmccann says: multi-letter type variables is an experimental new extension
22:31:17 <cmccann> there are way too many quotes from me in there :I
22:31:17 <shachaf> cmccann: I blame shachaf for that last quote.
22:31:23 <cmccann> shachaf, good call.
22:32:13 * shachaf welcomes the blame with open arms.
22:32:21 <Guest76229> anyone writing a windows rt version ghci?
22:32:29 <shachaf> I will take care of it as soon as cmccann takes care of my work.
22:33:18 <cmccann> shachaf, eh I've been too busy not working on my own projects to not do any of your work
22:33:42 <shachaf> cmccann: So you've been doing my work?
22:33:48 <Guest76229> lol
22:33:57 <Guest76229> i am the same way cmccann
22:34:02 <cmccann> no, I haven't had time for that either
22:34:30 <Guest76229> its hard work doing nothing
22:34:34 <monochrom> M30W: I would start with atomicModifyIORef. the job looks simple enough for now. but later, if the nature of the job changes, I would move to MVar, Chan, or TVar
22:34:46 <cmccann> yeah. not doing things takes a lot of time.
22:34:50 <shachaf> cmccann: I guess all your time has been taken up learning about lens, right?
22:35:17 <monochrom> it is highly-dependent on the exact actual job. so, not to say that I always begin with atomicModifyIORef
22:35:25 <cmccann> shachaf, it takes me a day or two to read each type signature
22:35:53 <monochrom> not all jobs are best done by shared variables. but...
22:35:54 <shachaf> cmccann: Same thing with edwardk, I suspect. That's why he rewrites them every time he comes across one.
22:35:59 <cmccann> haha
22:38:29 <monochrom> individual shared variable => atomicModifyIORef. wait for someone => MVar. messaging => Chan, TChan. a group of shared variables related by a data invariant => TVar
22:39:49 <monochrom> unfortunately, most other languages tell you to use shared variables and a few locks to do all four, therefore some programmers come to Haskell narrow-minded
22:42:25 <monochrom> whereas, I am just as narrow-minded, I tell you to use messaging for all four :)
22:44:36 <M30W> monochrom: Wouldn't a TVar be more suited then since File is more data?
22:45:21 <monochrom> oh, interesting.
22:45:23 <Axman6> you're only holding a list of Files right?
22:45:44 <monochrom> if you use immutable list, that's really one single point. individual shared variable
22:45:52 <monochrom> s/point/pointer/
22:46:10 <ctc> Which files/folders should I remove to wipe out the previous GHC installation (default settings in Ubuntu) entirely?
22:46:57 <monochrom> atomicModifyIORef blah (\xs -> (x:xs, xs))
22:47:26 <M30W> monochrom: So IORef it is?
22:48:05 <monochrom> but TVar gives you enough power to define your own mutable linked list. more work for you but you can haz mutable linked list now and it's thread-safe and coherent and all
22:48:50 <Axman6> and will probably lead to pretty crappy latency :\
22:49:05 <statusfailed> I'm about to (try to) teach Haskell to two newcomers to programming- does anyone have any suggestions on where to start?
22:49:42 <Jafet> http://cdsmith.wordpress.com/2011/08/16/haskell-for-kids-week-1/
22:49:51 <chirpsalot> Hmmmm.  I feel like I missed something.  What's this {-# LANGUAGE FlexibleContexts #-}
22:50:18 <chirpsalot> Not sure what to Google for.
22:50:39 <Axman6> @google Haskell FlexibleContexts GHC wiki
22:50:41 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleContexts
22:50:41 <lambdabot> Title: FlexibleContexts – Haskell Prime
22:50:46 <Jafet> @google ghc user's guide flexiblecontexts
22:50:56 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleContexts
22:50:56 <lambdabot> Title: FlexibleContexts – Haskell Prime
22:51:08 <chirpsalot> Sorry, I mostly meant the block comments thing.
22:51:16 <Jafet> @google ghc language pragma
22:51:18 <lambdabot> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghc-language-features.html
22:51:18 <lambdabot> Title: Chapter�7.�GHC Language Features
22:51:21 <chirpsalot> Thanks!
22:51:42 <Jafet> statusfailed: also http://www.haskell.org/haskellwiki/Haskell_in_education
22:51:51 <M30W> monochrom: So I was right to suggest TVar :D
22:52:06 <M30W> @hoogle TVar
22:52:07 <lambdabot> Control.Concurrent.STM.TVar module Control.Concurrent.STM.TVar
22:52:07 <lambdabot> GHC.Conc.Sync TVar :: (TVar# RealWorld a) -> TVar a
22:52:07 <lambdabot> GHC.Conc TVar :: (TVar# RealWorld a) -> TVar a
22:52:18 <Guest76229> hi
22:52:19 <monochrom> it may not be right to want a mutable linked list often
22:53:05 <statusfailed> Jafet: ooh, the "Haskell as a first language" link looks great
22:53:30 <Jafet> Yes. The only problem is that all of the information there is obsolete
22:53:48 <monochrom> it takes a critical mind to see that about half of the uses of mutable data in imperative languages does not need mutability after all
22:53:55 <Jafet> Also, http://www.cs.nott.ac.uk/~gmh/book.html: Ordering the book via either of the preceeding referral links to Amazon gives a higher return to the author, for the same price to the purchaser.
22:54:00 <M30W> monochrom: Will this TVar write the whole list every change?
22:54:09 <Jafet> (Hutton wants you to buy his book using his Amazon referral link.)
22:54:26 <monochrom> that depends on what you actually write
22:54:26 <Axman6> M30W: I'd guess that IORef is almost certainly what you want from a performance point of view, and possibly from a ease of use point of view too
22:54:58 <M30W> monochrom: 1000 files, change the status of 3.
22:55:02 <M30W> state *
22:55:08 <Axman6> unless you need to synchronise the values in two different shared variables, STM is probably not the right way to go
22:55:27 * cmccann notes that there's already a mutable linked list made with TVars right there in the same package
22:55:42 <monochrom> must it be a list?
22:55:51 <M30W> monochrom: Not a must.
22:55:59 <Axman6> i was thinking the same thing, about to suggest a set or a map
22:56:08 <M30W> File { id :: Integer, << adding this ;)
22:56:15 <Guest76229> i want to get a dog and name him monad
22:56:37 <M30W> Guest76229: I want you to get a /nick ^_^
22:56:45 <Jafet> I would not do such silly things to animals.
22:56:58 <monochrom> map, set, hashmap, hashset. (find the latter two in unordered-containers)
22:57:01 <Skillsob> Or you might name him Haskell, which happens to be a name.
22:57:04 <manju> So is there a minimal ghci example ?
22:57:06 <Axman6> if I had a dog I didn't like, it's call it IEEE-754
22:57:13 <cmccann> Axman6, that's harsh
22:57:15 <M30W> monochrom: IXSet ?
22:57:17 <tertl3> no monad is more mysterious
22:57:20 <cmccann> animal cruelty >:[
22:57:24 <monochrom> I don't know IXSet
22:57:25 <tertl3> no its not
22:57:26 <Axman6> =)
22:57:30 <manju> If I want to build something like ghci, is there some resource ?
22:57:34 <tertl3> the animalk has no idea
22:57:38 <Jafet> cmccann: perhaps the dog bit him.
22:58:15 <Axman6> I did say it was a dog I didn't like
22:58:31 <tertl3> ah well. my humor is too dry i suppose
22:58:57 * Axman6 -> dinner
22:58:57 <statusfailed> Jafet: that book link seems broken
23:01:39 <statusfailed> manju: you mean for haskell? There's a ghc library for interpreting haskell
23:02:05 <manju> statusfailed, Wow...Really ?! What is it called ?
23:02:21 <statusfailed> I can't remember, let me find it :D
23:02:43 <monochrom> are you thinking of hint?
23:02:54 <statusfailed> yes!
23:03:18 <statusfailed> thanks monochrom :)
23:03:22 <statusfailed> I can never remember that name
23:03:47 <M30W> monochrom: If not a List then which data type?
23:03:56 <manju> Haha...thanks statusfailed monochrom
23:04:08 <statusfailed> np, have fun :D
23:04:11 <monochrom> <monochrom> map, set, hashmap, hashset. (find the latter two in unordered-containers)
23:04:26 <M30W> @hoogle hashmap
23:04:26 <lambdabot> package hashmap
23:06:49 * M30W installs hashmap.
23:07:08 <monochrom> no, don't do that
23:07:13 * M30W ran 'ls' after loading a module O.o
23:07:17 <M30W> monochrom: What?
23:07:36 <monochrom> I wrote 10-11 words there. how many did you read?
23:07:55 <M30W> monochrom: map, set, hashmap, hashset find the latter two in unordered-containers
23:07:59 <M30W> All
23:08:11 <monochrom> yes good, so did you see "unordered-containers"?
23:08:18 <M30W> Yes
23:08:30 <monochrom> so install unordered-containers instead
23:08:35 <M30W> Oh
23:08:38 <M30W> Okay
23:09:01 <M30W> How to remove a package? O.o
23:09:14 <monochrom> ghc-pkg unregister
23:13:08 <M30W> O.o
23:14:47 * hackagebot yesod-fay 0.2.0 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.2.0 (MichaelSnoyman)
23:15:13 <M30W> How do I define the HashSet Files ?
23:18:23 <monochrom> @tell shapr I am interested in using ghclive on my computer. what are some security and safety precautions I should watch out for? thanks
23:18:23 <lambdabot> Consider it noted.
23:23:38 <M30W> monochrom: How do I define thw HashSet ?
23:25:34 <M30W> Wait; Okay, what I have to do is get a HashSet as the (TVar or IORef; which?)
23:30:19 <M30W> monochrom: Also; looking through your hpaste; http://hpaste.org/80347#a80349 << Wouldn't this have issues with a race condition?
23:34:54 <M30W> The number is between 81 and 81 -- Lol @ game
23:54:48 * hackagebot hakyll 3.5.2.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.5.2.1 (JasperVanDerJeugt)
