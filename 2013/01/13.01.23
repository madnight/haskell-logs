00:02:45 <rex> this is a test
00:03:14 <latermuse> my -Infinity came from computing (log 0)
00:13:33 <lightquake> i forget, what do i need to do to make data Foo a = Foo a deriving (Show) work (i.e., auto-derive in the case that a has a show instance)
00:13:48 <johnw> it should just work like that
00:13:59 <johnw> what's the error?
00:14:06 <lightquake> … oh wait
00:14:17 <lightquake> nevermind, i'm silly
00:16:10 <b__> where you're deriving only one instance you can omit the parens
00:29:03 <mm_freak_> b__ would hate my source code =)
00:30:02 <b__> can, not should ;)
00:32:32 <mm_freak_> according to my experience most haskell programmers have a compulsive need to get rid of parentheses =)
00:34:07 <johnw> i certainly suffer from that compulsion
00:34:16 <johnw> despite coming from Lisp!
00:34:30 <frerich> *because* you're coming from Lisp, maybe.
00:36:04 * hackagebot hlint 1.8.42 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.42 (NeilMitchell)
00:37:47 <latermuse> mm_freak: I frequently opt-in for more parenthesis. it offers better clarity sometimes
00:38:20 <snowylike> call me weird, but i like the parentheses
00:42:28 <liyang> I try to avoid nesting parentheses. If it's not nested, it's more readable with them than with $ I feel.
00:43:11 <dinox_> \msg lambdabot hejhej
00:43:14 <shachaf> $ is overused
00:43:27 <dinox_> whoops
00:44:32 <liyang> If a () pair spans multiple lines, I put an extra space after and before them.
00:47:50 <edwardk> i'm somewhat neutral on a single pair of parens as long as i can keep them from spanning multiple lines
00:48:22 <edwardk> any time i have to create an opening context that i have to close multiple lines later that isn't layout based i'm sad.
00:48:48 <b__> it's usually avoidable with lets and wheres though right?
00:49:15 <liyang> Yes, but sometimes they just add extra noise. It Depends.
00:49:20 <liyang> On Reasons.
00:49:23 <edwardk> let is fundamentally a multiline context i have to close with 'in' in most circumstances
00:49:48 <edwardk> so 'where' is my principal recourse, but that doesn't work in lambdas.
00:50:09 <edwardk> so it becomes a little game to restructure things so you avoid the parens while not passing duplicate arguments everywhere
00:50:38 <AfC> [what bugs me is the overloading of \ ... every time I see \p -> and \_ -> I keep thinking they're escaping the character. Retraining my brain slowly, but ouch]
00:50:38 <shachaf> Think of all the time you're wasting playing these little games!
00:50:45 <shachaf> You'd save all that if you just used LISP.
00:50:58 <b__> shachaf is right, you could've been playing Spelunky instead
00:51:20 <shachaf> b__: Can you give me a non-WINE port of Spelunky please?
00:51:24 <AfC> shachaf: if he wasn't playing these little games, he'd be sleeping. And then where would we be? Clarity of thought! It would be a disaster. Fight the temptation.
00:51:27 <shachaf> And also non-HTML.
00:51:31 <edwardk> shachaf: sure just upgrade to a mac
00:52:16 <shachaf> Purity of essence.
00:52:22 <shachaf> Our precious bodily fluids!
00:52:32 <shachaf> http://slbkbs.org/fluids.jpg
00:52:46 <johnw> there is no way i'm clicking on that link
00:53:03 <shachaf> It's more appropriate for #-blah anyway.
00:54:14 <shachaf> Hey, ddarius posted to -cafe.
00:54:22 <shachaf> I guess he's alive.
00:54:39 <b__> is he a legend?
00:55:09 <shachaf> Hmm, is ddarius a legend?
00:55:20 <cmccann> shachaf: hey look https://github.com/isomorphism/Delineate
00:55:43 <cmccann> probably will add some dual-intuitionistic stuff later just for fun.
00:56:15 <shachaf> Oh, that looks exciting.
00:56:33 <cmccann> it's a slightly cleaned-up version of that hpaste'd code, obviously
00:56:46 <cmccann> the haddocks are all goofy because I just used the existing comments
00:56:50 <shachaf> I can put it next to all the other "exciting-looking things at github.com/isomorphism/ that I never get around to properly looking at".
00:56:56 <cmccann> haha.
00:57:15 <cmccann> these is on hackage now though!! so you can use bicrosswalk in all your applications.
00:57:27 <shachaf> help
00:57:51 <shachaf> Does it have lens support yet?
00:58:01 <cmccann> well it has the things I added.
00:58:17 <cmccann> that work as prisms or whatnot.
00:58:17 <shachaf> Is it using lens 3.8 now?
00:58:23 <shachaf> I guess it already was.
00:58:29 <cmccann> I dunno. it's using whatever it is.
00:58:35 <cmccann> it doesn't have a lens dependency.
00:59:06 <liyang> cmccann: no, I'm sure it can give up any time it wants to.
00:59:06 <shachaf> cmccann: I totally came up with multiplicative disjunction before I ever heard of it.
00:59:23 <shachaf> In a moment of "whoa, dude, wouldn't it be crazy if"
00:59:30 <shachaf> I refuse to believe it's actually a thing.
01:00:06 <cmccann> shachaf: you should have just invented polycategories.
01:00:32 <cmccann> cf. http://ncatlab.org/nlab/show/polycategory
01:00:54 <cmccann> that's actually what inspired my implementation
01:02:00 <shachaf> How can we get ddarius to come back to IRC?
01:02:19 <shachaf> The channel is pretty much pointless without him.
01:02:45 <Maxdamantus> > Left 42 :: Int `Either` Double
01:02:47 <lambdabot>   Left 42
01:09:10 <hpaste> killy9999 pasted “recursive definitions” at http://hpaste.org/81157
01:09:25 * killy9999 is trying to understand these mutually recursive definitions
01:09:58 <killy9999> boolTyCon refers to falseDataCon, falseDataCon refers to boolTyCon
01:10:03 <killy9999> what sense does it make?
01:10:18 <killy9999> I know that thanks to Haskells laziness this works
01:11:53 <killy9999> this is actually taken from GHC - does anyone know how GHC uses these data types and why is this mutuall recursion necessary?
01:22:04 <srhb> The discussion about iteratees/pipes/conduits seems to have died down recently. Have we settled for pipes? :P
01:22:08 <frerich> killy9999 : It's probably just me needing some more coffee, but - where in your paste is the mutual recursion? :-}
01:23:37 <killy9999> well.. its in my paste :)
01:24:01 <killy9999> boolTyCon passes falseDataCon as a param to pcTyCon
01:24:19 <killy9999> falseDataCon passes boolTyCon as a param to pcDataCon
01:24:53 <latermuse> killy9999: You cant do that with modules though
01:25:06 <latermuse> killy9999: foo imports bar and bar imports foo wont work
01:26:05 * hackagebot yesod-rst 0.2.3 - Tools for using reStructuredText (RST) in a yesod application  http://hackage.haskell.org/package/yesod-rst-0.2.3 (PascalWittmann)
01:27:03 <killy9999> latermuse: unless you break dependency loop with a .hs-boot file ;)
01:28:24 <latermuse> killy9999: how does a .hs-boot file work?
01:28:37 <Anna30F> ____________Hello __________
01:31:17 <frerich> killy9999: Ah, I thought you meant to ask why mutually recursive definitions like that one work, but I guess you want to know what this particular definition means and why mutually recursive definitions are needed here.
01:32:52 <killy9999> latermuse: it gives type signatures for some functions without giving their definitions
01:33:29 <killy9999> this allows to break the loop in the dependency by using only type signatures provided by hs-boot, not the actuall implementations from a module
01:33:36 <killy9999> frerich: both in a sense
01:33:43 <killy9999> I understand how this technicaly works
01:34:02 <killy9999> but after almost a year with Haskell this still feels counterintuitive
01:34:44 <killy9999> and I guess I'd like to know in this particular case how are things organized that this doesn't end up with an infinite loop
01:35:01 <killy9999> s/infinite loop/bottom/
01:35:02 <killy9999> :)
01:35:17 <frerich> killy9999: I think you'd need to look at the definitions of pcTyCon and pcDataCon to see when/if they evaluate their arguments.
01:35:30 <killy9999> I'll do it
01:35:51 <killy9999> but my guess is that they just assign their parameters to fields of the appropriate data type
01:36:03 <killy9999> this seems quite often in GHC
01:36:50 <killy9999> latermuse: one more thing about hs-boot files. You ust use {-# SOURCE #-} pragma when importing to note that you want to use the boot file, not the actuall implementation
01:40:37 <mm_freak_> can i QuickCheck that a pure value throws an exception?
01:40:51 <mm_freak_> i mean, it throwing an exception is the expected behavior
01:42:07 <killy9999> mm_freak_: I gues syou could write a helper function for that?
01:43:11 <mm_freak_> 'expectFailure' seems to do it
01:46:29 <killy9999> "Modifies a property so that it is expected to fail for some test cases. "
01:46:33 <killy9999> for some or for all?
01:46:59 <killy9999> I mean is such a property allowed to fail or expected to fail?
02:06:07 * hackagebot HarmTrace 2.2.0 - Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-2.2.0 (JosePedroMagalhaes)
02:06:09 * hackagebot gitlib 0.7.0 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.7.0 (JohnWiegley)
02:08:16 <TorosFanny> I defined a Monadic iterate like this : iterateM f x = (f x) >>= iterateM f >>= return.(x:)
02:08:25 <TorosFanny> it compiles
02:08:33 <johnw> hello TorosFanny
02:08:52 <TorosFanny> but iterateM (return.(+1)) 0 >>= return.(take 10) never terminate
02:09:03 <TorosFanny> hello johnw
02:09:07 <johnw> can you describe what you expect iterateM to do?
02:09:25 <shachaf> TorosFanny: Haven't you asked about this function a few times before?
02:09:27 <johnw> you want it to repeatedly generate a value of by reapplying f?
02:09:28 <shachaf> Or was that someone else?
02:09:40 <TorosFanny> list a directory in breadth-first order
02:09:41 <johnw> shachaf: he was asking about (a -> m b) -> m (a -> b) before
02:09:54 <shachaf> johnw: *Someone* was asking about iterateM in here.
02:10:04 <shachaf> I want to know whether to give the same old response or what.
02:10:22 <TorosFanny> not the same question
02:10:40 <johnw> TorosFanny: so, are you asking why iterateM isn't lazy?
02:10:53 <TorosFanny> this is another way to list the directory
02:11:24 <TorosFanny> Yes
02:12:13 <johnw> so, the type of your function is Monad m => (a -> m a) -> a -> m [a]
02:12:16 <wuttf> Anyone using Hastache here? How good is it?
02:12:19 <TorosFanny> yes
02:12:22 <johnw> which is the right type for you want to do
02:12:26 <saeidw> I just found an implementation of Either in php on github
02:12:37 <johnw> but check out the return type
02:12:39 <johnw> it's not a list
02:12:54 <wuttf> saeidw: Link?
02:13:00 <shachaf> I think it will be best if you don't encourage lazy I/O here. :-)
02:13:04 <shachaf> I don't know whether that's your plan.
02:13:06 <TorosFanny> certainly not, it's a m []
02:13:14 <saeidw> wuttf, https://github.com/JosephMoniz/php-either
02:13:18 <shachaf> PHP is pretty off-topic in here.
02:13:30 <johnw> correct, so an m [] is a single value, not a list of values
02:13:41 <saeidw> shachaf, sorry about that, it just seemed interesting
02:13:45 <TorosFanny> I used it like this :iterateM (return.(+1)) 0 >>= return.(take 10)
02:13:46 <johnw> so the function can't return until it has that value
02:14:27 <TorosFanny> yes johnw
02:14:28 <johnw> what you could do is this
02:14:31 <johnw> return [m a]
02:14:38 <johnw> take 10 on that, and *then* sequence the result of take 10
02:14:42 <shachaf> That defeats the purpose.
02:14:46 <johnw> yes, it sort of does
02:15:00 <johnw> actually, it doesn't even work
02:15:07 <johnw> so never mind that I said that
02:15:18 <johnw> the action have to be bound together
02:15:28 <wuttf> saeidw I think its pretty awesome that haskell ideas are making to php
02:15:48 <TorosFanny> I have writen 3 version of the iterateM, all share the same problem
02:16:01 <johnw> yes, sequence has this same problem itself
02:16:05 <shachaf> TorosFanny: It is impossible to write iterateM in general that will do what you want.
02:16:05 <johnw> if given an infinite list
02:16:26 <shachaf> You can't have an IO action that generates a lazy list without special tricks that involve the word "unsafe".
02:16:44 <johnw> and as anyone will tell you, avoid anything beginning with unsafe like the plague
02:16:59 * johnw changes shachaf's nick to unsafeShachaf
02:17:12 <shachaf> If it doesn't type-check, stick "unsafe" on it until it does.
02:17:19 <TorosFanny> Sorry, I have writen 4 versions of iterateM, but the 4th one is of type :(Monad m) => (a -> Bool) -> (a -> m a) -> a -> m [a]
02:17:20 <johnw> ignore him
02:17:21 <shachaf> johnw: It won't help. I am beyond redemption.
02:17:27 <TorosFanny> and it works well
02:18:03 <johnw> iterateUntilM, I see no problem with that
02:18:48 <johnw> you avoid the infinitity problem by fusing a filter operation into your function
02:18:57 <johnw> which is how imperative languages have to express this same sort of thing
02:19:11 <johnw> (unless they get into iterators and such)
02:19:18 <shachaf> It's pretty awful how monadic things aren't compositional.
02:19:40 <johnw> yeah, I agree with you
02:19:47 <saeidw> Isn't the whole purpose of monads composability?
02:20:04 <johnw> >=> is better than writing all your code as CPS, I Guess
02:20:08 <shachaf> A different kind of composability. :-)
02:20:11 <TorosFanny> but the function to list directories in breadth-first order have to read all the contents and print the results
02:20:18 <saeidw> that is, the >>= operation is there to allow us to compose monadic value, or am I lost?
02:20:38 <TorosFanny> It is due to the strictness of iterateM
02:21:18 <johnw> iterateM has to be strict, it has no recourse
02:22:05 <TorosFanny> No way to make a lazy iterateM?
02:22:10 <johnw> no, there is no way
02:22:21 <johnw> because iterateM isn't building a list
02:22:44 <qnikst> can somebody help me with mutable vectors and fusion?
02:22:46 <johnw> under the hood, it's building a nested series of lambda functions
02:23:01 <hpaste> qnikst pasted “mutable vectors problem” at http://hpaste.org/81158
02:23:02 <HugoDaniel> hackage is slow :|
02:23:11 <johnw> @where hackage-luite
02:23:11 <lambdabot> I know nothing about hackage-luite.
02:23:15 <TorosFanny> where can I learn about the strictness of monad?
02:23:45 <johnw> TorosFanny: it's all in how >>= is implemented, if you study that in depth, you will discover why it must be strict
02:23:58 <srhb> Not sure I understand Floats completely. If I am given a float, say, via readLn, and I know how many decimals n it will have, when can I know if I get a precise Integer representation if multiply by 10^n and convert?
02:23:59 <johnw> take even a simple monad as your example case, like Identity
02:24:05 <srhb> Ever?
02:24:06 <qnikst> I'm having problems because ghc thinks I should use PrimState Id and not PrimState m
02:24:18 <qnikst> and it seems it's not a case
02:24:58 <johnw> srhb: floating point is an actual base 2 floating point number; the conversion to base 10 will always have issues, it's just a question of how accurate you need it to be
02:25:06 <shachaf> @hoogle PrimState
02:25:06 <lambdabot> No results found
02:25:14 <simpson> Did Hackage just go down again?
02:25:19 <shachaf> Yes.
02:25:38 <johnw> and the guys who can reboot it apparently aren't available until am PST
02:26:12 <simpson> Oh hey, you might know. Are mapAccumR and mapAccumL subject to the same general reasoning about strictness and thunks that foldr and foldl have?
02:26:27 <srhb> johnw: how about if I read each side of the decimal point and simply store both that and the denominator 10^n?
02:26:30 <simpson> IOW should I prefer mapAccumR if I don't care about direction?
02:26:33 <shachaf> simpson: No.
02:26:36 <srhb> As Integers.
02:26:38 <shachaf> If anything, prefer mapAccumL.
02:26:42 <shachaf> Unless I'm wrong.
02:26:49 <shachaf> @ty mapAccumL
02:26:51 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
02:26:51 <johnw> srhb: how about using Rationals until you need to render the value to a string?
02:27:07 <shachaf> > mapAccumL (\a x -> (a+x,x)) z [a,b,c,d,e]
02:27:08 <lambdabot>   (z + a + b + c + d + e,[a,b,c,d,e])
02:27:10 <johnw> the numbers gives a pretty faithful rendering at a specify decimal length
02:27:11 * typoclass grumbles about floats being counterintuitive and suble and sneaky little bastards. they're all too clever for their own good. it all needs moar Ratio
02:27:14 <shachaf> > mapAccum (\a x -> (a+x,x)) z [a,b,c,d,e]
02:27:16 <shachaf> > mapAccumR (\a x -> (a+x,x)) z [a,b,c,d,e]
02:27:16 <lambdabot>   Not in scope: `mapAccum'
02:27:16 <lambdabot>  Perhaps you meant one of these:
02:27:16 <lambdabot>    `IM.mapAccum' ...
02:27:17 <lambdabot>   (z + e + d + c + b + a,[a,b,c,d,e])
02:27:20 <typoclass> ... or Fixed
02:27:30 <johnw> numbers package, that is
02:27:30 <shachaf> @src mapAccumR
02:27:30 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:28:03 <shachaf> simpson: ɡ
02:28:06 <shachaf> Er.
02:28:09 <shachaf> simpson: ☝
02:28:30 <simpson> shachaf: Okay, so the difference really is all in the direction that the accumulation is done.
02:28:36 <simpson> Sweet. That makes things easier.
02:28:38 <simpson> Thanks!
02:28:47 <shachaf> I think mapAccumL is the one you should prefer.
02:29:01 <shachaf> Hmm, I might be wrong.
02:29:14 <shachaf> > mapAccumL (\a x -> (a+x,(show a,x))) z [a,b,c,d,e]
02:29:16 <lambdabot>   (z + a + b + c + d + e,[("z",a),("z + a",b),("z + a + b",c),("z + a + b + c...
02:29:21 <shachaf> > mapAccumR (\a x -> (a+x,(show a,x))) z [a,b,c,d,e]
02:29:22 <lambdabot>   (z + e + d + c + b + a,[("z + e + d + c + b",a),("z + e + d + c",b),("z + e...
02:29:30 <shachaf> I think I'm not wrong.
02:30:18 <TorosFanny> what makes me confused is in "iterateM (return.(+1)) 0 >>= return.(take 10)" how Ghci know the exect type of return? It is a polymorphic
02:30:42 <shachaf> TorosFanny: It probably defaults to IO.
02:30:44 <shachaf> ghci quirk.
02:30:45 <srhb> johnw: Somehow I did not know about rational, thanks.
02:30:54 <TorosFanny> make be that
02:31:10 <TorosFanny> just like 1+2 = 3 and that's integer
02:32:19 <hpaste> johnw pasted “mapAccumL/R.hs” at http://hpaste.org/81159
02:32:23 <johnw> shachaf: those definitions are sooo close
02:32:39 <johnw> just swapping a pair of '
02:33:14 <typoclass> srhb: i think Rational and Fixed are both way more predictable. Float bites you in the behinditudes, unless you're an expert on all the tons of stuff discussed on http://en.wikipedia.org/wiki/IEEE_floating_point
02:33:18 <johnw> since the final result is a (acc, [y]), is the [y] lazy if I don't evaluate the acc?
02:33:26 <shachaf> johnw: Yes, I saw.
02:33:35 <shachaf> johnw: Try it!
02:33:39 <johnw> will do!
02:34:12 <typoclass> hm, i think this was the page i was thinking of http://en.wikipedia.org/wiki/Floating_point
02:34:20 <shachaf> > length . snd $ mapAccumL undefined undefined "hello"
02:34:21 <lambdabot>   5
02:34:34 <shachaf> At least the spine is OK. :-)
02:34:34 <johnw> haha, it's lazy!
02:34:38 <johnw> > take 10 $ snd $ mapAccumR (\acc x -> (acc + 1, x)) 0 [1..]
02:34:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
02:34:55 <johnw> > fst $ mapAccumR (\acc x -> (acc + 1, x)) 0 [1..]
02:34:57 <lambdabot>   *Exception: stack overflow
02:35:03 <johnw> that's pretty cool
02:35:20 <shachaf> Easy version (recommended): Try it.
02:35:21 <shachaf> Advanced version: Figure it out without trying it.
02:35:41 <johnw> ooh, padawan task, jedi task
02:35:50 <shachaf> Not a version: Ask shachaf (because how would he know? He doesn't really know that many things.).
02:35:56 <johnw> Super advanced: know without trying
02:36:05 <shachaf> No, that's also not a version.
02:36:07 <shachaf> That's just caching.
02:36:10 <johnw> lol
02:36:15 <Henryk> Hey :)
02:36:20 <johnw> well, all the tuples made me think it was lazy
02:36:29 <Henryk> I have a question..
02:36:30 <lambdabot> hey Henryk
02:36:38 <Henryk> hey :p
02:36:40 <shachaf> Henryk: You should ask it!
02:36:44 <absence> is hackage down?
02:36:47 <johnw> because unless I look at the accumalator, the algorithm itself never forces the evaluation of the accumulator
02:36:50 <arbn> absence: Yes.
02:37:07 <typoclass> @where hackage-mirror
02:37:07 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
02:37:10 <johnw> it just passes it around
02:37:17 <typoclass> absence: ^^ may or may not help
02:37:27 <absence> typoclass: thanks :) can i get cabal to use it?
02:37:33 <Henryk> Its about i have patterns in haskell and for so one like this:
02:37:34 <Henryk> data Nat = O | S Nat deriving Show  add :: Nat ->  Nat -> Nat  add O y      = y add (S x) y  = S ( add x y )
02:37:52 <Henryk> And i wanted to do this for division but i dont know how to..
02:38:02 <shachaf> Division is advanced.
02:38:09 <shachaf> Have you tried doing multiplication and subtraction first?
02:38:17 <typoclass> absence: i think you need to take the line that lambdabot said and put it in ~/.cabal/config or some such. not really sure =)
02:38:45 <shachaf> absence: Or see the instructions at http://hdiff.luite.com/
02:38:47 <johnw> typoclass: that is correct
02:39:02 <typoclass> johnw: thanks for checking
02:39:06 <Henryk> yes i have substraction and multiplikation..
02:39:14 <Henryk> but still dont know how to do division..
02:39:26 <shachaf> Henryk: OK, then think of division as repeated subtraction.
02:39:42 <johnw> Henryk: http://cs.calstatela.edu/wiki/index.php/Courses/CS_332L/Peano_arithmetic#Division
02:39:57 <johnw> it's just what shachaf said
02:39:59 <johnw> with some examples
02:40:05 <Henryk> Thank you! :*
02:40:08 <Henryk> :)
02:40:10 <shachaf> You could read spoilers if you wanted.
02:40:15 <johnw> padawan
02:40:39 * johnw tries to get shachaf to see padawans everywhere, unless someone asks for their brain to hurt
02:40:40 <shachaf> Oh, those are Prolog spoilers.
02:41:26 <shachaf> johnw: If someone wants spoilers, they can find them themselves easily enough. What I can provide that Google can't yet is dialogue.
02:41:40 <johnw> that is true
02:42:16 <johnw> although, sometimes peolpe do just want the answer; it's possible he just didn't know what to google for
02:42:23 <b_jonas> I have division implemented in www.math.bme.hu/~ambrus/pu/Bin.hs but it's a bit ugly
02:42:33 <johnw> although, anyone implementing PA in Haskell is probably doing it to learn
02:43:17 <johnw> is Peano pronounced like Piano?
02:43:19 <b_jonas> this one is not PA, it's binary
02:43:27 <aristid> johnw: fold something into shortcircuit?
02:43:28 <yitz> divNat x y = integerToNat $ (div `on` natToInteger) x y
02:43:32 <arbn> johnw: Unless you speak whatever language "Peano" is from.
02:43:39 <johnw> oh
02:44:00 <aristid> johnw: just send me a pull request, i don't really use shortcircuit much anymore tbh because i feel i can't justify adding such a tiny dependency to projects
02:44:06 <arbn> Wasn't implementing division with PA an exercise in SICP? It sounds very familiar.
02:44:11 <Henryk> Hmm
02:44:15 <johnw> aristid: I have nothing to send you anymore
02:44:25 <aristid> johnw: what happened?
02:44:27 <typoclass> johnw: but it sounds more impressive if you make up some foreign-sounding pronunciation. people will think "wow that guy knows stuff"
02:44:29 <typoclass> =)
02:44:42 <johnw> shachaf and edwardk melted it away, it was an ice sculpture that could not bear the fierce heat of code review
02:44:52 <johnw> as, it's italian
02:44:58 <johnw> so not quite "Piano"
02:45:04 <johnw> more "peyANo"
02:45:05 <shachaf> johnw: The Internet is a bad place to ask about pronunciations.
02:45:11 <shachaf> Everyone makes up their own anyway.
02:45:12 <aristid> haha i just noticed i've been using the computer for 10 minutes without noticing the mouse was turned off
02:45:23 <Henryk> How do i say haskell that it should do minus (S x) (S y)  so many times that it fits?
02:45:41 <Henryk> for division
02:45:50 <shachaf> The same was you defined minus itself.
02:45:50 <aristid> johnw: may i know what it was anyways?
02:46:11 <aristid> shachaf: i love pronunciation, it is so easy :P
02:46:30 <shachaf> i love aristid. he is so predictable
02:46:31 <Henryk> Just minus x y or what?
02:46:33 <bxc> heh i've always pronounced peano as peeeeno, and then someone was talking to me about piano-arithmetic the other day and it took me day sto figure out wtf.
02:46:37 <absence> typoclass: that did the trick, thanks!
02:46:39 <aristid> shachaf: <3
02:46:49 <typoclass> absence: you're welcome
02:46:55 <bxc> doing a parser talk in London this evening if anyone is interested
02:46:58 <Henryk> shachaf: Just minus x y or what?
02:47:10 <aristid> shachaf: predictability is good, right?! it increases the performance of the branch predictor, i bet
02:47:11 <shachaf> Henryk: I don't know.
02:47:20 <shachaf> aristid is a branch?
02:47:24 <Henryk> Haha i will just do it but thanks:P
02:47:27 <johnw> aristid: it was a pair of monoids to represent short-circuiting, value-yielding And/Or, built on top of Either.  It turns out you get that exact behavior from the Applicative instance for Either via *>. :)
02:47:31 <aristid> shachaf: sure
02:48:05 <aristid> the whole house smells like garlic *important announcement*
02:48:19 <johnw> aristid: raw or cooked
02:48:26 <yitz> aristid: ok then. how do you pronounce "eyafjallajökull", the name of the volcano in iceland that erupted a while back?
02:48:33 <aristid> johnw: not sure, probably raw
02:48:45 <aristid> yitz: eyafjallajökull
02:48:58 <yitz> aristid: wrong. unless you're from iceland.
02:49:23 <aristid> yitz: i pronounce it germanely. or was it germanly?
02:49:31 <typoclass> yitz: just ask the inventor of the name http://theoatmeal.com/comics/volcano_name
02:50:29 <aristid> typoclass: he forgot the all-important umlaut.
02:50:29 <yitz> typoclass: :)
02:50:40 <typoclass> yitz: (according to him, it's pronounced 'meow')
02:51:16 <Doikor> hmmh it seems i pronounce it correctly except for that one T that isnt typed there.
02:51:26 <pettter> mëow
02:51:30 <yitz> Doikor: there are two T's not typed
02:51:47 <Doikor> yeah well i kinda got the second one from seeing some other icelandic names before
02:52:19 <yitz> Doikor: or you can use the sample pronounciation sound file in the wikipedia article, where the person just basically grunts
02:52:37 <Doikor> (been playing eve online with icelandic ppl for years)
02:53:12 <Doikor> im finnish so its mostly just saying what it reads. except add those t's
02:54:09 <yitz> Doikor: oh i though finnish was far different than any of the scandinavian languages
02:54:39 <yitz> *thought
02:55:02 <basdirks> it is
02:55:06 <Doikor> yeaeh it is.
02:55:31 <basdirks> but Finns usually speak Swedish
02:55:39 <Doikor> well umm not really ;)
02:56:02 <shachaf> Half of #haskell is Finnish.
02:56:12 <basdirks> and the other half Dutch
02:56:32 <bxc> is there a lot of haskell in finland?
02:56:39 <liyang> I know about the mirrors, hence oh noes. D:
02:56:40 <shachaf> There's a lot of IRC in Finland.
02:56:45 <bxc> heh
02:56:47 <Doikor> http://www.omniglot.com/writing/icelandic.htm but if you look at how they pronounce letters in icelandic.
02:57:08 <liyang> Because there's nothing else to do in Finland. :(
02:57:15 <yitz> bxc: see http://haskellers.com
02:57:52 <Doikor> mostly just irc being quite popular in finland. hell the guy who invented it is finnish too ;)
02:57:53 <t7> uk is the haskell capital of the universe :O
02:58:52 <bxc> not sure if that blob ove rhte UK is uk only
02:59:06 <Henryk> I'm german
02:59:40 <yitz> i see there are still some penguin haskellers and pirate haskellers
03:00:19 <yitz> penguin haskellers are american haskellers who reversed their lattitude and longitude and wound up in antarctica
03:00:39 <yitz> europeans who do that end up just off the coast of somalia, they are pirate haskellers
03:02:56 <typoclass> the well-known "ugh i mixed up the two numbers again" method of navigation
03:08:11 <Spockz> kosmikus: If I want line numbers, should I still use https://github.com/kosmikus/lhs2tex/blob/master/ExtLibrary/lineno/lineno.fmt? Because just using %include lineno.fmt tells me that lineno.fmt couldn't be found in the default search path
03:13:08 <herr_flupke> hi
03:13:18 <johnw> hi!
04:27:42 <qnikst> is it possible to mstream mutable vector?
04:42:41 <AfC> Is there a class that is a ByteString equivalent of Show? Doesn't have to be, and I can just write a function that returns a ByteString, but if there's an idiomatic name of typeclass floating around I'd use that.
04:42:57 <shachaf> What would it do?
04:43:19 <shachaf> For example what would show 12 give you?
04:44:14 <AfC> shachaf: no, I mean a function with a different name and :: ByteString instead of show :: String
04:44:20 <mauke> pack [12]
04:44:41 <mauke> AfC: that doesn't answer shachaf's question
04:45:18 <AfC> mauke: ok, thing 12 :: ByteString = S.pack "12"
04:45:29 <mauke> that's a type error
04:45:33 <mauke> pack takes [Word8]
04:46:22 <AfC> so, fine, yes, import qualified Data.ByteString.Char8 as S
04:46:31 <Peaker> Data.ByteString.UTF8 maybe has a "show" like function?
04:46:31 <mauke> :-(
04:46:39 <shachaf> AfC: Data.ByteString.Char8 is evil.
04:46:40 <AfC> I don't think we need to get hung up on pedantry
04:46:41 <shachaf> Please don't use it.
04:46:46 <AfC> Peaker: does it?
04:46:48 <mauke> AfC: can we get hung up on evil?
04:47:00 <shachaf> This isn't pedantry, it's a matter of not writing broken software.
04:47:13 <mauke> shachaf: that counts as pedantry
04:47:18 <Peaker> AfC, don't know, but whenever you're thinking of using Char8 and focusing on a US-specific audience, try to consider others and use UTF8 instead?
04:47:41 <shachaf> AfC: Asking for Text and/or Data.ByteString.UTF8 is much more reasonable.
04:47:56 <shachaf> Those types represent text, like String does. Data.ByteString is only for representing sequences of bytes.
04:48:04 <Peaker> AfC, well, you could always use "Data.ByteString.UTF8.fromString . show"
04:48:13 <AfC> shachaf: I speak languages other than English. Well aware.
04:48:33 <AfC> Peaker: I'm trying to avoid serializing out to String
04:48:34 <shachaf> Your awareness doesn't do any good if you don't use it.
04:48:47 <AfC> Peaker: the show instances are costing me 10-20% of the allocation
04:49:06 <AfC> Peaker: obviously a real app would use a more specific function, but for a simple introductory example,
04:49:25 <AfC> my question was "is there something accepted & idiomatic that is like show but not :: String"
04:49:39 <donri> why do you care about performance for an introductory example
04:49:46 <mauke> wasn't cereal like that?
04:50:00 <AfC> donri: because I don't want people freaking out at me that I've got show in an example
04:50:26 <donri> AfC: maybe look at text-format's buildable class, but it's different from show for string-like types
04:50:28 <AfC> BUT everyone knows what you mean when you say "putStr $ show x"
04:50:44 <donri> doesn't add quotes etc
04:50:54 <shachaf> AfC: Data.ByteString.Lazy.Builder.ASCII might do what you want.
04:51:31 <shachaf> But I maintain that you most likely shouldn't want it, certainly not for an introductory example.
04:51:42 <AfC> fine. I'll just leave the show in, then
04:51:44 <donri> is hackage down again
04:51:49 <shachaf> @where hackage-mirror
04:51:49 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
04:52:00 <shachaf> ...OK, you can leave the show in if you want to?
04:52:05 <donri> i was looking for haddocks :p
04:52:06 <AfC> yes.
04:52:16 <shachaf> That works too.
04:52:24 <shachaf> OK, as an alternative answer:
04:52:27 <AfC> shachaf: what I was looking for was a recommendation of something "better" to use if there was such a thing
04:52:40 <AfC> and if there isn't, fine
04:52:40 <shachaf> deriving (Show), the GHC magic that generates nice pretty-printers, is String-specific.
04:52:55 <shachaf> So you won't get anything else that just automatically uses the Show class, without going through String.
04:53:02 <Henryk> Hey how do i add everything in a list of integers to a final integer?
04:53:13 <AfC> right. Which is why I asked if there was a better/newer/whatever class than Show
04:53:18 <AfC> for "this sort of thing"
04:53:41 <AfC> Henryk: foldr
04:53:43 <shachaf> I mentioned you an alternative for showing some specific things above.
04:53:51 <Henryk> how do i add everything in alist to a sum/amount ?
04:54:06 <shachaf> It's more likely that you want foldl' than foldr.
04:54:07 <Henryk> i have a list with the type integers and want the sum of all elements in the list
04:54:10 <AfC> I'll just publish a function. asByteString or something. Kinda cumbersome name, though.
04:54:17 <probie> Henryk: foldl' (+)
04:54:18 <shachaf> Also, it seems even more likely that you want sum.
04:54:32 <shachaf> AfC: It's unfortunate.
04:54:52 <AfC> hence my search for something standard, if such
04:54:56 <donri> didn't i see some generics for show-to-text, hm
04:55:27 <shachaf> mauke: Did you change your stance on .Char8?
04:55:42 <shachaf> You used to be more supportive of it, I thought.
04:55:56 <probie> I can't get to hackage... is anyone else having problems with it?
04:56:02 <mauke> shachaf: I am multistanced
04:56:05 <johnw> yes, it is down
04:56:22 <johnw> lambdabot should just check the status of hackage anytime someone mentions it :)
04:56:25 <shachaf> mauke: Fancy.
04:57:03 <AfC> asBytes? toString? pack seems rather collision-worthy already
04:57:47 <donri> showBS
04:58:04 <donri> *BS is a convention
04:58:28 <johnw> there's also the 'stringable' package, it gives you "toString" and "fromString" for the 5 basic string types, with a UTF-8 bias
04:59:40 <AfC> stringable. Hm
05:00:02 <johnw> written mainly because i was tired of remembering how to convert from X to Y for every combination of string types; otherwise, it's nothing special
05:00:16 <AfC> johnw: sounds like just the thing
05:00:36 <shachaf> Ugh.
05:00:43 * shachaf goes to sleep.
05:00:51 <fmap> Stringing s t a b
05:00:58 <johnw> haha
05:01:07 <johnw> insider lens jokes, i love it
05:01:30 <donri> isn't there a convertible package that does that too
05:01:35 <johnw> yes, convertible-text
05:01:53 <donri> oh not in the core package?
05:02:00 <donri> yay orphans
05:02:01 <johnw> snoyberg just said I could take over maintainership of it yesterday; I intend to merge the two
05:02:10 <johnw> mostly in favor of the pre-existing one
05:04:56 <AfC> So 'toByteString' looks like the function name I should go with
05:05:06 <AfC> so be it
05:05:22 <probie> As hackage is down, can someone tell me what complexity getting the first element of Data.Sequence.Seq is, and what complexity getting the last element of Data.Sequence.Seq?
05:05:33 <johnw> Seq is a finger tree
05:05:36 <johnw> so O(1) on both
05:06:41 <AfC> johnw: I think you can get a Builder instance in for Stringable, looking at it now
05:06:57 <johnw> AfC: I think that's how convertible works
05:07:01 <johnw> you may want to check out convertible-text
05:07:17 * AfC sees if it's already installed
05:10:48 <mSSM> Is there a nicer way of expressing the following? `foldl (\(a,b) -> ( a + fst acc , b + snd acc ) ) (0,0) xs'
05:11:05 <mSSM> where xs :: [(Int,Int)]
05:11:12 <mauke> acc undeclared
05:11:32 <applicative> foldl op (0,0) where ...
05:11:37 <mauke> :t unzip
05:11:39 <lambdabot> [(a, b)] -> ([a], [b])
05:11:48 <mauke> :t join (***) sum . unzip
05:11:50 <lambdabot> Num c => [(c, c)] -> (c, c)
05:11:54 <akamaus> hello, is there a way to rebuild a packages and it's dependencies with a profile flag?
05:12:18 <mSSM> mauke: Sorry, I always mess that one up.
05:12:28 <applicative> akamaus: you mean, something you installed via cabal install from hackage
05:12:47 <akamaus> applicative, yeah
05:12:52 <shachaf> mauke: Hmm, that may have worse strictness behavior with large lists?
05:13:02 <applicative> akamaus: if that, then probably you should change the preferences in your ~/.cabal/conf
05:13:05 <applicative> config
05:13:26 <mSSM> mauke: that explains it to  me ...: `foldl (\(a1,a2) (b1,b2) -> ( a1+b1 , b2+b2)) (0,0) xs'
05:13:52 <shachaf> mSSM: Yes. But you should use foldl', not foldl.
05:13:57 <akamaus> applicative, oh, thanks! will tweak it. But what to do next? should I remove ~/.ghc and start from scratch?
05:13:58 <mSSM> Strict fold?
05:14:05 <shachaf> And it seems to me like you'll want to add a strictness annotation.
05:14:08 <applicative> akamaus: uncomment the library-profiling: True
05:14:13 <johnw> shachaf: thought you were sleeping
05:14:14 <mSSM> shachaf: isn't foldl' strict?
05:14:15 <shachaf> But see for yourself how it behaves on large lists.
05:14:16 <AfC> johnw: am I reading this right? The function is 'convertSuccess'? Oh. 'cs' and 'ca'. Weird.
05:14:18 <johnw> did your 30 seconds end?
05:14:18 <shachaf> johnw: I am.
05:14:27 <shachaf> mSSM: Yes, strict in the accumulator. But that may not be enough.
05:14:34 <johnw> AfC: I think you want just 'convert' from that library
05:14:51 <johnw> you need strictness in the tuple members
05:15:00 <johnw> seq x $ seq y $ ...
05:15:12 <akamaus> applicative, I  will. But right now I have tons of libraries built without profiling. I need to do something with it.
05:15:31 <mSSM> Yay, strictness again: the tuple members in `xs' are supposed to come from a stateful computation.
05:15:41 <mauke> :t foldl' (\(!a1,!a2) (!b1,!b2) -> ( a1+b1 , b2+b2)) (0,0)
05:15:42 <lambdabot> (Num t1, Num t) => [(t, t1)] -> (t, t1)
05:16:05 <mSSM> I.e. `evalState (replicate n myStatefulComp) myState'
05:16:28 <mSSM> So I want to `foldl' (\ .. -> .. ) (0,0) $ evalState ...
05:17:17 <AfC> johnw: a) doesn't appear to be a bare convert :: in convertible-0.4.0.2, and b) it's marked deprecated.
05:17:24 <johnw> shachaf: how come there's no Profunctor instance for (,)?
05:17:27 <mSSM> Will the compiler be smart enough to start folding right away, or will it wait until `evalState' finally spit out the [ result ] ?
05:17:32 <applicative> akamaus: somehow I think reasoning about this will be harder than starting over, but thats just my dubious experience
05:17:36 <`nand`> johnw: how would lmap work?
05:17:41 <`nand`> lmap :: (a -> b) -> (b, c) -> (a, c)
05:17:43 <johnw> AfC: yeah, I'm going to revive it, and fold in Stringable
05:18:04 <shachaf> johnw: Write it out and edwardk will commit it.
05:18:08 <shachaf> johnw: But no unsafeCoerce!
05:18:10 <AfC> convert would be good :)
05:18:14 <johnw> lmap f (x,y) = (f x, y)
05:18:20 <johnw> oh, hmm
05:18:22 <johnw> wrong direction
05:18:31 <`nand`> profunctors are contravariant in their left argument
05:18:46 <`nand`> (,) is a perfectly fine Bifunctor, though
05:19:05 <`nand`> in fact it has the appropriate instance
05:19:51 <johnw> ah
05:19:54 <johnw> that's what I wanted anyway
05:20:53 <mSSM> mauke: Can you explain how `join (***) sum . unzip' works? I used to write `( (***) sum sum) . unzip'
05:21:08 <lzm> is hackage.haskell.org down for everyone else?
05:21:28 <mauke> > join f x :: Expr
05:21:30 <lambdabot>   f x x
05:21:52 <Peaker> join :: m (m a) -> m a    ; m = (r->) leads to:   join  :: (r -> r -> a) -> r -> a
05:21:56 <fragamus> seems to ne down
05:22:03 <fragamus> *be
05:22:05 <Ayey> @lzm Yeah for me aswell
05:22:05 <lambdabot>   TemplateHaskell is not enabled
05:22:14 <Peaker> mSSM, the only way to give the "r" twice after getting it once is to duplicate it
05:22:15 <mSSM> lzm: I always try http://www.downforeveryoneorjustme.com/ which is cool if nobody answers. :0
05:22:36 <Peaker> mSSM, and btw: (***) sum sum = sum *** sum
05:22:45 <applicative> join takes you from an (a -> (a -> b)) to a mere (a -> b) if (a ->) is a monad
05:24:00 <mSSM> applicative: so in our case, the `m' in `m (m a)' is an arrow?
05:24:30 <Kallikanzarid> guys check it out
05:24:31 <Kallikanzarid> https://github.com/Kallikanzarid/synth
05:24:49 <Kallikanzarid> a small project of mine :)
05:25:24 <Kallikanzarid> the idea is to make a full-blown synthesizer library
05:25:34 <`nand`> as in, sound?
05:25:37 <johnw> mSSM: m is (a ->), not an arrow
05:25:44 <Kallikanzarid> `nand`, yes
05:26:00 <Kallikanzarid> you can try it if you have linux
05:26:34 <mauke> -> is an arrow
05:26:41 <mSSM> johnw: so in the case `join (***) sum', I could write `(join (***)) sum', right?
05:26:47 <applicative> lzm you can try swapping out remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive with the existing line in cabal/config
05:26:49 <`nand`> lines 58-64 look like they can be refatored
05:26:50 <johnw> mauke: ?  a -> b is an arrow
05:26:56 <`nand`> factored, even
05:27:04 <mauke> johnw: I don't think so
05:27:07 <mSSM> johnw: i.e., join acts on (***) ?
05:27:18 <mauke> mSSM: you can always write 'x y z' as '(x y) z'
05:27:22 <johnw> mSSM: you can write (join ***) sum'
05:27:46 <mauke> heh
05:27:47 <mSSM> yeah, right; redundant brackets
05:27:53 <johnw> mauke: (a ->) is a functor awaiting a type argument
05:27:54 <lzm> applicative: i just wanted to look at the documentation for a package
05:27:55 <mauke> johnw: I don't think so
05:28:00 <johnw> it's not just redundant
05:28:06 <johnw> (join (***)) is a syntax error
05:28:09 <mauke> johnw: I don't think so
05:28:16 <applicative> mSSM: sorry didn't see, yes (m (m b)) here takes the form (a->(a->b), as join for lists makes a [[a]] into an [a] - ie. it's concat
05:28:18 <`nand`> Kallikanzarid: it might be interesting to wrap Signal inside a newtype instead and then provide a Num instance, so you can just write eg. “3 * sig” instead of “3 `boost` sig”, or “a + b” instead of “mix [(1,a),(1,b)]”
05:28:37 <mauke> johnw: at this point my conclusion is that you're wrong about everything
05:28:42 <applicative> lzm: yes, I was going to say, won't help if your uploading or looking for documentation.
05:28:46 <johnw> mauke: excuse me?
05:29:01 <mauke> EVERYTHING
05:29:03 <`nand`> a -> b isn't an arrow, and join (***) isn't a syntax error
05:29:09 <applicative> lzm, if you installed it already, you should be able to do cabal unpack xyz to inspect the source, which is compressed somewhere
05:29:17 <`nand`> (a ->), on the other hand, /is/ a syntax error
05:29:21 <mauke> `nand`: and you can't write join (***) sum as (join ***) sum
05:29:27 <`nand`> but ((->) a) isn't exactly clearer
05:29:50 <johnw> huh, I thought it was a syntax error
05:29:57 <Kallikanzarid> `nand`, a good idea! 8)
05:30:00 <johnw> `nand`: why is it not an arrow?  because of the polymorphic types?
05:30:07 <`nand`> wrong kind, for starters
05:30:09 <`nand`> a -> b :: *
05:30:12 <mSSM> applicative: What I don't yet see is how join in `join (***) sum' makes this into `(***) sum sum'
05:30:13 <`nand`> an Arrow has kind (* -> * -> *)
05:30:24 <johnw> i was talking about a category theoretic arrow
05:30:24 <applicative> > join (+) 1
05:30:25 <fmap> @ty join `asAppliedTo` (***) `asAppliedTo` (undefined :: a -> (b -> c) -> d)
05:30:26 <lambdabot>   2
05:30:26 <lambdabot> ((b -> c) -> (b -> c) -> (b, b) -> (c, c)) -> (b -> c) -> (b, b) -> (c, c)
05:30:27 <johnw> not an Arrow arrow
05:30:29 <`nand`> or (k -> k -> *)
05:30:32 <`nand`> johnw: ah
05:30:38 <mauke> mSSM: because that's what join does: it duplicates function args
05:30:40 <applicative> > join (++) "hi mSSM"
05:30:43 <lambdabot>   "hi mSSMhi mSSM"
05:30:54 <johnw> ahhh
05:30:59 <johnw> join takes a function, silly me
05:31:06 <int-e> mSSM: the monad in question is the reader moonad (r ->); m a = r -> a; m (m a) = r -> r -> a
05:31:06 <`nand`> join takes an m (m a)
05:31:26 <applicative> mSSM:  its just that join (***) sum is one step higher order than join (+) 1
05:31:27 <johnw> i mean, (join (***)) is passing (***) to join
05:31:36 <Eelis> and this is exactly why writing the lambda explicitly is better for readability :P
05:31:42 <applicative> mSSM: it's clearer if you think of it as a macro !
05:31:53 <elliott> The most readable way to write (join (***)) is (over both).
05:32:00 <mSSM> Haskell confusion setting in again.
05:32:00 <int-e> mSSM: it's clearer once you understand it ;)
05:32:05 <`nand`> johnw: the mix-up was probably that (***) is an Arrow method, which gave a false contextual interpretation to “a -> b is an arrow”
05:32:12 <johnw> mSSM: sorry to add to it
05:32:43 <`nand`> elliott: agreed
05:32:49 <ctc> is it true that every instance of Data.Data is an instance of Data.Traversable?
05:32:50 <mSSM> int-e: ok, and applying `join (r -> r -> a)' gives me (r -> a)
05:33:01 <`nand`> ctc: do you mean Data.Data.Data?
05:33:03 <mSSM> int-e: that's ok, but how is the argument doubled now?
05:33:13 <ctc> `nand`: yes
05:33:15 <`nand`> ctc: and no, that's false
05:33:18 <mSSM> johnw: it's ok, at least someone is trying to help me :D
05:33:34 <Peaker> @djinn (r -> r -> a) -> r -> a
05:33:34 <lambdabot> f a b = a b b
05:33:39 <`nand`> wrong kind for starters, Traversable requires (* -> *); while Data requires *
05:33:49 <applicative> DeriveTraversable suggests there is some law in there though, no? `nand`
05:34:00 <Peaker> mSSM, that type tells you how the arg is doubled, there's no other non-bottom implementation
05:34:16 <int-e> mSSM: hmm, two ways. one, there is only one reasonable function of that type (see @djinn output), two, look how bind is defined for the reader monad (the r value gets passed to every single monad action), and unfold the bind.
05:34:17 <`nand`> I think it's a case of Data.Data.Data defining traversals over structures, or something
05:34:32 <`nand`> applicative: so deriving Traversable for some type T probably gives rise to a Data a => Data (T a) instance
05:34:33 <int-e> err, unfold the join.
05:34:43 <applicative> that's what I thought ctc was asking about though
05:34:51 <`nand`> oh, that could be
05:35:06 <CorkExaminer> yes hackage is down
05:35:21 <ctc> is it possible to define geq by Traversable?
05:35:25 <int-e> join f = f >>= id =[for reader]= \r -> id (f r) r = \r -> f r r
05:35:57 <`nand`> what exactly does geq do?
05:37:14 <mSSM> int-e: sorry, that =[for reader]= is supposed to be just `=' ?
05:37:25 <`nand`> looks like it, but only for reader
05:37:30 <ctc> `nand`: generic equality test
05:37:40 <mSSM> so, join f is defined as `f >>= id' ?
05:37:46 <int-e> @src join
05:37:46 <lambdabot> join x =  x >>= id
05:37:51 <mSSM> aha
05:38:21 <int-e> mSSM: yes, it was equality, but for a particular monad (i.e. type)
05:39:34 <mSSM> int-e: where can I look up the definition of (>>=) for reader?
05:39:42 <int-e> > join [[3,2],[4]]
05:39:43 <lambdabot>   [3,2,4]
05:40:03 <applicative> > join (Just Nothing)
05:40:05 <lambdabot>   Nothing
05:40:13 <killy9999> mSSM: currently nowhere because Hackage is down :)
05:40:20 <johnw> > join (Just (Just (Just 3)))
05:40:22 <lambdabot>   Just (Just 3)
05:40:25 <yitz> mSSM: never mind looking it up. try writing it yourself - you may find it easier than you think once you get started
05:40:31 <killy9999> but generaly use Hoogle to find stuff on hackage
05:40:50 <applicative> mSSM: it will be easier to write it yourself as yitz says
05:40:57 <int-e> mSSM: it's defined in Control.Monad.Instances (hoogle can probably tell you), so e.g. http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/Control-Monad-Instances.html
05:41:12 <int-e> but yitz's advice is good.
05:41:24 <mSSM> I will need to read more about the reader monad.
05:41:43 <CorkExaminer> maybe lamdabot could just say "Caution! Caution! There is no Hackage." in tribute to the lost in space robot
05:41:59 <applicative> bind :: (r -> a) -> (a -> (r -> b)) -> (r -> b) -- isn't that the signature
05:42:00 <yitz> mSSM: that's ok, but even before that, just look at the type of >>= for the reader monad and write it!
05:42:04 <CorkExaminer> whenever hackage goes down
05:42:12 <applicative> mSSM: ^^^
05:42:54 <applicative> bind r2a a2'r2b r = ???
05:43:30 <int-e> applicative: you're missing a c3po in there, and r2d2 got messed up a littl.
05:43:41 <applicative> oh am i
05:44:22 <int-e> not really, but I still don't like these names :)
05:44:56 <applicative> @type let bind r2a a2'r2b r = a2'r2b (r2a r) in bind -- admittedly hideous
05:44:58 <lambdabot> (t2 -> t1) -> (t1 -> t) -> t2 -> t
05:45:03 <applicative> no
05:45:19 * applicative should leave the arrows to int-e 
05:45:45 <applicative> @type let bind r2a a2'r2b r = a2'r2b (r2a r) r in bind -- admittedly hideous
05:45:46 <lambdabot> (t2 -> t1) -> (t1 -> t2 -> t) -> t2 -> t
05:45:51 <applicative> ta daaaa
05:46:54 * applicative needs a continuous intravenous feed from his typechecker to maintain rationality
05:47:37 <elliott> @tell cmccann releasing that linear logic stuff without telling me! :(
05:47:37 <lambdabot> Consider it noted.
05:47:40 <fmap> @ty (>>=) `asAppliedTo` Unsafe.Coerce.unsafeCoerce
05:47:41 <elliott> @tell cmccann it looks very cool
05:47:41 <lambdabot> (a1 -> a) -> (a -> a1 -> b) -> a1 -> b
05:47:41 <lambdabot> Consider it noted.
05:50:07 <fmap> @ty (>>=) `asAppliedTo` (undefined :: c -> d)
05:50:08 <lambdabot> (c -> a) -> (a -> c -> b) -> c -> b
05:50:13 <fmap> much better
05:57:15 <applicative> haskell is clearly making immense real world strides: Success story: novice haskeller moves console cursor with “netwire” FRP library
05:58:38 <applicative> "Dealing with console keyboard is not a hard task for a man, who wrote console tetris."
05:59:43 <applicative> http://danbst.wordpress.com/2013/01/23/novice-netwire-user/ -- this is the true Haskell esprit
06:00:33 <applicative> 'I just figure out StateT and monad transformers 2 weeks ago; before that I lived without state for six months"
06:06:37 <applicative> @tell mm_freak_ its nice to see netwire has a proper tutorial now :)
06:06:37 <lambdabot> Consider it noted.
06:10:21 <eddayyy> hackage been down for last 2 hours :(
06:11:13 <eddayyy> anyone know if it is likely to be fixed today?
06:11:22 <applicative> eddayyy: what do you need from it? there are alternatives, sort of
06:11:44 <eddayyy> applicative: there are?
06:11:54 <johnw> @where hackage-mirror
06:11:54 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
06:11:56 <eddayyy> applicative: I need to download a bunch of deps, update stuff etc
06:12:33 <eddayyy> applicative: can you use cabal with this?
06:13:39 <mysticc> @src foldM
06:13:39 <lambdabot> foldM _ a []     = return a
06:13:39 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
06:14:22 <johnw> eddayyy: yes, that's really what it's for
06:14:39 <johnw> add that "remote-repo..." line to your ~/.cabal/config, and comment out the one that points to hackage
06:14:41 <johnw> then cabal update
06:15:01 <eddayyy> johnw: sweet thank you for saving my day
06:15:05 <applicative> then remember to change back ...
06:15:07 <johnw> thank luite!
06:15:08 <eddayyy> @applicative as well
06:15:08 <lambdabot> Unknown command, try @list
06:15:19 <johnw> the only thing you can't do with that mirror is upload to it :)
06:15:49 <eddayyy> johnw, applicative, luite: perfect, thank you for the mirror!
06:16:44 --- mode: ChanServ set +o johnw
06:16:46 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.1 http://v.gd/CEBRVo ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com"]' by johnw
06:16:49 --- mode: johnw set -o johnw
06:18:41 <donri> johnw: need space before quote
06:19:02 <johnw> ah, ok
06:19:05 --- mode: ChanServ set +o johnw
06:19:09 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.1 http://v.gd/CEBRVo ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]' by johnw
06:19:13 --- mode: johnw set -o johnw
06:19:18 <mSSM> What do Arrows and the Reader monad have to do with each other.
06:19:39 <mSSM> s/\./\?/
06:19:46 <johnw> mSSM: the most basic definition for both looks like a function, but they are extremely different things
06:20:16 <mikeplus64> mSSM: Reader is a -> b, and an Arrow is a `some_arrow` b
06:20:43 <johnw> the (->) instance for Arrow is a -> b
06:20:43 <mikeplus64> (where some_arrow is commonly ->)
06:20:52 <mSSM> I am just asking because people tried to clarify my confusion in regards to using `join (***)' with me understanding the Reader monad.
06:21:10 <johnw> :t join (***)
06:21:11 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
06:21:23 <mSSM> (or rather, understasnding the implementation of (>>=) for reader)
06:21:38 <mikeplus64> > join (***) (+1) (0,0)
06:21:39 <lambdabot>   (1,1)
06:21:43 <johnw> have you written that definition yet?
06:21:45 <donri> ReaderT and Klesli are the same except for the order of the type parameters, and the instances
06:21:58 <ursfromthebackwo> #haskell
06:22:46 <int-e> donri: that hurt.
06:23:00 <donri> :)
06:23:03 <ursfromthebackwo> Dear all, could I make an advertisment for "Haskell User Group Frankfurt" on meetup.com? Here is the link to next Meetup: http://www.meetup.com/Frankfurt-Haskell-User-Group/events/100934772
06:23:36 <mSSM> johnw: I was thinking about something like State; so I suppose it would be: `reader >>= readerGenerator = R $ \r -> runReader ( readerGenerator (runReader reader r) ) r
06:23:38 <donri> i think you already did make an advertisement
06:23:54 <ursfromthebackwo> yes, realized it, mmh
06:24:06 <johnw> that looks about right to me, let me check
06:24:14 <mSSM> johnw: Where `R' wraps it up into the Reader monad.
06:24:26 <johnw> yes, that's it
06:25:02 <johnw> where join (***) comes into that, I do not know
06:25:07 <mSSM> lol
06:34:34 <donri> applicative: "Do you see it? The output has stopped printing after 15 seconds gone! Great discovery, this will help me later, no doubt."  -- but why? he just did "return", why should that stop the loop
06:35:07 <srhb> I don't think it stops the loop
06:35:10 <srhb> Notice that he interrupts it
06:35:13 <srhb> There's just no output
06:35:29 <donri> oh he's doing ^C manually when it stops printing
06:35:32 <srhb> Yes
06:35:54 <donri> i thought the wire was throwing interrupt for some reason
06:36:06 <srhb> Yes, that would be confusing for several reasons :P
06:36:36 <srhb> I still don't understand what FRP is good for, but alas...
06:39:00 <johnw> imagine writing code using variables that can change over time, but you don't need to code for that specifically
06:39:44 <johnw> like, foo = x . y <|> z.  Part of time foo = x . y, and part of the time foo = x . z.  You write your code with the expectation that either can be true at any given time
06:40:27 <johnw> if "y" becomes valid while the user holds down their mouse, but not otherwise, then you can see the connection with GUIs
06:41:36 <Eelis> i kinda lost my faith in FRP when i saw a talk about it at a Haskell conference where in the questions afterwards, SPJ asked the speaker "so.. you're using the RTS in a crazy way we compiler developers never planned for and which may or may not actually be sane?" and the answer was "yes"
06:42:49 <Eelis> another question was along the lines of "so.. you're doing speculative execution?" and the answer was "hmm, yeah i guess we might be, i'd have to look into that"
06:42:57 <Eelis> which sounded like the execution model of FRP is far from mature
06:43:09 <HugoDaniel> hi
06:43:23 <HugoDaniel> take a look at the "initials" function here: http://learnyouahaskell.com/syntax-in-functions#where
06:43:27 <johnw> Eelis: how new is FRP?
06:43:29 <HugoDaniel> that is strange
06:43:33 <Eelis> johnw: dunno
06:43:34 <HugoDaniel> i didn't know haskell could do that :)
06:43:41 <saeidw> Eelis, that sounds more like a problem with an implementation rather than with the concept of FRP
06:43:48 <mSSM> Is StateT both in MTL and Transformers now ?
06:43:53 <Eelis> saeidw: sure, but as a potential user, i care about implementation quality :)
06:44:09 <johnw> HugoDaniel: what about it is strange?
06:44:33 <HugoDaniel> the matching in the where clause
06:44:35 <johnw> mSSM: as I understand it, Transformers is to be preferred unless you really need something that's in the MTL
06:44:40 <Eelis> saeidw: and if the FRP people one day announce that they have what they consider an industrial strength implementation, i may take another look
06:44:50 <johnw> HugoDaniel: yes, you can pattern match in lots of places
06:45:11 <HugoDaniel> i see
06:45:12 <fmap> johnw: like convenience?
06:45:28 <saeidw> Eelis, that's reasonable :)
06:45:31 <johnw> fmap: I haven't yet needed transformers...
06:45:34 <johnw> i mean, MTL
06:46:20 <geekosaur> I'm confused.  mtl2 *is* more or less transformers
06:46:29 <Saizan> Eelis: yeah, that line of implementation looked quite misguided from the outside, i'm glad there seems to be more grounded reasearch atm
06:46:34 <johnw> then my information is bad, ignore me
06:46:35 <geekosaur> with a compatible API, which is why the platform uses mtl2 and not transformers
06:46:36 <mSSM> johnw: thanks
06:46:55 <Eelis> Saizan: ah, neat. what's a good source/blog/mailinglist to follow to keep updated on this work?
06:47:12 <johnw> Saizan: which library was the misguided one?
06:47:18 <mSSM> Hm, if I use cabal-dev, I should make a sandboxed `cabal-dev update', right?
06:47:26 <johnw> mSSM: you don't need to
06:47:26 <t7> whats a pointer to an element in a tree called again?
06:47:27 <Saizan> johnw: reactive
06:47:37 <Botje> t7: a pointer?
06:47:37 <johnw> is Netwire a preferred approach?
06:47:46 <johnw> t7: a cursor?
06:47:46 <Botje> t7: perhaps you mean a zipper?
06:47:50 <t7> zipper!
06:47:51 <Saizan> Eelis: i'm mostly seeing papers relating it to temporal logics at e.g. popl
06:47:51 <t7> thanks
06:47:52 <ursfromthebackwo> FRP: I tried apfelmus reactive-banana library and recently netwire (just some toy experiments) and both went pretty well. I do not agree that FRP is using the language in a non-intended way.
06:47:55 <geekosaur> (and StateT has been around in both mtl and transformers for years)
06:48:03 <johnw> a zipper is more than a pointer, it's a pointer with complete context
06:48:14 <Eelis> Saizan: ah
06:48:30 <t7> is there a nice way to deriver zippers or something?
06:48:44 <geekosaur> mSSM, if your confusion is "so which should I use?", the correct answer is "the one in mtl"
06:49:01 <johnw> http://stackoverflow.com/questions/2769487/mtl-transformers-monads-fd-monadlib-and-the-paradox-of-choice
06:49:03 <Saizan> and yeah, these newer libs
06:49:07 <mSSM> geekosaur: ok, now I am confused; why mtl, not transformers?
06:49:25 <johnw> go with what's in the platform, mtl
06:49:36 <srhb> johnw: Thanks for the summary of frp way back up there. :)
06:49:37 <johnw> i guess i'll start using that one too now
06:49:43 <johnw> srhb: sure thing
06:49:43 <geekosaur> that transformers exists at all is a bit of history that hasn't quite finished but has reached a local maximum
06:50:09 <johnw> geekosaur: I get confused by comments like this on SO: "Do you need standard monads for a new project? Use transformers & co., help us lay mtl to rest."
06:50:18 <Eelis> ursfromthebackwo: i don't claim that FRP is using the language in a non-intended way in principle. that was just the implementation they had at the time
06:50:48 <ursfromthebackwo> yes, understood
06:50:55 <johnw> that's what I based my advice on earlier
06:51:02 <johnw> ah, cmccan isn't here to elucidate
06:51:09 <geekosaur> (a couple years ago there were competing implementations:  monads-{fd,tf} and transformers which could sit on either, and a move toward using those pairs.  type families turn out to not yet be up to the task; meanwhile mtl was rewritten around transformers
06:51:09 <srhb> Ideally, nothing expressible in Haskell should be bad!!!! <_<
06:51:22 <srhb> I want my dream language, stat! Okay, we're pretty close...
06:51:22 <johnw> ahh
06:51:24 <geekosaur> (mtl uses fds, just as it did originally)
06:51:30 <johnw> and cmccann's comment is from 5/10, makes sense
06:52:04 <ocharles> hum, is there really no way to atomically read from an mvar? all the functions seem to have the caveat "if there are no other producers"
06:52:09 <geekosaur> but it will be a while before the question of fundeps vs. type families will be particularly relevant, meanwhile mtl remains the standard
06:53:04 <johnw> ocharles: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-November/015896.html
06:53:25 <ocharles> thanks!
06:53:38 <srhb> geekosaur: Why will it be a while?
06:53:57 <geekosaur> because they're still working out the extensions to how type families work
06:54:50 <srhb> Ah.
06:55:05 <geekosaur> functional dependencies currently allow you to do a few essential things (which I do not remember off the top of my head) that type families cannot, and the compiler support for those things in type families not only does not exist, but in some cases the theory's a little shaky too
06:55:10 <srhb> Yes, I thought I'd heard "type families are bad" a few times, i'm sure that's a paraphrase of that :P
06:55:16 <srhb> Okay.
06:56:02 <t7> this feels so 2008, define a data structure AND a zipper
06:56:12 <t7> maybe use lens?
06:56:15 <johnw> t7: i do believe lens can help you :)
06:56:25 <ocharles> hmm, maybe there's not a problem
06:56:34 <ocharles> I only put into an MVar after doing a take
06:56:35 <geekosaur> they're still a long term goal because fundeps are "interesting" (always fun to have a chunk of prolog invade your type system :) but not yet
06:56:40 <ocharles> so it would be impossible to have multiple producers
06:56:55 <johnw> i love it when programmers say impossible
06:57:15 <johnw> it's like possibility sits up and listens close, "Oooh, an opportunity for mischief!"
06:57:24 <Saizan> ocharles: yes, if all threads stick to the take/put discipline it's safe
06:57:42 <ocharles> yea, that's the situation i'm in. good!
06:59:07 <quchen> I'm having trouble coming up with a nice way of writing a function that intersperses "," to a number for prettyprinting, e.g. pretty 12345 = "12,345". Is there a one-liner solution for this that I fail to find, or do I really have to work out the eventualities?
06:59:38 <quchen> Splitting off the last 3 digits can be done with (`mod` 1000) of course, but that'll be 0 and not 000, which breaks numbers like 1000.
06:59:46 <johnw> you can always use a fold to do this
06:59:49 <johnw> but, there may be better ways
07:00:13 <Saizan> quchen: show it first and act on the characters
07:00:30 <quchen> Saizan: Yeah that's the hacky solution
07:00:44 <Saizan> i'd say it's the proper solution
07:00:52 <johnw> i would agree with Saizan
07:01:01 <johnw> you are wanting to modify the display characteristics, not the numerical ones
07:01:15 <quchen> Problem with that is that I have to start on the right side of the string counting triples, not on the left
07:01:28 <quchen> Hm. Oh well, glad I didn't miss something obvious and beautiful here ;-)
07:01:29 <t7> can i serialize my lens to string or something, so i can send to another language or something ?
07:02:31 <EvanR> so im trying to pass a function of type (IO a -> IO a) to function and use it on a value of type IO X to get IO X, but i cant do it if i have a type signature
07:02:35 <EvanR> thats annoying
07:02:52 <EvanR> it complains cannot match rigid type variable a in the signature with X
07:03:21 <byorgey> EvanR: paste the code or it didn't happen
07:03:31 <EvanR> ok
07:04:10 <johnw> quchen: ok, this is hideous, so begin the golfing
07:04:12 <johnw> reverse $ concat $ map (\(p,x) -> if p == 3 then "," ++ [x] else [x]) $ zip (cycle [0..3]) (reverse "123456789")
07:04:12 <quchen> > let pp = concat . reverse . intersperse "," . map reverse . chunk 3 . reverse . show in pp 12345
07:04:14 <lambdabot>   "12,345"
07:04:38 <quchen> Ewww.
07:04:40 <EvanR> http://codepad.org/rVMqMmgi this is the code, at some point i will need to account for the fact that unmask has type (forall a. IO a -> IO a) but right now im just trying to understand this problem which is independent of the fact that unmask will not be that type in another module
07:04:43 <quchen> And I thought mine was ugly ;-)
07:04:50 <EvanR> for my purposes in understanding this unmask has type (IO a -> IO a)
07:05:18 <quchen> But thanks to the both of you, you made me feel not bad by saying "yeah it's hacky" :-)
07:05:45 <srhb> What.
07:05:50 <mSSM> I am inside the do block of a StateT monad; in there, I have `g <- get ; p <- foo g ; (stuff where p is used)'; foo has type `IO Int'. Why exactly does that not work? GHC complains that it has the actual type `IO Int', while it expected `StateT ...' .
07:06:06 <mSSM> Can't I make monadic calls of a different type inside another monad?
07:06:24 <srhb> mSSM: Stacks?
07:06:32 <srhb> liftIO
07:06:35 <srhb> lift in general
07:06:41 <EvanR> so i can make it work be deleting the top level type sig, or by changing the type of unmark to forall a. IO a -> IO a and using an extension flag like RankNTypes
07:06:49 <EvanR> but i have no idea why
07:06:59 <EvanR> monomorphism restriction?
07:07:14 <mSSM> srhb: So I need to lift `foo' ?
07:07:39 <srhb> EvanR: Are you not basically saying "despite the fact that I will always pass an IO React Value, I'm claiming it can be ANY IO a -> IO a
07:07:51 <srhb> mSSM: Yes
07:08:05 <srhb> mSSM: And make sure the IO Monad is actually in your transformer stack
07:08:13 <srhb> mSSM: In the type, I mean.
07:08:21 <geekosaur> mSSM, do "blocks" are not blocks as you are thinking of them; they are expressions and the compiler is inserting operators to combine those expressions, and you need to make sure the types match what the inserted operators expect
07:08:37 <Saizan> > reverse . concat . zipWith (\p x -> p ++ [x]) (cycle ["",",",""]) . reverse $ "123456789"
07:08:39 <lambdabot>   "12,345,678,9"
07:09:01 <srhb> EvanR: Am I correct?
07:09:13 <srruby> is hackage.haskell.org down?
07:09:14 <Saizan> > reverse . concat . zipWith (\p x -> p ++ [x]) (cycle ["","","",","]) . reverse $ "123456789"
07:09:16 <lambdabot>   "12,3456,789"
07:09:22 <srhb> EvanR: If so, the answer is to stop lying to the compiler. :)
07:09:25 <EvanR> srhb: it also works if i change the type sig to (IO (React Value) -> IO (React Value)) but then i cant pass it unmask from forkIOWithUnmask which is (forall a. IO a -> IO a)
07:09:29 <byorgey> EvanR: if you have (IO a -> IO a)  it means the caller of objectLoop gets to choose the type a
07:09:35 <EvanR> oh
07:09:44 <byorgey> EvanR: i.e. it's as if you have  objectLoop :: forall a. Global -> ... (IO a -> IO a) ...
07:09:52 <EvanR> ok so the right answer for this si to change the sig
07:09:53 <byorgey> having (forall a. IO a -> IO a)  is very different
07:10:07 <byorgey> it means the caller of objectLoop must pass a function that works for *all* types a
07:10:07 <EvanR> my next question would be how to get unmask passed in
07:10:24 <srhb> Yes, if you mean to pass react arg to unmask, then you need to change the signature of unmask. Or react.
07:10:30 <mSSM> srhb: Another possibility would be to make `foo' into  :: ... -> m Int , right?
07:10:46 <mSSM> srhb: so that it just returns into w/e Monad is there, right?
07:10:51 <srhb> mSSM: If you use IO, you will end up with IO in your stack
07:10:55 <EvanR> do i need to wrap unmask in the caller? the thing using forkIOWithUnmask and objectLoop
07:11:00 <srhb> mSSM: You cannot magically introduce IO into your stack without having IO in the type.
07:11:11 <johnw> > snd $ foldr (\y (pos,xs) -> if pos == 2 then (0,(',':y:xs)) else (pos + 1,(y:xs))) (0,"") "123456789"
07:11:12 <lambdabot>   ",123,456,789"
07:11:26 <johnw> at least no reversing needed
07:11:31 <srhb> mSSM: If foo need not be IO, why was it there in the first place?
07:12:09 <byorgey> EvanR: I don't understand the question
07:12:13 <mSSM> srhb: I am using the `random' function from `mersenne-random', which always gives `IO a'
07:12:20 <t7> "No instance for (Data.Monoid.Monoid Expr)" i have never got this before...
07:12:21 <johnw> > dropWhile (== ',') $ snd $ foldr (\y (pos,xs) -> if pos == 2 then (0,(',':y:xs)) else (pos + 1,(y:xs))) (0,"") "123456789"
07:12:23 <lambdabot>   "123,456,789"
07:12:37 <mSSM> srhb: therefore I have IO
07:12:48 <EvanR> byorgey: i want to do forkIOWithUnmask and use objectLoop as the body, so the last parameter is supposed to be the unmask
07:12:49 <srhb> mSSM: If you want to use that inside your stateful computation, you must either pass it in as an argument before running the state, or you need IO in your transformer stack.
07:13:17 <mSSM> srhb: Can you give me an example what a State like that should look like?
07:13:21 <johnw> there are also packages that provide RandT
07:13:25 * byorgey has no idea what forkIOWithUnmask is
07:13:31 <mSSM> srhb: Or rather: I don't understand what `stack' means and how that type should look like.
07:13:41 <statusfailed> Can I use Hint to compile some Haskell and force it to be safe with Safe Haskell?
07:13:41 <johnw> StateT s IO a
07:13:50 <johnw> where s is your state type, and a is your value type
07:13:51 <EvanR> byorgey: well i end up with this type error
07:13:53 <EvanR> Couldn't match expected type `forall a. IO a -> IO a' with actual type `IO (React Value) -> IO (React Value)'
07:14:10 <EvanR> >_<
07:14:15 <srhb> mSSM: foo :: StateT Int IO Int; foo = do { a <- get; b <- liftIO readLn; return (a+b) }
07:14:18 <srhb> I think
07:14:28 <statusfailed> actually, is there a better option for executing 'untrusted' code?
07:14:39 <statusfailed> nevermind... found the wiki page
07:14:57 <EvanR> untrusted code should not have IO ;)
07:15:14 <mSSM> srhb: hm, now my code starts to look like boiler plate :(
07:15:25 <mSSM> srhb: out of a sudden liftIOs everywhere
07:15:47 <johnw> mSSM: are you ending up having to use liftIO in lots of places?
07:15:52 <mSSM> johnw: yes
07:15:57 <statusfailed> EvanR: I was worried about bottom and error/undefined stuff, but it looks like mueval solves the problem
07:16:00 <johnw> remember that liftIO takes an IO action
07:16:01 <mSSM> either that, or if I rewrite some functions, lift
07:16:05 <johnw> mean you can say: liftIO $ do ...
07:16:16 <mSSM> oh, ok
07:16:34 <srhb> I think transformers usually make code look _less_ boilerplatey :P
07:16:36 <EvanR> well, can someone explain how to use a value of type (forall a. IO a -> IO a)
07:17:10 <srhb> EvanR: Anything! As long as you don't assume anything about a.
07:17:17 <srhb> Which means, not a lot, really.
07:17:40 <EvanR> >_>
07:17:55 <statusfailed> EvanR: where's that from?
07:18:01 <EvanR> forkIOWithUnmask
07:18:26 <johnw> EvanR: from which package?
07:18:30 <johnw> ah, hackage is back!
07:18:34 <srhb> Fantastic.
07:18:40 <statusfailed> oh, hackage was down? I thought it was my internet connection
07:18:40 <statusfailed> haha
07:18:44 <EvanR> Control.Concurrent
07:19:12 <byorgey> EvanR: you just use it.
07:19:21 <byorgey> again, you are going to have to show us some code with the error.
07:19:29 <byorgey> otherwise it is impossible to say what you are doing wrong.
07:19:56 <EvanR> http://codepad.org/KOdNdrBB
07:20:43 <johnw> EvanR: I assume you saw the code example at http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/Control-Concurrent.html#v:forkIOWithUnmask?
07:21:35 <EvanR> yes
07:21:43 <byorgey> EvanR: that should work.  do you have a rank-2 type signature on objectLoop?
07:21:48 <johnw> so, forall a. IO a -> IO a is a function that leaves the value unaffected, by has an impact on the environment
07:21:55 <EvanR> byorgey: well i could
07:22:04 <johnw> so that unmask function is, I presume, just changing some internal data structures for the benefit of that thread
07:22:13 <byorgey> EvanR: you must.  Rank-2 type signatures can't be inferred.
07:22:19 <EvanR> ok
07:22:34 <EvanR> so ill change objectLoop to take (forall a.....) and use Rank2Type
07:23:41 <EvanR> so why cant forkIOWithUnmask provide a function IO a -> IO a without forall
07:24:08 <EvanR> the exception handling stuff doesnt seem to need Rank2
07:24:27 <johnw> how would it know what the type of a is?
07:24:44 <EvanR> it doesnt matter
07:24:49 <EvanR> look at this
07:25:00 <EvanR> :t (\x -> putStrLn "ok" >> x)
07:25:01 <lambdabot> IO b -> IO b
07:25:06 <byorgey> I don't know, but presumably it requires thinking carefully about who gets to pick which types, and why
07:25:39 <johnw> if you really want to know, create another function withuot the forall, and try to use it in place of forkIOWithUnmask
07:25:44 <EvanR> (\x -> restoreAsynMask >> x)
07:26:13 <EvanR> :t (\x -> putStrLn "ok" >> x) getChar
07:26:14 <lambdabot> IO Char
07:26:16 <geekosaur> it does matter, if you think about how type resolution works
07:27:49 <johnw> geekosaur: is it because a is invariant in the first function parameter to forkIOWithUnmask?
07:28:01 <johnw> (that is, if the forall were not present)
07:28:15 <geekosaur> johnw, if you omit the forall then the compiler is forced to assume that it must fix a type for (a)
07:28:29 <geekosaur> even if the function doesn't actually do anything with it (as in this case)
07:28:31 <EvanR> so monomorphism restriction?
07:28:47 <geekosaur> no, although it's sort-of related
07:28:54 <geekosaur> if you squint
07:28:58 <johnw> won't the call to unmask fix a type?
07:29:05 <srhb> Ah, the classical Haskell Squint.
07:31:23 <mSSM> So, inside a State do block, I now have a part `myBool <- liftIO $ {actionGivingIOBool}'; I wanted to use a `case myBool of { True -> ... ; False -> ...}' expression to then put a new state and result into the StateT monad. But I am not sure how to do that now?
07:31:42 <mSSM> Most likely I have gotten this completely wrong.
07:32:08 <johnw> mSSM: you may need a return $ in front of your case expression
07:32:24 <johnw> also, case on a Bool is more easily expressed using "if"
07:32:44 * hackagebot zlib-bindings 0.1.1.3 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.1.1.3 (MichaelSnoyman)
07:32:46 * hackagebot ChristmasTree 0.2.1.1 - Alternative approach of 'read' that composes grammars instead of parsers.  http://hackage.haskell.org/package/ChristmasTree-0.2.1.1 (DoaitseSwierstra)
07:33:04 <mSSM> johnw: tipp with the if is noted
07:33:15 <`ramses> can cabal tell me which of my installed packages have newer versions on hackage?
07:33:26 <johnw> the utility "cab" can
07:33:38 <mSSM> johnw: about the `return $ case ...': right now, I have `put st' and `return a' at the end of both cases.
07:33:43 <`ramses> ah, and where can I find that?
07:33:47 <johnw> ah, then you're ok
07:34:02 <johnw> cabal install cab :)
07:34:13 <johnw> then "cab outdated"
07:34:38 <johnw> another handy one is cabal-delete, which is only on github
07:35:10 <`ramses> I see a "cblrepo" package in my distro's repo, is that related?
07:35:24 <neutrino> i think cabal packages should come as .cab files /me hides
07:35:34 <johnw> i doubt that
07:35:41 <johnw> git://github.com/kazu-yamamoto/cab.git
07:35:53 <`ramses> okay, the description says "Tool to maintain a database of CABAL packages and their dependencies"
07:35:57 <Letchik> Hello. I was using cabal and I used 'cabal update' command. It said that there was a new version of cabal, so I used 'cabal install cabal-install' but now 'cabal update' says that there is a new version again. I updated it and installed it a few times and it still reports a new version. Originally I installed cabal from Haskell Platform.
07:36:00 <johnw> http://www.mew.org/~kazu/proj/cab/
07:36:16 <srhb> mSSM: If you return and put the same things in each case, why do you have a case at all. :)
07:36:21 <johnw> Letchik: check your PATH
07:36:22 <merlin-> hello. why can't you define typeclass instance for type alias without turning on TypeSynonymInstances extensions?  seems like a pointless limitation for me, am I missing something?
07:36:25 <`ramses> johnw: it's compiling, thanks :)
07:36:40 <neutrino> btw, anyone got a clue if the new cabal is coming along?
07:36:49 <quchen> ^ this
07:36:50 <johnw> merlin-: a type alias isn't a unique type
07:36:50 <neutrino> with the anti-cabal-hell capability
07:36:59 <merlin-> johnw I know
07:37:01 <neutrino> quchen: om nom...
07:37:03 <johnw> merlin-: that's why
07:37:38 <merlin-> johnw why doesn't it just define instance for the type alias refers to?
07:37:39 <johnw> merlin-: you can either newtype, or use TypeSynonymInstances to enable the extension that allows instances to be associated with type synonyms
07:37:44 <srhb> mSSM: Or perhaps you want to share some sequencing after each, in which case you move it after the case
07:37:45 <hpaste> mSSM pasted “Proper if?” at http://hpaste.org/81164
07:37:51 <johnw> merlin-: ah, I see what you are asking
07:37:58 <johnw> merlin-: I do not know
07:38:02 <mSSM> srhb: I have dumped my crime on hpaste ^
07:39:07 <srhb> mSSM: The only thing they have in common is S.put ge?
07:39:17 <mSSM> srhb: yes
07:39:29 <srhb> mSSM: That doesn't seem to be a huge problem.
07:39:37 <mSSM> srhb: if `doFlip' is true, it does some extra calculations and presents them as the result.
07:39:51 <srhb> But you might as well put it before the if, right?
07:39:51 <mSSM> srhb: if it's false, then it doesn't have to do those calculations, and simply presents (0,0)
07:39:58 <srhb> I mean, there's no sense to have them in both places.
07:39:59 <mSSM> srhb: yeah, I can do that.
07:40:06 <epta> It's a strange question, but how can I call f(x,y,z) in java for all x from [0..10]? So, I wanna something like map (\x -> f(x,y,z)) [0..10] without usual for loop
07:40:24 <srhb> So.. The state never changes?
07:40:40 <epta> In #java some boring people said "stfu and use for"
07:40:53 <srhb> epta: stfu and use for
07:40:55 <srhb> epta: Really.
07:40:56 <srhb> :P
07:41:05 <merlin-> epta hah
07:41:08 <mSSM> srhb: Well, this is touching a problem of my State.
07:41:25 <srhb> mSSM: Why? You're only reading state. You even put identical state back, which makes no sense
07:41:26 <mSSM> srhb: technically, the state should be the `Grid' you see there, but it contains a mutable vector.
07:41:33 <srhb> Ah, don't do that.
07:41:39 <mSSM> :(
07:41:55 <mSSM> srhb: in regards to the state staying the same: it's the generator.
07:42:01 <mSSM> srhb: I need to pass the generator aroud somehow.
07:42:17 <srhb> Reader is for immutable configuration
07:42:33 <mSSM> srhb: Ok, I could change that.
07:42:41 <srhb> In fact, reader is sufficient if you're manipulating some IO thingy as well
07:42:45 <srhb> And you just need a reference to it.
07:43:21 <mSSM> srhb: ok, that sounds like it makes sense.
07:43:25 <srhb> It doesn't
07:43:44 <mSSM> ?
07:44:09 <srhb> The problem is now so simple that the Reader abstraction is probably even too much. Might as well pass your config around by argument.
07:44:20 <johnw> i agree
07:45:23 <srhb> So either actually use State for your State, or simply pass your configuration around by argument and abandon RWS entirely
07:45:41 <mSSM> Well, I was happy I could use `evalStateT' in conjunction with `replicateM' :D
07:45:46 <mSSM> But you are right.
07:45:51 <srhb> You can still replicateM your IO action
07:46:20 <srhb> All you did is put layer upon layer of abstraction over your problem that you then subsequently did not use. :)
07:47:02 <mSSM> srhb: Yeah, this looks more handsome now.
07:49:20 <mSSM> srhb: Design-wise, it would make more sense to make the mutable vector immutable, and use that as a state. In that case I could use `StateT'
07:49:51 <beaky> data ISpellCaster s = ISpellCaster { castSpell' :: s -> IO () }
07:49:53 <mSSM> srhb: however, I wouldn't even know where to start to make that as fast as using a mutable vector (which I am doing now)
07:50:28 <`ramses> mSSM: is that some sort of Ising simulation?
07:50:45 <mSSM> `ramses: yeah, I am bugging #haskell for quite some time now.
07:50:45 <EvanR> java style naming
07:51:22 <`ramses> cool :) you're a physics student or researcher of some sort then?
07:51:29 <mSSM> `ramses: I am abusing that Ising simulation to learn haskell
07:52:02 <mSSM> `ramses: I am finishing my Masters in Physics right now. Have to do some numerics which are related to the Ising model.
07:52:15 <`ramses> painful to start with a problem that's for a large part just number crunching optimisation
07:52:24 <mSSM> tell me about it :D
07:52:37 <`ramses> hehe :)
07:52:44 <mSSM> What's painful is that there is not much work available online with problems similar to mine.
07:52:57 <srhb> mSSM: I might end up bugging you instead then, studying BSc. phys :P
07:53:07 <`ramses> yeah, if there was, you probably wouldn't be doing research about it ;)
07:53:29 <srhb> mSSM: But really, you can just as well go mutable and just pass the config around either with arguments or, if it gets really complicated, via ReaderT
07:53:39 <mSSM> Sure, you can find basic Monte Carlo simulations, but there is nothing available online using probabilistic methods && a mutable data structure.
07:53:55 <`ramses> ha, it's physicist's afternoon at #haskell :)
07:54:15 <EvanR> i read that as "pharmacist"
07:54:27 <mSSM> Most MC simulations online just generate a stream and fold over that, but there is no data which is being simulated on.
07:54:29 <srhb> Apparently it's spreading.. Perhaps if some of us become competent at Haskell, we can actually make it into a useful physicist's tool :P
07:54:36 <`ramses> that's some other day ;)
07:55:09 <`ramses> srhb: I'm a theoretical physicist doing a second degree in CS and I'm doing my thesis in haskell :)
07:55:24 <mSSM> `ramses, srhb where are you guys located at?
07:55:24 <srhb> `ramses: Nice! What's your thesis about?
07:55:30 <srhb> Copenhagen, Denmark.
07:55:39 <mSSM> srhb: visit me in Stockholm :0
07:55:44 <srhb> Oh, neat ^^
07:56:14 <trescenzi> what's everyones opinion on writing a compiler in Haskell? I have to write one for a class and I want to do it in a functional language.
07:56:25 <srhb> trescenzi: Haskell is excellent for writing compilers
07:56:34 <EvanR> will be easier than in other languages
07:56:40 <`ramses> srhb: not sure yet, I'm starting with it in a couple of weeks, I only know that I'll be doing it in a group that does functional programming in haskell
07:56:44 <Botje> trescenzi: do it. it's great fun :)
07:56:52 <srhb> `ramses: Gotta remember to ask you about it again then :P
07:56:53 <trescenzi> oh and as  note I have to write the whole thing sadly I can't use any lexer generatrators or anything
07:56:56 <`ramses> mSSM: belgium here
07:57:04 <mSSM> srhb: ok, I have liberated that function above from StateT, and it's a simple `:: ... -> IO (Int,Int)' now.
07:57:12 <srhb> trescenzi: Even more Haskell then. :-)
07:57:20 <trescenzi> yay!
07:57:20 <srhb> mSSM: Yeah :)
07:57:46 <`ramses> srhb: I should know more in a couple of weeks from now
07:57:53 <srhb> `ramses: Mentally noted. :)
07:58:13 <srhb> trescenzi: Wait, you actually know Haskell, right?
07:58:14 <mSSM> srhb: so, just to bug you with one more thing: the function actually calling `mcStep' now collects the results and sums them up. That function has :: S.StateT (Int,Int) IO (Int,Int)
07:58:37 <mSSM> srhb: Now, in there I have something like (wrong?) : (de,dm) <- join (***) sum . unzip <$> replicateM (n*n) $ mcStep gr ws ge
07:58:44 <trescenzi> srhb: lol yea. not amazingly well but i've been working with it for about 6 months now
07:58:47 <srhb> mSSM: Sounds like (Int,Int) -> IO (Int, Int) ?
07:59:11 <srhb> trescenzi: Okay, just making sure you were not starting from scratch, that would be hard probably.
07:59:17 <srhb> trescenzi: Depending on your deadline
07:59:41 <mSSM> srhb: Well, in that case the state is actually changing; i.e. I need to make it stateful.
07:59:51 <srhb> Is it?
07:59:55 <srhb> How so?
07:59:59 <trescenzi> srhb: I have about 3 months to do it so I think I should have time to learn the bits I don't know and get it all working
08:00:00 <Philippa> trescenzi: Are you allowed to use existing parser combinator libs, or will you have to write your own? 'Cos if it doesn't have to run fast, they're a piece of piss to write anyway
08:00:13 <Philippa> and to a first approximation, ADTs /are/ ASTs
08:00:18 <Philippa> which sure helps
08:00:34 <srhb> I assumed no lexer/parser gen meant no parser combinators.
08:01:01 <geekosaur> I would assume it means parser combinators but not e.g. happy
08:01:04 <geekosaur> or alex
08:01:16 <trescenzi> Philippa: I have to write everything myself but time is no issue at all. It's just an introduction to compilers class
08:01:29 <mSSM> srhb: by calling `mcStep' n times, `mcUpdate' calculates a (Int,Int) tuple, which is then used as an input to `mcUpdate' to calculate a new (Int,Int) tuple.
08:01:32 <trescenzi> Oh and by time I mean time complexity
08:01:49 <trescenzi> so yea the ADT /are/ AST is all that matters
08:01:55 <mSSM> srhb: So, mcUpdate itself is called n times, which itself calls mcStep m times.
08:02:35 <srhb> mSSM: I don't see how that needs to be stateful.
08:02:51 <srhb> mSSM: It sounds like a simple recursion?
08:02:52 <srhb> mSSM: I may be missing something.
08:03:00 <mSSM> srhb: what other option do I have rather than using an explicit recursion?
08:03:09 <mSSM> (I don't want to use an explicit recursion)
08:03:20 <trescenzi> geekosaur: so what's the difference between happy and alex and a lexer/parser generator? I'd most likely like to write it all myself but if it comes to it I wouldn't mind getting some allowed help
08:03:26 <srhb> mSSM: When do you want to terminate?
08:03:52 <mSSM> srhb: After the results from having run `mcUpdate' n times are collected and processed.
08:04:00 <geekosaur> trescenzi, happy takes a parser description and generates haskell code implementing it.  with parser combinators you have a library of parsing primitives and you must assemble a parser from them
08:04:27 <srhb> mSSM: iterateM?
08:04:32 <srhb> mSSM: Or something like that.
08:04:33 <geekosaur> now, it's possible that you might be expected to also implement those low level combinators; that's a question for the professor
08:04:41 <geekosaur> (or TA as the case may be)
08:04:56 <trescenzi> geekosaur: yea I don't think he'd like us to do that however it might be a useful way to see what it "should" look like
08:05:14 <geekosaur> but even then, it's not difficult to write something yourself that does the 90% of e.g. parsec that you'd need
08:05:34 <mSSM> srhb: I am not able to look that up right now, but is iterateM able to take the result of a previous run and use it in a successive run?
08:05:59 <srhb> mSSM: I don't think it's in the standards, but it's just the standard monadic version of iterate
08:06:17 <mSSM> srhb: hm, I see
08:06:22 <mSSM> srhb: that wuld work
08:06:31 <srhb> where iterate f x = [x, f x, f (f x), ...]
08:06:43 <mSSM> srhb: Also, I just realize that there is no need to carry around the intermediate result.
08:07:05 <`ramses> if you only need the end result, untilM might be better
08:07:08 <trescenzi> geekosaur: yea and as I mentioned before time complexity is not really a concern so I don't think it should be too difficult
08:07:30 <srhb> mSSM: :P
08:07:52 <mSSM> srhb: I actually just need e0 + (e0+e1) + (e0+e1+e2) + .... + (e0 + e1 + ... + e(n-1) + en)
08:08:12 <srhb> yes, well, you can just sum it from the outside.
08:08:18 <srhb> I assume.
08:09:17 <mSSM> Actually, to write it in a cleaner way: is there something that would give me: f (e0) + f(e0+delta_e(1)) + f(e0+delta_e(1)+delta_e(2)) + ... ?
08:09:29 <int-e> > sum . scanl (+) 0 . take 3 $ iterate f a
08:09:31 <lambdabot>   0 + 0 + (0 + a) + (0 + a + f a) + (0 + a + f a + f (f a))
08:09:45 <mSSM> Damn, this is cool
08:09:47 <mSSM> int-e: thank you
08:09:50 <mSSM> :* :* :*
08:10:26 <mSSM> (yes, that's a kissing smily)
08:10:38 <int-e> yuck. but scanl is cool :)
08:11:12 <mSSM> Haha, this is really cool.
08:11:15 <mSSM> Alrighty, thanks all!
08:11:21 <mSSM> I am off to the movies
08:11:24 <mSSM> :)
08:12:07 <mm_freak_> applicative: you mean the one in Control.Wire?
08:12:20 <GhostBarik> sorry, guys, may i ask? I recently wrote my first program in Haskell dealing with simple IO and succesfully compiled it. However the size of executable seems pretty big for me (1.2 MB). Is there any way i can reduce its size? Tnx
08:12:52 <GhostBarik> i know that the runtime system of haskell is pretty huge but still...
08:12:57 <applicative> mm_freak_: yeah
08:13:08 <Lethalman> GhostBarik, because the executable is not dynamic by default, it's static
08:13:10 <mm_freak_> btw, in my case it's better not to go through @tell…  much more likely that i miss a @tell than an "mm_freak_: blah blah blah"
08:13:12 <applicative> mm_freak_: I was just kidding
08:13:32 <applicative> mm_freak_: yeah, I realized that after hitting return...
08:13:37 <Lethalman> GhostBarik, search internet for dynamic/static and ghc and you'll find the answer
08:13:40 <mm_freak_> =)
08:13:57 <applicative> mm_freak_: in any case it a very nice post, I hope he keeps it up, maybe I'll figure it out
08:14:05 <GhostBarik> Lethalman, tnx a lot
08:14:20 <applicative> i mean, maybe ill figure out what to do with net wire
08:14:35 <mm_freak_> applicative: yeah…  although he is overcomplicating a few things, but that's fine for a novice =)
08:14:56 <bartavelle> isn't there a printf like function for Text somewhere ?
08:15:04 <mm_freak_> applicative: whenever you have a "main loop", you probably want netwire
08:15:15 <applicative> mm_freak_: I figured, but it will be nice if he just keeps going
08:15:58 <fmap> @hackage text-format
08:15:58 <lambdabot> http://hackage.haskell.org/package/text-format
08:17:53 <bartavelle> thanks fmap
08:36:23 <fragamus> @hoogle element
08:36:23 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects ElementArrayBuffer :: BufferTarget
08:36:23 <lambdabot> Test.QuickCheck.Gen elements :: [a] -> Gen a
08:36:23 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
08:42:00 <otters> @pl \x -> feed (parse parser x) ""
08:42:00 <lambdabot> flip feed [] . parse parser
08:42:45 * hackagebot hs-gchart 0.4.1 - Haskell wrapper for the Google Chart API  http://hackage.haskell.org/package/hs-gchart-0.4.1 (DeepakJois)
08:49:22 <otters> how do you express (\\"|[^"])+ in attoparsec?
08:49:36 <otters> (that's a regular expression)
08:52:32 <awestroke> Trying to figure out the rules of function composition. How come I can do "maximum $ (map (2*) [1, 2, 3])" but not "maximum . (map (2*) [1, 2, 3])"
08:52:45 * hackagebot family-tree 0.3.1.2 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.3.1.2 (NathanVanDoorn)
08:52:47 * hackagebot family-tree 0.3.1.3 - A family tree library for the Haskell programming language.  http://hackage.haskell.org/package/family-tree-0.3.1.3 (NathanVanDoorn)
08:52:59 <c_wraith> awestroke: because (map (2*) [1,2,3]) isn't a function
08:53:00 <Botje> awestroke: work out the .
08:53:22 <fmap> otters: many1 anyChar?
08:53:22 <Botje> maximum . (map f l) === \x -> maximum (map f l x)
08:53:33 <otters> fmap: that matches the " charactel
08:53:35 <otters> *r
08:54:12 <Mortchek> awestroke, f and g are composable as f.g if Codomain(g) equals Domain(f). (This presuppose both are functions.)
08:54:49 <fmap> otters: and (\\"|[^"])+ too?
08:54:51 <Mortchek> Or, hrm, does Haskell amend that rule?
08:55:04 <otters> fmap: well, the point is to match \" or any non-" character
08:55:09 <c_wraith> Mortchek: nope, that's exactly right.
08:55:10 <otters> you know, to match a string literal
08:55:17 <c_wraith> Mortchek: that's even what the type of (.) says
08:55:27 <Mortchek> @type (.)
08:55:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:55:32 <c_wraith> err.
08:55:34 <Mortchek> Heh.
08:55:36 <Mortchek> @type (Prelude..)
08:55:37 <c_wraith> :t (Prelude..)
08:55:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
08:55:38 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:01:46 <Sculptor> hi!
09:01:54 <Taneb> Hey, Sculptor
09:02:45 * hackagebot hipe 0.2.0.0 - Support for reading and writing ipe7 files (http://ipe7.sourceforge.net)  http://hackage.haskell.org/package/hipe-0.2.0.0 (FrankStaals)
09:02:47 * hackagebot yesod-platform 1.1.7.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.7.1 (MichaelSnoyman)
09:07:45 * hackagebot citeproc-hs 0.3.7 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.7 (AndreaRossato)
09:12:47 * hackagebot idris 0.9.6 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.6 (EdwinBrady)
09:20:57 <awestroke> More problems with function composition: https://gist.github.com/2d438a5296ead71ed416
09:21:35 <mauke> sigh
09:21:44 <awestroke> :(
09:22:04 <mauke> awestroke: 'f (g x) y' is not the same as 'f (g x y)'
09:22:05 <Philippa> someone's got a type-level function/constructor composition operator somewhere, right?
09:22:18 <Philippa> (in Haskell, I don't need to see the Agda version :p)
09:25:23 <HugoDaniel> im teaching haskell to a chinese girl
09:25:56 <HugoDaniel> i generated the chinese version of learn you a haskell, she is going through the book, and we do the exercices
09:26:06 <HugoDaniel> cool :)
09:26:14 <`ramses> which exercises?
09:26:33 <HugoDaniel> when she finishes each chapter
09:26:45 <`ramses> are their exercises in lyah?
09:26:48 <HugoDaniel> i run through the code (the black windows), and explain and ask her to do
09:26:56 <`ramses> there aren't in my edition..
09:27:10 <`ramses> s/their/there
09:27:25 <HugoDaniel> this: http://media.fcsh.unl.pt/~hugo/liu/haskell/chapters.html
09:27:35 <HugoDaniel> its the same in en
09:27:41 <HugoDaniel> black window with code
09:28:06 <srhb> Philippa: That sounds funky, how does one do that?
09:28:29 <Philippa> srhb: that's what I was asking :p I just figure someone must've written a type synonym or similar for it by now
09:28:32 <`ramses> okay, I thought you meant actual exercises..
09:28:50 <HugoDaniel> oh no, she is reading everything in chinese
09:28:55 <Philippa> (I'm doing a lot of gluing functors together and writing it all out longhand is getting really tedious - I was complaining on Twitter yesterday)
09:28:57 <HugoDaniel> my haskell is actually better than my chinese :D
09:29:29 <srhb> Philippa: Ah :P
09:29:58 <EvanR> rofl
09:30:05 <EvanR> do both
09:30:08 <EvanR> use chinese variable names
09:30:50 <Philippa> srhb: unless it's actually impossible, anyway. I really hate the fact you don't get eta-equivalence on type synonyms!
09:31:04 <srhb> Philippa: *blank stare*
09:31:06 <HugoDaniel> yeah, i use a chinese letter as a var, and she said "we dont have that symbol in chinese"
09:31:13 <Philippa> (you can't partially apply them, you /can/ write the synonym that's equivalent to partially applying...)
09:31:16 <srhb> Ah, right.
09:31:26 <HugoDaniel> thats when i realize that i should use en instead
09:32:44 <Philippa> HugoDaniel: yeah, there've been big shifts in common usage (thus, which Named Language do we call Chinese, or at least Mandarin?) within living memory. Officially-enforced ones, IIRC
09:35:50 <HugoDaniel> yes, english is a good intermediate language, i dont speak it very well, and she doesn't either, but we can understand, the type system also helps a lot
09:36:40 <Philippa> *nod*
09:37:03 <Philippa> I guess it helps when most of the 'hard' words are subject jargon?
09:37:28 <zomg> chinese is an insane language. whoever thought making 100k different letters was a good idea... (ok they're not exactly letters, but you get the idea)
09:37:31 <zomg> =)
09:38:21 <`ramses> zomg: they'll probably say the same about western languages having insane amounts of words, wont they?
09:38:49 <zomg> they still have words and they are constructed from the characters so I don't really see the difference with that regard
09:39:16 <srhb> Chinese is like legos...
09:39:23 <`ramses> okay, I don't know chinese, but I'd think we'd have the same complexity somewhere else in the language
09:39:23 * srhb stops right there.
09:39:50 <zomg> `ramses: I think there's a reason why mandarin chinese is considered one of the hardest to learn languages in the world :)
09:40:16 <`ramses> by people used to western languages or also by e.g. japanese people?
09:40:29 <zomg> That is a good question
09:41:14 <zomg> Japanese is different from chinese, although they do share some parts of a writing system. I don't know if it's signficant enough though, I don't actually speak any chinese but I do speak japanese
09:42:25 <zomg> They might have less of a hurdle learning the writing system at least, though the same character in japanese is usually pronounced differently in chinese and may have a different meaning altogether
09:43:06 <`ramses> yeah, I'm just wondering whether it is so difficult because it's just different from what we know or because it is inherently complex
09:44:11 <`ramses> but I have no answer :) We should have a chinese person here to give some perspective
09:44:20 <zomg> I think there are other complexities in chinese besides just the writing system, like the tone used changing the meaning of the word etc.
09:44:31 <hiptobecubic> yes
09:44:37 <hiptobecubic> the tone problem is a huge one
09:45:01 <hiptobecubic> small differences that westerners have trouble picking out can completely change the meaning of things
09:45:07 <`ramses> again, is that difficult because we're not used to it, or do chinese people find that difficult as wel?
09:45:16 <`ramses> well*
09:45:53 <zomg> isn't it pretty much the same with all native speakers.. they don't really find it difficult
09:45:58 <zomg> at least that's what I would think
09:46:12 <hiptobecubic> it's being not being used to it. There were some interesting studies, which I have no links for of course, about how it was important to start listening to chinese when you were very young if you wanted any chance at real fluency
09:46:19 <hiptobecubic> it's beyond not*
09:46:51 <hiptobecubic> Also they found some correlation between musical skill and tonal language fluency
09:47:04 <`ramses> interesting :)
09:47:44 <`ramses> zomg: true, but then how would one capture the concept of language difficulty in an objective manner?
09:47:53 * geekosaur wonders if wikipedia can be trusted on this... "The government of the People's Republic of China in mainland China has promoted them for use in printing since the 1950s and 1960s in an attempt to increase literacy." re Simplified Chinese writing
09:48:37 <zomg> `ramses: not sure if you can :) only from a pov specific to certain groups of people
09:48:48 <Philippa> geekosaur: I suspect a better question is whether you need to trust it?
09:48:50 <`ramses> wow, it would be insane if some people just couldn't read the paper because their native language is too hard for them
09:48:51 <hiptobecubic> i don't think the government is trying to keep the populace illiterate. it's probably not a point of pride
09:48:57 <zomg> a native speaker will generally find their own language easy, I don't think there's any doubts about that
09:49:18 <zomg> they might find it challenging to *write* it according to all of the grammar rules, but besides that
09:49:38 <hiptobecubic> `ramses, i think it's about whether someone who hasn't gone through formal school will have any hope. Not the educated.
09:50:10 <Philippa> hiptobecubic: ...how educated is educated?
09:50:24 <Philippa> (English has lots of little corners it's easy to fuck up, especially if you have to be formal)
09:50:33 <Philippa> (but that's mostly due to its tendency to mug other languages)
09:50:35 <hiptobecubic> Philippa, Has had writing lessons in an actual school?
09:50:47 <`ramses> english writing is awful, nothing is written as it sounds
09:50:57 <hiptobecubic> blame the Great Vowel Shift
09:51:02 <Philippa> `ramses: that depends a lot on the accents involved
09:51:09 <hiptobecubic> which is apparently the fault of young women
09:51:23 <hiptobecubic> if all of this fuss about vocal fry has any merit
09:51:26 <`ramses> Philippa: isn't that pretty much true in general?
09:51:30 <Philippa> American English isn't written how it sounds pronounced in Britain. British English looks wrong to Americans...
09:51:31 <geekosaur> the great vowel shift and the headlong collision between north germanic and norman french orthography...
09:51:46 <hiptobecubic> Philippa, neither is written how they sound
09:51:46 <Philippa> but if you know a smidgeon of French as well then it's easy to see where all those us are
09:52:48 <`ramses> I know French, but that doesn't help me a lot imo
09:53:03 <hiptobecubic> it helps with some british spellings
09:53:05 <`ramses> (although I see the romanisms :))
09:54:35 <`ramses> HugoDaniel: look at what you did, suddenly we are discussing linguistics!
09:56:26 <ryspy> Hello, I got a question.
09:56:31 <srhb> ryspy: Ask.
09:56:48 <ryspy> I would like to create a cloud based service, is this possible (in concurrency wise) with haskell?
09:56:55 <Philippa> hiptobecubic: A lot of the other spelling problems are "this is not a native word" problems, I find
09:56:56 <ryspy> I know the architecture matters.
09:57:08 <srhb> ryspy: Yes.
09:57:10 <Philippa> (having an instinct for where a word was, er, appropriated from helps)
09:57:19 <`ramses> @faq can haskell create a cloud based service?
09:57:19 <lambdabot> The answer is: Yes! Haskell can do that.
09:57:20 <ryspy> Ok, thanks.
09:57:35 <ryspy> Woops, sorry 'ramses :(
09:57:41 <srhb> @faq Can Haskell be used to create a _concurrent_ cloud based service?
09:57:41 <lambdabot> The answer is: Yes! Haskell can do that.
09:57:44 <srhb> Ok, we're all good.
09:57:53 <ryspy> Sorry shrb.
09:57:55 <`ramses> ryspy: no worries, it's a joke ;)
09:57:59 <ryspy> oh ok :)
09:58:01 <srhb> Yeah, just kidding.
09:58:26 <ryspy> Ok, thanks for the awnsers and the jokes?
09:58:37 <srhb> ryspy: If you want to big research topic, I guess Cloud Haskell is it
09:58:44 <srhb> Some fun talks on it, too, if you want actors etc.
09:59:04 <srhb> Erm, the big*
09:59:09 <ryspy> Ok, thanks :)
09:59:11 <Philippa> but at the same time? If you know what your underlying model should look like, you can write it from the ground up as in any language and it'll come out better than most
09:59:26 <ryspy> Yea, probably :)
09:59:31 <Philippa> (introspection-flavoured things are maybe a little complicated compared to a language with completely native reflection, though)
10:03:05 <HugoDaniel> :) sorry
10:19:02 <Sam0> Hi
10:19:38 <Sam0> How do you initialize a matrix using numeric prelude?
10:19:59 <Sam0> in MathObj-Matrix
10:20:32 <Sam0> it is defined Data T a and I am not sure how to instantiate this since I am new to Haskell
10:22:24 <wuttf> Can I "cast" an instance of a typeclass to a concrete type?
10:22:40 <mauke> an instance of a typeclass is a concrete type
10:22:53 <wuttf> welll
10:23:02 <wuttf> you catch my drift dont ya
10:23:06 <neutrino> no
10:23:07 <mauke> no
10:23:10 <ktosiek> I do, no you can't
10:23:36 <ktosiek> well, maybe for Typeable or something like that
10:23:38 <neutrino> do you mean you have an instance declaration without the type being defined, and you want to create a type based on that?
10:23:45 <wuttf> ktosiek: Ouch! I can't believe it man.
10:23:59 <geekosaur> wuttf:  what are you really trying to do
10:24:08 <ktosiek> wuttf: why would you do that?
10:24:14 <geekosaur> (if I had to guess, you're trying to use them to do OOP and that won't work)
10:24:14 <wuttf> geekosaur: That will need a paste, wait for it
10:25:44 <wuttf> geekosaur: Yes, I am trying to use them to do OOP :D
10:26:07 <wuttf> How did you figure? :-)
10:27:32 <wuttf> I just need a  plain old unsafe OOP typecast from interface -> concrete type
10:27:57 <glguy> You shouldn't need those in OOP, either
10:28:30 <wuttf> I do :)
10:28:49 <mauke> no, you don't
10:28:52 <glguy> it just means your program is wrong, if you only support the concrete type then change your type to reflect that
10:28:58 <`ramses> wuttf: also in OOP that signals a bad design
10:29:17 <bos> you could always join #haskell over on freenode and ask snoyberg/join #warp
10:29:19 <bos> oops
10:29:31 <geekosaur> wuttf, for all that typeclasses look OO-ish, they really are not, and you will only come to grief trying to use them that way.  they're more of a principled way to support ad-hoc polymorphism.
10:31:01 <wuttf> I know my API is not perfect, but I have 3 types  a b and c, and you can obtain type c from b, b from a, but they obviously work only if they are all implemented by the same module, which is a reasonable expectation I think.
10:32:25 <wuttf> I made them to be a typeclass to give a unified interface to the vendor specific implementations
10:33:35 <wuttf> So yes, while it is not (entirely) type safe, it would allow me to get shit done incredibly fast.
10:34:24 <ktosiek> can't you add some additional functions to typeclass?
10:34:34 <ktosiek> or new constraints on your function?
10:35:57 <wuttf> ktosiek: I will think about that. So I can't typecast?
10:36:39 <mauke> wuttf: even if you could, it wouldn't help you
10:36:40 <geekosaur> no
10:36:43 <ktosiek> no, that would make type system almost useless
10:37:04 <wuttf> mauke, how come?
10:37:16 <mauke> wuttf: why do you think a cast would help?
10:37:33 * geekosaur notes that the entire notion of typecasting here indicates a fundamental misunderstanding of Haskell's type system
10:38:28 <glguy> wuttf: Perhaps you should paste a small example where you think you need a "cast" and someone can show you what to fix
10:38:49 <feliperosa> Hi, could someone help me here? I'm getting a strange (link it seems) error when trying to call functions from Database.HDBC.Sqlite3 and Database.SQLite. But at the same time (I don't know where it came from) I'm able to call functions from Database.Sqlite3. Has someone came across this problem?
10:38:53 <wuttf> mauke: I already explained. I have 3 typeclasses, related, but all 3 have to be imlemented by the same vendor to be useful to each other. An other vendor could implement again that 3 interfaces etc.
10:39:41 <mauke> wuttf: that explains nothing
10:39:48 <mauke> or at least nothing in relation to my question
10:40:08 <xplat> how do i check the color depth in Gtk?  it used to be Graphics.UI.Gtk.Gdk.Visual.visualGetBestDepth, but that doesn't seem to be around anymore
10:40:24 <wuttf> mauke: I know I have leaky abstractions here ;)
10:40:29 <feliperosa> The error is 'Unknown PEi386 section name '.text.unlikely' if that helps..
10:40:46 <mauke> wuttf: no, you seem to have some misconceptions about types and classes
10:41:15 <wuttf> mauke: Well, probably, I am trying to use typeclasses as OOP interfaces.
10:41:28 <geekosaur> and ads you have already been told, that does not work
10:41:29 <mauke> that won't work
10:41:47 <mauke> also, "OOP interfaces" might be a misnomer
10:41:59 <xplat> typeclasses are better at this than OOP interfaces, though
10:42:19 <xplat> at least you can make a 3-parameter typeclass that ensures your 3 things know how to work with each other
10:43:13 <xplat> (though this may not still be the best approach)
10:43:15 <wuttf> xplat: So thats what multiparam typeclasses are good for?
10:43:28 <xplat> wuttf: it's one of the things they're good for
10:43:56 <wuttf> Sounds frigging awesome, thanks for the pointer.
10:44:03 <wuttf> gtg
11:03:31 <arrg> [extreme newbie] prsLine :: String -> String   gets me an error (ghci 7.6.1) .  I mean a function that takes one str arg and returns a string arg -- what's wrong?
11:03:59 <sipa> arrg: can you put your code on hpaste.org ?
11:03:59 <mauke> "an error" is too vague. what is the error?
11:04:01 <hpaste> fragamus pasted “weird” at http://hpaste.org/81174
11:04:14 <arrg> Couldn't match type `String -> String' with `[Char]'
11:04:25 <mauke> arrg: no, what is the complete, actual error?
11:06:07 <hpaste> fragamus annotated “weird” with “weird (annotation)” at http://hpaste.org/81174#a81175
11:07:48 * hackagebot hsb2hs 0.1 - Preprocesses a file, adding blobs from files as string literals.  http://hackage.haskell.org/package/hsb2hs-0.1 (JohnMacFarlane)
11:08:59 <geekosaur> arrg, the partial error you indicated means that you're somewhere using a string where a function from string to string is expected, or vice versa.  you'll have to show actual code and the full actual error message for anyone to be able to say anything more
11:11:08 <fragamus> @hoogle HSbytestring
11:11:08 <lambdabot> No results found
11:12:06 <fmap> fragamus: ghc-pkg list bytestring?
11:12:25 <geekosaur> um?  that's probably the compiled library behind the bytestring package
11:15:24 <meiji11> hi, is there a way to relocate a freshly built ghc to a new directory?
11:15:54 <meiji11> I tried a straight copy followed by editing the shell scripts in my-ghc/bin, but it can't find libHS-ghc-prim*, or something to that effect
11:17:18 <meiji11> I also want/need to delete all documentation and lib/ghc-7.4.2/ghc-7.4.2 prior to doing it, to stay beneath quota
11:17:26 <hpaste> fragamus annotated “weird” with “weird (annotation)” at http://hpaste.org/81174#a81176
11:21:16 <fmap> fragamus: so my guess would be you import modules that compiled against different bytestring versions
11:21:28 <fragamus> yes that makes sense
11:21:38 <fragamus> I use multiple ones
11:21:47 <fragamus> but I don't like it
11:22:13 <fragamus> My cryptographic project made me do it
11:22:42 <Lethalman> if having a whole api with State with setters and getters on objects
11:22:45 <meiji11> ah, i think i figured out how to do it, nm
11:22:55 <fragamus> Funny thing is that GHC has no problem with it
11:22:55 <Lethalman> then any function with that monad can change the properties of objects
11:23:33 <Lethalman> isn't that to be considered a side effect from a caller perspective?
11:23:44 <Lethalman> e.g. I call a function doSomething :: State ...
11:24:01 <Lethalman> since it is in the state monad, it is supposed to change the set
11:24:03 <Lethalman> *state
11:24:42 <Lethalman> and the state may contain objects used between many functions
11:24:56 <Lethalman> doesn't that make reasoning about the code hard?
11:25:15 <Lethalman> I'm looking here in particular: http://www.hgamer3d.org/hgamer3d/Docs/HGamer3D-APIs-Base-Physics-Physics.html
11:25:29 <Lethalman> where there are setters and getters over objects that are stored in the state I believe
11:25:51 <xplat> not as hard as if you don't even know vaguely what state can get changed
11:25:56 <Lethalman> the MHGamer3D monad makes coding easier, but harder to reason about, right?
11:26:13 <byorgey> Lethalman: sounds about right
11:26:29 <tac> Lethalman: My guess, looking at the API, is that MHGamer3D is IO + some custom state.
11:26:40 <tac> A lot of APIs work that way.
11:26:51 <Lethalman> tac, and is that pure?
11:27:01 <tac> I think most people would say it's impure
11:27:08 <Lethalman> tac, yes it's a reader + state + io
11:27:23 <tac> Most any FFI library will be some kind of IO-able monad.
11:27:32 <byorgey> "pure" depends entirely on your point of view.
11:27:57 <Lethalman> that seems a very imperative style, doesn't that defeat the point of haskell somehow?
11:28:04 <tac> Yes and no.
11:28:26 <tac> Haskell allows you to package up a lot of things statelessly
11:28:36 <tac> Then, at the lowest level, MHGamer3D does all the heavy lifting.
11:28:51 <tac> All programs, at the lowest level, have some kind of IO need.
11:28:56 <Lethalman> of course
11:29:03 <xplat> it's hard to use a binding to an imperatively-styled C library in a non-imperative style
11:29:19 <tac> The advantage of Haskell is that you can "abstract" away much (not all) the statefulness of your app
11:29:21 <Lethalman> xplat, tac, I can understand that
11:29:49 <Lethalman> but can be there a way to separate the object state from the IO stuff somehow?
11:29:55 <Lethalman> instead of mixing everything in a single powerful monad
11:30:04 <tac> in theory, yes
11:30:07 <Lethalman> because that's going to be a little pointless to me
11:30:11 <tac> however, there are often limitations of the underlying FFI
11:30:21 <xplat> you can actually hide some capabilities of a monad also
11:30:35 <applicative> @tell dcoutts could this output be a bug in bytestring http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=fasta&lang=ghc note that two others fail similarly http://benchmarksgame.alioth.debian.org/u32/benchmark.php?test=fasta&lang=all They clearly didn't used to do this.
11:30:35 <lambdabot> Consider it noted.
11:30:40 <tac> for a physics engine... the underlying C lib often makes the assumption you only need ONE instance (per process)
11:30:42 <xplat> so that you only get the sequencing and don't 'see' the ability to use IO in some high-level functions
11:30:48 <tac> You can't create multiple engine instances, each with its own state.
11:30:56 <tac> (again, depending on the library)
11:31:47 <Lethalman> tac, I got it, but I'm still a little disappointed after reading several libraries with very nice apis, and then seeing something like that mixing everything in a single monad
11:31:49 <xplat> (you do this by being polymorphic in the monad)
11:32:16 <Lethalman> that is if you start using MHGamer3D, most of your app is going to use it
11:32:25 <xplat> so you can mix in things that don't need to touch the 3D engine state or IO in as pure code
11:33:01 <xplat> and things that do need to touch the 3D state but don't need to know the details you can do as polymorphic monadic code
11:33:04 <soneri> hello
11:33:07 <soneri> !list
11:33:07 <monochrom> soneri: http://okmij.org/ftp
11:33:20 <xplat> (or using an abstract monad or other ways of hiding it)
11:33:56 <Lethalman> xplat, mh I believe I'm still too newbie to understand these things
11:34:11 <Lethalman> of course you can still call functions that do not use MHGamer3D
11:34:12 <tac> Lethalman: Keep in mind, Haskell is a language full of ideals. But ideals are rarely met.
11:34:21 <meiji11> is there a way to regenerate package.cache?
11:34:25 <meiji11> in a ghc build?
11:34:46 <tac> Most libraries on Hackage are cobbled together, the same as any open source software. And how good the library is is going to be a product of how talented the developer was
11:34:53 <tac> and how dedicated they were to making that package great
11:36:11 <Lethalman> for example the gui uses the same monad: http://www.hgamer3d.org/hgamer3d/Docs/HGamer3D-APIs-Base-GUI-BasicGUI.html
11:36:23 <Lethalman> wouldn't it be better to use a monad only for the gui?
11:36:30 <meiji11> ghc-pkg recache, that did it.
11:36:31 <Lethalman> (assuming the developer had the time to do it)
11:37:00 <tac> Lethalman: the more monads you have, the more boilerplate you're going to have
11:37:01 <Philippa> Lethalman: or at least different monads for different things, and subject to communication overhead between the two computations
11:37:06 <tac> converting between monads must be explicit.
11:37:28 <Philippa> (or whatever we call it when you start yoinking computation-continuations outside into 'normal' Haskell)
11:37:33 <Lethalman> tac, but only one monad is going to be exact the same to c or java
11:37:44 <tac> yes
11:37:47 <Lethalman> :S
11:37:52 <tac> But
11:38:03 <tac> The difference is, how you USE the library can still be done in a more proper way :)
11:38:16 <Lethalman> tac, same goes for c or java
11:38:25 <tac> but it's not enforced by the type system
11:38:27 <Philippa> Not the /exact/ same. You can construct the C- or Java-like language you want to use
11:38:43 <Philippa> which might have pointedly limited abilities in some regards and highly useful ones in others
11:38:46 <tac> I must go for now :)
11:39:07 * Lethalman full of doubts now
11:39:38 <Philippa> Working with monads is complicated and subtle, because you're effectively doing language design :-)
11:40:36 <Lethalman> Philippa, but after seeing this, and a library similar to that hgamer3d in another language, what's the gain in using haskell?
11:42:00 <Philippa> Lethalman: you get to use Haskell. That, and there's nothing stopping you doing huge chunks of pure stuff inside that one monad
11:42:13 <Philippa> return is a very, very important function that many people don't fully understand!
11:42:28 <Philippa> (which is to say: most people understand what it does just fine, just not the ramifications for program design)
11:44:02 <tac> to be sure, the FFI libraries tend to be very light wrappers over the underlying C code.
11:44:08 <tac> If you want beauty, you have to build it yourself :)
11:44:28 <Philippa> yeah. Which doesn't make the FFI libs useless: they enable people to choose their own idea of beauty!
11:52:29 <Lethalman> tac, Philippa, for example the accelerate/gpu libraries are very neat in that regard, as they abstract very well the operations to the underlying IO
11:52:50 <Lethalman> that is the first build the whole thing and then send them to the processing unit
11:52:57 <Lethalman> maybe this is different in the case of interactive systems
11:53:47 <Lethalman> or web frameworks do it good to as far as I saw
11:54:52 <Philippa> Lethalman: interactive systems are something that's seeing much active research still. There's a good reason to have libs aimed at a level that doesn't force choices
11:55:17 <Philippa> so the idea'd be to rig up your low-to-medium-level graphics/external interface libs to eg your chosen FRP lib
11:55:53 <Lethalman> Philippa, so FRP could be glued around that MHGamer3D too somehow?
11:56:16 <Philippa> talk to someone who does that stuff more actively :-)
11:56:27 <Lethalman> :)
11:56:34 <mm_freak_> Lethalman: do you have a main loop?
11:56:37 <pome> i'm pretty familiar and proficient with haskell, looking to learn more about curry-howard, proofs-as-programs &c. i have a basic knowledge of lambda calculus, but i assume not enough so. can anyone suggest some reading?
11:57:27 <Lethalman> mm_freak_, not in practice :P I'm just reading that lib, and was curious about its design
11:57:43 <Lethalman> mm_freak_, but yes, I think there's a main loop
11:57:52 <mm_freak_> Lethalman: whenever you have at least one main loop, you can use FRP =)
11:58:35 <Lethalman> mm_freak_, great, and would it make that MHGamer3D less... full of side-effects?
11:58:49 <Lethalman> or better, make the programmer less prone to use it directly
11:59:02 <Philippa> the latter
11:59:13 <Philippa> side-effects in your substrate aren't a problem if you don't have to reason about them
12:00:11 <srruby> Parsec: why do I have to do both:  import Text.Parsec   and import Text.Parsec.String(Parser) to get Parser ?
12:00:24 <Lethalman> Philippa, sorry, by substrate you mean the frp glue?
12:00:54 <srruby> and how can I even tell what import Text.Parsec imports?
12:01:45 <Philippa> Lethalman: and the libs it's talking to in order to get stuff done. Everything 'below' the code you're writing, design-wise
12:03:41 <Lethalman> mh ok thanks
12:04:15 <Peaker> how is hackage down so much? :-(
12:04:51 <sclv> practice
12:06:49 <Letchik> Why does drop function in ghci work like that? http://pastebin.com/bamS2rC8
12:06:49 <Letchik> Is there in haskell some maxint number that if I go over, it counts from 0 again?
12:06:57 <mauke> The paste bamS2rC8 has been copied to http://hpaste.org/81181
12:07:14 <byorgey> Letchik: yes, if you are using Int
12:07:17 <mauke> > maxbound :: Int
12:07:19 <lambdabot>   Not in scope: `maxbound'
12:07:19 <lambdabot>  Perhaps you meant `maxBound' (imported from Prelu...
12:07:24 <mauke> > maxBound :: Int
12:07:25 <lambdabot>   9223372036854775807
12:07:43 <byorgey> Letchik: and drop does indeed use Int
12:07:50 <byorgey> > 2^32
12:07:51 <lambdabot>   4294967296
12:07:51 <Lethalman> > 2^63
12:07:53 <lambdabot>   9223372036854775808
12:08:04 <byorgey> looks like Letchik has a 32-bit machine
12:08:16 <byorgey> or a 32-bit OS, or whatever
12:08:18 <Lethalman> byorgey, mh no, more like a 64 bit machine :)
12:08:25 <Lethalman> byorgey, that's a 64 bit Int
12:08:38 <Letchik> byorgey: not really, but ghci's changelog said that x64 is supported only since last version, which doesn't work somewhy.
12:08:44 <Letchik> Or was that only for windows.
12:09:04 <byorgey> oh, hmm
12:09:11 <byorgey> > logBase 2 49392123904
12:09:12 <lambdabot>   35.523561956057016
12:09:17 <byorgey> huh
12:09:31 <Letchik> Then why does the next number after that not drop anything too?
12:09:41 <Letchik> It should be negative then, right?
12:09:46 <Lethalman> ah that seemed big to me
12:09:47 <`ramses> Lethalman: the two lines both truncate the whole list on my 64bit machine, though
12:09:47 <Letchik> And must make exception.
12:09:55 <byorgey> no
12:09:58 <Letchik> Or error.
12:09:58 <byorgey> > drop (-5) [1,2,3]
12:10:00 <lambdabot>   [1,2,3]
12:10:05 <byorgey> > drop (-10) [1,2,3]
12:10:07 <lambdabot>   [1,2,3]
12:10:10 <byorgey> it's not an error
12:10:20 <Letchik> It's error for me.
12:10:23 <byorgey> negative arguments to drop act just like 0
12:10:33 <byorgey> Letchik: what error?
12:10:38 <Letchik> http://pastebin.com/MfnjTsDJ
12:10:40 <mauke> The paste MfnjTsDJ has been copied to http://hpaste.org/81182
12:10:40 <hpaste> srhb pasted “Type default?” at http://hpaste.org/81183
12:10:55 <byorgey> Letchik: you need parentheses around (-1)
12:10:59 <hpaste> srhb annotated “Type default?” with “Type default? (annotation)” at http://hpaste.org/81183#a81184
12:11:00 <Letchik> oh, right
12:11:02 <Letchik> sorry
12:11:14 <byorgey> Letchik: drop -1 [1,2,3,4,5] parses as   drop - (1 [1,2,3,4,5])
12:11:15 <Letchik> I see now.
12:11:20 <srhb> Could someone tell me what I'm missing in the above annotation? (There's a typo in the original)
12:12:17 <shapr> Any recommendations for good RGB data types with lots of typeclass instances?
12:12:27 <byorgey> srhb: how is Centi defined?
12:12:40 <Letchik> It's silly that such high level language allows such things instead of telling you about error.
12:12:41 <byorgey> shapr: have you looked at the  colour  package?
12:12:58 <shapr> byorgey: I have, was wondering if it's better than AC-colour ?
12:13:19 <srhb> byorgey: Um, I'd have to check Data.Fixed. It's something like Fixed E2
12:13:41 <byorgey> shapr: way, way better, assuming you want something that actually Does Color Right
12:13:41 <srhb> Yes, type Centi = Fixed E2
12:13:55 <byorgey> shapr: if you don't really care whether it's right and just want something convenient, then I don't know
12:15:01 <shapr> byorgey: I want a convenient RGB datatype that I can use to fade/interpolate an LED value for an Arduino.
12:15:06 <shapr> But I'll start with colour, thanks!
12:15:09 <byorgey> srhb: in the first one,  1 :: Integer.  In the second, 1 :: Centi.
12:15:34 <srhb> byorgey: So the first one should fail?
12:15:45 <srhb> Ah no.
12:16:00 <`ramses> srhb: div' gives an Integer, so the other argument to (+) should be Integer as well
12:16:04 <byorgey> srhb: in the second one it infers the type   div' :: Centi -> Centi -> Centi
12:16:06 <srhb> Hmm. Okay, so how come in the second one the arguments to div' don't simply become set as Centi?
12:16:16 <byorgey> and then rightly complains that there's no Integral instance for Centi
12:16:20 <srhb> oh..
12:16:24 <srhb> Aha, thanks.
12:16:35 <byorgey> div' :: (Real a, Integral b) => a -> a -> b
12:16:47 <srhb> Yep, got it. :-)
12:16:52 <`ramses> ah sorry, misguided by the type annotation..
12:19:18 * Canar pouts at Hackage.
12:19:40 <bgamari> dcoutts_, am I correct that there is currently no hint of sandbox support exposed by cabal-install on the master branch?
12:22:33 <srruby> Parsec: How can I access the string that was parsed?
12:22:46 <magic_> Hello everyone!
12:23:41 * bgamari pokes frantically at the motionless remains of Hackage
12:23:59 <geekosaur> @where hackage-mirror
12:24:00 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
12:24:12 <luite> \o/
12:24:14 <srhb> It seems to be dying a lot these days.
12:24:21 <srhb> Every time the Americans come home from work.
12:24:25 <bgamari> geekosaur, thanks
12:24:27 <luite> it's a new server, please report problems if hdiff doesn
12:24:32 <geekosaur> srruby, how did you parse it?  (normally you return the part(s) you want, or some representation thereof)
12:24:32 <luite> t work as expected
12:25:57 <shachaf> @remember edwardk <edwardk> UpStar and downstar need names that don't suck <donri> RisingStar ShootingStar <edwardk> by not sucking i meant, shorter ;)
12:25:57 <lambdabot> It is stored.
12:26:01 <srruby> geekosaur - I'm parsing it using various parsers... I'm returning a representation. Is there an easy way to grab the characters that were consumed?
12:26:30 <Canar> luite: how do i get documentation out of that?
12:26:35 <geekosaur> not without saving them somehow
12:26:57 <aristid> shachaf: why not just give dstcruz a text file each month, with the best lens quotes only.
12:27:09 <Philippa> though if you've already got the source text elsewhere, all you need from the parser is a position in it
12:27:15 <luite> Canar: not yet, you can build your local haddock of source :)
12:27:20 <luite> of course
12:27:21 <Philippa> (albeit possibly counted in characters rather than (line, column)
12:27:23 <Philippa> )
12:27:30 <geekosaur> (parsec automaticaly saving everything it parsed would lead to massive space leaks, since most programs don't care about it beyond the parts they themselves record in ASTs or whatever)
12:27:32 <shachaf> aristid: I see no reason to restrict ourselves to the good ones.
12:27:47 <Canar> luite: not much of a proper mirror :/
12:27:59 <aristid> shachaf: well, that means you select, not dstcruz :)
12:28:20 <srruby> geekosaur - I thought I saw a parser wrapper that would give me the characters consumed.
12:28:35 <srruby> but now I can't find it.
12:37:58 <magic_> Is there a good book about data structures in haskell?
12:38:14 <Peaker> Any Haskell bindings for any speech recognition library/program?
12:41:08 <bgamari> ?okasaki
12:41:08 <lambdabot> Unknown command, try @list
12:41:13 <ParahSailin> is hackage.haskell.org down?
12:41:27 <bgamari> magic_, See Okasaki's Purely Functional Data Structures
12:41:29 <bgamari> ParahSailin, Yes
12:41:41 <ParahSailin> is there a mirror?
12:43:41 <geekosaur> @where hackage-mirror
12:43:41 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
12:44:33 <ParahSailin> thanks
12:46:27 <ParahSailin> its not quite exact mirror though: http://hackage.haskell.org/packages/archive/Cabal/1.14.0/Cabal-1.14.0.tar.gz => http://hdiff.luite.com/packages/archive/Cabal/Cabal-1.14.0.tar.gz
12:46:48 <ParahSailin> so i can't sub it into the bootstrap.sh for cabal
12:47:03 <luite> ParahSailin: nah it does work
12:47:06 <luite> or at least it should
12:47:35 <luite> oh crap it doesn't
12:48:15 <`ramses> cabal update hangs here with that mirror
12:48:29 <NemesisD> any of you guys use aeson?
12:48:38 <ion> I have used it.
12:48:47 <Clint> i have
12:48:59 <luite> `ramses: hmm, i moved hdiff to a new server, it uses nginx now, i might have made a mistake
12:49:15 <geekosaur> [23 15:24] <luite> it's a new server, please report problems if hdiff doesn t work as expected
12:49:53 <luite> right, i'm looking into it now
12:50:33 <`ramses> luite: thanks for the effort :)
12:50:46 <`ramses> oh, now it does finish!
12:51:12 <`ramses> it tried a couple of times before and it was always stuck for minutes, now it does seem to work
12:51:31 <hpaste> NemesisD pasted “unwrapping json objects” at http://hpaste.org/81186
12:52:20 <NemesisD> i've gotten stuck. i need to unwrap a response, so i write a FromJSON instance for a throwaway newtype, but it doesn't seem to extract the toplevel "arguments" key
12:53:35 <geekosaur> the way you unwrap a FromJSON is with decode normally, I thought?
12:56:37 <NemesisD> geekosaur: i am trying to do it with cascading instances basically. a response looks like this: {"arguments":???}, so I write: instance RPCResponse a: parseJSON (Object v) = RPSuccess <$> v .: "arguments"
12:56:57 <NemesisD> so whatever 'a' is needs a FromJSONstance for whatever is under the "arguments" key
12:57:53 <NemesisD> and i don't really want to define an instance for [Torrent], so i created a newtype TorrentList so it can have its own instance, which I can then unwrap into [Torrent]
12:57:55 <ion> nemesisd: If you don’t mind a bit more ad-hoc way of parsing JSON and if the document isn’t too big, try something like: foo :: Value -> [Torrent]; foo = [ Torrent torrent | Object obj <- universeOf uniplate val; Array torrents <- obj ^.. ix "torrents"; String torrent <- toList torrents ]; bar = foo <$> eitherDecode jsonData
12:58:22 <ion> foo val = [ … that is
12:58:46 <NemesisD> universeOf uniplate? im not familiar with these
12:58:51 <ion> That’s from lens
12:59:11 <ion> Control.Lens and Data.Data.Lens
12:59:26 <NemesisD> hmm, the thing i like about my aproach is you don't have to write anything beyond typeclass instances
12:59:49 <ion> But you’ll probably need more boilerplate with the typeclass instances.
13:00:12 <ParahSailin> Setup: At least the following dependencies are missing:
13:00:13 <ParahSailin> base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6
13:01:10 <NemesisD> ahh wait i think i figured it out
13:01:34 <luite> ParahSailin: is that really the original location?
13:02:13 <luite> the archive layout is a little different from the original hackage, but i added a rewrite rule so all urls still work
13:02:15 <ParahSailin> luite: it's probably not your fault
13:02:28 <feliperosa> is hackage offline?
13:02:29 <luite> but it seems that cabal is served from multiple locations
13:02:39 <luite> ParahSailin: where did you find this url?
13:03:55 <ParahSailin> im trying to install ghc 7.6.1 straight from the distribution without bootstrapping with local 7.4.2
13:04:01 <ParahSailin> trying to build cabal
13:04:10 <ParahSailin> cabal-install to be exact
13:04:19 <NemesisD> ion: i think i wanted instead of doing parseJSON (Object v) = RPCSuccess <$> v .: "arguments", something like parseJSON (Object v) = RPCSuccess <$> (parseJSON <$> v .: "arguments")
13:04:38 <feliperosa> Hey guys, could you please check if you can connect to hackage.haskell.org?
13:04:47 <srhb> feliperosa: It's pretty much down.
13:04:48 <geekosaur> feliperosa, it's known to be down
13:04:52 <NemesisD> compiler doesn't seem to like it though
13:05:23 <CorkExaminer> hackage is down
13:05:32 <feliperosa> thank you guys :)
13:06:23 <NemesisD> ion: it only seems to work with parseJSON =<< v .: "arguments" but it doesn't seem to solve my problem
13:09:42 <edwardk> :t iso
13:09:43 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (b -> t) -> k (a -> f b) (s -> f t)
13:09:52 <edwardk> preflex: xseen cale
13:09:53 <preflex>  cale was last seen on freenode/#haskell 1 day, 20 hours, 14 minutes and 24 seconds ago, saying: Yeah
13:10:07 <edwardk> he's been hiding out from the lens revolution
13:10:29 <Taneb> That's an old iso
13:10:31 <ion> lambdabot *still* has the ancient version of lens‽ The new one has been out for, like, ages.
13:10:52 <hpaste> NemesisD annotated “unwrapping json objects” with “unwrapping json objects (annotation)” at http://hpaste.org/81186#a81187
13:11:18 <Cale> edwardk: okay okay
13:11:18 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:11:26 <edwardk> =)
13:11:44 <edwardk> we're needy bastards
13:12:37 <edwardk> cale: also Control.Exception.Lens would be an awesome addition to lambdabot
13:12:44 <edwardk> (as would Numeric.Lens)
13:12:56 <NemesisD> ion: do you see what approach i'm taking there?
13:12:57 <edwardk> both avoid conflicting with common names and make good introductions to prisms
13:13:21 <Cale> edwardk: cabal update is taking forever
13:13:57 <Cale> okay
13:14:06 <NemesisD> the "arguments" key I specify in the type is entirely ignored. i changed it to something bogus and it doesn't come up in the parse error
13:14:13 <mauke> @where hackage-mirror
13:14:14 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
13:14:30 <Cale> Any other Haskellers playing the Path of Exile open beta?
13:14:43 * ion googles
13:14:48 <edwardk> i thought the path to exile started when you learned haskell.
13:14:52 <Cale> hah
13:15:17 <edwardk> or maybe thats the path to enlightenment. i always get the two confused.
13:15:22 <NemesisD> ion: lol, if i replace RPCResponse a's impelmentation of parseJSON with error . show, it doesn't blow up. that code is not being called
13:15:55 <NemesisD> i think type inference is messing me up here
13:16:05 <Cale> http://www.downforeveryoneorjustme.com/hackage.haskell.org
13:16:25 <ion> Why doesn’t hackage have redundancy?
13:17:27 <NemesisD> who pays for hackage?
13:18:06 <ion> nemesisd: I’d need to debug the code myself to see what exactly is wrong.
13:18:07 <edwardk> right now i believe server resources come out of haskell.org funds. there has been talk of using a CDN, etc. for it
13:18:24 <edwardk> but that would be an interesting development project
13:19:18 <luite> ParahSailin: i added an extra rewrite rule to also serve files from those locations
13:21:53 <luite> `ramses: do you have a broken ipv6 config?
13:22:12 <`ramses> luite: I have a working ipv6 config..
13:22:16 <ParahSailin> how do i rebuild everything after i updated cabal config to enable library profiling
13:22:28 <ion> You can get a free CDN from http://www.cloudflare.com/
13:22:29 <`ramses> luite: a sixxs tunnel
13:22:50 <luite> `ramses: hmm, can you check that you can reach hdiff.luite.com over both v4 and v6?
13:23:08 <ion> It will work as a caching proxy against your server. You’ll just point your domain name’s A/AAAA records to them.
13:23:15 <`ramses> luite: you saw my comment above about it working now?
13:23:38 <luite> `ramses: yeah i was wondering if it tried v6 first and then v4 as a fallback, that could cause some delays
13:23:41 <ion> (Or perhaps you had to use their DNS servers.)
13:23:54 <`ramses> luite: that domain has no aaaa record
13:24:15 <luite> oh what... i guess i forgot some configuration then...
13:24:17 * geekosaur just tried that and found the same thing
13:24:46 <ion> I suppose one could switch hackage to that in, like, 15 minutes.
13:24:55 <geekosaur> modulo dns caching
13:25:15 <ion> sure
13:25:23 <luite> `ramses: ah you're right, only hdiff-test.luite.com has an ipv6 atm, i forgot to add the real one
13:25:44 <`ramses> I can indeed ping6 that one
13:27:08 <luite> k hdiff also has an AAAA record now
13:27:33 <NemesisD> wooot got it
13:28:47 <`ramses> luite: I can reach it over ipv6 indeed :)
13:28:53 <ornicar> is hackage down?
13:28:59 <luite> `ramses: k great
13:29:13 <Moggle> Anyone here have any familiarity with wxHaskell on Windows? I've got everything built easily, but all my compiled programs fail to start with 0xc000005 or whatever the error is.
13:29:52 <ParahSailin> how do i rebuild entire cabal library with library profile enabled on everything
13:30:20 <luite> ParahSailin: add library-profiling: True to your .cabal/config, remove ~/.ghc, reinstall EVERYTHING!
13:31:15 <ParahSailin> luite: when i remove .ghc i cant build anything
13:31:51 <`ramses> luite: I just checked with wireshark and cabal seems to prefer v4 anyway
13:32:13 <pw_> Hi, is hackage down now?
13:32:17 <luite> `ramses: ah i guess it is still a safer choice :)
13:32:21 <ornicar> it's down for me :(
13:32:41 <geekosaur> pw_, yes
13:32:51 <geekosaur> @where hackage-mirror
13:32:51 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
13:32:52 <pw_> too bad, any news for that?
13:33:21 <`ramses> luite: hmm, although I'd like it to use v6 when available, like most applications seems to do nowadays
13:34:36 <ornicar> geekosaur: thx for the mirror link
13:36:39 <pw_> the mirror works, thanks.
13:42:26 <parcs> Cale: i am!
13:42:39 <Cale> parcs: awesome :)
13:42:47 <Cale> <-- diamond supporter :)
13:43:21 <parcs> Cale: as soon as it finishes downloading. it's really silly that they made the new patch available only 2 hours before the start of OB
13:44:22 <Cale> Yeah, under Wine, there's a bug which makes Allocating Space take a very long time sometimes, and in this case, it took about an hour. I'm done downloading just now :)
13:45:08 <parcs> heh, it takes awfully long under windows too. not that long though
13:45:17 <wellnoidea> Hello there.
13:45:36 <Cale> Hello!
13:46:08 <edwardk> :t iso
13:46:09 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (b -> t) -> k (a -> f b) (s -> f t)
13:46:28 <glguy> hackage is back :)
13:47:04 <Cale> apparently not back enough...
13:53:40 <ParahSailin> @hoogle catch
13:53:41 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
13:53:41 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
13:53:41 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
13:54:13 <ParahSailin> how come i get Bio/GFF3/FeatureHierSequences.hs:75:54: Not in scope: `catch' when building bio
13:54:19 <donri> but hackage is up again, what are you people talking about
13:54:23 <geekosaur> that's slightly out of date; catch is no longer in Prelude in 7.6
14:05:36 <ParahSailin> how do i specify that i want Data.HashTable from package hashtables
14:07:07 <applicative> it doesn't have a module Data.Hashtable
14:08:00 <ParahSailin> @hoogle fromList
14:08:00 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
14:08:00 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
14:08:00 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
14:09:24 <applicative> I think you are to use one of the specific implementations in hashtable package
14:09:55 <ParahSailin> i just want it to not tell me "Data.HashTable will be removed in GHC 7.8. Please use an alternative, e.g. the hashtables package, instead."
14:10:35 <ParahSailin> is there a way to specify that i do have hashtables installed and that i want it to use that one?
14:11:14 <glguy> ParahSailin: Pick a module that hashtables provides
14:11:45 <ParahSailin> ah, not Data.HashTable, but Data.HashTable.Class?
14:14:02 <geekosaur> no, that looks to be the shared component between Data.HashTable.IO and the ST-based variants
14:14:37 <geekosaur> it is *possible* that Data.HashTable.IO is what you want, but I don't know how much porting your code would require and it sounds like nobody else active here does either
14:15:48 <ParahSailin> geekosaur: no i already am using hashtables package
14:16:06 <ParahSailin> i just had an import of some other Data.HashTable in there too
14:16:30 <ParahSailin> it built without warning on ghc 7.4.2, but on upgrade i needed to get rid of that
14:16:41 <geekosaur> then I think you're going to have to sort it out yourself
14:17:46 <ParahSailin> geekosaur: already done, it was as simple as adding .Class at the end
14:18:08 <uniquenick> what is the process for dealing with "someone uploaded something to hackage, and now it needs trivial changes to build and the maintainer dissapeared"?
14:18:14 <geekosaur> I wonder how true that is, but whatever
14:19:00 <geekosaur> uniquenick, might be best to ask that on the haskell-cafe mailing list, but if the maintainer has disappeared then anyone can upload a new version
14:19:49 <uniquenick> I can upload new versions of other people's stuff?
14:20:02 <applicative> I think this is likely to cause trouble
14:20:14 <fragamus> hey guys I have a data structure that I need to serialize BUT there is massive duplication… I think I need something that performs multiple passes over the data structure to identify leaves and convert them into a hash that can serve as a reference in the data stream, all the while building a hash map
14:20:15 <applicative> what is the package?
14:21:35 <geekosaur> that's why I said ask first on the mailing list...
14:21:58 <uniquenick> I haven't tried getting in touch with the maintainer yet, I was just wondering how it is handled
14:25:31 <geekosaur> then you should get in touch with the maintainer
14:28:07 * hackagebot rematch 0.1.1.0 - A simple api for matchers  http://hackage.haskell.org/package/rematch-0.1.1.0 (TomCrayford)
14:28:09 * hackagebot digestive-functors 0.6.0.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.6.0.0 (JasperVanDerJeugt)
14:28:11 * hackagebot digestive-functors-blaze 0.6.0.0 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.6.0.0 (JasperVanDerJeugt)
14:29:17 <geekosaur> but yes, the current hackage is a bit lame about that
14:29:22 <geekosaur> (among many other things(
14:33:13 * hackagebot digestive-functors-snap 0.6.0.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.6.0.0 (JasperVanDerJeugt)
14:33:15 * hackagebot digestive-functors-heist 0.6.0.0 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.6.0.0 (JasperVanDerJeugt)
14:33:17 * hackagebot digestive-functors-happstack 0.6.0.0 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.6.0.0 (JasperVanDerJeugt)
14:33:19 * hackagebot preprocessor-tools 1.0 - A framework for extending Haskell's syntax via quick-and-dirty preprocessors  http://hackage.haskell.org/package/preprocessor-tools-1.0 (JesseTov)
14:33:21 * hackagebot hbro 1.1.0.0 - Minimal KISS compliant browser  http://hackage.haskell.org/package/hbro-1.1.0.0 (koral)
14:33:24 <`nand`> digestive functors?
14:38:10 <applicative> which part of digestive functors dont you understand `nand`
14:38:23 <applicative> which part of "digestive functors" dont you understand `nand`
14:38:23 * hackagebot hbro-contrib 1.1.0.0 - Third-party extensions to hbro.  http://hackage.haskell.org/package/hbro-contrib-1.1.0.0 (koral)
14:38:25 * hackagebot preprocessor-tools 1.0.1 - A framework for extending Haskell's syntax via quick-and-dirty preprocessors  http://hackage.haskell.org/package/preprocessor-tools-1.0.1 (JesseTov)
14:39:08 <cloudhead_> hey anyone here use Hedis? need some help understanding the return types
14:39:08 <applicative> hm, I sent patches to 'preprocessor-tools' months ago....
14:40:12 <SamanthaD> Hello!
14:40:21 <shachaf> hi SamanthaD
14:40:26 <applicative> hi SamanthaD
14:40:39 <shachaf> hi applicative
14:40:39 <SamanthaD> I need help with category theory ;_;
14:40:59 <applicative> 1) composition must be associative
14:41:06 <shachaf> Whatcha category-theorizin' for?
14:41:10 <applicative> hi shachaf
14:41:25 <SamanthaD> shachaf: I'm trying to grok functors
14:41:37 <applicative> 2) you need an id
14:41:44 <`nand`> applicative: the part where I had no idea what they were, before I opened the haddock page
14:42:03 <shachaf> SamanthaD: In Haskell or in category theory?
14:42:11 <applicative> `nand`: it is a truly amazing package name
14:42:17 <SamanthaD> shachaf: I want to know how they apply to Haskell
14:42:18 <SamanthaD> here
14:42:31 <shachaf> The Haskell class Functor is a pretty restricted thing compared to CT functors. You don't need to understand the latter to understand the former.
14:42:55 <SamanthaD> My question is that a functor f: A -> B is a function such that all of the objects AND arrows in A get translated in some regular way to B
14:42:59 <applicative> in category theory the typical functor takes you from one category to another.
14:43:12 <applicative> right
14:43:24 <tac> SamanthaD: You can also try ##categorytheory for CT help
14:43:38 <applicative> oooooh ##categorytheory
14:43:42 <shachaf> SamanthaD: Well, there are two different things, the thing that maps objects and the thing that maps arrows.
14:44:20 <SamanthaD> applicative: That's what I mean. In category theory the functor takes you from one category to another by translating the objects and the arrows. But fmap seems to only translate objects and it can't change the structure of the data (which you would expect a functor to be able to do through the manipulation of arrows unless I'm not understanding it).
14:44:39 <applicative> no, fmap translates the (Haskell) arrows, no
14:44:40 <shachaf> SamanthaD: Here, the source and target category are both the same one.
14:44:41 <applicative> ?
14:44:49 <shachaf> (It'd be called an endofunctor.)
14:44:59 <SamanthaD> tac: Thanks, I'm really interested specifically in fmap at this point though.
14:45:11 <shachaf> So for example: chr :: Int -> Char; Maybe is a Functor; fmap chr :: Maybe Int -> Maybe Char
14:45:26 <applicative> SamanthaD: but it is a little confusing, that Functor means EndoFunctor so to say
14:45:46 <applicative> the category theory primer's account will include a distracting generality
14:46:06 <applicative> I mean, Haskell Functor might as well have been called EndoFunctor
14:46:07 <shachaf> SamanthaD: (Note: If your goal is to learn Haskell, category theory is probably not the best way.)
14:46:11 <SamanthaD> applicative: so, when I see haskell functors I should think "category theory endofunctor"
14:46:20 <applicative> yes
14:46:35 <applicative> well, it a particular category we're talking about of coursze
14:47:02 <applicative> a monad in the general category theory sense is always an 'endofunctor'
14:47:08 <shachaf> Not every endofunctor is an instance of Functor, either.
14:47:35 <tac> SamanthaD: The people in Category Theory most likely know Haskell very well
14:47:39 <Philippa-> SamanthaD: Haskell's Functors have parametricity to contend with
14:47:51 <Ralith> byorgey: are you familiar with OpenGL in the context of colour?
14:47:54 <SamanthaD> okay, maybe I should ask the question that brought me to this whole thing in the first place: What the heck is the difference between fmap and map?!
14:48:05 <tac> But fmap is basically just a function that preserves id   (ie: fmap id = id) and that preserves composition   (ie: fmap (f . g) = fmap f . fmap g)
14:48:05 <Ralith> :t fmap
14:48:07 <Ralith> :t map
14:48:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:48:08 <lambdabot> (a -> b) -> [a] -> [b]
14:48:08 <Philippa-> SamanthaD: map is specialised to []
14:48:09 <applicative> map is fmap where the functor is []
14:48:38 <SamanthaD> Philippa: Okay, that makes sense. Thank you.
14:48:43 <Philippa-> I suspect it's not called mapList due to hysterical raisins
14:48:59 <shachaf> > fmap (+1) [1,2,3]
14:49:01 <lambdabot>   [2,3,4]
14:49:02 <shachaf> > map (+1) [1,2,3]
14:49:03 <lambdabot>   [2,3,4]
14:49:06 <shachaf> > fmap (+1) (Just 5)
14:49:07 <lambdabot>   Just 6
14:49:09 <shachaf> > map (+1) (Just 5)
14:49:10 <applicative> we should have mapMaybe mapIO map...
14:49:10 <lambdabot>   Couldn't match expected type `[b0]'
14:49:10 <lambdabot>              with actual type `Data.May...
14:49:22 <shachaf> We have mapMaybe!
14:49:24 <shachaf> @ty mapMaybe
14:49:24 <applicative> then one will feel relief when one hits upon fmap...
14:49:25 <lambdabot> (a -> Maybe b) -> [a] -> [b]
14:49:40 <applicative> shachaf: ah I guess i had known that
14:49:55 <tac> Another way of thinking of fmap's signature....
14:49:56 <applicative> ah
14:49:57 <tac> @type fmap
14:49:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:50:00 <SamanthaD> so, why would you use map instead of fmap given that it's generally good practice to make ones functions as polymorphic as possible?
14:50:09 <tac> fmap :: Functor f => (a -> b) -> (f a -> f b)
14:50:10 <applicative> thats not my mapmaybe
14:50:15 <Ralith> SamanthaD: because you are a hysterical raisin.
14:50:22 <SamanthaD> by the way, thanks for putting up with my stupid questions
14:50:26 <tac> SamanthaD: because "polymorphic as possible" makes things harder for less experienced users
14:50:28 <shachaf> SamanthaD: fmap used to be called map.
14:50:39 <shachaf> SamanthaD: Then people got confusing error messages and so they changed it.
14:50:44 <tac> SamanthaD: if you didn't know about type classes, you could understand the type of map.... but you wouldn't understand the type of fmap
14:50:50 <Ralith> that seems kind of futile
14:50:58 <shachaf> @ty alongside
14:51:00 <lambdabot> Functor f => LensLike (Context a b) s t a b -> LensLike (Context a' b') s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
14:51:05 <shachaf> Not everyone has this philosophy.
14:51:05 <srhb> STAB
14:51:17 <ion> Masta B
14:51:20 <applicative> what does alongside do?
14:51:22 <Philippa-> it's also decreasingly necessary as Haskell is less weird to the average programmer
14:51:22 <SamanthaD> tac: to the fmapmobile then! *quickly changes all her code to incorporate her newly gleaned knowledge*.
14:51:28 <shachaf> srhb: Would you rather call it "s r h b"?
14:51:31 <ion> @type base
14:51:32 <lambdabot> Not in scope: `base'
14:51:36 <srhb> shachaf: Please!
14:51:38 <Philippa-> if you *mean* map, you may as well say map. It's easier on the reader
14:51:54 <tac> SamanthaD: I would argue overloading Int, Float, etc to be in a Num typeclass is a poor design choice, even
14:51:56 <tac> @type (+)
14:51:56 <Philippa-> (I'm having great 'fun' with code that's riddled with functors that really need naming)
14:51:57 <lambdabot> Num a => a -> a -> a
14:52:01 <shachaf> Philippa-: I used to make my code easy on the reader. But then I realized I could just make a reader macro.
14:52:15 <tac> When does code need to work for BOTH floats AND ints?
14:52:23 <srhb> shachaf: Damn, I thought you were going to make an "arrow to the knee"-joke there.
14:52:32 <srhb> Which is hilarious in this context, so you really missed a golden opportunity.
14:52:35 <applicative> type Simple s h a c f = s h a c h a f
14:52:42 <SamanthaD> tac: I always overload my numbers to either Integral or Floating.
14:52:59 <tac> The numeric tower in Haskell is pretty much terrible.
14:53:36 <sclv> i think the whole notion of a tower is flawed
14:54:13 <SamanthaD> sclv: Why? It makes sense that both Floating and Integral can both act like numbers ect ect
14:54:21 <Ralith> sclv, tac: what would you use instead?
14:55:07 <Ralith> tac: also I expect you to patch your answer to this question into Idris.
14:55:23 <tac> hehe
14:55:27 <sclv> towers are about implicit coercions
14:55:33 <sclv> i'm fine with more granular classes
14:55:54 <sclv> but don't think they really fit in a subtyping hierarchy
14:56:03 <sclv> haskell beat all the implicitness out of me
14:56:13 <SamanthaD> Ralith: I do all my computing my counting lambdas, thank you very much!
14:56:35 <Ralith> tac: seriously, Num needs to go.
14:57:17 <SamanthaD> Ralith: I don't understand why... isn't it useful to have functions like (+) or (*)? You couldn't have them without Num!
14:57:32 <Ralith> SamanthaD: yes you could.
14:57:45 <SamanthaD> Ralith: You would need two functions, right?
14:57:54 <SamanthaD> Ralith: I guess you could pattern match in the prelude...
14:57:57 <Ralith> I said Num "needs to go", not "polymorphic arithmetic functions need to go."
14:58:05 <srhb> You already have two functions.
14:58:07 * hackagebot ixdopp 0.1.3 - A preprocessor for expanding "ixdo" notation for indexed monads  http://hackage.haskell.org/package/ixdopp-0.1.3 (JesseTov)
14:58:10 <edwardk> :t iso
14:58:12 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (b -> t) -> k (a -> f b) (s -> f t)
14:58:12 <Ralith> er, move the first quote a word left
14:58:19 <edwardk> hackage still wonky?
14:58:24 <srhb> Yes.
14:58:26 <srhb> On and off.
14:58:27 <SamanthaD> srhb: Well, I know that! They're just tucked away conceptually in a class!
14:58:33 <srhb> SamanthaD: Right. :)
14:58:35 <edwardk> ok, off to boston haskell
14:58:53 <tac> Ralith: I think this came up before in #idris. The real issue is being able to use numeric literals (which is a useful and good thing)
14:59:27 <tac> Although, I know some languages have different literal syntax for different types
14:59:34 <Ralith> polymorphic operators are nice too
14:59:37 <tac> 1 : Int, 1d : Decimal, 1f : Float
14:59:40 <Ralith> for the very common things
14:59:47 <tac> right
14:59:52 <Ralith> so
14:59:57 <Ralith> how shall they be provided?
15:01:21 <tac> Dunno :)
15:01:27 <feliperosa> guys, I want to completely reinstall the haskell platform on my computer (Windows OS). I uninstalled it through the unistaller and deleted the cabal folder, but yet it seems that not all the packages are being uninstalled. Should I do anything else?
15:01:34 <tac> My views on operators are someone divergent with most of the FP community.
15:01:46 <feliperosa> I think maybe ghc-pkg has some config file somewhere that I'm not deleting?
15:01:49 <Ralith> that doesn't make it not worth stating!
15:02:04 <applicative> feliperosa: in .ghc ?
15:02:07 <Ralith> and if we don't do *something* we'll be stuck with Num.
15:02:10 <Ralith> and that's terrible.
15:03:05 <applicative> feliperosa: in ~/.ghc/--version--/package.conf.d
15:04:03 <feliperosa> applicative: Yeah, I think it is I have not seen that folder before hehe. I thought all ghc stuff were installed inside the haskell platform folder
15:04:04 <applicative> feliperosa: and then there is a global one both visible e.g. with ghc-pkg list
15:04:46 <applicative> feliperosa: that's the global stuff the things locally installed with cabal (no sandboxed) are
15:04:55 <applicative> registered in ~/.ghc
15:05:11 <feliperosa> applicative: The uninstaller does not delete the cabal and ghc folders in AppData =/
15:05:29 <feliperosa> Uhum, I think I found those. Thanks for pointing me :)
15:05:43 <applicative> ah i see.
15:08:28 <tac> Ralith: the weird thing about numbers is there's no real definition for what a number actually is
15:08:39 <tac> Algebraically, at least
15:08:48 <Ralith> tac: indeed!
15:08:56 <tac> You have yer groups, yer rings, yer fields
15:09:03 <tac> But then, floats aren't actually rings o__O
15:10:15 <Hafydd> Some numbers are not even groups.
15:10:54 <Hafydd> (e.g. the natural numbers without 0)
15:11:09 * tac shivers
15:11:16 <tac> The "counting numbers" :P
15:11:22 <shachaf> The natural numbers without 0 are a group.
15:11:29 <shachaf> Just not with the normal +/* operations. :-)
15:11:30 <Hafydd> Well, the natural numbers with 0 aren't a group either, but the natural numbers without 0 are not a semigroup.
15:11:43 <shachaf> Sure they are.
15:12:02 <shachaf> They're a semigroup with +/* and a monoid with *.
15:12:49 <Hafydd> Okay, I meant monoid, and with +.
15:13:08 * hackagebot fay-base 0.1.0.0 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.1.0.0 (AdamBergmark)
15:15:31 <tikhonjelvis> just out of curiosity: has anybody here actually used idiom brackets?
15:16:22 <Peaker> Why are idiom brackets not monad brackets? It could inject not only Applicative operations but =<< where needed as well...
15:16:33 <Peaker> i.e: syntax for ambient monads...
15:16:37 <tikhonjelvis> hmm
15:16:47 <ion> tikhonjelvis: I tried SHE (or whatever its name was) but it couldn’t handle operators properly because it didn’t know their fixities.
15:17:10 <tikhonjelvis> oh, operators are the main reason idiom brackets seem useful
15:17:18 <tikhonjelvis> because f <$> a <*> b isn't too bad
15:17:25 <tikhonjelvis> but (+) <$> a <*> b is
15:17:35 <tikhonjelvis> at least to my eyes
15:18:01 <Peaker> a couple years ago, someone in #haskell tried to popularize the <^(+)^> notation
15:18:05 <Peaker> @type (<^)
15:18:06 <lambdabot>     Not in scope: `<^'
15:18:07 <lambdabot>     Perhaps you meant one of these:
15:18:07 <lambdabot>       `^' (imported from Prelude), `^^' (imported from Prelude),
15:18:08 * hackagebot fay 0.12.0.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.12.0.1 (AdamBergmark)
15:18:17 <tikhonjelvis> heh
15:18:26 <Peaker> a <^(+)^> b
15:18:30 <feliperosa> wow
15:18:33 <tikhonjelvis> that does make your code look happy
15:18:42 <feliperosa> what's that?
15:18:49 <feliperosa> what it would mean?
15:19:02 <tikhonjelvis> I imagine it's equivalent to (+) <$> a <*> b
15:19:06 <feliperosa> a `spaceship` b?
15:19:09 <Peaker> > let (<^) = flip (<$>) ; (^>) = (<*>) in [1,2] <^(+)^> [3,4]
15:19:11 <lambdabot>   [4,5,5,6]
15:19:36 <tikhonjelvis> that's actually pretty brilliant
15:19:39 <tikhonjelvis> in a twisted sort of way
15:20:00 <Peaker> I find it terrible :)
15:20:08 <feliperosa> I understood nothing of it
15:20:11 <feliperosa> hehe
15:20:17 <Peaker> feliperosa, do you know <$> and <*> ?
15:20:29 <cmccann> it's terribly brilliant and brilliantly terrible
15:20:29 <lambdabot> cmccann: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:20:36 <Peaker> feliperosa, or the Applicative class?
15:21:03 <feliperosa> Yeah, I know the Applicative class. But I'm not used to it yet (I have like 7 months of haskell)
15:21:37 <tikhonjelvis> <$> is just fmap
15:21:41 <feliperosa> uhum
15:21:44 <Peaker> feliperosa, well, Functor only lets you apply pure functions on the "value" part, and not touch the "wrapper" part (i.e: you can touch the "a" freely, but not the "f", in "f a")
15:22:15 <feliperosa> uhum
15:22:25 <Peaker> feliperosa, Applicative lets you make "effect-free" wrappers("f"s) as well as "fuse" together, with a meaningful order, multiple "f"s while also combining their values
15:23:01 <Peaker> feliperosa, Functor, Applicative, Monad all play around the signature:  (a -> b) -> f a -> f b... Applicative adds an "f" wrapper around (a->b) and Monad adds an "f" wrapper around the "b" in (a -> b)
15:23:29 <feliperosa> uhum
15:23:32 <Peaker> anyway, <$> is just fmap, so you can lift a pure function and apply it on a wrapped value. Then you get a wrapped result
15:23:45 <Peaker> if the function is curried/of-more-than-one-arg, then that result is itself still a function
15:23:58 <Peaker> so you have, after the fmap, something like:   f (a -> b -> ... -> d)
15:24:07 <Peaker> @type (<*>)
15:24:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:24:36 <Peaker> So <*> lets you "feed the next arg" while combining the effects
15:24:48 <romildo> Concerning performance, should one of IOUArray or STUArray preferred over the other, when dealing with mutable unboxed arrays?
15:24:56 <Peaker> @let foo x y z = print x >> print y >> print z
15:24:59 <lambdabot>  Defined.
15:25:01 <feliperosa> Oh, I almost had it like really clear here
15:25:09 <Peaker> @type foo <$> getLine
15:25:10 <lambdabot> (Show a1, Show a2) => IO (a1 -> a2 -> IO ())
15:25:21 <Peaker> actually this is a bad example :)
15:25:23 <Peaker> @undef
15:25:26 <Ralith> romildo: I would expect the performance of those two to be identical.
15:25:27 <feliperosa> hahaha
15:25:29 <Peaker> @let foo x y z = x + y + z
15:25:31 <lambdabot>  Defined.
15:25:39 <Peaker> @type foo <$> readLine
15:25:40 <lambdabot>     Not in scope: `readLine'
15:25:40 <lambdabot>     Perhaps you meant one of these:
15:25:40 <lambdabot>       `readFile' (imported from Prelude),
15:25:49 <feliperosa> getLine?
15:25:52 <feliperosa> readLn
15:25:53 <feliperosa> ?
15:25:54 <Peaker> @type foo <$> readLn
15:25:55 <lambdabot> (Num a, Read a) => IO (a -> a -> a)
15:26:01 <Peaker> @type readLn
15:26:02 <rntz> getLine, I think
15:26:03 <lambdabot> Read a => IO a
15:26:06 <rntz> @type getLine
15:26:08 <lambdabot> IO String
15:26:11 <Peaker> @type foo
15:26:12 <lambdabot> Num a => a -> a -> a -> a
15:26:32 <Peaker> feliperosa, anyway, foo takes 3 args.. in  "foo <$> readLn",  foo was already fed its first arg (from the result of readLn)
15:26:48 <Peaker> and then the type of that is:   IO (a -> a -> a)   (missing 2 more args)
15:26:59 <Peaker> then you can use <*> to plug in the next arg:
15:27:08 <Peaker> @type (foo <$> readLn) <*> readLn
15:27:10 <lambdabot> (Num a, Read a) => IO (a -> a)
15:27:18 <Peaker> @type ((foo <$> readLn) <*> readLn) <*> readLn
15:27:19 <lambdabot> (Num b, Read b) => IO b
15:27:21 <feliperosa> OHHH
15:27:22 <feliperosa> wow
15:27:23 <feliperosa> heeh
15:27:26 <Peaker> @type foo <$> readLn <*> readLn <*> readLn
15:27:27 <lambdabot> (Num b, Read b) => IO b
15:27:30 <feliperosa> damn you Haskell..
15:27:38 <Peaker> also you can write that as:
15:27:45 <Peaker> @type pure foo <*> readLn <*> readLn <*> readLn
15:27:46 <lambdabot> (Num b, Read b) => IO b
15:28:14 <Peaker> feliperosa, so the <*> here is combining the effects of left-hand-arg with effects of right-hand-arg (left-to-right) and also combining the values (applies function on left with arg on right)
15:28:38 <feliperosa> I see
15:28:40 <Peaker> feliperosa, but.. you might wonder.. why do we need all this when a Monad can also encode this?
15:28:56 <Peaker> @type do { x <- readLn ; y <- readLn ; z <- readLn ; return (foo x y z) }
15:28:57 <lambdabot> (Num b, Read b) => IO b
15:29:10 <tikhonjelvis> to make life a bit more confusing, the idiom brackets we were talking about would let you write pure foo <*> readLn <*> readLn <*> readLn as something like (| foo readLn readLn readLn |)
15:29:44 <feliperosa> well that's nice
15:29:52 <Peaker> feliperosa, the concise notation doesn't warrant a new type-class.. <$> and <*> could be implemented via the Monad class, so why do we need the Applicative class?
15:29:55 <feliperosa> It reads list foo a b c
15:30:10 <Peaker> reads not list, but 3 things given as params to foo
15:30:14 <feliperosa> like* (I wrote list, I guess I'm still impressed)
15:30:32 <Philippa-> Peaker: hell, they're in Control.Monad under different names
15:30:40 <Peaker> feliperosa, yeah, that's the motivation of the <*> operator, to make it read nicely like that
15:30:40 <tikhonjelvis> feliperosa: exactly
15:30:44 <Peaker> Philippa-, yeah
15:31:02 <AfC> Peaker: without getting into it (because I'm not an expert), one of the things I noted from edwardk's Lens lecture was that a few of the structures he's working with are Applicative functors but not Monads.
15:31:30 <AfC> Peaker: given the power of what he's working on, it was the first time I'd seen an answer to that question.
15:31:40 <Peaker> feliperosa, the reason we have Applicative and not just Monad -- is that Applicative composition of wrapped values is that we can "see" all of the "f"s being composed together prior to having to compute any of the values
15:31:53 <AfC> [oh, sorry, you're not asking, you're telling]
15:31:56 <tikhonjelvis> I think some of the FRP libraries (at least Reactive Banana) also only provide applicatives, for efficiency reasons
15:31:59 <Peaker> AfC, yeah, Lens provides an excellent example for Applicative-that-is-not-Monad, but I've seen some examples of it prior to Lens too
15:32:17 <feliperosa> I see
15:32:37 <ion> There is no valid Monad instance of ZipLists of unlimited length IIRC.
15:32:40 <Peaker> feliperosa, Note that Applicative can only compose two values of the form: f <something>
15:32:46 <feliperosa> The Applicative syntax also feels more functional than using (do-notation + Monads)
15:32:52 <tikhonjelvis> yep
15:33:11 <feliperosa> Peaker: Yes, what do you mean by that?
15:33:13 <Peaker> feliperosa, whereas a Monad lets you compose: "f a" with "(a -> f b)". i.e: the "f" is hidden behind a Haskell function... a completely opaque black box
15:33:31 <tikhonjelvis> that's why I'm interested in the idiom brackets: they make it look even more natural
15:34:21 <Peaker> feliperosa, all of the Applicative composition power is derived from: f (a -> b) -> f a -> f b          (both args have fully exposed "f"s we can look at it before we do anything).   With a Monad, we have: (a -> f b) -> f a -> f b  so we MUST first execute the effects of the "f a" before we can get a glimpse of what effects are in the "F b"
15:34:33 <hughfdjackson> i'm trying to get the first letter of a string
15:34:48 <hughfdjackson> but i'm loathe to use head to do it, since it can error
15:35:05 <hughfdjackson> i was looking in hayoo for a [a] -> Maybe a, but couldn't find the equivalent :/ am i missing something?
15:35:21 <Peaker> @hoogle [a] -> Maybe a
15:35:22 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
15:35:22 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:35:22 <lambdabot> Prelude head :: [a] -> a
15:35:31 <Peaker> hughfdjackson, there it is ^^
15:35:46 * hughfdjackson blinks
15:35:54 <Peaker> hughfdjackson, though if you're gonna pattern match on that Maybe, you might as well pattern match on the original list
15:35:55 <tikhonjelvis> more generally, there's a package called `safe' which provides total versions of partial functions from the Prelude
15:35:56 <hughfdjackson> i did see that, but i think i misinterpreted its purpose :D
15:36:17 <hughfdjackson> Peaker: i'm feeling a bit icky using anything in non-IO code that may error
15:36:40 <hughfdjackson> :p probably a newbie-ish feeling, like when people in ##javascript tell me they're incredibly concerned with effeciency of their loops..
15:36:44 <feliperosa> and if you want a letter
15:36:49 <feliperosa> you could use find
15:36:56 <feliperosa> with isAlpha from Data.Char
15:37:06 <feliperosa> I think you said letter
15:37:15 <hughfdjackson> feliperosa: aye; the first letter
15:37:36 <Peaker> feliperosa, in other words: Applicative has a "phase distinction" between the wrappers (the "f"s) and the values (the "a"s), where you can process all the "f"s in a first pass, if you want, and only after that compute the result "a"s.  Monads can't have a "phase distinction", they must interleave effects with value computation.  This gives much more freedom to the implementor of an Applicative instance than one of a Monad instance.  And less
15:37:36 <Peaker> freedom to the Applicative user
15:37:44 <c_wraith> Hmm.
15:38:17 <c_wraith> I want an optimization pragma for GHC that tells it to inline a particular argument into a function body, if possible.
15:38:24 <feliperosa> Why you say less freedom to the Applicative user?
15:39:02 <Peaker> feliperosa, because a Monad user can do this:  do { l <- getLine ; if l == "yes" then launchMissiles else petKitty }
15:39:24 <Peaker> feliperosa, i.e: a Monad user gets to look at the *value* results of previous effects to decide which next effects to chain
15:39:42 <Peaker> feliperosa, whereas the Applicative composition forces the user to decide which effects to chain without looking at the result values at all
15:39:46 <feliperosa> @ty find isAlpha
15:39:47 <lambdabot> [Char] -> Maybe Char
15:39:57 <feliperosa> hughfdjackson:
15:40:18 <c_wraith> Err, that is, I want the pragma on the argument, resulting in the full function being specialized for the value of that argument statically, when possible.
15:40:52 <Peaker> c_wraith, it would be cool if you could SPECIALIZE on values and not just types
15:41:51 <c_wraith> my specific case for wanting this is being able to use first-class functions in an API, but getting the full benefit of inlining the functions passed to them.
15:41:51 <feliperosa> Peaker: Ohh I get it. You say the Monad composition will pass the value inside the Monad to a function so the function can decide what to do with it
15:42:11 <Peaker> feliperosa, yeah, that's exactly the difference between the Applicative and Monad composition power, see the types:
15:42:13 <Peaker> @type (=<<)
15:42:15 <lambdabot> Monad m => (a -> m b) -> m a -> m b
15:42:16 <Peaker> @type (<*>)
15:42:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:42:29 <Peaker> feliperosa, the types are very similar, but there's an important difference
15:42:37 <hughfdjackson> feliperosa: huh; i seem to be getting isAlpha :: Char -> Bool here
15:43:02 <Peaker> feliperosa, the "f" in <*> is exposed outside, whereas the "m" in =<< is the result of a function that sees the previous effect's result
15:43:21 <feliperosa> hughfdjackson: check the type of find and isAlpha, you'll get what to do
15:43:29 <feliperosa> @ty find
15:43:30 <lambdabot> (a -> Bool) -> [a] -> Maybe a
15:43:35 <feliperosa> @ty isAlpha
15:43:36 <lambdabot> Char -> Bool
15:44:22 <hughfdjackson> feliperosa: oooh :#
15:44:25 <hughfdjackson> i see what you did there
15:44:36 <hughfdjackson> i thought you were telling it to 'find' isAlpha
15:44:39 <hughfdjackson> :) thanks
15:44:39 <feliperosa> hughfdjackson: :), nice
15:44:55 <SamanthaD> I think I just had a revelation: If in category C there exists f: A -> B and we have functor F: C -> D there exists F(f): F(A) -> F(B). In other words, the arrows which are transformed always point between the same corresponding domain and codomain. Ergo... the structure of a functor is always maintained!
15:45:28 <Peaker> @ty liftA2
15:45:29 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:45:31 <Peaker> @ty liftA2 . liftA2
15:45:33 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
15:45:35 <feliperosa> Peaker: Just a second, I'm still thinking about it hehe
15:45:35 <Peaker> @ty liftA2 . liftA2 . liftA2
15:45:36 <lambdabot> (Applicative f2, Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 (f2 a)) -> f (f1 (f2 b)) -> f (f1 (f2 c))
15:46:00 <SamanthaD> AAAHAHAHAHA! I understand now! *gleefully run off into the sunset*
15:46:17 <feliperosa> haahahaha, that's a nice feeling
15:48:37 <SamanthaD> of course... the structure of the category CAN change in that you can apply a functor which merges various categories. But then what might have been disparate arrows become synonymous. They still share the same domain and codomain as their predecessor. Therefore, all you need to morph a functor is to describe how their objects change! (unless I'm stumbling around in the wrong direction, of course!)
15:48:44 <feliperosa> Peaker: Damn that's hard to grasp
15:48:49 <cmccann> SamanthaD: I think there's a bit more to the definition but it basically amounts to more formal ways of saying how structure is maintained
15:49:11 <Peaker> feliperosa, the difference in power?
15:49:12 <SamanthaD> cmccann: Formal is good. I like formal.
15:49:16 <feliperosa> Peaker: But I see the point, eventhough I don't understand the concept completely.
15:49:19 <cmccann> SamanthaD: fortunately a lot of the fiddly details are automatic in Haskell because of parametricity, which is nice!
15:49:23 <Peaker> feliperosa, do you know about grammar parsing?
15:49:24 <hughfdjackson> feliperosa: works like a charm :) thankyou
15:49:38 <feliperosa> hughfdjackson: np :)
15:50:05 <feliperosa> Peaker: Yes, to some extent (I'm still a undergraduate student).
15:50:09 <SamanthaD> cmccann: I'm elated right now because a mystery that's been bothering me for days makes sense now!
15:50:12 <Peaker> feliperosa, imagine you want something like parsec, but you want to efficiently compile the parser to an automaton and not just execute the parser
15:50:26 <feliperosa> Peaker: Ok
15:51:03 <Peaker> feliperosa, parsec can't really do a lot of smart things in this regard, because all the parsers inside a Parsec parser are hidden behind Haskell functions, which are completely opaque
15:51:04 <cmccann> SamanthaD: also, you do actually need to specify what the functor does on both objects and arrows, but again in Haskell there's often only one sensible way to do it
15:51:20 <cmccann> which is why the -XDeriveFunctor extension can exist
15:51:39 <Peaker> feliperosa, parseOneThing >>= haltingProblemHere    -- haltingProblemHere decides which next parser to chain, how can we optimize this chaining? (we can't)
15:51:58 <Philippa-> Peaker: that's not /quite/ true, but you might want to explain why :-)
15:52:08 <Philippa-> (Parsec can do it, Parsec's >>= implementation can't)
15:52:25 <SamanthaD> cmccann: That's what I meant! Still, the basic STRUCTURE remains the same
15:52:31 <Peaker> Philippa-, ah, you mean if you use Parsec but avoid Monadic composition?
15:52:41 <ion> haltingProblemHere is the best function.
15:52:43 <Peaker> (as in, avoid >>=)
15:52:46 <Philippa-> Peaker: Yeah. Not that I know if anybody's bothered doing this
15:52:55 <Philippa-> this can also buy you 'local' optimisations
15:53:37 <Philippa-> The bits around a >>= might know enough to partially optimise. The bits inside one are still an entire, potentially-optimiseable parser (and the optimisations might even be something the compiler can spot is constant)
15:53:52 <Peaker> Philippa-, yeah, but to buy a lot of benefit if you use it in applicative style, you probably need some ApplicativeFix interface like: (f a -> f a) -> f a   so that the parse-loop is visible to the framework
15:54:33 <Philippa-> Peaker: er, no
15:54:45 <Philippa-> you /do/ need a specific implementation of many though
15:55:06 <Peaker> well, you get a lot of benefit just from optimizing Applicative, but you'd get even more if you have fix, if you want to support context-free grammars, I think
15:55:34 <Philippa-> y'know, I'm not sure that lets you do anything well-placed laziness doesn't
15:55:50 <cmccann> SamanthaD: indeed, a generalized notion of structure-preserving map is what functors are essentially about.
15:56:11 <Philippa-> well, not quite true
15:56:24 <Peaker> if you juse use ordinary fix there, you get a cyclic parser structure, and referential transparency means the framework can't distinguish that from an infinite parser (but maybe there's a different way)?
15:56:25 <Philippa-> (yeah, rendering the grammar finite lets you do a lot in an obvious manner)
15:56:28 <SamanthaD> cmccann: I'm so gleeful!
15:57:07 <Philippa-> I'm pretty sure I've seen a paper or two that does some surprising tricks in this regard, yeah
15:57:20 <Philippa-> (I'd rather have not just afix but a sensible tagging scheme myself!)
15:57:28 <Peaker> Philippa-, that sounds interesting, I've been wondering if the applicative-fix was necessary for a while
15:57:48 <Philippa-> it's not about "the parse loop" though, it's about the /grammar/ loops :-)
15:58:00 <Peaker> yeah, to upgrade from regular to context free
15:58:22 <Philippa-> right. CFG = regex + letrec
15:59:09 <cmccann> SamanthaD: so, time to ponder natural transformations next? :D
15:59:31 <Peaker> feliperosa, anyway, my point was that if you use only Applicative composition of parsers (btw, (>>) is in the Monad type-class, but it actually only uses Applicative power, it doesn't require Monad. In the Applicative world it is called *>), and avoid Monadic composition, then your parser framework can see all the chained parsers before parsing anything
16:00:06 <Peaker> feliperosa, unlike Monadic composition which requires generating results (i.e: parsing) of previous parsers before deciding what the next parsers are
16:00:40 <Peaker> feliperosa, and seeing all the parsers involved before parsing anything -- is a great opportunity to compile/optimize a parser that will execute faster on each input
16:01:03 <Peaker> just based on the package name, I'm pretty sure http://hackage.haskell.org/package/regex-applicative utilizes this approach :)
16:01:51 <feliperosa> Damn, How long you guys have been programming/thinking in Haskell to get all this stuff so naturally?
16:02:50 <tikhonjelvis> I think it really helps to use Haskell for an actual project rather than just doing exercises and reading stuff
16:02:57 <Peaker> feliperosa, I think it all clicked after a lot of messing around at about ~1 year.. but I've been doing Haskell for ~5 years or so
16:03:20 <feliperosa> tikhonjelvis: Yep, agreed
16:03:23 <tikhonjelvis> at least it really helped everything fit together for me
16:03:27 <Peaker> but yeah, practice on actual code is much more efficient at building an understanding
16:03:37 <feliperosa> Peaker: What a cool library! I'll install it here
16:04:00 <Peaker> I don't actually know if it is any good :) I just needed an Applicative-style parser library :)
16:04:55 <tikhonjelvis> I started out with the Write Yourself a Scheme tutorial, but I'm not sure if it's the best option
16:05:33 <feliperosa> Peaker: Yeah, I'm mean nice in the Applicative way. I guess I'll try using it to grasp the concepts.
16:05:58 <feliperosa> Peaker: Not in the Applicative way, but in what I can learn.
16:06:36 <feliperosa> tikhonjelvis: Why it's not the best option?
16:06:54 <Peaker> feliperosa, you can try to use <$>, <*>, and liftA2 instead of "do" to get a handle on Applicative
16:06:59 <tikhonjelvis> hmm, I think it doesn't have the best code style
16:07:13 <feliperosa> Oh, I see
16:07:16 <SamanthaD> cmccann: I don't know what that is but it sounds fun.
16:07:33 <Peaker> feliperosa, perhaps as an exercise, try to implement liftA2, (<*), (*>) in terms of the Applicative interface, just by looking at their types
16:07:34 <tikhonjelvis> also, I ended up turning the Scheme interpreter into an interpreter for my own language, but then had to rewrite essentially all of it at one point
16:07:53 <tikhonjelvis> creating your own programming language, coincidentally, is a very fun project
16:08:00 <Peaker> feliperosa, then try to implement "sequence" and "filterM" functions using just the Applicative interface
16:08:09 <cmccann> SamanthaD: transformations between functors. you can define a category with functors as objects and natural transformations as the arrows, for example.
16:08:18 <tikhonjelvis> in a very self-indulgent way: there is literally no good reason for anybody to ever use the language I made
16:08:40 <SamanthaD> cmccann: THAT IS AMAZING!
16:09:04 <feliperosa> tikhonjelvis: hahaha
16:09:08 <Peaker> that must be the "abstract" in "abstract nonsense" :)
16:09:31 <SamanthaD> cmccann: are those actually used in the Haskell type system?
16:09:43 <feliperosa> Peaker: Alright, gonna try it now. I'm starting to get these more abstract concepts used in Haskell. Some days ago I just really understood what the State Monad was all about.
16:09:51 <feliperosa> Peaker: Now it feels so natural
16:10:00 <tikhonjelvis> SamanthaD: I don't know about the type system, but they're useful for understanding free monads
16:10:35 <feliperosa> tikhonjelvis: One of my greatest interests are in languages, I wish to someday create my own x).
16:10:42 <cmccann> SamanthaD: actually, natural transformations are a place where parametricity makes things extremely easy, almost automatic.
16:10:49 <cmccann> so they're kind of there anyway.
16:10:51 <Peaker> feliperosa, awesome :) That was the first Monad that clicked for me too.. I remember implementing it on my own, line by line, to make it click
16:10:54 <tikhonjelvis> feliperosa: Oh, you should. It's a lot of fun.
16:11:07 <tikhonjelvis> Makes you feel like omnipotent
16:11:23 <tikhonjelvis> unfortunately, if you give me ultimate power, you're going to get a very wonky universe
16:11:28 <Peaker> feliperosa, Reader and Writer are also excellent monads to practice with.. you can also write the Functor and Applicative instances for State, Reader, Writer if you want practice :)
16:12:08 <feliperosa> Peaker: Yeah! I still don't get them as naturally as the State Monad, but I'll surely do that
16:12:34 <feliperosa> tikhonjelvis: hahaha, yeah. It's useful for creating tools too.
16:12:55 <quazimodo> Guys trying to learn monads, curios about how we can take a f:a->Ma and >>= it to g:a->Ma.  does >>= map Ma to a ?
16:13:32 <sipa> quazimodo: no, it doesn't remove the Monad wrapping
16:13:40 <Peaker> feliperosa, they're sort of subsets of the state monad.. Reader only lets you "ask" the read-only state, Writer only lets you "tell" into an accumulating Monoid
16:13:50 <quazimodo> sipa: my only confusion is that i dont get how Ma and a are 'compatible'
16:13:52 <sipa> quazimodo: but you shouldn't think of it as "how can >>= do ..."
16:13:57 <SamanthaD> tikhonjelvis, cmccann: neat! I'll have to look into those.
16:14:13 <sipa> quazimodo: you should think of it as "something can only be a Monad, if there exists a >>= for which ..."
16:14:14 <Philippa-> quazimodo: the spaces matter
16:14:20 <tikhonjelvis> SamanthaD: If you're in a math mood, you should also check out universal algebra
16:14:31 <Philippa-> as do the types
16:14:42 <Philippa-> the LHS is M a, the RHS is a -> M b
16:14:54 <Philippa-> and you get an M b out
16:15:13 <quazimodo> my question is not that, actually
16:15:17 <Peaker> feliperosa, then there's the entire issue of composing various monads together into a single monad (Monad transformers), I remember that seemed way out of reach at the point that State clicked for me :)
16:15:33 <quazimodo> my confusion arises because i know how 2 functions can be composed if the type input for one is the type output of another
16:15:37 <sipa> quazimodo: for example, try to write >>= for the maybe monad yourself
16:15:52 <quazimodo> so if the type input for h is a , how can h accept an Ma ?
16:15:55 <feliperosa> Peaker: I tried reading somethings about Monad Transformers today. No luck though
16:16:10 <sipa> quazimodo: stop thinking as if >>= is so smart it needs to deal with all that
16:16:11 <Peaker> feliperosa, I wrote this: http://www.haskell.org/haskellwiki/Monad_Transformers_Tutorial   no idea if it is any good though, cause I didn't get any feedback on it
16:16:28 <sipa> quazimodo: to be a monad, you have to provide something that matches >>='s behaviour
16:16:46 <Peaker> feliperosa, by the way, this relates to all the Applicative stuff as well , that would have been my next point:  Applicatives don't need "transformers" because they compose naturally.. Monads need transformers because Monads (in general) do not compose
16:16:49 <feliperosa> Peaker: Let me read it. Then I'll work on Applicatives
16:17:31 <quazimodo> ok we need to step back a second, is >>= analoguoes to compose?
16:17:36 <feliperosa> Peaker: Wow, you're making me like Applicatives a lot haha.
16:18:26 <Peaker> they're a pretty cool, underappreciated point in the type-class hierarchy :)
16:18:48 <tikhonjelvis> Are they actually under-appreciated? Seems people use them quite a bit.
16:24:23 <quazimodo> i get the feeling monads provide transforms on data in between each function step
16:24:47 <quazimodo> because i can not understand how you can take an output of type Ma and pipe it into a function that has input of type a without mapping that Ma to some a
16:26:10 <Philippa-> quazimodo: right, but the monad's user doesn't get to do that except through >>=
16:26:58 <Philippa-> oh, and the monad knows nothing about the data
16:27:12 <Philippa-> so really what it's transforming is how you work on the data
16:28:07 <quazimodo> monads are a simple concept, yet the explanations are painful
16:28:13 <feliperosa> is there any diference between forM and mapM?
16:28:23 <tikhonjelvis> the arguments are reversed
16:28:24 <feliperosa> yeah, Monads are quite abstract
16:28:24 <tromp> flipped
16:28:25 <tikhonjelvis> but that's it
16:28:27 <Philippa-> that's because the good explanations tend to be a bit abstract
16:28:33 <Philippa-> so people don't always get them
16:28:47 <quazimodo> there needs to be a solid example with full explanations
16:28:59 <Philippa-> there are many of these
16:29:30 <Philippa-> there are so many "how to write and use a state monad" articles it's ludicrous
16:30:00 <SamanthaD> remember: if it blows your mind it's gonna fragment it before everything settles into place :3
16:33:46 <quazimodo> its not blowing my mind
16:34:38 <quazimodo> i just find maney of the explanations (so far) to be teacher oriented rather than student oriented
16:35:14 <quazimodo> *many. But there is a video by Brian Beckman that was very helpful
16:35:43 <quazimodo> i guess the only thing i was left thinking is how can f a->b  accept Ma unless Ma is transformed/mapped to some a
16:35:57 <feliperosa> Peaker: So the point of monad transformers is to basically take the value we are working on out of the stacked Monads so we can avoid doing that ourselves every time?
16:36:00 <Philippa-> there's a good chance that many are aimed at people with subtly different backgrounds. I mean, you're still talking about "Ma" - there is no such syntactic entity involved
16:36:38 <Philippa-> and yes, there's effectively a "runTheProgramRepresentedByThisComputation" function hidden somewhere (usually 'fused' into >>=)
16:37:05 <Philippa-> but what parameters that function would need varies from one monad to another
16:37:20 <Philippa-> (and in IO's case, it's just plain not a pure function)
16:37:33 <Peaker> feliperosa, hmm.. more than that: you need to be able to compose effects from all of the monad transformers being composed
16:38:04 <Peaker> feliperosa, MaybeT might be a bad example there, because you can always just use ordinary maybe and pattern-match manually, so it's hard to see a problem with avoiding the transformer there
16:38:52 <Peaker> feliperosa, but generally, if you have a monad like: MonadTrans1 (MonadTrans2 (MonadTrans3 m))   then it lets you interleave effects of each of the 3 monads
16:39:42 <Peaker> feliperosa, whereas if you have something like:   Monad1 (Monad2 (Monad3 a))  (Ordinary nested monadic values, not transformers), then you can only chain Monad1 effects, Monad2 effects, Monad3 effects independently. You can't get them to be interleaved
16:39:58 <feliperosa> Peaker: I get it. Because by saying IO (Maybe a) it's a computation that executes IO operations and may return a value
16:40:39 <feliperosa> Peaker: So the transformer helps composing them while mantaining their effects
16:41:08 <Peaker> feliperosa, yeah, exactly, you get to have effects from any of the transformers in the same monad, interleaved at will
16:41:33 <Peaker> also, playing with the order of the transformers changes the semantics of those effects in interesting ways
16:41:46 <feliperosa> How is that?
16:42:09 <Peaker> For example:   StateT s m a ~= s -> m (s, a)    MaybeT m a ~= m (Maybe a)
16:42:25 <Peaker> State s = StateT s Identity
16:42:30 <Peaker> Maybe = MaybeT Identity
16:43:02 <Peaker> StateT s Maybe a ~= s -> Maybe (s, a)           whereas:   MaybeT (State s) a ~= s -> (s, Maybe a)
16:43:30 <feliperosa> Oh right
16:43:32 <Peaker> so in the former monad transformer stack, if you use a "Nothing" effect, you don't have a final state as well
16:43:37 <glguy> ?unmtl ErrorT e (State s) a
16:43:37 <lambdabot> s -> (Either e a, s)
16:43:47 <feliperosa> Ohh, I understand it
16:44:05 <glguy> ?unmtl StateT s (ErrorT e Identity) a
16:44:05 <lambdabot> s -> Either e (a, s)
16:44:08 <Peaker> whereas in the latter, a "Nothing" does not lose the final state
16:44:46 <fragamus> hey I am worried that when I serialize my data structure the graph of records in it will take up more memory than it should because haskell might not realize that a given node has multiple arrows to it
16:45:08 <fragamus> does anyone know what happens
16:45:11 <Peaker> fragamus, how is your graph represented?
16:46:23 <fragamus> it is a list of records that contain the haskell equivalent of references to other records and so on
16:46:31 <Saizan> yes, unless you do something clever, serialization will flatten out your graph into a tree, duplicating stuff
16:46:47 <fragamus> yeah so Im thinking this:
16:47:11 <fragamus> I think I need something that performs multiple passes over the data structure to identify leaves and convert them into a hash that can serve as a reference in the data stream, all the while building a hash map
16:47:15 <Peaker> fragamus, the usual solution is to make the identities explicit -- and have the references be via these explicit identities, and not direct values
16:47:28 <fragamus> yahuh
16:47:37 <hpaste> “Felipe Rosa” pasted “liftM' exercise” at http://hpaste.org/81199
16:47:48 <feliperosa> Peaker: Is that right?
16:47:55 <Saizan> fragamus: there are packages on hackage to observe sharing (in IO) which you could use to preserve it when serializing
16:47:58 <feliperosa> Peaker: It type checks at least
16:48:22 <Peaker> fragamus, something like:  data Edge a = Edge Int a ; type Graph e n = IntMap (Node e n) ; data Node e n = Node [Edge e] n
16:48:30 <fragamus> well… I don't really want to be in IO, but I think i have a plan
16:49:16 <Peaker> feliperosa, yeah, but that's not related to Applicatives :) That's just extracting the power of ordinary Functor from the Monad interface
16:49:50 <Peaker> feliperosa, but it is also a good exercise if you add "ap" (and trivially: "pure' = return")
16:49:57 <feliperosa> Peaker: Yeah, I know hehehe. I just started with that since I understand Monads better at the moment
16:50:23 <Peaker> fragamus, then if you serialize the Graph(IntMap) you won't have any duplication
16:50:53 <latro`a_> hm, can anyone name an Applicative that can't be consistently made a Monad other than ZipList?
16:51:09 <fragamus> Peaker: yeah man you're right
16:52:26 <Peaker> latro`a_, Yes, Const
16:52:33 <latro`a_> touche
16:52:38 <latro`a_> any slightly less trivial ones?
16:52:46 <latro`a_> (ZipList isn't trivial but I'm familiar with it already)
16:52:58 <Peaker> latro`a_, and   (Writer :. Const ()) (Which I used once)
16:53:17 <Peaker> latro`a_, note that while Const is trivial, the fact it is Applicative and not Monad is very relevant to the lens library which makes full use of that
16:54:00 <fragamus> Peaker: do you think I have to suffer having that as my internal representation?
16:54:43 <fragamus> it seems like reinventing pointers which seems like a bad thing
16:55:38 <Peaker> fragamus, explicit pointers/identities in the few locations where you rely on the identities is nicer, IMO, than having identities everywhere
16:55:47 <Peaker> (which is the typical approach)
16:56:17 <SamanthaD> Anyway, thanks for all the help with the functors everyone! I'm off to nap and let it sink in.
16:57:21 <fragamus> I think I have an idea which can reconstitute it on the other end of the wire in such a way that it has the same memory footprint but only has the reference stuff in the serialized form
17:00:40 <copumpkin> EvanR: rallymode
17:06:30 <bgamari> Is the author of pipes around?
17:06:31 <joe9> join #dragora
17:21:24 <fragamus> I'm kinda depressed that i have to write this squirrelly code to serialize my graph
17:25:04 <Mortchek> @djinn (a -> b) -> (b -> a) -> a -> a
17:25:04 <lambdabot> f a b c = b (a c)
17:25:18 <Mortchek> How does djinn figure out I want that rather than just giving me f _ _ a = a?
17:25:34 <ion> It probably prefers to use all the parameters if possible.
17:25:56 <ion> @djinn (a -> b) -> (b -> c) -> (c -> d) -> (d -> a) -> a -> a
17:25:56 <lambdabot> f a b c d e = d (c (b (a e)))
17:26:06 <Mortchek> So it just ignores parameters if there is nothing it can possibly do with them?
17:26:11 <ion> @djinn (a -> b) -> (b -> c) -> (c -> b) -> (b -> a) -> a -> a
17:26:11 <lambdabot> f a _ _ b c = b (a c)
17:26:36 <Mortchek> Hmm, but there is something it could have done there.
17:28:12 <Guest43271> hi why should haskell be better support parallelism?
17:28:20 <Guest43271> supporting
17:28:24 <Guest43271> than c++
17:29:00 <Saizan> fragamus: seen data-reify on hackage?
17:29:09 <fragamus> no
17:30:06 <Guest43271> hi why should haskell be better support parallelism than a sequently language like c++?
17:30:18 <ion> guest: I don’t understand your question.
17:32:07 <Saizan> Guest43271: http://community.haskell.org/~simonmar/par-tutorial.pdf
17:32:39 <YayMe`> Can someone help me out? I feel like this is either useless, wrong, or both, it's my first attempt at really creating something monadic. Can anyone tell me which of the two it is? http://codereview.stackexchange.com/questions/20845/ (it's in javascript, no point in doing it in haskell when haskell already has all these monads in the provided libs)
17:33:40 <Guest43271> Saizan could haskell used for embedded systems?
17:35:21 <Saizan> Guest43271: not as easily
17:35:22 <YayMe`> Guest43271: some folks got cloud haskell going on rPi, rPi can be used in embedded systems (though typically embedded systems means industrial machines with altogether different architecture from consumer systems)
17:35:35 <Guest43271> why not?
17:36:06 <Saizan> it depends on how much memory you have, i guess
17:36:21 <Guest43271> haskell needs lots of memory?
17:36:48 <Saizan> not lots, but considering you have a garbage collector it's not tiny either
17:37:12 <Guest43271> there are some java languages running on low memory too
17:37:19 <Guest43271> on embedded platforms
17:37:40 <Guest43271> can u allocate memory on the stack?
17:38:43 <Saizan> Guest43271: i suggest you read a haskell introduction before you ask more specific questions
17:38:54 <Guest43271> ok i will just tell me :D
17:39:06 <Saizan> @where lyeah
17:39:07 <lambdabot> I know nothing about lyeah.
17:39:09 <Saizan> @where lyah
17:39:09 <lambdabot> http://www.learnyouahaskell.com/
17:39:34 <Saizan> the ghc user manual can also help with implementation details
17:39:41 <Saizan> or the manuals of other compilers
17:39:57 <Guest43271> can u allocate memory on the stack?
17:40:17 <Guest43271> using a garbage collector is never nice
17:40:28 <ion> s/never/often/
17:40:59 <parcs> usually
17:41:29 <parcs> Guest43271: haskell has no notion of a stack
17:41:31 <Guest43271> unpredictability of algorithms in terms of execution time is sometimes bad
17:41:44 <simpson> There are alternatives to both garbage collection and manual memory management if you're working embedded. Things like compile-time memory allocation, for example.
17:41:51 <simpson> Check out Virgil for an example.
17:41:53 <Guest43271> parcs, can you avoid the garbage collector?
17:42:09 <Taslem> Guest43271: Then Haskell is really bad. :3 It can be tricky to reason about code performance, but not impossible.
17:42:12 <simpson> Guest43271: What are you hoping to build?
17:42:13 <Guest43271> pre allocate it...
17:42:22 <simpson> Guest43271: Also, have you considered learning Haskell?
17:42:28 <parcs> Guest43271: you can write code that doesn't create garbage
17:42:35 <Guest43271> no just need to figure out if its worth :D
17:42:43 <Guest43271> for a real time application
17:42:45 <simpson> Guest43271: Well, yes, it's always worthwhile.
17:43:06 <Guest43271> can you write real time application using haskell?
17:43:12 <simpson> Hard or soft realtime?
17:43:27 <Guest43271> i ask for both
17:43:53 <simpson> Well, obviously soft realtime is possible.
17:44:01 <Guest43271> and hard realtime?
17:44:14 <Guest43271> with an real time operating system
17:44:22 <simpson> Requires you to establish a GC which is bounded in its runtime.
17:44:35 <parcs> Guest43271: your question has been answered many times and i'm sure those answers have been recorded by google
17:44:48 <Guest43271> ok what do you work on?
17:45:39 <simpson> Right now, dinner. :3
17:45:46 <HaskellNewbie> Hi all! Is there a way that I can do "read a" where a is a Char?
17:46:16 <Guest43271> parcs cant you avoid the garbage collector to be called in haskell?
17:46:23 <simpson> HaskellNewbie: Sure. You have to specify which type you'd like back from read, though.
17:46:29 <simpson> > read "1" :: Int
17:46:30 <lambdabot>   1
17:46:43 <HaskellNewbie> Oh! Cool, thank you! I'll give it a try.
17:47:00 <quux> Interesting...
17:47:20 <melvin-> are you trying to pass char to read or read a char from a string?
17:47:31 <Guest43271> simpson: nice http://www.youtube.com/watch?v=jBd9c1gAqWs
17:47:38 <HaskellNewbie> Well actually, I'm trying to evaluate the head from a string.
17:48:01 <HaskellNewbie> So far I have "read $ head src" where src is just a huge string
17:48:15 <melvin-> what do you expect first character to be?
17:48:41 <HaskellNewbie> It could be a digit or a char
17:48:57 <HaskellNewbie> Anything between [0..9] or 'e' or 'E'
17:48:59 <simpson> Guest43271: Well, you can't not have garbage collection. Haskell's semantics don't really permit it. The alternative is to just let garbage pile up until you exhaust memory.
17:49:12 <melvin-> if it is 'e' what do you expect back?
17:49:30 <HaskellNewbie> A char, I believe
17:50:04 <Taslem> HaskellNewbie: So what do you expect "read" to turn it into?
17:50:04 <Guest43271> simpson, hmm why not? ...it sounds like java...
17:50:04 <geekosaur> however if you code properly you can avoid creating much garbage through e.g. list fusion, which will reuse list cells instead of generating extra ones for garbage collection.
17:50:40 <simpson> Guest43271: Well, sure, you can do something like, say, CPython. You can just reference-count your way to victory.
17:51:08 <Guest43271> cpython is not haskell
17:51:17 <HaskellNewbie> My logic may be flawed. I'm assuming that if I do "read e" where e is a Char, I'd expect a Char, right?
17:51:51 <geekosaur> :t read
17:51:52 <lambdabot> Read a => String -> a
17:51:53 <melvin-> you get compile error because read expects a string
17:52:19 <HaskellNewbie> Ahhh, I see. That helps, thank you!
17:52:19 <Taslem> HaskellNewbiew read :: String -> (Read a => a); which means that it takes a string and produces any type which can be read.
17:53:02 <geekosaur> however note that the caller of read controls what type it looks for
17:53:11 <simpson> Guest43271: Obviously. What are you planning on building?
17:53:39 <Guest43271> simpson i concurrent application for a embedded system
17:53:42 <Guest43271> a
17:53:50 <geekosaur> also, hm, I think it will be looking not for a bare character but for something like 'e'
17:53:59 <geekosaur> > read "a" :: Char
17:54:00 <lambdabot>   *Exception: Prelude.read: no parse
17:54:02 <simpson> Guest43271: Well, go ask your boss what you should be building then.
17:54:12 <geekosaur> > read "'a'" :: Char
17:54:14 <lambdabot>   'a'
17:54:39 <Guest43271> simpson http://www.youtube.com/watch?v=iSmkqocn0oQ :D
17:55:24 <simpson> Guest43271: Sorry, what's your goal?
17:55:27 <HaskellNewbie> Alright. It sounds like I should start with a String, and that should become either a Char or an Int depending on what the String reads.
17:55:33 <blaenk> hey. I'm playing around with "simplifying" a function, and for some reason it consistently performs 13% slower than the non-simplified version
17:55:36 <blaenk> https://gist.github.com/4616965
17:55:43 <blaenk> is there anything you guys notice that's glaringly wrong?
17:56:02 <Taslem> HaskellNewbie: Actually, it can't choose on its own. You have to tell it what it should get out.
17:56:06 <Guest43271> simpson i want to build a parallel applicaiton for an impage processing on an embedded system
17:56:06 <blaenk> in that gist, conv' runs 13% slower than conv, consistently
17:56:24 <geekosaur> HaskellNewbie, check my last few remarks please
17:56:24 <simpson> Guest43271: Do you get to have Linux?
17:56:26 <Taslem> Sometimes it can infer, but it needs to know or you get an error "Ambiguous type variable"
17:56:30 <blaenk> perhaps there is some ghc optimization I'm unaware of that I'm missing out on
17:56:39 <Guest43271> simpson yes
17:57:04 <simpson> Guest43271: Then choice of language doesn't matter. Go with what makes you happy.
17:57:26 <Guest43271> and if i cant have linux?
17:57:41 <HaskellNewbie> I did, I was just trying to understand =)
17:58:07 <simpson> Guest43271: You already said that you had it. >:3
17:58:20 <simpson> Guest43271: I'm starting to think that you just want to argue instead of building things.
17:58:23 <Guest43271> lets assume i dont have linux
17:58:33 <quux> > sort [27,"quux","hello"]
17:58:35 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
17:58:35 <lambdabot>    arising from the literal ...
17:58:52 <simpson> Guest43271: Well, step one should be to obtain Linux. Without it, you don't really have the freedom to build what you want to build.
17:58:55 * quux fails.
17:59:11 <Guest43271> so haskell requires linux?
17:59:16 <quux> Not necessarily.
17:59:17 <hpc> no
17:59:19 <parcs> blaenk: hmm. in conv', try binding 'reverse hs' to a name
17:59:27 <Taslem> Guest43271: No, but it's not convenient on, say, Windows.
17:59:27 <quux> I'm using it on BSD systems
17:59:30 <Guest43271> at leat an operating system like windows or linux?
17:59:31 <simpson> No, I'm pretty sure that it runs on BSD, OSX, Win32, etc.
17:59:37 <blaenk> parcs: yeah I did try that :) I'll try it again
17:59:39 <hpc> some packages require posix (which makes windows hard)
17:59:45 <simpson> But if you're doing embedded work on Win32 or WinCE, then you have a *serious* problem. >:3
17:59:47 <hpc> some require external libraries that are linux-only
17:59:58 <hpc> in other words, haskell is a programming language :P
18:00:24 <tac> hpc: says who??
18:00:24 <Guest43271> c code also runs without an real operating system
18:00:29 <simpson> Guest43271: Ha, no it doesn't.
18:00:41 <hpc> tac: oh i forgot, it's actually a logically unsound theorem prover ;)
18:00:46 <Guest43271> lets say i have a microcontroller
18:00:49 <simpson> Guest43271: Bastardized dialects of C that are bootstrapped in a special fashion might run on bare metal.
18:01:01 <simpson> But C itself requires some things like stdio that the OS provides.
18:01:01 <blaenk> parcs: actually, now my benchmark (criterion) is only showing it to be -1% slower, at least that's more reasonable haha
18:01:04 <tac> hpc: I like to think of it as a feature-heavy Falso
18:01:10 <blaenk> must've been doing it wrong last time I bound it to a name
18:01:16 <simpson> Guest43271: If you're bare-metal, then you're *already* limited pretty heavilty.
18:01:31 <Guest43271> ?
18:01:37 <simpson> There have been a couple projects that let you compile Haskell for the bare metal.
18:01:52 <simpson> Guest43271: It still sounds like you don't know what you want to build, or maybe like you just want to argue.
18:01:59 <hpc> the typical approach in haskell is to pick a language to run on bare metal, then generate that language with haskell
18:02:05 <parcs> blaenk: yay
18:02:09 <jollytime> I don't understand how binary functions work if in haskell all functions really have one parameter? I am looking at the type signature of foldl and I'm a little puzzled :)
18:02:14 <blaenk> parcs: yeah that must've fixed it. -1% is negligible I suppose, thanks :)
18:02:20 <parcs> yeah it's probably just noise
18:02:27 <blaenk> yup
18:02:28 <Philippa> simpson: knock it off. Guest43271 is asking reasonable questions
18:02:30 <hpc> jollytime: functions can return functions
18:02:35 * quux just wants to be able to understand xmonad's source code.
18:02:43 <simpson> Philippa: You got it.
18:02:46 <hpc> jollytime: (+) :: Int -> (Int -> Int)
18:02:53 <hpc> jollytime: (+) 2 :: Int -> Int
18:03:00 <Guest43271> Philippa thanks!
18:03:03 <hpc> jollytime: ((+) 2) 5 :: Int
18:03:21 <jollytime> hpc, what about  foo = \x -> \y -> x + y
18:03:23 <jollytime> oops
18:03:25 <jollytime> wrong one
18:03:34 <jollytime> foldl :: (a -> b -> a) -> a -> [b] -> a
18:03:43 <jollytime> I'm not sure how to read this
18:03:43 <Philippa> Guest43271: I'm not aware of a Haskell implementation targetting microcontrollers. Haskell can make an awesome metalanguage if you teach it how to spit out microcontroller code though: think "macro assembler that checks your code makes sense"
18:04:14 <hpc> jollytime: sometimes it helps to lump a few params together; let's take foldr just to be arbitrary (and i am more comfortable with it)
18:04:15 <Philippa> Guest43271: FWIW, embedded is a large enough term these days it helps to clarify what scale of system you're looking to work on :-)
18:04:17 <hpc> :t foldr
18:04:19 <lambdabot> (a -> b -> b) -> b -> [a] -> b
18:04:49 <hpc> jollytime: if you lump the first two params together, you get foldr :: (a -> b -> b) -> b -> ([a] -> b)
18:04:58 <blaenk> parcs: yeah I'm dumb I forgot I changed the input size in between making the change you suggested. changing it back does show a 16% performance decrease
18:05:09 <hpc> which is, foldr (function of some sort) (value of some sort) :: list -> thing
18:05:09 <blaenk> parcs: so I'm calling conv and conv' with parameters [1..5] [1..10]
18:05:35 <blaenk> parcs: the interesting thing is that when I increase the parameter sizes to [1..100] [1.1000], that's when conv' is only 1% slower
18:06:15 <blaenk> I'm guessing it's a ghc optimization that conv' is missing out on in the smaller input size case, but I'm not sure
18:06:26 <hpc> jollytime: so fully applied and parenthesized, you'd have something like
18:06:46 <hpc> (((foldr f) z) [x, y, z])
18:07:02 <quux> > sort "quux"
18:07:02 <hpc> jollytime: the keywords you will want to google for are currying and partial application
18:07:04 <lambdabot>   "quux"
18:07:32 <jollytime> hpc, thanks
18:07:43 <blaenk> parcs: here's the full code I'm running https://gist.github.com/4617053
18:08:33 <YayMe`> The error monad can be used to effectively halt the monad and bubble through the following binds without acting, is there an easy catch function you can wrap an error monad in to say "in case of failure, just do x" ?
18:08:34 <jollytime> hpc, so (a -> b -> b) reads a function that takes two parameters, correct?
18:09:18 <hpc> jollytime: or it can read as function that takes a parameter and produces a function of a parameter
18:10:19 <hrumph> i need some help with yesod
18:10:51 <hrumph> i created a site with a scaffold. i want to add some columns to the user table but i don't know where the model for the user table is specified in the scaffold
18:10:58 <hpc> jollytime: incidentally, there's a proof of equivalence between "function from a thing to a function of another thing" and "function from a thing and another thing"
18:11:02 <hpc> :t curry
18:11:03 <lambdabot> ((a, b) -> c) -> a -> b -> c
18:11:04 <hpc> :t uncurry
18:11:05 <lambdabot> (a -> b -> c) -> (a, b) -> c
18:11:11 <hrumph> or should i just create an independent model for the extra user data i want to include?
18:11:12 <schellsan> hrumph, config/models
18:11:18 <schellsan> i think that's it
18:11:34 <hrumph> schelllsan you are right dammit
18:11:53 <hpc> jollytime: so generally haskellers will willfully forget about it and think in terms of 2 or more arguments
18:11:59 <hrumph> it was right under my nose i can't believe i didn't see it even though i created other entities in there
18:12:00 <hpc> jollytime: until they start playing tricks...
18:12:01 <schellsan> :)
18:12:05 <hpc> :t map (5 +)
18:12:07 <lambdabot> Num b => [b] -> [b]
18:12:11 <hpc> :t map
18:12:13 <lambdabot> (a -> b) -> [a] -> [b]
18:12:14 <hpc> :t (+)
18:12:16 <lambdabot> Num a => a -> a -> a
18:12:18 <hpc> :t (5 +)
18:12:19 <lambdabot> Num a => a -> a
18:12:30 <jollytime> i'd rather see it for what it really is
18:12:39 <jollytime> save myself some hassle down the road
18:12:41 <hrumph> i guess i was doing a bynch of gresps on *.hs files and not looking exactly where i was supposed to look
18:12:49 <hrumph> stupid wild goose chase
18:12:52 <YayMe`> can someone tell me the terms for these things: a function that's a -> m a to use in binds, the m a value itself, a chain of binds as a single function (basically a function that's written in do notation), and the m type itself. Of those things, which one is the monad? Is the monad a collection of multiple of those things? I've been struggling with terming these things as the monad finally takes full shape in my head..
18:13:44 <hpc> @src Monad
18:13:44 <lambdabot> class  Monad m  where
18:13:44 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
18:13:44 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
18:13:44 <lambdabot>     return      :: a -> m a
18:13:44 <lambdabot>     fail        :: String -> m a
18:13:50 <hpc> YayMe`: the monad is 'm' in the above
18:13:56 <quux> o_O
18:14:05 <hpc> YayMe`: any type that is an instance of Monad is "a monad"
18:14:13 <quux> This is going to be a big pill to swallow.
18:14:24 <augur> quux: monad stuff?
18:14:25 <hpc> so Maybe is a monad, but not Nothing or (Just 5) or (Maybe Int)
18:14:36 <hpc> and Either is not a monad
18:14:36 <quux> augur: Haskell
18:14:39 <augur> oh
18:14:42 <hpc> but (Either Int) can be a monad
18:14:49 <augur> well dont worry about complicated stuff for now, quux
18:14:51 <hpc> (it can be at least two monads!)
18:15:20 <quux> I won't. I'm going to play with Try Haskell! until I feel froggy enough.
18:15:25 <Mortchek> hpc, I can see the analogy to Maybe - but what's the other?
18:15:44 <hpc> YayMe`: to clarify the other things, a function of type (a -> m b) is sometimes called a "monadic function"
18:15:59 <hpc> YayMe`: and a value of type (m a) is sometimes called a "monadic action"
18:16:02 <augur> quux: lyah
18:16:05 <quux> I decided to try learning Haskell because C isn't sinking in so well, and I would like to hack on xmonad a little bit.
18:16:23 <hpc> YayMe`: that last point becomes a big sticker when you start talking about things that take actions as parameters (see: parser combinators)
18:16:27 <ion> quux: See LYAH, too.
18:16:28 <ion> @where lyah
18:16:28 <lambdabot> http://www.learnyouahaskell.com/
18:16:34 <geekosaur> jumping from C to Haskell, yes, I imagine your head will spin a bit
18:17:02 <hpc> i jumped from perl to haskell
18:17:07 <hpc> it was remarkably natural
18:17:28 <jollytime> perl is weird already :p
18:17:31 <hpc> i think it was because i actively wanted to forget perl
18:17:34 <geekosaur> perl at least comes with some functional constructs
18:17:42 <hpc> so i could quickly get into that zen state of "to learn, you must first unlearn"
18:17:59 <quux> augur, ion: thanks, that's my next planned step :)
18:18:10 <geekosaur> and lambdas.  you *still* can't do a lambda in ANSI C...
18:18:16 <geekosaur> (C++, yes)
18:18:21 <quux> is that the same as Learn You A Haskell For  Great Good!?
18:18:26 <geekosaur> yes
18:18:29 <quux> mmkay.
18:18:37 <augur> quux: should be your first step
18:18:44 <Mortchek> You sounded bewildered, then I remembered the punctuation in the title.
18:19:03 <YayMe`> hpc: would you take a look at what I wrote in javascript? I think I wrote what I'm calling "monadic combinators" but the terminology in my head get's confusing. they're not for parsing, though you could write a parser with them
18:19:12 <Hafydd> geekosaur: do you expect that they should be implemented in C?
18:19:29 <YayMe`> http://codereview.stackexchange.com/questions/20845
18:19:45 <YayMe`> hpc: what would you call "m_.or" in this?
18:20:03 <quux> Well, it'll be my first step after the interactive tutorials.
18:20:07 <quux> Thank you :)
18:20:10 <geekosaur> Hafydd, no, just pointing out the gulf between the languages
18:20:20 <geekosaur> C's kinda deliberately primitive
18:20:21 <YayMe`> it takes two.. "monadic function"s and returns one
18:20:33 <YayMe`> hpc: is that a "monadic combinator" ? what I just described
18:20:44 <Hafydd> I agree, but your use of "*still*" made me wonder.
18:20:59 <hpc> YayMe`: you almost seem to have invented Maybe
18:21:10 <hpc> it's hard to tell without any actual data declaration (yay js!)
18:22:00 <jollytime> hpc, just a quick recap, so best way to think of (a -> b -> b) is function that takes a parameter and returns a function, correct?
18:22:35 <ion> jollytime: Or a function of two parameters. Whichever seems more convenient at the time.
18:22:52 <jollytime> ion, but isn't that an illusion?
18:22:57 <hpc> jollytime: yes, or what ion said; either is correct up to isomorphism
18:23:26 <YayMe`> hpc: lol I know. I was aiming for the error monad which I've never actually used but the way I implemented bind basically does what I think the error monad does, and then my or is like what I was told monadplus for either is, does that seem right to you?
18:23:29 <jollytime> but if a function in haskell truly only takes one parameter, then saying otherwise is a lie, isn't it :D
18:23:36 <Hafydd> I don't see any advantage to thinking about them as n-ary functions.
18:23:54 <parcs> @tell blaenk i don't know what accounts for the difference in runtime, but you can go further in your investigation by comparing the core that ghc generates for each function with the -ddump-simpl flag. also, you can replace 'pad = replicate (length hs - 1) 0' with the more efficient 'pad = map (const 0) (drop 1 hs)'
18:23:54 <lambdabot> Consider it noted.
18:24:02 <YayMe`> hpc: what would the terms for "or" and "then" in there be? they both take two "monadic function"s and return one "monadic function", what does that make them?
18:24:30 <ion> Well, if you define “a function of two parameters” as “a function that returns a function”, either is fine. :-P
18:24:52 <hpc> YayMe`: completely assuming the rest of the code is right, monadic function of two actions
18:25:00 <hpc> YayMe`: you seem to have defined
18:25:06 <hpc> @src Maybe (<|>)
18:25:06 <lambdabot> Nothing <|> p = p
18:25:06 <lambdabot> Just x  <|> _ = Just x
18:25:25 <hpc> :t (<|>)
18:25:27 <lambdabot> Alternative f => f a -> f a -> f a
18:25:43 <YayMe`> @src Either (<|>)
18:25:43 <lambdabot> Source not found. You untyped fool!
18:25:52 <parcs> @tell blaenk also, the difference in runtime is in the sub microsecond level which could simply mean that the GC is performing an extra minor garbage collection or something trivial like that.
18:25:52 <lambdabot> Consider it noted.
18:25:53 <YayMe`> ahh lambdabot insulted me :(
18:26:23 <YayMe`> hpc: except it's not nothing because it's success or failure and both carry a value (like left or right)
18:26:32 <hpc> ah
18:26:47 <hpc> then... similar thing for Either
18:27:07 <hpc> lambdabot's @src database is woefully deficient
18:27:15 <hpc> it's just a text file with some stuff written in
18:27:19 <hpc> some of which is right
18:27:22 <hpc> some of which is wrong
18:27:24 <YayMe`> lol
18:27:28 <hpc> much of which is missing
18:27:33 <hpc> @src sort
18:27:33 <lambdabot> sort = sortBy compare
18:27:37 <hpc> @src sortBy
18:27:37 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
18:27:50 <hpc> the real implementation of sortBy is about 20 lines and AWESOME
18:27:55 <YayMe`> lol
18:28:03 <hpc> written by... augustss iirc
18:28:21 <hpc> i might be horribly mixing up names
18:28:37 <YayMe`> hpc: so is what I implemented monadic in nature or just applicative?
18:29:01 <hpc> YayMe`: your bind appears right, and i closed the tab so i forget if return is in there
18:29:10 <hpc> but with those two you have monad, applicative, functor, etc
18:29:16 <cmccann> hpc: "Rumoured to have been based on code by Lennart Augustsson", according to the Data.List source
18:29:26 <hpc> oh yay, i was right
18:29:28 <YayMe`> wait, with monad you don't automatically have applicative do you?
18:29:32 <hpc> you do
18:29:39 <hpc> but not alternative
18:29:45 <hpc> (which you also have in your code)
18:29:49 <YayMe`> right
18:29:56 <YayMe`> huh
18:30:09 <YayMe`> how is alternative placed then if it doesn't classify as applicative?
18:30:10 <quux> Lesson 3 over, syntactic sugar is sweet. But I still don't feel ready.
18:30:21 <hpc> @src Alternative
18:30:21 <lambdabot> class Applicative f => Alternative f where
18:30:21 <lambdabot>     empty :: f a
18:30:21 <lambdabot>     (<|>) :: f a -> f a -> f a
18:30:45 <quux> let's see if i can do one from memory.
18:30:46 <hpc> laws: empty and (<|>) form a monoid
18:30:54 <cmccann> Alternative and MonadPlus are both versions of Monoid for kind (* -> *)
18:30:55 <YayMe`> quux: it's easier when you get real haskell in front of you. the REPL makes it feel weird because you can't define anything, you have to use let chains to fake up definitions
18:31:07 <quux> > [a],[b],[c] == a,b,c
18:31:09 <lambdabot>   <hint>:1:4: parse error on input `,'
18:31:15 <quux> I did it wrong.
18:31:19 <hpc> YayMe`: there's a lot of ambiguity on what extra laws should be followed
18:31:27 <hpc> MonadPlus in particular gets a lot of argument
18:31:31 <cmccann> it's all terribly redundant and especially entertaining when the Monoid and MonadPlus/Alternative instances disagree
18:31:42 <YayMe`> hpc: yeah, I noticed that when I was asking about either's monadplus on stackexchange
18:32:00 <quux> That's fine... I'm kind of hesitant  to start with lyah because it seems to assume a solid understanding of imperative programming experience, which i don't quite have.
18:32:06 <hpc> general rule, avoid MonadPlus, use Alternative
18:32:15 <pzuraq_> Is there a way to specify which variable a function will return?
18:32:21 <pzuraq_> what's the pastebin this channel uses?
18:32:28 <hpc> @where hpaste
18:32:28 <lambdabot> http://hpaste.org/
18:32:40 <YayMe`> hpc: is it safe to say: applicative, functor, and monad are fixed known rules, monadplus and perhaps monoid may be more up for debate?
18:32:49 <hpc> monoid is fixed
18:32:54 <quux> The only language I ever got a real grip on at all is of little practical use nowadays, so I'm basically just starting over with programming as a beginner.
18:33:15 <YayMe`> and applicative falls under monoid, but monadplus is just trying to steal thunder?
18:33:15 <hpc> quux: honestly, you're at an advantage
18:33:29 <hpc> haskell requires a certain amount of forgetting everything you learned before
18:33:37 <pzuraq_> http://hpaste.org/81202
18:33:38 <geekosaur> YayMe`, monadplus considerably predates applicative
18:33:44 <YayMe`> quux: good for you, us suckers who come from OOP indoctrination are assaulted to the core by this stuff
18:33:54 <pzuraq_> I feel like there should be a way to generalize leftistElement and leftistKey
18:34:02 <quux> hpc: Heh, I learned the same when I started 65xx assembly
18:34:07 <quux> heard the same ^
18:34:19 <hpc> YayMe`: fun fact, if you squint right, OOP is the dual of functional programming
18:34:58 <YayMe`> hpc: yeah basically, I feel like I'm living Steve Yegge's blog about wearing tin-foil vests under your shirt when I'm at work. Can't speak the truth or you'll be skewered
18:35:28 <geekosaur> pzuraq_, I'm looking at that and wondering if it's a bug
18:35:42 <YayMe`> meanwhile secretly pulling every of the few interested engineers I stumble across towards learning FP to right the wrongs of our forebearers..
18:35:49 <pzuraq_> probably is, now that I'm looking at it
18:35:50 <geekosaur> should leftestKey run on the left subtree really return the value instead of the key?
18:36:19 <pzuraq_> hmm? It should return the key
18:36:37 <geekosaur> leftistKey (Bind leftTree _ _) = leftistElement leftTree
18:36:40 <Eelis> hpc: got a link about the details of said squinting?
18:36:50 <geekosaur> should that not be = leftistKey leftTree?
18:37:01 <hpc> Eelis: i really wish i did
18:37:08 <Eelis> ok
18:37:14 <hpc> the nearest thing i can think of is if you google the expression problem
18:37:16 <pzuraq_> oh
18:37:22 <pzuraq_> yeah, forgot to change that
18:37:23 <quux> > [a], [b], [c] == a,b,c
18:37:25 <lambdabot>   <hint>:1:4: parse error on input `,'
18:37:29 <Eelis> i'm familiar with the expression problem, but don't see how it shows any duality
18:37:32 * quux fails again.
18:37:43 <geekosaur> which on the other hand means you no longer have your original question :)
18:37:57 <hpc> Eelis: like i said, wish i had a good link :P
18:38:00 <Eelis> :)
18:38:03 <YayMe`> hpc: so monad gives functor and applicative by default (granted I have never been able to wrap my head around <$> or <*>), and since I have return and bind (bind behaves like error monads), I should be able to implement <$> and <*> (what are those called in english?) in my stuff there for more interestingness?
18:38:13 <quux> One more try.
18:38:33 <quux> > [ a , b , c ] == a,b,c
18:38:34 <lambdabot>   <hint>:1:19: parse error on input `,'
18:38:41 <quux> time for a break.
18:39:34 <YayMe`> and did I catch you right, my function: or (Monad m) => (a -> m b) -> (a -> m b) -> (a -> m b) is a "function of two monadic actions" ?
18:39:35 <hpc> YayMe`: let's just implement it
18:39:48 <hpc> er, implement the whole stack of type classes
18:39:49 <ion> yayme: fmap and ap
18:39:53 * hpc hpastes
18:40:32 <hpaste> hpc pasted “Functor” at http://hpaste.org/81204
18:40:41 <hpc> http://hpaste.org/81204 -- Functor from Monad
18:41:00 <hpc> er, i got the type of return wrong
18:42:31 <YayMe`> hpc: interesting, I am not familiar with the bind you defined, in javascript I defined (>>=) type of bind
18:43:12 * hackagebot hs-excelx 0.5.2.1 - HS-Excelx provides basic read-only access to Excel 2007 and 2010 documents in XLSX format.  http://hackage.haskell.org/package/hs-excelx-0.5.2.1 (MarkBaran)
18:43:32 <hpaste> hpc annotated “Functor” with “Functor (annotation)” at http://hpaste.org/81204#a81205
18:43:44 <hpc> http://hpaste.org/81205 -- applicative
18:43:53 <hpc> YayMe`: mine is just (=<<)
18:44:05 <hpc> which is (>>=) with the arguments reversed
18:44:10 <quux> ['a','b','c'] == a,b,c
18:44:17 <quux> oops
18:44:18 <YayMe`> hpc: how is return . f become (m a -> m b) instead of m (a -> b) ?
18:44:22 <quux> > ['a','b','c'] == a,b,c
18:44:23 <lambdabot>   <hint>:1:19: parse error on input `,'
18:44:26 <hpc> :t (return . ?f)
18:44:27 <lambdabot> (?f::f a, Monad m, Functor f) => f (m a)
18:44:35 <hpc> argh
18:44:38 <hpc> :t (return Prelude.. ?f)
18:44:39 <lambdabot> (?f::a -> b, Monad m) => a -> m b
18:44:51 <quux> > ['a','b','c'] == abc
18:44:53 <lambdabot>   Not in scope: `abc'
18:44:53 <lambdabot>  Perhaps you meant `abs' (imported from Prelude)
18:45:05 <quux> blah, forget it
18:45:07 <ion> > ['a', 'b', 'c'] == "abc"
18:45:09 <lambdabot>   True
18:45:22 <hpc> YayMe`: f :: (a -> b)
18:45:26 * quux facepalms
18:45:31 <hpc> (return . f) :: (a -> m b)
18:45:38 <YayMe`> hpc: does m (a -> b) just automatically transform into m a -> m b as some kind of distributive property?
18:45:46 <YayMe`> hpc: oo that's better
18:45:46 <hpc> bind :: (a -> m b) -> (m a -> m b)
18:45:51 <quux> Thank you, ion.
18:45:53 <YayMe`> perfect
18:45:54 <hpc> bind is the magic
18:46:23 <quux> Now if I can just commit it to memory.
18:46:31 <ion> I wrote something about Functor, Applicative and Monad in the context of Parsers recently, but this probably won’t be informative if you’re not familiar with Parsec-style parsing already. http://www.reddit.com/r/haskell/comments/16kf0j/parsing_markdown_with_parsec_how_pandoc_does_it/c7x9v3j?context=1
18:47:11 <YayMe`> ion: the reason I wrote the monadic functions I did is because of how awesome I found attoparsec when I wrote a couple parsers for kicks
18:48:07 <johnw> YayMe`: you would probably also like tirfecta
18:48:08 <johnw> trifecta
18:48:12 <YayMe`> ion: seeing how it worked I figured the same thing could be generalized to make any state machine composable in such a simple pleasant way, though I'm sure y'all knwo far more about it than i
18:48:52 <hpc> YayMe`: (State s) is a monad that abstracts pure state
18:49:35 <hpc> YayMe`: generally it depends on what you want to do with the state though, as there can be much nicer ways of handling it
18:50:00 <YayMe`> hpc: yeah I get that, but I'm referring to state machine as in control-flow constructs, the things most programmers create as behemoths of nested ifs and switches nested in ifs and switches and so on and so forth
18:50:08 <hpc> oh yes
18:50:11 <hpc> that's super easy
18:50:21 <YayMe`> hpc: in other words, how most oop/procedural programmers would write a parser
18:51:52 <YayMe`> hpc: seeing parser combinators I figured you could make the same thing to get the evil oop/procedural control-flow stuff composable for all general scenarios not just for parsing
18:52:22 <hpc> that would be Cont
18:52:30 <YayMe`> hpc: that's what my javascript is supposed to be kind of like, users create functions that take something and return success or failure (left or right), and then they compose them with or and then
18:52:43 <YayMe`> and until
18:53:09 <hpc> ah, you're actually still describing Either
18:53:15 <YayMe`> the composed piece being just a reusable function, you pass it to run along with a value to start the machine
18:53:49 <YayMe`> hpc: i'm talking about my general idea of composable control-flow to avoid ifs and switches nested all over eachother
18:55:07 <YayMe`> maybe i'll try translating my javascript into haskell so you guys can properly tell me what I'm doing wrong or why it's been done (and how it's been done better)
18:55:29 <YayMe`> http://codereview.stackexchange.com/questions/20845
18:56:29 <YayMe`> hpc: what's Cont ?
18:56:42 <cmccann> @src ContT
18:56:42 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
18:57:35 <NemesisD> hi guys. i have a datatype basically equivalent to either, i want to define an instance that maps a function over the Right value
18:58:41 <YayMe`> looks like either is popular tonight..
18:58:43 <cmccann> @hackage bifunctors -- NemesisD
18:58:43 <lambdabot> http://hackage.haskell.org/package/bifunctors -- NemesisD
18:58:51 <NemesisD> it seems like functor is the right one, but the type doesn't make a lot of sense: data RPCResponse a = Success a | Failure String, instance (Functor a); fmap _ (Failure s) = Failure s; fmap f (Success x) = Success (f x)
18:59:21 <parcs> NemesisD: that's a pretty sensible functor
18:59:36 <cmccann> oh, if you only have one type parameter, then just make it a Functor instance.
18:59:40 <YayMe`> cmccann: yeah, that does look similar to the idea I'm after
19:00:02 <NemesisD> parcs: but "the first argument of Functor should have kind * -> * but RPCResponse a has kind *
19:00:12 <YayMe`> cmccann: what does the class look like?
19:00:21 <cmccann> YayMe`: which class?
19:00:32 <YayMe`> cmccann: ContT or does it not have one?
19:00:33 <parcs> NemesisD: oh, you have to do 'instance Functor RPCResponse'
19:00:40 <cmccann> @src MonadCont
19:00:40 <lambdabot> class (Monad m) => MonadCont m where
19:00:40 <lambdabot>     callCC :: ((a -> m b) -> m a) -> m a
19:01:09 <YayMe`> that is strange
19:01:20 <YayMe`> how m a becomes m b I can't intuit
19:01:20 <cmccann> yes, it's call-cc
19:01:52 <NemesisD> ohhh
19:01:58 <YayMe`> cmccann: What do people use this Cont stuff for?
19:02:19 <cmccann> YayMe`: when you have "callCC f", f is called with an argument representing the "current continuation", i.e., the rest of the computation after the point where callCC is used.
19:02:34 <YayMe`> ahh
19:02:36 <cmccann> it's like setting a label and then calling a function with a portable goto pointing at that label.
19:02:54 <YayMe`> yes that does sound like what I'm doing in my javascript stuff
19:03:01 <johnw> YayMe`: there are some examples of using Cont here: http://www.vex.net/~trebla/haskell/cont-monad.xhtml
19:03:12 * hackagebot git-annex 3.20130124 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20130124 (JoeyHess)
19:03:43 <YayMe`> but I'm doing it with Either so that like error monad all continuations past a failure point will fail, but you can continue from earlier points using my or
19:03:58 <YayMe`> cmccann: Does that make any sense?
19:04:07 <YayMe`> or sound like something people have done?
19:04:24 <cmccann> YayMe`: if you're passing around success and failure continuations that's probably something like the church encoding of Either?
19:04:27 <YayMe`> I've learned basically every idea for something functional I come up with I find out is already in one of the main libs
19:04:30 <NemesisD> i think i have a problem of using functor, monad and applicative pretty much randomly until one of them works. functor doesn't solve my problem lol
19:04:31 <johnw> YayMe`: have you seen delimited continuations?
19:04:37 <YayMe`> cmccann: that's exactly what I'm passing around
19:04:45 <cmccann> i.e. (Either a b) = ((a -> r) -> (b -> r) -> r)
19:04:52 <parcs> NemesisD: what problem?
19:05:20 <YayMe`> cmccann: so read up on church encoding of either, is that something people use?
19:05:42 <cmccann> YayMe`: it's how you represent sum types in a lambda calculus with no data types
19:06:43 <NemesisD> parcs: i solved it, i needed an "fmap (fmap somefunction)" because i'm operating in a StateT
19:06:44 <cmccann> in general anything like church encodings or CPS transforms make things really convoluted and harder to understand if exposed to the programmer
19:06:55 <NemesisD> im not sure if there's an idiom for fmap . fmap
19:07:16 <johnw> :t fmap . fmap
19:07:18 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
19:07:37 <cmccann> YayMe`: but you can build other abstractions using that stuff, or sometimes exploit it for performance reasons
19:07:45 <NemesisD> man what happened to hayoo
19:08:40 <geekosaur> not sure, it was gone entirely for several days, yesterday it was there but slow
19:09:12 <YayMe`> cmccann: here's an example usage: inc a = success a+1 ... fail a = failure a ... fewIncs a = inc `then` inc `then` fail `then` inc ... run fewIncs 1 -> failure 3
19:09:26 <hpaste> feliperosa pasted “Applictives Q” at http://hpaste.org/81206
19:10:00 <feliperosa> hi guys, I'm trying to understand Applicatives. Could someone check that code, there's a question in it
19:10:09 <NemesisD> johnw: should i just alias fmap . fmap somewhere or is it indicating that i need a different instance
19:10:15 <YayMe`> cmccann: I implemented then and run in this way, as well as having bind honor failure to halt
19:10:54 <YayMe`> cmccann: then in that example, you could run (fewIncs `or` inc) 1 -> success 2
19:11:17 <feliperosa> please? http://hpaste.org/81206
19:11:25 <johnw> NemesisD: I use successive fmaps aften when dealing with nested monad transformers, or a monad transformer whose state value is a functor, for example
19:11:30 <johnw> ffmap would be good
19:12:02 <YayMe`> cmccann: does this make sense? then and or are both (Monad m) => (a -> m b) -> (a -> m b) -> (a -> m b)
19:12:17 <Philippa> johnw: like cadddr?
19:12:22 <johnw> yeah, exactly
19:12:35 <johnw> although i never use those :)
19:13:03 <m3ga> curses anyone? i see both hscurses and ncurses. hscurses is a little closer to the C api, but ncurses seems nicer. opinions?
19:13:58 <cmccann> YayMe`: I'm not sure I'm completely following, sorry. a bit distracted at the moment :\
19:15:29 <YayMe`> cmccann: No worries, I appreciate it anyway. Just trying to find a normal haskell thing I can relate what I did to, to treat like an answer sheet to compare but nothing seems to line up quite exact (so I likely did something wrong heh)
19:17:09 <YayMe`> the people who know the standard libs well enough to be helpful are always splitting their attention
19:17:57 <cmccann> YayMe`: juggling continuations around is a very broad concept so I don't know if there's anything specific to point you at anyhow
19:27:58 <shachaf> cmccann: Why do you answer all the good SO questions, anyway?
19:28:43 <cmccann> shachaf: for SCIENCE!
19:28:53 * shachaf notes that no one there mentioned that encoding ∃ with ∀ is mostly just currying.
19:29:49 <cmccann> I decided not to get into the issue of quantifiers as binders for type arguments.
19:30:29 <shachaf> To me that's what makes the encoding obvious directly, rather than indirectly.
19:30:38 <shachaf> Someone should write a thing about all these things!
19:30:41 <shachaf> (Someone = you.)
19:30:47 <shachaf> (Weren't you writing a Haskell book or something?)
19:31:32 <cmccann> shachaf: I've written at least two answers about those things.
19:31:41 <cmccann> I can only write about so many things in one thing.
19:31:42 <shachaf> Answers don't count.
19:31:45 <PolishDemon> hey guys :D
19:31:51 <cmccann> too many things would just be too many.
19:32:00 <shachaf> cmccann: And I've written a bunch of things in IRC about these things!
19:32:04 <PolishDemon> anyone have a good resource explaining tail recursion? I'm a tad lost -__-
19:32:47 <shachaf> PolishDemon: "tail recursion" is a thing that matters less in Haskell than in some other languages.
19:32:51 <shachaf> Or at any rate matters differently.
19:32:55 <shachaf> Where did you come across it?
19:33:04 <callen> shachaf: it matters in the sense that you don't have iteration, no?
19:33:15 <PolishDemon> right, but specifically in one of my classes, we're using haskell, and my professor wants us to optimize using tail recusrion
19:33:20 <PolishDemon> or at least try to
19:33:24 <shachaf> callen: Hmm?
19:33:43 <shachaf> PolishDemon: Here's an example of tail recursion:
19:33:44 <shachaf> @src foldl
19:33:44 <lambdabot> foldl f z []     = z
19:33:44 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:33:55 <shachaf> See how foldl is just calling itself repeatedly?
19:34:14 <PolishDemon> yes
19:34:20 <shachaf> As in, foldl a b c = fold a' b' c'
19:34:23 <shachaf> l
19:34:30 <YayMe`> cmccann: "Applicative gives you the additional power of running two parsers sequentially and having the first one result in a function to be applied to the result value of the second one." -> Does it give the initial value to each of the two parsers, and then applie the result from the first to the second basically?
19:34:30 <shachaf> Compare to:
19:34:32 <shachaf> @src foldr
19:34:32 <lambdabot> foldr f z []     = z
19:34:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:34:59 <shachaf> foldr a b c = blah blah (foldr a' b' c')
19:35:09 <callen> shachaf: maybe I've misunderstood something, but you don't have loops...right?
19:35:12 <callen> just recursion.
19:35:19 <cmccann> shachaf: also I think I've mentioned before wanting to write a thing about typed functional programming in general, starting from kinda first principles-ish
19:35:19 <YayMe`> cmccann: the "sequential" in that statement you made, makes the following part about applying result from first to result from second weird
19:35:19 <shachaf> callen: In Haskell? Sure, I guess.
19:35:26 <callen> shachaf: right that's my point.
19:35:41 <shachaf> callen: What does it have to do with tail recursion as such?
19:35:54 <cmccann> shachaf: which would probably incidentally use Haskell but not be about Haskell specifically as such
19:36:03 <shachaf> cmccann: Sure, that would be better.
19:36:47 <PolishDemon> shachaf: thanks!
19:36:58 <shachaf> PolishDemon: You managed to get something out of all that? I'm surprised.
19:37:02 <cmccann> YayMe`: well, the meaning of doing stuff with Applicative depends on the instance. I can't remember what the context of what you're quoting was.
19:37:02 <shachaf> I kind of made no sense.
19:37:04 <YayMe`> cmccann: is it like so: (<*>) p1 p2 = \x -> (p1 x) $ p2 x
19:37:17 <PolishDemon> well, taking a look, noticing a few differences. at least it's an example to look at :)
19:37:17 <callen> shachaf: I might be making a different point, but it seems to me that in the absence of TCO, you can't have a turing-complete machine with only recursion.
19:37:17 <shachaf> PolishDemon: Anyway, the question is why tail recursion is an optimization.
19:37:21 <YayMe`> cmccann: It's that reddit you linked
19:37:32 <shachaf> The answer is easy in strict languages but not as easy in Haskell.
19:37:39 <cmccann> YayMe`: that is (<*>) for one specific Applicative instance, yes
19:37:40 <shachaf> callen: Why?
19:37:46 <PolishDemon> well, compiled down to machine code it's a simple loop, no?
19:37:51 <shachaf> callen: A Turing machine has infinite tape. :-)
19:38:04 <hpaste> callen pasted “Round-Two, cabal can't upgrade.” at http://hpaste.org/81207
19:38:14 <callen> anybody care to take a whack?
19:38:20 <YayMe`> cmccann: awesome! That would be super easy to implement in the system I already wrote, so applicative probably would be easy to write for me
19:38:25 <callen> I installed via haskell-platform on the website.
19:38:57 <callen> I can update cabal, but not upgrade
19:39:53 <YayMe`> cmccann: Is that a common expectation of <*>, that it gives the passed in term to both functions, but then the way the results are combined differs for different types ?
19:39:53 <cmccann> YayMe`: that wasn't me that gave the link, it was ion
19:40:07 <YayMe`> cmccann: Well I'm not that sharp, deal
19:40:14 <ion> callen: When did that problem start? Did you run some specific command? What did you try to upgrade?
19:40:33 <cmccann> heh, just glad my memory isn't that bad
19:41:06 <cmccann> YayMe`: and no, different Applicative instances can be very different
19:42:05 <ion> yayme: (<*>) f g a = f a (g a) only in the (->) r instance. http://heh.fi/haskell/functors/#function-instance
19:43:01 <cmccann> the only consistent pattern is that Applicative combines the "structure" involved without inspecting the parametric part
19:43:21 <YayMe`> cmccann: How would you describe the intuition to build for applicative? For monad my intuition is something like: Takes value from a context, and a function to act on that value which then places it back into the context to sequence modifications
19:43:34 <YayMe`> ah
19:43:35 <shachaf> That intuition will get you nowhere.
19:43:42 <cmccann> so e.g. where the Monad instance for [] can express filtering and such, the Applicative instance can only do a cartesian product
19:43:54 <YayMe`> cmccann: combines the "structure" without inspecting the <word I can never figure out> part
19:44:06 <shachaf> There is no "value in a context", with monads.
19:44:55 <shachaf> The main thing about Applicative as opposed to Monad is that it's "context-free". But I'm not sure that'll help you much. :-)
19:45:11 <cmccann> YayMe`: public consensus seems to be that my best explanation of Applicative is the answer here: http://stackoverflow.com/q/3242361/157360
19:45:27 <shachaf> i love public consensus
19:45:43 <shachaf> Oh, you said "my", not "the".
19:46:08 <glguy_> shachaf: Where do you stand on public acceptance?
19:46:16 <shachaf> glguy_: imo it is so easy
19:46:25 <YayMe`> shachaf: what do you call the a in m a ?
19:46:37 <shachaf> I call it "a".
19:46:56 <YayMe`> you don't think of it as a value?
19:46:57 <ion> s t a b
19:47:06 <ion> yayme: It’s a type.
19:47:08 <shachaf> YayMe`: No, it's a type.
19:47:37 <cmccann> YayMe`: the answer I wrote here might be more directly helpful though: http://stackoverflow.com/q/8446263/157360
19:47:46 <YayMe`> shachaf: Either 1 <-- what is the 1 called?
19:47:56 <ion> yayme: A type error
19:48:08 <cmccann> (soon I'll be able to have entire conversations in terms of linking to things I wrote on SO)
19:48:08 <shachaf> ion: Now, now. It's a kind error.
19:48:10 <YayMe`> ion: lol right
19:48:16 <ion> shachaf: heh
19:48:24 <YayMe`> Left 1 <-- what is the 1 here called?
19:48:33 <shachaf> It's called 1.
19:48:45 <shachaf> How about: f x = ord x + 1
19:48:50 <shachaf> What's the (ord x + 1) called?
19:48:56 <glguy_> f x
19:48:58 <YayMe`> cmccann: 45k, I have no idea how you do that
19:49:15 <shachaf> cmccann loves stackoverflow
19:49:17 <shachaf> it is so easy for him
19:49:27 <YayMe`> shachaf: I think of that as a function, is that wrong?
19:49:43 <shachaf> YayMe`: ord x + 1 isn't a function. It's a value.
19:49:48 <cmccann> shachaf should write more answers on SO. it would be so easy.
19:49:49 <shachaf> (\x -> ord x + 1) is a function. :-)
19:50:08 <shachaf> YayMe`: The point is that (\x -> ord x + 1) :: m Int, for a particular m.
19:50:18 <ion> > (ord 'a' + 1) 2  -- aww, they killed NumInstances
19:50:20 <lambdabot>   The function `GHC.Base.ord 'a' GHC.Num.+ 1'
19:50:20 <lambdabot>  is applied to one argument,
19:50:20 <lambdabot>  b...
19:50:30 <ion> Oh, wait
19:50:34 <ion> That wouldn’t have worked anyway.
19:50:39 <shachaf> ion: Doesn't stop you from trying to confuse people.
19:51:02 <glguy_> shachaf is on a roll!
19:51:21 <shachaf> glguy_: I have bad memories of the NumInstances days.
19:51:33 <ion> Fortunately we still have (.) = fmap
19:51:38 <shachaf> Hooray.
19:51:47 <cmccann> > let 1 + 1 = 3 in 1 + 1
19:51:49 <lambdabot>   3
19:52:04 <cmccann> (that one's actually sorta educational though)
19:53:06 <shachaf> cmccann: I'm sorry, I've already gotten 40 points on an answer.
19:53:08 <shachaf> 41?
19:53:17 <cmccann> that's not good enough. keep trying!
19:53:20 <shachaf> *And* it was a monad tutorial.
19:53:24 <shachaf> Of sorts.
19:53:27 <cmccann> even worse!
19:53:29 <shachaf> I think that means I win SO.
19:54:00 <shachaf> stackoverflow is like an endomorphic monoid
19:55:04 <cmccann> hm, new HWN. looks like only a third of the quotes are about lens.
19:55:04 <PolishDemon> may I also ask: editor of choice for you guys?
19:55:15 <glguy_> Coca Cola
19:55:20 <ion> @quote vim.*nano
19:55:20 <lambdabot> ion says: let es = ["vim", "emacs", "nano"] in map (\e -> intercalate " and " (delete e es) ++ " suck, learn " ++ e) es
19:55:36 <shachaf> vimmmmmmmmmmmmmmmm
19:55:38 <shachaf> Er.
19:55:40 <shachaf> Oops.
19:55:45 <shachaf> Not that.
19:55:47 * shachaf sighs.
19:56:00 <shachaf> Let it be known that I am not recommending vim.
19:56:10 <shachaf> I'm just bad at keyboards.
19:56:13 <ion> He is recommending vimmmmmmmmmmmmmmmm.
19:56:21 <shachaf> Not that one either.
19:56:30 <glguy_> shachaf: There's still time to correct your recommendation, then
19:56:41 <cmccann> shachaf: have you considered replacing your keyboard with a lens
19:56:42 <shachaf> Hmm. I'll go with Pepsi?
19:56:45 <geekosaur> his cat/other pet might be recommending vim though :)
19:56:58 <shachaf> My other pet is a lens.
19:57:01 <johnw> shachaf: I wonder if in a blind usage test, people would vi over Emacs
19:57:15 <glguy_> 4 of 5 dentists recommend vim
19:57:26 <shachaf> johnw: Emacs is sweeter in the beginning, but overpowering by the time you finish the can.
19:57:33 <shachaf> So the tests aren't really fair.
19:57:39 <johnw> but it uses real cane sugar
19:57:40 <glguy_> johnw: would you have to go by beeps to decide which you liked better?
19:57:50 <shachaf> No one uses real cane sugar these days.
19:58:06 <johnw> glguy_: my Emacs already beeps too much at me
19:58:16 * cmccann wonders what soft drink SciTE would correspond to.
19:58:32 <glguy_> Mexican Coca Cola uses cane sugar afaik
19:58:45 <johnw> I didn't realize I wasn't in -blah!
19:59:07 <PolishDemon> mexican coca cola is the best.
19:59:11 <PolishDemon> THE best.
19:59:24 <shachaf> OK, this is enough.
19:59:49 <johnw> I love having enough
19:59:50 <johnw> it is so easy
20:00:04 <shachaf> PolishDemon: Editor questions are prone to start flamewars and won't actually help you at all. Lots of people use lots of editors.
20:00:14 <shachaf> PolishDemon: I recommend: Whichever one you were using anyway.
20:00:24 <shachaf> Don't bother learning both Haskell and an editor at the same time.
20:00:25 <PolishDemon> shachaf: sure, i was just curious :)
20:00:42 <PolishDemon> shachaf: I'm currently just using Sublime Text w/ some add-on packages.
20:00:49 <shachaf> These questions have been asked in here hundreds of times before and they never lead to any good.
20:00:57 <PolishDemon> I'll know for next time :)
20:01:01 <shachaf> People are parodying the old discussions with their joke answers.
20:01:11 <cmccann> ed is the standard editor!
20:01:13 <shachaf> That's why you're not getting any useful answers. :-)
20:01:26 <shachaf> cmccann: edwardk is?
20:01:27 <ion> I hear there are some great Haskell addons for Emacs. I should get around to learning it. There are also syntastic (which supports hdevtools) and vim-hdevtools for vim which are quite nice.
20:01:37 <cmccann> shachaf: it's possible.
20:01:43 <YayMe`> shachaf cmccann: my or is <|>, my then maybe qualifies for <*> ? my then is basically (i'm going to butcher case syntax, sorry) then f1 f2 = \x -> case (f1 x) of (Success y) -> f2 y | z -> z
20:01:44 <shachaf> ion: i love vim-hdevtools
20:01:51 <johnw> ion: I created hdevtools support for flycheck, btw
20:01:55 <YayMe`> would that match the intuition of <*> ?
20:01:57 <johnw> it works insanely well
20:02:06 <shachaf> YayMe`: (<|>) isn't an Applicative method.
20:02:16 <johnw> <|> is Alternative
20:02:16 <shachaf> If you want to learn about Applicative, stick to Applicative, not its weird subclasses.
20:02:35 <YayMe`> shachaf: right, but does my then seem to fit?
20:02:47 <YayMe`> as <*> ?
20:03:00 <shachaf> YayMe`: No.
20:03:11 <YayMe`> shachaf: balls.
20:03:15 <shachaf> Applicative is not about failure, and therefore not about success.
20:03:30 <shachaf> YayMe`: Maybe start with a good intuition for Functor/fmap.
20:03:58 <shachaf> YayM`: Given fmap, (<*>) :: f (a -> b) -> f a -> f b, liftA2 :: (a -> b -> c) -> f a -> f b -> f c, and liftA2 (,) :: f a -> f b -> f (a,b) are all equivalent.
20:04:11 <shachaf> YayMe`: I think the latter two are much simpler than the first one.
20:04:13 <YayMe`> shachaf: does either make sense as applicative?
20:04:24 <shachaf> Either what?
20:04:28 <shachaf> Oh, "Either"? Sure.
20:04:33 <shachaf> Well, "Either e".
20:04:59 <YayMe`> Ok, so I'm at least not working in an incorrect basis to begin with
20:06:34 <cmccann> YayMe`: try writing the rough structure of what you want to do in Haskell and then see if you can make Functor and Applicative instances with them
20:06:41 <cmccann> that's the easiest way to see if it fits
20:07:03 <shachaf> And if it doesn't fit, just add unsafe****ce
20:07:12 <YayMe`> I first need to figure out what would make something applicative to begin with.. functor is easy
20:08:01 <tieTYT2> why do I get this error: Prelude> read "a" :: Char  *** Exception: Prelude.read: no parse
20:08:17 <cmccann> tieTYT2: because that doesn't parse as a Char
20:08:21 <shachaf> tieTYT2: Because that's not what Chars look like.
20:08:21 <glguy_> > show 'a'
20:08:23 <shachaf> try "'a'"
20:08:23 <lambdabot>   "'a'"
20:08:27 <cmccann> > read "'a'" :: Char
20:08:29 <lambdabot>   'a'
20:08:46 <tieTYT2> oh ok
20:08:54 <geekosaur> if you just want to pick characters off the start of a string, maybe you want head instead of read
20:09:08 <ion> yayme: Do you have something in mind you’d like to make an instance of Applicative?
20:09:11 <tieTYT2> geekosaur: naw, I'm just learning from a book and I was curious what would happen
20:09:11 <geekosaur> (make sure it's not an empty string first)
20:09:17 <tieTYT2> because I noticed that Char "implements" Read
20:09:20 <SuperNoeMan> anybody here know ocaml? the channel isn't very active right now
20:09:22 <shachaf> geekosaur: Pattern matching, please. :-(
20:09:54 <shachaf> tieTYT2: Rule of thumb: read (show a) should be the same as a.
20:10:14 <ion> read (show a) `asTypeOf` a
20:10:18 <PolishDemon> later guys! thanks for the quick response to my tail recursion question :)
20:10:28 <shachaf> ion: I was going to say that and then decided not to.
20:10:31 <YayMe`> ion: Either
20:10:51 <shachaf> YayMe`: Either doesn't have the right kind. :-) You want "Either e".
20:10:56 <shachaf> (Which already has an instance.)
20:11:20 <tieTYT2> shachaf: ah ok, thanks
20:11:21 <cmccann> shachaf: more importantly Either is also an instance of Bicrosswalk!!!!
20:11:30 <cmccann> (spoiler: that's not actually important at all)
20:11:32 <ion> yayme: Ok, (<*>) :: Either e (a -> b) -> Either e a -> Either e b. How would you implement that for the “both are Rights” case?
20:11:33 <YayMe`> shachaf: What is Either e different from Either? they're different data types or just a partially completed version of Either ?
20:11:46 <shachaf> YayMe`: (Either e) is (Either) applied to one argument, yes.
20:12:21 <shachaf> YayMe`: If ion's exercise is too hard, I recommend trying pair :: Either e a -> Either e b -> Either e (a,b)
20:12:33 <shachaf> Or lift2  :: (a -> b -> c) -> Either e a -> Either e b -> Either e c
20:12:40 <tieTYT2> i may not be ready to understand the answer: Is Enum a type, a class, or a typeclass?
20:12:53 <shachaf> tieTYT2: It is a type class, also known as a class.
20:12:56 <cmccann> @src Enum
20:12:56 <lambdabot> class  Enum a   where
20:12:56 <lambdabot>     succ                     :: a -> a
20:12:56 <lambdabot>     pred                     :: a -> a
20:12:56 <lambdabot>     toEnum                   :: Int -> a
20:12:56 <lambdabot>     fromEnum                 :: a -> Int
20:12:58 <lambdabot> [3 @more lines]
20:13:19 <NemesisD> what datatype should i use to represent a floating point percentage?
20:13:26 <NemesisD> i.e. 40.5%
20:13:33 <shachaf> That doesn't look like a floating point to me.
20:13:42 <tieTYT2> cmccann: I'm just getting started, but I pretty much understand that
20:14:04 <NemesisD> i think i use that term wrong pretty frequently. what i meant is that it isn't necessarily an integer
20:14:20 <tieTYT2> shachaf: and what is Int?  Is that a data type?
20:14:26 <tieTYT2> @src Int
20:14:26 <lambdabot> data Int = I# Int#
20:14:27 <shachaf> NemesisD: You could use Rational.
20:14:33 <shachaf> tieTYT2: Int is a type, yes.
20:14:34 <cmccann> NemesisD: or Fixed
20:14:48 <tieTYT2> it's a data type but not a class type, right?
20:14:48 <shachaf> Or gasp Double.
20:14:57 <shachaf> tieTYT2: Correct. There's no such thing as a class type.
20:14:59 <cmccann> floating point is the devil.
20:15:11 <shachaf> There are classes -- which are the same thing as type classes -- and there are types.
20:15:15 <ion> Floating point is convenient for some things, but not most.
20:15:37 <tieTYT2> err, I meant
20:15:41 <tieTYT2> it's a data type but not a type class, right?
20:15:46 <shachaf> Correct.
20:15:51 <tieTYT2> ok cool
20:16:15 <tieTYT2> but both Enum and Int are called classes?  (I'm starting to annoy even myself here)
20:16:23 <shachaf> tieTYT2: No. Int is a type.
20:16:24 <ion> Nothing is both a data type and a type class.
20:16:27 <shachaf> Enum is a class.
20:16:34 <shachaf> ion: Nothing is a value.
20:16:34 <cmccann> ion: no, Nothing is a data constructor.
20:16:40 <cmccann> ...dammit shachaf
20:16:42 <ion> :-D
20:17:05 <tieTYT2> I thought someone above said that Enum can also be called a type class
20:17:16 <ion> There is nothing that is both a data type and a type class.
20:17:16 <shachaf> tieTYT2: "type class" means exactly the same thing as "class".
20:17:24 <shachaf> There's no other kind of class.
20:17:35 <shachaf> (Please, no pedantry over my use of "kind", cmccann.)
20:18:20 <cmccann> "type class" basically means "class of types", with "class" in the sense of "classification"
20:18:39 <shachaf> That is the classical sense of the word.
20:18:43 <shachaf> The sort you learn in class.
20:18:50 <YayMe`> Sorry was afk, so let's see for (<*>) :: Either e (a -> b) -> Either e a -> Either e b....
20:19:03 <shachaf> There's a classier definition, but we don't tell you that one yet.
20:19:56 <tieTYT2> ha ok
20:20:20 <tieTYT2> i'm really liking this learnyouahaskell book, but I wish it had exercises
20:20:42 <shachaf> i love monoids / monoids are so easy
20:20:43 <YayMe`> (<*>) (Right e1 f) (Right e2 a) = Right e2 $ f a
20:20:57 <glguy_> What's the inspiration for the "so easy" pattern?
20:21:01 <shachaf> YayMe`: Does that type-check?
20:21:01 <YayMe`> shachaf: I have no idea what to do with e1 vs e2 ?
20:21:05 <shachaf> YayMe`: (It doesn't.)
20:21:14 <YayMe`> Really?
20:21:19 <ion> shachaf: Your haiku sucked.
20:21:42 <ion> yayme: data Either e a = Left e | Right a
20:21:51 <YayMe`> Oo
20:21:54 <YayMe`> nevermind
20:22:43 <YayMe`> (<*>) (Right f) (Right a) = Right $ f a
20:23:04 <YayMe`> > :t (<*>)
20:23:05 <lambdabot>   <hint>:1:1: parse error on input `:'
20:23:22 <YayMe`> @t (<*>)
20:23:22 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:23:38 <YayMe`> ...yeah, that's what I meant...
20:23:55 <ion> yayme: That’s right (no pun intended).
20:24:02 <ion> @type (<*>)
20:24:04 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:24:12 <YayMe`> AHH
20:24:19 <YayMe`> why didn't I think to look at the type
20:24:23 <YayMe`> that makes perfect sense.
20:24:37 <ion> yayme: How would you write pure :: a -> Either e a?
20:24:58 <YayMe`> pure a = Right a
20:25:34 <ion> Correct.
20:25:48 <YayMe`> I'm really uncertain whether what I wrote was applicative or monadic, especially because my return is identical to that pure right there
20:26:03 <ion> (<*>) for the cases where exactly one of the parameters is a Left should be easy enough, too.
20:26:06 <shachaf> Either is both an instance of Applicative and an instance of Monad.
20:26:20 <shachaf> return should = pure, when you have an instance of both.
20:26:27 <YayMe`> ah
20:33:14 * hackagebot pandoc 1.10.0.5 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.10.0.5 (JohnMacFarlane)
20:38:18 <drdo> Is there some hackage mirror with ip6 support?
20:39:24 <glguy__> hdiff.luite.com has IPv6 address 2a01:4f8:190:30a1::2
20:41:11 <drdo> Doesn't work for me
20:41:26 <drdo> Unless it's cabal-install that does not support ip6 and/or requires some extra conf?
20:41:47 <tieTYT2> head' (x:_) = x  These parens have nothing to do with tuples, right?  That's so that the interpreter knows that (x:_) is one argument?
20:42:12 <drdo> tieTYT2: indeed
20:42:21 <shachaf> Grouping is the main functionality of parentheses.
20:42:28 <shachaf> Tuples are a weird secondary thing.
20:42:47 <tieTYT2> it just gave me a simple parse error without the parens.  What did it think I was trying to do without them?
20:43:13 <johnw> shachaf: and unit
20:43:21 <shachaf> johnw: And lots of things.
20:43:32 <glguy__> Oh, and naming operators
20:43:38 <johnw> oh yeah, good one
20:43:38 <shachaf> What I said is still correct.
20:43:42 <glguy__> helping shachaf is so easy
20:43:46 <shachaf> It's also used for imports/exports, and for sections.
20:43:55 <shachaf> And contexts.
20:43:58 <shachaf> And other things.
20:44:04 <glguy__> show off
20:44:17 <ion> tietyt2: (head' x):_ = x
20:44:26 <shachaf> ion++
20:44:34 <tieTYT2> ah I can kind of see how that doesn't make sense
20:44:34 * shachaf got too lost in pedantry to help.
20:44:51 <tieTYT2> thanks
20:44:54 <shachaf> Hmm, why is that a parse error?
20:44:57 <shachaf> Oh, right.
20:45:11 <drdo> constructors have to start with uppercase
20:45:22 <shachaf> drdo: Sure, but I thought it would just be a pattern match.
20:45:29 <shachaf> But of course you can't pattern match on "f x".
20:45:32 <drdo> shachaf: it would
20:45:45 <drdo> but "head'" can't be a constructor, because it starts with a lowercase letter
20:45:56 <shachaf> I think we're saying the same thing for different reasons.
20:45:57 <shachaf> Anyway never midn.
20:46:01 <drdo> Maybe
20:46:19 <YayMe`> shachaf: (<*>) :: Either e (a -> b) -> Either e a -> Either e b... (<*>) (Left e1) (Left e2) = ???
20:46:28 <shachaf> YayMe`: You get to pick.
20:46:34 <shachaf> I think either one is valid?
20:46:46 <shachaf> You have to prove the laws after you pick.
20:46:59 <YayMe`> ah, where's the laws?
20:47:09 <shachaf> @google applicative laws
20:47:11 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Applicative_Functors
20:47:11 <lambdabot> Title: Haskell/Applicative Functors - Wikibooks, open books for an open world
20:47:16 <drdo> Can anyone use cabal-install with ip6?
20:47:19 <shachaf> Hmph, wikibook.
20:47:28 <YayMe`> shachaf: thanks
20:53:15 * hackagebot egison 2.4.6 - An Interpreter and Compiler for the Programming Language Egison  http://hackage.haskell.org/package/egison-2.4.6 (SatoshiEgi)
21:08:25 <YayMe`> shachaf: say you're creating a type that's going to need to be functor, applicative, and monad; you generally always implement in that order or does it just depend time to time?
21:09:22 <shachaf> Order doesn't matter so much.
21:09:27 <YayMe`> that is, as you're putting it together
21:09:35 <YayMe`> does it make it easier to go in that order?
21:09:46 <sclv> typically fmap is the most straightforward
21:09:48 <YayMe`> because they build on eachother a bit
21:09:53 <sclv> newer ghcs can derive functor for you even
21:10:00 <callen> ion: cabal install cabal-install
21:10:13 <shachaf> sclv: In a few days a version of GHC that can derive a non-O(n^2) Functor for you will be out!
21:10:42 <sclv> very often though people define monad next, and then just do applicative in terms of monad
21:11:06 <YayMe`> gotcha
21:11:13 <shachaf> You can also define Functor in terms of Monad.
21:11:20 <YayMe`> does implementing functor make monad any easier to build on top?
21:11:24 <ion> callen: I’m under the impression you shouldn’t do that.
21:11:27 <sclv> depends on the monad!
21:11:44 <shachaf> Sometimes. If you like defining it in terms of join, for example.
21:11:47 <YayMe`> shachaf: Yeah, that's kind of how I went with what I made, which is why I'm asking which sequence is easier or if it always just depends
21:11:57 <shachaf> The Functor instance is generally very straightforward, though.
21:12:01 <sclv> i think its all very case by case
21:12:12 <sclv> but yeah, doing functor always feels like a warm-up
21:12:17 <shachaf> Just do whatever you feel like.
21:12:24 <shachaf> The Haskell motto.
21:12:44 <sclv> oh, is that our motto now?
21:12:44 <ion> @quote motto
21:12:44 <lambdabot> Zao says: Avoid Harrop At All Costs; Our new and glorious motto.
21:13:00 <shachaf> @quotto
21:13:00 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
21:13:19 <YayMe`> haha
21:13:35 <sclv> @quote avoid.success
21:13:35 <lambdabot> dpratt71 says: <dpratt71> so I read somewhere that the unofficial motto of Haskell was "avoid success at all costs"... <Baughn> dpratt71: Yeah. We failed.
21:14:11 <YayMe`> Why avoid harrop? did he stab one of the other important people when no one was looking?
21:14:24 <shachaf> I don't think he had anything to do with lenses.
21:14:36 <sclv> used to be a well known troll
21:14:40 <sclv> mellowed lately
21:14:57 <ion> Now we have shachaf instead.
21:15:18 <shachaf> Flying Seagull Consultancy
21:17:05 <YayMe`> sclv: really? Strange. He tweeted some terrible F# on codereview.se I posted which actually got me some feedback after it had sat as a dead Q forever
21:17:15 <YayMe`> seemed helpful
21:17:22 <YayMe`> unless I'm remembering wrong
21:17:46 <sclv> oh no he can be very helpful when he's in a language he likes
21:18:15 <sclv> but when he turns his attention to other language communities its like a personality transplant
21:18:23 <YayMe`> wait; likes F# but dislikes haskell?
21:18:30 <sclv> yeah
21:18:31 <sclv> a
21:18:40 <ion> Ah, he was the guy with the F# company.
21:18:45 <YayMe`> that doesn't make a lot of sense. They're pretty comparable in a lot of ways
21:18:59 <sclv> used to like ocaml. then turned on it viciously. for a while he turned on F# too and was talking about writing his own language or something
21:19:00 <shachaf> > compare "F#" "Haskell"
21:19:01 <lambdabot>   LT
21:19:04 <shachaf> Very comparable.
21:19:05 <sclv> but then returned to F#
21:19:35 <sclv> yeah, his behavior w/ other languages is trollish. it doesn't make sense really.
21:21:12 <YayMe`> shachaf: I agree, but F# is the closest in ability terms of popular languages to haskell of any I've run into..
21:29:19 <YayMe`> shachaf: how can (<*>) work for Left at all to comply with: pure f <*> pure x = pure (f x)
21:29:42 <YayMe`> shachaf: It doesn't seem possible for Either e
21:29:54 <YayMe`> (in my limited mind)
21:33:16 <shachaf> YayMe`: Where does the Left come in?
21:35:08 <sw2wolf> @hoogle Left
21:35:08 <lambdabot> Prelude Left :: a -> Either a b
21:35:09 <lambdabot> Data.Either Left :: a -> Either a b
21:35:09 <lambdabot> Control.Arrow left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
21:35:11 <YayMe`> the signature for Either e instance of applicative i was told to be (<*>) :: Either e (a -> b) -> Either e b -> Either e b
21:35:24 <shachaf> YayMe`: Take your definition of pure and (<*>).
21:35:27 <shachaf> Inline them into the law.
21:35:29 <shachaf> I bet it works out.
21:36:26 <YayMe`> shachaf: I have no definition for (<*>) that pattern matches for Left, only (Right f) (Right a)
21:36:55 <hrumph> in yesod where would a main navigation menu go in the default-layout or the default-layout-wrapper file?
21:39:02 <YayMe`> ... Right f <*> Right x = Right f x
21:39:13 <YayMe`> to meet the law, it doesn't have to work for Left?
21:39:24 <hrumph> a big beef i have with yesod is so little discussion of idomatic practices
21:39:40 <hrumph> i just read this does this and this does that
21:39:56 <hrumph> so ok i want a main navigation menu. where does it go?
21:40:00 <Nisstyre> hrumph: uh, lenses, and uh, stuff, monoids, *cough*
21:40:06 <YayMe`> haha
21:40:30 <YayMe`> I've yet not been convinced haskell has *any* idioms
21:40:33 <Nisstyre> but seriously, you have a good point
21:40:38 <Nisstyre> it's more of a low level library innit?
21:40:43 <hrumph> Nisstyre: yesod is a haskell thing so its not OT unless the channel owners tel me otherwise
21:41:00 <Nisstyre> I never suggested it was OT
21:41:18 <hrumph> ok i misunderstood your response
21:41:26 <edwardk> YayMe`: isn't there a book to try to get you into the yesod'ish way of thinking?
21:41:35 <Nisstyre> there's an OReilly book
21:41:52 <tieTYT2> why doesn't this function compile: http://pastebin.com/SJpiCJFA
21:41:53 <hrumph> there's a book and i'm actually managing to put a web site together step by step. its pretty cool
21:41:53 <mauke> The paste SJpiCJFA has been copied to http://hpaste.org/81208
21:42:02 <hrumph> i really like yesod as a matter of fact
21:42:03 <edwardk> i've not read it so i don't know how boilerplate-y it gets in the examples
21:43:10 <YayMe`> edwardk: I read some of a book on yesod but I'm more for references, the idiom stuff didn't sink in. I was mostly trying to learn to understand how to write hamlet, julius, and ceasar to interact right
21:43:32 <hrumph> i like yesod but i find that the the creator of yesod doesn't structure his documents the way i would like
21:43:51 <sclv> tieTYT2: not enough indentation
21:43:54 <edwardk> i just try to avoid being in any situation where i have to write yesod ;)
21:44:11 <edwardk> nothing against the framework just more dislike of doing webdev in general
21:44:21 <sclv> the successive wheres need to be nested beyond the beginning of the lhs of the binding declarations
21:44:29 <Nisstyre> I dislike web stuff as well
21:44:51 <tieTYT2> sclv: ah, my book hasn't said that yet but it said you could nest them.  Thanks a lot
21:45:10 <sclv> yeah, layout takes a bit of geting used to
21:45:35 <sclv> most documentation isn't very precise about the rules either, which doesn't help
21:45:39 <tieTYT2> sclv: so as long as it's one space past the first character?
21:45:55 <tieTYT2> ...of the above declaration?
21:46:01 <sclv> should be, if i recollect correctly
21:46:21 <tieTYT2> that is such a weird rule.  Means it could be very difficult to program in certain fonts
21:46:28 <sclv> each binding conceptually introduces a new scope, and so the where needs to be underneath it
21:46:44 <sclv> all haskell has to be in a monospaced font!
21:46:50 <sclv> otherwise abandon all hope :-)
21:47:01 <tieTYT2> in other words, I can't access z from the top.  That's exactly what I was trying to figure out with this code
21:47:09 <sclv> also why the community is so hard on spaces vs. tabs (since the former are uniform)
21:47:47 <sclv> exactly -- that rule makes it clear that each where "belongs" only to the scope of the preceeding declaration
21:48:51 <tieTYT2> the space rule does?  Does that mean this scope rule will apply everywhere the space rule applies?
21:49:02 <sclv> nested wheres are also sort of horrid looking. in my code, if i need to bind inside a where, i typically switch to a let
21:49:14 <tieTYT2> i learn about let's next
21:49:23 <sclv> the rules are both sort of the same.
21:49:25 <sclv> http://en.wikipedia.org/wiki/Off-side_rule
21:49:37 <tieTYT2> btw, is it possible to define pattern matching on a function that I type in ghci?
21:49:51 <sclv> the whole idea is that spacing expresses scope
21:50:11 <sclv> yeah, but declaring multiline functions in ghci requires some special tricks
21:50:59 <tieTYT2> oh
21:51:05 <tieTYT2> eh I won't bother until later then
21:51:05 <geekosaur> either use let { foo thing1 = ...; foo thing2 = ... } or use the multiline hack :{ ... :}
21:51:11 <sclv> http://stackoverflow.com/questions/8443035/multi-line-commands-in-ghci
21:51:26 <geekosaur> (the :{ and :} must be on lines by themselves)
21:51:30 <sclv> not too bad, but i don't like typing anything tricky in ghci anyway
21:51:40 <augur_> anyone know where i can find the typical alternative axiomatization of groups that uses different operator with a single gigantic obnoxious equation instead of three?
21:52:23 <YayMe`> tieTYT2: What were you writing that function for? Just trying random stuff?
21:52:29 <sw2wolf> :t (<$!>)
21:52:30 <tieTYT2> YayMe`: yeah
21:52:31 <lambdabot> Monad m => (a -> b) -> m a -> m b
21:52:46 <sw2wolf> :t (<$>)
21:52:46 <tieTYT2> YayMe`: my book didn't say if that was possible or not, so I wanted to find out
21:52:47 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:53:13 <tieTYT2> btw, is that considered a function or a constant or a variable or what?
21:54:04 <shachaf> All of the above.
21:54:16 <tieTYT2> k
21:54:28 <monochrom> sorry, what is "that"?
21:54:59 <tieTYT2> monochrom:  http://hpaste.org/81208
21:55:09 <YayMe`> pretty sure *everything* is considered a function in haskell when it's not a type
21:55:10 <shachaf> Oh, I didn't see that.
21:55:10 <tieTYT2> really I'm asking about no arg functions
21:55:17 <shachaf> No, that's not a function. Sorry.
21:55:23 <shachaf> YayMe`: No, that's completely untrue.
21:55:38 <tieTYT2> shachaf: what is it?
21:55:44 <monochrom> nestedWhere is not a function. but you can call it a constant, and you can call it a variable, though you may have funny thoughts about calling it both
21:55:46 <YayMe`> Ok, well I don't know what I'm talking about sorry
21:55:48 <shachaf> @google everything is a function in haskell?
21:55:49 <lambdabot> http://conal.net/blog/posts/everything-is-a-function-in-haskell
21:55:49 <lambdabot> Title: Conal Elliott » “Everything is a function” in Haskell?
21:55:57 <johnw> As a recovering nullary function believer, I have to agree with shachaf that's not correct at all and leads to wrong intuitions
21:56:15 <johnw> that blog post he linked to is great at explaining why
21:56:21 <YayMe`> Okey, thanks
21:56:22 <tieTYT2> ok i hope I can undersatnd it
21:56:23 <tieTYT2> ill ready
21:56:26 <tieTYT2> read
21:56:50 <johnw> soon, you won't even believe in functions taking multiple arguments :)
21:57:05 <monochrom> for haskell purposes, "x :: Bool" (for example) means that x is not a function. you need the type "X -> Y" for functions
21:57:19 <Mortchek> What, you mean functions taking tuples? ;)
21:57:31 <monochrom> for other purposes, it may be convenient to say "0-ary function". but those are not haskell purposes
21:57:32 <shachaf> The type (forall Z. X -> Y) also counts as a function.
21:58:00 <monochrom> and if you wonder about "the standard": the nice thing about standards is that there are so many to choose from
21:59:00 <monochrom> and since even mathematicians can be divided into those who consider 0 a natural number and those who do not, you can despair now
21:59:36 <monochrom> every community will use slightly different definitions. live with it. or else.
22:00:07 <tieTYT2> what's nullary mean?
22:00:11 <shachaf> monochrom: I once read a book that considered {0,1,2,...} "positive" and {1,2,3,...} "strictly positive".
22:00:18 <monochrom> takes/needs no parameters
22:00:43 <monochrom> I also heard that in French, "positive" means >=0, "negative" means <=0
22:01:06 <shachaf> Is there a word for "⋚ 0"?
22:01:08 <monochrom> n-ary means n parameters. now set n=0
22:01:24 <monochrom> the word for that is "zero"
22:01:32 <shachaf> Hmm?
22:01:43 <monochrom> unless I misunderstand you. then the word is "true"
22:01:45 <Hafydd> What does ⋚ mean?
22:01:50 <shachaf> 22DA   LESS-THAN EQUAL TO OR GREATER-THAN     [⋚]
22:01:55 <Hafydd> Heh.
22:02:07 <shachaf> monochrom: Perhaps the word is "real".
22:02:09 * applicative wonders what use "⋚" is, maybe 'comparable'
22:02:14 <shachaf> Except hyperreals are also ordered?
22:02:14 <Hafydd> "Ordered with respect to 0", maybe.
22:02:24 <shachaf> Not to be confused with: 22DB   GREATER-THAN EQUAL TO OR LESS-THAN     [⋛]
22:02:29 <Hafydd> Hahah.
22:02:35 <applicative> i /⋚ 0
22:02:37 <monochrom> oh God
22:02:40 <shachaf> See also 2278   NEITHER LESS-THAN NOR GREATER-THAN     [≸]
22:02:58 <applicative> i ≸ 0
22:03:17 <Hafydd> i ≸ u
22:03:27 <tieTYT2> shachaf: so what I made is a definition?
22:03:42 <shachaf> "definition" is a different class of thing from "function".
22:04:05 <monochrom> when you write "... = ..." in haskell, you do have a definition
22:04:20 <tieTYT2> but I write that when I write a function
22:04:33 <monochrom> but perhaps you need not worry about this so much
22:04:34 <tieTYT2> oh that's your point, I think
22:04:40 <tieTYT2> monochrom: yeah you're probably right
22:05:25 <monochrom> you write code that works. then I'm happy. I'm not too anal on terminology
22:05:48 <monochrom> but I'm anal on your self-consistency
22:06:33 <sclv> if someone writes code that doesn't work, then you're anal on terminology?
22:06:56 <monochrom> no. but I'm not happy
22:08:10 <applicative> maybe functions f :: () -> X should be called 'nullary'
22:08:55 <monochrom> ()->X is valuable for side effects. hahaha
22:09:58 <applicative> tieTYT2: here's a more pleasant nested where http://hpaste.org/81208
22:10:03 <simpson> Is there a library on the Random typeclass for adding small variation (jitter or such) to Random data? I want to take a bunch of things and give them some slight pseudo-random changes and was hoping that somebody had done the typing already.
22:11:14 * applicative thought simpson's "typing" meant 'figuring out the types'
22:11:54 <simpson> Oh, I meant that somebody had already written up the code.
22:11:56 <monochrom> "I have to type up my essay." "easy, :: Essay"
22:12:04 <YayMe`> applicative: as did I, was thinking it something way over my head. makes more sense the other way
22:13:29 <monochrom> w00t Haskell Weekly News!
22:13:40 <tieTYT2> applicative: i've read 2 books and neither of them formatted where's that way.  Is that abnormal?
22:13:56 <shachaf> monochrom: Lens Weekly Quotes
22:14:01 <monochrom> hehe
22:14:08 <tieTYT2> (not whole books, mind you)
22:14:14 <shachaf> Does anyone read any of HWN other than the quotes, anyway?
22:14:43 <monochrom> I click on some of the links. but not many.
22:14:57 <johnw> shachaf: i scan the articles to see if I missed any
22:15:05 <YayMe`> monochrom: just tell the teacher to make your Essay type an instance of show if they want to read it, easy :)
22:15:05 <carter> sclv alp and I were trying to convince harrop to try out haskell again some time
22:15:13 <carter> earlier last week
22:15:14 <applicative> tieTYT2: it's  a little abnormal
22:15:16 <monochrom> haha
22:15:19 <sclv> oh dear
22:15:24 <sclv> don't poke the troll
22:15:35 <carter> hes a nice smart guy when eh's not in troll mode
22:15:37 <applicative> harrop, ah I miss him
22:15:47 <tieTYT2> i'm gonna go bc my eyes are killing me.  Thanks for the help
22:15:49 <sclv> right but why invite the potential for a big mess
22:15:56 <carter> he actually is very supportive of that stuff i'm trying to do :)
22:15:59 <applicative> carter: that was my experience
22:16:07 <carter> applicative yes
22:16:26 <carter> idk what is missing from his brain that makes him hit troll mode
22:16:37 <carter> and i was quite blunt with him about how thats not ok behavior
22:16:41 <shachaf> Perhaps I am missing the same thing.
22:16:46 <applicative> I think it's the internet.
22:16:51 <carter> well
22:17:06 <monochrom> "3.0 is an edwardk phase. like Picasso's Blue Period" hahaha
22:17:11 <carter> i did curse him out over twitter the moment he went full troll mode
22:17:18 <carter> then he calmed down
22:17:29 <sclv> i can't keep up on SO, so HWN is very handy for finding good questions/discussions there too
22:17:38 <monochrom> perhaps by 4.0 we will finally see naked bottoms in lens!
22:17:43 <applicative> he wrote some of the more impressive ocaml entries on the shootout / 'benchmarks game'
22:17:47 <carter> hwn is a labor of love and great community service
22:17:48 <YayMe`> sclv: HWN ?
22:17:49 <carter> oh?
22:17:53 <carter> cool
22:18:07 <sclv> haskell weekly news
22:18:14 <carter> yeah, he knows a lot, he's just got a special form of cognitive issue called "trollitis"
22:18:16 <YayMe`> where's this?
22:18:24 <sclv> http://www.haskell.org/haskellwiki/HWN
22:18:28 <YayMe`> carter: this is 2013, it's really not that special anymore
22:18:41 <carter> YayMe` i have no idea what youre talking about
22:18:44 <carter> anyways
22:19:00 <carter> its a shame though, because when hes not in troll mode, super smart helpful guy
22:19:06 <carter> almost a mini kmett
22:19:18 <carter> dare i say
22:19:29 <YayMe`> carter: trolls may have made up a smaller portion of the general population ca. '92 is all I'm saying
22:19:35 <carter> YayMe` I don't care
22:19:39 <carter> :)
22:19:51 <carter> i'm talking about 1 specific person YayMe`
22:20:00 <carter> Jon Harrop
22:20:09 <carter> who has a funny trackrecord
22:20:20 <carter> of occasionally trolling various FP communities
22:20:24 <applicative> hm, I don't see any of Harrops among the leaders now, the ocaml people have taken to the shootout lately
22:20:25 <monochrom> hey shachaf, maybe next time, we will hear you say: "some people, when asking !list in #haskell, get a link to okmij.org" :)
22:20:27 <carter> but otherwise is a super smart, helpful dudes
22:20:27 <YayMe`> I was just making a general joke; all I know of him is he lent help to an F# Q i had
22:20:33 <carter> ah
22:20:34 <carter> yeah
22:20:39 <shachaf> !list
22:20:39 <monochrom> shachaf: http://hpaste.org
22:20:44 <YayMe`> I wasn't speaking ill of him or anything. just a joke. dude's way smarter than I for sure
22:20:57 <carter> YayMe`: sorry, been a bit tired today
22:21:03 <carter> my tone reading skills ran out hours ago
22:21:04 <carter> :)
22:21:25 <carter> like, a business proposal i'm writing has READ THIS PART
22:21:35 <YayMe`> carter: apparently, I've been screaming at you this entire time and you didn't even notice!
22:21:36 <carter> at one elemnet of th list
22:21:43 <carter> YayMe`? really?
22:21:44 <carter> oh
22:21:53 <carter> well
22:22:11 <carter> i was ignoring the humor 'cause i was too tired to parse it
22:22:27 <carter> ii can only thnk of things like quantifying how awesome people are or could be
22:22:45 <carter> and also if i could implement a make file interpreter using shake and shelly
22:22:46 <YayMe`> haha, go to sleep. I am. Later all and thanks for the mind-bending and humbling help
22:23:01 <callen> ion: why shouldn't I do that?
22:23:29 <carter> i spent last weekend trying to get travisCi and ciricleCI to do the ghc build from source + test scrips, so i've had build tools on my brain
22:23:42 <carter> YayMe` i'm cognitively tired
22:23:47 <carter> but not yet physically tired
22:23:48 <carter> ish
22:24:16 <carter> but yeah praps i should crash
22:24:58 <carter> actually: if i got a nice CI tool sorted out for easily doing hosted / VM test builds of ghc, would anyone here use it?
22:25:30 <carter> i kinda want it so i can to ghc hacking but not melt my laptop when i want to test build
22:36:50 <lispy> Someone should make a graphviz visualization of how the packages on hackage are related
22:36:55 <lispy> Or does that exist?
22:38:20 <carter> lispy there is some basic version of that in the rev-deps info for hackage2
22:38:26 <carter> (on the beta server therein)
22:38:37 <carter> and the cab cli tool can kinda tell you that
22:38:49 <carter> but i don't think theres any systematic exploration thereof
22:39:04 <carter> of the sort you're thinking of lisp
22:39:06 <carter> lispy
22:39:10 <carter> but its a good idea i spose
22:40:39 <lispy> Yeah, I wanted to see, visually, the connected components
22:41:23 <carter> lispy yeah, that'd be neat, and i think no ones done that
22:41:43 <applicative> dons used to have a big chart of dependencies on hackage
22:42:20 <applicative> lispy http://donsbot.wordpress.com/2009/03/16/visualising-the-haskell-universe/
22:42:41 <lispy> applicative: thanks
22:43:57 <carter> looks like some of the figures have bitrootte
22:44:33 <lispy> yeah
22:44:42 <lispy> Also, dons focuses on the module relationships
22:44:47 <applicative> yes
22:44:54 <lispy> I would step back and focus on the package relationships
22:49:54 <mm_freak_> i really liked paul graham's Beating the Averages article, but the more other stuff i read from him, the more i get the impression that he himself suffers from the blub paradox
22:50:41 <tac> mm_freak_: Paul Graham is kinda like those kids who made it big in Hollywood when they were 5
22:50:46 <tac> and then it ruins their lives
22:51:02 <mm_freak_> yeah
22:51:17 <tac> PG things because he managed to get his Lisp startup acquired by Yahoo, he's God's gift to tech startups.
22:51:32 <tac> mm_freak_: You know about Arc, right?
22:51:37 <mm_freak_> yes, i do
22:51:58 <mm_freak_> although i don't know where the project went
22:52:14 <tac> It's really a fantastic illustration of how shallow his knowledge of languages is.
22:52:51 <tac> It died. It was nothing but Scheme with a handful of syntax niceties and a shitty 1990s-style web framework built in
22:52:52 <carter> tac YES. its "lets implment a language on top of dr scheme / racket, but that has fewer features and is slower"
22:53:15 <mm_freak_> carter: fewer features might be fine, though
22:53:22 <mm_freak_> haskell doesn't have a lot of language features
22:53:28 <carter> mm_freak_ who said it was the good features? :)
22:53:31 <simpson> Well, wasn't the entire point of Arc to optimize a specific kind of data flow in Web apps?
22:53:36 <quux> Wow, grean plan, not.
22:53:41 <carter> simpson hehe
22:53:42 <pharaun> and end up dog slow?
22:53:46 <carter> yup
22:53:49 <quux> great ^
22:54:00 <tac> I'll credit Graham. He's a good writer and he has good aesthetics.
22:54:06 <carter> but
22:54:09 <carter> yes
22:54:12 <carter> hehe
22:54:15 <mm_freak_> well, honestly i've never looked at arc…  knowing what PG is like, it as going to be a lisp with extensive macro support and no static typing, so i didn't even bother
22:54:20 <simpson> http://paulgraham.com/arcchallenge.html
22:56:47 <mm_freak_> PG is not stupid or useless…  after all he coined the term "blub paradox" as a cultural mass-illusion…  it's just unfortunate that he suffers from it himself
22:56:51 <carter> mm_freak_ is not a good macro system
22:57:01 <carter> like, at all
22:57:02 <mm_freak_> carter: yeah, i'm not a good macro system =P
22:57:08 <carter> that too
22:57:11 <carter> heheheehe
22:57:28 <carter> i make odd typoes when i'm tired
22:57:40 <mm_freak_> i don't like macros, no matter in what language…  i haven't even written TH generators or quasiquoters in production, just experimented with them a bit
22:57:58 <mm_freak_> although i could probably use quasiquoters, i definitely wouldn't use TH
22:58:08 <mm_freak_> "use" as in "implement"
22:58:08 <shachaf> i love quasiquoters
22:58:10 <shachaf> they are so easy
22:58:16 <tac> I think it's awesome that he promoted the idea that technically minded people had the power to start their own businesses.
22:58:31 <tac> And the he advocated using technology based on merit, not popularity
22:58:37 <carter> mm_freak_ i've some things i'm experimenting with soon where i'll be using data kinds to generate really neat bits of specialized code at rune time
22:58:39 <carter> *run
22:58:42 <mm_freak_> tac: that's true
22:58:52 <carter> but were it not for fancy types, i'd have to use fancy macros :(
22:58:56 <mm_freak_> i do give him credit
22:59:07 <tac> Lisp was slow back then, but it was an honest-to-god better language than most of what was available
22:59:24 <startling> HN is so terrible
22:59:27 <startling> (the software)
22:59:28 <carter> sbcl / cmucl were around
22:59:38 <tac> Lisp is magical compared to C and Perl if you were doing early 1990s web dev
22:59:52 <pharaun> any particulars on why lisp is slow/was slow
22:59:59 <carter> startling yeah: he doesn't even handle the link state well
23:00:04 <pharaun> tac: and there's the lisp on jvm now days i suppose (clojure)
23:00:07 <carter> so certain links expire too soon
23:00:20 <startling> carter: definitely
23:00:24 <tac> pharaun: less optimization because Lisp was an academic language, not an industry language... that's probably the #1 reason
23:00:26 <ninegrid> is Blub anything like BlooP and FlooP?
23:00:30 <startling> also he apparently has a cron job restart it every couple of days
23:00:32 <mm_freak_> carter: you have fancy types, and the language itself is your macro system…  that's what non-strict semantics gives you
23:00:41 <tac> pharaun: also, functional languages support closures and first-class functions, and both incur performance penalties.
23:00:42 <carter> mm_freak_ yup!
23:00:44 <startling> which is a pretty bad codesmell.
23:00:47 <mrlaw> someone got some dumps out there ?
23:00:52 <pharaun> tac: ah fair enough
23:01:09 <carter> mm_freak_ though i may try to shift to prototyping stuff in idris to move things faster
23:01:22 <carter> startling yeah; its a clusterfuck of poo
23:01:24 <tac> ninegrid: Floop and Bloop are amazing :) They taught a generation the difference between general recursion and primitive recursion
23:01:39 <simpson> tac: Well, neither of those *have* to make things slow, but Lisp's model of computation is certainly not friendly towards either.
23:01:40 <mm_freak_> carter: does that really help?
23:02:00 <tac> simpson: I never said it was inherent
23:02:08 <simpson> tac: Fair enough. :3
23:02:09 <ninegrid> tac: yea, I like all his (Hofstadter's) stuff tbh
23:02:17 <startling> why isn't there hardware with first-class lambdas yet? :(
23:02:19 <carter> mm_freak_ well, right now its figuring out how to say what i want, and then trying to make sure its expressible in haskell
23:02:44 <simpson> :i Random
23:02:49 <tac> I highly recommend Hofstadter to my friends, but I've never finished the damn thing (GEB)
23:03:23 <tac> startling: Show me the ALU for such a computer and I'll help you set up a kickstarter for it :)
23:03:27 <simpson> Oh, she doesn't know. Does anybody know if there's an instance of Random for tuples? instance Random a => Random (a, a) where... ?
23:03:39 <mm_freak_> carter: i'd do it in haskell directly
23:03:50 <mm_freak_> but that's just me =)
23:04:35 <startling> tac: I've been thinking of learning verilog or whatever and giving it a shot
23:04:38 <carter> mm_freak_ well, its also in this case its also wanting ot make sure theres no bugs, and having an idea of how to make the api richer once haskell gets more powaaahhh
23:05:09 <carter> startling: there are allegedly people doing crazy hardware research that touches on that
23:05:13 <carter> lemme dig up the link
23:05:21 <startling> carter: interesting
23:05:49 <tac> startling: I honestly don't know enough about hardware design to even begin thinking about how you would write a lambda computer
23:05:57 <tac> it sounds like it would be a lot of fun though :)
23:06:07 <mm_freak_> carter: the problem is, if you don't actually write the code, it's difficult say whether your types work, are flexible enough, etc.
23:06:08 <carter> startling http://www.cs.columbia.edu/~martha/ somethings she's doing?
23:06:09 <ninegrid> tac: I read "Metamagical Themas" first, which I found to be better than GEB
23:06:21 <carter> mm_freak_ no, they work, i just want to prove they do :)
23:06:31 <mm_freak_> ok =)
23:06:40 <startling> tac, I was thinking something like a special kind of pointer that refers to a local value
23:06:52 <carter> and writing down all the properties and formalizing that
23:06:53 <startling> you'd need built-in semantics for pass-by-value and pass-by-refence though
23:06:55 <mm_freak_> isn't it depressing to move dependently typed code to a language without dependent types? =)
23:07:04 <startling> mm_freak_: ikr
23:07:08 <carter> mm_freak_ nope :)
23:07:14 <carter> its called compilation
23:07:18 <startling> ha
23:07:46 <tac> ninegrid: personally, I have found my own philosophy of computation. I don't need to read any more books on the subject :)
23:08:11 <tac> startling: nawww. You do need one of two things though
23:08:28 <tac> 1) hardware that reduces your expressions via full beta reduction (and always work purely :)
23:08:40 <mm_freak_> carter: you don't write your programs in idris and compile them to haskell, do you?  as idris doesn't compile to haskell (it isn't even nonstrict by default), you probably "compile" by hand ;)
23:08:41 <tac> or 2) hardware that works on linear logic that controls evaluation order entirely
23:09:00 <carter>  mm_freak_  indeed
23:09:02 <startling> tac: hm, good point
23:09:17 <startling> built-in immutability would be an interesting thing, too.
23:09:23 <carter> mm_freak_ the goal here is just ot reduce the paper math -> code math friction
23:09:38 <carter> figuring out what partial info i can encode
23:09:40 <carter> is more friction
23:09:42 <carter> in wha ti' doing
23:09:45 <carter> what i'm doing
23:09:50 <mm_freak_> oh, i don't have any friction there…  emacs is my paper =)
23:09:53 <mm_freak_> i always start with code
23:10:13 <carter> mm_freak_  my brain doesn't work that way
23:10:52 <mm_freak_> it's great that (unlike what paul graham says) haskell supports both approaches =)
23:11:28 <tac> It's pretty clear that PG would never support static languages
23:11:37 <tac> Static languages prevent bugs. They produce quality software.
23:11:49 <tac> If you're running a startup, you just need software good enough until you sell the company
23:12:01 <mm_freak_> hehe
23:12:17 <carter> tac in my case, without a good type system i couldn't even design the product i'm working on
23:12:37 <tac> what are you writing, carter ?
23:12:52 <startling> tac, on the other hand, if you use haskell, you have pretty good job security
23:13:03 <tac> well.... sorta
23:13:17 <tac> You know how many people would jump at the chance to do a decently paid Haskell job here? :P
23:13:22 <pharaun> its acquiring the job
23:13:29 <pharaun> that is the troublesome part
23:13:39 <startling> tac, about one hundredth as many people would jump on a decently paid python job?
23:13:41 <carter> tac really really nice tools for writing numerical computation / data analysis / machine leanring algs in haskell in a highlevel way with good performance
23:13:59 * tac is trying to turn his current job into a Python job...
23:14:04 <mm_freak_> i'd be happy to work for a haskell company, but unfortunately it seems like there are none in germany
23:14:16 <tac> carter: sounds neat. Do you know much about Machine Learning?
23:14:27 <mm_freak_> in fact i'm the guy who introduces haskell =)
23:14:34 <carter> tac in which sense?
23:14:41 <tac> in any sense
23:14:43 <carter> i'm still picking up lots of bits i don't know
23:14:53 <tac> I am really interested in learning some basic machine learning concepts
23:15:02 <carter> oh
23:15:02 <carter> ok
23:15:09 <tac> I realize I know absolutely nothing about any AI fields D:
23:15:09 <carter> well,
23:15:13 <carter> ok
23:15:23 <pharaun> mm_freak_: startup! :)
23:15:24 <carter> thats diffferent than how i interpreted the question
23:15:27 <mm_freak_> carter: for high performance neural networking, see how my 'instinct' library works
23:15:35 <mm_freak_> if you're interested
23:15:47 <carter> mm_freak_ i'll have alook see, have you seen alps hnn?
23:16:01 <mm_freak_> the hnn library?
23:17:00 <mm_freak_> ah, "alp's hnn"
23:17:02 <mm_freak_> yes, i have =)
23:17:05 * tac was looking at hnn earlier
23:17:23 <mm_freak_> instinct outperforms all neural network libraries on hackage
23:17:29 <mm_freak_> and not just a little
23:17:48 <mm_freak_> at least all of them in the "AI" category
23:17:53 <tac> instinct?
23:18:02 <ninegrid> why is it there are so many ruby entraprenuers and so few haskell ones?  lots of people created their own ruby jobs, but in haskell it is so rare
23:18:09 <tac> oh, I missed that one
23:18:21 <mm_freak_> tac: yeah, it's probably the name
23:18:36 <tac> I was looking through the AI package for neural net libs earlier today
23:18:38 <capisce> ninegrid: maybe because rubyists are more into web, where it's easier to get contracts?
23:18:39 <tac> and I didn't see instinct
23:18:43 <startling> ninegrid: haskellers with jobs are like dragons with gold
23:19:19 <carter> ninegrid i'm a startuper
23:19:23 <ninegrid> capisce: but haskell should outperform ruby at web
23:19:26 <tac> Wait until Cloud Haskell matures
23:19:30 <mm_freak_> tac: it doesn't have a lot of features (yet, a new version is on its way), but it's faaaast
23:19:33 <tac> Datamining in the cloud until kingdom come
23:20:07 <mm_freak_> if you're looking for high performance libraries and you see my name, you're at the right place =)
23:20:08 <tac> mm_freak_: the thing I'd like to know about NNs is... how do you determine what kind of dimensions suit your problem?
23:20:14 <tac> How many internal nodes do you need?
23:20:14 <ninegrid> tac: i've been watching that one... but F# has beat haskell to it with type providers and mbrace or cloudsharper
23:20:17 <tac> How many layers?
23:20:19 <capisce> ninegrid: sure, but ruby on rails became quite popular for doing web applications
23:20:32 <mm_freak_> tac: experimentation and some intuition
23:20:47 <mm_freak_> tac: think of groups of neurons representing "features"
23:20:49 <tac> ninegrid: being first to something doesn't make you the automatic winner. Although F# is a good language from what I've seen
23:20:53 <tac> type providers are pretty slick
23:21:06 <carter> ninegrid the mbrace stuff is wimpy :)
23:21:08 <mm_freak_> think how many features will be significant and how much information they hold
23:21:14 <mm_freak_> then design your inner layer
23:21:29 <mm_freak_> if you need more fancy grouping with subgrouping of features, you will need more than one hidden layer
23:21:31 <carter> mm_freak_ neural networks are good for feature generation basically :)
23:21:31 <tac> mm_freak_: So like.... if I wanted a filter on, say.... porn, how big of a network are we talking?
23:21:34 <ninegrid> tac: i wasn't implying that... i was just making the observation that it is strange, you see the F# community is quite a bit smaller than the haskell one
23:21:40 <tac> 10 nodes? 1000? 1m?
23:21:47 <carter> tac you'd still have a predictor on top
23:21:48 <mm_freak_> of course i'm assuming a multi-layer perceptron here…  there are other models, too
23:21:58 <carter> its just your'e getting "refined" signals
23:22:04 <tac> carter: a predictor just means a pre-approved solution set?
23:22:06 <mm_freak_> instinct supports all feed-forward models
23:22:14 <carter> tac i'm speaking loosely
23:22:28 <mm_freak_> tac: detecting porn is complicated
23:22:30 <carter> tac whats your current math level? i'll dig up some books for that level
23:22:59 <mm_freak_> tac: the problem is that you don't really /teach/ the features…  the network /makes/ the features
23:23:08 <tac> carter: I'm pretty versed. My calculus is pretty shitty, but I am pretty decent at topology, some algebra background, good linear algebra and analysis
23:23:18 <mm_freak_> and you can't really predict what those features will be, neither can you really inspect them later
23:23:33 <carter> tac the new hotness in machine learning tomes is the kevin murphy book
23:23:51 <carter> it has a very probabilistic modelling view
23:23:57 <carter> that i'm still learning / loading into my head
23:24:02 <carter> (reading it myself)
23:24:02 <tac> is "machine learning" just a political correct name for what used to be "artificial intelligence"?
23:24:08 <carter> tac not quite
23:24:12 <mm_freak_> tac: you don't need calculus to use neural networks…  in fact, you can implement and use neural networks without knowing anything about math =)
23:24:29 <mm_freak_> tac: to /understand/ backpropagation learning you will need some calculus, but really basic one
23:25:17 <tac> I know basic calculus
23:25:20 <tac> I just hate it :)
23:25:34 <mm_freak_> tac: machine learning describes all kinds of learning processes, even if no real "intelligence" ever comes out
23:25:39 <tac> ah
23:25:41 <tac> I see
23:25:44 <mm_freak_> for example markov models are machine learning, but not artifical intelligence
23:26:13 <carter> yeah
23:26:41 <carter> many ML algs are basically "find value for the model that minizes this scoring fucntion"
23:26:42 <tac> markov models are just FSMs that change randomly by weighted connections, right?
23:27:01 <tac> or.. those are markov chains I think
23:27:14 <mm_freak_> tac: no, markov models basically describe dependent probabilities
23:27:21 <mm_freak_> a very simple markov model is the markov chain
23:27:33 <ninegrid> enter PGM
23:27:42 <carter> 'night all
23:27:49 <mm_freak_> like "if this text starts with "blah", what is the probability distribution for the following character?"
23:27:55 <mm_freak_> good night carter
23:28:05 <carter> thankee
23:28:27 <tac> night
23:28:56 <mm_freak_> tac: you can write a funny text generator based on markov chains =)
23:29:02 <tac> hehe
23:29:11 <tac> I was actually looking for a Haskell package to do that earlier
23:29:18 <mm_freak_> markov-chain
23:29:20 <tac> but I think I could probably figure out how to write one
23:29:26 <mm_freak_> yes, you can
23:29:30 <tac> based on what you just said
23:29:36 <tac> I just need a thousand books
23:30:01 <ninegrid> tac: just take andrew ng's coursera class
23:30:12 <mm_freak_> no, you just need your brain…  when i implemented my first markov chain, i had never heard the word "markov" before =)
23:30:59 <tac> sure, but hearing "probability dist. of the next word" makes it much easier on my brain
23:31:04 <shachaf> If you have to look Markov chains up before implementing them, you get a mark of shame.
23:31:05 <tac> less thinking, more doing what is now obvious
23:31:33 <tac> shachaf: They are just digraphs where each node has weighted edges summing to 1, right?
23:31:53 * shachaf knows very little about markov chains.
23:31:56 <shachaf> All I know is puns.
23:31:58 * tac wonders if he can do a quantum markov chain implementation without looking at the definition.
23:32:17 <mm_freak_> tac: a simple and inefficient type you can start with:  data MarkovChain a = Map (Seq a) (Map a Double)
23:32:20 <mm_freak_> does that help? ;)
23:32:36 <tac> mm_freak_: not really. It's easier to think about it the other way I had in my head
23:33:39 <tac> @src Seq
23:33:39 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:33:42 <tac> @kind Seq
23:33:43 <lambdabot>     Not in scope: type constructor or class `Seq'
23:33:43 <lambdabot>     Perhaps you meant one of these:
23:33:43 <lambdabot>       `Seq.Seq' (imported from Data.Sequence),
23:33:51 <tac> @kind Seq.Seq
23:33:52 <lambdabot> * -> *
23:33:56 <tac> >_>
23:34:12 <mm_freak_> my last one looked like this:  data Chain a = Map (Seq a) (Int, IntervalMap Int a)
23:34:26 <mm_freak_> that was a very fast implementation, but can be done even better
23:34:32 <mm_freak_> especially if you specialize your 'a'
23:34:46 <mm_freak_> data Chain = Map Text (Int, IntervalMap Int Char)
23:34:52 <mm_freak_> data?
23:34:55 <mm_freak_> come on, ertes
23:34:56 <mm_freak_> type!
23:35:00 <mm_freak_> type Chain = Map Text (Int, IntervalMap Int Char)
23:35:12 <mm_freak_> it's early =)
23:35:40 <tac> I don't know if I would want to do any kind of data processing in Haskell >__>
23:35:42 <tac> heh
23:35:52 <mm_freak_> i wouldn't want any other language
23:35:56 <pharaun> tac: why not
23:35:58 <mm_freak_> data processing is so damn easy in haskell
23:36:23 <Nisstyre> @pl (\n -> foldr1 (*) [1..n])
23:36:23 <lambdabot> foldr1 (*) . enumFromTo 1
23:37:31 <sw2wolf> Is "data Trade = Buy qty price | Sell qty price" right definitiom in haskell ? i feel it is a bit long as the data constructor has same parameters ?
23:38:16 <tac> pharaun: I don't know enough about adding strictness to haskell, and I don't care enough to learn it :P
23:38:18 * hackagebot thyme 0.1.2.0 - A faster time library  http://hackage.haskell.org/package/thyme-0.1.2.0 (LiyangHu)
23:38:26 <tac> Laziness is a pain in my ass
23:38:30 <pharaun> heh
23:39:58 <tac> or should I say...
23:40:05 <tac> Laziness is [thunk]
23:40:16 <tac> go ahead
23:40:19 <tac> ask me what laziness is
23:40:21 <tac> :P
23:42:56 <Kanisterschleife> hi. How can I get a current version of ghc on a debian squeeze system without breaking dependencies?
23:43:28 <mm_freak_> sw2wolf: it's not right, because "qty" is not in scope
23:43:42 <mm_freak_> unless it's an associated type
23:44:40 <sw2wolf> is should be "data Trade = Buy Int Float | Sell Int Float" ?
23:44:49 <mm_freak_> something like that, yeah
23:45:03 <startling> are we talking about Bazaar again?
23:45:16 <mm_freak_> startling: not the Bazaar you're thinking of ;)
23:45:35 <sw2wolf> mm_freak_: can it be shorter ?
23:45:49 <mm_freak_> sw2wolf: yes
23:45:56 <sw2wolf> how ?
23:46:01 <mm_freak_> data T=B Int Float|S Int Float
23:46:24 <sw2wolf> :)
23:46:27 <mm_freak_> seriously, what could be shorter than that? ;)
23:46:47 <mm_freak_> haskell has about the most concise syntax possible for types
23:47:01 <sw2wolf> i mean both the B and S has same type variables...
23:47:15 <mm_freak_> Buy and Sell aren't variables…  they are constructors
23:47:27 <mm_freak_> a valid value of type Trade is:  Sell 3 5.5
23:47:34 <Kanisterschleife> any help?
23:47:35 <sw2wolf> yes
23:47:46 <mm_freak_> Kanisterschleife: yes, you can
23:47:57 <mm_freak_> you can install the haskell platform manually
23:49:01 <Kanisterschleife> mm_freak_: so far I installed haskell-platform and cabal through debian stable repository. What should I do now?
23:49:21 <mm_freak_> Kanisterschleife: undo that and try to install the haskell platform manually from…
23:49:24 <mm_freak_> @where hp
23:49:24 <lambdabot> http://hackage.haskell.org/platform/
23:49:47 <mm_freak_> i don't know what your options on debian are, but in the worst case you can always build it yourself
23:50:13 <mm_freak_> you can also just install GHC directly and then install the rest through cabal-install
23:50:16 <mm_freak_> that's what i do
23:50:52 <mm_freak_> i.e. install a GHC binary from the homepage, install a cabal-install binary, install the rest
23:51:20 <mm_freak_> @where ghc
23:51:20 <lambdabot> http://haskell.org/ghc
23:51:37 <Kanisterschleife> mm_freak_: one moment, I wll try getting hp from the link you sent
23:52:08 <mm_freak_> Kanisterschleife: the haskell platform is really just GHC, cabal-install and a few other tools and a few libraries
23:52:19 <mm_freak_> it's fine if you choose to install GHC and cabal-install alone
23:52:34 <wuttf> Any good tutorial on multiparam typeclasses?
23:52:38 <Kanisterschleife> mm_freak_: mh, but the page above refers to the debian stable repo for installation?
23:53:19 <Kanisterschleife> mm_freak_: or should I compile from source?
23:56:28 <Moggle> For anyone bothering with wxHaskell on windows, if your application is failing to start, it's probably a DLL conflict
23:56:40 <Moggle> not that the debugging bit from haskell would be so kind as to _say_ that
23:56:49 <Moggle> nah, it'd prefer you waste an hour of your life tracking down causes
