00:00:00 <oio> so a function can never do this [1] Prelude> clist 2 [1,2] Prelude> clist (-1) [-1,1,2]
00:00:04 <mm_freak> while the checkpoints are binary, the transaction logs are text
00:00:22 <hpaste> OiO pasted “nlist” at http://hpaste.org/80964
00:00:30 <M30W> Nice
00:00:40 <mm_freak> oio: an IO action can do that, but it's a very bad idea
00:01:05 <mm_freak> oio: and it's also unnecessary
00:01:53 <mm_freak> M30W: the idea is this:  you can make changes to the database quickly…  acid-state only logs the transaction and nothing more
00:02:22 <mm_freak> M30W: when you reload the database, acid-state loads the last binary checkpoint and replays all transactions performed since then
00:02:40 <M30W> mm_freak: Wait.. So there is no binary database file to do lookups through to get through the data ?
00:02:52 <M30W> Replays O.o
00:02:53 <mm_freak> there is, but it may be outdated
00:03:16 <mm_freak> the raw binary databases are called checkpoints
00:03:46 <M30W> Okay; sounds good. :)
00:03:54 <mm_freak> say your database is a list which is initially empty…  the corresponding binary file saves the empty list
00:04:04 <M30W> So after the checkpoint; is there a set iteration to auto-save ?
00:04:08 <M30W> Or all manual.
00:04:17 <mm_freak> now you add an element to that list…  acid-state stores an additional file that documents the change
00:04:23 <mm_freak> this is valid, since transactions have to be pure
00:04:41 <mm_freak> you can do as many such updates as you want, and for each of them a transaction log is saved
00:04:51 <oio> mm so its bad a idea to have io inside a function beacuase result changes with same argument
00:05:14 <M30W> mm_freak: Transaction logs are in what form? more or less print datastruct ?
00:05:18 <mm_freak> then at some point you can create a new checkpoint…  future loads of the library will load the latest checkpoint and replay all transactions done since then
00:05:24 <mm_freak> M30W: yeah
00:06:09 <mm_freak> you have a type with a constructor for every possible transaction…  it looks like this:  data ListOp = ListAdd Int | ListPop | ListClear
00:06:16 <mm_freak> oio: yes
00:06:34 <mm_freak> oio: it's not just good coding style to have pure functions in haskell…  it's actually required
00:06:40 <startling> oio: not necessarily – there are some things you can't do without IO
00:06:47 <startling> but avoid using it where possible, yes.
00:08:00 <mm_freak> M30W: the point is:  the checkpoint may not be up to date…  it's a valid and consistent state of the database, but it may have changed since then
00:08:30 <mm_freak> M30W: you can actually restore all prior states of the database provided you kept all checkpoints and all transaction logs =)
00:08:33 <M30W> mm_freak: And the transactions replay against the newest checkpoint to get back to date.
00:09:08 <oio> p.p
00:09:19 <mm_freak> M30W: say you have:  check1, trans11, trans12, trans13, check2, trans21, trans22
00:09:22 <mm_freak> in that order
00:09:38 <mm_freak> you can load either from check1, in which case you need to replay all transactions
00:09:47 <mm_freak> or you can load from check2, in which case you have to replay trans21, trans22
00:10:16 <mm_freak> M30W: btw, this machinery is normally hidden from you, but it's good to know when using acid-state =)
00:10:23 <lispy> pdxleif: for the majority of students it helps differentiate them. The majority of students stop at a 4 year degree. So without experience or specific references it can be hard to find something.
00:10:59 <lispy> pdxleif: hiring managers at good jobs get a sea of resumes all alike.
00:11:07 <M30W> mm_freak: Transactions could build up quickly (file size) the checkpoints would faster. Can multiple transactions be in a single file? Can transactions be created between two checkpoints?
00:11:17 <M30W> Seems more ideal for backups. :)
00:11:49 <mm_freak> M30W: no idea about the former…  you can create as many checkpoints as you want whenever you want
00:12:13 <mm_freak> a checkpoint really just captures the current state of the database…  it basically makes all prior checkpoints and logs unnecessary
00:12:45 <mm_freak> once you have created a checkpoint you can delete all past checkpoints and logs
00:12:49 <M30W> Yea. My point was; say there are two checkpoints and no transaction logs between, could each be loaded into seperate structures and be differed into a transaction/log for say an email?
00:13:23 <lispy> edwardk: my experiments show me that one of two things happen. a) ghc uses an encoding that doesn't support the codepoint you want to use and throws an exception, b) ghc outputs it successful and then it's up to your viewing program (console perhaps) to correctly render it (or fail in the process)
00:13:51 <lispy> edwardk: you should be in the later case with your codepage hack modulo SimonM's point about newline mangling.
00:13:57 <lispy> latter*
00:14:05 <M30W> Yes makes them unnecessary but if you keep the checkpoints (maybe delete constantly to have 3day, 1week, 2week, 1month, 6month backups)
00:14:15 <mm_freak> if you create two checkpoints with no logs inbetween, they are the same checkpoint ;)
00:14:25 <M30W> And could create transactions bettween them. Then it would be nice to build statistics on what has happened.
00:14:26 <mm_freak> @ M30W
00:14:49 <edwardk> mostly i just need to be able to show a bunch of greek letters. ;)
00:14:50 <M30W> mm_freak: Two checkpoints with the logs between removed * ;)
00:14:59 <edwardk> we use to just run in the greek codepage
00:15:13 <mm_freak> M30W: if you remove the logs inbetween, you can't go from the first checkpoint to the second
00:15:13 <edwardk> which is my fallback position
00:15:38 <mm_freak> M30W: the checkpoints themselves are both valid
00:15:54 <lispy> edwardk: yeah, and if you're not doing newlines newline mangling won't affect you :)
00:15:57 <mm_freak> it's just that you don't know how to get from checkpoint 1 to checkpoint 2
00:16:00 <M30W> mm_freak: I mean.. load cp1 to cp1, cp2 to cp2. Then compare the two structures to get a diff.
00:16:23 <mm_freak> M30W: yes, you can do that…  technically
00:16:42 <mm_freak> M30W: but acid-state doesn't expose such a flexible API
00:16:42 <M30W> mm_freak: You misunderstood me. Not interchanging between them without logs but comparing only. (Probally a different program)
00:17:21 <M30W> Also acid-state stores the entire database in ram, so potentially not ideal for many cases..
00:17:42 <mm_freak> M30W: that's a misconception…  in practice you want the database to live in RAM anyway
00:18:07 <M30W> In practice it could be useful but not if you don't have enough ram to do so.
00:18:32 <mm_freak> people do complicated and weird things to help postgresql/mysql keep the whole database in memory…  but when acid-state comes along and solves the problem simply by not going to disk, then people complain ;)
00:19:00 <mm_freak> M30W: you always have enough RAM…  if you don't have enough RAM the practical solution is to buy more RAM
00:19:01 <M30W> Hehe
00:19:23 <oio> any idea this error     Type of kind * used as a constraint
00:19:26 <mm_freak> you really don't want to resort to disk access, particularly if the database is that large
00:19:28 <M30W> Okay; what if the database needs to store more than 64G of ram. Then what? :P
00:19:34 <isomorphic> I want to use seq to force evaluation of a function (whose result I would not otherwise use for the purpose of debugging).   What's the right way to call it?  seq f f ?
00:19:40 <mm_freak> oio: you probably wrote something like "Int =>"
00:19:56 <M30W> I.e my phone; has 32G of storage; and 256M of ram.
00:19:59 <mm_freak> isomorphic: seq f f = f
00:20:16 <lispy> the second f there needs to be an expression that you depend on
00:20:33 <mm_freak> isomorphic: to just force the function you can do something like this in IO:  evaluate f
00:20:44 <mm_freak> isomorphic: that's equivalent to:  f `seq` return ()
00:20:45 * M30W not hinting to wanting to run a large database on his phone but it's relatable to the r3.14.
00:20:55 <lispy> > let foo f = seq f f in [foo undefined, 1] !! 1
00:20:57 <lambdabot>   1
00:21:06 <isomorphic> Hrm.  Ok.
00:21:10 <isomorphic> Thanks!
00:21:26 <mm_freak> M30W: acid-state isn't really for regular user applications…  you probably want TCache or something like that
00:22:01 <mm_freak> @hackage TCache
00:22:01 <lambdabot> http://hackage.haskell.org/package/TCache
00:23:02 <M30W> Interest area for me would be a webserver that could be updated via ssh or just the web-front-end.
00:23:15 <mm_freak> "updated"?
00:23:34 <M30W> ssh server could live inside the same program. Just seperate fork's.
00:23:53 <mm_freak> oh, if you get something like that to work, please tell me =)
00:23:55 <M30W> mm_freak: As in, entries modified, added, etc. One acid-state instance running.
00:24:16 <M30W> Haha, you like the concept aye? :)
00:24:41 <mm_freak> i actually wanted to do something like that, but found no useful SSH server libraries on hackage
00:24:49 <M30W> http://hub.darcs.net/simon/darcsden/browse/src/SSHServer.hs << Already had the idea, but once I saw this I was like... Oh sweet could it be any easier. :D
00:24:54 <mm_freak> but you can use TLS instead
00:25:02 <M30W> Hehehe.... ^^^ LINK
00:25:32 <M30W> Don't know when you looked for ssh on hackage but seems to exist.
00:25:38 <M30W> http://hackage.haskell.org/package/ssh
00:25:41 <mm_freak> M30W: http://hackage.haskell.org/package/tls-1.1.1
00:26:16 <M30W> mm_freak: Alex, who started darcsden made that ssh library by the looks of things. :)
00:26:58 <mm_freak> M30W: that doesn't look like a library i would want to use
00:27:05 <mm_freak> no haddocks, no comments, …
00:27:28 <M30W> mm_freak: Example usage ;)
00:27:38 <mm_freak> this is a cryptographic library
00:27:45 <oio> how can i tell a function otherwise dont do nothing ?
00:27:48 <M30W> Source is readable.
00:27:50 <mm_freak> we all know where bad docs get us:  openssl
00:28:03 <M30W> xD
00:28:14 <mm_freak> oio: sorry, i don't understand that question
00:28:40 <mm_freak> M30W: anyway, lack of documentation is always a bad sign for security-related code
00:28:51 <M30W> Indeed.
00:29:08 <M30W> mm_freak: Challange; documentate it and understand it all. GO!
00:29:15 <M30W> Good luck if you accept challange
00:29:23 <lispy> oio: give it a Maybe type?
00:29:25 <mm_freak> i'll go with TLS for now ;)
00:29:36 <M30W> Heh.
00:29:54 <lispy> > let foo x | x > 0 = Just x | otherwise = Nothing in foo 1
00:29:55 <lambdabot>   Just 1
00:29:59 <lispy> > let foo x | x > 0 = Just x | otherwise = Nothing in foo (-2)
00:30:01 <lambdabot>   Nothing
00:30:08 <lispy> oio: ^^
00:30:12 <M30W> mm_freak: The developer of the code lives in #darcs, maybe you could talk to him about the documentation.
00:31:01 <lispy> most of hackage has terrible docs though
00:31:02 <oio>  qt xs     | xs == "q" = exitSuccess | otherwise =
00:31:19 <lispy> oio: look at when
00:31:21 <lispy> :t when
00:31:21 <M30W> alexsuraci @ mm_freak
00:31:22 <lambdabot> Monad m => Bool -> m () -> m ()
00:32:24 <M30W> safePrime = 179769313486231590770839156793787453197860296048756011706444423684197180216158519368947833795864925541502180565485980503646440548199239100050792877003355816639229553136239076508735759914822574862575007425302077447712589550957937778424442426617334727629299387668709205606050270810842907692932019128194467627007
00:32:29 <M30W> Hehehe
00:33:14 <M30W> MaybeCallMe: May I have the constructors Call and Me please?
00:34:37 * M30W wonders where mm_freak disapeared to.
00:35:42 <oio> lispy: yeah but incomptible types so gotta use maybe
00:38:02 <M30W> mm_freak: Did you get lost in cryptographic source code?
00:42:36 <mm_freak> M30W: huh?
00:42:41 <mm_freak> but yes, indeed =)
00:42:58 <mm_freak> i was checking the code of TLS, and it seems like it has a serious vulnerability
00:43:57 <mm_freak> tls is fine, but tls-extra seems vulnerable
00:47:11 <startling> would you call it extra-vulnerable?
00:47:54 <memand> startling: badum-tsch
00:51:17 <M30W> mm_freak: Heh. -extra vulnerable, same developer?
00:51:40 <mm_freak> nope
00:51:46 <mm_freak> it's a different guy
00:52:29 <M30W> mm_freak: Where you looking? I just loaded it up. Same developer ?
00:54:20 <oio> qt xs          | xs == "q" = exitSuccess     |otherwise = dont do nothing?
00:55:47 <M30W> oio: Well xs is the wrong name (and type should be Char not String) if it's just xs == "q" -- x = 'q' however, where is the error?
00:55:59 <M30W> ExitWith exitSuccess maybe ?
00:56:21 <M30W> Oh
00:56:25 <M30W> otherwise = return ()
00:56:44 <mm_freak> M30W: oh, you're right…  i confused it
00:57:01 <oio> Ok, modules loaded: Main.
00:57:03 <mm_freak> anyway, bug report submitted
00:57:05 <M30W> mm_freak: Confused it with what? the ssh I linked you to?
00:57:07 <M30W> Heh
00:57:13 <M30W> mm_freak: What was the vulnerability ?
00:57:21 <M30W> s/was/is/
00:57:33 <mm_freak> https://github.com/vincenthz/hs-tls/issues/29
00:57:49 <M30W> oio: Did you take my other suggestions to that? :P
00:58:19 <oio> otherwise = return ()
00:58:32 <M30W> mm_freak: You didn't give any line info D:
00:58:37 <oio> is late.. gotta sleep
00:59:12 <M30W> oio: Night.
00:59:27 <mm_freak> M30W: indeed…  i'll leave that to the developer =)
00:59:46 <`nand`> whne (xs == "q") exitSuccess
00:59:51 <`nand`> when
01:00:12 <M30W> oio: head xs >>= qt -- qt :: Char -> IO ()
01:02:05 <M30W> oio: when (xs == "q") exitSuccess -- `nand`
01:02:15 <M30W> `nand`: You didn't ping him and he went to bed. :)
01:03:00 <M30W> mm_freak: Mind giving me the line info?
01:04:39 <mm_freak> M30W: http://hackage.haskell.org/packages/archive/tls-extra/0.6.0/doc/html/src/Network-TLS-Extra-Certificate.html#certificateVerifyAgainst
01:05:44 <mm_freak> M30W: the bug is spread all over that module
01:05:51 * M30W looks at the second time he has seen x@(a b c) and is loving how he understands it after finding the keyword @ this morning. :D
01:06:30 <M30W> mm_freak: Nice catch
01:07:16 <mm_freak> M30W: not proud of that…  it shows once again that TLS is too complicated
01:07:25 <M30W> Moxie, I have heard of this guy.. Where, I can't remember. :|
01:08:04 <M30W> mm_freak: I looked at TLS in haskell; then I looked back to ssh, ssh looks so much easier. xD
01:08:09 <mm_freak> M30W: he's known for RedPhone, TextSecure and sslsniff
01:08:15 <M30W> And covered more for what I was after. :)
01:08:33 <M30W> RedPhone, that about anti-blueboxing or bluebox replacement ?
01:08:45 <mm_freak> that about encrypting phone calls =)
01:08:49 <M30W> Ah
01:08:54 <mm_freak> unfortunately it uses VoIP
01:09:10 <mm_freak> so it's not exactly useful, unless you're in a wifi network
01:09:29 <M30W> Yea. :(
01:09:43 <M30W> Or call a voip service and tunnel with your encryption. :)
01:10:02 <M30W> (process of call; sadly can't encrypt who recieves)
01:10:12 <M30W> -- Tones for the number --
01:10:24 <mm_freak> the problem is that you would quickly run into your data limit
01:10:36 <M30W> Yea.
01:11:41 <M30W> Silly camera man.. Why did you bump the camera >_<
01:11:44 <M30W> :P
01:13:18 <b52> are there new information about the process of fp-completes undertaking to build an online haskell ide similiar to lighttable?
01:13:29 <M30W> XD Microsoft says it's basicly impossible to exploit. So he publishes a tool that exploits it.
01:15:26 <M30W> b52: Haddock
01:16:45 <M30W> There are the types (if defined which they should be) comments/documentation can be read. Following variables through are just substitutions. And due to haskell's infix . $ etc, if you request the full tree for what's going on.... That could take a while especially with teh recursion. :)
01:17:59 <b52> M30W: what you mean?
01:18:08 <M30W> You can also go through and get all the types and you have what you'd like for completion and whatnot.
01:18:18 <M30W> b52: What part are you refering to?
01:18:57 <b52> What do you mean by simply stating "Haddock"
01:19:16 <M30W> mm_freak: Problem -> Assuming you are requesting to use the calls while being mobile.
01:19:51 <M30W> b52: Haddock generates documentation to a structure from the types in the code, and inplace comments around the code.
01:20:39 <b52> Oo
01:20:44 <M30W> lightbox gives you the completion yes? Just get all the types and you have everything that there is to complete to. Get the documentation and you have more information for it.
01:20:47 <b52> and in how far is that related to my question?
01:21:08 <M30W> b52: What do you want to complete ?
01:21:12 <b52> i think you missed my point
01:21:19 <M30W> Re-ask ^_^
01:21:19 <b52> fp complete is a company ...
01:21:37 <M30W> Oh
01:21:50 <b52> quite known in here i assumed
01:22:09 <b52> http://fpcomplete.com/designing-the-haskell-ide/
01:22:46 <M30W> Yay haskell ide. :)
01:23:55 <M30W> b52: What was your question exectly ?
01:24:10 <b52> if anyone has further information about the process
01:24:22 <Lethalman> b52, mh they don't say why they dropped leksah?
01:24:51 <b52> Lethalman: nope
01:29:17 <hamishmack> Lethalman: They never even spoke to me.  Leksah development is going nicely though and there's lots still to do.
01:30:08 <mm_freak> M30W: wat?
01:30:08 <Lethalman> hamishmack, I'm very interested in leksah, but the initial dialog a little scared me :P what it does is downloading the sources? why does it use a different location than cabal?
01:31:04 <hamishmack> Generating the metadata is slow and GHC API used to crash often in the process
01:31:19 <hamishmack> so we uploaded prebuilt metadata files to leksah.org
01:31:59 <M30W> mm_freak: Voip doesn't have to be used when you are out and about. Works fine at home/work (wired)
01:32:03 <hamishmack> It can be faster (although from where I am in NZ it takes just as long to download)
01:32:10 <LambdaDusk> is there already a function in a library that creates an url-slug from a Text?
01:33:10 <hamishmack> You can switch of the downloading in the initial dialog and just have it build the metadata locally
01:33:27 <Lethalman> hamishmack, mh ok
01:34:00 <hamishmack> It uses "cabal unpack" though to download the source
01:34:40 <hamishmack> for each package in the "ghc-pkg list" results
01:35:18 <Lethalman> hamishmack, from the console I get a 404 now when I do Update system data
01:35:44 <Lethalman> http://www.leksah.org/metadata-0.12/hashable-1.1.2.3.lkshm
01:35:51 <hamishmack> That is normal.
01:36:13 <hamishmack> Just means we have not uploaded metadata for that package
01:36:27 <Lethalman> or maybe I have an outdated hashable
01:36:30 <hamishmack> It should build it locally instead
01:36:50 <hamishmack> More likely you have a newer version
01:37:00 <Lethalman> there is 1.2.0.5
01:38:31 <hamishmack> One of the outstanding tasks for Leksah is to set something to automaticaly upload metadata for all packages in hackage
01:40:32 <Lethalman> hamishmack, or change hackage to put this metadata within the built ghc packages
01:40:38 <`nand`> what ever happened to hackage 2? Is it still in development, how soon is it expected to hit a live trial?
01:41:49 <hamishmack> Debian Haskell guys actually bundle leksah metadata with their pacakges, which is super nice.
01:42:28 * M30W just pattern matched Moxie Marlinspike with mm_freak =)
01:42:32 <Lethalman> hamishmack, I don't see any metadata coming with leksah in debian
01:43:40 * hackagebot hlint 1.8.41 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.41 (NeilMitchell)
01:44:18 <hamishmack> Maybe I am mistaken, but my understanding was that if installed a debian haskell version of a library it comes with metadata
01:45:16 <Lethalman> hamishmack, ah, I'm installing haskell libraries through cabal only, not debian packages
01:48:28 <b52> Does leksah provide the type signature as well as commentary for an arbitrary function?
01:50:11 <hamishmack> The autocomplete window provides type and the haddock comments
01:50:52 * Lethalman if only all this was in emacs
01:50:58 <hamishmack> It searches globally (not just imported symbols)
01:51:04 <b52> hamishmack: where is that located?
01:52:08 <hamishmack> Assuming the metadata is working it shoudl come up when you type (or you can press Ctrl+Space)
01:52:37 <hamishmack> You can set it to only come up when you press Ctrl+Space in the preferences
01:52:38 <gienah> hamishmack: it works, took quite a while to process 600 pkgs it did complete
01:53:43 <hamishmack> I've been adding some webkit stuff today.
01:54:36 <hamishmack> New Docs pane that shows your haddock docs (as in those generated for the packages you are working on)
01:55:26 <hamishmack> I have set it up so "cabal haddock" runs when tests are enabled (the tick button on the toolbar)
01:55:28 <gienah> hamishmack: neat. gentoo app-editors/leksah-0.12.1.3-r3 has patched extracted from the leksah repo to build with ghc 7.6.1
01:58:22 <hamishmack> Long term plan is to migrate everything to webkitgtk, then use GHCJS to ditch Gtk (well at least provide the option of running in a browser)
02:02:19 <Lethalman> hamishmack, so that it uses 50% of memory
02:02:37 <Lethalman> :S
02:03:01 <Lethalman> hamishmack, the very few projects using webkitgtk I've seen have been ported back to gtk or clutter
02:03:26 <Lethalman> I would better reconsider that plan
02:06:40 <hamishmack> I figure we'll add WebKitGTK panes where it makes sense first (viewing docs).  Then where it is nice (inspecting data and HTerm).  Then try it out where it may not make sense (browsing metadata and editing code).
02:07:31 <hamishmack> If all of those work ok then we might be able to make a webkitgtk only version
02:07:34 <Lethalman> hamishmack, ah for reading docs certainly yes, I thought the whole GUI with webkit
02:07:53 <kamatsu> anyone in Sydney hiring functional programmer? my partner is currently looking for work
02:08:46 <hamishmack> I figure we can do it one pane at a time and see what is painful
02:10:46 <hamishmack> HTerm is atractive because it is the only way I can see to get a terminal window that works in Windows
02:36:17 <Walther> Uh, in amuse-bouche, the file reading function is made as: main = readFile "file" >>= putStr . process
02:36:23 <Walther> is this really a useful way?
02:37:12 <shachaf> Useful?
02:37:26 <shachaf> If it works, that would seem useful enough.
02:37:29 <shachaf> Or what do you mean?
02:38:36 <Walther> a "god way"; a way it is supposed to do in haskell
02:38:56 <shachaf> Seems OK for simple scripts.
02:41:31 <typoclass> Walther: seems good to me. which part is bugging you?
02:41:58 <Walther> typoclass: the part of many tutorials making a fuss about IO in Haskell :P I want to make sure that I learn the "right way" from the beginning
02:42:03 <`nand`> the only thing to be careful about is lazy I/O, I guess
02:42:27 <fmap> @ty "file" ^! act readFile . to ?process . act putStr
02:42:28 <lambdabot> (?process::String -> String) => IO ()
02:43:18 <Lethalman> `nand`, in the case of readFile, the laziness there is fine, right?
02:43:48 <typoclass> Walther: oh, that's what you mean. no, the example is alright :)
02:43:54 <typoclass> @type readFile
02:43:55 <lambdabot> FilePath -> IO String
02:44:27 <Walther> and what is that >>= doing there, exactly
02:44:44 <mauke> heh, that's the core of all IO
02:44:45 <typoclass> Walther: the left side (readFile "file") is of type IO String, the right side (putStr . process) is String -> IO ()
02:45:12 <`nand`> Lethalman: I guess so, in terms of resource usage
02:45:13 <mauke> Walther: what other programming languages do you know?
02:45:20 <Walther> mauke: python, java
02:45:20 <wuttf> Can a letted value ever change? If it has an MVar inside it and I call a function on it which returns an IO value?
02:45:26 <mauke> meh
02:45:35 <wuttf> Obviously I lack some basic knowledge here :D
02:45:58 <shachaf> wuttf: No.
02:46:08 <typoclass> Walther: i think you can think of it a little like a pipe in the shell. "run the command on the left side, give its output into the command on the right side" if that makes sense
02:46:10 <mauke> Walther: >>= is how you access the result of IO actions
02:46:18 <mauke> Walther: you can think of it as registering a callback
02:46:23 <Walther> ah, thanks
02:46:40 <mauke> (>>=) :: IO a -> (a -> IO b) -> IO b
02:46:41 <wuttf> shachaf: Ouch,
02:46:54 <wuttf> shachaf: Im fckd.
02:46:54 <Lethalman> Walther, do contents <- readFile "file"; putStr (process contents) is the same
02:46:55 <Walther> and that only pipes it to function called "process", so it is not callable / usable by other functions?
02:47:01 <shachaf> @yowch
02:47:01 <lambdabot> Couldn't find fortune file
02:47:12 <mauke> m >>= f builds an IO action that (when executed) executes m, calls f on the result, then executes the action returned by f
02:47:21 <`nand`> Walther: except process itself calls those, sure
02:47:54 <typoclass> Walther: nope, the right side is "putStr . process". process would be some function of type String -> String that you define. putStr is built-in
02:47:58 <typoclass> @type putStr
02:47:59 <lambdabot> String -> IO ()
02:48:16 <`nand`> (though since you're in IO you might be mutating the data into some MVar which you can then access from outside that particular call to ‘>>=’
02:49:02 <typoclass> `nand`: well i don't think he's already using MVars at this stage =)
02:49:16 <`nand`> just saying, everything is possible in IO
02:49:34 <Walther> so if I want to do something with the read data, i need to use the function name "process" - i.e. the data isn't readable by other functions by issuing some command
02:50:22 <`nand`> Walther: you could bind the action to some larger combination of functions; like in the example: do { x <- readFile "foo"; foo x; bar x; bat x; baz x }
02:50:37 <Walther> so what if I want to say dataset = [contents of file], so I can just issue mycommand . lines a
02:50:46 <Walther> er, mycommand . lines . dataset
02:50:48 <`nand`> the ‘readFile "foo"’ is still only being bound to one function; \x -> foo x >> bar x >> bat x >> baz x -- but that results in an IO action that does a lot of things
02:51:19 <typoclass> Walther: if you want to use the line you quoted, then yes. you'll define a function named "process". you could for example do "process s = reverse s", to get a program that reads the file named "file" and prints it out back to front
02:51:59 <Walther> typoclass: ...or, i would have to define process as something like making a list of the data, so i can refer to process in all the other functions
02:52:26 <Walther> but with that way of typing it (the amusebouche example), there is no way of referencing to it from other functions
02:52:33 <Walther> did i understand it right
02:52:38 <`nand`> Walther: do { dataset <- readFile "foo"; mycommand (lines dataset); ... } -- do you mean something like this?
02:52:41 <mauke> not sure
02:52:45 <typoclass> Walther: not sure what you're aiming for :-/ the data that you read in will show up as the "s" in "process s = ..."
02:53:00 <`nand`> I didn't understand your last few sentences
02:53:01 <mauke> that is, it will call 'process' with the String it read
02:53:08 <MaybeCallMe> In a haskell DLL being used from C, how can I preserve state between haskell function calls from C?
02:53:29 <`nand`> MaybeCallMe: you could conjure up a StablePtr or whatever in Haskell and pass that to/from C? :)
02:53:35 <`nand`> or maybe something involving MVars
02:53:58 <typoclass> Walther: which part are you referring to? this https://github.com/mzero/haskell-amuse-bouche or the video?
02:54:01 <Walther> .well, if we stick with the amuse-bouce video - he happily continues to making functions like reverseLines etc, but he doesn't actually refer to the original file reading command anymore
02:54:04 <MaybeCallMe> `nand`: hmm is there a way i can use TVars?
02:54:57 <MaybeCallMe> `nand`: because ive heard MVars are not good when threading is implemented in future in my program
02:55:10 <shachaf> MaybeCallMe: Your API should avoid using global variables if it can.
02:55:21 <shachaf> Just make a token that you pass to the C code, like `nand` said.
02:55:30 <shachaf> Also,
02:55:32 <shachaf> Er.
02:55:35 <beaky> hello
02:55:46 <shachaf> "ive heard MVars are not good when threading is implemented in future in my program" is not a good way to make decisions about concurrency.
02:56:20 <MaybeCallMe> shachaf: i can't serialize my state which i wish to pass to C
02:56:30 <beaky> is the ST monad ever necessary?
02:56:31 <MaybeCallMe> shachaf: it is too complicated
02:56:35 <shachaf> I didn't say to serialize it.
02:56:46 <shachaf> How would you do this in a C API?
02:56:51 <`nand`> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-StablePtr.html#t:StablePtr
02:56:53 <shachaf> Would you use a global variable?
02:57:23 <MaybeCallMe> shachaf: in C API, I would in this case have to use a global variable.
02:57:49 <shachaf> So you're the one making all those C APIs with hidden global variables everywhere?
02:57:50 <mauke> beaky: is Haskell ever necessary?
02:57:52 <shachaf> Stop it!
02:58:16 <`nand`> hmm
02:58:18 <wuttf> Would anyone familiar with the mongoDB driver help me out? I need an example of how to iterate over a cursor.
02:58:33 <`nand`> ignoring freeStablePtr; is unsafePerformIO on deRefStablePtr safe?
02:58:44 <beaky> haskell liberates us from the von-neumannstyle
02:58:57 <shachaf> MaybeCallMe: Just take whatever Haskell state you want and pass a pointer to the C code.
02:59:45 <MaybeCallMe> shachaf: don't know much about pointers in haskell
02:59:54 <MaybeCallMe> shachaf: where can i read about it
03:00:17 <shachaf> Well, you don't need to know about pointers when you're writing in Haskell.
03:00:24 <shachaf> You need to know about them when you're working with C.
03:00:28 <shachaf> So read the FFI documentation.
03:00:47 <MaybeCallMe> shachaf: ok be back later
03:00:56 <MaybeCallMe> shachaf: reading FFI for a while
03:02:31 <mauke> fmap f (Cod q) = Cod $ \k -> k (q f)
03:02:44 <mauke> ¯\(°_o)/¯
03:03:01 <shachaf> mauke: That's for Codensity?
03:03:11 <mauke> yes, but it's probably very wrong
03:03:17 <shachaf> Does it type-check?
03:03:19 <mauke> yes
03:03:30 <shachaf> Then I doubt it's wrong.
03:03:38 <mauke> it doesn't typecheck for Cont
03:03:55 <shachaf> Oh.
03:04:04 <mauke> f :: a -> b  and I'm basically instantiating the r in forall r. (a -> r) -> r with b
03:04:07 <shachaf> Maybe I'm mixed up, then.
03:04:18 <shachaf> (a -> r) -> r?
03:04:24 <shachaf> It should be m r.
03:04:36 <mauke> another way to look at it: \k ->  k (f (q id))
03:05:04 <mauke> i.e. I'm running the inner action, using 'id' to get the value out, then piping it through f, then calling my own kontinuation
03:05:22 <mauke> shachaf: I'm skipping the m
03:05:26 <shachaf> Oh.
03:05:29 <shachaf> That's not Codensity, then.
03:05:31 <shachaf> That's Identity.
03:06:01 <mauke> oh, very possible
03:06:08 <shachaf> jkff was in here a few months ago asking about the same thing.
03:06:17 <shachaf> (forall r. (a -> r) -> r) ~~ a
03:06:42 <mauke> let's see what the transformer version would look like ...
03:06:58 <mauke> (also, 'Cont r a' = contra)
03:08:42 * hackagebot certificate 1.3.5 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.3.5 (VincentHanquez)
03:09:00 <beaky> i love monoids
03:09:25 <mauke> :r
03:09:31 <shachaf> @arr
03:09:31 <lambdabot> Ahoy mateys
03:09:46 <beaky> but lists are the only monoids I know :(
03:09:56 <mauke> instance (Monad m) => Functor (Cod m) where
03:09:58 <mauke>   fmap f (Cod q) = Cod $ \k -> q (return . f) >>= k
03:10:38 <mauke> I'm not sure what this does but I'm pretty sure I shouldn't need a Monad constraint there
03:10:56 <shachaf> What's Cod?
03:11:07 <mauke> newtype Cod m a = Cod{ runCod :: forall r. (a -> m r) -> m r }
03:11:08 <beaky> Codomain
03:11:24 <shachaf> Oh, this is real Codensity.
03:12:02 <mauke> just a messed up instance because the r is so polymorphic I can do anything with it
03:13:11 <shachaf> Yes, you don't need the Monad.
03:13:23 <shachaf> In fact you don't even need Functor.
03:13:34 <mauke> yeah, I'm supposed to use the ContT instance
03:13:50 <mauke> the code above isn't valid for ContT because the r's don't line up
03:14:27 <MaybeCallMe> shachaf: can I do this:
03:14:27 <MaybeCallMe> foreign export ccall update :: StablePtr MyObject -> Double -> IO ()
03:14:27 <MaybeCallMe> and on the C side, I keep a copy of HsStablePtr. But what if I now want to call the haskell DLL from VBA, how will I keep a copy of HsStablePtr in VBA?
03:14:46 <shachaf> I don't know anything about VBA.
03:15:04 <MaybeCallMe> what else do you know? how about java or .NET?
03:15:19 <MaybeCallMe> JNA, or PInvoke?
03:15:19 <shachaf> How about them?
03:15:24 <mauke> I know C
03:15:35 <MaybeCallMe> how would you marshall StablePtr into JNA, or PInvoke?
03:15:36 <shachaf> Whichever one you use, I'd recommend reading its FFI documentation.
03:15:48 <MaybeCallMe> shachaf: ok
03:15:48 <shachaf> They're all different but they probably all interface with C.
03:16:19 <shachaf> Look up what a StablePtr is, etc.
03:16:29 <MaybeCallMe> HsStablePtr is a void pointer..
03:16:41 <MaybeCallMe> so i guess i need to marshall it as such
03:21:26 <shachaf> mauke: Note that you can get Cont from Codensity but not really the other way around.
03:24:18 <mauke> shachaf: Cont b = Codensity (Const b)?
03:24:26 <shachaf> Yes.
03:43:42 * hackagebot tls-extra 0.6.1 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.6.1 (VincentHanquez)
03:43:44 * hackagebot tls-debug 0.2.3 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.2.3 (VincentHanquez)
03:49:17 * M30W reads tls updates; mm_freak I think you're to thank. :D
03:49:59 <M30W> The haddock is missing :|
03:50:18 <merijn> M30W: Haddock sometime takes a while to update for new versions
03:50:30 <M30W> Fair enough.
03:50:33 <merijn> Just click the second newest version and read those docs until they update
03:50:51 * M30W wonders why xmonad won't let him switch workspaces atm..............
03:50:55 <M30W> Can't ^_^
03:51:09 <M30W> There we go FREE
03:53:16 <`nand`> M30W: I've found that xmonad can become unresponsible when it's waiting on some IO action
03:55:16 <M30W> `nand`: Yea. Usually when I have IO issues (This laptop + USB seem very concistant to breaking with IO; crypto freaks out and I can't access the filesystem, working at the moment; I normally just ssh out to my other laptop/ssh/desktop-like-use box for irc, code etc. But when firefox crashes I have to reboot.)
03:55:37 <M30W> As I was saying' XMonad is normally the only thing that doesn't lock up.
03:56:01 <M30W> Evil IO D:
03:56:24 <M30W> FF frozen :(
03:58:00 <typoclass> M30W: that doesn't really sound like an xmonad problem to me, i think more or less the whole system pauses when you have that kind of hardware issue
03:58:18 <typoclass> M30W: (and make a backup. i think your system is about to die)
03:58:26 <M30W> I know it's not xmonad.
03:58:27 <M30W> Haha
03:59:06 <M30W> This install... useless just a portable clone of my other usb which I'm booted on (ssh on the other laptop)
04:00:14 <M30W> TODO: Re-install win.8 on the 500G HDD with 128G for windows. Fix UEFI so it boots from my SSD instead of needing to chainboot through my sd card. And patch the ssd install so it boots ( Some issue with dbus not working; Haven't gotten around to fixing that )
04:00:36 <M30W> Just living from my 32G usb. Works. :)
04:01:02 <M30W> typoclass: Btw, this usb is never not flashing (TOO MUCH IO)
04:01:17 <M30W> No idea what's going on.
04:09:22 <`nand`> by IO I meant Haskell's IO type, not I/O in general
04:10:12 <M30W> It seems that I/O in general is locking (but not xmonad) while xmonad io only locks for a few seconds.
04:10:15 <M30W> :P
04:13:43 * hackagebot free-game 0.3.1.4 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.1.4 (FumiakiKinoshita)
04:16:43 <k0ral> hello, is there a way to specify the hidden elements from a module, instead of the exported ones ?
04:17:12 <M30W> a :: [IO ()]
04:17:26 <M30W> How do I in ghci run that silently ?
04:17:45 <shachaf> What does it mean to run a list?
04:18:44 <M30W> Trying to run this ugly chunk of code.
04:18:45 <M30W> [ (listenOn . PortNumber . fromInteger $ p) >>= \s -> accept s >>= \(h,_,_) -> hClose h | p <- [1024..65536] ]
04:19:07 <shachaf> What does it mean to run a list?
04:19:16 <Lethalman> M30W, sequence?
04:19:24 <M30W> Ofc
04:19:34 <shachaf> Well, sequence_
04:19:39 * M30W forgot to have forkIO
04:19:41 <M30W> Why _ ?
04:19:49 <shachaf> 04:17 <M30W> How do I in ghci run that silently ?
04:19:51 <M30W> Silent
04:19:52 <M30W> Yea
04:19:54 <M30W> :)
04:19:58 <M30W> Thanks guys.
04:20:38 <M30W> ghc: accept: resource exhausted (Too many open files)
04:20:40 <M30W> Hehehe
04:20:51 <M30W> 2040/tcp open  lam
04:21:04 <M30W> One way to count how many sockets I can open. :D
04:21:15 <Lethalman> :S
04:21:44 <Lethalman> M30W, >>= \s -> accept s >>= is just >>= accept >>=
04:21:57 <M30W> Indeed
04:22:10 <elliott> Lethalman: No it's not.
04:22:18 <M30W> I was doing more there; but yea.
04:22:22 <M30W> It's not ?
04:22:32 <elliott> Thta's (>>= (\s -> (accept s >>= ...))
04:22:45 <elliott> *That's
04:22:52 <M30W> Indeed.
04:22:58 <M30W> flip
04:22:59 <M30W> :)
04:23:04 <elliott> ?
04:23:17 <M30W> <interactive>: getProtocolByName: does not exist (no such protocol name: tcp)
04:23:20 <M30W> Interesting error
04:24:16 <`nand`> elliott: associativity, m >>= (\x -> k x >>= h)  =  (m >>= k) >>= h
04:25:47 <elliott> `nand`: I know.
04:27:27 <`nand`> then I'm not sure what you mean
04:28:13 <M30W> elliott: What Lethalman suggested worked.
04:28:30 <M30W> sequence_ [ forkIO $ (listenOn . PortNumber . fromInteger $ p) >>= accept >>= \(h,_,_) -> hClose h | p <- [1024..65536] ]
04:29:15 <elliott> Oh, huh.
04:29:18 <elliott> I had no idea (>>=) was infixl.
04:29:38 <elliott> Lethalman: Sorry; you were right.
04:30:36 <Lethalman> elliott, np \o/ I wasn't 100% sure of what I said :P
04:31:32 <M30W> hehe, lambdabot doesn't even know that the code is valid. O.o
04:31:36 <shachaf> elliott: Worse: >> is infixl
04:32:25 <M30W> shachaf: What's wrong with that?
04:32:28 <elliott> shachaf: Oh, ouch.
04:32:31 <elliott> That's nasty.
04:32:49 <M30W> What's nasty about it ? O.o
04:33:30 <M30W> a >> b = a >>= \_ -> b -- yea?
04:34:52 <mauke> wait, so (a >> b >> c) /= do { a; b; c }?
04:35:22 <shachaf> mauke: Yep.
04:35:26 <M30W> mauke: Yea.
04:35:27 <ocharles> > [1] >> [2] >> [3]
04:35:29 <lambdabot>   [3]
04:35:29 <shachaf> (Well, up to the monad laws it's the same.)
04:35:40 <ocharles> > do { [1]; [2]; [3] }
04:35:41 <lambdabot>   [3]
04:35:44 <mauke> yes, but this is why we have Codensity
04:36:09 <M30W> >> is kinda useless but looks cleaner than the do ; :P
04:36:12 <shachaf> > runWriter $ do { tell a; tell b; tell c }
04:36:14 <lambdabot>   No instance for (Data.Monoid.Monoid Debug.SimpleReflect.Expr.Expr)
04:36:14 <lambdabot>    arisi...
04:36:20 <shachaf> Phooey.
04:36:25 <elliott> (>>) isn't useless...
04:36:26 <shachaf> Cale: Upgrade SimpleReflect!
04:36:32 <shachaf> We want our monoid instance!
04:36:34 <ocharles> > [1] *> [2] *> [3]
04:36:36 <lambdabot>   [3]
04:36:48 <ocharles> wait, is this Perl or Haskell? How many ways are there to do it again?
04:36:57 <mauke> >=1
04:37:06 <M30W> elliott: In functionality, it does nothing but run that's after it.
04:37:11 <mauke> also, Haskell is Perl
04:37:13 <elliott> M30W: ?
04:37:15 <M30W> And discards it's output of the previous
04:37:27 <elliott> M30W: It's monadic sequencing that discards results; that's a perfectly useful operation.
04:38:21 <M30W> a >> b = a >>= \_ -> b -- a >> b == do { _ <- a; b }
04:38:38 <elliott> Sure.
04:38:43 <elliott> Except it's more the other way around.
04:38:47 <elliott> The latter is the sugar.
04:38:50 <mauke> a >> b = do {a; b}
04:39:01 <M30W> mauke: no
04:39:04 <M30W> _ <- a
04:39:16 <M30W> Note the >>= \_
04:39:20 <mauke> no
04:39:31 <M30W> No ?
04:39:33 <mauke> do { a; ... } desugars to a >> do { ... }
04:40:18 <M30W> if you're gonna have do there, no point to use a
04:40:24 <shachaf> do { a; b; c } ---> a >> do { b; c } ---> a >> b >> do { c } ----> a >> b >> c
04:40:27 <mauke> M30W: what
04:40:36 <shachaf> QED
04:40:40 <mauke> shachaf: modulo associativity
04:41:11 <M30W> shachaf: Not identical to my understanding
04:41:22 <shachaf> M30W: I was making a joke; never mind.
04:41:38 <shachaf> @ask Cale Could you upgrade SimpleReflect?
04:41:38 <lambdabot> Consider it noted.
04:41:41 <M30W> But functionality they do the same.
04:42:08 <M30W> exc the first doesn't discard the result.
04:43:17 * M30W wonders how to bind to more ports in the single program. Possible ?
04:43:31 <merijn> M30W: Create more sockets
04:43:38 <merijn> M30W: Can't bind a socket to more than one port
04:43:42 <M30W> merijn: I've got a bit more than more ;)
04:43:48 <M30W> main = sequence_ [ forkIO $ (listenOn . PortNumber . fromInteger $ p) >>= accept >>= \(h,_,_) -> hClose h | p <- [1024..65536] ]
04:44:01 <M30W> It doesn't get past 2043
04:44:07 <merijn> Why would you ever do that?
04:44:22 <merijn> M30W: Because your OS is sensibly limiting the amount of ports you can open
04:44:32 <M30W> I see.
04:44:43 <Lethalman> ulimit to the rescue
04:45:00 <M30W> Why would you ever do that -> for fun. :)
04:45:22 <M30W> Iteration fun.
04:45:49 <ocharles> M30W: you know about {map,for}M, right?
04:46:03 <ocharles> :t mapM
04:46:04 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
04:46:23 <ocharles> You can run a monadic action against each element in pure list
04:46:26 <ocharles> also:
04:46:27 <ocharles> :t mapM_
04:46:28 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
04:46:44 <ocharles> If you don't care about actually mapping the list values to something
04:47:06 <M30W> ocharles: Yea
04:47:21 <ocharles> ok
04:48:19 <MaybeCallMe> What is the haskellish elegant way do convert data A = B | C into Int
04:48:29 <M30W> ocharles: I wanted to play with [ x | x <- [i] ] :)
04:48:35 <ocharles> lsure :)
04:48:36 <merijn> MaybeCallMe: Depends on the exact form of B and C?
04:48:37 <elliott> MaybeCallMe: deriving Enum and then use toEnum/fromEnum?
04:48:46 <merijn> MaybeCallMe: Enum comes to mind
04:48:55 <typoclass> MaybeCallMe: a function? "toInt B = 42 ; toInt C = 37 ; toInt _ = 19"
04:49:01 <merijn> :t toEnum
04:49:03 <lambdabot> Enum a => Int -> a
04:49:06 <merijn> ugh
04:49:10 <M30W> ocharles: lsure? I sense non-belief.
04:49:20 <merijn> s/toEnum/unsafeToEnum
04:49:21 <ocharles> M30W: sure*
04:49:27 <MaybeCallMe> elliott:
04:49:27 <MaybeCallMe> merijin:
04:49:27 <MaybeCallMe> will check out Enum
04:49:27 <MaybeCallMe> typoclass: that is what I think to
04:49:34 <MaybeCallMe> *too
04:50:09 <merijn> MaybeCallMe: Just changing your datatype to "data A = B | C deriving (Enum)" should be sufficient
04:50:16 <zhulikas> :t unsafeToEnum
04:50:18 <lambdabot> Not in scope: `unsafeToEnum'
04:50:30 <M30W> ocharles: :)
04:50:32 <merijn> zhulikas: That doesn't exist, it's just that toEnum's type is awful
04:50:40 <zhulikas> ah, ok
04:50:41 <zhulikas> :)
04:50:43 <merijn> > toEnum 5 :: Bool
04:50:45 <lambdabot>   *Exception: Prelude.Enum.Bool.toEnum: bad argument
04:51:08 <merijn> zhulikas: Throws exceptions if your Int is too big
04:51:18 <zhulikas> > toEnum 1 :: Bool
04:51:20 <lambdabot>   True
04:51:24 <zhulikas> that's just wrong :)
04:51:55 <zhulikas> also, what about other programming languages where everything is true except 0?
04:51:58 <M30W> Can we define a datastruct to lambdabot ?
04:52:14 <M30W> @data A = B | C deriving (Enum)
04:52:14 <lambdabot> Unknown command, try @list
04:52:29 <M30W> data record *
04:52:40 <ocharles> data type*
04:52:41 <merijn> zhulikas: I saw someone jokingly suggest "class Trueish a where trueish :: a -> Bool"
04:52:42 <beaky> what is the most powerful feature of haskell
04:52:52 <zhulikas> :D
04:53:09 <merijn> zhulikas: You could totally write that if you wanted...
04:53:15 <zhulikas> nah, thanks
04:53:16 <zhulikas> I'm good
04:53:35 <mauke> merijn: I wasn't joking
04:53:36 <merijn> "instance Trueish [a] where trueish [] = False; trueish _ = True"
04:53:37 <MaybeCallMe> merijn: thanks. will derive Enum
04:53:50 <zhulikas> it would be False for 0, True for everything else in any other type :D
04:53:56 <M30W> ocharles: Oh yes, record is different. :)
04:54:04 <mauke> p || q = if trueish p then p else q
04:54:08 <zhulikas> :DD
04:54:11 <mauke> p && q = if trueish p then q else p
04:54:39 * M30W generally only dealt with records didn't really touch on those A = B | C, well.. A little for exceptions and states but meh. :)
04:54:49 <zhulikas> hey, shouldn't it be else (trueish p) ?
04:54:59 <zhulikas> because p isn't necessarily a boolean :D
04:55:01 <merijn> To bad "instance Trueish (Maybe a) where" and "instance Trueish a => Trueish (Maybe a) where" would overlap...
04:55:13 <merijn> zhulikas: Neither is p
04:55:26 <merijn> zhulikas: The type is (||) :: Trueish a => a -> a -> a
04:55:34 <zhulikas> ah, ok
04:55:35 <M30W> :t Trueish
04:55:35 <zhulikas> :D
04:55:36 <lambdabot> Not in scope: data constructor `Trueish'
04:55:45 <M30W> Thank god.
04:55:47 <merijn> M30W: That doesn't exist, I just came up with it
04:55:55 <M30W> merijn: "Thank god."
04:55:57 <M30W> :)
04:56:00 <zhulikas> we are prototyping on Haskell 2.0
04:56:01 <merijn> Nothing stops you from writing it, though...
04:56:04 <mauke> class Boolean a where toBool :: a -> Bool
04:56:10 <merijn> zhulikas: You mean ACME.PHP?
04:56:19 * zhulikas looks up 
04:56:24 <M30W> Wait, we're up to haskell 2.0 ?
04:56:28 <merijn> zhulikas: http://hackage.haskell.org/package/acme-php
04:56:33 <zhulikas> ohhhh
04:56:36 <merijn> "At last, a module that combines the dynamic-typing features of Haskell 2010 with the performance and strict semantics of PHP!"
04:56:36 <zhulikas> At last, a module that combines the dynamic-typing features of Haskell 2010 with the performance and strict semantics of PHP!
04:56:38 <zhulikas> love it :))))
04:56:39 <M30W> Can I see the RCF or whatever spec for haskell ?
04:56:45 <mauke> @where report
04:56:45 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
04:57:01 <mauke> > "Haskell" === ["P", "H", "P"]
04:57:02 <lambdabot>   False
04:57:04 <M30W> Firefox die
04:57:11 <merijn> acme-php is a hilarious joke :)
04:57:17 <M30W> Lolwat...
04:57:29 <zhulikas> let's see the source
04:57:58 <M30W>   pi = "3.14"
04:57:59 <M30W> LOL!
04:57:59 <merijn> zhulikas: github has more stuff
04:58:15 <zhulikas> instance Num String
04:58:20 <zhulikas> this is so wrong :D
05:00:24 <mauke> instance (Applicative f) => Num (f a)
05:00:30 <mauke> instance (Num a, Applicative f) => Num (f a)
05:00:59 <elliott> mauke: combine with Num () and you can use [()] as Nat
05:01:11 <elliott> > liftA2 (+) [0,0,0] [0,0]
05:01:13 <lambdabot>   [0,0,0,0,0,0]
05:01:15 * M30W needs to make an ircbot that will respond only to my commands and works as an irc client for the console. Multi-server support and ncurses.
05:01:21 <M30W> I wonder how well that would go :D
05:01:29 <M30W> I'd expect...... Not so well.
05:01:38 <merijn> M30W: What's stopping you? Probably wouldn't be *that* hard
05:01:49 <M30W> merijn: ncurses for one...
05:01:57 <merijn> @Hackage vty
05:01:57 <lambdabot> http://hackage.haskell.org/package/vty
05:02:09 <srhb> There's a hack for that.
05:02:10 <mauke> M30W: so basically like irssi?
05:02:15 <srhb> That really ought to be hackage's slogan.
05:02:16 <M30W> Holly crap
05:02:26 <M30W> mauke: Yea. But haskell. :D
05:02:43 <M30W> srhb: Yea
05:03:02 <M30W> merijn: I was looking for the wrong thing when I tried to find some ncurses library ages ago
05:03:04 <merijn> mauke: meh, I think it's a learning project worthy of more encouragement than yet another person trying Project Euler
05:03:16 <osfameron> I don't get subtract and elem in acme-php, aren't those reasonable definitions?
05:03:34 * M30W wonders where images come into that.....
05:04:25 <M30W> Image == space / chunk / section
05:04:35 <M30W> Interesting for a graphics library. :P
05:04:46 <merijn> osfameron: subtract is normally "flip (-)", isn't it?
05:04:52 <zhulikas> nothing is wrong with project euler :D
05:04:58 <elliott> osfameron: subtract is flipped.
05:04:58 <zhulikas> but it doesnt teach real world haskell
05:05:15 <osfameron> ah
05:05:29 <osfameron> I thought the joke was that the functions would work but stupidly
05:05:44 <merijn> @src elem
05:05:44 <lambdabot> elem x    =  any (== x)
05:08:35 <M30W> merijn: project euler is puzzles; real world is more fun. :)
05:09:16 * elliott likes notElem the most out of the acme-php functions.
05:10:35 <M30W> Is the acme-php meant to be a what not to do guide?
05:11:24 <bergmark> hehe
05:12:05 <M30W> bubble = wtf?
05:12:51 <zhulikas> M30W, I somehow can't find anything to work on with Haskell in the real world
05:12:59 <srhb> Idris looks pretty neat. A JS backend is a fun thing!
05:13:38 <M30W> zhulikas: Want some ideas? I have plenty
05:13:46 <zhulikas> yeah, share
05:13:51 <zhulikas> not sure if that would interest me though :D
05:14:53 <M30W> For documentation and reading code.. Work on the documentation for the package ssh.
05:15:18 <Lethalman> M30W, I think by real world he means something outside of haskell itself
05:15:19 <Lethalman> :)
05:15:41 <zhulikas> hah, so SSH has no documentation at all
05:15:44 <M30W> For real world coding. Webserver/ with ssl and fast
05:15:49 <M30W> I know :P
05:16:11 <M30W> Play with tcp :D
05:16:25 <M30W> mapM_ (\p -> forkIO $ (listenOn . PortNumber . fromInteger $ p) >>= accept >>= \(h,_,_) -> hClose h) [1024..65536]
05:16:29 <M30W> My last little play :D
05:16:39 <zhulikas> I actually though of implementing similar webserver to scotty
05:16:46 <M30W> Not that that is real world but fun. :)
05:17:31 <M30W> http://ix.io/41L/ zhulikas tcp guessing game. :D
05:17:58 <llyes23> salut
05:18:00 <M30W> Old version ignore
05:18:28 <M30W> http://ix.io/42q/
05:18:29 <M30W> :)
05:19:05 <zhulikas> hm :)
05:19:17 <M30W> TCP ♥
05:20:10 <zhulikas> oh!
05:20:14 <zhulikas> suddenly I found what to do
05:20:20 <zhulikas> just realized that I have an exam on Monday :D
05:20:33 <M30W> Btw. zhulikas (for a in {0..1024}; echo $a) | nc localhost 6666
05:20:43 <M30W> Or if bash wrap that echo with do ..;done
05:20:56 <M30W> zhulikas: Oh crap
05:21:46 <M30W> I have lots of holiday homework that I never started... TODO: Buy books; boot into windows and do some crap with excel. :'( And buy a $180 calculator WTF?
05:21:58 * M30W would rather use putty/ssh and ghci on my phone!!~!
05:22:14 <M30W> (Can't touch phone so go through the internet) :D
05:22:37 <ocharles> M30W: mapM_ (forkIO (listenOn . PortNumber . fromInteger >=> (accept >=> hClose . view _3))) [1024..65536]
05:22:40 <ocharles> if you want to golf it :)
05:22:51 <ocharles> you can probably do hClose . view _3 with Actions in lens
05:23:05 <M30W> ocharles: golf ?
05:23:20 <M30W> Also, I don't want lenses ;)
05:23:43 <ocharles> It might be: mapM_ (forkIO (listenOn . PortNumber . fromInteger >=> (accept >=> perform _3.act hClose))) [1024..65536]
05:24:06 <ocharles> M30W: https://en.wikipedia.org/wiki/Code_golf
05:24:12 <ocharles> why wouldn't you want lens? it's great :)
05:24:25 <M30W> Too many :P
05:24:50 <ocharles> oh actually, that should be composition into forkIO, but the general idea was >=> is great :)
05:25:22 <hpaste> npl pasted “why does this evaluate to 0 for some parameter?” at http://hpaste.org/80969
05:26:26 <mauke> > 27^27
05:26:27 <lambdabot>   443426488243037769948249630619149892803
05:26:35 <mauke> > 1 / (27^27)
05:26:36 <lambdabot>   2.2551652337284587e-39
05:26:43 <mauke> > log (1 / (27^27))
05:26:45 <lambdabot>   -88.98759538211688
05:27:45 <M30W> Infinity exists?
05:27:51 <npl> yes, I couldn't replicate this behaviour in ghci too
05:28:08 <fmap> > log (1 / (27^27)) :: Float
05:28:09 <lambdabot>   -Infinity
05:28:10 <mauke> npl: so how do you know it happens for 27/27?
05:28:13 <mauke> ah
05:28:17 <M30W> Heh
05:28:25 <mauke> that would do it
05:28:58 * M30W wonders why there is Infinity in haskell
05:29:44 <fmap> @google ieee754
05:29:45 <lambdabot> http://en.wikipedia.org/wiki/IEEE_floating_point
05:29:45 <lambdabot> Title: IEEE floating point - Wikipedia, the free encyclopedia
05:29:45 <srhb> Because of IEEE?
05:29:47 <fmap> M30W: ^
05:29:58 <npl> why does it work when you leave out the :: Float ?
05:30:09 <M30W> Heh
05:30:24 <fmap> npl: because default is Double
05:30:37 <npl> ah ok
05:31:38 * M30W now wonders why lambdabot was made to have two messages for the google result. Why not protocole://domain.tld/uri - Title: blah
05:32:13 <mauke> "/uri" ಠ_ಠ
05:32:25 <M30W> mauke: That the look of disaproval?
05:32:31 <ocharles> si
05:32:40 <Adnauseam> knowing mauke, he does not show disaproval
05:32:48 <Adnauseam> it is most likelz to be rage
05:32:54 <fmap> > log (1 / (144^144))
05:32:55 <lambdabot>   -Infinity
05:33:00 <M30W> heh
05:33:38 <M30W> mauke: /path/file.ext * happy?
05:33:43 <mauke> no
05:33:59 <M30W> mauke: Why? :(
05:34:11 <mauke> urls are not / do not refer to files
05:34:20 <mauke> and ".ext" is stupid in general
05:35:01 <mauke> also, query parameters and fragments
05:35:12 <M30W> ?query#search
05:35:12 <lambdabot> Unknown command, try @list
05:35:15 <M30W> Heh
05:35:53 <zhulikas> @src Infinity
05:35:53 <lambdabot> Source not found.
05:35:59 <zhulikas> because it doesn't exist!
05:36:16 <M30W> Seems only -Infinity
05:36:45 <M30W> > minBind-1 :: Int
05:36:47 <lambdabot>   Not in scope: `minBind'
05:36:47 <lambdabot>  Perhaps you meant `minBound' (imported from Prelude)
05:36:56 <M30W> > minBound -1 :: Int
05:36:57 <lambdabot>   9223372036854775807
05:37:04 <M30W> Heh
05:37:18 <zhulikas> :D
05:37:18 <mauke> > abs minBound :: Int
05:37:19 <lambdabot>   -9223372036854775808
05:37:23 <M30W> underflow ♥
05:37:43 <M30W> :t  abs
05:37:44 <lambdabot> Num a => a -> a
05:37:55 <M30W> @hoogle abs
05:37:55 <lambdabot> Prelude abs :: Num a => a -> a
05:37:55 <lambdabot> Control.Exception.Base absentError :: Addr# -> a
05:37:55 <lambdabot> System.IO AbsoluteSeek :: SeekMode
05:38:00 <zhulikas> I prefer Num String => String -> String
05:38:52 <wuttf> Is there a haskell channel for beginners?
05:38:59 <elliott> #haskell
05:39:06 <wuttf> :)
05:39:09 <zhulikas> :D
05:39:13 <zhulikas> everyone here is a beginner
05:39:15 <M30W>     abs n  = if n `geInt` 0 then n else negate n
05:39:16 <ocharles> wuttf: there is also #haskell-in-depth
05:39:17 <M30W> O.o
05:39:19 <ocharles> but that's very quiet
05:40:13 <wuttf> ocharles: I see =)
05:41:51 <srhb> Because of IEEE?
05:42:08 <srhb> wuttf: Why, do you feel that this channel is insufficient? Just out of curiosity.
05:42:23 <M30W> Sweet... vty ♥
05:42:36 <mauke> ContT qf <*> ContT qx = ContT (qf . (qx .) . (.))
05:42:37 <zhulikas> there is also #haskell-blah
05:42:47 <mauke> it typechecks!
05:42:47 <zhulikas> the true haskell channel
05:43:14 <mauke> @unpl (qf . (qx .) . (.))
05:43:14 <lambdabot> (\ g -> qf (\ m -> qx (\ d -> g (m d))))
05:43:22 <srhb> zhulikas: Haskell is off-topic in #haskell-blah :P
05:43:29 <zhulikas> :D
05:43:40 <zhulikas> it's quite easy to go off-topic in here too
05:43:51 <mauke> @unpl \qf qx -> (qf . (qx .) . (.))
05:43:51 <lambdabot> \ qf qx g -> qf (\ m -> qx (\ d -> g (m d)))
05:43:53 <zhulikas> too bad there are some control freaks who direct you to -blah quite soon :P
05:43:56 <M30W> " Automatically decodes keyboard keys into (key,[modifier]) tuples " Why not like EZConfig in xmonad D:
05:43:58 <srhb> That doesn't mean it should be done. ;)
05:44:28 <wuttf> srhb: I don't know, most people seem to be over 9000 thousand here, I feel a bit out of place.
05:44:40 <zhulikas> no worries
05:44:43 <srhb> wuttf: Don't. :) There's a constant influx of new people here.
05:44:45 <wuttf> 9 thousand *
05:44:47 <zhulikas> wuttf, I'm a total noob \o/
05:45:07 <M30W> vty, shouldn't be too hard to add EZConfig like turples for the bindings :)
05:45:13 <srhb> wuttf: The fact that there's a big span in the know-how of the people in here means there's almost certainly someone that can help with anything that might arise.
05:45:14 <zhulikas> every time I open my mouth, some demigods sarcastically make fun of me
05:45:22 <zhulikas> :D
05:45:26 <wuttf> zhulikas: Good to know there are others too ;)
05:45:43 <zhulikas> that happens when I try to say something smart. Apparently I'm not quite there yet :D
05:45:49 <mauke> http://www.haskell.org/haskellwiki/Real_World#haskell
05:45:56 * M30W was like you guys not too long ago. :D Doesn't take long guys ^_^
05:46:32 <zhulikas> there is one step for me to enter haskell world. Find a project I am passionate about and implement it in haskell
05:46:33 * M30W ♥ [(k,f)], might bring it to vty. :)
05:47:05 <zhulikas> I gathered enough understanding of haskell from solving 68 euler problems
05:47:11 * M30W can't find any vty examples -_-
05:47:35 <arturaz> why does haskellers love var names like qf qx g -> qf (\ m -> qx (\ d -> g (m d))) ?
05:47:45 <mauke> arturaz: they don't
05:47:49 <M30W> zhulikas: I skipped euler and went straight to configuring xmonad (First thing ever with haskell)
05:47:50 <zhulikas> sveikas, artūrai :D
05:47:51 <Hafydd> That isn't a var name.
05:47:53 <M30W> :D
05:48:10 <zhulikas> arturaz, security through obscurity :D
05:48:15 <M30W> Then cheated and started hacking vodik's xmonad configs instead. My Tmux module tho :D
05:49:07 <wuttf> arturaz: =)
05:49:46 <arturaz> zhulikas, priv?
05:50:13 <mauke> @djinn Cont r (a -> b) -> Cont r a -> Cont r b
05:50:14 <lambdabot> Error: Undefined type Cont
05:50:21 <mauke> oic
05:51:37 <fmap> @djinn (((a -> b) -> r) -> r) -> ((a -> r) -> r) -> ((b -> r) -> r)
05:51:37 <lambdabot> f a b c = b (\ d -> a (\ e -> c (e d)))
05:51:55 <mauke> @djinn Cont r (a -> b) -> Cont r a -> Cont r b
05:51:55 <lambdabot> f a b =
05:51:55 <lambdabot>     case a of
05:51:56 <lambdabot>     Cont c -> case b of
05:51:58 <lambdabot>               Cont d -> Cont (\ e -> d (\ f -> c (\ g -> e (g f))))
05:52:22 <arturaz> mauke, they don't?
05:52:25 <arturaz> ^^
05:52:29 <mauke> arturaz: correct
05:52:40 * M30W hopes that cabal installs vty-ui with the demos and doesn' error out
05:52:42 <arturaz> what's that above?
05:52:55 <mauke> arturaz: lambdabot output
05:54:12 <fmap> arturaz: are there better names?
05:54:32 <arturaz> fmap, can't say, I have no idea what those are
05:55:02 <fmap> well, (<*>) for Cont m is highly abstract anyways
05:56:44 <mauke> am I reading it wrong or is djinn doing it in the wrong order?
05:56:47 <fmap> arturaz: would you object to calling `x' `x' in `id x = x'?
05:56:55 <mauke> it invokes b first
05:57:09 <zhulikas> I think variables aren't of much importance as long as functions are small and you can read their type definitions
05:57:56 <mauke> my semi-handwritten version: ContT qf <*> ContT qx = ContT $ \k -> qf (\f -> qx (k . f))
05:57:56 <zhulikas> arturaz, you need to develop a haskell vision ;) being able to understand what code does without reading it
05:58:33 <arturaz> fmap, no, but I'd object calling a & b in fmap. from & to are sweet names
05:59:25 <mauke> arturaz: ew, no
05:59:37 <mauke> that reads terribly
05:59:54 <mauke> "this function maps from 'from' to 'to'"
06:00:55 <mauke> fmap :: Functor functor => (from -> to) -> functor from -> functor to  -- please kill me
06:01:23 <ocharles> (from to to) to functor from to functor to
06:02:30 <mauke> fmap2 :: Functor functor => (from -> from2 -> to) -> functor from -> functor from2 -> functor to
06:03:37 <arturaz> mauke, src and dst then if you want to speak it out loud
06:03:44 <elliott> mauke: I think you'll find that fmap2 a bit hard to implement :P
06:03:57 <elliott> arturaz: "src" and "dst" are not what I would call optimised for pronunciation...
06:04:24 <mauke> elliott: fmap2 :: Functor2 functor2 => (from -> from2 -> to) -> functor2 from -> functor2 from2 -> functor2 to
06:04:34 <mauke> now read it out loud
06:06:34 <ocharles> toot toot!
06:06:45 <elliott> mauke: does Monad become FunctorFunctor? :)
06:06:48 <M30W> Hoot hoot!
06:06:53 <Chousuke> how about src, dst? :P
06:07:29 <mauke> let's rename 'i' to 'loopCounter'
06:07:59 <Chousuke> sometimes when I read the more complicated haskell type signatures I wish people would use more than one or two characters for type variables
06:08:23 <Chousuke> not counting apostrophes
06:08:30 <mauke> for (int loopCounter = 0; loopCounter < a.length; loopCounter++) { a[loopCounter] += b[loopCounter * 2]; } // holy shit is this readable
06:08:41 <Chousuke> that's a strawman though
06:08:54 <mauke> disagree
06:09:06 <Chousuke> you can disagree all you want but it's still a strawman :P
06:09:11 <mauke> disagree
06:09:33 <Chousuke> "i" or "idx" in that case is perfectly understandable and doesn't need to be expanded
06:09:40 <mauke> Chousuke: why?
06:10:16 <Chousuke> because you're using the variable for indexing. :P
06:10:20 <`ramses> Chousuke: that's just because you're used to using i for indices
06:10:27 <mauke> Chousuke: so what?
06:11:04 <mauke> for (int loopCounter = 0; loopCounter < a.length; loopCounter++) { sum += f(loopCounter * 2); } // no indexing
06:11:32 <Chousuke> `ramses: sure, but that's a more specific use than just using a and b and c for the first, second, and third type variable of some function.
06:11:51 <srhb> That was not your complaint though.
06:11:57 <`ramses> Chousuke: if the type is fully polymorphic, there often is nothing more to say about it
06:12:09 <Chousuke> `ramses: often it's not, though.
06:12:12 <M30W> Is there any function that exists that upper's the first character? like this `ap ((:) . toUpper . head) tail`
06:12:31 <mauke> M30W: fails on empty strings
06:12:38 <M30W> mauke: Indeed.
06:12:42 <mauke> also fails on many non-empty strings
06:13:19 <M30W> mauke: Examples?
06:13:25 <M30W> I only see null
06:13:46 <mauke> M30W: what if the first character is 'ß'?
06:14:06 <M30W> "\223"
06:14:18 <mauke> what
06:14:37 <M30W> What I got.
06:14:45 <mauke> yes, but that's not the correct answer
06:14:53 <M30W> You can't upper it.
06:14:59 <mauke> yes, I can: "SS"
06:15:16 <M30W> ?
06:15:26 <mauke> the uppercase version of ß is SS
06:15:37 <M30W> O.o
06:15:42 <zhulikas> > toUpper 'ß'
06:15:42 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:15:42 <mauke> next one
06:16:00 <mauke> M30W: what if the string starts with i but is in turkish?
06:16:22 <mauke> the correct result would be İ
06:16:29 <M30W> Not problem in my code but in toUpper
06:16:32 <fmap> M30W: you can construct a traversal for that
06:16:36 <mauke> (and I for ı)
06:16:36 <`ramses> > uncurry (++) . ((map toUpper . take 1) &&& drop 1) $ "test"
06:16:38 <lambdabot>   "Test"
06:16:43 <`ramses> > uncurry (++) . ((map toUpper . take 1) &&& drop 1) $ ""
06:16:45 <lambdabot>   ""
06:16:50 <fmap> ew
06:16:54 <`ramses> :)
06:17:05 <mauke> M30W: if your code uses toUpper, then there is a problem in your code
06:17:35 <M30W> mauke: So what? Make my own with MANY cases?
06:17:48 <mauke> no, figure out what you're actually trying to do
06:18:05 <mauke> because "many cases" won't save you with turkish
06:18:07 <M30W> Was trying to take a string and upper the first char
06:18:14 <mauke> yes, that doesn't actually mean anything
06:18:39 <mauke> "the first char" and "upper" are ill defined
06:18:41 <srhb> If you want to be locale dependent, Data.Text.ICU has a proper toUpper.
06:18:46 * hackagebot arrow-list 0.6.1 - List arrows for Haskell.  http://hackage.haskell.org/package/arrow-list-0.6.1 (SebastiaanVisser)
06:18:51 <srhb> Or at least "better" toUpper.
06:19:00 <b__> why isn't the Prelude head of type '[a] -> Maybe a' ?
06:19:05 <srhb> b__: Yes.
06:19:17 <`ramses> :t listToMaybe
06:19:18 <lambdabot> [a] -> Maybe a
06:19:26 <`ramses> b__: ^^
06:19:34 <b__> > listToMaybe [1..4]
06:19:36 <lambdabot>   Just 1
06:19:37 <zhulikas> maybe there is a safeHead
06:19:50 <zhulikas> @hoogle [a] -> Maybe a
06:19:50 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
06:19:50 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
06:19:50 <lambdabot> Prelude head :: [a] -> a
06:19:59 <`ramses> > listToMaybe []
06:20:00 <lambdabot>   Nothing
06:20:03 <b__> > reverse $ listToMaybe [1..4]
06:20:04 <lambdabot>   Couldn't match expected type `[a0]'
06:20:05 <lambdabot>              with actual type `Data.May...
06:20:08 <b__> erm
06:20:16 <b__> > listToMaybe $ reverse [1..4]
06:20:18 <lambdabot>   Just 4
06:20:25 <b__> kinda lame but sure
06:20:27 <b__> ^^
06:20:31 <deggis> check package Safe
06:20:36 <b__> ok
06:20:36 <`ramses> what's lame? the name?
06:20:53 <b__> no the fact that head is dangerous
06:21:04 <plhk> does something like `man' exist for haskell? hoogle gives a lot of results, but i want exact match
06:21:13 <b__> it's kinda unhaskellish
06:21:19 <b__> esp. to have it in Prelude like that
06:21:43 <mauke> b__: I'd say head is unhaskellish no matter what type you give it
06:21:55 <srhb> mauke: How so?
06:22:40 <M30W> head (x:_) = x
06:23:29 <b__> M30W yes..
06:23:30 <srhb> M30W: That's the normal head, which clearly is not nice because it's partial.
06:24:05 <b__> head (x:_) = Just x; head _ = Nothing
06:24:18 <`ramses> @src listToMaybe
06:24:18 <lambdabot> listToMaybe []        =  Nothing
06:24:18 <lambdabot> listToMaybe (a:_)     =  Just a
06:24:19 <srhb> The question was why the above would be unhaskelly.
06:24:35 <mauke> srhb: if you do [a] -> a, it's partial; if you do [a] -> Maybe a, you've simply replaced one constructor ((:)) by another (Just). you still need to pattern match on the result
06:25:06 <srhb> True enough.
06:25:18 <b__> pattern matching on Maybe is arguably more haskellish
06:25:39 <b__> either way it's ugly
06:25:40 <srhb> pattern matching properly on lists is haskelly as well.
06:25:50 <srhb> (if it's really necessary)
06:26:04 <zhulikas> listToMaybe is such a misleading name
06:26:12 <b__> yep
06:26:25 <`ramses> it should be called safeHead or something like that
06:26:26 <b__> sounds php-esque as well
06:26:29 <zhulikas> yes
06:26:34 <srhb> b__: I mean, if you case listToMaybe xs of... why not simply case xs of [] -> ...; x:_ -> ...
06:26:45 <zhulikas> or just head and [a] -> a should be unsafeHead :)
06:26:46 <M30W> b__: But then it would be type Either
06:27:03 <`ramses> zhulikas: that would be even better, but would break a lot of code
06:27:05 <srhb> M30W: huh?
06:27:06 <M30W> Maybe *
06:27:08 <zhulikas> yes :/
06:27:26 <b__> in most case I guess a list where you don't know if there's stuff in it at ALL is just bad
06:27:51 <zhulikas> :D
06:28:01 <srhb> I think that's nonsense.
06:28:03 <M30W> srhb: b__ suggested head goes as a maybe.
06:28:08 <`ramses> b__: that happens often, doesn't it? for instance in generate-and-test scenarios where you're not sure whether a solution exists for every input
06:28:16 <srhb> That's exactly what a list is for. Zero or more things.
06:28:24 <M30W> :)
06:28:26 <b__> yeah true
06:28:27 <nelson_> greetings
06:28:32 <BobbyMcLiar> is Functor f1, Functor f2 =>  f1 a -> f2 b the same as forall f. Functor f => f a -> f b ?
06:28:38 <nelson_> curiosity, was haskell written in C like most other high level languages?
06:29:09 <`ramses> BobbyMcLiar: in the second one, the two f's must be the same, don't they?
06:29:12 <srhb> nelson_: GHC is written in Haskell mostly
06:29:14 <M30W> mauke: Is there a standard offset between characters to shift by ?
06:29:19 <b__> but still there are cases where the booleanness of a list comes from bad types
06:29:23 <M30W> (to upper)
06:29:45 <mauke> M30W: hahahahaha
06:29:53 <mauke> (no)
06:29:53 <BobbyMcLiar> `ramses: what does the forall keyword do then?
06:29:58 <M30W> mauke: Didn't think so
06:29:59 <Chousuke> nelson_: Haskell is a language, it's not written in anything. I don't know if any implementations exist that are written in C, though
06:30:06 <Chousuke> probably
06:30:14 <M30W> mauke: Atleast for a-z :P
06:30:19 <`ramses> nelson_: I guess it would be bootstrapped from a C runtime at least when you don't yet have a haskell compiler
06:30:26 <M30W> mauke: Err, I meant for each range *
06:30:26 <zhulikas> M30W, toUpper 'a' = 'A'; toUpper 'b' = 'B' ... :D
06:30:42 <mauke> > (toUpper '\x3c2', toUpper '\x3c3')
06:30:43 <lambdabot>   ('\931','\931')
06:30:50 <zhulikas> @src toUpper
06:30:50 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:30:52 <zhulikas> >:|
06:31:02 <M30W> @src rot13
06:31:02 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
06:31:04 <`ramses> BobbyMcLiar: declare that the type holds for all f's :) it is there as well in the first signature, just implicitely
06:31:06 <M30W> @where rot13
06:31:06 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
06:31:22 <mauke> > let c = '\x3c2' in toUpper c == toUpper (succ c)
06:31:24 <lambdabot>   True
06:31:27 * M30W was thinking something like that for each range of characters for upper'n mauke 
06:31:35 <mauke> M30W: ^
06:31:39 <`ramses> BobbyMcLiar: you can also have the forall appear somewhere inside the signature instead of at the beginning, that's when it matters
06:32:00 <BobbyMcLiar> `ramses: ok. thank you :)
06:32:09 <M30W> HEh
06:32:34 <M30W> > '\9829':['m','a','u','k','e']
06:32:36 <lambdabot>   "\9829mauke"
06:33:16 <b__> srhb: I just think that functions that can fail use Either or Nothing, whichever is more appropriate
06:33:37 <b__> instead of going fuck you on my program at runtime
06:33:42 <srhb> b__: Right, but like mauke said, you're exchanging a pattern match on a list that has an element or none with a pattern match on NOthing or Just
06:33:48 <b__> yeah that's true
06:33:55 <srhb> b__: Point being, you need neither head nor safeHead, they only make you pattern match on something else to the same effect.
06:34:09 <b__> yeah, it's an extra step
06:34:13 <M30W> > ap ((:) . toUpper . head) (map toLower . tail) "tEsT
06:34:14 <lambdabot>   <hint>:1:53:
06:34:14 <lambdabot>      lexical error in string/character literal at end of input
06:34:15 <M30W> > ap ((:) . toUpper . head) (map toLower . tail) "tEsT"
06:34:16 <lambdabot>   "Test"
06:34:45 <b__> > ap ((:) . toUpper . head) (map toLower . tail) ""
06:34:47 <lambdabot>  Terminated
06:35:01 <`ramses> except if you return the result of listToMaybe from some function in an API where it does not make sense to return a list
06:35:24 <`ramses> if you don't want users to depend on the result being obtained by using lists
06:36:28 <M30W> > let a "" = ""; a (x:xs) = (toUpper x):(map toLower xs) in a "teST" >> a ''
06:36:29 <lambdabot>   <hint>:1:75: parse error (possibly incorrect indentation)
06:36:33 <M30W> > let a "" = ""; a (x:xs) = (toUpper x):(map toLower xs) in a "teST"
06:36:35 <lambdabot>   "Test"
06:36:38 <M30W> b__: ^_^
06:36:48 <M30W> > let a "" = ""; a (x:xs) = (toUpper x):(map toLower xs) in a ''
06:36:49 <lambdabot>   <hint>:1:63: parse error (possibly incorrect indentation)
06:36:53 <M30W> Meh
06:36:56 <M30W> "" :)
06:37:22 <b__> > (\(x:xs) -> toUpper x : map toLower xs) "yO"
06:37:23 <lambdabot>   "Yo"
06:38:22 <M30W> b__: let a (x:xs) = Just ((toUpper x):(map toLower xs)); a _ = Nothing
06:38:57 <mauke> let a ((toUpper -> x) : (map toLower -> xs)) = x : xs
06:39:01 <M30W> > let a (x:xs) = Just (toUpper x:map toLower xs); a _ = Nothing in ""
06:39:02 <lambdabot>   ""
06:39:07 <M30W> O.o
06:39:20 <M30W> > let a (x:xs) = Just (toUpper x:map toLower xs); a _ = Nothing in "tEsT"
06:39:21 <lambdabot>   "tEsT"
06:39:29 <M30W> > let a (x:xs) = Just (toUpper x:map toLower xs); a _ = Nothing in a ""
06:39:30 <lambdabot>   Nothing
06:39:35 <M30W> =)
06:40:36 <mauke> > let a (map toLower -> (toUpper -> x) : xs) = x : xs; a _ = [] in a "tEsT"
06:40:38 <lambdabot>   "Test"
06:40:59 <M30W> Heh
06:41:14 <srhb> Is that a view pattern?
06:41:24 <mauke> no (it's two view patterns)
06:41:30 <srhb> Right.
06:42:05 <M30W> Nice
06:42:48 * M30W didn't even concider a view pattern.
06:44:05 <M30W> GHC extra not bad to forget about. =)
06:46:54 * M30W wonders if lambdabot has lambdaCase.
06:48:27 <M30W> > (\case "test" -> "yay"; _ -> "nay") "testing"
06:48:28 <lambdabot>   <hint>:1:3: parse error on input `case'
06:48:32 <M30W> Nope.
06:49:05 <b__> very creative ^^
06:49:34 <M30W> Needs -XLambdaCase
06:51:18 <`ramses> and needs ghc 7.6
06:56:09 * M30W wonders if there is a way to get LambdaCase in lambdabot runtime...
06:56:54 * M30W loves how he can use ghci as an mpd client. :) Ty libmpd
06:57:02 <Lethalman> M30W, maybe modifying L.hs
06:57:27 <M30W> Lethalman: This instance of lambdabot I can't control. =(
06:58:10 * M30W has never seen lambdabot to have any downtime either...
06:58:24 <M30W> @source
06:58:24 <lambdabot>  not available
06:58:34 <M30W> @where lambdabot
06:58:34 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
06:59:23 <M30W> @bf ++++
06:59:23 <lambdabot>  Done.
06:59:30 <M30W> Gimmeh output ?
06:59:32 <Lethalman> M30W, I don't think you can then
07:00:21 <M30W> :(
07:00:54 * M30W wishes every program was written in haskell on this computer that way my usb wouldn't keep flashing cause of all this IO.
07:00:57 <M30W> >_<
07:01:16 <fmap> M30W: ++++ doesn't have any output
07:01:23 <fmap> @bf +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
07:01:23 <lambdabot>   M
07:01:31 <M30W> Oh
07:01:45 <M30W> @bf +++++++++++++++++++++++.+++.++++++++++++++++++++>++++++++
07:01:45 <lambdabot>  Done.
07:01:53 * M30W needs to learn bf
07:03:41 <M30W> @bf >+++++++++[<+++++++++++>-]<[>[-]>[-]<<[>+>+<<-]>>[<<+>>-]>>>
07:03:41 <lambdabot>  Done.
07:04:06 <Lethalman> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
07:04:06 <lambdabot>   Hello World!
07:04:15 <M30W> Holly crap
07:04:51 <ocharles> M30W: why on earth would haskell mean no IO?
07:04:58 <M30W> @bf ++++++++++[>+++++++++>++++++++++++++>+++>+<<<<<<<-]>++.>+.+++++++++..+++++.<+++.<+++++++++++++.+.+++.----------.---------.>+.>.
07:04:59 <lambdabot>   bf: <stdout>: hPutChar: invalid argument (invalid character)
07:05:39 <M30W> :(
07:06:29 <M30W> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
07:06:29 <lambdabot>   Hello World!
07:06:53 <Guest19085> some native speaker here?
07:07:11 <M30W> Guest19085: Native = English = ALMOST EVERYONE HERE IF NOT ALL =)
07:07:16 <`ramses> I guess everyone speaks some language natively...
07:07:28 <M30W> `ramses: Nice.
07:07:39 <elliott> "Almost everyone" of 975 people is quite a stretch.
07:07:46 <`ramses> M30W: I certainly don't think everyone here is a native english speaker..
07:07:56 <M30W> elliott: I meant, almost everyone here knows English.
07:08:01 <merijn> I think a majority of #haskell is actually non-native English speakers...
07:08:10 <M30W> Didn't mean native for all but native for geri
07:08:24 <M30W> merijn: Really?
07:08:28 <b__> he means an English/American native speaker
07:08:32 * M30W only sees english ^_^
07:08:41 <zhulikas> :D
07:08:45 <merijn> I know many Dutch/Belgian/Israeli/German/Italian people in here...
07:08:48 <zhulikas> M30W, you want me to start speaking lithuanian?
07:08:49 <M30W> geri: You have a question?
07:08:55 <M30W> zhulikas: GO!
07:08:59 <zhulikas> :D
07:09:02 <M30W> :D
07:09:02 <geri> oh wrong channel lol
07:09:11 <merijn> M30W: That's because English is the language of #haskell, so any non-native English speakers still speak English here...
07:09:19 <geri> I am a hard working person with
07:09:19 <geri> excellent problem solving skills and I always try to come up with creative solutions out of the box.
07:09:19 <geri> I have learned how to quickly and efficiently get things done in order to achieve deadlines, multiple
07:09:19 <geri> times. ....any improvement on this...from english writing? :D
07:10:14 <b__> some functions are inverses of other functions (like (-) and (+)), but is there a type or class for such invertible functions?
07:10:26 <zhulikas> geri, wasn't your question about native speakers of brainfuck?
07:10:40 <Hermit> geri: wait, you want help writing your resume?
07:10:43 <Hafydd> What does "come up with creative solutions out of the box" mean?
07:10:55 <geri> Hermit, just these 2 sentences :D
07:10:57 <merijn> mm_freak: Ping? You can't hide from my netwire questions forever... :>
07:11:01 <Hafydd> Surely taking something out of a box is the opposite of being creative.
07:11:01 <M30W> zhulikas: Where other language....?
07:11:06 <b__> Hafydd it means corporate bs
07:11:12 <geri> Hafydd, to think out of the box...
07:11:31 <PeanutGuy> l
07:11:34 <PeanutGuy> http://bit.ly/UXqXjf
07:11:36 <Hafydd> I suggest rephrasing that, then, because it is reminiscent of "out of the box solutions".
07:11:38 <Hermit> geri: then you should say "I always try to come up with creative solutions thinking outside of the box"
07:11:57 <geri> ok
07:12:01 <b__> > let invert (+) = (-) in invert (+) 2 3
07:12:02 <lambdabot>   -1
07:12:05 <zhulikas> I am very good at thinking inside the box. Would that be a bad thing?
07:12:05 <Hafydd> Of course, it's good to know how to re-use existing code, but that's anothber matter.
07:12:26 <geri> Hermit, i dont want to delete hard working person :D
07:12:38 * M30W has a feeling that some smart cookie will use haskell 100% pointfree and make an operating system that has no IO after boot.
07:12:58 <`ramses> M30W: point-free does not exclude IO
07:13:07 <Fuuzetsu> is hayoo down?
07:13:08 <M30W> No IO as in hdd
07:13:11 <Hermit> geri: no, I was just fixing that part of the sentence (if you want an extra improvement on that very fix, enclose "outside of the box" with doublequotes)
07:13:17 <M30W> still io =)
07:13:19 <`ramses> M30W: point-free does not exclude IO to a hard disk
07:13:20 <Lethalman> `ramses, his phrase didn't imply point-free -> no IO
07:13:21 <Lethalman> :P
07:13:36 <M30W> `ramses: ?
07:13:37 <zhulikas> I feel like I'm in -blah channel :D
07:13:43 <`ramses> Lethalman: I deduced that implication from preceding context ;)
07:13:46 <M30W> zhulikas: :D
07:13:49 <Lethalman> `ramses, :P
07:14:09 <Hermit> geri: and instead of saying you are good at meeting deadlines, why not just say you are organized and plan for deadlines?
07:15:01 <Hermit> geri: and... we could continue this conversation on PM
07:15:07 <b__> it's also nicer in my view to say you use out-of-the-box thinking for getting work done
07:15:17 <b__> instead of the hippie creativeness
07:15:23 <Hermit> agreed
07:15:34 <geri> Hermit, i didnt organize it :D
07:15:36 <zhulikas> I should mention hippie creativeness in my resume
07:15:39 <zhulikas> that sounds so much cooler
07:15:46 <Hermit> haha
07:15:57 <M30W> xD
07:16:37 <M30W> zhulikas: Add every command and function you know into your resume. No one can reject what blows their mind. =)
07:16:55 <zhulikas> :D
07:17:11 <Hermit> I'd whack an applicant with their own resume if they bring me such a thing
07:17:15 <M30W> Especially if it's a book size worth. =D
07:17:36 <Hermit> specially if it's a book size worth...
07:18:44 <M30W> Hermit: Resume = obsucated
07:18:46 <M30W> :D
07:20:02 <M30W> Obfuscated resume program, Run it and you get a perfect text-formatted resume. :)
07:20:13 <M30W> (source code)
07:20:34 <M30W> Sun Jan 20 02:20:18 EST 2013
07:20:39 * M30W should sleep...
07:21:44 <b__> can any function other than id take type Id where 'type Id = forall a. a -> a'?
07:22:06 <Hermit> maybe const?
07:22:26 <b__> no
07:22:42 <fmap> b__: no
07:22:45 <`ramses> b__: I think that's the only possible non-bottom implementation
07:22:52 <b__> ok
07:23:13 <`ramses> as you cannot do anything with a value of a polymorphic type other then just returning it
07:23:18 <b__> yeah
07:23:26 <Eelis> you can still make slower and faster implementations :P
07:23:39 <`ramses> yeah, you can generate some heat :)
07:23:39 <M30W> http://www.ioccc.org/2012/endoh1/endoh1.c
07:23:42 <M30W> Smart cookie
07:24:58 <Hermit> that's one of the reasons I hate C
07:25:50 <M30W> http://www.ioccc.org/2012/hamano/hamano.c
07:25:53 <M30W> xD
07:28:19 <jeltsch> Hi, the generic binary package for Linux of GHC 7.6.1 needs libgmp.so.3.
07:28:45 <jeltsch> On Fedora 18, there are libgmp.so.10 and libmp.so.3. Can I use one of these as a fake libgmp.so.3?
07:31:00 <`ramses> jeltsch: probably noy
07:31:04 <`ramses> not*
07:31:16 <`ramses> the versions are there because they are incompatible
07:31:42 <`ramses> jeltsch: doesn't fedora offer a ghc package?
07:32:13 <b__> id and const are special because their type forall'ed only matches _them_
07:32:46 <jeltsch> `ramses: It always worked for me to use GMP 4 instead of GMP 3.
07:33:08 <jeltsch> `ramses: I don’t want to use a Fedora GHC package, since I want the latest GHC version.
07:34:10 <`ramses> jeltsch: then built the new version from source against the fedora libs?
07:35:40 <b__> type Const = forall a b. a -> b -> a only works for const, whilst there should be other functions that work fine with type Const a b = a -> b -> a
07:37:23 <b__> is there a name for those functions?
07:37:31 <jeltsch> `ramses: I tried building GHC from source only once and this took ages. I don’t want to do this again.
07:37:50 <jeltsch> In addition, I really need a quick solution, as I’m *very* low on time at the moment.
07:38:07 <jeltsch> I already have a GHC installation (from the binary bundlem
07:38:45 <jeltsch> I already have a GHC installation (produced from the binary bundle) that I have taken from another Linux installation.
07:38:48 <jeltsch> I just want to use this.
07:39:13 <jeltsch> And as I said, it was always possible to use libgmp.so.4 as libgmp.so.3.
07:39:30 <jeltsch> I’m just not sure about libgmp.so.10. The package says it is GMP 5.
07:40:00 <elliott> b__: You're looking for the notion of parametricity.
07:40:05 <jeltsch> And do you know what this libmp (not libgmp) is? It is part of Fedora’s gmp package, but I’m not sure whether it is same as libgmp.
07:42:33 <`ramses> I don't have a libmp on my system..
07:43:17 <Walther> > :t fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
07:43:19 <lambdabot>   <hint>:1:1: parse error on input `:'
07:43:59 <`ramses> jeltsch: you can try that quick and dirty solution, but it might fail
07:44:25 <`ramses> no other way to find out besides trying it, I guess
07:45:00 <jeltsch> `ramses: I tried, and at least, GHCi is able to start and to evaluate 10000000000 * 10000000000.
07:45:23 <`ramses> jeltsch: that's something ;)
07:46:26 <`ramses> Walther: that's not an expression, use let
07:46:47 <Walther> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
07:46:49 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
07:47:06 <Walther> uhh
07:47:17 <allsystemsarego> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:47:18 <`ramses> :t let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
07:47:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:47:19 <lambdabot> Num a => [a]
07:47:44 <Walther> `ramses: why was the "in fibs" necessary?
07:47:56 <`ramses> Walther: "let" without "in" is only valid in do-blocks
07:48:12 <`ramses> let defines the binding, in the expression using them
07:48:20 <`ramses> the bindings alone make no sense
07:48:48 <b__> elliott: ok
07:52:21 <b__> elliott: both Const and Id (CPS style) are used in Lens right? or are those different?
07:53:06 * Walther made a code that managed to chug three gigabytes of ram in 9s
07:53:08 <Walther> there *might* be something wrong in here
07:54:20 <Walther> fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
07:54:21 <Walther> sumEvenFibsUnder n = sum $ [x |x<- fibs, x <= n, x `mod` 2 == 0]
07:54:49 <fmap> @src even
07:54:49 <lambdabot> even n = n `rem` 2 == 0
07:54:51 <elliott> b__: no
07:54:54 <zxq9> What is the new way of doing things? It looks like GHC_PACKAGE_PATH is deprecated. Any docs on this?
07:55:01 <elliott> you may be thinking of the standard Const/Identity newtypes
07:55:10 <b__> ah yeah
07:55:15 <fmap> Walther: don't use `sum'
07:55:36 <Walther> fmap: hm?
07:55:48 <`ramses> sum is probably building up thunks, try a foldl'
07:55:51 <fmap> (and `mod' since all fibs are greater than zero)
07:56:50 <fmap> Walther: sum is defined with `foldl' and therefore just builds huge thunk and fails given sufficiently large list
07:57:07 <fmap> Walther: try `foldl' (+) 0'
07:58:43 <Walther> uh, what's the difference between `mod' and `mod`
07:58:49 <Walther> and respectively, foldl
07:59:01 <b__> elliott: but those look simply like wrapped versions of those basic functions
07:59:02 <elliott> sum specialised to Int or Integer should be efficient in GHC AFAIK.
07:59:20 <elliott> b__: rather they're type level versions
07:59:23 <elliott> newtype Const a b = Const a
07:59:27 <elliott> newtype Identity a = Identity a
07:59:31 <`ramses> elliott: only when compiled, then?
07:59:33 <Hermit> Walther: foldl' is strict, foldl isn't
07:59:36 <b__> elliott: yeah
07:59:46 <b__> so they can be made instances of other classes rite?
07:59:48 <elliott> `ramses: probably you need -O
07:59:59 <elliott> b__: well, so they can be passed as the "f" at all.
08:00:01 <`ramses> he's probably doing this in ghci
08:00:03 <elliott> Haskell doesn't have type lambdas
08:00:26 <b__> yeah
08:01:51 <Hermit> Walther: sumEvenFibsUnder n = foldl1' (+) $ filter (\x -> x <= n  &&  x `mod` 2 == 0) n   -- (using foldl1' from Data.List)
08:02:11 <Hermit> err
08:02:26 <Hermit> Walther: sumEvenFibsUnder n = foldl1' (+) $ filter (\x -> x <= n  &&  x `mod` 2 == 0) fibo
08:02:48 <Walther> Hermit: eh, getting a straight answer doesn't really help me if my goal is learning :P
08:02:55 <Walther> explanations, explanations
08:03:02 <mm_freak> merijn: pong
08:03:05 <mm_freak> =)
08:03:10 <Hermit> Walther: you know how lazy eval works?
08:03:16 <mm_freak> merijn: this is my third pong btw ;)
08:03:24 <Walther> Hermit: nothing is calculated before the value is needed
08:03:42 <Hermit> Walther: yes, and how is that implemented?
08:03:58 <Walther> i have no idea about the implementation
08:04:04 <Hermit> (the word "thunks" rings any bell?)
08:04:49 <`ramses> Walther: sum [1,2,3] = ((1 + 2) + 3), this doesn't get worked out anymore, and gets huge for a huge list
08:04:59 <Hermit> Walther: ok, lazy functions, when called produce a thunk, which is like a closure that will calc the result when it's required
08:05:03 <`ramses> thus leading to massive space usage
08:05:47 <cmccann> a thunk is like the program leaving itself a note "TODO -- think about this". if you ask what the thing is, the compiler thinks a bit, and when it's thunk things over you get what you asked for.
08:06:09 <Walther> ah, and foldr actually goes one element at a time, summing them as it goes?
08:06:25 <`ramses> cmccann: it's not the compiler doing the thinking there :)
08:06:26 <Hermit> Walther: when you collapse a list into a single result and the strict analysis doesn't do the right thing, you get that list length worth in thunks
08:06:47 <`ramses> Walther: no, foldr does that as well
08:06:53 <`ramses> it's lazy
08:07:12 <Hermit> Walther: foldl and foldr collapse a list applying a fn that takes 2 args successively, from left to right or right to left respectively
08:07:37 <Walther> uh, so how is fold any better than sum then?
08:07:53 <`ramses> foldl'  --> notice the '
08:08:02 <Hermit> Walther: foldl is lazy, but foldl' isn't
08:08:09 <Walther> hmm
08:08:14 <`ramses> that's a strict version of foldl, which does evaluate the subexpressions
08:08:22 <Hermit> foldl' won't generate any thunk. It will collapse the whole list at once
08:09:22 <cmccann> `ramses: actually I'm pretty sure that's roughly the origin of the term. :D
08:09:49 <`ramses> cmccann: but that thunking happens at runtime, right? It's not the compiler doing that
08:10:03 <elliott> cmccann: that's how I do my thinking too
08:10:04 <Hermit> `ramses: right
08:10:21 <cmccann> `ramses: yeah I messed up the wording a bit
08:10:29 <elliott> cmccann: except shachaf does the thinking part when the thunk gets forced
08:10:38 <Walther> sumEvenFibsUnder n = `foldl' (+) $ [x |x<- fibs, x <= n, x `mod' 2 == 0] -- gets me a parse error on input ``'
08:10:42 <cmccann> I think it did originally refer to the compiler doing the thinking, but at runtime it had already been thunk about
08:11:02 <`ramses> cmccann: I didn't know that was the origin of the word thunk though :)
08:11:33 <`ramses> Walther: leave out the quotation marks
08:11:35 <cmccann> well, the etymology is "the past tense of 'think' at two in the morning".
08:11:45 <`ramses> those where to set the names apart here
08:11:49 <cmccann> I don't recall the exact details otherwise
08:12:11 <Hermit> Walther: how about you check the actual example I gave you before? You are totally messing the quotes
08:12:24 <cmccann> elliott: good thing you're not strict, then. lots of those thunks must diverge.
08:12:30 <Hermit> Walther: either that or you are using a stupid editor
08:12:42 <Walther> Hermit: that uses filter and lambdas, which is completely different from my code
08:13:02 <Hermit> Walther: you used lists comprehensions instead, but it's equivalent
08:13:06 <Walther> Hermit: not saying that your solution is wrong, but it is completely different from mine
08:13:21 <Walther> my main goal is to learn, one bite at a time :)
08:13:42 <Hermit> Walther: sumEvenFibsUnder n = foldl1' (+) $ [x | x <- fibs, x <= n, x `mod` 2 == 0]  -- there you go
08:13:49 <`nand`> I always thought of “thunk” as a mixture of “think” and “chunk”
08:13:54 <Hermit> Walther: actually, take out the $, it's not needed
08:14:07 <Hermit> geez
08:14:13 <Walther> Hermit:  Not in scope: foldl'
08:14:20 <hiptobecubic> this is not a good way to do this
08:14:20 <`ramses> import Data.List
08:14:41 <Hermit> Walther: import Data.List (foldl1')
08:14:48 <hiptobecubic> you'll only get the sum of evens up to n, but the list never terminates
08:14:59 <`nand`> what's wrong with sum . takeWhile (<=n) . filter even $ fibs ?
08:15:09 <Hermit> @src sum
08:15:09 <lambdabot> sum = foldl (+) 0
08:15:09 <hiptobecubic> so your function never terminates
08:15:13 <Hermit> it's lazy
08:15:16 <`nand`> sum' then
08:15:19 <`nand`> w/e
08:15:33 <Walther> `nand`: sweeeeeet. that's a clean line
08:15:45 <magistr> haskell is very awful, couse it requires deep knowledges  theory of categories and lambda calculus
08:15:46 <`nand`> it also terminates
08:15:56 <Hermit> `nand`: you sure sum' exists?
08:16:00 <`nand`> Hermit: it doesn't
08:16:06 <`nand`> let sum' = foldl' (+) 0
08:16:15 <Hermit> ...
08:16:45 <leventov> hello, in ghc, what i should use to change body of the method if arguments conform some special classes? RULES, SPECIALIZE or something else? documentation messed me a bit
08:16:57 <magistr> language for math scientiest?
08:16:59 <hiptobecubic> magistr, the same way C requires deep knowledge of von neumann machines and assembly language.
08:17:28 <magistr> hiptobecubic, it is better than haskell!
08:17:38 <`ramses> magistr: any programmer should be a complexity theorist as well then?
08:17:43 <Hermit> magistr: so, what are you doing here?
08:17:45 <hiptobecubic> magistr, the point is that neither of those are true.
08:17:49 <mauke> magistr: are you just here for trolling?
08:17:59 <`nand`> mauke: that wasn't obvious?
08:18:04 <cmccann> pf, anyone who doesn't understand lambda calculus shouldn't be programming anyway
08:18:18 <hiptobecubic> lol
08:18:24 <`ramses> cmccann: the economy would take a big drop
08:18:34 <`nand`> anybody who doesn't understand higher categories /really/ has no business here
08:18:40 <cmccann> `ramses: no, just the employment rate of incompetent programmers
08:18:51 <magistr> languages only for math scienties is very awful
08:18:53 <`ramses> cmccann: and therefore the IT industry
08:19:02 <magistr> for what?
08:19:03 <mm_freak> leventov: the documentation is fine…  you want pattern matching, perhaps with guards
08:19:08 <Walther> sumEvenFibsUnder n = foldl' (+) . takeWhile (<=n) . filter even $ fibs -- No instance for (Num [a0]) arising from a use of `+'
08:19:17 <`ramses> cause really, how many day-to-day programmers know lambda calculus?
08:19:23 <cmccann> nah, dunno about you but I could get way more done without the industry being full of people who think abstraction is scary :P
08:19:51 <Hermit> Walther: .... would you care to be verbatim when copying?
08:19:59 <Hermit> Walther: foldl1' not foldl'
08:20:08 <`nand`> Walther: you forgot the base case
08:20:10 <`ramses> cmccann: you could, but would you be able to make up for the lost productivity due to 50% of IT personnel being gone?
08:20:24 <`nand`> Walther: foldl' (+) 0 -- don't use foldlr1', that would error out for small n
08:20:29 <`nand`> foldl1'*
08:20:48 <Hermit> `nand`: what?
08:20:49 <Walther> thanks!
08:21:08 <`nand`> > foldl1' (+) []
08:21:10 <lambdabot>   *Exception: Prelude.foldl1': empty list
08:21:15 <`nand`> > foldl' (+) 0 []
08:21:16 <lambdabot>   0
08:21:17 <leventov> mm_freak: pattern matching in geleralized function? never heard about it
08:21:21 <Hermit> right...
08:21:29 <leventov> *generalized
08:21:52 <elliott> magistr: it's true. haskell is very awful. you've exposed us.
08:21:54 <cmccann> `ramses: if I could use haskell instead of a mainstream language and all my coworkers did as well, the productivity gain would be a lot more than mere doubling. :P
08:21:55 <mm_freak> leventov: f x | even x = "wow, even!" | otherwise = "ugh, odd!"
08:21:59 <elliott> magistr: our only request is that you leave us to sob in peace.
08:22:05 <mm_freak> leventov: is that what you want?
08:22:25 <elliott> it's awful lonely, being a math scientiest
08:22:33 <magistr> mauke, no, i interesting practical literature how to learn haskell
08:22:41 <leventov> f a = True; f_spec :: Eq a => a -> Bool; f_spec a = False
08:22:42 <`nand`> haskell is all a facade to help edwardk seize world domination
08:23:02 <Walther> Hm. Seems like the function works like it was operating on takeWhile <n, not <=n
08:23:03 <cmccann> magistr: your current approach is suboptimal for getting anyone to assist you in any way
08:23:45 <Walther> as in, if i just take 7 fibs in ghci, i get [0,1,1,2,3,5,8]. However, sumEvenFibsUnder 8 results in 2
08:23:45 <Hermit> magistr: so you are bashing haskell but still want to learn it? even though you say C is better? make up your damn mind, will ya? If you really want to learn, leave the trolling aside and get serious
08:24:34 <mm_freak> Hermit: i don't think that helps either
08:24:46 <`ramses> Walther: how is that wrong?
08:24:48 <Hermit> mm_freak: too rude?
08:25:07 <`ramses> Walther: the only evens <=7 are 0 and 2
08:25:10 <mm_freak> Hermit: aggression is always answered with aggression =)
08:25:13 <`ramses> (and 0 shouldn't be there)
08:25:15 <Walther> `ramses: the function is supposed to sum "all not over n", hence, <=n, not <n
08:25:33 <`nand`> okay
08:25:34 <Hermit> mm_freak: so you want to make trolls feel all warm and fuzzy instead?
08:25:37 <`nand`> then it's a misnomer
08:25:41 <`nand`> sumEvenFibsNotOver n
08:25:41 <`ramses> yeah, 8 is not <= 7
08:25:43 <cmccann> Hermit: it's the #haskell way!
08:25:46 <mauke> Hermit: yes
08:25:48 <`nand`> sumEvenFibsLeq n :P
08:25:50 <mm_freak> Hermit: #haskell works like that
08:25:56 <mauke> either that, or ban them
08:26:05 <Walther> yeah, misnamed function but you saw the code :P
08:26:06 <Hermit> hmm
08:26:22 * cmccann pictures Cale and mauke playing good cop, bad cop
08:26:50 <Walther> oh wait, i just mixed two things
08:26:55 <Walther> sorry, everything's fine :)
08:26:56 <`nand`> `ramses: it's really debatable whether you let the fibonacci sequence start with 1 or 0
08:27:07 <mm_freak> Hermit: magistr probably has a reason why he thinks C is better…  the proper solution is to lead him =)
08:27:18 <Walther> `nand`: heh, luckliy that's not relevant for this specific problem
08:27:43 <`nand`> wikipedia claims the seeds are (0,1)
08:27:43 <`ramses> `nand`: oh, okay, I've always knows it to start with two 1s
08:27:46 <mauke> the only thing I insist on is that the 12th fibonacci number is 12^2
08:28:16 <`ramses> `nand`: hehe, then it must be true ;)
08:28:19 <mm_freak> > fix (\more x y -> x : more y (x + y)) 0 1 !! 12
08:28:20 <lambdabot>   144
08:28:24 <mm_freak> indeed
08:28:29 <`nand`> but wikipedia also mentions that (1,1) is an alternative :)
08:28:51 <Hermit> mm_freak: the only valid reason I can come up with to say C is better than haskell is binary size for embedded stuff like MCUs and kernel development. Other than that, it's a waste of time and effort
08:29:27 * `nand` wonders how small binaries compiled for the reduceron are, comparable to eg. GHC x86 output
08:29:44 <`nand`> (considering only the raw machine code and not the ELF header or other metadata)
08:29:45 <mm_freak> Hermit: even for kernels haskell as a language is better…  it's just that it's difficult to compile a kernel =)
08:30:00 <nyc> Different tools for different jobs, I say.
08:30:39 <`ramses> mm_freak: interfacing devices seems like a pita to me, although arguably that's true for C as well
08:30:47 <cmccann> @quote platitude
08:30:47 <lambdabot> ddarius says: "use the right platitude for the job"
08:30:49 <mm_freak> `ramses: you got it
08:31:05 <mm_freak> `ramses: i'd probably use a mix of haskell and assembler
08:31:12 <mm_freak> but so far nobody is paying me to write a kernel =)
08:31:19 <`ramses> mm_freak: but C is just that tiny bit more written with that use case in mind
08:31:23 * nyc programs kernels and suspects that various implicit allocations done by the runtime would be highly problematic.
08:31:32 <elliott> the proper solution is certainly not to feed people who are obviously trolling
08:31:35 <Hermit> mm_freak: now that would be something worth to be seen... a kernel written in haskell, but even then, it gives me chills down the spine to think about such a thing
08:31:41 <elliott> Hermit: there are several
08:31:45 <geekosaur> house?
08:31:59 <mm_freak> `ramses: not at all…  C sucks for kernels…  you need pages of code just to get an integer type of a particular size
08:32:23 <`ramses> mm_freak: I've never written one..
08:32:35 <jacobw> geekosaur: manoir?
08:32:54 <`nand`> anybody interested in kernels in Haskell see the house project(s)
08:33:00 <mm_freak> `ramses: well, just think about it:  forget all your #includes you got used to, including string.h, stdint.h, etc.
08:33:11 <mm_freak> you need to implement /everything/ yourself
08:33:17 <`ramses> ah, no libc?
08:33:25 <mm_freak> of course not
08:33:28 <`ramses> ouch
08:33:36 <Hermit> and not even malloc/free
08:33:42 <Hermit> you got to take care of that too
08:33:46 <`nand`> ah, I was too slow
08:34:00 <Walther> would be nice to see what it could do though
08:34:00 <mm_freak> `ramses: when you boot into your kernel, there is nothing except empty memory and your kernel…  you don't even get memory management for free
08:34:03 <Walther> compared to the C one
08:34:30 <mauke> mm_freak: automatic variables, yo
08:34:36 <`ramses> how much haskell would be accessible then? there would be similar constraints then, wont there?
08:34:45 <nyc> The pain involved in kernel implementation is not centered around the C runtime at all.
08:34:47 <mm_freak> `ramses: with haskell you would have the advantage that you would implement the RTS and most of those problems would be solved
08:35:14 <`nand`> Haskell runs on top of a RTS-- yeah
08:35:15 <ocharles> nyc so far seems to be the only person credible in this conversation
08:35:17 <ocharles> fwiw.
08:35:51 <`nand`> the main challenge would be implementing a (modified) RTS to run directly on the hardware, then you can expose much higher level abstractions to the kernel developer; eg. some form of hardware monad
08:35:58 <mm_freak> in fact the RTS is the tricky part
08:36:18 <mm_freak> it's basically the "kernel prelude and standard library"
08:36:43 <`nand`> House has implemented an RTS modified with mechanisms for, among other things, hardware interrupts and device communication
08:36:49 <mm_freak> `nand`: you could just expose the good old IO monad and wrap your abstractions around it
08:37:03 <nyc> With more advanced languages it could be a much bigger concern especially where it's intertwined with memory management and exceptions.
08:37:14 <Eelis> i don't think the implementation language is that important. the important thing is the functionality you expose to processes. for instance, the interface genode exposes to processes is a fairly clean C++ interface that could be wrapped in Haskell easily
08:37:30 <nyc> Interrupts being one form of exception.
08:37:45 <mm_freak> Eelis: the language is very important…  modern operating systems can't do anything fancy, because their languages are too complicated
08:37:45 <zxq9> In ImagineLand we have hardware Haskel machines, so this works. In the real world you're skipping over a huge part of what a kernel has to do to, well, be a kernel -- language aside.
08:37:54 <`nand`> mm_freak: I'm just not sure that the standard IO stuff like the C FFI make any sense in this context
08:37:59 <`nand`> or, for that matter, the rest of the Prelude concerning IO
08:38:10 <Eelis> mm_freak: i dunno what you mean by "modern operating systems"
08:38:27 <mm_freak> `nand`: sure they do…  this is in fact not a C FFI…  it's an FFI
08:38:35 <mm_freak> Eelis: linux, windows, etc.
08:39:04 <Eelis> mm_freak: the problem there is that they're not microkernels. a good microkernel is small enough that you can write it in C/C++ just fine
08:39:10 <`ramses> mm_freak: what fancy should the OS do then? imho it should mostly stay out of the way
08:39:11 <nyc> Memory management has to cope with running out of memory and gracefully returning failures and so on, which is very awkward to do from within language runtimes where the allocations may not even be visible to the programmer.
08:39:44 <mm_freak> Eelis: it's about the same reasoning as for compilers…  did you notice that with about every minor release of GHC you get new fancy features?  in GCC you mainly get speed improvements and bug fixes
08:40:15 <Eelis> mm_freak: well, i'm not sure how you planned for this analogy to work, but i sure don't see the kernel as something that needs to have as many fancy features as possible
08:40:17 <mm_freak> reason:  the GHC developers work in a language, where they can put their mental power in innovation instead of keeping bugs out
08:40:32 <`nand`> I think the most important aspect of an operating system is safety
08:40:39 <Eelis> kernels should be simple
08:40:54 <Eelis> and once they're simple it doesn't matter anymore how you implement them
08:40:54 <`nand`> and a powerful type system can enforce many more invariants to preserve safety than a comparatively weak one
08:41:14 <nyc> Kernels are innately complex.
08:41:24 <Eelis> nyc: nope. look at things like L4 kernels
08:41:25 <`nand`> that's what leads me to think kernels in Haskell or Agda would be a serious move forwards
08:41:31 <mm_freak> `ramses: for a few months now i'm working on a proof of concept operating system with a new type-based security model…  imagine that:  once a program has loaded, before it executes its first instruction, it's proven not to violate the security model =)
08:41:55 <`ramses> mm_freak: C isn't changing as much as haskell, the compiler just doesn't have to get any new features
08:42:00 <mm_freak> Eelis: you never saw that for compilers either until you met haskell =)
08:42:02 <zxq9> DOes that mean all programs now have to be provable?
08:42:03 <nyc> Microkernels are certainly fraught with subtlety and hardware interaction.
08:42:08 <b52> mm_freak: link?
08:42:16 <Eelis> mm_freak: saw what for compilers? i'm not following
08:42:21 <mm_freak> `ramses: but it does get new features…  GCC has language extensions as well
08:42:34 <mm_freak> b52: none exists at the moment, sorry…  you have to be patient
08:42:40 <M30W> ♥
08:42:44 <`ramses> mm_freak: okay, I can see the advantage of such a feature :)
08:42:45 <nyc> Hoisting drivers and such into userspace doesn't alleviate programming burdens at all.
08:42:52 <Eelis> nyc: but you wouldn't argue that they're anywhere near as complex as monolithic kernels, would you?
08:43:01 <mm_freak> well, i gotta go now, but i'm happy to explain it later =)
08:43:03 <mm_freak> see you
08:43:06 <Eelis> bye mm_freak
08:43:21 <`nand`> mm_freak: yes, that's exactly what I feel is the right approach to operating systems
08:43:22 <M30W> Bye mm_freak who I was about to start a conversation with =(
08:43:23 <Eelis> nyc: it means the kernel gets smaller
08:43:31 <`nand`> static security through type systems
08:43:51 <nyc> Eelis: They are less code only by dint of hoisting what would be within the kernel to userspace, and that at some cost.
08:43:52 <mm_freak> M30W: jabber: ertes@jabber.ccc.de
08:44:03 <M30W> Errm.
08:44:06 <M30W> Jabber :|
08:44:11 <Eelis> nyc: yes, they decompose the system into isolated components. that's a good thing
08:44:25 <Hermit> M30W: bitlbee?
08:44:28 <mm_freak> M30W: i have jabber on my cell =)
08:44:30 <M30W> Hermit: Nope
08:44:31 <`nand`> why jabber and not irc?
08:44:44 <M30W> mm_freak: Why you no have a bouncer for irc on your cell?
08:44:54 <M30W> OR better an irc client
08:44:55 <nyc> Eelis: Layer inversions for performance such as monolithic kernels are quite conventional.
08:44:56 <mm_freak> because IRC sucks on android
08:45:04 <mm_freak> anyway, i'm off now
08:45:05 * M30W has a 4yr old nokia w\ irssi
08:45:06 <Hermit> yaairc seemed fine
08:45:13 <M30W> mm_freak: yaaic is alright
08:45:19 <Hermit> that one
08:45:22 <Hermit> I forgot the name
08:45:29 <`nand`> would weechat/irssi/etc. run on mobile phones?
08:45:35 <`nand`> at least, I see no immediate reason why they wouldn't
08:45:36 <Eelis> nyc: no argument there, they certainly are the most popular. i'm not sure inferring their legitimacy from that is a good idea though ;)
08:45:36 <M30W> Still sucks but it's one of the best FREE clients
08:45:38 <M30W> Stupid java
08:45:39 <nyc> Got to go.
08:45:43 <M30W> android give us haskell >_<
08:45:59 <M30W> Hermit: I'm not sure if I was right :P
08:46:20 <Hermit> M30W: you were, it's yaaic
08:46:40 <`ramses> `nand`: if you jailbreak them, they'll probably not be in those app stores
08:46:54 <M30W> Hermit: My Huewai X1, Upgraded to cynogenmod android 4.1.2; My use for it = MPDroid = Control my music and volume of my desktop wirelessly. :)
08:47:13 <Hermit> M30W: I know ^_^ I use that too
08:47:17 <M30W> :D
08:47:19 <Hermit> mpd ftw <3
08:47:21 <`nand`> `ramses: (assuming one does not waste money on a product you're not allowed to use)
08:47:21 <M30W> Gotta love it
08:47:25 <Hermit> yeah
08:47:47 <M30W> Hermit: withMPD $ MPD.setVolume . (5+) . MPD.stVolume =<< MPD.status
08:48:00 <Hermit> M30W: only issue I have with it is the scrollers accuracy, it slides to the playlist 90% of the times I try to change the volume
08:48:32 <M30W> Hermit: Try to save a playlist; MULTILINE INPUT
08:48:38 <M30W> Crashes the client :P
08:48:42 <`nand`> M30W: yuck, a perfect use case for lenses
08:48:46 <M30W> Doesn't even send as injection :P
08:48:51 <Hermit> pff
08:48:54 <M30W> `nand`: PFtt
08:49:04 <tomoj> ?pl \c r t f -> r . t (c . f)
08:49:04 <lambdabot> flip ((.) . (.) . (.)) . flip (.) . (.)
08:49:17 <`ramses> haha :) way better!
08:49:42 <Hermit> I've been hearing lenses here and there once in a while, actually checked the haddoc and saw some scary type signatures. What's it all about?
08:50:13 <`nand`> Hermit: at the fundamental level, composable getters and setters (and traversals and folds and whatnot)
08:50:25 <tomoj> ?pl \f r t c -> r . t (c . f)
08:50:25 <lambdabot> flip ((.) . (.) . (.)) . flip (.) . flip (.)
08:50:29 <`nand`> Hermit: http://lens.github.com/ <- no scary type signatures required
08:50:40 <M30W> Hermit: a & b = b a -- Useless reordering crap ;)
08:51:07 * M30W expects someone to kill him about.......now; Hey look a lens
08:51:11 <`ramses> M30W: you can make fun of everything that way
08:51:26 <M30W> `ramses: Indeed :P
08:51:41 <`nand`> > (_2 .~ "world") ("hello", 12345) -- Hermit
08:51:42 <lambdabot>   ("hello","world")
08:51:46 <M30W> flip is crazy but pointfree fun :)
08:52:04 <`nand`> > ("hello", 12345) & _2 .~ "world" -- or this, note that (&) = flip ($)
08:52:06 <lambdabot>   ("hello","world")
08:52:07 * Hermit stares at that code line
08:52:34 <`nand`> Hermit: _2 refers to the second field of a tuple; .~ means “set to”
08:52:34 <Hermit> :t (.~)
08:52:36 <lambdabot> Setting s t a b -> b -> s -> t
08:52:40 <M30W> Hermit: They make sense but get annoying :P
08:52:43 <M30W> STAB!
08:52:51 <`ramses> `nand`: fmap (const "hello") ? :)
08:52:51 <M30W> Violens
08:53:00 <`nand`> `ramses: yes, exactly
08:53:11 <`nand`> `ramses: but with an overloaded ‘fmap’
08:53:42 <`ramses> yeah, the fmap one gets really annoying if you want to alter the first component
08:54:27 <`nand`> > (("foo", "bar"),"bat") & _1._2 .~ 12345 -- as claimed, they're composable (with (.))
08:54:29 <lambdabot>   (("foo",12345),"bat")
08:54:38 <`nand`> this sets the second field of the first field
08:54:39 <Hermit> now it's starting to make sense
08:54:56 <`nand`> you can also read out a lens
08:54:57 <M30W> Hermit: Hehe.
08:55:06 <`nand`> > (("foo", "bar"), "bat") ^. _1
08:55:07 <lambdabot>   ("foo","bar")
08:55:09 <`nand`> > (("foo", "bar"), "bat") ^. _1._2
08:55:11 <lambdabot>   "bar"
08:55:21 <Hermit> got it
08:55:37 <Hermit> got to say it's cryptic at first sight, but quite nice
08:55:38 <M30W> Too many lenses
08:55:45 <`nand`> Hermit: the rabbit hole goes much deeper than that :)
08:55:56 <tomoj> ah, (. ((. (.)) . (.))) . (.) . (.) . (.)
08:55:58 * Hermit checks wtf is Setting
08:56:02 <M30W> Hermit: Indeed but it's a HUGE library
08:56:09 <`nand`> > (("foo", "bar"), "bat") & partsOf biplate %~ (reverse :: String -> String)
08:56:10 <lambdabot>   (("tab","rab"),"oof")
08:56:20 <M30W> Hermit: Lens = Setter | Getter
08:56:32 <`nand`> Hermit: ?
08:56:37 <`nand`> err, M30W: ?
08:56:47 <M30W> Or am I thinking of something else
08:57:36 <`nand`> Hermit: ‘Setting’ is just a type alias for some complicated internal type; but the gist of it is that it expects something you can ‘set’; eg. a lens, a setter, a traversal, and some other crazy things
08:58:38 <`nand`> > [1,2,3,4,5] & traverse .~ '!'
08:58:39 <lambdabot>   "!!!!!"
08:58:55 <`nand`> > [1,2,3,4,5] & traverse *~ 3
08:58:55 <Hermit> hmm
08:58:56 <lambdabot>   [3,6,9,12,15]
08:59:13 <`ramses> how is that different from map?
08:59:22 <Hermit> I was about to say that
08:59:25 <`nand`> `ramses: no different in this case
08:59:43 <`ramses> ah, bit more composable then?
08:59:48 <`ramses> s/bit/but
08:59:58 <`nand`> yes; also you can write traversals for things that can't be Functors etc.
09:00:00 <M30W> `ramses: bit/but both valid :)
09:00:29 <`nand`> > (5 :: Word8) & bits %~ not
09:00:30 <M30W> Sun Jan 20 04:00:14 EST 2013
09:00:31 <lambdabot>   250
09:00:33 <`nand`> :t bits
09:00:34 <M30W> Hmmm :|
09:00:35 <lambdabot> (Applicative f, Bits b, Indexable Int k) => k (Bool -> f Bool) (b -> f b)
09:00:54 <`nand`> bits :: Bits b => Traversal' b Bool -- less complicated :)
09:01:49 <`ramses> those types remind me of scala type signatures, trying to be very general but ending up terribly long-winded
09:02:12 <`nand`> `ramses: an unfortunate side effect of “every combinator should work with every lens type”
09:02:34 <Hermit> by the way... how do I get to see the source of an instance in haddoc? Say I'm reading http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/Data-Maybe.html#t%3AMaybe and want to see the source of the Monad Mabye methods. How should I do it?
09:02:39 <`nand`> `ramses: the alternative is to provide every function 2, 3 times; for indexed folds/traversals/whatever or monadic folds/whatever
09:02:41 <`ramses> yeah, like scala's "everything should work for general subclasses"
09:03:43 <`nand`> that's even the ‘old’ bits
09:04:17 <Lethalman> Hermit, click "Source" on the right?
09:05:20 <Hermit> Lethalman: I'm not asking for the source of functions, but the source of methods
09:05:25 <`nand`> Lethalman: sometimes that doesn't take you to the correct source file
09:05:46 <`nand`> Hermit: usually the instance would be defined either in the module where the type is defined, or the module where the class is defined
09:06:16 <`ramses> in ghci you can use :info to see where an instance is defined
09:06:56 <Hermit> `nand`: yeah, I found the sources in the module where the class is defined but still, doesn't haddoc have any kind of facility to go stright to that method implementation?
09:07:21 <`nand`> Hermit: unfortunately not
09:07:38 <Hermit> aww, I suspected it but refused to believe it
09:10:07 <hpaste> unlink pasted “mapLast” at http://hpaste.org/80974
09:10:41 <unlink> Am I missing some generic way to do this *without* explicit recursion?
09:10:55 <`nand`> > [1..10] & _last *~ 2 -- lenses to the rescue again?
09:10:57 <lambdabot>   Not in scope: `_last'
09:10:57 <lambdabot>  Perhaps you meant one of these:
09:10:57 <lambdabot>    `last' (imported ...
09:10:59 <`nand`> Cale, updated!!
09:11:03 <`nand`> update*
09:11:11 <Hermit> unlink: mapButLast fn = map fn . init
09:11:12 <`nand`> > [1..10] & upon last *~ 2 -- hrmph
09:11:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,20]
09:11:26 <`nand`> Hermit: you lose the last element that way
09:11:34 <`ramses> Hermit: init crashes on nil
09:11:45 <Hermit> right...
09:12:07 <Hermit> I didn't read the code thoroughly, my mistake
09:13:26 <`nand`> unlink: not that I know of
09:16:13 <unlink> damn.
09:18:07 <unlink> I have to take something like   [["a", "b", "c"], ["d","e"], ["f","h"]]   and turn it into   ["a", "b", "c,", "d", "e,", "f", "h"]
09:18:22 <Rembane> unlink: concat
09:18:43 <unlink> note the commas after c and e
09:19:03 <Rembane> unlink: Oh. Sorry.
09:19:16 <merijn> concat . map (++",")
09:19:31 <merijn> Wait, not quite
09:20:10 <magistr> give me a books to learn the theory of categories
09:20:21 <unlink> So I invented those two combinators to express it like this: mapButLast (mapLast (++","))
09:20:23 <`nand`> concat . (mapped._last ++~ ",")
09:20:25 <merijn> magistr: Awodey is supposedly the go to place
09:20:29 <`nand`> oh, ++~ doesn't exist; <>~ then
09:20:31 <merijn> @where awodey
09:20:31 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
09:21:31 <`nand`> edwardk: ++~ as an (almost) alias for <>~ ?
09:21:58 <unlink> _last?
09:22:13 <`nand`> oh, there's no "," after h
09:22:17 <`nand`> _init._last then :P
09:22:23 <`nand`> unlink: lens combinators
09:22:38 <unlink> I didn't know there was a _last
09:22:49 <`nand`> it's fairly recent: http://ekmett.github.com/lens/Control-Lens-Cons.html#v:_last
09:22:59 <unlink> ah, that's why.
09:23:38 <`nand`> λ  concat $ [["a","b","c"],["d","e"],["f","h"]] & _init.mapped._last <>~ ","
09:23:40 <`nand`> ["a","b","c,","d","e,","f","h"]
09:24:48 <unlink> (&) is just too cute for me
09:25:46 <osfameron> what does it do?
09:26:37 <`nand`> (&) = flip ($)
09:28:03 <osfameron> ah
09:28:56 * hackagebot highlighting-kate 0.5.3.5 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3.5 (JohnMacFarlane)
09:38:56 * hackagebot reactive-balsa 0.1 - Programmatically edit MIDI events via ALSA and reactive-banana  http://hackage.haskell.org/package/reactive-balsa-0.1 (HenningThielemann)
09:44:57 <hpaste> SubTrain pasted “Parser” at http://hpaste.org/80978
09:45:48 <SubTrain> hello, can sombody help me with this please? http://hpaste.org/80978
09:46:11 <roadfish> @pl x = x
09:46:11 <lambdabot> x = fix id
09:46:40 <roadfish> @pl x z = putStr (z ++ "\n")
09:46:40 <lambdabot> x = putStr . (++ "\n")
09:48:22 <SubTrain> no one?
09:49:22 <Hafydd> @pl \x -> x
09:49:22 <lambdabot> id
09:51:49 <skuggi> SubTrain: you're probably more likely to get help if you actually ask a question.
09:58:39 <chrisdone> runRWS :: RWS r w s a -> r -> s -> (a, s, w) -- why is are w and s's order swapped in the return value?
09:59:10 <chrisdone> also a. the whole thing is reversed. what's the reason?
09:59:36 <SubTrain> @skuggi ok then: my problem I want to biuld a parser that turns strings into expressions and I added some examples how it should work I read about parserconstruction but I still don't get it completely
09:59:36 <lambdabot> Unknown command, try @list
09:59:53 <geekosaur> :t state
09:59:54 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
10:00:02 <SubTrain> skuggi ok then: my problem I want to biuld a parser that turns strings into expressions and I added some examples how it should work I read about parserconstruction but I still don't get it completely
10:00:04 <geekosaur> hm, odd
10:00:35 <chrisdone> meh
10:00:45 <burbul> @hoogle (a -> m c) -> (b -> m c) -> Either a b -> m c
10:00:45 <lambdabot> No results found
10:00:45 <jmcarthur> SubTrain: that is still not a question
10:00:55 <copumpkin> :t either
10:00:56 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
10:01:03 <copumpkin> burbul: ^
10:01:06 <Eduard_Munteanu> @unmtl ReaderT r (WriterT w (StateT s)) a
10:01:06 <lambdabot> Plugin `unmtl' failed with: `StateT s (a, w)' is not applied to enough arguments.
10:01:14 <burbul> yes, sorry, was being stupid
10:01:19 <Eduard_Munteanu> @unmtl ReaderT r (WriterT w (State s)) a
10:01:19 <lambdabot> r -> s -> (a, w, s)
10:01:37 <SubTrain> ok, can somebody explain to me how I schould begin to boult the structure of this parser?
10:01:43 <jmcarthur> SubTrain: http://book.realworldhaskell.org/read/using-parsec.html
10:03:57 <frerich_> Is there a static code analysis tool for Haskell programs which can help recognizing race conditions between threads?
10:04:43 <Eduard_Munteanu> How am I supposed to get a Value for yaml's parseJSON in the first place?
10:04:48 <monochrom> I think there isn't
10:05:08 <Eduard_Munteanu> Value is an instance of IsString, but that seems an awful alternative to Read.
10:05:24 <Eduard_Munteanu> (unless one feels like using 'spoon' on it)
10:06:11 <Eduard_Munteanu> Or maybe it's total after all? :/
10:06:15 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/yaml/0.8.2/doc/html/Data-Yaml.html
10:06:23 <burbul> is there a standard synonym for
10:06:23 <burbul> a f g = either (liftM Left . f) (liftM Right . g)
10:07:11 <fmap> @ty \f g -> either (liftM Left . f) (liftM Right . g)
10:07:12 <lambdabot> Monad m => (a -> m a1) -> (b -> m b1) -> Either a b -> m (Either a1 b1)
10:13:57 * hackagebot reactive-balsa 0.1.1 - Programmatically edit MIDI events via ALSA and reactive-banana  http://hackage.haskell.org/package/reactive-balsa-0.1.1 (HenningThielemann)
10:16:31 <fmap> burbul: see bimapM here: http://hackage.haskell.org/packages/archive/bifunctors/3.0/doc/html/Data-Bitraversable.html
10:18:41 <fmap> don't know if bifunctors is standard enough for you though
10:21:23 <Hermit> how about defining a Monad or Functor instance for Either with a hardcoded type
10:22:06 <Hermit> burbul: ^
10:23:40 <Hermit> it wouldn't be that nice but it would work just fine... I guess...
10:25:54 <Hermit> and you can generalize it just enough with a typeclass restriction... something like  instance Num a => Functor (Either a) where...
10:26:22 <Hermit> burbul: would that work for your case?
10:33:00 <neutrino_> lol i've been browsing some early 90s page on tube amps on web.archive.org and saw that the author had an email address @top.monad.net
10:35:12 <Eduard_Munteanu> Who knows, maybe Moggi was rocking back then. :)
10:35:28 <neutrino_> what's moggi, ed?
10:35:28 <Hermit> monad.net, not what any haskell programmer would expect...
10:35:47 <Eduard_Munteanu> neutrino_: the author of the first monad "tutorial" :D
10:36:09 <burbul> Hermit: not sure, but don't worry -- the reason I was asking was that there might have been some clever and more compact way to say the thing using functions/operators I didn't know about, and one learns a lot by finding out such things
10:36:17 <neutrino_> really?
10:36:18 <neutrino_> was it bad?
10:36:19 <Eduard_Munteanu> neutrino_: well, he wrote the first paper on applying monads to FP.
10:37:01 <burbul> If I have a do block in the [] monad, I can write
10:37:07 <burbul> val <- [1,2,3,4]
10:37:15 <sm> g'day all, what regular expressions library would you recommend that's cross platform, robust, and has a full complement of extended regexp features ?
10:37:16 <burbul> To nondeterministically pick a value
10:37:46 <Hermit> burbul: so?
10:37:49 <Eduard_Munteanu> sm: I'd probably look at whatever's in the Haskell Platform first.
10:37:51 <burbul> If I have a do block in the LogicT M monad (where M is some random monad), how do
10:37:59 <burbul> I do the corresponding thing?
10:38:36 <dmwit> ?hoogle Alternative f => [a] -> f a
10:38:36 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
10:38:36 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
10:38:36 <lambdabot> Test.QuickCheck.Gen elements :: [a] -> Gen a
10:39:50 <burbul> Is that using
10:39:51 <burbul> Applicative (LogicT f) => Alternative (LogicT f)
10:39:52 <burbul> ?
10:39:56 <dmwit> :t msum
10:39:57 <lambdabot> MonadPlus m => [m a] -> m a
10:40:07 <Lethalman> burbul, ListT?
10:40:10 <dmwit> :t asum . map return $ [1,2,3,4]
10:40:11 <lambdabot>     Not in scope: `asum'
10:40:11 <lambdabot>     Perhaps you meant one of these:
10:40:11 <lambdabot>       `Data.Foldable.asum' (imported from Data.Foldable),
10:40:19 <dmwit> :t Data.Foldable.asum . map return $ [1,2,3,4]
10:40:20 <lambdabot> (Monad f, Num a, Alternative f) => f a
10:40:28 <dmwit> :t Data.Foldable.msum . map return $ [1,2,3,4]
10:40:30 <lambdabot> (Num a, MonadPlus m) => m a
10:40:30 <dmwit> uh
10:40:36 <burbul> Lethalman, see http://stackoverflow.com/questions/14125207/difference-between-haskell-listt-logict-and-choicet
10:40:39 <dmwit> So, yeah, either of those would work.
10:40:44 <burbul> thank you!
10:41:11 <Lethalman> burbul, thanks
10:41:23 <sm> Eduard_Munteanu: thanks, good idea. That seems to be regex-compat + regex-posix + regex-base. IIRC those lacked some of the familiar regexp features, but time to try them again
10:41:40 <dmwit> burbul: For shorter lists, you can just use (<|>), of course.
10:48:12 <burbul> :t Data.Foldable.msum . map return
10:48:13 <lambdabot> MonadPlus m => [a] -> m a
10:49:00 <JCaesar> Hey. I have a function that is tied to Eq a. I can implement it more efficiently with (Hashable a, Ord a), but I need to keep it functioning with Eq a. Naming the two definitions differently is not an option. Is there a way to do this?
10:49:48 <sm> thank god for regex-compat, because 5 years into haskell I still have no idea how to use regex-base or regex-posix :)
10:50:11 <sm> I seem to remember there's some way to use operators like =~
10:50:25 <JCaesar> I think what I want may be doable by deffering type errors to runtime, but I'd rather not use unsafePerformIO. ;)
10:53:40 <beaky> what design patterns are there by default in haskell?
10:56:23 <sm> regex-compat's match functions die if you give them a malformed regexp. What is a safe (total) alternative  ?
10:56:50 <Taneb> parsec?
10:57:11 <sm> I need regexps, they are part of the ui
10:57:29 <hpaste> npl pasted “why does memory explode?” at http://hpaste.org/80979
11:00:31 <sm> I guess I should use the "Medium level API functions" in regex-posix
11:04:03 <monochrom> memory explodes because of overheat
11:04:31 <monochrom> "listOfSentencesToBestranslated" is too long :)
11:04:52 <sm> how do I combine CompOptions ("A bitmapped CInt containing options for compilation of regular expressions.", http://hackage.haskell.org/packages/archive/regex-posix/0.95.2/doc/html/Text-Regex-Posix-String.html) ?
11:05:19 <npl> monochrom: :P
11:05:36 <npl> monochrom: I don't know where the overheat is, if translated [s6] it works
11:05:43 <geekosaur> Data.Nits..|. ?
11:05:46 <geekosaur> er
11:05:49 <geekosaur> Data.Bits..|. ?
11:06:11 <monochrom> I am just joking about overheat. batteries are the ones that overheat and explode
11:06:16 <sm> ack wait, this api is in IO.. that's not what I want
11:06:35 <npl> ok, I get it
11:07:51 <sm> this module also says Portability: non-portable (regex-base needs MPTC+FD). But te HP uses it. I'm confused
11:08:59 <geekosaur> HP doesn't stick to haskell98/haskell2010
11:09:11 <Eduard_Munteanu> sm: well, MPTCs and FDs aren't much of an issue, considering GHC is pretty much the only sane choice.
11:09:11 <geekosaur> mptc+fd is standard enough
11:10:12 <sm> Eduard_Munteanu: oh I see, those are language extensions - no problem for me then, I just want it to build on windows
11:19:57 <HugoDaniel> hi
11:20:42 <HugoDaniel> im planing to develop a simple xmpp server in haskell, is anyone interested in joining forces ?
11:31:31 <burbul> @unmtl (StateT s) [] a
11:31:31 <lambdabot> s -> [(a, s)]
11:31:44 <dmwit> Does attoparse have a way to "group together" several parsers, so they either all succeed together or all fail together?
11:32:15 <dmwit> e.g. is there some operation "op" such that 'op (string "A") (string "B") = string "AB"'?
11:32:25 <burbul> If I'm working in the  monad I just mentioned, i.e. (StateT s) [] a,
11:32:39 <Ralith> dmwit: try and >>?
11:32:41 <burbul> and I chain the following in a do block:
11:32:47 <Ralith> does attoparsec have try?
11:32:48 <dmwit> Ralith: Don't guess, please.
11:32:50 <burbul> 1. a modification  of state
11:32:56 <burbul> 2. a nondeterministic action
11:33:03 <Ralith> dmwit: how does that no tdo what you want?
11:33:05 <dmwit> (Yes, it has try = id.)
11:33:23 <burbul> And then I run the thing on a state s_0 to get a [(a, s)] out
11:33:39 <burbul> Is the modification of state computed once, or many times?
11:33:46 <dmwit> Ralith: string "A" >> string "B" will commit as soon as it sees an 'A', where as string "AB" does not commit until it also sees a 'B'.
11:34:30 <Ralith> why's it got try=id then? o.O
11:34:33 <burbul> I think it will be once, but I just wanted to check before I do something potentially very inefficient...
11:34:38 <dmwit> burbul: once
11:34:41 <burbul> thank you
11:35:09 <dmwit> Ralith: Because it always backtracks. But once it commits, it's committed.
11:35:31 <Ralith> okay clearly I have no idea how attoparsec works
11:35:38 <dmwit> (This is a bit subtle, I know. It bit me at least twice now.)
11:36:08 <dmwit> Ralith: Compare string "AB" in attoparsec and string "AB" in parsec: in attoparsec, it commits only when it sees both 'A' and 'B', whereas in parsec it commits as soon as it sees 'A'.
11:36:25 <Ralith> ah, that sounds nice
11:36:27 <dmwit> To mitigate this, parsec gives you "try" which asks a big parser not to commit (ever).
11:36:38 <beyeran> Hi! I've got a csv-file looking link "\"foo\", 1.2, 2.3" and I want to parse it to a data structure like [(String, [Double])]. What is the most convenient way to do this?
11:37:12 <dmwit> attoparsec claims it doesn't need this because you can make big parsers that don't commit (until they do) by offering more things as primitives. But I don't see how to make the combinators act "as if they were a primitive" so to speak, and I'm wondering if it's possible at all.
11:38:48 <dmwit> Okay, having said that out loud, here's a crisper definition. By default, Parsec commits as soon as a parser accepts any token, and attoparsec commits as soon as any primitive parser succeeds.
11:39:14 <Ralith> dmwit: I think you want takeWith
11:39:23 <Ralith> -- | Consume @n@ bytes of input, but succeed only if the predicate
11:39:26 <Ralith> -- returns 'True'.
11:39:39 <dmwit> Parsec offers "try" to delay a commit until more than one token is taken; what does attoparsec offer?
11:39:46 <ion> And StateT [i] [] o never commits. :-P
11:40:01 <dmwit> ion: Right, and there are inefficient parsers, too. ;-)
11:41:04 <dmwit> Ralith: Where do you see takeWith?
11:41:29 <Ralith> dmwit: hm, it appears to be unexported
11:41:57 <Ralith> dmwit: try takeTill instead
11:42:19 <Ralith> and takeTill, and etc
11:42:26 <dmwit> eh?
11:42:59 <dmwit> takeTill doesn't really look related to me. I don't want a word-by-word operation, I want a way to combine two parsers that will backtrack if one of them fails.
11:43:08 <dmwit> ...fails anywhere, not just at the first primitive.
11:43:38 <Ralith> oh, you're specifically looking for a combinator, not a way to build other 'primitive' parsers?
11:43:58 <dmwit> I'm not sure I see the difference.
11:43:58 * hackagebot arbtt 0.7 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.7 (JoachimBreitner)
11:44:31 <dmwit> Well, anyway, takeTill is, indeed, another way to build a new primitive parser, but not flexible enough for me.
11:44:44 <Ralith> yeah I see that now
11:46:32 <dmwit> ah well
11:46:45 * dmwit refactors
11:47:30 <saeidw> Is virthualevn a "standard" kind of thing?
11:47:45 <saeidw> *virthualenv
11:48:52 <burbul> @mtl Library -> s -> [(a, s)]
11:48:52 <lambdabot> Maybe you meant: ft map msg pl unmtl url
11:48:55 <applicative> " "standard" "?
11:49:05 <lispy> hello
11:49:20 <burbul> @unmtl (StateT s) ListT (Reader Library) a
11:49:20 <lambdabot> Plugin `unmtl' failed with: `ListT (Reader Library, s)' is not applied to enough arguments.
11:49:28 <saeidw> applicative, I mean is it a common practice to use it?
11:49:44 <saeidw> I'm still not fully familiar with the entire ecosystem
11:49:55 <burbul> @unmtl (StateT s) ListT (Reader r) a
11:49:55 <lambdabot> Plugin `unmtl' failed with: `ListT (Reader r, s)' is not applied to enough arguments.
11:50:04 <burbul> @unmtl (StateT s) (ListT (Reader r)) a
11:50:04 <lambdabot> s -> r -> [(a, s)]
11:50:18 <burbul> Why isn't that
11:50:24 <burbul> r -> s -> [(a, s)]
11:50:24 <burbul> ?
11:51:15 <merijn> burbul: Because StateT is the outer wrapper?
11:51:35 <burbul> I'm reading it right to left in the order reader-list-state
11:51:40 <burbul> So I would have thought reader was the outermost one
11:51:47 <burbul> I'm not that used to monad stacks!
11:51:58 <merijn> burbul: Reader is the innermost one...
11:52:03 <merijn> Why would it be the outermost?
11:52:19 <merijn> It's StateT taking ListT as a monad and ListT taking Reader as an inner monad
11:52:20 <Eduard_Munteanu> @unmtl ListT (Reader r) a
11:52:20 <lambdabot> r -> [a]
11:52:27 <burbul> Well, StateT ListT Identity  means
11:52:35 <applicative> saeidw: I wouldn't say standard.  I think hsenv was supposed to be an improved version https://github.com/Paczesiowa/hsenv/network
11:52:38 <burbul>  a list of stateful operations
11:52:42 <burbul> Rather than a stateful nondeterministic operation
11:52:43 <dmwit> Even better question: what's the difference between r -> s -> [(a,s)] and s -> r -> [(a,s)] that makes you care?
11:52:53 <burbul> Nothing that makes me care, just trying to figure out how this works
11:53:17 <applicative> saeidw: or rather http://hackage.haskell.org/package/hsenv
11:53:19 <burbul> Don't worry, it's not important
11:53:36 <saeidw> applicative, thanks, I'll check that out. Cabal is kind of painful to use
11:53:50 <dmwit> burbul: Wait, StateT (ListT Identity) isn't a list of stateful operations.
11:53:57 <dmwit> ?unmtl StateT (ListT Identity) a
11:53:57 <lambdabot> Plugin `unmtl' failed with: `StateT (ListT Identity) a' is not applied to enough arguments.
11:54:01 <dmwit> ?unmtl StateT s (ListT Identity) a
11:54:02 <lambdabot> s -> [(a, s)]
11:54:04 <saeidw> "warning: installing this will DESTROY EVERYTHING YOU'VE EVER BUILT!"
11:54:12 <dmwit> It's a single stateful operation that returns a list.
11:54:24 <applicative> saeidw: It takes getting used to, I think. It has been  gaining a number of important powers recently.
11:54:25 <dmwit> (of outputs and new states)
11:54:28 <burbul> My point was that the state is inside the list in the sense that each
11:54:33 <burbul> Element in the list can be associated with a different state
11:54:51 <burbul> So the statefulness is inside the nondeterminism
11:54:55 <dmwit> And each index to the reader can be associated with a different state.
11:54:56 <saeidw> Yeah, from googling around I noticed a bunch of efforts to improve it
11:55:05 <dmwit> So the statefulness is inside the reader-ness.
11:55:33 <dmwit> (Note that this is a very different definition of "innermost" and "outermost" than most people use.)
11:55:39 <burbul> I need to think about this more -- but thanks
11:55:47 <applicative> saeidw: I wondering; I have a feeling there are a lot of complaints that are now out of date. Not that I am trying to declare it a miracle or anything.
11:55:51 <dmwit> Well, if something doesn't make sense, you should ask a question.
11:55:54 <dmwit> We do want to help.
11:56:02 <burbul> you are *incredibly* helpful here!!
11:56:11 * applicative declare it a miracly, actually, but a limited one....
11:57:22 <saeidw> Actually, I think my problems with it have mostly been due to packages that require unixy-ness
11:57:40 <saeidw> and I'm just shifting the blame onto the poor package manager :)
11:58:02 <dktn> preflex: list
11:58:03 <preflex>  Botsnack: [botsnack]; Cdecl: [cdecl]; 8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; PlokiRE: [re]; Seen: [seen]; Sixst: [6st]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; XSeen: [xseen];
11:58:04 <preflex>  ZCode: [zdec, zenc]
11:58:33 <applicative> saeidw: where C bindings are involved there can be a lot of unpleasantness
12:03:52 <applicative> well, it seems you really don't need to install all of xcode to get the ghc et cetera on os x anymore.
12:07:04 <saeidw> applicative, via homebrew I guess?
12:07:41 <applicative> saeidw: no I was just using the binary for ghc 7.6 locally installed
12:08:01 <saeidw> that works too :p
12:08:09 <applicative> its just that apple now has an independent way of giving us a gcc and whatever else.
12:10:58 * applicative wonder is homebrew is doing that
12:11:56 <hpaste> LambdaDusk pasted “template-haskell-error.txt” at http://hpaste.org/80980
12:12:29 <LambdaDusk> does anyone know the error above?
12:13:32 <bergmark> LambdaDusk: do you have several versions of template haskell installed?
12:13:35 <Hermit> LambdaDusk: try to clean the .hi and .o files
12:15:25 <LambdaDusk> Hermit: which ones?
12:16:52 <bergmark> also i've had problems with template-haskell 2.8 on ghc 7.4
12:18:38 <leventov> Anyone knows, is there a way in ghc to specialize the function defenition if arguments conform additional constraints? Ex. test :: Eq a => a -> Bool; test _ = True; test_spec :: Ord a => a -> Bool; test_spec _ = False;
12:19:48 <bergmark> do you mean (Eq a, Ord a) => a -> Bool ?
12:20:22 <leventov> bergmark: with different bodies
12:21:46 <applicative> LambdaDusk: does ghc-pkg list template-haskell show more than one version?  It seems to have loaded it already, but then to be loading it again when it breaks
12:21:52 <bergmark> oh i think i get what you mean
12:22:25 <fmap> bergmark: template-haskell is tied to ghc, so having problems with different versions is likely ;)
12:22:30 <bergmark> leventov: no, you need two functions then
12:23:19 <bergmark> leventov: from the place you pick which function to call you will always know the constraints, so you know which function you may call
12:24:22 <applicative> LambdaDusk: yes, there is clearly something broken.  For example, the build involved two versions of containers.
12:24:30 <bergmark> also the typechecker knows this if you don't ;)
12:24:48 <LambdaDusk> applicative: It shows me 2.7 and 2.8 instaled
12:25:24 <bergmark> ghc-pkg unregister template-haskell-2.8.0.0
12:25:55 <LambdaDusk> bergmark: Tells me that would break QuickCheck
12:26:02 <applicative> LambdaDusk: does 'ghc-pkg check' or ghc-pkg.exe check show something wrong
12:26:10 <bergmark> then you should rebuild quickcheck using template-haskell 2.7 instead
12:26:46 <LambdaDusk> bergmark, applicative: I think I will just return to my dev machine then... I thought I could equip my gaming-windows in a way I can work on sudden ideas
12:27:18 <applicative> LambdaDusk: probably you should unregister a lot of stuff and reinstall, alas
12:27:44 <LambdaDusk> Would a complete re-install of the haskell platform solve it? I get a lot of errors on ghc-pkg check
12:27:46 <bergmark> yeah, at some point something with bad dependencies was installed
12:27:48 <applicative> LambdaDusk: is this ghc-7.4?
12:27:58 <bergmark> LambdaDusk: you can just wipe your .ghc folder
12:28:43 <LambdaDusk> applicative: There is no haskell platform for ghc 7.6 yet
12:28:43 <bergmark> it said 7.4 in his paste :)
12:28:47 <bergmark> also that
12:29:10 <applicative> oh did it.
12:30:24 <bergmark> LambdaDusk: i enjoy tracking down these issues, but it's probably faster to just wipe .ghc
12:30:52 <LambdaDusk> I just completely reinstall the platform...
12:30:56 <applicative> the trouble is quickcheck and containers and of template haskell are already in the haskell platform and globally installed or whatever.  you don't want a conflicting locall installation of any of the
12:30:58 <applicative> them
12:31:21 <LambdaDusk> and the other is that my antivirus really dislikes the setup.exe files on a cabal install
12:31:28 * applicative though his typing would improve with this new keyboard....
12:32:44 <applicative> I guess the new haskell platform will overwrite  .ghc or its equivalent.
12:33:32 <LambdaDusk> i wiped it too, just in case
12:33:48 <applicative> you might to do well to name all the main packages you want to use at once ... cabal install yesod bytestring-blah-extras foo-ripple pony gutenberg-fibonacci
12:34:09 <LambdaDusk> pony is always installed on my system
12:34:33 <applicative> same here, it's my 'all is well' demo cabal-installation....
12:34:40 <LambdaDusk> I will install nothing but the deps of my current project
12:36:12 * applicative can't figure out what the devil homebrew is doing under the headings of ghc.rb and haskell-platform.rb
12:37:14 <applicative> LambdaDusk: I meant to finish the probably obvious thought, that if you make one command with many packages, cabal-install can try to find a single set of dependencies for all.
12:37:31 <applicative> i'm just worried it's going to reinstall things like containers, bytestring etc
12:38:45 <LambdaDusk> the new version of quickcheck came with happy and alex, I don't actually need those
12:39:43 <applicative> they don't matter, they are executables
12:42:24 <applicative> wait, I get it; homebrew finesses the need to require a gcc for ghc, by the fact that installation of homebrew now requires the relevant 'command line tools' including gcc
12:44:03 <ericmj> When I build with cabal some functions aren't exported from base modules because they are inside a preprocessor guard __GLASGOW_HASKELL__. How do I fix?
12:45:13 <LambdaDusk> ericmj: Check that you have the correct version of GHC installed?
12:45:54 <ericmj> LambdaDusk: I have 7.4.2 from Haskell Platform
12:46:40 <applicative> ericmj: what are you building?
12:47:01 <ericmj> just a project of my own
12:47:37 <applicative> oh i see; you put in the preprocessor directives>
12:47:39 <applicative> ?
12:47:39 <LambdaDusk> ericmj: Then just remove the preprocessor guards?
12:48:08 <ericmj> no. the preprocessor guards are in base files.
12:48:19 <ericmj> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Concurrent.html
12:48:34 <ericmj> I can't get access to forkFinally from my code
12:48:43 <applicative> ericmj: you want functions in base that are not exported if you are using ghc?
12:48:50 <applicative> ah
12:49:00 <ericmj> they should be exported using GHC?
12:49:21 <fmap> isn't forkFinally only in ghc-7.6 base?
12:49:40 <LambdaDusk> ericmj: Which version of base do you have installed?
12:49:42 <mysticc> Is there any similar function to: g n = foldM (\a _ -> f a) b [1..n] .. I don't like using lambda here
12:50:00 <ericmj> how do I check which package version I have?
12:50:10 <applicative> ghc-pkg list
12:50:15 <LambdaDusk> ghc-pkg list | grep base
12:50:18 <applicative> ghc-pkg list base
12:50:18 <simpson> @pl g a _ = f a
12:50:19 <lambdabot> g = const . f
12:50:29 <simpson> mysticc: I don't see the problem, though.
12:50:35 <applicative> various alternatives...
12:50:36 <bergmark> mysticc: i'd probably use the lambda there
12:50:52 <mysticc> ok
12:51:11 <applicative> ericmj: I see it's a fairly new function, http://www.haskell.org/pipermail/cvs-libraries/2012-June/015662.html
12:51:40 <ericmj> ok, i have base 4.5.1.0
12:51:58 <ericmj> can i use base 4.6 with GHC 7.4.2?
12:52:21 <LambdaDusk> ericmj: I wouldn't advise ut
12:52:42 <fmap> ericmj: no
12:52:45 <LambdaDusk> ericmj: But 4.5.1.0 doesn't have forkFinally, do you need it desparetely?
12:53:29 <hpaste> applicative pasted “forkFinally” at http://hpaste.org/80983
12:53:32 <ericmj> no, not really. i guess i can code something similar myself
12:53:41 <ericmj> oh thanks
12:53:48 <applicative> ericmj: does this compile ^^^
12:54:47 <ericmj> it does compile, thanks
12:55:15 <npl> I have code like this: "do result <- mapM producesStringsFunction data; mapM_ putStrLn result". each production of a String in "result" takes 30 seconds, and I want to print Strings to the terminal as soon as they are produced. but with "mapM_ putStrLn" it waits until the production of all Strings is finished; what can I do?
12:57:11 <Ralith> npl: have you tried mapM_ (producesStringsFunction >>= putStrLn) data?
12:57:28 <LambdaDusk> npl: mapM (\d -> do { x <- producesStringsFunction d; putStrLn x; return x }) data
12:58:00 <geri> what is cuda used for?
12:58:46 <LambdaDusk> geri: https://developer.nvidia.com/what-cuda
12:58:54 <geri> parallel programming?
12:59:01 <geri> ah i heard of it
12:59:20 <LambdaDusk> geri: It's some platform to put your code onto an nvidia gpu
12:59:29 <geri> just nvidia?
12:59:39 <simpson> Yep.
12:59:43 <LambdaDusk> geri: Yes.
12:59:49 <simpson> CUDA's not exactly what one would call "open."
12:59:56 <geri> why is it in c and not c++?
13:00:06 <LambdaDusk> geri: You might want to check out OpenCL
13:00:26 <LambdaDusk> geri: Because C is easier to compile down to machine code?
13:01:34 <LambdaDusk> geri: GPU tasks are usually heavy tasks that involve a lot of parallel float operations - the GPU has hundreds of cores that are optimised for floating point operations
13:01:43 <npl> LambdaDusk: Ralith: thanks!
13:03:21 <Ralith> npl: if you rewrote producesStringsFunction to not have side-effects, your first approach would probably have worked as well.
13:08:31 <fragamus> so…   i have been reading up on applicative functors and I have a question…      given that a lot of pain has been taken to create a common interface to them, are there any interesting examples of polymorphic code that adds value across the board
13:13:28 <bergmark> fragamus: aren't they an example of that themselves? i use it every day
13:14:06 <fragamus> yes
13:14:18 <fragamus> <*> is polymorphic
13:15:54 <fragamus> but what I'm curious about is that since there is a common interface to them, could not someone write an algorithm that did something useful (and non-trivial) that applied to them
13:16:42 <fragamus> some kind of algorithm that adds functionality in an orthogonal sense
13:16:43 <simpson> fragamus: Of course. I think you're just looking for something that meets "useful and non-trivial" for *you*.
13:16:54 <simpson> fragamus: Have you seen an applicative parser yet?
13:16:58 <applicative> fragamus: https://github.com/ekmett/parsers/blob/master/src/Text/Parser/Combinators.hs here is a demo of the power of applciative + alternativer
13:17:11 <fragamus> okie
13:17:13 <applicative> fragamus: I mean, with nothing else...
13:35:39 <hiptobecubic> :t (<|>)
13:35:40 <lambdabot> Alternative f => f a -> f a -> f a
13:45:07 <heatsink> I've been wondering about a particular optimization in GHC
13:47:46 <shachaf> Wondering is a lot of fun.
13:48:12 <hpaste> heatsink pasted “Global constant propagation in GHC” at http://hpaste.org/80985
13:49:37 <heatsink> It seems like the inliner and case-of-constructor and related transformations in GHC perform the analogue of dominator-tree constant propagation
13:49:48 <heatsink> But there's nothing like global constant propagation.
13:50:25 <heatsink> Even though 'x' is always zero, and it's passed through local variables and direct calls, it doesn't get replaced by a constant.
13:50:52 <heatsink> or by a global variable reference in this case, since GHC hoists constant Integers to the top level
13:51:15 <ku_> I can't seem to understand what Applicative is :(
13:51:35 <fmap> heatsink: you mean x is always 7?
13:51:36 <shachaf> heatsink: What would it mean for it to get replaced by a constant here?
13:52:04 <heatsink> Oh, yes.  I should have fixed that to z = 7
13:52:33 <ku_> at least not from the info in the Typeclassopedia
13:53:03 <heatsink> shachaf, it would replace "x + y" with "0 + y" and possibly do further optimizations like simplifying that to "y"
13:53:23 <ku_> trying the section in LYAH now
13:53:24 <shachaf> Ah, I see what you mean now. I misread it.
13:54:11 <heatsink> ku_, it helps to think of Applicative as a restricted form of Monad
13:54:11 <ion> ku: This probably won’t be very helpful if you’re not familiar with parsing already, but i happened to write about applicatives in the context of parsing recently: http://www.reddit.com/r/haskell/comments/16kf0j/parsing_markdown_with_parsec_how_pandoc_does_it/c7x9v3j?context=1
13:54:22 * shachaf notes that GHC would generate much better there if you used Int.
13:54:36 <ku_> ion: thanks, I'll take a look
13:54:41 <shachaf> Not that that's relevant here because presumably you're asking about the optimization in general.
13:54:42 <heatsink> Yes, shachaf, but that seems to be because it inlines 'k'
13:54:55 <ku_> heatsink: hmm, thanks, but I don't have such a profound understanding of monads either
13:55:55 <heatsink> Right.  I'm interested in the more general form of this pattern where some of a continuation's arguments are actually constant.
13:56:12 <heatsink> ...and the continuation is always directly called.
13:57:21 <ku_> heatsink: is Applicative basically just a functor that can take parameters?
13:58:30 <heatsink> ku_, it's more than that.  I think that it was introduced in a paper about parsing
13:58:51 <ku_> heatsink: too bad I don't know about parsing :(
13:59:23 <ion> > (+100) <$> [1..5]
13:59:24 <lambdabot>   [101,102,103,104,105]
13:59:30 <ion> > [(+100)] <*> [1..5]
13:59:32 <lambdabot>   [101,102,103,104,105]
13:59:48 <ku_> my brain just exploded
14:00:21 <ku_> Isn't <$> just fmap?
14:00:37 <ku_> > fmap (+100) [1..5]
14:00:38 <lambdabot>   [101,102,103,104,105]
14:00:46 <hiptobecubic> ku_, yes
14:01:10 <ion> Yes. (<$>) applies a function to every element of the list, the value in a Just, the result value of a parser, the result value of an IO action etc.
14:01:17 <heatsink> Yeah, here http://www.cse.chalmers.se/~bernardy/FunctionalIncrementalParsing.pdf
14:01:18 <ku_> so Applicative is basically a functor you can apply to other functors?
14:01:39 <ku_> heatsink: thanks, but that might be harder to understand since I haven't learned about parsing
14:02:04 <shachaf> ku_: Maybe think of this:
14:02:08 <ion> With (<*>) the function will be in or come from e.g. a list/Maybe/Parser/IO.
14:02:15 <Ste1891> Hi.  In a piecewise function definition, is it possible to define a let binding that applies to all of the equations; i.e. without having to write "let ... =" at the top of each one?
14:02:17 <shachaf> Functor gives you lift1 :: (a -> b) -> f a -> f b
14:02:19 <ion> > (+100) <$> Just 5
14:02:21 <lambdabot>   Just 105
14:02:23 <ion> > Just (+100) <*> Just 5
14:02:24 <lambdabot>   Just 105
14:02:31 <shachaf> Applicative adds to that: lift0 :: a -> f a; lift 2 :: (a -> b -> c) -> f a -> f b -> fc
14:02:31 <ion> > Nothing <*> Just 5
14:02:32 <lambdabot>   Nothing
14:02:34 <ion> > Just (+100) <*> Nothing
14:02:36 <lambdabot>   Nothing
14:02:59 <ku_> hmm, I think I understood a bit
14:03:01 <hiptobecubic> what is lift0? pure?
14:03:06 <hiptobecubic> yes, must be
14:03:06 <ion> yeah
14:03:09 <ku_> but why use Applicative instead of a monad?
14:03:09 <shachaf> Ste1891: Try using "where".
14:03:30 <ion> It’s less powerful but more general than Monad. Whenever you don’t need the full power Monad provides.
14:03:33 <heatsink> Ste1891, a 'where' clause is in scope over all guards: foo x | f x = y | g x = y where y = ...
14:03:46 <ion> Just like Functor is less powerful but more general than Applicative.
14:03:47 <shachaf> Sometimes Applicative can be more efficient.
14:03:51 <frerich_> In the StackOverflow answer at http://stackoverflow.com/a/1268772/91757 Don Sanders describes a simple producer-consumer system built on a Chan. In a comment to tha answer, Conal seems to hint that there may be a "purely functional solution"  to the problem. Does anybody know what he might have meant?
14:04:02 <Ste1891> OK, thanks.
14:04:31 <ku_> ion: I still don't quite understand what exactly the power of a Monad is
14:04:48 <shachaf> ku_: Then perhaps you should not worry about this so much.
14:04:57 <ku_> shachaf: ?
14:04:58 <shachaf> There's a lot of interesting Haskell that doesn't involve it.
14:04:59 <heatsink> Ste1891, if you're using multiple patterns, then you need to merge the definitions into one.
14:05:36 <conal> ku_: it's monad-ness that's more powerful, not any particular monad.
14:06:13 <conal> ku_: in other words, the Monad class makes more demands on a potential inhabitant (type constructor).
14:06:22 <shachaf> ku_: People tend to get obsessed with "understanding monads!" and "understanding applicative!", maybe because everyone talks about those so much, but there's a lot of Haskell you can learn without worrying about those directly.
14:06:52 <shachaf> Eventually they'll be relatively easy to understand because you'd be familiar with so many concrete examples.
14:07:00 <ku_> shachaf: what else should I learn first then?
14:07:21 <frerich_> conal: Hi there, do you happen to be the same Conal as the StackOverflow Conal (i.e. http://stackoverflow.com/users/127335/conal )?
14:07:45 <shachaf> There is only one Conal (though there are many Elliotts).
14:07:54 <conal> when people want to understand Monad, i always recommend they start with Monoid. then functor & applicative. then Monad is a simple step.
14:08:06 <mauke> kon-el
14:08:23 <conal> frerich_: yep.
14:08:31 <ion> Using concrete instances just like you’d use them if they used ad-hoc operators instead of the Applicative/Monad ones for the same thing should be possible and sooner or later your brain will just figure out the common pattern.
14:08:33 <ku_> conal: that is pretty much the order I tried to learn about them
14:08:38 <Ste1891> heatsink: merge the definitions?  Sorry, could you elaborate a bit?
14:08:53 <conal> ku_: oh, cool. where are you in the process?
14:09:13 <heatsink> Ste1891, I mean to turn let {f Nothing = ...; f (Just x) = ...} into let f mx = case mx of {Nothing -> ...; Just -> ...}
14:09:24 <ku_> conal: I'm not sure, I didn't really understand the use of any of them
14:09:29 <heatsink> So there's only one occurence of the name "f" that you're defining
14:09:45 <frerich_> conal: I recently noticed a comment of yours to an answer Don Sanders gave: http://stackoverflow.com/a/1268772/91757 - in that comment you seem to imply that there is a "purely functional solution" to the producer-consumer problem. That comment is over two years old though, do you remember what you were thinking of?
14:10:07 <ku_> I feel as if I was blind and I was trying to understand the color green :P
14:10:22 <Ste1891> heatsink: Oh, I see.  Thanks for that.
14:10:50 <conal> ku_: ah, okay. i suggest sticking with monoid or functor until it clicks. there's a lot of magical thinking surrounding Monad.
14:11:25 <heatsink> ku_, have you tried defining new instances of any type classes yet?  That's a good way of judging how comfortable you are with them.
14:12:13 <heatsink> If you're not sure how to define, e.g. a Num instance for (Int, Int), then you need to get more familiar with type classes.
14:12:16 <conal> when people say they want to "understand monads", i always suspect the question itself is misleading them. they already understand and work with lots of monads.
14:13:11 <ku_> heatsink: conal I think I understand the theory behind monoids, functors, applicatives and monads, just not sure how they're useful
14:13:37 <conal> and saying "monads" instead of "Monad" might just be using language loosely, but it might not be, since most other languages don't have this sort of abstraction.
14:14:25 <conal> ku_: let's narrow to Monoid. do you mean that you don't know what any monoids are for or that you don't know what the Monoid abstraction itself is for?
14:14:46 <ku_> I've never had trouble understanding supposedly hard concepts like pointers, metaprogramming or decorators, but Haskell is really something else
14:15:10 <ku_> conal: the abstraction
14:15:21 <conal> ku_: have you taken abstract algebra? groups, fields, etc?
14:15:33 <neutrino_> conal: it is my understanding that "trying to understand monads" is a terrible newbie trap
14:15:42 <ku_> conal: just not exactly fresh in my memory
14:16:55 <ion> You learned pointers, metaprogramming and decorators easily after you had already learned enough other things to make the jump small. One probably would have trouble learning about metaprogramming on the first day of studying programming.
14:16:55 <heatsink> > signum $ negate 1 :: Complex Double
14:16:56 <lambdabot>   (-1.0) :+ (-0.0)
14:17:04 <conal> ku_: a abstraction like Monoid lets you write code that applies across different types (addable numbers, sets, strings, etc)
14:17:37 <conal> ku_: you could instead write a bunch of similar code for these types, but we like reuse.
14:18:20 <ku_> conal: I think I understand monoids and functors, but I don't understand the use of applicatives and Monad
14:19:13 <ku_> ion: I see your point
14:20:25 <conal> ku_: Applicative is like Functor but more so. Where Functor lets you apply a single function across a "container" of values, Applicative lets you apply a "container" of functions across a container of values.
14:20:30 <ion> You’ll understand the use of them after having used concrete things like lists, Maybe, IO etc. enough.
14:20:39 <ku_> conal: e.g. Applicative: why not just extract the function?
14:21:14 <conal> ku_: how?
14:21:35 <ku_> conal: e.g. pattern matching
14:21:40 <ku_> why the separate interface?
14:22:03 <heatsink> ku_, that's like asking, why use fmap when you can just write a loop that accesses every element of a data structure?
14:22:13 <ku_> alright
14:22:21 <ion> You can’t just “extract the function” from IO (a -> b)
14:22:21 <ku_> can you give me an example of something that would be better as Applicative than Monad though?
14:22:39 <conal> ku_: the game is to write code that works across different type constructors. so you'd have to "extract the function" in a generic way. a way that wasn't specific to a single type constructor.
14:22:45 <ku_> ion: ah, I actually see how it makes sense in an IO context
14:22:45 <Eduard_Munteanu> ku_: IO is an applicative... but you shouldn't be able to pattern-match on IO
14:22:54 <ion> parseA *> parseB <* parseC runs the three parsers in sequence but only results in the result value of parseB.
14:22:58 <Eduard_Munteanu> (would amount to unsafePerformIO)
14:23:09 <ion> actA *> actB <* actC runs the three IO actions in sequence but only results in the result value of actB.
14:23:24 <ion> getLine *> getLine <* getLine reads three lines of input and results in the middle one.
14:23:31 <ku_> ?
14:23:57 <ion> > (Just 3 *> Just 4 <* Just 5, Nothing *> Just 4 <* Just 5, Just 3 *> Just 4 <* Nothing)
14:23:58 <lambdabot>   (Just 4,Nothing,Nothing)
14:24:23 <conal> ku_: about "would be better as Applicative than Monad", there's *always* and advantage to writing Applicative-generic code than Monad-generic code (code that works for all applicatives rather than for all monads): it's more general.
14:25:18 <ku_> What is the difference between <*, *>, <*>?
14:25:47 <conal> ku_: the first two discard results.
14:25:51 <ion> In hindsight, perhaps ignore <* and *> for now, this will probably just confuse you more. :-P
14:26:05 <shachaf> <*> will also just confuse you.
14:26:10 <shachaf> liftA2 is much simpler.
14:26:22 <ku_> How do I make the jump from theory to practice for more complex stuff?
14:26:32 <startling> ku_: if you don't want to ignore *> and <*, they point to the applicative action whose results you want to keep
14:26:39 <ion> No, start with the practice and worry about the theory later.
14:26:40 <conal> my summary of Functor vs Applicative vs Monad: fmap  :: (a -> b) -> (f a -> f b) ; (<*>) :: f (a -> b) -> (f a -> f b) ; (=<<) :: (a -> m b) -> (m a -> m b)
14:26:42 <dmwit> There's a blog post about having all finite products lying around somewhere in this Applicative stuff.
14:27:07 <dmwit> uh
14:27:10 <dmwit> s/products/zips
14:27:18 <startling> ku_: so getLine is an IO String and putStrLn "somestring" is an IO (). "getLine <* putStrLn "thanks!"" is an IO String
14:27:19 <conal> ku_: the later operations are more powerful than the earlier ones, and so are available for fewer type constructors.
14:27:23 <frerich_> ku_ Maybe making a jump from theory to practice means to practice ;-)
14:27:53 <allsystemsarego> Hi all, if within a console-based game I want to write characters at the terminal at every iteration in the main render loop, what kind of notation do I use for the endless loop, inside of the "main do"?
14:28:05 <dmwit> :t forever
14:28:06 <lambdabot> Monad m => m a -> m b
14:28:28 <allsystemsarego> @src forever
14:28:28 <lambdabot> Source not found.
14:28:36 <ion> forever a = do { a; forever a }
14:28:36 <startling> forever might be a bad idea
14:28:39 <dmwit> forever m = m >> forever m
14:28:54 <ku_> hmm
14:28:57 <dmwit> Yep, it might be.
14:29:01 <dmwit> Then again, it might not be.
14:29:06 <Taneb> :t \a -> fix (\r -> a*> r a)
14:29:07 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = t0 -> b0
14:29:07 <lambdabot>     In the return type of a call of `r'
14:29:07 <lambdabot>     Probable cause: `r' is applied to too many arguments
14:29:12 <startling> allsystemsarego: another thing to do is have "loop = { action <- whatever; if action == quite then return () else loop"
14:29:14 <heatsink> Is this like a text adventure?
14:29:25 <startling> *quit, not quite
14:29:25 <heatsink> Then you may want to use interact
14:29:31 <allsystemsarego> heath, more like pacman
14:29:31 <dmwit> "Would you like to stop? quite"
14:29:35 <Tordek> @pf forever m = m >> forever m
14:29:35 <lambdabot> Maybe you meant: bf pl
14:29:37 <startling> dmwit: heh
14:29:40 <ion> “if a then return () else b” a.k.a. “unless a b”
14:29:43 <Tordek> @pl forever m = m >> forever m
14:29:43 <lambdabot> forever = fix (ap (>>))
14:31:50 <heatsink> If you're doing console-based graphics, rather than text, you probably want to start by investigating ncurses for drawing
14:32:04 <heatsink> Writing the loop will come quite a bit later :)
14:32:48 <allsystemsarego> heatsink, in the Ruby version of the same game, I do a system("clear") and write everything from scratch
14:32:49 <heatsink> *curses
14:33:34 <dmwit> For simple stuff, ncurses may be overkill. Then again, simple stuff has a nasty habit of becoming unsimple.
14:34:00 <heatsink> Alright
14:34:02 <startling> ncurses is pretty annoying.
14:34:11 <dmwit> system("clear") is a pretty funny way to spell your ANSI codes, though =)
14:34:17 <startling> indeed
14:34:38 <`nand`> there's vty and vty-ui for an alternative to ncurses
14:34:39 <lispy> vty?
14:34:45 * lispy was actually trying to agree with `nand` there
14:36:17 <heatsink> So anyway, with the optimization I brought up earlier, I was curious if there's a rationale for why GHC doesn't have an optimization analogous to global constant propagation.
14:36:46 * dmwit looks up global constant propagation
14:36:57 <heatsink> In CFG-based compilers it's a fairly basic thing
14:37:43 <merijn> heatsink: What are you basing the fact that GHC doesn't have that on? (I'm not saying you're wrong, just curious)
14:37:49 <heatsink> dmwit, it's basically knowing that a function parameter 'x' is always a constructor of the form (C e1 e2 ... eN) by looking at all the callers of x
14:38:17 <heatsink> merijn, All the callers of the function, I mean
14:38:21 <dmwit> That sounds like a whole-program optimization.
14:38:23 <heatsink> merijn, http://hpaste.org/80985
14:39:17 <heatsink> It doesn't require whole-program transformation.  It sometimes comes up as a result of the case-of-case transformation.  That's what my paste illustrates.
14:39:30 <merijn> heatsink: Ah, I think the LLVM backend is capable of some optimisations similar to that
14:40:17 <dmwit> Hold on, it's not clear to me that this optimization is actually OK.
14:40:29 <dmwit> If you expected "print $! x" to always print 7, that would be wrong.
14:40:39 <dmwit> (sometimes "x" is an exception, instead)
14:41:08 <dmwit> I wouldn't be surprised if GHC did this kind of thing for unboxed values, though.
14:42:22 <dmwit> (7, if cond then 0 else n) is a different beast from if cond then (7, 0) else (7, n)
14:43:31 <Tordek> t fix
14:43:35 <Tordek> :t fix
14:43:36 <lambdabot> (a -> a) -> a
14:43:53 <Tordek> :source fix
14:44:00 <dmwit> ?src fix
14:44:00 <lambdabot> fix f = let x = f x in x
14:44:06 <heatsink> I thought they're the same as long as evaluation of the tuple and its fields are forced
14:44:12 <dmwit> or: fix f = f (fix f)
14:44:20 <dmwit> (but that doesn't have quite as good sharing)
14:44:21 <Tordek> ah
14:44:27 <Tordek> thanks
14:45:01 <hpaste> OiO pasted “Whats the problem?” at http://hpaste.org/80986
14:45:10 <dmwit> Okay, that's probably true.
14:45:27 <Tordek> what is?
14:45:40 <dmwit> heatsink's comment.
14:46:31 <heatsink> I don't know, OiO.  What is the problem?
14:46:55 <oio> neither
14:47:11 <dmwit> "I do X, expecting Y to happen, but Z happens instead."
14:47:27 <mauke> oio: there is no problem
14:47:30 <`nand`> ^
14:47:30 <mauke> HTH HAND
14:48:08 <oio> hask.hs: Prelude.read: no parse
14:48:28 <oio> As = a | 2..6 = 2..6 | 7..9 = 7..9 | Caras = b..z a hask.hs: Prelude.read: no parse
14:48:39 <mauke> that's because "a" is not a valid Int
14:48:39 <dmwit> "q" is not a number.
14:49:47 <dmwit> What I said is true but irrelevant.
14:49:49 <Tordek> oio: remember that patterns and guard are evaluated in order
14:49:53 <dmwit> I am ashamed.
14:50:10 <`nand`> mauke: I had to look up both of those acronyms. Is that bad?
14:50:23 <oio> > elem (read "1"::Int) [1..10]
14:50:24 <lambdabot>   True
14:50:44 <Tordek> > elem (read "a"::Int) [1..10]
14:50:45 <dmwit> > elem (read "a"::Int) [2..6]
14:50:45 <lambdabot>   *Exception: Prelude.read: no parse
14:50:46 <lambdabot>   can't find file: L.hs
14:50:55 * dmwit high fives Tordek
14:51:03 <Tordek> :P
14:51:08 <oio> ooooooo
14:51:10 * Tordek reciprocates
14:51:11 <oio> ....
14:51:55 <heatsink> I'll make an unboxed version of that example and see what GHC does
14:51:59 <merijn> Isn't ::Int kinda redundant there?
14:52:07 <merijn> > eleme (read "1") [1..10]
14:52:08 <lambdabot>   Not in scope: `eleme'
14:52:08 <lambdabot>  Perhaps you meant one of these:
14:52:08 <lambdabot>    `elem' (imported ...
14:52:15 <merijn> > elem (read "1") [1..10]
14:52:17 <lambdabot>   True
14:52:46 <Tordek> oio: the easy solution should be to move line 8 up to line 6
14:54:58 <frihd> quickly, i'm moving from a monadic-style Parsec parser to an applicative-style one
14:55:14 <Tordek> I'd like to grok that sentence
14:55:40 <heatsink> What happens if you move slowly?
14:56:02 <Tordek> the monadic police catches him
14:57:13 <frihd> I'm parsing a port number and "fail" if it's larger than 65535, how would you do this with applicative?
14:57:51 <Tordek> (in a semi-related note, I'd like to know what 'aplicative style' is)
14:58:18 <heatsink> frihd, you can't do that Applicatively.  You can keep that part monadic, though
14:58:18 <dmwit> frihd: You don't.
14:58:34 <frihd> thanks heatsink dmwit  :)
14:58:40 <dmwit> Alternately, you write out 65535 parsers and string them all together with <|>
14:58:46 <heatsink> haha
14:59:02 <dmwit> ...still not Applicative, though, since it also requires Alternative.
14:59:06 <frihd> hmm, sounds like a bad idea dmwit , i'll keep that bit monadic then
14:59:47 <frihd> Tordek:  Applicative is a typeclass somewhat between Functor and Monad
15:00:40 <ocharles> http://semantic-domain.blogspot.co.uk/2012/08/a-computational-lambda-calculus-for.html -- does anyone know a book, preferably suitable for a maths undergrand, that explains the notation at the top of this post?
15:00:51 <ocharles> i see it all the time in just about anything with type theory, but can barely understand it
15:01:14 <heatsink> ocharles, it's sequent calculus
15:01:29 <merijn> ocharles: I don't think there's really a book, but fortunately it's fairly simple
15:01:32 <dmwit> ocharles: No book needed, really. The horizontal bar is an implication arrow; the rest is a three-place relation.
15:01:34 <ocharles> well at least i finally have something to google :)
15:01:47 <heatsink> ezyang's thing is probably a good guide, I'll find that
15:01:57 <ocharles> dmwit: i don't know what implication really means, and certainly not what a three-place relation is
15:01:57 <ocharles> :)
15:02:03 <merijn> ocharles: Above the horizontal bar is the assumption, below the result (i.e. it's just logical implication"
15:02:07 <hiptobecubic> Is there a way to get  f' :: m (a -> b)  from  f :: (a -> m b) ?
15:02:15 <ocharles> maybe i should get a good book on first order logic
15:02:21 <dmwit> ocharles: No problem. Implication is "if A then B". Above the line is the "A" bit. Below the line is the "B" bit.
15:02:27 <merijn> ocharles: It just means "given the stuff above the bar, we may conclude the stuff below the bar"
15:02:28 <shachaf> hiptobecubic: No.
15:02:29 <dmwit> ocharles: A three-place relation is a set of triples, nothing more.
15:02:37 <heatsink> This website describes how sequent calculus can be used to describe simple logical inferences. http://logitext.mit.edu/logitext.fcgi/tutorial
15:02:37 <simpson> edwardk: In linear, how would I alter/get the magnitude of a V2? I can't find a way to do it without writing it myself.
15:02:56 <shachaf> hiptobecubic: Well, not for an arbitrary Monad.
15:03:03 <merijn> ocharles: The turnstile means, if we can conclude "right hand side" from "left hand side"
15:03:28 <dmwit> I'm not sure I would read the turnstile that way.
15:03:33 <ocharles> heatsink: awesome, thank you
15:03:37 <Tordek> hiptobecubic: I don't think that type makes sense for functions n general
15:03:50 <dmwit> I mean, this isn't even a sequent calculus, is it...?
15:04:04 <mauke> putChar :: String -> IO (); putChar' :: IO (String -> ()) ??
15:04:07 <merijn> ocharles: iow the first one is "if e has type A follows from Γ, then "val e" has type "T(A)" follows from Γ"
15:04:20 <shachaf> mauke: Except for the String bit.
15:04:26 <merijn> dmwit: It's not sequent calculus, afaik
15:04:31 <edwardk> simpson: look at quadrance and norm
15:04:56 <mauke> s/putChar/putStr/g
15:04:59 <edwardk> simpson: signorm will compute a unit vector in the direction of your existing non-unit vector, you can scale that
15:05:18 <edwardk> simpson: i tend to work with quadrance rather than magnitude because it avoids unnnecessary square roots
15:05:19 <heatsink> It's not sequent calculus?
15:05:24 <dmwit> No.
15:05:31 <ocharles> merijn: what does the 'follows from' bit mean?
15:05:56 <`nand`> hiptobecubic: there's distribute :: (Functor f, Distributive g) => f (g a) -> g (f a) -- for certain boring ‘g’
15:05:58 <dmwit> ocharles: We're defining the set of triples (Gamma, expression, type).
15:06:01 <dmwit> s/the/a/
15:06:03 <ocharles> right
15:06:12 <simpson> edwardk: Ah. I'm doing graphics, so magnitude's kind of important.
15:06:19 <dmwit> The way we define it is by saying "look for triples of the form (stuff above the bar) and add triples of the form (below the bar)".
15:06:37 <edwardk> simpson: yes, but many uses of magnitude can be replaced with quadrance with no loss is my point
15:06:47 <merijn> ocharles: In the context of type theory it usually means "if "e : A" is in the typing context Γ"
15:06:58 <edwardk> simpson: graphics is a domain i'm quite comfortable in ;)
15:07:01 <ocharles> is the 'Γ' bit a name for this equation/rule/thingy?
15:07:06 <ocharles> oh, i see
15:07:10 <dmwit> No, it's a metavariable.
15:07:16 <simpson> edwardk: Sure.
15:07:27 <dmwit> Think of it as pattern matching, and Gamma is the pattern that matches anything (and names it Gamma).
15:07:30 <edwardk> simpson: anyways quadrance is often called normSq in graphics circles
15:07:59 <simpson> edwardk: Right.
15:08:07 <ocharles> Well, now that I know what i'm googling for, I'll do some reading on the topic
15:08:20 <`nand`> come to think of it, is there an example of a non-boring Distributive (that is, other than (->) r and Identity)
15:08:46 <shachaf> `nand`: Tagged!
15:08:54 <shachaf> I guess that's Identity.
15:09:27 <Taneb> `nand`: a list type I made with its length in its type is Distributive, I think
15:09:33 <edwardk> `nand`: every distributive functor is isomorphic to some (->)
15:09:50 <edwardk> `nand`: this is a fundamental thing ;)
15:10:04 <edwardk> `nand`: this leads to a notion of representability
15:10:32 <Taneb> data List n a where Empty :: List Zero a; (:-) :: a -> List n a -> List (Succ n) a
15:10:37 <Hafydd> .'. all distributive functors are boring.
15:11:10 <Hafydd> Oh god, it's that face.
15:12:18 <Tordek> Taneb: is that a type for lists of a certain size? (/new to haskell)
15:12:30 <Taneb> Tordek: yeah
15:12:44 <Taneb> I wouldn't use it for anything serious, though
15:12:49 <Taneb> It's just me messing about
15:12:53 <Tordek> I assumed
15:13:11 <dmwit> data Nat n where Zero :: Nat n; Succ :: Nat n -> Nat (Succ n); now List n is isomorphic to (Nat n ->)
15:14:42 <Tordek> I'm making a simple little Fractal drawing thingie, and I have a huge amount of parameters: canvasW, canvasH, minX, minY, maxX, maxY, x, y, iterations... what would be the proper way to encapsulate all of these?
15:14:52 <dmwit> Make a record.
15:15:14 <dmwit> data Parameters = Parameters { minX, minY, maxX, maxY :: Int, {- ... -} }
15:15:16 <shachaf> That's only if you have a record number of parameters.
15:15:51 <heatsink> More generally, find groups of parameters that logically belong together and turn them into an algebraic data type.
15:15:52 <dmwit> instance Default Parameters where def = Parameters def def def def {- ... -}
15:15:53 <`nand`> Taneb: like; instance Distributive (List Zero); instance Distributive (List n) => Distributive (List (Succ n)) -- ?
15:16:03 <Taneb> Yeah
15:16:13 <heatsink> I'd say, first create a data type to group (x,y) values together
15:16:20 <heatsink> then put what you have left into a record
15:16:28 <startling> ^ yeah
15:16:37 <Taneb> `nand`: I wasted an afternoon defining all the instances I could think of for my List type
15:17:48 <heatsink> dmwit, my understanding is that any deduction system expressed using inference rules on judgments is sequent calculus.  Is that not right?
15:20:26 <dmwit> I thought sequent calculus was a specific formal system (or perhaps a small family of formal systems).
15:21:00 <dmwit> Wikipedia backs you up over me, though.
15:23:37 <heatsink> I'm not certain about the definition of sequent calculus, so I wanted to check if I was misusing it.
15:23:47 <Saizan> nah, natural deduction is inference rules too but it's not sequent calculus
15:24:00 <Tordek> (sorry, AFK), thanks for the record idea
15:25:26 <Saizan> sequent calculus is when your premises and conclusions look like Gamma |- Delta and those are to be interpreted as And(Gamma) -> Or(Delta)
15:25:57 <Saizan> (in intuitionistic versions Delta is restricted to be the singleton set)
15:27:57 <heatsink> Okay
15:28:17 <heatsink> I'll remember that
15:32:27 <heatsink> Okay,  I've verified that the optimization isn't performed on unlifted types either
15:37:31 <nejucomo> I have an (error "some label") as a parameter passed to a constructor...
15:37:48 <nejucomo> A test is failing with that error, but I don't understand why that constructor parameter is being reduced.
15:37:57 <nejucomo> How can I go about determining what expression reduces it?
15:38:15 <mauke> visual inspection?
15:38:27 <geekosaur> compile with profiling, run with +RTS -xc?
15:38:59 <nejucomo> mauke: I've been trying that, to no avail.
15:39:07 * nejucomo looks up +RTS and -xc
15:39:21 <nejucomo> Maybe I should try visual inspection even more carefully...
15:40:10 <heatsink> The -xc approach is generally what I try first
15:40:17 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html
15:40:41 <heatsink> Next step is using 'trace' to track down what gets evaluated before the error is produced
15:40:41 <shachaf> @where rts-xc
15:40:41 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
15:41:05 <geekosaur> +RTS sends options to the haskell runtime; -xc is a runtime option that produces a backtrace on exception
15:41:36 <nejucomo> geekosaur: Thanks, I just found that in the ghc user guide.
15:42:14 <ocharles> does -xc actually work well?
15:42:33 <nejucomo> Can I pass flags to cabal build, or must I alter the cabal file?
15:42:34 * ocharles hasn't really played with it
15:43:57 <ocharles> nejucomo: ghc-opts in cabal will pass stuff to ghc at compile time
15:44:04 <nejucomo> Another yack to shave in my herd is figuring out how to change my cabal file which builds three different binaries with largely the same modules in them, as a single library with three small main binaries...
15:44:11 <ocharles> `+RTS -xc` is used when you actually run your compiled binary
15:44:24 <heatsink> *yak to shave
15:44:32 <ocharles> nejucomo: A cabal file can have 1 library and multiple executables
15:44:46 <nejucomo> ocharles: Got it.  I had thought I didn't want to specify profiling in the cabal file, but I suppose for the short term I'll just leave it there.
15:44:47 <ocharles> in recent cabal's, the executables can build-depends on the library itself, or you can just bring it in with hs-source-dirs
15:44:56 <nejucomo> heatsink: Thanks.  ;-)
15:45:01 <ocharles> nejucomo: cabal configure has a --library-profiling option to do that for you
15:45:05 <ocharles> and --executable-profiling
15:45:07 <ocharles> i think those are the name
15:45:15 <ocharles> cabal configure --help to make sure i'm not spouting nonsense
15:45:29 <ocharles> oh, --enable-library-profiling, I think it might be
15:47:19 <heatsink> I think --enable-library-profiling is on by default
15:48:12 <heatsink> If it's compiling for profiling, you'll see p_o, p_hi files being built
15:49:52 <hpaste> Nejucomo pasted “inconsistent error messages” at http://hpaste.org/80989
15:49:56 <monochrom> it is on or off depending on ~/.cabal/config, and ~/.cabal/config defaults to off
15:50:05 <nejucomo> Well, that paste is pretty confusing.
15:50:41 <heatsink> Those flags are cabal flags, not ghc flags
15:50:47 <nejucomo> Could this be because I have a cabal or distribution layer that's made for a different version of ghc than I am using?
15:51:04 <heatsink> Add them as command line options when you run cabal configure
15:51:05 <nejucomo> Oooh...  Right.
15:51:09 <nejucomo> Thansk.
15:51:11 <nejucomo> thanks.
15:51:34 <nejucomo> So do I still need "-fprof-auto" as a ghc option?
15:51:41 <ocharles> i don't think so
15:51:42 <geekosaur> no
15:52:08 <geekosaur> if you're using cabal to build, use --enable-{executable,library}-profiling as appropriate and cabal will automaticaly add the right flags
15:52:27 <geekosaur> as parameters to the cabal install command
15:53:06 <monochrom> or cabal configure command
15:54:11 <nejucomo> With --enable-executable-profiling cabal configure now says it cannot find Control.Monad.State in mtl-2.1.1, suggesting I need to install a profiling version...
15:54:28 <`nand`> have you tried installing a profiling version of mtl-2.1.1?
15:54:34 <monochrom> then you need to rebuild mtl with --enable-library-profiling
15:54:57 <monochrom> there will be a recursive descent of the same for other libs
15:55:05 <nejucomo> So I never explicitly installed that library, IIRC, but cabal installed it for me when it was listed as a dependency.
15:55:26 <geekosaur> of course that may require rebuilding other stuff, but you may not need to build that other stuff for profiling.  but it'd be smart to do so in case you need it in the future
15:55:35 <nejucomo> Hm. Well, it seems like a lot of busy work, but I hope it pays off.
15:56:04 <nejucomo> Is there a flag in cabal configs where I can say "always build every package with profiling" ?
15:56:08 <geekosaur> yes.  typically people who do haskell development specify profiling in ~/.cabal/config before installing anything, so they don't need to worry about it\
15:56:35 <nejucomo> Is there a runtime cost added to all packages in that case?
15:56:49 <geekosaur> open ~/.cabal/config in a text editor; it will have been created the first time you ran cabal, and it's well commented
15:56:56 <heatsink> Packages are built in both profiling and non-profiling modes
15:56:56 <applicative> it takes longer to compile for sure...
15:57:11 <heatsink> There is a run-time cost, but only when running with profiling
15:57:21 <heatsink> Or rather, only when running the one that was compiled with profiling
15:57:22 <geekosaur> no, the profiling libraries will only be used if you build an executable with profiling.  normally you would turn on library profiling by default and use executable profiling only when needed
15:57:29 <nejucomo> Ok, so if I enable profiling builds it won't be the case that every cabal program I run will be in profiling mode, right?  That's what I want to avoid.
15:57:36 <nejucomo> Good to hear.
15:58:05 <applicative> nejucomo: no, that's the reason not to make then all 'profiling libraries', if I understand
15:58:34 * nejucomo reads up on those two options.
15:58:38 <geekosaur> no, the reason profiling is off for libraries by default is it uses potentially a lot more space
15:58:45 <applicative> ah
15:59:44 <geekosaur> if you're an end user installing something like xmonad or pandoc then you may never know about or care about profiling libs.  developers on theother hand would want to turn on library profiling by default so they have it when needed
16:00:00 <geekosaur> and will accept the extra space used by the profiling libs
16:01:39 <geekosaur> and a lot more time since every library has to be compiled twice, once with profiling (ewhich as already noted is significantly slower)
16:02:58 <nejucomo> cabal install --reinstall mtl-2.1.1 gives a list of 18 packages that "are likely to be broken by reinstalls".  Why would these dependents break?
16:03:27 <meiji11> I'm looking to squeeze a minimal haskell setup into about 600 mbs of space, and I'm wondering if someone has done that already.
16:03:33 <geekosaur> because ghc does very aggressicve inlining; any recompilation breaks those
16:03:36 <nejucomo> Is it true that profiling must be enabled in all dependencies if I am only interested in my own code?
16:03:42 <geekosaur> no
16:03:52 <geekosaur> [19 18:55] <geekosaur> yes.  typically people who do haskell development specify profiling in ~/.cabal/config before installing anything, so they don't need to worry about it\
16:03:53 <nejucomo> -because a dependency may be responsible for forcing the reduction of my own (error "some tag") ?
16:04:41 <geekosaur> you may not be using the other dependencies now (you'd have to check the dependencies of your own program) but it's often easier to just do it and get it over with, so you don;t have to go through this again later with some other progrm that has different dependencies
16:04:50 <nejucomo> geekosaur: I already have mtl-2.1.1 installed.  If I reinstall, assuming it's the exact same source, wouldn't inlining optimizations be identical?
16:05:18 <geekosaur> in theory they would be.  in practice, not always
16:05:28 <monochrom> it is possible that nothing is broken. do you want to try?
16:05:34 <geekosaur> if the package hash comes out the same then it did the same inlining :)
16:05:58 <geekosaur> *probably*
16:06:22 <monochrom> I am pretty sure that if you had a transactional file system, it would lose no data to try
16:06:25 <nejucomo> geekosaur: I guess a more general form of my question is: Are ghc builds with optimization deterministic over the input source, or are there bits of non-determinism (clocks) or poorly controlled determinism (temporary path strings, etc...) ?
16:07:08 <nejucomo> It would be nice if they were deterministic, especially for security auditing...
16:07:14 <geekosaur> I have observed builds of the same source with the same compiler come out slightly different, so there does ppear to be some nondeterminacy.  arguably that indicates a bug somewhere, but tracking down such bugs can be difficult
16:07:37 <nejucomo> Ok.  Well, I won't worry about that for now.
16:07:43 <geekosaur> do you want to be the test case for it, or do you just want to get pofiling working? :)
16:07:57 <monochrom> I think it is deterministic. but it is easy to overlook some variable
16:08:09 <nejucomo> heh...  now *that* would be a yak: "There was some bug in my program, but before I determined what it was, I found non-deterministic build bugs in ghc."
16:08:14 * geekosaur fully understands the security auditing point... security used to be part of his job, and he still follows various security news sources
16:08:21 <monochrom> mtl depends on transformer. if transformer changes, mtl changes too. you may overlook this
16:09:14 <nejucomo> What I'd really like to do is snapshot all installed packages; then recursively do "cabal install --reinstall ${pkg}-${currently_installed_version}"
16:09:34 <monochrom> make a full backup of your disk
16:10:13 <monochrom> oh, misread
16:10:27 <monochrom> ~/.cabal/world is likely to have a list you like
16:10:29 <burbul> Is there a standard way to run an action "speculatively" inside a State monad (or rather, monad involving a StateT)?
16:10:46 <burbul> I.e. I want to evaluate the action from the current state and see what the result would be, without actually changing the state
16:10:56 <burbul> [ I could build something using get and put
16:11:05 <burbul> But it seems like there might be a more idiomatic way of doing it]
16:11:18 <simpson> burbul: get would be the right way to do it.
16:11:26 <burbul> Thank you
16:11:45 <nejucomo> Hm.  Force reinstall of transformers and mtl completed without apparent error...  now I'd like to get a manifest of programs managed by cabal that I can somehow test.
16:11:48 <simpson> do { s <- get; when (satisfiesSomeCondition s) ... }
16:13:00 <burbul> or do { s <- get; monadic action; put s }, right?
16:13:03 <ocharles> nejucomo: ghc-pkg list shows you everything you have installed
16:13:28 <heatsink> :t withState
16:13:29 <lambdabot> (s -> s) -> State s a -> State s a
16:13:36 <heatsink> :t local
16:13:37 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
16:13:50 <ocharles> nejucomo: also, the 'world' package is a metapackage for everything you have installed
16:14:02 <heatsink> withState has the same type as local, but its side effect isn't local
16:14:42 <heatsink> I don't see the point of that function
16:17:33 <oio> haskell gui development?
16:18:03 <heatsink> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:gui
16:18:08 <parcs> dolphins and squirrels?
16:18:48 <nejucomo> ocharles: Ooh, very handy.
16:19:14 <nejucomo> If I reinstall world will versions be upgraded, or will I get the same versions?
16:19:58 <oio> any recommendation?
16:20:01 <applicative> nejucomo: you wont get the same versions
16:20:36 <applicative> nejucomo: you want the same versions because you know they worked together?
16:21:25 <nejucomo> applicative: I mainly want to change as few variables at a time as possible while bug hunting...
16:21:38 <nejucomo> But in this case, it's just easier to upgrade everything.
16:21:59 <nejucomo> I highly doubt the bug in my software would rely on the version of a dependency.
16:23:49 <MaybeCallMe> just figured out that cabal does build DLLs. the hack i found online doesnt work either
16:24:01 <MaybeCallMe> *doesnt build DLLs
16:27:17 <applicative> hm, MaybeCallMe maybe when duncan coutts is around you can inquire about it?
16:27:52 <applicative> MaybeCallMe: I think they are always desperate for windows competent people, by the way :)
16:29:53 <MaybeCallMe> applicative: ok
16:30:47 <MaybeCallMe> applicative: do you know his IRC handle?
16:31:13 <applicative> dcoutts
16:31:18 <HugoDaniel> hi
16:31:34 <oio> does someone has an experience with wxHaskell on os x
16:31:34 <MaybeCallMe> applicative: thanks
16:38:41 <applicative> oio what is going wrong? It can be a trial...
16:39:40 <applicative> > maxBound :: Int
16:39:41 <lambdabot>   9223372036854775807
16:43:13 <nejucomo> Hm.  Now when I run the unittests with +RTS -xc I get a segfault.
16:43:29 <nejucomo> Oh, but I also get this:
16:43:30 <nejucomo> *** Exception (reporting due to +RTS -xc): (THUNK_2_0), stack trace: TestSappho.Unparse.CAF
16:44:06 * hackagebot pandoc 1.10 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.10 (JohnMacFarlane)
16:44:11 <nejucomo> Does this mean the (error ...) expression is reduced as part of reducing a single CAF?
16:45:13 <nejucomo> Hrm.  Is there anything special about CAF evaluation?
16:45:57 <applicative> omg pandoc 1.10
17:06:13 <nejucomo> Well, after all this futzing with package upgrades, rebuilding with profiling, etc, I noticed the bug from visual inspection.  ;-)
17:06:28 <nejucomo> I learned some more of the toolchain though.
17:23:00 <aluink> i cleared my ~/.ghc and ~/.cabal/lib and did a ghc-pkg recache.  yet, when I try to install this package it claims it's reinstalling some and will break them? how can I start from scratch?
17:23:27 <aluink> I'm installing from source
17:23:48 <aluink> doing "cabal install" from the source dir and not "cabal install pkg"
17:24:01 <aluink> iow, not from hackage
17:25:55 <monochrom> since you cleared ~/.ghc, I don't see why either
17:26:26 <heatsink> DId you use --local?
17:26:50 <heatsink> --user
17:27:07 <aluink> heatsink: i'm not familiar with those flags.  for which? ghc-pkg or cabal? and what for?
17:27:36 <aluink> doesn't cabal install in the users ~/.cabal by default?
17:28:51 <monochrom> ok, if you bring in a second version of something that comes with GHC, it may trigger some reinstalls
17:28:57 <heatsink> For me, it installs with system-wide visibility unless --user is given
17:29:07 * hackagebot antigate 0.3 - Haskell interface for antigate.com captcha recognition service, and other services which support its API.  http://hackage.haskell.org/package/antigate-0.3 (MikhailKuddah)
17:29:23 <heatsink> in the global package repository
17:29:46 <monochrom> "cabal install" defaults to --user. "Setup blahblah" defaults to --global
17:30:55 <aluink> ok, i'm installing some of the dependencies manually. when it's done, i'll take a look at the error again and see which package it's trying to reinstall. i think I remember something about base being involve. bytestring maybe
17:32:02 <merlin_> is there something like fmap f pair that applies f to both fst and snd?
17:32:09 <aluink> monochrom: i'm thinking it must be something from GHC that's involved. that makes sense
17:33:18 <geekosaur> @hoogle (a -> b) -> (a,a) -> (b,b)
17:33:18 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
17:33:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
17:33:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
17:33:24 <geekosaur> hm, not quite
17:33:25 <fmap> > length *** reverse $ ("there", "is") -- merlin_
17:33:26 <lambdabot>   (5,"si")
17:33:34 <geekosaur> but that sounds like an arrow to me
17:34:02 <geekosaur> ...right, that
17:34:30 <fmap> > ("there", "is") & both %~ reverse
17:34:32 <lambdabot>   ("ereht","si")
17:34:34 <fmap> also that
17:35:13 <cmccann> :t join (***)
17:35:14 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
17:35:33 <cmccann> > join (***) (*2) (3,5)
17:35:34 <lambdabot>   (6,10)
17:37:03 <aluink> :t (***)
17:37:04 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
17:37:26 <aluink> :t join
17:37:27 <lambdabot> Monad m => m (m a) -> m a
17:37:35 * aluink facepalms
17:38:50 <cmccann> aluink: you see how it works, right?
17:38:58 * dmwit suggests the low-tech "both f (x, y) = (f x, f y)"
17:38:59 <cmccann> note that I don't really suggest using that in real code.
17:39:15 <cmccann> it's a well-known golf idiom on #haskell but rather obtuse otherwise
17:39:20 <aluink> no, i'm trying to figure it out.  how do you do asAppliedTo again?
17:39:36 <cmccann> aluink: do you know what the monad instance it uses is?
17:39:37 <dmwit> :t asAppliedTo
17:39:38 <lambdabot> (t -> b) -> t -> t -> b
17:39:45 <dmwit> :t join `asAppliedTo` (***)
17:39:46 <lambdabot> Arrow a => (a b c -> a b c -> a (b, b) (c, c)) -> a b c -> a (b, b) (c, c)
17:40:15 <aluink> i'm assuming Arrow's
17:40:27 <cmccann> well, not Arrow, that's a type class
17:40:37 <cmccann> but yes, ((->) e)
17:40:44 <cmccann> :t join
17:40:45 <lambdabot> Monad m => m (m a) -> m a
17:40:55 <merlin_> @hoogle both
17:40:55 <lambdabot> System.Posix.Terminal BothQueues :: QueueSelector
17:40:55 <lambdabot> Network.Socket ShutdownBoth :: ShutdownCmd
17:40:56 <cmccann> then set m = ((->) e)
17:40:58 <aluink> right, i'm not familiar with Arrow much
17:41:28 <cmccann> m (m a) gives you ((->) e) (((->) e) a), which is "e -> (e -> a)" written normally
17:41:42 <merlin_> no both as far as I see. was that a hint to write both myself?
17:42:04 <aluink> oh wow, that is obtuse
17:42:05 <aluink> i see it now
17:42:15 <cmccann> the monad instance for ((->) e), which is the pointless obfuscation monad (or, with a newtype wrapper, Reader) splits an argument among multiple functions
17:42:36 <monochrom> hehe
17:42:56 <cmccann> since join is the most primitive monad operation in some sense, it does the simplest version, which is applying one function to a single argument twice
17:43:06 <monochrom> soon, it will also be the pointless obfuscation functor and applicative
17:43:16 <cmccann> :t (.)
17:43:17 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:43:25 <cmccann> fmap for ((->) e) is function composition
17:43:48 <cmccann> and for some reason lambdabot has "generalized" it that way
17:43:54 <aluink> monochrom: ok, it was trying to downgrade containers and bytestring
17:44:28 <aluink> since this is my code, i'm upgrading the dependency requirement and i'll see if it's changed enough to break
17:44:42 <aluink> it's just a minor upgrade for both, so it *should* be ok
17:44:48 <monochrom> good good
17:44:58 <aluink> thanks for your help
17:45:04 <monochrom> you're welcome
17:45:56 <shachaf> cmccann: Can you make it so that (f .) becomes "fmap f", but (. f) becomes "lmap f"?
17:46:18 * geekosaur doesn't even want to think about it...
17:46:19 <monochrom> how could it be possible!
17:46:25 <aluink> cmccann: wow, you're making my head hurt. in a good way. i'll go lick my wounds now. 'night all
17:46:50 <cmccann> aluink: don't worry, misusing ((->) e) that way isn't really something people do in real code (I hope)
17:47:00 <cmccann> but it is the heart and soul of golfing pointless style on #haskell
17:47:53 <monochrom> if you're 20 and you don't play the golfing game, you have no brain
17:47:58 <cmccann> shachaf: you sure like asking me to implement weird type signatures
17:48:07 * cmccann is not djinn
17:48:13 <monochrom> if you're 40 and you still play the golfing game, you have no brain
17:48:38 <monochrom> hmm, maybe "no life" for the latter is more catchy!
17:48:45 <shachaf> Is there a way to have a brain?
17:49:03 <monochrom> yes. the only way to win is to not play!
17:49:11 <cmccann> monochrom: the proper progression is from golfing code length for terseness, to abstraction golfing for generality
17:49:34 <shachaf> cmccann: One of these is easier to measure than the other.
17:50:10 <cmccann> man, I'm not sure what to make of edwardk joining right after I said that.
17:50:19 <edwardk> ?
17:50:19 <monochrom> how to measure generality: 1/(the number of people who understand)
17:50:27 * geekosaur learned haskell in his 40s; where does that fit?
17:50:31 <cmccann> edwardk: "monochrom: the proper progression is from golfing code length for terseness, to abstraction golfing for generality"
17:50:48 <edwardk> hah
17:51:00 <edwardk> i like generality
17:51:05 <cmccann> it is so easy?
17:51:10 <monochrom> in that sentence, "monochrom:" means someone said it to monochrom. not monochrom said it
17:51:27 <shachaf> cmccann: Golfing for speed is more popular, I think.
17:51:27 <monochrom> however, what monochrom said were:
17:51:36 <monochrom> <monochrom> if you're 20 and you don't play the golfing game, you have no brain
17:51:41 <monochrom> <monochrom> if you're 40 and you still play the golfing game, you have no brain
17:51:41 <monochrom> <monochrom> hmm, maybe "no life" for the latter is more catchy!
17:51:49 <cmccann> monochrom: that was kind of implied since I said it was something I said, but yeah, sorry for the ambiguity.
17:51:58 <cmccann> far be it from me to blame other people for the nonsense I say.
17:52:47 <heatsink> @quote golf
17:52:47 <lambdabot> Jafet says: caleskell is the standard golf course.
17:52:56 <monochrom> I also suggested how to measure generality: 1/(number of people who understand). using this measure, perhaps lens is not too general
17:53:33 <aluink> :t (->)
17:53:34 <lambdabot> parse error on input `->'
17:53:35 <shachaf> monochrom: I think at this point there are parts of lens that nobody understands.
17:53:41 <aluink> hmmm
17:53:46 <heatsink> It's a type
17:53:49 <monochrom> or perhaps we don't have "what is lens" tutorials yet. we only have "use lens" tutorials
17:53:55 <shachaf> I know I don't understand some parts that I'm directly responsible for.
17:54:11 <aluink> is (->) = Arrow?
17:54:13 <Maxdamantus> Are type functions considered types?
17:54:13 <heatsink> :k (->)
17:54:14 <lambdabot> * -> * -> *
17:54:27 <aluink> ah!
17:54:30 <monochrom> to decrease the number of people who understand, you must have enough "what is" tutorials
17:54:45 <Maxdamantus> :k Either String
17:54:46 <lambdabot> * -> *
17:54:47 <heatsink> Maxdamantus, they're types but they're not first-class in GHC
17:54:55 <cmccann> monochrom: no good. it's named after a physical object already.
17:55:01 <cmccann> that really cuts down on the absurd analogies.
17:55:02 <heatsink> Higher-kinded types are types in GHC
17:55:08 <monochrom> heh
17:55:16 <aluink> so Arrow a b = (->) a b?
17:55:19 <cmccann> nobody is going to claim that a lens is like a burrito, it's a lens, I mean come on
17:55:27 <heatsink> aluink, Arrow is a generalization of (->)
17:55:39 <edwardk> if you eat a lens it won't end well.
17:55:39 <cmccann> aluink: Arrow is a type class for things that are kinda like (->) in certain ways
17:55:42 <aluink> ugh! of course it wouldn't be simple
17:55:46 <heatsink> (->) is one instance, but there are allegedly others
17:56:02 <aluink> where is (->) defined? I can't find it on hoogle
17:56:04 <shachaf> cmccann: In certain ways, such as "being instances of Arrow"?
17:56:10 <monochrom> we should have done: class Object m where (>>=) :: m a -> (a -> m b) -> m b ...
17:56:17 <shachaf> aluink: It's primitive. It's the thing in "a -> b"
17:56:24 <Maxdamantus> > let x :: (->); x = x in x
17:56:25 <heatsink> Speaking of which, "lentil" and "lens" come from the same root.  You can certainly eat lentisl.
17:56:25 <lambdabot>   Expecting two more arguments to `(->)'
17:56:39 <cmccann> shachaf: I was more thinking "have reasonable definitions of the Arrow functions" but yes.
17:56:45 <monochrom> I love lens. it is so delicious
17:56:49 <shachaf> aluink: Hoogle does find it, though.
17:57:01 <shachaf> http://www.haskell.org/hoogle/?hoogle=%28-%3E%29
17:57:08 <monochrom> oh, next Toronto Haskell meeting (February) I will talk about Arrow!
17:57:14 <Maxdamantus> So any value in the type system is called a "type"?
17:57:43 <monochrom> "value in a type system" sounds like an oxymoron
17:57:55 <cmccann> hm
17:58:13 <heatsink> Any term that has a kind is a type.
17:58:15 <cmccann> according to wiktionary, the word lens comes from the latin word for lentil
17:58:20 <Maxdamantus> Entity, maybe .. dunno.
17:58:26 <monochrom> but I would just say "a type system talks about types"
17:58:44 <heatsink> <heatsink> Speaking of which, "lentil" and "lens" come from the same root.  You can certainly eat lentisl.
17:58:51 <Maxdamantus> Seems like an odd use of teminology.
17:58:54 <cmccann> regular convex lenses are kinda lentil-shaped I guess.
17:59:10 <geekosaur> that's more or less the idea, yes
17:59:18 <cmccann> heatsink: yes, that's why I looked it up. was wondering what the root word meant.
17:59:25 <heatsink> oh, okay
18:00:11 <monochrom> a type system probably talks about types and something else. for example, a typing rule has to talk about both types and code
18:00:19 <Maxdamantus> Wikipedia says * describes types.
18:00:32 <shanse> is http-conduit is easiest way to make https requests?
18:00:39 <cmccann> hm, apparently a medical term for freckle-ish things also comes from the same root as "lens".
18:00:52 <oio> how can i get sdl to work on os x
18:01:23 <cmccann> edwardk: you should find some way to work the term "lentiginous" in.
18:01:32 <monochrom> haha
18:01:44 <edwardk> cmccann: lentigines?
18:01:47 <monochrom> "python is not lentiginous"
18:01:47 <heatsink> When only types in * are considered types, other well-kinded terms are called type constructors, or type operators.
18:02:13 <shachaf> @wn lentiginous
18:02:14 <lambdabot> *** "lentiginous" wn "WordNet (r) 3.0 (2006)"
18:02:14 <lambdabot> lentiginous
18:02:14 <lambdabot>     adj 1: relating to or covered with or resembling freckles [syn:
18:02:14 <lambdabot>            {freckled}, {lentiginous}, {lentiginose}]
18:02:15 <Maxdamantus> Mm. That terminology seems to make more sense.
18:02:21 <heatsink> However, in Haskell, "type constructors" are type-level names that don't evaluate to anything
18:02:25 <cmccann> edwardk: some sort of medical term for freckle-ish skin pigmentation spots I guess
18:02:28 <edwardk> class Freckled t where ...
18:02:33 <heatsink> So in Haskell, "EIther String" is not a type constructor
18:02:33 <cmccann> yessssssss.
18:02:40 <heatsink> in type theory, it is sometimes called a type constructor
18:03:17 <edwardk> I had an ex-gf with lots of freckles who was fond of that word ;)
18:03:18 <cmccann> edwardk: a type class for things that have a bunch of obvious surface-level lenses available clearly
18:03:29 <edwardk> (lentiginous)
18:05:10 <cmccann> edwardk: apparently "Lens" is also the genus of lentil plants but I'm not sure how that would fit in yet.
18:05:36 <hiptobecubic> can we fit voyeur into this somehow?
18:06:35 <hiptobecubic> i guess it would have to be some kind of higher order operator
18:06:45 * cmccann ponders something involve legumes being useful for nitrogen fixation.
18:08:41 <AfC> You have a Freckled type in lens now?
18:08:55 <edwardk> AfC: not yet ;)
18:09:56 <MaybeCallMe> Just re-wrote my C++ trading strategy DLL in Haskell.. performance is slow, and so the backtester produces different results, because the backtester has moved on to the future by the time the Haskell DLL makes up its minds.
18:11:26 <MaybeCallMe> I am not impressed. The only optimization left to make is to use Data.Sequence instead of Data.List
18:12:45 <cmccann> MaybeCallMe: what sort of operations are you doing on those lists?
18:12:51 <cmccann> (and how often)
18:13:00 <shachaf> You are quite the expert in Haskell optimization.
18:15:39 <MaybeCallMe> cmccann: the most frequent thing I do is drop the first few elements so as to make the list 3 elements long
18:16:37 <cmccann> so you always know ahead of time how long the lists will be?
18:16:41 <merlin_> is there a way to time something with higher resolution than diffUTCTime endTime startTime?
18:17:39 <MaybeCallMe> cmccann: no. when shit hits the fan the list can be very long
18:19:03 <MaybeCallMe> brb
18:26:38 <applicative> MaybeCallMe: what is the list holding?
18:30:07 <AfC> MaybeCallMe: you're obviously frustrated; fair enough. But there is a broad set of practices involved in writing and tuning performant Haskell, and you're probably going to need to take some of that in if your code has mission-critical performance requirements.
18:30:42 <oio> is there a way to have a persistent list on haskell
18:30:47 <AfC> (I'm climbing that learning curve myself)
18:31:21 <Maior> does anyone have any example code using Data.Array...?
18:31:27 <cmccann> oio: lists are always persistent, they're always there and never change as long as they're in scope.
18:31:51 <oio> take a look at this i want to keep the list of ints
18:32:00 <applicative> oio the trouble is getting the mutable evanescent ones no...
18:32:10 <hpaste> OiO pasted “CountCards” at http://hpaste.org/80992
18:33:04 <cmccann> oio: that code doesn't make much sense
18:33:31 <oio> it counts cards (blackjack)
18:33:52 <oio> Ace 1 then adds another int to the list sums
18:33:57 <oio> etc..
18:35:02 <oio> stack is wrong beacuse i dont know how to stack
18:35:44 <heatsink> What is an example of the input and output when stack is called?
18:35:46 <cmccann> oio: I'm really not sure what you expect half of this code to do.
18:36:29 <oio> stack 1
18:36:32 <oio> [1]
18:36:38 <oio> stack [2]
18:36:44 <cmccann> oio: I think you need to back up and explain what you want to do overall
18:36:46 <oio> [1,2]
18:36:56 <applicative> sum (stack (count x)) = count x
18:37:14 <hiptobecubic> It's more fun to guess about it and propose wild solutions
18:37:20 <cmccann> because I think you've taken a wrong turn somewhere and are trying to do things in a way that doesn't make sense
18:39:10 <heatsink> I agree with cmccann.
18:39:26 <shachaf> I disagree with cmccann but agree with heatsink.
18:39:39 <startling> I disagree with everyone.
18:39:42 <geekosaur> eyeroll*
18:39:46 <cmccann> I agree with startling.
18:39:48 <cmccann> er.
18:39:50 <heatsink> I think you're asking for mutable arrays with an append operation, but that's probably not the right solution.
18:40:00 <shachaf> oio: I do think you should learn some simpler parts of Haskell before doing this.
18:40:00 <cmccann> oio: anyway, to start with, you need to get rid of the notion of "modifying" a list.
18:40:05 <startling> cmccann: not any more, you don't!
18:40:12 <shachaf> You can make the sort of thing you're trying to do work, sort of, but it's probably not a good idea.
18:40:53 <cmccann> oio: if you want a function that "changes" a list, it needs to take an existing list as input and build a new list based on that
18:40:56 <oio> i mean its a simple program could someone get me some light
18:41:00 <hpaste> applicative annotated “CountCards” with “CountCards (annotation)” at http://hpaste.org/80992#a80993
18:41:01 <hpaste> applicative annotated “CountCards” with “CountCards (annotation)” at http://hpaste.org/80992#a80994
18:41:12 <applicative> hm, how did I do that?
18:41:26 <cmccann> oio: have you gone through LYAH or any other basic tutorial on haskell?
18:41:54 <oio> wikibooks haskell
18:42:09 <oio> havent finished @.@
18:42:15 <shachaf> Last time I read that it had all sorts of bad parts.
18:42:23 <shachaf> I think it's been improved since then but I don't know.
18:42:25 <cmccann> oio: LYAH might be a better place to start.
18:42:28 <cmccann> @where lyah
18:42:28 <lambdabot> http://www.learnyouahaskell.com/
18:42:59 <applicative> oio if the user types 'q' what is supposed to happen, it looks like it's -1 on the one hand and ... exitSuccess on the other ....
18:43:00 <oio> i saw dont like it
18:43:05 <etrepum> with that method of card counting you don't really need a list anywhere, the idea is to just deal with a small integer so you can do it in your head
18:43:32 <oio> qt xs          | xs == "q" = exitSuccess     |otherwise = return ()
18:43:37 <Nisstyre-laptop> oio: there are data structures better suited to updating parts of the list other than the head (i.e. not simply consing something onto the head)
18:43:45 <Nisstyre-laptop> e.g. zippers
18:44:38 <applicative> oio:  but also count says that 'q' is -1
18:44:48 <cmccann> oio: don't like it? why not?
18:45:20 <fryguybob> :q
18:45:26 <hiptobecubic> fryguybob, try again
18:45:35 <fryguybob> :D
18:45:38 <Nisstyre-laptop> oio: how experiences are you in general wrt programming?
18:45:39 <nejucomo> oio: You might also try http://book.realworldhaskell.org/
18:45:40 <oio> english is not my native language find it easy to understand on wikibooks
18:45:42 <Nisstyre-laptop> *experienced
18:45:50 <cmccann> oio: you could try http://www.haskell.org/tutorial/ instead.
18:45:56 <oio> in count q is -1
18:46:05 <cmccann> it's a bit more demanding but also straightforward.
18:46:08 <oio> in qt "q" is exitSucces
18:46:22 <Nisstyre-laptop> most (all?) of the tutorials mentioned are aimed at people who already have a decent amount of experience with programming
18:47:14 <applicative> oio yeah, but I was trying to figure out what was going on in main. To find out if the user wants to quit, wouldn't you need another getLine?
18:47:20 <cmccann> oio: one way or another, though, you REALLY should try to work through more of that sort of material. you're having trouble with pretty basic concepts here.
18:47:53 <cmccann> oio: bashing your head against a wall is not going to help you learn.
18:48:09 <applicative> oio is doing fine, I'd say
18:48:22 <oio> so how would you implemented ?
18:48:25 <oio> ...
18:48:30 <oio> iguess is simple
18:48:31 <applicative> a beginning is difficult in every science.
18:48:46 <Nisstyre-laptop> oio: how experienced would you say you are with programming?
18:49:14 <oio> hobby i study other carreer
18:49:31 <Nisstyre-laptop> okay, how long have you been doing it? What languages do you know well?
18:49:33 <applicative> good
18:49:45 <Nisstyre-laptop> Why do you want to learn Haskell?
18:50:15 <oio> like a moth
18:50:19 <oio> month
18:50:24 <Nisstyre-laptop> right now I'd say LYAH is definitely the best option for you
18:50:32 <Nisstyre-laptop> if you can read it, idk if there are translations
18:50:35 <applicative> oio, you don't need to know anything to study haskell, except the power of thought ... and some typing skill
18:51:10 <Nisstyre-laptop> applicative: and the ability to read
18:51:46 <oio> english not my mother language
18:52:28 <Nisstyre-laptop> oio: what is?
18:52:36 <oio> spanish
18:52:40 <Nisstyre-laptop> okay
18:52:49 <applicative> oio there are a couple of #haskell-X channels for languages other than whatever we use here....
18:53:06 <Nisstyre-laptop> oh look https://github.com/alvivi/lyah-es
18:53:20 <Nisstyre-laptop> http://aprendehaskell.es/
18:53:22 <Nisstyre-laptop> :D
18:53:40 <oio> idk i like wikibook so far
18:53:52 <Nisstyre-laptop> this looks pretty well done
18:54:02 <oio> the translation isnt perfect it get confusing some times
18:54:10 <heatsink> Cool
18:54:14 <oio> yeah i like the comments part
18:54:31 <heatsink> Hopefully they found a way to incorporate spanish puns into the text
18:54:40 <applicative> ill be darned, lyah-es
18:54:55 <hiptobecubic> nice
18:55:04 <hiptobecubic> this is funnier somehow than the original
18:55:19 <cmccann> english isn't actually the first language of the guy who wrote LYAH, is it?
18:55:26 <applicative> google translate, taking it back to English calls it "Learn Haskell for the good of all!"
18:55:27 <hiptobecubic> oof, why does it use a dark theme for code
18:55:30 <Nisstyre-laptop> cmccann: no idea
18:55:31 <applicative> perfect
18:56:01 <cmccann> (not that that matters or anything, just impressive if it's not his native language)
18:56:42 <applicative> no, he's from Czech Republic, Slovakia maybe  -- or am I imagining
18:57:14 <engla> very impressive
18:57:16 <oio> "NOTA: ¡Me has pillado en pleno proceso de revisión! Algunos capítulos están recién salidos del horno y necesetian ser revisados ¡Lo siento!"
18:57:29 <nus> http://learnyouahaskell.com/faq
18:57:31 <cmccann> applicative: well, where he lives doesn't necessarily indicate what his native language is
18:57:36 <cmccann> I kn
18:57:38 <cmccann> ergh
18:57:51 <cmccann> I know he lives in a country where english isn't the primary language
18:57:56 <oio> you got me some chapters are just baked and need to be checked
18:57:57 <startling> cmccann: you knergh?
18:57:58 <heatsink> If you're the kind of bad person who doesn't read introductions and has skipped this part, you should at least read the last part of this introduction
18:58:04 * cmccann knergh
18:58:09 * startling knergh
18:58:25 <Nisstyre-laptop> cmccann: well, babies become able to distinguish and not-distinguish between phonemes in the first 6 or so months of their lives, and that more or less determines what their native language is
18:58:26 <shachaf> grhgh
18:58:38 <Nisstyre-laptop> s/phonemes/allophones/
18:58:51 <applicative> I think English is not his mother tongue; he's just very brilliant
18:58:58 <heatsink> Distinguish phonemes and not distinguish allophones
18:59:00 <shachaf> preflex: seen idnar
18:59:00 <preflex>  idnar was last seen on #haskell 311 days, 15 hours, 58 minutes and 30 seconds ago, saying: well, either way, I can't actually find the instance
18:59:07 <cmccann> Nisstyre-laptop: the FAQ page doesn't say he was born there
18:59:13 <hiptobecubic> there was some study recently that said that language specialization already starts during pregnancy
18:59:16 <cmccann> that's why I was asking :P
18:59:16 <Nisstyre-laptop> oh okay then
18:59:24 <hiptobecubic> i think the swedes did it. it was on reddit. i didn't look into it
18:59:34 <Nisstyre-laptop> hiptobecubic: makes sense, the womb isn't sound proof
18:59:38 <applicative> Miran Lipovaca is a computer science student in Lubljana, Slovenia
18:59:43 <hiptobecubic> Nisstyre-laptop, that was the argument, yeah.
19:00:17 <oio> welll.. going to read it and see if i can make some improvements to the source
19:00:17 <cmccann> it's not THAT rare for e.g. a child of immigrants (perhaps even raised bilingual) to end up back in the parents' country or such
19:00:43 <applicative> "...He has a fascination with dancing skeletons and the number 71, and when he walks through automatic doors he pretends he's opening them with his mind"
19:01:09 <applicative> mccann, yes, and he *could* be a Martian invader...
19:01:39 <hiptobecubic> why does every translation change the color of the code blocks
19:01:48 <b__> funny, from "03:58 < applicative> I think English is not his mother tongue; he's just very brilliant" I guessed you were talking about Miran
19:01:51 <hiptobecubic> this is terrible: http://lyah.haskell.fr/demarrons
19:02:51 * applicative considers the possibility that BONUS is the love child of  Slavoj Zizek and some bot
19:07:49 <startling> bots can not love
19:07:55 <Nisstyre-laptop> startling: prove it
19:08:35 <startling> @faq can bots not love?
19:08:35 <lambdabot> The answer is: Yes! Haskell can do that.
19:08:37 * geekosaur notes that there's a bot called hugme in #perl6...
19:08:54 <shachaf> Does #perl6 have an eyerollbot?
19:09:17 <cmccann> oh man, we need an eyerollbot.
19:09:19 <cmccann> that would be awesome.
19:10:22 <startling> perl 6?
19:10:26 * startling rolls his eyes
19:10:34 <Nisstyre-laptop> wasn't perl6 prototyped w/ Haskell?
19:10:39 <Nisstyre-laptop> or was that an earlier perl?
19:10:52 <geekosaur> perl6, pugs, and there's some effort to revive it
19:12:45 <M30W> With a sha512, how would one store the hex as tightly as possible ? as a bytestring ?
19:13:32 <heatsink> Bytestring would work.  Probably UArray Word8 is more appropriate
19:13:43 <heatsink> for a known-length array of bytes
19:13:57 <shachaf> Hex?
19:14:28 <Nisstyre-laptop> I need to convert my ngram program to use byte arrays..., scaling up from digrams to trigrams and quadgrams uses a ton of memory :(
19:15:11 <M30W> shachaf: sha512 -> 128 hex characters.
19:15:34 <shachaf> No. But never mind.
19:16:42 <M30W> Point is, why store it as a string when it's hex and hex could be as... hex, there you have the set of bytes.
19:17:36 <shachaf> I'm not sure what "hex" has to do with it.
19:18:48 <M30W> i{]É�ímq¾{N3�J©|?z3��Ð5wÏt¾" as text
19:18:49 <Ralith> shachaf: you seem so fatalistic lately
19:18:50 <M30W> fail
19:18:52 <applicative> there's an effort to revive pugs, geekosaur ?
19:18:56 <M30W> control character -_-
19:19:04 <geekosaur> yes
19:19:51 <geekosaur> audreyt has gotten it working with recent ghc but is keeping it only on life support; various others are tryinng to add features since it currently passes somewhere around 35% of the perl6 spec tests.
19:19:56 <applicative> are the other schemes for implementating  perl 6 going to pieces somehow?
19:20:07 <geekosaur> no
19:20:17 <shachaf> I went through the code base and changed a lot deprecated things to be not deprecated.
19:20:22 <heatsink> That looks like a Lovecraftian hex to me
19:20:25 <M30W> shachaf: Hex -> String, think of hex not as a string but as the literal bytes.
19:20:33 <shachaf> Unfortunately I put it in a branch, and nobody pays attention to branches, so I think someone else redid all the work.
19:21:06 <shachaf> M30W: "hex"adecimal is a representation. Just like decimal. If you want to talk about the bytes themselves, say bytes. :-)
19:21:06 <M30W> be688838ca8686e5c90689bf2ab585cef1137c999b48c70b92f67a5c34dc15697b5d11c982ed6d71be1e1e7f7b4e0733884aa97c3f7a339a8ed03577cf74be09 <<< '' sha512sum
19:21:06 <geekosaur> I think the pugs effort is mostly about having a perl6 implementation that doesn't depend on a bytecode interpreter (the other implementations use Parrot and the CLR)
19:21:20 <shachaf> M30W: Anyway, as I said, never mind.
19:21:54 <M30W> shachaf: hexadecimal is a representation yes, why not just stay as the bytes for a record?
19:21:54 <heatsink> Maybe the unicode faq will clear up the idea of encoding bytes as text
19:22:38 <applicative> I see, pugs would be a proper 'compiler'
19:23:07 <shachaf> M30W: You're the one to bring up "hex".
19:23:54 <M30W> shachaf: In a record; how would the sha512 be stored?
19:24:06 <heatsink> It would probably be stored in an array
19:24:25 <M30W> heatsink: list* of what? each byte ?
19:24:26 <heatsink> The data is a string of bits, and the easiest way to store a string of bits is with an array of bytes
19:25:14 <shachaf> M30W: Why do you keep correcting the people whom you're asking questions?
19:25:55 <M30W> shachaf: To make sure that we're on the right page.
19:26:05 <applicative> shachaf, correcting people, it's infectious.
19:26:39 <heatsink> In principle, you could use a list of 512 Bools or a record of 512 Bools, but that would be an awkward way to do it.
19:26:54 <heatsink> I wouldn't recommend using records or lists as you were saying above.
19:26:56 <shachaf> You could also use a list of a certain length of ()s.
19:27:02 <shachaf> Lots of options.
19:27:09 <shachaf> But what heatsink said seems reasonable.
19:27:14 <shachaf> A bytestring seems reasonable too.
19:27:43 <M30W> So I was correct to think of a bytestring. :)
19:27:46 <shachaf> The right thing to do is probably to define a data type so you don't have to care.
19:27:49 <lispy> Integer is another option. In fact, I think there is a library on hackage that does that.
19:28:08 <shachaf> Integer seems like it might not be a great option. But who knows.
19:29:46 <idnar> wow, has it really been a year since I spoke on here?
19:29:55 <M30W> lets say.. data User = User { username :: ByteString, password :: ByteString, salt :: ByteString, regDate :: Integer } -- or something.
19:29:58 <idnar> clearly I need to do more haskelling
19:30:44 <shachaf> hi idnar
19:30:52 <idnar> hey :)
19:30:55 <shachaf> idnar: Being in #haskell and writing Haskell code aren't very correlated.
19:30:59 <M30W> Hey idnar
19:31:01 <shachaf> In fact they might be inversely correlated.
19:31:06 <idnar> haha
19:33:22 <MaybeCallMe> cmccann:
19:33:22 <MaybeCallMe> applicative:
19:33:22 <MaybeCallMe> AfC:
19:33:22 <MaybeCallMe> Sorry for the frustration earlier. I replaced Data.List with Data.Sequence and it is 3 times faster on average. But that hasn't solved my problem yet. It is still slower.. I guess I don't know enough Haskell for production yet.
19:34:11 <MaybeCallMe> it will be my weekend mistress for a long time to come
19:34:24 <cmccann> MaybeCallMe: for performance bottlenecks involving crunching lots of data, Haskell is probably not a good choice unless you know it well enough to grok the deepest of optimization deep magic.
19:34:38 <shachaf> Data.Sequence does not have particularly good constant factors if I remember correctly.
19:34:46 <gwern> @quote sequence
19:34:46 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
19:34:58 <shachaf> You were probably using mutable arrays or something in C++. You could try doing the same thing in Haskell.
19:35:05 <shachaf> (Not that I recommend that, though.)
19:35:14 <shachaf> @quote equence
19:35:14 <lambdabot> PaulWHomer says: [Regarding Cantor's diagonalization] The diagonal argument works perfectly fine with a sequence. It is invalid, however, when used on a magic sequence.
19:35:40 <MaybeCallMe> thanks ..
19:36:57 <applicative> MaybeCallMe: what are the things on the list?
19:37:00 <applicative> lists
19:37:08 <MaybeCallMe> just integers
19:37:16 <heatsink> Are they Int or Integer?
19:37:17 <cmccann> MaybeCallMe: a lot of real-world applications are essentially IO-bound (often network IO or user interaction, even), and in those cases Haskell is easy to use. plus the usual places where ML-style languages shine.
19:37:30 <MaybeCallMe> heatsink: i use Int now
19:37:33 <cmccann> CPU-limited number crunching is very much another matter.
19:37:53 <MaybeCallMe> cmccann: hmm
19:38:21 <cmccann> (rule of thumb: if FORTRAN is better than C for what you want to do, Haskell is probably worse)
19:38:22 <MaybeCallMe> i wish i could use haskell for everything.. i would have loved it
19:38:32 <MaybeCallMe> cmccann: hehe
19:38:52 <heatsink> In Haskell, each list element is a pointer to an Int.  If it's performance-critical, it may be worth using other data structures that contain Int values (instead of pointers)
19:38:57 <cmccann> MaybeCallMe: the FFI is not too painful, I'd seriously consider using Haskell as glue code for number crunching written in C or something.
19:39:21 <MaybeCallMe> cmccann: yes i agree. i loved the FFI
19:39:37 <MaybeCallMe> StablePtr FTW
19:39:44 <shachaf> You can use Haskell for a lot of things.
19:39:51 <shachaf> But you have to know Haskell pretty well for some of them.
19:40:30 <MaybeCallMe> yes.. i seriously liked the typoclassopedia classes.. they are very elegant and generic
19:40:35 <heatsink> Sometimes I find imperative pointer manipulation to be easier in the FFI than in C
19:49:39 <applicative> is parsec's choice the same as msum?
19:52:39 <applicative> its seeming it is.
19:53:05 <heatsink> Apparently so
19:53:22 <heatsink> @src choice
19:53:22 <lambdabot> Source not found. My brain just exploded
19:54:34 <heatsink> Parsec defines (<|>) as mplus
19:55:11 <applicative> choice = foldr (<|>) mzero;  but     empty = mzero     (<|>) = mplus
19:55:12 <applicative> right
19:55:16 <applicative> as you say
19:57:04 <heatsink> So... is a pineapple dual to a pumpkin because the hollow part is on the outside?
19:59:32 <otters> isn't the hollow part of nearly anything on the outside
20:04:10 * hackagebot yst 0.3.1 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.3.1 (JohnMacFarlane)
20:24:34 <kqr> why does sequence become a cartesian product for the list monad?
20:24:46 <shachaf> @src sequence
20:24:46 <lambdabot> sequence []     = return []
20:24:46 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:24:46 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
20:24:47 <kqr> is there some piece of intuition that i'm missing when i'm looking at the code?
20:25:00 <shachaf> Intuition: [] means nondeterminism.
20:25:19 <shachaf> So when you say do { x <- xs; ... }, x is "all of the values in xs", in a sense.
20:25:30 <shachaf> (Or alternatively each value in xs in turn. It doesn't mattermuch.)
20:25:30 <kqr> hm
20:25:51 <shachaf> So when you say do { x <- xs; y <- ys; return (x,y) }, that'll be the Cartesian product of xs and ys
20:26:06 <monochrom> yes, understand that one first
20:26:08 <shachaf> Because you're picking a value from xs and ys nondeterministically.
20:26:24 <kqr> this is really over my head
20:26:26 <shachaf> sequence is an extension of that to arbitrary lists.
20:26:38 <kqr> couldn't (do v <- x; vs <- sequence xs; return (v:vs)) be rewritten as (x:sequence xs)?
20:26:46 <monochrom> no
20:26:57 <shachaf> I recommend following monochrom's advice -- forget about sequence. Understand my example first.
20:27:21 <shachaf> > do { x <- "abc"; y <- [1,2,3]; return (x,y) }
20:27:23 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
20:27:46 <kqr> i'm trying!
20:27:53 <kqr> (is that by the way how list comprehensions work?)
20:27:57 <monochrom> yes
20:28:03 <shachaf> Do you know what "do" means?
20:28:13 <shachaf> That's an important step to understanding code that uses "do".
20:28:19 <kqr> yes, i do
20:28:27 <kqr> i could probably desugar that into binds and lambdas
20:28:40 <shachaf> What you said before seems to indicate otherwise. :-) Please desugar this just to make sure.
20:29:17 <kqr> "abc" >>= (\x -> [1,2,3] >>= (\y -> return (x,y)))
20:29:27 <kqr> > "abc" >>= (\x -> [1,2,3] >>= (\y -> return (x,y)))
20:29:28 <shachaf> Right. OK.
20:29:29 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2),('b',3),('c',1),('c',2),('c',3)]
20:29:31 <kqr> yeah
20:29:36 <mm_freak> kqr: sequence [xs, ys, zs] = do x <- xs; y <- ys; z <- zs; return [x, y, z]
20:29:37 <shachaf> Do you know the definitions of return and (>>=)?
20:29:55 * shachaf still advises understanding the (,) case before worrying about sequence.
20:29:58 <kqr> shachaf, probably not for list, when i think about it
20:30:06 <mm_freak> kqr: 'sequence' acts like an arbitrary-arity liftM*, where the function always constructs a list
20:30:28 <mm_freak> sequence [xs, ys, zs] = liftM3 (\x y z -> [x, y, z]) xs ys zs
20:30:39 <shachaf> kqr: OK, well, one thing that might help is inlining the definitions.
20:30:42 <shachaf> return (x,y) = [x,y]
20:30:52 <mm_freak> shachaf: huh?  no
20:30:57 <shachaf> Er.
20:31:00 <mm_freak> return (x, y) = [(x, y)]
20:31:00 <shachaf> return (x,y) = [(x,y)]
20:31:02 <shachaf> Right.
20:31:04 <shachaf> That.
20:31:12 <shachaf> xs >>= f = concat (map f xs)
20:31:12 <kqr> sure enough
20:31:20 <kqr> oooohhhh
20:32:00 <kqr> starts making sense now
20:33:32 <kqr> yeah i get it now
20:33:34 <kqr> thanks a bunch
20:33:58 <mm_freak> > sequence ["Hh", "Ee3", "Ll1", "Ll1", "Oo0"]
20:33:59 <lambdabot>   ["HELLO","HELLo","HELL0","HELlO","HELlo","HELl0","HEL1O","HEL1o","HEL10","H...
20:34:51 <kqr> it's just mindblowing that something that i'm familiar with from IO and Maybe can be used for something seemingly completely different when applied to list
20:35:53 <mm_freak> kqr: as a more interpretive approach to understanding 'sequence':  each of the sublists contains a nondeterministic value…  the result is a list that contains those nondeterministic values as elements
20:36:53 <startling> kqr: it's not so different from Maybe
20:37:06 <kqr> mm_freak, i'm not sure what nondeterministic value means in this case
20:37:13 <mm_freak> kqr: Maybe is really just [] constrained to at most one element =)
20:37:14 <startling> kqr: many possible results
20:37:36 <kqr> that's true
20:37:40 <mm_freak> think of a MaybeTwo
20:38:00 <mm_freak> > sequence ["h", "e", "Ll", "l", "o"]
20:38:02 <lambdabot>   ["heLlo","hello"]
20:39:28 <kqr> very well
20:39:30 <startling> that's a really nice example.
20:39:32 <kqr> i'll have to sleep on this
20:39:35 <kqr> thanks again
20:40:20 <mm_freak> > do h <- "h"; e <- "e"; l1 <- "Ll"; l2 <- "l"; o <- "o"; return [h, e, l, l, o]
20:40:21 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:40:22 <lambdabot>              with actual type...
20:40:42 <mm_freak> > do h <- "h"; e <- "e"; l1 <- "Ll"; l2 <- "l"; o <- "o"; return [h, e, l1, l2, o]
20:40:43 <lambdabot>   ["heLlo","hello"]
20:40:46 <mm_freak> of course =)
20:44:05 <startling> kqr, do notation might be a better way to understand it
20:44:22 <startling> x <- someList is "for all the elements of someList..."
20:45:41 <mm_freak> > sequence . transpose $ ["HELLO", "hello"]
20:45:42 <lambdabot>   ["HELLO","HELLo","HELlO","HELlo","HElLO","HElLo","HEllO","HEllo","HeLLO","H...
20:47:15 <mm_freak> > sequence . transpose $ ["0.!", "1:?"]
20:47:18 <lambdabot>   ["0.!","0.?","0:!","0:?","1.!","1.?","1:!","1:?"]
20:57:55 <ofan> is there any documentation for fixIO?
20:59:09 <mm_freak> :t fixIO
20:59:10 <lambdabot> Not in scope: `fixIO'
20:59:23 <shachaf> ofan: There's documentation on MonadFix in general.
20:59:39 <shachaf> By documentation I mean: "For a detailed discussion, see Levent Erkok's thesis, Value Recursion in Monadic Computations, Oregon Graduate Institute, 2002."
20:59:58 <cmccann> shachaf: that sure does sound detailed!
21:00:20 <mm_freak> if you don't want to go through a whole paper, mfix/fixIO simply allow an action to refer to its own result…  that works because of laziness
21:00:45 <shachaf> The thesis is actually pretty readable if I remember correctly.
21:01:00 <shachaf> I skimmed it when I was trying to understand MonadFix and it seemed relatively straightforward.
21:01:04 <mm_freak> mfix (\threadId -> forkIO (killThread threadId))
21:14:33 <hpaste> callen pasted “I see cabal still sucks” at http://hpaste.org/80996
21:14:38 <callen> yes, yes I did.
21:15:10 <shachaf> callen: How courageous!
21:15:32 <callen> I just freshly installed Haskell Platform from the main site and tried to do a cabal install cabal-install
21:15:39 <callen> what is going on?
21:22:33 <ofan> shachaf: thanks, I see mfix, I guess it's the same as fixIO
21:22:55 <startling> callen: is your old 'cabal' still around?
21:23:20 <mm_freak> ofan: fixIO is mfix for IO
21:23:34 <mm_freak> :t mfix
21:23:35 <lambdabot> MonadFix m => (a -> m a) -> m a
21:23:39 <mm_freak> replace the 'm' by IO
21:24:43 <startling> IOonadFix IO?
21:25:41 <ofan> mm_freak: yes
21:26:28 <mm_freak> startling: that's wrong
21:28:53 <mm_freak> (forall a m. (MonadFix m) => (a -> m a) -> m a) IO = forall a. (a -> IO a) -> IO a
21:29:28 <shachaf> mm_freak: You could've at least put the m before the a!
21:31:30 <startling> IOIO_freak?
21:31:41 <mm_freak> shachaf: then i would have to flip the type function first
21:31:50 <shachaf> ?
21:32:11 <shachaf> You wrote (forall a m. ...), so you should give the a argument first, if you're "being like that".
21:32:28 <monochrom> or write "forall m a" :)
21:32:28 <mm_freak> uh
21:32:33 <mm_freak> i'm being stupid
21:32:35 <mm_freak> of course =)
21:32:40 <shachaf> That's what I mean by putting the m first.
21:32:51 <shachaf> Anyway, it's pretty confusing to use Haskell syntax like that.
21:32:56 <mm_freak> sure
21:33:09 <mm_freak> but in fact it's not ambiguous =)
21:33:10 <monochrom> I love type application. it is so lazy.
21:33:27 <shachaf> i love monochrom
21:33:29 <shachaf> he is so predictable
21:33:38 <monochrom> no! monochrom is lazy
21:33:54 <mm_freak> we're all lazy…  that's part of the definition of "smart programmer"
21:36:04 <xenocons> mm_freak: does that work on my resume?
21:37:14 <mm_freak> xenocons: it might actually, but it's probably not a good idea =)
21:37:30 <mm_freak> the smaller the company, the more likely it is to work
21:38:35 <xenocons> s/smaller/smarter
21:39:54 <xenocons> imagine explaining it in the interview, 'i uh, only do things as they are required, not before,.. wait i mean, i only do stuff when you ask me, wait... umm'
21:40:27 <xenocons> well actually its also a good strategy to not get interviews at bad companies
21:41:36 <mm_freak> actually i do say the first one, just expressed a little differently
21:41:49 <mm_freak> along the lines of, "i don't waste energy/work"
21:42:00 <cmccann> not doing unnecessary work is a good thing
21:42:15 <cmccann> doing necessary work only at the last minute is not. that is why you have a strictness analyzer :P
21:42:21 <xenocons> hah
21:45:57 <callen> startling: old?
21:46:02 <callen> startling: if it was, how would I fix it?
21:46:26 <callen> startling: time stamp on the binary is from Jan 19
21:53:32 <startling> callen, thought you may have reinstalled without uninstalling the old ghc and cabal
21:54:11 <callen> startling: I did uninstall the old ghc and cabal
21:54:15 <callen> per the script's instructions.
21:54:28 <callen> everytime I come back to Haskell, something new breaks.
21:54:38 <startling> sorry. :/
21:59:55 <kerrick> Is there a common convention for naming the function defined by
21:59:58 <kerrick> (func) x y = y x
21:59:59 <kerrick> ?
22:00:56 <kerrick> e.g. this Stack Overflow post <http://goo.gl/KMu5L> uses the operator "|>"; I'm wondering if this is a common convention
22:01:27 <kerrick> I wish $ would just work this way; it makes more sense to me (it works like a Unix pipe, and is easier to parse reading left-to-right)
22:01:37 <shachaf> kerrick: lens defined (&) for that.
22:01:41 <shachaf> > 1 & succ
22:01:43 <lambdabot>   2
22:02:22 <edwardk> > ("hello",42) & _2 .~ "kerrick"
22:02:23 <lambdabot>   ("hello","kerrick")
22:03:35 <shachaf> Well, yes, lens also defines one or two other operators.
22:04:03 <edwardk> so i've been told
22:04:07 <kerrick> shachaf, ah, cool
22:04:11 <edwardk> i should really get around to learning lens some day
22:04:39 <shachaf> edwardk: Don't bother. It's pretty much impossible for a newcomer these days.
22:04:44 <kerrick> that's actually what I was thinking of calling it, since it seems like one of the few available single-character punctuation symbols
22:05:01 <shachaf> If you call it % yitz will get mad at you.
22:05:01 <Maxdamantus> :t _2
22:05:02 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
22:05:08 <edwardk> shachaf: oh well, i guess the window has passed. maybe i should write my own lens library ;)
22:05:28 <shachaf> edwardk: I've written over a dozen.
22:05:37 <shachaf> i love writing lens libraries. they are so easy.
22:05:45 <edwardk> Maxdamantus: _2 f ~(a,b) = (,) a <$> f b
22:05:56 * shachaf wonders about getting rid of that ~
22:05:57 <kerrick> yitz?
22:06:11 <edwardk> shachaf: this has at least one known downside
22:06:24 <shachaf> edwardk: It does for "both", at least.
22:06:33 <edwardk> including breaking an example
22:06:47 <Maxdamantus> Ah. So it doesn't work for higher numbers of fields
22:06:59 <shachaf> It does in practice.
22:07:00 <edwardk> > (1,2,3)^._2
22:07:02 <lambdabot>   2
22:07:06 <edwardk> > (1,2,3)^._3
22:07:06 <shachaf> Because its definition is more complicated than what edwardk said.
22:07:07 <lambdabot>   3
22:07:11 <sw2wolf> @hoogle lens
22:07:11 <lambdabot> package lenses
22:07:12 <lambdabot> package data-lens
22:07:12 <lambdabot> package data-lens-fd
22:07:15 <edwardk> i just spelled out the instance for pairs
22:07:16 <shachaf> Ugh.
22:07:19 <edwardk> @hackage lens
22:07:20 <lambdabot> http://hackage.haskell.org/package/lens
22:07:22 <shachaf> @hackage lens -- sw2wolf: this
22:07:22 <lambdabot> http://hackage.haskell.org/package/lens -- sw2wolf: this
22:07:24 <Maxdamantus> Ah.
22:07:46 <shachaf> lenses was the crazy one, wasn't it?
22:07:58 <edwardk> lenses used state-> state transformers
22:08:16 <edwardk> accessors used henning's crazy type but has since become more normal
22:08:26 <edwardk> i've stopped thinking about most of the others
22:08:43 <shachaf> Henning's crazy type?
22:08:47 <shachaf> Let me guess what that was called.
22:08:52 <edwardk> T ;)
22:09:12 <shachaf> I was right!
22:09:13 <sw2wolf> shachaf: thx
22:11:26 <Maxdamantus> the diagram on https://github.com/ekmett/lens#lens-lenses-folds-and-traversals has subpixel antialiasing :\
22:12:19 * Maxdamantus wishes things would stop spitting out subpixel antialiased images.
22:12:26 <Maxdamantus> Maybe it's a screenshot .. dunno.
22:12:37 <edwardk> Maxdamantus: i don't get much control over that. it comes out of the tool that way
22:12:45 <Maxdamantus> Hm. Weird.
22:12:54 <Maxdamantus> Yeah. Logo at the bottom.
22:16:45 <johnw> which package providing a Group type class is currently "state of the art"?
22:17:34 <johnw> looks like edwardk wins
22:18:11 <edwardk> be warned the algebra package is pretty brutal to use
22:18:32 <johnw> hmm.. your monoids package says to use reducers
22:18:44 <johnw> is there a Group in reducers?
22:18:50 <edwardk> not currently
22:19:09 <johnw> which package would you recommend?
22:19:12 <edwardk> if you wanted to port more code from monoids to reducers i'd happily take the patch
22:19:22 <johnw> i'm trying to extend IntMap to support an inverse to mappend
22:19:27 <johnw> ok
22:19:31 <johnw> works for me!
22:19:55 <edwardk> you have commit access now
22:20:00 <johnw> tahnk
22:20:07 <johnw> the other day i cloned every github repo you have
22:20:11 <johnw> just to make grepping easier ;)
22:20:11 <edwardk> hah
22:20:48 <johnw> so, i'll start by using monoids to get familiar with it
22:20:56 <johnw> then i'll try to switch to reducers and see what needs to be ported to keep my app working
22:21:20 <shachaf> i love reducers
22:21:22 <shachaf> they are so easy
22:21:34 <johnw> last day, shachaf
22:21:36 <edwardk> if you want to call i can go through the design motivation differences between the two libraries, etc.
22:21:41 <johnw> then the triteness police will come to your door
22:21:48 <johnw> edwardk: that would be great
22:21:58 <edwardk> give me about 2 minutes
22:22:07 <shachaf> johnw: It's still Saturday in proper o'clock!
22:22:11 <johnw> which area code?
22:22:16 <edwardk> 857
22:22:19 <johnw> kk
22:22:48 <cmccann> shachaf lives in his own timezone, where it is always IRC o' clock.
22:23:12 <shachaf> cmccann thinks I never sleep.
22:23:21 <cmccann> well
22:23:21 <shachaf> In reality I sleep 12 hours a day -- every other minute.
22:23:25 <cmccann> maybe you IRC in your sleep.
22:23:39 <Maxdamantus> Has anyone seen shachaf and Batman at the same time?
22:23:52 <cmccann> no, edwardk is batman. shachaf is robin.
22:24:07 <cmccann> this was already established at some point because of some reason.
22:24:10 <shachaf> cmccann: Let's make it Robyn, for rot13-completeness.
22:24:14 * hackagebot htodo 0.0.1 - A todo application.  http://hackage.haskell.org/package/htodo-0.0.1 (YoichiHirai)
22:24:16 <edwardk> =)
22:29:16 * hackagebot htodo 0.0.2 - A todo application.  http://hackage.haskell.org/package/htodo-0.0.2 (YoichiHirai)
22:34:14 * hackagebot htodo 0.0.3 - A todo application.  http://hackage.haskell.org/package/htodo-0.0.3 (YoichiHirai)
22:39:14 * hackagebot imagemagick 0.0.2 - bindings to imagemagick library  http://hackage.haskell.org/package/imagemagick-0.0.2 (AlexanderVershilov)
22:41:36 <monochrom> > rot13 robyn
22:41:37 <lambdabot>   Not in scope: `robyn'
22:41:41 <monochrom> > rot13 "robyn"
22:41:44 <lambdabot>   "ebola"
22:41:50 <monochrom> err
22:42:22 <simpson> Hey, I'm getting a thing ready for release. It does both text and sound things. Which top-level namespace should it go under?
22:44:07 <Ralith> Vague.
22:50:36 <victoredwardocal> g'day
22:56:15 <victoredwardocal> So, I am trying to read XBM (X Bitmap) files in Haskell, as I wish to improve Xmobar so that we may have little icons
22:56:41 <victoredwardocal> Would I be correct to be looking here: http://hackage.haskell.org/packages/archive/X11/1.4.5/doc/html/Graphics-X11-Xlib-Misc.html#7
22:56:49 <victoredwardocal> ?
23:01:06 <geekosaur> no, none of those routines will read or process xbm or xpm files
23:02:45 <geekosaur> but then, xbm files are more than a bit strange.  see the wikipedia entry on them.  (typically they are C source code)
23:05:12 <geekosaur> the subset of C used is highly standardized, so a parser for it is not particularly difficult and you don't necessarily have to drag in Parsec to do it
23:05:21 <victoredwardocal> geekosaur: Hi, oh ok, yea they look weird
23:05:52 <victoredwardocal> Well geekosaur I noticed XMonad has the ability to read it
23:06:28 <victoredwardocal> http://www.haskell.org/haskellwiki/Xmonad/Config_archive/avendael%27s_xmonad.hs
23:06:57 <victoredwardocal> wrapBitmap I am trying to find documentation though..
23:07:05 <victoredwardocal> I don't understand it currently..
23:07:09 <geekosaur> not really, no
23:07:27 <victoredwardocal> oh? so what is happening there?
23:07:29 <geekosaur> wrapBitmap is defined in there, and what it is generating is an instruction for dzen
23:07:37 <geekosaur> which is what's doing the actual reading
23:07:45 <victoredwardocal> so dzen is actally doing the work
23:07:48 <geekosaur>    where
23:07:48 <geekosaur>       wrapBitmap bitmap = "^p(5)^i(" ++ myBitmapsPath ++ bitmap ++ ")^p(5)"
23:08:18 <victoredwardocal> I did not completely understand this line
23:08:33 <victoredwardocal> what does p(5) mean?
23:08:39 <geekosaur> and ^i(...) tells dzen2 to load an icon from a specified bitmap file
23:08:51 <victoredwardocal> right I see
23:08:53 <geekosaur> it's ^p(5) and it's another instruction to dzen2
23:09:11 <victoredwardocal> right right, I don't really know anything about dzen2
23:09:15 <geekosaur> it's the sort of escape sequences dzen2 accepts in strings passed to it for display
23:09:27 <johnw> cmccann: where can I find your 'these' library?
23:09:33 <geekosaur> that passing is done by DynamicLog in the logHook
23:09:38 <victoredwardocal> Now I understand, I did not realise it was a escape sequence
23:10:31 <victoredwardocal> geekosaur: right right, so to get started with this I should make a stand alone program that can read XBM files first?
23:10:52 <geekosaur> as a starting point, probably
23:11:14 * geekosaur should not still be up now but the folks in the room next door are noisy; he cannot promise full lucidity...
23:13:06 <victoredwardocal> geekosaur: oh well, I am so boring I will prob send you to sleep :)
23:15:18 <victoredwardocal> geekosaur: Should I just use cpphs then?
23:15:39 <geekosaur> cpphs won't help
23:16:15 <victoredwardocal> dang, I just noticed its C and preprocessor stuff
23:16:21 <geekosaur> it would let you use #if / #ifdef / #define in your own haskell code; it can't parse actual C code, even the simple stuff in an xbm file
23:16:32 <victoredwardocal> yep
23:16:41 <victoredwardocal> I actually have to write a custom parser
23:17:03 <victoredwardocal> oh well, anywhere I can get a clear spec on exactly what subset I am required to parse?
23:17:49 <geekosaur> parsec can easily parse that file but if you were to submit it for inclusion in contrib it'd be rejected because of the parsec dependency (they'd suggest it for inclusion in xmonad-extras instead)
23:17:59 <johnw> @where these
23:17:59 <lambdabot> data These a b = This a | That b | These a b
23:18:34 <geekosaur> the wikipedia article describes it pretty well:  2 or 4 #defines for the size and the optional hotspot, then the rest is as shown in their example
23:19:11 <nejucomo> I want to sequence monads of Bool so that the whole sequence short-circuits to False as soon as any step does...
23:19:13 <geekosaur> static char icon_name[] = { (list of hex encoded bytes separated by commas) };
23:19:22 <nejucomo> Is there a good way to do this?
23:19:39 <geekosaur> @src all
23:19:39 <lambdabot> all p =  and . map p
23:19:41 <nejucomo> So the type is: Monad m => [m Bool] -> m Bool
23:20:04 <geekosaur> ah, sorry
23:20:12 <nejucomo> geekosaur: Will that run all arguments through the monad?
23:20:22 <victoredwardocal> geekosaur: Isn't this what happy is for, generating a haskell model to parse given a BNF spec?
23:20:23 <geekosaur> sounds like MonadPlus to me, actually
23:20:24 <nejucomo> I specifically want short-circuit because there may be side-effects.
23:20:36 <nejucomo> Thanks, I'll look into it.
23:20:51 <nejucomo> (Actually I just realized there won't be side-effects, but the types don't enforce that...)
23:20:54 <geekosaur> so you realize there's no way to undo a side effect if you hit a False somewhere in the middle?
23:21:36 <geekosaur> you would need to traverse twice:  once to determine that there are no False-s, second time to sequence
23:22:44 <ashu> well Hello everybody :) here is a newbie , was trying to learn haskell , want to know where to start SYSTEMATICALLY
23:22:53 <johnw> @where lyah
23:22:53 <lambdabot> http://www.learnyouahaskell.com/
23:23:15 <nejucomo> geekosaur: Right, the semantics should be if a side effect produces true, continue, otherwise stop at that point.
23:23:25 <geekosaur> victoredwardocal, you can use happy for that, yes, it's a traditional style parser generator as opposed to a parser combinator library like parsec.  whether this is more appropriate I couldn't say
23:24:19 <geekosaur> nejucomo, you may want to look at MonadPlus then.  but I'm too tired to be certain
23:24:44 * geekosaur should probably step away from the keyboard and see if anyone with more functioning brain cells can answer...
23:25:21 <hpaste> Nejucomo pasted “sequencing (m Bool)” at http://hpaste.org/81000
23:25:41 <victoredwardocal> geekosaur: thanks, have a good night. I'll perhaps play with parsec first to get my head around the solution..
23:30:35 <johnw> nejucomo: what about the Monoid All?
23:30:57 <johnw> or MaybeT
23:31:12 <johnw> both will short-circuit their binary operation on a negative result
23:31:22 <edwardk> johnw: making the changes to linear now
23:31:47 <johnw> thanks, I'm ready to push the placeholder into the branch
23:32:03 <edwardk> i'm just doing it to mainline ;)
23:32:03 <johnw> done, it begins!
23:32:19 <johnw> hey, works for me
23:32:24 <johnw> see what I did in sparse
23:32:27 <johnw> may save you some work
23:32:35 <edwardk> k
23:34:35 <johnw> so, all this started just because I wanted an inverse operation to mappend for my sparse vector space :)
23:34:48 <edwardk> heh
23:35:00 <johnw> now I see how you end up producing so many libraries :)
23:35:55 <johnw> "Let's see, I need a library for this; but to do that I can abstract this, and that abstraction could use this new type class, which is general enough for *it's* own library..." -- the edwardk concept
23:36:00 <edwardk> class Functor f => Additive f where  (^+^) :: Num a => f a -> f a -> f a;;   (^-^) :: Num a => f a -> f a -> f a; lerp :: Num a => a -> f a -> f a -> f a  -- with default definitions
23:36:09 <edwardk> in terms of Applicative
23:36:22 <edwardk> then the V2, etc. instances just use the default definitions
23:36:29 <edwardk> and the maps can implement it sparsely
23:37:51 <johnw> push it!  then go back to lens, I didn't mean to distract you with another fascination
23:38:05 <johnw> i'll chew on the sparse stuff
23:38:45 <edwardk> k, it'll be a few more minutes
23:38:56 <johnw> kk, i'll go get a snack
23:39:15 * hackagebot crypto-pubkey-openssh 0.0.0 - OpenSSH public keys parser  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.0.0 (FedorGogolev)
23:47:23 <edwardk> ok, it builds running tests
23:49:17 <johnw> commit! push!
23:49:52 <johnw> ty
23:50:00 <edwardk> pushed
23:50:14 <edwardk> had to resolve conflicts ;)
23:54:10 * M30W wonders how acid state works so nicely over tcp =)
23:57:28 <mysticc> What happend when adding two word32 overflows ?
23:58:00 <M30W> mysticc: it overflows
23:58:05 <simpson> mysticc: Exactly what you would expect.
23:58:09 <M30W> I.e 65536 + 6 = 6
23:58:27 <simpson> > (255 :: Word8) + (43 :: Word8)
23:58:28 <lambdabot>   42
23:58:34 <M30W> (word16)
23:58:55 <simpson> > 65536 :: Word16 -- M30W
23:58:56 <lambdabot>   0
23:58:57 <mysticc> simpson: I mean do I get addition modulo 2^32
23:59:07 <M30W> simpson: Yea.
23:59:09 <simpson> mysticc: You get all operations mod 2^32, yes.
23:59:20 <mysticc> ok thanks
23:59:45 <M30W> > (65536 :: Word16) + (5 :: Word16)
23:59:47 <lambdabot>   5
