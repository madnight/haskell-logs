00:00:27 <shachaf> cmccann: I guess if GHC's optimizer was better it would work!
00:00:38 <shachaf> For some crazy reason it checks the tag even though it shouldn't need to.
00:00:43 <cmccann> shachaf: indeed
00:00:45 <cmccann> how silly!
00:00:54 <shachaf> Should file a bug.
00:00:59 <cmccann> you should file a bug report about not being able to implement unsafeCoerce.
00:01:11 <cmccann> ...
00:01:14 <cmccann> anyway.
00:18:10 <latermuse> is there anyway to do a leftjoin with Data.Map?
00:18:51 <latermuse> ive got two hashmaps with the same keys, but different values, and i want to do computations on the values while keeping the keys
00:19:58 <cmccann> @type M.unionWith
00:19:59 <lambdabot> Ord k => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
00:20:16 <latermuse> <3
00:20:30 <cmccann> see also various other functions along similar lines
00:20:44 <latermuse> thanks cmccann!
00:21:05 <shachaf> If I define a pure-Haskell Concurrent Haskell implementation, how valid would it be to put yield points at >>=s?
00:21:07 <cmccann> I am an excellent source of information.
00:21:11 <latermuse> its my first data.map project, and im brainfarting all over the place. union was so obvious too
00:21:12 <shachaf> Since it's allowed to be "preëmptive".
00:21:30 <cmccann> shachaf: probably going to technically violate monad laws somehow.
00:21:53 <cmccann> though hopefully not in a way that can be observed from the inside.
00:21:54 <shachaf> cmccann: Well, sure.
00:22:05 <shachaf> But IO is a mess anyway.
00:23:56 <cmccann> ok, I added the exponentials to my linear logic thing.
00:24:04 <cmccann> should probably put that on github at some point
00:24:10 <cmccann> instead of just using that old hpaste.
00:24:11 <earthy> wow. "preëmptive". I'd have written that as pre-emptive. :)
00:24:18 <cmccann> shachaf is fancy.
00:24:23 <earthy> or dutch
00:25:28 <cmccann> anyway, I'm out for the night.
00:25:33 <cmccann> good luck breaking the monad laws, shachaf.
00:25:40 <shachaf> cmccann: You should join elliott and my Gobby sessions!
00:25:56 <shachaf> Well, or not. It would probably be a disaster.
00:26:05 <cmccann> yeah.
00:26:10 <cmccann> you don't realize how many typos I make.
00:26:20 <basdirks> even we Dutch don't throw umlauts on that word
00:26:28 <earthy> basdirks: I know. :)
00:26:36 <shachaf> Half of #haskell is Dutch.
00:26:41 <cmccann> I think shachaf just likes unicode.
00:26:42 <basdirks> not even us Dutch*
00:26:53 <earthy> shachaf: half?
00:27:14 <earthy> *holy* cow. 935 nicks.
00:27:30 <earthy> that'd imply 450 dutchies on #haskell
00:28:13 <earthy> given that I know that there's like 1500 people faculty in all of university computer science in the Netherlands that sounds a bit steep. :)
00:29:17 <shachaf> Not everyone in #haskell is university!
00:30:12 <wuttf> No, some of them are working on the Mars Colonization thingie.
00:30:40 <earthy> true. however, the size of university faculty in computerscience is a rough measure of the size of the field
00:31:10 <earthy> let's say there's 150000 IT people in .nl. then *still* 450 seems like a big number.
00:31:40 <SamanthaD> earthy: Maybe the Dutch just have particularly good taste in programming languages.
00:32:11 <earthy> SamanthaD: um. no. :)
00:33:26 <earthy> (cool... that 150000 was not far off the mark at all... there were 140000 jobs in the 'ICT Sector' of which 120000 in software development & production)
00:33:42 <wuttf> How can I Integer -> Int ?
00:33:50 <earthy> wuttf: fromIntegral
00:34:10 <wuttf> earthy: Neat.
00:35:34 <wuttf> SamanthaD: The Dutch have a particularly good taste for everything (see weed legalisation)
00:35:51 <wuttf> I mean how cool those people get?
00:36:17 <latermuse> wuttf: dont forget washington and colorado
00:36:24 <earthy> actually, the production and wholesale of weed is illegal
00:36:26 <earthy> in .nl
00:36:44 <wuttf> latermuse: Yes, USAians are improving too, but only recently.
00:36:44 <earthy> (there's an exception for home growing with a max of 5 plants)
00:37:24 <liyang> > reads "0.1" :: [(Int, String)]
00:37:26 <lambdabot>   []
00:37:26 <SamanthaD> latermuse: As a Californian I'm slightly miffed that they beat us to that. I mean, we have Hayward, Santa Cruz, AND the Height Ashburry! What do they have?!
00:37:30 <liyang> WHY.
00:37:56 <latermuse> SamanthaD: The mormons are big in california. they block that stuff pretty well
00:38:28 <liyang> Why not [(0, ".1")]? D:
00:39:16 <earthy> > reads "\".1\"" :: String
00:39:18 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
00:39:18 <lambdabot>              with actual type...
00:39:32 <earthy> > reads "\".1\"" :: [String]
00:39:33 <earthy> drat
00:39:33 <lambdabot>   Couldn't match expected type `GHC.Base.String'
00:39:33 <lambdabot>              with actual typ...
00:39:36 <shachaf> liyang: "reads" is only for parsing the entire string.
00:39:56 <liyang> shachaf: you mean "read" shurely?
00:40:15 <shachaf> Oh, no.
00:40:24 <shachaf> It's because of another thing, sorry.
00:40:37 <shachaf> > reads "0   .1" :: [(Int,String)]
00:40:39 <lambdabot>   [(0,"   .1")]
00:40:52 <shachaf> Probably looking for some terminatorb.
00:40:58 <liyang> shachaf: yup, I figured out that worked…
00:41:08 <liyang> '.' is a perfectly fine terminator for an Int.
00:43:43 <wbruce> Given data Item = Item String, and a list of [Item], what's the easiest way to get a list of the String values (eg, using map)?
00:44:00 <shachaf> map (\(Item x) -> x)
00:44:14 <shachaf> Or you can define data Item = Item { getItem :: String }, and then map getItem
00:44:34 <wbruce> see, I knew it had to be simple. Thanks, shachaf.
00:46:00 <wbruce> Is there a way to pattern match the String, and have a reference to Item as well? eg, if I was building a Map?
00:46:24 <wbruce> "reference" not being the right word, probably
00:47:09 <shachaf> > let foo x@(y:ys) = (x,y,ys) in f "hello"
00:47:10 <Ralith> wbruce: \(item@(Item string) -> ...)
00:47:10 <lambdabot>   Ambiguous occurrence `f'
00:47:10 <lambdabot>  It could refer to either `L.f', defined at <local...
00:47:12 <shachaf> > let foo x@(y:ys) = (x,y,ys) in foo "hello"
00:47:13 <lambdabot>   ("hello",'h',"ello")
00:47:35 <wbruce> aha
00:47:41 <wbruce> awesome, thanks!
00:50:21 <wuttf> shachaf: What is that @ bussiness?
00:50:53 <shachaf> wuttf: Here, let me demonstrate how it works:
00:50:58 <shachaf> > let foo x@(y:ys) = (x,y,ys) in f "hello"
00:51:00 <lambdabot>   Ambiguous occurrence `f'
00:51:00 <lambdabot>  It could refer to either `L.f', defined at <local...
00:51:04 * shachaf sighs.
00:51:10 <shachaf> > let foo x@(y:ys) = (x,y,ys) in foo "hello"
00:51:11 <lambdabot>   ("hello",'h',"ello")
00:51:23 <liyang> shachaf: would you consider that a bug?
00:51:28 <wuttf> Pattern matching + varname ?
00:51:40 <shachaf> You could call it that.
00:51:42 <latermuse> is there an easy way to sort a list of tuples?
00:51:46 <shachaf> I think Hoogle links to a more detailed explanation.
00:51:51 <shachaf> latermuse: "sort" is pretty easy.
00:51:52 <liyang> shachaf: Hugs has the same feature. :-/
00:51:58 <latermuse> bwahaha
00:51:59 <shachaf> liyang: Does the Report specify it?
00:52:23 <liyang> Let me check…
00:52:38 <shachaf> @unmtl FreeT f m a
00:52:38 <lambdabot> FreeT f m a
00:52:42 <shachaf> Phooey.
00:53:21 <shachaf> liyang: Instead of worrying about that, you could spend your time extending @unmtl to work with Free!
00:53:28 <shachaf> A Useful Service To Humanity.
00:53:58 <liyang> shachaf: I'm working on thyme.
00:54:19 <shachaf> Oh boy, a time library.
00:54:31 <shachaf> Enigmagic likes those.
00:54:41 <shachaf> I've come to the conclusion that >50% of finance is time libraries.
00:54:43 <liyang> shachaf: we don't need another one?
00:54:59 <sclv> probably true
00:55:07 <sclv> but very specific notions of time
00:55:22 <sclv> all day count conventions and business day logic
00:55:40 <shachaf> It sounds awful.
00:55:59 <sclv> straightforward in any sane language
00:56:00 * liyang is happy with the design of "time" but not its performance, and Ashley isn't going to budge on that issue, so…
00:56:22 <shachaf> liyang: Needs more unsafeCoerce?
00:56:34 <sclv> the core design of "time" is fine -- the api/documentation/usability is hellish
00:56:54 <liyang> shachaf: no, just {-# UNPACK #-}!Int64 is fine.
00:57:07 * shachaf is mostly happy not to do have to worry about time.
00:57:26 <liyang> sclv: what do you find annoying regarding its usability?
00:57:28 <sclv> i suppose for performance issues yeah just straight posix is the efficient thing
00:57:29 <shachaf> Instead I worry about Unicode encodings and such.
00:57:39 <sclv> i always forget how to do straightforward things
00:57:56 <shachaf> @unmtl StateT s m a
00:57:56 <lambdabot> s -> m (a, s)
00:58:16 <sclv> like if i'm using a localtime and want to roll it forward by 30 minutes, that's amazingly hard
00:58:17 <liyang> sclv: straight POSIX doesn't let you talk about calendars. :(
00:58:20 <shachaf> Do I want FreeT of StateT or StateT of FreeT?
00:58:21 <sclv> sure
00:58:30 <sclv> i'm just talking for performance :-)
00:58:49 <sclv> i know there's issues why you can't just add e.g. 30 to a localtime
00:58:59 <sclv> but the "right" thing is insanely nonobvious
00:59:16 <sclv> lots and lots of straightforward tasks involve going through multiple conversions
00:59:50 <liyang> sclv: would lenses help?
01:00:16 <shachaf> Lenses and time are tricky.
01:00:27 <sclv> and yeah, time isn't much help for financial notions of time
01:00:30 <edwardk> we've been toying with time, but it requires improper prisms/lenses
01:00:32 <shachaf> If you want, say, an hours lens, you can't have it "roll over" into the next day.
01:00:36 <sclv> it isn't bad for them, but its not particularly good
01:00:44 <shachaf> Well, or you can do improper things or various sorts.
01:01:19 <sclv> there's a "lensy" notion that would probably help with time, because you're really applying different transformations in different spaces
01:01:26 <b_jonas> I think a come from monad is impossible, but at least I can have a computed abstain from monad.
01:01:38 <shachaf> sclv: Thinking in terms of isomorphisms is probably more reasonable.
01:01:43 <b_jonas> (that's really just a special case state monad)
01:01:56 <sclv> isomorphisms are probably too strong
01:02:01 <shachaf> b_jonas: Why is come from impossible?
01:02:12 <sclv> there's multiple ways to describe the "same" time
01:02:23 <sclv> within a given space
01:02:35 <sclv> carrying structure is a homology group as i recall
01:02:46 <sclv> so arguably that's the core abstraction :-P
01:03:02 <sclv> if someone told me i needed homology groups to do time though, i'd have them committed
01:03:21 <shachaf> Clearly you need cohomology groups.
01:03:24 <sclv> yeah, a come from monad should be straightfoward actually
01:03:25 <tac> what's the basic idea of a homology group?
01:04:07 <sclv> tac: i certainly don't understand it deeply enough to explain it simply
01:04:18 <b_jonas> shachaf: because the come from statements can be hidden anywhere inside functions that the monad can't match against or evaluate
01:04:55 <b_jonas> shachaf: even in a potentially infinite loop
01:04:57 <sclv> well yeah, come from needs to be a monadic effect. i can't be in pure functions
01:05:16 <b_jonas> sclv: even if it's a monadic effect, that's not enough I think
01:05:32 <shachaf> b_jonas: You'll need to some preprocessing, I think.
01:05:38 <shachaf> Just like goto.
01:05:46 <liyang> sclv: back to your original problem… if you stick to UTCTime and adding on NominalDiffTimes, things are convenient enough.
01:06:07 <sclv> edwardk's backward continuation monad or whatever sort of gives you come from iirc
01:06:20 <sclv> liyang: sure. but then i'm sticking to utctime!
01:06:28 * liyang could add an AffineSpace instance for LocalTime.
01:06:38 <sclv> the whole point of the time library is arguably that i don't need to stick to utctime
01:06:40 <b_jonas> shachaf: but you can't do the preprocessing in general because the code can contain come from inside functions to which you can't give a suitable argument
01:06:41 <frerich> What's a good way to wake up a thread which sits in a 'readTChan' call? The onle way I foundw as to throw an exception to the thread, but that seems a little hacky. Right now I'm using a "poison pill" approach (i.e. the chan contains Maybes and if a Nothing is read the thread stops). I wonder whether there's maybe a way to do something like select() (or WaitForMultipleObjects() in the Windows API) .
01:06:46 <sclv> otherwise 90% of the complexity of the library would disappear
01:06:53 <sclv> because utctime is really f-n simple
01:07:10 <shachaf> frerich: Write to the TChan?
01:07:12 <sclv> so if the advice is to use utctime, then excuse the rant, perhaps we should just throw out the library
01:07:13 <b_jonas> as in, functions on the right hand side of a >>=
01:07:22 <shachaf> frerich: Or use `orElse` in STM to block on multiple things.
01:07:26 <frerich> shachaf: Well that's the poison pill method, right.
01:07:29 <sclv> alternately, we could improve using things besides utctime :-)
01:07:41 <liyang> sclv: would a diffLocalTime and addLocalTime help?
01:07:56 <sclv> not sure if that's the right model, but probably
01:08:01 <frerich> shachaf: Hmmm, orElse... I tip-toed around that so far... you think it would be useful here? Let me read up on that.
01:08:07 <sclv> i haven't needed to use time in anger for a while
01:08:38 <shachaf> frerich: "Compose two alternative STM actions (GHC only). If the first action completes without retrying then it forms the result of the orElse. Otherwise, if the first action retries, then the second action is tried in its place. If both actions retry then the orElse as a whole retries."
01:08:42 <sclv> i don't think is just the one thing though. its really that we should go through and just enumerate the types of operations we think should be straightforward across time types, and see which are and which aren't
01:09:25 <sclv> like its not just one missing feature -- its that in general there's not a coherent story for uniform, well documented ways to do standard date/time arithmetic .
01:09:55 <liyang> The problem is that LocalTime can come from UTCTime in some TimeZone, or from AbsoluteTime at an observation meridian. So it's not clear whether we should be adding NominalDiffTimes or DiffTimes to LocalTime.
01:10:54 * liyang generally sticks to UTCTime and only convert to LocalTime for display. 
01:11:15 <liyang> I feel that's how it's intended to be used.
01:11:35 <frerich> shachaf: That looks like it's worth a try, thanks! I skipped orElse so far sinec somebody here mentioned that "It would complicate things". :-}
01:12:21 <sclv> arguably you could add both to localtime, though there may be some subtlety i'm missing
01:12:29 <sclv> nominaldifftime seems the more useful, all told
01:12:38 <liyang> sclv: yes, leap seconds.
01:12:53 <sclv> yes, i know leap seconds are the difference
01:13:13 <sclv> i suppose the argument is with utctimes you take them into account and absoluetimes you don't
01:13:35 <sclv> regardless, you can recover both from a localtime afaik
01:13:40 <sclv> that's all i mean
01:17:38 <liyang> http://en.wikipedia.org/wiki/DUT1 :-/
01:24:09 <liyang> Right, so the Report specifies that reads = readSigned readDec for Int, but not readSigned nor readDec. With GHC readDec "0.1" gives [(0, ".1")] as expected, but readSigned uses lex which consumes the entire "0.1", so fails.
01:42:48 <spacekitteh> hmm... i seem to have a space leak... solving a first order ODE takes about 5gb for 100k samples XD
01:42:48 <liyang> http://hackage.haskell.org/trac/ghc/ticket/7613
01:43:23 <juhp> hayoo is down?
01:43:41 <juhp> erm back up
01:50:57 <yitz> liyang: urgh that bug has probably been around forever. so who knows how much code silently depends on it by now.
01:51:28 <liyang> yitz: is it a feature now? D:
01:51:37 <liyang> It's all grown up.
01:53:53 <hpaste> SamanthaD pasted “Yukon Data Structures” at http://hpaste.org/81059
01:54:05 <SamanthaD> I'd appreciate criticism
01:54:22 <SamanthaD> Especially how I'm implementing the tableau and foundation
01:54:48 <SamanthaD> ... and whether I'm over-typing
02:00:06 <HugoDaniel> hello
02:00:35 <SamanthaD> HugoDaniel: Hello!
02:00:56 <HugoDaniel> :)
02:01:16 <HugoDaniel> im planning to do a xmpp server/client in haskell, anyone interested in teaming ?
02:02:57 <SamanthaD> HugoDaniel: Sorry, I'm still teething when it comes to functional programming. Though... is this going to be a major project?
02:03:09 <yitz> liyang: here's another fun one:
02:03:15 <yitz> > read "5" :: Double
02:03:17 <lambdabot>   5.0
02:03:21 <yitz> > read "5" :: Rational
02:03:23 <lambdabot>   *Exception: Prelude.read: no parse
02:03:28 <yitz> > 5 :: Rational
02:03:30 <lambdabot>   5 % 1
02:03:41 <yitz> > read "5.0" :: Rational
02:03:42 <lambdabot>   *Exception: Prelude.read: no parse
02:04:25 <Ralith> HugoDaniel: you will find that people are much more interested in collaborating when you have done more than plan
02:04:35 <HugoDaniel> Ralith: ok
02:05:43 <HugoDaniel> SamanthaD: no, i just want to have xmpp done in haskell in a way that i can easily use in my projects, no bigger requirements yet
02:06:02 <SamanthaD> HugoDaniel: Though... for the record I'd love to watch someone who knows what their doing plan a decently large project.
02:06:15 <HugoDaniel> i surely don't know what im doing :D
02:06:29 <SamanthaD> HugoDaniel: Yay! Friend! ;)
02:06:33 <HugoDaniel> that pretty much resumes my life, i could write that in my CV, a onliner CV :)
02:06:37 <HugoDaniel> *oneliner
02:15:45 <awestroke> Hello. I am getting a weird error message from a function definition, regarding record pattern packing/unpacking... https://gist.github.com/b7dd3d0137fbf92b85e1
02:17:17 <mikeplus64> awestroke: record field accessors are just fieldname record
02:17:25 <mikeplus64> awestroke: so you want nodes graph, not graph.nodes
02:17:25 <frerich> awestroke: Did you maybe mean "nodes graph" instead of "graph.nodes"?
02:17:38 <wuttf> Strange, I have created some types and in GHC they work fine but in source I get "Ambiguous type variable `a0' in the constraints:"
02:18:11 <awestroke> mikeplus64, frerich: what does nodes graph do here?
02:18:46 <frerich> awestroke: I yields the value of the 'nodes' field of the graph.
02:18:48 <mikeplus64> nodes :: Graph -> [Node w], and is made by that record declaration
02:19:12 <frerich> awestroke: Your 'Graph' declaration defines two functions 'nodes' and 'edges' which... yeah, just listen to what mikeplus64 says :-)
02:19:24 <awestroke> oooh, it implicitly defines functions
02:19:25 <awestroke> thanks
02:20:21 <spacekitteh> does hmatrix have profiling libraries?
02:20:50 <mysticc> Does any virtual package system work on ghc-7.6. I tried virthualenv and cabal-dev but I think they are not updated to work with ghc-7.6
02:24:01 <awestroke> is there a way to directly unpack values from a tuple in GHCi? let (g, v) = funcThatReturnsTuple a b c
02:24:30 <awestroke> I did try exactly that but that bugged ghci out, perhaps it's the correct way anyway
02:24:53 * hackagebot aws-sdk 0.9.1.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.9.1.0 (YusukeNomura)
02:25:56 <wuttf> http://news.ycombinator.com/item?id=5090717
02:26:20 <wuttf> Seems like the beginning of some Haskell bashing
02:26:20 <frerich> awestroke: That looks fine to me, and works in my GHCi, too.
02:28:52 <awestroke> frerich, when I do it and then type "g", I get a prompt or similar at "Graph {nodes = "
02:32:10 <frerich> awestroke: Maybe that doesn't have anything to do with the "unpacking" (I seem to recall some Haskell book called this "deconstructing") the tuple but rather with the string representation of whatever that function returns as the first tuple element?
02:45:13 <Hail_Spacecake> I'm having trouble understanding some stuff about PortNumber
02:45:21 <Hail_Spacecake> :t PortNumber
02:45:22 <lambdabot> Not in scope: data constructor `PortNumber'
02:45:34 <Hail_Spacecake> is PortNumber -> PortID
02:45:51 <Hail_Spacecake> and info PortNumber reports instance Num PortNumber -- Defined in `Network.Socket'
02:46:10 <Hail_Spacecake> and indeed in ghci I can just do something like let port = PortNumber 8080
02:46:26 <Hail_Spacecake> but, if I do sometheing where I explicitly indicate the type is an Int
02:46:41 <Hail_Spacecake> say, read (getArgs !! 2) :: Int
02:46:45 <Hail_Spacecake> I can't pass that value into PortNumber
02:46:48 <Hail_Spacecake> and I'm not sure why
02:47:30 <notdan> In Network.Socket PortNumber is defined like this: http://hackage.haskell.org/packages/archive/network/latest/doc/html/src/Network-Socket-Types.html#PortNumber
02:48:08 <notdan> try specifying a Word16 type
02:48:21 <mikeplus64> Hail_Spacecake: try fromInteger (read (getArgs !! 2))
02:48:37 <saeidw> or rather, intToPortNumber
02:48:37 <mikeplus64> i don't think PortNumber has a Read instance
02:49:02 <saeidw> also defined in Network.Socket
02:49:08 <mikeplus64> also getArgs won't work like that
02:49:21 <Eylith> Hello World
02:49:25 <Hail_Spacecake> er, yeah, that'd have to be something I bound to the value of getArgs
02:50:26 <Hail_Spacecake> okay, hm, if I add fromIntegral in there it works
02:50:40 <Hail_Spacecake> but I don't understand why I need to add the fromIntegral in there if I'm reading an int directly
02:50:50 <Hail_Spacecake> but I can type in a literal number in ghci and have that work unproblematically
02:50:53 <hpaste> marekw2143 pasted “default_context” at http://hpaste.org/81060
02:51:11 <marek__> hello, how does it happend that pasted "hello" function just returns "Just 3" ?
02:51:11 <Hail_Spacecake> I don't need to do let myPort = PortNumber $ fromIntegral 8080, I can just do let b = PortNumber 8080
02:51:30 <marek__> does (+) is defined for Maybe in some special way ?
02:51:46 <mikeplus64> Hail_Spacecake: you should be able to just do read somestr :: PortNumber
02:51:56 <marek__> I mean paste: http://hpaste.org/81060
02:52:17 <Hail_Spacecake> mikeplus64 that doesn't work at all
02:52:35 <mikeplus64> oh oops
02:52:38 <mikeplus64> misread Real as Read
02:53:10 <mikeplus64> Hail_Spacecake: the reason is PortNumber has an instance for Num so it gets number literals natively
02:53:29 <fmap> marek__: (+) isn't defined for Maybe at all
02:53:30 <saeidw> :t Network.Socket.PortNumber
02:53:31 <lambdabot>     Not in scope: data constructor `Network.Socket.PortNumber'
02:53:37 <saeidw> bah
02:53:47 <Hail_Spacecake> so why can't I read my string as a num?
02:53:49 <marek__> fmap: so how  does it results in "Just 3"?
02:54:27 <fmap> marek__: well, a is 1, b is 2, return is Just -> return (a + b) is Just 3
02:54:38 <Hail_Spacecake> if I try PortNumber $ read "8080" :: Num, that says expecting one more argument to Num
02:55:00 <marek__> fmap: ohh, I thought that "a" is "Just 1"
02:55:21 <mikeplus64> Hail_Spacecake: PortNumber $ read "8080" :: PortNumber
02:55:22 <mikeplus64> Num is a class constraint thing
02:55:28 <marek__> fmap: forgot how "<-" works, thanks<!
02:56:19 <notdan> marek__: one could also write Just 3 >>= \a -> Just 4 >>= \b -> return (a+b)
02:56:22 <fmap> marek__: `x <- f' is "execute action f, bind its result to x"
02:56:26 <saeidw> Hail_Spacecake, intToPortNumber $ read "8080" :: Int
02:56:39 <Hail_Spacecake> where is intToPortNumber defined?
02:57:01 <saeidw> http://hackage.haskell.org/packages/archive/network/latest/doc/html/src/Network-Socket-Types.html#intToPortNumber
02:57:40 <mikeplus64> intToPortNumber = fromIntegral :p
02:58:03 <saeidw> pretty much, but it also applies htons
03:02:36 <ahihi> intToPortNumber isn't exported, is it?
03:02:53 <ahihi> fromInteger . read should work
03:03:37 <saeidw> yeah, I just noticed it isn't :/
03:05:07 <Eylith> I need an explanation : what's the difference  ? let (_:(x:_)) = (10, "abc") in x and let (_,(x:_)) = (10,"abc") in x
03:06:04 <ahihi> the first one is a type error, because (:) is the constructor for lists, not tuples
03:06:30 <Eylith> I guess this is what I don't get, tuples isn't lists ?
03:06:35 <ahihi> no
03:06:52 <ahihi> tuples hold a fixed amount of items, possibly of different types
03:06:59 <ahihi> lists hold a varying amount of items, all of the same type
03:07:16 <Eylith> Tuples are size fixed ?
03:07:39 <Eylith> Ok, thank you
03:08:30 <SamanthaD> Eylith: Also, in a list all the elements must be of the same type. In tuples you can mix types.
03:09:10 <Eylith> I understand, even if I never did the difference before
03:09:26 <SamanthaD> Eylith: The fundamental difference between lists and tuples is that tuples allow you to mix types in the elements. Tuples' fixed size is just a consequence of the type system.
03:09:29 <Eylith> sorry for my broken english btw
03:09:38 <SamanthaD> Eylith: It's okay
03:10:15 <wuttf> How to properly nest case ... of constructs? "Pattern match(es) are overlapped"
03:10:38 <shachaf> wuttf: I recommend not overlapping your pattern matches.
03:10:44 <shachaf> (What else can I say?)
03:10:58 <wuttf> You mean case in a case?
03:11:19 <hpaste> keep_learning pasted “Haskell type checker example” at http://hpaste.org/81061
03:11:20 <quicksilver> that error has nothing to do with the fact your cases are nested.
03:11:27 <shachaf> I mean that GHC said your pattern matches are overlapped, so it would seem that they're overlapped.
03:11:30 <keep_learning> Hello All
03:11:31 <quicksilver> it just means that, at one level or the other, the pmatches are overlapped
03:11:38 <Eylith> SamanthaD> Just to be sure : can you have a list of mixed type element with a variable size ?
03:11:39 <shachaf> quicksilver: It might have to do with indentation of the inner or outer case.
03:11:57 <wuttf> quicksilver: No? I just want to nest my cases, I don't intend to overlap pattern matches
03:12:02 <SamanthaD> Eylith: No. Because it would be impossible to define its type.
03:12:07 <shachaf> But I'm not going to try to mind-read. wuttf should paste their code.
03:12:12 <wuttf> I don't even WTF is overlapping pattern matches
03:12:17 <keep_learning> I am trying  problems on http://haskellonline.org/ but getting this error http://hpaste.org/81061
03:12:27 <shachaf> Eylith: It is possible in various ways but it's usually not what you want.
03:12:30 <wuttf> shachaf: Okay.
03:12:44 <Eylith> .. So is it possible or not ? :D
03:12:47 <SamanthaD> shachaf: Oh? How do you make arbitrarily long mixed-type lists?
03:13:14 <shachaf> SamanthaD: Lots of ways, depending on what exactly you mean by "list" and "mixed-type".
03:13:17 <shachaf> For example, [Dynamic]
03:13:29 <Eylith> shachaf> Do you know Qt a bit ?
03:13:31 <SamanthaD> shachaf: Oooooh!
03:13:36 <shachaf> SamanthaD: Uh oh.
03:13:44 <quicksilver> wuttf: it means that one of your cases can never be reached.
03:13:45 <SamanthaD> shachaf: uh oh?
03:13:50 <shachaf> SamanthaD: Forget I said anything about Dynamic. You shouldn't know about it!
03:14:05 <shachaf> Better to learn about existential types or something.
03:14:10 <quicksilver> wuttf: like for example case x of Just y -> "hi"; Just z -> "never happens"
03:14:14 <shachaf> But usually those are a bad idea too.
03:14:22 <SamanthaD> shachaf: Don't worry, I have no intention of tossing type safety out the window for a bit of convenience!
03:14:28 <wuttf> quicksilver: Wow, so I have redundancy here?
03:14:41 <wuttf> quicksilver: Ahh I see
03:15:01 <quicksilver> wuttf: you either have an unreachable case or GHC things you might
03:15:06 <Eylith>  Iguess it's a no
03:15:27 <shachaf> Eylith: Nope.
03:15:29 <wuttf> GHC - the tricky bastard.
03:16:53 <Guest32621> [42,13,22]
03:16:57 <SamanthaD> Eylith: The basic problem is that everything needs a type signature. For example, a tuple (1, "Squeak") would have the type signature (Int, [Char])
03:17:20 <`nand`> keep_learning: the error is relatively straightforward. `Either' is not a data constructor
03:17:23 <`nand`> it's a type constructor
03:18:13 <keep_learning> `nand`, Oh , you mean I have put the Left a or Right a to apply the function on values ?
03:18:17 <typoclass> keep_learning: hi. the problem seems to be that Either can't be used in this way on the right-hand side of a "=". you can only use Left or Right. i'm not familiar with those questions, so Left/Right may or may not be what you reasonably need
03:18:33 * quicksilver thinks that 'Overlapping Patterns' is the wrong name for that warning, it should be called 'Redundant Patterns'
03:18:46 <`nand`> I'm not sure what you mean by “to apply the function”; but yes, Left and Right are the constructors of Either
03:18:49 <typoclass> keep_learning: (scratch that with the "right-hand side of =", it's really everywhere on the value-level)
03:20:21 <keep_learning> `nand`, typoclass  Thank you. This one is working  furry f ( EitherLeft ( Left a  )  )  = EitherLeft ( Left ( f a ) )
03:22:39 <yitz> quicksilver: i actually don't understand what wuttf thought it meant
03:23:43 <yitz> quicksilver: to me "overlapping" always made perfect sense. "redundant" would imply completely repeated, not just overlapping. but i would have figured that wording out, too.
03:24:16 <wuttf> yitz: I would show code but it is laced with unreadable stuff.
03:26:59 <yitz> wuttf: not your code. before you thought the ghc error "pattern matches are overlapped" meant something else. i wasn't sure what you thought it meant. quicksilver thinks that the error message should be fixed to avoid that ambiguity.
03:27:19 <`nand`> I agree that ‘overlapping’ sounds misleading because overlapping pattern matches are really common and perfectly fine
03:27:27 <`nand`> whereas ‘redundant’ gets the point across; that it will never trigger
03:27:42 <yitz> aha i see.
03:28:20 <yitz> something like f _ will almost always overlap with what came before it, and that's ok.
03:28:27 <wuttf> yitz: I am sorry but I can't offer clarification, I am so confused =)
03:29:07 <yitz> maybe "unreachable pattern match" would be better. "redundant" would make me start looking for some kind of repetition.
03:29:18 <yitz> wuttf: no it's ok i got it now. thanks.
03:29:43 <`nand`> unreachable sounds good
03:29:53 <wuttf> Yea I liek that most too
03:30:07 <quicksilver> yitz: but overlapping is perfectly normal and expected style.
03:30:19 <quicksilver> yitz: it's only the completely redundant cases that are not normal.
03:30:20 <yitz> quicksilver: yes i see now what you mean
03:30:24 <quicksilver> unreachable would be fine too
03:31:12 <wuttf> Daamn, I got it. GHC is so clever and I am so stupid.
03:31:34 <yitz> wuttf: hang in there, you'll outsmart it yet.
03:31:52 <seed419> how could I format this to respect the 80 column limit convention? http://ompldr.org/vaDV1aw
03:31:59 <seed419> just curious...the 80th column is highlighted
03:32:58 <yitz> seed419: start the { on the next line, indent a little bit
03:33:15 <`nand`> you could cut down on the indentation for starters, I would write “xTheme = defaultThem” then a linebreak and “  { active...” on the next
03:33:34 <`nand`> you could also interrupt the string and continue it on the next line with ++
03:33:44 <seed419> `nand`: ah good call
03:33:50 <`nand`> or use a multi-line string (with \ before the linebreak)
03:34:10 <seed419> `nand`: no spaces though...wasn't sure how to do it without a space in the string
03:34:25 <seed419> yitz: tried that first but it didn't save much.  I had to indent a ton and it looked odd
03:34:29 <yitz> seed419: you can break strings across line breaks using \, and then another \ on the next line after the indentation. but that's kind of eccentric syntax, so most people use it only as a last resort.
03:34:55 * quicksilver prefers concat or ++ to \string gaps\
03:35:05 <frerich> seed419: An unrelated remark, but I think it wouldn't hurt if you made more use of the type system (e.g. use a 'Color' data type instead of String everywhere).
03:35:08 <seed419> I would have to agree
03:35:26 <yitz> seed419: hmm? just a little more than defaultTheme. in fact, you can even line it up with defaultTheme if you want.
03:35:34 <seed419> frerich: feedback appreciated :)  still new to haskell, so thanks I will look into it
03:35:55 <seed419> yitz: ah okay.  it looked odd to me
03:36:54 <yitz> quicksilver: yeah string gaps are weird
03:37:29 <Mikicacarica> http://fcasroma.blogspot.com/
03:37:36 * `nand` .oO( instance IsString (Free Char ()) -- do { "foo"; "bar"; "bat" } )
03:38:06 <shachaf> `nand`: Free Char?
03:38:11 <seed419> sob.  i'd have to do something goofy like ++ http://ompldr.org/vaDV1bw
03:38:18 <`nand`> shachaf: oops, (Char,)
03:38:23 <shachaf> Ah.
03:38:25 <seed419> such a massive string
03:38:34 <quicksilver> `nand`: ok, string gaps are weird looking, but abusing monad notation for monoidal behaviour is moral turptitues
03:38:43 <seed419> maybe I'll just define the string above as a variable
03:38:45 <shachaf> `nand`: Did you see augustss's BASIC?
03:39:07 <`nand`> shachaf: I might've; link?
03:39:21 <shachaf> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
03:39:29 <seed419> currentFont = "insanely-long-font-string-10-X--131-32-3-23-332-iso10000004-1"
03:39:32 <`nand`> ah yeah, I saw that one
03:39:32 <yitz> seed419: confession. i would just make a special case and put that string on the next line with less indentation. so shoot me.
03:39:45 <shachaf> `nand`: There have been various versions.
03:39:53 <shachaf> That one has a nice abuse of strings.
03:40:27 <seed419> yitz: do you usually always follow that convention limit as well?  I see a lot of people disregard it
03:40:37 <`nand`>     250   PRINT X*X;" You won!"
03:41:17 <seed419> I guess in the big scheme of things it's not that important, but I at least make an effort to try :/
03:41:38 <yitz> haha a new dialect of template haskell
03:42:12 <yitz> seed419: i try to, just because it makes things less messy for me in emacs
03:42:14 <`nand`> in that case I'd honestly consider just breaking 80col
03:42:28 <seed419> I wish I could take a haskell course in college instead of this visual basic nonsense and java
03:42:40 <seed419> silly required courses
03:43:32 <seed419> does haskell have a curses library?
03:44:02 <`nand`> not that I know of. It has an ncurses library, though
03:44:16 <seed419> nice
03:44:38 <`nand`> a few, actually
03:44:58 <`nand`> there's also vty, which is a pure haskell library aimed at terminal apps in the way ncurses is
03:48:07 <seed419> nice vty looks great
03:49:49 <spacekitteh> what is this? "base:GHC.Base.sat_sWO"
04:06:08 <TorosFanny> I writed a Monadic iterate: iterateM f x = sequence $ iterate (>>= f) (return x) it can be compiled, but only take up resource
04:06:36 <TorosFanny> I have to terminate with Ctrl-C
04:07:08 <mauke> makes sense
04:07:08 <opqdonut> in a strict monad (e.g. IO), it will try to produce the whole list
04:07:39 <opqdonut> actually, in any monad it will do that
04:07:51 <opqdonut> since sequence needs to propagate a failure that happens down the list
04:08:18 <opqdonut> > sequence (replicate 1000 (Just 1) ++ [Nothing])
04:08:19 <`nand`> what about ((->) r)
04:08:20 <lambdabot>   Nothing
04:08:36 <frerich> I think my non-existant computer science education is showing, but - what complexity (in big-oh notation) does an algorithm which needs sum [1..n] steps? Like, a naive way to filter out duplicates from a list by taking the head of the list, then checking whether it's contained in the reult, and if it's not appending. The "checking whether it's contained in the result list" part would need to perform first 0 comparisons, then 1, then 2, then three...
04:09:04 <spacekitteh> :/ a computation i'm trying to make should only allocate 3-4 MB..it's allocating 13gb D:
04:09:05 <Botje> sum [1..n] is O(n^2)
04:09:13 <mauke> sum [1..n] == n*(n+1) `div` 2
04:09:29 <mauke> == n²/2 + n/2
04:09:36 <int-e> Botje: huh?
04:09:38 <spacekitteh> +c
04:09:40 <mauke> O(n²)
04:10:25 <frerich> Thanks! Sometimes I regret having dropped out of university to take a job :-}
04:10:26 <int-e> Botje: Sorry. It's right, but not tight, for most Num instances.
04:10:35 <spacekitteh> is there a strict version of scanl?
04:10:53 <mauke> int-e: there's an implicit O( ) there
04:11:23 <shachaf> mauke: Where?
04:12:05 <int-e> Oh, ignore me. Apparently, whenever I see O() I think of runtime rather than values. (It doesn't help that people also say things like "sort is O(n log(n))".
04:13:06 <neutrino_> in context of computer science, i do that too
04:13:13 <neutrino_> i don't in the context of real analysis
04:13:28 <mauke> shachaf: O(sum [1..n])
04:13:39 <int-e> neutrino_: so "sum [1..n] is O(n^2)" is ambiguous then :)
04:14:27 <shachaf> mauke: Hmm, I don't think that's what it means.
04:14:42 <shachaf> mauke: You could also say sum [1..n] = O(n^3), for example.
04:14:44 <neutrino_> int-e: nah, the context here is computer science.
04:14:48 <shachaf> The = isn't real equality.
04:14:54 <mauke> shachaf: irrelevant
04:15:04 <shachaf> It's ∈ or ⊂ or something.
04:15:09 <mauke> the question was about an algorithm that takes sum [1..n] steps, i.e. one in O(sum [1..n])
04:15:12 <srhb> NOt proportional?
04:15:19 <mauke> and that means quadratic complexity
04:16:53 <shachaf> Usually when you say f(n) = O(g(n)) that means something very different from "O(f(n)) is equal to O(g(n))"
04:17:11 <shachaf> (Also we're all being slightly sloppy with notation, but anyway.)
04:17:17 <Hafydd> Slightly
04:19:09 <shachaf> Anyway, never mind.
04:19:10 <int-e> Sometimes I see f(n) \in O(g(n)).
04:19:27 <mauke> int-e: yeah, that's what I use
04:19:29 <int-e> or should that be f \in O(g)
04:19:32 <int-e> :)
04:19:55 <mauke> shachaf: in this case I think the intent was to say O(x) = O(y), not x ∈ O(y)
04:22:08 <absence> is it possible to embed the ghc interpreter (or even compiler) in e.g. a c++ app and use haskell as a scripting language similar to how lua is used?
04:22:22 <srhb> Why isn't it something like T(n) ∝ O(f(n)) ? Seems to make more sense to me.
04:22:57 <shachaf> What does that mean?
04:24:04 <srhb> Perhaps I've misunderstood. Is T(n) not supposed to be the time of the algorithm wrt n?
04:24:18 <b_jonas> absence: well, that's sort of what lambdabot does, so probably yes, but it might not be too practical
04:25:52 <mauke> MarasLy: your irc script sucks
04:26:36 <absence> b_jonas: i thought lambdabod was a haskell program
04:28:18 <absence> b_jonas: ah right, one can call haskell code from c++ of course. so the embedding is done in haskell and then called by (and linked with) the app
04:42:22 <mSSM> I want to rewrite my program to use the State Monad: at the moment, I have two data structures: A mutable vector, and a Data type, which contains a generator MTGen (from mersenne-random), and a value, which is calculated from the elements in the mutable vector. Now I have a function, which takes the generator, produces a random number at a random index, updates the vector with it, and then returns the Data
04:42:23 <mSSM> structure with the new generator + calculated value.
04:43:52 <mSSM> If I want to make a stateful computation, does it make sense to make the State of my program a data structure with {Generator, Mutable Vector, Value}, where a `runState' returns the updated thing?
04:44:13 <srhb> Why keep the mutable vector?
04:44:21 <mSSM> srhb: what do you mean?
04:44:39 <mSSM> srhb: do you ask why I am using it at all?
04:45:04 <srhb> Well, yes, I guess, but also why you would want to keep it once you move to State. You could just use some immutable data structure then.
04:45:59 <mSSM> srhb: I am using it for performance reasons, because I have a very very big number of read/write actions on it.
04:46:07 <mSSM> And I cannot perform them lazily.
04:46:25 <mSSM> I tried Data.Map, immutable vectors, and lists.
04:47:00 <srhb> Alright. Anyway, you could do as you suggest, yes. I guess I just wouldn't bother if I have to use mutable data anyway.
04:47:45 <mSSM> srhb: at the moment, my function f takes the vector v and the data structure s, updates the vector and makes a new s, and then calls itself with `f v s' '
04:47:53 <mysticc> what does this error mean http://hpaste.org/81062
04:48:06 <mSSM> srhb: you mean, I shouldn't bother going to State ?
04:48:24 <srhb> mSSM: I'm not saying you shouldn't. I'm saying I wouldn't. I'm not sure if that's wise, though.
04:50:35 <srhb> mSSM: In reality I'd probably make it use State with immutable vectors and then decide afterwards if I really did need mutation. :-)
04:54:57 * hackagebot Bookshelf 0.2 - A simple document organizer with some wiki functionality  http://hackage.haskell.org/package/Bookshelf-0.2 (EmilAxelsson)
05:05:44 <spacekitteh> gahhhhhhh
05:05:56 <spacekitteh> i spent the last four or so hours looking for a memory leak in my program
05:06:02 <spacekitteh> turns out it's in hmatrix's mplot
05:29:57 * hackagebot csv-enumerator 0.10.2.0 - A flexible, fast, enumerator-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-enumerator-0.10.2.0 (OzgunAtaman)
05:33:52 <Peaker> "hpaste" package depends on "HAppS" which doesn't seem to exist?
05:35:01 <srhb> Peaker: Correct.
05:35:11 <Peaker> how do I install hpaste then?
05:35:14 <Peaker> trying from github now
05:35:48 <srhb> I assume you rewrite hpaste using Happstack
05:37:56 <Peaker> I think the github hpaste already did that
05:38:00 <Peaker> but for some reason not uploaded to hackage
05:38:17 <Peaker> or maybe it's a different project with the same name, I'm not sure
05:38:28 <mSSM> In the vector package, what is the difference between a) indexing V.(!), b) safe indexing `V.(!?), c) unsafe indexing `V.unsafeIndex' ?
05:38:42 <mSSM> In particular, what is the difference between V.(!) and V.unsafeIndex
05:39:02 <Peaker> oh it's using snap, and author=ChrisDone only, so it's probably a different project with same name
05:39:19 <mSSM> It's pretty clear what (?!) does, but I am at a loss about a) and c) http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed.html
05:39:23 <srhb> mSSM: It says so quite clearly in the haddock. (!) does a bounds check, unsafeIndex does not.
05:39:58 * hackagebot skein 0.1.0.11 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well.  http://hackage.haskell.org/package/skein-0.1.0.11 (FelipeLessa)
05:40:22 <mSSM> srhb: that just means if the index is within the bounds?
05:40:39 <mSSM> srhb: What I don't understand is what would happen if the index is not within bounds in the (!) case.
05:40:47 <mSSM> srhb: (!?) can return Nothing
05:41:10 <srhb> mSSM: Exception. :)
05:42:03 <srhb> mSSM: !? produces a Maybe a, ! produces an a or excepts, unsafeIndex happily segfaults.
05:42:12 <mSSM> srhb: Oh, okay.
05:42:21 <mSSM> unsafeIndex it is then! :D
05:43:01 <neutrino> interesting
05:43:03 <neutrino> i didn't know of !?
05:43:05 <mSSM> srhb: thank oyu
05:43:08 <neutrino> @hoogle (!?)
05:43:08 <lambdabot> No results found
05:43:14 <neutrino> where is !? defined?
05:43:16 <mSSM> hoogle fails
05:43:20 <mSSM> neutrino: http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed.html
05:43:29 <neutrino> does that exist for lists?
05:43:49 <mSSM> neutrino: In general it doesn't give any results from the vector package.
05:44:10 <neutrino> interesting, why does it not?
05:44:40 <mSSM> neutrino: I wouldn't know...
05:44:52 <neutrino> ok
05:44:56 <mSSM> Just whatever I fed it from there so far, none of the results pointed to vector
05:44:58 * hackagebot HarmTrace-Base 1.0.0.2 - Parsing and unambiguously representing musical chords.  http://hackage.haskell.org/package/HarmTrace-Base-1.0.0.2 (JosePedroMagalhaes)
05:47:15 <spacekitteh> i'm pretty fucking annoyed about the lack of a standard library for numerics
05:47:20 <srhb> @hoogle [a] -> Int -> Maybe a
05:47:20 <lambdabot> Prelude (!!) :: [a] -> Int -> a
05:47:20 <lambdabot> Data.List (!!) :: [a] -> Int -> a
05:47:20 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
05:47:28 <srhb> I'm sure it's there somewhere...
05:47:35 <srhb> Of course, it's pretty horrible.
05:47:50 <srhb> spacekitteh: That fucking sucks! Have a cookie.
05:48:03 * spacekitteh omnomnoms it
05:48:18 <`ramses> :t \n -> lookup n . zip [1..]
05:48:19 <lambdabot> (Enum a, Eq a, Num a) => a -> [b] -> Maybe b
05:49:27 <mSSM> spacekitteh:
05:49:34 <mSSM> ^ Haskell ain't used for numerics.
05:49:42 * mSSM learning the hard way.
05:49:44 <spacekitteh> yeah, i know
05:49:57 * spacekitteh is writing a control theory library in haskell
05:50:12 <neutrino> spacekitteh: what are its aims?
05:50:28 <spacekitteh> basically to replicate some basic functionality of the control system toolbox in matlab
05:51:41 <neutrino> never used that. can you explain otherwise?
05:51:43 <spacekitteh> so far i have a general nonlinear time-varying first order differential equation solver (just an rk4 implementation)
05:51:53 <neutrino> ok
05:52:31 <spacekitteh> basically, it's used to design controllers using LTI system theory mostly
05:52:47 <mSSM> spacekitteh: what underlying data structures are you using for that?
05:52:54 <mSSM> spacekitteh: repa, vector ... ?
05:52:57 <spacekitteh> hmatrix
05:53:13 <mSSM> which I think uses vector?
05:53:20 <spacekitteh> yeah i believe so
05:53:43 <spacekitteh> Double -> Vector Double -> Vector Double -> Vector Double -> Vector Double (time -> current state -> control input -> noise -> next state)
05:53:54 <neutrino> spacekitteh: could i use it to find out what the output signal of a circuit with hysteresis would be, given an input signal?
05:54:09 <mSSM> spacekitteh: immutable or mutbale vectors?
05:54:12 <spacekitteh> yeah assuming you have a state space description
05:54:17 <spacekitteh> umm, i'm not sure, immutable i think
05:54:30 <neutrino> i don't think there's a state space, it's just a vector field?
05:54:32 <mSSM> Also, what exactly is Data.Vector.Storable ?
05:54:46 <neutrino> i'm pretty bad with CT though, so i might be misunderstanding something
05:54:57 <spacekitteh> neutrino: x,y coordinates are state variables
05:54:58 * hackagebot HarmTrace 2.1 - Harmony Analysis and Retrieval of Music  http://hackage.haskell.org/package/HarmTrace-2.1 (JosePedroMagalhaes)
05:55:17 <spacekitteh> so basically find dx/dt and dy/dt
05:55:27 <neutrino> ok well given a point x,y and a dx/dt i can tell you dy/dt
05:55:40 <neutrino> dx/dt is given by the input signal
05:55:43 <spacekitteh> i'll show you my code, hang on
05:55:52 <neutrino> it's a series of int or whatever
05:56:13 <spacekitteh> www.bpaste.net/show/71821
05:56:57 <carryni> Good morning everyone. I'm struggling to get my head around partial application of binary operators. When I write ((<) a), is that (a < ...) or (... < a). For a function I would presume the former, but the latter is how it lexically looks in the source code.
05:57:43 <Peaker> carryni, ((<) a) == (a <)
05:57:46 <typoclass> > (> 3) 2 -- carryni
05:57:47 <lambdabot>   False
05:57:55 <typoclass> > ((>) 3) 2 -- carryni
05:57:57 <lambdabot>   True
05:58:49 <srhb> carryni: Putting an operator in paranthesis simply removes it's infix status. The left argument thus becomes the first, the right becomes the second.
05:58:56 <typoclass> hope that's not confusing ... the basic pattern is, the 2 will be put on the side where there's an operator missing: "(___ > 3)"
05:59:02 <mSSM> > flip (>) 2 3
05:59:03 <srhb> carryni: Sections are special.
05:59:04 <lambdabot>   True
05:59:21 <mSSM> lol @ flip
05:59:23 <carryni> typoclass: I don't understand the first one you wrote
05:59:28 <typoclass> carryni: and the addition is that when you do (>) instead of >, you make the operator behave like a function (i.e. all prefix)
05:59:53 <srhb> Sections, ie (3>) puts the argument on the side where you visually see it. Thus it is a function that returns true if 3 is greater than its argument
05:59:55 <typoclass> carryni: (ignore what mSSM says)
06:00:13 <typoclass> >   (3 >) 2 -- carryni, another example
06:00:14 <lambdabot>   True
06:00:34 <typoclass> >   (> 3) 2 -- note that the very first ">" is just so that lambdabot processes it
06:00:36 <lambdabot>   False
06:00:48 <carryni> typoclass: it seems to be you can make it work either way with parens, which is confusing as I'm used to being able to remove parens around a single value without it making a difference!
06:01:01 <srhb> That's what's special about paranthesis.
06:01:04 <srhb> Or, sections, rather.
06:01:54 <srhb> It's quite useful though, here's a function that divides by two: (/2)
06:02:02 <carryni> So I'm doing (all (\a -> a > x) foo), and I can write that as (all (> x) foo), as that's a section?
06:02:17 <srhb> Yes.
06:02:51 <carryni> Got it, thanks everyone. Will read about sections.
06:03:24 <carryni> Sections look almost too good :) You think the compiler can't possibly be that accommodating to let you write like that, and you must need to be more specific.
06:03:41 <srhb> carryni: It is very useful in many cases.
06:04:00 <srhb> carryni: You might be interested in knowing that functions can be made infix with the use of ``
06:04:01 <mSSM> carryni: sections? can you give me a link?
06:04:20 <typoclass> carryni: right. the default is that functions are prefix, operators are infix. to change a function to be infix, suround it with ``, e.g. "elem 6 [1..10]" is the same as "6 `elem` [1..10]". both will give True. to change an operator to be prefix, surround it with (), e.g. "2 + 4" is the same as "(+) 2 4"
06:04:25 <carryni> mSSM: i only just heard about them here - but i found the wiki http://www.haskell.org/haskellwiki/Section_of_an_infix_operator
06:04:55 <spacekitteh> is there a way to plot to gnuplot _without_ generating roughly 200mb of strings for 150k doubles?
06:05:03 <mSSM> typoclass: he shouldn't ignore what I said: flip is in the link I gave
06:05:27 <mSSM> typoclass: oops
06:05:31 <mSSM> the link he gave ^
06:05:31 <carryni> mSSM: i'm a woman
06:05:40 <mSSM> the link she gave ^
06:05:58 <mSSM> w/e, move to finland: they don't distinguish :D
06:06:49 <typoclass> mSSM: in the above context, i thought that introducing flip will only confuse things further
06:07:00 * srhb agrees
06:07:00 <mSSM> typoclass: yes, you are right
06:07:04 <typoclass> mSSM: sorry if that was misjudged
06:07:13 * mSSM is in general confused as hell when it comes to Haskell.
06:07:20 <srhb> mSSM: :P
06:09:20 <mSSM> typoclass: besides, I justified what I wrote with information I got after I wrote it, so you were perfectly right to call me out on that. :)
06:09:54 <typoclass> mSSM: no worries =) we seem to be all agreeing vigorously
06:11:36 <tazjin> I'm in a debate with a friend and he wants to know what makes the String type slower than ByteString or Text, can somebody explain why?
06:11:46 <srhb> String is a simple linked list of characters.
06:11:49 <mauke> tazjin: types have no speed
06:12:06 <tazjin> * operations on String
06:12:52 <typoclass> mauke: i think he's referring to the usual implementations
06:13:16 <mauke> typoclass: they still have no speed
06:13:27 <mauke> tazjin: depends on the operations
06:14:07 <typoclass> tazjin: i think i remember edwardk saying that he did some benchmarks, and in some cases Text turned out to be slightly faster than String, but it was really not a general broad trend. hope i'm not misremembering
06:14:27 <srhb> It obviously depends a lot on what you're doing anyway.
06:15:14 <typoclass> srhb: right. which is really the takeaway. the overly general advice like "use Text, it's faster than String" is always dangerous
06:15:22 <srhb> Sure, definitely.
06:15:35 <srhb> But there are many cases in which it is true.
06:18:29 <typoclass> srhb: sure. anyway, less talkings, moar measurings =)
06:19:08 <srhb> typoclass: Yus.
06:19:25 <hpc> i cried: http://www.qdb.us/53151
06:22:04 <quchen> Is there a reason backticks can only contain single functions? For example, why doesn't   1 `negate . (+)` 2   work?
06:22:15 <opqdonut> simplicity
06:22:33 <opqdonut> but there are some fun hacks to make things like that work
06:22:51 <opqdonut> let me dig up a link...
06:23:33 <opqdonut> kut muutenkin sen suhteen
06:23:36 <opqdonut> oops
06:23:47 <opqdonut> http://hackage.haskell.org/packages/archive/InfixApplicative/1.1/doc/html/Control-Applicative-Infix.html
06:24:29 <opqdonut> heh, haddock renders the operators in a funny way
06:25:16 <quchen> opqdonut: Thanks
06:25:34 <typoclass> opqdonut: oh, that's interesting
06:26:06 <quchen> The module is also pretty basic
06:26:21 <opqdonut> yeah, it's a really simple trick
06:26:22 <quchen> Header's almost as long as the source ;-)
06:26:38 <opqdonut> I thought there was a package on hackage that did the same for pure expressions
06:26:41 <opqdonut> but I can't find it
06:43:44 <liyang> > read "3 % 4" :: Rational
06:43:45 <lambdabot>   3 % 4
06:44:09 <liyang> yitz: I think Rationals are supposed to be written like that.
06:44:15 <ski> > read "3 % (-4)" :: Rational
06:44:16 <lambdabot>   (-3) % 4
06:44:43 <ski> > read "3 % 0" :: Rational
06:44:44 <lambdabot>   *Exception: Ratio.%: zero denominator
06:45:11 <liyang> Yes, Data.Rational.% does check.
06:45:36 <jmcarthur> the most appropriate way to express a rational number is with (/)   :)
06:45:53 <liyang> pi / 0.5
06:46:06 * jmcarthur sighs
06:46:07 <liyang> (Is definitely not Rational.)
06:46:18 <jmcarthur> but neither is  pi % 0.5
06:46:28 <mux> totally beside the point
06:46:37 <liyang> No, because neither nominator nor denominator are Integral. :)
06:46:42 <jmcarthur> right...
06:46:47 <jmcarthur> i don't see the point
06:46:54 <jmcarthur> > pi / 0.5 :: Rational
06:46:56 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
06:46:56 <lambdabot>    arising from a us...
06:47:00 <jmcarthur> you get a type error either way
06:47:21 <jmcarthur> > 3 / (-4) :: Rational
06:47:22 <lambdabot>   (-3) % 4
06:47:39 <liyang> You were objecting to the use of '%'?
06:48:51 <kennyd> > (3 :: Int) / (2 :: Int)
06:48:53 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
06:48:53 <lambdabot>    arising from a use o...
06:48:56 <jmcarthur> yeah. it's just another thing you have to import and it constrains your code unnecessarily
06:48:57 <kennyd> > (3 :: Int) % (2 :: Int)
06:48:59 <lambdabot>   Not in scope: `%'
06:48:59 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
06:49:12 <kennyd> > (3 :: Int) R.% (2 :: Int)
06:49:14 <lambdabot>   3 % 2
06:49:34 <jmcarthur> well, alright, you can define other Ratio types with it
06:54:14 <killy9999> what does CTYPE pragma do?
07:01:57 <rogers_> is there a "IO a -> IO ()" function?
07:02:04 <ion> @type void
07:02:06 <lambdabot> Functor f => f a -> f ()
07:02:13 <ion> Also: _ <- … in a do block.
07:02:18 <rogers_> thanks
07:02:38 <Peaker> I wish that sqlite3 embedded the source in the package and built it, like GLFW-b does
07:02:46 <Peaker> so much nicer than depending on C lib install
07:06:10 <quchen> rogers_: fmap (const ())
07:06:22 <quchen> Or short: (() <$)
07:06:31 <quchen> :t (() <$)
07:06:32 <lambdabot> Functor f => f b -> f ()
07:06:35 <elliott> or in short
07:06:36 <elliott> :t void
07:06:38 <lambdabot> Functor f => f a -> f ()
07:07:08 <quchen> :i void
07:07:14 <quchen> @info void
07:07:14 <lambdabot> void
07:07:21 <quchen> @hoogle void
07:07:21 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
07:07:21 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
07:07:21 <lambdabot> package void
07:07:28 <quchen> Oh, it's in base?
07:09:38 <mysticc> What function converts from Lazy Bytestring to Strict Bytestring
07:10:01 <quicksilver> concat . toChunks
07:10:17 <quicksilver> although I have a feeling there is a direct conversion in recent bytestring libraries
07:10:25 <quicksilver> surprisingly often that's not what you want though
07:12:27 <mysticc> quicksilver: Yeah I will not actually be using it but I have a function which I need to test which outputs lazy bytestring but I also need to apply another function to the output which works on strict bytestring.
07:16:40 <carryni> Is there a guide as to how I can construct my own operators. I don't mean the infix keyword, I mean what symbols it is appropriate to use, and which it isn't, which are already in important use elsewhere, etc. Idiom and style more than technique.
07:22:03 <quchen> carryni: I think edwardk searched Hackage himself in order to find what operators were free to use.
07:22:39 <quchen> To find out what symbols are allowed in general, I'd look directly at the Haskell report. Presumably it's pretty much "no letters, and no leading : and '".
07:22:45 <carryni> quchen: what characters can I use in the first place? I come from Scala, and there they have lots of rules about which characters you can and can't, and including some characters changes the way they fit into the grammar
07:23:48 <quchen> See page 10 of the Haskell report
07:24:21 <quchen> Reserved operators: .. | : | :: | = | \ | | | <- | -> | @ |  ̃ | =>
07:25:25 <quchen> Other than that, anything of the regex form [^:].+ is allowed I think.
07:25:30 <carryni> "An operator symbol starting with a colon is a constructor.", that's new to me - what does that mean?
07:25:47 <quchen> Constructor as in data constructor
07:26:09 <nlogax> Uppercase symbol :)
07:26:22 <quchen> When you encounter something like :%, you immediately know it's not a function in the "calculate stuff" sense, but more like a "Just" or "Cons".
07:26:25 <mysticc> What is the use of NOINLINE pragma. I mean where does it benefit performance wise?
07:26:46 <quchen> mysticc: You don't want to inline unsafePerformIOs for example.
07:26:59 <quchen> At least sometimes.
07:27:25 <mysticc> quchen: What happens if they are inlined?
07:27:49 <quchen> The side effect may occur twice.
07:28:17 <quchen> let a = Debug.Trace "Ha!" 1 in (a,a)
07:28:27 <quchen> If a is inlined here, it's a tuple of two Trace calls.
07:28:40 <quchen> If it's not inlined, it's only one call, whose result is inserted in the tuple.
07:29:05 <flebron> So in trying out the Cont r monad, I did a few things that seemed unintuitive. Suppose I have f = Cont $ \g -> 1 + g 10. It's sort of weird that, in monadic code, the sheer introduction of this line affects everything below it, even if I'm never using the result in x <- f. Is the usual tactic in Cont r to simply feed a function a value, and execute the function passed? That is, something like Cont $ \g -> g k, for some k constant
07:29:06 <flebron>  or variable?
07:29:07 <quchen> (Note that I abused the let statement there. Lets don't work this way.)
07:30:03 <quchen> flebron: Introducing lines in do notation means adding functions to the >>= chain.
07:30:17 <quchen> Same thing with "put 3" - it affects the whole stateful calculation below.
07:30:19 <flebron> right, yes, I ended up expanding it and seeing that was what had happened
07:31:01 <flebron> But I think the usage I had in mind of Cont r is something akin to a more flexible ((->) r), functions that expect (one or more) values before they can run.
07:32:55 <quchen> flebron: I avoid Cont like goto in C, so I'm afraid I can't help you with good practices there
07:33:11 <quchen> If it helps, I probably think it's as weird as you do ;-)
07:33:42 <flebron> My goal is just to explore a few monads to get "used to" enough Haskell. I've gone through LYAH, and I'm in the process of replacing Python with Haskell as my go-to scripting language
07:34:23 <quchen> flebron: Do you understand the basic instances yet, i.e. Maybe, Either, [], Reader, Writer, State?
07:34:49 <quchen> Cont is probably the most exotic one of the basic monads.
07:35:23 <quchen> RWS is also nice sometimes, it's Reader+Writer+State
07:35:27 <flebron> Yeah, I think I do. Maybe is for computations that can fail at some point, Either is a beefed up Maybe with error messages of some type, [] is nondeterminism, Reader is ((->) r), writer is "Let's have a monoid to which we append on every action", and State is... let's just thread some variable which we can update and read at any point.
07:35:56 <flebron> I definitely need more practice with R, W, and S though :)
07:36:06 * osfameron doesn't understand what use Reader is tbh
07:36:16 <quchen> I think Reader is best thought of as independent of ((->) r)
07:36:24 <flebron> a value that is expecting a value to... exist.
07:36:37 <flebron> So (+2) is a Reader value. When you give it a 5, then it exists as 7.
07:36:37 <quchen> It's kind of the same thing, but LYAH insists in using the function interpretation, which is pretty confusing in the beginning though.
07:36:46 <flebron> Whereas (+) is a "Reader unary function".
07:37:24 <quchen> Reader in do notation looks much nicer. The API of Reader provides you with the "ask" function, which fetches the environmental value.
07:37:37 <mSSM> typoclass: besides, I justified what I wrote with information I got after I wrote it, so you were perfectly right to call me out on that. :)
07:37:52 <mSSM> ^ sorry, wrong window
07:47:51 <quchen> flebron: Parsec is also a monad.
07:48:00 <flebron> Should I play with that?
07:48:24 <quchen> Well, Parsec is quite complex, but getting a feeling for how to use it will surely be useful
07:49:15 <quchen> Parsec is like IO in the beginning: it's useful to know how to work with it, but implementation wise it's a little much.
07:49:47 <quchen> RWH has a chapter on writing a parser which teaches you the basics of monadic parsing, and then later there's a chapter on Parsec itself.
07:50:17 <quchen> And then there's that part of the Parsec chapter that tells you you should try not to use it as a Monad, but that's not something you have to be concerned of on your first go ;-)
07:58:54 <`ramses> quchen: why not? Parsec as an applicative parser is not harder then Parsec as a monadic one imho
07:59:42 <quchen> `ramses: I'm not sure. Writing it in do notation was way easier for me a couple of months ago.
07:59:58 <feliperosa> is there a standard way of documenting haskell code?
08:00:00 <quchen> Also he wants some monads
08:00:04 <feliperosa> I mean, a convention
08:00:05 <quchen> feliperosa: Haddock
08:00:15 <int-e> type signatures ;)
08:00:22 <srhb> AND haddock. :P
08:00:27 <feliperosa> oh right
08:00:38 <feliperosa> thank you guys
08:00:43 <`ramses> learning some applicatives along the way would certainly be beneficial to his understanding :)
08:01:19 <quchen> `ramses: Hm. Maybe. I don't know, Applicatives form this weird intermediate state between Monads and Functors.
08:01:39 <quchen> Functor -> Monad feels more natural to me at least than introducing ap along the way.
08:01:58 <quchen> But that's debatable. Anyway, he should read the parsing chapters.
08:02:11 <`ramses> ah no, I really like the Functor -> Applicative -> Monad path lyah takes
08:02:17 <srhb> I feel much the same. I use applicative when I recognize I'm doing something antipatterny with Monad that could be handled in a simpler way.
08:02:22 <srhb> (as quchen)
08:02:56 <`ramses> I often try to start with applicative and switch to do notation when I need bind
08:03:12 <quchen> Crazy I say!
08:03:33 <srhb> I guess it's fundamentally The Right Way (tm) but it's haaard. :P
08:04:04 <magicman> I like how the applicative parsers resemble BNF. In a way.
08:04:30 <wuttf> magicman: +1
08:04:38 <quchen> magicman: Stuff put together by operators?
08:05:01 <quchen> foo | bar    <=>   foo <|> bar
08:05:14 <quchen> Seems legit
08:06:02 <mSSM> Is there any reason why I should use `negate x' rather then `-x' in e.g. `let x = 1; -x' (cf `negate x) ?
08:06:25 <`ramses> > let x = 1 in -x
08:06:26 <lambdabot>   -1
08:06:35 <mSSM> Are there cases where a simple `-x' might not work (outside of stuff like function composition)?
08:06:40 <magicman> Eh, there's the <$> <*> cruft, but a production of F ::= A B 'c' D will generally correspond to a parser f = make_f <$> a <*> b <*> char 'c' <*> d
08:06:43 <`ramses> I think negate is useful for sections
08:07:13 <quchen> `ramses: Negate in sections?
08:07:25 <mSSM> `ramses: Yes, stuff like that comes to mind; I was just wondering if there are any other problems, since -, (-) is kind of a special operator.
08:07:26 <parcs> mSSM: negate exists to be passed into a higher order function like 'map', e.g. 'map negate xs'
08:07:35 <`ramses> to section (-)
08:07:49 <parcs> mSSM: 'subtract' exists for that same purpose
08:07:53 <quchen> Ah.
08:07:56 <`ramses> no wait, I'm saying that wrong
08:08:00 <geekosaur> so, haskell doesn't really support unary operators.  negative numbers are handled by a hack, which means that things you might reasonably expect to work do not (notably, (- 1) is not a section)
08:08:04 <mSSM> > map (*(-1)) $ take 10 [1..]
08:08:05 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
08:08:14 <mSSM> > map negate $ take 10 [1..]
08:08:15 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
08:08:38 <jmcarthur> negate is also how (-1) works
08:08:44 <parcs> > map (-1*) [1..10]
08:08:45 <lambdabot>   The operator `GHC.Num.*' [infixl 7] of a section
08:08:45 <lambdabot>      must have lower prece...
08:08:52 <mSSM> ok
08:08:54 <jmcarthur> (-1) = negate (fromInteger 1)
08:09:00 <mSSM> Thanks
08:11:30 <rogers_> can you have a list of Num a, mixing numbers of different types?
08:11:36 <quchen> Nope.
08:11:43 <quchen> Not with standard lists at least.
08:12:04 <quchen> A list of Nums has type   Num a => [a]
08:12:16 <quchen> Choosing one element to be a fixes the list to that choice.
08:13:49 <rogers_> can I make a NumWrapper type then that wraps numbers of different type, and have a list of that?
08:13:55 <srhb> Yes.
08:14:06 <geekosaur> you can, but you can't do as much with it as you might like
08:15:53 <Lethalman> rogers_, but your list will always be [Wrapper a], and that "a" has to be fixed
08:16:15 <Lethalman> rogers_, maybe you have too look at Typeable or something like that to have dynamic types, not sure though i'm newbie
08:16:42 <geekosaur> you can use a forall, but that als means you dont know about the wrapped thing to do anything with it.  beyond that you're looking at hacks involving Typeable, yeh
08:16:52 <geekosaur> or more prercisely Dynamic
08:16:56 <quicksilver> no you're not
08:17:02 <quicksilver> you have a variety of possible options
08:17:07 <quicksilver> various kinds of existentials
08:17:13 <quicksilver> of which Dynamic is just the most extreme
08:17:19 <quicksilver> or an ADT
08:17:20 <Lethalman> data Wrap = Wrap Int | Wrap Double | ... ?
08:17:50 <hpaste> Quchen pasted “Hetero list” at http://hpaste.org/81070
08:17:57 <quchen> ^ List of different Nums.
08:18:25 <quicksilver> yes, Lethalman
08:18:28 <Lethalman> wanted to say that but I was afraid I misunderstood forall :P
08:18:32 <quicksilver> (that was the 'ADT' option)
08:18:33 <Lethalman> so what I said can be done with forall
08:18:43 <quicksilver> although you need different constructor names
08:19:18 <Lethalman> quchen, isn't it possible to do data Wrap = forall a. (Num a) => Wrap a and then [Wrap] ?
08:19:26 <parcs> existentials are almost never the answer
08:19:28 <quicksilver> yes, it is, Lethalman
08:19:29 <hpaste> Quchen annotated “Hetero list” with “Heterolist compilable” at http://hpaste.org/81070#a81071
08:19:33 <Lethalman> wow
08:19:39 <Lethalman> very nice :D
08:19:42 <quicksilver> which is not very different from what quchen did
08:19:53 <Lethalman> quicksilver, except that's lists only
08:19:55 <quicksilver> he just buried the forall into one constructor of a custom List
08:20:06 <quicksilver> rather than having a generic wrapper and then using normal lists.
08:20:21 <quicksilver> but the key question is what do you actually want to do with the list when you've got it.
08:20:44 <quicksilver> If you want to know which type each element is then data Wrap = WInt Int | WDouble Double | ... may actually be better
08:21:02 <rogers_> quicksilver: I want to pass elements to functions accepting Num a
08:21:31 <quchen> rogers_: That forall dance will carry on.
08:21:31 <quicksilver> for that purpose, the existential will work, yes
08:22:05 <quchen> Mapping over that hetero list will require some fancy type I assume.
08:22:09 <elliott> just getting any Num isn't generally very useful
08:22:13 <elliott> since you can't turn it into anything else
08:22:28 <quchen> like f :: Num b => (forall a. Num a => a) -> b
08:22:31 <scooty-puff> if i have to write part of a module in c and import it in to haskell, to i have to make sure to faux namespace the c functions?
08:22:44 <scooty-puff> i.e. my_package_dostuff(void) vs. dostuff(void)
08:24:18 <`ramses> quchen: can you actually implement such f?
08:24:33 <`ramses> (non trivially)
08:24:36 <quchen> Never tried it.
08:24:48 <quchen> Gotta catch the bus, if you find something @tell me :-)
08:25:06 <`ramses> no time to try atm
08:25:14 <`ramses> figured maybe you knew :)
08:26:19 <yitz> scooty-puff: why?
08:27:12 <scooty-puff> yitz: in case some other package has a c function called dostuff as well - are there kept separate somehow? (i'm not super familiar with .. most of c and symbol resolution)
08:27:24 <scooty-puff> *are there -> are they
08:27:39 <yitz> scooty-puff: haskell uses the regular linker, like c
08:27:54 <yitz> *ghc
08:28:55 <yitz> scooty-puff: if you have a .h file and make it visible in your .cabal, then you can use ffi to import the c functions defined there
08:29:33 <yitz> scooty-puff: if you reveal more than one .h file to ghc and they define function with the same name, you have the same problem you would have in c
08:30:01 <scooty-puff> ok - but if the header is not available, no worries about a non-static c function in a .c file without an exported .h screwing anything up?
08:30:50 <bartavelle> System.Time is from old-time (so probably deprecated), and Time from haskell98
08:30:53 <yitz> scooty-puff: again, should be the same as importing it in c
08:30:58 <bartavelle> isn't there anything from base to handle time ?
08:31:13 <yitz> bartavelle: Data.Time
08:31:22 <yitz> @hackage time
08:31:22 <lambdabot> http://hackage.haskell.org/package/time
08:31:31 <bartavelle> it is not in base
08:31:45 <bartavelle> this means you need an external module for this right ?
08:31:46 <yitz> bartavelle: right not in base. it's in the haskell platform though.
08:31:51 <bartavelle> ok thanks
08:41:00 <aluink> @type join `asAppliedTo` (***)
08:41:01 <lambdabot> Arrow a => (a b c -> a b c -> a (b, b) (c, c)) -> a b c -> a (b, b) (c, c)
08:41:33 <`ramses> :t asAppliedTo
08:41:35 <lambdabot> (t -> b) -> t -> t -> b
08:43:20 <rogers_> given data NumWrapper = forall a. (Num a) :-> WrapNum, how can extract Num a from (WrapNum 1.0) (or pass it to a function accepting Num a) from ?
08:43:34 <rogers_> s/from//
08:44:04 <Lethalman> rogers_, (Num a) => WrapNum a ... no?
08:44:31 <Lethalman> what is :->?
08:47:58 * geekosaur guesses their chat client tried to recognize it as a smiley and did something weird
08:47:58 <rogers_> heh ghc told me its brain exploded
08:48:10 <rogers_> here is what I am trying to do:
08:48:28 <geekosaur> rogers_, as I said earlier, you can use forall but you can't do much with it afterward.  in particular you cannot unwrap it; the forall erases the real tyoe
08:48:30 <geekosaur> type
08:49:03 <hpaste> rogers_ pasted “hetero list” at http://hpaste.org/81073
08:49:22 <rogers_> geekosaur: that is disappointing
08:50:22 <mSSM> Can I somewhere read up on what the hell the ST monad is and what I can do with it?
08:50:30 <`ramses> rogers_: you pattern match "WrapNum [x]", but then [] should have a Num instance?
08:50:31 <mSSM> s/hell//
08:50:42 <geekosaur> also, what you're doing on line 7 that made ghc unhappy is backwards from what you intended, I think
08:51:09 <geekosaur> `ramses, I think theyre trying to add a wrapper, not remove it (which is what pattern matching does)
08:51:10 <mSSM> Does the ST monad have anything to do with StateT ?
08:51:26 <tac> mSSM: they have the similar spirit.
08:51:29 <geekosaur> in all it looks a lot like they're trying to write some other language in haskell, and it's working about as well as one might expect
08:51:55 <rogers_> geekosaur: at line 7 I am trying to extract wrapped Num
08:52:09 <tac> State threads a state through a computation. ST threads an environment of mutable pointers of sorts
08:52:15 <tac> err
08:52:15 <`ramses> geekosaur: but anyway he can't have a list inside a NumWrap, right? (unless he also wrote an Num instance for [])
08:52:24 <tac> mSSM: StateT... no. StateT is a monad transformer
08:53:03 <mSSM> tac: I am confused :D
08:53:03 <geekosaur> `ramses, right, because they're working on the wrong level.  they think they have a WrapNum'd list but they have a list of WrapNum-s
08:53:16 <tac> mSSM: Do you know about monad transformers?
08:53:17 <geekosaur> the T in ST is not the same T in StateT
08:53:26 <`ramses> geekosaur: ok, that's what I was thinking, hence the comment :)
08:53:42 <geekosaur> (ST cannot be a monad transformer, it can only exist at the bottom of a stack of monads)
08:54:01 <mSSM> tac: most likely not
08:54:15 <`ramses> that would be STT (does that exist?)
08:54:20 <geekosaur> it does not
08:54:22 <geekosaur> as I just said
08:54:24 <elliott> you can implement STT with a little bit of unsafePerofrmIO
08:54:25 <tac> mSSM: I would ignore StateT then until you come across monad transformers.
08:54:29 <elliott> but it's inefficient
08:54:31 <elliott> (safe though)
08:54:32 <`ramses> ah, sorry, missed that
08:54:53 <rogers_> in my actual code I have Movable class, implemented by various types. And I want to have a list of Movable objects (whether wrapped or not), and I want to be able to pass elements to all the functions accepting Movable, for example move :: Movable a => a -> Point -> IO ()
08:55:16 <rogers_> I am surprised that this is so difficult (or impossible) in haskell
08:55:20 <tac> mSSM: but ST is pretty simple. It lets you create mutable variable (STRefs... available in Data.STRef), and you can read, write, and update those variables... but unlike IO, you can "erase" the fact you're using mutable data.
08:55:38 <elliott> rogers_: You probably don't want to use a typeclass there.
08:55:47 <geekosaur> rogers_, why?  haskell is strictly typed.  you're trying to make strict typing go away
08:55:52 <elliott> It's likely you're falling prey to the existential typeclass antipattern.
08:56:00 <mSSM> tac: sounds like ufn
08:56:02 <mSSM> fun
08:56:04 <rogers_> elliott: what should I use?
08:56:17 <geekosaur> if you really need to do that, use Data.Dynamic
08:56:29 <elliott> rogers_: Probably a data type, whether a sum type or a record of behaviour. See these for more information:
08:56:37 <geekosaur> but do you *really* need to do that?
08:56:38 <mSSM> tac: I am going to look for a proper tutorial to see if I can understand the concept any better.
08:56:42 <elliott> rogers_: http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F, http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
08:56:48 <geekosaur> or are you just trying to write perl in haskell?
08:56:59 <`ramses> tac: that's "erase" as in encapsulate, right? Not as in actually don't use mutable refs at runtime
08:57:26 <rogers_> geekosaur: how would  strict typing go away? I am not asking to cast Movable to XY, which could fail, I just want to use objects as Movable
08:57:52 <tac> `ramses: erase as in, runST has the type (forall s. ST s a) -> a
08:58:00 <geekosaur> your example is wrapping Nums, you are trying to make a generic number that you can ignore the type of, that is making strict typing go away\
08:58:20 <geekosaur> but what you describe now sounds like trying to emulate objects in haskell and you're tripping over the usual failure points there
08:58:23 <`ramses> tac: I know :) I don't know much more than that about it though
08:58:27 <tac> `ramses: it lets you forget you were working inside a monad ever. And it's also a way to safely let you smuggle destructive IO into pure computations.
08:58:35 <geekosaur> I expect next youll try to abue typeclasses because they sound OO --- or did you already fall into that trap once?
08:59:05 <rogers_> geekosaur: not sure why you singled out perl. this type od polumorphism is supported by pretty much every language I know besides C
08:59:26 <geekosaur> I singled out perl as an example of a language which is very loosely typed (in fact, all but untyped)
08:59:50 <`ramses> tac: can you do IO in ST?
08:59:55 <geekosaur> C will autopromote stuff but variables still have fixed types; assigning a (double) to an (int) variable won;t suddenly make it a (double) variable like in Perl
08:59:58 <aristid> `ramses: not legally
09:00:12 <`ramses> what does that mean?
09:00:24 <geekosaur> but in any case, Haskell is strictly typed, not like all those other languages you know
09:00:27 <tac> `ramses: No. You can only do newSTRef, readSTRef, and writeSTRef
09:00:30 <rogers_> what does loose typing has to do with it? I want to treat objects as Movable (or Num) , and dont expect to cast them to their real type.
09:00:39 <geekosaur> ...
09:00:48 <geekosaur> right, have you gone through LYAH yet>
09:00:49 <`ramses> ah okay, you said you could smuggle IO in
09:00:50 <geekosaur> ?
09:00:55 <tac> `ramses: "under the hood", these are IO operations. However the *interface* for them is pure.
09:01:19 <`ramses> tac: ah okay, that's the image I had of ST, a limited wrapper around IO
09:01:35 <tac> pretty much.
09:02:02 <tac> IO let's you do anything you want to the world.
09:02:13 <rogers_> it seems that the issue in here is that typeclasses arent first class types. you can accept Num a, but you cant have a list of Num a
09:02:23 <geekosaur> rogers_, I'm afraid the fact that you asked that question indicates that you don't understand what is going on
09:02:28 <tac> `ramses ST creates a very small world for you, let's you do anything you want to it, then throws that world away when it's done so no one ever knew it existed
09:02:48 <geekosaur> rogers_, in a ceretain sense you are "correct".  but they are not supposed to be first class types
09:03:02 <tac> rogers_: Num a => [a]    <- doesn't this work?
09:03:04 <geekosaur> you want OO.  you won;t find it here, at least not that way
09:03:14 <mSSM> I asked a question earlier about trying to rewrite my program to be a stateful computation. Now that there are more people here, I would like to post it again.
09:03:24 <tac> if you want something more like OO's polymorphism, you need existential types, tho
09:03:32 <tac> mSSM: ask away
09:03:42 <rogers_> tac yes that is what I wanted
09:03:50 <geekosaur> you want Num to be an OO class.
09:03:56 <geekosaur> it's not, it will not be.
09:03:58 <tac> existential types have kinda shitty support in Haskell, sadly
09:03:59 <srhb> mSSM: Shoot.
09:04:01 <geekosaur> it's not supposed to be
09:04:16 <mSSM> At the moment, I have two data structures: A mutable vector, and a Data type, which contains a generator MTGen (from mersenne-random), and a value, which is calculated from the elements in the mutable vector. Now I have a function, which takes the generator, produces a random number at a random index, updates the vector with it, and then returns the Data structure with the new generator + calculated value.
09:04:27 <geekosaur> there are ways to get what you want (such as HList) but they're not especially friendly
09:04:30 <mSSM> If I want to make a stateful computation, does it make sense to make the State of my program a data structure with {Generator, Mutable Vector, Value}, where a `runState' returns the updated thing?
09:04:37 <mSSM> srhb: You answered that question earlier. :)
09:04:42 <tac> mSSM: vector as in dynamically sized array?
09:04:51 <srhb> mSSM: I know, but I'd like to see more insights :-)
09:04:57 <rogers_> geekosaur: it makes typeclasses a lot less usable though if you cant have a collection of typeclasses and use them in a generic way with the operations they support
09:04:59 <mSSM> tac: fixed size array with tons of read/write.
09:05:20 <geekosaur> rogers_, you;re still imagining that typeclasses are intended for the kidn of OO you want to do
09:05:30 <geekosaur> they are not.  they are not intended to be.
09:05:38 <mSSM> tac: the size of the array doesn't change, but I have something in the vicinity of 10^7 write instances, where one element is changed.
09:05:48 <tac> mSSM: ah, I see. The point is it's mutable.
09:05:57 <rogers_> geekosaur: I also fail to see how would allowing this make haskell any less strictly typed
09:06:06 <mSSM> tac: I have implemented my code with Lists, Maps, Immutable and Mutable vectors.
09:06:15 <mSSM> tac: Mutable vectors are 3 times as fast as immutable.
09:06:16 <tac> mSSM: I don't know about efficiency of it, but doing the state monad the way you have it seems like it should work
09:06:19 <rogers_> geekosaur: yeah they arent, which is a shame
09:06:26 <geekosaur> ...
09:06:35 <geekosaur> I am failing to make my point, I see
09:06:47 <tac> mSSM: If you want a mutable array, though, an STArray would do the job too, I think
09:06:48 <geekosaur> yes, I understand that you want Haskell to be a proper OO languagde
09:07:05 <geekosaur> it's not one and there isn't much interest in making it one
09:07:09 <tac> (OO stands for OOverated :P)
09:08:30 <geekosaur> and, well, most people don't think it's a shame that Haskell ins't an OO language because if they want an OO language, they use an OO language.  Haskell is a pure functional language instead
09:10:26 <elliott> You can do OOP-style programming in Haskell just fine.
09:10:29 <elliott> Nicer than in most OOP language sIMO.
09:10:35 <elliott> You don't use typeclasses to do it, though; you use data types.
09:10:38 <ion> Simon says
09:11:36 <rogers_> geekosaur: geekosaur: you still havent explained what allowing this has to do with strict typing
09:12:34 * tac wonders how OO got to be such an important buzz word
09:12:35 <rogers_> how would making typeclasses first class types make haskell any less strictly typed?
09:13:34 <elliott> "Making typeclasses first class types" doesn't really mean anything.
09:13:36 <rogers_> geekosaur: also dismissing a feature that would make haskell more usable just because that feature is related to OOP and "haskell is not OOP lnaguage" is not very sensible
09:13:55 <tac> elliott: I was about to say just that.
09:14:14 <elliott> rogers_: I don't think this feature would make Haskell more usable.
09:14:15 <tac> Typeclasses are effectively implicit parameters
09:14:24 <elliott> Mainly because you don't seem to understand typeclasses well enough to propose a change to them.
09:15:14 <rogers_> elliott: by first class I meant ability to have a list of typeclasses, and ability to operate on them in a generic way (with operations supported for that typeclass)
09:15:23 <tac> rogers_: Such a thing exists.
09:15:30 <tac> rogers_: They are called existential types.
09:15:31 <elliott> rogers_: A list of typeclasses?
09:15:42 <geekosaur> sigh
09:15:45 <elliott> Your terminology is confused, which makes it seem like your ideas are confused.
09:15:57 <geekosaur> rogers_ wants haskell to be their favorite OO language
09:16:05 <srhb> rogers_: How would sum work on a list with values of type [Int,Double] ?
09:16:11 <rogers_> elliott: yes. If typeclasses were first class types you could have a list od them
09:16:18 <elliott> rogers_: What would that mean?
09:16:22 <srhb> rogers_: Remember that (+) is defined in the instances of the type class
09:16:31 <elliott> I can imagine the type [* -> Constraint].
09:16:36 <elliott> Then [Num, Eq, Ord] would be a list of typeclasses.
09:16:37 <rogers_> geekosaur: you fixate more on terms (OOP) than on usability this would bring
09:16:41 <elliott> I seriously doubt this is what you have in mind though.
09:16:46 <tac> rogers_: http://www.haskell.org/haskellwiki/Existential_types#Dynamic_dispatch_mechanism_of_OOP
09:16:50 <tac> rogers_: ^ This is exactly what you want
09:16:54 <tac> It already exists in Haskell
09:17:00 <elliott> I doubt rogers_ really wants an existential type in this instance.
09:17:06 <elliott> But that's a separate issue.
09:17:41 <tac> elliott: [11:04] <rogers_> geekosaur: it makes typeclasses a lot less usable though if you cant have a collection of typeclasses and use them in a generic way with the operations they support
09:17:48 <rogers_> srhb: that wouldnt work, because you cant add Nums of different types
09:17:50 <tac> ^ This sounds exactly like what Ex. Types give you
09:17:53 <mSSM> tac: I am actually quite happy with the Mutable Vector. I was just wondering if it makes sense to make the computation stateful, to have a cleaner program.
09:17:56 <srhb> rogers_: Exactly.
09:18:12 <mSSM> tac: And then the question is: what should the type (result) of my stateful computation be?
09:18:15 <rogers_> srhb: your point? other things would work
09:18:19 <srhb> rogers_: So type classes have nothing to do with grouping together in one structure things that have (different!) implementations of some functions.
09:18:26 <srhb> rogers_: It's simply a confusion of terms.
09:18:47 <elliott> rogers_: I really think you should become more experienced with the typeclass system before proposing changes to it that don't make any sense. You don't seem to understand its intent at all and are just analogising it to the meaning of "class" used in OOP languages, which typeclasses have very little to do with.
09:19:04 <elliott> Multiple people have told you this repeatedly but you seem to just be ignoring them and insisting it would make the language more usable. It's not productive.
09:19:14 <tac> mSSM: hmm. I would say if you're looking for the "cleanest" way to do something, zoom out until you get to the "pure" interface you want to have
09:19:28 <tac> mSSM: You don't want to have to thread your state forever (and if you do, you probably want some kind of IORef instead)
09:19:34 <srhb> rogers_: Consider also how any function would ever work for anything on your "list of Nums"
09:19:38 <srhb> rogers_: Aside from, trivially, id
09:19:46 <mSSM> tac: What do you mean by `thread'?
09:19:51 <mSSM> (sorry for my ignorance)
09:19:52 <tac> mSSM: I would say, think about the lifetime of your vector object
09:20:09 <geekosaur> mSSM, a thread in this case is a thread of evaluation
09:20:25 <srhb> rogers_: And how about pattern matching? You need to consider what the real type is, but Num is not a type, so what do you do now?
09:20:35 <geekosaur> not a thread in the sense of threaded programming
09:20:38 <srhb> Etc. etc. etc.
09:20:39 <tac> mSSM: all "state" monads work in basically the same way. They pass the state around implicitly. We call that "threading the state"
09:20:52 <mSSM> tac: In my case, the vector object stays alive until the very end of the run, until I get the last value from it. These values are collected in a list, and then processed further.
09:20:56 <tac> right, geekosaur, not at all related to threads :)
09:21:22 <tac> mSSM: if your vector lives from the start of the program until the end, it makes sense to keep it in IO, (in my opinion)
09:21:51 <srhb> Obviously, we could just add primitives like isInt, isDouble, isFloat and friends. That'll tidy things up nicely.
09:22:43 <jmcarthur> if it's dynamic typing you want, we of course have Data.Dynamic
09:22:48 <jmcarthur> have fun with that
09:22:55 <srhb> We lost him. :<
09:22:59 <jmcarthur> ah
09:23:28 <ion> isInteger :: Integer -> Bool; isInteger = const True
09:23:42 <srhb> ion: Helpful :P
09:24:05 <rogers-> elliott you are right I am not too experienced with type classes. but people who are in this channel basically told me what I want can't be done, or can be half-done with what appears to be a hack to rectify this issue.
09:24:19 <srhb> There is no issue. The design is good.
09:24:42 <srhb> You have not yet understood why it is so, but I can't blame you for that at all. It's also not entirely easy to explain it.
09:24:42 <mSSM> tac: Right now, my program mainly acts in the IO monad. I have to say however that that was not a conscious choice. I rather work in the IO monad because I do not know any better.
09:24:45 <elliott> rogers-: There's a difference between the solution you think you need and *any* solution.
09:24:51 <geekosaur> rogers-, I see you paid attention only to the first part of what elliott said
09:24:51 <rogers-> srhb the issue is that I can't have a collection of typeclasses (a list), and treat them in a generic way suitable for that type class. surely I am not the only one who wants to do this?
09:24:58 <elliott> It might be true that you have some specific desire to do a certain thing that won't work well in Haskell.
09:25:08 <elliott> That doesn't mean you can't solve your underlying problem. I gave you several links to resources that might help you.
09:25:17 <elliott> Unofrtunately I haven't seen you describe your problem concretely enough to help more than that.
09:25:29 <srhb> rogers-: What you're saying is ill defined. What you want is to have a heterogenous list that "magically works". It doesn't really exist.
09:25:33 <rogers-> you can accept a typeclass in a function and operate on it generically. is it that weird that I want to have a list of typeclasses and operate on them generically?
09:25:36 <tac> mSSM: I feel you. Moving away from IO (and listening to these crazy #haskell jerks about making as much of your code "pure" as possible) is a bit of an art ;)
09:25:36 <srhb> rogers-: You get strong typing, or you don't.
09:25:54 <mSSM> tac: E.g., mersenne-random has the method `random', which gives me a `IO a', therefore I am in IO where my code needs those random values.
09:26:05 <srhb> rogers-: What? No, you can't.
09:26:07 <geekosaur> srhb, what rogers- is saying is that theirfavorite OO system is the only correct way to think about things, and is trying to "help" haskell by making it think that one approved way
09:26:40 <srhb> geekosaur: Yes, and what I'm saying is that he has not yet understood why he really does not want that, in a less knee-jerky way than you have been. :P Or at least trying very hard!
09:26:44 <geekosaur> and any suggestion that the one approved way might not really be appropriate is ignored as the talk of heathens
09:27:09 <geekosaur> sorry, I get a bit knee jerky when someone persistently ignores that which they really do not want to hear or think about
09:27:31 <srhb> Understood. And fairly so. I'm just irredeemably patient, apparently. :P
09:27:36 <tac> mSSM: If you have your code handy, you could hpaste, and we could give you any tips for obvious refactoring ideas :)
09:27:41 <rogers-> geekosaur well how do you do it in haskell, tell me?  I want to have a list of Movable objects, and I want to pass each element to move :: Movable a => a -> (Int, Int) -> IO (). so far the solution I got recommended was forall hack which doesn't work
09:27:54 <rogers-> I can't do it like that, how can I do it then?
09:28:00 <mSSM> tac: I would actually really appreciate that, but I feel that that is a bit too much to ask.
09:28:11 <srhb> mSSM: not at all
09:28:25 <srhb> mSSM: If we look and go "aaaaah, my eyes!" you get to keep it that way. :P
09:28:30 <tac> mSSM: Well, we're not being paid to help you, but if you're cool, (or we're sufficiently bored at work), we may help you anyway ;)
09:28:34 <geekosaur> I don't think it can be answered in the way you want.  the problem is you are still trying to treat typeclasses as the kind of OO you realy want them to be
09:28:56 <elliott> rogers-: Like I've tried to tell you: the chances you want a typeclass here are slim.
09:29:00 <rogers-> so how would this be done in haskell? what is the alternative? I want to treat a collection of Movable objects as Movables
09:29:05 <elliott> It's impossible to advise further without, e.g. knowing what your typeclass is.
09:29:09 <geekosaur> ^^
09:29:23 <elliott> If you keep insisting on phrasing your question in terms of typeclasses, you'll never find a satisfactory solution.
09:29:23 <rogers-> elliot I will paste, moment
09:29:25 <srhb> rogers-: For instance, say I had a map of game board positions
09:29:45 <geekosaur> what are you really trying to do?  there is very probably a proper functional way to do it, if you can stop focusing on hwo haskell really ought to be thinking lke your favorite OO language
09:29:52 <srhb> ?
09:29:52 <hpaste> mSSM pasted “MC Ising” at http://hpaste.org/81075
09:29:55 <hpaste> rogers_ pasted “Movable” at http://hpaste.org/81076
09:30:09 <mSSM> srhb, tac: here is the monster.
09:30:19 <zett_zelett> Okay, I want to tackle this bug I encountered yesterday where nothing shows up in my ghci-prompt when typing in things after using the `funcPlot` function from Graphics.Gnuplot.Simple. – Is this the right place to ask? If so – how can I start to find out what's been going wrong?
09:30:29 <elliott> rogers-: OK, I notice immediately you can turn Movable into a data type.
09:30:43 <elliott> rogers-: data Movable = Movable { pos :: IO POINT, setPos :: POINT -> IO Movable }
09:30:59 <rogers-> elliot how? I have various different types implementing this
09:31:11 <mSSM> srhb, tac: It is a Monte Carlo simulation, which creates a n*n grid and then flips spins according to the a temperature.
09:31:16 <elliott> rogers-: Any instance Movable Foo can be translated into a function Foo -> Movable. Try it.
09:31:31 <elliott> rogers-: You don't lose any power, because you're forgetting what specific instance you used anyway (because you're packing it into a list of "any movable").
09:33:07 <elliott> rogers-: Now, it may be that just pos and setPos isn't enough functionality for you to consume the list of Movables how you want.
09:33:11 <elliott> But this problem would exist just as much with typeclasses.
09:33:33 <rogers-> elliott you are right that would work, even though it would make general use a more clumsy (having to wrap objects for every use)
09:33:51 <elliott> It's no more clumsy than an existential (constructor becomes a function), and in fact it can be less clumsy.
09:33:53 <tac> mSSM: just breezing over it, I'd say this program is "simple" enough to live in IO.
09:33:59 <geekosaur> we can't know that as we can't see what you're doing with it
09:34:06 <elliott> rogers-: ...because if you only ever use Foo to pass it to your (Foo -> Movable) function, then you don't need Foo at all.
09:34:07 <geekosaur> but I have a feeling you're just doing OO because it's what you know
09:34:11 <elliott> You can just create a Moveable directly.
09:34:17 <tac> mSSM: If you wanted to get it out of IO, ST is probably a good candidate. From what I saw, I think the only *actual* IO you need is for printf
09:34:30 <elliott> But yes, a typeclass definition is only enough to give pointers.
09:34:36 <mSSM> tac: The main function where the magic happens is `mcStep'
09:35:11 <srhb> mSSM: Purely an aesthetic thing, have you considered not indenting your blocks so much?
09:35:28 <mSSM> srhb: I am still working on my coding style.
09:35:33 <mSSM> srhb: I can try to do that, yes.
09:35:42 <tac> heh, srhb indeed. mSSM the initObservables func is a bit awkward :)
09:35:43 <srhb> I think = do \n                                                 foo -- is ugly :P
09:35:55 <srhb> where the \n is followed by a ton of spaces
09:35:58 <srhb> I usually use 2/4
09:36:23 <mSSM> srhb: I never know what to do if I have `function lots of arg u ments = do \n' What now?
09:36:56 <srhb> mSSM: i indent to the n or the t in "function"
09:37:46 <ihm1> does anyone know if snap can be configured to remove comments from html before serving it?
09:37:51 <srhb> mSSM: in mcStep,  pos <- would be aligned at the t in "mcStep"
09:38:06 <rogers-> elliott, your solution works for my case (since I am deciding whether I want to use a typeclass or not). but what if I wanted to do something similar to instances of some typeclass. are you honestly saying you don't think haskell would benefit from having the ability to have a regular collection of those typeclasses, and having the ability to operate on them in a generic way?
09:38:38 <srhb> "operating on type classes" still makes no sense to me
09:38:51 <mSSM> tac: do you mean as in coding style? In general, the part of my program giving me the initial grid and the Energy and Magnetization part of my `Ising` data structure are not worrying me that much, since they are only called once.
09:38:52 <rogers-> srhb by operate I mean pass them to functions accepting those type classes
09:38:57 <elliott> rogers-: It does, if I understand what you mean by "collection of typeclasses" (existentials). I feel it doesn't benefit from the capability much. Newbies misuse it far more often than I find a legitimate use for it myself.
09:39:14 <bergmark> ihm1: any reason you are using html comments instead of the ignore splice?
09:39:32 <mSSM> tac: my program mainly lives in `mcStep' and the functions handing variables down to it.
09:39:40 <ihm1> bergmark: i wasn't aware of that
09:39:46 <bergmark> ok :)
09:39:51 <mSSM> srhb: and do you leave the `do' in the same line?
09:39:58 <geekosaur> rogers-, are you honestly saying that typeclasses are obligated to be whatever kind of OO you are clearly used to?
09:40:05 <srhb> mSSM: do \n <four spaces>
09:40:07 <tac> mSSM: the only effectful computation in mcstep, as far as I can tell, is the update of your grid
09:40:20 <srhb> mSSM: where four spaces is in addition to where the line with the "do" started
09:42:04 <rogers-> geekosaur they aren ot obligated, but it would make them more usable
09:42:14 <mSSM> tac: After `mcUpdate' called `mcStep' n*n times (n*n = total # of elements in the grid/vector), I need to get the latest `energy' and `magnetization' values from `Ising'
09:42:15 <geekosaur> no, they wouldn't
09:42:31 <geekosaur> except to people who insist that haskell is obligated to be their preferred kind of OO language
09:42:35 <geekosaur> which is not what haskell is
09:42:54 <tac> Gotta run, lunchtime :O
09:43:12 <mSSM> tac: `mcUpdate' itself is called `ns' times, so that I end up with a number of `ns' (e,m) tuples.
09:43:14 <rogers-> geekosaur how many times have you mentioned OOP?  your apparent hate for it makes you unable to see benefits it would bring.
09:43:24 <mSSM> tac: Ok, thanks so far.
09:43:28 <tac> mSSM: good luck!
09:43:30 <geekosaur> ...
09:43:37 <geekosaur> rogers-, I'm afriad that comment is very telling
09:43:49 <geekosaur> you just said outright that haksell y=should really be OO
09:43:59 <rogers-> geekosaur and you have yet to explain how would the ability to have a list of Show typeclass capable of being passed to print make haskell any less strongly typed
09:44:07 <mSSM> srhb, tac: if you have any more suggestions, I would be online later on again. :)
09:44:22 <geekosaur> rogers-, that would be because you;d have to stop trying to do OO and look at what haskell actually is, to be able to understand it
09:44:42 <basdirks> rogers-: maybe OO for Haskell is awesome, why not implement it?
09:44:48 <rogers-> geekosaur and you've been dismissing a feature related to OOP simply because it's OOP. interfaces are related to OOP as well, and that is more or less what typeclasses are
09:44:54 <mSSM> srhb: So you are saying that `do' should be in the line after `=' ?
09:45:03 <srhb> mSSM: No, the \n is a newline
09:45:13 <geekosaur> various people *have* tried to explain it to you.  you ignored it, apparently because you;re still trying to find the OO you know has to be there
09:45:31 <geekosaur> rogers-, n, typeclasses are not interfaces.  that's like OOP-think mistake #2 in haskell
09:45:41 <mSSM> srhb: yes, but you are saying "four spaces in addition to where the line with the do started"
09:45:54 <hpaste> srhb annotated “MC Ising” with “MC Ising (annotation)” at http://hpaste.org/81075#a81077
09:46:06 <srhb> mSSM: See annotation, I did checkFlip in the style I would use
09:46:34 <rogers-> geekosaur I said "more or less". that is how LYAH described them in introduction
09:46:46 <mSSM> srhb: yeah, thanks
09:46:59 <mSSM> srhb: hah, that does look nicer
09:47:03 <srhb> mSSM: Using that consistently means "meaningful code" always starts on that outer level rather than arbitrarily depending on how many/long arguments you have
09:47:13 <srhb> I personally think it is nicer.
09:47:20 <geekosaur> they have some resemblances.  those fall apartquickly if you take that to mean you can do OO with them
09:47:54 <srhb> mSSM: Contrary to do, I would push guards to the next line
09:48:22 <mSSM> srhb: Can you give me an example for `transPos' and `calcObservables'?
09:48:27 <mSSM> that is, guards and let
09:48:53 <hpaste> srhb annotated “MC Ising” with “MC Ising (annotation) (annotation)” at http://hpaste.org/81075#a81078
09:48:57 <srhb> mSSM: See mcUpdate for that suggestions
09:49:48 <geekosaur> unfortunately I think we're talking past each other at this point
09:49:58 <rogers-> geekosaur if there is one thing haskell should have taken from OOP, this is it.  we have all this neat generic functionality in typeclasses, but we can't do something as simple as operating on a group of objects that implement
09:50:07 <rogers-> it
09:50:37 <geekosaur> only if that is how you insist on thinking about it.  haskell wants you to think *functionally*
09:50:57 <ihm1> bergmark: does snap have anything to minify css/js?
09:51:27 <srhb> mSSM: calcObservables confuses me, do you mean to use both let and where?
09:51:29 <osfameron> geekosaur: I sometimes wonder why you couldn't think of a functor application using object dispatch as functional still?
09:51:31 <mSSM> srhb: Would you push the let in ` = let ' to the next line? i.e. ` =\n <four spaces>let' ?
09:51:33 <rogers-> geekosaur. I am thinking functionally.  I want to use functions to operate on a list of XY type classes, but haskell doesn't allow me for whatever reason
09:51:33 <Hermit> rogers-: check out existentials
09:51:35 <bergmark> ihm1: not sure, but it should be simple to just run some minimizer on it before serving
09:51:40 <mSSM> srhb: Yeah, I do
09:51:50 <bergmark> ihm1: or to do it statically in production mode
09:52:09 <ihm1> ya; ok, thanks
09:52:10 <rogers-> geekosaur, and please explain how is what elliot suggested me (to use a list of Movable data instead of typeclass) any more functional?
09:52:15 <hpaste> srhb pasted “mSSM” at http://hpaste.org/81079
09:52:17 <geekosaur> no, you are thinking functional-OO.  there are languages which do that (scala and ocaml/f# come to mind)
09:52:29 <srhb> mSSM: The let part is there. Similar for the where part, but pushed further back
09:52:37 <osfameron> geekosaur: how do you explain the difference?
09:53:00 <rogers-> Hermit I have tried that half an hour ago, they don't do what I need
09:53:04 <srhb> mSSM: Good enough? :)
09:53:08 <mSSM> srhb: Yeah, thanks :)
09:53:13 <mSSM> srhb: That does look a lot nicer. :)
09:53:15 <srhb> Great!
09:53:24 <Eelis> rogers-: what do you need?
09:53:36 <geekosaur> you're still thinking fundamentally in terms of manipulating abstract objects, and I'm somewhat at a loss to see how to get past that
09:53:42 <srhb> mSSM: If you use Emacs, marking big let blocks like that and doing M-x align-regex <ret> = <ret> is pretty awesome
09:54:21 <mSSM> srhb: vim here... I suppose it would work somehow there as well
09:54:34 <srhb> mSSM: yes. :P Somehow.
09:54:43 <Lethalman> rogers-, http://www.haskell.org/haskellwiki/Existential_type#A_short_example
09:54:48 <Hermit> rogers-: I'd scroll and read the whole thing but a lot has been said, and by the time I end reading the conversation may have ended as well. So... what do you want to do?
09:54:52 <rogers-> gekosaur which is exclty what elliott's suggestion does, data Movable being abstract object
09:55:20 <mSSM> srhb: But you wouldn't say, that I need to push everything after = ? For example, can you have a look at `makeWeight' ?
09:55:30 <srhb> mSSM: Sure...
09:56:00 <rogers-> Hermit I had a Movable typeclass, implemented for various types. and I wanted to have a list of Movable objects, and then do generic operations on them (such as pass them to move :: Movable a => a -> Point -> IO function)
09:56:28 <geekosaur> osfameron, I am not sure I can compose a short summary, which is why I'm kinda at a loss here
09:56:39 <srhb> mSSM: I generally dislike the structure of that thing.
09:56:39 <Eelis> rogers-: and you don't see how existentials let you do that?
09:56:55 <elliott> I think it's fine to think in terms of abstract objects. Haskell is pretty good at that.
09:56:59 <elliott> Not to say it's always the right approach.
09:57:09 <mSSM> srhb: It's very nested :D
09:57:10 <Hermit> rogers-: an existential type can do exactly this. In short, an existential let's you make heterogeneous lists based on common typeclasses those types share
09:57:19 <geekosaur> but the notion of object in question is not the same
09:57:20 <srhb> mSSM: yes :P
09:57:26 <osfameron> geekosaur: fair enough.  I'm mostly not attempting to do anything where I want OO-functional in haskell at the mo, but it's confused me previously...
09:57:33 <geekosaur> explaining that is where I'm not sure how to proceed
09:57:38 <feliperosa> what's the best way to parse strings in haskell? (like doing formatted input in any language like C++)
09:57:47 <rogers-> well I have tried using existential type but couldn't make it work, and no one said it's possible so I just assumed it isn't.
09:57:53 <mSSM> srhb: Do you have a suggestion what I should do with it? Break it up?
09:57:53 <elliott> feliperosa: Take a look at Parsec.
09:58:00 <Lethalman> rogers-, I've just linked you
09:58:02 <elliott> rogers-: Anything you can do with the data type I gave you can do with an existential. It'll just be uglier.
09:58:02 <Eelis> "no one said it's possible so I just assumed it isn't" <-- this is not wise
09:58:03 <Lethalman> rogers-, read that link
09:58:08 <elliott> (Well, more or less.)
09:58:30 <elliott> I still seriously doubt a typeclass is the best solution here.
09:58:41 <geekosaur> an abstract "object" in Haskell is not going to behave like an OO Object, and trying to apply OO thinking to it directly isn't going to work.
09:58:44 <hiptobecubic> I'm confused about this
09:58:58 <hiptobecubic> Can someone tell me what they think rogers- wants?
09:59:00 <geekosaur> unless you go with something like how OOHaskell did it
09:59:11 <geekosaur> which is HList under the covers
09:59:59 <elliott> hiptobecubic: I don't think anyone knows what rogers- wants :)
10:00:27 <Eelis> speaking of "heterogeneous" lists, is there a way to do this without data/newtype?:  http://codepad.org/fVlOZJOF
10:00:53 <srhb> mSSM: I'm not sure. I think it's just abominable :P
10:00:59 <hiptobecubic> rogers-, it sounds like you want to have a list of things which implement Num
10:01:26 <Hermit> Eelis: how would you say [Showable] then?
10:01:29 <hiptobecubic> So that you can write generic functions that work on "Nums" and just pass in this list without specifying the concrete type?
10:01:29 <rogers-> hiptobecubic that was a simplified example, but yes I wanted to have a list of typeclasses of different types
10:01:43 <rogers-> yes
10:01:45 <Eelis> Hermit: ideally i'd define   type Showable = exists a . Show a => a
10:02:10 <hiptobecubic> rogers-, and so a list like [1, 2.5, (5 % 6)] should be possible because they all implement Num?
10:02:11 <mSSM> srhb: Didn't you learn that you shouldn't comment on the looks of other parents' children (no matter how ugly they are)? :D
10:02:33 <Eelis> Hermit: it's the extra constructor wrapping that i'd like to avoid
10:02:36 <Eelis> because it's fugly :)
10:02:45 <rogers-> hiptobecubic yes.  with the limitation of being to treat each element as a Num, not as underlining type
10:02:51 <Hermit> Eelis: then you wouldn't have an existential constructor
10:02:52 <rogers-> +able
10:03:00 <srhb> mSSM: Sorry :P
10:03:02 <elliott> Eelis: There is a way.
10:03:05 <elliott> Eelis: type Showable = String
10:03:07 <hiptobecubic> rogers-, so we only consider them to be of type (Num a => a), yes?
10:03:11 <Eelis> elliott: very funny
10:03:15 <rogers-> right
10:03:16 <elliott> l :: [Showable]; l = [show 3, show 'x']
10:03:18 <elliott> Eelis: I'm not kidding.
10:03:28 <elliott> Eelis: That "Showable" type should never be in any code; it's simply a mistake.
10:03:38 <elliott> String is much easier to use and just as easy to create.
10:03:46 <Eelis> elliott: your answer was a joke because it doesn't work for other less trivial type classes
10:03:47 <srhb> mSSM: It's still slightly prettier if you follow my rules.
10:03:48 <Hermit> Eelis: you would get implicit existential construction and would then be screwed when trying to retreive a type if you don't have a real constructor
10:03:58 <hiptobecubic> rogers-, ok. What do you imagine one could do with such a list? Given that you have no idea what type they are or whether or not they are of the same type?
10:04:11 <mSSM> srhb: yeah, it is
10:04:14 <mSSM> srhb: thanks a lot
10:04:27 <Eelis> ah, wait, i think i already had this problem once and solved it slightly better than Showable
10:04:29 <srhb> mSSM: Something like http://hpaste.org/81080
10:04:29 <hiptobecubic> you can't use any of the binary operations of num unless you are just using the same element twice i guess
10:04:30 <Lethalman> hiptobecubic, he can do multiplication and sum :P
10:04:31 <mSSM> srhb: I found myself reindenting my code all the time after I have changed the name of an argument to a function
10:05:06 <Hermit> Eelis: how
10:05:20 <rogers-> hiptobecubic not much, because you can't operate on Nums of different types. but take a different example, a list of Show typeclasses.  each one could be passed to a print function.
10:06:02 <Eelis> Hermit: http://codepad.org/0SxAfR3W
10:06:09 <Hermit> rogers-: I know geekosaur confused you, but what you want is an existential type. Read the link Lethalman gave you
10:06:12 <rogers-> (or in the actual code I am writing, a list of Movable typeclasses could be moved around by passing them to move :: Movable a => a -> Point -> IO ()
10:06:40 <Hermit> rogers-: bear in mind they have some limitations though...
10:07:15 <rogers-> Hermit yeah I realized by now existential type could make it work. I bookmarked that page
10:07:22 <Hermit> Eelis: wait, that would break for a type that doesn't implement Show
10:07:30 <Eelis> Hermit: break?
10:07:36 <feliperosa> elliott: Do you recomend any tutorial on Parsec? I'm just looking for some on google.
10:07:45 <feliperosa> elliott: Thanks, btw
10:07:49 <Hermit> errr
10:07:58 <Eelis> Hermit: the point of Any Show is to be able to contain a term of any type that implements Show :)
10:08:03 <Hermit> Eelis: sorry, missed the c parameter in the type
10:08:03 <srhb> mSSM: Yeah, that's a bad sign. :P
10:08:07 <Eelis> Hermit: ah ok
10:08:17 <elliott> feliperosa: I think the only parsec tutorial is a really ancient one that still sort of mostly works. :/
10:08:20 <elliott> I don't have a link off-hand.
10:09:06 <feliperosa> elliott: Ok, I"ll keep searching :)
10:09:27 <Hermit> Eelis: nice. It'd be nicer if one could do  Any (Num, Ord)  or something like that (I know the syntax is nonsensical)
10:09:35 <Eelis> Hermit: i think that may work
10:10:05 <wbruce> I'm getting a weird error from cabal build after breaking up a library i'm building (System.Evidence) into a set of hierarchical modules. https://gist.github.com/bff0fb5fadf636d39a0c
10:10:14 <Eelis> or at least i've seen some context where putting class constraints in "tuples" created the intersection of those constraints
10:10:49 <Hermit> Eelis: hmm, never seen that
10:10:51 <dcoutts_> wbruce: most likely, you didn't list all the modules in the new lib you made
10:11:32 <wbruce> dcoutts_: So, ie, other-modules in my .cabal
10:11:40 <dcoutts_> wbruce: and from the symbol name, you can tell that it's the module System.Evidence.Resolvable that was not listed
10:11:42 <Eelis> Hermit: i can't get it to work :)
10:12:02 <Hermit> Eelis: I'm thinking about it too
10:12:07 <wbruce> What an unfriendly way it has of letting me know ;) Thanks; will try that.
10:13:43 <wbruce> dcoutts_: That was it; wonderful. Thanks again.
10:14:32 <dcoutts_> wbruce: one day cabal will do module dependency analysis and so will know when you forgot to list all the modules
10:15:38 <geekosaur> rogers-, another thing I should mention:  I'm not opposed to OO, but when a Haskell beginner starts throwing around OO it is usually a symptom that they are trying to force Haskell to be some other language instead of trying to learn Haskell
10:16:30 <geekosaur> and, well, that's not really productive
10:16:49 <rogers-> geekosaur it looks like I am not the only one who thinks this would be useful, that is why we have ExistentialQuantification
10:16:54 <parcs> Hermit: you can have a conjunction of things of kind Constraint (eg (Num Int, Ord Int)) but not a conjunction of things of kind * -> Constraint (eg (Show,Num))
10:16:56 <hpaste> mSSM pasted “Compare” at http://hpaste.org/81081
10:17:03 <mSSM> srhb: ^
10:17:04 <wbruce> geekosaur: seems like an excellent way to avoid learning. I have to consciously stop myself from going down that route sometimes.
10:17:13 <Eelis> i think that it's perfectly understandable that once one has written some (unary) type class, one wants to make a list of objects of (differing) types that all implement the type class
10:17:14 <mSSM> srhb: prettier?
10:17:42 <Eelis> i don't think there's anything particularly OO about it
10:18:24 <Eelis> and it's sad that we have to point people to something called "existential types" just to let them do that
10:18:25 <Hermit> parcs: makes sense regarding the kind, but I'm still not seeing how (Num Int, Ord Int) would be useful
10:18:56 <Hermit> Eelis: agreed
10:19:20 <alfiangozali> test
10:19:32 <srhb> alfiangozali: Test yourself.
10:19:47 <Eelis> if only we had dependent types and first class type classes, then we could define that Any properly ;) (it's called sigT in Coq, for example)
10:20:10 <Eelis> without any funky extensions, but using the core language facilities
10:20:11 <srhb> mSSM: I prefer version two, but I would probably align that with the actual definition
10:20:18 <Hermit> after all, type safety is about not using wrong functions on types they don't work with. Making heterogeneous lists based on common functionality and then allowing only that common functionality on those members is perfectly typesafe
10:20:27 <Eelis> Hermit: yeah :)
10:20:30 <Hermit> s/wrong//1
10:20:38 <srhb> mSSM: Well, maybe not. version 2 it is :P
10:20:49 <mSSM> srhb: haha, ok :D
10:20:52 <mSSM> srhb: thanks a lot
10:21:19 <mSSM> I have not gotten farther with my actual program, but at least it looks perfectly organized now :D
10:21:25 <srhb> mSSM: It helps, imo. :)
10:21:36 <srhb> Being able to scan it better helps for me, at least.
10:21:40 <alfiangozali> wondering what haskell really is #work with left pane <---
10:21:52 <srhb> alfiangozali: Huh?
10:22:01 <mSSM> srhb: yeah, it's a lot better readable
10:22:32 <mSSM> Well, thanks all! I am off. :)
10:22:35 <Hermit> Eelis: but we get ostentatious names for such a thing, like existential types, which leaves anyone D: wondering wtf does that even mean until they figure it's actually a simple thing
10:23:01 <Hermit> totally non intuitive
10:23:07 <alfiangozali> you know, it is when you unexpectedly get lost in tryhaskell.org :)
10:23:52 <Eelis> Hermit: i didn't really get what you meant with "you would get implicit existential construction and would then be screwed when trying to retreive a type if you don't have a real constructor" though
10:24:36 <srhb> alfiangozali: Ah :) Have fun with that ^^
10:25:01 <hiptobecubic> I really think this opinion that it's a shame that Haskell uses a lot of vocabulary from mathematics to describe things is terribly misguided though
10:25:03 <Hermit> Eelis: yeah, I didn't know how to put it clearly. I'll reword it.
10:26:23 <feliperosa> elliott: Could you point me the Parsec combinators I would most likely to use to parse a list of Ints separated by spaces? I tried: many (digit `sepBy` space), but it raised an exception.
10:27:03 <elliott> well, that wants every digit to be separated by a space
10:27:07 <alfiangozali> I am going to try learning haskell because of this -> http://www.datapointed.net/visualizations/math/factorization/animated-diagrams/
10:27:24 <feliperosa> oh
10:27:47 <Hermit> Eelis: ..when you apply an existential constructor (like Any), normally you can't take the value out to the original type. Say you do  Any "string", then want to convert this Any Show to Maybe String. This can be done adding a convert method in the existential type class
10:27:48 <elliott> I haven't used Parsec in a while so I might not be much help, I'm afraid
10:27:59 <feliperosa> oh yeah, I think I got what I did wrong
10:28:21 <hiptobecubic> There is a word for some concept. It's clearly defined and usually pretty old. It's terrible to learn some new word like "interface-type" or whatever this would be called, and then never realize how it relates to anything else.
10:28:24 <elliott> Hermit: you'll have a hard time writing such a conversion method
10:28:24 <feliperosa> I think you already solved my problem lol
10:28:39 <Hermit> elliott: I managed to ;-)
10:28:46 <feliperosa> yup
10:28:49 <Eelis> Any Show -> String  is easay
10:28:51 <Eelis> *easy
10:28:54 <Hermit> elliott: took me ages to realize how to do it though
10:28:59 <Hermit> (3 days actually)
10:29:03 <Hermit> until it clicked
10:29:14 <feliperosa> elliott: thanks, I did (many digit) `sepBy` space
10:29:17 <feliperosa> hehe
10:29:20 <Hermit> Eelis: try it
10:29:29 <Eelis> Hermit:   ding (Any s) = show s
10:29:31 <Eelis> done
10:29:54 <applicative> > Data.List.foldl' (\a b -> 1 ) undefined [undefined]
10:29:56 <lambdabot>   1
10:29:58 <feliperosa> damn, I keep falling in love with Haskell every time I learn anything new lol
10:29:59 <Hermit> Eelis: hahaha
10:30:04 <applicative> well that's a drag ^^^
10:30:06 <Eelis> Hermit: it compiles and works
10:30:12 <Hermit> Eelis: that's not what I meant but well played :-D
10:30:18 <Eelis> oh
10:31:19 <Hermit> Eelis: what I was talking about is, take this list: [Any 1, Any 'c'] :: [Any Show]  and turn it into  [Maybe Int]  (it should be Nothing when it hits Any 'c')
10:31:33 <Eelis> oh. well yeah, that's a very different thing :)
10:33:04 <alfiangozali> what is the meaning of fst()?
10:33:32 <alfiangozali> for example : fst (28,"chirs")
10:33:33 <Heffalump> fst() would be a type error - fst on its own is a function that takes a tuple  and returns the first eleent
10:33:50 <Heffalump> ok, in that case it means give me the first element of (28,"chirs"), i.e. 28
10:34:05 <applicative> > let foldl op = let go !z [] = z; go !z (x:xs) = go (op z x) xs in go in foldl (+) undefined [undefined]
10:34:06 <lambdabot>   *Exception: Prelude.undefined
10:34:09 <basdirks> :t fst () -- ignore this
10:34:10 <lambdabot>     Couldn't match expected type `(a0, b0)' with actual type `()'
10:34:10 <lambdabot>     In the first argument of `fst', namely `()'
10:34:10 <lambdabot>     In the expression: fst ()
10:34:25 <applicative> there's glory for you a strict left fold.
10:34:58 <srhb> feliperosa: Did you know you can also do cool stuff like fmapping into parsers?
10:35:01 <parcs> Hermit: you can do that if you have 'data Any c = forall a. (c a, Typeable a) => Any a'
10:35:05 <hiptobecubic> elliott, doesn't SomeException do that?
10:35:25 <alfiangozali> hmm..fst for first?
10:35:26 <basdirks> wats this: http://monad.com/
10:35:31 <hiptobecubic> there is toException and fromException
10:35:38 <elliott> hiptobecubic: yes, through Typeable
10:35:48 <elliott> if you want to get Typeable involved in your hierarchy be my guest :P
10:36:15 <Hermit> parcs: hmmm, haven't tried that
10:36:15 <feliperosa> srhb: What do you mean?
10:36:15 <srhb> feliperosa: Like... (read <$> many digit) `sepBy` space :: Parser [Int] ?
10:36:17 * Hermit puts hands to work
10:36:29 <srhb> It just blows my mind sometimes :P
10:36:32 <applicative> basdirks: "A principled tutorial from Tony Morris (don't let that turn you off).
10:36:36 <applicative> hah
10:37:11 <basdirks> "Know that monads are not all that unique. There are lots of other things that are relatives of monads, with their own useful uses. For some reason it just turns out that monads have the best PR / lobbyists / agents. Point being that getting all hung up on monads monads monads like Ballmer is (a) making it harder to understand them because they seem like rare unique strage single-instance things never to be repeated on earth or in hea
10:37:25 <feliperosa> srhb: Wow, that's even better than my version of it. I'm somewhat new to Haskell (like 6 to 7 months).
10:37:34 <srhb> feliperosa: about the same here. :)
10:37:56 <alfiangozali> I want to learn haskell more, where I can do that? This is my first time trying trhaskell.org, I know, always there is a first time :)
10:38:11 <alfiangozali> *tryhaskell
10:38:18 <applicative> alfiangozali: 'learn you a haskell for great good' is the going tutorial
10:38:19 <feliperosa> srhb: oh, were you into functional programming before it?
10:38:48 <applicative> people here can help with things youre stuck on alfiangozali. you can paste problematic code on hpaste.org
10:39:04 <parcs> :t cast -- Hermit
10:39:05 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
10:39:20 <alfiangozali> may I know, what is haskell really is?
10:39:42 <srhb> alfiangozali: A really cool language that will corrupt your mind for eternity.
10:39:44 <alfiangozali> is it web client side prog lang?
10:40:02 <Ralith> it's a town in arkansas
10:40:08 <srhb> @faq Can Haskell do client-side web stuff?
10:40:08 <lambdabot> The answer is: Yes! Haskell can do that.
10:40:20 <applicative> it is a programming language, a 'general purpose' one like C or Python
10:41:17 <alfiangozali> is haskell has any wrappers for java, c#, etc?
10:41:26 <applicative> It has three advantages: 1) It is beatiful; 2) It actually makes sense (as long as certain topics are avoided) 3) It's compiler is rightly called 'Glorious'
10:41:40 <applicative> Its rather than It's
10:41:47 <osfameron> heh
10:42:01 <osfameron> can you realistically do client-side web stuff in haskell?
10:42:10 <osfameron> e.g. a javascript compiler backend?
10:42:17 <srhb> osfameron: Have you seen Fay?
10:42:22 <luite> depends on what you want, fay is quite usable
10:42:28 <osfameron> nope
10:42:29 * osfameron googles
10:42:32 <luite> not quite haskell though
10:42:33 <srhb> It's damned awesome :P
10:42:40 <srhb> Well, it's a proper subset at least.
10:43:03 <luite> osfameron: i'm still working hard on ghcjs, but it's a lot of work
10:43:22 <alfiangozali> oh god -_-" I still haven't catch up what haskell really is
10:43:35 <applicative> alfiangozali: what is Java?
10:43:36 <luite> and you'll probably have to wait until GHC 7.8 before GHCJS will be really usable with a 64 bit GHC
10:43:38 <srhb> alfiangozali: It's a nice programming language. it can be used for lots of stuff. It makes your brain happy.
10:43:46 <parcs> is that a philosophical question? haskell is a programming language
10:44:19 <alfiangozali> okay, it's a programming language which can ... *fill the blanks
10:44:24 <ijp> byorgey: call me a weakling, but I've found your "Monoids: Theme and Variations" slow reading
10:44:25 <applicative> alfiangozali: Haskell is the same thing that Java is, only Java is verbose nonsense, Haskell is sensible sense.
10:44:49 <alfiangozali> have you ever heard F# in visual studio?
10:44:49 <parcs> alfiangozali: http://www.haskell.org/haskellwiki/Introduction
10:45:00 <applicative> alfiangozali: we've heard of it here ....
10:45:04 <osfameron> Fay looks quite cute
10:45:23 <alfiangozali> -_-"
10:45:25 <osfameron> it looks like the DOM stuff is mostly a question of passing strings to the FFI
10:45:38 <luite> osfameron: no typeclasses though
10:45:40 <applicative> F# is a similar language in some respects, as are ocaml standard ml etc.
10:45:46 <alfiangozali> F# is a functional programming languange which .net platformed
10:46:08 <osfameron> luite: makes sense given what it's compiling to, I guess
10:46:30 <osfameron> it doesn't look like writing nontrivial stuff in it will be *that* much nicer than writing javascript just yet though...
10:46:37 <luite> osfameron: hmm, it's not hard to translate typeclasses to javascript, but you need a typechecker to do the work
10:46:54 <srhb> osfameron: It kinda is, imo :P
10:47:15 <luite> osfameron: ghcjs can compile most haskell to js, including things like bytestring and text
10:47:43 <osfameron> luite: sounds nice.  How does it manage with the DOM and other javascript object integration?
10:47:58 <osfameron> srhb: have you got a good pointer to a more elaborate example of Fay?
10:48:08 <srhb> osfameron: Did you see the "in the wild" part of fay lang?
10:48:11 <osfameron> aha http://fay-lang.org/#section-1
10:48:18 <osfameron> srhb: sorry, yes, just noticed it!
10:48:25 <srhb> :)
10:48:35 <srhb> I like the ring oscillator one.
10:48:45 <srhb> Also the Fay IDE in Fay
10:48:49 <luite> osfameron: that part is not quite done, although js objects can be passed around as primitve types. type JSObj = GHC.Prim.ByteArray# works fine
10:49:04 <alfiangozali> aha..i know it :)
10:49:07 <applicative> how does the http://ide.fay-lang.org/ work? can I somehow run the javascript?
10:49:24 <luite> just make sure to not use the byte array primops on that thing, it will crash and burn!
10:50:17 <alfiangozali> Fay link makes clear everything *.*
10:50:27 <srhb> applicative: Top buttons
10:50:42 <applicative> I think I'm getting it.
10:50:48 <hpaste> marek__ pasted “State” at http://hpaste.org/81082
10:51:49 <marek__> why when using "sfun" from pasted (^^) code, expression  runState (sfun2 >>= sfun) 10 throws error?
10:52:13 <marek__> sorry, expression should be: runState (sfun >>= sfun) 10
10:52:41 <srhb> I don't even have a State constructor in Control.Monad.State
10:52:58 <geekosaur> with a modern mtl I'd expect a different error, the State constructor no longer exists
10:53:01 <osfameron> ok, the ring oscillator one was cute (I ignored all the scary looking maths ;-)
10:53:09 <srhb> osfameron: Yeah :P
10:53:17 <edwardk> srh: Control.Monad.State is built around StateT, using State as an alias for StateT s Identity now instead of having a fully separate simpler State type
10:53:17 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:53:26 <marek__> srhb: instaling haskell-platform should help
10:53:38 <geekosaur> marek__, you're running an older one
10:53:43 <geekosaur> it's not in newer Platforms
10:53:49 <geekosaur> mtl was reworked
10:53:59 <srhb> marek__: Yes, it could. Have a go at it. ;(
10:54:04 <srhb> ;)*
10:54:11 <marek__> geekosaur: quite possible since I'm on some not very (but still old) ubuntu
10:54:19 <geekosaur> the State *type* exists; the State *constructor* does not (for most things you use "state" instead)
10:54:49 <edwardk> what geekosaur said ;)
10:55:17 <edwardk> sfun = state (\x -> (x*2, x))  -- is what you want
10:55:23 <edwardk> not State
10:56:06 <edwardk> i honestly kind of wish mtl 2 hadn't eliminated the simpler State, Writer, etc. types
10:56:27 <marek__> well, I've learned from http://learnyouahaskell.com
10:56:31 <osfameron> srhb: ok, Language.Fay.JQuery looks quite reasonable in terms of syntax
10:56:32 <osfameron> cute
10:57:08 <srhb> osfameron: I really like it, personally. :)
10:58:21 <srhb> marek__: And if you want the state modified, it's the second tuple thingy.
10:58:33 <srhb> What on earth to call that. Second element of tuple? Sounds weird.
10:59:29 <blueonyx> > :t snd
10:59:30 <lambdabot>   <hint>:1:1: parse error on input `:'
11:02:10 <alfiangozali> if there is anyone who want to know what haskell really is, you may give this link http://learnyouahaskell.com/introduction#so-whats-haskell
11:02:35 <srhb> alfiangozali: That's all we do in this channel, link to LYAH.
11:02:44 <alfiangozali> it works on me #imperative-programmer
11:03:13 <maksbotan> hy guys
11:03:25 <srhb> maksbotan: Hi
11:03:42 <maksbotan> could you point me some wrong ideas in my code: http://bpaste.net/show/71880
11:03:51 <maksbotan> i'm afraid i did it totally wrong
11:04:19 <maksbotan> i suppose using runState inside State's do block is not the right thing to do, but i don't know the right one
11:05:41 <srhb> Well, you can directly use other stateful computations in a State do block... If that's what you want. I think it may be
11:06:28 <maksbotan> srhb: i know i can, i just ask if there is more elegant way of doing this :)
11:07:50 <parcs> maksbotan: wat? why are you doing that
11:08:51 <maksbotan> parcs: doing what exactly?
11:10:30 <parcs> maksbotan: do state <- get; let (r,state') = runState thing state; put state'; case r of ....
11:10:57 <maksbotan> parcs: i feel it's bad, that's why i'm here
11:10:57 <parcs> maksbotan: that is identical to doing 'r <- thing; case r of' ...
11:11:10 <parcs> maksbotan: http://bpaste.net/show/71880/
11:11:11 <maksbotan> parcs: what? seriosly?
11:11:20 <parcs> maksbotan: oops, this http://bpaste.net/show/HHC1rKUllgcg4um4m1Lb/
11:11:28 <srhb> That's what I was trying to say, albeit poorly I guess :)
11:11:41 <maksbotan> oh no
11:11:46 <Hermit> parcs: I'm struggling with making a Typeable instance for an existential type (so I can use cast). What would you suggest?
11:11:57 <maksbotan> why all haskell coders like to rewrite my code instead of just pointing ><
11:12:04 <Hermit> (messing with TypeRep is scaring me)
11:12:09 <parcs> maksbotan: i did both
11:12:09 <maksbotan> parcs: anyway thanks, now i realise how foolish it was
11:12:11 <srhb> maksbotan: I tried! :P
11:12:29 <maksbotan> thanks, guys
11:12:36 <parcs> Hermit: don't make your own Typeable instance. use -XDeriveDataTypeable and do 'data ... deriving (Typeable)'
11:13:11 <parcs> Hermit: oh, you want to make a Typeable instance for an existential type? i don't think that's possible
11:13:40 <Hermit> parcs: aww, damn
11:14:02 <parcs> Hermit: oh, looks like it is! try deriving an instance
11:14:13 <Hermit> parcs: then the Typeable constraint for the Any existential type won't do to convert back to the original type
11:14:23 * Hermit tries
11:14:58 * ski trees
11:15:45 <Hermit> parcs: can't do. Types must be of kind *
11:16:36 <wellnoidea> Hi there.
11:16:40 <parcs> Hermit: what exactly are you doing?
11:16:57 <Hermit> parcs: data Any c = forall a . (c a, Typeable a) => Any a deriving (Typeable)
11:18:28 <Hermit> parcs: nevermind. Though not generic, I managed to make these convertions for the types I care. It would have been nice to use cast though, but seems it's a no for existentials
11:19:19 <wellnoidea> I have a question, how much math does one need for Haskell?
11:19:35 <alfiangozali> is there anyone here who ever worked with softcomputing algorithm?
11:19:40 <monochrom> highschool algebra. and not directly. just aptitude for variables
11:19:45 <monochrom> and substitution
11:19:57 <wellnoidea> substitution?
11:20:02 <monochrom> don't laugh. many people fail even those
11:20:16 <parcs> Hermit: oh, the problem with that is the 'c' parameter which doesn't have the expected kind according to the Typeable-deriving mechanism. i don't really know much about that. it's strange that you want to have a Typeable instance on Any itself, though
11:20:55 <alfiangozali> like genetic algorithm, artificial neural network, or machine learning like hidden markov model?
11:20:56 <monochrom> yes, substitution, like if I say "f x = (x,x)", then it implies "f True = (True,True)"
11:20:57 <parcs> Hermit: maybe you can carefully create a valid Typeable instance
11:21:26 <Hermit> parcs: that's exactly what I've been struggling with the past hour
11:21:32 <wellnoidea> I'm quite new to software developement and looking for something to start with besides php.
11:21:33 <monochrom> or if I say "f :: a -> (a,a)", then you can plug Bool into a
11:21:37 <Hermit> parcs: and it's scary
11:22:05 <srhb> wellnoidea: Learning Haskell and PHP side by side is going to be trippy as hell, if you do it, please please please blog about it. :P
11:22:26 <wellnoidea> O.K. algebra is fine, sunstitution looks....    interesting
11:22:41 <wellnoidea> trippy as hell? why so?
11:22:44 <srhb> wellnoidea: It's just a question of plugging values in where their names are.
11:22:55 <monochrom> you didn't see substitution in highschool algebra?
11:22:58 <parcs> Hermit: yeah, it's not something that was meant to do by hand. good luck
11:23:14 <wellnoidea> plugging in things? I think I can do that.
11:23:25 <applicative> if y = x + 1 then y + 1 = (x + 1) + 1
11:23:27 <srhb> wellnoidea: Well, PHP is a dynamically typed, mutable, poorly designed language while Haskell is an extremely well-designed strongly typed, functional language.
11:23:36 <wellnoidea> Possibly I saw it. But I'm not perfectly aware of it.
11:23:39 <srhb> (That may be slightly subjective) :P
11:23:39 <monochrom> like, if they give you a formula "(x+1)^2 = x^2 + 2x + 1", you did not realize that a special case is "(3+1)^2 = 3^2 + 2*3 + 1"?
11:24:05 <applicative> if square x = x * x then square 3 = 3 * 3 -- that's how haskell works....
11:24:27 <srhb> > let x = 3 in x
11:24:28 <lambdabot>   3
11:24:34 <srhb> I guess that's the most basic example :P
11:24:38 <wellnoidea> I think I can manage that.
11:24:44 <applicative> > let square x = x * x in square 3
11:24:46 <lambdabot>   9
11:24:47 <monochrom> good good
11:24:59 <awestroke> Hello! I have a problem with a list becoming infinity without reason: https://gist.github.com/b5c3a70afba201c87ee2
11:25:04 <wellnoidea> Well the differences between php and Haskell is what actually interested me.
11:25:04 <awestroke> becoming infinite*
11:25:08 <applicative> without a reason??
11:25:09 <srhb> Without reason! Oh no. :P
11:25:44 <srhb> wellnoidea: And it really should
11:25:52 <wellnoidea> And about the bad design of php, well I suppose that's a tribute to its degree of specialization.
11:25:53 <awestroke> well, I see no reason
11:25:56 <srhb> wellnoidea: I was quite serious when I suggested you blog about the experience, and the differences in particular
11:25:57 <applicative> awestroke: does the line let (n, g) = addVertex g 10 overwrite the old 'g', maybe?
11:26:05 <srhb> wellnoidea: Nah that's not it, but you'll notice soon enough.
11:26:06 <monochrom> Hermit: "data SomeException = forall e . Exception e => SomeException e   deriving Typeable" is supported for existential type. straight from Control.Exception source code
11:26:09 <applicative> why I say 'overwrite' I don't know
11:26:14 <awestroke> applicative: hopefully, yes. why does that matter
11:26:55 <wellnoidea> I'm not quite the blogger type though...
11:26:57 <Hermit> monochrom: but SomeException is of kind *, not * -> *, right?
11:26:59 <applicative> awestroke: well you define the new g in terms of itself, so it's not too surprising its infinite
11:27:03 <applicative> liket the familiar
11:27:04 <monochrom> correct
11:27:12 <applicative> > let one = 1:ones in ones
11:27:13 <lambdabot>   Not in scope: `ones'
11:27:14 <lambdabot>  Perhaps you meant `one' (line 1)Not in scope: `ones'
11:27:14 <lambdabot> ...
11:27:16 <srhb> wellnoidea: Well okay, Haskell is still a ton of fun to learn. Definitely worth it. :)
11:27:20 <applicative> > let ones = 1:ones in ones
11:27:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:27:22 <applicative> rather
11:27:35 <Hermit> monochrom: the problem I'm having is making a Typeable instance for an existential of kind * -> *
11:27:35 <wellnoidea> Sounds good, thx.
11:27:39 <awestroke> applicative: why would the addVertex function care (or know) what variable assignment I do? It should work with what I pass it, no?
11:27:51 <srhb> wellnoidea: Do you know of LYAH?
11:27:57 <Hermit> monochrom: data Any c = forall a . (c a, Typeable a) => Any a deriving (Typeable)
11:28:02 <wellnoidea> No.
11:28:07 <applicative> let (n, g) = addVertex g 10 defines a graph g that has infinitely many vertices added...
11:28:08 <srhb> @where LYAH
11:28:08 <lambdabot> http://www.learnyouahaskell.com/
11:28:14 <srhb> wellnoidea: ^^
11:28:16 <monochrom> that one is more than existential type
11:28:30 <wellnoidea> Ah, O.K. yes I bookmarked it already.
11:28:32 <applicative> awestroke: try asking for g2 after let (n, g2) = addVertex g 10
11:29:02 <Hermit> monochrom: I see
11:29:10 <awestroke> applicative: that works. but I can't grasp why it would be defined in terms of itself just because I "overwrite" a symbol
11:29:17 <alfiangozali> and..no one :(
11:29:21 <srhb> awestroke: Did you understand the "ones" example?
11:29:42 <srhb> awestroke: The g to the right in your let binding is the same as the g to the left. Ie. let bindings are recursive.
11:30:25 <awestroke> srhb: ah. but then, how can I ever use this without creating a new variable each time I need to modify the graph?
11:30:28 <wellnoidea> What is Haskell used for IRL?
11:30:35 <monochrom> "data X a = forall b. Show b => X a b  deriving Typeable" is supported too. existential type. *->*
11:30:38 <srhb> wellnoidea: Everything, anything. :)
11:30:42 <srhb> wellnoidea: It's very general purpose.
11:30:45 <awestroke> wellnoidea: check out the top haskell repos on github
11:30:47 <applicative> awestroke: why would you use the same symbol in both places?
11:30:52 <Botje> wellnoidea: facebook uses it for mass rewriting of PHP. banks use it to evaluate contracts.
11:30:55 <monochrom> your problem is "c a" instead of "Show a"
11:31:03 <srhb> awestroke: If you simply call the left side g2, you're fine.
11:31:11 <Botje> wellnoidea: galois uses it to build very specific VMs
11:31:21 <Hermit> monochrom: I see, so if I hardcode the constraints, it works, right?
11:31:24 <awestroke> wellnoidea: https://github.com/languages/Haskell
11:31:27 <monochrom> yes
11:31:30 <Hermit> nice
11:31:34 <Hermit> got to try it
11:31:56 <monochrom> use the scientific method. design experiments to refute your hypotheses. yes, refute.
11:31:59 <ski> parcs : hm, a simple test with deriving `Typeable' for an existential data type seemed to work just fine
11:32:06 <applicative> wellnoidea: here's my favorite haskell app http://johnmacfarlane.net/pandoc/  https://groups.google.com/group/pandoc-discuss
11:32:31 <wellnoidea> Sweet: learn-you-a-haskell-exercises on Github...
11:33:53 <parcs> ski: yeah, the problem is that every it demands that every parameter in the type constructor has the kind *, so 'data Any (c :: * -> Constraint) = forall a. ...' is out
11:33:59 <awestroke> applicative: say I want to add vertices depending on user input. so I loop in my main monad and accept weights. now how do I update the graph without redefining the symbol g?
11:34:24 <Botje> you call your loop with (addVertex whatever g)
11:35:34 <awestroke> Botje: if I don't redefine g, it will add the vertex to an empty graph each time, resulting in a graph with a single vertex no matter how many addVertex calls are done
11:35:51 <srhb> No.. :)
11:35:56 <Botje> awestroke: I'm assuming you have a loop currentGraph = ...
11:35:57 <applicative> awestroke: there's nothing you can do about it, addVertex 10 g /= g ... except in one case -- the 'infinite' one you produced earlier.
11:36:11 <Botje> then you just call loop (addVertex 10 currentGraph)
11:36:35 <ski> parcs : ok, ok
11:36:43 <applicative> awestroke: it would be lame but suppose you had an IORef Graph then the same ref could hold different graphs
11:36:53 <Botje> awestroke: or you store it in an IORef .. what applicative said
11:37:07 <ski> (a polymorphic `Typeable' class would probably help here)
11:37:08 <srhb> Isn't IORef a bit of an early suggestion? :P
11:37:15 <applicative> srhb: yes
11:37:36 <applicative> srhb: but mutation is sort of the topic
11:37:46 <awestroke> where can I read more about "loop"... the hackage page for it is down
11:37:49 <srhb> Oh, I did not realize.
11:37:53 <srhb> You write your own loop.
11:37:56 <Botje> awestroke: uh, it's a function you define yourself ..
11:38:04 <awestroke> gaaaah
11:38:08 <monochrom> hehe
11:38:10 <Botje> awestroke: you said ' so I loop in my main monad and ..'
11:38:15 <mysticc> Can anyone explain this line from haskell wiki: If a function you want inlined contains a slow path, it can help a good deal to separate the slow path into its own function and NOINLINE it.
11:38:58 * applicative is wondering why that is
11:39:11 <awestroke> oh.. yeah.. but how do I do that loop without redefining any variable
11:39:20 <awestroke> how do I store the current graph
11:39:29 <Botje> awestroke: you don't store it. you pass it as an argument to the loop.
11:39:47 <awestroke> and how does the loop store the intermediate result
11:39:51 <srhb> loop graph = ... control flow ... loop newGraph ... or something
11:39:51 <Botje> it does not store it
11:39:53 <Hermit> mysticc: to inline everything except the slow path
11:39:59 <Botje> it passes it to the next iteration, modified or not.
11:40:02 <monochrom> and at each recursive call, you can choose to pass the same graph or a different graph
11:40:19 <mysticc> Hermit: What is the problem with inlining the slow path?
11:40:30 <awestroke> oh... thanks
11:40:45 <mysticc> Hermit: Or how does it affect performance inlining slow path?
11:40:48 <srhb> awestroke: Often you really don't need mutation. :)
11:41:07 <Hermit> mysticc: let me check the article
11:41:23 <mysticc> Hermit: http://www.haskell.org/haskellwiki/Performance/GHC
11:41:42 <Botje> awestroke: you could construct a graph in one go using something like foldl addVertex emptyGraph [1..20]
11:41:42 <applicative> main = do ref <- newIORef nullgraph ; forever (go ref) ---- go ref = do input <- getInput; modifyIORef (op input) ; newgraph <- readIORef ref ; print newgraph
11:42:08 <Hermit> mysticc: so the slow path can be cached
11:42:14 <Hermit> on it's own
11:42:20 <Hermit> mysticc: makes sense?
11:42:49 <monochrom> oh, you want memoization, no re-computation
11:44:01 <mysticc> Hermit: Ohh, thanks
11:44:07 <applicative> how come lennart is against 'dependency injection' it's so much clearer than, say, 'monad', no? http://stackoverflow.com/questions/14327327/dependency-injection-in-haskell-solving-the-task-idiomatically/14329487#14329487
11:44:19 <mysticc> Hermit: But that is beneficial if it is used several times?
11:45:29 <srhb> applicative: Isn't really him that wrote the answer, though
11:45:36 <copumpkin> applicative: he edited it
11:45:41 <copumpkin> the author there is mm_freak, I believe
11:45:47 <Hermit> mysticc: the compiler usually will try to avoid recomputation of pure functions, so will reuse a value across multiple calls that use the same arguments
11:45:49 <monochrom> is dependency injection really clear? please explain it to me
11:46:07 <applicative> ah indeed.
11:46:17 <applicative> mm_freak is unusually sensible there
11:46:36 <srhb> I also don't understand dependency injection. The code in the answer is perfectly clear though.
11:46:53 <applicative> he didnt even recommend wires -- though tekmo couldn't resist
11:46:57 <monochrom> IMO monad is clear because it has a short precise definition
11:47:04 * applicative demands dependency injection lenses
11:47:15 <elliott> shocking answer from tekmo there :)
11:47:16 <ion> lens injection
11:47:19 <simpson> DI is just function application for Java.
11:47:20 <edwardk> thats what makeClassy is for
11:47:25 <elliott> I'd never have guessed pipes would be the solution!
11:47:44 <monochrom> ok, function application is much clearer, haha
11:47:50 <applicative> mm_freak++
11:48:00 <srhb> makeClassy?
11:48:12 <applicative> srhb: in Control.Lens.TH
11:48:21 <srhb> Oh, that.
11:48:45 <Hermit> mysticc: now if your slow path deppends on the environment or has side effects, it's useless to avoid inlining it
11:49:23 <Hermit> mysticc: but even then, you can factor most of it and avoid inlining
11:49:56 <mysticc> Hermit: Thanks
11:50:56 * applicative uses the cake pattern for dependency injection now that there's a purely functional implementation.
11:51:01 <applicative> buzz
11:51:43 <Hermit> mysticc: :-)
11:56:12 <applicative> this is a moronic question, but now that I have 4 cores, I am fiddling with parallel things a little.  But whereas before I could conveniently flood both cores with parallel calcualtions, the OS seems to be keeping me from using more than 50% of any of them.
11:56:33 <applicative> What am I doing wrong? Confused in Santa Fe.
11:56:48 <Botje> you wouldn't be using hyperthreading, would you?
11:56:55 <applicative> ?!
11:56:55 <lambdabot> Maybe you meant: . ? @ v
11:57:15 <monochrom> v
11:57:22 <Hafydd> ?v
11:57:22 <lambdabot> Just 'J'
11:57:30 <applicative> ha
11:57:35 <Hafydd> What could it mean?!
11:57:37 <applicative> what is hyperthreading
11:58:04 <monochrom> hyperthreading is one core but approximately two ALUs inside. my feeble understanding anyway
11:58:05 <abbe> more than 1 logical cores on 1 physical core
11:58:18 <abbe> execution engines
11:58:21 <Botje> hyperthreading is one physical core claiming it's two, but with a lot of limitations.
11:58:22 <applicative> I was doing something from Control.Concurrent actually, with forkIO.
11:59:07 <applicative> Botje now that you mention it, I dont really know what I have, I just noticed signs of four-ness last night.
11:59:43 <srhb> I like HT. It makes my laptop feel like a server when I look at top.
11:59:51 <monochrom> exact CPU name may help experts identify it. but I am not one of them
12:00:23 <Philippa> HT is mostly using the second thread to have something to do if the first one stalls a bit
12:02:03 <tac> What's the least hopeless windowing toolkit for Haskell on Windows?
12:02:12 <monochrom> if you know pthreads, write a C program to create 4 threads and test
12:02:53 <srhb> tac: wx is harder to get a development environment working with, but easier to work with once it's up, in my experience.
12:03:06 <srhb> tac: gtk the other way around. But they're both exceedingly horrible, tbh.
12:03:18 <tac> by "get a dev env up" do you mean "getting your code to compile in the first place"?
12:03:23 <srhb> Yes.
12:03:29 <tac> that is what I was afraid of
12:03:47 <Jeanne-Kamikaze> I thought wx was the easiest to get set up
12:03:59 <Jeanne-Kamikaze> gtk and qt are hell compared to it
12:04:00 <maksbotan> srhb: parcs: can you spot more problems now? :) http://bpaste.net/show/71895
12:04:03 <srhb> Did I miss them up? Hmm.
12:05:48 <tac> Also, FPR is the only real innovation to UI programming (and still a bit developed).... <-- is this statement more or less true?
12:06:02 <tac> (and still a bit underdeveloped***)
12:07:17 <mKarpis> Hi All,.... please, in which package is included Data.Applicative?
12:07:36 <applicative> monochrom: my processor is an intel core i5
12:07:49 <Lethalman> @index Data.Applicative
12:07:49 <lambdabot> bzzt
12:08:02 <ion> I misread that as “my professor is an intel core i5”
12:08:10 <monochrom> hahaha
12:08:12 <Lethalman> @index <*>
12:08:12 <lambdabot> bzzt
12:08:15 <Lethalman> :P
12:08:28 <simpson> mKarpis: Did you want Control.Applicative maybe?
12:08:40 <Philippa> applicative: that's not much detail :-(
12:08:41 <monochrom> my thesis supervisor is a T-1000
12:08:47 <applicative> hm, it seems that doesn't solve the problem...
12:08:53 <applicative> as Philippa is saying
12:08:56 <Philippa> (Core i5 means anything Intel've considered mid-range in about the last four years)
12:09:11 <monochrom> yeah, I meant CPU ID
12:09:14 <Philippa> (for laptops, that's mostly dual-core hardware)
12:09:21 <Philippa> (but only mostly)
12:09:47 <mKarpis> well,, the error is: Could not find module `Data.Applicative'
12:10:05 <hpaste> flebron pasted “Is this idiomatic?” at http://hpaste.org/81085
12:10:38 <monochrom> /proc/cpuinfo has a good chance of telling you the detailed CPU name
12:11:05 <applicative> it is looking like it is '4 logical processors, 2 cores'
12:11:14 <monochrom> for example mine is "model name : Intel(R) Pentium(R) Dual  CPU  T3200  @ 2.00GHz" here
12:11:32 <monochrom> ok, my thesis supervisor is a T3200 :)
12:11:38 <mKarpis> simpson: hi, the error I'm gettin is: Could not find module `Data.Applicative'
12:12:40 <monochrom> 2 core 4 logical may mean 2 core, each HT
12:12:50 <applicative> well, I think I will drop study of parallelism again; this seems to make it more rather than less complicated
12:13:18 <simpson> mKarpis: Well, what is giving you that error? AFAICT there is no Data.Applicative.
12:17:19 <wellnoidea> Just read a few things. Is substitution equal to pattern matching?
12:18:02 <geekosaur> um.  context?
12:18:44 <monochrom> no, not equal
12:19:00 <wellnoidea> Oh, sorry we had this earlier, what is neede for Haskell? => algebra and substitution
12:19:20 <Philippa> mmm. Substitution really is just seeing x, saying "I know x = 1" and writing 1 instead
12:19:39 <monochrom> context: it was asked how much math you need for learning haskell. I answer: highschool algebra, and indirectly: variables and substitution
12:19:41 <Philippa> pattern-matching is the bit that goes "that's x!", sort of
12:19:52 <wellnoidea> Hm, O.K. It's nice that there is such a heavy word for it ;)
12:20:26 <wellnoidea> Well, I can manage that ^^
12:23:55 <monochrom> perhaps I should level-up the math prerequisite to unification
12:24:58 <hiptobecubic> In the haskell faq it says of the monad type class: "type class polymorphism over type constructors (which few other languages have)". Which part of it does this refer to?
12:25:59 <Philippa> hiptobecubic: Monad is an example of what used to be called a "constructor class"
12:26:13 <Philippa> for any instance Monad m, m's kind isn't *
12:26:20 <Philippa> (rather, it's * -> * - m is a type constructor)
12:28:42 <monochrom> type constructors are IO, Maybe, etc. as opposed to Int, IO Int, Maybe Int
12:28:47 <hiptobecubic> sorry, i'm lagging really hard here for some reason...
12:29:26 <monochrom> in "class Monad m", m may be IO, Maybe. But not IO Int, Maybe Int
12:29:42 <hiptobecubic> Ok let me rephrase. How is type class polymorphism different from type class polymorphism over type constructors?
12:30:25 <hiptobecubic> Does it just mean that it's polymorphic in the constructor?
12:30:35 <monochrom> usually, if you don't emphasize "over type constructors", then I only imagine "class Show a", where a can be Int, Bool, Maybe Int, IO Int. I don't imagine a=Maybe
12:30:44 <monochrom> yes
12:30:59 <hiptobecubic> ok
12:31:40 <wellnoidea> A bit OOT but what languages are 3d applications mostly written in?
12:31:50 <simpson> wellnoidea: C++.
12:31:56 <wellnoidea> thx
12:31:57 <Philippa> Whatever comes to hand
12:31:58 <simpson> wellnoidea: This isn't a good thing, BTW.
12:32:09 <monochrom> compare the types "a -> Maybe a" vs "Int -> m Int"
12:32:12 <Philippa> C++ is a common choice when people are worried about performance, but it's really not necessary
12:32:18 <simpson> wellnoidea: C++ is not a very enjoyable language for doing things. It's just the language that's used because of tradition.
12:32:40 <wellnoidea> What is an enjoyable language?
12:32:45 <Philippa> well, because traditionally people are worried about performance and didn't have the background to understand how a language that doesn't look like C++ could do the job
12:32:50 <Philippa> Malbolge :p
12:33:02 <simpson> wellnoidea: Something without manual memory management, for starters. :3
12:33:05 <monochrom> an enjoyable language is one that makes you say "I love this language. it is so easy"
12:33:34 <wellnoidea> Malbolge? Do I smell sulfur?
12:33:37 <Chousuke> I don't think haskell is easy but it's certainly nice.
12:34:03 <monochrom> I love haskell. it is so lazy.
12:34:12 <wellnoidea> Well I'm mostly looking for something else to play around with.
12:34:56 <Chousuke> actually GHC-Haskell is probably neater than standard haskell :P
12:34:59 <monochrom> I worry about performance. my performance, not computer performance.
12:35:13 <Jeanne-Kamikaze> I find C++ quite enjoyable
12:35:21 <derdon> monochrom: well said :)
12:35:37 <Jeanne-Kamikaze> nothing like tinkering with raw memory every once in a while
12:35:39 <monochrom> not to say that I accept very slow programs. care != worry
12:35:50 <Chousuke> sometimes you have to worry about computer performance too
12:36:02 <Chousuke> but really, it's not easy to write performant programs in C++ either
12:36:15 <wellnoidea> I'd like to see some kind of performance right now....
12:36:28 <Chousuke> if you just start coding a GUI app using Qt or something in C++ chances are you will end up with something that barely performs better than one you'd write in Python
12:36:39 <Philippa> wellnoidea: what is "some kind of"?
12:36:39 <monochrom> visit youtube for music performance and dance performance
12:36:46 <Chousuke> unless you explicitly pay attention to making it performant
12:36:50 <Jeanne-Kamikaze> why do you measure performance with GUI apps
12:37:03 <Chousuke> it was just an example
12:37:04 <Philippa> only, there's a big difference between "not as fast as it could be" and "pathologically slow"
12:37:08 <Jeanne-Kamikaze> a very bad example
12:37:29 <Chousuke> I don't think so
12:37:36 <Jeanne-Kamikaze> a GUI app doesn't need performance
12:37:43 <Chousuke> I mean, C++ is not an uncommon choice for GUI apps
12:37:46 <Hermit> hiptobecubic: as I see it, typeclass polymorphism over type constructor would be Functor f => f Maybe
12:37:47 <Philippa> a GUI app needs to be responsive
12:37:53 <Jeanne-Kamikaze> sure
12:38:05 <Philippa> this mostly amounts to not suffering from pathologically bad performance and knowing when to fork a thread to do something
12:38:20 <monochrom> haskell performance: http://www.youtube.com/watch?v=Ci48kqp11F8
12:38:21 <Chousuke> I'm just trying to make the point that using C++ for a project doesn't automatically mean you will gain any performance benefit
12:38:44 <Jeanne-Kamikaze> I doubt your C++ programs perform as bad as their python counterparts
12:39:39 <Jeanne-Kamikaze> yes but you're putting an example where performance is not even needed
12:39:54 <Jeanne-Kamikaze> let's write a game or something half real-time in C++ and pyhon, see who wins
12:40:13 <Philippa> that depends how you define "win"
12:40:17 <wellnoidea> Yeah, that was a good performance. I bet he's a good programmer....
12:40:37 <Chousuke> Jeanne-Kamikaze: python is completely suitable for writing games though
12:40:37 <Philippa> Python is perfectly adequate for most gaming tasks a single person should be thinking about working on
12:40:44 <monochrom> my game in haskell and performs well: http://hpaste.org/52480
12:41:07 <Chousuke> Jeanne-Kamikaze: and again, the C++ game engine will not be automatically performant.
12:41:21 <Chousuke> you'll need programmers that actually pay attention to performance
12:41:40 <Jeanne-Kamikaze> it'll be automatically more performant than in python, unless you're doing it really wrong
12:42:03 <Adeon> your wonderful game is not passing hlint
12:42:19 <wellnoidea> Is 23:11: Error: Redundant do part of thegame?
12:42:22 <monochrom> I refuse camel case
12:42:22 <Philippa> *nod*. This is heading hugely off-topic and I'm not sure it'll be welcome in -blah either
12:42:44 <monochrom> hlint is stupid in talking about camel case. I don't care about it
12:43:13 <monochrom> as for redundant do, that's just for better symmetry. why should you care
12:43:23 <deech> Hi all, is it possible to create a module in TH?
12:43:25 <Philippa> wellnoidea: there are things you can do to get reasonable performance for 3D work in Haskell moderately easily. Optimising your arse off is more tedious, but then it is in C++ too
12:43:46 <Axman6> Monochro_Do_You_Like_Ada_Case?
12:43:54 <monochrom> haha
12:44:11 <monochrom> I like oleg'case the most
12:44:16 <Axman6> ( actuallu quite like Adamcase in Ada)
12:44:44 <Axman6> bleh, typing on an ipad without autocorrect sucks
12:45:15 <monochrom> I suppose since I also write init_lo, I like ada case too
12:45:32 <Axman6> heh
12:45:59 <deech> Does the new type-level number promotion allow arithmetic expressions at the type level as well?
12:46:01 <monochrom> I refuse camel case and mark zuckerberg. same level. not negotiable.
12:46:20 <c_wraith> monochrom: you must hate nearly all haskell libraries, then.
12:46:40 <monochrom> yeah. what's with getLine and then hGetLine?
12:46:51 <Axman6> speaking of Ada, more people should learn Ada. the meme that its an ancient, dead language is far from correct  imo its a much more advanced language than even C++11 and much more pleasant to work with
12:47:01 <elliott> @remember monochrom I refuse camel case and mark zuckerberg. same level. not negotiable.
12:47:01 <lambdabot> Done.
12:47:05 * ijp sides with monochrome on this one
12:47:11 <monochrom> do you realize that to edit code to change between them, I have to modify two letters, not one?
12:47:33 <deech> Axman6: I've been toying with Ada as a alternative to C++.
12:47:43 <Axman6> good :)
12:48:30 <deech> Axman6: I've been trying to figure out how elegantly use it from Haskell. Something better than flattening out the inheritance hierarchy.
12:48:39 <Axman6> ive been trying to figure out if i can make it compile for an ARM Cortex-M3 but i feel until AdaCore supports ARM im out of luck
12:49:24 <Axman6> you can just export ada functions and procedures as C functions no?
12:50:23 <Axman6> then FFI them
12:50:30 <deech> Axman6: Yeah, but to export an instance of an object you're flattening out the hierarchy and it starts to look like Gtk2HS.
12:50:59 <deech> Axman6: If they're part of a class. Which it looks like most are.
12:51:02 <Axman6> ah :/ im not interrested in the OOP side of Ada
12:51:30 <Hermit> monochrom: but isn't camelcase the default in haskell?
12:51:31 <deech> Axman6: Got it.
12:52:10 <monochrom> there is no default in the language. there is default in people.
12:52:23 <Axman6> deech: whatre you trying to use ada for anyway?
12:52:37 <Hermit> right... conventions...
12:52:59 <Hermit> monochrom: so, you can't stand camelCaseStuff?
12:53:02 <deech> Axman6: Provide a better interface to C++ libs. I think GNAT can directly instantiate C++ objects and call them.
12:53:26 <deech> Axman6: I'm hoping it does something sensible with constructors that throw exceptions.
12:53:33 <Axman6> yiu may be right, ive never looked into it
12:54:04 <Axman6> any idea if Ada and C++ exceptions play nicely?
12:54:22 <monochrom> I can stand it. but it is illogical for haskell
12:54:32 <Axman6> there is a whole section in the gcc manual about using Ada anc C++ afterall
12:55:20 <TheRedMood> AHH!
12:55:22 <monochrom> camel case is fine in java php ocaml. to change GetField to Field, you just need to delete Get, you don't have to change F to f
12:55:29 <TheRedMood> NOW I GET WHY CONST EXISTS!
12:55:30 <TheRedMood> :D
12:55:40 <Hermit> monochrom: to me, lisp-style-names are the best there is. Plays nice with autocompletion too: g-s-k TAB -> global-set-key
12:55:53 <monochrom> yes
12:55:57 <mauke> Hermit: I hate that
12:56:06 <Axman6> ew
12:56:15 <mauke> it requires planning ahead for a *convenience* feature
12:56:19 <Hermit> mauke: what do you like?
12:56:36 * Axman6 likes camel case
12:56:38 <monochrom> I would really like identifiers to be unrestricted. I want to add spaces. I want to add ♥
12:56:39 <mauke> autocompletion where I don't have to think about it
12:57:34 <Hermit> mauke: I don't see why would a convenience feature be bad
12:57:55 <Hermit> it's not meant to fix a bad design in an ad-hoc way
12:58:02 <Hermit> it's just a convenience feature
12:58:10 <mauke> non sequitur
12:58:12 <jmcarthur> i don't see where the "planning ahead" comes from
12:58:22 <aristid> Hermit: the point is that conscious effort is needed, and there are better ways to design that.
12:58:33 <jmcarthur> you mean typing gsk before hitting tab based on your knowledge that it will complete to something real?
12:58:35 <Hermit> aristid: like?
12:58:35 <monochrom> I am fine with planning ahead for future convenience. haha
12:58:43 <mauke> jmcarthur: how do you know you have to type "g-s-k" to be able to expand it afterwards?
12:58:44 <aristid> ways which minimize conscious effort and rely on things like muscle memory
12:59:01 <jmcarthur> mauke: seems to me that you just type the first letter of each word and hit tab...
12:59:07 <aristid> Hermit: regular autocompletion that displays the options as you start typing?
12:59:18 <aristid> Hermit: ido works well for me
12:59:20 <mauke> jmcarthur: no, you also have to type the dashes
12:59:43 <jmcarthur> mauke: sure, and if the dashes are conventional then this is unsurprising, no?
12:59:49 <mauke> jmcarthur: irrelevant
12:59:54 <monochrom> don't type "g-n-u" and autocomplete. if you do, you get "g-n-u-not-unix"
13:00:36 <Hermit> aristid: yeah, ido is nice, I like it too, but typing the acronym and then expanding is good.
13:00:41 <jmcarthur> i guess i still don't see the point. i still don't see what the planning ahead bit is
13:00:54 <jmcarthur> if i intend to type global-set-key then i know exactly what to type
13:01:31 <Hermit> monochrom: you'd get only one expansion per tab
13:02:21 <monochrom> yes, but then you are tempted to autocomplete again, and again, ad infinitum. then you spend the whole day playing instead of coding
13:02:40 <aristid> jmcarthur: you know _immediately_ how the words are split and that it's precisely globa-set-key and not set-key-global?
13:03:07 <aristid> jmcarthur: and yes, we're talking about fractions of a second here:)
13:03:14 <ziman> what would the difference be with camelCase here?
13:03:28 <mauke> jmcarthur: how do you know this?
13:04:15 <jmcarthur> i guess this stems from a difference between how i use autocompletion and how other people use it
13:04:27 <jmcarthur> i guess a lot of people use it when they don't know what they are looking for
13:04:27 <aristid> jmcarthur: how do you use it?
13:04:35 <jmcarthur> i just use it to save keystrokes
13:04:54 <mauke> no, seriously: how do you know this?
13:04:58 <aristid> jmcarthur: what do you use when you don't precisely know what you need?
13:05:09 <jmcarthur> documentation
13:05:11 <Hermit> ziman: that you can leave empty fields if you don't remember the exact word there or want a wildcard for that field:  g--k TAB -> global-set-key / global-unset-key   Can't do that with camelcase, right?
13:05:12 <aristid> mauke: know what? oO
13:05:18 <TorosFanny> ask a silly question: how to make a string containing backslash
13:05:25 <mauke> aristid: <jmcarthur> if i intend to type global-set-key then i know exactly what to type
13:05:29 <jmcarthur> there's no telling what some random function i just discovered through autocompletion actually does
13:05:46 <mauke> aristid: "g-s-k" in this case
13:05:55 <jmcarthur> (in general, i realize that if it's type directed then this isn't always the case)
13:05:55 <aristid> jmcarthur: there are degrees of ignorance.
13:05:58 <TheRedMood> I just figured out how to do project euler problem 1 in haskell :D
13:06:01 <Hermit> TorosFanny: "string\\blah"
13:06:09 <jmcarthur> aristid: right, such as type-directed autocompletion
13:06:11 <monochrom> what have I done
13:06:13 <TorosFanny> thanks
13:06:13 <aristid> jmcarthur: i might remember that there is this function and it has global and set and keys in the name, but no more.
13:06:30 * hackagebot blink1 0.2 - Control library for blink(1) LED from ThingM  http://hackage.haskell.org/package/blink1-0.2 (DylanSimon)
13:06:30 <TheRedMood> eul1 = sum [x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
13:06:40 <TheRedMood> > sum [x | x <- [1..999], x `mod` 3 == 0 || x `mod` 5 == 0]
13:06:42 <lambdabot>   233168
13:06:44 <TheRedMood> :D
13:06:44 <monochrom> oh, I merely pointed you to my hpaste. hlint is not my fault
13:06:46 <TheRedMood> It worked!
13:06:52 <aristid> jmcarthur: also, the availability of undo and version control means i personally do sometimes dare call an unknown function.
13:06:54 <jmcarthur> aristid: i still wouldn't trust the result if it wasn't exactly what i expected
13:07:01 <jmcarthur> sure
13:07:30 <jmcarthur> i just mean i would consider such a result to be an educational moment rather than a cue to just move one
13:07:38 <jmcarthur> *move on
13:09:30 <byorgey> ijp: I wouldn't call you a weakling.  Is there something in particular you're having trouble understanding?
13:09:55 <ijp> just hard to keep it all in my tiny head
13:10:19 <ijp> I would have never have noticed that difference lists generalise that way if you hadn't pointed it out, so thanks for that
13:10:33 <byorgey> =)
13:10:53 <monochrom> don't feel bad about not inventing a generalization
13:10:57 <byorgey> I actually hadn't noticed it before writing the paper
13:11:16 <johnw> @seen bonus
13:11:17 <lambdabot> Unknown command, try @list
13:11:36 <jmcarthur> generalize in what way?
13:11:46 <byorgey> to difference monoids
13:11:48 <jmcarthur> is this the monoid thing
13:11:51 <jmcarthur> ah
13:12:15 <byorgey> i.e. using (a -> a)  in place of  a, when a is an instance of Monoid
13:12:20 <jmcarthur> right
13:12:32 <monochrom> nice
13:12:32 <byorgey> automatically reassociates all the <> to the right
13:12:46 <jmcarthur> this is also the basis of the fmlist package
13:13:18 <byorgey> ah, cool, I had forgotten about fmlist
13:19:56 <mm_freak> wat?
13:20:57 <monochrom> ohai, we like you
13:21:21 <monochrom> we hate dependency injection. it is so buzzy. :)
13:21:47 <mm_freak> monochrom++
13:21:57 <mm_freak> btw, i love what it is
13:22:00 <mm_freak> i just hate the term =)
13:22:08 <mm_freak> you got me, i love functions ;)
13:25:19 <jmcarthur> i still don't really understand what dependency injection actually is
13:25:35 <jmcarthur> i've read all kinds of bs that claims to explain it, but nothing seems so interesting about it
13:26:32 <parcs> > 24/26
13:26:33 <parcs> > 24/16
13:26:33 <lambdabot>   0.9230769230769231
13:26:34 <lambdabot>   1.5
13:38:17 <frerich_> Which tools parse make use of the source-repository setting in Cabal files?
13:38:23 <frerich_> s/parse//
13:38:50 <byorgey> frerich_: Hackage displays a link to the source repo
13:39:05 <byorgey> frerich_: and I think cabal will soon have a command to let you automatically clone the repo for a package
13:41:56 <simpson> IIUC, IO is strict in every operation. Does this mean that transformers on IO (like, say, StateT s IO) are also strict?
13:44:31 <c_wraith> depends on what you mean by "strict"
13:44:58 <zett_zelett> http://math.stackexchange.com/questions/74347/construct-a-function-which-is-continuous-in-1-5-but-not-differentiable-at-2/74383#74383 omg this is so great.
13:45:26 <c_wraith> « modify (+1) » in StateT Int IO will always build up a thunk
13:45:26 <simpson> Well, for StateT s IO, let's say that each action is strict in s.
13:45:42 <simpson> So only lifted actions will be strict, then?
13:45:59 <c_wraith> It really depends on what you mean by strict.
13:46:16 <c_wraith> There isn't a standard definition for what it means for a monad to be strict
13:46:52 <ciaranm> it means it fails you if you forget to verify the laws
13:49:21 <ski> .. "it fails" meaning ?
13:49:37 <ciaranm> gives you a grade F
13:49:44 <zett_zelett> http://math.stackexchange.com/questions/180605/uniform-distribution-with-probability-density-function-find-the-value-of-k/180649#180649 this might be even greater.
13:54:41 <monochrom> StateT X IO has many things: the state value, the put/get actions, the IO actions, and there are more. you have to say, strict in which one
13:55:21 <monochrom> StateT X IO will not be strict in the X state value. neither "C.M.State.Strict" nor "C.M.State.Lazy" will
13:56:03 <srhb> Well it would certainly help if the names carried some sort of significance.
13:56:09 <simpson> Yeah, I don't understand State.Strict. How is it strict?
13:56:11 <monochrom> but the IO actions will be in the same order as though you're back in IO, if that's what you want
13:56:17 <srhb> How about C.M.State.SomeWhatStringInSomeParametersWhenTheMoonIsJustRight
13:56:32 <srhb> Strict* even.
13:56:40 <simpson> Well, I'm not worried about reordering.
13:56:50 <monochrom> my http://hpaste.org/41790/controlmonadstatelazy shows what's so Strict/Lazy about C.M.State
13:57:06 <simpson> I'm just curious, because I've got lots of lenses doing lots of state alteration and I'm curious about whether or not I could be somehow improving things with more/less strictness.
13:57:52 <c_wraith> when altering the state, the rule is simple: the thunks will only be evaluated when you actually examine the contents of the state
13:58:38 <monochrom> I now wonder what Lazy StateT IO does to the IO actions!
13:59:02 <simpson> So if I want to improve my performance, I'd be better off trying to pull actions out into purer chunks of code that don't know about StateT instead of trying to convince StateT to be better?
13:59:14 <monochrom> hmm, should be same order as IO
13:59:50 <c_wraith> you're always better off doing the calculations with less overhead
14:00:22 <c_wraith> if you're using >>= in a transformed monad when you don't need to, there's definitely a lot of unnecessary overhead
14:01:22 <Ralith> simpson: you should always try to have good factoring regardless
14:01:45 <simpson> Hm. Would it be worth moving some non-IO stuff into StateT s Identity and then calling those from my StateT s IO?
14:01:56 <simpson> Or is IO just as "cheap" as Identity?
14:02:03 * simpson would guess so, but isn't sure
14:03:28 <monochrom> haha, Lazy StateT X IO hangs
14:04:03 <c_wraith> that's what I expected, more or less
14:04:35 <sipa> :t Lazy
14:04:36 <lambdabot> Not in scope: data constructor `Lazy'
14:04:41 <monochrom> yeah, I mispredicted. Lazy StateT's (>>=) simply calls IO's (>>=), cannot do head recursion
14:04:42 <c_wraith> The tricks lazy StateT relies on don't work when the monad it wraps strongly sequences actions
14:04:55 <monochrom> sipa, Lazy is a shorthand for Control.Monad.State.Lazy
14:04:58 * ski imagines doing `unsafeInterleaveIO' in each `(>>=)' in `LazierStateTIO'
14:05:02 <sipa> ha
14:05:10 <monochrom> oh yeah! unsafeInterleaveIO
14:05:21 <c_wraith> brilliant! :)
14:05:25 <monochrom> http://hpaste.org/77374
14:06:40 <ski> monochrom : "head recursion" ?
14:07:15 <monochrom> head recursion means "gen = do { gen >> body }". as opposed to tail recursion
14:07:28 <simpson> @src sequence
14:07:28 <lambdabot> sequence []     = return []
14:07:28 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:07:28 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
14:07:35 <monochrom> err, s/>>/;/ since I'm using do anyway
14:08:57 <ski> c_wraith : .. i wonder how to define "strongly sequences actions"
14:10:15 <ski> (monochrom : hm, i was thinking of something similar to that `gen' style, though for DCG (left-recursion) or for deductive databases (bottom-up left-recursion))
14:11:51 <monochrom> StateT's Lazy vs Strict means this. in m >>= f, m returns (s,x) (or is it (x,s)?), and (>>=) has to pattern-match against that tuple for passing s and x to f. now the difference: Lazy says ~(s,x), Strict says !(s,x)
14:12:51 <elliott> (s,x), I think.
14:12:53 <elliott> @unmtl State s a
14:12:54 <lambdabot> s -> (a, s)
14:12:58 <ski> (like `expr2(E0 ^ E1) --> expr2(E0),[^],expr3(E1).' or `path(First,Last) :- path(First,NextToLast),edge(NextToLast,Last).')
14:12:59 <elliott> oh. (a, s). now why is that
14:13:25 <monochrom> of course, I'm telling this story using modern notation. mtl and transformers was written a long time ago. it was "let (x,s) =" vs "case of (x,s)"
14:14:09 <ziman> > fmap (+1) (2, 2)
14:14:11 <lambdabot>   (2,3)
14:14:11 <mikeplus64> monochrom: hm, would that mean Lazy is more efficient in many cases (ie where you don't care about s, (or x))?
14:14:23 <monochrom> but even sticking to Haskell 98, I would love them to be "case of ~(x,s)" vs "case of (x,s)", to show you clearly what's same and what's different
14:14:25 <mikeplus64> or are they just as lazy as before in Strict
14:14:25 <ski> elliott : .. i'm also annoyed by the ordering in `State' and `Writer' and `random'
14:14:36 <elliott> monochrom: "case of (x,s)"
14:14:37 <ski> @type random
14:14:38 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
14:14:40 <ski> @type mapAccumL
14:14:40 <elliott> I hope Haskell never had that syntax!
14:14:41 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
14:15:01 <awestroke> Is there a way to make this work? "hasPath graph a b = [hasPath graph y b <- (x, y, w) <- edges graph, x == a]" I thought about partially applying hasPath graph with b in some way and then mapping
14:15:08 <awestroke> don't know how to do that though
14:16:29 <ski> awestroke : what do you want to return from the list comprehension ?
14:16:37 <monochrom> mikeplus64, you probably don't realize that "case of (x,s)" does not evaluate x or s
14:17:16 <awestroke> ski: oops... not that right now. I was going to add a "any" function that checks if any element in the result array is true
14:17:26 <monochrom> if your only concern is, "sometimes I don't use x, sometimes I don't use s", then Strict still doesn't evaluate things you don't use
14:17:31 <simpson> :t all -- awestroke
14:17:32 <lambdabot> (a -> Bool) -> [a] -> Bool
14:17:40 <simpson> Er, that's not the one I wanted.
14:17:43 <simpson> :t or
14:17:44 <lambdabot> [Bool] -> Bool
14:17:55 <simpson> > or [False, False, True]
14:17:56 <lambdabot>   True
14:17:59 <mikeplus64> monochrom: but it will deconstruct the tuple?
14:18:09 <monochrom> yes
14:18:21 <awestroke> simpson: thanks! perfect
14:18:54 <mikeplus64> now the question is whether the (x,s) thunk is more expensive than an x thunk and an s thunk :)
14:19:53 <ski> awestroke : perhaps you wanted something like `hasPath graph a b = [blah | (x, y, w) <- edges graph , x == a , blah <- hasPath graph y b]' ..
14:20:06 <monochrom> you are looking at "case this_takes_3_minutes_to_just_yield_the_tuple_ctor of (x,s)/~(x,s)". therefore, gen=do{gen; body} is the right way to look at it
14:20:42 <awestroke> ski: yes, everything up to x == a.. Forgot about | the first time, so I though it was not possible to do it like that ^^
14:21:15 <monochrom> however, no one writes code like that. everyone writes code such that you will use the tuple soon, so you may as well deconstruct the tuple early and free memory
14:21:56 <awestroke> how do I check if a and b are the same instance?
14:22:18 <c_wraith> ski: yeah, I don't know how to formally define that, either
14:22:22 <monochrom> mikeplus64: what you said still indicates misunderstanding
14:22:30 <mikeplus64> monochrom: what did I say
14:22:42 <monochrom> "now the question is whether the (x,s) thunk is more expensive than an x thunk and an s thunk"
14:23:17 <monochrom> suppose you just want to evaluate x. then you must deconstruct the tuple first. the comparison is moot
14:23:59 <monochrom> there are only 3 cases. evaluate nothing. evaluate just to get tuple, evaluate to get both tuple and x.
14:24:35 <monochrom> there is no "evaluate to get x but skip the tuple". therefore, there is no choosing between "the tuple thunk vs the x thunk"
14:25:08 <awestroke> I'm doing something like "hasPath graph a b | a == b = True" and I want it to be true only if a and b is the exact same object. can't find how on google
14:26:19 <ski> so in case `a' and `b' are inequal, `hasPath graph a b' should evaluate to `False', is that correct ?
14:26:53 <awestroke> ski: no I have a follow up guard
14:27:26 <ski> well, you said "I want it to be true only if a and b is the exact same object" .. perhaps you meant something different
14:27:30 <awestroke> and | otherwise = ...
14:27:47 <awestroke> I want that guard to be true only if a === b, not if a eq b
14:27:57 <geekosaur> um
14:28:01 <ski> .. e.g. "I want it to be true when a and b is the exact same object" ?
14:28:03 <awestroke> right now, ghc wants be to make the type deriving eq
14:28:04 <geekosaur> have you heard of referential transparency?
14:28:05 <simpson> awestroke: There's no such test in Haskell.
14:28:29 <ski> awestroke : there are no standard operations called `===' nor `eq' in Haskell
14:28:53 <awestroke> no, I was just trying to communicate my goal
14:29:21 <awestroke> so how do I make haskell interpret "Node 10 == Node 10" as False?
14:29:34 <mikeplus64> awestroke: unless you use MVars or IORefs or similar, there is no difference
14:29:38 <ski> i don't think there's any simple way around the `Eq' constraint here
14:29:39 <monochrom> I have also decided that "StateT X IO" has StateT inner, IO outer. as opposed to what people usually say about StateT being an outer wrapper
14:29:47 <ski> awestroke : no
14:30:24 <geekosaur> awestroke, referential transparency requires that there be no observable difference between those
14:31:19 <awestroke> damn
14:31:45 <bergmark> monochrom: yeah i think so as well, i think :)
14:31:46 <mikeplus64> by all accounts, this is a Good Thing[tm]
14:31:48 <mikeplus64> awestroke:
14:32:13 <geekosaur> it means a haskell implementation is free to share as much or as little of a value as it desires
14:32:20 <awestroke> how do I calculate the minimum distance between nodes a and b if half the nodes are indistinguishable from b
14:32:25 <geekosaur> which can save a lot of memory
14:32:34 <monochrom> if you look at "ParsecT (ContT IO)" for example, the actual code is "do x <- runContT (runParsecT blah)". parsec is the innermost, cont is in the middle, and the IO do-block is the outermost
14:33:25 <ski> awestroke : we want to enable the compiler to restructure code so that what you might think are two distinct (but structurally equal) run-time objects are actually optimized to be the same object; or vice versa
14:33:57 <geekosaur> if you have multiple nodes and you want them to distinct then you need to label them somehoiw
14:34:06 <ski> awestroke : and we also want to enable the human reader/maintainer to restructure code in such ways, using equational laws, without fear of changing the behaviour of the program
14:34:08 <awestroke> ski: that amounts to a divine, shining, perfect stick right through my wheel
14:34:29 <monochrom> you can also look at the types and expressions. StateT X IO a is X -> IO (a, X). IO is being outer, you transport extra data inside IO, not outside
14:34:29 <awestroke> M)
14:34:30 <awestroke> ;)
14:34:55 <awestroke> I will look into labeling them.. Thanks for explaining
14:35:02 <monochrom> (>>=) of StateT X IO is (>>=) of IO with extra data smuggling
14:35:31 <ski> @unmtl StateT X IO a
14:35:31 <lambdabot> X -> IO (a, X)
14:37:02 <simpson> Makes sense, I guess.
14:38:53 <monochrom> my elaborate example http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#yield-intro really makes you rethink what is inside and what is outside.
14:39:19 <otters> apparently it's a bad idea to use template haskell to define a datatype with 16777216 constructors
14:40:08 <monochrom> it makes generators and the "yield" command. it makes them at the ContT IO level. and it still can suspend and resume a parser written at the ParsecT (ContT IO) level
14:40:54 <monochrom> if you think in terms of "ParsecT is outside, ContT IO is inside", you cannot imagine why the inside can suspend and jump out, then jump back in and resume
14:41:55 <monochrom> but if you think "ParsecT is inside, ContT IO is outside", then it is more believable that ContT IO is being the master here, therefore it can suspend and resume at will
14:48:43 <AfC> "I is the master". Sounds like a good B grade zombie flick.
14:49:04 <Nisstyre> AfC: sounds like a good pun
14:49:10 <Nisstyre> a giant eye that controls everyone
14:49:48 <Nisstyre> <insert nerdy D&D reference to beholders>
14:50:07 <monochrom> the game master is the real master
14:52:33 <awestroke> does not Ord imply Eq?
14:52:41 <monochrom> yes does imply
14:55:32 <ski> @type let eqImpliedByOrd :: (Eq a => f a) -> (Ord a => f a); eqImpliedByOrd fa = fa in eqImpliedByOrd
14:55:33 <lambdabot> Ord a => (Eq a => f a) -> f a
15:02:20 <kadams_> hello
15:04:52 <parcs> hallo
15:17:09 * hackagebot kevin 0.1.6 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.1.6 (JoelTaylor)
15:17:50 <nirajs> hii
15:18:08 <nirajs> sir I wrote a program to implement take funtion of haskell
15:18:16 <nirajs> pls tell me where I am wrong
15:18:17 <nirajs> #haskell
15:18:24 <nirajs> take::(Num a, Ord a)=>a->[a]->[a] take a x:xs 	| a==0&&xs==[] = [] 	| a<0 error " invalid case " 	| a>length (x:xs) " invaid case " 	| otherwise b:take (a-1) bs
15:18:32 <b__thesunalso> @hpaste
15:18:32 <lambdabot> Haskell pastebin: http://hpaste.org/
15:18:46 <nirajs> k thnks
15:19:02 <hpaste> nirajs pasted “take ” at http://hpaste.org/81092
15:22:09 * hackagebot aws 0.7.6 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.6 (AristidBreitkreuz)
15:22:17 <phyrephox> hi all,
15:22:23 <phyrephox> i'm having trouble installing the http-server package
15:22:58 <phyrephox> i'm getting this: https://gist.github.com/9c427c84bae806750764
15:23:18 <phyrephox> (when i try to install using cabal i get a compile error, so i'm trying to install manually)
15:23:37 <fmap> what's the compile error?
15:23:37 <phyrephox> however, i checked all the package versions for the listed packages, and they seem to be within the ranges. and they're all installed
15:23:54 <phyrephox> https://gist.github.com/ede96ed1252c8bbaefa6
15:26:06 <fmap> hmm, I guess http-server is not compatible with network >= 2.4
15:26:35 <phyrephox> ok i see
15:26:37 <phyrephox> i'll try downgrading
15:26:53 <hpaste> b_ annotated “take ” with “take  (annotation)” at http://hpaste.org/81092#a81093
15:27:02 <b__thesunalso> nirajs: ^^
15:27:55 <fmap> downgrading network will probably break a lot of stuff :(
15:28:48 <nirajs> thankyou very much
15:29:02 <b__thesunalso> no problem, good night
15:29:14 <fmap> phyrephox: you may try hiding `close' from Network.Socket import
15:29:34 <fmap> (in http-server sources that is)
15:30:04 <phyrephox> yeah that's what i was planning on doing, but i can't even get past configure
15:30:54 <phyrephox> i tried ghc-pkg unregister network-2.4.1.0 but it said it would break some other packages -- it seems like doing that would enter me into dependency hell
15:31:23 <fmap> phyrephox: try `cabal configure' instead of `runhaskell Setup.hs configure'
15:32:04 <phyrephox> fmap: that worked, going to modify the source...
15:32:05 <fmap> I hope you have cabal-install installed :)
15:32:50 <fmap> phyrephox: yeah, cabal-install and runhaskell Setup.hs have inverted defaults :]
15:33:00 <monochrom> whenever there is a dependency hell problem, you can be pretty sure that cabal-install is installed, and involved
15:33:34 <hpaste> “Anonymous Coward” annotated “take ” with “take  (annotation)” at http://hpaste.org/81092#a81094
15:34:05 <frerich_> Coolness, with a lot of help from this channel (thanks guys!) I managed to create a first version of a multithreaded web crawler with Haskell. And it's still less than 200 LOC! This is the most complex Haskell program I ever wrote. :-) I'd be happy to hear about any comments regarding the code, which can be found at https://github.com/frerich/lambdacrawler/blob/master/main.hs
15:36:23 <phyrephox> fmap: new compile error, https://gist.github.com/558b289cd4692e863523
15:38:48 <phyrephox> maybe i should try another version of http-server?
15:39:17 <fmap> phyrephox: yeah, you don't want that one from 2009
15:39:37 <monochrom> there are only two versions to try :)
15:40:00 <phyrephox> yeah... neither one works... fmap, is there a newer version? i can't find anything on the web
15:40:13 <monochrom> but on my computer socketConnection wants one more parameter. String -> Int -> Socket -> IO (HandleStream ty). you're missing the Int. (port number?)
15:40:24 <phyrephox> ah, maybe this: https://github.com/GaloisInc/http-server
15:43:44 <monochrom> eh, http-server 1.0.1 builds fine on current Haskell Platform (network 2.3.1.0)
15:44:20 * monochrom loves sandboxing. so he can try-build this and then throw it away
15:44:41 <phyrephox> i'm a dumbass though and didn't install the haskell platform -- i installed from the ubuntu package manager :(
15:44:44 <monochrom> I love sandboxing. it's so lazy. and where is shachaf? :)
15:44:50 <shachaf> hi monochrom
15:45:01 <monochrom> ubuntu which version?
15:45:10 <davorak> If I have a type sig of blah :: m a -> m' b is there any way of telling the type checker that a /=b and m /=m'?
15:45:30 <phyrephox> anyway, i fixed it by installing the version from github
15:45:36 <phyrephox> thanks fmap and monochrom!
15:45:42 <monochrom> eh? new theme at packages.ubuntu.com
15:46:00 <phyrephox> its like 11.something LTS server i think
15:46:14 <monochrom> ok that may be too old yes
15:46:47 <Hermit> davorak: why would you want that?
15:48:06 <monochrom> 10.04 LTS? 12.04 LTS? there is no 11.something LTS
15:48:48 <otters> davorak: the fact that they have different names tells the typechecker that
15:49:05 <davorak> no the type check allows them to be the same.
15:49:05 <phyrephox> ah, sorry Ubuntu 12.04.1 LTS
15:49:11 <otters> wait, no it doesn't
15:49:16 <davorak> blah :: a -> b can be blah Int -> INt
15:49:17 <otters> why would you want that
15:49:40 <otters> and also, no, that isn't possible
15:49:45 <otters> as far as I know
15:49:59 <monochrom> http://packages.ubuntu.com/precise/libghc-network-dev  2.3.0.10  not old at all
15:50:08 <davorak> There is an interesting pseudo proof method at the bototm of olegs cont tutorial that could be extended with prarameterized monads and a type sig like the aformentioned.
15:51:26 <davorak> otters: That is unfortunate
15:51:56 <Hermit> davorak: you could go about doing that with a 2 param typeclass, using functional dependencies to make one arg dependant to the other. But then you'd need to define instances of all the types that you would need
15:52:07 <monochrom> eh? I force my computer to bring in and use network-2.3.0.10, still no compiler error for http-server
15:52:33 <Hermit> davorak: if you need to operate on a fistful of types, it's doable, but ugly
15:53:13 <monochrom> "cabal install http-server --constraint='network == 2.3.0.10'" succeeded
15:56:03 <davorak> Hermit: I am not very knowledgable about functional dependencies, but that is where I thought I would find a solution. I do not follow how I can use 2 param typeclass to get a sigg that specifies that blah :: a -> b | (a /= b)
16:03:32 <Mathnerd314> frerich: why do you use MVar instead of TMVar?
16:04:28 <shachaf> TMVar is a trademark of Research Software Ltd.
16:05:10 <monochrom> heh
16:07:01 <hpc> Var(TM)
16:16:15 <nirajs> sir pls help me in quicksort it says parse error at '=' but i could not understand
16:16:20 <hpaste> nirajs pasted “pls help me on this” at http://hpaste.org/81095
16:17:25 <davorak> Equality contraints allow for t1 ~ t2 to indicat that t1 is the same type as t2 in the presence of type families but I can not find any hints to get t1 /~ t2 t1 to not equal t2.  Anyone have any ideas?
16:18:03 <kennyd> nirajs white space matters in haskell syntax. line up big variable with small
16:18:32 <nirajs> oh I see thanks alot kennyd
16:18:37 <kennyd> welcome
16:23:47 <msxx> this is my sloppy attempt to fetch every other element in a list. can someone come up with something elegant?
16:23:54 <msxx> > let xs = [1..10]; nDrop = 2 in reverse . snd . foldl (\(n,xs) x -> (n+1, if n `mod` nDrop == 0 then x:xs else xs)) (0, []) $ xs
16:23:55 <lambdabot>   [1,3,5,7,9]
16:24:57 <hpc> > let others = foldr (\x xs -> x : tail xs) [] in others [1..10]
16:24:58 <lambdabot>   [1*Exception: Prelude.tail: empty list
16:25:10 <geekosaur> davorak, http://stackoverflow.com/questions/6939043/is-it-possible-to-place-inequality-constraints-on-haskell-type-variables
16:25:16 <hpc> > let others = foldr (\xs x -> x : tail xs) [] in others [1..10]
16:25:19 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [a0]
16:25:21 <hpc> pah
16:25:24 <elliott> > zip f [1,2,3] (tail [1,2,3])
16:25:26 <lambdabot>   Ambiguous occurrence `f'
16:25:26 <lambdabot>  It could refer to either `L.f', defined at <local...
16:25:30 <elliott> !
16:25:44 <elliott> @tell Cale simple-reflect "f" is broken in lambdabot
16:25:44 <lambdabot> Consider it noted.
16:25:49 <elliott> > zip g [1,2,3,4,5] (tail [1,2,3,4,5])
16:25:51 <lambdabot>   The function `GHC.List.zip' is applied to three arguments,
16:25:51 <lambdabot>  but its type `[...
16:25:57 <elliott> > zipWith g [1,2,3,4,5] (tail [1,2,3,4,5])
16:25:58 <Cale> @undefine
16:25:58 <lambdabot>   Ambiguous type variable `c0' in the constraints:
16:25:58 <lambdabot>    (GHC.Show.Show c0)
16:25:58 <lambdabot>     ...
16:26:05 <Cale> > zip f [1,2,3] (tail [1,2,3])
16:26:06 <elliott> > zipWith g [1,2,3,4,5] (tail [1,2,3,4,5]) :: [Expr]
16:26:06 <lambdabot>   mueval-core: L.hs: openBinaryFile: does not exist (No such file or directory)
16:26:06 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
16:26:07 <lambdabot>   [g 1 2,g 2 3,g 3 4,g 4 5]
16:26:11 <Cale> > zip f [1,2,3] (tail [1,2,3])
16:26:12 <lambdabot>   The function `GHC.List.zip' is applied to three arguments,
16:26:12 <lambdabot>  but its type `[...
16:26:18 <Cale> > zipWith f [1,2,3] (tail [1,2,3])
16:26:19 <lambdabot>   Ambiguous type variable `c0' in the constraints:
16:26:19 <lambdabot>    (GHC.Show.Show c0)
16:26:19 <lambdabot>     ...
16:26:22 <Cale> okay
16:26:25 <elliott> ah, thanks
16:27:09 <elliott> > zipWith id (cycle [f,g]) [1,2,3,4,5] :: [Expr]
16:27:10 <lambdabot>   [f 1,g 2,f 3,g 4,f 5]
16:27:38 <elliott> > concat $ zipWith ($) (cycle [pure, const mempty]) [1,2,3,4,5] :: [Expr]
16:27:40 <lambdabot>   [1,3,5]
16:27:56 <elliott> > let others = concat . zipWIth ($) (cycle [pure, const []]) in others [1,2,3,4,5]
16:27:56 <msxx> nice
16:27:57 <lambdabot>   Not in scope: `zipWIth'
16:27:57 <lambdabot>  Perhaps you meant one of these:
16:27:57 <lambdabot>    `zipWith' (impo...
16:28:02 <elliott> pah
16:28:06 <elliott> > let others = concat . zipWith ($) (cycle [pure, const []]) in others [1,2,3,4,5]
16:28:08 <lambdabot>   [1,3,5]
16:28:16 <elliott> probably the plain recursive definition is most readable though
16:28:35 <elliott> > let others = concat . zipWith ($) (cycle [pure, const []]) in others [1]
16:28:37 <lambdabot>   [1]
16:28:40 <elliott> > let others = concat . zipWith ($) (cycle [pure, const []]) in others [1,2,3]
16:28:42 <lambdabot>   [1,3]
16:28:43 <msxx> yeah. especially if I want to make it more general (drop every N element)
16:28:43 <elliott> right
16:29:24 <elliott> > let every n = concat . zipWith ($) (cycle (pure : replicate n (const [])) in every 2 [..]
16:29:25 <lambdabot>   <hint>:1:75: parse error on input `in'
16:29:27 <elliott> > let every n = concat . zipWith ($) (cycle (pure : replicate n (const []))) in every 2 [..]
16:29:29 <lambdabot>   <hint>:1:88: parse error on input `..'
16:29:34 <elliott> > let every n = concat . zipWith ($) (cycle (pure : replicate n (const []))) in every 2 [1..]
16:29:35 <hpc> there's also Maybe
16:29:36 <lambdabot>   [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
16:29:50 <elliott> hmm, what
16:29:54 <msxx> heh
16:29:55 <elliott> > let every n = concat . zipWith ($) (cycle (pure : replicate (n-1) (const []))) in every 2 [1..]
16:29:56 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
16:29:58 <elliott> > let every n = concat . zipWith ($) (cycle (pure : replicate (n-1) (const []))) in every 10 [1..]
16:30:00 <lambdabot>   [1,11,21,31,41,51,61,71,81,91,101,111,121,131,141,151,161,171,181,191,201,2...
16:30:18 <davorak> geekosaur: Thanks
16:30:44 <elliott> feel there's a nicer way to write that
16:30:50 <elliott> oh hm
16:30:52 <fragamus> (+) <$> (+3) <*> (*100) $ 5
16:30:55 <elliott> :t \f -> concat . zipWith ($) f
16:30:56 <lambdabot> [b -> [a]] -> [b] -> [a]
16:30:59 <fragamus> > (+) <$> (+3) <*> (*100) $ 5
16:31:01 <lambdabot>   508
16:31:05 <elliott> :t \f -> join . (f <*>)
16:31:06 <lambdabot> (Monad m, Applicative m) => m (a1 -> m a) -> m a1 -> m a
16:31:12 <fragamus> i need help sorting that out ^
16:31:54 <fragamus> it seems that the 5 gets used twice
16:32:57 <fragamus> nvm
16:33:00 <johnsonw> If I'm consuming (like with map or whatever) a list, rather than storing it, it doesn't matter if that list comes from two massive lists joined by ++ does it? I know it allocates a new spine, but that spine is garbage as quickly as it's allocated isn't it?
16:33:01 <fragamus> i got it
16:36:41 <msxx> what should dropEvery 0 [1..10]?  how about 1 instead of 0?
16:36:46 <msxx> return
16:37:36 <monochrom> what is dropEvery?
16:38:02 <kylcarte> :t dropEvery
16:38:04 <lambdabot> Not in scope: `dropEvery'
16:38:34 <msxx> a function I am writing. dropEvery n xs will drop every nth element
16:39:50 <monochrom> so, are we going to argue over what the English "drop every nth element" means?
16:40:30 <msxx> that was the idea. what does dropping every first element means? every zeroth?
16:41:02 <Maxdamantus> :t \n -> map snd . filter ((/= n) . fst) . zip (cycle [1..n])
16:41:03 <lambdabot> (Enum a, Eq a, Num a) => a -> [b] -> [b]
16:41:17 * Maxdamantus would expect it to do something like that.
16:41:32 <monochrom> perhaps 0 should be rejected
16:42:10 <Maxdamantus> s/something like //
16:42:50 <Maxdamantus> "*** Exception: Prelude.cycle: empty list
16:44:39 <msxx> how about dropEvery 1 _ = []; dropEvery 0 xs = xs
16:45:35 <msxx> Maxdamantus: nice implementation btw
16:46:00 <elliott> > let every n = concat . zipWith ($) (cycle (pure : replicate (n-1) (const []))) in every 0 [1..10]
16:46:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:46:04 <elliott> > let every n = concat . zipWith ($) (cycle (pure : replicate (n-1) (const []))) in every 1 [1..10]
16:46:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:46:26 <elliott> Maxdamantus: oh, that version is clever
16:46:37 * lispy thinks we should get LiquidHaskell hooked up to lambdabot 
16:46:46 <lispy> Wouldn't that be fun?
16:47:06 <monochrom> what does LiquidHaskell do?
16:47:24 <lispy> monochrom: adds refinement types to haskell
16:47:32 <lispy> it calls out to Z3 to solve them
16:47:33 <monochrom> yikes, that will be fun
16:48:10 <lispy> monochrom: http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/blog/2013/01/01/refinement-types-101.lhs/
16:48:17 <lispy> they have a demo
16:48:22 <ion> Interesting
16:48:31 <byorgey> lambdabot already has enough trouble just evaluating Haskell expressions, good luck having it run an instance of Z3 as well =P
16:48:41 <monochrom> I love predicate subtypes
16:48:58 <Philippa> Z3?
16:49:11 <lispy> byorgey: heh. There is that...
16:49:12 <monochrom> Z3 is an automatic theorem prover
16:49:24 <Philippa> also I'm having to do something in the ballpark of refinement types (and classes operating on them) at the moment and it's a PITMFA!
16:49:32 <ion> I can’t say i’m a fan of the syntax they’re using.
16:49:34 <lispy> Philippa: Z3 is an SMT solver developed by MS and recently they made it "free" for open source/academic use
16:49:41 <Philippa> ah. Makes sense, I guess
16:49:53 <Philippa> Some ideas are really coming of age right now
16:50:33 <Philippa> (I think we're starting to get in need of another 'qualified types' paper! The Implicit Calculus is definitely targetted at one chunk of the issue)
16:51:03 <Philippa> (but there's another side that feels like it wants covering somewhere, I think)
16:51:33 <lispy> byorgey: Right now lambdabot runs on an inexpensive linode. If there are beefier hosting services around the same price I could probably be convinced to switch.
16:52:55 * byorgey wouldn't know
16:53:08 <byorgey> lispy: oh, are you the one who maintains/hosts lambdabot now?
16:53:47 <lispy> byorgey: ever since Don left UNSW I've been hosting the machine and Cale runs lambdabot out of his shell account.
16:54:01 <byorgey> ahhh, I see
16:54:50 <lispy> It's not perfect. I forget to upgrade ghc for years at a time on that machine :)
16:55:18 <lispy> Cale doesn't mind being the lambdabot admin, but I think he doesn't want to be the maintainer
16:55:28 <Cale> Yeah
16:55:36 <Ralith> lispy: SMT?
16:55:38 <lispy> We really could use a third person to fill that role
16:55:46 <lispy> Ralith: Satisfiability modulo theories
16:55:49 <Ralith> o
16:55:54 <lispy> Ralith: basically, SAT + arithmetic
16:56:04 <Ralith> sounds useful!
16:56:28 <monochrom> not just arithmetic. anything with a decision procedure
16:57:11 <lispy> You can make a rough ordering of theorem proving as: SAT < SMT < {Interactive Theorem provers, Dependent types}
16:57:25 <monochrom> it can prove: length "abc" > 2
16:57:36 <lispy> where you go from simple to more complex but you gain something in expressive power
16:59:12 <lispy> For folks who want to learn about SMT there are several bindings on hackage. sbv, yike-{easy,painless}, and probably more
17:03:18 <edwardk> is there any easy way to find out the versions of everything that came with older haskell platforms without installing them?
17:03:56 <edwardk> lispy: that reminds me i should resurrect my SMT bindings some day
17:06:08 <geekosaur> sadly it looks like the wayback machine didn't start logging haskell.org/platform/changelog.html until fairly late :(
17:07:47 * hackagebot cabal-rpm 0.7.0 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.7.0 (JensPetersen)
17:08:05 <applicative> the source itself is linked http://www.haskell.org/platform/prior.html
17:08:34 <applicative> no i take that back some of the older links are dead
17:11:25 <monochrom> edwardk: if you can find old tarballs, you can just unpack and do some ls and cat
17:12:01 <monochrom> oh noes, edwardk is on to SMT lens
17:12:35 <monochrom> unfortunately, I tossed out the old tarballs, too
17:12:49 <applicative> i dont see tarballs before 2011
17:13:18 * hackagebot thyme 0.1.1.1 - A faster time library  http://hackage.haskell.org/package/thyme-0.1.1.1 (LiyangHu)
17:15:56 <monochrom> http://hackage.haskell.org/package/haskell-platform-test tells you something about way back in 2010.2.0.0 :)
17:15:58 <applicative> it seems there is a document platform.packages in each tarball with the desired list
17:16:20 <monochrom> yeah
17:16:57 <lispy> edwardk: yeah, esp. considering it's yices-{easy,painless} not what I typed :)
17:17:07 * lispy makes silly typos when excited
17:18:39 <monochrom> I knew something was wrong with "yike" but I could not remember the correct name "yices"
17:19:48 <applicative> ooh, the thyme library has l_ns_s
17:20:22 * simpson doesn't understand why time is slow
17:20:35 <fragamus> being a haskell coder is like being a botswainian lumberjack
17:20:57 <johnw> fragamus: how is that?
17:21:11 <fragamus> well, there are no trees in botswana
17:21:16 <monochrom> haha
17:21:17 <johnw> lol
17:22:05 <monochrom> I know
17:22:47 <monochrom> being a haskell coder is like being a python optometrist. there is no lens in python.
17:22:55 <Hafydd> Hahah.
17:23:18 * hackagebot functor-combo 0.3.1 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.3.1 (ConalElliott)
17:24:00 * monochrom is very good at designing snark remarks that offends multiple communities at once, even multiple communities that usually oppose each other
17:29:02 <msxx> is it wrong to say that haskell has duck typing?
17:29:27 <Hafydd> Yes.
17:29:29 <elliott> yes
17:29:32 <feliperosa> yea
17:29:32 <shachaf> It's pointless to say it.
17:31:23 <feliperosa> since Haskell checks all types in compile-type (unless there's some ghc extension that allows it to postpone)
17:31:29 <msxx> because haskell is statically typed? how do we call it then
17:31:33 <feliperosa> is there?
17:32:10 <geekosaur> it checks at compile time, although you can use Data.Dynamic to work (with some difficulty) with dynamically typed values
17:32:26 <feliperosa> ugh
17:32:54 <simpson> msxx: Yes, Haskell is statically typed, and strongly typed.
17:34:08 <applicative> I thought lenses gave us duck typing http://chrisdone.com/posts/duck-typing-in-haskell
17:34:12 <applicative> naw
17:34:15 <pcarrier> hi! I'm trying to install cabal-dev on haskell platform (OSX), I have cabal update && cabal install cabal-install, and it seems to complain a lot
17:34:16 <pcarrier> https://gist.github.com/d7748ae8208fea0d4924
17:34:38 <feliperosa> msxx: And completing simpson, you would need something to allow type checking at runtime to have duck typing
17:34:53 <pcarrier> any help would be welcome. I know near to nothing about the ghc ecosystem.
17:34:55 <monochrom> say "haskell has static typing"
17:35:10 <msxx> what is haskell equivalent called then? not having to specify types
17:35:14 <ion> msxx: In Haskell, you often use type classes for the “quacks like a duck” thing.
17:35:22 <pcarrier> msxx, switching languages? :)
17:35:36 <applicative> msxx you don't have to specify types for the most part
17:35:40 <geekosaur> msxx: type inference
17:35:41 <monochrom> but I think "haskell has duck typing" is not so wrong
17:35:48 <applicative> msxx with a real type system, you have inference
17:36:04 <applicative> and then with an ultra-real type system, you lose it again, but never mind
17:36:23 <applicative> pcarrier: are you using a cabal-dev from github?
17:36:28 <monochrom> it looks like a duck, it type-checks as a duck, it is a duck
17:36:44 <feliperosa> hahah
17:36:55 <pcarrier> applicative, I don't know. but I never specified any 3rd party source from haskell platform
17:36:56 <feliperosa> it type-checks as a duck, it is a duck
17:37:40 <ion> msxx: For instance, “show” works with a bunch of types and you can implement show for your type, too.
17:38:52 <pcarrier> applicative, I provided a "cabal list --installed --simple-output" in the gist, can that answer?
17:39:12 <applicative> sorry didn't see the gist
17:39:17 <pcarrier> applicative, no problem
17:39:18 <applicative> just a sec
17:39:33 <pcarrier> applicative, thanks
17:39:40 <otters> say my application has two threads; one runs a timer that the other can reset, and if the timer runs out, the timer thread sends a message to the other thread
17:39:44 <otters> what's the best way to implement this
17:39:48 <otters> my first thought was exceptions
17:40:08 <Philippa> monochrom: yeah, if you consider "static duck typing" to be a degenerative case that isn't duck typing per se, it makes enough sense. Apparently that TMR article I wrote yonks back generated a non-trivial amount of heat on a Ruby site I only heard about via an old friend years later because he'd run into it and gone "ah, that's what she's been up to!"
17:40:40 <applicative> you don't want new versions of those pcarrier, things in the platform.
17:41:07 <pcarrier> applicative, sorry, no new versions of? :)
17:41:27 <applicative> pcarrier: I'm not sure which og the assorted github branches is the going one of cabaldev
17:41:58 <applicative> the author of cabal dev gave up on it for some reason; but other people keep maintaining branches.
17:42:02 <monochrom> to install a sandboxer, you must first install a sandboxer
17:42:07 <pcarrier> wow, I completely fail to parse that sentence. feels weird to be the newbie again.
17:42:23 <applicative> I don't know what the wisdom is, on which is best, but there are patches are recent as today on some of them...
17:42:37 <applicative> which is the best branch repo I mean
17:42:40 <pcarrier> well, I'm fine giving up on sandboxing.
17:43:26 <pcarrier> updated the gist with "cabal install -j snap" which fails too :)
17:44:15 <pcarrier> I can give you a similar output with cabal install -j yesod-platform
17:44:25 <applicative> pcarrier: how long have you been installing with this ghc?
17:44:42 <pcarrier> applicative, first day. tried to removed everything before.
17:44:50 <applicative> pcarrier: you are installing some complicated stuff, boy!
17:44:52 <pcarrier> with uninstall-hs, ~/Library/Haskell, ~/.cabal
17:44:54 <feliperosa> otters: Do you have anything implemented?
17:44:59 <monochrom> otters: I am not sure what you use exceptions for. for telling the timer thread to reset? for sending a message to the non-timer thread?
17:44:59 <otters> feliperosa: not yet
17:45:02 <pcarrier> applicative, am I, really? :]
17:45:05 <applicative> https://github.com/creswick/cabal-dev seems to have committed recently
17:45:08 <otters> monochrom: both, I suppose >_>
17:45:16 <applicative> pcarrier: yesod is such a monster
17:45:23 <otters> because it's not like the threads are waiting for each other's messages, it's more like raising an interrupt
17:45:30 <applicative> let me study the output, maybe I will have some thought.
17:45:50 <pcarrier> applicative, so you don't think I have some more general issue?
17:46:01 <applicative> pcarrier: sorry, maybe it sounded like I was opposing installing all these things; not at all.
17:46:06 <pcarrier> applicative, for cabal-dev, snap, yesod-platform to all fail? :D
17:46:08 <monochrom> well, the benefit of doing both is that only one happens
17:46:09 <feliperosa> otters: well, in that case I think it's better to go with exceptions
17:46:24 <pcarrier> applicative, I assumed something was broken on my system
17:46:36 <feliperosa> otters: Have you seen Control.Concurrent.throwTo?
17:46:42 <otters> feliperosa: that's what I was going to use
17:47:36 <Saizan> msxx: if you mean not havint to write out type signatures it's called having type inference
17:47:47 <otters> I wasn't sure how I would tell the threads each other's ThreadIds but I suppose I could use an MVar
17:48:08 <feliperosa> otters: One question I have is: you want the target thread to be terminated?
17:48:31 <applicative> pcarrier: there is something wrong. two versions of the Cabal library, for one thing. hm...
17:48:39 <otters> feliperosa: target thread = not the timer thread?
17:48:44 <otters> because not necessarily
17:48:49 <monochrom> two versions of Cabal is because of "cabal install cabal-install"
17:48:50 <otters> I just want an exception to be thrown
17:48:55 <pcarrier> applicative, couldn't that derive from having one system-wide in haskell-platform and one after running cabal install cabal-install?
17:48:57 <applicative> yes monochrom
17:49:00 <otters> okay, I think I'll eliminate the xy problem and explain my entire situation
17:49:17 <otters> I have this program that acts as a proxy between IRC and another chat protocol, kinda like bitlbee but for one network only
17:49:27 <applicative> yes pcarrier but it is highly suspicious, I'm not sure what monochrom will advise :)
17:49:28 <monochrom> I keep telling people to refuse to upgrade, and they keep telling me back "what's the harm? it's just an executable!"
17:49:30 <otters> and when I lose connection to the remote server, hGetChar just hangs indefinitely
17:49:40 <otters> instead of timing out and allowing me to gracefully restart
17:49:42 * applicative sees what monochrom will advise
17:49:44 <monochrom> it is bloody not just an executable
17:49:57 <otters> so I figured I would keep track of when the last packet was received and time out manually
17:50:06 <feliperosa> oh right
17:50:16 <pcarrier> monochrom, so it'd be best to start from scratch? I'm probably gonna miss cabal install -j but I can live without
17:50:17 <applicative> I think pcarrier, that you should stick with the platform cabal-install, or else chuck the platform and install the ghc-7.6 binary, and then cabal install
17:50:33 <applicative> then the newer cabal install
17:50:40 <otters> alternatively, has anybody had a problem with hGet* hanging forever when the connection was lost?
17:51:07 <pcarrier> applicative, will give that a try. thanks!
17:51:09 <feliperosa> otters: you could kill the blocked thread using killThread and restart it. I think it's a reasonable solution
17:51:18 <monochrom> if you have cabal-dev, use cabal-dev to upgrade cabal-install, so that you can throw away the new Cabal
17:51:22 <otters> feliperosa: okay, fair enough then
17:51:37 <applicative> I am using the ghc-7.6 binary tarball thingy on os x.  I haven't tried to install a gui machinery; that's the only thing that is likely to cause trouble
17:51:53 <DanC> I think I just successfully compiled my 1st haskell program ;-)
17:52:00 <applicative> cabal dev was the target here, monochrom
17:52:04 <applicative> DanC: GOOD WORK
17:52:21 <monochrom> yeah. to install a sandboxer, you must first install a sandboxer
17:52:34 * applicative still remembers typing ghc --make for the first time, following a blogpost of stepkut
17:52:59 <applicative> pcarrier: you may be surprised to learn that monochrom is quite helpful on these matters
17:53:21 <pcarrier> :)
17:53:34 <pcarrier> well, thanks guys. I'll try going without haskell platform.
17:53:47 <monochrom> ah, but do you also remember typing "ghc --make" for the last time? :)
17:54:04 <pcarrier> well, "brew install ghc" might do that for me? :)
17:54:10 <pcarrier> but I will, thanks
17:54:23 <applicative> there is a platform uninstaller somewhere
17:54:26 <mnc> hi
17:54:31 <applicative> what does brew install give you now?
17:54:31 <pcarrier> sudo uninstall-hs --remove thru 7.5
17:54:50 <pcarrier> applicative, /usr/local/Cellar/ghc/7.4.2 (5176 files, 767M) *
17:55:00 <mnc> could somebody maybe take a look at this? http://hpaste.org/81099, rather new to haskell and I'm not sure what the best way to go about this is
17:55:55 <applicative> pcarrier: yeah I see it.  Hm, I wonder if that will cause trouble with a new cabal-install though.
17:56:08 <pcarrier> applicative, the ghc version?
17:56:27 <pcarrier> applicative, god, this haskell ecosystem likes to feel wanted, doesn't it?
17:56:34 <monochrom> otters: I think throwing exceptions both directions is right for this
17:56:38 <applicative> it's the same ghc as you have, which is what gave you the 'out of date' Cabal library, spurned by the new cabal-install
17:57:01 <otters> monochrom: out of curiosity, can you think of a more "haskelly" way to do this
17:57:04 <applicative> the Cabal package comes with ghc and is sort of wired in, this is why it's bad to cabal-install cabal install without --dry-run
17:57:07 <pcarrier> applicative, oh cabal is part of ghc?
17:57:14 <pcarrier> mkay. thanks.
17:57:25 <applicative> pcarrier: it's a boot library or whatever the jargon is.
17:57:26 <monochrom> no, i can't, apart from finding out why hGetChar doesn't abort
17:57:43 <applicative> pcarrier: the executable cabal-install is not part of ghc
17:57:45 <geekosaur> mnc, in Haskell it is the caller that decides the result type.  the correct way to do it is an additional ADT which has constructors for the various possibilities
17:57:46 <pcarrier> oh yeah, that's a really old ghc version.
17:57:54 <pcarrier> is there a recent distribution of ghc for OSX?
17:58:40 <applicative> pcarrier: anyway, starting over with the homebrew thing should be fine if you don't update cabal install.  I think that yesod for example is not yet taking account of ghc-7.6
17:59:01 <applicative> pcarrier: yes there is a 7.6 binary tarball, just a sec
17:59:01 <pcarrier> no backwards-compatibility?
17:59:06 <pcarrier> http://www.haskell.org/ghc/download_ghc_7_6_1#macosx_x86_64
18:00:01 <applicative> http://www.haskell.org/ghc/download_ghc_7_6_1 yes
18:00:01 <applicative> pcarrier, you can install it locally, that's what I do these days, having formerly done it just for HEAD
18:00:33 <applicative> just put /Users/pcarrier/ghc76/bin or wherever you put it in PATH
18:01:02 <hpaste> geekosaur annotated “function -> Basic a” with “function -> Basic a (annotation)” at http://hpaste.org/81099#a81100
18:01:13 <applicative> pcarrier: the old cabal executable(s) may still work, but you can also use the build script whatever its called from inside the cabal-install tarball
18:01:17 <mnc> geekosaur: so I could make class Basic a where ... and then have instances for all the different types?
18:01:40 <geekosaur> this is not a class, it's just a data
18:01:42 <pcarrier> hmmm what's a bindist? looks like it contains source code.
18:02:04 <geekosaur> um?  bindist is a relocatable binary with some stuff to do the relocation
18:02:10 <pcarrier> oh ok.
18:02:13 <pcarrier> he he thanks.
18:02:32 <applicative> pcarrier: no, just unpack it, cd inside and follow the README
18:02:34 <applicative> pcarrier: our friend monochrom has the idea under 'ghc' here http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
18:02:37 <EvanR> so is it (unblock foo) `catch` bar, or unblock (foo `catch` bar) ?
18:02:53 <applicative> pcarrier he uses xhtml because it's the format of the future
18:03:51 <monochrom> because <![CDATA does not work in html
18:03:55 <pcarrier> ha ha I remember defending XHTML 1.1 because being XML was the thing. and somewhere on the way I got lost and started seeing XHTML as a presentation format, not a storage one.
18:04:00 <geekosaur> mnc, a typeclass has the same problem as just saying 'Result a':  it's the caller that gets to say which class instance is used, not your function
18:04:59 <pcarrier> it went downhill from there. now my most structured thought about W3C formats is "whatever".
18:05:22 <pcarrier> oh, so now I need to install cabal-install by hand. he he he.
18:05:27 <applicative> get the tarball for cabal install http://hackage.haskell.org/package/cabal-install and use bootstrap.sh
18:06:59 <pcarrier> so what happened to the archlinux haskell stuff anyway? in my memories there were dozens and dozens of binary packages available in a 3rd party repo.
18:07:01 <applicative> monochrom's page has you installing the whole haskell platform, but this will be partly out of date
18:07:01 <applicative> pcarrier: the main point in this exercise is to see how simple it is; it may be that in the end ghc-7.6 is too new for some things you want.
18:07:09 <applicative> the haskell platform doesn't have the new version of bytestring for example -- unless I'm misremembering
18:07:38 <pcarrier> applicative, and everybody is just building on haskell platform?
18:07:43 <applicative> pcarrier: yeah, they changed the way they did it.
18:07:48 <pcarrier> applicative, why you break APIs? :(
18:08:36 <pcarrier> is it hard not to keep backwards-compatible APIs around in haskell?
18:08:43 <mnc> geekosaur: so what I should be doing is data Basic = Basic Error | Basic Result | Basic Int ...?
18:08:43 <pcarrier> s/not to/to/
18:08:56 <monochrom> you are looking at forward compatible
18:09:01 <geekosaur> pcarrier, if that's referring to compatibility with ghc 7.6, it's because ghc serves two purposes.  it's a production compiler *and* a testbed for new ideas in type theory
18:09:34 <monochrom> you are looking at a program written at 7.0 time, and you try to compile it with 7.6
18:09:36 <applicative> in haskell land, nothing has happened unless all APIs have been broken
18:09:52 <pcarrier> monochrom, no, backwards compatible. if everybody is, nobody needs to be forward-compatible.
18:09:56 <geekosaur> mnc, also see the comment afterward.  I have no idea what you plan to do with it, so I couldn't say which approach is better  but for error vs. value at least, you want the kind of Response type I sketched out
18:10:06 <pcarrier> monochrom, stay compatible with your own previous releases, all good.
18:10:08 <applicative> pcarrier: monochrom also has some amusing reflections on cabal-install http://www.vex.net/~trebla/haskell/sicp.xhtml
18:10:27 <geekosaur> pcarrier, sometimes backward compatibility means giving up on forward development
18:10:51 <applicative> pcarrier: we cannot make ourselves subservient to the dead of the past
18:10:54 <monochrom> ok, I see your point. then it is true that we don't put backward compatibility at top priority
18:11:16 <monochrom> we deliberately define Haskell 2010 so that some programs written for Haskell 98 become compiler errors, yes
18:11:17 <geekosaur> see my earlier comment; one of the big recent breakages was Show and Eq prerequisites for Num, because it made type-level numbers more difficult to define
18:11:40 <applicative> the tradition of all the dead generations weighs like a nightmare on the minds of the living
18:11:40 <applicative> avoid backward compatibility at all costs!
18:12:03 <pcarrier> oh so that's why nobody uses that language. now I get it. :D
18:12:05 <geekosaur> (but it helps that for theoretical reasons those prerequisites never really made a lot of sense as being mandatory for all instances of Num)
18:12:26 <geekosaur> well, I should not say theoretical there
18:12:39 <mnc> I'm obviously missing something. I'll just re-read the lyah about typesclasses I guess
18:12:43 <mnc> thanks anyway
18:13:02 <elliott> geekosaur: it wasn't type-level-related, was it?
18:13:02 <geekosaur> went away too fast
18:13:12 <elliott> it's just that you can define a bunch of useful Num instances that aren't Eq or Show
18:13:15 <geekosaur> elliott, I thought the type level nats were a largeish part of it
18:13:24 <geekosaur> what is type level Show?
18:13:27 <elliott> well, I don't think those are actually instances of Num or anything, are they? doesn't seem to make much sense
18:14:12 <geekosaur> I thought it was involved at some level, maybe I'm confused.  not difficult to confuse me when you start doing type level trickery...
18:14:40 <applicative> pcarrier: I am using haskell 2525
18:14:40 <applicative> type level numbers are so 21st century
18:14:40 <applicative> I take it that we have type level Strings now, but not type level Chars
18:15:18 <monochrom> haskell 2525 probably has kind-level naturals
18:15:38 <ems_> > let square x = x * x in map square [1, 2, 3, 4]
18:15:39 <lambdabot>   [1,4,9,16]
18:16:14 <chesscon> hi
18:16:31 <chesscon> :load, :reload??
18:16:37 <parcs> > iterate (succ . join (+)) 1
18:16:39 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,26...
18:16:39 <monochrom> syntax error
18:16:42 <chesscon> help for :load, :reload?
18:16:46 <geekosaur> mnc, typeclasses let you talk about multiple types.  they do not let you return something and make the caller deal; instead the caller tells *your function* which instance it wants.  presumably callers to your function do not want to request an error return... although they may want to request a Bool for a successful result, in which case a typeclass *might* be appropriate
18:17:33 <geekosaur> what kind of help?
18:17:50 <chesscon> :load?
18:17:58 <chesscon> or :reload?
18:18:07 <chesscon> :load file.hs??
18:18:23 <geekosaur> I don't think anyone understands what you're asking...
18:18:26 <monochrom> I don't understand your question
18:18:49 <shachaf> Perhaps add a few some more question marks.
18:18:51 <geekosaur> :reload reloads the last file :load-ed, or the file specified on the command line if you loaded a file that way
18:19:07 <pcarrier> ok, who wants to play "rewrite some horribly, horribly wrong oneliners"?
18:19:20 <shachaf> pcarrier: That's not how you do it.
18:19:29 <chesscon> ok
18:19:30 <shachaf> Just paste/@paste whatever code you have.
18:19:47 <pcarrier> shachaf, that's not very playful.
18:20:02 <parcs> i do!
18:20:06 <mnc> geekosaur: the error actually doesn't quite fit, that's true. I guess the function I want is something like (Basic a) => Path -> Either Error a
18:20:08 <monochrom> yeah, you should say, "I love oneliners", etc
18:20:15 <parcs> they are so easy?
18:20:19 <shachaf> pcarrier: People will play if they want to (they usually do).
18:20:25 <pcarrier> shachaf, it's meant to be horrible. (though I don't know how to fix it yet, but will after more reading tomorrow)
18:20:27 <pcarrier> ghci> mapM (\a->Data.UUID.V1.nextUUID) [1..1000]
18:20:44 <shachaf> @ty replicateM 1000
18:20:45 <lambdabot> Monad m => m a -> m [a]
18:20:51 <geekosaur> mnc, probably.  the question is what you intend with (a) there.
18:21:15 <shachaf> monochrom: Do you love new lenses?
18:21:29 <geekosaur> does the caller of your function know what type (a) it should be getting back?  or is it supposed to find some way to deal with whatever (a) your function decides to produce?
18:21:30 <monochrom> neutral
18:21:45 <mnc> geekosaur: well, to be precise I want to talk to an API. all responses share the Basic part and the a is whatever their requested from the API
18:21:46 <shachaf> In one function we're paying a 1000x constant factor for the right asymptotic behavior.
18:22:01 <monochrom> yikes
18:22:03 <feliperosa> why are lenses so great? (I think the question sounds mean, but I really don't know why hehe)
18:22:05 <shachaf> That's how principled we are.
18:22:27 <Ralith> shachaf: explain http://stackoverflow.com/questions/395981/representing-continuous-probability-distributions/5555071#5555071 to me
18:22:39 <applicat1ve> pcarrier: all one liners must now be rewritten to take advantage of Control.Lens
18:22:40 <mnc> geekosaur: the caller knows what a is supposed to be
18:23:16 * applicat1ve thinks, yeah shachaf explain *that*
18:23:29 <pcarrier> applicat1ve, I can't begin to start. "functor" sounds like a dirty word.
18:23:31 <edwardk> feliperosa: the lens library is neat because it showcases a new way to think about haskell code when it comes to subtyping that makes it possible to make a large highly-compositional API that just 'does what you mean' when you mix and match parts of it together.
18:23:34 <shachaf> Ralith: That looks like statistics.
18:23:35 <geekosaur> ok, so the caller gets to specify (a) and one possible error return is "couldn't convert to that type".  that's the kind of thing you might use a typeclass for, although there might also be other alternatives (if you're talking to a JSON API you probably want to look at Aeson, for example, which has its own "type system" for this kind of thing)
18:23:41 <Ralith> shachaf: a little!
18:23:50 <pcarrier> applicat1ve, barely exaggerating
18:23:58 <shachaf> Ralith: Statistics, if I remember correctly, is the devil.
18:24:05 <Ralith> well, of course
18:24:07 <shachaf> But what's the question?
18:24:13 <geekosaur> "lies, damned lies, and statistics"
18:24:19 <edwardk> feliperosa: the 'lens' part of lens is kinda boring, its the lens-like constructions, folds, getters, traversals, isos, prisms, equalities, and indexed variations of these things that make lens novel compared to 'all the other lens libraries' out there
18:24:22 <shachaf> Ralith: I have a link to a web page that explains the subject matter, if you like.
18:24:28 <monochrom> truth, damn truth, and Kripke structures
18:24:49 <shachaf> Ralith: http://stackoverflow.com/a/5555071
18:24:53 <monochrom> (Kripke structures are about multiple-world semantics, so, multiple truths)
18:24:57 <feliperosa> edwardk: Oh thanks, could you name one library that uses them so I can see an example?
18:25:24 <Ralith> shachaf: in order of importance: first, I want to work out how exactly to write a monad instance for this; second, I want to know if there's a way to hook an analytic PDF or CDF in without using quadrature; finally, I want to understand it well enough that I could have worked the first two out on my own.
18:25:24 <shachaf> feliperosa: http://lens.github.com/ has some information.
18:25:49 <applicat1ve> there is a new lensified time library we just noticed
18:25:50 <shachaf> Ralith: It looks a bit like it might be Cont?
18:25:51 <edwardk> feliperosa: there are a bunch of examples in the examples folder, like a pong game that uses them a brainfuck interpreter, the snap webframework uses them in a limited way, my tables library builds an in-memory data store on top of them..
18:26:02 <monochrom> Kripke multiple-world semantics is a semantics for intuitionistic logic, for you intuitionistic truth lovers!
18:26:04 <mnc> geekosaur: I'm working with aeson. i have have (from|to)JSON instances for my Basic a, and all the possible types of a. now I just want the thing to retrieve the json to be general so that the caller just needs to specify the path and the expected type
18:26:36 <edwardk> feliperosa: https://www.youtube.com/watch?v=cefnmjtAolY&hd=1 is a video where i go through explaining them
18:26:43 <Ralith> shachaf: that looks possibly related
18:26:53 <edwardk> feliperosa: that is enough to get you up and running them lenses and understanding their laws, etc.
18:27:16 <edwardk> http://lens.github.com/tutorial.html has more of a tutorial feel to it
18:27:20 <feliperosa> edwardk: nice!
18:27:33 <feliperosa> shachaf: Thanks for that link :)
18:27:41 <edwardk> lambdabot also has lens installed so you can play around
18:27:49 <edwardk> > ("hello","world")^._2
18:27:50 <lambdabot>   "world"
18:28:01 <edwardk> > ("hello","world") & _2 .~ 42
18:28:02 <lambdabot>   ("hello",42)
18:28:30 <edwardk> > "jello" & upon last .~ 'y'
18:28:32 <lambdabot>   "jelly"
18:28:43 <shachaf> Oh, come on. upon?
18:28:46 <edwardk> =)
18:29:01 <monochrom> @quote alpha
18:29:01 <lambdabot> monochrom says: recursive directory search is an alpha-beta with boring values of alpha and beta.
18:29:02 <edwardk> i wanted to showcase that there are some powerful if odd tools in the box
18:29:10 <Ralith> shachaf: so what kind of things can I do with such a monad
18:29:16 <Ralith> in statistical terms
18:29:27 <geekosaur> mnc, so I think what you want there is to use decode to get a Maybe a and then one of your error returns if is the result is Nothing.  you need to declare that a must be an instance of FromJSON
18:29:27 <shachaf> i don't love statistics
18:29:36 <shachaf> they are so lazy
18:29:42 <mnc> geekosaur: the other solution would be to have one function for every possible type of a but that struck me as somewhat clumsy
18:29:45 <geekosaur> http://hackage.haskell.org/packages/archive/aeson/0.6.1.0/doc/html/Data-Aeson.html#g:7
18:29:49 <Ralith> oh well Cont gives me somewhere to start at least
18:29:55 <shachaf> Ralith: I like Cont!
18:30:00 <Ralith> ^^
18:30:09 <shachaf> Didn't we talk about Cont once?
18:30:12 <geekosaur> that's more or less what you will end up with at some point with typeclasses.  luckily for you, Aeson already has the functions you need :)
18:30:15 <shachaf> And intuitionism and all that?
18:30:20 <geekosaur> which is the FromJSON typeclass
18:30:30 <Ralith> shachaf: I don't think so.
18:30:39 <mm_freak_> does anyone actualy use the "detailed" type for cabal test suites?  are there any packages that make this actually useful?
18:30:56 <feliperosa> lenses sound powerful, as most things I hear coming from haskell
18:31:11 <mnc> I'll try thay, geekosaur. thank you for the patience
18:33:05 <edwardk> lens is interesting because it is a fairly schizophrenic library. on one hand it tries to be as painfully efficient as possible and on the other it tries to be as general as possible and we're willing to basically rewrite whole swathes of it in search of more generality. the main goal is that if you grab something you think should work with something else it should work if there is a principled way that the two can be combined
18:33:05 <geekosaur> so you use FromJSON a => Path -> Either String a, and you can then use decode to get something which is a FromJSON a => Maybe a, and if it's Nothing then you return Left "wrong type" instead of Right a
18:36:04 <fizzbang> i'm having a lot of trouble getting gpipe and it's dependencies set up
18:36:08 <mm_freak_> test-framework-smallcheck doesn't seem maintained anymore =(
18:36:09 <fizzbang> cabal install seems to fetch all sorts of outdated versions of packages that i already have...
18:36:35 <edwardk> mm_freak_: afaik it was never implemented
18:36:52 <mm_freak_> edwardk: well, there is a package on hackage
18:36:58 <edwardk> mm_freak_: the doc that was written to the contrary
18:37:00 <mm_freak_> but it doesn't build and is from 2011
18:37:29 <cmccann> documentation without code? now there's a switch.
18:37:30 <mnc> geekosaur: works, thank you again. it was easier expected afterall
18:37:37 <mnc> +than
18:37:57 <mm_freak_> what do you guys use?  is quickcheck really the answer?
18:38:08 <edwardk> mm_freak_: i would love to be proven wrong, but last i heard that never went in
18:38:21 <applicat1ve> fizzbang, what version of containers do you have, according to ghc-pkg list containers
18:38:22 <mm_freak_> edwardk: i didn't look at the source code, so i don't know
18:38:45 <donri> what? it's from 2012 http://hackage.haskell.org/package/test-framework-smallcheck
18:39:10 <mm_freak_> oh, bad memory, but it's still very old
18:39:24 <mm_freak_> in any case it doesn't build
18:39:32 <fizzbang> applicat1ve: system has 0.5.0.0 but .cabal has 0.4.2.1
18:39:40 <donri> mm_freak_: what ghc?
18:39:50 <donri> i think it built fine for me on 7.4 before
18:39:53 <mm_freak_> The Glorious Glasgow Haskell Compilation System, version 7.6.1
18:40:37 <donri> yea that's not even in the latest platform
18:40:49 <applicat1ve> fizzbang: yes this is part of the trouble. how much breaks if you do ghc-pkg unregister containers-0.4.2.1
18:40:49 <mm_freak_> is test-framework really that great?  so far i'm fine with using smallcheck directly
18:40:58 <applicat1ve> fizzbang: it will tell you before doing anything
18:41:00 <edwardk> mm_freak_: which package?
18:41:11 <mm_freak_> edwardk: ?
18:41:20 <edwardk> had the detailed-test results
18:41:48 <mm_freak_> edwardk: what do you mean?  i haven't ever seen a package that uses detailed testing
18:41:59 <edwardk> oh i must have misparsed your statements
18:42:08 <Saizan> shachaf: is that approach to dealing with distributions viable? the cdf code seems pretty wasteful
18:42:16 <edwardk> [21:36] edwardk:	 mm_freak_: afaik it was never implemented
18:42:16 <edwardk> [21:36] mm_freak_:	 edwardk: well, there is a package on hackage
18:42:16 <donri> mm_freak_: i think it's nice, you can run tests in parallel, you can select tests to run and use a single executable for different types of tests with unified options. not sure you need that if all your tests are smallchechs though
18:42:21 <mm_freak_> hmm, maybe it's a good idea to drop test-framework and go with detailed+smallcheck
18:42:28 <shachaf> Saizan: I don't know anything about that code.
18:42:28 <fizzbang> applicative:  GPipe-TextureLoad-1.0.4 GPipe-1.4 list-tries-0.4.3 binary-0.6.4.0 GLUT-2.3.1.0
18:42:30 <shachaf> Saizan: Ask Ralith.
18:42:44 <donri> mm_freak_: don't use detailed yet, it was released only by accident
18:42:48 <fizzbang> applicative: lots, it seems
18:42:50 <mm_freak_> oh, ok
18:43:03 <Ralith> Saizan: wasteful how?
18:43:11 <mm_freak_> then i'll just use exitcode-stdin with smallcheck, until test-framework-smallcheck is updated =)
18:43:11 * monochrom suggests nuke them all
18:43:13 <applicative> fizzbang: hm. I take it you have ghc-7.6?
18:43:23 * hackagebot lens 3.8 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8 (EdwardKmett)
18:43:31 <ion> woot
18:43:33 <donri> omg lens 3.8
18:43:47 <ion> Why doesn’t lambdabot have lens 3.8 yet‽
18:43:49 <edwardk> as for testing, i tend to use doctests, quickcheck via test-framework, and hunit
18:43:50 <fizzbang> applicative: 7.6.1, yes
18:43:50 * applicative is with monochrom. cut and paste the breakages, make a script ghc-pkg unregister NNNN --force for each of them
18:43:52 <edwardk> hahah
18:44:02 <shachaf> help
18:44:03 <donri> ion: inoriet, ancient 3.7
18:44:06 <edwardk> @tell cale lens 3.8 is out. lambdabot is ancient again ;)
18:44:06 <lambdabot> Consider it noted.
18:44:06 <shachaf> lens 3.8 is out?
18:44:18 <donri> 3.8 has been around for several seconds already
18:44:19 <monochrom> no. rm -r ~/.ghc/*-7.6.1
18:44:19 <shachaf> Cale: We need lens 3.8!
18:44:21 <mm_freak_> still no Data.Char lenses =/
18:44:28 <sclv> its obselete already in lens-years
18:44:36 <ion> @tell cale Please add the new imports for things like Numeric.Lens, too. Thanks.
18:44:36 <lambdabot> Consider it noted.
18:45:04 <ijp> the problem with lens is that people like me, who haven't used it yet, are likely to never catch up :)
18:45:23 * monochrom should write up about "constraint: bytestring installed \n constraint: containter installed \n etc etc" real soon
18:45:23 <edwardk> ijp: he nice thing is that as we go large parts of it get simpler
18:45:31 <applicative> ijp, you don't have to catch up ^. is stable, as are a few others
18:46:00 <fizzbang> monochrom: applicative: why does cabal install bring in outdated versions of packages i already have?
18:46:19 <fizzbang> monochrom: applicative: should i just come on irc every time i want a package? :)
18:46:22 <monochrom> in this case because you have even more versions you already have
18:46:44 <monochrom> read my http://www.vex.net/~trebla/haskell/sicp.xhtml for why
18:46:49 <fizzbang> monochrom: is there anything i can do to not have more versions i already have? haha..
18:47:03 <Saizan> Ralith: well, mu has to use its argument as a black box, so i imagine it has to do more work than if it knew everything after z won't contribute to the integral
18:47:03 <fizzbang> monochrom: thanks.. i'll read that
18:47:18 <applicative> fizzbang: they are required by old cabal files. gpipe for example, needs a new cabal file. I refuse to install opengl and glut so i can't test it though
18:48:19 <applicative> fizzbang: if you do cabal unpack gpipe, see what happens if you do cabal configure and cabal build after striking the upper bounds in gpipe.cabal
18:48:22 <fizzbang> applicative: so i got multiple versions because ghc or the h-p installed version x of some packages, but gpipe needs version x+blah of some packages?
18:49:07 <Ralith> Saizan: eh, constant factor
18:49:14 <monochrom> I tested it. somewhat. at GHC 7.4.2 Haskell Platform 2012.4.0.0, "cabal install --dry-run gpipe" does not bring in older versions of anything. also, adding --constraint='containers == 0.5.0.0' does not make a difference. therefore, I say, it's the asker's database being confusing
18:49:24 <hpaste> applicative pasted “gpipe.cabal speculation” at http://hpaste.org/81101
18:49:52 <applicative> fizzbang: you don't have the haskell platform I don't think, since it uses ghc-7.4
18:50:05 <applicative> fizzbang: you have a very new ghc, so things are a bit of a mess.
18:50:28 <applicative> monochrom: oh, i'm trying to figure out what you said
18:50:45 <fizzbang> applicative: if i'm going to be installing gpipe and it's dependencies, is it less messy to use the haskell platform or just my distro's ghc?
18:51:07 <Saizan> Greendale Community
18:51:18 <applicative> right, Greendale Community
18:51:26 <Saizan> sorry, mispaste
18:51:27 <fizzbang> applicative: you're right; currently i'm using just a ghc from my distro, but not the whole hp..
18:51:45 <applicative> monochrom: gpipe requires containers <5
18:52:07 <Eduard_Munteanu> fizzbang: some distros provide a Haskell Platform package (or a metapackage that depends on particular HP libs)
18:52:49 <applicative> Eduard_Munteanu: but he is using ghc-7.6 This would be easier with ghc-7.4 which is the going Platform ghc
18:53:14 <fizzbang> Eduard_Munteanu: applicative: i'd be fine nuking all of my haskell installation to get gpipe working
18:53:30 <monochrom> then I can't explain why --constraint='containers == 0.5.0.0' does not cause an error
18:54:35 <applicative> fizzbang: also for gpipe you need glut and opengl.  I certainly would prefer a package manager figuring the c libraries + haskell libraries nonsense
18:56:17 <monochrom> haha, but it also wants an old version of QuickCheck. that can be confusing
18:56:42 <fizzbang> applicative: ok.. so i'll try removing everything again and starting from my distro's repositories..
18:56:43 <monochrom> put it in a sandbox
18:56:48 <fizzbang> eh?
18:56:48 <applicative> fizzbang: does your distro have a ghc-7.4+haskellplatform? this has opengl + glut
18:57:00 <mm_freak_> edwardk: any particular reason why you keep properties and hunit tests separate?
18:57:47 <edwardk> the hunit suite was contributed by obk, he wanted a simpler test suite he could use to explain to people.
18:58:01 <mm_freak_> ah, ok
18:58:08 <edwardk> i was just happy to have more tests
18:58:25 <edwardk> this was before we had ~600 doctests added
18:58:46 <fizzbang> applicative: yeah, i'm on archlinux so the distro has most of hackage... but i'm not sure i understand the version issues well..
19:01:48 <applicative> fizzbang: I see. Note the advice of monochrom that after installing with pacman & co. you should use cabal install not returning
19:02:15 <monochrom> or not use cabal install ever
19:02:40 <monochrom> then again, if you cleanse ~/.ghc weekly, it may be ok
19:03:30 * applicative cleans ~/.ghc every couple of weeks since he cant decide between the diverse sandboxing technologies abroad
19:04:27 <monochrom> I have gone hand-typed sandboxing. that is, entering --package-conf=blahblah by hand
19:05:00 <monochrom> fun fact: it's --package-db for cabal, -package-conf for ghc, and --package-conf for ghc-pkg
19:05:18 <monochrom> I love inconsistencies. they are so lazy
19:05:32 <fizzbang> monochrom: that's super not fun sounding..
19:06:01 <shachaf> monochrom: It used to be -package-db for GHC, I think.
19:06:05 * applicative was interested he's waiting for manual-sandboxing.xhtml
19:06:07 <edwardk> monochrom: better one of them changed in cabal 1.16 and gives a warning on the other, breaking any test suite that uses -Werror
19:06:25 <edwardk> er with cabal 1.16 and ghc 7.6.1
19:06:36 <efiish_> Hi, How to use the lambdabot?
19:06:38 <monochrom> oh, I do sandboxing very sparingly, so hand-typing things doesn't hurt yet
19:06:41 <applicative> > 1 + 1
19:06:43 <lambdabot>   2
19:06:52 <applicative> > sort "efiish"
19:06:53 <lambdabot>   "efhiis"
19:06:58 <efiish_> > 1+1
19:06:59 <lambdabot>   2
19:07:08 <applicative> you can message lambdabot separately
19:07:13 <monochrom> also, I actually set "DB=blahblah" and then I just type "-package-conf=$DB"
19:07:28 <applicative> I haven't figured out to do this in irssi yet, but even here it is possible, I'm sure....
19:07:37 <efiish_> > help
19:07:38 <lambdabot>   Not in scope: `help'
19:07:54 <applicative> > let help = 3 in help ^ help
19:07:55 <lambdabot>   27
19:08:39 <applicative> how do I talk to lambdabot in irssi, not /msg lambdabot hmmm.
19:09:02 <efiish_> How can I get help of it?
19:09:09 <efiish_> >?
19:09:11 <fizzbang> according to this: https://bbs.archlinux.org/viewtopic.php?id=147638 .. archlinux users should "Install ghc and cabal using pacman, install everything else using cabal."
19:09:17 <fizzbang> i gues i'll check out the mailing list..
19:09:20 <parcs> applicative: /query lambdabot perhaps
19:10:03 <applicative> thats it's thanks parcs
19:10:37 <applicative> efiish_: there's not much help to be given, you just write complete evaluable haskell expressions that return something in a showable type
19:11:13 <applicative> > let op = (+) in foldr op 1 $ map ord "let op = (+) in foldr op 1 $ map ord"
19:11:14 <lambdabot>   2755
19:11:34 <efiish_> applicative: thx!
19:11:42 <applicative> efiish_: there are other commands like @type
19:11:45 <applicative> @type 'a'
19:11:47 <lambdabot> Char
19:13:24 * hackagebot direct-sqlite 2.3.3.1 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.3.1 (IreneKnapp)
19:13:57 <efiish_> It is a haskell interpreter?
19:14:06 <applicative> efiish_: yes
19:14:21 <efiish_> @type "applicative"
19:14:22 <lambdabot> [Char]
19:14:26 <applicative> it's the same as is used in tryhaskell.org  that may have some advice
19:14:57 <efiish_> :t 'a'
19:14:59 <lambdabot> Char
19:15:22 <efiish_> Thx applicative!
19:18:24 * hackagebot lens 3.8.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.0.1 (EdwardKmett)
19:18:59 * applicative figures he can give up on his new-lens-version resolutions now. 
19:19:27 <monochrom> what? 3.8.0.1 already?!
19:20:01 <shachaf> monochrom: 3.8 is old!
19:20:05 <edwardk> there was a minor issue with building the test suite if you had an older version of semigroups installed
19:20:08 <applicative> now with fun-house mirrors
19:20:21 <monochrom> whee!
19:20:53 <edwardk> applicative: what was the resolution?
19:21:07 <monochrom> but when will it have snowwhite's-stepmon's mirror?
19:21:19 <applicative> one lens makes you larger, and the other makes you small, and the ones your mother gives you don't do anything at all
19:21:35 <shachaf> preflex: seen Cale
19:21:35 <preflex>  Cale was last seen on #haskell 2 hours, 26 minutes and 7 seconds ago, saying: Yeah
19:21:51 <edwardk> wow preflex lives
19:21:54 * edwardk hugs preflex
19:22:02 <monochrom> "mirror mirror, who writes the most abstract lib of all!" "edwardk if you just count #haskell, but oleg if you also count the forest"
19:22:23 <edwardk> the difference is oleg doesn't bother to maintain them
19:22:41 <edwardk> i'm at least hit or miss ;)
19:22:58 <levi> He just collects piles of them on his website.
19:23:10 <applicative> he mostly sticks to haskell 98 or -- Haskell 98 ! as he write it ....
19:23:21 <monochrom> haha
19:23:24 * hackagebot tables 0.1 - In-memory storage with multiple keys using lenses and traversals  http://hackage.haskell.org/package/tables-0.1 (EdwardKmett)
19:23:37 <monochrom> > product [2..98]
19:23:38 <lambdabot>   942689044888324774562618574305724247380969376407895166349423877729470707002...
19:23:38 <applicative> oleg doesn't need your extensions
19:23:56 <monochrom> "this code is Haskell 9426890448883..."
19:24:37 <monochrom> yeah, Haskell 2525 is so yester-eon
19:36:59 <m3ga> Control.Parallel.Strategies anyone? when should I use the different strategies like rseq vs rpar vs rdeepseq?
19:38:05 <mm_freak_> m3ga: highly depends on what you're doing
19:38:24 * hackagebot lens 3.8.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.8.0.2 (EdwardKmett)
19:38:37 <mm_freak_> you usually combine a sequential evaluator with a parallel evaluator, example:  parMap rdeepseq (^1000000) [2..10]
19:39:19 <mm_freak_> i haz tables!
19:40:04 <cmccann> hooray! another lens release!
19:40:31 <edwardk> the last one was so celebrated i figured i'd just keep pushing out intermediate releases ;)
19:41:03 <edwardk> mm_freak_: if someone wants to work on the template-haskell code generator for tables, it'd probably get done a lot faster
19:42:04 <ion> Lens 3.8.0.3 will be so awesome.
19:43:51 <mm_freak_> edwardk: i have no experience with TH, sorry
19:44:10 <edwardk> http://ekmett.github.com/lens/ has the haddocks for lens 3.8 for the impatient
19:47:37 <m3ga> mm_freak_: are the tradeoffs of rseq vs rpar vs rdeepseq documented somewhere?
19:48:23 <mrout> Best and worst parts of Haskell?
19:48:39 <mikeplus64> i'd just like to advertise my own itch scratching in lens: you can now have lenses with the same names from records
19:49:05 <ion> The same names as what?
19:49:26 <schellsan> mrout, type system and type system =P
19:49:37 <schellsan> jk;)
19:49:39 <mrout> schellsan: that's not very specific
19:49:46 <mikeplus64> ion: e.g. data P = P{_pX,_pY :: Int}; data Q = Q {_qX, _qY :: Double}; makeFields ''P; makeFields ''Q will make lenses 'x' and 'y' that work with both through a typeclass
19:49:54 <mrout> :P
19:50:01 <bacon1989> i've discovered the oddest thing when studying haskel
19:50:02 <ion> mikeplus64: alright
19:50:22 <bacon1989> how does one grab individual values within a tuple which is greater than a triple?
19:50:27 <schellsan> no - it's not, just a silly joke :)
19:50:33 <ion> bergmark: Pattern matching (or lens)
19:50:39 <edwardk> > (1,2,3,"hello")^._4
19:50:41 <lambdabot>   "hello"
19:50:52 <ion> > case (1,2,3,"hello") of (_,_,_,a) in a
19:50:54 <lambdabot>   <hint>:1:35: parse error on input `in'
19:50:55 <edwardk> (that uses lens)
19:51:01 <ion> > case (1,2,3,"hello") of (_,_,_,a) -> a
19:51:02 <lambdabot>   "hello"
19:51:22 <ion> > let (_,_,_,a) = (1,2,3,"hello") in a
19:51:24 <lambdabot>   "hello"
19:51:29 <bacon1989> edwardk: why is it so convoluted?
19:51:40 <mikeplus64> edwardk: can we generate lenses for things other than records? (i mean, things withot labels)
19:51:49 <ion> Define convoluted.
19:51:58 <bacon1989> > let x = [1,2,3,4] !! 0
19:51:59 <lambdabot>   not an expression: `let x = [1,2,3,4] !! 0'
19:52:13 <mikeplus64> because we could do what makeFields does for _1, _2 etc. for data constructors that aren't records
19:52:27 <monochrom> convoluted: when you have to sum or integrate f(x)*g(u-x) :)
19:52:29 <shachaf> bacon1989: Because what would the type of that thing be?
19:52:29 <edwardk> bacon1989: how do you index by number into a tuple that has different types?
19:52:35 <ion> monochrom: :-)
19:52:40 <schellsan> what version of ghc ships with the llvm backend?
19:52:49 <edwardk> bacon1989: ("hello",(),43,Left Jello) !! 3 ?
19:53:06 <edwardk> what is the type of (!!)
19:53:20 <shachaf> (!!) :: Dynamic
19:53:48 <ion> (!!) :: a -> b
19:53:52 <ion> -> c
19:53:54 <monochrom> oh! we miss that opportunity when someone asked about duck typing!
19:54:07 <monochrom> we have lens typing instead :)
19:54:08 <mrout> what does !! do again?
19:54:20 <monochrom> also, s/miss/missed/
19:54:21 <shachaf> mrout: It opens a Hoogle window.
19:54:28 <edwardk> :t (!!)
19:54:29 <lambdabot> [a] -> Int -> a
19:54:32 <ion> mrout: It’s an evil operator that returns the nth element from a list.
19:54:40 <mrout> evil? Why?
19:54:44 <schellsan> ion, what makes it evil?
19:54:44 <edwardk> its a poor man's 'ix'
19:54:53 <mrout> can't be as evil as some of the $}#@{#}@{#@ things in perl
19:54:54 <edwardk> shachaf: it can fall off the end
19:54:55 <shachaf> schellsan: It crashes your program if the list is too short.
19:54:58 <edwardk> > [] !! 3
19:54:59 <lambdabot>   *Exception: Prelude.(!!): index too large
19:55:05 <shachaf> edwardk: Oh. Now I see.
19:55:11 <edwardk> > []^?element 3
19:55:12 <ion> If you’re indexing lists by nth element, you’re somewhat likely misusing lists.
19:55:13 <lambdabot>   Nothing
19:55:13 <schellsan> ahhh
19:55:20 <edwardk> > [1,2,3,4,45]^?element 3
19:55:21 <lambdabot>   Just 4
19:55:36 <schellsan> just as head does on an empty list?
19:55:40 <edwardk> and in general yeah, if you need to look up in a list by position you're using the wrong structure
19:59:39 <schellsan> what's the best way to sandbox different versions of ghc?
19:59:49 <shachaf> "sandbox"?
20:00:10 <monochrom> I put them in /usr/local/ghc-7.4.2 and play with PATH
20:00:20 <schellsan> *if i wanted to have 7.8 for a specific project
20:00:30 <schellsan> i see
20:00:31 <shachaf> If you wanted to have 7.8, it would be tricky.
20:00:46 <shachaf> But I still don't know what you mean by "sandbox".
20:00:58 <shachaf> If you just want to have multiple versions of GHC installed, you can just install multiple versions of GHC.
20:01:56 <schellsan> well, i'd like to be able to play with different versions but in a way that doesn't clobber ghc from the haskell platform
20:02:14 <schellsan> maybe like rubyenv for ruby
20:02:34 <schellsan> (which i don't have too much experience with either)
20:02:45 <schellsan> i'm just wondering what the convention is
20:03:14 <schellsan> is 7.8.x just tricky for some reason?
20:03:23 <shachaf> 7.8 is not released.
20:03:33 <schellsan> oh!
20:03:52 <shachaf> Anyway, installing multiple of GHC just works.
20:03:56 <Eduard_Munteanu> schellsan: install it as a user
20:03:59 <bacon1989> so how would I go about summing a tuple? Is their a special function for that?
20:04:00 <monochrom> ruby analogies do not carry over to ghc. there are many reasons, not just compilation
20:04:04 <shachaf> Then you can say ghc-7.6.1, etc.
20:04:20 <shachaf> bacon1989: Yes, but the better answer is "don't sum a tuple".
20:04:30 <shachaf> It doesn't really make much sense to want it, in general.
20:04:36 <bacon1989> i see
20:04:42 <Eduard_Munteanu> :t uncurry (+)
20:04:43 <lambdabot> Num c => (c, c) -> c
20:04:46 <bacon1989> guess i'll do some more studying
20:04:53 <shachaf> @ty sumOf each
20:04:53 <ion> The even better answer is “why do you want to sum a tuple?”
20:04:54 <lambdabot> Not in scope: `each'
20:04:59 <shachaf> Cale: Upgrade lens!
20:05:07 <monochrom> the main point you need to know is that 7.4.2 does not even see libs built for 7.6.1, and vice versa. you read it right, does not even see
20:05:18 <mrout> you should probably sum a list...
20:05:34 <shachaf> whoa, dude
20:05:39 <shachaf> It doesn't even *see* them?
20:05:49 <schellsan> Eduard_Munteanu: do you mean set up a user for a specific ghc?
20:05:52 <ion> oh man!
20:06:24 <Eduard_Munteanu> schellsan: you could do that, but I was saying you should install it in your home dir, not system-wide.
20:06:38 <Philippa> ion: because the tuple came out of some function where it made sense at the time
20:06:40 <monochrom> it is the main reason why possessing multiple ghc versions works fine
20:06:48 <schellsan> Eduard_Munteanu, ah, okay
20:07:04 <Philippa> (maybe you're calculating manhattan distance?)
20:07:45 * applicative is glad that the internets are abuzz with the question, "Haskell vs. C -- which is faster?" as usual. Ugh.
20:08:20 <monochrom> bacon1989 is summing a list of length known at the type level. think about it that way. have fun!
20:08:44 <monochrom> @quote monochrom faster.than
20:08:44 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
20:09:05 <applicative> good point.
20:09:33 <schellsan> monocrom, i'm guessing that's because cabal installs libs in version specific places?
20:09:47 <schellsan> and - good one.
20:10:12 <monochrom> no. it is because different ghc versions produce incompatible assembly code
20:10:30 <monochrom> or has significant potential to
20:11:21 <schellsan> ah - so when cabal builds a package/lib using a specific ghc it essentially seperates it? sorry if i'm totally missing the point!
20:11:37 <monochrom> complete overhaul of the whole computational model has happened one or two times actually
20:11:53 <jmcarthur> :t template
20:11:55 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
20:12:06 <jmcarthur> > sumOf template (1,2,3,4,5) :: Integer
20:12:08 <lambdabot>   15
20:12:18 <monochrom> ghc insists on the separation. ghc implements the separation. cabal is just obeying
20:12:40 <monochrom> the separation has been there before cabal existed
20:13:11 <schellsan> what should i read to learn more about that? (i don't want to waste too much of your time)
20:13:26 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml
20:13:28 <Eduard_Munteanu> :t sumOf
20:13:29 <lambdabot> Getting (Sum a) s t a b -> s -> a
20:14:00 <shachaf> > sumOf _1 (sumOf,sumOf) both (1,2)
20:14:02 <lambdabot>   3
20:14:33 <schellsan> monochrom: awesome, thanks - you're right on point
20:16:38 <edwardk> > sumOf each (1,2,3,4,5)
20:16:39 <lambdabot>   Not in scope: `each'
20:16:44 <edwardk> bah old lens
20:16:52 <shachaf> edwardk: In new lens my trick wouldn't've worked.
20:18:43 <shachaf> preflex: seen preflex
20:18:45 <shachaf> Hm.
20:19:37 <cmccann> shachaf: seen shachaf
20:19:45 <shachaf> hi cmccann
20:20:06 <shachaf> did you solve my type problem
20:20:13 <cmccann> which one
20:20:18 <cmccann> I've lost track
20:20:20 <cmccann> you have too many
20:20:32 <shachaf> any of them
20:20:41 <cmccann> well, no.
20:20:59 <shachaf> Well, then.
20:22:13 <alec__> where can i view these problems, shachaf?
20:22:26 <shachaf> Ask cmccann.
20:22:34 <edwardk> alec__: new lens for you
20:22:40 <alec__> where can i view these problems, cmccann?
20:22:50 <cmccann> alec__: ask shachaf.
20:22:54 <shachaf> I think the most recent one was: given (unsafeCoerce :: f (Id a) -> f a), write (unsafeCoerce :: a -> b)
20:22:58 <shachaf> Without type familis.
20:23:00 <shachaf> e
20:23:08 <cmccann> yeah
20:23:17 <cmccann> the obvious GADT version didn't work :[
20:23:24 <shachaf> Right.
20:23:34 <shachaf> i love obvious versions
20:23:37 <shachaf> they are so easy
20:24:24 <shachaf> I should submit a GHC patch to do that optimization.
20:25:25 <cmccann> you should.
20:26:32 <Mortchek> As an exercise, I'm trying to come up with a point-free expression of flip. But I'm a bit stumped as to where to start. Anyone have any hints?
20:26:48 <shachaf> Mortchek: Given what primitives?
20:26:55 <shachaf> Point-free is about expressing functions in terms of other functions.
20:27:05 <shachaf> lambdabot likes to use flip as a primitive.
20:27:09 <Mortchek> Let's say S K I.
20:27:23 <Mortchek> And compose.
20:27:33 <shachaf> OK, then use the S K I rules as listed on https://en.wikipedia.org/wiki/Combinatory_logic
20:27:39 <shachaf> You can point-free any function.
20:27:52 <Mortchek> Ah, neat! Thanks.
20:28:06 <cmccann> flip is the C combinator, btw.
20:28:21 <cmccann> and (.) is B.
20:28:31 <shachaf> The gist of the rules: (\x -> A B) turns into S (\x -> A) (\x -> B); (\x -> x) turns into I; (\x -> y) turns into K.
20:29:09 <shachaf> Into K y, that is.
20:29:25 <Mortchek> Yeah, already figured out B, I, and some other things based on S and K. Got a bit stumped on C.
20:29:44 <Mortchek> Having some actual rules will definitely help.
20:29:49 <shachaf> These rules let you translate anything into S/K completely mechanically.
20:29:57 <shachaf> It's pretty boring. :-)
20:30:09 <Mortchek> It's a bit tedious, but interesting to figure out anyhow. :P
20:30:44 <shachaf> More interesting: Write a program to do it, along with an optimizer.
20:30:48 <shachaf> That way we can get rid of pointfree.
20:31:28 <cmccann> translating to SKI in a way that typechecks is a bit trickier than the untyped translation, though.
20:32:25 <shachaf> @pl (\x -> x x) (\x -> x x)
20:32:28 <lambdabot> ap id id (ap id id)
20:32:28 <lambdabot> optimization suspended, use @pl-resume to continue.
20:32:32 <shachaf> @pl-resume
20:32:38 <lambdabot> ap id id (ap id id)
20:32:38 <lambdabot> optimization suspended, use @pl-resume to continue.
20:32:45 <shachaf> Maybe just one more would've found it.
20:33:44 <Mortchek> Doesn't (\x -> x x) (\x -> x x) just reduce to itself infinitely?
20:34:18 <Mortchek> Well, lifting the typing restriction.
20:34:19 <ion> @type (<*>) . const . (<*>) <*> const const
20:34:21 <lambdabot> (b1 -> a -> b) -> a -> b1 -> b
20:34:46 <shachaf> (\x -> x x) (\x -> x x) reduces to (\x_ae12 -> x_ae12 x_ae12) (\x_eh1w -> x_eh1w x_eh1w)
20:35:06 <Philippa> Mortchek: yep
20:35:36 <shachaf> @ty (\x -> outR x x) (InR (\x -> outR x x))
20:35:37 <lambdabot> a
20:35:39 <shachaf> > (\x -> outR x x) (InR (\x -> outR x x))
20:35:42 <lambdabot>   mueval-core: Time limit exceeded
20:36:09 <Philippa> shachaf: you weren't offered alpha-equivalence, so that's not a valid beta reduction :p
20:36:39 <shachaf> Philippa: I helped myself to alpha-equivalence.
20:36:58 <Philippa> which still makes it no longer /just/ a reduction
20:37:02 <Mortchek> What's that fuzziness after the x?
20:37:17 <Mortchek> Did a tool generate that?
20:37:27 <shachaf> Mortchek: What are you calling me!
20:37:31 <Mortchek> :)
20:42:53 <synonymous> Hi! Is it possible to specify a package dependency in a pragma or in the cabal file on a per-module basis?
20:43:20 <johnw> you can use -package X in an OPTIONS_GHC pragma, but why would you want to?
20:44:09 <synonymous> i have two packages with the exact same interface so doesn't know which one to use
20:45:02 <monochrom> you can use a cabal file
20:45:29 <synonymous> johnw:
20:45:29 <synonymous> unknown flag in  {-# OPTIONS_GHC #-} pragma: -package
20:45:29 <synonymous> unknown flag in  {-# OPTIONS_GHC #-} pragma: package_name
20:45:30 <monochrom> there are also flags for the ghc command line
20:46:32 <monochrom> the most recommended way, though, is none of the above. use sandboxing instead
20:46:51 <monochrom> although, all sandboxing solutions are currently in a flux state
20:49:38 <synonymous> monochrom: thanks, i'll read up on it. However, I'm not conserned with the cleanness of the approach right now. How could i do it with cabal or ghc command line?
20:52:50 <applicative> synonymous: there is also the {-#LANGUAGE PackageImports #-} extension
20:53:24 <applicative> synonymous: then you write import Control.Monad ; import "my-package" Control.Foolishness
20:57:05 <synonymous> applicative: yes, good idea, but it only half works. It still needs the package dependency to be specified in the cabal file or elsewhere. So other modules will also have to specify the package they want
20:58:56 <applicative> ah I see.
21:00:16 <lesser> do you usually add language thingy per file or you set it globally?
21:00:40 <applicative> I think per file is Preferred Usage, but that's not e.g. what ghc does...
21:00:55 <applicative> It looks a lot better stuffed away in the cabal file ....
21:01:35 <shachaf> I prefer them in files.
21:03:26 * hackagebot kevin 0.2 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.2 (JoelTaylor)
21:04:21 * applicative wonders who this kevin is
21:04:30 <applicative> hm... still importing *Data*.Lens...
21:04:44 <edwardk> applicative: freak
21:04:54 <otters> applicative: are you referring to kevin
21:04:59 <applicative> yes
21:05:02 <otters> yeahhhhh
21:05:05 <otters> I wrote it back in the day
21:05:15 <otters> I'll migrate to lens for 0.3 I guess
21:05:37 <edwardk> wow. data-lens
21:05:59 * edwardk takes a look to see what he uses out of data-lens
21:06:17 <otters> yeah actually maybe I will fix it
21:06:22 <otters> right now
21:08:19 <edwardk> just pulled to check
21:08:37 <edwardk> updated the two dependencies i know of, now waiting for building of dependencies
21:08:45 <cmccann> if you want to be all retro and stuff, use fclabels instead!
21:09:10 <edwardk> regex-pcre-builtin-0.94.4.5.8.31  wow thats a version number
21:09:13 <johnw> what does fclabels stand for?
21:09:18 <edwardk> first class labels
21:09:23 <cmccann> it's got lots of awkward oldschool clumsiness.
21:09:30 <johnw> I wonder how regex-pcre-builtin decides which one to increase
21:10:09 * applicative read 'awkward' as 'edwardk'
21:10:39 <shachaf> What's data-lens?
21:10:44 * shachaf is confused.
21:10:55 <Clint> something from 1927
21:10:59 * applicative can't remember either
21:11:12 <applicative> did it have a Category instance?
21:12:00 <shachaf> roconnor should alpha-rename it to s a.
21:13:33 <Fabrizio> Hello, could anyone tell me what is the best method for catching c-side exceptions through the FFI. I have a c-function which might through an exception.
21:13:45 <shachaf> C functions can't throw exceptions.
21:13:48 <shachaf> C does not have exceptions.
21:13:58 <johnw> do you mean a signal?
21:14:00 <johnw> longjmp?
21:14:19 <Fabrizio> throw "this is a c++ error"
21:14:22 <shachaf> Perhaps better than guessing would be asking.
21:14:27 <shachaf> C is not C++.
21:14:31 <shachaf> Haskell doesn't have an FFI to C++.
21:14:34 <Fabrizio> *sorry
21:14:42 <Fabrizio> -stdc++
21:14:57 <shachaf> You'll have to wrap it into a function that doesn't throw an exception on the C++ side.
21:15:01 <johnw> shachaf: I am asking
21:15:04 <shachaf> And then export it to Haskell with C++'s C FFI.
21:15:20 <edwardk> otters: i just converted it to lens.
21:15:35 <otters> what, kevin?
21:16:04 <otters> yeah I'm about to
21:16:47 <edwardk> otters: check your pull requests ;)
21:17:06 <edwardk> wish some tweaking it could be made much more idiomatic.
21:17:14 <edwardk> is there a reason why KevinIO isn't an instance of MonadState?
21:17:30 <otters> I would imagine because, at the time, I had no idea what I was doing
21:17:32 <edwardk> you use get_ and modify_ etc, all over the place instead
21:17:43 <edwardk> ah. going back for a second pass ;)
21:17:52 <otters> yeah, I'm going to completely rewrite for 0.3
21:18:00 <otters> I tried to figure out a way to make it an instance of MonadState but I couldn't work it out
21:18:27 * hackagebot gitlib-s3 0.2.1 - A repository backend for storing Git objects in Amazon S3  http://hackage.haskell.org/package/gitlib-s3-0.2.1 (JohnWiegley)
21:18:36 <edwardk> well, you can make an actual type rather than use ReaderT of the TVar and get it
21:18:45 <otters> right
21:18:56 <shachaf> ReaderT of a TVar should not be MonadState.
21:19:33 <edwardk> it'd admittedly be pretty dirty
21:20:00 <edwardk> you could also make an embedding from state into KevinIO that runs a state action and atomically modiffies the TVar with the input to the output of the action
21:20:20 <shachaf> Sure.
21:20:26 <edwardk> basically it becomes StateT Kevin STM a -> KevinIO a
21:20:37 <edwardk> then you can do whatever you want in that interim
21:20:51 <otters> ...@_@
21:22:28 <edwardk> fiddling with it real quick
21:36:58 <isomorphic> I have a Maybe (IO Text).   Should I be able to use liftIO applicatively, eg: do liftIO <$>  a :: (Maybe (IO Text)) ?
21:37:22 <shachaf> Look at the types.
21:37:27 <shachaf> @ty (liftIO <$>)
21:37:28 <lambdabot> (Functor f, MonadIO m) => f (IO a) -> f (m a)
21:37:36 <shachaf> Is that what you want?
21:37:59 <isomorphic> Can you state the way that type reads to you ?
21:38:33 <mm_freak_> isomorphic: what do you want to do with the Maybe (IO Text)?
21:38:37 <shachaf> Well, f can be Maybe.
21:38:43 <shachaf> m can be whatever.
21:38:47 <shachaf> I don't know what you're trying to do.
21:39:39 <hpaste> isomorphic pasted “putCell Handler” at http://hpaste.org/81105
21:39:41 <hpaste> isomorphic pasted “putCell Handler” at http://hpaste.org/81106
21:39:43 <mm_freak_> you could run it, you could turn it into an IO (Maybe Text), etc.
21:39:53 <mm_freak_> don't paste code, explain
21:40:16 <mm_freak_> part of solving a problem in haskell is knowing what the problem is =)
21:40:54 <isomorphic> So, evaluateCellFormula inboundCell has :: Maybe (IO Text)
21:41:18 <isomorphic> I'd like to keep the Maybe - to put into the cellDisplay field - but I want to lose the IO
21:41:28 <isomorphic> eg, I really need a Maybe Text
21:41:49 <isomorphic> liftIO is the way I'd handle it being in IO
21:42:08 <isomorphic> so I'm thinking applying that applicatively ought to work
21:42:12 <isomorphic> ghc disagrees.
21:42:27 <statusfailed> Has anyone done an aeson-traversal/prism library?
21:42:31 <mm_freak_> :t maybe (return Nothing) (fmap Just)
21:42:32 <lambdabot> (Monad m, Functor m) => Maybe (m a) -> m (Maybe a)
21:43:36 <isomorphic> mm_freak:  That looks kind of perfect
21:43:40 <shachaf> isomorphic: Aha.
21:43:46 <shachaf> The function you want is Data.Traversable.sequenceA
21:43:46 <sw2wolf> :t (,)
21:43:47 <lambdabot> a -> b -> (a, b)
21:43:53 <johnw> :t sequenceA
21:43:54 <lambdabot>     Not in scope: `sequenceA'
21:43:54 <lambdabot>     Perhaps you meant one of these:
21:43:54 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
21:44:01 <johnw> :t Data.Traversable.sequenceA
21:44:02 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
21:44:02 <shachaf> @ty Data.Traversable.sequenceA :: Maybe (IO a) -> IO (Maybe a)
21:44:03 <lambdabot> Maybe (IO a) -> IO (Maybe a)
21:44:11 <isomorphic> Thanks!  I will have a look!
21:44:12 <johnw> good call
21:44:15 <isomorphic> (then report back!)
21:46:28 <otters> edwardk: any progress
21:46:52 <edwardk> otters: yeah lots. almost builds. made a bunch of changes to settings just now
21:46:58 <otters> awesome
21:47:05 <otters> if you do get it to work, show me before you explain it
21:47:53 <edwardk> sure
21:53:45 <edwardk> otters: ok i pushed a new version to github.com/ekmett/kevin
21:53:54 <edwardk> i'll keep fiddling
21:54:12 <otters> cool
21:55:03 <edwardk> in the Kevin type, is the settings ever modifed?
21:55:33 <edwardk> data Kevin = Kevin { … , … :: Settings, … } those settings
21:55:43 <edwardk> e.g. can anything in there lift out of the TVar?
22:03:03 <sw2wolf> :t isInfixOfI
22:03:04 <lambdabot>     Not in scope: `isInfixOfI'
22:03:04 <lambdabot>     Perhaps you meant one of these:
22:03:05 <lambdabot>       `isInfixOf' (imported from Data.List),
22:03:17 <sw2wolf> :t isInfixOf
22:03:19 <lambdabot> Eq a => [a] -> [a] -> Bool
22:04:06 <otters> edwardk: yeah
22:04:21 <edwardk> yeah its modified or yeah stuff can be lifted out? =)
22:04:32 <shachaf> edwardK; yeah
22:04:36 <edwardk> shachaf: =P
22:04:43 <otters> oh, I thought the first and the second question were equivalent
22:04:48 <otters> lol
22:04:52 <otters> uh, the settings are modified
22:04:55 <ski> @type isInfixROf
22:04:56 <lambdabot> Eq a => [a] -> [a] -> Bool
22:04:56 <otters> and I'm not sure if they can be lifted out or not
22:05:00 <otters> I don't think so
22:05:08 <edwardk> fair enough. kinda figured that out after i asked
22:05:12 <otters> they're modified at startup and then accessed by both threads, iirc
22:05:16 <edwardk> wondering if any of the other parts in there are fully mutable
22:05:19 <edwardk> yeah
22:05:29 <edwardk> er i mean if any other parts are fully immutable
22:06:29 <otters> heh, so I'm just looking through your code
22:06:52 <edwardk> it was kind of a rush job
22:07:06 <otters> it still makes mine look kind of embarrassing
22:07:09 <otters> to be fair, I don't know what it does
22:07:18 <edwardk> ask questions, and i'll answer
22:07:34 <otters> so you like single-letter variable names
22:07:49 <edwardk> some of those were to avoid collisions
22:07:53 <shachaf> otters: Only because GHC doesn't support empty variable names.
22:08:00 <otters> and "kevin" runs an STM action, okay
22:08:04 <edwardk> e.g. i named something kevin and that caused your local kevin variable to collide
22:08:11 <otters> oh, I see
22:08:22 <edwardk> so i renamed it to kill the warning
22:08:37 <otters> so the definition of KevinIO remains the same, but you define KevinS and it's not even necessary to define a MonadState instance because it's already a MonadState instance
22:08:39 <edwardk> and for lack of anything better picked 'k' as its a local variable and nobody can see it ;)
22:09:13 <mm_freak_> KevinIO?  is that accepted convention?  then i'm gonna call my monad transformer ErtugrulT
22:09:17 <edwardk> yeah, i made a little KevinS for those actions you lift. basically when you do something in kevin its making a little transaction and giving you access to the parts
22:09:25 <otters> yeah, I see that
22:09:31 <otters> :t use
22:09:33 <lambdabot> MonadState s m => Getting a s t a b -> m a
22:09:39 <otters> and use works for any MonadState
22:09:43 <edwardk> yeah
22:09:44 <otters> and the action kevin runs is a MonadState instance
22:09:48 <edwardk> yep
22:10:04 <edwardk> arguably i could go to something in the middle
22:10:09 <otters> no, I like how it is now >_>
22:10:13 <edwardk> i could make a version of use that works in your kevinIO
22:10:23 <edwardk> and then we can simplify the kevin $ use  calls to use_
22:10:30 <otters> well it still has the same functionality doesn't it
22:10:35 <edwardk> and that has the benefit that it doesn't spuriously write back
22:10:44 <otters> oh right
22:10:45 <edwardk> reducing unnecessary collisions
22:11:01 <otters> oh because kevin always modifies the tvar
22:11:12 <edwardk> gets_ (view name)      works just as well as kevin $ use name
22:11:18 <bh> Is Hackage broken?
22:11:29 <edwardk> and better because of reduced collisions
22:11:39 <shachaf> bh: Yep.
22:11:46 <shachaf> Someone should put it in the topic.
22:11:54 <otters> edwardk: gets_ is ugly, though
22:11:56 <bh> shachaf: alas!
22:11:57 <shachaf> (Not that it'll change anything. But still.)
22:12:11 <edwardk> true, hence we can make a use_ call ;)
22:12:18 <edwardk> use_ = gets_ . view
22:13:07 <shachaf> Shouldn't that be view_ or something?
22:13:20 <edwardk> er
22:13:21 <shachaf> Well, maybe not.
22:13:26 <edwardk> no because its on gets_
22:13:32 <shachaf> I guess it's Statey.
22:13:36 <SegFaultAX> What is the preferred data validation library?
22:13:45 <SegFaultAX> Or, is there one?
22:13:57 <shachaf> My two favorites are (const False) and (const True)
22:14:02 <SegFaultAX> :)
22:14:06 <shachaf> The former is for the theory, the latter is for when I need to get things done.
22:14:41 <SegFaultAX> shachaf: I'm looking for something quite lightweight. Something that can validate URLs and email addresses, for example.
22:15:02 <bh> shachaf: is there a hackage mirror that I can tell cabal to use?
22:15:04 <edwardk> otters: ok, check now
22:15:22 <johnw> bh: luite has a mirror
22:15:32 <johnw> see http://comonad.com/reader/2012/hackage-mirror/
22:15:43 <shachaf> @where hackage-mirror
22:15:44 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
22:15:45 <otters> edwardk: lovely
22:16:00 <bh> shachaf: <3
22:16:02 <otters> edwardk: I already merged that pull request
22:16:55 <guidj0s> Hackage seems to be offline. Is there any other reliable source of library documentation?
22:17:12 <johnw> guidj0s: did you enable Documentation in your ~/.cabal/config?
22:17:17 <shachaf> Install the library using the Hackage mirror, then look on your hard drive.
22:17:22 <shachaf> @where hackage-mirror
22:17:22 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
22:17:28 <johnw> shachaf: that only helps if he enables documentation
22:17:35 <johnw> and if he did, then he already has the docs
22:17:49 <edwardk> otters: sent another
22:18:05 <guidj0s> johnw: I'll check it out. Thanks.
22:18:07 <shachaf> johnw: I tend to look up documentation for uninstalled packages.
22:18:16 <shachaf> If they're installed, then I just look at the source.
22:18:33 <johnw> ah, i have Haddock include source links
22:18:37 <guidj0s> johnw: False.
22:18:55 <johnw> guidj0s: then set it to true and reinstall via the mirror, as shachaf suggested
22:19:01 <shachaf> False: The best Bool?!
22:19:05 <johnw> after, you can open ~/.cabal/share/doc/index.html
22:24:29 <edwardk> otters: ok, i think thats about as clean as it gets without invasive changes
22:24:47 <otters> okay
22:24:51 <otters> I'm fine with invasive changes
22:24:54 <otters> but maybe we'll shelve that
22:24:58 <edwardk> =)
22:25:06 <blackdog> otters: more arms, maybe. or a second spleen?
22:25:26 <otters> if you have a spare spleen, give it to my mother
22:25:27 <shachaf> hi blackdog
22:26:03 <blackdog> shachaf: heya mate :) /me is killing time on #haskell until hackage recovers from its bout of lightheadedness
22:26:26 <shachaf> blackdog: There's a mirror.
22:26:29 <shachaf> @where hackage-mirror
22:26:29 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
22:26:42 <otters> holy lens dependencies batman
22:26:51 <blackdog> while i'm here: current hotness for option processing for command line apps?
22:26:54 <edwardk> hahahaha
22:26:56 <blackdog> shachaf: ah, that's right. cheers.
22:27:05 <otters> optparse-applicative is nice
22:27:18 <shachaf> otters is not a fan of semigroupoids, eh?
22:27:36 <otters> what practical use can there possibly be for semigroupouds
22:27:39 <otters> oids
22:27:41 <blackdog> otters: ooh, that sounds good. i didn't actually mind cmdargs, but that TH/profiling bug is a pain in the backside.
22:28:28 <beefcube> if I have declared "class (Ord p) => Job p j i c | j -> i, j -> c where ..." shouldn't just two arguments be sufficient to create an instance?
22:28:30 <otters> edwardk: I assume it's because you included lenses for so many external datatypes
22:28:47 <shachaf> beefcube: No.
22:28:48 <johnw> otters: i'm liking optparse-applicative too, and I was a big cmdargs user before
22:28:55 <shachaf> You need to specify the other two. Otherwise what would they be?
22:29:11 <otters> I might use optparse-applicative if I feel like adding another dependency to kevin
22:29:15 <blackdog> johnw: two recommenders is enough for me to embrace the new shiny.
22:29:16 <otters> it's already starting to feel like quasi-yesod
22:29:19 <edwardk> otters: lens comes pre-canned with stuff for much of the haskell platform.
22:29:19 <beefcube> sachaf: derived from the instance :P ?
22:29:24 <beefcube> *shrug*
22:29:35 <otters> it's like batteries included, but the batteries are required and some of them are triangular
22:29:37 <shachaf> beefcube: What does that mean?
22:29:48 <edwardk> otters: https://github.com/ekmett/lens/wiki/FAQ#wiki-scope
22:30:01 <otters> neat
22:30:09 <edwardk> otters: the thing is we use many of those dependencies internally for lens
22:30:19 <otters> I know, I'm not complaining
22:30:21 <edwardk> in essence lens depends on the haskell platform and on what it needs internally
22:30:22 <shachaf> Like bytestring.
22:30:22 <otters> it's a great library
22:30:32 <shachaf> How would we have written that bytestring tree code without bytestring?
22:30:37 <edwardk> it has a _few_ gratiuitous extras
22:30:46 <beefcube> shachaf: it seems like I should be able to declare an instance, that conforms to the class definition, without explicitly mentioning the last two types?
22:30:51 <edwardk> but we use comonads heavily in the library, and comonad-transformers transitively depends on semigroupoids
22:31:06 <shachaf> beefcube: class Foo a b | a -> b means that, given a, you can figure out what b is.
22:31:39 <edwardk> also by depending on semigroupoids we get the Apply instances that would be needed if anyone wanted to define 'relevant traversals'
22:31:43 <shachaf> But you have to say what it is *somewhere*.
22:31:49 <shachaf> MonadCatchIO-transformers sticks out mostly because the name is so long.
22:32:05 <shachaf> i love comonads
22:32:05 <edwardk> shachaf: yeah that one is a little.. interesting
22:32:07 <shachaf> they are so easy
22:32:19 <edwardk> i didn't look to see if his kevin code was dealing with any exceptions
22:32:27 <otters> it is
22:32:38 <otters> and plenty of em
22:32:41 <shachaf> lens makes exceptions so easy
22:32:56 <edwardk> otters: check out Control.Exception.Lens
22:33:15 <edwardk> http://ekmett.github.com/lens/Control-Exception-Lens.html
22:33:50 <otters> ...
22:33:53 <edwardk> it uses the notion of a 'prism', which is like a lens for sums to let you catch and throw exceptions without scoped type variables
22:34:36 <edwardk> catching _AssertionFailed (assert False (return "uncaught")) $ \s -> do something with the string out of the AssertionFailed exception here.
22:34:36 <otters> nice
22:35:15 <gseitz> edwardk: otters: since kevin is an application (vs. library) and users joining a room etc... won't happen all that often, it's no problem to keep addUser pure and move the modification outward
22:35:19 <edwardk> catching _Foo generally replaces catch … $ \(s :: Foo) -> …  but can be filtered, etc.
22:35:22 <gseitz> I'm fiddling a bit with ekg (metrics/stats library) and I ended up with IORefs all over the place, to allow for "direct" modifications of fields (eg. of Histogram) rather than making Histogram pure
22:35:42 <gseitz> do you think that's sensible?
22:36:02 <otters> let me just refresh myself on what addUser does
22:36:05 <edwardk> i'll let you guys figure that out. i mostly just wanted to take a look at a 'real world example' and someone who was already using data-lens was pretty much ideal.
22:36:07 <otters> it's been awhile since I worked on this program
22:36:22 <edwardk> so i took poor otters' code and mangled it for my own selfish ends
22:36:30 <otters> it was poor wasn't it
22:36:37 <edwardk> the code was fine
22:36:42 <edwardk> it did what it needed to do
22:36:44 <edwardk> and you made it work
22:36:45 <otters> although I can't find addUser
22:37:07 <gseitz> it's in Base.hs
22:37:12 <edwardk> im not sure what i did as i tossed code hither and yon ;)
22:37:22 <edwardk> i don't think i cut up the addUser code
22:37:26 <shachaf> edwardk: Where did isomorphisms get into it?
22:37:27 <otters> christ, why is it in Base.hs
22:37:59 <gseitz> there's a whole lot in Base ;)
22:38:00 <otters> that's like Wordpress' functions.php
22:38:11 <otters> I am ashamed
22:39:22 <otters> cabal-dev doesn't complain about a .cabal file that apparently specifies stm (==2.4 && ==2.3)
22:39:41 <alec__> @hoogle readExpr
22:39:41 <lambdabot> No results found
22:39:56 <gseitz> since a Histogram is typically modified by many threads, directly changing the various fields without going throuh STM seemed okay, but my intuition for that might be completely off
22:39:58 <alec__> i'm trying to follow this tutorial called write you a scheme in 48 hours
22:40:40 <alec__> in chapter 2 there's a function called readExpr which is supposedly imported using import System, except import System doesn't work in the current ghc
22:40:46 <kerrick> [a*b | a <- [1..99], b <- [100 - a]]
22:40:52 <shachaf> alec__: Yes, it's been split up.
22:41:00 <shachaf> Figure out where the things you want are and import them.
22:41:01 <kerrick> Is b <- [100 - 1] the best syntax for the above line?
22:41:06 <kerrick> b = 100 - a didn't work
22:41:12 <blackdog> kerrick: not really. let b=100-a should work
22:41:18 <kerrick> blackdog, ah OK
22:41:27 <alec__> yes; how can i figure that out, shachaf? is there anything else helpful besides hoogle?
22:41:32 <blackdog> or just [a*(100-a)| a<-[1.99]]
22:41:33 <kerrick> blackdog, it's coming back to me now
22:41:33 <shachaf> Hoogle is pretty good.
22:41:35 <kerrick> blackdog, thanks!
22:41:37 <shachaf> What's the issue?
22:42:01 <alec__> the function readExpr from chapter 2 of said book
22:42:09 <alec__> imported using import System
22:42:13 <shachaf> readExpr is defined right there.
22:42:22 <alec__> ok
22:42:35 <shachaf> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing#Presentation looks like it's been fixed to import System.Environment
22:43:03 <alec__> ok, thanks shachaf
22:43:14 <alec__> shachaf++
22:44:25 <alec__> the text still talks about importing 'System' but i guess the code's been updated...
22:44:30 <otters> okay, for some reason, cabal-dev wants stm both ==2.3 and ==2.4
22:44:41 <otters> but the only directive in my .cabal file is stm == 2.4.*
22:45:13 <shachaf> I don't use cabal-dev so I can't help you with it.
22:45:18 <otters> What do you use
22:45:22 <shachaf> With normal cabal I would try cabal -v to see what it says.
22:45:27 <shachaf> Maybe that'll work here.
22:45:35 <shachaf> I just use plain old cabal.
22:46:20 <otters> oh, never mind
22:46:20 <sw2wolf> me too, cabal-dev eats too much disk space ?
22:46:22 <otters> forgot to cabal-dev configure
22:47:15 <shachaf> class ( Profunctor p, Choice p, Strong p , Corepresentable p, Comonad (Corep p), Traversable (Corep p) , Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p) , ArrowLoop p, ArrowApply p, ArrowChoice p) => Conjoined p where
22:47:19 <shachaf> I like how this got into the release.
22:56:20 <edwardk> because i put it there
22:56:37 <shachaf> Right.
22:56:43 <edwardk> there wasn't much point in reducing the complexity on the class as all of those can be useful
22:57:13 <edwardk> as a Conjoined profunctor preserves limits and colimits in all sorts of directions
22:58:30 <edwardk> i use the comonad for corep p on a conjoined profunctor in a couple dozen places in the code, i use the representability. i use the arrow
22:58:50 <edwardk> and choice gets used when you go to use them in prisms, etc.
22:58:56 <edwardk> Profunctor p is redundant
22:58:59 <edwardk> i'll remove that one ;)
22:59:40 <shachaf> Good.
22:59:45 <shachaf> You know how much I hate profunctors.
23:00:06 <edwardk> yep
23:00:30 <hpaste> otters pasted “curious lens installation error” at http://hpaste.org/81107
23:01:12 <edwardk> otters: if you ghc-pkg list | grep template-haskell how many entries comes up?
23:01:17 <otters> hang on
23:01:47 <otters> just the one, 2.8.0.0, but there are broken packages
23:01:49 <otters> I'll look at them
23:02:06 <edwardk> last time i saw something like this it was because of an illegal template-haskell version for the version of ghc the user was on
23:02:10 <edwardk> what version of ghc?
23:02:15 <otters> 7.4.2
23:02:28 <otters> and my haskell-platform (homebrew) came with th-2.7.0.0
23:03:05 <edwardk> thats the problem. if you upgrade template-haskell all sorts of things break
23:03:07 <otters> hang on, I'm gonna reinstall haskell platform
23:03:12 <otters> well, the error happened before I updated it
23:03:15 <otters> that's why I updated it
23:03:17 <otters> upgrade*
23:03:32 <otters> but I'm reinstalling haskell platform so we'll see if anything changes
23:03:37 <edwardk> lens should work with whatever version of template-haskell comes with your compiler, if it doesn't there is a problem.
23:04:12 <edwardk> we should support everything from 7.0 to recent 7.7's
23:05:49 <edwardk> anyways upgrading th will only make that problem worse. =)
23:06:08 <sw2wolf> :t ap
23:06:09 <lambdabot> Monad m => m (a -> b) -> m a -> m b
23:07:03 <kerrick> f n = 2:(replicate 5 n)
23:07:12 <kerrick> is there a way to define this using currying?
23:07:25 <shachaf> What does currying have to do with it?
23:07:28 <shachaf> It only takes one argument.
23:07:30 <kerrick> so that the n is implicit, I mean
23:07:44 <shachaf> Ah, point-free.
23:07:46 <shachaf> f n = 2:(replicate 5 n)
23:07:48 <shachaf> Er.
23:07:49 <shachaf> @pl f n = 2:(replicate 5 n)
23:07:49 <lambdabot> f = (2 :) . replicate 5
23:07:57 <kerrick> ah, that makes sense
23:08:19 <kerrick> thanks shachaf!
23:09:17 <poliquin> Looks like hackage.haskell.org is down ... Or is it just me :-)
23:09:25 <shachaf> @where hackage-mirror
23:09:25 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
23:09:36 <poliquin> Thanks!
23:11:37 <sw2wolf> suppose, a type needs two type variable as "newtype Foo a b = ...", why can it instance Applicative just using one type variable as "instance Applicative (Foo a) where ..." ?
23:12:10 <shachaf> Compare: instance Applicative Maybe where ...
23:12:23 <shachaf> Maybe has one type variable; why can you make the instance with just zero?
23:12:35 <sw2wolf> :t Maybe
23:12:36 <lambdabot> Not in scope: data constructor `Maybe'
23:12:54 <Maxdamantus> :info Maybe
23:13:34 <sw2wolf> shachaf: it is what i want to know
23:13:57 <shachaf> Let's use Functor instance of Applicative
23:14:04 <shachaf> class Functor f where fmap :: (a -> b) -> f a -> f b
23:14:08 <shachaf> Let f = Maybe
23:14:13 <shachaf> fmap :: (a -> b) -> Maybe a -> Maybe b
23:14:20 <shachaf> Does that much make sense?
23:14:37 <sw2wolf> yes
23:14:52 <shachaf> Does your Foo make sense now?
23:15:14 <sw2wolf> thinking ...
23:15:34 <edwardk> functor instance of applicative?
23:15:46 <shachaf> Er, instead.
23:16:04 <shachaf> There are too many "inst" words.
23:16:15 <shachaf> My fingers operate on a four-character prefix.
23:16:59 <edwardk> heh i can't say anything about randomly substituting words ;)
23:19:10 <sw2wolf> shachaf: the second type variable will be  supplied in instance function ?
23:19:21 <shachaf> Something like that, yes.
23:19:36 <sw2wolf> a bit clear
23:19:57 <shachaf> "Maybe" is a functor, not "Maybe a"; similarly, "Foo a" is an Applicative, not "Foo a b".
23:20:59 <sw2wolf> yeah
23:21:37 <sw2wolf> how about Foo a b c ?
23:21:49 <shachaf> 23:11 <sw2wolf> suppose, a type needs two type variable as "newtype Foo a b = ...", why can it instance Applicative just using one type variable as "instance Applicative (Foo a) where ..." ?
23:21:56 <shachaf> Foo a b c doesn't make sense.
23:22:49 <sw2wolf> is 'newtype Foo a b c = ...  ' illegal ?
23:22:56 <shachaf> No.
23:23:11 <shachaf> If you wrote "newtype Foo a b c = ...", then you would write instance Applicative (Foo a b) where ...
23:23:37 <sw2wolf> "Foo a b " is applicative
23:23:47 <shachaf> What?
23:23:58 <sw2wolf> ignore it
23:24:03 <edwardk> @hpaste
23:24:04 <lambdabot> Haskell pastebin: http://hpaste.org/
23:24:18 <hpaste> edwardk pasted “parallel traversal” at http://hpaste.org/81108
23:24:31 <edwardk> shachaf: thats an idea sketch. thoughts?
23:25:23 <sw2wolf> :t lift
23:25:24 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
23:25:38 <edwardk> basically parallel traverse . traverse should  do each ap in the first traversal in parallel and then continue below as normal.
23:26:31 <edwardk> its probably not doing it, but thats the general sketch of what i want
23:36:27 <shachaf> edwardk: "You really hate code reuse, don't you?"
23:36:38 <edwardk> can't reuse it there
23:36:43 <edwardk> different types
23:36:46 <edwardk> different constraints
23:36:48 <shachaf> Oh, right.
23:36:52 <shachaf> You're using (<.>)
23:36:54 <edwardk> yes
23:36:55 <shachaf> OK, so it's just a lens thing.
23:37:08 <edwardk> that (<.>) is from Apply not Lens
23:37:31 <edwardk> thats Applicative sans pure. for relevant traversals, etc.
23:37:33 <shachaf> I mean the thing where you hate code reuse.
23:37:39 <edwardk> oh
23:37:39 <shachaf> Just in lens, not in general. :-)
23:37:57 <shachaf> Anyway, the idea seems reasonable.
23:38:44 <edwardk> i prefer an end-user being able to puzzle through code in isolation more than i prefer making them run around all over searching for the meaning if disparate bits and pieces, but as the pieces get bigger i can be more and more often talked into reusing them
23:41:29 <sw2wolf> :t evalStateT
23:41:30 <lambdabot> Monad m => StateT s m a -> s -> m a
23:41:48 * shachaf tries to work out what the Grain/Parallel thing is for.
23:41:52 <shachaf> Is it just strictness?
23:43:46 <edwardk> yeah i'm playing with variations on it
23:43:52 <edwardk> e.g. ust using a single constructor, etc.
23:44:27 <edwardk> like i said, its more of a sketch. the parallel combinator has the right shape but the rest is just throwing crap at a wall
23:44:44 <shachaf> Right.
23:45:15 <shachaf> Does this do "the right thing" for both folding and mapping?
23:46:00 <edwardk> if it works for traversal it'll work for those
23:46:34 <edwardk> still sketching if it does the right thing for traversal
23:46:39 <shachaf> I mean, does the reconstruction function get parallelized?
23:46:47 <shachaf> Maybe it doesn't matter.
23:49:46 <edwardk> i think i had the wrong semantics anyways
23:49:54 <edwardk> i think i want par for non-grains, and seq for grains
23:58:14 <hpaste> fragamus pasted “golf invitational” at http://hpaste.org/81109
23:59:07 <shachaf> @ty compare `on` snd
23:59:08 <lambdabot> Ord b => (a, b) -> (a, b) -> Ordering
23:59:10 <shachaf> @ty comparing snd
23:59:12 <lambdabot> Ord a => (a1, a) -> (a1, a) -> Ordering
23:59:21 <srhb> Waking up and checking #haskell for Europeans: http://static.quickmeme.com/media/social/qm.gif
23:59:33 <srhb> Oops, http://www.quickmeme.com/meme/3snzng/
