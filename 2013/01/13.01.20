00:00:00 <M30W> > (65536 :: Word8) + (5 :: Word32)
00:00:02 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
00:00:02 <lambdabot>              with actual type...
00:00:06 <M30W> Hehe
00:00:18 <johnw> 65536 doesn't fit in Word16, so you're just saying 0
00:00:30 <M30W> johnw: It loops
00:00:34 <johnw> ah
00:00:38 <M30W> overflow -> back to start
00:01:56 <M30W> In the case of user supplied ports one would have say 66666; the programmer could decide to either let that go through and overflow to 1300 (Iirc) or to make sure it's <65536
00:02:05 <M30W> > 66666 :: Word16
00:02:06 <lambdabot>   1130
00:02:12 <M30W> Yea that :P
00:03:33 <simpson> > fromIntegral (66666 :: Int) :: Word16
00:03:34 <lambdabot>   1130
00:03:39 <simpson> Just cast it.
00:04:08 <M30W> simpson: That's the first option I listed. :P
00:04:56 <shachaf> Haskell doesn't have casts.
00:06:34 <simpson> I know, I know, it's not actually a cast.
00:11:15 <M30W> Is there any way to make this pointfree? `accept >>= \(h,_,_) -> hClose h`
00:11:30 <M30W> Without lenses
00:13:38 <mikeplus64> M30W: that's fine as is, striving for cuteness only leads to insanity and lens libraries
00:13:53 <edwardk> M30W: no
00:13:57 <vhz> M30W: if you define fst3, yes
00:14:12 <M30W> Okay didn't think so ^_^
00:14:36 <M30W> Also why is it lambdabot freaks with turples with _ ?
00:15:01 <simpson> @pl accept >>= (\(h,x,y) -> hClose h)
00:15:01 <lambdabot> (line 1, column 19):
00:15:01 <lambdabot> unexpected "y"
00:15:01 <lambdabot> ambiguous use of a non associative operator
00:15:04 <simpson> Heh.
00:15:39 <M30W> Or turples as lambdas ?
00:18:30 <M30W> main = read . head <$> getArgs >>= listenOn . PortNumber . fromInteger >>= runConn -- And now I wonder if I should add a handeler on that or wrap the getArgs a bit more.
00:18:33 <M30W> :P
00:23:12 <startling> it's too bad you can't pattern match against lambda.
00:25:41 <M30W> startling: /case or /a -> case a of
00:25:57 <M30W> to use /case you need LambdaCase
00:26:10 <M30W> s,/,\,g
00:26:35 <startling> M30W: not what I meant.
00:26:53 <M30W> Still pattern matching with a lambda.
00:27:01 <startling> I said "against"
00:27:13 <M30W> Against it how
00:27:38 <startling> something like someFn (\a -> f b) = f
00:27:54 <startling> (Yes, I'm aware this is silly and breaks referential transparency)
00:28:10 <M30W> There is something like taht
00:28:29 <M30W> ViewPatterns
00:29:31 <startling> nope, completely different.
00:31:06 <M30W> Would break types ?
00:37:22 <Saizan> fmap f m >>= g = m >>= g . f <-- is there a name for that law?
00:39:42 <johnw> doesn't that rely on the ((->) e) instance of Functor?
00:39:52 <shachaf> No, that follows directly from the monad laws for any monad.
00:39:53 <M30W> Hmmm. How would one simplify this ?   f <- newIORef M.empty; A { b = f }
00:40:27 <johnw> M30W: with lens, actually
00:40:35 <shachaf> x >>= g = join (fmap g x), so fmap f m >>= g = join (fmap g (fmap f m)) = join (fmap (g . f) m) = m >>= g . f
00:40:37 <johnw> although it will require some setup
00:41:07 <johnw> shachaf: ah, I see it now
00:41:15 <johnw> fmap is just applying f within the monad
00:41:16 <M30W> So.. No easy way to simplify/make that pointfree? D:
00:41:20 <M30W> W\o lenses
00:41:26 <simpson> M30W: Why?
00:41:55 <johnw> \x -> A { b = x } <$> newIORef M.empty
00:42:06 <edwardk> M30W: you can't pointfree record access
00:42:52 <M30W> :(
00:43:05 <edwardk> thats kinda why lenses were made =P
00:43:23 <M30W> \x -> A x <$> newIORef M.empty -- That would be valid yea ?
00:43:34 <edwardk> sure
00:43:40 <shachaf> Maybe.
00:43:54 <edwardk> assuming 'b' was the second field, etc
00:43:57 * M30W can't see any reason to why record access can't be pointfree :|
00:43:58 <shachaf> Not unless your definition of A happens to match up.
00:44:04 <shachaf> Well, try it out.
00:45:29 <M30W> A = { b :: IORef M.Map ID B }
00:46:08 <shachaf> That looks like a syntax error.
00:46:33 <M30W> type B = M.map ID C -- s/M.Map ID B/B/
00:46:34 <startling> I love syntax errors.
00:46:37 <startling> They are so easy.
00:47:05 <shachaf> What?
00:47:23 <shachaf> Never mind.
00:47:30 <startling> shachaf: syntax errors.
00:47:37 <M30W> type B = M.Map ID C; data A = { b :: IORef B }
00:47:46 <basdirks> M30W: your attempt has disappointed shachaf
00:48:13 <M30W> basdirks: ?
00:48:31 * shachaf sighs.
00:49:00 <basdirks> M30W: how could that A possibly work?
00:49:17 * hackagebot hakyll 4.1.0.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.1.0.0 (JasperVanDerJeugt)
00:49:39 <startling> M30W: use-mention distinction yo
00:49:57 <M30W> basdirks: data A = { b :: IORef B }
00:52:43 <BobbyMcLiar> ghc tells me that I should use -XRank2Types in a type signature. How do I do that?
00:52:57 <shachaf> You don't use it in a signature, you use it for the whole file.
00:52:59 <basdirks> {-# LANGUAGE Rank2Types #-} pragma
00:53:05 <shachaf> Put {-# LANGUAGE Rank2Types #-} at the top of the file.
00:53:12 <shachaf> Or compile with -XBlah
00:53:39 <BobbyMcLiar> hm ok I already did that. Then I'm having a different problem
00:53:46 <M30W> man ghc gives a nice list of them all =)
00:54:19 * hackagebot typelevel-tensor 0.2 - Tensors whose ranks and dimensions type-inferred and type-checked.  http://hackage.haskell.org/package/typelevel-tensor-0.2 (TakayukiMuranushi)
00:54:27 <BobbyMcLiar> I'm using lens with a polymorphic type. thats why I get this error
00:54:53 <startling> BobbyMcLiar, it needs to be the very first thing in the file
00:55:53 <BobbyMcLiar> startling: It is. The error message vanished when I added RankNTypes. The message was kind of misleading
00:57:33 <startling> BobbyMcLiar: k. just a common thing I've seen and done
00:58:13 <BobbyMcLiar> startling: Yep. Some days ago that really was my problem
00:59:16 <startling> GHC really should warn for that.
01:01:01 <shachaf> BobbyMcLiar: Note that you can accept a lens without requiring rank-2 types.
01:01:04 <shachaf> By using cloneLens
01:01:20 <simpson> So, has anybody else been infuriated by Crockford's "Monads and Gonads" talk?
01:01:36 * simpson just realized that -blah is the right channel, sorry
01:01:49 <edwardk> simpson: its easy to be confused by that talk because crockford has no idea what he's talking about
01:02:43 <shachaf> > let foo l x = (view l' x, set l' 'a' x) where l' = cloneLens l in foo _1 (1,2)
01:02:44 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Mutator b0'
01:02:45 <lambdabot>            ...
01:02:55 <shachaf> > let foo l x = (view (cloneLens l) x, set (cloneLens l) 'a' x) in foo _1 (1,2)
01:02:55 <simpson> edwardk: At "Which mainstream language was the first to have lexical closures? That's right, JavaScript," I flipped my table and decided to just pretend that he's some random senile guy.
01:02:57 <lambdabot>   (1,('a',2))
01:03:06 <shachaf> Simon "lets should not be generalized" Peyton Jones strikes again!
01:03:15 <startling> simpson: hahahaha
01:03:39 <edwardk> simpson: hah
01:04:36 <simpson> Anyway, I'm in a happy place. I have a 100-line pong which I independently hacked up, and I'm well on my way to doing my entire run of One Game a Month in Haskell.
01:05:00 <simpson> And I'll start publishing the source to the engine parts of it once I'm satisfied that it's useful to others.
01:06:47 <mmcdermo> Is there a good resource for the syntax used in type system papers? I'm lost on the double down arrow and the right arrow extending from a bar.
01:07:43 <Saizan> x |-> e is just like \x -> e in haskell
01:07:52 <startling> mmcdermo, can you link to an example?
01:07:58 <mmcdermo> Saizan: thanks!
01:08:05 <mmcdermo> startling: http://people.cs.uu.nl/andres/LambdaPi/LambdaPi-old.pdf
01:08:21 <startling> oh hey, that thing
01:08:21 <mmcdermo> Although I do need to learn to read. The double down arrow is explained several paragraphs after usage.
01:08:29 <startling> yes, I had tons of trouble with it too.
01:08:34 <Saizan> the double down arrow is often used to mean "terminates", but it has its own meaning in that paper
01:08:46 <frerich_> Hm, is there a tool which can check Haskell source code for opportunities to factor code out of IO actions into pure functions?
01:08:47 <startling> it's "evaluates to", isn't it?
01:09:09 <mmcdermo> startling: That's what it states in the paper
01:09:30 <Saizan> really? iirc it was about type inference
01:09:47 <mmcdermo> " The
01:09:47 <mmcdermo> notation e ⇓ v means that the result of completely evaluating e is v.
01:10:05 <mmcdermo> Copy/paste fail. The block symbol is a double down arrow.
01:10:17 <startling> no, it's a double down arrow. :)
01:10:35 <startling> (your irc client is the one failing here)
01:10:42 <Saizan> ah, yeah, it's ::_downarrow that's type checking
01:10:54 <mmcdermo> startling: Probably not irssi's fault. I have a strange compilation of font packages installed.
01:11:11 <Saizan> mmcdermo: anyhow, those inference rules are actually defining what the double-down-arrow means
01:11:20 <startling> mmcdermo: okay, it's your terminal's fault, then.
01:12:05 <mmcdermo> Saizan: That makes sense in a broad way. I shall investigate with this in mind.
01:13:39 <Saizan> you can read them as a logic program
01:14:11 <mmcdermo> Saizan: Any tips on evaluation strategies? :)
01:15:12 <Saizan> sure, match your query against the conclusions to find a rule and then recurse on the premises :)
01:15:27 <Saizan> backtrack if necessary
01:17:24 <mmcdermo> Saizan: Thanks for the tip - I won't feel as crazy recursing and backtracking knowing that it's the strategy.
01:19:20 <Saizan> not everything defined as inference rules is meant to be executable though, some are meant more like GADTs which you have to build (i guess this is another instance of the code is data is code is data ..)
01:22:17 <mmcdermo> Saizan: I guess learning about dependent types and type system syntax at the same time is rather nice then.
01:23:41 <Saizan> heh yeah :)
01:24:10 <Saizan> in fact in epigra1 you'd use that syntax to define datatypes
01:24:15 <Saizan> *epigram1
01:27:09 <mmcdermo> Saizan: Sounds about right. Seems like there's some vast singularity approaching - but that's probably just because I mostly used PHP before haskell.
01:28:41 <Saizan> heh
01:30:22 <simpson> Out of curiosity, is there a simpler monad than State [] which is isomorphic to a stack with a few stack-primitive operations and access to the top of the stack?
01:34:07 <Saizan> you could have the free monad over the singnature of the operations, but State [a] would still be the most obvious interpretation
01:36:24 <mmcdermo> Saizan: Thanks for the help! I made it past the first page and was able to apply logic and achieve about 50% understanding.
01:36:58 <mmcdermo> Saizan: Which I consider to be an awesome success :). Night!
01:38:40 <M30W> Is there a function for fromList Maybe ?
01:42:06 <Lethalman> M30W, fmap fromList ?
01:46:28 <M30W> f . fromList $ map (x . read) xs
01:46:36 <M30W> x returns Maybe
01:46:53 <M30W> Lethalman: ^
01:47:27 * M30W renames x later.
01:47:46 <monqy> :t catMaybes
01:47:47 <lambdabot> [Maybe a] -> [a]
01:48:04 <monqy> is this what you want?
01:48:12 <M30W> Yea.
01:48:26 <M30W> @hoogle catMaybes
01:48:26 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
01:48:35 <shachaf> You should start with the type.
01:48:45 <shachaf> You know about Hoogle, so you could've just typed that type in.
01:48:56 <shachaf> Makes it much easier to figure that out first.
01:49:12 <M30W> Yay
01:49:41 <M30W> shachaf: Good tip; go with the type. :)
01:49:46 <M30W> Thanks
01:53:37 * M30W should use M-s h more often; (xmonad, search hoogle)
01:58:38 <epta> What happens with hayoo?
01:59:02 <srhb> It searches more?
02:01:14 <M30W> It's slower :)
02:01:22 <M30W> Not responding to me atleast :P
02:01:49 <epta> Yeah, it was responding something about minute
02:03:28 <srhb> Works fine, here.
02:04:18 * hackagebot htodo 0.0.4 - A todo application.  http://hackage.haskell.org/package/htodo-0.0.4 (YoichiHirai)
02:04:20 * hackagebot linear 0.7 - Linear Algebra  http://hackage.haskell.org/package/linear-0.7 (EdwardKmett)
02:05:31 <Lethalman> it seems to me that hayoo search by type is less quality than hoogle
02:05:38 <Lethalman> for example (a -> b) -> [a] -> [b] doesn't return map as first result
02:06:05 <shachaf> Hayoo is probably a better choice for searchign by name.
02:06:12 <Lethalman> shachaf, seems so
02:06:18 <Lethalman> it doesn't even return Prelude.map
02:06:25 <shachaf> It seems to me to be down.
02:06:38 <startling> here, too.
02:09:12 <mysticc> @hoogle sizeOf
02:09:12 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
02:09:12 <lambdabot> GHC.Constants sIZEOF_CostCentreStack :: Int
02:09:12 <lambdabot> GHC.Constants sIZEOF_generation :: Int
02:14:19 * hackagebot gemstone 0.1 - A simple library for SDL+GL games.  http://hackage.haskell.org/package/gemstone-0.1 (CorbinSimpson)
02:15:20 <simpson> Heh. I have released yet more code.
02:17:59 * Lethalman as a newcomer feels good at seeing new hackage versions get released often
02:31:53 <zxq9> There doesn't happen to be any way to develop Haskell applications on Android and iOS, does there?
02:33:58 <srhb`> zxq9: I think so, though not necessarily easy.
02:34:19 * hackagebot language-spelling 0.3.2 - Various tools to detect/correct mistakes in words  http://hackage.haskell.org/package/language-spelling-0.3.2 (FrancescoMazzoli)
02:36:51 <cads> zxq9: not anything polished or used in any mobile app developer's toolkit, that i know of
02:37:12 <cads> but I do remember some people writing code that specially targets the ios, say
02:38:07 <jdnavarro> is there anyway to predict to which thread it will switch when using `yield`?
02:38:24 <jdnavarro> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Control-Concurrent.html#g:4
02:39:35 <zxq9> Hrm... not a very happy situation.
02:39:56 <jdnavarro> I have a thread that is always blocking but want to launch another one in case a value shows up in a queue
02:39:56 <zxq9> It would be nice if we could use a single cool language and widget set everywhere. But apparently that's just not the case.
02:40:45 <jdnavarro> I could kill the blocking thread and relaunch it again after the second thread is done, but I was wondering if it wouldn't be better to suspend the first one
02:44:19 * hackagebot linear 0.8 - Linear Algebra  http://hackage.haskell.org/package/linear-0.8 (EdwardKmett)
02:48:01 <Saizan> jdnavarro: how is it blocking? i imagine many blocking operations provided by the stdlib will prevent it from getting scheduled
02:48:39 <jdnavarro> it's waiting on data from a TCP socket
02:51:07 <Saizan> yeah, i think it won't be relevant until data arrives
02:52:33 <jdnavarro> Saizan: I want that thread to pull data from the socket when there are no tasks in a queue, but as soon as a new task is available, I'd like that listener thread to stop and have the second thread sending data back and forth through the socket until is done
02:53:00 <jdnavarro> when is done, then the first thread should take over again
02:53:49 <Saizan> ah
02:55:34 <Saizan> waiting for data from the socket and tasks on the queue at the same time seems the hardest part
02:55:58 <Saizan> other than that you can just use a single thread
02:56:00 <c_wraith> the mechanism ghc gives you for doing that is multiple threads
02:57:01 <Saizan> c_wraith: but even with multiple threads it's not easy to stop reading from the socket once there's something in the queue
02:57:19 <c_wraith> throwTo will work
02:57:25 <c_wraith> but it's kind of ugly
02:57:50 <jdnavarro> Saizan: right, I don't want the listener thread to mess up with the worker thread
02:58:17 <jdnavarro> would `orElse` work here?
02:58:31 <c_wraith> if network traffic was an STM event, sure
02:59:13 <Saizan> anyhow to answer your original question you can't predict/control which thread you will switch to after a yield
03:00:07 <Saizan> for `orElse` to work you could push the network traffic into a TChan using another thread, then you can `orElse` on reading on that chan
03:00:50 <c_wraith> That doesn't really work, though, because it doesn't free up the socket for use by the task from the queue
03:01:33 <c_wraith> throwTo is really the only way I know of to get a thread to stop reading from a socket.
03:02:50 <jdnavarro> I guess I could kill the listener thread when there is a new task, and have the worker thread launch a new listener when is done, would that work?
03:02:52 <c_wraith> I mean..  That's how System.Timeout is implemented
03:03:00 <c_wraith> You don't need to kill the listener thread
03:03:17 <c_wraith> exceptions need not be fatal
03:05:13 <jdnavarro> c_wraith: so could I throw a custom exception to stop it and resume later?
03:07:10 <c_wraith> yeah, though you'd want to synchronize between the listening thread and the task manager
03:07:20 <c_wraith> Probably with a pair of MVars
03:08:41 <c_wraith> So that the thread reading the queue is sure the listener thread is done with the socket before proceeding, and vice versa
03:10:43 <jdnavarro> ok, I think I'm getting it, I'll play with `throwTo`
03:10:48 <jdnavarro> thanks
03:41:37 <rohitkav> What does Monad means
03:44:52 <johnw> heh
03:45:08 <johnw> rohitkav: it describes an interface that a value supports
03:45:20 <johnw> consisting of two functions, 'return' and '>>='
03:45:32 <johnw> what they do depends on the type of the value involved
03:45:45 <edward> its greek for unit or alone.
03:45:45 <johnw> my recommendation is to read the section in Learn You a Haskell about them
03:45:47 <johnw> @where lyah
03:45:47 <lambdabot> http://www.learnyouahaskell.com/
03:49:11 <`ramses> but start in the chapter about functions, and work your way to the monad chapter
03:49:19 <`ramses> it will make a lot more sense then
03:49:27 <`ramses> s/functions/functors
03:49:33 <shachaf> edward?
03:49:35 <shachaf> help
03:49:58 <srhb> Lens distress beacon activated?
03:50:55 <shachaf> srhb: edwardk isn't the confusing one here.
03:51:17 <srhb> Aha.
03:51:26 <Zariel> Is there are a way to add type constraints to data types?
03:51:41 <Zariel> ie, data (Ord a) => Fish a = Fish a ?
03:52:04 <Botje> yes, it's possible, but it's Not Done(tm)
03:52:05 <shachaf> Yes, but you probably shouldn't do it.
03:52:17 <Zariel> instead have the type constraint on the functions that use the type?
03:52:30 <shachaf> Yes.
03:52:47 <johnw> shachaf: did you hear that any Map, IntMap, etc., is now a vector space?
03:53:41 <srhb> johnw: !! awesome!
03:53:53 <`ramses> Zariel: if you do so, you have to add the same constrain to *any* function using that data type
03:54:15 <johnw> it's in linear 0.7, just import Linear.Vector and boom, you can ^+^ between Maps over Num types
03:54:16 <`ramses> if you don't, you only add them to the functions which rely on the constraint
03:54:22 <Zariel> yeah that was why I thought it would be clearer to add the type constraint to the data type
03:54:24 <srhb> That is excellent. :)
03:59:16 <`ramses> Zariel: you can hide the constructor and have a function to create values which does have the constraint. That makes it visible (and mandatory) without the annoyance
04:02:38 <jacobw> hi, i'm trying to follow this, the code example here works when i paste it, i can't see what formatting error i'm making when typing it
04:02:39 <jacobw> http://learnyouahaskell.com/syntax-in-functions#case-expressions
04:03:11 <srhb> jacobw: Tabs?
04:03:17 <jacobw> as far as i can see, the second pattern should be intended to show that it's in the same block
04:03:41 <jacobw> srhb: so the third line should be "\t(x:_) -> x"?
04:03:42 <srhb> jacobw: It would be easier if we see what you typed and the error you get, hpaste.org it
04:03:53 <srhb> No, don't use tabs.
04:04:07 <jacobw> srhb: sure
04:04:22 <jacobw> srhb: don't use tabs?
04:04:36 <shachaf> Nope. Use spaces.
04:04:38 <srhb> jacobw: Don't use tabs.
04:04:55 <Hafydd> I'll join the peer pressure.
04:04:58 <Hafydd> Use spaces!
04:06:55 <jacobw> srhb: http://pastebin.com/Dc3cv8nr
04:07:00 <mauke> The paste Dc3cv8nr has been copied to http://hpaste.org/81003
04:07:09 <jacobw> srhb: how many spaces for each block?
04:07:19 <srhb> jacobw: That's up to you. I use two or four, depending.
04:07:43 <srhb> jacobw: There's a tab in your space.
04:07:43 <shachaf> jacobw: The (x:_) has to be aligned with the []
04:07:45 <srhb> er, paste.
04:07:52 <shachaf> And also use spaces.
04:09:15 <jacobw> nice
04:10:29 <srhb> jacobw: If it feels odd, it's because that kind of formatting is generally not used. NOrmally I think people would move the patterns to the next line
04:10:49 <srhb> jacobw: then [] and (x:_) start on the same column number without having to indent one line a lot.
04:11:26 <srhb> jacobw: See my annotation: http://hpaste.org/81003
04:12:07 <srhb> (and then align the arrows too for niceness!)
04:13:17 <hpaste> jacobw pasted “case_identation-1” at http://hpaste.org/81006
04:13:29 <jacobw> srhb: i see now
04:14:12 <bsrk> Hi,
04:14:14 <bsrk> I have a tuple (a,a), and function (a -> b). How do I most efficiently apply the function over the two values?
04:14:38 <Peaker> bsrk, what do you mean by "efficiently"? Less code?
04:14:43 <bsrk> yes
04:14:49 <bsrk> less code
04:14:52 <Peaker> > both%~(*2)  $ (1,2)
04:14:54 <lambdabot>   (2,4)
04:15:09 <bsrk> thanks!
04:15:20 <shachaf> Note that this uses a third-party library, lens.
04:15:20 <wuttf> > :t both
04:15:22 <lambdabot>   <hint>:1:1: parse error on input `:'
04:15:23 <shachaf> @ty over both
04:15:25 <lambdabot> (a -> b) -> (a, a) -> (b, b)
04:15:39 <Peaker> Control.Lens defines "both" which is a traversal of both in a tuple. And it defines %~ which applies a pure function on every element of a traversal
04:15:40 <mikeplus64> is there a way to get cabal not to rebuild everything (and only rebuild what it needs to)
04:15:43 <mikeplus64> ?
04:15:58 <srhb> mikeplus64: That's default behaviour (in ghc) is it not?
04:16:18 <Peaker> mikeplus64, it does that normally, unless it's building from the cache -- you can "cabal unpack" and use "cabal install" within the unpacked dir if you're getting rebuilds of a dependency
04:16:30 <Peaker> s/cache/temporary-unpack-dir
04:16:53 <mikeplus64> srhb: it seems not, at least when i'm playing with lens if i change anything
04:27:28 <edward> Hi
04:27:36 <srhb> edward: Hi.
04:28:03 <edward> I am just trying to install BNFC-2.4.2.1 and it seems to blow up at formats/c-sharp/CSharpTop.hs:362:19: Not in scope: `catch'
04:28:16 <edward> Has the package gone out of date on hackage?
04:28:24 <shachaf> Probably.
04:28:27 <shachaf> Are you using GHC 7.6?
04:28:31 <edward> Aww :/
04:28:36 <edward> let me check
04:28:48 <edward> 7.6.1 yes
04:29:00 <shachaf> 7.6 deprecated an old exception mechanism and unfortunately broke a lot of programs.
04:29:36 <edward> ah, yea, I ran into problems before I believe when I first updated because Arch is rolling as you know.
04:29:40 <hamid> hmm is there a function for taking 10 last element of the list?
04:29:51 <shachaf> No.
04:30:02 <edward> tail ?
04:30:04 <shachaf> You can write an efficient one by using a clever trick, or you can do it some boring way.
04:30:30 <hamid> shachaf, what's the trick?
04:30:40 <shachaf> It's in the style of
04:30:42 <shachaf> @where sneaky
04:30:42 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
04:30:52 <shachaf> Except the other way.
04:31:02 <shachaf> It doesn't have as concise an implementation unfortunately.
04:31:31 <magistr> what different between definition range of function and domain of function?
04:31:37 <edward> I am trying to improve xmobar shachaf so that it can handle images next to things like network, cpu etc..
04:31:43 <hamid> shachaf, ok thanks.
04:32:06 <edward> However both the X Pixmap (XPM) and XBM are pathological specs
04:32:35 <edward> So I basically need to write a frontend of a C compiler just to view a image
04:32:51 <shachaf> Is there no library for it?
04:32:51 <magistr> edward, what different between definition range of function and domain of function?
04:33:03 <edward> I was hoping BNFC would do most of the work for me
04:33:30 <Athas> How do I disable library profiling on the command line when building with cabal?
04:33:36 <edward> magistr: domain is where the function maps from and the range is where it maps to
04:33:53 <edward> magistr: I don't believe so
04:34:52 <`ramses> what's the usual approach to upgrade a cabal pkg? Say I have an old version of hlint installed and want to remove it and install the most recent version instead? Google is confusing me...
04:35:28 <`ramses> I read that cabal upgrade has been deprecated due to problems with it but I can't find a sane alternative
04:35:44 <hamid> how lovely streams were and i wasn't aware of :|
04:35:48 <srhb> Athas: Have you taken a look at cabal configure --help | grep profiling ?
04:35:55 <edward> oops I mean shachaf
04:36:11 <edward> perhaps http://hackage.haskell.org/packages/archive/X11/1.4.5/doc/html/Graphics-X11-Xlib-Misc.html#7
04:36:12 <johnw> just cabal install hlint
04:36:22 <`ramses> will that remove the old version?
04:36:22 <edward> that's the closes I could find
04:36:34 <johnw> ghc-pkg unregister hlint, then cabal install hlint
04:36:41 <johnw> it will overwrite the old version's binary
04:36:49 <Athas> srhb: ah, yes, I forgot it was a compile-time and not a build-time option.
04:36:55 <Athas> Er, s/compile/configure/.
04:37:13 <Athas> There, now it links.
04:37:17 <srhb> Athas: Great. :)
04:37:27 <`ramses> ah okay, so no further clean up required after the unregister? I thought the old packages would be kept somewhere then
04:37:59 <`ramses> will that also upgrade and overwrite any deps of hlint that got newer versions?
04:38:16 <`ramses> (and if so, should I manually unregister all of those as well?)
04:41:55 <edward> shachaf: still here?
04:42:11 <shachaf> edward: Yep.
04:50:01 <edward> shachaf: I think I am starting to work it out now.. http://hpaste.org/43464/readbitmapfile http://xmonad.org/xmonad-docs/X11/Graphics-X11-Xlib-Misc.html
04:50:07 <edward> is what I am currently looking at.
04:55:59 <shachaf> edward: Seems reasonable.
04:56:10 <shachaf> You could also just convert the picture to whatever format you like.
04:56:18 <shachaf> In advance.
04:57:32 <edward> shachaf: This is true, however most of those little icon packs online are in XBM or XPM format
04:57:47 <edward> In particular I am trying to display these
04:57:49 <edward> http://dzen.geekmode.org/dwiki/doku.php?id=dzen:icon-packs
05:03:05 <tcsavage> Can anyone tell me, using the LLVM bindings, how I can create a `ConstValue Word32` value?
05:04:34 <edward> shachaf: Xlib programming makes one want to run off the side of a cliff
05:04:43 <shachaf> Yep.
05:04:51 <shachaf> Why not convert the images to another format?
05:08:18 <BobbyMcLiar> What do I have to do to make lens create lenses of fields of rank 2 types? I just get a Not in scope error message
05:14:14 <edward> shachaf: Whats a better format to deal with?
05:14:23 <edward> For this particular use
05:14:27 <shachaf> Whatever there are libraries for?
05:14:44 <edward> Well this is a very special use..
05:14:51 <shachaf> p*m is very simple.
05:14:54 <shachaf> ppm etc.
05:14:59 <edward> icons in xmobar
05:15:40 <edward> shachaf: is there a haskell library for that?
05:16:00 <shachaf> I don't know.
05:18:45 <edward> shachaf: its also inefficent isn't it
05:18:56 <edward> although I guess 8x8 pix does not matter
05:28:21 <zett_zelett> I have little time, otherwise I'd research it myself: What type can I use for a function definition like Num a => (a -> a) if I want ordering and fractions?
05:28:43 <zett_zelett> I kind of need Fractional ∩ Ord, I think.
05:29:09 <psii> (Fractional a, Ord a) => ...?
05:29:19 <zett_zelett> Thanks (didn't know the syntax).
05:31:38 <`ramses> zett_zelett: if you know how to define the function but unsure about the type, you can always try to load it in ghci and ask for the type
05:33:57 <wmasson> what benefits are there to explicitly typing your functions? I know inference doesn't always work but if it does is it worth adding the type anyway?
05:34:13 <shachaf> @quote rwbarton inference
05:34:13 <lambdabot> rwbarton says: type inference is supposed to be the compiler's job, not the reader's job
05:34:23 * hackagebot HarmTrace-Base 1.0.0.1 - Parsing and unambiguously representing musical chords.  http://hackage.haskell.org/package/HarmTrace-Base-1.0.0.1 (BasDeHaas)
05:34:41 <wmasson> ok
05:34:44 <wmasson> thanks
05:34:49 <AfC> wmasson: {shrug} it's often not obvious what types a function does
05:35:01 <AfC> s/types //
05:35:13 <AfC> wmasson: so it can help with code readability.
05:35:35 <Hermit> wmasson: and... without explicit typing, the MR can screw up
05:38:35 <zett_zelett> http://pastebin.com/ksAzCfca how can I fix "possible wrong identation"?
05:38:36 <mauke> The paste ksAzCfca has been copied to http://hpaste.org/81007
05:38:51 <EarlGray> Hello. If I want a stack interface to a list, is there an available standard implementation?
05:39:42 <EarlGray> HaskellWiki shows how to implement this in few lines, but I'd rather use some standard code
05:39:45 <elliott> EarlGray: you should be able to just use lists directly
05:39:52 <elliott> or maybe State [a] if you want something monadic
05:39:54 <EarlGray> ok
05:40:01 <elliott> depends on your needs
05:43:13 <s_kilk> hi everyone, would any of you be able to help me with the first example of Chapter 10 "Persistent" from the Yesod book ? when attempting to run the example I get an error : `PersistEntityBackend' is not a (visible) associated type of class `persistent-1.1.0.1:Database.Persist.Store.PersistEntity'. the code is the first example here: http://www.yesodweb.com/book/persistent
05:45:42 <`ramses> zett_zelett: align every "if" with its corresponding "then" and "else"
05:46:30 <hiptobecubic> i'm having trouble understand this explanation of Free things.http://stackoverflow.com/questions/14387839/functors-and-free-objects-in-hask
05:47:13 <hiptobecubic> if you have a Free foo, i believe someone here said that it was "the foo which makes no additional assumptions" or something to that effect
05:47:23 <zett_zelett> `ramses: Thanks, yes. I also figured it out meanwhile. (I'm a bit under time pressure.)
05:47:27 <hpaste> cordawyn pasted “Testing pipes” at http://hpaste.org/81008
05:48:10 <hpaste> ClaudiusMaximus pasted “for zett_zelett” at http://hpaste.org/81009
05:48:17 <hiptobecubic> but in this example, it looks like `i` is `pure`
05:48:22 <ClaudiusMaximus> zett_zelett: but guards would be better
05:50:39 <hiptobecubic> but  to have f' . i = f, you need (f' :: FT -> S) . (i :: T -> FT)
05:51:44 <Hermit> EarlGray: or you could do it without lists too... let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
05:53:55 <hiptobecubic> but what is f' doing? If we're talking about free monoids (lists) then f' is just `head` i guess?
05:53:56 <hpaste> cordawyn annotated “Testing pipes” with “Testing pipes (annotation)” at http://hpaste.org/81008#a81010
05:55:10 <elliott> Hermit: That's not very useful because it's hard to give them useful types.
05:55:17 <hpaste> “`ramses” annotated “pastebin.com/ksAzCfca” with “with guards” at http://hpaste.org/81007#a81011
05:55:35 <`ramses> zett_zelett: ^^ also note that the inv function already exists, it's called recip
05:57:03 <beaky> hello
06:00:25 <hiptobecubic> :t (***)
06:00:26 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:01:33 <hiptobecubic> > negate (***) (+3) $ (2 ,10)
06:01:34 <lambdabot>   Couldn't match expected type `(->)' with actual type `(,)'
06:01:39 <hiptobecubic> oops
06:02:20 <hiptobecubic> > negate *** (+3) $ (2, 10)
06:02:21 <lambdabot>   (-2,13)
06:02:50 <zett_zelett> Another question: Is there possibly maybe a module or something which allows me to plot functions like Rational -> Rational?
06:07:11 <hiptobecubic> if you are plotting then it doesn't need perfect precision. plot (fromRational . f)
06:07:57 <edward> ok, anyone done X programming in Haskell before?
06:09:22 <merijn> edward: X as in the windowing protocol?
06:13:14 <edward> merijn: yes
06:22:48 <Hermit> edward: how about asking at #xmonad?
06:24:03 <edward> Hermit: maybe a good idea
06:24:09 <edward> really need to setup my irssi
06:24:17 <Hermit> why not weechat?
06:32:30 <gspr> I'm trying to clean up my checks somewhat confused when it comes to building Properties. Suppose I have two checks: f :: (Foo a) => a -> a -> Bool   and  g :: (Foo a) => a -> a -> a -> Bool. I can of course easily define a new check h by h x y z = f x y && g x y z, but can't I also do so with QuickCheck's conjunction?
06:33:37 <gspr> I think I'm trying to say h = f .&&. g
06:36:05 <Hermit> :t (.&&.)
06:36:06 <lambdabot>     Not in scope: `.&&.'
06:36:06 <lambdabot>     Perhaps you meant `.&.' (imported from Data.Bits)
06:36:23 <geri> how difficult is it to learn haskell?
06:36:31 <srhb> geri: 9.
06:36:31 <Hermit> geri: brutal
06:36:35 <gspr> Hermit: I'm talking about Test.QuickCheck.(.&&.)
06:36:38 <johnw> geri: it really depends on your backgroudn
06:36:39 <geri> with c++ backgground?
06:36:50 <`ramses> geri: impossible, then
06:36:51 <johnw> yeah, it will be hard
06:36:55 <johnw> that's where I came from
06:37:03 <geri> haha...nothing is impossilble
06:37:03 <srhb> You need to learn functional programming. That's the big thing. Haskell is easy enough once you've got that. :P
06:37:20 <geri> why should you use functional programming?
06:37:35 <srhb> Because Haskell is cumbersome otherwise.
06:37:38 <johnw> one good way to learn functional programming is to follow this course: http://www.cis.upenn.edu/~bcpierce/sf/
06:38:06 <srhb> Meh, LYAH will give you the foundations. ^^
06:38:15 <johnw> LYAH is much better for using Haskell
06:38:31 <johnw> I just find that SF has a really nice progression
06:38:34 <srhb> Right, but I think actually diving into FP after learning an FP language's basics is wiser.
06:38:47 <johnw> yes, I can't argue with you there
06:38:49 <srhb> Not that I'm very much opposed.
06:39:02 <johnw> plus, SF gets to be *fun*
06:39:40 <johnw> you know, we need a LYAH with interactive exercises...
06:40:02 <srhb> Yeah.
06:40:40 <`ramses> what do you mean by interactive exercises? like tryhaskell?
06:41:11 <Hermit> geri: http://www.cse.chalmers.se/~rjmh/Papers/whyfp.html
06:41:17 <fmap> SF with vim is *pain* :[
06:41:25 <johnw> fmap: oh wow, I bet
06:41:38 <johnw> I use ProofGeneral in Emacs, integrated with prooftree
06:41:59 <johnw> i see pretty trees of my proof where the branches turn green as I prove my subgoals :)
06:42:07 <srhb> That sounds fun.
06:42:14 <johnw> it's seriously addictive
06:42:24 <srhb> could you be convinced to do a screencast of it sometime?
06:42:33 <johnw> i've spent entire nights wanting to go to bed and not being able to
06:42:38 <srhb> I've mostly no idea what I'd use it for, and I'd like to see a practical example with it. :)
06:42:39 <johnw> you know, that's not a half bad idea, srhb
06:42:44 <johnw> I can at least show you a screenshot
06:42:51 * Hermit thumbs up for the screencast
06:42:53 <srhb> Thanks! (But do a screencast, too! :D)
06:43:05 <parcs> yeah, the problem is that people get overwhelmed when learning haskell because they are learning like 3 distinct and unfamiliar concepts at once
06:43:12 <srhb> parcs: Exactly.
06:43:37 <srhb> But I still think learning language basics then headdesking a few times is not too dangerous.
06:44:23 <soafee-chan> :t map
06:44:24 <lambdabot> (a -> b) -> [a] -> [b]
06:44:59 <basdirks_> I attack new things in Haskell straight ahead, which results in pretty retarded and nonsensical questions sometimes, but also gets me where I want fastest
06:44:59 <johnw> srhb: http://ftp.newartisans.com/pub/prooftree.png
06:45:28 <Hermit> soafee-chan: you can also use lambdabot privately ;-)
06:45:44 <basdirks> or install it on your machine
06:45:50 <spacekitteh> that would save some minor embarassment i guess
06:46:05 <srhb> johnw: Neat!
06:46:32 <johnw> light blue on the right side means "proven text"
06:47:04 <johnw> or rather, processed text
06:48:24 <srhb> It looks very cool. I get the idea of how it works. :)
06:49:08 <zett_zelett> I want to install plot, but I receive this error: "Configuring hmatrix-0.14.1.0... Checking foreign libraries... FAIL *** Sorry, I can't link GSL. …".
06:49:36 <Maior> basdirks: I know that feeling!
06:50:20 <Hermit> johnw: what do you use this for?
06:50:32 <basdirks> =]
06:51:02 <johnw> Hermit: http://www.cis.upenn.edu/~bcpierce/sf/
06:52:04 <johnw> "Software Foundations", aka "Crack in a Bag" -- if you like functional programming :)
06:52:12 <zett_zelett> I can't interpret the error.
06:52:52 <Hermit> johnw: I was asking about the screenshot
06:53:03 * Hermit giggles
06:53:04 <johnw> Hermit: yes, that's what I use that for
06:53:04 <srhb> zett_zelett: Have you installed GSL?
06:53:24 <`ramses> zett_zelett: looks like you need some lib installed. Called GSL, I guess
06:53:52 <srhb> Probably libgsl-dev on a Debian based system.
06:54:20 <zett_zelett> Ah, yes I tried to install it.
06:54:27 * hackagebot tls-extra 0.4.6.1 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.6.1 (VincentHanquez)
06:54:29 * hackagebot hakyll 4.1.1.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.1.1.0 (JasperVanDerJeugt)
07:00:37 <zett_zelett> Ohmy, I'm installing libraries for 10 minutes now.
07:01:08 <zett_zelett> YES.
07:01:09 <zett_zelett> DONE.
07:01:18 <zett_zelett> Finally.
07:01:18 <johnw> huh
07:01:27 <johnw> i have sandbox builds that take up to an hour
07:01:38 <johnw> just installing library after library after library...
07:03:36 <srhb> Yes, where are my parallel builds already..
07:03:49 <johnw> you don't use cabal install -j?
07:04:27 <srhb> I don't think cabal install has that on my system
07:04:35 <johnw> ah, that's a pity
07:04:39 <Taneb> I'm gonna think outloud for a bit
07:04:53 <Taneb> XML-like things, generating them
07:05:07 <Taneb> Could be a Monoid
07:05:42 <Taneb> element :: Text -> Attribute -> Content -> Content
07:05:59 <Taneb> text :: Text -> Content
07:06:19 <Taneb> instance Monoid Attribute; instance Monoid Content
07:06:28 <Taneb> Attribute is really closer to AttributeSet
07:06:40 <Taneb> In fact, I could just use that
07:06:59 <Taneb> element :: Text -> Set Attribute -> Content -> Content
07:07:07 <Taneb> Although it's more of a mappy thing
07:07:21 <Taneb> element :: Text -> Map Text Text -> Content -> Content
07:07:58 <Taneb> text :: Text -> Content -- formats so it's safe, &gt; etc
07:08:39 <johnw> Taneb: I wonder if this relates: Taneb:
07:08:41 <johnw> http://apfelmus.nfshost.com/articles/monoid-fingertree.html
07:09:13 <Taneb> johnw: I don't think so
07:09:28 <Taneb> Because XML-like data can be arbitrary trees, not just 2-3 trees
07:09:34 <basdirks> data HTML = Inner String | Node String Attributes (Maybe [HTML])
07:09:42 <johnw> but can't you model any arbitrary tree as a 2-tree?
07:09:48 <basdirks> type Attributes = Map String String
07:10:18 <basdirks> node x = Node x Map.empty (Just [])
07:10:25 <basdirks> leaf x = Node x Map.empty Nothing
07:10:44 <basdirks> this is what I use for generating HTML in a production environment
07:10:54 <Taneb> I'd have used Text personally
07:11:11 <basdirks> sure, if I run into the need
07:11:24 <Hermit> edward: have you found any decent info regarding xlib already?
07:11:36 <Taneb> And the Maybe is redundant, you can just use an empty lsit
07:11:39 <Taneb> *list
07:11:44 <basdirks> no it's not
07:12:29 <basdirks> the empty list means has no children here
07:12:33 <basdirks> Nothing means it can't have children
07:12:41 <basdirks> in which case it's a leaf element like <img>
07:12:43 <Taneb> Ah, I'm thinking of arbitray XML
07:12:48 <basdirks> sure
07:12:54 <Taneb> Which explains the discrepency
07:13:03 <basdirks> for XML you'd want to do it differently
07:15:16 <Taneb> data XML = Inner Text | Node Text Attributes [XML] | TempWrapper (Seq XML) {- helps with Monoid instance -}; type Attributes = HashMap Text Text
07:16:08 <Taneb> Wait, I can separate out TempWrapper
07:16:22 <basdirks> getAttr x k = x ^? attrs.ix k
07:16:26 <basdirks> looks familiar?
07:16:37 <basdirks> or are you not doing it with lens?
07:16:44 <Taneb> I'm just thinking outloud
07:16:54 <Taneb> Haven't actually written anything down yet
07:19:28 <Taneb> It's a sort-of-Monoid; it's a Monoid as long as we promise that there's a layer above
07:22:51 <johnw> Taneb: have you heard of byorgey's dualtree?
07:22:59 <johnw> you saying "layer above" made me think of it
07:22:59 <Taneb> I have not
07:23:08 <johnw> https://github.com/diagrams/dual-tree
07:27:01 <epta> What is a shorthand for `{ do; f1 x; f2 x; f3 x }'?
07:27:26 <johnw> f1 x >> f2 x >> f3 x
07:27:51 <epta> Without repeating `x'
07:27:57 <johnw> mapM_ ($ x) [f1, f2, f3]
07:33:04 <johnw> or maybe even: flip runReaderT x $ do f1; f2; f3
07:34:10 <hpc> ReaderT is a newtype so you would have some wrapping noise on f1, f2, f3
07:34:11 <hpc> iirc
07:34:45 <hpc> :t ?x <$> ?f <*> ?g <*> ?h
07:34:46 <lambdabot> (?x::a2 -> a1 -> a -> b, ?f::f a2, ?g::f a1, ?h::f a, Applicative f) => f b
07:34:56 <hpc> er
07:34:58 <hpc> bah
07:35:09 <hpc> :t (?f <*> ?g <*> ?h) ?x
07:35:11 <lambdabot> (?f::t -> a1 -> a -> b, ?g::t -> a1, ?h::t -> a, ?x::t) => b
07:35:39 <`ramses> :t \x -> foldM (\_ b -> b x) undefined
07:35:40 <lambdabot> Monad m => t -> [t -> m a] -> m a
07:36:13 <johnw> @hoogle f (a -> m b) -> f a -> f (m b)
07:36:13 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
07:36:13 <lambdabot> Test.QuickCheck.Arbitrary shrinkList :: (a -> [a]) -> [a] -> [[a]]
07:36:13 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
07:36:15 <Taneb> Well the way I've designed this XML type makes making lenses for it really easy
07:36:59 <johnw> hpc: to use <*> like that for ((->) e), we'd need a kleisli variant
07:41:36 <johnw> hmm.. maybe not
07:51:09 <parcs> `ramses: undefined?
07:51:27 <`ramses> that is not used, but there is no foldM1
07:51:52 <`ramses> I would come up with something better for real usage
07:53:03 <mauke> > minBound `div` negate 1
07:53:05 <lambdabot>   Ambiguous type variable `a0' in the constraints:
07:53:05 <lambdabot>    (GHC.Enum.Bounded a0)
07:53:05 <lambdabot>  ...
07:53:10 <mauke> > minBound `div` negate 1 :: Int
07:53:12 <lambdabot>   *Exception: arithmetic overflow
07:53:27 <mauke> > maxBound + 1 :: Int
07:53:28 <lambdabot>   -9223372036854775808
07:54:29 * hackagebot JuicyPixels 3.0 - Picture loading/serialization (in png, jpeg, bitmap, radiance and gif)  http://hackage.haskell.org/package/JuicyPixels-3.0 (VincentBerthoux)
08:11:34 <wuttf> Hey I found this blogpost http://monadicheadaches.blogspot.hu/2007/11/random-numbers-where-it-all-started.html
08:11:47 <wuttf> I think this guy is spreading misinformation
08:12:28 <wuttf> "...  the State Monad has runState function. But, as I said in one of my previous post, IO has its own run function: unsafePerformIO, from Foreign module."
08:14:10 <engla> 2007 is long ago
08:14:19 <wuttf> Still on the net though
08:16:18 <mauke> hah, perl has (shitty) tutorials from 1997 on the web
08:16:20 <fmap> no way there could be misinformation on the internets
08:16:53 <elliott> But, beware! randomList is now and impure function masked as a pure function. Haskell could tricked by this masking and make the wrong thing misled by the purity assumption.
08:16:56 <elliott> So, I promised myself not to write another Monad tutorial, but I did, at last!
08:16:58 <elliott> great post
08:18:02 <preyalone> Has anyone gotten GHC to run on Windows RT?
08:26:42 <Shapeshifter> Does someone here know how many copies RWH sold?
08:28:23 <merijn> wutff: I automatically assume that any "beginner" haskell blogposts will be shitty, because they usually are. Doubly so if they're about monads or IO :\
08:28:32 <preyalone> Does Haskell support compilation to C code?
08:28:53 <srhb> preyalone: Haskell is a language, not a compiler. GHC has a C backend, I believe.
08:30:08 <`ramses> does parsec provide applicative instances for e.g. GenParser somewhere? I can't seem to find one
08:30:14 <preyalone> The C backend was deprecated :( http://www.haskell.org/ghc/docs/latest/html/users_guide/code-generators.html
08:30:43 <bgamari_> Does one need to do anything to ensure that capabilities actually exist after calling setNumCapabilities?
08:31:08 <srhb> preyalone: Well, why do you need it?
08:31:15 <bgamari_> I'm looking at an eventlog and I see that the RTS logged that it was created the capabilities
08:31:26 <bgamari_> and then moves threads to them
08:31:29 <preyalone> srhb: Interested in writing cross-platform mobile apps in Haskell.
08:31:49 <bgamari_> yet it takes over 10 seconds before any of them actually start running
08:32:10 <preyalone> srhb: Android, iOS, and Windows RT support C/C++ code, so it should be possible to write mobile apps in Haskell, compile to C, build the apps, run the apps.
08:32:59 <merijn> preyalone: The C backend was never 100% true C, I think? I think the evil mangler had to modify somestuff after compilation (but I'm not 100% sure on that)
08:33:25 <jmcarthur> merijn: the evil mangler did weird things with calling conventions and such, iirc
08:33:26 <applicative> preyalone: the C backend still exists, but is used for porting ghc to new platforms; it must be an 'unregisterd' build or something
08:33:27 <bgamari_> I find it hard to believe that this operating system scheduling latency
08:33:45 <jmcarthur> bgamari_: no, that sounds like either the fault of ghc or your program, to me
08:34:00 <elliott> preyalone: The C backend was never portable.
08:34:03 <bgamari_> jmcarthur, Yeah, it sounds like it
08:34:05 <elliott> preyalone: GHC can compile to ARM, though.
08:34:10 <bgamari_> jmcarthur, This is GHC 7.7, so it could be a regression
08:34:19 <elliott> Also, the system interfaces for all those three OSes differ anyway.
08:34:22 <jmcarthur> plausible
08:34:23 <elliott> So you won't be running the same code on all of them.
08:34:27 <preyalone> elliott: Happen to know which version of GHC includes this?
08:34:39 <elliott> Not precisely, just "fairly recent ones".
08:34:51 <preyalone> elliott: Meh, Makefile + Custom Haskell UI wrappers...
08:35:15 <elliott> You might want to ask iPwn Studios people about it, if it still even exists; they are/were working on an iPhone game in Haskell
08:35:39 <eddayyy> hey guys, I was wondering if anyone could help with a problem in haskell where i have to duplicate a lot of code
08:35:53 <eddayyy> i'm using flexible instances but I'm sure there must be a better way to do it
08:35:59 <hpaste> eddayyy pasted “FlexibleInstances” at http://hpaste.org/81019
08:36:51 <elliott> eddayyy: Move the Binary a => constraint outside of Request.
08:36:53 <elliott> Then give
08:36:58 <elliott> instance Binary a => Binary (Request a) where ...
08:37:19 <elliott> eddayyy: Also, I suggest not using "length" as a field name.
08:37:43 <cmccann> johnw: https://github.com/isomorphism/these
08:37:48 <eddayyy> elliott: wow that works :D
08:38:17 <merijn> preyalone: Specifically Cale (who is frequently in here) used to work for a company doing Haskell for iOS development, maybe he can give you some pointers
08:38:19 <elliott> I think technically you could just write "instance Binary (Request a)" as-is, but moving the constraint out is a good idea anyway.
08:38:34 <eddayyy> elliott: it didn't work when just writing it as is
08:38:47 <eddayyy> couldn't resolve Binary a
08:39:28 <preyalone> merijn: Awesome!
08:39:29 <bgamari_> jmcarthur, http://mw0.mooo.com/~ben/new-capability-latency.png
08:41:16 <bgamari_> it's very strange, I see dozens of "waking up thread N on cap M" events in a row with the same N and M
08:45:31 <eddayyy> elliott: thanks for your help :)
08:52:19 <hpaste> fmap pasted “any idea what does it want from me?” at http://hpaste.org/81021
08:52:26 <merijn> bgamari_: Is it doing blocking operations?
08:52:40 <merijn> bgamari_: MVar/Chan/TVar/file IO/whatever?
08:54:18 <bgamari_> merijn, There are STM operations being done
08:54:29 <bgamari_> but there shouldn't be that much contention
08:54:58 <bgamari_> merijn, after all of the caps have started things run pretty smoothly
08:56:44 <merijn> bgamari_: hmm, no clue then
08:58:54 <applicative> fmap, what ghc version are you using; this works fine here, it seems
08:58:58 <bgamari_> merijn, If I set the number of capabilities with +RTS -N things seem to come right up
08:59:56 <fmap> applicative: 7.6.1
09:03:08 <applicative> fmap, hm, same here.
09:03:26 <fmap> applicative: did you enable warnings? :)
09:03:48 <fmap> same behaviour here with 7.4.1 actually
09:04:31 <applicative> what, me enable warnings?
09:04:37 <applicative> yea I see it now
09:09:05 <zett_zelett> Why does ghci hang after I use `plotFunc`?
09:13:11 <applicative> because plotFunc never finishes calculating?
09:15:05 <applicative> > let plotFunc x = plotFunc x in plotFunc 1
09:15:08 <lambdabot>   mueval-core: Time limit exceeded
09:19:11 <applicative> It's one possibility anyway zett_zelett ...
09:19:38 <zett_zelett> applicative, well I get back to the prompt.
09:20:01 <hiptobecubic> this thing is incredible http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/
09:20:07 <zett_zelett> What does your line do?
09:20:26 * geekosaur wonders if this plotFunc is the one from Graphics.Gnuplot
09:20:42 <zett_zelett> I use Graphics.Gnuplot.Simple.
09:21:45 <geekosaur> so you get back the prompt.  what do you mean by "hang"?
09:22:36 <zett_zelett> I can't type anything into the prompt.
09:22:43 <edwardk> BobbyMcLiar: sadly, lenses of rank-2 types and existential types just don't work. if you work through the signature they require impredicative types and first class existentials respectively
09:22:48 <zett_zelett> If I press keys, nothing shows up.
09:23:01 <zett_zelett> I can Ctrl + C, though.
09:23:17 <zett_zelett> It gives me a new prompt line, but I can't type anything into it either.
09:24:53 <hiptobecubic> I'm always amazed when I see someone solve a problem like that
09:25:21 <hiptobecubic> It feels like wizardry really. It must take a long time before you start to see your problem in these terms
09:26:15 <zett_zelett> hiptobecubic, I don't know anything about computer science, but I'm amazed that differentiation would play a major role.
09:27:35 <zett_zelett> Oh actually, it doesn't _really_ hang.
09:27:44 <zett_zelett> It just doesn't show me, what I type in anymore.
09:28:03 <zett_zelett> That's strange.
09:28:48 <zett_zelett> So I can type in commands without what I type and press enter. When I typed them correct, they'll work.
09:28:55 <zett_zelett> +seeing
09:31:30 <vifanq> I enter equations & declarations from the /tutorial, into ghci, and errors are returned, like: "length :: [a] -> Integer" yields: Couldn't match expected type `Integer' with actual type `Int'
09:32:03 <applicative> vifanq: what did you type, exactly
09:32:16 <vifanq> if I enter "length :: [a] -> Int", then: No instance for (Show ([a0] -> Int))
09:32:35 <applicative> length does 'return' and Int (i.e. a machine number), but usually you want Integer which is the default
09:32:58 <vifanq> applicative: the line "length :: [a] -> Integer"
09:33:09 <applicative> vifanq: yes, it would 'evaluate' length, but doen't know what to show you]
09:33:13 <applicative> try typing
09:33:18 <applicative> > length [1,2,3]
09:33:20 <lambdabot>   3
09:33:38 <vifanq> ahso, so it is a build in function
09:33:55 <applicative> then we get an Int, not function from lists to Ints
09:34:07 <vifanq> the tutorial gives its definition and I tried entering the def into ghci
09:34:10 <applicative> yes, length is a prelude function
09:34:30 * hackagebot pandoc 1.10.0.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.10.0.1 (JohnMacFarlane)
09:35:06 <edwardk> hiptobecubic: that post is a large part of why i started planning with semirings and left-seminearrings, etc.
09:36:37 <applicative> vifanq: is it behaving sensibly, now?
09:38:00 <vifanq> applicative: yes. I think I need some ghci oriented tutorial, though
09:38:56 <rogers_> is mapM_ guaranteed to run actions in sequence and in the same thread?
09:38:57 <applicative> vifanq: I take it you've see 'learn you a haskell'. I does have zillions of ghci illustrations as it goes along.
09:39:51 <vifanq> applicative: lol, good sense of humor of the site :]
09:40:45 <vifanq> thanks, I will use this book
09:41:41 <applicative> you saw the web version i take it. http://learnyouahaskell.com/chapters
09:42:04 <applicative> people can explain the obscure bits here vifang
09:44:19 <vifanq> cool :]
09:44:30 <vifanq> good part from the site: "The whole thing is completely free to read online, but it's also available in print and I encourage you to buy as many copies as you can afford!"
09:50:20 <vifanq> I tried learning Haskell multiple times and the results are best to describe as "do it finally for great god" ;] Then I have worked a little on computability and recursive functions - which are equal to computable functions. Thus, can it be said, that Haskell works, because computing means pretty much <<reducing>> ?
09:52:30 <srhb> vifanq: Uuuhhh.
09:52:41 <srhb> vifanq: If you wanted to be extremely vague and imprecise and probably wrong, why not?
09:54:02 <vifanq> ok.. It just struck me that this might be the intuition to finally get along with haskell
09:54:20 <srhb> It sounds wrong to me, but whatever floats your boat.
09:54:36 <basdirks> there is no _one_ intuition that's going to bring you enlightenment
09:54:53 <mm_freak> i think for particular people there is indeed /one/ such intuition
09:55:36 <zett_zelett> What if the intuition that brings you enlightenment says that there is only one intuition?
09:56:02 <srhb> Bam! Religion invented.
09:58:32 <hpaste> “Edward O'Callaghan” pasted “xmobar icon support” at http://hpaste.org/81023
09:58:58 <edward> Hi, I am writing icon support for xmobar
09:59:25 <edward> Could someone give me a hand sorting out this scoping issue I have please?
09:59:31 * hackagebot pandoc 1.10.0.2 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.10.0.2 (JohnMacFarlane)
10:01:35 <Peaker> which cabal package was it that you could just execute to get an http file server?
10:02:09 <typoclass> edward: hello. could you copy-paste the error message you are getting? (hpaste)
10:03:51 <hpaste> “Edward O'Callaghan” pasted “xmobar icon support - errors” at http://hpaste.org/81024
10:04:04 <edward> typoclass: Sure ^
10:08:11 <typoclass> edward: thanks. that looks like an import is missing
10:09:11 <rogers_> I simetimes wish there was an implicit conversion between some various Num types
10:09:30 <edward> typoclass: ?
10:09:48 <rogers_> like Int -> Double, etc
10:09:55 <basdirks> rogers_: in order to not know what types you're working with?
10:10:11 <Mathnerd314> are there any Haskell libraries for doing Markov Chain Monte Carlo?
10:10:40 <basdirks> @hoogle Monte
10:10:40 <lambdabot> package monte-carlo
10:10:52 <rogers_> basdirks: I am dividing a lot of Ints and fromIntegral calls pretty much dominate my function
10:10:54 <basdirks> @hoogle Markov
10:10:54 <lambdabot> package markov
10:10:54 <lambdabot> package markov-chain
10:11:31 <arbn> fromIntegral is my best friend.
10:12:16 <Lethalman> arbn++
10:12:23 <basdirks> Mathnerd314: http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=markov http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=markov#hl=en&tbo=d&sclient=psy-ab&q=monte+carlo+site:hackage.haskell.org%2Fpackage&oq=monte+carlo+site:hackage.haskell.org%2Fpackage&gs_l=serp.3...11956.13684.0.13815.11.11.0.0.0.0.100.571.10j1.11.0.les%3B..0.0...1c.1.e2SGXcFI3yc&pbx=1&bav=on.2,o
10:13:20 <typoclass> edward: in the lines 60 to 70, what exactly are you doing?
10:15:13 <Lethalman> monte-carlo seems to do almost nothing...
10:15:20 <Lethalman> it's just a value,rng pair
10:15:31 <typoclass> edward: do you know lyah? it's a good textbook that teaches haskell. it's available free of charge
10:15:34 <typoclass> @where lyah
10:15:34 <lambdabot> http://www.learnyouahaskell.com/
10:15:55 <Lethalman> ah MC.Class has some good utilities
10:16:11 <mvj4_> are there any drop-in replacements for ContT to achieve different intermediate return types? I've seen index-core and index-extras, but they seem quite limited.
10:18:09 <Mathnerd314> basdirks: I don't think those are the right sort of library. It has to do inference of a chain; see http://en.wikipedia.org/wiki/Markov_chain_Monte_Carlo
10:18:29 <cmccann> mvj4_: different intermediate return types in what sense?
10:20:08 <edward> typoclass: yes, but this is not working code yet
10:20:16 <Mathnerd314> (background: I'm looking at http://projects.csail.mit.edu/church/wiki/Church and wondering how it compares to Haskell)
10:20:48 <mvj4_> cmccann: I wan't to do something like "do x <- f; g x", where f :: a, g :: b, a /= b. perhaps I should be doing this some other way..
10:21:04 <mvj4_> both are monadic with ContT (...)
10:21:29 <cmccann> mvj4_: you want to change the "r" parameter in (ContT r)?
10:21:32 <edward> typoclass: I am just trying to fix the scoping at the moment
10:21:38 <typoclass> edward: right :-) it reads like c code so far, not really like haskell
10:22:57 <edward> typoclass: thats because the X server is written in C and when you read there crappy docs you have to pretend you are writing C to even get a clue what they are on about..
10:23:38 <edward> typoclass: first I just want to hack it till it works, this is not a final solution
10:24:32 * hackagebot pandoc 1.10.0.3 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.10.0.3 (JohnMacFarlane)
10:25:45 <edward> typoclass: lines60-70 create a X graphical context and copy or whatever it does fill out the context with the pixmap
10:26:17 <rogers_> you cant even + Int and Integer :|.
10:26:21 <edward> some X server black magic I don't understand and looks horrifically old and horrible
10:26:43 <merijn> rogers_: Small price to pay
10:26:45 <edward> rogers_: they are very different types
10:26:49 <mvj4_> cmccann: yeah, I want differets r:s.
10:26:53 <mvj4_> different*
10:27:13 <typoclass> edward: what you could maybe do is write actual c code in a *.c file, and then call it from haskell via the ffi (foreign function interface). this would minimize the haskell code you have to write. i don't know if it would minimize the overall pain :-/
10:27:15 <merijn> @quote who.do.you.call
10:27:15 <edward> Int is machine, Integer is algebric I guess?
10:27:15 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
10:27:17 <rogers_> merijn: and what is the pro of such strictness? not really seeing it
10:27:44 <edward> typoclass: no, that wont be accepted upstream into xmobar
10:27:51 <typoclass> edward: here is some information http://www.haskell.org/haskellwiki/FFI_Introduction
10:28:02 <edward> typoclass: I know how to use FFI
10:28:20 <merijn> rogers_: Avoiding it would horribly complicate the Numeric interface, it's not so much an advantage here, but more a "fixing it would make a lot of other cool stuff much more difficult"
10:28:24 <typoclass> edward: Integer can be arbitrarily large, Int is limited by the machine (usually 32 or 64 bit)
10:28:31 <cmccann> mvj4_: ok. what do you want to do that needs different "r"s? generally when using ContT you want to avoid constraining the "r" type anywhere but when you use runContT.
10:28:42 <edward> typoclass: I know that, I was telling rogers_ that
10:29:05 <edward> can we get back to my actual question about scoping please?
10:29:27 <merijn> edward: Int is not exactly machine size, Int is defined as "at least" 27 bits (in practice I think it's 31 bits on 32bit and 63 bit on 64 bit architecture
10:29:52 <merijn> (In GHC, that is)
10:30:13 <monochrom> Int is machine word size, Integer is unlimited (like unlimited internet)
10:30:23 <rogers_> "fixing it would make a lot of other cool stuff much more difficult" <- what cool stuff?
10:30:40 <edward> merijn: machine is good enough to give a feeling.. anyway tell rogers_ not me..
10:31:09 <rogers_> I think that was for me anyway
10:31:45 <edward> I am asking about scoping, not type definitions nor random tutorials or completely changing my code form haskell to C O_o
10:32:01 <edward> s/from
10:32:16 <merijn> rogers_: The Num typeclass hierarchy would have to be *a lot* more complicated to support "(+) :: Num a, Num b, Num c => a -> b -> c" style addition/subtraction, I'm not sure you could do that and if you could, implementing your own Num types would become very painful and require exponentially more work
10:32:39 <Mathnerd314> edward: what does readXBM do?
10:33:08 <cmccann> merijn: pf, just encode the range of values at the type level and compute the least upper bound so that the result is the smallest numeric type that includes both argument types. what could be simpler?
10:33:32 <cmccann> type inference that works is overrated anyhow.
10:33:52 <mvj4_> cmccann: just realised that the internal function (like f >>= g) can be lifted into the state layer without any significant struggle, since continuation-stuff is not needed at that level. thanks!
10:34:09 <rogers_> merijn: I can see that. but when would you even want to implement new Num type? we have bigint, complex numbers, rationals
10:34:39 <merijn> rogers_: Vectors? Matrices?
10:34:53 <rogers_> yeah true
10:34:58 <merijn> Num instance for polynomials
10:35:03 <cmccann> mvj4_: great! obviously I was working toward either "you can avoid constraining r" or "you can't actually use ContT", just wasn't sure which yet.
10:36:55 <merijn> rogers_: Basically there's two choices, 1) let the user coerce everything to a compatible type (i.e. "Num a => a -> a -> a") or 2) force every instance/type to be coerced to the same one so you can have ("Num a, Num b, Num c => a -> b -> c")
10:36:59 <rogers_> how about having implicit conversions for built in types, with Num class remaing the same. wouldnt that be possible?
10:37:11 <merijn> rogers_: The latter is rather tricky, because to which common type do you coerce?
10:37:44 <elliott> explicit coercions often conceal bugs
10:37:46 <elliott> er
10:37:48 <elliott> implicit coercions often conceal bugs
10:37:49 <elliott> oops :)
10:38:03 <edward> Mathnerd314: this is not acutally functioning code currently. However readXBM reads a X Bitmap image and displays the pixmap it is mapped to
10:40:34 <Mathnerd314> edward: so it should be of type Display -> Drawable -> FilePath -> IO Pixmap?
10:41:09 <typoclass> edward: well, for starters, you could change line 76 to "(bitmap_width, bitmap_height, bitmap, _, _) <- readBitmapFile display window filename". you can then remove lines 60-70
10:41:20 <merijn> rogers_: Anyway, I don't have to use fromIntegral that often, so the few times I do I tend to think it's not such a big problem
10:41:52 <geekosaur> edward, trying to catch up on this, most of your errors previously pasted are Graphics.X.(...) imports missing; CInt requires Foreign.C.Typed
10:42:12 <geekosaur> er.  Foreign.C.Types --- but may also be brought in scope by the missing X11 import(s)
10:42:12 <Mathnerd314> edward: and switch/case is written case ... of in Haskell
10:42:54 <geekosaur> Graphics.X11.Xlib provides GC and should probably be considered a prerequisite import for any X11 related code
10:45:22 <vifanq> How to get "ghci>" prompt in ghci, instead of "Prelude>" ?
10:45:24 <edward> thanks!
10:45:48 <Iceland_jack> vifanq: :set prompt "ghci> "
10:46:19 <rogers_> merijn: not claiming its a big problem, but it is annoying  times.  anyway I will just have to get used to it. maybe Ill write a shorter alias for fromIntegral
10:46:54 <vifanq> Iceland_jack: ahso.. I'm trying to fix what is apparently blocking usage of ":1 scriptName", and other things from tutorial.. Is there some "mode" in ghci ?
10:47:18 <geekosaur> there is no ":1".  perhaps you mean ":l"?
10:47:32 <vifanq> yeah o<-<
10:47:50 <edward> should io come from system.io or something?
10:47:51 <geekosaur> (trained on an old manual typewriter? :)
10:48:04 <geekosaur> io is a local alias for liftIO
10:48:21 <geekosaur> xmobar probably defines it somewhere, although I'd need to poke around to see where
10:48:24 <edward> Mathnerd314: the switch/case are just comments, it does not matter.
10:48:35 <geekosaur> @index liftIO
10:48:35 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:49:11 <edward> right, maybe  Control.Monad.Reader ?
10:49:54 <edward> nope
10:50:13 <geekosaur> in the xmobar source, the XUtil or Plugins.Monitor.Common modules --- probably the former for this
10:50:14 <monochrom> Control.Monad.IO.Class
10:51:10 <monochrom> but all those other Control.Monad.* guys have it too
10:53:21 <edward> XUtil fixed it, forgot about that
10:53:23 <edward> thanks!
10:54:09 <edward> this code looks horrific
10:54:13 <edward> it is 6am however
10:57:55 <hpaste> “Edward O'Callaghan” pasted “what??” at http://hpaste.org/81026
10:58:33 <edward> geekosaur: whats all that jazz about?
10:59:38 <typoclass> edward: in haskell, function names start with a lower-case letter, types with an upper-case letter. "Pixmap" is not an okay name for a function
10:59:50 <epta> xmobar code looks horrific, indeed
10:59:51 <monochrom> I say "what??" too, but to your code, not to the error message. the error message is right. what is "Pixmap ... = ..." doing in instance code?
11:00:12 <monochrom> in other words what is "Ctor ... = ..." doing in instance code?
11:00:15 <geekosaur> yeh, that makes no sense
11:01:25 <monochrom> and "Ctor ... = ..." is called pattern binding. Example: "Just x = if True then Just 5 else Nothing"
11:01:37 <edward> typoclass: ah that should be commented out, Pixmap is not a function
11:05:03 <edward> I need sleep, now I am just doing :q in my term
11:06:07 <Mathnerd314> edward: push your code on Github somewhere so we can discuss it more
11:11:45 <edward> Mathnerd314: sure
11:11:49 <rogers_> are non-alphated function names reserved for operators? or can I have something like (~) :: a -> b ?
11:12:32 <jmcarthur> (~) in particular is reserved, but apart from special cases like that you can define your own operators
11:12:58 <monochrom> you can have (>++) :: a -> b -> c
11:13:03 <geekosaur> alphanumerics (and internal or final ') are prefix, symbols are infix
11:13:06 <rogers_> jmcarthur: note that it takes a and returns b
11:13:09 <merijn> rogers_: There's a list of "operator characters" in the report, names using those will always be operators (although nothing restricts operators to take only two arguments
11:13:17 <jmcarthur> rogers_: that has nothing to do with what i said
11:13:27 <monochrom> I think you can have (>++) :: a -> b too
11:13:29 <merijn> I'm not sure whether you can have unary operators, but I don't see why not?
11:13:31 <jmcarthur> > let (+++) x = x + 1 in (+++) 5
11:13:33 <lambdabot>   6
11:13:40 <geekosaur> but wrapping an infix in () makes it prefix (as in your declaration) and wrapping a prefix in `` makes it infix (these do not nest)
11:13:40 <monochrom> \∩/
11:13:42 <merijn> There you go, you can\
11:13:49 <rogers_> jmcarthur: right. and what you said has nothing to do with my question
11:13:55 <jmcarthur> rogers_: i just answered it by example
11:13:55 <benmachine> http://math.stackexchange.com/q/282932/29966 ← if anyone here has views on this I'd be grateful
11:14:08 <jmcarthur> rogers_: i misunderstood the question the first time
11:14:12 <merijn> > let (+) x = x - 1 in +5
11:14:13 <lambdabot>   <hint>:1:22: parse error on input `+'
11:14:17 <merijn> > let (+) x = x - 1 in 5 +
11:14:19 <lambdabot>   <hint>:1:25: parse error (possibly incorrect indentation)
11:14:38 <jmcarthur> rogers_: i was confused because whether or nothing something is an operator is independent of the number of arguments
11:14:48 <monochrom> > let (+) x = x - 1 in (x +)
11:14:49 <lambdabot>   x - 1
11:14:57 <rogers_> jmcarthur: okay
11:15:05 <jmcarthur> *whether or not
11:15:07 <monochrom> this one is supposed to be somewhat wrong
11:15:07 <merijn> rogers_: Ok, so looks like you can't have unary operators without parentheses
11:15:18 <jmcarthur> indeed
11:15:32 <rogers_> yeah just tested if you could too
11:15:44 <merijn> 2 and more is simple, though
11:16:03 <merijn> > let (+++) a b c = a + b + c in 1 +++ 2 3
11:16:04 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> a))
11:16:04 <lambdabot>    arising from the ambiguity chec...
11:16:07 <merijn> hmmm
11:16:07 <geekosaur> see also the massive PITA known as negative constants
11:16:16 <merijn> > let (+++) a b c = a + b + c in (1 +++ 2) 3
11:16:17 <lambdabot>   6
11:16:23 <monochrom> Haskell 98 etc say (x +) is (\y -> x + y). not exactly (+) x. but compilers have been doing (+) x for a long time. of course, no big deal really
11:17:02 <jmcarthur> i'm conflicted about whether this wrapper i'm creating around an existing python library should live in IO. the functionality is technically pure, but only with the assumption that the python runtime is initialized and the library is installed on the user's machine
11:17:26 <jmcarthur> i guess i could make some sort of a token that is loaded via IO and then passed to pure functions...
11:17:45 <jmcarthur> but that still makes some assumptions, like that the runtime isn't finalized
11:17:58 <monochrom> token. passing. FSM -> (a, FSM) again? :)
11:18:21 <monochrom> more seriously, I don't know
11:18:52 <monochrom> how easy is it to accidentally finalize?
11:19:20 <jmcarthur> hard, unless you also use another python library and the wrapper for it happens to finalize it
11:19:33 <jmcarthur> it's just a global state
11:19:51 <Mathnerd314> jmcarthur: you're doing haskell<->python integration? how?
11:19:58 <jmcarthur> Mathnerd314: the cpython package
11:20:38 <edward> Mathnerd314: https://github.com/victoredwardocallaghan/xmobar/commit/54d072dff7c65528d7d913df84b99406e08f5dbf
11:21:20 <edward> btw, I have some category theory notes I wrote in my github if anyone is interested. The LaTeX is all open, improvements welcome!
11:22:16 <jmcarthur> Mathnerd314: there's a pretty nice intro here https://john-millikin.com/articles/ride-the-snake/
11:23:10 <benben> does anyone have any experience of the haskell prompt exiting due to Segmentation faults?
11:23:20 <rtharper> sounds bad
11:23:27 <rtharper> did you compile it yourself?
11:23:33 <Mathnerd314> edward: thanks. I'll check it out (eventually).
11:23:40 <jmcarthur> benben: segfaults are usually due to bad FFI bindings and sometimes due to ghc bugs
11:23:55 <Mathnerd314> jmcarthur: and you agree with the first line that it's "an easy and practical approach to reusing the Python community's work"?
11:24:25 <jmcarthur> Mathnerd314: it seems pretty nice so far
11:24:34 <jmcarthur> Mathnerd314: it feels a lot like writing normal FFI code
11:24:36 <benben> it happened with defining `let fac n = product [1..n]` and then runnign `fac 100000`
11:25:05 <typoclass> jmcarthur: i've sometimes wished there was some kind of "soft IO" that indicates something is not referentially transparent, but also doesn't have side effects. like getNumberOfCpuCores or getProgName
11:25:16 <typoclass> (not sure if that makes any sense anyway =)  )
11:25:28 <benben> when loading it from a file it works fine
11:25:51 <jmcarthur> benben: maybe has something to do with libgmp
11:26:17 <jmcarthur> benben: i just tried it and it works for me
11:26:26 <jmcarthur> benben: The Glorious Glasgow Haskell Compilation System, version 7.6.1
11:26:37 <edward> must sleep!
11:26:43 <edward> Night folks
11:27:13 <benben> version 7.4.2
11:27:33 <jmcarthur> maybe it was a bug that has since been fixed
11:27:44 <hiptobecubic> riiideee the snaaakeeeeeeeeee
11:28:04 <Mathnerd314> typoclass: well, you could do it by splitting up the IO monad into "ReadIO" and "WriteIO" monads, which only do reads/writes resp.
11:28:18 <jmcarthur> Mathnerd314: actually, i'd say this is a bit nicer than writing normal FFI code to C because you don't have to deal with pointers and such
11:28:20 <typoclass> Mathnerd314: right, something along those lines
11:28:51 <jmcarthur> Mathnerd314: but on the other hand there's a runtime and dynamic loading to deal with, which is why i am unsure about whether it should be in IO of course
11:29:11 <Mathnerd314> typoclass: but then you run into the expression problem, because interfacing the two requires lots of explicit type changes
11:29:21 <benben> ok, well I'll try updating the 7.6.1
11:30:00 <Mathnerd314> typoclass: you have to stick in lots of lift* methods to change ReadIO to TwoWayIO, which Haskell doesn't make easy
11:30:16 <typoclass> Mathnerd314: sure, it's idle musings, not in any way thought out =) i don't know if that would be a good fit for the current haskell language
11:30:16 <Mathnerd314> typoclass: which is why Haskell needs subtyping!
11:31:02 <typoclass> Mathnerd314: you should duck before people start throwing things at you =)
11:31:24 <jmcarthur> man, and here i was picking up a stone
11:31:45 <Mathnerd314> jmcarthur: the Python code might have bugs, i.e. calls to launchMissiles, so I think it should always be in IO
11:31:46 <jmcarthur> err, a tomato i mean
11:31:56 <jmcarthur> Mathnerd314: haskell code can have bugs too...
11:32:08 <Mathnerd314> jmcarthur: not launchMissiles types of bugs
11:32:14 <jmcarthur> it can with unsafePerformIO
11:33:09 <Mathnerd314> jmcarthur: right, which is why if you trust the Python code you're using you can use unsafePerformIO and put it in there. But then it won't be "Safe Haskell"
11:33:41 <Mathnerd314> typoclass: actually, I think I'll open a bug for it. The stones should all be concentrated in one place :-)
11:33:58 <jmcarthur> Mathnerd314: i already have to trust a lot of code. i don't think that's the point. the point is that i don't necessarily trust the *origin* of the code, since it is loaded dynamically. i don't even trust that the code will be there
11:42:48 <Mathnerd314> jmcarthur: so... are you uncertain whether to put it in a monad? or are you uncertain of which monad to use?
11:43:21 <jmcarthur> whether to do so. in spirit it's still pure :(
11:43:53 <jmcarthur> it's okay, i'm just going to make it pure for now
11:44:22 <Mathnerd314> jmcarthur: so you perceive a penalty for writing monadic code?
11:44:59 <jmcarthur> that would be overgeneralizing
11:45:11 <jmcarthur> for this particular case i would perceive a penalty
11:46:07 <jmcarthur> because if it had been written in haskell it would be completely pure
11:46:51 <`nand`> Hmm, odd; I can't seem to import Network.MPD anymore even though libmpd is installed and ghc-pkg describe libmpd mentions Network.MPD as exposed module
11:47:00 <`nand`> what could be going on here?
11:47:13 <srhb> jmcarthur: It's a bit strange that you seem to be saying that "monadic" == impure.
11:48:36 <geekosaur> cabalized?  --> is the package providing Network.MPD listed in the *.cabal file?
11:48:52 <`nand`> geekosaur: testing in ghci
11:48:53 <geekosaur> not cabalized?  --> did you runHaskell Setup.l?hs --user ?
11:48:56 <geekosaur> oh
11:49:07 <geekosaur> multiple versions installed?
11:49:24 <`nand`> oh, there appears to have been one in ~/.cabal; I wonder where that came from
11:49:28 <typoclass> `nand`: stuff is hidden? either because cabal is hiding it or because ghc-pkg hide
11:49:28 <`nand`> never mind :)
11:49:41 <Mathnerd314> jmcarthur: how is alt-stdlib coming along, now that GHC has ConstraintKinds etc.?
11:50:00 <`nand`> oh, now I remember; I was testing libmpd patches and forgot to unregister the local version after I was done
11:50:51 <Tehnix> having a bit of trouble on OS X installing hinotify. I get the following https://gist.github.com/4581226
11:51:16 <luite> OS X doesn't have inotify
11:51:35 <Tehnix> hmm, well, that would explain it
11:52:22 <luite> try fsnotify, a cross platform lib that uses inotify on linux, fsevents on SO X
11:53:16 <Tehnix> thanks, but it was another package i was installing that needed it, and i had just narrowed it down to this. But, it's no big deal :)
11:53:25 <Tehnix> (the package was keter)
11:56:07 <jmcarthur> srhb: i am talking specifically about the IO monad, for one.
11:56:38 <jmcarthur> srhb: the IO monad is just a way to express things that have side effects in a pure way, but that doesn't mean you don't have to think about side effects when you're using IO
11:57:29 <jmcarthur> Mathnerd314: it's not moving right now, but yes, it is definitely enabled now :)
11:58:08 <geekosaur> Tehnix, ypu'll have to yell at snoyman to use something portable like fsnotify :) inotify is a linux kernel feature, not available on other systems
11:58:44 <geekosaur> I think the rest of the dependencies should work on *bsd and most unixlikes
11:59:11 <applicative> Tehnix: http://hackage.haskell.org/package/hfsevents-0.1.3
12:00:11 <Tehnix> geekosaur: yeah :/ for now, I'll settle on just toying around on my VPS although it would have been nicer playing with it locally...
12:01:08 <maq> hi
12:01:43 <applicative> hi maq
12:04:03 <jmcarthur> Mathnerd314: my tastes have changed since alt-stdlib was started, and the project is basically dead anyway. if anything it might be worth just starting over
12:04:50 <Mathnerd314> jmcarthur: what, you don't think writing everything using category theory is a worthwhile goal?
12:06:02 <Mathnerd314> although maybe that wasn't the actual goal of alt-stdlib
12:06:29 <jmcarthur> no, that was definitely not the goal
12:06:50 <ciaranm> right. some things are more naturally expressed using plain old algebra.
12:06:56 <jmcarthur> the goal, to me, was the be able to write more generic code and more safely
12:07:02 <jmcarthur> *was to be able to
12:07:17 <jmcarthur> without sacrificing convenience
12:07:46 <jmcarthur> and with better defaults (e.g. if i started over i think Text would be the default String type)
12:09:25 <jmcarthur> Mathnerd314: i think i sense a bit of negativity from you today. this is unusual. am i just misreading?
12:11:36 * cmccann has long since concluded that some fundamental issues with the standard libraries can't be fixed properly without several language extensions (possibly including some that don't exist yet)
12:12:12 <Phil___> Hi, I'm a total beginner and all I've done is install the latest Haskell Platform. When I launch GHCi I get an error "Could not find module 'Text.RegexOR' Perhaps you meant Text.Regex (from regex-compat-0.95.1)"
12:12:46 <Phil___> Does anyone know where this error comes from and how to resolve it? As all I've done is install the platform and launch the interpreter I'm a bit confused as to why something isn't working
12:13:43 <applicative> Text.RegexOR  ??
12:14:18 <Eduard_Munteanu> Phil___: how do you launch ghci?
12:14:38 <applicative> Phil___: what platform are you on>  what ghc version did you install?
12:15:27 <Phil___> I installed whichever is the current Haskell Platform so I have whichever version of ghc comes with that (I'll just check). I'm launching it from the start menu in windows
12:15:28 <applicative> its as if it were loading a file that said 'import Text.RegexOR'
12:15:57 * geekosaur thinks there's a bogus .ghci file somewhere (or whatever the windows version calls it)
12:15:57 <applicative> so all you do is type ghci or ghci.exe in the command window, and this happens?
12:16:42 <Phil___> windows-> "ghci", yes
12:16:52 <applicative> thats what I was wondering, an odd .ghci file, forget what it;s called in windows
12:17:00 <Phil___> With the same issue if launched from the console
12:17:28 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-dot-files.html
12:17:43 <applicative> hah
12:17:45 <Phil___> The platform is 2012.4.0.0, ghc version 7.4.2 if that matters
12:17:45 <applicative> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/ghci-dot-files.html
12:18:12 <applicative> thats the going standard
12:18:52 <applicative> C:/Documents and Settings/PHIL___/Application Data/ghc/ghci.conf  <- does something like this exist?
12:19:16 <Eduard_Munteanu> applicative: unix habits :)
12:20:06 <applicative> oh, Phil___ does ghci -ignore-dot-ghci  do any better
12:20:28 <Phil___> applicative: yes!
12:20:33 <Phil___> To the latter question
12:20:37 <Phil___> Still looking for the .conf file!
12:21:07 <geekosaur> it could be a filename .ghci or a filename ghci.conf depending on its location
12:21:16 <applicative> it looks like it is a bad ghci.conf as geekosaur predicted.  maybe the Platform puts this stuff somewhere else
12:21:35 <Mathnerd314> jmcarthur: I'm just annoyed with open-source fragmentation. Everything would be so much easier if everyone could settle on one language, one compiler, one OS, etc.
12:22:10 <geekosaur> try using dir /s to find it?  (IIRC that's how you do recorsive file search on windows; dir /s ghci.conf)
12:22:36 <Mathnerd314> jmcarthur: but the tools for doing that just aren't there; scaling to millions of LOC is an unsolved problem
12:22:51 <jmcarthur> Mathnerd314: i think that without this redundancy we would be much farther behind technologically
12:23:05 <Phil___> Ok, thanks all. I'll have a look and let you know when I eventually find it :-)
12:23:42 <jmcarthur> if everybody used the same tools, evolution would be the only way to make progress, but sometimes revolution is just a better way to go about it
12:23:54 <Mathnerd314> jmcarthur: that's what all the free-market people say, is that competition leads to higher levels of innovation
12:23:54 <Phil___> Ah, here it is
12:24:07 <jmcarthur> competition isn't even what i'm talking about
12:24:11 <Phil___> Including "import Text.RegexPR"
12:24:18 <jmcarthur> imagine we are all using java and nothing else
12:24:23 <jmcarthur> how do we move forward?
12:24:28 <Phil___> So I'll just change that to import Text.Regex
12:24:35 <Phil___> Thanks
12:24:43 <saeidw> Phil___, where did you end up finding it
12:24:44 <jmcarthur> every change to our world would require backward compatibility
12:24:56 <jmcarthur> moving to -blah
12:26:22 <Phil___> So it's my fault after all :-)
12:26:22 <simpson> So I'm thinking about making a DSL for talking about 2D game sprites. Has anybody worked on this before? I already know about free monads; is there anything else Haskell-specific that I should read up on?
12:27:22 <cmccann> simpson: talking about them how? movement, animation, collision detection, ...?
12:28:09 <simpson> cmccann: Yeah. I'm kind of frustrated with how much work has to go into things like collision detection, and I keep seeing patterns in my walls of spaghetti that might be easier to deal with if I could just talk about sprites in a more abstract way.
12:28:24 <simpson> Like, what kind of collision is it? How does the collision affect the two sprites?
12:28:43 <cmccann> simpson: that was intended as a "which ones" question, but I'll take "yeah" as meaning "all of the above" :P
12:28:48 <simpson> I recognize that part of this relies on a physics engine, but I feel that a serious rigid-body engine is orthogonal.
12:28:57 <simpson> cmccann: And yes, all of it. :3
12:29:20 <cmccann> collision detection is a huge worm-filled canning factory
12:29:43 <simpson> I've seen free-game on Hackage and been inspired by the technique, but I want to do something more robust and flexible.
12:29:46 <cmccann> it's tricky to consider any part independently without forcing awkwardness or inefficiency into other places when you use it
12:30:12 <g3orge> -/quit
12:30:32 <cmccann> for example, consider the problem of checking a bunch of sprites for collisions in an actual game
12:30:46 <cmccann> you don't want to check every possible combination, generally
12:30:55 <simpson> No, you'd use a spatial hash. No biggie.
12:31:08 <simpson> And yeah, you probably only care about a couple specific sprites.
12:31:22 <cmccann> some collisions you don't care about, some never happen (sprites don't move), &c.
12:31:31 <simpson> Right.
12:32:03 <cmccann> also, most spatial data structures are designed for static-ish data and need tweaking to perform well with updates
12:32:38 <simpson> Yeah. I've read through Chipmunk and seen all this.
12:32:39 <cmccann> you also have a lot of information you could use for narrowing down possible collisions, by consider velocity and time and whatnot. collision checks are relatively expensive if you want more than crude bounding boxes.
12:33:02 <cmccann> if you want immutable data structures, which are nice in haskell, things certainly don't get easier
12:33:23 <simpson> I'm also thinking about the general declaration and handling of sprites. I have a couple data types already, but I keep doubting their usefulness because of the way they're laid out.
12:33:24 <cmccann> these are just a few of the reasons why I have like three or four scrapped attempts at a haskell sprite library lying around
12:33:26 <vifanq> does Haskell makes it easier to write programs that compute? I mean like Fortran is supposed to. Or like maybe matlab environment, where it is easy to make matrices and so
12:33:51 <cmccann> vifanq: if you want to express computations easily, sure. if you want to crunch lots of numbers fast, no, stick with FORTRAN.
12:33:57 <applicative> @faq does Haskell makes it easier to write programs that compute?
12:33:57 <lambdabot> The answer is: Yes! Haskell can do that.
12:34:39 <vifanq> applicative: is this really answer?
12:34:44 <cmccann> simpson: there's also the issue of how time is handled, for a general-purpose sprite library you want to be somewhat agnostic about the time step used
12:34:51 <applicative> are there any bindings to Fortran things via the FFI ? Is that possible, or maybe you just go via C
12:35:00 <cmccann> or ideally, whether there's a discrete time step at all, to permit FRP-ish stuff
12:35:13 <simpson> cmccann: It always comes back to FRP, doesn't it. :3
12:35:15 <cmccann> applicative: how do you think hmatrix works? :P
12:35:33 <applicative> how does it work? via C?
12:35:38 <simpson> cmccann: Let's say that I'm not writing this for posterity, but I'm just writing it to make *my* games better.
12:35:47 <simpson> applicative: Probably yes.
12:35:48 <cmccann> simpson: it doesn't have to. but if you want to write a broadly-useful sprite library, it would be nice to support FRP as well as other approaches
12:36:04 <magistr> give me a nice books to learn lambda calculus
12:36:06 <simpson> cmccann: I already gave up on that. I just want to write a library that is useful for more than one style of game.
12:36:08 <vifanq> @faq does Haskell makes it easier to write programs that launch space rockets?
12:36:08 <lambdabot> The answer is: Yes! Haskell can do that.
12:36:41 <cmccann> simpson: you still want to be agnostic about time step as much as possible.
12:36:42 <simpson> Like, just being able to write a 2D platformer and a 2D shmup with the same library would be amazing. Right now the only libraries like that are *too* general and require a lot of wheel reinvention.
12:36:57 <simpson> cmccann: Already got that part done.
12:37:03 <ClaudiusMaximus> cmccann: one project of mine i computed next time of all collisions, then used the first collision as the time step and incrementally updated the list of all next-collisions, but then it was just circles and no external forces..
12:37:12 <vifanq> cmccann: how about numerical methods.. where you have some loop, and steps h, and so on
12:37:27 <ClaudiusMaximus> cmccann: i mean the time step each step was til the next collision
12:37:33 <cmccann> ClaudiusMaximus: I've toyed with a few ideas for things like that... never settled on anything I liked though.
12:38:06 <magistr> give me a books to learn a lambda calculus
12:38:28 <zett_zelett> wiki.
12:38:39 <magistr> what?
12:38:54 <cmccann> vifanq: again, that stuff is probably easy to write, but getting it to be very fast is hard.
12:39:06 <cmccann> it'll be "fast enough" for simple stuff though.
12:39:07 <saeidw> magistr, try going through: http://plato.stanford.edu/entries/lambda-calculus/
12:39:25 <elliott> magistr: you'd have to ask a math scientiest.
12:40:00 <magistr> thanks
12:40:37 <cmccann> simpson: I've found that it makes things massively more pleasant if movement speed and animation frame duration and whatnot can be specified in seconds or whatnot
12:40:50 <cmccann> and let the display routines and whatever else figure out how to make that work
12:41:37 <simpson> cmccann: Yeah, I've already done that. I have data Animation a = Animation { sprite :: Sprite a, velocity :: V2 a } in units per second.
12:41:44 <simpson> And a couple helpers to move them.
12:41:53 <cmccann> simpson: another thing that often comes up is kinda-cyclic dependencies between sprites and game logic
12:42:24 <simpson> cmccann: Right. I'm trying to figure out how to isolate those.
12:42:29 <cmccann> creating new entities based on the position of another or having one sprite tied to another somehow or whatnot
12:44:05 <simpson> And also I'm kind of concerned about how I'm holding the sprites. I've got them directly stuck into my global state. In other languages I'd use a hashmap of names to sprites.
12:44:20 <simpson> But having an M.Map String Sprite a feels really *really* wrong.
12:44:41 <cmccann> it's also tricky to figure out where to draw lines when stuff is reused--e.g., the same image in several animations, the same animation in different sets of animation, the same animation group used for multiple kinds of game entity, the same kind of entity at multiple locations...
12:45:42 <cmccann> in some cases a string dictionary probably is the right way
12:46:12 <cmccann> simpson: anyway, I'm just kind of rattling off everything I can remember causing me headaches in previous attempts
12:46:22 <simpson> cmccann: Ah, yeah.
12:46:24 <magistr> elliott, in what channel I must ask this question?
12:47:54 <simpson> cmccann: Also I notice that I'm getting really gnarly with my composition of data types.
12:48:27 <cmccann> simpson: for a concrete example, consider this: a boss enemy in a shmup with multiple pieces that move semi-independently (and can be destroyed individually), with pieces flashing red when damaged without interrupting their current animation, spawning various smaller enemies
12:48:35 <simpson> Like, a sprite has a shape, right? And a box? Maybe a box. It's textured or colored. Or maybe shaded, but probably colored. Maybe there's an alpha? There aren't particles attached. Or are there?
12:48:43 <vifanq> cmccann: matlab might be not as fast too
12:49:03 <simpson> cmccann: Right, so you want hierarchal sprites.
12:49:13 <simpson> And you want to be able to overlay materials.
12:49:23 <cmccann> simpson: possibly! unless that complicates things so much that it's nicer to have special cases for stuff like that.
12:49:34 <simpson> I mean, this eventually leads to Sprites having an IO () to draw themselves.
12:49:37 <cmccann> in which case it'd be nice to reuse as much as possible of the "basic" stuff.
12:49:48 * simpson notices that free-game has a core action that is just IO ()
12:49:56 <cmccann> and of course that has its own problems
12:50:12 <cmccann> because drawing is opaque to your high-level rendering code
12:50:19 <simpson> Yes, it should be.
12:50:34 <simpson> Except when textures get involved, because of the cost of rebinding a texture.
12:51:44 <funclearner> question on subtle(or not so) difference between sub-classing and sub-typing
12:51:47 <vifanq> cmccann: so it's more about hmm, ease of expressing algorithms, which implies ease of verification. When I code algorithm in C/C++ it is way away from mathematical form, and very severe for verification
12:52:00 <cmccann> vifanq: yes, that's a lot of it
12:52:06 <funclearner> class (Eq a) => Num a
12:52:10 <funclearner> where ..
12:52:16 <cmccann> vifanq: but it's not something I've done much so I can't say a lot more about it
12:52:47 <cmccann> simpson: the problem with completely opaque rendering is if you want to control a viewport of some sort without the sprites being aware of it
12:52:51 <funclearner> does it mean that , all types which satisfy Num are subtypes
12:53:00 <funclearner> of all types which satisfy, Eq ?
12:53:11 <rogers_> I have setPosition function that accepts object to move and coordinates. would it be more common to accept object we are moving as first argument or coordinates?
12:53:15 <vifanq> cmccann: cool
12:53:15 <cmccann> or other global transformations or whatnot
12:53:42 <cmccann> rogers_: what's the result type?
12:53:54 <rogers_> cmccann: IO ()
12:53:59 <simpson> cmccann: So maybe I should have a datatype for how the material should be applied, a datatype for the shape and coordinates, and a datatype for how it should collide with other entities.
12:54:07 <funclearner> how do you differentiate between in subtyping and subclassing in func languages (I think haskell doesn't have subtyping,right?)
12:54:12 <simpson> cmccann: Well, that's what GL's matrices are for.
12:54:26 <simpson> cmccann: And eventually the sprites could draw to VBOs which you transform on the CPU or with a vert shader.
12:54:31 <cmccann> rogers_: in that case it doesn't matter too much, but I'd put the object first
12:55:20 <rogers_> cmccann: would it matter if I returned something else, say new version od the object? curious why
12:55:23 <cmccann> simpson: yeah, if you're using GL that avoids a variety of rendering issues
12:55:49 <cmccann> rogers_: if it's a pure function "modifying" something, coordinates first means partial application gives you something of type "Thing -> Thing"
12:55:55 <cmccann> which you can then compose to do multiple "modifications"
12:56:00 <tieTYT2> i'm using leskah.  Is there a window for an interpreter inside this ide?
12:56:15 <rogers_> cmccann: ah
12:56:55 <cmccann> rogers_: e.g. look at Data.Map and the argument orders there
12:58:32 <cmccann> simpson: anyway, the end of the story is that adding enough flexibility everywhere to do everything makes a mess, but for any restriction you assume I can probably come up with a plausible example of something nice it would interfere with
12:58:37 <rogers_> cmccann: that makes sense. how about this in my example?  findObject ... >>= setPosition (0,0). AFAIK its slighly more clumsy to do this if we accept object first?
12:58:43 <simpson> cmccann: Well, thanks for your input.
12:58:46 <cmccann> simpson: if there's a "right" answer here I don't know what it is.
12:59:27 <cmccann> rogers_: if you expect to use it that way then put the object last, sure.
12:59:35 * hackagebot hakyll 4.1.2.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.1.2.0 (JasperVanDerJeugt)
12:59:41 <funclearner> I mean if type a satifies Num , it also satisfies Eq , but my question is, for typeclasses is there a notion of 'is-a-Relation ship?"
12:59:53 <cmccann> rogers_: putting the object first means partial application lets you work with things that are acting on different objects generically
13:00:37 <rogers_> cmccann: I dont even know how to write that if object comes second. using flip didnt do it
13:00:38 <cmccann> simpson: as I said, this is all stuff I've made a few attempts at. never was satisfied with the results, as you can probably guess.
13:00:56 <rogers_> if object comes first even
13:01:53 <cmccann> rogers_: flip ought to work, but like I said you can use whichever order you expect to be most convenient for your code
13:02:16 <cmccann> in fact, you SHOULD use the order that's more convenient for your code.
13:03:26 <cmccann> simpson: and I'd certainly be interested to see what you come up with, these are wheels I'm tired of reinventing.
13:11:18 <jmcarthur> simpson: feel free to lurk in #haskell-game. it's a pretty quiet channel, but with occasional bursts of activity
13:14:27 <magistr> jmcarthur, in what channel I can ask about lambda calculus?
13:14:53 <jmcarthur> magistr: maybe there is a computer science channel?
13:15:05 <jmcarthur> magistr: this one isn't the most awful one, but it's not *completely* relevant
13:15:16 <magistr> jmcarthur, ok
13:20:49 <tieTYT2> i'm using cygwin.  When I'm in ghci shoudl pressing the up arrow should me the last line I typed?  If there's a way to turn this on what should I google?  "ghci cygwin history" isn't finding anything
13:21:13 <Iceland_jack> tieTYT2: you can try C-p
13:21:24 <saeidw> tieTYT2, if you're using haskell platform on windows, the regular ghci works fine with up/down arrows
13:21:39 <tieTYT2> saeidw: I am using it
13:21:54 <tieTYT2> but I'm starting ghci from the cygwin console.  Is that a mistake?
13:22:01 <saeidw> try running ghci outside a cygwin window, see if that works
13:22:18 <tieTYT2> hm, yeah it works correctly there
13:22:22 <saeidw> I know cygwin will set some weird terminal stuff that might confuse ghci
13:23:00 <mm_freak> is "strong lax monoidal functor" just a complicated way to say "Applicative"?
13:23:03 <saeidw> tieTYT2, try this from your cygwin console: "start ghci"
13:23:43 <tieTYT2> start doesn't exist.  I think that's a cmd.exe command
13:23:56 <jmcarthur> mm_freak: yes
13:24:00 <mm_freak> thanks
13:24:42 <mm_freak> now when edwardk talks about strong lax semimonoidal functors i know what he's talking about =)
13:24:45 <saeidw> tieTYT2, yeah, I was hoping it would spawn a cmd.exe window with a properly set up ghci
13:26:06 <frerich_> Hm, is there a common naming scheme for MVars/TVars? I've been using a scheme which uses 'x' for some value and 'xMV' for the MVar which holds the value, but I wonder whether there's maybe some common convention (like using x' for something which holds the new value for x or 'go' for a recursive helper).
13:26:26 <mm_freak> frerich_: i use x and xVar
13:26:31 <mm_freak> sometimes xRef
13:27:05 <mm_freak> frerich_: the common convention is to be clear =)
13:27:12 <mm_freak> x and xVar is pretty clear =)
13:27:35 <frerich_> xVar would've been better than xMV as I just noticed when porting from MVar to Var… :-}
13:28:30 <tieTYT2> ooh, there's a winghci command
13:28:37 <tieTYT2> i kind of prefer this to cygwin anyway
13:29:10 <mm_freak> frerich_: xVar is better when your editor supports camelcase for word jumping
13:29:26 <mm_freak> xMV is a bit awkward there
13:37:54 <diracdelta> Hi, I'm trying to specify a data structure (for the disk format). I would like to do somethig like data Format = { diskDriveLocation :: Byte2, directoryName :: Byte16, directoryStart :: Byte2}
13:38:26 <diracdelta> So far, the only way that I can think of defining Byte2, and Byte 16 is by doing something like data Byte2 = Byte Byte
13:38:46 <diracdelta> and data Byte16 = Byte Byte  Byte Byte  Byte Byte  Byte Byte Byte Byte  Byte Byte  Byte Byte  Byte Byte
13:38:56 * Maxdamantus just implemented fixed-sized ints like that in another language.
13:39:00 <jmcarthur> diracdelta: there's Data.Word.Word16 for Byte16
13:39:19 <shachaf> Word16 would be Byte2. :-)
13:39:20 <`nand`> I use ‘m’ for an MVar
13:39:20 <diracdelta> Maxdamantus: what language?
13:39:24 <`nand`> and ‘t’ for a TVar
13:39:35 <geekosaur> you might also want to look at the "binary" package
13:39:43 <Maxdamantus> A language I'm implementing for someone at university.
13:40:00 <shachaf> There's unfortunately no nice way in Haskell to express constraints like that in the type system and still use an efficient representation (that I know of).
13:40:03 <diracdelta> jmcarthur: Okay. I can use that, is the underlying implementation what I described? Or does it do something smarter?
13:40:08 <jmcarthur> shachaf: ah, i misread
13:40:30 <shachaf> You can make a type which is represented as an array or bytestring or something, and use a smart constructor to make sure it stays the right size.
13:40:30 <diracdelta> geekosaur: will do. I take it it's a package for working with file formats?
13:40:44 <Maxdamantus> It had a base N1 type and a composition mechanism to produce another one twice as long as a given one.
13:41:04 <Maxdamantus> So N2 = C(N1), N4 = C(N2), N8 = C(N4)
13:41:05 <shachaf> You can also use {-# UNPACK #-} which would probably make it much more efficient (but still horribly in-).
13:41:18 <geekosaur> might be more correct to say it's a package for building things that work with file formats
13:41:20 <jmcarthur> diracdelta: for Byte2 you can use Word16, which is just a 16 bit unsigned integer. for Byte16, you could perhaps use Word128 from  http://hackage.haskell.org/package/data-dword
13:41:35 <`nand`> the closest you can get is smart constructors; you could use a phantom type to put a modulo on every operation
13:41:54 <jmcarthur> diracdelta: however, that package i just linked doesn't provide integration with the binary or cereal packages for you
13:41:59 * Maxdamantus hasn't figured out how to implement division yet though.
13:43:08 <jmcarthur> diracdelta: actually, now that i look at the names of your fields, i see that Byte16 doesn't need to be numeric
13:43:14 <jmcarthur> diracdelta: so i would just use ByteString there
13:43:24 <jmcarthur> err
13:43:32 <jmcarthur> that might not work. it needs to be static length
13:43:36 <Maxdamantus> er, it wasn't like diracdelta's Byte16.
13:43:48 <Maxdamantus> Ah, these are bytes, not bits.
13:44:59 <monochrom> 16 bytes would have to be [Word8] or Vector Word8 or something like that
13:45:39 <monochrom> of course, a record with 16 fields is also ok :)
13:46:15 <monochrom> bytestring is also good
13:46:43 <monochrom> I think "it has to be 16 at the type level" is overrated
13:47:02 <monochrom> perhaps s/I think/IMO/
13:48:09 <monochrom> if you're implementing a Θ(n) algorithm, why don't you also enforce that at the type level?
13:48:29 <ciaranm> because complexity proofs are a bitch
13:48:31 <monochrom> as opposed to the pretty weak and uninformative "it terminates" in agda and coq
13:48:37 <diracdelta> Hm. Thanks everyone. :)
13:49:26 <monochrom> complexity proof for e.g. reverse is not a bitch. in fact, the termination proof already contains the complexity proof. you're just throwing away information.
13:50:04 <monochrom> almost always, a termination proof already contains a loose upper bound complexity proof
13:50:12 <ciaranm> the proof that 2 + 2 = 4 is easy too. that doesn't mean all proofs in algebra are easy.
13:50:23 <shachaf> monochrom: Even C has a type for this!
13:51:02 <monochrom> ok, let's talk about some proofs rather than all proofs
13:51:48 <monochrom> for reverse, why don't you enforce Θ(n) at the type level? this proof is not a bitch
13:52:42 <ciaranm> there's not much point in adding a mechanism for something like that if it's only useful in obvious cases
13:56:42 <monochrom> then my opinion is that "these arrays have size 16" at the type level is also only useful in obvious cases
13:57:13 <monochrom> for haskell
13:59:08 <monochrom> haskell type system, even with extensions, is so restricted that only trivial, obvious proofs of "has size 16" is supported. whenver you can convince the compiler of that statement, it is also true that you can just eyeball the code and find it obvious
13:59:17 <vermeille> Hello guys !
13:59:35 <vermeille> Did someone install Haste, the Haskell to Javascript compiler ?
13:59:37 <monochrom> exactly in the same situation as "it is easy to eyeball reverse's code and see it's Θ(n)"
14:00:32 <funclearner> guys, I want to learn about typed-type level programming
14:00:39 <funclearner> any pointers?
14:00:43 <Maxdamantus> Eh .. people have implemented more general arithmetic in the type system.
14:01:00 <monochrom> now if you move to agda and coq, you can no longer say "don't do hard proofs", because there you very well intend to do hard proofs. complexity proofs are not harder than other proofs.
14:01:09 <funclearner> specifically, the evil-cool 'kind polymorphism'
14:01:21 <Maxdamantus> So you can say "has size that is the sum of the size of these two things"
14:02:34 <leggo> Warning: No explicit method nor default method for `foo'
14:02:44 <leggo> how come this is just a warning and not error?
14:02:47 <Tehnix> A question (if anyone knows): If I compile a yesod app (or in general, a Haskell app) on one OS, would there be a possibility that it wouldn't work on another OS? Or does the compiler take care of it all?
14:03:03 <Maxdamantus> http://www.ict.kth.se/forsyde/files/tutorial/tutorial.html#FSVec
14:03:49 <monochrom> Maxdamantus, my point is not what statement is proved, but how trivial the proof is
14:05:07 <Eduard_Munteanu> Tehnix: depends what you mean by the first and second OS.
14:05:09 <monochrom> and I talk about how trivial the proof is, because I am refuting "if you are only writing trivial proofs, don't bother"
14:06:30 <Eduard_Munteanu> Tehnix: generally, it won't work unless you take extra measures.
14:06:36 <Tehnix> Eduard_Munteanu: In my current case, I would be compiling the app on OS X and trying to deploy it on Debian/Linux. For some reason, it just now occured to me that that might be an issue.
14:07:18 <Tehnix> I don't know why on earth I did not think about it earlier though -.- Always looking for some more complex problem when it in fact was rather simple ^_^
14:07:19 <Choko_> Tehnix: you compile it to native code so it will not work
14:08:14 <vermeille> No one for Haste installation ?
14:08:16 <Tehnix> But, in the case of compiling on a Debian machine and deploying on another Debian machine, that would most likely work, no?
14:08:26 <applicative> Tehnix: It is less likely you'll have trouble going os x -> linux unless you are using one of the few os x specific libraries
14:08:30 <Eduard_Munteanu> Tehnix: you could get a Debian vm. Then you could build a statically-linked version of that app, which should work fine.
14:08:36 <Choko_> that should work Tehnix
14:08:53 <Tehnix> Eduard_Munteanu: My thought also
14:09:09 <Eduard_Munteanu> Tehnix: the only way to guarantee it works is to do static linking, I'd say
14:09:24 <cmccann> unless the machines are different architectures or have incompatible versions of other stuff installed or whatnot
14:09:45 <Eduard_Munteanu> GHC statically links Haskell libs by default, but not system libs.
14:10:06 <Eduard_Munteanu> So you'll have to tinker with linker options (and have static libs installed).
14:10:09 <cmccann> yeah, and I think a few system libs can cause problems with unexpected versions? not sure.
14:10:13 <Choko_> Eduard_Munteanu: if you just ensure they run the same debian version you should be fine.
14:10:40 <Eduard_Munteanu> cmccann: I'm assuming the .so number of the installed lib could change
14:10:49 <cmccann> as long as both debian machines are on the same kind of hardware and have roughly the same set of packages around it should be fine
14:12:01 <Tehnix> hmmm, well, they won't be on the same hardware at all. Imma try my way forward. Would have loved to compile and deploy from my laptop though :/
14:12:27 <Eduard_Munteanu> Tehnix: get a VM of the target architecture.
14:12:50 <Eduard_Munteanu> (Since cross-compiling is rather out of the question with GHC)
14:13:10 <Eduard_Munteanu> Tehnix: but what does same hardware mean?
14:13:13 <Choko_> or compile it on the target platform. cabal packages are really easy to make :)
14:13:21 <cmccann> well, when I say "same kind of hardware" I mean something like "both are x86"
14:13:21 <Eduard_Munteanu> (for some reason I thought of PPC)
14:13:42 <cmccann> like, if you build something on an x86 debian machine it's not going to run on the debian install you put on your toaster oven
14:13:47 <Eduard_Munteanu> Yeah, not sure he got that.
14:14:10 * applicative_ hadn't known there were debian toaster ovens
14:14:25 <cmccann> (more plausibly, 32bit vs. 64bit could be an issue)
14:14:35 <Tehnix> Eduard_Munteanu: Afaik my server is on AMD and locally I'm on Intel. Havne't really toyed much with this exact issue, so am not quite aware of the impact of that yet.
14:15:33 <Eduard_Munteanu> Tehnix: another question: do you get the same Debian install dvd/whatever on both?
14:15:55 <Eduard_Munteanu> (another way of phrasing the same question, actually)
14:16:14 <Tehnix> Eduard_Munteanu: No. But I'll prolly be able to match the OS version anyways
14:16:54 <Tehnix> ... unless I'm misunderstanding the question :|
14:16:59 <cmccann> Tehnix: doesn't sound like you have any obvious problems, might be easiest to just compile a simple test program and see if it runs
14:17:13 <Tehnix> cmccann: yeah
14:17:49 <Tehnix> will have to wait till i get on a better net though :/ need to dl Debian first before I can install it in a VM ^_^
14:21:59 <monochrom> VMs are nice
14:22:11 <shachaf> they are so easy
14:22:21 <Eduard_Munteanu> Poor man's cross-compiler.
14:23:07 <Eduard_Munteanu> shachaf: what's this "so easy" thing, some recent meme? :)
14:24:37 * hackagebot mongoDB 1.3.2 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.3.2 (FedorGogolev)
14:27:18 <monochrom> it's more often in the form "I love ___. it's so easy"
14:32:09 <basdirks> shachaf's themesong: http://www.youtube.com/watch?v=1tBeqxKKseA
14:32:40 <`nand`> I thought it was “I love ____. ____s are so easy”
14:32:59 <shachaf> Hmm, too many drums.
14:33:02 <basdirks> no, it's "It's so easy to fall in love"
14:33:14 <basdirks> shachaf mixed up the words
14:38:34 <cmccann> i love drums
14:38:35 <cmccann> they are so easy
14:39:22 <vermeille> Does anyone knows a way to execute Haskell code in a browser ? I heard about Haste and some javascript interpreters
14:39:38 <vermeille> What works ?
14:39:44 <johnw> Fay
14:39:46 <cmccann> there are various imperfect ways to compile Haskell into JS
14:39:47 <akoada> hi I have a problem, basicly if I pass a drawingarea as an argument, then the drawings won't show up
14:40:02 <vermeille> johnw: Fay isn't only a subset of Haskell ?
14:40:06 <cmccann> fay is probably the easiest to get up and running with but only supports a limited subset of Haskell
14:40:08 <akoada> can you give me some advices aroud it?
14:40:09 <johnw> GHCJS
14:40:47 <vermeille> I'm trying to install it, but it's painful
14:41:04 <johnw> then, Fay :)
14:41:15 <johnw> but i'm assuming you already have a bunch of Haskell code that you want to run in the browser?
14:41:17 <vermeille> Can we emit LLVM code with ghc 7.6.1 ?
14:41:23 <vermeille> Absolutely :)
14:41:27 <johnw> yeah, then emscripten
14:41:28 <Eduard_Munteanu> akoada: what is that about? Gtk2Hs?
14:41:36 <vermeille> That was my thoughts
14:41:51 <akoada> yes, gtk2hs
14:42:03 <johnw> yeah, you can use -fllvm, and then pass an option down to the compiler to -S -emit-llvm
14:42:17 <vermeille> Perfect !
14:42:21 <vermeille> Gogo emscripten :D
14:42:30 <vermeille> It will be awesome on my blog :D
14:43:03 <Eduard_Munteanu> akoada: you're also have to rephrase that question... pass a DrawingArea to what?
14:43:14 <Eduard_Munteanu> akoada: not really, let's talk here.
14:43:49 <akoada> basicly I have a main monad, this is for seting up the window and other, and there is created a canvas
14:44:02 <johnw> but I guess what you really want is bitcode, not IR
14:44:10 <IngCr3at1on> I feel like this should be really easy and I'm just missing something : I need to parse a string by grabbing the front of it up to a specific character.
14:44:24 <johnw> but can you always llc the IR, as a test to make sure it's "standalone"
14:44:26 <akoada> I have drawable functions and if I pass the canvas them to draw on, the drawing wont show up
14:44:33 <cmccann> > takeWhile (/= 'd') "abcdefg"
14:44:35 <lambdabot>   "abc"
14:45:09 <IngCr3at1on> you would think that would have shown up somewhere in my searching; thanks a ton
14:45:18 <cmccann> > break (== 'd') "abcdefg"
14:45:20 <lambdabot>   ("abc","defg")
14:45:24 <cmccann> that's also useful
14:45:30 <cmccann> if you want to pull off chunks progressively
14:45:32 <akoada> Eduard_Munteanu: and if I copy-paste some examples to the main, the it works
14:45:45 <cmccann> IngCr3at1on: see also dropWhile &c.
14:46:02 <IngCr3at1on> yeah, dropWhile I knew but for some reason was missing the others
14:46:13 <IngCr3at1on> just pulled them up via hoogle though thanks again
14:46:25 <johnw> > partition (/= 'd') "abcdefg"
14:46:26 <lambdabot>   ("abcefg","d")
14:47:25 <cmccann> johnw: btw, dunno if you saw when I mentioned it earlier, but I think you were asking about https://github.com/isomorphism/these ?
14:47:38 <johnw> yes, i saw the note in my client, thanks
14:47:47 <johnw> now i just need to get him to cabal upload it :)
14:48:08 * cmccann doesn't have a hackage account
14:48:16 <johnw> want me to upload it for you?
14:48:33 <CodeDmitry> Hello
14:48:59 <johnw> cmccann: i get a build error with GHC 7.4.2
14:49:02 <Eduard_Munteanu> CodeDmitry: hi
14:49:05 <CodeDmitry> Suppose I am required to display a message exactly n times, how would one go around this?
14:49:07 <johnw> https://gist.github.com/4582342
14:49:17 <Eduard_Munteanu> :t replicateM
14:49:17 <cmccann> johnw: yeah, it probably needs some tidying up and the dependencies are probably goofed up
14:49:18 <lambdabot> Monad m => Int -> m a -> m [a]
14:49:31 <Eduard_Munteanu> :t replicateM_
14:49:32 <lambdabot> Monad m => Int -> m a -> m ()
14:49:38 <johnw> i wouldn't mind being your release maintainer for it, if that's what you prefer
14:50:39 <Eduard_Munteanu> :t replicate
14:50:40 <lambdabot> Int -> a -> [a]
14:50:48 <applicative_> hello CodeDmitry
14:50:56 <CodeDmitry> Eduard, :t replicate gives " Int a => a -> [a]
14:50:57 <Eduard_Munteanu> CodeDmitry: the above ^ should help
14:50:58 <cmccann> johnw: you are more than welcome to put as much effort into it as you want to :P
14:51:07 <CodeDmitry> suppose I want to say "Hello World" exactly 3 times
14:51:16 <CodeDmitry> including the "\n"
14:51:18 <cmccann> I should probably fix that error though. not sure why my GHC didn't complain.
14:51:24 <CodeDmitry> How would I go around doing so?
14:51:45 <ion> > replicate 3 "Hello World\n"
14:51:46 <lambdabot>   ["Hello World\n","Hello World\n","Hello World\n"]
14:51:53 <Eduard_Munteanu> CodeDmitry: make '\n' part of your string, or replicateM_ the putStrLn action
14:52:12 <CodeDmitry> that gives me a list of strings, does that mean I have to map foreach over it?
14:52:36 <Eduard_Munteanu> > concat (replicate 3 "Hello World\n")
14:52:38 <lambdabot>   "Hello World\nHello World\nHello World\n"
14:52:51 <ion> mapM_ putStrLn (replicate 3 "Hello world")
14:53:04 <ion> replicateM_ 3 (putStrLn "Hello world")
14:53:48 <ion> (putStr . unlines . replicate 3) "Hello world"
14:54:01 <CodeDmitry> i guess that works, although i'd prefer not having an "\n" in it
14:54:04 <johnw> cmccann: it's a typo looks like
14:54:06 <johnw> w instead of m
14:54:10 <CodeDmitry> thanks though
14:54:15 <cmccann> no, it's a copy+paste failure
14:54:22 <CodeDmitry> I want to add \n only when printing
14:54:23 <Eduard_Munteanu> CodeDmitry: see what ion said
14:54:26 <cmccann> from the WriterT instances
14:54:37 <cmccann> I was really sick of writing instances at that point
14:54:39 <CodeDmitry> ah
14:55:00 <ion> > (unlines . replicate 3) "Hello world"
14:55:02 <lambdabot>   "Hello world\nHello world\nHello world\n"
14:55:10 <cmccann> johnw: if you feel like helping giving it a quick look over for any other problems would be nice
14:55:18 <johnw> sure
14:55:34 <johnw> ok, I fixed the code
14:55:36 <johnw> now builds fine
14:55:48 <johnw> do you want to give me commit bit on github?
14:55:51 <johnw> or should I pull request you?
14:57:03 <applicative> > (vcat . replicate 3 . text) "Hello world"
14:57:05 <lambdabot>   Hello world
14:57:05 <lambdabot>  Hello world
14:57:05 <lambdabot>  Hello world
14:57:09 <cmccann> johnw: pull request is fine
14:57:26 <Eduard_Munteanu> johnw: grr, you coming from CVS? :P
14:57:53 <Eduard_Munteanu> Generally there's only one commiter for a Git repo.
14:58:06 <johnw> huh?
14:58:48 <Eduard_Munteanu> I thought you asked for commit rights.
14:59:05 <johnw> i did; edwardk usually gives them to me, so I thought I could talk other people into it too ;)
14:59:12 <johnw> cmccann: pull request sent
14:59:33 <cmccann> well the primary issue is that I'd have to figure out how to do that on github
14:59:42 <cmccann> whereas I've handled pull requests before :P
14:59:51 <CodeDmitry> This is tricky >.>
14:59:55 <Eduard_Munteanu> You probably have to add his ssh key as well?
15:00:04 <johnw> Settings, Collaborators, "jwiegley", Add :)
15:00:15 <cmccann> johnw: hm actually those constraints just need to be removed
15:00:40 * Eduard_Munteanu is mostly used to repo.or.cz / kernel.org and that sort of stuff
15:01:01 <Eduard_Munteanu> (I still think it's way nicer than github's interface)
15:01:45 <Eduard_Munteanu> Makes quite a difference for the shortlog for example.
15:01:53 <elliott> github handles the ssh keys
15:01:55 <cmccann> johnw: I was sloppy in copy and pasting parts of the instances for WriterT, that's the only reason that was there
15:02:28 <cmccann> elliott, you should think of some more instances for Bicrosswalk one of these days
15:03:05 <shachaf> cmccann: Does it have any instances?
15:03:07 <elliott> cmccann: unfortunately it is too perfect an abstraction to be useful.
15:03:13 <cmccann> shachaf: yes, two!
15:03:16 <cmccann> Either and These
15:03:58 <Tehnix> Anyone know what "ExitFailure 9" in cabal means? (or would you need more output?)
15:04:12 <cmccann> @remember elliott cmccann: unfortunately it is too perfect an abstraction to be useful.
15:04:12 <lambdabot> I will never forget.
15:04:41 <elliott> Tehnix: would need more output
15:04:52 <fmap> Tehnix: looks like SIGKILL
15:05:05 <CodeDmitry> My guess would be that cabal has a list of error codes to help diagnose failures, although microsoft proven this method of diagnostics not very user friendly
15:05:31 * geekosaur has rarely found the exit codes from cabal to be useful on any platform
15:05:37 * Eduard_Munteanu would've guessed it's a plain return code
15:05:59 <geekosaur> Eduard_Munteanu, it might be, but if there's a shell in between then it could in fact be a mapped signal
15:06:14 <Eduard_Munteanu> You can't really react to a SIGKILL... maybe if it's a child process, dunno.
15:06:15 <CodeDmitry> plain return code tends to be 0, non 0 return codes are usually there for outdated method of diagnostics
15:06:31 <hpaste> Tehnix pasted “cabal install yesod fail” at http://hpaste.org/81036
15:06:51 <Tehnix> ^ the output
15:06:54 <CodeDmitry> g2g
15:07:16 <Tehnix> my debian install has really been messing with me when using cabal :/
15:07:23 <Eduard_Munteanu> CodeDmitry: bash uses return codes quite extensively
15:07:43 <Eduard_Munteanu> But yeah, you normally only distinguish zero and non-zero.
15:09:00 <cmccann> johnw: anyway the re-exports of the monad stuff are a little wonky, I should fix those as well
15:09:11 <cmccann> not that I expect anyone else to ever use it but oh well
15:09:13 <johnw> fix and i will upload 0.3
15:09:30 <johnw> edwardk was mentioning a use for it yesterday
15:09:40 <johnw> but it's hard to use what's not hackage :)
15:09:47 * cmccann also wonders if these dependencies make sense
15:09:52 <johnw> i got a 500 error trying to upload it, odd
15:10:01 <johnw> ah, it worked
15:11:10 <cmccann> johnw: a use for These? or for the monad transformer based on it? it's the latter I don't expect anyone to bother with.
15:11:20 <johnw> for These
15:11:21 <johnw> ah, ok
15:12:16 * applicative wonders why Tehnix 's install crashes after saying 'World file is already up to date.'
15:13:41 <Tehnix> applicative: I coduln't really find anything in the output that gave any insight into what the problem is :/
15:15:26 <oio> Im not used to windows could someone tell how to add or check enviroment variables
15:15:34 <oio>      CABAL_DIR: C:\Users\XXX\AppData\Roaming\cabal (Windows XP: C:\Documents and Settings\XXX\Application Data\cabal, or for all Windows versions: %APPDATA%\cabal)     GHC_VERSION: 7.0.3 (for our convenience)     WXC_VERSION: 0.90.0.2     WXWIN: C:\wxWidgets-2.9.3     WXCFG: gcc_dll\mswu     PATH: (add these) %WXWIN%\lib\gcc_dll;%WXWIN%;%CABAL_DIR%\wxc-%WXC_VERSION%\%GHC_VERSION%
15:15:57 <Tehnix> could it be that it runs out of memory? (http://haskell.1045720.n5.nabble.com/HipmunkPlayground-compile-error-td4340391.html)
15:16:11 <Tehnix> ^ was concerning my own problem
15:17:36 <NemesisD> i'm running something in the StateT monad, but i have some code that does: doStuffWithStateT = E.catch actionNeedingState otherActionNeedingState, but catch deals with IO, not my state monad. what should i do?
15:18:23 <monochrom> there is monad-control for that
15:18:28 <NemesisD> in particular, my state holds a session id, when it gets a certain error, it needs to update its session id and try again
15:19:33 <CodeDmitry> back
15:19:38 * hackagebot these 0.2 - An either-or-both data type, with corresponding hybrid error/writer monad transformer.  http://hackage.haskell.org/package/these-0.2 (JohnWiegley)
15:20:33 <NemesisD> oof, the types in monad-control are really hard to follow
15:21:31 <CodeDmitry> (putStr . unlines . replicate 3) "Hello world!" is kinda hard to follow >.>, especially the replicate 3
15:21:58 <fmap> NemesisD: you probably want lifted-base, it's based on monad-control and easier to use
15:22:16 <CodeDmitry> putStr(unlines(replicate 3 "Hello, world!")) feels more honest
15:22:45 <monochrom> lifted-base should be more direct
15:23:09 <cmccann> elliott, do you remember why these has a dependency on semigroupoids? was it just for the sake of making the instance list for These longer?
15:23:25 <NemesisD> so I want Control.Exception.Lifted's catch?
15:23:28 <elliott> cmccann: yes I think so
15:23:40 <cmccann> elliott, oh, but bifunctors depends on semigroupoids anyway
15:23:40 <ion> codedmitry: That’s just because of your previous habits from certain other languages. You’ll get used to it quickly.
15:23:42 <elliott> cmccann: semigroupoids is a good dependency though!
15:24:05 <cmccann> yeah, just wanted to make sure these dependencies made some sense
15:24:12 <CodeDmitry> ion, im trying to, but the idea of storing partial function with one argument, but not the second, seems strange
15:24:28 <CodeDmitry> by seems strange, I mean makes no sense
15:24:32 <cmccann> anyway, Bifunctor is absolutely worthwhile so semigroupoids gets a free pass anyway
15:24:38 * hackagebot hquery 0.1.0.0 - A query language for transforming HTML5  http://hackage.haskell.org/package/hquery-0.1.0.0 (TychoAndersen)
15:25:18 <monochrom> yeah, Control.Exception.Lifted, catch and try etc
15:26:01 <monochrom> StateT IO is a ready-made instance of the necessary classes. should be immediately applicable
15:26:09 <ion> codedmitry: A benefit of the former is that you can separate the function into “foo = putStr . unlines . replicate 3”. You can’t separate “putStr(unlines(replicate 3”.
15:26:30 <cmccann> elliott, there's also a dependency on comonad but I don't think that's useful for these
15:26:35 <CodeDmitry> you're right ian, but "Replicate 3" is not a full function
15:26:37 <cmccann> er, transitive dependency
15:27:04 <elliott> cmccann: These is a Comonad if its last type argument is Default!!!!! probably?
15:27:06 <leggo> CodeDmitry it is. all haskell functions take one argument
15:27:07 <CodeDmitry> replicate requires 2 arguments, and while I know there are go-arounds, the go-arounds are very difficult to comprehend
15:27:12 <elliott> duplicate :: These a b c -> These a b (These a b c)
15:27:16 * monochrom knows. "full function" means "f(x)", like how mathematicians say "the function sin(x)"
15:27:25 <cmccann> elliott, suggesting instances of Default is not even funny
15:27:29 <CodeDmitry> leggo you're right, but thinking that way really complicates your problem for anybody who wants to make sense of it
15:27:37 <elliott> cmccann: yes. clearly make it Default instead.
15:27:38 <elliott> er.
15:27:40 <elliott> cmccann: yes. clearly make it Monoid instead.
15:27:49 <elliott> that sounds complicated so you know it's theoretically sound
15:27:57 <ion> codedmitry: Think replicate(3)("foo") in a language you have used previously.
15:28:13 <CodeDmitry> The reason I'm learning haskell is to learn to express problems in a more natural ways, so that when I implement them in C or C++, I know what i'm doing makes sense
15:28:21 <jmcarthur> CodeDmitry: what do you mean "replicate 3" is not a full function? it *is* a function
15:28:26 <jmcarthur> :t replicate 3
15:28:27 <johnw> like replicate3 = std::bind(replicate, 3, _1);
15:28:27 <lambdabot> a -> [a]
15:28:29 <ion> codedmitry: With that kind of a definition of replicate you can easily do “foo = replicate(3); bar = foo("foo")”.
15:28:30 <leggo> CodeDmitry anyway, do you find `map (^2) [0..10]' strange as well? we are partially applying a function there too
15:28:52 <CodeDmitry> hmm
15:29:15 <johnw> it's also like saying (\x -> replicate 3 x)
15:29:22 <CodeDmitry> ill try breaking it down into functions and see how i do...
15:29:29 <johnw> replicate 3 returns a function that takes one argument
15:29:38 <johnw> and replicate 3 "foo" returns a non-function value
15:29:54 <CodeDmitry> ah
15:29:56 <johnw> it helps when you think of functions as first-class values, and not as a subspecies
15:30:18 <jmcarthur> replicate 3 "foo"  ==  (replicate 3) "foo"
15:30:19 <CodeDmitry> thanks for all your help guys =]
15:30:22 <leggo> :t replicate 3
15:30:24 <lambdabot> a -> [a]
15:33:23 <CodeDmitry> ugh it doesnt work
15:33:29 <CodeDmitry> f x = putStr x
15:33:33 <CodeDmitry> g x = unlines x
15:33:39 <CodeDmitry> h x = replicate 3 x
15:33:43 <CodeDmitry> main = f((f . g . h) "Hello, World!")
15:33:50 <johnw> write some type signatures
15:33:52 <CodeDmitry> why doesnt it work
15:33:54 <johnw> that should help make it all clear
15:34:04 <ion> The same reason putStr (putStr "foo") doesn’t work.
15:34:07 <johnw> you are mixing IO functions with pure functions
15:34:14 <mauke> all functions are pure
15:34:23 <johnw> i mean, monadic functions with non-monadic functions
15:34:31 <mauke> all functions are monadic
15:34:42 <cmccann> mixing functions with other functions that have types that don't match
15:34:50 <johnw> you are mixing a -> b functions with a -> m b functions
15:35:02 <mauke> johnw: b can unify with m b'
15:35:13 <ion> codedmitry: Drop the extra “f”.
15:35:25 <johnw> you are mixing functions whose types do not match
15:35:30 <mauke> no
15:35:35 <mauke> it's not about mixing functions
15:35:42 <CodeDmitry> good point
15:35:44 <johnw> you are composing incompatible functions?
15:36:03 <mauke> no, the problem is the outer 'f'. no composition is involved
15:36:14 <johnw> ah
15:36:21 <CodeDmitry> well it compiled... now lets run it
15:36:29 <CodeDmitry> interpreted*
15:36:35 <CodeDmitry> it worked
15:36:37 <CodeDmitry> :|
15:36:38 <mauke> it's trying to apply a function to an argument of an incompatible type
15:36:43 <johnw> which formulation worked, CodeDmitry?
15:36:48 <ion> codedmitry: You can also write: f = putStr; g = unlines; h = replicate 3
15:36:52 <monochrom> the one that type-checks
15:36:56 <johnw> mauke: thanks
15:37:05 <jmcarthur> CodeDmitry: f = putStr; g = unlines; h = replicate 3; main = (f . g . h) "Hello, World!"
15:37:06 <CodeDmitry> ion, I wasnt sure I could >.> thanks
15:37:12 <johnw> #haskell is like a whetstone upon which I refine my Haskell vocabulary
15:37:27 <CodeDmitry> actually nvm
15:37:28 <ion> codedmitry: In fact, hlint would have suggested that change. I recommend running hlint against .hs files.
15:37:34 <CodeDmitry> without arguments it makes no sense to me
15:37:40 <johnw> hlint is a good learning tool too
15:37:49 <johnw> it constantly tells me that take 1 = head :)
15:38:01 <monochrom> haha
15:38:03 <jmcarthur> CodeDmitry: functions are just values. that's a key aspect of haskell that you will need to get used to
15:38:16 <ion> codedmitry: replicate = \n -> \x -> something with n and x
15:38:19 <CodeDmitry> jm I know but the idea of keeping f = replicate 3 gives me a headache
15:38:21 <jmcarthur> johnw: but that's wrong! :(
15:38:24 <leggo> but take 1 isn't head :)
15:38:26 <ion> codedmitry: replicate 3 = \x -> something with 3 and x
15:38:31 <CodeDmitry> f x = replicate 3 x makes sense to me
15:38:33 <ion> codedmitry: replicate 3 "foo" = something with 3 and "foo"
15:38:34 <johnw> :t head
15:38:35 <lambdabot> [a] -> a
15:38:36 <johnw> :t (take 1)
15:38:37 <lambdabot> [a] -> [a]
15:38:40 <johnw> sigh
15:38:48 <jmcarthur> johnw: different behavior, too
15:38:51 <jmcarthur> > take 1 []
15:38:51 <ion> codedmitry: replicate :: Int -> String -> [String]
15:38:52 <lambdabot>   []
15:38:54 <jmcarthur> > head []
15:38:56 <lambdabot>   *Exception: Prelude.head: empty list
15:38:58 <mauke> (tail isn't drop 1 either)
15:38:59 <ion> coedmitry: replicate 3 :: String -> [String]
15:39:06 <ion> codedmitry: replicate 3 "foo" :: [String]
15:39:08 <johnw> something I do a lot of is the same as head, cant' remember now
15:39:38 <mauke> head == head . take 1 :-)
15:39:45 <jmcarthur> > foldr const undefined [1,2,3]
15:39:46 <lambdabot>   1
15:39:46 <CodeDmitry> I kinda go by a rule "if I can't explain how it works, I can't use it", its a strange rule that is frowned upon by many, but f = replicate 3 kinda falls into that rule
15:39:49 <jmcarthur> > foldr const undefined []
15:39:50 <lambdabot>   *Exception: Prelude.undefined
15:40:12 <johnw> it tells me that x == [] is null x
15:40:16 <mauke> CodeDmitry: if you don't understand how that works, then you don't understand 'replicate 3 x' either
15:40:29 <jmcarthur> johnw: actually, that's wrong too, but in a better way
15:40:31 <mzero> CodeDmitry: let's break it down a little
15:40:38 <jmcarthur> johnw: oh wait, no, nevermind me
15:40:47 <CodeDmitry> not in terms of haskellspeak, but in terms of imperative explanation, replicate(3, x) is somewhat simple
15:40:54 <mzero> because once you get this... your mind will pop in a funny/good way
15:40:56 <jmcarthur> johnw: i was thinking length x == 0
15:41:04 <mauke> CodeDmitry: but 'replicate 3 x' means '(replicate 3) x', not 'replicate (3, x)'
15:41:28 <cmccann> imperative explanations are not good explanations of replicate
15:41:29 <jmcarthur> CodeDmitry: in imperative speak, replicate 3 x == replicate(3)(x)
15:41:34 <mzero> so, let's start wtih lambdas, are you comfortable with those, CodeDmitry ?
15:41:41 <mauke> * not actually imperative
15:41:44 <CodeDmitry> no i am not
15:41:45 <jmcarthur> (right)
15:41:48 <mzero> aha
15:41:52 <mzero> let's look at this then
15:42:00 <mauke> > (\x -> x + 1) 2
15:42:01 <lambdabot>   3
15:42:04 <mzero> fizzle = \x -> x + 3
15:42:10 <johnw> CodeDmitry: are you familiar with lambdas in C++?
15:42:12 <CodeDmitry> most imperative programmers do not understand lambdas, maybe the next c++ standard will change that, but i doubt it
15:42:12 <mauke> don't start with names :-(
15:42:21 <CodeDmitry> No, I am not
15:42:26 <johnw> [](int x) { return x + 1; }
15:42:29 <jmcarthur> C# has had lambdas forever
15:42:34 <johnw> it's a kind of "anonymous function"
15:42:43 <jmcarthur> C++ lambdas are terrible
15:42:47 <mzero> mauke: I think not trying to hit CodeDmitry with it all head on is a better approach
15:42:51 <jmcarthur> they aren't even real closures
15:42:59 <monochrom> "f(x)(y)" is functional notation too, Landin used it all the time
15:43:01 <mzero> okay - so scrap C++ that is a red herring
15:43:02 <ciaranm> c++ lambdas are extremely useful and aren't lambdas because lambdas would have overhead
15:43:08 <CodeDmitry> all c++ features are terrible, but if used properly they can make better code
15:43:24 <mauke> mzero: I think it is
15:43:24 <monochrom> I think Milner used to all the time too in type inference papers
15:43:25 <CodeDmitry> thats why I am very careful when I use c++
15:43:25 <ciaranm> c++ is terrible, but not being terrible isn't always an option
15:43:43 <jmcarthur> c++ is terrible for very well-defined reasons
15:43:53 <CodeDmitry> c++ is the most central programming language imho, writing good code is it is impossible unless you define your own standard
15:44:03 <jmcarthur> "central"?
15:44:06 <monochrom> ok, why are we still arguing over c++
15:44:10 <CodeDmitry> eg, it supports so many ways of solving problems, most of them are wrong
15:44:16 <mzero> I realize you do from your somewhat "zen master whack in the head" comments.... but I teach a different way
15:44:22 <CodeDmitry> thats part of the reason im learning haskell
15:44:39 <mzero> well, then let's get to it
15:44:51 <t7> @quote monoid
15:44:51 <lambdabot> kmc: says: (): worst monoid ever
15:45:04 <jmcarthur> no! it's a great monoid!
15:45:04 <mzero> > let fizzle = \x -> x + 3  in fizzle 9
15:45:05 <lambdabot>   12
15:45:11 <mzero> Is that clear, CodeDmitry
15:45:14 <mauke> mzero: it looks like you're trying to build down from existing knowledge, "unlearning" bits along the way
15:45:26 <leggo> ciaranm in what way are C++ lambdas not lambdas?
15:45:28 <mauke> I think it's easier to start from scratch, taking tiny steps upwards
15:45:34 <CodeDmitry> not at all, but it makes some sense
15:45:43 <ciaranm> leggo: c++ lambdas are actually structs
15:45:44 <jmcarthur> leggo: they are "lambdas" but not closures
15:45:45 <CodeDmitry> I mean, i understand that it works, but I wouldnt be able to explain it
15:46:06 <mzero> I'm trying to work though the misconception by re-adapting it -  which works better with many learners
15:46:08 <jmcarthur> or they are closures if you explicitly tell it how to be structured...
15:46:16 <johnw> leggo: they are compiler-shorthand for a compiler-named class with member variables named after the captured locals, and an operator()
15:46:18 <mzero> okay, CodeDmitry
15:46:21 <mzero> look at
15:46:31 <mzero> > let fizzle x = x + 3 in fizzle 9
15:46:32 <lambdabot>   12
15:46:43 <t7> you have a problem so you decide to use haskell, now you have a morphism in the category of problems. (or something)
15:46:45 <mzero> Is that clear?
15:46:48 <johnw> (and appropriate constructors)
15:46:57 <CodeDmitry> what does "in fizzle 9" mean
15:47:02 <mzero> AH
15:47:04 <leggo> sort of. I haven't really used lambdas in C++
15:47:08 <monochrom> if you cannot explain "replicate 3" and "map f" etc, your ability will be very limited. I'm fine with not using magic. I'm not fine with staying in the "cannot explain" state forever.
15:47:35 <mzero> That is just a way for me to define a name, then use it here in lambda bot   (though let is a valid Haskell construction)
15:47:38 <mauke> CodeDmitry: 'let VARIABLES in BODY'
15:47:47 <mauke> it defines local names for use in an expression
15:48:01 <leggo> :t replicate
15:48:02 <lambdabot> Int -> a -> [a]
15:48:03 <leggo> :t replicate 3
15:48:04 <lambdabot> a -> [a]
15:48:16 <leggo> does that help explaining what happens, CodeDmitry?
15:48:22 <mauke> leggo: unlikely
15:48:23 <jmcarthur> > let x = 5 in x + x
15:48:24 <lambdabot>   10
15:48:35 <mauke> > let pi = "four" in pi
15:48:36 <lambdabot>   "four"
15:48:37 <mzero> so it means   "define this stuff while running this other thing"
15:49:04 <CodeDmitry> >.> i still don't get "in" >.>
15:49:11 <johnw> when I was first learning Haskell, people showing me type signatures as explanation was rarely edifying
15:49:11 <mzero> but back to fizzle  ---- what I want you to look at is the two definitions of fizzle:     fizzle x = x + 3     and     fizzle = \x -> x + 3
15:49:18 <mauke> CodeDmitry: 'in' is not a thing. 'let ... in ...' is
15:49:20 <monochrom> "in" is part of the syntax of "let ... in ..."
15:49:21 <jmcarthur> CodeDmitry: "in" is just a part of "let" syntax
15:49:26 <fragamus> @hoogle Maybe a -> Maybe a -> Maybe a
15:49:27 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
15:49:27 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
15:49:27 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
15:49:30 <CodeDmitry> ah
15:49:49 <monochrom> "in" is punctuation. discuss.
15:50:06 <jmcarthur> CodeDmitry: "in" separates the "bindings" from the "body"
15:50:21 <CodeDmitry> so "let x = 9" is the same as "let x = 9 in x"?
15:50:22 <jmcarthur> no
15:50:22 <mauke> CodeDmitry: no
15:50:29 <geekosaur> somehow I knew that was coming
15:50:29 <Zearen> Hello, so I have a rather disturbing bug that has me at a loss:
15:50:29 <jmcarthur> CodeDmitry: the former is not finished
15:50:29 <geekosaur> the form of "let" you have apparently seen before is specific to "do" syntax
15:50:29 <`nand`> “let x = 9” is not a valid expression
15:50:37 <mzero> no, "let x = 9" (without the in) is part of the "do" syntatic sugar.... and we aren't there yet!
15:50:42 <`nand`> (I hope I am using the term expression correctly here)
15:50:43 <CodeDmitry> strange, it worked in ghci
15:50:45 <geekosaur> @undo do { let x = 9; return $ x + 5 }
15:50:51 <lambdabot>  Parse error at "}" (column 32)
15:50:51 <monochrom> ghci is special
15:51:14 <mauke> CodeDmitry: that's because ghci pretends to be an interactive 'do' block
15:51:15 <applicative> Zearen: yes?
15:51:16 <johnw> yeah, don't let ghci fool you, it may be better to write this stuff in a real code file and compile it
15:51:16 <CodeDmitry> >.> my head hurts more now
15:51:41 <monochrom> I love inconsistency. it is so crazy
15:51:42 <mauke> wtf
15:51:42 <Zearen> After importing Control.Monad.Cont, ghc complains that the data constructor `Cont' is not found.
15:51:49 <mauke> CodeDmitry: have you never seen local variables before?
15:51:53 <pyry`> johnw: heh, this is often my problem, yet i guess coming from python, i'm used to being able to run things in an interpreter on and off
15:52:04 <pyry`> er, cli
15:52:07 <mauke> Zearen: yes, there is no such thing
15:52:10 <CodeDmitry> I have, I think, but I declare them in a rather strange way
15:52:12 <johnw> pyry`: i live in ghci, i just don't write my code there; I only call it from there
15:52:15 <applicative> Zearen: yes, it isn't a data constructor anymore
15:52:27 <Zearen> Oh, great.
15:52:38 <pyry`> johnw: i'd be curious what tips you have for making that process more efficient
15:52:41 <applicative> Zearen: the constructor is ContT  Cont is a type synonym
15:52:45 <monochrom> Cont is gone. use cont. lowercase
15:52:46 <leggo> how come 'let' doesn't need 'in'  in a do block by the way?
15:52:53 <Zearen> So let's say I'm reparing legacy code, is there a work around....
15:52:56 <geekosaur> Zearen, you may be working from an older document; all the standalone monads are now transformers over Identity.  for most things "cont" will work for "Cont"
15:52:57 <Zearen> Ah, aso
15:53:11 <CodeDmitry> nvm, i always use a do block
15:53:16 <`nand`> leggo: it's a syntax form specific to a do block
15:53:18 <applicative> Zearen: rigtht, like monochrom says, if you lower case it you have a 'smart constrcutor' that does what Cont did in tutorials
15:53:33 <johnw> pyry`: Emacs is what makes it efficient for me
15:54:04 <monochrom> Similarly, change "State (\s -> (s,0))" to "state (\s -> (s,0))"
15:54:05 <mauke> leggo: 'do { let STUFF; ... }' desugars to 'let STUFF in do { ... }'
15:54:12 <applicative> Zearen: all the monad/monad transformer libraries went through the same change after an epic battle of the gods that I am sorry to say I missed  ...
15:54:24 <hpaste> mzero pasted “simple lambdas” at http://hpaste.org/81037
15:54:27 <CodeDmitry> is there a way to hide everyone who joins and leaves the chat
15:54:38 * hackagebot linear 0.9 - Linear Algebra  http://hackage.haskell.org/package/linear-0.9 (EdwardKmett)
15:54:40 <monochrom> the Peace Treaty Accord of Vienna 2008 :)
15:54:45 <pyry`> johnw: ahh, gotcha. i use vim, but i assume there are some similar packages between the two that make it work better. i suppose i should invest some time in finding things to paste code into ghci or something
15:55:01 <mauke> CodeDmitry: I don't know how it works in webchat
15:55:11 <ijp> CodeDmitry: depends on the client
15:55:11 <`nand`> how large is your attic?
15:55:11 <mauke> it's pretty easy in most "normal" irc clients
15:55:12 <CodeDmitry> its really hard to read lol
15:55:13 <applicative> Zearen: so you will find exactly the same with e.g. State -- use state as a (psuedo- or 'smart'-) constructor, since the real constructor is StateT
15:55:17 <mzero> CodeDmitry: don't always use a do block --- that way lies madness!
15:55:17 <johnw> pyry`: i rely upon four things to make my Haskell development go quicker: ghci-integration (C-c C-l to reload the current file in ghci); flycheck+hdevtools for instant indication of syntax errors in my code; compilation-mode so I can run cabal build&& cabal test and jump to errors; and a locally installed Hoogle for really fast lookups within a broader range of packages than the standard Hoogle allows for
15:55:38 <CodeDmitry> I tried setting up quite a few irc clients ,they all failed connecting to haskell, i'm probably doing it wrong
15:55:53 <CodeDmitry> oddly, my android irc works fine
15:55:58 <Zearen> applicative: Dutifully noted
15:56:08 <mauke> CodeDmitry: what do you mean, "connecting to haskell"?
15:56:13 <mauke> you'd connect to freenode
15:56:15 <Zearen> And that worked, so thanks all :)
15:56:25 <CodeDmitry> it failed to connect to #haskell on freenode :\
15:56:36 <pyry`> johnw: mm, cool! i'll look around and see what i can find that's vimmy. i can probably use my pain points in learning haskell as an excuse to improve my overall coding experience
15:56:36 <mauke> you don't connect to channels, you join them
15:56:40 <CodeDmitry> i can try again but idk which irc client to use anymore
15:56:54 <monochrom> what do you care how other people connect
15:57:02 <mauke> monochrom: who?
15:57:15 <CodeDmitry> connect/join are pretty much the same ideas :\
15:57:21 <mauke> CodeDmitry: no, they're not
15:57:27 <monochrom> join freenode and concat to #haskell :)
15:57:33 <mauke> hah
15:57:43 <johnw> wow, this conversation about partial application has really gone over a lot of territory :)
15:57:57 <monochrom> because I am bored
15:58:06 <CodeDmitry> back to the issue, which irc client to use
15:58:06 --- mode: ChanServ set +o mauke
15:58:07 --- mode: mauke set +b amathew*!*@*
15:58:22 <mauke> that should cut down on at least some of the spam
15:58:59 <mauke> CodeDmitry: depends on your OS
15:59:04 <CodeDmitry> Windows 7
15:59:27 <monochrom> then manatee may be out of the question
15:59:33 <mauke> I don't really know any windows clients. xchat?
16:00:00 <Maxdamantus> (SilverX is a free build of XChat for Windows)
16:00:01 <`nand`> weechat and irssi should run on windows, afaik
16:00:07 --- mode: mauke set -o mauke
16:00:09 <CodeDmitry> I'd use Ubuntu but I it's a bit late for that now
16:00:17 <monochrom> mirc, xchat, ychat (which is xchat, different builder), there are others
16:00:27 <CodeDmitry> I prefer Ubuntu over Windows 7, but in some cases I need to use Windows
16:00:42 <mauke> well, there's always chatzilla if you're using firefox
16:00:44 <monochrom> also, nothing wrong with using webchat
16:00:48 <`nand`> xchat trolls windows users; but third party builds exist
16:00:52 <mauke> monochrom: how do you hide joins/parts in webchat?
16:01:00 <monochrom> I don't know
16:01:06 <CodeDmitry> getting mirc
16:01:06 <mauke> and that is the problem
16:01:32 <parcs> mauke: in the settings panel
16:02:01 <CodeDmitry> mirc says its an evaluation copy
16:02:35 <mauke> CodeDmitry: listen to parcs \o/
16:02:54 <parcs> CodeDmitry: you're better off using linux in some form if you want to use a tolerable irc client and haskell
16:02:55 <`nand`> mIRC is proprietary
16:03:08 <`nand`> parcs: that condition can arguably be dropped
16:04:37 <jmcarthur> omg we're arguing over platforms and irc clients now?
16:04:51 <mauke> no
16:05:08 <`nand`> I don't see any arguments
16:05:11 <zomg> There is no argument. Only real way to IRC is using the raw protocol
16:05:13 <zomg> =)
16:05:23 <pharaun> just use ii
16:05:24 <`nand`> good ol' netcat
16:05:25 * mauke starts up nc
16:05:31 <johnw> socat - tcp:irc.freenodenet:6667
16:05:35 <monochrom> every function takes only 1 argument
16:05:36 <johnw> mauke: at least be more modern than that
16:05:42 <cmccann> johnw: I fixed a few things with these
16:06:02 <johnw> cmccann: time for a new release?
16:06:17 * johnw fires up the releasing machinery
16:06:19 <cmccann> gotta run AFK for a bit, if you want to take a look and like make sure it builds and stuff sure
16:06:29 <johnw> i'll bump version to 0.3
16:06:35 <cmccann> already did
16:06:39 <johnw> ok
16:06:59 <johnw> ah, I see it now, I was on the wrong branch
16:07:21 <cmccann> anyway, afk for a bit, if I did anything stupid I'll fix it when I get back
16:07:30 <Dima__> hi
16:07:38 <Dima__> Hexchat seems to work
16:08:11 <Dima__> How do I change my nick?
16:08:23 <hrumph> hi
16:08:23 <mauke> /nick
16:08:30 <CodeDmitry> Alright
16:08:34 <CodeDmitry> HexChat works fine
16:08:53 <hrumph> yesod problem. i've added the default-layout.lucius file but its having absolutely no effect on anything i'm seeing. i'm following the tutorial at http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/
16:09:39 * hackagebot these 0.3 - An either-or-both data type, with corresponding hybrid error/writer monad transformer.  http://hackage.haskell.org/package/these-0.3 (JohnWiegley)
16:09:41 <applicative> hrumph: there is a #yesod by the way
16:10:11 <leggo> is there a more elegant way to do this?
16:10:14 <leggo> > map (\(x,y) -> [x,y]) $ zip [0..5] [5,4..0]
16:10:15 <hrumph> same question posted tehre too
16:10:15 <lambdabot>   [[0,5],[1,4],[2,3],[3,2],[4,1],[5,0]]
16:11:13 <johnw> leggo: zipWith (:)
16:11:27 <johnw> or, zipWith (\x y -> [x,y])
16:12:23 <leggo> yeah latter will work
16:13:09 <hrumph> i had to "touch a file called StaticFiles.hs
16:13:23 <hrumph> something in a google told me that
16:14:10 <hrumph> that triggered some recompilation
16:14:39 * hackagebot linear 0.9.1 - Linear Algebra  http://hackage.haskell.org/package/linear-0.9.1 (EdwardKmett)
16:19:19 <applicative> hrumph: Is there something calling defaultLayout or the like?
16:22:59 <JosephFritzll> how to make a gay fuck a woman?
16:23:00 <JosephFritzll> shit her into cunt
16:23:11 <elliott> @where ops
16:23:11 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
16:23:11 <lambdabot> xerox
16:23:14 --- mode: ChanServ set +o mauke
16:23:15 --- mode: mauke set +b *!*@176.96.167.187
16:23:30 --- kick: JosephFritzll was kicked by mauke (you have angered the gazebo)
16:23:32 --- mode: ChanServ set +o edwardk
16:23:41 <copumpkin> o.O
16:24:25 <jmcarthur> huh
16:24:29 <jmcarthur> i never knew that
16:25:29 --- mode: mauke set -o mauke
16:32:02 <CodeDmitry> Hexchat really works well :)
16:37:20 <aluink> cmccann: ping
16:43:29 * applicative just realized he has four cores
16:43:35 <vermeille> Sadly, I was unable to use emscripten with Haskell :(
16:44:50 <Ralith> vermeille: no ghc calling convention support?
16:45:01 <vermeille> even the most simple hello world fails
16:45:17 <vermeille> I don't know why, I have an horrible stack trace
16:46:24 <vermeille> I believe that's because Emscripten does some cross compilation stuff that ghc cannot follow, like replacing standard headers
16:47:08 <aluink> @hoogle join (***)
16:47:08 <lambdabot> Warning: Unknown type ***
16:47:08 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
16:47:08 <lambdabot> Control.Monad.Trans.Identity runIdentityT :: IdentityT m a -> m a
16:47:51 <fragamus> @hoogle Maybe a -> a
16:47:52 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
16:47:52 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
16:47:52 <lambdabot> Data.Monoid First :: Maybe a -> First a
16:48:13 <kvda> What's the equilivant of ghci :t in Haskell?
16:48:53 * geekosaur does not understand the question
16:49:06 <Ralith> what's the equivalent of your mouse's scroll wheel in haskell?
16:49:12 <kvda> Hah
16:49:42 <kvda> I mean, I want the same output of :t in a compiled script.
16:50:03 <shachaf> You probably don't.
16:50:04 <geekosaur> "compiled script"?  oy
16:50:16 <shachaf> What's wrong with a compiled script?
16:50:34 <geekosaur> haskell does not have built-in introspection.  and strict typing makes introspection difficult to work with anyway
16:50:41 <mauke> a script is what you give the actors; a program is what you give the audience
16:50:42 <mm_freak> how about a compiled program?  but that doesn't help kvda
16:51:16 <mm_freak> kvda: what do you need?  try explaining it without referring to interpreter commands
16:51:20 <Ralith> geekosaur: how does it make it difficult to work with?
16:51:22 <kvda> Right, thank you.
16:51:25 <geekosaur> shachaf, mostly that it implies they think haskell is like php or perl
16:51:45 <mauke> geekosaur: it is!
16:51:46 <geekosaur> Ralith, consider:  what exactly can you *do* with it?
16:51:50 <Maxdamantus> You could implement it for a specific set of types/type constructors.
16:51:59 <Iceland_jack> well it's possible to call ghci with “echo :t take | ghci”
16:52:11 <elliott> kvda: You can do main = print (typeOf foo) if you import Data.Typeable?
16:52:12 <Iceland_jack> Obviously I would not recommend doing that…
16:52:15 <elliott> But I don't see why you'd want to.
16:52:17 <monochrom> mauke++
16:52:22 <mm_freak> (the universe knows i love haskell, but this channel sometimes needs to be reminded that there is a real world out there) =)
16:52:37 <aluink> @hoogle typeOf
16:52:37 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
16:52:37 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
16:52:37 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
16:52:44 <shachaf> Perhaps mauke would say that Haskell programs only have access to Haskell values, not expressions. But expressions have types, not values.
16:52:47 <shachaf> Probably not, actually.
16:52:50 <mauke> the RealWorld is just an artifact of the ghc RTS
16:52:58 <mm_freak> mauke++
16:53:08 <elliott> The real world gets eliminated at compile-time, then.
16:53:10 <Maxdamantus> > typeOf typeOf
16:53:11 <lambdabot>   Ambiguous type variable `a0' in the constraint:
16:53:11 <lambdabot>    (Data.Typeable.Internal....
16:53:15 <kvda> elliott, thank you, I was looking for something along those lines.
16:53:28 <elliott> kvda: But why?
16:53:30 <kvda> Just for learning how it works
16:53:44 <Ralith> geekosaur: find the names of constructors, say
16:53:46 <mm_freak> kvda: you can write the Typeable class yourself…  there is nothing magic about that
16:53:56 <applicative> @type typeOf
16:53:58 <lambdabot> Typeable a => a -> TypeRep
16:53:58 <elliott> kvda: It isn't as generic as :t.
16:54:01 <elliott> typeOf only works on Typeable stuff.
16:54:03 <monochrom> you can lie when you write a Typeable instance
16:54:04 <applicative> @type typeOf typeOf
16:54:05 <lambdabot>     Ambiguous type variable `a0' in the constraint:
16:54:05 <lambdabot>       (Typeable a0) arising from a use of `typeOf'
16:54:05 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
16:54:07 <aluink> > typeOf False
16:54:08 <lambdabot>   Bool
16:54:14 <elliott> What GHCi does with :t has no direct equivalent in Haskell.
16:54:14 <mm_freak> kvda: usually you only use it, when you need to do unsafe stuff
16:54:19 <elliott> monochrom: Well, that lie also lets you unsafeCoerce...
16:54:20 <aluink> > show $ typeOf False
16:54:21 <lambdabot>   "Bool"
16:54:26 <shachaf> mm_freak: Typeable has plenty of magic.
16:54:27 <elliott> monochrom: Hand-written Typeable instances are pretty much assumed not to exist.
16:54:37 <shachaf> Like unsafeCoerce, and DeriveTypeable.
16:54:39 <mm_freak> shachaf: what magic other than DeriveDataTypeable?
16:54:40 <monochrom> we are in agreement
16:54:40 <elliott> Oh, I should be addressing this to mm_freak.
16:54:48 * elliott didn't see what it was in response to.
16:54:53 <Maxdamantus> > typeOf (&&)
16:54:54 <lambdabot>   Bool -> Bool -> Bool
16:55:06 <mm_freak> elliott: sure, either you write everything or you derive everything…  for Data.Typeable you derive
16:55:12 <applicative> > typeOf (&)
16:55:13 <lambdabot>   Ambiguous type variable `a0' in the constraint:
16:55:13 <lambdabot>    (Data.Typeable.Internal....
16:55:14 <elliott> mm_freak: Typeable is magic in that Data.Typeable not exporting unsafeCoerce is dependent on nobody ever writing an incorrect Typeable instance.
16:55:18 <aluink> cmccann was talking about a Monad instance for ((->) a) yesterday, does anyone know where that's defined?
16:55:18 <applicative> oh god
16:55:25 <monochrom> a haskell implementation is likely to erase type information because it is not needed at run time
16:55:32 <elliott> So writing a Typeable instance by hand isn't really avoiding magic, it's just making everything more likely to explode.
16:55:59 <kvda> Right.
16:56:02 <shachaf> aluink: Depends on your GHC version.
16:56:05 <mm_freak> i'm saying that Typeable isn't magic…  unsafeCoerce is magic, but Typeable isn't
16:56:06 <shachaf> aluink: Perhaps Control.Monad.Instances
16:56:10 <monochrom> except for REPL, of course
16:56:36 <mm_freak> you could write MyTypeable only for extracting type information, which can be useful/interesting in combination with ExistentialQuantification
16:56:45 <aluink> it was in reference to finding a function :: (a -> b) -> (a,a) -> (b,b)
16:56:53 <shachaf> Typeable is a better primitive than unsafeCoerce.
16:56:57 <jmcarthur> :t join (***)
16:56:59 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
16:57:05 <aluink> and he sighted the golf entry of join (***) yes
16:57:13 <mauke> cited?
16:57:19 <monochrom> there is the "GHC API". it means your executable includes a copy of most of ghci, and therefore you can talk about types during run time
16:57:19 <aluink> yes, sorry
16:57:32 <shachaf> Golf entries ahoy!
16:57:34 <shachaf> @yarr
16:57:34 <lambdabot> Smartly me lass
16:57:51 <monochrom> it also means your executable is huge, tens of MB
16:57:52 <shachaf> lens is an even better primitive: It has a bunch of useful functions *and* it tends to export unsafeCoerce.
16:57:53 <aluink> shachaf: where are those? my google-fu was weak while looking for them
16:58:01 <shachaf> aluink: Where are what?
16:58:15 <aluink> shachaf: those Golf entries
16:58:17 <edwardk> shachaf: =P
16:58:24 <edwardk> we haven't exported unsafeCoerce in over a month
16:58:45 <shachaf> Speaking of which, what's left for 3.8?
16:59:12 <edwardk> i'm mostly cleaning stuff up, and seeing if we can tree up Text
16:59:16 * monochrom is very tempted to @remember edwardk we haven't exported unsafeCoerce in over a month
16:59:34 <edwardk> monochrom: mind you its been over a month since our last major release ;)
16:59:49 <monochrom> because a connotation could be "now is time to export it again"
16:59:59 <shachaf> Author: Edward Kmett <ekmett@gmail.com>
16:59:59 <shachaf> Date:   Sat Jan 12 14:31:17 2013 -0500
16:59:59 <shachaf> Ceasing to export unsafeCoerce
17:00:14 <edwardk> that was head
17:00:19 <shachaf> Oh, well, sure.
17:00:21 <edwardk> doesn't count unless it hits hackage
17:00:48 <shachaf> Well, profunctors now exports unsafeCoerce.
17:00:53 <shachaf> Admittedly only in a .Unsafe module.
17:01:03 <edwardk> in a {-# LANGUAGE Unsafe #-} module
17:01:31 <geekosaur> {-# LANGUAGE Incoherent #-}
17:01:46 <applicative> it's such a pleasure always having unsafeCoerce in scope though
17:01:49 <mauke> {-# LANGUAGE FuckIt #-}
17:02:04 <shachaf> Can you believe The Masses still have k (a -> f b) (s -> f t) lenses?
17:02:15 <edwardk> we need to fix that
17:02:21 <shachaf> Yes.
17:02:30 <applicative> The Masses??
17:02:39 <shachaf> applicative: This Means You.
17:02:49 <applicative> hoi polloi
17:02:49 <edwardk> i need to do a pass with snap and whatnot and make sure we're not breaking them irredeemably before we ship
17:02:59 <edwardk> so i'd hazard we'll probably ship it tomorrow
17:03:03 <shachaf> edwardk: Should we do an analogous Text traversal? to go with the ByteString one?
17:03:10 <shachaf> It'd be trickier because the Text could grow.
17:03:22 <shachaf> s/\?//
17:03:27 <edwardk> yeah, but text already does that mamagement by growing it, etc.
17:03:49 <edwardk> when you give text a text fragment of known char-count it starts one size then doubles and trims
17:03:49 <applicative> is there a new lens type somehow that we incognoscenti are using?
17:04:03 <edwardk> applicative: equalities for one
17:04:19 <AfC> "incognoscenti". That's a good word.
17:04:33 <shachaf> applicative: These days lensese are p a (f b) -> p s (f t) rather than k (a -> f b) (s -> f t)
17:04:42 * applicative imagines forall f . Functor f => (Void -> f Void) -> Void -> f (Void)
17:04:55 <applicative> with suitable coercions...
17:04:56 <edwardk> in the somewhat near future they may erode to p a b -> q s t
17:05:07 <shachaf> Maybe.
17:05:09 <mauke> applicative: id?
17:05:10 <ion> Pabqst
17:05:21 <applicative> I see you redistributed -> and p (or k)
17:05:22 <geekosaur> and then quaff a beer?
17:05:34 <edwardk> usually we have p = q, so its just pabst
17:05:37 <edwardk> even better
17:06:00 <edwardk> dolio gave me endless amounts of crap at the office when i showed him a signature you could clearly read both pabst and stab out of.
17:06:08 <Playground> Is there any way to derreference a "Ptr a"?
17:06:20 <applicative> > '🍺 '
17:06:20 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
17:06:20 <mauke> Playground: yes
17:06:22 <geekosaur> @index peek
17:06:22 <lambdabot> Foreign.Storable, Foreign
17:06:24 <shachaf> @hoogle Ptr a -> IO a
17:06:24 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
17:06:24 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
17:06:26 <applicative> aw
17:06:26 <lambdabot> Network.Socket.Internal peekSockAddr :: Ptr SockAddr -> IO SockAddr
17:06:35 <geri> does haskell support multithreading?
17:06:41 <mauke> haha
17:06:48 <applicative> its all it ever does, geri
17:06:48 <leggo> ^^
17:06:50 <Playground> mauke: geri: shachaf: ty
17:06:55 <Playground> geekosaur: *
17:07:09 <geri> hu?
17:07:31 <ion> @faq Can Haskell do multithreading?
17:07:31 <lambdabot> The answer is: Yes! Haskell can do that.
17:07:33 <shachaf> geri: I recommend the FAQ:
17:07:34 * applicative is a little confused too
17:07:35 <shachaf> @where faq
17:07:35 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:08:37 <geri> ok
17:08:44 <applicative> http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
17:10:58 <cmccann> regarding the subject of deriving Typeable, what about types where that doesn't work? :[
17:13:49 <edwardk> cmccann: in 7.8 or so we should have a generalized typeable where you can do it for everything/it is automatically done for everything
17:14:02 <cmccann> that would be nice
17:14:36 <shachaf> Next up -- make it implicit in every signature.
17:14:38 <shachaf> Like `seq`
17:14:44 <edwardk> *twitch*
17:14:47 <cmccann> hahaha
17:14:49 <edwardk> nobody wants that ;)
17:15:00 <cmccann> that's the worst thing you've said yet, shachaf.
17:15:02 <cmccann> congratulations.
17:15:02 <edwardk> ok, nobody who knows what they are talking about anywas ;)
17:15:11 <shachaf> cmccann: To be fair, monochrom said it first.
17:16:07 <elliott> just make every typeclass implicit
17:17:50 <cmccann> also, make it possible to use a typeclass where a type is expected as syntactic sugar for (exists a. Foo a => a)
17:17:56 <cmccann> that would be so great!!
17:19:26 <applicative> so Control.Lens.Equality is the great breakthrough??
17:19:39 <edwardk> no, profunctor lenses is the big one
17:19:47 <edwardk> well using p a (f b) -> q s (f t)
17:19:52 <edwardk> which means Iso and Prism compose with (.)
17:20:00 <edwardk> and it has a hundred knock-on effects
17:20:47 <edwardk> Review is new, we have the magma combinators for inspecting traversals, we have breadth first searches, prisms for cons and snoc, prisms for the entire exception hierarchy, etc.
17:20:55 <edwardk> there is a _lot_ of stuff in 3.8
17:21:41 <Felipe_sgRosa> hi guys, which library use the State monad (I'm kinda new to Haskell)? I want to take a look at the code so I could try understanding that monad better. I think a code I'm developing would benefit from it.
17:22:37 <preyalone> Can someone help me resolve a type error? I'm trying to use channels to emulate actors. https://github.com/mcandre/parhello/blob/master/haskell/helloactor.hs
17:22:49 <preyalone> helloactor.hs:28:18:     Couldn't match expected type `IO t0' with actual type `[a0]'
17:23:07 <parcs> Felipe_Rosa: the 'mtl' package provides the state monad
17:23:24 <cmccann> parcs: I think the question was about using it, not the definition
17:23:32 <parcs> oh
17:23:36 <shachaf> @ty replicate
17:23:37 <lambdabot> Int -> a -> [a]
17:23:41 <shachaf> preyalone: ☝
17:23:44 <geekosaur> preyalone, I would suspect you want replicateM
17:24:03 <geekosaur> :t replicateM
17:24:04 <lambdabot> Monad m => Int -> m a -> m [a]
17:24:09 <Felipe_sgRosa> parcs: Yeah, cmccann is right. I got the definition but I think I don't really get the use of the monad...
17:24:22 <preyalone> geekosaur: In the Control.Monad module?
17:24:39 <applicative> Felipe_sgRosa: import Control.Monad.Trans.State
17:25:30 <geekosaur> yes
17:25:40 <shachaf> preyalone: threadDelay does not take milliseconds.
17:25:43 <applicative> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-State-Strict.html rather
17:26:04 <preyalone> microseconds?
17:26:42 <AfC> Heh, I just looked that up myself. Yes it's microseconds
17:26:55 <applicative> Felipe_sgRosa: there is no State monad properly speaking in the newer standard melange of libraries.   StateT is a 'monad transformer' that covers more territory
17:27:01 <preyalone> Noted.
17:27:12 <cmccann> ...again, the question was about usage examples, not where StateT comes from.
17:27:35 <cmccann> Felipe_sgRosa: anyway, I can't think of any clear examples of using the State monad off the top of my head
17:27:41 <parcs> Felipe_sgRosa: are you looking for a "real world" use of teh state monad or a contrived example that demonstrates its features?
17:27:44 <applicative> its funny, the sentence is quite opaque I think youre rright
17:27:49 <cmccann> only stuff where there's a bunch of other stuff going on as well
17:28:18 <preyalone> @ty zipWith
17:28:19 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:28:28 <preyalone> Ah, the function comes first.
17:29:11 <applicative> Felipe_sgRosa: here is a dual tutorial for State and Lens https://github.com/ekmett/lens/blob/master/examples/Pong.hs
17:29:15 <Felipe_sgRosa> parcs: I think a real world example would do better. I've looked at some tutorials on the internet but none has cleared my mind.
17:29:17 <cmccann> actually, the relevant LYAH chapter seems to have some nice bits of example code
17:29:18 <preyalone> Anyone remember the syntax for lambdas with multiple arguments?
17:29:23 <preyalone> \(a,b) -> ...
17:29:28 <preyalone> \a b -> ...
17:29:32 <shachaf> Try it!
17:29:43 <cmccann> oh yeah, that pong code is good.
17:29:45 <shachaf> Exactly one of those will work for your code.
17:30:37 <Felipe_sgRosa> applicative: Thanks! That's nice, I'm going to take a look at it.
17:31:55 <applicative> Felipe_sgRosa: each 'Writer' module in pandoc uses a simple state https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Writers/Markdown.hs
17:32:53 <preyalone> My lambda syntax looks correct, but there's something causing a type error in the zipWith call. https://github.com/mcandre/parhello/blob/master/haskell/helloactor.hs#L32
17:33:13 <preyalone> helloactor.hs:32:9:     Couldn't match expected type `IO a0' with actual type `[c0]'
17:33:26 <shachaf> @ty zipWith
17:33:27 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
17:33:32 <shachaf> It is the same thing as before.
17:33:48 <Felipe_sgRosa> applicative: Thanks a lot! I just scrolled by the files you sent me and I think they will help me :D.
17:34:04 <shachaf> Also, you shouldn't use replicate here.
17:34:10 <applicative> @pf (\chan c -> writeChan chan c)
17:34:10 <lambdabot> Maybe you meant: bf pl
17:34:17 <applicative> @pl (\chan c -> writeChan chan c)
17:34:17 <lambdabot> writeChan
17:34:22 <shachaf> But whatever.
17:34:53 <parcs> Felipe_sgRosa: check out the Snap framework. it uses the State monad extensively
17:35:01 <preyalone> I'm using replicateM now. Are you saying I shouldn't use replicateM either?
17:36:03 <applicative> zipWith (\chan c -> writeChan chan c) chans s = zipWith writeChan chans c
17:36:22 <shachaf> Which is just as much of a type error, since zipWith returns a list.
17:36:40 <preyalone> Is there a zipWith for nonpure functions?
17:36:42 <applicative> so you need sequence ?
17:37:02 <shachaf> There is zipWithM.
17:37:06 <preyalone> !
17:37:08 <shachaf> zipWithM won't make you happy, though.
17:37:14 <applicative> @type zipWithM
17:37:15 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
17:37:47 <applicative> does writeChan return () ?
17:38:00 <applicative> @type sequence
17:38:01 <lambdabot> Monad m => [m a] -> m [a]
17:39:08 <preyalone> Thanks all. I remember now why I wrote out that lambda -- I'm transforming the data slightly before writing it to the channel.
17:40:37 <applicative> @type  \xs ys -> sequence $ zipWith writeFile xs ys
17:40:39 <lambdabot> [FilePath] -> [String] -> IO [()]
17:40:52 <shachaf> applicative: What is the goal here?
17:41:04 <shachaf> @ty zipWithM writeFile
17:41:05 <lambdabot> [FilePath] -> [String] -> IO [()]
17:41:06 <shachaf> @ty zipWithM_ writeFile
17:41:07 <lambdabot> [FilePath] -> [String] -> IO ()
17:41:13 <applicative> what's your goal?
17:41:29 <applicative> zipWithM is for the birds.
17:41:45 <SamanthaD> 'allo everyone
17:41:53 <shachaf> hi SamanthaD
17:41:59 <SamanthaD> hey shachaf!
17:42:07 <cmccann> hi shachaf
17:42:15 <shachaf> hi cmccann
17:42:50 <shachaf> `welcome cmccann
17:42:50 <preyalone> applicative: I just wanted to write a demo app in Haskell mimicking agents.
17:42:51 <cmccann> shachaf ought to be the official greeter for #haskell.
17:42:53 <shachaf> Oops, wrong channel.
17:43:18 <isomorphic> hey all :)
17:43:21 <preyalone> "zipWithM is for the birds" How so?
17:43:27 <shachaf> isomorphic: Are you isomorphic to cmccann?
17:44:07 <isomorphic> shachaf:  I'm isomorphic to everyone in the channel :)
17:44:08 <cmccann> shachaf: adjectives are generally not isomorphic to nouns
17:44:32 <shachaf> isomorphic: Are you cmccann (up to isomorphism)?
17:44:44 <SamanthaD> So, as part of my learning I'm coding a Yukon solitaire game. Each card is represented as a data structure that contains the suit, face value, and whether the card is up or down. My question is, I want the face value to only go from 1-13. Should I be using a discriminated list or what?
17:44:49 <applicative> yes preyalone I see the source
17:44:59 <shachaf> What's a discriminated list?
17:45:19 <applicative> zipWithM op xs ys = sequence $ zipWith op xs ys which is 3000 x clearer, preyalone
17:45:20 <shachaf> You could write data Card = C2 | C3 | C4 | C5 | ... if you wanted.
17:45:31 <SamanthaD> shachaf: You know, like I would do with the suits where it can equal either hearts, spades ect...
17:45:35 <shachaf> Well, value,  not Card.
17:45:51 <Eduard_Munteanu> I think he's equivalent to <someone> if he's iso up to iso.
17:45:56 <SamanthaD> shachaf: what's the Cs for?
17:46:05 <preyalone> Doesn't the naming of zipWithM indicate this?
17:46:09 <applicative> moreover preyalone it doesnt require anything but the Prelude
17:46:10 <cmccann> SamanthaD: you could do that, but it's a bit of a hassle for something like that
17:46:12 <shachaf> SamanthaD: They're for "names can't start with digits"
17:46:26 <shachaf> Or you could use an Int or something if you preferred, and get a less type safety but maybe more convenience.
17:46:27 <preyalone> I'll give you that.
17:46:29 <shachaf> It depends on what you're doing.
17:46:35 <SamanthaD> shachaf: Oh, right, of course!
17:46:35 <applicative> that it is stored in Control.Monad doesn't quite show that it's worthless, since join is trapped in there....
17:46:51 <shachaf> cmccann: Speaking of cards, you know how De Bruijn Sequences are the best thing?
17:46:55 <preyalone> String join?
17:47:03 <applicative> @type join
17:47:04 <lambdabot> Monad m => m (m a) -> m a
17:47:10 <applicative> @type concat
17:47:11 <lambdabot> [[a]] -> [a]
17:47:21 <SamanthaD> shachaf: is this a pun?
17:47:45 <shachaf> Not really.
17:48:38 <applicative> preyalone: it doesn't matter it's good; I just feel like I need it as much as appendM xs ys = liftM2 (++) xs ys
17:48:50 <Eduard_Munteanu> @@ @run (@where rot13) "shachaf"
17:48:51 <lambdabot>   "funpuns"
17:49:02 <Eduard_Munteanu> His very name is a pun. :P
17:49:20 <preyalone> Some of us don't yet understand liftM. /shygrin
17:49:20 <applicative> no, rot13 of his name is
17:49:40 <applicative> liftM2 (+) (Just 1) (Just 2)
17:49:54 <shachaf> Or GADTs!
17:49:57 <applicative> liftM2 (+) [ 1] [2,3]
17:50:09 <applicative> > liftM2 (+) [ 1] [2,3]
17:50:11 <lambdabot>   [3,4]
17:50:24 <applicative> > liftM2 (+) (Just 1) (Just 2)
17:50:25 <lambdabot>   Just 3
17:50:37 <SamanthaD> So, is there a "best practice" method of coding an integer data structure that logically has an upper and lower bound? The other way I was thinking was have a dedicated function used to interface with the structure but that's awfully object-oriented for my taste.
17:50:39 <applicative> this irsii thing is muddling my already doubtful brain
17:50:49 <preyalone> Is that literate Haskell notation?
17:50:55 <shachaf> SamanthaD: The standard thing would probably be just a type with a smart constructor.
17:50:56 <jfischoff> SamanthaD: look at the Enum class
17:50:59 <applicative> the > ? preyalone
17:50:59 <shachaf> preyalone: No, it's bot notation.
17:51:00 <Eduard_Munteanu> SamanthaD: Bounded, Enum
17:51:04 <jfischoff> ^
17:51:05 <applicative> > 1 + 1
17:51:06 <lambdabot>   2
17:51:13 <applicative> > reverse "preyalone"
17:51:15 <lambdabot>   "enolayerp"
17:51:24 <Ralith> E_NO_LAYER_P
17:51:34 <SamanthaD> Thank you very much, schachaf, jfischoff and Eduard_Munteanu. That's just what I was looking for!
17:51:35 <shachaf> SamanthaD: newtype Card = Card Int; card :: Int -> Maybe Card; card n | n < 0 || n > 12 = Nothing | otherwise = Card n
17:51:45 <shachaf> Or maybe I misunderstood your question.
17:51:47 <isomorphic> Hrmm - I want to do a case on an IO (Maybe String), I'll call it x.    My thought was to do case liftIO x of - but that complains - No instance for (MonadIO Maybe) - thoughts?
17:51:55 <CodeDmitry> irc doesnt kick you after certain time frame?
17:52:02 <CodeDmitry> I was away for like 30 mins :X
17:52:12 <jfischoff> SamanthaD: :)
17:52:15 <shachaf> isomorphic: do { y <- x; case y of ... }
17:52:15 <Eduard_Munteanu> CodeDmitry: no, idling for hours/days is really common
17:52:52 <shachaf> irc kicks you out for talking too much, not too little.
17:52:54 <CodeDmitry> one more stupid question, what is the standard command loop look like in haskell (while true, getinput, processinput)
17:53:10 <SamanthaD> shachaf: No, I don't think you misunderstood my question. I just need to learn how to make these custom data constructors.
17:53:31 <cmccann> shachaf: sorry, was afk making bread pudding. what's this about sequences or some whatnot?
17:53:32 <Eduard_Munteanu> CodeDmitry: there are various ways to do that, one of them is interact
17:53:35 <Eduard_Munteanu> :t interact
17:53:36 <lambdabot> (String -> String) -> IO ()
17:53:38 <mm_freak> CodeDmitry: forever $ …
17:53:38 <shachaf> CodeDmitry: Just one more? You promise?
17:53:45 <shachaf> CodeDmitry: forever $ getInput >>= processInput
17:53:54 <CodeDmitry> lol thanks sha
17:54:03 <preyalone> CodeDmitry: You can use a while loop, but it does require a little crufty syntax.
17:54:20 <mm_freak> the syntax for while loops is much saner in haskell
17:54:26 <preyalone> Mostly because you're looping over a body / series of IO operations
17:54:29 <applicative> @type while
17:54:30 <lambdabot> Not in scope: `while'
17:54:37 <applicative> :(
17:54:44 <applicative> @type Control.Monad.while
17:54:45 <Eduard_Munteanu> @hoogle whileM
17:54:45 <lambdabot>     Not in scope: `Control.Monad.while'
17:54:45 <lambdabot>     Perhaps you meant one of these:
17:54:45 <lambdabot>       `Control.Monad.fail' (imported from Control.Monad),
17:54:45 <lambdabot> No results found
17:54:46 <geekosaur> (IRC won't kick you out but cheap routers might expire the NAT table entry)
17:54:53 <preyalone> Similarly, when, Haskell's if without the else, requires a little crufty syntax.
17:54:55 <CodeDmitry> @t "Hello"
17:54:56 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:54:57 <mm_freak> until :: (Monad m) => m (Maybe a) -> m a
17:55:03 <shachaf> "series of IO operations"? That sounds like [IO a] to me.
17:55:28 <Eduard_Munteanu> preyalone: there's whenM for that.
17:55:46 <Eduard_Munteanu> Unless you mean for normal functions, but there it doesn't make sense.
17:55:47 <mm_freak> there's 'when' for that
17:55:51 <mm_freak> whenM is something different
17:55:55 <Eduard_Munteanu> Erm, right.
17:56:11 <sw2wolf> :t whenM
17:56:12 <lambdabot>     Not in scope: `whenM'
17:56:12 <lambdabot>     Perhaps you meant `when' (imported from Control.Monad.Writer)
17:56:21 <sw2wolf> :t when
17:56:23 <lambdabot> Monad m => Bool -> m () -> m ()
17:56:33 <mm_freak> sw2wolf: for whenM replace "Bool" by "m Bool"
17:56:41 <sw2wolf> ok
17:56:45 <cmccann> SamanthaD: if you're going to represent card rank as a wrapped Int I would probably define a bunch of identifiers for each rank, e.g. "king = Rank 13"
17:57:00 <cmccann> then you can just use those most of the time instead of worrying about constructing new values
17:57:04 <applicative> > let if_ p a  = if p then a else return () in if_ (3 < 4) [(),(),()]
17:57:05 <lambdabot>   [(),(),()]
17:57:12 <mm_freak> the more experienced you get in haskell, the less often you use when/whenM
17:57:13 <shachaf> By the way, the correct order for cards is:
17:57:20 <shachaf> [2,3,4,5,6,7,8,9,10,J,Q,K,A]
17:57:21 <sw2wolf> @hoogle m Bool -> m() -> m ()
17:57:21 <lambdabot> Data.Generics.Aliases ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
17:57:21 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
17:57:21 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
17:58:01 <isomorphic> shachaf:  Thanks.   That seems to make sense, but now it complains that the IO (Maybe String) isn't  a GHandler App App t0 - which is the type associated with the do block I've put the <- operation in.   Should I be able to mix these two types IO (Maybe String) and GHandler App App t0 within a single do block?
17:58:07 --- mode: ChanServ set +o mauke
17:58:07 --- mode: mauke set -b amathew*!*@*
17:58:14 * applicative likes when
17:58:27 * mm_freak prefers (<|>)
17:58:36 <SamanthaD> cmccann: Well, what I was planning on doing was just representing them as values and letting the interface translate them. I think it would make the logic easier since in Yukon all a queen, for example, really is is a 12. Just have the interface do the translation.
17:58:44 <mm_freak> or (<>) where applicable
17:58:53 <mm_freak> and recently i came to like (<!>) =)
17:59:01 <shachaf> isomorphic: Maybe you need to liftIO it. I have no idea what GHandler is.
17:59:07 <cmccann> SamanthaD: that's also a reasonable approach
17:59:23 <mm_freak> shachaf: yesod's request handler monad family
17:59:23 <Eduard_Munteanu> isomorphic: what are you working with?
17:59:31 <Eduard_Munteanu> Ah, seemed familier.
17:59:34 <isomorphic> shachaf, Eduard_Munteanu:  FYI, it's from Yesod.
17:59:35 <Eduard_Munteanu> *familiar.
17:59:51 <Eduard_Munteanu> isomorphic: liftIO
17:59:56 <mm_freak> yesod has Handler, GHandler and GGHandler…  i'm still waiting for GGGHandler
17:59:58 <shachaf> isomorphic: Then maybe you should ask #yesod
18:00:00 <Eduard_Munteanu> GHandler is a MonadIO.
18:00:07 --- mode: mauke set -o mauke
18:00:11 <isomorphic> Ah- so, y <- liftIO x ?
18:00:22 <mm_freak> isomorphic: yes
18:00:22 <stepkut> mm_freak: Go-Go-Gadget Handler?
18:00:30 <mm_freak> =)
18:00:37 <sw2wolf> :t liftIO
18:00:38 <lambdabot> MonadIO m => IO a -> m a
18:00:39 <shachaf> SamanthaD: Perhaps lenses will fix your make^H^H^H^Hprogram.
18:00:49 <mm_freak> it shows how much yesod can generalize handlers =)
18:00:57 <SamanthaD> shachaf: fraid I haven't learned lenses yet! O.O
18:01:12 <mm_freak> type GGGGGGGGGGGGHandler a = forall m. (Monad m) => m a
18:01:35 <cmccann> shachaf would probably be happy to tell you all about lenses.
18:01:40 <edwardk> heh
18:01:56 <shachaf> lenses are so easy
18:02:01 <applicative> whats the definition of (<!>) mm_freak
18:02:06 <isomorphic> shachaf, mm_freak , Eduard_Munteanu:  Thanks!
18:02:14 <elliott> mm_freak: Monad? that's not very general
18:02:16 <mm_freak> applicative: see Data.Functor.Alt from semigroupoids
18:02:20 <applicative> ah
18:02:22 <elliott> try (Invariant m)
18:02:30 <mm_freak> elliott: ok…
18:02:38 <mm_freak> type GGGGGGGGGGGGGGGGGGGGGGGGGHandler a = forall m. m a
18:02:41 <mm_freak> how about that?
18:02:46 <elliott> nicely uninhabited
18:02:54 <mm_freak> that's the price of abstraction
18:03:29 <SamanthaD> cmccann: Well, I know I'm going to need a few concepts I don't already know to make this thing. It's more of a replacement for Write Yourself a Scheme in 48 hours in that I can't peek at the answers. I know, for example, I'm definitely going to need zippers to handle the lists of cards representing the tableaus
18:03:29 <applicative> type GGGGGGGGGGGGGGGGGGGGGGGGGHandler a = forall m. Monad m => m a
18:03:42 <cmccann> @quote elliott abstraction
18:03:42 <lambdabot> elliott says: cmccann: unfortunately it is too perfect an abstraction to be useful.
18:03:43 <mm_freak> applicative: no, that's GGGGGGGGGGGGHandler as defined above
18:03:43 <applicative> still uninhabited hm
18:03:54 <mm_freak> applicative: no, that one is habitated
18:03:55 <shachaf> applicative: That's not uninhabited.
18:04:08 <mm_freak> return 3 :: GGGGGGGGGGGGHandler Int
18:04:11 <applicative> whats in it
18:04:19 <mm_freak> that's your choice
18:04:34 <mm_freak> it's universal after all
18:04:39 <applicative> type GGGGGGGGGGGGGGGGGGGGGGGGGHandler  = forall m. Monad m => m Int
18:04:42 <applicative> is inhabited
18:04:57 <applicative> @type return (3 :: Int)
18:04:58 <lambdabot> Monad m => m Int
18:05:17 <preyalone> How can I include wildcards/unknowns in type synonyms? "type Actor = Chan a -> IO ()" results in "Not in scope: type variable `a'"
18:05:21 <mm_freak> > return 3 :: forall m. (Monad m) => m Int
18:05:23 <lambdabot>   No instance for (GHC.Show.Show (m0 GHC.Types.Int))
18:05:23 <lambdabot>    arising from a use of...
18:05:32 <mm_freak> > (return 3 :: forall m. (Monad m) => m Int) :: Maybe Int
18:05:33 <lambdabot>   Just 3
18:05:37 <mm_freak> there, habitated
18:05:43 <Eduard_Munteanu> preyalone: pass it as a parameter to Actor
18:05:49 <mm_freak> preyalone: type Actor a = …
18:05:56 <preyalone> thanks
18:06:19 <applicative> preyalone: dont listen to mm_freak
18:06:43 <applicative> oh, wait, I see, but then it depends on a
18:06:58 <mm_freak> it should probably depend on 'a'
18:07:00 * applicative thought mm_freak was using _ literally. 
18:07:04 <Eduard_Munteanu> I don't think he wants 'a' universally quantified.
18:07:06 <applicative> mm_freak: yes i agree
18:07:16 <sw2wolf> use type as parameter same as template in C++ ?
18:07:24 <mm_freak> Eduard_Munteanu: and no such solution has been proposed =)
18:07:36 <preyalone> I wouldn't have used ... literally, though oddly enough, Lua does have ... syntax.
18:07:47 * applicative is under the impression is the same as templates in C++
18:07:49 <neutrino_> this new paper on functional programming seems really interesting. but the CT seems beyond my grasp. http://isotropic.org/papers/chicken.pdf
18:07:52 <Eduard_Munteanu> Well, it's the only other choice really, besides passing 'a' to Actor :)
18:07:56 <mm_freak> sw2wolf: well, C++ templates are a macro system…  in haskell you get actual type variables
18:08:18 <sw2wolf> yes
18:09:28 <sw2wolf> C++ must CPP template to type variable ?
18:09:50 <Eduard_Munteanu> neutrino_: heh, yeah, I remember that.
18:09:51 <mm_freak> C++ doesn't have type variables
18:09:57 <mm_freak> as said, it's a macro system
18:10:22 <sw2wolf> oh,. after CPP, it becomes type
18:10:40 <sw2wolf> without type variable
18:10:41 <Eduard_Munteanu> Well, Haskell has '..'.
18:10:47 <Eduard_Munteanu> > [1..3]
18:10:48 <lambdabot>   [1,2,3]
18:11:13 <sw2wolf> '..' is syntax sugar ?
18:11:18 * Eduard_Munteanu kinda wonders why not '...', though
18:11:23 <Eduard_Munteanu> sw2wolf: yeah
18:11:31 <sw2wolf> thyx
18:11:32 <geekosaur> :t enumFromTo
18:11:33 <Eduard_Munteanu> For enumFromTo.
18:11:33 <lambdabot> Enum a => a -> a -> [a]
18:11:34 <sw2wolf> thx
18:11:38 <shachaf> @let a...b = [a..b]
18:11:40 <lambdabot>  Defined.
18:11:45 <shachaf> > 1...20
18:11:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
18:12:16 <ion> @let a....b = a...pred b
18:12:19 <lambdabot>  Defined.
18:12:20 <ion> > 1....20
18:12:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
18:12:32 <ion> huby
18:13:26 * applicative dimly remembers an 'honorable mention' for the icfp contest this year; it was all C++ templates
18:13:52 <applicative> "
18:13:52 <applicative> We cannot submit our binaries because all the computation in our code
18:13:52 <applicative> happens at compile time, during template instatiation. In fact we use
18:13:52 <applicative> templates as a Pure Functional Programming Language! Long live the
18:13:53 <applicative> λ. That is, we use the C++ compiler as a functional interpreter."
18:14:08 <preyalone> How can I retrieve the current execution thread's Id?
18:14:29 <hpaste> SamanthaD pasted “Yukon Types” at http://hpaste.org/81041
18:14:37 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Control-Concurrent.html#v:myThreadId
18:14:42 <applicative> threadID <- forkIO blah ; print thread_id
18:15:10 <SamanthaD> There we go... I figure that's what you're supposed to use Maybe for. The only thing I'm not sure it's good practice to do it like that because it'll mean a lot of logic will have to work with a maybe monad instead of a simple, unwrapped data
18:15:18 <cmccann> SamanthaD: you probably want some deriving clauses on those, for what it's worth
18:15:38 <SamanthaD> cmccann: Yes, of course. I'm just sketching at this point.
18:15:52 <cmccann> SamanthaD: just checking. :] and there's nothing wrong with using Maybe.
18:15:59 <cmccann> you don't have to treat it as a monad at all if you don't want to.
18:16:11 <shachaf> data Cat = Kitty Pawses deriving (Clawses)
18:16:20 <applicative> hm how does myThreadId :: IO ThreadId  -- Returns the ThreadId of the calling thread (GHC only). work
18:16:41 <SamanthaD> cmccann: Of course! Maybe is just an algebraic data type after all. Hmm... I'd still need to have all functions as type Just a -> b instead of just a -> b
18:16:44 <shachaf> SamanthaD: Maybe is just a plain old type.
18:17:07 <shachaf> SamanthaD: Typically if a function needs to, say, accept a Card, you just pass it a Card, not a Maybe Card.
18:17:08 <SamanthaD> LOL, I just re-read what I wrote >.<
18:17:14 <Eduard_Munteanu> applicative: probably some RTS stuff, what do you mean?
18:17:22 <SamanthaD> I'd still have to have the types be Just a -> b instead of only a -> b
18:17:22 <cmccann> SamanthaD: if the functions are type (a -> b) you can use fmap &c. to get (Maybe a -> Maybe b)
18:17:25 <shachaf> SamanthaD: That way the function doesn't need to worry about the Nothing case.
18:17:36 <shachaf> Instead, the person *calling it* needs to worry about the Nothing case.
18:17:43 <shachaf> It lets you worry about it in exactly one place rather than everywhere.
18:17:51 <cmccann> generally you only want to eliminate the Maybe when you have a default value or can handle the Nothing case appropriately
18:17:59 <preyalone> Does forkIO return the current thread's Id, or the new thread's Id?
18:18:09 <elliott> preyalone: new
18:18:19 <applicative> let aa n = forkIO (print n >> myThreadId >>= print) in mapM_ aa [1..20]
18:18:28 <preyalone> Ah. How can I get the current thread of execution's Id, such as the primary thread's Id?
18:18:33 <applicative> there's some undesirable results, as might be expected :) ^^^
18:18:38 <elliott> @hoogle threadId
18:18:38 <lambdabot> Control.Concurrent data ThreadId
18:18:38 <lambdabot> GHC.Conc.Sync data ThreadId
18:18:38 <lambdabot> GHC.Conc data ThreadId
18:18:42 <geekosaur> you might follow the link I pasted and the n scroll around to see the documemtation of other stuff
18:18:43 <elliott> ugh
18:18:46 <SamanthaD> Maybe it is, then! I definitely don't want defective logic allowing cards to be placed on face-down cards.
18:18:48 <elliott> @hoogle myThreadId
18:18:48 <lambdabot> Control.Concurrent myThreadId :: IO ThreadId
18:18:48 <lambdabot> GHC.Conc.Sync myThreadId :: IO ThreadId
18:18:48 <lambdabot> GHC.Conc myThreadId :: IO ThreadId
18:18:50 <shachaf> @google How can I get the current thread of execution's Id, such as the primary thread's Id? haskell
18:18:51 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
18:18:51 <lambdabot> Title: Control.Concurrent
18:18:58 <shachaf> Like that. :-)
18:19:05 <SamanthaD> Thank you!
18:19:13 <Eduard_Munteanu> @google What's the meaning of life?
18:19:14 <lambdabot> No Result Found.
18:19:20 <Eduard_Munteanu> :(
18:19:20 <geekosaur> :p
18:19:55 <cmccann> SamanthaD: also, the FaceUp type is obviously equivalent to Bool, but using a special-purpose type for what's basically a yes/no value is also fine
18:20:12 <SamanthaD> cmccann: I figured it gives more type safety
18:20:23 <shachaf> SamanthaD: I suspect your types will change as you write more of the program.
18:20:34 <shachaf> We'll see. :-)
18:20:50 * applicative is worried about SamanthaD 's mutable types
18:20:53 <cmccann> SamanthaD: in this case it's probably more a benefit of clarity, and of not having to remember which Bool means which
18:20:59 <SamanthaD> applicative: why?
18:21:22 <isomorphic> If I have a do-block with GHandler App App t0, and want to put something the other way around from last time - eg: a Maybe (IO String), am I right to think I need to lift into Maybe?
18:21:27 <applicative> types don't change! even their inhabitants dont!
18:21:57 <cmccann> applicative: obviously shachaf was suggesting type-level IORefs
18:22:27 <applicative> cmccann: I wouldn't past him, with all this lens foolishness
18:22:27 <shachaf> cmccann: Um, that's unsafe.
18:22:29 <z1y> is the homepage a bit slow?
18:22:30 <shachaf> Type-level TVars.
18:22:34 <SamanthaD> applicative: Oh, I know that! These cards are going to go into lists of cards which will then be handled in functions of type [Card] -> [Card]
18:22:58 <cmccann> shachaf: even better!
18:22:59 <shachaf> z1y: Seems OK to me.
18:23:00 <applicative> ah okay then, that type will change
18:23:26 <Eduard_Munteanu> isomorphic: you could use 'sequence' to "swap" those
18:23:31 <SamanthaD> applicative: So I'm okay?
18:23:35 <z1y> shachaf: Thank you. Seem a network problem here
18:23:37 <Eduard_Munteanu> :t Data.Traversable.sequence
18:23:38 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
18:23:46 * cmccann is starting to lose track of who's joking and who's actually trying to help SamanthaD :P
18:23:51 <shachaf> @ty Data.Traversable.sequenceA
18:23:52 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
18:24:03 <shachaf> cmccann: We're trying to cheer up SamanthaD with jokes.
18:24:34 <SamanthaD> shachaf: Did you know that a disproportionate percentage of functional programmers are anarchists?
18:24:35 <Eduard_Munteanu> But it probably depends on what you're doing.
18:24:48 <applicative> z1y: it's powered by MediaWiki so it must be very fast
18:24:58 * cmccann sees where this is going
18:25:04 <isomorphic> Eduard_Munteanu:  Is that as simple as y <- liftIO $ sequence x ?
18:25:12 <SamanthaD> shachaf: We all learn to abhor state ;)
18:25:33 <Eduard_Munteanu> SamanthaD: huh? I've been fighting these statists for a while now, pretty sure they aren't. :)
18:26:08 <applicative> SamanthaD: oh yes, quite okay on reflection
18:26:20 <Eduard_Munteanu> isomorphic: if you're ok with  y :: Maybe Something
18:26:31 <SamanthaD> Eduard_Munteanu: I was in the anarchist club the other day. For some reason they just dismissed my proposal to wrap the state up in a monad >.>
18:26:45 <applicative> we abhor state, thinking: If it moves, kill it
18:26:50 <Eduard_Munteanu> Oh, I get it now.
18:27:18 <SamanthaD> applicative: or hide it away in a wrapper like a dirty little secret.
18:27:42 <shachaf> Monads are not dirty. :-(
18:27:46 <shachaf> Nor is state.
18:27:50 <shachaf> State is great.
18:27:50 <CodeDmitry> I disagree
18:27:59 <cmccann> IO is kinda dirty.
18:28:09 <CodeDmitry> Nomads, I mean Monads are dirty, so are Lambdas
18:28:10 <Eduard_Munteanu> Yeah, and IO is some sort of global state.
18:28:11 <cmccann> because of all the garbage that gets dumped in it for lack of anywhere else to go.
18:28:24 <SamanthaD> shachaf: you're one of those dirty imperative communists who want the state to dictate everything!
18:29:02 <CodeDmitry> I always thought dictation of state gave us "freedom"
18:29:08 <applicative> cmccann: but the alternatives are worse.  e.g. in Frank, even Maybe is made into an 'effect' ; ick
18:29:24 <jfischoff> @remember SamanthaD shachaf: you're one of those dirty imperative communists who want the state to dictate everything!
18:29:24 <lambdabot> Good to know.
18:29:53 <Eduard_Munteanu> State owns Writers, which get 'censor'ed. :P
18:30:13 <Eduard_Munteanu> :t censor
18:30:14 <lambdabot> MonadWriter w m => (w -> w) -> m a -> m a
18:30:31 <elliott> applicative: What's inherently bad about that?
18:30:33 <CodeDmitry> Is there no better word to describe Monads?
18:30:52 <CodeDmitry> synonyms of some sort
18:31:00 <shachaf> No.
18:31:00 <cmccann> better than what?
18:31:17 <applicative> elliott: maybe nothing, I just found it tiresome.  Half the stuff that is 'monadized' seems rightly thus handled, explicitly etc
18:31:26 <Eduard_Munteanu> That's like accidentally when you write code.
18:31:26 <CodeDmitry> Dictionary says Atom is a synonym to Monad
18:31:44 <cmccann> CodeDmitry: that would be useless and confusing as a term
18:31:45 <elliott> Frank's effect system seems pretty explicit to me.
18:32:03 <Eduard_Munteanu> Heh, Leibniz' stuff.
18:32:05 <CodeDmitry> it would, but many people have heard Atom before starting haskell
18:32:11 <cmccann> CodeDmitry: so?
18:32:12 <elliott> CodeDmitry: Atom would be just as opaque and less useful.
18:32:14 <CodeDmitry> whereas Monad is only known by people who are evil
18:32:19 <elliott> Let's call it "Dog"! Lots of people know that word!
18:32:20 <shachaf> CodeDmitry: People are not familiar with the concept.
18:32:20 <cmccann> the software industry is full of obscure jargon.
18:32:21 <elliott> Oh, you're just trolling.
18:32:24 <shachaf> Why use a word that they're familiar with?
18:32:34 <CodeDmitry> It gives a sense of transition
18:32:36 <applicative> I should maybe not put it that way.  There is nothing confusing about treating Maybes as values, or Eithers etc
18:32:39 <Eduard_Munteanu> They don't even have the same etymology, AFAIK.
18:32:42 <cmccann> CodeDmitry: no, it doesn't.
18:32:49 <elliott> CodeDmitry: I don't think you know enough about monads to tell people what they should call them...
18:32:54 <SamanthaD> I like to wrap up my values in small-fuzzy-animal-not-scary-at-alls
18:32:55 <simpson> CodeDmitry: Most programmers outside of Haskell have *not encountered monads*.
18:32:59 <cmccann> Eduard_Munteanu: they both come from the greek root for "one".
18:33:10 <CodeDmitry> I said haven't heard of Monads
18:33:16 <simpson> CodeDmitry: And when they have, they've found the concept to be similarly frustrating.
18:33:17 <CodeDmitry> they might've encountered or invented them
18:33:18 <cmccann> SamanthaD: the technical term there is "warm fuzzy thing".
18:33:37 <simpson> CodeDmitry: The only one I know of is Deferred. If you know of others, please do tell us.
18:33:42 <applicative> elliott: I think by 'handling explicitly' I mean 'treat as values'
18:33:43 <Eduard_Munteanu> cmccann: I'm not sure if Leibniz' follows the same idea as "monad, dyad, triad..."
18:33:59 <shachaf> Going by the logs, it seems that CodeDmitry has been half-trolling since they first joined the channel.
18:34:07 <shachaf> CodeDmitry: Please be nicer.
18:34:17 <applicative> CodeDmitry: emulate shachaf
18:34:17 <Eduard_Munteanu> TBF he's also been asking some down-to-earth questions too.
18:34:34 <CodeDmitry> I'm not trolling, I just ask strange questions at times
18:34:37 <CodeDmitry> more often than others
18:35:07 <CodeDmitry> I do not say things for the sake of rhetorical reaction, thus I am not a troll
18:35:12 <Eduard_Munteanu> CodeDmitry: anyway, it wouldn't be the first word with two completely different meanings.
18:35:18 <elliott> Well, you call people who use different terminology than you evil.
18:35:23 <elliott> That's pretty much trolling.
18:35:27 <elliott> Try not doing that.
18:35:28 <shachaf> <CodeDmitry> So painful to read haskell documentation
18:35:29 <shachaf> <CodeDmitry> So much superfluous terminology in this language
18:35:34 <simpson> To be fair, I *am* evil. Just sayin'.
18:35:35 <shachaf> Etc.
18:35:41 <cmccann> Eduard_Munteanu: there are at least three distinct uses of "monad" or "monadic". all they have in common is the greek root "monos", no other relation to my knowledge.
18:35:41 <SamanthaD> I know when I started learning Haskell I saw monads as a central feature of the language.
18:36:08 <CodeDmitry> To be honest, I still have a lot of trouble understanding Functors :|
18:36:16 <cmccann> Eduard_Munteanu: Leibniz's stuff, the "-adic" words, and the CT use
18:36:31 <Eduard_Munteanu> Ah.
18:36:35 <CodeDmitry> Can somebody dumb down functors for me ?\
18:36:43 <hrumph> SamanthaD: they're not central features in your opinion?
18:36:59 <Eduard_Munteanu> @where typeclassopedia
18:36:59 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:36:59 <applicative> > fmap even [1,2,3]
18:37:01 <lambdabot>   [False,True,False]
18:37:04 <jfischoff> CodeDmitry: do something inside a box
18:37:10 <cmccann> Eduard_Munteanu: note that if you google for "monad etymology" roughly the second result you find will be something I wrote ;]
18:37:11 <applicative> > fmap even (Just 1)
18:37:13 <lambdabot>   Just False
18:37:26 <CodeDmitry> I'm terrible at doing things inside the box
18:37:35 <CodeDmitry> Unless I invent the ox
18:37:35 <SamanthaD> hrumph: Well... they are just not as much as I had made them. I mean, look at the language Clean. It's pretty much Haskell but with monads replaced by a type system feature. It's still reasonably the same language.
18:37:37 <CodeDmitry> box*
18:37:37 <Eduard_Munteanu> CodeDmitry: see Typeclassopedia's explanation, possibly LYAH's too
18:38:22 <applicative> lyah is good on Functor I think.
18:38:25 <cmccann> the features of Haskell that let the type class Monad exist are pretty central to the language, moreso than Monad itself.
18:38:57 <applicative> I regretted it when he junked the terminology that had him saying [1,2,3] is a functor, Maybe 3 is a functor -- you can map over them
18:39:06 <applicative> Just 3 rather
18:39:39 <SamanthaD> Speaking of which... Clean has a type signature where a variable is promised to only be used by a single function. In that way the compiler can allow it to be updated in-place rather than making deltas of the original value like Haskell does. Is there a language extension that emulates this ability?
18:39:51 <oio_> i am getting this weird bug
18:39:54 <johnw> but [1,2,3] isn't a functor, it's an object in the target category
18:39:54 <applicative> CodeDmitry: his mantra in lyah is 'a functor is something you can map over'
18:40:04 <cmccann> SamanthaD: I wish it did :[
18:40:07 <SamanthaD> cmccann: That's kinda what I meant.
18:40:07 <bbloom> slightly off-topic question that the language gurus in here might know the answer to: is there a (research?) language that has no positional arguments? maybe something where every function is a function of Map -> Map
18:40:13 <hpaste> oio pasted “GHC BUG” at http://hpaste.org/81043
18:40:14 <shachaf> SamanthaD: Not really.
18:40:16 <applicative> johnw: yes, it was strange usage, but parallel to a familiar use of Monad
18:40:18 <CodeDmitry> I understand that, but that makes me go forward to looking at what a map is
18:40:24 <CodeDmitry> then a map will redirect me to something else
18:40:28 <jfischoff> SamanthaD: no haskell does not have linear types
18:40:31 <CodeDmitry> which will cause an infinite regress..
18:40:33 <johnw> bbloom: you mean, like Python but using only keyword arguments?
18:40:48 * cmccann wants linear types >:[ >:[
18:40:53 <Eduard_Munteanu> bbloom: what sort of keys would that map have?
18:41:13 <CodeDmitry> haskell seems to define maps as foreach, whereas I'm used to them being mutable hash tables
18:41:16 * jfischoff wishes he knew more about all things linear
18:41:23 <CodeDmitry> it makes me angry and confused
18:41:33 <johnw> CodeDmitry: there is 'map' the function and 'Map' the data type
18:41:35 <Eduard_Munteanu> CodeDmitry: that's more like Data.Map, the latter.
18:41:36 <SamanthaD> cmccann: Hmm... maybe I could put that a year or two down my "will maybe get to" list. Definitely don't want to see that kinda thing in core haskell but as an extension...
18:41:38 <cmccann> mutable hash tables are the worst idea to ever become popular in programming
18:41:55 * elliott thinks you're definitely confused, at least.
18:41:56 <preyalone> What can I use in place of an IO statement when no action needs to be performed?
18:41:58 <Eduard_Munteanu> Don't confuse the noun with the verb.
18:42:12 <shachaf> CodeDmitry: Haskell is not what you're used to. I'm sorry.
18:42:12 <Eduard_Munteanu> The former has different meanings as well.
18:42:13 <ijp> cmccann: I dunno, they are up against some pretty steep competition
18:42:17 <johnw> preyalone: return ()
18:42:23 <cmccann> jfischoff: I can talk at great length about linear logic if there's anything you're wondering :D
18:42:24 <shachaf> CodeDmitry: You'll have to learn new things, things that you're not used to, to learn Haskell.
18:42:24 <bbloom> johnw: Eduard_Munteanu: maybe, i dunno... was just curious, since i often spend too much time trying to decide the order of arguments for things to best facillate currying or composition
18:42:27 <CodeDmitry> I accept your apology
18:42:38 <ijp> PHP being the obvious example
18:42:39 <preyalone> johnw: And I can use this anywhere in my code, or only at the end of functions?
18:42:41 <CodeDmitry> I still am trying to cram the idea into my head, it just hurts
18:42:45 <shachaf> I'm not apologizing.
18:42:57 <shachaf> I'm offering my condolences.
18:42:58 <johnw> preyalone: it can happen anywhere that an IO a is needed
18:43:04 <preyalone> :)
18:43:13 <cmccann> ijp: PHP? I was talking about programming :P
18:43:15 <CodeDmitry> You haskell guys really like clearing ambiguities
18:43:19 <ijp> cmccann: touche
18:43:21 <johnw> CodeDmitry: hahah
18:43:23 <Eduard_Munteanu> bbloom: Agda for example lets you name arguments, although you still have to preserve the ordering.
18:43:23 <CodeDmitry> that's why I'm learning it in part...
18:43:25 <johnw> CodeDmitry: you noticed that? :)
18:43:31 <applicative> shachaf is unique in that he didn't have to learn anything new.
18:43:43 <shachaf> shachaf is unique in that he didn't have to unlearn anything.
18:43:47 <shachaf> He knew nothing to begin with.
18:43:49 * johnw fondly remembers an hour long discussion with shachaf about clarifying the meaning of undefined
18:43:50 <Eduard_Munteanu> bbloom: the order still seems relevant, how is composition going to work?
18:44:05 <shachaf> johnw: I like to leave its meaning undefined.
18:44:12 <AfC> Stupid question: using {atto,}parsec, how useful are <?> annotations? I just added a bunch trying to debug a problem, only for none of them to "show up"
18:44:17 <cmccann> SamanthaD: one of these days I'm going to make a Haskell-like language where linearity is the default and you have to explicitly mark things as able to be duplicated or discarded :D
18:44:20 <ion> undefined = undefined
18:44:21 <AfC> (an exception is being thrown from deeper in)
18:44:22 <ion> That’s fine.
18:44:22 <applicative> 'undefined' is the least meaningful expression in Haskell
18:44:42 <applicative> AfC: are you using parseTest ?
18:44:55 <AfC> I think I thereby established that it wasn't my code, but I don't really know, hence question.
18:45:17 <applicative> or what function are you running the parsers with?
18:45:23 <Eduard_Munteanu> There are some qualitative differences between undefined = undefined and undefined as something the RTS can bail out on at runtime.
18:45:36 <cmccann> > fix error -- this is much more meaningful
18:45:38 <AfC> applicative: not in this case, no
18:45:38 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:45:39 <CodeDmitry> so a Functor is anything you can use a foreach over? (map over?)
18:45:57 <shachaf> CodeDmitry: Are you reading any one introduction to Haskell?
18:45:58 <SamanthaD> cmccann: Would there be any real advantage to that?
18:46:02 <Eduard_Munteanu> CodeDmitry: fmap
18:46:07 <AfC> applicative: (I am in other tests)
18:46:14 <CodeDmitry> yeah, i still don't get diff between map and fmap
18:46:18 <bbloom> Eduard_Munteanu: no clue, that's why i was curious if anyone had ever thought this same thought and explored it :-)
18:46:23 <Eduard_Munteanu> CodeDmitry: map is a special case of fmap
18:46:26 <shachaf> SamanthaD: cmccann likes to do crazy type system things. Don't mind him.
18:46:30 <Eduard_Munteanu> :t fmap
18:46:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:46:33 <Eduard_Munteanu> :t map
18:46:35 <lambdabot> (a -> b) -> [a] -> [b]
18:46:36 <cmccann> SamanthaD: it would make static reasoning about resource use the default, much like lack of side effects is the default in Haskell
18:46:42 <shachaf> SamanthaD: (Note: We all like to do crazy type system things. Don't mind any of us.)
18:46:45 <elliott> cmccann: I know a guy who works on a compiler from a functional language with an affine type system to hardware(!)
18:46:46 <Eduard_Munteanu> map is fmap for f = []
18:46:47 <elliott> it's pretty cool
18:46:56 <cmccann> elliott: neat!
18:46:57 <shachaf> elliott: Who/what?
18:47:02 <CodeDmitry> map over null? O_o
18:47:11 <SamanthaD> cmccann: I approve of that!
18:47:31 <ion> @type (!)
18:47:32 <lambdabot> Ix i => Array i e -> i -> e
18:47:45 <elliott> cmccann: ...also the language is an Algol derivative
18:47:56 <Eduard_Munteanu> CodeDmitry: [] means lists
18:48:13 <CodeDmitry> isn't [] == ""?
18:48:14 <Eduard_Munteanu> [a] = [] a
18:48:19 <CodeDmitry> oh
18:48:21 <Eduard_Munteanu> CodeDmitry: at value level yes.
18:48:28 <Eduard_Munteanu> But here we're talking types.
18:48:38 <Eduard_Munteanu> I know, the terminology is a bit overloaded.
18:48:38 <cmccann> elliott: interesting. perhaps it could be the first algol derivative to actually improve on algol!
18:48:44 <SamanthaD> CodeDmitry: Yes. [] == ""
18:48:54 <elliott> cmccann: https://sites.google.com/site/thegeometryofsynthesis/, https://sites.google.com/site/thegeometryofsynthesis/language if you're interested
18:49:03 <elliott> note that the compiler has an unfortunately draconian license
18:49:11 <elliott> you have to agree to give away your first-born etc. just to get the download link
18:49:17 <SamanthaD> CodeDmitry: String is just syntactic sugar for [Char]
18:49:28 <CodeDmitry> I understand that, it's similar to C
18:49:30 <AfC> applicative: I guess I'm asking "do they hurt" or "do they actually help, or are they just handholding or the unaware?"
18:49:33 <CodeDmitry> but more type safe
18:49:42 <cmccann> elliott: ugh. why do people do that. :[
18:49:45 <M30W> mapM_ (forkIO . (>>= \(h,_,_) -> hClose h) . (accept =<<) . listenOn . PortNumber . fromInteger) [1024..2000] -- Is there any way that could be cleaner? without lenses =)
18:49:55 <elliott> cmccann: it was out of his hands and into the lawyers'
18:49:56 <rdesfo> In GHCI does haskell have something like R's '?<function>', besides :type or :info?
18:50:00 <SamanthaD> elliott: I don't like using any compiler with a license more restrictive than LGPL if I can possibly help it!
18:50:07 <ion> m30w: Yes: make it more pointful.
18:50:25 <CodeDmitry> i tried typing [] 1 into ghci, and it didn't work
18:50:26 <M30W> ion: Why points? D:
18:50:31 <edwardk> not sure why those didn't link to the user accounts
18:50:31 <CodeDmitry> :|
18:50:33 <cmccann> elliott: oh, so no human beings were involved in the decision then.
18:50:35 <edwardk> er wrong channel
18:50:37 <ion> m30w: You wanted it to be cleaner, didn’t you?
18:50:43 <Eduard_Munteanu> M30W: split that up into a   forM_ [1024..2000] $ \a -> do   and multiple statements
18:51:22 <M30W> Heh
18:51:31 <preyalone> Is there a way to reference TVars by name? I'd rather not have to pass around the TVar to every little dippy function in my threads.
18:51:40 <M30W> right to left, almost pointfree works. :)
18:51:51 <cmccann> preyalone: use ReaderT?
18:51:53 <Eduard_Munteanu> preyalone: use ReaderT then
18:52:08 <Eduard_Munteanu> It takes care of passing around an environment.
18:52:11 <preyalone> Is ReaderT in the stm package, or something else?
18:52:21 <Eduard_Munteanu> @index ReaderT
18:52:21 <lambdabot> Control.Monad.Reader, Control.Monad.RWS, Control.Monad.Reader, Control.Monad.RWS
18:52:31 <applicative> AfC: does parseTest (string "a" <?> "an a") "d" give you ' ... expecting an a"
18:52:40 <Eduard_Munteanu> mtl or base, not sure.
18:53:00 <Eduard_Munteanu> In any case, you almost certainly have it.
18:53:28 <applicative> AfC: for me it says "parse error at (line 1, column 1): unexpected "d" ; expecting an a"
18:53:39 <CodeDmitry> Can functors be explicitly created, or are functors an abstract entity?
18:53:41 <applicative> which is kind of useful....
18:54:14 <Eduard_Munteanu> CodeDmitry: you make Functors == you make instances of the typeclass Functor
18:54:30 <AfC> applicative: actually, it gives Fail "d" ["an a"] "Failed reading: takeWith"
18:54:33 <AfC> (huh)
18:54:42 <Eduard_Munteanu> CodeDmitry: and yeah, you normally write them yourself, although 'deriving' might do too.
18:54:46 <applicative> data CodeDmitry a = Code a | Dimitri a ; instance Functor CodeDmitry where fmap f (Code x) = Code (f x); fmap f (Dimitri y) = Dimitri (f y)
18:55:10 <shachaf> CodeDmitry: The answers to your questions, as well as background needed to understand those answers (which it looks like you don't yet have) are covered in many introductions to Haskell.
18:55:14 <shachaf> Are you reading any?
18:55:32 <AfC> applicative: (this is #%&^ attoparsec, with it's decision to not track useless information like position)
18:55:43 <applicative> aaah
18:56:17 <AfC> applicative: I'm guessing a <?> *is* happening, but perhaps further in.
18:56:26 <CodeDmitry> I am reading many, but I have issues understanding abstract concepts
18:56:37 <AfC> anyway, if so, that would seem to say "<?> annotations are useless if working in attoparsec"
18:56:38 <CodeDmitry> At least without using them
18:58:42 <message144> Hi, if i call (sqrt foo) multiple times from within different functions where "foo" is the same list, does the ghc compiler only compute it once, knowing the computed value for each time afterwards?
18:59:17 <Eduard_Munteanu> message144: not necessarily, it depends
19:00:02 <applicative> AfC: if I do parseTest (string "a" <?> "an a") "d" I get "Fail "d" ["an a"] "Failed reading: takeWith" "
19:00:04 <Eduard_Munteanu> You probably have to provide more detail.
19:00:09 <cmccann> elliott: oh btw. johnw was nice enough to upload these to hackage for me, so now you can use Bicrosswalk in all your projects!!
19:00:21 <cmccann> just imagine the possibilities.
19:00:27 <cmccann> there are so many of them.
19:00:31 <applicative> AfC: which is admittedly less informative.  Maybe what it is thinking of as failing, isn't something with a <?> ?
19:01:09 <elliott> cmccann: oh boy
19:01:11 <message144> Eduard_Munteanu, i am just trying to figure out the best way to structure a small program im working on.. trying to decide if i should calculate (sqrt foo) once, then pass the result to various functions, or if it is ok to just calculate it in the various places i need it so i dont have to pass it around evrerywhere
19:01:27 <elliott> cmccann: possibilities like, um...
19:01:30 <message144> Eduard_Munteanu, its for a Project Euler question
19:01:32 <AfC> applicative: yeah. I'll leave the annotations out for now. Thanks.
19:01:32 <elliott> cmccann: the possibilities that there are
19:01:59 <cmccann> elliott, yes exactly. those possibilities which are all out there, being incredibly possible and stuff.
19:02:23 <applicative> message144: sqrt doesn't act on lists exactly.  There are devices to arrange that such a thing is calculated once; if it's cheap though why worry
19:02:27 <Eduard_Munteanu> message144: if 'foo' can be shared, then probably so will 'sqrt foo' if defined and bound to a name within an appropriate scope.
19:03:08 <preyalone> Is ReaderT threadsafe, or should I use ReaderT to access a TVar?
19:03:09 <Eduard_Munteanu> message144: for example take  bar = sqrt 2
19:03:11 <message144> applicative, oh woops.. i did not mean list. i meant integer.
19:03:17 <applicative> AfC I don't see anything in the docs about <?> adding a performance penalty, the possibility is written into the Fail type. But who knows
19:03:19 <Eduard_Munteanu> That definition seems likely to be shared.
19:03:32 <cmccann> preyalone: ReaderT gives you an immutable environment, there's nothing to be thread-unsafe there
19:03:38 <Eduard_Munteanu> preyalone: sure, it's just parameter passing
19:04:02 <Eduard_Munteanu> @unmtl ReaderT (TVar Int) IO ()
19:04:02 <lambdabot> TVar Int -> IO ()
19:04:13 <cmccann> if one of those immutable values happens to be a TVar then you can use that from various places as you'd expect
19:04:27 <applicative> > let bar = sqrt 3.3 in bar + bar + bar
19:04:29 <lambdabot>   5.449770637375485
19:04:40 <preyalone> Ah, so I would HAVE to pass a TVar. I've decided to try writing a simple actor framework, and there's a need to refer to a global table of ThreadId -> Chan a 's
19:04:57 <applicative> > (sqrt 3.3) + (sqrt 3.3) + (sqrt 3.3)
19:04:58 <lambdabot>   5.449770637375485
19:05:28 <applicative> ^^ in the second case it is calculated three times unless there is a rare intervention of 'common subexpression elimination'
19:05:40 <Eduard_Munteanu> preyalone: you just don't do it explicitly, except when you run the ReaderT thing.
19:05:53 <Eduard_Munteanu> :t runReaderT
19:05:54 <lambdabot> ReaderT r m a -> r -> m a
19:06:21 <Eduard_Munteanu> So you just provide that value for 'r' once.
19:06:21 <applicative> message144: pardon pointless brackets (sqrt 3.3) above...
19:07:34 <message144> applicative, ok... this "common subexpression elimination" is a new term for me. i suppose that gives me something interesting to research.
19:07:34 <Eduard_Munteanu> Though IIRC, CSE can also go against sharing.
19:07:47 <preyalone> Hmm... Can I fork a dummy thread, retrieve its ThreadId, then actually give it something to do?
19:08:06 <cmccann> preyalone: if you have some suitable way of communicating with it, sure
19:08:17 <Eduard_Munteanu> message144: it's a common compiler optimization, it does exactly what the name says: looks for expressions that occur multiple times and eliminates the redundant occurences.
19:08:35 <preyalone> cmccann: That's just it: I'm writing an actor framework, so there is no way to communicate with it yet.
19:08:37 <shachaf> preyalone: You probably shouldn't use ThreadIds.
19:08:49 <shachaf> They're only useful for "exceptional" things.
19:09:06 <preyalone> shachaf: How would you emulate Erlang/Scala's ability to ! messages to process IDs?
19:09:08 * Eduard_Munteanu can't think of an example where CSE kills sharing off the top of his head, hm.
19:09:09 <applicative> message144: if you use something expensive many times in a definition then f = g (expensive + h expensive) where expensive = .... will end up calculating it once.
19:09:12 <elliott> shachaf: Exceptional things like making sure all your threads are killed at the appropriate times. :(
19:09:17 <elliott> Eduard_Munteanu: it can cause space leaks
19:09:36 <preyalone> aye.
19:09:37 <applicative> message144: since it's the same as f = (\expensive ->  g (expensive + h expensive) ) ...
19:09:38 <shachaf> preyalone: Use a channel.
19:09:40 <edward> Hi, anyone know the semantics of copyPlane from Xlib?
19:10:01 <message144> Eduard_Munteanu, applicative: ok, that gives me a good start i think. thank you
19:10:34 <preyalone> shachaf: Right. I'm making a framework such that users can send messages to an agent (thread), by using the thread ID. Channel lookups will happen in the background.
19:10:36 <Eduard_Munteanu> elliott: which is a symptom of too much (long-lived) sharing, after all?
19:10:47 <elliott> Eduard_Munteanu: sure
19:10:54 <shachaf> preyalone: I'd probably make my own abstraction rather than use ThreadId.
19:11:03 <shachaf> There's no guarantees that ThreadIds are anything.
19:11:20 <cmccann> sure there is. they're guaranteed to be ThreadId values.
19:11:34 <cmccann> well, either that or _|_.
19:11:35 <shachaf> cmccann: But what does it denote?!
19:11:51 <shachaf> In Hugs ThreadId =  ()
19:11:52 <cmccann> shachaf: a ThreadId value obviously geez cmon shachaf.
19:11:57 <preyalone> I need to start with something, and ThreadIDs are intuitive (and good to grab in case of memory leaks, need to kill/restart threads, etc)
19:12:09 <shachaf> preyalone: In Hugs, ThreadId = ()
19:12:15 <edward> I am trying to fix line, https://github.com/victoredwardocallaghan/xmobar/commit/54d072dff7c65528d7d913df84b99406e08f5dbf#L1R67
19:12:28 <cmccann> people use Hugs? D:
19:12:28 <JoeyA> Who uses Hugs anymore?
19:12:31 <preyalone> Does Hugs even have multithreading?
19:12:38 <shachaf> Sure.
19:12:50 <Eduard_Munteanu> Heh.
19:12:52 <preyalone> Let's focus on GHC for now. I'll add Hugs compatibility if I ever get this to work in the first place.
19:13:19 <shachaf> The point is, don't use ThreadIds.
19:13:23 <JoeyA> If they do, they'll need to get the network package working on Hugs again.
19:13:24 <cmccann> "let's assume GHC and worry about other stuff later" -- ah, the hackage motto
19:13:53 <JoeyA> (among other things, I'm sure)
19:13:59 <cmccann> wait, no. that should be "let's assume a recent GHC" instead.
19:14:37 <cmccann> nobody uses ancient versions of GHC like 6.12 anymore, right?
19:14:43 <preyalone> Imagine you're in charge of writing an agent framework. How do you implement the ability for agents to communicate to each other based on some identifiable trait that doesn't require passing around all sorts of variables?
19:15:04 <JoeyA> Data.Unique ?
19:15:14 <cmccann> preyalone: the point is you should be finding a nicer way to pass around variables :P
19:15:16 <JoeyA> I.e. generate a unique identifier for each agent.
19:15:18 <preyalone> A globally accessible HashMap ThreadId (Chan a) seems like the most intuitive answer.
19:16:16 <JoeyA> Should work fine for GHC.  If this won't work for other Haskell implementations, then don't export the representation.
19:16:26 <preyalone> cmccann: I don't mind passing around a global table in the background, using ReaderT in the framework. But it's a bit much to require users downstream to manually pass ALL channels to ALL agents.
19:17:26 <preyalone> So...
19:17:39 <Eduard_Munteanu> preyalone: use another communication primitive, something that lets multiple listeners and writers to use a single channel.
19:18:06 <preyalone> I can either create and add a new channel, mapped to the thread id, when an agent is spawned, OR, i can perform a check-and-create-if-necessary to all send and receive calls.
19:18:59 <preyalone> Something I forgot to ask: Do Control.Concurrent.Channel's allow multiple readers and/or writers?
19:21:22 <JoeyA> Control.Concurrent.Chan, you mean?
19:21:35 * cmccann wonders why not use TChan
19:21:56 <preyalone> Grr. I can't think of how to obtain a thread ID for a new agent without actually forking it. I can see an edge case where I've spawned the agent, but I haven't actually inserted its channel into the global lookup table, so when the agent tries to receive messages, it can't find which channel it should listen on.
19:22:00 <Eduard_Munteanu> Www.4Chan.Org :P
19:22:23 <preyalone> cmcann: How does TChan differ from Chan?
19:22:32 <JoeyA> You can write to a Chan from multiple threads.  They'll just be writtein in some order.
19:22:34 <cmccann> preyalone: the same way TVar differs from IORef
19:22:50 <preyalone> What's an IORef
19:23:01 <preyalone> TVar is threadsafe IORef?
19:23:02 <JoeyA> err, the items will be written to the same stream.
19:23:08 <cmccann> sort of
19:23:14 <cmccann> I mean, there's more to it than just thread-safe
19:23:14 --- mode: ChanServ set +o mauke
19:23:15 --- mode: mauke set -b *!*@176.96.167.187
19:23:16 <Eduard_Munteanu> preyalone: a mutable container
19:23:26 <cmccann> but IORef is kinda the opposite of thread-safe
19:23:38 <shachaf> IORef is thread-safe for some meanings of thread-safe.
19:23:48 <preyalone> JoeyA: "some order" is perfect for agent mailboxes.
19:24:17 <cmccann> and TChan is a channel that you can read and write transactionally the way you can use TVar
19:24:31 <Eduard_Munteanu> Back when I wondered in kernel land we worried about lots of things wrt thread safety.
19:25:00 <cmccann> thread safety is basically a non-issue using STM, it's nice
19:25:03 <preyalone> Hmm, not sure I understand. If TChan is transactional, why would anyone ever use Chan?
19:25:09 <Eduard_Munteanu> So when I see 'atomic' in Haskell I don't really know what it means :/
19:25:15 --- mode: mauke set -o mauke
19:25:15 <cmccann> preyalone: slightly more efficient I assume. also, older.
19:25:48 <Eduard_Munteanu> Apparently you never get garbage when doing single reads / single writes.
19:26:02 <cmccann> preyalone: in your case (don't care about message order, &c.) you probably would actually be fine with just Chan
19:26:06 <preyalone> But I'm still not sure how semantically/behaviorally TChan and Chan differ. To me, Chan implies a multithreaded environment and therefore requires Chan to be threadsafe and low overhead.
19:26:08 <Eduard_Munteanu> So it's thread-safe at least in that sense.
19:26:13 <cmccann> I tend to use STM everywhere for thread interaction by default though
19:26:29 <preyalone> Does TChan maintain the original order, while Chan does not guarantee the same order?
19:26:53 <shachaf> No.
19:27:01 <cmccann> preyalone: with TChan, you can have multiple operations, on multiple channels or involving TVars &c., and be sure that the whole thing is atomic
19:27:11 <cmccann> and no race conditions or deadlocks possible
19:27:34 <oio> i am getting this bug  in ghc while tryng to run a wxhaskell program on ghci
19:27:36 <preyalone> Could you have deadlocks on Chans alone?
19:27:49 <hpaste> oio pasted “GHC BUG” at http://hpaste.org/81045
19:28:01 <cmccann> preyalone: if two threads are waiting on each other to send something with Chan then yes
19:28:34 * Eduard_Munteanu wonders if there's any general-purpose (not just kernel-only) lockdep implementation that you could run your program against.
19:29:05 <preyalone> Assuming each agent has one channel for receiving messages, and uses some sort of global lookup table to send messages to other agents, could that result in deadlock?
19:29:06 <Eduard_Munteanu> (lockdep is something that proves deadlock-safety)
19:29:23 <cmccann> preyalone: beats me! reasoning about concurrency is hard.
19:29:27 <cmccann> that's why I just use STM and not have to worry :P
19:30:19 <preyalone> cmcann: Agents are a natural way to express MapReduce. STM could be a component of that.
19:30:23 <cmccann> preyalone: that said, actor-based systems are a model that tries to make concurrency more understandable and sorta solve the same problem STM does
19:30:51 <preyalone> Yeah, the fact that they're related only makes things more confusing for me..
19:31:03 <cmccann> so you're not really going to benefit from it as much because you're explicitly solving the same problem in a different way
19:31:17 <preyalone> I see that the Hackage "actors" package gets no love since pre-GHC 7.
19:31:48 <cmccann> preyalone: I don't think actor-based stuff ever really caught on much in Haskell
19:31:53 <cmccann> especially once STM was around and stable
19:32:10 <cmccann> which is a pity, because it's a neat way to do things
19:33:09 <cmccann> preyalone: anyway, you probably don't really need TChan for what you're doing
19:33:29 <preyalone> Okay.
19:33:35 <cmccann> I tend to use STM by default in case I do want it later
19:33:53 <cmccann> it's largely the same API so you could convert your code easily if you wanted to
19:34:05 <cmccann> if you're using TVars then you're already using STM anyway
19:34:55 <preyalone> Let's pretend that new threads always get ThreadIds exactly one more than the current thread count or last ThreadId created. How can I obtain this value?
19:35:27 <shachaf> Why are you pretending things that are both untrue and will make your life complicated?
19:35:55 <cmccann> preyalone: do you have your current code uploaded anywhere? it's hard to point you in the right direction without knowing what you're working with.
19:36:17 <preyalone> shachaf: Because I need to setup the channel vs threadid table before i let an agent run, because otherwise it might try to read from a channel that doesn't exist yet.
19:36:18 <cmccann> but I'm pretty sure you're heading down a blind alley somewhere here and things more difficult than they need to be
19:36:53 <shachaf> I recommend not using ThreadIds at all. Forget about ThreadIds in general. They're only useful for specific things.
19:37:09 <cmccann> in particular, there's probably no reason you can't initialize everything in one go, and start the agent with all the channel stuff it needs.
19:37:17 <preyalone> Is STM isomorphic to agents? If they are, I'm not sure how I would transform a MapReduce problem into an STM problem.
19:37:28 <cmccann> no, they're very different
19:37:51 <cmccann> just different angles of attack on the same problem, namely the fact that concurrency is a pain in the ass
19:38:07 <preyalone> cmccan: I suppose I could use PretendIDs, starting at 0, and create a channel for each agent that way.
19:38:38 <preyalone> Do not try and bend the thread, that is impossible.
19:39:52 <elliott> I doubt you need IDs.
19:40:55 <cmccann> preyalone: it might help to consider "setting up communication channels" and "routing messages between agents" as separate problems.
19:41:15 <cmccann> the former you want to do at the same time you create the thread.
19:41:26 <cmccann> the latter you can figure out after the fact if necessary.
19:41:30 <CodeDmitry> the amuse bouche repository on github is pretty practical :)
19:41:32 <preyalone> Messages require some mapping between senders/recipients. Call them IDs, names, addresses, whathaveyou.
19:42:11 <preyalone> Without any mapping, users downstream would have to manually pass all the channels between their agents.
19:42:29 <cmccann> preyalone: yes, but that doesn't have to be tied to starting up a thread
19:42:45 <shachaf> Why not just pass channels around when you need to send messages to them?
19:43:13 <shachaf> I mean, otherwise you'll be passing a ThreadId around, and then look it up in your table, and send a message to the channel.
19:43:35 <cmccann> preyalone: would a small code example of what I have in mind help?
19:44:00 <preyalone> shachaf: The send and receive functions could lookup-and-create-if-necessary, but that's unnecessary overhead, when the channels should have been made at spawn time.
19:44:17 <preyalone> cmccann: :) Please.
19:44:43 * hackagebot pandoc 1.10.0.4 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.10.0.4 (JohnMacFarlane)
19:45:04 <shachaf> What?
19:46:22 <preyalone> Can someone point me to a nice tutorial on using ReaderT to setup and check "global" variables, because the API is quite terse.
19:46:56 <geekosaur> preyalone, maybe a shift in conceptualization will help.  pass a list of channels; think of the channel *as* the thread id, if that's all ypu're using the thread id for
19:47:10 <bergmark> preyalone: check real world haskell
19:47:41 <preyalone> geekosaur: Not a bad idea. But it would be nice to be able to print out / have a mnemonic for the channel. Hence, Pids likd in Erlang.
19:48:47 <preyalone> geekosaur: Plus, when you're spawning agents left and right, how do you, after the fact, learn about the new channels in the agents spawned early?
19:49:12 <geekosaur> how do you learn about the new thread IDs?
19:49:15 <preyalone> You'd have to implement a private messaging system just for the channel list, and you're back at the original problem.
19:49:50 <preyalone> geekosaur: Let's say the first agent wants to communicate with the 50th created agent. How does the first agent learn the 50th agent's channel?
19:50:13 <geekosaur> how does it learn that there are 50 agents?  or that it needs to talk to the 50th?
19:51:01 <preyalone> geekosaur: How does an agent refer to another agent, _at all_, without some sort of naming convention, i.e., ID system?
19:51:10 <geekosaur> (I am not simply throwing your questions back at you; either there is information that I missed or you didn't tell us, or you are assuming thread IDs have some property that lets you find out about them somehow... and Haskell threads don't necessarily work that way)
19:51:33 <Eduard_Munteanu> preyalone: one possible resolution is "you never need to refer to specific agents".
19:51:45 <elliott> preyalone: ThreadIds aren't predictable enough to use as a naming system in this sense anyway.
19:51:46 <preyalone> geekosaur: :) No worries. It's hard for me to express why IDs are necessary. They're not only intuitive, I believe they're crucial to the implementation of agents.
19:51:47 <Eduard_Munteanu> So stuff like the 50th agent might not be relevant.
19:51:48 <elliott> i.e. you have no guarantees over them.
19:52:02 <geekosaur> ^^
19:52:04 <preyalone> Eduard_Munteanu: When an agent sends a message, where does it go?
19:52:27 <preyalone> elliott: Fair enough, so I'll use incrementing PretendIDs.
19:53:22 <geekosaur> but now you have to pass that around as well, and make sure everything can find it... remember, no globals you can refer to
19:53:32 <geekosaur> *mutable* globals that is
19:53:34 <preyalone> Has anyone here used Erlang? I'm trying to implement spawn, send, and receive. That's it.
19:53:43 <johnw> geekosaur: *cough* State monad
19:53:44 <preyalone> geekosaur: ReaderT.
19:54:01 <Eduard_Munteanu> preyalone: presumably you have some peer discovery mechanism like broadcasts "who has resource X".
19:54:01 <shachaf> Stonad.
19:54:08 <geekosaur> and if you passed a state to a new thread, how do you uupdate it from another thread?  State is not mutable in the sense of procedural mutables
19:54:11 <preyalone> A ReaderT pointing to a TVar storing the ID -> Chan lookup table.
19:54:27 <johnw> ah, then ReaderT like preyalone said
19:54:34 <preyalone> Eduard_Munteanu: That would require a message passing system, which I'm trying to implement.
19:54:58 <Eduard_Munteanu> preyalone: might work with a bus-style channel
19:55:18 <geekosaur> ok, so we're back to IDs.  or possibly we're just using a list of Chans and *no* id, and the index into the table is your fake ID
19:55:24 <Eduard_Munteanu> preyalone: if the message contains the intended destination encoded in it.
19:55:40 <preyalone> Eduard_Munteano: What's a destination?
19:55:47 <preyalone> For now, I'm using IDs.
19:56:33 <Eduard_Munteanu> preyalone: you'd just reply back to whoever sent you a message, that way you don't need to keep a list of all possible agents around.
19:57:13 <preyalone> Eduard_Munteano: How do you send the _first_ message, if there is no address system?
19:57:24 <Eduard_Munteanu> preyalone: broadcast
19:57:30 <geekosaur> preyalone, you are frustrated because erlang comes with message passing libraries.  there may well be something already on hackage to do what yoju want to do, but as you
19:57:49 <geekosaur> ve only spoken in generalities it's hard to tell exactly what you are trying to do or what libraries might be appropriate
19:57:51 <preyalone> geekosaur: Yes, the agents package that doesn't work in GHC 7.
19:57:57 <Eduard_Munteanu> preyalone: you send a message anyone can reply to.
19:58:17 <Nolrai25> So if i wanted to do a simple graphical tic tack toe program in haskell what libraries should I use for I/O?
19:58:23 <preyalone> Eduard_Munteanu: How do you send the broadcast message when there is no address system?
19:58:48 <preyalone> Keep a global list of Chans and write to all of them?
19:58:55 <preyalone> It wouldn't solve the problem, anyway.
19:59:15 <Eduard_Munteanu> preyalone: maybe you don't want a Chan.
19:59:29 <Playground> Is there any way to bootstrap the cabal-install's install script (bootstrap.sh) in such a way that it installs the documentation for its dependencies?
19:59:43 <preyalone> Eduard_Munteanu: What would you use for threads to communicate?
20:00:15 <Eduard_Munteanu> Dunno, I'm not sure.
20:00:51 <Eduard_Munteanu> It's not a big problem anyway, as you can abstract it behind some API.
20:01:31 <preyalone> I'm looking at the ReaderT docs, and I have no idea how to use it. I'd like to keep a context available to several functions, so that the user isn't required to manually pass the context around.
20:01:56 <preyalone> I guess I'm supposed to create my own custom monad, like Random, but I'm not sure how to do that yet.
20:02:23 <Eduard_Munteanu> > flip runReaderT 5 $ do { x <- ask; return (x + 1) }
20:02:24 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
20:02:24 <lambdabot>    arising from a use of `M21001704...
20:02:26 <Nolrai25> Reader does that.
20:02:44 <Eduard_Munteanu> > flip runReader 5 $ do { x <- ask; return (x + 1) }
20:02:46 <lambdabot>   6
20:03:06 <Eduard_Munteanu> Works similarly for ReaderT.
20:03:50 <preyalone> Nolrai25: I think that I should jump start the reader with a default binding, then let the user write the agent body after a dollar sign.
20:03:54 <Eduard_Munteanu> preyalone: so any  ReaderT Integer SomeMonad a  typed function can just use 'ask' to inspect the environment.
20:04:03 <fragamus> ugh
20:04:23 <fragamus> i need some kind of foldWhile
20:04:33 <Nolrai25> preyalone: I have no idea what you mean.
20:04:39 <preyalone> Go home, fragamus, you're drunk.
20:04:45 <Eduard_Munteanu> fragamus: fold f . takeWhile g?
20:05:03 <Eduard_Munteanu> fragamus: alternatively   takeWhile g . fold f   :)
20:05:48 <Eduard_Munteanu> (erm, add the starting value there, but you get the idea)
20:06:08 <preyalone> Nolrai25: I've noticed a code pattern. RVar and Curl and friends have a getShitStarted thing that you call, and then you write your code, and your code runs inside the framework. I need to implement this, but I don't know how.
20:07:06 <Eduard_Munteanu> preyalone: you could make an Agent monad to abstract certain operations.
20:07:41 <preyalone> Eduard_Munteanu: Aye sir. I just don't know how to make a monad yet.
20:08:24 <preyalone> I want my agent framework to work like startFramework <your code> endFramework, if that makes sense.
20:08:40 <Eduard_Munteanu> :t bracket
20:08:41 <lambdabot>     Not in scope: `bracket'
20:08:41 <lambdabot>     Perhaps you meant one of these:
20:08:41 <lambdabot>       `brackets' (imported from Text.PrettyPrint.HughesPJ),
20:09:15 <Eduard_Munteanu> preyalone: that's pretty easy, if all you want is to run some code before and after it.
20:09:55 <Eduard_Munteanu> But I thought you might want agent code to access certain operations.
20:10:12 <preyalone> I want everything in the <code body> middle part to be able to access the ReaderT environment.
20:10:53 <Eduard_Munteanu> preyalone: ok, for start, let's not hide things.
20:10:58 <preyalone> Only the framework would need to access the ReaderT environment, but I don't mind if the user code wants access too.
20:11:40 <Eduard_Munteanu> Then all you need to do is ask the user to write   ReaderT Env SomeMonad a  functions.
20:11:45 <preyalone> Eduard_Munteano: Believe me, I don't want to make anything private. It's a real pain to use hscurl or whatever when the developer hid the UserAgentString customization methods.
20:12:45 <preyalone> Eduard_Munteano: Not quite. I'm only invoking ReaderT, because I need a way for agents to lookup channels based on IDs. Without a ReaderT, users would have to manually do this, and that's crap that should be done in the background, hence, a framework.
20:13:40 <Eduard_Munteanu> Well, you could hide that ReaderT behind some wrapper.
20:13:43 <preyalone> I understand that ReaderT can relieve the end user of the burden of manually passing around the TVar that holds the Map ID (Chan a)'s.
20:14:24 <preyalone> Because the STM developers didn't see fit to allow named TVars.
20:14:44 * hackagebot blink1 0.1 - Control library for blink(1) LED from ThingM  http://hackage.haskell.org/package/blink1-0.1 (DylanSimon)
20:14:49 <geekosaur> wat
20:15:06 <Eduard_Munteanu> I concur with geekosaur.
20:15:08 <Eduard_Munteanu> wat
20:15:32 <Eduard_Munteanu> preyalone: if you want to associate "names" to the TVars, you can do it yourself.
20:16:00 <Eduard_Munteanu> Think   Map String (TVar Something)
20:16:18 <preyalone> Yes, I am doing that. Because I've got to solve two problems: 1) How do I create an address scheme for agents to use channels? 2) How does an agent lookup channels in the address table?
20:16:59 <preyalone> Eduard_Munteano Map String (TVar a) would be enough, but I don't want downstream users to have to pass the map around. They might as well pass the TVar around in that case.
20:17:16 <shachaf> Strings are awful.
20:17:53 <monochrom> Map Address (TChan Stuff). use a suitable type for Address
20:19:01 <preyalone> Yes. And finally, ReaderT, because passing around the address hashmap in the user's agent code is awful.
20:19:41 <preyalone> Shit, but I bet the user would still have to pass around the reader context anyway... Back to square 2.
20:20:04 <preyalone> If you could just name TVars...
20:24:15 <geekosaur> you really are wedded to this global namespace thing, aren't you?  you're not going to be at all happy working with Haskell
20:24:59 <preyalone> geekosaur: Heh. But seriously, how do you refer to IO channels between agents without some sort of address scheme?
20:25:21 <shachaf> If you want someone to write to a channel, give them the channel.
20:25:31 <shachaf> I think people have said this a few times before. What's wrong with it?
20:25:54 <preyalone> How do you "give" an agent a channel?
20:26:18 <shachaf> How do you "give" an agent an address?
20:27:05 <preyalone> shachaf: When an agent is created, it is forked as a thread, thereby earning a thread ID. For all intents and purposes, let's assume this is also its address.
20:27:45 <shachaf> As long as by thread ID you don't mean ThreadId.
20:27:50 <preyalone> You have to manually grant the thread a Chan, and a Chan is just a thing in RAM.... But you can send a message to an agent by targetting what you do have, which is the agent's ID.
20:27:50 <shachaf> I already said not to use ThreadId.
20:27:57 <preyalone> shachaf: lol
20:28:08 <shachaf> Hilarious.
20:28:09 <geekosaur> so you still think there's a g;obal regoistry of thread IDs you can work with
20:28:15 <shachaf> Why do you have the agent's ID?
20:28:16 <preyalone> shachaf: Scala and Erlang use ThreadID, so it can't be that bad.
20:28:18 <shachaf> Where did you get it?
20:28:25 <shachaf> OK, this is fruitless.
20:28:28 <preyalone> geekosaur: If I implement one, yes.
20:28:44 <preyalone> I'm sorry that we're talking in circles. I don't know how to phrase what I'm after.
20:28:44 <Eduard_Munteanu> preyalone: you could store a bunch of Chans in a IORef, send it over a Chan, put it in an MVar etc..
20:28:48 <monochrom> I don't know whether you will understand this. but I always do: forkIO (f param1 param2 param3 param4). f is a loop. param1 may be a channel that f needs, param2 may be an IP address that f needs. etc etc
20:29:36 <preyalone> monochrom: This only works if you have a fixed number of channels to work with. It doesn't scale to 1,000,000+, dynamically created agents.
20:29:50 <geekosaur> if you implement one, yes.  but then you keep looping back to this "give TVars a name" thing because you really want there to be a magic global registry somewhere
20:29:59 <preyalone> monochrom: In other words, agents should be allowed to spawn further agents.
20:30:15 <Eduard_Munteanu> preyalone: so what's the problem?
20:30:42 <preyalone> Try implementing Erlang-style agents, just spawn(), send(), and receive(), without some sort of address system.
20:30:55 <monochrom> I don't understand why my scheme does not scale
20:31:21 <preyalone> It's really convenient to be able to send messages to named agents without worrying about "channels", i.e., framework-internal stuff.
20:31:29 <shachaf> Named how?
20:31:30 <shachaf> With a String?
20:31:32 <monochrom> I also don't understand why my scheme implies a fixed number of channels
20:31:39 <preyalone> named with some sort of naming scheme.
20:31:41 <Eduard_Munteanu> Chans already name themselves.
20:31:46 <shachaf> Strings don't scale.
20:31:52 <shachaf> You can't remember 1,000,000 strings
20:32:03 <monochrom> yeah, string is the does-not-scale one
20:32:05 <preyalone> monochrom: Let's start with your code. f param1 param2 param3 param4 implies exactly four (fixed) channels..
20:32:16 <preyalone> Let's extend this to N channels: f params.
20:32:29 <isomorphic> What's the name for the (<-) operator?
20:32:32 <isomorphic> bind?
20:32:38 <preyalone> Now you have an arbitrary number of channels, but they must be known ahead of time; i.e., agents would not be able to spawn new agents with new channels.
20:32:43 <Eduard_Munteanu> isomorphic: it's not an operator
20:33:10 <Eduard_Munteanu> It's syntax.
20:33:11 <isomorphic> Eduard_Munteanu:  That would explain my lack of progress finding out its type in ghci ;)
20:33:21 <Eduard_Munteanu> Heh.
20:33:26 <preyalone> Where an agent is thing that blocks on its channel, waiting for a message to act on.
20:33:44 <Eduard_Munteanu> isomorphic: see how do-notation desugars
20:33:45 <preyalone> Optionally sending messages to agents as part of its computation.
20:33:50 <isomorphic> Eduard_Munteanu:  So the type on either side of it is preserved?
20:34:28 <monochrom> ok, I have not seen a good design that gives 100000 channels to one single thread, as opposed to 1 channel for 1 thread and have 100000 threads. but if you insist, use an array or something for param1
20:34:29 <Eduard_Munteanu> isomorphic: y <- f x; g y   ===   f x >>= (\y -> g y)
20:34:37 <wbruce> I'd like to wrap a value in the IO monad for an HUnit test (without doing any actual IO); any pointers?
20:35:03 <johnw> wbruce: return?
20:35:09 <preyalone> monochrom: An array would be a particularly bad choice, because again, fixed number of channels is undesirable.
20:35:28 <preyalone> wbruce: return <value>
20:35:40 <preyalone> liftM value or whatever
20:35:44 <monochrom> why is array fixed?
20:35:53 <Eduard_Munteanu> How about a list.
20:35:54 <wbruce> johnw: I thought the same; not sure where I'm screwing up (but obviously I am) -- will investigate some more ;-) thanks!
20:35:59 <Eduard_Munteanu> s/\./?/
20:36:01 <preyalone> That's the definition of an array.
20:36:13 <isomorphic> Eduard_Munteanu:   Does "===" mean equivalent?
20:36:29 <Eduard_Munteanu> isomorphic: yeah, not actual notation or anything
20:36:29 <monochrom> not in haskell
20:36:44 <isomorphic> Eduard_Munteanu:  No, that makes sense -just making sure I understand
20:36:51 <preyalone> monochrom: Anyhow, how would you update this container to include new channels for new agents?
20:37:00 <preyalone> And how would the agents access this container?
20:37:03 <johnw> it's not just equivalent, it *is* that
20:37:23 <preyalone> Some sort of global data structure is required in order to implement message passing to arbitrary recipients.
20:37:30 <wbruce> maybe I'm confused because return "foo" :: Monad m => m [Char], not IO specifically
20:38:01 <sandmonster> new to haskell here, is this allowed?        let sum, difference = addsub 1 2 where addsub x y = (x+1, y-1)    to assign values to multiple variables, if not what would be the best way to do this?
20:38:02 <Eduard_Munteanu> wbruce: that's the most general type for that expression
20:38:06 <dolio> I, for one, don't believe you need 100,000 threads each communicating arbitrarily with every other thread.
20:38:37 <preyalone> dolio: That's what an agent system does.
20:38:56 <dolio> I didn't say it couldn't be done.
20:39:00 <dolio> I said I don't believe you need it.
20:39:06 <preyalone> It maps well to such things as BitTorrent clients, or HTTP servers.
20:39:07 <shachaf> wbruce: return "foo" :: IO [Char] too.
20:39:10 <preyalone> Or databases.
20:39:14 <wbruce> Eduard_Munteanu: and the type system can infer the more specific fact I'm looking to build IO "foo", I'm guessing
20:39:19 <isomorphic> preyalone:  Reminds me of this - http://xkcd.com/350/
20:39:51 <monochrom> there are several HTTP servers written in haskell and none has your structure
20:39:51 <Eduard_Munteanu> wbruce: yeah, it also depends where you actually put that expression
20:39:53 <preyalone> Yeah, agents could implement that.
20:40:33 <monochrom> there is also a bittorrent client written in haskell too and it doesn't seem to have your structure
20:40:44 <preyalone> monochrom: HTTP servers by and large don't need the threads to communicate with each other, just the web server and the web client. It's a subset of agenthood.
20:41:04 <preyalone> I never said agents were the only way of doing these. I just said they're a natural way of doing them.
20:41:06 <Eduard_Munteanu> I think he's trying to do Erlang-ish stuff.
20:41:28 <preyalone> I.e., "spawn an agent that does X" where X is handle an HTTP client request.
20:41:32 <preyalone> Yes.
20:41:54 <monochrom> "natural" is language-dependent
20:42:19 <preyalone> Haskell can do 90% of the agent behavior without any additional code. It just doesn't have message passing between addressable agents.
20:42:26 <monochrom> go to C and "select" is "natural" there. not agent. not thread. not objects
20:42:54 <monochrom> now go to ##c and grill them for not scaling for 100000 agents
20:43:22 <Eduard_Munteanu> Actually 100000 doesn't sound like a really large number.
20:43:29 <hpaste> “C. McCann” pasted “kind of horrible example of running agents” at http://hpaste.org/81046
20:43:36 <cmccann> preyalone: sorry, had to run AFK for a bit there
20:43:41 <preyalone> forkIO (doTheCoolThing someData) is great. I just want to add the ability for doTheCoolThing to output its computational results to a specific otherThing, and loop.
20:44:07 <Eduard_Munteanu> (So even with pthreads, I expect decent computers should do that)
20:44:21 <cmccann> the hpaste'd code there is kind of ugly but it's along the lines of what I'd actually do
20:44:23 <preyalone> Yeah, I wrote a basic forkbomb/0 in Erlang, and the little guys didn't even slow down my CPU.
20:44:41 <cmccann> (e.g. I wouldn't use String everywhere for real code)
20:44:45 * hackagebot hquery 0.1.0.1 - A query language for transforming HTML5  http://hackage.haskell.org/package/hquery-0.1.0.1 (TychoAndersen)
20:44:49 <isomorphic> Hrmm.. another silly question.  I have an IO String that will be an argument to a constructor I've made that takes a String parameter.    I think I could do an unsafePerformIO to turn it back into a String.  However, what's the way I ought to be thinking to keep everything in IO?
20:45:19 <Eduard_Munteanu> preyalone: well, I guess they're green threads, so the only thing that happens is the process grows in size.
20:45:45 <preyalone> C. McCann, that's exactly what I'm looking for!
20:45:51 <geekosaur> lift the constructor into IO instead.  see fmap / liftM
20:46:19 <johnw> isomorphic: f <$> yourIOString, typically
20:46:19 <Eduard_Munteanu> Con <$> ioAction
20:46:51 <cmccann> preyalone: sorry for all the rough edges there, some helper functions would cut down on the extra noise for pulling things from the AgentEnv and whatnot
20:47:07 <preyalone> The last bit I'd like to do is wrap the "asks inbox" and such calls so that as far as user-written agents are concerned, there's just spawn, send, receive, and some sort of Pid naming system for channels.
20:47:33 <Eduard_Munteanu> preyalone: for that you can implement your own monad
20:47:33 <cmccann> preyalone: yeah, that wouldn't be hard at all.
20:47:49 <preyalone> I don't believe it is, I'm just not sure how to make monads.
20:48:57 <edwardocv> X programming in Haskell is horrible, I wish the binding was to XCB instead of libX
20:49:18 <geekosaur> there's an hcb package, I think
20:49:37 <isomorphic> I'm a bit lost as to how that works in the named parameter format, eg:   Con { x = "A", y = "B"}  - where does the fmap go?
20:49:43 <geekosaur> that said, if you;re the person trying to add icon support to xmobar, you can't use hxb with xmobare
20:50:46 <Eduard_Munteanu> isomorphic: then you probably want to approach it differently.
20:50:59 <Eduard_Munteanu> strA <- ioAction
20:51:09 <Eduard_Munteanu> strB <- someOtherIoAction
20:51:30 <Eduard_Munteanu> let foo = Con { x = strA, y = strB }
20:51:58 <isomorphic> Eduard_Munteanu:  I'm seeing now.   That figures from the earlier discussion about '<-'
20:52:03 <isomorphic> Thanks
20:52:31 <Eduard_Munteanu> You could also do  Con <$> ioAction <*> someOtherIoAction   but that brings in applicative stuff
20:53:14 <Eduard_Munteanu> And relies on the fact record syntax reduces to normal constructor application.
20:53:49 <preyalone> cmccann: startAgent shouldn't need the user to come up with addresses on his own; the framework should automatically generate new addresses when the user calls spawn.
20:53:51 <isomorphic> Eduard_Munteanu:  At this stage I'm trying to get more comfortable with monads by trying to use them, so I'll get this straight and then likely come back and revisit
20:54:47 <cmccann> preyalone: personally I prefer naming things explicitly in this case, but ok.
20:55:03 <isomorphic> I'm assuming that your example above is the IO action equivalent of Con StrA StrB ?
20:55:26 <preyalone> cmccann: The Pids will be used explicitly by the user's agent code, but obtaining a Pid for each agent should be automatically done.
20:55:55 <Eduard_Munteanu> isomorphic: as you can see, when you have   y <- f x; ...   if  f x :: m a  then  y :: a  right where those dots are.
20:56:55 <Eduard_Munteanu> But you shouldn't think of '<-' as taking out a value from the monad.
20:57:52 <isomorphic> Eduard_Munteanu:  How should I best think of it?
20:58:35 <Eduard_Munteanu> The best way is probably to understand it in terms of (>>=) and lambdas.
20:58:43 <CodeDmitry> What's the closest language to Haskell?
20:58:50 <isomorphic> Eduard_Munteanu: Thanks :)
20:58:59 <johnw> isomorphic: <- is binding an intermediate value to a name
20:58:59 <CodeDmitry> I heard it's Clojure.
20:59:18 <monochrom> I heard SHE
20:59:36 <shachaf> Haskell.
20:59:42 <Eduard_Munteanu> shachaf++
21:00:10 <monochrom> there is also disciple
21:00:16 <mikeplus64> CodeDmitry: one of the MLs? miranda?
21:00:20 <johnw> agda isn't so far away
21:00:23 <plhk> idris
21:01:07 <CodeDmitry> I like Haskell, but I really hate haskell examples and explanations with a passion
21:01:42 <jfischoff> we know
21:01:42 <lambdabot> jfischoff: You have 1 new message. '/msg lambdabot @messages' to read it.
21:01:47 <jfischoff> @messages
21:01:47 <lambdabot> shachaf said 2h 12m 28s ago: cmccann isn't in #-blah, so I doubt those messages will get through.
21:02:00 <cmccann> ...
21:02:04 <johnw> CodeDmitry: I felt similarly once
21:02:10 <jfischoff> hey
21:02:11 <johnw> it was me that needed to change
21:02:37 <CodeDmitry> I mean I love the idea of writing expressive code, but I hate the idea of writing code you can only explain with mathematical/haskell jargon
21:02:49 <jfischoff> cmccann: I meant to ask you for links for learning linear logic and linear lambda calculus
21:03:18 <cmccann> jfischoff: I really only have like three, all of which are pretty obvious
21:03:18 <plhk> CodeDmitry: lyah explains stuff like you're five
21:03:40 <CodeDmitry> you can't explain things to people with over 8 years of hobbyist experience as if they were 5, they get bored
21:03:41 <jfischoff> lay them on me
21:03:46 <Eduard_Munteanu> CodeDmitry: you might like the idea you're finally using a modern programming language, or something that doesn't rely heavily on 70s principles.
21:04:03 <shachaf> Haskell uses 80s principles instead.
21:04:15 <monochrom> you cannot avoid mathematical jargon. "function" and "integer" are mathematical jargon. you say them all the time for C
21:04:20 <Eduard_Munteanu> Well, perhaps, but not quite.
21:04:24 <Eduard_Munteanu> Miranda != Haskell.
21:04:26 <cmccann> jfischoff: http://en.wikipedia.org/wiki/Linear_logic http://ncatlab.org/nlab/show/linear+logic http://plato.stanford.edu/entries/logic-linear/
21:04:39 <Maxdamantus> But they don't relate to mathematical functions and integers in C :\
21:04:41 <shachaf> monochrom: At least in C you abuse those terms to the point that they're almost unrecognizable.
21:04:48 <CodeDmitry> computer science will never change... "
21:04:48 <CodeDmitry> All non-trivial abstractions, to some degree, are leaky.
21:04:48 <CodeDmitry> "
21:05:09 <johnw> CodeDmitry: the mathematical concepts are more fundamental; by learning them you learn to think about the root abstraction more directly.  For example, a monoid is at the heart of what it means for things to be "combinable, plus a unitary element".  You can avoid talking about Monoids, and talk about "appending" instead (and indeed one person felt it should be called Appendable), but then you'll miss the connections to arithmetic, and
21:05:09 <johnw> other cases where Monoids can't really be understand as an "append" operation
21:05:33 <CodeDmitry> I agree, mathematical thinking is fundamental to making good solutions, mathematical thinking is TERRIBLE for explaining ideas.
21:05:43 <johnw> well, I have no real debate with you there :)
21:05:45 <shachaf> I don't know what mathematical thinking is.
21:05:53 <mm_freak> CodeDmitry: not if both think mathematical
21:06:03 <Maxdamantus> > dropWhile (/= 0) [(1 :: Integer)..]
21:06:06 <lambdabot>   mueval-core: Time limit exceeded
21:06:12 <Maxdamantus> > dropWhile (/= 0) [(1 :: Int)..]
21:06:15 <lambdabot>   mueval-core: Time limit exceeded
21:06:16 <mm_freak> CodeDmitry: in this channel you will find that ideas are often expressed by pasting a type with no explanation at all =)
21:06:21 <Eduard_Munteanu> Ignoring previous knowledge and a common, succint language only makes explaining worse.
21:06:39 <johnw> CodeDmitry: have you ever heard of the book, "Elements of Programming"?
21:06:40 <CodeDmitry> that is a problem, not all types are self explanatory.
21:06:47 <CodeDmitry> I believe I have
21:06:48 <Eduard_Munteanu> Now sure, not everybody knows math, but not everybody is a programmer either.
21:06:50 * shachaf stops reading #haskell before getting too rude.
21:07:01 <mm_freak> CodeDmitry: the types are…  it's just not immediately apparent what the possible values are
21:07:08 <johnw> it's by Stepanov, the author of the C++ STL
21:07:29 <johnw> anyway, the book is based on C++, but in it he aims to explain fundamental data structures and algorithms in terms of their mathematical foundations
21:07:32 <Eduard_Munteanu> Mundane stuff like pointers haunt lots of people.
21:07:45 <johnw> and even the book jacket says, "This is not an easy book."
21:08:06 <edwardocv> geekosaur: Can you give me your views on this so far https://github.com/victoredwardocallaghan/xmobar/blob/master/src/Plugins/Icons.hs
21:08:23 <CodeDmitry> That's why I learn haskell, to leave dealing with pointers and fun stuff, to a point where I already know what i'm trying to do makes sense.
21:08:40 <CodeDmitry> So that after debugging, I know reasoning behind it is solid.
21:08:58 <johnw> from the Preface: "This book applies the deductive method to programming by affiliating programs with the abstract mathematical theories that enable them to work."  Well, I think Haskell just lets you learn these kind of fundamental more directly, from the beginning, at the price of a steeper learning curve
21:08:59 <Eduard_Munteanu> Ideally you don't debug, you just typecheck. ;)
21:09:09 <CodeDmitry> Not all bugs come from type issues.
21:09:49 <Eduard_Munteanu> True, though the types we use could be a lot more expressive.
21:09:57 <CodeDmitry> precisely
21:10:22 <CodeDmitry> Haskell code tends to force you to write code that makes sense, after that you can do whatever you want with ti
21:10:35 <mm_freak> CodeDmitry: ideally your bugs just cause system crashes from swap thrashing =)
21:10:39 <Eduard_Munteanu> Anyway, Haskell's pretty much the closest you can get to research stuff without starting to deal with practicality issues.
21:10:49 <johnw> yeah, Haskell type checking covers so many problems cases, that I always feel a little bit disappointed when it doesn't warn me at all when I've written an infinite recursion :)
21:10:57 <CodeDmitry> Actually my latest bugs came from algorithm trying to insert a string into a trie data structure in C
21:11:07 <johnw> Coq, by contrast, would never let me compile such a thing
21:11:12 <CodeDmitry> it wasn't a type issue, it was a misunderstanding of what a trie was between me and the data structure
21:11:42 <mm_freak> johnw: well, it tells you at runtime in many cases
21:11:59 <edwardocv> I hate working with bindings to C
21:12:00 <mm_freak> you probably have some traumatic memories of "<<loop>>"
21:12:05 <CodeDmitry> As a rule, you want to move as many bugs to compile time as possible
21:12:12 <CodeDmitry> runtime errors lead into using gdb, which is fun
21:12:12 <Eduard_Munteanu> CodeDmitry: more advanced type systems let you specify and check / prove certain invariants about your data structures. Like lists of a fixed length.
21:12:48 <Eduard_Munteanu> Or "non-empty lists".
21:13:37 <CodeDmitry> sadly, I can't test ideas in Haskell, haskell is more useful for initial design rather than fixing issues
21:13:44 * Maxdamantus sees explicit results (always in return values) as being fairly important too.
21:14:05 <CodeDmitry> that's kinda a problem :\
21:14:32 <mysticc> @hoogle (</>)
21:14:32 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
21:14:32 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
21:15:16 <johnw> Maxdamantus: you mean, always writing total functions?
21:15:23 <CodeDmitry> ?
21:15:26 <Maxdamantus> No.
21:15:28 <mm_freak> Eduard_Munteanu: "more advanced"?  than haskell?  because haskell can do what you just mentioned =)
21:15:51 <shachaf> mm_freak: Haskell lets you make a new type of non-empty lists.
21:15:53 <mm_freak> CodeDmitry: you seem to be implying that you can't do real-world development in haskell, which i couldn't disagree more strongly about
21:16:06 <shachaf> mm_freak: It doesn't let you pass someone a regular list along with a proof of nonemptiness.
21:16:11 <shachaf> Why am I still here?
21:16:12 <Maxdamantus> You always apply functions for their return values.
21:16:17 <edwardocv> How do I debug Major opcode of failed request:  62 (X_CopyArea) that is, arguments passed to XCopyArea from a haskell binding?
21:16:19 <CodeDmitry> Oh you can definitely do real world development in haskell, I mean you will have hell of a time checking existing systems with haskell
21:16:34 <simpson> CodeDmitry: Uh, have you written any Haskell yet?
21:16:41 <CodeDmitry> Nothing serious, no
21:16:43 <mm_freak> shachaf: data NonEmpty a = NonEmpty (a :| [a])
21:16:58 <shachaf> mm_freak: Yes. <shachaf> mm_freak: Haskell lets you make a new type of non-empty lists.
21:17:09 <mm_freak> isn't expecting a NonEmpty instead of a [] a proof?
21:17:15 <shachaf> That's not the same as foo :: (xs :: [a]) -> ProofOfNonEmpty xs -> ...
21:17:25 <mm_freak> i see
21:17:25 <CodeDmitry> I'd make something more serious, but I am having an ongoing war with cabal
21:17:27 <plhk> edwardocv: use xtrace to see what's going on
21:17:28 <monochrom> a while ago, chrisdone posted on google+ about arcane math jargon as he learned graph theory. I replied, essentially saying, yeah, you're replacing by arcane coding jargon, kettle calling pot black
21:17:47 <johnw> mm_freak: I think such a type represents a theorem; because able to write a function which accepts a NonEmpty list instead of [] would be a proof, right?
21:17:49 <mm_freak> shachaf: but that appears to me to be a curried version of what i just wrote
21:17:54 <mm_freak> shachaf: i don't see the difference
21:18:19 <monochrom> you go into a specialty subject, you must use jargon. "plain english" is too misleading
21:18:21 <edwardocv> xtrace, is that like strace but for x?
21:18:24 <edwardocv> let me see
21:18:32 <mysticc> Is there partitionM ?
21:18:43 <johnw> liftM partition :)
21:18:55 <johnw> or liftM2, I suppose
21:19:09 <shachaf> mm_freak: Let's say you have a type for prime numbers, and a type for Fibonacci numbers.
21:19:13 <CodeDmitry> I really want to install Gtk2Hs but I got no idea how >.>
21:19:22 <shachaf> mm_freak: Can you write a function that accepts a prime Fibonacci number?
21:19:27 <edwardocv> plhk: how do you make it use urxvt xtrace: line 173: xterm: command not found
21:19:37 <johnw> cabal install gtk2hs-buildtools cairo gtk
21:19:41 <edwardocv> silly X software :/
21:19:56 <johnw> that's what I always start with
21:20:50 <hpaste> “C. McCann” annotated “kind of horrible example of running agents” with “kind of horrible example of running agents (annotation)” at http://hpaste.org/81046#a81047
21:20:59 <cmccann> preyalone: I made a few modifications if you're interested
21:21:08 <plhk> edwardocv: i don't understand where xterm comes from :/
21:21:13 <preyalone> Yeah! I've begun hacking on the code as well.
21:21:39 <preyalone> For example, I want the structure of Message to be determined by the user, not by the framework.
21:22:15 <mm_freak> shachaf: what would be the type of the prime fibonacci number?
21:22:29 <cmccann> preyalone: yeah, I just made everything Strings for demonstration purposes, which is horrible. parameterizing it in the message type is the right way to go.
21:22:48 <shachaf> mm_freak: If you have a "number" type and a "proof" type, you might write a function like foo :: (x::Nat) -> ProofOfPrime x -> ProofOfFibonacci x -> ...
21:23:01 <johnw> cabal --builddir does not play well at all with cabal-dev :(
21:23:06 <johnw> thankfully, lndir comes to my rescue
21:23:16 <mm_freak> shachaf: so Prime and Fib are the same type?
21:23:18 <shachaf> ?
21:23:23 <mm_freak> Nat
21:23:25 <preyalone> cmccann: I'm trying to parameterize AgentEnv but I'm getting compile errors.
21:23:26 <shachaf> No.
21:23:43 <shachaf> ProofOfPrime :: Nat -> *
21:23:54 <shachaf> It's inhabited when its argument is prime.
21:23:57 <mm_freak> shachaf: the value, not the proof…  fibonacci and prime numbers have the same type, but there are extra types for the proofs…  is that what you mean?
21:24:18 <plhk> edwardocv: make sure you're using right xtrace, there's some other program (not related to X11) by that name
21:24:37 <preyalone> http://hpaste.org/81048
21:25:00 <shachaf> mm_freak: Yes, a number is just a Nat here.
21:25:13 <shachaf> You can pass a function just a regular number, and then pass it additional arguments for proofs about that number.
21:25:17 <monochrom> prime numbers may be too hard
21:25:23 <preyalone> Are Nat's finally builtin to modern GHC's?
21:25:27 <cmccann> preyalone: you'll need to parameterize a lot more than that, unfortunately
21:25:27 <shachaf> No.
21:25:41 <cmccann> @quote cmccann demote
21:25:41 <lambdabot> cmccann says: personally I'm just waiting for an extension that demotes types to the value level, so that we can finally have natural numbers.
21:25:55 <mm_freak> shachaf: seems quite possible to me
21:26:08 <edwardocv> plhk: lol, it does not even come with a man page or anything useful to indicate if I have the right tool from --help
21:26:47 <preyalone> cmccann: What does report do?
21:26:55 <edwardocv> plhk: does your come up with something like
21:26:56 <edwardocv> xtrace --help
21:26:57 <edwardocv> Usage: xtrace [OPTION]... PROGRAM [PROGRAMOPTION]...
21:26:58 <plhk> edwardocv: should say "xtrace: Dump all X protocol data being tunneled from a fake X display to a real one." for --help
21:26:59 <shachaf> mm_freak: ?
21:27:07 <cmccann> preyalone: in my example? prints to the console.
21:27:12 <edwardocv> plhk: ok, then its not righ
21:27:16 <cmccann> quick and dirty way to see what the agents are doing.
21:27:34 <plhk> edwardocv: http://xtrace.alioth.debian.org/
21:27:44 <preyalone> cmccann: Wouldn't putStrLn be sufficient?
21:27:48 <edwardocv> plhk: I need to find where they put it on arch
21:28:15 <cmccann> preyalone: it would, but note that I'm prefixing anything they print with the agent that printed it
21:28:22 <cmccann> you could do other stuff in there as well
21:28:28 <mm_freak> shachaf: squarePrimeFib :: Nat s -> IsPrime s -> (forall s'. Nat s' -> a) -> a
21:28:34 <preyalone> cmccann: Ah, that is useful.
21:28:56 <shachaf> There are remarkably few square primes.
21:29:13 <shachaf> Anyway, I don't remember what the discussion was about.
21:29:18 <shachaf> What's IsPrime?
21:29:20 <hpaste> “C. McCann” annotated “kind of horrible example of running agents” with “kind of horrible example of running agents (parameterized)” at http://hpaste.org/81046#a81049
21:29:30 <tac> shachaf: apparently, a type constructor
21:29:31 <cmccann> preyalone: there you go
21:29:33 <mm_freak> shachaf: no, it was an example…  it takes a prime fib and returns the square
21:29:49 <tac> taking prime numbers to the singleton type and composite (and unit) numbers to the empty type
21:29:59 <mm_freak> shachaf: in fact i left out the fibonacci requirement
21:30:10 <mm_freak> but i think that function demonstrates my (untested) approach
21:30:39 <shachaf> I think it kind of defeats the purpose.
21:30:41 <cmccann> preyalone: the general idea here is that startAgent can construct a bunch of pre-set actions for each agent to control how they interact, gets everything prepared, then uses that to make the ReaderT environment for the Agent
21:30:47 <mm_freak> the idea is that a function takes a Nat with a fully polymorphic 's' and proves a property about it
21:31:08 <CodeDmitry> can somebody make sense of this error? http://hastebin.com/godecixapo.vbs
21:31:11 <mm_freak> the good thing:  you can write Nat itself without ever knowing what properties will be proven about it
21:31:18 <mm_freak> you just add a type parameter 's'
21:31:20 <monochrom> vbs?
21:31:21 <cmccann> preyalone: also, addNewChannel is now a nice example of why STM lets you not worry about concurrency stuff
21:31:26 <shachaf> preyalone: Good job. You've bugged #haskell until they answered your question instead of telling you what question you *should* be asking.
21:31:35 <shachaf> I hope you're pleased with yourself. Few people reach this point.
21:31:55 <CodeDmitry> I'll get there someday...
21:31:58 <tac> should is a relative notion.
21:32:04 <shachaf> CodeDmitry: I very much hope not.
21:32:09 <cmccann> shachaf: that seems unnecessarily hostile :[
21:32:18 <shachaf> cmccann: Oh, I didn't mean it as hostile here.
21:32:22 <edwardocv> plhk: thanks I am giving it a go
21:32:24 <shachaf> preyalone: No hostility meant. I was amused.
21:33:11 <monochrom> to be fair, only one answered answered the unasked question
21:33:17 <CodeDmitry> I'm trying to install Gtk2Hs, and I get the following error: http://hastebin.com/godecixapo.vbs , can somebody explain what it means :|
21:33:19 <preyalone> shachaf: Believe it or not, I'm completely new to concurrency, Erlang, and actors. I just think they're cool and wanted to try my hand at porting them to Haskell.
21:33:35 <mm_freak> preyalone: why would you?
21:33:39 <shachaf> I believe it.
21:33:51 <shachaf> I think you'll figure it out. :-)
21:33:53 <Eduard_Munteanu> preyalone: you might be interested in http://www.haskell.org/haskellwiki/Cloud_Haskell
21:34:02 <cmccann> preyalone: take a look at addNewChannel and see how many potential race conditions that would have if it weren't transactional :D
21:34:29 <AfC> CodeDmitry: the Linux equivalent of those errors is "you need to install the -dev packages"
21:35:17 <preyalone> My professor has a Java test suite for finding race conditions that formed his PhD... Just port Haskell onto the JVM and run the test suite over Agency!
21:35:23 <CodeDmitry> I can bang my head and try to figure out how to set it up on my computer, but what if i'm stupid enough to want my friend to try out my program :|
21:35:31 <cmccann> haha, good luck with that :P
21:35:39 <edwardocv> plhk: good god, I have no idea what all this junk is that it tips out on the screen
21:37:02 <mm_freak> preyalone: i rather meant, why would you want actors in the first place?  we have better abstractions
21:37:40 <cmccann> preyalone: but since addNewChannel runs in a single STM transaction, it's guaranteed to not have race conditions or deadlocks if anything else modifies the same stuff, but doesn't stop other threads from reading from things
21:38:10 <preyalone> mm_freak: Better is a tad bit subjective. STM is really really awesome, and `parmap` is Heaven. But actors are an interesting, fairly intuitive way of framing some problems.
21:38:54 * cmccann also likes actors as a way of thinking about some problems
21:39:03 <mm_freak> preyalone: you have the building blocks to construct actors easily, but you don't want an actors library…  just use concurrency the way that fits your task best
21:39:45 <AfC> CodeDmitry: I assume you've followed the instructions for http://www.gtk.org/download/win32.php ? If you grabbed the "all in one bundle" then you should have the developer files installed.
21:39:58 <CodeDmitry> I have
21:40:06 <AfC> hrm
21:40:10 <CodeDmitry> i took the bundle, and put the bin folder into path
21:40:17 <preyalone> mm_freak: Actors are NOT easy to implement, or I would have already finished.
21:40:34 <preyalone> Thank goodness I can lean on STM and other tools as building blocks. It would suck to rely on semaphores.
21:40:55 <cmccann> they're easy to implement if you already know Haskell and how to make use of its existing concurrency tools!
21:41:07 * AfC really doesn't know much about Microsoft Windows®, sorry.
21:41:12 <preyalone> @type <$>
21:41:13 <lambdabot> parse error on input `<$>'
21:41:17 <mm_freak> preyalone: didn't you say that you are new to concurrency?  you might /find/ it difficult, because you lack the experience ;)
21:41:17 <preyalone> Shit.
21:41:20 <johnw> @type (<$>)
21:41:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:41:53 <preyalone> does this make sense? fromJust <$> lookup ...
21:41:56 <latermuse> cmccann: blacksmithing is easy after you are a master of blacksmithing
21:42:06 <cmccann> mm_freak: that's why I wrote a simple example instead of trying to talk preyalone out of going down blind alleys :P
21:42:13 <johnw> preyalone: i would not recommend it
21:42:19 <cmccann> preyalone: noooooo don't use fromJust :[
21:42:33 <johnw> preyalone: maybe valueIfNothing functionIfJust <$> lookup
21:42:37 <monochrom> and it's fromJust (lookup ...)
21:42:44 <johnw> or use fromMaybe defaultValue <$> lookup
21:42:46 <preyalone> cmccann: Then let's work on an incrementing ID system that guarantees that all agents have channels.
21:42:58 <AfC> CodeDmitry: but clearly pkg-config can't find what it needs to find. You may need to set an environment variable and/or tell cabal something. PKG_CONFIG_PATH or so.
21:43:12 <CodeDmitry> yeah I have not set PKG_CONFIG_PATH
21:43:24 <CodeDmitry> I'm getting libxml right now, but im not sure where I should path to
21:44:18 <preyalone> I went down a blind alley, picked up fromJust, and shot myself in the foot... Nope, nothing there.
21:44:37 <cmccann> preyalone: well, right now a channel is created at the same time the agent is started, so they'll always have one
21:44:45 <AfC> CodeDmitry: if you installed (you did, right) the all-in-one bundle then all that stuff should be in known places.
21:44:54 <mm_freak> cmccann: i see…  well, i'm done with him =)
21:45:00 <CodeDmitry> I can't install an all in one bundle, it's an archive
21:45:00 <cmccann> and note that it's even fine if the channel is written to before the agent is started--the contents will be there when it looks
21:45:21 <CodeDmitry> I can unpack it and set paths to it...
21:45:32 <preyalone> cmccann: Let's change findAgent :: Name -> Agent STM (Maybe (TChan Message)) to findAgent :: Name -> Agent STM (TChan Message), because there shouldn't be a case where you can't find a channel.
21:45:49 <plhk> edwardocv: i'll look into it
21:46:11 <cmccann> preyalone: but what if something has the id of an agent that has halted in the meantime?
21:46:15 <AfC> CodeDmitry: <http://jacob.stanley.io/2010/10/20/installing-gtk2hs-on-windows/>, <http://projects.haskell.org/gtk2hs/archives/2005/06/24/installing-on-windows/>, <http://www.haskell.org/haskellwiki/Gtk2Hs/Windows> may be relevant
21:46:24 <cmccann> handling failure modes is prety fundamental here.
21:46:29 <preyalone> I suppose there's the edge case of the user calling send infinity "Hi!", but in that case, we should raise an exception.
21:46:50 <preyalone> cmccann: The inbox should start filling up, but nothing address wise should fail.
21:46:53 <CodeDmitry> ill try, hopefully my paths won't confuse it further
21:47:44 <cmccann> trying to guarantee that someone is always listening to the message you send isn't really the right approach
21:48:15 <cmccann> preyalone: better would be to abstract over the TChan and instead only provide a generic "output". you don't want agents reading other people's mail anyway.
21:48:16 <preyalone> cmccann: Any chance you'd like to start hosting this code on GitHub? If we get a decent API up, I'd like to put it on Hackage someday.
21:48:22 <tac> cmccann: because it's impossible, right? :)
21:49:14 <cmccann> then if an agent is missing or dead or never existed or whatever, it could just give out a fake version
21:49:26 <cmccann> that discards the messages immediately or whatnot
21:49:49 <CodeDmitry> now the installer wants me to install an outdated compiler >.>
21:49:57 <preyalone> cmccann: Wanna put your code on GitHub so we can submit patches to each other?
21:50:16 <cmccann> preyalone: nah, I need to go to bed soon
21:50:24 <preyalone> me too
21:50:36 <cmccann> and to be honest I have too many projects of my own to develop this much
21:50:42 <preyalone> Maybe we would have finished earlier if we had simply updated the official Hackage actors lib for GHC 7
21:50:49 <cmccann> actor stuff is interesting but not really useful to me at the moment
21:51:04 <preyalone> Not doing any "big data"?
21:51:25 <cmccann> I don't think that's a terribly official package. it also doesn't seem that great to begin with.
21:52:01 <cmccann> you're more than welcome to do what you want with my example code though
21:52:03 <preyalone> Well, your API is half decent, and you bothered to include a real working example unlike 99% of libraries out there.
21:52:21 <preyalone> I'll annotate it cmccann, not sure of your real name.
21:53:06 <cmccann> preyalone: this is me on github, incidentally: https://github.com/isomorphism
21:53:38 <preyalone> Cool. This is me. https://github.com/mcandre
21:53:51 <preyalone> peace
21:55:33 <CodeDmitry> Must resist urge to ragequit haskell
21:55:46 <CodeDmitry> The library support is so terrible ...
21:55:46 <shachaf> Must resist urge to ragequit #haskell
21:56:07 <CodeDmitry> Its intentionally made to make people like me angry.
21:56:11 <isomorphic> I've just thrown up the code I've been working on - http://pastebin.com/hZzLLYHk (rather than hpaste) - my aim is to get the IO Text generated in evaluateCellFormula to be the y parameter in cellDisplay.  What am I doing wrong?   I'm trying to use the >>= as suggested by Eduard_Munteanu
21:56:16 <mauke> The paste hZzLLYHk has been copied to http://hpaste.org/81050
21:57:11 <CodeDmitry> I'll just consider haskell Malware from now on, and focus on the concepts rather than getting anything real written in it
21:57:19 <shachaf> So much for not putting it up on hpaste.
21:57:20 <TorosFanny> How to make a IO (a->b) from a->(IO b) or whether that's possible
21:57:31 <shachaf> TorosFanny: It is not possible.
21:57:36 <isomorphic> shachaf: ;)
21:57:43 <cmccann> TorosFanny: quite thoroughly impossible, I'm afraid.
21:58:04 <TorosFanny> why not?
21:58:27 <shachaf> TorosFanny: Consider putChar
21:58:33 <johnw> isomorphic: the probxlem is your Nothing case
21:58:34 <shachaf> foo putChar :: IO (Char -> ())
21:58:42 <cmccann> TorosFanny: try writing a function with the type "(a -> IO b) -> IO (a -> b)" and find out!
21:58:50 <johnw> unless the type of jsonToRepJson is IO Text
21:59:36 <johnw> isomorphic: what is the type of jsonToRepJson?
21:59:54 <mikeplus64> does anyone use "sum" records? like data A = A { x :: a, ... } | B { x :: a, ... }
21:59:55 <Cale> CodeDmitry: The problem from your paste seems to indicate that you don't have the development versions of the libraries you're installing the Haskell bindings to installed properly.
21:59:55 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
22:00:05 <Eduard_Munteanu> isomorphic: that looks fine wrt (>>=), however you probably need to 'lift' IO stuff.
22:00:24 <isomorphic> johnw:  I think it's the same as at the top - Handler RepJson ?
22:00:24 <johnw> ah, I missed that he's in Handler
22:00:24 <Eduard_Munteanu> isomorphic: erm, 'liftIO'
22:00:26 <CodeDmitry> I know but I had to jump through so many hoops, including the installer told me "oh, your lua installation conflicts with haskell, go fix that"
22:00:28 <cmccann> jfischoff: dunno if you're still around, but sorry for being distracted earlier. were those links helpful at all?
22:00:30 <johnw> oh?
22:00:41 <CodeDmitry> It should be much simpler, or at least clearer
22:00:45 <Cale> CodeDmitry: Since you're on Windows, I don't actually know what to do to fix the problem, but presumably installing those libraries would be a reasonable idea ;)
22:00:47 <jfischoff> cmccann: sure.
22:01:01 <CodeDmitry> Yes, uninstalling windows and installing ubuntu would fix the issues
22:01:05 <CodeDmitry> sadly I can't do that right now
22:01:06 <jfischoff> cmccann: although...
22:01:20 <CodeDmitry> or just installing virtualbox, but thats avoiding the issue
22:01:20 <SamanthaD> CodeDmitry: See, you figured out the solution all on your own!
22:01:21 <johnw> isomorphic: the code is expecting 'z' to be in Handler, not in IO
22:01:31 <CodeDmitry> brb sister woke up
22:01:48 <isomorphic> johnw:  So, liftIO z?
22:01:48 <johnw> i mean, you can't mix >>= between different Monads
22:01:54 <cmccann> jfischoff: I was continually vexed by a lack of clear explanation of what the multiplicative disjunction does, which seems nearly universal in anything explaining linear logic.
22:02:18 <johnw> yes
22:02:18 <jfischoff> cmccann: I am really interested in the connection that linear lambda calculus has to monodical categories. Specifically the category of finite hilbert spaces and other similar categories
22:02:24 <Eduard_Munteanu> isomorphic: no, you probably want to liftIO the whole 'case'.
22:02:43 <cmccann> jfischoff: the nlab article should say what the categorical structure of linear logic is
22:02:47 <isomorphic> Eduard_Munteanu: can you give me a bit of insight into what you looked at to see that?
22:02:47 <jfischoff> cmccann: I am still working at a high level on this stuff
22:02:49 <cmccann> it did last time I looked at it anyway
22:02:56 <johnw> Eduard_Munteanu: but jsonToRepJson isn't in IO
22:03:09 <Eduard_Munteanu> Oh, hm.
22:03:11 <jfischoff> cmccann: yeah and even if it said anything I probably wouldn't get that much out of it
22:03:25 <jfischoff> since my category theory isn't that great
22:03:35 <Eduard_Munteanu> isomorphic: do what johnw said then
22:03:36 <cmccann> jfischoff: but yes, it's a closed monoidal category with products and coproducts and a dualizing object
22:03:57 <cmccann> jfischoff: it's very much NOT cartesian closed, which may be surprising if you're used to Haskell and such
22:04:19 <jfischoff> cmccann: Right
22:04:20 * isomorphic plays Hindley Milner sudoku
22:04:25 <Cale> shachaf: I updated simple-reflect
22:04:27 <johnw> lol
22:04:36 <shachaf> Cale: Thanks!
22:04:41 <Cale> What's new?
22:04:46 <shachaf> Monoid instance.
22:04:47 <johnw> Cale: does you have a repo for your updated lambdabot?
22:04:47 <shachaf> > x <> y
22:04:51 <lambdabot>   x <> y
22:05:04 <edwardocv> anyone want to have a go with my icon support in xmobar?
22:05:06 <shachaf> > sumOf both (x,y)
22:05:09 <lambdabot>   x + y
22:05:09 <Cale> johnw: I haven't really done much of anything to update lambdabot
22:05:11 <shachaf> > foldlOf both (+) 0 (x,y)
22:05:13 <lambdabot>   0 + x + y
22:05:14 <shachaf> Er.
22:05:20 <shachaf> That doesn't need the monoid instance.
22:05:27 <edwardocv> I think I am getting close to it work
22:05:30 <shachaf> I was demonstrating, uh, dlists or something?
22:05:38 <shachaf> Cale: Anyway, thanks!
22:05:42 <cmccann> jfischoff: that said, I'm afraid I've not the slightest clue what the category of finite hilbert spaces is
22:05:52 <johnw> Cale: How do I get lambdabot to join a new channel?
22:05:58 <jfischoff> cmccann: I wonder how linear lambda calculus relates to bimonodial categories http://ncatlab.org/nlab/show/bimonoidal+category which finite hilbert spaces are
22:06:15 <jfischoff> among many other things
22:06:44 <Eduard_Munteanu> cmccann: Haskell? Did you have in mind a language where * is only a closed monoidal category?
22:06:46 <Cale> johnw: The command is @join <channel> if you mean your own lambdabot instance
22:06:58 <johnw> no, i mean "the" lambdabot
22:07:00 <Cale> johnw: If you mean lambdabot on freenode, just ask me
22:07:16 <johnw> calmbdabot
22:07:18 <Eduard_Munteanu> johnw: yeah, the command is   Cale: ... :)
22:07:26 <johnw> Cale: can you have him join #ledger?
22:07:36 <johnw> i have a feeling we're going to be discussing much more Haskell there soon
22:07:40 <cmccann> Eduard_Munteanu: a linear lambda calculus, i.e. something related to linear logic the way usual typed lambda calculi relate to intuitionistic logic
22:07:53 <Cale> okay
22:07:55 <plhk> edwardocv: sample config?
22:07:56 <Eduard_Munteanu> Oh, hm.
22:07:56 <isomorphic> Eduard_Munteanu, johnw : Thanks again :)
22:08:17 <Eduard_Munteanu> I should read up on linear logic first.
22:08:35 <jfischoff> me too
22:08:35 <cmccann> jfischoff: hm
22:09:30 <cmccann> jfischoff: with linear logic you get four kinds of monoidal structure to work with
22:09:40 <jfischoff> oh really
22:09:41 <cmccann> with two pairs where one distributes over the other
22:10:38 <wollw> I have a question about domain and range of functions and the number of possible functions that can exist.  I'm watching The Algebra of Algebraic Data Types and the lecturer mentions a function with three possible inputs (A, B, or C) that each map to a possible output (True or False).  He mentions there are 8 possible functions... I must be being really dense because I only see six possibilities...
22:11:13 <cmccann> jfischoff: you have conjunctions and disjunctions (i.e., logical and/or) along with additive and multiplicative
22:11:50 <cmccann> jfischoff: and multiplicatives distribute over the logically opposing additive
22:12:22 <cmccann> jfischoff: so if that's all there is to the stuff you're asking about then linear logic is that twice over :P
22:12:33 <jfischoff> yes it sounds like
22:12:38 <Eduard_Munteanu> wollw: take it another way... your function is completely defined by what it does to A, B and C.
22:12:47 <jfischoff> very cool
22:13:24 <cmccann> jfischoff: the two distributive pairs are also described as having positive or negative polarity
22:13:37 <Eduard_Munteanu> wollw: so I can represent each possible function as a triplet. Say the first one is (False, False, False)
22:14:33 <cmccann> jfischoff: computationally positive polarity is necessarily eager evaluation, while negative polarity is necessarily demand-driven lazy evaluation
22:14:45 <jfischoff> necessarily?
22:14:55 <cmccann> well, not necessarily I guess
22:15:09 <cmccann> but remember the linearity constraint
22:15:09 <Eduard_Munteanu> wollw: and I can count upwards just like in binary, the 2nd being (False, False, True) (or 001 if you like) etc. all the way up to (True, True, True)
22:15:32 <cmccann> if the type system requires you to use every piece of the input you're given, that's a big hint to the strictness analyzer
22:15:37 <Eduard_Munteanu> It's pretty straightforward to see you have 2^3 = 8 possible functions.
22:15:43 <jfischoff> huh
22:16:27 <cmccann> jfischoff: I'm guessing you somehow missed the last fifty times I've posted a link to my simple encoding of linear logic in Haskell?
22:16:45 <jfischoff> yes!
22:16:52 <cmccann> something I wrote as an intuition-building exercise for the computational content of linear logic
22:16:57 <cmccann> http://hpaste.org/75222
22:16:59 <wollw> Eduard_Munteanu: I'm still confused I'm afraid.  What would the type signatures look like?
22:17:14 * jfischoff is reading
22:18:03 <Eduard_Munteanu> wollw: say data Foo = A | B | C. Now your functions have the type Foo -> Bool.
22:18:14 <wollw> right
22:18:50 <wollw> and there would be two possibilities for each A, B, and C... one for true and one for false...
22:19:05 <wollw> that's the way i've been thinking at least
22:19:11 <wollw> but i'm obviously missing something
22:20:04 <Eduard_Munteanu> wollw: you don't add them up, you multiply them
22:22:52 <Eduard_Munteanu> wollw: say A and B are fixed, then you have two possibilities for C. If you let B vary, then you have 2 times as many possibilities. The same goes for A. Therefore 2 * 2 * 2.
22:23:18 <shachaf> cmccann: Intuition-building exercise?
22:23:24 <wollw> oh!
22:23:39 <cmccann> shachaf: yes?
22:23:41 <wollw> I was looking at it all wrong.
22:23:46 <shachaf> You don't need that in Haskell, do you? You need a linear-building exercise or something.
22:24:04 <wollw> Thanks Eduard_Munteanu
22:24:09 <cmccann> shachaf: I give that joke a 4.5/10
22:24:25 <shachaf> cmccann: It could've been done better.
22:24:31 <tac> Is it just me, or does it seem like there ought to be a monadic case expression?
22:24:45 <Eduard_Munteanu> wollw: write all possible combinations down, they're only 8, to see for yourself :)
22:24:52 <plhk> edwardocv: add  setForeground dpy gc pix
22:25:06 <wollw> Eduard_Munteanu: Yeah, I'm going to go do that. :)
22:25:08 <tac> having to do .... x <- myIOThing; case x of .... seems annoying. I don't want to name the intermediate expression "x"
22:25:10 <plhk> edwardocv: and you should be fine
22:25:17 --- mode: ChanServ set +o copumpkin
22:26:06 --- mode: copumpkin set +b *amathew*!*@*$##fixyourconnection
22:26:29 --- mode: copumpkin set -o copumpkin
22:27:12 <jfischoff> cmccann: very cool. I need to run it, but first I must return to my clifford algebra crap :p
22:27:30 <cmccann> jfischoff: that reminds me, I never finished that geometric algebra thing I was working on :[
22:27:53 <jfischoff> cmccann: that's what I am working on too!
22:28:02 <jfischoff> how far are you?
22:28:10 <cmccann> messy implementation crap
22:28:14 <jfischoff> yes
22:28:30 <cmccann> because hand-rolling everything was too horrible to consider and doing stuff on the fly is horrifically slow
22:28:39 <cmccann> which means happy fun TH time
22:28:57 <jfischoff> that's cool though
22:28:59 <cmccann> generating so many frickin multiplication tables, pain in the ass argh
22:29:08 <jfischoff> sound more advanced that what I am doing
22:29:18 <cmccann> what's your approach?
22:29:21 <jfischoff> I am not so concerned with speed now
22:29:27 <jfischoff> mostly trying to learn
22:29:53 <cmccann> I wanted an implementation of the conformal model for 3d space that was fast enough for at least simple stuff
22:30:07 <jfischoff> I am treating the multiplication as polynomial multiplication followed by a substitution based on the signature…or at least  that … if it is possible
22:30:21 <jfischoff> I think that works I not positive
22:30:37 <jfischoff> but it gave my an excuse to get my polynomial code in better shape some what
22:30:38 <cmccann> jfischoff: the tricky part is getting the sign flips right
22:30:56 <edwardocv> plhk: I think I am almost there, do you want to see.. I cleaned it up now
22:31:09 <jfischoff> cmccann: for reversions?
22:31:16 <edwardocv> plhk: https://github.com/victoredwardocallaghan/xmobar/blob/master/src/Plugins/Icons.hs
22:31:17 <jfischoff> or just in general
22:31:28 <shachaf> > rot13 "unfunpuns"
22:31:30 <cmccann> jfischoff: no, for normalizing the result of polynomial-style multiplication
22:31:30 <lambdabot>   "hashachaf"
22:32:12 <jfischoff> you mean when you have basis elements that have a negative squared value?
22:32:25 <cmccann> jfischoff: no, just in general, though that doesn't help either
22:32:55 <jfischoff> yeah well running into problems is part of how I intend to learn
22:33:00 <jfischoff> :p
22:33:25 <edwardocv> plhk: it compiles and runs but it does not work
22:33:32 <mm_freak> shachaf: did you actually pick your name as a rot13 of funpuns? ;)
22:33:33 <cmccann> jfischoff: given two products of basis elements, to normalize it to a no-duplicates consistent order you have to figure out how many times you have to swap two basis elements
22:33:44 <edwardocv> I can't see the little cat bitmap plhk
22:33:59 <cmccann> mm_freak: the frightening part is that that's his real name
22:33:59 <plhk> edwardocv: http://bpaste.net/show/5rEfruh34BJyNTmXp54L/
22:34:23 <cmccann> mm_freak: I'm still not sure I completely buy that, it's too convenient
22:34:52 <mm_freak> lol
22:35:09 <mm_freak> > rot13 "ertugrul"
22:35:11 <lambdabot>   "reghtehy"
22:35:58 <Eduard_Munteanu> That's a Turkish name, right?
22:36:00 <simpson> > rot13 "simpson"
22:36:01 <jfischoff> cmccann: right the anti commuting
22:36:02 <lambdabot>   "fvzcfba"
22:36:09 <simpson> Yep, doesn't mean anything.
22:36:23 <jfischoff> cmccann: totally forgot about that :p
22:37:30 <cmccann> jfischoff: e.g., consider e234 multiplied by either e14 or e24, and what the sign of the result will be
22:37:40 <cmccann> assuming all basis elements square to 1
22:38:05 <jfischoff> e234 = e2 * e3 * e4?
22:38:11 <cmccann> yeah
22:38:55 <cmccann> and e.g. e234 = -e324 = e342
22:39:06 <jfischoff> yeah
22:40:23 <tac> How do you get a string error message out of an IOError object?
22:40:35 <edwardocv> plhk: thanks, however its still not work. I committed the changes I have done
22:41:11 <jfischoff> well if you just multiply them you can get e234 * e14 = -e231 but you want to normalize the order right so you have -e123
22:41:13 <jfischoff> I think
22:41:17 <jfischoff> but one sec
22:41:53 <tac> @hoogle IOError -> String
22:41:54 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
22:41:54 <lambdabot> System.IO.Error ioeGetLocation :: IOError -> String
22:41:54 <lambdabot> System.IO.Error ioeGetFileName :: IOError -> Maybe FilePath
22:43:27 <plhk> edwardocv: it does
22:43:45 <jfischoff> cmccann: I wonder if there is a way to handle the sign changes as part monomial multiplication ?
22:43:51 <isomorphic> Can anybody give some intuition as to why sequence 'swaps' a IO (Maybe String) to an Maybe [IO String]  ? It doesn't seem evident from its type, sequence :: Monad m => [m a] -> m [a]
22:44:00 <plhk> edwardocv: you're drawing on the root window, it's covered by xmobar
22:44:09 <jfischoff> cmccann: if that would be some what efficient?
22:44:17 <edwardocv> plhk: Ah!
22:44:26 <cmccann> jfischoff: I think the most efficient way is just going to be computing a lookup table
22:44:30 <SamanthaD> Haskell classes remind me of object oriented objects in that they define functions for specific data structures. Someone smack me if being a noob, please.
22:44:38 <edwardocv> plhk: how do I get it to draw on top then?
22:44:48 <jfischoff> cmccann: I assume that would be dimension dependent
22:45:03 <jfischoff> err standard basis dependent
22:45:04 <tac> isomorphic: I think you have your types wrong there.. maybe?
22:45:18 <plhk> edwardocv: create a window, map it raised
22:45:20 <tac> There's no list in the first type sig you gave
22:45:44 <isomorphic> tac:  Maybe - the effect I've seen is the order of the IO and the Maybe get reversed
22:46:03 <cmccann> jfischoff: the anticommutative part is consistent, so you can pre-precompute that and then layer extra sign flips based on what the basis elements square to if you want
22:46:19 <edwardocv> plhk: so I have to create another window and overlay it with the xmobar one?
22:46:23 <cmccann> that part is easy to check if you e.g. use bitfields to store which basis elements something has
22:46:31 <edwardocv> plhk: sorry, I don't really understand the X protocal
22:46:49 <tac> isomorphic: sequence turns a list of commands into a command that returns a list.
22:46:56 <jfischoff> cool
22:46:56 <sw2wolf> SamanthaD: Maybe it is better to regard Haskell's class as interface in other language ...
22:47:12 <plhk> edwardocv: yes
22:47:20 <shachaf> SamanthaD: That's not how you use classes in Haskell usually.
22:47:32 <SamanthaD> sw2wolf: I'll look into it, thanks
22:47:47 <shachaf> SamanthaD: Some people do that but it'll probably make you unhappy.
22:47:54 <SamanthaD> shachaf: but if I really wanted to write in an OO way in Haskell classes is how I would do it
22:48:02 <shachaf> I suggest treating Haskell's classes as their own thing, without analogy to OO.
22:48:07 <shachaf> SamanthaD: Not necessarily.
22:48:12 <shachaf> You might just use a record.
22:48:15 <jfischoff> cmccann: do you have the code up?
22:48:26 <shachaf> Did you see the FAQ entry on this?
22:48:28 <cmccann> jfischoff: no, I wasn't happy with the API yet and got bogged down in TH cruft
22:48:38 <edwardocv> plhk: also should that be copyArea or copyPlane?
22:48:48 <isomorphic> tac:  That's true.  I guess it amounts to that kind of change.
22:48:56 <edwardocv> for what I am trying to do, I still dont fully get when to use each
22:49:11 <SamanthaD> shachaf: no, I haven't. I was just learning how to work with typeclasses and was unsure why you would bother with a class for datastructures you made when you could just write up some functions the old-fashioned way.
22:49:19 <cmccann> SamanthaD: the "correct" way to imitate OO style in Haskell is with a record corresponding to objects, with the record type itself being an "abstract base class"
22:49:47 <cmccann> and using smart constructors to stand in for concrete classes and their constructors
22:49:55 <isomorphic> I have mueval on 86 linux, and also on a mac - it's very slow on Linux.  Has anybody seen this behaviour?
22:50:01 <cmccann> type classes then correspond loosely to interfaces
22:50:05 <plhk> edwardocv: you have a bitmap => copyPlane it is
22:50:14 <SamanthaD> cmccann: I guess that makes sense. You'd want your objects to be stateful.
22:50:19 <jfischoff> cmccann: we should combine forces
22:50:20 <cmccann> not necessarily!
22:50:22 <plhk> edwardocv: i wonder if there's way to get xmobar's window id
22:50:29 <edwardocv> plhk: cool thanks
22:50:35 <cmccann> immutable objects are perfectly nice, even in languages that aren't Haskell.
22:50:51 <edwardocv> plhk: well I am not sure, because if I could that would make it easier right
22:50:54 <SamanthaD> cmccann: Well, believe me when I say I'm not trying to code objective haskell!
22:50:54 <johnw> i've still got an object from years ago laying around here somewhere...
22:50:58 <cmccann> jfischoff: is your code up anywhere? I can dig mine out and see if there's anything I can scavenge that might be useful for you
22:51:32 <shachaf> SamanthaD: I think Oleg has a paper about that...
22:51:49 <cmccann> SamanthaD: sometimes a OO-flavored style is the best way to do things, but trying to do everything with type classes isn't the way to implement it
22:51:50 <SamanthaD> shachaf: about implementing objects in Haskell?
22:51:55 <jfischoff> cmcann: its in the very early stages. I am still don't have multiplication. I can have it up some time this coming up week though
22:52:01 <jfischoff> cmccann: ^
22:52:25 <jfischoff> Ill ping you when it is up
22:53:13 <SamanthaD> cmccann: So... would it be fair to say "use typeclasses when the function returns a property of the data structure at hand?"
22:53:41 <edwardocv> plhk: will this work for me? https://github.com/victoredwardocallaghan/xmobar/blob/master/src/XUtil.hsc#L182
22:53:52 <SamanthaD> cmccann: For example, I'm currently coding a data structure that corresponds to a card and the card has a suit. I've written a class that has a function that calculates whether the suit is red or black.
22:54:26 <cmccann> SamanthaD: I'd mostly suggest not creating your own type classes until you're more familiar with the language
22:54:30 <plhk> edwardocv: yes
22:54:41 <shachaf> SamanthaD: That should probably just be a f unction.
22:54:53 <cmccann> they're very expressive but overusing them can create lots of headaches
22:55:06 <cmccann> if you can write something simple with a plain function, do that.
22:55:15 <SamanthaD> cmccann: And... promptly putting my knowledge of class definition on the back-burner.
22:55:30 <shachaf> SamanthaD: When people start out they have a tendency to try to use type classes for way too many things, from what I see in #haskell at least.
22:55:55 <SamanthaD> shachaf: Alright. So, what would be a really GOOD use of a typeclass, then?
22:55:57 <cmccann> type classes are for abstracting out common meaning where the details depend on the types
22:56:18 <cmccann> SamanthaD: the standard type classes are all good examples, with maybe a few exceptions, cough
22:56:28 <shachaf> I was going to say "the Prelude has good examples", but then I remembered all the classes in the Prelude.
22:56:33 <cmccann> have you seen the typeclassopedia?
22:56:42 <SamanthaD> cmccann: Ah, I see. So if I had two types of card decks but with similar functions that need to work on both I would use classes. Otherwise, I should avoid them!
22:57:00 <SamanthaD> cmccann: No, I haven't!
22:57:25 <shachaf> SamanthaD: Probably even in that case you wouldn't.
22:57:39 <shachaf> It depends on the specifics, I guess.
22:57:54 <SamanthaD> shachaf: But it would allow me to write generic functions of type Card a => a -> b
22:58:03 <cmccann> SamanthaD: possibly, with a deck of cards I suspect everything could be simply parametric or specialized
22:58:19 <shachaf> It would, but there may be better ways to do it.
22:58:25 <SamanthaD> shachaf: Okay!
22:58:29 <shachaf> The trouble is that it's hard to give you a completely local solution.
22:58:42 <cmccann> there's not much you'd do with different kinds of card decks that isn't exactly the same, e.g. you wouldn't need a "Card" type class to shuffle or deal in general
22:58:48 <cmccann> and the rules of a card game are probably specific enough that a type class would be superfluous
22:59:01 <shachaf> If you know about the expression problem, ADTs give you *both* sides of it, not just one.
22:59:09 <cmccann> since there'd be little generic code you could write, &c.
22:59:09 <fragamus> is there a better way to do this:
22:59:10 <fragamus> let thing :: Int -> [(a,Int)] -> (a,Int)
22:59:10 <fragamus>      thing a (b:bs)
22:59:11 <fragamus>          | (a < b^._2) = b
22:59:11 <fragamus>          | otherwise = thing (a - b^._2) bs
22:59:26 <shachaf> hpaste.org would probably be a better way to do it.
22:59:31 <SamanthaD> cmccann: Well, I meant functions like "are these different colors" when you have, say, a type of card deck with two colors and a type of card deck with three colors.
22:59:33 <shachaf> (Or putting it all on one line.)
23:00:35 <cmccann> SamanthaD: in that case you'd probably want the Card type parameterized by a type representing the colors
23:00:47 <cmccann> and then you can do stuff involving colors in a parametric way, without needing a type class
23:00:59 <cmccann> but in some cases the typeclass might make sense, it's hard to say exactly
23:01:10 <SamanthaD> cmccann: Well, thanks!
23:01:15 <edwardocv> plhk: http://bpaste.net/show/XI9okwyaPNa13hqnDMPq/
23:01:22 <shachaf> SamanthaD: You should learn about the expression problem, by the way. It's a useful perspective for thinking about this sort of thing.
23:01:45 <cmccann> that's one of the reasons why I'd advise sticking to standard typeclasses for a while until you get a better feel for what makes them useful or not
23:01:49 <edwardocv> plhk: Can you point out my stupidlity here?
23:02:17 <cmccann> it's hard to find simple rules or guidelines to follow without having that experience
23:02:39 <fragamus> http://hpaste.org/81051
23:02:41 <SamanthaD> shachaf: this? http://c2.com/cgi/wiki?ExpressionProblem
23:02:57 <plhk> edwardocv: you have to map it with mapRaised
23:03:06 <shachaf> SamanthaD: That's the one.
23:03:16 <SamanthaD> shachaf: Okay, I'll go read it.
23:03:33 <johnw> fragamus: you have a question?
23:03:49 <fragamus> yeah is there a fold or something I can use there
23:03:55 <cmccann> SamanthaD: also interesting and relevant, the paper and link to Lambda the Ultimate here: http://wcook.blogspot.com/2009/11/on-understanding-data-absraction.html
23:04:17 <SamanthaD> cmccann: Thank you!
23:04:24 <shachaf> SamanthaD: That page makes it seem like the FunctionalProgramming approach is the opposite of the ObjectOriented approach.
23:04:32 <shachaf> But really Haskell can do both approaches quite well.
23:04:38 <shachaf> And without any type classes in either case.
23:04:46 <cmccann> (despite the remark about it being pretty technical, I found the paper quite readable)
23:05:12 <SamanthaD> shachaf: Hmm... I suppose I'll figure out how that's done in time, too!
23:05:31 <cmccann> shachaf: it's really imitating subtyping that is horrible in Haskell, which people often take as a given when thinking about OOP
23:05:47 <cmccann> (that's also where typeclass abuse tends to come in)
23:06:08 <cmccann> shachaf: btw you should read that paper I linked to above as well, if you haven't already
23:06:23 <shachaf> I haven't.
23:09:44 <latermuse> hey, ive got a big list of tuples: [(Integer,String)]. Each string has a word in it, that may appear many times. How can I make it add up the Integer part of the tuple for every instance of a certain word on the right?
23:09:49 <fragamus> i puzzled over it and I could not thing of a way to use a fold
23:10:19 <shachaf> fragmaus: What is the goal of that code?
23:10:33 <fragamus> to return one pair
23:10:35 <latermuse> [(13,"hi"),(10,"hi"),(4,"meow")], would become [(23,"hi"),(4,"meow")]
23:10:45 <SamanthaD> latermuse: Why use a fold over a filter?
23:10:59 <SamanthaD> latermuse: That was supposed to be "why not"
23:11:22 <latermuse> SamanthaD: Thanks, ill give that a shot :)
23:11:27 <shachaf> @ty groupBy
23:11:28 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
23:11:34 <SamanthaD> latermuse: OH! I misunderstood your question...
23:12:43 <shachaf> > map (sum . map fst &&& snd . head) . groupBy ((==) `on` snd) . sortBy (compare `on` snd) $ [(13,"hi"),(10,"hi"),(4,"meow")]
23:12:45 <lambdabot>   [(23,"hi"),(4,"meow")]
23:12:46 <shachaf> Blech.
23:13:42 <edwardocv> plhk: The part I am missing here is that I don't understand where the window is that newWindow returns?
23:14:32 <shachaf> > foldl' (\x (a,b) -> x & at b.non 0 +~ a) M.empty [(13,"hi"),(10,"hi"),(4,"meow")]
23:14:34 <lambdabot>   fromList [("hi",23),("meow",4)]
23:14:38 <shachaf> How's that?
23:14:42 <srhb> Using Map would be nice.
23:14:44 <srhb> Ah...
23:14:46 * srhb is too slow
23:16:05 <shachaf> Is there a nicer lens way of doing that?
23:16:25 <edwardocv> plhk: i.e. I have something like this http://bpaste.net/show/SZxZA5eByRd8syZ7Mw3c/ but that is not compilable
23:16:35 <plhk> edwardocv: let's move that conversation in private
23:17:16 <bourbaki> Can anyone recover pages of the Haskell Wiki?
23:17:48 <shachaf> > M.unionsWith (+) . map (\(n,s) -> M.singleton s n) $ [(13,"hi"),(10,"hi"),(4,"meow")]
23:17:50 <lambdabot>   fromList [("hi",23),("meow",4)]
23:17:53 <shachaf> That's another way.
23:18:08 <shachaf> latermuse: Take your pick. :-)
23:19:10 <latermuse> thanks shachaf :)
23:21:21 <srhb> > M.fromListWith (+) . map swap $ [(2,"foo"), (2,"foo"), (3,"bar")]
23:21:23 <lambdabot>   fromList [("bar",3),("foo",4)]
23:22:26 <shachaf> srhb++
23:22:37 <srhb> Hurray, approval! \o/
23:23:12 <shachaf> i love approval
23:23:15 <shachaf> it is so easy
23:23:16 <srhb> Totally.
23:23:19 <shachaf> Oops!
23:23:22 <latermuse> is M. the Data.IntMap module?
23:23:30 <srhb> Data.Map
23:23:35 <latermuse> got it, thanks
23:24:02 <srhb> latermuse: When you see a key/value list, I think often the answer is "Data.Map" :P
23:24:13 <latermuse> yep! brainfart, haha
23:25:18 <basdirks> less drums shachaf, less drums
23:30:38 <tieTYT2> i'm reading real world haskell and it just explained lazy evaluation.  Is this an important beginner topic though?  It seems like something they could have introduced much later
23:31:32 <tieTYT2> seems more like a "neat implementation detail" that the haskell interpreter does instead of something that I need to consider often when I'm reading code
23:31:58 <shachaf> tieTYT2: It's pretty fundamental.
23:32:06 <ManAmongHippos> What is a solid book to get started with Haskell?
23:32:17 <shachaf> Well, non-strictness is entirely fundamental. Laziness is pretty important too.
23:32:25 <shachaf> ManAmongHippos: Many people recommend LYAH
23:32:30 <shachaf> @where lyah
23:32:30 <lambdabot> http://www.learnyouahaskell.com/
23:32:45 <shachaf> cmccann: He totally cheats with isEmpty :-(
23:32:46 <basdirks> Programming in Haskell by Graham Hutton is nice
23:32:49 <ManAmongHippos> shachaf: What might others recommend?
23:33:06 <shachaf> ManAmongHippos: I like _Programming in Haskell_ by Hutton.
23:33:57 <shachaf> LYAH is available for free online, which is an advantage.
23:33:58 <cmccann> shachaf: eh who's on the what now
23:34:36 <shachaf> cmccann: In the data abstraction thing.
23:34:36 <basdirks> shachaf: am I on your /ignore or do you just agree very vehemently?
23:34:39 <shachaf> I guess he talks about that, though.
23:34:44 <cmccann> shachaf: oh right
23:34:47 <shachaf> basdirks: About what? Drums?
23:35:16 <basdirks> Hutton
23:35:46 <shachaf> johnw: Is mentioning unsafePerformIO *really* necessary?
23:37:15 * tac doesn't believe USING unsafePerformIO is ever necessary </opinion>
23:40:22 <cmccann> all the cool kids use unsafeCoerce instead.
23:41:16 <shachaf> cmccann: The cool kids derive unsafeCoerce from someone else's exported code.
23:41:53 <shachaf> cmccann: Can you think of a way to derive unsafeCoerce given f :: forall f a. f (Id a) -> f a and no extensions?
23:42:39 <shachaf> Whose implementation is unsafeCoerce, that is.
23:43:50 <cmccann> shachaf: not immediately, no.
23:44:19 <shachaf> With type families it's easy.
23:44:23 <cmccann> (with extensions there are a lot more angles of attack)
23:44:46 <shachaf> With GADTs it's probably possible? Not sure.
23:45:08 <cmccann> yeah, I suspect that opens up the same sort of holes that GeneralizedNewtypeDeriving does
23:45:36 <shachaf> http://www.haskell.org/pipermail/glasgow-haskell-users/2013-January/023570.html
23:46:37 <shachaf> You can get an evil invalid GADT value with it but I'm not sure how to turn it into unsafeCoerce.
23:46:42 <shachaf> (And the same with rank-2 types.)
23:53:47 <hpaste> “C. McCann” pasted “import Unsafe.Shachaf” at http://hpaste.org/81054
23:53:54 <cmccann> ugh I clearly need sleep
23:54:11 <cmccann> I somehow manage to hpaste that three times by hitting the wrong key in my browser
23:54:24 <cmccann> shachaf: anyway there's how to do it with GADTs
23:54:32 <cmccann> as you can see it's entirely different from the TypeFamilies version
23:54:43 <cmccann> I can see why you didn't figure out how to do that
23:54:49 * hackagebot syntactic 1.5.2 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.5.2 (EmilAxelsson)
23:56:03 <Guest10158> HELLO world
23:56:14 <shachaf> cmccann: Oh, that should have been more obvious.
23:56:32 <cmccann> well, it actually was that obvious. :P
23:57:03 <shachaf> cmccann: Oh, wait, it doesn't work.
23:57:19 <shachaf> I had an example pretty similar to that.
23:57:22 <cmccann> hm, it doesn't?
23:57:31 <shachaf> It gives you a non-exhaustive case in unBar.
23:57:36 <cmccann> ah
23:57:37 <cmccann> hm.
23:57:48 <shachaf> I tested it and it looked like it worked.
23:57:52 <cmccann> probably some way to work around that.
23:57:56 <shachaf> Then I realized I typed unsafeCoerce instead of coerce.
23:58:08 <cmccann> but don't feel like figuring it out tonight.
23:58:09 <cmccann> heh.
23:58:16 <shachaf> cmccann: I tried to a bit and didn't work it out.
23:58:23 <shachaf> But probably something is possible.
