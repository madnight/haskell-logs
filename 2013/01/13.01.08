00:33:00 <fragamus> hey I'm working with byte string and I want to do numeric operations sometimes. I'm seeing a lot of stuff on Lazy ByteStrings and a numerics instance for that, but I think Im using the non-lazy ones. Im a little bit hazy on that
00:34:30 <osa1> how can I make vim2hs's auto-indentation 4 spaces instead of 8 ?
00:35:57 <Saizan> fragamus: converting to lazy is easy
00:36:09 <donri> osa1: set shiftwidth=4
00:36:41 <osa1> donri: doesn't work. it's already set to 4 in my vimrc (and I checked now with :set shiftwidth and it's already 4)
00:37:32 <AfC> and set tabstop=4
00:37:45 <donri> osa1: some autoindentation indents two steps, for consistency with https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
00:37:45 <osa1> AfC: it's already set too
00:37:49 <b_______>  18 set shiftwidth=2
00:37:49 <b_______>   19 set softtabstop=2
00:37:50 <b_______>   20 set tabstop=2
00:38:02 <b_______> softtabstop maybe?
00:38:27 <AfC> b_______: no, I don't think so - that has to do with when you're mixing tabs and spaces
00:39:02 <b_______> ok
00:39:02 <donri> osa1: i set shiftwidth to 2, and then a function body is indented twice = 4 spaces, and the "where" once = 2 spaces
00:39:05 <osa1> donri: hmm OK so I need to au! BufRead,BufNewFile *.hs set shiftwidth=2
00:39:16 <fragamus> Saizan: does converting to lazy ByteString involve memory allocation?
00:39:23 <donri> auto FileType haskell, should do it
00:39:35 <donri> or put it in .vim/filetype/haskell.vim
00:39:53 <donri> .vim/ftplugin that is
00:40:08 <Saizan> fragamus: almost none, that direction is fairly cheap, you only need to allocate a cons cell
00:41:22 <fragamus> ok I'm looking into it
00:42:41 <b_______> are vim2hs and haskellmode compatible?
00:43:24 <donri> they should be, but i recommend ghc-mod and hdevtools over haskellmode
00:43:42 <b_______> okay
00:58:10 <johnw> donri: ghc-mode works alongside haskell-mode rather nicely
01:03:54 <mansoor-s> ( ͡° ͜ʖ ͡°)
01:05:26 <fragamus> I'm having trouble with   fromStrict      trying to import that function     no workie
01:05:48 <fragamus> import qualified Data.ByteString.Lazy as L (fromStrict)
01:08:52 <donri> drop the (fromStrict) and use L.fromStrict
01:09:17 <fragamus> ok ill do that but my brain is like WTF
01:09:26 <johnw> ok, I integrated hdevtools into ghc-mod.el :)
01:10:44 <donri> johnw: are you talking about vim then?
01:10:48 <johnw> no, Emacs
01:11:06 <fragamus> import qualified Data.ByteString.Lazy as L
01:11:11 <johnw> i just changed ghc-flymake.el to use "hdevtools check" instead of "ghc-mod check".  Man is it faster!
01:12:59 <donri> johnw: also try -fno-code
01:13:10 <johnw> as an option to what?
01:13:22 <donri> to ghc, via hdevtools
01:13:45 <johnw> good idea!
01:13:58 <donri> downside is it doesn't run TH so such code isn't type checked
01:14:06 <johnw> ah
01:17:28 <fragamus> OK I really am not seeing the fromStrict function when I import Data.ByteString.Lazy
01:19:26 <fragamus> so how in the blue blazes do I get it
01:21:19 <donri> are you prefixing it with "L."?
01:25:08 <fragamus> tried it with and without the L
01:26:12 <basdirks> is there a guide somewhere on how to use the stability and portability fields of haddock headers?
01:26:52 <donri> fragamus: maybe you have an old version, duno
01:27:00 <donri> @hpaste your code
01:27:00 <lambdabot> Haskell pastebin: http://hpaste.org/
01:27:27 <donri> and check ghc-pkg list bytestring
01:28:54 <donri> you could also try fromChunks . return
01:29:02 <johnw> donri: -fno-code works great, thanks!
01:29:16 <donri> johnw: is it noticably faster?
01:29:21 <johnw> oh heck yes
01:29:24 <johnw> like 10x at least
01:29:31 <johnw> oh, you mean no-code?
01:29:33 <johnw> no, not by itself
01:29:46 <donri> it makes ghc-mod much faster, duno about hdevtools which is already quite fast
01:30:19 <donri> still, only type checking should be even faster
01:30:27 <johnw> makes sense
01:30:30 <johnw> i'll keep the TH thing in mind
01:35:53 <fragamus> i have determined that I have an old version of bytestring     how can I upgrade?
01:36:02 <fragamus> I tried to use cabal but it complains
01:36:11 <fragamus> maybe I should reinstall platform
01:36:23 <liyang> Ah, the dreaded monochrom restriction.
01:36:42 <fragamus> is there any automated cabal thingy that will bring me up to date on everything?
01:38:55 <QinGW> haskell-update does it?
01:38:57 <johnw> donri: did even more hacking
01:39:28 <johnw> M-p and M-n navigate error message like before, but if the error is just one-line long it uses the minibuffer instead of a separate window.  And if it does use a separate window, it minimizes the vertical height
01:39:39 <donri> fragamus: you should upgrade platform yes, and no you can't do that with cabal
01:40:00 <fragamus> oh i shall look that up thanks
01:40:51 <donri> johnw: also maybe try the ghci stuff in haskell mode? should be fast too since it's preloaded and interpreted
01:41:11 <donri> i use vim though, don't really know emacs
01:41:22 <johnw> ah, ok
01:41:29 <johnw> what ghci stuff?
01:42:50 <donri> i don't really know more than that it has such a feature
01:43:03 <fragamus> looks like the best way is to reinstall the entire platform
01:43:03 <donri> where it integrates cabal-dev ghci into emacs
01:43:21 <donri> and you can :r to reload etc
01:45:04 <akamaus> hi. I'm working on an implementation of r-tree. Types of values placed in it have a class constraint. Now I want to add mapping of a function to elements. So basically I have a functor. But these additional type constraints prevent me from declaring a Functor instance. Is there a way to overcome this? I'm thinking of Data.Map. It's a Functor, but nevertheless elements must be of class Ord.
01:49:13 <mgsloan> akamaus: Unfortunately there is no principled way to overcome that.  Would your Functor instance need to actually use the "Ord" constraint?
01:49:17 <yitz> akamaus: the new constraint kinds extension in recent versions of ghc will help you. look it up in the ghc docs.
01:50:14 <mgsloan> yitz: Wouldn't that just let you define your own version of Functor that also accepts constraints?
01:50:36 <mgsloan> But not actually make a proper Functor instance
01:51:08 <yitz> mgsloan: well right the current Functor class requires fmap to work for all types.
01:51:26 <mgsloan> yup, that's pretty much the point :)
01:51:51 <Jafet> @remember liyang <fragamus> how can I upgrade bytestring? I tried to use cabal but it complains  <liyang> Ah, the dreaded monochrom restriction.
01:51:51 <lambdabot> I will remember.
01:51:57 <yitz> mgsloan: but it would allow akamaus to define a way to map any function over the elements of the container whenever that makes sense. i think that is what akamaus wants.
01:52:21 <fragamus> @remember the alamo
01:52:21 <lambdabot> Okay.
01:52:28 <akamaus> mgsloan, I looked at the Map implementation inside the containers package. Looks like they have a constraint only on 'insert', and fmap is implemented without it. Unfortunately, In my case I need to rebalance the tree, so I can't use the same trick
01:52:35 <yitz> @quote alamo
01:52:35 <lambdabot> the says: alamo
01:53:08 <mgsloan> yitz: Sure, but could just have an "rmap :: (Ord a, Ord b) => (a -> b) -> RTree a -> RTree b"
01:53:38 <akamaus> yitz, I thought about Functor only to make use of a familiar interface. Of course, I can leave without it with my own custom function
01:54:00 <mgsloan> I guess we can have "gmap :: GFunctor Ord f => (a -> b) -> f a -> f b" if we really want to ;)
01:54:34 <mgsloan> akamaus: Data.Set has this problem too - no Functor instance
01:54:46 <Jafet> Data.Set has a deeper problem.
01:55:12 <Jafet> Well, if RTree is like Set, then it would have the same problem.
01:55:22 <mgsloan> yup
01:55:25 <akamaus> mgsloan, indeed, in Data.Map they retain the tree structure while mapping
01:55:43 <mgsloan> akamaus: Yeah, because you aren't changing the keys (or their types)
01:55:59 <mgsloan> s/types/type/
01:56:28 <akamaus> in my case RTree is conceptually closer to Set than to Map
01:56:57 <Jafet> Can fmap obey the functor law for RTree?
01:57:28 * hackagebot fields-json 0.2.1.1 - Abusing monadic syntax JSON objects generation.  http://hackage.haskell.org/package/fields-json-0.2.1.1 (MariuszRak)
01:58:14 <akamaus> Jafet, I guess it should
01:59:20 <akamaus> Jafet, what problem with Sets are you talking about?
01:59:39 <Jafet> Set is not a functor.
01:59:51 <merijn> akamaus: That sets have an Ord constraint on their elements, and there's no way to make Functor (fmap) preserve that constraint
02:00:02 <Jafet> It is more problematic than that
02:00:12 <Jafet> The functor law is fmap (f.g) = fmap f.fmap g
02:00:46 <merijn> And I guess that if fmap changes the relative Ordering of elements the Set would have to be reordered, which is not allowed
02:00:52 <Jafet> > let s = S.fromList [1..4]; f = (*2); g = (`div`2) in (S.map (f.g) s, S.map f.S.map g$s)
02:00:54 <lambdabot>   (fromList [0,2,4],fromList [0,2,4])
02:01:01 <Jafet> Er
02:02:15 <johnw> merijn: I don't see why that's necessarily a problem; you can have endofunctors on Posets, as long as the magnitude is the same; even the relation could change.  Now whether that expressible in Haskell...
02:02:43 <Jafet> What was that example again
02:02:54 <fragamus> still having problems after reinstalling haskell platform… it seems that Data.ByteString.Lazy does not support fromStrict
02:03:19 <johnw> fragamus: are you sure it isn't fromChunks that you want?
02:03:27 <johnw> fromStrict is in Data.Text.Lazy
02:03:52 <johnw> https://gist.github.com/4482613
02:04:06 <johnw> oh, sorry
02:04:08 <johnw> lazyFromStrictB = flip BLI.chunk BLI.Empty
02:04:10 <fragamus> i see that.  I have an internal byte string and I want to convert to a Lazy so I can do some math with it as an instance of Num
02:04:14 <johnw> where BLI is import qualified Data.ByteString.Lazy.Internal as BLI
02:04:48 <johnw> the bytestring conversions to/from Lazy aren't part of the public interface
02:05:21 <johnw> fragamus: this code is in my "stringable" module, btw
02:05:28 <fragamus> ah cool
02:05:33 <fragamus> that looks nice
02:05:33 <johnw> which then allows you to just say "toLazyByteString", whatever the input string/bytestring
02:06:13 <johnw> although note that there is a UTF-8 bias in that module
02:06:56 <Jafet> akamaus: newtype OrdMap f a = OrdMap { ordMap :: f a, compare = a -> a -> Ordering }; instance Functor f => Functor (OrdMap f)
02:06:59 <fragamus> awesome
02:07:10 <Jafet> This looks familiar...
02:07:47 <akamaus> wow :)
02:08:02 <Jafet> Probably ask edwardk if he's written that already
02:08:21 <Jafet> Wait, f can't be a Functor
02:08:46 <Jafet> Well, let f~RTree, small details
02:09:15 <akamaus> Jafet, why?  Because you can't provide compare for arbitrary type?
02:09:39 <Jafet> The point of this is that f isn't a functor, so you wrap it in OrdMap
02:09:48 <Jafet> You will need a different instance for each f
02:18:34 <akamaus> I'm writing a quickcheck property for my mapRTree now. Is there a way to generate arbitrary functions? :)
02:18:58 <Jafet> @hoogle Coarbitrary
02:18:58 <lambdabot> Test.QuickCheck.Arbitrary class CoArbitrary a
02:18:58 <lambdabot> Test.QuickCheck class CoArbitrary a
02:18:58 <lambdabot> Test.QuickCheck.Arbitrary coarbitrary :: CoArbitrary a => a -> Gen c -> Gen c
02:19:03 <merijn> johnw: It's not *necessarily* a problem, it's just impossible to preserve that constraint in Haskell, as-is
02:21:02 <alec> can someone give me a really concise explanation of ifte?
02:21:12 <aristid> @hoogle ifte
02:21:12 <lambdabot> No results found
02:21:49 <merijn> Isn't ifte just the function form of if/then/else?
02:22:37 <Jafet> @google ifte
02:22:39 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
02:22:53 <Taneb> Oh no
02:23:05 <Taneb> It's in Control.Monad.Logic.Class, right?
02:23:11 <Taneb> @hackage logict
02:23:11 <lambdabot> http://hackage.haskell.org/package/logict
02:23:20 <Jafet> @ohnoogle
02:23:20 <lambdabot> No query entered
02:23:21 <lambdabot> Try --help for command line options
02:23:29 <Jafet> @ohnoogle --help
02:23:29 <lambdabot> Hoogle v4.2.7, (C) Neil Mitchell 2004-2011
02:23:29 <lambdabot> http://haskell.org/hoogle
02:23:29 <lambdabot>  
02:23:50 <Taneb> ifte :: [a] -> (a -> [b]) -> [b] -> [b]
02:23:53 <merijn> Ah, yeah there seems to be an ifte function in LogicT, the other common definition seems to be if/then/else like I said
02:24:42 <alec> ok; i don't really get what it's useful for though
02:26:43 <Taneb> It's a bit like (>>=), but with a default if you give it []
02:27:38 <Jafet> I don't really get what that's useful for
02:28:10 <Wizek> Hello! I'm quite new to haskell, so bear with me. :)  I have a test.hs file which contains `putStrLn "one"` and when I run `:l test.hs` in GHCI I get this error: "Parse error: naked expression at top level". I know this error has something to do with Hs being non-procedural, but I don't now how to fix it. So, how do I print a string when I load it's file with `:l`?
02:28:28 <Taneb> Give it a name
02:28:36 <Taneb> Something like foo = putStrLn "one"
02:28:53 <Taneb> .hs files aren't just copied line-by-line into GHCi
02:29:12 <merijn> Wizek: The best name would probably be "main"
02:29:27 <merijn> Wizek: Which is the action that is executed when you run a haskell file
02:29:29 <Jafet> Wizek: echo 'puts("one");' > test.c && gcc test.c
02:29:48 <Taneb> Wizek, don't listen to Jafet
02:29:56 <Jafet> I'm a bad person
02:30:15 <merijn> Taneb: Well, it's a similar problem and might clarify the issue IFF Wizek knows C
02:30:33 <Taneb> merijn, ah
02:30:50 <merijn> Taneb: Because C doesn't allow naked top level expressions either
02:31:06 <Taneb> Heh, I don't know C, I assumed it did
02:31:50 <merijn> Nope, everything goes in functions and the entry point is main.
02:32:07 <merijn> s/functions/procedures/ #don'tstonemeplease
02:32:33 <Jafet> echo 'puts(x);' > test.c && gcc test.c # this compiles
02:32:35 <Jafet> C is great
02:32:55 <Wizek> Taneb: I gave it the name "main", and now it loads, but it only executes when I "invoke" main, and not automatically.
02:33:05 <merijn> Jafet: Doesn't compile for me
02:33:07 <Taneb> Wizek, yeah, that would work
02:33:07 <EarlGrayW> Wizek: try  main = putStrLn "one" in the haskell file
02:33:25 <Jafet> Wizek: do you know what "ghci" stands for?
02:33:26 <Taneb> I mean, that's what's supposed to happen
02:33:27 <merijn> Wizek: ghci doesn't run a file when you load it
02:33:45 <EarlGrayW> Wizek: you can run main as :m in ghci
02:33:55 <HugoDaniel> hi
02:34:07 <HugoDaniel> im trying to learn type families
02:34:21 <QinGW> runghc
02:34:28 <merijn> Jafet: For me it produces "Undefined symbols for architecture x86_64: "_main", referenced from: start in crt1.10.6.o ld: symbol(s) not found for architecture x86_64"
02:35:06 <merijn> Jafet: clang also doesn't swallow it. I think your gcc is borked (or more borked then usual :p)
02:35:16 <Jafet> merijn: echo 'char main[1] = {};' >> test.c
02:35:19 <kennyd> Wizek main will be ran automatically when you compile your source and run the resulting executable
02:35:21 <Jafet> Should work then
02:35:48 <Wizek> kennyd: I've only used ghci yet, trying to figure out how to compile my hs file right now
02:36:23 <merijn> Wizek: "ghc --make test.hs" should be sufficient, the produced executable should run the "main" action by default
02:36:42 <merijn> Wizek: i.e. "main = putStrLn "one"" should print "one" when executed
02:37:07 <Wizek> ah, that worked :)
02:37:09 <Wizek> nice
02:37:13 <Wizek> thanks
02:37:39 <kennyd> is there any difference between ghc test and ghc --make test.hs ?
02:38:08 <bitonic> kennyd: no, if you are using a recent version of ghc, iirc
02:41:55 <Wizek> I'm still curious about the first part: is there a way to load my.hs & run a function (called main, or some other) from ghci?
02:42:04 <mrxy> :t writer
02:42:06 <lambdabot> MonadWriter w m => (a, w) -> m a
02:42:21 <mrxy> is that equal to Monoid m => (a, m) -> Writer m a  ?
02:42:40 <merijn> Wizek: Well, main is not a function, but an IO action. You can run it just by executing the action in ghci, though. (i.e. typing "main" or "foo" and hitting enter)
02:42:52 <fragamus> hey why does it say that NumLazyByteString is obsolete?
02:43:06 <merijn> mrxy: Modulo some arbitrary underlying monad transformer stack, yes
02:43:30 <fragamus> Is there something else I should be using to get a ByteString to be an instance of Integral
02:44:03 <merijn> mrxy: It's basically a generalisation that lets you use stuff like writer in a monad transformer stack that has a writer in it somewhere
02:45:00 <fragamus> http://hackage.haskell.org/package/NumLazyByteString
02:45:13 <fragamus> why does it say obsolete and what can I do about it
02:45:17 <mrxy> merijn thanks
02:46:15 <Sizur> !1
02:46:18 <Jafet> fragamus: why do you expect people to know about a random package
02:46:18 <alc> fragamus, how about readInt and readInteger in Data.ByteString.Lazy.Char8
02:46:29 <Sizur> !1
02:47:05 <Sizur> :1
02:47:35 <fragamus> the integers are represented as binary, not as ascii.  Also I am hoping to avoid memory allocation associated with conversion to Integer
02:48:29 <Jafet> That's funny
02:48:34 <Jafet> http://hackage.haskell.org/packages/archive/NumLazyByteString/0.0.0.1/doc/html/src/Data-ByteString-Lazy-Num.html
02:48:47 <Jafet> instance Num NumBS where (*) = asInteger2 (*)
03:14:22 <ski> @type writer :: Monoid m => (a, m) -> Writer m a  -- mrxy
03:14:23 <lambdabot> Monoid m => (a, m) -> Writer m a
03:17:32 * hackagebot concrete-typerep 0.1.0.2 - Binary and Hashable instances for TypeRep  http://hackage.haskell.org/package/concrete-typerep-0.1.0.2 (ReinerPope)
03:31:09 <Moggle> State monoids confuse me. Anyone know of any good pages that explain them really well?
03:31:17 <Moggle> The LYAH page on them is lacking slightly.
03:31:20 <Moggle> I need a fresh perspective!
03:32:10 <Taneb> Basically, State s a means "if you give me an s, I'll give you an a, AND a new s"
03:32:31 <Taneb> The State monad just passes about the s and uses it to make a's
03:32:31 <Jafet> What is a state monoid
03:32:37 <Moggle> monad
03:32:38 <Moggle> :P
03:32:41 <Moggle> i knew I wrote something horrifically
03:32:47 <Taneb> State s a = s -> (a, s)
03:32:51 <Jafet> No, really, what is a state monoid
03:32:54 <Taneb> Hmm
03:32:56 <Jafet> It could be interesting
03:33:13 <Taneb> The obvious would be (a -> s-> (a, s))
03:33:18 <Taneb> Which is Endo (a, s)
03:33:39 <Moggle> Taneb: I understand that, and yet the implementation for the state instance of monad leaves me feeling kind of... o.O
03:33:44 <Jafet> Something along the lines of Writer
03:34:08 <Taneb> Moggle, yeah, it's not the nicest to actually code
03:34:18 <Taneb> return's easy enough
03:34:25 <Moggle> yeah
03:34:31 <Moggle> it's bind that has me confused
03:34:32 <Moggle> :P
03:34:49 <Moggle> it's okay, though, I found a few tutorials devoted specifically to them!
03:35:00 <Moggle> HOPEFULLY I should be able to code the state monad implementation on my own after
03:35:01 <Jafet> You don't need to understand the implementation to know how State works
03:35:14 <Taneb> bind :: (a -> s -> (b, s)) -> (s -> (a, s)) -> s -> (b, s) -- roughly
03:36:02 <Jafet> > let f state = state + 1; g state = state + 2; in f (g 3)
03:36:03 <lambdabot>   6
03:36:10 <Jafet> That's the state monad
03:36:15 <Jafet> Except without the monad
03:36:18 <Taneb> :t \f g s -> uncurry f (g s)
03:36:20 <lambdabot> (a -> b -> c) -> (t -> (a, b)) -> t -> c
03:36:43 <Taneb> :t \f g s -> uncurry f (g s) :: (a -> s -> (b, s)) -> (s -> (a, s)) -> s-> (b, s)
03:36:45 <lambdabot>     Couldn't match type `t'
03:36:45 <lambdabot>                    with `a
03:36:45 <lambdabot>                          -> b
03:36:50 <Moggle> Jafet: I understand that, and yet I feel like something is missing when I can't fully understand 3 lines of code.
03:36:52 <Taneb> :t (\f g s -> uncurry f (g s)) :: (a -> s -> (b, s)) -> (s -> (a, s)) -> s-> (b, s)
03:36:53 <lambdabot> (a -> s -> (b, s)) -> (s -> (a, s)) -> s -> (b, s)
03:37:11 <Taneb> That's an implentation of bind for a simplified State monad
03:39:51 <Jafet> Don't worry, just read ten random blog posts and it'll become clear
03:55:49 <merijn> Moggle: For me it helped to look at the implementation and manually "execute" some state actions using it (i.e. do the substitutions by hand)
04:03:15 <mSSM> When is it advisable to use Unboxed types rather than Boxed? E.g. boxed vs unboxed vectors.
04:05:11 <basdirks> is there a package for matching certain things in Haskell code?
04:05:22 <basdirks> like regexp's for type signatures, function definitions etc
04:05:38 <basdirks> or preferably, actual partial parsers
04:05:40 <EarlGrayW> Language.Haskell.Lexer?
04:05:53 <EarlGrayW> though I have not worked with it
04:06:54 <tdammers> Language.Haskell.Meta should have all you need to actually parse haskell
04:07:15 <tdammers> it's in the haskell-src-meta package
04:07:20 <basdirks> okay thanks
04:26:43 <ClaudiusMaximus> most recent output from my haskell: http://mathr.co.uk/misc/2013-01-08_hyperbolic_butterflies.png (4.6MB)
04:27:24 <ClaudiusMaximus> shame i haven't figured out a better algorithm, quadratic complexity (in image width) is slow :(  45mins for that...
04:31:03 <basdirks> tdammers, EarlGray^, thanks for the suggestions, these modules were precisely what I needed
04:31:11 <zomg> ClaudiusMaximus: heh, that's an.. interesting image
04:31:12 <zomg> :D
04:31:28 <ClaudiusMaximus> zomg: :)
04:31:50 <hiptobecubic> it's amazing how many of my python bugs are directly because i thought some state variable was not being changed.
04:32:09 <hiptobecubic> ClaudiusMaximus, :D this thing is great. Some kind of packing algorithm?
04:32:17 <merijn> HP needs to move to 7.6 so I can finally test my code using Travis-CI >.>
04:33:28 <ClaudiusMaximus> mSSM: unboxed arrays uses less memory/indirection (so are probably faster) but you can't have data dependencies between items in the same array
04:34:11 <ClaudiusMaximus> hiptobecubic: :) it's a hyperbolic tiling in the Poincaré half-plane model
04:34:45 <ClaudiusMaximus> hiptobecubic: i ported the maths from this C++ http://en.wikipedia.org/wiki/File:Poincare_halfplane_eptagonal_hb.svg
04:34:55 <hiptobecubic> ah of course! Hyperbolic tiling tin the Poincaré half-plane. I should have recognized it.
04:35:00 <hiptobecubic> in*
04:35:19 <ClaudiusMaximus> hiptobecubic: and the colouring from an older project (symmetrical in 24 colours, apparently related to Klein quartic)
04:35:24 <hiptobecubic> are the verticies butterflies then?
04:35:35 <hiptobecubic> the black verticies i mean
04:36:02 <hiptobecubic> vertices? vertexes?
04:36:11 <opqdonut> vertices.
04:36:19 <ClaudiusMaximus> hiptobecubic: it's the dual tiling, with 3 butterflies in each triangle, with front wing tips at the vertices (which are centers of heptagons)
04:36:23 <hiptobecubic> Vertices then.
04:37:28 <hiptobecubic> there are no vertices at the centers of these heptagons
04:37:28 <ClaudiusMaximus> mSSM: also, unboxed arrays tend to use a constant space allocation for each element, so you can't use them for all types
04:38:21 <ClaudiusMaximus> hiptobecubic: i know, it's more like this one http://en.wikipedia.org/wiki/File:Uniform_tiling_73-t2.png
04:39:12 <hiptobecubic> i see
04:39:22 <hiptobecubic> Well it's neat
04:39:29 <mrxy> > tell "foo"
04:39:30 <lambdabot>   No instance for (GHC.Show.Show (m0 ()))
04:39:30 <lambdabot>    arising from a use of `M21760634...
04:39:38 <hiptobecubic> ClaudiusMaximus, shared somewhere?
04:39:51 <mrxy> I got a different error in ghci, "No instance for (MonadWriter [Char] m0)"
04:40:05 <ClaudiusMaximus> hiptobecubic: the code? not yet, will publish it tonight and write a sequel to my blog post http://mathr.co.uk/blog/2013-01-03_eschers_butterflies.html
04:40:37 <mrxy> trying to understand why `tell "foo"' gives me that error in ghci, while `runWriter $ tell "foo"' works and returns ((), "foo")
04:41:47 <ClaudiusMaximus> mrxy: it doesn't know what m0 to pick
04:42:09 <mm_freak_> mrxy: it's because they haven't implemented mind reading in GHC yet =)
04:42:36 * hackagebot hsc3-process 0.9.0 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.9.0 (StefanKersten)
04:42:38 * hackagebot hsc3-server 0.6.0 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.6.0 (StefanKersten)
04:42:47 <mm_freak_> mrxy: try this:  tell "foo" :: Writer String ()
04:42:55 <mm_freak_> > tell "foo" :: Writer String ()
04:42:56 <lambdabot>   No instance for (GHC.Show.Show
04:42:56 <lambdabot>                     (Control.Monad.Trans.Wri...
04:43:31 <mrxy> mm_freak_ lambdabot gives same error with or without explicit type
04:43:41 <hiptobecubic> ClaudiusMaximus, this is nice.
04:43:53 <mm_freak_> mrxy: reason:
04:43:54 <mm_freak_> :t tell
04:43:55 <lambdabot> MonadWriter w m => w -> m ()
04:44:03 <mm_freak_> oh, it is actually polymorphic
04:44:14 <mm_freak_> > tell "blah"
04:44:16 <lambdabot>   No instance for (GHC.Show.Show (m0 ()))
04:44:16 <lambdabot>    arising from a use of `M60193641...
04:44:25 <mm_freak_> weird
04:44:44 <mm_freak_> ah, no, it's actually the same cause, just with a different type class
04:45:37 <mm_freak_> mrxy: 'tell' is a function from the type class MonadWriter, which may (and does) have instances for various monads
04:45:54 <mm_freak_> so you have to actually specify which writer monad you're referring to, Writer in your case
04:46:03 <hiptobecubic> ClaudiusMaximus, this approxeq class is a nice trick.
04:46:10 <merijn> tell is also just a function of the Writer monad, which produces nice name clashes if you accidentally import both :p
04:46:30 <mm_freak_> then you get he Show instance error, which just means that whatever library is implementing your Writer monad did not provide a Show instance
04:47:18 <hpaste> raulcaj pasted “I/O delayed” at http://hpaste.org/80451
04:48:04 <raulcaj> can anyone help me? why putStr only happens when getLine_ terminates?
04:48:51 <hiptobecubic> ClaudiusMaximus, actually this whole thing is neat. It's weird to see linalg done 'haskelly' with normal old ADTs
04:48:59 <merijn> raulcaj: Because output is buffered and putStr doesn't flush it until it prints a \n
04:49:08 <hpaste> raulcaj annotated “I/O delayed” with “I/O delayed (annotation)” at http://hpaste.org/80451#a80452
04:49:10 <merijn> raulcaj: Set stdout to be unbuffered
04:49:37 <merijn> raulcaj: That, or manually flush stdout after every putStr
04:50:59 <kennyd> he will still have issues with stdin buffering, which is done at OS level. not sure if haskell provides the functions to change this behavior
04:51:57 <raulcaj> I already did "hSetBuffering stdin NoBuffering" and "hSetBuffering stdout NoBuffering" but still.. no success...
04:52:33 <ski> did you try `hFlush stdout' yet ?
04:52:37 <raulcaj> also did hFlush stdout after each putStr.. but stil..
04:52:57 <EarlGrayW> raulcaj: what OS do you use?
04:52:58 <mrxy> would Writer be appropriate for reporting parsing errors?
04:53:09 <raulcaj> I'm using Windows 7
04:53:41 <raulcaj> Haskell Platform 2012.04
04:54:19 <ski> > runWriter $ do tell "blah"
04:54:20 <lambdabot>   ((),"blah")
04:55:40 <ski> mrxy : no, unless you do error-correcting parsing
04:55:50 <ClaudiusMaximus> hiptobecubic: thanks!
04:56:29 <mrxy> yeah I got the feeling I am trying to misuse it. what should I use instead?
04:57:16 <hiptobecubic> ClaudiusMaximus, you were complaining about speed? In general or compared to some other language?
04:58:08 <ClaudiusMaximus> hiptobecubic: in general, it's because my algorithms are rubbish
04:58:10 <mrxy> I am parsing a file line by line, and I want to report line where the errors happened as well as details about the error
04:58:32 <hiptobecubic> ClaudiusMaximus, ah. Life is hard.
04:58:39 <ClaudiusMaximus> hiptobecubic: in particular it's in one function that finds equivalence classes for colouring...
05:00:13 <hiptobecubic> i think my gl bindings are too old
05:00:32 <`nand`> ski: cwiid is a driver and set of utilities for the nintendo wiimote
05:01:04 <ClaudiusMaximus> hiptobecubic: ...which i also realized is buggy in general (it doesn't merge equivalence classes, so depending on order of input you could get too many)
05:01:25 <ski> ok
05:03:17 <ClaudiusMaximus> hiptobecubic: anyway, that function is quadratic complexity, but using a more clever algorithm (like figuring out the colour permutations for each of the transformations as in the flat planar case) it would be linear
05:03:51 <mysticc> Can we access hpc from ghc api?
05:04:18 <ClaudiusMaximus> hiptobecubic: i suppose i could figure out the permutations from a coloured smaller region and then use those for the larger version
05:06:21 <merijn> mrxy: I think parsec actually had semi-builtin support for something like that?
05:07:25 <merijn> mrxy: The RWH Parsec chapter has an example that reports line numbers, for example
05:08:46 <hiptobecubic> ClaudiusMaximus, well it's a nice project
05:09:06 <hiptobecubic> ClaudiusMaximus, needs a cabal file so I know what to install :(
05:10:13 <ClaudiusMaximus> hiptobecubic: cabal install GLUT repa-devil -- should do the trick
05:10:30 <hiptobecubic> aha, glut
05:10:31 <ClaudiusMaximus> hiptobecubic: but yes, it's on my todo list..
05:11:55 <mSSM> Is there a smarter way adding profiling flags than `cabal-dev install --ghc-options="-prof -auto-all -caf-all" ' ?
05:12:18 <ClaudiusMaximus> hiptobecubic: as are spherical versions, more hyperbolic versions, and a unified front end allowing you to choose number of triangles about each vertex
05:12:25 <mSSM> Is it possible to write those flags into the .cabal file?
05:12:38 <Wizek> How can I tell haskell to stop evaluating a list comprehension after a certain point? I'd like something like this: `[x|x<-[1..], x+1 < 50]`
05:13:10 <t7> <- take 50 [1..]
05:13:15 <mSSM> Wizek: Do you want 50 elements?
05:13:16 <t7> or [1..50]
05:13:23 <ClaudiusMaximus> Wizek: takeWhile
05:13:38 <ClaudiusMaximus> Wizek: but there's no list-comp syntax for that afaik
05:13:40 <Wizek> yes, takewhile sounds like it
05:13:58 <Wizek> That may not ba a problem, thanks ClaudiusMaximus
05:14:19 <alpounet> mSSM, yes, a "ghc-prof-options" field in your "library"/"executable" section in the cabal file
05:15:02 <alpounet> mSSM, which will be triggered by --enable-{library, executable}-profiling when passed to cabal-dev install
05:15:17 <mSSM> alpounet: Cool, that would habe been my next question.
05:15:23 <mSSM> alpounet: thanks
05:15:34 <mSSM> ClaudiusMaximus: thanks for your reply earlier
05:15:38 <hpaste> raulcaj annotated “I/O delayed” with “I/O delayed (annotation)” at http://hpaste.org/80451#a80453
05:15:51 <alpounet> mSSM, note that in the very same vein, you can put your usual build options in a "ghc-options" field
05:16:46 <mSSM> alpounet: These fields I put in each executable section?
05:17:11 <raulcaj> Does anyone knows a function equivalent to 'getChar' but that don't waits for Enter key being hit?
05:17:37 <ClaudiusMaximus> raulcaj: getChar, but with hSetBuffering stdin NoBuffering
05:17:42 <alpounet> mSSM, yes
05:18:04 <alpounet> it's always specific to a library/executable that is part of your cabal package
05:18:40 <ToranLipse> Hello, if I have data Tree x = Leaf x | Branch [Tree x], how do I test to see if an item is a leaf or a branch?
05:18:50 <Taneb> Pattern matching
05:19:13 <Taneb> isLeaf (Leaf _) = True; isLeaf _ = False
05:19:23 <raulcaj> C:\root\home\haskell\box>ghci
05:19:23 <raulcaj> GHCi, version 7.4.2: http://www.haskell.org/ghc/  :? for help
05:19:23 <raulcaj> Loading package ghc-prim ... linking ... done.
05:19:23 <raulcaj> Loading package integer-gmp ... linking ... done.
05:19:23 <raulcaj> Loading package base ... linking ... done.
05:19:23 <raulcaj> Prelude> :m + System.IO
05:19:25 <raulcaj> Prelude System.IO> hSetBuffering stdin NoBuffering
05:19:27 <raulcaj> Prelude System.IO> getChar
05:19:28 <ToranLipse> Ah ok thanks.
05:19:31 <raulcaj> asdaada
05:19:33 <raulcaj> 'a'
05:19:37 <raulcaj> sorry, didn't work
05:19:39 <ToranLipse> Why is it in ()?
05:20:08 <Taneb> Because GHCi specialises it
05:20:12 <hiptobecubic> ClaudiusMaximus, almost.... errors at runtime :(   http://vpaste.net/zxFSq
05:20:19 <`nand`> raulcaj: works fine for me
05:20:33 <Taneb> "let isLeaf (Leaf _) = True; isLeaf _ = False; isLeaf :: Tree x -> Bool"
05:20:37 <Taneb> That should work, ToranLipse
05:20:55 <tdammers> mrxy: there's getPosition in Text.Parsec.Prim
05:20:55 <`nand`> my output is "λ getChar\na'a'\nλ " where λ is the GHCi prompt and \n is a newline
05:21:12 <raulcaj> Which OS?
05:21:18 <`nand`> Gentoo Linux
05:21:48 <raulcaj> maybe it don't work well com Windows..
05:21:53 <ToranLipse> It does, thanks.
05:21:57 <raulcaj> on*
05:22:09 <`nand`> raulcaj: have you tried using a different terminal emulator / shell?
05:22:17 <`nand`> the stock windows one isn't very good
05:23:10 <raulcaj> thanks.. I'll do some more research..
05:23:10 <mSSM> alpounet: I suppose I am still doing something wrong: this section in the exectuable field fails: ghc-prof-options:    "-prof -auto-all -caf-all", while specifying --ghc-options="-prof -auto-all -caf-all" as an argument to cabal-dev install works
05:23:38 <kennyd> it appears to be an old bug that unfortunately hasn't been fixed yet. http://hackage.haskell.org/trac/ghc/ticket/2189
05:23:39 <mSSM> alpounet: I am getting the error: ghc: unrecognised flags: -prof -auto-all -caf-all
05:24:11 <mSSM> This is with --enable-executable-profiling through the .cabal file
05:24:54 <akamaus> where is the 'many' combinator in attoparsec?
05:24:56 <alpounet> mSSM, try removing the " "s
05:25:00 <ToranLipse> Taneb?
05:25:21 <ClaudiusMaximus> hiptobecubic: ah, then maybe your graphics drivers are not good enough?  not sure which gl version geometry shaders are in
05:25:22 <mSSM> alpounet: thanks
05:25:33 <Taneb> ToranLipse, yeah?
05:25:41 <ClaudiusMaximus> hiptobecubic: also i seem to have a #version 400 in the glsl, which might be overkill
05:25:44 <`nand`> akamaus: attoparsec doesn't export ‘many’
05:25:47 <ToranLipse> Im trying to create a map function for tree and this is the best I can come up with:
05:25:48 <ToranLipse> mapTree :: (a -> b) -> Tree a -> Tree b
05:25:49 <ToranLipse> mapTree f t
05:25:49 <ToranLipse>  | isTip t = f t
05:25:49 <ToranLipse>  | otherwise = map (mapTree f) t
05:25:55 <`nand`> it exports many', many1 and many1' though
05:25:56 <kennyd> raulcaj see this for a workaround: http://stackoverflow.com/questions/2983974/haskell-read-input-character-from-console-immediately-not-after-newline
05:25:58 <ToranLipse> But its not working.
05:26:20 <Taneb> ToranLipse, first, you'd use pattern matching whenever you could
05:26:29 <Taneb> mapTree f (Leaf x) = ...
05:26:35 <ToranLipse> Oh!
05:26:39 <hiptobecubic> ClaudiusMaximus, latest intel on chip graphics.
05:26:41 <Taneb> mapTree f (Branch xs) = ..
05:26:44 <ToranLipse> Yeh, sorry. That makes sense.
05:26:50 <Taneb> No, that's just a style point
05:27:05 <akamaus> nand, oh, looks like I can use 'many' from Control.Applicative. Right?
05:27:11 <`nand`> akamaus: yeah looks like it
05:27:16 <`nand`> or .Alternative, whatever
05:27:20 <Taneb> The code you've got for when it's a leaf gives you a "b", not a "Tree b", ToranLipse
05:27:25 <`nand`> oh wait, Alternative is defined in C.Applicative
05:27:36 <ToranLipse> Oh.
05:27:37 <ClaudiusMaximus> hiptobecubic: mm, probably not badass enough - the hyperbolic version doesn't need geometry shader, so i can try to do it that way when i merge them
05:28:05 <ToranLipse> How do I solve that?
05:28:13 <Taneb> Follow the types
05:28:19 <Taneb> What's the type of "t"?
05:28:23 <ToranLipse> Tree
05:28:24 <`nand`> find b -> Tree b
05:28:32 <ClaudiusMaximus> hiptobecubic: what does glewinfo|head say? (debian package glew-utils iirc)
05:28:38 <`nand`> (or, arguably, figure out what the function should be doing first; then look for the appropriate functions ;)
05:28:40 <hiptobecubic> ClaudiusMaximus, i don't see what about this needs anything fancy
05:28:43 <Taneb> And what's the type of "f"?
05:28:55 <`nand`> for a ‘map’-style function, you probably want mapTree id = id
05:28:58 <hiptobecubic> ClaudiusMaximus, http://vpaste.net/Nug3n
05:28:59 <ToranLipse> a -> b
05:29:01 <ClaudiusMaximus> hiptobecubic: it's because i wrote it in a bizarre way
05:29:07 <Taneb> So, can you use f on t?
05:29:14 <ClaudiusMaximus> hiptobecubic: will fix it later this week
05:29:15 <`nand`> so that would mean that mapTree id (Tree x) would have to evaluate to Tree x
05:29:17 <`nand`> err
05:29:19 <`nand`> s/Tree/Tip/
05:29:32 <hiptobecubic> ClaudiusMaximus, be sure to @tell me when you do. :)
05:29:33 <ToranLipse> I dont know.
05:29:37 <Yrogirg> hello! Has anyone tried iHaskell --- haskell interprtor for iOS? How is it? https://itunes.apple.com/us/app/ihaskell/id581754371?mt=8
05:29:44 <`nand`> ToranLipse: the type of ‘t’ isn't Tree
05:29:49 <ClaudiusMaximus> hiptobecubic: will do, i'll try to make it OpenGL 2.1 compatible
05:29:52 <S11001001> sounds illegal, Yrogirg
05:29:57 <ToranLipse> Its a Leaf or a Branch then?
05:30:08 <Yrogirg> S11001001, why?
05:30:20 <`nand`> it's Tree a
05:30:23 <ToranLipse> Oh.
05:30:39 <ClaudiusMaximus> hiptobecubic: but now i have to go out, should be back in a couple of hours...
05:31:01 <hiptobecubic> ClaudiusMaximus, this chip should do opengl 4, in theory. drivers must be behind the times
05:31:07 <hiptobecubic> ClaudiusMaximus, sure. Toodleoo
05:31:11 <Taneb> ToranLipse, to map over something, you need to "get it out", apply the function, then "put it back in"
05:31:40 * `nand` experiences an irresistible urge to cry out ‘lenses!’
05:31:44 <ToranLipse> How do I go about doing that?
05:31:51 <Taneb> Pattern matching to get it out
05:31:59 <ToranLipse> Ok.
05:32:02 <ToranLipse> Let me try again.
05:32:27 <Taneb> If you say "foo (Leaf t) = bar", and apply foo to something of type "Tree x", t would have type x
05:32:34 <S11001001> Yrogirg: the interpreter rules for app store (unless those changed again), also I believe Apple owns starting a product name with the letter i
05:33:25 <S11001001> Yrogirg: anyway an IRC connection to freenode and a chat session with lambdabot is more useful, and even includes "share results with friends" (in #haskell)
05:33:52 <tdammers> S11001001: Apple *tried* to own the i- prefix, but were overruled in court
05:33:55 <`nand`> S11001001: but no IO
05:34:12 <`nand`> tdammers: doesn't mean they can't disallow it in their app store
05:34:20 <tdammers> they can have any specific iSomething protected as a trademark, but not the general concept of prefixing i-
05:34:30 <tdammers> `nand`: point taklen.
05:34:31 <S11001001> `nand`: not sure what IO you'd do in that app :)
05:34:34 <tdammers> taken, even.
05:34:37 <`nand`> that being said, that wouldn't make it ‘illegal’
05:34:50 <tdammers> for some values of 'illegal'
05:34:56 <`nand`> and if it's on the apple.com app store... they surely look at everything before accepting it
05:34:58 <`nand`> w/e
05:35:01 <tdammers> as in, violating an agreement between you and apple
05:35:05 <S11001001> `nand`: well...
05:35:09 <`nand`> tdammers: fair enough
05:35:46 <`nand`> can't you just, like, run GHCi on the iOS? :)
05:35:50 <ToranLipse> How about this? Any closer... lol
05:35:51 <ToranLipse> mapTree :: (a -> b) -> Tree a -> Tree b
05:35:51 <ToranLipse> mapTree f (Leaf a) = (Leaf (f a))
05:35:51 <ToranLipse> mapTree f (Branch xs) = map (mapTree f) xs
05:35:54 <`nand`> is it a POSIX environment?
05:36:04 <`nand`> ToranLipse: the first two lines look correct
05:36:07 <Taneb> ToranLipse, closer
05:36:11 <tdammers> `nand`: that would seriously surprise me
05:36:16 <`nand`> the last one is almost correct
05:36:26 <mrxy> there is Hugs on cydia
05:36:35 <Taneb> ToranLipse, `nand` is a lot better at this than I am. Listen to him
05:36:36 <`nand`> ToranLipse: ‘map (mapTree f) xs’ has type [Tree a], but you want Tree a;
05:37:03 <`nand`> sorry
05:37:07 <`nand`> it has [Tree b], you want Tree b
05:37:10 <Yrogirg> S11001001, interpreters are allowed with certain limitations, there is a couple of scheme interpreters already.
05:37:30 <ToranLipse> How do I get it out of the list then?
05:37:46 <dmwit> That's backwards -- you want to put it in the tree, not take it out of the list. =)
05:37:50 <`nand`> ToranLipse: it's not so much getting it-- yeah
05:38:03 <ToranLipse> Oh!
05:38:03 <Taneb> ToranLipse, you put it back in a Tree
05:38:04 <`nand`> ToranLipse: you took off the Branch constructor but you don't put it back again :)
05:38:10 <ToranLipse> (Branch ())?
05:38:19 <ToranLipse> with all that inside the ()?
05:38:21 <`nand`> if by () you meant (map (ma-- yeah
05:38:33 <ToranLipse> Ah! I get it. Thank you =)
05:39:35 <`nand`> it's probably good to write (...) when omitting something like that, since () is a valid value ;)
05:39:50 <`nand`> (admittedly, so is (...), but that one's much less likely to cause confusion)
05:42:14 <srhb> I don't have the (...) operator. I feel cheated.
05:42:30 <`nand`> let (...) = error "et cetera"
05:43:09 <srhb> Yum.
05:51:41 <alpounet> > let { (...) [] = [] ; (...) [x] = repeat x ; (...) x@(x0:xs) = scanl (+) x0 ((zipWith (-) xs x)...) } in take 10 ([1,4,9]...)
05:51:42 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
05:52:20 <alpounet> (from http://codepad.org/WDXeV59b)
05:54:00 <basdirks> cool
05:56:51 <djcoin> oO
05:57:40 * hackagebot snaplet-postgresql-simple 0.3.0.1 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.3.0.1 (DougBeardsley)
05:57:55 <mSSM> when write an immutable vector, I can force a strict evaluation with "v' = v // [(a,b)]", so that I don't get a huge heap of v's. For performace reasons, I have switched to Mutable vectors: how can I make a strict unsafeWrite ?
05:58:03 <mSSM> When writing to*
05:58:26 <mSSM> oh, sorry, this should read: "!v' = v // [(a,b)]"
06:02:23 <Saizan> for mutable stuff writes are already strict, wrt the spine at least
06:02:47 <Saizan> you might want to force the element though, if you're not using an unboxed vector
06:04:33 <mSSM> Saizan: as in, I make the element I am writing strict, before I write to the vector?
06:05:04 <mSSM> I actually just tried that; dropped my heap from 45MB to 1.6KB
06:05:07 <mSSM> crazy
06:06:05 <Saizan> heh, what's the type of your elements?
06:07:10 <srhb> Is there ever a reason to use boxed vectors?
06:07:45 <Saizan> srhb: if your elements are too painful to get unboxed
06:07:56 <srhb> Saizan: Hm.
06:08:01 <Saizan> or if you are using it as a memotable
06:08:15 <srhb> Ah, right. That's actually quite clever.
06:08:29 <srhb> Epiphanies!
06:09:27 <mSSM> Unboxing is the next thing I will do
06:09:31 <mSSM> Saizan: Elements are just Integers
06:09:51 <Saizan> Int unboxes fine, Integer less so
06:10:02 <mSSM> Oh, Ints then :)
06:10:26 <mSSM> They are just +1, -1
06:10:28 <mSSM> So that's fine
06:11:00 <srhb> Then even Ints are a bit big
06:11:02 <srhb> Go deeper!
06:11:03 <srhb> :o
06:11:04 <absence> can randomR (1, 10::Double) return 10?
06:11:18 <srhb> but I guess it doesn't matter since they won't be packed together :P
06:11:31 <srhb> > 10 :: Double
06:11:33 <lambdabot>   10.0
06:11:35 <srhb> absence: Yes
06:12:10 <ziman> according to the doc, the interval is closed
06:12:20 <tdammers> "For continuous types there is no requirement that the values lo and hi are ever produced, but they may be, depending on the implementation and the interval. "
06:12:29 <mSSM> srhb: Is there a list of such types supported by haskell?
06:12:34 <Saizan> Bool's do get packed in UArray, not sure about vector though
06:14:15 <srhb> Saizan: Oh really. Fancy.
06:14:41 <absence> srhb: does that mean random and randomR (0, 1::Double) are not the same?
06:15:02 <srhb> absence: Look what tdammers said
06:15:10 <tdammers> might also want to read the source
06:15:15 <tdammers> http://hackage.haskell.org/packages/archive/haskell98/latest/doc/html/src/Random.html#randomR
06:15:36 <absence> ah sorry, thanks!
06:16:14 <tdammers> basically, what randomR does for doubles is generate a random 32-bit integer, and scale it to the specified range
06:16:19 <EarlGrayW> Ahem, I've tried an example from RWH chapter 20, "System programming", and it does not work:
06:16:21 <EarlGrayW> getDirectoryContents >>= return . filter (`notElem` ["." :: FilePath, ".."])
06:16:38 <EarlGrayW> what has change?
06:16:38 <tdammers> and random is defined as randomR (0, 1) for Doubles
06:17:27 <int-e> electrogeek: that's missing an argument for getDirectoryContents
06:18:05 <srhb> EarlGrayW: ^^^ what int-e said
06:18:18 <EarlGrayW> thanks
06:18:37 <EarlGrayW> my omission
06:18:41 <srhb> Yep. :)
06:18:46 <absence> tdammers: the docs says the range of random is [0,1) for fractional types. does that include the continuous types which according to randomR has the range [0,1]?
06:19:34 <EarlGrayW>  filter (`notElem` [".", ".."]) <$> getDirectoryContents "/" -- seems much more nicer :)
06:19:40 <mSSM> Hm, changing from Boxed to Unboxed vectors just gave me a speed decrease of 33%
06:19:50 <mSSM> Isn't that supposed to be the other waye round?
06:19:56 <tdammers> absence: reading the source, my conclusion would be that both ends of the interval *can* be produced by randomR, at least for doubles
06:20:03 <srhb> EarlGrayW: Yes, foo >>= return . bar -- is bad style
06:20:09 <mm_freak_> mSSM: unboxed vectors force every value
06:20:29 <Jafet> mSSM: "I sold my pickup truck for a european car. WHY IS IT SLOWER?"
06:20:39 <andsens_> I have a problem with Parsec recognizing comments: I am parsing mustache templates. The various tags all start with "{{". So does the block comment however ("{{! comment }}"), i have set commentStart and commentEnd to "{{!" and "}}". Whenever I add comments to a template, parsec complains that the comment is unexpected. When does Parsec remove comments, I thought it would happen before the source hits my parser?
06:20:44 <mm_freak_> mSSM: try this:  main = fromList [undefined] `seq` return ()
06:21:06 <mm_freak_> mSSM: will do nothing with boxed vectors and throw an exception with unboxed vectors
06:21:50 <mSSM> mm_freak_: My vector only holds Ints and is of fixed size. I thought using Unboxed makes sense.
06:21:50 <absence> tdammers: so if random = randomR (0,1) for Doubles, either the code or documentation is wrong?
06:22:07 <mm_freak_> mSSM: that doesn't make the Ints easy to caluclate
06:22:08 <mm_freak_> calculate
06:22:29 <tdammers> not 100% sure
06:22:39 <mm_freak_> mSSM: (fromList . map (^10000000)) [2..9]
06:23:20 <Jafet> Almost none of the Double instances make any sense, what do you expect anyway
06:23:21 <tdammers> depends whether randomIvalInteger's range is inclusive or exclusive
06:23:35 <mm_freak_> mSSM: using unboxed vectors doesn't just speed things up, it also changes semantics
06:23:50 <mm_freak_> the change in semantics can very well make your program slower
06:24:07 <srhb> absence: I don't see how the documentation is wrong? Or the implementation
06:24:07 <mm_freak_> in other words:  boxed vs. unboxed is not just a representation change, but also a change in programming paradigm
06:24:25 <mSSM> mm_freak_: Ok, I think my understanding of these things is not deep enough to account for that.
06:25:11 <mSSM> mm_freak_: In particular, I wouldn't know where to start looking for why the Unboxed version performes slower, and if I can make it faster.
06:25:18 <mm_freak_> mSSM: just think about this:  a boxed vector of 100000 complicated values is lazy, so the vector is created instantly and the values are only caluclated when you actually ask for them
06:25:47 <mm_freak_> mSSM: an unboxed vector is one continuous blob of fully evaluated values in memory, so once you create the vector, all values are also calculated
06:26:33 <absence> srhb: ah, i assumed random = randomR (0,1) for Doubles as tdammers mentioned, but he must have been looking at an older version, because the current version does x/(x+1)
06:26:35 <mm_freak_> mSSM: compare the time needed here:  V.length (V.singleton (3^1000000 :: Int))
06:26:47 <mm_freak_> mSSM: where V = Data.Vector in one case and V = Data.Vector.Unboxed in the other
06:27:03 <Jafet> > 3^1000000 :: Int
06:27:04 <lambdabot>   7682401271709541633
06:27:12 <tdammers> srhb: if randomR uses [l,h], and randomR is documented to use [0,1) but implemented as randomR (0,1), then that's kind of contradictory
06:27:47 <absence> tdammers: random isn't implemented as randomR (0,1)
06:28:17 <tdammers> it is for Doubles?
06:28:33 <tdammers> instance Random Double where
06:28:37 <tdammers>   random g       = randomR (0::Double,1) g
06:28:41 <absence> tdammers: what version?
06:28:50 <tdammers> http://hackage.haskell.org/packages/archive/haskell98/latest/doc/html/src/Random.html#randomR
06:28:53 <tdammers> hmm wait
06:28:56 <tdammers> haskell98
06:29:08 <absence> http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/src/System-Random.html#randomR
06:29:18 <absence> :)
06:29:42 <tdammers> yep
06:29:52 <tdammers> complete rewrite of the Double instance
06:30:19 <tdammers> amazing what 15 years of maturing can do to a programming language ;)
06:30:53 <absence> for sure :)
06:46:22 <fragamus> hey fellas I am trying to write some code that steps through the Word8s in a ByteString.Internal
06:47:19 <fragamus> I have a math operation that I need to do. It is presently written using fold and I am "pretending" I know how to step through the Word8s
06:47:59 <shachaf> What's wrong with fold?
06:48:05 <fragamus> I am mainly concerned that I don't want to incur any memory allocation
06:48:18 <Taneb> foldl does what you want
06:48:18 <shachaf> (Other than it having broken strictness in bytestring -- but that's a different matter.)
06:48:22 <akamaus> fragamus, why not to use scans?
06:48:46 <akamaus> er
06:49:24 <fragamus> well ok so… I can make an array of Word8 using unpack or something?
06:49:42 <fragamus> er… list of Word8
06:49:51 <shachaf> You can.
06:50:03 <fragamus> will that incur memory alloc?
06:50:04 <shachaf> But be careful of foldr/build fusion mssing up your program. :-)
06:50:17 <shachaf> See http://hackage.haskell.org/trac/ghc/ticket/7556
06:50:48 <simpson> fragamus: You probably can't avoid *any* memory allocation. If you're worried about copying the ByteString, you're probably in the clear.
06:50:59 <fragamus> oh yeah
06:51:16 <fragamus> I don't mind a constant size alloc
06:51:18 <Jafet> I use bytestrings as integers my code is efficient durrr
06:51:37 <fragamus> Jafet that is cool. I want to do that
06:52:24 <fragamus> it seems that there is no Integral instance for ByteString
06:53:03 <fragamus> my dream would be to have an Integral instance for internal ByteString
06:53:06 <Taneb> That's because it's stupid and less efficient than using Integer
06:53:06 <shachaf> dcoutts: Oh, you replied. Thanks for working on it!
06:53:24 <mm_freak_> fragamus: allocations aren't usually a problem in haskell…  it's just what other languages would call putting some local variables on the stack in haskell is called allocation, too, because a "call stack" is not used
06:53:25 <shachaf> dcoutts: Is there a recommended workaround for now? Calling B.Internal.unpackBytes directly, or something?
06:53:35 <shachaf> Actually, that doesn't work on bytestring 0.9.
06:54:40 <mm_freak_> fragamus: also if you're doing mathematical stuff, ByteString is likely the wrong choice
06:54:49 <fragamus> Yeah it is
06:54:53 <fragamus> but
06:55:08 <fragamus> Im immersed in it for other reasons
06:55:14 <mm_freak_> fragamus: if you actually need fast finite lists of values, go for Vector
06:55:44 <fragamus> well I don't have freedom to use other than ByteString Internal
06:55:58 <fragamus> and to use other will cost something in performance
06:56:03 <fragamus> for the conversion
06:56:06 <mm_freak_> fragamus: you can go from ByteString to Vector easily, even without conversion overhead
06:56:16 <fragamus> now you're tawkin
06:56:17 <mm_freak_> see Data.Vector.Storable
06:56:34 <Jafet> Vector doesn't have a Num instance either
06:57:49 <mm_freak_> would be stupid anyway…  if i would have to regard a byte array as an integer, i would create an Integer in the first place
06:58:03 <mm_freak_> which is just a byte array internally
06:58:13 <mm_freak_> at least in the "large integer" case
06:58:58 <mm_freak_> fragamus: btw, if you use repa (a library around vectors), you also get parallelization for free
06:59:07 <mm_freak_> speed = vector
06:59:17 <Jafet> But repa allocates memory, man!
06:59:20 <Jafet> It's bad.
07:07:10 <kamatsu> repa allocates memory only at the very end of the computation
07:07:31 <kamatsu> you get a great deal out of its delaying and fusing of computation
07:08:36 <Jafet> That's mainly because people are lazy and only force the result
07:08:55 <kamatsu> that's the point of repa
07:09:12 <kamatsu> delay computations as much as possible to build up work, it makes parallelizing much more efficient
07:10:22 <shachaf> There's no way to write e.g. foo :: Dynamic -> Maybe String which tries to "show" its argument, right?
07:10:39 <kamatsu> not easily
07:10:42 <HugoDaniel> here is a simple benchmark of IntMap/HashMap/Boxed Vector if anyone cares http://pastie.org/5647610
07:10:44 <kamatsu> you could write your own custom existential
07:10:45 <shachaf> Of course using Dynamic for things like that is a bad thing anyway.
07:11:05 <Jafet> You could emulate show
07:11:11 <kamatsu> data CanShow where ExI :: Show a => a -> CanShow
07:11:20 <kamatsu> then just use that rather than dynamic
07:11:21 <shachaf> kamatsu: Sure, but this is some sort of (Map String Dynamic) that is used in a bunch of different places.
07:11:24 <shachaf> Apparently.
07:11:35 <shachaf> kamatsu: If someone was making an existential like that, I'd tell them to just use String. :-)
07:11:40 <kamatsu> you could roll your own Dynamic that uses Show as well as Typeable?
07:11:52 <Jafet> shachaf is writing php?
07:11:57 <elliott> CanShow ~ String
07:12:02 <shachaf> This isn't my code.
07:12:16 <Jafet> Yes, but you're writing in it
07:12:16 <elliott> shachaf: you could make a Typeable/Dynamic thing which gives access to instances
07:12:24 <elliott> might need compiler support though?
07:12:35 <kamatsu> Do you have full knowledge of what types the Dynamic can be?
07:12:44 * hackagebot HLearn-distributions 0.2.1 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-0.2.1 (MikeIzbicki)
07:12:53 <shachaf> Apparently yes, so you could enumerate through the types until one works.
07:13:05 <kamatsu> then just transform the Dynamic into a sum type
07:13:23 <shachaf> kamatsu: Full knowledge in *this particular case*.
07:13:32 <shachaf> The Map String Dynamic is used in a lot of other places, apparently.
07:13:44 <Jafet> Transform it in this particular case
07:13:48 <kamatsu> OK, well, just write a function Dynamic -> SomeSumType
07:13:56 <kamatsu> and deriving instance Show SomeSumType
07:14:00 <shachaf> Might as well write Dynamic -> String in this case.
07:14:15 <kamatsu> oh, i was assuming that you'd want it for something more than just showing
07:14:22 <shachaf> (Except that the class isn't Show but something else with a single method a -> T.)
07:14:54 <chrisdone> prefixed :: Eq a => a -> [a] -> (Maybe a,[a])
07:14:54 <chrisdone> prefixed prefix = go where
07:14:54 <chrisdone>   go (x:y:rest)
07:14:54 <chrisdone>     | x == prefix = (Just y,rest)
07:14:57 <chrisdone>     | otherwise   = fmap (x:) (go (y:rest))
07:14:57 <Jafet> Can't you just emulate show?
07:15:00 <chrisdone> this already defined anywhere as a single function?
07:15:02 <Jafet> Oh, that only works for Data.
07:15:12 <Jafet> @hoogle stripPrefix
07:15:12 <lambdabot> Data.List stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]
07:15:12 <lambdabot> Data.Text stripPrefix :: Text -> Text -> Maybe Text
07:15:12 <lambdabot> Data.Text.Lazy stripPrefix :: Text -> Text -> Maybe Text
07:15:46 <Jafet> Wait, what
07:16:01 <kamatsu> what's prefixed supposed to do?
07:16:08 <chrisdone> λ> prefixed 42 [1,2,3,42,4,5,6,7]
07:16:09 <chrisdone> (Just 4,[1,2,3,5,6,7])
07:16:41 <kamatsu> that seems like an odd function to expect to be in stdlibs
07:16:47 <chrisdone> ah, forgot to include comment:
07:16:47 <chrisdone> -- | Extract the element prefixed by the given element in the list.
07:16:58 <mauke> how is that useful?
07:17:29 <Eduard_Munteanu> Typeclasses are to universes (as in Power of Pi), as <what?> are to datatypes?
07:17:54 <Eduard_Munteanu> IOW, is there a name for open types?
07:18:26 <chrisdone> i'll take that as a no/i don't know ;)
07:18:32 <kamatsu> chrisdone, usually when I write a function like that I feel like i'm doing it wrong
07:18:57 <kamatsu> but i don't know your use case, so ehhh...
07:19:02 <Jafet> > case break (42==) [1,2,3,42,4,5,6,7] of (a,_:x:b) -> (Just x, a++b)
07:19:04 <lambdabot>   (Just 4,[1,2,3,5,6,7])
07:19:12 <Jafet> ; _ -> error "who designed this function"
07:20:02 <Jafet> Oh, a drive-by question
07:21:41 <Jafet> @pl \(a,_:x:b) -> (Just x, a++b)
07:21:41 <lambdabot> uncurry ((. tail) . (`ap` tail) . (. head) . flip ((.) . (,) . Just) . (++))
07:22:06 <kamatsu> feel like there might be an easier way
07:22:09 <Jafet> @produce-lens \(a,_:x:b) -> (Just x, a++b)
07:22:09 <lambdabot> Unknown command, try @list
07:22:50 <kamatsu> maybe use &&&?'
07:23:22 <kamatsu> (Just . head . tail . snd) &&& something
07:24:22 <ToranLipse> http://pastebin.com/HhK7Zywi Can someone explain how I make tips2 work with foldrTree?
07:24:26 <ToranLipse> Please?
07:24:27 <kamatsu> uncurry (++) . second (drop 2)
07:24:27 <mauke> The paste HhK7Zywi has been copied to http://hpaste.org/80455
07:25:21 <kamatsu> ((Just . head . tail . snd) &&& uncurry (++) . second (drop 2)) $ break (42==) [1,2,3,42,4,5,6,7]
07:25:28 <kamatsu> > ((Just . head . tail . snd) &&& uncurry (++) . second (drop 2)) $ break (42==) [1,2,3,42,4,5,6,7]
07:25:30 <lambdabot>   (Just 4,[1,2,3,5,6,7])
07:25:38 <kamatsu> Jafet: there you go
07:25:48 <Jafet> I don't see any lenses
07:25:54 <kamatsu> nah, just Control.Arrow
07:26:22 <kamatsu> I think it's easier than @pl's version
07:26:30 <shachaf> Jafet: "produce-lens" is called "upon"
07:26:53 <Jafet> :t upon
07:26:54 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] k) => (s -> a) -> k (a -> f a) (s -> f s)
07:27:02 <shachaf> Unfortunately I don't think it works here.
07:27:24 <Jafet> That's a superb list of constraints
07:27:47 <edwardk> Jafet: there is no lens that takes (a,_:x:b)   to (Just x, a ++ b)
07:27:54 <edwardk> you can't pass the laws
07:27:55 <kamatsu> ToranLipse: you shouldn't give the identity function to foldrtree
07:28:20 <quicksilver> Data.Data.Data => from the Catch-22 school of typeclass numbering
07:28:23 <Jafet> I don't think upon produces a lens as much as it produces a little version of haskell where the lens works
07:28:24 <kamatsu> ToranLipse: You want the result of the function to be [a], so instead of id you should give a function a -> [a], such as return
07:29:01 <kamatsu> foldrTree return (++)  [] t should work
07:29:06 <edwardk> > "hello world" & upon (!!4) .~ 'x'
07:29:08 <lambdabot>   "hellx world"
07:29:30 <edwardk> > "hello world" & upon last .~ 'x'
07:29:32 <lambdabot>   "hello worlx"
07:29:33 <ToranLipse> Oh ok.
07:29:35 <ToranLipse> Thanks.
07:29:40 <ToranLipse> =)
07:29:51 <edwardk> it uses magic though, there are plenty of functions it can't do
07:30:01 <hiptobecubic> i wish all of the lenses sounded like olde english
07:30:08 <Jafet> :t betwixt
07:30:09 <lambdabot> Not in scope: `betwixt'
07:30:13 <hiptobecubic> yes
07:30:20 <Jafet> :t astride
07:30:21 <lambdabot>     Not in scope: `astride'
07:30:21 <lambdabot>     Perhaps you meant `aside' (imported from Control.Lens)
07:30:25 <edwardk> i've been looking for a use for 'athwart'
07:30:27 <kamatsu> beholden?
07:30:37 <elliott> :t withal
07:30:37 <kamatsu> forasmuch?
07:30:38 <Wizek> When writing functions with haskell I sometimes impove them by copying them and adding an `'` after their name. But with recursive ones I sometimes forget to update the self-reference names, so only the first iteration runs with the new code, and the rest with the old one. Can I self-reffer like this: `fibs = 0 : 1 : zipWith (+) recurse (tail recurse)`  (instead of `fibs = 0 : 1 : zipWith (+) fibs (tail fibs)`)?
07:30:38 <lambdabot>     Not in scope: `withal'
07:30:38 <lambdabot>     Perhaps you meant `within' (imported from Control.Lens)
07:30:52 <elliott> Wizek: You can use fix.
07:30:56 <shachaf> Wizek: fibs = fix $ \recurse -> ...
07:30:57 <elliott> fibs = fix $ \me -> 0 : 1 : zipWith(+) me (tail me)
07:31:08 <shachaf> It's not too idiomatic, though.
07:31:10 <kamatsu> Wizek: use fixpoint
07:31:18 <elliott> shachaf: Well, neither is having a bunch of versions of the same function.
07:31:42 <shachaf> elliott: Sure. But to make this work you need to use fix *before* you decide to have a bunch of versions of the same function.
07:31:44 <edwardk> upon :: (Data a, Data s, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s -- in lens head
07:32:00 <edwardk> elliott: Withal is a class in tables
07:32:32 <Jafet> @wn athwart
07:32:33 <lambdabot> *** "athwart" wn "WordNet (r) 3.0 (2006)"
07:32:33 <lambdabot> athwart
07:32:33 <lambdabot>     adv 1: at right angles to the center line of a ship
07:32:33 <lambdabot>     2: at an oblique angle; "the sun shone aslant into his face"
07:32:33 <lambdabot>        [syn: {obliquely}, {aslant}, {athwart}]
07:32:34 <edwardk> clearly the version of levels that only takes the first so many levels of breadth first search should be 'insofar'
07:32:35 <elliott> edwardk: heh, I vaguely recall that
07:32:49 <fmap> > "hello world" & upon reverse .~ "."
07:32:51 <lambdabot>   "hello world."
07:33:11 <fmap> hmm
07:33:12 <edwardk> fmap: upon has to 'find one element in the whole' and can't force any other elements of the same type that aren't along the path there
07:33:43 <edwardk> hence why head and tail and (!!) work they don't force any particular element of the list other than the one they match
07:33:54 <edwardk> and tail and tail.tail work because the other list nodes that you find are on the way to the target
07:34:07 <edwardk> but reverse forces the whole list so it gives you the whole list back
07:34:13 <hiptobecubic> maybe i should just start writing in shakespeare (https://en.wikipedia.org/wiki/Shakespeare_(programming_language))
07:34:33 <edwardk> worse it keeps chasing until it gets to the last element
07:38:02 <absence> > let a = scanl (+) 0 [1, 1, 2, 1] in zip a (tail a)
07:38:04 <lambdabot>   [(0,1),(1,2),(2,4),(4,5)]
07:38:20 <absence> are there any library functions i can use to make that code less convoluted?
07:39:00 <Jafet> > ap zip tail . scanl (+) 0 $ [1,1,2,1]
07:39:02 <lambdabot>   [(0,1),(1,2),(2,4),(4,5)]
07:39:19 <Jafet> @quote zip.ap.tail
07:39:19 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
07:39:27 <startling> > zip <$> tail $ scanl (+) 0 [1, 1, 2, 1]
07:39:28 <lambdabot>   No instance for (GHC.Show.Show ([b0] -> [(b1, b0)]))
07:39:29 <lambdabot>    arising from a use ...
07:39:36 <Jafet> :t stereo
07:39:37 <startling> aw.
07:39:37 <lambdabot> Not in scope: `stereo'
07:41:22 <absence> thanks :)
07:42:46 * hackagebot linear 0.4.2.2 - Linear Algebra  http://hackage.haskell.org/package/linear-0.4.2.2 (EdwardKmett)
07:45:16 <sipa> @pl \y -> x `mod` y /= 0
07:45:16 <lambdabot> (0 /=) . (x `mod`)
07:46:48 <sipa> @pl \y -> y*y <= x
07:46:48 <lambdabot> (<= x) . join (*)
07:49:34 <dmwit> ?pl let x = 3 in x
07:49:35 <lambdabot> 3
07:49:38 <dmwit> huh
07:49:57 <shachaf> @@pl let in 3
07:49:58 <Taneb> ?pl let x = 3; y = (+ 1) in y x
07:49:58 <lambdabot> 4
07:50:05 <shachaf> @pl let in 3
07:50:05 <lambdabot> 3
07:50:37 <Taneb> @pl let  in let  in 6
07:50:37 <lambdabot> 6
07:50:48 <dmwit> ?pl let odd n = if0 n False (not (even (n-1))); even n = if0 n True (not (odd (n-1))) in odd
07:50:48 <lambdabot> snd (fix (uncurry (flip ((,) . ap (flip if0 True) . (not .) . (. subtract 1)) . ap (flip if0 False) . (not .) . (. subtract 1))))
07:50:52 <dmwit> oh god
07:50:58 <elliott> looks pretty good to me
07:51:55 <dmwit> ?pl let a n = b n; b n = c n; c n = a n in c
07:51:56 <lambdabot> fst (fix (uncurry ((`ap` snd) . (. fst) . flip ((.) . (,)) . flip (,))))
07:52:23 <Jafet> What is this I do not even
07:59:43 <applicative> it is good once in a while, this @pl
07:59:47 <applicative> @pl goo f x = liftM2 (,) (return x) (f x)
07:59:47 <lambdabot> goo = liftM2 fmap (,)
07:59:59 <applicative> by contrast:
08:00:00 <applicative> @pl goo f x = f x >>= \y -> return (x,y)
08:00:01 <lambdabot> goo = (`ap` ((return .) . (,))) . ((>>=) .)
08:02:25 <srhb> Do plugins and hint require the presence of GHC? I'm not sure if they are even meant to be something that clients use without a Haskell installation.
08:03:17 <roadfish> mmm, now have offline hoogle running in ghci
08:03:47 <Jafet> @pl (\f g x -> f x $ g x) (\f x y -> f y) (\x f -> x (f x) (f x))
08:03:47 <lambdabot> id
08:04:28 <tobias__> can anyone help me in proving some allegations ?
08:04:49 <tobias__> re.g. map (f . g) == map f . map g
08:05:00 <roadfish> @pl goo f x = f x >>= \y -> return (x,y)
08:05:00 <lambdabot> goo = (`ap` ((return .) . (,))) . ((>>=) .)
08:05:27 <tobias__> i dont know where ta begin, never did anything like this before
08:06:01 <srhb> tobias__: For instance, replace map with its definition
08:07:10 <tobias__> i dont have the definitions
08:07:18 <tobias__> where can i find them?
08:07:29 <sipa> @src map
08:07:29 <lambdabot> map _ []     = []
08:07:29 <lambdabot> map f (x:xs) = f x : map f xs
08:07:34 <srhb> tobias__: You can find them via hoogle. :)
08:08:53 <applicative> so  map f (map g) [] = []   = map (f . g) [], for the base case
08:09:53 <tobias__> u mean the inductionsstart?
08:10:07 <applicative> suppose map f (map g ) xs = map (f.g) xs; does  map f (map g ) (x:xs) = map (f.g) (x:xs) ?
08:10:18 <applicative> tobias__: yes
08:11:26 <applicative> woops bad bracketting above
08:11:31 <Jafet> lemma "map f o map g = map (f o g)" by auto
08:11:38 <applicative>  suppose map f (map g ) xs = map (f.g) xs; does  map f (map g  (x:xs) ) = map (f.g) (x:xs)
08:11:45 <applicative> grrrr
08:11:52 <applicative>  suppose map f (map g  xs) = map (f.g) xs; does  map f (map g  (x:xs) ) = map (f.g) (x:xs)
08:12:56 <roadfish> preflex: hello
08:13:32 <roadfish> http://www.haskell.org/haskellwiki/IRC_channel#preflex
08:13:39 <roadfish> does the preflex bot exist anymore?
08:13:39 <elliott> preflex isn't here
08:14:05 <roadfish> was it voted off #haskell?
08:14:14 <elliott> I don't think so.
08:14:19 <elliott> ask mauke I guess
08:14:23 <Jafet> It was removed by fiat.
08:16:03 <shachaf> mauke: preflex wasn't based on lambdabot, was it?
08:16:24 * shachaf wonders where that rumour started.
08:16:36 <shachaf> Oh, mauke isn't here.
08:16:36 <fragamus> ok… my basic plan is this: I have an internal ByteString in hand.    I will use toForeignPtr and then take that pointer and make a Data.Vector.Storable.Mutable.
08:16:52 <shachaf> fragamus: You probably shouldn't do that...
08:17:01 <shachaf> You're not supposed to mutate bytestrings.
08:17:16 <fragamus> well I don't want it to be mutable
08:17:17 <roadfish> quote roadfish
08:17:45 <fragamus> I am just looking for a way to turn my ByteString into a Vector
08:18:09 <fragamus> and I saw a handy    fromForeignPtr function
08:19:48 <srhb> fragamus: But it already is a vector.
08:20:01 <fragamus> oh really
08:20:06 <roadfish> is there a way to get a list of lambdabot commands
08:20:14 <roadfish> this list is incomplete http://www.haskell.org/haskellwiki/IRC_channel#lambdabot
08:20:44 <applicative> fragamus: V.unfoldr B.uncons
08:20:58 <applicative> fragamus: B.unfoldr V.uncons goes the other way
08:21:54 <leksah> Is haskell for Mathematical use only?
08:22:09 <srhb> leksah: Almost not at all, I believe.
08:22:11 <applicative> leksah: Haskell has no mathematical use
08:22:24 <tobias__> btw is this even right?-------------- map ( f . g) == map f . map g ------- ..... or is it wrong?
08:22:29 <Jafet> Haskell is so useless that even mathematicians don't use it
08:22:31 <shachaf> It's right.
08:22:37 <applicative> yes tobias__
08:22:49 <roadfish> leksah: No. I am using Haskell to just write text-processing scripts that you could also just to in Python/Ruby/etc
08:22:52 * hackagebot toysolver 0.0.3 - Assorted decision procedures  http://hackage.haskell.org/package/toysolver-0.0.3 (MasahiroSakai)
08:22:57 <applicative> thats a way of expressing the thing you were proving above
08:23:13 <tobias__> ok....thank u...then i ll continue proof it ;)
08:24:08 <roadfish> leksah: there is gtk2hs and wxhaskell for writing GUIs in Haskell
08:24:53 <applicative> fragamus: except I forgot there is no V.uncons at the moment. I made a lens or rather an Iso somewhere...
08:25:16 <roadfish> leksah: darcs is a revision control system in Haskell and hledger is an accounting packge
08:25:51 <roadfish> @help
08:25:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:25:52 <fragamus> applicative: ok so all I need is to iterate over the Word8s and accumulate a number as a function of them
08:26:01 <roadfish> @list
08:26:01 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:26:26 <fragamus> so Starting with my internal ByteString.....
08:27:56 <tobias__> @src .
08:27:56 <lambdabot> (f . g) x = f (g x)
08:27:56 <lambdabot> NB: In lambdabot,  (.) = fmap
08:28:44 <tobias__> NB: In lambdabot,  (.) = fmap.....what does this mean?
08:29:01 <applicative> fragamus,  bytestring has folds and stuff, I thought you proposed to Mutate the sequence
08:29:12 <fragamus> oh i just saw that
08:29:16 <fragamus> I'm happy now
08:29:22 <fragamus> I can use fold and all is good
08:29:26 <Clint> :t (.)
08:29:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:29:29 <Clint> tobias__: ^
08:29:31 <shachaf> tobias__: Ignore it. It's just there to be confusing.
08:29:43 <shachaf> tobias__: If you really want to know the answer, theres a post somewhere
08:30:06 <shachaf> @google comonad.com fmap rederives
08:30:08 <lambdabot> http://comonad.com/reader/index.php?s=rederives
08:30:08 <lambdabot> Title: The Comonad.Reader » Search Results » rederives
08:30:38 <applicative> there needs to be an @lensify command like @pl
08:30:51 <srhb> It's weird that that has anything to do with Reader.
08:30:57 <edwardk> applicative: congratulations. you are hereby nominated to write the plugin
08:31:09 <applicative> how do I @lensify lame_uncons vec = case vec !? 0 of Nothing -> Nothing; Just w8 -> Just (w8,Vector.tail vec)
08:31:53 <elliott> applicative: you probably want an Iso there
08:31:56 <elliott> but you can write a Lens as
08:32:31 <elliott> lame_uncons vec = case vec !? 0 of Nothing -> pure vec; Just w8 -> (\w8' -> Vector.cons w8 (Vector.tail vec)) <$> (w8, Vector.tail vec)
08:32:39 <elliott> oh, probably you can use // or something for that <$>
08:32:41 <edwardk> applicative: something like an _uncons :: Vector v a => Lens' (v a) (a, v a)
08:32:42 <edwardk> ?
08:32:48 <elliott> ...and also it's a traversal
08:32:53 <elliott> oh, it's a prism actually :)
08:32:59 <edwardk> er
08:33:01 <roadfish> if I cabal install lambdabot then do I get to query lambdabot during ghci? ... like how I can :hoogle in ghci
08:33:04 <elliott> Prism (a, v a) (b, v b) (v a) (v b)
08:33:09 <edwardk> er _uncons :: Vector v a => Lens' (v a) (Maybe (a, v a) )
08:33:12 <elliott> too bad that's the other way around to how you'd use the traversal version
08:33:22 <edwardk> i guess thats an iso
08:33:44 <edwardk> _uncons :: Vector v a => Iso' (v a) (Maybe (a, v a))
08:34:28 <applicative> hadn't thought of an uncons  Iso, I was making a bytestring <-> Vector Word8 Iso
08:34:54 <edwardk> iso (maybe empty (uncurry cons)) ...
08:35:11 <applicative> as part of my secret war to irrationally replace text and bytestring with vector Word8 and Char
08:35:14 <srhb> edwardk: You need to make bookmarks in that Youtube video so we can jump to, say, "the bit about Iso" :P
08:35:16 <applicative> hah
08:37:06 <applicative> srhb, you can add it to @where if you can remember how
08:37:15 <edwardk> srhb: can i do that?
08:37:55 <edwardk> i can add anotations, not sure about bookmarks
08:38:09 <srhb> edwardk: Hm, I think I saw them once. Maybe I'm dreaming.
08:38:18 <shachaf> edwardk: You could name some times in the description, which YouTube would turn into links.
08:38:28 <shachaf> "Isos at 1:04:28", etc.
08:38:52 <edwardk> if someone wanted to put together a list of those times i'd add it to the description
08:38:58 <leksah> I am thankful for those good answers, Indeed they make me change the way I used to think of Haskell.
08:39:03 <srhb> I'll do it next time I watch it.
08:39:11 <hpaste> applicative pasted “bytestring<->vector” at http://hpaste.org/80457
08:39:20 <leksah> It's unusual Language.
08:39:27 <shachaf> srhb: You're supposed to watch that video at least twice a day.
08:39:29 <applicative> here's one attempt at an iso ^^
08:39:35 <srhb> shachaf: Yep, so all done for today. ;)
08:39:42 <srhb> (Ha!)
08:39:58 <shachaf> @localtime srhb
08:39:59 <lambdabot> Local time for srhb is Tue Jan  8 17:39:42 2013
08:40:09 <shachaf> Hmm, you have to watch it once right before you go to sleep.
08:40:21 <srhb> Changing the rules like that is unfair. :P
08:40:24 <applicative> I can make an Iso for a concrete type of Vector Word8 and anything in the IsByteString class in Data.ByteString.Lens
08:40:37 <elliott> applicative: Vector Char seems like a bad string representation.
08:41:03 <applicative> elliott: it is frequently much faster. of course it takes more space.
08:41:44 <elliott> Faster for accessing a codepoint by index?
08:42:25 <applicative> elliott: hm, don't know about that. I have run various wacky experiments, e.g. making parsers
08:42:51 <elliott> Well, I just mean that seems like an uncommon operation.
08:42:53 <applicative> it is never appreciably slower, frequently much faster, but always Strict and so on
08:42:57 <elliott> But it's O(1) for Vector Char and O(not 1) for Text
08:43:15 * elliott thinks we need a proper fingertree-of-small-vectors representation for strings.
08:44:33 <shachaf> elliott: Accessing codepoints by index may be uncommon, but marking *some* point in the Text to be able to access it in constant time is not.
08:44:38 <alpounet> isn't that what the ropes packages is about?
08:44:43 <edwardk> shachaf: I always figured the lens video was for use as a sleep aid. When you cant sleep you can listen to the dulcet tones of my voice while I tell you a story. Its like one of those subliminal power talk tapes people fall asleep to. They can wake up after and go "man, I'm going to master profunctors today!"
08:44:47 <shachaf> You can't get any sort of offset/index thing that you can pass around to other people to use with the text.
08:44:55 <elliott> shachaf: Zippers!
08:45:08 <benmachine> would people in here agree with the notion that catching the SystemExit exception is bad practice?
08:45:15 <alpounet> @hackage rope
08:45:15 <lambdabot> http://hackage.haskell.org/package/rope
08:45:18 <edwardk> elliott: its in trifecta
08:45:19 <shachaf> elliott: What?
08:45:29 <benmachine> er, the ExitCode exception, I suppose
08:45:31 <edwardk> oh yeah that too
08:45:34 <edwardk> i forgot i wrote that
08:46:00 <elliott> I seem to remember I didn't like something about Trifecta's ropes, but I forget what
08:46:14 <byorgey> johnw: looking for me?
08:46:18 <epta> How can I define foldl1 for Data.HashMap.Strict? There is only foldl'
08:47:02 <elliott> Maybe the imperfect thing is that it's in an edwardk package he doesn't even remember he wrote :)
08:47:20 <edwardk> heh
08:47:28 <edwardk> i need to fix rope, it has its own internal comonad type
08:47:29 <ethercrow> yi has an internal rope with a comment "should be external library"
08:47:41 <shachaf> epta: You can derive foldl1 from foldl
08:47:54 <shachaf> epta: E.g. fold with a Maybe
08:47:58 <edwardk> this was from before category-extras exploding
08:48:32 <ethercrow> when I tried to replace it with some rope from hackage, one of them didn't compile, one wasn't unicode-friendly and one had too different API
08:49:16 <elliott> Also rope doesn't really seem to have as much Unicode-y stuff as text does.
08:49:45 <elliott> Hmm, that fromByteString doesn't even split it into chunks. I guess that doesn't matter?
08:51:41 <epta> shachaf: you mean, just get `maybeToList . take1 . fromList` as a initial foldl argument?
08:51:55 <shachaf> I mean something like
08:52:20 <shachaf> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Fold.hs#L1107
08:53:33 <elliott> edwardk: man, rope doesn't even export a single lens
08:53:43 <edwardk> heh
08:53:45 <epta> shachaf: ok
08:55:11 <merk_> is it considered a bad style to use >>= and lambda over do and <- ?
08:55:52 <sclv> not necessarily
08:56:05 <zomg> merk_: use the style which makes it more readable, more easy to tell what's going on
08:56:10 <sclv> i personally don't like >>=, and like =<< instead, since it reads in the same "order" as .
08:56:19 <sclv> foo =<< bar =<< baz is quite nice
08:56:27 <qwr> but writing long sequences of >>= tends to be less readable than do
08:56:32 <sclv> but in fact often with that pattern you can use <=< instead
08:56:51 <zomg> qwr: indeed, I occasionally write helper functions because of that
08:56:56 <sclv> if i need a fair amount of explicit lambdas, i'll often switch to "do"
08:58:10 <applicative> merk_: the really good style is >=>   <=< of course
08:58:21 <applicative> oh as sclv says.
08:58:51 <applicative> > reverse "foo =<< bar =<< baz"
08:58:53 <lambdabot>   "zab <<= rab <<= oof"
08:59:36 <merk_> I meant something like this:  x <- foo, vs foo >>= \x. I oddly prefer the latter, possibly because I just grooked how do notations expand to that form
09:00:06 <byorgey> merk_: sure, use whichever one you prefer
09:00:08 <applicative> merk_: then it's better than do notation...
09:00:59 <applicative> merk_: do notation is better when theres a pile of \x -> ... \y -> ...
09:02:18 <srhb> I don't think I've ever noticed >=> and <=< before
09:02:26 * applicative keeps repeating what sclv has said
09:02:55 * hackagebot warp 1.3.7 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.7 (MichaelSnoyman)
09:02:57 <applicative> @type readFile >=> putStrLn
09:02:58 <lambdabot> FilePath -> IO ()
09:03:25 <srhb> Oh, that's nice.
09:04:24 <srhb> What are they called? Those operators.
09:04:36 <srhb> Monad composition?
09:04:44 <byorgey> fish, and fishy-fish
09:04:45 <applicative> kleisli composition
09:04:45 <shachaf> Kleisli composition
09:04:50 <srhb> Aha. :P
09:04:58 <applicative> except byorgey calls them fish
09:04:58 <bgamari> mokus, ping
09:05:17 * applicative calls them warm-fuzzy-right and ...
09:06:17 <Lethalman> :t (>=>)
09:06:19 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
09:06:38 <benmachine> I always call <=< the fish operator
09:06:38 <Lethalman> cool
09:06:41 <applicative> srhb have you seen the account of the monad laws with >=> and return ?
09:06:46 <benmachine> but yes, it's also called kleisli composition
09:06:50 <srhb> applicative: I don't think I have.
09:07:35 <applicative> srhb: it's last bit here, for example, http://www.haskell.org/haskellwiki/Monad_Laws
09:08:46 <srhb> applicative: Ah, I see. It does look a lot more intuitive like that.
09:09:08 <applicative> srhb: yes much more
09:09:14 <shachaf> srhb: How about the ones with "join . fmap join == join . join"?
09:09:18 <shachaf> Those are pretty good.
09:09:46 <roadfish> now I have lambdabot in ghci:
09:09:47 <roadfish> :def lambdabot \x -> return $ ":!lambdabot -e \"" ++ x ++ "\""
09:09:56 <srhb> shachaf: Yes :)
09:10:05 <srhb> Or something to that extend. Is that quite right?
09:10:08 <roadfish> but I keep getting "Initialising plugins ................. done."
09:10:32 <shachaf> srhb: Isn't it?
09:10:38 <applicative> the join / fmap ones are good if you are actually drawing the diagrams
09:11:18 <shachaf> Yes, it matches this nice diagram: https://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Monad_multiplication_explicit.svg/500px-Monad_multiplication_explicit.svg.png
09:11:53 <srhb> In what universe is that a "nice diagram" O_o
09:11:54 <Lethalman> roadfish, works here
09:12:30 <Nereid> I think it's a nice diagram.
09:12:31 <shachaf> kamatsu: "Existential types are absolutely essential for any type-heavy Haskell code." -- do you really think so?
09:12:33 <srhb> It would probably help if I could read it. <_<
09:12:45 <tac> srhb: it's symmetric except the top morphism and the left one, which happen to be flip-flopped
09:12:48 <shachaf> srhb: Think of it like this, with made up notation.
09:12:54 <shachaf> srhb: You have m1 (m2 (m3 a))
09:13:04 <roadfish> Lethalman: lambdabot is working fine. but the plugin message on each :lambdabot command is a bit annoying. would be nice if had lambdabot as a local server
09:13:07 <mm_freak_> existential types are only really necessary when you want to statically prove run-time things
09:13:16 <applicative> I think that by 'type heavy' he  means 'using existential types'
09:13:16 <shachaf> srhb: You can either join to get m12 (m3 a) and then join again to get m123 a
09:13:23 <Nereid> it just says join[X] . fmap[T] join[X] = join[X] . join [T X]
09:13:26 <shachaf> srhb: Or you can fmap join to get m1 (m23 a) and then join to get m123 a
09:13:32 <shachaf> srhb: The law is that you get the same result either way.
09:13:35 <Nereid> where [] is type specialization
09:13:54 <srhb> shachaf: Oh, now I get it.
09:13:55 <Nereid> and can be ignored
09:13:58 <Lethalman> roadfish, a --quiet would be enough if it was there
09:14:10 <srhb> Nereid: Ok :)
09:14:31 <Nereid> read T(T(X)) as m (m a)
09:14:51 <shachaf> srhb: If you squint just a bit you can see how that's a lot like a monoid.
09:15:15 <Nereid> so it says we have both join . join, join . fmap join :: m (m (m a)) -> m a
09:15:19 <Nereid> that they are equal
09:16:05 <shachaf> srhb: In particular think about it in terms of composition. Instead of writing m1 (m2 (m3 a)), write (m1 . m2 . m3) a
09:16:11 <roadfish> Lethalman: I'm happy anyway. now I can do ":ho" and ":la" in ghci. Things are speeding up now.
09:16:17 <shachaf> Then you can reason about things you can do that (m1 . m2 . m3) thing.
09:16:18 <srhb> shachaf: But wait, what's identity then
09:16:22 <Lethalman> roadfish, ahah
09:16:39 <roadfish> Lethalman: I was missing the help in python interpreter
09:16:55 <Lethalman> roadfish, right
09:17:08 <shachaf> srhb: return? I'm not sure what you mean.
09:17:12 <srhb> Oh..
09:17:12 <roadfish> I think I'm going to go crazy with this ":def" command.
09:17:30 <roadfish> ... I mean with entries in ~/.ghci
09:17:48 <roadfish> I added "|head" to :hoogle though:
09:17:50 <roadfish> :def hoogle \x -> return $ ":!hoogle \"" ++ x ++ "\" | head"
09:18:07 <ssl> I have a few more chapters to go in LYaH - any recommendations on what to read next to continue my crash course in haskell?
09:18:26 <mm_freak_> ssl: write software
09:18:43 <roadfish> ssl: some good videos too http://www.youtube.com/watch?v=b9FagOVqxmI
09:18:47 <Lethalman> roadfish, yes better use hoogle directly of course, what do you use of lambdabot after all? @pl ? @src ?
09:18:56 <mm_freak_> ssl: as a gentle start you may want to experiment with writing web apps using one of the three major frameworks, happstack, snap and yesod
09:19:33 <roadfish> Lethalman: still just exploring the possibilies. I see people do "@" stuff here and I will try out in ghci.
09:20:05 <roadfish> Lethalman: I wonder if the #haskell lambdabot has large datafiles that aren't in my local ghci :lambdadot.
09:20:15 <srhb> shachaf: I'm a bit fuzzy on the difference between μT(x) and μx
09:20:15 <srhb>  
09:20:29 <Lethalman> roadfish, such as?
09:20:49 <mm_freak_> µx doesn't seem to make sense
09:21:02 <mm_freak_> µ is a natural transformation, so it acts on functors like T
09:21:03 <srhb> It's a join on.. what?
09:21:04 <roadfish> Lethalman: which of my comments is the "such as" about?
09:21:07 <ssl> mm_freak_: that is what I was thinking of doing - I have a few small Ruby/Sinatra web apps I might try to recreate using haskell
09:21:19 <Lethalman> roadfish, what ability the lambdabot here has that yours has not?
09:21:34 <mm_freak_> ssl: yeah, do that…  reading makes you ever more excited, but doesn't help you get stuff done =)
09:22:35 <osa1> ok so I don't know much about type families but it looks like it can help make some modules' interfaces(like Data.Vector and it's mutable/unboxed parts) simpler, am I wrong, or otherwise why authors don't use it more often ?
09:22:58 <ssl> mm_freak_: of those frameworks, which do you think would be easiest to dive in to or at least has the best documentation?
09:23:13 <roadfish> Lethalman: I don't know yet. still just exploring. but I see that local data for for lambdabot is at ~/.cabal/share/lambdabot-4.2.3.3/State ... and the files don't seem that large.
09:23:16 <srhb> Because they're all just pining for applicative translucent functors.
09:23:48 <mm_freak_> ssl: all of them and none of them, it really depends on you…  i'd say yesod is the most difficult (to understand, not to use), but gives you the most static guarantees
09:24:26 <mm_freak_> ssl: just have a look at all of them
09:24:26 <kamatsu> osa1: Repa uses data families to unify various representations
09:25:16 <srhb> I personally found Yesod extremely hard to start using, except for launching the test template. On the other hand, Happstack was straightforward.
09:25:22 <roadfish> Lethalman: interesting. some of the files in ~/.cabal/share/lambdabot-4.2.3.3/State are actually gzipped but don't have a gz suffix on them. so I'm going to unzip them. I'm thinking that I can add data to customize my local :lambdabot
09:25:46 <kamatsu> For sinatra style apps, might want to consider scotty
09:25:54 <kamatsu> it's very small, easy to fit in your head
09:26:33 <roadfish> ~/.cabal/share/lambdabot-4.2.3.3/State/where lists 650 urls that have been accumulated on #haskell
09:27:03 <roadfish> ok, so this local lambdabot data is looking reasonably large now
09:27:55 <specing> Hello
09:27:58 <ssl> kamatsu: will check it out - sinatra was incredibly helpful when I first got into web development with ruby, so something similar in haskell will probably be a good place to start
09:28:20 <specing> Is it normal for Haskell (GHC) to use 3.5GB memory compiling a single file?
09:28:29 <kamatsu> specing, not usually
09:28:36 <kamatsu> specing, depends on what you're compiling though
09:29:16 * Lethalman feels ghc is using a lot of memory as well cause I feel the swap, but never analyzed it though
09:29:28 <roadfish> in ~/.cabal/share/lambdabot-4.2.3.3/State/karma there is someone called "<" with -3875 karma
09:29:29 <kamatsu> I have worked on some repa code that took a long time to compile
09:29:32 <ToranLipse> Can someone please explain this question?
09:29:32 <ToranLipse> http://pastebin.com/5PXs4FzR
09:29:34 <kamatsu> you have to inline a lot of things
09:29:35 * elliott isn't surprised by GHC using any finite amount of memory.
09:29:38 <mauke> The paste 5PXs4FzR has been copied to http://hpaste.org/80461
09:29:48 <ToranLipse> Isnt it just Elem = Exp?
09:29:54 <kamatsu> this tends to blow out the code size using a lot of memory
09:30:14 <kamatsu> ToranLipse: do you understand polish notation?
09:30:23 <ToranLipse> I do yeh.
09:30:34 <kamatsu> OK, so what about the question don't you understand?
09:30:41 <ToranLipse> Elem is just an Exp right?
09:30:49 <kamatsu> No, Exp isn't polish notation
09:30:57 <ToranLipse> Oh.
09:31:46 <kamatsu> You should be able to go [Elem] -> Expr and Expr -> [Elem] though, so there's a bijection between them
09:31:49 <srhb> ToranLipse: Either Numbers or Operators. App Op Expr Expr is not an operator, nor a number
09:33:27 <ToranLipse> Hang on im just trying to get my head round it.
09:37:19 <ToranLipse> Nope. Completely puzzled.
09:37:43 <lispy> kamatsu: save lispy!
09:37:44 <kamatsu> so, polish notation lets you represent expressions like (3 − 4) + 2 as 3 4 − 2 +
09:37:53 <mysticc> @hoogle parseModule
09:37:53 <lambdabot> Language.Haskell.Parser parseModule :: String -> ParseResult HsModule
09:37:53 <lambdabot> Language.Haskell.Parser parseModuleWithMode :: ParseMode -> String -> ParseResult HsModule
09:38:00 <kamatsu> lispy: ?
09:38:15 <kamatsu> so, how would you represent polish notation expressions in Haskell?
09:38:19 <ToranLipse> Other way around in my example: 6*7 becomes * 6 7
09:38:34 <lispy> 17:47 < kamatsu> save macros and lispyness
09:38:37 <shachaf> kamatsu: That's reverse polish notation, not polish notation. :-)
09:38:47 <kamatsu> shachaf: arg, derp
09:38:55 <kamatsu> lispy: oh right, I was referring to Clojure
09:38:58 <shachaf> kamatsu: Anyway, as a tree?
09:39:03 <ToranLipse> Its like the Exp: App Op Expr Expr
09:39:25 <kamatsu> but that's not really polish notation, that's an abstract syntax tree
09:39:54 <kamatsu> polish notation is a sequence of tokens, something like App Op Expr Expr is a data structure that isn't a linear sequence.
09:41:31 <ToranLipse> So I am representing it as a tree type structure and I want it as a linear structure?
09:41:37 <kamatsu> yes
09:42:19 <ToranLipse> So I just need to do an inorder traversal?
09:42:33 <kamatsu> the question isn't asking you to write an algorithm, it's asking you to define a type
09:42:43 <kamatsu> but you would do a traversal to convert between the representation
09:44:07 <kamatsu> so how would you represent one of your Expr's as a list of a nonrecursive type?
09:44:21 <kamatsu> e.g [Elem], where Elem does not contain another Elem?
09:45:08 <ToranLipse> Er.
09:45:14 <ToranLipse> Two secs while I try to figure this out.
09:45:38 <ToranLipse> I have to use recursion to get this non-recursive type though?
09:45:54 <kamatsu> by "non-recursive" type I mean
09:46:11 <kamatsu> "data Elem = stuff" where stuff does not contain the word "Elem"
09:46:32 <kamatsu> note that your "Expr" type is recursive
09:47:15 <ToranLipse> data Elem?
09:47:22 <ToranLipse> You mean type?
09:47:29 <kamatsu> you could use data or type
09:47:32 <shachaf> kamatsu: What's the difference?
09:47:34 <ToranLipse> Oh ok.
09:47:36 <kamatsu> type would be a little trickier.
09:47:43 <ToranLipse> I am trying to do type.
09:47:46 <shachaf> kamatsu: + a * b c is just a way of writing a tree.
09:47:47 <kamatsu> because you'd have to know about some built-ins in Haskell
09:48:06 <ToranLipse> Oh wait. It doesnt say type.
09:48:07 <ToranLipse> Sorry.
09:48:13 <kamatsu> shachaf: right, but this is a distinction between concrete and abstract syntax.
09:48:35 <kamatsu> shachaf: it just so happens that with PN, the correspondence between concrete and abstract is 1:1
09:48:44 <shachaf> kamatsu: Well, you're free to represent it as [Name]
09:48:50 <shachaf> Which you then need to parse into the AST
09:49:04 <kamatsu> shachaf: right, that's essentially what the question is asking ToranLipse to do
09:49:12 <slack1256> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
09:49:57 <slack1256> don't be intimitated by the name, it's just a clever trick kamatsu
09:50:11 <kamatsu> slack1256: hm?
09:50:27 <kamatsu> free monads?
09:50:31 <kamatsu> what about them?
09:50:53 <shachaf> kamatsu: Oh, I was missing some context.
09:51:15 <slack1256> kamatsu: you where asking "so how would you represent one of your Expr's as a list of a nonrecursive type?"
09:51:35 <kamatsu> slack1256: I am helping someone with a homework question, I think free monads would be too far out of left field
09:51:37 <kamatsu> ;)
09:51:48 <srhb> oh oh OH OH I have a quote on that.
09:51:48 <slack1256> kamatsu: oh, my bad
09:51:54 * srhb forgot it
09:52:10 * slack1256 needs to get the context before replying
09:52:11 <ToranLipse> what do you mean concrete or abstract?
09:52:28 <kamatsu> ToranLipse: don't worry about that, that's just some PLs jargon that isn't relevant to the question
09:52:40 <ToranLipse> Oh ok.
09:52:46 <kamatsu> basically abstract syntax is an unambiguous way of representing a language's syntax for use in a compiler
09:53:17 <kamatsu> concrete syntax is a sequence of symbols, the code we actually write
09:53:37 <kamatsu> your Expr is an abstract syntax, what you're being asked to define is closer to a concrete syntax
09:54:07 <specing> Ok, compile finished at 3.6GB
09:54:10 <kamatsu> but it's not extremely pertinent to the question
09:54:17 <kamatsu> specing: what are you doing with GHC?
09:54:32 <zebr> hey. just to make sure, am i right in thinking that any arbitrary lambda term may be transformed into a supercombinator?
09:54:41 <ToranLipse> Elem = Op | Int?
09:55:07 <kamatsu> ToranLipse: you have the right idea
09:55:39 <kamatsu> ToranLipse: but you either need to make that a data declaration, or a type synonym. As is, data Elem = Op | Int won't do what you want
09:56:22 <kamatsu> ToranLipse: what other languages do you know? It may help to explain by analogy to them
09:56:30 <ToranLipse> Java
09:56:40 <kamatsu> oh, damn, no C?
09:56:46 <ToranLipse> Sorry. Afraid not.
09:56:54 <kamatsu> Java is one of the very few languages without type synonyms
09:57:01 <kamatsu> and without sum types
09:57:12 <ToranLipse> I know. Hence why im finding type synonyms a bit confusing.
09:57:28 <kamatsu> OK, so type synonyms are just introducing a name for a type that already exists
09:57:39 <kamatsu> if I say type String = [Char]
09:57:50 <HugoDaniel> is there any special magic function that makes (a -> b -> d) -> (a -> b -> c -> d)
09:57:54 <HugoDaniel> like const but for the last arg
09:58:01 <kamatsu> that's saying that, to Haskell, String is exactly the same type as [Char]
09:58:06 <ToranLipse> I understand the basics.
09:58:08 <ToranLipse> I think.
09:58:11 <HugoDaniel> last const :P
09:58:25 <kamatsu> HugoDaniel: how would you type that?
09:58:27 <Taneb> :t ?f .: const
09:58:28 <lambdabot> (?f::a -> b) => a -> b1 -> b
09:58:37 <Taneb> :t ?f .:: const
09:58:39 <lambdabot>     Not in scope: `.::'
09:58:39 <lambdabot>     Perhaps you meant `.:' (line 111)
09:58:44 <hiptobecubic> @djinn f :: (a -> b -> c) -> (a -> b -> c -> d)
09:58:44 <lambdabot> Cannot parse command
09:58:46 <kamatsu> ToranLipse: data declarations are different
09:58:49 <hiptobecubic> @djinn (a -> b -> c) -> (a -> b -> c -> d)
09:58:49 <lambdabot> -- f cannot be realized.
09:58:53 <kamatsu> they create a whole new type from scratch
09:58:53 <hiptobecubic> apparently not
09:58:56 <Taneb> :t fmap fmap fmap fmap fmap ?f const
09:58:58 <lambdabot> (?f::(b1 -> a) -> b, Functor f) => f a -> f b
09:59:00 <HugoDaniel> oh ok
09:59:06 <hiptobecubic> wait
09:59:09 <hiptobecubic> typo
09:59:12 <kamatsu> so if I go data Bool = True | False
09:59:13 <HugoDaniel> (\a b c -> f a b)
09:59:16 <HugoDaniel> something like that
09:59:17 <hiptobecubic> @djinn (a -> b -> d) -> (a -> b -> c -> d)
09:59:17 <lambdabot> f a b c _ = a b c
09:59:23 <kamatsu> I am creating a data type, called Bool, with two constructors, True and False.
09:59:25 <hiptobecubic> lol, well i guess that was stupid
09:59:40 <kamatsu> Constructors can also take arguments, e.g data Maybe a = Just a | None
09:59:49 <hiptobecubic> i was hoping for some monstrous combination of (.) and const for some reason
09:59:55 <kamatsu> this means Maybe Bool has three possible values, Just True, Just False, and Nothing
10:00:00 <ToranLipse> Ok.
10:00:18 <kamatsu> lastly, data declarations can be recursive
10:00:27 <kamatsu> like data List a = Cons a (List a) | EmptyList
10:00:56 <kamatsu> OK, so you need to define a new type, called "Elem", which is either an Op or an Int
10:01:07 <HugoDaniel> ill just write (\a b c -> f a b) directly then :)
10:01:18 <kamatsu> so we can go data Elem = OpElem Op | IntElem Int
10:01:33 <dgpratt> @pl f a b c _ = a b c
10:01:33 <lambdabot> f = ((const .) .)
10:01:35 <kamatsu> and this creates two constructors, one for the Op case, one for the Int case, which take one of those types as an argument
10:01:37 <kamatsu> OR
10:01:42 <kamatsu> we can go type Elem = Either Op Int
10:01:59 <kamatsu> Either is a built-in type to haskell that is defined as data Either a b = Left a | Right b
10:02:12 <ToranLipse> Hmm ok.
10:02:14 <kamatsu> so for the cases where you have just two alternatives, sometimes it's easier to use Either.
10:02:31 <kamatsu> hopefully that helps!
10:02:54 <kamatsu> zebr: depends on what you mean by "transform"
10:03:08 <kamatsu> zebr: and what your input is
10:03:14 <ToranLipse> Thanks. Can I ask why "data Elem Op | Int" doesnt work? havent they already been constructed?
10:03:20 <ToranLipse> =
10:03:31 <kamatsu> data Elem = Op | Int will define a data type that has two values
10:03:33 <kamatsu> "Op" and "Int"
10:03:45 <kamatsu> you need to give a name for the constructor of each alternative
10:04:19 <kamatsu> in general, it's data TypeName = ConName Type Type Type… | ConName Type Type Type..
10:04:20 <ToranLipse> Ah ok. Thank you very much.
10:21:06 <Taneb> > ("Hello, ", succ) <*> ("world!", 8)
10:21:08 <lambdabot>   ("Hello, world!",9)
10:21:26 <srhb> Oh more weird instances.
10:21:30 <hiptobecubic> what the hell is that
10:21:39 <Taneb> Writer applicative
10:21:41 <srhb> Another lamdabot special/abomination
10:21:41 <srhb> :P
10:21:48 <Taneb> No, it's in Control.Applicative
10:21:48 <shachaf> srhb: Nope.
10:21:54 <srhb> What!
10:21:59 <shachaf> It's just Writer.
10:22:03 <shachaf> You know Writer, right?
10:22:04 <srhb> O_o
10:22:05 <srhb> Yes
10:22:09 <hiptobecubic> i thought the monoid was snd
10:22:10 <shachaf> newtype Writer w a = Writer (w,a)
10:22:12 <srhb> Not that I've used it, but...
10:22:12 <hiptobecubic> guess not
10:22:22 <Taneb> Should be in Control.Monad.Instances, but it isn't
10:22:31 <shachaf> srhb: If you look at that you might notice that thw newtype is a little redundant.
10:22:39 <shachaf> You can just make the same instance for (,)
10:22:53 <hiptobecubic> tuple can mean a lot of things though
10:23:00 <srhb> shachaf: Right
10:23:05 <srhb> Funky!
10:23:22 <hiptobecubic> you need your newtype wrapper to pick the instance you want
10:23:38 <srhb> There's not an instance for (,) is there
10:23:38 <Taneb> triple = (+) <*> join (+)
10:23:48 <shachaf> srhb: There is.
10:23:53 <srhb> Oh.
10:24:29 <hiptobecubic> Why did lambdabot pick the Writer instance?
10:24:39 <Taneb> Because that's the only instance for tuples
10:24:54 <hiptobecubic> shachaf, just said otherwise, didn't he?
10:25:17 <Taneb> > extract (const 4)
10:25:19 <otters> :t (+) <*> join (+)
10:25:19 <lambdabot>   Not in scope: `extract'
10:25:20 <lambdabot> Num b => b -> b
10:25:31 <otters> :t ((+) <*>)
10:25:32 <lambdabot> Num b => (b -> b) -> b -> b
10:25:35 <Taneb> > (+) <*> join (+) $ 3
10:25:36 <lambdabot>   9
10:25:41 <Taneb> > (+) <*> join (+) $ 7
10:25:42 <lambdabot>   21
10:25:49 <hiptobecubic> :t join (+)
10:25:50 <lambdabot> Num a => a -> a
10:26:08 <shachaf> There's no Monad intance for (,)
10:26:11 <shachaf> There is Applicative
10:26:32 <Taneb> join :: Monad m => m (m a) -> m a; or (a -> a -> b) -> a -> b
10:26:50 <hiptobecubic> yes
10:26:59 <hiptobecubic> join (+) 4
10:27:03 <hiptobecubic> > join (+) 4
10:27:04 <lambdabot>   8
10:27:07 <elliott> shachaf: I thought one got added?
10:27:16 <otters> :t join (+) <*> join (+)
10:27:17 <Lethalman> pictures are gone only for me? http://newartisans.com/2012/08/monads-in-pictures/
10:27:18 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> b0
10:27:18 <lambdabot>     Expected type: (a0 -> b0) -> (a0 -> b0) -> a0
10:27:18 <lambdabot>       Actual type: (a0 -> b0) -> (a0 -> b0) -> a0 -> b0
10:27:24 <shachaf> elliott: Monad? I don't think so.
10:27:34 <srhb> Lethalman: Nope, gone.
10:27:35 <hiptobecubic> Lethalman, gone.
10:27:39 <Lethalman> :(
10:27:42 <elliott> shachaf: Someone should add that.
10:27:45 <hiptobecubic> kind of ruins the article
10:27:48 <shachaf> elliott: Agreed.
10:27:54 <Lethalman> I was going to share that to a friend
10:27:55 <shachaf> elliott: I think there was some silly reason for it?
10:28:06 <elliott> shachaf: A reason different to "nobody got around to it"?
10:28:11 <shachaf> elliott: Yes.
10:28:21 <shachaf> Ask edwardk.
10:28:26 <shachaf> Lethalman: It's gone because it was misleading, I think.
10:28:56 <srhb> johnw: Why are the pictures gone? D:
10:28:57 <Lethalman> shachaf, huh it gave me a good point in understanding monads and applicatives
10:29:15 <shachaf> I disagree.
10:29:31 <shachaf> It would make you *think* you understood while actually confusing you.
10:29:36 <shachaf> A lot of the monad introductions do that.
10:29:50 <Taneb> Taneb's Monad Tutorial: don't worry about it.
10:30:00 <Taneb> You don't need to know what a monad is to use them
10:30:12 <Taneb> You don't even need to know what a monad is to write instances
10:30:21 <shachaf> Lethalman: Oh, I thought he took the entire page down.
10:30:26 <shachaf> I guess the text is still there.
10:30:34 <srhb> It seems like an error, definitely.
10:30:39 <hiptobecubic> What helped me was reading a lot of them and realizing that the only thing they had in common was "there's some kind of fancy context around the value".
10:30:45 <Lethalman> shachaf, but what matters in that post is the pictures :P because it's "monads by pictures" :P
10:31:01 <elliott> That blog post's explanation looks pretty dangerously wrong to me.
10:31:01 <shachaf> But the pictures are misleading.
10:33:22 <kennyd> elliott can you elaborate?
10:33:52 <elliott> kennyd: on what?
10:35:06 <c_wraith> hiptobecubic: I don't even like to think "around the value". I just like to think "composition of values with types that fit a particular pattern"
10:35:28 <Lethalman> @djinn a -> a
10:35:28 <lambdabot> f a = a
10:35:32 <c_wraith> Well, composition of functions returning values with those types
10:35:33 <kennyd> what part or parts are dangerously wrong?
10:35:36 <Lethalman> why on my lambdabot it doesn't work :-(
10:35:53 <c_wraith> Lethalman: do you have the djinn binary installed?
10:35:53 <hiptobecubic> c_wraith, i don't mean physically around
10:35:58 <Lethalman> c_wraith, I have
10:36:04 <hiptobecubic> c_wraith, i guess "associated with"
10:36:05 <kamatsu> "context around a value" is a little misleading for some more unusual monad instances, where the context is more important than the value
10:36:15 <kamatsu> for example, AST's parameterised by the type of variable names.
10:36:19 <Lethalman> c_wraith, No output from Djinn; installed?
10:36:22 <elliott> kennyd: its explanation of monads
10:36:24 <Lethalman> this is what lambdabot says
10:36:35 <c_wraith> hiptobecubic: well, my problem with that is that I don't necessarily believe there is a "the value"
10:36:38 <elliott> "Dangerous" because people who read monad tutorials don't know what monads are, so they will believe more or less anything a tutorial says about them
10:36:40 <shachaf> Lethalman: Is djinn installed?
10:36:44 <Lethalman> shachaf, yes
10:36:49 <shachaf> Is it in your PATH?
10:36:54 <elliott> So a wrong explanation will convince people, and they won't realise they don't understand.
10:36:58 <Lethalman> shachaf, c_wraith, strace says execve(djinn) = 0
10:36:58 <shachaf> Lethalman: I recommend "the usual debugging procedure"
10:37:11 <shachaf> Yay, you straced it.
10:37:23 <shachaf> Next step, figure out what lambdabot is doing post-execve.
10:37:30 <Lethalman> :S
10:37:33 <hiptobecubic> c_wraith, sure there is.  m a, there is some value with type a (unless it's just a shim to fit some signature somewhere)
10:37:40 <elliott> hiptobecubic: [a]
10:37:45 <elliott> does not necessarily contain a value with type a
10:37:56 <elliott> and even if it's non-empty, there's no "a" value because there can be many values
10:38:00 <elliott> yet [] is a monad
10:38:09 <elliott> and what abour (r -> a)? (r ->) is a monad for every r, after all...
10:38:10 <Lethalman> shachaf, lambdabot writes "f :: a -> a" and djinn gives no output
10:38:18 <Lethalman> that is, Djinn>
10:38:29 <hiptobecubic> Let me clarify. "Value" is as nebulous a term as "context" here. I don't mean "Haskell values that can be written as literals."
10:38:38 <shachaf> Nor does (a -> a), (State s a), (Maybe a), (IO a), (Cont r a), (Either e a), (STM a), or almost any other monad instance.
10:38:48 <Lethalman> shachaf, maybe djinn changed in the while? seems like f ? a -> a does some result
10:38:49 <kamatsu> @djinn f :: a -> a
10:38:49 <lambdabot> Cannot parse command
10:38:56 <Lethalman> @djinn f ? a -> a
10:38:56 <lambdabot> Cannot parse command
10:38:57 <elliott> [] :: [a] doesn't contain a value of type "a", unless your definition is so nebulous as to mean nothing.
10:39:05 <hiptobecubic> @djinn a -> a
10:39:05 <lambdabot> f a = a
10:39:11 <Lethalman> kamatsu, lambdabot prepends f ::
10:39:18 <shachaf> Lethalman: You'll probably have to read the lambdabot source to figure out what it's doing.
10:39:29 <shachaf> If it's wrong you'll have to fix it yourself.
10:39:30 <Lethalman> shachaf, I think the problem is that djinn changed how queries are done
10:39:33 <shachaf> Such is the Way of Lambdabot.
10:39:43 <Lethalman> shachaf, ahha yes, I'm going to write a wrapper around djinn :P
10:39:47 <shachaf> Lethalman: Unlikely.
10:39:56 <shachaf> Well, maybe.
10:39:58 <hiptobecubic> elliott, the value is all the different elements of [], which, vacuously, are of type a, yes.
10:40:02 <Lethalman> shachaf, how do I recompile lambdabot in cabal otherwise?
10:40:04 <shachaf> Djinn hasn't been updated in quite a while, though.
10:40:12 <shachaf> You just do?
10:40:18 <Lethalman> ?
10:40:25 <shachaf> Otherwhat?
10:40:32 <shachaf> You recompile it the same way you compile it.
10:40:39 <Lethalman> shachaf, cabal install djinn, that's what I did
10:41:12 <hiptobecubic> Just like   Nothing :: Maybe a  has a value, which is also, vacuously, of type a
10:41:26 <elliott> Except that's not true...
10:41:33 <elliott> At least calling this "the value" is incredibly misleading.
10:41:48 <c_wraith> Honestly, thinking of it as "composition of functions returning types of a particular form" really kind of drives home the point that Kleisli arrows are a better description of the interface.
10:41:54 <shachaf> hiptobecubic: It seems to me that you're stating something that more or less amounts to be a tautology except it's incredibly misleading.
10:41:55 <kamatsu> yep
10:43:14 <hiptobecubic> I don't see what's so circular about this. You have some monad `m a`. The `a` is a type. The value, whatever it is and however it is presented, which depends entirely on the monad, has that type.
10:43:46 <shachaf> hiptobecubic: What you mean is essentially that "m" is covariant, right?
10:43:51 <kamatsu> i had a little "aha" when I realised that the (endo)Functor instance is the composition of two functors: from Hask to Kleisli category: (a -> b) -> (a -> f b) and then bind from the Kleisli category back to Hask (in the image of f) (a -> f b) -> (f a -> f b)
10:44:20 <elliott> hiptobecubic: But it's not singular.
10:44:26 <elliott> There are multiple the values.
10:44:32 <elliott> Or none.
10:44:36 <hiptobecubic> there can be. yes.
10:44:50 <srhb> I think monad 'm a' is confusing enough in itself.
10:44:52 <shachaf> How many "a"s does foo :: a -> a contain?
10:44:55 <srhb> What does the a even mean?
10:45:05 <srhb> And how is it relevant to the monad.
10:45:19 <Lethalman> weird
10:45:24 <Lethalman> the code is correct, it uses f ?
10:45:26 <hiptobecubic> shachaf, "contain" is the wrong word, unless we're treating monads like boxes for some reason?
10:45:33 <Lethalman> but strace says f ::
10:45:57 <hiptobecubic> But to answer what i think you mean, I'll say 1. Of type a.
10:46:02 <fmap> @quote containers
10:46:02 <lambdabot> heatsink says: If monads are containers, the Cont monad is a klein bottle.
10:46:10 <fmap> not that :[
10:46:18 <fmap> @quote kmc containers
10:46:18 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
10:46:29 <kamatsu> i like that one
10:46:33 <hiptobecubic> that one is good
10:47:03 <hiptobecubic> There was another good one
10:47:06 <kamatsu> i don't understand what's the big hangup about it though
10:47:06 <srhb> It's a problem of temptation, the temptation of saying unwrap.
10:47:17 <srhb> It's just such a good word that we want monads to be gift wrapping paper.
10:47:22 <kamatsu> when I teach monads in my classes, I just treat them matter-of-factly.
10:47:33 <Taneb> Is "ArrowMonad (Cokleisli ((,) a) b" equivalent to a -> b
10:47:36 <hiptobecubic> Something like "monads are like chocolate steam trains, traveling backwards through outer space"
10:47:39 <srhb> kamatsu: I'm sure there's some interesting herd sociology going on :P
10:47:49 <elliott> Um, (a -> a) has as many as as there are as.
10:47:51 <srhb> hiptobecubic: That's the Tardis monad, isn't it
10:47:51 <kamatsu> I think people find them difficult because they expect them to be more complicated than necessary.
10:47:58 <srhb> kamatsu: Yep.
10:48:01 <hiptobecubic> kamatsu, yes but it's hard to accept that because.... yes that.
10:48:08 <elliott> Or more generally, (r -> a) has as many "the value"s as there are "r"s.
10:48:35 <hiptobecubic> you look around and everyone says "MONAD! Look at all the problems they solve!" And you look at writer and you think "This is a tuple." And then you think "I'm clearly missing something."
10:48:46 <srhb> elliott: Oh goodie, so we just throw in a "forall" in the horrible analogy. That'll fix it. :P
10:48:50 <hiptobecubic> elliott, yes.
10:48:55 <kamatsu> yeah
10:48:57 <elliott> srhb: I agree the analogy is horrible
10:48:59 <hiptobecubic> and that is the value
10:49:05 <elliott> Cont is a good example here too.
10:49:09 <shachaf> srhb: foralls are great for simplifying things.
10:49:14 <srhb> shachaf: Surely :P
10:49:17 <kamatsu> I just teach them the "you could have invented monads" way
10:49:26 <kamatsu> I write it without monad sugar, doing annoying plumbing
10:49:29 <srhb> forall monad analogies m....
10:49:30 <elliott> hiptobecubic: You just said "that" about a potentially infinite number of values.
10:49:35 <kamatsu> and then i rewrite with the monad to make it cleaner
10:49:38 <shachaf> srhb: forall is pretty the best thing.
10:49:40 <kamatsu> people are like "ah, that's nice"
10:49:42 <Lethalman> that lambdabot code is a little too much for me :-(
10:49:48 <hiptobecubic> elliott, yes. And an infinite number of values is a 'thing'.
10:49:48 <kamatsu> not "oh my god, monads are a thing I have to learn"
10:49:56 <hiptobecubic> elliott, which is how we are able to discuss it.
10:49:58 <shachaf> Lethalman: It's too much for everyone.
10:50:14 <elliott> hiptobecubic: I don't consider myself capable of discussing it, because I honestly have no idea what you are referring to.
10:50:27 <hiptobecubic> elliott, well you're doing a great job of faking it then.
10:50:30 <Lethalman> shachaf, I see that it invokes djinn correctly, but then I don't know how it parses the output with the regex
10:50:32 <elliott> Are you saying that every monad is isomorphic to (ctx, [a]), or something?
10:50:37 <elliott> Where the [a] is "the value".
10:50:58 <hiptobecubic> I don't know. I'd have to think about what that really means
10:51:15 <elliott> My whole point is that I don't know what you really mean :)
10:51:23 <kamatsu> similarly, when I was in high school i didn't do well at calculus, mostly because my math teachers had built up calculus in the preceding years as some sort of difficult bogeyman.
10:51:41 <kamatsu> when i was in university my teachers just used calculus as though it was simple, and suddenly it was simple for me.
10:51:48 <elliott> hiptobecubic: I think all the statements you can make about "the value of 'm a'" with your definition of "the value" might be indistinguishable from statements about "m a".
10:51:49 <hiptobecubic> i'm not sure about that isomorphism because I don't see how you would use such a tuple to do anything
10:51:51 <beekor> that is true,  as a novice, any monad paper starts with how this is a big topic, etc
10:52:01 <beekor> okay i shouldn't say 'any', but many.
10:52:02 <srhb> Oh... Oh god. Quantum Mechanics 1 is my "monad tutorial"... >_<
10:52:54 <kamatsu> that's why I like "You could have invented monads", which is the only monad tutorial worth a damn
10:53:09 <hiptobecubic> it's the value of the thing of type 'a', not the value of 'm a', but then again I'm not capable of rigorously defending that
10:53:18 <kamatsu> it's like "writer is just a tuple, reader is just a function, really there is no magic going on here"
10:53:37 * elliott is incredibly confused.
10:53:55 <hiptobecubic> kamatsu, yes, but then you think "Well what's the point of this stupid word then?"
10:54:13 <kamatsu> I've been asked that before
10:54:17 <kamatsu> I showed them the warm fuzzy thing filter
10:54:29 <hiptobecubic> ?
10:54:33 <kamatsu> monad, warm fuzzy thing, who cares what it's called, we just need a name for the interface
10:54:40 <hiptobecubic> oh
10:54:41 <kamatsu> there's some filter that replaces the word "monad" with "warm fuzzy thing"
10:54:48 <kamatsu> on any web page, iirc
10:54:54 <hiptobecubic> I thought you meant you suffocated them with a pillow.
10:55:11 <S11001001> misty banana unicorn
10:55:13 <kamatsu> i haven't gotten that exasperated with my students… yet.
10:55:44 <shachaf> hi S11001001
10:56:00 <hiptobecubic> well everyone knows they are burritos and not "warm fuzzy things" so that probably didn't clarify it
10:56:06 <shachaf> Have you considered changing your nick to 11001010?
10:56:07 <kamatsu> Monads are almost incidental in the class though, they usually understand them well enough to do the assignments. The thing they just don't get no matter how hard I try is rule induction
10:56:13 <S11001001> shachaf: no
10:56:47 <kamatsu> only the most talented students get my rule induction questions right. I don't think they have sufficient mathematical background
10:56:52 <kamatsu> but there's little I can do about that
10:56:52 <ijp> hiptobecubic: burritos can become warm fuzzy things, given time and a microwave
11:00:53 <d1p0> hi
11:00:57 <kamatsu> hi
11:01:22 <d1p0> begining with haskell
11:02:09 <kamatsu> welcome
11:04:59 <epta> Is there a way to lift Maybe from tuple?
11:05:02 <epta> @hoogle (a, m b) -> m (a,b)
11:05:02 <lambdabot> No results found
11:05:12 <kamatsu> sequence with writer and maybe
11:05:14 <basdirks> 1
11:05:17 <kamatsu> @hoogle sequence
11:05:18 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:05:18 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
11:05:18 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
11:05:22 <kamatsu> oh wait
11:05:27 <kamatsu> sequence is with lists
11:05:52 <kamatsu> @hoogle f (m a) -> m (f a)
11:05:52 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:05:52 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
11:05:52 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
11:06:57 <bourbaki> Greetings
11:07:16 <monochrom> ♥ haskell
11:07:42 <bourbaki> Is there anything for Haskell that i can use to require the user to provide a proof to instanciate a class or somesuch?
11:08:00 * hackagebot matchers 0.4.0.0 - Text matchers  http://hackage.haskell.org/package/matchers-0.4.0.0 (OmariNorman)
11:08:02 * hackagebot multiarg 0.8.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.8.0.0 (OmariNorman)
11:08:04 * hackagebot penny-lib 0.6.0.0 - Extensible double-entry accounting system - library  http://hackage.haskell.org/package/penny-lib-0.6.0.0 (OmariNorman)
11:08:24 <kamatsu> epta: write a traversable instance for (,) a and you can use Data.Traversable's sequence
11:08:26 <kamatsu> shouldn't be too hard
11:08:28 <fmap> @ty uncurry (\a b -> fmap ((,) a) b)
11:08:29 <lambdabot> Functor f => (a1, f a) -> f (a1, a)
11:09:07 <kamatsu> bourbaki: Haskell is not isabelle, and it is turing complete so the type system isn't a proof system like Coq or Agda
11:09:12 <kamatsu> bourbaki: So, in general no
11:09:32 <epta> fmap: great, thanks
11:09:33 <kamatsu> bourbaki: It's possible to do type-level proofs using GADTs but the logic is unsound
11:09:33 <fmap> @ty uncurry (fmap . (,))
11:09:34 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
11:09:40 <S11001001> @ty strength
11:09:42 <lambdabot> Not in scope: `strength'
11:09:46 <S11001001> ptthhh
11:10:08 <bourbaki> kamatsu: Hm ok i think that i really should finally tip over and have a look at agda ...
11:10:19 <roadfish>  /quit
11:10:27 <kamatsu> Agda is a pretty language
11:10:48 <bourbaki> Currently i have the idea to somehow prevent the user from using any function on the instances of the classes but the ones provided by them.
11:11:27 <bourbaki> So if you want to do something like distribute over a sum you need to provide a function for it.
11:11:36 <shachaf> S11001001: costrength is better anyway.
11:11:45 <bourbaki> kamatsu: I have no doubt about that only Emacs is holding me back so far :)
11:12:14 <kamatsu> bourbaki: What do  you mean "using any function on the instances of the classes but the ones provided by them"
11:12:15 <kamatsu> ?
11:12:57 <S11001001> bourbaki: Rank2Types, ExplicitForall, data Traversable f = Traversable (forall a b g. Applicative g => (a -> g b) -> f a -> g (f b))
11:13:06 * hackagebot penny-bin 0.6.0.0 - Extensible double-entry accounting system - binary and documentation  http://hackage.haskell.org/package/penny-bin-0.6.0.0 (OmariNorman)
11:13:08 <S11001001> syntax may vary with how well I remember it
11:13:25 <bourbaki> kamatsu: The problem i have is that you can just dabble with the operators although you might do something that is not allowed like using distributivity.
11:13:42 <bourbaki> S11001001: uh?
11:13:45 <kamatsu> i'm not sure I understand, an example?
11:14:01 <kamatsu> what's wrong with using distributivity?
11:14:15 <bourbaki> kamatsu: I mean that i want to prevent the user from using any function but the ones i require him to provide in that instance of the class.
11:14:24 <S11001001> bourbaki: given that definition, Traversable Maybe: * is the type of a value representing the ability to traverse Maybe
11:14:45 <bourbaki> kamatsu: That is all ok if it is real numbers but this is not always the case for all types.
11:14:47 <shachaf> @ty _just
11:14:49 <lambdabot> (Applicative f, Prismatic k) => k (a -> f b) (Maybe a -> f (Maybe b))
11:14:53 <kamatsu> uh… how would proof systems help there?
11:15:04 <kamatsu> I don't know what class you're even referring to
11:15:15 <bourbaki> So you could have an instance of a class that should have distributivity but you are not required to proof it or provide a function that makes this sure.
11:16:06 <bourbaki> kamatsu: I mean classes as in mathematical structures http://math-classes.org/
11:16:09 <kamatsu> right
11:16:28 <kamatsu> so you want a semigroup class say with associativity obligations
11:16:41 <bourbaki> Lets take a look at a ring, it can be commutative or not.
11:16:47 <kamatsu> right
11:16:50 <bourbaki> Er yes or a group.
11:17:06 <bourbaki> So all i can do in Haskell is label a new class, that just says so.
11:17:15 <kamatsu> so "laws" of a typeclass are typically just documentation in Haskell
11:17:16 <bourbaki> But there is no constraint there whatsoever.
11:17:19 <kamatsu> true
11:17:25 <kamatsu> there is no way to do this easily in Haskell
11:17:31 <bourbaki> Aye
11:17:39 <bourbaki> My idea was now to add a function to the class.
11:17:44 <bourbaki> Commutate for example
11:17:50 <tac> Needs more infinity groupoids
11:18:03 <kamatsu> with dependent types, you can just require a proof of your laws
11:18:09 <bourbaki> That takes to a's and two functions.
11:18:26 <kamatsu> similarly, with Isabelle, type classes may also contain proof obligations as well as definitions
11:18:46 <tac> type classes with proofs are nice things
11:18:49 <bourbaki> Might stuff like this eventually be added to Haskell?
11:18:58 <kamatsu> I would say no
11:19:07 <tac> bourbaki: I'm sure someone will hack it together, but it will never be pleasant in Haskell
11:19:30 <bourbaki> I mean i totally see the use of languages like Agda but from what i have gathered so far all languages in that field do not do quite well in terms of longlivity and such.
11:19:45 <kamatsu> why do you say that?
11:20:12 <kamatsu> we've had dependently typed languages for decades now
11:20:13 <bourbaki> I can not point to the article precisely atm but i read that other languages that have dependent types did not do quite well.
11:20:21 <tac> Longevity has nothing to do with it, I don't think. Dependent types in programming languages is just a relatively young idea.
11:20:22 <bourbaki> They all suffered from one or another problem.
11:20:32 <bourbaki> Aye
11:20:36 <tac> Martin-Lof's ITT has only been around since the 80s
11:20:57 <kamatsu> (I use the word "decades" because most dep typed languages are about 10 years old)
11:21:11 <bourbaki> I just wish that Agda would not have chosen Emacs as a default editor :(
11:21:17 <kamatsu> That's easily fixable
11:21:21 <kamatsu> patches welcome
11:21:29 <bourbaki> Fells like tackling two problems at once then :)
11:21:30 <kamatsu> I was working on integrating Yi
11:21:38 <tac> I'm really amazed what Agda is able to do with Emacs integration.
11:21:42 <tac> Is Yi even still around? :O
11:21:46 <bourbaki> I was opting for Sublime :)
11:21:47 <kamatsu> but the Emacs mode is still way better
11:21:54 <kamatsu> Sublime is not nearly flexible enough for our purposes
11:22:00 <bourbaki> Oh?
11:22:21 <tac> rather, is Yi even still under active development?
11:22:21 <kamatsu> Agda has the notion of "holes", which have an associated type context.
11:22:27 <kamatsu> tac: sadly, I think not
11:22:28 <bourbaki> Well maybe i really should have a look at Emacs it just feels so clunky and big :(
11:22:39 <tac> Holes are the greatest gift to programmers since the invention of types
11:22:45 <bourbaki> kamatsu: I saw that in a youtube video :)
11:22:46 <kamatsu> these holes let you interactively build up your program
11:22:52 <gwern> tac: don't we need holes only because of types?
11:22:59 <tac> bourbaki: I think emacs is a bit bloated, but at its core, it's a decent editor
11:23:04 <tac> gwern: shhhhhh :)
11:23:30 <bourbaki> Is there a working Debian package for Agda?
11:23:35 <kamatsu> i don't know
11:23:47 <kamatsu> i use the development version of agda
11:23:59 <kamatsu> so I haven't kept up to date with official releases, I just read the patch log
11:24:00 <bourbaki> I think ill try to get it working in a Debian virtual box.
11:24:41 <Clint> bourbaki: http://packages.debian.org/search?keywords=libghc-agda-dev
11:25:09 <bourbaki> Clint: Thanks a bunch
11:26:06 <tac> In that mathclasses link, are setoids just quotient types?
11:26:11 <tac> (same as in Agda)
11:26:23 <kamatsu> Agda has explicit setoids
11:26:39 <kamatsu> the quotient types were, as far as I remember, a way to make that nicer
11:26:53 <tac> well yeah. Sets + an equiv relation
11:27:29 <kamatsu> right, but if you look at the Agda standard library, all of the structures are with respect to some setoid, rather than using propositional equality
11:27:30 <bourbaki> Should we maybe move to #agda :)?
11:27:40 <tac> already there :P
11:27:54 <bourbaki> I know but kamatsu is not
11:27:55 <kamatsu> i should probably routinely join that, just setting up my new IRC client
11:28:11 <Wizek> > (round 33.3) / 10
11:28:12 <lambdabot>   Ambiguous type variable `a0' in the constraints:
11:28:12 <lambdabot>    (GHC.Real.Fractional a0...
11:28:15 <appamatto> Is there a good way to see which versions of a given package are compatible with your current .cabal file?
11:28:26 <Wizek> How can I make this yield 3.3?
11:29:11 <kamatsu> > (round 33.33 :: Double) / 10
11:29:13 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
11:29:13 <lambdabot>    arising from a use ...
11:29:14 <thoughtpolice> holes are so much nicer in agda than GHC.
11:29:20 <thoughtpolice> emacs integration aside
11:29:30 <kamatsu> what's wrong with the new GHC holes?
11:29:40 <kamatsu> > (round 33.33 :: Int) / 10
11:29:42 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
11:29:42 <lambdabot>    arising from a use o...
11:29:49 <kamatsu> oh for crying out loud
11:29:52 <kamatsu> >  fromIntegral (round 33.33 :: Int) / 10
11:29:54 <lambdabot>   3.3
11:30:07 <kamatsu> there
11:30:11 <thoughtpolice> well, i don't really think it's a *bug* but, it appears that when you put a hole somewhere, it will obviously only give you the types of some bindings in scope that are 'relevant.' but as you fill in the hole more, the context changes, so 'relevant bindings' change all the time
11:30:14 <Wizek> hmm
11:30:27 <thoughtpolice> so as i refine something with holes, i often 'lose track' of things because the bindings will get mentioned then disappear
11:30:36 <Wizek> are both of those necessary? If so, why?
11:30:58 <thoughtpolice> it's not really a bug, but i do find that annoying. the behavior in Agda seemed a bit more consistent, but then agda has a lot more evidence available and the feature isn't totally new
11:31:05 <thoughtpolice> so i imagine GHC could get a lot better here
11:31:47 <kamatsu> Wizek: it's because the numerics in Haskell are heavily overloaded, and GHC has to  resolve all types  eventually
11:31:53 <thoughtpolice> kamatsu: that's definitely my main complaint so far. i do think it's an awesome addition overall, though
11:32:03 <kamatsu> :t round
11:32:04 <lambdabot> (Integral b, RealFrac a) => a -> b
11:32:11 <glguy> > fromInteger (round 33.3) / 10
11:32:13 <lambdabot>   3.3
11:32:18 <kamatsu> oh, that works?
11:32:20 <kamatsu> surprising
11:32:50 <elliott> defaulting
11:33:25 <kamatsu> ah yeah, i'm not much a fan of that
11:33:29 <seliopou> :t round
11:33:30 <lambdabot> (Integral b, RealFrac a) => a -> b
11:33:34 <seliopou> :t 33.33
11:33:35 <lambdabot> Fractional a => a
11:33:46 <appamatto> Do you do "cabal init" repeatedly or update the file manually, or is there some other recommended way of managing .cabal files?
11:33:52 <seliopou> mmm
11:34:01 <kamatsu> appamatto: I just write them by hand
11:34:24 <thoughtpolice> i normally just copy a cabal file from another project of mine, and replace all occurrences of the package name using a regex :P
11:35:01 <appamatto> Heh, nice. The package version calculus seems difficult to manage though
11:35:05 <dcoutts> appamatto: created it with cabal init, after that edit it by hand
11:35:16 <dcoutts> don't do what thoughtpolice does :-)
11:35:28 <srhb> I throw stuff at it by hand until it compiles.
11:35:33 <appamatto> hehe
11:35:50 <Taneb> I am pretty sure "(ArrowMonad (Cokleisli ((,) a))) b" is equivalent to "a -> b"
11:35:55 <appamatto> My hand edits use == instead of <= etc.
11:36:03 <dcoutts> cabal init  is reasonably good, it gives you sensible stuff, close to current recommended practice
11:36:12 <appamatto> It's nice that cabal init can give you version ranges
11:38:36 <Taneb> \(ArrowMonad (Cokleisli f)) r -> f (r, ())
11:39:00 <Taneb> \f -> ArrowMonad (Coklesili $ \(r,()) -> f r)
11:40:04 <monochrom> I write invalid field names into the project.cabal file, then run "cabal configure" to show me undocumented valid field names
11:40:45 <seliopou> monochrom: even for documented ones, it's quicker than looking it up
11:41:28 <elliott> monochrom: What's the best invalid field name?
11:41:43 <monochrom> wonky
11:42:16 * Lethalman still can't realize why @djinn doesn't work on his local lambdabot :-(
11:42:40 <monochrom> for example the yet undocumented default-language
11:43:37 <hpaste> “dr.chaos” pasted “checkHMAC” at http://hpaste.org/80464
11:44:07 <elliott> Lethalman: perhaps you do not have djinn installed
11:44:13 <elliott> monochrom: I think default-langauge id documented?
11:44:14 <elliott> is
11:44:15 <Lethalman> elliott, I have and lambdabot finds it
11:44:20 <Lethalman> elliott, it's something in parsing the output
11:44:58 <snowylike> what licenses are recommended within the haskell community?
11:45:00 <snowylike> (and why)
11:45:08 <monochrom> I can't find it in http://www.haskell.org/cabal/users-guide/developing-packages.html
11:45:13 <elliott> snowylike: BSD and because everyone uses it
11:45:34 <snowylike> ghc is BSD too, right?
11:45:34 <shachaf> snowylike: Be a rebel, use MIT.
11:45:45 <Taneb> shachaf, elliott told me off when I used MIT
11:46:10 <elliott> I think me telling you off if you do it is the best reason to not do anything.
11:46:10 <glguy> snowylike: GHC is provided to you under the BSD3 license. Common practice is to do the same.
11:46:36 <snowylike> okay
11:47:12 <monochrom> be a rebel. specify no license. let the users scratch their heads :)
11:47:18 <shachaf> Am I not supposed to install containers-0.5.2.1?
11:47:26 <shachaf> It conflicts with template-haskell, it seems.
11:47:30 <Clint> Taneb: why, because ISC is better?
11:47:42 <monochrom> containers comes with GHC. you are not supposed to override it
11:47:52 <shachaf> OK then.
11:47:58 <Taneb> Clint, seriously, because BSD3 is essentially the same and supported by more versions of Cabal
11:47:59 <shachaf> Time for a third rm -r .ghc
11:48:06 <Clint> Taneb: no, BSD2 is essentially the same
11:48:07 <Clint> BSD3 sucks
11:48:12 <shachaf> If I'm not supposed to override it, why does cabal try to override it so much?
11:48:13 <monochrom> and a ton of other things that come with GHC depends on containers
11:48:24 <Taneb> Clint, oh no!
11:48:24 <monochrom> because cabal doesn't know
11:48:29 <glguy> This is not a good channel for license debates
11:48:31 <Clint> true
11:49:06 <monochrom> but I believe cabal does say, "reinstalls may break things. not doing it. use --force-reinstall if you want"
11:50:03 <shachaf> monochrom: No, it just goes ahead and installs 0.5.2.1
11:50:12 <shachaf> For things that don't depend on template-haskell
11:50:28 <shachaf> Then when you try to install something that uses template-haskell much later, it tells you that it would have to downgrade it and reinstall everything.
11:52:31 <monochrom> oh, I see, it does that. bad bad bad
11:53:21 <Taneb> That's why I --dry-run everything now
11:53:34 <monochrom> yes, and why I tell everyone to do that
11:53:42 <Taneb> After I ended up with half a dozen versions of bytestring
11:53:55 <monochrom> and sandboxing etc etc
11:53:55 <kartoffelbrei> quick question: to check out holes in GHC, i'll have to fetch the HEAD version source and build it myself, right?
11:54:15 <elliott> kartoffelbrei: yes
11:54:33 <kartoffelbrei> elliott: thanks
11:54:45 <Lethalman> ok I sorted out the problem
11:55:00 <shachaf> monochrom: So what is the point of releasing containers-0.5.2.1?
11:55:04 <Lethalman> or maybe not...
11:55:10 <shachaf> Presumably GHC 7.8 will have containers-0.6 anyway.
11:55:11 <monochrom> I don't mind. I didn't do it...
11:55:16 <monochrom> err
11:55:20 <monochrom> I don't know. I didn't do it...
12:03:40 <sm> --dry-run++ !
12:04:00 <Taneb> @karma --dry-run
12:04:00 <lambdabot> --dry-run has a karma of 1
12:11:43 <fmap> @karma x
12:11:43 <lambdabot> x has a karma of 14
12:12:09 <j> j
12:12:31 <Taneb> @karma Taneb
12:12:31 <lambdabot> You have a karma of 1
12:12:34 <Taneb> :/
12:12:40 <ski> Guest51193 : hello
12:12:42 <Taneb> @karma shachaf
12:12:42 <lambdabot> shachaf has a karma of 30
12:12:47 <shachaf> @karma+ java
12:12:47 <lambdabot> shachaf's karma lowered to 29.
12:12:50 <Taneb> shachaf popular
12:13:34 <ski> heh
12:13:58 <shapr> Is Erik de Castro Lopo here?
12:13:58 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
12:14:46 <kaol> shapr: His nick is m3ga, and not currently.
12:15:57 <shapr> ah, too bad. I want his patch for qemu-static that allows building of ghc: https://bugs.launchpad.net/qemu/+bug/1042388
12:16:18 * shapr digs around for m3ga's email address
12:17:45 <kaol> He's used mle+hs@mega-nerd.com on debian-haskell@lists.debian.org
12:18:03 <kamatsu> mailto:erikd@mega-nerd.com
12:18:10 <kamatsu> i think that's for mailing lists
12:18:17 <kamatsu> use erikd@ i think
12:18:52 <shapr> I'll try that, thanks!
12:19:07 <shapr> kamatsu: Hopefully he won't get lots of spam since #haskell is logged :-)
12:19:25 <kamatsu> it's on his website
12:19:34 <kamatsu> i don't think he's concerned
12:19:38 * Lethalman still couldn't sort out the lambdabot problem with djinn :'-(
12:19:56 <kaol> @karma kaol
12:19:56 <lambdabot> You have a karma of -10
12:20:05 <Taneb> Oh no
12:20:09 <kamatsu> how did that happen?
12:20:11 <kamatsu> @karma kamatsu
12:20:11 <lambdabot> You have a karma of 0
12:20:13 <kamatsu> :(
12:20:22 <Taneb> kamatsu--
12:20:31 <shachaf> What's going on?
12:21:48 <shapr> kaol++
12:22:34 <kamatsu> @karma kamatsu
12:22:34 <lambdabot> You have a karma of -1
12:22:38 <kamatsu> can i give myself karma?
12:22:39 <kamatsu> kamatsu++
12:22:44 <kamatsu> @karma kamatsu
12:22:44 <lambdabot> You have a karma of -1
12:22:45 <alec> what's the python/IDLE equivalent of haskell :l in ghci?
12:22:46 <kamatsu> aww
12:22:59 <Lethalman> YES!
12:23:12 <Lethalman> shachaf, had to wrap djinn to output one Djinn> less
12:25:29 <kaol> I put Haskell on my resume and I was asked to criticize it in a job interview. I was thinking that reading my old code hurts more than with some other languages.
12:25:46 <alec> interesting, kaol
12:25:46 <kamatsu> i have a long list of things I don't like about Haskell
12:25:47 <shapr> huh, interesting.
12:25:50 <alec> which job interview?
12:25:53 <kamatsu> but pretty much any language has a longer list
12:25:56 <alec> what kind of position?
12:26:02 <shapr> kamatsu: Me too, first and foremost that I don't have a job writing Haskell.
12:26:24 <Taneb> Things I don't like about Haskell:
12:26:26 <Taneb> Um
12:26:39 <kamatsu> records suck, data abstraction is annoying
12:26:50 <kaol> Web development mainly, though it's going to be mostly with Java and PHP.
12:26:57 <Taneb> I can't think of anything I can't get around
12:27:07 <alec> ok
12:27:24 <thoughtpolice> kamatsu: no module abstraction at all :/
12:27:31 <c_wraith> There are plenty of things I don't like about Haskell.  But the list is longer for every other language I've used.
12:27:32 <kamatsu> yeah
12:28:07 <alec> compiling stuff seems really cpu intensive
12:28:16 <kaol> The interviewer started talking about lisp. He thought that macros were hot stuff.
12:28:16 <alec> i don't like that
12:28:24 <alec> lisp is fugly
12:28:29 * alec hates lisp with a passion
12:28:30 <kamatsu> I think macros are madness
12:28:40 <Taneb> I have more problems with the haskell environment
12:28:43 <kamatsu> but I used to be a schemer, so I still have some partiality to them
12:28:46 <Taneb> Haddock docs for type families is poor
12:29:21 <Taneb> emacs' haskell mode thingy has indentation rules I disagree with
12:29:55 <kamatsu> if we're talking Haskell with extensions, I find the haskell type system with GADTs and type families to be relatively nice, but throw in data kinds and stuff can get annoying when it doesn't have to be
12:30:18 <Lethalman> shachaf, c_wraith the problem was djinn output was Djinn> f :: ... while lambdabot needed Djinn> \nf :: ... so I wrapped djinn with a script :(
12:30:33 <parcs> kaol: perhaps reading your old haskell code is harder because you are presumably relatively less experienced with reading haskell than with reading other languages
12:30:48 <kamatsu> e.g type classes on a closed promoted kind, you have to put the constraint on the type even if every inhabitant of the closed kind is a member of the type class.
12:31:40 <kaol> foldrs seem write only to me. But I love them nonetheless.
12:32:07 <kaol> I get sad when I have to write for loops in some other language.
12:32:29 <kamatsu> foldr's aren't write only to me
12:32:45 <Taneb> foldr's are read-only to me
12:32:54 <parcs> i don't think any language is inherently less readable than another
12:33:05 <Taneb> Malbolge
12:33:06 <kamatsu> parcs: You haven't used APL, I see
12:33:07 <Taneb> Whitespace
12:33:19 <Taneb> Glass
12:33:48 <c_wraith> my favorite is still foldr (\x xs -> if x == ' ' && null xs then "" else x:xs) []
12:34:04 <alec> i disagree, parcs; look at brainfuck
12:34:06 <c_wraith> That's a brilliant example of optimal laziness in foldr
12:34:09 <kamatsu> remove trailing spaces?
12:34:20 <parcs> alec: brainfuck isn't that unreadable if you format it nicely
12:34:40 <Taneb> parcs, Whitespace
12:34:42 <thoughtpolice> kamatsu: well, technically as it stands, there are no closed kinds. Any is a superkind of everything, so you can break stuff using it. i think this will get resolved in 7.8.x
12:35:09 <c_wraith> kamatsu: yes, but it's as lazy as possible - it results in characters as soon as it knows they aren't trailing whitespace
12:35:26 <c_wraith> well, trailing spaces
12:35:28 <thoughtpolice> (in practice i'm not sure if it's worth GHC catering to people-using-Any-everywhere, but there may be theoretical issues beyond "just ignore it and try to infer things anyway")
12:36:05 <kaol> I guess foldr isn't the culprit but my overeagerness to turn my lambdas to pointfree code.
12:36:50 <kaol> Who needs variables.
12:37:08 <shapr> stack based languages?
12:37:33 <Eelis> or someone implementing id ;)
12:37:35 <parcs> i think what people attribute to "readability" in languages is actually "how similar is this language with what i am already used to"
12:37:42 <neutrino_> hi
12:37:42 <Taneb> shapr, Underload is Turing-complete and stack-based, and has no variables
12:38:12 <Taneb> > join const 4
12:38:13 <lambdabot>   4
12:38:20 <Taneb> id, pointfree
12:38:27 <c_wraith> > fix const 4
12:38:28 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = b0 -> t0
12:38:33 <c_wraith> oh, right
12:38:36 <c_wraith> > fix $ const 4
12:38:38 <lambdabot>   4
12:38:48 <Eelis> Taneb: yeah, i meant "someone implementing id in a non-contrived way"
12:38:48 <c_wraith> so, yeah, more complicated than join const
12:38:50 <neutrino_> i have been looking at a possible way of representing a tree in such a way that it can be parsed incrementally, while the document describing it is streaming
12:38:54 <Lethalman> c_wraith, how is it possible that x == ' ' && null xs for two spaces? isn't it (' ':' ':"") so xs is " " ?
12:38:54 <Taneb> Eelis, bah
12:39:01 <neutrino_> can anyone suggest any approaches to this?
12:39:03 <Lethalman> maybe I have to revisit foldr
12:39:31 <c_wraith> Lethalman: I really like that example because it forces you to *really* understand what foldr is doing.
12:39:31 <kaol> If the same algorithm takes a few lines with Haskell and a screenful with some other language, will the time read both be the same?
12:39:44 <neutrino_> i'm trying to represent a variable-branch-number tree
12:39:47 <c_wraith> kaol: depends on how familiar you are with the idioms the code uses, in either case
12:40:00 <c_wraith> neutrino_: does Data.Tree work?
12:40:17 <Taneb> > fix (flip ap . flip const) const 5
12:40:20 <lambdabot>   5
12:40:41 <Taneb> id without variables or join
12:40:45 <neutrino_> c_wraith: i'm not talking about the data structure in haskell, i'm talking about what's written to disk
12:41:15 <c_wraith> neutrino_: oh.  If you want streaming, you want to use a prefix representation
12:41:31 <neutrino_> one way i thought of was to specify each node with its full path, kind of like when you do "find ." in a directory
12:41:39 <neutrino_> c_wraith: what is prefix representation?
12:41:44 <Lethalman> c_wraith, got it... very nice
12:42:28 <c_wraith> neutrino_: information on a node before information on its children
12:42:46 <Taneb> :t fix (flip ap . flip const)
12:42:46 <neutrino_> as opposed to..?
12:42:47 <lambdabot> (a -> a -> b) -> a -> b
12:42:50 <neutrino_> infix?
12:43:02 <c_wraith> neutrino_: or postfix
12:43:10 <Taneb> :t fix ((<**>) . seq)
12:43:11 <lambdabot>     Ambiguous occurrence `<**>'
12:43:11 <lambdabot>     It could refer to either `Control.Applicative.<**>',
12:43:11 <lambdabot>                              imported from `Control.Applicative' at State/L.hs:4:1-26
12:43:21 <Taneb> :t fix ((Control.Applicative.<**>) . seq)
12:43:22 <lambdabot> (a -> a -> b) -> a -> b
12:43:27 <neutrino_> what would postfix representation of a tree look like?
12:43:29 <Taneb> > fix ((Control.Applicative.<**>) . seq) (+) 2
12:43:31 <lambdabot>   4
12:43:45 <Taneb> > fix ((Control.Applicative.<**>) . seq) const pi
12:43:47 <lambdabot>   3.141592653589793
12:43:49 <c_wraith> neutrino_: RPN notation for arithmetic is postfix:  3 4 +
12:44:04 <Taneb> Haskell: best language
12:44:04 <neutrino_> i thought rpn was the other way around? that is, + 3 4
12:44:10 <Taneb> That's just pn
12:44:20 <c_wraith> postfix is really nice when you want to add to the tree incrementally
12:44:37 <c_wraith> because you can always add another node and say "this is the parent of the whole previous tree"
12:44:46 <neutrino_> mhm
12:44:54 <neutrino_> i see what you mean
12:45:18 <c_wraith> a prefix notation doesn't allow that, since it starts at the root
12:45:24 <neutrino_> rihgt
12:45:36 <Lethalman> c_wraith, you can still build a tree btw
12:45:38 <c_wraith> But that also means that when you're reading it from a stream, you know when you're done
12:45:40 <neutrino_> what do you think of my "find"-inspired idea?
12:47:09 <c_wraith> It allows better random access, but you lose the ability to easily derive the shape of the tree from a single pass over the data.  (you can still do it, but it's more work)
12:47:21 <Lethalman> it's just a stack
12:47:49 <neutrino_> c_wraith: why do i lose the ability to derive the shape of the tree from a single pass when using a full path-to-node??
12:47:55 <neutrino_> sorry, one too many question marks
12:48:34 <c_wraith> You don't lose the ability, you just lose it being completely trivial
12:48:50 <c_wraith> You have to reconstruct it from parts, instead of it being automatic
12:49:22 <neutrino_> how do you mean?
12:50:01 <neutrino_> sorry if i'm being slow, i just can't picture what you mean
12:53:27 <c_wraith> the obvious way to make it work is to accumulate the paths into a tree. Which works, and isn't a performance problem - but it's not just plain old starting with a tree.
12:57:08 <neutrino_> c_wraith: hmm
12:57:15 <neutrino_> c_wraith: what is "plain old starting with a tree"?
12:58:31 <seliopou> What about some sort of suffix language? You could incrementally parse it in that case
12:59:20 <c_wraith> well, if you're parsing a prefix representation of the tree, you never have to explicitly spend code building it - just the recursion in parsing the representation is an implicit representation of it, which is sufficient for many purposes.
12:59:45 <epta> Is there a way to load 2 files in ghci?
12:59:45 <ClaudiusMaximus> hiptobecubic: pushed the code here, not yet fixed for OpenGL 2 though... https://gitorious.org/maximus/butterflies
12:59:50 <seliopou> I'm thinking something like this: 1 2 l 3 4 l 4 p m m
13:00:00 <mvj4_> Tardis (time traveling state) issue: "Just n <- getFuture; sendPast (Just 2)" results in an infinite loop. There is an example in the documentation on the same format, but it does not evaluate the result. Any ideas?
13:00:05 <hiptobecubic> ClaudiusMaximus, ok
13:00:09 <c_wraith> Whereas with a list of paths, you don't get that implicit representation when parsing the data
13:00:20 <seliopou> erm, I meant
13:00:29 <seliopou> that doesn't make sense
13:00:35 <seliopou> but basically the idea is
13:00:43 <seliopou> you have a list of labels
13:00:51 <seliopou> you say "I'm done listing labels" for this layer
13:01:15 <seliopou> goes on a stack, then you have a command that creates a node with this label
13:01:35 <seliopou> and a command that adds the most recent layer as a child to that node
13:01:47 <hiptobecubic> ClaudiusMaximus, i'll pull again after you (possibly?) update it
13:02:12 <neutrino_> c_wraith: i'm still not sure what the difference is. do you mean that with explicit paths, i have to split off the part of the path that is "new"?
13:02:19 <seliopou> so something like: 1 n 2 n 3 n 4 n 5 n m m 6 n m m 7 m m
13:03:18 <ClaudiusMaximus> hiptobecubic: yep i'll let you know when i get it working on my old laptop...
13:03:54 <seliopou> Would create: Tree 7 [Tree 6 [Tree 5 [Leaf 3, Leaf 4], Leaf 2, Leaf 1]]
13:04:02 <c_wraith> neutrino_: I'm not sure I can explain it further. I guess I've reached this point from doing a lot of work with both representations at various times.
13:04:18 <neutrino_> yeah, i haven't worked much with trees.
13:04:26 <hiptobecubic> ClaudiusMaximus, i should also see about these gfx drivers. intel usually has decent support and this is the latest crap from them (ivy)
13:04:38 <hiptobecubic> might have to build a new kernel
13:05:18 <Lethalman> @pl f1 f2 x = f1 (f2 x)
13:05:18 <lambdabot> f1 = fix (.)
13:05:41 <roscot> Ciao a tutti
13:05:49 <ClaudiusMaximus> hiptobecubic: i think Mesa 9 or 10 might support it, maybe ##opengl would know more, but i'm not sure how stable those versions are...
13:05:50 <neutrino_> quick, ban roscot
13:05:54 <neutrino_> @where ops
13:05:54 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
13:05:54 <lambdabot> xerox
13:06:03 <neutrino_> bah
13:06:26 <shapr> eh? who's roscot?
13:06:37 <glguy> Discussion -> #haskell-ops
13:06:40 <neutrino_> xdcc wardialer bot.
13:18:32 <kamatsu> what's a wardialer?
13:18:42 <neutrino_> talk in #haskell-ops
13:20:44 * shapr attempts to cabal install yesterday's version of imapget on his Raspberry Pi
13:20:46 <Canar> kamatsu: a program that dials a bunch of phone numbers looking for a network to connect to
13:21:19 <shapr> I'll be highly irritated if imapget also fails, that means none of the functionality I want builds in 256MB of RAM with a 100MB swapfile.
13:21:33 <Taneb> kamatsu, an obnoxious fan of a certain movie, often found on Tumblr
13:22:06 <Canar> Taneb: what film?
13:22:15 <ezyang> Does cabal-dev support 'cabal-dev runghc'?
13:22:29 <Taneb> The Lorax, I believe
13:22:55 <Taneb> Although I'm not particularly sure
13:23:07 * hackagebot blastxml 0.3 - Library for reading Blast XML output  http://hackage.haskell.org/package/blastxml-0.3 (KetilMalde)
13:23:33 <ezyang> (it doesn't support that particular spelling, but I'm wondering if there's a way to get something similar)
13:26:14 <Hafydd> Hey, there's an idea for a new esoteric typeclass-name: Lorax
13:27:20 <byorgey> ezyang: what would you like it to do?
13:29:00 <neutrino_> shapr: i see you are into xtreme computing.
13:30:09 <ezyang> byorgey: Hm, are the semantics not clear? I would imagine it would be like 'cabal-dev ghci' except non-interactive.
13:30:33 <shapr> neutrino_: eh?
13:30:53 <byorgey> oh, yes, I see now
13:31:32 <byorgey> ezyang: anyway, I'm pretty sure the answer is no
13:31:46 <alpounet> byorgey, run a script with the current sandbox -- for quickly testing your library or smth
13:31:50 <alpounet> i guess
13:32:06 <byorgey> I guess you have to pass some sort of flag to the normal runghc telling it where to find the package DB
13:32:39 <neutrino_> shapr: pushing your raspi to the limit
13:33:04 <shapr> Oh, yah... want to donate to my fund to buy a 512MB Pi so I can actually do real Haskell dev on ARM?
13:33:07 * hackagebot hyperdrive 0.1 - a fast, trustworthy HTTP(s) server built  http://hackage.haskell.org/package/hyperdrive-0.1 (JeremyShaw)
13:33:21 <shapr> I'm at 52.5% of $40 since two guys at my hackerspace donated.
13:33:27 <ezyang> ok, maybe I'll contribute the feature.
13:34:12 <Taneb> shapr, do you have a donatey thing
13:34:23 <alpounet> byorgey, yeah, cabal-dev can even give you the GHC options it uses
13:34:35 <alpounet> cabal-dev ghc-opts or smth
13:34:44 <ezyang> I don't understand how to use that flag
13:34:47 <byorgey> ezyang: don't bother contributing to cabal-dev, it's dead. contribute to cabal-install instead.
13:34:57 <ezyang> Oh, cabal-dev is dead? Oooops.
13:35:06 <byorgey> I mean dead metaphorically.
13:35:08 <alpounet> yeah cabal-install will have proper sandboxes soon
13:35:28 <byorgey> cabal-install is going to supersede it soon, and it is barely maintained.
13:35:36 <ezyang> ah, ok
13:35:36 <neutrino_> shapr: i sorta have to pay my rent first :p
13:35:39 <shapr> Taneb: paypal to shae@ScannedInAvian.com ?
13:35:43 <alpounet> it'll have been of great help though
13:35:44 <neutrino_> but other than that i'd love to
13:35:47 <byorgey> if you submit pull requests for cabal-dev they will likely just sit there unmerged.
13:35:53 <shapr> Taneb: It's been suggested I should do a kickstarter.
13:36:01 <neutrino_> howeve, if you want, i have access to an 18-bit PDP, so you could put haskell on that.
13:36:04 <neutrino_> *however
13:36:23 <shapr> neutrino_: no thanks, I have enough white elephant hardware at the moment :-/
13:36:38 <neutrino_> it's not hardware it's just a login
13:36:51 <neutrino_> it's internetworked to the world wide web
13:38:54 <Taneb> shapr, I've thrown some money at you
13:39:29 <Taneb> It...
13:39:31 <Taneb> might cover it
13:39:35 <shapr> Taneb: w00t! thanks!
13:40:12 <Taneb> How much did I send, in American?
13:40:21 * shapr checks
13:40:57 <shapr> nothing at the moment.
13:41:10 <Taneb> Give it a few minutes, it's got to get across the atlantic
13:42:25 <shachaf> ciao
13:42:26 <shachaf> !list
13:42:26 <monochrom> shachaf: http://okmij.org/ftp
13:42:32 <shachaf> monochrom: thx
13:42:42 <rio> having functions f :: a -> b -> c, p :: a' -> a, q :: b' -> b, how would i obtain the obvious composition a' -> b' -> c?
13:42:59 <shapr> Taneb: I hope it gets across the atlantic!
13:43:04 <Taneb> So do I
13:43:42 <shachaf> @djinn (a -> b -> c) -> (a' -> a) -> (b' -> b) -> a' -> b' -> c
13:43:42 <lambdabot> f a b c d e = a (b d) (c e)
13:43:47 <shachaf> @@ @pl @djinn (a -> b -> c) -> (a' -> a) -> (b' -> b) -> a' -> b' -> c
13:43:47 <lambdabot>  f = ((flip . ((.) .)) .) . (.)
13:43:54 <shachaf> Hmm, not optimal.
13:45:17 <rio> in my case i want to compose || with two functions that even take the same number and give a boolean
13:45:27 <croikle> seems like something with (***)
13:45:36 <S11001001> rio: are a' and b' the same?
13:45:38 <croikle> but maybe the basic lambda is most readable :)
13:45:51 <Taneb> Can someone give shapr a quarter?
13:46:05 <rio> S11001001: in this case, yes
13:46:15 <shapr> My 512MB Raspberry Pi fund is now at $39.75 of $40 !
13:46:16 <S11001001> rio: liftA2 f p q
13:46:28 <shapr> Taneb: w00t! Many thanks!
13:46:33 <Taneb> No problem!
13:46:55 <byorgey> I can give shapr a quarter!
13:46:59 <byorgey> But it is a physical one.
13:47:13 <byorgey> I promise to give it to shapr next time I see him.
13:47:58 <S11001001> rio: iow liftA2 specializes to (a -> b -> c) -> (r -> a) -> (r -> b) -> r -> c
13:48:09 <shapr> byorgey: ha!
13:48:36 <Taneb> shapr, that's you funded!
13:48:52 * shapr dances cheerfully
13:49:15 <shapr> and now to see if I can find a Raspberry Pi in stock somewhere...
13:49:15 <hiptobecubic> what about shipping?
13:49:41 <shapr> hiptobecubic: The plan was to find a Pi and shipping for about $40, I'm hoping that can be done.
13:49:47 <hiptobecubic> ah
13:50:00 <hiptobecubic> i wouldn't know. I don't have one either:(
13:50:03 <startling> shapr, you got enough? cool!
13:50:20 <startling> now you can do all the hard work and I can have GHC someday when I decide to get one!
13:50:29 <shapr> I'm okay with that :-)
13:50:29 <luite> is 256MB with some swap enough?
13:50:39 <Taneb> I knew it was a good investment
13:50:50 <shapr> luite: It's not enough to build libraries I desire such as iCalendar
13:51:05 <shachaf> shapr: Why is it not enough? Just takes too long, or what?
13:51:11 <luite> does it have a sata connector?
13:51:21 <Taneb> Best 12 I've ever sent someone I've never met in another country for no immediate return
13:51:21 <shapr> The oom killer takes over and kills ghc
13:51:29 <luite> shapr: more swap?
13:51:30 <shachaf> shapr: What if you add more swap?
13:51:53 <shapr> I have a 100mb swapfile and a 4gb usb stick in my pocket...
13:52:15 <shapr> That still wouldn't be enough to build ghc 7.6, of course.
13:52:29 <elliott> 4 gigabytes should be enough to build GHC.
13:52:30 <shachaf> Plug a bigger thing into it?
13:52:45 <shapr> At some point swap space just leads to thrashing.
13:52:50 <hpaste> derdon pasted “type inference behaviour” at http://hpaste.org/80470
13:52:51 <luite> usb hdd might be faster
13:52:59 <Taneb> This is how I imagine shapr right now: http://www.mspaintadventures.com/storyfiles/hs2/04104_4.gif
13:53:08 * hackagebot Workflow 0.8.0.0 - Monad transformer for thread state persistence and workflow patterns  http://hackage.haskell.org/package/Workflow-0.8.0.0 (AlbertoCorona)
13:53:11 <derdon> can someone explain the output of my paste to me?
13:53:11 <shapr> Taneb: yup, pretty much :-)
13:53:20 <Eelis> i don't really get this raspberry pi excitement. wikipedia tells me it was developed "with the intention of stimulating the teaching of basic computer science in schools". sounds really boring
13:53:48 <shapr> Eelis: It's a 'real' Linux box for $40 that fits into your pocket.
13:53:54 <derdon> why does it make a difference whether I assign a function to a name or if I access its type directly?
13:53:56 <S11001001> derdon: http://www.haskell.org/onlinereport/decls.html#sect4.3.4
13:54:10 <Eelis> shapr: why would i carry that thing in my pocket? i already have a smartphone
13:54:11 <luite> Eelis: yeah school sux, boring!
13:54:18 <derdon> S11001001: thanks
13:54:18 <S11001001> derdon: also search "monomorphism restriction"
13:54:27 <derdon> ok, will do that
13:54:30 <Nereid> dmr = delightful monomorphism restriction.
13:54:37 <Nereid> @where dmr
13:54:37 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:54:44 <S11001001> cool
13:55:00 <shapr> Eelis: If you drop a smartphone you're out $400+
13:55:13 <Eelis> shapr: sure, but i want to do that anyway because i want some decent hardware in my pocket
13:55:17 <Eelis> not $40 junk
13:55:20 <shapr> But a $40 computer is cheap enough to try crazy things with.
13:55:29 <hiptobecubic> it's not junk
13:55:35 <alpounet> well, also, you're not forced to put it in your pocket, but you could also put it on wheels and make it a self driving car
13:55:47 <Eelis> hiptobecubic:  compared to a $400 smartphone, it obviously is :)
13:55:48 <alpounet> (tiny, tiny car, even)
13:55:59 <luite> hmm, does it have an accelerometer?
13:56:03 <Nereid> no
13:56:11 <hiptobecubic> Eelis, still no.
13:56:11 <luite> aw :/
13:56:22 <Eelis> hiptobecubic: if you say so
13:56:33 <Nereid> nor wifi or a cell radio or a screen or ...
13:56:37 <shapr> Eelis: You can buy one and see if it can still work while submerged in cooking oil.
13:56:38 <alpounet> luite, nah but I think there are many ways to plug a lot of fun stuffs :)
13:56:39 <luite> it's probably about as fast as a $90 smartphone
13:56:45 <Eelis> shapr: useful
13:56:51 <shapr> I got a $10 wifi widget that works nicely with my Pi
13:56:59 <Nereid> that's the idea.
13:57:29 <shapr> Eelis: this is the first full Linux system that's cheap enough for any sort of experiment that might kill it.
13:57:52 <Eelis> ok, i guess it's exciting for hardware hobbyists then
13:57:53 <luite> alpounet: yeah... it's probably fun to tinker with... but i don't want to add more unfinished projects to my already way too long list :/
13:58:33 <shapr> Eelis: I don't have a smartphone, it doesn't fit into a student loans budget. but I'm making my own smartclone that does google calendar, google voice, gmail, twitter and whatever else.
13:58:35 <shapr> with HASKELL!
13:58:45 <Eelis> good luck with that
13:59:13 <luite> the new lego mindstorms kit also looked interesting, but i can't find the information anymore :/
13:59:17 <shapr> All the libraries exist on Hackage, and they build on my laptop, so I'm hoping they will build with the new Pi that has 512MB
13:59:18 <alpounet> luite, luckily, that's something I have had the occasion to do at high school… but it was really dumb and simple, I could make something really awesome now, I even have my neural nets lib for OCR and whatnot :p anyway, i plan to resume that kind of stuffs once i'm out of the student situation
13:59:34 <Eelis> can't you crosscompile?
13:59:51 <shapr> Can ghc cross-compile?
13:59:54 <luite> ah 64MB RAM ARM9, 16MB flash
14:00:00 <Eelis> shapr: no clue, never tried
14:00:03 <hiptobecubic> i thought not
14:00:05 <monochrom> GHC cross-compile story has just begun
14:00:11 <shapr> Eelis: See, so many things to learn!
14:00:12 <Eelis> heh, how embarrassing
14:00:37 <luite> alpounet: hehe
14:00:56 <luite> alpounet: they had some mindstorms kits in my undergrad university, but i never actually played with one... :/
14:00:57 <monochrom> I think "compile to ARM" is the first and current goal
14:01:17 <hiptobecubic> can't llvm help with this somehow? Or does it not target arm
14:01:29 <shapr> monochrom: that works decently with ghc 7.4, but that version doesn't have ghci or template haskell
14:01:33 <shapr> ghc 7.6 has both on ARM
14:01:56 <alpounet> luite, the cool thing is that I can give the boring (for me) stuffs to do to other people -- i'm really not good for graphical art/design for example :P -- so that makes it even funnier
14:01:59 <monochrom> I mean the cross-compile story. so, on x86, compile to ARM
14:02:59 <shapr> hiptobecubic: I think llvm is central to ghc 7.6 having ghci and template haskell on ARM
14:03:06 <luite> monochrom: please volunteer to get cross compilation with template haskell working!
14:03:27 <luite> <- really want it for ghcjs
14:04:01 <alpounet> luite, are there things ghcjs doesn't support yet?
14:04:20 <luite> uh lots, i guess :p
14:04:20 <shapr> Eelis: Does any of that explain why the Raspberry Pi has some appeal?
14:04:35 <Eelis> shapr: like i said, i can see the point for hardware hobbyists
14:04:50 <alpounet> luite, for example I guess it can't handle anything dealing with the ( C ) FFI
14:05:09 <luite> alpounet: nah it can call javascript
14:05:18 <luite> lots of the base library depends on ffi
14:05:43 <alpounet> luite, yeah but it won't build e.g hmatrix
14:06:11 <luite> alpounet: yeah unless you reimplement it somehow in javascript, possibly with the help of emscripten
14:07:18 <startling> Eelis: one reason I kind of want one is to use as an always-on mpd server to attach to speakers in my kitchen.
14:07:36 <Eelis> i see
14:07:54 <startling> like, there's a lot of stuff that's worth doing if it only takes $30 and trivial amounts of power.
14:08:09 * hackagebot MFlow 0.2.0.0 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.2.0.0 (AlbertoCorona)
14:08:38 <shapr> I built a buck converter circuit for my Pi so I can run it off six AAs in my jacket pocket, and wifi works.
14:08:47 <hiptobecubic> startling, yes
14:08:57 <hiptobecubic> startling, that would be fabulous
14:08:59 <shapr> So now I only need software to get my smartclone working, and I don't want to use Python!
14:09:47 <alpounet> luite, haha, not gonna happen :p i was just curious if you could showcase ghcjs with my neural nets library. not yet apparently heh
14:10:03 <shapr> m3ga: oh hey!
14:10:44 <shapr> m3ga: Can I get a copy of your qemu patch?
14:11:02 <luite> alpounet: does it use algorithms that are hard to implement in haskell without hmatrix? just backprop right, without ad?
14:11:19 <startling> hiptobecubic: now I just need a decent web client that isn't PHP. :(
14:11:50 <luite> http-conduit?
14:11:54 <alpounet> luite, without ad indeed, and i only have vector, base, hmatrix and mwc-random as dependencies (and their dependencies), but that's really reasonable
14:12:03 <luite> ah
14:12:07 <luite> vector should be doable
14:12:15 <startling> luite: heh, I mean for mpd.
14:12:52 <luite> alpounet: arrays are implemented with typed javascript arrays
14:12:56 <luite> you need DataView
14:13:17 <luite> vector should be mostly supported already, might need a few extra ffi things
14:13:42 <Moggle> Anyone here know of any good libraries for making a simple GUI that displays a webpage? I was going to look into webkit-haskell and maybe finding some way to put it in gtk2hs
14:14:08 <hiptobecubic> startling, why a webclient?
14:14:21 <startling> hiptobecubic, for non-nerd friends
14:14:27 <hiptobecubic> ah right
14:14:34 <startling> :)
14:14:38 <Moggle> startling: yeah pretty much that
14:14:40 <Moggle> :P
14:15:04 <alpounet> luite, well i won't work on that now :P if there was a way it could work almost out of the box, i would have tried, but that looks enough time consuming that it could make me late with other stuffs
14:15:05 <shapr> startling: I got mpd working on my Pi right away, was nice.
14:15:32 <Moggle> strictly speaking I don't need to make it display a web page, but frankly that's the fastest way to get something usable up for what I want
14:15:32 <startling> shapr: how's the analog output?
14:15:50 <Moggle> well, I shall delve deep into the depths of webkit!
14:16:13 <shapr> startling: It was a bit crackly with Occidentalis, I haven't tried with Raspbian, but I can certainly try it right now.
14:16:34 <luite> alpounet: yeah i want to make some demos in a few weeks, but i need to fix more low level bugs first
14:16:57 <startling> shapr: much appreciated.
14:17:12 <startling> mostly I'm worried the amplifier will be terrible.
14:17:21 <luite> alpounet: trying to get the test suite working (which by itself requires a lot of stuff to work right, the whole IO library with buffering, text encoding, iconv emulation etc)
14:17:30 <shapr> I've heard that Raspbian is better because it's tuned for armhf, lemme check.
14:17:56 <luite> atm i can only putStrLn one thing with the new code generator
14:18:02 <luite> after that something is wrong
14:18:18 <shapr> w00t! imapget cabal install'd !
14:18:20 * shapr dances cheerfully
14:18:28 <luite> but i need more coffee to debug this i think...
14:18:57 <luite> probably a large mug of espresso
14:20:18 <alpounet> luite, which test suite? ghc's?!
14:20:25 <parcs> my raspberry pi is still sitting in my drawer, neglected
14:20:32 <static_void> ill take it :P
14:20:47 <luite> alpounet: selected tests from ghc's, fay's and my own :)
14:20:53 <shapr> parcs: whaat?
14:21:22 <alpounet> luite, oh ok, how's it going? how much of it is passing?
14:21:36 <shapr> parcs: Do you have one of the early 256MB models? or one of the more recent 512MB models?
14:21:45 <luite> alpounet: not much yet, but mainly due to bugs that affect stdout
14:21:46 <parcs> shapr: early :(
14:21:58 <static_void> Has anyone here read The Haskell Road To Math, Logic, Programming?  What sort of level is it?  I already have basic discrete maths, but I'm intrigued by Haskell, having enjoyed the functional bits of Ruby.
14:22:02 <shapr> parcs: Still nifty hardware, I can suggest lots of uses :-)
14:22:13 <luite> alpounet: stdout is not yet flushed correctly, and writing stdout multiple times crashes with an unexpected closure type error
14:22:14 <hiptobecubic> static_void, it is *terrible* for learning haskell
14:22:27 <hiptobecubic> static_void, but it is an interesting book otherwise
14:22:28 <static_void> okay, I'll read Learn You A Haskell first
14:22:31 <hiptobecubic> yes
14:22:35 <hiptobecubic> in fact
14:22:42 <hiptobecubic> you will be hopelessly lost otherwise
14:22:49 <static_void> ha, yeah
14:22:54 <static_void> It looks pretty arcane so far
14:23:02 <static_void> but that what seems fun
14:23:06 <luite> alpounet: this is with the gen2 new code generator btw, the trampoline generator could probably pass more but i haven't tried that yet
14:23:22 <plhk> hiptobecubic: is it any good for learning math and logic?
14:23:22 <startling> hiptobecubic: is useful if I know haskell already?
14:23:25 <startling> heh
14:23:41 <hiptobecubic> I took the course that the author gives using the book, thank god I already knew haskell. everyone else was just hopelessly lost
14:23:42 <static_void> plhk:  Discrete Mathematics for New Technology is really good
14:24:09 <parcs> shapr: the biggest obstacle is my lack of anything that accepts hdmi input
14:24:20 <ijp> hiptobecubic: that book has been stuck in my toread pile for months now :(
14:24:27 <hiptobecubic> plhk, it's not bad. It is an ok introduction to proof writing and prepositional logic maybe
14:24:30 <parcs> shapr: so without some kind of monitor i can't really do anything with it
14:24:43 <monochrom> um, propositional logic!
14:24:49 <hiptobecubic> oops
14:24:52 <hiptobecubic> yes
14:24:58 <monochrom> (prepositional logic is an oxymoron :) )
14:25:02 <hiptobecubic> not prepositions :)
14:25:04 <shapr> parcs: Put the latest version of Raspbian onto an SDHC card, plug it into the network. ssh and link-local dns are enabled by default. (I'm almost certain that's true)
14:25:17 <static_void> hiptobecubic:  is it worth reading even if I have basic discrete maths under my belt?  I thought maybe I could get another angle to look at it.  I enjoy it at least
14:25:21 <parcs> shapr: ooo, handy
14:25:34 <shapr> parcs: I use byobu for console stuff and ssh -X -C for anything X
14:25:54 <hiptobecubic> static_void, if you've never had a symbolic logic course or if you did, and enjoyed it, then yes
14:25:55 <parcs> oh wait, that's problem #2: i don't have an SDHC card :) i guess i'll order one right now!
14:25:56 <startling> parcs: doesn't it have analog video out?
14:26:00 <monochrom> I suppose the book's goal is math, logic, and programming, but not haskell
14:26:17 <parcs> startling: not sure, actually..
14:26:21 <shapr> parcs: As startling said, you can plug it into any analog TV
14:26:25 <static_void> Thanks, guys
14:26:39 <parcs> oh it's that big yellow connector? cool
14:26:42 <startling> yeah.
14:26:46 <hiptobecubic> monochrom, which is a bit strange, because (esp when it was written) there weren't a huge number of people that needed the former if they had the latter i think
14:26:51 <monochrom> yikes, analog TV. this is Apple II all over again
14:26:52 <startling> the one you plug your n64 into on the tv
14:27:10 <hiptobecubic> composite?
14:27:11 <shapr> monochrom: or you can use HDMI
14:27:18 <elliott> surely it'll go into anything with a VGA input
14:29:49 <monochrom> audience expectation is important. talking math, logic, programming, and haskell to a bunch who just want programming is a lost cause
14:30:13 <static_void> Well I
14:30:19 <hiptobecubic> well the book title isn't misleading in that sense
14:30:58 <hiptobecubic> but the course was called "Software Specification and Testing". People were pretty upset when it was 75% over and we had spent the entire time talking about transitive closures
14:31:09 <static_void> Well Im not a currently-enrolled CS student -- learning by books -- but I enjoyed the courses I took.  I mostly wanna program, but the theory is cool enough to look into.
14:31:33 <static_void> ah yeah that sounds weak
14:31:47 <monochrom> ok, but did the students understand transitive closures quickly?
14:31:58 <hiptobecubic> those that cared
14:32:06 <static_void> ^
14:32:26 <monochrom> how many?
14:32:29 <hiptobecubic> static_void, like I said. If you want to learn about logic then go for it. If you want to learn how to write haskell programs then put it back on the shelf
14:32:53 <hiptobecubic> monochrom, how many cared?
14:33:04 <static_void> hiptobecubic:  I do suppose I might be spreading myself thin.  I'll take that advice.  Thanks
14:33:08 <monochrom> right. actually, how many understood transitive closure quickly
14:33:52 <static_void> I think more people could program, learn math, etc, but they don't all try equally hard.  A class that holds hands doesn't deserve to be a college class
14:34:32 * monochrom would start with testing and gradually escalate to specifications and math. piaget's theory, concrete before abstract, special before general. test cases are special specifications
14:35:11 <kqr> is there a better way to write f = getLine >>= putStrLn . show . parse >> f
14:35:21 <kqr> i tried with interact, but that doesn't seem to do getLine but getContents
14:35:23 <hiptobecubic> It's hard to say. We talked about it and had some practical sessions, but in the end it turned into one of those courses where no one is satisfied. The people who want to plow through and get to meaty topics are SOL and the people who wanted to learn about whatever it was that they envisioned from the title "Software Testing and Specification" were also SOL
14:36:05 <hiptobecubic> I remember at some point I was turning the assignments into code golf
14:36:11 <static_void> lol
14:36:14 <monochrom> typical mathematician mindset. thinking that abstract before concrete, general before special works
14:36:31 <static_void> I dunno math can help understanding
14:36:34 <static_void> you dont NEED it
14:36:35 <static_void> sure
14:36:56 <monochrom> math can help understanding. teach it after concrete experience, not before
14:37:09 <hiptobecubic> the professor is a logician. The students were all (except for me) part of the Software Engineering master program
14:37:10 <static_void> yeah thats a better learning model
14:37:35 <parcs> kqr: interact (unlines . map (show . parse) . lines)
14:37:39 <static_void> well I know from tutoring my niece teaching ONE person is hard
14:37:45 <hiptobecubic> yes
14:37:46 <static_void> A whole class must be excrutiating
14:37:52 <kqr> parcs, huh i thought i tried with that
14:37:56 <kqr> parcs, i guess i'll try again
14:38:01 <kqr> parcs, would you say it's better, though?
14:38:05 <hiptobecubic> a whole class that is openly frustrated with the direction the course is going
14:38:12 <mikeplus64> kqr: your one is fine
14:38:12 <hiptobecubic> it was pretty doomed
14:38:13 <Saizan> i like the "example of use; definition; more examples" order
14:38:36 <mikeplus64> kqr: you can also do forever $ getLine >>= print . show
14:38:42 <kqr> parcs, it sure worked
14:38:47 <kqr> mikeplus64, that one was nice
14:38:58 <mikeplus64> i mean print . parse
14:39:06 <hiptobecubic> but there were some really huge flaws in the delivery of that course
14:39:10 <static_void> Saizan:  a good compromise, 'cause it can't really be taught linearly either way.  Too much interdepence
14:39:18 <monochrom> the math enthusiast's ideal, ergonomically disastrous K-12-PhD curriculum order: category theory in kindergarten, universal algebra in grades 1-12, rings and fields in undergrad, finally real numbers and natural numbers in PhD
14:39:22 <static_void> Do y'all use haskell for everyday scripting, video games, ..., or what?
14:39:35 <monochrom> at postdoc, you finally know how to do 231*5
14:39:45 <monochrom> NOT GOING TO WORK
14:40:12 <monochrom> there is a reason you played with a few lego bricks before you learned a few natural numbers
14:40:29 <hiptobecubic> like no explanation whatsoever about monads, but having several assignments requiring at least an understanding of do notation and IO
14:40:54 <static_void> monochrom:  may not be practical, but I think some abstract math is actually easier than arithmetic.  Venn Diagrams weren't so bad.  I think geometry before algebra would be a good idea.
14:40:54 <hiptobecubic> so you have people that are getting angry because "return doesn't work", etc
14:41:20 <static_void> monochrom:  the beauty of math isnt doing arithmetic:  it's discovery and I want SOME proof even for kids
14:41:33 <static_void> just to see who's interested
14:42:06 <monochrom> if you want a geometry version of the story, I can do that too
14:42:10 <hiptobecubic> that's a key point
14:42:38 <hiptobecubic> i think it's important to dump this stuff on the table early because *some* kids will love it and go off on their own with it
14:42:50 <static_void> Geometry is more tangible and full of a history of great proof
14:42:51 <hiptobecubic> the ones that don't like aren't forced into it
14:43:06 <monochrom> category theory in kindergarten, homotopy in grades 1-12, topology in undergrad, differential geometry in PhD
14:43:17 <static_void> hiptobecubic:  I would say my entire public schooling taught me pretty much nothing about how computers actually work
14:43:19 <monochrom> at postdoc, you finally look at triangles
14:43:35 <static_void> so it took me a while to find out I liked programming
14:43:47 <hiptobecubic> but it's a crime to have a 12 year old that would love to learn about sets and groups but doesn't know they exist
14:43:47 <ijp> monochrom: when do I get to learn about circles?
14:44:02 <monochrom> concurrently with triangles
14:44:15 <static_void> monochrom:  is there really that much to homotopy :O
14:44:40 <monochrom> I don't know. but it is abstract. doing abstract things early is the problem
14:44:40 <static_void> then again we learn arithmetic/algebra over the same time frame
14:45:05 <static_void> I still disagree with your premise to some extent
14:45:12 <static_void> I think the abstract can come before the concrete
14:45:26 <static_void> Someone earlier said the best way is example, definition, detailed examples
14:46:37 <shapr> startling: Raspberry Pi mpd output is really quiet, but no longer stuttering as it was with occidentalis. I had to unmute and turn up the volume with alsamixer too
14:46:40 <static_void> I think I'll reprioritize learning more languages before theory though, thanks to the room's advice
14:47:09 <static_void> shapr:  what're you doing with the pi?
14:47:11 <Saizan> yeah, you're not going to get the definition immediately, but it's nice to be able to check the examples against it
14:47:15 <shapr> startling: it's perfectly fine with these sennheiser headphones, but probably wouldn't feed unpowered desktop speakers with any audible volume
14:47:24 <shapr> static_void: Haskell development!
14:47:43 <static_void> I'm just curious what people use haskell ffor
14:48:01 <luite> <- for making websites
14:48:03 <startling> shapr: cool. :)
14:48:09 <shapr> I'm using Haskell to build a smart without the phone replacement on my Raspberry Pi.
14:48:17 <static_void> cool
14:48:35 <shapr> static_void: Do you have a Pi also?
14:48:47 <static_void> nah, eventually maybe, they're not too expensive
14:48:53 <static_void> I wanna hack away at one
14:49:05 <stepkut> shapr: I'll donate the rest if you get hOp to work on the RPi
14:49:06 <static_void> I have no use for it except that it's cool
14:49:17 <monochrom> "examples, definition, more examples" works iff the first "examples" are understood by the audience to begin with. and what examples do they understand? those that talk about concrete things they have seen before. therefore, it is still concrete before abstract, special before general
14:49:23 <shapr> stepkut: uh... that's actually a really amazing and awesome idea, but also months of work.
14:49:40 <monochrom> and the second "more examples" must wait later because clearly they talk about new, more abstract things
14:49:45 <shapr> stepkut: I think halvm on the Pi is a more attainable goal.
14:50:01 <Saizan> monochrom: "example"
14:50:02 <startling> what's h0p?
14:50:53 <static_void> monochrom:  it's really complex.  Like I said, I've tried tutoring basic division and it's hard.  I've tried learning things by books and wikipedia and found myself jumping back and forth.  Learning and teaching are both difficult without some framework, but what that framework is....?  People are still working on it.
14:51:40 <static_void> Basically I think the people who are willing to put in the work will get it.  And so we might as well expose concepts to kids to test the waters
14:52:08 <shapr> startling: precursor to House and LightHouse: http://www.haskell.org/haskellwiki/Applications_and_libraries/Operating_system
14:52:13 <startling> ah
14:52:16 <Wizek> I have this: "isPalindrome :: Eq a => [a] -> Bool". How can I make it accept numbers too?
14:52:36 <shapr> startling: Jeremy Bobbio and Sebastien Carlier got GHC running on the bare metal, and presented it at EuroHaskell 2003
14:52:50 <static_void> link?
14:53:01 <static_void> I might start a rPi VM
14:53:07 <shapr> or maybe that was EuroHaskell 2004?
14:53:08 <monochrom> "willing to put in the work" means: if the teacher uses a wrong order, the student does the work of finding a right order
14:53:44 <shapr> static_void: Haskell doesn't run on the bare metal of the Raspberry Pi, only on x86
14:54:03 <sipa> ehhh what?
14:54:03 <lambdabot> sipa: You have 1 new message. '/msg lambdabot @messages' to read it.
14:54:05 <nathanfh> Wizek: if it was me, I'd define a function f :: Num a => a => [a], then have a separate numericPalindrome = isPalindrome . f
14:54:26 <static_void> shapr:  oh that's better anywa.  VM on x86.  I'll need x86.  d'oh
14:54:29 <hpc> only an x86 cpu has enough RAM buckets to store all the wifis and the gigglybits
14:54:38 <shapr> startling: Even more amusing, EuroHaskell 2004 was a joke conference until somebody got confused and submitted a paper. Then I had to find a venue.
14:54:55 <static_void> Oh you hosted?
14:55:00 <elliott> shapr: that's amazing
14:55:21 <Wizek> nathanfh: Can't the compiler decide which one to call based on the types? With something like pattern matching?
14:55:33 <shapr> static_void: chalmers university in Sweden hosted
14:55:48 <elliott> Wizek: You can overload isPalindrome with a typeclass, but I would strongly recommend not doing so.
14:55:53 <elliott> It's not idiomatic for this
14:56:01 <startling> shapr: haha
14:56:41 <shapr> Chalmers were hosting EuroPython 2004, so I started joking about EuroHaskell 2004 happening right afterwards. But really I was going to visit Anders Carlsson and sit on his floor and talk about Haskell.
14:57:03 <static_void> monochrom:  the right order for one person isn't the same for the other 24.  Another issue is that once you understand something, it seems easy for you, so you can have a hard time relating to the kids.
14:57:07 <Wizek> elliott: what do you mean by "not idiomatic"?
14:57:18 <monochrom> but there are orders wrong for all 25
14:57:39 <static_void> true, but I don't wanna uproot education
14:57:49 <static_void> Just sprinkle in hints of what computers actually do
14:57:56 <monochrom> there are also orders right for a few and still isn't too bad for the rest
14:57:59 <static_void> We teach our kids calculus, which is arguable not useful
14:58:04 <static_void> for CS
14:58:11 <static_void> it's an industrial age mindset
14:58:12 <elliott> Wizek: I mean it's considered bad style; it's not really what typeclasses are for. It'll also be more limited (you can't work with all future Num instances upfront without overlapping+incoherent instances, which are incredibly evil).
14:58:19 <elliott> Wizek: in Haskell it's best to be explicit about these things.
14:58:25 <elliott> So, two different functions for two different purposes.
14:59:20 <static_void> here's what we do:  tear out all the content of columbus and replace it with a footnote.  Add in compsci for kids.
14:59:34 <static_void> I still remember that 1492 rhyme
15:02:21 <shapr> stepkut: Do you think HaLVM is doable on ARM?
15:09:00 <Wizek> elliott: I've not yet learned about the solution you propose. But I don't see why this wouldn't be the same thing. Anyways, I'm going this way: "let p :: Show a => a -> Bool; p = isPalindrome.show". Why won't this work without the type declaration?
15:09:21 <zomg> Oh damnit, why doesn't Text.Parsec.Token export the functions for parsing string literals..
15:09:50 <zomg> All I want to do is use ' instead of " for the string and as far as I can tell now I need to redeclare all those functions myself just to make sure it behaves sanely
15:09:54 <parcs> Wizek: try 'let p x = isPalindrome (show x)'
15:10:14 <elliott> Wizek: Monomorphism restriction.
15:10:17 <elliott> It's kind of complicated.
15:10:36 <elliott> that function is a horrible abuse of Show, btw, and you shouldn't use it in any kind of production setting :P
15:10:50 <Wizek> What should I use then?
15:11:20 <elliott> I'd define a separate function for palindromic numbers
15:11:54 <Wizek> (This is the only fn I know of which turns all kind of numbers into strings)
15:11:58 <roconnor> how come getPositive isn't exported from Test.QuickCheck.Modifiers?
15:12:14 <thetallguy1> edwardk: http://comonad.com/reader/2011/free-monads-for-less/ asserts that hackage free is obsolete, but it seems current, so...you changed your mind?
15:12:19 <Wizek> elliott: You mean you woldn't build on the existing one which takes a list?
15:12:49 <tom22931> http://hpaste.org/80473 doesn't compile, and instead suffers from conflicting definitions. Why isn't pattern matching smart enough to handle that? I realise I can correctly implement 'equals' using guards (for example).
15:13:08 <elliott> Wizek: I probably would.
15:13:10 <elliott> but I wouldn't use show :)
15:13:16 <dawesbr> Hello #haskell, I'm having problem with some Haskell Functional Programming revision, anyone think they can lend me a hand on stuff to do with foldr and fusion laws?
15:13:45 <tom22931> Is there any (ideally newbie-friendly!) documentation/paper which would explain the limits of haskell's pattern matching?
15:13:46 <alpounet> sure, just ask your question(s) :)
15:14:22 <cmccann> tom22931: it's not prolog pattern matching for one thing
15:14:25 <dawesbr> One of the past papers I'm revising from has, "Using the fusion law for foldr, prove that foldr f e (xs++ys) = foldr f (foldr f e ys) xs, for all lists xs and ys"
15:14:34 <dawesbr> it's simple by induction, but I don't see how the fusion law helps
15:14:34 <Wizek> elliott what would you use instead of show that turns any Num into String?
15:14:59 <cmccann> tom22931: it just binds identifiers and distinguishes constructors, it doesn't do anything fancy like check for equality like you were hoping for
15:15:10 <sclv> also, logically, you're *defining* equality
15:15:13 <dawesbr> (fusion law we're given is f . foldr g a = foldr h b, where f a = b, f (g x y) = h x (f y), f is strict)
15:15:29 <sclv> you can't define equality only by relying on equality already being defined
15:15:38 <elliott> Wizek: I wouldn't turn it into a String. your function works for any list of Eq
15:15:40 <sclv> (at least not without some inductive indirection, etc.)
15:15:52 <cmccann> tom22931: you can use boolean guards e.g. "foo x y | x == y = ..." but that would obviously be somewhat redundant in this case
15:16:14 <cmccann> might as well just define "equal = (==)" at that point
15:16:16 <Wizek> ah, that is right
15:16:52 <parcs> foo x ((==x) -> True)
15:16:53 <tom22931> sclv: Sure, this was a pathological example meant to be the smallest thing I could think of to produce the error where I'd prefer there wasn't an error.
15:16:56 <edwardk> thetallguy1: yeah i split it back there
15:17:18 <thetallguy1> edwardk: thanks, just wanted to make sure I was in the right place.
15:17:20 <sclv> anyway, yes, the point is pattern matching just names and deconstructs
15:17:29 <alpounet> dawesbr, figure out what f is in your case
15:17:37 <tom22931> cmccann: I see. Okay, "it just binds identifiers and distinguishes constructors" was what I was after. Thanks.
15:17:42 <tom22931> sclv: too ^^. :)
15:18:01 <elliott> Wizek: in particular, I would probably write digits :: Integral a => a -> [a]
15:18:10 <dawesbr> alpounet, I that's the trouble
15:18:17 <elliott> and then I might not even bother defining the version for integral numbers -- I'd just do palindromic (digits n)
15:18:19 <dawesbr> my closest attempt has f as foldr f e
15:18:30 <thetallguy1> tom22931: I thought about this a few years back and floated a question on the difference, the answer came back from SM, pattern matching is the primitive, equality defined in terms of it.
15:18:54 <dawesbr> It didn't work out in the end though, I can't seem to find a correct f etc.
15:19:38 <alpounet> dawesbr, so, you start by foldr f e (xs++ys) = foldr f (foldr f e ys) xs. now, try to remove xs and ys from that equation, introducing the composition of the right functions
15:19:47 <alpounet> (eta-reduce)
15:20:55 <alpounet> because if we want it to look like the fusion rule for folder, it'll help make it look like it to remove the lists
15:20:57 <hiptobecubic> @pl \xs ys -> foldr f (foldr f e ys) xs
15:20:57 <lambdabot> flip (foldr f . foldr f e)
15:21:49 <alpounet> oh well, simpler now :]
15:22:50 <dawesbr> so flip (foldr f . foldr f e) xs ys = foldr f (foldr f e ys) xs, so STP foldr f e (xs++ys) = foldr f . (foldr f e ys) xs ?
15:22:53 <Cale> OT: This is super-cute: http://acko.net/blog/how-to-fold-a-julia-fractal/
15:23:16 <Cale> (be sure to click the arrow buttons on the visuals :)
15:24:10 <dawesbr> hm no sorry I think I've done something wrong there
15:25:29 <roconnor> is there a non-IO test functions somewhere in QuickCheck?
15:27:54 <Cale> roconnor: In general, because properties can involve IO, it's not quite possible, but you might just be looking for unGen
15:29:49 <niteria> what's the relation between functors and homomorphisms?
15:30:06 <roconnor> how do I make properties that use IO?
15:30:24 <dawesbr> I'm being pretty dense I'm afraid. So flip (foldr f . foldr f e) xs ys = foldr f (foldr f e ys) xs, so I suppose it's best consider foldr f . foldr f e
15:31:23 <dawesbr> in which case, f a = b in the fusion law, so this must fuse to something of the form foldr h (foldr f e)?
15:32:17 <roconnor> hmm monadicIO
15:32:47 <dawesbr> which means h must be of a type [c]->([a]->b)->([a]->b)?
15:33:02 <dawesbr> sorry, c not [c]
15:33:36 <dawesbr> I'm running myself into the ground here
15:37:35 <nathanfh> is there any reason why Data.List doesn't define unfoldl?
15:37:42 <nathanfh> Or is there just not much call for it?
15:39:19 <Nereid> niteria: a functor is a homomorphism of categories.
15:39:21 <Nereid> :c
15:40:31 <fmap> nathanfh: what's the point?
15:40:45 <dawesbr> alpounet, I'm really struggling here
15:41:03 <dawesbr> so foldr f (foldr f e ys) xs = flip (foldr f . foldr f e) xs ys
15:41:34 <dawesbr> flip (foldr f . foldr f e) xs ys = (foldr f . foldr f e) ys xs
15:41:40 <nathanfh> fmap: I was sketching out a digits function because of Wizek's question, and my first instinct was basically built out of quotRem and unfoldl, which I just assumed existed.
15:41:46 <dawesbr> and (foldr f . foldr f e) is of a fusion law form
15:42:06 <nathanfh> Using unfoldr and then reversing the results is fine, I was just curious as to why Data.List only defines one.
15:42:10 <dawesbr> considering the fusion law as f . foldr g a = foldr h (f a)
15:42:30 <dawesbr> then foldr f . foldr f e = foldr h (foldr f e) for some h
15:43:03 <dawesbr> h must satisfy h x (f y) = f (g x y), which in this case is h x (foldr f y) = foldr f (f x y)
15:43:50 <dawesbr> Not sure where to go here
15:43:56 <dawesbr> f x y = foldr f y x?
15:44:12 <dawesbr> so h x (foldr f y) = foldr f (foldr f y x)
15:44:37 <dawesbr> h = foldr f . flip?
15:44:51 <alpounet> don't forget about the ++ you had between xs and ys
15:45:10 <dawesbr> Well that's the thing is I also don't see where that gets introduced
15:45:32 <dawesbr> in h?
15:49:24 <dawesbr> h = foldr f . (flip id)?
15:50:24 <luite> Cale: whoah great post. and very cool that the software for making those diagrams is available. can't wait to hook it up with haskell with some ghcjs
15:50:55 <sipa> what browser do you use to watch it?
15:51:01 <dawesbr> alpounet, I flat out do not see where ++ gets introduced :(
15:51:09 <luite> i used safari, after chrome decided not to show webgl things
15:51:46 <sipa> neither chromium or ff works here
15:51:53 <alpounet> safari here too
15:51:57 <alpounet> works fine
15:52:34 <alpounet> dawesbr, I think you should now start back with the original equation
15:52:38 <alpounet> (the one with ++)
15:52:48 <alpounet> and try to reduce it to a form where the fusion rule is applicable
15:55:21 <alpounet> (sorry not to be more helpful, i'm working on something so can't do all the stuffs with you)
15:55:38 <shapr> luite: What's the post?
15:56:08 <luite> shapr:  00:22 < Cale> OT: This is super-cute: http://acko.net/blog/how-to-fold-a-julia-fractal/
15:56:11 <dawesbr> AH! I GOT IT!
15:56:15 <dawesbr> jeez
15:56:20 <dawesbr> that is not something I expected
15:56:37 <dawesbr> rewrite xs++ys as foldr : ys xs
15:56:40 <dawesbr> neat
15:58:14 <shapr> luite: I bet that guy never has any trouble getting jobs!
16:04:55 <alpounet> dawesbr, good job!
16:08:20 * hackagebot linear 0.5 - Linear Algebra  http://hackage.haskell.org/package/linear-0.5 (EdwardKmett)
16:09:02 <dawesbr> alpounet, thanks for your help! fusion laws seem quite important to my course, but weren't in the lectures at all and only mentioned briefly in a problem sheet - now I see it's all about rewriting other functions as folds, it's pretty simple!
16:09:34 <johnw> edwardk: does your linear library deal with vector spaces?
16:09:54 <alpounet> dawesbr, well, it goes beyond that, but you should read the stream fusion paper if it catches your interest :) out of interest, where are you studying?
16:10:06 <edwardk> johnw: basically its about free vector spaces using lenses as the representation of the basis
16:10:17 <johnw> what is a "free" vector space?
16:10:32 <cmccann> one you don't have to pay for
16:10:46 <edwardk> e -> r   for some basis e.
16:11:13 <edwardk> data C = E | I   could be a perfectly cromulent basis for the complex numbers.
16:11:14 <johnw> so each polynomial term is just a function on a constant?
16:11:18 <edwardk> C -> Double
16:11:45 <cmccann> seems like a better question would be what a vector space that isn't free looks like
16:11:48 <edwardk> now, a representable Functor is one that is isomorphic to a function from some value x.    f a  ~ x -> a   f is 'represented' by x.
16:11:54 <johnw> cmccann: good point
16:12:00 <edwardk> so linear uses representable functors for all of its vector spaces
16:12:26 <edwardk> every vector space is free. this is a classical result though and may not hold in a constructive setting
16:12:35 <dawesbr> alpounet, Oxford
16:12:38 <johnw> edwardk: so, if I wanted to define my own vector space, which type/class in your library do I start with?
16:12:55 <cmccann> edwardk: ah well that explains why I was having a hard time imagining a non-free one
16:13:09 <edwardk> basically you use Representable from lens 3.7 as the core of it
16:13:33 <edwardk> cmccann: otoh, there are non-free _modules_ over rings so you can find plenty of those
16:13:34 <kqr> is there any particular reason not to use >>> from control.arrow to make the data flow from left to right instead of right to left? (besides >>> being horribly clunky to write and read)
16:13:51 <edwardk> kqr: mostly clunkiness
16:14:07 <kqr> i find it a little sad that >>> got the clunky operator and . got the neat one
16:14:08 <edwardk> that and the style nazis will attack
16:14:32 <edwardk> i usually try to hold off the style nazis with performance ninjas
16:14:36 <kqr> haha
16:14:55 <edwardk> but now that shachaf has sworn off looking at core i'm running out of ninjas
16:15:21 <kqr> it just feels so much neater to have my data flow from left to right than sort of "backwards"
16:15:32 <kqr> especially in nested expressions
16:15:44 <AfC> "sworn off looking at core" heh
16:15:51 <LambdaDusk> hi I wanna install cabal-install but the bootstrap.sh stops at Data.Text.Lazy and then ends with "Building the text package failed"... can anyone help?
16:16:00 <kqr> which mostly read from left to right, until the composed parts, where it temporarily goes right to left
16:16:09 <edwardk> :t (&)
16:16:11 <lambdabot> a -> (a -> b) -> b
16:16:33 <edwardk> > ("hello","world") & _2 .~ "!!!" & _1.element 0 .~ 'j'
16:16:36 <lambdabot>   ("jello","!!!")
16:16:42 <edwardk> you can also turn things around that way
16:17:38 <kqr> :t (.~)
16:17:39 <lambdabot> Setting s t a b -> b -> s -> t
16:17:43 <kqr> woah
16:17:55 <kqr> but oh
16:17:58 <kqr> i get it
16:18:00 <kqr> yeah
16:18:45 <edwardk> > ("hello","world") & set _2 "!!!" & set (_1.element 0) 'j'
16:18:47 <lambdabot>   ("jello","!!!")
16:18:52 <fmap> 12 seconds to understand (.~)? I guess that's record now
16:18:54 <edwardk> that removes some of the infix noise ;)
16:19:03 <alpounet> LambdaDusk, is there a reason you're not installing platform right from the start instead of installing cabal-install by hand?
16:19:37 <kylcarte> :t (&)
16:19:38 <lambdabot> a -> (a -> b) -> b
16:19:59 <kylcarte> ah
16:20:15 <kqr> fmap, not really understand it in the sense of grokking it completely
16:20:25 <kqr> fmap, i just realised how it was used in this case and why it could be useful
16:20:38 <kqr> fmap, partly aided by me reading a similar discussion here a few months ago
16:22:31 <LambdaDusk> alpounet: GHC 7.6... I have it on my dev system so I thought I should have it on my target system, too
16:23:40 <drdo> Is there some class for things that can be unfolded?
16:25:34 <alpounet> LambdaDusk, alright, fair enough! Note that any cabal-install (one from a (earlier) haskell-platform install for example) can work. it'll just use the first GHC in your PATH by default, and you can specify other GHCs you have around through --with-ghc, and other ghc-pkg's with --with-hc-pkg or smith like that
16:25:43 <alpounet> no binary cabal-install for your platform though?
16:26:35 <alpounet> oh well no there aren't. so if you don't have another cabal-install around, yes you'll have to solve that issue. let's see..
16:26:40 <LambdaDusk> alpounet: It's some managed server, I have nothing I can't compile myself. And there's only one ghc on it anyway
16:27:32 <alpounet> LambdaDusk, ok, so what's the exact error it stops on? could you paste the log on hpaste or some similar site?
16:28:20 <alpounet> drdo, yes, http://hackage.haskell.org/package/unfoldable
16:29:10 <LambdaDusk> alpounet: There's no error: http://pastie.org/5651887
16:30:58 <LambdaDusk> alpounet:  it just... fails
16:31:05 <alpounet> LambdaDusk, uh.
16:32:47 <LambdaDusk> alpounet: ^^
16:33:05 <LambdaDusk> alpounet: To be honest I am stumped here
16:33:20 <LambdaDusk> I'll go with the haskell platform, I guess
16:33:43 <alpounet> LambdaDusk, that's not supposed to happen, wait :p
16:33:50 <drdo> alpounet: Indeed, i had found it
16:34:10 <drdo> Thank you
16:37:03 <LambdaDusk> alpounet: Trying with an earlier version. same result
16:37:53 <drdo> What's the purpose of those WrappedMonad and WrappedArrow newtypes?
16:38:08 <elliott> to give Arrow instances for monads
16:38:10 <elliott> and Monad instances for arrows
16:38:33 <drdo> elliott: How does it help?
16:38:50 <elliott> well, an instance ArrowLoop a => Monad (a ()) or whatever is not ok
16:39:03 <elliott> since the context is not looked at when resolving instances
16:39:06 <elliott> so you need wrappers
16:39:09 <alpounet> LambdaDusk, does it start with text or did you strip the rest away?
16:39:17 <drdo> I didn't follow
16:39:32 <elliott> how much do you know about typeclasses?
16:39:55 <drdo> This much | |?
16:39:56 <fmap> LambdaDusk: what's the error code?
16:40:38 <drdo> elliott: I'm not terribly familiar with the limits of the system
16:41:11 <LambdaDusk> alpounet: The others went through OK and then text failed, so I started again and it started at text
16:41:24 <LambdaDusk> fmap: there is no error code, see http://pastie.org/5651887
16:41:28 <alpounet> oh right.
16:41:29 <drdo> i.e. i don't know what ghc means when he starts talking about heads not being smaller or whatever it is
16:41:53 <drdo> Well, i do, it's obvious now that i said it
16:42:08 <drdo> Anyway, i'm going off the point
16:42:10 <alpounet> LambdaDusk, what if you do what the script does with text, but by hand? that is, fetch the tar archive of that precise version, unpack it, build the Setup.hs just like in the script, and call configure build etc
16:42:27 <roconnor> anyone good with Parsec?  I'm trying to get "sepBy" to parse an empty list
16:42:38 <alpounet> LambdaDusk, how much RAM does that machine have?
16:42:38 <roconnor> but clearly I'm doing it wrong
16:43:05 <roconnor> how does <|> work in parsec?
16:43:16 <roconnor> what has to happen in the first branch for the second to activate?
16:43:21 * hackagebot machines 0.2.3 - Networked stream transducers  http://hackage.haskell.org/package/machines-0.2.3 (EdwardKmett)
16:43:26 <byorgey> roconnor: it has to fail.
16:43:29 <drdo> a parse failure presumably
16:43:35 <byorgey> roconnor: but note that it doesn't backtrack.
16:43:44 <drdo> Yeah i was going to say that
16:43:44 <edwardk> roconnor: it has to fail without consuming input
16:43:50 <roconnor> byorgey: like fail fail?
16:43:54 <byorgey> roconnor: so if the first branch consumes some input and THEN fails, you're out of luck
16:44:02 <byorgey> roconnor: what other kind of fail is there? =)
16:44:09 <drdo> byorgey: without consuming :P
16:44:10 <roconnor> okay, how am I supposed to fail without looking ahead?
16:44:16 <edwardk> roconnor: use try
16:44:16 <drdo> No clue
16:44:19 <edwardk> try foo <|> bar
16:44:26 <drdo> Well, by cheating it seems
16:44:31 <edwardk> try will make failure that consumes input look like failure that didn't consume it
16:44:56 <edwardk> roconnor: the idea is you use try over smaller chunks though
16:45:00 <LambdaDusk> alpounet: I get this: http://pastie.org/private/fd4mcdyw5qyfjmimlj65a
16:45:28 <roconnor> try (many1 (noneOf " ]>"))
16:45:29 <edwardk> foo = try (figure out this is the right branch) *> keep going <|> other alternatives
16:45:39 <roconnor> is good?
16:45:40 <drdo> Not doing backtracking by default, i wonder how many hours were lost by users because of that
16:45:40 <edwardk> once you get past 'figure out this is the right branch' you are 'committed
16:46:10 <edwardk> in general if you use 'try' around a parser that consumes multiple characters you're doing it wrong
16:46:19 <edwardk> er not multiple characters, but is recursive like that
16:46:27 <glguy> drdo: It's about efficiency. It allows you to write fast parsers
16:46:40 <glguy> which don't hold on to the input stream any longer than necessary
16:46:45 <LambdaDusk> alpounet: about 12 GB
16:46:57 <edwardk> drdo: the alternative is holding onto a massive state of every possible way you can backtrack, it also has benefits for error reporting
16:47:01 <alpounet> uh, that's more than enough.
16:47:06 <drdo> I know
16:47:20 <roconnor> edwardk: how about (sepBy (try foo) (symbol ","))
16:47:33 <roconnor> okay to use sepBy I need to use something that does try
16:47:38 <alpounet> LambdaDusk, I think you should open an issue on 'cabal's issue tracker at github -- there definitely is something wrong, you may be able to track it down with strace and whatnot but the cabal guys will know better what to do, i'm afraid this isn't something i have ever seen
16:47:39 <drdo> That's why people came up with grammar based parsers
16:47:41 <roconnor> otherwise it is impossible to parse an empty list
16:47:50 <edwardk> roconnor: whats foo? generally foo should be trying for itself
16:47:50 <jfischoff> drdo: I think ReadP works differently
16:47:54 <drdo> And restricted ones at that
16:48:00 <drdo> To enable efficient implementation
16:48:09 <drdo> Parsec is about being nice to use
16:48:10 <roconnor> edwardk: foo is (many1 (noneOf " ]>"))
16:48:21 <roconnor> edwardk: ah
16:48:21 <LambdaDusk> alpounet: are you able to point me to their issue tracker and how to publish the the problem?
16:48:35 <jfischoff> drdo: actually I don't know
16:48:44 <drdo> jfischoff: I've never looked at ReadP
16:48:45 <edwardk> roconnor: the idea with try is you 'try just long enough to commit'
16:48:56 <edwardk> e.g. a keyword or two
16:48:59 <LambdaDusk> alpounet: I might suspect it's a problem in Text, rather
16:49:09 <roconnor> you want me to make foo = (:) <$> try (noneOf " ]>") <*> (many (noneOf " ]>"))
16:49:11 <edwardk> enough to make the grammar in the end look like it would be LL(1)'ish
16:49:16 <roconnor> ... that seems akward
16:49:21 <drdo> But, honestly, if you try to write a parser for haskell for example in parsec, you're gonna have a bad time
16:49:24 <drdo> I think
16:49:24 <edwardk> roconnor: no
16:49:36 <edwardk> but i suppose that would work
16:49:59 <drdo> It will either be very slow, or will be written in a very weird fashion for efficiency
16:50:10 <byorgey> LambdaDusk: http://github.com/haskell/cabal/issues
16:50:14 <roconnor> edwardk: okay i want to parse a list of non-empty-words not containing " ]>," that separated by commas.
16:50:15 <alpounet> LambdaDusk, https://github.com/haskell/cabal/issues -- (i think it requires you to have a github account) just create a new issue there, and explain the problem with as much information as you can (the machine it's run on, the OS, the ghc version, the link to the cabal you got, etc
16:50:23 <roconnor> how do I do this in parsec?
16:50:26 <edwardk> your many (noneOf "]>")   how is that supposed to end so you can parse the ","    ',' isn't ] or >
16:50:32 <glguy> drdo: fortunately there is a huge valley of usefulness between parsing Haskell and not parsing for parsec to exist in
16:50:46 <drdo> glguy, i completely agree
16:50:47 <roconnor> edwardk: I forgot the ,
16:51:23 <edwardk> if thats effectively your 'token' then thats fine. just be warned you'll hold onto the entire string so if that word is huge you have a problem ;)
16:51:57 <alpounet> LambdaDusk, text builds just fine with ghc 7.6.1, so I don't see how that could be possible...?
16:52:08 <roconnor> so the obvious code of (sepBy (many (noneOf " ]>,")) (symbol ",")) does not parse the empty string as the empty list
16:52:47 <roconnor> er
16:52:54 <roconnor> (sepBy (many1 (noneOf " ]>,")) (symbol ",")) does not parse the empty string as the empty list
16:53:25 <edwardk> what about just doing that as an extra case?
16:53:44 <LambdaDusk> alpounet: I will open the issue and we will see
16:53:58 <edwardk> many1 (noneOf "]>,")) `sepBy` symbol "," <|> pure []
16:54:15 <glguy> roconnor: It doesn't work because of your definition of "symbol"
16:54:28 <glguy> (I don't know if you've already covered this, I haven't been reading carefully)
16:55:27 <roconnor> glguy: what's wrong with symbol?
16:55:37 <roconnor> this is the example given in the Parsec docs
16:55:52 <glguy> roconnor: My reasoning is that that code works fine when symbol is replaced with "string" for parsing the "" to []
16:56:13 <roconnor> "string" ?
16:56:29 <glguy> :t string
16:56:30 <lambdabot>     Not in scope: `string'
16:56:30 <lambdabot>     Perhaps you meant one of these:
16:56:30 <lambdabot>       `storing' (imported from Control.Lens),
16:56:42 <edwardk> roconnor: >>> parseTest (some (noneOf "]>,") `sepBy` symbol "," <|> pure []) ""
16:56:42 <edwardk> []
16:56:43 <glguy> Well, do that in your GHCi, lambdabot doesn't have Parsec :)
16:56:50 <edwardk> >>> parseTest (some (noneOf "]>,") `sepBy` symbol "," <|> pure []) "hello,world"
16:56:50 <edwardk> ["hello","world"]
16:57:10 <LambdaDusk> alpounet: Submitted the error, but with 500 open issues I am not confident on a quick resolve... will try haskell platform tomorrow
16:57:18 <glguy> Prelude Text.Parsec> parseTest (sepBy (many1 (noneOf " ]>,")) (string ",")) ""
16:57:18 <glguy> []
16:57:18 <glguy> Prelude Text.Parsec> parseTest (sepBy (many1 (noneOf " ]>,")) (string ",")) "hello,world"
16:57:19 <glguy> ["hello","world"]
16:57:23 <LambdaDusk> alpounet: But thanks for the help anyway
16:57:48 <edwardk> >>> parseTest (some (noneOf "]>,") `sepBy` symbol ",") ""
16:57:49 <edwardk> []
16:57:58 <edwardk> works with the trifecta symbol too ;)
16:58:36 <roconnor> what's the difference between (symbol ",") and (string ",")?
16:58:39 <alpounet> LambdaDusk, i'm really puzzled by this error, sorry i can't be more helpful. however there are quite a few people working on cabal so your issue will be seen and commented. if you stress out a bit the fact that it (apparently?) is for production etc, this may get more attention :P
16:59:18 <edwardk> symbol is a token parser so it looks for trailing whitespace
16:59:21 <monochrom> one difference: symbol "," eats trailing spaces
16:59:45 <LambdaDusk> alpounet: Production on a hobby project not yet written ^^ I can work with rails if this doesn't resolve either way
16:59:51 <monochrom> it may also check against "reserved operators" but I forgot
16:59:56 <roconnor> oh
17:00:02 <edwardk> >>> parseTest (some (noneOf "]>,") `sepBy` symbol ",") "hi, roconnor"
17:00:02 <edwardk> ["hi","roconnor"]
17:00:10 <edwardk> >>> parseTest (some (noneOf "]>,") `sepBy` string ",") "hi, roconnor"
17:00:10 <edwardk> ["hi"," roconnor"]
17:00:19 <roconnor> ah
17:00:31 <roconnor> I'm actually using (char ',')
17:00:33 <roconnor> opps
17:00:37 <alpounet> LambdaDusk, naaaah, don't: http://www.insinuator.net/2013/01/rails-yaml/ :p
17:00:44 <roconnor> oh I see where I'm going wrong
17:00:56 <kurtmedley> test
17:01:05 <roconnor> sorry I wasn't even parsing the empty string. I was parsing " ".
17:01:11 <roconnor> no wonder I was getting screwy results
17:01:18 <roconnor> sorry, sorry everyone
17:01:29 <edwardk> monochrom: nah the reserved operators are done by reservedOp
17:01:51 <edwardk> that checks for trailing characters in the operator set, etc.
17:01:58 <LambdaDusk> alpounet: Node. then
17:02:12 <LambdaDusk> alpounet: I will go rest, thanks for your help again
17:03:02 <alpounet> you're welcome
17:05:05 <roconnor> thanks everyone!
17:06:14 <hpaste> quest_5692 pasted “buildtree spot the problem?” at http://hpaste.org/80478
17:06:36 <quest_5692> hi, i wrote this code as practice, want to build a tree from a word
17:06:53 <quest_5692> the insert function looks fine to me but once i put it into use for buildtree
17:06:59 <quest_5692> it doesnt work, why :o
17:07:52 <quest_5692> BANANA = Node [("banana",Leaf 0), ("a",Node [("",Leaf 5),  ("na",Node [("",Leaf 3),   ("na",Leaf 1)])]), ("na",Node [("",Leaf 4), ("na",Leaf 2)])]
17:08:01 <quest_5692> this is the tree i want to build
17:09:39 <quest_5692> http://imgur.com/30THY
17:09:48 <quest_5692> illustration of my tree
17:18:44 <applicative> quest_5692: were you thinking you would use Data.Tree?  You need something that labels nodes with a different type from leaves.
17:19:31 <quest_5692> applicative: hmm, im slowly finding the root of problem,
17:19:42 <quest_5692> i found out i havent put in base case
17:20:02 <quest_5692> put in already, but now when i use buildtree, it will just comeout as node [banana, leaf 0
17:20:26 <quest_5692> so somehow insert anana7 into [banana, leaf0] is not working
17:20:48 <hpaste> quest_5692 pasted “buildtree update 2” at http://hpaste.org/80479
17:26:33 <craigInnes> hi guys, i am trying to install the latest supported version of ghc for ubuntu, but cant seem to get it to work. I have followed the instructions on GHC's website by running apt-get update && apt-get install ghc6 ghc6-prof ghc6-doc, but my console says ghc is already up to date. However, when I check the version of GHC using --version, it comes up as 7.4.1
17:28:53 <fmap> craigInnes: and what version do you expect to get?
17:29:02 <craigInnes> 7.6.1?
17:29:11 <hpc> from ghc6?
17:29:30 <fmap> http://packages.ubuntu.com/search?keywords=ghc claims nothing better that 7.4.2 is available
17:29:51 <fmap> s/that/than/
17:29:58 <craigInnes> i am going on information from http://www.haskell.org/ghc/download_ghc_7_6_1
17:31:23 <hpc> craigInnes: #1 - ghc6 is the 6.x.x set of versions
17:31:44 <hpc> craigInnes: #2 - if you want to be the absolute latest ghc release, you never go with what apt has
17:31:52 <hpc> install the binary from here:
17:31:53 <hpc> @where ghc
17:31:53 <lambdabot> http://haskell.org/ghc
17:32:52 <craigInnes> hpc: Ah kk, i thought it was a bit funny installing ghc6. I was just blindly following the instructions on ghc's website (which does actually list installing those pacakges when you click the instructions for 7.6.1)
17:33:04 <hpc> heh
17:33:23 <hpc> it shouldn't be that hard
17:33:46 <hpc> apt-get the ghc dependencies (libgmp, probably zlib, one or two more)
17:34:04 <hpc> then download the right binary from the ghc website and ./configure && make install
17:34:21 <hpc> or however ghc does builds
17:34:39 <craigInnes> hpc: KK thanks. Will this clobber over any libraries etc i currently have installed with caball for my current version of ghc?
17:34:53 <hpc> no
17:35:04 <hpc> each ghc has a separate ghc-pkg
17:35:09 <craigInnes> hpc: I am new to this. I largely just want the latest ghc so I can use parts of the ghc api for a program i am writing. I dont know if this changes the situation
17:36:37 <hpc> ah
17:36:46 <hpc> so, blow away any ghc you have right now
17:36:52 <hpc> then go here: http://www.haskell.org/ghc/download_ghc_7_6_1#binaries
17:38:27 <hpc> or if you want to look like that guy from the matrix while ghc compiles, follow from here: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13 (stop once you have cabal installed)
17:40:06 <hpc> compiling ghc yourself is a good exercise, but not really necessary
17:40:27 <hpc> so, ghc provides the compiler ghc, ghci, runghc, runhaskell, and some other neat stuff
17:41:23 <hpc> it also gives ghc-pkg, which is somewhat of a package manager
17:41:35 <hpc> (more of a database, really)
17:42:02 <hpc> cabal is a build system that can download from hackage, compile, then register with ghc-pkg
17:42:33 <hpc> if you want to get fancy, there's also cabal-dev
17:42:35 <`nand`> runghc? Is that like runhaskell, but compiled?
17:42:38 * shapr gets FANCY!
17:42:40 <hpc> which is a sort of "sandbox cabal"
17:42:50 <hpc> `nand`: no; runhaskell is an alias for runghc
17:42:54 <`nand`> okay
17:42:59 <craigInnes> hpc: okay, so imma out myself as a total linux noob and say that i havent really installed from binaries before. When you say "blow away any ghc you have right now" could you elaborate?
17:43:02 <`nand`> if you want to get really fancy, you could try using Nix :P
17:43:03 <hpc> made generic so it can work with other compilers
17:43:14 <hpc> craigInnes: apt-get remove *whatever*
17:43:30 <hpc> in the specific case of your issues
17:43:57 <amindfv> craigInnes: if you want to be thorough: http://stackoverflow.com/questions/6884478/everywhere-that-ghc-haskell-platform-installs
17:45:00 <hpc> craigInnes: one possible issue you will hit has to do with libgmp
17:45:08 <hpc> iirc, something like it not finding libgmp.so.3
17:45:18 <hpc> or some silly numeric suffix
17:45:21 <craigInnes> hpc: I was assumping id probably just have to do sudo apt-get remove ghc?
17:45:33 <hpc> yeah
17:54:45 <craigInnes> hpc: okay so the issue i am running in to when I try to do ./configure is I get the error checking for path to top of build tree... ./configure: line 2121: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: No such file or directory
17:55:12 <craigInnes> however, from venturing down into utils/ghc-pwd/dist-install etc. it appears this file does actually exist
17:55:17 <craigInnes> so I am a little confused
17:55:24 <hpc> hmm
17:56:53 <parcs> craigInnes: your local gmp is too new
17:57:02 <hpc> haha
17:57:38 <craigInnes> parcs: What does that mean and how do I fix that fact?
17:58:56 <parcs> craigInnes: you should compile ghc 7.6 from source
18:00:49 <craigInnes> parcs: Okay thanks. Is that significantly more difficult than installing from the binary? I haven't installed any packages from source before
18:01:02 <hpc> nah, just slower
18:01:15 <hpc> or if there's errors, it takes longer to solve each one because of it
18:01:33 <hpc> but not harder from the perspective of thought effort
18:13:27 <drdo> elliott: By the way, i do understand things like Control.Arrow.Kleisli. The Wrapped ones aren't at all like that
18:14:27 <k0001> Is there any particular name for the type: Applicative m => a -> m b? I.e, just like a Kleisli arrow but for an Applicative instead of a Monad.
18:14:31 <drdo> Monad m => Functor (WrappedMonad m)
18:14:33 <drdo> Why not "Monad m ⇒ Functor m" ?
18:15:54 <drdo> k0001: What is that supposed to be?
18:16:21 <drdo> And i mean what's the intuitive idea behind that
18:16:52 <elliott> drdo: You can' write an instance Monad m => Functor m, because it means you can't have any other Functor instances.
18:17:00 <elliott> Instance resolution only looks at the bit after the =>
18:17:10 <elliott> So it says "instance Functor m (by the way, once you've chosen, you need Monad m)"
18:17:21 <drdo> I see
18:17:29 <drdo> I figured it would be something like that
18:17:46 <drdo> I battle with the type system quite often
18:18:09 <drdo> Is there no extension to allow stuff like that though?
18:18:16 <drdo> OverlappingInstances?
18:18:47 <elliott> You can use OverlappingInstances and IncoherentInstances and stuff and it'll still not work properly :)
18:18:55 <elliott> It's a fundamental tradeoff of the typeclass system.
18:18:57 <drdo> What is the actual technical difficulty?
18:19:06 <cmccann> the open world assumption
18:19:35 <cmccann> the compiler works under the idea that you could always add new instances in the future
18:19:43 <k0001> drdo: I'm just wondering if I can give some name to a function like (\a -> pure (a + 1))
18:19:59 <drdo> k0001: We give names to patterns that are cool
18:20:03 <drdo> Why is that cool?
18:20:08 <cmccann> most of the weird limitations of instance resolution come down to that feature of type classes
18:20:30 <drdo> cmccann: What do you mean "the future" ?
18:20:58 <k0001> drdo: because it's the type of the first argument to 'Data.Traversable.traverse'
18:21:00 <drdo> Oh please don't tell me it's about compiling modules separately
18:21:09 <drdo> And not wanting to look at everything
18:21:09 <cmccann> any code that GHC isn't looking at when it's making decisions
18:21:38 <cmccann> including other modules being compiled, or modules later importing the one being compiled, or whatever else
18:21:55 <drdo> So basically it's a made up problem
18:22:04 <cmccann> no
18:22:33 <drdo> Hmm?
18:22:38 <cmccann> it's a wanting code to have a consistent meaning problem
18:22:51 <drdo> What do you mean?
18:23:26 <drdo> I honesly don't see the any problem with stuff like that
18:23:28 <drdo> *honestly
18:23:29 <cmccann> would you agree that importing one thing from a module should not suddenly cause unrelated code that doesn't use the thing which was imported to mean something completely different?
18:23:29 <elliott> It's the "adding instances should not change the meaning of a correct program".
18:23:37 <elliott> If you don't see the problem you should try building large systems that use typeclasses.
18:23:37 <drdo> elliott, Why not?
18:23:44 <drdo> Well
18:24:02 <drdo> How would it change the program?
18:24:14 <elliott> The unrelated code cmccann mentions would end up using a completely different instance.
18:24:15 <drdo> Well yes it can
18:24:19 <elliott> For what type? You don't know.
18:24:20 <cmccann> drdo: I wouldn't because you're not allowed to do that
18:24:28 <cmccann> unless you turn on overlapping instances or whatever other nonsense
18:24:29 <drdo> Supposedly you pick the most specific instance
18:24:59 <elliott> Yes, and there can be a more specific instance than Functor m => Monad m.
18:25:07 <drdo> Sure
18:25:08 <elliott> Thus changing the meaning of unrelated code that would previously use that fallback instance.
18:25:17 <elliott> Because you imported a Monad SomeType instance from another module.
18:25:38 <cmccann> drdo: so if you import "foo" from module A and use it in a function "bar", would you expect the behavior of the function "baz" to change, even though it doesn't use "foo" at all?
18:25:41 <drdo> I didn't get that, can you clarify
18:25:56 <drdo> Sorry if i'm being annoying, i haven't slept in a while
18:25:57 <cmccann> drdo: because either you accept that scenario, or you accept no overlapping instances
18:26:07 <cmccann> or you invent a completely different system
18:26:30 <drdo> cmccann: No, i would not, i didn't quite understand how it could
18:27:06 <cmccann> drdo: because by importing module A you also get an instance for some type class that "baz" uses
18:27:18 <cmccann> which is more specific than whatever instance would be selected otherwise
18:27:36 <cmccann> so even importing "nothing" from module A changes the meaning of "baz"
18:27:52 <drdo> It's still not clear that that could reasonably happen
18:27:58 <cmccann> I'm not sure how to make it more clear
18:28:04 <cmccann> that's how it works, that is what can happen
18:28:07 <drdo> i.e. that the new instance isn't indistinguishable
18:28:08 <cmccann> this is an immutable fact
18:28:49 <cmccann> here, I'll give you a nicely plausible example
18:29:02 <cmccann> you create an overlapped (Monad m) => Applicative m instance
18:29:05 <cmccann> because why not
18:29:11 <drdo> Alright
18:29:28 <cmccann> everything works great
18:29:40 <drdo> Indeed
18:29:46 <cmccann> then you import another module that for some strange reason has defined a different Applicative instance for some list-like type
18:29:53 <cmccann> except that it defined the ZipList version
18:30:03 <drdo> ok
18:30:06 <cmccann> which is now more specific than your monadic instance
18:30:25 <drdo> hmm?
18:30:29 <cmccann> so anything using the Applicative instance of this list-like type suddenly changes from (<*>) being cartesian product to zip
18:30:48 <drdo> That is not reasonable
18:30:57 <cmccann> drdo: correct
18:31:06 <cmccann> in other words, overlapping instances is not reasonable
18:31:09 <monochrom> you have both "instance (Monad m) => Applicative m" and "instance Applicative MyList". they both match MyList. but they behave different
18:31:10 <drdo> cmccann: On the programmer's part
18:31:12 <cmccann> which is what we were saying to begin with
18:31:28 <elliott> drdo: if you write Functor m => Monad m, then **every Monad instance there is** becomes overlapping.
18:31:35 <elliott> so yes, it would be an error to write such an instance, on the programmer's part, i.e. yours
18:31:38 <elliott> which is why it's not allowed :P
18:31:39 <drdo> elliott, Don't you mean the other way around?
18:31:45 <cmccann> drdo: both pieces are independently reasonable
18:31:50 <cmccann> they are not reasonable when combined
18:31:59 <drdo> elliott: But it disallows reasonable things
18:31:59 <elliott> drdo: no
18:32:07 <cmccann> that is a staggeringly terrible form of anti-compositionality
18:32:15 <drdo> You mean to implement the Monad class assuming only Functor?
18:32:27 <drdo> The "reasonable" part is implied
18:32:34 <drdo> Otherwise unsafePerformIO and etc
18:32:46 <elliott> ??
18:32:48 <elliott> I told you it's not reasonable.
18:33:01 <drdo> Nevermind
18:33:07 <elliott> Well, in this particular case it's reasonable assuming the laws are obeyed.
18:33:08 <drdo> I just got confused
18:33:14 <elliott> But in general this stuff isn't reasonable.
18:33:14 <drdo> I was studying logic earlier
18:33:18 <monochrom> no one means to implement Monad assuming only Functor
18:33:19 <drdo> I was reading => as implies
18:33:23 <drdo> Functor implies Monad
18:33:25 <elliott> If you're going to change the language to allow Functor m => Monad m you should just add a Functor superclass to Monad like it should be instead
18:34:19 <elliott> Er, yes, these arrows are totally flipped, of course.
18:34:32 <cmccann> there are plenty of specific cases where it seems reasonable to do something that needs overlapping instances
18:34:35 <drdo> It's rather confusing
18:34:38 <cmccann> in many of those cases it actually is reasonable
18:34:38 <drdo> Because you might mean
18:34:44 <drdo> class Functor => Monad
18:34:45 <drdo> or
18:34:48 <drdo> instance Monad => Functor
18:34:49 <cmccann> however overlapping instances in the general case are not reasonable
18:35:09 <drdo> Or the other 2 mistakes
18:35:35 <drdo> cmccann: Right
18:36:02 <drdo> The idea is to figure out if you would get unreasonable behaviour from reasonable things done by someone else
18:36:30 <cmccann> that's the point, overlapping instances allows cases where two reasonable things are combined to become unreasonable
18:36:31 <drdo> If the other person does unreasonable things... garbage in, garbage out
18:36:45 <drdo> cmccann: That is a problem indeed
18:36:52 <drdo> But i have no understood how it might happen
18:36:59 <drdo> *not
18:37:05 <cmccann> I've explained it like twice at least
18:37:38 <covi> I often find myself jumping through different parts of my code, only to see the type signature of some function. Is there any vim plugin that smoothens this process?
18:37:40 <drdo> It was too vague. To just the how reasonable something is, you need to be pretty specific
18:37:45 <drdo> *judge
18:38:27 <monochrom> may I lure you to switch to emacs? :)
18:38:40 <drdo> It's not much better on the emacs side
18:38:49 <drdo> Or at least i don't know about it
18:38:50 <cmccann> drdo: I gave sufficient detail to figure out as many specifics as you need
18:39:28 <monochrom> there is a common haskell-mode on emacs that shows type sig of a name, provided that name has "name :: type sig" in the same file
18:39:29 <drdo> cmccann: You aren't exactly convincing :)
18:39:37 <drdo> You even said "for some strange reason" yourself :P
18:39:49 * cmccann shrugs
18:40:11 <fmap> covi: ghc-mod
18:40:16 <cmccann> ask someone else to explain it again, I guess
18:40:51 <drdo> fmap: I use ghc-mod, it's pretty nice
18:41:27 <drdo> What i desire the most is indentation
18:41:51 <drdo> haskell-mode's indentation is terrible, all of them
18:42:19 <monochrom> one of them is not terrible for me
18:42:20 <drdo> I just use the simplest one where i have to press tab 50 times to indent something
18:42:34 <Ralith> this is why I dislike layout
18:42:36 <drdo> The other ones fight with me and indent with a style i don't like
18:42:43 <Ralith> indentation is a huge pain in the ass
18:42:50 <drdo> Ralith: lisp #1
18:42:55 <Ralith> \o/
18:42:55 <monochrom> http://hpaste.org/47103/emacs_haskellmode_demo
18:43:15 <Ralith> unfortunately there are no good statically typed lisps...
18:43:17 <covi> fmap: which of them?  https://github.com/scrooloose/syntastic  https://github.com/eagletmt/ghcmod-vim
18:43:32 <fmap> the latter
18:43:36 <alpounet> drdo, ghc requires it to be unambiguous which instance declaration it should use to resolve a type-class constraint
18:43:38 <drdo> Ralith: You can't really have one
18:43:48 <drdo> We discussed that a lot, as i recall
18:44:08 <Ralith> drdo: doubtful, as I'm of the belief that you certainly can
18:44:11 <drdo> You can sorta kinda do something, but the result wouldn't really have the lisp spirit
18:44:12 <covi> fmap: thanks
18:44:23 <Ralith> that depends on your interpretation of "the lisp spirit" :P
18:44:30 <cmccann> parentheses
18:44:35 <cmccann> lots of parentheses
18:44:38 <drdo> Ralith: Did you keep working on that area?
18:44:40 <cmccann> also, metaprogramming
18:44:43 <cmccann> but mostly parentheses
18:45:02 <fragamus> my heap profile says my memory is filling up with pinned objects.  They seem to hang around.  any insight?
18:45:16 <drdo> cmccann: It's mostly the ability to satisfy your every whim
18:45:18 <drdo> freedom
18:45:37 <Ralith> drdo: I've shelved it to work on more core functionality of idris, with the intention to someday return to it as an idris frontend once idris proper works to my satisfaction.
18:45:40 <fmap> covi: you may also want to check neco-ghc
18:45:48 <drdo> Oh right
18:45:54 <drdo> I was at triton's house
18:45:57 <drdo> The other day
18:46:05 <drdo> He mentioned you were doing something with idris
18:46:23 <Ralith> cool
18:46:25 <monochrom> pinned objects may be bytestrings
18:46:42 <Ralith> I realized I can tolerate a lot of idiosyncratic syntax for the sake of a really nice type system
18:47:04 <drdo> Full type theory is really cool
18:47:16 <drdo> But then the real world comes knocking
18:47:16 <Ralith> it's a ton of fun to work with
18:47:35 <drdo> For you to quit writing proofs and get something working this year
18:47:42 <fragamus> yes my pinned objects are certainly byte strings   is there anything I can do to get GC to clean upthem?
18:47:45 <Ralith> thus idris' design principles
18:47:51 <drdo> Ralith: I'm not familiar with it
18:48:12 <drdo> I just know that it's "something vaguely like agda"
18:48:15 <drdo> and friends
18:48:17 <monochrom> GC cleans up them iff you do not hold onto them
18:48:18 <Ralith> ah, well
18:48:24 <Ralith> in short, it's not nearly so proof-oriented
18:48:36 <drdo> What does that mean?
18:48:39 <Ralith> it has full support for proving things, of course, but the idea is to be able to work just fine without doing so as well.
18:48:59 <Ralith> allows you to take advantage of the expressiveness of the type system to whatever extent you like
18:49:00 <drdo> You only have to prove the stuff you want to
18:49:13 <drdo> You can always use more general types
18:49:24 <Ralith> that's the idea, yes
18:49:32 <covi> Interesting, cabal install ghc-mod fails on my Mac
18:49:39 <drdo> And every system has a "unsafeProofByHandwaving"
18:49:39 <Ralith> there's a pretty attractive and highly practical happy medium in there, imo.
18:50:05 <drdo> Ralith: Oh boy
18:50:11 <Ralith> specifically, idris is orientied around directly writing executable code
18:50:11 <drdo> I know that feeling
18:50:28 <monochrom> "hold onto them" is a bit vague, and I don't know how to say it better. but suppose you have "main = do s<-(some i/o giving you a huge bytestring); infinite_loop_that_refers_to_s" then you are holding onto s
18:50:51 <Ralith> you can start with something as unsafe as you like and refine it, as well
18:50:53 <drdo> Ralith: To be honest, i think we need to go there
18:51:09 <drdo> In Haskell you can really feel the limitations
18:51:13 <Ralith> I agree
18:51:43 <Ralith> I mean, hell, I've been wanting ways to express arbitray propositions since I started programming, though I didn't know how to put it
18:52:39 <Ralith> not necessarily complete proofs of correctness, but midlevel stuff like length-indexed vectors which can make life both easier and safer without taking an immense amount of effort.
18:53:23 <drdo> You can do that in haskell
18:53:34 <drdo> Kinda
18:53:38 <cmccann> with enough jumping through hoops
18:54:19 <Ralith> the hoops are many, and the result is awkward and constrained
18:54:22 <drdo> It is
18:54:25 <fragamus> I understand.  I am trying to run it longer to see if GC clean ups them.  I am certain I do not hold them. They are transient dudes.
18:54:26 <Ralith> and that's just one example
18:54:33 <drdo> There's 10 billion extensions for little specific things
18:55:10 <drdo> At some point you just gotta say "I can live with undecidable type checking" and go!
18:55:21 <cmccann> type checking shouldn't be undecidable.
18:55:26 <cmccann> type inference is another matter.
18:55:41 <drdo> cmccann: It is
18:55:46 <cmccann> then again, type inference doesn't work for Haskell + various GHC extensions as is.
18:56:00 <`nand`> what extensions break type inferencing other than RankNTypes?
18:56:12 <drdo> Inference is hopeless if you have the full type theory
18:56:25 <Ralith> it seems a bit silly to mind broken type inference when all that requires of the programmer is good-practice top-level declarations
18:56:28 <drdo> You can infer something here and there
18:56:28 <cmccann> `nand`: I can't recall off the top of my head
18:56:45 <cmccann> and for the most part GHC is good about inferring the rest given a few critical annotations
18:57:16 <drdo> `nand`: I didn't mean Haskell
18:57:32 <cmccann> which is a feature worth keeping in more expressive languages, to my mind. infer as much as you can reliably infer.
18:57:37 <`nand`> drdo: aye, but cmccann did
18:57:40 <cmccann> but don't lose sleep about not inferring everything.
18:58:11 <latermuse> is there an easy way to pseudo-randomly scramble a list?
18:58:17 <drdo> It's not even very clear what infering would mean if you have full type theory
18:58:58 <`nand`> latermuse: you would probably want something like an array instead of a list for that
18:59:07 <covi> Can someone look at the error message by cabal? ghc-mod fails to install, due to some hashable issues: http://hpaste.org/80481
18:59:17 <drdo> covi: doesnt' work from hackage
18:59:21 <cmccann> I also wouldn't mind more support for writing out fancy type signatures and having term inference fill in implementation details
18:59:24 <drdo> get it from github forks
18:59:45 <drdo> There's a couple of forks there that fix the compilation problems
18:59:51 <covi> drdo: `it'?
18:59:55 <drdo> ghc-mod
19:00:22 <drdo> For a second i thought i was crazy there, you clearly asked about ghc-mod
19:00:46 <`nand`> you could have been talking about hashable
19:00:47 <drdo> cmccann: It's not just fancy, it's as powerful as your code
19:00:53 <`nand`> or ghc, arguably
19:01:01 <covi> drdo: Can you point me to such a fork
19:01:12 <drdo> covi: Sure, let me check, i got it here somewhere
19:01:26 <fragamus> well i said I hold not them, but I think I wrong am
19:01:34 <monochrom> heh
19:01:59 <`nand`> cmccann: I would like the ability to write out partial type signatures; eg. return 1 :: [_]  would have the type Num a => [a]; and not (Num a, Monad m) => m a
19:02:03 <drdo> No, i can't, i don't know how to use git
19:02:07 <drdo> Let me try googling
19:02:21 <cmccann> `nand`: I think oleg had some horrific hack to do that, heh
19:02:25 <cmccann> but yeah it would be nice
19:02:31 <`nand`> yeah I saw that, but it's not quite the same thing
19:02:44 <drdo> https://github.com/jwiegley/ghc-mod
19:02:45 <drdo> Here's one
19:02:47 <`nand`> he used it for two particular scenarios, but it didn't generalize iirc
19:03:20 <`nand`> actually, it probably would
19:04:08 <drdo> I would just like some sort of primitive type-level abstraction
19:04:12 <`nand`> let asList :: [a] -> [a]; asList = id in asList (return 1)
19:04:17 <monochrom> drdo: have you reproduced covi's problem? namely, "lookupSymbol failed in resolveImports
19:04:21 <drdo> You can't switch parameter order around
19:04:26 <drdo> *even
19:04:36 <monochrom> /Users/covi/.cabal/lib/hashable-1.2.0.2/ghc-7.6.1/HShashable-1.2.0.2.o: unknown symbol `_hashable_siphash24_sse2'
19:04:37 <drdo> monochrom: No
19:04:41 <drdo> I have ghc-mod working
19:04:46 <aavogt> @src asTypeOf -- `nand`
19:04:47 <lambdabot> Source not found. My mind is going. I can feel it.
19:04:51 <drdo> I do know that the version on hackage does not work
19:04:52 <aavogt> :t asTypeOf
19:04:53 <lambdabot> a -> a -> a
19:04:58 <drdo> Unless it has been updated meanwhile
19:05:01 <Nereid> @src asTypeOf
19:05:01 <lambdabot> asTypeOf = const
19:05:05 <Nereid> note @src is pretty dumb
19:05:12 <johnw> drdo: I have hdevtools working with ghc-mod now, and it's *wicked* fast
19:05:19 <drdo> It was updated
19:05:25 <Nereid> @src asTypeOf
19:05:25 <lambdabot> asTypeOf = const
19:05:26 <aavogt> asTypeOf predates oleg's stuff
19:05:28 <Nereid> ok
19:05:29 <drdo> Last update was June or something when i tried
19:05:30 <covi> monochrom: I noticed that line, don't know how to solve it.
19:05:31 <johnw> i was able to set the flyspell auto timeout back to 0.5, because now syntax checking takes milliseconds
19:05:49 <joefiorini> Hey all, just starting with Haskell, what is the best way to isolate my app's dependencies from cabal's global & user packages? cabal-dev?
19:06:04 <monochrom> well then, I have confidence that a newer version of ghc-mod makes no difference, since the problem is with linking hashable
19:06:04 <drdo> Are there any news in the indentation area?
19:06:06 <johnw> joefiorini: I prefer cabal-dev, yes
19:06:36 <`nand`> aavogt: I guess that could work, if you're fine with throwing in undefined; eg. say you want to instead write (return 1 :: _ Int) you could use return 1 `asTypeOf` (undefined :: a Int); or let f :: a Int -> a Int; f = id in f (return 1)
19:06:38 <monochrom> mac os x was also mentioned. may be a 32bit vs 64bit problem specific to mac os x instead
19:06:44 <joefiorini> johnw: is there a way to run your app without having to cabal-dev install every time?
19:06:49 <covi> monochrom: i tried reinstalling hashable, but the error persists.
19:06:50 <fragamus> my laptop noise makes when running haskell program this   like warp engine under strain severe
19:06:54 <covi> monochrom: i am using 32bit
19:07:02 <joefiorini> johnw: like I can with runghc?
19:07:04 <aavogt> `nand`: yeah, it's less painful if there's a shorter abbreviation for undefined
19:07:26 <aavogt> like '__' or 'u' or something else
19:07:44 <`nand`> let as = asTypeOf; type = undefined in return 1 `as` (type :: a Int) -- too bad ‘type’ is reserved
19:07:46 <Nereid> or _|_
19:07:49 <cmccann> how about ☃
19:07:52 <cmccann> I like ☃
19:08:00 <Nereid> @let _l_ = undefined
19:08:02 <lambdabot>  Defined.
19:08:08 <`nand`> ⊥
19:08:11 <drdo> covi: Usually at that point i go "rm -rf ~/.ghc"
19:08:18 <drdo> And install stuff again
19:08:20 <Nereid> > generalCategory '⊥'
19:08:20 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
19:08:23 <Nereid> oops
19:08:24 <drdo> Usually solves the problm
19:08:26 <drdo> *problem
19:08:37 <`nand`> > generalCategory '\8869'
19:08:39 <lambdabot>   MathSymbol
19:08:42 <`nand`> blah
19:08:43 <fmap> johnw: does hdevtools play nice with cabal-dev environment?
19:08:45 <Nereid> :(
19:08:51 <drdo> cabal and cabal-install and ghc-pkg are all black magic
19:09:08 <cmccann> > generalCategory '\9731'
19:09:10 <lambdabot>   OtherSymbol
19:09:18 <monochrom> then you haven't read my http://www.vex.net/~trebla/haskell/sicp.xhtml
19:09:31 <covi> drdo: how do i install stuff again? download ghc source back and compile?
19:09:41 <drdo> covi: Hmm?
19:09:46 <drdo> I just meant removing the user intalled packages
19:09:53 <drdo> and installing with cabal-install the thing you want
19:10:04 <monochrom> covi, read my http://www.vex.net/~trebla/haskell/sicp.xhtml for what ~/.ghc means
19:10:08 <fragamus> is _|_ part of syntax or just documentation?
19:10:14 <drdo> monochrom: That's so misleading
19:10:18 <drdo> The url
19:10:31 <drdo> I read "sicp" and thought...
19:10:44 <monochrom> clearly, c stands for cabal
19:10:44 <covi> too long to read
19:11:13 <Nereid> fragamus: it's supposed to be ⊥, and it's not real haskell syntax
19:11:18 <drdo> I meant "http://mitpress.mit.edu/sicp/" obviously
19:11:21 <covi> monochrom: just to let you know i once read your post about scanl, really cool
19:11:21 <cmccann> fragamus: it's an ASCII version of ⊥ which is... yeah what Nereid said
19:11:33 <monochrom> thank you for choosing monochrom!
19:11:44 <drdo> Where can i read about why cabal-install never upgrades anything and there's no way to do it?
19:12:00 <covi> monochrom: can you help solve my problem at hand
19:12:03 <Nereid> fragamus: it's read "bottom" and is just used to represent any nonterminating value.
19:12:21 <drdo> covi: Trust me, just delete the user packages and install again
19:12:27 <drdo> It's faster than trying to figure it out
19:12:42 <drdo> At least that's what i do
19:12:44 <monochrom> I can't, because it is specific to mac os x, and I don't use mac os x, so I did not pay attention last time a similar problem was troubleshooted
19:13:02 <covi> drdo: what do you mean by 'install again'
19:13:30 <drdo> covi: rm -rf ~/.ghc && cabal install ghc-mod
19:13:33 * hackagebot linear 0.6 - Linear Algebra  http://hackage.haskell.org/package/linear-0.6 (EdwardKmett)
19:13:46 <Nereid> @let bot = var "\8879"
19:13:47 <lambdabot>  Defined.
19:13:50 <Nereid> > bot
19:13:52 <fragamus> nonterminating _|_ is like wife
19:13:52 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (invalid character)
19:13:55 <Nereid> aww argh
19:13:59 <covi> drdo: kk, i'm doing this, thanks
19:14:01 <drdo> Assuming your cabal-install isn't in there
19:14:05 <drdo> And is in the global db
19:14:59 <monochrom> cabal-install is not even in any db. if anything it is in /usr/bin or /usr/local/bin or ~/.cabal/bin
19:15:16 <drdo> Yes, that
19:15:26 <drdo> I'm sleepy
19:15:57 <monochrom> you need to use the scientific method to validate more things before you claim them
19:16:13 <covi> monochrom: r u a grad student?
19:16:19 <monochrom> no
19:16:57 <cmccann> monochrom is a monochrom
19:17:13 <drdo> I find the terminology "grad student" rather funny
19:17:25 <monochrom> yes
19:17:38 <Nereid> why isn't monochrom a dichrom
19:17:46 <drdo> People don't say that here, or anything equivalent
19:18:10 * cmccann doesn't know why students are measured in gradians
19:18:27 <drdo> And it's the name, that distinction isn't emphasized
19:18:32 <drdo> *it's not just the name
19:18:43 <Ralith> `nand`: iirc idris supports type signatures like you are asking for
19:18:53 <covi> drdo: isn't grad student = graduate student?
19:18:58 <drdo> covi: Yes
19:19:18 <Ralith> `nand`: I know you can do e.g. 'the (List _) (return 1)'
19:19:23 <covi> drdo: Same error occurs..
19:19:24 <Ralith> fairly sure that extends to real signatures.
19:19:28 <drdo> But i have only heard americans saying that and making that distinction
19:19:34 <drdo> Between ungrad and grad students
19:19:36 <covi> I will give that fork a try
19:21:36 <covi> Failed. Failed.
19:21:47 <covi> Guess it's because my ghc is 7.6.1
19:21:49 <drdo> Heed my warnings, delete everythin
19:21:57 <drdo> Don't fight cabal and ghc, you will lose
19:22:09 <covi> drdo: I deleted .ghc, what else do you want me to delete
19:22:41 <fragamus> i fought the law and the law won
19:22:49 <drdo> I don't know man, i should shut up, i'm doing this shit again, just saying stuff on irc
19:23:26 <fragamus> first step is to admit problem
19:24:06 <drdo> fragamus: I just start spewing stuff out, i don't even care if no one answers, starts to happen when i've been up for longer than 50-60 hours
19:24:49 <fragamus> drdo: yeah its the caffienne
19:24:56 <drdo> Yes, let's go with that
19:38:01 <tibbe> I updated my style guide to mention working with laziness for the first time (https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md#dealing-with-laziness). What do people think?
19:40:51 <liyang> tibbe: don't you want to mention your -funbox-strict-primitive-fields ?
19:41:02 <tibbe> liyang: once it's out
19:44:06 <monochrom> it should be either "strict and non-strict" or "eager and lazy". but it is a losing battle
19:44:29 <luite> hm what's a primitive here?
19:44:32 <covi> How to install a Cabal package automatically? I used 'runhaskell Setup.hs configure', and it tells me i have a dozen dependencies not yet installed.
19:44:39 <monochrom> and it is my lone battle
19:44:41 <liyang> I'd say something on the drawbacks of -funbox-strict-fields on non-primitive fields in that case.
19:44:45 <mikeplus64> covi: cabal install
19:44:52 <copumpkin> funbox
19:44:55 <copumpkin> I want a funbox
19:44:59 * liyang prefers to explicitly say {-# UNBOX #-}, at least for now.
19:45:10 <covi> mikeplus64: thanks.
19:45:36 <mikeplus64> liyang: -funbox-strict-fields won't do anything on non-primitive fields, won't it? like trying to do data X = X {-# UNPACK #-} !Bool
19:45:50 <liyang> luite: something that has an unboxed type in GHC. Int#, Double# &c.
19:46:39 <luite> liyang: hm, i thought an Int# field was always stored unboxed
19:47:00 <liyang> mikeplus64: Bool is a sum… I mean sometimes you want a record field to be strict, but you don't want its contents to be unpacked into the outer record.
19:47:08 <copumpkin> luite: it is
19:47:41 <mikeplus64> liyang: i mean that in that case it doesn't have any effect, right?
19:47:45 <mikeplus64> other than strictness
19:47:54 <liyang> luite: but { foo :: !Int } isn't, without that flag.
19:47:54 <monochrom> perhaps "data X = X !Int#" is the question here
19:48:31 <luite> liyang: right, Int is not primitive or unlifted
19:49:37 <liyang> -funbox-strict-fields-with-a-primitive-type-underneath.
19:49:47 <luite> right
19:49:55 <monochrom> -ftake-off-all-your-clothes
19:50:33 <liyang> -fhow-do-you-know-im-wearing-any
19:50:50 <liyang> wat.
19:50:54 <monochrom> -fbecause-the-profiler-says-so
19:59:03 <dysinger> anyone here use nixos or nixpkgs for ghc 7.4 or 7.6 ?
20:04:24 <dysinger> echo 'main = print "hello world"' > hello.hs ; ghc --make -static -optc-static -optl-static -optl-pthread hello.hs
20:04:33 <dysinger> gives a linker error on nixos/nix
20:04:43 <dysinger> (gmp)
20:04:57 <dysinger> I'm trying to figure out why & possibly fix their build recipe
20:05:19 <dysinger> or maybe it's just due to the nature of Nix pkgs being in non-standard locations, I just have to learn how to compile better.
20:06:16 * aavogt used nix a couple years ago
20:07:13 <jfischoff> dysinger: roconnor might be able to help you
20:07:34 <dysinger> cool I will be on the lookout
20:08:35 <aavogt> dysinger: also might be worth asking in #nixos
20:09:18 <roconnor> dysinger: what system are you using?
20:10:00 <roconnor> ah yes, I have an error with that command
20:10:37 <roconnor> I've never tried a static build before
20:10:40 <roconnor> this is interesting
20:11:10 <roconnor> dysinger: I'm afraid you will have to talk the the ghc package maintainers about this
20:11:22 <roconnor> I'd be quite interested to have static builds working
20:14:41 <roconnor> dysinger: here is the build log if that helps:  http://hydra.nixos.org/build/2596690/log/raw
20:14:42 <dysinger> aavogt: the guys on nixos aren't super concerned with haskell. It's up to me to push it forward.
20:14:52 <dysinger> roconnor: I'm using nix on ubuntu and also nixos
20:14:56 <dysinger> and also on the mac
20:15:13 <roconnor> dysinger: in theory the builds for nixos and nix on ubuntu are identical
20:15:35 <dysinger> I've been building different permutations of the ghc 7.6.1 nix recipe all day with no success
20:15:40 <aavogt> dysinger: people like marcweber should be pushing it
20:15:47 <dysinger> trying to get static compilation working
20:16:23 <dysinger> ok maybe an email to the maintainers next
20:16:28 <aavogt> one place to start is to check if gcc does static linking properly
20:16:53 <aavogt> maybe you can just replicate the same hack (if there is one?) for ghc's call to ld
20:17:12 <roconnor> dysinger: if you do -v you get to see the failing command
20:17:20 <dysinger> one sec
20:17:25 <roconnor> can i get ghc to not delete temp files?
20:17:51 <roconnor> It appears to be running /nix/store/knyqmizvmpi8bm745zbmalksplxd10sq-gcc-wrapper-4.6.3/bin/gcc which is good
20:18:22 <roconnor> and it passes -L/nix/store/01d61sgqavjph83c9qx9n05yjv1qblcl-gmp-5.0.5/lib  which is also good
20:18:40 <dysinger> wow maybe it's gcc
20:18:51 <dysinger> I see the gcc call & it has gmp on there
20:19:08 <monochrom> roconnor: -keep-tmp-files
20:19:12 <roconnor> thanks
20:19:47 <monochrom> look for a directory called /tmp/ghc[0-9]* IIRC
20:20:10 <roconnor> yep
20:20:38 <roconnor> this gcc command look reasonable to me.  I'm not sure why it fails
20:25:02 <roconnor> dysinger: I *think* the problem is that there is no static library  libgmp.a built with gmp (by default)
20:25:20 * roconnor checks the gmp log
20:25:37 <dysinger> iconv was doing the same thing this afternoon
20:25:45 <dysinger> I added iconv as a dep to ghc 7.6.1 nix expr
20:25:58 <dysinger> and when i compiled static it complained about not finding either one
20:26:10 <dysinger> even though base needs iconv in order to even compile & install ghc 7.6.1
20:32:36 <drbean> I'm trying to install ghc-mod too, but cabal is not finding the fedora packages, hlint and ghc-ghc-paths.
20:33:02 <roconnor> dysinger: are you on 32 bit or 64 bit?
20:33:22 <dysinger> this is 32bit but I'm moving back and forth
20:33:30 <dysinger> it's on a vm
20:34:09 <roconnor> dysinger: what's your path for ghc and for gmp-5.0.5?
20:35:19 <dysinger> On this particular 32bit vm it's ghc 7.4.2 on /nix/store/858ww5lrjxca5asa79vwq5rm6m1h3q6k-ghc-7.4.2/ and /nix/store/a9jvlnrva7vr1szbg6shpw6nr5xz898p-gmp-5.0.5/
20:35:45 <dysinger> 7.4 & 7.6 are the same as far as error from the simple hello world app I pasted above
20:37:44 <roconnor> dysinger: here is the problem: http://hydra.nixos.org/build/2539755/nixlog/10/raw
20:37:52 <roconnor> configure flags: --disable-static --prefix=/nix/store/01d61sgqavjph83c9qx9n05yjv1qblcl-gmp-5.0.5 --enable-fat --enable-cxx
20:37:58 <roconnor> --disable-static
20:38:28 <dysinger> ahhhah
20:38:38 <dysinger> that's not in the nix expr I'm looking at
20:38:49 <dysinger> I bet that's something higher up in nix
20:38:52 <roconnor> ya, I'm trying to find the expression
20:38:59 <dysinger> because it happens to libiconv too
20:39:06 <roconnor> ... now granted, this version is not that same version you have installed
20:39:19 <dysinger> it's been like this for a while I think
20:40:41 <dysinger> roconnor: http://old.nabble.com/Re%3A--PATCH--urweb-compiler-enable--static-flag-p30212418.html
20:41:22 <dysinger> looks like it's a setting
20:41:45 <dysinger> I'm off to try it but it probably means recompiling the whole os
20:41:49 <dysinger> ahhhhh gentoo
20:43:54 <drbean> My problem, cabal not finding HP packages on Fedora was not having the fedora ghc-hlint-devel and ghc-ghc-paths-devel packages installed.
20:44:16 <roconnor> dysinger: you can add a parameter to the gmp expression to optionially dontDisableStatic
20:44:34 <roconnor> dysinger: then you can modify the haskell package to pass in a modified gmp that has the flag set
20:44:34 <dysinger> y
20:44:40 <roconnor> dysinger: and you don't have to rebuild your entire OS
20:44:50 <dysinger> and iconv
20:44:56 <dysinger> and ncurses
20:44:59 <dysinger> and that should do it
20:45:28 <roconnor> dysinger: you may want to discuss in #nixos to see if there is an easier way to modify packages to dontDisableStatic.
20:45:40 <roconnor> dysinger: possibly when people in europe are awake.
20:46:04 <roconnor> dysinger: I need to go to sleep.  you can msg me if you have any problems.
20:46:13 <roconnor> dysinger: but I think this is promising
20:47:31 <dysinger> roconnor: awesome thanks
20:50:09 <kate_r> hi
20:50:09 <kate_r> does anyone know how the universal quantifier can be encoded using quantifier constants and lambda terms?
20:50:24 <kate_r> is it like All(P) == (P = (\x. True)) ? where P is a predicate.
20:52:20 <mephx> can anyone tell me how do I upgrade the base package with cabal?
20:52:54 <aavogt> mephx: you should upgrade your ghc instead
20:53:11 <aavogt> which might be possible if  'cabal install ghc' worked
20:54:46 <mephx> aavogt: I'm on ubuntu, ghc7 from tree is version 7.4.2, I have a dependency for >=base-4.6
20:55:01 <mephx> aavogt: there is no such package ghc cabal says
20:56:23 <quchen> mephx: I would suggest installing GHC and packages manually (i.e. OS-independent). I went through the war between Ubuntu and GHC/Platform a couple of times, it's not worth it.
20:57:05 <quchen> Actually, I don't see a single benefit in using the OS package manager in the Haskell case.
20:57:06 <mephx> quchen: ok, but I think we should start a ppa for that
20:57:44 <mephx> quchen: not everyone is a power user, sometimes the best for us isn't the best for everyone
20:58:04 <quchen> Problem is when GHC updates to a new version and changes the Prelude or something like that, your old stuff won't compile.
20:58:29 <quchen> So I'd like to explicitly tell GHC to update. (Bonus: you can have multiple GHC installations alongside each other.)
21:01:11 <mephx> I'm sure with a little extra packaging work, that behaviour could be done
21:02:04 <mephx> perhaps if I really fall in love with haskell
21:02:56 <mephx> thank you both for the advice, cheers
21:03:59 <quchen> My "install GHC+Platform manually" file is 26 lines long and I'd call it foolproof (test subject: me). But as you are going to fall in love with Haskell anyway, we just found ourself the packager ;-)
21:04:59 <mephx> start by sharing that script and we might get ourselves a deal
21:05:04 <mephx> =P
21:07:12 <monochrom> as with all software: just use your linux repo if you have lax version requirements, install your own if you have strict version requirements. GHC may be in either category depending on you, and only you
21:08:39 <hpaste> Quchen pasted “Quchen's GHC update script for humans” at http://hpaste.org/80483
21:08:43 <monochrom> it is quite possible that one person must keep chasing new GHC versions but can stick with one xchat version for a long while. and it is possible that another person is just the opposite
21:09:29 <quchen> It's written for myself, so I omitted stuff like "download GHC tarball" and "edit $PATH". That'll add a few more lines.
21:09:31 <mephx> quchen: <3
21:10:58 <quchen> Especially the "clean .ghc and .cabal" part can save you a lot of trouble ;-)
21:31:55 <hpaste> monochrom pasted “continuation parsec style” at http://hpaste.org/80484
21:33:47 <monochrom> hehehe, enjoy!
21:34:48 <covi> http://hpaste.org/80486 load and loadIO look suspiciously similar to me. Is there a nice way to factor these two?
21:37:57 <drbean> Which category you are in will also depend on your OS packagers.
21:38:02 <drbean> So kudos to them.
21:51:22 <Clint> covi: why aren't you throwing in IO?
21:52:31 <covi> Clint: Are you asking why I am using load at all?
21:52:37 <Clint> no
21:53:17 <Clint> i'm asking why your loadIO doesn't throw exceptions
21:54:32 <covi> Clint: Maybe I should, for now I just use []
21:56:41 <Clint> you could do "loadIO" by wrapping load in Control.Exception.Base.try i suppose
22:13:28 <roadfish> trying to cabal install breakout. have working through a few dependencies. now have this Ambiguous module name `Prelude'.
22:14:01 <roadfish> did a websearch and says I'm supposed to remove something.
22:14:12 <roadfish> am trying this:
22:14:12 <roadfish>    $ sudo ghc-pkg hide haskell98-2.0.0.1 ; sudo ghc-pkg recache
22:14:13 <roadfish>  
22:14:36 <roadfish> but didn't seem to fix the cabal complaint.
22:19:28 <liyang> You fight with ghc-provided packages, you lose.
22:22:33 <roadfish> liyang: I've only been using cabal to install packages for a few days so far. I'm still somewhat ignorant so your comment is a bit cryptic. Does it imply some way forward? Or are you just commiserating?
22:22:44 <liyang> monochrom: I somehow have it stuck in my head that your eponymous restriction is the rule that, unless one is a GHC/Cabal expert, one ought not to mess with GHC-provided packages. Did you actually say something of that sort, or am I imagining things?
22:24:07 <liyang> roadfish: it was a cryptic commiseration.
22:24:29 <mzero> roadfish - hiding/showing packages with ghc-pkg will have little effect on cabal based projects
22:24:56 <mzero> the hide/show status is just the default visibilty that GHC uses when searching for packages that might contain included modules
22:25:31 <mzero> projects built with cabal have the specification of exactly which packages should be included via the .cabal file - and cabal arranges to have exactly just that set visible during compilation
22:25:56 <mzero> the problem is that breakout itself probably has a .cabal file specification that doesn't work against a modern GHC installation
22:26:03 <mzero> where did you find breakout?
22:26:34 <Nereid> @hackage breakout
22:26:34 <lambdabot> http://hackage.haskell.org/package/breakout
22:26:42 <Nereid> 2009. heh.
22:26:49 <roadfish> I just did a local "hoogle breaktou"
22:27:08 <roadfish> just stumbled across it during other hoogling
22:27:08 <Nereid> depends on haskgame which depends on haskell98. yeah nope.
22:27:52 <roadfish> aynyway, another tip from websearching is to edit the haskgame.cabal file.
22:27:53 <mzero> that isn't gonna work...
22:28:01 <mzero> it is possible
22:28:28 <Nereid> what if you install haskell98 <2 and let it use that, does that work?
22:28:46 <roadfish> yeah, the tips were for other packages
22:28:49 <Nereid> because that doesn't include Prelude
22:29:18 <mzero> eeeeek...... scary
22:29:43 <mzero> I'd try taking the haskell98 dependency out of haskgame
22:29:47 <Nereid> me too.
22:30:28 <mzero> but... this is kind of tough way to learn the Haskell ecosystem: but updating someone else's four year old un maintained packages!
22:30:38 <mzero> s/but/by/
22:32:09 <roadfish> hackage orphans.
22:32:24 <roadfish> sounds like some kind of war crime
22:32:56 <roadfish> searching for this cabal file
22:33:04 <roadfish> I'm guessing I should edit:
22:33:04 <roadfish>    ./share/hoogle-4.2.14/databases/download/hackage-cabal/haskgame/0.0.5/haskgame.cabal
22:33:15 <mzero> run    cabal unpack haskgame
22:33:20 <roadfish> there is also 0.0.4 0.0.43 etc
22:33:30 <roadfish> ok, I already did the cabal unpack haskgame
22:33:36 <mzero> that will unpack the package into a directory for you, and then you can edit it and build it there
22:33:57 <mzero> edit the .cabal file in the unpacked dir
22:34:09 <roadfish> ok, it uninstall in the currert directory
22:34:56 <roadfish> edited. but now what?
22:35:09 <roadfish> do I use this directory to somehow complete the installation in ~/.cabal ?
22:36:08 <roadfish> hmm, maybe I'm supposed to do "runghc Setup.lhs"
22:36:23 <mzero> no
22:36:25 <mzero> run
22:36:30 <mzero> cabal configure && cabal build
22:36:37 <mzero> and if it works
22:36:39 <mzero> cabal install
22:37:48 <roadfish> nope, didn't work: Could not find module `IO' ... member of the hidden package `haskell98-2.0.0.1'. ... need to add `haskell98'
22:38:06 <roadfish> so RIP dear breakout. I never knew thee.
22:39:47 <mephx> while installing the matching haskell platform for 7.4.2 (2012.4.0.0), make install fails with: <command line>: cannot satisfy -package-id base-4.5.1.0-6e4c9bdc36eeb9121f27ccbbcb62e3f3 clue?
22:40:46 <mephx> mmm, never mind. I might need to change some more env stuff
22:41:26 <roadfish> mephx: are you installing with some OS package manager or are you installing with cabal?
22:41:26 <mzero> that's odd
22:41:47 <mzero> sounds like they're building HP from source!
22:41:55 <roadfish> I did "apt-get install haskell-platform"
22:42:20 <mephx> roadfish: fixed, was still using the distro's ghc-pkg binary. I'm installing by hand through Quchen's guide
22:42:21 <M30W> Why is it whenever I try to compile something from source I almost always get things are out of date -_-
22:43:25 <mephx> roadfish: meaning, untaring and make installing ghc and platform respectivelly in a safe prefix
22:43:36 <roadfish> M30W: is using "cabal install ..." considered "compiling from source" whereas using "apt-get install ..." would not be?
22:43:49 <M30W> roadfish: Yes
22:43:54 <mzero> well, no
22:44:00 <mzero> not in the case of Haskell Platform
22:44:18 <M30W> True
22:44:18 <mzero> HP can be installed several ways, and in one of them, you get a source tarball of ALL the packages, and build from that
22:44:38 <roadfish> ok, so can't cabal HP. but using cabal for other packages is still considered compiling-from-source.
22:44:42 <mephx> Setup: At least the following dependencies are missing:
22:44:42 <mephx> random -any
22:44:44 <mephx> lol
22:44:52 <mzero> in another, you just cabal install the package and it pulls in the other stuff - either way, you're are building from source, but they are somewhat different
22:45:00 <roadfish> hmm, "cabal HP" sounds like the latest Rowlings novel
22:45:20 <mzero> mephx- how did you get GHC?
22:45:29 <roadfish> cabal easier than really buliding from source
22:45:53 <mephx> mzero: http://www.haskell.org/ghc/download_ghc_7_4_2
22:45:57 <mzero> for everything EXCEPT ghc and HP itself (because HP includes cabal, so there is a chicken and egg issue there)
22:46:09 <mzero> but prebuilt?
22:46:23 <mzero> 'cause not having random seems like a big error!
22:46:35 <mephx> http://www.haskell.org/ghc/dist/7.4.2/ghc-7.4.2-x86_64-unknown-linux.tar.bz2
22:46:43 <mzero> I'm guessing you are trying to have multiple versions installed?
22:47:01 <mephx> the error came out while configuring QuickCheck, already isntalling HP
22:47:38 <mzero> sounds like you've got ghc-pkg db confusion going on -
22:47:41 <M30W> Why does arch have 7.6 when the latest stable is 6.4 in the extra repos; it should be in the testing repo. :|
22:48:09 <mephx> mzero: anything else besides /usr/bin symlinks that need to be changed?
22:48:54 <mzero> mephx: not sure - I've never installed multiple versions !
22:49:14 <mephx> parallel, glut, primitive were built right behind and everything went ok
22:50:25 <liyang> Two-letter Scrabble words?
22:50:44 <liyang> (Oops. Disregard that comment.)
22:51:19 <mephx> mzero: I'm pretty much sure that the links are the only relevant thing
22:52:01 <mephx> Setup is getting the correct prefix, compiler, pkg and hsc2hs
22:52:03 <mzero> well - run "ghc-pkg list" and double check that
22:52:13 <mzero> a) the db names include 7.4.2 in the paths
22:52:31 <mzero> b) the list of packages in the global db looks correct for 7.4.2
22:52:39 <mzero> (I can hpaste a list for your)
22:53:03 <mephx> mzero: list reports from /usr/local/haskell-7.4.2/ghc-7.4.2/ with base-4.5.1.0
22:53:19 <mephx> mzero: which seems correct
22:53:43 <hpaste> mzero pasted “7.4.2 ghc package list” at http://hpaste.org/80487
22:53:44 <mephx> mzero: but indeed the list is kind of short
22:54:24 <mephx> mzero: yup, something's wrong, you have random, I don't
22:55:20 <mzero> sorry
22:55:21 <mzero> my bad
22:55:23 <mzero> that includes HP
22:55:24 <mzero> here
22:55:25 <mzero> http://www.haskell.org/platform/changelog.html
22:56:12 <mzero> that page has the list of what is in GHC and what comes with HP
22:56:14 <mephx> mzero: now the list is the same (except win32)
22:56:36 <mzero> so, back to installing HP - which is it installing QuickCheck before random
22:56:39 <mzero> are you using the HP script?
22:56:49 <mzero> or are you just installing the dirs one -by- one by hand?
22:56:58 <mephx> no, configure, then make
22:57:01 <mephx> as the guide
22:57:57 <mzero> ah - did you  save the output from the build up to that point?
22:58:01 <mzero> I bet random didn't build
22:58:36 <mephx> mzero: lol these Makefiles don't like -j4
22:58:46 <mephx> mzero: fixed
22:58:49 <mzero> OH NO - you can't do that!
22:59:10 <mephx> I do it always unless stated
22:59:21 <mzero> heh - well, that should go into the README
23:00:24 <mephx> mzero: the Makefiles should be prepared for that
23:00:40 <mzero> I'm filing a bug right now
23:00:50 <mephx> compiling one object at a time is kind of lazy
23:01:12 <mephx> kind of... cough =P
23:01:46 <mzero> http://trac.haskell.org/haskell-platform/ticket/218
23:02:11 <mephx> mzero: wp ;)
23:03:44 <mzero> well - there are two separate issues here: 1) ghc doesn't build a project in parallel - just one module at a time   b) the pacakges themseleves could be kicked off in parallel ... if only the makefile understood the package dependencies
23:04:09 <mzero> at present we don't have that information encoded in the makefile - since we have cabal figure it out for us dynamcially we when build the source tarball
23:04:23 <mephx> that's the whole purpose of the Makefile
23:04:36 <mzero> no, in this case, the Makefile is a glorafied shell script
23:04:48 <mzero> ;-P
23:05:06 <schrejily> Does anyone heck teck the rooga beega bagga?  Hebber master hoon a ferr fee.  Hilly a mackhole.  The shiny dot in the middle of a liddle light, of the middle of a lep lep lains!  Gotta get that schit ass shcrap
23:05:07 <mephx> hehe
23:05:08 <schrejily> Moistie bather.  riberian schmecklef  Mulla Malee loo lup the new flood wars.  Chuddy dip, chuddy dip, chuddy microchip.  Bucka lucka loo, bucky lucky blay.  Bucka lucky blay lee.
23:05:09 <schrejily> Burpaline: The wonder world.  Salmy magoo goal greggats  Rump duh duh duh dump, duh duh duh demp doop dump, runna nuh nah  Riggity ass gaggags  i nick  Roddan raldwell  Roady carewell reggal mahole  Rup tup shmelly smelly shmebb ub.  Roady farewell rose bose mahaggal.  A pocahontas watch
23:05:12 <schrejily> Blubbity ash hoosh her mellopath.  a Maticake for my buddy andy  Oh we-heh-heh-hell I'm thinking about the greg nargs, I'm thinkin about you!  End midal too walkin' with a dolphin.  I went up that street, you went up another street, we all up the presidio.  I'm goin out with arsenio!
23:05:14 <schrejily> fuckin bone screllalidge moink.  ruggity fucker fagger. rum dum dacka lacka rum dum jay  Go out with jay, another blue jay we fixed my astercoil plather  I'm hickin' my dagger  Rum dickily toon witherspoons.  I'm a falcons baleiva work with the yake my 7'9'er forever tumchy tither
23:05:15 <schrejily> i wrote my life story on my poop pad.  one of the greatest art exhibits of 1999 was in a new york museum of art.  In it, cow poop or fecal matter was put on a copy of the painting called "The Last Supper".  This was thought to be a form of modern art.  chumpin up the rears.  Rubb blillick bath.
23:05:16 <schrejily> The shiny dot in the middle of the light blue circle or ring is glowing silver in color like steel or real silver.  Eating pings, eating pies, Snow quibbicker bather I'm a niner!  That's right I'M A NINER!  Dipoke when we dip oh blip we dip, chucka hand oh blip we dip.  yxoukcil polk jhaggel.
23:05:18 <schrejily> Whether muh luck lick whither spoons.  wups to the umpteenth hicka low daggal.  cckocket tlopres redda ropres HUCK DICKILI DOON!  Feelie wheelie whilla maluck lick.  Slimy boo beggats.  I'm saggat I'm zeggat ziggurats.  Poop is pee.  My name is Mr. Pochahantas.  I'm a cartoon or movie character.
23:05:20 <schrejily> They put me on a watch today, sometimes I pee sometimes I'm James!  Whoodas pratts my nig names chats.  Challa-hoe banchee with a proodas made.  I'm chilly I'm child ugly daves don't go wild.  My wild, ugly boss suddenly became thin  frint glint chip.  chip chip microchip.  chip chip microchip!
23:05:21 <schrejily> My little greg narg, My little greg narg, I have freedom of speech rights!  My little greg narg, my little greg narg, you wish I didn't have rights!
23:05:22 <schrejily> Nockaragathan dick slam!  Chilly chilla choe-lal-lip!  Scuh loo lathian buck seats  Moan mlutha mah-lee black mam.  rudda doo din-ump dah doo-nah-nah
23:05:24 <schrejily> Waar chawecka wipth wella jalipth  All kinds of |\|iggers and buffy-oh juice!  I'm bagging ack the hag.  Ran a plucky plunky item plains!  Bagging the nig nag.  Bagging like green grags.
23:05:25 <schrejily> How do you wreck liss me.  Those fuckin' farts.  Wonter... a cloody a millickal bath.  Slurpy slick ass lots of pep  It's like scotch pithy.  I'm thinking about ruggity greggal.  Juvenile detention centers.  Slurpy pitch pot pee.  No likes.  Wobbity willow willa whop.  Willy wallow traps.  You can combine one or more of the darameters.
23:05:27 <schrejily> I'm trhinking about the rich ass mechgeggals.  I'm thinking about the rich ass micgeggals. Cham cham chack a leek a horn teen!   Poot wardy whail wo hootin tood!  Holla hoolah hope, laser whip!
23:05:28 <schrejily> Rabby dab runna ma nay  I'm dabster deester and I'm here to say... rump tump tigga ligger rump tump tay!  Frucky duck with the wenner hoopler wheel  Cruckity puck on an ass hole  Death bones doesn't like dlo flo.
23:05:29 <schrejily> Does anyone want to yikkel up the gecko?  Chickity china the chinese chicken!  Fucking gregging lick piss ass cunt.  Haggle hilla horst worst redneck.  Buster hymin  Juvvy joof jevuv.  Reggy McJellico.  Into that pussel.  No |\|iggards.  Your ass nards turned into a POLLEN GRAIN!  Ramis blavely reese seats.
23:05:31 <schrejily> Frucky duck with one of those chin ladin traps.  Rudder smudge wellicker wheel!  Run tun ton reddal shmip foe whip woe wack.  Rump tump tigger ligger runnel scrath.  Doo nah ninnel, nih, nee nat noe.  Runt dunt dinny!  Rump tump chickin leaker ladin straps...  Bam bam glacky I'm degga damn.
23:05:32 <elliott> hi
23:05:33 <schrejily> Ruh hent a lilla hole lieu. The craig mattican.  BITCH IF YOU DON'T TAKE DOWN THAT WEBCAM I AM KILLIN' YOUR DAMN DOGS.  Electromotive force.  Razh ta relley lep ta mezh.  Sh Soosh shzhs, seesh seesh-sheesh shoosh shzh shshs shshs.  chicawith hedgehog.  Ram bram bellalow, brown rye rom one day jeezh cheats!
23:05:35 <schrejily> Drederick mick taid with a drederick mick taid with a .. with a... drederick mick taid!  Is anyone here the funkistard corn.  I boo basted I'm feelin' gleem.  Rujjidy jallisher squillidger.  fuck you titty suckin' two balled bitch with a fat green clit.  Rark tah hoohk tah blanky roop roop duggan.
23:05:37 <schrejily> Rigg ass graggan  Arewenoo..  Arwenoo zee-oo zaya.  Chinna 2olombia adaa wella shrek raflood lool.  Ground rearing some groans.  I'm huff tuff reffa leffa lurf nords.  I'm just like... vanilla ice  foe davvity wheel barow  Exparly ex preggo  Is anyone out there a rig ass graggan?  lelly in mah kellar  WRESTLING'S FAKE!
23:05:39 <schrejily> Pargastian wildly nig nargs.  smeggalty dellets  Far foo faqqin  Digital damage.  Where wally niqqs.  It's coast to coast night.  Hoke a lup!  Free faq fornag!  Puck a leek a lup to lup round tround.  Wormser marrial niqs.  El delphin trilaxal.  Blanking bluck to the black a lickel bleck narge.
23:05:39 <jfischoff> @ops
23:05:40 <lambdabot> Maybe you meant: docs oeis pl
23:05:40 <elliott> @where ops
23:05:40 <lambdabot> arjanb bos Cale conal copumpkin dcoutts dibblego dons edwardk glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom Philippa Pseudonym quicksilver roconnor Saizan shapr sjanssen ski wli
23:05:40 <lambdabot> xerox
23:05:41 <schrejily> Puggy muggle maggity ass riggle ma hole.  Buck a waath ess wheel wall!  Bustin' room past tin!  Buckin' room past in!  A harnaly scrary o mep.  Rons raplaisher pa noans  rebble dibby dump dimp gabble dak.  A wristafiable pluckin'  Blacking it up to the reng teng blickhole.  I kleb to the sand of the blicka rickin time.
23:05:43 <schrejily> Rekkal theh mick thuck the rep tep taistral.  Wallif ma wallis wallets.  Is anyone here a jelly-o shkrapper?  Bam glacky I'm mega man!  Has anyone here ram baisted before?  The koost a heeckil pludgeon.  Feathers round rick gring air!  Liquid cereal's good for you.  The mummified goblin.  Pallaj oh plex.
23:05:44 <schrejily> Gotta set up for the suicide slide  Gamma mareenmon.  I've got more scrap ass shit than you can balieve with.  Sally McDuffo whip.  after secv on a sp00ky stream F/\gga foo regga makegg mahoun.  Its all fun and games until the power goes out.  Mennima Pay Street.  rubbbity dib dadge pickard.  Lelly in ma kellar.
23:05:46 <schrejily> I'm on recky o gregor street.  Miggity ass raggan.  Boyar bod.  Pellicka pool wiss wall.  Watching bynum bukkake the smelts  Haggity ass mahown.  Trukkity rep roon, the kitz a kickel plujin.  Trellalickers and burb street.  Huck a dickin' dime.
23:05:47 <schrejily> Float a pelly plaack ass.  You're a digital dumbass.  Smuggy jaloo meff jillahole.  Dick, dick, dick dickaloo!  Dick dickaloo my darling.  Haggity ma heggal hole.  nuriggerdy diggal.  Visi blurb cage.  O melon man mist meluhn mijohn.  Oh man mellajoram.  Hebble oh babble.
23:05:49 <schrejily> Two guns and a ruck roog.  Turned into a hollow loop.  scritch scratch the happy fog.  Is anyone here a fudge plucker.  I'm talking bout a rastal marry yo map.  Too many ruggerty dag datoes  Or are you fuck wappys out for kill gore!
23:05:50 <schrejily> The curmudgeonly pearl; ask and you might be answered.   Finger with a whop top tinger.  Rig tig tigger.  I'm ram bastin' I'm feelin' clean!  Pricey bad ass, a whop winger!  Gullable dick waffer.  Miggity mahoming beacon.  Nick lickal novice.  Your remenance.  Square juice miknuller.  Permio plather.
23:05:52 <schrejily> Where does master words eat pies for shells?  Trenna ma lilla manole.  A rargy barg ark.  Shockity strip with the rectify guy.  Clockity rep with the rectify fly.  Hebble o babble.  Rudda nah neh noo.  HEP TEP ROGGY!    I'm thinkin' about greckin' the rummified coin!  Let's look at Amenhotep 4's mummified groin!
23:05:53 <schrejily> Ploona lefflie ludge picking!  Haggy smith heddal, marry oh dettal.  Hannabalist, no cannibalist, no hannibalist balievar.  Ban dackoo.  Put on weight!  Wherr wiss fall, nudge plucking.  too many |\|igg/\s, that's my line.  I'm squirt with the worth of the mother plucking fine.  Hoomee missee  Mic daisy too.  Davey oh doubt.  Meggie mahoo middle.
23:05:54 <schrejily> Too many Romulan potatoers.  Matoonal dakkal.  Helly muhp, melly muhp, runna minuck taste-rum.  Wack ass weight!  Hellamanorf weg watthal.  I think I'll just start to try my .smuretsaTcN  rubbbity boom ducking.  Hitchaleval exasht romice.  Up with jelly my humpfrins.  Uva devil miss tee pie.  She can't poo!
23:05:56 <schrejily> Shniqqen munuh lik leggal  perritolma penis pran chella  maloney day breeze  Paahster jam ban wikkle.   Hella mah lun mick hella malole.  Hella minull mic mella manoh.  The roadline, it's illegal.  Trully mulla mih nole.  I'm a relladge-o-melladge-o-ram.  Come on you fuckin dag asses.
23:05:57 <schrejily> Damned ram bastions.  oilleJcM oper Smelly gruthergrarin trilaxals.  withers ground ring air  Puggle dee maggle dee mack traggle  Jeremy sniqqle. Jeremy spoken, in next day  I brusht boyered, I kicked a ball!  mellaminorf  troll protectors, trolls on the road!  troll protectors, their stones of power glow!
23:05:59 <schrejily> Fleeberty dith bub, a hick now a hither they humpty tance Lunchell munch a reg uhl schoolio tress nael Chuck a lick a loon baby tunes Weerz mellicorp To the wack ann watching machine wells darilla raptor plexing
23:06:00 <schrejily> Shligga ligga millik hole Shligga ligga millik hole regamakio mathjul hah there Just like in Bart Simpson the Magazine! Ban ricky ban glicky jallo whip! menario mibs Pahorp pahilla thin meffrin slujjal jeggy moran magomorph baleener
23:06:02 <schrejily> I spell it throwt, you spell it throat, the real way to spell it is throwt throwt THROWT!  Hux a mex a lig dwarf  dudikolan mail street.  Rella manae, Rella Manae, Rye dut duh!  I'm living on budgy placky street.  Reggal dee deck shweener  Hicker trellalicker
23:06:03 <schrejily> What part of that doesn't make sense to you robo  I'm rang dang smacking it up to the reck a heek a horn drom.  Rag agg big chacka lo datey fifty.  Sniggital maggal  Shelly a jelly a jew lillaputan meglamarian necks booga man  Rejja mella mic jeggal  Baika looka reg tag
23:06:04 <schrejily> Throat a pelly proat raick axe.  It doesn't eat muggo whip.  It's a piece of paiper.  Scrubbbity ass ragamahoun.  Raggity ass maga muffin.  Where's songy brother?  Where's spongy brother?  Jellanie mic flyer.  Paloody pluck bag ack.  Paloody pluck bag ack.
23:06:06 <schrejily> Whyn you call it throat throwt.  I'm a baffy hoe.  Flivvy a niv von neffran.  Purity and prudence  I'm suing for diaper damage.  Scragg a billy blunk rake  rast eye heeker, playmus guy  I don't know what a rubbbity dabby is.  Scrunny maloo lef heel hole.  Scrunny maloo lef heel hole.
23:06:07 <schrejily> Arthie shlellijge.  Arthie shlellidge.  Talking about a bee turning into a guano root.  today I'm doing pasta, i crumble it and pan fry it.  Fuckin frosty.  david hippa lappa pomprin.  Is anyone here a hemp hole?  Yeah, well shnijjy mc millicker: i know billy knalavolitz.
23:06:09 <schrejily> The Baby Faced Assassin pond.  yrummin!   Shmega melanie goetz  I'm smacking it up to the electrify beam, smacking it to the galactify beam!  Smackin the penis with the erectify beam!  When will another green skroan the horrified scream
23:06:10 <schrejily> rubbbity dag daggy dib dib, daggy daggy dib dib, daggy daggy diggy diggy dib, throwt a welly wheel wall  Reppity shcrep bam bam rep rep paranep  Shnubbity shnib up bam bam  Givin' me twice, i a molst a meeka pleck. Givin' me twice, a molst a meeka pleck.
23:06:12 <schrejily> Jeminee smucking smiggle.  Halittle halorst hamerrian sects nep tep hotep gargle dee gook mackie mchellic hole.  My niqqer dee dag sparky.  Ponto comical blessnor I'm dain dead.  Razor renzor manellik s-meg smeg you're all smegs.  We're hovvy hella pruss miss puss  Smelly mudga munaqqal  Posta wicka holma melancholy laggam
23:06:13 <schrejily> Shmelly a mellac.  Cloaky active camoflauge mail bow  Warez into a whoop coup daddy deam, I filed a lawsuit with G.L.E.A.M.  Dag a ricka bleg nagg.  Richel reprezhnik rally mic hoe whip.
23:06:15 <schrejily> fucking ass licking piss sucking cunt.  Threnthie oh pod throonis Tragallellah.  bweeey eeeiw!  bweeeeey ail!  shnib polmans mahhal wourney  Track a mix a meg norge
23:06:16 <schrejily> Flathican fellow street.  Mc Grellae Mc Regegg.  Prag a cuckian bag of gunk.  Duh nuh nihh nuh farty milligers.  Par boockalie twistie taiter.  Tittly spoof bee  Trellie oh dabble  Antenna rethal  Fucky daddy dicky  Fucky daddy dicky
23:06:18 <schrejily> Chucka lucka ling to the chucka looka lat, man can't be banned! Dee oh doing!  Chili box sand reggat. Crackity raggity ann  shaggy rab rabble  smiley oh diley oh reggal na meck transhole  In a tough manner  pung dungh chicka licka bang dad.  Guess what you smartie millickan jallefnaord.  Spend rellik maholmes.
23:06:19 <schrejily> Rudda boom boom dugging.  My name is jameel my name's jamaan.  Take this you fuckin' brack stab from buck hole.  Brag a cuck of bintorns.  I had to have jalooch to have breakfast. Trug a leck leg hole.  Tellah mef raf.  Trukkle trella lickle mazzle trag.  Shab shab skrellix magellix
23:06:20 <schrejily> Roonah bucky blay lee!  Roonah bucky blay lee!  An aggle dee dak beyond the premier.  switch up to a wedge pluckie  A jecka looch reft round!  poochin maleggal  Drek a lek meek foamie.  shlick a jig jeffjob  A jella jitch manifest  Horkin malurgis hoarde.  prebelally mobijowrist.
23:06:22 <schrejily> Fartily gas farts on someone's jacket.  Hicka low daggal.  Manil hill the jiller.  Reet dih doo deh dih, reet deh doo duh.  dendridic millimorph cardackio cleptio maggle  Jackintoshy zillword.  Just another macgasm trexie o mario bubble.  I had to have a mummified wheat bread.
23:06:23 <schrejily> Slaggy McNelly O-Loop.  Hillie Millie. Mijujik calej loft, shweener screlly mellamanorf.  The plux to the plack a leak a lithio meth  galactical terrial tuesday.  Ploody loon, back a toon!  ron ton a jelly a shawn.  Herd mah thuh fah thuh.  Jeggal mig ella cracker.  trellamanorf mick hick hole
23:06:25 <schrejily> Rump tump tiddle doo, rump dump damn.  Farbooky twistie taiter. Farbooky twistie oh plox.  jickellastrip shtiffy  Trellie oh dabble  Sabba7kom allah bilkhair ya rawafeth 3ash men shafek.  3alaikom essalam mawlana.  9eqeleyya kaanat men madresat Averroes.  plan dan duckalin jee uhst waistband
23:06:26 <schrejily> Sparra kitha mellon hoh snail bookanees.  Pucka hoonkin dick ass waste.  Triclapian transcripts.  Are you a jalellaputian?  Arthie midge millik.  See that is why I keep going "galactico trallie o-reggal"  Cuckin twanbastin wigwams shmagga miggal smell-it syllabalistic macro.  Oh-rellage oh ram
23:06:28 <schrejily> Trellik mic jelliger.  Throwty a pellage plex.  Spigga McGregor  peggly oh dabble  Hicky trellalick.  You stupid pudgy fucker.  Sneqqal segagal.  Purital laggy oh baggal.  Bucka broon broom shella muluk mic niqqer.  Rooshta shpella.  Plocky of pleckal bag a cuck of frin torns
23:06:29 <schrejily> Wa Alikum salam wa rehmatullah e wa barakat.  Tarka dellalie dool.  Mig iff raheg hord.  Raga nahoolie jeg narf.  Hellage rellage o-ram well to do it pollis  Scribble dee babble.  Mezzle ma norf.  Praggity no maddak  Duck a ween wark.  You shpuffy shpook ma leggin don't be such a terrorisdt.
23:06:31 <schrejily> Hedgy McPillik.  Hocka licka meals on weals.  Batman, batware, guess who could be in the next Batman movie? It could be you!  Galactical tactical earns the hard way.  Maggie Mig mellijopod.  trar ga moogly a mix traeger  Puh reb deb dejjer. fuck jalafi jalive.
23:06:32 <schrejily> Leepadipa did away.  lovely women spit things.  shnep a leppie loon.  smellagajee smellamanew.  Fruggity diggty!  Scrunny maloo lef heel hole  shlody shlicka rabbits  Galactical tactical plack ass.  Pawikki scrap runa mallilligram.  pick tatots.  Conifanible pluckin.  Boom bam shpaghetti monk.
23:06:34 <schrejily> Sum bum parlacktical barthy backthickal.  partrusially prtregally reggal megagal.  You fuckin roody poot noink.  Smullah jah litch jitch runhole.  Shit up you bad ass.  Is anyone here a rubbbity deaf nard.  Sniggital wathal whip.  Thylacoleo carnifex for a pet, hugga ghigga micomprin.  Don't fuck with my restaurant!
23:06:35 <schrejily> Truggity reg up rim dum, a spoon contacts the kinigigal concern.  trust no one, tiger miller  Michelle and jantsy with a banshee!  pasa wuh thuh fail the jookified coin.  Oh my gum! Oh my gum!  It's oh ho ho he's here!  Malika joola jalegnorf.  Malika joola jalegnorf.  Heggal the munch tunch taste rins.
23:06:35 <ofan> wtf
23:06:37 <schrejily> Prestegious milla ma hoe.  Panny meffa lick waifers.  Malorf jin, jalallally jin, screggat mo meggat mo methalithal lowdown.  It's oh ho ho she's here!  Has anyone here ever been to the bastard zones?  Shmeggal dee mech eck golms.  Boon toon underwear, boon town.
23:06:38 <schrejily> Veronika, days of joy, happy time for girls and boys.  Fuggle dee daggle.  Ploody pluck a loon, baby tunes.  Hella mah nor.  Snuggity rabbity pit street.  Hackel meal McZhellikehr.  Wooh wee!  spagg midge mellot.  Jello mic tatum.  Trucka looger legga baby.  martial mic reg egg  trans mestrials
23:06:40 <schrejily> Mella Midge Mister Pluggity ricking.  Rab trab traisies.  fruggity hesterani knellect.  Rumpin dumpin dighole.  Rumpin Dumpin durds.  Barvis joon a hear a harvey snards.  Jellis mellis  Trelalix twixt nick davey.  Rawl eenf rurst o plast.  Rella mahole rick.
23:06:41 <schrejily> Scrunny mit tack pick jack.  I'm talkin bout plucky PLUCKIE pluckie o'hare.  withers ground ring air.  parchookalie buckle, weeh eeh.  pluckily boosier bael regget ramajot.  bartoofteein regleg.  Ret round hujamima bound.  Tickle me timbers.  Farg duddly uck uck darg marg.  Hosh a mosh a luke a leek a leggin!  Audacity of it all, you feel small
23:06:42 <schrejily> Clarbudgy cabujjin, Carblinkin carblastan carbleggegg.  Are bastion you jastuin.  We're all for the Kardassians who lost the war against the Federation, don't you tell worf we need another ration.  Fargleb skeeol skowl all bleb.  carmattick raticular pledge mahole heel.  Mettick marial mahoney blastokist
23:06:44 <schrejily> Shmartooty boots breath.  Rennimino rick taid.  Renniminnow rick taid.  Carbloochy bad ass.  Renna ma nick patrol.  A chucka oo maow maow, chucka oo maow maow, a chucka oo mow maow, chucka oo maow maow.  Panta hoasta leeka tolweth hade.  Rum dump dump digalagger.
23:06:44 <mephx> lol
23:06:45 <schrejily> Cannabalism regamalan.  Bardacian bull-horne mooses aren't in this quadrant of the galaxy.  Playin' Star Trek Online cause it's free to play, just like All Points Bulletin: Reloaded and Final Fantasy XIV.  Eee dah climp lah plocky ug tug tech.
23:06:47 <schrejily> I went out with twenty of those rebbity jellickers.  we're all midge millickers.  Puh reb deb dejjer.  Galactical tactical plack ass.  Rump tump tiddle doo, rump dump damn.  Ban ricky ban glicky jallo whip!  Pahorp pahilla thin meffrin.  Reggal dee deck shweener.  It doesn't eat muggo whip.
23:06:47 <Tesseraction> Ah, the weekly spam captain.
23:06:48 <schrejily> It's a piece of paiper.  Scrubbbity ass ragamahoun.  Raggity ass maga muffin.  maggity von heffrin  Shtooty mic blackened.  Shooty hick black and pick tatots.  hugga ghigga micomprin.  Don't fuck with my restaurant!  Truggity reg up rim dum.  a spoon contacts the kinigigal concern.  trust no one, tiger miller.
23:06:49 <schrejily> Michelle and jantsy with a banshee.  prebelally mobijowrist.  Fartily gas farts on someone's jacket.  Where's spongy brother.  eye heeker playmus guy.  Helly midge mushkin.  Rumina mee drowls wall width.
23:06:51 <schrejily> I've got your mother's pussy juice bottled, I sell it out of my house
23:06:53 <schrejily> S.ll.a.g.g.y mc pit street.  Hustler hova heeva Chick ova heeva ova heeva.  Braxalarian blalalxrals.  snuggity rab rab rabbits.  Snuggies aren't selling anymore.  most people don't know what a "snuggie" is.  Halla micka wheel wyaujtkchtpt.
23:06:54 <schrejily> Spaqqa miffa liffa leggin.  Terry baloris trickaleggal.  Sequester mlajjap  eastro diz  hamta wan ta licka holmus preed.  Scatty picka loon dunes.  Hoakalin McGregoar.  Roddy McFlyer.  Hillie Midge Millik!  Arfie McChaffer  Chickababy
23:06:55 <schrejily> Shaggy mig rehehehehehehp  Spleggy melajamick pick tatot.  Pegila meligomesk  pigilidack fellijiscrap  barckarian bustrap  piggin kegalarelej  shtooty shtipt kid  mlelagaraphix transslits
23:06:56 --- mode: ChanServ set +o edwardk
23:06:57 <schrejily> Milla jalaoft jitch breakfast  Peef pond pallooleol babble.  I had to have sex in diapers!  I HAD TO HAVE SEX IN DIAPERS!  diaper sniper days, everyone knows about sex. it pays  when my nickname used to be snake.
23:06:58 <schrejily> Puritalin baggy of gunk.  my name's not tristan it's rastan.  rallin for null like a holdy hook black ann.  Tiny tim, dick ass whim.  Shaloody shlock braze made.  Pullilcoch dravinarial balactal guarns.
23:06:59 --- mode: ChanServ set +o glguy
23:07:00 <schrejily> Albatross doog ee rook rack egg.  Wanny manilnorf  traggat muh hilli hole back street  pormande usft vadinal deena.  sex with a shoogie look laygie.  Zellamanorf worf wallow.  isn't that up the street?
23:07:01 <schrejily> Shlagg lagg McNellanorf.  I'm a jalooch jooch jeggal jalalicker.  Tricky ass jillickers.  Dev dev developers and wheat.  /jalack a mic taxle\  juki al juba nas wat eerie fun, jest maleel oo had, lala in mackmod.  Fifty tramps.
23:07:03 <schrejily> Mister Doofie's diapers.  Pahole hell wack pahole hell paiper.  jegga rilla ma jorf.  plack a pleek meladromic mezzistove  tricky the band needs a tan  no one cares about care bears  eatch mizzle tag the mazer milojprafft malidge praft
23:07:04 <schrejily> Mahole hack mellow the wiper.  Milla janil.  plex kuying flying trev plegs.  Jaloffin Jalillobie.  I'm in your cement.  Parudgy rij jelellolebob.  blanky rich fandestriovon.  Galaxio trabble.  Hef a heavy hompfrin pole.  Jalooshitty scrooch
23:07:06 <schrejily> I've got more track ass gangsta shit than you could ever come up with.
23:07:07 --- mode: glguy set +b *!~poopee@112.145.28.107
23:07:09 --- kick: schrejily was kicked by edwardk (Your behavior is not conducive to the desired environment.)
23:07:15 <Tesseraction> Thanks edwardk!
23:07:17 <elliott> not conducive to the desired environment indeed
23:07:23 --- mode: glguy set +b *!*@112.145.28.107
23:07:35 <edwardk> sorry was distracted
23:07:38 --- mode: glguy set -b *!~poopee@112.145.28.107
23:10:01 <mzero> "Thylacoleo carnifex" is quite a reference for a spamtroll
23:11:10 <Ralith> that was weird
23:12:21 <mzero> was that like Markov-chain swearing trained on a combination of sex-chat and Wikipedia?
23:13:01 <liyang> mzero: re (stuff before the spam), there's cabal-sort.
23:13:29 <mzero> llyang - we already use the cabal library in HP to get the order
23:13:37 <M30W> Dahell?
23:13:58 <mzero> but what mephx was after requires more than that - we need dependency tree to know what can be done in parallel
23:14:20 <liyang> mzero: I mean to use cabal-sort to get the inter-package dependencies.
23:14:21 <wereHamster> how do I convert a Fixed to Integer (by multiplying the value with the resolution)?
23:14:41 <mzero> overall, I doubt it's worth the effort - but if someone wants to send me a patch to do it -- I'm all ready to merge it in! :-)
23:15:32 <mephx> mzero: You may build GHC from source, but this requires GHC. To understand
23:15:36 <mephx> recursion…
23:15:57 <liyang> mzero, mephx: we build multiple cabal packages in parallel in our build system with the help of cabal-sort… I'm not sure I understand what's different here.
23:16:10 <liyang> mephx: well-founded, so we're okay.
23:16:23 <mzero> noting - only building Haskell Platform is a bit trickier - you have to do it WITHOUT cabal !
23:16:24 <mephx> liyang: use that aswell for the platform
23:16:33 <mephx> simple
23:16:33 <mzero> since HP provides cabal!!!
23:16:45 <mephx> chicken egg
23:17:19 <liyang> Use a previous (or pre-built) HP to build the current?
23:17:41 <mephx> liyang: if binary stuff comes with ghc, why not the same with hp?
23:19:00 <mzero> wereHamster: fromRational . toRational     I think
23:19:08 <mzero> :t fromRational . toRational
23:19:09 <lambdabot> (Fractional b, Real a) => a -> b
23:19:38 <mzero> Not sure I ever grok'd Fixed
23:21:34 * M30W was compiling something before.... Forgot what it was. xD htop ♥ Ohh. :)
23:31:09 <rfw> @pl \(X (Y x)) -> f x
23:31:09 <lambdabot> (line 1, column 5):
23:31:09 <lambdabot> unexpected "("
23:31:09 <lambdabot> expecting operator or ")"
23:31:18 <rfw> @pl \x -> f x
23:31:18 <lambdabot> f
23:31:21 <shachaf> What do I do about errors like: <interactive>: /home/shachaf/.cabal/lib/lens-3.8/ghc-7.6.1/HSlens-3.8.o: unknown symbol `profunctorszm3zi1zi2_DataziProfunctorziUnsafe_zdfProfunctorZLzmzgZR_closure'
23:31:42 <rfw> @pl \(X x) -> f x
23:31:42 <lambdabot> (line 1, column 5):
23:31:42 <lambdabot> unexpected "x"
23:31:43 <lambdabot> expecting operator or ")"
23:31:46 <rfw> :(
23:31:57 <shachaf> rfw: It's impossible. What do you expect?
23:32:03 <rfw> shachaf: just wondering
23:32:14 <elliott> f . review _X
23:43:14 <wereHamster> mzero: not quite. I'd like to convert a "1.01" :: Fixed E2 into 101 :: Int
23:43:31 <mzero> hmmm... no idea
23:45:06 <liyang> wereHamster: that's the problem with Fixed. You can't directly get the representation out. You'll have to multiply it by 100 then round to an Int.
23:45:38 <wereHamster> liyang: yes, But then I'd need to know that it's an E2
23:45:50 <liyang> But you do, don't you?
23:46:03 <wereHamster> so it seems there is no way to convert Fixed a -> Int and then to Fixed a again without knowing the a
23:47:35 <liyang> wereHamster: (HasResolution a) => Fixed a -> Integer
23:48:28 <liyang> (That might not be your type…)
23:51:23 <liyang> > (\ n -> round (n * fromInteger (resolution n)) :: Integer) (1 :: Fixed E2)
23:51:24 <lambdabot>   100
