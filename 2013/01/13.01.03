00:13:22 <ivanm> zxq9: how is it ambiguous? "The Current and previous releases of qtHaskell are preview versions and are released under the terms of the GPL."
00:13:33 <ivanm> unless I've found an old version (the one on berlios)
00:23:52 <zxq9> ivanm: The license terms that are distributed with the binary state otherwise, as does the cabal.hs ("all rights reserved"). The terms in the LICENSE file are completely ambiguous as to what you can use it for, and only covers redistribution.
00:25:00 <zxq9> ivanm: Details like that guarantee that tiny companies like mine that would like to use it for real projects and support it can't. And without that kind of commercial support nothing is going to get real traction.
00:28:59 <Ralith> zxq9: is the author not responding to emails?
00:31:41 <zxq9> Ralith: No idea (yet). In any case we'll need to compare it against hqk and decide which is more promising long-term before worrying much yet.
00:32:06 <M30W>  Without using Word16, how might one wrap say `100000` to `34464` but as an actural Integer ? Cleanest I can get is.. `fromInteger 100000 :: Word16` But the type is Word16. Would there be a cleaner way to take the wrapping/overflow and return an Int?
00:33:04 <M30W> > let x = fromIntegral (fromInteger 100000 :: Word16) :: Integer; :t x
00:33:05 <lambdabot>   <hint>:1:65: parse error on input `:'
00:33:10 <Ralith> > 100000 `mod` 2^16
00:33:11 <lambdabot>   34464
00:33:28 <M30W> > fromIntegral (fromInteger 100000 :: Word16) :: Integer
00:33:29 <lambdabot>   34464
00:33:35 <M30W> Ralith: Thanks. :)
00:34:04 * M30W thought of % but not `mod`. Haha
00:41:07 <Jafet> > 100000 .&. 0xffff
00:41:09 <lambdabot>   34464
00:41:29 <M30W> O.o
00:42:33 <M30W> > outStrLn $ show $ sum $ map (read :: String -> Integer) ["53","64","12"]
00:42:35 <lambdabot>   Not in scope: `outStrLn'
00:42:35 <lambdabot>  Perhaps you meant one of these:
00:42:35 <lambdabot>    `putStrLn' (im...
00:42:39 <M30W> > putStrLn $ show $ sum $ map (read :: String -> Integer) ["53","64","12"]
00:42:41 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
00:42:41 <lambdabot>    arising from a use of ...
00:43:15 <M30W> That works here? O.o
00:43:25 <Ralith> > sum $ map (read :: String -> Integer) ["53","64","12"]
00:43:26 <lambdabot>   129
00:44:33 <M30W> Ralith: hPutStrLn hdl $ show $ sum $ map (read :: string -> Integer) ["53","64","12"]
00:44:52 <srhb> M30W: It's generally bad form to chain uses of $, instead use . to compose your functions and $ before the final argument
00:45:18 <M30W> srhb: Err, I didn't ask my question ** How could that be made cleaner? ;)
00:45:21 <M30W> Thanks ^_^
00:45:50 <srhb> M30W: If you only need to print to stdout, print instead of hPutStrLn h . show
00:45:56 <M30W> hPutStrLn hdl . show . sum $ map (read :: String -> Integer) ["53","64","12"]
00:46:13 <M30W> srhb: hdl -> socket, so.. Not stdout :)
00:46:35 <srhb> M30W: Alright. Move the $ to just before the final list
00:46:50 <srhb> You do get an extra symbol, but it makes it clearer what is going on
00:47:16 <M30W> putStrLn . show . sum . map (read :: String -> Integer) $ ["53","64","12"]
00:47:19 <srhb> Right.
00:47:29 <M30W> :)
00:47:42 <srhb> M30W: (I don't like read -> show chains, but I'm assuming you have reasons for the example)
00:47:44 <M30W> srhb: Is there any way that could be made cleaner?
00:48:01 <M30W> srhb: sx -> getArgs
00:48:24 <M30W> well.. let (x:xs) = words line
00:48:25 <srhb> M30W: You could combine sum and map to a single fold, but I would advise against it, sum . map is more Haskelly and clearer to read
00:48:29 <M30W> Not getargs; that was different.
00:49:24 <M30W> srhb: For understanding purpous; what do you mean exactly? What would be the alt for using a single fold?
00:50:37 <Ralith> :t foldr ((+) . read) 0
00:50:38 <lambdabot> (Num b, Read b) => [String] -> b
00:51:07 <M30W> O.o
00:51:11 <srhb> > foldl' ((+) . read) 0 ["0", "22", "56"]
00:51:13 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
00:51:13 <lambdabot>    arising from a use of `GHC...
00:51:16 <srhb> Ugh
00:51:25 <srhb> > foldr ((+) . read) 0 ["0", "22", "56"]
00:51:27 <lambdabot>   78
00:51:54 <M30W> Hmm
00:52:09 <M30W> 19:48         srhb | M30W: You could combine sum and map to a single fold, but I would advise against it, sum . map is more Haskelly and clearer to read
00:52:24 <srhb> M30W: I assume you're quoting me for truth. :P
00:52:25 <M30W> srhb: To me; that fold seems a little cleaner. What do you mean by Haskelly?
00:52:36 <srhb> M30W: Easier to read. Why do you think the fold is cleaner?
00:52:41 <M30W> srhb: Quoting cause questioning you ^
00:52:42 <M30W> lol
00:53:00 <M30W> srhb: Less to read and it makes sense except that zero ?
00:53:09 <M30W> unless..
00:53:14 <M30W> 0 + 0 + 22 +56 ?
00:53:16 <srhb> Right
00:53:20 <M30W> Heh
00:53:26 <srhb> Because...
00:53:34 <srhb> > foldr ((+) . read) 0 []
00:53:36 <lambdabot>   0
00:53:46 <M30W> > map ((+) . read) ["54","645","23"]
00:53:47 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
00:53:47 <lambdabot>    arising from a use of `M83656...
00:53:59 <M30W> Hehe
00:54:06 <srhb> M30W: With map, each element is not related to any other, so + is nonsensical
00:54:14 <M30W> Ahh
00:54:18 <M30W> Fair enough
00:54:27 <M30W> srhb: I still find that fold cleaner. :)
00:54:43 <srhb> M30W: Well, be my guest.
00:54:50 <M30W> ^_^
00:55:09 <M30W> Hmm
00:55:20 <Ralith> with laziness, I think it comes out about the same
00:55:22 <srhb> You should note that for big lists, strict operators like (+) are a bad fit for any fold but foldl' -- and sum has the same problem
00:55:28 <srhb> Ralith: Computationally, exactly the same
00:55:33 <M30W> Hmm ->
00:55:43 <M30W> Hmm -> Nvm, I forgot to type that zero.
00:56:15 <srhb> @src foldr
00:56:15 <lambdabot> foldr f z []     = z
00:56:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:56:34 <Ralith> srhb: yeah, but it's a lot easier to write it prettily if you use foldr :D
00:56:45 <srhb> Yep.
00:56:47 <srhb> No flips.
00:56:51 <M30W> runhaskell x.hs 66666 # Listening on 1130
00:56:52 <M30W> :)
00:57:40 * M30W now has a math daemon running on his computer that supports only addition.
00:57:43 <M30W> lol
00:57:48 <srhb> M30W: :)
00:58:05 <M30W> Well; ping/echo/quit wouldn't count haha
00:58:10 <danr> M30W: nifty!
00:58:34 <M30W> danr: For when.... You have literally nothing but netcat/telnet avaliable :P
00:59:20 <danr> M30W: precisely! I hate when that happens and I have to sum numbers!
00:59:26 * M30W goes back to trying to learn more haskell by finding ways to get stuck. :)
00:59:32 <M30W> danr: lol
01:00:00 <Jafet> Just root a public telnet service to gain access to dc.
01:00:12 <srhb> Jafet: Hard without a shell
01:00:17 <srhb> :P
01:00:35 * M30W loves the word "hard" cause it's not impossible. :D
01:01:12 <M30W> > maxBound `mod` 2^16
01:01:13 <lambdabot>   Ambiguous type variable `a0' in the constraints:
01:01:13 <lambdabot>    (GHC.Enum.Bounded a0)
01:01:13 <lambdabot>  ...
01:01:29 <M30W> > maxBound :: Word16
01:01:30 <M30W> lol
01:01:31 <lambdabot>   65535
01:01:44 <M30W> > (maxBound :: Word16) +5
01:01:45 <lambdabot>   4
01:01:53 <M30W> One way to take 1 !
01:02:02 <M30W> ever itteration
01:02:08 <M30W> > (maxBound :: Word16) +500000
01:02:10 <lambdabot>   41247
01:02:13 <M30W> :D
01:03:00 <M30W> > 2^2^20 `mod` 2^8
01:03:02 <lambdabot>   0
01:03:05 <M30W> > 2^2^20 `mod` 2^16
01:03:06 <lambdabot>   0
01:03:09 <M30W> :(
01:03:18 <M30W> > 2^2^20 `mod` 2^20
01:03:19 <lambdabot>   0
01:03:27 <srhb> M30W: Are you failing math? :P
01:03:33 <M30W> srhb: Hehe
01:04:04 <M30W> srhb: And no; in school (year 10 this comming year) I'm top of the class. Lol.
01:04:12 <srhb> :-)
01:04:13 <M30W> Oh derp
01:04:17 <M30W> Mega fail lol
01:04:30 <M30W> > 2^2^20*3 `mod` 2^20
01:04:31 <lambdabot>   0
01:04:36 <M30W> Blah
01:04:44 <M30W> > 34676432462467263 `mod` 2^20
01:04:45 <lambdabot>   53439
01:04:48 <M30W> :)
01:05:05 <M30W> Why was that * was meant to be +
01:05:52 * hackagebot snaplet-i18n 0.0.4 - snaplet-i18n  http://hackage.haskell.org/package/snaplet-i18n-0.0.4 (HaishengWu)
01:08:22 <M30W> Hehe.
01:09:05 * M30W wanted to take his music off random and didn't want to open another terminal or interface with his bot and had ghci open. :m +Network.MPD withMPD . random $ False
01:09:08 <M30W> :D
01:09:27 <M30W> withMPD $ random False *
01:09:32 <M30W> Same thing
01:09:41 <M30W> lambdabot: time
01:09:43 <M30W> @time
01:09:44 <lambdabot> Local time for M30W is Thu Jan  3 20:09:27 2013
01:09:59 <M30W> Hah
01:10:04 <M30W> I don't want my time >_<
01:10:07 <M30W> @time lambdabot
01:10:07 <lambdabot> I live on the internet, do you expect me to have a local time?
01:10:12 <M30W> @time srhb
01:10:13 <lambdabot> Local time for srhb is Thu Jan  3 10:09:56 2013
01:10:50 <hpaste> Hrumph pasted “Critique this first attempt at writing Haskell” at http://hpaste.org/80138
01:11:18 <hrumph> ok i finished my validation code excercise
01:11:28 <hrumph> i put some comments at the bottom
01:11:47 <hrumph> i made sure to include one do block
01:13:41 <t7> hrumph: its not idiomatic to use {}'s with do
01:14:03 <t7> people generally use white space instead
01:14:12 <hrumph> ok i'll try to conform
01:14:22 <hrumph> that will be hard for me thought because of my C background
01:14:30 <srhb> hrumph: Most people align their <-s too
01:14:38 <srhb> (where it's reasonable)
01:15:04 <hrumph> ok done
01:15:07 <hrumph> both done
01:15:32 <Ralith> spaces on both sides of ->
01:15:36 <Ralith> and ::
01:16:04 <hrumph> where i had to declare an instance for Either is there an import that has exactly that so i don't have to declare it myself?
01:16:10 <M30W> @hoogle Word16
01:16:10 <lambdabot> Data.Word data Word16
01:16:10 <lambdabot> Data.Text.Foreign dropWord16 :: I16 -> Text -> Text
01:16:10 <lambdabot> Data.Text.Foreign lengthWord16 :: Text -> Int
01:16:11 <hrumph> a monad instance that is
01:16:19 <M30W> @hackage Data.Word
01:16:19 <lambdabot> http://hackage.haskell.org/package/Data.Word
01:16:19 <srhb> hrumph: Instead of [Char] write String
01:16:19 <M30W> lol
01:16:27 <M30W> D:
01:16:40 <M30W> What's the package lol?
01:16:48 <srhb> hrumph: Either is in the Prelude, is it not
01:16:58 <`ramses> hrumph: on what version of ghc are you? On 7.6 I don't need to import anything for the either instance
01:17:12 <`ramses> on 7.4 you need to import Control.Monad.Instances
01:17:12 <hrumph> for the monad declaration ?
01:17:20 <srhb> hrumph: The instance declaration, yes.
01:17:28 <srhb> hrumph: You don't need any imports.
01:17:39 <hrumph> 7.4.2
01:17:47 <hrumph> that problem will be solved in a week when i install fedora 18 then
01:17:54 <`ramses> ah, so import Control.Monad.Instances
01:17:54 <hrumph> if it really goes live in a week
01:18:05 <srhb> M30W: I think you are looking for @index
01:18:31 <M30W> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Word.html#Word8
01:18:34 <M30W> #include "MachDeps.h"
01:18:39 <srhb> hrumph: I'm on 7.4.2 and I need no imports for Either
01:18:40 <M30W> O.o Haskell aint C.
01:18:51 <M30W> C library works?
01:19:03 <hrumph> srhb i don't need an import to use either. i need an import for the monad instance declaration
01:19:13 <hrumph> the monad instance declaration for either
01:19:15 <srhb> hrumph: well, that's what I meant. Are you sure?
01:19:16 <M30W> C header *
01:19:20 <`ramses> srhb: really? I don't have an either instance for monad in scope with 7.4.2
01:19:31 <srhb> `ramses: That's odd.
01:20:24 <hrumph> import Control.Monad.Instances worked...
01:20:55 <srhb> I must have done something weird with mine...
01:21:14 <hrumph> shrug it'll improve soon anyway. they've been working on getting haskell right for fedora 18
01:21:30 <hrumph> it will be all up todate in a week i hope
01:21:39 <hpaste> “`ramses” pasted “Monad instances in Prelude” at http://hpaste.org/80139
01:21:44 <srhb> Either wya, a few imports aren't dangerous. :)
01:21:44 <M30W> Funny how Data.Word -> Word8/16/etc aren
01:21:45 <hrumph> for fedora 19 they plan on having yesod as a package too
01:21:50 <M30W> t words but Ints
01:22:03 <M30W> s,\n,',
01:22:22 <`ramses> srhb: ^ Those are the instances in 7.4.2 and 7.6.1, with -ignore-dot-ghci to avoid any modifications
01:22:42 <hrumph> oh this is weird
01:22:54 <hrumph> its not complaining about the missing instance now...
01:22:58 <hrumph> i don't know what's going on
01:23:06 <hrumph> its ok now but i swear it was complaining earlier
01:23:19 <`ramses> it should be complaining on 7.4...
01:23:55 <hrumph> ok now it complains after i restarted ghci
01:24:01 <hrumph> so its back to complaining
01:24:24 <hrumph> so i do have to have the extra Impor line in after all
01:24:50 <srhb> `ramses: Is there a proper readMaybe in the new Prelude? :D
01:24:53 <M30W> putStrLn $ "Listening on " ++ show (port `mod` 2^16) -- Can anyone see any clean way to remove those parens?
01:25:30 <Jafet> putStrLn $ "Listening on " ++ show port
01:25:53 * hackagebot spy 0.7 - A compact file system watcher for Mac OS X, Linux and Windows  http://hackage.haskell.org/package/spy-0.7 (StefanSaasen)
01:25:55 <M30W> Jafet: If port is higher than maxBound :: Word16/PortNumber then it'll give the wrong number.
01:26:03 <`ramses> srhb: don't think so... I guess they just added some extra imports (deliberately or not)
01:26:09 <M30W> I.e It *CAN'T* listen on 100000
01:26:15 <srhb> `ramses: Ah well.
01:26:19 <Jafet> Port numbers cannot be higher than that, so it makes no difference.
01:26:29 <Nereid> > 100000 :: Word16
01:26:30 <lambdabot>   34464
01:26:56 <Nereid> putStrLn $ "Listening on " ++ show (fromIntegral port :: Word16)
01:27:10 <`ramses> srhb: I have 7.6.1 here and had to make some assignments for university that had to compile on their install of 7.4.2. I always had to add in more imports when trying to compile the 7.6 code on 7.4
01:27:12 <Nereid> or just get it from the PortNumber.
01:27:50 <srhb> `ramses: Right. :) I think the default imports of Prelude have been a bit too conservative. Who doesn't want Control.Monad and <$> for instance.
01:28:53 <Nereid> make your own prelude.
01:29:13 <`ramses> yeah, those would be pretty useful, along with some of the none clashing Data. modules maybe. But it doesn't bother me too much either
01:29:32 <srhb> Well, me neither.
01:33:40 <Lethalman> @tell neutrino in the end I've wrapped muevel to manipulate the arguments passed by lambdabot
01:33:40 <lambdabot> Consider it noted.
01:35:50 <M30W> @tell M30W testing
01:35:50 <lambdabot> You can tell yourself!
01:35:54 <M30W> :(
01:35:58 <Lethalman> lol
01:36:13 <M30W> @tell archeyDevil testing
01:36:13 <lambdabot> Consider it noted.
01:36:47 <M30W> Fail why did I write "testing" O.o
01:36:57 <srhb> archeyDevil: I was wondering myself.
01:37:01 <srhb> archeyDevil: Now say something.
01:37:05 <hrumph> i', glad i made the effort to learn what monads and monad transformers really are
01:37:06 <archeyDevil> Yo
01:37:06 <lambdabot> archeyDevil: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:37:11 <archeyDevil> O.o 2?
01:37:18 <hrumph> i read somewhere just to use them at first and then learn later
01:37:26 <archeyDevil> 20:36    lambdabot | BadKitty said 14d 18h 32m ago: test
01:37:28 <hrumph> but that wouldn't of worked for me
01:37:32 <archeyDevil> Hehe, forgot about that
01:37:40 <BadKitty> ^_^
01:37:47 <srhb> hrumph: It wouldn't have for me either. Though I'm slightly fuzzy on how mtl works still.
01:38:21 * BadKitty was about to change nick again; but already too many changes too quickly.... I'ma leave it for a bit lol
01:39:15 <srhb> BadKitty: There are some offtopic haskell channels if you feel you're spamming here. (you are, a bit. ;))
01:41:27 <M30W> @tell BadKitty you have homework to do.
01:41:27 <lambdabot> Consider it noted.
01:41:30 <M30W> :)
01:41:42 <M30W> Will, almost certain never be read :D
01:42:11 <`ramses> M30W: you suffering from a dissociative disorder? :)
01:42:39 <M30W> `ramses: From... What??
01:42:46 <M30W> Can't even pronounse that.
01:43:40 <`ramses> hehe, what people mostly refer to as schizophrenia, the multiple identity thingy
01:43:48 <M30W> Heh
01:43:52 <M30W> Quite haha.
01:44:04 <`ramses> although schizophrenia is something completely different
01:44:05 <Nereid> you may feel welcome in #haskell-blah
01:44:06 <Nereid> :p
01:44:10 <M30W> Nahh; I don't change that often
01:44:39 <simpson> `ramses: Please don't joke about DID or other mental illnesses.
01:45:03 <`ramses> simpson: ok sorry, no offense intended
01:45:13 <simpson> No worries.
01:45:46 <zett_zelett> How old is learnyouahaskell?
01:46:00 <merijn> zett_zelett: I'd guess about 2 years now?
01:46:11 <zett_zelett> Thanks.
01:46:15 <`ramses> the book's first print appears to be 2011
01:46:44 <zett_zelett> I found a minor mathematical mistake and I'm unsure whether to contact Bonus about it, it's rather pedantic.
01:46:59 <`ramses> elaborate :)
01:47:23 <zett_zelett> http://learnyouahaskell.com/starting-out here he (or she?) writes that:
01:47:25 <zett_zelett> ghci> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]
01:47:39 <zett_zelett> gives you "a list of all possible triangles with sides under or equal to 10. "
01:47:54 <zett_zelett> But that's not true, is it? Because there's no triangle with sides 1,1,10.
01:48:02 <simpson> But that doesn't work because of the triangle inequality, right.
01:48:51 <`ramses> zett_zelett: there ought to be some constraint on what ends up in the resulting list as well, no?
01:48:52 <zett_zelett> Or maybe it is in hyperbolic geometry or something.
01:48:54 <merijn> zett_zelett: eh...it should?
01:49:17 <merijn> > let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ] in (1,1,10) `elem` triangles
01:49:18 <lambdabot>   True
01:49:20 <Nereid> hyperbolic geometry still satisfies the trinagle inequality.
01:49:36 <merijn> zett_zelett: (1,1,10) is in there
01:50:04 <xlr> but 1,1,10 is not a triangle
01:50:08 <zett_zelett> merjin: but there is no real triangle existing in the world outside with lengths 1, 1 and 10.
01:50:10 <merijn> Why not?
01:50:10 <Nereid> no, it's a triple of numbers.
01:50:17 <zett_zelett> merijn*
01:50:26 <merijn> oh, right
01:50:28 <simpson> > [ (a, b, c) | a <- [1..10], b <- [a..10], c <- [b..10], a + b >= c ]
01:50:30 <lambdabot>   [(1,1,1),(1,1,2),(1,2,2),(1,2,3),(1,3,3),(1,3,4),(1,4,4),(1,4,5),(1,5,5),(1...
01:50:32 <merijn> Minor nitpick
01:50:37 <simpson> Oh, oops.
01:50:38 <srhb> merijn: In order for it to be a triangle the sum of lengths of two sides must be greater than the last..
01:50:40 <simpson> > [ (a, b, c) | a <- [1..10], b <- [a..10], c <- [b..10], a + b > c ]
01:50:41 <lambdabot>   [(1,1,1),(1,2,2),(1,3,3),(1,4,4),(1,5,5),(1,6,6),(1,7,7),(1,8,8),(1,9,9),(1...
01:50:47 <Nereid> simpson: not quite, (10,1,1) is in there
01:50:56 <`ramses> just not on a flat space :)
01:51:02 <simpson> Nereid: Yeah, you gotta specify all three constraints, I guess.
01:51:05 <merijn> `ramses++
01:51:15 <zett_zelett> Nereid: hyperbolic geometry still satisfies the trinagle inequality. -> But the distance function isn't the same?
01:52:09 <zett_zelett> Oh, wait.
01:52:19 <zett_zelett> Fallacy.
01:52:23 <Nereid> huh
01:52:49 <zett_zelett> I was thinking about the lengths as coordinates of points.
01:52:51 <Nereid> the triangle inequality is always satisfied if distance is measured by geodesics
01:54:06 <zett_zelett> (I wasn't questioning the triangle inequality but I thought that (1,1,10) as a triple of points (wrong!) wouldn't satisfy it.)
01:54:17 <zett_zelett> (Or might satisfy it.)
01:54:32 <Nereid> heh.
01:56:01 <Nimatek> > let isTriangle (a,b,c) = longestSide > sum otherSides where longestSide = maximum [a,b,c]; otherSides = [a,b,c] \\ [longestSide] in [(a,b,c) | a <- [1..10], b <- [1..10], c <- [1..10], isTriangle (a,b,c)]
01:56:02 <lambdabot>   [(1,1,3),(1,1,4),(1,1,5),(1,1,6),(1,1,7),(1,1,8),(1,1,9),(1,1,10),(1,2,4),(...
01:56:15 <Nimatek> err
01:56:25 <Nimatek> > let isTriangle (a,b,c) = longestSide < sum otherSides where longestSide = maximum [a,b,c]; otherSides = [a,b,c] \\ [longestSide] in [(a,b,c) | a <- [1..10], b <- [1..10], c <- [1..10], isTriangle (a,b,c)]
01:56:26 <lambdabot>   [(1,1,1),(1,2,2),(1,3,3),(1,4,4),(1,5,5),(1,6,6),(1,7,7),(1,8,8),(1,9,9),(1...
01:56:30 <Nimatek> less than, of course.
01:57:12 <zett_zelett> Doesn't work, you need to check that every side is shorter than the sum of the other sides.
01:57:48 <zett_zelett> (a,b,c) defines a triangle ⇔ a < b + c and b < c + a and c < a + b
01:58:10 <Nimatek> Doesn't the line I posted do this?
01:58:41 <simpson> > [ (a, b, c) | a <- [1..10], b <- [1..10], c <- [1..10], a + b > c, a + c > b, b + c > a ]
01:58:43 <lambdabot>   [(1,1,1),(1,2,2),(1,3,3),(1,4,4),(1,5,5),(1,6,6),(1,7,7),(1,8,8),(1,9,9),(1...
01:59:44 <`ramses> > [(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..c], a^2 + b^2 == c^2]
01:59:46 <lambdabot>   [(3,4,5),(4,3,5),(6,8,10),(8,6,10)]
01:59:48 <zett_zelett> Nimatek: I guess it doesn't? It only checks whether the longest side is shorter than the sum of the others.
02:00:22 <Nimatek> zett_zelett: Yep, that's an equivalent definition.
02:00:30 <`ramses> > [(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2] -- no doubles
02:00:31 <lambdabot>   [(4,3,5),(8,6,10)]
02:02:40 <zett_zelett> Nimatek: Yeah, right. (I really had to think about this.)
02:02:41 <simpson> [ (x^2 - y^2, 2 * x * y, x^2 + y^2) | x <- [1..], y <- [1..], x > y ]
02:02:51 <simpson> > [ (x^2 - y^2, 2 * x * y, x^2 + y^2) | x <- [1..], y <- [1..], x > y ]
02:02:55 <lambdabot>   mueval-core: Time limit exceeded
02:03:08 <simpson> > [ (x^2 - y^2, 2 * x * y, x^2 + y^2) | x <- [1..10], y <- [1..10], x > y ] -- fiiiine
02:03:09 <lambdabot>   [(3,4,5),(8,6,10),(5,12,13),(15,8,17),(12,16,20),(7,24,25),(24,10,26),(21,2...
02:04:09 <Nimatek> simpson's version is better though :)
02:04:14 <Nimatek> The first one.
02:04:26 <Nereid> Control.Monad.Omega is good.
02:04:34 <mikeplus64> !hoogle omega
02:04:36 <`ramses> simpson: you can avoid the extra constraint by modifying the lower bound :)
02:04:43 <mikeplus64> @hoogle omega
02:04:43 <lambdabot> package Omega
02:04:43 <lambdabot> package omega
02:04:43 <lambdabot> package control-monad-omega
02:04:52 <mikeplus64> hurp
02:04:54 <simpson> `ramses: Probably.
02:05:34 <Nereid> > [ (x^2 - y^2, 2 * x * y, x^2 + y^2) | x <- [1..], y <- [1..x] ]
02:05:35 <lambdabot>   [(0,2,2),(3,4,5),(0,8,8),(8,6,10),(5,12,13),(0,18,18),(15,8,17),(12,16,20),...
02:05:43 <Lethalman> @hoogle (a -> a) -> a -> [a]
02:05:43 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
02:05:43 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
02:05:43 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
02:05:56 <Nereid> > [ (x^2 - y^2, 2 * x * y, x^2 + y^2) | x <- [1..], y <- [2..x-1] ]
02:05:58 <lambdabot>   [(5,12,13),(12,16,20),(7,24,25),(21,20,29),(16,30,34),(9,40,41),(32,24,40),...
02:06:01 <Nereid> oops
02:06:06 <Nereid> meh
02:06:18 <Lethalman> > iterate (\(_,g) -> next g) (next $ mkStdGen 123)
02:06:20 <lambdabot>   [(4921044,4961736 40692),(1462061206,970416508 1655838864),(1639921808,1595...
02:06:59 <mauke> > iterate (next . snd) (next $ mkStdGen 123)
02:07:01 <lambdabot>   [(4921044,4961736 40692),(1462061206,970416508 1655838864),(1639921808,1595...
02:07:20 <mauke> > iterate (snd . next) (mkStdGen 123)
02:07:21 <lambdabot>   [124 1,4961736 40692,970416508 1655838864,1595848509 2103410263,858493321 1...
02:07:35 <mauke> :t unfoldr
02:07:36 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
02:07:56 <mauke> > iterate (Just . next) (mkStdGen 123)
02:07:58 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a0'
02:07:58 <lambdabot>              with actual...
02:08:01 <mauke> > unfoldr (Just . next) (mkStdGen 123)
02:08:03 <lambdabot>   [4921044,1462061206,1639921808,1133905431,2099244251,45143271,169785971,127...
02:08:16 <Jafet> > randoms $ mkStdGen 123
02:08:17 <lambdabot>   [5912679320616661859,5085716927896574010,-5356009888664962999,-409439400294...
02:13:04 <Lethalman> weird
02:13:09 <Lethalman> same seed different numbers?
02:13:13 <Lethalman> :t randoms
02:13:14 <lambdabot> (RandomGen g, Random a) => g -> [a]
02:13:25 <Lethalman> probably Random is not Int
02:13:44 <Lethalman> @src Random
02:13:44 <lambdabot> class Random a where
02:13:44 <lambdabot>   random    :: RandomGen g => g -> (a, g)
02:13:44 <lambdabot>   randoms   :: RandomGen g => g -> [a]
02:13:44 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
02:13:44 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
02:13:46 <lambdabot>   randomRIO :: (a,a) -> IO a
02:13:48 <lambdabot>   randomIO  :: IO a
02:13:48 <Lethalman> :S
02:13:57 <Lethalman> thought output was limited sorry
02:17:49 <ziman> hello, I'm trying to install a package (Agda-2.3.2.0) and I'm getting errors about `process' and `directory': http://hpaste.org/80141
02:18:24 <ziman> i've tried installing, unregistering, reinstalling etc. the packages but the error persists no matter what
02:18:58 <ziman> and I've noticed that the Agda installation process always tries to compile directory and process from scratch, regardless of whether they're in the system already
02:19:34 <ziman> does anybody have a clue what might be going on? on my other box, Agda installed flawlessly
02:19:38 <shachaf> That doesn't sound right.
02:19:48 <shachaf> Is it that it wants a different version of process/directory from what you have?
02:20:04 <ziman> it has two equal versions with different hashes
02:22:22 <hpaste> ziman pasted “process hashes” at http://hpaste.org/80142
02:23:57 <ziman> I tried unregistering the packages and deleting them from package.conf.d (which might have broken things further) but the behavior I see is the same
02:27:15 <ziman> I'll nuke my ~/.ghc and ~/.cabal, I just hoped that somebody would recognize the error :)
02:27:58 * shachaf typically renames rather than deletes.
02:28:15 <ziman> that's what I do, too
02:28:30 <srhb> I tell people online that I rename rather than delete.
02:32:36 <hiptobecubic> I shamelessly just delete it
02:32:58 <Jafet> You rename directories? Where's your backup?
02:34:22 <Wherewhat> I'm trying to get a list of lists of heads of a list of lists, what I have right now is: map (map head) $ takeWhile (all (not . null)) $ iterate (map tail) [[1,2,3],[2,3],[4,3,2]]
02:34:28 <ziman> do you backup ~/.cabal and ~/.ghc? :)
02:34:36 <Wherewhat> I'm still learning Haskell though, was wondering if there was a better way
02:34:43 <Jafet> I back up /dev/sda.
02:35:37 <srhb> Wherewhat: Pain!
02:35:50 <Wherewhat> srhb: D:
02:36:03 <srhb> Wherewhat: Write down the type you have and the type you want to get
02:36:13 <Jafet> That is the best troll all day
02:36:43 <b_jonas> @hoogle foreach c. IO a -> St c a
02:36:43 <lambdabot> Parse error:
02:36:43 <lambdabot>   foreach c. IO a -> St c a
02:36:43 <lambdabot>            ^
02:36:50 <Jafet> :t map (map head) . takeWhile (all (not . null)) . iterate (map tail)
02:36:51 <lambdabot> [[b]] -> [[b]]
02:36:54 <b_jonas> @hoogle IO a -> St c a
02:36:54 <lambdabot> Did you mean: IO a -> ST c a
02:36:54 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
02:36:54 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
02:37:04 <b_jonas> @yes
02:37:04 <lambdabot> Maybe you meant: let oeis yow
02:37:43 <Wherewhat> Sorry, I feel stupid, you guys lost me
02:38:10 <srhb> Wherewhat: You have a list of lists? You want a list of the inner lists heads?
02:38:21 <`ramses> Wherewhat: looks like you're trying to transpose the list?
02:38:41 <Wherewhat> I'm trying to get the heads of a list, then the heads of the tails of that list etc, until there's no tails left
02:38:50 <Wherewhat> What I have does do what I want, It's just really ugly
02:39:20 <`ramses> Wherewhat: try with a fold :)
02:39:55 <`ramses> and have a look at the zip and zipWith functions
02:40:08 <srhb> Hmm, a fold isn't that obvious is it
02:40:17 <srhb> I'd make it a recursive definition instead. Seems simpler.
02:40:38 <`ramses> srhb: building up a result incrementally from a list, sounds like a fold to me...
02:40:46 <Wherewhat> I've no idea where I would start with a fold D:
02:41:17 <shachaf> What are you trying to do?
02:41:27 <srhb> `ramses: Only he want the front of each element for each iteration
02:41:32 <shachaf> What's the desired result for the list you gave, for example?
02:41:42 <Wherewhat> For the example I pasted I want
02:41:47 <HugoDaniel> hi
02:41:54 <Wherewhat> [[1,2,4],[2,3,3]]
02:42:12 <`ramses> srhb: yeah, that's not a problem me thinks :)
02:42:40 <`ramses> if the code is basically transposing, like I think it is
02:42:54 <srhb> `ramses: Well, how do you access every element from within the handler in fold? *boggle*
02:42:57 <Wherewhat> `ramses: nah that is what I want, for each iteration, I just want all the heads, each iteration being just the tails
02:43:28 <shachaf> > transpose [[1,2,3],[2,3],[4,3,2]]
02:43:29 <lambdabot>   [[1,2,4],[2,3,3],[3,2]]
02:43:44 <shachaf> > transposeOf traverse [[1,2,3],[2,3],[4,3,2]]
02:43:46 <lambdabot>   [[1,2,4],[2,3,3]]
02:43:46 <`ramses> srhb: you don't, but you can build up the transpose by cosidering every sublist
02:44:21 <srhb> `ramses: Sure, you could do that. Seems painful though. :P
02:44:38 <`ramses> > foldr (zipWith (:)) (repeat []) $ [[1,2,3],[3,4,5],[6,7]]
02:44:39 <lambdabot>   [[1,3,6],[2,4,7]]
02:44:49 <shachaf> Oh, people have already said that it's transpose.
02:44:55 <shachaf> So what's the question now?
02:45:06 <srhb> HOw to read the source code of transpose. :P
02:45:29 <Jafet> :t transposeOf
02:45:31 <lambdabot> LensLike ZipList s t [a] a -> s -> [t]
02:45:50 <`ramses> srhb: ^ not too bad I think :)
02:46:03 <srhb> `ramses: No, it isn't.
02:46:44 <Jafet> @src transpose
02:46:44 <lambdabot> transpose []             = []
02:46:44 <lambdabot> transpose ([]   : xss)   = transpose xss
02:46:44 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
02:46:46 <`ramses> only needs a case for the empty input list, that would give an infinite list of empty lists with this definition
02:46:51 <srhb> Seems quite obvious now that I've seen it. Ah well. :P
02:47:15 <srhb> `ramses: Why, doesn't zipWith break on shortest?
02:47:20 <Wherewhat_> Sorry, my router died
02:47:23 <Wherewhat_> I don't know how much I missed
02:47:51 <srhb> Wherewhat_: All of it. :P
02:47:53 <`ramses> srhb: what do you mean? it does I think, otherwise the result would have three sublists
02:48:06 <`ramses> Wherewhat_: look at the logs :)
02:48:17 <Wherewhat_> `ramses: checking now ;p
02:48:19 <Jafet> @where pi_10
02:48:19 <lambdabot> (take 100) [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]]
02:48:27 <Jafet> Oh hm
02:48:34 <Lethalman> what's that?
02:48:47 <`ramses> ugly
02:48:53 <Lethalman> @where
02:48:53 <lambdabot>  @where <key>, return element associated with key
02:48:57 <Jafet> Ok, I changed my mind, we should have the transpose one there
02:49:34 <Jafet> @where+ pi_10 (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
02:49:34 <lambdabot> Done.
02:50:10 <Lethalman> @hoogle Num a => a -> a -> a
02:50:10 <lambdabot> Prelude (*) :: Num a => a -> a -> a
02:50:10 <lambdabot> Prelude (+) :: Num a => a -> a -> a
02:50:10 <lambdabot> Prelude (-) :: Num a => a -> a -> a
02:50:58 <Lethalman> @hoogle (Num a, Num b, Num c) => a -> b -> c
02:50:59 <lambdabot> Prelude (*) :: Num a => a -> a -> a
02:50:59 <lambdabot> Prelude (+) :: Num a => a -> a -> a
02:50:59 <lambdabot> Prelude (-) :: Num a => a -> a -> a
02:50:59 <`ramses> srhb: ah I missunderstood your question, with an empty input the zipWith is never applied
02:51:25 <`ramses> srhb: foldr just returns the initial accumulator, which is repeat [] in this case -> infinite
02:51:39 <Wherewhat_> Ah, transpose is close to what I was after, except transpose keeps going if one of the lists is empty
02:51:43 <srhb> `ramses: Yeah.
02:52:02 <Jafet> @where pi_11
02:52:02 <lambdabot> [show(foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..4*2^n])!!n|n<-[0..]]
02:52:19 <Jafet> Atrocious.
02:52:30 <Jafet> @where+ pi_11 [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]]
02:52:30 <lambdabot> Done.
02:54:41 <hape01> @where Text.Parsec.String
02:54:41 <lambdabot> I know nothing about text.parsec.string.
02:55:24 <Jafet> @hoogle Text.Parsec.String
02:55:24 <lambdabot> Text.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
02:55:24 <lambdabot> Text.ParserCombinators.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
02:55:24 <lambdabot> package string-class
02:55:30 <Wherewhat_> Sorry, I'll stop asking about this, but last question because transpose seems to be what I was after, I'm just not sure how I would stop transpose at the end of the shortest sublist
02:55:32 <Lethalman> oh installed hoogle but I need a database, thought it used the online database
02:55:33 <hape01> :-)
02:55:47 <mauke> > [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]]
02:55:50 <lambdabot>   mueval-core: Time limit exceeded
02:55:57 * hackagebot keyvaluehash 0.3.1 - Pure Haskell key/value store implementation  http://hackage.haskell.org/package/keyvaluehash-0.3.1 (EyalLotem)
02:56:03 <mauke> > [show(foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..4*2^n])!!n|n<-[0..]]
02:56:07 <lambdabot>   mueval-core: Time limit exceeded
02:56:08 <Jafet> > (take 100) [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]]
02:56:09 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
02:56:21 <`ramses> Wherewhat_: my foldr version given above does that
02:57:00 <`ramses> Wherewhat_: or do ou really mean you don't want the results of the list following the shortest one?
02:57:12 <`ramses> you* lists*
02:57:59 <Wherewhat_> `ramses: no sorry what you did was what I was looking for, I missed it in the logs, thank you
02:58:43 <`ramses> Wherewhat_: make sure to use a pattern match to catch the empty list, cause that foldr gives an infinite list as result in that case
02:59:03 <Jafet> > transposeOf traverse []
02:59:05 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
02:59:09 <Jafet> shachaf: !!
02:59:33 <Wherewhat_> `ramses: ah, well I'm just going over it either way, still pretty new to haskell, takes me forever to get a mental picture of hwo things work D:
02:59:38 <Wherewhat_> how*
02:59:59 <`ramses> do you see how it works then?
03:00:27 <Wherewhat_> Not yet, bare with me (I'm stupid)
03:01:57 <Lethalman> is it possible to let a local installation of hoogle use the online hoogle database?
03:02:01 <Lethalman> instead of creating a local database
03:04:57 <Jafet> Don't you think that, as Herr Strangelove puts it, the entire point would be lost?
03:12:15 <Wherewhat_> `ramses: alright, got it rofl, took me a while. That's badass
03:14:36 <mikeplus64> why do people sometimes do "return $! ()"? surely () doesn't create a thunk?
03:14:41 <`ramses> Wherewhat_: good that you put in the effort, used to took me ages too but you get used to it :)
03:15:12 <zomg> Wherewhat_: haha, first time I hear anyone describe a programming language feature as "badass".. =)
03:15:24 <Wherewhat_> Rofl
03:16:09 <quicksilver> mikeplus64: cargo cult?
03:16:41 <quicksilver> mikeplus64: a fairly high proportion of uses of $! (and return $! in particular) seem motivated by voodoo rather than semantic knowledge.
03:19:11 <mikeplus64> quicksilver: seems so, i would have thought return () :: IO () would have been reliably optimized to a noop (and the example i read from io-streams was indeed :: IO ())
03:19:49 <quicksilver> mikeplus64: return () isn't exactly a noop
03:19:56 <quicksilver> it does indeed return the () after all :-)
03:20:08 <quicksilver> however it's a noop if it comes before >>
03:20:16 <quicksilver> (as is any other return)
03:20:35 <mm_freak_> mikeplus64: "return ()" by itself can't be optimized, but it can be in combination with other stuff
03:20:46 <mm_freak_> example:  return x >>= f = f x
03:22:45 <mikeplus64> mm_freak_: quicksilver: oh, ok. i will check if something silly like do { return (); return (); putStrLn "aaa"; return (); return (); } :: IO () compiles down to lots of returns before the putStrLn "aaa" (although for all i know those might vanish in core -> cmm?)
03:23:12 <mikeplus64> and if a return $! () does anything different to return () ;)
03:23:21 <mm_freak_> mikeplus64: IO is pretty lightweight, but i'm not sure if such an optimization is taking place
03:23:50 <mm_freak_> return $! () is very different and is unlikely to be optimized away
03:24:00 <zett_zelett> Which Prelude function takes [ "a", "b", …, "z"] to "abcde…z" and what is the best way to search functions by desired functionality?
03:24:11 <mm_freak_> zett_zelett: concat
03:24:23 <Lethalman> zett_zelett, @hoogle [String] -> [Char] maybe
03:24:38 <mm_freak_> mikeplus64: the rule is:  return x >>= f = f x, but return $! x = x `seq` return x
03:24:55 <mm_freak_> now you have a seq wrapper around the return, so the optimization rule does no longer apply
03:24:59 <zett_zelett> Thanks, mm_freak and Lethalman.
03:25:52 <quicksilver> return x >>= f ~~~ f x is not an optimisation rule as far as I know
03:25:54 <quicksilver> it's a law.
03:26:05 <quicksilver> but a law is not the same thing as an optimisation rule.
03:26:31 <quicksilver> when GHC does that optimisation it's just a natural consequence of inlining the definitions of >>= and return (in a particular monad)
03:27:03 <quicksilver> and the seq won't make that inlining fail.
03:27:38 <quicksilver> The seq should get removed, as far as I know, because () is a singleton object in the GHC implementation and the strictness analyzer should know it can't be _|_.
03:27:41 <mm_freak_> it will fail for function-like monads
03:27:47 <mm_freak_> and internally IO is implemented function-like
03:27:50 <mm_freak_> at least in GHC
03:28:04 <mikeplus64> quicksilver: how does inlining turn return x >>= f into f x? for say Maybe, it would be like Just x >>= f => case Just x of Just x -> f x; _ -> Nothing
03:28:18 <mikeplus64> or can ghc see that case expression is redundant?
03:28:22 <quicksilver> yes, it can.
03:28:26 <mikeplus64> neat
03:29:17 <quicksilver> mikeplus64: http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/spec-constr.pdf
03:30:07 <quicksilver> although I recall that detailed experience of SpecConstr turned out to be more subtle than the paper suggests.
03:30:13 <quicksilver> as is almost always the case.
03:30:53 <quicksilver> mm_freak_: don't see why it should fail for function monads.
03:31:33 <quicksilver> after inlining, that's beta reduction
03:31:43 <mm_freak_> quicksilver: i'm not sure how opaque functions are to GHC, but i was assuming a RULE, in which case it definitely fails
03:31:44 <quicksilver> GHC does beta reduction under some circumstances as far as I know.
03:31:50 <quicksilver> it's not a RULE, as I said.
03:32:04 <mikeplus64> quicksilver: ok, it seems basically anything return () :: IO () including return $! () will turn into nothing if it's inlined and not the "end" of the "IO block"
03:32:07 <quicksilver> it's a natural consequence of inlining followed by standard optimisations
03:32:22 <mikeplus64> in which case if it's inlined then it will disappear again
03:32:26 <quicksilver> yup
03:32:38 <quicksilver> GHC is fairly good at optimising when everything is known statically
03:32:45 <quicksilver> and you don't get much more 'known statically' than ()
03:32:50 <mm_freak_> i think it can optimize the return away in many simple cases, but as soon as 'x' is bound it probably won't get optimized
03:32:51 <mikeplus64> yeah :)
03:33:04 <mm_freak_> i mean the 'x' in return $! x
03:34:12 <quicksilver> mm_freak_: lambdas are not at all opaque, incidentally
03:34:19 <quicksilver> lambdas are very much inspectable and optimisable
03:34:35 <quicksilver> functions exported from another module are opaque
03:34:43 <quicksilver> (unless the inliner put their source in the .hi file...)
03:35:49 <mikeplus64> hm, i wonder if it is possible to do "partial inlinings" of functions -- so that for instance x >> y >> z >> w might by ~magic~ turn into let f = y >> z in x >> f >> w -- and if that would ever be desireable
03:36:34 <quicksilver> that's the opposite of inlining
03:36:38 <quicksilver> (outlining?)
03:37:03 <mikeplus64> i mean if you had a function = x >> y >> z >> w, and called it, it would produce that
03:37:32 <quicksilver> there are things called lambda lifting and let floating
03:37:43 <quicksilver> you have to be careful in general as they increase sharing and therefore cause memory leaks
03:38:50 <mikeplus64> more things to read about i guess
03:39:11 <Lethalman> is let x = foo the same as x <- return foo ?
03:39:39 <Taneb> Not quite but yes
03:39:45 <mikeplus64> Lethalman: it isn't the same, but x should be the same in both
03:39:58 <`ramses> Lethalman: if you're in a proper monad
03:40:02 <Taneb> Avoid the second one
03:40:19 <quicksilver> the second one is useful to (ab)use the pattern-match-failure-calls-fail thing
03:40:32 <quicksilver> but it looks ugly
03:40:43 <Lethalman> ah
03:40:54 <Lethalman> an example of why it wouldn't be the same?
03:41:45 <mikeplus64> Lethalman: if you had a naughty [] monad instance for example, you could have return _ = []
03:41:45 <`ramses> if return adds more then a minimal context, the second could cause side effects. But such a monad does not obey the monad laws, although it could be written of course
03:42:08 <mikeplus64> in which case let x = foo and x <- return foo would not be the same
03:42:14 <quicksilver> let (Just x) = Nothing -- makes x into an error-value
03:42:23 <quicksilver> Just x <- Nothing -- calls 'fail' in the monad
03:42:36 <quicksilver> sorry, missing return there
03:42:41 <quicksilver> Just x <- return Nothing -- calls 'fail' in the monad
03:42:52 <M30W> What would be a clean way to make case .... do f; dosomething x ... do f2; dosomething x. -> y f ... where y = ... dosomething x
03:43:00 <mikeplus64> > do Just x <- Nothing; return x
03:43:01 <lambdabot>   Nothing
03:43:03 <M30W> I mean; where would f go?
03:43:03 <`ramses> quicksilver: that would just bind x to Nothing
03:43:12 <M30W> y = do f; dosomething x?
03:43:15 <quicksilver> `ramses: nope.
03:43:41 <Lethalman> ok
03:43:43 <`ramses> huh? return Nothing == Just Nothing, isn't it?
03:43:52 <quicksilver> Just/Nothing is a bad example because it's now hard to demonstrate in the simplest fail-Monad.
03:44:08 <quicksilver> `ramses: only in the Maybe monad but even if it is, the <- unwraps the Just.
03:44:35 <`ramses> ah, true, sorry :)
03:44:50 <quicksilver> > do Left x <- return (Right "hi"); return x :: Maybe Int
03:44:52 <lambdabot>   Nothing
03:45:07 <quicksilver> > let Left x = Right "hi" in x
03:45:09 <lambdabot>   *Exception: <interactive>:3:5-23: Irrefutable pattern failed for pattern Da...
03:45:14 <quicksilver> different :)
03:46:09 <dongetit> Do I have to manually export everything in a module?
03:46:20 <quicksilver> the default is to export everythiing
03:46:24 <quicksilver> if you don't give an export list
03:46:41 <dongetit> quicksilver: I see! Thanks. Any way to blacklist instead of whitelist? :D
03:47:32 <mikeplus64> dongetit: i don't think so
03:47:45 <dongetit> No problem, dumb question anyway.
03:47:47 <M30W> > let x f = do { f; print "test" } in x print "testing"
03:47:48 <lambdabot>   The function `x' is applied to two arguments,
03:47:48 <lambdabot>  but its type `GHC.Types.IO a...
03:47:58 <merijn> Relatedly, is there a way to auto-generate export lists for TH generated functions?
03:47:58 <M30W> > let x f = do { f; print "test" } in x $ print "testing"
03:47:59 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
03:47:59 <lambdabot>    arising from a use of ...
03:48:00 <Lethalman> quicksilver, ok thanks
03:48:05 <M30W> Hmm
03:48:18 <merijn> dongetit: Pretty annoying issue, actually. For example when TH is generating code you want to export
03:48:21 <Lethalman> M30W, drop print
03:48:37 <quicksilver> M30W: what you wrote is fine (the second time)
03:48:47 <quicksilver> lambdabot doesn't execute IO actions
03:48:47 <Lethalman> probably doesn't work in lambdabot
03:48:48 <merijn> Lethalman: No, that would actually make it not work
03:48:53 <quicksilver> but there is nothiing wrong with it.
03:48:54 <M30W> > let x f = do { f; print "test" } in x $ "testing"
03:48:56 <lambdabot>   Couldn't match expected type `GHC.Types.IO a0'
03:48:56 <lambdabot>              with actual typ...
03:49:12 <M30W> Lethalman: What I want is x to run the function it's given then run something else after.
03:49:13 <dongetit> merijn: Code generation is evil imho. But then, last time I codegenerated it was in PHP
03:49:19 <merijn> M30W: IO actions aren't showable and lambdabot doesn't run IO
03:49:33 <dongetit> I guess template haskell is safer since it is type safe?
03:49:38 <mikeplus64> merijn: sometimes (many times) i wish TH was just string manipulation + a Q monad to reify stuff and change the current location
03:49:39 <merijn> dongetit: Well, I certainly don't want to manually write all my lenses...
03:49:49 <merijn> :t let x f = do { f; print "test" } in x $ "testing"
03:49:50 <lambdabot>     Couldn't match expected type `IO a0' with actual type `[Char]'
03:49:50 <lambdabot>     In the second argument of `($)', namely `"testing"'
03:49:50 <lambdabot>     In the expression: x $ "testing"
03:50:01 <merijn> :t let x f = do { f; print "test" } in x $ print "testing"
03:50:02 <lambdabot> IO ()
03:50:07 <dongetit> merijn: What is a lens?
03:50:08 <merijn> Copied the wrong one :p
03:50:17 <M30W> Lol
03:50:25 <merijn> dongetit: functional and composable getters/setters
03:50:35 <quicksilver> 11:47 < M30W> > let x f = do { f; print "test" } in x $ print "testing"
03:50:41 <quicksilver> M30W: ^^ that one was fine
03:50:47 <quicksilver> try it in ghci
03:50:51 <M30W> where x f = do { f; parseIn hdl }
03:51:01 <dongetit> merijn: I kind of puke from getters and setters, the record syntax in haskell sucks though so I may need them
03:51:23 <M30W> quicksilver: Yea, as I expected; but not what I'm trying in my program.
03:51:38 <merijn> M30W: Then you're making some unrelated mistake there :p
03:51:45 <merijn> M30W: pastebin relevant example + error?
03:51:53 <M30W> "ping" -> x $ hPutStrLn   hdl "pong"
03:52:33 <dongetit> I think Haskell is the first language where I would appreciate a teacher.
03:52:40 <M30W> Crap. Need to get my ix login back from backups lol. (new install)
03:53:24 <hpaste> M30W pasted “parseIn Loop” at http://hpaste.org/80143
03:53:28 <M30W>     Couldn't match expected type `IO () -> IO ()'
03:53:30 <M30W>                 with actual type `[Char]'
03:54:12 <M30W> @hoogle (>>)
03:54:12 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
03:54:12 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
03:54:12 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
03:54:13 <merijn> M30W: Name clash
03:54:24 <merijn> M30W: You have x bound as function in where and by the let
03:54:31 <M30W> Ah
03:54:32 <M30W> Thanks
03:54:42 <merijn> M30W: The let is in closer scope as the where (and it's a [Char])
03:55:01 <`ramses> M30W: you can enable warnings for that, might help
03:56:02 <hpaste> merijn annotated “parseIn Loop” with “parseIn Loop (annotation)” at http://hpaste.org/80143#a80144
03:56:07 <M30W> runhaskell x.hs 66666
03:56:10 <merijn> M30W: I would actually do it like that annotation, probably
03:56:12 <M30W> Listening on 1130
03:56:16 <M30W> Love the overflow haha
03:56:35 <merijn> or fmap instead of <$>, whatever you prefer
03:57:01 <M30W> merijn: Funny that; You changed it to command:rest; and I have c:xs :P
03:57:17 <merijn> :)
03:57:46 <M30W> Nice change at the start; skipped that when I skimmed. Was gonna ask about that before but forgot haha
03:58:19 <Lethalman> quicksilver, given they have the same behavior in a context, is let or <- preferred for some reason apart the coding style?
03:58:29 <M30W> Yay
03:58:39 <M30W> Much cleaner now that it was. :D
03:58:41 <quicksilver> well it feels silly to use an unnecessary return just to unwrap it with <-
03:58:48 <M30W> Except that x still isn't that clean :P
03:58:51 <quicksilver> so I prefer let to <- return
03:58:59 <Lethalman> quicksilver, ok, me too :)
03:59:20 <merijn> M30W: Take a look at monad-loops? Maybe you can use one of the functions in there to simplify further
03:59:37 <M30W> @where monad-loops
03:59:38 <lambdabot> I know nothing about monad-loops.
03:59:49 <M30W> Hehe
03:59:54 <merijn> M30W: It's a package on Hackage
03:59:55 <M30W> hackage
03:59:59 <M30W> Yea. Noticed :)
04:00:02 <mm_freak_> @hackage monad-loops
04:00:02 <lambdabot> http://hackage.haskell.org/package/monad-loops
04:00:21 <mm_freak_> i wonder if it actually checks
04:00:26 <mm_freak_> @hackage acme-stupid-package
04:00:26 <lambdabot> http://hackage.haskell.org/package/acme-stupid-package
04:00:29 <mm_freak_> it doesn't
04:00:39 <M30W> merijn: How about using Left Right ? Right = continue, Left = finished.
04:00:42 <aristid> merijn: i've found monad-loops to be interesting, but it usually lacks the precise loop function i would need, so using it requires ugly adapter code
04:01:16 <M30W> So.. case map toLower c of "echo" -> Right echoCommand hdl xs
04:01:24 <merijn> M30W: Sure, that works. Or Maybe, Just -> action to continue, Nothing -> quit
04:01:34 <M30W> and "quit" -> Left ()
04:01:42 <merijn> aristid: Yeah, it's a bit hit and miss, but when it does have the exact loop you want it's nice
04:02:00 <M30W> merijn: Ah, nice.
04:02:24 <M30W> merijn: Mind modifying your change on hpaste again with that?
04:02:25 <merijn> M30W: Then you could use something like "whileJust" from monad-loops
04:04:40 <zett_zelett> Can you guys give me advice?
04:05:28 <zett_zelett> I'm new to programming (I've just done some C a while ago), and I only read a bit about different languages and paradigms.
04:06:05 <zett_zelett> As a mathematician I'm really interested in Haskell and functional programming. But LISP is also very appealing to me.
04:06:33 <zett_zelett> Should I start with LISP or with Haskell or with another language, maybe something object oriented like Ruby?
04:06:38 <Jafet> MATHEMATICA
04:07:01 <`ramses> zett_zelett: I think most people here (including me) will be biased towards haskell
04:07:18 <`ramses> so I'd say go for haskell ;)
04:07:58 <M30W> mzero ?
04:08:02 <M30W> merijn: ^
04:08:46 <zett_zelett> `ramses: Yes, I should have known. : - )
04:09:10 <merijn> M30W: gimme a sec :)
04:10:06 <Lethalman> zett_zelett, start with the funnier :P
04:11:07 <zett_zelett> Lethalman: And what's the funnier?
04:11:54 <Lethalman> zett_zelett, depends on you ;)
04:12:21 <Lethalman> zett_zelett, read the basics of lisp, haskell and ruby and decide
04:12:31 <Lethalman> that's only a possible path obviously
04:12:47 <zett_zelett> Yeah, that was my plan anyway.
04:13:08 <hpaste> merijn annotated “parseIn Loop” with “parseIn Loop (annotation) (annotation)” at http://hpaste.org/80143#a80146
04:13:27 <merijn> M30W: Not entirely happy with that one, but should hopefully give some clue on what kind of thing you could do
04:13:39 <merijn> (Also, I totally didn't test if that code is actually correct :p)
04:14:14 <M30W> merijn: >> return True vs >> parseIn hdl
04:14:15 <M30W> haha
04:14:34 <Lethalman> zett_zelett, I can't read lisp parens, and knowing python and smalltalk is enough to get bored by ruby... therefore... :)
04:14:34 <merijn> M30W: Yeah, the return True bugs me
04:14:52 <Lethalman> plus I like types and type inference (don't like instead types without inference like java :S)
04:14:52 <merijn> M30W: It'd be nicer if you could make echoCommand, etc return IO Bool instead of IO ()
04:14:57 <merijn> That'd make the return True redundant
04:15:37 <merijn> Didn't have time to think about how to that nicer without knowing what echoCommand/addCommand all do
04:15:50 <M30W> Ah
04:15:59 <merijn> M30W: Alternatively
04:16:00 * hackagebot clientsession 0.8.0.2 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.8.0.2 (MichaelSnoyman)
04:16:08 <merijn> M30W: Just use forever + exception on quit
04:16:17 <M30W> Lol
04:16:23 <M30W> Back to forever/exception suggestion
04:16:32 <M30W> okay; how, I haven't touched exceptions yet..
04:16:34 <merijn> M30W: I'm dead serious, that's pretty sensible design, imo
04:16:54 <`ramses> Lethalman: java has type inference as well, just not as powerful as haskell
04:17:29 <M30W> merijn: What? Using forever and exceptions? Okay. :)
04:17:37 * M30W needs to learn more about exceptions.
04:17:40 <merijn> M30W: tbh, they're not that hard if your familiar with exceptions in any other language and the documentation of Control.Exception is pretty good
04:17:49 <zhulikas> @pl (\a -> (head a) == 5)
04:17:49 <lambdabot> (5 ==) . head
04:18:12 <M30W> merijn: Could you give me an example?
04:18:13 <mm_freak_> snoyberg: i'd sleep much easier if you actually used SHA2 oder SHA3 for clientsession
04:18:30 <mm_freak_> (instead of skein)
04:18:51 <merijn> M30W: Definition of globIn on https://github.com/merijn/SNet2.0/blob/master/SNet.hs
04:18:53 <snoyberg> mm_freak_: i actually haven't looked at that code in a long while, someone else maintains the cryptography aspects of clientsession
04:19:17 <dongetit> Is there a way to put any type of data into a Map? And pull it out with something like a cast or type assertion?
04:19:31 <Tordek> hi
04:19:33 <snoyberg> mm_freak_: i'm out of the loop on this one, what's the downside of skein vs sha2? are there known vulnerabilities?
04:19:33 <merijn> M30W: Although instead of reading until EOF you want to use something like "raise" to raise the exception yourself when you read the "quit" command
04:20:14 <Tordek> I'm trying to `cabal install wx`, but it fails seemingly with no reason; any clue on why that might be?
04:20:25 <merijn> :t Control.Exception.handle
04:20:26 <lambdabot> GHC.Exception.Exception e => (e -> IO a) -> IO a -> IO a
04:20:39 <mm_freak_> snoyberg: it's not as thoroughly analyzed as SHA2
04:21:21 <merijn> M30W: Basically handle takes a handler (function from exception to IO a) and an action that might throw an exception (IO a) and returns IO a.
04:22:09 <`ramses> dongetit: that would be pretty unsafe
04:22:20 <merijn> M30W: In your case the exception handler could be something like "ignore the exception argument and print "quit"" and the IO action would just be your currently loop with "raise MyException" as value for the "quit" case
04:22:39 <M30W> merijn: So. Where to define MyException?
04:22:39 <`ramses> dongetit: probably possible somehow if you really want to, but not really desirable
04:22:57 <mm_freak_> snoyberg: btw, are there any plans to create a higher level layer on top of WAI?  currently i'm using snap-core/snap-server because of that lack, but it's more difficult to combine snap with web-routes-boomerang or such
04:23:02 <M30W> Just type MyException deriving SomeException?
04:23:17 <mm_freak_> snoyberg: in other words, i'd like something slightly lower level than snap, but higher level than WAI
04:23:28 <merijn> M30W: The Control.Exception page has a minimal example of defining MyException to be an exceptio
04:23:38 <snoyberg> mm_freak_: i really don't know the intricacies of skein and hmac, you'dhave to ask vincent or felipe if it's secure enough
04:23:43 <M30W> @hackage Control.Exception
04:23:43 <lambdabot> http://hackage.haskell.org/package/Control.Exception
04:23:54 <snoyberg> mm_freak_: i don't have plans to build something in particular, but scotty could be an option for you
04:24:07 <snoyberg> mm_freak_: or theoretically yesod-pure (http://hackage.haskell.org/package/yesod-pure)
04:24:21 <dongetit> `ramses: I see. How could I define a generic communication interface between parts of my application then? Using something like an ADT imitating JSON?
04:24:22 <merijn> M30W: Control.Exception is in base, hoogle will find the relevant page. The first code sample on the page should be sufficient
04:24:36 <M30W> merijn: Yea, found it ^^
04:25:07 <mm_freak_> snoyberg: yesod-pure looks scary…  it looks like i'd basically have to reinvent yesod to work with it
04:25:29 <mm_freak_> but scotty seems interesting
04:25:30 * M30W still confused lol
04:25:31 <M30W> :|
04:25:31 <`ramses> dongetit: rely on multiple constructors and pattern matching instead of type casting
04:25:35 <dongetit> `ramses: Basically I want to put a map in a state monad and allow all my app to issue all state changes trough that, But obviously some information can be arrays, or numbers or strings etc
04:25:43 <snoyberg> mm_freak_: i'm not sure what you mean by that, it's essentially allowing you to use the Handler monad without using yesod's default routing
04:26:11 <`ramses> dongetit: I'd make a type for the data and have different constructors for all possible kinds of content
04:26:26 <snoyberg> mm_freak_: i guess the real question is what features are you looking for, and what features in yesod scare you away from it. that would determine which frameworks fit the middle ground
04:26:29 <`ramses> then you can pattern match where you consume the data to act differently for every different kind
04:27:10 <`ramses> dongetit: there may be other options as well though, I'm no expert :)
04:27:59 <M30W> @hoogle forever
04:27:59 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
04:28:20 <M30W> @hoogle raise
04:28:20 <lambdabot> System.Posix.Signals raiseSignal :: Signal -> IO ()
04:28:20 <lambdabot> package happraise
04:28:22 <mm_freak_> snoyberg: i'd like to experiment with a custom framework, so i'd like to do all the routing myself, but reuse as much existing stuff as possible…  the current approach is snap + digestive-functors + web-routes-boomerang (to be implemented) + shakespeare (to be implemented)
04:29:13 <snoyberg> mm_freak_: others in that space have used yesod-routes, which despite its name is *not* yesod-specific
04:29:20 <Lethalman> `ramses, yes it's very little... just think of HashMap<................> foo = new HashMap<..................> where nowadays one can write var foo = new HashMap<........>
04:29:34 <snoyberg> mm_freak_: the libraries are definitely designed to be reused by non-yesod projects, it should be relatively easy to accomplish
04:29:35 <Lethalman> that's getting old of java
04:29:37 <mm_freak_> snoyberg: oh, let me have a look
04:29:43 <`ramses> Lethalman: and calling generic functions
04:29:52 <`ramses> s/functions/methods
04:30:02 <Lethalman> `ramses, exactly
04:30:19 <Lethalman> it's tedious
04:31:20 <`ramses> Lethalman: yes, it is lacking in many aspects, but it's there :)
04:31:24 <M30W> merijn: How to raise?
04:31:44 <dongetit> Can I create an ADT where the elements themselves are typeclasses rather than concrete types?
04:31:57 <Lethalman> `ramses, they could do something in java 7 perhaps :( blame on java devs :P
04:32:14 <hpaste> merijn annotated “parseIn Loop” with “parseIn Loop (minimal example using exceptions)” at http://hpaste.org/80143#a80147
04:32:30 <merijn> M30W: That's a minimal example using exceptions
04:33:01 <mm_freak_> snoyberg: well, it's difficult to integrate into my framework, which is continuation-based…  it would essentially be an addon, but i'm running into the same problem with web-routes-boomerang, so it's not yesod-routes' fault
04:33:25 <`ramses> Lethalman: I hope the new lambdas will use some inference as well, such that they are not too verbose
04:33:40 <snoyberg> mm_freak_: i don't have much experience with continuation-based frameworks, i certainly haven't thought about how it would play into type-safe routing
04:33:42 <`ramses> but I haven't really looked at their syntax in detail yet
04:33:42 <Lethalman> right, anonymous classes is another tedious thing
04:33:57 <snoyberg> mm_freak_: webwire was a project that was going to do continuation-based on top of WAI
04:33:59 <merijn> M30W: It defines a new LoopTerminated datatype, which is made an exception. Then it runs the IO action with a handler that prints "quit!" when it exits
04:34:00 <M30W> merijn: x.hs:10:40: Not in scope: type constructor or class `Typeable'
04:34:35 <merijn> M30W: Although I just noticed I forgot to add the "forever" to make it loop, that should go after the handle, but before the do block
04:34:44 <`ramses> Lethalman: yeah that's terrible! we have some functional stuff in java at work which uses anonymous classes to create closures, but most of the time the verbosity kills any advantage in expressiveness
04:34:55 <merijn> M30W: Did you import Data.Typeable? That's required for the Typeable class that Control.Exception needs
04:34:56 <mm_freak_> snoyberg: i'm the author of netwire and webwire…  my current experiment doesn't use netwire though
04:34:59 <M30W> Oh you have a hpaste
04:35:09 <snoyberg> mm_freak_: oh, hi ertugul :)
04:35:13 <mm_freak_> hi there =)
04:35:14 <merijn> (Unrelated, why doesn't Control.Exception re-export Data.Typeable's class?)
04:35:23 <mm_freak_> ertugrul acutally =)
04:35:46 <snoyberg> mm_freak_: sorry ;)
04:35:47 <Lethalman> `ramses, add to that the fact that captured variables must be final, thus you have to create wrappers around them to actually mutate them :P
04:36:09 <`ramses> mutate? you mutate?! ;)
04:36:12 <merijn> M30W: If any of that code confuses you, just ask :)
04:36:14 <mm_freak_> snoyberg: btw, did you actually do any further experiments with GHCJS and netwire?
04:36:21 <Lethalman> `ramses, ahaha it's java after all, you have to mutate :P
04:36:30 <M30W>     Can't make a derived instance of `Typeable EndLoop':
04:36:32 <M30W>     In the data declaration for `EndLoop'
04:36:41 <M30W> oh
04:36:41 <snoyberg> mm_freak_: brb, phone call, and no, i haven't
04:36:47 <`ramses> I never see that as an issue actually, the semantics of closures with mutable data would be tedious anyway
04:36:58 <M30W> Working
04:36:59 <M30W> Time to test
04:37:01 <`ramses> and prone to a lot of concurrency problems
04:37:16 <M30W> Hehehehe
04:37:20 <Lethalman> `ramses, it's there in any other language with closures that you can mutate variables outside of it
04:37:28 <M30W> merijn: "x.hs: EndLoop" Did nothing haha
04:37:34 <M30W> Oh wait
04:37:37 <M30W> Slowly quit..
04:37:40 <luite> mm_freak_: GHCJS used to have a bad memory leak bug that caused problems with longer running things, that was fixed recently
04:37:40 <`ramses> so I actually think it's a good decision to only create closures over final variables (although in the case of java, the decision was rather technically inspired)
04:37:51 <M30W> Kinda like a timeout..
04:38:05 <mm_freak_> luite: i haven't tried GHCJS yet…  right now i'm struggling with the server side
04:38:10 <Lethalman> `ramses, let's say int i=0; foreach (collection, (item) => { i++; });
04:38:21 <mm_freak_> (not exactly struggling, but yeah, i want to get stuff done)
04:38:22 <`ramses> Lethalman: but do you ever really need that? It's also not like they are immutable, you just cannot change the reference
04:38:25 <merijn> M30W: If it's printing "EndLoop" that means the exception is not being caught :p
04:38:42 <Lethalman> `ramses, it happens that I needed that, yes
04:38:56 <merijn> (Unless that's what you made the handler print)
04:39:20 <Lethalman> `ramses, it's very common in imperative languages with closures, really
04:39:21 <snoyberg> mm_freak_: back
04:39:32 <`ramses> Lethalman: ok, I never ran into that, but I use final a lot anyway :)
04:39:36 <mm_freak_> snoyberg: wb
04:39:49 <snoyberg> oh, i didn't realize luite was here, the guy who actually understands ghcjs
04:40:29 <luite> mm_freak_: ah, i'm a bit behind unfortunately, because of some problems with the new code generator, the GHCJS installation procedure hasn't been improved yet
04:40:31 <mm_freak_> btw, how does GHCJS compare to other approaches like fay and UHC in terms of practicality/real-world-readiness?
04:40:33 <`ramses> Lethalman: which languages are you talking about, exactely, python or ruby or such?
04:40:40 <Lethalman> `ramses, yes... also smalltalk
04:40:56 <Lethalman> `ramses, c# probably too
04:40:58 <luite> mm_freak_: yeah that's still a bit of a problem :) fay is still far more ready
04:41:20 <snoyberg> mm_freak_: by the way, at least myself, and i think a lot of other yesod developers and users, are really interested in seeing other frameworks, especially WAI-based ones
04:41:34 <mm_freak_> i see…  i figured that it's terribly difficult to write a GHC backend
04:41:43 <snoyberg> mm_freak_: if you run into issues, let me know, or bring it up on the mailing list
04:42:00 <Lethalman> `ramses, http://stackoverflow.com/questions/428617/what-are-closures-in-net
04:42:02 <Tordek> I'm trying to `cabal install wx`, but it fails seemingly with no reason; any clue on why that might be?
04:42:10 <luite> mm_freak_: well not terribly difficult, but a lot of work, especially with all the libraries and other infrastructure
04:42:45 <mm_freak_> snoyberg: in case you missed it, i've hpasted some proof of concept code for continuation-based interaction:  http://hpaste.org/79601
04:42:56 <mm_freak_> snoyberg: see the main action and the annotated example interaction
04:43:07 <`ramses> Lethalman: ok, maybe I've used java too much :)
04:43:08 <mm_freak_> luite: porting the RTS seems like a lot of work to me
04:43:17 <Lethalman> `ramses, ahah np, just to say ;)
04:43:26 <luite> mm_freak_: ghcjs is the only one that has threading, so forkIO with blocking stuff works if you ned it
04:43:29 <luite> need
04:43:32 <`ramses> but I honestly never ran into the situation where I really needed such mutability
04:43:56 <luite> mm_freak_: yeah that might be where most of the work is, but probably not the most difficult work
04:44:05 <mm_freak_> snoyberg: the underlying monad looks a lot like Cofree, but it's not a comonad, much less a free comonad…  however, it is a monad that provides much of the goodies of Wire, but allows arbitrary reentry points
04:44:22 <Lethalman> .oO(comonad?)
04:44:47 <merijn> Lethalman: In math speak "co-" usually means "opposite world" ;)
04:44:59 <mm_freak_> luite: the reason i mention it is that i was looking hard for a language to write a kernel in (for fun)…  none of the languages seems usable for that
04:45:08 <merijn> Lethalman: i.e. a cofunctor is the inverse of a functor, a comonad the inverse of a monad, etc.
04:45:18 <luite> mm_freak_: right, javascript does make things harder
04:45:25 * Lethalman can't imagine a cofunctor
04:45:29 <snoyberg> mm_freak_: interesting, i'm not quite sure how it would play into a web framework, but i'd like to see
04:45:30 <Lethalman> @hoogle cofunctor
04:45:30 <lambdabot> package cofunctor
04:45:52 <M30W> merijn: Now quit kills the program :P
04:45:56 <M30W> Not what I want lol
04:46:05 <Lethalman> is it something like f a -> f b -> a -> b perhaps? :P
04:46:05 <luite> mm_freak_: regular javascript closures hide stuff from the user (it's the only way to do actual encapsulation), which prevents you from implementing certain ghc features. doing stuff by hand is a bit tricky because javascript lacks pointers
04:46:12 <mm_freak_> snoyberg: in a web framework imagine this:  do (user, pass) <- loginForm; checkLogin user pass; back
04:46:23 <M30W> How to close a buffer?
04:46:27 <mm_freak_> snoyberg: hides as much of the stateless nature of HTTP as you want
04:46:29 <merijn> M30W: Like I said, are you actually handling the exception? If it's printing EndLoop instead of "quit" then it looks like your not catching the exception
04:46:37 <snoyberg> mm_freak_: ahh.. interesting
04:46:39 <merijn> s/your/you're
04:47:00 <M30W> merijn: Nahh, I got everything; I'm just closing the server sock not the client hdl xD
04:47:15 <merijn> M30W: :)
04:47:23 <luite> mm_freak_: (which causes some problems with the ghc escape analysis, native ghc allocates some objects on the stack, in native ghc an object reference is just a pointer. if you keep all objects on the heap, they could just be array offsets, or small arrays. but if you allocate some on the stack that doesn't work...)
04:47:44 <M30W> How to close the buffer?
04:47:44 <M30W> merijn:
04:47:44 <mm_freak_> snoyberg: in other words you're not viewing form handling as separate requests, but essentially a form has about the same semantics as "getLine", a blocking call
04:47:47 <merijn> M30W: Also, don't forget the forever to make it loop (I forgot to write that down)
04:47:58 <merijn> M30W: I think you just need "hClose hdl"?
04:48:01 <merijn> :t hClose
04:48:02 <lambdabot> Not in scope: `hClose'
04:48:06 <M30W> Ah
04:48:07 <merijn> :t System.IO.hClose
04:48:08 <lambdabot> GHC.IO.Handle.Types.Handle -> IO ()
04:48:23 <snoyberg> mm_freak_: so you're doing to HTTP what green threads do to async I/O
04:48:27 <M30W> @hoogle hClose
04:48:27 <lambdabot> System.IO hClose :: Handle -> IO ()
04:48:27 <lambdabot> GHC.IO.Handle hClose :: Handle -> IO ()
04:48:27 <lambdabot> GHC.IO.Handle hClose_help :: Handle__ -> IO (Handle__, Maybe SomeException)
04:48:31 <mm_freak_> snoyberg: yeah
04:48:33 <snoyberg> mm_freak_: to really stretch the analogy
04:48:36 <M30W> Import what? O.o
04:48:53 <M30W> nvm lol
04:48:54 <M30W> Read wrong
04:49:09 <M30W> AH!
04:49:13 <M30W> merijn: Problem.
04:49:25 <snoyberg> mm_freak_: i wonder if there's a way to achieve something like that in a more RESTful, stateless manner
04:49:44 <snoyberg> mm_freak_: my understanding is that most continuation-based approaches store a lot of state to make it happen
04:50:00 <hpaste> M30W pasted “Whole program” at http://hpaste.org/80150
04:50:04 <M30W> merijn: ^_^
04:50:12 <M30W> x.hs:40:25: Not in scope: `hdl'
04:50:14 <Lethalman> snoyberg, mm_freak_, my idea is that the client stores the point and the necessary content to continue the request, rather than the server
04:50:16 <M30W> ;)
04:50:30 <M30W> How to pass that through the catch?
04:50:53 <mm_freak_> snoyberg: in such a framework you need to differentiate between volatile state (form waiters, volatile resources) and persistent state (regular resources, user sessions, etc.)
04:50:58 <Lethalman> snoyberg, mm_freak_, for example if you have a task, the client stores: step=2, var1_step1=val1, var2_step2=val2 and so on
04:51:20 <simon> @pl map (\(x, y) -> (f x, y))
04:51:20 <lambdabot> map (first f)
04:51:21 <mm_freak_> Lethalman: as said, that's much more difficult to achieve with a monad than it sounds
04:51:29 <Lethalman> :-(
04:51:55 <merijn> M30W: How to pass what through the catch?
04:51:59 <mm_freak_> to make this easy you need RTS support for serializing functions and closures
04:52:01 <M30W> merijn: the hdl
04:52:05 <merijn> M30W: oh, the hdl
04:52:05 <M30W> To close it
04:52:08 <M30W> Yea
04:52:19 <snoyberg> mm_freak_: in yesod, we easily make that split: session/database info versus query string/post parameters
04:52:24 <M30W> (handle, throw, Exception) <- appended to line 4 :)
04:52:28 <mm_freak_> luite: sorry for my late answer…  i know how the original STG works, but i have no idea what GHC does nowadays and how that would map to javascript
04:52:32 <snoyberg> mm_freak_: you're right, it would be harder in a continuation approach
04:52:49 <merijn> M30W: EndLoopException is just a normal data type, you can define "data EndLoop = EndLoopException Handle" and do "throw (EndLoopException hdl)", then pattern match in the handler
04:53:13 <mm_freak_> snoyberg: the idea is this:  you have your regular routing, but a form handler is allowed to create volatile resources for the form handling…  i think that's okay for POST
04:53:49 <merijn> M30W: So have "eL (EndLoopException h) = hClose h", instead of "eL e = hClose hdl"
04:53:51 <luite> mm_freak_: oh yeah ghc has some optimizations, and a lot of things have changed in some way. there's only one stack now, and dynamic pointer tagging. but a new code generator doesn't have to implement that (ghcjs does use one stack, but no pointer tagging)
04:54:45 <luite> mm_freak_: you can serialize closures with the ghc eden project :)
04:55:00 <mm_freak_> luite: i figured that it would be easiest to write an SK compiler for javascript, but that one is going to be slow =)
04:55:13 <mm_freak_> luite: however, you wouldn't need a code scrambler anymore =P
04:55:39 <luite> hmm, i doubt that would work :)
04:56:41 <M30W> merijn: Still stick :|
04:56:47 <M30W> stuck *
04:56:48 <luite> anyway i should do some coding :p already got much less done than planned in the past two weeks due to my trip to budapest and the christmas and new year business :)
04:57:14 <M30W> I fix one issue, I get MORE!
04:57:15 <mm_freak_> luite: eden seems very interesting
04:57:18 <mm_freak_> thanks for the pointer
04:58:05 <mm_freak_> snoyberg: i'll release my monad library soon, if you're patient =)
04:58:11 <hpaste> M30W annotated “Whole program” with “Whole program (annotation)” at http://hpaste.org/80150#a80152
04:58:15 <merk_> what would be non-printf equivalent of this:
04:58:15 <M30W> merijn: ^^
04:58:23 <mm_freak_> it should be easy to use together with WAI, and it is easy to use with snap
04:58:24 <snoyberg> mm_freak_: i'm always patient ;)
04:58:42 <luite> mm_freak_: yeah i was looking into using eden for persistent state and "webscaleness" of continuations (being able to move them over to different servers) before i decided that for my application, moving them over to te client would be better :)
04:58:44 <merk_> > printf "%.2f" 4.567
04:58:45 <lambdabot>   Ambiguous type variable `a0' in the constraints:
04:58:45 <lambdabot>    (GHC.Show.Show a0)
04:58:45 <lambdabot>     ...
04:58:51 <merijn> M30W: What gets stuck?
04:59:13 <mm_freak_> snoyberg: only thing is that you probably need an IORef/MVar/TVar for the continuation store…  at least you need that with snap, because Snap is not a transformer
04:59:18 <merk_> > printf "%.2f" 4.567 :: String
04:59:20 <lambdabot>   "4.57"
04:59:32 <merk_> how would I do that without printf?
04:59:36 <M30W>  http://sprunge.us/eJBB
04:59:38 <M30W> merijn:
04:59:39 <mm_freak_> luite: how exactly do you move continuations to the client?
05:00:07 * M30W would have used ix.io but TODO: get login file back from backups lol.
05:00:35 <luite> mm_freak_: by doing all computation on the client instead, using the server only for simple things, retrieving or modifying some data :)
05:00:48 <merijn> M30W: Ah, you shouldn't have added the h argument to handle here "forkIO . forever . handle eL h $ parseIn h"
05:00:48 <mm_freak_> luite: ah, makes sense =)
05:00:58 <mm_freak_> i thought you came up with some magic =)
05:01:12 <M30W> merijn: Yea, I just noticed
05:01:17 <M30W> Back to two errors still
05:01:21 <M30W> x.hs:37:31:
05:01:23 <M30W> x.hs:40:37:
05:01:32 <merijn> M30W: And the "Handle" argument to eL is also wrong, should be "EndLoop -> IO ()"
05:01:33 <luite> it would've been interesting to serialize closures with eden and then run them with ghcjs :p
05:01:53 <merijn> Instead of "EndLoop -> Handle -> IO ()", since you're wrapping the Handle with your EndLoop datatype
05:02:01 <mm_freak_> that would be almost crazy
05:02:07 <M30W> Okay new error but "possible fix" ;)
05:02:08 <luite> far too crazy for me :p
05:02:18 <M30W>       add an instance declaration for (Exception (Handle -> EndLoop))
05:02:20 <M30W> Hmm
05:02:34 <merijn> M30W: No
05:03:11 <M30W> merijn: Suggestion?
05:03:14 <merijn> M30W: What that's saying is "handle expects a function from an Exception to an IO a, but you're giving "Handle -> EndLoop -> IO a" (and only EndLoop is an exception
05:03:38 <hpaste> merijn annotated “Whole program” with “Whole program (annotation) (annotation)” at http://hpaste.org/80150#a80153
05:03:43 <merijn> M30W: That paste should work
05:04:13 <merijn> M30W: Only changed line 12, 40 and 50 from your original
05:04:32 <M30W> x.hs: <socket: 9>: hGetLine: illegal operation (handle is closed)
05:04:42 <M30W> merijn: Yea.
05:04:50 <M30W> Noise on close.
05:05:27 <merijn> That shouldn't happen on the server with that code
05:06:11 <merijn> hmmm
05:06:36 <merijn> M30W: Oh, I see the bug
05:06:41 <M30W> Where?
05:06:50 <merijn> you have "forever . handle eL" instead of "handle eL . forever" :)
05:06:58 <M30W> Ah
05:07:06 <merijn> M30W: So after the first exception it starts from the beginning, instead of breaking out of the loop :p
05:07:41 <merijn> So it throws an exception, close the handle, then restarts the loop :)
05:07:45 <M30W> downloader.hs: <socket: 9>: hGetLine: end of file
05:07:54 <M30W> merijn: Now still exception for EOF :P
05:08:29 <merijn> M30W: That happens when the remote side closes the connection, I think
05:08:36 <M30W> merijn: Yes.
05:08:49 <M30W> merijn: How could I deal with this?
05:08:57 <merijn> Which you can solve by adding a handler for that too. I think Control.Exception also has a function that takes a list of handlers and catches all of them
05:09:10 <M30W> O.o
05:09:51 <merijn> You'd need to handle EOF anyway, even if you didn't use an exception to break out of the loop, hGetLine on a disconnected socket would still throw EOF
05:10:45 <M30W> merijn: Function that takes a list of handlers. How so?
05:11:18 <M30W> I mean; can't eL handle multiple exceptions?
05:12:20 <merijn> M30W: It can, but only of the same type. You could make eL of type "SomeException", but then you couldn't get the Handle argument from it
05:12:36 <M30W> Ah
05:13:29 <merk_> what was safe equivalent of read again, that does not throw? it is in a thirt party library I believe
05:13:42 * M30W be stumped.
05:14:09 <merijn> merk_: readMaybe in Text.Read
05:14:58 <quicksilver> well there is also 'reads'
05:15:12 <merk_> what is the cabal module called?
05:15:13 <quicksilver> which is a core function and just as powerful but marginally less convenient
05:15:52 <M30W> withMPD next
05:15:54 <M30W> Whoops
05:15:58 <merijn> quicksilver: Text.Read is in base too
05:16:16 <M30W> ghci -> my MPD client :)
05:16:44 <merk_> merijn: I do not have it
05:16:54 <merk_> new addition or?
05:17:05 <merijn> merk_: Reasonably new, 7.2 or 7.4, I believe
05:17:08 <M30W> merijn: Suggestion?
05:17:17 <M30W> For catching this EOF
05:17:23 <quicksilver> merijn: oh.
05:17:26 <quicksilver> merijn: :)
05:17:28 <merk_> must be newer, I have 7.4
05:17:43 <merijn> M30W: I'd wrap a second handle or uses Control.Exception.catches to specify a list of handlers
05:18:22 * M30W hasn't slept in over 40hrs and you've just told him something that went straight to :t -> Confusion
05:18:25 <M30W> lol
05:18:28 <merijn> merk_: My bad, only since 7.6
05:19:00 <merijn> M30W: May be time to get some sleep, then? :p
05:19:09 <M30W> merijn: Maybe...
05:19:38 <M30W> merijn: Mind writing what you just said cause I read code with no issue; English is my bottleneck ;)
05:19:49 <M30W> (Moreso when tired)
05:19:55 <merijn> :t Control.Exception.catches
05:19:56 <lambdabot> IO a -> [Control.Exception.Handler a] -> IO a
05:20:14 <M30W> Well; My haskell skills are my bottle neck but yea. lol
05:20:18 <M30W> :|
05:20:22 <merijn> That expects a list of Handler a, which is just "Handler <exception function here>"
05:20:46 <merijn> i.e. "catches action [Handler eL]" would work to wrap it with your current handler
05:21:05 <merijn> Adding multiple handlers would just be "catches action [Handler eL, Handler myOtherHandler]"
05:21:24 <M30W> Hmm
05:21:29 <M30W> What to do for EOF ?
05:21:34 <M30W> Nothing to really do?
05:21:44 <M30W> Just to ignore?
05:22:00 <merijn> Close handle and ignore
05:22:14 <M30W> Wait; EOF doesn't close it's self?
05:22:23 <merijn> Don't think so?
05:22:24 <shachaf> Jafet: Hmm, interesting.
05:22:25 <merijn> Not sure
05:22:37 <M30W> Oh ofc not.
05:22:45 <M30W> One way input can be closed. Derp.
05:23:02 <M30W> Just usually that leads to closing the other :P
05:23:56 <merijn> M30W: Alternatively you could go back to your original implementation where EndLoop doesn't have a Handle inside and change your handler to "eL :: Handle -> SomeException -> IO (); eL hdl _ = hClose hdl"
05:24:18 <merijn> And then have "handle (eL hdl) . forever . etc"
05:24:20 <M30W> O.o
05:25:01 <merijn> Partially apply the function to generate a different exception handler for each Handle
05:26:29 <dongetit> How should I go about somehting like: I have an application context, which consitst of approx 6 fields. One of them is the Display. What if I want to change a property of the display? I must recreate the whole context, but isnt that boilerplate?
05:26:40 <b__> j
05:26:40 <dongetit> Obviously kinda conrived example but you catch my drift.
05:26:49 <M30W> Yay
05:26:55 <M30W> merijn: Thank you very much sir. ^_^
05:27:07 <merijn> M30W: np
05:27:30 <merijn> dongetit: That's the kind of thing lenses help simplify :)
05:27:34 <M30W> ~/downloader >> runhaskell downloader.hs 66666; Listening on 1130; quit; ls; add -- Added some output to the server haha.
05:28:02 <dongetit> merijn: :D I loled.
05:28:16 <merijn> dongetit: ?
05:28:59 <dongetit> merijn: I exactly need a thing what I explicitly dismissed 2 hours ago.
05:29:06 <dongetit> merijn: Tutors please.
05:29:12 <merijn> @hackage data-lens
05:29:12 <lambdabot> http://hackage.haskell.org/package/data-lens
05:29:15 <merijn> @hackage lens
05:29:15 <lambdabot> http://hackage.haskell.org/package/lens
05:30:03 <hpaste> “^^thief^^” pasted “StateT transformer” at http://hpaste.org/80155
05:30:26 <dongetit> merijn: Ty.
05:30:30 <merijn> The second is more comprehensive, but can also be more intimidating. And half the people in here are fiddling with lens, so if you google for a lens tutorial and then ask question when you get stuck you'll probably get going in a short time
05:30:35 <merijn> (FSOV short)
05:31:30 <M30W> merijn: Hehe. Due to catching all; if they cause an error; they get the boot :P
05:31:47 <M30W> I.e add notnumber
05:32:15 <merijn> M30W: Yeah
05:32:25 <^^thief^^> I'm trying to understand monad transformers but I feel I may missing something, could someone have a quick look at my attempt to explain StateT to myself
05:33:11 <M30W> merijn: How about.. eL h EndLoopException = hClose h; eL h WHATEVEREOFIS = hClose h ?
05:33:16 <M30W> What is EOF exception wise?
05:34:17 <merijn> M30W: That won't type check, because IOException (EOF) is a different type then EndLoop
05:34:21 <M30W> If it catches neither; then it just goes as a normal issue.
05:34:30 <M30W> Ahh
05:34:49 <merijn> M30W: That's what catches is for, so you can have two (or more) functions with different types to handle different exceptions
05:35:08 <M30W> Yea.
05:35:27 <M30W> Think maybe I should use that?
05:36:01 <merijn> M30W: In this simple case I think the SomeException version is nicer
05:36:25 <merijn> M30W: If you add more exceptions for different things, then it might be worth it. But in general, simpler == better
05:36:57 <M30W> merijn: And so add text = boot :P
05:37:45 <merijn> M30W: You could add different exception to for example print an error before booting them, but that depends on exactly what you want
05:40:49 <kranius> hello, I'm trying to install djinn with cabal, but process fails during linking
05:41:02 <M30W> End of the day; it's just a haskell to learn project, but it's intended to be a daemon for downloading files from different protocoles and will be interacted with quite strict so that kicking/booting/closing on error isn't such a bad point but maybe I just need to divide up what the users are giving me and deal with it with exceptions on the functions exactly not the loop it's self which imo should keep only the network closing there as it has.
05:41:12 <M30W> merijn: Sorry slab lol
05:41:15 <kranius> 'gcc: error: unrecognized command line option ‘-Wl‘'
05:42:59 <Lethalman> M30W, yes you should split the problems as much as you can, handle them separately, then combine them... don't do everything in a single loop
05:43:39 <M30W> e :: SomeException -> IO () -- Should I really be having this in the where ? :P
05:43:59 <BlankVerse> while installing a package , if it says that ghc-7.6.1 is likely to be broken by reinstalls , is it because its cabal file has "Tested-With:   GHC==7.2.2 GHC==7.4.1 GHC==7.4.2
05:44:11 <merijn> M30W: Depends, if you only use it in that function, where makes perfect sense
05:44:16 <M30W> addCommand h xs = handle e . hPutStrLn h . show . foldr ((+) . read) 0 $ xs; where e _ = putStrLn "Client failed to give me just numbers for the add command."
05:44:39 <M30W> removed the definitions for irc.
05:44:52 <M30W> But that catches the event so I'm happy. :)
05:46:44 <M30W> Oh merijn could you explain the concept behind . vs $ ? the .'s could all be replaced with $'s yes? But $ only on the last.
05:48:09 <HugoDaniel> is there an equivalent to OverloadedStrings but for lists ?
05:48:27 <HugoDaniel> overloaded lists ? :P
05:48:29 <|||tux||> M30W: x . y $ z = x $ y $ z
05:48:38 <merk_> I am a bit confused with exceptions handling in haskell. would appreciate if someone can tell what construct or function is equivalent to catch in other languages. I want to catch my exceptions (thrown with error function), print them on the screen and terminate the program
05:49:09 <merijn> merk_: The catch function is equivalent to catch :)
05:49:32 <M30W> merijn: Oh curious; what do you think of this program skill wise concidering it's my first haskell program. ^_^ I've only really been hacking vodik's xmonad config and changing everything how I want.
05:49:33 <|||tux||> In what module is catch?
05:49:40 <merk_> ok thanks
05:49:46 <merijn> |||tux||: Control.Exception
05:49:58 <M30W> |||tux||: I know. I was asking for what's the difference with them?
05:50:03 <merk_> do I need to combine it with try function?
05:50:10 <M30W> Other than . can go for all but the last and $ can be in all
05:50:18 <merijn> M30W: Looks pretty good for a simple beginner example
05:50:41 <|||tux||> M30W: There is no difference, it's the same
05:50:47 <M30W> |||tux||: Okay.
05:51:14 <merijn> merk_: No, try and catch functions are basically the same, but they return errors in a different way
05:51:29 * M30W just had an urge to re-write M80T in haskell. (He my MPD-IRC bridge bot)
05:51:36 <merijn> M30W: Well, not entirely true. (.) combines two functions together, whereas ($) is function application
05:51:45 <M30W> s,just,has been having for a while,
05:52:05 <|||tux||> merijn: But x $ y $ z is the same as x . y $ z, isn't it?
05:52:05 <merijn> M30W: i.e. "(f . g) x = f (g x)" whereas "f $ x = f x"
05:52:19 <merijn> |||tux||: Yes, but not because they do the same thing
05:52:35 <M30W> Ahh
05:52:36 <M30W> Nice
05:52:52 <|||tux||> Ok, thought he was asking if that was the same, not if $ is the same as (.)
05:53:11 <M30W> Nice way to explain it *
05:53:32 <merijn> The main reason for $ is the fact that function application binds tighter than operators
05:53:58 <merijn> So "f . g x" parses as "f . (g x)", instead of "(f . g) x"
05:54:03 <fmap> BlankVerse: no, it's because you are trying to reinstall some package ghc-7.6.1 depends on
05:54:35 <fmap> (don't do that)
05:54:38 <merk_> I am following exceptions tutorial in real world haskell and try (print undefined) is giving me ambigous type error
05:54:45 <merijn> $ has lower precedence then ., so "f . g $ x" turns into "(f . g) x"
05:55:15 <merijn> merk_: It doesn't know what the type of exception you're trying to catch is
05:55:39 <merijn> merk_: "try (print undefined) :: Either SomeException ()"
05:56:54 <merk_> how come it worked in a tutorial without that? maybe one of several extensions I am using is causing it?
05:59:18 <merk_> it looks like it is catching all exceptions for them: http://book.realworldhaskell.org/read/error-handling.html
05:59:41 <fmap> merk_: it worked when RWH at the time rwh was written, but exception system was reimplemented after that
05:59:52 <fmap> s/when RWH//
06:00:41 <M30W> > fmap (5+) [0..] -- Hello fmap. :)
06:00:42 <merijn> merk_: Also, usually GHC would infer the correct exception type from context, it's just that in minimal examples there's not enough context for type inference of the exception type
06:00:42 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
06:01:26 <BlankVerse> fmap: how do i find out which reinstall package does ghc-7.6.1 depends on
06:02:06 <zebr> hey all. is there a name for a kind of 'uncurried lambda calculus' in which abstractions may have an arity greater than 1?
06:03:29 <dongetit> merijn: Have you seen the fields package? http://hackage.haskell.org/package/fields
06:04:26 <shachaf> dongetit: A lens library?
06:04:32 <shachaf> Or, rather, a different syntax for fclabels?
06:04:43 <shachaf> Why not just use lens?
06:05:05 <shachaf> > (("hello","there"),5) ^. _1._2
06:05:07 <lambdabot>   "there"
06:05:08 <dongetit> shachaf: Yes. Well I am a newbie and this is the first package which description I can actually understand :D
06:05:22 <shachaf> > (("hello","there"),5) & _1._2 .~ 8
06:05:24 <lambdabot>   (("hello",8),5)
06:05:31 <fmap> BlankVerse: `ghc-pkg field ghc-7.6.1 depends' will list ghc-7.6.1 dependencies, also cabal-install should tell which packages will be reinstalled, so you need to find the intersection :)
06:05:46 <merk_> anyone knows an up to date tutorial on haskell exceptions? I tried following http://www.haskell.org/haskellwiki/Exception but it left me even more confused
06:05:50 <shachaf> dongetit: This lets you use actual "." to compose accessors!
06:06:18 <M30W> Good night world. Thankyou very much merijn and anyone else who helped over the past day/night. I shall sleep now/soon. -- And no I wasn't working on that all day/night haha.
06:06:24 <dongetit> shachaf: You see, I can't decipher anything you wrote there :S
06:06:51 <shachaf> dongetit: Well, I'm using a bunch of symbols just to match what that page does.
06:07:01 <dongetit> But I will! :-D. I am fairly persistent.
06:07:09 <shachaf> @let tupleFst = _1; tupleSnd = _2
06:07:10 <lambdabot>  Defined.
06:07:23 <shachaf> > view (tupleFst.tupleSnd) (("hello","there"),5)
06:07:25 <lambdabot>   "there"
06:07:31 <shachaf> > set (tupleFst.tupleSnd) 8 (("hello","there"),5)
06:07:33 <lambdabot>   (("hello",8),5)
06:07:59 <shachaf> > modify (tupleSnd) (*10) (("hello","there"),5)
06:08:00 <lambdabot>   Couldn't match expected type `t0 -> t1' with actual type `()'
06:08:08 <shachaf> Er.
06:08:10 <shachaf> > over (tupleSnd) (*10) (("hello","there"),5)
06:08:12 <lambdabot>   (("hello","there"),50)
06:09:01 <rntz> what makes reallyUnsafePtrEquality# so really unsafe?
06:09:38 <`ramses> rntz: no referential transparency ?
06:10:09 <rntz> lack of referential transparency is more unsafe than unsafeCoerce?
06:10:22 <Jafet> It doesn't even test pointer equality.
06:10:32 <Jafet> Oh wait, maybe it does
06:10:42 <Jafet> I don't really remember what it does exactly
06:11:24 <quicksilver> rntz: the fact that GC can occur mid comparison
06:11:33 <quicksilver> so it can have false negatives as well as false positives
06:12:18 <merk_> this is madness, I cant find working exception handling code. realworldhaskell first example gives me ambigous error. first example on haskell gives me "cant make a derived instance of Typeable MyException"
06:12:36 <rntz> quicksilver: ha, that is pretty bad
06:12:56 <merk_> in haskell.org
06:14:38 <hpaste> merk pasted “exceptioin example from haskell.org that gives me rrors” at http://hpaste.org/80159
06:15:07 <Philonous> merk_:  You need {-# LANGUAGE DeriveDataTypeable -#}
06:15:16 <Philonous> merk_:  It actually says so in the error message
06:15:35 <Philonous> merk_:  Err, {-# LANGUAGE DeriveDataTypeable #-}
06:16:31 <merk_> but why would I need language extensions for this? cant it be done without them?
06:16:46 <Philonous> merk_:  It can be done, but it shouldn't
06:16:53 <rntz> Typeable isn't even Haskell98, is it?
06:16:55 <merk_> hmm
06:17:25 <Philonous> rntz:  I don't know, what's non-haskell98 about it?
06:17:41 <quicksilver> well it's not part of haskell98
06:18:04 <quicksilver> and the automatic derivation of it is a language extension
06:18:15 <quicksilver> and the implementation of 'cast' is not possible in haskell98
06:18:30 <Philonous> quicksilver:  It's just a type-class, does it use something that can't be done in H98?
06:18:42 <quicksilver> yes.
06:18:49 <quicksilver> try to write 'cast' in H98 :)
06:19:31 <Philonous> quicksilver:  WIth the FFI? You can have unsafeCoerce via unsafePerformIO which can arguably be done with the FFI, can it not?
06:19:31 <hpaste> zhulikas pasted “Euler#38” at http://hpaste.org/80160
06:19:38 <zhulikas> wow
06:19:42 <zhulikas> anyway, problem #38
06:19:45 <quicksilver> Philonous: nope.
06:19:52 <zhulikas> if anybody solved it, can you tell me where is my mistake in this code?
06:20:03 <quicksilver> Philonous: you can write an undefined program which has no haskell98 semantics
06:20:06 <merk_> ok I will add that extension. one more thing, should I define exception type when I want to signal parsing errors, or is it fine to just use error function?
06:20:09 <Philonous> quicksilver:  Ah, you need existential types as well
06:20:10 <quicksilver> Philonous: which *happens* to work on GHC.
06:20:11 <zhulikas> I rewrote the whole thing a couple of times, still getting the same answer
06:20:18 <zhulikas> and that answer seems to be incorrect
06:20:35 <rntz> quicksilver: I mean, cast also has no "defined semantics" as far as I know
06:20:41 <rntz> so arguably you have implemented it :P
06:20:44 <zhulikas> tried increasing the boundary
06:20:46 <quicksilver> rntz: cast has perfectly defined semantics.
06:21:01 <rntz> quicksilver: where's the formal spec?
06:21:19 <quicksilver> it doesn't have to be written down somewhere to be defined.
06:21:29 <rntz> ... that's more or less exactly what I mean by defined.
06:21:49 <quicksilver> well if that's what you want it's probably written in a mailing list somewhere :)
06:21:49 <rntz> specified by something concrete, as opposed to 'this is what I think it should do in my head'
06:23:35 <merk_> there is more than one catch too? "ambigous occurence 'catch'" Prelude.catch and Control.Exception.catch
06:23:42 <merk_> I give up
06:23:50 <Philonous> merk_:  Use Control.Exception.Catch
06:23:50 <rntz> import Prelude hiding (catch)
06:24:29 <subbyyy> are they one in the same or are they different?
06:25:05 <Philonous> subbyyy:  The one in the Prelude is for IOErrors only
06:25:19 <subbyyy> and*
06:25:28 <subbyyy> i see, thanks Philonous
06:27:00 <Philonous> merk_:  You parser should probably return something like Either Error Result, not throw exceptions.
06:29:15 <merk_> I tried it, mu code became too convulted for no gain
06:30:10 <merk_> it is a one-shot parser, used in this program only, and if there is a parsing error my program should notify the user about it and terminate
06:30:10 <rntz> if you dislike writing monadic code, I have to break it to you: you're not gonna like haskell
06:30:43 <Philonous> merk_:  I'd go for error in that case.
06:31:02 <merk_> rntz: I dislike it when I dont gain anything with it
06:32:50 <Philonous> merk_:  You don't lose much, either. Just use ParsecT s u (Either String) instead of ParsecT su Identity.
06:33:27 <rntz> oh, I was assuming that merk_ wasn't using parsec for parsing. if you are using parsec, you really don't lose anything by adding EitherT on the outside, or Either on the inside.
06:35:07 <merk_> I am not using it. it is on my to-learn list.
06:41:54 <^^thief^^> Can someone have a quick look at this please http://hpaste.org/80162
06:42:38 <^^thief^^> Trying to figure out the implementation of the StateT transformer, can't get my head around one particular line
06:42:54 <byorgey> ^^thief^^: the line   runStateT (k a) s'  ?
06:42:54 <lambdabot> byorgey: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:43:00 <^^thief^^> yep
06:43:16 <byorgey> ^^thief^^: what's confusing you?
06:43:36 <^^thief^^> well k a yields a value of type StateT s m b
06:43:44 <Philonous> ^^thief^^:  You can read that line as (runStateT (k a)) s'
06:43:56 <^^thief^^> ah
06:43:57 <byorgey> ^^thief^^: right
06:44:20 <Philonous> ^^thief^^:  So the StateT is unpacked before it is applied
06:44:27 <byorgey> yes, runStateT  is turning that  StateT s m b  into an actual function of type  s -> m (b, s)
06:44:38 <byorgey> which is then applied to the new state s'
06:44:43 <^^thief^^> I had the associativity wrong in my head
06:44:50 <byorgey> ah, that would do it =)
06:44:55 <Lethalman> this is all so complicated the first time :(
06:45:17 <Lethalman> is there any alternative to monad transformers? :P
06:45:26 <^^thief^^> thanks
06:47:07 <byorgey> Lethalman: sure, don't use monad transformers
06:47:37 <Lethalman> byorgey, that's always possible?
06:47:42 <byorgey> of course
06:47:43 <Philonous> Lethalman:  You can translate the transformer stack into a monolithic monad
06:50:25 <mm_freak_> in fact nowadays there are better ways to compose effect systems
06:50:50 <Philonous> mm_freak_:  Care to elaborate?
06:50:59 <mm_freak_> here is an example:  http://comonad.com/reader/2012/abstracting-with-applicatives/
06:51:29 <mm_freak_> compose, then capture (i.e. turn the composition into a single functor/monad)
06:51:37 <mm_freak_> "single" as in "monolithic"
06:52:00 <Lethalman> yes I quite understood the basics of applicative functors and I like that
06:54:41 <hrumph> yo is there any work being done by anyone on a PDF authoring module?
06:55:03 <hrumph> just sufficient to make simple forms and what not
06:55:06 <merk_> Philonous: did you mean I should use error function instead of defining my own exception types?
06:55:35 <merk_> type*
06:56:58 <Philonous> merk_:  If you don't mean to catch them anyway and only as a way to abort the program, yes.
06:57:11 <Philonous> merk_:  You don't really gain much by introducing your own exceptions
06:58:32 <mm_freak_> Lethalman: read the article anyway…  edwardk doesn't write when there is nothing to write =)
06:58:32 <merk_> yeah, I was only going to catch them to print the error and terminate, which is what errror already does
06:59:08 <edwardk> mm_freak_: that article is by sclv, not me
06:59:16 <mm_freak_> oh
06:59:27 <mm_freak_> i didn't know that blog has multiple authors
06:59:31 <edwardk> i've been branching out a bit and letting coworkers write a bit, since i've been too busy lately
06:59:53 <edwardk> just the last couple of posts
06:59:56 <mm_freak_> anyway, the article is good…  it caused a few "oh!" moments for me
07:00:41 <Philonous> merk_:  For proper error handling I'd really go the EitherT / ErrorT way, so your code remains pure (Exceptions are only observable in IO)
07:01:15 <hrumph> what is the ErrorT way?
07:01:24 <hrumph> i've learned the EitherT way but what is the ErrorT way?
07:01:39 <Lethalman> mm_freak_, that's too much for me yet :)
07:01:39 <hrumph> i've learned how to use EIther and Maybe
07:01:40 <merk_> I will try rewriting it like that when I understand monads better
07:01:58 <Philonous> hrumph:  ErrorT is basically EitherT, just with some restrictions on what types you can use as the Left part
07:02:03 <beaky> hello
07:02:12 <hrumph> Philonous: ok
07:02:12 <beaky> what does the lambda in the lambda calculus mean?
07:02:25 <mrout> o.O https://github.com/splinterofchaos/Pure
07:02:29 <hrumph> beaky: its the abstraction symbol typically used in such languages
07:02:36 <beaky> ah
07:02:46 <beaky> so it doesn't really mean anything
07:03:12 <hrumph> i wouldn't say that
07:03:17 <beaky> oh
07:03:45 <hrumph> if you know any type theory its really easy to understand what it means
07:04:07 <hpaste> owst pasted “Failing to use superclass instance on structurally smaller type” at http://hpaste.org/80163
07:04:26 <beaky> in SICP they said all functional programs decompose into a bunch of lambdas
07:05:01 <owst> Should I be able to "use" the (Eq a) instance given a constraint (Ord (a, b))? If not, why not?
07:05:15 <hrumph> for instance if i have a and object t with x as a free variable of type 0 and variable x is of type 0 then x<-t is a function of type 0->0
07:05:42 <hrumph> this is in type theory but and equivalent idea applies in the lambda calculus
07:06:11 <mm_freak_> hrumph: if you ever have to decide between ErrorT and EitherT, go for EitherT
07:06:24 <mm_freak_> ErrorT = Retarded EitherT
07:06:27 <Philonous> owst:  How is it supposed to work? The equality of composite type might be something different than just the equality of it's components
07:06:41 <mrout> https://github.com/splinterofchaos/Pure <-- Haskell in C++
07:07:27 <merk_> how do I force evaluation of an entire list so that exception is thrown before I start printing it's elements?
07:07:35 <Rembane> seq!
07:07:44 <Philonous> owst:  Consider the Rational numbers. Two rational numbers being equal doesn't imply their denominator or numerator being equal
07:07:53 <hrumph> so imagine that t is the formula sin(x)+cos(x), then x<-(sin(x)+cos(x)) is just the function that takes x as and argument and gives you sin(x)+cos(x), typically described like f(x)=sin(x)+cos(x)  (still talking to beaky here but i'm done)
07:07:54 <mm_freak_> merk_: deepseq or a certain foldl'
07:08:13 <hrumph> mm_freak_: agree. i've only been coding haskell for my first time last night and that's what i did
07:08:55 <mm_freak_> > let xs = [1..1000] in foldl' (\y x -> x `seq` y) () xs `seq` xs
07:08:56 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:08:57 <merk_> thanks. I am curious why evaluate couldnt do it? when do you use evaluate?
07:09:00 <hrumph> i started my haskell life by studying monads functors and monad transformers so i would know what i was doing when i began actually doing it
07:09:03 <mm_freak_> > let xs = [1,2,3,undefined] in foldl' (\y x -> x `seq` y) () xs `seq` xs
07:09:05 <lambdabot>   *Exception: Prelude.undefined
07:09:19 <owst> Philonous: I'm not asking for (a, b) == (c, d) `implies` a == b. But there should be an instance of Eq around for the components (the compiler would complain when trying to make the Ord instance for (a,b) otherwise)
07:09:27 <mm_freak_> or flip seq, if you will
07:09:38 <mm_freak_> > let xs = [1,2,3,undefined] in foldl' (flip seq) () xs `seq` xs
07:09:40 <lambdabot>   *Exception: Prelude.undefined
07:09:43 <owst> Philonous: err `implies` a == c
07:09:46 <hrumph> sorry i was using the vairable bidning notaion in a do block when i meant to use the abstractor notation
07:10:02 <mm_freak_> merk_: 'evaluate' like 'seq' only forces the head constructor
07:10:16 <mm_freak_> if you have A (B (C D)), it only forces the A
07:11:29 <owst> Philonous: The compiler must know that instances exist for the components, when declaring the instance for the composite, but it won't let *me* use the component instances directly
07:12:18 <Philonous> owst:  No, there is no requirement for the components to have an Eq instance. Data Foo a b = Foo a b; instance Eq Foo where _ == _ = True is fine.
07:12:35 <owst> Ok, not in general, but for tuples there is
07:12:48 <Philonous> instance Eq (Foo a b), even
07:12:50 <zhulikas> I need a function to select all combinations of N elements from a list
07:13:21 <quicksilver> in generaly, Ord (a,b) is a weird constraint to carry around
07:13:22 <zhulikas> [1,2,3] select 2 would give [[1,2], [2,3], [1,3]]
07:13:25 <Philonous> owst:  You are still asking the compiler to conjure up the class dictionary out of thin air.
07:13:27 <Lethalman> @hoogle [a] -> [[a]]
07:13:28 <lambdabot> Data.List inits :: [a] -> [[a]]
07:13:28 <lambdabot> Data.List permutations :: [a] -> [[a]]
07:13:28 <lambdabot> Data.List subsequences :: [a] -> [[a]]
07:13:37 <quicksilver> why not carry around (Ord a, Ord b) instead?
07:13:58 <zhulikas> Lethalman, so you suggest getting permutations and then filtering out with length N ? :)
07:14:10 <Lethalman> zhulikas, if the list is not very long, why not :P
07:14:11 <byorgey> zhulikas: try Math.Combinat.Sets.choose from the combinat package
07:14:47 <zhulikas> Lethalman, it is relatively long (~10k elements), but I think it may work :) after all I am interested in the answer here
07:14:51 <hrumph> sorry this is ot, how many people are in this chan? my client doesn't have a /list command available for some reason
07:15:03 <zhulikas> byorgey, I'll look into it, thanks
07:15:11 <zhulikas> hrumph, 964
07:15:24 <byorgey> zhulikas: if it has 10k elements than generating a superset of what you want and filtering is probably a terrible idea.
07:15:35 <merk_> must be one od the largest channels on freenode
07:15:37 <zhulikas> actually yes....
07:15:37 <hrumph> that sounds a bit on the high side....
07:15:39 <zhulikas> hehe
07:15:48 <zhulikas> 10k of permutations is a huge dataset
07:16:02 <owst> quicksilver: I'm using something like this in a GADT constructor, with a Ord constraint on the type parameter; I have an element of type MyGADT (l, l), and want to use the Ord instance on an element of the contained pair
07:16:05 <zhulikas> I'll look into your suggested package
07:16:24 <owst> Philonous: well, yeah, I've not thought about the implementation - I'd just expect it to be possible
07:16:47 <zhulikas> it does  exactly what I need
07:16:50 <zhulikas> thanks, byorgey
07:16:51 <zhulikas> :)
07:16:51 <byorgey> > length . show $ product [1..10000]
07:16:53 <lambdabot>   35660
07:16:57 <byorgey> sure =)
07:17:03 <quicksilver> owst: interesting.
07:17:53 <owst> quicksilver: It's just irritating to me at the moment :-)
07:18:24 <quicksilver> yup, well, you can't do constraint reduction backwards
07:18:32 <quicksilver> although I'd never previously thought about wanting to.
07:19:26 <owst> It doesn't seem totally unreasonable - it's just forgetting extra structure, in some sense.
07:20:35 <merk_> how come deepseq isnt just returning passed object?
07:20:39 <owst> quicksilver: thanks for giving me a name for what I'm talking about: "constraint reduction"
07:20:43 <hrumph> the number was real. sorry for doubting
07:21:09 <edwardk> owst: you have Ord (l,l) and want to recover Ord l ?
07:21:52 <owst> edwardk: exactly
07:22:02 <owst> Well, actually Eq l
07:22:17 <mrout> can this channel interpret Haskell?
07:22:25 <mrout> with a bot?
07:22:30 <dmwit> > "yes it can!"
07:22:32 <lambdabot>   "yes it can!"
07:22:33 <Philonous> owst:  eq x y = (x,x) == (y,y)
07:22:36 <mrout> > http://liveworkspace.org/code/4G3M3m$9
07:22:37 <edwardk> owst: you could always take your resulting 'l' and smash two copies into a tuple, it'll match value you'd get. ;)
07:22:37 <lambdabot>   Not in scope: `http'Not in scope: `liveworkspace'Not in scope: data constru...
07:22:41 <mrout> oops i am retarded
07:22:47 <edwardk> like Philonous did t
07:22:49 <mrout> forgot to copy before I pasted
07:22:53 <owst> edwardk: hah!
07:22:54 <mrout> > let fact n = if n == 0 then 1 else n * fact (n-1) in fact 5
07:22:56 <lambdabot>   120
07:23:00 <mrout> FUCK YES
07:23:19 <djcoin> lol
07:23:21 <owst> Philonous: winner ;-)
07:23:23 <edwardk> > product [1..5]
07:23:24 <lambdabot>   120
07:23:28 <shachaf> > 120
07:23:29 <lambdabot>   120
07:23:39 <merk_> I like how error "some error" is displayed as progname: "some error", instead of "Unhandled exception: ...", leaving the impression od sloppy programming
07:24:17 <mrout> edwardk: yes, you can do that. typing product [1..5] doesn't really help practice recursion though, does it?
07:24:26 <edwardk> mrout: not so much ;)
07:24:41 <dmwit> Implementing product might... or fold(r/l), depending how deep you want to go. =)
07:24:43 <mrout> > map (fix (\rec n -> if n == 1 || n == 2 then 1 else rec (n-1) + rec (n-2))) [1..20]
07:24:45 <lambdabot>   <hint>:1:12: parse error on input `rec'
07:24:49 <mrout> fuck
07:24:52 <edwardk> mrout: it was a half-joking reference to the end of http://www.willamette.edu/~fruehr/haskell/evolution.html
07:24:53 <shachaf> mrout: But you can practice recursion with ghci too!
07:27:10 <Lethalman> mrout, also fix is not defined by default
07:27:48 <HrumphTemp> ok perhaps OT again. how did #haskell get so popular? i thought it was an obscure mathie type thing
07:27:53 <HrumphTemp> until recently
07:27:55 <mrout> Lethalman: really?
07:28:03 <Lethalman> :t fix
07:28:05 <lambdabot> (a -> a) -> a
07:28:13 <Lethalman> only lambdabot has it then :P
07:28:18 <merijn> HrumphTemp: #haskell has been over 600 users since I learned of it, which was 2-3 years ago
07:28:27 <merijn> HrumphTemp: Since then it has been steadily climbing towards 1000
07:28:56 <HrumphTemp> people told me about it but then i thought no one would want to use that, looking at some of the weird looking code
07:28:58 <Lethalman> mrout, didn't think lambdabot imported Data.Function... good to know :)
07:31:03 <HrumphTemp> so haskell is right behind python, perhaps at second place. what other languages did i miss?
07:31:30 <merijn> HrumphTemp: Results of #code2012 on twitter: http://www.ioncannon.net/projects/code2012/
07:31:38 <mrout> Haskell is by no means a highly popular language
07:31:56 <mrout> but it's certainly well known
07:32:07 <mrout> compared to C++ or Java or Python though? It's tiny IRL.
07:32:14 <HrumphTemp> irc numbers are the crude measure i'm going by. these numbers cannot mean nothing
07:32:25 <jerojasro> HrumphTemp: most of us just hang around waiting for explanations about monads :o
07:32:37 <merk_> :D
07:32:56 <mrout> jerojasro: Maybe hahahahahahahahahaha
07:34:58 <byorgey> HrumphTemp: Haskell *is* an obscure mathy type thing.  But it turns out basing your real-world programs on math works really, really well. =)
07:34:59 <HrumphTemp> interesting that visual basic didn't make it on the list
07:35:14 <HrumphTemp> byorgey: yeah i'm totally sold. i think its absolutely revolutionary
07:35:33 <HrumphTemp> i'm can't believe it. its like a religious experience without drugs
07:35:39 <byorgey> hehehe
07:36:15 <mrout> I still prefer doing my maths on paper and my programming in C++, but I *do* like Haskell
07:37:28 <dmwit> > map (fix (\rec n -> if n == 1 || n == 2 then 1 else rec (n-1) + rec (n-2))) [1..20]
07:37:30 <lambdabot>   <hint>:1:12: parse error on input `rec'
07:37:34 <dmwit> weird
07:37:42 <dmwit> I don't see a parse error, and ghci likes it just fine.
07:37:50 <BlankVerse> what is the best way to have multiple versions of ghc installed?
07:38:11 <dmwit> BlankVerse: You can just install them all at once. They're careful about putting things in different directories / at different file names.
07:38:14 <HrumphTemp> its already changed how i will code in imperative code. i'm not longer ok with using excpetions liberally in imperative code because haskell has taught me that you can have superior flow control with minimal exceptions, *even though* i've been told that people underuse exceptions
07:38:19 <Lethalman> > rec
07:38:20 <lambdabot>   not an expression: `rec'
07:38:21 <shachaf> dmwit: rec is a keyword
07:38:29 <byorgey> dmwit: does ghci like it just fine if you enable -XDoRec ?
07:38:30 <dmwit> BlankVerse: You'll have, e.g., ghc-7.6.1, ghc-7.4.2, etc.
07:38:38 <BlankVerse> dmwit: using cabal?
07:38:48 <dmwit> byorgey: Aha!
07:38:58 <dmwit> BlankVerse: Using cabal, just add --with-compiler=ghc-7.6.1, or etc.
07:38:59 <BlankVerse> dmwit: i guess no!!!
07:39:02 <EvanR> @src fix
07:39:02 <lambdabot> fix f = let x = f x in x
07:39:20 <BlankVerse> dmwit: would that install the ghc compiler too?
07:39:30 <dmwit> No, cabal cannot (yet) install ghc.
07:39:41 <dmwit> But there's generally no reason to build GHC yourself. Just install the binaries for your OS.
07:39:55 <BlankVerse> dmwit: the package manager has only one version
07:40:06 <dmwit> The GHC website has more versions.
07:40:46 <beaky> how do purely-functional RNGs work in haskell?
07:40:57 <dmwit> beaky: You send them a seed, and get a new seed back.
07:41:01 <beaky> ah
07:41:07 <beaky> so the seed gets passed through as a monad
07:41:19 <dmwit> That's one pretty common way to handle things, yes.
07:41:34 <dmwit> It's not required, though.
07:41:41 <beaky> ah
07:47:22 <beaky> the monad way seems to be elegant
07:49:53 <beaky> so monads can be used to model the leaking-out of state?
07:50:32 <mm_freak_> :t state random
07:50:34 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
07:50:48 <mm_freak_> :t state random :: (Random a) => State StdGen a
07:50:49 <lambdabot> Random a => State StdGen a
07:50:54 <Lethalman> :t state next
07:50:55 <lambdabot> (MonadState s m, RandomGen s) => m Int
07:51:32 <Lethalman> mh
07:51:35 <Lethalman> > random :: Double
07:51:37 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
07:51:37 <lambdabot>              with actual ty...
07:51:38 <Lethalman> err
07:51:50 <mm_freak_> beaky: that's a way to do it…  most applications would simply use IO and many others use some abstraction to hide the state
07:52:03 <Lethalman> so random seems more general than next
07:53:13 <Lethalman> mm_freak_, is in general better to avoid IO?
07:53:20 <mm_freak_> no
07:53:23 <rdesfo> are there any haskell groups for ubuntu?
07:53:36 <mm_freak_> Lethalman: it's often better, but not better in general
07:54:45 <mm_freak_> Lethalman: in many cases you really don't care /what/ random numbers you get (repeatability, etc.), but you really just want random numbers, and you want to perform IO effects with those numbers
07:55:05 <mm_freak_> in that case using randomIO or randomRIO is better than using a StateT StdGen IO
07:55:30 <Lethalman> mm_freak_, mh, I just wrote a simple program to run a simulation, and using State StdGen was very fine, didn't need IO
07:55:54 <Modius``> Is there something in Haskell libs like "Either" but with 3 elements?  I realize that's the time to start using a type; but I'm changing one out in a C# codebase (where a 3-element is useful) and would like to know if someone already gave it a name.
07:56:22 <mm_freak_> Modius``: you mean something like data X a b c = A a | B b | C c?
07:56:36 <applicative> Either a (Either b c)
07:56:37 <Modius``> Yeah
07:56:37 <Lethalman> mm_freak_, so i lifted the computation in IO, was that better than using IO?
07:56:51 <mm_freak_> Modius``: algebraically that's the same as Either (Either a b) c and Either a (Either b c)
07:56:59 <Modius``> Right, just wanted to know if a 3-element one has a named representation in haskell libs (remember, this is a C# codebase)
07:57:03 <mm_freak_> and most often one of those is actually more appropriate
07:57:23 <mm_freak_> Modius``: read "Either" as "+"
07:57:35 <Modius``> Meh - I'm goingwith "Union" for the 3-element
07:57:40 <mm_freak_> Either (Either a b) c = (a + b) + c
07:58:02 <mm_freak_> Lethalman: i don't know your application
07:58:29 <mm_freak_> Modius``: "sum" is more appropriate than "union"
07:58:49 <hpaste> Lethalman pasted “Simulation” at http://hpaste.org/80166
07:58:56 <Lethalman> mm_freak_, ^^
07:59:09 <Lethalman> mm_freak_, see the montecarlo function
07:59:20 * Lethalman yes I know, still with this program :P haven't written anything else in the while eheh
08:00:20 <mm_freak_> Lethalman: seems like you're essentially constructing and consuming streams
08:00:40 <mm_freak_> Lethalman: i most often use streams to express something like that
08:02:13 <Lethalman> mm_freak_, yes it is a stream
08:03:07 <Lethalman> mm_freak_, looked into Stream without understanding much on how to create a stream from that
08:03:17 <zhulikas> looking for an easy way to sortBy length of [[a]]
08:03:52 <mm_freak_> Lethalman: you can construct it using 'iterate' or ad hoc
08:04:04 <fmap> @ty sortBy (comparing length)
08:04:06 <lambdabot> [[a]] -> [[a]]
08:04:11 <mm_freak_> ones = Cons 1 ones
08:04:25 <zhulikas> ahhh, comparing
08:04:28 <zhulikas> thanks
08:04:43 <shachaf> @ty sortBy (comparing void) -- lazier
08:04:44 <lambdabot> (Functor f, Ord (f ())) => [f a] -> [f a]
08:04:55 <Lethalman> @hoogle iterate
08:04:56 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
08:04:56 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
08:04:56 <lambdabot> Data.ByteString.Lazy.Char8 iterate :: (Char -> Char) -> Char -> ByteString
08:04:57 <mm_freak_> Lethalman: if you don't want to depend on a stream package, you can also simply use lists, but they are a bit inconvenient
08:04:59 <rntz> is there a haskell module for dynamically-sized arrays?
08:05:07 <rntz> (mutable, not persistent)
08:05:10 <yitz> Modius``: i find almost always that a sum type with more than two elements is better off with a meaningful name specific for the application.
08:05:14 <Lethalman> mm_freak_, yes I tried to use lists and didn't manage to things as simple as I did in the paste
08:05:17 <mm_freak_> rntz: array, vector, repa
08:05:20 <Lethalman> *to do
08:05:32 <Lethalman> mm_freak_, other than that, does it look good overall?
08:05:52 <mm_freak_> Lethalman: it looks very imperative, but apart from that it seems fine (the montecarlo function)
08:06:35 <mm_freak_> Lethalman: try again using streams…  it's really simple:  generate a stream of values (f g' x' = x' `Cons` f (blah g') (blubb x'))
08:06:36 <yitz> Modius``: in fact, that is most often the case for two elements, too. i use either just as some kind of intermediate result, or for a calculation that might report an error.
08:06:42 <mm_freak_> Lethalman: then just consume the stream
08:06:50 <mm_freak_> filter, find, head, etc.
08:06:52 <rntz> mm_freak_: if by array you mean Data.Array, it isn't dynamically sized. or perhaps the term I'm looking for is dynamically resizable.
08:06:57 <shachaf> rntz; There is at least <http://hackage.haskell.org/package/ArrayRef>, though it looks pretty abandoned.
08:07:00 <parcs> @hoogle withTempFile
08:07:00 <lambdabot> No results found
08:07:01 <rntz> I'll look into vector & repa
08:07:02 <shachaf> I don't think there's anything in the standard library.
08:07:09 <parcs> i am disappoint that that doesn't exist
08:07:30 <shachaf> vector and repa are also not dynamically resizable, as far as I know.
08:07:31 <mm_freak_> rntz: vector and repa are your best bets, but resizing arrays usually isn't a good idea
08:07:36 <mm_freak_> shachaf: they are
08:07:44 <rntz> "resizing arrays usually isn't a good idea" wha?
08:08:12 <mm_freak_> rntz: can cause heavy allocation
08:08:17 <shachaf> mm_freak_: Do you mean something other than copying every time you resize?
08:08:23 <Lethalman> mm_freak_, that's what I thought, I first tried sequence $ repeat sample but then the resulting list either accumulated too many thunks or was strictly evaluated... I will try streams thanks
08:08:30 <shachaf> I think rntz is after something like std::vector in C++
08:08:33 <mm_freak_> shachaf: you can't really prevent copying
08:08:35 <rntz> ==shachaf
08:08:46 <rntz> by "dynamically resizable", I mean with a reasonable allocation policy that avoids copying overly much by eg. doubling on overflow
08:08:49 <zhulikas> hmm... so my list is quite huge... is there a way to sort in constant space?
08:08:59 <rntz> this is a well-known technique that works well in practice
08:09:04 <yitz> mm_freak_: which streams library are you recommending for Lethalman?
08:09:19 <rntz> if there isn't a library that does it I guess I'll do it myself but blehh...
08:09:22 <aristid> rntz: i don't think it works well in conjunction with persistence.
08:09:22 <zhulikas> 24259095 elements
08:09:25 <mm_freak_> rntz: i think you will have to implement the growing yourself, e.g. as a wrapper around an MVector
08:09:34 <rntz> aristid: yes, that's why I specified "(mutable, not persistent)"
08:09:47 <aristid> rntz: ok, didn't read that far back.
08:09:58 <mm_freak_> rntz: another option is to use a hash table, which has that behavior built in usually
08:10:02 <zhulikas> how can I sort a list of 24259095 elements relatively fast?
08:10:15 <mm_freak_> zhulikas: vector-strategies
08:10:15 <quicksilver> whenever I've had a problem like that, a dynamically resizeable mutable array has turned out not to be the best solution.
08:10:35 <mm_freak_> zhulikas: see the implementation of my 'quickset' package
08:10:36 <shachaf> Come to think of it it's a bit strange that it doesn't exist.
08:10:58 <quicksilver> I've normally opted for a hybrid strategy where newly added elements go into a persistent structure (list/fingertree)
08:10:58 <rntz> the "problem" here is implementing a language where one of the data structures is a mutable dynamically sized array
08:11:04 <rntz> so I don't think a "better solution" exists
08:11:14 <quicksilver> and they periodically get copied into mutable storage if required.
08:11:15 <rntz> except perhaps "implement a different language", but I didn't come to #haskell for moral advice :P
08:11:38 <mm_freak_> rntz: in any case, i'm pretty sure you have to do it yourself
08:11:38 <quicksilver> just because you're implementing mutable arrays in your source language
08:11:52 <quicksilver> doesn't mean you have to use haskell mutable arrays as your implementation
08:11:57 <quicksilver> or as the only part of your implementation.
08:12:00 <rntz> yes, I could imitate them with a hashtable
08:12:04 <rntz> lua style
08:12:05 <rntz> but bleh
08:12:09 <mm_freak_> rntz: vector at least allows you to grow vectors in-place when possible
08:12:46 <quicksilver> not necessarily a hashtable
08:13:01 <rntz> or a ref to a Data.Sequence.Seq, but then access isn't really O(1)
08:13:07 <quicksilver> a map, a fingertree, a list, a list of arrays, etc etc.
08:13:12 <quicksilver> O(1) doesn't really exist.
08:13:14 <rntz> look, I know there are other ways I could do this, but frankly this is the datastructure I want
08:13:40 <quicksilver> then by all means go ahead and do so :)
08:13:56 <quicksilver> your meta-question appeared to be "Can it really be true that this isn't in the standard libraries?"
08:14:06 <rntz> I had no meta-question
08:14:08 <sclv> the most efficient way to do it is probably thru c bindings
08:14:11 <mm_freak_> rntz: i think a vector of vectors is probably easiest to implement…  it gives you the expected O(1) behavior, but requires two indexing operations
08:14:15 <quicksilver> and I was supplying the meta-answer "Probably because it isn't actually the best solution to any common problem"
08:14:19 <rntz> my question was "is there a module that gives me this" and the answer is apparently "no"
08:14:20 <sclv> this is #haskell, we always find the meta-question !
08:14:23 <rntz> and it took far too long to get a straight answer
08:14:37 <rntz> and I would appreciate if you answered the question before the supposed meta-question next time
08:14:42 <yitz> rntz: the bottome line is that you need that "reasonable allocation policy". since this whole approach is so much less common in haskell, it wouldn't be surprising if you'll have to do something yourself that basically implements such a policy.
08:14:50 <mm_freak_> rntz: "no" isn't really as useful as trying to give you some pointers
08:14:56 <rntz> actually in this case it is.
08:14:57 <quicksilver> other people had already answered the actual question, rntz.
08:15:03 <sclv> rntz: shachaf actually gave you the answer right away
08:15:09 <rntz> yes. thanks, shachaf.
08:15:19 <mm_freak_> rntz: the other way to look at it is that we're trying to help you…  if that's an offense, i'll stop
08:16:11 <sclv> the default assumption when someone wants something v. unhaskelly is that maybe they're not familiar with the more fp solutions in that space
08:16:21 <sclv> 90% of the time in this channel its true
08:16:42 <sclv> the other 10% the interlocutor needs to do a bit more work to make clear that yes they're familiar with other approaches and no those aren't suitable
08:17:11 <sclv> this is typically more efficient for answering most questions well most of the time
08:17:30 <sclv> it does have a bit of worst-case complexity though
08:17:42 <sclv> haha just like a hashtable!
08:17:45 <Eduard_Munteanu> How do I convert a (Nominal)DiffTime to an Integer representing picoseconds?
08:18:07 <mm_freak_> Eduard_Munteanu: round
08:18:39 <sclv> difftime is fractional and ord
08:18:44 <sclv> erm, and num
08:18:52 <sclv> and real even
08:18:53 <Eduard_Munteanu> Hm, I see, thanks.
08:19:17 <M30W> String vs ByteString. Anyone mind telling me the reason to how ByteString gives a huge performance boost and why it exists and didn't just replace String?
08:19:20 <mm_freak_> i love the Real class in haskell
08:19:29 <shachaf> Yes, it's wonderful.
08:19:34 <mm_freak_> class Real a where toRational :: a -> Rational
08:19:37 <DMcGill> M30W: Strings are singly linked lists.
08:19:44 <yitz> M30W: if anything, Text should replace String, not ByteString
08:19:46 <DMcGill> Easy to understand and to pattern match on
08:19:54 <shachaf> M30W: ByteString is actually not for the same thing as String.
08:19:58 <DMcGill> However, indexing is O(n)
08:20:00 <shachaf> M30W: You want to compare String to Text.
08:20:06 <shachaf> ByteString should be compared to [Word8]
08:20:07 <M30W> And ByteStrings are literally the string stored far better in ram.
08:20:17 <ryant5000> what's a good library for getting https these days?  I've been using the curl library, but it's not very haskellish
08:20:20 <shachaf> M30W: No, a ByteString is *bytes* stored in RAM.
08:20:26 <shachaf> Bytes aren't characters!
08:20:33 <Eduard_Munteanu> Prelude Data.Time.Clock> round $ picosecondsToDiffTime 100 :: Integer
08:20:33 <Eduard_Munteanu> 0
08:20:34 <M30W> shachaf: That's what I meant lol
08:20:36 <yitz> M30W: no. ByteString is not a string of text.
08:20:46 <mm_freak_> M30W: ByteStrings aren't for text, but for actual binary blobs of data
08:20:58 <Eduard_Munteanu> mm_freak_: the docs say conversion function treat difftimes as seconds... :/
08:21:01 <M30W> Ahh
08:21:20 <mm_freak_> Eduard_Munteanu: round (1000 * myNominalDiffTime)
08:21:44 <DMcGill> However, Text is still a huge improvement on String so M30W's question still stands
08:21:54 <mm_freak_> as sclv pointed out, NominalDiffTime is a Num =)
08:22:02 <shachaf> Text is an improvement on String for some things and the opposite for other things.
08:22:29 <Eduard_Munteanu> Anyway, it's probably an XY problem... what I really want to do is take a NominalDiffTime and mod it to another one.
08:22:41 <sclv> ?ty mod
08:22:42 <lambdabot> Integral a => a -> a -> a
08:23:43 <Eduard_Munteanu> Why isn't (Nominal)DiffTime an Integral? :/
08:23:46 <sclv> so either you integralify it or you write a mod-like thing that works on reals, since i think it is a real too
08:24:05 <sclv> its in seconds, so you need fractional bits to get enough precision
08:24:33 <Eduard_Munteanu> :(
08:24:59 <quicksilver> there is already a mod-like thing which works on fractionals
08:25:03 <quicksilver> @hoogle mod'
08:25:03 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
08:25:03 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
08:25:11 <Eduard_Munteanu> What can I use to get a number of pico/nano/microseconds since the unix epoch?
08:25:16 <quicksilver> > 2.5 `mod'` 1.1
08:25:18 <lambdabot>   0.2999999999999998
08:25:35 <quicksilver> you should be able to use mod' on NominalDiffTimes
08:25:41 <Eduard_Munteanu> Hm.
08:26:01 <Eduard_Munteanu> Thanks, I'll try that.
08:26:18 * sclv was not aware of mod'
08:27:02 <yitz> Eduard_Munteanu:  Data.Time.Clock.POSIX.utcTimeToPOSIXSeconds
08:27:40 <quicksilver> also you can just use realToFrac to convert your nominaldifftime to Rational and multiply by 10^12 (to get picoseconds)
08:27:50 <quicksilver> many ways this cat can be skun
08:28:19 <Eduard_Munteanu> yitz: I think I want getPOSIXTime, I need better precision than mere seconds.
08:28:35 <yitz> Eduard_Munteanu: ok sounds good
08:28:47 <Eduard_Munteanu> "skun"? First time I hear that. :)
08:29:56 <startling> it's actually "skan"
08:30:07 <yitz> Eduard_Munteanu: actually, utcTimeToPOSIXSeconds gives you a NominalDiffTime. so on the one had you do get the precision, but on the other hand the cat is rescunned.
08:30:22 <Eduard_Munteanu> Heh.
08:36:59 <jesyspa> Let's say I have a type T with some constructors X, Y, Z.  Is it theoretically possible to write a function f that returns the number of parameters X, Y, and Z take without enumerating?  (i.e., how many arguments they must be passed before you get something other than a function?)
08:38:42 <byorgey> jesyspa: you can do it if you have an instance of Data for your type
08:38:53 <byorgey> which lets you inspect the actual data type definition
08:39:20 <jesyspa> Interesting, will take a look, thanks.
08:39:23 <Eduard_Munteanu> Or TH I guess, but no, not "normally".
08:39:28 <shachaf> byorgey: Does it actually?
08:39:40 <jesyspa> Is TH template Haskell?
08:39:43 <byorgey> but that's sort of "cheating".  At a fundamental, theoretical level, it can't be done unless you have some extra information lying around (like a Data instance) to tell you the answer.
08:39:43 <shachaf> I think I tried to figure out how to figure out constructor arity with Data.Data.Data and didn't manage it.
08:40:09 <shachaf> I might be thinking of some other information than arity, though.
08:41:02 <Eduard_Munteanu> jesyspa: yes
08:41:34 <byorgey> shachaf: I've never actually done it, I assumed it would be possible, but I don't actually know for sure.
08:42:29 <sclv> you can do it purely with oleg tricks
08:42:33 <byorgey> yes, I guess you can certainly do it with Template Haskell though
08:42:44 <sclv> he's got some posts on "deepest functor" or whatever
08:42:44 <byorgey> sclv: orly?
08:43:18 <jesyspa> Should I prefer TH or Data.Data?
08:43:37 <sclv> yeah -- you use typeCast' to determine when something is *not* a function
08:43:45 <sclv> or generalize for the functor instance
08:43:47 <shachaf> sclv: There's a proof that you can do anything with oleg tricks. Unfortunately the proof involves oleg tricks, so I don't understand it.
08:44:10 <Saizan> you can use ~ instead of TypeCast now
08:44:11 <byorgey> jesyspa: it depends.  Why do you want to do this?
08:44:12 <sclv> also, i can do it with plain mptcs and type families or fundeps, as long as i know what the "base type" is supposed o to be
08:44:29 <sclv> Saizan: ~ doesn't replace TypeCast in all cases, only the reasonable ones
08:44:40 <sclv> for doing type inequality type stuff you still need TypeCast
08:44:42 <Saizan> sclv: got an example?
08:44:46 <sclv> hlist!
08:44:49 <sclv> TypeEq!
08:44:52 <byorgey> sclv: but what about now that we have overlapping type family clauses?
08:45:04 <Saizan> sclv: i managed to do the IsFunction trick with ~ just fine
08:45:08 <sclv> byorgey: ah, haven't played with those yet, but i think they might finally do the trick
08:45:10 <quicksilver> you need overlapping instances to count arity, don't you?
08:45:20 <sclv> ok, I stand corrected on IsFunction then
08:45:22 <quicksilver> at least in the presence of polymorphim you do
08:45:25 <jesyspa> byorgey: For practice; I've got a type with a lot of constructors and don't want the repetition.  (Need to know number of parameters because it corresponds to resulting assembly instruction size.)
08:45:33 <sclv> yeah you need overlapping instances, but other than that its straightforward
08:45:39 <sclv> Saizan: you have code for that, btw?
08:45:45 <quicksilver> overlapping instances are not terribly straightforward IMO.
08:45:56 <sclv> I'd love a generic "tuple all the arguments" trick
08:46:13 <sclv> i would make a sweet interface to e.g. cloud haskell
08:46:23 <byorgey> jesyspa: in that case, I would prefer Data.Data
08:46:30 <byorgey> it's going to be a lot cleaner if it works
08:46:40 <byorgey> BUT we aren't sure whether it will work
08:46:49 <Saizan> sclv: got this http://code.haskell.org/~Saizan/Uncurry.hs
08:46:51 <byorgey> if it doesn't work, then forget it.
08:46:52 <sclv> i think typeable has enough information on is own
08:47:01 <jesyspa> Thanks, will use that then.  I come from C++ TMP, so ugliness won't scare me. :P
08:47:04 <sclv> you can get the type and see if is an arr type
08:47:09 <byorgey> bringing in TH is not worth it if you were not otherwise planning to use TH anyway
08:47:21 <byorgey> sclv: oh, true
08:47:22 <jesyspa> I'd like to learn TH eventually, it sounds like a lot of fun.
08:47:26 <sclv> but this only works for monomorphicish things, unless you use polytypable which is scary
08:47:28 <byorgey> jesyspa: it isn't.
08:47:29 <sclv> and olegian
08:47:42 <jesyspa> And what's this oleg tricks thing that keeps being mentioned?
08:47:44 * sclv reps for TH done right :-)
08:48:00 <byorgey> jesyspa: it is many things.
08:48:16 <jesyspa> http://okmij.org/ftp/Haskell/types.html ?
08:48:25 <sclv> basically we thought we didn't have a turing complete type system and then oleg showed that he could trick it into being one
08:48:31 <byorgey> jesyspa: yes.
08:48:34 <sclv> and once he cracked the code did all sorts of magic
08:48:39 <jesyspa> Hah, cool, will give it a read. :D
08:49:02 <sclv> its pretty dense going, and generally not recommended for production code. but its wild stuff.
08:52:01 <n-dolio> Even stuff you could use in production you should probably rewrite. oleg tends not to have the greatest coding style.
08:53:23 <hpaste> me pasted “Writer example, LYAH” at http://hpaste.org/80173
08:53:44 <wereHamster> can someone explain this syntax to me: conf@(XConfig { XMonad.modMask = modMask }) ?
08:55:09 <monochrom> that's a pattern, of the form variable@pattern
08:55:59 <monochrom> it says: match your value against the pattern, but also use the variable conf to refer to the whole value
08:56:22 <wereHamster> that one I get. But what's with the { XMonad.modMask = modMask } ?
08:57:21 <bacon_lies> http://hpaste.org/80173 <-- In this example, I'm trying to walk through what's happening in my head and failing.  First off, the a and b vars hold Writer values, right?
08:57:34 <monochrom> that creates variable modMask to refer to the field content
08:57:56 <wereHamster> is that standard haskell or does it need a special compiler flag?
08:58:03 <monochrom> regrettedly, the variable has the same name as the field name
08:58:08 <monochrom> it is standard haskell
08:59:47 <hpaste> me pasted “LYAH, Writer” at http://hpaste.org/80175
09:00:14 <bacon_lies> ^^Realized that my example was too bunched up, repasted
09:01:37 <bacon_lies> http://hpaste.org/80175 <-- So, in this, the 'a' and 'b' vars hold writer values, not the raw numbers 3 and 5, correct?
09:01:38 <owst> bacon_lies: a and b are the result *values* of the logNumber computations (i.e. 3 and 5)
09:02:03 <owst> No, they hold "raw numbers"
09:02:04 <wereHamster> I know the @-syntax from all@(x:xs), but that pattern matching of fields was new to me
09:02:39 <sclv> Saizan: can your code be made to work on heterogenous types taking an hlist, or is it limited to homogenous ones?
09:03:49 <Saizan> sclv: yup, it'd be simpler in some ways actually
09:04:06 <sclv> ok. i'm spending some time grokking it
09:04:28 <bacon_lies> Whoa. So how is are all the messages preserved in the end? (we see return (a+b) which gives a writer that issues the full report?). It seems like we are snatching the raw values shoving them in variables, discarding the message...but in the end we get the full message. Missing something
09:04:36 <monochrom> you can have { fieldname0 = pattern0, fieldname1 = pattern1 ... } in general
09:04:54 <monochrom> it matches field contents against patterns
09:05:05 <quicksilver> and those patterns can include record patterns of their own
09:05:05 <sclv> Saizan: I basically just want this: http://hpaste.org/80178
09:05:12 <quicksilver> which really doesn't look very nice to me
09:05:17 <sclv> except without the Identity hanging out at the bottom
09:05:18 <monochrom> haha
09:05:33 <monochrom> I sometimes do that
09:06:04 <owst> bacon_lies: you don't discard the log values, they're carried along. return foo means "make the computation result in foo, without altering the output"
09:06:11 <wereHamster> so I could have something like a@(X { field1 = (x:xs), field2 = b@B }) ?
09:06:48 <owst> bacon_lies: where "output" is the writer "log"
09:07:12 <monochrom> yes!
09:07:22 <wereHamster> nifty
09:07:33 <bacon_lies> but isn't return(a*b), just putting (3*5) in a minimal context? Like (15, [""])
09:07:40 <bacon_lies> I have to think about what you said for a moment
09:08:17 <monochrom> return(a*b) puts (3*5) in (15, whatever we already have)
09:08:25 <Saizan> sclv: that'd be uncurry' reify
09:08:44 <tac> bacon_lies: wouldn't [] be even more minimal than [""]?
09:09:11 <monochrom> and whatever we already have seems to be "Got number: 5"
09:09:24 <sclv> Saizan: wao. awesome.
09:09:40 <owst> bacon_lies: it does put it in the "empty context", but each sub-action's writer log is concatenated together
09:10:54 <shapr> yay code!
09:11:22 <monochrom> I see. I erred
09:11:32 * hackagebot hpasteit 0.2.0.0 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.2.0.0 (PatrickPalka)
09:11:51 <owst> bacon_lies: your log is a list; each action (logNumber 3, logNumber 5, return (a * b)) generates a "value" and a log (a list). The final value is the last action's value, and the final log is the concatenation of all the logs
09:12:38 <Saizan> sclv: i think a recent enough ghc wouldn't even need the Uncurry'/IsFunction encoding, since UndecidableInstances got more liberal
09:12:54 <sclv> didn't know that
09:13:04 <sclv> anyway, i'm going to stick with this
09:13:17 <sclv> its just what i needed
09:13:57 <owst> bacon_lies: http://learnyouahaskell.com/for-a-few-monads-more shows you how the Monad instance for (Writer w) is defined. Your w is [String], which is a Monoid, as required
09:14:34 <Saizan> cool, it works especially well for constructors, since the final return type is necessarily not a function and we can discard the whole Uncurry context
09:15:11 <bacon_lies> Right. I'm just getting my old imperative value assignment and return statements jumbled with the haskell. I get the "gist" of what is going on, but I dont' have a precision picture. I'll go back and draw out the lambda that the do statement forms to make it explicitly clear
09:17:41 <sclv> aha, mine needs undecidable but not overlapping, this of course needs overlapping. anyway, the use case is that a "closure" in the cloud haskell sense is always a function of *one* parameter
09:17:46 <sclv> which is serialized into a bytestring
09:18:22 <sclv> so if we want to pack a higher arity function into a serializable closure we need to uncurry it, and its nice to do so automatically
09:18:39 <sclv> i think this completes my implementation of a frontend to CH with no template haskell
09:19:48 <Saizan> as long as the user don't get scared by the type hackery :)
09:19:53 <Saizan> *users
09:20:07 <sclv> less scary than TH!
09:21:32 * hackagebot hpasteit 0.2.1.0 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.2.1.0 (PatrickPalka)
09:21:50 <Lethalman> ha! that's what I need ^^
09:23:47 <Lethalman> oh I can't install it
09:23:57 <byorgey> Lethalman: why not?
09:24:30 <Lethalman> byorgey, http://paste.debian.net/221418/
09:25:04 <byorgey> oh, it *requires* base-4.6 ?
09:25:22 <byorgey> I bet that constraint could be relaxed
09:25:40 <byorgey> you'll have to ask parcs I suppose
09:29:38 <parcs> Lethalman: i suppose i should relax the depencies :) one sec
09:29:45 <Lethalman> thanks :)
09:37:27 <parcs> Lethalman: phew, done http://hackage.haskell.org/package/hpasteit-0.2.2.0
09:41:22 <eacameron> Is there a type class to describe all string-like data types? I would prefer not to write functions that are specific to ByteString, or Text if I can use a type class constraint to make them more generic...
09:41:33 * hackagebot hpasteit 0.2.2.0 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.2.2.0 (PatrickPalka)
09:41:35 <byorgey> parcs: what does hpasteit view  do ?
09:41:44 <ezyang> There is IsString
09:41:50 <byorgey> I tried it and nothing seems to happen
09:41:59 <ezyang> But it probably doesn't have enough methods for you to do anything useful.
09:42:07 <parcs> byorgey: try 'hpasteit view "http://hpaste.org/80185"'
09:42:18 <parcs> or hpasteit view 80185
09:42:27 <DrChaos> how do I install hpasteit?
09:42:35 <elliott> cabal install hpasteit?
09:42:36 <DrChaos> I want it to install to ~/bin
09:42:42 <byorgey> parcs: that's what I did.  nothing happens.
09:42:47 <byorgey> parcs: what is supposed to happen?
09:42:54 <DrChaos> zsh: command not found: cabal
09:42:54 <ilyak> I wonder why isn't there a function that does (a -> b) -> [a] -> [(a, b)]
09:43:03 <ilyak> Am I missing something?
09:43:17 <shachaf> map (\x -> (x, f x))?
09:43:18 <dmwit> DrChaos: Run bootstrap.sh in the tarball at
09:43:20 <dmwit> ?hackage cabal-install
09:43:20 <lambdabot> http://hackage.haskell.org/package/cabal-install
09:43:26 <eacameron> ezyang: yeah it just has lines/unlines words/unwords
09:43:30 <parcs> byorgey: the paste gets downloaded locally, $EDITOR or vi gets called with the file path of the local paste
09:43:32 <ilyak> shachaf: Writing this every time is a waste
09:43:35 <Lethalman> parcs, why does this happen? http://paste.debian.net/221423/
09:43:40 <eacameron> maybe something more like IsList?
09:43:45 <shachaf> ilyak: It doesn't come up very often for me.
09:43:47 <eacameron> that would have break, span, etc...
09:43:55 <shachaf> What's the context?
09:44:12 <shachaf> You can also say "zip xs (map f xs)"
09:44:16 <dmwit> eacameron: I think the "lens" package has a traversal for String, Text, ByteString, etc.
09:44:17 <Lethalman> parcs, I've tweaked the cabal config to always compile with profiling
09:44:26 <dmwit> traversals... give you a lot
09:44:34 <ilyak> shachaf: We use this function a lot (not in Haskell obviously), we call it zipWith
09:44:39 <shachaf> Which is (zip <*> map f), of the (zip <*>) family.
09:44:48 <elliott> ilyak: Isn't that functorial strength?
09:44:50 <parcs> byorgey: oh, looks like when $EDITOR is empty getEnv returns Just ""
09:44:59 * DrChaos installs cabal-rpm
09:45:04 <byorgey> parcs: my $EDITOR is  "emacs -nw"
09:45:11 <byorgey> maybe the -nw is causing trouble
09:45:22 <ilyak> and there is also groupBy: (a -> b) -> [a] -> [(b, [a])]
09:45:23 <DrChaos> byorgey -> how do you access the menu bar in emacs -nw?
09:45:27 <parcs> byorgey: oh! right
09:45:33 <parcs> byorgey: i'm using rawSystem instead of system
09:45:35 <shachaf> elliott: Is it?
09:45:40 <parcs> i guess system is the right thing here
09:45:50 <dmwit> There is no right thing. =(
09:45:50 <ilyak> And personally I think that people who invented map-reduce were slightly wrong
09:46:03 <parcs> Lethalman: oh, it's because you've installed some libraries against bytestring 0.9 when i require bytestring 0.10
09:46:09 <parcs> Lethalman: i should relax that dependency as well
09:46:13 <ilyak> The main, most useful operations should be not map and reduce, but zipWith and groupBy
09:46:14 <monochrom> Lethalman: it is because hpasteit wants bleeding edge bytestring and you are just one version behind. etc etc
09:46:15 <Lethalman> parcs, ahah yes thanks :)
09:46:25 <ilyak> you can solve so much more problems with those two
09:46:42 <Lethalman> :t zipWith
09:46:43 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
09:46:49 <ilyak> in fact, map and reduce are degenerate versions of zipWith and groupBy
09:46:51 <byorgey> DrChaos: F10, or M-x menu-bar-open .
09:46:51 <monochrom> basically the author assumes everyone is at GHC 7.6 while the rest of us are with Haskell Platform
09:47:02 <ilyak> Lethalman: That's the wrong zipWith
09:47:10 <byorgey> (I never use the menu bar though)
09:47:11 <Lethalman> :S
09:47:15 <monochrom> which is GHC 7.4
09:47:19 <zhulikas> someList :: [Int]
09:47:23 <Lethalman> ilyak, functors, perhaps?
09:47:24 <dmwit> :t map . (id &&&)
09:47:25 <lambdabot> (c -> c') -> [c] -> [(c, c')]
09:47:27 <zhulikas> can I expect this to be memoized?
09:47:35 <zhulikas> if I do repetitive access to this list
09:47:41 <zhulikas> (compiled with -O2)
09:47:42 <elliott> zhulikas: It's shared, yes.
09:47:44 <byorgey> zhulikas: yes
09:47:50 <elliott> Not really memoisation.
09:48:12 <zhulikas> damn, then something is really wrong with rest of my algorithm :)
09:48:23 <zhulikas> it's running for a couple of minutes now
09:48:34 <ilyak> It's not that they are hard to implement
09:48:40 <ilyak> (groupBy is a little tricky)
09:48:47 <zhulikas> it is supposed to though, I have a list of 24259095 elements, looking up values there
09:48:48 <ilyak> but it's that they make you like a king kong
09:48:50 <zhulikas> ohhhh
09:48:52 <zhulikas> I know!!!!
09:48:53 <ilyak> vastly more powerful
09:49:00 <ilyak> once you wield those two functions
09:49:06 <zhulikas> I think vector allows O(1) access to elements
09:49:06 <monochrom> I would say it counts as memoization
09:50:01 <elliott> I think calling it memoisation is an indication you expect things of the compiler it's not doing.
09:50:24 <elliott> Or even, thinking of it as more unreliable than it is.
09:50:32 <shachaf> dons would disagree with you, and tell you that it's a common misconception.
09:50:56 <shachaf> http://stackoverflow.com/a/10174708/712548
09:52:22 <shurikas> ok, I was wrong about vector access
09:52:55 <zhulikas> it allows access by index, not by value
09:52:57 * DrChaos is building an RPM version of the latest "Cabal" package
09:53:02 <eacameron> dmwit: interesting, I'll have to look into that
09:53:03 <zhulikas> I need to look up if vector contains an element
09:53:31 <zhulikas> ahhh, elem
09:53:32 <zhulikas> \o/
09:53:34 <HugoDaniel> hi
09:53:47 <HugoDaniel> how do i add strictness anotations to a datatype that i have defined with record syntax ?
09:54:01 <shachaf> ! in front of the type
09:54:36 <|||tux||> zhulikas: Maybe you should look at Data.Set?
09:55:20 <HugoDaniel> shachaf: so: data T = T { mytype :: !Int } ?
09:55:22 <HugoDaniel> can i have !Maybe Int ?
09:55:39 <shachaf> HugoDaniel: Sure, the same way you can have it without record syntax.
09:55:44 <parcs> ugh ghc 7.4 doesn't have lookupEnv either :(
09:55:51 <Clint> is there an advantage in using Down over sortBy (flip compare) ?
09:55:53 <HugoDaniel> !Maybe Int outputs an error :/
09:56:03 <iratsu> !(Maybe Int)
09:57:46 <HugoDaniel> oh, cool, thanks
09:57:49 <HugoDaniel> ttyl gotta go
09:58:06 <tromp> :t showIntAtBase
09:58:08 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
09:58:40 <tromp> :t intToDigit
09:58:41 <lambdabot> Int -> Char
10:00:05 <tromp> > map (\x->showIntAtBase 3 intToDigit x "") . iterate (*2) $ 1
10:00:07 <lambdabot>   ["1","2","11","22","121","1012","2101","11202","100111","200222","1101221",...
10:01:25 <Lethalman> :t showIntAtBase
10:01:26 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
10:01:59 <tromp> @hoogle showIntAtBase
10:01:59 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
10:02:27 <Lethalman> why the last "" in that lambda then?
10:03:06 <shachaf> Lethalman: Look up ShowS
10:03:17 <shachaf> (For example, by typing :i ShowS in ghci.)
10:03:37 <|||tux||> Does lambdabot also have :i ?
10:03:38 <Lethalman> ah
10:03:52 <Lethalman> shachaf, that's subtle :)
10:03:54 <startling> |||tux||: no
10:04:02 <parcs> Lethalman, byorgey: can you try the latest version? http://hackage.haskell.org/package/hpasteit-0.2.3.0
10:06:34 * hackagebot hpasteit 0.2.3.0 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.2.3.0 (PatrickPalka)
10:07:46 <parcs> i should relax the dependencies on directory, process and network too
10:08:25 <Lethalman> parcs, installing deps, let's see... thanks :)
10:10:29 <DrChaos> will somebody please tell me why HPateIt.hs fails to compile with: 101:46: Not in scape: `lookupEnv'?
10:10:40 <parcs> yeah, i just fixed that
10:10:55 <parcs> try 0.2.3.0 (you can just downoald the tarball instead of running cabal update)
10:11:10 <eacameron> I haven't truly mastered the art of "Hoogling" yet: could some one show me how to see if there is something to do this? (a -> c) -> (b -> d) -> Either a b -> Either c d
10:11:44 <fmap> @ty (+++)
10:11:45 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
10:11:46 <dmwit> :t (+++)
10:11:47 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
10:12:01 <Clint> eacameron: http://hackage.haskell.org/packages/archive/bifunctors/3.0.2/doc/html/Data-Bifunctor.html
10:12:22 <parcs> also i'm truncating unicode characters all over the place. damn
10:12:32 <eacameron> Clint: fmap: dmwit: wow...cool
10:12:45 <eacameron> was that from hoogle or from memory?
10:13:40 <hpaste> DrChaos pasted “via HPasteIt” at http://hpaste.org/80188
10:13:53 <eacameron> looks like Prelude doesn't put either into Bifunctor or ArrowChoice
10:13:58 <eacameron> is that done somehwere?
10:14:05 <eacameron> *Either not either
10:14:27 <shachaf> eacameron: The ArrowChoice instance is (->), not Either.
10:14:33 <shachaf> a = (->)
10:14:50 <shachaf> So (b -> c) -> (b' -> c') -> Either b b' -> Either c c'
10:15:31 <eacameron> shachaf: I'm not sure what that means...
10:15:52 <hpaste> DrChaos annotated “via HPasteIt” with “modified intersperse' + error” at http://hpaste.org/80188#a80189
10:15:52 <shachaf> eacameron: Control.Arrow is weird. Just pretend it has the type I wrote.
10:16:07 <shachaf> eacameron: Bifunctor isn't part of base, unfortunately.
10:16:19 <eacameron> shachaf: so it works with Either...but not because there is an explicit Either instance?
10:16:29 <shachaf> @ty (+++)
10:16:30 <elliott> It works with Either because the function's type has Either in it.
10:16:30 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
10:16:33 <shachaf> That type already has Either in it.
10:16:42 <elliott> class ArrowChoice a where (+++) :: a b c -> a b' c' -> a (Either b b') (Either c c')
10:16:46 <elliott> instance ArrowChoice (->) where ...
10:16:53 <eacameron> elliott: oh...so I was thinking way too hard
10:17:13 <DrChaos> would somebody please look at my paste? I know that I need to carefully read the line that says (x : sep)
10:17:43 <shachaf> DrChaos: intersperse' takes two arguments; you're only giving it one.
10:17:47 <eacameron> elliott: OHHH got it
10:17:49 <eacameron> thank you
10:18:41 <DrChaos> shachaf -> duh.
10:18:54 <shachaf> DrChaos: You don't need to use arrows for addressing people. Even in #haskell.
10:19:07 <shachaf> DrChaos: Also, you should pay attention to all those yellow and red boxes on hpaste.
10:19:55 <DrChaos> I really don't want to use foldr or foldl
10:20:09 <DrChaos> I'll listen to what it says about brackets
10:20:55 <shachaf> OK, the foldr thing is a fair point, if you're doing this to learn.
10:21:06 <shachaf> And the map thing.
10:21:35 * hackagebot repa-devil 0.3.2.2 - Support for image reading and writing of Repa arrays using in-place FFI calls  http://hackage.haskell.org/package/repa-devil-0.3.2.2 (RaphaelJavaux)
10:21:51 <eacameron> wow that "lint" feature of hpaste is awesome...is there a way to use that without Hpaste?
10:22:13 <dmwit> cabal install hlint
10:22:23 <DrChaos> I just eliminated both redundant brackets warnings
10:22:54 <`^_^v> i have 2 lists and i want to find the first element between them that differs. is there a better way to do this than zip and drop?
10:23:15 <Lethalman> so many libraries to compile to install hpasteit... .cabal is going to be huge :)
10:23:31 <shachaf> zip seems pretty reasonable.
10:23:36 <shachaf> I'm not sure how you'd use drop
10:23:45 <shachaf> (Unless you mean dropWhile.)
10:23:49 <`^_^v> yes
10:24:12 <`^_^v> actually, the problem is finding the last element that doesn't differ
10:24:20 <`^_^v> sorry
10:25:12 <shachaf> So reverse and find the first equal pair?
10:25:49 <`^_^v> the lists aren't necessarily the same size
10:26:05 <DrChaos> this doesn't make much sense: intersperse' sep (x:xs) = intersperse' sep (x : sep : xs)
10:26:33 <DrChaos> what I want to do is add the seperator to a list item for every list item except the last
10:27:00 <DrChaos> but how to call intersperse' with the rest of the list as an argument?
10:28:33 <DrChaos> besides I get this scary compilation error, and I don't know why
10:30:07 <Lethalman> DrChaos, x : sep : (intersperse' sep xs)
10:30:41 <Lethalman> DrChaos, then you want an exist condition on intersperse' _ [x] to avoid adding the separator
10:30:50 <Lethalman> *exit
10:31:14 <DrChaos> Lethalman -> huh? won't that only add the separator to the first list item?
10:31:36 * hackagebot hpasteit 0.2.4.0 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.2.4.0 (PatrickPalka)
10:33:10 <hpaste> DrChaos annotated “via HPasteIt” with “current intersperse' + error” at http://hpaste.org/80188#a80195
10:33:21 <Lethalman> parcs, works thanks :)
10:33:30 <DrChaos> Lethalman -> please take a look at that
10:33:49 <parcs> Lethalman: yay
10:33:58 <Lethalman> DrChaos, (x:[]) is [x]
10:34:15 <DrChaos> yes
10:34:20 <Lethalman> DrChaos, then you must return a list, not an element
10:34:29 <DrChaos> that was my thought
10:35:13 <DrChaos> OMG! It works!
10:35:18 <hpaste> edwardk pasted “A prefix and suffix sum applicative” at http://hpaste.org/80196
10:35:31 <DrChaos> Lethalman -> how did you get the idea for x : sep : ?
10:36:10 <Lethalman> DrChaos, mh... that was natural, you just need a little more practice
10:36:49 <DrChaos> Lethalman -> what exercises should I be working on?
10:37:02 <DrChaos> I need simpler exercises than implementing all of the rest of Data.List
10:37:24 <DrChaos> they have some complex functions in Data.List that I'm not sure I can implement
10:37:26 <DrChaos> ]
10:37:49 <Lethalman> DrChaos, don't know, I don't usually do exercises... I just write the program I want and solve problems by learning on the way
10:38:23 <DrChaos> Lethalman -> there is a funny show called Sergeant Frog. In the first episode the alien frog tries to take over and enslave the human race with a vacuum cleaner
10:38:51 <DrChaos> he says that he has gotten one of the earth's most powerful weapons [the vacuum cleaner]
10:39:27 <DrChaos> that must be the Super Suck 9000
10:39:45 <DrChaos> ok, </offtopic>
10:43:58 <Lethalman> DrChaos, :S
10:44:06 <hpaste> DrChaos annotated “via HPasteIt” with “intersperse': final version” at http://hpaste.org/80188#a80197
10:44:41 <Guest9118> Anybody else coming from a Java background?
10:44:59 <Lethalman> DrChaos, or intersperse' _ = id :-)
10:45:26 <Lethalman> mh
10:45:27 <Lethalman> no
10:45:37 <Lethalman> DrChaos, forget what I said, that can't work
10:55:44 <Lethalman> DrChaos, for example you could rewrite it using foldr ;)
10:56:23 <MrChutney> http://screencloud.net/v/mn3M
10:56:32 <MrChutney> ghc seems to be complaining about my "let" there for some reason -
10:56:53 <MrChutney> with "parse error on input 'let'"
10:57:11 <MrChutney> I am so confused! I can't figure out what I did wrong there
10:57:24 <DrChaos> :t foldr
10:57:25 <lambdabot> (a -> b -> b) -> b -> [a] -> b
10:57:35 <Nereid> @let f _ [] = []; f s (x:xs) = x : foldr (\a b -> s:a:b) [] xs in (f 0 [], f 0 [1], f 0 [1,2,3])
10:57:35 <lambdabot>   Parse error: in
10:57:41 <DrChaos> what does this type signature mean?
10:57:42 <Nereid> > let f _ [] = []; f s (x:xs) = x : foldr (\a b -> s:a:b) [] xs in (f 0 [], f 0 [1], f 0 [1,2,3])
10:57:44 <lambdabot>   ([],[1],[1,0,2,0,3])
10:58:16 <Nereid> DrChaos: foldr takes 3 arguments: a function (a -> b -> b), a value  of type b, and a list of type [a]
10:58:16 <DrChaos> a function that takes a variable of type a, takes a variable of type b, returns a variable of type b, and another function ...
10:58:36 <DrChaos> Nereid -> can you show me a simple foldr example?
10:58:43 <Nereid> > foldr (+) 0 [1..10]
10:58:43 <Hafydd> MrChutney: I'd guess because you are using a foul indentation scheme.
10:58:45 <lambdabot>   55
10:59:01 <Hafydd> MrChutney: see if adding braces and semicolons fixes it ,and then you'll know.
10:59:03 <Nereid> > foldr (:) [] [1..10]
10:59:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:59:11 <MrChutney> OK thanks, Hafydd, I'll try that
10:59:12 <monochrom> MrChutney: paste the same code to a pastebin. the point is to see whether you get the same alignment.
10:59:27 <MrChutney> Or well, I'll try a pastebin then
11:01:36 * hackagebot keyvaluehash 0.3.1.1 - Pure Haskell key/value store implementation  http://hackage.haskell.org/package/keyvaluehash-0.3.1.1 (EyalLotem)
11:01:50 <Nereid> > foldr (\a b -> (a:head b):b) [[]] [1..5]
11:01:51 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
11:04:00 <MrChutney> Ah, here we go. My vim is configured not to expand tabs right now
11:04:11 <MrChutney> I'll see if things change if I expand tabs to spaces...
11:04:13 * shapr boings quietly
11:06:21 <MrChutney> Fixed!
11:06:25 <MrChutney> Thank you very much
11:06:39 <Nereid> MrChutney: also, :help 'listchars'
11:06:42 <Nereid> in vim
11:07:54 <Nereid> MrChutney: makes it easy to spot tabs
11:08:10 <DrChaos> is $ function application and . function composition?
11:08:14 <Nereid> yes
11:08:28 <DrChaos> what does <+> do?
11:08:48 <Nereid> where do you see that?
11:08:48 <derdon> how must the function signature be in http://bpaste.net/show/67952/?
11:09:23 <DrChaos> Nereid -> things like XMonad configuration file
11:09:40 <DrChaos> can <+> mean different things depending on context?
11:09:42 <mauke> derdon: remove the signature, let ghci tell you
11:10:06 <derdon> mauke: ghci complains then as well
11:10:16 <mauke> derdon: yes, because you messed up the order of your arguments
11:10:49 <Nereid> DrChaos: I dunno, maybe it's something specific to xmonad
11:10:52 <mauke> DrChaos: start ghci, 'import XMonad', ':t (<+>)'
11:11:00 <mauke> report results :-)
11:11:11 <derdon> mauke: oh
11:11:14 <Nereid> ah, it is.
11:11:33 <Nereid> DrChaos: you can find out yourself.
11:11:35 <Nereid> @where hayoo
11:11:35 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:12:58 <DrChaos> hold on, let me reboot my other laptop into Linux
11:13:06 <DrChaos> I want my xmonad configuration file
11:18:42 <derdon> mauke: the order of the arguments was really the problem, thank you
11:21:37 * hackagebot gravatar 0.5.2 - Look up gravatar image urls by email address  http://hackage.haskell.org/package/gravatar-0.5.2 (PatrickBrisbin)
11:21:39 * hackagebot checkers 0.3.0 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.3.0 (ConalElliott)
11:21:54 <b__> is there a consensus in the community about classy-prelude?
11:22:06 <sclv> no. but lots of people don't like it at all
11:22:17 <sclv> there was  a lot of criticism when it was released
11:22:30 <sclv> which is why they backpedaled and did basic-prelude, etc.
11:22:34 <elliott> b__: not consensus, but imo it sucks :P
11:22:51 <b__> but why does it suck?, en bref?
11:23:01 <sclv> the only reason i'm not saying "the consensus is: don't use it" is because obviously, some people (the devs) like it
11:23:12 <sclv> you should dig up the old reddit thread
11:23:14 <elliott> it's been written about more than I care to, but briefly, misuse of non-semantic classes
11:23:16 <sclv> it was a lengthy discussion
11:23:22 <b__> okay
11:24:43 <b__> does it try to solve a problem that (in your view) isn't there, or does it solve it the wrong way?
11:27:32 <scooty-puff> can a sum type have another sum type unpacked into it?
11:28:04 <hpaste> scooty-puff pasted “unpack” at http://hpaste.org/80201
11:28:09 <shachaf> No, GHC doesn't support unpacking sums in any way.
11:28:09 <scooty-puff> (i ask because i am not getting a warning for the above)
11:29:54 <shachaf>     Ignoring unusable UNPACK pragma on the first argument of `Node'
11:30:18 <derdon> is haddock the way to go for documenting haskell code?
11:30:41 <derdon> (don't want to waste time learning the "wrong" tool)
11:31:11 <shachaf> Yes.
11:31:35 <derdon> thanks :)
11:34:43 <scooty-puff> shachaf: hmm, i may need to check my settings
11:35:34 <byorgey> sclv: re: themes on streams, yes, http://byorgey.wordpress.com/2011/05/20/themes-on-streams-part-ii/
11:35:45 <byorgey> sclv: and thanks for the link, I hadn't actually seen that!
11:36:02 <sclv> came from a paper by kock on polynomial functors
11:36:24 <sclv> thx for the link, dunno how i missed it :-)
11:37:29 <byorgey> yeah, I need to look more carefully at some of kock's papers
11:37:37 <byorgey> no worries =)
11:38:02 <byorgey> sclv: in that post I refer to a third post which I never wrote
11:38:27 <sclv> ah, good, so then i won't have to go and ask you again
11:38:32 <byorgey> sclv: however I think part II contains enough that you could easily reconstruct the content of the missing third post =)
11:38:37 <noobvasu> hi guys,
11:38:53 <sclv> so i've been pondering napieran functors more btw
11:38:56 <noobvasu> I was recently reading a blogpost by micheal synoman
11:39:07 <byorgey> sclv: ah, cool
11:39:12 <noobvasu> about is basic-prelude and classy-prellude
11:39:21 <sclv> and have a sort of intuition for log (a + b) --> log  a  + log (1 + a / b)
11:39:29 <sclv> but of course its practically meaningless
11:39:54 <sclv> but it did send me chasing more stuff on subtraction and division on functors (what sent me to kock)
11:39:54 <noobvasu> his main USP was functions on non-concrete types
11:40:03 <sclv> any good references that you might have?
11:40:38 <noobvasu> is it more difficult to write functions on non-concrete collections? how one achieves that
11:41:18 <noobvasu> instead of assuming a random access list , one can assume a forward foldable container/collection
11:41:31 <byorgey> sclv: another good reference is Fiore and Leinster, "Objects of categories as complex numbers"
11:41:38 * hackagebot checkers 0.3.1 - Check properties on standard classes and data structures.  http://hackage.haskell.org/package/checkers-0.3.1 (ConalElliott)
11:42:01 <sclv> ah right, i was looking at that. subject to some rules in can subtract and divide "en passant" which is v. helpful
11:42:02 <noobvasu> Any starting material on writing uber-generic code in haskell
11:42:09 <byorgey> sclv: right
11:42:22 <sclv> but i don't know if i can connect e.g. subtraction or division back to anything else as such
11:42:49 <noobvasu> I have read a few articles and some code about D's Ranges
11:43:01 <sclv> i don't know if any of that relates to the subtraction and division in that "connecting types and physics" paper by sabry that was making the rounds
11:43:10 <noobvasu> they look promising for a mutable first language
11:43:17 <byorgey> sclv: yeah, I've been wondering that too.  I haven't come up with anything.
11:43:28 <noobvasu> I'm not sure how you do that in haskell
11:43:37 <sclv> when you take the log of a sum you do get this notion of "ok, now I get to tell my caller the structure rather than vice versa"
11:43:40 <sclv> that feels familiar
11:43:47 <sclv> like continuation encoding
11:43:58 <byorgey> hmm, right
11:44:18 <byorgey> and the notion of negatives in that paper is traveling backwards in time
11:44:26 <byorgey> which might be connected somehow
11:44:55 <byorgey> oh, wait, never mind
11:52:38 <adek05> Do you know if it is possible to somehow tell Data.Aeson autogenerated (by TH) serializerer to JSON not to include value constructor of algebraic type but directly serialize record which it constructs? So that for data Foo = Bar {...} | Baz {...} I will get <serialized {...}> instead of {"Bar":<serialized {...}>}.
11:53:06 <k0ral> Hello
11:56:07 <k0ral> I have a syntax question: I would like to write: "data D = D { f :: A -> B -> Int }; let x = A { f a _ = 1, f _ b = 2 };" but it seems this kind of pattern matching syntax isn't allowed when defining x
11:56:44 <k0ral> I'm getting "duplicate field name `f' in record construction"
11:56:50 <shachaf> k0ral: Correct.
11:56:57 <shachaf> You can take two arguments and then do "case" yourself.
11:57:17 <shachaf> k0ral: But note that "f a _ = 1; f _ b = 2" doesn't make sense because the first case matches everything.
11:57:45 <k0ral> shachaf: 'a' and 'b' are specific values in A and B
11:58:03 <k0ral> shachaf: plus I didn't give you a real example, I made it just for the question
11:58:16 <shachaf> OK. But your example makes no sense. :-)
11:58:27 <shachaf> (Whereas it would make sense if you used "A" and "B", or something.)
11:58:29 <shachaf> (But anyway.)
11:58:31 <k0ral> I know, and was kind of expecting such remark
11:58:48 <`^_^v> anyone have any happy experience?
11:59:11 <`^_^v> i'm trying to tag my tokens with positions, but not sure how to od that
11:59:16 <shachaf> All my experiences were happy until lens came along.
12:01:02 <k0ral> I happen to be rewriting my whole code to make use of lens
12:01:14 <k0ral> what do you say ?
12:03:56 <Cale> shachaf: Are you upset with lens now? :)
12:04:32 <shachaf> Cale: lens is fine!
12:04:41 <shachaf> At the cost of my sanity
12:05:05 * edwardk apologizes for breaking shachaf
12:05:05 <Cale> `^_^v: I haven't used happy, but I'll have a quick look at the documentation for it
12:06:08 <k0ral> what's the problem with lens ?
12:06:35 <shachaf> Nothing.
12:07:10 <k0ral> should I sense irony ?
12:07:15 <edwardk> shachaf is suffering from generalization fatigue ;)
12:07:25 <edwardk> and the long release cycle ;)
12:07:44 <shachaf> The worst part is that I'm indirectly responsible for half of these!
12:08:02 <Eduard_Munteanu> I'm waiting for some process to spew out some data, and I want to read it all when hReady returns True. Any idea how to do that?
12:08:48 <shachaf> Eduard_Munteanu: Why use hReady?
12:08:59 <Eduard_Munteanu> shachaf: what else?
12:09:03 <Cale> Eduard_Munteanu: Make a new thread
12:09:06 <shachaf> What do you do if it gives you False?
12:09:24 <Eduard_Munteanu> shachaf: continue and do some other processing
12:09:35 <Cale> forkIO an action which just reads the handle immediately
12:09:37 <Eduard_Munteanu> shachaf: it's some sort of loop
12:10:10 <shachaf> Eduard_Munteanu: Why not do what Cale said, then?
12:10:21 <Eduard_Munteanu> Cale: hm, and I'm supposed to use a Chan or something to get the data back in my main process?
12:10:28 <shachaf> That way you can have one thread which keeps reading from the handle, and then do whatever when it gets data.
12:11:10 <Eduard_Munteanu> Oh well, I guess I can use an MVar.
12:11:40 * hackagebot hpasteit 0.3.0.0 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.3.0.0 (PatrickPalka)
12:12:01 <Cale> Eduard_Munteanu: there's also the lovely async library which is made for things like that
12:12:42 <Cale> http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html
12:12:48 <simpson> Wait, there's an asynchronous library for doing things which people actually recommend?
12:12:55 <shachaf> async is good.
12:13:05 <shachaf> I used to mention spawn around here but I think async is more standard now and does more.
12:13:15 <Hafydd> `^_^v: what lexical analyser are you using?
12:13:18 <shachaf> (At the cost of a slightly more awkward interface for some things, but it doesn't really matter.)
12:13:19 <simpson> Holy crap. This is a great library. I like it already.
12:13:33 * simpson makes mental note: For Twisted in Haskell, "async"
12:13:50 <Eduard_Munteanu> Cale: hrm, I'd rather do it on my own right now... so I guess it's MVars.
12:13:52 <shachaf> simpson: I don't think those are really comparable at all?
12:14:07 <shachaf> simpson: Also the whole point of "async" is to make things synchronous.
12:14:32 <Hafydd> `^_^v: you could have the position encoded as extra information inside some monad when happy is doing its computation monadically, or as a concrete field on your tokens.
12:14:51 <simpson> shachaf: The entire point of Twisted is to do things in an event-driven, asynchronous manner. The interface is pretty similar-sounding and appears to do the same things.
12:15:22 <shachaf> simpson: Doing things in an event-driven, asynchronous manner is a means, not an end.
12:15:34 <shachaf> In GHC there is usually a better way.
12:15:47 <shachaf> Namely, threads. All "async" is is a small wrapper around GHC threads.
12:15:50 <deus_rex> :t (<*>) . pure
12:15:52 <lambdabot> Applicative f => (a -> b) -> f a -> f b
12:15:54 <deus_rex> :t (<$>)
12:15:55 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:16:03 <deus_rex> :)
12:16:04 <simpson> shachaf: Yes, but actually getting things like timers done with threads is a PITA.
12:16:41 <shachaf> Well, "async" doesn't give you a timer.
12:16:47 <Taneb> @source liftA
12:16:47 <lambdabot> liftA not available
12:16:48 <shachaf> System.Timeout gives you something, though.
12:16:57 <shachaf> simpson: It's not particularly painful, anyway?
12:17:11 <shachaf> What do you need a timer for?
12:17:34 <simpson> Generating primitive events.
12:18:13 <shachaf> ?
12:20:11 <simpson> Eh, ignore me. I'm just bein' stupid, as usual.
12:21:15 <Lethalman> deus_rex, :S why is that?
12:21:45 <Lethalman> ah the functor of pure becomes a function?
12:22:02 <Lethalman> clear...
12:24:14 <Eduard_Munteanu> Dang, but I still need to check whether the MVar / TChan etc. actually contains something, and avoid blocking.
12:24:46 <Eduard_Munteanu> I guess tryTakeMVar is better than hReady, though.
12:25:21 <shachaf> Eduard_Munteanu: And then what do you do if the MVar is empty?
12:25:24 <monochrom> why do you avoid blocking? the answer may help
12:25:52 <Eduard_Munteanu> Ok, let me state what I'm trying to implement.
12:26:09 <hiptobecubic> Why aren't Product a and Sum a instances of functor?
12:26:22 <hiptobecubic> Well, have instance.
12:26:24 <Eduard_Munteanu> I'm controlling mplayer in slave mode. I send a bunch of commands to it, wait for it to answer, check if it's finished playing the movie etc.
12:26:24 <hiptobecubic> s
12:27:11 <Eduard_Munteanu> If the movie has finished playing, I need to load a new one. If it didn't, I still want to do some other work, like check it's in sync with a master clock.
12:28:15 <Eduard_Munteanu> Now, I can't really query mplayer whether it finished or not, it will say so when it's done.
12:28:38 <Eduard_Munteanu> So, any ideas?
12:30:13 <monochrom> I would consider this. set up a Chan or TChan. one thread blocks on mplayer still playing, when mplayer finishes playing, send a message to the channel
12:30:56 <monochrom> another thread does "some other work", of which I don't actually know the nature. but perhaps it also needs to send messages to that channel.
12:31:22 <monochrom> a third thread reads that channel and decides what to do next
12:32:36 <Eduard_Munteanu> Hm, I see... does the other thread block at all? I have a loop which must run, regardless of input/output.
12:32:54 <Eduard_Munteanu> e.g. run every millisecond or so
12:33:27 <monochrom> every thread must block. "every millisecond" means blocking for time, too
12:34:14 <monochrom> unless you want to drain electricity and have busy loops
12:34:22 <Eduard_Munteanu> Yeah, but I don't want it to block on input/output, I currently threadDelay in a loop.
12:37:42 <monochrom> perhaps there is room for a book on designing haskell concurrent programs
12:38:07 <DrChaos> are there bindings for wayland for haskell already?
12:38:13 <DrChaos> I want to code for Wayland
12:38:23 <DrChaos> I know GTK3 supports it, and so does Qt 5
12:38:46 <DrChaos> when are Haskell bindings for GTK 3 going to be released?
12:39:07 <DrChaos> I'd love to work on the bindings, but I really don't know how to progrm
12:39:24 <DrChaos> any exercises so that I can learn how to program?
12:39:27 <Lethalman> hiptobecubic, any answer to your question?
12:40:26 <hiptobecubic> DrChaos, start simple. lyah
12:40:27 <shachaf> monochrom: Simon Marlow is currently writing such a book, isn't he?
12:40:39 <hiptobecubic> Lethalman, what? About Product a and Sum a?
12:40:43 <Lethalman> hiptobecubic, yes
12:40:51 <hiptobecubic> Lethalman, doesn't appear so.
12:41:36 <Eduard_Munteanu> Hrm, why does MVar care whether it's empty or full?
12:41:43 <derdon> DrChaos: for excercises, eulerproject is a good place. especially with haskell
12:42:06 <Eduard_Munteanu> vs using Maybe to do that
12:42:28 <shachaf> Eduard_Munteanu: That's how blocking happens.
12:42:37 <parcs> Eduard_Munteanu: you can efficiently poll on an empty mvar
12:42:46 <Eduard_Munteanu> I don't want to block :(
12:43:19 <elliott> Eduard_Munteanu: MVars being able to be empty is the point.
12:43:23 <elliott> Otherwise it's just an IORef.
12:43:35 <Eduard_Munteanu> I thought IORefs aren't threadsafe.
12:43:40 <Eduard_Munteanu> Or are they?
12:43:51 <parcs> they are
12:44:05 <thoughtpolice> you can use atomicallyModifyIORef, but it has some restrictions on its use IIRC
12:44:17 <DrChaos> derdon -> anything simpler? I have to know the basics of recursion and what "x : sep : intersperse' sep xs" really means
12:44:25 <shachaf> "threadsafe" can mean a lot of things.
12:45:50 <DrChaos> so each recursive call into intersperse'  runs "x : sep :" as well?
12:45:58 <DrChaos> oh, yes it does
12:46:13 <Eduard_Munteanu> shachaf: atomic updates, e.g. I don't get garbage if the IORef is read in the middle of a write
12:46:31 <hiptobecubic> Lethalman, well trying to do it myself... I think there's a problem with (<*>)
12:46:33 <derdon> DrChaos: read LYAH first, then (as hiptobecubic already said)
12:46:46 <derdon> DrChaos: there is a section about "thinking recursively"
12:46:47 <hiptobecubic> Product (a -> b)  doesn't make a lot of sense perhaps
12:47:02 <DrChaos> the reason why is the last :, it says append to beginning of new list returned by the return value of intersperse' sep xs
12:47:09 <sclv> you never get garbage in an IORef
12:47:17 <parcs> Eduard_Munteanu: reading and writing an ioref is an atomic operation i think
12:47:24 <sclv> what's not atomic is normal modify
12:47:28 <Lethalman> hiptobecubic, ah, because it must be a Num
12:47:29 <sclv> since it reads then writes
12:47:35 <hiptobecubic> Lethalman, because the Monoid instance requires Num
12:47:37 <hiptobecubic> yes
12:47:39 <sclv> so somebody can snake in another modification inbetween
12:47:40 <Eduard_Munteanu> What's the point of atomicWriteIORef et al. then?
12:47:45 <sclv> atomicmodify does it in one step
12:47:49 <hiptobecubic> although it *does* compile
12:47:51 <Lethalman> hiptobecubic, it can still be a functor
12:47:59 <hiptobecubic> functor does work, yes
12:48:14 <thoughtpolice> sclv: snakes are clever like that :)
12:48:15 * monochrom shakes head
12:48:22 <sclv> if I modify an IORef and someone else does, then they can logically step on one another
12:48:32 <sclv> but an atomicmodify is safe
12:49:05 <parcs> how does atomicModifyIORef work? does the RTS use a global lock that applies to every IORef in the program?
12:49:07 <Eduard_Munteanu> Hm, makes sense for the 'modify' bits.
12:49:17 <zomg> shachaf: now that you mention haskell books, anyone in particular I should be bugging about if I'm interested in maybe writing something?
12:49:50 <hiptobecubic> Lethalman, i'm just trying to see how close to foldM i can get using regular foldl
12:52:41 <hiptobecubic> It would be nice if we had instance Num a => Num (Product a) as well
12:52:45 <twanvl> parcs: I believe it uses a compare-and-swap, to see if some other thread beat you to the modification, and retry in that case
12:52:53 <twanvl> but I could be wrong
12:53:33 <Eduard_Munteanu> So a lock, basically.
12:53:51 <hiptobecubic> if *feels* like you should be able to make an applicative out of this
12:54:03 <Eduard_Munteanu> I guess you can't really do atomic updates en masse, it only works for word-sized integers.
12:54:28 <hiptobecubic> (+) <$> Product 2 <*> Product 3  -- Seems totally reasonable.
12:54:43 <twanvl> that is *not* a lock
12:55:01 <hiptobecubic> but i guess when you get  Product (2+) it's ruined
12:55:12 <parcs> twanvl: ah, i see
12:55:29 <twanvl> it is like a simple case of STM
12:56:00 <deus_rex> :t (+)
12:56:02 <lambdabot> Num a => a -> a -> a
12:56:17 <deus_rex> :t pure (+) :: (Num a) => Product (a -> a -> a)
12:56:18 <lambdabot>     No instance for (Applicative Product)
12:56:19 <lambdabot>       arising from a use of `pure'
12:56:19 <lambdabot>     Possible fix: add an instance declaration for (Applicative Product)
12:56:20 <elliott> hiptobecubic: sure Product can be Applicative
12:58:24 <DrChaos> will somebody please tell me if my function tracing is wrong?
12:59:16 <hiptobecubic> elliott, it *can*. I've written that. But I don't think you can use it as an applicative and a monoid because of the Num constraint
12:59:33 <hpaste> monochrom pasted “basic multiplex structure” at http://hpaste.org/80203
12:59:45 <monochrom> Eduard_Munteanu, see my paste
13:00:19 <shachaf> zomg: Presumably the people who might read it?
13:00:28 <shachaf> Or I don't know.
13:00:47 <shachaf> I don't think a Haskell book is very different from any other book. Or at least any other technical book.
13:00:59 <elliott> hiptobecubic: Well, if you get a Product Int as the result it'll work as a Monoid just fine.
13:01:13 <DrChaos> how do I type a down arrow?
13:01:23 <hiptobecubic> elliott, working on it. I ended up with some nested mess
13:01:29 <zomg> shachaf: hehe yeah that's what I figured =)
13:01:44 <zomg> I've written plenty of technical articles on a variety of topics but never a book
13:01:54 <Eduard_Munteanu> monochrom: hm, so basically, I should drive the "main" loop from another thread, no?
13:02:05 <Fuuzetsu> edwardk: Do you always go to talks in that white shirt and black/grey trousers? It's always easy to spot you in Haskell talk videos because of it~
13:02:16 <monochrom> I don't understand the question
13:02:23 <zomg> But the prospect of possibly making a bit of money from writing stuff I somewhat enticing so maybe I'll give it a shot =)
13:02:31 <zomg> *is
13:02:39 <shachaf> zomg: I think the approach taken with LYAH was to put up a free version online and then later turn it into a book after it was done.
13:02:56 <Eduard_Munteanu> monochrom: I was initially thinking of combining dispatcher and receiver1
13:02:56 <shachaf> But that's somewhat constraining as an approach. :-)
13:03:15 <zomg> Well at least that approach has the benefit of having people look at it so you know if it's actually making any sense to anyone else than you =)
13:03:24 <monochrom> now you know better
13:03:32 <Eduard_Munteanu> monochrom: right, thanks
13:10:44 <hiptobecubic> Lethalman, nevermind. I think I just ended up reinventing fold :: t m -> m, only stupider.
13:11:10 <Lethalman> hiptobecubic, :S
13:23:15 <j4hr0m> hi room
13:24:48 <j4hr0m> how can i compute the number n that applies to "length (unwords (take n (words xs))) < k && length (unwords (take (n+1) (words xs))) > k"
13:26:43 <croikle> length $ filter (<k) $ \n -> map (length . unwords . take n) (words xs)
13:26:46 <croikle> perhaps
13:26:59 <croikle> takeWhile, not filter
13:27:13 <j4hr0m> thanks, i will try that
13:27:19 <hpaste> jesyspa pasted “Data.Data usage -- sane?” at http://hpaste.org/80206
13:27:22 <croikle> and that map needs to be on [1..] .. shoot
13:27:44 <jesyspa> Is that a reasonable way of doing things?
13:28:03 <croikle> length $ takeWhile (<k) $ map (\n -> length . unwords . take n $ words xs) [1..]
13:30:06 <j4hr0m> croikle, thanks a lot, seems to work!
13:30:28 <croikle> cool. make sure you understand why it works, of course
13:30:53 <j4hr0m> yeah, that would be the next question.. any hints?
13:31:14 <j4hr0m> i need information about the n..
13:31:18 <j4hr0m> thats for sure
13:31:36 <croikle> well, I'm finding the (length . unwords . take n $ words xs) for each n
13:31:54 <croikle> you want the last one of those which is less than k
13:32:19 <j4hr0m> ok, got it, thanks
13:33:02 <croikle> one could translate more literally and find (last something), but then we'd need to keep the indices around
13:33:04 <j4hr0m> i need a method, how to get such solutions, it seems i am still trying the things from a wrong approach
13:33:26 <ciccio> ciccio
13:33:35 <shachaf> !list
13:33:35 <monochrom> shachaf: http://hpaste.org
13:33:45 <shachaf> monochrom: How big is the !list list?
13:34:09 <Jafet> Thought of the day: think harder.
13:34:56 <monochrom> 3
13:35:09 <shachaf> Oh.
13:35:15 <monochrom> the other 2 are oleg and hackage
13:35:20 <shachaf> I thought it was much larger.
13:36:31 <croikle> j4hr0m: well, a useful idea in some cases like this is that you can make an infinite list of all values, and then do stuff with it
13:36:40 <croikle> map is your friend
13:36:57 <croikle> there are many other ways to go, of course
13:37:31 <j4hr0m> i will meditate about that... how long are you programming haskell?
13:38:35 <croikle> I'm no guru... just find varied problems to practice on
13:38:42 <hiptobecubic> Why is "Monoid a => Monoid (Maybe a)" defined such that mempty = Nothing instead of mempty = Just mempty ?
13:38:49 <j4hr0m> that was a good idea, i am getting it, thanks a lot
13:39:10 <simpson> hiptobecubic: Think about the type of mempty.
13:39:10 <croikle> project euler is good for one sort, but it's also good to find some other things
13:39:23 <byorgey> parcs: latest version of hpasteit works for me
13:39:24 <DrChaos> how do I rebuild every cabal installed package against the system libraries for bytestring and utf8-string?
13:39:36 <hiptobecubic> simpson, Monoid a => a ?
13:40:01 <DrChaos> I don't want cabal using a newer version of bytestring and utf8-string in my home directory because that breaks XMonad
13:40:02 <elliott> hiptobecubic: because the mappend uses Nothing as the identity
13:40:07 <monochrom> because you don't need "Monoid a => Monoid (Maybe a)" for the behaviour you describe
13:40:07 <simpson> hiptobecubic: Right. How would you come up for a value when you don't know what the type is?
13:40:15 <elliott> simpson: ...?
13:40:21 <elliott> You can define another instance that uses mempty = Just mempty
13:40:35 <hiptobecubic> simpson, using the monoid instance of the parameter type
13:41:26 <simpson> hiptobecubic: Ah. So you're asking why this particular instance behaves this way?
13:41:51 <hiptobecubic> yes
13:42:05 <hpaste> DrChaos pasted “`cabal install hpasteit' output” at http://hpaste.org/80209
13:42:10 <DrChaos> please tell me I can use these packages, see this: ^
13:42:31 <j4hr0m> croikle: do you mean this? http://xaviershay.github.com/project-euler/
13:42:35 <hiptobecubic> but monochrom says it's unnecessary and i'm now thinking about why
13:42:41 <DrChaos> I don't want utf8-string or bytestring upgraded
13:42:58 <absence> has anyone used diagrams enough to know if it's possible to check if a diagram is (m)empty?
13:43:25 <croikle> j4hr0m: http://projecteuler.net/ . that page is somebody's solutions
13:43:49 <monochrom> the behaviour you describe is just lifting everything by a Just. it does not need an instance
13:44:04 <hiptobecubic> I can see that maybe it's unnecessary, given the way Just a <> Just a is defined. But that's kind of circular i think?
13:44:15 <j4hr0m> ok
13:44:22 <hiptobecubic> monochrom, oh. I guess that's all i wanted then
13:44:31 <edwardk> Fuuzetsu: nah, i just have lots of random casual office clothing ;)
13:44:52 <Fuuzetsu> ah
13:44:56 <byorgey> absence: it is possible, though there isn't a nice function for doing so.  Perhaps there should be.
13:45:04 <byorgey> absence: I would be interested to hear about your use case.
13:46:34 <byorgey> absence: isEmpty = isNothing . getOption . unDUALTree . unQD   ought to do it
13:46:57 <byorgey> might need a few extra imports
13:47:39 <byorgey> absence: also, for future reference, you can also ask questions like this in #diagrams
13:48:12 <j4hr0m> croikle: great stuff, you really helped me
13:48:36 <bxc> whats #diagrams?
13:48:55 <hiptobecubic> But we still have to wonder why Product and Sum don't have num instances
13:49:07 <croikle> j4hr0m: you're welcome. good luck with your haskell future
13:49:23 <bxc> ah diagrams
13:49:44 <absence> byorgey: thanks! i'm trying to do some recursive stuff and want to stop recursing when things get below a given size threshold. checking the size is no problem, and then it produces an empty diagram instead of whatever was supposed to be there. so i was thinking of using empty diagram as a stop condition
13:50:17 <byorgey> absence: why not just return Nothing instead?
13:51:22 <byorgey> seems a bit dodgy returning the empty diagram, sort of like returning -1 to indicate an error
13:52:06 <absence> byorgey: why not indeed, somehow i got stuck poking at the monoid stuff because it's new to me. Maybe might fit better, i'll give it a shot. thanks!
13:52:28 <byorgey> ok, cool, let us know how it turns out =)
13:56:18 <shapr> PS. it's nice to tag a github repo to match the hackage version so it's easy to get there!
13:56:32 <hiptobecubic> It would be nice if we had something like "instance Num a, Wrapper b => Num (b a)", however that would work
13:56:58 <hiptobecubic> because a lot of instances for newtype wrappers all look exactly the same except for the header
13:57:09 <nathanfh> http://hackage.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving
13:57:17 <nathanfh> hip^^
13:57:19 <byorgey> hiptobecubic: well, there's GeneralizedNewtypeDeriving
13:57:33 <hiptobecubic> Snap
13:57:42 <nathanfh> Snap is something else.
13:57:43 <hiptobecubic> I guess my ideas aren't so terrible after all
13:57:48 <byorgey> ask and ye shall reveice =)
13:58:07 <hiptobecubic> nathanfh, Snap was Snap long before Snap was Snap.
13:58:07 <byorgey> hiptobecubic: we also have that: snapframework.com
13:58:14 <byorgey> anything else you might wish for today?
13:58:31 <hiptobecubic> A pony
13:58:41 <byorgey> http://hackage.haskell.org/package/pony
13:58:47 <croikle> haskellsh
13:58:47 <nathanfh> http://www.haskell.org/haskellwiki/Web/Frameworks#Haskell_on_a_Horse
13:59:32 <hiptobecubic> And people complain that haskell doesn't have enough libraries
14:00:03 <hiptobecubic> nathanfh, link is dead
14:00:38 <nathanfh> Yeah. I'm pretty sure HoH was abandoned a long time ago.
14:00:49 <nomeata> Quick poll on a scale from 0 to 10: How geeky is someone who uses xmonad?
14:00:53 <nathanfh> It was just a web framework with a funny name the maintainer never finished.
14:00:56 <nathanfh> e
14:01:14 <byorgey> nomeata: 7?
14:01:16 <shapr> nomeata: 7 ?
14:01:18 <Spockz> does anyone remember this haskell based blogging tool where you can write posts in markdown but .lhs as well? I believe it features a gui-editor and git based storage as well?
14:01:25 <shapr> byorgey: jinx!
14:01:28 * byorgey gives shapr a high-7
14:01:31 <shapr> hah!
14:01:42 <shapr> Spockz: hakyll
14:01:52 <shapr> Spockz: But maybe you're asking about gitit?
14:01:57 <byorgey> hakyll doesn't have a gui-editor
14:01:58 <nomeata> Typical for the haskell community: lots of consensus :-)
14:02:07 <shapr> Spockz: http://gitit.net/
14:02:11 <byorgey> Spockz: yeah, probably you're thinking of gitit
14:02:22 * shapr beats the iCalendar package with a stick
14:02:25 <Spockz> shapr, byorgey: okay, I'll give that a shot :)
14:02:43 <shapr> Ok, it better compile this time.
14:03:04 <croikle> cabal install --beat-with-stick
14:03:33 <shapr> cabal install --force-reinstalls >:-(
14:04:35 <byorgey> cabal install --with-general-AI
14:05:09 <shapr> Yah, I keep having to do manual installs on my Raspberry Pi to get the most conservative package installs possible.
14:05:15 <croikle> cabal install --please --pretty-please
14:05:54 <shapr> Building takes looong, so I'd always rather use any binary deb that would satisfy the requirements, but "cabal install" defaults to getting the latest versions of the dependencies and installing them all.
14:06:01 <neutrino> hi
14:06:01 <lambdabot> neutrino: You have 2 new messages. '/msg lambdabot @messages' to read them.
14:06:29 <shapr> Oh, I got permission to NMU HaskellNet, I can do that now!
14:06:54 * shapr bops cheerfully
14:08:09 <parcs> byorgey: yay :)
14:08:16 <monochrom> cabal install --complete-but-inconsistent
14:08:42 <monochrom> yes, that's what I think of most people's cabal wishes
14:09:00 <DrChaos> monochrom -> I'd like to tell cabal not to update the bytestring or utf8-string packages at all
14:09:21 <`nand`> cabal install --with-compiler=skynet
14:09:30 <absence> byorgey: using Maybe i'll have to check for Just or Nothing because the monad version causes the entire computation to be Nothing instead of keeping the values up to that point, and the monoid version doesn't stop at Nothing. of course then i can do away with the entire Maybe and just use the size check to decide whether to recurse or not. please don't ask why i didn't think of that to begin with :D
14:09:48 <monochrom> you need a newer version of hpasteit. its constraints are relaxed
14:09:51 <parcs> DrChaos: cabal update
14:10:27 <DrChaos> ok
14:10:30 <Peaker> the hashable library breaks in interesting ways with various versions
14:10:30 <Peaker> unsafePerformIO easter eggs for breaking some referential transparency in the name of security was one fun debugging activity :)  Now getting illegal instructions in SSE2 code, despite an apparent cpuid check to verify SSE is available
14:10:50 <monochrom> 0.3.0.0 was just two hours ago
14:11:16 <monochrom> this is the problem with the author using bleeding edge version of GHC
14:11:28 <DrChaos> well huh, that resolves the issue I think
14:11:45 <shapr> @hoogle mergeWithKey
14:11:45 <lambdabot> No results found
14:11:49 <DrChaos> monochrom -> can the answer to euler project question #1 be by using a list comprehension?
14:12:02 <monochrom> I don't care about project euler
14:12:03 <hiptobecubic> DrChaos, is it the product one? Becuase use
14:12:07 <hiptobecubic> yes*
14:12:24 <DrChaos> monochrom -> any other good programming exercises then?
14:12:25 <monochrom> but all problems can be solved by list comprehensions
14:12:39 <hiptobecubic> DrChaos, there are many ways to do it and in fact you'll find that using haskell for project euler is basically cheating until you get to the upper level problems
14:12:53 <DrChaos> hiptobecubic -> oh wow
14:12:55 <DrChaos> lol
14:13:08 <hiptobecubic> There are a lot of problems that you almost just directly translate
14:13:10 <croikle> but there are >300 of them, so there's plenty more to do
14:13:23 <derdon> hiptobecubic: I don't consider that cheating.
14:13:29 <hiptobecubic> and if you read the haskell code aloud, you get the problem description back in idiomatic english
14:13:56 <DrChaos> well I'll try working a couple project euler problems, the moment I don't know how to do it I'll come back here
14:14:01 <hiptobecubic> derdon, well no. But it doesn't help you learn to waste time struggling with big int in C
14:14:11 <`nand`> brute force solutions are always so beautiful
14:14:16 <monochrom> I don't find it cheating. however, I find it uninteresting
14:14:25 <shapr> Any idea which version of containers added Data.Map.mergeWithKey ?
14:14:35 <shapr> I think I need to fix the bounds on the iCalendar cabal file.
14:14:39 <hpaste> j4hr0m pasted “linefeed with number of chars” at http://hpaste.org/80214
14:14:45 <DrChaos> to check if a number is a multiple of 3 or 5, do num % 3 == 0 || num % 5 == 0
14:14:49 <DrChaos> right
14:14:50 * shapr digs around on hackage
14:14:57 <monochrom> then again, there is probably no contradiction between cheating and uninteresting
14:15:09 <derdon> It's always a good thing if you write some code to excercise. doesn't matter if it's really about math or just to learn more about a programming language
14:15:25 <j4hr0m> does maybe anyone have a shorter/more performant version?
14:15:55 <derdon> DrChaos: there is also `rem` to get the remainder of a division
14:15:56 <monochrom> afterall, "read some formulas from your palm" is an uninteresting way to solve exam questions, too
14:16:08 <derdon> > 17 `rem` 5
14:16:09 <lambdabot>   2
14:16:22 <`nand`> as opposed to ‘read some formulas from your memory’?
14:16:24 <tac> > (negate 17) `rem` 5
14:16:25 <lambdabot>   -2
14:16:46 <monochrom> I derive some formulas during exam
14:17:10 <monochrom> but I did not say that non-cheating is interesting
14:17:13 <derdon> I prove the derived formulas of monochrom during exam.
14:18:00 <`nand`> I'm saying it's equally boring to just commit formulas to memory; you might as well just write them down and read them off a paper
14:18:10 <absence> byorgey: hpaste.org/80215 <- so this is what i came up with. is there a better or more clever way, or is that about as good as it gets?
14:18:13 <`nand`> actually, that's what we do
14:18:16 <`nand`> no point in testing that kind of thing
14:18:22 <monochrom> I agree. I give open-book exams. the most interesting and hardest kind
14:18:26 <drdo> How would one go about using netwire with something like gtk?
14:18:38 <DrChaos> wait, does using hPutStrLn in main mean main must have the type of "IO()"?
14:18:45 <monochrom> yes
14:18:52 <shapr> Aha, mergeWithKey was added in at least containers 5.*
14:18:55 <shachaf> main can also have the type "IO somethingElse"
14:19:02 <shachaf> Regardless of whether you use hPutStrLn
14:19:03 <byorgey> absence: looks good to me
14:19:08 <monochrom> I guess what shachaf says
14:19:30 <Clint> what can happen to the somethingElse?
14:19:38 <drdo> As opposed to other frp packages like grapefruit or reactive-banana, which have that "compile/actuate" kind of thing
14:19:46 <shachaf> Nothing will happen, unless you use runghc, in which case it'll be printed.
14:19:48 <shachaf> But that's a bug.
14:19:59 <shapr> Does github have some way I can connect an issue and a pull request?
14:20:01 <DrChaos> main = hPutStrLn (show (sum [ x | x <- [1..1000], x % 3 == 0 || x % 5 ==\
14:20:12 * `nand` wonders if it would be reasonable to have ‘main’ behave more like writing an expression in GHCi, where it would get run if it's an IO action; the result being ‘show’'d if a Show instance is available; and if it isn't an IO action it would just get ‘show’'d if possible
14:20:12 <hpaste> j4hr0m pasted “linefeed with number of characters per line” at http://hpaste.org/80216
14:20:18 <DrChaos> main = hPutStrLn (show (sum [ x | x <- [1..1000], x % 3 == 0 || x % 5 == 0 ]
14:20:24 <DrChaos> is my syntax correct?
14:20:31 <`nand`> then you could write stuff like ‘main = "Hello, world!"’ to write a hello world
14:20:41 <`nand`> well, not quite
14:20:44 <`nand`> that would include the "
14:20:49 <monochrom> why do you use hPutStrLn?
14:21:01 <absence> byorgey: great. while on the topic, the only way to figure out how big something will be on screen is to pass the transformations around right?
14:21:01 <`nand`> doesn't hPutStrLn need a handle?
14:21:05 <DrChaos> I want the list output to me as a string with a newline at the end
14:21:16 <monochrom> yes, but why the h?
14:21:38 <byorgey> if I understand your question correctly, then yes
14:21:40 <DrChaos> I don't think I know of all the string output functions available to me
14:21:44 <byorgey> absence: ^^
14:21:54 <monochrom> ok, then, look up putStrLn
14:22:02 <nh2> why does cabal build re-link on every invocation?
14:22:42 <nh2> can I suppress that so that it checks object file timestamps or so? I would like it to be blazing fast.
14:23:18 <derdon> DrChaos: I prefer the usage of filter to a list comprehension
14:23:27 <monochrom> cabal build does not re-link here
14:24:38 <hiptobecubic> What's the deal with fail? I know it's invoked for pattern match failures, but is that it?
14:24:44 <monochrom> yes
14:24:46 <Lethalman> I see several projects doing in main much IO for initialization, writing stuff, files and so on... (like initA; initB; writeC; saveD; ...) doesn't that defeat the purpose of not having side effects?
14:25:07 <derdon> Lethalman: you can't avoid them completely ;)
14:25:09 <Lethalman> maybe that's something not avoidable?
14:25:15 <absence> byorgey: ok, thanks :) back to coding!
14:25:33 <Lethalman> derdon, ok, but then the rest of the application tries to avoid that?
14:25:41 <derdon> Lethalman: yep
14:26:10 <derdon> Lethalman: indeed, also devs of imperative languages should do that
14:26:37 <derdon> because functions which have no side effects are easier to test and adapt
14:27:16 <Lethalman> derdon, so IO is to be isolated as much as you can?
14:27:48 <DrChaos> wait...is any number x `mod` 3 == 0 a number that is a multiple of 3?
14:28:08 <monochrom> yes
14:28:11 <derdon> Lethalman: yes
14:28:22 <tac> DrChaos: Do you know about modular arithmetic?
14:28:50 <DrChaos> MWAHAHAH, I got the answer to problem 1 right
14:28:50 <Lethalman> derdon, ok thanks
14:29:15 <derdon> DrChaos: you divide x by 3, then you look at the rest of the definition. that is what mod does. now you can answer it yourself
14:29:26 <DrChaos> apparently the problem was me specifying numbers from 1 [inclusive] to 1000 [inclusive] instead of numbers from 1 [inclusive] to 999 [inclusive]
14:29:54 <derdon> apparently you should excercise reading the problem definition.
14:30:14 <DrChaos> derdon -> that's not a clear definition of modulus
14:30:15 <NougatRillettes> did anyone ever read Categories for the working mathematician ?
14:30:23 <NougatRillettes> and if yes, what could you say about it ?
14:30:25 <shapr> Oh look, creating a pull request on github also creates an issue! https://github.com/tingtun/iCalendar/issues
14:30:28 <tac> NougatRillettes: You might want to try ##categorytheory
14:30:40 <NougatRillettes> here is a chan for this ? :D
14:30:41 <shapr> So a pull request is pretty much the same thing as an issue. That's smart.
14:30:48 <DrChaos> I'd say that modulus divides a number and checks if it divides evenly
14:30:50 <Nereid> a pull request is an issue with code attached.
14:31:16 <tac> AFAIK, Categories for the Working Mathematician is the best resource for learning category theory IF you already know a bit about algebraic geometry or algebraic topology (or something like that)
14:31:25 <Nereid> or math in general
14:31:34 <Nereid> since the examples in there are basically all motivated by stuff in math.
14:31:36 <derdon> DrChaos: no, that's not true.
14:31:51 <monochrom> I am not a working mathematicians, therefore I do not read categories for the working mathematician
14:31:55 <Nereid> DrChaos: do you know about the division algorithm?
14:32:01 <NougatRillettes> hm okay what would you say are the prerequisite ?
14:32:31 <Jafet> monochrom is an unemployed mathematician
14:32:38 <monochrom> no
14:32:50 <tac> Nereid: I know a lot of mathy who wouldn't touch Category Theory even if they were on a plane with 4 busted engines, and from the top of the ceiling, a copy of MacLane fell out instead of the normal oxygen mask, and it was the only thing that could keep them alive.
14:32:53 <Eduard_Munteanu> Jafet: aren't most of them? :P
14:33:05 <tac> mathy people*
14:33:13 <Nereid> DrChaos: for any two integers a and b, with b positive, there are unique integers q and r such that a = qb + r and 0 <= r < b.
14:33:18 <tac> (if you want to be grammatically correct about it....)
14:33:30 <Nereid> DrChaos: and in haskell, we have a `div` b = q, and a `mod` b = r.
14:33:31 * Eduard_Munteanu couldn't resist, didn't mean to offend :D
14:33:39 <Nereid> DrChaos: note that a is divisible by b if and only if r = 0.
14:34:03 <Nereid> (because then a = qb)
14:34:53 <Nereid> it's often said that r is the remainder upon dividing a by b.
14:35:00 * DrChaos wonders how you'd define the fibbonacci sequence in haskell
14:35:07 <DrChaos> it should be easy, right?
14:35:19 <croikle> try it yourself
14:35:33 <Nereid> > fix $ (0 :) . scanl (+) 1
14:35:35 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:35:35 <croikle> there are some very slick ways
14:35:44 <tac> Is something wrong with quickcheck + lambdabot?
14:35:45 <tac> @check \(x, k) -> 3 * k + x `mod` 3 == 0
14:35:47 <lambdabot>   Not in scope: `myquickcheck'
14:35:53 <Nereid> yes
14:36:40 <Nereid> it's broken.
14:36:43 * DrChaos is confused already
14:36:59 <DrChaos> fib 1 = 1; fib 2 = 2; fib n = <confusion starts here>
14:37:16 <Nereid> the sequence doesn't start with 1, 2
14:37:20 <Nereid> anyway
14:37:28 <mauke> fib n = fib (n - 1) + fib (n - 2)
14:37:36 <Nereid> ^ all it takes is to write the definition.
14:37:36 <mauke> but that's not a sequence, that's a (very inefficient) function
14:37:40 <Nereid> indeed.
14:37:51 <DrChaos> :(
14:37:58 <mauke> why so serious
14:38:02 <Nereid> > let fib 0 = 0. fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 100
14:38:02 <DrChaos> how am I ever going to learn how to write a sequence?
14:38:04 <lambdabot>   <hint>:1:22: parse error on input `='
14:38:08 <derdon> DrChaos: the wikipedia article of haskell has something for you
14:38:09 <Nereid> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 100
14:38:10 <mauke> DrChaos: what's a sequence?
14:38:13 <lambdabot>   mueval-core: Time limit exceeded
14:38:25 <Jafet> @src sequence
14:38:25 <lambdabot> sequence []     = return []
14:38:25 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:38:26 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
14:38:32 <mauke> Jafet: you're fired
14:38:33 <croikle> nereid: try like 40
14:38:39 <Nereid> croikle: no
14:38:47 <Nereid> croikle: the timeout was the point.
14:38:47 * Jafet glazes over
14:38:59 <Nereid> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! 100
14:39:00 <DrChaos> Jafet -> now bring me a donut!
14:39:00 <lambdabot>   354224848179261915075
14:39:15 <Nereid> this one should be easier to understand.
14:39:52 <derdon> DrChaos: problem #6 is much easier
14:39:57 <watermind> why is Store also called Costate?   I understand the latter is a Comonad, but calling it Costate makes it seem like we could obtain it from State by inverting the arrows
14:40:14 <edwardk> watermind: costate is a historical accident i've campaigned against
14:40:24 <Eduard_Munteanu> watermind: it's the same adjunction as the one in State
14:40:25 <DrChaos> derdon -> not to somebody who hasn't taken algebra 2 yet
14:40:36 <shachaf> edwardk: Campaigned against except for when you've used it?
14:40:38 <edwardk> Eduard_Munteanu: yes, but sadly, flipping an adjunction doesn't lead to a dual
14:40:38 <DrChaos> oh
14:40:43 <derdon> DrChaos: problem #6 is really easy, I promise
14:40:45 <edwardk> shachaf: i'm a hypocrit
14:40:46 <Nereid> watermind: every adjunction gives a monad and a comonad. State and Costate come from the same adjunction.
14:40:56 <mauke> > iterate(round.((0.5+sqrt 1.25)*).fromInteger)1
14:40:58 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
14:41:02 <edwardk> Nereid: yes, but sadly this relationship isn't one of duality.
14:41:09 <Eduard_Munteanu> Yeah, you get the comonad on the wrong category.
14:41:11 <shachaf> Hypocritical hit!
14:41:16 <DrChaos> you just have to equare every number in a list and sum that
14:41:19 <Nereid> I wonder.
14:41:21 <watermind> ok I understand now
14:41:26 <mauke> > iterate(round.((0.5+sqrt 1.25)*).toEnum)1
14:41:27 <DrChaos> that can be done using a list comprehension, I think
14:41:28 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
14:41:30 <mauke> nice
14:41:39 <Eduard_Munteanu> Actually, forget that.
14:41:44 <derdon> DrChaos: learn maths, please
14:41:49 <edwardk> anyways, costate, coreader, cowriter were all in common use before i found haskell and before i properly understood the distinction
14:42:06 <derdon> DrChaos: and the little gauss equation
14:42:31 <edwardk> i worked with roconnor to rename costate to store, and then renamed all the ones in category-extras when i fixed up their infelicities and moved them to comonad-transformers.
14:42:32 <watermind> edwardk: so neither of those are duals, just but obtained from the same adjunction?
14:42:38 <edwardk> watermind: correct
14:42:44 <Nereid> > map fst $ iterate (\(a,b) -> (b,a+b)) (0,1)
14:42:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
14:42:48 <watermind> edwardk: thanks! that was really confusing me
14:42:50 <edwardk> watermind: hence why costate is a terrible name
14:43:00 * DrChaos got stuck on trying to find a mixture of 15 and 35% solution to make 30cc of 25% solution
14:43:33 <Nereid> there are more efficient ways to randomly get the n'th fibonacci number, though.
14:43:39 <Nereid> that's O(log n)
14:43:40 * DrChaos is really rusty in math and is afraid he will fail
14:43:43 <derdon> Nereid: looks pretty :)
14:43:52 <shachaf> NNereid: What's the adjunction?
14:44:15 <Nereid> (,) t  -|  (->) t
14:44:23 <Nereid> or s instead of t.
14:44:43 <Nereid> it's the adjunction witnessed by curry and uncurry.
14:44:43 <derdon> DrChaos: there is a formula for calculating 1+2+3+…+n
14:44:43 <shachaf> Oh, that's the Indexed thing.
14:45:03 <shachaf> (s,a) -> b ~ a -> (s -> b)
14:45:25 <DrChaos> derdon -> I want to learn math using the excellent Life of Fred books, but being in a regular high school leaves less time for that
14:45:26 <derdon> DrChaos: saves some time and memory to use it in comparison to sum [1..n]
14:45:45 <derdon> I don't know what a regular high school is like :D
14:45:59 <Jafet> > let mm xs ys = [[sum $ zipWith (*) x y | y <- transpose ys] | x <- xs]; m = [[0,1],[1,1]]; f 0 = [[1,0],[0,1]]; f n | odd n = f (n-1) `mm` m | 1>0 = mm `join` f (n`div`2); fib n = head.head.f$n+1 in fib (10^6)
14:46:01 <lambdabot>   195328212870775773163201494759625633244354299659187339695340519457162525788...
14:46:02 <DrChaos> derdon -> were you homeschooled all your life?
14:46:23 <derdon> DrChaos: nope, but maybe from another country (Germany)
14:46:39 <DrChaos> derdon -> ah, I am currently in the public school system
14:46:43 <DrChaos> I need a math tutor
14:46:57 <DrChaos> like how you'd do the mixture equation
14:46:58 <mauke> ah, another Simon
14:47:09 <DrChaos> I got stuck on trying to find a mixture of 15 and 35% solution to make 30cc of 25% solution
14:47:17 <tac> What kind of math are you interested in DrChaos ?
14:47:19 <derdon> mauke: did you /whois me?
14:47:24 <mauke> derdon: yes
14:47:29 <derdon> :)
14:47:45 <DrChaos> x is the amount of 35% solution, 30 - x the amount of 15% solution, and then my head blows up
14:48:06 <DrChaos> I think I should drop out of high school so that I can have more time to practice just math
14:48:16 <DrChaos> not the best solution, either
14:48:21 <biscarch> is there a good way to manage ghc environments on OSX?
14:48:36 <mauke> ok, so you have 25% of 30cc being stuff
14:48:36 <monochrom> because it's a 35% solution  (duck)
14:48:59 <mauke> 0.25*30cc = stuff
14:49:04 <croikle> DrChaos: the key in those is to think about the amount of stuff. x of 35% is 0.35x stuff
14:49:43 <DrChaos> and 0.15(30 - x) is a part of the solution, I gather
14:50:05 <tac> If you're not part of the solution, you're part of the precipitate xD
14:50:23 <hpc> @remember tac If you're not part of the solution, you're part of the precipitate
14:50:24 <lambdabot> Done.
14:50:36 <hpc> that was so bad it was even worse than bad
14:50:39 <hpc> i love it
14:50:46 <mauke> hpc: that's an ancient joke
14:50:58 <tac> You can't credit me with that! I just stole it and said it
14:50:58 <Jafet> If you're not part of the solution, you're part of the final solution
14:51:05 <croikle> haha
14:51:13 <Rembane> Ouch :)
14:51:15 <Nereid> DrChaos: you should try ##math
14:51:29 * tac has only had bad experiences with ##math
14:51:30 <zxq9> "'is' over 'of' equals 'percent' over '100'"... and think hard from there (protip: sometimes one element is its own stack of the same equation)
14:51:41 <Nereid> tac: I don't ever go there anymore.
14:51:42 <mauke> zxq9: that confused me
14:51:48 * DrChaos will simply drop out of high school if he finds he is rusty in algebra 1 and needs to be reschooled in beginning algebra
14:51:49 <Nereid> I found it just made me depressed.
14:51:58 <DrChaos> or he will ask the school if they would help him
14:52:06 <DrChaos> I don't want to drop out, really
14:52:07 <tac> Nereid: For some reason, there are some very obnoxious trolls who are very good at math that hang out there.
14:52:14 <DrChaos> I want to learn all my math really well
14:52:20 <Rembane> DrChaos: Don't drop out of school, do math in your spare time instead.
14:52:35 <derdon> DrChaos: may I ask about your age?
14:52:39 <NougatRillettes> what are those 2 "#" chan you are linking ?
14:52:52 <DrChaos> derdon -> I'm 19
14:52:54 <mauke> NougatRillettes: some of them are ##math
14:53:17 <zxq9> mauke: 40/200 = 20/100 so "20 (is) over 100 (of) equals 20 (percent) over 100"
14:53:20 <derdon> DrChaos: oh, thought you were younger
14:53:25 <NougatRillettes> wy two '#' ?
14:53:26 <croikle> is #math a different channel, then?
14:53:29 <Nereid> NougatRillettes: freenode channel naming policy. channels not officially associated with a project get ##
14:53:32 <Nereid> #math doesn't exist
14:53:34 <DrChaos> I'm trying to ask my mom why I've been held back so much
14:53:38 <Nereid> and redirects to ##math
14:53:39 <zxq9> mauke: "40 over 200 equals 20 over 100" etc.
14:53:41 <croikle> ah, okay
14:53:42 <NougatRillettes> oh, ok
14:53:44 <Jafet> Oh, who needs math. Look at the Billboard 100. None of them ever needed math.
14:53:53 <derdon> haha
14:53:54 <croikle> I'd seen that before, with ##crawl, and wondered
14:53:58 <DrChaos> Jafet -> lol
14:54:07 <hpc> croikle: it's freenode policy on "official" channels
14:54:19 <Jafet> Look at Schoenberg. That guy used math and never got anywhere.
14:54:34 * DrChaos likes math but he needs to relearn major parts of it
14:54:36 <hpc> there's no single entity that can say "it's okay; i am math and this channel is mine"
14:54:38 <hpc> hence ##
14:55:07 <Jafet> hpc: write a program called math
14:55:19 <mauke> math. not even once.
14:55:25 <Rembane> Dr Dredd: "I AM THE MATH!!!"
14:55:34 <derdon> "Being math isn't normal. But on meth it is"
14:55:44 <mauke> You want the math? YOU CAN'T HANDLE THE MATH!
14:56:18 <tac> There's also a lot of different kinds of math
14:56:20 <tac> Lots
14:56:28 <DrChaos> well at first I was premature so I was held back a year, second I repeated 9th grade because they wouldn't accept my homeschool  credits, and I had to repeat 10th, 11th, and 12th grade because I was home schooled
14:56:31 <tac> There are more math than programming languages.
14:56:44 <derdon> tac: I like it if people think "math = arithmetic"
14:56:49 <DrChaos> we mixed grade levels so in 9th grade [homeschooled] I had 12th grade courses etc. etc.
14:56:51 <zxq9> DrChaos: Helpful site. Algebra is, by the way, a completed area of study and you can actually learn all of it. A lot of calculus is complete as well, but it gets really wacky from there (like unbelievably wacky). Anyway: http://www.purplemath.com/modules/index.htm is a good place.
14:57:14 <tac> "Complete" is a relative term, zxq9 :)
14:57:23 <tac> I'm sure some people would disagree strongly with those kinds of statements.
14:57:32 <snowylike> i wouldn't call algebra complete
14:57:35 <DrChaos> zxq9 -> what section of that site would help you solve a mixtures problem?
14:57:39 <Jafet> High school algebra is formally incomplete
14:57:46 <Jafet> @google tarski high school algebra
14:57:47 <lambdabot> http://en.wikipedia.org/wiki/Tarski's_high_school_algebra_problem
14:57:52 <Jafet> !!!
14:58:05 <DrChaos> I know how to do problems involving ratios
15:01:03 <alkabetz> Is there a currently an FFI wrapper to mlock(3)?
15:01:16 <Cale> Jafet: Well, that's a particular formalisation of "highschool algebra" which doesn't include negation :)
15:01:22 <alkabetz> Er, rather, to mlockall(2)?
15:01:39 <Cale> alkabetz: What does that do?
15:01:48 <nlogax> @seen chrisdone
15:01:48 <lambdabot> Unknown command, try @list
15:01:53 <tac> Cale: I'm assuming they take negation to be x + y when y is negative.
15:02:32 <alkabetz> Cale: It prevents the process's memory space from being swapped/paged to disk.
15:02:45 <Jafet> Cale: most people aren't told the versions of the axioms with negation in them, though
15:02:51 <Cale> tac: Negative numbers have nothing to do with it -- you can't prove anything which would require subtraction or negation involving the list of axioms on that page because none of them mention it.
15:02:54 <croikle> hm, yeah, they don't include additive inverses
15:03:03 <hpaste> nh2 pasted “cabal relink” at http://hpaste.org/80217
15:03:10 <nh2> monochrom: http://hpaste.org/80217
15:03:16 <Jafet> Is x + -x = 0 enough?
15:03:18 <nh2> 2 executables always relink, 2 don't
15:03:36 <Jafet> I guess you need the axiom for 0, too
15:04:01 <DrChaos> ah, I know my problem
15:04:22 <tac> ah, yeah, I guess they don't mention the existence of zero
15:04:29 <DrChaos> due to my lust for all things technological, my memory for math has gone by the wayside
15:04:30 <shapr> Why must my Raspberry Pi compile Haskell libraries so slowly? :-( I guess I'll have to try overclocking it.
15:04:59 <shapr> nlogax: He's around, you're just looking in the wrong place.
15:05:10 <DrChaos> shapr -> have fun with your frizzed out Pi
15:05:17 <croikle> shapr: you can work on cross-compilation while you wait
15:05:28 <tac> which is a good thing, too, because laws 11 and 4 combined cause issues
15:05:31 <hpc> croikle++
15:05:53 <shapr> Bah, I wanted to finish building iCalendar on my Pi before I had to drive off to the knitting party. But not today it seems!
15:06:14 <zxq9> DrChaos: It'll be tough to drop math in favor of tech, since tech is nearly all based on math (unless you're an Apple person -- then its based on the premise that hope + love = change)
15:06:27 <nlogax> shapr: Ah, thanks
15:06:31 <croikle> zxq9: that looks like math to me
15:06:43 <hpc> shapr: http://cdn.memegenerator.net/images/300x/5238133.jpg
15:07:07 <DrChaos> zxq9 -> but most of my programming has just used simple math, not even algebra 1 level
15:07:34 <Nereid> you should do more cool programming then.
15:07:46 <c_wraith> Which is fine, until you get to a problem that has a well-known solution, but you don't know it.
15:07:46 <Jafet> Don't worry, most working programmers do the same thing.
15:07:47 <zxq9> DrChaos: Once you get into more interesting problems you'll start realizing you need to study up more on your own. Happens to me every so often still -- especially set theory.
15:07:53 <Cale> alkabetz: Having a look around, I don't see one. I suppose you might just be able to foreign import it.
15:08:01 <shapr> hpc: Jag forstår inte?
15:08:19 <tac> There's a lot you can do with a computer knowing next to 0 math
15:08:21 <Jafet> mlock locks pages. Good luck finding pages in haskell
15:08:23 <alkabetz> Cale: Yeah.  I was mostly curious if anyone had tried it yet.
15:08:25 <DrChaos> err...is there a power function in Haskell?
15:08:26 <Cale> alkabetz: I have no idea whether there would be unintended consequences of using that.
15:08:30 <hpc> :t (**)
15:08:31 <lambdabot> Floating a => a -> a -> a
15:08:32 <Nereid> DrChaos: there are two
15:08:33 <hpc> :t (^)
15:08:34 <lambdabot> (Integral b, Num a) => a -> b -> a
15:08:35 <hpc> :t (^^)
15:08:36 <lambdabot> (Fractional a, Integral b) => a -> b -> a
15:08:36 <Cale> There are three
15:08:39 <Nereid> oh, three
15:08:40 <shachaf> > subsequences "hello" -- four
15:08:42 <lambdabot>   ["","h","e","he","l","hl","el","hel","l","hl","el","hel","ll","hll","ell","...
15:08:43 <croikle> :t **
15:08:44 <lambdabot> parse error on input `**'
15:08:52 <zxq9> DrChaos: what c_wraith said. But I'd add that painfully discovering a solution on your own vastly aids in appreciation and deep understanding of the accepted solution once you find/are referred to it later.
15:09:07 <Nereid> @src (^^)
15:09:07 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
15:09:07 <shachaf> Hmm, no, subsequences isn't right.
15:09:08 <alkabetz> Jafet: Yes, hence mlockall(2)
15:09:14 <Nereid> @src (^)
15:09:14 <lambdabot> x ^ 0            =  1
15:09:14 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
15:09:14 <lambdabot>   where f _ 0 y = y
15:09:14 <lambdabot>         f x n y = g x n
15:09:14 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
15:09:16 <lambdabot>                       | otherwise = f x (n-1) (x*y)
15:09:18 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
15:09:20 <lightquake> anybody in here have experience with netwire?
15:09:21 <shachaf> Never mind.
15:09:26 <shapr> Ok, let's see if this iCalendar library will parse the output of Google Calendar...
15:09:34 <DrChaos> zxq9 -> yes, I will try figuring out how to write the fib function
15:09:39 <Jafet> alkabetz: okay then.
15:10:05 <Jafet> Other than possibly not being useful, it should be straightforward to foreign import them.
15:10:09 <Cale> shapr: I might be interested to know what result you get there.
15:10:10 <Nereid> I like exponentiation by squaring in Z[\sqrt 5].
15:10:29 <Nereid> er
15:10:32 <Nereid> Z[\phi]
15:10:33 <lightquake> it seems like the 'best' approach for writing an opengl application in it is to use something with a MonadReader GuiState instance, and let the GuiState contain all the state of stuff like mouse button status, mouse position, key presses, etc
15:11:07 <shapr> Cale: ping me tomorrow
15:11:11 <Jafet> [[0,1],[1,1]], the generating matrix for phi
15:11:19 <lightquake> the other way would to use IO for the monad and make effectful wires for everything
15:11:48 <Nereid> yes, that is the matrix of phi in the Z-basis {1, phi} in Z[phi].
15:11:54 <Nereid> or something.
15:11:59 <Nereid> but who needs matrices.
15:12:06 <shachaf> i love matrices
15:12:09 <shachaf> they are so easy
15:12:14 <Nereid> me too, but sometimes they're more than you need.
15:12:33 <Jafet> UBLASPHEMER
15:12:35 <croikle> I need to give J some more time
15:12:51 <snowylike> who wants matrices when you have linear maps between vector spaces?
15:12:56 <shachaf> Actually I don't know the first thing about linear algebra. :-(
15:12:56 <snowylike> don't need concrete stuff
15:13:35 <Nereid> shachaf: linear algbera is pretty cool.
15:13:49 <Nereid> and important.
15:14:06 <Nereid> because it is very widely applicable.
15:15:17 <DrChaos> err...I want to find the square of the sum of a list of numbers
15:15:30 <DrChaos> OH
15:15:41 <Nereid> > sum . map (^3) $ [1..10] -- square of sum of numbers from 1 to 10
15:15:43 <lambdabot>   3025
15:15:52 <Jafet> Actually, you mainly see matrices everywhere because people keep writing their totally unrelated problems as arrays
15:15:53 <Nereid> er
15:15:58 <Nereid> yeah
15:16:24 <snowylike> i'd say it's more because we tend to linearize problems that are considered hard
15:16:31 <Nereid> yes
15:16:31 <DrChaos> main = putStrLn [ (x,y) | x <- (sum [1..10]) ^ 2 .. ]
15:16:57 <DrChaos> Nereid -> is my solution good?
15:17:03 <Rembane> DrChaos: Why the tuple?
15:17:05 <croikle> what's y?
15:17:08 <Nereid> DrChaos: I don't even know what your solution is doing.
15:17:13 <Nereid> anyway, yeah.
15:17:19 <Jafet> It's 35% good.
15:17:21 <Nereid> differential calculus is all about linearization, really.
15:17:22 <croikle> and (sum [1..10])^2 isn't a list
15:17:37 <Nereid> DrChaos: you should first get your solution to compile before you ask if it's good.
15:17:51 <DrChaos> Nereid -> x will be the square of the sum of the first 10 natural numbers
15:18:00 <Nereid> it sure won't.
15:18:06 <Jafet> snowylike: graph problems aren't linear
15:18:18 <DrChaos> dang, I really need to understand how the map function works then
15:18:20 <lightquake> DrChaos: are you familiar with python?
15:18:20 <Jafet> Well, unless you know spectral analysis or something
15:18:23 <Nereid> Jafet: they kind of are, if you look at them in the right way.
15:18:23 <DrChaos> or how to use it
15:18:26 <DrChaos> lightquake -> no
15:18:47 <Jafet> I've been squinting at them
15:19:06 <snowylike> If my sketchy memory doesn't betray me
15:19:07 <|||tux||> > sum [1..10] ^ 2
15:19:08 <lambdabot>   3025
15:19:09 <DrChaos> Nereid -> why are you using map (^3) [...] ?
15:19:12 <Nereid> Jafet: the incidence matrix of a graph is the matrix of the one nontrivial differential in its corresponding chain complex.
15:19:14 <Nereid> DrChaos: magic.
15:19:22 <snowylike> damn you Nereid
15:19:28 <Nereid> lol
15:19:31 <snowylike> why did you pick the one thing that i wanted to say?
15:19:35 <Nereid> :(
15:19:53 <DrChaos> Nereid -> magic? wow, I'm impressed
15:19:55 <Jafet> Is there any other linear relation in a graph matrix then
15:20:01 <|||tux||> Nereid: How does your solution work? :O
15:20:05 <Nereid> |||tux||: magic :D
15:20:13 <Jafet> > sum . map (^3) $ [-10..-5]
15:20:14 <lambdabot>   Not in scope: `..-'
15:20:18 <Jafet> > sum . map (^3) $ [-10 .. -5]
15:20:18 <shachaf> DrChaos: You shouldn't address people with ->. It's not polite.
15:20:20 <lambdabot>   -2925
15:20:42 <Nereid> > sum [1..1000] ^ 2 ==  sum (map (^3) [1..1000]
15:20:43 <lambdabot>   <hint>:1:46: parse error (possibly incorrect indentation)
15:20:44 <Nereid> > sum [1..1000] ^ 2 ==  sum (map (^3) [1..1000])
15:20:45 <lambdabot>   True
15:21:09 <Rembane> That's fun.
15:21:13 <snowylike> Jafet: i'm no expert on graphs, but i think many interesting things are nowadays thought about using (generalized) eigenvalues
15:21:17 <snowylike> though you kind of said that
15:21:24 <DrChaos> shachaf :: do you like my new nick completer?
15:21:25 <|||tux||> > (10*11/2) ^ 2
15:21:26 <Nereid> I dunno anything about graphs.
15:21:27 <lambdabot>   3025.0
15:21:54 <Nereid> DrChaos ☃ I like mine better.
15:21:54 <|||tux||> Why using sum [1..10] :p
15:22:18 <Nereid> time to go.
15:22:21 <DrChaos> Nereid :: what is that supposed to be? a jug of milk?
15:22:25 <Nereid> it's a snowman.
15:22:29 <DrChaos> oh
15:22:33 <Jafet> > ((x+1) * (x+2)/2)^3 - (x * (x+1)/2)^3
15:22:34 <lambdabot>   (x + 1) * (x + 2) / 2 * ((x + 1) * (x + 2) / 2) * ((x + 1) * (x + 2) / 2) -...
15:22:41 <Jafet> Useless
15:22:43 <DrChaos> I want some warm milk; I think I'll go get some
15:22:50 <Jafet> > deriv (x * (x+1)/2)^3
15:22:51 <lambdabot>   Not in scope: `deriv'
15:28:37 <plcplc> > undefined
15:28:39 <lambdabot>   *Exception: Prelude.undefined
15:29:30 <croikle> @src undefined
15:29:30 <lambdabot> undefined =  error "Prelude.undefined"
15:29:37 <derdon> Jafet: why don't you use wolframalpha?
15:32:04 <|||tux||> (x * (x+1)/2)^3 doesn't seem like the right equation for sum . map (^3) $ [1..x] to me
15:33:38 <DrChaos> huh...I don't think I know enough haskell to write this function getSumOfSquares (x:xs) for project euler problem 6
15:33:54 <DrChaos> it's frusturating
15:34:17 <tac> Do you know how to take a square?
15:34:17 <snowylike> what exactly is your problem?
15:34:30 <|||tux||> > let xs = [1,5,7,9] in (==) <$> sum . map (^3) <*> (^2) . sum $ xs
15:34:32 <lambdabot>   False
15:34:44 <DrChaos> wait, let me redo the function without a helper function
15:34:53 <DrChaos> I remember being down this road before
15:35:02 <|||tux||> DrChaos: sum [1..10] ^ 2 ?
15:35:03 <Nereid> 99% of the time you don't need a helper function.
15:35:28 <Nereid> and half the time you need a helper function you can do it with foldl instead
15:35:50 <hpc> you mean foldr?
15:36:14 <DrChaos> getSumSquares (x:[]) = [x^2]
15:36:16 <DrChaos> getSumSquares (x:xs) = x^2 : getSumSquares xs
15:36:17 <croikle> DrChaos: can you write getSquares?
15:36:51 <|||tux||> > map (^2) [1,2,3,4]
15:36:53 <lambdabot>   [1,4,9,16]
15:36:56 <DrChaos> that should take each item of the list and square it, I think I've implemented something sort of like the map function
15:37:16 <|||tux||> You have implemented the map function :p
15:37:35 <Nereid> what about getSumSquares []
15:37:44 <DrChaos> let's see if I can get the correct answer using my function
15:38:07 <DrChaos> Nereid :: I just defined that to equal [0]
15:38:16 <Nereid> :(
15:39:07 <derdon> DrChaos: why don't you use the idea of |||tux||?
15:39:41 <DrChaos> derdon :: I'll try both
15:40:07 <croikle> if you do implement a recursive function, usually all you need are cases for (x:xs) and []
15:40:08 <DrChaos> there, I wrote a note
15:40:17 <croikle> [x] is often irrelevant
15:41:34 <pnielsen> croikle: because [x] is x:[]
15:42:03 <derdon> which is x:[]:[]
15:42:15 <c_wraith> No, it's not
15:42:20 <pnielsen> (x:xs) -> (x:[])
15:42:31 <DrChaos> well huh, it seems my getSumSquares function has a little bug
15:42:42 <pnielsen> derdon: huh, no :p
15:43:06 <newsham> > extpoly [1,4,9]
15:43:07 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
15:43:10 <pnielsen> derdon: that implies it's a list of lists, that x is a list too, and the last item is an empty list
15:43:14 <c_wraith> :t ?x:[]
15:43:15 <lambdabot> (?x::a) => [a]
15:43:20 <c_wraith> :t ?x:[]:[]
15:43:21 <lambdabot> (?x::[a]) => [[a]]
15:43:25 <derdon> pnielsen: oh, you're right
15:45:24 <DrChaos> wait, I want a single number, not a list
15:45:31 <Nereid> indeed
15:45:46 <derdon> > sum [3,5,8]
15:45:48 <lambdabot>   16
15:45:50 <croikle> can you decompose this in to nice separate chunks?
15:45:51 <derdon> tadaa
15:46:04 <croikle> sumsquares = sum . squares
15:48:11 <DrChaos> ok err...I want getSumSquares to output a list, but I have been unsuccessful in this endevour
15:48:21 <croikle> why do you want a list?
15:48:25 <derdon> DrChaos: what is your code so far?
15:48:29 <croikle> can you give example output?
15:48:37 <croikle> getSumSquare [1,2] = ?
15:49:06 <Nereid> "get" sounds redundant.
15:49:27 <hpaste> DrChaos pasted “Euler problem6.hs” at http://hpaste.org/80218
15:49:57 <Nereid> first look at the type.
15:50:04 <derdon> Nereid: but my university prof told me that getters are good!
15:50:17 <hpaste> DrChaos annotated “Euler problem6.hs” with “Errors (annotation)” at http://hpaste.org/80218#a80219
15:50:48 <Nereid> DrChaos: according to the type, I could give it a list of Chars, and get back out a list of Chars.
15:51:07 <DrChaos> Oh, I see
15:52:19 <hpaste> DrChaos annotated “Euler problem6.hs” with “Updated type signature” at http://hpaste.org/80218#a80220
15:52:34 <Nereid> you still want to return a list?
15:52:53 <derdon> DrChaos: remove line 4, it is not necessary
15:53:06 <Nereid> that too
15:53:25 <DrChaos> Nereid :: yes I still want to return a list
15:53:27 <Nereid> but let's get it to typecheck first
15:53:35 <Nereid> DrChaos: then how come getSumSquares [] = 0?
15:54:00 <croikle> Nereid: just define Num [Int] :)
15:54:03 <DrChaos> Oh, I see. If you pass it an empty list it returns the numeral 0
15:54:18 <DrChaos> it's compiled now
15:54:59 <hpaste> DrChaos pasted “Euler problem6.hs Final” at http://hpaste.org/80221
15:55:49 <Nereid> ok.
15:55:54 <Nereid> a couple comments.
15:55:56 <DrChaos> "Congratulations, the answer you gave to problem 6 is correct"
15:56:23 <Nereid> getSumSquares is an odd name, since you're not summing anything.
15:56:33 <Nereid> I'd probably just call it "squares".
15:56:38 <derdon> DrChaos: ok, now I can show you my solution: https://github.com/derdon/hodgepodge/blob/master/lang/challenges/euler-solutions/6/6.hs
15:56:41 <shachaf> Nereid: It's just a misspelling of "getSomeSquares"
15:56:45 <Nereid> haha
15:57:03 <Nereid> next, there's no reason to return [0] in the base case, you may as well just use an empty lits.
15:57:04 <Nereid> list.
15:57:35 <Nereid> derdon: I'd use div instead of (/). :p
15:58:03 <derdon> Nereid: ok
15:58:25 <Nereid> > sum . map (liftA2 (-) (^3) (^2)) $ [1..100]
15:58:27 <lambdabot>   25164150
15:58:35 <Nereid> silly.
15:58:44 <mauke> > 4 / 6
15:58:45 <lambdabot>   0.6666666666666666
15:58:49 <mauke> > 4 `div` 6
15:58:50 <lambdabot>   0
15:58:52 <mauke> > 4 / 6 :: Rational
15:58:54 <lambdabot>   2 % 3
15:59:19 <derdon> ah, ``2 % 3`` must be read as "two third"
16:01:10 <plhk>  > foldl (flip $ (+) . (^2)) 0 [1,2,3,4]
16:01:20 <plhk> > foldl (flip $ (+) . (^2)) 0 [1,2,3,4]
16:01:22 <lambdabot>   30
16:02:52 <Nereid> mm fusion.
16:03:20 <derdon> so ``flip (f . g)`` is not the same as ``g . f``?
16:03:39 <mauke> derdon: no, that would be flip (.) f g
16:03:48 <derdon> ah
16:03:54 <mauke> @unpl flip (f . g)
16:03:54 <lambdabot> (\ b c -> f (g c) b)
16:05:27 <deus_rex> > foldr ((+) . (^2)) 0 [1,2,3,4]
16:05:29 <lambdabot>   30
16:05:32 <deus_rex> ^^ attn plhk
16:06:37 <nathanfh> > sum $ map (^2) [1,2,3,4]
16:06:39 <lambdabot>   30
16:07:03 <derdon> what is generally better: map or fold?
16:07:09 <mauke> huh?
16:07:12 <mauke> map is a fold
16:07:25 <derdon> mauke: map is a fold? how?
16:07:30 <Eduard_Munteanu> Hrm...
16:07:38 <croikle> fold is more general, but if what you're doing can be expressed map it may be more readable
16:07:39 <mauke> map f = foldr ((:) . f)
16:07:45 <derdon> mauke: fold saves the results, while map works on each item seperately
16:07:58 <Lethalman> ... []
16:08:00 <Nereid> :t \f -> foldr ((:) . f)
16:08:01 <lambdabot> (a -> a1) -> [a1] -> [a] -> [a1]
16:08:04 <Nereid> er
16:08:05 <Nereid> :t \f -> foldr ((:) . f) []
16:08:07 <lambdabot> (a -> a1) -> [a] -> [a1]
16:08:10 <Eduard_Munteanu> Is there an inverted Maybe monad? One that shortcircuits out at the first Just, but keeps going on Nothing?
16:08:11 <mauke> oh, right
16:08:21 <croikle> @pl \f -> foldr ((:) . f)
16:08:21 <lambdabot> foldr . ((:) .)
16:08:23 <elliott> Eduard_Munteanu: I think there is somewhere
16:08:30 <Eduard_Munteanu> I find myself using Either Something () for that.
16:08:35 <otters> you could define one
16:08:37 <mauke> @pl map f = foldr ((:) . f) []
16:08:38 <lambdabot> map = flip foldr [] . ((:) .)
16:08:47 <derdon> croikle: what about performance? is a map faster than an equivalent fold because it is more specific?
16:08:53 <shachaf> Eduard_Munteanu: That's not really a monad.
16:08:55 <elliott> Eduard_Munteanu: you can do it by lifting to Either
16:09:26 <elliott> shachaf: well, it's as much a monad as the flipped Either, just you have a constraint on the result type to () to run it back into Maybe
16:09:26 <mauke> derdon: no, it's just more readable
16:09:28 <croikle> you can turn a map into a parMap, but aside from that? probably not
16:09:38 <shachaf> elliott: So it's... Either?
16:09:45 <Nereid> derdon: thinking of map as a fold is useful because then you can talk about fusion.
16:09:52 <Nereid> foldr f z . map g = foldr (f . g) z
16:09:53 <Eduard_Munteanu> TypelevelFlip Either :P
16:09:57 <elliott> shachaf: I guess I'm not making much sense.
16:09:59 <shachaf> I mean, you have to make it as flexible as Either on the second argument for it to be a monad.
16:10:20 <Nereid> well it's useful for more than that I guess
16:10:32 <shachaf> Eduard_Munteanu: No, it's not flipped Either.
16:10:40 <shachaf> It has to be plain Either for the monad instance to work.
16:10:41 <deus_rex> :t flip Either
16:10:43 <lambdabot>     Not in scope: data constructor `Either'
16:10:43 <lambdabot>     Perhaps you meant `Other' (imported from Math.OEIS)
16:10:51 <deus_rex> :t flip $ Either Int String
16:10:52 <lambdabot>     Not in scope: data constructor `Either'
16:10:52 <lambdabot>     Perhaps you meant `Other' (imported from Math.OEIS)
16:10:52 <lambdabot>     Not in scope: data constructor `Int'
16:11:05 <Eduard_Munteanu> You can't really flip type functions.
16:11:07 <deus_rex> err
16:11:08 <deus_rex> lol
16:11:15 <Nereid> lol
16:11:20 <Lethalman> :t flip Left
16:11:22 <lambdabot>     Couldn't match expected type `b0 -> c0'
16:11:22 <lambdabot>                 with actual type `Either a0 b1'
16:11:22 <lambdabot>     Expected type: a0 -> b0 -> c0
16:12:07 <Eduard_Munteanu> I'll probably just go with Either.
16:12:14 <fmap> @ty flip _left
16:12:15 <lambdabot> Applicative f => Either a c -> (a -> f b) -> f (Either b c)
16:12:36 <Eduard_Munteanu> Basically I'm trying some parsers in order, and want to quit as soon as I find a match.
16:12:53 <Nereid> why not use <|>
16:12:59 <Lethalman> :t _left
16:13:00 <lambdabot> (Applicative f, Prismatic k) => k (a -> f b) (Either a c -> f (Either b c))
16:13:03 <dolio> How does 'foldr f z . map g = foldr (f . g) z' require thinking of map as a fold?
16:13:38 <Nereid> maybe it doesn't. but it's a special case of more general fusion I guess.
16:13:49 <Nereid> (also, let f = (:) and z = [] in that equation
16:13:57 <Eduard_Munteanu> Nereid: hm, actually, I think I could use that
16:14:06 <Nereid> Eduard_Munteanu: that's what it's for.
16:14:17 <dolio> In GHC, it fuses because map is a build, not a fold.
16:14:31 <Nereid> eh
16:14:43 <Eduard_Munteanu> Yeah, I'll just do that, I thought I might need more complicated things.
16:15:01 <Nereid> ok
16:20:25 <Guest56479> There's a lotta people in here and not a lotta talking.... I'm almost afraid to say anything.
16:20:32 <Nereid> just say something
16:20:43 <Nereid> we won't bite :)
16:20:59 <shachaf> Nereid: Clearly Guest56479 isn't *actually* afraid to say anything.
16:21:12 <Nereid> well he did say almost ;)
16:21:31 <Philippa_> six quiet minutes isn't a lot
16:22:24 <Guest56479> hah. Well I'd come to ask about ghc crashing on startup, but apparently the third time really is the charm, and it's working now.
16:28:52 <cmccann> edwardk, did you see my latest adventures in type hackery on SO?
16:28:57 <edwardk> no
16:29:02 <cmccann> sadly I still can't get it to work completely and I'm not sure it's possible :[
16:29:07 <edwardk> i haven't been on SO in a couple of months really
16:29:08 <cmccann> http://stackoverflow.com/q/14133121/157360
16:29:14 <DrChaos> ok guys, how would you define the fibonacci sequence in haskell?
16:29:17 <DrChaos> wait
16:29:32 <shachaf> pigworker posted a comment on SO saying that infinite traversals don't exist.
16:29:48 <`nand`> > let fibs = 0 : scanl (+) 1 fibs in fibs
16:29:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:29:59 <shachaf> http://stackoverflow.com/questions/14110671/do-traversables-really-require-to-be-traversed-left-to-right
16:30:07 <hiptobecubic> > (+) <$> (1, 2) <*> (3, 4) :: (Int, Int)
16:30:08 <edwardk> cmccann: ah
16:30:08 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
16:30:09 <lambdabot>    arising from a use of...
16:30:10 <hiptobecubic> Why does (<*>) need a Monoid here?
16:30:25 <hiptobecubic> oh
16:30:27 <shachaf> hiptobecubic: It's the same reason it needs it in Writer.
16:30:29 <hiptobecubic> for the first element
16:30:50 <DrChaos> fib 1 = 1; fib 2 = 2; fib n = if n < 0 then fib (n-1) + fib (n-2) else error "fib undefined for negative numbers"
16:31:16 <cmccann> edwardk, things that have failed so far: a minimal attempt at delayed unification on a Constraint, and a Constraint version of "fix"
16:31:22 <edwardk> shachaf: *shrug* there are many things you can do with an infinite traversal. thats just not one of them =P
16:31:32 <nathanfh> Someone posted a neat fibonacci I hadn't thought of before earlier
16:31:41 <edwardk> cmccann: can you just require a member that provides the dictionary witness?
16:31:47 <shachaf> @quote _pizza_
16:31:47 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
16:32:02 <Peaker> > traverse (pure . (+1)) [1..]
16:32:03 <lambdabot>   No instance for (GHC.Show.Show (f0 [b0]))
16:32:03 <lambdabot>    arising from a use of `M256356...
16:32:13 <Peaker> > runIdentity . traverse (pure . (+1)) [1..]
16:32:15 <lambdabot>   Couldn't match expected type `Data.Functor.Identity.Identity'
16:32:15 <lambdabot>              ...
16:32:19 <nathanfh> > take 5 $ fix $ (0:) . scanl (+) 1
16:32:21 <lambdabot>   [0,1,1,2,3]
16:32:25 <Nereid> :t traverse (pure . (+1)) [1..]
16:32:27 <lambdabot> (Enum b, Num b, Applicative f) => f [b]
16:32:36 <cmccann> edwardk, probably, I was just hoping to express it more directly
16:32:39 <edwardk> class Differentiable (f :: * -> *) where type D f :: * -> *; witness :: (Differentiable (D f) => r) ->r
16:32:40 <DrChaos> OK guys, my fib function is buggy
16:32:41 <shachaf> > traverse (Just . (+1)) [1..]
16:32:43 <lambdabot>   *Exception: stack overflow
16:32:49 <Nereid> > traverse (pure . (+1)) [1..] :: [Int]
16:32:50 <nathanfh> or alternatively
16:32:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
16:32:51 <lambdabot>              with actual type ...
16:32:57 <Nereid> > traverse (pure . (+1)) [1..] :: [[Int]]
16:32:59 <lambdabot>   *Exception: stack overflow
16:33:00 <nathanfh> > take 5 $ fix $ (1:) . scanl (+) 1
16:33:02 <Nereid> well.
16:33:02 <lambdabot>   [1,1,2,3,5]
16:33:10 <DrChaos> > let fib 1 = 1; fib 2 = 2; fib n = if n < 0 then fib (n-1) + fib (n-2) else error "fib undefined for negative numbers" in fib 5
16:33:10 <edwardk> cmccann: or even witness :: Dict (Differentiable (D f))
16:33:11 <lambdabot>   *Exception: fib undefined for negative numbers
16:33:18 <Peaker> shachaf, with Maybe it really needs to do an infinite find of no Nothings
16:33:19 <edwardk> then you can open that when you need it
16:33:30 <shachaf> Peaker: Yep.
16:33:41 <DrChaos> WTF? would somebody please tell me what is wrong with my fib function?
16:33:43 <shachaf> Peaker: If only colists were costrong! Or something.
16:33:46 <cmccann> edwardk, that'd probably be the sane approach, yeah
16:33:47 <edwardk> then forcing witness is what prompts the next step of evaluation
16:33:48 <DrChaos> oh
16:34:11 <Peaker> > runIdentity $ traverse (pure . (+1)) [1..]
16:34:13 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
16:34:14 <`nand`> if [] is a legal traversable instance then Stream must be a legal traversable instance because a Stream is just a special case of a []
16:34:17 <DrChaos> nvm
16:34:22 <Peaker> ok, that was a silly thing above
16:34:28 <Peaker> shachaf, ^^ infinite traversal
16:34:29 <DrChaos> I don't know what is wrong with it, let me hand trace it
16:34:45 <aristid> DrChaos: if n < 0 -- flipped
16:34:52 <hiptobecubic> What was the lambdabot command to show precedence with parens?
16:35:00 <shachaf> Peaker: Whatever, man. It doesn't obey the laws.
16:35:00 <`nand`> DrChaos: perhaps you forgot to define fib 0
16:35:13 <Peaker> shachaf, oh, maybe :)
16:35:23 <shachaf> Peaker: Or maybe it does.
16:35:27 <shachaf> Peaker: edwardk makes a good argument.
16:35:37 <shachaf> DrChaos: Your condition is backwards.
16:35:46 <DrChaos> OH
16:35:51 <`nand`> ah, that too
16:36:14 <`nand`> (well, starting with 0 or 1 is arbitrary either way)
16:36:40 <Peaker> shachaf, @tell me what it is if you can, please :)  , I gotta sleep
16:36:40 <Nereid> fib 0 = 0, fib 1 = 1.
16:36:50 <Nereid> it should start this way.
16:37:18 <Nereid> the people who don't want 0 to be the first fibonacci number probably don't like 0-based indexing either.
16:37:20 <shachaf> Peaker: Something about only a finite number of reassociations rather than "true associativity" (which is a concept that doesn't even make sense for infinite lists?). I don't know.
16:37:36 <Nereid> I don't even know what it means to have an infinite number of reassocations.
16:37:39 <shachaf> Nereid: I like 0-based indexing and I like 1 to be the first Fibonacci number.
16:37:43 <Nereid> shachaf: :(
16:37:49 <shachaf> Nereid: "sorry"
16:37:59 <nathanfh> Me, too.
16:38:02 <Nereid> shachaf: but various identites work nicer this way.
16:38:10 <Nereid> more nicely
16:38:25 <Nereid> or something.
16:38:44 <edwardk> Peaker: basically an associativity law in a _constructive_ setting is a pretty fragile thing, because induction on it only allows you to reassociate a finite number of times
16:38:44 <shachaf> Nereid: But nostalgia won't let me have it any other way than [1,1,2,3,5..]
16:38:54 <Nereid> :(
16:39:05 <Nereid> edwardk: what does constructive have to do with it?
16:39:08 <DrChaos> > let fib 0 = 0; fib 1 = 1; fib n = if n > 0 then fib (n-1) + fib (n-2) else error "fib undefined for negative numbers" in fib 2
16:39:10 <lambdabot>   1
16:39:18 <DrChaos> that's not right, it should return 2
16:39:31 <edwardk> Peaker: so with an infinite traversal you can work with it just fine so long as you don't try to do an infinite amount of work moving things around
16:39:31 <Nereid> it's right, if you start with 0, 1
16:39:56 <DrChaos> Nereid :: I did
16:40:06 <DrChaos> are you sure fib 2 is supposed to equal 1?
16:40:07 <`nand`> then it's right
16:40:13 <Nereid> DrChaos: 0 + 1 = 1, no?
16:40:19 <mreh> http://hpaste.org/80227 - is this safe?
16:40:21 <DrChaos> yes
16:40:25 <Nereid> 0, 1, 1, 2, 3, 5, ..
16:40:35 <DrChaos> is that the actual sequence?
16:40:37 <Nereid> yes
16:40:38 <elliott> mreh: yes except in certain GHC versions
16:40:44 <Nereid> :(
16:40:44 <elliott> oh
16:40:45 <mreh> that en in traceDebug can't float outside the top level definition?
16:40:47 <elliott> traceDebug isn't safe
16:40:48 <elliott> since it's impure
16:41:08 <elliott> mreh: I suggest using traceIO
16:41:09 <elliott> @hoogle traceIO
16:41:10 <lambdabot> No results found
16:41:10 <`nand`> https://oeis.org/A000045
16:41:17 <`nand`> DrChaos ^
16:41:35 <elliott> mreh: unsafePerformIO $ do { en <- readIORef debug; when en $ traceIO msg; return a }
16:41:40 <Nereid> OEIS knows what's right.
16:41:50 <`nand`> https://en.wikipedia.org/wiki/Fibonacci_number
16:41:52 * hackagebot HLearn-algebra 0.1.0 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-0.1.0 (MikeIzbicki)
16:42:01 <edwardk> Nereid: well, i suppose its more a function of halting than constructiveness, i tend to lump the two together, since most constructive settings lack something like the axiom of choice.
16:42:45 <mreh> elliott what's unsafe about my definition?
16:42:55 <Nereid> but even in math where AC is all over, lots of things are only valid if you're only allowed to do a finite number of things.
16:42:58 <elliott> mreh: it has side effects
16:43:00 <edwardk> but when i'm working in a real computational setting, i can't perform an infinite sequence of steps
16:43:12 <mreh> so does trace, but that's a pure function
16:43:19 <elliott> trace is not pure
16:43:23 <elliott> The trace function should only be used for debugging, or for monitoring execution. The function is not referentially transparent: its type indicates that it is a pure function but it has the side effect of outputting the trace message.
16:43:27 <elliott> even the docs admit as much
16:43:39 <mreh> that's like mine :)
16:43:46 <elliott> yes
16:43:47 <elliott> and it's impure
16:43:47 <mreh> although mine reads from a global IO ref
16:43:57 <`nand`> the global IO ref thing is safe; the tracing not so much
16:44:19 <`nand`> (well, except for unsafePerformIO $ readIORef debug; that isn't safe)
16:44:33 <mreh> what do you mean by safe here?
16:44:38 <edwardk> Nereid: the argument is more by analogy to the Escardo-style topology/infinite search in finite time/etc where you can do seemingly impossible things as long as you restrict what you do to a finite number of steps.
16:45:05 <`nand`> mreh: type safe, pure, referentially transparent
16:45:06 <Nereid> that's still searching a compact space.
16:45:10 <`nand`> ‘consistent’, I guess
16:45:12 <mreh> right okay
16:45:13 <Nereid> I dunno.
16:45:23 <mreh> the intention was that setDebug is called only once
16:45:32 <mreh> when the program reads arguments
16:45:32 <Nereid> I don't know what my point is.
16:45:36 <edwardk> 'traversals are finitary' is more than sufficient to permit you to use the ability to re-associate all you want, but in practice we use a lot of crap on infinite lists and that isn't going away, so the theory needs to evolve to suit it
16:45:46 <DrChaos> ok, how do I get the list of all even fibonacci numbers?
16:45:52 <`nand`> filter even fibs
16:45:53 <mreh> so if setDebug only gets called once, is what I'm doing safe? that's the question I meant to ask
16:45:53 <edwardk> Nereid: i think we are in violent agreement honestly.
16:45:56 <DrChaos> I really don't know the syntax for that
16:45:58 <DrChaos> oh
16:46:52 <DrChaos> main = putStrLn (show $ filter even (map fib [1..4000000]))
16:46:55 <DrChaos> like that?
16:47:13 <`nand`> putStrLn . show = print
16:47:26 <`nand`> otherwise, that should work
16:47:27 <edwardk> i can do lots of meaningful operations on infinite traversals, ones where there are infinities in literally all directions (e.g. searching a tree decorated with the rationals)
16:47:58 <DrChaos> `nand` :: you use print like this? main = print $ filter even (map fib [1..4000000])
16:48:04 <edwardk> the search only explores a finite portion of the space, so compactness is retained
16:48:13 <`nand`> yes, that should work
16:48:55 <DrChaos> is this a VERY slow fib function?
16:48:58 <`nand`> yes
16:49:12 <DrChaos> :( this is going to take forever to run
16:49:17 <`nand`> probably
16:49:47 <DrChaos> do I need to study a lot of math to do it much faster?
16:49:56 <DrChaos> I'd love to optimize it
16:50:06 <`nand`> there are simple optimizations you can make without requiring much knowledge
16:50:31 <`nand`> for one, if you need a list of fibs, you're probably wasting work if you calculate each number individually, rather than calculating a sequence of them
16:50:45 <`nand`> for two, the definition you gave is exponential since you're constantly recomputing numbers you already computed
16:50:56 <DrChaos> `nand` :: I see
16:51:05 <`nand`> eg. fib 3 = fib 2 + fib 1 = (fib 0 + fib 1) + fib 1; so you're computing ‘fib 1’ twice
16:51:12 <edwardk> you can walk over lots of infinite structures with many monads, but some you can't. e.g. maybe is effectively giving you a decision procedure for stream equality its Pi_2^0 complete. you need an oracle for the halting problem, but many applicatives aren't strict in both args to (<*>) and so work perfectly well
16:51:14 <`nand`> for fib 4; you're computing ‘fib 1’ not twice, but four times
16:51:16 <`nand`> etc.
16:51:19 <`nand`> it goes up exponentially
16:51:23 <lolcathost> DrChaos: You can compute Fibonacci numbers using the fast exponentiation algorithm.
16:51:32 <edwardk> you can explore their result productively
16:51:43 <edwardk> the problem isn't that [1..] is infinite, its that Maybe isn't productive
16:52:16 <DrChaos> lolcathost :: let me google it
16:53:11 <DrChaos> lolcathost :: http://nayuki.eigenstate.org/page/fast-fibonacci-algorithms
16:53:13 <nathanfh> Curious: is there an extension or compiler flag that allows custom defaulting of ambiguous type constraints?
16:53:18 <DrChaos> is that the Fast algorithm defined there?
16:53:24 <edwardk> Nereid: not sure if that was completely coherent
16:53:34 <lolcathost> DrChaos: Let F_n be the 2x2 matrix whose main diagonal elements are fib (n+1) and fib (n-1), and whose other two elements are both equal to fib n. Then F_n = F_1 ^ n.
16:54:00 <nathanfh> So you could, for example, tell ghc to default ambiguous instances of IsString to Text, or what not?
16:54:17 <DrChaos> lolcathost :: sorry, your in way over my head
16:54:22 <lolcathost> @src (^)
16:54:22 <lambdabot> x ^ 0            =  1
16:54:22 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
16:54:22 <lambdabot>   where f _ 0 y = y
16:54:22 <lambdabot>         f x n y = g x n
16:54:22 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
16:54:24 <lambdabot>                       | otherwise = f x (n-1) (x*y)
16:54:26 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
16:58:27 <DrChaos> lolcathost :: I don't know how you'd program that
16:58:42 <DrChaos> I'd love to get it done, but I don't quite understand it yet
16:58:47 <DrChaos> OH
16:58:48 <Nereid> edwardk: I'm not sure I quite get what your point is.
16:59:00 <Nereid> but whatever
16:59:17 <DrChaos> diagonal as in | fib n | fib n |
16:59:19 <jozefg> Why does x `seq` x do nothing but x `deepseq` x  does force the evaluation of x?
16:59:35 * edwardk gives up
16:59:37 <DrChaos>         |fib (n-1) | fib (n+1)|
16:59:45 <lolcathost> DrChaos: Nope.
16:59:50 <DrChaos> darn
17:00:32 <monochrom> sometimes, x `deepseq` x does not force the evaluation of x either. const True (x `deepseq` x)
17:00:49 <lolcathost> DrChaos: [ [ fib (n+1) , fib n ] , [ fib n , fib (n-1) ] ]
17:00:58 <edwardk> Nereid: my only point was that saying infinite traversals don't exist ignores the fact that we productively (in both senses of the word) employ them every day, and that one needs a more nuanced statement, 'but whatever'
17:00:59 <monochrom> first understand that. then you may be more ready
17:01:07 <jozefg> monochrom: so when deepseq itself is evaled then x is evaled as well?
17:01:22 <Nereid> edwardk: heh, ok.
17:01:28 <DrChaos> lolcathost :: is that the fast doubling algorithm on the page I linked to?
17:01:30 <monochrom> I don't understand the question
17:02:13 <lolcathost> DrChaos: I have no web browser atm.
17:02:46 <jozefg> monochrom: Never mind I got it
17:04:02 <lolcathost> DrChaos: If that's the exponentiation by squaring algorithm, then yes.
17:05:04 <zxq9> DrChaos: Have you read the Gentle Introduction to Haskell?
17:05:12 <DrChaos> zxq9 :: no
17:05:19 <lolcathost> DrChaos: You should!
17:05:32 <Nereid> @let pow e (*) x 0 = e; pow e (*) x 1 = x; pow e (*) x n = (if even n then id else (*) x) (let y = pow e (*) x (n `div` 2) in y*y)
17:05:33 <lambdabot>  Defined.
17:05:42 <shachaf> beep beep zam pow
17:05:59 <zxq9> DrChaos: Its not entirely gentle, but the first 3 chapters are particularly interesting to think through. Well, all of it is, really, but I think a lot of your confusion would be clarified if you read through that slowly.
17:06:00 <DrChaos> Given F(k) and F(k + 1) we have F(2k) = F(k)[2F(k + 1) - F(k)] and F(2k + 1) = F(k + 1)^2 + F(k)^2
17:06:22 <DrChaos> @google gentle introduction to haskell
17:06:24 <lambdabot> http://www.haskell.org/tutorial/
17:06:24 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
17:06:24 <Nereid> > pow (1,0) (\(a,b),(c,d) -> (ac+bd,ad+bc+bd)) (0,1) 8
17:06:26 <lambdabot>   <hint>:1:18: parse error on input `,'
17:06:31 <Nereid> > pow (1,0) (\(a,b) (c,d) -> (ac+bd,ad+bc+bd)) (0,1) 8
17:06:32 <lambdabot>   Not in scope: `ac'
17:06:32 <lambdabot>  Perhaps you meant one of these:
17:06:33 <lambdabot>    `a' (line 1), `c' (l...
17:06:36 <Nereid> oops haha.
17:06:45 <Nereid> > pow (1,0) (\(a,b) (c,d) -> (a*c+b*d,a*d+b*c+b*d)) (0,1) 8
17:06:47 <lambdabot>   (13,21)
17:07:07 <Nereid> > (fix $ (0:) . scanl (+) 1) !! 8
17:07:09 <lambdabot>   21
17:07:13 <DrChaos> Nereid :: holy crap, that's the answer!
17:07:29 <DrChaos> 0, 1 are the identies, are they not?
17:07:33 <DrChaos> identities*
17:07:46 <Nereid> DrChaos: (a,b) represents the number a + b * phi
17:07:50 <Nereid> where phi = (sqrt 5 + 1) / 2
17:08:00 <Nereid> the function there is multiplication of such numbers
17:08:04 <monochrom> 0=0 and 1=1 are identities
17:08:04 <Nereid> (1,0) is 1, and (0,1) is phi.
17:08:14 <Nereid> so it's just the fact that
17:08:20 <Nereid> phi^n = F_(n-1) + F_n * phi.
17:08:44 <Nereid> > let fib n = snd . pow (1,0) (\(a,b) (c,d) -> (a*c+b*d,a*d+b*c+b*d)) (0,1) $ n in map fib [0..]
17:08:46 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:09:35 <Nereid> the pow I defined above is a generic exponentiation by squaring function.
17:10:00 <Nereid> pow e (*) x n = x * x * ... * x (n factors)
17:10:00 <zxq9> In completely off-topic news, the Freenode weather review/forecast: http://zxq9.com/archives/763
17:10:07 <Nereid> and pow e (*) x 0 = e
17:11:33 <DrChaos> Nereid :: ahahahahah, somebody said that he'd been called a genius when pouring coffee into the wrong hole
17:11:45 <DrChaos> That's GENIUS
17:13:43 <Nereid> ??
17:14:38 <Nereid> you mean I'm *not* supposed to put the coffee in the water tank?
17:15:46 <DrChaos> Nereid :: well this guy had a coffee cup and a soup bowl. He put the coffee into the soup bowl and the soup into the coffee cup
17:16:09 <Nereid> I bet I've done worse.
17:16:42 <zxq9> DrChaos: I've been known to try drinking the salsa and pouring milk onto my eggs in the morning when distracted.
17:18:59 <othiym23> what's the current best practice for error / exception handling in Haskell?
17:19:32 <othiym23> like, an updated version of "8 ways to handle errors in Haskell" with recommended strategies
17:20:07 * derdon upvotes othiym23 question
17:20:53 <Nereid> sounds like a question that would get posted to stackoverflow.
17:22:04 <othiym23> Nereid: there are a bunch of existing questions, but none of them suggest that there's been any convergence on strategies across libraries
17:22:39 <othiym23> writing a bunch of lifting functions to weld together different error-handling approaches when using multiple libraries sounds like a huge bummer
17:23:14 <othiym23> I just figured people working on things like happstack would have hammered on this a bit
17:23:44 <othiym23> and that some of them might be here ;)
17:24:49 <othiym23> the closest I can find is the error-handling chapter in RWH
17:25:48 <Eiam> zxq9: nice link,
17:25:55 <Eiam> zxq9: and I just realized, thats your website =0 boo ahha
17:27:41 <zxq9> Eiam: Just thought to write that a few minutes ago, scanning over last day's logs... needs a few edits, but meh. Might do that every year -- Freenode is sort of an unfiltered measure of general community activity in a way (at least among uber geeks).
17:28:07 <Eiam> you don't comment on #rubyonrails or #ruby however
17:28:15 <Eiam> or ##javascript
17:28:20 <Eiam> so I felt a bit left out
17:28:43 <Eiam> since i know pretty much no haskell, I forgot everything I learned from the last time I picked it up, and I lurk here as a reminder to go start learning again =)
17:29:14 <zxq9> Eiam: Haha. No, Ruby is its own private nightmare, so I just rolled that up (gingerly) into the bit about #rails
17:30:30 <applicative> othiym23: have your looked at tekmo's lib http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html http://hackage.haskell.org/package/errors-1.3.1
17:31:13 <othiym23> applicative: no. thank you!
17:31:26 <Eiam> zxq9: how do you have any insight into the channels, you don't appear to BE on any of them =)
17:31:45 <othiym23> in semi-unrelated news, has anyone got ghci running in a browser with emscripten yet?
17:32:18 <othiym23> then Haskell could be added to http://repl.it, instead of Roy being left to carry the monadic flag alone
17:32:34 <zxq9> Eiam: My life gets sucked away by IRC if I am in too many at once... so logs is the way to travel in most cases. Same with MLs and usenet.
17:32:53 <Eiam> so you sit down and READ channel logs
17:32:56 <Eiam> but don't participate?
17:32:57 <Eiam> =0
17:33:52 <zxq9> Eiam: Its easy to identify the gems: they are nearly all snippets or links and conversation attending the two. Everything else is mostly whining/noise.
17:34:00 <zxq9> othiym23: Is there a big need for ghci in a browser?
17:35:19 <othiym23> having a Haskell REPL in the browser is always interesting, zxq9
17:35:31 <elliott> zxq9: fwiw arch's channel is #archlinux unless it changed
17:35:42 <othiym23> and is sure to have an even grosser implementation than the emscripten-generated versions of Ruby and Python
17:35:49 <Eiam> couldn't you do a REPL with something like Nu?
17:35:54 <Eiam> similiar to how it does it for objc?
17:36:16 <othiym23> Eiam: the goal is to have it actually hosted in the browser itself
17:36:18 <Eiam> oh, wouldn't be in the browser tho
17:36:20 <zxq9> elliott: Eek! I'll edit it in a bit. There's some stupid phrasing/bad writing in there too.
17:36:20 <Eiam> right yeah
17:36:24 <mauke> well, there's an entire linux system running in the browser
17:36:30 <othiym23> also to blow people's minds with the power of LLVM / emscripten
17:36:42 <othiym23> which doesn't have a strictly utilitarian value, but o well
17:36:48 <Eiam> i should add LUA to my list of languages to learn
17:36:51 <mauke> http://bellard.org/jslinux/index.html
17:36:51 <Eiam> sigh, not enough time
17:36:58 <Nereid> lua is a pretty cool language.
17:37:10 <Nereid> it knows what it's trying to be.
17:37:12 <Eiam> sure, but haskell seems that way too. I have no immediate use for either
17:37:16 <mauke> all I know about lua is that its array indices start at 1
17:37:20 <mauke> that's where I stopped reading
17:37:22 <Nereid> haha
17:37:24 <Eiam> mauke: wat? those jerksl
17:37:31 <Eiam> why would you do that.
17:37:47 <shachaf> I heard luajit is nifty.
17:37:49 <Nereid> well, you can start them at 0 if you want. just the standard library functions assume 1.
17:37:50 <zxq9> othiym23: So we need an interpreter hosted in a hosted envronment running in side another program atop a window manager on an OS which itself is likely virtualized in the first place... Is there a platform parallel to Occam's Razor, I wonder...
17:38:04 <othiym23> Eiam: a fun way to learn lua is to play around with luvit, which is basically a super-small, even faster version of Node.js with lua instead of JS
17:38:29 <othiym23> Eiam: or the newest version of Redis, which allows you to write stored procedures (more or less) in deterministic lua
17:38:34 <Eiam> oh just what I need, someone letting javascript out of the browser.
17:38:40 <Eiam> re: node.js
17:38:42 <Nereid> haha
17:38:42 <othiym23> which means that Redis is now basically an app server on top of everything else
17:39:10 <Eiam> i wish javascript would die. die die and be replaced by almost anything else. this will never happen ,but I will wish it anyway
17:39:13 <othiym23> zxq9: someday even reality will be virtualized (cf. ref. Greg Egan's Permutation City)
17:39:40 <othiym23> JavaScript keeps me fed and mentally occupied, which is good for the world at large
17:39:52 <Eiam> javascript makes me swear the most
17:39:53 <Eiam> =)
17:40:02 <lolcathost> lol @ mentally occupied
17:40:04 <Nereid> Eiam: we could just treat javascript as a target for compilers. cf. fay
17:40:07 <koala_man> Eiam: what if we start/keep layering things on top?
17:40:17 <zxq9> Welcome back to the revelations of the 1960's... Its like a big generational wheel of people who realize bits are bits and can execute, that code can pick its own path, and then eventually that running arbitrary stuff wherever doesn't always equate to a useful plan...
17:40:21 <Nereid> or ghcjs I guess
17:40:22 <othiym23> that's what llvm.js is for!
17:40:23 <lolcathost> othiym23: Juggling your way through its insane semantics?
17:40:26 <zxq9> and so they reduce the computing stack back down again.
17:40:27 <Eiam> koala_man: oh you mean how everyone tries to write a framework to manage the awfulness that is JS? don't we already try to do that?
17:40:46 <koala_man> Eiam: no, new languages that compile to js
17:40:55 <othiym23> using emscripten to compile llvm to JS so that you can use JS to translate your Haskell into LLVM bytecode that can be compiled down to JS again
17:40:57 <Eiam> oh, like dart or go or whatever
17:40:58 <othiym23> wheee
17:41:07 <Eiam> or coffeescript
17:41:10 <Eiam> sounds like an awful idea.
17:41:13 <koala_man> or haskell
17:41:19 <Eiam> sounds like an awful idea.
17:41:34 <zxq9> I think the breaking point tends to come when you start realizing that an instance of lang/host/box X is hosted on box Y which is hosted on yet another instance of X -- and then deciding that the turtles should indeed not extend all the way down.
17:41:35 <Nereid> Eiam: check out fay and then say again that it's an awful idea.
17:41:40 <lolcathost> Eiam: The problem with CoffeeScript is that JavaScript's syntax is the *least* of its problems.
17:41:53 <cmccann> Nereid, web applications are an awful idea
17:41:59 <Nereid> you're an awful idea
17:42:03 <Eiam> lolcathost: I've enumerated the problems I have with my boss once, about javascript. man we got into it
17:42:07 <othiym23> lolcathost: I was able to kill most of the afternoon tormenting people with oddities in JS's numeric stack: https://twitter.com/othiym23/status/286973393113333760 / https://twitter.com/othiym23/status/286983288516665344
17:42:15 <Eiam> I've since learned to not bother enumerating my problems with JS to people
17:42:31 <Eiam> and I too pay the bills with javascript, ruby & "web apps"
17:42:38 <lolcathost> Eiam: The problem is most likely JavaScript, not you.
17:42:39 <othiym23> lolcathost: JS's semantics are actually pretty simple -- unityped lambda calculus with some groday Algol syntax smeared over the top
17:42:47 <koala_man> othiym23: are you a brony or what?
17:42:49 <cmccann> Eiam, I wouldn't think enumerating the problems with JS would be that difficult
17:42:51 <cmccann> 1. JS
17:42:52 <cmccann> there, done
17:42:57 <othiym23> its problem is the way it jams mutation and lambdas together
17:42:58 <lolcathost> othiym23: What about scoping?
17:43:00 <othiym23> the results are non-delicious
17:43:13 <othiym23> lolcathost: the scoping rules are stupid, not insane ;)
17:43:17 <Eiam> cmccann: well, "not following principles of least surprise" maybe better
17:43:20 <Eiam> ugh, stop sucking me in. =)
17:43:37 <othiym23> koala_man: hell naw dogg, my avatar predates Friendship is Magic by like 7 years
17:43:41 <lolcathost> othiym23: What about "this"? What about prototypal inheritance? (Sorry, maybe I'm too close-minded, but I can only reason using types...)
17:43:43 <othiym23> at this point I refuse to change it mostly out of spite
17:44:08 <shachaf> /part #javascript-h8rs
17:44:14 <koala_man> you liked pony cartoons while they were still underground
17:44:29 <lolcathost> othiym23: Several times has JavaScript's "this" keyword made me want to get out of the office and stab random people just because.
17:44:32 <othiym23> lolcathost: the absence of a static type system is a bummer for sure, but "this" allows you to do some crazy shit, and you can still write most of the monads in pure JS
17:44:57 <mauke> lolcathost: why? 'this' is just another function parameter
17:44:59 <othiym23> I haven't tried to get a monad transformer working yet, mostly because the continuation monad in JS nearly broke my brain
17:45:05 <othiym23> too many functions returning functions
17:45:22 <shachaf> othiym23: An implementation of Cont in JS is pretty short.
17:45:49 <othiym23> shachaf: yeah, but getting it right was hard, for me at least
17:45:59 <lolcathost> othiym23: I'm a sloppy programmer, so I'm always going for whatever prevents me from causing too much damage - and advanced static type systems are the best tool for that.
17:46:02 <othiym23> didn't know until I tried to do it how hard I'd been leaning on Haskell / SML's type system
17:46:08 <Eiam> Nereid: I guess Fay would be interesting if I knew haskell, but I generally frown upon languagse that compile down to another 'high level' language
17:46:12 <othiym23> mauke: "this" is a keyword, not a function parameter
17:46:12 <shachaf> othiym23: Yep, for me too. Partly because I didn't realize what I was writing was Cont until after I'd written it.
17:46:14 <mauke> > let x = 0/0 in x /= x
17:46:15 <lambdabot>   True
17:46:16 <shachaf> A type system would've helped.
17:46:19 <croikle> mauke: the stuff where sometimes 'this' isn't what you want and you have to define 'that' instead?
17:46:22 <mauke> othiym23: what's the difference?
17:46:38 <mauke> croikle: you mean because it's a function parameter?
17:46:39 <othiym23> it's dynamically scoped, so it refers to wherever a function happens to be attached at the time it's called
17:46:48 <mauke> it's lexically scoped
17:46:55 <mauke> it always refers to the innermost enclosing function
17:46:55 <othiym23> nope
17:47:07 <Eiam> except when it doesn't
17:47:13 <mauke> it always does
17:47:15 <mauke> no exceptions
17:47:19 <shachaf> Eiam: Why are you in here if you don't know Haskell or are interested in Haskell-related things?
17:48:00 * shachaf likes the thing in JS where (1,x).y() != x.y()
17:48:05 <Eiam> shachaf: I've commented on that previously. I made it through most of learn you a haskell but didnt' have anything to DO with haskell, so I stay in here to remind myself to go pick it back up (and find something to do with it)
17:48:08 <zxq9> shachaf: I think its a reminder that a glimmer of sanity exists somewhere on the intertubes.
17:48:32 <zxq9> Eiam: Paraphrased what you *really* meant. ;-)
17:48:33 <Nereid> shachaf: what's the difference?
17:48:34 <othiym23> mauke: function Thing () { this.x = 1; } ; Thing.prototype.getX = function () { return this.x } ; var thing = new Thing() ; var getX = thing.getX ; getX() -> ?
17:48:39 * cmccann likes the thing in JS where he doesn't use it 
17:48:42 * Nereid isn't very experienced with js's subtleties
17:48:45 <shachaf> Nereid: "this"
17:48:52 <Nereid> hmm
17:49:15 <lolcathost> JavaScript's "this" is a major source of pain, really. :-|
17:49:21 <mauke> othiym23: window.x
17:49:30 <Eiam> lolcathost: only when it bites you, otherwise its not THAT big of a deal imo
17:49:37 <othiym23> that's not its innermost enclosing function ;)
17:49:42 <mauke> othiym23: wat
17:49:42 <Eiam> i mean i often do var that = this;
17:50:03 <lolcathost> Eiam: And then var thaat = that; var thaaat = thaat; and so on, right?
17:50:03 <Eiam> "hang on, I'm going deeper!"
17:50:17 <Eiam> lolcathost: haha I've actually only ever done it for one level deep
17:50:22 <mauke> othiym23: the 'this' in getX refers to the 'this' parameter of the innermost enclosing function. which is a function parameter. which is passed by the caller
17:50:28 <othiym23> also that's only true in a browser, in general it points to the global context when this is not bound to an object through the scope
17:50:40 <othiym23> mauke: there is no "this" parameter
17:50:42 <mauke> othiym23: which is 'window' because that's the default
17:50:55 <mauke> othiym23: every function in javascript has exactly two parameters, 'this' and 'arguments'
17:51:01 <othiym23> it's fundamentally not like Perl's blessing, it's dynamically evaluated
17:51:08 <mauke> wat
17:51:16 <othiym23> mauke: semantically it may look like that, but that's not how it's defined in ES5
17:51:18 <mauke> that doesn't even make sense
17:51:20 <Eiam> zxq9: lol maybe. I want to hope & believe, but until I experience it, I remain skeptical =)
17:51:28 <mauke> othiym23: I don't care about ES5
17:51:42 <othiym23> shit, man, that's the definition of the language
17:51:48 <deus_rex> lolcathost: you can avoid a lot of var that=this; with judicious use of Function.prototype.call/apply/bind
17:51:56 <mauke> othiym23: don't believe everything you read
17:52:11 <othiym23> you can not care about it all you want, but implementors use that as their guide for implementing things like JITs, not an intuitionistic understanding of its operational semantics
17:52:18 <mauke> Perl's bless is about associating objects with classes. JS doesn't even have classes
17:52:27 <lolcathost> deus_rex: Heh, I don't do Web development anymore, so I just avoid JavaScript altogether! XD
17:52:41 <mauke> othiym23: I don't think it's operational
17:53:24 <mauke> in fact, I don't care at all what implementors do as long as the results match my model
17:53:31 <shachaf> Nor is it intuitionistic.
17:55:44 <deus_rex> lolcathost: I'm a front-end web developer by trade, and it kind of irks me how so many programmers see the C-like syntax, and think it's isomorphic to <C-like language>
17:55:54 <Ralith> well
17:55:57 <deus_rex> and then declare it to be a crap language when they encounter exotic semantics
17:56:04 <deus_rex> like prototypal inheritance, etc
17:56:07 <deus_rex> anyway, this is very off topic
17:56:13 <cmccann> wait, I thought all languages with curly braces were essentially identical!
17:56:15 <othiym23> yeah, my bad
17:56:18 <Ralith> I'd hardly call that exotic
17:56:20 <othiym23> didn't mean to troll
17:56:26 <lolcathost> deus_rex: I don't expect it to look like C. I just expect it to be elegant.
17:56:30 <lolcathost> s/look/behave/
17:56:43 <lolcathost> Is that too much to ask for?
17:56:54 <deus_rex> lolcathost: Not at all, and it's true that JS has its warts and wrinkles
17:57:01 <othiym23> elegance is subjective
17:57:36 <othiym23> I find most of the JS written by substack to approach elegance, for a definition of elegance that prioritizes getting stuff done
17:59:59 <hpc> deus_rex: i like to say javascript is the most seamless transition from imperative to OO to functional programming that you can find today
18:00:20 <zxq9> I find that we're entering a bad state across techdom in general, since most of the effort across the entire industry is attempts to hack a document broadcast protocol into responsive applications that pretend to be secure...
18:00:42 <drdo> zxq9: Oh wow
18:00:46 <drdo> You feel it now?
18:00:57 <croikle> the browser is the new x86
18:00:59 <othiym23> well, you can have one of those at a time
18:01:09 <othiym23> croikle: hence llvm.js ;)
18:01:34 <deus_rex> hpc: I think that makes javascript potentially an excellent first programming language, were it not for mentioned the warts and wrinkles
18:02:41 <drdo> That is off the point, some sort of bytecode should have been used instead
18:03:17 <deus_rex> not that they were my first exposure to programming, but in the first year of CS courses I learned far more from the couple weeks spent on scheme than on java
18:03:21 <hpc> deus_rex: nah; maybe a second or third
18:03:39 <hpc> it's only really good for transitioning from one style to another, because everyone knows C syntax
18:03:42 <othiym23> deus_rex: JavaScript is a pretty terrible Scheme ;)
18:03:56 <zxq9> drdo: Been feeling it for a while... (warning, un-proofread blather ahead: http://zxq9.com/archives/530 http://zxq9.com/archives/535 http://zxq9.com/archives/711 )
18:04:00 <othiym23> altho it would be cool to see a Little JavaScripter
18:04:02 <deus_rex> hpc: one advantage it has is its ubiquity
18:04:30 <hpc> deus_rex: a ubiquitously horrid development environment ;)
18:05:03 <zeiris> The ironic thing is that browsers are cross-platform, but now there's cross-browser compatibility issues.
18:05:03 <hpc> i've done web dev for a couple of years now and STILL don't know how to write a goddamn string to the error console
18:05:04 <zxq9> deus_rex: That also implies a requirement to program toward utilizing lowest-common-denominator features.
18:05:28 <subbyyy> urlbar 5
18:05:41 <subbyyy> ooops typo
18:06:03 <othiym23> hpc: console && console.log && console.log("hi there, chum")
18:06:21 <hpc> zeiris: and annoyingly, it's split between IE and mobile-webkit; can't go too new or IE craps out; can't go too old or mobile webkits don't know what to do
18:07:04 <jmcarthur> and the prize for longest-module-to-compile-of-the-day goes to http://hackage.haskell.org/packages/archive/data-dword/0.2.1/doc/html/Data-DoubleWord-TH.html
18:07:17 <hpc> othiym23: not working for me (firefox, web developer toolbar's error console)
18:07:23 <jmcarthur> wait, no
18:07:28 <jmcarthur> i think it's actually http://hackage.haskell.org/packages/archive/data-dword/0.2.1/doc/html/Data-DoubleWord.html
18:07:44 <jmcarthur> i always mix up whether the module ghc shows is the one it's currently compiling or the one it just finished
18:07:47 <mauke> hpc: wfm in firefox, ctrl-k
18:07:58 <mauke> I mean ctrl-shift-k
18:08:25 <nh2> can I pass extra-include-dirs into cabal via an environment variable?
18:08:27 <hpc> mauke: aaaaaargh, that works
18:08:34 <DrChaos> how would you define this in a haskell source file?: (*) x) (let y = pow e (*) x (n `div` 2) in y*y)
18:08:37 <DrChaos> opps
18:08:48 <othiym23> hpc: what version of FF?
18:08:49 <hpc> strange that it wouldn't work in the web developer console
18:08:59 <hpc> othiym23: latest release
18:09:03 <DrChaos> nvm, I want to figure this out myself
18:09:06 <othiym23> I'm surprised anybody still uses Web Developer
18:09:09 <mauke> hpc: that is the web developer console
18:09:13 <mauke> what are you using?
18:09:20 <hpc> othiym23: it's got some neat stuff
18:09:48 <othiym23> yeah, but doesn't Firebug / the built-in console pretty much supplant it at this point?
18:09:56 <othiym23> hpc: console.dir(console) is fun in a meta way
18:10:00 <subbyyy> latest FF console isnt too bad
18:10:13 <hpc> does firebug still make firefox a lot slower?
18:10:31 <jozefg> hpc: for me yes
18:10:32 <pnielsen> yes
18:10:34 <othiym23> hpc: not if you leave it turned off most of the time and only enable it as needed, which is its current default state, I believe
18:10:37 <subbyyy> i stopped using it cause i remember it did, switched to chrome dev tools a while back
18:10:50 <othiym23> as a nodernerd, I use Chrome for everything, so I live in WebKit Inspector
18:10:54 <pnielsen> as long as you're using it it will be slower, simply because it's gathering a lot more info
18:11:12 <hpc> (also show form field info, hide background images, outline elements, show http headers, probably more i am forgetting)
18:11:24 <pnielsen> as othiym23 says, not if it's in disabled mode for the pages you're visiting
18:12:04 <hpc> you'd be surprised how handy hiding background images is; where i work we try to serve the same html to browsers and mail clients, and outlook doesn't do backgrounds of any kind
18:20:19 <DrChaos> how do you translate this "Basic method" here into haskell? http://en.wikipedia.org/wiki/Exponentiation_by_squaring
18:21:42 <DrChaos> I did: pow x n | x == 1 = x | otherwise = if even x then pow x*x (n `div` 2) else x * pow x*x ((n-1) `div` 2)
18:21:42 <hpc> x ** n | even x = ...
18:21:48 <hpc>        | odd x = ...
18:22:03 <hpc> or something like that
18:22:07 <DrChaos> but that results in an error
18:22:13 <DrChaos> ah
18:22:26 * DrChaos translates if statement into guard
18:22:42 <hpc> you can also match numeric literals
18:22:48 <hpc> 1 ** n = n
18:22:51 <hpc> x ** 1 = 1
18:22:55 <hpc> er
18:23:01 <hpc> you get what i mean
18:23:19 <hpc> and it will desugar into a guard with (==)
18:23:19 <shachaf> i love numeric literals
18:23:22 <shachaf> they are so easy
18:23:31 <croikle> you need parens for pow (x*x)
18:23:32 <hpc> this is incidentally the reason for Num having an Eq constraint
18:23:32 <DrChaos> pow x n | x == 1    = x
18:23:34 <hpc> @src Num
18:23:34 <lambdabot> class  (Eq a, Show a) => Num a  where
18:23:34 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:23:34 <lambdabot>     negate, abs, signum     :: a -> a
18:23:34 <lambdabot>     fromInteger             :: Integer -> a
18:23:34 <DrChaos>         | even x    = pow x*x (n `div` 2)
18:23:36 <DrChaos>         | otherwise = x * pow x*x ((n-1) `div` 2)
18:23:45 <shachaf> hpc: Except for the bit where it doesn't.
18:24:00 <hpc> oh right, that got changed
18:24:03 <croikle> pow x*x -> (pow x) * x, which is probably not what you want
18:24:25 <DrChaos> but that results in an Occurs check
18:24:27 <DrChaos> AH
18:24:29 <DrChaos> I see croikle
18:24:37 <DrChaos> got it fixed, it links now
18:24:43 <croikle> function application binds tightest
18:24:54 <mauke> >implying
18:24:57 <cmccann> using numeric literals as "patterns" with a type that has a Num instance but not Eq will generate the errors you'd expect
18:25:19 <cmccann> so it's not like having the Eq constraint on Num did anything very useful
18:25:40 <DrChaos> OK, so I got that pow function compiled in, now I just need to implement a suitable fib function
18:25:40 <mauke> > getZipList ZipList {getZipList = "hi"}
18:25:42 <lambdabot>   "hi"
18:26:36 <DrChaos> I don't know how you'd transfer the math in the Fast doubling method defined here into Haskell: http://nayuki.eigenstate.org/page/fast-fibonacci-algorithms
18:27:22 <DrChaos> the pow function is part of that solution, I just need to implement the fast doubling
18:28:14 <DrChaos> AH
18:28:38 <croikle> DrChaos: good for you on that pow, but I think the exponentials from the prelude implement that anyway
18:28:39 <hpc> i would probably go with a tree of some sort, for that one
18:28:57 <hpc> or a "table", if you take the typical diagram of a tree and rotate it 45 degrees
18:29:19 <croikle> ^^ and ^ do, ** uses exp and log stuff
18:29:54 <lightquake> what's the haskell style, GUIState or GuiState?
18:30:03 <parcs> GuiState
18:30:10 <elliott> the only popular style guide recommends the latter I think
18:30:10 <DrChaos> so erm...I don't know how to write a fast doubling fibonacci sequence algorithm, all I have is this Java code here to look at: http://nayuki.eigenstate.org/res/fast-fibonacci-algorithms/fastfibonacci.java
18:30:16 <elliott> personally I prefer the former
18:30:19 <hpc> going "down" will double the index you are looking at, going right will transition to (2k+1)
18:30:44 <lightquake> i like GuiState more too for reasons i can't identify
18:30:53 <hpc> then i think you could use some lcm/gcd magic to figure out how to scroll to a given index
18:31:42 <cmccann> the really interesting question about generating fibonacci numbers is: how many do you have to generate before your algorithm uses less memory than a lookup table of precomputed values?
18:31:55 <DrChaos> he's like: Hard or soft taco, quick, 5 seconds until the bomb explodess
18:32:14 <DrChaos> 5 seconds later: <HOARSE>Soft!</HOARSE>
18:32:22 <cmccann> note that it only takes 50 or so numbers to exceed a typical machine integer, I think.
18:33:13 <hpc> cmccann: or "how fast does your algorithm have to be for the recomputations to take less time than pre-generating a large table and eating the cache misses"
18:33:25 <cmccann> hpc, that's also interesting!
18:33:58 <hpc> obviously you can use a time-fast algorithm to generate the table, too
18:34:13 <cmccann> I was actually assuming a table generated at compile-time
18:34:30 <hpc> this reminds me of that primes package
18:34:43 <zxq9> will IO bottlenecks never affect the apparent speed, at any scale?
18:34:47 <hpc> that was just a global [Integer] of the first thousand prime numbers
18:35:07 <cmccann> hpc, that's beautiful
18:35:32 <hpc> dare i say it's an even more elegant abuse of coding ability than acme-php
18:36:51 <lightquake> hpc: haha
18:37:11 <lightquake> now i want to take that and extend it so you can do template haskell stuff
18:37:32 <lightquake> like, makePrimesList 'pList 200
18:38:28 <latermuse> :q
18:38:30 <latermuse> doh
18:38:42 <cmccann> hpc, ahahahahaha the "optimized for lists" sort is great
18:39:39 <croikle> ah, I found it. you really need to look at the source, the haddock isn't funny
18:39:58 <hpc> yeah, the source is key
18:39:58 <cmccann> hpc, and notElem is a work of art
18:40:54 <hpc> also, special thanks to https://github.com/rfw for contributing ("5 bananas" + "2 oranges" = "7")
18:41:02 <rfw> hpc: :)
18:41:11 <hpc> :D
18:42:36 <hpc> cmccann: my goal is to reimplement the entirety of Prelude.hs, with uniformly sublte and unique brokenness
18:42:44 <hpc> *subtle
18:42:48 <DrChaos> ok well erm...how do I do shiftLeft 1 b?
18:43:23 <DrChaos> I want to translate this java code into haskell or want somebody to estow their knowledge on how to make a fast fib function that generates the numbers on me
18:43:25 <croikle> the realfrac instance is broken, I think. the tail removes the '.', which shouldn't happen
18:43:48 <DrChaos> wait, that's pretty much useless
18:44:06 <DrChaos> or is it? I need to generate _every_ fibonacci number in the sequence up to 100
18:44:14 <croikle> just go with something small
18:44:21 <DrChaos> I mean, 400000000
18:44:37 <croikle> like fibs = 0:1:zipWith (+) fibs (tail fibs)
18:44:42 <cmccann> hpc, seems like you missed something important though
18:44:57 <latermuse> whats the best way to shift a list one to the right? [1,2,3,4,5] becomes [2,3,4,5,6]
18:45:12 <cmccann> hpc, you should enable OverloadedStrings and write IsString instances for basically everything
18:45:16 <hpc> croikle: it should work
18:45:30 <DrChaos> no it's for this project euler exercise, they have the nth fibonacci number  dialed up so that your code will run so slow you feel like tearing your hair AND your pupils out
18:45:31 <aavogt> > map succ [1,2,3,4,5]
18:45:32 <hpc> cmccann: yeah, i have spent maybe a total of 2 hours effort on acme-php so far
18:45:33 <lambdabot>   [2,3,4,5,6]
18:45:44 <cmccann> hpc, hours well-spent, clearly
18:45:50 <latermuse> thanks!
18:46:01 <DrChaos> so I want a FAST fib algorithm, but I don't know how to make it
18:46:06 <aavogt> > map (+1) [1,2,3,4,5]
18:46:08 <lambdabot>   [2,3,4,5,6]
18:46:09 <hpc> oh my god, i forgot i had this too: https://github.com/headprogrammingczar/acme-comonad
18:46:34 <DrChaos> > map (^16) [1..10]
18:46:36 <lambdabot>   [1,65536,43046721,4294967296,152587890625,2821109907456,33232930569601,2814...
18:46:59 <croikle> hpc: well, whatever you like. properFraction "12.345" = ("12","345") doesn't seem to match with the typical behavior.
18:47:00 <DrChaos> is that second number there equivalent to 64K?
18:47:22 <hpc> croikle: oh, damn you are right
18:49:15 <DrChaos> oh god, I can't translate this java code
18:49:43 <DrChaos> lolcathost :: how do you write a fast fibonacci algorithm in haskell?
18:50:15 <Nisstyre> DrChaos: unfoldr
18:50:21 <zxq9> Guest86792: That was an interesting way of evading the question.
18:50:25 <plhk> DrChaos: probably like this: fib n = fi^n - (1-fi)^n/sqrt(5) where fi = (1 + sqrt(5))/2 ?
18:50:30 <croikle> you have to calculate the first 400 millions fibonacchi numbers?
18:50:31 <Guest86792> zxq9: Authentication fail.
18:50:41 <Guest86792> zxq9: I haven't properly configured weechat.
18:50:43 <DrChaos> croikle :: yes
18:50:49 <Nereid> plhk: I hope that's not with floating point math.
18:50:57 <croikle> or all fibs under 400 million
18:51:01 <subbyyy_> ^5 wee chat user
18:51:03 <croikle> there's a big difference
18:51:15 <DrChaos> http://projecteuler.net/problem=2
18:51:15 <hpc> Nereid: and you know what else floats? A DUCK!
18:51:22 <Nisstyre> > take 10 $ unfoldr (\(p, c) -> Just (p, (c, p+c))) (0, 1)
18:51:23 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
18:51:38 <mauke> hpc: sort :: [()] -> [()]
18:51:43 <mauke> is this deliberate?
18:51:52 <DrChaos> Nisstyre :: WTF?!
18:51:56 <Nisstyre> plhk: you should let him try and prove the closed form
18:52:04 <hpc> mauke: yes; the package is really intended for you to be reading the source
18:52:06 <Nereid> DrChaos: the lazy functional way is to
18:52:11 <Nereid> make a list of *all* fibonacci numbers
18:52:15 <mauke> hpc: I did
18:52:24 <mauke> elem seems to be not broken
18:52:26 <Nereid> and then takeWhile them up to 4 million
18:52:28 <mauke> is this a bug?
18:52:40 <croikle> > length $ takeWhile (< 4000000) $ unfoldr (\(p, c) -> Just (p, (c, p+c))) (0, 1)
18:52:42 <lambdabot>   34
18:52:46 <Nereid> mauke: monomorphism restriction?
18:52:50 <mauke> Nereid: yeah
18:52:53 <croikle> you only need the first 34, not 4 million of thetm
18:52:54 <DrChaos> Nereid :: is that what that code does?
18:52:58 <hpc> mauke: is it broken?
18:53:06 <mauke> hpc: ?
18:53:08 <Nereid> DrChaos: think abou tit.
18:53:11 <Nereid> space
18:53:13 <croikle> you can get to 34 with the slow recursive version
18:53:27 <Nereid> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 34
18:53:27 <croikle> or the nice dynamic. you don't need to get fancy
18:53:30 <lambdabot>   mueval-core: Time limit exceeded
18:54:42 <Nereid> let fib n = fib' 0 1 n; fib' a b 0 = a; fib' a b n = fib' b (a+b) (n-1) in map fib [0..]
18:54:44 <Nereid> > let fib n = fib' 0 1 n; fib' a b 0 = a; fib' a b n = fib' b (a+b) (n-1) in map fib [0..]
18:54:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
18:54:47 <mauke> elem x [] = False; elem x (y : ys) = elem x ys || x == y
18:55:15 <croikle> Nereid: okay, it's slow in ghci, but 1.5s when compiled
18:55:25 <Nereid> that's still awful slow :p
18:55:32 <hpc> mauke: i was considering making it elem x (y:ys) = x == y || elem y ys
18:55:35 <croikle> sure :)
18:55:45 <hpc> but decided to leave at least a couple of correct functions just to screw with people
18:56:28 <Nereid> hpc: you should put acme-comonad on hackage ;)
18:56:32 <DrChaos> Nereid :: how do you compile that?
18:56:50 <Nereid> I would have called it Ntrl.Comonad but whatever.
18:56:54 <mauke> hpc: you should still put the recursive case first
18:56:59 <mauke> we don't want it to run too fast
18:57:03 <mauke> or work on infinite lists
18:57:17 <hpc> Nereid: it is
18:57:24 <hpc> Nereid: look under the Ntrol category
18:57:40 <hpc> (i accidentally forgot to make it Acme)
18:57:42 <Nereid> oh you made a new category.
18:57:44 <Nereid> heh
18:58:29 <Nereid> I should make something and put it on hackage.
18:58:52 <croikle> on the topic of code humor, seen evil.js? https://github.com/kitcambridge/evil.js/blob/gh-pages/evil.js
18:59:47 <DrChaos> Nereid :: wow, that's a really fast fib algorithm you posted there
18:59:47 <Nisstyre> DrChaos: is the unfoldr version fast enough?
18:59:56 <DrChaos> Nisstyre :: I didn't try it
19:00:09 <DrChaos> fib n = fib' 0 1 n
19:00:11 <DrChaos>         where fib' a b 0 = a
19:00:13 <DrChaos>               fib' a b n = fib' b (a+b) (n-1)
19:00:13 <croikle> it's basically the same
19:00:15 <mauke> evil.js is insufficiently evil
19:00:15 <DrChaos> that's fast!
19:00:16 <Nereid> just about anything is faster than the naive version
19:00:21 <Nisstyre> DrChaos: obviously the closed form will be the quickest for large n
19:00:23 <Nereid> DrChaos: that one's O(n) though
19:00:28 <Nereid> Nisstyre: closed form?
19:00:36 <mauke> non-recursive
19:00:44 <Nisstyre> Nereid: yes, there is a formula in terms of basic arithmetic functions
19:00:49 <Nereid> yes, including exponentiation
19:01:01 <Nereid> I'm very aware of it.
19:01:19 <Nereid> but exponentiation is recursive still.
19:01:19 <hpc> croikle: i have to agree with mauke here
19:01:30 <DrChaos> I really don't get how this fib function of yours works...I guess I'd have to trace it
19:01:38 <Nereid> unless you are doing floating-point exponentiation in which case you should be shot.
19:02:00 <Nereid> DrChaos: it's just like what you'd do in an imperative language, except with a loop replaced by recursion
19:02:24 <croikle> yeah, it's more "silly.js". it made me laugh the first time
19:02:32 <Nisstyre> Nereid: exponentiation may be recursive but "closed forms" are judged by how "well known" the functions are, and whether your function itself is recursive
19:02:38 <mauke> DrChaos: it loops from n down to 0, keeping two accumulators in a and b
19:03:14 <DrChaos> Nereid :: ah, well I still don't quite get it
19:03:14 <Nisstyre> Nereid: so, it won't be constant time, yeah
19:03:28 <mauke> I quite like evil.css
19:03:49 <DrChaos> I'd have to trace it
19:04:01 <hpc> br { display: table-cell; }
19:04:11 <hpc> and that will ruin pretty much every site made before 2004
19:04:30 <m3ga> does "ghc -ddump-splices" not work in ghc-7.6 like it did in ghc-7.4.1
19:04:32 <m3ga> ?
19:05:19 <Nereid> DrChaos: one moment
19:06:15 <DrChaos> Nereid :: fib 1 = fib' 0 1 n = fib' 1 1 (1-1) = fib' 1 1 0 = 1
19:06:47 <DrChaos> I can try fib 2...will take a while to trace though
19:06:53 <Nisstyre> DrChaos: you do know that there's a straight iterative algorithm for fibonnaci too right?
19:06:57 <Nisstyre> other than the tree recursive version
19:07:18 <DrChaos> Nisstyre :: no, I'm not aware of that one
19:07:27 <DrChaos> I'm really quite new to programming
19:07:38 <Nisstyre> okay, that's fine
19:07:49 <Nisstyre> you may want to have a look at SICP
19:07:54 <dmwit> Why " ::" instead of just ":"? Do less work, mate. =)
19:08:08 <DrChaos> fine
19:08:08 <hpaste> Nereid pasted “fib” at http://hpaste.org/80231
19:08:24 <hpc> also, conform to the convention for pinging people
19:08:28 <Nereid> DrChaos: the fib' recursion in haskell correpsonds to the loop in an imperative language
19:08:40 <dmwit> In fact, your IRC client will probably even do it for you if you start typing someone's nick and hit "tab".
19:08:42 <Nisstyre> DrChaos: the one Nereid just pasted is the iterative version
19:08:43 <hpc> some clients (namely the one i am using) will only ping on "<nick>:"
19:09:31 <Clint> hpc, that's sad
19:09:45 <DrChaos> dmwit :: my IRC client puts "dm<TAB> :: " = "dmwit :: " for m
19:09:47 <DrChaos> me
19:09:59 <hpc> Clint: it saves me from quite a bit of trouble in here
19:09:59 <Philippa_> hpc: you're only supposed to see when you're spoken to, not spoken about? Ow
19:10:05 <hpc> @google hpc
19:10:06 <lambdabot> http://www.hpc.ncep.noaa.gov/
19:10:06 <lambdabot> Title: Hydrometeorological Prediction Center (HPC) Home Page
19:10:15 <hpc> @google haskell program coverage
19:10:17 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_program_coverage
19:10:17 <lambdabot> Title: Haskell program coverage - HaskellWiki
19:10:21 <dmwit> huh, strange
19:10:26 <hpc> also high performance computing
19:10:28 * Clint nods.
19:10:36 <Philippa_> yeah, I can see that one being a pain
19:10:39 <Nereid> DrChaos: in general, loops in an imperative language translate to recursion in haskell, with loop parameters replaced with extra arguments to the recursive function.
19:10:44 <hpc> on another network my nick is "Spock", which is another one that gets pinged more than i would like
19:10:48 <DrChaos> Nereid :: wow
19:10:49 <monochrom> and all of you are only supposed to see sentences mentioning your name, therefore for example you don't see this, ever.
19:11:01 <Philippa_> too much K/S roleplay?
19:11:03 <Nisstyre> DrChaos: SICP calls those kinds of recursive functions "iterative"
19:11:14 <Nisstyre> which I think is a good way of saying it
19:11:18 <Nereid> actually
19:11:22 <Nereid> there's an intermediate step. let me paste it.
19:11:26 <DrChaos> I need to learn the technique to transform any while or for loop into a recursive call
19:11:46 <DrChaos> I see that the loop in haskell continues until n = 0
19:11:51 <dmwit> Oh, that's easy. First compile into assembly, then decompile into Haskell.
19:11:53 <DrChaos> well, the recursive call, that is
19:12:08 <DrChaos> dmwit :: no, that's not easy
19:12:20 <hpaste> Nereid annotated “fib” with “fib (annotation)” at http://hpaste.org/80231#a80232
19:12:32 <dmwit> I was not being 100% serious.
19:12:51 <Nereid> DrChaos: this is a more literal translation of the haskell version.
19:12:57 <DrChaos> Nereid :: nice
19:13:36 <Nereid> it's just that most imperative languages (including python) don't do tail recursion well so you never actually use it in practice.
19:14:08 <Nisstyre> DrChaos: this is one of my favourite recursive algorithms: http://ideone.com/lb2bSV
19:14:10 <dmwit> To be fair, Haskell does not do all tail-recursive functions well, either.
19:14:34 <cmccann> to be fair, Haskell does not benefit from TCO the same way strict languages do
19:14:39 <dmwit> right
19:14:47 <dmwit> You need a completely different approach to life.
19:14:57 <Nisstyre> look at Scheme for a better comparison
19:15:08 <cmccann> despite the inability of many compilers or interpreters for strict languages to perform an utterly simple optimization
19:15:26 <cmccann> for reasons that continue to escape my understanding
19:15:27 <mauke> in perl it's actually a pessimization
19:15:35 <mauke> normal calls are faster
19:15:35 <Nereid> lua does TCO :)
19:15:42 <cmccann> as a rule of thumb, perl is weird
19:15:45 <mauke> (I benchmarked it)
19:15:46 <cmccann> that's why peopel like it
19:15:47 <Nisstyre> so does Racket :)
19:16:03 <mauke> perl is also possibly unique in that it lets the programmer do a manual tail call
19:16:11 <Nereid> but racket is like scheme.
19:18:30 <Nisstyre> Nereid: well, sort of, but it has a lot more than Scheme
19:18:35 <Nereid> sure.
19:19:48 <Nereid> I've been meaning to learn a member of the lisp family, and scheme seemed to be fairly sane, so I installed racket the other day.
19:20:01 <Nisstyre> Nereid: cool, /j #racket
19:20:10 <Nereid> just restricting myself to r6rs for now.
19:20:37 <Nisstyre> Nereid: I'm working on a small static language in Racket, with type inference
19:21:05 <Nisstyre> basically just me trying to get better at parsing and learn about how type inference works
19:21:41 <cmccann> one of these days I need to give clojure a shot
19:22:21 <pickled> clojure is ok, but the whole toolchain for the jvm based lang's is slightly annoying
19:22:22 <cmccann> I've liked pretty much everything I've read from the guy behind it (whose name escapes me) about the motivations and principles &c
19:22:27 <DrChaos> Nisstyre :: I don't know how your favorite recursive algorithm works, it has a lot of heady stuff in itt
19:22:53 <Nisstyre> DrChaos: I like it because I came up with it myself without referencing anything on how to calculate permutations :P
19:23:13 <DrChaos> Nisstyre :: what is your IQ? I don't know mine
19:23:17 <Nisstyre> DrChaos: no idea
19:23:23 <Nisstyre> don't really care that much
19:23:28 <DrChaos> it's probably 150...lucky you
19:23:33 <Nisstyre> hah, no way
19:23:42 <Nisstyre> probably close to 100
19:23:50 <Nisstyre> maybe 110
19:24:05 <DrChaos> well I hope I'm at least 110 in math
19:24:10 <`nand`> people care about IQ?
19:24:23 <Nisstyre> DrChaos: well 100 is average by definition
19:24:41 <Nisstyre> `nand`: not particularly, unless I'm in psychology and we're talking about intelligence testing
19:24:59 <Philippa_> `nand`: A friend of mine's got a lot out of the components, but that's because they have a rather spiky profile
19:25:26 <Philippa_> it's pretty lousy the rest of the time though
19:25:56 <`nand`> intelligence is a nonlinear thing
19:26:16 <`nand`> (but this is -blah material)
19:28:31 * cmccann considers complaining about how measurement scales like IQ highlight how odious Num is, since multiplying IQs is patent nonsense but fromInteger is reasonable
19:29:32 <`nand`> if we divide IQs by 100, eg. 1.0 is the average, then maybe the product of two IQs is the combined intelligence of those two working together :P
19:29:54 <cmccann> `nand`, no, that would be min
19:30:00 <Nereid> haha
19:30:02 <Philippa_> cmccann: optimist
19:30:11 <edwardk> `nand`: (a + b) / 3
19:30:32 <Philippa_> edwardk: that at least passes the "does it scale to crowds?" test!
19:30:37 <cmccann> Philippa_, well I'm not accounting for other factors like communication and coordination overhead in general
19:30:49 <cmccann> since those apply to any form of cooperative task
19:32:18 <monochrom> Q: "people care about IQ?"  A: "sure people do, just look at all of you talking about IQ"
19:32:29 <Eduard_Munteanu> I work better when I'm alone, I guess that makes me below average? :P
19:32:39 <cmccann> monochrom, taking absurd things too seriously is my favorite form of humor
19:33:18 <`nand`> that might be the working principle of ‘lens’
19:33:29 <edwardk> ?
19:33:43 <Eduard_Munteanu> Still got that on highlight? :)
19:34:00 <monochrom> @stab stab
19:34:01 <lambdabot> I won't; I want to go get some cookies instead.
19:34:09 <cmccann> `nand`, what is, taking absurd things seriously?
19:34:13 <monochrom> @botsnack
19:34:13 <lambdabot> :)
19:34:17 <`nand`> yes. it wasn't a very well thought out joke, admittedly
19:34:18 <cmccann> I think lens is more about taking serious things absurdly.
19:34:30 <monochrom> haha
19:35:15 <`nand`> as long as you don't take absurd things absurdly
19:35:23 <Nereid> :t absurd
19:35:24 <lambdabot> Not in scope: `absurd'
19:35:33 <`nand`> then you get to zugohisto prepromorphisms
19:38:29 <edwardk> lens is more an experiment in seeing if i sufficient documentation can lead end-users through layer after after layer of abstraction and generalization
19:38:48 <`nand`> documentation, and type aliases
19:38:53 <`nand`> until you run :t
19:39:01 <monochrom> don't forget s t a b
19:39:05 <Philippa_> I'm certainly looking forward to seeing what my dad thinks of it when he has a go
19:39:06 <Nereid> running :t is the best part
19:39:22 <`nand`> I like how even ‘view’ has gotten harder to read thanks to the MonadReader stuff
19:40:20 * `nand` wonders if that can be rectified via type aliases
19:40:45 <`nand`> type r :-> a = forall m. MonadReader r m => m a
19:41:14 <Nereid> have you seen what's going into 3.8?
19:41:28 <`nand`> that's the profunctors patch?
19:43:29 <tgeeky> I just can't wait for the amateur functors. I bet they are tailor made for me.
19:43:31 <edwardk> `nand`: well, there is more than one profunctor patch going in ;)
19:43:39 <`nand`> ah
19:46:58 <`nand`> how long has it been since 3.7? the release cycle is in shambles
19:47:02 * hackagebot HLearn-distributions 0.1.0.0 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-0.1.0.0 (MikeIzbicki)
19:47:17 <edwardk> i've deliberately slowed the release cycle way down
19:47:53 <edwardk> currently i expect we'll get 3.8 out the door mid-to-late-january
19:48:11 <`nand`> what's still planned for it?
19:48:53 <edwardk> switching everything to profunctors, zipper improvements based on magma-derivatives so you can walk around in infinite traversals in more ways and do things like log-time index seeking in intmaps and maps
19:49:10 <`nand`> sounds neat
19:49:11 <edwardk> index-preserving getters, traversals, zippers, etc.
19:49:20 <cmccann> slowing down the release cycle for lens was probably necessary because the massive type signatures were overloading the hackage server's capacity
19:50:27 <edwardk> i'm currently working on breadth-first traversals, which you can use with commutative operations when you want to avoid having multple infinities you could fall into and only want to deal with one
19:50:54 <`nand`> hackage has seen worse
19:50:55 <`nand`> :: (Enveloped p, Transformable p, PathLike p, V p ~ R2, Enveloped a, V a ~ R2) => a -> p
19:50:59 <shachaf> FOUR SIMULTANEOUS INFINITES IN A SINGLE 24-NODE TREE ROTATION
19:51:39 <shachaf> nand: ifindOf :: Profunctor q => Overloading (Indexed i) q (Accessor (Endo (Maybe a))) s t a b -> (i -> a -> Bool) -> q s (Maybe a)
19:51:56 <shachaf> droppingWhile :: (Corepresentable p, Comonad (Corep p), Profunctor q, Applicative f) => (a -> Bool) -> Overloading p q (Compose (State Bool) f) s t a a -> Overloading p q f s t a a
19:52:01 <`nand`> ouch
19:52:01 <Philippa_> edwardk: is there enough in there that I can get my VPL parsing lib for 'free' yet?
19:52:44 <edwardk> shachaf: to be fair in the ifind case i expect that one will get nicer with a nicer type synonym.
19:52:54 <edwardk> the droppingWhile signature is pretty much indefensible ;)
19:53:16 <Philippa_> edwardk: wanting type-level records yet?
19:53:17 <edwardk> but i think i give like 16 alternatives right above it ;)
19:53:22 <edwardk> Philippa_: no
19:53:23 <`nand`> that Overloading stuff is getting almost as bad as iterators
19:53:31 <`nand`> in terms of type parameters
19:54:06 <Philippa_> `nand`: that's what I was thinking with the records, yeah
19:54:07 <edwardk> p  and q are the profunctors involved. f is the functor, forced on us by 'twan-compatibility' so we can work with traversals nicely
19:54:19 <edwardk> s t a b are what you've come to expect
19:54:40 <shachaf> edwardk: I almost hope we end up with the outer k eventually.
19:54:41 <edwardk> commonly p = q, or p = Indexed i, q = (->)
19:54:49 <edwardk> shachaf: heh
19:54:50 <shachaf> Just so that there are no concrete types left in the signature at all.
19:55:06 <shachaf> k (p a (g b)) (q s (f t))
19:56:31 <beefcube> i'm considering using haskell for testing some solutions related to resource constrained scheduling problems, is haskell a bad choice for this (in contrast to just using C or C++), since the gist that I'm getting from others is that Haskell makes dealing with graphs difficult? Sorry I know this is a dumb question, but I just want to avoid a lot of pain
20:02:30 <DrChaos> hmm...I want to test if a number is divisible by all of a list of numbers
20:02:43 <DrChaos> oh wait
20:02:50 <DrChaos> I can specify a range
20:03:08 <DrChaos> isDivisibleByList a b (x:xs) = ...
20:03:33 <DrChaos> well, the name of the function is misleadin
20:03:48 <DrChaos> isDivisibleByRangeOfNumbers
20:05:50 <DrChaos> isDivisibleByRangeOfNumbers a b (x:xs) | a <= b =
20:05:53 <DrChaos>                                        | True = error "invalid range"
20:06:21 <croikle> this seems overly complicated
20:06:58 <DrChaos> it might be
20:08:23 <plhk> > all ((== 0) . flip mod 5) [1..10]
20:08:25 <lambdabot>   False
20:08:49 <plhk> ah, it's the other way
20:10:27 <plhk> > all ((== 0) . mod 5) [5,10..20]
20:10:30 <lambdabot>   False
20:10:42 <DrChaos> wait, hell
20:10:53 <croikle> the flip was right
20:11:21 <croikle> helps to use `mod` 5 to think about it, perhaps
20:12:10 <DrChaos> wait, how to make my function return a true or false value as soon as a truth value is known?
20:12:44 <DrChaos> let me try and do that...
20:12:47 <DrChaos> might take some thought
20:13:09 <Clint> as opposed to waiting a few days to mull it over?
20:13:20 <DrChaos> yes
20:13:48 <`nand`> f x = sum [1..maxBound :: Int64] `seq` g x
20:15:02 <croikle> hm, how quick is that if you use Int32 instead?
20:15:22 <`nand`> it will most likely fill your memory rather fast
20:15:44 <`nand`> ‘sum’ doesn't have the most efficient implementation for that
20:15:49 <croikle> oh, yeah
20:17:17 <DrChaos> How do I generate tuples with a number and a truth value made by a call to isDivisibleByRange 1 20 <the number>?
20:17:26 <croikle> seems to be constant memory use, actually
20:17:32 <croikle> @src sum
20:17:33 <lambdabot> sum = foldl (+) 0
20:17:46 <croikle> maybe that's O2 working its magic
20:17:47 <Eduard_Munteanu> DrChaos: just write that?
20:18:00 <DrChaos> also, if I could filter for snd being True only, I'd find the number in no time
20:18:22 <croikle> then do that
20:18:27 <croikle> filter snd
20:18:28 <DrChaos> can I use the zip function for this?
20:18:32 <`nand`> croikle: the actual GHC/base implementation is different from what @src shows
20:18:38 <`nand`> croikle: but yeah, I was running without optimizations
20:19:11 <croikle> took 75 seconds or so for 32 bits here
20:19:11 <DrChaos> :t zip
20:19:12 <lambdabot> [a] -> [b] -> [(a, b)]
20:19:27 <DrChaos> how do i use the zip function?
20:19:46 <subbyyy> > zip [1, 2] [3, 4]
20:19:47 <lambdabot>   [(1,3),(2,4)]
20:19:48 <shachaf> i love zip functions
20:19:50 <shachaf> they are so easy
20:20:08 <DrChaos> no, I don't think that's what I had in mind
20:20:25 <Eduard_Munteanu> map is more appropriate
20:20:45 <`nand`> I think answering that would entail figuring out what DrChaos is trying to accomplish in the first place
20:21:00 <shachaf> I've already determined that to be impossible.
20:21:09 <plhk> DrChaos: [(n, isDivisibleByRange 1 20 n) | n <- [1..5]]
20:21:09 <croikle> probably working on primality testing
20:21:13 <DrChaos> what I want is a sort of loop of all numbers [1..40000] that outputs a tuple containing the number and a truth value from a call to isDivisibleByRange 1 20 <the number>
20:21:18 <DrChaos> plhk :: ah
20:22:39 <Eduard_Munteanu> Why do you need the tuple?
20:22:51 <DrChaos> plhk :: how do I filter that list for snd == True?
20:23:02 <Eduard_Munteanu> I mean maybe you're trying to solve some other problem.
20:23:36 <croikle> you can filter in the list comprehension
20:23:40 <croikle> or outside it
20:24:03 <DrChaos> croikle :: can you show me how you'd do that outside the list comprehension?
20:24:21 <plhk> DrChaos: filter snd [(n, isDivisibleByRange 1 20 n) | n <- [1..400000]]
20:24:23 <Eduard_Munteanu> length . filter snd
20:24:26 <croikle> filter (\x -> snd x == True) is the literal one
20:24:38 <croikle> but that reduces to filter snd, as said before
20:24:39 <`nand`> of course, (==) True = id
20:24:55 <Eduard_Munteanu> Erm, I guessed you were interested in how many of them are true, for some reason.
20:28:27 <DrChaos> is there any way to use takeWhile so that as long as a condition evaluates to False the program just keeps on going on to bigger and bigger numbers?
20:28:37 <DrChaos> or am I thinking of some other function?
20:29:19 <plhk> :t any
20:29:21 <lambdabot> (a -> Bool) -> [a] -> Bool
20:29:23 <tgeeky> DrChaos: dropWhile ?
20:29:28 <AfC> um, takeWhile (not condition) ?
20:29:42 <tgeeky> yes, what he said
20:29:45 <Hafydd> If you're okay with it running out of memory.
20:29:56 <ivanm> where does running out of memory come from?
20:30:08 <cmccann> from using a lot of memory, typically
20:30:10 <Hafydd> > takeWhile (const True) [1..]
20:30:11 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:30:21 <AfC> Hafydd: I use a Turing machine. It has an infinite amount of tape. No memory problems.
20:30:33 <ivanm> Hafydd: for it to run out of memory depends on what you do with the results, not with the takeWhile itself
20:30:41 <Hafydd> Oh yes, sorry.
20:30:43 <tgeeky> > dropWhile (const False) [1..]
20:30:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:30:51 <Hafydd> I was just writing some Python, it must have addled my brains.'
20:31:18 <ivanm> I believe that's an occupational hazard :p
20:31:50 <DrChaos> um...I don't know how to combine takeWhile with other functions to result in a tuple with (<a number>, isDivisibleByRange 1 20 <a number>) in the output
20:32:09 <ivanm> que?
20:32:28 <ivanm> DrChaos: back up a bit and tell us what you actually want to do
20:32:47 <DrChaos> ivanm :: I want to solve this project euler problemhttp://projecteuler.net/problem=5
20:32:54 <DrChaos> http://projecteuler.net/problem=5
20:33:03 <plhk> yeah, this sounds like XY problem (http://www.perlmonks.org/index.pl?node_id=542341)
20:33:37 <DrChaos> to do that I wrote the function isDivisibleByRange which tests if a number is evenly divisible by a whole range of numbers
20:33:44 <ivanm> plhk: yeah, just couldn't remember that term :p
20:34:05 <ivanm> DrChaos: so isDivisibleByRange :: (Int,Int) -> Int -> Bool or something?
20:34:32 <DrChaos> ivanm :: yes
20:34:38 <ivanm> I'd be tempted to do then: head . filter (isDivisibleByRange (1,20)) [1..]
20:34:50 <roadfish> if step through a point-free function in ghci, is there any way to look at the values being operated on?
20:35:04 <ivanm> or you could optimise it: using a range of (11,20) should suffice
20:35:19 <ivanm> roadfish: ghci has a debugger, but I've never used it
20:35:25 <ivanm> or you can scatter trace statements everywhere
20:35:36 <DrChaos> ivanm :: does that show which number caused the isDivisibleByRange function to output True?
20:35:42 <ivanm> but it's probably easier if you _don't_ use point-free in that case if you don't understand it :p
20:35:47 <ivanm> DrChaos: yes
20:35:54 <ivanm> @type filter
20:35:56 <lambdabot> (a -> Bool) -> [a] -> [a]
20:35:57 <AfC> ivanm: I actually tried it the other day. It was surprisingly useful. You do have to jump through the hoops to make sure you can run a [snippet of] your program from GHCi, which can be tricky.
20:36:02 <ivanm> ^^ return only values that match the rpedicate
20:36:10 <Hafydd> > let xs = [1..] in dropWhile (const True) xs `seq` xs
20:36:16 <lambdabot>   mueval: mueval: Prelude.undefinedExitFailure 1
20:36:16 <roadfish> ivanm: too true. I am now learning one of the pitfalls of using point-free function.
20:36:22 <ivanm> heh
20:36:27 <ivanm> unmaintainable mess? :p
20:37:00 <DrChaos>     Couldn't match expected type `a0 -> [c0]' with actual type `[a1]'
20:37:02 <DrChaos>     In the return type of a call of `filter'
20:37:04 <DrChaos>     Probable cause: `filter' is applied to too many arguments
20:37:31 <ivanm> oh, I forgot the $
20:37:44 <ivanm> head . filter (isDivisibleBy (11,20)) $ [1..]
20:38:04 <ivanm> again, you can minimise your work by starting at a higher number
20:38:12 <DrChaos> problem5: Prelude.head: empty list
20:38:15 <roadfish> is there any opinion on point-free. makes things clean or makes things obtuse? I'm still trying to adopt high-level Haskell-thinking.
20:38:28 <`nand`> depends
20:38:58 <ivanm> DrChaos: which means there's either no such number, or your isDivisibleBy function is wrong
20:38:59 <shachaf> roadfish: I say you should make one decision right now -- point-free good or point-free bad -- and from now on, always go by that, no matter what.
20:39:04 <ivanm> and in this case I suspect the latter :)
20:39:38 <ivanm> DrChaos: actually, if you had [1..] as your input list, there's no way you'd ever get that error, as the filter would never stop and return an empty list...
20:40:02 <ivanm> roadfish: for small things, it can help you avoid an explicit variable
20:40:42 <DrChaos> ivanm :: I don't think that function is wrong as I tested it with isDivisibleByRange 1 10 2520 and it worked perfectly
20:41:00 <DrChaos> I then tried it with 2519 as the last argument and it correctly outputted False
20:41:00 <ivanm> can you paste your entire code up somewhere?
20:41:01 <ivanm> @hpaste
20:41:01 <lambdabot> Haskell pastebin: http://hpaste.org/
20:41:31 <hpaste> DrChaos pasted “problem5” at http://hpaste.org/80234
20:41:39 <glguy> DrChaos: check out
20:41:40 <glguy> :t find
20:41:44 <lambdabot> (a -> Bool) -> [a] -> Maybe a
20:42:05 <roadfish> ok, I had written some code that processes a text file and extracts info. Then I started switching code to a point-free style ... and was amazed at home much got switched over ... but then at one step hit this bug and realized that I can't get values during point-free debugging.
20:42:05 <ivanm> oh, forgot about find
20:42:06 <glguy> I haven't been following your conversation, but but seems like a function you were just asking for
20:42:36 <ivanm> DrChaos: what's the actual input list you're providing to the filter?
20:42:56 <DrChaos> um...[2520] for starters
20:43:55 <DrChaos> oh wow
20:44:01 <DrChaos> main :: IO()
20:44:02 <DrChaos> main = print $ head . filter (divisibleByRange 1 10) $ [2520]
20:44:07 <DrChaos> that prints out 2520
20:44:10 <hpaste> ivanm annotated “problem5” with “problem5 (annotation)” at http://hpaste.org/80234#a80235
20:44:18 <ivanm> DrChaos: ^^
20:44:39 <croikle> maybe you wanted [1..2520] instead?
20:44:53 <DrChaos> if I do it like this will it keep on going forever? I want it to stop at the first True result. : main = print $ head . filter (divisibleByRange 1 20) $ [1..]
20:45:01 <roadfish> I'm still coming from Python and getting into this Haskell world. There is a term "Pythonic" and a "right way" to do things in Python. Is there a smilar notion in Haskell? And a similar term, like "Haskellic"? Or is Haskell just to vast/deep to have a standard approach?
20:45:05 <croikle> try and see?
20:45:21 <ivanm> DrChaos: yes, that's what the head is for
20:45:22 <ivanm> @type head
20:45:24 <lambdabot> [a] -> a
20:45:26 <croikle> if there is a result, the head picks the first one
20:45:38 <DrChaos> oh perfefct
20:45:39 <ivanm> croikle: well, there should be; if nothing else product [1..20]
20:45:48 <croikle> yes, I know
20:45:50 <DrChaos> I'll let it run a long time
20:46:01 <croikle> just figured he could do with some experimenting spirit
20:46:13 <glguy> > foldl1 lcm [1..10]
20:46:14 <lambdabot>   2520
20:46:38 <`nand`> glguy: nice
20:46:42 <croikle> > foldr1 lcm [1..20]
20:46:44 <lambdabot>   232792560
20:46:45 <DrChaos> [drchaos:~/Programming/Haskell/euler]$ ./problem5
20:46:47 <DrChaos> 232792560
20:46:49 <DrChaos> [drchaos:~/Programming/Haskell/euler]$
20:46:52 <DrChaos> woot! I bet that's the correct answer!
20:47:11 <DrChaos> Yep, solved it!
20:47:39 <glguy> You're going to have to list the language you are using to solve problems as #haskell
20:47:45 <croikle> hahaha
20:48:19 <DrChaos> oh god, you mean that I really don't know anything
20:48:36 <DrChaos> at least I came up with the whole divisibleByRange function
20:48:49 <`nand`> glguy: language used: IRP
20:49:22 <DrChaos> maybe if I'd read that Gentle Introduction to Haskell I'd get much better
20:49:32 <croikle> you're getting somewhere. your solutions can be kind of complex, but you need practice, basically
20:50:13 <ivanm> I would have guessed that divisibleByRange (a,b) x = all ((==0) . mod x) [a..b]
20:50:23 <croikle> composing Prelude functions is usually nicer than making your own recursive functions
20:50:25 <glguy> DrChaos: The point is that Project Euler isn't programming problems, it's math problems. Being great at Haskell won't make you great at Project Euler
20:50:29 <ivanm> DrChaos: nah, the gentle introduction was only gentle at the time
20:51:10 <DrChaos> glguy :: ok
20:51:27 <donri> not sure i'd call euler problems "math problems"... the palindrome of a number?
20:51:30 <DrChaos> well, um...I'll read that gentle introduction to haskell after I watch one more episode of Code Lyoko
20:51:32 <twopoint718> There is often some kind of mathematical insight that can solve a Euler problem straight-away.
20:52:08 <`nand`> most of the PE problems after the first dozen or so are designed so that brute forcing them is intractable
20:52:28 <Nereid> project euler isn't really a good way to learn a new language
20:52:30 <croikle> you have to have at least one algorithmic insight, yeah
20:52:37 <Nereid> well
20:52:56 <`nand`> Nereid: as long as you don't mind not finding the answer?
20:53:11 <Nereid> no, I mean
20:53:37 <Nereid> especially if you're trying to design an algorithm to solve the problem at the same time.
20:57:05 <roadfish> ok! I just answered my question (sort of). Temporarily convert a point-free function into a lambda function and then I can print the argument in ghci.
20:59:21 <Iceland_jack> donri: finding a palindrome is not a math problem?
20:59:51 <donri> treating numbers as strings of characters doesn't seem very much like math to me
20:59:53 <Iceland_jack> abcba means solving 10001a + 1010b + 100c
21:00:01 <donri> of course at some level, "everything is math", but that's besides the point
21:00:11 <Iceland_jack> My point is definitely not that everything is math..
21:02:05 <beaky> hello
21:04:11 <donri> the euler project i'm remembering isn't about finding palindromes like "abcba" but about things like, find a *number* whose exponent is a palindrome, e.g. 11^2 = 121
21:04:31 <donri> s/project/problem/
21:04:46 <Iceland_jack> the square of whom, yeah
21:04:57 <donri> yea
21:04:58 <donri> sorry
21:05:02 <Iceland_jack> no problem
21:05:53 <donri> http://projecteuler.net/problem=4
21:06:53 <Iceland_jack> Interesting
21:07:04 <Iceland_jack> so two 2-digit numbers?
21:07:12 <Iceland_jack> no exponentiation really
21:07:21 <donri> i was making up an example
21:07:24 <Iceland_jack> sure
21:07:33 <Iceland_jack> but you can use a similar thing that I pointed to earlier, no
21:07:34 <Iceland_jack> ?
21:07:38 <donri> point being that it's talking about numbers as strings
21:07:49 <Iceland_jack> Where?
21:08:02 <donri> the whole problem.
21:08:24 <Iceland_jack> Not sure I would agree with that, do you think the concept of palindrome numbers implies strings?
21:08:26 <donri> eh, nevermind
21:09:28 <Iceland_jack> so you're looking for 3-digit numbers x and y such that: x * y = abccba right?
21:09:44 <Hafydd> Iceland_jack: how would you define a palindromic number?
21:09:58 <Iceland_jack> Hafydd: wikipedia has a nice entry
21:10:27 <Hafydd> Yes, it does.
21:10:29 <Hafydd> "A palindromic number or numeral palindrome is a number that remains the same when its digits are reversed."
21:10:47 <Hafydd> What are these "digits" of a number it's talking about?
21:10:57 <Hafydd> They seem to form some kind of a string, don't they?
21:11:11 <Iceland_jack> Just because digits may coincidentally form a string that does not mean that it is a string problem
21:11:38 <Hafydd> I don'
21:11:38 <Iceland_jack> Case in point, Wikipedia's formal definition
21:11:41 <Hafydd> I don
21:11:50 <Hafydd> I don't think anyone said it was a "string problem".
21:12:16 <Iceland_jack> donri said that it treated numbers as strings
21:13:56 <fragamus> GHC optimization question: I have a recursive function, and a parameter passes, unchanged, on recursive invocation. Inside the function there is an equation based solely on the variable. IS GHC SMART ENOUGH to re-use the result of that equation in the recursive calls rather than recompute the result?
21:15:52 <AfC> fragamus: I believe the answer is "it depends"
21:16:26 <AfC> fragamus: I saw discussion of this on Stack Overflow or Reddit just in the last few days
21:16:52 <fragamus> really?
21:16:52 <AfC> fragamus: unfortunately, I AM NOT SMART ENOUGH to know what GHC is going to do on a given day.
21:17:05 <lolcathost> fragamus: Is it impossible to refactor your function into, say, an inner helper recursive function, which has access to the unchanging value?
21:17:21 <fragamus> yes
21:18:01 <fragamus> but its interface is currently very pretty and i dont want to wreck it unless i have to
21:18:08 <lolcathost> f a b c ... = g ... where { unchanging = ... ; g ... = recursive definition having access to unchanging }
21:18:15 <manju> Hello
21:18:17 <lolcathost> fragamus: The interface doesn't have to be altered.
21:18:23 <lolcathost> fragamus: Only the internal implementation.
21:18:33 <fragamus> oh right
21:18:52 <fragamus> I WAS NOT SMART ENOUGH
21:19:08 <manju> Maybe wrong question for this channel, but does Frege have the equivalent of a ghci ?
21:19:20 * lolcathost never used Frege.
21:20:13 <lolcathost> fragamus: Heh, no worries, everyone has bad days.
21:21:43 <dolio> Project euler 4 is easily solvable on a computer by brute forcing if you just treat numbers as strings. But there are ways that aren't brute force that involve math.
21:22:27 <dolio> Not complicated math, but more math than multiplying, stringifying, reversing.
21:23:22 <Iceland_jack> I would advise against using the brute-force solution
21:23:41 <dolio> Right. That's not the point of the problems.
21:23:51 <Iceland_jack> it is not difficult to simplify it substantially
21:24:01 <dolio> Eventually they started making them so that they aren't easy to brute force.
21:24:11 <dolio> To encourage the actual math-involving solutions.
21:28:02 <covi> @hoogle Int -> Integer
21:28:02 <lambdabot> Data.Bits bit :: Bits a => Int -> a
21:28:03 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
21:28:03 <lambdabot> Data.Bits complementBit :: Bits a => a -> Int -> a
21:28:20 <covi> I have an Int, how do I change it into an Integer?
21:28:22 <croikle> fromIntegral
21:28:32 <croikle> your general integral conversion function
21:28:55 <donri> dolio: i suspected as much. i guess i'm wondering if the concept of a palindromic number has any significance in math or if it's just a peculiarity we made up and devices a formal definition for?
21:29:09 <covi> I tried  (fromIntegral . length)  as a function that returns the length of a list as an Integer, but typecheck fails.
21:29:29 <Iceland_jack> @type genericLength
21:29:31 <lambdabot> Num i => [b] -> i
21:30:21 <covi> @src genericLenght
21:30:21 <lambdabot> Source not found. It can only be attributed to human error.
21:30:22 <croikle> strange, I'd think it would work. still, genericLength is exactly that
21:30:24 <covi> @src genericLength
21:30:24 <lambdabot> genericLength []    = 0
21:30:24 <lambdabot> genericLength (_:l) = 1 + genericLength l
21:30:58 <covi> So taking a length of a list is O(n) in haskell?
21:31:18 <croikle> yes
21:31:50 <croikle> though there are other data structures which are better for many uses
21:32:36 <dolio> Well, pretty much every structure is going to be O(n) telling you its size unless it precomputes it.
21:32:39 <croikle> > (fromIntegral . length) [] :: Integer
21:32:42 <lambdabot>   0
21:33:03 <croikle> ^ this does work, btw.
21:33:22 <croikle> but only for lists not longer than an Int
21:33:26 <croikle> hence genericLength
21:34:30 <croikle> I hate to think of how long 4 billion Integer computations will be, though...
21:37:40 <DrChaos> I'm doing something illegal
21:37:59 <DrChaos> I'm making a cup of coffee at 23:37 :P
21:39:36 <DrChaos> OMFG it's so gewd
21:39:59 <covi> What's the diff. between Integer and Int in Haskell?
21:40:11 <shachaf> @google What's the diff. between Integer and Int in Haskell?
21:40:12 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2005-May/009906.html
21:40:12 <lambdabot> Title: [Haskell-cafe] Int vs Integer?
21:40:23 <shachaf> Cale++
21:40:27 <DrChaos> if you implement basic instructions in C with __asm__ is it possible to write e.g. a BIOS in Haskell?
21:40:38 <Iceland_jack> croikle: didn't take too long..
21:40:39 <dolio> croikle: 4 billion doesn't take long.
21:40:45 <dolio> 2^64 takes a while.
21:40:53 <DrChaos> I'd get the machine to switch to 32 bit mode with C
21:40:55 <croikle> haha, I'm sure it would
21:40:59 <DrChaos> then the haskell takes over
21:41:41 <shachaf> elliottcable: What if I could get you a good deal on the nick "elliott"?
21:42:06 * elliottcable laughs
21:42:14 <elliottcable> shachaf ⑊ I already offered him over a grand. He declined.
21:42:43 <DrChaos> I should address people with radioactivity warning sings
21:42:46 <DrChaos> signs
21:42:48 <elliottcable> In fact, I'd never use the damn thing; I either go by “ec” or this, the same thing I use everywhere else
21:43:01 <elliottcable> DrChaos ⑊ SPREAD THE COMPLETION_CHAR CHAOS
21:43:10 <shachaf> No. You really shouldn't. It's annoying. Just use : like everyone else.
21:43:12 <elliottcable> but getting hilighted every time he involves himself in a conversation in here *was* annoying
21:43:24 <DrChaos> elliottcable :: yours is sexy
21:43:35 <elliottcable> DrChaos ⑊ I like ::. Stick with it and ignore the hatahs.
21:43:46 <DrChaos> :)
21:44:07 <ezyang> Hmm, does alex's posn wrapper easily support generating line spans (e.g. what line/col a token starts and what line/col it ends)? Sounds like I need a monad to do that...
21:54:01 <covi> @hoogle IO a -> ErrorT b IO a
21:54:01 <lambdabot> Did you mean: IO a -> ErrorT b (IO a) a
21:54:01 <lambdabot> Control.Monad.Trans.Error throwError :: (Monad m, Error e) => e -> ErrorT e m a
21:57:08 * hackagebot webserver 0.6.0.0 - HTTP server library  http://hackage.haskell.org/package/webserver-0.6.0.0 (JohnLato)
22:00:15 <lightquake> how do I convert a Double to/from a CDouble?
22:01:31 <glguy> ?type realToFrac
22:01:31 <shachaf> realToFrac?
22:01:32 <lambdabot> (Fractional b, Real a) => a -> b
22:05:12 <lightquake> and all the OpenGL stuff requires ctypes, which means i'm going to have to put realToFrac everywhere around my graphics code :/
22:05:33 <covi> Main.hs:29:20: Module `Data.IORef' does not export modifyIORef'
22:05:55 <covi> What's wrong? http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html says it does have modifyIORef'
22:06:23 <lightquake> covi: which version of base do you have?
22:06:24 <glguy> covi: You probably have an older version of "base"
22:07:43 <donri> well, http://hackage.haskell.org/packages/archive/base/3.0.3.1/doc/html/Data-IORef.html
22:07:50 <monochrom> or use CInt and CDouble throughout
22:07:58 <donri> must be a *really* old base then
22:08:10 <lightquake> base 3.x is pretty old
22:08:18 <lightquake> what would that be, even
22:08:19 <donri> lightquake: and it does have modifyIORef
22:08:39 <lightquake> monochrom: yeah, i guess there's no downside to it
22:08:48 <donri> oh wait a prime
22:09:59 <statusfailed> Is there a safe version of toEnum, something like safeToEnum :: Enum a => Int -> Maybe a
22:10:06 <beaky> hello
22:10:26 <beaky> what is the difference between a variable in a purely-functional language like Haskell and a variable in something like C?
22:10:30 <donri> covi: looks like you need ghc 7.6 for that, but it's easy to add yourself: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/src/Data-IORef.html#modifyIORef%27
22:10:39 <glguy> statusfailed: No.
22:11:08 <statusfailed> hm, ok.
22:11:29 <donri> @hoogle Enum a => Int -> Maybe a
22:11:29 <lambdabot> Prelude toEnum :: Enum a => Int -> a
22:11:29 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
22:11:29 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
22:11:37 <lightquake> beaky: Haskell variables are 'referentially transparent', meaning that if x = f y, then you can replace x with f y everywhere
22:11:48 <beaky> ah
22:11:53 <covi> How can I update my ghc?
22:12:05 <covi> I'm using the platform on Mac OS I believe.
22:12:18 <statusfailed> @hoogle (Enum a, Bounded a) => Int -> Maybe a
22:12:18 <lambdabot> Prelude toEnum :: Enum a => Int -> a
22:12:18 <lambdabot> Data.IntMap lookup :: Key -> IntMap a -> Maybe a
22:12:18 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
22:12:24 <glguy> covi: You should be using the latest version of the Haskell Platform, typically.
22:12:38 <glguy> covi: (and especially if you have to ask)
22:12:39 <statusfailed> bounded doesn't guarantee all ints within the bounds are valid though I guess
22:12:49 <covi> The Glorious Glasgow Haskell Compilation System, version 7.4.2
22:13:10 <beaky> how does haskell handle state
22:13:13 <ziman> beaky, in Haskell, a variable is simply a name for a value, `a = 2 + 3' means that `a' is an alias for `2+3', while in C, variables are "boxes" where you can put different values and change their contents, similar to IORef in Haskell
22:13:29 <beaky> oh
22:13:41 <beaky> so haskell has those boxed variables that are everywhere in imperative languages?
22:14:50 <monochrom> how does haskell handle state: depends on what you use state for
22:15:17 <beaky> I want to write the imperative stateful version of factorial for example
22:15:23 <ziman> in Haskell, the word "boxed" has a bit different meaning, but yes, the idea of a mutable variable corresponds to IORefs/STRefs
22:15:30 <monochrom> in general: "how to translate each feature into haskell" is counterproductive. ask directly: how to solve each problem in haskell
22:15:33 <shachaf> i love boxed variables
22:15:34 <ziman> it's just that you use them quite differently
22:15:36 <shachaf> they are so easy
22:16:38 <thoughtpolice> shachaf: what happened to your capitalization?!
22:18:20 <shachaf> thoughtpolice: Hmm?
22:18:31 <monochrom> you can convert imperative variables to function parameters. to "modify", just pass a different parameter at the next recursive call
22:19:44 <lightquake> wait, no, i can't use CDouble everywhere because netwire uses Double
22:20:21 <monochrom> imperative_factorial n = loop 1 0  where  { loop p i | i==n = p  | otherwise = loop (p*i) (i+1) }
22:20:44 <monochrom> ah, should not start with 0
22:21:04 <monochrom> @let imperative_factorial n = loop 1 1  where  { loop p i | i==n+1 = p  | otherwise = loop (p*i) (i+1) }
22:21:05 <lambdabot>  Defined.
22:21:14 <monochrom> > imperative_factorial 5
22:21:16 <lambdabot>   120
22:22:09 <monochrom> p and i are imperative variables. while i /= n+1, loop back but "change" p to p*i, "change" i to i+1
22:23:33 <hpaste> statusfailed pasted “writing safeToEnum” at http://hpaste.org/80238
22:23:40 <statusfailed> can anyone help me with that? ^
22:23:47 <statusfailed> scoped type variables doesn't seem to do what I thought
22:24:12 <dmwit> statusfailed: use more forall
22:24:28 <glguy> statusfailed: fromEnum $ minBound :: a   ==> fromEnum (minBound :: a), perhaps?
22:24:42 <elliott> statusfailed: you need "forall a."
22:24:45 <elliott> before the (Enum a
22:24:45 <statusfailed> glguy: I forgot to fix that, you're right, bu tit's not hte problem
22:24:45 <glguy> yes, and also add "forall" if you want the variable to be scoped
22:24:47 <elliott> but you also need what glguy said
22:24:58 <statusfailed> forall in the minBound bit?
22:24:59 <elliott> safeToEnum :: forall a. (Enum a, Bounded a, Ord a) => Int -> Maybe a
22:25:02 <statusfailed> ah, ok
22:25:04 <elliott> that's how scopedtypevariables works
22:25:31 <monochrom> I wonder why you need type annotations in the first place
22:25:36 <dmwit> It's a bit backwards from what you might expect if you grew up in the PL community, but it breaks fewer programs that way.
22:25:38 <statusfailed> oh *free* type variables to be reused
22:25:39 <statusfailed> heh
22:25:53 <croikle> some discussion of this problem: http://stackoverflow.com/questions/2743858/safe-and-polymorphic-toenum
22:25:54 <statusfailed> free meaning forall'd?
22:26:30 <statusfailed> croikle: clearly I didn't google well enough :D
22:26:54 <dmwit> statusfailed: No, forall'd variables are the bound ones.
22:27:26 <dmwit> (hence the "backwards from what you might expect" comment)
22:28:40 <statusfailed> dmwit: isn't that the opposite of what I have though? I have "forall a.", and have reused it in the function body
22:28:54 <shachaf> "forall" is like a lambda.
22:29:03 <shachaf> (\x -> ... (...x...) ...) works fine.
22:29:04 <dmwit> statusfailed: You might also like this trick: [mini_, maxi_, result] = [minBound, maxBound, toEnum i]; mini = fromEnum mini_; maxi = fromEnum maxi
22:29:25 <hpaste> glguy annotated “writing safeToEnum” with “fewer extensions” at http://hpaste.org/80238#a80239
22:29:29 <dmwit> no type annotations are necessary with such a trick
22:29:50 <glguy> dmwit: I wasn't reading chat when you wrote that :)
22:29:52 <dmwit> Ah, yes, glguy has posted the complete version of this. =)
22:29:57 <monochrom> I see why now
22:30:06 <glguy> You can use "asTypeOf" similarly
22:30:33 <dmwit> shachaf: It's not very like a lambda; the variable it binds isn't bound inside the forall, it's bound outside the forall. Sort of.
22:30:53 <dmwit> shachaf: It would be like writing (\x -> ...) (x + 3) and expecting those x's to be the same.
22:31:31 <statusfailed> dmwit, glguy: nice :D
22:31:35 <dmwit> statusfailed: I'm not sure I understood your latest question.
22:31:36 <glguy> it's like writing (\x -> …. where … x + 3) and expecting those x's to be the same
22:31:39 <fragamus_> is there a fold that would help me search a binary tree? (I have to apply a special function which determines which branch to follow)
22:31:48 <shachaf> dmwit: That's true.
22:32:13 <statusfailed> dmwit: basically, this page: http://www.haskell.org/haskellwiki/Scoped_type_variables seems to describe the type variable "a" in "forall a." as "free"
22:32:22 <fragamus_> am I stuck with explicit recursion
22:33:06 <monochrom> wait, "forall" is a quantifier, a binder, it makes variables bound not free
22:33:42 <statusfailed> monochrom: so the page is wrong? or am I reading it wrong
22:33:46 <dmwit> statusfailed: It allows you to take a free variable and bind it for reuse.
22:33:57 <statusfailed> oh... sorry, I get it
22:33:57 <dmwit> statusfailed: Before the forall appears, it's free; afterwards, it's bound.
22:34:04 <statusfailed> ok haha
22:34:10 <statusfailed> it has to be free to be used with forall
22:34:14 <croikle> fragamus: I think you should be able to do that
22:34:21 <statusfailed> cheers
22:34:59 <monochrom> it says "free" twice. the second instance is correct: "Legal, because b is now a free variable"
22:35:21 <monochrom> the first instance is incorrect.
22:35:59 <monochrom> consider this analogy: (\x -> x + x). is any x free there?
22:36:38 <monochrom> I can understand why the author miswrote. again consider an analogy:
22:36:41 <croikle> frag: for example, fold (\l r -> if (...) then l else r)
22:36:56 <monochrom> suppose I write x+x alone first. both x's are free.
22:37:21 <monochrom> later, I add "\x ->" before them. you can describe this act two ways:
22:37:31 <monochrom> 1. now the x's are bound
22:38:20 <monochrom> 2. I re-use free x's in the scope my lambda
22:38:53 <monochrom> the second way is better amended as: I re-use *previously* free x's in the scope of my lambda
22:39:14 <monochrom> they *were* free before I added "\x->". but that was the past. now they are bound
22:40:32 <monochrom> allow me to use a final analogy. if you have an ex-wife, you don't go around saying that she *is* your wife
22:40:53 <beaky> how do I use state within a  function and then return a pure value?
22:41:19 <elliott> runState/runST
22:42:50 <sw2wolf> :t isNormalFile
22:42:52 <lambdabot> Not in scope: `isNormalFile'
22:42:54 <dmwit> > runIO (do { v <- newIORef "foo"; readIORef v })
22:42:55 <lambdabot>   Not in scope: `newIORef'
22:42:55 <lambdabot>  Perhaps you meant `newSTRef' (imported from Data....
22:43:20 <sw2wolf> @hoogle isNormalFile
22:43:20 <lambdabot> No results found
22:43:26 <dmwit> > runIO (do { print "bar"; return "foo" })
22:43:28 <lambdabot>   "foo"
22:44:15 <beaky> wow runST works!
22:44:18 <beaky> but isn't that unsafe?
22:44:34 <mikeplus64> dmwit: oh dear
22:44:36 <dmwit> The whole point of ST is that no, it's not unsafe.
22:44:38 <croikle> sw2wolf: seems to exist inside some xmonad thing
22:44:50 <sw2wolf> croikle: yes
22:44:51 <c_wraith> beaky: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.144.2237 covers ST
22:44:55 <beaky> ah
22:44:59 <mikeplus64> @hoogle runIO
22:44:59 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
22:44:59 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
22:44:59 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
22:45:12 <beaky> also, what is the difference between IO and ST
22:45:17 <beaky> (and runIO and runST)
22:45:31 <c_wraith> The interfaces
22:45:34 <beaky> oh
22:45:35 <dmwit> ST can only read and write to memory. IO can do other things -- touch the disk, network, screen, etc.
22:45:43 <beaky> launch missiles ^^
22:46:00 <dmwit> Also, the difference between runIO and runST is that runST exists, and runIO is a figment of your imagination. =)
22:46:09 <monochrom> @type runIO
22:46:11 <lambdabot> t -> [Char]
22:46:13 <c_wraith> The implementations are identical, internally - but ST cleverly limits what you can do such that it can be externally pure
22:46:14 <beaky> < dmwit> > runIO (do { v <- newIORef "foo"; readIORef v })
22:46:18 <mikeplus64> dmwit: is that runIO you just used actually running IO in lambdabot?
22:46:20 <monochrom> @type print
22:46:21 <beaky> wow what's that
22:46:22 <lambdabot> Show a => a -> IO ()
22:46:28 <mikeplus64> > runIO ()
22:46:29 <dmwit> > runIO (do { print "foo"; return "the illusion breaks" })
22:46:30 <lambdabot>   "foo"
22:46:31 <lambdabot>   "foo"
22:46:35 <beaky> oh
22:46:36 <mikeplus64> :|
22:46:45 <beaky> so runIO is some lambdabot hack?
22:46:48 <dmwit> =D
22:46:52 <dmwit> runIO _ = "foo"
22:46:53 <c_wraith> no really
22:47:13 <beaky> lol
22:47:27 <croikle> @src runIO
22:47:27 <lambdabot> Source not found. It can only be attributed to human error.
22:47:38 <monochrom> @free t->String
22:47:38 <lambdabot> Extra stuff at end of line
22:47:48 <monochrom> @help free
22:47:48 <lambdabot> free <ident>. Generate theorems for free
22:48:16 <monochrom> @free fst
22:48:17 <lambdabot> f . fst = fst . $map_Pair f g
22:48:27 <dmwit> Perhaps ?free can only handle polymorphic types.
22:48:35 <monochrom> @free runIO
22:48:35 <statusfailed> monochrom: Those made sense- I liked your final analogy :D
22:48:36 <lambdabot> $map $id . runIO = runIO . f
22:48:48 <dmwit> oooooo
22:48:59 <`nand`> @free free
22:49:00 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `free'\n\n"
22:49:04 <dolio> free needs a name.
22:49:09 <`nand`> damn, didn't give me any insightful identities about itself
22:49:10 <dolio> And a type.
22:49:16 <dmwit> map id = id, therefore runIO = runIO . f
22:49:24 <dolio> Or just a name if it's defined wherever it's looking.
22:49:40 <covi> @hoogle IO (IOref a) -> IORef a
22:49:40 <lambdabot> Did you mean: IO (IORef a) -> IORef a
22:49:41 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
22:49:41 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
22:49:46 <monochrom> @free mine::t->String
22:49:47 <lambdabot> mine = mine . f
22:49:56 <dmwit> covi: Not gonna happen.
22:50:17 <covi> @hoogle IO (IORef a) -> IORef a
22:50:17 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
22:50:17 <lambdabot> Data.Foldable msum :: (Foldable t, MonadPlus m) => t (m a) -> m a
22:50:17 <lambdabot> Data.Generics.Aliases ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
22:50:34 <dmwit> You can go IO (IORef a) -> IO a, maybe.
22:50:39 <croikle> :t unsafePerformIO
22:50:41 <lambdabot> Not in scope: `unsafePerformIO'
22:50:53 <croikle> that would do it :)
22:51:09 <dmwit> :t join . (Data.IORef.readIORef <$>)
22:51:10 <lambdabot> IO (GHC.IORef.IORef a) -> IO a
22:51:22 <dmwit> err
22:51:31 <dmwit> :t (>>= readIORef)
22:51:33 <lambdabot>     Not in scope: `readIORef'
22:51:33 <lambdabot>     Perhaps you meant `readSTRef' (imported from Data.STRef)
22:51:39 <dmwit> :t (>>= readSTRef)
22:51:41 <lambdabot> ST s (STRef s b) -> ST s b
22:51:45 <covi> dmwit: ok. but can i do  a -> IORef a
22:51:58 <dmwit> covi: No, but you can do a -> IO (IORef a).
22:52:23 <covi> I need to sequence some operations, in order to get from a to IOref a
22:52:34 <dmwit> You can't get away with claiming you're not doing IO if you're mucking about with IORefs.
22:53:47 <dmwit> Bleh, if we're being pedantic, there are some things you can do with IORefs that don't need IO. But creating them, reading and writing to them, etc. are not among those things.
22:54:34 <dmwit> covi: Probably the next most helpful thing you can do is to tell us about one step back. What makes you think you need to go from a to IORef a?
22:59:09 <beaky> is there a flip to <$>?
23:00:14 <beaky> :t <$>
23:00:15 <lambdabot> parse error on input `<$>'
23:00:18 <beaky> :(
23:00:25 <monochrom> @type (<$>)
23:00:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:00:44 <beaky> @hoogle Functor f => f a -> (a -> b) -> f b
23:00:45 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
23:00:45 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
23:00:45 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
23:00:53 <beaky> probably not :(
23:01:57 <croikle> others have wished for one
23:02:47 <croikle> http://www.haskell.org/pipermail/libraries/2010-April/013403.html
23:05:39 <beaky> http://ideone.com/g44CxW I managed to get the imperative factorial in haskell. Anyone willing to criticize it? :D
23:06:15 <Fuuzetsu> but why
23:06:33 <beaky> I want to try imperative programming in haskell
23:06:42 <Fuuzetsu> see me previous question
23:06:47 <Fuuzetsu> my*
23:07:00 <beaky> I love imperative programming :D
23:07:19 <Fuuzetsu> you should probably be using an imperative language then
23:07:53 <beaky> but imperative languages lack haskell features like pattern matching, closures, higher-order functions, algebraic datatypes, lazy evaluation, referential transparency, etc.
23:08:03 <beaky> and monads :D
23:08:36 <Fuuzetsu> All those things make for a really nice _functional_ language features.
23:09:17 <beaky> they could be nice for a procedural language too
23:09:48 <dmwit> beaky: I wouldn't be surprised if this code stack overflows on largish inputs.
23:09:57 <beaky> hmm lets try
23:10:18 <beaky> with an input of 100000
23:10:23 <dmwit> You're building up a big ol' thunk in ans.
23:10:30 <beaky> right
23:10:44 <beaky> ah it didn't overflow :D
23:10:59 <beaky> but it ran slower than foldl' (*) 1 [1..100000]
23:12:12 * hackagebot HLearn-distributions 0.1.0.1 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-0.1.0.1 (MikeIzbicki)
23:12:14 * hackagebot Elm 0.7 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.7 (EvanCzaplicki)
23:14:01 <beaky> how do I optimize it
23:15:18 <croikle> $! is strict application
23:15:39 <croikle> if you'd like to keep the thunks down
23:18:26 <beaky> ah
23:18:29 <beaky> thanks that fixed it :D
23:19:22 <beaky> now it's fast
23:19:26 <beaky> as fast as C
23:22:08 <Nereid> yeah, it's easy to accidentally build up thunks in a STRef or similar.
23:22:12 * hackagebot elm-server 0.7 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.7 (EvanCzaplicki)
23:22:14 * hackagebot HLearn-algebra 0.1.0.1 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-0.1.0.1 (MikeIzbicki)
23:27:12 <lightquake> bleh
23:27:19 <hpaste> beaky pasted “imperative factorial” at http://hpaste.org/80242
23:27:24 <lightquake> my GLFW program is getting like… .012 seconds per frame
23:27:31 <beaky> any ways to further optimize the imperative factorial?
23:28:21 <croikle> > recip 0.012
23:28:23 <lambdabot>   83.33333333333333
23:28:36 <lightquake> that's when it's doing basically nothing, too
23:28:50 <`nand`> what about when it's doing something?
23:29:16 <lightquake> i mean, all it does is move a square, so same thing, but ideally i'd like it to be faster than that
23:36:42 <lightquake> wait, i think i know what it is
23:37:19 <lightquake> i think i'm running into resolution issues
23:38:48 <johnw> sm: ping
23:39:31 <nus> beaky, ($!) is irrelevant there, only the modifySTRef' change is
23:44:20 <lightquake> wait, no, i actually am getting a bad framerate :/
23:45:42 <lightquake> this is frustrating
23:46:15 <lightquake> actually wait
23:46:26 <lightquake> maybe i'm getting limited by the refresh rate of the LCD or something
23:46:51 <lightquake> that would make sense since i'm never seeing a 'framerate' higher than 60
23:48:49 <croikle> I was wondering about something like that
23:48:54 <lightquake> yeah
23:48:57 <lightquake> it has vsync enabled by default
23:49:03 <lightquake> so of course i can't get better than 60FPS
23:49:38 <croikle> how much do you get without vsync?
23:49:54 <lightquake> 3000
23:49:59 <croikle> nice
23:50:10 <lightquake> crisis averted
23:50:33 <croikle> 3000fps is so jerky, I can't stand it
23:51:11 <lightquake> yeah there's some weird jerkiness going on here
