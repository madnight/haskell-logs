00:00:01 <M30W> ?
00:02:49 <akamaus> M30W, please, elaborate a bit more.
00:03:10 <M30W> Are your luaCode just lines of lua code (String) ?
00:05:41 <akamaus> M30W, sort of. Actually, on the upper layer I use run_lua. http://hpaste.org/81518
00:05:57 <M30W> run_lua
00:05:58 <M30W> looks c
00:06:00 <akamaus> you see, it's just a call to a single function
00:06:12 <M30W> D: runLua CAMEL CASE!
00:07:16 <akamaus> M30W, it's just a humble worker, I don't export it :)
00:07:41 <M30W> Fix yo case!
00:07:51 <M30W> Haha, even hPaste is telling you :P
00:08:54 <M30W> concat ["'", T.unpack s, "'"]
00:08:56 <M30W> Pftt
00:09:50 <M30W> (("'" ++) . (++ "'")) T.unpack s
00:09:52 <M30W> :)
00:10:22 <akamaus> M30W, a questionable improvement :)
00:10:30 <M30W> :P
00:10:48 <M30W> It doesn't use concat for adding quotes. It's an imporvement :)
00:11:23 <M30W> luaRaw, this takes a string and evaluates it yea?
00:12:10 <M30W> concat ("return " : fun : "(" : intercalate ", " (map render_value args) : [")"])
00:12:30 <M30W> Look there, seems what you want to improve.
00:12:30 <akamaus> yeah, it sends it through socket, gets the results and converts them to haskell types.
00:12:36 <M30W> To take multiple lines
00:13:54 <akamaus> M30W, I already did it, I added luaRawMulti :: [LuaCode] -> m [[LuaValue]]
00:14:26 <akamaus> it takes a list of scripts sends them in one turn and collects all the results
00:14:40 <M30W> I see.
00:14:45 <M30W> What are you asking again?
00:14:49 <akamaus> now I'm thinking how to make use of it :)
00:15:09 <akamaus> I have a bunch of wrappers which use luaRaw
00:15:18 <M30W> Also.. akamaus `["return ", fun, "(", intercalate ", " (map render_value args), ")"] >>= id`
00:15:28 <M30W> who needs concat :3
00:16:36 <akamaus> M30W, I'm afraid this moves us closer to IOCCC coding style
00:16:49 <M30W> IOCCC? XD
00:16:59 <M30W> Love oc
00:17:19 <M30W> But dude, it's basicly the same thing ^_^
00:18:01 <M30W> akamaus: Better> ["return ", fun, "(", intercalate, ", ", map render_value args, ")"] >>= id
00:18:25 <M30W> wait..
00:18:29 <M30W> never mind back up
00:18:36 <akamaus> M30W, seems you like list monads :)
00:18:45 <M30W> akamaus: Better> ["return ", fun, "(", intercalate ", " (map render_value args), ")"] >>= id
00:18:48 <M30W> That works :P
00:19:10 <M30W> akamaus: No... Looks like I don't like concat :D
00:19:24 <akamaus> can I ask, why?
00:19:31 <M30W> More fun ^^^
00:19:55 <akamaus> it was quite readable, wasn't it?
00:19:59 <M30W> Also.. Control.Monad (join); join a = a >>= id
00:20:05 <M30W> It was.
00:20:41 <akamaus> M30W, Lets have fun by thinking how to parallelize that damn wrappers!
00:20:43 <M30W> Also.. I don't think you were even using concat therE?
00:20:54 <M30W> :D
00:22:10 <M30W> How was your concat acturally working there....
00:22:21 <M30W> "string" : "string" -- Not valid
00:22:46 * hackagebot postgresql-libpq 0.8.2.2 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8.2.2 (LeonSmith)
00:22:57 <M30W> @pl concat ("string" : "string")
00:22:57 <lambdabot> (join . ("string" :)) "string"
00:23:03 <M30W> O.o
00:23:39 <M30W> -XWhat?
00:23:41 <M30W> :P
00:27:02 <akamaus> M30W, I had a list as last element :)
00:27:09 <M30W> People... Why you all forget to reply to ping requests? D:
00:27:21 <M30W> akamaus: Oh ofc
00:27:23 <frerich> Hm, a while ago some people here were talking about how a function like 'a -> b' cannot be realized. Unfortnately it only later occurred to me that this kind of signature can easily happen if you partially apply some function, e.g. 'const 1' has the type 'Num a => b -> a'. So is it really correct to say 'a -> b' cannot be realized?
00:27:33 <M30W> Still crazy
00:27:44 <M30W> akamaus: You're not even using concat properally!
00:28:16 <shachaf> It's easy to write a function of type Num b => a -> b
00:28:23 <shachaf> Num lets you do that.
00:28:44 <akamaus> @pl concat ("a":"b":"ccc":["zzz"])
00:28:44 <lambdabot> join ["a", "b", "ccc", "zzz"]
00:28:54 <PatrickRobotham> You want forall a. forall b. a -> b
00:29:06 <M30W> akamaus: join a = a >>= id
00:30:36 <akamaus> M30W, so what? :) these a interchangeable definitions. But let me show you this: http://hpaste.org/81519. Take a look at getValues.
00:31:40 <akamaus> M30W, I'd like to be able to parallelize such kind of computations. You see, there is no data dependencies between individual calls
00:32:04 <M30W> akamaus: don't give hpaste links with a dot after -_-
00:33:53 <M30W> akamaus: I don't see why you can't just merge all the commands into a sequence of code which acturally does the running of the lua
00:34:21 <M30W> Maybe modify the existing library so you can wrap it with better code then trying to work around the existing library
00:34:36 <M30W> (Suggest a patch upstream to allow that library to do such exportable)
00:34:43 <M30W> If not already.
00:36:19 <M30W> Lenin[Away]: Automatic status messages? Don't: http://sackheads.org/~bnaylor/spew/away_msgs.html
00:37:34 <akamaus> M30W, I need to get the result, so I can't just glue them together.  Moreover, the actual use case is a bit more involved.  Istead of getValue I have a function with one call to run_api and a bunch of post processing, which can be expressed as pure compuration.
00:38:04 <akamaus> And I want to be able to compose it, both in sequential and parallel forms.
00:38:16 <M30W> akamaus: What you have -> want. Wrapper to give the return values to stdout?
00:38:46 <M30W> akamaus: Gimmeh more source
00:38:48 <M30W> :)
00:41:32 <akamaus> M30W, lets rephrase. I want to be able to write computations like getValues which exploit the ability to run a bunch of independent subcomputations like getValue in one turn. But sometimes, in case they have data dependency, I also need to sequence them. Probably I'm looking for a more restricted structure than Monad.
00:42:47 <M30W> So... ["code","code"] -> [result,result]
00:43:31 <M30W> or ["has output", "no output"] -> [Just "some output", Nothing]
00:43:38 <M30W> ?
00:44:01 <akamaus> M30W, I recently added it, luaRawMulti :: [LuaCode] -> m [[LuaValue]]. But after that I realized I can't use it in the current framework
00:44:57 <jbu> hi all: if I have an anonymous function (\a b -> b ++ [a]), will it be ok with me passing in a list as parameter b?  how does the anonymous function know that b could or should be a list?
00:45:06 <akamaus> ..without doubling  all the intermediate levels
00:46:17 <akamaus> jbu, you have to pass list as b. The compiler looks at signature of (++) and determines types of operands
00:46:41 <edwardk> :t \a b -> b ++ [a]
00:46:42 <lambdabot> t -> [t] -> [t]
00:47:01 <jbu> oh wow cool
00:48:12 <jbu> thanks, I think looking at its type helps me understand what the compiler is doing
00:57:22 <M30W> LOL! Working on a text adventure game; Terns out I know the map too much to ask for it to fail on me ;) Explored the whole map then attempted to do a direction I couldn't go and yay game over. :P
00:57:43 <hpaste> basdirks pasted ‚ÄúIs this considered a hack?‚Äù at http://hpaste.org/81520
00:57:47 * hackagebot language-lua 0.1.6 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.1.6 (OmerAgacan)
00:57:49 <M30W> Ilegal movement. how did I forget? :P
00:58:47 <M30W> @ping
00:58:47 <lambdabot> pong
00:59:53 <shachaf> basdirks: You could probably use lists or something.
01:00:09 <shachaf> lmerge [real_2, period, real_2)
01:00:12 <shachaf> s/.$/]/
01:00:22 <basdirks> probably yes, I'll try that
01:05:12 <basdirks> hm got any pointers on the how?
01:10:22 <basdirks> I can't put Parsers of different types in a list
01:11:35 <shachaf> Oh.
01:11:40 <shachaf> Then maybe it doesn't work.
01:12:09 <basdirks> I don't think so either
01:12:14 <shachaf> You can have a list like [foo a, foo b, foo c]?
01:12:26 <shachaf> Maybe foo is lifted.
01:13:11 <basdirks> I could lift the Parsers into a class
01:13:22 <basdirks> but that would get messy
01:20:47 <TravisD> Hi. Is there a must-read Haskell book for people with programming background but new to FP?
01:21:07 <TravisD> I'm also interested in there being a nice PDF available. I'm happy to pay
01:21:47 <basdirks> you mean like a book for one-legged football players?
01:22:08 <mrout> basdirks: if this was reddit, you'd be straight onto /r/nocontext
01:22:09 <PatrickRobotham> TravisD: Real World Haskell?
01:22:33 <mmarabillas> is Haskell obsolete/useless?
01:22:45 <PatrickRobotham> mmarabillas: It's certainly not obsolete!
01:22:57 <slack1256> also I don't know any language obsolete
01:23:08 <slack1256> I even get paid for maintain old cobol code
01:23:35 <basdirks> TravisD: do you know "Learn You A Haskell (for great good)"?
01:23:48 <jesyspa> slack1256: PDP-9 assembler?  Although someone somewhere probably still uses one...
01:23:53 <shachaf> TravisD: _Programming in Haskell_ is good.
01:23:53 <TravisD> basdirks: I looked at it a little while ago
01:24:16 <basdirks> I second shachaf's suggestion
01:24:23 <shachaf> I really like it as an introduction to Haskell, but most people prefer to recommend the ones that are free online.
01:24:46 <mrout> basdirks: what was the "one-legged football players" comment about?
01:24:54 <mrout> a book for one-armed coders or something?
01:25:31 <slack1256> jesyspa: we could say that language when languages graduates. they go to "maintenance mode"
01:25:42 <slack1256> is like... college life ;_;
01:27:45 <pharaun> this is probably a silly question, but is there any good pre-existing pattern/library for "restricted" IO monads?
01:27:48 * hackagebot markdown 0.1.2 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.2 (MichaelSnoyman)
01:27:54 <pharaun> like file only io, network only IO, etc..
01:28:03 <basdirks> mrout I was poking fun at the potential handicap of having a "programming background" but being new to FP, it wasn't a very useful remark
01:28:19 <basdirks> it comes from personal experience though
01:28:22 <mmarabillas> ermergherd! why so many haskell chatters..
01:28:43 <mrout> basdirks: hahaha, I like that.
01:28:44 <mrout> clever
01:29:03 <slack1256> mmarabillas: aparently #haskell is one of the busiest channel on freenode :-)
01:29:29 <mrout> slack1256: probably because Haskell is hard to many people.
01:29:42 <basdirks> everyone wants to play football
01:29:51 <srhb> pharaun: Have you read the restricted IO section in the GHC manual_
01:30:29 <slack1256> mrout: at least there is interest
01:30:44 <pharaun> srhb: 7.23.1.2 (building secure system (restricted io monads)
01:30:52 <pharaun> )
01:30:52 <srhb> pharaun: Right.
01:31:20 <pharaun> srhb: yeah i've read it, was just wondering if there was already some pre-existing ones if not its np for me to do this :)
01:31:22 <mrout> slack1256 :)
01:31:43 <pharaun> srhb: it was mostly for my API, wanted to make it so it could interop with other libraries if possible than just spawning my own type
01:32:27 <pharaun> easy enough to implement my own anyway so i guess i'll just go do that :)
01:32:47 <srhb> pharaun: Right right. :)
01:53:21 <slack1256> @type lift
01:53:23 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
01:53:46 <slack1256> @type (do {you <- even; lift})
01:53:48 <lambdabot> (Integral (m a), Monad m, MonadTrans t) => m a -> t m a
01:54:30 <merijn> :t do you even lift
01:54:32 <lambdabot> Not in scope: `you'
01:54:42 <merijn> :t let you = undefined in do you even lift
01:54:43 <lambdabot>     Ambiguous type variable `t0' in the constraint:
01:54:43 <lambdabot>       (MonadTrans t0) arising from a use of `lift'
01:54:43 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
01:55:29 <slack1256> yeah, lambdabot doesn't share the notation of ghci
01:56:34 <Cale> slack1256: hm?
01:56:48 <slack1256>  as in @type instead of :t
01:56:52 <Cale> :t even
01:56:54 <lambdabot> Integral a => a -> Bool
01:56:59 <Cale> Sure it does ;)
01:57:10 <Cale> @type won't work in ghci though
01:57:11 <lambdabot> parse error on input `in'
01:57:46 * slack1256 reached enlightenment
01:57:54 <Itkovian> congrats
02:01:50 <merijn> Hell, even :i
02:01:53 <merijn> :i Maybe
02:02:03 <merijn> Ha, way to botch that :)
02:02:23 <slack1256> @info Maybe
02:02:23 <lambdabot> Maybe
02:02:29 <slack1256> heh
02:02:40 <wuttf> ieee754-0.7.3 ... <interactive>: m: Module can't be found, Anyone has experienced this on GHCi and Win?
02:02:47 <merijn> I was sure :i used to work in lambdabot?
02:02:49 <shachaf> mikeplus64 is working on a Haskell evaluation thing that's way faster than mueval, and better.
02:02:54 <shachaf> merijn: Never worked.
02:03:40 <wuttf> I found this thread: http://hackage.haskell.org/trac/ghc/ticket/3242, but none of the solutions worked for me, I cant find mingwex.dll on my machine.
02:08:24 <mrbungle> is read considered evil like eval is in python?
02:08:34 <shachaf> read is very different from eval
02:08:41 <shachaf> eval executes code; read just parses.
02:08:59 <mrbungle> ok
02:10:11 <fmap> mrbungle: read is considered evil but not the way eval is
02:10:45 <slack1256> the idea for read is was to provide cheap serialization with show
02:10:58 <slack1256> ideal world "read . show = id"
02:11:04 <sopvop> is there something in Control.Lens. like (^.) for cases like   `view (foo.bar) <$> f) ?
02:11:51 <Taneb> f & traverse %~ (foo . bar)
02:11:59 <sopvop> thanks
02:12:05 <shachaf> mapped, not traverse
02:12:13 <shachaf> Well, traverse will work whenever it type-checks.
02:12:13 <Taneb> Yeah
02:12:20 <Taneb> But mapped is more general
02:12:27 <shachaf> Wait, that doesn't work.
02:12:34 <shachaf> foo.bar is a lens.
02:12:37 <sopvop> yes
02:13:09 <shachaf> I don't think we have that operation. Seems a bit specialized?
02:13:36 <Taneb> Getter s a -> f s -> f a
02:13:58 <Taneb> (Functor f)
02:14:14 <srhb> I just had a brainmelt How do I zip a list of lists with coordinates, ie. first element of first list is (1,1) , next of first is (2,1) etc. The inner lists may have different lengths.
02:16:50 <shachaf> > zipWith (\i l -> zipWith (\j x -> ((i,j),x)) [0..] l) [0..] ["hello","there"] -- the obvious thing is a bit ugly
02:16:52 <lambdabot>   [[((0,0),'h'),((0,1),'e'),((0,2),'l'),((0,3),'l'),((0,4),'o')],[((1,0),'t')...
02:17:17 <srhb> No, thanks, that was exactly what I was trying to get at.
02:17:38 <SamanthaD> hey everyone
02:17:52 <merijn> map (\(i,x) -> map (\(j,y) -> ((i,j), y)) . zip [1..] . map (zip [1..])
02:17:55 <shachaf> > [(i,j,x) | (i,l) <- zip [0..] ["hello", "there"], (j,x) <- zip [0..] l]
02:17:57 <lambdabot>   [(0,0,'h'),(0,1,'e'),(0,2,'l'),(0,3,'l'),(0,4,'o'),(1,0,'t'),(1,1,'h'),(1,2...
02:18:25 <merijn> > map (\(i,x) -> map (\(j,y) -> ((i,j), y)) . zip [1..] . map (zip [1..]) $ ["hello", "there"]
02:18:27 <lambdabot>   <hint>:1:93: parse error (possibly incorrect indentation)
02:18:30 <merijn> awww
02:18:39 <merijn> > map (\(i,x) -> map (\(j,y) -> ((i,j), y))) . zip [1..] . map (zip [1..]) $ ["hello", "there"]
02:18:39 <shachaf> The list comprehension looks nicest to me so far.
02:18:41 <lambdabot>   No instance for (GHC.Show.Show ([(t2, t0)] -> [((t1, t2), t0)]))
02:18:41 <lambdabot>    arising...
02:19:07 <merijn> > map (\(i,x) -> map (\(j,y) -> ((i,j), y)) x) . zip [1..] . map (zip [1..]) $ ["hello", "there"]
02:19:10 <lambdabot>   [[((1,1),'h'),((1,2),'e'),((1,3),'l'),((1,4),'l'),((1,5),'o')],[((2,1),'t')...
02:19:13 <merijn> There we go
02:19:28 <merijn> Or did you want to flatten them too
02:19:36 <srhb> Nah, that's fine.
02:19:37 <merijn> > concatMap (\(i,x) -> map (\(j,y) -> ((i,j), y)) x) . zip [1..] . map (zip [1..]) $ ["hello", "there"]
02:19:40 <lambdabot>   [((1,1),'h'),((1,2),'e'),((1,3),'l'),((1,4),'l'),((1,5),'o'),((2,1),'t'),((...
02:19:48 <merijn> You can probably refactor it a bit nicer
02:19:55 <shachaf> > join [[(i,j,x) | j <- [0..] | x <- l] | i <- [0..] | l <- ["hello", "there"]]
02:19:57 <lambdabot>   [(0,0,'h'),(0,1,'e'),(0,2,'l'),(0,3,'l'),(0,4,'o'),(1,0,'t'),(1,1,'h'),(1,2...
02:21:10 <merijn> srhb: I think the "best" approach is to get the second index by just "map (zip [1..])", the first coordinate is then map each list's index and combining (sounds like it needs more lens!)
02:21:23 <srhb> MOAR LENS. :P
02:21:52 <mrbungle> moar everything!
02:22:02 <shachaf> moar monoids plz
02:22:03 <hpaste> SamanthaD pasted ‚ÄúGuards in case expression question.‚Äù at http://hpaste.org/81524
02:22:04 <shachaf> i love monoids
02:22:05 <shachaf> they are so easy
02:22:35 <shachaf> SamanthaD: The _ is indented too far.
02:22:42 <shachaf> All the cases have to be indented the same amount.
02:22:46 <shachaf> Delete one space and it works. :-)
02:23:07 <SamanthaD> shachaf: Oy... you're right >.<
02:23:32 <shachaf> I'm always right.
02:23:35 <shachaf> Just ask Taneb.
02:24:05 <SamanthaD> shachaf: Thanks. I've been indenting my wildcards to match up with my variables just out of some weird stylistic bug up my shorts.
02:24:13 <ithinktoomuch> How do you make sense out of this? -  :: [Int] -> [[a] -> [a]]
02:24:31 <Taneb> What are people asking me?
02:24:55 <Taneb> Oh, lenses everywhere
02:24:58 <Taneb> A very good idea
02:25:04 <shachaf> ithinktoomuch: It's a function that takes a list of Ints and returns a list of functions.
02:25:10 <shachaf> Each of those functions takes a list and returns a list.
02:25:14 <ithinktoomuch> the type is a func from list of ints to a list of functions which take a list and return a list, right?
02:25:18 <SamanthaD> shachaf: I read, though, on some StackExchange post that it's bad style to write code like I did where you have guards before a pattern match in a case expression. Until you pointed it out I figured it was just because it wouldn't WORK but now I'm puzzled. Is there any truth to that?
02:25:19 <ithinktoomuch> ohhh
02:25:57 <shachaf> SamanthaD: Seems OK to me.
02:26:06 <ithinktoomuch> @shachaf: and each of those list of funcs take in a list and return a list, right?
02:26:06 <lambdabot> Unknown command, try @list
02:26:19 <SamanthaD> shachaf: Me too! I happen to think the style is rather elegant myself. Anyway, thanks for your help!
02:26:49 <Taneb> :t getAny .:  foldMap (Any .)
02:26:51 <lambdabot> (Functor g, Foldable t, Monoid (g Any)) => t (g Bool) -> g Bool
02:27:03 <Taneb> :t getAny .:  foldMap (Any Prelude..)
02:27:05 <lambdabot> Foldable t => t (a -> Bool) -> a -> Bool
02:27:13 <shachaf> ithinktoomuch: Correct.
02:27:22 <shachaf> ithinktoomuch: It's a pretty strange type.
02:27:53 <ithinktoomuch> @shachaf: yes, I am just trying out some things. it is strange as it is the output of  :t map drop
02:27:53 <lambdabot> Unknown command, try @list
02:28:08 <ithinktoomuch> ofcourse i dont know what it means or where i would use it.
02:28:21 <ithinktoomuch> I was just trying some exercises to udnerstand types
02:28:30 <danr> > [ b | Just a <- [Nothing,Just () | b <- [0,1] ] -- I would have expected [1] here, isn't this a bit weird?
02:28:31 <lambdabot>   <hint>:1:34: parse error on input `|'
02:28:40 <danr> > [ b | Just a <- [Nothing,Just ()] | b <- [0,1] ] -- I would have expected [1] here, isn't this a bit weird?
02:28:42 <lambdabot>   [0]
02:28:53 <danr> til a quirk of parallell list comps
02:29:32 <shachaf> danr: I think the different parts are processed entirely independently.
02:29:51 <chord> who is still here?
02:30:03 <shachaf> There is only silence and some second-hand clothes.
02:30:07 <merijn> chord: About 974 people...
02:30:20 <shachaf> merijn: But how many of them take bait?
02:30:26 <chord> I still think that Go language is underrated
02:31:01 <frerich> ;-)
02:31:02 <bitonic> chord: this is a channel about another programming language, Haskell
02:31:08 <danr> shachaf: yeah so it seems. but for me it's (or was) a bit counterintuitive
02:31:15 <sebzim4500> > 1 + 2
02:31:17 <lambdabot>   3
02:31:40 <chord> bitonic: so you admit that Go is underrated
02:32:02 <bitonic> chord: I didn‚Äôt say anything about Go, and this is not the right place to talk about Go
02:32:10 <merijn> chord: Trolling is not very appreciated
02:32:12 <vhz> bitonic: don't feed the troll :)
02:32:25 <sebzim4500> > length $ filter (\x -> x % 2 == 0) [1 .. 10]
02:32:26 <lambdabot>   Not in scope: `%'
02:32:26 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
02:32:37 <sebzim4500> > length $ filter (\x -> x `mod` 2 == 0) [1 .. 10]
02:32:39 <lambdabot>   5
02:32:43 <sebzim4500> > length $ filter (\x -> x `mod` 2 == 0) [1 .. 1000]
02:32:44 <lambdabot>   500
02:32:49 <sebzim4500> > length $ filter (\x -> x `mod` 2 == 0) [1 .. 100000]
02:32:51 <lambdabot>   50000
02:32:54 <sebzim4500> > length $ filter (\x -> x `mod` 2 == 0) [1 .. 100000000]
02:32:58 <lambdabot>   mueval-core: Time limit exceeded
02:33:27 <plhk> > map ($ [1,2,3]) $ map drop [1,2]
02:33:29 <lambdabot>   [[2,3],[3]]
02:33:38 <plhk> ithinktoomuch: ^
02:34:12 <sebzim4500> @list
02:34:12 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:34:16 <sebzim4500> @pointfree
02:34:16 <lambdabot> Unknown command, try @list
02:34:20 <sebzim4500> @pointfull
02:34:20 <lambdabot> ()
02:34:32 <sebzim4500> @help
02:34:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:34:40 <sebzim4500> @help pointfull
02:34:40 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:34:42 <chord> bitonic: so whats your opinion of Go in relation to Haskell?
02:34:44 <sebzim4500> @help pointful
02:34:44 <lambdabot> pointful <expr>. Make code pointier.
02:35:09 <sebzim4500> pointful test x y = x y
02:35:51 <ithinktoomuch> map (+1) [1..3]
02:35:58 <ithinktoomuch> > map (+1) [1..3]
02:36:01 <lambdabot>   [2,3,4]
02:36:29 <ithinktoomuch> @plhk : couldnt understand that, maybe I still dont get the $ sign
02:36:29 <lambdabot> (line 1, column 1):
02:36:29 <lambdabot> unexpected ":"
02:36:29 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
02:38:50 <Taneb> :t alaf Any foldMap
02:38:52 <lambdabot> Foldable t => (r -> Bool) -> t r -> Bool
02:42:34 <kennyd> > map ($ 0) [(+1), (+2)]
02:42:36 <lambdabot>   [1,2]
02:42:49 * hackagebot websockets 0.7.2.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.7.2.1 (JasperVanDerJeugt)
02:43:34 <kennyd> > ($ 1) (+ 10)
02:43:35 <lambdabot>   11
02:49:46 <mason2> I need something to take a screenshot, save/load images, and access them at pixel level. is there anything more lightweight I could use instead of a full blown GUI library like GTK?
02:51:24 <Entroacceptor> you could just outsource the screenshotting
02:52:48 <frerich> kennyd: The best use case I found for mapping '$ something' over a list is when trying to decide whether some value satisfies a range of predicates (i.e. a 'satisfiesAll :: a -> [a -> Bool] -> Bool' with 'satisfiesall x = and . map ($ x)'.
02:53:42 <frerich> mason2: On which operating systems do you need this?
02:55:36 <mason2> frerich: I would prefer if it was portable since the rest of my program is (linux, osx, win)
02:58:29 <vhz> mason2: you could use juicypixel for load/save/access, but for taking the screenshot there's no portable solution that i can think of
03:24:56 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù pasted ‚ÄúFermat factoring‚Äù at http://hpaste.org/81525
03:27:50 * hackagebot aws-sdk 0.9.4 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.9.4 (YusukeNomura)
03:37:40 <msxx> how can I get 'source' link on the generated haddock documentation?
03:38:25 <Taneb> cabal install whatever --haddock-hyperlink-source
03:38:37 <Taneb> (you need HsColour installed)
03:40:42 <fmap> (no, you can't add this somewhere in cabal config)
03:53:37 <shachaf> bitonic: Sometimes ImplicitParams can act like holes.
03:54:21 <bitonic> shachaf: no but I miss making a hole, typing function, pressing C-c C-r, and then keep filling in the arguments
03:54:25 <HugoDaniel> hi
03:54:27 <HugoDaniel> in attoparsec
03:54:32 <HugoDaniel> im constantly doing this: http://hpaste.org/81526
03:54:38 <bitonic> shachaf: while looking at the context
03:54:50 <HugoDaniel> is there any way to consume the last matched char but not putting in the result ?
03:54:54 <shachaf> It's not ideal but it's much better than nothing.
03:55:12 <bitonic> even if the only legacy of Agda will be of having thought the world how useful holes are, that‚Äôll be enough
03:55:33 <bitonic> although probably Epigram is probably what started it
03:56:46 <donri> HugoDaniel: are you looking for <* ?
03:58:14 <donri> oh, you're not. but it would help
03:59:08 <quicksilver> pretty sure it was epigram, bitonic
03:59:22 * quicksilver saw pigworker do a talk on it a decade ago
03:59:25 <bitonic> quicksilver: yeah
03:59:34 <bitonic> I guess that Agda is what popularised it
04:00:04 * shachaf likes the idea of Agda "popularizing" something.
04:00:30 <quicksilver> "Sense and Sensibility (A Pragmatic Approach to Dependently Typed Programming)" http://www.cs.nott.ac.uk/~gmh/appsem03.html
04:00:59 <quicksilver> e.g. http://www.cs.nott.ac.uk/~gmh/appsem-slides/mcbride/image08.png
04:01:05 <quicksilver> now that's what I call technology.
04:01:15 <donri> aren't holes in agda much more powerful (emacs integration) than -XTypeHoles?
04:01:17 <bitonic> shachaf: as far as programming languages go Agda is pretty popular
04:01:33 <osfameron> it is?
04:01:52 <bitonic> quicksilver: the whole ‚Äòcombinator‚Äô approach to refinement has its disadvantages
04:02:01 <bitonic> but it is pretty sexy
04:03:25 <bitonic> in the end I think that a straight pattern-matching-structural-recursion approach is more realistic
04:05:13 <Mon_Ouie> -
04:05:17 <bitonic> but I‚Äôd like to use a programming languages that uses it before judging :P.  maybe I should try to install epigram someday
04:05:19 <Mon_Ouie> (Sorry.)
04:08:31 <bitonic> that would probably be an interesting exercise in software archaeology...
04:09:55 <gspr> Can hsc2hs generate peek/poke etc for nested structs when then the "inner" struct isn't declared separately anywhere? If I have something like  struct {int x;} foo;  struct {struct foo s;} bar;, then it's easy but what if I just have struct {struct {int x;} foo;} bar;?
04:16:12 <mm_freak> where is -XTypeHoles?  do i need GHC HEAD for that one?
04:16:19 <shachaf> Yes.
04:16:23 <mm_freak> too bad
04:16:28 <shachaf> Or just wait a couple of weeks for GHC 7.8 to come out?
04:16:37 <hiptobecubic> 7.8 already?
04:16:43 <hiptobecubic> I'm still not on 7.6
04:16:47 <shachaf> "We plan to release 7.8 in mid Feb, and then have a TH upheaval shortly thereafter (I hope). So let‚Äôs put this in afterwards."
04:16:55 <shachaf> Unless he means 2014.
04:16:57 <shachaf> I hope not.
04:17:15 <mm_freak> alright then
04:17:24 <msxx> are there any breaking changes between 7.4 and 7.6? where can you look it up?
04:17:34 <donri> is that suggesting we might get typed TH in 7.10? pretty please?
04:17:55 <hiptobecubic> I thought the main problem in migrating to 7.6 was one of libraries. I would guess that's resolved by now
04:18:28 <nomeata> hiptobecubic: still not every library on hackage builds with ghc 7.6. but most do.
04:18:55 <msxx> why not, what was changed?
04:19:24 <nomeata> msxx: version bumps of core libraries :-)
04:19:33 <nomeata> msxx: and FFI changes (not all types are valid there any more)
04:19:44 <donri> type operator incompat, directory using new time instead of old-time
04:19:46 <nomeata> msxx: and Bits does no longer imply Num and Eq
04:20:11 <shachaf> Are monoids still easy in 7.6?
04:20:21 <typoclass> shachaf: never been easier
04:20:31 <hiptobecubic> why would monoids be hard suddenyl?
04:20:33 <shachaf> typoclass: good. i love monoids
04:20:37 <hiptobecubic> and suddenly*
04:21:03 <donri> 'mdo' is now syntax for mappend! ok not really!
04:21:13 <nomeata> shachaf, typoclass: admit it, that conversation was just an attempt to get into HWN‚Äôs quotes section :-)
04:21:35 <hpaste> basdirks pasted ‚Äúshachaf, turns out I was looking for something like this.‚Äù at http://hpaste.org/81527
04:23:03 <shachaf> nomeata: Not on my part. I'm in HWN too much as it is.
04:23:41 <shachaf> basdirks: pConc doesn't mention the class at all.
04:23:54 <shachaf> It looks like it's just being used at one instance.
04:24:03 <shachaf> @quote nomeata
04:24:03 <lambdabot> nomeata says: Ah, it seems Iím creating a tuple with more than 62 elements somewhere..
04:24:09 <shachaf> @quote nomeata
04:24:10 <lambdabot> nomeata says: Haskell is basically Swiss: Small, Efficient, and it's fun to explore the higher parts.
04:24:25 <shachaf> @quote nomeata
04:24:25 <lambdabot> nomeata says: Ah, it seems Iím creating a tuple with more than 62 elements somewhere..
04:24:34 <nomeata> these are very old indeed
04:24:44 <shachaf> You aren't in here much recently.
04:24:59 <nomeata> IRC generally
04:25:40 <shachaf> monochrom: You used to be monotonom?
04:26:07 <arcatan> oh, is HWN going once again?
04:26:59 <shachaf> Occasionally.
04:27:44 <arcatan> HOC
04:27:57 <M30W> Hello; Could anyone here tell me a cleaner way to get this to work? getLine >>= \a -> case (x a) of Just r -> ...; Nothing -> print "Game over"
04:28:34 <M30W> I've tried a few things inside the case such as case (getLine >>= x) etc but won't typecheck cause it thinks it's expecting IO instead of maybe.
04:29:00 <basdirks> shachaf: you're right
04:29:09 <basdirks> lemme fix
04:29:11 <ocharles> M30W: you probably want the 'maybe' function
04:29:30 <M30W> ocharles: hmm
04:30:06 <M30W> ocharles: ?
04:30:08 <ocharles> getLine >>= maybe (print "Game over") (\r -> do something with r) . x
04:30:19 <ocharles> is one option
04:30:20 <M30W> Ooo.
04:30:31 <ocharles> As is, x <$> getLine >>= maybe (print "Game over") (\r -> ...)
04:30:40 <M30W> ah
04:30:43 <M30W> <$>
04:30:51 <ocharles> (or fmap x getLine >>= maybe ...)
04:31:53 <tdammers> or liftM
04:32:27 <nomeata> M30W: with GHC 7.6 and -XLambdaCase you can also write "getLine >>= (\case Just r -> ...; Nothing -> print "Game over") . x"
04:32:42 <shachaf> LambdaCase syntax is so ugly. :-(
04:33:05 <tdammers> lambdas in general feel dirty to me, in haskell at least
04:33:42 <M30W> shachaf: Lambdacase works but yea; looks a little ugly
04:33:54 <arcatan> lambdacase is there? i was looking for it last month and couldn't find it
04:33:59 <ocharles> nomeata: but that's still horrible
04:34:06 <ocharles> it doesn't really solve anything here :)
04:34:11 <arcatan> although hmm, i guess i'm still on GHC 7.4.2
04:34:16 <typoclass> didn't they have a discussion the other day which came up with some neat ideas for better syntax?
04:34:29 <ocharles> "the other day"? try "every day"
04:34:29 <ocharles> :P
04:34:37 <M30W> if only getLine >>= case x of worked :P
04:34:46 <nomeata> ocharles: better? "getLine >>= return . x >>= (\case Just r -> ...; Nothing -> print "Game over")"
04:34:46 <ocharles> it does, that's what lambda case is
04:34:55 <M30W> Well.
04:34:56 <M30W> Meh
04:35:08 <ocharles> nomeata: no, still worse. `maybe` is the right way to deal with this, or perhaps MaybeT
04:35:24 <M30W> @src (<$>)
04:35:24 <lambdabot> f <$> a = fmap f a
04:37:36 <ocharles> M30W: If you have lots of places where Maybe comes in, and you want to turn the Nothing's into (print "Game over"), it sounds like you want MaybeT
04:37:56 <ocharles> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Control-Monad-Trans-Maybe.html
04:38:03 <M30W> ocharles: Hehe... I have lots of maybe's atm :)
04:38:25 <M30W> Can't click link til I rebook :|
04:40:53 <donri> return x `ap` getLine >>= \mr -> do r <- mr; ... `mplus` liftIO (print "Game Over") -- best solution yet!
04:41:15 <M30W> ...
04:41:28 <M30W> getLine >>= \c -> case x c of so far the best haha
04:41:45 <donri> nah 'maybe' is your friend
04:42:02 <M30W> Acturally good point ocharles said that too.
04:42:06 <ocharles> several times
04:42:09 <donri> :)
04:42:15 <M30W> Hehe
04:42:20 <ocharles> the problem with using case is you will rapidly have walking indentation
04:42:37 <ocharles> and that's a smell - that should count as code duplication
04:43:08 <donri> fromJust `catch`
04:43:12 * donri runs and hides again
04:43:27 * typoclass yells in the direction of donri
04:44:46 <M30W> fmap x getLine >>= maybe (game mr rx) (\d -> game (go r rx d) rx)
04:44:47 <M30W> Winning
04:44:52 <M30W> <$>
04:45:41 <ocharles> hm
04:46:34 <ocharles> x <$> getLine >>= flip game rx . maybe mr (go r rx)
04:46:36 <ocharles> but I hate flip :|
04:46:41 <donri> needs moar =<<
04:47:21 * ocharles applies ocharles to eatBurrito
04:47:26 <ocharles> bbiab!
04:47:27 <M30W> Hehe
04:47:52 <M30W> @pl x <$> getLine >>= maybe (game mr rx) (\d -> game (go r rx d) rx)
04:47:52 <lambdabot> maybe (game mr rx) (flip game rx . go r rx) =<< x <$> getLine
04:48:24 <ocharles> that's basically what I wrote, except I factored (game _ rx) out
04:49:27 <M30W> More or less
04:50:39 <M30W> Hmmm
04:50:53 <M30W> Larger problem now.
04:51:04 <M30W> go c rx d = maybe (Just c) (\r -> M.lookup d (rDirections r)) (M.lookup c rx)
04:51:19 <M30W> If the lookup returns Nothing I want Just c
04:54:01 <hpaste> killy9999 pasted ‚ÄúGuard in Either monad?‚Äù at http://hpaste.org/81529
04:54:04 <M30W> maybe (Just c) Just (M.lookup c rx) -- :(
04:54:16 <killy9999> Is there a way to do a guard in Either monad?
04:54:25 <killy9999> the pasted code is obviously wrong
04:54:33 <killy9999> but I think it shows the intention
04:54:48 <donri> Just $ fromMaybe c (M.lookup ..) -- ?
04:54:53 <Cale> killy9999: You could always just use if/then/else with Left and Right
04:55:12 <killy9999> Cale: I know, but I was trying to think of a way to avoid it
04:55:35 <killy9999> I wanted the code to be more idiomatic i.e. less understandable for beginners :)
04:55:45 <donri> M30W: although it seems odd you want to use Maybe without Nothing
04:55:49 <Cale> Well, you can factor that out...
04:56:00 <M30W> @hoogle fromMaybe
04:56:00 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
04:56:45 <|||tux||> go c rx d = ((M.lookup c rx) >>= (\r -> M.lookup d (rDirections r)) <|> Just c ?
04:56:46 <M30W> donri: Didn't work?
04:57:14 <M30W> @hoogle (<|>)
04:57:14 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
04:57:14 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
04:57:14 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
04:57:28 <|||tux||> > Nothing <|> Just 3
04:57:29 <lambdabot>   Just 3
04:57:42 <|||tux||> > Just 3 <|> Just 4
04:57:44 <lambdabot>   Just 3
04:58:33 <M30W> Yea
04:59:16 <hiptobecubic> > Sum 1 <|> Sum 2
04:59:18 <lambdabot>   No instance for (Control.Applicative.Alternative Data.Monoid.Sum)
04:59:18 <lambdabot>    arisin...
04:59:38 <|||tux||> > Sum 1 <> Sum 2
04:59:39 <lambdabot>   Sum {getSum = 3}
04:59:52 <hiptobecubic> yes I was just curious if it was also an Alternative
05:00:12 <hiptobecubic> > [1] <|> [2]
05:00:13 <lambdabot>   [1,2]
05:00:26 <M30W> Morning world
05:00:50 <|||tux||> fmap (+3) $ Sum 4
05:00:55 <|||tux||> > fmap (+3) $ Sum 4
05:00:56 <lambdabot>   No instance for (GHC.Base.Functor Data.Monoid.Sum)
05:00:56 <lambdabot>    arising from a use of...
05:01:03 <M30W> Yay
05:01:23 <M30W> |||tux||: in your code you missed a close paren. I corrected it wrong to remove the open :P
05:02:05 <M30W> @pl unlines [fName x, abc x]
05:02:05 <lambdabot> unlines [fName x, abc x]
05:02:12 <danr> can I get cabal --enable-tests to write the test's stdout? it seems to suppressed
05:02:12 <M30W> Naww
05:03:22 <|||tux||> > map ($ 1) [(+1), (*2), (-5)]
05:03:24 <lambdabot>   No instance for (GHC.Num.Num (b0 -> b0))
05:03:24 <lambdabot>    arising from a use of `e_11125'...
05:03:49 <|||tux||> > map ($ 1) [(+1), (*2), (subtract 5)]
05:03:51 <lambdabot>   [2,2,-4]
05:04:12 <killy9999> danr: if the tests don't get displayed it means they passed. If any test fails they should get displayed on stdout (or stderr?)
05:04:25 <int-e> > [(+1), (*2), (subtract 5)] `sequence` 1
05:04:27 <lambdabot>   [2,2,-4]
05:04:28 <Hafydd> @unpl unlines [fName x, abc x]
05:04:28 <lambdabot> unlines [fName x, abc x]
05:04:34 <danr> my tests take a long time to run, and on travis if a test don't do output for 10 minutes it cancels the tests
05:04:55 <M30W> What was the function to join list entries with a string ? interlase?
05:05:10 <int-e> M30W: intercalate?
05:05:20 <M30W> @hoogle intercalate
05:05:20 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
05:05:20 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
05:05:20 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
05:05:24 <M30W> Thanks
05:06:26 <M30W> Yay
05:06:52 <M30W> Now problem. No exit to the game. :P
05:07:08 <M30W> Thanks guys ^_^
05:07:30 <M30W> 100 lines so far of text-adventure fun. =)
05:07:40 <M30W> 98 *
05:09:54 <M30W> Fail input parser.... Does nothing but handle directions (explicitly). :P
05:10:26 <M30W> Oh well; I'll continue to play around with this. it's awesome :D
05:10:42 <M30W> As for now; I am gonna go to bed. Good night world. ^_^
05:15:42 <absence> for a gadt doing e.g. data Num n => Expr n where ... doesn't work. is adding the constraint to each of the constructors the only way to do this?
05:19:56 <ocharles> absence: http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html -- 7.4.2
05:20:28 <ocharles> http://stackoverflow.com/questions/11585891/class-constraints-for-data-records
05:22:03 <killy9999> can anyone give me a hint how to intgrate useful error messages into a parser?
05:23:07 <earthy> um.
05:24:17 <earthy> http://www.cs.uu.nl/wiki/bin/view/Helium/Downloads
05:24:21 <ocharles> killy9999: i'll trade you that hint for a better question
05:24:34 <earthy> killy9999: read those sources...
05:24:47 <ocharles> killy9999: unless you wanted the answer "yes" :)
05:25:23 <killy9999> ocharles: :)
05:26:15 <killy9999> so
05:26:25 <killy9999> how do I integrate usefule error messages into a parser?
05:26:37 <killy9999> and I mean a toy parser, not a production quality one
05:26:39 <ocharles> by providing an example of what you have and what you want
05:27:08 <absence> ocharles: in other words adding the constraint to the constructors is the right way?
05:27:18 <ocharles> absence: no
05:27:25 <ocharles> adding the constraints to functions that use them is
05:27:29 <killy9999> ocharles: I have almost nothing at the moment, I want to rethink it before coding to much
05:27:55 <killy9999> but the idea is that I want user to specify some options from the command line
05:27:59 <killy9999> these will be parsed
05:28:16 <killy9999> and whenever something is incorrect i want the message to be useful
05:28:19 <ocharles> so... optparse-applicative ?
05:28:29 <ocharles> http://ocharles.org.uk/blog/posts/2012-12-17-24-days-of-hackage-optparse-applicative.html
05:28:48 <liff> is there a RegexLike.Extract instance for Data.Text anywhere?
05:28:53 <ocharles> (there are other libraries that do the same type of thing)
05:29:07 <killy9999> ocharles: nope
05:29:14 <killy9999> I'd like to write that from scratch
05:29:18 <killy9999> for educational purposes
05:29:35 <killy9999> BTW. you still have a broken RSS feed ;)
05:29:46 <ocharles> killy9999: ok, then http://paolocapriotti.com/blog/2012/04/27/applicative-option-parser/
05:29:53 <ocharles> i know :(
05:30:17 <ocharles> if you want to write an option parser from scratch and do errors, that isn't really a question that can be answered
05:30:24 <ocharles> because that depends entirely on how you structure your solution
05:31:33 <killy9999> mhm
05:31:41 <killy9999> probably yes
05:31:53 <killy9999> https://github.com/alephnullplex/cradle/blob/master/code/src/Lbach/Parser/Core.hs
05:31:59 <killy9999> so my idea is to adapt this parser
05:32:23 <killy9999> so far I changed Maybe to Either. This allows to have some sort of error messages
05:32:32 <killy9999> but it's hard to put them in useful places
05:33:15 <killy9999> I'd have to check the result of every function like digit, literal and so on whether it returns Left or not
05:34:16 <liff> oh, never mind, found regex-tdfa-text
05:34:43 <ocharles> killy9999: no, that's what the Either monad is for
05:34:48 <ocharles> @hackage either
05:34:48 <lambdabot> http://hackage.haskell.org/package/either
05:34:58 <absence> ocharles: but i use phantom types in the gadt to preserve type safety though, so e.g "Add :: Num n => Expr n -> Expr n -> Expr n" to make sure you can't add strings or something crazy like that
05:35:25 <ocharles> absence: write smart constructors instead
05:35:29 <ocharles> add :: Num n
05:35:30 <ocharles> urgh
05:35:49 <ocharles> add :: Num n => Expr n -> Expr n -> Expr n ; add = Add
05:36:14 <killy9999> ocharles: yes, but in general I would like to supply my own error messages
05:36:55 <killy9999> ocharles: let's say I have this: space = char <=> isSpace
05:37:23 <killy9999> space :: String -> Either String (String, Char)
05:37:26 <fmap> ocharles: what's wrong with class constraints in GADT's constructors?
05:38:03 <killy9999> ocharles: now if I am unable to parse a space, I would have to check the result of char <=> isSpace and add an erro message
05:38:22 <killy9999> I haven't yet figured out how to do that without the boilerplate of case expressions
05:39:12 <osa1> does anyone here know a workaround for Parsec's expression parser's this property: "Prefix and postfix operators of the same precedence can only occur once" ? I need to find a way to parse "- - 2"
05:40:07 <ocharles> fmap: I guess nothing really
05:40:12 <ocharles> I mean Add is a function after all anyway
05:41:50 <ocharles> "NOTE: New wiki account creation is currently disabled. If you need an account please email "nominolo" (at the email service from Google) or on the haskell-cafe mailing list."
05:41:51 <ocharles> :|
05:41:53 <ocharles> nominolo: ping?
05:43:20 <fmap> ocharles: well, havind separate smart constructor is much less nice because suddenly you need to `Num a =>' everywhere
05:43:56 <fmap> (not having to do so is a point of `Num a =>' in data constructor I think)
05:44:36 <shachaf> Having Num a => in places that use it, rather than a dictionary stored in the data types, is not really a bad thing.
05:47:51 <absence> shachaf: i thought the point of having types in the constructors was type safety, like this example from the wikibook: http://hpaste.org/81530
05:48:31 <bitonic> are there any cool pretty printer libraries apart from ‚Äòpretty‚Äô?
05:51:29 <osa1> bitonic: Text.PrettyPrint.Leijen
05:52:11 <shachaf> absence: That seems unrelated to type classes.
05:52:33 <bitonic> osa1: that looks a lot like ‚Äòpretty‚Äô but overloaded, am I right?
05:52:48 <bitonic> and ‚ÄòDoc‚Äô is not a ‚ÄòMonoid‚Äô :(
05:53:17 <osa1> bitonic: I don't remember differences exactly but it has some useful additions. and also some functions are changed.
05:54:28 * fizbin has a potentially flame-warish question.
05:55:03 <Taneb> fizbin, unless you want a monad tutorial, fire away
05:55:07 <fizbin> I don't want to start a flame war, mind. I'm just aware that, yeah, people might think this is flamish.
05:55:50 <Taneb> You'll never know unless you ask
05:56:12 <jrajav> I don't think I've ever seen a proper flame war in this channel
05:56:53 <fizbin> So, one reason I've been asked to seriously consider Haskell for this ${project I'd like to elaborate on, but can't unfortunately} is because supposedly Haskell can make it possible to guarantee that certain invariants about our data structures aren't violated.
05:57:34 <fizbin> And I've seen the "Haskell lets you enforce variants through the type system" idea in several places - e.g., on one of the slide decks from galois.
05:57:43 <DMcGill> when interpreting numeric literal in source code, is Num the typeclass I need to implement for my type?
05:57:53 <Taneb> DMcGill, yes
05:57:54 * typoclass finds this flame war underwhelming, after all the preliminary warnings =)
05:58:36 <absence> shachaf: maybe i'm thinking the wrong way, but the idea was that in the example, the Add constructor works for one type (Int), while without a gadt it will work for any type. i want something inbetween, i.e. any type that is an instance of the Num class
05:58:45 <fizbin> But as I was looking at examples of people actually using the type system to avoid certain classes of bugs, I didn't really see anything too odd compared to what I've seen done in well-designed java or scala.
06:00:56 <fizbin> So my question is, I get that Haskell can enforce something about code (e.g., that it never touches global state or never does IO) that other languages can't, but can it actually enforce invariants on data structures that are any better than what you could do in Java, Scala, C++, etc. by making all the functions that could potentially violate invariants private, and wrapping them in a public interface that guarantees no invariant
06:01:48 <Botje> fizbin: you can encode some stuff in the type system.
06:01:55 <fizbin> If you want the flame warrior version, I'm calling [citation needed] on the idea that Haskell can enforce data structure invariants better than other languages easily at my fingertips.
06:02:17 <Botje> fizbin: for example, tom moertel showed off a case some time ago where you can completely prevent SQL/HTML injection using tagged strings
06:02:58 <Botje> and you can encode information about the length of a list in the type system as well.
06:03:07 <fizbin> Okay, but that'd be more impressive if I didn't know about the SafeHTML subsystem in GWT.
06:03:10 <frerich> fizbin: I'm not too familiar with Java, but one nice property of Haskell functions is that they are pure, i.e. may not have side effects. The compiler enforces this. I think you cannot have a Java compiler enforce this (but I might be wrong).
06:03:45 <frerich> fizbin: I don't know anything about Scala, maybe it has that, too.
06:04:37 <frerich> fizbin: So in Haskell, the type of a function greatly trims the amount of things it may do (unlike with Java, where any function may do anything including launching ballistic intercontinental missiles AFAIK).
06:04:51 <shachaf> Botje: You can tag strings in a dynamically-typed language too.
06:05:02 <Botje> shachaf: of course. but it's easy to forget one.
06:05:03 <typoclass> fizbin: i think haskell's and java's type system are on the same spectrum. haskell is just a little bit further, but it doesn't have some earth-shattering unbelievable feature. i'd describe it as a regular type system turned up to eleven. for some reason, it seems to much more helpful in practice than you'd expect
06:05:14 <shachaf> Botje: No, it's impossible to forget one.
06:05:44 <fizbin> frerich: I get that, but I don't see how that leads to better enforcement of data obeying invariants.
06:06:05 <Botje> shachaf: hmm, you're referring to String subtypes in ruby / python or something? I'm only familiar with perl tainted strings
06:06:29 <shachaf> Botje: I'm sure it would work in Perl too.
06:06:43 <frerich> fizbin: It doesn't, I think - this was more of a general statement about the type system. As far as enforcing invariants goes, I can't think of a reason why Haskell would be more appropriate than any other language which has opaque types and some sort of concept of 'visibility'.
06:06:58 <shachaf> Botje: Just define a SafeString "type"/"tag"/whatever, and make the write() function check that your string is safe before writing it.
06:07:09 <fizbin> typoclass: That's fine, any other examples of invariant-preserving type system design? I am going to dig up that reference on preventing SQL injection.
06:07:10 <shachaf> And make it hard to create safe strings.
06:07:54 <shachaf> You get the same protection against SQL/HTML injection that you might get with static types. Except if you make a mistake it could be a runtime crash -- but that's way better than someone running arbitrary SQL/HTML.
06:08:21 <typoclass> fizbin: i think if you have very well-designed java code, with interfaces that are tightly controlled and lots of unit tests, then yes, it's comparable to haskell code. the thing is, it takes much more effort and discipline
06:08:28 <jrajav> I had to spend a few hours yesterday convincing business that arbitrary HTML injection was bad
06:08:31 <jrajav> -__-
06:09:03 <fizbin> So that is something Haskell gives that I don't see from other languages - it turns some invariant checking from runtime into compile time checks.
06:09:19 <typoclass> fizbin: yup, well put
06:09:27 <fizbin> But I don't know that that's of much benefit to my particular use case.
06:10:21 <frerich> fizbin: One thing which may be in favor of Haskell is that creating opaque types is quite easy, i.e. little boilerplate involved. whichi n turn means you actually do it ;-)
06:10:51 <frerich> fizbin: But having a 'SQLStatement' type which is internall just a String and then having a constructor function which enforces certain invariants is still not completely compile-time checked - the constructor validates at runtime.
06:10:58 <Taneb> :t lookup
06:10:59 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
06:11:09 <fizbin> I just need to make sure that the program never produces invariant-violating output. Whether it does that because the type system forces me to check all the possible things that could be bad about the input and emit a nice error or do that through an ugly exception and stack trace doesn't really matter.
06:11:23 <Taneb> Is there a function "a -> (b -> b) -> [(a, b)] -> [(a, b)]" that operates on similar lines to lookup?
06:11:57 <shachaf> I'm not sure what that type would do.
06:12:19 <shachaf> @ty lookup
06:12:21 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
06:12:35 <Taneb> Find the first element in the list whose first element matches a, and apply the function to the second element
06:12:37 <shachaf> Eq a? Does it transform values for keys that match the one you gave it?
06:12:42 <shachaf> Ah, the first one.
06:12:53 <shachaf> I bet lens is the nicest way to express that.
06:13:03 <shachaf> I don't think there's a lens for [(a,b)], though.
06:13:07 <Taneb> I thought you wanted me to use less lens!
06:13:18 <typoclass> fizbin: i think an example is Maybe. in java any object reference can be null (afaik). very often, you need something to be not null. you have to litter the code with "if (obj == null) ...", it isn't always what you can sensibly do then, and it's easy to miss a few places. you need code review, unit tests, discipline, constant worry. this is because the type system is not powerful enough to distinguish "a String" from "a String, or null"
06:14:15 <fizbin> Right, so that's an argument for heavily Haskell-influenced Scala.
06:14:22 <typoclass> fizbin: not sure if i've phrased this in a good way, but i feel haskell removes several classes of worries, and in the end you get excellent code with moderate effort. in other languages, you certainly can get good or excellent code, but it takes phenomenal effort
06:14:55 <frerich> typoclass: I think Java has a 'NotNullable<T>' generic or something for that particular case.
06:15:24 <frerich> Sorry for being offtopic. :-}
06:15:35 <Taneb> :t \a -> traverse . filtered (views (== a) _1) . _2
06:15:36 <lambdabot>     Couldn't match expected type `s0 -> Accessor Bool t0'
06:15:36 <lambdabot>                 with actual type `Bool'
06:15:36 <lambdabot>     Expected type: Overloading p0 (->) (Accessor Bool) s0 t0 a0 b0
06:15:39 <fizbin> frerich: Not built in. There are some libraries that have classes like Option (e.g. guava), but it's not overly common.
06:16:01 <Taneb> :t \a -> traverse . filtered (views _1 (== a)) . _2
06:16:03 <lambdabot> (Eq a, Applicative f, Traversable t, Field2 b b a1 b2, Field1 b t1 a b1, Indexable Int p) => a -> p a1 (f b2) -> t b -> f (t b)
06:16:12 <mikeplus64> > let{;;;;;;;;;;;;;;;;;;;;;;} in ()
06:16:13 <lambdabot>   ()
06:16:16 <frerich> fizbin: Well you could say that it's a feature of the language to be able to define it as part of a library. In Haskell, 'Maybe' is not a part of the language either but a part of the standard library.
06:16:17 <fizbin> typoclass: The Scala community has embraced the Scala version of Maybe (called Optional) heavily though.
06:16:20 <typoclass> fizbin: possibly it is an argument for scala =) i'm not really familiar with it, i only hear some folks saying "it tries to be haskell, but it's all less smooth"
06:16:48 <Taneb> :t let pukool a = traverse . filtered (views _1 (== a)) . _2 in zip [1..10] "hello" & pukool 3 %~ succ
06:16:50 <lambdabot>     Ambiguous type variables `t0', `b0' in the constraint:
06:16:50 <lambdabot>       (Field1 b t0 a b0) arising from the ambiguity check for `pukool'
06:16:50 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
06:17:14 <frerich> fibin: I concur with typoclass: you can probably write pretty much equally type-safe code in Java than with Haskell, but it takes a lot more effort.
06:17:26 <Taneb> :t let pukool a = traverse . filtered (views _1 (== a)) . _2; pukool :: (Eq a, Traversal t) => a -> Traversal' [(a, b)] b in zip [1..10] "hello" & pukool 3 %~ succ
06:17:27 <lambdabot>     Expecting three more arguments to `Traversal t'
06:17:28 <lambdabot>     In the type signature for `pukool':
06:17:28 <lambdabot>       pukool :: (Eq a, Traversal t) => a -> Traversal' [(a, b)] b
06:17:30 <fizbin> I've found a paper arguing that if you assemble a certain subset of obscure features in Scala, you have essentially the low-level representation that some haskell compilers use internally as part of the compilation.
06:17:39 <typoclass> frerich: i also heard about an annotation, "@Nullable" or something ... i'm not up to date on java. in any case, good to see some haskell features slowly finding their way into other languages
06:17:42 <Taneb> :t let pukool a = traverse . filtered (views _1 (== a)) . _2; pukool :: (Eq a) => a -> Traversal' [(a, b)] b in zip [1..10] "hello" & pukool 3 %~ succ
06:17:44 <lambdabot> (Enum a, Eq a, Num a) => [(a, Char)]
06:17:48 <Taneb> > let pukool a = traverse . filtered (views _1 (== a)) . _2; pukool :: (Eq a) => a -> Traversal' [(a, b)] b in zip [1..10] "hello" & pukool 3 %~ succ
06:17:50 <lambdabot>   [(1,'h'),(2,'e'),(3,'m'),(4,'l'),(5,'o')]
06:18:08 <frerich> typoclass: Yep
06:18:15 <shachaf> > let pukool a = traverse . filtered (views _1 (== a)) . _2; pukool :: (Eq a) => a -> Traversal' [(a, b)] b in zip [1..10] "hellock" & pukool 3 %~ succ
06:18:17 <typoclass> Taneb: hello, friendly reminder, lambdabot is also available in private chat
06:18:18 <lambdabot>   [(1,'h'),(2,'e'),(3,'m'),(4,'l'),(5,'o'),(6,'c'),(7,'k')]
06:18:33 <Taneb> typoclass, I swear that worked when I typed it ghci
06:18:42 <frerich> typoclass: FWIW Boost has an 'boost::optional' template which apparently intends to achieve the same. And our internal C++ codebase has a 'Maybe' template :-)
06:18:50 <frerich> (complete with 'Just' and 'Nothing' constructor functions)
06:18:51 <fizbin> typoclass: That annotation is documentation-only, though some introspection/bugfinding tools (such as the excellent findbugs) will use that annotation to check things about java code.
06:19:57 <psii> I'd like to bring another point into this discussion: using third-party libraries. You can be very disciplined about your own code, but if you want to use other libraries, which are written in a language that doesn't encourage those disciplines, then you have something more to worry. Of course, bad libraries in haskell are possible, but most of the time you can see the "contract on how to use the library correctly" in the type
06:19:57 <psii> signatures.
06:20:02 <typoclass> fizbin: i see. i guess, haskell has that introspection/bugfinding tool integrated into the compiler, making it impossible to forget to run it, etc. :-)
06:20:51 <typoclass> frerich: then you need to pay royalties to haskell =)
06:21:09 <typoclass> psii: excellent point
06:21:20 <frerich> psii: Good point!
06:21:42 <fizbin> But okay. So I have one reference to go hunt down on safe strings; I'd really like more examples of designing types/typeclasses to deliberately avoid certain classes of bugs, but I can see how it'd be hard to find those.
06:22:05 <nexx> typoclass well there is also HLint
06:22:10 <fizbin> After all, bugs that don't make it past the compiler wouldn't necessarily register as bugs really.
06:24:01 <typoclass> fizbin: so in summary, i wouldn't say haskell has some mythical unbelievable secret feature (this would only create unrealistic expectations). but a dozen moderate type system improvements can multiply each other, and come out as a huge savings
06:24:58 <typoclass> fizbin: the end result is, in my experience, it's hard to get stuff to compile in haskell, but once it does, there's not many bugs in it anymore
06:25:43 <fizbin> typoclass: And compared to Java, I can see that. (many moderate type system improvements) I'm having a harder time seeing that compared to Scala, especially if in code review we're strict about sticking to the immutable subset.
06:26:27 <typoclass> fizbin: probably yes
06:26:28 <fizbin> The big potential advantage Haskell has is that some algorithms we want to use are more naturally expressed in a lazy language than in an eager-evaluation one.
06:27:05 <typoclass> fizbin: you'd have this new german coworker called ghc sitting in the code reviews, being very pedantic and rigorous =)
06:27:22 <frerich> He sure has a german attitude at times.
06:28:10 <fizbin> But that's a separate issue, and I need to go talk to our deep algorithm dreamer more about what those algorithms are that he doesn't want to express strictly, and whether he needs laziness everywhere or could live with the strategically applied laziness you can easily get in Scala.
06:28:32 <portnov> hi all
06:28:35 * fizbin already has a sufficient number of German co-workers
06:28:44 <portnov> http://hpaste.org/78159 ‚Äî any ideas?
06:28:45 <typoclass> fizbin: my condolences
06:28:56 <bacon1989> i have a problem concerning hinting types
06:29:05 <bacon1989> normally when I use HDBC.fromSql
06:29:12 <shachaf> portnov: Sounds like the package is broken and needs to be updated.
06:29:22 <bacon1989> i use it like... (HDBC.fromSql id)::Int
06:29:26 <bacon1989> and hint at the type
06:29:32 <bacon1989> but what if I were to map it?
06:29:41 <bacon1989> map HDBC.fromSql ids
06:29:44 <geekosaur> portnov, you have ghc 7.6.x?  I don't think gtk2hs is compatible yet; ghc 7.6 is stricter about followingt he standard with respect to types in foreign imports
06:29:59 <portnov> geekosaur: :(
06:30:20 <geekosaur> (I think all that
06:30:57 <portnov> what is the problem?
06:31:02 <geekosaur> s needed is an additional import line somewhere but unsure about details.  you might try building gtk2hs from its repo instead of via cabal/hackage
06:31:04 <portnov> CULong is bad type?
06:31:19 <geekosaur> it's a valid type but it has to be directly imported or something like that now
06:31:23 <shachaf> No, it's fine.
06:31:36 <shachaf> It's an FFI thing. GHC 7.4 wasn't following the standard and unfortunately many packages didn't either.
06:32:08 <vhz> portnov: archlinux has a port of gtk2hs for ghc-7.6
06:32:11 <geekosaur> indirectly imported via some other module is a violation of the strict letter of the FFI specification; ghc used to allow it, so people were lazy [ :) ] but now ghc is strict about it
06:32:18 <tdammers> bacon1989: (map HDBC.fromSql ids)::[Int] maybe?
06:32:20 <portnov> vhz: why it's not in upstream?
06:32:40 <vhz> I don't know :)
06:32:48 <geekosaur> the gtk2hs repo has it, just hasn't been released yet as I understand it
06:33:03 <vhz> ah yes i was about to suggest that
06:33:09 <shachaf> I just cabal installed gio successfully.
06:33:15 <shachaf> Maybe you just need to cabal update?
06:33:43 <fizbin> Hrm. Maybe I could wrap all datastructure manipulation functions inside a monad that did invariant checking on the way out of the monad and then make the output function be called outside the Monad...
06:33:56 <portnov> shachaf: currently gio installs ok, but pango still fails
06:34:24 <shachaf> Installed pango-0.12.4
06:34:24 <shachaf> Installed gio-0.12.4
06:34:31 <shachaf> I'm using GHC 7.6.2
06:34:32 <portnov> hmm
06:35:10 <portnov> shachaf: GHC 7.6.1.20121207, pango-0.12.4. Maybe it's 64-bit issue?
06:35:36 <typoclass> fizbin: if you tell us more about those invariants, maybe someone has ideas about how to express them directly in the type system
06:35:40 <shachaf> 7.6.2, x86_64-unknown-linux
06:35:53 <shachaf> Maybe something changed in 7.6.2.
06:36:44 <portnov> ok, there is 7.6.2 in experimental. Will try :)
06:36:58 <typoclass> portnov: have you ruled out that the underlying c library is different? (version mismatch?)
06:37:50 <portnov> typoclass: maybe. How do I know which version of libpango this package needs?
06:39:00 * vhz confirm gtk install properly with ghc 7.6.2 and the hackage package
06:39:17 <typoclass> portnov: no, i meant that the gio haskell package is encountering a c library that it can't handle
06:39:37 <shachaf> typoclass: That would not cause these errors.
06:39:41 <vhz> portnov: i don't think it will make a difference, but i'm using 1.32.5
06:39:49 <shachaf> portnov: GHC 7.6.2 came out today, mind you.
06:39:56 <shachaf> Or yesterday, I guess.
06:40:00 <portnov> nice :)
06:40:11 <typoclass> shachaf: hm ok, thanks for checking
06:40:14 <luite> mynd you
06:40:41 <fizbin> Okay, how about this: Say I have a (Map String [String]) that defines my invariants and some other input that I need to transform into a [(String, String)] and I want to obey the invariant that if (a,b) is in the output then b is in fromJust (lookup a invariantMap)
06:40:44 <typoclass> portnov: http://hackage.haskell.org/package/gio indicates that package fails to build on the hackage server, with similar errors
06:41:15 <typoclass> dmwit: yo?
06:41:37 <shachaf> typoclass: gio builds fine here, with GHC 7.6.2
06:41:50 <portnov> hm, http://hackage.haskell.org/packages/archive/gio/0.12.4/logs/failure/ghc-7.6
06:42:00 <portnov> i think it's 7.6.1 on hackage.
06:42:01 <fizbin> Taneb: Still looking for that lookup-ish function?
06:42:15 <Taneb> Yeah, I'm using a lensy hack right now
06:42:29 <fizbin> Because it sounds very much like Data.Map.adjust.
06:42:43 <Taneb> Except I don't have a map
06:42:50 <Taneb> And I can't help that
06:43:00 <fizbin> Fair enough.
06:43:07 <Taneb> And I think converting to a map, then converting back is a huge waste of time
06:45:27 <portnov> cabal install gtk2hs-buildtools installs `random' package
06:45:29 <portnov> :)
06:46:33 <vhz> portnov: :)
06:46:45 <srhb> What on earth are the bounds in Data.Graph.buildG?
06:47:55 <vhz> srhb: does it depends on the planet where you install it ? :)
06:48:21 <srhb> If only I knew.
06:50:01 <srhb> was trying to use it in order to do some A* searching, but I'm starting to doubt it as a choice, it's completely opaque to me. :P
06:50:49 <mysticc> I have a map which I want to index on multiple fields. Is there any package to do that?
06:51:42 <srhb> IxMap? Isn't that what it is?
06:52:22 <EvanR2> IxSet
06:52:49 <EvanR2> a map from any of your indexes to a matching subset
06:52:55 * hackagebot enummapset-th 0.6.0.0 - TH-generated EnumSet/EnumMap wrappers around IntSet/IntMap.  http://hackage.haskell.org/package/enummapset-th-0.6.0.0 (LiyangHu)
06:53:25 <typoclass> fizbin: i think i'd use a 'smart constructor' for that, which is a simple function relying on things being hidden away in a module, so that it's impossible to construct invalid values. a more elaborate solution could be that for every key in your invariantMap, you define one data = PossibleValue1 | PossibleValue2 | ... . this would also ensure nobody can create invalid values
06:53:51 <portnov> shachaf: cabal install gtk worked fine on ghc 7.6.2 from debian experimental, thanks :)
06:53:58 <TorosFanny> I tried :k State,why it says  Type synonym `State' should have 1 argument, but has been given none
06:53:58 <TorosFanny>     In a type in a GHCi command: State
06:54:01 <fizbin> typoclass: Unfortunately, invariantMap isn't known at compile time.
06:54:12 <EvanR2> :k State
06:54:14 <lambdabot> Top level:
06:54:14 <lambdabot>     Type synonym `State' should have 1 argument, but has been given none
06:54:14 <lambdabot>     In a type in a GHCi command: State
06:54:23 <TorosFanny> yes
06:54:23 <`^_^v> did anyone here go to the nyc meetup yesterday
06:54:29 <`^_^v> that place had a good beer selection
06:54:51 <TorosFanny> but :k State Int is ok
06:55:06 <TorosFanny> why not :k State gives *->*->*
06:56:08 <shachaf> Because of what the error says.
06:56:09 <portnov> TorosFanny: with current mtl2, there is no `State' on type checker stage. There is only StateT Identity.
06:56:20 <shachaf> State is a type synonym. It should have one argument.
06:56:29 <EvanR2> :k StateT
06:56:31 <lambdabot> * -> (* -> *) -> * -> *
06:56:38 <shachaf> Type synonyms do not have kinds.
06:57:03 <fizbin> typoclass: So I guess that leaves the smart constructor as the only way to go. That transforms invariant checks into runtime-only checks again.
06:57:10 <TorosFanny> I got it, thanks
06:57:59 <portnov> and Haskell cannot into partial application of type synonyms :/
06:58:27 <portnov> in class instance declarations, for example
06:58:31 <typoclass> fizbin: right, but if those invariants really can't be known at compile time, it's kind of hard to know and apply them at compile time :-)
06:59:01 <fizbin> I suppose I could have something that forces the functions constructing things to pull the snd of those tuples from the invariantMap. Hrm...
06:59:47 <typoclass> fizbin: have you thought about somehow delaying compilation, or parts of compilation, until the invariants are known? xmonad does quite well with having full haskell as the language of its configuration file. it just runs ghc on it, which may or may not produce a binary then
07:03:03 <fizbin> I have been trying to find a quick rundown of how xmonad does that and whether it would be possible to ship enough of ghc with $(product) to make that a viable approach. I wish I could find a blog post where someone talked about the issues of doing that commercially with clients who aren't the kind to have a full ghc install just on a whim.
07:04:10 * shachaf doesn't like xmonad's approach very much.
07:04:49 <typoclass> fizbin: it's very unsophisticated, it just plainly runs ghc, and either displays its errors, or runs the binary file
07:05:19 <fizbin> typoclass: But again, that's essentially a run-time error, since it's caught by a compiler that's invoked at runtime.
07:07:18 <typoclass> fizbin: true, i was thinking about using ghc for some checking and stuff. it doesn't solve the basic paradox that the invariants aren't known until runtime, but somehow need to be know before that
07:09:37 <fizbin> I do like the idea of forcing bits to get pulled from the invariantMap. Maybe I can run the input function inside something that's essentially a (State InvariantMapType) and force the output to be [ValidPair], where the only way to get a ValidPair is a function that reaches into the state, something like validPairLookup::(String -> String -> State InvariantMapType (Maybe ValidPair)).
07:10:07 <fizbin> VaildPair would of course be some newtype that wraps (String, String)
07:12:11 <bacon1989> alright so, I have a list of statements in dStatements -> ["DELETE FROM category WHERE id=23423", "DELETE FROM category WHERE id=12345"] etc, and running map HDBC.runRaw dStatements gives me Couldn't match expected type `IO a0' with actual type `[b0]'
07:12:33 <bacon1989> what am I missing here?
07:12:40 <shachaf> Context, among other things.
07:12:43 <mauke> types
07:12:53 <bacon1989> i'm not passing the map to a list, is this the issue?
07:12:59 <mauke> ??
07:13:05 <bacon1989> one sec
07:13:26 <bacon1989> first off runRaw :: conn -> String -> IO ()
07:13:41 <bacon1989> and I want to pass a [String]
07:13:58 <bacon1989> I tried mapM_ runRaw [String]
07:14:11 <bacon1989> but this gave me trouble
07:14:26 <bacon1989> now map doesn't provide any suitable solution either
07:14:28 <merijn> Where's the conn in that example?
07:14:54 <merijn> runRaw has two arguments and mapM_ runRaw [String] only gives it one
07:14:56 <fizbin> Don't you want mapM_ (runRaw conn) [String]  ?
07:15:22 <bacon1989> bah
07:15:24 <bacon1989> yes
07:15:42 <bacon1989> I should probably take a break from this, I can't even spot simple errors :S
07:15:59 <bacon1989> but yeah, it was the missing Connection
07:16:01 <bacon1989> thanks
07:16:19 <merijn> bacon1989: Step one in investigating errors is look at the expected type and the actual type and try to focus on figuring out why they're different :p
07:17:32 <bacon1989> haha yeah
07:17:57 <tdammers> bacon1989: it actually works that way in haskell
07:18:07 <bacon1989> I had been doing that, but I had been using HDBC.execute before
07:18:32 <bacon1989> so when I switched to runRaw, i left out the connection AND the prepared sqlValues
07:19:03 <bacon1989> I should have read the types though, I know :S
07:19:25 <tdammers> ghc was even telling you
07:19:31 <tdammers> "Couldn't match expected type `IO a0' with actual type `[b0]'"
07:20:05 <merijn> I like it when haskell types let me debug peoples code even when I have no clue what their code means or what it's supposed to be doing :)
07:20:25 <tdammers> merijn: I even come across that situation with my own code :o
07:20:34 <tdammers> also, hlint.
07:29:26 <fizbin> Does haskell have visibility controls other than "exported" and "not exported"? I.e., if I wanted to have several related modules that could call each other's private functions with a guarantee that other modules couldn't do that, how would I do that?
07:29:54 * fizbin is thinking something like Java's package-level protections or C++'s "friend" declaration
07:30:17 <shachaf> The standard thing to do is make .Internal modules and have the non-Internal modules re√´xport the relevant parts of them.
07:30:34 <shachaf> You can either export the .Internal modules or not, depending on how you feel.
07:30:42 <shachaf> (Export from the cabal package, I mean.)
07:31:23 <fizbin> Huh. Have an example of a package that does that?
07:31:43 <shachaf> Does what?
07:31:58 <dcoutts> fizbin: bytestring does it (it exports the .Internal module)
07:32:01 <fizbin> nm; I found an example on github.
07:32:25 <shachaf> There's no big difference between ones that export the .Internal modules and don't; it's just a .cabal change.
07:33:16 <HugoDaniel> how can i check if all the items in a list are equal ? im doing this: all (\i -> [i] == take 1 lst) lst
07:34:07 <merijn> Why [i]?
07:34:10 <shachaf> foo [] = True; foo (x:xs) = all (==x) xs
07:34:15 <Botje> HugoDaniel: check the nub function.
07:34:29 <HugoDaniel> yeah, i could nub lst == []
07:34:32 <Botje> it removes all duplicates, so if you get back a list of size one you only have one distinct element.
07:34:40 <shachaf> That sounds inefficient.
07:34:47 <HugoDaniel> yes, nub is inefficient
07:34:54 <HugoDaniel> at least it says in the haddock
07:34:55 <HugoDaniel> :)
07:35:05 <fmap> @ty all (uncurry (==)) . ap zip tail
07:35:06 <lambdabot> Eq b => [b] -> Bool
07:35:29 <Botje> HugoDaniel: you didn't say you wanted it to be efficient.
07:35:41 <hiptobecubic> ap zip tail  a nice idiom
07:35:45 <hiptobecubic> is a*
07:36:25 <Eelis> @ty ap zip tail
07:36:27 <lambdabot> [b] -> [(b, b)]
07:36:35 <fryguybob> @quote zip`ap`tail
07:36:35 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
07:36:40 <fmap> @ty and . ap (zipWith (==)) tail
07:36:41 <lambdabot> Eq b => [b] -> Bool
07:36:41 <HugoDaniel> :D
07:37:57 <hiptobecubic> This is in the function monad, no?
07:38:00 <hiptobecubic> this ap
07:38:03 <fmap> yes
07:38:19 <hiptobecubic> @src (-> r) ap
07:38:19 <lambdabot> Source not found. You untyped fool!
07:38:24 <hiptobecubic> @src (-> r) (<*>)
07:38:24 <lambdabot> Source not found. I feel much better now.
07:38:35 <HugoDaniel> in Control.Monad yes
07:38:39 <fizbin> @info ap
07:38:39 <lambdabot> ap
07:38:41 <hiptobecubic> @src (<*>) (-> r)
07:38:41 <lambdabot> Source not found. :(
07:38:43 <HugoDaniel> lambdabot insults!
07:38:46 <prophile> @pl \f -> ap (zipWith f) tail
07:38:46 <lambdabot> (`ap` tail) . zipWith
07:38:55 <fmap> @src (->) (<*>)
07:38:55 <lambdabot> (<*>) f g x = f x (g x)
07:39:03 <hiptobecubic> damnit
07:39:05 <fmap> that's S
07:39:28 <hiptobecubic> I'm confused though
07:39:41 <hiptobecubic> :t ap
07:39:42 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:40:24 <hiptobecubic> (-> (a -> b)) -> (-> a) -> (-> b)  right?
07:40:28 <fizbin> :t ap shows
07:40:30 <lambdabot> Show a => (a -> String) -> a -> String
07:42:53 <hiptobecubic> How is (-> a) pronounced?
07:43:06 <shachaf> However you like.
07:43:13 <shachaf> It's not valid Haskell anyway.
07:43:44 <hiptobecubic> Well if it were, it wouldn't be ambiguous would it?
07:43:52 <hiptobecubic> It's like... a section of the (->) type operator?
07:43:54 <geekosaur> ((->) a) on the other hand is often pronounced "reader"
07:44:21 <danr> or something with environment (like environment monad)
07:44:24 <shachaf> Do you pronoucne (Int -> Char) "Reader Int Char"?
07:44:34 <danr> shachaf: silly!
07:44:37 <shachaf> It's just a function.
07:44:50 <geekosaur> no, but it's not a section on (->) :)
07:44:57 <hiptobecubic> the a in ((->) a) is the input type, yes?
07:45:03 <danr> hiptobecubic: yes
07:45:15 <frerich> Actually, how *do* people pronounce 'Int -> Char'? 'Function of Int to Char'?
07:45:23 <hiptobecubic> so this thing doesn't specify an output type and is polymorphic in the input?
07:45:24 <danr> frerich: Int to Char?
07:45:45 <hiptobecubic> func from int to char? mapping from int to char?
07:45:49 <fizbin> > ap (\x y -> unwords [x,"`ap`",y]) (\x -> unwords ["f",x]) "start"
07:45:50 <lambdabot>   "start `ap` f start"
07:46:39 <frerich> danr: Is that the same as "Int over Char"? Not sure how you said it in english...
07:46:58 <hiptobecubic> I'm just having trouble making the analogy with, for example <*> for Maybe
07:48:25 <|||tux||> Is there a package on hackage providing a MonadEither mtl typeclass?
07:49:01 <shachaf> |||tux||: How about mtl?
07:50:07 <|||tux||> Does ErrorT work in connection with the errors package?
07:50:35 <shachaf> I don't know anything about that package.
07:50:59 <shachaf> @hackage either has an instance
07:50:59 <lambdabot> http://hackage.haskell.org/package/either has an instance
07:51:04 <dmwit> portnov: pong
07:51:43 <dmwit> (I think typoclass called for me on your behalf, not 100% sure why, though.)
07:51:51 <portnov> dmwit: ?
07:51:52 <shachaf> gtk troubles
07:51:57 <shachaf> Since resolved.
07:52:01 <portnov> ah, yes
07:52:14 <portnov> dmwit: pango did not compile on GHC 7.6.1.
07:52:50 <dmwit> Hm, compiles here on 7.6.1. What did you figure out was the problem?
07:53:19 <portnov> dmwit: just cabal install pango.
07:54:03 <portnov> dmwit: http://hackage.haskell.org/packages/archive/pango/0.12.4/logs/failure/ghc-7.6
07:54:50 <dmwit> I'm aware that it didn't build on Hackage, but I don't know what the actual problem is. Did you figure out what it was?
07:55:17 <fizbin> I don't suppose there's any convenient way when writing my module to say "Export everything top-level except Foo" without writing out every top-level symbol except Foo, is there?
07:55:21 <dmwit> As I said, it works fine here, also on 7.6.1, so I'm a bit puzzled.
07:55:23 <fmap> I thought the problem was hackage has old buildtools
07:55:31 <merijn> fizbin: Unfortunately not :\
07:55:39 <shachaf> dmwit: It works with 7.6.2
07:55:45 <shachaf> On 7.6.1 I think it had the FFI problem.
07:55:56 <shachaf> Not sure why 7.6.2 changes anything there.
07:56:04 <merijn> fizbin: You could have another module do "module FooWrapper (module Foo) where import Foo hiding (Bar)", I think
07:56:25 <merijn> But I'm not sure that works
07:57:08 <fizbin> merijn: Interesting. If I could stuff multiple modules into one file I might consider that. As it is, I'll just suck it up and keep the export list up-to-date.
07:57:10 <dmwit> shachaf: Again, I don't know what to say other than "I just now, less than five minutes ago, built and installed pango-0.12.4 on GHC 7.6.1 with no problem".
07:57:24 <shachaf> Ah.
07:57:26 <shachaf> I don't know, then.
07:57:56 * hackagebot dbus-th 0.1.1.0 - TemplateHaskell generator of DBus bindings  http://hackage.haskell.org/package/dbus-th-0.1.1.0 (IlyaPortnov)
08:01:22 <dmwit> (...and I don't really want to upload a dozen different versions of pango to Hackage just to do debugging.)
08:04:08 <portnov> dmwit: let's just say "don't use so old compiler as 7.6.1 is" ;)
08:06:13 <dcoutts> dmwit: btw, for that kind of use case, you can host cabal packages elsewhere, people can cabal-install betas direct from http urls
08:19:35 <ParahSailin> @pl oneEdit' x l = concatMap ($ x) [oneDel' x l, oneSub' x l, oneIns' x l]
08:19:35 <lambdabot> oneEdit' = ap ((.) . (=<<) . flip id) (ap (ap . ((:) .) . oneDel') (ap (ap . ((:) .) . oneSub') (flip flip [] . ((:) .) . oneIns')))
08:19:51 <ParahSailin> i could accept one point
08:22:57 * hackagebot sym 0.8 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.8 (AndersClaesson)
08:24:32 <c_wraith> \x -> concatMap ($ x) . flip map [oneDel' x, oneSub' x, oneIns' x]
08:24:54 <c_wraith> But yeah, extracting the x from that will always result in ugly
08:27:22 <elliott> ParahSailin: I find your original version most readable.
08:28:02 <elliott> c_wraith: are you sure that's right?
08:28:03 <elliott> the flip map part
08:28:09 <elliott> looks like it'll result in [l (oneDel' x), ...]
08:29:02 <c_wraith> oh, you're right.
08:29:29 <c_wraith> needs to end with . flip id
08:29:32 <c_wraith> which makes it way worse
08:31:11 <shachaf> Why not concat [oneDel' x l x, oneSub' x l x, oneIns' x l x]?
08:31:21 <shachaf> That seems even simpler to me.
08:31:55 <gspr> Can hsc2hs generate peek and poke for nested structs when then the inner struct isn't declared separately anywhere? If I have something like  struct {int x;} foo;  struct {struct foo y;} bar; then hsc2hs easily lets me access the y.x of a struct bar, but what if I just have struct {struct {int x;} y;} bar;? Can hsc2hs still help me access the y.x of a struct bar?
08:33:40 <elliott> shachaf: or even oneDel' x l x ++ oneSub' x l x ++ oneIns' x l x
08:34:19 <shachaf> hi
08:38:15 <ksf> ...there's a flag that makes those nasty  R_X86_64_32S relocation errors while linking dissapear, but I can't remember which.
08:38:54 <shachaf> I bet they'd go away if you switched to SPARC.
08:40:31 <ksf> iirc it has something or the other thing to do with multilib.
08:46:15 <ParahSailin> just playing around in ghci with +s set-- is it reasonable that writeArray on an IOUArray might take 8 us, or might one expect that to be sped up on actual compile
08:47:08 <geekosaur> lots of things speed up when compiled; the bytecode backend is neither fast nor optimized
08:49:54 <ksf> -dynamic -shared -fPIC works, but that's not static.
08:51:41 <brianq> Hi - does anyone here know how Read of a tuple interacts with readParens? What stops readParens stripping off parens before the tuple can parse them?
08:53:59 <Botje> ParahSailin: time it and find out :)
08:55:43 <ksf> -optl=-nopie , for further reference. the problem is a hardened gcc.
08:57:30 <ParahSailin> why no docs here? http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/GHC-IOArray.html
08:58:15 <brianq> ParahSailin: i don't know - but i've found lots of 404s in the docs recently
08:58:35 <brianq> ParahSailin: i've brought it up multiple times - nobody cares
08:58:42 <ParahSailin> like, am i supposed to guess?
08:59:00 <quicksilver> I care, brianq
08:59:06 <quicksilver> but I don't know what broke them.
08:59:46 <brianq> quicksilver: if you take a random walk through the docs, you will find many many broken links, and over the last three months it's gotten worse. i should have made a list but haven't. there are loads
09:00:04 <quicksilver> I know.
09:00:05 <quicksilver> It's a bug.
09:00:15 <parcs> brianq: it probably does some backtracking
09:00:20 <quicksilver> either in haddock, or in the GHC build system
09:00:54 <brianq> is that just a guess? if you know more than i do i will put some time into tracking it down
09:01:23 <quicksilver> brianq: well, do you have any more examples?
09:01:32 <quicksilver> brianq: both of broken links and the page they're linked from?
09:01:43 <brianq> one minute...
09:02:29 <parcs> GHC.IOArray has this pragma: {-# OPTIONS_HADDOCK hide #-}
09:02:35 * quicksilver nods
09:02:41 <parcs> probably has something to do with it
09:02:55 <brianq> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Prelude.html#g:4 - that has a broken link to source for example, found that one yesterday after somone else asked about it
09:02:58 * hackagebot udbus 0.1.1 - Small DBus implementation  http://hackage.haskell.org/package/udbus-0.1.1 (MichaelSnoyman)
09:03:55 <parcs> strange
09:03:59 <portnov> eh
09:04:11 <portnov> what was wrong with `dbus' package!?
09:04:20 <polynomial2> so I usually resolve situations where I have an 'IO a' and need 'a' by doing myA <- IoFunctionThatReturnsIoA inside a do block. how can I do the equivalent in this code? https://github.com/bos/pronk/pull/18/files#L0R153 I have a function that returns an IO Bool and I need a Bool inside the problems variable
09:04:49 <ParahSailin> @ty fmap
09:04:51 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:04:55 <polynomial2> I unforunately am not educated enough to use the right vocabulary to describe my problem but hopefully that makes sense
09:05:48 <Botje> polynomial2: grab the value of your IO Bool thing in advance.
09:06:01 <polynomial2> Botje: I can do that but I do not think it has scope inside the where block
09:06:21 <Botje> polynomial2: correct. so you either have to move the problems thing in a let definition, or make the bool thing a parameter of problems.
09:06:32 <parcs> brianq: i think that's also because of the OPTIONS_HADDOCK pragma
09:06:47 <polynomial2> Botje: is there no way to do this "unpacking" from IO a to a inline?
09:06:52 <Botje> (by the way, that's a pretty cool pattern. I'm totally stealing that)
09:06:55 <Botje> polynomial2: haskell forbids it.
09:07:04 <quicksilver> ParahSailin: where did you find the link?
09:07:12 <quicksilver> ParahSailin: (to that IOArray page which is broken)
09:07:16 <parcs> brianq: the Eq class is exported by GHC.Classes which has the {-# OPTIONS_HADDOCK hide #-} pragma
09:07:19 <polynomial2> Botje: it is forbiden for reasons to do with purity and IO and things I don't understand yet, correct?
09:07:32 <Botje> correct.
09:07:34 <brianq> parcs: well why on earth is there a link to the source code then?
09:07:41 <Botje> polynomial2: if you want to get on with more useful stuff, you can use unsafePerformIO
09:07:45 <quicksilver> presumably generating the source link is the bug, brianq
09:07:52 <quicksilver> although I don't thin I understand the intention
09:08:01 <quicksilver> plenty of internal modules are browsable
09:08:03 <quicksilver> primitives and all
09:08:05 <quicksilver> why hide some?
09:08:07 <Botje> polynomial2: but if you put code using unsafePerformIO up for review people *will* shout at you.
09:08:08 <polynomial2> Botje: that's ok, I think I will avoid unsafe IO stuff. this exercise is helping me understand the basic constructs of the language
09:08:12 <parcs> brianq: dunno
09:08:19 <fizbin> Anyone know of any decent introductions or cookbooks for Arrows out there?
09:08:24 <ParahSailin> http://hackage.haskell.org/package/base-4.6.0.0
09:08:43 <Botje> polynomial2: you could always modify problems before you use it.
09:08:48 <polynomial2> Botje: I too thought the pattern was pretty cool. that pull request is actually the result of a discussion on this channel last night when I was asking about how to validate arguments
09:08:48 <ParahSailin> quicksilver: most of the GHC.X links are broken
09:08:52 <quicksilver> ParahSailin: thanks.
09:09:04 <polynomial2> Botje: ok, makes sense
09:09:22 <quicksilver> ParahSailin: not all, though.
09:09:23 <Botje> isHappy <- checkIsHappy; let problems' = problems ++ [ "I am not happy" | not isHappy ]
09:09:26 <Botje> or something like it.
09:09:38 <quicksilver> I guess that, as parcs said, it's the OPTIONS_HADDOCK hide ones
09:09:44 <Botje> (and then use problems' instead of problems later, of course)
09:09:48 <polynomial2> hrm, interesting. that seems like a solid approach
09:09:59 <fizbin> Because with Arrows I'm still at the "WTF! All I want to do is (something that'd be easy with normal functions)" stage, and what I really need is a collection of recipes to follow.
09:10:23 <polynomial2> ok and I can not just reassign the modified problems to problems because the variable is not mutable?
09:10:35 <Botje> polynomial2: you cannot reassign variables in haskell.
09:10:50 <Botje> if you do problems = problems ++ [ ... ] you will end up with an infinite loop
09:11:03 <polynomial2> Botje: ok, good to know
09:11:40 <Botje> (note that you can introduce new bindings that shadow existing bindings, but you'll see it when you see it)
09:12:00 <bitonic> with the ‚Äòpretty‚Äô package, is there a way to say ‚Äòbreak here if necessary for the line not to be too long‚Äô?
09:12:14 <fizbin> I suspect that if I try to explain what I want, the answer from Arrow experts is "I'm not thinking about it correctly," which isn't actually helpful.
09:12:34 <polynomial2> Botje: ok great. thanks very much
09:12:51 <Botje> no problem
09:16:00 <glguy> fizbin: For the most part people haven't found the Arrow class to be useful beyond providing a few combinators for working with tuples
09:16:24 <fizbin> And I'd love to ignore them. But HXT won't let me.
09:16:35 <shachaf> glguy: That hierarchy could use some restructuring.
09:17:22 <elliott> fizbin: What Arrow experts?
09:18:45 <quicksilver> haxml + hxt convinced me that arrows are a useful shape of thing to consider
09:19:00 <quicksilver> but haxml appears to show that the type class, per se, isn't that helpful
09:19:39 <Eelis> don't arrows have some applications in certain kinds of parsers?
09:19:54 * glguy initially read that as "certain kinds of papers"
09:20:05 <quicksilver> yes, they do Eelis
09:20:09 <shachaf> quicksilver: Profunctors are a better foundation for this abstraction.
09:20:10 <quicksilver> as an algebraic construct definitely.
09:20:25 <quicksilver> Eelis: but the actual notation never convinced me
09:20:27 <fizbin> Well, the feeling of pain and frustration I'm seeing now with arrows feels like what it felt like to slam into monads before I figured them out. Therefore, I assume the rest of that holds: that there are Arrow experts who will unhelpfully tell me that I'm thinking about them wrong and should consider burritos.
09:20:31 <quicksilver> compared to combinator naturally.
09:20:35 <Eelis> quicksilver: fair enough
09:20:45 <quicksilver> shachaf: what does that mean?
09:21:18 <shachaf> A hierarchy that starts with profunctors makes a lot more sense than one that starts with Category and adds the Arrow methods.
09:21:43 <shachaf> We came up with a partial one for lens.
09:22:04 <edwardk> that said, we're still quibbling over particulars though ;)
09:22:23 <quicksilver> shachaf: for the specific application of parsers and transformers?
09:22:35 <edwardk> Eelis: the arrow role for parsers is actually better served by applicatives.
09:22:44 <quicksilver> parsers and transformers are what convinced me that arrows are useful
09:22:51 <shachaf> For the general idea of things with the shape of arrows.
09:23:01 <shachaf> Profunctoriality is relaly the one fundamental thing about that shape.
09:23:08 <shachaf> More than, say, composition or identity.
09:23:10 <edwardk> Eelis: an applicative grammar properly captures 'context free', a monadic grammar properly captures 'context sensitive'. arrow is a weird point in between that is both too big and too small.
09:23:15 <quicksilver> a -> [b] is a transformer for which you can apply to a bunch of as inside a structure
09:23:16 <shachaf> Lots of things have the shape but don't have identity.
09:23:38 <quicksilver> certainly I used the fact that (a->).[] was an applicative
09:23:43 <quicksilver> much more often than anything else
09:23:48 <quicksilver> in building these up
09:23:52 <quicksilver> edwardk: ^^ is that what you mean?
09:24:25 <edwardk> quicksilver: i mean that swierstra and duponcheel's parsers which were the original motivation for arrows are better implemented as applicatives. they don't use the arrow-ness at all.
09:24:38 <edwardk> but we didn't have the notion of applicative at the time
09:24:46 <edwardk> so they were built into something bigger than it needed to be
09:25:16 <quicksilver> right.
09:25:30 <quicksilver> edwardk: and is 'the applicative' you're talking about, the partially applied arrow?
09:25:44 <quicksilver> edwardk: is it the (a ~>) applicative for the array ~>
09:25:48 <quicksilver> arrow.
09:25:58 <edwardk> and we can generalize many of the constructions in arrow to more general signatures. instead of first and second, it can use an arbitrary copointed functor p a b -> p (f a) (f b)  and left and right can repeat the same for an arbitrary pointed functor p a b -> p (f a) (f b), we can lift traversals, etc.
09:26:15 <shachaf> "context free" was the idea that made Applicative make sense for me.
09:26:37 <shachaf> I mean, make sense in a way other than "just a couple of monad methods put in their own class for some reason".
09:26:38 <edwardk> quicksilver: in the same sense that a monad m is a partially applied ArrowApply, yes.
09:26:57 <edwardk> the arrow requires us to spend a lot of time mucking around with an argument we don't need for composition we don't want
09:27:53 <quicksilver> edwardk: to be clear my question was; if the S-D parsers are implemented "as applicatives" is that applicative essentially the one which comes from the partially applied arrow? Or is there *another* way of looking at S-D parsers as a different applicative?
09:28:14 <edwardk> quicksilver: your intuition is correct
09:29:39 <edwardk> quicksilver: arrows gained traction between there was 13 years between swierstra and duponcheel's parser and the invention of Applicative.
09:29:44 <edwardk> er because there
09:29:52 * quicksilver nods
09:30:08 <quicksilver> if I had another excuse to write the transformer stuff again I'd think about it again
09:30:08 <fizbin> I just wish I could drop stuff in and out of the arrow world easily. E.g., I've got all these things that have signatures like (Tree t, ArrowTree a) => a (t b) b and I want to view them as just a ((t b) -> b), because I've got a (t b) and want a b, and just want to do my damn work. I don't really care about building up an abstraction of ways one might consider turning a (t b) into a b.
09:30:13 <shachaf> If only some of the effort put toward crazy arrow notation was put toward Applicative notation!
09:30:23 <edwardk> shachaf++
09:30:45 <fizbin> This "get out of my way and just let me do my domain-specific stuff" is the same feeling I had towards monads.
09:31:12 <Saizan> fizbin: arr?
09:31:17 <hpc> @quote yarr
09:31:18 <lambdabot> hpc says: yarr, arr be rather arr-bitrary
09:31:44 <fizbin> Saizan: I actually want something like the inverse of arr
09:31:51 <fizbin> :t arr
09:31:53 <lambdabot> Arrow a => (b -> c) -> a b c
09:31:53 <quicksilver> edwardk: at the time I was writing that code, it wasn't widely known in this channel that partially applied Arrows were applicative
09:31:58 <quicksilver> edwardk: I thought I'd found something new :)
09:32:10 <edwardk> quicksilver: =)
09:32:10 <quicksilver> edwardk: although, of course, other people did know, just not the people I was talking to
09:32:51 <shachaf> fizbin: That defeats the purpose.
09:33:15 <edwardk> fizbin: look magic. inverse arr: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/Context.hs#L351 =)
09:33:44 <fizbin> shachaf: I know you are not being hostile, but it is hard to avoid a bit of a hostile reaction to that statement.
09:33:56 <edwardk> any arrow representable by a comonad admits an 'unarr'
09:34:32 <edwardk> if p a b  is isomorphic to a -> w b  such that w offers an 'extract' method w b -> b  then you can get a -> b out of p a b
09:35:16 <edwardk> Monoid m => a -> m -> b        a -> (m, b)     a -> Identity b   each offer this notion.
09:36:00 <fizbin> That is, I don't want to use arrows, really, but HXT is full of them. I don't understand why, I "just" want to run the functions HXT seems to have in a straight-forward manner. I really don't care about any further point of arrows.
09:36:11 <shachaf> fizbin: What should I say?
09:36:32 <Saizan> fizbin: it's not the point of arrows, it's the point of HXT
09:36:56 <Saizan> fizbin: it is using the extra structure of arrows to implement those functions, you can't just pretend it to go away without addressing it
09:37:14 <Saizan> fizbin: basically look for the runX and friends combinators
09:37:34 <fizbin> Look where? The type of runX is a bit involved.
09:38:01 <fizbin> That is, runX seems to be implying some sort of surrounding IO monad.
09:38:08 <sclv> hxt is such a dead end
09:38:08 <fizbin> I think. Maybe.
09:38:11 <sclv> it drives me nuts
09:38:17 <Saizan> yes, runX needs the IO monad
09:38:38 <Saizan> you might get away with a simpler arrow type, though, those would be the friends
09:38:59 <Saizan> ArrowTree has LA and SLA as instances
09:39:17 <fizbin> But what if I've already gotten my XmlTree and just want plain ordinary pure functions? I should use runLA?
09:39:24 <Saizan> yeah
09:40:38 <fizbin> Okay, I guess I can see that and it makes sense to me.
09:40:41 <Saizan> (i don't much like the huge classes of HXT either, nor the Arrowy nature, but that's another point)
09:41:29 <msxx> how can I get an element from an MArray?  I am reading http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text-Array.html#t:MArray but I don't see a way to do it
09:42:42 <msxx> oh, there is unsafeIndex
09:43:42 <fizbin> I still get thrown by functions (like HXT's getNode) that have as a type signature a type variable that doesn't appear anywhere else. It twists my mind that getNode can be any ArrowTree type.
09:44:36 <fizbin> Which isn't something unique to Arrows, I know, it's a general Haskell behavior done all the time. Still, HXT and its Arrow stuff seem to throw that kind of thing in my face more than I'm used to.
09:45:14 <fizbin> :t Text.XML.HXT.Core.getNode
09:45:15 <lambdabot> Couldn't find qualified module.
09:45:24 <Saizan> it's a method of the class..
09:45:46 <fizbin> :t Control.Arrow.ArrowTree.getNode
09:45:48 <lambdabot> Couldn't find qualified module.
09:45:51 <shachaf> @ty mempty
09:45:52 <lambdabot> Monoid a => a
09:46:03 <fizbin> :t getNode
09:46:04 <lambdabot> Not in scope: `getNode'
09:46:11 <shachaf> HXT isn't in lambdabot.
09:46:25 <shachaf> I think almost no one actually cares about HXT. I might be wrong, though.
09:46:29 <fizbin> Nor, it seems, is Control.Arrow.ArrowTree
09:46:48 <fizbin> Yeah, if I didn't have to eat XML I wouldn't care about it either.
09:46:56 <shachaf> Given that that module is part of HXT, I'm not surprised.
09:46:57 <Saizan> there are other XML libs
09:48:10 <fizbin> Yeah, I think I chose poorly and may see how much work it would be to rip this stuff out and go to HaXml
09:48:37 <Saizan> i'm not sure if HaXml is the best option either
09:50:24 <fizbin> Ooh, yeah - LGPL may be a no-go in this environment.
09:52:32 <Saizan> weird they are all based around String rather than Text
09:52:45 <Saizan> seems like there hasn't been much use for XML recently
09:53:12 <glguy> or people have been working with small amounts of XML and haven't worried about converting?
09:53:50 <Saizan> oh, xml-conduit uses text
09:53:59 <shachaf> Yes, but it also uses conduit.
09:54:19 <Saizan> glguy: i guess
09:54:46 <Saizan> glguy: maybe the SAX-like packages are more focused on this
09:56:30 <sclv> for just parsing out of xml i recommend tagsoup
09:56:36 <sclv> its lightweight, efficient, and easy
09:56:37 <sclv> i
09:56:38 <sclv> t
09:56:39 <sclv> 
09:57:13 <sclv> erm, it doesn't do schema validation type stuff, and it isn't good for generation. but for just sucking out some data, its extremely easy
09:57:14 <fizbin> sclv: why tagsoup instead of just xml ? (Text.XML.Light)
09:57:28 <sclv> the tagsoup api is awesome to use
09:57:53 <sclv> walking the structure with xml is a bit more complicated
09:58:20 <sclv> haxml and hxt both predate Text is why they're built how they are
09:59:05 <fizbin> Well, I will be walking the structure all over in many different ways, so that is an argument in tagsoup's favor.
09:59:38 <HugoDaniel> shachaf: conduit is not bad
10:25:20 <BlindRadish`> Question!
10:25:27 <BlindRadish`> "MVar operations are always observed to take place in the order they are written in the program, regardless of the memory model of the underlying machine. This is in contrast to IORef operations which may appear out-of-order to another thread in some cases."
10:26:00 <BlindRadish`> If I have some state I need to lock/unlock but don't care about what order it occurs in, should I use MVar or IORef?
10:26:16 <glguy> You can't lock an IORef
10:26:27 <merijn> BlindRadish`: MVar is probably best
10:27:09 <BlindRadish`> Hmm.  Will MVar be forced to execute everywhere it comes up?  Or is it lazy, but lockable?
10:27:27 <merijn> MVar is a container that is potentially empty
10:27:33 <mauke> BlindRadish`: huh?
10:27:35 <glguy> neither ioref nor mvar are strict in the value you write to them
10:27:50 <BlindRadish`> I literally don't care about the order or even if it runs unless I need output.  I just need to make sure it blocks parallel use.
10:27:51 <merijn> i.e. you can read or write a value into it, if it is empty, then reading from it will block. If it is full then writing to it will block
10:28:16 <merijn> BlindRadish`: You can just use modifyMVar to take out the state, modify it and then put it back
10:28:22 <mauke> BlindRadish`: do you happen to know what a "patch pumpkin" is?
10:28:28 <BlindRadish`> Nah
10:28:45 <BlindRadish`> so it will only take it out if it needs it right?  lazily?
10:29:04 <BlindRadish`> if I use modify and the code reaches that point, will it be strict or lazy?
10:29:10 <merijn> I don't understand what that means
10:29:30 <BlindRadish`> I'm not even sure that scenario exists lol.
10:29:43 <BlindRadish`> "Like many other Haskell data structures, MVars are lazy. This means that if you place an expensive unevaluated thunk inside an MVar, it will be evaluated by the thread that consumes it, not the thread that produced it. Be sure to evaluate values to be placed in an MVar to the appropriate normal form, or utilize a strict MVar provided by the strict-concurrency package."
10:29:52 <BlindRadish`> wtf is a thunk?
10:29:59 <BlindRadish`> what the thunk?
10:30:16 <mauke> meh
10:30:23 <mauke> I think you can actually ignore this
10:33:01 * hackagebot select 0.4.0.1 - Wrap the select(2) POSIX function  http://hackage.haskell.org/package/select-0.4.0.1 (GardSpreemann)
10:33:38 * startling thunks BlindRadish` 
10:34:31 <BlindRadish`> ow... alright i get it.
10:34:36 <BlindRadish`> :D
10:35:36 <merijn> BlindRadish`: Thunk is the haskell term for a computation that "hasn't been done yet" (for some definition of hasn't and done)
10:36:02 <BlindRadish`> ah i got it now
10:36:14 <BlindRadish`> so i can thunk a modify MVar
10:36:20 <BlindRadish`> ?
10:36:21 <merijn> BlindRadish`: i.e. "[1..]" doesn't return an infinite list, it returns a thunk for creating an infinite list. When you evaluate it, it will return a (:) and a thunk for 1 and a thunk for the remainder
10:36:42 <BlindRadish`> i see!
10:36:51 <geekosaur> you could think of it as a function that, when run, will do the computation.  (in fact any non-strict operation is a thunk that will be run when its value is needed)
10:37:08 <merijn> BlindRadish`: It means "if you do "reallyExpensiveComputation x" and put the result in the MVar, then the reallyExpensiveComputation might not have actually been done yet
10:37:26 <merijn> BlindRadish`: Which doesn't really matter, unless you planned to run multiple computations in parallel
10:37:29 <BlindRadish`> got it
10:37:51 <BlindRadish`> got it got it
10:38:07 <BlindRadish`> i do plan to do many in parallel
10:39:02 <SamanthaD> merijn: I don't see how you can say that it doesn't really matter. Lazy evaluation might mean that reallyExpensiveComputation x might not need to be fully evaluated at all.
10:39:22 <BlindRadish`> the more it runs out of order, the better :D
10:39:29 <BlindRadish`> in this case.
10:39:57 <SamanthaD> BlindRadish` what are you up to?
10:40:05 <geekosaur> sometimes.  what you need to watch out for is everything staying a thunk/potential computation until you go to print the result and it has to compue everything right then to do it :)
10:40:06 <BlindRadish`> prng
10:40:11 <BlindRadish`> multithreading
10:40:12 <merijn> SamanthaD: I mean that if you don't expect to compute in parallel, then it doesn't matter *when* it is evaluated (i.e. before writing to the MVar or after Reading from it)
10:40:50 <BlindRadish`> it can run in any order in multiple threads, but not in parallel.
10:41:00 <BlindRadish`> but i'm going to catch parallel and pass it to another prng
10:41:30 <geekosaur> although sometimes that is what you want, because the print routine can then pick and choose what it wants to print, and hence what will be evaluated, which means you can avoid computing expensive stuff that it doesn't care about
10:41:43 <SamanthaD> merijn: Oh! That makes sense. I remember back when I was first getting introduced to Haskell concepts I thought that lazy evaluation might cause the computer to "back up" which I guess is true if you're doing concurrency but with single threads it just means that you get there faster anyway so...
10:41:53 <SamanthaD> merijn: But yeah, I see what you're trying to say.
10:42:37 <BlindRadish`> thanks guys!
10:43:03 <BlindRadish`> hey should i get a dedicated irc?
10:43:19 <BlindRadish`> i'm just using the web one, is the difference worth doing
10:43:19 <BlindRadish`> ?
10:43:42 <quchen> Is there some way I can use data/type/newtype in a let environment?
10:43:50 <zomg> BlindRadish`: depends, with 'dedicated' irc clients you can get logging, and they'll remember your settings, channels etc.
10:43:55 <shachaf> quchen: No.
10:43:56 <SamanthaD> BlindRadish` You mean a dedicated IRC client? I think so. I use XChat.
10:44:02 <merijn> quchen: That question doesn't make sense?
10:44:11 <zomg> BlindRadish`: so if you need more features then sure, but if you're just chatting on a single channel and don't need that stuff then web based ones will probably work fine too
10:44:20 <quchen> merijn: It would, if your program was constrained to be a single statement.
10:44:37 <quchen> Well, CPP it is then
10:44:38 <SamanthaD> quchen: Why would you want to do something like that?
10:45:48 <BlindRadish`> SamanthaD: maybe he's using prompt? i had the urge to plug in single line programs back when i was getting started.
10:45:54 <quchen> SamanthaD: Was just wondering.
10:46:02 <shachaf> You can define data types in ghci
10:46:05 <shachaf> That's a different story
10:46:07 <BlindRadish`> quchen: always good to wonder!
10:46:14 <BlindRadish`> shachaf: I could never get it to work!
10:47:15 <SamanthaD> quchen: Oh, I see! Anyway, if you really needed to define a datatype that you don't export you could always use a module. And tuples are good for local data structures assuming you don't need multiple data constructors...
10:48:23 <quchen> SamanthaD: I can't import stuff as well.
10:48:30 <quchen> Prelude only. :s
10:48:51 <quchen> Trying to get a minimal parser running.
10:48:55 <SamanthaD> quchen: Uh oh... did you break something?
10:49:53 <quchen> SamanthaD: Don't worry, everything's fine. I'm quchen, not IO quchen
10:49:53 <BlindRadish`> quchen: reload everything!
10:50:20 <BlindRadish`> hey why does this run? newMVar 1, how do I name that??
10:50:40 <BlindRadish`> myVar <- newMVar 1?
10:50:50 <c_wraith> yes
10:50:59 <BlindRadish`> <- confuses me so badly.
10:51:00 <SamanthaD> BlindRadish: Uhm... that would be a bind
10:51:16 <BlindRadish`> this <- is a bind?
10:51:21 <SamanthaD> BlindRadish` Yes!
10:51:24 <BlindRadish`> I thought >>= was a bind.
10:51:35 <SamanthaD> BlindRadish` You are talking about <- in do notation, right?
10:51:41 <shachaf> BlindRadish`: Maybe you should learn more about how IO works in Haskell before writing this program.
10:52:01 <BlindRadish`> SamanthaD: SamanthaD, I have no idea what I'm talking about. :D
10:52:16 <SamanthaD> BlindRadish`: b <- a is the same as a >>= (\b -> stuff)
10:52:29 <BlindRadish`> shachaf: I almost got it!
10:52:40 <shachaf> Almost got what?
10:52:50 <bitonic> how does one document the argument of a data constructor which is not a record?
10:52:58 <BlindRadish`> shachaf: the kind of program i was to write completed!
10:53:39 <BlindRadish`> I'll read up on binds.
10:53:44 <BlindRadish`> SamanthaD: thanks!
10:53:56 <SamanthaD> BlindRadish`: or alternatively... let m args = {stuff} in input >>= m
10:53:57 <BlindRadish`> shachaf: will read more
10:54:34 <SamanthaD> BlindRadish: Real World Haskell has a good article on it in the chapter or Monads called "Desugaring do notation"
10:55:21 <BlindRadish`> SamanthaD: RWH has been a great help but i haven't read it that thoroughly yet.  Thanks!
10:56:17 <SamanthaD> BlindRadish` I know a lot of people prefer using plain old >>= rather than do notation. I like using >>= when possible because it lets me use guards and I absolutely love using guards. That being said... foregoing do notation does come at the cost of your code slowly marching across the screen ;)
10:56:27 <SamanthaD> BlindRadish` also, you can combine them.
10:57:28 <startling> some things are better expressed in do notation. some things are better expressed with >>=/>>
10:57:49 <startling> BlindRadish`: you can also look at @undo
10:58:05 <startling> @undo do { a <- b; c <- d a; return c; }
10:58:07 <lambdabot> b >>= \ a -> d a >>= \ c -> return c
10:59:05 <SamanthaD> BlindRadish`: Oh yeah! New lines in do notation correspond to >> which is just a >>= that throws out the bound variable.
10:59:07 <S11001001> use >=> instead of >>=, then you can flatten your screen columns in the same way as with compose chains, just don't use earlier bindings :)
10:59:26 <shachaf> use monoids
10:59:27 <jesyspa> Hm, that's the same as b >>= d, isn't it?
10:59:28 <shachaf> monoids are so easy
11:00:12 * owst still doesn't understand this "use monoids; monoids are so easy" thing that shachaf has going on every few days
11:00:45 <shachaf> Well, do you deny that they're easy?
11:01:02 <SamanthaD> shachaf: Monads are plenty easy too, though...
11:01:08 <Saizan> owst: nobody does, don't worry
11:01:09 <owst> For who?
11:01:28 <geekosaur> we've secretly replaced shachaf with a monoid, let's see if anyone notices
11:04:17 <owst> What's the recommended way of deprecating a package on hackage? I've seen recommendation/examples of "deprecated" appearing in the package synopsis, or emailing someone (who?) and asking for the package to be marked as obsolete. What's the current best approach?
11:04:39 <shachaf> Email Ross.
11:05:32 <BlindRadish`> haskell is crazy.
11:05:38 <owst> Right, thanks
11:06:06 <BlindRadish`> needs more sugar lol
11:07:06 <ParahSailin> 404: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-ForeignPtr.html
11:08:06 <startling> ParahSailin: ugh
11:10:08 <merijn> owst: My current theory is that shachaf became a little kooky from all the lens code :)
11:10:50 <merijn> I can picture him in a straight jacket babbling about prisms and monoids :p
11:11:10 <ParahSailin> @hoogle withForeignPtr
11:11:12 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
11:11:22 <ParahSailin> well, at least i can get docs that way
11:11:24 <edwardk> sorry about that. for the good of the many i imprinted a bit too much of my consciousness upon him.
11:11:38 <shachaf> http://images1.wikia.nocookie.net/__cb20121226075034/cnc/images/8/87/Prism_Tower.jpg
11:11:57 <ParahSailin> @src withForeignPtr
11:11:58 <lambdabot> Source not found. :(
11:12:03 <merijn> shachaf: Man, RA2 was awesome :>
11:12:15 <ParahSailin> @hoogle foreignptr
11:12:15 <lambdabot> Foreign.ForeignPtr module Foreign.ForeignPtr
11:12:15 <lambdabot> Foreign.ForeignPtr data ForeignPtr a
11:12:15 <lambdabot> Foreign.ForeignPtr addForeignPtrFinalizer :: FinalizerPtr a -> ForeignPtr a -> IO ()
11:15:34 <ParahSailin> at least there's http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/Foreign-ForeignPtr-Safe.html
11:20:50 <Eduard_Munteanu> Hrm, what's a nice  (Monad m) => Maybe a -> MaybeT m a   ?
11:20:56 <fizbin> What's the difference between declaring data Foo = Foo { bar :: Bar } and the same with "newtype" instead?
11:21:00 <mauke> :t lift
11:21:08 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
11:21:48 <n-dolio> Wrong lift.
11:21:49 <Eduard_Munteanu> mauke: um, that translates to  m a -> MaybeT m a
11:22:00 <Eduard_Munteanu> I'm looking for a  liftMaybe  of sorts.
11:22:29 <mauke> maybe nothing just
11:22:37 <mauke> where nothing = ?; just = ?
11:23:16 <Eduard_Munteanu> :t MaybeT . return
11:23:25 <lambdabot> Not in scope: data constructor `MaybeT'
11:23:39 <Eduard_Munteanu> Bah.
11:23:55 <Eduard_Munteanu> :t Control.Monad.Trans.Maybe.MaybeT . return
11:24:00 <lambdabot> Monad m => Maybe a -> Control.Monad.Trans.Maybe.MaybeT m a
11:24:11 <Eduard_Munteanu> But it's kinda ugly.
11:25:12 <n-dolio> unsafeCoerce . return
11:25:46 <Eduard_Munteanu> fizbin: the newtype wrapper is peeled away at runtime
11:25:54 <Eduard_Munteanu> n-dolio: heh
11:26:04 <n-dolio> That one requires an annotation to disambiguate.
11:26:21 <fizbin> Okay, but so far as hiding the constructor of my Foo type, both are equivalent?
11:26:22 <startling> fizbin: nothing semantically
11:26:27 <parcs> fizbin: http://www.haskell.org/haskellwiki/Newtype
11:26:40 <startling> fizbin: but newtypes are exclusively compile-time
11:26:48 <Eduard_Munteanu> fizbin: that doesn't do anything to hide constructors.
11:27:05 <fizbin> Oh, an actually useful haskellwiki page.
11:27:09 <startling> fizbin, so using newtype rather than data can be more performant
11:27:15 <merijn> startling: bzzzt
11:27:23 <parcs> fizbin: not sure what that means. there are lots of useful haskellwiki pages
11:27:24 <merijn> startling: Wrong, newtype has different semantics from data
11:27:32 <startling> merijn: what are they?
11:27:50 <startling> oh, bottom
11:27:55 <Eduard_Munteanu> Also, newtypes let you use generalized newtype deriving (which lets you derive any class that's supported by the wrapped type)
11:27:58 <merijn> startling: Yeah
11:28:06 <fizbin> parcs: Sorry, I was burned this morning by reading haskellwiki/Case expecting it to remind me of "case" syntax.
11:28:51 <startling> fizbin: haha. :(
11:29:00 <fizbin> Which, I know, I should read a bunch of haskell before getting back to using it again, but it'd be nice if that page's content were related to the title.
11:29:19 <Eduard_Munteanu> Anyway, the reason I was asking is there are lots of functions around that return maybes, and I figure there should be an elegant way to get them working with MaybeT.
11:30:19 <Eduard_Munteanu> fizbin: I'd use the "Gentle Introduction" as a quick reminder
11:30:31 <Eduard_Munteanu> @where gentle
11:30:32 <lambdabot> http://www.haskell.org/tutorial/
11:33:04 <merijn> fizbin: If you need syntax reminders: http://cheatsheet.codeslower.com/
11:33:25 <fizbin> merijn: Oooh. That's nice.
11:33:27 <merijn> That's a fairly extensive haskell syntax cheat sheet there
11:33:41 <fizbin> I think I saw that several months ago, but had forgotten.
11:34:21 <parcs> > 150 + 150 :: Word8
11:34:25 <lambdabot>   mueval-core: Time limit exceeded
11:34:57 <fizbin> > (150 + 150) :: Word8
11:34:59 <lambdabot>   44
11:36:49 <basdirks> > maxBound :: Word8
11:36:51 <lambdabot>   255
11:37:02 <fizbin> > 150 :: Word8
11:37:05 <lambdabot>   150
11:37:32 <fizbin> > 150 :: Word8 + 150 :: Word8
11:37:33 <lambdabot>   <hint>:1:16: parse error on input `150'
11:37:55 <basdirks> > (150 :: Word8) + (150 :: Word8)
11:37:57 <lambdabot>   44
11:38:55 <spindles> Hi, I'm new novice learner here.. and have a question to ask while doing some exercises going lyah.  Not sure if I'd interrupt anything
11:39:22 <basdirks> spindles: go ahead
11:39:39 <basdirks> always welcome to ask questions
11:40:14 <spindles> is "cross" definition allowed when declaring enum? If not, what would be a good alternative? An example coming up
11:40:36 <basdirks> you can paste examples at hpaste.org
11:40:38 <basdirks> @hpaste
11:40:38 <lambdabot> Haskell pastebin: http://hpaste.org/
11:41:11 <Eduard_Munteanu> spindles: you should provide some context, e.g. a link to the exercise etc.
11:42:48 <spindles> data Card = Ace | 1 | .. | 10 | Jack | Queen | King | Joker, and then data Suit = Spade | Club | Diamond | Heart both deriving (Show, Read, Eq, Ord, Enum, Bounded).  Now say the game has some special definition where data BonusWild = Ace | Joker (so ace and joker are wildcards...)
11:43:12 <mauke> the definition of Card is a syntax error
11:43:24 <mauke> the definition of BonusWild tries to redefine Ace and will fail
11:43:54 <spindles> mauke: i know, i didn't wanna write out the whole 1 | 2 | all to 9 | 10 | ...
11:44:05 <mauke> wat
11:44:13 <mauke> writing a longer syntax error won't make it valid code
11:44:14 <Eduard_Munteanu> spindles: constructors can't be numbers
11:44:14 <fizbin> Is there a standard function that is of type Bool -> Maybe () ?
11:44:14 <scooty-puff> i think thats what he's going for - depending on use, you could have data Card a where Ace :: Card Wild or something
11:44:41 <Eduard_Munteanu> spindles: they need to be unique, capitalised names
11:45:04 <scooty-puff> spindles: are you going for something comparable to polymorphic variants?
11:45:15 <Eduard_Munteanu> spindles: you could name them C1, C2 ... though
11:45:20 <spindles> Ok, got it on the unique and capitalized name part, will change it
11:46:09 <fizbin> Ah, guard will do it.
11:47:16 <spindles> I am not sure if i learned about polymorphic variants yet.  I am looking for a way to do some maybe vector crossing data.  So in this case, any of the Card value can of of any Suit value, but with out having to do a lot of function -> bool to check if something is wild, something is bonus etc
11:47:16 <clahey> spindles: Could you do what you want with a function Card -> bool?
11:47:36 <clahey> spindles: What's wrong with having those functions?
11:48:25 <spindles> i guess if a game is complex enough and has a lot of special rules, then i would write a lot (not that i mind much)?
11:49:07 <byorgey> if a game is complex and has a lot of special rules then you're going to have to write a lot of *something*.
11:49:12 <clahey> spindles: Say you could do what you wanted with BonusWild = Ace | Joker.  How would you imagine using that?
11:49:39 <tdammers> clahey: pattern matching?
11:49:51 <spindles> clahey: say a quick way to check if a certain card is wild / bonus / etc...
11:49:51 <mauke> tdammers: less vague, please
11:50:01 <mauke> spindles: yes, how would you check that?
11:50:53 <spindles> make a function with something like any (== Card) BonusWild  without having to type out Ace | Joker
11:50:54 <parcs> > maxBound*maxBound :: Word8
11:50:55 <tdammers> sth like isWild (Card a _) = case a of { Ace -> True; Joker -> True; otherwise -> False }
11:50:56 <lambdabot>   1
11:51:04 <elliott> fizbin: using guard for that purpose is clever!
11:51:19 <tdammers> or guards, indeed
11:51:21 <mauke> spindles: that's not even close to valid Haskell
11:51:33 <clahey> spindles: So just write the function tdammers has there and use it.
11:51:34 <tdammers> or just three patterns for that function
11:51:39 <mauke> tdammers: your use of 'otherwise' saddens me
11:51:51 <tdammers> mauke: why so?
11:51:57 <clahey> tdammers: I think it's the same in the end, but:
11:52:02 <fizbin> elliot: Not so much "clever" as "that's what hoogle gave me"
11:52:09 <mauke> tdammers: because it indicates a misunderstanding of pattern matching
11:52:33 <clahey> isWild Card Ace _ = True; isWild Card Joker _ True; isWild _ = False
11:52:36 <clahey> is more readable.
11:52:39 <tdammers> mauke: hmm... care t elaborate?
11:52:43 <clahey> (With separate lines instead of ;.)
11:52:45 <mauke> clahey: and a syntax error
11:52:52 <byorgey> tdammers: otherwise = True, it's for use in guards
11:53:01 <clahey> mauke: Oh, cause I missed the =?
11:53:07 <mauke> tdammers: 'otherwise' is a random variable you're binding there
11:53:12 <tdammers> ah
11:53:13 <tdammers> right
11:53:18 <clahey> mauke: I've seen that usage recommended.
11:53:19 <byorgey> tdammers: as a pattern, it matches anything, but so would any other variable name; if you're not using it, it's best to use _
11:53:27 <mauke> clahey: what would the type of isWild be?
11:53:28 <tdammers> right
11:53:43 <basdirks> isWild (Card a _) = a `elem` [Ace, Joker] ?
11:54:03 <tdammers> I've seen it in example code, and I like how it signals what it is about
11:54:03 <spindles> Ok, so i take it the constants defined in data x = a | b | c are not symbolic evaluated where a could be data a = d | e | f, so you would in the end has a composite of data x = (d | e | f) | b | c
11:54:13 <clahey> mauke: I was assuming the same type that tdammers was in his statement, not using the original type.
11:54:15 <tdammers> but yeah, _ is more idiomatic, in the end
11:54:23 <clahey> mauke: So it would be Card -> bool.
11:54:26 <mauke> tdammers: except in this case it signals that you have no clue what you're doing
11:54:34 <clahey> Where data Card = Card rank suit
11:54:43 <mauke> clahey: then 'isWild Card Ace _' is not valid code
11:54:43 <clahey> data Rank = Ace | Two...
11:54:50 <basdirks> Bool, not bool
11:54:58 <clahey> basdirks: Of course.
11:55:06 <clahey> mauke: Ah, parentheses.
11:55:21 <clahey> isWild (Card Ace _) = True; isWild (Card Joker _) = True; isWild _ = False
11:55:22 <hpaste> scooty-puff pasted ‚ÄúCards‚Äù at http://hpaste.org/81537
11:55:32 <clahey> Better?
11:55:39 <scooty-puff> spindles: that may or may not be comparable to what you want - i left the suit off for simplicity
11:55:44 <mauke> yes
11:55:47 <spindles> clahey: Yep, thanks
11:56:14 <tdammers> mauke: my sincerest apologies, then
11:56:27 <basdirks> isWild (Card a _) = a `elem` [Ace, Joker] still seems more obvious to me
11:56:53 <clahey> basdirks: Does it get optimized down to the same thing?
11:56:59 <scooty-puff> basdirks: i guess it depends if you want static or dynamic determination
11:57:11 <mauke> especially since now you can do bonusWild = [Ace, Joker] and closely mimic the original idea
11:57:23 <clahey> The problem I see with scooty-puff's example is that the wildness of the card is encoded in the type of the cards, whereas it's actually data about the game.
11:58:07 <scooty-puff> though you could keep it unknown - though then would need either rank-n types or existential quantification to do it really dynamically
11:58:18 <scooty-puff> SomeCard = forall wild . SomeCard (Card wild)
11:58:25 <scooty-puff> but yeah, if its not needed or used, no point
12:04:18 <schellsan> i'm having a lot of 'Not in scope' errors while using persistent, my model constructors (which i'm exporting and importing) don't seem to exist in my other modules
12:04:29 <schellsan> has anyone ran into that?
12:05:57 <spindles> So is symbolic evaluation in enum definition allowed? Say the cards are ranked by AceSpade,  TwoSpace, ... , KingSpace, AceClub, ... KingClub, .. KingHeard, Joker.  Instead of making a giant data Cards = AceSpace ...Joker, define four separate data SpaceSuit, ClubSuit, etc, then then make data Cards = SpadeSuit | ClubSuit | DiamongSuit | HeartSuit | Joker deriving (Eq, Ord), so you can do TwoSuit `compare` ThreeHeard even though they are originally def
12:05:57 <spindles> ined in separately.
12:07:45 <Eduard_Munteanu> How do I do a fsync on a file? I take it hFlush isn't enough to guarantee the data hits the disk, is it?
12:08:13 <scooty-puff> data Suit = Hearts | Spades | Diamonds | Clubs; data Number = C1 | C2 | ...; data Card = Card Suit Number | Joker
12:09:06 <scooty-puff> Card Heart C2 `compare` Card Spade C3, assuming you add a deriving (Eq, Ord) to all of them
12:09:16 <merijn> Eduard_Munteanu: Even fsync assumes the disk controller and driver don't lie to you (they do)
12:09:27 <scooty-puff> though i'm not sure which suit you would expect to be greater than another, other than their order
12:09:43 <clahey> scooty-puff: Generally, if there's an order, it's Clubs Diamonds, Hearts, Spades.
12:10:05 <spindles> scooty-puff: ok, thanks
12:10:05 <clahey> scooty-puff: But this is the same situation where your order is game specific.
12:10:24 <Eduard_Munteanu> merijn: well, I'm assuming they don't, that'd break quite a few filesystems that rely on it for consistency
12:10:34 <merijn> Eduard_Munteanu: Yes, it does
12:11:05 <merijn> Eduard_Munteanu: FreeBSD has the option to turn that stuff off, but the performance is so terrible (and even then it's not always safe) that the default is on
12:11:32 <merijn> Eduard_Munteanu: This is why most modern file systems have journaling for consistency
12:11:50 <Eduard_Munteanu> Journalling itself relies on write barriers for instance.
12:12:25 <merijn> Eduard_Munteanu: It relies on barriers, but whether or not they succesfully make it to disk doesn't really affect the consistency
12:12:29 <fizbin> Hoogle fails me on this type: (a -> b) -> (a -> c) -> (b -> c -> d) -> a -> d
12:12:48 <fizbin> Is there a standard function with that type?
12:12:48 <Eduard_Munteanu> merijn: hm yeah, I guess only the ordering is guaranteed
12:12:53 <merijn> disk crash before the barrier hits the disk is indistiguishable from the disk crashing before the barrier
12:13:01 <merijn> So you maintain sequential consistency
12:13:21 <merijn> fizbin: Only if b and c are the same
12:13:23 <merijn> :t on
12:13:25 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:13:32 <Eduard_Munteanu> Normally, unless write caching is enabled (usually frowned upon), things aren't so grim.
12:13:47 <Eduard_Munteanu> I only need mild guarantees anyway.
12:14:08 <merijn> So I guess the more important question is what level on consistency your application really needs
12:14:13 <Eduard_Munteanu> e.g. I don't want to lose 5 mins of work or so.
12:14:28 <merijn> The OS should flush to disk long before then
12:14:37 <clahey> fizbin: undefined has that type.
12:14:47 <clahey> fizbin: As does const undefined.
12:14:52 <merijn> I think you can probably get away with hFlush and nothing else unless it's really critical
12:15:03 <clahey> Sorry, I know that's not useful.
12:15:10 <Eduard_Munteanu> Basically I'm logging some statistics to a file, and I don't want a crash / reboot / powerdown to make it lose a lot of records.
12:15:14 <fizbin> clahey: :p
12:15:22 <Eduard_Munteanu> merijn: hm, I see.
12:15:27 <clahey> @djinn (a->b) -> (a->c) -> (b -> c -> d) -> a -> d
12:15:28 <lambdabot> f a b c d = c (a d) (b d)
12:15:50 <clahey> I see that it's easy to write.
12:15:54 <merijn> I think FreeBSD for example syncs file blocks after 5s of inactivity (maybe even less), so 5 minutes of works seems really doubtful
12:15:55 <fizbin> I was thinking something where the definition would be‚Ä¶ Actually, yeah. That.
12:16:21 <clahey> I wonder if that's one of the combinators in To Mock a Mockingbird.
12:16:25 <merijn> Eduard_Munteanu: So I don't think it is worth the effort, unless it's unacceptable to have that happen like once every several K runs
12:17:12 <merijn> Eduard_Munteanu: Given the frequency of disk crashes and the frequency of syncing, I'd just go with an 1 in a very large number chance of losing a significant off work and say fuck it
12:17:25 <Eduard_Munteanu> Hm, fair.
12:17:33 <Eduard_Munteanu> Thanks.
12:18:14 <merijn> I think the odds of cosmic radiation corrupting your data are probably larger than the odds of losing more than 30s of work
12:18:41 <merijn> (Mind you, the odds of cosmic radiation corrupting your data are pretty significant in consumer drives :>)
12:19:26 <Eduard_Munteanu> I thought they mainly corrupt RAM or flip bits in semiconductors, generally.
12:19:40 <Eduard_Munteanu> Not so sure about drives.
12:19:44 <merijn> That too
12:19:57 * geekosaur knows several folks who do hard drive research.  they have very low opinions of consumer grade hard drives
12:20:13 <geekosaur> one of them has not much higher opinion of hard drives period...
12:20:20 <merijn> The universe is pretty malicious
12:20:29 <fizbin> @djinn (a -> Bool) -> (a -> Bool) -> (a -> Bool)
12:20:29 <lambdabot> f a b c =
12:20:29 <lambdabot>     case b c of
12:20:30 <lambdabot>     False -> a c
12:20:30 <lambdabot>     True -> False
12:20:39 * Eduard_Munteanu digs a big hole into the ground :P
12:22:21 <schellsan> are there any glaring gotchas wrt module import/export when using TH?
12:22:42 <geekosaur> then you get screwed by radon :)
12:23:01 <Eduard_Munteanu> Hrm, right. :(
12:23:48 <clahey> @pl  f a b c = case b c of False -> a c; True -> False
12:23:48 <lambdabot> (line 1, column 31):
12:23:48 <lambdabot> unexpected '>'
12:23:48 <lambdabot> expecting operator
12:24:14 <fizbin> :pl f a b c = (a c) || (b c)
12:24:36 <clahey> @pl f a b c = (a c) || (b c)
12:24:36 <lambdabot> f = liftM2 (||)
12:24:58 <fizbin> :t liftM2
12:24:59 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:25:05 <scooty-puff> :info (->)
12:25:10 <scooty-puff> bah
12:25:50 <clahey> I think the djinn gave you f a b c = not (b c) && a c
12:26:30 <fizbin> Right, but what I asked about was what I really wanted anyway
12:27:03 <clahey> fizbin: I figured.
12:28:10 <elliott> clahey: I don't think djinn ever uses not...
12:29:18 <fizbin> What module do I import to get the Monad instance for (->) ?
12:29:34 <fizbin> Sorry, for ((->) a)
12:29:45 <Eduard_Munteanu> Control.Monad.Instances I think
12:32:01 <clahey> elliott: It defined it using a case statement, but I think that was the result.
12:32:11 <elliott> hmm.
12:32:12 <elliott> okay
12:32:20 <elliott> it's just that it has no reason to ever negate a boolean
12:32:22 <elliott> because that never changes types
12:33:18 <fizbin> elliot: True, but it clearly wrote "case ‚Ä¶; True -> False"
12:34:44 * elliott didn't see djinn's output, so I can't comment, but I suspect it merely had a False case to try and use up more of its arguments (which it does), and then for the True case had to produce an arbitrary Bool, and picked False because it's listed first
12:35:03 <fizbin> Yeah, something like that.
12:35:34 <fizbin> @djinn (a -> Bool) -> (a -> Bool) -> (a -> Bool)
12:35:34 <lambdabot> f a b c =
12:35:34 <lambdabot>     case b c of
12:35:34 <lambdabot>     False -> a c
12:35:34 <lambdabot>     True -> False
12:35:45 <Eduard_Munteanu> Is there any point in using a STM TVar instead of a IORef for a simple shared memory location?
12:36:22 <Cale> Eduard_Munteanu: only if you're actually going to write STM transactions
12:36:22 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:50:49 <jonkri_> did you see my question?
12:51:05 <Eduard_Munteanu> jonkri_: no
12:51:12 <jonkri_> okay, here it goes
12:51:16 <jonkri_> what do you generally do when you want to be able to produce two kinds of errors for an Either e a function?
12:52:00 <fizbin> What's the higher level typeclass function that is implemented in Maybe by "mapMaybe"?
12:52:26 <opqdonut> fmap?
12:52:31 <fizbin> Is there one? Possibly in Alternative?
12:52:58 <opqdonut> oh, mapMaybe is (a -> Maybe b) -> [a] -> [b]
12:53:12 <fizbin> Yeah, not like fmap
12:53:26 <opqdonut> mapMaybe f xs = xs >>= maybeToList . f
12:53:37 <opqdonut> at least
12:53:54 <c_wraith> well, the first generalization is (Functor f) => (a -> Maybe b) -> f a -> f b
12:54:08 <c_wraith> Oh, but that doesn't work, right
12:54:14 <c_wraith> Functor isn't good enough
12:54:15 <Eduard_Munteanu> Or \f -> catMaybes . map f
12:54:44 <c_wraith> :t traverse
12:54:46 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:55:03 <opqdonut> traverse is almost
12:55:03 <c_wraith> That's not right, looks like
12:55:31 <c_wraith> it looks like it'd give you a Nothing if any of the function applications resulted in Nothing
12:55:42 <c_wraith> So even though the signature is close, the meaning is entirely different
12:55:57 <fizbin> To generalize, it seems to me that you need a sense of "is this result something I should skip", which feels to me like the kind of thing Alternative cares about.
12:55:58 <opqdonut> right, the failures propagate
12:58:36 <opqdonut> I'm not really sure what the generalized mapMaybe would do for containers other than lists
12:58:39 <opqdonut> e.g. trees
12:59:01 <opqdonut> trees with data in the nodes, that is
12:59:17 <c_wraith> Seems like it'd need some sort of Unfoldable class
12:59:20 <schellsan> turns out the errors i was getting were just in ghc-mod, not while actually compiling
13:00:42 <fizbin> opqdonut: Well, I was generalizing on the Maybe part of that, not the list part.
13:00:57 <Eduard_Munteanu> Maybe it makes sense for MonadFail stuff.
13:01:43 <fizbin> But if you were to generalize on the list part to trees, I assume that what you'd get is a tree with the same structure, except that where the function had yielded Nothing that branch (and all its children) would be gone.
13:04:11 <fizbin> Except of course then there's the issue of what the result is if the root's data yielded Nothing.
13:04:23 <c_wraith> empty tree time!
13:04:24 <fizbin> So maybe it doesn't make sense to generalize of the container.
13:06:47 <fizbin> I mean, if you had your tree type defined as data Tree = Branch Int Tree Tree | Leaf then you'd do:
13:07:51 <Eduard_Munteanu> Which is why I suggested stuff like MonadFail, MonadZero etc... generally anything which has an "empty" value.
13:08:17 <fizbin> generalizedMapMaybe f (Branch x lft rgt) = case (f x) of {Just y -> Branch y (generalizedMapMaybe f lft) (generalizedMapMaybe f rgt); Nothing -> Leaf}
13:08:42 <Eduard_Munteanu> Though I suppose it doesn't have to be a monad.
13:09:09 <tobiassjosten> I'm making a web crawler of sorts. It has two lists of URLs and I want the program to pop one URL from the first, test it, add it to the second list if successful. Then it should pop one from the second list and test that one as well, before adding it to a third "history" list.
13:09:22 <tobiassjosten> Only, I have nooo idea how to set this up with FP. Any pointers please?
13:10:23 <Eduard_Munteanu> tobiassjosten: are you making some sort of breadth-first traversal?
13:11:31 <fizbin> Hey, if I have a data type where the type name is the same as the only constructor, if I just export the type name does that export the contructor too?
13:11:49 <jonkri> why is the use of ErrorT usually a bad idea in the IO monad? i read somewhere that throwDyn should be used instead
13:11:54 <Eduard_Munteanu> fizbin: no
13:12:11 <tobiassjosten> Eduard_Munteanu: I don't think so, no. Basically I want to compare one site's paths to another's, to help catch mistakes when doing website migration work.
13:12:30 <Eduard_Munteanu> jonkri: I don't think it's a bad idea. :/
13:12:38 <fizbin> And without the constructor exported, people won't be able to destructure my type in pattern matches, correct?
13:12:57 <Eduard_Munteanu> fizbin: yeah
13:13:03 <Saizan> jonkri: the control flow in the resulting monad can be hard to reason about
13:13:22 <tobiassjosten> So I start with ["/"] for site 1 and [] for site 2. I request "/" from site 1, parse the response for links, add those to the site 1 list and then go on to check / for site 2 as well. If that makes sense?
13:13:57 <jonkri> Eduard_Munteanu: do you generally use ErrorT for any function that can result in an error or throw an exception? if so, how do you deal with IO exceptions?
13:14:23 <jonkri> Saizan: why is that?
13:15:17 <Eduard_Munteanu> jonkri: one can handle IO exception separately
13:15:32 <Eduard_Munteanu> (e.g. catch them)
13:15:58 <jonkri> i'm thinking about catching them and rethrowing them in the context of my error type. does that make sense?
13:16:11 <Eduard_Munteanu> Yeah.
13:18:16 <Eduard_Munteanu> I don't really see IO exceptions as idiomatic Haskell stuff, so I prefer Maybe, Either, Error ...
13:18:34 <jonkri> thanks for that :)
13:18:38 <jonkri> i think i agree
13:19:35 <Saizan> i think once you're in IO the api is mostly the same
13:19:52 <Saizan> so it's kind of a FUD to take ErrorT as more idiomatic
13:20:33 <Saizan> i guess the main drawback is that IO exceptions aren't marked in the type
13:20:45 <n-dolio> It's somewhat like checked vs. unchecked exceptions.
13:20:49 <Saizan> (i.e. which specific subset you are using)
13:22:41 <Eduard_Munteanu> Also, transformers generalize nicely to ST for example, I suppose.
13:22:53 <Saizan> otoh, ErrorT has the big downside of not interacting with callback apis
13:33:05 * hackagebot hpaco-lib 0.22.0.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.22.0.0 (TobiasDammers)
13:33:07 * hackagebot hpaco 0.22.0.0 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.22.0.0 (TobiasDammers)
13:34:07 <Eduard_Munteanu> I wonder if MonadState instances make sense for IO.
13:34:29 <Eduard_Munteanu> Similarly, MonadError or other stuff.
13:35:32 <glguy> Eduard_Munteanu: which 's' would you choose for: MonadState s (IO a)?
13:36:22 <Eduard_Munteanu> Right, I think the current MonadState isn't enough, just wondering.
13:37:08 <Eduard_Munteanu> Wait, I misread that.
13:38:00 <Eduard_Munteanu> Yeah, nevermind, this can't possibly work.
13:40:14 <monochrom> clearly, MonadState RealWorld IO :)
13:40:20 <Eduard_Munteanu> Hm, maybe this could work with a special transformer, e.g. MonadIO m => StateIOT s m a? I'm unsure.
13:41:15 <Eduard_Munteanu> Or perhaps any base monad which can hold a state.
13:42:01 <monochrom> see also: http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Mutable.html  "type IOVector = MVector ReadWorld" :)
13:42:02 <Saizan> MonadState s (ReaderT (IORef s) IO)
13:42:40 <Saizan> (you'd newtype that, and probably use MVar)
13:42:51 <Eduard_Munteanu> Hm, that might do.
13:44:54 <danr> Saizan: what, that doesn't make any sense? put the state both in State and in an IORef?
13:45:03 <danr> oh. now I get it. sorry
14:19:13 <schellsan> man - this not in scope stuff is discouraging...
14:21:07 <schellsan> in one file i export a bunch if constructors that are generated by persistent
14:21:19 <schellsan> then in another file i import that module
14:21:54 <schellsan> but those aren't in scope in my second module
14:22:14 <mauke> how do you export them?
14:23:14 <hpaste> schellsan pasted ‚Äúexport‚Äù at http://hpaste.org/81540
14:23:36 <glguy> You need to export the constructors, too
14:23:45 <glguy> e.g.: Maybe(..) or Maybe(Just,Nothing)
14:24:28 <schellsan> I thought Track and Msg were the contstructors
14:24:33 <monochrom> note that "module M(Maybe, Just, Nothing)" does not work. it has to be what glguy says
14:25:13 <mauke> schellsan: type constructors or data constructors?
14:25:53 <schellsan> here's where i get embarassed...i'm not sure...
14:26:08 <monochrom> read again what everyone has said. read completely.
14:26:22 <mauke> hmm
14:26:30 <mauke> schellsan: what do you mean when you say constructor?
14:26:52 <schellsan> well ghc is telling me the data contstructors are not in scope
14:27:17 <schellsan> but tbh i don't know the difference between type and data constructors
14:27:39 <schellsan> i know type is for making a type synonym and data is for making a new data structure
14:27:44 <mauke> data Bool = False | True
14:27:55 <mauke> 'Bool' is a type constructor, 'False' and 'True' are data constructors
14:28:05 <mauke> data Maybe a = Nothing | Just a
14:28:17 <mauke> 'Maybe' is a type constructor, 'Nothing' and 'Just' are data constructors
14:28:29 <schellsan> ah - thanks
14:29:10 <schellsan> i guess this is harder because TH is generating the type and data constructors for me
14:29:16 <schellsan> so i'm not sure what they are
14:29:33 <mauke> you can use wildcards to export them all
14:29:41 <mauke> <glguy> e.g.: Maybe(..)
14:29:41 <merijn> schellsan: There are wildcards
14:29:50 <glguy> They are going to be hard to use if you don't know what they are
14:30:05 <monochrom> you need to know at least the type constructor name
14:30:22 <monochrom> but once you know, it's life as usual
14:30:31 <mauke> monochrom: not even that if you omit the export list
14:30:35 <Clint> it is making you something like data Msg = Msg { msgTime :: UTCTime, msgBody :: Text }
14:30:48 <monochrom> oh heh, sure
14:31:17 <schellsan> right, right - getting rid of the explicit exports got rid of those errors
14:31:26 <Clint> so what you want to export is Msg(..)
14:31:50 <Clint> that will get you everything Msg-related except for MsgId
14:34:00 <schellsan> hmmm - changing it to Msg (..) yields "The export item `Msg(..)' suggests that `Msg' has (in-scope) constructors or class methods, but it has none"
14:36:11 <schellsan> but exporting everything works
14:37:24 <schellsan> k - i don't understand yet but thanks for your help
14:38:34 <geekosaur> because that warning is generated without being able to see the TH-generated constructors, probably, but they're there when the constructors are actually recorded in the .hi?
14:39:09 <geekosaur> TH kinda messes witht he compiler's brain
14:39:16 <geekosaur> (which is the whole point...)
14:39:39 <schellsan> that's what i was thinking, that it's because they aren't generated until "pre-compile" but exporting everything fixes the error, which to me is confusing
14:49:47 <hpaste> paf31 pasted ‚ÄúState Lens‚Äù at http://hpaste.org/81541
14:50:26 <edwardk> paf31: thats the approach used in the 'lenses' package
14:50:36 <ocharles> Any containers experts around? I have an (IntMap Foo), and I want all Foo's that have an index >= x
14:50:43 <paf31> edwardk: thanks, thats what i was going to ask :)
14:50:59 <edwardk> ocharles: http://www.haskell.org/ghc/docs/6.6/html/libraries/base/Data-IntMap.html#v%3Asplit
14:51:08 <glguy> split :: Key -> IntMap a -> (IntMap a, IntMap a)
14:51:17 <ocharles> hmm
14:51:19 * ocharles looksup split
14:51:20 <paf31> i've seen the lens type which abstracts over a functor, but i hadnt seen something like this ("state-action-lifting"?) before
14:51:34 <elliott> that representation is kind of awkward in general imo
14:51:38 <ocharles> glguy: I'll have to lookup x too, but that might well do the job
14:51:47 <ocharles> oh, splitLookup
14:52:02 <edwardk> paf31: yeah. i objected to it back in http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285 which is funny given that i've recanted and gone whole hog to the opposite extreme ;)
14:52:04 <BlindRadish> can someone help me out http://hpaste.org/81542
14:52:16 <BlindRadish> i'm doing something wrong
14:52:27 <niklasb> hi. so I have this program that basically generates lots of objects and puts them into a simple index (a strict HashMap). It's taking about 10x as much resident memory as I'd expect it to need from estimating the memory usage of my data structures. can I somehow measure the total memory usage of a value and all of its referenced objects? or what is a typical way of debugging this kind of thing?
14:53:08 <merijn> niklasb: There's some pretty good profiling tools, RWH has a good intro chapter on profiling haskell programs
14:53:09 <edwardk> "Because of the lack of Category instance, the baroque encoding, and the requirement of template-haskell in the main package, this is my least favorite implementation." -- little did i know...
14:53:54 <niklasb> merijn: I've done that, profiling with -hy or -hd shows that it's actually that hashmap that is taking all the memory. also, not doing the insertions makes the program run in more or less constant space.
14:54:17 <psii> BlindRadish: in order to use MVars, "test" must be an IO action. but your last line "a" indicates, that "test" should be pure. change the last line to "return a" and try again.
14:54:20 <niklasb> but I don't know why the objects involved take up so much memory on the heap
14:54:49 <paf31> edwardk: is there an advantage that you know of, over van Laarhoven lenses, or vice versa? the only thing i could think of was that you wouldnt need higher order quantification, so you could use these in eg scala
14:54:58 <monochrom> BlindRadish: "a"? "return a"?
14:55:07 <paf31> sorry, not scala, maybe f# or c#?
14:55:21 <elliott> you do have a forall in there
14:55:34 <paf31> sure, but a forall a : *, not forall f : * -> *
14:55:56 <edwardk> paf31:  type StateLens s s' = forall a. (s -> (a, s)) -> s' -> (a, s')  is still higher rank, when you pass it in as an arg
14:55:59 <BlindRadish> uh... maybe?
14:56:05 <BlindRadish> i just wanted to print
14:56:06 <psii> BlindRadish: it often helps, if you explicitly write a type signature for your top-level functions.
14:56:08 <BlindRadish> do has to return?
14:56:20 <mauke> no, the types have to match
14:56:30 <edwardk> paf31: note the s -> (a, b -> t)   lens is completely first order, even in negative position
14:56:57 <paf31> true. i was actually working in f# originally, where there is no such thing as forall f : * -> *
14:57:02 <monochrom> if you just want to print, "print a"
14:57:13 <paf31> (to the best of my knowledge)
14:57:41 <BlindRadish> monochrom: you fixed it, but it still doesn't do what i need it to do lmao
14:57:47 <lightquake> wait wait wait
14:57:49 <edwardk> also take a look at your StateLens more closely: forall a. (s -> (a, s))  -> s' -> (a, s')           note that when f = (,) a   you get (s -> f s) -> s' -> f s'
14:57:51 <BlindRadish> monochrom: but thanks, it compiles now! :D
14:57:52 <lightquake> when did ghc grow support for holes?
14:57:55 <monochrom> sure. I don't know what you "need" to do
14:58:02 <merijn> lightquake: 7.8, I believe?
14:58:08 <lightquake> oh, nice
14:58:10 <monochrom> I probably don't care either
14:58:26 <paf31> right, i noticed but wasnt sure if you lost anything by specialising to (,a)
14:58:37 <merijn> lightquake: You can abuse ImplicitParameters as holes in older versions
14:58:42 <hpaste> BlindRadish annotated ‚Äúcan't figure MVar‚Äù with ‚Äúcan't figure MVar (fixed but still not working fully!)‚Äù at http://hpaste.org/81542#a81543
14:58:44 <lightquake> well sure, but i don't like doing that
14:59:40 * monochrom decides to do the simplest lip service
15:00:26 <edwardk> paf31: no. this is equivalent to exists c. a <-> (b, c)
15:00:28 <lightquake> i'm tempted to upgrade to 7.8 as soon as it comes out just for that, tbh
15:00:32 <edwardk> paf31: thats another way to encode a lens
15:00:44 <hpaste> monochrom annotated ‚Äúcan't figure MVar‚Äù with ‚Äúcan't figure MVar (fixed but still not working fully!) (annotation)‚Äù at http://hpaste.org/81542#a81544
15:00:53 <monochrom> there. incremented
15:01:12 <BlindRadish> :(
15:01:27 <BlindRadish> monochrom: its supposed to increment when i call a function :( :( :(
15:01:47 <merijn> BlindRadish: Because you first read a, then write back a+1 and then print a
15:01:52 <merijn> BlindRadish: a doesn't change...
15:02:02 <merijn> BlindRadish: What else would you expect, if not 1
15:02:03 <BlindRadish> it should change eventually?
15:02:11 <BlindRadish> i mean...
15:02:13 <monochrom> someone else will figure out what you want, without you writing any specification properly. I am not playing the guessing game
15:02:20 <merijn> BlindRadish: No, the contents of the MVar change, but a is not the contents of the MVar
15:02:25 <BlindRadish> i want it to print 1 then 2 then 3 each time i call it.
15:02:42 <BlindRadish> why doesn't a contain the contents?
15:02:51 <merijn> BlindRadish: You're creating a new MVar everytime you run test...
15:02:56 <monochrom> a has the previous content, not the latest content
15:03:04 <elliott> lightquake: ghc's holes are less usable than implicitparameter holes
15:03:11 <lightquake> how so?
15:03:12 <merijn> You probably want "test :: MVar Int -> IO Int"
15:03:12 <elliott> the errors are less nice
15:03:30 <monochrom> a is not symlink to your mvar
15:03:48 <BlindRadish> either way it should increment eventually, but if i'm recreating the var eachtime how do i create it without doing so outside the scope?  should i do it in main?
15:05:03 <BlindRadish> merijn: could you show me by annotating?
15:05:20 <BlindRadish> merijn: try as i might, i just do not understand :( :(
15:06:52 <BlindRadish> i need the simplest example, but all i can find are applicable examples (too complex to grok) and documentation (too vague for a rookie)
15:07:48 <monochrom> you need: <merijn> You probably want "test :: MVar Int -> IO Int"
15:08:15 <monochrom> also, therefore, you are right about creating the MVar once and for all at a higher level eg main
15:08:32 <monochrom> perhaps s/higher/outer/
15:09:53 <hpaste> merijn annotated ‚Äúcan't figure MVar‚Äù with ‚Äúcan't figure MVar (fixed but still not working fully!) (annotation) (annotation)‚Äù at http://hpaste.org/81542#a81545
15:10:08 <merijn> BlindRadish: After the last line mvar will contain 3
15:10:20 <merijn> (fully runnable example)
15:10:50 <BlindRadish> merijn: THANK YOU
15:11:45 <BlindRadish> so once main completes, then all my variables are toast?
15:11:52 <merijn> newMVar just creates a "box" where you can put something (for example, an Int). takeMVar empties the box, putMVar puts something in. If you keep creating new boxes everytime (i.e. newMVar) then of course nothing is going to happen
15:12:06 <BlindRadish> so i should think of main as the entire life of my program?
15:12:08 <merijn> BlindRadish: Once nothing has a reference to the MVar, it will be garbage collected
15:12:20 <merijn> BlindRadish: main *is* the entire life of your program
15:12:38 <merijn> BlindRadish: By definition, much like in C, C++ and Java
15:12:48 <bitonic> what was that function on lists that grouped adjacent equal elements together?  I vaguely recalled something like that in base, I don‚Äôt want to ridefine it
15:12:52 <bitonic> *redefine it
15:12:52 <monochrom> fun fact: if you have several threads, and main dies, then the other threads die too
15:12:57 <BlindRadish> okay so if i call test from inside test, each gets its own mvar?
15:13:07 <merijn> monochrom: Word, that tripped me up so much
15:13:17 <monochrom> however, java is the opposite
15:13:17 <BlindRadish> no they scope down to main never mind
15:13:37 <BlindRadish> monochrom: are you serious?
15:13:41 <merijn> BlindRadish: A new MVar is only created by newMVar, if you just pass the same MVar to multiple functions, it will Just Work (TM)
15:13:43 <monochrom> yes
15:14:03 <BlindRadish> monochrom: dasterdly
15:14:19 <merijn> BlindRadish: The usual approach is to have an MVar/TVar to keep track when the last thread dies and have the main thread block on that
15:14:34 <BlindRadish> monochrom: so like, enter a recursive die? no->loop yes->final O??
15:14:35 <monochrom> a java program continues until all non-daemon threads die
15:15:03 <monochrom> I don't know what your sentence means
15:15:22 <BlindRadish> java sucks OO is lame
15:16:08 <BlindRadish> java is like politics but haskell is like culture
15:16:28 <monochrom> I don't care about OO "discussions". I am just talking about threads.
15:16:40 <BlindRadish> lol "discussions"
15:17:04 <BlindRadish> i'm just mad at java because i wanted to use it but it takes way too long
15:18:50 <zeiris> bitonic: I suspect that's RLE encoding, which isn't in base but is a common code golf puzzle.
15:19:06 <mauke> bitonic: group
15:19:19 <bitonic> mauke: no, ‚Äògroup‚Äô groups *all* the equal things, iirc
15:19:26 <bitonic> ah no.
15:19:33 <bitonic> you are very right.  thanks
15:28:33 <BlindRadish> gotta love the haskell.  is it some guy's name or what?
15:28:46 <ciaranm> haskell curry
15:31:20 <BlindRadish> oh shit the guy who invented currying invented haskell?
15:31:32 <ciaranm> schonfinkel invented currying
15:31:37 <BlindRadish> always thought they were two people
15:31:37 <sipa> no, but the language was named after Haskell Curry
15:31:50 <BlindRadish> oh right i remember reading that somewhere
15:31:55 <lightquake> is there a way to sign a hackage package?
15:32:09 <BlindRadish> i hate miscredit
15:32:10 <ciaranm> in blood
15:32:19 <lightquake> in a way that will automatically verify the signature
15:32:20 <BlindRadish> ciaranm: lol
15:35:21 <geekosaur> lightquake, not currently, it comes up fairly regularly and I think is scheduled for newhackage if it ever happens
15:39:08 <clahey> http://en.wikipedia.org/wiki/Stigler%27s_law_of_eponymy
15:39:16 <clahey> Which of course was not first discovered by Stigler.
15:42:30 <BlindRadish> lol i saw that
15:43:37 <jrajav> I named a currying package for Javascript "finkel"
15:43:59 <jrajav> I like to think that someday someone browsing github will get the joke and exhale lightly from their nostrils (before they normally would have)
15:45:58 <clahey> jrajav: Nice.
15:46:11 <johnw> can I get "cabal build" to also run hlint and fail the build if hlint has ignored suggestions?
15:48:43 <dcoutts_> johnw: yes, using build hooks in the Setup.hs
15:48:51 <johnw> ah, of course
15:49:31 <dcoutts_> johnw: and if you want to send hlint patches for Cabal... :-)
15:49:49 <johnw> just checking that there isn't already a common usage
15:49:58 <johnw> i may craft a patch later
15:49:59 <flaper87> hi guys, Need some help here. http://pastebin.com/ENedikUe
15:50:04 <mauke> The paste ENedikUe has been copied to http://hpaste.org/81546
15:50:13 <flaper87> there's a small function and error in that paste
15:50:30 <flaper87> I don't quite understand why I'm getting it (prety new to haskell)
15:50:39 <flaper87> pretty*
15:52:02 <johnw> :t withContext
15:52:04 <lambdabot>     Not in scope: `withContext'
15:52:04 <lambdabot>     Perhaps you meant one of these:
15:52:04 <lambdabot>       `withCont' (imported from Control.Monad.Cont),
15:52:44 <flaper87> withContext comes from haskell-zmq3
15:52:51 <johnw> what is its type?
15:53:50 <flaper87> johnw: withContext :: (Context -> IO a) -> IO a
15:54:22 <johnw> then why are you passing it a "1"?
15:55:48 <flaper87> johnw: https://github.com/twittner/zeromq-haskell/blob/master/tests/System/ZMQ3/Test/Properties.hs#L96
15:56:01 <flaper87> I'm definitely missing some understandings
15:56:41 <glguy> System.ZMQ.withContext :: Size -> (Context -> IO a) -> IO a
16:02:23 <flaper87> glguy: johnw was right, that type is for zmq2 and I'm using zmq3 (the repo tests don't seem to be updated)
16:02:25 <flaper87> johnw: thanks
16:08:08 * hackagebot gf 3.4 - Grammatical Framework  http://hackage.haskell.org/package/gf-3.4 (ThomasHallgren)
16:36:28 <ixmatus> how do I set "-v" for ghci in my ~/.ghci
16:36:45 <ixmatus> :set args doesn't do the trick
16:36:48 <ixmatus> (can it even be done?)
16:38:27 <geekosaur> ixmatus, you do know "args" is not literal there?  ":set -v" works here
16:38:37 <ixmatus> ah!
16:38:40 <ixmatus> okay
16:38:45 <ixmatus> thank you
16:38:49 <monochrom> heh
16:38:58 <cmccann> ugh, sometimes I hate reddit.
16:39:08 <monochrom> why?
16:39:10 <byorgey> only sometimes?
16:39:17 * geekosaur usually hates reddit
16:39:53 <monochrom> is there anyone who loves reddit?
16:39:57 <cmccann> it's practically designed to produce conversations with no useful content
16:40:16 <monochrom> there should be tons who love reddit, since there are tons who actually read it and add posts
16:40:28 <monochrom> so why do the same people say they hate reddit?
16:40:56 <ciaranm> because reddit is a maths hating "pragmatic programmer" loving circlejerk
16:41:04 <monochrom> I don't think there is a way to design either way
16:41:20 * glguy doesn't think you're going to get a representative subset of the larger population asking in #haskell
16:41:27 <cmccann> the problems with reddit itself and the culture it encourages are systemic, that doesn't mean all sub-reddits are terrible.
16:42:06 <ixmatus> I don't *love* it, but I do like certain sub-reddits; (the Haskell sub-reddit has been useful for me)
16:42:22 <monochrom> you open up a forum, people will add useless content
16:42:40 <cmccann> in fact, they tend to be not terrible roughly  in proportion to how much they stick to a constructive content about a well-defined topic
16:42:40 <Sedative_smoke> Monochromatic
16:42:49 * psii discovered reddit through /r/haskell
16:42:55 <ciaranm> forums thrive on noise. if there's just signal, you search and find your answer. the only way for a forum to survive is to be useless enough to create a community.
16:43:18 <cmccann> problem is, reddit usually creates BAD communities.
16:43:34 <Sedative_smoke> Monchrom, there is link to reddit in topic.
16:43:38 * elliott has been giving up on even /r/haskell of late.
16:44:04 <monochrom> yes there is. your point?
16:44:10 <Sedative_smoke> Obviously there is someone who loves reddit.
16:44:22 <monochrom> good. my point too.
16:44:31 <monochrom> <monochrom> there should be tons who love reddit, since there are tons who actually read it and add posts
16:44:41 <cmccann> right now I've got a mild flu or something and there's a massive comment thread where someone who's basically a troll to begin with is stirring shit up because they have a political axe to grind.
16:45:37 <psii> cmccann: then stay away from that thread?
16:45:41 <cmccann> I should probably go do something else before my patience is exhausted and I do something drastic.
16:45:44 <monochrom> I see your sentiment. flu viruses are trolling your body, stirring up nose congestion too :)
16:45:47 <elliott> cmccann: I cannot even begin to guess at the slightest possibility of which thread it could imaginably be
16:46:05 <elliott> truly a mystery
16:46:10 <cmccann> elliott, it's the one where I want to delete 60% of the comments and ban someone when I look at it
16:46:23 <cmccann> but really that could be anything
16:46:26 <ciaranm> if only we had more women in here. they're much better at reading people's emotions.
16:46:33 <monochrom> I think you should ban now, while your patience is thin
16:46:40 <elliott> cmccann: it must be "GHC HEAD now has support for named holes; an extension of -XTypeHoles. Feedback welcome!"
16:46:52 <ciaranm> naming holes is a very sexist thing to do
16:47:02 <elliott> just terrible. overloading the valid variable name _foo like that?
16:47:02 <glguy> ciaranm: I'm going to hold you accountable for what you're starting :)
16:47:12 <monochrom> once your flu is gone and you're a nice guy again, you will be too kind-hearted to ban someone who should have been banned last year
16:47:13 <elliott> ciaranm: not sure what the point of this is
16:47:59 <cmccann> ciaranm: har har. let's drop that line of conversation, ok?
16:48:09 * hackagebot ez-couch 0.3.0 - A high level library for working with CouchDB  http://hackage.haskell.org/package/ez-couch-0.3.0 (NikitaVolkov)
16:49:27 <cmccann> monochrom: y'know I honestly can't tell how serious you're being there
16:49:36 <monochrom> I am serious
16:50:24 <elliott> I think monochrom probably has it right
16:50:56 <cmccann> monochrom: ok, if I flip my shit and ban somebody I'll say it was because you told me to
16:50:57 <elliott> but I am selfish; I would like the SNR of /r/haskell to improve for my own enjoyment!
16:51:04 <monochrom> OK!
16:51:18 <ciaranm> could be worse. could be stackoverflow...
16:51:28 <cmccann> how is stackoverflow worse?
16:51:36 <cmccann> it's basically better than reddit in every way.
16:51:37 <Eduard_Munteanu> monochrom is either serious or not serious... no shades of gray there.
16:51:44 <monochrom> haha
16:51:57 <elliott> pfft, monochrom is a colourful chap once you get to know him
16:52:10 <ciaranm> "Question closed: moderator doesn't understand haskell and doesn't know what the question is about, so assumes it is not appropriate"
16:52:27 <monochrom> did that really happen?
16:52:39 <cmccann> ciaranm: I've rarely seen a haskell question closed inappropriately. the only one I can recall was reopened quickly.
16:53:09 <Eduard_Munteanu> Wow, heh.
16:53:10 <cmccann> but there's a lot of bullshit questions that don't get closed when they should, at least in other tags.
16:53:16 * elliott has seen about 3 Haskell questions closed incorrectly on SO. and about 50 left unclosed when they should have been
16:54:00 <cmccann> monochrom: anyway, I'm not the one you need to convince. the only reason I don't moderate a lot more heavily is that it's not really what the community there seems to want.
16:54:15 <monochrom> I can imagine that in some categories, it is right to close haskell questions, and even "we don't know haskell" is a valid reason
16:54:22 <cmccann> and most of the noise doesn't quite cross the threshhold where nuking it from orbit and dealing with complaints is more appealing than ignoring it.
16:54:40 <elliott> cmccann: that is the subset of the community that sticks around -- and speaks up -- after a long peroid of light moderation
16:55:03 <elliott> people who want more moderation won't necessarily bother posting if they think light moderation isn't doing well for the place
16:55:14 <elliott> especially if they aren't the kind of people who would comment actively anyway
16:55:41 <cmccann> elliott: yes, but I'm not sure that can really be altered. especially by a sudden shift in policy.
16:56:12 <cmccann> and anyway, I'm not going to do that without at least one or two other moderators on board.
16:56:22 <elliott> just saying not to assume people don't want moderation based on what active people seem to want :)
16:57:58 <cmccann> elliott: maybe you should start an insurrection to demand stricter moderation!
16:58:56 <cmccann> (incidentally, the only haskell question on SO I can recall being inappropriately closed was reopened with two votes from people not active in the haskell tag, so the outside influence at least cuts both ways)
16:59:21 <elliott> cmccann: I might just implement my own stricter moderation by hiding the comments link.
16:59:33 <monochrom> haha
17:00:51 <zachk> hello all of #haskell :D
17:00:58 <guymann> hi
17:01:01 <Eduard_Munteanu> ohai
17:01:08 <Taslem> Hullo.
17:01:33 <zachk> been busy in the real world
17:01:41 <zachk> so unfulfulling must code again
17:01:43 <zachk> :D
17:01:46 <Taslem> @pl f a b c d e f = d a (c (f d d) e d (b b f)) c
17:01:50 <lambdabot> f = flip flip id . (liftM2 (flip . ((flip . (flip .)) .)) .) . (. (flip (flip . ((flip . (ap .)) .) . join . ((flip . (flip .) . flip) .) . (. (flip =<< flip id)) . (.)) . join id)) . (.) . ap . (((.
17:01:50 <lambdabot> ) . (.)) .) . flip id
17:01:50 <lambdabot> optimization suspended, use @pl-resume to continue.
17:02:12 <Taslem> "optimization"?
17:02:48 <elliott> pessimisation
17:02:49 <zachk> @pl-resume
17:02:50 <elliott> @pl=resume
17:02:50 <lambdabot> f = flip flip id . (liftM2 (flip . ((flip . (flip .)) .)) .) . (. (flip (flip . ((flip . (ap .)) .) . join . ((flip . (flip .) . flip) .) . (. (flip =<< flip id)) . (.)) . join id)) . (.) . ap . (((.
17:02:50 <lambdabot> ) . (.)) .) . flip id
17:02:50 <lambdabot> pointless: sorry, nothing to resume.
17:02:53 <zachk> ching
17:03:02 <elliott> indeed, so pointless
17:03:15 <zachk> its flipping me out
17:03:24 <psii> :t flip id
17:03:26 <lambdabot> b -> (b -> c) -> c
17:03:35 <zachk> :t flip
17:03:37 <lambdabot> (a -> b -> c) -> b -> a -> c
17:03:41 <zachk> :t id
17:03:43 <lambdabot> a -> a
17:04:02 <glguy> zachk: lambdabot will respond to /msg
17:04:07 <zachk> k
17:04:34 <geekosaur> (actuallyit's flipping you off)
17:04:40 <zachk> what is the best practice of using emacs with haskell?
17:05:08 <zachk> o the archers and frogs, how I prefer hiking in ice with klogs
17:05:09 <elliott> best practice for what?
17:05:12 <Eduard_Munteanu> Install vim and forget emacs. :P
17:05:24 <zachk> how does one use emacs and haskell nicely together, for beginners at emacs
17:05:27 <zachk> did that
17:05:30 <monochrom> haskell-mode. https://github.com/haskell/haskell-mode
17:05:36 <zachk> ahhh danke
17:06:34 <Sedative_smoke> Asking about it st
17:07:52 <Eduard_Munteanu> Really now, I might start using Emacs for the holes stuff.
17:08:21 <Eduard_Munteanu> Assuming they'll implement it in haskell-mode.
17:08:54 <Eduard_Munteanu> Sedative_smoke: did you want to ask something?
17:10:31 <Sedative_smoke> Nah, just wriggling with stupid mobile client.
17:10:41 <Sedative_smoke> Struggling.
17:20:35 <fragamus> I seem to remember the ListT monad having some problems, and that there was a better one somewhere.
17:22:17 <Eduard_Munteanu> @google listt done right
17:22:19 <lambdabot> http://www.haskell.org/haskellwiki/ListT_done_right
17:22:19 <lambdabot> Title: ListT done right - HaskellWiki
17:22:40 <Eduard_Munteanu> fragamus: maybe this ^^
17:22:52 <fragamus> yep I'm on it
17:22:55 <fragamus> thanks
17:24:19 <cmccann> fragamus: note that the two versions of ListT are really different ideas
17:24:20 * Eduard_Munteanu can't remember the reason off the top of his head, maybe he should re-read that
17:24:59 <cmccann> fragamus: the "problem" version attempts to be a "lists-as-collections" transformer where order doesn't matter, and fails if the inner monad is not commutative (I think)
17:25:35 <cmccann> the "done right" version is a "lists-as-possibly-infinite-streams" transformer with a baked-in notion of sequential order
17:26:28 <Eduard_Munteanu> I wonder if there's a theorem specifying the minimal conditions for a monad to have a transformer version.
17:27:12 <Eduard_Munteanu> (assuming you can boil it down to some conditions, maybe not)
17:27:38 <cmccann> well, monad transformers are kind of an ad-hoc notion to begin with.
17:28:02 <Eduard_Munteanu> cmccann: I've seen at least one way to put it formally
17:28:32 <Eduard_Munteanu> Monad transformers as monoid homomorphisms.
17:28:55 <cmccann> that said, there's a pretty consistent "recipe" that I think all the standard transformers but ListT follow
17:29:37 <Eduard_Munteanu> Hm, about that recipe... I wonder... can you build them the other way around?
17:29:50 <cmccann> how so?
17:30:12 <Eduard_Munteanu> Normally, FooT m a  is some  m (Foo a).
17:30:28 <Eduard_Munteanu> How about Foo (m a)?
17:30:46 <cmccann> well, that's just functor composition, isn't it?
17:30:47 <elliott> ReaderT r m a is r -> m a
17:30:53 <elliott> StateT s m a is s -> m (a, s)
17:30:59 <elliott> I don't think your rule holds very often
17:31:18 <crdueck> is there a way to lookup a key of a Data.Map.Map and update it? something like updateKey :: Ord k => k -> k -> Map k a -> Maybe (Map k a)
17:32:16 <Eduard_Munteanu> Hrm.
17:32:38 <elliott> crdueck: k -> k ->?
17:32:39 <elliott> are you sure?
17:32:48 <Eduard_Munteanu> It does make me wonder if there's a rule or a pattern to it.
17:32:58 <cmccann> and yeah, the usual rule for "FooT m" is take the basic Foo, and put the "m" to the right of any functions and outside sums and products
17:32:59 <Eduard_Munteanu> Maybe not as simplistic.
17:33:20 <crdueck> elliott: yes, 'updateKey oldKey newKey map = ...'
17:33:31 <monochrom> no. I used delete, then insert
17:33:42 <elliott> crdueck: so it moves a key?
17:33:52 <cmccann> if you apply the "outside sums and products" rule recursively you also get something similar to the stream-style ListT
17:34:22 <crdueck> monochrom: thats what i'm trying to avoid, does 'delete k $ insert k v map' get optimized at all?
17:34:33 <elliott> cmccann: does that rule work to derive ContT?
17:34:49 <blackmirroxx2> xmonad and xmobar rocks
17:35:15 <crdueck> whoops, delete k $ insert k' v map
17:35:22 <monochrom> I don't think there is anything to optimize
17:35:31 <cmccann> elliott: ContT is weird. but the inner monad does go to the right of the function arrows...
17:35:39 <monochrom> also, you should insert (delete map) rather than delete (insert map)
17:36:41 <crdueck> why is that?
17:37:03 * geekosaur was wondering if they had meant that delete(insert) would be optimized away
17:37:10 <geekosaur> or had inverted them
17:37:27 <geekosaur> I should say delete . insert
17:37:43 <bitonic> is there a pretty printing library that easily lets me tell it ‚Äòif this block of text is too wide, then indent with n space with a newline, otherwise start it on the same line‚Äô
17:37:57 <Eduard_Munteanu> Also wondering if there's a dual for transformers, like given FooT Bar a, can you make a BarDualT Foo a ~ FooT Bar a?
17:38:11 <Eduard_Munteanu> So many questions... *sigh*
17:38:15 <bitonic> it seems like a fairly basic thing to do but as far as I can see ‚Äòpretty‚Äô doesn‚Äôt do it
17:39:10 <elliott> crdueck: because consider k == k'
17:39:28 <crdueck> elliott: ahh, good point
17:39:57 <BMeph> crdueck: "Short" answer, idempotence...or, what edwardk said. :)
17:39:57 <crdueck> it wont apply in my particular case, but still
17:40:39 <BMeph> Sorry, what *elliott said. Dang it, elliott, when did you start answering questions, instead of just asking them? ;)
17:41:00 <elliott> elliottk
17:41:03 <napping> bitonic: that sounds more or less like what they do
17:41:27 * elliott has been answering questions here for years! to varying degrees of success.
17:41:29 <bitonic> napping: then I‚Äôm misunderstanding - what‚Äôs the combinator that inserts a new line if the block is too wide?
17:42:11 <BMeph> BBL - Ween-doze neets a restart...again. :/
17:42:15 <napping> both the hughes and wl pretty printer are sort of the other way around - you tell it the place newlines *might* go, and it leaves them out if a group in the output is short enough
17:42:59 <monochrom> bitonic: "sep" says "either hsep or vcat". similarly, "cat" says "either hcat or vcat". perhaps they have potential
17:43:12 <napping> something like group(nest 2 (line <> .....))
17:43:54 <monochrom> also, $$ may or may not be close
17:44:03 <bitonic> monochrom, napping: yeah those look fine actually, thanks
17:44:08 <bitonic> monochrom: $$ always newlines
17:44:39 <monochrom> no, try the example in the haddock. text "hi" $$ nest 5 (text "there")
17:44:58 <cmccann> Eduard_Munteanu: what would the dual of a monad transformer be? a monad un-transformer? :P
17:45:08 <bitonic> monochrom: OK, but that‚Äôs totally unrelated to line width
17:45:20 <monochrom> yeah, nevermind
17:45:36 <bitonic> I‚Äôll try sep, thanks
17:46:08 <Eduard_Munteanu> cmccann: I was thinking maybe something weaker, looking like some sort of adjunction.
17:46:50 <elliott> Eduard_Munteanu: I think the answer to that dual question is "no"
17:47:01 <elliott> what on earth would IODualT look like?
17:47:02 <Eduard_Munteanu> Mostly wondering whether you could have a "untransformer" like that for IO or ST.
17:47:06 <cmccann> Eduard_Munteanu: I'm not sure what would be sensibly dualized in this case, unless you do the same thing to the monad
17:47:15 <elliott> right I think the problem is you are taking Foo
17:47:19 <elliott> if you take FooDual it might make sense
17:47:20 <cmccann> in which case you have comonad transformers instead, which are perfectly sensible
17:47:40 <Eduard_Munteanu> elliott: for IO it's simple... IODualT m a = IO (m a)
17:47:42 <elliott> I can imagine StateT s IO a ~ IODualT (StateDual s) a
17:47:52 <elliott> Eduard_Munteanu: huh? that doesn't work for e.g. ReaderT
17:47:56 <napping> bitonic: I usually have to render some text documents at various sizes to make sure I've got things right, sometimes the correct places to put group and line boundaries seem odd
17:48:03 <elliott> ReaderT r IO a ~/~ IODualT (Reader r) a
17:48:19 <bitonic> napping: I suppose ‚Äògroup‚Äô is from wl?
17:48:23 * Eduard_Munteanu thinks
17:48:34 <napping> yeah, my examples were with wl
17:48:50 <Eduard_Munteanu> @unmtl ReaderT r IO a
17:48:50 <lambdabot> r -> IO a
17:49:07 <bitonic> napping: OK, I‚Äôll try to keep it with ‚Äòpretty‚Äô for the time being, but wl does look nice
17:49:23 <Eduard_Munteanu> Though it's really the same up to sequence.
17:49:27 <Shimizoki> This is for an assignment: I need to create a function hep :: [String] -> [String] that replaces "you" with "u", "are" with "r", etc. I Figured out a way to do it recursively with guards, however I get hung up with how to convert (["by", "the", "way"] to ["btw"]). Can anyone point me in the right direction?
17:49:36 <elliott> Eduard_Munteanu: a -> IO b and IO (a -> b) are *not* the same
17:49:40 <elliott> String -> IO () vs. IO (String -> ())
17:49:44 <elliott> the former is putStrLn, the latter is useless
17:49:49 <napping> the main thing it adds is "align"
17:49:54 <Eduard_Munteanu> Hrm, you're right.
17:50:25 <Eduard_Munteanu> elliott: oh wait
17:50:29 <cmccann> putStrLn "totally not useless!" >> return (const () :: String -> ())
17:51:12 <napping> I'm trying to figure out how to faithfully model an AST representation from some Java code
17:51:24 <Eduard_Munteanu> String -> IO () can't do anything more than IO (String -> ()) can *if* you're using Reader. Can it?
17:51:34 <elliott> Reader gives you exactly as much power as (->)
17:52:04 <bitonic> napping: oh right, nice... that‚Äôs useful to pp function application for example
17:52:06 <hpaste> Shimizoki pasted ‚ÄúHep‚Äù at http://hpaste.org/81551
17:52:07 <napping> Having constructors organized into trees which inherit fields from parent types seems to a little hard to faithfully reproduce
17:52:12 <monochrom> IO (String -> ()) can do a lot of things. but afterwards, the String->() you obtain is not too exciting
17:52:48 <elliott> well, "useless" might be a bit far.
17:52:58 <elliott> but it's certainly never a type you'd end up consciously using, since IO () does the job just as well
17:53:06 <elliott> (modulo unsafePerformIO hackery)
17:53:22 <Eduard_Munteanu> Wait, I'm not sure you understand what I meant. I'm not saying they're equivalent as types.
17:54:17 <qasd> Anyone here good at reports, should an image have the figure number in the image or as a note beneath it?
17:54:23 <Eduard_Munteanu> I'm not sure what I meant... I should probably use some paper.
17:55:35 <Shimizoki> If anyone here has any advice as to how I could approach my problem, I would greatly appreciate it. Thank you.
17:56:49 <napping> Shimizoki: that seems like a bit of an incomplete description - what would it do with words you don
17:56:57 <napping> you don't have a mapping for?
17:57:31 <napping> or you mean just matching sequences at all?
17:57:44 <Shimizoki> napping: It would leave them alone. I made a paste a moment ago with my current section of code: http://hpaste.org/81551
17:58:37 <napping> well, the general operation is checking if some prefix of the input is in your table, recursing after the replacement if so and shifting just one word if not
17:59:21 <napping> probably nicer to hardcode like hep ("you":ws) = "u":hep ws
17:59:40 <napping> which generalizes nicely to hep ("by":"the":"way":ws) = "btw":hep ws
18:00:36 <Shimizoki> Oh, I had not thought of that.
18:01:19 <napping> either that or keep a table of the substitutions ([Word],Word) and to somethine like if (prefix `isPrefixOf` ws) then replacement:<recurse on drop (length prefix) ws> else ... try others ...
18:01:51 <monochrom> use a regexp :)
18:01:53 <napping> but I guess the simple pattern matching is probably plenty for what you need
18:02:05 <geekosaur> now you have two problems :)
18:02:09 <monochrom> "a" regexp :)  "a" makes it sound so easy
18:02:33 <geekosaur> actually that should be:  now you have problems+
18:02:56 <monochrom> "a" regexp for such a problem is likely 10 regexps composed carefully. that is why it is so difficult
18:04:00 <monochrom> similarly, a 500-page math book can be said to consist of "a" theorem. "a" theorem is the conjunction of 500 theorems
18:04:50 <geekosaur> now you have problems{2,} except when you have problems\{2,\} :)
18:04:55 <YayMe> monochrom: What's the difference between a conjunction and composition?
18:05:07 <monochrom> haha
18:05:30 <monochrom> conjunction is the and-operator
18:05:43 <monochrom> composition refers to any operator
18:06:07 <YayMe> what about conjunction of or operators?
18:06:08 <Shimizoki> napping: Thank you, And yes... I believe your second solution is beyond the scope of this assignment. Its working just as I was hoping now.
18:06:29 <monochrom> (||) && (||) && (||) is a type error
18:08:35 <YayMe> is that a conjunction? Or is this a conjunction? \x y -> (&&) $ (||) $ (||) x y
18:09:25 <monochrom> @type \x y -> (&&) $ (||) $ (||) x y
18:09:27 <lambdabot>     Couldn't match expected type `Bool' with actual type `Bool -> Bool'
18:09:27 <lambdabot>     In the second argument of `($)', namely `(||) $ (||) x y'
18:09:27 <lambdabot>     In the expression: (&&) $ (||) $ (||) x y
18:09:45 <monochrom> I really refuse to classify type-erroneous expressions
18:10:07 <Eduard_Munteanu> Type error normal form. :P
18:10:11 <monochrom> ok, apart from the classification "type-erroneous"
18:10:18 <YayMe> No your honor, you're in cojunct of court!
18:10:27 <YayMe> s/cojunt/conjunct
18:18:25 <Shimizoki> napping: If you are still there, Is there a way to use case expressions for the multiple word replacements?
18:18:44 <qasd> Anyone here good at reports, should an image have the figure number in the image or as a note beneath it?
18:18:50 <napping> pattern matching is the same either way
18:19:23 <napping> guards, as patterns, etc. all have the same syntax, the only difference is -> vs. =
18:21:35 <Shimizoki> napping: I only mention this because its stated in the assignment that points will be deducted if there is duplicate code. I'm not sure if something like the solution you provided would count as that.
18:23:34 <napping> I think the fully abstracted form is the one using a table [([Word],Word)], but the pattern matching one is not bad
18:24:46 <napping> you are thinking of making a case expression returning pairs so you only write the recursive call once?
18:27:12 <Shimizoki> I was thinking of doing something like a helper function that takes a string and does the  case expression returning the replaced value... However I dont see how that would work with 'btw'
18:27:37 <WhereIsMySpoon> Can someone please translate this haskell code into english? http://hpaste.org/81550 I know absolutely nothing about haskell, but my friend provided me with this and I want to see how his solution is different to mine
18:27:48 <WhereIsMySpoon> I've never programmed in a functional language before
18:31:41 <cglazner> is there a singleton analogy to (,) on the type level?
18:32:01 <cglazner> like a "dummy" tuple?
18:32:27 <davean_> cglazner: conceptually, how does that differ from an untupled type?
18:34:28 <cglazner> well i have a function of type (say) Array (a, a) b -> ([Int],[Int]) -> b
18:34:52 <cglazner> i can generalize to any tuple by making it type Array (i a) b -> i [Int] -> b
18:35:00 <parcs> WhereIsMySpoon: you'd be best off asking your friend to translate
18:35:13 <cglazner> but then i can't use it with singletons
18:35:14 <WhereIsMySpoon> parcs: if he was around, i would
18:35:22 <elliott> cglazner: you can't use that with (,,) either
18:35:27 <elliott> or whatever
18:39:06 <cglazner> ah i see, i had a test that type-checked because it set i ~ (,) Int
18:39:47 <cglazner> or something that wasn't what i indented
18:39:57 <noah_> WhereIsMySpoon: my impression is that it generate random points and tries to connect them in a graph
18:40:13 <noah_> WhereIsMySpoon: where points are only connected if they are close enough
18:40:36 <noah_> WhereIsSpoon: it then prints the average number of connected graphs generated over some trials
18:40:40 <WhereIsMySpoon> noah_: yes, sorry, i should have set the context - the point of the program is that it makes points, sees if tehyre connected if within radius R then generates a probability that for radius R, nodes N that the graph is connected
18:40:45 <WhereIsMySpoon> the thing is
18:40:54 <WhereIsMySpoon> there must be something fundamentally different between that
18:41:11 <hrumph> hi
18:41:20 <hrumph> i need help to understand how to paginate a form in yesod
18:41:21 <WhereIsMySpoon> and (what i think is the same thing) in java that ive done, which is: http://pastie.org/5978440
18:41:48 <WhereIsMySpoon> because he gets a probability of 9.93%
18:41:58 <WhereIsMySpoon> and i get all networks are non connected, a 0%
18:42:28 <cmccann> WhereIsMySpoon: well, presumably one or the other program has a bug, then
18:42:49 <WhereIsMySpoon> cmccann: well, yes, and im assuming his is correct as he has about 20-30 years of programming experience
18:42:51 <WhereIsMySpoon> and i have 4
18:43:07 <WhereIsMySpoon> so i was wondering if anyone could either word for word translate his haskell
18:43:18 <WhereIsMySpoon> or tell me what the difference is between my code and his, in terms of functionality
18:43:31 <cmccann> seems like noah_ gave a reasonable summary of the algorithm
18:44:05 <WhereIsMySpoon> cmccann: i already know what the program should do, its just that mine obviously does it wrong, and he has done something different that i havent seen
18:45:40 <napping> Shimizoki: I already had an example matching several words, that was one of the nice things about doing it with patterns. If you want to put the matching in a separate case or helper function or something, you just have to remember that the different cases differ in two parts - the replacement, and the rest of the string
18:45:58 <hrumph> he fieldviewfunc constructor of the Field type doesn't have a parater where i can pass in a page number so what do I do?
18:46:03 <napping> well, at least they differ in what tail of the string you recurse on once you have added some patterns matching multiple words
18:46:51 <cmccann> WhereIsMySpoon: the algorithm is relatively simple at heart, and this is probably not the best place to get help with debugging Java code
18:47:24 <WhereIsMySpoon> cmccann: i know it's simple, and thats what's annoying, the difference between him getting 9.93% and me getting 0% is kinda huge
18:47:31 <WhereIsMySpoon> i just really wish i knew what he was doing
18:47:34 <WhereIsMySpoon> but i cant read haskell
18:47:35 <WhereIsMySpoon> at all
18:48:54 <noah_> WhereIsMySpoon: ok
18:49:21 <WhereIsMySpoon> in essence, its not the java code that needs debugging, its the way im going about the problem
18:49:41 <WhereIsMySpoon> thats why i wanted someone to help decode the haskell so i can see what he's done to get a proper result
18:49:42 <noah_> WhereIsMySpoon: your java code has a big bug- it compares all points to each other and exits if any are too far away
18:50:17 <WhereIsMySpoon> noah_: yes, if one point is not connected, then the whole network is not a connected network
18:50:23 <WhereIsMySpoon> wait
18:50:24 <noah_> WhereIsMySpoon: no
18:50:29 <WhereIsMySpoon> it needs to go through the whole network first
18:50:34 <WhereIsMySpoon> rather than exiting at the first non connected thing
18:50:37 <noah_> WhereIsMySpoon: yea
18:50:38 <WhereIsMySpoon> doesnt it
18:50:40 <WhereIsMySpoon> <_____>
18:50:50 <noah_> WhereIsMySpoon: the haskell is much more efficient, btw
18:50:56 <WhereIsMySpoon> noah_: im sure :p
18:51:25 <noah_> WhereIsMySpoon: just check that each point is close enough to at least one point to connect to it and it would work
18:51:31 <WhereIsMySpoon> yea
18:51:53 <noah_> Also
18:51:57 <noah_> learn haskell
18:51:57 <noah_> btw
18:51:59 <noah_> just a plug
18:52:01 <napping> that won't check that the graph is connected, just that every connected component has at least two points in it
18:52:20 <noah_> indeed
18:52:47 <noah_> napping: good point, the haskell builds the graph up until there are no points not connected to it
18:53:27 <napping> If you don't want to keep an explicit set of things know to be connected, perhaps there's something pretty with union-find
18:56:24 <WhereIsMySpoon> noah_: http://pastie.org/5978582
18:56:27 <WhereIsMySpoon> this look better?
18:57:16 <WhereIsMySpoon> still no connected networks tho :(
18:58:05 <aistis> hello all, i am looking at the jmacro library and have recently hit a bug that i cant really solve. Any expression that I pass into jmacro, no matter how simple will throw this error: "parse error on input `]'"
18:58:15 <aistis> any ideas?
18:59:48 <noah_> WhereIsMySpoon: this has become a Java question, but to point you in some direction- break will only break the inner loop, so you always return false. also, you need to keep track of the connected points somehow, as napping said
19:00:24 <hpaste> aistis pasted ‚Äújmacro‚Äù at http://hpaste.org/81552
19:11:01 <sclv> mauke: huge loool at your newtype quote in hwn
19:14:00 <aistis> ah, well i fixed it.. Apparently you need the quasiquotes LANGUAGE pragma..
19:14:23 <cmccann> elliott: hey, your quote about bicrosswalk is in HWN! :D
19:14:32 <elliott> oh boy
19:14:34 <elliott> I'm famous!!!!!
19:14:42 <cmccann> yeah!!!
19:14:50 <elliott> does this mean I get money
19:14:54 <cmccann> no
19:14:59 <elliott> what
19:15:01 <elliott> this is terrible
19:15:16 <cmccann> but you do get to bask in the glow of public recognition.
19:15:22 <cmccann> that's worth something I guess.
19:16:42 <lewis1711> why can I not do "data OneOrZero = 1 | 0" ?
19:18:37 <cmccann> lewis1711: because that's not how the syntax works
19:18:37 <cmccann> what are you trying to accomplish?
19:19:26 <parcs> @quote newtype
19:19:26 <lambdabot> mauke says: <mauke> a newtype is like an existing type but wearing glasses and a fake mustache  <mauke> and a sign saying "you've never seen me before"
19:20:48 <lewis1711> cmccann, a list of direcitons of type (Int, Int). so i can have a function that takes a direction and only a direction. I was mainly just testing to see if I could use "literals" in data constructors
19:21:13 <lewis1711> something like "data Direction = North (0, -1)... " etc
19:21:31 <cmccann> lewis1711: nope, sorry
19:22:09 <cmccann> you probably just want "data Direction = North | South ..." etc. and then a function that produces the offset values
19:22:19 <lewis1711> yeah, that was my second choice
19:22:22 <cmccann> e.g. "moveDir North = (0, -1)" and so on
19:23:29 <lewis1711> does haskell optimise the way the fact I have to call a function to get the offset values? since it's pure and it always knows that moveDir North = (0, -1) ?
19:23:52 <cmccann> lewis1711: well, Haskell is a language and doesn't optimize anything . :P
19:24:00 <cmccann> but I think GHC is pretty aggressive about inlining
19:24:42 <lewis1711> yeah I guess I shouldn't really care anyway
19:24:42 <cmccann> I wouldn't worry about it though, unless it turns into a performance bottleneck for some reason
19:24:52 <cmccann> premature optimization and all that whatnot.
19:27:01 <jnhnum1> why, in ghci, does a generic Num get printed as a float when you require it to be storable? what I mean is why do I get the following output:
19:27:02 <jnhnum1> Prelude Data.Packed.Vector Foreign.Storable> 4 :: (Num a, Storable a) => a 4.0
19:28:10 <cmccann> because the default integral type is Integer, which is not a Storable instance
19:28:19 <cmccann> is my guess at any rate.
19:29:00 <cmccann> so it probably defaults to Double
19:29:13 <lewis1711> sorry I don't know the term for this, so it's hard to google - how do I like "wrap" things? like a data constructor (SpecialNumber 3) that makes a special number. err.
19:30:33 <lewis1711> oh nm, found it
19:33:45 <Shimizoki> how would one use tail recursion to find the index of a speficied element in a list? (I am not allowed to use any built in functions like elem')
19:34:40 <Shimizoki> f 4 [4] returns 0, f 4 [0, 4] returns 1, f 4 [0, 0, 0, 0] returns -1
19:35:17 <Ralith> Shimizoki: this sounds like homework.
19:35:19 <sepp2k> Shimizoki: The naive recursive approach will be tail recursive already. There's nothing special you need to do to make it tail recursive.
19:35:37 <Shimizoki> Ralith: It is.
19:35:59 <cmccann> ... -1? why the sweet bouncing crap would it return -1 for something not found?
19:36:00 <cmccann> that's horrible.
19:36:32 <monochrom> the teacher may be a C expert :)
19:36:33 <Shimizoki> sepp2k: the method I am using cant return -1 because I am doing 1+(f 4 tail ls).
19:36:34 <sepp2k> cmccann: Maybe they didn't cover Maybes in class yet?
19:36:35 <Eduard_Munteanu> Remember doing  if (foo() < 0) <handle error>  ? :)
19:36:36 <jollytime> sweet bouncing crap! 1+ for creative swear word
19:36:52 <cmccann> :t findIndex
19:36:53 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
19:37:00 <Shimizoki> I have not covered maybes.
19:37:01 <cmccann> even the Prelude gets this one right
19:37:19 <cmccann> but Maybe is simpler than lists... :[
19:37:21 <monochrom> may I talk about how to approach this problem now?
19:37:21 * cmccann sighs
19:37:31 <Eduard_Munteanu> Shimizoki: yes it can
19:37:37 <sepp2k> Shimizoki: I apologize, I was incorrect. The naive approach is not tail recursive.
19:37:55 <Shimizoki> sepp2k: Thats ok, I would have never known ;)
19:38:37 <monochrom> do you know how to solve this, if you are not limited to tail recursion?
19:38:45 <Shimizoki> I have found several examples online that use maybes, however I feel that is beyond the scope of the assignment.
19:39:02 * cmccann grumbles about poorly-thought-out homework assignments being misleading and counterproductive
19:39:09 <Shimizoki> monochrom: Couldnt I just use elemIndex?
19:39:21 <Eduard_Munteanu> You'll want to use an accumulator to make it tail recursive.
19:39:28 <monochrom> yes, but how would you write elemIndex yourself?
19:40:08 <Michael_> How do I cast a fractional int to a float? I'm getting this error mesage https://gist.github.com/4679850. Thank you
19:40:13 <Shimizoki> monochrom: Oh, well then no... I have no idea how. Thats why I am here. I can get it to work except in the case that the list is not empty and the element is not found
19:40:35 <monochrom> ok, show your current work
19:40:52 <Eduard_Munteanu> Shimizoki: well, what do you do when the list isn't empty and you haven't found the element?
19:41:06 <monochrom> Michael_: fromIntegral
19:41:07 <Eduard_Munteanu> You keep looking. :)
19:41:08 <cmccann> ...heh, the Prelude implementation of elemIndex is really cute.
19:41:10 <hpaste> Shimizoki pasted ‚ÄúwhatIndex‚Äù at http://hpaste.org/81553
19:41:35 <mauke> next = 1 / fromIntegral (length nubNames)
19:41:58 <Eduard_Munteanu> Shimizoki: that's alright
19:42:21 <Shimizoki> In the current method I am using if its not found -1 is returned, but then it adds 1 to that for each element in the list. Thus in the case its not found it returns len-1
19:42:23 <lewis1711> aren't you all going to demand he use pattern matching? :)
19:42:24 <Michael_> thank you
19:42:48 <Eduard_Munteanu> Shimizoki: no, it's fine, really.
19:43:00 <cmccann> Eduard_Munteanu: no, it doesn't work
19:43:16 <Eduard_Munteanu> Hm?
19:43:38 <Eduard_Munteanu> Oh, crap.
19:43:40 <monochrom> Shimizoki: do you know how to write your own "length" with tail recursion?
19:43:50 <Shimizoki> Eduard_Munteanu: I dont mean to imply you are wrong... but it doesnt work on my end when I run it. So maybe there is something missing?
19:44:02 <Eduard_Munteanu> Nevermind, I misread
19:44:41 <Shimizoki> monochrom: I think so. when its empty return 0 and in the recursive do 1+f(tail)
19:44:52 <Eduard_Munteanu> Fortunately, if you turn it into a tail-recursive version, the fix will be really easy.
19:44:55 <monochrom> that is not tail recursion
19:45:09 <monochrom> "tail" does not refer to the list
19:45:21 <Shimizoki> Ohhh, perhaps I dont know what tail recursion is then :P
19:46:28 <cmccann> conveniently, the easiest fix to the algorithm would make it tail recursive, and making it tail recursive would make the fix obvious.
19:46:31 <Shimizoki> I guess that the logical "Do recusion on the tail" isnt right. Guess Ill do some googling'
19:47:36 <monochrom> before that, did your teacher explicitly, verbatimly, absolutely say "tail recursion"? as opposed to your abridging, butchering, putting-in-your-own-words which must be wrong?
19:48:05 <Saizan> must?:D
19:48:29 <monochrom> yes, students must misrepresent teachers. must. they always do. indistinguishing from must.
19:48:46 <monochrom> s/indistinguishing/indistinguishable/
19:48:57 * cmccann misrepresents monochrom.
19:49:18 <monochrom> to be fair, the fault is with the teachers. the teachers always teach, "put it in your own words, to show you understand"
19:49:23 <Shimizoki> lol, I dont remember any definition being given for "tail-recursion" I just saw in the assignment that "Hint: it may be useful to use tail-recursion" and concocted on my own the wrong definition of the word
19:49:27 <monochrom> in reality, it shows that they don't understand
19:49:41 <Eduard_Munteanu> *may be useful*
19:50:01 <cmccann> ah, the old "what do you mean the students don't already know the jargon I should be teaching them?"
19:50:10 <glguy> Eduard_Munteanu: certainly wouldn't be required
19:50:23 <hpaste> monochrom annotated ‚ÄúwhatIndex‚Äù with ‚Äúbasic idea‚Äù at http://hpaste.org/81553#a81554
19:50:45 <monochrom> my paste is a basic example of tail recursion, and how to obtain it
19:51:46 <hpaste> ‚ÄúAnonymous Coward‚Äù pasted ‚Äúdata experiment‚Äù at http://hpaste.org/81555
19:51:51 <lewis1711> why is (Melee North) not a valid NonFreeAction in the last line?
19:52:02 <lewis1711> (lol anonymous coward)
19:52:07 <Shimizoki> hmmmm, I actually had something similar to that originally but changed it. If you dont mind. Can you explain to me then "In your own words" :P what tail-recursion is and how it differs from what I did.
19:52:24 <cmccann> lewis1711: because one Attack is a nullary data constructor, the other Attack is a type
19:52:46 <monochrom> tail recursion means: f param = f (operation on param). that is all.
19:52:47 <cmccann> try something like "... | Attack Attack" and then (Attack (Melee North))
19:52:48 <Eduard_Munteanu> lewis1711: you're mixing up type constructors and data constructors
19:53:00 <Eduard_Munteanu> They can share names in a confusing way.
19:53:25 <cmccann> though many people would encourage not using the same name for a type and a data constructor not belonging to that type...
19:53:28 <lewis1711> oh I see
19:53:33 <Shimizoki> monochrom: so how does that differ from what I did... when my param was a list, and my operation was taking the tail of it?
19:53:37 <cmccann> because it gets confusing for obvious reasons
19:53:37 <lewis1711> I *sort of* see
19:54:11 <Shimizoki> monochrom: Sorry if I am missing something painfully obvious.
19:54:12 <monochrom> tail recursion means the outermost call is to f again
19:54:12 <Eduard_Munteanu> lewis1711: datatypes always wrap something in a constructor
19:54:32 <monochrom> whereas in "1 + mylength xs" the outermost call is to +, not mylength
19:54:42 <Eduard_Munteanu> data MyNumber = Int | Float    isn't valid, or at least not what you want.
19:55:10 <cmccann> lewis1711: what you have now is the same as if you had "data NonFreeAction = Move Direction | AttackAction" instead
19:55:13 <Eduard_Munteanu> That's just like saying   data MyNumber = A | B
19:56:06 <riley__> The advantage of tail recursion that the stack is kept smaller?
19:56:12 <liyang> Fin 2 is a number!
19:56:15 <lewis1711> I think I understand now. so at the risk of being simplistic; how *should* i encode this? without repeating names
19:56:20 <Eduard_Munteanu> riley__: perhaps in C
19:56:29 <copumpkin> liyang: nuh uh!
19:56:31 <Shimizoki> monochrom: is this because + is a function? thus its actually doing (+) 1 f()
19:56:35 <copumpkin> it's a type >_>
19:56:36 * copumpkin runs
19:56:40 <monochrom> yes
19:56:48 <Eduard_Munteanu> riley__: in Haskell, it's less important
19:57:11 <lewis1711> I understand what cmccann said, when he told me how to code it so it would run, but involves using the same name for data constructors and types
19:58:06 <hpaste> ion annotated ‚ÄúwhatIndex‚Äù with ‚Äúbasic idea (annotation)‚Äù at http://hpaste.org/81553#a81556
19:58:07 <Eduard_Munteanu> lewis1711: you don't have to
19:58:51 <hpaste> Hrumph pasted ‚ÄúNeed to fix error‚Äù at http://hpaste.org/81557
19:59:05 <hrumph> yo someone tell me why the function is bitching about types
19:59:06 <riley__> Eduard_Munteanu: Is there any _simple_ explanation for how Haskell handles tail recursion differently? I'd like to know.
19:59:08 <Eduard_Munteanu> Arguably, that's the case for   ... = n `seq` helper xs (1 + n)   :)
19:59:18 <cmccann> lewis1711: the simplest thing would be either rename the Attack type to something like "AttackMethod", the Attack constructor to something like "AttackAction", or if they're mostly handled together anyway just merge the Melee and Ranged constructors into NonFreeAction
19:59:34 <lewis1711> that seems sensible enough
19:59:40 <riley__> Eduard_Munteanu: Or rather, doesn't...
20:00:03 <monochrom> haskell does not handle tail recursion differently. but it handles evaluation order differently
20:00:07 <ion> hrumph: Is ‚Äúyo‚Äù like ‚Äúplease‚Äù? Use Text.pack (or the OverloadedStrings extension).
20:00:23 <Eduard_Munteanu> riley__: foldr for example isn't tail-recursive, yet it produces nice results when you fold with a productive operator.
20:00:27 <ion> @type "foo"
20:00:29 <lambdabot> [Char]
20:00:30 <ion> @type Text.pack "foo"
20:00:33 <lambdabot> Couldn't find qualified module.
20:00:34 <monochrom> for example "const True (3+n)" do not evaluate 3+n first. or at least, do not have to
20:00:37 <ion> @type T.pack "foo"
20:00:39 <lambdabot> Couldn't find qualified module.
20:00:54 <ion> Text.pack :: String -> Text.Text
20:01:05 <ion> hrumph: Data.Text.pack that is, fully qualified.
20:01:07 <hrumph> ion i thought that appending  ":: Text" would cause it to be interpereted as text
20:01:23 <ion> hrumph: :: doesn‚Äôt do any type coercion.
20:01:35 <hrumph> ok
20:01:37 <Eduard_Munteanu> riley__: if you did that in C, eventually you'd blow the stack.
20:01:43 * monochrom denouces OverloadedString
20:01:54 <riley__> Haskell is just changing what the thunks contain?
20:03:05 <Eduard_Munteanu> riley__: not quite. On one hand the computation proceeds lazily. On the other hand it just creates new thunks as it goes, and the GC cleans up the previous stuff.
20:03:21 <sepp2k> hrumph: ++ takes lists as operands, not texts.
20:03:25 <Eduard_Munteanu> It's not actual mutation.
20:03:35 <monochrom> it is merely a different evaluation order
20:03:50 <hrumph> oh isee and Text is not a list but String is...
20:03:51 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml for lazy evaluation order
20:03:54 <hrumph> hmm
20:04:10 <monochrom> has foldl and foldr examples
20:04:16 <sepp2k> hrumph: Right. Use Data.Text.append to concatenate two texts.
20:04:41 <ion> hrumph: or (<>) from Data.Monoid
20:04:44 <hrumph> sepp2k: is it more efficient to work with strings then do a final pack at the end?
20:04:45 <Eduard_Munteanu> riley__: of course, if you try to foldr with say (+) on numbers, you will blow the stack. But that's because (+) on numbers is strict.
20:04:53 <monochrom> oh! I know how to give the right answer without tail recursion!
20:05:48 <Eduard_Munteanu> So, associativity aside, foldl / foldl' is nice for strict operations, foldr is nice for productive, non-strict operations.
20:06:19 <hpaste> monochrom annotated ‚ÄúwhatIndex‚Äù with ‚ÄúwhatIndex (completion)‚Äù at http://hpaste.org/81553#a81558
20:06:43 <monochrom> P.S. it is analogous to what you would do if you used Maybe
20:07:07 <monochrom> oh, I should have posted the analogous Maybe version too, then you'll see
20:07:20 <riley__> As usual, my mind is blown :) But I'm starting to see the difference.
20:09:03 <hpaste> monochrom annotated ‚ÄúwhatIndex‚Äù with ‚ÄúwhatIndex (completion, if you used Maybe)‚Äù at http://hpaste.org/81553#a81559
20:09:31 <monochrom> and it has a bug. find it!
20:09:48 <Shimizoki> monochrom: Using what you provided I was able to convert it to something that seems to work. So the theory behind it is that you have another passed argument that keeps track of the count. Then you use if if you need to, else return some hardcoded value.
20:10:25 <monochrom> yes that works nicely, I think you get it
20:11:14 <hpaste> Shimizoki annotated ‚ÄúwhatIndex‚Äù with ‚ÄúwhatIndex (annotation)‚Äù at http://hpaste.org/81553#a81560
20:11:52 <monochrom> yes that works, good good
20:12:28 <Shimizoki> Alright, that seems like a pain. I'll have to get used to that
20:13:27 <Shimizoki> Thank you very much for your patience...
20:13:33 <monochrom> you're welcome
20:14:49 <Shimizoki> So what is this maybe thing? that looks interesting
20:15:51 <ion> @src Maybe
20:15:51 <lambdabot> data Maybe a = Nothing | Just a
20:15:59 <monochrom> when the type is "Maybe Int" for example, the value has two possibilities.
20:16:03 <Eduard_Munteanu> Shimizoki: it lets you indicate failure
20:16:10 <Eduard_Munteanu> In a nicer way.
20:16:16 <monochrom> "Nothing". this value contains no Int
20:16:26 <monochrom> "Just n". this case contains an Int, it's n
20:16:35 <ion> And in a way that requires the consumer of the value to handle the failure case.
20:16:54 <ion> As opposed to for instance overloading an arbitrary integer for that.
20:17:14 <monochrom> so you can represent "no sensible answer, or one sensible answer"
20:18:10 <Shimizoki> And you use Just to indicate the sensible answer?
20:18:15 <monochrom> yes
20:19:04 <monochrom> elemIndex is similar to your homework, but it uses Maybe for that
20:19:15 <monochrom> > elemIndex 'x' ['p','q']
20:19:17 <lambdabot>   Nothing
20:19:23 <monochrom> > elemIndex 'x' ['p', 'x', 'q']
20:19:25 <lambdabot>   Just 1
20:19:31 <monochrom> those are the two possibilities
20:19:41 <Shimizoki> I also figured out why I was having so much issue with the later problems in this assignment. I was only supposed to do problem 1 (Which I finished forever ago easily).. The other stuff will be taught over then next week or two. whoops
20:19:52 <monochrom> oh hahaha
20:19:57 <ion> hehe
20:20:28 <Shimizoki> its alright... I much prefer to struggle through problems and talk to people that know the stuff than wait to know the answers.
20:20:37 <shachaf> I prefer the version where the other problems are unsolved.
20:20:54 <msxx> "<monochrom> for example "const True (3+n)" do not evaluate 3+n first. or at least, do not have to"  <- just does not have to or is it guaranteed not to?
20:21:03 <Nisstyre> Shimizoki: you could've implemented Maybe in any other language
20:21:08 <Nisstyre> it's a pretty intuitive idea
20:21:19 <Nisstyre> I'm sure it has been done thousands of times in languages with no exceptions like C
20:21:23 <shachaf> msxx: That depends on what you mean by "evaluate".
20:21:34 <shachaf> msxx: The value of that expression is guaranteed to be True
20:21:35 <monochrom> depends on whether you're talking about "Haskell, in principle" or "Haskell, in practice"
20:21:41 <msxx> will 3 + n be computed? what if n is undefined?
20:21:51 <Eduard_Munteanu> I think there are 2 notions of evaluate.
20:21:57 <msxx> monochrom both, is there a difference?
20:21:59 <Shimizoki> Nisstyre: I have used similar ideas in C, but not quite to that extent.
20:22:06 <Nisstyre> msxx: whether it's undefined doesn't have any bearing on when it will be evaluated
20:22:07 <Eduard_Munteanu> One side-effectful (will bail out on undefined), one pure.
20:22:11 <monochrom> in practice, 3+n is not evaluated. we don't have a compiler or interpreter that evalutes it
20:22:44 <monochrom> in principle, you can fork a thread to evaluate it, but make sure you discard it. in case it takes too long, make sure you abort it
20:23:07 <Eduard_Munteanu> A compiler mustn't error out on 'const True undefined' even if it attempts to evaluate undefined.
20:23:18 <shachaf> You don't even need to fork a thread.
20:23:29 <monochrom> "Haskell, in principle" only requires: "const True (3+n)" terminates and answers True. despite n being possibly bad.
20:23:32 <shachaf> You can spend at most N steps evaluating the expression, and then not use its value.
20:24:05 <monochrom> in general, I like to just stick to practice
20:24:30 <Eduard_Munteanu> It's not like theory and practice really disagree, though.
20:24:41 <msxx> yeah. it's just implementation detail
20:25:08 <napping> monochrom: in principle you don't need to bother about discarding unecessary threads either
20:27:53 <Shimizoki> How does one use modules?
20:27:54 <monochrom> no, it is not implementation detail. it is physics vs philosophy. "if a ball hits a tree but no observer is around, does it make a sound?"
20:28:07 <cmccann> ugh.
20:28:19 <Nisstyre> monochrom: contrary to popular (and even unpopular) belief, philosophy is not about asking dumb questions
20:28:20 <Shimizoki> monochrom: Thats the most interesting version of that statement I have ever heard...
20:28:41 <monochrom> my physicist answer: it makes a sound. and if you evaluate 3+n for 10 steps and then abort it and discard it, you still evaluate 3+n
20:29:29 <monochrom> the philosophy answer: perhaps it doesn't make a sound. and perhaps if you evaluate 3+n for 10 steps and then abort it and discard it, you do not evaluate 3+n
20:29:47 <glguy> o.O
20:29:53 <glguy> monochrom: it might be time to take a break ;)
20:30:07 <monochrom> Nisstyre, I do not imply that philosophy asks dumb questions. I do not understand why you are telling me this.
20:30:34 <Nisstyre> monochrom: well because "does the ball make a sound?" isn't something a philosopher would care much about
20:30:38 <startling> Nisstyre is offended. He himself is a dumb question
20:30:38 <Nisstyre> at least a good philosopher
20:30:47 <startling> Nisstyre, it's just your definition of "sound
20:30:48 <startling> "
20:31:02 * Nisstyre rolls his eyes at startling 
20:31:20 * kill9 is startled
20:33:16 * cmccann is getting seriously tempted to purge that stupid reddit post of any and all comments not directly relevant to the OP
20:33:30 <napping> I don't think it's maintained, but there was an Eager Haskell
20:33:30 <cmccann> I'm sick and need to get to bed soon and I don't trust people to not keep feeding the troll.
20:33:44 <ion> What post?
20:33:59 <Nisstyre> what Reddit post?
20:34:22 <cmccann> this one: http://www.reddit.com/r/haskell/comments/17jy0e/my_reaction_to_how_to_exclude_women_from_your/
20:34:43 <cmccann> like half the comment threads have gone off on completely irrelevant topics
20:35:17 <Nisstyre> cmccann: wait, didn't that happen a while ago?
20:35:27 <cmccann> it's in response to that
20:35:51 <cmccann> that post (which is itself more than fine) is from Doaitse himself responding to the previous one
20:35:58 <Shimizoki> how do I load a module using ghci?
20:36:00 <Nisstyre> yeah, I see that
20:36:04 <Nisstyre> so he's just responding now?
20:36:08 <Shimizoki> is it just :load path
20:36:08 <monochrom> :load filename
20:36:25 <monochrom> yes, in fact pathname is also right
20:36:43 <cmccann> Nisstyre: I don't think he's a frequent user of reddit :P
20:36:53 <Shimizoki> if the path has spaces in it, it doesnt seem to work when I put it in quotes. Is there a different way I should do it?
20:37:08 <shachaf> cmccann: help i can't tell which one is the troll
20:37:12 <shachaf> are they all trolls??
20:37:16 <cmccann> yes
20:37:18 <cmccann> especially me
20:37:19 <napping> Doaiste is the elder Swiestra, right?
20:37:57 <Nisstyre> cmccann: I don't get why someone brought up stereotype threat. He never suggested women aren't as good at programming or CS, which is what stereotype threat is about.
20:37:58 <monochrom> :load "hey you.hs" works here
20:38:09 <shachaf> cmccann: Now you've brought it to #haskell.
20:38:11 <monochrom> but try not to have spaces in the filename
20:38:26 <Nisstyre> For anyone who doesn't know it's a phenomenon where you mention that a specific group do poorly at a task, which causes them to actually do worse.
20:38:26 <cmccann> ugh. I know people complain every time I grumble about wanting to clean house on reddit posts, but trainwrecks like that comment thread are why we can't have nice things
20:38:37 <cmccann> Nisstyre: can we not get into that here?
20:38:39 <monochrom> oh, directory with spaces, that's fair enough
20:38:43 <shachaf> cmccann: Maybe #haskell-blah is a better channel for it.
20:38:45 <Shimizoki> monochrom: the space was in the path name... is there a certain folder I need to navigate to ? or have my files in?
20:38:45 <Nisstyre> cmccann: I'm not trying to start an argument.
20:38:47 <cmccann> it's not on-topic here or on /r/haskell.
20:38:49 <Nisstyre> yeah
20:39:43 <monochrom> :load "hey hey/f.hs" works here too
20:40:06 <cmccann> copumpkin: hey, feel like talking me out of doing something drastic? :P
20:40:20 <shachaf> cmccann: are you going to delete /r/haskell
20:40:44 <cmccann> shachaf: sadly I can't delete all of reddit
20:40:44 <copumpkin> cmccann: depends whether I agree with it or not :)
20:40:53 <shachaf> cmccann: It would be a big improvement on average.
20:40:58 <cmccann> copumpkin: reddit comment thread trainwreck, I am sick and irritable
20:41:21 <copumpkin> I'm so exhausted :( don't really want to get angry tonight too :(
20:41:23 <cmccann> and would seriously like to purge all comments not directly relevant to the OP and maybe ban someone who doesn't really contribute anything useful anyway
20:41:33 <monochrom> too bad you are not in #haskell-blah
20:41:55 <shachaf> cmccann: I haven't contributed anything useful to that thread.
20:41:57 <monochrom> then again, I only want to say, "dream big --- dream of deleting all of reddit" :)
20:41:59 <copumpkin> it'd be nice to be able to just lock threads
20:42:07 <shachaf> I agree that #haskell-blah would be a better channel for it.
20:42:18 <cmccann> shachaf: you've probably contributed more useful stuff to /r/haskell than this particular poster has
20:42:28 <Shimizoki> monochrom: Ahhh I see that I was loading my modules out of order... thats annoying.
20:42:44 <pharaun> what's up with haskell-blah ?
20:42:56 <monochrom> it's too quiet
20:43:05 <pharaun> heh
20:43:46 <cmccann> copumpkin: yes. I hate that there's no way to keep things on-track and constructive short of nuking stuff from orbit.
20:44:40 <Clint> unlike on this channel
20:45:01 <cmccann> one of the many reasons that reddit seems like its designed to make everything terrible. sigh.
20:45:29 <shachaf> There ought to be a thing which is like Reddit except good?
20:45:31 <shachaf> I should patent that.
20:45:41 <Nisstyre> cmccann: go ahead and delete it, I doubt that many people will miss it
20:45:49 <Clint> i think it was called usenet
20:46:04 <cmccann> no, usenet was terrible in its own ways.
20:46:07 <copumpkin> Nisstyre: no, I'm reasonably sure people will go batshit insane
20:46:12 <cmccann> they were more interesting ways though.
20:46:14 <slack1256> but usenet also was bad on certain ways
20:46:18 <copumpkin> "OMG CENSORSHIP" posts popping up all over the subreddit
20:46:21 <Clint> yes, terrible but also bad
20:46:30 <copumpkin> people have a way of going insane about shit like that
20:46:44 <monochrom> like I said, it does not take design to achieve that, and there is no design to avoid that, short of locking up
20:46:46 <Nisstyre> copumpkin: that was supposed to be a bit sarcastic :P
20:46:53 <copumpkin> :)
20:47:00 * monochrom does not allow comments on his blog, for this reason
20:47:03 <copumpkin> anyway, #haskell-blah is probably better :P
20:47:04 <cmccann> copumpkin: my tolerance for that kind of thing is dwindling every time people lack the willpower and/or common sense to not perpetuate terrible comment threads.
20:47:07 <geekosaur> see "net of a million lies"
20:47:29 <Nisstyre> monochrom: a strict comment policy isn't enough?
20:47:58 <monochrom> hmm, yes that's enough, but it's expensive
20:48:57 <monochrom> it also must contain much wide grey areas. it's easier said than done
20:50:29 <Canar> the big problem with reddit (and what's also made it so popular) is the fact that subs are "owned" rather than community managed
20:50:53 <Canar> The hierarchy is the problem, and what keeps there from being a cohesive meta-community
20:50:54 <Nisstyre> monochrom: http://languagelog.ldc.upenn.edu/nll/?page_id=72
20:50:58 <Nisstyre> that is the best one I've seen
20:53:22 <msxx> I am bothered by this selective demands for equality
20:53:27 <shachaf> copumpkin: Who cares about "OMG CENSORSHIP" posts? Just delete them.
20:53:43 <monochrom> yes Nisstyre that's nice
20:54:01 <msxx> yes women are underepresented in the technical community, highest paying jobs, but they are also underrepresented among the homeless people, construction workers, soldiers in Iraq, and numerous other dangerous and lowest-paying positions. I don't see anyone making demands for equality in those areas
20:54:02 <monochrom> haha shachaf wins
20:54:10 <Nisstyre> monochrom: yeah if you want to discuss it more talk in #haskell-blah
20:54:13 <cmccann> shachaf: I already did that today, someone created a sockpuppet account just to post a passive-aggressive comment about moderation.
20:54:20 <shachaf> msxx: Please, not here/now.
20:54:32 <cmccann> msxx: for fuck's sake, don't.
20:54:48 <Canar> ShitRedditSays might be watching.
20:54:57 * Canar hides
20:54:58 <msxx> cmccann, well you kind of brought it up.
20:55:05 <shachaf> msxx: Just stop.
20:56:02 <msxx> shachaf I wasn't the one who brought the topic in. anyway I am stopping
20:56:36 <hpaste> Hrumph pasted ‚ÄúAnother problen‚Äù at http://hpaste.org/81562
20:56:40 <cmccann> nobody brought the topic up. it's not a relevant topic.
20:56:48 <shachaf> I wish clicking on the "stackoverflow" logo took you to /questions/tagged/haskell
20:57:04 <cmccann> the topic I did bring up was DELETING A BUNCH OF STUPID COMMENTS talking about that topic.
20:57:55 <msxx> cmccann and why did you link the page?
20:58:04 <shachaf> Let's have a big argument about why cmccann linked that page.
20:58:19 <geekosaur> msxx: take it to #haskell-blah where it's on topic
20:58:37 <shachaf> It's also on-topic in #haskell-/dev/null
20:59:14 <shachaf> People who aren't in #haskell-blah shouldn't tell other people to go there to get rid of them. -blah is not meant to be a trash can.
20:59:29 <hrumph> if we put the arg in special syntax maybe it will be on topic sort of like [offtopic| did you know that .... |]
20:59:34 <hrumph> anway help me with my problem
21:00:17 <slack1256> I am currently reading ttfp, the main focus of dependent types is to develop "proofs" but appart from more safety, what else do we get?
21:00:35 <slack1256> do we get more semantic power? or more opportunities of performance?
21:00:51 <Nisstyre> slack1256: you get more auto-generated code
21:01:01 <shachaf> hrumph: That doesn't look like a valid Haskell file.
21:01:07 <Nisstyre> slack1256: http://youtu.be/XGyJ519RY6Y
21:01:07 <shachaf> It doesn't have 38 lines.
21:01:10 <slack1256> Well, yeah ttfp also says that
21:01:18 <hrumph> oh i see i'm missing a bracket
21:01:23 <slack1256> but also says that maybe isn't the optimum program for the specification.
21:01:25 <hrumph> i accidentally deleted a bracket
21:01:34 <hrumph> shachaf: its valid
21:01:55 <hrumph> i accidentally deleted two brackets before the snippet
21:01:57 <shachaf> hrumph: Well, the error is for a file with at least 38 lines.
21:02:09 <hrumph> schachaf yes i only posted a snippet
21:02:12 <shachaf> hrumph: (My point was that you didn't paste the whole code, and that the actual problem was elsewhere.)
21:02:40 <shachaf> (So you should paste something that you're sure actually gives you an error. :-) )
21:04:54 <hrumph> sorry schachaf but there's a lot of junk code in this file as i hammer it into shape
21:05:07 <hrumph> if i posted the whole thing there would be a lot of garbage posted
21:06:11 <schellsan> do any of you use vim + ghc-mod?
21:06:43 <hrumph> shachaf furthermore most people in this chan aren't familiar with the yesod quasi quoters
21:06:56 <shachaf> hrumph: Good point.
21:07:25 <hrumph> if i get aroudn to it i'll take them all out entirely and put them in files
21:07:34 <hrumph> which i think is best practice but its a pain
21:08:00 <hrumph> they certainly make the code hard to read
21:09:44 <tieTYT2> I'm reading learn you a haskell and it's explaining that a lot of the functions in Data.Set/Map/List overlap so you've gotta qualify them.  Can someone explain to me why this doesn't get annoying?
21:10:07 <hrumph> tieTYT2: i am still a haskell newbit bue you never have to import everything
21:10:12 <shachaf> It's not very annoying to type S.filter to filter a set.
21:10:43 <schellsan> tieTYT2: you can also only import specific functions from a module
21:10:47 <startling> tieTYT2: it is annoying, but S.filter isn't so bad.
21:10:48 <geekosaur> thaty's your answer.  import qualified Muble.Frotz.Foobie as MF
21:10:51 <tieTYT2> shachaf: I was hoping you were going to say "you rarely use more than one of those Data's per haskell file or something
21:11:07 <startling> tieTYT2: well, that's true, too.
21:11:21 <shachaf> tieTYT2: QUalified imports are not so bad.
21:11:39 <startling> I like qualified imports.
21:11:42 <startling> They are so easy.
21:11:43 <tieTYT2> ok, I'll take your word for it.  You rarely do it in java and it'd be super annoying if you usually had to
21:11:45 <schellsan> tieTYT2: and in that case you can do import Data.List (head) or something
21:11:59 <geekosaur> yes, but in Java you make up for it in your class names :)
21:12:00 <startling> tieTYT2: Java is kind of its own little island. :|
21:12:18 <tieTYT2> geekosaur: hah, that's mostly in Spring
21:12:19 <shachaf> tieTYT2: There are also other approaches.
21:12:34 <shachaf> For example lenses let you do some of these operations nicely.
21:12:45 <tieTYT2> i haven't learned of lenses yet
21:13:05 <shachaf> Don't.
21:13:08 <shachaf> Learn Haskell first. :-)
21:13:34 <tieTYT2> will do
21:13:37 <tieTYT2> back to the book
21:13:57 <Shimizoki> monochrom: Thank you for all your help, And everyone else aswell. I think I got everything I need for now. Take care.
21:14:02 <monochrom> w00t Haskell Weekly News!
21:14:17 <monochrom> you're welcome
21:14:38 <shachaf> monochrom: You've been quoted!
21:14:43 <shachaf> I don't understand your quote, though.
21:15:11 <shachaf> I thought that I'd been quoted, but it turns out I've only been quoted contravariantly.
21:15:16 <monochrom> the only relation between the two is that I personally refuse both. that is all
21:15:48 <shachaf> Haskell uses camel case. You don't seem to refuse it.
21:15:55 * cmccann creates a fake facebook account named "MonoChrom"
21:16:15 <monochrom> right, but I don't add more camel case names. I add names like lock_up
21:16:43 <cmccann> real programmers don't use either, andjustmashwordstogether.
21:17:08 <monochrom> and especially when I post on hpaste, I write like lock_up, and I don't care what hlint says, hlint can go to reddit
21:17:12 <Ralith> cmccann is only half real programmer.
21:17:17 <mason2> I am stuck at writing a haskell equivalent of what would be two nested loops in an imperative language, with inner most loop optionally terminating both loops and writing result to a variable right before terminating
21:17:49 <shachaf> mason2: You could use a list.
21:18:15 * hackagebot citation-resolve 0.1.0.0 - convert document IDs such as DOI, ISBN, arXiv ID to bibliographic reference.  http://hackage.haskell.org/package/citation-resolve-0.1.0.0 (TakayukiMuranushi)
21:18:40 <mason2> can you explain how?
21:19:15 <shachaf> How to what?
21:19:23 <mikeplus64> > [ (x, y) | x <- [0..10], y <- [0..x], even (x + y) ]
21:19:24 <lambdabot>   [(0,0),(1,1),(2,0),(2,2),(3,1),(3,3),(4,0),(4,2),(4,4),(5,1),(5,3),(5,5),(6...
21:20:24 <mason2> "use lists" didnt make me any smarter than before I asked the question
21:20:40 <mason2> here is what I am trying to emulate:
21:20:55 <shachaf> mason2: Your question was too vague to give a concrete answer to.
21:21:12 <monochrom> but more concrete is coming
21:21:20 <hpaste> mason pasted ‚Äúhow to do something like this in haskell‚Äù at http://hpaste.org/81564
21:22:49 <mason2> it involves IO btw
21:22:51 <monochrom> > head [ i+j | i<-[0..100], j<-[0..100], i==j ]
21:22:53 <lambdabot>   0
21:23:12 <shachaf> You could always do it with two nested loops.
21:23:20 <shachaf> Oh, wait, you posted code.
21:23:39 <shachaf> Not that I see any IO in that code.
21:23:51 <monochrom> IO makes it a bit different
21:23:52 <mikeplus64> mason2: you can't goto in haskell. you can call/cc, but that's maybe overkill. if it involves IO then you might just be best off writing the loops yourself; for i | i < limit = ...; | otherwise = return ()
21:24:53 <monochrom> why is IO involved? is it because "if something" reads the outside world?
21:25:17 <mikeplus64> mason2: in that definition, you'd have maybe 'if something then writeIORef result else for (i+1)'
21:25:19 <mason2> I am iterating through image array
21:25:42 <mikeplus64> (assuming your function :: IO (), if not, maybe just return it normally)
21:25:51 <mikeplus64> (for using IORefs or not)
21:26:16 <mason2> I was hoping it could be done without IORef
21:26:26 <mikeplus64> it probably can
21:26:27 <monochrom> what is the type of the array? I don't believe IO is needed
21:26:34 <mikeplus64> @hackage repa
21:26:34 <lambdabot> http://hackage.haskell.org/package/repa
21:26:41 <mason2> :t arrayRead
21:26:43 <lambdabot> Not in scope: `arrayRead'
21:27:02 <mikeplus64> mason2: this package is very good at parallel multi-dimensional array processing
21:27:15 <mason2> it is MArray
21:27:45 <monochrom> ok, MArray is fair, but you should be able to obtain an immutable array to begin with
21:28:43 <monochrom> for example use unsafeFreeze...
21:29:03 <mason2> I see
21:29:22 <monochrom> then it's just "head [ a!i + a!j | i<-[0..100], y<-[0..100], a!i == a!j ]"
21:29:55 <monochrom> (obtain a from "a <- unsafeFreeze the_marray")
21:32:47 <mason2> so that would terminate when a!i equals a!j
21:33:18 <monochrom> yes
21:34:14 <mason2> is freeze expensive?
21:34:32 <mikeplus64> what stops list-like monad instances for arrays being made? that way you could use list comprehension syntax with them
21:34:38 <monochrom> freeze is expensive. does a copy. unsafeFreeze is cheap. optimizer tries to avoid copy.
21:34:50 <mason2> ah
21:35:21 <monochrom> if you don't want to use unsafeFreeze, I have other ideas too
21:36:21 <mason2> ok go on, I will need them if I ever need to mutate the array for speed reasons.
21:36:35 <mason2> for read-only access though this looks nice
21:36:38 <latermuse> Quick question: Haskell installs easiest on which linux distribution?
21:36:48 <latermuse> ive had nightmares with centos
21:38:02 <cmccann> I use ubuntu and typically install GHC binaries myself rather than use the distro repositories
21:38:24 <latermuse> it installed easily on my mac
21:38:38 <latermuse> but im about to setup a new server, and need haskell working as soon as possible out of the box
21:38:38 <cmccann> never had any real problems that weren't caused by not following monochrom's advice on using cabal
21:38:44 <latermuse> and have a free choice of operating systems
21:38:58 <latermuse> cmccann: do you have a link for that?
21:39:42 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/103083
21:40:16 <cmccann> latermuse: I do now!
21:40:30 * cmccann never bothered to bookmark it since monochrom gives the link out so often
21:41:46 <monochrom> actually it's a new one
21:42:25 <monochrom> the one you're thinking of is http://www.vex.net/~trebla/haskell/sicp.xhtml
21:43:16 * hackagebot aws-sdk 0.9.4.1 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.9.4.1 (YusukeNomura)
21:44:30 <hpaste> monochrom annotated ‚Äúhow to do something like this in haskell‚Äù with ‚Äúhow to do something like this in haskell (annotation)‚Äù at http://hpaste.org/81564#a81565
21:44:52 <monochrom> mason2: that paste would be the next thing I try
21:45:07 <latermuse> does haskell install easily from ports on freebsd?
21:45:55 <monochrom> there is a bug
21:46:16 <hpaste> monochrom annotated ‚Äúhow to do something like this in haskell‚Äù with ‚Äúhow to do something like this in haskell (annotation) (annotation)‚Äù at http://hpaste.org/81564#a81566
21:46:26 <monochrom> that is the bugfix
21:47:15 <elkng>  /join haskel
21:47:33 <mason2> thanks monochrom
21:47:38 <elkng> why /join haskel redirects here ?
21:49:05 <cmccann> monochrom: yes, but that link is one of the first things in the message
21:49:12 <mason2> that looks good
21:49:13 <monochrom> oh!
21:49:15 <elkng> http://4.bp.blogspot.com/-vB4CktTAYIU/UMtVpLztkrI/AAAAAAAAAbQ/2qkHhjcIrUo/s1600/IMAG0931.jpg is that haskell related ?
21:49:58 <cmccann> elkng: the guy with the beard is one of the people who designed Haskell
21:50:02 <elkng> I mean those text on shirt
21:50:19 <elkng>  no those two biig thingie under shirt
21:50:37 <cmccann> the text is a reference to a joke which was itself a reference to research done by the guy with the beard.
21:53:57 <M30W> How would one have an either with 6 different possibilities? Reimplent either?
21:54:30 <M30W> Or do it the right way :3
21:54:31 <ion> That wouldn‚Äôt be a reimplementation of Either.
21:54:35 <cmccann> M30W: or use nested Eithers
21:54:37 <elkng> cmccann: why are you referencing to the guy with the beard so many times ?
21:54:44 <elkng> is he so important ?
21:55:34 <cmccann> M30W: if you have a particular set of six possibilities, you should make a custom data type for it
21:55:47 <M30W> cmccann: I have that already
21:56:34 <M30W> data Direction = North | East | South | West | Up | Down | Direction { direction :: Direction } -- Not gonna work.
21:57:23 <cmccann> M30W: I'm not sure what you're trying to do there
21:58:16 * hackagebot embeddock 0.1.0.1 - Embed the values in scope in the haddock documentation of the module  http://hackage.haskell.org/package/embeddock-0.1.0.1 (TakayukiMuranushi)
22:00:43 <aavogt> M30W: that's legal, no?
22:01:24 <aavogt> Direction { direction :: [Direction] } -- might make more sense
22:02:34 <M30W> aavogt: You can't have a list of directions.
22:02:58 <aavogt> how about north northeast?
22:03:13 <M30W> Not that 3D :P
22:03:27 <M30W> (Text adventure)
22:03:29 <M30W> =)
22:04:33 <Nisstyre> M30W: have you looked at zippers?
22:04:45 <Nisstyre> there is an example on wikibooks that uses zippers to create an adventure game
22:04:55 <aavogt> sometimes you have hexagon grids, which means you need two more than (North | East | South | West)
22:05:14 <M30W> Nisstyre: I've looked but I'm not quite sure how to use them (Even seen that page)
22:05:39 <M30W> I'm kinda making my M.Map's similar to a tree with zippers but I haven't played with the zippers yet.
22:05:40 <Nisstyre> M30W: the idea is that you "save" the previous nodes
22:05:48 <Nisstyre> the ones you iterated through to find the current one
22:06:05 <Nisstyre> that includes the root obviously
22:06:22 <aavogt> Nisstyre: is there any advantage if you don't need an undo?
22:06:48 <Nisstyre> aavogt: if you wish to "mutate" it there is a clear advantage
22:07:22 <TravisD> Can you use zippers to efficiently "modify" linked lists in the middle?
22:07:26 <Nisstyre> yes
22:07:32 <TravisD> neat :)
22:07:41 <Nisstyre> look at Xmonad for an example
22:07:59 <TravisD> thanks - I'm just learning Haskell so that might be a bit down the road
22:08:10 <aavogt> efficiency isn't very important to xmonad
22:08:30 <aavogt> it's not like you have more than a hundred windows
22:08:46 <Nisstyre> speak for yourself >.>
22:10:15 <fragamus> Data.List.nub is O(n^2)
22:10:19 <fragamus> ugh
22:12:10 <aavogt> Nisstyre: depending on what's going on in your configuration, it's pretty likely that some things are linear or quadratic in the number of windows
22:12:14 <Nereid> fragamus: can it be improved?
22:12:20 <geekosaur> it has to rely solely on (==) wjich makes it more general but slower
22:12:35 <Nereid> ah yeah, I guess it could if you had Ord
22:12:40 <aavogt> without it becoming an issue
22:12:40 <Nereid> or something
22:12:43 <hpaste> schellsan pasted ‚Äúupdate yesod‚Äù at http://hpaste.org/81568
22:12:57 <M30W> Nisstyre: How would the tree be for my game with 6 possible directions ?
22:13:04 <M30W> (For the zipper)
22:13:22 <fmap> if you have `Ord' there is `S.toList . S.fromList'
22:13:41 <Nereid> is that stable?
22:13:50 <geekosaur> I think head . group . sort is the usual Ord-using version?
22:14:02 <geekosaur> something like
22:14:37 <geekosaur> no
22:14:37 <geekosaur> map head . group . sort
22:14:37 <schellsan> in order to use update in yesod, do i have to write an instance for PersistQuery IO?
22:14:37 <geekosaur> head of each group
22:14:37 <Nereid> yeah, that totally jumbles up the order so no
22:14:52 <Nereid> I would stick the elements seen so far in a Set and then remove the ones that are in the  set
22:16:18 <mikeplus64> schellsan: i don't know, but maybe #yesod will
22:16:18 <mikeplus64> (although #haskell may also)
22:16:18 <Nereid> set insertion and membership is O(log n) so you'd get O(n log n) that way.
22:16:18 <Nereid> @src nub
22:16:18 <lambdabot> nub = nubBy (==)
22:16:18 <Nereid> @src nubBy
22:16:18 <lambdabot> nubBy eq []             =  []
22:16:18 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
22:16:18 <mikeplus64> schellsan: a guess is that you don't want to use IO, you want to use one of yesod's monads. do :i PersistQuery to see what instances for what types it has
22:16:27 <snoyberg> schellsan: you don't need such an instance, you just need to call the appropriate run function based on your backend
22:17:14 <Nereid> > Set.empty
22:17:14 <lambdabot>   Not in scope: `Set.empty'
22:17:14 <lambdabot>  Perhaps you meant one of these:
22:17:14 <lambdabot>    `Seq.empty' (...
22:17:14 <snoyberg> schellsan: if you're in a scaffolded site, you'll want runDB
22:17:14 <Nereid> > S.empty
22:17:14 <lambdabot>   fromList []
22:17:14 <snoyberg> schellsan: if you're not in a yesod app, you can see an example of using persistent standalone in the synopsis of http://www.yesodweb.com/book/persistent
22:17:50 <schellsan> snoyberg: yes, i'm using it in an irc bot and i've been trying to follow that post
22:18:02 <Nereid> > let nubSet xs = nubSet' xs (S.empty) = []; nubSet' [] _ = []; nubSet' (x:xs) s = if x `S.member` s then nubSet' xs s else x : nubSet' xs (S.insert x s) in nubSet [1,2,3,2,4,4,5]
22:18:04 <lambdabot>   <hint>:1:38: parse error on input `='
22:18:18 <Nereid> uh
22:18:38 <Nereid> > let nubSet xs = nubSet' xs S.empty; nubSet' [] _ = []; nubSet' (x:xs) s = if x `S.member` s then nubSet' xs s else x : nubSet' xs (S.insert x s) in nubSet [1,2,3,2,4,4,5]
22:18:39 <schellsan> snoyberg: ultimately it's called from a runResourceT
22:18:40 <lambdabot>   [1,2,3,4,5]
22:18:56 <snoyberg> schellsan: the reason you can't create a `PersistQuery IO` is that IO has no context to determine the database connection to use
22:19:16 <Nereid> > S.toList . S.fromList $ [5,2,3,3,1,4,2]
22:19:19 <lambdabot>   [1,2,3,4,5]
22:19:26 <Nereid> yeah, order where.
22:19:41 <TravisD> What does nub stand for? Is the goal to remove duplicates from a list?
22:19:42 <Nereid> @let nubSet xs = nubSet' xs S.empty where nubSet' [] _ = []; nubSet' (x:xs) s = if x `S.member` s then nubSet' xs s else x : nubSet' xs (S.insert x s)
22:19:42 <lambdabot>  Defined.
22:19:42 <Nereid> TravisD: yes.
22:19:59 <Nereid> the docs claim "The name nub means `essence'."
22:19:59 <mm_freak> do you say "boldlier" or "more boldly"?
