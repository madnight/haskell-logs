00:19:38 <fragamus> any library that does this?
00:19:40 <fragamus> (\(x1:x2:[]) -> (x1,x2))
00:20:12 <Cale> fragamus: Nothing standard.
00:20:20 <fragamus> mkay
00:20:31 <Cale> fragamus: btw, you could also write that (\[x,y] -> (x,y))
00:20:42 <fragamus> oh nice ill try that
00:20:56 <Cale> tbh, I think the lambda is probably nicer than any other name you could give it
00:25:27 <Iceland_jack> fragamus: what would the function do for lists of other lengths? throw an error?
00:25:37 <fragamus> yeah
00:25:45 <elliott> it's not a particularly nice function to start with
00:25:52 <fragamus> you're right
00:26:45 <Iceland_jack> There isn't a lot of situations where you'd want to convert between lists and tuples
00:27:13 <Iceland_jack> Tuples have a fixed length, lists are homogeneous etc.
00:27:20 <Iceland_jack> *aren't a lot
00:35:08 <donri> > (,)<$>(!!0)<*>(!!1)$ [a,b]
00:35:09 <lambdabot>   (a,b)
00:35:14 <donri> BEAUTIFUL
00:35:52 <elliott> > (length "head", length "(!!0)")
00:35:54 <lambdabot>   (4,5)
00:36:00 <elliott> donri: for shame
00:36:09 <donri> elliott: not enough punctuation
00:37:04 <donri> > liftA2 (,) head (head.tail) [a,b]
00:37:06 <lambdabot>   (a,b)
00:37:34 <johnw> > liftA2 (,) head last [a,b]
00:37:36 <lambdabot>   (a,b)
00:37:38 <donri> > liftA2 (,) head (fmap head tail) [a,b]
00:37:40 <lambdabot>   (a,b)
00:38:28 <donri> > liftA2 (,) head last [a,b,c]
00:38:29 <lambdabot>   (a,c)
00:39:08 <johnw> i want an idiom like ifM' for: do x <- f ; if x then y else z
00:39:31 <donri> @hackage cond
00:39:31 <lambdabot> http://hackage.haskell.org/package/cond
00:39:50 <johnw> nice, thanks!
00:40:01 <johnw> heh, he calls it ifM too :)
00:41:00 <donri> :)
00:42:15 <startling> yeah, that sounds really useful
00:44:12 <johnw> it's too bad Haskell doesn't have a builtin cond that makes guards available at the expression level
00:44:21 <johnw> list-based cond is too ugly
00:44:34 <elliott> ghc does nowadays
00:44:43 <johnw> it does?  you mean multiway if?
00:45:17 <gdeest_> Hi, is there a nice and easy way to launch a bunch of threads, and wait indefinetely for any thread crash ?
00:45:29 <elliott> johnw: yeah
00:45:51 <gdeest_> I've got a few threads communicating to each other by channels, and I'd like the whole program to end whenever one of these threads fails
00:47:34 <gdeest_> (the whole program is run as a system daemon, and may fail if the database server is not up. I'd prefer to let the system respawn the process automatically rather than catching all exceptions in each thread, and relaunching the action)
00:48:36 <donri> sadly multiway if doesn't nest
00:48:51 <donri> http://hackage.haskell.org/trac/ghc/ticket/4359#comment:89
00:50:21 <Saizan> we could just have a very thin sugar over case () of () | ...
01:55:47 <hpaste> freddy pasted “cel'hofatta” at http://hpaste.org/80245
01:56:02 <hpaste> freddy pasted “miracolo” at http://hpaste.org/80246
02:07:20 * hackagebot iCalendar 0.2 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.2 (ChristianRoedliAmble)
02:22:39 <PHO_> !seen sjamaan
02:23:05 <PHO_> !help
02:23:16 <lightquake> does netwire have a way to 'lift' a wire, or do all my wires have to be in the same monad?
02:25:59 <notdan> how can I tell Haskell not to import some class instance?
02:27:21 <lightquake> notdan: you can't
02:27:33 <lightquake> if a module defines a class instance, every module that imports it gets that instance
02:29:47 <notdan> I see, thanks
02:34:14 <gspr> This is probably a long-shot, but: does anybody know if there's a video or writeup accompanying Magalhães's "More Well-Typed Than Ever" presentation (http://dreixel.net/research/pdf/ghc7.6mwtte_pres_dhd2012.pdf) ?
02:40:28 <donri> gspr: i recall seeing such a video, but i don't have a link...
02:40:47 <gspr> donri: Ah, but at least that means I should probably keep looking :)
02:41:03 <donri> gspr: http://vimeo.com/42399455
02:41:18 <donri> i lied
02:41:26 <gspr> hehe
02:41:44 <gspr> damn, how could I have overlooked that? It has the same title as the presentation slides I linked to
02:41:47 <gspr> oh well, thanks :)
02:43:10 <gspr> I'm still pretty much in the dark with the stuff he's talking about.. how much is just (very nice) sugar to make life easier when doing type-level stuff?
02:43:42 <gspr> I guess what I'm really asking is: at, say, GHC 7.4, is it still possible to (relatively comfortably) do length-typed vectors and similar?
02:49:25 <srhb> gspr: http://byorgey.wordpress.com/2010/07/19/typed-type-level-programming-in-haskell-part-iii-i-can-haz-typs-plz/ -- perhaps you can compare here
02:49:34 <gspr> (or, put another way, as someone who's been putting off learning about type-level programming way too long and finally wants to get his hands dirty: does it really pay off to get GHC 7.6, or might I just as well start learning with my package manager's version, 7.4.2?)
02:50:03 <srhb> I don't know the answer, but I'm in the same boat, so I'm listening intently. ^^
02:50:13 <gspr> srhb: Yeah, that's actually the (series of) blog post(s) that got me interested in the first place :)
02:50:20 <srhb> Ah :)
02:50:44 <gspr> srhb: The way conal does it seems workable, but then again, people are really singing the praises of the 7.6 I hear
02:51:04 <srhb> gspr: I've the same feeling, but nothing concrete to add. :D
02:51:24 <gspr> Maybe I should just not be typical me, hovering around looking for the best approach, and instead get my hands dirty :P
02:52:17 <srhb> gspr: Mirror, mirror on the wall...
02:52:59 <srhb> I think the problem (for me) is to see the practical applications. Not that the academics aren't interesting, but it's hard to "dive in" when you don't have a concrete problem to solve.
02:53:16 <Lethalman> hi I have a function satisfy :: Graph -> Bool, that returns True/False depending on certain properties of the given graph... now I pass this function to other functions
02:53:31 <Lethalman> now I decide that I could use a cache in the satisfy function
02:53:42 <gspr> srhb: Well, the canonical example of length-typed lists seems *very* useful (in the pracitcal sense) to me.
02:53:46 <Lethalman> would that be possible without changing the type of satisfy?
02:54:55 <srhb> Lethalman: Doesn't sound likely, no. Unless you're talking about memoization in which case the function itself need not be changed
02:55:04 <gspr> srhb: Oh, btw, I seem to have partially answered my own question with regards to how necessary the 7.6 stuff is: slide 8 (PDF page 11) of http://dreixel.net/research/pdf/ghc7.6mwtte_pres_dhd2012.pdf
02:55:06 <srhb> gspr: Yes, that's true. The one example :P
02:55:09 <Lethalman> srhb, oh
02:56:39 <Lethalman> srhb, I think so, that is I want satisfy to return immediately if it already seen the same Graph
02:56:46 <Lethalman> srhb, an LRU cache
02:58:23 <merijn> Lethalman: What you want is commonly called memoisation
02:58:32 <Lethalman> merijn, ok
02:58:40 <invariant> Lethalman, that is not expressible in Haskell without using extensions.
02:59:18 <srhb> gspr: Right.
02:59:21 <merijn> Lethalman: There's some papers on nice ways to do in haskell without changing the original function type, but some of those are also a bit complicated to understand, not sure if anyone can offer simpler alternatives
02:59:22 <Lethalman> mh
02:59:35 <srhb> gspr: The kind restriction looks terribly smart.
02:59:55 <Lethalman> this is one of the things that imperative algorithms solve for instance
03:00:00 <Lethalman> *imperative languages
03:00:09 <Lethalman> since you can store the cache somewhere
03:00:21 <hugosthlm> I'm trying to install EclipseFP in Ubuntu 12.10. I get this error http://cnebula.blogspot.se/2012/07/hoogle-problem-in-eclipsefp-unexpected.html . I can't follow the instructions because scion-browser 0.2.9 doesn't install. "    No instance for (MonadResource IO)       arising from a use of `get'"
03:00:22 <gspr> srhb: Yes
03:00:27 <srhb> Lethalman: Feel free to unsafeReadCache
03:00:45 <invariant> merijn, without extensions, you cannot.
03:00:58 <merijn> invariant: Without extensions I can't do anything in haskell anyway
03:01:04 <Lethalman> srhb, ah
03:01:08 <invariant> merijn, Oleg can.
03:01:14 <invariant> merijn, and Galois can.
03:01:34 <invariant> merijn, hardly an argument that you can't.
03:01:35 <Lethalman> srhb, invariant, alternatively I need a monad right?
03:01:44 <invariant> Lethalman, you never need a monad.
03:01:46 <srhb> Lethalman: That's the easiest way to go
03:01:47 <merijn> invariant: I fail to see the point in this discussion?
03:01:52 <Lethalman> :S
03:01:54 <invariant> Lethalman, you could use a monad.
03:01:58 <hugosthlm> Any better room to discuss EclipseFP?
03:02:03 <invariant> Lethalman, but you never need one.
03:02:04 <srhb> invariant: You're being counterproductive. :P
03:02:10 <Lethalman> invariant, and how would you do that then?
03:02:17 <merijn> invariant: Also, I fail to see how whatever Oleg/Galois/whoever can do reflects on what *I* can do
03:02:24 * hackagebot regex-pcre-builtin 0.94.4.5.8.31 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.5.8.31 (AudreyTang)
03:02:35 <invariant> merijn, you used it as a kind of argument as if it meant something.
03:02:43 <invariant> merijn, it was an argument based on authority.
03:02:50 <srhb> *headdesk*
03:03:11 <invariant> Lethalman, that would depend on the problem.
03:03:23 <merijn> invariant: It *is* an argument of authority
03:03:23 <Lethalman> invariant, the problem is what I stated
03:03:26 <invariant> Lethalman, but if you just want an easy solution, use a state monad transformer.
03:03:41 <merijn> Argument from authority is only a fallacy if someone *isn't actually an authority on the subject*
03:03:51 <invariant> merijn, which happens to be the case.
03:03:55 <Lethalman> srhb, srhb, something like satisfy :: Graph -> SomeMonad Bool ? but I may have different satisfy
03:04:07 <merijn> invariant: Oh? And you know this because?
03:04:11 <Lethalman> like satisfy1, satisfy2...
03:04:20 <Lethalman> that may use different monads
03:04:25 <invariant> Lethalman, or extend it to MonadCache
03:04:26 <srhb> Lethalman: The trivial example is something like Graph -> PathToDataBase -> IO Bool
03:04:38 <Doikor> argument from authority is always fallacy. use some actual proof/reasoning instead.
03:04:49 <srhb> Lethalman: In which your function first does a lookup in your database and otherwise generates the answer and puts it in the database before returning
03:05:02 <quicksilver> hugosthlm: I don't know of a better place, but I don't think many people here use it.
03:05:18 <Lethalman> srhb, ok, that obviously needs rewriting of all my satisfy functions plus all the users
03:05:33 <srhb> Lethalman: Probably.
03:05:41 <srhb> Lethalman: The type system will help you, though.
03:05:52 <invariant> Lethalman, if you are pointing out some kind of design flaw in the Haskell language, then yes, this is an annoying feature.
03:06:15 <merijn> Doikor: No, they're a *weaker* argument than proof/reasoning, but they're certainly not a fallacy and in cases where actual proofs are impossible for whatever reason they certainly apply
03:06:29 <Lethalman> srhb, what if I have different satisfy functions, and they may use different monads?
03:06:40 <srhb> invariant: What is?
03:06:43 <Lethalman> srhb, I stick with IO Bool and lift everything?
03:07:11 <srhb> Lethalman: I didn't advise you to use IO Bool, you could certainly make a common interface, the example was slightly contrivewd.
03:07:17 <Lethalman> ok
03:07:45 <Lethalman> but in generale I need m Bool as return type, that's for sure
03:08:10 <Lethalman> MonadCache is interesting though, thanks
03:08:43 <Skillsob> @quote research.language
03:08:43 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
03:08:44 <lambdabot> s, phone apps, and web services.
03:09:21 <invariant> I wonder how much stock trading happens in Haskell in terms of volume of some US market.
03:09:40 <invariant> I think less than a hundredth of a percent.
03:10:36 <invariant> Same with bioinformatics. The people who actually work in bioinformatics are not using Haskell.
03:11:08 <invariant> If WhatsApp says that they use Erlang, that might mean something.
03:11:23 <invariant> Then again, they patched the run-time system and the Linux kernel to make it work.
03:11:37 <invariant> As such, any such statements are rather worthless without details.
03:12:54 <invariant> They actually use FreeBSD, but the same likely applies .
03:24:04 <Jafet> invariant: the percentage might vary depending on whether you include Knight's $400m investment
03:24:28 <invariant> Jafet, you mean their bad trade?
03:31:49 <kvda> hello, anyone using Haskell on OpenBSD?
03:32:16 <Jafet> > 400e6 / 141e9
03:32:18 <lambdabot>   2.8368794326241137e-3
03:32:27 <Jafet> Perhaps not.
03:34:15 <ciaranm> netcraft confirms: openbsd is dead
03:35:13 <invariant> Jafet, but did they use Haskell for that?
03:35:24 <Jafet> Nobody knows.
03:36:38 <invariant> Jafet, do you know what happens when someone hacks into a trading system and starts trading? Are the trades reversed or is it just tough luck?
03:37:27 <kvda> ciarnam, lel, openbsd is stronger than most other bsd's
03:37:30 <ciaranm> invariant: depends upon who has more friends in high places
03:37:47 <kvda> better than lunix anyway
03:37:52 <kvda> :p
03:38:07 <Jafet> It depends on the exchange. NYSE redacted a few of Knight's trade.
03:38:35 <bxc> invariant: trades get cancelled for other reasons, which is not specifically reason for them to be cancelled for hacking
03:38:41 <bxc> but the principle does exist
03:39:22 <invariant> Jafet, perhaps it is more than 0.01% ;)
03:39:42 <invariant> Since apparently all the high rollers (er quants) are here.
03:45:26 <Jafet> It's actually very easy to discourage hackers. Hire them and give them equity.
03:45:57 <kvda> the competent ones anyway
03:57:42 <Gem> test
04:08:52 <gspr> So I just started learning type-level stuff, doing the obligatory length-typed vectors first. I know I'm missing something major here, but here it goes still:
04:09:13 <gspr> Suppose Nat is the usual type-level naturals kind
04:09:29 <gspr> and data Vect :: * -> Nat -> * as usual
04:10:01 <HugoDaniel> hi
04:10:07 <gspr> is it possible to express something like "Vect a n for any Nat n"?
04:10:12 <HugoDaniel> how can i know how much memory my data type instance is occupying ?
04:10:22 <merijn> gspr: Yes
04:10:39 <merijn> gspr: Lemme peek what the correct syntax is, I forget
04:10:40 <gspr> merijn: If I were to guess... would this be... kind polymorphism?
04:11:12 <merijn> gspr: I don't think you need kind polymorphism for this
04:11:42 <quicksilver> forall a :: *, n :: Nat. Vect a n
04:11:44 <quicksilver> isn't it?
04:11:57 <merijn> quicksilver: Yeah, I think so
04:12:27 <merijn> Actually just having "Vect a n" should be sufficient as the foralls can usually be omitted as normal
04:12:36 <gspr> hmm, this sounds reasonable
04:14:56 <gspr> So let's see... Kind polymorphism would then be... "unknown kinds" in a sense?
04:15:12 <merijn> gspr: Yes
04:15:36 <gspr> OK, good! And this is *not* to be confused with the kind "*", right? Which is simply a particular kind?
04:15:50 <quicksilver> yes
04:15:53 <gspr> great
04:15:56 <quicksilver> * is a particular kind - the kind of normal types
04:16:00 <merijn> Instead of having "data Foo :: * -> *" you'd have "Foo :: ? -> *" where ? can have any kind (i.e. *, * -> *, or Nat)
04:16:15 <gspr> Yes, right, makes sense.
04:16:19 <quicksilver> * is not supposed to make you think of wildcards (a.l.a. shell or regexp or DOS)
04:16:31 <quicksilver> it's supposed to be "a single distinguished element"
04:16:31 <gspr> Right, it does :)
04:16:37 <quicksilver> as in "the set {*}"
04:16:56 <gspr> Yes, I'll try to keep that in mind! It'll be my one-point set from now on. Damn you BASH.
04:18:19 <gspr> OK, so, learning this kind stuff has revealed a confusion regarding ordinary types I seem to have carried with me all along. So here comes an embarassing question to clear it up: Is, say,  [a]  a type? I've always thought of it as something "taking a type and giving a new type"...
04:18:41 <gspr> this is coming back to haunt me now "one level up"
04:19:03 <srhb> gspr: Isn't it more like "takes a type and gives a CONCRETE type"?
04:19:24 <srhb> So it is a type, but not a concrete one (ie. not all type variables have been "filled")
04:19:29 <gspr> srhb: Right, that's how I'm thinking about it, and always have. And I think of, say, [Int] as "a type". In the sense "a concrete type"
04:20:00 <gspr> but now at the next level up, these non-rigorous notions of "concrete" and "non-concrete" types come back to bite me
04:20:15 <merijn> gspr: There's some confusion because people tend to mix terms
04:20:23 <srhb> Abstract is better than non-concrete, I guess
04:20:24 <gspr> (well, they might well be rigorous, but I've always carried them with me in a non-rigorous way)
04:20:37 <gspr> merijn: That I can understand :)
04:20:38 <srhb> I think they are rigorous terms.
04:20:44 <mm_freak_> select = init . liftA2 (zipWith (\xs (y:ys) -> (y, xs ++ ys))) inits tails
04:20:50 <mm_freak_> i'm using this function in every other project
04:21:06 <srhb> Perhaps parameterized is better than abstract, again...
04:21:10 <mm_freak_> and from what i gather quite a few people have been asking for it here and on SO
04:21:16 <merijn> gspr: "type" can mean "a value of kind *" or "any type/kind/sort expression on the right of ::"
04:21:21 <mm_freak_> so maybe i should propose to add it to Data.List
04:21:29 <mm_freak_> :t init . liftA2 (zipWith (\xs (y:ys) -> (y, xs ++ ys))) inits tails
04:21:30 <lambdabot> [t] -> [(t, [t])]
04:21:33 <gspr> merijn: Hmm... right.
04:21:36 <merijn> gspr: So people end up saying things like "Vect has type * -> Nat -> *"
04:21:38 <mm_freak_> > init . liftA2 (zipWith (\xs (y:ys) -> (y, xs ++ ys))) inits tails $ "abcde"
04:21:40 <lambdabot>   [('a',"bcde"),('b',"acde"),('c',"abde"),('d',"abce"),('e',"abcd")]
04:21:52 <merijn> gspr: Usually it's not very confusing, because in context it is usually clear what is meant
04:22:08 <srhb> I always thought type-of-type was just as clear or moreso than kind.
04:22:47 <merijn> gspr: If you want to be pedantic you can say that any value of kind * is a type, which means [a] is a type (since [] is fully applied), but it is not concrete as there are still variables in the expression
04:23:24 <srhb> merijn: Isn't that kind of cheating? Leaving the parameter there is basically the same as saying []
04:23:34 <srhb> (Kind-level currying? ,_,)
04:23:57 <merijn> srhb: Well, you can't unify unapplied types
04:24:04 <gspr> merijn: Right.. hm.. well, not trying to be difficult here. I've never had a problem with this before, but the slight abuse of concepts (in my head) causes problems for me when going "one level higher" in the hierarchy :p
04:24:09 <merijn> Well, you could, but it'd be trivial
04:24:48 <merijn> gspr: Yeah, I had the same experience, you get used to it once you started actually writing code that uses this stuff. As the code is usually much less confusing than the abstract concepts
04:24:53 <gspr> Yeah
04:25:07 <gspr> I think the root of it all is that I've always thought of some category whose objects are "all Haskell types"
04:25:20 <gspr> and I've never really asked myself how does, say, [a] fit into this
04:25:42 <gspr> in the sense that I don't think about it as an object in that category
04:25:43 <neutrino> hi
04:25:52 <gspr> I think of it as a way of producing an object in that category
04:25:57 <neutrino> does anyone know if the #c and #asm channels got locked down somehow?
04:26:02 <gspr> say, a functor with an a vague and foggy domain :p
04:27:09 <merijn> neutrino: You probably want ##c?
04:27:31 <srhb> gspr: I think that's actually a pretty good intuition of it. Maybe even correct. :P
04:27:33 <gspr> To be clear, I think of [a] as a value (not in the Haskell sense) of a functor "F : FoggyVagueness -> Hask". And this bites me when moving a level up
04:27:57 <hape01> the domain of a functor is a monad, that is foggy enough ;-)
04:28:10 <gspr> especially when I try to think of the concept of "some kind n" in the same setting
04:28:33 <srhb> I really only understand kindedness in the sense of "how many types do I need to make a concrete type"
04:28:49 <gspr> Yeah, that seems intuitive
04:29:34 <neutrino> merijn: hmm, probably
04:29:35 <gspr> hape01: Really? I'm not well-versed in category theory... but that doesn't sound right to me...
04:29:36 <neutrino> thanks
04:31:27 <quicksilver> gspr: I don't think it's 100% clear what '[a]' means, out of context.
04:31:41 <quicksilver> I mean, to be boring and pedantic, [a] is a type term with a free variable.
04:32:02 <quicksilver> conventially in haskell if you leave variables free then they're universally quantified
04:32:33 <quicksilver> "forall a . [a]" is certainly a type - but it might not be a type in a simple model of Hask
04:32:45 <quicksilver> since polymorphic types are not first-class types in simple Hask
04:32:49 <srhb> Because a is not a type, but a type parameter?
04:32:57 <srhb> Ah.
04:33:03 <quicksilver> so, for example, "forall a . [a]" is not a member of *
04:33:04 <hape01> gspr: "The instances of Functor for lists, Maybe and IO satisfy these laws. "... Are there functors, which are not based on Monads?
04:33:13 <srhb> Is it * -> * ?
04:33:16 <quicksilver> nope.
04:33:26 <quicksilver> it doesn't have parameters
04:33:29 <quicksilver> that would be []
04:33:32 <quicksilver> but it's polymorphic.
04:33:38 <gspr> quicksilver: Ah, that sentence about polymorphic types not being first-class types in simple Hask *really* cleared up things for me
04:33:46 <srhb> Yeah. I guess [a] is just unclear other than for describing a shape
04:33:51 <quicksilver> it would be permitted to be a member of '*' in an Impredicative system
04:34:03 <quicksilver> or Higher Rank
04:34:12 <quicksilver> but standard haskell is neither Impredicative nor HigherRank
04:34:20 <quicksilver> and the GHC extensions for those are not without their issues.
04:34:34 <gspr> quicksilver: Is there a handwavy way to sketch what a "Hask with polymorphic types included among the objects" is, as a category? (To someone without a background in type theory)
04:34:57 <quicksilver> I think it's fine, gspr, but I don't know what it is.
04:35:06 <gspr> quicksilver: OK :)
04:35:18 <quicksilver> categories can model higher rank types
04:35:23 <quicksilver> (I just don't know the details)
04:35:50 <gspr> right, ok :)
04:35:59 <gspr> you've certainly cleared up some things though
04:36:16 <quicksilver> yes. Higher Rank is in System F.
04:36:27 <quicksilver> (sorry I had to google search to fill in gaps in my knowledge/memory)
04:36:41 <quicksilver> but higher rank gives problems with type inference (so does impredicative)
04:36:44 <srhb> It was very useful.
04:36:49 <quicksilver> which is why they're not commonly standardised.
04:36:55 <gspr> right... ok
04:37:23 <quicksilver> so, [Int] is of kind *, and [] is of kind * -> *
04:37:26 <quicksilver> no problems with those two
04:37:32 <gspr> Yes, those seem fine
04:37:36 <quicksilver> [a] is... a little ambiguous in isolation.
04:37:39 <gspr> and what you said matches my understanding well
04:37:56 <gspr> Right.. well, good to know that it is in fact a bit foggy for others than myself :)
04:37:57 <srhb> \a -> [a] == [] ? :P
04:38:08 <quicksilver> quite so, srhb
04:38:21 <quicksilver> but people conventially use a different symbol for type abstraction
04:38:27 <srhb> that's the only way I can understand it at least.
04:38:30 <quicksilver>  /\ a -> [a]
04:38:33 <srhb> Ah
04:38:34 <srhb> Clever.
04:38:42 <gspr> cute :)
04:38:51 <quicksilver> and obviously that '==' is some kind of metalevel equality.
04:38:56 <srhb> Sure.
04:38:59 <gspr> obviously
04:39:01 <srhb> *handwaves*
04:39:09 <quicksilver> haskell and ML's type systems make type lambdas and type application invisible
04:39:16 <quicksilver> this is a very very clever simplification
04:39:24 <quicksilver> and it makes type inference work in a nice simple way
04:39:34 <gspr> hmm, I see
04:39:34 <quicksilver> that's the "genius" of Hindley-Milner
04:39:48 <quicksilver> unfortunately when you start from the direction of being a user of the languages
04:39:56 <quicksilver> you don't see why it's a clever simplification :)
04:40:06 <gspr> hehe
04:40:10 <srhb> Really? It seems like they're just not allwing you to do an eta abstraction
04:40:10 <quicksilver> but if you start from the direction of "how do we turn System F into a programming language"
04:40:42 <srhb> Well, actually that's not true.
04:40:56 <quicksilver> then it's quite a remarkable observation that if you (1) make type quantification implicit (always universal at the outermost) (2) make all types inferred (3) make all type applications implicit (and guided by type inference)
04:41:07 <quicksilver> ... you end up with a simple, tractable, polymorphic programming language.
04:41:16 <gspr> :D
04:41:18 <quicksilver> without all the problems which plague complete dependently typed systems.
04:41:51 <srhb> I can't decide if this is clever or if it was more like an "oh wow, look at that, it actually works!"-thing :P
04:42:16 <gspr> Right... I don't know any of this stuff, but I *do* often feel that I really really yearn for dependent types :)
04:42:35 <bitonic> well things get messy way before dependent types
04:42:36 <Saizan> it actually makes more sense as a way to internalize meta-variables from STLC typing judgements
04:42:54 <Saizan> rather than sugaring up System F
04:43:35 <quicksilver> I think it makes sense from both of those directions
04:43:37 <Saizan> and i think that's why we don't even have optional type lambdas/application, which would be feasible
04:43:46 <Philippa> quicksilver: preferable simultaneously
04:44:01 <ofan> is book.realworldhaskell.org down?
04:44:14 <deus_rex> ofan: down for me
04:44:19 <ofan> oops
04:45:59 <gspr> Again, with the caveat that the following question is very dumb due to my lack of understanding: Can you, without dependent types, define a function that takes a list of type [a] and produces a length-typed vector Vec a n, where n has kind Nat and is in fact the type level natural corresponding to the length of the list?
04:46:27 <merijn> gspr: You can even do that in haskell
04:46:30 <srhb> I think you can fake it. But only because I think I saw it described somewhere.
04:46:44 <gspr> merijn: oh, really? I just thought you could do it for fixed n?
04:46:50 <Saizan> you need an existential, but yeah
04:46:57 <gspr> oh wow -- HOW? :)
04:46:58 <merijn> Saizan: Not really
04:47:12 <Saizan> merijn: if you want the n to be the length of the list you do
04:47:44 <Saizan> gspr: just the obvious recursion
04:47:49 <merijn> Saizan: How so? You can just enforce it in the constructor, no?
04:48:34 <quicksilver> well the code can't know what n is going to be
04:48:34 <merijn> gspr: GADT that uses DataKinds to encode length of a list: https://github.com/merijn/SNet2.0/blob/master/SNet/Variants.hs
04:48:39 <gspr> Saizan: Oh right, because I *am* allowed to give the function signature :: [a] -> Vec a n? I thought I had to make n a *specific* type-level nat
04:48:43 <Saizan> merijn: toVec :: [a] -> Vec a n would have to work for any 'n', while here we need to compute n out of the list
04:49:03 <quicksilver> you could make a version which works forall n but gives _|_ with the wrong n
04:49:03 <merijn> Saizan: Ah, I should have read more closely
04:49:05 <quicksilver> (I think)
04:49:17 <quicksilver> or a version which returns Maybe (Vec a n) and gives Nothing with the "wrong" n
04:49:18 <Saizan> gspr: you want :: [a] -> exists n. Vec a n
04:49:24 <quicksilver> like Typeable's cast
04:49:24 <merijn> Saizan: Couldn't impredicative types do this?
04:49:39 <quicksilver> but if you want it to 'just be' the right n then it's an existential type
04:49:56 <merijn> Well, ImpredicativeTypes would make it impossible to see *which* n it's returning...
04:49:59 <Saizan> gspr: except exists is not valid haskell and we hae to use a datatype
04:50:16 <Saizan> merijn: i don't see how ImpredicativeTypes would help here
04:50:20 <srhb> How does that even work, I can't see what it would do to any code that uses said vector if it "just is" the right n. I mean, how do I get any guarantees from that.
04:50:22 <merijn> Saizan: It doesn't
04:50:32 <HugoDaniel> how can i know the memory that an instance of my datatype is occupying ?
04:50:38 <HugoDaniel> *how much memory
04:50:58 <quicksilver> heap profiling, HugoDaniel
04:51:08 <srhb> HugoDaniel: gspr: Me too, but I've also been trying to
04:51:09 <srhb> Oops
04:51:14 <srhb> HugoDaniel: http://stackoverflow.com/questions/3254758/memory-footprint-of-haskell-data-types
04:51:15 <gspr> Saizan: I'm being slow now... but I don't get what you mean by "have to use a datatype"...
04:51:21 <quicksilver> srhb: you don't really get any guarantees from it
04:51:25 <quicksilver> srhb: and that's the problem :)
04:51:37 <quicksilver> you don't know at compile time (the compiler doesn't know) which n it's going to be
04:51:44 <srhb> quicksilver: Indeed. Because that's impossible.
04:51:45 <quicksilver> so you can't use most of your nice strongly-typed functions on it.
04:51:47 <Saizan> srhb: unless we also reflect the list into the type system we can't really relate it to the n
04:52:05 <Saizan> srhb: but it's useful when you have a list and you have to call some Vec code
04:52:14 <merijn> gspr: You'd have to do something like "Maybe (Vec a n)" as haskell doesn't let you determine n
04:52:17 <srhb> quicksilver: But is that a guarantee in and of itself? That you can't use those functions?
04:52:22 <merijn> gspr: So you couldn't type it otherwise
04:52:35 <gspr> merijn: Hmm, now I'm confused...
04:53:00 <merijn> gspr: How do you determine the value of n in "[a] -> Vec a n"?
04:53:08 <Saizan> gspr: data ExistsNat f where ENat :: forall (n :: Nat). f n -> ExistsNat f
04:53:08 <quicksilver> srhb: well for example you couldn't use a type-safe tail
04:53:15 <merijn> gspr: The answer (in haskell, without dependent types) is "you don't"
04:53:20 <quicksilver> (if you had a tail function which only worked for n>0)
04:53:21 <srhb> quicksilver: Ah, yes.
04:53:25 <Saizan> gspr: then we can do toVec :: [a] -> ExistsNat (Vec a)
04:53:26 <merijn> gspr: In Agda and friends you can do that easily
04:53:30 <gspr> Ah, right, ok!
04:53:33 <srhb> quicksilver: In fact any function with n set would fail
04:53:40 <srhb> quicksilver: Or with requirements of n, right?
04:53:40 <gspr> I'm getting it, I think. Thanks guys!
04:53:48 <Saizan> merijn: but you can!
04:53:51 <merijn> gspr: Which is basically exactly the difference between dependent types and non-dependent types
04:54:08 <HugoDaniel> srhb: thanks :)
04:54:15 <Saizan> you determine n by recursing on the list
04:54:19 <merijn> gspr: dependent types can let the value of 'n' depend on the value of the input argument
04:54:27 <HugoDaniel> quicksilver: how can i do heap profiling ? im using the ps command right now :/
04:54:29 <Saizan> and you return it as a result of your function.
04:54:49 <merijn> Saizan: You just end up generating it and only returning "exists" of n happens to match the n your code is asking for
04:54:53 <gspr> Mhm! OK, this is beginning to make sense. Now... I guess I have to understand how ExistsNat works
04:54:58 <merijn> Saizan: Which is not really the same :p
04:55:07 <gspr> *thinks*
04:55:42 <merijn> gspr: Are you familiar with cast?
04:55:43 <merijn> :t cast
04:55:45 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
04:55:56 <srhb> HugoDaniel: http://www.scs.stanford.edu/11au-cs240h/notes/perf-slides.html#(20)
04:56:02 <merijn> :t cast 1 :: Maybe Integer
04:56:03 <lambdabot> Maybe Integer
04:56:06 <merijn> eh
04:56:09 <merijn> > cast 1 :: Maybe Integer
04:56:10 <lambdabot>   Just 1
04:56:11 <gspr> merijn: No. I am, in fact, a little bit scared every time I see Typeable. But in fact, I haven't dared look at it seriously
04:56:14 <quicksilver> @google GHC heap profiling
04:56:15 <merijn> > cast 'a' :: Maybe Integer
04:56:16 <lambdabot> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/prof-heap.html
04:56:16 <lambdabot> Title: 5.4.�Profiling memory usage
04:56:16 <lambdabot>   Nothing
04:56:19 <Saizan> merijn: it is really the same, the distinction is elsewhere
04:56:28 <quicksilver> HugoDaniel: what srhb said, but also, the link above
04:56:36 <merijn> gspr: Then forget I mentioned it :)
04:56:39 <srhb> HugoDaniel: Check the following slides.
04:56:48 <gspr> merijn: No, no, one has to face one's fears they say :P
04:57:27 <gspr> merijn, quicksilver, Saizan (and others): Thank you all for really clearing up some things for me. These are holes in my understanding I've waited way too long to attempt to fill.
04:59:41 <merijn> gspr: It's more that it'd be a sidetrack from the main questions
04:59:56 <gspr> ah
04:59:58 <merijn> gspr: I had a convenient example if you happened to be familiar with it already
05:00:05 <gspr> I see
05:00:51 <HugoDaniel> thanks :D
05:04:58 <mm_freak_> in which module do i find the list lenses in the lens package?
05:05:56 <elliott> mm_freak_: Data.List.Lens
05:06:02 <mm_freak_> asked differently:  i need to modify a list element at a certain index, if it exists and leave the list untouched otherwise…  where do i look?
05:06:07 <mm_freak_> thanks
05:06:12 <elliott> mm_freak_: oh, you want at/_at
05:06:24 <elliott> (in the released 3.7 version; else see Control.Lens.At docs for 3.8)
05:06:39 <elliott> oh wait
05:06:45 <elliott> you can't use those with lists in 3.7
05:06:50 <elliott> so my original suggestion was correct
05:06:53 <elliott> :t element 12
05:06:53 <hpaste> ocharles pasted “Type families and constraint kinds” at http://hpaste.org/80252
05:06:54 <lambdabot> (Applicative f, Traversable t, Indexable Int k) => k (a -> f a) (t a -> f (t a))
05:06:56 <ocharles> hola
05:07:00 <elliott> well sort of
05:07:02 <ocharles> is there a way to get the above paste to work without changing runFoo?
05:07:16 <elliott> mm_freak_: anyway you probably just want to use element
05:07:18 <ocharles> I have a type class that introduces a type family, which I use with constraint kinds
05:07:37 <ocharles> but sometimes, the choice of the parameter is irrelevent, because I never actually use the value - it's always discarded
05:07:54 <mm_freak_> :t element
05:07:55 <lambdabot> (Applicative f, Traversable t, Indexable Int k) => Int -> k (a -> f a) (t a -> f (t a))
05:08:04 <mm_freak_> thanks
05:08:26 <ocharles> I was trying to use '()' to do this because I guess I need to actually choose a type at some point, but that's no good...
05:09:39 <ocharles> hmm, I guess by pattern matching on it I am actually trying to use the value at some point
05:12:17 <Saizan> ocharles: maybe you meant type C a :: * -> Constraint ?
05:12:54 <ocharles> mmm, no. the above works fine
05:12:56 <Saizan> ah, no, tricked by the variable names
05:12:57 <ocharles> at least that bit works
05:13:44 <ocharles> the actual use case is I have a applicative functor, where part of it is (Const mo), to produce a 'view' during it's execution. But I don't care about that view sometimes
05:14:39 <ocharles> So I was just going to render to (), which everything can be rendered to, and then just discard it.
05:15:28 <ocharles> If I could somehow indicate that C a b should *only* be constraints of the form 'X a b' then I think I'd be golden
05:24:32 <mm_freak_> how do i construct a "drop n" traversal?
05:24:48 <mm_freak_> > (_tail .~ "ucks") "super"
05:24:49 <lambdabot>   Not in scope: `_tail'
05:24:49 <lambdabot>  Perhaps you meant one of these:
05:24:49 <lambdabot>    `tail' (imported ...
05:25:40 <mm_freak_> > (Data.List.Lens._tail .~ "ucks") "super"
05:25:42 <lambdabot>   Not in scope: `Data.List.Lens._tail'
05:27:39 <shachaf> > upon (drop 6) .~ "blah" $ "hello there" -- I don't actually recommend using upon, but it'd work.
05:27:40 <lambdabot>   "hello blah"
05:28:20 <mm_freak_> what the hell…
05:28:22 <mm_freak_> :t upon
05:28:24 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexable [Int] k) => (s -> a) -> k (a -> f a) (s -> f s)
05:28:39 <shachaf> It does evil things.
05:28:41 <ocharles> upon is serious black magic
05:28:42 <`nand`> > "super" & partsOf (dropping 1 traverse) .~ "ucks"
05:28:44 <lambdabot>   "sucks"
05:28:59 <shachaf> `nand`: That's almost certainly not what you want.
05:29:05 <ocharles> Ok, I rephrased my question as http://stackoverflow.com/questions/14158074/using-constraint-kinds-and-type-families-with-limited-constraints if anyone wants to see a clearer explanation
05:29:08 <ocharles> that makes it lunch time
05:29:25 <shachaf> > "some string" & partsOf (dropping 5 traverse) .~ "longer string"
05:29:26 <lambdabot>   "some longer"
05:29:33 <`nand`> ah, yeah, needs the same number of elements
05:29:50 <mm_freak_> ok, yeah, that one looks very magicky
05:30:13 <mm_freak_> > upon snd .~ "blah" $ (123, 456)
05:30:15 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
05:30:15 <lambdabot>    arising from the literal ...
05:30:25 <shachaf> mm_freak_: It can't change the type.
05:30:32 <mm_freak_> > upon snd .~ "blah" $ (123, "blubb")
05:30:34 <lambdabot>   (123,"blah")
05:30:43 <mm_freak_> amazing…  hacky, but amazing
05:31:50 <shachaf> > upon (foldl1 (\x y -> y)) .~ 'q' $ "hello there" -- substitute your own function!
05:31:52 <lambdabot>   "hello therq"
05:31:57 <mm_freak_> it would be great to have some predefined Char lenses/isos
05:32:04 <mm_freak_> in particular getting rid of chr/ord
05:32:09 <shachaf> Hmm.
05:32:21 <elliott> mm_freak_: which direction should be default and what should the name be?
05:32:24 <shachaf> That would be pretty nice, actually.
05:32:29 <elliott> I guess we could just have two
05:32:31 <elliott> _chr and _ord or whatever
05:32:35 <elliott> then you could do, like, _ord %~ rot13
05:32:37 <elliott> that'd be pretty cool
05:32:48 <mm_freak_> elliott: i'd also like to have _letter, _digit, etc.
05:33:11 <shachaf> Some of these are a bit problematic since they can fail in both directions, or something.
05:33:13 <mm_freak_> rot13 = _letter +~ 13
05:33:29 <mm_freak_> if not letter, do not set
05:33:41 <ion> æ
05:33:42 <mm_freak_> and do The Right Thing for upper-/lowercase
05:33:42 <shachaf> _letter._mod 26 +~ 13 -- :-)
05:34:05 <mm_freak_> _letter would have to do the modulo itself to be well defined
05:34:10 <ion> ಠ is also a letter
05:34:11 <shachaf> I'm not sure you can "do the right thing" for upper/lowercase.
05:34:39 <mm_freak_> (_asciiLetter +~ 1) 'a' = 'b'
05:34:42 <mm_freak_> (_asciiLetter +~ 1) 'A' = 'B'
05:35:46 <Jafet> ion: ✉
05:35:58 <ion> I see what you did there.
05:36:18 <shachaf> mm_freak_: (By the way, there's also #haskell-lens for these sorts of things.)
05:36:54 <edwardk> shachaf: _mod 26 ?
05:37:29 <edwardk> shachaf: you could do the right thing as a lens, since you have access to if the original was upper case or not
05:37:29 <shachaf> edwardk: OK, it doesn't actually make sense. :-)
05:37:31 * hackagebot hsemail 1.7.4 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.7.4 (PeterSimons)
05:39:20 <mm_freak_> :t isDigit
05:39:22 <lambdabot> Char -> Bool
05:39:48 <dmwit> > isDigit "b"
05:39:49 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:39:49 <lambdabot>              with actual type...
05:39:53 <dmwit> *smack*
05:39:56 <dmwit> > isDigit 'b'
05:39:57 <lambdabot>   False
05:40:14 <`nand`> > isDigit '²'
05:40:14 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
05:40:18 <`nand`> bah
05:40:21 <dmwit> > isHexDigit 'b'
05:40:22 <lambdabot>   True
05:40:52 <mm_freak_> > let asciiDigit = sets (\f c -> if isDigit c then chr (mod (f (ord c - ord '0')) 10 + ord '0')) in (asciiDigit +~ 5) '3'
05:40:54 <lambdabot>   <hint>:1:94: parse error on input `)'
05:41:59 <mm_freak_> > let asciiDigit = sets $ \f c -> if isDigit c then chr (mod (f $ ord c - ord '0') 10 + ord '0') else c in (asciiDigit +~ 5) '3'
05:42:00 <lambdabot>   '8'
05:42:06 <mm_freak_> > let asciiDigit = sets $ \f c -> if isDigit c then chr (mod (f $ ord c - ord '0') 10 + ord '0') else c in (asciiDigit +~ 5) '8'
05:42:07 <lambdabot>   '3'
05:42:59 <mm_freak_> can even be a SimpleLens Char (Maybe Int)
05:43:44 <edwardk> mm_freak_: you probably want a prism
05:44:02 <mm_freak_> edwardk: i'm still new to lens…  this is my first serious use actually
05:44:18 <edwardk> base :: (Integral a, Show a) => a -> Prism' String a -- is in HEAD Numeric.Lens
05:44:27 <edwardk> -- >>> "100" ^? base 16
05:44:28 <edwardk> -- Just 256
05:44:32 <edwardk> -- >>> 1767707668033969 ^. remit (base 36)
05:44:32 <edwardk> -- "helloworld"
05:45:04 <merijn> Two months from now I won't even need to write code anymore...
05:45:14 <merijn> Just search lens for the right lens/traversal...
05:45:58 <mm_freak_> lol
05:46:01 <`nand`> no Read in there?
05:46:18 <edwardk> merijn: don't worry. i've ben generalizing everything. you'll have beautiful type signatures to contend with ;)
05:46:55 <Taneb> takingWhile is my favourite
05:46:57 <edwardk> \l p -> taking 1 (l .filtered p)
05:46:58 <edwardk>   :: (Monad (Rep q), Applicative f, Applicative (Rep q), Corepresentable p, Comonad (Corep p), Category p, Representable q) =>
05:46:58 <mm_freak_> documentation for APrism
05:46:59 <edwardk>      (p a (BazaarT p q f a a a) -> q s (BazaarT p q f a a t)) -> (a -> Bool) -> Overloading p q f s t a a
05:47:03 <mm_freak_> If you see this in a signature for a function, the function is expecting a Prism, not some kind of alien invader.
05:47:06 <mm_freak_> lol
05:47:09 <Guest78629> Hi, I'm a little confused about IO monads. I have a text file I wish to read into a Data.Sequence structure and then perform operations on said structure. While I am able to read the text file into a string and format it as a Sequence, it becomes type IO(Seq.Seq Char) and won't let me perform operations on it.
05:47:20 <edwardk> mm_freak_: we no longer have Overloaded Prismoid Mutators ;)
05:47:45 <`nand`> ‘f a a t’ <- accurate description of type signature
05:48:03 <mm_freak_> Guest78629: do mySeq <- theIOActionYouWroteSoFar
05:48:24 <mm_freak_> then for the following code mySeq is your Seq Char
05:49:03 <Taneb> takingWhile
05:49:06 <Taneb>   :: (Corepresentable p, Profunctor q, Comonad (Corep p), Applicative f, Gettable f)
05:49:09 <Taneb>   => (a -> Bool) -> Overloading p q (Accessor (Endo (f s))) s s a a -> Overloading p q f s s a a
05:49:28 <edwardk> that could dumb down to (SelfAdjoint p, SelfAdjoint q, Applicative f) => Overloading p q (BazaarT p q f) s t a a -> Overloading p q f s t a a
05:49:49 <edwardk> Taneb: yes, but this way it works on indexed traversals and what not
05:49:49 <mm_freak_> i kindly ask you to move those scary type signatures to #haskell-lens =P
05:50:03 <edwardk> because previously
05:50:07 <edwardk> :t takingWhile
05:50:09 <lambdabot> (Applicative f, Gettable f) => (a -> Bool) -> Getting (Endo (f s)) s s a a -> LensLike f s s a a
05:50:21 <edwardk> that only worked on folds and getters
05:50:44 <edwardk> now it works on folds, getters, lenses, traversals, indexed traversals, index-preserving traversals, etc.
05:50:51 <Taneb> Yay!
05:50:52 <edwardk> and they retain those additional properties
05:50:53 <shachaf> Even though it doesn't make legal traversals.
05:51:01 <edwardk> you can write back through it (illegally)
05:51:10 <edwardk> but it documents this fact, etc.
05:51:19 <edwardk> actually
05:51:24 <edwardk> you can't write back through it presently
05:51:33 <edwardk> we've got another generalization wave to do ;)
05:51:46 <edwardk> that one is on my todo list
05:51:52 <edwardk> because its crippled relative to droppingWhile
05:52:15 <monstter> Hello guys, could please someone take a look at http://hpaste.org/80253 ? GHC (7.6.1 in case it matters) complains about "The type variable `backend0' is ambiguous", and I have no idea what it wants here...
05:53:05 <Taneb> monstter, throw type signatures at it
05:53:22 <Taneb> But I don't know which to throw or where :(
05:53:54 <monstter> Taneb: if I knew what type signature it wants here, I wouldn't be asking ;)
05:54:02 <Guest78629> mm_freak_: I get still get type mismatches if I do that.
05:55:02 <monstter> Pasting types GHC mentions in its type mismatch errors only produces other, sometimes evem more magical errors.
05:57:02 <shachaf> Bizarre type errors in code you didn't even write seems to be a common symptom of writing in Yesodskell. :-)
05:57:57 <monstter> shachaf: I'm not event touching Yesod itself...
05:59:30 <Saizan> this is code he did write
05:59:47 <Saizan> monstter: what's the type of checkUnique?
05:59:56 <sclv> monstter: the real error seems to be that UniqueUserName is of type PersistEntityBackend...
06:00:12 <sclv> while checkUnique looks like it wants something of PersistMonadBackend...
06:00:19 <monstter> sclv: maybe, but it is what TH generates...
06:00:46 <srhb> Are they supposed to be flipped in the quasiquoter (or whatever we call that black magic thingy)
06:01:01 <srhb> name String, password String, UniqueUserName name -- seems weird
06:01:26 <monstter> Saizan: from hackage: checkUnique :: (PersistEntityBackend val ~ PersistMonadBackend m, PersistEntity val, PersistUnique m) => val -> m Bool
06:02:07 <sclv> hrm, I think srhb is onto something?
06:02:08 <monstter> srhb: I'm not sure I understand what y ou mean
06:02:17 <srhb> monstter: name Type, name Type, Type name
06:02:22 <srhb> monstter: Isn't the last one flipped?
06:02:36 <srhb> monstter: In the mkPersist thingy
06:02:44 <monstter> srhb: nah, its the way it works.
06:03:02 * srhb throws her hands in the air
06:03:03 <monstter> srhb: the first two are field definitions, the last one is constraint
06:03:09 <srhb> Disgusting.
06:04:40 <Saizan> PersistEntityBackend (Unique (UserGeneric backend0)) <- i'd like to know if picking a concrete type for backend0 would make the type family compute
06:05:14 <dreixel> gspr: do you still need more info regarding that presentation?
06:05:35 <Saizan> in that case you should probably add a type signature to UniqueUserName "a"
06:05:53 <monstter> Saizan: Well, here lies the problem - I don't know how to do that. I tried several type signatures, and it doesn't seem to help.
06:05:58 <sclv> yep, Saizan is on the right track
06:06:04 <sclv> give it its own name at the top level
06:06:11 <sclv> and then give it a type signature there
06:06:25 <sclv> and once you've given it the right one, then try to plug it in where it should go
06:06:38 <Saizan> monstter: it'd look like "b1 <- checkUnique $ (UniqueUserName "a" :: Unique (UserGeneric Foo))"
06:06:55 <sclv> or do that :-)
06:07:28 <quicksilver> yes, the problem seems to be that the 'checkUnique' doesn't infer that it must run in the same backend (the postgres backend) as the rest of the code
06:07:32 <quicksilver> I'm not sure why not though
06:07:46 <Saizan> quicksilver: type families in the way
06:07:55 <Saizan> checkUnique :: (PersistEntityBackend val ~ PersistMonadBackend m, PersistEntity val, PersistUnique m) => val  -> m Bool
06:08:21 <Saizan> there's no way for information to flow from m to val
06:08:31 <quicksilver> http://www.yesodweb.com/book/persistent doesn't have any examples of using checkUnique
06:08:50 <monstter> quicksilver: maybe that's why...
06:09:35 <monstter> Saizan: you mean like (UniqueUserName "a" :: Unique (UserGeneric SqlBackend)) ?
06:10:40 <Saizan> monstter: yeah, if PersistEntityBackend (Unique (UserGeneric SqlBackend)) ~ SqlBackend
06:11:11 <quicksilver> if nothing else it should give a better error message, monstter
06:11:34 <monstter> Saizan: And does it? I'm not sure I get the '~' thing...
06:12:05 <quicksilver> you could read ~ as 'reduces to' or 'means' or 'is the same type as'
06:12:06 <Saizan> monstter: we have to find the instances of PersistEntityBackend to tell
06:12:21 <Saizan> monstter: or you can try and see
06:12:38 <quicksilver> Saizan: I fear the instances are in the TH-generated code so hard to 'find' them.
06:12:51 <quicksilver> (hmm actually can TH generate TF instancse now?)
06:13:08 <monstter> It doesn't compile with the one I pasted, so its probably not the right one.
06:13:40 <Saizan> quicksilver, monstter: :info PersistEntityBackend in ghci, commenting out initDb, maybe?
06:15:02 <Saizan> monstter: :t UniqueUserName would also help, to be safe
06:15:35 <monstter> UniqueUserName :: String -> Unique (UserGeneric backend)
06:15:50 <monstter> type family PersistEntityBackend val1 :: * -- Defined in `Database.Persist.Store'
06:17:20 <quicksilver> ok, so UniqueUserName really is parametric in backend, it seems. It's backend agnostic.
06:17:29 <quicksilver> that's good, no hard constraints to get in line - just need to annotate it.
06:17:33 <Eduard_Munteanu> Any tips on minimizing context switching latency?
06:18:06 <quicksilver> Eduard_Munteanu: always concentrate on a single task for a determined amount of time (15/30 minutes); turn off email alerts and IRC alerts.
06:18:14 <monstter> class PersistEntity val where (...) PersistEntityBackend (..)
06:18:20 <Eduard_Munteanu> Heh.
06:18:50 <Saizan> monstter: maybe we should just grep the sources :)
06:19:07 <Eduard_Munteanu> What I'm doing is controlling mplayer from Haskell and syncing playback to a clock. Once in a while I start getting 50 ms then 20ms delays, I'd like to even them out.
06:19:53 <Eduard_Munteanu> Can I do better than that?
06:20:13 <Eduard_Munteanu> I'm currently using MVars and forkIO to send messages across.
06:20:53 <monstter> Saizan: it's here http://hackage.haskell.org/packages/archive/persistent/latest/doc/html/src/Database-Persist-Store.html#PersistEntityBackend but seeing the source doesn't really help me
06:21:41 <quicksilver> Eduard_Munteanu: you should be able to. are you using -threaded?
06:21:56 <quicksilver> you can increase the resolution of the default pre-emption time
06:21:57 <Eduard_Munteanu> quicksilver: yes, and passing -N4
06:22:02 <Saizan> monstter: that's the declaration, what we need is the instances
06:22:05 <Eduard_Munteanu> I passed -C as well.
06:22:51 <monstter> Saizan: I guess it's more complicated than grep instance PersistEntityBackend?
06:23:51 <Eduard_Munteanu> The thing is, I sometimes get even as good as 10ms difference between the clock and mplayer's file position.
06:24:21 <Eduard_Munteanu> But the worst cases result in lots of seeking around.
06:25:51 <Saizan> monstter: grep PersistEntityBackend
06:26:18 <monstter> Oh, so it's even simpler. In progress...
06:30:25 <Saizan> i guess grep 'type PersistEntityBackend' would be more precise, if the other is getting to many results
06:31:46 <Eduard_Munteanu> Hm, maybe I should do some lag prediction.
06:34:38 <monstter> Saizan: the one with type finds only "class PersistEntity val where type PersistEntityBackend val"
06:35:32 <Saizan> monstter: the other?
06:36:11 <monstter> Many occurences in type signatures, like class (PersistStore m, PersistEntity a, PersistEntityBackend a ~ PersistMonadBackend m) => DeleteCascade a m where
06:37:12 <Saizan> monstter: are you doing this for all the packages?
06:37:28 <monstter> For persistent and persistent-postgresql.
06:37:39 <monstter> Ah, I missed persistent-template.
06:38:19 <monstter> Whoah.
06:38:26 <Saizan> the last resort will be -ddump-splices to see if the TH code is the one producing the instances
06:38:55 <monstter> http://hpaste.org/80257
06:39:57 <monstter> This doesn;t look readable to me.
06:40:26 <Saizan> seems like it is supposed to
06:41:15 <Saizan> monstter: pass -ddump-splices to ghc(i) when loading your code, it should print out what the TH macro expands to
06:43:06 <monstter> Saizan: like this? http://hpaste.org/80258
06:43:41 <quicksilver> type instance PersistEntityBackend (UserGeneric backend) = backend
06:43:53 <quicksilver> is the key line I think
06:44:42 <quicksilver> anyhow you have a better error message now, or did you already paste that? /me reads up
06:46:15 <Saizan> quicksilver: we lack an instance for Unique though, since UniqueUserName :: String -> Unique (UserGeneric backend)
06:46:27 <quicksilver> but Unique is just a data family
06:46:43 <quicksilver> Unique (UserGeneric backend) reduces to UniqueUserName String
06:46:56 <quicksilver> and I think there is no instance for that
06:47:09 <quicksilver> so maybe this is quite simply an incorrect way to use checkUnique?
06:47:18 <monstter> So is it a bug in the TH code, after all?
06:47:48 <Saizan> quicksilver: data families don't reduce
06:47:57 <quicksilver> Saizan: sorry, you're right, that was all wrong.
06:48:12 <quicksilver> except for the part where I said "Unique is just a data family"
06:48:21 <quicksilver> Unique is just a data family and, as far as I can see, there are no instances for it.
06:48:58 <ocharles> edwardk: do you have any examples of actually using your `constraints` library?
06:49:15 <ocharles> I think I need the notion of entailment from it, but I haven't managed to get my teeth stuck in to it yet
06:49:22 <Saizan> still seems like you're not supposed to call checkUnique like that
06:49:26 <monstter> quicksilver: data instance Unique (UserGeneric backend) = UniqueUserName String
06:49:32 <quicksilver> yes indeed
06:49:33 <edwardk> its just the toys from the blog post that are publicly available
06:49:49 <quicksilver> monstter: what made you think it was right to call 'checkUnique' like that?
06:50:08 <ocharles> edwardk: ah, k
06:50:30 <monstter> quicksilver: docs on hackage.
06:50:47 <quicksilver> monstter: can you show me which bits?
06:50:50 <monstter> "Check whether there are any conflicts for unique keys with this entity and existing entities in the database. "
06:51:12 <monstter> Desciption of checkUnique.
06:51:22 <srhb> Presumable, User i the entity, not UniqueUserName?
06:51:24 <srhb> is*
06:52:12 <srhb> monstter: checkUnique (User "a" "b") should do what you want
06:52:13 <quicksilver> I think what srhb says
06:52:23 <monstter> checking...
06:52:44 <quicksilver> golly, what  good test case in how type families + TH can lead to poor error messages :-(
06:52:52 <srhb> Indeed.
06:52:58 <srhb> This ought to have been obvious.
06:53:24 <monstter> Gaaaaaaah, it works.
06:53:37 <quicksilver> so "UniqueUserName" is a special tool you use for calling 'getBy'
06:53:37 <monstter> Thank you guys.
06:53:42 <quicksilver> (and maybe some other things)
06:53:48 <Saizan> with better support in ghci to see type family instances it would have been better
06:54:05 <quicksilver> Saizan: btu really this should have been a simple type error
06:54:20 <quicksilver> "UniqueConstraint passed when FieldName expected"
06:54:20 <monstter> The one I got was completely impenetrable for me...
06:54:50 <monstter> Is it fixable in the TH code, or is it a GHC shortcoming?
06:54:50 <quicksilver> but all the higher order type structures means that there are no simple types like 'UniqueConstrain' and 'FieldName'
06:55:03 <edwardk> woot.
06:55:06 <edwardk> >>> ["hello","world"]^..levels (traverse.traverse).traverse.traverse
06:55:07 <edwardk> "hewlolrold"
06:55:13 <edwardk> provides a much more obvious ordering
06:55:18 <srhb> edwardk: What. What!
06:55:26 <edwardk> >>> ["hello","world"]^..levels (traverse.traverse).taking 4 traverse.traverse
06:55:26 <edwardk> "hew"
06:55:34 <edwardk> provides a depth-limited breadth-first search for instance
06:55:40 <srhb> o_o
06:55:44 <flebron> i.e. magic
06:55:50 <edwardk> levels gives you a list of levels as a breadth first search
06:55:51 <ocharles> could we have [[1234],[4567]]^..levels etc ?
06:55:56 <ocharles> (the output of)
06:56:01 <ocharles> erm
06:56:04 <ocharles> without the duplicate 4 :)
06:56:14 <ocharles> classic off by one!
06:56:14 <quicksilver> monstter: I think it's probably a shortcomgin in GHC that the error message is so poor / so hard to diagnose, but it's a shortcoming or trade-off of the way Persist is implemented that they've encoded things as type classes and type families not simple types
06:56:16 <edwardk> >>> [[1,2],[3,4]]^..levels (traverse.traverse)
06:56:17 <edwardk> [[Pure,Ap 0 True True (Last {getLast = Nothing}) Pure Pure,Ap 1 False False (Last {getLast = Just ()}) (Ap 1 False False (Last {getLast = Just ()}) (Leaf () 1) Pure) (Ap 0 True True (Last {getLast = Nothing}) Pure Pure),Ap 2 False False (Last {getLast = Just ()}) (Ap 1 False False (Last {getLast = Just ()}) Pure (Ap 1 False False (Last {getLast = Just ()}) (Leaf () 2) Pure)) (Ap 1 False False (Last {getLast = Just ()}) (Ap 1
06:56:18 <edwardk>  False False (Last {getLast = Just ()}) (Leaf () 3) Pure) Pure),Ap 1 False False (Last {getLast = Just ()}) (Ap 0 True True (Last {getLast = Nothing}) Pure (Ap 0 True True (Last {getLast = Nothing}) Pure Pure)) (Ap 1 False False (Last {getLast = Just ()}) (Ap 1 False False (Last {getLast = Just ()}) Pure (Ap 1 False False (Last {getLast = Just ()}) (Leaf () 4) Pure)) Pure)]]
06:56:26 <ocharles> what the flipping flip
06:56:29 <srhb> o_O
06:56:33 <quicksilver> edwardk: win?
06:56:36 <edwardk> i don't recommend looking at the magmas you get too closely ;)
06:56:53 <srhb> magmas... That's a thing now?
06:57:00 <edwardk> >>> [[1,2],[3,4]]^..levels (traverse.traverse).to (fmap toList)
06:57:00 <edwardk> [[[],[],[1],[2,3],[4]]]
06:57:04 <ocharles> magmas are just binary operations on an algebra, I thought?
06:57:08 <srhb> "lens is a library that produces magmas, that in turn should not be inspected closely"
06:57:13 <srhb> ocharles: Oh well. :P
06:57:16 <monstter> quicksilver: okay, I get it. Thanks.
06:57:23 <edwardk> ocharles: thats perhaps more accessible
06:57:25 <Rembane> Sounds like Dwarf Fortress...
06:57:48 <edwardk> i may switch to a simpler magma type for this since it doesn't need all the magma support we have for zippers
06:57:59 <edwardk> ocharles: they are
06:58:07 <edwardk> here they are annotated with all sorts of things i'm not currently using
06:58:19 <ocharles> edwardk: is Ap the magma atm? What is type is Ap?
06:58:49 <edwardk> ocharles: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Magma.hs
06:59:01 <ocharles> ta
06:59:02 <shachaf> ocharles: Magma is less scary than it looks.
06:59:02 <edwardk> magma :: AnIndexedTraversal i s t a b -> Lens s t (Magma i a) (Magma j b)
06:59:13 <edwardk> it picked up a lot of annotations for its usecases in zipper
06:59:27 <shachaf> It's just data Magma a = Pure | Leaf a | Ap (Magma a) (Magma a) with some indexing and booleans and things.
06:59:28 <edwardk> but the version i'll use for this breadth first walk will be simpler in the end
06:59:49 * shachaf approves of a simpler magma type.
06:59:54 <shachaf> Especially if it's exposed to users.
06:59:57 <edwardk> yeah
07:00:06 <ocharles> I wonder if Magma will help with my damn 3-way tree merge stuff
07:00:12 <edwardk> it'll probably be 'Level' or something without the annotations
07:01:43 <edwardk> @hpaste
07:01:43 <lambdabot> Haskell pastebin: http://hpaste.org/
07:01:56 <hpaste> edwardk pasted “bfs traversal” at http://hpaste.org/80260
07:02:20 <edwardk> the fact that i wound up with a list of magmas was an implementation detail that turned out to be quite nice from a depth limited search perspective
07:03:11 <Jafet> I'm writing C++ now, and I want traversals
07:03:17 <Jafet> A curse upon edwardk
07:03:38 <edwardk> >>> ["hello","world"]^..levels biplate.traverse.traverse :: String
07:03:38 <edwardk> "hewlolrold"
07:03:38 <quicksilver> all of edwardks code ideas can be mechnically converted to C++ template hackery, of course.
07:03:40 * shachaf isn't *quite* happy with the idea of exposing the illegal monoid to users.
07:03:42 <Jafet> Actually, it might be possible to do a limited form of this in C++
07:03:56 <edwardk> shachaf: the alternatives are all asymptotically slower =(
07:03:56 <quicksilver> and when I say 'mechanically' you really don't want to imagine the machine which does that.
07:03:57 <Jafet> ...without writing 1000-line templates
07:04:20 <shachaf> edwardk: Depending on what operations you want to allow on the tree, I guess.
07:04:37 <shachaf> You could probably allow some specific ones without leaking too much. But it's not that great.
07:04:38 <edwardk> well, i'm thinking of exporting Level but perhaps not its constructors, etc.
07:04:43 <quicksilver> imposing the restriction that the resulting mess be compilable by any particular C++ compiler in a reasonable time might be a problem.
07:04:46 <shachaf> Actually I guess almost anything that you do level-wise violates the laws.
07:04:59 <shachaf> Since a biased tree is supposed to be the same as a balanced tree.
07:05:00 <edwardk> but yeah depth limiting anything is inherently 'evil'
07:05:10 <edwardk> useful evil
07:05:11 <edwardk> but evil
07:05:38 <edwardk> if i were in one of my more law-abiding phases i'd be mad at myself ;)
07:06:13 <Jafet> quicksilver: your C++ template algorithms just aren't sufficiently performant
07:08:34 <johannesbodannes> Why would
07:08:34 <edwardk> >>> ["hello","world"] & levels biplate.taking 7 traverse.traverse %~ toUpper
07:08:35 <edwardk> ["HELlo","WOrld"]
07:08:36 <johannesbodannes> http://hackage.haskell.org/packages/archive/time/1.1.4/doc/html/Data-Time-Clock-POSIX.html
07:08:37 <johannesbodannes> this say
07:08:45 <johannesbodannes> that most people won't need this package?
07:08:58 <johannesbodannes> Is there a better alternative?
07:09:17 <edwardk> that goes 7 levels deep in the tree while
07:09:19 <edwardk> >>> ["hello","world"] & taking 7 (levels biplate.traverse.traverse) %~ toUpper
07:09:19 <edwardk> ["HELLo","WORld"]
07:09:24 <edwardk> goes 7 elements deep in breadth first order
07:09:39 <johannesbodannes> Like, I was wanting to develop a sort of expiring datatype for a cache that I'm writing
07:09:58 <johannesbodannes> and I'm generally used to using POSIX timestamps for my timing needs
07:10:20 <edwardk> i may change it down to a traversal of magmas rather than a lens to a list of them
07:10:25 <edwardk> slightly safer
07:10:31 <edwardk> then one 'traverse' drops out of that definition
07:10:35 <quicksilver> johannesbodannes: because you might as well just use UTCTime
07:10:51 <quicksilver> johannesbodannes: no particular reason to use POSIXTime
07:10:58 <johannesbodannes> Would UTCTime adjust for daylight's savings and the like?
07:11:27 <quicksilver> UTCTime and POSIXTime both measure UTC
07:11:32 <quicksilver> there is no daylight savings in UTC.
07:11:39 <johannesbodannes> Oh excellent
07:11:41 <quicksilver> you can calculate corresponding local time of course
07:11:57 <johannesbodannes> OH so I misunderstand what UTCTime is
07:13:05 <edwardk> that works out nicer
07:13:08 <edwardk> now its
07:13:08 <edwardk> >>> ["hello","world"] & taking 7 (levels biplate.traverse) %~ toUpper
07:13:10 <edwardk> ["HELLo","WORld"]
07:13:14 <edwardk> and >>> ["hello","world"] & levels biplate.taking 7 traverse %~ toUpper
07:13:15 <edwardk> ["HELLO","WORLD"]
07:13:22 <Peaker> quicksilver, is it me or where you absent for ages? :)
07:13:26 <Peaker> s/where/were
07:15:21 <quicksilver> Peaker: I'm never absent. I'm sometimes quiet.
07:15:34 <quicksilver> especially when it's busy at work, or I have another child, or I move house.
07:16:25 <Peaker> quicksilver, real life is a poor substitute for IRC :)
07:16:29 <quicksilver> edwardk: do you use >>> as a prompt because secretly you'd rather be using python?
07:16:58 <Peaker> Python's interactive shell is nicer than ghci :P
07:17:02 <edwardk> quicksilver: so i can paste it into a doctest easier ;)
07:17:03 <merijn> quicksilver: Or he just really likes categories?
07:17:08 <merijn> :t (>>>)
07:17:09 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
07:17:37 <srhb> Peaker: How so?
07:18:02 <Peaker> srhb, no need for funny :{ and :} business when you have multi-lines.  No need for "let" for assignments
07:18:11 <srhb> Peaker: True.
07:18:22 <Jafet> :set +m
07:18:23 <Peaker> and I much prefer the plain floating point representation over the "e" notation
07:18:48 <Peaker> Jafet, oh, cool! That helps :)
07:18:52 <Peaker> why is it not the default?
07:19:13 <Peaker> oh awesome, this will really help
07:19:25 <Jafet> python's shell is so bad, that people made another one
07:19:38 <Jafet> EOF
07:19:58 <Peaker> but even with +m, Python's shell lets you reload(module) without losing your bindings
07:20:08 <Peaker> and it doesn't use the annoying "e" floating notation, and it doesn't need "let"
07:20:21 <hiptobecubic> Peaker, sometimes.
07:20:29 <Peaker> hiptobecubic, ?
07:20:36 <hiptobecubic> Peaker, sometimes it just fails completely and nothing works until you kill it and start a new one.
07:20:50 <hiptobecubic> reloading is basically "unsupported"
07:21:00 <hiptobecubic> it works for very simple modules
07:21:05 <Peaker> hiptobecubic, It's pretty predictable, and it's nicer than having a restart-modulu-imports you get from ghci whenever anything is reloaded
07:21:32 <Peaker> hiptobecubic, in practice, when I write Python and toy with it in the interactive shell, I do manage to reload() because usually I'm testing simple stuff I'm writing
07:21:35 <hiptobecubic> losing bindings is pretty annoying
07:21:50 <Peaker> it is true that it is hard to get reload() to work for large changes in a realistic set up
07:22:10 <Peaker> but at least for the simple cases you get reload() which in ghci you don't get at all :(
07:22:15 <hiptobecubic> Peaker, that's fine for toy modules, yes, but for example if your module loads some other module, that doesn't get redone
07:22:29 <Peaker> hiptobecubic, but usually I'm just changing one module, so I can reload only that one
07:22:35 <Peaker> hiptobecubic, and sometimes another module that imported it
07:23:22 <hiptobecubic> you have to manually reload everything that changes. reloading a module doesn't reload dependencies. Binary extensions aren't reloaded at all, ever.
07:23:47 <Peaker> also, in ghci, I can't do this:  import Data.Map, Foo.Bar ; m <- foo ; let x = bar           so I can use that one-liner to reload and re-bind, like I can in the Python shell
07:24:11 <Peaker> hiptobecubic, for the very common case of editing a single Python module, reload() is useful
07:24:18 <Peaker> it is true it doesn't handle all edge cases well
07:30:04 <Peaker> this is my event loop: http://hpaste.org/80261
07:30:10 <Peaker> this is my profile result: http://hpaste.org/80262
07:30:32 <Peaker> how does rawEventLoop  take 38% of the time, when all it has is a forever loop that calls 3 different cost centres?
07:31:01 <Peaker> (prof options are -Wall -auto-all -caf-all -rtsopts)
07:32:41 <Jafet> Admittedly, the tab completion, debugger, option selector and time/memory profiling can hardly make up for ghci's many deficiencies.
07:33:10 <tippyk> what paper were lens introduced in? the haskell wiki page is only about how to use them, and from googling i find slide decks but not attribution
07:33:19 <mm_freak_> btw, i really wonder why there is a 'tails', but not a 'drops'
07:33:42 <quicksilver> tippyk: I think the name was coined by the bananas, lenses, barbed wire paper
07:33:44 <edwardk> tippyk: they aren't really all that academically rooted. there are some tangentially related papers by benjamin pierce
07:33:46 <edwardk> quicksilver: no
07:33:52 <edwardk> that paper is irrelevant
07:34:02 <quicksilver> oh, my apologies
07:34:11 <edwardk> and merely has an unfortunately identically named syntactic construction
07:34:17 <Taneb> mm_freak_, inits
07:34:24 <edwardk> quicksilver: np, its just something repeated enough that i felt the need to add it to the faq ;)
07:34:35 <edwardk> and so i try to squash it when i hear it again ;)
07:34:38 <Jafet> > takeWhile (not.null) $ iterate (drop 3) "mm_freak_"
07:34:39 <lambdabot>   ["mm_freak_","freak_","ak_"]
07:34:48 <quicksilver> right, the bananas paper is about foo-morphisms
07:34:53 <mm_freak_> Jafet: i know how to define it
07:34:54 <quicksilver> and they just use a lens bracket
07:35:16 <edwardk> [(  )]   looked like a lens to them
07:35:18 <Jafet> Ok, so define it
07:35:36 <quicksilver> it looks liek one to me too, edwardk
07:35:48 <shachaf> 【 and 】 look like lenses to me.
07:35:51 <mm_freak_> > let drops n = takeWhile (not . null) . iterate (drop n) in drops 3 ['a'..'z']
07:35:53 <lambdabot>   ["abcdefghijklmnopqrstuvwxyz","defghijklmnopqrstuvwxyz","ghijklmnopqrstuvwx...
07:35:56 <quicksilver> I learn about lenses from http://twanvl.nl/blog/haskell/overloading-functional-references which doesn't use the word lens.
07:35:59 <edwardk> well, eventually maybe we can steal the syntax for them for lenses and come full circle ;)
07:36:01 <shachaf> Unfortunatly Unicode lacks a PRISMATIC BRACKET
07:36:09 <quicksilver> twanvl used to be a regular here
07:36:11 <edwardk> quicksilver: back then they were still 'functional references'
07:36:20 <Jafet> Lentil brackets
07:36:22 <edwardk> benjamin pierce coined the term lenses for a more general construct
07:36:40 <edwardk> and we've since repurposed it to match his 'very well behaved lenses'
07:37:45 <quicksilver> Relational Lenses: A language for defining updateable views
07:38:06 <quicksilver> makes sense. DB conferences love updateable views
07:38:25 <Philippa> mmm. It's a good thing I don't feel like I have the time to play with bidi parsing/pretty-printing + AST updates, really
07:38:42 <Philippa> let alone the traceable desugaring things I wanted to play with
07:39:16 * quicksilver thinks it is necessarily a *bad* thing when smart people don't have the time to play with interesting ideas.
07:39:37 <quicksilver> Pierce wrote Unison?
07:40:26 <djcoin> quicksilver: yep
07:40:38 <Philippa> sure. Being mistaken about whether you do is a bad thing, though
07:40:49 <quicksilver> I've never noticed that even though I have visited the unison page many times over the years
07:40:52 <Philippa> (so I'm implicitly asserting that I don't, yeah)
07:40:58 <quicksilver> clearly I'm unobservant
08:02:50 <subbyyy> VinSpee could you post your view, it should work
08:03:06 <subbyyy> wrong channel :x
08:05:58 <Peaker> so, if I have: mainLoop = forever $ a >> b >> c          how come the profiler gives me 40% time in mainLoop, but almost no time in a, b, or c?
08:06:13 <Peaker> if a,b,c are inlined, is the cost center information lost?
08:07:54 <merijn> Peaker: Are you sure a, b and c are doing something?
08:08:15 <Peaker> merijn, well, given the main loop actually does interesting stuff, sure :)
08:08:43 <Peaker> I'd expect nearly 0 time in mainLoop, and all the time in some combination of a,b,c
08:10:40 <srhb> Peaker: If you inline them, you lose the automatic cost center annotation
08:10:51 <srhb> Peaker: (But you can add your own)
08:12:11 <Peaker> srhb, I actually do have a manual SCC annotation on a,b,c, and still all the time is in mainLoop
08:13:18 <srhb> Peaker: Odd.
08:14:49 <Peaker> srhb, https://github.com/Peaker/lamdu/blob/eyal/profiling/bottlelib/Graphics/UI/GLFW/Events.hs#L77
08:15:51 <Peaker> http://hpaste.org/80264
08:16:26 <srhb> Peaker: Isn't it weird having two cost centres directly after each other
08:16:50 <srhb> Peaker: I would expect eg. loopPoll to be completely superfluous
08:16:51 <Peaker> srhb, yeah, I was wondering if maybe inlining messed it up, so I added even more SCC annotations :)
08:17:07 <Peaker> srhb, I had annotations only at the external definitions initially
08:18:15 <srhb> Anyway, I don't understand why you are seeing your results.
08:18:31 <srhb> FFI magic?
08:22:47 <srhb> No, that shouldn't affect it either. Hm.
08:23:37 <n-dolio> Peaker: Are you compiling with serious optimizations on? I haven't profiled in a while, but I seem to recall that can cause some weird stuff to happen with cost center reporting.
08:28:08 <Peaker> n-dolio, I am using -O2 iirc
08:28:16 <n-dolio> Yeah. I'd not do that.
08:28:18 <Peaker> oh, actually not in profiling
08:28:23 <Peaker>   ghc-options:         -O2 -Wall
08:28:23 <Peaker>   ghc-prof-options:    -Wall -auto-all -caf-all -rtsopts
08:28:30 <n-dolio> Oh. That's odder, then.
08:30:02 <n-dolio> Unless ghc-prof-options just inherits ghc-options, or something. But that'd be unfortunate.
08:31:34 <Peaker> oh, it does seem to append the ghc-opts too
08:32:17 <Peaker> it adds -O by default, though. Should I use -O0?
08:32:41 <n-dolio> -O0 is safest, certainly.
08:32:44 * hackagebot diff3 0.2 - Perform a 3-way difference of documents  http://hackage.haskell.org/package/diff3-0.2 (OliverCharles)
08:33:01 <n-dolio> I'd probably see what it does without any optimizations.
08:33:18 <Peaker> need to clean to change optimization flags, cabal isn't smart enough to rebuild, apparently :(
08:34:08 <dcoutts> Peaker: cabal leaves that to ghc, and ghc thinks optimisations flags don't matter for rebuilding
08:34:08 <lambdabot> dcoutts: You have 4 new messages. '/msg lambdabot @messages' to read them.
08:34:12 <Peaker> I'll try with the default (-O) flag and see what happens then
08:34:14 <dcoutts> it will rebuild on other flag changes
08:34:20 <Peaker> dcoutts, that's weird
08:34:29 <Peaker> sounds like a bug report worthy
08:38:22 <Peaker> if I add -O0, I get both -O and later -O0 in my ghc command line
08:38:30 <Peaker> I wonder which takes precedence
08:38:53 <Igloo> The last one
08:38:53 <Peaker> anyway, even in that setting, I still see my rawEventLoop as a significant chunk (now 20%) without seeing any of the cost centres from which it is composed
08:40:07 <Peaker> Igloo, thanks
08:40:21 <Peaker> so even without optimizations, my profile only shows the forever loop itself but none of its components, as costly
08:41:07 <kke05597> ciao
08:41:10 <c_wraith> that sounds implausible
08:41:11 <kke05597> !list
08:41:11 <monochrom> kke05597: http://okmij.org/ftp
08:41:32 <c_wraith> haha.  nice auto-responder, monochrom
08:41:52 <n-dolio> Peaker: Perhaps a, b and c return immediately, giving an action that takes time that is attributed to mainLoop?
08:42:07 <Peaker> n-dolio, hmm.. that sounds plausible :)
08:42:20 <c_wraith> oh.  Yes, that would explain it
08:42:28 <Peaker> how do I get IO time profiling then?
08:42:44 * hackagebot diff3 0.2.0.1 - Perform a 3-way difference of documents  http://hackage.haskell.org/package/diff3-0.2.0.1 (OliverCharles)
08:42:59 <Peaker> I think I've already stumbled on this in the past, and had already forgotten.. time profiling is a bit tricky with the IO DSL in there
08:47:44 * hackagebot diff3 0.2.0.2 - Perform a 3-way difference of documents  http://hackage.haskell.org/package/diff3-0.2.0.2 (OliverCharles)
08:52:11 <Peaker> I guess I'm gonna add some manual IO profiling and connect it with ekg
08:53:46 <quicksilver> Peaker: I don't have anything to contribute except to remark that I saw strange bugs with the profiler before and I imagined it was something like the optimiser moving SCCs around.
08:54:06 <quicksilver> Peaker: I never particularly solved them I'm afraid. I just managed to get a general idea where the time must be being spent andmoved on
09:07:35 <nus> Peaker, is GLFW built with profiling?
09:10:09 <Peaker> nus, yeah, otherwise it wouldn't build
09:10:54 <nus> oh, right
09:11:06 <nus> also, you seem to be on 7.2?
09:11:12 <hpaste> Crockeo pasted “IORef Problem” at http://hpaste.org/80266
09:11:14 <Crockeo> (Since this is going to be a little unspecific, I'm going to whip up an hpaste to go with it) I'm working a little in HOpenGL, and I've been facing a problem regarding the use of IORefs. I have an IORef of a PointMatrix (:: [(Float, Float)]) that I'm trying to use to be able to change the position of the PointMatrix in one function while displaying it in its own display callback. The only problem is the display callback's ioref doesn'
09:11:57 <shachaf>                 only problem is the display callback's ioref doesn'
09:11:57 <ziman> Crockeo, your line has been truncated at "callback's ioref doesn'"
09:12:11 <Crockeo> Hmmm okay.
09:12:20 <Crockeo> "t seem to ever be 'updated.'"
09:13:32 <Crockeo> I've tested and it _says_ that the quad is staying stationary in the display function, while in the keyboard function (no matter where it's caught) it always says it's been moved.
09:13:49 <croikle> why use unsafePerformIO in display?
09:13:50 <Crockeo> (Well, not no matter, just the keys I've bound)
09:13:58 <croikle> rather than quad <- readIORef quadRef
09:14:22 <Crockeo> (croikle: I- I don't really know. I'll go change it.)
09:14:55 <Crockeo> (Or at this point I could just do, "readIORef >>= drawQuad")
09:15:19 <croikle> yeah, sounds good
09:15:35 <Crockeo> "readIORef quadRef >>= drawQuad"*
09:15:40 <croikle> dunno if that has any effect, but it stuck out to me
09:15:49 <Crockeo> Didn't change anything, unfortunately :(
09:16:37 <ziman> Crockeo, try pasting the new source (with quad <- ...)
09:17:04 <hpaste> Crockeo pasted “New Source” at http://hpaste.org/80267
09:17:09 <neutrino> @faq can haskell help me find a cheap jtag cable?
09:17:09 <lambdabot> The answer is: Yes! Haskell can do that.
09:17:17 <neutrino> but how? :(
09:19:15 <ziman> Crockeo, do you have unsafePerformIO's or other unsafe functions anywhere else?
09:19:39 <Crockeo> Nope!
09:20:03 <srhb> neutrino: Ebay Monad?
09:20:49 <ziman> hmm
09:20:50 <rntz> is pzero == choice []?
09:21:05 <rntz> well, s/==/equivalent to/, but w/e
09:22:28 <shachaf> rntz: In Parsec?
09:22:58 <neutrino> srhb: that's not referentially transparent.
09:23:23 <shachaf> A quick grep suggests yes: "choice ps = foldr (<|>) mzero ps", "mzero = parserZero", "pzero = parserZero"
09:24:09 <b__> what's the notation for multi-line doctest _inputs_
09:24:16 <rntz> shachaf: yes
09:24:32 <rntz> ah, I bet mzero is why pzero is no longer documented or exported from Text.Parsec
09:29:52 <shachaf> rntz: What is the language you're implementing?
09:50:12 <beaky> hello
09:52:27 <art2art> hello all
09:52:43 <Eelis> hey art
09:52:50 <gspr> dreixel: Re the presentation: Nope, but thanks for asking. I enjoyed watching :-)
09:53:10 <dreixel> gspr: alright, cool :)
10:00:25 <dougransom> @pf trySetFieldBlank f = trySetField f ""
10:00:25 <lambdabot> Maybe you meant: bf pl
10:01:33 <art2art> I'm learning haskell and I'm exercising to understand how a do-notation works.
10:02:06 <art2art> log :: Int -> Writer [String] Int
10:02:06 <art2art> log x = writer (x, ["Number: " ++ show x])
10:02:06 <art2art>  
10:02:06 <art2art> multWithLog :: Writer [String] Int
10:02:09 <art2art> multWithLog = do
10:02:12 <art2art>   a <- log 3
10:02:15 <art2art>   b <- log 5
10:02:19 <art2art>   tell ["hello"]
10:02:22 <art2art>   return (a * b)
10:02:25 <art2art>  
10:02:48 <dougransom> @pl trySetFieldBlank f = trySetField f ""
10:02:48 <lambdabot> trySetFieldBlank = flip trySetField []
10:03:07 <psii> art2art: please use http://hpaste.org
10:03:20 <dougransom> @pl trySetFieldBlank g = trySetField g ""
10:03:21 <lambdabot> trySetFieldBlank = flip trySetField []
10:04:31 <art2art> oh, thanks!
10:06:44 <quchen> In the docs for Data.Set, insert is listed as O(log(n)). However, shouldn't that be O(n*log(n)) because of immutability?
10:07:02 <quchen> As in copy the whole set -> O(n)
10:07:28 <kennyd> it does not copy entire set
10:07:35 <Philippa> art2art: think of it as a limited version of let, only for monadic languages instead of Haskell
10:07:58 <psii> quchen: by using a datastructure like finger trees, you don't have to copy everything
10:08:11 <Philippa> (when you don't use <- with a statement, that's the equivalent of let _ = ...)
10:09:01 <quchen> psii: How's that? The Set implementation seems to  be quite straightforward to me.
10:09:51 <halplease> Once I am in a particular kind of monad with do notation, all my sequence will be in that monad right?
10:10:08 <quchen> I can see how for lists you can have O(1) prepend, that's because the rest of the list doesn't change when you prepend something.
10:10:14 <psii> quchen: I haven't looked at the Set implementation yet, sry. I just know that there are tricks like finger trees, which make those datastructures feasible in a functional context.
10:10:21 <quchen> However, for trees, the insert function does rebalancing.
10:10:22 <halplease> Sorry for the vague question, I cant word it better
10:10:29 <srhb> halplease: Your intuition is right.
10:10:31 <kennyd> quchen 99% of the set is not allocated but reused on insert. only the nodes on it's way up have to be allocated again
10:10:44 <srhb> halplease: There are monad transformers for when you need to use more than one monad.
10:11:06 <quchen> psii: Alright, I guess I'll have to read the paper the Set docs refer to
10:11:18 <halplease> srhb: Or nested monads and lifting?
10:11:27 <quchen> kennyd: I thought that was nifty GHC optimization, not a property of the Set itself
10:11:28 <srhb> halplease: That's the usual solution, yes. :)
10:11:57 <hpaste> art2art pasted “do-notation ” at http://hpaste.org/80273
10:12:46 <art2art> http://hpaste.org/80273
10:12:56 <srhb> art2art: You have the order wrong in the last example
10:13:04 <Philippa> halplease: right, if you've got a monad expressed in terms of the one you're in, you can use it from there - it needs its own do block, but then the function to 'run' it will give you a lexical scope to work in anyway
10:13:07 <srhb> art2art: And where you bind things with <- in the do version, you need to name the lambda parameters
10:13:33 <srhb> art2art: log 3 >>= \a -> log 5 -> \b ...
10:13:39 <rntz> shachaf: a simple intermediate language for a lisp I'm implementing
10:13:41 <srhb> Oh oops,
10:14:08 <srhb> art2art: log 3 >>= \a -> log 5 >>= \b -> ...
10:14:16 <srhb> art2art: With proper paranthesis where needed
10:15:17 <rntz> the language itself only has lambdas, function application, local variable assignment, literals for a few types, and a few conveniences on top of those (let, letrec, scheme-like begin)
10:16:49 <halplease> Philippa: I see thank you.
10:16:58 <kennyd> quchen see chapter 8 of LYAH, it has implementation of unbalanced immutable binary tree
10:17:53 <pr> i know the demand seems quite low, but has anyone actually written something like gofmt for haskell? not just some tool that gives style suggestions, rather something thats automated like gofmt
10:17:54 * hackagebot jsonrpc-conduit 0.2 - JSON-RPC 2.0 server over a Conduit.  http://hackage.haskell.org/package/jsonrpc-conduit-0.2 (GabrieleSales)
10:18:07 <hpaste> art2art pasted “do-notation2” at http://hpaste.org/80274
10:18:43 <art2art> hmm, http://hpaste.org/80274  what about this?
10:18:45 <halplease> I wanted to give up learning Haskell but I can't live without the Hindley-Milner type inference anymore.
10:18:47 <kennyd> treeInsert should make it clear that only the nodes on the way up are reallocated, the rest of the tree is reused
10:19:15 <srhb> art2art: You mean how to do it in a do version? Try it for yourself, replace foo >>= \a -> ... with a <- foo
10:19:29 <croikle> immutability lets you reuse fragments (the unchanged stuff)
10:22:40 <beaky> when designing a procedural program, I think of the big picture, then I think of subproblems, and then once I hit bottom I work my way up with the functions (programming is a hylomorphism!). Is it the same when designing a program in the functional programming paradigm?
10:22:56 <Philippa> that's a good way to work, yeah
10:23:28 <Philippa> working bottom-up only works when you know where you're going, after all
10:23:39 <mm_freak_> beaky: that's the intuitive idea, and in haskell you actually use composition abstractions to make sure that you can develop and test all parts in isolation
10:23:45 <merk_> can someone remind me what does  do x <- Just 10; y <- Just 20; return (x + y)  expand to?
10:23:59 <Philippa> (but sometimes it makes sense to ask "how do I talk about the things I'm working with?" in isolation of the particular high-level goal: that's one of the more useful lessons of OO)
10:24:25 <tcrayford> Just 10 >>= (\x -> (Just y) (\y -> Just (x + y))
10:24:26 <tcrayford> I think
10:24:31 <tcrayford> oh, missed a >>=
10:24:39 <tcrayford> Just 10 >>= (\x -> (Just y) >>= (\y -> Just (x + y))
10:25:32 <merk_> thanks.. let me decode that
10:26:02 <shachaf> @undo do x <- Just 10; y <- Just 20; return (x + y)
10:26:02 <lambdabot> Just 10 >>= \ x -> Just 20 >>= \ y -> return (x + y)
10:26:41 <mm_freak_> > liftA2 (+) (Just 10) (Just 20)
10:26:43 <lambdabot>   Just 30
10:27:05 <merk_> what if it is Nothing instead of Just 10, are those lambdas never called?
10:27:07 <dougransom> @pl trySetFieldBlankArr a = arr trySetFieldBlank a
10:27:07 <lambdabot> trySetFieldBlankArr = arr trySetFieldBlank
10:27:21 <croikle> merk_: yep
10:27:29 <art2art> srhb: In fact, I'm trying to understand how a Writer monad works with do-notion. tcrayford: thanks! I've realized my mistake.
10:27:35 <croikle> Nothing >>= _ = Nothing
10:27:45 <mm_freak_> merk_: the later lambdas aren't called
10:27:58 <mm_freak_> > Nothing >>= undefined
10:28:00 <lambdabot>   Nothing
10:28:00 * hackagebot pretty-show 1.4.1 - Tools for working with derived Show instances.  http://hackage.haskell.org/package/pretty-show-1.4.1 (IavorDiatchki)
10:31:05 <merk_> cool, thanks all. everything is a bit clearer now
10:33:29 <Lethalman_> > runIdentity $ do a <- pure 2; a <- pure (a+1); pure a
10:33:30 <lambdabot>   3
10:34:18 <merk_> a in second lambda shadows a in the first one?
10:34:32 <croikle> yeah
10:34:35 <Lethalman_> merk_, yes
10:35:33 <Lethalman_> > (+) <$> Identity 2 <*> Identity 3
10:35:34 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity b0))
10:35:34 <lambdabot>    aris...
10:35:44 <Lethalman_> > runIdentity $ (+) <$> Identity 2 <*> Identity 3
10:35:45 <lambdabot>   5
10:36:07 <Lethalman_> so Identity is nothing else a box?
10:37:01 <beaky> \does haskell have C++/C# style namespaces?
10:37:04 <shachaf> It is nothing else a box.
10:37:21 <Philippa> beaky: Just modules and lexical scoping
10:37:24 <beaky> oh
10:37:48 <halplease> Haskell is #18 on github now
10:38:05 <Lethalman_> shachaf, that may be used more to explain monads and applicatives, as it's such simple
10:38:29 <Lethalman_> before diving into IO, writer, reader, state, ...
10:38:39 <Lethalman_> @src runIdentity
10:38:39 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
10:39:42 <croikle> @src runIdentityT
10:39:43 <lambdabot> Source not found. Where did you learn to type?
10:39:46 <Lethalman_> is it just runIdentity (Identity x) = x perhaps?
10:39:55 <croikle> looks good
10:39:57 <dougransom> @pl trySetFieldBlankArr field =  arr (trySetFieldBlank field)
10:39:57 <lambdabot> trySetFieldBlankArr = arr . trySetFieldBlank
10:40:30 <shachaf> Lethalman_: No, it's mostly terrible for that.
10:40:41 <shachaf> Lethalman_: It makes people say things like "monads are boxes".
10:40:51 <shachaf> It has almost none of the interesting properties of monads.
10:41:23 <c_wraith> What interesting properties?
10:41:41 <c_wraith> The whole point of the abstraction is that it's not interesting.
10:42:37 <shachaf> c_wraith: OK, but the goal is to get some intuition about what you can and can't do, and how things behave, and so on.
10:42:56 <Lethalman_> ah runIdentity is just the value inside Identity, of course
10:42:58 <shachaf> The main point of monads is to talk about effects, in one sense or another. Identity has no effects.
10:43:24 <Lethalman_> :t mfix
10:43:25 <lambdabot> MonadFix m => (a -> m a) -> m a
10:43:42 <c_wraith> I kind of think "effects" is a terrible term for anything other than IO.
10:43:55 <shachaf> Hmm, I rather like the term.
10:44:10 <shachaf> IO is an exception to most monads in that its effects aren't nice at all.
10:44:28 <shachaf> Do you also object to calling values :: m a "actions"?
10:44:41 <c_wraith> no, that one's fine..
10:44:49 <c_wraith> It's just the word "effects" that bothers me.
10:45:06 <c_wraith> It's too intertwined with IO in most people's minds
10:45:07 <shachaf> The "effect" of «modify (+1)» seems to me to be modifying the state.
10:45:17 <c_wraith> I think that interferes with understanding
10:45:27 <shachaf> Possibly.
10:45:35 <shachaf> Anyway, I wasn't using that value to explain anything.
10:45:39 <shachaf> Er, that word.
10:46:28 <robbe-> FWIW, I only recently started to develop a better understanding for monads, and I fully agree with c_wraith about the 'effects'.
10:47:02 <HugoDaniel> is there a function like :: Word32 -> (Word8, Word8, Word8, Word8) ?
10:47:11 <robbe-> Monads were actually a lot easier than I anticipated, too. :-)
10:47:14 <HugoDaniel> and vice-versa
10:47:50 <beaky> how does haskell work
10:48:01 <beaky> all that abstract math stuff getting compiled into very efficient code
10:48:03 <c_wraith> robbe-: yeah, the problem is that people who haven't grasped the concept think they must be important, and so they say they're important to haskell.
10:48:30 <c_wraith> beaky: look at the papers on the "Spineless Tagless G-Machine" for the basic implementation idea
10:48:58 <c_wraith> beaky: GHC uses a heavily modified version of that - but the underlying idea describes the basic model pretty well
10:49:03 <beaky> ah
10:49:32 <Lethalman_> HugoDaniel, search with hoogle
10:49:32 <beaky> does that machine handle all that thunking, garbage-collection, tail-call elimination and stuff?
10:50:39 <c_wraith> There are seriously a lot of papers available for the techniques GHC uses.
10:50:39 <HugoDaniel> is there any shell command to search hoogle ?
10:50:46 <Lethalman_> hoogle
10:50:47 <c_wraith> HugoDaniel: "hoogle"
10:50:57 <croikle> @hoogle Word32 -> (Word8, Word8, Word8, Word8)
10:50:57 <lambdabot> No results found
10:51:06 <HugoDaniel> oh ok
10:51:07 <HugoDaniel> :/
10:51:42 <c_wraith> beaky: seriously, just start looking at any and all papers by Simon Peyton Jones and Simon Marlow. They produce very clear writing, and almost entirely about ideas the GHC internals draw from.
10:51:53 <croikle> @hoogle Word32 -> [Word8]
10:51:53 <lambdabot> Data.Data gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]
10:51:53 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
10:51:53 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
10:52:16 <HugoDaniel> i'll do it myself and upload to hackage
10:52:17 <HugoDaniel> :P
10:52:25 <HugoDaniel> bin-ops or something like that :/
10:52:44 <DrChaos> can I restrict Point a = Pt a a to working on Floats only with Pt :: (Float a) => a -> a -> Pt a?
10:52:51 <DrChaos> or is my syntax incorrect?
10:52:55 <mizu_no_oto> Speaking of Hoogle, how hard would it be to modify hoogle to look for instances of a type class?
10:53:04 <crdueck> @pl \m f x -> m >>= f x
10:53:04 <lambdabot> (.) . (>>=)
10:53:21 <DrChaos> I mean, data Point a = Pt a a
10:53:40 <DrChaos> I don't want a Point Char for example
10:53:40 <mizu_no_oto> @hoogle (a -> b) -> (a, c) -> (b, c)
10:53:40 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
10:53:40 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
10:53:40 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
10:54:01 <crdueck> @pl \x -> m >>= f x
10:54:01 <lambdabot> (m >>=) . f
10:54:09 <mizu_no_oto> But (a -> b) -> (a, c) -> (b, c) is first for the (,) instance of Arrow
10:54:19 <croikle> DrC: I think you generally add the constraints on the functions, not on the type
10:54:25 <beaky> I'm really worried about reading haskell papers; they are full of technical category-theory stuff and arcane math notation :(
10:54:45 <HugoDaniel> does the (,) constructor also ocuppy 1 word ?
10:55:03 <HugoDaniel> (Word16, Word16) how many bytes does this occupy in memory ?
10:55:11 <beaky> but I'm so intrigued how they got a language that defies the von-neumann model to run in von-neumann machines :D
10:56:02 <c_wraith> beaky: If you read the ones about the implementation of GHC, they have exactly zero category theory in them
10:56:07 <DrChaos> erm...how is this Gentle Introduction to Haskell going to be useful if it contains no exercises? I need programming exercises
10:56:26 <c_wraith> DrChaos: most people would say the gentle introduction isn't very useful unless you're an ML programmer
10:56:33 <crdueck> @pl \x -> f x >> g x
10:56:33 <lambdabot> liftM2 (>>) f g
10:56:44 <DrChaos> c_wraith :: what is ML?
10:56:52 <Philippa> c_wraith: it was fairly useful to me at the time. Which was a decade ago.
10:56:57 <shachaf> c_wraith: Do you know what spineless means?
10:57:17 <c_wraith> DrChaos: a family of programming languages that have some similarity to haskell, with the primary differences being non-purity and strictness
10:57:21 <c_wraith> shachaf: not really
10:57:30 <beaky> spineless means lacking a spine
10:57:37 <tromp> beaky: a recent ioccc winner implements a pure functional language in a few dozen lines
10:57:46 <shachaf> c_wraith: I know the thing GHC does isn't really tagless anymore.
10:57:50 <beaky> ah like the lambda calculus?
10:57:51 <shachaf> They don't even do vectored returns!
10:57:55 <crdueck> :t liftM2 (>>)
10:57:57 <lambdabot> (Monad m1, Monad m) => m (m1 a) -> m (m1 b) -> m (m1 b)
10:57:57 <DrChaos> c_wraith :: well err...I want a book that contains exercises. Do you know of a good book that does?
10:58:02 <|||tux||> mizu_no_oto:  Actually, i think it's first for the (->) arrow
10:58:04 <shachaf> I hear it's not spineless either, but I'm not sure what spineless means.
10:58:06 <DrChaos> RWH is too advanced
10:58:21 <mizu_no_oto> <|||tux||>: >_<
10:58:29 <c_wraith> beaky: http://research.microsoft.com/apps/pubs/default.aspx?id=67083  This paper is *exactly* what you want, readable, and contains no category theory
10:58:42 <mizu_no_oto> <|||tux||>: That's what I meant
10:58:55 * DrChaos goes to make another cup of coffee
10:59:25 <Philippa> shachaf: It's only 'incidentally' tagged these days though - the tags are an optional optimisation rather than a fundamental part of the evaluation model
10:59:56 <shachaf> Philippa: Even that's not really true, I think.
11:00:00 <shachaf> Well, sort of.
11:00:12 <shachaf> When you see an unevaluated thunk you jump to it and when it returns it gives you a tagged pointer.
11:00:21 <Philippa> right, but you can safely ignore the tag
11:00:36 <c_wraith> well, if you mask it out
11:00:43 <shachaf> Not after it returns. :-) Wait, I might be confused.
11:00:44 <c_wraith> You can't ignore its presence, just its content :)
11:00:54 <Philippa> c_wraith: sure
11:01:01 <refried_> If I've got a bunch of State a (),  and some State b ()  and I want to compose them neatly into State (a,b) ()  is there a good way do that?
11:01:26 <Philippa> shachaf: the tag is /solely/ there to let you dispatch on the constructor (sometimes) without jumping to the pointer
11:01:29 <c_wraith> refried_: that's not a use any of the combinators I can recall handles
11:01:41 <Philippa> if you jump to the pointer, you'll also find out which constructor you're dealing with
11:02:13 <Philippa> and 0 is always "no info, you're gonna have to jump"
11:02:19 <shachaf> Philippa: If you jump to the pointer, it'll force the thunk and then pass you a new tagged pointer.
11:02:26 <|||tux||> refried_:  StateT a State b ?
11:02:30 <shachaf> At which point you have to look at the tag.
11:02:32 <glguy_> refried_: http://hackage.haskell.org/packages/archive/lens/3.7.1.2/doc/html/Control-Lens-Zoom.html
11:02:35 <Philippa> shachaf: nope
11:02:37 <refried_> c_wraith: k, thanks though — I think there's some stuff for interoperating between Lens and State but not familiar offhand
11:02:49 <c_wraith> yeah, check glguy's link
11:03:07 <shachaf> Philippa: That's what I seem to be seeing for the code GHC generates.
11:03:08 <refried_> glguy_ ok this looks interesting
11:03:12 <glguy_> refried_: The types are potentially overwhelming, but the way you use it is very simple
11:03:14 <shachaf> Philippa: It's very possible that I'm misreading it, though.
11:03:18 <shachaf> Philippa: What does it do
11:03:19 <shachaf> ?
11:03:58 <shachaf> One thing it *doesn't* do is vectored returns, as in forcing a Maybe by passing it Just and Nothing continuations as two arguments.
11:04:15 <refried_> glguy_: thanks — trying to find an example
11:04:48 <Philippa> shachaf: OK, bearing in mind I'm operating off my own memory of the paper where they started doing this? An evaluated thunk is just a block of code that trivially returns its value, and a /boxed/ one is where you get the pointer-with-tag. When you have an actual value in hand, the info that tells you which constructor it is happens to be indirected - there's an RTS 'info' block
11:04:58 <Philippa> (but if you know which pointer is always (:)...)
11:05:27 <Philippa> the pointer-with-tag will just lead you to an evaluated thunk, which'll then return that value, which you can then check the info block for
11:05:54 <refried_> ah ok… magnify to change the Reader; zoom to change the State. ?
11:06:04 <Peaker> nus, 7.4.1 here
11:06:36 <hpaste> glguy pasted “zoom demo” at http://hpaste.org/80275
11:06:46 <Philippa> shachaf: I think there used to be room for a sort of trampolined vectored return as an implementation of case? BICBW
11:07:09 <Philippa> (the value was what called you back, effectively)
11:07:33 <glguy_> refried_: of course if you named a few things you wouldn't need to write "zoom" all the time
11:07:42 <shachaf> Philippa: OK, so you mean that you can dereference the pointer after you know it's evaluated (i.e. after it's returned to you) to find out which constructor it is?
11:08:09 <refried_> glguy_: thanks!  ("if i named a few things"?)
11:08:20 <glguy_> zop1 = zoom _1 op1
11:08:31 <refried_> oh ok sure
11:08:34 <refried_> oh duh
11:08:37 <refried_> thanks :-)
11:08:47 <Philippa> shachaf: when it's returned to you, you should be holding a value (possibly in a box)
11:09:11 <glguy_> refried_: Better than using tuples would be using a record. That would make it easier to add and remove fields as you go
11:09:24 <refried_> *nod*
11:09:26 <refried_> thanks again
11:09:35 <navaati> @hoogle Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
11:09:35 <lambdabot> Control.Parallel.Strategies ($|) :: (a -> b) -> Strategy a -> a -> b
11:09:35 <lambdabot> Control.Parallel.Strategies ($||) :: (a -> b) -> Strategy a -> a -> b
11:09:35 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
11:09:43 <shachaf> Philippa: A box?
11:09:44 <navaati> hi
11:10:08 <Philippa> shachaf: when you're handling things by reference still (mostly used to implement polymorphism)
11:10:29 <navaati> do one knows about a clever way to say "fmap f . blah" ?
11:10:34 <Philippa> anyway, it's always legit to have no tag/only a "no info here" tag (same thing). You only have a problem if you tag a constructor that's not accurate
11:11:21 <navaati> :t (<=<)
11:11:22 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
11:12:29 <Philippa> shachaf: oh, sorry, I'm full of shit, this is the unboxing process anyway! I'll stop talking crap, I clearly need food worse than I thought
11:12:48 <shachaf> Philippa: Looking at the generated code for "foo (Just x) = x; foo Nothing = ...", it first checks the tag to see whether it's evaluated. In the case that it isn't, it pushes a return address and then jumps to the pointer.
11:13:04 <Philippa> yeah. It doesn't have to do that though
11:13:15 <shachaf> Then the code at the return address checks the tag of its argument and has two cases: tag >= 2 and else.
11:13:16 <Philippa> if it jumps to the pointer, it's still fine
11:13:27 <shachaf> Philippa: Sure. But the code at the return address *assumes* a tag.
11:13:43 <shachaf> It only checks whether the tag is >=2 or not. It doesn't handle the case of the tag == 0.
11:14:12 <Philippa> yeah. It knows it's never /going/ to get tag == 0 though
11:14:20 <Philippa> try it with a type with a few tens of constructors
11:14:28 <shachaf> Right. But at this point in the evaluation it relies on the tag.
11:14:33 <Philippa> well, a handful'll do on a 32bit system
11:14:40 <shachaf> Sure, if it has more than 7 or so constructors, it's going to have to dereference the pointer.
11:14:45 <Philippa> yes. It's /allowed/ to. It doesn't have to.
11:14:52 <Philippa> but it's allowed to /because it forced evaluation/
11:15:03 <shachaf> Right.
11:15:11 <shachaf> The point is that once you force a sum with a small number of constructors, the tag *has* to be there.
11:15:28 <Philippa> ...I think we're using different values of 'has' there
11:15:28 <Peaker> shachaf, I wonder how it would work if instead of an "is evaluated" flag, an evaluated thunk had a func-ptr that does nothing but return the evaluated result
11:15:37 <Philippa> the compiler's totally free to use a different strategy
11:15:46 <Philippa> that doesn't break the RTS semantics
11:15:53 <beaky> does GHC have a pedantic mode?
11:16:09 <Philippa> the client code can still go do it the slow way if it wants
11:16:29 <shachaf> Philippa: OK, sure.
11:16:31 <Philippa> the tag 'has' to be there /because that's how it was implemented/ - we're safe if we forget that fact
11:16:49 <shachaf> Peaker: That's the old way. :-)
11:17:04 <shachaf> Peaker: (Old and still valid.)
11:17:05 <Philippa> otherwise, it 'has' to be there because, er, we know the rules the codegen uses to decide if it's using that strategy or not
11:17:13 <Philippa> or because we've been handed evidence it's there
11:17:22 <shachaf> Philippa: Fair enough.
11:17:23 <Philippa> it's not inherent in being-a-small-type in the RTS language
11:17:31 <Peaker> DrChaos, there's LYAH and the euler project for exercises
11:17:34 <Philippa> </pedantic>
11:17:46 <Peaker> shachaf, ah -- it was switched to a check because it's faster?
11:18:00 <shachaf> I guess all I was saying is that you can't just set the lowest three bits of every pointer to 0 everywhere and still have things work.
11:18:05 <shachaf> Which isn't saying much.
11:18:14 <shachaf> Peaker: Yep.
11:19:07 <shachaf> Peaker: That's the "tagless" part in "spineless tagless g-machine" (as far as I know).
11:19:24 <shachaf> You should read the STG paper (long) and the dynamic pointer tagging paper (shorter and more recent) to learn about this.
11:19:39 <Philippa> shachaf: yeah, client code can make assumptions because it's what gets to exercise the option
11:19:48 <shachaf> @where+ ptr-tag http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
11:19:48 <lambdabot> Okay.
11:20:14 <Peaker> shachaf, so the new way is no longer tagless? or is the tag something else?
11:20:21 <Philippa> it's a different form of tag
11:20:50 <Philippa> given an RTS-pointer, you haven't a clue what you're actually holding. You need a type as well, then the tag is just info about the constructor on the other side
11:21:03 <Philippa> compare and contrast with tagging in dynamically-typed languages
11:21:18 <Philippa> (the GC doesn't give a shit about tags!)
11:21:31 <shachaf> OK, sure. It's not tagging the pointer with a type.
11:21:58 <shachaf> Is that what the "tagless" in STG means? It seems kind of pointless to tag things with types at runtime.
11:22:16 <Philippa> it's easy to say that now we have tagless machines :p
11:22:26 <navaati> if i create an IORef, and the only place where this ref is referenced is in a callback given to a gtk widget, and i later destroy the widget, will memory be properly freed ?
11:22:34 <Philippa> (that info block I mentioned? It tells you which parts of the value are pointers the GC needs to look at...)
11:22:35 <shachaf> Philippa: True!
11:23:03 <c_wraith> navaati: depends on if the gtk widget gets GCd properly. If it does, then the IORef is fine...  But it really depends on the gtk stuff.
11:25:05 <navaati> so, normaly, gtk2hs takes care of telling the RTS to free every haskell closure given to gtk when the corresponding widget is destroyed ?
11:26:08 <mauke> it's not like you can "free" an IORef manually anyway
11:26:22 <nus> Peaker, the naming of the profiling options has changed in 7.4, but the old names are still compatible, so that's cosmetics...
11:27:09 <dcoutts> navaati: yes (though it's possible to create a cycle where a widget and a callback keep each other alive)
11:28:03 * hackagebot c0parser 0.2 - Simple C0 Parser  http://hackage.haskell.org/package/c0parser-0.2 (DanielSeidel)
11:28:05 * hackagebot c0check 0.2 - Simple C0 Syntax Check  http://hackage.haskell.org/package/c0check-0.2 (DanielSeidel)
11:28:07 * hackagebot snaplet-sqlite-simple 0.4.0 - sqlite-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-sqlite-simple-0.4.0 (JanneHellsten)
11:28:09 * hackagebot direct-sqlite 2.3.2 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.3.2 (IreneKnapp)
11:29:05 <navaati> mauke: yes, i was just wondering how well gtk2hs handle things
11:30:12 <navaati> dcoutts: ok, thanks. Uh, problem is that as i see things, such a cycle could occur quite easily, couldn't it ?
11:44:55 <crdueck> @pl \i -> do x <- m; f x i
11:44:55 <lambdabot> (line 1, column 16):
11:44:55 <lambdabot> unexpected ';'
11:44:55 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
11:45:07 <shachaf> @@ @pl @undo \i -> do x <- m; f x i
11:45:07 <lambdabot>  (m >>=) . flip f
11:45:22 <crdueck> thanks :)
11:49:53 <beaky> I've just made a profound discovery
11:50:13 <beaky> both water and air are monoids :D
11:50:36 <nathanfh> beaky: wat?
11:51:26 <beaky> maybe ice isn't a monoid though
11:51:37 <c_wraith> what's the zero element?
11:51:59 <mauke> cake
11:52:06 <beaky> maybe the vacuum of space
11:52:07 <c_wraith> > cake
11:52:09 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
11:52:26 <nathanfh> Couldn't we generalize it to say that all fluids are monoids?
11:53:11 <c_wraith> I might agree that the list of atoms/molecules make up a monoid under list concatenation
11:53:18 <navaati> > cake !! 1
11:53:20 <lambdabot>   "One can prepared coconut pecan frosting."
11:53:26 <navaati> > cake !! 2
11:53:28 <lambdabot>   "Three slash four cup vegetable oil."
11:53:32 <applicative> there is always a null item in a mereology
11:55:48 <brunonery> hi there! what's the difference between "StateT Maybe" and "MaybeT State" ?
11:56:03 <croikle> which one you have to lift to access
11:56:06 <shachaf> @unmtl StateT Maybe a
11:56:06 <lambdabot> Plugin `unmtl' failed with: `StateT Maybe a' is not applied to enough arguments, giving `/\A. Maybe -> a (A, Maybe)'
11:56:10 <shachaf> @unmtl StateT s Maybe a
11:56:10 <lambdabot> s -> Maybe (a, s)
11:56:19 <shachaf> @unmtl MaybeT (State s) a
11:56:19 <lambdabot> s -> (Maybe a, s)
11:56:31 <shachaf> croikle: No, they're quite different.
11:56:35 <mauke> whether failure keeps state
11:56:44 <gspr> Saizan: Hi again. Regarding the ExistsNat way of mitigating not having an "exists" quantifier you told me earlier today (I haven't had time to look at it thoroughly before now): does it need new GHC 7.6 things to work? I get a complaint that the type variable f is not in scope
11:56:47 <croikle> oh, yeah
11:57:14 <gspr> Saizan: I guess it's the same kind of complaint one would get when one needs -XScopedTypeVariables, but turning that on doesn't help
11:57:29 <shachaf> gspr: If you asked the question with a bit more context then maybe people other than Saizan could help. :-)
11:57:29 <brunonery> hmmm interesting
11:57:51 <shachaf> For example, people could see whether you're using forall in your code -- you need to use forall to make ScopedTypeVariables work.
11:58:06 <c_wraith> the big difference between the two is whether state is available after early termination.
11:58:25 <brunonery> I thought it wouldd be the other way around
11:58:49 <shachaf> OK, it's the other way around: "the big difference between the two is whether state isn't available after early termination."
11:59:03 <brunonery> no, I mean I though StateT would keep the state after termination
11:59:08 <brunonery> and MaybeT wouldn't
11:59:16 <brunonery> but from unmtl it seems it's the other way around
11:59:22 <shachaf> brunonery: Expand out the types and see. :-)
11:59:24 <c_wraith> yeah, I always get that backwards, too
11:59:46 <c_wraith> I have to check the return type of each after removing newtype wrappers to get it right :)
11:59:47 <shachaf> StateT s m a = s -> m (a,s)
11:59:54 <c_wraith> (which is what the @unmtl command does)
11:59:56 <gspr> shachaf: True! I was learning about data kinds and type-level naturals earlier today, and I wanted to turn a list into a length-typed vector where the length type is the type-level natural corresponding to the list's length. Saizan explained to me (hopefully retelling this correctly now) that that would mean having the type of the function depend on the value of one of its arguments (i.e. dependent types?).
11:59:59 <brunonery> c_wraith: following the intuition is not always good haha
12:00:10 <gspr> He showed me how to work around it using  data ExistsNat f where ENat :: forall (n :: Nat). f n -> ExistsNat f
12:00:30 <gertc> how do i hide id from prelude so i can do this data User = User { id          :: Text
12:00:40 <shachaf> gspr: OK, your forall needs to mention "f"
12:00:41 <gspr> gertc: import Prelude hiding (id)
12:00:46 <gertc> thx
12:00:59 <shachaf> gspr: If you have any variables quantified with "forall", you need to mention all of them.
12:01:05 <gspr> shachaf: Ah, right... it's something about ahving to make all foralls explicit if one is?
12:01:27 <shachaf> gspr: (The f on the outside is actually not related to the f on the inside -- you could just as easily replace the inside letter with g if you wanted.)
12:01:30 <shachaf> gspr: Yep.
12:01:38 <brunonery> c_wraith: by the way, the poster in SO originally got it backwards too: http://stackoverflow.com/questions/5075621/what-is-the-difference-between-different-orderings-of-the-same-monad-transformer
12:01:43 <gspr> shachaf: Right. I really know this, just forgot. Thanks :)
12:02:01 <bstrie> hi folks, I just learned thirty seconds ago that ghc is self-hosted. does anyone know if it does the same three-phase compilation that e.g. gcc does? how long in wall-clock time does it typically take to complete a full self-hosted build?
12:02:30 <gertc> :q
12:02:50 <gertc> doh vim command sorry :)
12:02:55 <monochrom> it takes only two stages. but it is hours
12:03:15 <bstrie> monochrom: interesting, so is it comparable to pypy then?
12:03:21 <monochrom> I don't know
12:03:23 <shachaf> bstrie: I don't know what the three-phase compilation that gcc does is, but this might be relevant: http://hackage.haskell.org/trac/ghc/wiki/Building/Architecture/Idiom/Stages
12:03:43 <bstrie> shachaf: thanks
12:03:53 <shachaf> GHC doesn't necessarily take hours to compile.
12:04:20 <bstrie> I figure it depends on the machine, yeah. was just looking for a ballpark ("fast as lua" to "slow as pypy")
12:05:33 <Philippa> bstrie: it's phased, yeah. Haven't built it myself - had a few failing goes on an ARM chromebook, otherwise haven't needed to
12:05:50 <Philippa> I hear it takes about a day on a Pandaboard and that having a decent amount of RAM helps!
12:06:22 <bstrie> Philippa: I was just idly comparing the build speeds of various self-hosted compilers (gcc, clang, rust, etc.)
12:06:24 <Philippa> (so maybe an hour or two on a modern x86 chip that isn't branded Atom or similar given 8GB of RAM?)
12:06:36 <bstrie> ok, thanks
12:06:48 <shachaf> I think it's less than that.
12:07:12 <shachaf> I would make clean and rebuild to find out, except I'd rather not.
12:07:14 <Philippa> *nod*. You can expect intensely optimising compilers to take longer to build optimised versions of themselves than it takes to get something out of something that doesn't optimise much
12:07:26 <Philippa> room warm enough already, huh? :p
12:07:53 <monochrom> haha
12:08:29 <shachaf> Sometimes when I'm cold I open a couple of ghci sessions and run last [1..]
12:08:45 <shachaf> gwern: Should I fold proteins instead?
12:08:55 <gwern> shachaf: yes
12:09:25 <brunonery> shachaf: foldr or foldl?
12:09:33 <gwern> shachaf: also, I don't think that would work well, wouldn't that just use up memory and segfault, as opposed to a nice tight arithmetical loop?
12:09:41 <thoughtpolice> shachaf: when i was walking around seattle in october, i compiled GHC on my laptop to keep warm at a coffee shop :)
12:09:56 <shachaf> gwern: Why?
12:10:17 <shachaf> Certainly, it shouldn't segfault for any reason.
12:10:23 <gwern> fine, OOM killer
12:10:28 <shachaf> Why?
12:10:28 <croikle> http://spl.smugmug.com/Humor/Lambdacats/i-2zgRG5v/0/O/1c199077-f3db-47e7-9bc4-a4447b1b7ba0.jpg
12:10:35 <gwern> shachaf: well, a tight loop would exercise the cpu a lot and shed a lot of heat; writing to ram doesn't generate as much heat as far as I know, and will terminate if you run out of memory
12:10:47 <thoughtpolice> bstrie: with a few cores and about 4GB of RAM, you can compile GHC in well under 30 minutes
12:10:56 <shachaf> Why should it use up more than constant memory?
12:11:12 <shachaf> Well, OK, log(size of number)
12:11:17 <monochrom> because Integer is not constant memory
12:11:18 <int-e> shachaf: running several processes in parallel ...
12:11:26 * int-e wonders
12:11:28 <Philippa> thoughtpolice: I was only semi-joking about building GHC turning my chromebook into a bedwarmer the other night
12:11:29 <monochrom> and you're talking about log(infinity)
12:11:34 <gwern> indeed.
12:11:35 <Philippa> thoughtpolice: good to know!
12:11:44 <thoughtpolice> bstrie: of course, more cores and more memory makes that go down. :) on this machine (quad i7, 16GB RAM) i can do a 'full' GHC stage build in about 10-14 minutes i think
12:11:45 <shachaf> monochrom: Yes, but fortunately I stopped the process before it got there.
12:11:52 <thoughtpolice> s/stage/stage2/
12:12:01 <shachaf> monochrom: So I mean that at any point in the loop it should only use log(number of iterations so far)
12:12:09 <Philippa> nice! How much does that go down for 8GB?
12:12:25 <Philippa> (my i7 machine's only got 8, it's a couple of years old now)
12:12:29 <monochrom> and if it's ghci as opposed to ghc -O, last[1..] builds a growing thunk for the "current" number
12:12:56 <shachaf> monochrom: In my experience it does not.
12:13:04 <thoughtpolice> Philippa: it probably doesn't make too much of a difference in all honesty. i think at about 4GB and beyond, you'll get better results from more cores and a faster HDD
12:13:24 <shachaf> monochrom: Why would it?
12:13:36 <shachaf> This is up to Integer's enumFrom instance, I think.
12:13:47 <thoughtpolice> Philippa: i'd be willing to bet the difference between my linux w/SSD, 16GB of RAM and i5 and this machine w/SSD and 16GB of RAM with i7, is almost entirely at that point locked up in the difference in core numbers between the two
12:14:10 <thoughtpolice> (since with hyperthreads, the i7 has 8 cores, and the i5 is dual, which bumps it to 4)
12:14:34 <Philippa> heh, I'm not sure I was expecting HT to be quite that strong for GHC...
12:15:14 <thoughtpolice> i don't think HT induce entirely-linear build time speedup, but twice as many things compiling at once does help :)
12:15:15 <shachaf> I wouldn't be surprised if HT helped GHC compilation a fair amount.
12:15:21 <Philippa> I can tell you it takes a lot longer than that on an ARM chromebook, anyway
12:15:23 <shachaf> But then again I don't really know.
12:15:36 <Philippa> shachaf: I'm not expecting none? Just not expecting a 100% boost
12:15:43 <shachaf> monochrom: The enumFrom instance for Integer is strict.
12:15:55 <thoughtpolice> oh, it's probably not a 100% boost, i couldn't give you exact timings at the moment
12:15:56 <shachaf> Philippa: Sure, it hardly ever gives you 100%
12:16:04 <monochrom> oh! then it helps
12:16:10 <Philippa> I could see it doing better than average for GHC though, yeah
12:16:18 <thoughtpolice> but it's not 30 minutes vs 15 or anything, probably more like ~20ish vs ~15ish
12:16:27 <shachaf> I've found it to help even in cases where you would think it wouldn't.
12:16:30 <thoughtpolice> (it's been a while since I built GHC on that linux machine)
12:17:47 <thoughtpolice> Philippa: oh, and also it's worth mentioning, mk/build.mk in the GHC tree has a *substantial* affect on build times, of course :)
12:18:11 <shachaf> I like to set build.mk to stop at stage0
12:18:12 <thoughtpolice> since that controls whether you build in 'full optimized' mode, where everything is pretty much -O2, or you only compile with optimized libraries and unoptimized GHC, etc.
12:18:13 <shachaf> Very fast.
12:18:38 <thoughtpolice> that *can* make the difference between GHC building in 40 minutes and 20 minutes alone
12:19:18 <thoughtpolice> shachaf: HOLY COW I'M TOTALLY GOING SO FAST OH F***
12:19:36 <monochrom> hahaha
12:19:46 <shachaf> -fomit-instruction-pointer
12:20:12 <monochrom> -fdry-run
12:20:33 <Philippa> thoughtpolice: right now I need to figure out the right kludge to get it to stop asking where its LLVM is, anyway
12:20:42 <Philippa> (and right now I'm too tired/dopey to do so!)
12:20:45 <shachaf> Philippa: Isn't that kludge just $PATH?
12:21:00 <thoughtpolice> Philippa: did symlinking llc-3.0/opt-3.0 to llc/opt not work?
12:21:02 <Philippa> shachaf: slightly more, Ubuntu does silliness, but yeah
12:21:10 <thoughtpolice> that's all I've ever done IIRC
12:21:22 <Philippa> thoughtpolice: shachaf's probably right about what I've missed on an otherwise nearasdammit as-installed system :-)
12:21:48 <Philippa> I've just had a lousy week in terms of energy levels, is all
12:21:48 <thoughtpolice> heh, i could have sworn ~/bin was in $PATH by default on ubuntu these days
12:21:52 <thoughtpolice> ah
12:23:09 <zhulikas> @pl (\a b -> head a == head b)
12:23:09 <lambdabot> (. head) . (==) . head
12:23:15 <zhulikas> hmm :/
12:23:23 <croikle> zhulikas: use `on`
12:23:25 <monochrom> it's a bit more subtle. at .profile time, iff ~/bin exists, it is added to PATH
12:23:28 <zhulikas> @t liftM2
12:23:28 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
12:23:33 <zhulikas> :t liftM2
12:23:34 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:23:36 <zhulikas> I think I need that instead
12:23:43 <mauke> :t (==) `on` take 1
12:23:45 <lambdabot> Eq a => [a] -> [a] -> Bool
12:23:47 <Philippa> monochrom: huh. I might be fine now, then
12:24:29 <zhulikas> @type ((==) `on` head)
12:24:30 <lambdabot> Eq b => [b] -> [b] -> Bool
12:24:32 <zhulikas> thanks
12:24:38 <zhulikas> exactly what I need
12:24:48 <zhulikas> @type on
12:24:49 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:24:56 <zhulikas> this isnt very clear though
12:25:01 <zhulikas> ahh, no, it is
12:25:13 <rntz> honestly, the definition of on is clearer than its type
12:25:21 <zhulikas> type is also very clear :D
12:25:28 <zhulikas> just looks confusing
12:25:37 <zhulikas> haha, I dont make sense
12:25:40 <zhulikas> clear, but confusing
12:25:46 <monochrom> it is just long
12:25:50 <zhulikas> yes
12:25:57 <zhulikas> @src on
12:25:58 <lambdabot> (*) `on` f = \x y -> f x * f y
12:26:11 <monochrom> clearly, humans are underperforming at reading anything long, formal language or natural language
12:26:23 <Philippa> right, here we go again. My lap is about to get a couple of degrees warmer
12:26:32 <zhulikas> monochrom, nobody read to the end of your very last sentense
12:27:00 <Philippa> that's probably because monochrom's very last sentence has yet to be written?
12:27:14 <monochrom> haha
12:27:32 <monochrom> "nobody knows the answer to last[1..]"
12:27:32 <zhulikas> :D
12:27:47 <Philippa> monochrom: you're hopeful :p
12:27:54 <monochrom> or perhaps, s/knows/waits for/
12:27:59 <zhulikas> also, I only recently adopted point free functions
12:28:05 <zhulikas> and can't say how much I love them!
12:28:12 <Philippa> there's a lovely point free version of Y in terms of S
12:28:33 <zhulikas> code is much more readable too!
12:28:55 <monochrom> I think the type says "convert (b->b->c) to (a->a->c), using (a->b)"
12:29:38 <monochrom> (clearly, the trick to reading anything long is divide and conquer)
12:29:55 <srhb> Ding!
12:31:59 <Philippa> zhulikas: I find a tasteful blend works well, yeah
12:32:17 <croikle> things like (f .) . g are kinda ehhh
12:32:33 <Philippa> croikle: yeah. So people have provided alternative names for them
12:32:35 <croikle> though maybe that's better written with (.).(.)
12:32:44 <Rembane> Tripple boobs?
12:32:49 <zhulikas> :D
12:32:56 <croikle> it is known as the boob operator
12:33:06 <Nereid> :t (.)(.)
12:33:07 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
12:33:12 <Nereid> gah cale.
12:33:15 <Philippa> croikle: congratulations, as a long-standing female haskeller I have never seen that one before
12:33:17 <croikle> or maybe that one, dunno
12:33:25 <Nereid> :t let (.) = (Prelude..) in (.)(.)
12:33:26 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
12:33:38 <zhulikas> :D
12:33:50 <Nereid> :t let (.) = (Prelude..) in (.)(.)(.)(.)(.)(.)
12:33:51 <lambdabot> (b -> b1 -> c) -> (a -> b) -> a -> (a1 -> b1) -> a1 -> c
12:33:55 <Nereid> :t let (.) = (Prelude..) in (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
12:33:56 <lambdabot> (b1 -> b -> c) -> (a -> b1) -> a -> (a1 -> b) -> a1 -> c
12:34:00 <croikle> Philippa: really? I've seen it referenced several times, and haven't been around that long
12:34:08 <Nereid> these two are equal. why?
12:34:15 <shachaf> Nereid: Because associativity, I think.
12:34:19 <shachaf> I don't remember anymore.
12:34:24 <Nereid> well, because you prove they're equal.
12:34:25 <shachaf> I stepped through it once.
12:34:29 <Nereid> me too
12:34:50 <Philippa> croikle: I'm also never, ever sarcastic
12:34:52 <Nereid> it's silly in any case.
12:35:04 <croikle> Philippa: d'oh
12:35:37 <Nereid> I want to find an opportunity to use it in some real code.
12:36:31 <zhulikas> :D
12:36:41 <zhulikas> I just wrote a function which is called weirdPanda :|
12:36:52 <zhulikas> and it does its job just great
12:43:01 <hiptobecubic> Is it right to say that groups are monoids where every object is invertible?
12:43:40 <Nereid> sure.
12:43:43 <Nereid> if by object you mean element.
12:52:43 <HugoDaniel> hi
12:52:50 <Wizek> hello
12:53:13 <HugoDaniel> whats the best data type (in terms of space efficiency) to store an array/set of bytestrings ?
12:53:32 <mauke> ()
12:53:35 <HugoDaniel> :D
12:53:44 <simpson> HugoDaniel: A lazy BS is a list of strict BSs.
12:54:09 <simpson> So you could probably just get away with handling lazy BSs. What are you building?
12:55:47 <HugoDaniel> simpson: a simple memory indexing data structure
12:56:09 <HugoDaniel> unfortunately things tend to occupy loads of MB in haskell
12:56:23 <dmwit> ?hackage bytestring-trie
12:56:23 <lambdabot> http://hackage.haskell.org/package/bytestring-trie
12:56:57 <`^_^v> i have something like this: case Map.lookup … of Nothing -> tell ["error"] Just _ -> (nop)
12:57:03 <`^_^v> how would i implement that nop
12:57:20 <shachaf> return ()?
12:57:21 <byorgey> `^_^v: return ()
12:57:40 <HugoDaniel> is it possible to use bytestring in vector unboxed ?
12:57:59 <dmwit> HugoDaniel: Only data values with a bounded size can be put in an unboxed vector.
12:58:25 <HugoDaniel> all my data types are bounded
12:58:27 <neutrino_> maybe you can use a vector of unboxed chars?
12:58:33 <dmwit> ByteString is not bounded.
13:00:51 <HugoDaniel> i dont know how to make instances of Unbox
13:01:09 <applicative> a vector of unbox chars is fine; a vector of bytestrings no
13:01:22 <applicative> unboxed chars.
13:01:45 <simpson> HugoDaniel: So you've already built this thing and been dissatisfied with memory consumption, right?
13:01:57 <HugoDaniel> simpson: sort of, im benchmarking
13:02:08 <HugoDaniel> its half-way done
13:02:40 <applicative> do the bytestrings represent something?
13:02:48 <HugoDaniel> the heap profiling showed some nasty graphics for Vector MyData
13:03:11 <HugoDaniel> even though MyData fields are strict and unpacked
13:03:45 <HugoDaniel> so im serializing to strict ByteStrings with cereal, and also created some constrained text datatypes
13:04:08 <applicative> HugoDaniel: http://hackage.haskell.org/packages/archive/vector-th-unbox/0.2.0.1/doc/html/Data-Vector-Unboxed-Deriving.html
13:14:43 <osa1> where can I download source of base ?
13:14:57 <HugoDaniel> thanks
13:14:58 <shachaf> Hackage?
13:15:00 <HugoDaniel> gotta go now
13:15:32 <osa1> I can't find base on hackage
13:15:41 <osa1> aha, found it
13:16:27 <startling> @hackage base
13:16:27 <lambdabot> http://hackage.haskell.org/package/base
13:16:30 <dmwit> shachaf: That's a cruel trick.
13:16:58 <shachaf> dmwit: Hmm?
13:17:15 <shachaf> dmwit: Oh, you're thinking they'll type `cabal unpack base` and get the wrong version?
13:17:17 <applicative> https://github.com/ghc/packages-base/tree/master/GHC
13:18:09 <startling> is there a typeclass that just wants *> ?
13:18:11 <shachaf> dmwit: The download link at the bottom of the page startlambdaboting linked to work fine.
13:18:26 <shachaf> startling: Is (<*>) good enough?
13:18:39 <startling> shachaf: nope
13:18:56 <bstrie> thoughtpolice: thanks for the experiment :)
13:19:02 <dmwit> shachaf: Hm, I thought it was a cruel trick because I got tricked. But perhaps most people would not.
13:19:02 <shachaf> startling: IT'LL HAVE TO DO
13:19:09 <shachaf> dmwit: ?
13:19:30 <shachaf> Is it the thing I said or something else?
13:19:33 <dmwit> shachaf: Just as you say: I went "cabal unpack base" and got a version of base where all the files say "module Foo where import "base" Foo".
13:19:39 <startling> shachaf: heh. My thing isn't an Applicative, though, so it needs to have its own *>-ish thing
13:19:54 <shachaf> dmwit: Yes, with cabal unpack you have to specify a version, due to annoying things.
13:20:03 <Wizek> I'm on tryhaskell.org/#22 and I have a question abotu step 22. Why won't it accept my answer as `let (a, _) = (10,"abc") in a`?
13:20:10 <shachaf> But I said Hackage, not cabal unpack. :-) I should probably have specified further.
13:20:22 <dmwit> what, cabal isn't Hackage? ;-)
13:20:54 <glguy_> Wizek: your solution gets the 10 out, and not the 'a'
13:21:01 <shachaf> Wizek: The exercise is «Try to get the 'a' value from this value using pattern matching»
13:21:19 <Wizek> oh
13:21:33 <Wizek> I thought it was about the first value of the tupe
13:21:35 <Wizek> tuple
13:21:44 <Wizek> as it was referred to as a beforehand
13:21:47 <Wizek> thanks
13:23:07 <dmwit> Is TryHaskell supposed to automatically advance if you get the right answer?
13:23:36 <Wizek> for me it does
13:23:49 <glguy_> dmwit: You aren't rewarded for being clever in your solutions
13:23:57 <Wizek> I like this site so far
13:24:06 <Wizek> hope I won't rn out of lessons soon
13:24:53 <dmwit> glguy_: I wasn't rewarded for being unclever, either. Perhaps I'm not so good at Haskell as I thought.
13:25:19 <glguy_> dmwit: which step was that?
13:25:21 <shachaf> dmwit: I heard you'd rather unsafeCoerce than pattern-match...
13:26:14 <dmwit> glguy_: Step 22, I tried "let (_, a:_) = (10,"abc") in a", which looked pretty damn close to the answer they were asking for...
13:26:17 <dmwit> to me
13:26:35 <dmwit> (I wasn't surprised at all when my "clever" attempts weren't accepted. ;-)
13:26:49 <shachaf> I tried a "clever" solution: 'a'
13:26:53 <dmwit> yep, me too
13:27:00 <glguy_> dmwit: the difference was you can't have the space after the first ','
13:27:03 <dmwit> and let (_, a:_) = (10, "abc") in 'a'
13:28:01 <glguy_> You have to name your variable 'a', as well
13:28:08 <glguy_> just a little specific :)
13:29:00 <dmwit> To be fair, I can't really imagine a good way to catch all the things I'd want to try, anyway.
13:29:12 <dmwit> So a bad way is a start. =)
13:29:21 <Wizek> regexp?
13:29:48 <dmwit> Perhaps something like that, yeah.
13:30:11 <burbul> What's the easiest way of writing a function that maps
13:30:25 <shachaf> map
13:30:34 <glguy_> <_<
13:30:35 <Wizek> haha very funny
13:30:37 <burbul> [a,b,c,d] |->  [[f(a),b,c,d], [a,f(b),c,d], ... ]
13:30:51 <burbul> I can do it bare hands, but it seems like it should be in the library...
13:30:55 <burbul> *a library
13:31:58 <glguy_> thing f xs = [ ys ++ f z : zs | (ys,z:zs) <- zip (inits xs) (tails xs)] -- is the first thing that comes to mind
13:32:30 <burbul> thanks
13:33:26 <shachaf> Is this one of those things that's nicely expressed as a "paramorphism"?
13:34:27 <shachaf> > (\f s -> map (ipeeks f) $ holesOf traverse s) toUpper "hello"
13:34:28 <lambdabot>   Not in scope: `ipeeks'
13:34:32 <shachaf> Hmph.
13:34:37 <Wizek> So, this pattern matching thing is for all data types what regexp is for strings? And`_` is like `.+`?
13:34:53 <shachaf> > (\f s -> map (\(Context k x) -> k (f x)) $ holesOf traverse s) toUpper "hello"
13:34:54 <lambdabot>   ["Hello","hEllo","heLlo","helLo","hellO"]
13:35:06 <dmwit> Patterns are a bit less powerful than regexen. _ is a bit like .+, yes
13:38:19 <S11001001> @ty duplicate
13:38:21 <lambdabot>     Not in scope: `duplicate'
13:38:21 <lambdabot>     Perhaps you meant one of these:
13:38:21 <lambdabot>       `replicate' (imported from Data.List),
13:38:52 <S11001001> @ty (Control.Comonad.=>>)
13:38:54 <lambdabot> Control.Comonad.Comonad w => w a -> (w a -> b) -> w b
13:39:31 <Wizek> are there other equivalents as well? like `.*`, `|` or `[]`?
13:40:34 <shachaf> > let diag f [] = []; diag f (x:xs) = (f x:xs) : map (x:) (diag f xs) in diag toUpper "abc"
13:40:35 <lambdabot>   ["Abc","aBc","abC"]
13:41:12 <lightquake> blah
13:41:21 <lightquake> the haskell indentation mode i'm using doesn't handle the rec keyword properly
13:41:45 <byorgey> > (\f s -> map (peeks f) $ holesOf traverse s) toUpper "hello"
13:41:46 <lambdabot>   Not in scope: `peeks'
13:41:59 <byorgey> peeks works if it's in scope
13:42:06 <shachaf> True, no need for indexing.
13:42:28 <shachaf> byorgey: Anyway holesOf isn't satisfactory because it gives you a list rather than the original structure.
13:42:35 <byorgey> right.
13:42:41 <shachaf> I want that function!
13:42:46 <byorgey> me too.
13:43:03 <shachaf> Traversable t => (a -> b) -> t a -> t (a, a -> t b)
13:43:04 <byorgey> I don't see why it would be difficult to implement.
13:43:06 <shachaf> Or something like that.
13:43:26 <shachaf> It's not difficult if you're willing to cheat enough.
13:43:35 <shachaf> We want something that doesn't use any partiality.
13:44:11 <byorgey> Traversable t => t a -> t (Context a a t)
13:44:28 <byorgey> that's the essence of it
13:44:31 <shachaf> That works too.
13:44:42 <gilligan_> evening
13:44:43 <shachaf> Er, I got my type wrong.
13:44:49 <byorgey> this is "Hancock's cursor down operator"
13:44:51 <shachaf> Traversable t => (a -> b) -> t a -> t (a, b -> t b)
13:45:02 <byorgey> as attributed by Conor McBride.
13:45:03 <shachaf> But what you said works too.
13:45:18 <byorgey> makes sense
13:45:43 <shachaf> byorgey: Anyway a good solution is welcome. :-)
13:45:50 <shachaf> roconnor wanted it too.
13:45:55 <byorgey> I will give it some thought.
13:46:06 <glguy_> shachaf: regarding "Anyway holesOf isn't satisfactory because it gives you a list rather than the original structure." , Did you want "Representable"?
13:47:14 <shachaf> @ty \x -> (unsafePartsOf traverse .~ holesOf traverse x) x
13:47:16 <lambdabot> Traversable t => t a -> t (Context a a (t a))
13:47:17 <neutrino_> hi glguy_ !
13:47:22 <shachaf> @ty \x -> (partsOf traverse .~ holesOf traverse x) x
13:47:23 <lambdabot>     Occurs check: cannot construct the infinite type:
13:47:23 <lambdabot>       a0 = Context a0 a0 (t0 a0)
13:47:23 <lambdabot>     Expected type: t0 (Context a0 a0 (t0 a0))
13:47:25 <glguy_> Hello, neutrino_.
13:47:27 <shachaf> glguy_: Did I?
13:48:02 <glguy_> shachaf: It's not the same, but it reminded me of what you were saying in that sentence. (I haven't been following the rest of the conversation)
13:49:29 <byorgey> shachaf: oh, does that \x -> (unsafePartsOf traverse .~ holesOf traverse x) x  thing work?
13:50:52 <shachaf> byorgey: Yep.
13:50:58 <byorgey> nice
13:51:09 <shachaf> But it flattens the whole thing out into a list. :-(
13:51:18 <shachaf> Well, you could write the same thing with Magma.
13:51:23 <shachaf> But using partsOf is nasty.
13:51:37 <DrChaos> What are some good programming exercises?
13:51:39 <byorgey> you mean it's inefficient?
13:51:54 <deus_rex> DrChaos: Get up from your chair every 15 minutes, do some jumping jacks, situps, and pushups.
13:51:56 <shachaf> I mean it's partial.
13:52:11 <shachaf> And also multiple passes, and also flattens out the monoid.
13:52:18 <shachaf> There ought to be a really nice way of doing it.
13:52:25 <byorgey> right, OK.
13:55:56 <BrianHV> is there a standardish data structure whose elements are addressable? I want a way to navigate through the structure and have elements link to other elements
13:56:23 <navaati> BrianHV: look at Data.Map
13:56:42 <navaati> whose core operation is :
13:56:47 <navaati> :t Data.Map.lookup
13:56:48 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
13:57:07 <glguy_> ?type holes
13:57:08 <lambdabot> Plated a => a -> [Context a a a]
13:57:26 <DrChaos> deus_rex :: hahah
13:58:27 <BrianHV> hm... strictly speaking that fulfills my stated requirements, I suppose. let me look into it and see if I hit other constraints.
13:58:30 <BrianHV> thanks
13:58:45 <shachaf> glguy_: The [] Plated instance is unlikely to be what you want. :-)
13:59:10 <`nand`> DrChaos: maybe something like http://www.haskell.org/haskellwiki/99_questions ? but be warned, it's a translation of a translation (or something), so iirc a lot of them are not related to very idiomatic haskell
13:59:25 <`nand`> shachaf: []'s plated just finds the tail?
13:59:39 <`nand`> > "hello"^..plate
13:59:40 <lambdabot>   ["ello"]
13:59:56 <glguy_> wow, that's interesting :)
14:00:09 <`nand`> makes sense, if you consider lists a one-sided tree; with the tail as its child
14:00:12 <shachaf> `nand`: Yep.
14:00:27 <glguy_> Someone was looking for a function like this earlier
14:00:28 <glguy_> > let thing f = map (\(Context g y) -> g (f y)) . holesOf traverse in thing (+1) [10,20,30]
14:00:30 <lambdabot>   [[11,20,30],[10,21,30],[10,20,31]]
14:00:49 <shachaf> Yes.
14:01:01 <shachaf> I think I and/or byorgey gave that answer. :-)
14:01:13 <shachaf> But it cheats, because it only works for lists accidentally.
14:01:14 <`nand`> :t holesOf
14:01:15 <lambdabot> LensLike (Bazaar a a) s t a a -> s -> [Context a a t]
14:01:30 <shachaf> Pft, that's old holesOf
14:01:36 <glguy_> shachaf: How's that?
14:01:46 <shachaf> New holesOf :: (Corepresentable p, Comonad (Corep p)) => Overloading p (->) (Bazaar p (->) a a) s t a a -> s -> [Pretext p (->) a a t]
14:01:48 <`nand`> (RepresentableProfunctor p, Comonad (Rep p)) => Overloading p (->) (Bazaar p (->) a a) s t a a -> s -> [Pretext p (->) a a t]
14:01:49 <`nand`> of course
14:01:52 <`nand`> it all makes sense
14:01:56 <shachaf> glguy_: Imagine it was anything other than a list.
14:02:05 <shachaf> holesOf would still give you a list, rather than the original structure.
14:02:13 <shachaf> Well, I suppose it's possible that what you want is a list anyway.
14:02:15 <shachaf> Who knows.
14:02:17 <glguy_> It would give you a list of the original structure
14:02:41 <shachaf> Right.
14:02:57 <`nand`> shachaf: how about if you want a new structure that is like a nested version of itself, with the appropriate context at each position?
14:03:10 <glguy_> I see what you mean. I'm now trying to think of why I'd want it to not be a list, now
14:03:15 <`nand`> context having been replaced*
14:13:44 <hpaste> ePak pasted “Ctrl-C sub-process” at http://hpaste.org/80281
14:14:17 <startling> how evil is ImplicitParams? I like it a lot for writing unit tests with a minimum of boilerplate
14:15:04 <sclv> not evil at all
14:15:39 <byorgey> it's not evil.  Just seldom used.
14:15:48 <startling> good to know, thanks
14:15:56 * Heffalump likes them
14:16:01 <shachaf> It's the... Oh, never mind.
14:16:12 <startling> :D
14:16:16 <Heffalump> I avoid re-binding them in recursive calls though
14:16:29 <ePak> Hi, I am facing some unexpected behavior with haskell in Windows, I hope someone would help me with this
14:16:35 <startling> Heffalump: haha
14:17:11 <Heffalump> startling: it's legal, but can be confusing (there's an example either in the GHCmanual or the haskell wiki, IIRC)
14:17:21 <Heffalump> ePak: go ahead and describe it
14:17:27 <startling> sure, makes perfect sense
14:19:35 <`nand`> hmm, it seems implicit param contexts aren't valid types (of kind Constraint)
14:19:36 <ePak> If I run this program http://hpaste.org/80281 under Windows' cmd.exe, press ctrl-c will not interrupt the "waitForProcess" call, but it works if I run it in MinGW shell
14:19:57 <ePak> tried both ghc 7.4.1 and 7.6.1 and compiled with -threaded
14:20:07 <parcs> you never know with windows
14:20:08 <Heffalump> ePak: ctrl-c in windows is hard :-(
14:20:32 <parcs> on windows ghci randomly exits with "blocked indefinitely on mvar"
14:21:01 <Jeanne-Kamikaze> windows is blocked on an mvar
14:21:15 <snowylike> why are so many compression algorithms patented?
14:21:54 <Jeanne-Kamikaze> because society is fucked up
14:23:59 <ePak> so, it works in MinGw because it is a POSIX enviroment?
14:28:16 * hackagebot uu-parsinglib 2.7.4.1 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.4.1 (DoaitseSwierstra)
14:28:18 <t7> Jeanne-Kamikaze: because you live in a country with software patents
14:29:10 <lightquake> hackage seems to be down/something again
14:29:30 <glguy_> lightquake: works here
14:29:39 <glguy_> Can anyone else confirm that it's not working?
14:29:49 <lightquake> ok, it's just being really slow for some reason
14:29:50 <parcs> works for me
14:29:58 <lightquake> there we go
14:31:32 <Jeanne-Kamikaze> t7: and you don't ?
14:38:16 * hackagebot memoize 0.4 - A memoization library  http://hackage.haskell.org/package/memoize-0.4 (JesseTov)
14:38:37 <blackdog> hey, spot check - which of these is more readable? https://gist.github.com/4458080
14:39:11 <blackdog> wondering if my mania for applicative is actually helpful
14:39:34 <shachaf> I don't think that's overuse in that case.
14:40:08 <lightquake> the one part that trips me up is that i keep wanting to parse a <$> b >>= c as a <$> (b >>= c)
14:40:39 <shachaf> One could use fmap to avoid that, I guess.
14:40:46 <glguy_> or just (.)
14:41:00 <glguy_> c . a =<< b
14:41:32 <shachaf> That also works.
14:41:44 <nathanfh> blackdog: I'd go with the second, but I've been informed that my style is frustrating to other developers in my office.
14:42:07 <nathanfh> I think it's an idiosyncrasy of the other developers in my office, but whatever.
14:42:22 <nathanfh> They just love do notation for some reason.
14:42:54 <nathanfh> probably so the haskell illiterates in the office can get the gist of things, more or less.
14:44:07 <`^_^v> i am trying to figure out the hashtables package. can anyone give me a hand? http://hpaste.org/80283
14:44:46 <glguy_> `^_^v: try (1 :: Int)
14:45:12 <glguy_> you have to pick a type for the keys
14:47:31 <`^_^v> if i just do that without changing the type signature, i get: Could not deduce (v ~ Int) from the context (Num v). if i change the signature to Maybe Int, i get: Ambiguous type variable `h0' in the constraint: (H.HashTable h0) arising from a use of `H.new'
14:47:59 <glguy_> `^_^v: You want to pick the type of the keys, not the values
14:48:18 <glguy_> Your type signature already says that the values can be any (Num v => v)
14:48:35 <glguy_> but you've given no hint about what the type of the keys of the hashtable are
14:49:02 <glguy_> try only annotating the "1" when you do a lookup
14:49:59 <`^_^v> i still get the latter error in that case
14:53:04 <glguy_> `^_^v: You also need to specify what concrete HashTable you are using
14:53:10 <glguy_> since you're going through the class interface
14:53:53 <`^_^v> yeah, just did that, seems to work now
14:54:46 <glguy_> also, it's an ugly, hard-coded hack that you can use $ with runST
14:55:14 <shapr> Cale: so far, iCalendar does parse google calendar's private url .ics output, but I've still not done anything useful with it.
14:55:19 <`^_^v> seems pretty to me :)
14:55:24 <flappflopp> anyone know of papers comparing non-mathematical to mathematical functions and comparing similarities and differences between math and the non-platonic math-like thing of computer science (which could extend beyond programming). I suppose the haskell IO Action is such an object. What I mean is that in math, a function cannot refer to anything physical, only abstract, whereas to do IO you need to refer to something physical, so t
14:55:25 <flappflopp> interesting side effect
14:55:47 <shapr> flappflopp: last part of your first line was "something physical, so t"
14:56:07 <glguy_> `^_^v: It leads to people not understanding why other, similar Rank-2-using code doesn't work because GHC is hard-coded to special-case the name "$"
14:56:13 <flappflopp> .., so the "calculation" of a function has an  interesting side effect
14:56:28 <hrumph> hi
14:56:42 <hrumph> i realise i may not have really grapsed haskell's evalation strategy
14:56:46 <flappflopp> I wonder if someone has studied these physical function more not in the context of a specific programming language, but in themselves
14:57:06 <gertc> how can i rename id from prelude? hiding did not work out, i need a Main.id and Prelude.id for aeson to work https://github.com/gertcuykens/hoauth2/blob/branch/0.2.6/example/Google/test.hs
14:57:28 <shachaf> gertc: Hiding should be fine.
14:57:37 <srhb> flappflopp: I suppose what is most often done is "imagine" you have a function that takes the whole world as its argument, so that it retains a function.
14:57:41 <srhb> flappflopp: (Which works rather well)
14:57:44 <gertc> i need it for this $(deriveJSON id ''User)
14:57:48 <shachaf> import Prelude hiding (id)
14:57:56 <shachaf> Isn't it simpler to just use a different identifier?
14:58:01 <gertc> then i cant do this $(deriveJSON id ''User)
14:58:16 <gertc> no google returns id field
14:58:17 <ziman> then do import qualified Prelude
14:58:53 <hrumph> Supposing i have a an expression like a || b, is it guaranteed that a|| b will resolve to true if A is true no matter what b is so we wouldn't have to worry if b resolves to _|_  ?
14:59:14 <gertc> but then i need to rename every prelude function right?
14:59:16 <tromp> yes
14:59:22 <gertc> like P.Show ...
14:59:30 <tromp> > True || undefined
14:59:32 <lambdabot>   True
14:59:53 <startling> > False && undefined
14:59:54 <lambdabot>   False
14:59:58 <startling> cool
15:00:03 <gertc> is somthing like this possible ? data User = User { Main.id::Text
15:00:28 <startling> gertc: why not just name it "identifier"?
15:00:53 <flappflopp> srhb: that is still non-mathematical, you are inputting the world, a physical object, and transforming the world, so it's a physical transformation, something which isn't really allowed in math, but I think has interesting properties and I'm interested in whether this might have other applications
15:01:08 <hrumph> >  (Just 1) `mplus` undefined
15:01:08 <gertc> aeson seems to do a one on one comparison, if the name does not match teh incomming jsons it returns Nothing
15:01:10 <lambdabot>   Just 1
15:01:21 <hrumph> ok so it works for mplus too which is good
15:01:38 <hrumph> so the generall idea will work for every function?
15:02:31 <tromp> yes, lazyness evaluates only what is needed
15:02:51 <gertc> i tried data User = User { uid::Text but it really need to be data User = User { id::Text to match google incomming json id field
15:03:01 <startling> tromp: sure, but it still could be strict in both arguments
15:03:13 <startling> hrumph: no, it won't work for every function
15:03:14 <shachaf> gertc: Does the name of your variable have to match the JSON object's key?
15:03:18 * hackagebot Nomyx-Rules 0.0.3 - Language to express rules for Nomic  http://hackage.haskell.org/package/Nomyx-Rules-0.0.3 (CorentinDupont)
15:03:21 <shachaf> gertc: That sounds awful if the library requires it.
15:03:21 <gertc> yes
15:03:27 <gertc> i agree
15:03:31 <flappflopp> computing a math function requires energy, time and memory, you can investigate using methods of algorithmic complexity etc, but what about IO? Is there similar theories to algorithmic complexity etc?
15:03:35 <hrumph> startling: in which cases does it not work?
15:03:54 <tromp> > undefined || True
15:03:55 <lambdabot>   *Exception: Prelude.undefined
15:04:03 <startling> hrumph, seq messes things up
15:04:09 <hrumph> trop that's not an example of the same thing
15:04:10 <startling> but also can make things more efficient
15:04:39 <tromp> "what is needed" depends on what you pattern match on
15:04:55 <tromp> rather than some mathematical sense
15:04:56 <startling> tromp: not necessarily
15:05:04 <startling> tromp: again, seq can mess things up
15:05:26 <tromp> ok; i view seq as matching implicitly:)
15:05:40 <startling> tromp: uh, that's pretty wrong
15:05:44 <Philippa> flappflopp: either the IO is really computational, or it's information-theoretic (in which case it's /partly/ computational) or it's none of compsci's concern how the ballistics of your ICBM actually work
15:05:49 <startling> matching is more like an implicit seq
15:06:14 <hrumph> ok so that's my point is that it won't go evaluating all the arguments at once in order to exploit paralllellism
15:06:26 <Philippa> matching is fundamental demand: seq is the addition
15:06:28 <hrumph> if it did we could get things like division by 0 exceptions at the very least
15:06:56 <Philippa> hrumph: you can only evaluate all the arguments if you know they're finite or the function's strict in them
15:06:58 <hrumph> when we did something like True || (1/0 == 1)
15:07:28 <hrumph> ok think about my above example and imagine that the compiler wanted to do things in an aggressively parallell fasion
15:08:00 <Philippa> hrumph: thankfully that exception wouldn't propagate
15:08:18 <Philippa> the study's been done on that one, IIRC
15:08:19 * hackagebot Nomyx 0.0.3 - A Nomic game in haskell, featuring automatic, machine-executed rules written by the players  http://hackage.haskell.org/package/Nomyx-0.0.3 (CorentinDupont)
15:08:23 <Philippa> rather, the semantics have been defined
15:09:46 <hrumph> > True || (1/0 == )
15:09:48 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
15:09:48 <lambdabot>              with actual type...
15:09:56 <hrumph> oops
15:10:04 <hrumph> > True || (1/0 ==1)
15:10:06 <lambdabot>   True
15:14:08 <dmwit> startling: Hm, I think "pretty wrong" is too strong.
15:14:17 <Lethalman> @hoogle (a -> Bool) -> Stream a -> a
15:14:17 <lambdabot> Did you mean: (a -> Bool) -> IODeviceType -> a
15:14:17 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
15:14:17 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
15:14:22 <startling> dmwit: is it?
15:14:38 <dmwit> Thinking of seq as being a magical pattern match that magically knows all the available top-level patterns (even if the relevant constructors aren't in scope) seems pretty close to the real deal to me.
15:14:52 <startling> dmwit: hmmm, alright
15:15:16 <dmwit> The only exception is that seq also magically forces functions, which you can't do with pattern matching. =)
15:15:34 <startling> good point
15:17:18 <Philippa> I definitely prefer to think of seq as separate from matching
15:17:38 <dmwit> Why is that?
15:17:48 <skp> hi
15:17:53 <dmwit> Hiya, skp.
15:18:09 <skp> how are you? :)
15:18:24 <Philippa> seq-in-terms-of-matching is clearly artificial once you look at functions, matching-in-terms-of-seq is just plain silly and awkward
15:18:52 <Philippa> (and especially: matching should be independent of seq)
15:18:58 <startling> Philippa: yeah, it makes more sense to me that way
15:20:00 <dmwit> As far as rules of thumb go, just having one exception isn't so bad at all. Hell, I could easily see a language addition that added a pattern for forcing functions.
15:20:44 <croikle> gertc: btw, you can import prelude twice: once hiding (id), and once qualified to allow for P.id
15:21:28 <gertc> ok trying
15:22:02 <Philippa> dmwit: sure. But may as well just treat them independently
15:22:16 <Cale> @tell shapr Thanks for the update! It's good to know that already exists so we might avoid having to write it :)
15:22:16 <lambdabot> Consider it noted.
15:22:23 <Philippa> if you're going to make an exception, push it to top level where it won't mess with other features
15:22:40 * dmwit nods agreeably
15:24:42 <hrumph> > (\x y->(True)) undefined undefined
15:24:43 <lambdabot>   True
15:25:42 <gertc> croikle, import Prelude hiding (id) import qualified Prelude as P (id) works
15:25:48 <gertc> thx
15:26:07 <hrumph> ok so it tries to evaluate the function first before even the args, but there must be some kind of backtracking because if the function won't immediately evaluate it has to evaluate the first arg then backtrack to the function to see if it can evaluate just with that and so on.
15:26:18 <croikle> np. I learned that with Repa
15:26:29 <Lethalman> what's the point of Stream when there are lists?
15:26:50 <glguy_> Lists have a []
15:27:53 <dmwit> Lethalman: In Haskell, or other languages?
15:28:20 <dmwit> Some languages distinguish least- and greatest-fixed-points a bit more than Haskell does.
15:28:25 <Lethalman> dmwit, in haskell
15:28:38 <Lethalman> I'm referring to the stream hackage
15:28:39 <dmwit> Okay, then what glguy_ said.
15:29:14 <Lethalman> dmwit, and what's the sense of what he said? there's no real difference?
15:30:01 <dmwit> No, there's a very real difference: streams never end.
15:30:05 <dmwit> (Because they have no [].)
15:30:11 <Lethalman> ah
15:30:14 <Lethalman> ok
15:30:23 <Lethalman> dmwit, so there's no difference between infinite lists and streams?
15:30:27 <Lethalman> :)
15:30:41 <dmwit> Well, the thing is that the type system is guaranteeing that some of your lists are infinite.
15:30:57 <dmwit> You can do some nice things as a result.
15:31:01 <dmwit> Like make a comonad instance.
15:31:06 <glguy_> It's a bit like having Int's when you already had Double
15:35:47 <Lethalman> ok
15:39:53 <startling> what's the trick for using things like X where "type X a = forall s. Y s => s a" in modules that don't have Rank2Types enabled?
15:40:13 <startling> i.e. I'm defining it in a module *with* Rank2Types enabled
15:44:26 <Lethalman> are things like runWriter or runSomething unsafe? or only unsafePerformIO and other unsafeFoo are?
15:45:41 <luite> Lethalman: they're not unsafe
15:46:14 <Lethalman> luite, so I can have a function foo :: Int that for example runs a monad of that kind without any trouble?
15:46:18 <shachaf> runWriter is very safe.
15:46:26 <shachaf> There's nothing unsafe about monads.
15:46:40 <startling> Lethalman: IO is a special monad
15:46:43 <luite> Lethalman: yeah. nothing unsafe about it. it's very similar to fromMaybe, which 'runs' some Maybe monad action
15:46:45 <startling> runWriter is completely pure
15:46:49 <shachaf> "head" and "!!" are less safe than runWriter
15:46:56 <glguy_> but still totally safe :)
15:47:01 <Lethalman> ah
15:47:16 <Lethalman> ok right
15:47:18 <Lethalman> :)
15:47:23 <startling> Lethalman: the big thing is that you can't have Monad m => m a -> a
15:47:35 <startling> Writer a -> a is fine
15:47:39 <mm_freak_> startling: other modules can use it without having to enable anything
15:47:46 <mm_freak_> (the Rank2Types thing)
15:47:53 <Lethalman> ok thanks, good to know :)
15:47:55 <startling> er, those type signatures are very wrong but you get the idea
15:49:21 <startling> mm_freak_: I get Illegal polymorphic or qualified type: X a / Perhaps you intended to use -XRankNTypes or -XRank2Types
15:49:31 <startling> for any X a -> Int -> Spec
15:51:05 <thoughtpolice> startling: do you want ExistentialQuantification?
15:51:29 <startling> no
15:51:48 <mm_freak_> startling: weird
15:52:25 <mm_freak_> it works for regular ADTs both with higher rank polymorphism and existentials
15:54:13 <thoughtpolice> i don't know, this kind of makes sense IMO? if you have a 'type Foo = ...', there's no real way of hiding the RHS when Foo is in scope, is there? the RHS is merely substitued 'in place', so perhaps GHC is right to complain it needs RankNTypes?
15:54:25 <startling> thoughtpolice, lens does it, though
15:54:30 <startling> @src Lens
15:54:31 <lambdabot> Source not found. It can only be attributed to human error.
15:54:31 <thoughtpolice> if you use a function or something that uses a rank2 type, no, you don't need to specify it necessarily
15:54:42 <startling> :t Lens
15:54:43 <lambdabot> Not in scope: data constructor `Lens'
15:55:12 <thoughtpolice> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
15:55:18 <thoughtpolice> hm
15:59:35 <binroot> Hey, can someone help me reduce these 2 lines into 1 line? https://gist.github.com/4458622
16:00:25 <parcs> do theInput <- readFile "input.txt"; putStrLn $ (show.length.lines) (readFile "input.txt")
16:01:01 <binroot> thanks!
16:01:09 <dmwit> readFile "input.txt" >>= putStrLn . show . length . lines
16:01:13 <Philippa> well, my GHC build's hit stage 2
16:01:15 <dmwit> Unless you really meant to read the file twice.
16:01:25 <applicative> readFile "input.txt" >>= print . length . lines
16:01:44 <nlogax> @undo do { theInput <- readFile "input.txt"; putStrLn $ (show.length.lines) (readFile "input.txt") }
16:01:44 <lambdabot> readFile "input.txt" >>= \ theInput -> putStrLn $ (show . length . lines) (readFile "input.txt")
16:01:58 <binroot> thank you dmwit
16:02:16 <binroot> applicative, thanks for reducing it to just print
16:02:39 <applicative> readFile >=> print.lines $ "input.txt"
16:02:52 <applicative> readFile >=> print.length.lines $ "input.txt"
16:08:42 <Lethalman> :t >=>
16:08:45 <lambdabot> parse error on input `>=>'
16:08:48 <Lethalman> :t (>=>)
16:08:50 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
16:28:20 <posluchac> hi
16:29:32 <posluchac> how can I use HASKELL to solve problem from ARTIFICAL INTELIGENCE, like DEPTH TREE SEARCH ,or A*, its hardest than same algorithn in C++ with C++ Standart Library data structures, like FIFO/LIFO/LISTs etc. ?
16:30:53 <applicative> @faq can I use HASKELL to solve problem from ARTIFICAL INTELIGENCE, like DEPTH TREE SEARCH ,or A*, its hardest than same algorithn in C++ with C++ Standart Library data structures, like FIFO/LIFO/LISTs etc. ?
16:30:53 <lambdabot> The answer is: Yes! Haskell can do that.
16:31:27 <posluchac> much easer? what is reason use haskell and not c++ or java?
16:32:19 <cmccann> not using c++ or java is its own reason
16:32:21 <applicative> no curly brackets?
16:32:45 <shachaf> @karma
16:32:45 <lambdabot> You have a karma of 35
16:32:49 <shachaf> I prefer to use java++
16:32:51 <shachaf> @karma
16:32:51 <lambdabot> You have a karma of 34
16:32:58 <applicative> ha
16:32:59 <shachaf> Hmm, it still works.
16:33:06 <applicative> shachaf++
16:33:14 <shachaf> java++ # that karma is all fake anyway
16:33:33 <Philippa> posluchac: just having basic data structures in the libraries doesn't say much for a language
16:33:59 <posluchac> what is the beest? [haskell, clojure, scala]
16:34:45 <Philippa> well, we're likely to be biased in here, no?
16:34:53 <cmccann> no language is the best, all programming languages are awful
16:34:58 <cmccann> just some are more awful than others
16:35:00 <startling> haskell is the beest
16:35:05 <cmccann> but it's not a total order
16:35:35 <posluchac> i think scala has best marketing and web portal a will probably use scala at first place
16:35:48 <Philippa> *shrug* - up to you
16:36:05 <startling> using a language because it has "the best marketing" is kind of strange
16:36:16 <Philippa> I'm not finding it terribly easy to usefully answer your questions
16:36:18 <cmccann> startling, not really, it's actually quite common
16:36:25 <cmccann> saying so directly, however...
16:36:31 <applicative> haskell has the better marketing; the syntax is much better
16:36:32 <startling> cmccann: heh, good point
16:36:32 * Lethalman finds haskell homepage more attractive than one of scala
16:36:38 <startling> me too.
16:36:45 <Philippa> (DFS is staggeringly easy in any language where recursion is natural, A* is arguably trickier without mutability but not by much...)
16:37:00 <blackdog> cmccann: it can be a reasonable one, though. if you have two languages A & B, and you think they're technically about equal, it makes sense to go for the one which has the bigger user community
16:37:09 <blackdog> and marketing has some influence on that.
16:37:21 <startling> does scala have a bigger community?
16:37:30 <cmccann> blackdog, with a bunch of case-dependent caveats that's reasonable
16:37:53 <Philippa> like: you can't pay me enough to deal with the Ruby community in general
16:37:58 <posluchac> ma teacher misis Bielikova from FIIT STU say notginh about haskell, she teach functional programming she says about other languages
16:38:00 <blackdog> startling: i don't know, actually. they seem to have more paid jobs.
16:38:04 <cmccann> (e.g. a community that has very little interest in what you want to use the language for doesn't help much)
16:38:08 <startling> blackdog: heh.
16:38:13 <blackdog> Philippa: curious - why is that?
16:38:28 <applicative> posluchac: I think we all like clojure and scala here.
16:38:31 <blackdog> i have problems talking to rubyists about types, but they're generally relatively friendly to me.
16:38:37 <Philippa> blackdog: several well-documented incidents and the reactions to them
16:38:41 <cmccann> some people around here have very colorful opinions about scala
16:38:52 <blackdog> Philippa: oh. like the porno on the slides incident? :/
16:38:55 <cmccann> Philippa, the ruby community? or rails?
16:38:57 * startling coughedwardkcough
16:39:25 * applicative coughstartlingcough
16:39:51 * startling coughcoughcough
16:39:56 * simpson coughapplicativecough
16:39:57 <sacundim> i have just felt the temptation to make an instance Num a => Num (ReaderT r m a)
16:40:03 <Philippa> cmccann: hrmm, I'm wondering if you're counting some of my comments there?
16:40:10 <sacundim> i don't need to be convinced not to do it, but some consolation would be good :-(
16:40:13 <Philippa> (Scala strikes me as the new C++ - that is not a compliment)
16:40:32 <startling> using any "functional-inspired" language is a huge pain imo
16:40:36 <glguy_> Philippa: for C++ or Scala? :-D
16:40:56 * cmccann has heard scala described as "haskell's type system with java bolted on as a scripting language"
16:41:01 <Philippa> glguy: indeed
16:41:04 <sacundim> my brain is too old for clojure
16:41:14 <Philippa> cmccann: and if it were actually Haskell's system, that might be a compliment :p
16:41:39 <sacundim> every time I look at clojure I can't help but ask why isn't it a scheme dialect
16:41:43 <Philippa> (subtyping is not good for type inference, this hasn't been news for a long time)
16:41:46 <shachaf> sacundim: Is that a special case of instance (Num a, Applcative f) => Num (f a)?
16:41:50 <startling> so would (pipes or conduit) be a good idea for writing a binary parsing library that can seek around files to avoid keeping the whole file in memory?
16:41:56 <sacundim> shachaf: yup
16:42:25 <Philippa> posluchac: I think it's fair to say that Haskell will be the most overtly challenging of the three
16:42:29 <Philippa> eh, oh well
16:43:07 <sclv> clojure is basically a scheme dialect
16:43:11 <cmccann> from what I gather, scala is probably more difficult to understand in full
16:43:20 <sclv> except all true schemes have tail recursion and clojure can't
16:43:21 <sacundim> sclv: if only.
16:43:30 <Philippa> cmccann: sticking to the language and not the common libraries? Yeah
16:43:31 <cmccann> but you can stagger pretty far treating it as a more confusing version of java, or a crippled version of haskell
16:43:36 <startling> sclv: isn't it more common lisp inspired?
16:43:37 <sclv> it also has sillier macros, if i recall?
16:43:49 <sacundim> sclv: except for a ton, ton of differences in syntax
16:44:15 <sclv> oh, right. is that syntax more clisp-like, or just its own thing?
16:44:25 <Lethalman> scala has many rough edges and things that you wouldn't expect by a bunch of syntax and concepts... might be more evil than c++
16:44:40 <sacundim> sclv, both
16:44:56 <sacundim> scala has bounded quantification in its type system, right?
16:45:24 <sclv> the thing that i remember being especially weird is like (let x 10 y 20) where alternate arguments mean different things. is that the sort of thing you're getting at?
16:45:25 <cmccann> scala has like type-level kitchen sinks or something
16:45:44 <cmccann> it sounds way more confusing than Haskell to me D:
16:45:58 <cmccann> (where Haskell means Haskell, not GHC with -XAllTheExtensions)
16:46:05 <sacundim> sclv: i don't remember.  I remember looking at it, and deciding i'm too old to learn another idiosyncratic lisp dialect
16:48:07 <Lethalman> how safe is getting clock time with unsafePerformIO?
16:48:13 <Lethalman> :P
16:48:14 <c_wraith> Scala's type system is more complex than GHC with -XAllTheExtensions
16:48:31 <cmccann> Lethalman, how much do you care whether you get a meaningful value?
16:48:41 <cmccann> if the answer is "not at all" then it's perfectly safe
16:49:09 <Lethalman> cmccann, ok, what do you mean by meaningful value?
16:49:17 <c_wraith> You will probably get a time that was sometime during the execution of the program, if you inspect the value
16:49:36 <cmccann> c_wraith, for seriously? I find that a bit hard to believe, if we're really talking a current GHC with as many non-conflicting extensions as possible
16:49:40 <c_wraith> If you're hoping for more than that, you're at the mercy of GHC's optimizations.
16:49:41 <glguy_> Lethalman: It'll be a clock time, probably one between when you started your program and when you evaluated the thunk
16:49:51 <Lethalman> oh ok, it's due to laziness then
16:50:02 <c_wraith> cmccann: I think you're underestimating how complicated scala actually is
16:50:08 <cmccann> Lethalman, and depending on things and stuff you may get the same value at various points, or not.
16:50:13 <glguy_> Lethalman: and maybe it will be different values or maybe the same
16:50:15 <sclv> we also understand ghc's system
16:50:35 <Philippa> cmccann: Subtyping *really* messes a system up
16:50:38 <sclv> scala doesn't have a full story for how all the features interact
16:50:39 <cmccann> c_wraith, or perhaps I've spent too long staring into the abyss of how complicated things can be with GHC :P
16:50:50 <cmccann> I don't think GHC does either.
16:50:52 <sclv> we "understand" simpified models of it, or bits and pieces
16:51:02 <Lethalman> alright thanks
16:51:05 <cmccann> unless by story you mean "SPJ knows some people working on a paper about it"
16:51:14 <sclv> in theory one can read the outside in paper and pretty much know how it works right now
16:51:38 <sclv> and then the kind stuff just sits on top
16:52:17 <sclv> unification with subtyping will also throw lots of surprises at you
16:52:32 <sclv> my favorite being that its totally legit to look up a string in a set of ints
16:52:40 <sclv> and there's really no way around it
16:52:49 <Philippa> well, that's why you don't use unification with it
16:53:13 <Philippa> you just generate waaaaay too many constraints and conclude there's no Best Solution :p
16:53:17 <sclv> like if you make the lookup function invariant then you can't look up a maybe, because the option type like other adt-alike case classes is represented with subtyping
16:53:33 <sclv> (i'm just talking about scala's solution, not the "right way")
16:53:40 <Philippa> *nod*
16:53:58 <sacundim> subtyping makes my brain hurt
16:54:02 <sclv> that has probably been the source of more scala bugs on my part than anything else in the language
16:54:20 <sclv> with the "bias" of unioning maps being a close second
16:54:25 <cmccann> subtyping can be useful but I don't think I'd want it to be omnipresent in a real type system
16:55:13 <Philippa> ML got in enough trouble with subtyping of signatures and using
16:55:29 <Philippa> (so near and yet thankfully so far from type classes)
16:55:35 <cmccann> there are times that I'd like to have a bit of subtyping in Haskell but I suspect I would much more frequently want to ditch subtyping in scala
16:57:46 <startling> I want to make some code faster. Should I use GHC benchmarking or learn criterion or something else?
16:58:17 <cmccann> startling, scattering strictness annotations haphazardly and then wondering why it doesn't help seems to be one popular strategy
16:58:19 <shachaf> What's GHC benchmarking?
16:58:28 <startling> er, *GHC profiling
16:58:32 <startling> cmccann: heh. D:
16:58:37 <alpounet> criterion + the profiling stuffs from GHC, definitely :)
16:58:58 <cmccann> I'd start with whichever of the two is quickest to get working
16:59:05 <alpounet> criterion lets you benchmark various implementations of something, so that's for comparison, not figuring out how your code behaves (which is profiling)
16:59:18 <startling> alpounet: oh, I see
16:59:19 <cmccann> because there's a decent chance it'll immediately show you something major to fix
16:59:33 <shachaf> Benchmarking and profiling don't solve the same problem.
16:59:35 <startling> does it make it easy to compare old versions of code against newer ones?
16:59:37 <sacundim> startling: do you have unit tests?  I've found it useful to profile those
16:59:43 <startling> sacundim: yeah, I do.
17:00:05 <alpounet> startling, yeah, criterion only asks for a few values to compute, doesn't care how you get them, so you can call two different functions, that's about it :)
17:00:07 <sacundim> i think this fits in with cmccann "quickest thing" suggestion
17:00:17 <startling> alpounet: oh, darn.
17:00:26 <startling> would be cool if it could compare two git versions or whatever
17:00:38 <startling> sacundim: good point
17:00:49 <cmccann> yeah, if you have a limited number of options it's easier to compare them than profile each separately
17:01:23 <cmccann> if you have an implementation and a countable number of ways you could tweak and want to know why it's slow you probably want to profile, not make random changes and hope to optimize via random walk
17:01:53 <startling> what's the cabal flag to install profiling versions of a library?
17:02:03 <alpounet> --enable-library-profiling
17:02:11 <cmccann> startling, the one you set in your config file before you install anything at all
17:02:19 <cmccann> because otherwise you will regret it
17:02:34 <glguy_> startling: If you plan to do profiling you'll probably want to blow away all your cabal installed stuff and start over (with profiling turned on)
17:02:46 <blackdog> so, i might be doing something stupid... i'm trying to build packages with cabal-dev, and i continually get errors like "<command line>: cannot satisfy -package-id attoparsec-0.10.3.0-21d970556da1a375b429009468405cd1
17:02:51 <cmccann> enable haddocks while you're at it, if you don't already
17:02:55 <startling> cmccann: good point
17:02:56 <glguy_> library-profiling: True
17:02:58 <tcrayford> I've run criterion runs over git history before btw. It's good times, especially when you graph it over a lengthy period of time. You can spot perf regressions really obviously
17:03:00 <glguy_> in your ~/.cabal/config
17:03:12 <blackdog> if i then cabal install attoparsec manually, it works fine. but isn't this the point of using cabal-dev, that you can isolate stuff? what am i doing wrong?
17:03:40 <alpounet> well with cabal-dev i tend to reinstall profiling (and normal) versions of libraries quite often, but yes making it True in the cabal config file is a good idea
17:03:44 <cmccann> tcrayford, fun! I've always wanted to try that but have a habit of getting distracted before projects reach the point where it would be meaningful, heh
17:04:38 <tcrayford> cmccann: I do it by default on all my projects these days. At the very least I graph unit test runtime and sloc/etc. It all gets spit into a csv that I can throw at a graphing library or whatever
17:04:42 <alpounet> blackdog, uh? what did you do to get the error? just 'cabal-dev install' ?
17:04:50 <cmccann> also, for mostly pure libraries it might be fun to do something similar with quickcheck, to see where behavior changes
17:04:59 <blackdog> alpounet: with --enable-tests and --enable-benchmarks
17:05:42 <tcrayford> cmcann: I don't think I follow that, can you expound that? Do you mean just graphing quickcheck time? Or running the same set of qc tests across many commits?
17:05:54 <alpounet> blackdog, but just 'cabal-dev install' works?
17:06:13 <blackdog> yep
17:06:23 <blackdog> benchmarks brings in a whole lot of extra libs
17:06:30 <blackdog> criterion and aeson and whatnot
17:06:41 <cmccann> tcrayford, comparing the same functionality between versions and seeing where the results differ
17:07:14 <cmccann> say if you start with a naive but obvious implementation, then you could just have automatic checks for "did behavior change" rather than coming up with specific test cases
17:07:37 <tcrayford> I guess that depends on your project really ;)
17:07:55 <cmccann> yeah, would only be helpful in certain cases, obviously
17:08:02 <tcrayford> those of mine that fit quickcheck with naive implementations, I keep one around for testing purposes only
17:08:17 <tcrayford> (e.g., I have a disk-backed k/v store that I qc against an in memory store)
17:08:30 <cmccann> neat!
17:09:22 <alpounet> blackdog, hmm weird… so it seems it doesn't take care of installing your tests' dependencies? or does it?
17:12:14 <blackdog> alpounet: hang on, i'll get you a full dump
17:12:42 <gayboy69> …...
17:13:06 <blackdog> alpounet: https://gist.github.com/4459013
17:13:33 <blackdog> so, yes, it doesn't install dependencies.
17:14:06 <startling> darn, no obvious low-hanging fruit
17:14:22 <startling> Guess I'll have to dive right into low-level bytestring stuff. :/
17:14:45 <alpounet> blackdog, all the libraries listed as "new dependencies" are the ones only used in benchmarks and tests right?
17:15:37 <blackdog> alpounet: yes.
17:15:47 <blackdog> alpounet: the odd thing is that hastache clearly requires ieee754
17:16:24 <DrCode> hi all
17:16:37 <alpounet> blackdog, so, if you put these guys in your library's reps, not the tests' or the benchs', it builds everything fine I guess? if so, I think you can file a bug on cabal-dev's bug tracker
17:16:41 <DrCode> what is haskell?
17:17:07 <blackdog> alpounet: that's a thought. ok, i'll try that.
17:17:15 <alpounet> err, s/reps/deps/
17:17:29 <DrCode> I am new
17:18:05 <sacundim> DrCode: http://www.haskell.org/haskellwiki/Haskell
17:18:08 <Philippa> Haskell is a programming language - specifically a function, typeful, lazy one
17:18:11 <Philippa> *functional
17:18:18 <Philippa> (unlike my typing)
17:18:22 <blackdog> that seems to work - it's just not doing any more than first-level dependency resolution on things pulled in through benchmarks.
17:18:44 <DrCode> is it cross platform?
17:18:52 <startling> Philippa, you're typing isn't typeful? that sounds serious
17:18:56 <startling> *your
17:19:32 <Philippa> DrCode: Yep. I'm building the Glasgow Haskell Compiler on an Ubuntu ARM system right now, I normally work under Windows
17:19:48 <alpounet> blackdog, alright, I think you can file that bug report :P there seems to be a problem with the propagation of the dependencies for tests/benchmarks
17:20:03 <alpounet> keep me posted about the issue when it's solved, if you remember by that time
17:20:07 <DrCode> wow , nice
17:20:09 <Philippa> you might have trouble targetting a C64, though
17:20:11 <blackdog> alpounet: actually, no - it doesn't work even when i add it to the normal deps list
17:20:30 <blackdog> weird thing: cannot satisfy -package-id monad-par-extras-0.3.2-a53e9353f2df39a702db7ea3c5b5605f
17:20:36 <blackdog> but: cabal-dev/packages-7.6.1.conf/monad-par-extras-0.3.2-a53e9353f2df39a702db7ea3c5b5605f.conf
17:21:42 <startling> oh, I guess throwing some bigger bytestrings at it might help
17:24:22 <duncant_> am I right in thinking that (.) sort of goes backwards? so that ((a (.) b) x) is like (b (a x))
17:24:38 <tcrayford> yeah :(
17:25:09 <alpounet> blackdog, investigating your issue right now. reading https://github.com/creswick/cabal-dev/issues/10
17:25:26 <sacundim> duncant_: you have a preference
17:25:43 <sacundim> it's not "right" or "wrong"
17:25:54 <cmccann> duncant_, ((a (.) b) x) means (((a (.)) b) x)
17:26:00 <cmccann> I don't think that's what you meant
17:26:03 <duncant_> sacundim: yeah, i mean in order of the lexemes in the text, rather than right or wrong backwards
17:26:17 <sacundim> oh
17:26:20 <sacundim> nvm
17:26:29 <mikeplus64> @pl w x = f x . return
17:26:29 <lambdabot> w = (. return) . f
17:27:18 <cmccann> duncant_, anyway, ((f . g) x) = (f (g x))
17:27:29 <mauke> @src (.)
17:27:29 <lambdabot> (f . g) x = f (g x)
17:27:29 <lambdabot> NB: In lambdabot,  (.) = fmap
17:27:55 <cmccann> but the type looks "backwards" in some manner
17:27:57 <mauke> > (show . sqrt) 2
17:27:59 <cmccann> :t (Prelude..)
17:27:59 <lambdabot>   "1.4142135623730951"
17:28:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:29:43 <alpounet> oh wait blackdog, it only fails when it's building the dyn version of hastache. maybe it complains because it wants a dyn version of ieee or smith?
17:30:07 <monochrom> (c <- a) <- (b -> a) <- (c <- b)
17:30:09 <blackdog> alpounet: i have shared turned on in my config, though
17:30:14 <blackdog> and don't have ieee installed yet
17:30:26 <monochrom> err, have a typo :)
17:31:41 <alpounet> blackdog, oh, so it should have tried to install ieee first
17:32:06 <DrCode> if I have c++ libs , can I use them in haskell crossplatform?
17:32:27 <DrCode> dose ghc or jhc make it native
17:32:44 <sacundim> DrCode: http://www.haskell.org/haskellwiki/FFI_Introduction
17:33:07 <sacundim> that deals with C interface, dunno enough C++ to say about it
17:33:51 <sclv> there is no c++ interface
17:33:51 <cmccann> it's like using C while having a rusty iron spike shoved through your eye
17:33:52 <DrCode> ok
17:33:55 <sclv> you wrap your c++ in c
17:33:56 <DrCode> thanku
17:34:18 <DrCode> I see
17:34:27 <DrCode> thanku
17:34:38 <blackdog> alpounet: it seems to work if i turn off dynamic in ~/.cabal/config
17:34:45 <blackdog> alpounet: which is an odd corner-case
17:35:13 <DrCode> the code that ghc or jhc compile is native?
17:35:27 <mauke> DrCode: yes
17:36:14 <mauke> ghci uses some sort of bytecode for interactive use, but it can still load compiled modules
17:37:02 <DrCode> I use haxenme , Is it the same? what are better to use?
17:37:31 <alpounet> blackdog, now, is that a cabal issue or a cabal-dev issue?
17:37:42 <dougransom> @karma
17:37:42 <lambdabot> You have a karma of 0
17:37:57 <dougransom> @karma
17:37:57 <lambdabot> You have a karma of 0
17:38:28 <DrCode> I started project in haxe , so now I got confuzed
17:39:49 <sacundim> DrCode: i had to look up haxenme and haxe.  i hadn't heard before about it, and i wonder how many people in this channel have—though I expect somebody has
17:40:15 <sacundim> hmm, the haxe compiler is written in OCaml
17:40:46 <blackdog> alpounet: still unclear
17:40:51 <DrCode> bcz that I consider to move to haskell
17:42:29 <DrCode> I am looking for xmpp lib and voice chat
17:42:57 <johnw> joeyh: can I have just part of an annexed repository be in "direct mode"?
17:42:59 <DrCode> dose haskell have modules for fast devlope?
17:43:42 <covi> What's the version of GHC included in Haskell Platform 2012.4.0.0 for Mac OS X, 32 bit ? Seems like 7.4.2, but I want a newer
17:43:49 <DrCode> also what about blackberry?
17:44:00 <alpounet> covi, no haskell platform release with a newer GHC, yet
17:44:14 <alpounet> you can install it yourself though
17:44:33 <alpounet> blackdog, sounds like a cabal issue to me, but you can try reporting it at the cabal-dev folks first though
17:45:24 <covi> alpounet: I tried downloading the source. ./configure is the first step and goes well, but sudo make install gives me an error.
17:46:14 <alpounet> covi, http://www.haskell.org/ghc/download_ghc_7_6_1#binaries contains a library for x86 Mac OS X
17:46:50 <geekosaur> covi, if you want a newer ghc, then you dont want the platform...
17:46:53 <blackdog> alpounet: i have a minimal(ish) test case now - https://github.com/mwotton/cabal-dev-bug
17:46:56 <alpounet> covi, http://www.haskell.org/ghc/dist/7.6.1/ghc-7.6.1-i386-apple-darwin.tar.bz2 too
17:48:08 <covi> ghc-7.6.1-i386-apple-darwin.tar.bz2  gives me the source, not a runnable binary installer
17:48:10 <alpounet> s/library/binary/ sorry
17:48:26 * hackagebot highlighting-kate 0.5.3.4 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3.4 (JohnMacFarlane)
17:48:54 <covi> It's not a binary
17:49:17 <alpounet> covi, it's supposed to be a binary, hm
17:50:20 <alpounet> blackdog, alright so we were right, but does the same thing happen with vanilla cabal?
17:51:19 <Igloo> covi: That's a binary distribution. What's the error?
17:53:26 * hackagebot diffdump 0.7.5 - Tools for diffing stdout  http://hackage.haskell.org/package/diffdump-0.7.5 (GregFitzgerald)
17:54:05 <covi> Igloo: I tried again, and it worke!
17:54:08 <covi> *worked
17:54:28 <blackdog> alpounet: no, vanilla cabal works fine
17:54:30 <blackdog> https://github.com/creswick/cabal-dev/issues/85
17:54:40 <covi> SHould I do anything else to complete the installation? ghc --version and ghci still give 7.4.2.
17:54:47 <shachaf> Hmm, so it worked once and didn't work once. You should try it a third time and take the best-of-three.
17:54:57 <shachaf> Anything else other than...
17:55:29 <monochrom> what does "worked" mean? also, check PATH
17:55:47 <monochrom> if using bash, "type ghc" is informative
17:55:55 <covi> monochrom: the make install finishes without errors
17:56:20 <alpounet> thanks
17:56:32 <covi> ghc is hashed (/usr/bin/ghc)   and /usr/bin is in my PATH
17:57:00 <zomg> Hmh, as much as having to do a case Nothing -> return Nothing makes me feel there's a better way to go about it, that just sometimes results in a just as unwieldy looking >>= >>= chain
17:57:12 <monochrom> and your "configure" and "make install" puts the new GHC at... ?
17:57:31 <CoverSlide> JavaScript is awesome
17:58:21 <covi> monochrom: i see..
17:58:31 <blackdog> CoverSlide: more than -some, it's -ful.
17:58:54 <CoverSlide> oh yeah? says who?
17:59:11 <shachaf> This sound like a good topic for our subchannel, #haskell-/dev/null
17:59:14 <shachaf> s
17:59:32 <blackdog> shachaf: indeed *abashed*
18:00:11 <zomg> CoverSlide: javascript is horribly broken or so they tell you. Somehow people still manage to write working software with it =)
18:00:30 <monochrom> are we done yet?
18:00:54 <covi> monochrom: well, should I just rm the old ghc?
18:01:15 <shachaf> If you want to make fun of a language in here, at least make fun of Haskell, so that you're on topic.
18:01:22 <monochrom> I don't know. but re-arranging PATH seems to be safer and cheaper
18:01:46 <CoverSlide> sorry, just testing something out
18:02:23 <shachaf> covi: You can rm the old ghc if you like. I didn't, though.
18:04:35 <covi> Awesome. Thanks for your help!
18:04:51 <covi> I can remove the binary dir now, right?
18:05:00 <monochrom> yes
18:05:04 <shachaf> Instead of removing, try renaming.
18:05:09 <shachaf> Then if it still works you can remove it.
18:05:20 <covi> shachaf: cool
18:05:39 <shachaf> (Hard disk space is free as of 2008.)
18:05:47 <monochrom> not true
18:05:56 <covi> shachaf: no! 128G SSD is running out of space, all the time.
18:06:40 <monochrom> I just saved a hundred dollars by simply deleting several versions of GHC
18:07:03 <covi> lol
18:07:15 <monochrom> but, ah, the US Dollar is free as of 2008, that's what you mean!
18:07:21 <shachaf> monochrom: Did you delete 7.8, 7.10, and 7.12?
18:07:38 <shachaf> monochrom: Yes, that must've been it.
18:07:44 <monochrom> 6.10, 6.12, 7.0.2, 7.0.3
18:22:31 <mercury^> edwardk: Hi. I thought of the following way to make the MonadST instance sane without as much effort as it would currently take: define a data kind dummy (for example data Dummy = Dummy), and define ReaderT' ∷ Dummy → (★ → ★) → ★ → ★, etc.; one can make them instances of some class MonadTrans', with an instance MonadTrans' h ⇒ MonadTrans (h Dummy).  The old transformers are recovered by (type ReaderT = ReaderT' 'Dummy) and so on.  Final
18:23:43 <cmccann> "Final" was an amusingly appropriate place for that to get cut off.
18:24:02 <edwardk> neither monad-st nor mtl currently requires DataKinds. so this is a tough sell ;)
18:24:48 <mercury^> Oh :)
18:25:17 <mercury^> “Finally one can use MonadTrans' in the MonadST instance and everything should be fine, because the kind of a MonadTrans' instance cannot be reproduced.”
18:26:43 <zomg> Is there some common approach used if you want to chain multiple functions that return IO (Maybe Foo)? It seems a bit inconvenient to do x >>= fromJust . fmap y >>= fromJust . fmap z
18:27:16 <edwardk> zomg: you can use MaybeT
18:27:23 <parcs> :t traverse
18:27:25 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
18:27:26 <edwardk> zomg: its not very good for short chains though
18:27:32 <edwardk> there is also that
18:28:14 <zomg> I see, I'll take a look at those. Thanks!
18:29:37 <mercury^> edwardk: another thing: since one can introduce the “hidden” types of a class that uses type-families via ConstraintKinds, but cannot hide the implicit parameters of a class using functional dependencies, would it not be good to implement the transformer classes using type-families and to export the current interface using ConstraintKinds?
18:30:18 <edwardk> constraint kinds are another thing that neither of those packages currently depend upon
18:30:43 <edwardk> mtl far predates constraint-kinds and is compatible with versions of ghc and other compilers back to the stoneage
18:31:24 <mercury^> But are there people actually using very old versions of GHC?
18:31:45 <edwardk> mtl is one of those packages that gets used with other compilers. not just ghc
18:31:59 <mercury^> Alright. :)
18:32:49 <mercury^> It would be a lot of effort for probably little gain to rewrite everything, anyway.  I was just wondering whether it would not be a slightly superior interface in principle.
18:33:43 <covi> @hoogle liftIO
18:33:43 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
18:33:43 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
18:33:43 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
18:33:56 <covi> Control.Monad.Trans is gone?
18:34:01 <gehko> test
18:36:18 <covi> I installed GHC 7.6.1., and I failed to load Control.Monad.Trans
18:37:29 <`nand`> covi: works for me
18:38:07 <covi> `nand`: what should i do... i downloaded the binary for Mac OS and installed.
18:38:31 <`nand`> covi: maybe you're missing the transformers package?
18:38:45 <covi> `nand`: mtl?
18:38:54 <`nand`> mtl depends on transformers
18:38:59 <`nand`> I mean ‘transformers’
18:39:46 <covi> `nand`: http://hackage.haskell.org/package/transformers-0.3.0.0 this, right?
18:40:02 <`nand`> yes
18:40:51 <`nand`> oh
18:40:59 <`nand`> Control.Monad.Trans is exported by mtl
18:41:10 <`nand`> and just re-exports Control.Monad.Trans.Class and Control.Monad.IO.Class
18:42:13 <shachaf> I wish monad transformers weren't terrible. :-(
18:42:17 <shachaf> The idea is so nice.
18:42:46 <covi> Why do you think they're terrible
18:43:44 <cmccann> shachaf thinks most things are terrible
18:44:18 <cmccann> in this case he's right though, monad transformers in general are a one-way ticket to the pit of despair
18:44:25 <cmccann> some common limited uses are fine though
18:44:47 <roadfish> is there an equivalent to the Python "%" for formatting? ... eg "%d %s" % (33,"apples") which gives "33 apples"
18:44:57 <shachaf> Text.Printf.printf
18:45:02 <roadfish> I know of printf ... but I don't want to output right away
18:45:10 <shachaf> > printf "%d %s" 33 "apples" :: String
18:45:12 <lambdabot>   "33 apples"
18:45:17 <roadfish> I just want to build up intermediate results first
18:45:18 <shachaf> printf will give you a string just fine.
18:45:32 <shachaf> Look at the Text.Printf documentation. :-)
18:45:35 <covi> `nand`: I am doing  cable upgrade cabal-install, which seems to be able to solve the problem
18:45:38 <roadfish> ok, so it doen't output
18:45:49 <Nereid> printf does some type trickery to behave both like printf and sprintf.
18:46:05 <`nand`> roadfish: it can.. do both
18:46:05 <cmccann> good old type trickery.
18:46:22 <cmccann> what would we do without type trickery?
18:46:28 <cmccann> besides being able to read type signatures more easily.
18:46:36 <`nand`> wallow in despair, probably?
18:46:45 <cmccann> quite possibly.
18:47:19 <shachaf> cmccann: I'm annoyed at how people talk about how great monads are for avoiding nesting and structuring code and so on -- and they're even right! -- but if you have another monad involved, things get very awkward.
18:47:44 <shachaf> Maybe and Either and so on are good fun to use in a localized way.
18:47:45 <cmccann> well, it's only awkward if you need to interleave them
18:47:54 <shachaf> MaybeT/EitherT/ContT/FreeT/etc. are awful.
18:48:16 <cmccann> not a fan of failure monad transformers, I take it?
18:48:16 <shachaf> When you structure your whole program around a "stack" it's OK.
18:48:18 <`nand`> I was under the impression that either EitherT or ErrorT were horribly broken
18:48:28 <`nand`> but I can't remember which
18:48:36 <shachaf> cmccann: I'm a fan of them in principle.
18:48:44 <cmccann> I'm not!
18:49:34 <cmccann> non-local control flow is bad in general whether you call it "throw", "goto", "call-cc" or whatever.
18:50:17 <cmccann> that sort of nonsense should be as localized as possible in general
18:51:01 <cmccann> and preferably in more structured ways than just saying (Left "WHOOPS") because you don't feel like handling some error condition
18:51:01 <shachaf> Which is why it would be a good thing for monad transformers to be easy to use locally.
18:51:01 <`nand`> looks like ErrorT pulls in Error for ‘fail’, while EitherT doesn't
18:52:17 <cmccann> shachaf, how would that work? not disagreeing, just not seeing what you mean.
18:53:07 <`nand`> cmccann: rather IO (Maybe a) than MaybeT IO a ?
18:53:25 <cmccann> right, but how would you make that easier to use locally?
18:54:03 <`nand`> (that wasn't a reply to your question to shachaf)
18:54:38 <shachaf> I'm not quite sure how it would work. :-) That's why I'm unhappy.
18:54:40 <cmccann> oh, about me not liking failure monads?
18:55:06 <`nand`> about you liking things being as localized as possible
18:55:07 <k0001_> Btw, the errors package helps dealing with EitherT/MaybeT/EitherRT more comfortably → http://hackage.haskell.org/package/errors
18:55:34 <`nand`> oh
18:55:37 <shachaf> I think the other day I was talking about how in some languages you can say things like foo(x) { if (invalid(x)) return blah; if (...) return ...; ... }
18:55:39 <`nand`> MaybeT m a ~ m (Maybe a)
18:55:42 <cmccann> `nand`, well, IO (Maybe a) and MaybeT IO are subtly different in that by using the latter you're always using both
18:55:44 <shachaf> Which is pretty nice for flattening things out.
18:56:01 <`nand`> so you could just runMaybeT those
18:56:02 <cmccann> but in many cases, I don't WANT them mixed 90% of the time
18:56:20 <shachaf> It's perfectly possible to do that in Haskell if you don't have another monad involved, by just using Either.
18:56:29 <dmwit> shachaf: foo x | invalid x = blah | otherwise = ...
18:56:47 <cmccann> if I have a bunch of IO actions and a few that return Maybe types, wrapping it in MaybeT introduces a whole lot of implicit escape points in the control flow
18:56:52 <dmwit> or even foo x | invalid x = blah; foo x = ...
18:56:52 <cmccann> even if I don't use them
18:57:21 <dmwit> ...I may have missed some context here.
18:57:23 <dmwit> apologies
18:57:24 <shachaf> dmwit: Yes, but what if do { b <- check x; when (invalid b) $ i'mdone; ... } ?
18:57:37 <shachaf> Or whatever.
18:57:51 <shachaf> Early return like that is one example of a convenient idiom for flattening out nested things.
18:57:55 <cmccann> and if you're thinking that my objection to MaybeT also applies to other things in Haskell or other languages then you're probably right and I don't like those either
18:57:57 <dmwit> shachaf: use ContT or something ;-)
18:58:03 <shachaf> dmwit: EitherT works fine here.
18:58:13 <dmwit> ContT is cooler
18:58:15 <shachaf> But the issue I was annoyed at is that monad transformers are terrible.
18:58:15 <dmwit> more geek cred
18:59:08 <shachaf> Anyway monads do this sort of "flattening nested computations" thing so well. It's really annoying that when you have one monad, sticking another one on becomes so awkward that it's not worth it.
18:59:09 <dolio> I don't know what you're writing, but nonlocal control flow is essential for staying sane in plenty of programs.
18:59:51 <dolio> Manually plumbing your errors around everywhere in a type inference algorithm would be completely awful, for instance.
18:59:57 <cmccann> being less bad than the alternative doesn't make me like something any more than I would otherwise
19:00:52 <dolio> No, you're just wrong about it being bad in those cases.
19:01:13 <dolio> It is not bad to include type errors in the monad for type checking.
19:01:46 <cmccann> right, ok. I don't have a problem with that as such, true.
19:02:06 <covi> So I have a non-empty list  vs :: [a],  I have  case vs of { [x] -> ... ; x:p@[_] -> ... },  but then I received Non-exhaustive patterns in case error. What's wrong?
19:03:22 <shachaf> covi: Those patterns are handling a list with one element, and a list with two elemets.
19:03:31 <shachaf> You're not handling a list with zero elements or with more than two.
19:03:49 <Rileld> When you use System.Posix.Files.getFileStatus, and the file doesn't exist, it throws some sort of error. Does anyone know how to recover from that?
19:04:45 <BMeph> file error fever...catch it! ;þ
19:07:14 <covi> shachaf: I see!
19:08:30 * hackagebot sym 0.5.1 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.5.1 (AndersClaesson)
19:08:32 * hackagebot sym 0.5.2 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.5.2 (AndersClaesson)
19:09:04 <byorgey> ooh, nice
19:10:41 <roadfish> why was the trigger to make hackagebot output something just now?
19:10:56 <johnw> roadfish: someone did "cabal upload"
19:11:33 <roadfish> ah, so hackagebot is reporting real-time fresh meat
19:11:40 <johnw> real-timeish
19:13:03 <roadfish> so #haskell has two bots (at least). lambdabot and hackagebot. is faybot also a bot?
19:13:16 <johnw> i don't know
19:13:23 <johnw> lambdabot is also in many channels
19:14:40 * shachaf is also a bot.
19:15:20 <`nand`> just as efficient/productive, precise and emotionless?
19:15:59 <johnw> shachaf announces new packages by comparing them to the devil
19:20:57 * cmccann ponders our three bots as a representation of the three fates, tracing the thread of birth, life, and death. hackagebot to announce new code we can use, lambdabot to let us see code being used, and shachaf to tell us not to use things.
19:21:31 <johnw> lol
19:21:51 <shachaf> cmccann: I strive to be maximally efficient, and tell you not to use things before they are even written.
19:27:20 <epta> Is there any Map with (!) with O(1) ?
19:27:58 <shachaf> Data.Map has (!) with O(log n), where n ≤ 64
19:28:07 <shachaf> Therefore it's O(1).
19:28:51 <epta> shachaf: is it a joke or something? :[
19:29:21 <shachaf> It's a joke but it's also pretty much true.
19:29:26 <shachaf> Why do you care about O(1)?
19:31:45 <dolio> IntMap is O(64).
19:33:23 <luite> donri: Map Int is too :p
19:33:34 <donri> what?
19:33:42 <luite> O(64)
19:33:54 <donri> i think you're mistabbing
19:34:03 <luite> oops
19:34:04 <dolio> You can't put more than 2^64 things in Map Int, and access is log n, so 64.
19:34:41 <epta> Wait, so n here is not a number of element but a number of bits?
19:35:02 <shachaf> It doesn't really matter what n is.
19:35:10 <mauke> you can't put more than 2^64 things in [Int], and access is O(n), so O(1)
19:35:13 <luite> epta: it kind of doesn't really matter for big O notation, the number of elements is bounded so lookup is O(1)
19:36:06 <dolio> You can put more than 2^64 things in an [Int].
19:36:06 <shachaf> I think an answer to my question would be helpful here.
19:36:08 <epta> Well, thanks, it's a great news :]
19:36:51 <shachaf> So spine-strict lists are O(1), but lazy lists are O(n).
19:39:38 <cmccann> as a rule of thumb, if you're not really sure what your specific performance requirements are, then Data.Map is fast enough for you
19:39:39 <parcs> so what is Data.Map.Lazy
19:40:09 <shachaf> Value-lazy.
19:40:15 <shachaf> Spine-strict.
19:40:32 <cmccann> if Data.Map turns out to be too slow for some reason, then you now have a specific requirement and you can figure out what will meet those requirements
19:41:33 <parcs> oh right
19:44:38 <hrumph> how come a splitPlaces function is mentioned at http://hackage.haskell.org/packages/archive/split/0.2.1.1/doc/html/Data-List-Split.html but nothing comes up when i search it with hoogle?
19:44:55 <donri> hoogle's db is old
19:45:08 <donri> try hayoo
19:45:15 <shachaf> @hoogle splitPlaces
19:45:15 <lambdabot> No results found
19:45:18 <shachaf> @hoogle splitPlaces +split
19:45:18 <lambdabot> Could not find some databases: split
19:45:18 <lambdabot> Searching in:
19:45:18 <lambdabot>   .
19:45:32 <shachaf> hrumph: Well, it works on online Hoogle.
19:45:42 <shachaf> You have to specify that you want to search "split" with +split
19:46:54 <hrumph> i eant to hoogle http://www.haskell.org/hoogle/, right?
19:47:04 <hrumph> then i put splitPlaces in the search box and got nothing
19:47:17 <shachaf> And what happened after you tried what I said?
19:47:37 <hrumph> +split doesn't return anything
19:47:50 <shachaf> Did you search for splitPlaces +split?
19:48:00 <shachaf> The same thing I typed above, except on the web page. :-)
19:48:09 <hrumph> ok that came up with something
19:48:22 <hrumph> ok how come that returned something but not just splitPlaces?
19:48:59 <shachaf> Because Hoogle only searches standard packages.
19:49:40 <hrumph> so the Data.List.Split package is non-standard?
19:50:10 <shachaf> It will become more standard soon.
19:53:15 <epta> Why (!) from containers-0.5.0.0 was changed for (!!) in last version?
19:53:59 <epta> Oh, sorry, nevermind
19:54:59 <JoeyA> What's a good way to include a text file in a Cabal package, so that it will be built into the binary as a 'String' ?
19:55:28 <JoeyA> @google cabal paths module
19:55:30 <lambdabot> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
19:55:51 <JoeyA> JoeyA: You should try googling first :-)
19:57:42 <JoeyA> Hmm, that link would require bundling a separate text file, I think.
19:58:12 <cmccann> the only way I know of to include an external file as a string is with TH
19:58:22 <cmccann> which would be very easy to do
19:58:44 <parcs> @hoogle factor
19:58:44 <lambdabot> package factory
19:58:44 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment data BlendingFactor
20:00:47 <JoeyA> @hackage file-embed
20:00:48 <lambdabot> http://hackage.haskell.org/package/file-embed
20:00:51 <JoeyA> Looks promising
20:01:13 <cmccann> apparently someone has already done the work of writing the TH for you
20:01:21 <cmccann> oh, snoyman. of course.
20:01:21 <JoeyA> Right
20:01:24 <JoeyA> @hackage command-should-check-if-the-package-actually-exists-but-doesnt
20:01:24 <lambdabot> http://hackage.haskell.org/package/command-should-check-if-the-package-actually-exists-but-doesnt
20:01:30 <cmccann> haha
20:06:13 <DrChaos> hello
20:06:38 <hrumph> how come the take function needs to have an Int instead of just an Integral?
20:06:50 <cmccann> shachaf, hey look you're on the 30-day high score list http://stackoverflow.com/tags/haskell/topusers
20:06:58 <DrChaos> would somebody help me with my pack function? If you can't figure out what it does by reading it, then I think it's junk. But anyways, here goes: http://vpaste.net/YcSjU
20:06:59 <cmccann> :t genericTake
20:07:00 <lambdabot> Integral i => i -> [a] -> [a]
20:07:27 <cmccann> hrumph, also the answer is "for no good reason"
20:07:49 <startling> it could be Num even
20:08:00 <cmccann> what good would that do?
20:08:13 <startling> none. but it *could* be
20:08:16 <hrumph> refresh me on the meaning of num again
20:08:31 <startling> has +, -, * etc
20:08:35 <cmccann> it means you can convert from an Integer and use various arithmetic operations
20:08:35 <startling> also abs and signum
20:08:44 <cmccann> and also abs and signum for murky reasons
20:08:48 <JoeyA> DrChaos: Yeah, I can't tell what that does at a glance (and running it produces a pattern match failure).  What is it supposed to do?
20:09:10 <hrumph> a num could could be a fractional right?
20:09:15 <cmccann> yes
20:09:16 <hrumph> so it wouldn't make sense in a take function at alll
20:09:23 <DrChaos> JoeyA :: it's supposed to take consecutive duplicate elements and put them into a sublist
20:09:40 <startling> @src take
20:09:40 <lambdabot> take n _      | n <= 0 =  []
20:09:40 <lambdabot> take _ []              =  []
20:09:40 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
20:09:42 <JoeyA> > group [1,1,1,2,3,2]
20:09:43 <lambdabot>   [[1,1,1],[2],[3],[2]]
20:09:45 <JoeyA> Like that?
20:09:57 <cmccann> if a function uses integer-ish things you want Integral for contravariant position and Num for covariant position :P
20:09:58 <startling> it just needs Ord and Num
20:09:58 <hrumph> @src genericTake
20:09:58 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:10:17 <startling> wow, lambdabot is surprisingly apologetic today
20:10:36 <JoeyA> DrChaos: Is 'group' what you're looking for?
20:13:56 <hrumph> ok so i've replaced take and drop now with genericTake and genericDrop so i can now use Integeral instead of Int to keep things more general
20:17:23 <startling> the right way to do Take would be with Ord and Monoid. :S
20:18:10 <min|dvir|us> What does => mean?
20:18:12 <JoeyA> hrumph: Well, genericTake is less efficient (barring optimization), since it has to call a method from the 'Integral' dictionary.
20:18:16 <startling> er, Enum too
20:19:01 <JoeyA> min|dvir|us: example: Eq a => a -> [a] -> Bool
20:19:07 <hrumph> joey but if i compile shouldn't the compiler figure it out and result in the same efficiency?
20:19:16 <cmccann> startling, the RIGHT right way would be to have it take a natural number, or something equivalent to one
20:19:20 <JoeyA> Here, this says "a has an Eq instance"
20:19:35 <min|dvir|us> It's like the predicate of a type description?
20:19:53 <JoeyA> So it separates the "context" (instances things have to have) and the rest of the type signature.
20:20:05 <min|dvir|us> Does => only apply to typeclasses?
20:20:19 <startling> cmccann: yeah
20:20:21 <hrumph> joey you said barring optimisation. won't the optimisation be sufficient?
20:20:32 <startling> hrumph: depends
20:20:51 <JoeyA> hrumph: Not if the call doesn't get inlined, which might happen if you have a function calling a function calling genericTake, all of them being generic.
20:20:56 <cmccann> there's really nothing that makes sense for "take" on lists that isn't essentially a natural number
20:21:10 <cmccann> if you also generalize take somehow for non-lists then maybe something else would make sense
20:21:18 <cmccann> but I don't know what it'd be at that point
20:21:32 <JoeyA> min|dvir|us: Basically, yes
20:21:43 <min|dvir|us> JoeyA: yes to what?
20:22:14 <JoeyA> Yes, it applies to typeclass constraints.
20:22:28 <cmccann> I suppose you could think of take as being a special case of zipWith (flip const)
20:23:10 <JoeyA> You'll also see it in typeclass declarations: class Monad m => MonadIO m where
20:23:27 <min|dvir|us> You need to understand that I am not at your point in Haskell.
20:23:48 <cmccann> since [()] is equivalent to Natural
20:23:58 <cmccann> but that's just getting silly
20:24:52 <JoeyA> min|dvir|us: You'll get used to the syntax if you write some programs using it.
20:25:18 <parcs> :k (=>)
20:25:20 <lambdabot> parse error on input `=>'
20:25:26 <JoeyA> For example, suppose you want to make a function that takes a list of items, 'show's them, and concatenates them.
20:25:41 <JoeyA> > let f xs = concat $ map show xs in f [1,2,3]
20:25:43 <lambdabot>   "123"
20:26:00 <cmccann> min|dvir|us, everything to the left of => is a constraint. unless you start turning on experimental language extensions, typeclasses are the only constraints
20:26:10 <min|dvir|us> I see.
20:26:23 <JoeyA> > let f :: [a] -> String; f xs = concat $ map show xs in f [1,2,3]
20:26:25 <lambdabot>   No instance for (GHC.Show.Show a)
20:26:25 <lambdabot>    arising from a use of `GHC.Show.show'
20:27:00 <hpaste> Rileld pasted “MaybeT Monad Transformer” at http://hpaste.org/80289
20:27:02 <Rileld> I'm having trouble getting this code involving MaybeT to work. Thanks for any help :)
20:27:08 <JoeyA> Here, we need the type of our items 'a' to have a Show instance, so we constrain it:
20:27:27 <JoeyA> > let f :: Show a => [a] -> String; f xs = concat $ map show xs in f [1,2,3]
20:27:28 <lambdabot>   "123"
20:27:37 <cmccann> min|dvir|us, you'll also occasionally see "~" as a constraint, such as in GHC's error messages, which means a constraint that two types should be the same
20:28:45 <min|dvir|us> What does 'in' mean there?
20:28:49 <min|dvir|us> Is that a function or a keyword?
20:29:01 <cmccann> keyword
20:29:09 <parcs> it's a keyword in the syntax 'let <bindings> in <expr>'
20:29:10 <cmccann> it's "let ... in ..."
20:29:28 <min|dvir|us> Oh, didn't see the let.
20:29:41 <min|dvir|us> All let has a corresponding in, yes?
20:29:42 <cmccann> > let foo = "foo" in foo ++ "bar"
20:29:43 <lambdabot>   "foobar"
20:30:04 <cmccann> min|dvir|us, in do blocks you can have let without in
20:30:05 <JoeyA> min|dvir|us: Right, except in do notation, where you can just say "let x = 42"
20:30:11 <c_wraith> min|dvir|us: all let *expressions* have a corresponding in.  However, you can have implicitly-scoped lets in do blocks
20:30:19 <cmccann> but that's sort of implicitly making the rest of the do block the part after "in"
20:30:27 <min|dvir|us> Why are those do blocks?
20:30:29 <parcs> and guards, and list comprehensions :)
20:31:09 <parcs> @where lyah
20:31:09 <lambdabot> http://www.learnyouahaskell.com/
20:31:18 <min|dvir|us> Yes, I know, I'm in the middle of it.
20:31:26 <cmccann> ok we're getting the stereophonic explanation thing going on again here
20:31:41 * cmccann bows out since min|dvir|us doesn't really need to hear everything three times
20:31:43 <min|dvir|us> cmccann: if by that you mean multiple people explaining the same thing, it's useful.
20:32:08 <cmccann> even if we say almost exactly the same thing? :P
20:32:45 <min|dvir|us> cmccann: at least to me it's important to understand which statements are isomorphic to each other.
20:34:00 <cmccann> I just worry that it will seem overwhelming. somebody comes in and asks a straightforward question and they kinda get force-fed the answer from three people simultaneously
20:35:10 <cmccann> anyway, sorry to sidetrack things there
20:36:35 <parcs> > let ff | let hh = gg, let gg = () = () in ff
20:36:36 <lambdabot>   Not in scope: `gg'
20:36:36 <lambdabot>  Perhaps you meant `g' (imported from Debug.SimpleReflect)
20:36:39 <min|dvir|us> http://en.wikibooks.org/wiki/Haskell/do_Notation
20:36:45 <min|dvir|us> Reading that, still don't understand the point of do notation.
20:36:53 <cmccann> syntactic sugar.
20:37:00 <min|dvir|us> For what?
20:37:08 <startling> min|dvir|us: lots of things
20:37:19 <cmccann> it doesn't actually do anything (ha, ha) that you can't write as an expression.
20:37:20 <JoeyA> readLn >>= \a -> readLn >>= \b -> print (a+b)
20:37:31 <cmccann> it's just a more convenient way to express some things
20:37:32 <JoeyA> versus do a <- readLn; b <- readLn; print (a+b)
20:37:58 <min|dvir|us> So do notation only deals with side effects?
20:38:21 <cmccann> it works for any monad, most of which don't involve "side effects" in any usual sense
20:38:34 <min|dvir|us> OK, so only monads?
20:38:38 <startling> min|dvir|us: yeah.
20:38:40 <cmccann> yes
20:38:47 <min|dvir|us> OK, so I haven't gotten to that point yet. :)
20:38:53 <cmccann> it's a syntax for monads, nothing more or less
20:38:56 <JoeyA> It deals with a Monad, which is kinda like a burrito, but a lot of tutorials have been written about it.  (you need to learn the #haskell in-jokes, too)
20:39:00 <startling> min|dvir|us: anything you do with do notation can be done with >>=
20:39:08 <startling> min|dvir|us: >>= is in a typeclass called Monad
20:39:22 <min|dvir|us> startling: this makes some sense.
20:39:41 <flebron> consider it similar to the ways of eliminating callback hell in js
20:39:56 <flebron> at some point, you get tired of writing f(function() { ... (function() { ...
20:40:00 <startling> flebron: it's much more general than that, though
20:40:05 <flebron> likewise, at some point haskellers got tired of writing >>= \x -> ...
20:40:13 <flebron> and so they started writing "x <- ..."
20:40:29 <cmccann> > do { x <- [1 .. 5]; guard (odd x); replicate x (show x) }
20:40:31 <lambdabot>   ["1","3","3","3","5","5","5","5","5"]
20:40:32 <flebron> sure, it's much more general
20:41:14 <cmccann> @undo do { x <- [1 .. 5]; guard (odd x); replicate x (show x) }
20:41:14 <lambdabot> [1 .. 5] >>= \ x -> guard (odd x) >> replicate x (show x)
20:41:16 <parcs> > let ff | let hh = gg; gg = () = hh in ff
20:41:17 <lambdabot>   ()
20:42:02 <startling> min|dvir|us: don't fall for the trap of thinking of Monad as special, it's just a typeclass that's useful for a lot of different kinds of things
20:42:22 <min|dvir|us> Unfortunately I don't have as clear an understanding of typeclasses or types as I'd like.
20:42:27 <tac> Monads are just a special kind of algebraic thing. Like groups. Or vectorspaces
20:42:38 <min|dvir|us> Is return a function or keyword?
20:42:42 <cmccann> function
20:42:45 <cmccann> :t return
20:42:46 <lambdabot> Monad m => a -> m a
20:42:57 <cmccann> > return 5 :: [Int]
20:42:58 <lambdabot>   [5]
20:43:01 <flebron> you can think of them as interfaces
20:43:03 <cmccann> > return 5 :: Maybe Int
20:43:05 <lambdabot>   Just 5
20:43:28 <min|dvir|us> :src return
20:43:30 <flebron> if a type is a member of some typeclass, you have certain assurances about some functions that work with it
20:43:32 <min|dvir|us> @src return
20:43:32 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:43:36 <cmccann> @src Monad
20:43:36 <lambdabot> class  Monad m  where
20:43:36 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
20:43:36 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
20:43:36 <lambdabot>     return      :: a -> m a
20:43:36 <lambdabot>     fail        :: String -> m a
20:43:47 <parcs> @src [] return
20:43:47 <lambdabot> return x    = [x]
20:43:51 <flebron> so if you know F is an instance of Functor, then you know fmap works on things of type F a
20:43:52 <JoeyA> min|dvir|us: A typeclass is, in a sense, something you can say about a type.
20:43:52 <parcs> @src Maybe return
20:43:52 <lambdabot> return              = Just
20:43:52 * cmccann forgets how to get the source for--yeah, that
20:44:06 <JoeyA> For example, "Eq a" means you can compare two values of type a using ==
20:44:07 <min|dvir|us> JoeyA: so why not just say it in a type?
20:44:19 <flebron> because the type doesn't know about all possible interfaces
20:44:23 <flebron> suppose you make a type Char
20:44:42 <flebron> 10 years later, someone says "Hey, I can actually print Chars!, Char is a type of 'Showable' thing!"
20:44:46 <JoeyA> min|dvir|us: You could just say it in the type: Eq a -> a -> a -> Bool
20:45:02 <JoeyA> We would have to redefine Eq to be a record holding a function (==) :: a -> a -> Bool
20:45:12 <flebron> instead of having to change what Char is, to now have it be Showable, you say how Char is an instance of Showable (in Haskell it's just Show, not Showable)
20:45:12 <xpika> 3
20:45:14 <JoeyA> And callers would have to pass this Eq record explicitly.
20:45:25 <JoeyA> With a typeclass, the compiler passes that record automatically.
20:45:58 <hrumph> is there a generic monad fold function?
20:46:03 <min|dvir|us> So a typeclass basically just defines 'special' functions that can apply to it?
20:46:12 <cmccann> hrumph, in what sense?
20:46:13 <hrumph> sorry for a monadplus
20:46:15 <hrumph> monadplus
20:46:25 <hrumph> folding on the mplus operator
20:46:28 <parcs> hrumph: msum
20:46:29 <JoeyA> hrumph: Data.Traversable.mapM, perhaps?
20:46:31 <hrumph> msum
20:46:33 <JoeyA> Or mapM_
20:46:36 <hrumph> sounds good
20:46:38 <cmccann> :t msum
20:46:39 <lambdabot> MonadPlus m => [m a] -> m a
20:46:41 <hrumph> i'll check that out
20:46:46 <flebron> min|dvir|us, yes
20:46:53 <startling> min|dvir|us: yep
20:46:59 <flebron> it's an interface, if you wish. it defines abilities of a type.
20:47:00 <cmccann> > msum [Nothing, Just 'a', Nothing, Just 'b', Just 'c', Nothing]
20:47:02 <lambdabot>   Just 'a'
20:47:04 <min|dvir|us> OK, this is making a lot more sense. What makes a function special?
20:47:12 <flebron> you can add '-able' to a lot of things. T is an instance of Show? T is Showable.
20:47:13 <c_wraith> min|dvir|us: they don't need to be functions, actually
20:47:15 <startling> min|dvir|us: it's declared in a typeclass defiition
20:47:17 <c_wraith> @srouce bounded
20:47:17 <lambdabot> bounded not available
20:47:21 <c_wraith> @srouce Bounded
20:47:21 <lambdabot> Bounded not available
20:47:26 <c_wraith> darn.
20:47:43 <c_wraith> class Bounded a where minBound :: a ; maxBound :: a
20:47:44 <flebron> srouce?
20:47:48 <cmccann> haha
20:47:50 <c_wraith> spleling is hard
20:47:50 <flebron> lambdabot is forgiving
20:48:03 <hrumph> > mconcat [Nothing, Just 'a', Nothing, Just 'b', Just 'c', Nothing]
20:48:04 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
20:48:04 <lambdabot>    arising from a use o...
20:48:07 <hrumph> oh
20:48:19 <min|dvir|us> So practice people almost never make new typeclasses?
20:48:26 <cmccann> @fqa can haskell fix spelling errors?
20:48:26 <lambdabot> Maybe you meant: faq ft
20:48:29 <cmccann> bah
20:48:34 * cmccann shakes his fist
20:48:35 <startling> cmccann: hilarious
20:48:41 <startling> min|dvir|us: it depends
20:48:49 <cmccann> joke status: ruined
20:48:51 <startling> min|dvir|us: you can make one whenever you want, but you don't often need them
20:49:07 <flebron> the same frequency as making interfaces :p
20:49:20 <min|dvir|us> flebron: interface in Java?
20:49:30 <DrChaos> JoeyA :: ok err...I'll have to go back to the drawing board on the pack function, which should equal the group function if I can make it work
20:49:34 <flebron> min|dvir|us, yes
20:49:48 <cmccann> the analogy to interfaces is not entirely accurate, mind
20:49:55 <cmccann> but they are similar
20:49:58 <min|dvir|us> Aren't those completely useless other than to specify a type constraint?
20:50:02 <flebron> well, if interfaces could also define variables that the type must provide
20:50:15 <flebron> min|dvir|us, completely useless other than to {very useful thing}? yes
20:50:21 <cmccann> flebron, and static methods... :P
20:50:30 <flebron> sure :p
20:50:59 <DrChaos> pack (x:y:xs) = x' x y xs
20:51:00 <DrChaos>               where x' x y xs | x == y = x : y
20:51:05 <DrChaos> is that a good start?
20:52:09 <DrChaos> wait, no, it's not
20:52:14 <hrumph> i just realised that mconcat and msum behave differently for Monoid [Char] and Monad []
20:52:38 <cmccann> well the MonadPlus and Monoid instances behave differently, so yes
20:53:31 <cmccann> if memory serves me the MonadPlus instance is also a monoid, but the Monoid instance couldn't work for MonadPlus
20:53:49 <min|dvir|us> Does > take :: statements?
20:53:58 <min|dvir|us> > as in the in-channel interpreter.
20:53:59 <lambdabot>   <hint>:1:4: parse error on input `in'
20:54:37 <cmccann> lambdabot accepts a peculiar mixture of things that you can do with GHCi
20:54:52 <cmccann> you can also /msg lambdabot and try things out all you want
20:55:31 <flebron> cmccann, there's also the slight issue of interfaces not existing for something that isn't a type, like a type ctor
20:55:44 <min|dvir|us> cmccann: thank you. :)
20:56:12 <cmccann> flebron, yes, though in most cases the language itself can't express that idea as such
20:56:20 <cmccann> unlike e.g. static methods
20:57:44 <DrChaos> @let pack (x:y:xs) = (if x == y then x : y : pack xs else [] : pack xs) in pack [1,1,1,2]
20:57:44 <lambdabot>   Parse error: in
20:57:58 <flebron> well perhaps it would be something like an interface for templates in C++
20:58:05 <gwern> @quote templates
20:58:05 <lambdabot> Fanael says: yeah, C++ templates are a large step in the right direction, if the "right direction" means back.
20:58:30 <flebron> :p
20:59:33 <cmccann> @quote C++
20:59:33 <lambdabot> psychobot says: let's eat grandma vs let's eat grandma aka interfacing with a guard
20:59:51 <cmccann> that did not work as intended.
21:00:15 <c_wraith> it uses regexes
21:00:27 <cmccann> yeah.
21:00:32 <cmccann> that occurred to me after the fact.
21:00:48 <c_wraith> @quote c\+\+
21:00:48 <lambdabot> qwe1234 says: haskell type classes smell like c++ concepts.
21:01:15 <hrumph> they're more like those things in java can't remember what they're called
21:01:34 <hrumph> things that got a lot of unfair hate
21:01:39 <cmccann> heh, the concepts quote is remarkably relevant.
21:02:56 <c_wraith> and yes, C++ concepts have (in the theoretical reality in which they're part of the language) a lot in common with type classes
21:03:04 <hrumph> the interfaces in java
21:05:04 <DrChaos> well crud
21:05:40 <DrChaos> why wouldn't pack (x:y:xs) = if x == y then x : y : pack xs else [] : pack xs -- [] : closes the sublist, I think
21:05:45 <JoeyA> hrumph: generics?
21:05:47 <DrChaos> why wouldn't it work?
21:05:58 <DrChaos>     No instance for (Num [a0])
21:06:03 <flebron> i think the generic list had the issue of non covariance?
21:06:05 <hrumph> joey i think they're just called "interfaces"
21:06:32 <hrumph> they just speicified types, although they didn't have default implentations
21:06:42 <flebron> (a subtype of b does not imply list<a> subtype of list<b>)
21:06:57 <c_wraith> DrChaos: the problem is in your else branch, probably.
21:07:19 <c_wraith> DrChaos: you probably don't want to be prepending an empty list, because that messes up types a lot
21:07:20 <DrChaos> huh? how do you start generating a list of lists inside of a function?
21:07:28 <hrumph> typeclasses are like java interfaces but with the option  of default implementations
21:08:08 <c_wraith> DrChaos: well, what's the type you want for pack?
21:08:30 <hrumph> it was the java answer to multiple inheritance which the java designers didn't like
21:09:18 <hrumph> it was a good idea but it got a lot of flak from the peanut gallery
21:10:17 <hrumph> not that anyone gives a crap about java anymore but they got some unfair flak
21:10:37 <hrumph> that's what happens when you are ahead of your time
21:14:12 <hrumph> ok time to change from monoids to monads...
21:20:59 <tac> a monad is a kind of monoid though :O
21:21:20 <startling> shhhh
21:21:21 <hrumph> mathematically but haskell def is different
21:21:46 <min|dvir|us> How is a monad a monoid?
21:21:51 <hrumph> monadplus
21:21:54 <parcs> > 0 - 1 :: Int8
21:21:55 <lambdabot>   -1
21:22:01 <hrumph> we both meant monadplus
21:22:16 <hrumph> i keep saying monad too when i mean monadplus
21:22:23 <parcs> > 0 - 1 :: Word8
21:22:24 <lambdabot>   255
21:22:33 <min|dvir|us> I still don't understand.
21:22:50 <hrumph> the mzero element is the identity of the monoid
21:23:11 <min|dvir|us> How are these used in Haskell?
21:24:09 <flebron> well, interfaces can let you know things about a type
21:24:23 <flebron> there are some things that the language cannot express, and are simply conventions
21:25:10 <min|dvir|us> Can you give me an example MonadPlus use case?
21:25:19 <parcs> > 0x100 .|. 255 :: Word16
21:25:21 <lambdabot>   511
21:25:23 <hrumph> min|dvir|us: yes
21:25:34 <flebron> damned connection. anyway.
21:25:34 <flebron> but what you don't know, is that this (==) defines an equivalence relation
21:25:37 <hrumph> sum of errormessages or Nothings
21:25:41 <hrumph> you want the first error message
21:25:51 <flebron> this (==) being an equivalence relation isn't specified in the type, it is outside of the language
21:25:58 <hrumph> so sum your Maybes using msum if you want the first error message
21:26:20 <flebron> a lot of typeclasses have these "extra-language" restrictions
21:26:37 <flebron> one of those, is "things which can act like a monoid", known as the typeclass Monoid
21:26:38 <hrumph> OTO if you use mconcat (using the monoid class) you'll end up summing the wrapped strings rather than getting the leftmost one in the sum
21:27:00 <flebron> the language will not stop you from making something an instance of Monoid, which isn't really a monoid
21:27:11 <hrumph> min|dvir|us: i just discovered this exciting fact tonight a few minutes ago
21:27:18 <flebron> say, string concatenation, but with the mzero (or unit, in math talk), being "abc"
21:28:41 <hrumph> min|dvir|us: i haven't really learned about tehse yet but with msum there are sume control functiosn like guard and stuff which are useful to
21:29:16 <flebron> it is pretty difficult, i'd say, to understand what a monad is in terms of mathematics
21:29:46 <flebron> it already is difficult to understand what a monoid object is (not just a monoid, but the categorical generalization of it)
21:30:42 <hrumph> a monoid object isn't hard to understand because there are some very trivial examples, such as set union with empty set as the identity
21:30:45 <hpaste> Rileld pasted “Simplified MaybeT Problem” at http://hpaste.org/80290
21:30:50 <hrumph> string concatenation being another
21:30:57 <Rileld> If anyone could help me use MaybeT I'd really appreciate it. My issue is here: http://hpaste.org/80290
21:30:58 <flebron> that's a monoid
21:31:08 <flebron> a monoid object in a monoidal category is a bit harder
21:31:14 <hrumph> ok
21:31:21 <hrumph> that i don't know about and probably never will
21:31:42 <startling> haha
21:31:44 <flebron> you can take a look at the definition here: http://en.wikipedia.org/wiki/Monoidal_category
21:32:04 <hrumph> since i don't know category theroy i won't understand it so no thanks
21:32:08 <flebron> it took me some time, not because of haskell but because of categories in general, to get used to commutative diagrams and what they "mean"
21:32:53 <sw2wolf> :t runMaybeT
21:32:55 <lambdabot> Not in scope: `runMaybeT'
21:35:08 <hrumph> if i wanted to learn category theory would good experience with haskell help me at all?
21:36:54 <hrumph> probably not
21:37:29 <zxq9> probably studying a bit of category theory, being confused, trying something practical that requires it, and then going back for a re-look would be the fastest way to get your head around it.
21:39:16 <hrumph> if i knew category theory would it help me with haskell?
21:40:00 <simpson> AFAICT there's not *that* much overlap.
21:40:30 <startling> just naming afaict
21:40:49 <hrumph> but the inspiration must have come from it otherwise the naming wouldn't be what it is
21:41:03 <hrumph> so the language designers definitely benefitted
21:41:06 <min|dvir|us> > let collatz n = if n == 4 then [] else n:collatz (if n `mod` 2 == 0 then n/2 else n*3+1) in collatz 4
21:41:07 <lambdabot>   Ambiguous type variable `a0' in the constraints:
21:41:07 <lambdabot>    (GHC.Real.Fractional a0...
21:41:14 <min|dvir|us> What's wrong with that?
21:41:16 <hrumph> its whether me as a language user could also benefit the way they did
21:43:48 <min|dvir|us> flebron: you still around?
21:44:13 <flebron> YEAH
21:44:16 <flebron> *yeah, sorry, caps
21:44:30 <min|dvir|us> Could you help me with a couple of lines up?
21:45:02 <flebron> well, i don't know if this is the issue, but you're doing both mod and /
21:45:20 <flebron> / wants a Fractional
21:45:23 <flebron> mod wants an Integral
21:45:27 <flebron> perhaps you want div
21:45:32 <min|dvir|us> Oh, that makes sense.
21:45:41 <min|dvir|us> > let collatz n = if n == 4 then [] else n:collatz (if n `mod` 2 == 0 then n `div` 2 else n*3+1) in collatz 4
21:45:42 <lambdabot>   []
21:45:49 <min|dvir|us> > let collatz n = if n == 4 then [] else n:collatz (if n `mod` 2 == 0 then n `div` 2 else n*3+1) in collatz 10
21:45:50 <lambdabot>   [10,5,16,8]
21:45:56 <min|dvir|us> Sweet. :)
21:45:59 <flebron> :)
21:46:01 <min|dvir|us> > let collatz n = if n == 4 then [] else n:collatz (if n `mod` 2 == 0 then n `div` 2 else n*3+1) in collatz 100
21:46:02 <lambdabot>   [100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8]
21:46:14 <flebron> one example of lazyness being useful to define things clearly
21:48:30 <min|dvir|us> Is there a better way to write this?
21:48:32 <min|dvir|us> > let collatz n = n:if n == 1 then [] else collatz (if n `mod` 2 == 0 then n `div` 2 else n*3+1) in collatz 100
21:48:34 <lambdabot>   [100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1]
21:49:00 <min|dvir|us> Is that clear to a trained Haskell eye?
21:49:05 <simpson> > let collatz = iterate (\n -> if mod n 2 == 0 then div n 2 else n * 3 + 1) in collatz 1023
21:49:06 <lambdabot>   [1023,3070,1535,4606,2303,6910,3455,10366,5183,15550,7775,23326,11663,34990...
21:49:56 <min|dvir|us> > let collatz = iterate (\n -> if mod n 2 == 0 then div n 2 else n * 3 + 1) in collatz 100
21:49:57 <lambdabot>   [100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,...
21:50:13 <min|dvir|us> WTF?
21:50:24 <flebron> what about it?
21:50:34 <min|dvir|us> "..."
21:50:36 <flebron> it computes f(x), f(f(x)), f(f(f(x))), ....
21:50:43 <min|dvir|us> Oh, gotcha.
21:50:44 <flebron> lambdabot won't print everything
21:50:59 <min|dvir|us> What is -> doing here?
21:51:09 <flebron> it is part of the lambda abstraction syntax
21:51:10 <simpson> It's a lambda.
21:51:18 <flebron> what you know in js as function(x) { foo }, in haskell it's \x -> foo
21:51:20 <min|dvir|us> Oh, haven't gotten there yet. :)
21:51:21 <simpson> > (\x -> x + 1) 41
21:51:22 <lambdabot>   42
21:51:30 <min|dvir|us> flebron: ahh, wonderful.
21:51:34 <flebron> (function(x) { return x + 1; })(41)
21:51:56 <flebron> note there's an implicit "return" (if that makes sense) in haskell, since you must always have a value in your function
21:52:13 <flebron> the value may be something to indicate a lack of value (like Nothing in Maybe), but it's still a value of some type
21:52:16 <min|dvir|us> Right, it's like a Python lambda.
21:52:20 <flebron> sure
21:52:33 <flebron> i think mozilla at one point implemented something like function(x) x+1
21:52:53 <min|dvir|us> @src iterate
21:52:53 <lambdabot> iterate f x =  x : iterate f (f x)
21:53:00 <min|dvir|us> Noice.
21:53:06 <mauke> function foo(x) x + 1;  // should work in firefox
21:56:27 <min|dvir|us> @src /
21:56:27 <lambdabot> Source not found. You type like i drive.
21:57:42 <min|dvir|us> > 1 /= 2
21:57:43 <lambdabot>   True
21:57:47 <min|dvir|us> > 1 /= 1
21:57:48 <lambdabot>   False
21:57:51 <min|dvir|us> > 1 /= 0
21:57:52 <lambdabot>   True
21:58:30 <min|dvir|us> > even 2
21:58:32 <lambdabot>   True
21:59:06 <zxq9> hrumph: Category theory would help you with programming in general, but not because of syntax or anything, rather because to really get it you need to understand what underlies it -- which is a huge slice of math in general
21:59:19 <min|dvir|us> > let collatz n = iterate(\n -> if n `even` then n `div` 2 else n*3+1) in collatz 100
21:59:21 <lambdabot>   <hint>:1:43: parse error on input `then'
21:59:31 <min|dvir|us> > let collatz n = iterate(\n -> if even n then n `div` 2 else n*3+1) in collatz 100
21:59:33 <lambdabot>   No instance for (GHC.Show.Show (a0 -> [a0]))
21:59:33 <lambdabot>    arising from a use of `M215...
21:59:39 <zxq9> hrumph: If you understand the bajillion pieces underneath, then category theory helps you by abstracting them into chunks and formalizing how chunks can interact.
21:59:57 <min|dvir|us> > let collatz n = iterate(\n -> if even n then n `div` 2 else n*3+1) n in collatz 100
21:59:58 <lambdabot>   [100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,...
22:00:09 <min|dvir|us> > let collatz n = iterate(\n -> if even n then n `div` 2 else n*3+1) n in collatz 10
22:00:10 <lambdabot>   [10,5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,...
22:00:43 <flebron> indeed, i think of category theory more as a language of patterns than as a specific topic, like i'd consider topology
22:01:09 <min|dvir|us> > let collatz n = iterate \n -> if even n then n `div` 2 else n*3+1 n in collatz 10
22:01:10 <flebron> "let's call {this thing that we all talked about frequently but just didn't name} a functor"
22:01:10 <lambdabot>   can't find file: L.hs
22:01:19 <zxq9> I think of category theory as a sort of meta-math
22:02:05 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in collatz 10
22:02:06 <lambdabot>   [10,5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,...
22:02:18 <simpson> min|dvir|us: The lambda arrow associates really far; you need the parentheses.
22:02:19 <zxq9> Which, incidentally, is how most functional programs wind up getting written by the end of a project, but not usually because the authors set out to write a program "by the principles of category theory"
22:02:23 <mauke> the technical term is "abstract nonsense"
22:02:34 <zxq9> lol
22:02:38 <min|dvir|us> simpson: lambda's more important than function application?
22:02:42 <mauke> or "generalized abstract nonsense"
22:03:37 <simpson> min|dvir|us: In that example, it gobbled up everything, including "in".
22:04:10 <flebron> it's the opposite, min|dvir|us, -> bound very loosely
22:04:26 <mysticc> I have a function which returns m a, how do you get to return tm m1 a where tm is transformer of m? I mean what function should I look for here?
22:04:31 <flebron> application binds tightly, f x y is (f x) y, not f (x y). \_ -> gobbles up whatever it can find
22:04:53 <mauke> mysticc: lift
22:04:59 <min|dvir|us> flebron: that will always confuse me.
22:05:18 <mysticc> :t lift
22:05:20 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
22:06:04 <mysticc> mauke: No it is different. Suppose I have a function which returns Maybe a, How do I use it say inside MaybeT m
22:06:40 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in count $ filter (>=15) [ collatz n | n <- [0..100] ]
22:06:41 <lambdabot>   Not in scope: `count'
22:06:41 <lambdabot>  Perhaps you meant one of these:
22:06:41 <lambdabot>    `BS.count' (impor...
22:07:04 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in length $ filter (>=15) [ collatz n | n <- [0..100] ]
22:07:04 <mauke> :t MaybeT
22:07:05 <lambdabot>   No instance for (GHC.Num.Num [a0])
22:07:05 <lambdabot>    arising from the literal `15'
22:07:05 <lambdabot>  Possib...
22:07:06 <lambdabot> Not in scope: data constructor `MaybeT'
22:07:59 <hrumph> what's the equivalent of MaybeT for Either?
22:08:07 <hrumph> is there an EitherT i can use?
22:09:18 <min|dvir|us> @src takeWhile
22:09:18 <lambdabot> takeWhile _ []                 =  []
22:09:18 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
22:09:18 <lambdabot>                    | otherwise =  []
22:09:31 <hrumph> oh i found it
22:09:33 <Jafet> @hoogle EitherT
22:09:33 <lambdabot> package EitherT
22:09:48 <roconnor> is Elm typed?
22:09:49 <hrumph> no its control.monad.either
22:10:35 <min|dvir|us> > let collatz n = takeWhile (/=2) $ iterate (\n -> if even n then n `div` 2 else n*3+1) n in filter (>=15) [ length $ collatz n | n <- [0..100] ]
22:10:38 <lambdabot>   mueval-core: Time limit exceeded
22:10:39 <johnw> hehe, searching for "haddock images" certainly didn't return what I was expecting
22:10:45 <johnw> i guess there are a lot of images of haddock on the Web
22:10:56 <min|dvir|us> > let collatz n = takeWhile (/=2) $ iterate (\n -> if even n then n `div` 2 else n*3+1) n in collatz 100
22:10:57 <lambdabot>   [100,50,25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4]
22:11:43 <min|dvir|us> > let collatz n = takeWhile (/=2) $ iterate (\n -> if even n then n `div` 2 else n*3+1) n in filter (>=15) [ length $ collatz n | n <- [1..100] ]
22:11:44 <lambdabot>   [15,18,16,16,19,19,22,110,17,17,17,105,25,20,20,20,33,108,28,15,15,15,103,2...
22:12:20 <min|dvir|us> @src map
22:12:20 <lambdabot> map _ []     = []
22:12:21 <lambdabot> map f (x:xs) = f x : map f xs
22:13:33 <pnkbst> onoes, gratuitous quit messaging!
22:15:40 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ n | n <- [1..100], length $ takeWhile (/=2) $ collatz n >= 15 ]
22:15:42 <lambdabot>   Couldn't match expected type `[a0]'
22:15:42 <lambdabot>              with actual type `GHC.Type...
22:16:28 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ n | n <- [1..100], 15 <= length $ takeWhile (/=2) $ collatz n]
22:16:29 <lambdabot>   The first argument of ($) takes one argument,
22:16:29 <lambdabot>  but its type `GHC.Types.Bool...
22:16:51 <min|dvir|us> @src $
22:16:51 <lambdabot> f $ x = f x
22:16:53 <hrumph> i ipmorted Control.Monad.Either but its not working
22:17:04 <hrumph> i'm getting Could not find module `Control.Monad.Either'
22:17:05 <min|dvir|us> This one I don't understand.
22:17:36 <flebron> heh
22:17:39 <mauke> min|dvir|us: 15 <= length is not a function
22:17:41 <flebron> it doesn't do anything
22:17:47 <flebron> it just has low preference, like \_ ->
22:18:02 <flebron> so "essentially", a $ b means ( a )  ( b )
22:18:10 <flebron> s/preference/precedence/
22:18:43 <min|dvir|us> mauke: how do I make it a function? Would I use filter?
22:18:53 <mauke> min|dvir|us: what
22:19:06 <min|dvir|us> I'm sorry for my ignorance.
22:19:19 <mauke> min|dvir|us: how do I make "hello" a number? would I use sqrt?
22:19:30 <hrumph> how do i import something with EitherT?
22:19:42 <min|dvir|us> mauke: do you see what I'm trying to do?
22:19:45 <mauke> min|dvir|us: no
22:20:23 <min|dvir|us> mauke: I want to get the numbers between 1 and 100 for whom the collatz series doesn't contain a 4 until at least the 15th place.
22:20:42 <flebron> so "the first 15 places don't contain a 4"
22:20:43 <mauke> ok, so the general shape is filter (...) [1 .. 100]
22:20:45 <hrumph> oh so i had to install the EitherT package
22:20:49 <flebron> so 4 is not in take 15 of that
22:21:05 <flebron> so 4 `notElem` (take 15 whatever)
22:21:47 <min|dvir|us> I don't want to use take.
22:22:00 <flebron> ... I don't want to eat bananas, but here we are.
22:22:02 <min|dvir|us> I want to use takeWhile.
22:22:12 <flebron> ... why?
22:22:26 <mauke> and how?
22:22:26 <min|dvir|us> Because then I can find the length.
22:22:27 <flebron> You could use takeWhile (/= 4) and see if length >= 15
22:22:32 <flebron> but they're both the same
22:22:38 <Jafet> @let lolz 1 = pure 0; lolz n = do memo <- get; case IM.lookup n memo of Just l -> pure l; _ -> let m | even n = div n 2 | 1>0 = 3*n+1 in do l <- succ <$> lolz m; put $! IM.insert n l memo; return l
22:22:40 <min|dvir|us> I want the length as a number, rather than picking a threshold.
22:22:40 <lambdabot>  Defined.
22:22:42 <hrumph> crap i still can't get EitherT recognised
22:22:43 <mauke> flebron: that's semistupid
22:22:52 <Jafet> > map head $ groupBy ((>=) `on` snd) $ mapM (liftM2 fmap (,) lolz) [1..10000] `evalState` IM.empty
22:22:56 <lambdabot>   [(1,0),(2,1),(3,7),(6,8),(7,16),(9,19),(18,20),(25,23),(27,111),(54,112),(7...
22:23:04 <min|dvir|us> mauke: what is the literate solution to this problem?
22:23:11 <mauke> what is literate?
22:23:19 <min|dvir|us> Subjective, I supposed.
22:23:21 <min|dvir|us> *suppose
22:23:45 <mauke> > let collatz = iterate (\n -> if even n then n `div` 2 else n*3+1) in filter (\n -> 4 `notElem` take 15 (collatz n)) [1 .. 100]
22:23:46 <lambdabot>   [9,14,15,18,19,25,27,28,29,30,31,33,36,37,38,39,41,43,47,49,50,51,54,55,56,...
22:23:47 <hrumph> ok got it
22:24:07 <hrumph> installed package and then import Control.Monad.Trans.Either
22:24:11 <flebron> mauke, what is semistupid?
22:24:39 <flebron> my solution was exactly what you wrote, 4 `notElem` take 15 foo
22:24:45 <min|dvir|us> OK, what if I wanted the length of each series before 4?
22:24:47 <mauke> flebron: using takeWhile and using length afterwards
22:25:04 <flebron> right, that's because he wanted to (for some reason) use takeWhile
22:25:12 <flebron> but it's not my solution
22:25:17 <min|dvir|us> I would use length and takeWhile, right?
22:26:09 <flebron> you want to do that
22:26:12 <flebron> it's pretty weird
22:26:38 <min|dvir|us> No, I just want to find the length of the collatz series until the first 4 for each of the numbers between 1 and 100.
22:26:58 <flebron> that would be length . takeWhile, but that's not what you had written
22:27:06 <flebron> you wanted to see which ones didn't have a 4 in the first 15
22:27:07 <min|dvir|us> @src .
22:27:07 <lambdabot> (f . g) x = f (g x)
22:27:07 <lambdabot> NB: In lambdabot,  (.) = fmap
22:27:46 <min|dvir|us> . looks just like $.
22:27:51 <mauke> no, it doesn't
22:28:09 <mauke> $ takes a function and an argument, . takes two functions
22:28:37 <min|dvir|us> mauke: got it.
22:28:55 <flebron> $ is application
22:28:58 <flebron> . is composition
22:29:41 <johnw> how do I specify a project directory to be copied into the doc directory by cabal?
22:30:24 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ (n, length . takeWhile (/=2) $ collatz n) | n <- [1..100] ]
22:30:26 <lambdabot>   [(1,2),(2,0),(3,6),(4,1),(5,4),(6,7),(7,15),(8,2),(9,18),(10,5),(11,13),(12...
22:30:43 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ (n, takeWhile (/=2) $ collatz n) | n <- [1..100] ]
22:30:44 <lambdabot>   [(1,[1,4]),(2,[]),(3,[3,10,5,16,8,4]),(4,[4]),(5,[5,16,8,4]),(6,[6,3,10,5,1...
22:31:25 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ (n, length $ takeWhile (/=2) $ collatz n) | n <- [1..100] ]
22:31:26 <lambdabot>   [(1,2),(2,0),(3,6),(4,1),(5,4),(6,7),(7,15),(8,2),(9,18),(10,5),(11,13),(12...
22:31:36 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ (n, length . takeWhile (/=2) $ collatz n) | n <- [1..100] ]
22:31:38 <lambdabot>   [(1,2),(2,0),(3,6),(4,1),(5,4),(6,7),(7,15),(8,2),(9,18),(10,5),(11,13),(12...
22:31:45 <min|dvir|us> So in that case . and $ are the same?
22:31:49 <flebron> huh?
22:31:57 <flebron> you say "that" as if you had just said something
22:31:58 <mauke> > [2 + 2, 2 * 2]
22:32:00 <lambdabot>   [4,4]
22:32:04 <mauke> so in that case + and * are the same?
22:32:33 <min|dvir|us> How do you know which one is better to use semantically?
22:32:37 <flebron> um
22:32:40 <flebron> they are entirely different
22:32:46 <flebron> they have nothing to do with eachother
22:32:49 <min|dvir|us> But in this case they are exactly the same.
22:32:57 <flebron> $ is usef simply because application binds tightly
22:33:00 <mauke> wrong question
22:33:13 <min|dvir|us> In this case, would you use $ or .? Why?
22:33:15 <flebron> $ is merely because of how haskell is
22:33:27 <flebron> please stop thinking of . and $ as related
22:33:33 <mauke> min|dvir|us: I would use . because it leads to more extractable subexpressions
22:33:34 <min|dvir|us> I'm not. Please answer my question.
22:33:39 * hackagebot wl-pprint-extras 3.2 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.2 (EdwardKmett)
22:33:41 <min|dvir|us> mauke: thank you.
22:33:41 * hackagebot wl-pprint-terminfo 3.0.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.0.1 (EdwardKmett)
22:33:55 <flebron> answering your question in this case is less than optimal
22:33:59 <min|dvir|us> So in general $ should be avoided.
22:34:02 <flebron> your question seems to hide some sort of misunderstanding
22:34:08 <min|dvir|us> No shit. It's a question.
22:34:09 <flebron> for instance that $ and . are related in any way
22:34:15 <mauke> min|dvir|us: it's the wrong question
22:34:17 <flebron> a question does not imply a misunderstanding
22:34:32 <min|dvir|us> mauke: what is the right question? What is the answer to the right question?
22:34:51 <flebron> the right question is "why did $ and . behave similarly in this case?"
22:35:03 <mauke> in (f . g . h $ x) all of (f . g), (g . h), (f . g . h), (h $ x), (g . h $ x) are valid subexpressions
22:35:03 <flebron> and the answer is slightly trivial
22:35:09 <flebron> you wanted to write f (g x)
22:35:12 <mauke> flebron: I don't think that's the right question
22:35:21 <flebron> this is both ( f ) (g x), which is what i told you f $ g x is
22:35:30 <flebron> and (f . g) x
22:35:32 <mauke> in (f $ g $ h $ x) you can't usefully extract (f $ g) or (g $ h)
22:35:46 <flebron> right, it doesn't scale, because . and $ really aren't related
22:35:52 <min|dvir|us> So save $ to the very end.
22:36:01 <mauke> min|dvir|us: yeah, that's what I do
22:36:01 <flebron> it is an accident that in this case, a space is what you want, so you use $ or .
22:36:15 <mauke> flebron: that doesn't really answer which you should use
22:36:17 <flebron> stylistically, yes, one tries to save $ until the end, and use composition elsewhere
22:36:38 <flebron> mauke, because "which you should use" implies they're just alternatives to eachother, and that's not pedagogically helpful
22:36:51 <mauke> they are alternatives in f (g x)
22:36:59 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ (n, length . (takeWhile (/=2)) . collatz n) | n <- [1..100] ]
22:36:59 <flebron> yes, as an accident
22:37:00 <lambdabot>   No instance for (GHC.Real.Integral [a0])
22:37:00 <lambdabot>    arising from a use of `e_123121...
22:37:04 <mauke> flebron: doesn't matter
22:37:11 <min|dvir|us> Oh, stupid.
22:37:17 <mauke> min|dvir|us: $ n
22:37:17 <flebron> it matters that the person doesn't get the idea that, as stated, "$ and . are the same"
22:37:28 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ (n, length . (takeWhile (/=2)) . collatz $ n) | n <- [1..100] ]
22:37:30 <lambdabot>   [(1,2),(2,0),(3,6),(4,1),(5,4),(6,7),(7,15),(8,2),(9,18),(10,5),(11,13),(12...
22:37:34 <min|dvir|us> mauke: nice.
22:37:39 <flebron> anyway, moot point, i hope it is clear now
22:37:50 <Jafet> . is the alternative to <$>
22:38:08 <flebron> as lambdabot notes :p
22:38:23 <flebron> (note, min|dvir|us , <$> is not $)
22:38:25 <johnw> one way to think of f <$> g is that it maps f over the value returned by g, which is just what . means
22:38:32 <stacky> application has higher precedence than composition, so you have to use (f . g) x or f . g $ x
22:38:45 <mauke> oh god, how did <$> come into this
22:38:58 <flebron> a subtle, classy troll :)
22:39:03 <flebron> (in good sport)
22:39:07 <min|dvir|us> stacky: but isn't f.g application already?
22:39:12 <mauke> don't make me pull out liftM
22:39:12 <flebron> f.g is composition
22:39:15 <johnw> how do I install custom docs with cabal?  I have images in a "docs" directory, but cabal install isn't paying any attention to them
22:39:21 <min|dvir|us> . is an infix function, though.
22:39:24 <stacky> Right, but it's application of the . infix operator
22:39:24 <flebron> it is not application, unless you want to say "it is the application of f and g to ."
22:39:33 <Jafet> liftA? I don't even know 'er.
22:39:40 <mauke> did you mean: the application of (.) t of
22:39:40 <stacky> which has lower precedence than application
22:39:43 <flebron> or, really, application of g to (.f), whici is, itself, application of f to (.)
22:39:44 <mauke> did you mean: the application of (.) to f*
22:39:47 <donri> johnw: sadly i think your only option is to install them as data files
22:40:02 <mauke> flebron: your application is backwards
22:40:09 <johnw> donri: does that install them into ~/.cabal/share/doc/<package>/html?
22:40:19 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ (n, length . (takeWhile (/=2)) $ collatz n) | n <- [1..100] ]
22:40:21 <flebron> (f . g) is (.) f g is it not?
22:40:21 <lambdabot>   [(1,2),(2,0),(3,6),(4,1),(5,4),(6,7),(7,15),(8,2),(9,18),(10,5),(11,13),(12...
22:40:24 <johnw> i think that puts them into ~/.cabal/share/<package>
22:40:31 <donri> johnw: no, share/package
22:40:34 <donri> yea
22:40:36 <startling> johnw: do what edwardk did and just put the image on imgur
22:40:37 <mauke> flebron: f x is f applied to x
22:40:39 <flebron> oh you mean I should have written (.) f and not (.f)
22:40:52 <flebron> mauke, OK, language barrier then :)
22:40:56 <edwardk> startling: i'm not terribly satisfied with that solution because i can't update the links
22:41:32 <startling> that's good though -- older docs will link to old images, new docs will link to a different image
22:41:36 <johnw> startling: i'm trying to follow the instructions at http://stackoverflow.com/questions/14017112/images-in-haddock-documentation, but they don't work
22:41:51 <min|dvir|us> @src redice
22:41:51 <lambdabot> Source not found. That's something I cannot allow to happen.
22:41:53 <min|dvir|us> @src reduce
22:41:53 <lambdabot> reduce _ 0 = undefined
22:41:54 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
22:41:54 <lambdabot>     where d = gcd x y
22:41:55 <edwardk> startling: the problem is when i go to fix something retroactively, e.g. a typo, etc. i can't do it
22:41:59 <edwardk> i can fix the ones in the wiki
22:42:11 <min|dvir|us> That's not what I wanted.
22:42:28 <mauke> min|dvir|us: foldl?
22:42:33 <edwardk> and imgur isn't known for their super-reliability
22:42:38 <min|dvir|us> @src foldl
22:42:38 <lambdabot> foldl f z []     = z
22:42:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:42:42 <johnw> One guy says "Note also that if your image is in e.g. docs/images/, you can reference it with <<images/some_img.jpg>>", but I have no idea where he gets that idea
22:42:58 <edwardk> johnw: the guy is on crack
22:43:46 <edwardk> at least i've never gotten it to work
22:43:49 <edwardk> if you can, great!
22:43:52 <edwardk> show me how
22:43:58 <startling> edwardk: good point
22:44:06 <min|dvir|us> > let collatz n = iterate (\n -> if even n then n `div` 2 else n*3+1) n in [ (n, foldl (.) [length, (takeWhile (/=2)), collatz] $ n) | n <- [1..100] ]
22:44:07 <lambdabot>   Couldn't match expected type `a0 -> b0' with actual type `[t0]'
22:44:10 <johnw> well, i know how to do it, I just don't know if Simple can do it
22:44:10 <startling> maybe you should do the data uri thing?
22:44:14 <pnkbst> edwardk: I doubt that
22:44:32 <edwardk> pnkbst: so its not crack?
22:44:32 <johnw> startling: that would just be too much of a pita
22:44:34 <pnkbst> edwardk: although marijuana is legal in many places
22:44:50 <startling> johnw: yeah.
22:45:10 <mauke> min|dvir|us: nice idea but 1) you're missing foldl's second argument and 2) all elements of a list must have the same type
22:45:54 <min|dvir|us> mauke: I see.
22:46:01 <min|dvir|us> So there's no way to force foldl into this.
22:46:01 <mauke> :t foldr (.) id
22:46:02 <lambdabot> [a -> a] -> a -> a
22:46:05 <mauke> right
22:46:15 <min|dvir|us> @src foldr
22:46:16 <lambdabot> foldr f z []     = z
22:46:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
22:46:26 <mauke> @where folds
22:46:26 <lambdabot> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
22:47:29 <min|dvir|us> mauke: thanks for the diagrams but they make absolutely no sense right now.
22:47:45 <mauke> @src []
22:47:45 <lambdabot> data [] a = [] | a : [a]
22:47:59 <Jafet> http://foldr.com
22:48:35 <mauke> > foldr f z [1, 2, 3, 4, 5]
22:48:36 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 z))))
22:48:43 <mauke> > foldl f z [1, 2, 3, 4, 5]
22:48:44 <lambdabot>   f (f (f (f (f z 1) 2) 3) 4) 5
22:49:59 <Saizan> and, btw, you most likely want the stricter version, foldl', rather than foldl
22:50:37 <min|dvir|us> Can someone translate this Python function binary_associations please? https://bitbucket.org/mindvirus/binaryapplicator/src/9dd1e2ae355c09543cf8de34cc6e9d758cba7ffd/main.py?at=master#cl-79
22:50:53 <stacky> I don't think strictness would help to fold (.)
22:50:58 <flebron> "is the first application the leftmost, or the rightmost element of the list?"
22:51:23 <min|dvir|us> flebron: that makes sense.
22:51:47 <min|dvir|us> It's basically impossible to use a list of functions as the last argument to foldl/r?
22:51:52 <Saizan> stacky: no, i'd use ($) with that
22:52:07 <min|dvir|us> In fact, having lists of functions is generally useless?
22:52:15 <Saizan> no, it's quite useful
22:52:24 <DrCode> what is the diffrent between llvm and nekovm
22:52:38 <min|dvir|us> Saizan: how would I fold .?
22:52:39 <flebron> it's pretty useful
22:52:41 <DrCode> I understand hasksell uses llvm
22:52:55 <mauke> :t foldr (.) id
22:52:56 <lambdabot> [a -> a] -> a -> a
22:53:00 <mauke> like this
22:53:01 <flebron> > map ($ 2) [(+2), (*3), (^4)]
22:53:01 <Saizan> min|dvir|us: like that ^^
22:53:02 <lambdabot>   [4,6,16]
22:53:43 <Saizan> ?type foldl' (flip ($))
22:53:44 <flebron> > foldr (.) id [(+2), (*3), (^4)] 9
22:53:44 <lambdabot> a -> [a -> a] -> a
22:53:45 <lambdabot>   19685
22:53:52 <flebron> > foldl (.) id [(+2), (*3), (^4)] 9
22:53:54 <lambdabot>   19685
22:53:57 <min|dvir|us> What is $ 2?
22:54:04 <flebron> "apply to two"
22:54:10 <Saizan> stacky: see "foldl' (flip ($))"
22:54:21 <min|dvir|us> Wow, Haskell is nuts, man.
22:54:24 <flebron> the folds i wrote above use a list of functions
22:54:38 <stacky> mhm, sorry
22:54:51 <flebron> > (9^4)*3+2
22:54:52 <lambdabot>   19685
22:54:54 <stacky> I saw them foldling with (.) so I just
22:54:58 <Saizan> stacky: tbf, it probably goes in the other order
22:55:11 <mauke> trying to catch me folding dirty
22:55:14 <stacky> haha it's okay i get it
22:55:48 <Saizan> min|dvir|us: btw, your problem is that the functions in this list [length, (takeWhile (/=2)), collatz] are of different types, so you can't really put them in a list
22:56:07 <flebron> also..
22:56:16 <flebron> > ((id) . (+2) . (*3) . (^4)) 9
22:56:17 <lambdabot>   19685
22:56:28 <flebron> the reason why my foldr and foldl were the same, is that composition is associative
22:56:44 <min|dvir|us> Saizan: yes, I undersatnd that.
22:57:00 <min|dvir|us> Saizan: as a result, folding with . is a fruitless endeavor.
22:57:09 <Saizan> min|dvir|us: not really
22:57:10 <flebron> it isn't, as i showed above
22:57:15 <flebron> > foldl (.) id [(+2), (*3), (^4)] 9
22:57:17 <lambdabot>   19685
22:57:47 <flebron> that does ((((id) . (+2)) . (*3)) . (^4)), and applies it to 9
22:57:48 <Saizan> min|dvir|us: it's more interesting when the list is not a constant, of course
22:58:40 <flebron> foldr would do ((+2) ((*3) . ((^4) . (id)))), and apply that to 9
22:58:54 <flebron> there's a . missing in my last expression :p
22:58:58 <min|dvir|us> So there's literally no way to reduce function composition.
22:59:04 <mauke> > foldr (.) id [(+2), (*3), (^4)] 9
22:59:04 <flebron> ...
22:59:06 <lambdabot>   19685
22:59:10 <flebron> min|dvir|us, are you reading what I'm typing?
22:59:16 <min|dvir|us> Other than the specific case where all the functions have the same type.
22:59:16 <stacky> to reduce? .-.
22:59:21 <thoughtpolice> > foldl (.) id [(+2), (*3), (^4)] 9 :: Expr
22:59:23 <lambdabot>   9 * 9 * (9 * 9) * 3 + 2
22:59:34 <flebron> min|dvir|us, well, that's really the least you want
22:59:37 <mauke> > ((+2) . ((*3) . ((^4) . (id)))) 9
22:59:38 <lambdabot>   19685
22:59:42 <flebron> otherwise how could you ever hope to compose them?
22:59:54 <flebron> (an arbitrary list of functions, that is)
23:00:00 <mauke> flebron: step by step
23:00:08 <Saizan> min|dvir|us: we could have a different type of list that allows that
23:00:11 <mauke> only adjacent functions need compatible in/output types
23:00:13 <flebron> but the list wouldn't be of the same type :p
23:00:21 <min|dvir|us> Saizan: elaborate please?
23:00:22 <mauke> flebron: duh?
23:00:40 <flebron> mauke: that "duh" is the rhetorical question i asked min|dvir|us
23:01:09 <flebron> using higher order types you could ask for a foldl that requested polymorphic functions
23:01:34 <startling> this is trivially easy in Idris. :D
23:01:35 <flebron> but i'm not sure that improves things
23:02:21 <Saizan> min|dvir|us: with GADTs (an extension of algebraic datatypes) we can write data IList f i j where Nil :: IList f i i; Cons :: f i k -> IList f k j -> IList f i j
23:03:21 <Saizan> min|dvir|us: so IList (->) A B would be a list of functions of matching types (but not all the same) which when composed go from A to B
23:03:42 <stacky> man, gadts are cool. I should sit down and learn them soon :/
23:03:59 <startling> they're not hard
23:04:31 <Saizan> min|dvir|us: i can't say that i've wanted to do this too often, but i've used that IList type in the past
23:04:43 <startling> it's just a different more powerful way of declaring data types -- rather than data X = Y A | Z B, you write "data X where y :: A -> X; z :: B -> X"
23:05:01 <min|dvir|us> Saizan: thank you. :)
23:05:06 <Saizan> min|dvir|us: anyhow you probably want to return to GADTs much later after you are more familiar with the basics of haskell
23:05:12 <min|dvir|us> Yeah.
23:05:30 <stacky> that's all there is to it, huh?
23:05:32 <stacky> welp
23:05:47 <thoughtpolice> not quite, but it's a start :)
23:05:56 <min|dvir|us> Can you translate this Python function https://bitbucket.org/mindvirus/binaryapplicator/src/9dd1e2ae355c09543cf8de34cc6e9d758cba7ffd/main.py?at=master#cl-79 to Haskell please
23:05:59 <min|dvir|us> ?
23:06:08 <mauke> I don't speak python
23:06:09 <Saizan> stacky: do uou understand existential types and (~) ?
23:06:12 <thoughtpolice> (personally i like the GADT syntax, anyway.)
23:06:24 <min|dvir|us> It's confusing, but it basically makes http://upload.wikimedia.org/wikipedia/commons/0/01/Catalan_number_binary_tree_example.png
23:06:38 <min|dvir|us> Given a list of green bananas.
23:07:08 <johnw> i've never seen a record on the left-hand side of an = before
23:07:18 <johnw> Record { field = name } = f x
23:07:20 <johnw> what does that mean?
23:07:27 <stacky> I'm not practiced on existential types; and the ~ in pattern matching? sure
23:07:53 <Saizan> johnw: pattern match
23:07:59 <mauke> johnw: looks like it's binding name
23:08:04 <johnw> Saizan: interesting
23:08:09 <simon> I've got a foo :: X -> State A [B], and then an xs :: [X], and when I do mapM foo xs, I expect State A [[B]]... so I wonder if there's a concatMapM, or if there's something prettier than concat <$> mapM foo xs
23:08:10 <Saizan> stacky: no, the one in types
23:08:14 <johnw> what's that kind of pattern match called?
23:08:21 <stacky> Ah, then nope
23:08:27 <stacky> I guess now I know where to start
23:08:36 <mauke> :t Tree
23:08:37 <lambdabot>     Not in scope: data constructor `Tree'
23:08:37 <lambdabot>     Perhaps you meant `True' (imported from Data.Bool)
23:08:39 <mauke> :t Node
23:08:40 <lambdabot> a -> Forest a -> Tree a
23:08:56 <donri> johnw: that there is just a normal pattern match
23:09:08 <donri> johnw: there are extensions for shorter forms though
23:09:24 <simon> @pl concat <$> mapM foo xs
23:09:24 <lambdabot> join <$> mapM foo xs
23:09:39 <johnw> i've never seen that kind of match mentioned before
23:09:47 <min|dvir|us> > let associations (x:xs) = (x:associations xs, (associations xs):x) in assiociations [1, 2, 3, 4]
23:09:49 <lambdabot>   Not in scope: `assiociations'
23:09:49 <lambdabot>  Perhaps you meant `associations' (line 1)
23:10:09 <donri> johnw: i don't know that it has any special name. it's part of record syntax
23:10:14 <johnw> usually if it's Record { field = x }, that's either establishing a value for x, or setting the field of an existing record's field to x; I've never seen it as a way to name the field's value
23:10:40 <johnw> sorry, establishing a value for the field using x
23:10:47 <donri> yes, it's binding x to the field's value
23:10:57 <johnw> yeah, i see that, it's pretty cool
23:11:01 <johnw> but brand new to me!
23:11:15 <donri> also note that you don't have to mention all or even any fields
23:11:29 <donri> isJust Just{} = True
23:11:30 <johnw> yeah, i'm only mentioning one field
23:11:34 <flebron> min|dvir|us, you want the number of trees of a given number of leaves?
23:11:35 <donri> and doesn't even require a proper record
23:11:45 <flebron> (binary trees)
23:11:48 <min|dvir|us> flebron: no, I don't want the number of trees; I want the trees themselves.
23:12:01 <min|dvir|us> > let associations (x:xs) = (x:associations xs, (associations xs):x) in associations [1, 2, 3, 4]
23:12:02 <lambdabot>   Couldn't match expected type `[a0]' with actual type `([a0], t0)'
23:12:06 <donri> also: Record{field} is like field=field with record puns
23:12:13 <donri> Record{..} does that for all fields
23:12:13 <flebron> well, you can construct them
23:12:21 <donri> with record wildcards
23:12:27 <flebron> say your function is called f k, returning a list of trees of k leaves
23:12:43 <min|dvir|us> OK.
23:12:56 <flebron> f k is Tree (f i) (f (k-i)) for every i in 1..k-1
23:13:07 <min|dvir|us> @src Tree
23:13:07 <lambdabot> Source not found. Just try something else.
23:13:11 <flebron> where that is pseudosyntax for "grab a tree from f i, grab another tree from f (k-i), make a new tree"
23:13:14 <johnw> is there a good, standardish function for copying a directory recursively?
23:13:19 <min|dvir|us> :t Tree
23:13:21 <lambdabot>     Not in scope: data constructor `Tree'
23:13:21 <lambdabot>     Perhaps you meant `True' (imported from Data.Bool)
23:13:33 <flebron> it's not a standard constructor, min|dvir|us , i just used tree because it made sense
23:13:37 <donri> @hackage system-fileio maybe
23:13:37 <lambdabot> http://hackage.haskell.org/package/system-fileio maybe
23:14:12 <min|dvir|us> flebron: could you make a working example? Sorry, it's hard to read Haskell pseudocode.
23:14:27 <johnw> donri: i was hoping for something based on FilePath = String
23:15:44 <flebron> say the type is
23:15:50 <flebron> data Tree = Leaf | Node Tree Tree
23:16:06 <flebron> then f 1 = [Leaf], f k = [Node left right | i <- [1..(k-1)], left <- f i, right <- f (k - i)]
23:17:08 <flebron> f 4 is [Node Leaf (Node Leaf (Node Leaf Leaf)),Node Leaf (Node (Node Leaf Leaf) Leaf),Node (Node Leaf Leaf) (Node Leaf Leaf),Node (Node Leaf (Node Leaf Leaf)) Leaf,Node (Node (Node Leaf Leaf) Leaf) Leaf]
23:17:27 <flebron> "clearly" the same as your linked image
23:19:08 <flebron> the first one is your rightmost in the image, the second one is the one before rightmost, etc
23:21:06 <johnw> edwardk: i have a solution, though i'm not sure you will like it
23:21:12 <edwardk> ?
23:21:24 <hpaste> johnw pasted “Setup.hs (for custom images)” at http://hpaste.org/80292
23:21:28 <johnw> use built type custom, and that Setup.hs
23:22:16 <johnw> i guess that should be in postInstall though, not postHaddock
23:24:27 <hpaste> johnw annotated “Setup.hs (for custom images)” with “Setup.hs (for custom images) (annotation)” at http://hpaste.org/80292#a80293
23:26:10 <edwardk> johnw: thats not terrible
23:26:33 <johnw> no.  what we need is an "extra-docs" field in Simple, though
23:26:55 <edwardk> *nods*
23:29:27 <johnw> i'll open an issue for johan
23:33:01 <hpaste> Hrumph pasted “Second Haskell Program” at http://hpaste.org/80294
23:33:09 <hrumph> OK i've written my second haskell program now
23:33:18 <johnw> edwardk: https://github.com/haskell/cabal/issues/1167
23:33:36 <hrumph> can someone look at it specifically at the bottom the mainControl function i don't like the way i called the EItherT constructor directly
23:33:49 <johnw> my Custom solution doesn't handle the "sdist" case, nor does it correctly install images into dist/ when you just do "cabal haddock"
23:33:53 <hrumph> it felt wrong. can anyone tell me what i erally should be doing?
23:43:56 <Saizan> hrumph: you can use "either throwError return $ parseLine line" if you want
23:44:23 <Saizan> hrumph: if you import Control.Monad.Error
23:45:02 <hrumph> ok i'll research that later if i get around to it
23:46:52 <hrumph> i definitely don't want to be throwing exceptions at that point
23:47:01 <hrumph> so i'll keep things the way they are
23:47:22 <hrumph> i want evaluation to continue in the main function no matter what because i'll assess the result there
23:47:40 <Saizan> it wouldn't be throwing exceptions any more than with your code
23:48:02 <hrumph> i'm not throwing any at all anywhere
23:48:12 <hrumph> i'm carefully propogating my errors everywhere
23:48:26 <Saizan> ok, so my code wont' either
23:48:46 <Saizan> (it depends on what we mean by exceptions really, it won't throw IO exceptions, that's for sure)
23:48:48 <hrumph> ok i'll have to learn what it does later then
23:51:39 <hrumph> ok how do i force an exit or an exception in an IO do block?
23:51:50 <hrumph> just want to force an exit right now
23:52:03 <elliott> mm_freak_: hey, you were asking about a chr/ord iso, right?
23:52:08 <elliott> mm_freak_: you can just use "enum"
23:52:18 <elliott> though you'll need a type annotation for the Int -> Char case
23:52:44 <hrumph> i call exitWIth apparently
23:52:53 <osa1> I don't understand how does `s` type variable in ST monad help protecting escapes from ST monad. I read almost all SO posts about it but still don't get it. can anyone help me ? :)
23:53:07 <elliott> though, I think "from enum" is probably the more useful order for characters
23:55:31 <mauke> osa1: the first thing 's' does is make sure all parts of the same ST action use the same 's'
23:55:41 <mauke> :t newSTRef
23:55:43 <lambdabot> a -> ST s (STRef s a)
23:56:14 <mauke> and all STRefs include the 's' of their creating action in their type
23:56:15 <osa1> mauke: all ST functions uses s parameter from ST monad it's called in, is that correct ?
23:56:40 <mauke> osa1: I'm not sure what you said makes sense
23:56:50 <mauke> nothing actually uses s
23:57:00 <mauke> what do you mean by "ST function"?
23:57:11 <osa1> me too :) can you giv eme some code examples for emulating that behavior (without using ST monad)
23:57:12 <mauke> and what do you mean by "ST monad"?
23:57:19 <mauke> what behavior?
23:58:57 <osa1> mauke: by behavior I mean having a type variable and using that forbidding calls outside a function like runST
23:59:28 <mauke> but that's not what happens
23:59:37 <osa1> oh
23:59:42 <mauke> > length [newSTRef ()]
23:59:44 <lambdabot>   1
23:59:51 <mauke> here I'm calling newSTRef
