00:00:05 <Fuuzetsu> idlers gonna idle
00:00:31 <ttoz> hey :) new to haskell, you guys?
00:01:05 <Fuuzetsu> I think you'll find that we have all levels of skill here.
00:01:50 <`nand`> up to a limit
00:02:27 <ion> lim_{x → ∞}
00:03:37 <Axman6> ttoz: got any questions? We're more than happy to help
00:04:33 <`nand`> and down to a colimit
00:04:47 <Fuuzetsu> down to shachaf
00:04:54 <ttoz> Axman6: currently playing with tryhaskell, I like to learn things myself but will definitely ask if I need to
00:04:57 <ttoz> thanks :)
00:14:51 <arbn> Could someone explain to me the constraint "(MonadError String m, MonadIO m)", and what I need to do about that in order to deal with it while doing IO?
00:20:18 <latro`a> arbn---m = IO satisfies that constraint, I think
00:20:24 <latro`a> so for just IO it doesn't matter
00:21:26 <ion> instance MonadError IOException IO
00:21:49 <Fuuzetsu> :i MonadError
00:22:32 <arbn> latro`a: The type is String -> m (String, String), but when I just give it a string argument, I get this error... "No instance for (Control.Monad.Error.Class.MonadError String m0)"
00:23:06 <arbn> latro`a: Do I need to use mapM or something?
00:26:42 <hpaste> arbn pasted “MonadError ” at http://hpaste.org/80684
00:28:03 <arbn> When I try to bind it, I get that error, even though I thought IO == m, too.
00:29:41 <ion> arbn: I wonder if this works? either fail return =<< runErrorT (opfContentsFromZip "…")
00:31:40 <arbn> ion: Yes it does.
00:33:17 * hackagebot cryptohash-cryptoapi 0.1.0 - Crypto-api interfaces for cryptohash  http://hackage.haskell.org/package/cryptohash-cryptoapi-0.1.0 (VincentHanquez)
00:33:25 <ion> someAppropriateName = either fail return <=< runErrorT
00:34:36 <arbn> ion: Yeah. I guess what I was missing was the runErrorT. So, I can use runErrorT on the computation, bind into IO, and then use any instance of MonadError to handle the possible failure, right? Either is one example.
00:37:04 <ion> arbn: The original problem was that the function has a String constraint, but the MonadError instance for IO wants an IOException instead. Unless there’s a nicer way, one could use the ErrorT instance of MonadError instead and do something with the resulting IO (Either String a) value instead.
00:37:47 <arbn> ion: Oooh. I see. OK. Thanks.
00:37:50 <ion> Let me sprinkle a bit more “instead” in there, three wasn’t quite enough.
00:58:17 * hackagebot hakyll 3.5.3.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.5.3.0 (JasperVanDerJeugt)
01:00:14 <arbn> Cool.
01:00:18 * arbn likes Hakyll.
01:00:56 <ion> I wish Hackage pages had changelogs.
01:01:19 <Taneb> ion, have you seen hdiff?
01:01:24 <Taneb> http://hdiff.luite.com/
01:01:52 <ion> taneb: Yeah
01:04:57 <viran> hey, T(n) = T(n/2) + O(n) ; it seems to me this should equal O(nlog(n)) but my notes says it's O(n) any idea why?
01:05:25 <Taneb> I'm not familiar with T notation
01:05:26 <c_wraith> because the recursive part only adds up to another O(n)
01:05:39 <c_wraith> n + n/2 + n/4 + n/8 etc
01:05:53 <c_wraith> the sum is O(n)
01:05:56 <mrout> c_wraith: the sum is n
01:06:14 <mrout> 2 actuallly
01:06:18 <viran> oh, thanks
01:06:21 <mrout> oh, 2n
01:06:40 <mrout> 1/2 + 1/4 + 1/8 + ... = 1
01:06:46 <mrout> so add another 1, 2
01:06:47 <c_wraith> mrout: too much precision.  It's 2 * O(n) - 1
01:07:05 <c_wraith> mrout: which is useless, so don't use that much precision
01:08:12 <mrout> congratulations, you fucked up your big O notation.
01:08:24 <mrout> k*O(n) + c = O(n)
01:08:41 <mrout> n + n/2 + n/4 + n/8 + n/16 + ... = 2n
01:08:42 <c_wraith> I think you missed the point entirely
01:09:20 <mrout> 1: 2*O(n) = O(n)
01:09:30 <mrout> 2: O(n) + 1 = O(n)
01:09:41 <mrout> where '=' = 'is'
01:10:25 <c_wraith> yes, you've definitely missed the point *entirely*
01:10:34 <mrout> Missed what point?
01:11:07 <c_wraith> Which is that saying 2n - 1 (I have no clue why you think it's 2n) instead of O(n) is too much precision
01:11:38 <c_wraith> It's like if I asked what 3 + 5 is and you said 8.0000002
01:11:44 <mrout> 1 + 1/2 + 1/4 + 1/8 == 2
01:12:02 <mrout> But 3 + 5 isn't 8.0000002
01:12:08 <mrout> are you on drugs? It's 8.
01:12:14 <ion> c_wraith: But i have a Pentium
01:12:27 <c_wraith> ion: then 16/2 is 8.0000002
01:12:33 <c_wraith> ion: but not with +
01:12:58 <mrout> Similarly, (n + n/2 + n/4 + n/8 + ...) == n  * (1 + 1/2 + 1/4 + 1/8 + ...) == n*2
01:13:12 <c_wraith> mrout: you seem to be under the impression we're working with floating point numbers, but we're not
01:13:23 <mrout> I'm not under any such impression
01:13:34 <mrout> You're the one that's talking about 8.0000002
01:13:36 <c_wraith> 8 + 4 + 2 + 1 = 15, not 16
01:13:58 <mrout> no shit
01:14:00 <mrout> you said "etc."
01:14:12 <c_wraith> with the knowledge that n is an integer
01:14:36 <mrout> 1 + 2 + 4 + 8 has nothing to do with 1/1 + 1/2 + 1/4 + 1/8
01:14:55 <Ralith> this is an extremely silly argument
01:14:57 <mrout> you said "etc." implying 1 + 1/2 + 1/4 + 1/8 + 1/16 + 1/32 + ...
01:15:15 <c_wraith> Ralith: it's not even an argument, it's just a total loss of context
01:15:28 <mrout> c_wraith: look, it's very simple.
01:15:54 <mrout> I'm not talking about floating point numbers. I'm not talking about a computer.
01:16:10 <c_wraith> mrout: yes. I answered in context. you ignored context. very simple.
01:16:11 <mrout> I'm stating that 1 + 1/2 + 1/4 + 1/8 + 1/16 + 1/32 + ... = 2
01:16:58 <mrout> This is a mathematical fact, and context has nothing to do with it.
01:17:16 <viran> mmm, given an array of numbers, what is the best way to find all the numbers that are less then the median?
01:17:56 <Ralith> take ((length xs) / 2) (sort xs)
01:18:21 <Ralith> filter (< (median xs)) xs
01:19:24 <viran> Ralith: i mean theoraticly, can i do it better than sorting (in nlogn) and taking the lower half?
01:19:55 <mrout> Well by definition, you can only find the median by sorting.
01:20:01 <Ralith> oh, right, median
01:20:49 <mrout> I forget, what's the median of a list with an even number of items in it?
01:21:03 <mrout> [1, 2, 3, 4, 5, 6], not [1, 2, 3, 3, 4, 5]
01:21:19 <Ralith> the mean of the middle two, iirc
01:21:19 <Taneb> 3.5
01:21:33 <mrout> Ahh, thought it might be something like that
02:01:12 <fragamus> i want to use lenses and it seems to need template haskell.  what is template haskell, am i already using it
02:01:48 <Fuuzetsu> it's used for meta-programming and you aren't using it if you don't know what it is
02:02:27 <lightquake> template haskell is a way to use haskell code to generate haskell code at compile time
02:02:39 <fragamus> ah
02:02:46 <lightquake> the lens package uses template haskell to generate your lenses for you so you don't have to define them explicitly
02:03:17 <mrout> like template metaprogramming in C++? compile time code generation? It even has the word template, I *must* be right.
02:03:47 <Fuuzetsu> it's practically C++
02:03:55 <Fuuzetsu> in fact, just use C++
02:03:59 <mrout> nice. or perhaps not.
02:04:14 <fragamus> is it ugly
02:04:21 <basdirks> yes
02:04:23 <Fuuzetsu> arguably
02:04:42 <srhb> You don't _need_ to use TH in order to use lenses.
02:04:54 <fragamus> but lens is easier with it right
02:05:03 <lightquake> you can manually write your lenses, yeah
02:05:04 <srhb> Not easier, but less cumbersome.
02:05:09 <basdirks> yes it is very convenient
02:05:30 <fragamus> less filling
02:05:34 <lightquake> but once you have the lenses defined you don't need to use TH
02:57:46 <`nand`> the ugliest thing about TH is manipulating syntax trees
03:01:25 <RawProduce> TH?
03:02:11 <Nereid> template haskell
03:02:34 <RawProduce> is that anything like C++ templates?
03:02:42 <RawProduce> still quite new to Haskell :)
03:03:20 <shachaf> Sort of, but not really.
03:03:22 <srhb> It's like this conversations keeps rebooting itself at about this point. Didn't it start yesterday originally? :P
03:03:25 <shachaf> Anyway you shouldn't use it if you're new to Haskell.
03:03:40 <Nereid> it's not really like C++ templates.
03:03:52 <RawProduce> ah ok
03:04:01 <Nereid> it's for compile-time generation/manipulation of code.
03:04:39 <Nereid> I haven't really written any TH stuff.
03:40:26 <Saizan> i wonder why they didn't just name it MetaHaskell or something referring macros
03:42:19 <johnw> it's a conversation starter
03:43:05 <plat0> Is GHC still based on an STG machine substantially similar to the one described in "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine - Version 2.5 (1992)"
03:44:21 <arbn> Saizan: Yeah. Especially since the closest comparison is probably the macro system of some LISP somewhere.
03:45:17 <shachaf> plat0: It's similar at a high level but a lot of the details are different.
03:46:33 <plat0> shachaf: Is there a new paper describing recent a recent implementation?
03:46:44 <plat0> s/new/newer/
03:47:29 <shachaf> plat0: There are a bunch of papers.
03:47:41 <shachaf> @where eval-apply
03:47:41 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/index.htm
03:47:47 <shachaf> @where ptr-tag
03:47:47 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
03:47:51 <shachaf> @where cpr
03:47:52 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
03:47:56 <shachaf> Those are a few.
03:48:06 <plat0> Thanks shachaf!
03:48:20 <shachaf> They're generally pretty readable, and also shorter than the STG paper. :-)
03:55:50 <arbn> So... every accessor for a record must be exported from a module individually?
03:56:30 <shachaf> What do you mean?
03:56:51 <arbn> shachaf: There not some shorthand for exporting all the fields of a record.
03:58:26 <Saizan> Record(..)
03:58:26 <Fuuzetsu> don't they get exported when you export the type?
03:58:33 <arbn> Fuuzetsu: No.
03:58:53 <basdirks> arbn: module Foo ( Bar(..) ) where
03:59:08 <arbn> basdirks, Saizan, thanks!
03:59:54 <Saizan> tbf, Type(..) is for exporting the constructors, not sure if it also exports the fields but i imagine there's something similar if not
04:00:04 <shachaf> (..) should owrk.
04:00:38 <basdirks> Saizan yes it exports the accessors as well
04:27:34 <Maior> attempting to teach myself Haskell via some trial and error and online tutorials (I know, I know, sorry...) and I'm struggling to work out how I might define a type... "as an alias for / equivalent to" (I suspect a lot of the issue is the words I'd put there) a multidimensional Data.Array
04:28:44 <RawProduce> Maior: wouldn't it be something like   type MyType = Data.Array
04:28:55 <arbn> Maior: "type synonym" is the word you're looking for.
04:29:13 <arbn> Maior: And it looks like what RawProduce just did.
04:29:14 <Maior> RawProduce: right, but restricting that array to be 2D?
04:29:50 <Maior> sorry for lack of clarity, the "multidimensional" bit was supposed to feature strongly in my question
04:30:34 <Maior> (it'd be nice if I could generalise my function for n-dimensional arrays; I do not have that skill)
04:30:48 <Maior> s/for/across/
04:33:23 * hackagebot ldif 0.0.13 - The LDAP Data Interchange Format (LDIF) tools  http://hackage.haskell.org/package/ldif-0.0.13 (RadoslavDorcik)
04:34:26 <Maior> I guess I want Data.Array with Ix constrained to be a pair
04:39:46 <`nand`> what exactly are toLower/toUpper based on?
04:40:16 <`nand`> > (generalCategory '\119808', toLower '\119808')
04:40:17 <lambdabot>   (UppercaseLetter,'\119808')
04:40:40 <Nereid> `nand`: towlower/towupper
04:40:46 <ocharles> :t generalCategory
04:40:47 <lambdabot> Char -> GeneralCategory
04:41:01 <ocharles> are these text-icu functions?
04:41:14 <ocharles> you might get better results with that
04:41:56 <Nereid> towlower is a standard C library function.
04:42:01 <Nereid> well C99, I guess.
04:42:59 <`nand`> hmm, so it's based on the system locale? (judging by the description of towlower)
04:43:10 <Nereid> apparently
05:00:56 <`nand`> that seems fairly environment-dependent for a seemingly pure function
05:02:16 <RawProduce> well, upper/lower casing is invariably environment dependent since the locale determines how to achieve it
05:07:01 * Lethalman fell in love with memoize hackage
05:27:15 <osa1> why some names exported when I run `import MyModule` aren't being exported when I run `import qualified MyModule as M` as M.someNameExportedWhenIRunNonQualifiedImport ?
05:29:36 <ocharles> osa1: not entirely following, paste some code
05:29:40 <ocharles> preferably a minimal test case
05:29:50 <`nand`> do you mean ‘imported’ when you say ‘exported’?
05:29:58 <ocharles> M.foo will work as long as M exports foo
05:30:19 <Saizan> osa1: yeah, it's not very clear, maybe what you want is to rexport names as qualified?
05:30:44 <Saizan> osa1: it's not clear what you mean by "run" btw
05:31:27 <osa1> ok sorry for my english. let's say I have a module that imports some other modules(unqualified), now when I just "import MyModule" I can use all names defined by that module but also names imported by that module
05:31:44 <osa1> now if I import MyModule as qualified, I can't use names imported by MyModule
05:32:07 <Saizan> osa1: do you mean in ghci?
05:32:26 <osa1> Saizan: no, I can't compile the file because of unbound names
05:32:42 <osa1> ok let me paste a quick example (maybe I'm doing something else wrong)
05:32:48 <ocharles> seeing some code will definitely help
05:32:57 <Saizan> yep, code + interaction log
05:33:01 <osa1> ok
05:38:40 <hpaste> osa1 pasted “module help” at http://hpaste.org/80695
05:38:41 <Saizan> anyhow when you import a module M you don't get the names from the modules M imports automatically
05:38:54 <Saizan> that happens only if M explicitly re-exports those modules
05:38:55 <osa1> ok I think I misunderstand Haskell modules
05:39:05 <osa1> Saizan: that was exactly my problem
05:39:07 <osa1> thanks
05:40:38 <Saizan> osa1: np, i guess you got confused by the behaviour of the ghci prompt
05:41:12 <Saizan> since when loading an interpreted module you do get its imports in scope
05:43:26 <maki`> if I understand correctly, Monads came first, then Functors and Applicatives?
05:43:35 <osa1> Saizan: I didn't like the behavior because when I explicitly export a module, I have to explicitly export other names too. is there a way to tell "export Text.Parsec module and other names defined in current module" ?
05:44:09 <`nand`> on that matter, I wish there was an invocation of ghci that would completely clear the scope and only import those things that were defined in the file you are loading; eg. if the file imports Prelude hiding (id) and defines its own id, you could use ghci file.hs and ‘id’ would refer to only the one in the file
05:44:18 <`nand`> even if you had other imports, including Prelude, in ~/.ghci
05:44:21 <maki`> why do we need Functors and Applicatives?  from my perspective (possible wrong) they give us a lot of duplicated functionality.  fmap liftA liftM, etc
05:44:32 <maki`> possibly
05:44:38 <ocharles> maki`: otherway round, liftA duplicates what applicative gives you
05:44:41 <ocharles> :t liftA
05:44:41 <`nand`> the solution I use so far is to have a local .ghci which will override ~/.ghci
05:44:42 <lambdabot> Applicative f => (a -> b) -> f a -> f b
05:44:43 <`nand`> but it's a hack
05:44:49 <Saizan> osa1: not really, you could make a third module that rexports both MyModule and Ttext.Parsec though
05:45:47 <`nand`> what's the purpose of ‘liftA’ anyway? It seems like a completely useless function, given fmap
05:45:50 <`nand`> oh wait
05:45:52 <`nand`> I know
05:45:57 <`nand`> instance Functor Foo where fmap = liftA
05:46:02 <Saizan> right
05:46:26 <maki`> ocharles but still wondering why Functors and Applicatives were created. can do do something that Monads can't?
05:46:34 <Saizan> maki`: the point is that some structures can't be made a Monad (or Applicative) but can still be Applicatives (or Functors)
05:46:36 <`nand`> there are Functors and Applicatives which are not Monads
05:46:41 <ocharles> maki`: plenty they can't, because they are more general
05:46:51 <ocharles> erm, that came out a bit backwards
05:47:02 <ocharles> `nand`'s answer is what I meant to say :)
05:47:16 <maki`> what would be an example of a Functor or Applicative that isn't a Monad
05:47:30 <`nand`> ZipList is an Applicative that can't be a Monad
05:47:53 <Saizan> (,) a without a constraint on a is a Functor and not an Applicative
05:48:27 <`nand`> Const a without a constraint on it is a functor and not an applicative; Const a with a Monoid a constraint is an applicative
05:48:30 <`nand`> but it can't possibly be a monad
05:48:47 <ocharles> more generally, applicatives are closed under composition, but monads aren't.
05:48:52 <ocharles> so there's a whole slew of applicatives that can't be monads
05:49:21 <Saizan> also, some parsers can do optimizations when using the Applicative interface that can't be done with the Monad interface
05:50:14 <osa1> Saizan: does that because Monad interfaces actually provide a context dependent framework, but applicatives can't do that so applicative interfaces define context-free ones ?
05:50:49 <`nand`> something like that, I'd guess
05:51:14 <Saizan> osa1: thanks to haskell recursion you can have context-sensitive grammars even with just applicative combinators
05:52:49 <Saizan> osa1: the main problem is that the Monad interface is higher-order and functions are too opaque to allow that kind of self-analysis
05:53:05 <ocharles> hmmm. thinking about applicatives while i brushed my teeth - is a commutative applicative anything special?
05:53:19 <ocharles> then you would have an applicative you could evaluate in parallel (ie, reader applicative)
05:54:02 <Saizan> osa1: but yeah there's a sense in which Monad let you decide the effects by looking at the results of previous computations while Applicative doesn't
05:54:51 <ocharles> googling "commutative monad agda" doesn't seem to bring much up either
06:00:52 <hiptobecubic> ocharles, would it not being commutative stop you from doing it in parallel anyway? I thought that ap already limited things in such a way that you can't have interdependencies like with monads
06:01:06 <hiptobecubic> sure you might end up doing extra work and throwing it away
06:01:08 <hiptobecubic> :t ap
06:01:09 <lambdabot> Monad m => m (a -> b) -> m a -> m b
06:01:20 <hiptobecubic> :t (<*>)
06:01:22 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:02:30 <Saizan> liftA2 (,) x y and fmap swap $ liftA2 (,) y x still have quite different effects in many cases
06:03:24 <chris___> haskell?
06:04:00 <Eelis> haskell!
06:04:16 <chris___> anyone knows any good use for haskell?
06:04:22 <hiptobecubic> programming
06:04:31 <Eelis> solving projecteuler puzzles
06:04:46 <Saizan> that's actually a poor use of haskell
06:04:51 <Iceland_jack> running code on lambdabot
06:05:04 <Saizan> though memoization can be fun
06:05:19 <Eelis> you're saying Haskell is not suitable for projecteuler puzzles?
06:05:29 <chris___> are there any industrial problems you can solve faster and easier with haskell instead of C for example?
06:06:01 <Eelis> i would say so. quick throwaway programs, for example
06:06:06 <hiptobecubic> chris___, that is a pretty meaningless question.
06:06:30 <chris___> what do you mean?
06:06:37 <Saizan> Eelis: i was questioning more project euler than haskell there
06:06:37 <merijn> Almost any language is superior to C for solving industrial problems, unless you happen to be doing real-time/embedded
06:06:55 <Eelis> Saizan: oh
06:06:58 <hiptobecubic> chris___, it depends entirely on the domain and your familiarity with the languages
06:07:10 <hiptobecubic> chris___, also what merijn said.
06:07:21 <merijn> Eelis: I (and many others) consider Project Euler (despite it's popularity) to be worthless for learning/practicing programming
06:07:34 <Eelis> oh well
06:07:45 <merijn> Eelis: It's neat for learning and practicing arithmetic and number theory, but doesn't let you solve "real" programming issues
06:08:03 <chris___> then really its not that useful in the real world
06:08:09 <Eelis> well, i don't think they make any claims of being a /comprehensive/ set of exercises to learn programming
06:08:18 <Eelis> just a fun set of puzzles
06:08:23 <hiptobecubic> chris___, C/C++ are industry standard because they are well known and there is an enormous pool of "talent" to hire from. Not because they are good languages or because they make anything easy to do.
06:09:09 <hiptobecubic> chris___, in particular C. C is really a last resort, in my opinion. Only the right choice when you have ruled out all the other languages you know
06:09:16 <chris___> yeah, I understand that. That is why i was wondering if Haskell can replace them in some situations and make the job easier
06:09:25 <hiptobecubic> chris___, sure. assuming you know haskell
06:10:03 <chris___> I only the basics of haskell at the moment
06:10:10 <hiptobecubic> chris___, if the question is "are people using haskell for anything" then you haven't googled enough. This room alone is as big as #python
06:10:38 <Iceland_jack> hiptobecubic: the size of the room is a pretty bad metric
06:10:38 * Eelis loves how the haskell community keeps using the user count of #haskell as its penis size
06:11:20 <hiptobecubic> Iceland_jack, sure, but it at least establishes that people are somehow tracking things
06:11:23 <arbn> This conversation is boring.
06:11:53 <chris___> I see what you mean arbn, lets talk about chess tactics instead
06:12:20 <nh2> does cabal invoke ghc as a subprocess or use its api?
06:12:58 <parcs> the laatter
06:13:23 <parcs> nh2: notice how cabal-install doesn't depend on any particular ghc package
06:13:35 <parcs> which is where the ghc api is provided
06:14:26 <parcs> hmm, i guess it could indirectly depend on a ghc package..
06:14:56 <parcs> oops, i meant to say the former, not the latter
06:15:15 <Eelis> too bad. would've been nifty :)
06:22:20 <elliott> is there any way to use both the ArrowChoice combinators/etc. and GADTs? you can't really decompose your data into the whole tree-of-Eithers-and-tuples that arrow stuff often ends up being because you lose the GADTness
06:25:47 <maki`> isn't there a concat . replicate N function? I can't find it
06:25:54 <maki`> > concat . replicate 2 $ "foo"
06:25:56 <lambdabot>   "foofoo"
06:28:20 <Saizan> > repeat 2 "foo"
06:28:22 <lambdabot>   The function `GHC.List.repeat' is applied to two arguments,
06:28:22 <lambdabot>  but its type `...
06:28:32 <Saizan> right, that's not it
06:33:45 <Hafydd> @pl concat . replicate n
06:33:45 <lambdabot> join . replicate n
06:38:55 <absence> what's the best way to append lots of single elements to the end of a list, DList or prepend/reverse?
06:44:05 <donri> absence: Seq in containers maybe?
06:47:13 <Saizan> i doubt Seq is going to buy you much here
06:47:27 <Saizan> but it depends on how you use the intermediate values
06:48:55 <Saizan> if you index into them then Seq is good, otherwise you pay the overhead for nothing
06:50:02 <Saizan> DList should be a kind of deforested version of prepend/reverse, so definitely better if you just keep appending in a linear fashion
06:51:23 <Saizan> (though the accumulation of closures are just the same on the heap as the prepended list? but at least you don't have to unwind them to get to the top)
06:53:51 <absence> right, reverse is probably a bad idea for infinite data :)
07:00:21 <Cale> I wouldn't use the DList library
07:00:29 <Cale> I'd usually just use functions directly
07:01:34 <Saizan> yeah, DList is mostly useful as a name of the concept
07:01:39 <Cale> You can think of the composition functions that accumulate on the heap as being more or less equivalent to data constructors for a tree representation
07:01:46 <Cale> (at least in terms of cost)
07:01:59 <Cale> They have some small constant cost each
07:02:08 <Saizan> though i wonder if there's some implementation issue that you might get wrong not using the lib
07:02:12 <Cale> (in both time and space)
07:03:19 <Cale> It's possible, I guess. You're really after a small subset of the possible functions on lists, but in practice I usually don't find it hard to keep that straight
07:05:40 <donri> uh how would you append to an infinite list
07:06:04 <donri> Seq gives you O(1) append for finite lists
07:06:13 <mm_freak> somehow i find digestive-functors much easier to use than reform
07:06:24 <donri> mm_freak: because it's much less type safe!
07:06:35 <mm_freak> is it?  how?
07:06:40 <donri> it's easier to use in the way php is easy to use ;)
07:07:15 <mm_freak> donri: how is it less type-safe?
07:07:25 <donri> well the field names are stringly typed and not even connected between the form and view
07:07:52 <mm_freak> they just need to be unique
07:08:21 <mm_freak> and i don't see how reform improves that except that it won't let me choose the field names by default
07:08:23 <donri> yes, and you must take care to make them unique, and take care to spell them correctly in the view/form
07:08:38 <mm_freak> well, ok, field names…  anything else?
07:08:46 <donri> and take care to use every field from the form in the view, and no unused field
07:09:18 <donri> duno, they're pretty similar except for the field names thing
07:09:25 <donri> reform has validation "proofs"
07:09:38 <donri> which let you track in the type system if something was validated correctly
07:10:06 <mm_freak> yeah, i saw that
07:10:25 <mm_freak> i think i'll go with digestive-functors for now, until reform makes itself easier to use =)
07:10:59 <donri> depends how you're using them. if you're writing highly custom views, DF is more convenient (albeit less safe)
07:11:11 <mm_freak> yes, i do that
07:11:13 <donri> if you're fine with the generated views, reform shouldn't be less convenient, might even be more convenient
07:12:18 <donri> i'd love to see something closer to the original ocaml formlets with hsp+reform, but we're not sure how to do that
07:12:26 <mm_freak> also i'm not using HSX
07:12:39 <mm_freak> i'm using blaze-html directly
07:12:49 <donri> aye
07:13:25 <mm_freak> so far the only advantage of HSX i've seen is that you don't need to generate the URLs separately, but i'm happy to do that =)
07:13:47 <donri> actually blaze is really annoying at that because it's not a monad transformer
07:14:35 <mm_freak> it's not necessarily annoying…  it's just that your templates have this type:  page :: Title -> Body -> App Html
07:15:00 <mm_freak> page title body = do goHome <- showURL Home; goContact <- showURL Contact; return $ do …
07:15:10 <donri> well it's annoying if for example you're generating a HTML list of URLs
07:15:44 <mm_freak> i find it more reasonable exactly for that…  remember that you can generate chunks of HTML separately and insert them into the template
07:15:47 <ncs> i have a datatype: data A = Zero | One | Two deriving Enum
07:15:58 <ncs> how can i define succ Two to be equal to Zero?
07:16:05 <mm_freak> ncs: by not deriving Enum
07:16:16 <donri> lis <- forM things $ \thing -> url <- showURL thing; return $ li ...;; ul lis
07:16:18 <donri> shit like that
07:16:49 <ncs> so I manually have to define a "succ" function?
07:17:15 <mm_freak> donri: linklist <- mapM_ (fmap f . showURL) urls
07:17:22 <mm_freak> where f is a pure function obviously
07:17:27 <donri> rather than simply, ul $ forM_ things $ \thing -> do url <- showURL thing; li thing
07:17:38 <mm_freak> ncs: yes
07:18:19 <mm_freak> ncs: you can also define toEnum/fromEnum and then write 'succ' based on that modulo 3
07:19:08 <mm_freak> ncs: that makes sense, when you have many constructors
07:20:47 <ncs> ok, thanks!
07:21:06 <donri> mm_freak: and then you add dynamic i18n and have to do msg <- getTranslator; p $ msg WelcomeMsg in every template bit, as opposed to <p><% WelcomeMsg %></p>
07:21:09 <donri> etc
07:21:37 <donri> oh wait it's worse because you have to "return" that "p"
07:21:39 <donri> with blaze
07:23:09 <donri> oh and you have to call toHtml on the msg
07:23:20 <donri> do msg <- getTranslator; return $ p $ toHtml $ msg WelcomeMsg
07:23:39 <mm_freak> donri: oh, i'm not doing it that way…  i'm using reflection for that, so i can use the regular ToHtml class
07:23:41 <donri> all this indirection obscures the template itself
07:24:16 <donri> i don't know what that means
07:24:40 <mm_freak> donri: data Message lang = Hello | HowAreYou | Bye
07:25:32 <donri> and then?
07:25:39 <mm_freak> donri: instance (lang `Reifies` (Message lang -> Text)) => ToHtml (Message lang) …
07:25:43 <mm_freak> see the reflection library
07:26:01 <mm_freak> and yes, it's completely static =)
07:26:11 <donri> where is lang coming from
07:27:23 <mm_freak> donri: 'reify'
07:27:32 <donri> interesting
07:27:55 <mm_freak> you write a wrapper around that, called it withLang for example
07:27:55 <donri> you could do that for web-routes too i imagine?
07:28:03 <mm_freak> yes
07:28:08 <mm_freak> you can do that for everything
07:28:20 <donri> reify the askRouteFn
07:28:36 <mm_freak> you could even i18n the handlers themselves
07:29:00 <srhb> What on earth does reify mean anyway?
07:29:11 <mm_freak> like ask a different database for german users than for english users
07:29:23 <mm_freak> srhb: it's a way to lift values to the type level and back
07:29:35 <srhb> Oh.
07:29:58 <mm_freak> srhb: the canonical example of that is modular arithmetic:  instance (n `Reifies` Modulus) => Num (Mod n) where …
07:30:08 <Adrian> hello
07:30:13 <mm_freak> withModulus 15 $ 3^100000
07:30:17 <fmap> srhb: don't try to read reflection package source code :]
07:30:33 <srhb> fmap: Thanks for the warning. :P
07:30:36 <fmap> paper is much more understandable
07:30:45 <mm_freak> yes, the paper is fine
07:30:56 <mm_freak> it's also a good idea to try to implement the stuff from the paper
07:32:58 <elliott> If you think operationally I think the package's source code is easier to understand. But it's of course disgusting.
07:33:39 <mm_freak> donri: the only problem with that approach is that the translations remain static…  you can fetch them from a database when initializing, but then they are fixed
07:33:53 <mm_freak> you could initialize for every request, but that's overhead
07:34:00 <donri> well that's probably fine for most web apps
07:34:07 <mm_freak> it is
07:34:54 <donri> i imagine you'd usually initialize it every request anyway? based on request headers, or logged on user / cookie / session
07:35:05 <mm_freak> srhb: btw, you can understand how to use reflection by looking at the haddocks
07:35:11 <mm_freak> no need to read the paper nowadays
07:35:25 <mm_freak> use reify to lift, then use reflect to, well, reflect =)
07:35:52 <mm_freak> donri: if you use acid-state yes, if you use some RDBMS no
07:36:13 <mm_freak> for acid-state the overhead is almost zero
07:36:15 <donri> are you supposed to write any instances for Reifies?
07:36:20 <mm_freak> no
07:36:24 <srhb> I'm not sure what it's useful for, but maybe the haddocks will explain :P
07:36:34 <donri> odd to export the class then
07:37:07 <mm_freak> srhb: try to implement a modular arithmetic type with Eq, Show and Num
07:37:24 <mm_freak> since base 4.5 Eq and Show are optional, but you really do want them ;)
07:37:31 <donri> srhb: looks like you get a Reader without Reader or implicit parameters without ImplicitParams?
07:37:58 <absence> is there a guide to or rules of thumb for writing code that doesn't hang when processing infinite data?
07:38:20 <mm_freak> absence: yes, be productive for producers and destructive for consumers
07:38:52 <mm_freak> absence: that means:  producers should always have a constructor wrapped around the recursive call
07:39:13 <mm_freak> consumers should always pattern-match and recurse for structurally smaller arguments
07:40:01 <beaky> hello
07:41:27 <absence> mm_freak: thanks!
07:41:38 <mm_freak> absence: for finding documents the search keywords are "codata", "corecursion" and "coinduction", the latter being the theoretical foundation
07:42:05 <mm_freak> but they will come to exactly the conclusion i just gave you =)
07:44:02 <absence> mm_freak: ah, i've seen those words around on the net, good to know what they are for ;)
07:52:20 <srhb> Are there any guidelines on how to make "hooks" in a functional setting? Any differences or resources I should be aware of?
07:52:37 <mm_freak> srhb: "hook" is quite a broad word
07:52:46 <srhb> Right, I mean like event hooks
07:52:51 <mm_freak> you have callbacks, coroutines, concurrency, …
07:53:11 <mm_freak> srhb: be more precise, please
07:53:13 <srhb> I should make my idea more concrete before asking. I'll be back. :P
07:55:28 <burbul> I have a potentially infinite list; I want to print out at most 20 entries (which is easy using take), and then print out a warning if the list length is greater than 20.  Is there any easy way to do this using standard library functions, or should I define my own lengthAtLeastN?
07:57:46 <srhb> burbul: You can safely take 21 elements and check the length of that, if you want
07:57:58 <srhb> > length . take 21 $ [1,2,3]
07:58:00 <lambdabot>   3
07:58:25 <burbul> thanks
08:02:40 <maki`> are Qt bindings for haskell usable?  I am more familiar with Qt than GTK
08:03:27 <mrout> what's that great way of doing parsers in Haskell again?
08:03:41 <Clint> attoparsec?
08:03:48 <mrout> no idea what it's called
08:03:50 <jmcarthur> parsec, attoparsec, trifecta
08:03:54 <mrout> I'll probably recognise the link
08:14:06 <theo> hi everyone
08:14:14 <Taneb> Hey, theo
08:14:21 <mrout> hello
08:14:27 <Taneb> theo, are you one of the many theos I know IRL?
08:14:47 <mrout> theo: are you Theo Barnard? That would be creepy as fuck.
08:14:53 <Taneb> (the answer is "probably not")
08:15:04 <theo> no I am not
08:15:08 <mrout> phew
08:15:22 <theo> why is this creepy?
08:15:43 <Taneb> Are you Theo Hornsey, Windebank, Nichols, or Hope?
08:16:22 <theo> no I am  just another Theo that never signed on to this chat
08:16:26 <Taneb> Okay
08:16:31 <Taneb> How are you, theo
08:16:47 <donri> fantheotastic!
08:16:52 <theo> I fund an artikel about haskell and thought lets see what it is
08:17:26 <donri> haskell was a mathematician and logician
08:17:32 <donri> next question!
08:17:35 <Taneb> theo, it's an amazing programming language, you should learn it
08:17:44 <mrout> It's really good.
08:17:51 <mrout> I've just started, and I already think it's amazing.
08:18:00 <bergmark> donri: ur not helping!!
08:19:59 <theo> I will give it a try. I am used to the old Delphi
08:23:27 <mrout> I want to write a compiler for a language I'm working on. I'd like to write it in Haskell. Help me.
08:23:37 <mrout> where do I start
08:23:44 <mrout> I've read most of LYAH
08:24:34 <mrout> ?fagq
08:24:34 <lambdabot> The answer is: Yes! Haskell can do that.
08:24:37 <mrout> ?faq
08:24:37 <lambdabot> The answer is: Yes! Haskell can do that.
08:24:42 <mrout> .faq
08:24:46 <mrout> lambdabot: faq
08:24:54 <donri> @where faq
08:24:54 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
08:24:57 <maki`> mrout did you look at parsec
08:24:58 <mrout> ty
08:25:22 <maki`> http://www.haskell.org/haskellwiki/Parsec
08:25:47 <donri> trifecta is better for a compiler :)
08:26:10 <johntromp> i seem to have landed in dependency hell...
08:26:44 <johntromp> trying to install latest HLearn-distributions-0.2.2.1
08:26:57 <parcs> mrout: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
08:27:05 <johntromp> rejecting: criterion-0.6.2.0/installed-453... (conflict: criterion =>
08:27:14 <mrout> @where bnfc
08:27:14 <lambdabot> BNF Converter, <http://www.cse.chalmers.se/research/group/Language-technology/BNFC/>
08:27:15 <mrout> aha
08:27:18 <mrout> that's it
08:28:10 <maki`> is qtHaskell what i should be looking at for haskell Qt bindings?
08:28:13 <johntromp> but the dependency is (≥0.6.1.1), so how does that get rejected?
08:28:18 <mrout> it seems to appropriate that BNFC is a compiler compiler compiler
08:28:34 <hellertime> what are some good examples of haskell modules on hackage with really stand out documentation?
08:29:03 <donri> mrout: there's also happy for bnf
08:29:57 <mrout> @where lyah
08:29:57 <lambdabot> http://www.learnyouahaskell.com/
08:31:12 <donri> ah looks like bnfc can generate files for happy/alex
08:31:33 <donri> hellertime: pipes maybe
08:32:43 <mrout> http://www.digitalgrammars.com/ipl-book/ <-- good?
08:32:50 <hellertime> donri: that looks promising, nice level of complexity and organization. thanks.
08:33:28 * hackagebot amrun 0.0.0.4 - Interpreter for AM  http://hackage.haskell.org/package/amrun-0.0.0.4 (DanielSeidel)
08:33:43 <donri> hellertime: also lens, has examples for almost every function. but maybe not as good narrative docs as pipes ...
08:34:07 <donri> not on hackage anyway. there's a tutorial on a wike
08:34:09 <donri> wiki
08:34:45 <hellertime> donri: both are good starts.
08:34:59 <hellertime> wow lens really is quite complete
08:35:41 <Taneb> hellertime, it's getting completer all the time
08:35:59 <Taneb> Currently elliott and shachaf are taking shifts to make sure it never, ever, EVER stops improving
08:36:49 <hellertime> Taneb: so the completeness of lens will not converge then? :)
08:37:10 <Taneb> It's expected to achieve sentience by version 4.4
08:37:21 <mrout> http://www.digitalgrammars.com/ipl-book/ <-- good?
08:37:58 <elliott> Taneb: Actually we are secretly trying to ruin lens.
08:38:11 <mrout> anyone? http://www.digitalgrammars.com/ipl-book/ ??
08:41:51 <duch> ping
08:42:39 <Taneb> pong
08:43:55 <mrout> ping
08:44:51 <Taneb> pong
08:45:04 <ion> coping
08:45:06 <RawProduce> lol
08:45:08 <Taneb> I'm good at this table tennis malarkey
08:45:16 <RawProduce> brilliant
08:45:21 <Taneb> ion, barely, they're a player up
08:54:24 <mm_freak> ok, reform isn't that complicated, if you ignore the happstack crash course =)
08:58:28 <message144> Is there a "better" or more idiomatic way to write this: map (\x -> read x :: Int) (words "10 20 30 40 50")   ?
08:58:48 <mm_freak> this is actually a very weird, but very beautiful language property…  you can actually learn a library by looking at its API, and it's often easier and faster than reading a tutorial
08:58:59 <ion> It’s often not a good idea to use read.
08:59:20 <monochrom> perhaps map read (words "10 20 30 40 50") :: [Int] is shorter
08:59:51 <mm_freak> message144: once you start using the values you're reading, the need for the type signature may disappear
09:00:21 <mm_freak> message144: type inference fails here, because you're not feeding the values anywhere, you're just generating them, and the way to generate them depends on their type…  that's why it wants to know the type
09:00:30 <message144> mm_freak, oh, i was actually wondering about that.. I noticed when I run the statement by itself without the ":: Int" type signature, i get an error, but when I pass it to a function, it works fine
09:01:52 <message144> so it seems that the type signature is more useful for ghci debugging than anything else in this case ?
09:02:03 <mm_freak> message144: probably
09:02:12 <donri> message144: map read ... :: [Int] ?
09:02:25 <BobbyMcLiar> Hello :) I'm trying to use fclables and I'm able to run the example, but if I try to use the mkLabels in a different module than Main ghc tells me "Parse error: naked expression at top level". Why is that? Can someone point me to some easy, but non trivial examples of fclables in use?
09:02:28 <mm_freak> and yes, typing expressions into GHCi often needs more type signatures than using them in a full program
09:02:28 <donri> oh monochrom already said it
09:02:47 <mm_freak> BobbyMcLiar: you need to turn on TemplateHaskell
09:02:58 <mm_freak> put {-# LANGUAGE TemplateHaskell #-} at the top of your source file
09:03:03 <BobbyMcLiar> I did!
09:03:19 <message144> monochrom, donri : thank you.. that does answer my original question, and mm_freak, thank you, that has solved a point of confusion for me
09:03:25 <mm_freak> BobbyMcLiar: is it at the top?  above the module declaration?
09:03:50 <mm_freak> it may follow comments, but it has to be above any non-comment
09:03:51 <BobbyMcLiar> It wasn't 'top' enough^^ Thank you. Now it works
09:04:00 <BobbyMcLiar> You saved me a lot of time
09:04:08 <mm_freak> BobbyMcLiar: as a side note, nowadays you should probably switch to the 'lens' package =)
09:04:17 <BobbyMcLiar> really?
09:04:22 <BobbyMcLiar> I'll give it a shot
09:05:04 <mm_freak> don't get shocked by the size of the library though…  it can do a lot more than just setters and getters =)
09:05:10 <message144> As one last question on "::" . Is there a reason it cannot be accessed as a function? Such as being able to do "((::) foo Int)" instead of "foo :: Int", or is that just a really dumb question?
09:05:27 <mm_freak> message144: it's not an operator
09:05:30 <ion> :: is not a function/operator, it’s syntax.
09:05:46 <mm_freak> message144: if (::) were a function, what would its type be?
09:06:06 <message144> mm_freak, I dont know. I guess i would have to leave that up to the experts :)
09:06:10 <message144> but that is a good question
09:06:38 <ion> Value -> Type -> Value ;-)
09:06:47 <mm_freak> message144: (::) is a syntax to write type claims (you're not defining types, you're just claiming for something to be of some type, and the compiler checks whether you're right)
09:07:14 <mm_freak> ion: that's a kind error
09:07:18 <mm_freak> (->) :: * -> * -> *
09:07:24 <ion> mm_freak: OH, REALLY?
09:07:36 <mm_freak> just saying ;)
09:07:47 <message144> mm_freak, ok thanks.. that makes sense to me
09:12:11 <elliott> mm_freak: technically (->) has a different kind to that I think
09:12:15 <message144> well, ive spent 5 days deconstructing problem 11 here: http://www.haskell.org/haskellwiki/Euler_problems/11_to_20 , and im finally starting to understand it. this language makes me feel like an idiot sometimes.
09:12:28 <mm_freak> elliott: i'm ignoring PolyKinds
09:14:04 <elliott> mm_freak: I mean, because of unboxing
09:14:15 <mm_freak> elliott: that's gone since a few GHC versions
09:14:19 <mm_freak> :k (->)
09:14:21 <lambdabot> * -> * -> *
09:14:42 <elliott> hm
09:14:55 <BobbyMcLiar> message144 : did you try http://www.haskell.org/haskellwiki/99_questions  ? Its not so mathy
09:15:30 <message144> BobbyMcLiar, no. I will try that. Thanks
09:21:03 <jesyspa> Does Haskell have any kind of idiomatic way of updating individual values in n-tuples?  I'm writing a compiler and it's a pain to change anything in the symbol table.
09:22:29 <ion> > ("foo", 4, []) & _2 .~ True
09:22:31 <lambdabot>   ("foo",True,[])
09:22:39 <jesyspa> :O
09:22:44 <ion> (The lens package)
09:22:52 <jesyspa> I want.  Thanks! :D
09:23:52 <mm_freak> jesyspa: your symbol table is a tuple?
09:24:40 <jesyspa> mm_freak: Well, I have different "levels" of symbol tables, each of which is a state of a tuple.
09:24:56 <david1991> Hey, I have a small question regarding the usage of "forall", suppose I have a function with the following type: eqCons :: (forall b.(b -> b -> Bool) -> (t b -> t b -> Bool)) -> (a -> a -> Bool) -> (Cons t a ->  Cons t a -> Bool). This actually works, however if I do not add the forall b. it doesn't work and it tries to match type a with type b, why does it do that?
09:25:27 <mm_freak> david1991: probably because you're using recursion
09:25:35 <david1991> yes, I am
09:25:38 <mm21> but lens has max _9 ;)
09:25:44 <mm_freak> david1991: what you want is polymorphic recursion
09:26:03 <mm_freak> and the 'forall' is needed for that
09:26:09 <jesyspa> Something along the lines of ClassST = State (ClassData) \ MethodST = ClassData -> State MethodData \ StamentST = (ClassData, MethodData) -> State StamenentData
09:26:22 <david1991> yes, that's entirely true, so GHC automatically tries to "limit" the recursion?
09:26:27 <johnw> david1991: I think what he means you're passing in an a where a b is desired, causing the compiler to infer that a ~ b
09:26:43 <ion> mm21: Try contributing a patch that adds, say, _10 through _999.
09:26:56 <mm_freak> david1991: the reason is:  the argument to your eqCons is a function that promises to work /for all/ types 'b', so the eqCons function can actually choose any type, including 'a'
09:27:27 <mm_freak> without 'forall' the type is specified by the caller of eqCons
09:27:43 <johnw> ah, don't listen to me, mm_freak has it
09:28:05 <mm_freak> because then the 'forall' is at the front of the definition, which means:  eqCons itself promises to work /for all/ types 'b', so it can't just work for 'a'
09:28:46 <mm_freak> in better words:  eqCons can't just choose b = a
09:28:55 <mm_freak> because the caller might choose b ≠ a
09:29:23 <david1991> Ah I see... but the caller isn't defined yet!
09:29:32 <mm_freak> it doesn't have to be
09:29:36 <david1991> :|
09:29:37 <johnw> it's recursive, you are calling yourself
09:29:41 <mm_freak> eqCons would make a promise it can't fulfill
09:29:42 <mm21> ion: i don't think so :)
09:29:51 <david1991> OH I SEE!
09:30:04 <david1991> thank you!
09:30:25 <mm_freak> david1991: mentally (or even explicitly) put a 'forall' in front of the definition =)
09:31:24 <mm_freak> david1991: for the same reason you can't write this:
09:31:29 <mm_freak> x :: a
09:31:29 <mm_freak> x = 3
09:31:45 <mm_freak> because the "caller" (user) of 'x' may choose something else for 'a' like String
09:31:47 <david1991> however I thought that GHC would automatically put foralls into function types, since if I define id' :: a -> a, this is correct.
09:31:56 <mm_freak> yes, it does
09:31:59 <mm_freak> x :: forall a. a
09:32:03 <mm_freak> that's the same as x :: a
09:32:07 <david1991> so why isn't it do with the b thing?
09:32:13 <david1991> doing *
09:32:24 <mm_freak> because mind reading hasn't been implemented into GHC yet =)
09:32:29 <david1991> lol
09:32:42 <mm_freak> -XDoWhatIMean
09:32:52 <mm_freak> bbl
09:33:29 <TheRedMood> http://learnyouahaskell.com/starting-out#im-a-list-comprehension
09:33:36 <TheRedMood> What if I have not taken a course in mathematics?
09:33:51 <johnw> don't worry
09:34:12 <TheRedMood> only part i can relate to is the |
09:34:20 <TheRedMood> the <- lokos like something I have sen in R
09:34:22 <johnw> have you used list comprehensions in Python?
09:34:27 <TheRedMood> No.
09:34:29 <TheRedMood> :(
09:34:32 <TheRedMood> But I do know python!
09:34:38 <johnw> you know what, you can ignore them for a little while if you want to
09:34:40 <david1991> so when can I assume that GHC automatically puts the forall and when it does not?
09:34:45 <johnw> they are quite cool, but certainly not ever necessary
09:34:54 <TheRedMood> So please if you have some way to relate it to that, then I could understand it :D
09:35:05 <johnw> [ x | x <- [1,2,3]]
09:35:10 <Saizan> david1991: it doesn't automatically put foralls into function types, it automatically puts them just after ::
09:35:18 <johnw> this means: return a list where each member of the list is drawn from the list [1,2,3]
09:35:21 <david1991> oh ic
09:35:34 <TheRedMood> So
09:35:38 <TheRedMood> The part before the |
09:35:39 <Saizan> e.g. x :: a is the same as x :: forall a. a
09:35:42 <TheRedMood> Is the doing function
09:35:50 <TheRedMood> And the part behind the |
09:35:52 <TheRedMood> is the data ?
09:35:56 <johnw> it's an expression, not a functio
09:35:57 <johnw> n
09:36:06 <johnw> it's the expression that represents what each member of the output list will become
09:36:15 <johnw> > [ x * 2 | x <- [1,2,3] ]
09:36:17 <lambdabot>   [2,4,6]
09:36:24 <TheRedMood> Oh
09:36:28 <johnw> the part behind the | is the data, yes
09:36:28 <glguy> TheRedMood: Did you read that page yet? None of the text seems to assume you've used that in math before
09:36:47 <TheRedMood> glguy, I have yes, but it was very confusing.
09:37:12 <TheRedMood> johnw, So it would be sort of like a reverse | in bash?
09:37:22 <TheRedMood> Sending data to the left not the right
09:37:23 <TheRedMood> ?
09:37:28 <srhb> Nothing like it, no.
09:37:32 <johnw> not really
09:37:36 <johnw> it's a bit more like this:
09:37:38 <TheRedMood> Why not?
09:37:42 <TheRedMood> Oh
09:37:46 <johnw> echo 1 2 3 | while read elem ; do echo $elem ; done
09:37:46 <TheRedMood> Ignore that question and go on please.
09:37:49 <johnw> if you wanted a bash analogy
09:37:55 <TheRedMood> Yeah
09:38:00 <TheRedMood> But here it is going ->
09:38:06 <TheRedMood> in haskell it goes
09:38:08 <johnw> but that's really underpowered compared to these list comprehenions
09:38:08 <TheRedMood> <-
09:38:15 <johnw> yes
09:38:16 <TheRedMood> Yeah I know, I am just trying to relate it to something
09:38:17 <TheRedMood> Oh!
09:38:20 <TheRedMood> That was what I meant
09:38:27 <TheRedMood> I am sorry for confusing you.
09:38:46 <quchen> [ x | x <- [1,2,3] ]  means  "list of x where x is drawn out of [1,2,3]"
09:38:48 <TheRedMood> Now it makes a lot more sense :D
09:38:54 <quchen> [ 2*x | x <- [1,2,3] ]  means  "list of 2*x where x is drawn out of [1,2,3]"
09:38:56 <srhb> more like [x*2 | x <- [1,2,3]] -- x*2 where x is drawn from [1,2,3]
09:38:59 <TheRedMood> yeah, now I kind of see it :D
09:38:59 <srhb> Eh, too slow. :P
09:39:09 <TheRedMood> Thanks so much!
09:39:22 <srhb> where should be "for each" instead, really.
09:39:29 <ion> > [ (x,y) | x <- [1,2,3], y <- ['a','b','c'] ]
09:39:30 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
09:39:38 <johnw> ion: too much :)
09:40:12 <TheRedMood> ...
09:40:14 <quchen> TheRedMood: Do you understand ^^
09:40:14 <quchen> ?
09:40:16 <TheRedMood> I actully get that
09:40:18 <srhb> Mostly it's because that simplifcation tends to break down.
09:40:44 <TheRedMood> He is making y in a list with 'a', 'b' and 'c' in it
09:40:51 <TheRedMood> and x a list with 1, 2, 3 in it
09:41:17 <TheRedMood> Then he is "outputing" or "using" them to make a tuple of x and y
09:41:19 <TheRedMood> Am I wrong?
09:41:36 <johnw> the output list is "every combination of x with y"
09:41:42 <srhb> It's not really that y or x are lists. It's more like 'for each x drawn from [1,2,3], for each y drawn from "abc": (x,y)'
09:41:44 <johnw> it's called a cross-product of two lists (or sets)
09:41:47 <ion> for x in [1,2,3]: for y in ['a','b','c']: yield (x,y)  (or something like that)
09:41:55 <TheRedMood> ...
09:42:06 <TheRedMood> You managed to make something very simple, very hard, incredibly fast
09:42:07 <ion> [ (x,y) for x in [1,2,3] for y in ['a','b','c'] ]
09:42:09 <TheRedMood> :|
09:42:13 <johnw> yeah, that's why I told ion it was too much :)
09:42:17 <johnw> just ignore that usage for now
09:42:20 <TheRedMood>  No.
09:42:26 <TheRedMood> If I get the wrong idea now
09:42:30 <TheRedMood> it might stick :)
09:42:40 <TheRedMood> Might aswell just bear trough it and come out with the correct idea.
09:43:32 <ion> (To be clear, those last two lines were Python… if they happen to be valid.)
09:43:45 <TheRedMood> ion, yeah, trying my hardest to remember python :)
09:43:48 <TheRedMood> But
09:43:50 <TheRedMood> Wait
09:44:06 <TheRedMood> It is taking the head of each list(if it is a list) and using that
09:44:12 <TheRedMood> So it is using every possible value?
09:44:17 <srhb> Yes.
09:44:22 <TheRedMood> And
09:44:24 <TheRedMood> Oh
09:44:25 <maki`> for each x it goes through every y
09:44:25 <srhb> I don't like thinking about it as head, really.
09:44:26 <TheRedMood> Then the question is
09:44:38 <TheRedMood> Which one of them is the outer for loop(if we compare it to python)
09:44:44 <ion> The first one.
09:45:00 <TheRedMood> So the first statment is always the first for loop?
09:45:04 <srhb> Yes
09:45:08 <TheRedMood> Again I am making analogies here.,
09:45:10 <TheRedMood> Okay.
09:45:18 <TheRedMood> Now are there anythin more fancy stuff?
09:45:35 <quchen> TheRedMood: "|" = where. "<-" = is drawn from. "," between "<-"s = and. [...] = list. That's it. [x*y | x <- [1,2], y <- [3,4,5]] = list of x*y WHERE x IS DRAWN FROM [1,2] AND y IS DRAWN FROM [3,4,5]
09:45:35 <TheRedMood> About list comprehentions
09:45:38 <srhb> For list comprehensions? Only conditions, and what they desugar to
09:45:45 <TheRedMood> desugar?
09:45:56 <TheRedMood> quchen, thanks :)
09:45:58 <srhb> It's just fancy syntax for what the list monad does.
09:46:05 <TheRedMood> monad?
09:46:10 <TheRedMood> I have heard that before somewhere
09:46:11 <quchen> srhb: Don't start with desugaring. Too early. Way too early.
09:46:17 <srhb> I wasn't going to.
09:46:18 <TheRedMood> O.o
09:46:26 <srhb> It's not THAT bad though.
09:46:29 <johnw> TheRedMood: read more into the learn you a haskell stuff
09:46:35 <srhb> You read the function definitions and you finally understand what is happening.
09:46:39 <TheRedMood> johnw, again thanks :)
09:46:44 <quchen> TheRedMood: Monads are something you'll learn about later. You don't need to know them to understand list comprehensions.
09:46:44 <srhb> But yes, a bit early.
09:46:53 <srhb> (Yes you do)
09:46:54 <johnw> we're always happy to help when you've got more questions
09:46:57 <maki`> TheRedMood here is a fun one, from LYAH tutorial. an infinite list of right triangles
09:46:58 <ion> > [ (x,y) | x <- [1,2,3], y <- ['a','b','c'], even x ]
09:47:00 <lambdabot>   [(2,'a'),(2,'b'),(2,'c')]
09:47:06 <srhb> But you don't need to understand the list monad to USE list comprehensions.
09:47:11 <maki`> > [ (a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
09:47:12 <ion> for x in [1,2,3]: for y in ['a','b','c']: if even(x): yield (x,y)
09:47:15 <lambdabot>   mueval-core: Time limit exceeded
09:47:23 <maki`> > [ (a,b,c) | c <- [1..], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
09:47:27 <lambdabot>   mueval-core: Time limit exceeded
09:47:39 <TheRedMood> thanks all of you. I heard a lot of wierd things about the haskell community, but it turns out you are just a very friendly bunch :D
09:47:43 <srhb> maki`: You're forgetting an upper limit
09:47:49 <maki`> should have added take, won't flood the channel
09:47:54 <johnw> you've heard weird things about the community?  or just the language?
09:47:54 <srhb> Yes it would.
09:47:56 <srhb> Wouldn't it?
09:48:01 <srhb> *thinks*
09:48:07 <quchen> srhb: Lambdabot stops after one line
09:48:10 <quchen> > [1..]
09:48:11 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:48:14 <srhb> Oh.
09:48:22 <maki`> how come that worked?
09:48:23 <TheRedMood> johnw, The community, and the language. Most of it is the sterio typical, "Mathematics on meth" stuff.
09:48:33 <TheRedMood> > 2 + 2
09:48:35 <lambdabot>   4
09:48:36 <TheRedMood> :D
09:48:41 <TheRedMood> What a good boy!
09:48:44 * TheRedMood pets lambdabot 
09:49:04 <johnw> TheRedMood: i was terrible at math and hating it my whole life; now because of Haskell I'm not only learning math again, but really enjoying it
09:49:18 <TheRedMood> johnw, I am bad with numbers in general.
09:49:20 <johnw> Haskell is like my "math playground"
09:49:27 <quchen> TheRedMood: The most important thing is not to be scared of the math. As demonstrated earlier, we're all pretty happy with the mathy stuff (e.g. monads), and that is most likely not the best way to teach Haskell (nor is it required).
09:49:39 <TheRedMood> johnw, but I like to challange myself. I get bad grades at school, so this is my attempt at fixing that, and doing what I like at the same time :D
09:50:00 <TheRedMood> quchen, yeah, i learned that fear is the only wall when it comes to learning, the first time I dared to open a terminal window.
09:50:03 <johnw> i always fought just to pass, so you're in good company
09:50:05 <quchen> It's also not required to know math to learn Haskell. However, many people enjoy adding mathy stuff. (Because it's awesome)
09:50:08 <ion> theredmood: The people who say that use said mathematical stuff all the time, they just don’t know it.
09:50:29 <TheRedMood> Well I have to take a quick break now.
09:50:32 <TheRedMood> My head is hurting X3
09:50:35 <TheRedMood> See ya all later
09:50:41 <ion> They probably use monoids daily, for instance.
09:50:45 <quchen> Bye :-)
09:51:08 <johnw> ion: people start using monoids in grade school, they just never call them that :)
09:51:12 <ion> yes
09:51:31 <quchen> johnw: They use things that are monoids. Big difference to monoids.
09:51:38 <johnw> that's a good point
09:51:40 <ion> theredmood: But because they don’t recognize the common theme they have less tools to reason about it.
09:52:19 <johnw> i ran into "operads" the other day
09:52:26 <quchen> Never heard of that.
09:52:33 <johnw> it's yet another way to define monads
09:52:34 <quchen> (Never heard of monoids in math either)
09:52:37 <quchen> Oh.
09:52:37 <johnw> like, the 4th way that I know of now
09:53:36 * hackagebot rematch 0.1.0.0 - A simple api for "matchers"  http://hackage.haskell.org/package/rematch-0.1.0.0 (TomCrayford)
09:53:50 <johnw> 1) via adjunction, 2) as functorial monoids, 3) via operads, 4) via the traditional "define Functor, then Applicative, then Monad"
09:53:51 <quchen> I think understanding monads the mathematical way is far less useful that getting a working knowledge if you just want to use them in Haskell.
09:54:24 <johnw> quchen: for only using monads, that's fine
09:54:33 <quchen> "Functor with return and join" is as far as I've gotten so far and it's fairly useful.
09:54:38 <johnw> quchen: but for creating new monads and discovering new applications for them, the theory really helps
09:54:57 <quchen> johnw: Is there more to it than seeing something you can flatten and inject stuff in?
09:54:57 <johnw> look at how much lens has developed due to edwardk's profound understanding of functors
09:55:22 <johnw> quchen: a monad is just an enriched functor
09:55:25 <TheRedMood> functors?
09:55:26 <quchen> johnw: edwardk makes a bad example. He could've gotten that out of chewing gum if he had to.
09:55:36 <quchen> TheRedMood: PSSST we thought you were gone :D
09:55:42 <johnw> TheRedMood: oh, I thought you had left!
09:55:46 <TheRedMood> Haha
09:55:46 <TheRedMood> X3
09:55:51 <TheRedMood> Well I am going now
09:56:01 <TheRedMood> I am just noting down everything you guys say so i can google it later
09:56:03 <TheRedMood> GOING NOW!
09:56:04 <TheRedMood> :;D
09:56:15 <quchen> NOOO
09:56:18 <quchen> DON'T DO IT
09:56:27 <quchen> You're not ready to open Pandora's Box!
09:56:31 <hiptobecubic> lyah will take you pretty far in understanding the conversations in this room. at least enough to ask better questions
09:56:41 <johnw> quchen: so, yeah, a functor which can collapse "F (F a)" down to "F a" is a exactly a monad
09:56:54 <Dodek> quchen: for instance, every adjunction gives rise to a monad
09:56:59 <quchen> (I'm serious. Finish LYAH first, as in a first read, not a full understanding. Then start googling.)
09:57:21 <Dodek> quchen: so if you know about adjunctions, spotting one give you a monad for free
09:57:22 <johnw> yes, and the *reason* why a monad can collapse F (F a) down to F a is explained by the adjunction
09:57:23 <quchen> johnw: How is return implemented with this?
09:57:29 <ion> theredmood: Hint: when you google for functors and find the Wikipedia page, do not assume the concept is as unapproachable as the article makes it seem. (I didn’t even look at it, but i know what Wikipedia articles about concepts such as that are always like.)
09:57:44 <byorgey> quchen: you can't, you also need a return separately
09:57:45 <johnw> quchen: return is just the operation of the function, a -> F a
09:57:51 <johnw> s/function/functor
09:58:00 <byorgey> that's not the operation of the functor
09:58:08 <johnw> I thought any functor can map a to F a
09:58:11 <byorgey> no
09:58:16 <johnw> ah, enlighten!
09:58:23 <byorgey> any functor can map (a -> b) to  (F a -> F b)
09:58:26 <cmccann> it maps objects A to F A
09:58:33 <cmccann> that's not the same thing as mapping a value in Haskell-land
09:58:37 <johnw> ah
09:58:46 <johnw> so, this is the I -> T natural transformation at work?
09:58:53 <cmccann> that is, it's mapping the type, not a value
09:58:57 <cmccann> yes
09:59:02 <byorgey> right.  The  I -> T  natural transformation is exactly 'return'.
09:59:06 <hiptobecubic> I -> T ?
09:59:08 <cmccann> (I a -> T a) is equivalent to (a -> T a)
09:59:14 <johnw> ok, sorry quchen, it's a functor that can collapse F (F a) to F a, and that can map any value a to F a
09:59:18 <hiptobecubic> identity?
09:59:20 <byorgey> hiptobecubic: where I is the identity functor
09:59:26 <cmccann> i.e. (forall a. Identity a -> m a)
09:59:27 <hiptobecubic> ok
09:59:43 <beaky> hello
09:59:49 <byorgey> hiya beaky
09:59:55 <johnw> yes, the true identity functor that maps A -> A
10:00:00 <beaky> what isn't Haskell good at?
10:00:05 <srhb> beaky: Tell me, do you have a bot that automagically writes "hello" when you join a channel?
10:00:06 <johnw> not quite the same as the Haskell "Identity" functor
10:00:08 <quchen> johnw: Well, that's the definition of a Haskell monad: fmap, return, join
10:00:18 <johnw> quchen: yes! :)
10:00:18 <quchen> Even I understand that. Nothing profound in that! ;-)
10:00:21 <beaky> srhb: I type in hello as soon as I join a channel :D
10:00:23 <srhb> @faq Can Haskell be bad at anything?
10:00:23 <lambdabot> The answer is: Yes! Haskell can do that.
10:00:39 <johnw> quchen: it's only profound in where the meaning of those definitions come from.  but you're right, monads are quite simple
10:00:40 <quchen> johnw: But I can see how all the free monad stuff and adjoint things and comonads can be helpful.
10:00:43 <cmccann> the other half is a natural transformation (T ∘ T) -> T which works out to be join if you express it in Haskell
10:01:27 <quchen> johnw: I wish I understood comonads like I understand monads. I'm sure they're as easy to use as monads, but the comonad mountain is still ahead of me
10:01:32 <quchen> And it keeps bugging me
10:01:43 <johnw> a comonad just flips the arrows
10:01:43 <quchen> Maybe it'd be better if we had od-notation for comonads :-)
10:01:46 <byorgey> beaky: it's not good for writing really low-level stuff like hardware drivers
10:01:54 <johnw> if a monad is I -> T, TT -> T, a comonad is T -> I, T -> TT
10:01:54 <byorgey> at least not directly.
10:02:10 <cmccann> comonads don't seem to lend themselves to anything as tidy as do notation
10:02:15 <quchen> johnw: I know. I also know the implementation. Reading the code however makes me feel stupid. Store comonad, oh what are you doing
10:02:16 <cmccann> though maybe there is something similar
10:02:35 <quchen> Took me long enough to understand the Stream instance
10:03:03 <johnw> Store is a lot more obvious in adjunction form, granted
10:03:09 <cmccann> store is dual of state, right?
10:03:27 <johnw> the way Haskell defines Monads with return and >>= actually makes some really simple things seem more complicated than they are
10:03:37 * cmccann can never remember what the names people use for various comonads mean, where people means mostly edwardk
10:03:38 <johnw> cmccann: i don't think store is costate
10:03:48 <johnw> i think store is the costate comonad
10:04:04 <glguy> store?
10:04:09 <quchen> :t Store
10:04:10 <lambdabot> Not in scope: data constructor `Store'
10:04:12 <johnw> the state comonad is something edwardk calls "Context"
10:04:13 <quchen> Hm.
10:04:19 <johnw> (at least, in lens)
10:04:27 <cmccann> also, (>>=) is used because it's convenient to program with, even if it obscures the basic definitions
10:04:31 <glguy> Context is just a generalized Store
10:04:44 <quchen> edwardk is the secret author of the Haskell 2011+ standard
10:05:27 <hpaste> johnw pasted “costate.hs” at http://hpaste.org/80701
10:05:43 <johnw> there is Context, which has been called 3 things by 3 people
10:05:50 <johnw> including both Store and Costate
10:05:52 <quchen> I really hope people start using (&) from Control.Lens (= flip ($)) and it gets added to Data.Function
10:05:57 <quchen> Gooo EdK
10:06:08 <beaky> ah
10:06:09 * cmccann still likes (|>). :[
10:06:18 <quchen> cmccann: BOOOOOOOOOO
10:06:21 <beaky> also I heard it is hard to find out the performance of lazy code
10:06:27 <quchen> (Dumb to type on a German keyboard :-( )
10:06:37 <cmccann> johnw: that doesn't look like costate unless a and b are the same type
10:06:49 <quchen> Gotta go, have a nice afternoon guys
10:07:27 <johnw> ok, is State Hom ⊣ Prod?
10:07:52 <srhb> beaky: It's very different to reason about eg. memory usage. Perhaps even worse.
10:08:10 <johnw> which would be (s -> (s, a)), right?
10:08:12 <cmccann> State is the currying adjunction
10:08:17 <johnw> or is that Prod ⊣ Hom?
10:08:32 <johnw> (s, s -> a)
10:08:48 <johnw> i think the latter is Store, isn't it?
10:09:10 <cmccann> it's the same adjunction, just functor composition in the opposite order
10:09:23 <beaky> ah
10:09:36 <johnw> oh, i didn't realize adjoints could be flipped and mean the same adjunction
10:09:37 <cmccann> state is ((s ->) . (s,)) so costate would be ((s, ) . (s ->))
10:09:43 <cmccann> the adjoint isn't flipped
10:09:56 <cmccann> there are four functors involved here
10:10:10 <johnw> what are they?
10:10:14 <cmccann> the adjoint functors, and the functors you get from composing them in either order
10:11:29 <cmccann> if F is left adjoint to G, then (F∘G) is a monad and (G∘F) is a comonad
10:11:44 <cmccann> er
10:11:46 <cmccann> other way around I think
10:11:54 <johnw> i think you're right
10:11:56 <johnw> I have:
10:11:58 <johnw> instance Monad   (Hom d) (Prod d)
10:11:58 <johnw> instance Comonad (Prod d) (Hom d)
10:12:02 <luauser> .
10:12:13 <johnw> so that fits
10:12:20 <johnw> so yeah, Store is the state comonad
10:12:33 <johnw> so what is costate?  is that the same thing as the state comonad?
10:12:55 <cmccann> I would assume that costate is synonymous with store
10:13:25 <cmccann> I can't think of any sensible meaning for costate other than the comonad arising from the same adjunction as state
10:13:58 <johnw> costate would be ((s, a) -> s), wouldn't it?
10:14:32 <cmccann> that's not even a functor
10:14:39 <cmccann> well, a Functor
10:14:46 <cmccann> the a is in contravariant position
10:14:53 <johnw> ah, ok
10:15:03 <johnw> i thought there were more monads/comonads present here than I guess there are
10:15:03 <cmccann> different kind of duality there :P
10:15:19 <johnw> so is Store just over-named then?
10:15:41 <johnw> (it could be a contravariant functor, couldn't it?)
10:15:59 <cmccann> well, Reader is overnamed as well
10:16:05 <cmccann> a.k.a. Hom
10:16:29 <cmccann> and no, contravariant functors = functors to the opposite category = not endofunctors
10:16:43 <cmccann> so monads and comonads are irrelevant concepts
10:17:23 <cmccann> however, note that you can have a monad in Hask that arises from an adjunction involving functors to/from another category
10:17:52 <cmccann> in which case the monad and comonad may exist as Functor instances but the adjoint functors can't be defined as Functor instances
10:18:02 <cmccann> er, monad or comonad
10:18:06 <cmccann> not both obviously :]
10:18:24 <johnw> interesting!
10:18:37 <johnw> I guess we lost quchen somewhere along the way there :)
10:18:47 <johnw> and who says we're mathy!
10:18:59 <cmccann> for example, if you think of [] as the usual free monoid functor that involves a different category
10:19:10 <johnw> k
10:19:11 <byorgey> quchen left right after "<cmccann> if F is left adjoint to G, then (F∘G) is a monad and (G∘F) is a comonad"
10:19:13 <TheRedMood> ...
10:19:20 <byorgey> must have been offended that cmccann got it the wrong way around
10:19:25 <cmccann> hahaha
10:19:28 <cmccann> oh well :[
10:19:33 <TheRedMood> functors
10:19:53 <TheRedMood> ...
10:20:00 <cmccann> johnw: or take the generic contravariant functor (-> r), which ends up being self-adjoint-ish with its counterpart coming back over from the opposite category
10:20:03 <TheRedMood> And this is required to understand list compherhentions?
10:20:06 <TheRedMood> O-o
10:20:08 <johnw> TheRedMood: functors are awesome, and you'll spend many a long month pondering them if you go down the road less travelled by
10:20:14 <cmccann> johnw: the monad you get from that adjunction is Cont
10:20:40 <cmccann> TheRedMood: nothing I've been saying for the past half hour has been required to understand anything in Haskell :P
10:20:41 <johnw> cmccann: yes, I've seen that explication for Cont before
10:20:50 <TheRedMood> Phew!
10:20:51 <TheRedMood> :D
10:21:01 <johnw> yeah, you don't NEED any of this
10:21:07 <TheRedMood> johnw, sorry but that sentence did not make any sense
10:21:08 <TheRedMood> X3
10:21:13 <johnw> in the same way that you don't need fun to survive :)
10:21:22 <TheRedMood> O_O
10:21:34 <TheRedMood> Being 2 mentally, I can't not grasp the consept of life without fun
10:21:55 <johnw> it probably sounds like crazed gobbledy gook, as it did to me in the beginning
10:21:59 <cmccann> TheRedMood: what we're talking about is a mathematical basis for things that exist in haskell. it's good for understanding WHY they work in Haskell, but not needed to understand how they work or how to use them
10:22:10 <johnw> but once you get to a certain point, this stuff is really quite beautiful
10:22:13 <Rembane> johnw: When does it stop sounding like crazed gobbledy gook?
10:22:20 <TheRedMood> cmccann, I want to understand the basics. Why stuff works is for me very important.
10:22:23 <johnw> Rembane: it took a couple years for me
10:22:40 <Rembane> johnw: Good. Then I don't need to feel stupid. :)
10:22:43 <byorgey> Rembane: 5:14pm on 3 June
10:22:44 <johnw> and I had to start learning math on the side
10:22:48 <Rembane> byorgey: :D
10:22:51 <dmwit> Still sounds like gobbledy-gook to me, and I participated in a two-year-long category theory reading group.
10:22:58 <TheRedMood> O_O
10:23:05 <TheRedMood> Well then, I am backing out of here
10:23:13 <TheRedMood> Seems like the likes of me cannot do this.
10:23:20 <dmwit> Nonsense.
10:23:20 <TheRedMood> T_T
10:23:25 <johnw> oh yo ucan
10:23:27 <dmwit> Anybody can do it, with some determination and focus.
10:23:42 <TheRedMood> dmwit, Is deretimination alone going to do it?
10:23:44 <johnw> the thing no one is telling you is that most of what we're talking about is absurdly simple, once you understand the language it uses to describe the concepts
10:23:47 <TheRedMood> dmwit because i got that.
10:23:48 <byorgey> TheRedMood: and time.
10:23:53 <cmccann> yes, it sounds far more difficult than it is.
10:24:06 <TheRedMood> So with some time and the guts, this is pheasable?
10:24:11 <johnw> absolutely
10:24:15 <cmccann> and learning enough Haskell to understand how it translates into Haskell is a decent stepping stone to understanding the general concept
10:24:22 <johnw> in fact, you'll say, "Is that all it was?" when you get it :)
10:24:26 <TheRedMood> Then I'm here to stay
10:24:33 <`nand`> (not if you keep asking question about whether or not to do something, instead of just doing it)
10:24:33 <cmccann> (as long as you don't get confused because of assumptions from Haskell that don't apply in general)
10:24:35 <TheRedMood> johnw had that with pointers in C :)
10:25:33 <`nand`> cmccann: what do you mean, not all functors are strong!?
10:26:21 <cmccann> `nand`: in fact, not all categories are cartesian closed
10:26:22 <dmwit> What do you mean, not all categories have exponentials?
10:26:26 <cmccann> shocking, I know
10:26:34 <`nand`> utter blasphemy
10:26:34 <dmwit> dang, beat to the punch by just a few seconds =P
10:26:47 <johnw> there are categories without exponentials?
10:26:53 <dmwit> plenty, yep
10:26:56 <cmccann> being cartesian closed is overrated anyhow
10:26:57 <johnw> example me
10:27:08 * cmccann likes his linear logic thanks
10:27:19 <dmwit> Well, the category of lenses is my personal favorite example. =)
10:27:36 <johnw> did edwardk create a Lens category now?
10:27:48 <`nand`> any discrete category :P
10:28:00 <dmwit> johnw: Oh, are we restricting ourselves to Haskell Category's, then?
10:28:10 <johnw> oh, I guess not
10:28:10 <`nand`> except maybe a few trivial ones
10:28:15 <johnw> that wouldn't be sporting now, would it
10:28:29 <cmccann> the automaton arrow doesn't give you a cartesian closed category, does it?
10:28:37 <dmwit> `nand`: Hm, I was going to say that, but then stopped out of nervousness that discrete categories might be featureless enough to have exponentials by accident...
10:29:15 <`nand`> dmwit: oh, you could be right
10:30:06 <dmwit> I guess not. They don't even have products, which is sort of a prerequisite to exponentials in the formulation I'm looking at on Wikipedia.
10:30:33 * cmccann notes that "exponential" implies being cartesian closed, and that you can have categories with an "internal hom" that isn't an exponential
10:30:50 <johnw> what does it imply that?
10:31:01 <`nand`> exponential implies having a terminal object?
10:31:09 <johnw> s/what/why
10:31:17 <cmccann> by definition is why
10:31:33 <dmwit> Don't you need exponentials and also a nullary product?
10:31:33 <cmccann> this is one of those "not everything is Haskell" moments I suspect :P
10:31:53 <cmccann> an exponential object is defined as an internal hom in a cartesian closed category
10:32:06 <johnw> i see that cartesian closed means (a,b) implies (a -> b)
10:32:18 <cmccann> you can have categories with an internal hom, that even behaves like higher-order functions and all that, but not be an exponential
10:32:19 <johnw> does that imply exponentation because of b^a?
10:32:58 <johnw> oh, I see, it's the third property of cartesian closedness
10:33:08 <johnw> Any two objects Y and Z of C have an exponential Z^Y in C.
10:33:54 <johnw> cmccann: can you name such a category?
10:34:34 <cmccann> johnw: my favorite example which everyone is probably tired of is linear logic
10:34:51 <cmccann> if you build a type system based on that you have higher-order functions and "currying" and all that
10:34:56 <johnw> http://ncatlab.org/nlab/show/linear+logic?
10:35:07 <cmccann> but the resulting category of types and functions is not cartesian closed
10:35:24 <cmccann> yes, plato.stanford.edu/entries/logic-linear/ is also helpful
10:35:33 <cmccann> also en.wikipedia.org/wiki/Linear_logic
10:35:44 <johnw> thanks, i'll read up on that
10:36:17 <mreh> I'm using alsa-pcm, and I get bursts of noise, am I supposed to use a buffered version to make it sound smooth?
10:36:26 <cmccann> johnw: hpaste.org/75222 might help you translate it into what it would mean as a programming language type system
10:36:51 <`nand`> a Haskell example, how familiar
10:38:35 <`nand`> can't you ditch Category and define your own with PolyKinds?
10:38:48 <cmccann> `nand`: yes, but I didn't bother
10:39:01 <cmccann> that code was obviously a work in progress :P
10:39:23 <cmccann> mostly to help me build intuition for what linear logic means computationally
10:44:55 <nh2> how can I generate an hi file only with ghc?
10:45:41 <nh2> "ghc -fno-code -ohi out.hi myfile.hs" gives me "ghc: -ohi can only be used when compiling a single source file"
10:45:56 <nh2> althought there is only a single source file
10:49:52 <nh2> I better ask this on stackoverflow
10:50:34 <geekosaur> if I had to guess, -fno-code suppresses part of the compilation necessary
10:51:44 <nh2> geekosaur: but then the error message is wrong
10:52:00 <geekosaur> no, the error message has two parts, both must be satisfied
10:52:13 <geekosaur> you have the single source file but you are suppressing compilation...
10:52:14 <`nand`> ! is pronounced "of course" (or sometimes "bang")
10:52:16 <`nand`>  ? is pronounced "why not"
10:52:18 <`nand`> okay, that's just silly enough to interest me
10:54:19 <nh2> geekosaur: two parts? I see only one being written down there
10:55:12 <geekosaur> "can only be used with a single source file" w=is one thing.  "can only be used when COMPILING a single source file" has two requirements
10:55:43 <nh2> geekosaur: aah you're right
10:56:08 <nh2> (although I would prefer "-ohi cannot be used with -fno-code")
10:56:24 <nh2> geekosaur: now we only have to find out how to do it instead. I posted on http://stackoverflow.com/questions/14306934/haskell-how-to-only-generate-hi-file-with-ghc
10:56:34 <`nand`> ghc -ohi test.hi test.hs -- gives me the same error
10:56:50 <ziman> have you tried leaving out the *.hi name?
10:56:51 <geekosaur> (and yes, compilation in ghc does tangle levels enought hat suppressing code generation might cause issues.)
10:56:58 <geekosaur> huh
10:57:16 <geekosaur> hm, actually
10:57:19 <geekosaur> try adding -c
10:57:26 <nh2> ah there we go, an ans ... yes
10:57:28 <geekosaur> I wonder if this is an interaction with --make being on bu default
10:57:33 <nh2> that seems to work
10:57:35 <Alex_Sevastopol> hello word :D
10:57:41 <Alex_Sevastopol> world
10:58:01 <nh2> geekosaur: oh no it doesnt
10:58:06 <geekosaur> or maybe not even that, just the assumetion that it's to build an executable
10:58:42 <`nand`> hmm
10:58:54 <`nand`> -c suppresses generating an executable, and -odir can be used to redirect the .o file
10:59:44 <`nand`> leaving you with just the .hi file
11:00:25 <nh2> `nand`: but I do not want to do the code generation phase at all (this speeds up typechecking by at least factor 3)
11:00:40 <TheRedMood> Oh
11:00:42 <TheRedMood> NEW QUESTION!
11:00:43 <TheRedMood> :D
11:01:01 <johnw> yes? :)
11:01:27 <TheRedMood> As I said I am not into deeper mathematics(yet, i do hope i will at some point), but some of the terminology of lists are confusing me
11:01:32 <TheRedMood> Head is okay
11:01:34 <TheRedMood> So is tail
11:01:37 <TheRedMood> But init.
11:01:46 <johnw> look for the picture of the big caterpillar
11:01:48 <johnw> explains it all
11:02:03 <TheRedMood> Yes
11:02:08 <TheRedMood> But why is it called init?
11:02:12 <johnw> a list is head+tail or init+last
11:02:16 <johnw> init = initial part of the list
11:02:18 <johnw> all but last
11:02:49 <Eelis> TheRedMood: it's pretty arbitrary. best to just memorize and move on :)
11:02:50 <TheRedMood> So there is no mathematical about it?
11:02:53 <TheRedMood> oh
11:02:54 <TheRedMood> okay
11:02:55 <TheRedMood> Thanks :)
11:03:13 <TheRedMood> Now then, lets try to handle those list comprehntions
11:03:26 <TheRedMood> And maybe get better spelling too. Maybe.
11:03:43 <frerich> johnw: Hrm, I think I'll never be able to read Eric Carle's "The Very Hungry Caterpilla" to my son again without thinking of Haskell lists.
11:04:04 <johnw> frerich: and that's a good thing! :)
11:04:23 <`nand`> cmccann: after reading the “$1 lollipop candy bar” explanation this is beginning to make some sense
11:04:44 <johnw> `nand`: where is that explanation?
11:04:55 <cmccann> `nand`: that explanation, like most, tends to fall down when you get to multiplicative disjunction
11:04:55 <`nand`> https://en.wikipedia.org/wiki/Linear_logic#The_resource_interpretation
11:05:16 <cmccann> but it's a reasonable place to start
11:05:46 <TheRedMood> AH!
11:06:01 <TheRedMood> So list compherhentions don't work without a list.
11:06:06 <TheRedMood> That makes sense.
11:06:40 <thetallguy> anyone know of an online pdf for 2009 Dan Piponi, Commutative Monads, Diagrams...?
11:07:43 <TheRedMood> hm
11:08:06 <TheRedMood> Another question.. in LYSFGG they use the variables xs and x
11:08:12 <TheRedMood> is this common practice?
11:08:15 <thetallguy> maybe is wasn't a paper, just a talk
11:08:16 <johnw> we just call it LYAH, easier to type
11:08:17 <srhb> LYAH?
11:08:21 <srhb> TheRedMood: And yes
11:08:23 <TheRedMood> LYAH.
11:08:25 <TheRedMood> got it.
11:08:25 <srhb> TheRedMood: xs for x in plural
11:08:27 <johnw> xs means "lots of x's"
11:08:35 <srhb> Pronounced "x'es"
11:08:36 <johnw> or, 0 or more ;)
11:08:40 <TheRedMood> xs is often a list?
11:08:41 <TheRedMood> Haha
11:08:45 <johnw> yeah, almost always
11:08:46 <TheRedMood> error handling.
11:08:50 <TheRedMood> or tuples
11:09:02 <srhb> xs is conventionally only used for lists.
11:09:06 <TheRedMood> oh
11:09:10 <TheRedMood> Thanks for that head up!
11:09:26 <TheRedMood> Not that I am going to write anything release worthy for a while, but that was a nice note
11:09:45 <srhb> It makes sense because that "tail" can indeed have 0 or more "x'es"
11:10:00 <`nand`> I like to use it when pattern matching on any tree-like recursive structure
11:10:34 <TheRedMood> O_O
11:10:36 <TheRedMood> WHAT WAS THAT?
11:10:41 <srhb> Trees?
11:10:45 <TheRedMood> No
11:10:47 <`nand`> in short, anything that ‘holds multiple values’, like lists or sets or maps
11:10:48 <TheRedMood> all those people splitting
11:11:04 <TheRedMood> Didn't you see that list?
11:11:15 <johnw> i don't see parts and joins
11:11:17 <TheRedMood> Like the big wall of *<name> has quit
11:11:22 <`nand`> neither do I
11:11:27 <srhb> Off here, too.
11:11:30 <srhb> Too noisy.
11:11:32 <`nand`> but I saw the user count going down from 1000-ish to 975
11:11:39 <TheRedMood> Like the big wall of *<name> has quit(*.net *.split) *
11:11:46 <`nand`> I only have them enabled for people that have been vocal in the past 5 minutes
11:11:56 <johnw> `nand`: in which client?
11:11:56 <TheRedMood> Well okay.
11:12:01 <`nand`> johnw: weechat
11:12:02 <TheRedMood> irssi i bet
11:12:02 <TheRedMood> Oh
11:12:03 <TheRedMood> Okay
11:12:04 <TheRedMood> X3
11:12:30 <johnw> `nand`: i want that feature
11:13:12 <TheRedMood> > 2 != 3
11:13:19 <TheRedMood> ...
11:13:21 <srhb> /=
11:13:24 <TheRedMood> AH!
11:13:28 <TheRedMood> Wait
11:13:29 <`nand`> lambdabot?
11:13:29 <TheRedMood> ...
11:13:31 <`nand`> oh
11:13:31 <TheRedMood> What is that?
11:13:33 <srhb> But lambdabot died.
11:13:39 <`nand`> probably just affected by the netsplit
11:13:41 <TheRedMood> ./= ?
11:13:48 <TheRedMood> What is tnetsplit?
11:13:52 <`nand`> <-- │ lambdabot (~lambdabot@li85-105.members.linode.com) has quit (*.net *.split)
11:14:04 <TheRedMood> YOU saw it!
11:14:09 <TheRedMood> What is netsplit?
11:14:13 <srhb> And irc server dropped from the network.
11:14:18 <srhb> (I think)
11:14:19 <`nand`> https://en.wikipedia.org/wiki/Netsplit
11:14:44 <TheRedMood> Ah
11:14:46 <TheRedMood> That is bad.
11:14:54 <`nand`> give it a few minutes
11:14:55 <TheRedMood> Yeah
11:16:00 <mun> hi
11:16:03 <mun> i have a general logic question
11:16:03 <mun> is it the right notation to write "(a : T) \in S"? that is, a of type T is an instance of a set S?
11:16:17 <TheRedMood> Why do you write /= instead of != ?
11:16:23 <TheRedMood> IS it related to mathematics?
11:16:36 <srhb> Yes, do you remember the equals sign with a bar across it?
11:16:53 <`nand`> TheRedMood: comes from ≠
11:16:57 <srhb> Well, not really mathematics... Just the usual symbol. The bar is just slightly moved to the left :P
11:17:02 <`nand`> Haskell doesn't use ! for logical negation
11:17:12 <TheRedMood> Nanar, thanks.
11:17:18 <otters> we use ! for strictness
11:17:26 <`nand`> or indexing
11:17:28 <TheRedMood> srhb, I have seen it before, but in school we have not gotten that far yet
11:17:33 <TheRedMood> ! ?
11:17:41 <TheRedMood> Can someone give me a example?
11:17:49 <TheRedMood> I have ghci open so if you could write it here.
11:18:01 <johnw> you don't want to deal with ! just yet
11:18:15 <zhulikas> > not True
11:18:16 <TheRedMood> Oh
11:18:17 <TheRedMood> Okay
11:18:17 <otters> [1,2] !! 1
11:18:25 <zhulikas> in other language that would be !true
11:18:27 <TheRedMood> Then I take your word for that.
11:18:32 <`nand`> cmccann: do you know of an alternative intuition that doesn't assume a lot of mathematical knowledge?
11:18:44 <TheRedMood> ...
11:18:46 <TheRedMood> intuition?
11:18:47 <zhulikas> :D
11:19:06 <zhulikas> `nand`, intuition of imperative languages!!!
11:19:24 <TheRedMood> ...
11:19:29 <TheRedMood> I am confused again >.<
11:19:30 <cmccann> `nand`: well, does a computational interpretation count?
11:19:43 <cmccann> i.e. in the same way that Haskell relates to intuitionistic logic
11:20:23 <`nand`> cmccann: well, an intuition of what the things ‘mean’ / how they can be used; rather than just staring at the definitions and figuring out why they type check
11:20:28 <TheRedMood> johnw, I think I will stop trying to understand what they are talking about and go back to more basic jaskell
11:20:30 <TheRedMood> haskell*
11:20:43 <zhulikas> :D
11:20:59 * zhulikas will go back to euler problem #60
11:21:18 <johnw> TheRedMood: an "intuition" is fathoming an abstraction at a deeper level than just a description of its principles
11:21:22 <cmccann> `nand`: game semantics is a nice way to talk about it, but I'm not sure if it gives a good intuition on its own. an interactive toy would help.
11:21:32 <TheRedMood> ---
11:21:43 <TheRedMood> That made a bit more sence johnw
11:21:47 <`nand`> cmccann: actually, the comments on that hpaste are quite clear
11:21:49 <cmccann> `nand`: a computational interpretation is straightforward enough, which is what that hpaste with my encoding in Haskell does
11:22:12 <TheRedMood> johnw, like why something works?
11:22:15 <cmccann> or you can just take it as a logic directly and build intuition for what kind of reasoning it allows
11:22:51 <johnw> usually developing an intuition results in seeing old things in new ways, and realizing that the abstraction you've been trying to understand has been around you all along
11:22:58 <`nand`> the latter is probably what I'm looking for
11:23:05 <cmccann> `nand`: the comments in the hpaste are condensed descriptions of the intuition I built for it over the course of months toying with the ideas
11:24:52 <TheRedMood> johnw, like why the hypotenus in a 30-60-90 triangle will be 2 times the shortest "katet" (I only know the norwegian word).
11:24:59 <TheRedMood> Is that an intuition ?
11:25:11 <cmccann> `nand`: ok. you get the basic idea about "linearity" here, right? can't discard premises, &c.
11:25:32 <`nand`> no, I actually have no idea what ‘linearity’ means
11:25:34 <cmccann> haha
11:25:42 <cmccann> ok, well
11:25:49 <`nand`> other than linear functions on numbers having a constant derivative
11:26:12 <cmccann> computationally it means not reusing terms
11:26:20 <cmccann> every argument to a function must be used exactly once
11:26:35 <cmccann> so e.g. "const" is not allowed
11:26:43 <`nand`> sounds reasonable enough
11:27:03 <johnw> TheRedMood: that depends on what you understood from discovering that "why"
11:27:08 <`nand`> fits into the ‘resource’ interpretation
11:27:18 <cmccann> logically it means not reusing or discarding premises
11:27:46 <cmccann> if you're familiar with how lambda calculus relates to intuitionistic logic you can probably see how that relates
11:27:55 <johnw> TheRedMood: intuitions are almost impossible to just tell someone; usually you have to arrive at them through hard work and applying yourself to exercises which demonstrate an abstraction in various ways
11:28:07 <TheRedMood> ..
11:28:10 <TheRedMood> Abstraction being?
11:28:19 <johnw> a monoid is a simple abstraction
11:28:38 <johnw> a monoid is an algebraic structure that has an identity element, and a binary associative operator
11:28:46 <TheRedMood> monoid?
11:28:50 <johnw> for integers over addition, it's 0 and +, for integers over multiplication, it's 1 and *
11:28:51 <cmccann> `nand`: now, given the assumption of linearity, it turns out you need two kinds of conjunction and disjunction
11:28:55 <TheRedMood> ...
11:29:09 <johnw> because 0 + x = x, x + 0 = x, and x + x = some new x
11:29:22 <johnw> the "monoid" is simply describing the required elements and operations
11:29:25 <Taneb> TheRedMood, a Monoid is a thing where you can smash two together, and there's a kind of thing where if you smash it on something else it doesn't do anything
11:29:28 <johnw> identity, and binary associative operator
11:29:40 <TheRedMood> o-o
11:29:41 <johnw> Monoid is an abstraction, and there are *many* examples of it
11:30:00 <johnw> developing an intuition for Monoids takes a little time, however, _even though the abstraction itself is so basic_
11:30:08 * TheRedMood realizes his brain was just blown 200 meters away from his cranium.
11:30:15 <johnw> but once you have that intution, many things will instinctively look like Monoids to you
11:30:21 <johnw> you'll say to yourself, Oh, that's just a cmonoid
11:30:35 <cmccann> `nand`: with the "additive" versions you only actually have one "thing", essentially
11:30:38 <_nooblearn> I read a SO question called  "why GHC so large?"
11:31:01 <johnw> in fact, it's _because_ the abstraction is so basic that it takes time to grasp
11:31:08 <johnw> it's almost too basic, below the level of typically pragmatic thinking
11:31:18 <_nooblearn> somebody answered that, ghc is bundled as static library and set of shared libraries
11:31:45 <johnw> and so you come to understand Monoid not by studying the rules of Monoids, but by studying many different examples of Monoids, until the common properties just "click"
11:31:55 <cmccann> `nand`: so additively "A and B" means that A and B could both be true but you don't get to have both of them, while "A or B" means you get one or the other
11:31:57 <johnw> that's when you develop the intuition
11:32:02 <_nooblearn> is there any effort underway to bring down , size of ghc install to say below 100 MB?
11:33:07 <cmccann> `nand`: if you think in terms of Haskell with a linearity restriction, Either is the additive disjunction, so it probably means what you'd expect that to mean
11:33:13 <srhb> _nooblearn: I doubt that's a general priority.
11:33:33 <`nand`> cmccann: yeah, that newtype in the hpaste makes sense, as does multiplicative conjunction
11:33:36 <_nooblearn> srnb: ok
11:33:47 <TheRedMood> After I have picked up my brain I will go back to haskell.
11:34:10 <cmccann> `nand`: yeah, in Haskell + linearity (,) is multiplicative conjunction, which I think I said in the hpaste as well
11:34:15 <JoeyA> Is it possible to "shutdown" a socket Handle?  That is, send EOF to the peer, but still be able to receive bytes?
11:34:20 <_nooblearn> i was just wondering Ocaml default install takes like 10 MB on centOS(similar on fedora) and GHC takes 280 MB
11:34:29 <`nand`> newtype Mult f g r = Mult { getMult :: (f r, g r) } -- yesw
11:34:34 <_nooblearn> I googled and found that SO question
11:34:49 <cmccann> `nand`: the additive disjunction and multiplicative conjunction both have "positive polarity"
11:34:55 <edwardk> cmccann: re state/costate, store arises by composing the adjunction for state the other way around, this isn't actually a dual construction. hence why costate is a terrible name, similarly coreader, cowriter, etc.
11:35:20 <cmccann> edwardk: heh ok I'll keep that in mind
11:35:26 <maki`> if I wanted to take a screenshot, manipulate image, save it and display it on the screen, is full blown GUI library like GTK or Qt my only option?
11:35:46 <johnw> edwardk: ah, there you are
11:35:48 <`nand`> I'm a bit confused by the difference between multiplicative disjunction and additive conjunction; the latter means I can pick either but not the other; the former means I can disprove either but then I'm stuck with the other?
11:36:03 <TheRedMood> :o
11:36:12 <johnw> store is the flipped adjunction of state, and not costate
11:36:18 <johnw> edwardk: so what is costate?
11:36:30 <TheRedMood> From listning to you people, it sounds like edwardk i a demigod. Maybe he is :O
11:36:59 <johnw> edwardk can be scary sometimes, let's put it that way
11:37:10 <cmccann> `nand`: yeah, those are confusing. I find it helps to think in terms of dependencies or demands
11:37:18 <TheRedMood> O_O
11:37:26 <TheRedMood> So you are not scary johnw ?
11:37:34 <johnw> heck no, i'm like a giant fuzzy kitten
11:37:40 <TheRedMood> O_o
11:37:41 <`nand`> the scariest person in here is shachaf
11:37:52 <TheRedMood> I am honeslty scared to the bone right now
11:37:54 <shachaf> @arrrr
11:37:59 <shachaf> Aw.
11:38:03 <`nand`> lambdabot netsplitted
11:38:09 <cmccann> `nand`: there's a sense in which negative polarity corresponds to lazy evaluation and positive polarity corresponds to strict evaluation
11:38:51 <cmccann> `nand`: so computationally you can think of the negative polarity connectives as moving demands for values "backwards"
11:40:35 <zhulikas> looking for a function to take all possible combinations of N elements from a list
11:40:43 <cmccann> `nand`: in the additive conjunction, you give it a single demand and it obliges. the choice of what to demand is specified exactly by the additive disjunction; this is the de morgan duality I used to implement it.
11:40:44 <zhulikas> sort of like [a] -> Int -> [[a]]
11:40:51 <`nand`> zhulikas: replicateM ?
11:40:58 <johnw> TheRedMood: but seriously, Haskell is _fun_ once you get past the beginning stages
11:41:02 <zhulikas> is there anything more effective?
11:41:06 <zhulikas> I use replicateM now
11:41:07 <johnw> it's my favorite language of all time by far
11:41:10 <Lethalman> wow using fix for dynamic programming is so fun
11:41:20 <Lethalman> and it's fast
11:41:25 <johnw> Lethalman: how are you using it?
11:41:40 <Lethalman> johnw, fix f :S
11:41:41 <Guest73754> permutation from Data.List?
11:41:43 <zhulikas> oh yeah, it is fun
11:41:52 <Lethalman> johnw, is there some optimization made by ghc underneath?
11:41:57 <zhulikas> johnw, also, I personally need to get past solving euler problems
11:41:58 <Lethalman> it's like it has some kind of memoization
11:42:05 <mreh> how could I implement a buffered Chan?
11:42:13 <johnw> Lethalman: that would be a question for shachaf
11:42:25 <TheRedMood> johnw its already fun :o
11:42:30 <johnw> he's the in-house ghc optimization guru
11:42:31 <mreh> just storing the buffer size with the Chan in an MVar would result in starvation
11:42:32 <shachaf> hi
11:42:37 <TheRedMood> Oh
11:42:38 <TheRedMood> Holy
11:42:43 <shachaf> GHC doesn't "memoize" functions.
11:42:44 <TheRedMood> he write the compiler?
11:42:48 <TheRedMood> O_O
11:42:58 <johnw> no, he just writes fast code
11:42:59 <`nand`> he spends all day staring at core
11:43:06 <TheRedMood> ?
11:43:09 <TheRedMood> Core as in?
11:43:15 <johnw> core is the language that GHC compiles Haskell into it
11:43:17 <shachaf> Are you people spreading rumors about me?
11:43:18 <`nand`> the intermediate language used by GHC for code generation
11:43:21 <johnw> think of it as "lobotomized haskell"
11:43:24 <`nand`> shachaf: no, move along
11:43:26 * shachaf doesn't know *that* much about GHC.
11:43:31 <TheRedMood> shachaf, What would you say your role in the haskell community is?
11:43:33 <shachaf> In fact I know very little.
11:43:33 <TheRedMood> :D
11:43:41 <`nand`> shachaf: quick, now you'll need to study GHC more so you can live up to your reputation
11:43:44 <shachaf> TheRedMood: I make puns in #haskell.
11:43:48 <TheRedMood> shachaf, The people admitting they know little, are the once who know the most.
11:43:49 <mreh> raconteur
11:43:52 <shachaf> Ask thoughtpolice. He knows about GHC, right?
11:44:01 <TheRedMood> shachaf, That is an important role, indeed.
11:44:30 <cmccann> `nand`: blah, I need to run AFK for a bit, dunno if any of this was making sense anyway
11:44:54 <`nand`> cmccann: fair enough, I'm about to sleep; it seemed to be making sense, let's see if that still holds true when I wake up tomorrow
11:45:01 <cmccann> heh
11:45:09 <zhulikas> :D
11:45:26 <cmccann> `nand`: the only other thing I'll mention is that you can think of negation as describing continuations
11:45:31 <k00mi> is it ok to use unicode (±) where it could be (+) or (-), depending on what is passed to the function?
11:45:54 <cmccann> if A is a value of type A, then (not A) is a continuation accepting a value of type A
11:46:02 <import> Hi there!
11:46:13 <johnw> k00mi: you can use that character for an operator, yes
11:46:14 <`nand`> I can see that from the type of Not
11:46:39 <cmccann> `nand`: yes, my encoding is basically CPS all the way down
11:46:54 <johnw> is CPS the new turtle?
11:47:05 <k00mi> johnw: i know i _can_, but is it regarded as bad? i never saw any unicode in code
11:47:08 <cmccann> but the analogy holds beyond just an implementation detail
11:47:11 <`nand`> am I correct in thinking that since (Not x) ‘demands’ an x, it will cancel out some ‘x’ that is known to be true?
11:47:22 <johnw> i wager not everyone will love you for doing it, but it all depends on how public your code will become
11:47:42 <cmccann> `nand`: yes, that's called "function application"
11:47:48 <TheRedMood> play
11:47:50 <TheRedMood> okay
11:47:54 <johnw> i wouldn't mind reading such an operator, but it would be tiresome if I you intended me to use it
11:48:12 <cmccann> `nand`: I think that's at the very bottom of the hpaste
11:48:39 <TheRedMood> At "Types and Typeclasses" in LYAH
11:48:42 <TheRedMood> finally :D
11:48:50 <k00mi> johnw: ok thanks, it won't be a library function or something so it should be fine
11:49:04 <`nand`> cmccann: apply :: x ⊗ (x ⊸ y) ⊢ y -- excellent, now I just need to figure out what ⊸ and ⊢ are
11:49:04 <johnw> TheRedMood: LYAH is worth a second read, after you've finished and played with a bit of code
11:49:10 <TheRedMood> Ph
11:49:12 <TheRedMood> Yeah
11:49:16 <TheRedMood> I am just at the secound chapter :D
11:49:17 <cmccann> `nand`: both are implication, basically
11:49:47 <johnw> TheRedMood: congrats!  a wondrous journey has begun :)
11:49:54 <`nand`> I'm guessing x ⊸ y means ‘consumes parameter x to return y’
11:49:56 <cmccann> the turnstile refers to the wrapper type that hides the CPS crap, the lolipop is a function type
11:50:08 <TheRedMood> Oh not this again
11:50:12 <TheRedMood> Signatures :(
11:50:23 <johnw> signatures are your best friend
11:50:29 <cmccann> `nand`: note that the lolipop is just a type synonym
11:50:30 <TheRedMood> Shh you.
11:50:33 <`nand`> johnw: except when you're forced to write them
11:50:37 <johnw> wel,l yeah
11:50:45 <johnw> but i feel naked when I have a top-level function without a signature
11:50:54 <johnw> i even put signatures on x = "Foo"
11:51:02 <TheRedMood> I feel like this is appropriate music for learning haskell: https://www.youtube.com/watch?v=S_XIxtuxq9s
11:51:06 <TheRedMood> Slow begining
11:51:11 <TheRedMood> Awesome fast paced end :D
11:51:20 <`nand`> “Not x ⅋ y” <- I'm thinking “either you use x, or you don't use y”
11:52:06 <JoeyA> I thought ⅋ was a spec on my screen and tried to wipe it off.
11:52:21 <JoeyA> I've been in this channel long enough.  I should know better.
11:52:21 <johnw> lol
11:52:39 <shachaf> A spec in cmccann's mind.
11:52:45 <cmccann> yes.
11:53:03 <johnw> You know you've found the perfect operator when the reader tries to wipe it off his screen.
11:53:15 <cmccann> `nand`: well, at some level it's the same as classical implication "a implies b" => "not a OR b"
11:53:22 <TheRedMood> I generaly use ascii caharacters
11:53:40 <TheRedMood> MAybe that has to change with haskell
11:53:47 <johnw> it doesn't
11:54:04 <aristid> TheRedMood: 99.9% of haskell code is pure ascii.
11:54:06 <`nand`> cmccann: oh, yeah
11:54:08 <TheRedMood> Got it
11:54:11 <cmccann> and from the "keep one if you disprove the other" perspective it means you can either give it an "x" and keep a "y", or give it a continuation that takes a "y" and keep a continuation that takes an "x"
11:54:24 <TheRedMood> And why is elem enaseced in ``
11:54:30 <TheRedMood> Those `` take a long time to write
11:54:38 <srhb> TheRedMood: It makes it infix
11:54:45 <TheRedMood> infix is mentioned in LYAH
11:54:47 <johnw> foo a b and a `foo` b are the same
11:54:48 <srhb> TheRedMood: In fact it makes any function infix rather than prefix
11:54:58 <johnw> just as (+) a b and a + b are the same
11:55:05 <srhb> TheRedMood: Conversely, paranthesis makes infix operators prefix
11:55:10 <TheRedMood> .....
11:55:10 <johnw> () and `` are ways to change infix to prefix, or prefix to infix
11:55:15 <TheRedMood> So this is lisp all over?
11:55:26 <srhb> How is it Lisp?
11:55:28 <`nand`> cmccann: that's what negloli is doing?
11:55:31 <TheRedMood> (+ 3 2)
11:55:31 <srhb> I mean, no. :P
11:55:32 <johnw> he means the prefix notation
11:55:35 <cmccann> `nand`: if you expand all the newtypes and other cruft (¬A ⅋ B) is equivalent to Kleisli Cont a b
11:55:36 <srhb> Ah.
11:55:40 <cmccann> `nand`: yes
11:55:45 <johnw> it's not (+ 3 2), but (+) 3 2
11:55:53 <TheRedMood> (+3 (- 2 (* 2 3)))
11:55:54 <cmccann> "a implies b" is equivalent to "not b implies not a" here
11:56:00 <Eduard_Munteanu> No, '))))))))))))))))))))' sounds more like Lisp. :P
11:56:09 <TheRedMood> johnw I know, just writing it in lisp to show what I mean.
11:56:12 <johnw> (+) 3 ((-) 2 ((*) 2 3))
11:56:13 <JoeyA> Needs law of excluded middle!
11:56:29 <Philippa> operator syntax doth not a lisp make
11:56:35 <cmccann> JoeyA: that's equivalent to the identity function here!
11:56:38 <srhb> I feel lonely without lambdabot. ._.
11:56:47 <E0000_> lisp is mainly a syntax ;)
11:56:54 <JoeyA> cmccann: Why are we shouting?!
11:57:00 <TheRedMood> BECAUSE WE LOVE IT!
11:57:00 <TheRedMood> :D
11:57:20 <Eduard_Munteanu> Yes, a syntax deficit... a lithp.
11:57:42 <cmccann> JoeyA: here: http://hpaste.org/75222#line319
11:58:20 <E0000_> speaking of which check out my object oriented programming language in 24 hours https://github.com/evanrinehart/octo-warning-robot
11:58:44 <TheRedMood> AHH!
11:58:55 <TheRedMood> So i can make signatures for functions?=
11:59:09 <`nand`> you can ‘use’ Unit as often as you want?
11:59:17 <TheRedMood> I think I will be doing this for every function I will every single function I write X3
11:59:20 <srhb> TheRedMood: Yes. If you can figure out the right one.
11:59:23 <Eduard_Munteanu> TheRedMood: type signatures? Yes, it's actually best practice.
11:59:27 <TheRedMood> A habbit from C
11:59:28 <`nand`> oh, yeah, x ⊢ x ⊗ Unit
11:59:32 <TheRedMood> But there it was prototypes
11:59:41 <cmccann> `nand`: it's basically (), note
12:00:08 <johnw> when people paste code in channel without signatures asking why it doesn't compile, our first suggestion is always "add signatures" :)
12:00:41 <Eduard_Munteanu> Sometimes the problem simply vanishes after they do that. ;)
12:00:51 <Eduard_Munteanu> (admittedly, in a confusing way)
12:01:50 <cmccann> `nand`: so you can use Unit as often as you like as long as it's in a context where x ⊢ x ⊗ Unit makes sense
12:02:14 <hpaste> “Anonymous Coward” pasted “Singatures?” at http://hpaste.org/80705
12:02:29 <TheRedMood> That w as me i think?
12:02:36 <TheRedMood> I am not a coward :(
12:02:47 <srhb> hpaste says otherwise.
12:02:47 <johnw> are you using ⊢ to mean ⟼
12:02:54 <`nand`> what exactly does ⊢ mean anyway? I guess it's like logical implication
12:03:11 <cmccann> `nand`: it's sort of an abuse of notation here
12:03:15 <johnw> oh, it's implication?
12:03:33 <TheRedMood> But regardless is that what you would mean with type declaration?
12:03:41 <srhb> TheRedMood: Type signature
12:03:50 <cmccann> I need to hide all the CPS cruft my encoding introduces, and that's what the turnstile is doing
12:04:03 <TheRedMood> srhb, Did you read the paste
12:04:12 <TheRedMood> ?
12:04:15 <srhb> TheRedMood: I did. And yes, your first line is a type signature/
12:04:21 <TheRedMood> Okay :D
12:04:37 <srhb> TheRedMood: Notice that hlint is complaining at the bottom.
12:04:38 <TheRedMood> String? Is there such a type?
12:04:40 <`nand`> cmccann: so it's just (->) + sugar?
12:04:48 <cmccann> `nand`: I used the turnstile specifically because it makes things look like the sequent calculus stuff used to describe the logic on wikipedia or nlab or whatever
12:04:53 <Eduard_Munteanu> type String = [Char]
12:04:54 <srhb> TheRedMood: It's synonymous with [Char] and you should prefer String.
12:04:56 <TheRedMood> Yeah, but LYAH doesn't mention it.
12:05:05 <TheRedMood> Oh
12:05:06 <TheRedMood> Okay :D
12:05:13 <cmccann> `nand`: if you want you can think of the turnstile as being the arrows of the category and the lolipop as being the internal hom, i.e. a function type
12:06:16 <cmccann> `nand`: in an actual programming language with a linear logic-based type system there'd be no particular need for a distinction there, and you could just use the lollipop everywhere
12:06:27 <cmccann> or maybe something easier to type
12:06:47 <Eduard_Munteanu> Erm, like they interpret Heyting algebra in Awodey's?
12:07:14 <Eduard_Munteanu> (the category's arrow vs exponentials)
12:07:39 <cmccann> Eduard_Munteanu: ahh, but linear implication is not an exponential object :D
12:07:51 <cmccann> (exponential implies a cartesian closed category, as was discussed earlier)
12:08:11 <Eduard_Munteanu> Ah, dunno much about linear logic. :(
12:08:25 <Eduard_Munteanu> (and I missed that discussion)
12:08:39 * hackagebot fquery 0.2.1.4 - Installed package query tool for Gentoo Linux  http://hackage.haskell.org/package/fquery-0.2.1.4 (SergeiTrofimovich)
12:09:39 <Eduard_Munteanu> cmccann: but is it a closed monoidal category?
12:09:44 <cmccann> yes
12:10:04 <Eduard_Munteanu> In other words, is your linear implication right adjoint to the products?
12:10:09 <Eduard_Munteanu> I guess so.
12:10:20 <cmccann> you get currying with the multiplicative conjunction
12:10:26 <cmccann> but the additive conjunction is the categorical product
12:10:50 <cmccann> Eduard_Munteanu: ncatlab.org/nlab/show/linear+logic is pretty approachable if you're comfortable with a bit of abstract nonsense-ese
12:11:09 <Eduard_Munteanu> I'll have a look.
12:11:14 <cmccann> there's also http://ncatlab.org/nlab/show/star-autonomous+category
12:12:07 <cmccann> which I think describes the structure of the multiplicative fragment of linear logic
12:12:53 <cmccann> if you add the categorical product and coproduct to that as separate thingies you get everything you need for linear logic I think
12:13:49 <cmccann> Eduard_Munteanu: and there's http://hpaste.org/75222 which is my encoding of linear logic in Haskell and was the context of `nand` asking about the turnstile vs. lollipop
12:15:28 <message144> Any tips on how I could extract  a list of columns from a boxed Data.Array ?
12:17:34 <Eduard_Munteanu> cmccann: what's the idea behind that Not?
12:18:11 <Eduard_Munteanu> I mean, why the two parameters?
12:18:48 <cmccann> Eduard_Munteanu: the "f" is the meat of it, the "r" is the result type for the omnipresent CPS cruft
12:19:14 <Eduard_Munteanu> Ah.
12:19:20 <cmccann> the "r" needs to be threaded through everything, because negation corresponds to a disembodied continuation
12:20:04 <cmccann> Eduard_Munteanu: note the "Var" newtype which simply ignores the result type
12:20:32 <cmccann> Eduard_Munteanu: you've seen the use of CPS transformation to encode "classical logic", right?
12:20:58 <cmccann> :t \k -> k . Left $ k . Right -- lem
12:21:04 <cmccann> dammit
12:21:06 <cmccann> no lambdabot
12:21:11 <Eduard_Munteanu> Yeah, I think I remember it.
12:21:43 <cmccann> anyway, (forall r. Either a (a -> r) -> r) is law of the excluded middle, modulo CPS cruft
12:22:51 <Eduard_Munteanu> Ah, I don't think of that as CPS... more like the axiom of explosion. Not a ~ forall r. a -> r
12:23:01 <Eduard_Munteanu> Or a different encoding of Void.
12:23:50 <cmccann> Eduard_Munteanu: anything on the left side of a function arrow is "negated" in some sense
12:24:03 <cmccann> "a -> Void" is negation with no extra baggage, and is non-constructive because of it
12:24:44 <cmccann> "a -> r" where r is an arbitrary type quantified somewhere out there is almost negation (r could in fact be Void, after all)
12:24:50 <Eduard_Munteanu> Non-constructive how? I think a -> Void implies forall r. a -> r
12:25:16 <cmccann> can you get "a" from "(a -> Void) -> Void"?
12:25:25 <Eduard_Munteanu> No.
12:25:38 <cmccann> but you can from "forall r. (a -> r) -> r"
12:26:20 <Eduard_Munteanu> Hm, how?
12:26:34 <cmccann> pick r ~ a and apply it to id
12:27:06 <cmccann> remember, Cont r a = Cont ((a -> r) -> r)
12:27:06 <Eduard_Munteanu> Oh, hm... /me thinks
12:27:16 <cmccann> there's another subtle distinction here
12:27:18 <hpaste> Matthias pasted “unique” at http://hpaste.org/80707
12:27:33 <cmccann> between something like Cont where you can have callCC
12:27:53 <Matthias|PC> can someone help me with this? http://hpaste.org/80707 I'm trying to make a function that removes all duplicates from a list
12:27:58 <cmccann> or a CPS-ish encoding that doesn't allow callCC, like (forall r. (a -> r) -> r)
12:28:05 <Matthias|PC> I get that this does not work because it will always be in the original list
12:28:16 <Matthias|PC> I'd need to check if the value is already present from within the new list
12:28:44 <Eduard_Munteanu> IIRC callCC was Peirce's law?
12:29:01 <cmccann> yes
12:29:15 <cmccann> which is classically valid, but not intuitionistically or in linear logic
12:30:23 <cmccann> (working out why that's the case, and why you can't write callCC when the "r" is quantified like that, is a fun little exercise)
12:32:05 <opqdonut> wait, why can't I get from a to (a -> Void) -> Void. if I have x::a can't I just set f g = g x?
12:32:50 <Eduard_Munteanu> opqdonut: you can, not the reverse though
12:33:12 <opqdonut> right, I misread cmccann's question
12:33:13 <Eduard_Munteanu> ((a -> Void) -> Void) -> a
12:33:20 <opqdonut> yeah
12:33:37 <maki`> Matthias you can't refer to the new list until it's already generate
12:33:44 <maki`> +d
12:34:02 <cmccann> fun fact: you can also consider a dual-intutionistic logic where double negation can be eliminated but not introduced
12:34:04 <lamefun> can I place hidden cache in variables? say I have data Shape = Polygon [Vector2] and want to do collision-detection, can I somehow cache stuff that only needs to be computed for each polygon once without making the structure more complex?
12:34:13 <cmccann> and where LEM is valid but the law of non-contradiction is not :D
12:34:46 <Eduard_Munteanu> cmccann: I was thinking about that...
12:35:18 <cmccann> Eduard_Munteanu: oh?
12:36:04 <Eduard_Munteanu> cmccann: hm, is it equivalent to LEM and no non-contradiction?
12:37:00 <Eduard_Munteanu> I don't know if it's even possible, I thought you get a -> Not (Not a) anyway.
12:37:04 <applicative> Matthias|PC: you can produce a new list as you go along, of course
12:37:18 <cmccann> Eduard_Munteanu: it's basically the de morgan dual of the differences between intuitionistic and classical logic
12:37:26 <Matthias|PC> applicative: how do you mean?
12:37:30 <zhulikas> no matter how proud of my algorithm I will be, there will always be a function in someone's library which performs a million times faster...
12:37:56 <cmccann> in dual-intuitionistic logic double-negation is a stronger notion of truth than un-negated, and you can recover classical logic via double-negation encoding just like in intuitionistic logic
12:38:32 <cmccann> Eduard_Munteanu: it's a particular flavor of paraconsistent logic, i.e., a logic with no principle of explosion
12:38:37 <applicative> Matthias|PC: say, a foldl' ... start with [] ; as each new element of the list you are nubbing comes in, check if it is in the list you are constructing. etc
12:39:12 <applicative> > let op x xs = if x `elem` xs then xs else x:xs in foldl' op [] "aaaaaaaaaaaaaaaaaaaa"
12:39:50 <Matthias|PC> hmmm, thanks
12:39:53 <Matthias|PC> I'll have a look at it
12:40:13 <Eduard_Munteanu> cmccann: I thought paraconsistent stuff assumed the negation of the non-contradiction law.
12:40:13 <cmccann> Eduard_Munteanu: I think the way it ends up working out here is that given "a AND not a" you can only consider them separately
12:40:34 <cmccann> paraconsistent is an overall term for a variety of logics
12:40:40 <cmccann> dual-intuitionistic is just one example
12:40:57 <Eduard_Munteanu> Hm, not so weird then
12:41:34 <cmccann> the negation of the law of non-contradiction is just the LEM by de morgan duality, isn't it?
12:42:06 <Eduard_Munteanu> cmccann: I read it as ∃ p. p & Not p
12:42:28 <Eduard_Munteanu> Which is weird.
12:43:17 <Casca> hi everyone
12:43:24 <Eduard_Munteanu> Casca: hi
12:43:34 <Casca> what's a good piece of open source Haskell code that I can use to study real world Haskell code and idioms?
12:43:39 * hackagebot amrun 0.0.0.5 - Interpreter for AM  http://hackage.haskell.org/package/amrun-0.0.0.5 (DanielSeidel)
12:43:47 <derdon> Casca: Xmonad?
12:44:02 <applicative> Casca: https://github.com/jgm/pandoc
12:44:07 <cmccann> Eduard_Munteanu: ah yeah, I'm not sure what that would mean, though depending on what that ∃ is quantifying over you might be able to prove it anyway
12:44:11 <cmccann> I'd have to work through it to be sure
12:44:23 <Casca> derdon, yeah, I was thinking Xmonad. i haven't dug into its code yet but maybe you have a better codebase to point me to
12:44:31 <Casca> by better i mean more newbie-friendly
12:44:32 <kennyd> Matthias|PC unless this is a learning practice there's already nub in standard library
12:44:42 <lamefun> And what's haskell way to deal with errors, like if someone tries to create a rectangle with negative width?
12:44:44 <cmccann> dual-intuitionistic logic is a bit counter-intuitive (ha, ha)
12:44:47 <Matthias|PC> learning practise, thanks though :)
12:45:27 <Eduard_Munteanu> cmccann: if we're starting from scratch, we don't have all the de Morgan laws.
12:45:49 <shachaf> cmccann: Intuitionistic logic is also a bit counter-intuitive.
12:46:24 <shachaf> At least when I'm using my "logic" intuition rather than my "computer program" intuition.
12:46:26 <Eduard_Munteanu> cmccann: furthermore, I think you were eliminating Not Not silently there
12:46:39 <applicative> lamefun what  do you want to do with it? Get back to the user, fail,...?
12:46:47 <derdon> lamefun: document the function. write that it's not a good idea to use negative widths.
12:47:19 <derdon> lamefun: expect smart programmers. that's the way I do it when writing APIs
12:47:52 <cmccann> Eduard_Munteanu: right, de morgan duality doesn't hold in intuitionistic or dual-intuitionistic logic in general
12:47:53 <derdon> lamefun: but don't expect smart users! give useful error messages in your CLI or GUI
12:49:34 <cmccann> Eduard_Munteanu: it gets tricky to talk about dual-intuitionistic logic because you have to distinguish carefully between whatever meta-logic you're assuming (often classical) and the logic being discussed
12:49:52 <jesyspa> Is there any operator @ such that (_1 @ _2) .~ 1 $ ((0, 0), (0, 0)) would be ((0, 1), (0, 0))?
12:49:58 <applicative> lamefun: http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors --which might be viewed as a complaint; and later http://blog.ezyang.com/2011/08/8-ways-to-report-errors-in-haskell-revisited/  There is a recent library http://hackage.haskell.org/package/errors explained here and in links here: http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
12:50:14 <johnw> jesyspa: just use .
12:50:25 <jesyspa> Doh, thanks.
12:50:26 <Eduard_Munteanu> cmccann: how about intuitionistic logic without non-contradiction (merely oblivious of it, not negating it)?
12:51:03 <Eduard_Munteanu> IDK what you'd call that.
12:51:21 <cmccann> dunno
12:52:08 <cmccann> my main interest here is linear logic; the dual-intuitionistic stuff just came along for the ride
12:52:38 <Eduard_Munteanu> I was also wondering about anti-classical logic; that is, negating LEM.
12:53:01 <cmccann> you can embed intuitionistic logic in linear logic using the modal operators, and the de morgan dual of that gives you a similar embedded dual-intuitionistic logic
12:53:51 <cmccann> (this relates to the business with sequent calculus and allowing only a single term on a particular side of each sequent)
12:54:37 <epta> `handle (\(SomeException a) -> when ((show a) == "ExitSuccess") someAction)'. I fell like a bull in chinashop :[. How it could be rewritten?
12:54:55 <epta> s/==/\/=/
12:55:08 <hpaste> lamefun pasted “Is this a remotely sane thing to do?” at http://hpaste.org/80708
12:56:28 <fmap> epta: pattern match on ExitCode instead of SomeException
12:58:44 <qasd> So Im writing a report on a fairly big school project. when we coded be just did this iteratively. Specification->Implement and test. No unittests. Just test until satisfied. So I doubt this can be put under some sort of software developing method right?
13:00:40 <applicative> 'specification driven development' seems a bit pleonastic... qasd
13:01:18 <cmccann> pleonastic is a good word.
13:01:40 <cmccann> Eduard_M1nteanu: anyway I really did need to run AFK earlier and now I extra-need to do so
13:02:22 <applicative> lamefun in this particular case why not allow a negative double. A circle is determined by its radius, which is a vector along the x axis so to say; it doesnt matter what direction, since were making a circle
13:02:55 * shachaf read that as "double negative" and spent a while trying to connect it to cmccann.
13:03:03 <cmccann> hahahahaha
13:07:04 <applicative_> lamefun: there is the usual point as well, that if circle x = Circle (abs x) and only circle is exported, then every Circle constructed will have a positive radius
13:07:16 <`ramses> ignorant question just to be sure: it should be perfectly fine to have two StateT transformers with the same state in one transformer stack, right?
13:07:28 <applicative_> my friend lamefun keeps appearing and disappearing
13:07:35 <`ramses> because they appear to be confused about their states...
13:08:23 <shachaf> `ramses: It should work but also be rather annoying.
13:08:34 <shachaf> Since you have to lift all the time to specify which state to modify.
13:08:43 <shachaf> You might instead pass one big state around.
13:08:52 <`ramses> shachaf: yeah, I defined functions to handle the lifting
13:08:53 <shachaf> data MyState = MyState StateA StateB
13:09:07 <shachaf> Then use State MyState
13:09:14 <shachaf> You can use lenses to make this more convenient. :-)
13:09:47 <`ramses> the problem is, I run them like "flip runState [] . flip runStateT (initT "a")" and I only use "lift . put", never a put, but still both states are occupied...
13:09:48 <TheRedMood> I am itching to ask a question
13:09:49 <applicative_> data MyState = {inner : StateA; outer :  StateA}
13:09:52 <TheRedMood> I know I should google :(
13:10:23 <newsham> ltgtfy.com, theredmood :)
13:10:29 <newsham> err.. lmgtfy.com
13:10:33 <applicative_> data MyState = MyState{inner : StateA; outer :  StateA}
13:10:33 <TheRedMood> yeah.
13:10:54 <TheRedMood> newsham yeah I know.
13:12:51 <shachaf> What's a type p that supports the operations (p a b -> p (r,a) (r,b)) and (p a b -> p (Either r a) (Either r b)), but not (p a a)?
13:13:40 * hackagebot opensoundcontrol-ht 0.1.1.2 - Haskell OpenSoundControl utilities  http://hackage.haskell.org/package/opensoundcontrol-ht-0.1.1.2 (HenningThielemann)
13:14:01 <cmccann> shachaf: type inequality proofs? :P
13:14:02 <newsham> shachaf: if p means not-equal?
13:14:38 <shachaf> OK, p is also a profunctor in this case.
13:14:46 <cmccann> pf, details.
13:14:51 <shachaf> So you have (a -> a') -> (b' -> b) -> p a b -> p a' b'
13:14:58 <newsham> a != b -> (r,a) != (r,b).   a != b -> (r or a) != (r or b).   but not   a != a
13:15:32 <shachaf> newsham: Right. Type inequality also works with my funny (misnamed) cocategory from the other day.
13:15:46 <newsham> i missed that show..
13:15:46 <shachaf> Which has p a a -> Void, p t s -> Either (p t x) (p x s)
13:16:01 <shachaf> Or maybe that's p x x -> p b a, not sure.
13:18:31 <applicative_> a cocategory is one with no id, and nothing composes?
13:19:07 <shachaf> I shouldn't call it a cocategory. I just like the name "mpose".
13:19:16 * cmccann suggests "decompose"
13:19:53 <shachaf> Cale: Could you bring lambdabot back?
13:20:07 <Eduard_Munteanu> cat a c -> (cat b c, cat a b) ?
13:21:08 <E0000_> i just did a foldl over a reversed list, and somehow it makes me think i should have done foldr...
13:22:00 <absence> does anyone know of a breadth-first traversal for Data.Tree similar to the depth-first Traversable instance that comes with it?
13:22:01 <JoeyA> Has anyone written a network library that focuses solely on TCP (and possibly other stream-likes) ?
13:22:45 <edwardk> absence: in lens head you can do breadth first traversals of any traversal-- but the notion of breadth isn't exactly the same you might expect
13:22:48 <edwardk> because it deals with infinite fanout
13:23:11 <Lethalman> JoeyA, you can find all the network libraries here http://hackage.haskell.org/packages/archive/pkg-list.html#cat:network
13:23:28 <applicative_> E0000_: you should generally do a foldr over a foldl.  There is the special case of strict 'tail recursive' things with fold'
13:24:01 <`ramses> I'm going insane here, I have an algorithm with works fine with a State monad, if I now add an extra StateT, and insert one (lift . put) with a constant, both states change... anyone an idea what could cause such behavior?
13:24:13 <E0000_> applicative_: im trying to understand if foldr would be have applicable
13:24:19 <E0000_> would have been*
13:24:46 <applicative_> E0000_: the  operation you fold with will need to be flipped of course
13:24:48 <shachaf> `ramses: The behavior is caused by you not posting your code.
13:24:59 <E0000_> yes i see that from the types
13:25:09 <E0000_> they sigs are identical except the fold op has flipped args
13:25:26 <absence> edwardk: remember what source file it's in?
13:25:28 <`ramses> shachaf: ok, give me a minute
13:25:32 <mm_freak> `ramses: StateT s1 (State s2) = State (s1, s2)
13:25:55 <shachaf> Also what mm_freak said. Which is also waht I said a little while ago.
13:26:04 <edwardk> absence: >>> Node 0 [Node 1 [Node 11 [], Node 12 []], Node 2 [Node 21 [], Node 22 []], Node 3 [], Node 4 []]^..Control.Lens.levels traverse.traverse
13:26:05 <edwardk> [0,1,2,11,3,12,21,4,22]
13:26:14 <mm_freak> ok, i'm disregarding bottoms
13:26:16 <applicative_> E0000_: right, exactly.
13:26:22 <edwardk> that deals with infinite lists of children and infinitely deep trees
13:26:31 * shachaf notes that that isn't in a released version of lens.
13:26:40 <edwardk> i'd said lens head
13:26:54 <shachaf> True.
13:27:17 <E0000_> applicative_: in my algorithm im doing a special case on the last element, and what im doing makes no sense for empty lists
13:27:41 <E0000_> but i am taking a list of b and producing a nested structure of a's
13:27:48 <E0000_> so fold*1 doesnt work
13:27:58 <hpaste> “`ramses” pasted “Transformer issue” at http://hpaste.org/80711
13:28:45 <`ramses> when I run that, the (lift . put) seems to put that node into both states...
13:28:53 <glguy> `ramses: Do you know about Debug.Trace.trace?
13:29:00 <applicative_> oh no`ramses theyre gonna hit you with lenses
13:29:01 <absence> edwardk: looks very useful, but a bit heavy for learning :)
13:29:06 <E0000_> so i dont see how i could possibly use foldr
13:29:23 <`ramses> glguy: yeah... I knew the import for unsafePerformIO by heart
13:29:45 <shachaf> `ramses: It seems to me that put and lift . put should be the same.
13:29:47 <`ramses> applicative_: I'm practicing for an exam, no lenses there :)
13:30:11 <`ramses> shachaf: huh? why is that? shouldn't they act on the two different states?
13:30:14 <glguy> `ramses: you need lift . lift . put
13:30:18 <applicative_> you could have invented lenses, `ramses, and maybe you already have
13:30:19 <zhulikas> still no lambdabot :/
13:30:34 <shachaf> One of them is executing at the level of the ReaderT; the other one is executing at the level of the StateT
13:30:43 <`ramses> ah! of course!
13:31:01 <glguy> `ramses: If you find yourself using two States, use one state with a record
13:31:06 <`ramses> that was the missing link, I was thinking upwards from the most inner state but it goes the other wat
13:31:11 <`ramses> s/wat/way
13:31:26 <shachaf> I think glguy is the third person to say that.
13:31:37 <shachaf> Probably at this point it won't make a difference. :-)
13:31:42 <Cale> @bot
13:31:46 <lambdabot> :)
13:31:48 <`ramses> glguy: but I kind of like to define functions "getFoo putFoo getBar putBar" using lifts and use those
13:32:00 <shachaf> `ramses: Instead, define them on the record.
13:32:26 <`ramses> shachaf: ok, that might be less prone to changes in the transformer stack
13:32:27 <structuralist> is there a way to simplify something like do {modify (+1); x <- get; return (f x)}
13:32:29 * applicative_ approves of putting State monads on the exam...
13:32:36 <edwardk> absence: you asked if there was something for breadth first traversal, that does it at least ;)
13:32:42 <`ramses> structuralist: fmap?
13:32:48 <shachaf> structuralist: With lens, you can say "f <$> id <+= 1"
13:32:59 <`ramses> structuralist: ah no, sorry
13:33:22 <structuralist> I don't know anything about lenses
13:33:31 <shachaf> OK, you might need parentheses.
13:34:00 <`ramses> thanks guys, I was really going nuts on this :)
13:34:42 <applicative_> modify (+1) >>  gets f
13:34:51 <applicative_> is that the same^^^
13:34:56 <shachaf> That too.
13:35:19 <shachaf> Also: state (\x -> (f x, x + 1))
13:35:23 <shachaf> Er, no.
13:35:34 <shachaf> Also: state (\x -> let x' = x + 1 in (f x', x))
13:35:38 <structuralist> yes! argh so obvious now, thanks applicative_
13:36:50 <`ramses> pff, with a composite state, defining puts, gets, modifies, etc is a lot more typing then just lifting...
13:37:15 <`ramses> I see where the lens comment came from
13:37:15 <shachaf> `ramses: That's why you use lenses!
13:37:27 <mauke> :t state (((,) =<< ?f) . succ)
13:37:28 <lambdabot> (?f::s -> a, Enum s, MonadState s m) => m a
13:37:34 <structuralist> where's a good place to learn about lenses?
13:37:39 <`ramses> shachaf: I can't, I'm practicing for an exam where we're only allowed to use stuff from HP
13:37:58 <shachaf> @where lens
13:37:58 <lambdabot> http://lens.github.com/ https://github.com/ekmett/lens
13:38:07 <absence> edwardk: levels was a nice hint though, the function with the same name in Data.Tree does breadth-first
13:43:55 <hpaste> glguy annotated “Transformer issue” with “using monad transformers” at http://hpaste.org/80711#a80713
13:44:13 <glguy> `ramses: At least when you are using monad transformers for more than one function, this is a nice "pattern"
13:45:01 <`ramses> glguy: sorry, what is the nice pattern? the composite state?
13:45:18 <glguy> `ramses: using transforms to implement the monad you want
13:45:29 <glguy> not to have that implementation detail leaking all over
13:45:57 <`ramses> I'm not sure I'm quite following, you mean that in general the usage of transformers is good?
13:47:20 <glguy> You shouldn't need lift/get/put/ask when implementing your algorithm, only when implementing the primitive operations of the monad you want to work in
13:47:34 <glguy> and you newtype the monad transformer stack
13:47:52 <glguy> so it doesn't leak into your implementation
13:50:48 <`ramses> glguy: yeah, that's why I wrote the functions wrapping the lifts
13:51:07 <`ramses> glguy: normally I would also newtype indeed, but using language extensions isn't allowed either
13:51:29 <mauke> extensions?
13:51:57 <`ramses> GeneralizedNewtypeDeriving, I don't feel like making instancec for MonadState, MonadTrans, MonadReader etc myself...
13:52:00 <glguy> `ramses: I derived Monad/Functor, but you don't have to take that short-cut
13:52:16 <glguy> `ramses: You wouldn't want a MonadReader instance for your Stack
13:52:27 <glguy> and unless you're using lenses, you wouldn't want a monadstate for your Stack, either
13:52:59 <`ramses> but the newtype wouldn't have ask, put etc, would it?
13:53:14 <glguy> Right, it shouldn't
13:53:24 <glguy> it should have the specific operations you need
13:53:31 <applicative_> equivalents are not too hard to define
13:53:33 <glguy> not general access to implementation details
13:53:44 <`ramses> glguy: ah ok, I see what you mean
13:54:11 <`ramses> glguy: that would certainly be worth it for a good api, but I'm just implementing a simple exercise here :)
13:54:37 <glguy> Yeah, like I said, it might not matter when you are defining one throwaway function
13:54:55 <m4a1fox> jgjghhkjh
13:54:56 <`ramses> no, but it's good advice :) I'm quite new to this stuff
13:55:34 <`ramses> gotta run, but thanks for all the input :)
13:56:24 <edwardk> absence: thats where i stole the name from
13:58:32 <hpaste> glguy annotated “Transformer issue” with “You don't need monads” at http://hpaste.org/80711#a80715
13:59:10 <glguy> @tell `ramses I left you an annotation http://hpaste.org/80711#a80715
13:59:10 <lambdabot> Consider it noted.
14:09:20 <yuri__> ola
14:09:32 <yuri__> this is radio clash?
14:10:50 <sclv> yes, yes it is.
14:11:17 <sclv> now we'll let you know. if you should stay or you should go.
14:11:37 <yuri__> My direction - Casbah
14:13:12 <applicative_> THIS LANGUAGE DOES NOT SUBSCRIBE TO THE INTERNATIONAL PLAN
14:15:36 <applicative_> is it a sufficient objection to type classes that they incline everybody to write a algebra library with e.g. class Eq r => NoetherianRing r where...
14:17:03 <parcs> hi
14:17:39 <yitz> applicative_: apparently not. cf. classy prelude.
14:17:56 <applicative_> grrr. hi parcs
14:18:58 <yuri__> sorry . police is on my back. i'll call you from london
14:19:00 <yuri__> sorry
14:19:06 <yuri__> excuse me
14:19:49 <yuri__> sergei sokolov
14:22:41 <kontroma> hi everyone!
14:27:51 <applicative_> hello kontroma what are expected and *actual* types
14:28:01 <applicative_> hello kontroma, what are your expected and *actual* types
14:31:26 <tomoj> what is the denotation of Data.Map? partial functions (k -> v)?
14:32:12 <`nand`> k -> Maybe v
14:32:21 <tomoj> ah, that was my first guess
14:32:23 <tomoj> thanks
14:40:30 <jesyspa> Do I understand correctly that in Haskell, lazy evaluation is deterministic and guaranteed?  If I find see some action happening, it means that action was *necessary* to compute a result I used?
14:41:46 <Saizan> not really
14:42:02 <copumpkin> it means that something asked for the result
14:42:18 <copumpkin> whether that was strictly necessary is another question
14:43:15 <mm_freak> jesyspa: you can't really observe this the way you think…  it's not the same as lazy loading from a database or something like that
14:43:17 <Saizan> you are guaranteed non-strictness, so an optimizing compiler (like GHC) can decide to evaluate more eagerly as long as it can prove it won't alter the resulting value
14:44:01 <mm_freak> jesyspa: you only observe the difference in that you can have partial/infinite data structures
14:44:15 <arturaz> Hi there. A quick question: if I were to write something like a website with mysql access and some REST api calls in haskell, what frameworks/libraries would you recommend?
14:44:26 <mm_freak> (and in a lot of unexpected memory behavior until you get used to it) =)
14:44:35 <tomoj> so the semantic function for Map is not a functor morphism?
14:44:43 <mm_freak> arturaz: happstack, snap or yesod
14:45:20 <Saizan> jesyspa: it still means that in the end it can only evaluate what is demanded, but the order can be unpredictable
14:45:29 <jesyspa> Well, to put more specifically: when translating a class definition, I'd like the table of members to be filled before member function code gets generated.  Should I just write an extra function to do that transformation, or can I remove dependencies and thereby achieve that with lazy evaluation?
14:45:35 <mm_freak> arturaz: personally i've tried all three of them and currently i'm going with happstack, but it's really a matter of taste
14:45:37 <Taslem> @pl (\x -> x + x)
14:45:37 <lambdabot> join (+)
14:45:48 <Taslem> @pl map (\x -> x + x)
14:45:48 <lambdabot> map (join (+))
14:45:56 <arturaz> mm_freak, does that also give me DB connectivity out of the box?
14:46:30 <mm_freak> arturaz: DB access is an addon in all three cases
14:46:44 <mm_freak> but it's really a matter of installing a library and using it together with the framework
14:47:14 <Saizan> jesyspa: is this pure code? and what do you mean by "before" specifically, if so?
14:47:54 <mm_freak> arturaz: if you're not forced to use mysql, you probably don't want to use it anyway
14:48:12 <arturaz> mm_freak, what model does the happstack follow? evented? threaded? something else?
14:48:28 <jesyspa> Saizan: I use the State monad; not sure whether that changes anything.  By "before", I mean that I want to do one run over the code which sets up the symbol table and discards the code (meaning the symbol table isn't queried), and then the second run uses that symbol table.
14:48:33 <arturaz> mm_freak, what do you suggest instead of mysql?
14:48:51 <mm_freak> arturaz: monoidal composition is the basic idea
14:49:05 <stepkut> arturaz: each request is handled in a separate lightweight thread -- though the underyling IO system uses kevent, etc
14:49:05 <arturaz> *blink*
14:49:10 <mm_freak> you write as many small applications as you want and just compose them
14:49:23 <mm_freak> in about the most straightforward way you can think of:  add them =)
14:49:29 <jesyspa> Hmm, actually, I think lazy evaluation may be doing its job fine, and I may just be running into some other bug on my part.
14:49:37 <arturaz> mm_freak, yeah, you still have to store the data somewhere, right?
14:49:51 <mm_freak> arturaz: yes, for most applications i'd recommend acid-state
14:50:23 <Saizan> jesyspa: it does seem like you should be able to exploit lazyness to "tie the knot" (which is the term for defining a value in terms of itself)
14:50:28 <tomoj> if the denotation of Map is just (k -> a) the functor morphism seems to work out?
14:50:41 <jesyspa> Thanks, let's see where I screwed up then. :D
14:50:50 <Saizan> jesyspa: though the State monad might get in the way there, unless you use mfix
14:51:04 <jesyspa> mfix?
14:51:06 <mm_freak> arturaz: acid-state adds ACID properties to your data types, so you don't need to translate between the haskell type and some RDBMS table design
14:51:08 <Saizan> jesyspa: there are some articles on the haskell wiki about this i think
14:51:19 <jesyspa> Alright, will take a look.
14:52:31 <Taslem> @pl q f x = if null x then x else f (head x) : q f (tail x)
14:52:32 <lambdabot> q = fix ((ap (if' =<< null) .) . ap (ap . ((:) .) . (. head)) . flip flip tail . ((.) .))
14:52:33 <arturaz> mm_freak, still, this seems like quite a jump for me, as I'm quite accustomed to mysql and its limitations. And I probably want to learn one thing at a time ;)
14:52:55 <Taslem> @pl q x y z = (x z) (y z)
14:52:55 <lambdabot> q = ap
14:53:02 <mm_freak> arturaz: are you experienced with haskell?
14:53:40 <arturaz> mm_freak, no, I'm just thinking of a toy project to actually learn it.
14:54:14 <mm_freak> arturaz: in that case learn the language basics and then read the happstack crash course or even the happstack-lite tutorial
14:54:17 <Saizan> jesyspa: the third article here might fit you well http://www.haskell.org/wikiupload/1/14/TMR-Issue6.pdf
14:54:39 <mm_freak> arturaz: http://happstack.com/clck/view-page-slug/3/documentation
14:54:47 <jesyspa> Thanks.  Actually, I think I found the issue...
14:54:52 <jesyspa> Wasn't updating enough on time. :)
14:57:33 <arturaz> ok, thanks for info. good night!
14:57:51 <jesyspa> Yay, found the issue!  Thanks all.
15:01:42 <maki`> if one wanted to take a screenshot, manipulate it, display it on the screen, etc in haskell is full blown GUI library like GTK or Qt the only option?
15:02:11 <yitz> maki`: why not a browser?
15:02:14 <srhb> maki`: Probably not.
15:02:28 <srhb> In fact, very little in a GUI library does what you want.
15:02:37 <srhb> Aside from the displaying bit, which other components can help with as well.
15:03:28 <maki`> is there any image manipulating lib I should look at?
15:03:54 <mm_freak> maki`: there are plenty of image loading/saving libraries, but i'm afraid you may have to do the manipulation yourself
15:04:20 <mm_freak> for the former i recommend JuicyPixels, unless it doesn't support the format you use
15:04:49 <Rarrikins_g_u> Do any Haskell web frameworks make uploading a file, processing it, and presenting the results of the processing easy?
15:04:54 <maki`> what about taking a screenshot?
15:04:59 <maki`> if possible portably
15:05:34 <E0000_> sucks that portable means windows mac and X
15:05:38 <yitz> Rarrikins_g_u: that would be fine in any of the popular frameworks
15:05:51 <Rarrikins_g_u> OK, thanks
15:06:11 <mm_freak> Rarrikins_g_u: all of them
15:06:33 <yitz> E0000_: i think nowadays portable means a phone or a tablet
15:06:38 <mm_freak> Rarrikins_g_u: in all frameworks except yesod you would actually use a separate library for that
15:06:53 <E0000_> guess so, for screenshots
15:07:20 <E0000_> but i think screenshots is generally a clusterfuck on phones
15:08:05 <mm_freak> maki`: for taking screenshots i'm sure that you will have to deal with the portability
15:08:23 <mm_freak> for X use the Xlib binding, for windows use the win32 API, etc.
15:08:26 <E0000_> does askell run on phones?
15:08:36 <mm_freak> E0000_: practically no
15:08:50 <applicative> juicy.pixels now supports something called hdr images. looking at a few, I oppose this.
15:09:03 <mm_freak> E0000_: you could ask ipwn studios to release their iphone backend for GHC, though
15:10:00 <mm_freak> and there is effectively nothing for android except some immature javascript generators, which you could use with cordova or something
15:13:48 * hackagebot profunctors 3.2 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-3.2 (EdwardKmett)
15:14:22 <mm_freak> bah
15:14:34 <frerich> That's a nice example: thinks like "pro functors 3.2" which seem to have about zero documentation and an obscure name: what benefit is there in having it on hackage?
15:14:45 <mm_freak> edwardk: you really could have released that an hour ago, /before/ i updated everything =P
15:14:53 <edwardk> mm_freak: hahaha
15:15:04 <shachaf> mm_freak: You're using profunctors?
15:15:04 <edwardk> sorry about that
15:15:06 <frerich> I'm sure they are good for *something* but how is a mere mortal supposed to figure out what for? :}
15:15:10 <E0000_> "pro functors" ;)
15:15:12 <mm_freak> frerich: profunctors is really useful actually
15:15:29 <shachaf> mm_freak: You'll be happy to hear that profunctors is slowly turning into arrows.
15:15:31 <sclv> frerich: the docs are actually pretty good at the moment
15:15:33 <shachaf> (Not really.)
15:15:34 <shachaf> (But sort of.)
15:15:35 <edwardk> frerich: there are docs in there describing all of the laws and links to articles on the topic
15:15:55 <edwardk> its also just about the entire underpinnings of the lens package which has hundreds of examples of using them
15:15:58 <frerich> Where on http://hackage.haskell.org/package/profunctors-3.2 do I have to click to see the docs?
15:16:00 <mm_freak> shachaf: well, since every functor+arrow is a profunctor…
15:16:13 <sclv> the docs haven't been built for 3.2 yet. look at the last version: http://hackage.haskell.org/packages/archive/profunctors/3.1.3/doc/html/Data-Profunctor.html
15:16:16 <edwardk> frerich: on 3.1.3 the docs have been generated.
15:16:22 <sclv> docs on hackage get built once or twice a day only
15:16:23 <edwardk> frerich: the haddocks don't generate for up to 12 hours
15:16:28 <frerich> Aah
15:16:45 <frerich> That's good to know, I had this happening more than once already, maybe I just always looked in some unfortunate moment.
15:16:59 <edwardk> the majority of the API hasn't changed from 3.1.3 to 3.2
15:17:02 <mm_freak> shachaf: btw, i'm not a big fan of arrows anymore =)
15:17:11 <shachaf> mm_freak: Oh.
15:17:16 <shachaf> Why not?
15:17:49 <mm_freak> shachaf: everyone agrees that the tuple stuff in arrows is very ugly, but people (i.e. Cale and me) have different approaches to solving that problem
15:18:08 <mm_freak> Cale adds some classes and writes a preprocessor
15:18:13 <mm_freak> my solution is not to use arrows =)
15:18:48 * hackagebot profunctor-extras 3.3 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-3.3 (EdwardKmett)
15:29:47 <alpounet> mm_freak, eh, weren't you writing netwire and whatnot using arrows?
15:31:16 <merijn> alpounet: I'm writing a project in C, doesn't mean I like C ;)
15:32:43 <alpounet> merijn, well, choosing an abstraction / a design isn't the same as choosing a language (moreover, you usually have the choice of the former but not that often of the latter)
15:33:14 <alpounet> but i'm asking since if i remember well the big thing about netwire was that everything there was about arrows
15:34:44 <craigInnes> hi, has anyone used the System.Plugins library before? I am trying to compile and load a function from another problem but am having trouble handling LoadFailures
15:36:00 <donri> stepkut: ^
15:37:10 <stepkut> craigInnes: I've used it a bit..
15:38:34 <craigInnes> stepkut: My issue is that If I have a load failure, I simply want it to ignore it and go no further. But this seems to cause all subsequent loads to fail, regardless of whether they are correct or not
15:38:56 <stepkut> craigInnes: :-/
15:39:24 <craigInnes> stepkut: That probably wasnt very clear, hold on and i will try and paste some example code
15:40:19 <mm_freak> alpounet: netwire provides both an arrow and an applicative interface
15:40:44 <mm_freak> you would use the arrow interface when you want to write code with feedback (ArrowLoop) or choice (ArrowChoice)
15:40:53 <mm_freak> doing that with the combinators can be really ugly
15:42:24 <craigInnes> stepkut: http://pastebin.com/uxXu9uXz This is a segment from the code that uses it. If the user clicks a button, it tries to load up the code within a text box and draw a picture with a function within it.
15:42:26 <mauke> The paste uxXu9uXz has been copied to http://hpaste.org/80717
15:43:46 <stepkut> craigInnes: i don't see anything obviously wrong
15:44:18 <stepkut> what fails, the make or the load?
15:44:49 <Guest66100> hi. does haskell have a web platform ?
15:45:18 <Entroacceptor> Guest66100: multiple! snap, yesod, happstack
15:45:45 <mikeplus64> also scotty which is interesting
15:45:45 <Guest66100> nice. and how's the performance compared to .net or php ?
15:46:04 <mikeplus64> much better than php, i don't know about .net
15:46:30 <zomg> Guest66100: I would say in comparison to php or .net there are more interesting things about haskell than just pure performance =)
15:46:39 <Entroacceptor> oh, I don't know about scotty
15:46:41 <mikeplus64> Guest66100: http://www.yesodweb.com/blog/2011/03/preliminary-warp-cross-language-benchmarks
15:46:46 <zomg> I think the performance is "good enough" for most intents and purposes
15:46:47 <craigInnes> stepkut: It is the load that fails. The example i was playing with was where I change the function within Test.hs to something like pics, or change the module name to Tes
15:47:18 <applicative> oh, mikeplus64 mentioned scotty https://github.com/ku-fpg/scotty
15:47:19 <mikeplus64> zomg: good enough and very good indeed :P
15:47:30 <craigInnes> stepkut: From what I understand, this would compile fine, but fail to load because its looking specifically for the pic function within the Test module
15:47:43 <stepkut> craigInnes: and you are sure the .o file is really changing after a successful compile?
15:47:49 <Guest66100> php compiles scripts at the runtime , everytime page is called. .net has the "application mode" that behaves like an application. it processes request until it's manualy closed by the developer. how does haskell behave ?
15:48:00 <stepkut> oh
15:48:11 <stepkut> if you change the name of the module or the name of the function in the module.. that would certainly break things..
15:48:32 <zomg> Guest66100: haskell applications serve requests, I guess it's a bit similar to how .net behaves
15:48:34 <mikeplus64> Guest66100: haskell applicatoins are compiled executables
15:49:13 <craigInnes> stepkut: Indeed. However, if i then try and run the function again, having changed the input back to its original correct version, it *still" tells me it has failed
15:49:34 <Guest66100> okay , thx for the answers
15:49:48 <mm_freak> i need lenses for IxSet…  do i have to write them myself right now?
15:49:49 <mikeplus64> Guest66100: http://snapframework.com/blog/2010/11/17/snap-0.3-benchmarks this is old, but still shows snap having better performance than others (who have also probably improved)
15:50:00 <edwardk> mm_freak: or switch to tables ;)
15:50:23 <stepkut> mikeplus64: yeah, those stats are ancient history
15:50:33 <mm_freak> edwardk: tables?
15:50:38 <craigInnes> stepkut: Its as if failing to load once causes to to fail on all subsequent loads. Regardless of whether it is now correct or not
15:50:56 <edwardk> github.com/ekmett/tables   its my work-in-progress lens-based ixset-like in-memory data-store
15:51:26 <mm_freak> edwardk: is it more static than ixset?
15:51:32 <stepkut> craigInnes: I have never seen that behavior before
15:52:02 <edwardk> table^.with FooId (<) 400.with fooBar (>=) "hello"
15:52:20 <edwardk> mm_freak: FooId there uses a key, fooBar uses a table scan on the resulting table.
15:52:21 <donri> i don't think tables use typeable like ixset no
15:52:27 <mikeplus64> stepkut: it'd be interesting to set up a "contrived benchmark in haskell web frameworks" that is say updated once a month (with comparisons to other languages)
15:52:34 <edwardk> mm_freak: we don't rely on Data/Typeable. you can put functions in the tables, etc.
15:52:58 <mm_freak> edwardk: great!  i hope you'll release it soon…  i've been wanting something like that for a long time
15:53:20 <stepkut> mm_freak: there is a data-lens library for ixset.. but it suffers from the problem that you can't actually have a valid data-lens instance for IxSet. No support for lens... hoping to just switch to tables, really
15:53:25 <edwardk> mm_freak: you can also write back through the queries.    table & with FooId (>) 400 .rows.fooBar_ +~ 1
15:53:25 <stepkut> mm_freak: http://happstack.com/docs/crashcourse/AcidState.html#ixset_lens
15:53:40 <mikeplus64> since performance is always and understandably an asking point by new people
15:53:57 <stepkut> mikeplus64: better get started!
15:54:02 <mm_freak> anyway, for now i'll write the lenses manually
15:54:02 <mikeplus64> :)
15:54:43 <donri> mm_freak: not sure you can write useful legal lenses for ixset
15:54:43 <mm_freak> stepkut: i'm using 'lens'
15:54:56 <stepkut> mm_freak: yup
15:55:02 <mm_freak> donri: sure you can, if they are specific enough and include a Maybe
15:55:06 <donri> mm_freak: might be better of separating getters and setters, or just use helpers like 'to'
15:55:09 <stepkut> mm_freak: as I said.. support for data-lens, but not lens..
15:55:51 <mm_freak> thanks guys…  back to work
15:55:59 <donri> mm_freak: well the updateIx etc in ixset don't behave in any lensy way so you'd have to reimplement similar functions that do
15:56:58 <mm_freak> well, maybe i should just not uses lenses for the ixset
15:57:00 <donri> for queries i do stuff like, view $ foo.bar.to (@= Key).to toSet.folded.baz
15:57:28 <donri> for updates i have a custom modify function that i pass functional lenses (the ~ operators)
15:58:30 <mm_freak> great…  Html doesn't even have a SafeCopy instance =/
15:58:51 <stepkut> :O
15:59:12 <stepkut> I can see that being a bit tricky to implement
15:59:17 <donri> deriveSafeCopy works across packages right?
15:59:29 <mm_freak> stepkut: indeed
15:59:32 <stepkut> donri: ?
15:59:43 <mm_freak> i guess i should store serialized HTML
15:59:45 <donri> well i'm not sure
16:00:25 <mm_freak> donri: Html is not serializable easily
16:00:38 <donri> does it contain functions or something?
16:00:40 <mm_freak> or rather:  serializing it essentially means rendering the HTML
16:00:52 <mm_freak> donri: yes, there is an underlying monad
16:01:17 <mm_freak> and today i'm not feeling like discussing serialization of functions again =)
16:01:49 <stepkut> mm_freak: time to switch to clean?
16:01:55 <neutrino> hi mm_freak
16:02:28 <mm_freak> stepkut: the language?
16:02:33 <stepkut> mm_freak: yeah
16:02:36 <mm_freak> neutrino: hi there
16:02:44 <mm_freak> stepkut: neither time nor interest =)
16:02:54 <neutrino> tired of serialization, huh?
16:03:24 <mm_freak> neutrino: it's interesting how many problems serialization of functions would solve =)
16:03:30 <edwardk> @remember cmccann * cmccann has concluded that lenses are just a category whose objects are english prepositions and whose morphisms are all unsafeCoerce
16:03:30 <lambdabot> I will remember.
16:03:41 <neutrino> mm_freak: how many?
16:03:44 <cmccann> heh
16:03:48 * hackagebot rematch 0.1.0.1 - A simple api for "matchers"  http://hackage.haskell.org/package/rematch-0.1.0.1 (TomCrayford)
16:03:58 <mm_freak> neutrino: all of them probably =)
16:04:03 <neutrino> hmm ok
16:04:11 <mm_freak> anyway, i'll just safe rendered HTML
16:04:11 <neutrino> yes, "probably" must be the right word
16:04:25 <neutrino> since there certainly exists a probability appropriate
16:04:25 <mm_freak> s/safe/save/
16:23:14 <roadfish> I notice that some cabal packages have chs files. Are they compiled with hsc2hs?
16:23:35 <shachaf> @google chs file haskell
16:23:37 <lambdabot> http://tommd.wordpress.com/2009/09/22/haskell-bindings-to-c-c2hs/
16:23:37 <lambdabot> Title: Haskell Bindings to C – c2hs « Beware the Jabberwolk
16:23:43 <shachaf> Looks like they're compiled with c2hs
16:24:45 <roadfish> ok, likely explains why hsc2hs gives so many errors
16:55:04 <gertc> Just (User a b c d e f g h i) <- liftIO $ userinfo' m    how do i create var u that represent a complete user object?
16:55:26 <shachaf> Just u <- ...?
16:55:39 <shachaf> You can say Just u@(User ...) <- ... if you want both.
16:55:45 <gertc> yes but i also need a b c ..
16:56:04 <gertc> aha u@
16:56:12 <shachaf> Also if you have 9 parameters like that, maybe you shouldn't be pattern matching like that?
16:58:19 <gertc> you mean like using the (..) extention?
16:58:25 <johnw> u@(User {}) is the syntax
16:58:27 <shachaf> No.
16:58:41 <shachaf> I mean using selectors or something. :-)
16:58:47 <shachaf> (NB: something = lens)
16:58:48 <johnw> there is also a record matching syntax; what is it again shachaf?
16:59:02 <johnw> puns, that's what I'm thinking of
16:59:12 * shachaf isn't a huge fan of those.
16:59:16 <johnw> lolo
16:59:28 <johnw> i'm guessing you dislike the whole LANGUAGE thing altogether, eh?
16:59:31 <shachaf> I GET IT, THE JOKE IS I DON'T LIKE SOMETHING.
16:59:40 <shachaf> Like shadowing.
17:00:12 <shachaf> NamedFieldPuns encourage shadowing. It's convenient but shadowing tends to be trouble.
17:00:37 <johnw> punning would let him say u@(User { a, b, c })
17:00:57 <johnw> i don't think I've seen you revert to all caps before
17:01:08 <shachaf> I type in all-caps all the time.
17:01:13 * johnw has maybe given shachaf a hard time once too often...
17:01:16 <shachaf> You're just in the wrong channels.
17:01:19 <johnw> ah
17:01:28 <johnw> it's funny how channel-variable you are
17:01:39 <johnw> shachaf-blah is a blast
17:01:43 <shachaf> blahst
17:01:55 <shachaf> It depends on which oblahst I'm in.
17:02:05 <johnw> shachaf-lens is like watching an episode of Weird Science
17:02:21 <edwardk> heh
17:02:23 <gertc> ok so for u@(User { a, b, c }) i need to google haskell punning?
17:02:29 <johnw> gertc: yes, record puns
17:02:31 <shachaf> @google named field puns ghc
17:02:33 <lambdabot> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html
17:02:33 <lambdabot> Title: 7.3.�Syntactic extensions
17:02:35 <johnw> -XNamedFieldPuns
17:02:37 <shachaf> That's the name.
17:02:53 <shachaf> It has disadvantages.
17:03:02 <johnw> there is also -XRecordWildcards
17:03:04 <edwardk> you should see shachaf in real life
17:03:07 <lispy_> only the shadowing disadvantage
17:03:28 <johnw> edwardk: I think I need to, to truly understand The Shachaf
17:03:33 <lispy_> It can make some code (where you need 90% of your fields most of the time) much more concise
17:03:40 <johnw> ICFP 2013, come and meet shachaf!
17:03:41 <shachaf> As if there's only one "real-life" version?
17:03:47 <edwardk> fair enough
17:04:01 <johnw> does a drunk shachaf exist?
17:04:09 <lispy> -XRealShachaf
17:04:27 <shachaf> @src Real
17:04:27 <lambdabot> class  (Num a, Ord a) => Real a  where
17:04:27 <lambdabot>     toRational      ::  a -> Rational
17:04:29 <johnw> i bet when he's drunk he turns on every GHC extension and uses only ten different variable names throughout his code
17:04:42 <shachaf> johnw: So, business as usual?
17:04:46 <johnw> lol
17:04:54 <johnw> edwardk only ever uses 26 variable names
17:04:57 <Nisstyre-laptop> Is there anything in the stdlib that will generate permutations of n length? I see Data.List.permutations but that's not what I want.
17:04:58 <johnw> and I think the reason is obvious
17:05:09 <Nisstyre-laptop> Or is there a good combinatorics package on hackage?
17:05:13 <johnw> Nisstyre-laptop: take n ...?
17:05:15 <E0000_> well never need more than 26 variable names
17:05:28 <edwardk> i use more when i'm off writing hungarian haskell
17:05:31 <copumpkin> Nisstyre-laptop: what do you want then?
17:05:45 <copumpkin> > length (permutations [1..5])
17:05:46 <lambdabot>   120
17:05:47 <johnw> copumpkin! ltns
17:05:48 <Nisstyre-laptop> copumpkin: I want to generate all of the possible digrams in the English alphabet
17:05:50 <copumpkin> johnw: hi!
17:05:52 <johnw> did you go somewhere for the holidays?
17:06:27 <copumpkin> > replicateM 2 ['a'..'z']
17:06:28 <lambdabot>   ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao"...
17:06:33 <copumpkin> Nisstyre-laptop: does that count?
17:06:40 <Nisstyre-laptop> copumpkin: maybe
17:06:45 <lispy> > [x:y:[] | x <- [ 'a'..'z'], y <- ['a' .. 'z']]
17:06:47 <lambdabot>   ["aa","ab","ac","ad","ae","af","ag","ah","ai","aj","ak","al","am","an","ao"...
17:06:50 <copumpkin> johnw: not really :)
17:06:57 <copumpkin> well, NYC a fair bit
17:06:59 <copumpkin> but that's not very far
17:07:01 <johnw> edwardkVariableGenerator = replicateM 1 ['a'..'z']
17:07:10 <nyc> What did I do this time?
17:07:17 <lispy> heh
17:07:24 <Nisstyre-laptop> > length $ replicateM 2 ['a'..'z']
17:07:25 <lambdabot>   676
17:07:38 <Nisstyre-laptop> that should be 650
17:07:38 <johnw> > 26^2
17:07:40 <lambdabot>   676
17:07:52 <lispy> Nisstyre-laptop: filter?
17:07:54 <shachaf> Where does the number 650 come from?
17:07:57 <copumpkin> 26 * 25?
17:08:01 <shachaf> Oh.
17:08:01 <Nisstyre-laptop> shachaf: 26!/24!
17:08:30 <Nisstyre-laptop> but yeah, it simplifies to 26*25
17:08:51 <copumpkin> @let pairs = liftA2 (=<<) zip (tail . tails)
17:08:54 <lambdabot>  Defined.
17:08:55 <copumpkin> :t pairs
17:08:57 <lambdabot> [b] -> [(b, b)]
17:09:06 <augur> shachaf: whats wrong with shadowing?
17:09:12 <copumpkin> > length $ pairs ['a'..'z']
17:09:14 <lambdabot>   325
17:09:16 <johnw> never seen a =<< lifted before
17:09:18 <copumpkin> damn!
17:09:20 <copumpkin> half!
17:09:24 <Nisstyre-laptop> close :P
17:09:50 <copumpkin> > pairs [1..4]
17:09:52 <lambdabot>   [(1,2),(2,3),(3,4),(1,3),(2,4),(1,4)]
17:10:07 <lispy> > length $ nub [x:y:[] | x <- [ 'a'..'z'], y <- ['a' .. 'z']]
17:10:09 <lambdabot>   676
17:10:24 <shachaf> lispy: You want filter (uncurry (/=)). Except that's awful.
17:10:32 <johnw> > length $ permutations ['a'..'z']
17:10:35 <lambdabot>   mueval-core: Time limit exceeded
17:10:46 <Nisstyre-laptop> that'll be 26!
17:10:52 <johnw> ah
17:11:14 <shachaf> 00:35:14 <maukd> @let select [] = []; select (x : xs) = (x, xs) : map (fmap (x :)) (select xs)
17:11:15 <johnw> length $ filter ((==2) . length) $ permutations ['a'..'z']
17:11:17 <johnw> > length $ filter ((==2) . length) $ permutations ['a'..'z']
17:11:17 <shachaf> @let select [] = []; select (x : xs) = (x, xs) : map (fmap (x :)) (select xs)
17:11:19 <lambdabot>  Defined.
17:11:21 <lambdabot>   mueval-core: Time limit exceeded
17:11:28 <shachaf> > [ (x,y) | (x, ys) <- select ['a'..'z'], y <- ys ]
17:11:28 <lispy> > length $ filter (\x -> length x == 2) $ permutations [ 'a'..'z']
17:11:30 <lambdabot>   can't find file: L.hs
17:11:31 <lambdabot>   [('a','b'),('a','c'),('a','d'),('a','e'),('a','f'),('a','g'),('a','h'),('a'...
17:11:33 <shachaf> > length [ (x,y) | (x, ys) <- select ['a'..'z'], y <- ys ]
17:11:35 <lambdabot>   650
17:11:41 <Nisstyre-laptop> nice
17:11:42 <shachaf> That's mauke's solution.
17:11:49 <copumpkin> mauke: good job!
17:12:24 <lispy> > length $ filter (\x -> length x == 2) $ permutations [ 'a'..'z']
17:12:27 <lambdabot>   mueval-core: Time limit exceeded
17:12:34 <johnw> lispy: it takes too long to filter the list
17:12:37 <lispy> yeah
17:13:06 <lispy> @hoogle permutations
17:13:10 <lambdabot> Data.List permutations :: [a] -> [[a]]
17:13:10 <lambdabot> package action-permutations
17:13:19 <shachaf> http://stackoverflow.com/questions/12869097/splitting-list-into-a-list-of-possible-tuples
17:13:24 <shachaf> That's pigworker's answer.
17:13:34 <johnw> there's choose, from combinat
17:13:42 <johnw> "All possible ways to choose k elements from a list, without repetitions."
17:14:15 <Nisstyre-laptop> johnw: yeah, that's what I was looking for
17:14:56 <johnw> shachaf: where is select from?  hoogle is failing me
17:14:56 * lispy is still waiting for 'permutations ['a'..'z']' to finish
17:14:59 <johnw> @info choose
17:15:00 <lambdabot> choose
17:15:15 <shachaf> johnw: It's from a few lines above.
17:15:22 <johnw> ah, I see
17:16:01 <johnw> > select [1..4]
17:16:03 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
17:16:12 <johnw>  oh, that's handy
17:17:25 <lispy> That should really be in Data.List, I reckon
17:18:00 <johnw> easy enough to propose to libraries, i'd +1 it
17:18:50 <mm_freak> lispy: …
17:18:56 <mm_freak> > product [1..26]
17:18:58 <lambdabot>   403291461126605635584000000
17:19:05 <mm_freak> have fun waiting for that many permutations
17:19:07 <shachaf> > let iaep e [] = [[e]]; iaep e (x:xs) = (e:x:xs) : map (x:) (iaep e xs) in iaep 'x' "hello"
17:19:08 <lambdabot>   ["xhello","hxello","hexllo","helxlo","hellxo","hellox"]
17:20:02 <mm_freak> > liftA2 (zipWith (\x y -> x ++ 'x':y)) inits tails "abcde"
17:20:03 <lambdabot>   ["xabcde","axbcde","abxcde","abcxde","abcdxe","abcdex"]
17:20:29 <lispy> mm_freak: oh, good point.
17:21:29 <lispy> I knew it was going to be a lot, but I didn't realize it was that many
17:22:03 <mm_freak> lispy: your processor probably needs a few years just to count to that number in a register =)
17:22:14 <Nereid> > evalStateT (replicateM 2 $ StateT select) [1..4]
17:22:15 <lambdabot>   [[1,2],[1,3],[1,4],[2,1],[2,3],[2,4],[3,1],[3,2],[3,4],[4,1],[4,2],[4,3]]
17:22:28 <copumpkin> cute :)
17:22:30 <Nereid> =)
17:22:41 <copumpkin> > length $ evalStateT (replicateM 2 $ StateT select) [1..4]
17:22:43 <lambdabot>   12
17:22:52 <copumpkin> > length $ evalStateT (replicateM 2 $ StateT select) ['a'..'z']
17:22:54 <shachaf> mm_freak: Rather more than a few years.
17:22:54 <lambdabot>   650
17:22:58 <mm_freak> > logBase 2 (product [1..26])
17:23:00 <lambdabot>   88.38195332701626
17:23:04 <mm_freak> shachaf: indeed
17:23:05 <Nereid> > 26*25
17:23:06 <lambdabot>   650
17:23:23 <mm_freak> Nereid: nice one =)
17:23:42 <mm_freak> oh, that's not like me…
17:23:59 <mm_freak> > sum . map (logBase 2) $ [1..26]
17:24:01 <lambdabot>   88.38195332701628
17:24:03 <mm_freak> better =)
17:24:30 <Nereid> > sumOf (folded . to (logBase 2)) [1..26]
17:24:31 <lambdabot>   88.38195332701628
17:26:04 <mm_freak> > sumOf folded [1..4]
17:26:06 <lambdabot>   10
17:27:53 <Nereid> :t sumOf folded
17:27:54 <lambdabot> (Num b, Foldable f) => f b -> b
17:36:15 <Nereid> there we go.
17:36:26 <Nereid> @let select' [] = []; select' (x:xs) = (x,xs) : select' xs
17:36:27 <lambdabot>  Defined.
17:36:31 <Nereid> > evalStateT (replicateM 2 $ StateT select') [1..4]
17:36:33 <lambdabot>   [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
17:36:38 <Nereid> =)
17:37:35 <Nereid> @let perm n l = evalStateT (replicateM n $ StateT select) l
17:37:37 <lambdabot>  Defined.
17:37:39 <Nereid> @let comb n l = evalStateT (replicateM n $ StateT select') l
17:37:41 <lambdabot>  Defined.
17:37:55 <shachaf> > select' "abcd"
17:37:57 <lambdabot>   [('a',"bcd"),('b',"cd"),('c',"d"),('d',"")]
17:38:08 <Nereid> > map (\n -> length $ comb n [1..6]) [0..6]
17:38:09 <lambdabot>   [1,6,15,20,15,6,1]
17:38:34 <Nereid> > map (\n -> length $ perm n [1..6]) [0..6]
17:38:36 <lambdabot>   [1,6,30,120,360,720,720]
17:47:30 <Nereid> haskell is too cool.
17:47:38 <bergmark> ya man
17:53:23 <Maior> as someone currently refactoring $anon_ducktyped_language code, I find myself heartily agreeing
18:00:13 <glguy> You guys are so brave to take a stand with Haskell in this channel!
18:00:38 * Rarrikins_g_u brandishes his ax.
18:00:44 <lambdabot> i hate haskell! worst language ever
18:01:17 <glguy> I'm guessing haskell! is Yahoo!'s version
18:01:17 <Rarrikins_g_u> Haha
18:01:34 <Rarrikins_g_u> lambdabot is enslaved to carry out people's Haskell commands day and night.
18:01:36 <JoeyA> @hoogle hayoo
18:01:36 <lambdabot> No results found
18:01:40 <JoeyA> @google hayoo
18:01:43 <lambdabot> http://holumbus.fh-wedel.de/hayoo/
18:01:43 <lambdabot> Title: Hayoo! - Haskell API Search
18:01:48 <startling> @yahoo hoogle
18:01:48 <lambdabot> Unknown command, try @list
18:01:58 <startling> >:(
18:02:01 <JoeyA> @pl \a b c d e f -> f e d c b a
18:02:01 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
18:03:34 <shachaf> preflex: seen benmachine
18:03:35 <preflex>  benmachine was last seen 141 days, 2 hours, 24 minutes and 52 seconds ago, saying: <private message>
18:04:52 <Wizek> Is there a takeWhile fn which also returns the value that causes it to halt?
18:05:52 <mm_freak> Wizek: takeWhile n . liftA2 (zip (,)) id tail
18:06:03 <johnw> fmap head (partition xs)
18:06:05 <mm_freak> uhm
18:06:16 <johnw> assuming there is more in "xs"
18:06:17 <mm_freak> > takeWhile (< 3) . liftA2 zip id tail $ [1..5]
18:06:19 <lambdabot>   No instance for (GHC.Num.Num (b0, b0))
18:06:19 <lambdabot>    arising from a use of `e_13215'
18:06:19 <lambdabot>  ...
18:06:20 <johnw> oh, and partition takes a predicate
18:06:35 <johnw> > fmap head (partition even [1,2,3,4,5])
18:06:36 <lambdabot>   ([2,4],1)
18:06:46 <johnw> hm.. not it
18:07:04 <johnw> > fmap head (span even [1,2,3,4,5])
18:07:05 <lambdabot>   ([],1)
18:07:09 <mm_freak> > liftA2 zip id tail $ [1..5]
18:07:11 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
18:07:11 <johnw> > fmap head (span odd [1,2,3,4,5])
18:07:13 <mm_freak> oh
18:07:13 <lambdabot>   ([1],2)
18:07:32 <mm_freak> > takeWhile ((< 3) . fst) . liftA2 zip id tail $ [1..5]
18:07:32 <johnw> so, use headMaybe and you're golden
18:07:34 <lambdabot>   [(1,2),(2,3)]
18:07:37 <glguy> Wizek: use "span"
18:07:38 <mm_freak> there you go
18:07:39 <glguy> :t span
18:07:40 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
18:07:51 <mm_freak> and yes, span is better =)
18:08:12 <Wizek> ah, yes, span will do it I believe, thanks
18:08:29 <CodeDmitry> Hello, does anybody know if its possible to use >>= and <<= explicitly?
18:08:40 <CodeDmitry> eg, f =<< g =<< 2
18:08:41 <johnw> certainly
18:08:43 <glguy> CodeDmitry: you want >>= and =<<, right?
18:08:47 <mm_freak> CodeDmitry: of course, and you probably mean =<<
18:08:55 <CodeDmitry> yeah
18:09:08 <CodeDmitry> I cant wrap my mind around how they work
18:09:14 <glguy> Code: but you probably don't want g =<< 2
18:09:32 <CodeDmitry> say, i have f x = x+2 and g x = x**2
18:09:35 <glguy> It's possible that you want a 2 there, but very unlikely
18:09:37 <mm_freak> CodeDmitry: look at the types and mentally replace 'm' by whatever monad you're using
18:09:39 <CodeDmitry> can i make a composite function using >>=?
18:09:46 <shachaf> >>= >=> =>> =<< <=< <<= =>= =<= all exist
18:09:47 <mm_freak> CodeDmitry: by using (.)
18:09:50 <shachaf> Isn't it a bit ridiculous?
18:09:56 <johnw> what is =<=?
18:10:02 <shachaf> Cokleisli composition.
18:10:03 <mm_freak> > (+2) . (**2) $ 3
18:10:05 <lambdabot>   11.0
18:10:10 <johnw> oh, heh, that actually makes sense
18:10:14 <CodeDmitry> i thought it was also possible with >>= and =<<
18:10:20 <glguy> CodeDmitry: >=> and <=< are the compositional versions of >>= and =<<, respectively
18:10:28 <glguy> so you can have: (f <=< g) x
18:10:36 <CodeDmitry> hm
18:10:42 <mm_freak> CodeDmitry: (>>=) and (=<<) are used to compose monadic values/actions
18:10:51 <cmccann> shachaf: did you ever see the coHaskell logo I made?
18:10:56 <mm_freak> for function composition use (.)
18:10:57 <glguy> CodeDmitry: Do you have examples of what you want to do?
18:11:11 <CodeDmitry> i want to do explicit composition of two functions using bind
18:11:19 <CodeDmitry> for the sake of understanding
18:11:23 <mm_freak> CodeDmitry: that doesn't make sense
18:11:27 <applicative> > show <=< show $ 1
18:11:28 <lambdabot>   "'1'"
18:11:38 <glguy> CodeDmitry: Show us an example of what you want to be able to do and what you've tried
18:11:50 <CodeDmitry> I tried doing f <= g <= x
18:11:56 <CodeDmitry> where f,g are functions and x is an input
18:12:00 <CodeDmitry> but it doesnt work
18:12:03 <mm_freak> CodeDmitry: (f . g) x
18:12:06 <CodeDmitry> i also tried <=< and it doesnt owrk
18:12:23 <CodeDmitry> i want to understand the binding, not the compositio
18:12:25 <applicative> import Control.Monad   ((<=<))
18:12:27 <CodeDmitry> i know how . works
18:12:28 <mm_freak> CodeDmitry: f . g is the composition of the functions f and g, and you apply it to x
18:12:41 <johnw> . works between functions a d -> b
18:12:43 <glguy> CodeDmitry: Pick some concrete f,g,and x, perhaps, so that we can talk about specific types
18:12:47 <mm_freak> CodeDmitry: monadic binding is something related, but the types are different
18:12:47 <johnw> >>= works between functions a -> m b
18:12:52 <johnw> sorry, I meant a -> b above
18:13:02 <johnw> and I meant >=>
18:13:03 <johnw> gah
18:13:08 <mm_freak> CodeDmitry: really, look at the types!
18:13:19 <mm_freak> :t (>>=)
18:13:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:13:30 <CodeDmitry> I checked that
18:13:30 <CodeDmitry> and its cryptic
18:13:31 <mm_freak> mentally replace 'm' by some concrete monad like IO or Maybe
18:13:33 <shachaf> Does Foo m a b = Foo { unFoo :: forall c. (b -> m c) -> a -> m c } have the same benefits as Codensity?
18:13:53 <applicative> > enumFromTo 1 >=> show $ 4
18:13:54 <lambdabot>   "1234"
18:13:55 <mm_freak> CodeDmitry: you have a function that produces an IO action like putStrLn or print
18:13:59 <Clint> mmm.. cryptic
18:14:08 <mm_freak> CodeDmitry: but the argument to that function comes as the result of another IO action
18:14:15 <mm_freak> CodeDmitry: (>>=) is the plug
18:14:23 <mm_freak> :t getLine
18:14:24 <lambdabot> IO String
18:14:26 <mm_freak> :t putStrLn
18:14:27 <lambdabot> String -> IO ()
18:14:32 <mm_freak> :t getLine >>= putStrLn
18:14:33 <lambdabot> IO ()
18:14:47 <mm_freak> (>>=) :: IO String -> (String -> IO ()) -> IO ()
18:14:54 <CodeDmitry> so its impossible to compose say, sin and cos with bind?
18:15:05 <CodeDmitry> i can only use .?
18:15:13 <applicative> @type readFile >=> writeFile "tmp"
18:15:14 <lambdabot> FilePath -> IO ()
18:15:17 <cmccann> that's what (.) is for
18:15:22 <cmccann> bind is not for composition
18:15:25 <glguy> CodeDmitry: bind and (.) are totally different
18:15:34 <mm_freak> CodeDmitry: you can make a very werid version of sin . cos using bind…  it's weird, because you don't get a /function/, but a monadic action that produces a function
18:15:51 <CodeDmitry> err, so bind just works is a pipeline of IO and other fun stuff?
18:16:00 <CodeDmitry> like | in unix?
18:16:13 <mm_freak> CodeDmitry: it's a highly generalized, type-safe variant of unix |
18:16:33 <mm_freak> > Just 3 >>= \x -> Just (x + 5)
18:16:34 <lambdabot>   Just 8
18:16:43 <applicative> CodeDmitry: this is a familiar analogy for IO
18:17:06 <applicative> http://okmij.org/ftp/Computation/monadic-shell.html
18:17:11 <CodeDmitry> interesting >.>
18:17:16 <mm_freak> i think unix pipes rather correspond to (>=>), not (>>=)
18:17:26 <mm_freak> where 'return' is the identity morphism
18:17:47 <mm_freak> and 'cat' is the unix identity morphism
18:17:50 <shachaf> Some people, when asking about a problem in #haskell, get a link to okmij.org. Now they have two problems.
18:17:59 <mm_freak> lol
18:18:19 <CodeDmitry> i usually end up with over 5
18:18:21 <AfC> ha
18:18:25 <CodeDmitry> but i somehow manage to get some sort of result
18:18:29 <CodeDmitry> >.>
18:19:16 <mm_freak> @remember shachaf me people, when asking about a problem in #haskell, get a link to okmij.org. Now they have two problems.
18:19:16 <lambdabot> Okay.
18:19:22 <mm_freak> oops
18:19:29 * shachaf people
18:19:36 <cmccann> shachaf is people!
18:19:47 <mm_freak> @forget shachaf me people, when asking about a problem in #haskell, get a link to okmij.org. Now they have two problems.
18:19:47 <lambdabot> Done.
18:19:54 <mm_freak> @remember shachaf Some people, when asking about a problem in #haskell, get a link to okmij.org. Now they have two problems.
18:19:54 <lambdabot> Done.
18:20:00 <mm_freak> there you go =)
18:20:03 * shachaf is made out of people.
18:20:07 <shachaf> They're making shachaf out of people!
18:20:29 <applicative> > let cat = return ; (.|) = (>>=) in cat 14 .| show
18:20:29 <CodeDmitry> Now I shall go into a monastery meditate upon the meaning of "Just"
18:20:29 <mm_freak> @quote schneier
18:20:29 <lambdabot> mm_freak says: bruce schneier is an endofunctor that turns all automorphisms into identities
18:20:31 <lambdabot>   "14"
18:20:36 <CodeDmitry> be back in 10 years
18:20:51 <mm_freak> CodeDmitry: data Maybe a = Nothing | Just a
18:21:03 <applicative> that oleg unix pipes business is unusually lucid
18:21:14 <shachaf> i love unix pipes
18:21:16 <shachaf> they are so easy
18:21:27 <mm_freak> yeah, because there is only one object
18:21:29 <mm_freak> Text
18:21:38 <Clint> you mean ByteString
18:21:49 <mm_freak> true
18:22:00 <shachaf> Lazy ByteString!
18:22:01 <mm_freak> probably lazy ByteString
18:22:05 <mm_freak> hah
18:22:51 <CodeDmitry> what did data Maybe a = Nothing | Just a do
18:22:57 <CodeDmitry> I cant initialize an a, and i cant use an a
18:22:58 <CodeDmitry> >.>
18:23:02 <shachaf> http://slbkbs.org/e/h.txt -----> http://slbkbs.org/e/b.txt
18:23:22 <startling> CodeDmitry: it declares a type "Maybe a" for all types "a"
18:23:49 <startling> CodeDmitry: ("a" is a variable)
18:23:54 <CodeDmitry> i cant use an "a"
18:23:58 <CodeDmitry> :t a crashes
18:23:59 <lambdabot> Not in scope: `crashes'
18:24:07 <startling> CodeDmitry, sure, because it's a variable.
18:24:07 <shachaf> CodeDmitry: You are very confused.
18:24:14 <CodeDmitry> I am
18:24:20 <shachaf> Which introduction to Haskell are you reading?
18:24:29 <CodeDmitry> Real World Haskell, and 50 other sources
18:24:33 <shachaf> OK.
18:24:45 <shachaf> Instead of doing that, take something introductory, and read it from the beginning, carefully.
18:24:55 <shachaf> @where lyah is popular
18:24:55 <lambdabot> http://www.learnyouahaskell.com/
18:25:15 <CodeDmitry> brb
18:27:23 <mm_freak> CodeDmitry: i second shachaf's suggestion…  it seems like you have a very operational thinking, and that's the first thing you have to get rid of
18:27:35 <mm_freak> probably comes from prior programming experience in an imperative language
18:28:38 <Nereid> I wonder if it helped me when learning haskell to have a mathematical background.
18:29:13 <shachaf> Plenty of people learn Haskell without a mathematical background.
18:29:24 <Nereid> of course.
18:29:24 <shachaf> For example me!
18:29:26 <CodeDmitry> I do not see how that is relevant, as while the concepts are unique, they cannot be made sense of unless i understand the context of use, which I can only do by analogy
18:29:26 <Eduard_Munteanu> Monoids may seem less scary of a name.
18:29:35 <mm_freak> Nereid: it probably helped understanding a few basics like the (.) function
18:29:51 <Nereid> I'm not talking about any specific things in it.
18:29:53 <cmccann> Nereid: it seems like that helps a bit, but not enough that it's worth trying to learn any particular math stuff before trying to learn Haskell
18:30:06 <Nereid> just how to think.
18:30:13 <mm_freak> CodeDmitry: that's where your confusion comes from…  in haskell there are a lot of things without usage context
18:30:14 <cmccann> yeah, mathematical thinking in general is probably helpful
18:30:18 <shachaf> I still don't know how to think. :-(
18:30:30 <Eduard_Munteanu> Non-math people tend to be reluctant at learning mathy stuff, IME.
18:30:38 <Nereid> evidently, you like your backwards lenses. :s
18:30:41 <mm_freak> CodeDmitry: you make the context
18:31:12 <shachaf> Maybe you'd learn more if your nick was CodeNsity.
18:31:21 <Eduard_Munteanu> So at least that's one measure of openness towards new things.
18:31:37 <CodeDmitry> How does one make use a pencil without knowing what a pencil is?
18:31:49 <cmccann> Eduard_Munteanu: most non-math people have only been exposed to math by having tedious piles of arithmetic forced upon them
18:32:15 <mm_freak> CodeDmitry: we all learned to use numbers without ever asking what they are…  just consider the 'undefined' value
18:32:18 <Eduard_Munteanu> Yeah, I agree school ruined it for most of them. :(
18:32:18 <mm_freak> undefined :: x
18:32:20 <mm_freak> undefined = undefined
18:32:36 <cmccann> Eduard_Munteanu: you've read Lockhart's Lament, right?
18:32:46 <Eduard_Munteanu> Not really, I should look it up.
18:32:58 <cmccann> http://www.maa.org/devlin/devlin_03_08.html
18:33:09 <Eduard_Munteanu> Oh, I think I have.
18:33:15 <Eduard_Munteanu> Yeah, I definitely remember it.
18:33:23 <mm_freak> CodeDmitry: the haskell community takes this to its conclusion:  abstractions should not be bound to practical purpose, but to theoretical soundness…  once you have soundness, you can apply
18:34:17 <CodeDmitry> I am not one of the few people who can accept facts for themselves, unless the facts are consistent with other concepts that make sense, I am relunctant to accept them. I quite a few months making sense why division by zero is undefined. Now I have no doubts.
18:34:45 <CodeDmitry> Then if somebody asks me in turn to why division by zero is undefined, I won't answer with just "because it is"
18:34:53 <Nereid> division by zero (of nonzero things) can make sense as long as you don't involve addition though.
18:35:02 <CodeDmitry> whereas most people will make you even more confused by resorting to circular reasoning
18:35:16 <Nereid> I'll shut up  now.
18:35:25 <CodeDmitry> lol
18:35:30 * cmccann divides Nereid by zero.
18:35:55 <mm_freak> CodeDmitry: i'm not saying, "because it is", i'm just saying: there is some reasoning behind all that, but that reasoning seldomly refers to practical programming…  the practical programming aspect follows naturally
18:37:58 <CodeDmitry> It's just very difficult to grasp some concepts from limited examples...
18:38:14 <Nereid> examples are great.
18:38:28 <CodeDmitry> eg, this understanding sometimes is not consistent through composition
18:38:48 <CodeDmitry> for example, it is very hard to find good examples of binding
18:38:57 <CodeDmitry> most binding examples are for how bind is defined, not how it is used
18:39:10 <CodeDmitry> which becomes a problem in testing understanding
18:40:01 <mm_freak> CodeDmitry: ok, let me be explicit:  while (.) is composition in the Hask category, (<=<) is composition in the kleisli category of the corresponding monad…  does that help? ;)
18:40:13 <Nereid> ...
18:40:13 <Nereid> :P
18:40:14 * shachaf suspects mm_freak is not in fact helping at all.
18:40:25 <mm_freak> it's not supposed to help =)
18:40:25 <CodeDmitry> it does, since i can not google kleisli
18:40:34 <CodeDmitry> now*
18:40:39 <shachaf> mm_freak: Then why say it?
18:40:48 * Eduard_Munteanu awaits the first math guy to come in and get like, totally enlightened by that explanation
18:41:08 <mm_freak> it only helps in that it builds a bridge between (.) and (<=<)
18:41:20 <mm_freak> i leave building the bridge between (<=<) and (=<<) to someone else =)
18:41:37 <Eduard_Munteanu> "Whoa man, why didn't you say so... all the examples I saw consisted of weird programming stuff."
18:41:47 <cmccann> well, (<=<) is to (=<<) as (.) is to ($)
18:41:51 <cmccann> that part is easy
18:42:04 <mm_freak> CodeDmitry: main = getLine >>= putStrLn
18:42:08 <mm_freak> there is a practical example
18:42:16 <CodeDmitry> that is a good example
18:42:45 <mm_freak> i gave it before, but failed to see that actually writing "main =" would be helpful =)
18:42:46 <Eduard_Munteanu> CodeDmitry: by chance, are you comfortable with do-notation, even on a superficial level?
18:42:58 <Eduard_Munteanu> (some learn a bit of IO before monads at large)
18:42:59 <CodeDmitry> main provides context :\
18:44:10 <Eduard_Munteanu> @undo { a <- f; b <- g a; h a b }
18:44:10 <lambdabot>  Parse error at "{" (column 1)
18:44:19 <Eduard_Munteanu> @undo do { a <- f; b <- g a; h a b }
18:44:19 <lambdabot> f >>= \ a -> g a >>= \ b -> h a b
18:45:03 <CodeDmitry> so >>= only passes monads?
18:45:11 <CodeDmitry> *pipes*
18:45:45 <Eduard_Munteanu> That doesn't make a lot of sense... (>>=) only works with monadic functions, yes.
18:45:57 <Eduard_Munteanu> :t (>>=)
18:45:58 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:46:00 <CodeDmitry> and f x = sin x is not a monadic function?
18:46:14 <Eduard_Munteanu> It isn't.
18:46:21 <CodeDmitry> alright
18:46:37 <CodeDmitry> monadic functions use -> and <-, like a <- getLine?
18:46:38 <Eduard_Munteanu> (although theoretically it could be, but nevermind)
18:46:57 <Eduard_Munteanu> CodeDmitry: -> is totally unrelated to <-
18:47:01 <shachaf> CodeDmitry: I hope this isn't too rude to say, but from what I've seen you don't understand the important parts of Haskell well enough to be worrying about monads.
18:47:05 <shachaf> Did you see the FAQ on this?
18:47:19 <shachaf> http://www.haskell.org/haskellwiki/FAQ#The_M-word
18:47:22 <CodeDmitry> Sounds about right shachaf
18:47:27 <shachaf> Look at 8.3
18:47:28 <CodeDmitry> i guess ill  go read more
18:47:29 <CodeDmitry> :\
18:47:52 <shachaf> So I recommend that you stop worrying about (>>=), which uses a lot of Haskell features that you don't know, and instead learn those features.
18:47:59 <shachaf> They are much more fundamental than monads.
18:48:28 <CodeDmitry> is map and fmap more fundamental?
18:48:32 <CodeDmitry> i cant use those neither
18:48:38 <Eduard_Munteanu> Yeah.
18:48:50 <Eduard_Munteanu> > map (+1) [1,2,3]
18:48:51 <lambdabot>   [2,3,4]
18:48:52 <CodeDmitry> >.>
18:48:58 <johnw> i'd just stick with pure functions, let fmap and monads wait for a while
18:49:03 <CodeDmitry> whats +1
18:49:13 <johnw> that's a nice pure function :)
18:49:14 <shachaf> (+1) is a function.
18:49:16 <zomg> CodeDmitry: exactly what it looks like ;)
18:49:19 <shachaf> "+1" is a syntax error.
18:49:23 <Eduard_Munteanu> CodeDmitry: a section, stands for \x -> x + 1
18:49:23 <shachaf> (On its own.)
18:49:31 <CodeDmitry> it looks like a magic number with a superfluous +
18:49:32 <shachaf> This is described in most introductions to Haskell.
18:49:34 <CodeDmitry> >.>
18:49:42 <shachaf> Are you reading any?
18:49:49 <shachaf> @where lyah is pretty popular.
18:49:49 <lambdabot> http://www.learnyouahaskell.com/
18:49:50 <CodeDmitry> I am
18:49:57 <shachaf> Don't read Real World Haskell.
18:50:03 <shachaf> That one is not so much of an introduction.
18:50:04 <Eduard_Munteanu> Not yet, at least.
18:50:04 <CodeDmitry> It's a bit tricky
18:50:25 <monochrom> (+ 1) is syntax sugar for (\x -> x + 1)
18:50:37 <monochrom> and I lag
18:50:40 <Eduard_Munteanu> > let double x = 2 * x in map double [1,2,3,4]
18:50:41 <lambdabot>   [2,4,6,8]
18:51:44 <monochrom> but it works for all infix operators. (&& blah) means (\x -> x && blah), (blah &&) means (\x -> blah && x)
18:52:13 <aristid> all except (-).
18:52:27 <CodeDmitry> [x+1 | x <- [1, 2, 3]] seems a bit more readable :\
18:52:38 <CodeDmitry> though it kinda abstracts away the map...
18:52:41 <dmwit> > let double x = 2 * x + 1 in map double [1,2,3,4] -- come on, let's be realistic, Real World Haskell looks more like this
18:52:42 <lambdabot>   [3,5,7,9]
18:52:46 <monochrom> yeah, an exception is made for - so that (-5) means negative five as you expect
18:53:03 <parcs> > map (-5) [1..5] -- am i helpful?
18:53:04 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
18:53:04 <lambdabot>    arising from the ambiguity chec...
18:53:11 <monochrom> yes you are welcome to use list comprehension if it floats your boat
18:53:11 <aristid> parcs: :P
18:53:12 <shachaf> parcs: No. So why say it?
18:53:24 <Eduard_Munteanu> CodeDmitry: you should probably look into 'map' and other introductory stuff, so you don't abuse comprehensions too much.
18:53:30 <dmwit> shachaf: As if you ever passed up a chance to be unhelpfully funny.
18:53:48 <parcs> shachaf: for the lulz, of course
18:53:49 <shachaf> dmwit: There is a strong survivor bias involved here.
18:53:54 <shachaf> You have no idea how many chances I've passed up!
18:54:09 <aristid> > map (subtract 5) [1..5] -- the lack of working sections on (-) led to a function just for that
18:54:10 <lambdabot>   [-4,-3,-2,-1,0]
18:54:37 <Eduard_Munteanu> > map 5 [1..5]
18:54:38 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> b))
18:54:39 <lambdabot>    arising from the ambiguity chec...
18:54:50 <aristid> Eduard_Munteanu: i believe that part of lambdabot was killed of
18:54:53 <aristid> :t (.)
18:54:54 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:54:55 <CodeDmitry> I think ill go think about all this... be back when I feel my questions make more sense
18:54:59 <aristid> not this one though
18:55:01 <Eduard_Munteanu> > 5 1
18:55:02 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
18:55:02 <lambdabot>    arising from the ambiguity chec...
18:55:05 <Eduard_Munteanu> Cool.
18:55:18 <shachaf> dmwit: Anyway, #haskell-lens is where it's at for the funpuns.
18:55:18 <aristid> :t flip -- and this was reverted too, i think
18:55:20 <lambdabot> (a -> b -> c) -> b -> a -> c
18:56:28 <aristid> dmwit: #haskell-lens is so much fun, the puns have to be re-written here so dstcruz can pick them up for the HWN.
18:57:36 <aristid> @quote preprosition
18:57:36 <lambdabot> No quotes match. Take a stress pill and think things over.
18:58:23 <shachaf> aristid: You're thinking of prepro*morphism*.
18:59:02 <aristid> @quote prepositions
18:59:02 <lambdabot> cmccann says: * cmccann has concluded that lenses are just a category whose objects are english prepositions and whose morphisms are all unsafeCoerce
18:59:23 <Ralith> hahaha
18:59:26 <edwardk> hah
19:02:09 <aristid> is there a name for categories with exactly one arrow per source/target pair?
19:02:27 <Eduard_Munteanu> Poset categories.
19:02:53 <aristid> so unsafeCoerce forms a poset category with haskell types as objects?
19:02:59 <Nereid> exactly one, or at most one?
19:03:12 <aristid> Nereid: exactly one
19:03:17 <Eduard_Munteanu> Oh, right.
19:03:34 <Eduard_Munteanu> Sorry, posets only do with "most".
19:03:44 <Nereid> let's go with "equivalent to 1"
19:03:46 <johnw> does an oriented graph also count?
19:03:49 * Eduard_Munteanu . o O (tosets?)  :)
19:04:00 <Eduard_Munteanu> (totally-ordered sets)
19:04:03 <shachaf> losets > tosets
19:04:04 <dmwit> I doubt there's a standard name for it.
19:04:09 <shachaf> (But tosets ≥ losets)
19:04:14 <dmwit> How about a "clique category"?
19:04:46 <Nereid> how about a category equivalent to 1.
19:05:09 <aristid> Nereid: doesn't 1 only have one object?
19:05:16 <Nereid> yes, but equvalence is not isomorphism
19:05:32 <aristid> ?
19:05:48 <cmccann> meh, equivalence and isomorphism are the same up to isomorphism
19:05:51 <Nereid> equivalences don't give bijections between objects.
19:05:53 <Nereid> necessarily.
19:05:53 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Equivalence_of_categories
19:05:56 <Nereid> ^
19:06:21 <Eduard_Munteanu> But yeah, I didn't know 1 was equivalent to any of those.
19:07:00 <Eduard_Munteanu> Ah, pretty easy to see though.
19:07:15 <aristid> i think my category corresponds to a complete graph
19:07:24 <aristid> Eduard_Munteanu: how so?
19:07:39 <Nereid> look at the unique functor to 1
19:07:43 <Nereid> it's fully faithful and essentially surjective.
19:07:48 <Eduard_Munteanu> Pick F(C) = *, F(f) = id_*
19:07:50 <aristid> sorry that's over my head :P
19:08:30 <Nereid> well, read the article I guess.
19:08:35 <Eduard_Munteanu> Full and faithful are just surjective, respectively injective for pairs of objects.
19:08:36 <magicman> It's also essentially a total linear order.
19:08:55 <Nereid> no, that's on hom-sets.
19:09:00 <Eduard_Munteanu> *on arrows.
19:09:03 <magicman> Er, that's redudant >_<
19:09:08 <shachaf> @yarrow
19:09:08 <lambdabot> Swab the deck!
19:09:28 <Nereid> aristid: for such a category C, there's a unique C -> 1, and you pick any 1 -> C.
19:09:45 <Nereid> 1 -> C -> 1 is obviously the identity, and C -> 1 -> C is naturally isomorphic to the identity (you prove this).
19:09:55 <aristid> Nereid: hmm i think i was mischaracterizing what i meant though
19:09:58 <Nereid> maybe one should call it a contractible category.
19:09:59 <Nereid> ok
19:10:24 <aristid> because it would be exactly two arrows, not exactly one? for A,B we need A->B and B->A arrows
19:10:26 <Nereid> except not quite.
19:10:42 <Nereid> you said source/target pair, and I assumed pairs were ordered.
19:11:27 <aristid> well either way the thing i mean doesn't form a total order because there are arrows in both directions always.
19:11:51 <dmwit> Yes, it's not a total order.
19:11:53 <Nereid> so you want a category where for each A,B there's exactly one arrow either A ->B or B -> A?
19:12:05 <dmwit> I think that question is orthogonal to whether it's equivalent to the 1 category.
19:12:09 <aristid> Nereid: no, i want both arrows to exist
19:12:14 <Nereid> ok.
19:12:20 <magicman> Then I take back my earlier statement.
19:12:22 <Eduard_Munteanu> Then it's what we said above.
19:12:23 <Nereid> then it's what we said above.
19:12:34 <magicman> And agree with what they said above :p
19:12:40 <Eduard_Munteanu> :D
19:12:48 <aristid> dmwit: well yeah i don't understand the equivalence stuff anyways :P but somebody talked about it being equivalent to a total order and that didn't add up
19:13:11 <Nereid> the other thing would be a connected poset, I think.
19:13:14 <Nereid> no wait.
19:13:23 <Nereid> that's not it either.
19:13:23 <dmwit> Nobody said it was equivalent to a total order.
19:13:33 <aristid> dmwit: linear total order
19:13:53 <Nereid> I mean a poset where any pair is comparable.
19:13:59 <Eduard_Munteanu> aristid: it's just isomorphism up to isomorphism. Instead of have two functors F, G such that FG = 1, GF = 1, you only have FG ~ 1, GF ~ 1
19:14:30 <aristid> Eduard_Munteanu: my knowledge of this stuff is really really superficial, sorry.
19:14:31 <Eduard_Munteanu> Yeah, I was wrong about total orders above.
19:15:58 <Eduard_Munteanu> You just need a bit of background on natural transformations, although I guess you can just get a feeling for it without knowing about natural isomorphisms in detail. :)
19:16:27 <aristid> Eduard_Munteanu: one of these days i want to learn more, but basically my knowledge comes from reading the first 20 pages of a script on CT
19:16:31 <magicman> Ah, right. Because for (A,B), there's A->B, and B->A, and also the compositions of these two A->A and B->B, that necessarily are 1_A and 1_B.
19:16:56 <applicative> a  script??
19:17:14 <aristid> applicative: ?
19:17:21 <applicative> i see, any given script on CT
19:17:29 <aristid> applicative: i like free legal pdf files.
19:18:07 * Eduard_Munteanu ended up buying Awodey's anyway
19:18:24 <Eduard_Munteanu> Ah, free too.
19:18:45 <Eduard_Munteanu> Not sure what's a good free legal introduction to CT these days.
19:19:01 <aristid> Eduard_Munteanu: i'm considering buying the lawvere book
19:19:40 <applicative> they're very different
19:19:58 <aristid> applicative: which in itself is no statement about quality
19:20:17 <applicative> learn you a category theory vs unreal world category theory
19:20:33 <aristid> lawvere is the "learn you a"?
19:20:43 <applicative> yes, surprisingly...
19:21:03 <aristid> surprising because lawvere is a heavyweight in the field?
19:21:04 <dolio> Category theory for people who don't know what functions are.
19:21:06 <Nereid> I have a copy of maclane but I haven't really looked at it.
19:21:19 <Nereid> I should probably learn what ends and kan extensions are at some point.
19:21:25 <shachaf> i love functions
19:21:27 <shachaf> they are so easy
19:21:42 <aristid> f = unsafeCoerce DONE
19:22:15 <Nereid> like
19:22:22 <Nereid> derived functors are kan extensions or something, I guess.
19:22:39 <dolio> Huh?
19:22:59 <Nereid> this has nothing to do with haskell, sorry.
19:24:58 <dolio> Kan extensions are like 'Ran f g a = forall r. (a -> f r) -> g r', where you interpret the quantifier and arrows in an appropriately categorical way.
19:25:20 <aristid> applicative: i think this reinforced my desire to get the lawvere book first.
19:25:23 <roadfish> huh. I tried to "/join #gtk2hs" and then noticed that "TS for #gtk2hs changed from 1358133772 to 1264686904" ... any clue about what the heck that means?
19:25:30 <dolio> Or maybe I got the f and g backwards.
19:25:53 <Nereid> well I know the definition.
19:25:56 <Nereid> that doesn't mean much.
19:26:59 <Nereid> roadfish: it doesn't really mean anything.
19:27:05 <geekosaur> roadfish, http://freenode.net/faq.shtml#channelts
19:27:33 <geekosaur> basically it's chanserv noticing a netsplit after the fact
19:27:42 <dolio> I had something I was going to write about that, but then got lazy.
19:46:37 <dmwit> Wait, there's a #gtk2hs?
19:46:52 <dmwit> Oh, not really.
19:46:54 <dmwit> Good.
19:47:29 <Ralith> why is that good?
19:57:59 <sclv> dolio: I was actually just puzzling over the relationship between the haskell version of Kan extensions vs. the standard categorical definition. In part I've got something that looks almost like a Lan but not quite.
19:58:25 <sclv> If you don't get around to writing it up, I'll just bother you about it on irc anyway :-P
20:06:44 <dolio> sclv: Well, mainly it requires a bunch of background about how to interpret quantifiers categorically, and there's a lot to establishing that.
20:07:43 <Balkanito> http://www.youtube.com/watch?v=ergu2dSIO7U
20:07:59 <dolio> The punchline was that there's a theorem that any small complete category is also cocomplete.
20:08:10 <sclv> hrm. references?
20:08:30 <shachaf> dolio: Hey, ddarius gave me that as an exercise once.
20:08:36 <shachaf> I forgot about it.
20:08:37 <dolio> Which, if you look at it, the construction of Colim J = forall r. (forall a. J a -> r) -> r.
20:09:01 <dolio> As long as you read the quantifiers in the right way.
20:09:07 <dolio> And that's exactly how you'd do it in Haskell.
20:09:46 <sclv> data NotReallyLan f g b = forall a. NotReallyLan (f a) (g (a -> b))
20:09:52 <sclv> is the type i ran into btw
20:10:05 <dolio> Oh. You should ask edwardk about that.
20:10:33 <sclv> Lan is (f a) (g a -> b) so its freaking close
20:11:33 <dolio> He has a store transformer thing where he has to choose between StoreT (w a) (w a -> b) and StoreT (w a) (w (a -> b)) or something like that.
20:11:44 <dolio> And they have somewhat different properties.
20:12:43 <sclv> interesting, i'll pursue that
20:16:50 <shachaf> Maybe that's related to ComonadApply?
20:20:15 <shachaf> It looks like the Apply equivalent of Density.
20:20:58 <Michael_>     `[a] -> a' is applied to too many type arguments
20:20:58 <Michael_>     In the type signature for `play':
20:20:59 <Michael_>       play :: ([a] -> a) -> ([a] -> a) [a] -> [a]
20:21:26 <shachaf> Sounds right to me.
20:21:27 <Michael_> Why does that error occur? At first I tried passing Bool in rather than a, but I still got an error?
20:21:34 <shachaf> Your type is wrong.
20:21:42 <shachaf> Look at the ([a] -> a) part.
20:22:08 <shachaf> What do you expect the type of play to be?
20:22:29 <Playground> Michael_: Both as are supposed to be the same type.
20:22:52 <mapf> I have something strange. I run bench with criterion and heap grows unlimited. Does IO bench and 'collect gc between iterations' works together?
20:22:56 <Playground> Michael_: Otherwise, it would be [a] -> b.
20:23:02 <Michael_> oh, I'm really sorry, it's not an error in the two functions as arguments, rather I missed a ->. Sorry to bother
20:23:07 <shachaf> Playground: That has nothing to do with the error.
20:23:13 <Playground> Oh.
20:23:16 <Playground> My bad.
20:23:18 <mapf> So I really do not understand that is happening.
20:23:42 <shachaf> mapf: I assume GC works as usual.
20:24:01 <shachaf> Lots of things could be going on.
20:24:41 <mapf> I just send 40M buffer to API. API internally just copy from RAM to RAM. So 40 + 40 is just 80, not all my ram...
20:25:08 <shachaf> It seems that one of your assumptions is wrong.
20:25:15 <mapf> which one?
20:25:21 <shachaf> I don't know.
20:25:22 <johnw> maybe it's not copying
20:25:32 <johnw> it might just be recording a pending copy, and then another, etc.
20:25:37 <shachaf> mapf: Maybe if you @pasted some code people would be able to look.
20:25:54 <johnw> how @paste work?
20:26:13 <shachaf> @paste
20:26:13 <lambdabot> Haskell pastebin: http://hpaste.org/
20:26:25 <johnw> ah, you just meant lambdabot to chime in
20:26:32 <mapf> johnw: I'm call clEnqueueWriteBuffer with 40Mb buffer that all. It's OpenCL api.
20:26:53 <johnw> call something in Haskell is not the same as being certain that it being executed at that moment
20:26:54 <shachaf> If that all, then there's not very much code to show.
20:27:20 <johnw> yeah, we need to see code, as shachaf mentioned
20:27:20 <mapf> i can' paste, there are plenty of code
20:27:22 <tomoj> is there a functor for (k -> Maybe a) different from the one for (->) k?
20:27:34 <shachaf> tomoj: You mean as a newtype?
20:27:38 <tomoj> sure
20:27:50 <shachaf> newtype Foo k a = Foo (k -> Maybe a) deriving Functor
20:27:58 <shachaf> Seems like a special-purpose type to me.
20:28:34 <Eduard_Munteanu> @unmtl MaybeT (Reader k) a
20:28:34 <lambdabot> k -> Maybe a
20:28:42 <shachaf> Oh, true, there's MaybeT.
20:29:54 <tomoj> ah
20:30:08 <tomoj> so that's not just a composition of the maybe and reader functors?
20:30:27 <tomoj> or is that exactly what that means..
20:30:29 <shachaf> You can also express it with Compose, sure.
20:31:03 <shachaf> Compose ((->) k) Maybe a ~~ k -> Maybe a
20:31:21 <mapf> heh, it seems like i just have a leak somethere.
20:32:09 <mapf> yep, i shamelessly forgot to release a buffer in bench. ._.
20:32:28 <shachaf> No sham!!
20:32:39 <shachaf> s/!/e/
20:46:55 <roadfish> I want to hack on one of the packages sitting in ~/.cabal/packages/hackage.haskell.org/
20:47:09 <roadfish> but I don't want to damage my current setup
20:47:59 <roadfish> in this case, I want to modify something sitting under Graphics/Rendering/Cairo
20:48:20 <sclv> cabal unpack mypackagename
20:48:28 <sclv> will open it in a new directory
20:48:34 <roadfish> so I have unzipped and untarred it. can I shift it to, say, Graphics/Rendering/Cairo2
20:48:55 <sclv> yeah, you can edit the cabal file to give it a new package name
20:48:59 <roadfish> ok, cabal unpack
20:49:05 <sclv> but the modules will still overlap
20:49:34 <sclv> so you'll need to manually hide/show packages with ghc-pkg so both aren't available at once
20:49:39 <sclv> (if you cabal install it, that is)
20:50:10 <roadfish> is there some way to do "import" without going through with a "cabal install"?
20:50:22 <shachaf> Yes.
20:50:35 <roadfish> is cabal-dev maybe part of the answer?
20:50:39 <shachaf> If you've cabal built a package, you can use the in-place ghc thing.
20:51:01 <shachaf> dist/package.conf.inplace
20:51:08 <shachaf> You can tell GHC to use that.
20:52:20 <roadfish> ok, good ... still not clear on the exact steps. but I think I can search on this stuff. so I guess I want to google this "dist/package.conf.inplace"
20:52:50 <shachaf> roadfish: ghc -package-db, I think.
20:53:13 <shachaf> The User's Guide and/or man page probably talks about it.
20:54:04 <roadfish> ok, thanks for the tips
21:07:36 <roadfish> looks like -package-db is in 7.6 but not 7.4
21:07:43 <shachaf> Oh.
21:07:47 <roadfish> not in the 7.4 man page
21:07:47 <shachaf> I wouldn't know about that.
21:08:02 <roadfish> is on http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/packages.html
21:08:09 <roadfish> but not in the 7.4.1 version
21:08:27 <roadfish> anyway, I still have some good suggestions to search on
21:09:15 <shachaf> `man ghc-7.4.1` lists -package-conf for me.
21:11:49 <roadfish> ok, cool ... want to use -package-conf
21:41:59 <roadfish> sclv shachaf: am now getting prints in my hacked version of cairo-0.12.4. so thanks for the tips.
22:02:54 <shachaf> Maybe I'll ask my question again. I want to find a type p that supports: p a b -> p (r,a) (r,b); p a b -> p (Either r a) (Either r b)
22:03:00 <shachaf> But doesn't support: p a a
22:03:16 <shachaf> (I.e. doesn't have a valid foo :: forall a. p a a.)
22:42:54 <bxc> is there a library function to interleave teh elements of two (or more) lists, like f "abc" "QRZ" = "aQbRcZ" ? I cna't find one in hoogle but it seems familiar as if i've seen it
22:43:48 <shachaf> > concat $ zipWith (\x y -> [x,y]) "abc "QRZ"
22:43:49 <lambdabot>   <hint>:1:44:
22:43:49 <lambdabot>      lexical error in string/character literal at end of input
22:43:54 <shachaf> > concat $ zipWith (\x y -> [x,y]) "abc" "QRZ"
22:43:56 <lambdabot>   can't find file: L.hs
22:43:58 * hackagebot mime-types 0.1.0.2 - Basic mime-type handling types and functions  http://hackage.haskell.org/package/mime-types-0.1.0.2 (MichaelSnoyman)
22:44:00 * hackagebot warp 1.3.7.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.7.1 (MichaelSnoyman)
22:44:00 <shachaf> OK then.
22:44:02 * hackagebot warp-tls 1.3.5 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.3.5 (MichaelSnoyman)
22:44:03 <shachaf> lambdabot hates me.
22:44:05 <shachaf> Someone else type it.
22:44:20 <lambdabot> i don't hate you, try again
22:44:26 <shachaf> OK then.
22:44:27 <shachaf> @msg #haskell i don't hate you, try again
22:44:27 <lambdabot> i don't hate you, try again
22:44:30 <shachaf> Aw.
22:44:34 <shachaf> That kind of spoiled it.
22:44:42 <shachaf> > concat $ zipWith (\x y -> [x,y]) "abc" "QRZ"
22:44:44 <lambdabot>   "aQbRcZ"
22:46:04 <fmap> > concat . getZipList . traverse ZipList $ ["abc", "QRZ"]
22:46:05 <lambdabot>   "aQbRcZ"
22:46:12 <Hafydd> @pl \x y -> [x,y]
22:46:12 <lambdabot> (. return) . (:)
22:46:29 <shachaf> > (concat . transpose) ["abc","QRZ"]
22:46:30 <lambdabot>   "aQbRcZ"
22:48:39 * bxc nods
22:51:31 <slack1256> can somebody help me with this?
22:51:32 <slack1256> http://winterkoninkje.dreamwidth.org/81209.html
22:51:39 <slack1256> how did he derive that a in finite?
22:51:56 <slack1256> *s/in/is/
22:56:02 <sclv> slack1256: think through the type a bit more
22:56:29 <sclv> (a -> f b) -> f (a -> b).
22:56:50 <sclv> assume f is e.g. a list
22:57:00 <sclv> now we've gone from a -> [b] to [ a -> b]
22:57:21 <sclv> how can we do that? only by enumerating every value of a and sticking it in a position in the list.
22:58:43 <sclv> (and then smushing all the results of applying the various inhibitants of a together, which gives the finiteness)
22:59:19 <sclv> e.g. imagine instead of list we have Maybe.
22:59:50 <sclv> we should only get a Just back at the top level if *all* the results of a -> f b give back a Just
23:00:14 <sclv> so to even inspect the top constructor we need to fully enumerate all the values of a, feed them to our function, and check their own top constructor
23:00:53 <sclv> if you look at the source of Searchable that's linked, you'll note that assemble is actually defined in terms of allValues, which should help with the intuition...
23:01:05 <shachaf> That's a fun type.
23:02:41 <shachaf> Of course, writing allValues in terms of assemble is easy if you're used to lenses. :-)
23:02:45 <sclv> you only have to be finite b/c its working over all applicatives. if you specialize a bit more you can do better in many cases.
23:03:26 <slack1256> oh
23:03:39 <slack1256> now I am seeing it
23:04:08 <dolio> It has to be finite if you want it to be total for all applicatives.
23:04:10 <dolio> As he says.
23:04:45 <sclv> this relates to the proof that there's no infinitraversal i imagine
23:04:56 <slack1256> this is cool
23:05:04 <mshassium> Hello.
23:05:16 <edwardk> yes, the things we use every day don't exist.
23:05:35 <sclv> i had heard there was a proof
23:05:39 <mshassium> has any one of Russia
23:05:57 <edwardk> in coq, that if you live in a universe that is coq-like, amazingly you can't do things you can't do in coq
23:06:02 <sclv> but that was two weeks ago, decades in #lens years
23:06:03 <shachaf> mshassium: Maybe try #haskell.ru
23:06:22 <shachaf> Infinitraversals exist but are fishy.
23:06:33 <mshassium> ьфниу
23:06:36 <mshassium> maybe
23:07:12 <sclv> i like fishies. fatty tuna belly especially.
23:07:24 <edwardk> the stock example of an infinite traversal that isn't is you can't walk say, an infinite list with Maybe, right?  well, the culprit there is that Maybe's (<*>) is strict in both arguments, that is where it breaks down, not in the use of traverse in the first place
23:08:00 <shachaf> I think of it as an issue with associativity.
23:08:03 <edwardk> lots of things work with infinite traversals, the laws don't preclude them existing, the laws preclude you from using the associativity law more than a finite number of times
23:08:05 <sw2wolf> :t (<*>)
23:08:06 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:08:07 <shachaf> You have the "finite number of reassociations" argument.
23:08:22 <shachaf> It seems sort of reasonable.
23:08:23 <sclv> so the argument is you have the infinitraversal, it just breaks on some applicatives
23:08:25 <sclv> ?
23:08:34 <sclv> as in we can fold infinite lists, but some folds, like sum, don't work
23:08:39 <shachaf> It's simpler to think of an infinifold.
23:08:58 <shachaf> Those exist/don't exist just as much as infinitraversals.
23:08:59 <edwardk> the argument is that if you have an infinite traversal then you'd better have a monad where forcing it doesn't force an infinite path ;)
23:09:16 <sclv> yeah, that makes sense to me.
23:09:17 <edwardk> its the standard issue you get with data vs. codata.
23:09:33 <edwardk> i can't compute length of an infinite list
23:09:38 <edwardk> does that mean infinite lists don't exist?
23:09:49 <shachaf> It might mean FMLists don't exist!
23:09:55 <shachaf> They're a good deal weirder than infinite lists.
23:10:02 <edwardk> you just learn not to do that and to be careful about specifying if something is a least or greatest fixed point
23:10:21 <sclv> so to make reader traversable, you still need allvalues, but assuming you have that, an infinite list is acceptable?
23:10:22 <shachaf> If I give you an infinite FMList, what can you do with it? You can't reliably get *any* information out of it.
23:10:30 <shachaf> Because maybe its head exists and its last doesn't, or vice versa.
23:11:10 <edwardk> shachaf: i can get information out of it with levels, but i piss all over the monoid laws to do it
23:11:21 <shachaf> edwardk: Sure.
23:11:27 <shachaf> I don't count that. :-)
23:11:31 <sclv> i mean obv list is traversable and possibly infinite
23:11:32 <edwardk> it exists =P
23:11:51 <sclv> so i assumed that infinitraversals don't exist was a more subtle statement than that :-)
23:11:53 <shachaf> OK, so not only infinite traversals exists, but Magma's monoid instance exists?
23:11:57 <shachaf> Good luck convincing roconnor.
23:12:07 <edwardk> shachaf: =P
23:12:15 <edwardk> magma doesn't have a monoid instance
23:12:19 <simpson> :i FMList
23:12:21 <edwardk> the evil monoid instance is on another type
23:12:24 <shachaf> Whatever it's called these days.
23:12:25 <simpson> What's FMList?
23:12:30 <shachaf> @hackage fmlist
23:12:30 <lambdabot> http://hackage.haskell.org/package/fmlist
23:12:40 <shachaf> i love fmlists
23:12:41 <edwardk> actually we don't have a Magma anyways, just scoria, jacket and level
23:12:42 <shachaf> they are so easy
23:12:49 <sclv> it's either a hilarious or unfortunate acronym or both
23:12:58 <edwardk> sclv: hah
23:13:25 <shachaf> FMList = Bazaar for Foldable
23:13:33 <shachaf> Er, for Folds.
23:13:58 * hackagebot forml 0.2 - A statically typed, functional programming language  http://hackage.haskell.org/package/forml-0.2 (AndrewStein)
23:14:22 <simpson> FMList looks a bit crazy.
23:14:34 <shachaf> simpson: Wait until you see Bazaar!
23:14:42 <sclv> ?ty foldMap
23:14:43 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
23:14:52 <shachaf> newtype Bazaar a b t = Bazaar { runBazaar ::forall f. Applicative f => (a -> f b) -> f t }
23:14:55 <simpson> shachaf: I still don't grok Bazaar, but I figure that I can save that for some other day.
23:15:17 <shachaf> simpson: Well, FMList is a special case of Bazaar where "f _ = m"
23:15:34 <sclv> FMList (forall m. Monoid m => (a -> m) -> m)
23:15:44 <shachaf> @ty flip foldMap
23:15:45 <lambdabot> (Foldable t, Monoid c) => t a -> (a -> c) -> c
23:15:58 <sclv> that alpha renaming is terrible
23:16:00 <shachaf> Ugh, now flip's variables are taking precedence?
23:16:02 <dolio> Why wouldn't roconnor agree with the magma instance of monoid? It's an efficient implementation hidden behind an abstraction barrier that makes its instance valid up to extensional equality, right? :)
23:16:30 <shachaf> Magma is not very hidden typically.
23:16:37 <shachaf> Maybe some flavours of it are. Not levels, though.
23:16:43 <sclv> so basically FMList is you take a list, and you apply foldMap to it, and capture the result behind a constructor
23:16:47 <dolio> Can you inspect it yourself?
23:16:56 <sclv> among the things you can do with that function is generate a new list
23:17:05 <sclv> but you can also do all the other things one does with a foldmap
23:18:05 <shachaf> You can even make a Magma!
23:18:10 <dolio> I wonder if people have thought about that....
23:18:14 <shachaf> dolio: I think you can inspect at least one of the varieties yourself.
23:18:43 <dolio> A module where a datatype breaks required equations internally but that breakage is invisible to consumers of the module.
23:18:50 <dolio> Oh.
23:19:19 <shachaf> Well, "levels" doesn't do that.
23:19:33 <shachaf> The point of it is that it gives you values breadth-first as it finds them.
