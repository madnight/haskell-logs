00:51:34 <Lethalman> is there any other way other than creating an ld wrapper script to make gold work with ghc?
01:05:15 <M30W> What is --> for?
01:05:23 <shachaf> Whatever you want it to be.
01:05:43 <M30W> shachaf: Example for use?
01:06:12 <fmap> it's ordinary haskell operator
01:06:33 <fmap> (i.e. provide more context)
01:06:34 * M30W has seen it but doesn't understand what it's for.
01:07:03 <fmap> > let a --> b = a + b in 3 --> 5
01:07:04 <M30W> "332"  --> argAt 1 >>= \chan -> send "MODE" [ chan, "+b" ]
01:07:05 <lambdabot>   8
01:07:34 <shachaf> > "jackal" --> "silver dragon"
01:07:37 <lambdabot>   You zap the wand of polymorph at the jackal! The jackal turns into a silver...
01:07:45 <Ralith> hahaha
01:07:49 <M30W> Wtf?
01:07:50 <Ralith> that is the best num instance
01:07:51 <M30W> How?
01:08:00 <M30W> Ha
01:08:05 <M30W> Smart
01:08:29 <M30W> :t "jackal" --> "silver dragon"
01:08:30 <lambdabot> [Char]
01:08:44 <M30W> :t -->
01:08:45 <lambdabot> <no location info>: not an expression: `'
01:08:55 <M30W> @hoogle -->
01:08:55 <lambdabot> Unknown flag: -->
01:08:55 <lambdabot>  
01:08:59 <M30W> :(
01:08:59 <t7> (-->)
01:09:03 <M30W> @hoogle (-->)
01:09:03 <lambdabot> No results found
01:09:04 <t7> brackets
01:09:12 <M30W> t7: Yea missed them, thanks. :P
01:09:16 <M30W> Still no results. :P
01:11:12 <M30W> http://symbolhound.com/?q=%28--%3E%29+haskell That was useless :|
01:11:57 <shachaf> M30W: As people have said here a few times: It's just an operator. It's not part of Haskell. You can make it whatever you like.
01:12:06 <M30W> Oh
01:12:13 <shachaf> It's not in the standard library.
01:12:19 <M30W> I read it wrong then.
01:12:27 <shachaf> It's just three characters next to each other. :-)
01:12:31 * M30W rages at vodik for having it in his code.
01:12:45 <mikeplus64> M30W: i think it's in xmonad as well
01:12:53 <mikeplus64> @hoogle (-->) +xmonad
01:12:53 <lambdabot> Could not find some databases: xmonad
01:12:53 <lambdabot> Searching in:
01:12:53 <lambdabot>   .
01:12:55 <M30W> Same
01:13:08 <M30W> Not in my config lol.
01:13:18 <M30W> And that thing is huge. ♥
01:13:30 <shachaf> i love huge configs
01:13:32 <shachaf> they are so easy
01:13:43 <M30W> shachaf: You love unicode cause it's easy
01:14:10 <M30W> Ha.
01:14:20 <M30W> When did I bork my git stuff (No such directory .git)
01:14:23 <mikeplus64> M30W: e.g. className =? "Gimp" --> doFloat
01:14:31 <M30W> mikeplus64: Yea.
01:14:41 <ion> m30w: Your things keep laughing a lot.
01:14:46 <shachaf> http://www.haskell.org/hoogle/?hoogle=--%3E+%2Bxmonad
01:14:52 <M30W> ion: ?
01:15:09 <raymank26> hi all. I am trying to build some source code. The code contains #ifdef macros. How can I define them?
01:15:20 <ion> Just now your config was laughing.
01:15:20 <shachaf> raymank26: With #define?
01:15:25 <shachaf> Or -DFOO?
01:15:28 <frerich> M30W: It might also be a port of the C++ "downto" operator. ;-)
01:15:31 <M30W> ion: ?
01:15:34 <fmap> that (-->) is what when should be :[
01:15:49 <shachaf> fmap: ?
01:15:55 <fmap> @ty when
01:15:56 <shachaf> when should involve Monoid?
01:15:57 <lambdabot> Monad m => Bool -> m () -> m ()
01:16:16 <fmap> see, annoying Bool
01:16:28 <shachaf> You want it to accept m Bool?
01:16:31 <fmap> yep
01:16:33 <shachaf> That's a completely different function.
01:16:38 <shachaf> It's also not what (-->) is.
01:17:08 <raymank26> shachaf: I would like to include source code to build tree. What flag should I pass to ghc for #ifdef foo?
01:17:20 <shachaf> raymank26: What?
01:17:29 <shachaf> You want to define the macro foo?
01:17:54 <fmap> well, (--> is completely different generalized when
01:17:55 <raymank26> yes, i think
01:17:58 <fmap> still more convenient :[
01:18:02 <shachaf> 01:15 <shachaf> Or -DFOO?
01:18:06 <shachaf> That, I guess?
01:18:17 <raymank26> o, thank you. I will try it.
01:19:13 <raymank26> shacaf: How pass it to cabal for installing package?
01:19:22 <raymank26> shachaf: How pass it to cabal for installing package?
01:19:28 <mikeplus64> cpp-options: i think raymank26
01:20:00 <mikeplus64> but you can ghc-options: -DFOO
01:20:31 <raymank26> thank you
01:22:10 <M30W> infixr 0 -->
01:22:16 <M30W> What does infixr 0 do?
01:22:29 <mikeplus64> M30W: set the precedence/fixity to 0
01:22:42 <`ramses> fixity declaration, lowest fixity and right-associative
01:22:51 <M30W> Meaning... It's first ?
01:23:07 <killy9999> if there are two modules with the same name, but one is .hs and the other is .lhs which one takes priority?
01:23:20 <M30W> killy9999: Test it ?
01:23:30 <`ramses> it binds very loosely, e.g. f . g --> h . i would be parsed as (f . g) --> (h . i)
01:23:44 <killy9999> M30W: of course if nobody knows then I will ;)
01:24:03 <killy9999> but if someone already knew the answer I'd be happy to hear it
01:24:12 <M30W> killy9999: It takes a few minutes to test
01:24:26 <Botje> M30W: higher binds earlier.
01:24:36 <Botje> M30W: I always look at the precedence of + and - vs * and / :)
01:24:53 <M30W> [1 of 1] Compiling Main             ( a.hs, a.o )
01:24:57 <M30W> killy9999: .hs
01:25:16 <`ramses> I always look at (.) vs ($) cause I know one is highest and one is lowest :)
01:25:28 <killy9999> M30W: just did the same thing, but thanks!
01:25:31 <killy9999> :)
01:25:40 <M30W> ~ >> echo 'main = print "test"' > a.hs
01:25:40 <M30W> ~ >> echo 'main = print "whoah"' > a.lhs
01:25:42 <M30W> killy9999: :)
01:25:53 <M30W> output -> "test"
01:26:35 <M30W> Not that lhs was even valid haha
01:27:34 <`ramses> M30W: it was, it just contained that code as text
01:27:47 <M30W> `ramses: Haha. Indeed.
01:28:02 <raymank26> -D flag isn't works for me. I have build error: cabal install CV. ghc version is 7.6.1. Build error is http://pastebin.com/Fb4hHpZP . And part of source code according to it http://pastebin.com/6tA0zE7Z My cabal command: cabal install CV --ghc-options=-DOpenCV24=1 How to fix that?
01:28:08 <mauke> The pastes Fb4hHpZP 6tA0zE7Z have been copied to http://hpaste.org/80855 http://hpaste.org/80856
01:28:27 <M30W> `ramses: Eitherway it complains when you try to ghc --make it :P
01:28:56 <neutrino> @tell napping thanks!
01:28:56 <lambdabot> Consider it noted.
01:29:30 <`ramses> M30W: ah, seems you do need some ">"s, didn't know that
01:29:59 <merijn> `ramses: You could also use \begin{code} and \end{code} for lhs
01:30:19 <`ramses> I know, didn't want to type out that alternative as well :)
01:30:27 <M30W> `ramses: Don't need, but for a valid program it needs something. I.e if it's a library, it's gonna have module blah where. If it's an execuitable, it's gonna have main =
01:31:37 * M30W wonders why we can't just have main a b c = print $ concat [a, " was nice, while ", b, " was nicer, but ", c, " just sucks"
01:32:01 <M30W> ./program C haskell java
01:32:28 <Cale> C nicer than Java? hmmm...
01:32:36 <srhb> Instead of getArgs, or what do you mean?
01:32:37 <M30W> Cale: Yupp. :)
01:32:38 <Cale> I guess for some purposes, that's true.
01:32:42 <M30W> srhb: Yea.
01:32:47 <Cale> C is a better target language for compilers than Java
01:33:43 <`ramses> M30W: that would be weird and confusing imo
01:33:46 <simpson> I could get behind that.
01:34:03 <shachaf> M30W: Do you know about Hoogle?
01:34:05 <Ralith> Cale: let's not be hasty
01:34:05 <quchen> What does it take for a package to appear in Hoogle? Is there any hope Control.Lens gets added to it anytime soon?
01:34:07 <M30W> srhb: Cause it's kinda not standard compared to the rest of the arguments for any other function. Maybe even let it be read to the type and have if the wrong type is given, complain to the user.
01:34:11 <M30W> shachaf: Yes?
01:34:25 <MasseR> quchen: Honestly, I prefer hayoo
01:34:30 <shachaf> M30W: http://www.haskell.org/hoogle/?hoogle=infixr :-)
01:34:37 <M30W> Heh.
01:34:38 <M30W> Derp
01:34:42 <johnw> MasseR: how come?
01:34:55 <srhb> M30W: But you'd still need getArgs for doing it anywhere else. And you would have to pretend they were pure inside main, or still get them out with bind or do syntax.
01:35:08 <srhb> M30W: Having getArgs means consistency.
01:35:20 <MasseR> johnw: Nice UI, almost as good search and searches from all of hackage
01:35:32 <srhb> And what if your pattern in main doesn't match?
01:35:35 <shachaf> quchen: Hayoo! finds lens operators.
01:36:03 <johnw> MasseR: I build my own Hoogle, which searches more of the Hackage than I want most of the time :)
01:36:12 <shachaf> M30W: Feel free to write your own function to do it.
01:36:12 <M30W> srhb: Generally; main just manages arguments and starts the rest of the program. For me, often loops. (Daemons for tcp networking fun)
01:36:15 <quchen> shachaf: Hayoo has a habit of being down when I need it.
01:36:27 <shachaf> quchen: You can install Hoogle locally with whatever packages you want.
01:36:34 <M30W> Meh
01:36:37 <shachaf> M30W: Of course, you can't make that particular main work, because it's a weird magic thing.
01:36:40 <srhb> M30W: getArgs >>= yourMain
01:36:44 <shachaf> Which is a good reason for it not to exist.
01:36:50 <shachaf> But you can do what srhb said.
01:36:52 <M30W> shachaf: main = getArgs >>= newMain
01:36:56 <M30W> srhb: Just beat me to it
01:37:15 <srhb> I don't think having more magic in main is a good idea. :P
01:37:47 <M30W> main = getArgs >>= go where go a b c = do -- win
01:37:56 <`ramses> what module is getArgs in again?
01:38:02 <srhb> System.Environment
01:38:03 <johnw> System.Environment
01:38:06 <M30W> Control.Environment (getArgs)
01:38:09 <M30W> System *
01:38:17 <johnw> or, @hoogle getArgs
01:38:23 <johnw> @hoogle getArgs
01:38:23 <lambdabot> System.Environment getArgs :: IO [String]
01:38:24 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
01:38:37 <`ramses> ah, right that shows modules as well :)
01:38:56 <M30W> Anyone wanna see my tcp guessing game? (Not guessing the port but guessing the number)
01:39:06 <shachaf> Everything johnw says should be treated as a lambdabot command, because of the @
01:39:24 <srhb> M30W: Funny, I made something similar for a friend in order to show off forkIO
01:39:40 <M30W> Ha
01:39:50 <johnw> shachaf: fsbot in #emacs works that way
01:40:14 <shachaf> johnw: ?
01:40:17 <`ramses> join #vim
01:40:21 <`ramses> oops!
01:40:23 <johnw> oh, n/m
01:40:24 <M30W> http://ix.io/user/archeydevil <<
01:40:25 <M30W> :)
01:40:32 <johnw> your IRC client is showing you my op status
01:40:34 --- mode: johnw set -o johnw
01:40:39 <johnw> mine doesn't
01:42:52 <M30W> shachaf: No it shouldn't lamdabot doesn't even see johnw was op'd in the line it reads to get the commands after PRIVMSG blah :PREFIX
01:43:09 <M30W> Or afaik it doesn't get sent with the user ident.
01:44:42 <shachaf> Clearly we have a moral disagreement.
01:45:00 --- mode: edwardk set -o edwardk
01:49:40 * M30W looks at what he did with getArgs >>= go, and then thinks about the previously used e <- getArgs case e of ... BASICLY THE SAME
01:49:43 <M30W> lol
01:52:45 * M30W is happy with getArgs >>= \e -> case e of
01:54:02 <merijn> M30W: In 7.6 you could use LambdaCase
01:55:07 <merijn> "getArgs >>= \case"
01:55:36 <M30W> O.o
01:55:36 <`ramses> is that recommended to be used already or still pretty experimental?
01:55:54 <Lethalman> \case ... ?
01:55:58 <merijn> `ramses: Define experimental?
01:56:06 <Lethalman> so case is a keyword and can't be used as first lambda argument?
01:56:09 <M30W> merijn: That shouldn't work ?
01:56:19 <`ramses> likely to still change significantly in the future or cause trouble
01:56:20 <kamatsu> LambdaCase is an extension
01:56:23 <merijn> `ramses: It's not backwards compatible, but there's not tricky magic or special semantics so there's not much that could go wrong
01:56:37 <merijn> M30W: LambdaCase is an extension in 7.6 and later
01:56:53 <merijn> M30W: "\case FOO" is identical too "\e -> case e of FOO"
01:57:09 <Lethalman> neat
01:57:29 <M30W> Doesn't work here..
01:57:38 <merijn> `ramses: I would say the odds of it changing are pretty much non-existent, the only downside is your code won't compile on older GHC's (specifically it won't work with Haskell Platform, so that could be an issue)
01:57:43 <M30W> haskell/args/Main.hs:6:21: parse error on input `case'
01:57:52 <merijn> M30W: It needs GHC 7.6 and "{-# LANGUAGE LambdaCase #-}" at the start of your file
01:57:56 <M30W> The Glorious Glasgow Haskell Compilation System, version 7.6.1
01:58:00 <M30W> ah
01:58:13 <M30W> Yay
01:58:14 <M30W> Neat
01:58:15 <M30W> ^_^
01:58:18 <merijn> Or -XLambdaCase as GHC argument, but pragma's are nicer
01:58:26 <M30W> Oh yea.
01:58:44 <`ramses> ah ok, thanks. I often find it difficult to gauge the stability and desirability of all these extensions
01:58:48 <neutrino> hey guys how can i annotate the type of the TVar in this line of code? listTV <- atomically $ newTVar [1, 2, 3]
01:59:02 <merijn> `ramses: Most are rather stable and a large portion desirable
01:59:23 * M30W wonders if it is really worth it.. Okay saves a few characters in source. But.. Doesn't change performance ?
01:59:37 <shachaf> You don't have to use it.
01:59:52 <`ramses> but what's included in most... I've read blog posts showing how combinations of multiple extensions can lead to unsafe code
01:59:54 <merijn> M30W: Probably not, but it can't hurt to know :p
01:59:58 <merijn> `ramses: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
02:00:11 <merijn> `ramses: I (mostly) agree with that answer
02:00:47 * shachaf generally has LambdaCase on the to-avoid list, because the syntax is so ugly.
02:00:48 <neutrino> i want to tell Haskell that it's an [Int]
02:00:51 <shachaf> But that's just me.
02:00:51 <merijn> `ramses: In general I think only Undecidable/Overlapping/Incoherent Instances can cause safety problems
02:01:42 <`ramses> I think the one I meant had to do with GeneralizedNewtypeDeriving, maybe I can find it
02:01:56 * hackagebot websockets 0.7.2.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.7.2.0 (JasperVanDerJeugt)
02:02:12 <`ramses> merijn: http://joyoftypes.blogspot.be/2012/08/generalizednewtypederiving-is.html
02:02:54 <M30W> shachaf: I kinda agree.
02:03:17 <M30W> Lambda's are nice but strange for a case.
02:05:45 <`ramses> merijn: he doesn't seem to really show how he can write unsafeCoerce though, so I don't know how legitimate that post is
02:06:24 <merijn> `ramses: Everything in the "good" list is ok (or even recommendable), GeneralizedNewtypeDeriving can cause issues, in some situations (I'm not really sure which), but generally that only happens if your typeclasses actively try to break things
02:06:45 <merijn> `ramses: tbh, I've not yet had much need for GND, though
02:07:11 <merijn> FlexibleContexts/FlexibleInstances are (despite not being on the list) also fine
02:07:38 <`ramses> ah ok, sufficient answer to me :)
02:08:00 <`ramses> I've only used GND because it is handy for newtyped transformer stacks
02:09:39 <merijn> `ramses: I would actually also add the extensions DataKinds, KindSignatures and PolyKinds to the list of safe/good extensions, but those are mostly useful in 7.6 and further
02:10:13 <`ramses> maybe someone should make an up to date list, the new ones keep on coming ;)
02:10:53 <merijn> `ramses: The GHC manual is actually fairly readable and reasonably clear on how safe things are
02:11:11 <`ramses> you mean the man page?
02:11:23 <merijn> `ramses: No, the html manual
02:11:38 <merijn> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html
02:11:53 <tdammers> this kind of information kind of exceeds the scope of a man page IMO
02:12:02 <M30W> God haven't seen documentation like that since I was using BSD.
02:12:03 <M30W> :(
02:12:22 <M30W> (Well other than that wiki, seen it a few times)
02:12:25 <M30W> those docs *
02:12:34 <`ramses> merijn: thanks, bookmarked
02:12:57 <`ramses> and that are a lot of extensions o.O
02:13:13 <merijn> `ramses: Yeah :p
02:13:54 <merijn> A lot of them are just extra/nicer syntax and ways to get a more expressive type system, though
02:14:01 <neutrino> newTChan doesn't have a value parameter. how is the type of the chan determined? only using type inference from subsequent writes?
02:14:55 <merijn> `ramses: Also, from personal experience: you can learn a lot just reading over them. Most have explanations and examples showing their uses
02:17:18 <`ramses> merijn: until now I've just read the ones I ran into because ghc suggested them + the ones I came across in RWH. Maybe I'll have to read one every day :)
02:17:43 * Walther has been reading Learn You A Haskell and just started reading Real World Haskell yesterday
02:18:00 <`ramses> Walther: I read lyah first as well
02:18:31 <M30W> Lol I found a typo on that huge page :D
02:18:42 <hiptobecubic> I didn't enjoy RWH very much
02:18:45 <Walther> `ramses: it was *fun* to read. tricking my silly brain into rewarding me from reading a programming tuto ;)
02:18:55 <M30W> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#view-patterns << First code block. Spot the typo
02:18:59 <tdammers> I tried "Gentle Introduction" and lyah first, but RWH worked better for me
02:19:15 <neutrino> meh, i have reservations about lyah
02:19:37 <merijn> neutrino: Why?
02:19:41 <M30W> Typ,TypView vs Type,TypeView
02:19:45 <M30W> Fail docs
02:20:10 <merijn> M30W: Submit a patch/fix?
02:20:16 <M30W> merijn: To where?
02:20:42 <`ramses> Walther: yes, it does an awesome job in making the language very intriguing while remaining very tractable.
02:21:11 <`ramses> only the two chapters on io are a bit long winded
02:21:32 <M30W> I would expect someone online would have access to those docs no ?
02:21:34 <neutrino> merijn: in places where miran can't figure out how to present something, he just skips over it and you're left hanging.
02:21:48 <`ramses> neutrino: could you give an example?
02:22:02 <M30W>  n+k pattern support is disabled by default. To enable it, you can use the -XNPlusKPatterns flag.
02:22:02 <neutrino> there are various other observations where the quality is less than desirable
02:22:10 <M30W> Isn't n+k meant to be illegal ?
02:22:16 <`ramses> btw, I think in a beginners guide it is reasonable to leave out some details
02:22:16 <neutrino> let me find a link
02:22:26 <merijn> M30W: Send a mail to the most appropriate list of these: http://www.haskell.org/mailman/listinfo/
02:22:49 <merijn> M30W: n+k are considered bad, and are no longer part of the standard, but the extension still exists for backwards compatibility
02:23:34 <neutrino> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
02:23:39 <M30W> Fair enough
02:23:40 <neutrino> search for "fonzie says".
02:24:11 <`ramses> firefox doesn't find fonzie...
02:24:27 <M30W> `ramses: lies, worked here
02:24:32 <neutrino> then just search for "says".
02:24:39 <`ramses> M30W: huh??
02:24:46 <M30W> `ramses: /fonzi
02:25:15 <marekw2143> what is  <|> ?
02:25:18 <`ramses> seems firefox's search is messed up, it's there indeed
02:25:25 <neutrino> marekw2143: it's an alternative.
02:25:37 <marekw2143> like "OR" in Python?
02:25:40 <M30W> @hoogle (<|>) | marekw2143
02:25:41 <lambdabot> Warning: Unknown type |
02:25:41 <lambdabot> Control.Applicative unwrapArrow :: WrappedArrow a b c -> a b c
02:25:41 <lambdabot> Control.Category id :: Category cat => cat a a
02:25:43 <neutrino> @type (<|>)
02:25:44 <lambdabot> Alternative f => f a -> f a -> f a
02:25:48 <M30W> @hoogle (<|>)
02:25:48 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
02:25:48 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
02:25:48 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
02:26:15 <M30W> marekw2143: like OR in python is what it is in many languages... ||
02:26:19 <M30W> (||) *
02:26:43 <marekw2143> OK:) but it' s: f a -> f a -> f a
02:26:57 * hackagebot hslogstash 0.1.0.0 - A library to write structured messages to a logstash server.  http://hackage.haskell.org/package/hslogstash-0.1.0.0 (SimonMarechal)
02:26:59 * hackagebot aws-sdk 0.9.0.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.9.0.0 (YusukeNomura)
02:27:07 <`ramses> neutrino: he improved that in the printed version
02:27:13 <M30W> let True || x = True; False || x = x
02:27:15 <M30W> Something like that
02:27:17 <marekw2143> so each "ored" value shoudl be instance of Alternative ?
02:27:23 <`ramses> the website is lacking is some aspects that are fixed in the printed version
02:27:28 <`ramses> too bad he never updated the website
02:27:33 <mauke> marekw2143: no, types are instances, not value
02:27:37 <mauke> s
02:28:12 <`ramses> > [1,2] <|> [3,4]
02:28:16 <lambdabot>   [1,2,3,4]
02:28:18 <marekw2143> ok, , so each type hsould be instance of "Alternative"? as there's written: Alternative f => f a -> f a -> f a
02:28:22 <`ramses> > Just 1 <|> Just 4
02:28:23 <lambdabot>   Just 1
02:28:29 <mauke> marekw2143: f is an instance of Alternative
02:28:44 <`ramses> marekw2143: for lists, it gives a new list containing all alternatives, because a list can do that
02:28:47 <M30W> Interesting
02:28:55 <M30W> > 5 <|> 6
02:28:57 <lambdabot>   No instance for (GHC.Num.Num (f0 a0))
02:28:57 <lambdabot>    arising from a use of `e_156'
02:28:57 <lambdabot>  Pos...
02:28:59 <`ramses> for Maybe, it contains just on of the two, because a maybe cannot hold two values
02:29:01 <M30W> :)
02:29:04 <merijn> > Nothing <|> Just 1
02:29:05 <lambdabot>   Just 1
02:29:11 <merijn> > Just 3 <|> Just 1
02:29:12 <lambdabot>   Just 3
02:29:18 <Walther> BTW, given that Haskell is a "purely functional" language, is there such a thing as random?
02:29:25 <mauke> :t random
02:29:26 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
02:29:26 <`ramses> Walther: yes, in IO
02:29:33 <M30W> @hoogle randomRIO
02:29:33 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
02:29:36 <merijn> `ramses: Also pure, if you use a seed
02:29:39 <marekw2143> > Nothing <|> Just 1
02:29:40 <lambdabot>   Just 1
02:29:56 <M30W> > System.Random.randomRIO (0, 1024)
02:29:57 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO a0))
02:29:57 <lambdabot>    arising from a use of ...
02:30:04 <Walther> `ramses: ahh, makes sense to put that in IO; "dirty code"
02:30:13 <merijn> Walther: You can also use seeds + PRNG
02:30:20 <`ramses> merijn: right, but that's more like an rng algorithm, it doesn't give you anything random
02:30:20 <M30W> Hmm ?
02:30:31 <mauke> M30W: no instance for Show (IO a)
02:30:33 <merijn> M30W: randomRIO == IO == no lambdabot
02:30:36 <bartavelle> If the seed is random, it is ok
02:30:39 <M30W> Ah ofc
02:31:10 <`ramses> bartavelle: but then you end up in IO again if you want a "realy random" (modulo all the usual) seed
02:31:13 <M30W> > System.Random.randomRIO (0, 1024) >>= \n -> let a = n in a -- Doubt this will work
02:31:14 <lambdabot>   No instances for (GHC.Num.Num (GHC.Types.IO b0),
02:31:14 <lambdabot>                    System....
02:31:28 <`ramses> M30W: you cannot escape IO
02:31:32 <mauke> M30W: \n -> let a = n in a better written as \n -> n
02:31:43 <mauke> >>= id better written as join
02:31:59 <M30W> mauke: I know. was just trying to hack around that io :P
02:32:08 <mauke> then you don't understand IO
02:32:09 <M30W> But the bot does ZERO of it :(
02:32:10 <`ramses> M30W: you can't!
02:32:18 <M30W> `ramses: I know :'(
02:32:25 <mauke> this is not a syntactic issue
02:32:25 <`ramses> (modulo unsafePerformIO, but lambdabot wont have that either)
02:33:12 <M30W> Does randomRIO use /dev/random ?
02:33:46 <Lethalman> how do I clean up the compiling cache of cabal?
02:33:49 <M30W> Or alike.
02:34:07 <Lethalman> cabal install will reuse the compiled objects of the previous cabal install trial
02:34:08 <TheRedMoodie> Hello :D
02:34:13 <`ramses> M30W: There is a single, implicit, global random number generator of type StdGen, held in some global variable maintained by the IO monad. It is initialised automatically in some system-dependent fashion, for example, by using the time of day, or Linux's kernel random number generator.
02:34:19 <Lethalman> something like cabal install --clean hackage
02:34:24 <`ramses> from the haddock
02:34:35 <TheRedMoodie> is the network package installed by default if I am running haskell on windows?
02:34:46 <`ramses> (should have used quotes)
02:35:35 <M30W> `ramses: "linux's kernel random number generator." Which? /dev/random or /dev/urandom :P
02:35:57 <M30W> Btw, it's a module not the linux kernel's generator.
02:36:03 <`ramses> I was wondering myself, presumably /dev/random as urandom can run out of entropy
02:36:24 <M30W> `ramses: other way
02:37:02 <M30W> /dev/random is useless and uses hardware events to generate entropy; useless if you have a vm cause you don't have all that io to generate the entropy from.
02:37:12 <M30W> /dev/urandom I'm not sure for the methods.
02:37:23 <`ramses> ah, ok, the other way around it is :)
02:37:29 <M30W> /dev/random loops it's entropy when it runs out.
02:37:32 <TheRedMoodie> ..
02:37:59 <`ramses> TheRedMoodie: ghc-pkg list
02:38:05 <TheRedMoodie> ?
02:38:09 <TheRedMoodie> let me try that
02:38:12 <M30W> list installed
02:38:12 <`ramses> that shows the installed packages
02:38:23 <M30W> oh nvm
02:38:34 * M30W was thinking of some other tool maybe cabal?
02:38:39 <`ramses> you can also view the list on the haskell platform's website somewhere
02:38:46 <M30W> Yea.
02:38:56 <TheRedMoodie> nothing
02:39:01 <TheRedMoodie> The site is empty.
02:39:03 <M30W> cabal list (--installed)
02:39:09 <TheRedMoodie> I mean the command gave no output
02:39:34 <TheRedMoodie> It states that network is installed
02:39:35 <M30W> TheRedMoodie: ghc-pgk list gave nothing ?
02:39:40 <TheRedMoodie> Yeah
02:39:47 <TheRedMoodie> non
02:39:56 <TheRedMoodie> ghc-pgk list installed
02:39:56 <`ramses> you have installed the haskell platform?
02:39:58 <TheRedMoodie> gave nothing
02:39:58 <M30W> It would have listed things... base etc
02:40:05 <M30W> TheRedMoodie: Yea, that was wrong.
02:40:05 <`ramses> ah no, drop the installed
02:40:16 <M30W> 21:38         M30W | oh nvm
02:40:18 <M30W> 21:38             -x- M30W was thinking of some other tool maybe cabal?
02:40:26 <TheRedMoodie> oh
02:40:32 <M30W> cabal list --installed # Bit more information. :)
02:40:41 <TheRedMoodie> now it lists a whole lot, but i used grep to serach for network and it is listed there
02:40:47 <TheRedMoodie> I did that, and it also found it.
02:40:53 <TheRedMoodie> but I can't import it.
02:40:59 <M30W> ofc it did; it used it.
02:41:00 <TheRedMoodie> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
02:41:03 <TheRedMoodie> Following that.
02:41:04 <M30W> TheRedMoodie: How are you importing?
02:41:11 <M30W> Oh I know that bot a little well. :)
02:41:13 <TheRedMoodie> The first bolk of code there.
02:41:25 <TheRedMoodie> a little well? Did you write it :D
02:41:30 <M30W> No
02:41:32 <M30W> Lol
02:41:33 <TheRedMoodie> Oh.
02:41:34 <TheRedMoodie> X3
02:41:35 <M30W> Hacked from it :P
02:41:48 <TheRedMoodie> Nice
02:42:15 <TheRedMoodie> Well, could you enlighten me as to both my windows laptop and my gentoo home server doesn't find the "Network" module ?
02:42:15 <M30W> TheRedMoodie: ghci import Network
02:42:17 <M30W> Give error
02:42:24 <TheRedMoodie> got it
02:43:07 <TheRedMoodie> in the cli or once I am in ghci, do i type import Network
02:43:22 <M30W> in ghci where import seems useful
02:43:47 <TheRedMoodie> I don't know ghci, so I thought those parameters, might booted it up with network loaded :3
02:43:53 <TheRedMoodie> Well there is no error.
02:44:05 <M30W> No error okay.
02:44:10 <M30W> runhaskell ircbot.hs
02:44:48 <TheRedMoodie> Could not find module `Network':
02:44:50 <M30W> Acturally; inside ghci. :l ircbot.hs
02:44:58 <TheRedMoodie> give me a secound...
02:45:17 <M30W> s/u//
02:46:13 <TheRedMoodie> No error.
02:46:29 <M30W> Strange
02:46:31 <TheRedMoodie> Haha, isen't regeular expressions lovley?
02:46:38 <TheRedMoodie> And also, there is no output
02:46:46 * M30W doesn't even dare to make a regexp to correct that.
02:47:18 <TheRedMoodie> Haha, you could do it with optional matching.
02:47:25 <M30W> TheRedMoodie: oh yes. :run main
02:47:59 <TheRedMoodie> Now it is importing something..
02:48:07 <M30W> ;)
02:48:15 <TheRedMoodie> There was absoulutly no output, but it did work
02:48:17 <TheRedMoodie> I mean
02:48:28 <TheRedMoodie> From the stream, from freenode there was no output.
02:48:31 <TheRedMoodie> But it imported a set of packages.
02:48:54 <M30W> It doesn't print out the network activity
02:48:57 <M30W> It worked
02:49:04 <TheRedMoodie> Yeah, i know :D
02:49:09 <TheRedMoodie> I just need to change a port...
02:49:28 <TheRedMoodie> There we go :D
02:49:30 <M30W> pong x    = write "PONG" (':' : drop 6 x)
02:49:31 <M30W> Wow
02:49:54 <TheRedMoodie> ?
02:50:03 <M30W> Funny bot code
02:50:40 <TheRedMoodie> Ahh, I am still very new to haskell, so I can kind of guess what the first part does, but other than that its greek to me
02:51:10 * M30W wonder why the hell that bot has readerT....
02:51:57 * hackagebot CV 0.3.7 - OpenCV based machine vision library  http://hackage.haskell.org/package/CV-0.3.7 (VilleTirronen)
02:52:02 <M30W> TheRedMoodie: https://github.com/vodik/ircbot/ <<< Better irc bot. :D
02:52:20 <TheRedMoodie> Is that yours?
02:52:24 <TheRedMoodie> :D
02:52:30 <M30W> Nope
02:52:36 * M30W /= vodik
02:52:44 * M30W == archeydevil
02:52:56 <M30W> TheRedMoodie: ^^
02:53:01 <marekw2143> myfun a b | trace ("myfun " ++ show a ++ " " ++ show b) False = undefined
02:53:07 <TheRedMoodie> ....
02:53:09 <marekw2143> what above ^^ code "says" ?
02:53:40 <M30W> wtf ?
02:53:44 <TheRedMoodie> myfun + variable a + " " + variable b ?
02:53:48 <Lethalman> marekw2143, trace is your problem?
02:53:57 <TheRedMoodie> I don't know what trace is?
02:54:20 <mauke> @index trace
02:54:20 <lambdabot> Debug.Trace
02:54:23 <Lethalman> marekw2143, that code is there just to show the values of a and b
02:54:35 <marekw2143> Lethalman: but waht "|" means?
02:54:39 <TheRedMoodie> But M30W What can the problem be? I can't compile the .hs file if I Can't import the network module outside of ghci ?
02:54:39 <M30W> marekw2143: myfun a b | trace $ concat ["myfun ", a, " ", b"] False = undefined
02:54:40 <Lethalman> marekw2143, it's a guard
02:54:54 <M30W> TheRedMoodie: I have no idea. :|
02:54:57 <marekw2143> oh, when myfun evaluates to "False"?
02:54:58 <TheRedMoodie> :(
02:55:02 <M30W> TheRedMoodie: :(
02:55:09 <TheRedMoodie> Both linux and windows...
02:55:10 <M30W> TheRedMoodie: It's strange, I have to give you that. :)
02:55:14 <M30W> TheRedMoodie: Both ?
02:55:16 <M30W> What distro?
02:55:24 <Lethalman> marekw2143, no, when False happens to be True, which is never... that code is there just to debug the values of a and b
02:55:51 <monoidal> marekw2143: when myfun is evaluated, the guard is run, it prints value of a and b and then returns false (i.e. we proceed to the next clause and disregard 'undefined')
02:55:51 <TheRedMoodie> gentoo
02:55:55 <M30W> Lethalman: Nice when False happens to be True. Love it :D
02:56:01 <c_wraith> though it has a type error as written
02:56:01 <M30W> TheRedMoodie: What did you break?
02:56:06 <TheRedMoodie> Haha
02:56:07 <TheRedMoodie> Nothing.
02:56:14 <c_wraith> you want trace (concat ..) False
02:56:16 <M30W> TheRedMoodie: Just "Obviously, something"
02:56:29 <mauke> TheRedMoodie: what did you do? what error message did you get?
02:56:34 <TheRedMoodie> Ahh, it is flaming gentoo X3
02:56:36 <marekw2143> Lethalman: but from what I know guards are evaluated from left to right, so why should "trace" be evaluated ?
02:56:51 <Lethalman> marekw2143, mh?
02:56:52 <TheRedMoodie> Well, nothing. It can't find "Network" from outside of ghci
02:56:53 <mauke> marekw2143: because trace is left
02:56:57 * hackagebot hgettext 0.1.30 - Bindings to libintl.h (gettext, bindtextdomain)  http://hackage.haskell.org/package/hgettext-0.1.30 (VasylPasternak)
02:56:59 * hackagebot http-conduit 1.8.7 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.7 (MichaelSnoyman)
02:57:06 <marekw2143> "left"?
02:57:06 <mauke> TheRedMoodie: dude, you don't get random error messages just for sitting at your terminal
02:57:12 <mauke> TheRedMoodie: you must have run some command
02:57:12 <M30W> marekw2143: Left *
02:57:17 <mauke> marekw2143: your words
02:57:19 <marekw2143> what does it mean?
02:57:27 <mauke> I don't know, you said "from left to right"
02:57:29 <M30W> marekw2143: Left "Error" Right "Success"
02:57:31 <marekw2143> what does it mean: trace is left?
02:57:34 <mauke> M30W: what?
02:57:36 <TheRedMoodie> mauke, do you want the exact command I ran to get the not found message?
02:57:45 <mauke> TheRedMoodie: yes, and I want the exact error message
02:57:47 <M30W> mauke: What?
02:57:49 <TheRedMoodie> got it :D
02:57:56 <mauke> M30W: why are you talking about Either?
02:58:07 <M30W> mauke: "Trace is left"
02:58:12 <TheRedMoodie> ghc --make flagboot.hs
02:58:21 <M30W> "because trace is left" *
02:58:23 * M30W doesn't know.
02:58:33 * M30W read that as the return.
02:58:45 <TheRedMoodie> flagboot.hs:1:7:
02:58:45 <TheRedMoodie>     Could not find module `Network':
02:58:45 <TheRedMoodie>       Use -v to see a list of the files searched for.
02:58:47 <Lethalman> M30W, that's just spamming and confusing people
02:58:48 <TheRedMoodie> There
02:58:58 <TheRedMoodie> Thats the exact error message.
02:59:03 <mauke> marekw2143: (left side >) trace ("myfun " ++ show a ++ " " ++ show b) False (< right side)
02:59:08 * M30W wonders if TheRedMoodie tried with -v :)
02:59:13 <mauke> marekw2143: clearly 'trace' is on the left
02:59:16 <TheRedMoodie> I did :D
02:59:28 <marekw2143> mauke: on the left of what ? :)
02:59:39 <TheRedMoodie> It seems it only searched in my current directory
02:59:44 <M30W> Using binary package database: /usr/lib/ghc-7.6.1/package.conf.d/package.cache
02:59:44 <shachaf> marekw2143: Of my screen.
02:59:45 <M30W> Using binary package database: /home/archey/.ghc/x86_64-linux-7.6.1/package.conf.d/package.cache
02:59:52 <M30W> TheRedMoodie: Do you have something of the like at the top?
02:59:58 <gspr> This is probably a stupid question, but I'll shoot anyway: When doing length-typed lists in the standard way, one essentially also re-implements the list data structure itself. This is fine since lists are very simple, but I still wonder, is it possible to wrap existing data types in a "length-typed" wrapping? I feel it oughta be possible, but precisely how escapes me..
03:00:11 <TheRedMoodie> yes
03:00:21 <shachaf> gspr: In Haskell or in something like Agda? :-)
03:00:23 <mauke> TheRedMoodie: what does 'ghc-pkg find-module Network' say?
03:00:43 <gspr> shachaf: Haskell, yes... with various extensions, of course.
03:00:52 <M30W> TheRedMoodie: ghc --make flagboot.hs |& curl -F 'sprunge=<-
03:00:56 <M30W> TheRedMoodie: ghc --make flagboot.hs |& curl -F 'sprunge=<-' sprunge.us
03:00:58 <TheRedMoodie> That yealds: /usr/lib/ghc-6.12.3/package.conf.d
03:01:05 <shachaf> gspr: You "pretty much" have to redefine the type.
03:01:12 <mauke> TheRedMoodie: is that all?
03:01:26 <TheRedMoodie> yes
03:01:27 <TheRedMoodie> http://sprunge.us/NfIH
03:01:32 <M30W> TheRedMoodie: ghc -v --make flagboot.hs |& curl -F 'sprunge=<-' sprunge.us
03:01:36 <gspr> shachaf: While I love the standard length-typed lists that are always the first example of using type-level naturals, I feel it leaves a lot to be desired if one has to re-implement the underlying data structure as well.
03:01:36 <M30W> TheRedMoodie: Missed that -v lol
03:01:46 <gspr> shachaf: Oh.. well.. that's a shame
03:01:47 <mauke> M30W: "lol" is still not punctuation
03:01:54 <gspr> shachaf: Thanks for the info :)
03:01:58 <TheRedMoodie> http://sprunge.us/AVDF
03:01:59 <M30W> mauke: >_<
03:02:05 <shachaf> gspr: In something like Agda you can have a proof as a value.
03:02:14 <M30W> Using binary package database: /usr/lib/ghc-6.12.3/package.conf.d/package.cache
03:02:26 <shachaf> gspr: So you might have the type ((x:[a]), ProofThatLengthIsEven x)
03:02:28 <M30W> Strange.
03:02:30 <gspr> shachaf: Right. I can imagine it being possible in Agda.
03:02:31 <TheRedMoodie> I have to go now :(
03:02:38 <TheRedMoodie> I will see you later
03:02:46 <monoidal> gspr: you can go from labelled to non-labelled with an existential
03:03:11 <M30W> mauke: It's a bad habbit; I hate it too >_<
03:03:25 * M30W tends to "lol" in here and ^_^ in #archlinux. :|
03:03:28 <mauke> TheRedMoodie: emerge -va dev-haskell/network
03:03:43 <monoidal> #join #haskell-in-depth	
03:03:47 <gspr> shachaf: What I was thinking, though, is that any data structure for which "length-typing" makes sense, typically has a way to build said structure from a list, i.e. a fromList function, one could somehow utilize the length-typed lists to length-type any suitable already-existing type.
03:04:06 <TheRedMoodie> Thanks alot mauke!
03:04:10 <gspr> monoidal: I don't think I got that part...
03:04:28 <gspr> monoidal: Was the comment on #haskell-in-depth meant for me?
03:04:39 <monoidal> gspr: no, that was a type
03:04:40 <mauke> gspr: unlikely
03:05:00 <gspr> mauke: OK
03:05:10 <monoidal> gspr: if List n a are lists of length n, then data List' a = forall n. List' (List n a) are lists of unspecified length
03:05:24 <Eduard_Munteanu> gspr: in Agda you could just call length on that list, even in a type.
03:06:11 <M30W> TheRedMoodie: You only have 6.12.3 and you're on gentoo... Is that their newest version?
03:06:11 <gspr> Eduard_Munteanu: I see
03:06:25 <M30W> The Glorious Glasgow Haskell Compilation System, version 7.6.1
03:06:48 <mauke> M30W: newest default version, yes
03:06:55 <M30W> Heh
03:07:05 <mauke> you have to manually unblock newer versions
03:07:05 <Eduard_Munteanu> M30W: yeah, although there's a 7.4.2 available keyword-masked
03:07:15 <Eduard_Munteanu> Which is what I use.
03:07:16 <gienah> the gentoo haskell overlay has The Glorious Glasgow Haskell Compilation System, version 7.7.20121213
03:07:34 * M30W has to go.
03:07:35 <gienah> ghc 7.6.1 compiles more stuff though
03:07:40 <M30W> Good bye world. ^_^
03:08:23 <mSSM> Is there some function that can give me: a -> m [a] -> m [a] ?
03:08:44 <mauke> :t fmap . (:)
03:08:46 <lambdabot> Functor f => a -> f [a] -> f [a]
03:09:03 <Eduard_Munteanu> :t flip const
03:09:04 <lambdabot> b -> c -> c
03:09:05 <johnw> :t liftM . (:)
03:09:06 <Eduard_Munteanu> :P
03:09:07 <lambdabot> Monad m => a -> m [a] -> m [a]
03:09:16 <mauke> :t const id
03:09:18 <lambdabot> b -> a -> a
03:09:36 <mauke> :t pure ask
03:09:38 <lambdabot> (Applicative f, MonadReader r m) => f (m r)
03:10:07 <mauke> > pure ask 'a' (Just "hello")
03:10:08 <mSSM> johnw: What does that . do?
03:10:09 <lambdabot>   Just "hello"
03:10:23 <mauke> mSSM: function composition
03:10:27 <mSSM> oh
03:10:30 <mSSM> right :D
03:11:19 <mSSM> mauke, johnw: thanks
03:20:04 <M30W> "reversing twice a finite list, is the same as identity"
03:20:10 <M30W> What is id meant to be exactly ?
03:20:16 <srhb> id a = a
03:20:33 <M30W> Point being ?
03:20:50 <srhb> What do you mean? It's the identity function.
03:21:09 <M30W> I mean.. It's useful for..... nothing ?
03:22:14 <mauke> M30W: is 0 even a number?
03:22:28 <M30W> Yes?
03:22:48 <M30W> What would id be useful for?
03:23:02 <monoidal> http://stackoverflow.com/questions/3136338/uses-for-haskell-id-function
03:23:52 <mauke> M30W: what would 0 be useful for?
03:23:58 <srhb> Consider id to (.) as 0 is to addition
03:24:06 <srhb> (That's just one case, where it's obvious)(
03:24:08 <typoclass> monoidal: that's a good link. thanks
03:24:37 <M30W> I see
03:24:45 <srhb> I assume there's a monoid for (->) ?
03:24:55 <srhb> Oh wait.
03:24:57 <fmap> more than one
03:25:06 <M30W> @hoogle (->)
03:25:06 <lambdabot> keyword ->
03:25:06 <lambdabot> Test.QuickCheck.Function data (:->) a c
03:25:07 <srhb> Yeah.
03:25:45 <mauke> @src Endo
03:25:45 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:26:39 <M30W> getArgs >>= \a -> case a of { (p:l:u) -> let port = p; lower = l; upper = u ; ... } -- How does that not work?
03:27:04 <mauke> M30W: I don't know, how does it not work?
03:27:27 <merijn> M30W: Is upper a list?
03:27:36 <M30W> No
03:27:41 <merijn> M30W: There you go
03:27:46 <mauke> upper is clearly a list
03:27:50 <mauke> it's on the RHS of :
03:27:51 <M30W> Ah ofc
03:28:13 <mauke> also, why not just write case a of { port:lower:upper -> ... }?
03:28:31 <M30W> That makes more sense...
03:29:03 <mSSM> What's wrong with: `foo x | x <= 0 = return [] | otherwise = do { y <- bar x ; fmap . (:) y $ foo (x-1) }'
03:29:27 <M30W> Surprisingly not readability :)
03:29:49 <mSSM> Where `bar x :: IO Int' as an example
03:29:51 <merijn> mSSM: What is fmap fmapping?
03:29:57 <mSSM> Where `bar x :: Int -> IO Int' as an example
03:30:01 <mauke> mSSM: precedence
03:30:15 <mauke> also, you want fmap (y :) (foo (x - 1))
03:30:50 <M30W>     parse error (possibly incorrect indentation or mismatched brackets)
03:30:56 <M30W> Why :|
03:31:09 <mSSM> merijn: I want to end up with an IO [Int]
03:31:16 <M30W> Everything is aligned...
03:31:18 <mauke> M30W: possibly incorrect indentation or mismatched brackets
03:31:21 <monoidal> mSSM: what is type of bar?
03:31:30 <mauke> <mSSM> Where `bar x :: IO Int' as an example
03:31:31 <mSSM> monoidal: :: Int -> IO Int
03:31:40 <M30W> getArgs >>= \a -> case a of p:l:u -> let port = p; lower = l; upper = u
03:31:44 <mSSM> mauke: sorry, I fixed it after
03:31:44 <monoidal> mSSM: foo x = mapM bar [1..x]?
03:31:49 <mauke> mSSM: no, you broke it
03:31:58 <mSSM> :D
03:32:16 <mauke> :t getArgs >>= \a -> case a of p:l:u -> let port = p; lower = l; upper = u
03:32:18 <lambdabot> parse error (possibly incorrect indentation)
03:32:27 <mauke> M30W: that's not a valid program
03:32:32 <M30W> I know
03:32:59 <mauke> missing 'in' after 'let'
03:33:35 <M30W> in the rest of the program..
03:36:53 <mSSM> liftM is just monadic fmap ?
03:37:18 <monoidal> mSSM: yes, it's essentially the same thing
03:37:49 <mSSM> monoidal: Has that something to do what Functor (?) was introduced later?
03:37:52 <mSSM> Or something like that?
03:38:41 <monoidal> mSSM: yes, it's a historic accident
03:38:51 <monoidal> liftM = liftA = fmap
03:39:01 <mSSM> monoidal: Are there plans to fix this? It seems redundant?
03:39:36 <monoidal> mSSM: there are alternative preludes that fix it, but they're used rather rarely
03:40:07 <monoidal> mSSM: perhaps in the future it will be fixed
03:40:29 <fmap> mSSM: fix what? you still may want to use liftA/liftM as default implementations
03:41:08 <mSSM> fmap: haha :D
03:41:17 <fmap> i.e `instance Functor X where fmap = liftA; instance Applicative X where ...'
03:41:18 <monoidal> fmap in almost all cases can be derived automatically
03:41:19 <mSSM> I am wondering about the redundancy
03:41:48 <mSSM> Or do you _want_ to have fmap, liftA, liftM?
03:41:58 * hackagebot mathgenealogy 1.3.0 - Discover your (academic) ancestors!  http://hackage.haskell.org/package/mathgenealogy-1.3.0 (PeterRobinson)
03:42:05 <fmap> yes
03:42:20 <M30W> How would one take either from a default or use the first argument (if given)
03:42:59 <M30W> type of Integer
03:43:35 <fmap> mSSM: see also fmapDefault and foldMapDefault from Data.Traversable
03:45:09 <fmap> i love redundancy
03:45:37 <`ramses> if one of them fails, we can just switch to another one ;)
03:46:05 <neutrino> is there a function like this? Alternative f => f a -> f b -> Either a b
03:46:15 <M30W> > Nothing <|> 555
03:46:17 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
03:46:17 <lambdabot>    arising from a use o...
03:46:32 <M30W> > Nothing <|> Just 555
03:46:34 <lambdabot>   Just 555
03:46:43 <M30W> @hoogle (<|>)
03:46:43 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
03:46:44 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
03:46:44 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
03:46:55 <M30W> @hackage control.applicative
03:46:55 <lambdabot> http://hackage.haskell.org/package/control.applicative
03:47:00 <neutrino> M30W: that's not what i want though..
03:47:05 <neutrino> but.. hmm, i think i have an idea
03:47:10 <M30W> What's the way to get that link?
03:47:18 <monoidal> neutrino: since data Empty a can be made an Alternative, the answer is no
03:47:37 <merijn> neutrino: What would it decide on?
03:47:40 <monoidal> neutrino: um I mean data Empty a = E
03:47:51 <neutrino> yeah btw i got the result type wrong
03:48:11 <neutrino> i guess i want Alternative f => f a -> f b -> f (Either a b)
03:48:24 <`ramses> :t liftA2 (const Right)
03:48:25 <lambdabot> Applicative f => f a -> f b -> f (Either a1 b)
03:48:26 <neutrino> but i'll just use <|> and Left / Right explicitly
03:48:44 <merijn> neutrino: can't you just "fmap" Left /Right in there and then use <|>?
03:48:45 <neutrino> `ramses: how does that work?
03:48:47 <M30W> > Just Nothing
03:48:49 <lambdabot>   Just Nothing
03:49:12 <`ramses> neutrino: it applies Right in the second Applicative :) probably not what you want, but it has the right type
03:49:27 <neutrino> right..
03:49:33 <merijn> @pl \x y -> (Left <$> x) <|> (Right <$> y)
03:49:33 <lambdabot> (. (Right <$>)) . (<|>) . (Left <$>)
03:49:38 <merijn> :t \x y -> (Left <$> x) <|> (Right <$> y)
03:49:39 <lambdabot> Alternative f => f a -> f b -> f (Either a b)
03:49:49 <merijn> :t uncurry
03:49:51 <lambdabot> (a -> b -> c) -> (a, b) -> c
03:50:09 <neutrino> how does uncurry help?
03:50:12 <merijn> :t uncurry (<|>) . Left &&& Right
03:50:13 <lambdabot>     Couldn't match expected type `(f0 a0, f0 a0)'
03:50:13 <lambdabot>                 with actual type `Either b0 b1'
03:50:13 <lambdabot>     Expected type: b0 -> (f0 a0, f0 a0)
03:50:16 <monoidal> neutrino: what would you expect for f [1,2,3] [False,True], for example?
03:50:16 <neutrino> hmm
03:50:17 <merijn> oh, wait
03:50:35 <merijn> Anyway, you get the idea
03:50:37 <neutrino> monoidal: not sure what your code means.
03:51:00 <merijn> neutrino: [] is an instance of Alternative, so what would it do for that list?
03:51:03 <monoidal> neutrino: you want f :: Alternative f => f a -> f b -> f (Either a b). what should be the result of  f [1,2,3] [False,True] be?
03:51:21 <M30W> monoidal: Do you mean zipWith f [1,2,3] [False,True] ?
03:51:30 <monoidal> M30W: no
03:51:35 <`ramses> no, the lists are alternatives
03:51:35 <M30W> Okay
03:51:38 <neutrino> monoidal: you use the same label for two things, that's confusing
03:51:54 <`ramses> but given any two elements, e.g; 1 and True, the result could either be Left 1 or Right True
03:51:58 <`ramses> which one should it be?
03:51:58 * hackagebot billboard-parser 1.0.0.1 - A parser for the Billboard chord dataset  http://hackage.haskell.org/package/billboard-parser-1.0.0.1 (BasDeHaas)
03:52:13 <neutrino> anyways, i want to use this for STM, and find out whether my result came from the left or the right, that's all
03:53:36 <`ramses> neutrino: maybe you should supply some example output
03:54:05 <merijn> `ramses: He just said what, he wants to use the STM instance of Alternative and figure out *which* one completed
03:54:32 <M30W>  s <- listenOn . PortNumber $ fromInteger p; runConn s
03:54:43 <`ramses> ah, okay, didn't know that was an alternative as well
03:54:45 <M30W> How could that be merged to a single line ?
03:55:03 <monoidal> M30W: (listenOn . PortNumber $ fromInteger p) >>= runConn
03:55:12 <M30W> Ahh parens
03:58:24 <Lethalman> what is <|> for? is it some other kind of monoid?
03:58:38 <merijn> :t (<|>)
03:58:39 <lambdabot> Alternative f => f a -> f a -> f a
03:58:55 <merijn> Lethalman: It's for applicatives that have a notion of alternatives
03:59:05 <M30W> > Nothing <|> Just 5
03:59:06 <srhb> Lethalman: Right, it's a monoid for Applicatives
03:59:06 <lambdabot>   Just 5
03:59:06 <mSSM> Say, I have a function that gives me a [Int] with about 10^7 elements, and then I want to `sum $ giveBigList n', will Haskell first spit out that [Int] and THEN sum, or will it be smart enough to do it during the run?
03:59:07 <Lethalman> merijn, the result is either the one on the left or on the right?
03:59:09 <merijn> (Or Functors, I forget which)
03:59:10 <M30W> > Just 2 <|> Just 5
03:59:11 <lambdabot>   Just 2
03:59:14 <M30W> lambdabot: ^^
03:59:16 <merijn> Lethalman: Well, both in some cases
03:59:25 <merijn> > [1,2,3] <|> [4,5,6]
03:59:27 <lambdabot>   [1,2,3,4,5,6]
03:59:30 <Lethalman> :S
03:59:37 <Lethalman> > [1,2,3] <> [4,5,6]
03:59:39 <lambdabot>   [1,2,3,4,5,6]
03:59:46 <Lethalman> what's the difference here?
03:59:47 <`ramses> Lethalman: as lists can hold several elements, these can combine all alternatives
03:59:56 <`ramses> without dropping any
03:59:58 <M30W> > Nothing <> Just 5
04:00:00 <lambdabot>   Ambiguous type variable `a0' in the constraints:
04:00:00 <lambdabot>    (GHC.Num.Num a0)
04:00:00 <lambdabot>      a...
04:00:03 <mSSM> I am wondering about the space Haskell allocates for that big list, if I just want to throw it away after summing the elements
04:00:04 <M30W> Lethalman: More support :)
04:00:13 <merijn> mSSM: Depending on the surrounding code haskell can eliminate the allocation, yes
04:00:14 <`ramses> a Maybe on the other hand cannot do that, so it has to drop something for two Justs
04:00:16 * M30W goes offline. Night world.
04:00:18 <hpaste> neutrino pasted “break stm loop” at http://hpaste.org/80860
04:00:26 <neutrino> here you go guys
04:00:28 <Lethalman> Maybe is not a monoid? thought it was
04:00:33 <neutrino> how does that look?
04:00:48 <`ramses> Maybe is a monoid if what's inside the Maybe is a monoid
04:00:56 <Lethalman> ah
04:01:08 <fmap> Lethalman: `Maybe a' is a Monoid, `Maybe' is an Alternative
04:01:16 <`ramses> instance Monoid a => Monoid (Maybe a) -- Defined in `Data.Monoid'
04:01:18 <Lethalman> > Just (Sum 4) <> Just (Sum 5)
04:01:20 <lambdabot>   Just (Sum {getSum = 9})
04:01:48 <Lethalman> `ramses, fmap, ah now that's more clear thanks
04:02:08 <Lethalman> so <> has the concept of "appending" while <|> has the concept of alternative?
04:02:44 <Lethalman> > Just (Sum 4) <> Nothing
04:02:45 <lambdabot>   Just (Sum {getSum = 4})
04:02:51 <TheRedMoodie> I am back.
04:03:28 * Lethalman still unclear about the difference in the applications of monoids and applicatives, but will grasp the concept on the way of learning hs :)
04:03:36 <TheRedMoodie> What mauke wanted me to emerge fixed the problem, but now i need to fix it on this windows laptop.
04:04:26 <hpaste> “`ramses” pasted “Illegal instance” at http://hpaste.org/80861
04:04:37 <`ramses> ^^ why is that instance illegal?
04:04:54 <`ramses> ghc says "All instance types must be of the form (T a1 ... an)"
04:05:20 <`ramses> but I don't see how I don't satisfy that constraint
04:05:51 <Cale> `ramses: you're missing the T
04:06:14 <TheRedMoodie> I learned about logarithems today in math class :D
04:06:36 <merijn> Lethalman: When you try to use them the difference will be intuitive
04:06:57 <`ramses> Cale: isn't Diff the T ?
04:06:57 <Cale> `ramses: your instance will overlap with every other -- instance selection is done without any consideration of the class constraints on the instances, and only after selecting the instance is the constraint checked
04:07:10 <Cale> Nope
04:07:18 <Cale> T is meant to be a type constructor
04:07:31 <`ramses> so I would have to write an instance for every instance of Integral?
04:07:35 <Cale> yes
04:07:43 <`ramses> that sucks
04:08:00 <Cale> But you don't need a class for this
04:08:04 <Cale> you could just write
04:08:10 <Cale> diff a b = fromIntegral (a-b)
04:08:16 <monoidal> `ramses: you can create a wrapper newtype D a = D a and then an instance Integral a => Diff (D a)
04:08:19 <`ramses> some non-numbers would have to be instances as well..
04:08:29 <Cale> diff :: (Integral a, Num n) => a -> a -> n
04:08:48 <Cale> `ramses: The instance you wrote conflicts with every other instance
04:08:53 <`ramses> I'd also need diff :: Num n => Char -> Char -> n
04:09:03 <Cale> There's no way to prevent types from later becoming instances of Integral
04:09:28 <`ramses> that would require a class right? I basically want to have a class for all types that have some notion of distance bewteen elements
04:09:44 <merijn> `ramses: The point is this: Imagine you write "instance Diff Char", now someone else writes "instance Integral Char", now which implementation should GHC pick?
04:10:02 <`ramses> yeah, I see that problem
04:10:19 <TheRedMoodie> Ahh
04:10:27 <latermuse> is there an easier way to get the last n members of a list than by using:    reverse . take n . reverse $ list
04:10:27 <TheRedMoodie> Running it inside of mingw solved it :D
04:10:28 <`ramses> I was just hoping I could somehow avoid having to write instances for any Num instance I'd like to be able to use
04:10:57 <merijn> `ramses: Another alternative would be "class Integral a => Diff a", but that might force people to be evil
04:10:58 <Cale> `ramses: You can do the newtype tagging thing
04:11:48 <merijn> i.e. only allow Integral's to be Diff's and let someone else sort it out
04:12:08 <fmap> latermuse: no
04:12:34 <Hafydd> > inits [1..10] !! 5
04:12:35 <lambdabot>   [1,2,3,4,5]
04:12:43 <Hafydd> Er...
04:12:49 <Hafydd> > tail [1..10] !! 5
04:12:50 <lambdabot>   7
04:12:53 <Hafydd> > tails [1..10] !! 5
04:12:54 <lambdabot>   [6,7,8,9,10]
04:13:02 <HugoDaniel> hi
04:13:04 <Hafydd> latermuse: ^
04:13:07 <latermuse> fmap: it feels like using (reverse . take n . reverse) is going to be slow algorithmically
04:13:07 <monoidal> > tails [1..10] !! 2
04:13:09 <lambdabot>   [3,4,5,6,7,8,9,10]
04:13:15 <monoidal> Hafydd: that's take 2
04:13:19 <monoidal> * drop 2
04:13:19 <fmap> latermuse: it's O(n)
04:13:28 <Hafydd> Oh... true
04:13:35 <fmap> latermuse: you can't do better, lists are single-linked
04:13:38 <latermuse> fmap: that means, the more in the list, the slower it goes?
04:13:43 <`ramses> ok, will try the newtype, thanks :)
04:13:43 <fmap> yes
04:13:48 <latermuse> got it
04:13:50 <latermuse> thanks :)
04:14:29 <`ramses> merijn: the whole point would be to be able to make any sensible type a Diff...
04:15:25 <`ramses> got it working with the newtype, I can live with that :)
04:16:23 <`ramses> I was actually trying to do this on an exam yesterday and I was really pulling my hear out because I couldn't grasp what I was doing wrong :)
04:19:51 <fmap> latermuse: if you often need to get last n elements consider using Data.Sequence instead
04:29:26 <hpaste> neutrino pasted “commitBuffer: illegal operation (handle is closed) -- how to fix this?” at http://hpaste.org/80862
04:29:50 <neutrino> hey guys, i was wondering if anyone knew what's going on
04:30:09 <neutrino> why is the handle passed to me by withFile closed?
04:30:42 <neutrino> it seemingly actually isn't because i can write to it from within a function, but not from within another function..
04:32:12 <merijn> neutrino: You're letting the file handle escape out of the scope of withFile
04:32:22 <merijn> I think?
04:32:32 <neutrino> i'm writing from another thread, yeah
04:32:43 <neutrino> um, how do i do this better?
04:32:49 <neutrino> just do my own bracketing with finally?
04:33:04 <Saizan> the point of withFile is that it closes the handle when the callback returns
04:33:32 <neutrino> the callback doesn't return before the threads are finished
04:33:32 <merijn> Saizan: Well, it looks like he blocks until the rest terminates, but still...
04:33:38 <neutrino> but i guess the type checker doesn't know that
04:33:41 <merijn> I'm not sure what you're allowed to do exactly
04:33:43 <neutrino> and assumes on the safe side
04:34:00 <Saizan> the typechecker has nothing to do with this
04:36:12 <neutrino> what does?
04:36:42 <Saizan> execution of the function you pass to withFile
04:36:57 <Saizan> in fact "threads" starts empty
04:36:59 * hackagebot network-conduit-tls 0.6.0.4 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-0.6.0.4 (MichaelSnoyman)
04:37:13 <Saizan> and finished too
04:37:29 <Saizan> (different notions of empty though)
04:37:54 <janua> Hello, I have a list of string, which I would like to output to the console. I thought i would just try to do it in main, but i can't quite match what i need to do. I have tried main = map (putStrLn . show), and lots of other variations. Any pointers
04:38:04 <neutrino> i tried making a minimal case where i write to the file from another thread, but that works
04:38:05 <Saizan> so the execution can go through to the end without the forked threads ever running
04:38:27 <Saizan> neutrino: basically you have a synchronization bug here
04:38:30 <kennyd> :t map (putStrLn . show)
04:38:31 <lambdabot> Show a => [a] -> [IO ()]
04:38:46 <hpaste> neutrino pasted “writing from another thread works” at http://hpaste.org/80863
04:38:54 <merijn> janua: You probably want mapM or mapM_
04:38:56 <merijn> :t mapM
04:38:58 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
04:39:00 <merijn> :t mapM_
04:39:01 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
04:39:18 <janua> merijn: AH, I tried liftM
04:39:29 <merijn> janua: Alternatively, sequence would've worked
04:39:29 <janua> But not mapM
04:39:30 <neutrino> Saizan: that's interesting, but i do believe the threads do execute?
04:39:36 <merijn> :t map putStrLn
04:39:36 <neutrino> so i'm not sure that is the issue?
04:39:37 <lambdabot> [String] -> [IO ()]
04:39:37 <janua> merijn: Sequence?
04:39:43 <merijn> :t sequence . map putStrLn
04:39:45 <lambdabot> [String] -> IO [()]
04:39:49 <merijn> :t sequence
04:39:50 <janua> Oh
04:39:50 <lambdabot> Monad m => [m a] -> m [a]
04:39:55 <merijn> :t sequence_
04:39:57 <lambdabot> Monad m => [m a] -> m ()
04:40:07 <janua> I didn't know about sequence either. I will have a look at it, thank you!
04:40:12 <merijn> janua: mapM and mapM_ are really just "sequence . map f"
04:40:25 <bartavelle> is there an already made module that will let me easily convert a mysql query into a source (for conduits) besides the raw mysql C bindings ?
04:40:33 <merijn> janua: FYI, you can find these kinds of things using Hoogle to search for type signatures :)
04:40:34 <neutrino> Saizan: let me fix that quickly
04:40:53 <merijn> @hoogle Monad m => (a -> m b) -> [a] -> m [b]
04:40:53 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:40:53 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:40:53 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
04:41:02 <Saizan> neutrino: my point is that they can execute too late
04:41:32 <neutrino> mhm
04:41:56 <neutrino> seems to work great
04:41:59 <neutrino> thanks a lot, Saizan
04:43:48 <janua> merijn: I see what sequence does now. Which is nice to know about. But i cant seem to get the syntax correct. main = sequence . map putStrLn [...]
04:44:00 <Saizan> neutrino: np
04:44:09 <janua> mapM works perfectly though
04:44:37 <Axman6> sequence . map f xs is (sequence) . (map f xs)
04:44:42 <neutrino> it's funny.. i forgot that "spinning something up" actually requires waiting for it to be spinning.
04:44:42 <janua> Oh
04:44:55 <janua> This works... main = sequence $ (map putStrLn) []
04:44:56 <Axman6> you need a $ before xs if you want to write it like that
04:45:08 <Axman6> that's horrid =)
04:45:19 <Axman6> sequence . map putStrLn $ xs
04:45:21 <janua> Is it!?
04:45:39 <Axman6> (map putStrLn) [] is map putStrLn []
04:45:50 <Axman6> the brackets are completely redundant
04:46:13 <janua> Axman6: I see. I am still coming to terms with $ and .
04:46:40 <Axman6> f . g . h $ x is (f . g . h) x
04:46:41 <Lethalman> don't overuse $, sometimes () are more clear
04:46:45 <neutrino> janua: that can be tough :)
04:46:56 <b_jonas> Lethalman: indeed
04:47:03 <janua> :)
04:47:04 <arbn> Haskellers like squiggles more than parens. It's so you can tell us apart from Lispers. :P
04:47:22 <Lethalman> also don't overuse (), sometimes $ is more clear :P
04:47:35 <marekw2143> when I have function: ith i = last . take i, then why does it return's it'h element of the list?
04:47:41 <janua> Ok one last question. If i use mapM_ i don't get the last line, it gets discarded. How would i achieve this with.. sequence . map putStrLn
04:47:43 <marekw2143> I mean how the list is passed to "take" function?
04:48:07 <Lethalman> marekw2143, ith i xs = last (take i xs)
04:48:18 <Lethalman> it's the same
04:48:25 <marekw2143> I't just syntatcitc sugar?
04:48:29 <melvin> janua what do you mean?  mapM_ is implemented with sequence_ and map
04:48:31 <Lethalman> marekw2143, it's composition
04:48:49 <marekw2143> :type (.)
04:48:58 <Lethalman> :t (.)
04:48:59 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:49:03 <melvin> lanua oh, are you talking about return value?  sequence_ is mapM_ equivalent
04:49:04 <janua> Oh, there is a sequence_
04:49:07 <Lethalman> :t (Prelude..)
04:49:08 <lambdabot> (b -> c) -> (a -> b) -> a -> c
04:49:33 <marekw2143> Lethalman: i understand (.) applied to one arg function f.g x  = f (g x)
04:49:35 <merijn> janua: The issue with your initial code is that function application binds tighter than operators, so "sequence . map putStrLn [..]" is parsed as "sequence . (map putStrLn [..])" which means . is getting a list as righthand value instead of a function
04:49:39 <janua> I don't have sequence_ in scope
04:49:46 <Lethalman> marekw2143, that's it in your example
04:49:53 <Lethalman> it's applied to one argument, the list
04:50:12 <merijn> @hoogle sequence_
04:50:12 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
04:50:12 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
04:50:12 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
04:50:13 <marekw2143> Lethalman: oh, yeah, because "take i" is just a function of one arg, yes?
04:50:20 <janua> !
04:50:21 <Lethalman> :t take 10
04:50:22 <lambdabot> [a] -> [a]
04:50:29 <Lethalman> :t last . take 10
04:50:31 <lambdabot> [b] -> b
04:50:32 <marekw2143> Lethalman: thanks
04:50:33 <Axman6> merijn: do you understand the equivalence between double xs = map (*2) xs and double = map (*2)?
04:50:38 <janua> My bad
04:50:46 <merijn> janua: Should be in prelude, otherwise import Control.Monad
04:50:54 <janua> I do have it in scope. And it all makes sense now. Thank you :)
04:50:59 <merijn> Axman6: I should hope so, so I think you grabbed the wrong name ;)
04:51:10 <Axman6> uh, yeah, that was for marekw2143
04:51:25 <janua> Got to get lunch! First time i have actually scripted in haskell. :)
04:51:27 <marekw2143> Axman6: yes
04:51:31 <Axman6> I'm supposed to be asleep, but my girlfriend's hidden my sleep mask so i can;t sleep
05:15:13 <Lethalman> I get /usr/bin/ld: final link failed: No space left on device even with cabal install pandoc --ghc-options="-optl -Wl,--no-keep-memory" :'-( hints other than buy more ram?
05:15:27 <mauke> buy more disk
05:15:44 <mauke> also, check df -h
05:16:07 <Lethalman> mauke, more disk?
05:16:09 <Lethalman> disk is fine
05:16:12 <typoclass> Lethalman: i think "no space left on device" indicates the disk is full, not the ram
05:16:19 <mauke> Lethalman: apparently not
05:16:23 <Lethalman> device doesn't necessary mean disk
05:16:32 <Lethalman> the device can also be something like tmpfs on ram and be full
05:16:32 <mauke> ramdisk?
05:16:43 <Lethalman> *necessarily
05:24:09 <parcs> why is Control.Exception.finally defined like it is http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/src/Control-Exception-Base.html#finally instead of a `finally` sequel = mask $ do r <- a; _ <- sequel; return r ?
05:24:26 <parcs> er, that should say mask_
05:26:45 <parcs> i guess i don't really understand mask
05:27:00 * hackagebot antigate 0.2.1 - Interface for antigate.com captcha recognition service.  http://hackage.haskell.org/package/antigate-0.2.1 (MikhailKuddah)
05:27:21 <mauke> parcs: your definition would run 'a' with exceptions blocked
05:27:40 <mauke> and it wouldn't run sequel in case of an exception
05:29:15 <parcs> mauke: doesn't mask just mask asynchronous exceptions?
05:29:19 <mauke> yes
05:32:47 <parcs> oh, i get it
05:32:50 <parcs> thanks mauke
05:35:37 <hpaste> sonOfRa pasted “Case Fallthrough” at http://hpaste.org/80864
05:36:00 <sonOfRa> I'm tryingto achieve something like a case fallthrough here. Is that possible, or do i have to list each value independently?
05:36:23 <mauke> is that Haskell?
05:36:30 <sonOfRa> it's a case of
05:36:38 <mauke> in Haskell?
05:36:42 <sonOfRa> yes
05:36:55 <sonOfRa> step is an IO()
05:36:58 <mauke> no, it's not
05:37:05 <mauke> step :: (a, b) -> c
05:37:09 <mauke> for some reason
05:37:23 <sonOfRa> well, it's out of context
05:37:37 <mauke> why does step take a tuple?
05:37:40 <Philonous> sonOfRa:  _ matches everything, so you can use it as a catch-all case
05:37:55 <Lethalman> sonOfRa, lower c first ?
05:38:11 <sonOfRa> Lethalman, that makes sense, thanks
05:38:23 <mauke> step (lab, case toLower c of { 'w' -> exit lab; 'a' -> pos })
05:38:36 <sonOfRa> Philonous, that would only allow for one overall fall through, not for each char
05:39:21 <Lethalman> sonOfRa, or if you want to be more general, x | toLower x == 'w' -> ...; x | toLower x == 'a' -> ...
05:39:51 <mauke> x `elem` "aA"
05:39:54 <sonOfRa> I think I will just toLower it, and then do the valid checks. Thanks
05:40:15 <sonOfRa> Most reasonable choic at this point
05:40:18 <mauke> > case 'W' of (toLower -> 'w') -> "hi"
05:40:21 <lambdabot>   "hi"
05:40:38 <Lethalman> what's that? :S
05:41:19 <Philonous> Lethalman:  view patterns
05:42:47 <Lethalman> Philippa_, the left part of -> is applied against the case expression and matched to the right part?
05:43:07 <frerich> Funky; is that just a nicer syntax for guards? I.e. case 'W' of x | toLower x == 'w' -> "hi"?
05:44:42 <monoidal> freirich: it's much more powerful. for example, case x of (f -> Just y) -> ... computes f x, matches against Just y, and binds y.
05:45:17 <monoidal> frerich: you can also do e.g. case x of (f -> u, g -> v)
05:45:26 <frerich> errrr.... let me digest that.
05:45:36 <Lethalman> the right part is a pattern, awesome
05:46:27 <monoidal> "x" matches pattern "f -> p" if "f x" matches pattern "p"
05:46:33 <frerich> monoidal: Ah I think I get it, in your second example f x and g x would be coomputed and their results would be bound to u and v?
05:47:03 <frerich> hmmm, funky. I should check my programs, maybe this would simplify somet hings.
05:47:24 <monoidal> frerich: no, it's f (fst x) and g (snd x)
05:47:43 <Lethalman> \o/
05:47:51 <monoidal> frerich: like case x of (a,b) -> ... matches a = fst x, b = snd y
05:48:19 <mSSM> How come `read' from Prelude is pure? If I read the String and want to use it as an Int, but the String turns out to be "fooled_you", then the whole program is going to crash.
05:48:19 <frerich> Aaah...
05:48:38 <monoidal> frerich: for example, case x of [f -> Just y, g -> [z]] -> ... matches if x is a two-element list where f of first element is Just y, and g of second element is one-element list [z]
05:52:03 <Lethalman> mSSM, you can use reads
05:52:06 <clahey> mSSM: There do seem to be a lot of unsafe things of that nature.
05:52:15 <clahey> mSSM: But there's usually an alternative to do it right.
05:52:25 <clahey> Rather, safely.
05:52:33 <slack1256> mSSM: purity has to do whether the function only depends of it argument instead of some assumed variable
05:52:37 <clahey> Pure and unpure are different from safe and unsafe, though they're related.
05:52:39 <monoidal> mSSM: Text.Read.readMaybe
05:52:44 <slack1256> that's the common purity here
05:53:15 <clahey> Actually, I'm not sure they're related, but performUnsafeIO suggests that they are.
05:53:31 <clahey> Or whatever the function is called that lets you pretend an IO computation is pure.
05:53:42 <monoidal> purity/impurity, safety/unsafety, totality/partiality are 3 different things
05:54:00 <slack1256> as clahey said
05:54:11 <clahey> monoidal: What's the difference between safety and totality?
05:54:18 <monoidal> total means everywhere defined
05:54:31 <clahey> And safe?
05:55:07 <monoidal> hm, purity is actually very close to safety
05:55:26 <monoidal> by safe, I mean things that are in safe haskell
05:55:27 <erineh_> and then theres safety as in unsafeInterleaveIO
05:55:37 <clahey> So read is partial, not unsafe or impure?
05:55:43 <monoidal> yes
05:55:45 <monoidal> like division
05:56:08 <fmap> > 1 / 0
05:56:09 <lambdabot>   Infinity
05:56:19 <erineh_> haha
05:56:22 <srhb> > 1 `div` 0
05:56:22 <monoidal> > 1 `div` 0
05:56:23 <lambdabot>   *Exception: divide by zero
05:56:24 <lambdabot>   can't find file: L.hs
05:56:56 <srhb> integer division is partial. :P
05:57:15 <fmap> clearly solution is to use doubles everywhere
05:57:25 <erineh_> > (1 % 1) / 0
05:57:26 <lambdabot>   Not in scope: `%'
05:57:26 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
05:57:30 <erineh_> > (1 R.% 1) / 0
05:57:32 <lambdabot>   *Exception: Ratio.%: zero denominator
05:57:40 <Eduard_Munteanu> Um, 1 / 0 = Inf is false however you interpret it.
05:58:04 <erineh_> > let Inf = 1/0 in 1/0 == Inf
05:58:04 <srhb> I interpret it as the limit 1/x as x tends toward zero, clearly.
05:58:05 <lambdabot>   Not in scope: data constructor `Inf'
05:58:05 <lambdabot>  Perhaps you meant one of these: `In' ...
05:58:15 <erineh_> True ;)
05:58:16 <Eduard_Munteanu> srhb: which doesn't exist
05:58:17 <monoidal> > 1/0 == 1/0
05:58:19 <lambdabot>   True
05:58:26 <clahey> srhb: From below or from above?
05:58:33 <erineh_> Infinity exists
05:58:44 <Eduard_Munteanu> Yeah but not a plain limit of that.
05:58:51 <erineh_> NaN exists ;)
05:58:58 <srhb> clahey: Eh, whichever works :P
05:59:06 <fmap> > 1/(-0)
05:59:06 <mikeplus64> > 1/0+1 == 1/0
05:59:08 <lambdabot>   -Infinity
05:59:08 <lambdabot>   can't find file: L.hs
05:59:11 <clahey> srhb: They give different values.
05:59:18 <srhb> Yes.
05:59:20 <mikeplus64> wat
05:59:27 <Eduard_Munteanu> So these numbers are non-Archimedean?
05:59:29 <fmap> mikeplus64: sorry
05:59:34 <erineh_> definitely
05:59:38 <Eduard_Munteanu> 0 = 0+  -0 = 0- ?
05:59:41 <clahey> The double math is just standard IEEE, right?
05:59:43 <erineh_> they dont even distribute ;)
05:59:51 <clahey> > 0 == -0
05:59:53 <lambdabot>   True
06:00:01 <clahey> > 1/0 == 1/(-0)
06:00:02 <lambdabot>   False
06:00:07 <erineh_> > (0/0) == (0/0)
06:00:09 <lambdabot>   False
06:00:22 <clahey> > Infinity == Infinity
06:00:24 <lambdabot>   Not in scope: data constructor `Infinity'Not in scope: data constructor `In...
06:00:36 <mikeplus64> > -0.0 == 0.0
06:00:37 <lambdabot>   True
06:00:38 <Eduard_Munteanu> Depends how you want to compare infinities.
06:00:40 <erineh_> > let Infinity = 1/0
06:00:42 <lambdabot>   not an expression: `let Infinity = 1/0'
06:00:49 <erineh_> @let Infinity = 1/0
06:00:50 <lambdabot>  <local>:24:1: Not in scope: data constructor `Infinity'
06:00:58 <Eduard_Munteanu> > Infinity == Infinity
06:00:59 <lambdabot>   Not in scope: data constructor `Infinity'Not in scope: data constructor `In...
06:01:01 <clahey> > let infinity = 1/0 in infinity == infinity
06:01:02 <lambdabot>   True
06:01:15 <clahey> > 0/0
06:01:17 <lambdabot>   NaN
06:01:18 <Eduard_Munteanu> Wat.
06:01:22 <clahey> > let nan = 0/0 in nan == nan
06:01:24 <lambdabot>   False
06:01:33 <erineh_> *clap clap*
06:01:34 <Eduard_Munteanu> I don't think this is standard IEEE behavior.
06:01:37 <erineh_> it is
06:01:41 <srhb> Believe it.
06:01:52 <Eduard_Munteanu> Inf = Inf just like that is dumb :)
06:01:54 <clahey> Eduard_Munteanu: Pretty sure it is.
06:02:04 <erineh_> more like Inf is dumb
06:02:14 <clahey> > let neg0 = -0 in 1/neg0
06:02:16 <lambdabot>   -Infinity
06:02:20 <Eduard_Munteanu> Not really.
06:02:30 <clahey> > let neg0 = -0, zer = 0 in zer == neg0
06:02:32 <lambdabot>   <hint>:1:14: parse error on input `,'
06:02:33 <mauke> > (===)
06:02:35 <lambdabot>   No instance for (GHC.Show.Show (a0 -> b0 -> GHC.Types.Bool))
06:02:35 <lambdabot>    arising fro...
06:02:40 <clahey> > let (neg0 = -0, zer = 0) in zer == neg0
06:02:41 <lambdabot>   <hint>:1:11: parse error on input `='
06:02:42 <Eduard_Munteanu> let infinity = 1/0 in infinity - infinity
06:02:43 <mauke> clahey: ;
06:02:46 <Lethalman> ;
06:02:47 <clahey> > let (neg0 = -0; zer = 0) in zer == neg0
06:02:49 <Eduard_Munteanu> > let infinity = 1/0 in infinity - infinity
06:02:49 <lambdabot>   <hint>:1:11: parse error on input `='
06:02:50 <erineh_> ieee754 sucks for math purposes, ok for science purposes ;)
06:02:51 <lambdabot>   NaN
06:03:03 <clahey> > let neg0 = -0; zer = 0 in zer == neg0
06:03:03 <Eduard_Munteanu> > let infinity = 1/0 in infinity / infinity
06:03:04 <lambdabot>   True
06:03:05 <lambdabot>   can't find file: L.hs
06:03:08 <clahey> > let neg0 = -0; zer = 0 in zer == neg0
06:03:10 <lambdabot>   True
06:03:13 <Eduard_Munteanu> > let infinity = 1/0 in infinity / infinity
06:03:14 <lambdabot>   NaN
06:03:16 <clahey> > let neg0 = -0; zer = 0 in 1/zer == 1/neg0
06:03:18 <lambdabot>   False
06:03:44 <Eduard_Munteanu> > let infinity = 1/0 in infinity /= infinity
06:03:46 <lambdabot>   False
06:03:57 <erineh_> is == defined using a delta
06:04:11 <clahey> > 0.0000000000000000000000000001 == 0
06:04:13 <lambdabot>   False
06:04:16 <Eduard_Munteanu> That wouldn't be standard IEEE behavior.
06:04:17 <clahey> > 0.0000000000000000000000000000000000000000001 == 0
06:04:19 <lambdabot>   False
06:04:23 <erineh_> ok good
06:04:23 <clahey> > 0.0000000000000000000000000000000000000000000000000000000000000000000000000001 == 0
06:04:25 <lambdabot>   False
06:04:29 <Lethalman> this is something you can do in your ghci guys
06:04:34 <erineh_> its denormal zero
06:04:48 <erineh_> er nvm
06:04:53 <mauke> > 0/0 === "Infinity"
06:04:55 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Bool)
06:04:55 <lambdabot>    arising from a use ...
06:04:58 <erineh_> > 1e-400 == 0
06:04:59 <lambdabot>   True
06:05:03 <Eduard_Munteanu> Which is why you always do stuff like abs (x - x0) < some_epsilon
06:05:04 <erineh_> > 1e-300 == 0
06:05:05 <lambdabot>   False
06:05:19 <erineh_> Eduard_Munteanu: i do not always do that
06:05:22 <Eduard_Munteanu> > 1e-300
06:05:24 <lambdabot>   1.0e-300
06:05:38 <Eduard_Munteanu> > 1e-3000000000000000
06:05:43 <lambdabot>   mueval: ExitFailure 1
06:05:43 <lambdabot>  mueval: Prelude.undefined
06:05:47 <S11001001> If you could add a type parameter to Float, I bet you could add a monad instance and get away with doing whatever you want too.
06:05:55 <mauke> > 0/0 === "Infinity"
06:05:58 <lambdabot>   False
06:06:14 <clahey> :t (===)
06:06:16 <lambdabot> (Eq b, Typeable a, Typeable b) => a -> b -> Bool
06:06:25 <erineh_> === is PHP ==
06:06:37 <mauke> more like PHP ===
06:06:37 <Eduard_Munteanu> :t 1e-300
06:06:38 <lambdabot> Fractional a => a
06:06:40 <clahey> And why did the result change?
06:07:04 <erineh_> > 1e-30000000000000000000000 :: Rational
06:07:09 <lambdabot>   mueval: ExitFailure 1
06:07:09 <lambdabot>  mueval: Prelude.undefined
06:07:27 <mauke> stop trying to construct hueg integers
06:07:42 <Eduard_Munteanu> Is this IEEE-compliant behavior?
06:07:42 <erineh_> hueg integers, interesting
06:07:51 <erineh_> Rational isnt IEEE
06:07:58 <Hafydd> If that was an attempt to construct a huge integer, let alone even an integer, it was a rather miserable one.
06:08:00 <Eduard_Munteanu> I mean Double.
06:08:02 <mauke> Eduard_Munteanu: IEEE doesn't specify lexing in programming languages
06:08:08 <erineh_> Hafydd: ahahaah
06:08:20 <Eduard_Munteanu> mauke: I mean stuff like comparing infinities and such
06:08:25 <erineh_> yes
06:08:26 <mauke> Eduard_Munteanu: that is, yes
06:08:29 <Hafydd> (The denominator would be though, yes)
06:08:32 <mauke> Rational = Ratio Integer
06:09:18 <Eduard_Munteanu> Hm, actually, you can't really define both == and /= to return false on infinities.
06:09:31 <erineh_> you can if you want
06:09:33 <mauke> I can't?
06:09:33 <Eduard_Munteanu> Because you'll trip when you negate the condition anyway.
06:09:35 <TheRedMood> haha
06:09:40 <TheRedMood> I think you can?
06:09:52 <TheRedMood> You just have to want todo it enough.
06:09:57 <Eduard_Munteanu> Well, you can but it still doesn't cover all use cases.
06:09:58 <erineh_> > (0/0) /= (0/0)
06:09:59 <lambdabot>   True
06:10:32 <erineh_> im confused why you object to infinity == infinity
06:10:32 <S11001001> I don't see why haskellers put up with this
06:10:34 <mauke> > 0/0 === 0/0
06:10:36 <lambdabot>   False
06:10:48 <beaky> hello
06:10:53 <srhb> beaky: Hello
06:11:00 <Eduard_Munteanu> beaky: hi
06:11:02 <Hafydd> > (1/0) == (2/0)
06:11:04 <lambdabot>   True
06:11:06 <Eduard_Munteanu> eL_Bart0: ohai there too
06:11:24 <TheRedMood> ...
06:11:28 <TheRedMood> How does that even owrk ?
06:11:32 <erineh_> > 1e-400 == 1e-500
06:11:34 <lambdabot>   True
06:11:37 <apriori_> hey guys.. in a pattern for a function taking a list, is it somehow possible to decompose in like take n elements instead of only one?
06:11:54 <srhb> apriori_: Not generally, no.
06:12:01 <srhb> apriori_: For any finite number, yes.
06:12:17 <Eduard_Munteanu> erineh_: infinities are indeterminate forms, for example inf - inf isn't 0.
06:12:18 <apriori_> srhb: can you give me an example for the finite number case?
06:12:26 <Eduard_Munteanu> It can be any number or infinity.
06:12:30 <srhb> apriori_: Ie. foo (a:b:c:xs) = you can use the first three elements and the tail, here
06:12:32 <erineh_> > (1/0) - (1/0)
06:12:33 <lambdabot>   NaN
06:12:40 <erineh_> Eduard_Munteanu: in fact it can be no number ;)
06:12:48 <apriori_> srhb: ah, ok.. just tried [x, y, z]:xs.. and that failed of course
06:12:51 <apriori_> srhb: thanks
06:12:57 <srhb> apriori_: It doesn't fail, but xs is a list of lists
06:13:03 <erineh_> Eduard_Munteanu: and as i demonstrated, you have the same issue with zero itself
06:13:07 <monoidal> apriori_: that means a list where the first element is the list [x,y,z]
06:13:38 <erineh_> > let (a:b:c:d:e:xs) = [1,2,3,4,5] in b+d
06:13:40 <lambdabot>   6
06:13:42 <Eduard_Munteanu> erineh_: um, how so?
06:13:56 <Hermit> apriori_: [x,y,z]  ==  (x:y:z:[])
06:13:58 <apriori_> monoidal: ok, yeah..
06:14:09 <erineh_> Eduard_Munteanu: one may object to comparing zero as equal when 'obviously' 1e-400 and 1e-500 are not equal
06:14:19 <apriori_> Hermit: ok, thaks :)
06:14:23 <apriori_> *thanks
06:14:55 <erineh_> adding two zeros always gives zero even if the computation that arrived at zero didnt result in zero in another number system
06:15:10 <Eduard_Munteanu> erineh_: you can compare for equality fine up to the precision of your FP numbers.
06:15:12 <erineh_> infinity acts the same way
06:15:55 <erineh_> so zero can be considered an indeterminate form
06:16:17 <`ramses> erineh_: zero is a number, infinity is not
06:16:29 <quicksilver> Eduard_Munteanu: there is precisely the same issue at both ends; zero is to very small numbers exactly as infinity is to large numbers.
06:16:36 <erineh_> which is ridiculous of course, because zeros, infinities, and NaN are all very well defined characters in this system
06:16:36 <quicksilver> `ramses: that's a very narrow view.
06:16:42 <Eduard_Munteanu> erineh_: well, then any number is an indeterminate form.
06:16:56 <erineh_> yeah so thats silly
06:16:56 <quicksilver> there are many possible meanings of 'number' and many number systems
06:17:07 <`ramses> quicksilver: how so? infinity is not an element of R or C, iirc
06:17:12 <quicksilver> yes.
06:17:17 <`ramses> it's a limit within those sets
06:17:19 <quicksilver> those are two number systems
06:17:20 <erineh_> ieee floating point isnt R
06:17:26 <quicksilver> there are other number systems available
06:17:34 <quicksilver> and as erineh_ says, floating point is not R
06:17:37 <Eduard_Munteanu> TBH, I'd be happy with forbidding equality comparison altogether :)
06:17:52 <quicksilver> IEEE floating point is, objectively, a rubbish number system
06:17:53 <erineh_> i think a lot of haskell people agree ;)
06:17:56 <quicksilver> but it's the one we have :P
06:18:00 <quicksilver> (one of the ones we have)
06:18:01 <`ramses> no, I didn't follow the whole discussion, I had the expression we were talking about math numbers, not ieee
06:18:43 <erineh_> ieee754 is the modern version of egyptian reciprocals xD
06:18:44 <`ramses> s/expression/impression
06:18:52 <osfameron> are there better systems than IEEE floating point that could realistically be used in Haskell instead, in the near future?
06:18:54 <Hafydd> http://en.wikipedia.org/wiki/Extended_real_number_line
06:19:11 <quicksilver> osfameron: there are better ones you can use today - which are much much slower.
06:19:24 <quicksilver> osfameron: it doesn't seem likely there will better fast ones.
06:19:33 <quicksilver> hardware support is all wrapped up in IEEE-ish systems.
06:19:49 <quicksilver> there are some good reasons for that and some bad ones and some historical ones.
06:19:56 <osfameron> quicksilver: ah, that makes sense.
06:20:05 <quicksilver> something you can use today which is not *too* slow, is Integer
06:20:09 <quicksilver> (which you can then scale in some way)
06:20:22 <osfameron> it's probably better that we have a well known, well optimized number system, even if it has deficiencies...
06:20:27 <erineh_> > 3 * 4.12 :: Pico
06:20:29 <lambdabot>   12.360000000000
06:20:52 <osfameron> but you can mix in other number representations as needed (e.g. for financial, engineering, etc. uses) quite easily?
06:20:53 <erineh_> osfameron: popularity inversely proportional to quality ;)
06:20:55 <Eduard_Munteanu> Integer is still a lot slower than FP at certain ranges of interest.
06:21:04 <quicksilver> much much slower, yes, Eduard_Munteanu
06:21:05 <erineh_> spread out the shit
06:21:37 <osfameron> oh. why is integer slower than floating point?
06:21:43 <erineh_> not integer
06:21:44 <erineh_> Integer
06:21:50 <osfameron> ah
06:21:58 <`ramses> osfameron: no hardware support?
06:22:13 * osfameron finds working with numbers in haskell really annoying because of this stuff...
06:22:20 <clahey> If the numbers are big enough be slower even without hardware support, I would think.
06:22:31 <erineh_> i daresay haskell isnt really for 'numerics' anyway
06:22:33 <clahey> add: "it would be"
06:22:55 <quicksilver> I think haskell has reasonable numerics support
06:23:25 <clahey> I think working with numbers in haskell is great because of all this stuff.
06:23:31 <quicksilver> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:numeric
06:23:34 <quicksilver> and
06:23:40 <quicksilver> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:numerical
06:23:55 <clahey> But then I usually use C++ where you get Int and Double and if you want anything else, it's a real pain.
06:23:58 <erineh_> yeah i greatly appreciate the fact that im not stuck with Doubles
06:24:10 <erineh_> and that they dont magically convert between two systems
06:24:11 <clahey> In haskell, you get those and you can have other stuff pretty easily if you want.
06:24:20 <clahey> erineh_: Yep!
06:24:25 * osfameron is coming from Perl where numbers just magically change size as appropriate
06:24:32 <Eduard_Munteanu> Though Double give pretty good "bang for the buck".
06:24:47 <erineh_> they dont change size, they convert from int to double
06:24:51 <erineh_> then fail
06:25:31 <erineh_> sometimes silently
06:25:31 <osfameron> oh, I'm not talking about big numbers
06:25:32 <clahey> erineh_: They don't switch to Integer?
06:25:39 <erineh_> not in perl
06:25:42 <osfameron> I mean haskell is annoying for doing stuff with *numbers* in general
06:26:01 <clahey> osfameron: Because you have to know whether you want floating point or not?
06:26:12 <erineh_> i think its better to know what you want, and then get it
06:26:17 <erineh_> rather than not know what you want, then be fucked
06:26:44 <Eduard_Munteanu> All the "fromInteger" stuff might seem excessive to someone accustomed to say, Matlab.
06:26:47 <beaky> how do I get a heterogeneous list in haskell
06:26:56 <Eduard_Munteanu> @google hlist
06:26:58 <lambdabot> http://hackage.haskell.org/package/HList
06:26:58 <lambdabot> Title: HackageDB: HList-0.2.3
06:27:01 <erineh_> meh
06:27:12 <osfameron> working out whetehr you need fromInt or fromInteger or fromIntegral stuff is annoying
06:27:13 <Eduard_Munteanu> beaky: ^ but you probably don't want a heterogenous list anyway
06:27:13 <erineh_> beaky: you probably dont want one, but you can use Dynamic
06:27:18 <clahey> The integer casting stuff is a little annoying.
06:27:28 <erineh_> osfameron: just use fromIntegral everywhere
06:27:33 <Eduard_Munteanu> beaky: if you want to implement it yourself, look at existentials, that's one way.
06:27:33 <erineh_> clahey: its not a cast
06:27:38 <erineh_> its a conversion
06:27:38 <clahey> I think it's a microcosm of the differences between languages.
06:27:39 <beaky> ah
06:27:52 <clahey> erineh_: It's a conversion in C too.
06:27:56 <erineh_> no its not
06:28:06 <erineh_> a cast in C is different from an auto conversion in C
06:28:27 <erineh_> cast is a type system reinterpretation
06:28:34 <erineh_> same data
06:28:48 <t7> whats the easiest (ByteString -> Text) ? some kinda decode utf8 ?
06:28:56 <clahey> But if I write int x = (int) 5.7 it converts the value.
06:29:08 <erineh_> you dont need the (int)
06:29:14 <clahey> Casting a pointer does a type system reinterpretation.
06:29:25 <Eduard_Munteanu> erineh_: I don't think so... contrast with pointer reinterpretation
06:29:31 <erineh_> int x = 5.7 does the conversion adding (int) is redundant
06:29:42 <erineh_> Eduard_Munteanu: it doesnt convert anything
06:29:50 <clahey> erineh_: In C, casting number types does conversions.
06:30:03 <clahey> I think it's an argument over semantics anyway.
06:30:05 <Eduard_Munteanu> e.g. int a = 10; float *b = (float *) &a
06:30:19 <osfameron> I think what annoys me is that there's no (Integer i, Float f) => i / i -> f
06:30:21 <erineh_> thats undefined behavior
06:30:41 <clahey> Anyway, I have to go.
06:30:43 <erineh_> clahey: well obviously its semantics :)
06:30:53 <Eduard_Munteanu> erineh_: well, you made it sound like unsafeCoerce
06:31:02 <erineh_> it is
06:31:13 <Eduard_Munteanu> The last one? Yeah.
06:31:20 <Eduard_Munteanu> But the cast isn't.
06:31:31 <erineh_> the cast is, the rest of it is nonsense
06:31:33 <clahey> Whereas the interesting discussion, IMO, is the difference in attitudes toward run time bugs and compile time errors.
06:32:17 <clahey> osfameron: What about (\x y -> fromIntegral x / fromIntegral y)  Doesn't that do what you want?
06:32:17 <Eduard_Munteanu> Um, (int) 1.2  is nothing like unsafeCoerce 1.2 :: Int
06:32:23 <erineh_> ...
06:32:33 <erineh_> int x = 1.2 has nothing to do with cast, true
06:32:54 <erineh_> throwing (int) in there does not 'cause' a conversion
06:32:55 <clahey> erineh_: I will look up the definitions of the word cast in the context of the C standard when I get back, but I have to run.
06:33:26 <clahey> erineh_: I would disagree that the (int) isn't redundant so much as it is inserted automatically if it's not there.
06:33:26 <Eduard_Munteanu> erineh_: it does in some cases... e.g.   2 / ((int) 1.2)
06:33:36 <erineh_> clahey: untrue
06:33:51 <clahey> Yeah, maybe.
06:33:55 <quicksilver> osfameron: not exactly hard to write one if you do that all the time ;)
06:34:01 <clahey> Maybe it's the = doing something different.
06:34:23 <quicksilver> osfameron: I generally find the 5 minutes it makes me thinking about "hmm? did I really want integers here or what did I want?" is time well spent.
06:34:37 <clahey> But I think Eduard_Munteanu has a great point.
06:34:54 <erineh_>  / may do auto conversion
06:35:13 <hpaste> pauser pasted “title” at http://hpaste.org/80869
06:35:14 <erineh_> obviously you can use a cast to decide which one
06:35:22 <quicksilver> I think the difference between coercion / conversing / casting is a matter of technical definition and the languages are not entirely consistent in how they use the words.
06:35:44 <quicksilver> it's a silly argument to just be arguing about which words the language standard(s) use.
06:35:56 <erineh_> it annoys me to use cast to mean conversion
06:36:03 <hpaste> pauser annotated “title” with “title (annotation)” at http://hpaste.org/80869#a80870
06:36:04 <erineh_> which is really popular but whatever
06:36:53 <cl_away> What does    4 / (static_cast<int>(2.2))   give in C++?
06:36:55 <Eduard_Munteanu> Non-conversions sound like undefined behavior, at least in a sane language and between incompatible types.
06:37:08 <quicksilver> erineh_: not least by the C++ language defintion
06:37:10 <erineh_> c++ is another story
06:37:18 <quicksilver> erineh_: which has for different operations which are all called 'cast'
06:37:22 <quicksilver> four.
06:37:29 <Eduard_Munteanu> I'm not sure there's anything sensible inbetween unsafeCoerce and a conversion.
06:37:38 <erineh_> the progenator of generations of evil and stupidity
06:37:38 <hpaste> pauser annotated “title” with “title (annotation) (annotation)” at http://hpaste.org/80869#a80871
06:38:11 <pauser> hello, im writing a function like in here but it does not seem to work. http://hpaste.org/80869 . the error is in there. do you maybe have any idea why its not working ?
06:39:12 <quicksilver> pauser: [foo c1]
06:39:25 <quicksilver> pauser: that's a 1-element list containing a Bool.
06:39:34 <quicksilver> pauser: (because foo is a function which takes "a"s to Bools)
06:40:12 <quicksilver> I have a feeling I know what it should be, from the type, but I also suspect this might be homework and it might be good for you to follow what I'm saying first.
06:40:51 <pauser> actually i just want to learn for the exam
06:40:58 <erineh_> pauser: use the interpreter to evaluate subexpressions until it gives you a type that you dont agree with
06:41:27 <erineh_> then fix the code or fix yourself ;)
06:41:49 <`ramses> pauser: then it will certainly be better to find it yourself with some help from people here :)
06:42:11 <erineh_> `ramses: or use irc during the exam ;)
06:42:26 <pauser> haha
06:42:38 <osfameron> cl_away, quicksilver: yeah, that incantation is what I eventually came up with last time.  Took me about an hour... (only a minute now.  It still seems counterintuitive and fiddly though)
06:43:36 <`ramses> erineh_: I assume the guys organising the exam will probably have thought about the lack of objectivity when students have internet access :)
06:43:49 <erineh_> honor system
06:43:56 <pauser> well how do i say that a should be a Bool
06:43:59 <erineh_> to deny internet is without honor
06:44:16 <pauser> tfilter :: (it is something here) =>
06:44:22 <`ramses> pauser: that would imply you want your function to return a list of Bools?
06:44:39 <quicksilver> osfameron: I think the only counter-intuitive part is the precise name 'fromIntegral'.
06:44:56 <quicksilver> osfameron: the notion that you'd call some function to convert an Int to its corresponding Double seems entirely reasonable.
06:45:03 <quicksilver> osfameron: and if you were just stuck for the name, why not ask? :)
06:45:06 <pauser> aha i should return somewhere a true or false
06:45:07 <pauser> ?
06:45:11 <`ramses> erineh_: heh, intelligence is defined by one's skill in using search engines then :)
06:45:25 <osfameron> quicksilver: it's odd that you can't divide an integer by another integer, like you do all the time in maths, real life, @other_programming_languages
06:45:30 <quicksilver> pauser: I don't think you *want* a to be a bool.
06:45:31 <`ramses> pauser: what is the purpose of the function foo?
06:45:32 <erineh_> `ramses: once you get out of school, you will find that is the case lol
06:45:47 <quicksilver> > 12 `div` 3
06:45:48 <lambdabot>   4
06:45:49 <quicksilver> osfameron: ^^
06:46:05 <pauser> oh im stupid
06:46:22 <quicksilver> pauser: you are returning a list of "a"s, you have one "a" (that's c1) so you have a natural way to decide if you want to incude c1 in the output list or not.
06:46:23 <`ramses> erineh_: I'm only for 50% still in school, and I know what you mean, but I wouldn't have gained that skill without being forced to train other skills as well
06:46:23 <merijn> pauser: That's the sensation of learning ;)
06:46:24 <osfameron> quicksilver: partly because I'd found fromInt, and was using that (except the other thing I was dividing wasn't an Int, and GRRRRR)
06:46:27 <erineh_> i think its odd that theres a period of time in computer programming where you divide totally different from in school (non integer division)
06:46:28 <quicksilver> the clue is in the name 'cfilter'
06:46:36 <osfameron> quicksilver: yeah, but dividing ints and getting float result
06:46:56 <quicksilver> osfameron: have you tried dividing two ints in C?
06:47:07 <merijn> quicksilver++
06:47:09 <erineh_> dividing integers expecting to get ieee floating point is frightening ;)
06:47:27 <osfameron> quicksilver: no
06:47:27 <erineh_> > divMod 9 4
06:47:28 <lambdabot>   (2,1)
06:47:37 <erineh_> thats how we did it in school
06:47:39 <quicksilver> osfameron: you get integer division, not a floating point.
06:47:56 <quicksilver> osfameron: the symbol is /, but the operaton is `div` as above.
06:47:56 <johnju> I'm writing some relatively large list comprehensions, but I can't find a nice way to format them on multiple lines. Is there any idiom or good examples for this? (yes, I've considered factoring it out)
06:47:58 <`ramses> quicksilver: was that meant for me? I know what his function should do, I was wondering if he knew explicitely what that function ought to do
06:48:00 <osfameron> quicksilver: ok, but Haskell, unlike C, is a high-level language
06:48:13 <quicksilver> osfameron: this isn't about high versus low.
06:48:16 <erineh_> johnju: maybe you want to rewrite it as a list monad
06:48:23 <erineh_> with do notation
06:48:24 <quicksilver> it's about static versus dynamic types.
06:48:29 <quicksilver> haskell, like C, has static types.
06:48:51 <johnju> erineh_: that's a good idea thanks
06:49:11 <`ramses> johnju: I find do notation a lot better and neater then list comprehensions
06:49:29 <hpaste> pauser annotated “title” with “title (annotation) (annotation) (annotation)” at http://hpaste.org/80869#a80873
06:49:31 <osfameron> sure.  but why isn't the type of (/) something like (Number n, Fractional f) => n -> n -> f ?
06:49:51 <pauser> whats wrong now ?
06:50:10 <quicksilver> osfameron: just a tendency to define the uniformly typed operators first and give them the simpler names.
06:50:18 <johnju> `ramses: have you seen scala? you have to write your do notation as a list comprehension, which they call for, so any operation in a monad looks like a for loop!
06:50:24 <flux> osfameron, I would be surprised if it weren't more annoying than the current behavior
06:50:26 <quicksilver> osfameron: obviously the operation you suggest can be defined, more or less.
06:50:31 <`ramses> pauser: which one is line 40 in the original?
06:50:34 <osfameron> quicksilver: "uniformly typed?"  as in a-> a -> a ?
06:50:45 <`ramses> johnju: yeah, I hate that
06:50:45 <pauser> 40:	tfilter foo Leer = []
06:51:00 <quicksilver> osfameron: yes, like that
06:51:19 <johnju> erineh_: how do I do the guard part of a list comprehension though?
06:51:25 <covi> Does the pcap package have docs? http://hackage.haskell.org/package/pcap
06:51:38 <quicksilver> johnju: guard (the whole word)
06:51:41 <Lethalman> :t guard
06:51:43 <lambdabot> MonadPlus m => Bool -> m ()
06:51:55 <quicksilver> do x <- [1,2,3]; guard x > 1; return x
06:52:05 <quicksilver> > do x <- [1,2,3]; guard (x > 1); return x
06:52:06 <lambdabot>   [2,3]
06:52:23 <`ramses> is pauser gone?
06:52:45 <osfameron> quicksilver: Bah.  I guess when you know some rules for working with numbers, it makes more sense.  It still feels cumbersome and surprising to me.
06:52:45 <johnju> quicksilver: this is genius! thanks
06:53:34 <`ramses> johnju: once I learned that, I never wrote a single list comprehension again :)
06:53:39 <johnju> osfameron: the C way of doing it is confusing in different ways - how often do you put a million casts into a c program to stop it choosing the wrong format for intermediate values?
06:53:48 <frerich> I currently use foldM to execute a list of IO actions (which download a HTML page each and extract all links), passing a bit of state (the set of seen links) along. I'd now like to parallelize this. Somebody suggested the 'async' package for that, which looks interesting - but I wonder whether there are better ways to do this? In particular, async doesn't seem to solve the "synchronizing on shared state" thing.
06:54:35 <erineh_> frerich: if youre folding, then you cant parallize it because your state needs to be updated in order
06:55:24 <frerich> erineh: Yeah, but I guess I could factor out smoe stuff which can be done in parallel: fetching a bunch of links and parsing them.
06:55:36 <erineh_> yeah so maybe foldM is not right
06:55:46 <frerich> Hm
06:55:47 <osfameron> johnju: yeah, I guess I'd expect C to be annoying...
06:55:52 <quicksilver> johnju: never, osfameron doesn't use C.
06:56:11 <quicksilver> osfameron: it's quite different from some languages. It's not as different from *all* languages as you were making out.
06:56:21 <quicksilver> osfameron: it's certainly something to get used to.
06:56:37 <quicksilver> osfameron: if only Haskell had a really helpful IRC channel and mailing list to get people over humps like this...
06:56:46 <merijn> frerich: forkIO + STM?
06:56:50 <frerich> erineh: I guess the only part which needs to be synchronized is the 'merge all fetched links from multiple pages, figure out which of them we didn't visit yet, repeat' part.
06:57:09 <erineh_> simpler well defined rules are nicer because you end up telling the computer what you want rather than the computer telling you what it wants
06:57:29 <merijn> frerich: Keep the state of which links have been visisted in an STM variable, have workers update that as they go
06:57:35 <frerich> merijn: Ah forkIO, I remember that now... let me look at that.
06:58:05 <merijn> frerich: forkIO just spawns an IO action in a separate thread so they run concurrently, then you can use STM to coordinate the sharing of information
06:58:08 <erineh_> frerich: yeah, i dont think thats a synch step. no reason to force the program to be on one page at a time
06:58:42 <frerich> merijn: Is there some practical limit to the number of threads I can fork with forkIO?
06:59:28 <frerich> Like, what if I fetch a page with, say, 65536 links - I suppose it wouldn't be very wise to have all of them get handled by a separate thread (even if it would be a green thread?).
07:01:27 <frerich> merijn: Hm, maybe an MVar would already be sufficient for my needs.
07:01:57 <quicksilver> I don't think 65,000 threads will actually be a problem
07:02:42 <quicksilver> but it might not feel the most elegant design
07:03:03 <frerich> quicksilver: I'd very much appreciate suggestions for how to improve :-)
07:06:52 * Lethalman retries cabal install pandoc by setting $TMP :S
07:08:54 <quicksilver> frerich: well the natural thing to do (to me) is to store the URLs to be fetched in a Chan
07:09:15 <quicksilver> frerich: and fork a number of "worker" threads who repeat: take one from chan; process link;
07:09:29 <quicksilver> frerich: and you can experiment/configure the optimum number of workers. Perhaps 100 or 200.
07:10:22 <Eduard_Munteanu> I guess you want the workers to push/queue more stuff to the Chan.
07:23:01 <johnju> Is there a monad function to drop the return value? I've run sequence to run a list of actions, but I don't care about the return value, so i need to change it to be (), what can I do?
07:23:41 <johnju> I can    do { sequence ...; return () } but that feels very verbose and like there must be a function for it, hoogle doesn't give any answers
07:23:41 <Eduard_Munteanu> :t void
07:23:42 <lambdabot> Functor f => f a -> f ()
07:23:48 <xnyhps> :t sequence_
07:23:49 <lambdabot> Monad m => [m a] -> m ()
07:23:50 <Eduard_Munteanu> johnju: ^^
07:24:25 <HugoDaniel> are the definitions in a where strictly evaluated ?
07:24:26 <Eduard_Munteanu> Yeah, sequence_ is better in this particular case.
07:24:42 <johnju> Eduard_Munteanu: thanks, you know I hoogled for that signature, but because it underlines the links, i didn't see the difference between sequence and sequence_!
07:24:45 <Eduard_Munteanu> HugoDaniel: not particularly, no
07:27:06 <HugoDaniel> thanks Eduard_Munteanu
07:27:10 <HugoDaniel> but let is, right ?
07:27:23 <Eduard_Munteanu> HugoDaniel: let isn't either
07:28:28 <Eduard_Munteanu> HugoDaniel: the only difference is 'let' is an expression and 'where' binds to the whole definition.
07:29:05 <quchen_> Eduard_Munteanu: What do you mean by "binds to the whole definition"?
07:29:09 <Eduard_Munteanu> Which might affect stuff like sharing.
07:29:18 <quchen_> I always saw where as a postfix let
07:29:25 <HugoDaniel> oh hmm
07:29:35 <HugoDaniel> i wish i could clearly understand the diff. between them
07:30:08 <Eduard_Munteanu> quchen_: in "f = foo where foo = ...", the where is part of the whole f = ... thing.
07:30:57 <Eduard_Munteanu> HugoDaniel, quchen_: http://www.haskell.org/haskellwiki/Let_vs._Where
07:32:14 <quicksilver> I wouldn't say where binds to "the whole" definition.
07:32:30 <quicksilver> in a typical complex piece of haskell there may be several expressions and several definitions.
07:32:35 <Eduard_Munteanu> Right, just to that particular clause(?) I guess.
07:32:35 <quicksilver> (nested inside each other)
07:32:49 <quicksilver> I would just say that let *is* an expression, and where *modifies* a definition.
07:33:13 <quicksilver> what's interesting is that the notion of definition that where modifies can be several guards.
07:33:16 <quicksilver> that's useful sometimes.
07:33:34 <quicksilver> (and the names that the where introduces are accessible in the guards themselves, too)
07:33:48 <Sculptor> hello o/
07:34:01 <johnju> The latest docs online have broken links - go to http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:IO and click on source and it's 404 - can anyone here deal with that or is it a bug report?
07:34:08 <frerich> quicksilver: having a thread pool which processes a queue would be what I would've done in, say, C++ as well. I just didn't know whether this was plausible and/or convenient in Haskell :)
07:34:17 <`ramses> where is in scope for the preceding _equation_ but not necessarily the whole definition, iirc. If you have multiple equations for a function, one where clause cannot be used for all of them
07:34:19 <frerich> quicksilver: but thanks for mentioning 'Chan', that's something else to hoogle for
07:34:35 <quicksilver> `ramses: yes, you're quite rigt.
07:34:38 <erineh> uhg, i am having such a timezone nightmare
07:34:43 <quicksilver> depending what you think 'definition' means.
07:34:53 <quicksilver> it is indeed only a single equation.
07:35:31 <`ramses> quicksilver: yeah, I interpreted definition as meaning the whole definition of the function, including all equations
07:36:32 * quicksilver nods
07:36:34 <bxc> erineh: discovering that timezones are more complicated than you initially thought?
07:38:31 <`ramses> erineh: in code or in reality? :)
07:39:25 <frerich> quicksilver: Those 'worker threads' you mentioned, would those be 'lightweight threads' as given by forkIO or something else?
07:39:36 <quicksilver> they'd be forkIO threads.
07:39:45 <quicksilver> that's the only kind of thread there is.
07:39:47 <quicksilver> (well, mostly)
07:39:55 <frerich> I thought I saw forkOS or so...
07:40:04 <quicksilver> if someone just says thread, they mean forkIO threads.
07:40:11 <frerich> Ok.
07:40:12 <quicksilver> forkOS threads are forkIO threads.
07:40:19 <quicksilver> they're just a special kind of forkIO threads
07:40:28 <quicksilver> they're bound to a single OS thread.
07:40:29 <quicksilver> don't use them.
07:40:53 <frerich> Ok.
07:41:10 <frerich> Hm, and a Chan can be thought of to be a thread-safe double-ended queue?
07:42:45 <quchen_> freiksenet: Not double-ended. Chans are FIFO.
07:43:27 <frerich> Err yeah sorry, I meant to imply a double-ended queue where one end is used for writing and the other end is used for reading.
07:43:36 <frerich> Like a pipe
07:43:44 <quchen_> That's a queue.
07:43:55 <quicksilver> yes, a threadsafe queue.
07:43:56 <quchen_> A double ended queue can be read/written to from both sides.
07:44:02 <quicksilver> multiple readers and multiple writers
07:44:05 <quicksilver> (if you want them)
07:44:12 <quicksilver> readers block if it's empty
07:44:17 <quicksilver> writers never block
07:44:43 <quchen_> Yep
07:45:03 <frerich> Hm I see. In that case I guess I could have a Chan of URIs to process, the threads consume that, and I'd need to have a Set of URIs in an MVar to be able to tell which of the links I fetched are unseen (and those which are unseen are written to the chan)
07:46:01 <quchen_> Hm? Sounds like there's a circle in there.
07:46:41 <quchen_> You fetch URIs from the queue and consume them (which makes them visited), and then you add the unseen ones to the queue.
07:47:19 <frerich> Yes but in order to determine the unseen ones I need to maintain a separate data structure (say, a Set) in an atomic way, no?
07:47:42 <Eduard_Munteanu> frerich: this is pretty much a breadth-first search
07:48:08 <frerich> Eduard_Muntenau: Yes, well, right now it is (in a single thread) :)
07:48:33 <quchen_> You have a list of URIs to see. Threads get these URIs using a Chan, look at them, and send the results to some central worker (presumably using another Chan).
07:48:53 <quchen_> I don't understand why you would need another structure to save which ones you've seen.
07:49:31 <frerich> quchen_: I was thinking that I need it in order to be able to tell which of the links I fetched from each of the HTML pages should be written to the Chan again
07:49:46 <Eduard_Munteanu> Obviously this isn't always a tree.
07:50:07 <frerich> Yes, in fact - it usually isn't.
07:50:47 <Eduard_Munteanu> So you have to cope with cycles, at least.
07:51:19 <quchen_> frerich: Oooh, you have a list of URLs and you only want to process the ones that you haven't already seen before (e.g. in a previous run). Then an MVar is the way to go. (Maybe a TVar?)
07:52:18 <frerich> quchen_: Yes, it's like a web crawler - and in order to avoid running in circles I need to keep track of the seen URLs
07:52:49 <quchen_> Then use TVar (Set Uri).
07:53:37 <frerich> Hm I was envisioning MVar (since that's what http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html mentions)
07:54:37 <beaky> what is the difference between a monad and an ordinary function?
07:55:02 <mauke> a function is a value. a monad is a type
07:55:24 <quchen_> frerich: An MVar should do the trick here I guess (after some thinking about worst cases)
07:55:47 <beaky> ah
07:55:58 <mauke> e.g. Maybe is a monad
07:56:02 <beaky> > [0, (-1)..(-100)] >>= show
07:56:03 <lambdabot>   "0-1-2-3-4-5-6-7-8-9-10-11-12-13-14-15-16-17-18-19-20-21-22-23-24-25-26-27-...
07:56:16 <beaky> so lists are monads?
07:56:21 <mauke> no, list is a monad
07:56:27 <beaky> oh
07:56:27 <mauke> specifically, the [] type
07:56:34 <Eduard_Munteanu> :k []
07:56:35 <lambdabot> * -> *
07:57:03 <beaky> lists are functions from any set to any set?
07:57:06 <Eduard_Munteanu> Any monad is * -> *, anything else doesn't really make sense.
07:57:36 <Eduard_Munteanu> beaky: no
07:57:38 <`ramses> beaky: no, the list constructor takes a type to a type
07:57:43 <beaky> ah
07:57:54 <`ramses> just like eg Maybe does
07:57:57 <quchen_> The only issue I can come up with is two threads get the URL set when they both have the same URL. They both process the URL, and both add the "visited" flag back to the MVar. However, nothing breaks here.
07:58:05 <Eduard_Munteanu> beaky: [] maps types to the type of lists containing values of that particular type, if it makes sense
07:58:16 <`ramses> beaky: [] is a type constructor, [Integer] is a type
07:58:24 <beaky> ah
07:59:19 <quicksilver> quchen_: you can avoid that if you choose to. If you use take/put semantics on the MVar
07:59:33 <quicksilver> then the first thread takes the MVar, adds its URL to visited
07:59:42 <quicksilver> the second thread has to wait until its put back
07:59:51 <quicksilver> and thus the second thread will see it as visited and move on.
08:00:09 <quchen_> True, with only one MVar it locks
08:00:11 <quicksilver> (this involved setting things to visited before you've actually done the work, of course)
08:00:28 <`ramses> beaky: I think lyah explains monads pretty well. Start in the chapter about functors though
08:00:32 <quchen_> My program had a somewhat bad concept. (Take first, process URL, add afterwards. Better is your version: Take/add first, process.)
08:02:48 <frerich> Fun, looking forward to tonight to give this a try. :)
08:03:39 <frerich> I wonder whether the number of worker threads to use somehow correlates with the number of parallel HTTP connections allowed or the like.
08:04:34 <beaky> ah
08:04:50 <beaky> I can't grasp the notion of functors :(
08:05:11 <`ramses> beaky: then don't jump to monads, cause they are fancy functors
08:05:14 <beaky> ah
08:05:27 <mauke> a functor is a container that supports 'map'
08:05:38 <`ramses> what do you not understand about functors?
08:05:49 <beaky> so functors are just containers?
08:06:01 <elliott> not really
08:06:02 <`ramses> "... that support map"
08:06:18 <hpaste> quchen pasted “isMember with insert side effect” at http://hpaste.org/80876
08:06:25 <quchen_> frerich: ^
08:06:30 <`ramses> they don't have to be actual containers, but containers are the most obvious functors
08:06:30 <quchen_> Something like that.
08:07:44 <`ramses> beaky: do you understand the map function for lists well?
08:08:52 <beaky> yes
08:09:09 <beaky> @src map
08:09:09 <lambdabot> map _ []     = []
08:09:09 <lambdabot> map f (x:xs) = f x : map f xs
08:09:21 <`ramses> :t map -- more relevant
08:09:22 <lambdabot> (a -> b) -> [a] -> [b]
08:09:26 <mauke> :t fmap
08:09:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:09:44 <beaky> ah
08:09:50 <mauke> > fmap (* 2) (Just 3)
08:09:51 <lambdabot>   Just 6
08:09:57 <mauke> > fmap (* 2) [4, 5]
08:09:58 <beaky> so functors contain a type?
08:09:59 <lambdabot>   [8,10]
08:10:13 <`ramses> they are type constructors
08:10:16 <tac> @type fmap (* 2) (* 2)
08:10:18 <lambdabot> Num b => b -> b
08:10:24 <tac> > fmap (* 2) (* 2) 1
08:10:25 <lambdabot>   4
08:10:28 <tac> o_O
08:10:28 <`ramses> their values don't necessarily *contain* a type
08:10:48 <mauke> tac: f = ((->) e)
08:11:05 <beaky> ah
08:11:07 <`ramses> tac: I would leave out that instance for a while ;)
08:11:14 <tac> mauke: I know. I just.... typeclasses.....
08:11:22 <beaky> tac: that's function composition :D
08:11:42 <beaky> but doesn;t that mean functions are functors too? :( now I'm even more confused
08:11:45 <`ramses> beaky: that's why lambdabot's (.) is fmap
08:11:56 <`ramses> beaky: ignore that for now
08:12:05 <mauke> beaky: a function is like a key-value map with automatic lookup
08:12:06 <`ramses> but yes they are
08:12:07 <beaky> (*10) . [1..10]
08:12:08 <mauke> or something
08:12:12 <beaky> > (*10) . [1..10]
08:12:13 <lambdabot>   [10,20,30,40,50,60,70,80,90,100]
08:12:28 <quchen_> beaky: Functions are examples of Functors. However, that instance is very confusing and you shouldn't worry about it. :-)
08:12:33 <beaky> ah
08:12:49 <beaky> mauke: that's actually a very interesting perspective on functions :D
08:12:54 <tac> > show `fmap` (+1) `fmap` (read :: String -> Int) $ "123"
08:12:55 <lambdabot>   "124"
08:13:05 <mauke> beaky: if you squint hard enough, functions are containers :-)
08:13:13 <beaky> like closures?
08:13:16 <tac> functions are just generalized product types
08:13:21 <mauke> no, like I said
08:13:29 <beaky> ah
08:13:30 <`ramses> mauke: isn't that stretching the meaning of the word container a bit
08:13:32 <tac> A x A x A x ... x A (infinity times) is isomorphic to N -> A
08:13:37 <mauke> `ramses: yes
08:13:51 <`ramses> I'd rather say a functor is not necessarily a container
08:14:01 <tac> I guess in Haskell (a, a, a, a, ...) ~ Nat -> a
08:14:03 <mauke> pfft, I'll stretch my analogies until they break
08:14:07 <beaky> what is the most abstract description of a functor?
08:14:15 <quchen_> Functions "contain" the thing they will evaluate to eventually when seen as Functors (and you insist using the container picture).
08:14:15 <mauke> @src Functor
08:14:15 <lambdabot> class  Functor f  where
08:14:15 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:14:17 <mauke> ^ that
08:14:17 <geekosaur> topological functions? :p
08:14:20 <tac> A functor is the morphism in the category of small categories
08:14:32 <geekosaur> or at least topological analogies...
08:14:37 <`ramses> a type constructor f with an operator of type :: (a -> b) -> f a -> f b
08:14:46 <tac> A functor is a category homomorphism.
08:15:07 <beaky> ah
08:15:14 <`ramses> guys, he's asking about functors in haskell
08:15:18 <`ramses> not in category theory
08:15:26 <beaky> aren't they related?
08:15:30 <tac> A functor is a map that takes commutative diagrams in one category to commutative diagrams in another.
08:15:31 <`ramses> somehow
08:15:40 <tac> oh, if it's haskell
08:15:46 <tac> It's just an endofunctor
08:15:58 <tac> Taking commuting diagrams in Hask to commuting diagrams to Hask
08:16:03 <beaky> hehe
08:16:20 <mauke> <end of unctor>
08:18:05 <beaky> so functors in Haskell are just fancy functions that map to themselves?
08:18:17 <quchen_> beaky: Heck no. Ignore tac.
08:18:42 <Lethalman> beaky, functors are what they are defined in haskell
08:18:48 <Lethalman> :S
08:18:48 <mauke> don't ignore tac, ignore yourself
08:18:59 <beaky> ah
08:19:09 <quchen_> What tac is saying is about as useful as teaching a first grader ring theory before telling them how to calculate (+).
08:19:26 <`ramses> hehe :)
08:19:28 <tac> quchen_: I don't see the issue. He'll learn more if he's curious what the fuck I'm actually talking about.
08:19:30 <quchen_> (No offense tac.)
08:19:38 <tac> At least, that's how I learned all the math I know :)
08:19:53 <`ramses> (just find the ideal, stupid toddler)
08:20:43 <beaky> what is a number
08:21:01 <quchen_> 1 is a number
08:21:11 <quchen_> Glad you didn't ask "what exactly is a number"
08:21:24 <beaky> so from understanding all the different instances of numbers, I can get an idea of the general notion of number?
08:21:30 <AS_> 1 is a numeral right?
08:21:52 <beaky> 1 is a numeral representing the number 1 :D
08:21:53 <sipa> :t 1
08:21:54 <lambdabot> Num a => a
08:25:01 <tac> Anyone who has used Haskell's Prelude knows "number" has only the faintest concrete meaning.
08:25:48 <beaky> I think I understand functors. Functors things that satisfy certain laws
08:25:56 <beaky> functors are things*
08:26:08 <`ramses> beaky: that's a pretty vague description ;)
08:26:12 <t7> functors only exist in your mind
08:26:25 <sclv> i have a sculpture of a functor on my desk
08:26:31 <tac> sclv: hehe
08:26:47 <`ramses> sclv: is it polymorphic? :)
08:27:33 <tac> beaky: Lists, Trees, and Monads. Those are the most important functors in your life.
08:27:58 <tac> When I think about a functor, I almost always have the List example in my head.
08:28:29 <sclv> (->) is my favorite functor
08:28:34 <tac> (+1) : Int -> Int           --------- List -------->         fmap (+1) : List Int -> List Int
08:29:21 <tac> show : Int -> String        ------------ List ----------> fmap show : [Int] -> [String]
08:29:42 <scooty-puff> given data Rep a b = U | a :-> b and data S = O | C and rep 'C 'C ~ (':->) S S a c, does not a ~ 'C?
08:29:43 <tac> id : a -> a                     -------------- List -------------->  fmap id : [a] -> [a]
08:31:09 <Saizan> scooty-puff: there are a few ghc versions where that doesn't hold
08:31:10 <scooty-puff> Could not deduce (a ~ 'C)
08:31:12 <scooty-puff>     from the context (rep 'C 'C ~ (':->) S S a c)
08:31:14 <scooty-puff> k
08:31:34 <scooty-puff> Saizan: with newer versions being ones where it does hold?
08:31:49 <scooty-puff> (> 7.6.1, hopefully 7.8, etc.)
08:32:17 <beaky> ah those examples make sense
08:32:21 <scooty-puff> eh, i can discover for myself
08:32:29 <beaky> so functors are an abstraction over functions
08:32:41 <Saizan> scooty-puff: yeah, basically it used to work, then they disabled it, but reenabled in HEAD a few months ago
08:32:54 <`ramses> beaky: functors allow applying a function on the values "inside" the functor
08:33:01 <`ramses> for a loose definition of "inside"
08:33:18 <`ramses> for lists, maybes, trees, ... inside really is inside
08:33:33 <beaky> what about function :D
08:33:51 <beaky> I guess the inside is the variables
08:33:52 <`ramses> well, a function (a -> b) "contains" values of type b
08:34:00 <scooty-puff> Saizan: thanks - i can workaround now by strengthening type signatures
08:34:03 <`ramses> to get such a b, you'd give a value of type a
08:34:17 <Saizan> scooty-puff: http://hackage.haskell.org/trac/ghc/ticket/7377
08:34:20 <beaky> but lists, trees, and functions are just endofunctors
08:34:35 <beaky> like tac said :D
08:35:13 <`ramses> a list is not an andofunctor, [] is an endofunctor in the category of types
08:35:15 <tac> @kind ([])
08:35:15 <Lethalman> about functors
08:35:16 <lambdabot> * -> *
08:35:19 <tac> @kind (IO)
08:35:20 <beaky> oh
08:35:20 <lambdabot> * -> *
08:35:24 <tac> @kind Maybe
08:35:25 <lambdabot> * -> *
08:35:31 <tac> All of these things are * -> *
08:35:36 <beaky> so those aren't endofunctors
08:35:38 <tac> They are all functions from types to types
08:35:50 <tac> (type-level functions, but still functions)
08:35:50 <Lethalman> is (Either a) a functor because it's not possible to do it for the Left?
08:36:08 <tac> A functor is a special class of things that have kind * -> *
08:36:08 <`ramses> Lethalman: yes, fmap on a left is id
08:36:08 <Lethalman> that is you can't do (Either _ b) and let the type parameter be the left one
08:36:32 <Lethalman> `ramses, what you mean?
08:36:35 <tac> @kind Either String
08:36:36 <lambdabot> * -> *
08:36:39 <Lethalman> `ramses, ah ok
08:36:45 <AS_> Hmm, are there any other that also have problems with the Captcha for the Trac?
08:36:49 <Lethalman> `ramses, but I mean why is the instance of Functor only mapping the Right?
08:36:55 <Lethalman> is it possible to have an instance fo map only the Left?
08:37:03 <Lethalman> *to
08:37:04 <`ramses> no
08:37:12 <`ramses> a functor always has kind * -> *
08:37:16 <beaky> ah
08:37:26 <beaky> so all type constructors are functors
08:37:30 <Lethalman> `ramses, ok but is it possible to have an instance of Either for mapping the Left?
08:37:36 <`ramses> think about if, for (Either a b), you'd have to supply a function that can take both a and b as possible input
08:37:45 <tac> Lethalman: sorta... you would need a type-level function equivalent of flip
08:37:46 <`ramses> s/if/it
08:37:49 <scooty-puff> \me ponders uploading to hackage something that currently only compiles on HEAD
08:37:53 <Lethalman> tac, ok that's it
08:37:59 <Lethalman> thanks
08:38:00 <tac> Flip f a b = f b a
08:38:15 <`ramses> Lethalman: ah ok, I guess I misunderstood your question :)
08:38:24 <tac> Then Flip Either a is a functor (I believe)
08:38:24 <Lethalman> tac, ah that's interesting
08:38:28 <Lethalman> `ramses, np I wasn't very clear
08:38:55 <tac> Hmm
08:39:01 <tac> I'm not sure all type constructors are functors
08:39:17 <tac> Though... they might be?? I'm not sure about that, though
08:39:25 <n-dolio> Depends on the category.
08:39:36 <tac> It seems like it would require parametricity
08:39:41 <`ramses> let's constrain that to Hask
08:40:07 <n-dolio> No, I mean that you have to pick the right domain category for them to be considered a functor.
08:40:13 <tac> beaky: as long as you can define fmap, though (and defined it in a way that satisfies all the laws), you're golden
08:40:39 <`ramses> n-dolio: what do you mean by that?
08:41:12 <Lethalman> what about data Foo a = Foo ?
08:41:14 <n-dolio> newtype Foo a = Foo (Int -> a) -- this is a functor from Hask to Hask.
08:41:33 <n-dolio> newtype Foo a = Foo (a -> Int) -- this is a functor from Hask^op to Hask
08:41:51 <`ramses> Lethalman: then fmap = id ?
08:41:51 <tac> Lethalman: yeah. Your fmap would just be fmap f = id, if I'm not mistaken
08:42:06 <Lethalman> ah ok
08:42:12 <tac> fmap id = id which is right, and fmap (f . g) = id = id . id = fmap f . fmap g
08:42:21 <beaky> fmap reminds me of lenses
08:42:26 <n-dolio> newtype Foo a = Foo (a -> a) -- this is a functor from Hask^wat to Hask, where Hask^wat arrows pairs of Hask arrows and Hask^op arrows.
08:42:30 <tac> phantom types give you trivial fmap definitions
08:43:17 <tac> n-dolio: If you were working in a total language instead, things might be nicer.
08:43:25 <tac> (Obviously, Haskell is not)
08:43:38 <`ramses> n-dolio: I don't follow that :s but I don't know a lot about Hask etc either
08:43:39 <n-dolio> Well, I'm not worried about exact equations.
08:44:26 <n-dolio> tac: All the stuff I said above applies to a total language, too.
08:44:57 <tac> ah, I misread your definition.
08:45:05 <elliott> IORef is a functor from sadness to lies :(
08:45:21 <n-dolio> `ramses: The idea is, if the parameter is in only covariant position, it's a functor from Hask, if it's only in contravariant position, it's from Hask^op, if it's in both co and contra positions, you need both maps. Etc.
08:45:30 <tac> elliott: oh? how so?
08:45:41 <elliott> tac: Well, I don't think it's a functor at all.
08:46:01 <n-dolio> For a GADT index, the category in question is probably Haskell types with equality as morphisms.
08:46:02 <merijn> elliott: Why not?
08:46:18 <elliott> merijn: How is it one?
08:46:27 <n-dolio> (Which isn't a super interesting category.)
08:46:37 <merijn> In the same way Maybe is one?
08:46:48 <elliott> Well, you can write fmap for Maybe.
08:46:53 <elliott> Not so for IORef.
08:47:06 <merijn> I guess, the problem is that you have to produce a result of the same type
08:47:08 <elliott> I'd expect to be able to write invmap (from the invariant package) for IORef if anything, but still no.
08:47:09 <tac> it's hard to tell, since IORef is abstract.
08:47:29 <n-dolio> elliott: IORef is (could be) invariant, so it's the (a -> b) -> (b -> a) -> IORef a -> IORef b case.
08:47:32 <elliott> fmap is "obviously" impossible even in the abstract for IORef, since you can both read and write.
08:47:37 <merijn> iorefFmap :: (a -> a) -> IORef a -> IORef a
08:47:50 <elliott> n-dolio: Right, could be. But isn't.
08:47:57 <elliott> Abstract types ruin everything.
08:48:01 <`ramses> n-dolio: I actually don't know what Hask^op is either, but I guess I just have to read a bit about it
08:48:15 <n-dolio> Well, yeah, they don't provide that function.
08:48:46 <n-dolio> `ramses: If C is a category, then C^op is a category, where the arrows from A to B in C^op are arrows from B to A in C.
08:48:51 <n-dolio> And the same objects.
08:49:18 <elliott> n-dolio: Right, and you can't implement it at all for IORef's representation in GHC.
08:49:20 <quicksilver> elliott, n-dolio : you can write it for Data.StateVar, in a manner of speaking.
08:49:35 <quicksilver> and Data.StateVar is kind of a chose-your-own-implementation IORef
08:49:41 <tac> elliott: Yeah, I think given a clever definition, you could have IORefs that are packaged with functions that get run on readIORef
08:49:42 <`ramses> ah, why is it called that way? it's like fmapping the inverse over the category :)
08:49:52 <tac> although... yeah, you can't write then.. nvm
08:49:57 <n-dolio> elliott: Yeah, that doesn't surprise me. They'd have to hold on to those pre and post functions.
08:50:19 <elliott> Maybe we should all be using (exists s. (Lens' s a, IORef s)) as our IORef type.
08:50:32 <elliott> Then you could give an Invariant instance.
08:50:48 <elliott> (At the cost of unimportant stuff like probably a lot of constant factors.)
08:51:05 <n-dolio> elliott: And probably no one actually wants to map an IORef very often.
08:51:13 <n-dolio> So it'd be wasted overhead.
08:51:15 <quicksilver> elliott: or HasGetter a, HasSetter a
08:51:21 <quicksilver> elliott: or StateVar
08:51:23 <quicksilver> etc...
08:51:24 <elliott> n-dolio: Right.
08:51:31 <elliott> quicksilver: Well, a lens is precisely a getter + a setter.
08:51:52 <quicksilver> I know but I'm talking about specific existing classes
08:51:57 <quicksilver> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
08:52:48 <elliott> Right.
08:55:20 <beaky> are there multifunctors in haskell?
09:02:06 * hackagebot hs-bibutils 4.16 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-4.16 (AndreaRossato)
09:11:14 <ski> beaky : "multifunctors" being ?
09:11:53 <beaky> like a function composition that composes binary functions
09:12:20 <Lethalman> :t on
09:12:22 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
09:12:34 <beaky> woah
09:13:01 <beaky> @src on
09:13:01 <lambdabot> (*) `on` f = \x y -> f x * f y
09:13:09 <Lethalman> @hoogle bifunctor
09:13:10 <lambdabot> package bifunctors
09:13:15 <beaky> ah thanks
09:13:30 <beaky> wow haskell hsa a library for everything
09:13:46 <Lethalman> except for up-to-date guis :(
09:13:51 <beaky> :(
09:13:53 <ski> > (sortBy (compare `on` length) . words) "The quick brown fox jumps over the lazy dog"
09:13:55 <lambdabot>   ["The","fox","the","dog","over","lazy","quick","brown","jumps"]
09:14:15 <beaky> imagine a purely functional GUI framework
09:15:08 <ski> perhaps look at Fudgets, or conal's work
09:21:13 <hiptobecubic> @src comparing
09:21:13 <lambdabot> Source not found. Where did you learn to type?
09:21:32 <hiptobecubic> i guess it's probably just  (compare `on`)
09:21:37 <ski> aye
09:21:55 <beaky> compare `on` length is an awesome thing
09:22:07 * ski sometimes defines  equating f = (==) `on` f
09:22:26 <Lethalman> turns out my problem about the device space was the /tmp
09:22:36 <Lethalman> I used another tmp with $TMPDIR and $TMP and all was fine
09:23:10 <ski> > (sortBy (comparing length `mappend` compare) . words) "The quick brown fox jumps over the lazy dog"  -- sort primarily by length, secondarily by lexicographic ordering
09:23:12 <lambdabot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
09:23:20 <sclv> anyone remember when/why let floating can be a bad idea?
09:23:37 <neutrino_> what's let floating?
09:24:41 * ski notes conal appears
09:25:16 <conal> hey
09:25:16 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
09:25:38 <ski> beaky was imagining a purely functional GUI framework
09:26:10 <ski> (i'm not sure whether she/he/it has any questions, though)
09:26:11 <sclv> let floating is a compiler optimization where we take all the lets under lambdas, and pull them out as far to the left as possible
09:26:39 <parcs> what's the difference between an inlined unsafePerformIO function and unsafeDupablePerformIO ?
09:26:48 <conal> denotative (precise, consistent semantics), or just functional (whatever that means)? or ?
09:27:09 <sclv> so \x -> \y -> \z -> let foo = 2 * x in foo + y + z becomes \x -> let foo = 2 * x in \y -> \z -> foo + y + z
09:27:22 <sclv> i know that it isn't always an optimization, but i forget why
09:27:32 * ski is waiting to see whether beaky responds
09:27:34 <sclv> let floating helps with cse too
09:28:04 <parcs> conal: was that to me?
09:28:23 <conal> i used to assume people mean denotative by "functional". but a lot goes by "functional" these days.
09:28:34 <sclv> parcs: as i recall, unsafe only happens once, unsafeDupable is allowed to happen multiple times
09:28:38 <ClaudiusMaximus> sclv: the usual cse-like issues of space vs time?
09:28:39 <conal> parcs: no. beaky.
09:29:14 <sclv> which is just their name, so i'm trying to remember the circumstnace.
09:29:18 <sclv> oh, wait, you said inlined.
09:29:20 <sclv> hmm
09:29:20 <parcs> sclv: but an inlined unsafePerformIO allows it happen multiple times too, right?
09:29:57 <n-dolio> unsafePerformIO uses an MVar or something to ensure that the effect can only happen once.
09:30:04 <n-dolio> Dupable does not.
09:30:18 <n-dolio> I think.
09:30:56 <n-dolio> So there's some unlikely race condition where Dupable can cause things to happen twice.
09:31:18 <sclv> right, even without inlining you can get dupable twice
09:31:24 <sclv> at the same call site
09:31:35 <sclv> so inlining lets it happen once per call
09:31:40 <ski> conal : is there a short overview or definition of what "denotative programming" means ?
09:31:41 <sclv> dupable lets it happen twice for the *Same* call
09:31:56 <sclv> if two threads enter a closure at once
09:32:16 <conal> ski: there's a terse definition in landin's seminal "next 700 programming languages". i'll dig up a pointer.
09:32:36 <conal> for "denotative", follow pointers from http://conal.net/blog/posts/is-haskell-a-purely-functional-language#comment-35882
09:33:31 <conal> Peter Landin (grandfather of ML & Haskell) recommends "denotative" as a replacement for vague terms like "functional" and "declarative".
09:35:12 <tac> Are there any good twitter APIs for Haskell that support making tweets?
09:35:25 <ski> would Mercury programming be considered denotative ?
09:35:29 <conal> note landin's test for whether a "notation is genuinely functional or merely masquerading."
09:37:03 <merlin_> I am a bit confused what hsc gives me over defining foreign functions in .hs file, and what binding-dsl has over manually both. can someone give me a quick summary?
09:37:23 <merlin_> s/manually//
09:37:45 <sonOfRa> So, when using Control.Exception.catch instead of the Prelude version(from System.IO.Error?), I can not figure out how to properly catch an exception on reading a file
09:37:46 <sonOfRa> http://hpaste.org/80878
09:38:15 <conal> ski: i don't know mercury.
09:38:40 <sonOfRa> the above code works perfectly fine when not using Control.Exception.catch, but with it, i get the following error, and I can't figure out how to get it to work
09:38:40 <sonOfRa> http://hpaste.org/80879
09:38:48 <ski> Mercury is a logic programming language (though it supports functions as well, so one could say logic/functional language)
09:40:09 <ski> it uses a similar syntax as Prolog, but has removed illogical features of Prolog : e.g. cut, setarg/3, assert[az]/1 & retract/1, var/1 & nonvar/1 & (==)/2, and side-effecting I/O
09:40:23 <conal> ski: that's about all i know. based on just that much, it might or might not be. depends on particulars.
09:41:21 <ski> one might say that it's a purified version of Prolog, with an added static type system (and a mode and determinism system)
09:41:27 <ski> (and a module system)
09:42:11 <ski> the intension is that the ordinary logical laws should be valid for reasoning about, and transforming, programs
09:42:59 <tac> ski: Why is cut illogical?
09:43:19 <ski> (most illogical features in Prolog can be displayed as a failure of conjunction to be commutative, e.g.)
09:43:48 <tac> it's not the same cut as the cut rule in logic, is it?
09:44:18 <maxharris> hey everyone.
09:44:19 <geekosaur> cut aborts a leg of a pattern match, roughly
09:44:20 <ski> tac : (a) its behaviour depends on the context it appears in; (b) you can't even factor out a block of code including cut into a new predicate (cf. with `return',`break',`continue' in C)
09:44:27 <ski> tac : right, it's not the same
09:44:40 <geekosaur> *very* roughly
09:45:00 <tac> ski: ah, kk
09:45:22 <ski> ordinarily, you can understand separate clauses of a Predicate definition separately
09:45:32 <maxharris> I'm trying to get base >= 4.4, and I'm on a OS 10.6 machine. Which Haskell platform installer version do I need?
09:45:46 <maxharris> OS X 10.6 I mean
09:45:48 <ski> but if you write
09:45:48 <byorgey> how can I check what the current set of global preferred versions is for Hackage?
09:45:58 <ski>   max(A,B,A) :- A >= B,!.
09:46:03 <ski>   max(A,B,B).
09:46:29 <ski> the the `!' (cut) in the first clause affects the meaning of the second clause `max(A,B,B)', so you can no longer understand a program clause in isolation
09:48:21 <ski> (s/the the/then the/)
09:54:34 <geekosaur> maxharris, the current one should work.  be warned that despite what the installer page for mac says, the 64 bit version of ghc does not work on 10.6 (core dumps)
09:54:38 <maxharris> how do I tell what version of base is included here? http://lambda.haskell.org/platform/doc/2012.4.0.0/
09:54:56 <maxharris> It doesn't list a version next to base anywhere in there
09:55:00 <geekosaur> (I got it installed 64 bit via macports and have not seen problems yet, but I have been warned that there are in fact problems)
09:55:22 <geekosaur> http://www.haskell.org/platform/changelog.html says base 4.5.0.0 ⟶ 4.5.1.0 in 2012.4.0.0
09:55:39 <geekosaur> (ghc 7.4.2)
09:55:49 <maxharris> ok, thanks guys!
09:56:15 * Lethalman sees cabal downloading hakyll after 2 days of compiling
09:56:30 <ski> conal : in case you're interested, the project page is at <http://www.mercurylang.org/>
09:56:41 <conal> ski: thx
09:57:52 <ski> (there's a papers section, but on a quick scan, i didn't find a paper which discusses much the "pure declarative logic" aspects of Mercury)
09:58:46 <ski> (there is also a (small) #mercury channel here on FreeNode)
10:09:03 <beaky> if javascript's wtfs are things like == vs ===, and C's wtfs are fall-through switches, what are Haskell's wtfs?
10:09:13 <tibbe> Do we have a function to split Strings on a separator in base?
10:09:15 <nand`> is the TypeNats stuff implemented to a usable degree in any of the GHC branches yet? I tried type-nats but it doesn't seem to solve 1+1 ~ 2
10:10:12 <tac> beaky: unsafePerformIO, seq, the fact that typeclasses require you to be able to solve prolog to understand your code, the fact that type inference requires you to solve hindley milner to understand your code.
10:10:30 <tac> _ patterns, the fail method in monad
10:10:31 <nand`> tibbe: I don't think there are any in base, but see Data.List.Split
10:10:36 <tac> There's a few
10:10:36 <tibbe> ok
10:10:38 <tibbe> thanks
10:10:43 <parcs> tibbe: the closest thing is 'break' or 'span' which splits on the first separator
10:10:49 <tibbe> right
10:10:52 <tibbe> just checking
10:10:56 <tibbe> before i roll my own
10:10:58 <mm21> tac: why _ patterns?
10:11:00 <Lethalman> tibbe, splitOn
10:11:09 <beaky> solve prolog?
10:11:23 <Lethalman> (not in base)
10:11:23 <geekosaur> beaky:  one of the more common gotchas is trying to use variables in pattern matches.  that is, let a = 5 in { foo a = 6; foo _ = 7 } won't work because "a" is taken to mean create a new binding that shadows the old one and matches anything
10:11:31 <nand`> splitOn is in Data.List.Split
10:11:43 <tac> mm21: those aren't all that bad. I take that one back
10:11:57 <yitz> beaky: Monad is not a subclass of Functor
10:12:06 <Lethalman> beaky, foo a a = a won't work, the first time I did I expected so match the first and second argument to be the same :P
10:12:08 <beaky> ah
10:12:08 <nand`> tibbe: there are some limited forms of splitting functions in base, words and lines
10:12:14 <Lethalman> *to
10:12:18 <tac> beaky: How do you know when there's an typeclass instance for a type? Answer, you have to follow the inference rules generated by all the instances in a typeclass.
10:12:35 <tibbe> nand`: right
10:14:04 <fryguybob> byorgey: Open the `preferred-versions` file from 00-index.tar.gz.
10:14:09 <elliott> tac: I don't see how any of those are wtfs.
10:14:11 <yitz> tibbe: Data.List.Split is in the platform now. why roll your own?
10:14:23 <byorgey> fryguybob: ah, thanks
10:14:34 <elliott> tac: unsafePerformIO is incredibly important and useful (you couldn't write useful FFI bindings without it, for instnace); same for seq.
10:14:46 <elliott> Typeclasses, without language extensions, are much simpler than Prolog (not full constraint solving at all).
10:15:00 <elliott> Oh, I missed fail. fail in Monad *is* a WTF.
10:15:56 <tibbe> yitz: I'm hacking on GHC
10:16:14 <yitz> tibbe: that would do it :)
10:16:20 <tibbe> :)
10:16:29 <tibbe> you're getting better SSE support
10:16:32 <tac> The whole "It's a language extension" argument is just a way to dismiss any drawbacks of the language. No one writes Haskell 98. Haskell is de-facto what GHC will compile.
10:16:38 <ski> Lethalman : works in Prolog and Erlang
10:16:59 <Lethalman> ski, yes, that's why it's a wtf at first :P
10:17:14 <beaky> ah
10:17:22 <ski> did you see Haskell after any of those two ?
10:17:49 <Lethalman> ?
10:18:00 <tac> Also, the choice of typeclasses in the Prelude. In particular, the numeric tower
10:18:06 <ski> s/see/first see/
10:18:13 <elliott> tac: Still, it's not constraint solving: the general principle of not having to look at the contexts to determine the chosen instance holds almost always (maybe always? not sure with incoherent instances or whatever but nobody uses that).
10:18:34 <Lethalman> ski, yes, did something in prolog and erlang before writing some working haskell programs
10:20:02 <yitz> tac: it's not so simple as that. ghc is still also a research compiler. there is a subtle transition when a feature that had been just a research experiment becomes both stable enough and widely enough to enter the haskell that people use in practice.
10:20:17 <yitz> *use it]
10:20:50 <tac> I agree. it's not simple. It's arguably more complex than C++ :P
10:21:31 <tac> But language fails are somewhat personal things. I've just lost more hair to type classes than to any other language feature in haskell.
10:21:35 <yitz> tac: the haskell prime committee was supposed to help. but in the end no one had enough time to spend on that project to keep it useful.
10:22:42 <yitz> tac: yes i agree. that's why the "classy prelude" irks me. i hope that doesn't catch on. i want type classes only where they are really needed.
10:23:06 <tac> yitz: I'm not saying there aren't completely legitimate reasons for these kinds of things :)
10:23:30 <tac> Haskell isn't a diamond, put on this earth by the divine lambda in the clouds
10:24:05 <tac> it is the more powerful functional animal that has survived the test of Darwin
10:24:13 <yitz> tac: sure. i don't think saving people from saving T.take instead of take is one of those legitimate reasons.
10:24:53 <tac> More than the qualification, it's the number of modules I have to import that tends to bug me in Haskell.
10:25:01 <tac> I swear, any module I write imports at least a dozen
10:25:21 <tac> (though, I could probably reduce that number if I knew which modules imported which other modules maybe)
10:25:24 <yitz> tac: doesn't bother me. certainly not enough to make a total wreck out of the prelude.
10:37:08 * hackagebot clay 0.1 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.1 (SebastiaanVisser)
10:41:07 <sonOfRa> I'm asking the user for input in a first step. If the user enters a Q or q for quit, this action should be executed:
10:41:07 <sonOfRa> http://hpaste.org/80880
10:41:40 <tac> sonOfRa: are you new to Haskell?
10:41:58 <sonOfRa> well, first semester, but near the end. The problem I'm having, is that it immediately terminates
10:42:03 <tac> kk
10:42:08 <sonOfRa> with an exception that openFile failed, file does not exist
10:42:08 * hackagebot haskell-qrencode 1.0.4 - Haskell bindings for libqrencode.  http://hackage.haskell.org/package/haskell-qrencode-1.0.4 (JamesSanders)
10:42:16 <tac> just asking, because usually you write your functions uncurried :)
10:42:50 <sonOfRa> It seems that it does not wait for the getLine, but just passes something there and goes on to the next step, which I don't understand
10:42:53 <tac> Maybe it's the exitSuccess throwing an exception
10:43:09 <tac> ah, it doesn't prompt you then?
10:43:20 <sonOfRa> No
10:43:50 <sonOfRa> it somehow gets some input from somewhere else, I "solved" it by inserting another getLine before fn <- getLine
10:43:59 <sonOfRa> but that seems like a dirty hackish kind of way to solve it
10:44:16 <tac> So it prints the prompt
10:44:21 <tac> but then it doesn't wait for input
10:44:23 <Hermit> sonOfRa: maybe it's because getLine is being lazily evaluated. Try  fn `seq` save fn tuple...
10:44:24 <sonOfRa> exactly
10:45:15 <tac> In any case, I think the exit success probably belongs on the last line (not inside the catch)
10:45:41 <sonOfRa> putting it on the last line is a problem
10:45:51 <sonOfRa> in case there was an error, i want to prompt the user for a valid filename
10:46:09 <sonOfRa> the check is basically just for permission denied
10:47:38 <geekosaur> sunOfRa:  if I had to guess, you're making a typical (in many languages) error involving buffered I/O
10:47:51 <geekosaur> "If the user enters a Q or q for quit"
10:48:06 <geekosaur> I'm betting you just read the character, but input is line buffered so the newline is still waiting to be read
10:48:20 <geekosaur> er
10:48:23 <geekosaur> sonOfRa ^^
10:48:38 <ski> sonOfRa : re <http://hpaste.org/80878>, not sure if anyone already said this, but i think you want `return (read contents :: (Labyrinth, Position))', or better, `readIO contents'
10:49:33 <beaky> > fmap (fmap (+)) [[1..10], [1..10], [1..10]]
10:49:34 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
10:49:34 <lambdabot>    arising from a use of `M54191...
10:50:04 <beaky> > [[1..10], [1..10], [1..10]] >>= sum
10:50:06 <lambdabot>   No instances for (GHC.Enum.Enum [b0], GHC.Num.Num [b0])
10:50:06 <lambdabot>    arising from a u...
10:50:35 <beaky> my haskell-fu isn't good :(
10:50:54 <kennyd> what are you trying to do?
10:51:07 <Lethalman> > [[1..10], [1..10], [1..10]] >>= return . sum
10:51:08 <lambdabot>   [55,55,55]
10:51:15 <beaky> yeah that!
10:51:19 <beaky> wow how did it work
10:52:02 <kennyd> > map sum [[1..10], [1..10], [1..10]]
10:52:04 <lambdabot>   [55,55,55]
10:52:21 <beaky> ah
10:53:02 * Hermit wouldn't mess with the list monad if a simple map can do the job
10:53:12 <applicative> > liftM sum  [[1..10], [1..10], [1..10]]
10:53:14 <lambdabot>   [55,55,55]
10:53:27 <applicative> this is more 'monadic' like your original >>= sum
10:53:34 <beaky> ha
10:53:37 <beaky> ah*
10:54:01 <beaky> liftM seems to preserve the monad
10:55:36 <ski>   liftM = fmap
10:55:44 <Hermit> beaky: preserve the monad you say... they are just lists. There's no vodoo magic other than a Monad [] instance...
10:55:47 <srhb> If you just want monads instead of the direct fmap, we can make it woese
10:55:57 <srhb> > do { xs <- [[1..10], [1..10], [1..10]]; (return . sum) xs }
10:55:58 <lambdabot>   [55,55,55]
10:56:35 <srhb> (but, really, use fmap) :P
10:56:54 <Hermit> for lists fmap = map so why bother with fmap?
10:56:58 <srhb> True enough.
10:57:03 <Hermit> keep it simple
10:57:14 <HugoDaniel> yeah, but for everything else fmap rocks
10:57:17 <srhb> Point being, use the fact that it's a functor. map shouldn't really exist imo.
10:57:20 <frerich_> What kind of language is this that it makes people try to come up with the most contrived solution - is coming up with the simplest solution too easy? :)
10:57:27 <srhb> frerich_: yes!
10:57:28 <HugoDaniel> i even prefer fmap over <$> because that way i can avoid importing applicative
10:58:17 <fmap> @ty fmap over (<$>)
10:58:19 <lambdabot> (Mutator b -> Mutator t) -> (s -> b) -> s -> t
10:58:20 <beaky> <$> saves a character or three
10:58:23 <elliott> HugoDaniel: (<$>) is in Data.Functor.
10:58:29 <Lethalman> :t over
10:58:31 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
10:58:36 * Lethalman runs away scared
10:58:39 <beaky> :t fmap fmap fmap
10:58:41 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:58:43 * ski thinks `<*>' ought to have been called `<$>', and `<$>' something else (perhaps `$>' ?)
10:58:55 <HugoDaniel> :D
10:59:04 <HugoDaniel> ok
10:59:23 <HugoDaniel> i usually import <$> from Control.Applicative
10:59:52 <elliott> ski: what to call (<$) then?
11:00:39 <ziman> :t (<$)
11:00:41 <lambdabot> Functor f => a -> f b -> f a
11:01:03 <johnw> fconst? :)
11:01:39 <beaky> > 1 <$ ['a']
11:01:41 <lambdabot>   [1]
11:01:56 <yitz> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
11:01:57 <lambdabot> (Functor f1, Functor f) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
11:01:58 <yitz> @type fmap fmap fmap fmap fmap fmap
11:01:59 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
11:02:17 <beaky> :type fix fmap
11:02:26 <beaky> :t fix fmap
11:02:28 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = f0 b0
11:02:28 <lambdabot>     Expected type: (a0 -> b0) -> a0 -> b0
11:02:28 <lambdabot>       Actual type: (a0 -> b0) -> f0 a0 -> f0 b0
11:02:50 <ski> elliott : i'd prefer no `$' at all in it, since it doesn't apply any function to an argument
11:03:15 <elliott> call it (<) then :P
11:03:33 <beaky> why did $ mean funcion application?
11:04:44 <ski> i don't know, but it has that meaning in `$' and `$!'
11:06:19 <johnw> I think it's <$ by analogy with <*, in the way that <$> relates to <*>
11:06:36 <johnw> i.e., that the thing to the left is pure is both $ cases, and applicative in both * cases
11:08:34 <ski> imo, `<*>' could be a sensible name for `Applicative i => i a -> i b -> i (a,b)'
11:08:53 <johnw> :t (***)
11:08:54 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
11:09:06 <johnw> i'd call it <***>
11:09:24 <johnw> or, just maybe, liftA2 (,) :)
11:09:37 <johnw> how about <,>
11:09:44 <johnw> that would be the most appropriate I think
11:10:04 <ski> yes, it would be better if the type `(a,b)' was written otherwise
11:10:05 <elliott> (<+>) :: Alternative f => f a -> f b -> f (Either a b)
11:10:10 <johnw> and <:> would be Applicative f => f a -> f [a] -> f [a]
11:10:26 <johnw> ah, I see why you want <*>
11:10:39 <elliott> (<^>) :: ??? f => f ??? -> f ??? -> f (a -> b)
11:10:42 <johnw> yep
11:11:00 <johnw> <*> was perhaps not the best choice for what it does
11:11:38 * elliott would like to see a much lighter-weight name for <*>
11:11:45 <elliott> like (~) or something.
11:12:08 <johnw> a unicode operator would actually be nice for that one
11:12:14 * hackagebot smtp-mail 0.1.4.3 - Simple email sending via SMTP  http://hackage.haskell.org/package/smtp-mail-0.1.4.3 (JasonHickner)
11:12:28 <elliott> no because you actually have to type it :P
11:12:41 <johnw> well, Emacs does make that rather easy
11:12:51 <johnw> 2√i²
11:12:58 <johnw> is no harder to type than ASCII
11:13:13 <johnw> just a wee bit harder :)
11:16:36 <akosch> what's the general opinion on F# here? I'm tinkering with it and it doesn't seem to venture nearly as far away from the mainstream as haskell does, but it still seems like a nice alternative to other .net languages
11:16:56 <johnw> that pretty much sums it up
11:17:22 <srhb> "Better than C#, not Haskell"? :P
11:17:39 <akosch> srhb: my thoughts exactly :)
11:18:26 <akosch> does the CLI even offer TCO?
11:18:37 <jang> I believe so, yeah
11:18:39 <merijn> akosch: It seems to basically be Ocaml with .NET support, so in that sense it's probably a good substitute for ocaml on Windows. And Ocaml (to me) is a "it'll do if there's no haskell"-language
11:19:11 <akosch> jang: I've heard that the JVM (Scala?) has problems with that
11:19:15 <geekosaur> more or less; F# is explicitly modeled on O'Caml
11:19:24 <jang> it does. The JVM still doesn't do TCO.
11:19:54 <jang> scala has a @tailrec annotation that'll error if a function can't be TCOed.
11:20:28 <jang> which means, no mutual recursion and the functions in question have to be "final" (since scala does OO)
11:20:48 <jang> no idea what the state of the art for sala on cli is.
11:20:58 <akosch> jang: thanks for the info
11:21:10 <akosch> sadly I don't know OCaml: does anyone have book recommendations on F#?
11:21:53 <akosch> (I'm not looking for winforms tutorials, I would be more interested in the language features/syntax)
11:22:26 <jang> I still think the nicest language feature is a first-class units-of-measure implementation.
11:22:59 <jang> it means f# code can do away with hungarian notation and embed such "assertions" in the type system, where they belong :-)
11:23:42 <akosch> jang: wow, this actually is pretty cool (even by haskell standards)
11:24:40 <akosch> I hope it's not unpatriotic if someone doesn't like the hungarian notation as a hungarian :(
11:25:13 <johnw> oh, it's being patriotic to the world
11:26:41 <merlin_> if function f calls printf with hardcoded format string, is it correct to that if f <some arg> doesn't produce runtime error, no call to f will produce printf-related runtime error?
11:26:49 <jang> the original intent of hungarian notation was not completely misguided; but when it turned into a straightforward reflection of concrete types it lose all reason.
11:26:51 <merlin_> hope that made sense
11:26:59 <johnw> merlin_: sorry, it did not :(
11:27:37 <johnw> jang: i worked with a Java programmer who used "oFoo" to refer to a variable of any object type
11:27:37 <lispy> merlin_: f <some arg> is very different from f <any arg>, did you mean the later?
11:27:51 <jang> johnw: that's awful :-(
11:27:57 <akosch> jang: I think they originally used it for some old arcane language
11:28:20 <johnw> when I explained that that was ridicilous because every fundamental type had a unique prefix character, so you could just say that anything NOT a fundamental type was an object type, I was met with disbelief
11:28:23 <akosch> johnw: I've heard of companies where this is in the coding standard :/
11:28:24 <monochrom> "oFoo" is a new level of depravity
11:28:48 <monochrom> > printf "%d" 5 :: String
11:28:49 <lambdabot>   "5"
11:28:49 <johnw> oFoo is like naming functions "funFoo"
11:28:55 <monochrom> > printf "%d" True :: String
11:28:57 <lambdabot>   No instance for (Text.Printf.PrintfArg GHC.Types.Bool)
11:28:57 <lambdabot>    arising from a us...
11:28:57 <johnw> what in the heck does it buy you?
11:29:08 <monochrom> > printf "%s" 5 :: String
11:29:09 <lambdabot>   "*Exception: Printf.printf: bad argument
11:29:17 <monochrom> runtime error is still possible
11:29:24 <johnw> > printf "%s" True
11:29:25 <akosch> johnw: "everythingIsAnObjectFoo"
11:29:26 <lambdabot>   No instance for (Text.Printf.PrintfArg GHC.Types.Bool)
11:29:26 <lambdabot>    arising from a us...
11:29:31 <jang> "oFoo" may be my new IRC nick.
11:29:36 <merlin_> lispy: no, I meant some arg. if call to that function with one argument doesnt produce runtime errors can we assume that we cant get printf-related runtime errors with any argument
11:29:37 <johnw> > printf "%d" 5
11:29:39 <lambdabot>   Ambiguous type variable `a0' in the constraints:
11:29:39 <lambdabot>    (GHC.Show.Show a0)
11:29:39 <lambdabot>     ...
11:29:49 <monochrom> or if you say, "but I am putting it in a function f!" ok, let's try
11:29:53 <ski> > printf "%d" 5 :: String
11:29:54 <lambdabot>   "5"
11:30:26 <merlin_> I think we can assume that but I am not sure
11:30:31 <monochrom> oh wait, you hardcode both the format string and the type. then no runtime error.
11:30:53 <merlin_> monochrom: yes, much better way of putting it
11:31:16 <lispy> Well, in that case http://theproofistrivial.com/
11:31:40 <johnw> lispy: that's awesome
11:31:45 <monochrom> god
11:31:47 <merlin_> wondering though if there is some printf corner case where that isnt truei
11:32:02 <johnw> i live for printf corner cases
11:32:04 <lispy> merlin_: I'm assuming you are ignoring _|_
11:32:29 <merlin_> yes I am talking about runtime errors related to printf only
11:32:34 <lispy> merlin_: could you have a misbehaving type class instance get in the way?
11:32:54 <lispy> I guess printf defines all its own instances so the answer would be no?
11:33:17 <merlin_> I have no idea that is why I am asking :)
11:33:38 <monochrom> printf does not let you add instances
11:33:40 <lispy> Sorry if that was confusing, I was wondering outloud
11:33:58 <merijn> FRP question (netwire), I get most of the state is usually supposed to be in the wire I'm stepping through, but what's best way to deal with state that needs to be saved outside the wire too? Use the fact that Wires run in a monad and then use IO/STM to keep state outside the wires?
11:34:33 <ski> hm, blank page
11:34:41 <merijn> And then the next question is: If I'm gonna do that, does it even make sense to use FRP at all?
11:35:45 * merijn pokes mm_freak with a stick
11:36:18 <monochrom> haha, this question is related to the Smullyan drinking paradox
11:37:25 <monochrom> sdp :: Int -> String; sdp x = printf "%whatever" x
11:37:56 <akosch> monochrom: I didn't hear anyone refer to that in a long time :)
11:38:18 <monochrom> there exists non-⊥ Int x such that: if sdp x is an error, then every sdp y is an error :)
11:42:04 <akosch> monochrom: The ultimate truth, I'm a witness
11:55:55 <`nand`> does that imply that either the function never errors, or always errors?
11:56:18 <monochrom> yes
11:56:44 <sonOfRa> I'm following this (http://leiffrenzel.de/papers/commandline-options-in-haskell.html) guide on command line options, but there's a thing that I don't understand: How does this work? http://hpaste.org/80881
11:56:57 <sonOfRa> He calls a function with ONE argument, but uses 2 arguments in the equation?
11:58:01 <geekosaur> it's called partial application
11:58:22 <geekosaur> optInput is a function which is passed a parameter.  that parameter will be fed to the partially applied function
11:58:56 <sonOfRa> no, what I mean is something different
11:59:03 <geekosaur> wait, I was looking attthe wrong thing
11:59:14 <mm21> taking sets as objects and as arrows, those f:A -> B where f^-1(b) infinite for all b∈B. is this a category? http://math.stackexchange.com/questions/49143/is-it-a-category says there are no identies, but i don't see this
11:59:17 <sonOfRa> readInput takes ONE argument of type Options
11:59:18 <geekosaur> but it's still likely to be the answer.  partial application is used a lot in haskell
11:59:32 <sonOfRa> but in the equation, he uses readInput opt arg =...
11:59:48 <monochrom> oh interesting, it should be a type error isn't it?
12:00:02 <monochrom> unless "IO" means something else
12:00:12 <geekosaur> it should complain about that, I'd think, yeh.
12:00:35 <Eduard_Munteanu> mm21: what do you mean f^-1(b) is infinite?
12:00:55 <sonOfRa> My, modified exampe comes out with this compile error:   The equation(s) for `startFile' have two arguments,
12:00:55 <sonOfRa>   but its type `Options -> IO Options' has only one
12:01:26 <ski> mm21 : if `f = id : A -> A', then `{x : A | f(x) = b}' is just `{b}', which is finite
12:01:51 <mm21> Eduard_Munteanu: every b in B has infinite a in A that map onto b?
12:01:51 * geekosaur checks the original reference to see what's really going on
12:01:59 <Eduard_Munteanu> The preimage is infinite as a set?
12:02:13 <mm21> ski: thx i try to understand that
12:02:15 * hackagebot haskades 0.1.1 - Utility to generate bindings for BlackBerry Cascades  http://hackage.haskell.org/package/haskades-0.1.1 (StephenWeber)
12:02:18 <sonOfRa> geekosaur, starts at "Towards a higher level"
12:02:22 <Eduard_Munteanu> mm21: that only works when A and B are sets of numbers
12:02:43 <ski> Eduard_Munteanu ?
12:02:54 <mm21> Eduard_Munteanu: i'ts from awodey page 6 (top)
12:03:01 <geekosaur> oh, I think I see, if this is the thing at the end then it's just a copy/paste error
12:03:02 <Eduard_Munteanu> Oh, nevermind I misinterpreted that.
12:03:19 <Eduard_Munteanu> (I thought f^-1(b) = some a which is infinite)
12:03:24 <geekosaur> mm, except that doesn't seem to match either. actually
12:04:10 <Eduard_Munteanu> mm21: you might be interested in ##categorytheory, we're there too :)
12:04:28 <mm21> oohhh :D
12:04:46 <geekosaur> hm.  ok, I think it is copy-paste error
12:04:59 <sonOfRa> on my end, or on the blog's end? Oo
12:05:03 <geekosaur> writeOutput :: Options -> IO Options
12:05:04 <geekosaur> writeOutput arg opt = return opt { optOutput = writeFile arg }
12:05:24 <geekosaur> (which si followed by "Thus if we recognize...")
12:05:44 <sonOfRa> Yeah. There he does the same thing, using 2 parameters in an equation, whereas it only takes one
12:05:59 <geekosaur> so they copy-pasted from something (probably an earlier iteration of either the code or the blog entry) and failed to fix it
12:06:09 <sonOfRa> -.-
12:06:24 <merijn> sonOfRa: It's possible to have 2 parameters in an equation that only takes 1, but not in this case
12:06:33 <geekosaur> (some of us refer to that as copypasta...)
12:06:55 <merijn> For example, if the return value is a function. Lemme see if I still have an example of that
12:09:25 <monochrom> the internet has errors. trust monochrom only.
12:09:46 <int-e> @bot
12:09:46 <lambdabot> :)
12:10:46 <hpaste> “`ramses” pasted “Too much parameters” at http://hpaste.org/80883
12:11:04 <`ramses> merijn: you don't mean something like that?
12:11:21 <monochrom> that one is valid
12:11:49 <`ramses> yeah, trivial actually
12:12:57 <sonOfRa> Is it just me or is accepting commandline arguments rather tedious in haskell? Oo
12:13:06 <`nand`> not really
12:13:20 <merijn> `ramses: It's weirder if you "type Foo a = a -> a" it and then write "a -> Foo a"
12:13:28 <`nand`> there are several libraries to do the job, and for simple stuff you can just get them as a [String] and do whatever
12:13:32 <frerich_> How does one update the base package? I tried 'cabal update && cabal install base' but it says that 'base-4.5.1.0' is already installed. On Hackage I can see http://hackage.haskell.org/package/base-4.6.0.0 though.
12:13:32 <merijn> sonOfRa: Isn't it tedious in any language...
12:13:37 <`ramses> merijn: I was suspecting that was what you meant :)
12:13:50 <glguy> frerich_: You install a new version of GHC to update base
12:14:23 <`ramses> merijn: but that was basically what you were getting at or is there an other way still?
12:14:37 <merijn> `ramses: That's what I meant
12:14:47 <frerich_> glguy: Oh, I see. So I first have to figure out how to uninstall the existing version (I just saw I have three 'cabal' binaries on OS X...)
12:14:55 <geekosaur> frerich, more to the point, base contains the ghc runtime; it *must* be installed as part of the compiler
12:15:06 <geekosaur> you cannot uninstall or upgrade it in an existing compiler
12:15:15 <merijn> frerich_: Did you install the platform?
12:15:27 <frerich_> merijn: Quite honestly: I cannot remember.
12:15:29 <geekosaur> (well, there are ways to force the issue but the result is guaranteed not to work)
12:15:33 <frerich_> I have ghc 7.4.2
12:16:12 <merijn> frerich_: Simple to check, if there is an Uninstaller under "/Library/Frameworks/GHC.framework/Versions/Current/Tools/" then you have platform and can use that to uninstall
12:16:39 <frerich_> merijn: Indeed, I do! Thanks!
12:18:05 <frerich_> merijn: I also noticed that I have various ghc versions beneath /Library/Haskell, do you know where that comes from?
12:18:16 <frerich_> ghc 7.0.3 from may 2011, hmm
12:18:31 <monochrom> hackage hosts base just for providing haddock link targets. not intended for oral use
12:20:17 <elliott> frerich_: why do you need new base?
12:20:20 <elliott> 7.4.2 is recent enough
12:20:35 <frerich_> elliott: It appears that forkFinally is not in my version.
12:20:42 <elliott> ah, okay
12:21:04 <elliott> frerich_: the docs give a definition for it, though
12:21:13 <elliott> so you could just define a local equivalent rather than going to the fuss of upgrading GHC if you'd like
12:21:33 <frerich_> elliott: Yeah, but I thought - I might just as well do a quick upgrade of the base package. And now look where I am… :-}
12:23:17 <monochrom> for your general sanity, do not "upgrade" what comes with GHC, even if you are allowed to
12:23:37 <monochrom> of course, unless you upgrade the whole GHC wholesale
12:25:17 * frerich_ sees that the haskell-platform package is 192MB, which is not only 128 +64 but also 0xC0; the byte in the run-length encoding of PCX files signaling an encoded sequence
12:25:20 <kamatsu> arg, douglas crockford, please be quiet.
12:25:44 * Lethalman .cabal here is 1.7gb :S
12:25:45 <kamatsu> his talks lately have been revolving around a very loose and poorly explained definition of a "monad"
12:26:23 <kamatsu> i hate it when people are misinformed. Most people have a tendency to think that people that confidently talk about stuff are an expert.
12:26:34 <monochrom> oh, sloppy descriptions of monad are cheaper than disk space
12:27:01 <monochrom> I hate that too. especially in #haskell
12:29:42 <BobbyMcLiar> Is it possible to have lenses for a data type with multiple constructors in the 'lens' package?
12:30:51 <elliott> BobbyMcLiar: yes
12:30:58 <elliott> you might want a prism or a traversal
12:31:10 <elliott> or even just a lens, if every constructor shares the field
12:31:30 <kamatsu> echo A monad is just a `sed "$RANDOM\!d" /usr/share/dict/words`
12:32:20 <ijp> is that valid sed?
12:32:31 <kamatsu> linenum!d gets a line from a file
12:32:38 <kamatsu> i use the \! because i'm on zsh
12:32:55 <ijp> oh sorry, the $RANDOM comes from the shell, duh
12:33:33 <ijp> sed is crazy complicated for what it is supposed to be
12:33:40 <kamatsu> "A monad is just a adjective"
12:33:50 <kamatsu> ah crap, grammar doesn't work
12:33:56 <kamatsu> oh well, it was a one line script
12:34:59 <geekosaur> sed is quite simple, actually.  it just doesn't "think" like people.  (see also:  tcl)
12:39:10 <monochrom> programmers do not want to entertain precise ideas. (although, they want to talk to the computer in a precise language.) how to know: consider self-selection. if they wanted to entertain precise ideas, they would have went into math or physics etc, not programming
12:39:50 <merijn> monochrom: Programming is very suited to entertaining imprecise ideas, though
12:40:10 <s_kilk> hi everyone, when using haskell-mode in emacs, is it possible to temporarily disable the tab-cycle / indentation behaviour, so that i can manually indent a line?
12:40:16 <merijn> Which is what makes it so neat
12:40:18 <monochrom> yes, this is why programming attracts a few mathematicians, though not so many
12:40:58 <monochrom> but bear in mind the majority of programmers chose programming because they hated math
12:41:00 <merijn> Ok, I'm clearly not grokking FRP sufficiently deeply, as I'm still confused how to go about proper design for an FRP program :\
12:41:48 <`nand`> the only FRP-ish stuff I've managed to begin to understand on a grand “how do I build an actual program using this?” scale is netwire
12:41:57 <`nand`> and of course, that's having only written trivial programs
12:42:14 <glaswegian> hey guys. I'm trying to use both hsc2hs and cpphs macros in the same file. is this a recipe for disaster or is there a sane way to do it?
12:42:36 <merijn> `nand`: I understand netwire-ish on a simple "how to do interaction" scale, but now that I'm thinking of an application that needs to persist some state I'm confused how to mix that with FRP
12:42:50 <glaswegian> preprocessing with cpphs first complains about #{else..., hsc2hs first complains about macro substitution
12:43:48 <`nand`> the gist of it as I understood is basically that netwire's steps would be fed off external input, and possibly doing IO or side effects or whatever needs doing in their underlying monad
12:43:51 <merijn> `nand`: i.e. most applications seem to loop a "WorldState -> WorldState" wire
12:44:22 <`nand`> well, the idea with netwire is that state is localized
12:44:36 <merijn> `nand`: Yes, but that means you can't persist it
12:45:06 <`nand`> well you can certainly initialize it; though I'd have to think about how to /save/ it
12:45:20 <merijn> `nand`: Mixing these two notions is exactly where I get stuck. But I'm not sure that means I don't understand how you're supposed to use FRP or whether FRP is unsuited to what I want
12:45:57 <merijn> I was thinking I might want to have a "Input -> Output" wire and have the worldstate in IO (using acid-state for persistence, for example)
12:45:57 <`nand`> merijn: maybe some abstraction could be made here for arrows with serializable local state? with the idea being that the entire system could be automatically serialized and deserialized through eg. something like acid-state
12:46:41 <merijn> `nand`: Maybe, but I'd need someone with more FRP experience to tell me whether that's even a worthwhile direction to go into, or whether I should just do things imperative style
12:46:43 <`nand`> but ask mm_freak
12:47:01 <merijn> `nand`: He's a slacker who didn't respond when I ping-ed him an hour or so back :p
12:47:17 <`nand`> maybe he's still thinking about it? D:
12:47:27 <jubos> hi does anyone have any experience using http-conduit for HTTPS connections?  I am running into issues due to the fact I don't have /etc/ssl/certs and not sure what I should put in there or if there is a way to disable checking for the cert store
12:47:45 <`nand`> though it'd seem like a reasonably common thing
12:48:08 <`nand`> eg. in the domain of FRP-ish video games
12:48:13 <merijn> jubos: Without checking for a cert the S part of HTTPS becomes basically useless
12:48:24 <`ramses> jubos: doesn't your distro provide ca-certs ?
12:48:24 <merijn> `nand`: That's exactly what I'm trying to toy with ;)
12:48:28 <`nand`> where the user may want to persist settings about his user interface
12:48:43 <merijn> `nand`: Or just worldstate in the case of multiplayer things
12:49:08 <jubos> merijn: it probably does, but I am not seeing it on the box (I don't control it, CentOS).  I don't really care too much about the security (just doing read only crawl)
12:49:43 <`nand`> merijn: the solution will probably involve lenses
12:50:18 <merijn> `nand`: netwire+lenses is my current "toy with" list, combined with maybe acid-state
12:50:37 <`nand`> I would be interested in a nice combination of the three
12:50:42 <merijn> Or rather, Control.Lens is, the older one I already understood :p
12:50:52 <frerich_> Hm, apparently the latest Haskell-platform package doesn't include base -4.6.0.0 :-/
12:50:53 <EarlGray^> Hello. Why everyone uses IORefs in introductions to OpenGL for handling callbacks?
12:51:06 <EarlGray^> (using GLUT/GLFW)
12:51:12 <shachaf> merijn: The new Control.Lens is coming out in a few days.
12:51:27 <shachaf> It's way better!
12:51:32 <shachaf> I don't know why I mentioned that.
12:51:49 <frerich_> shachaf: I guess because it's so easy!
12:51:52 <jubos> merijn: `ramses: curl doesn't seem to be having a problem.  Does it generate certs or do something built in?
12:51:57 <monochrom> the latest haskell platform is at ghc 7.4.2
12:52:03 <`nand`> there's, like, infinitely more profunctors in use now
12:52:08 <`nand`> clearly much better
12:52:10 <geekosaur> EarlGray^, you might show an example, but:  how do you pass mutable data across callbacks?
12:52:33 <merijn> EarlGray^: What else would you use?
12:52:46 <EarlGray^> geekosaur: is this approach good enough: http://dmytrish.wordpress.com/2013/01/12/haskell-opengl-animation-done-right/ ?
12:52:50 <geekosaur> callbacks are often pointles sif they can't modify mutable data.  IORefs are how you deal with mutable data
12:53:35 <EarlGray^> also I would like you all to review approach described there, are there any drawbacks, maybe, it has been already invented and so on
12:53:39 <`ramses> jubos: I don't know much about ssl stuff, but I know on my distro you need ca-certificates to have ssl working for many programs
12:53:42 <monochrom> you can use channels. I like channels, too
12:53:43 <tac-tics> geekosaur: I recently discovered the joys of having my entire application in a ReaderT State where State is just a bunch of IORef (Maybe a)'s
12:53:45 <geekosaur> EarlGray^, they're using STM which is much the same as using IO
12:54:07 <EarlGray^> yeah, but it's not global variables
12:54:12 <merijn> tac-tics: "IORef (Maybe a)", you mean MVar? :p
12:54:13 <EarlGray^> oach
12:54:26 <monochrom> IORef is not that "global" either
12:54:32 <EarlGray^> *it's not "global variables" anymore
12:54:35 <`nand`> merijn: doesn't reading an empty MVar block, as opposed to reading back a Nothing?
12:54:42 <geekosaur> ^^ so your complaint is not IORefs, it's using them via globals?
12:54:44 <merijn> `nand`: There's "tryRead"
12:54:46 <tac-tics> merijn: I suppose I could have meant that :)
12:54:46 <`nand`> oh, okay
12:55:03 <tac-tics> I just wish it was prettier to extract the IORefs in such code
12:55:21 <`nand`> surely the “global” part of IORef is using unsafePerformIO to get them at the top level
12:55:40 <geekosaur> in that case, the answer is probably because the globals solution is the easy one.  I personally avoid using globals for that, but I can understand why an opengl programming tutorial might want to focus on something more to the point than how to do mutable data properly in haskell
12:56:00 <`nand`> which you can do with unsafePerformIO . newTVarIO just as well
12:56:09 <monochrom> it is entirely possible to use callbacks and non-global IORef
12:56:15 <tac-tics> every time you unsafePerformIO, God kills a category
12:56:27 <simpson> EarlGray^: BTW, just as a suggestion, don't use GLUT at all.
12:56:32 <merijn> tac-tics: Don't we have uncountably many of those anyway?
12:56:43 <simpson> EarlGray^: SDL's got great Haskell bindings and is far simpler and easier to use as far as handling events.
12:56:46 <tac-tics> merijn: Depends on your foundations, I suppose.
12:56:56 <EarlGray^> yes, I don't use it anymore, as it is in my article
12:57:03 <`nand`> what's the previous stage of a category called? kittengory?
12:57:09 <monochrom> tac-tics: what about unsafeInterleaveIO? http://hpaste.org/77374 hehe
12:57:12 <simpson> Instead of callbacks, SDL asks you to loop on your own and read events when you want to handle them.
12:57:15 <merijn> `nand`: precategory, I think?
12:57:27 <ski> `nand` : perhaps "groupoidoid" ?
12:57:28 <tac-tics> `nand`: I beleive their called small categories ;)
12:57:32 <EarlGray^> simpson: It's just like my reinvented wheel :)
12:57:40 <`nand`> ski: semigroupoid?
12:57:42 <EarlGray^> I want to know what I've reinvented :)
12:57:45 <tac-tics> monochrom: I actually don't know wtf unsafeInterleaveIO does D:
12:57:45 <ski> perhaps
12:57:57 <tac-tics> someone explained it to me once, but it seemed nonsensical.
12:58:01 <monochrom> ok, test my programs there to find out
12:58:03 <simpson> EarlGray^: Ah, sure.
12:58:19 <`nand`> ski: oh, semicategory perhaps
12:58:41 * ski thinks `unsafeInterleaveIO' is as safe as `forkIO'
12:59:10 <`nand`> ski: semicategory seems to be the term for category without identities
13:00:00 <tac-tics> Call to rename IO  "UnsafeIO"
13:00:20 <tac-tics> I was trying to get HSLua to work today, and it kept crashing my IRC bot :(
13:00:32 <monochrom> great, then we have to rename "unsafePerformIO" to "unsafePerformUnsafeIO"
13:00:54 <monochrom> oh, that may be simply UnsafeFFI
13:01:12 <tac-tics> monochrom: Well, you could just call it performUnsafeIO, because it's safe relative to the monad you're using it is (which is to say, it's unsafe)
13:05:18 <ski> i think i'd prefer it if it were called something like `promisePureIO', where the meaning of "pure" (the conditions under which it's safe to use the operation) is spelled out
13:09:46 <johnw> you mean, IO with no side effects?
13:10:05 <ciaranm> what's a side effect?
13:11:50 <johnw> hmm
13:12:24 <monochrom> I no longer say that doing I/O is a side effect
13:12:30 * Walther just registered account to Euler, will start seriously learning haskell from now on
13:12:47 <Walther> so prepare yourselves for answering plenty of silly questions in the future :P
13:12:50 * Taneb prefers Rosalind
13:12:59 <monochrom> but I will say, such-and-such procedure does I/O, such-and-such other procedure doesn't
13:13:22 <monochrom> no, I will just prepare for not answering
13:13:30 <johnw> lol
13:13:46 <monochrom> your questions are not silly. I have no interest in Euler
13:14:33 <shachaf> "project euler" leads to asking questions that won't help you learn Haskell.
13:14:49 <merijn> I wonder where this idea that Project Euler is good for learning programming came from
13:15:08 <derdon> merijn: not good for learning, but maybe for excercising
13:15:11 <lispy> it's good for learning dynamic programming :)
13:15:13 <merijn> It's neat for code golfing, but even the over done cliche of an IRC bot would be a better way to learn programming
13:15:27 <lispy> (dynamic programming a successful way to solve many of the problems there)
13:15:32 <merijn> derdon: Also not, because PE has you do many things which don't really help you exercise design skills
13:15:33 <int-e> lispy: and pell equations
13:15:55 <derdon> merijn: but it makes you learn more about math!
13:15:59 <Lethalman> you learn dynamic programming just by reading what it is, don't even have to write a solution
13:16:10 <ciaranm> derdon: that's not maths!
13:16:45 <ciaranm> you won't learn much from Euler. write an rpn calculator, a compiler, and a constraint solver.
13:17:14 <quchen> Compiler seems to be a very good exercise to learn Haskell. Worked for SPJ.
13:17:32 <merijn> Writing a unifier would help grok the type system :)
13:17:59 <ciaranm> maybe not a haskell compiler...
13:18:03 <merijn> quchen: It's not even such a silly idea, haskell is excellent for writing compilers, ADT make for great AST's and parsec helps parse
13:18:14 <ciaranm> a compiler is <1000 lines of haskell
13:18:18 <merijn> Just look at "Write Yourself a Scheme in 48 hours"
13:18:28 <lispy> Implementing this paper is fairly easy (it's meant as a tutorial) and helps you grok lambda calc and dependent types: http://www.andres-loeh.de/LambdaPi/
13:18:36 * Ralith thinks parsec is rather overrated
13:18:50 <lispy> Ralith: Writing a mini-parsec is a great learning tool though.
13:18:54 <merijn> lispy: I think LambdaPi was actually pretty tricky (granted I only read, didn't implement)
13:18:55 <Ralith> oh, definitely
13:18:57 <lispy> Ralith: Otherwise , I tend to agree
13:19:04 <merijn> Ralith: What would you use, then?
13:19:13 <ski> quchen : how about writing a Haskell compiler in Haskell, to learn it, like Meacham ? :)
13:19:16 <lispy> merijn: happy + alex, if you know the grammar
13:19:17 <t7> regex
13:19:24 <Ralith> merijn: from the set of haskell libraries? Trifecta, probably, but I wouldn't be terribly happy about it.
13:19:38 <johnw> in CL, there is a technique of returning Parser (<closure type>) as the result of parsing rules, so that the final result is directly callable, rather than constructing an AST that gets evaluated.  Is this practice used in Haskell too?
13:19:43 * Ralith likes nice predictable context-free grammars
13:19:45 <ciaranm> parsec is a good introduction to applicatives
13:19:53 <lispy> happy is a GLR parser generator, so it handles most language definitions just fine.
13:19:55 <quchen> ski: That would certainly teach me some Haskell, but I think it's a bit of an overkll. I think I would spend more time reading about compilers. A Scheme interpreter is nice though.
13:19:58 <ski> (see <http://repetae.net/computer/jhc/jhc.shtml#the-story-of-jhc>)
13:20:18 <shachaf> ski: No title or author?
13:20:32 <Ralith> johnw: I haven't seen it, but there's no particular reason you couldn't do it.
13:20:34 <yitz> as a practical parsing tool, i like attoparsec
13:20:36 <ski> quchen : make sure to implement at least tail-calls, and preferably continuations as well
13:21:10 <quchen> Also I have to learn Scheme first ;-)
13:21:15 <tac-tics> lispy: see also Conor's http://strictlypositive.org/Easy.pdf
13:21:17 <ijp> if you do hygienic macros as well, you'll be more complete than most other "scheme" implementations
13:21:22 <ski> shachaf : for you : "The story of jhc" by John Meacham
13:21:30 <yitz> shachaf: that link is to the website of john meacham, the author of jhc.
13:21:46 <shachaf> It just seemed so uncharacteristic of ski.
13:21:56 <yitz> ah i see :)
13:22:50 <edwardk> shachaf loves adding titles and authors.
13:22:52 <edwardk> its so easy
13:22:56 <yitz> @google the story of jhc
13:22:58 <lambdabot> http://tulsage.wordpress.com/2011/09/07/jhc-his-story-after-vietnam/
13:22:58 <lambdabot> Title: JHC – His story after Vietnam | Tulsage.com
13:23:11 <yitz> umm no
13:23:49 <ciaranm> how do i make my haskell code run fast? :(
13:24:17 <simpson> ciaranm: How is it slow?
13:24:19 <Ralith> hang a carrot in front of it
13:24:30 <yitz> ciaranm: mention java
13:24:33 <quchen> Can Haskell run fast?
13:24:33 * ski misread "adding" as "addling"
13:24:35 <johnw> prefix all code with ^?
13:24:49 <Ralith> haha
13:24:52 <ciaranm> it's only marginally faster than the java implementation...
13:25:04 <yitz> postfix all identifiers with #
13:25:04 <Lethalman> java is not slow
13:25:26 <ciaranm> compared to c++ it is, at least for the kind of thing i'm doing...
13:26:49 <Lethalman> ciaranm, if your haskell program is faster than the java implementation, that's already a good situation imo
13:27:25 <Lethalman> ciaranm, for everything else... profile :)
13:27:37 <ciaranm> Lethalman: not really, since i don't particularly want to spend three years doing this stuff in c++ rather than haskell :P
13:27:50 <quchen> ciaranm: Parallelize! :-)
13:27:52 <frerich_> Hm, how do you debug 'thread blocked indefinitely in an MVar operation' errors?
13:28:32 <ciaranm> quchen: did that already on the c++ side. but i can't really claim i've got a 100x speedup out of haskell when the sequential implementation is crap...
13:28:38 <Walther> Uh, how to make this work
13:28:40 <Walther> sumMultiples a b c = sum [x | x <- [(min a b)..c], (x `mod` a == 0) or (x `mod` b == 0)]
13:29:04 <Lethalman> Walther, || instead of or
13:29:13 <quchen> :t or
13:29:14 <lambdabot> [Bool] -> Bool
13:29:31 <quchen> > or [True, False, False]
13:29:32 <Walther> so that i take the sum of a list that takes all numbers from (min a,b) to c, so that the numbers are either multiples of a or b
13:29:32 <lambdabot>   True
13:29:38 <quchen> Or is for lists.
13:29:41 <Walther> but they don't have to be both
13:29:42 <quchen> || is the binary operator.
13:30:16 <tac-tics> @hoogle (a -> Bool) -> (a -> Bool) -> (a -> Bool)
13:30:16 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
13:30:16 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
13:30:16 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
13:30:22 <lispy> tac-tics: is that the same paper in a different format?
13:30:59 <tac-tics> lispy: heh, it might be.
13:31:15 <quchen> Walther: a || b is "at least one of a, b is True".
13:31:22 <quchen> Sounds like what you're looking for.
13:31:34 <Walther> ...i still need to parse out duplicates
13:31:55 <Walther> quchen: yup, || solved it
13:32:00 <Walther> now to work on those duplicates
13:32:07 <Walther> as in, all x must be unique
13:32:26 <quchen> Duplicates? That list won't contain duplicates
13:32:37 <Walther> oh wait
13:32:39 <quchen> You're feeding a single list to x
13:32:53 <Walther> somehow sumMultiples 1 1 2 still returns 3
13:33:10 <quchen> Maybe remove the sum and see how the list looks like
13:33:34 <Walther> hm.
13:33:50 <Walther> ah, got it
13:34:05 <WaffleCat> what is the name of the <+> operator?
13:34:24 <Walther> sumMultiples a b c = sum [x | x <- [(min a b)..(c-1)], (x `mod` a == 0) || (x `mod` b == 0)]
13:34:27 <Walther> pretty <3
13:34:28 <WaffleCat> or is there such a thing?
13:34:31 <johnw> :t (<+>)
13:34:32 <lambdabot>     Ambiguous occurrence `<+>'
13:34:33 <lambdabot>     It could refer to either `Control.Arrow.<+>',
13:34:33 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
13:34:41 <johnw> :t (Control.arrow.<+>)
13:34:42 <lambdabot> Couldn't find qualified module.
13:34:45 <johnw> :t (Control.Arrow.<+>)
13:34:46 <lambdabot> ArrowPlus a => a b c -> a b c -> a b c
13:35:01 <WaffleCat> oh neato!
13:35:04 <WaffleCat> thanks!
13:35:15 <byorgey> WaffleCat: uh, where did you see this <+> ?
13:35:31 <byorgey> if you saw it in xmonad, it is unrelated to the one in Control.Arrow
13:35:34 <WaffleCat> byorgey: While reading the source of xmonad
13:36:05 <byorgey> in general anyone is free to define operators to mean whatever they want, there is not always a "standard" definition
13:36:23 <byorgey> WaffleCat: in xmonad, I believe it is simply a synonym for 'mappend' from the Monoid type class
13:37:12 <geekosaur> ^^
13:37:58 <geekosaur> (originally specialized to ManageHook but later just made an alias for straight mappend)
13:38:57 <WaffleCat> byorgey: ah - how would you guess  that? From just glancing at, say, a contrib module like this one http://xmonad.org/xmonad-docs/xmonad-contrib/src/XMonad-Config-Desktop.html I don't see an import statement with the word monoid in it
13:40:23 <geekosaur> the best way to do it is to look up (<+>) on hayoo and then check a reference that looks like a relevant package.  although holumbus.fh-wedel.de seems to be down at the moment :(
13:41:09 <geekosaur> (you won't see an import of Data.Monoid; it's coming from XMonad.Core which is re-exported by XMonad)
13:41:12 <`ramses> when profiling, I assume the "total alloc" is the sum of all allocations made. Is it also possible to get the maximum size the heap ever reached?
13:41:13 <monochrom> the next best way is to ask here BUT SAY WHERE YOU SAW IT
13:41:27 <absence> how bad is 30 % gc time and 50 % productivity?
13:41:53 <monochrom> I think that's called maximum residency
13:42:10 <monochrom> and part of the profile report
13:42:48 <tgeeky_> The maximum space actually used by your program is the "bytes maximum residency" figure. This is only checked during major garbage collections, so it is only an approximation; the number of samples tells you how many times it is checked.
13:43:53 <tgeeky_> maybe he was sking of those numbers (30,50) % are bad without knowing more information?
13:43:57 <tgeeky_> asking*
13:44:29 <`ramses> ah, it's not in the profiling report, but in the thing you get with -sstderr
13:44:57 <monochrom> oh, sorry, I have always only used -sstderr
13:45:07 * monochrom does not trust the profiler
13:45:21 <tgeeky> don't start something :(
13:45:39 * tgeeky trusts monochrom, but not transitively
13:46:18 <`ramses> it's the first time I use it, but my tree traversal seems to be leaking massive amounts of memory :s
13:46:26 <edwardk> ?
13:47:43 <edwardk> `ramses: is this a lens traversal or the term used in a more generic sense?
13:47:58 <`ramses> no, general case
13:48:12 <`ramses> I traverse a Stern-Brocot tree
13:54:49 <edwardk> ah
13:54:51 <magicman> @type scanl
13:54:52 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
13:57:08 <zhulikas> can I pattern match Ratio?
13:57:19 <zhulikas> > Data.Ratio.% 1 2
13:57:20 <lambdabot>   <hint>:1:1: parse error on input `Data.Ratio.%'
13:57:25 <zhulikas> > 1 % 2
13:57:27 <lambdabot>   Not in scope: `%'
13:57:27 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
13:57:34 <zhulikas> > 1 R.% 2
13:57:36 <lambdabot>   1 % 2
13:57:37 <zhulikas> this.
13:57:42 <magicman> > case 1 R.% 2 of {a :% b -> a}
13:57:43 <lambdabot>   Not in scope: data constructor `:%'
13:57:43 <lambdabot>  Perhaps you meant one of these:
13:57:43 <lambdabot>    `:+...
13:57:46 <zhulikas> matching against (a % b) doesn't work
13:57:50 <magicman> > case 1 R.% 2 of {a R.:% b -> a}
13:57:51 <lambdabot>   Not in scope: data constructor `R.:%'
13:58:06 <magicman> @info Ratio
13:58:06 <lambdabot> Ratio
13:58:32 <magicman> Huh. Looks like you can't.
13:58:39 <zhulikas> ok
13:58:45 <zhulikas> strange, this isn't a complex type
13:58:54 <magicman> But numerator and denominator are the projection functions.
13:59:00 <zhulikas> yes.
13:59:03 <zhulikas> I'll rely on those then
13:59:23 <quchen> Is there a reason % isn't exported?
13:59:36 <magicman> To avoid constructing things like 2 :% 4, I guess.
13:59:53 <magicman> The library may use the fact that it's in lowest-denominator form in its algorithms.
14:00:04 <quchen> Oh wait, :%
14:00:08 <quchen> What's that?
14:00:12 <monochrom> > 2%4
14:00:13 <lambdabot>   Not in scope: `%'
14:00:13 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
14:00:20 <quchen> In any case, it also doesn't work for Data.Ratio.%
14:00:32 <magicman> 2 % 4 will give 1 :% 2.
14:00:40 <monochrom> Data.Ratio hides the constructor. you cannot pattern-match it.
14:00:44 <magicman> > denominator (2 R.% 4)
14:00:46 <lambdabot>   2
14:01:10 <quchen> Ah, % isn't the data constructor but a wrapper around it so it can cancel
14:01:12 <quchen> Makes sense
14:01:16 <magicman> Yep.
14:01:33 <tgeeky> +1 knowledge
14:01:41 <monochrom> this is an example of "smart constructor for upholding a data invariant"
14:01:58 <magicman> Though I don't think there's any conceptual reason why pattern-matching shouldn't be allowed, it's just that exposing the constructor at all exposes it for both construction and destruction.
14:02:58 <quchen> So :% isn't exported so that you can't create 2 :% 4, the downside being losing pattern matching, and % can't be matched on because it's just a function
14:02:59 <monochrom> Data.Ratio is also rather old. if it were rewritten today, it would still hide the constructor, but also give you a view pattern option
14:03:17 <magicman> quchen: Exactly.
14:03:30 <quchen> What's a view pattern option?
14:03:44 <jang> I think there's kind of a conceptual reason: there's no real reason (except, perhaps, for internal algorithms) to prefer a fraction to be expressed in its simplest common form
14:04:01 <`ramses> quchen: http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
14:04:04 <elliott> ratio :: Iso (Ratio a) (Ratio b) a b
14:04:09 <elliott> er, (a,a) (b,b)
14:05:01 <ciaranm> someone should rewrite everything using shiny new toys and correct definitions and no partial functions and ponies
14:05:01 <Taneb> elliott, that's not a valid Iso
14:05:11 <Taneb> consider (2, 4)
14:05:26 * ski . o O ( "The OCaml language -- Chapter 7  Language extensions -- 7.9  Private types" <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual021.html#toc76>)
14:05:39 <monochrom> it would define another data type (say T) with constructor exposed to you, or just use the tuple type. then it would give you a function Ratio a -> T a, or Ratio a -> (a,a)
14:05:48 <elliott> Taneb: that doesn't stop edwardk :P
14:05:48 <monochrom> you can use that function in view patterns
14:06:16 <aluink> I don't understand why line 17 has type errors in this paste (http://hpaste.org/80893)
14:06:33 <aluink> btw, Data.Json.Builder gives me instance Value Int
14:06:59 <elliott> aluink: because k :: Value a => [(BS.ByteString,a)]
14:07:03 <elliott> means that you work for all Value instances "a"
14:07:07 <elliott> in fact you only work for the Value instance "Int"
14:07:12 <quchen> Interesting, those view patterns.
14:07:28 <c_wraith> elliott: it's worse than that.  gender isn't an Int
14:07:35 <c_wraith> Oh, so it is.
14:07:36 <`ramses> quchen: have a look at pattern guards as well
14:07:41 <c_wraith> Ok, it's even *worse*
14:07:45 <elliott> c_wraith: Names aren't integers either!
14:07:52 <elliott> aluink must live in a very strange world.
14:08:06 <aluink> yeah, originally I had varying types. But to investigate I made them all Int.
14:08:21 <aluink> elliott: how am I only working on Int?
14:08:37 <ski> aluink : `MyType' has fields of type `Int'
14:08:39 <elliott> k :: Value a => [(BS.ByteString,a)]
14:08:47 <merijn> aluink: Your type says a, your code says "Int"
14:08:50 <elliott> This means: "you can use k as [(BS.ByteString,a)] for any a that is a Value instance"
14:08:53 <ski> so `n',`a',`g' bound at `MyType n a g' all have type `Int'
14:08:55 <elliott> so you work as [(BS.ByteString,String)]
14:08:59 <quchen> `ramses: As in case | foo == bar = ...?
14:09:00 <elliott> and [(Bs.ByteString,Char)] etc.
14:09:04 <elliott> (just guessing instances of Value here)
14:09:11 <elliott> But you don't: you only work with one *specific* a -- Int.
14:09:16 <aluink> ok, let me pose this question. I'd like to make MyType hold Ints and ByteStrings, both of which are instances of Value. How can I do this?
14:09:18 <elliott> That's not what you're claiming with k's type signature.
14:09:19 <ski> aluink> :t toJson
14:09:24 <merijn> I suspect aluink thinks typeclasses work like ExistentialQuantification
14:09:35 <aluink> merijn: perhaps...
14:09:38 <elliott> aluink: Probably [("name", toJson n),("age", toJson a),("gender", toJson g)]
14:09:43 * aluink goes to lookup ExistentialQuantification
14:09:50 <elliott> But I don't know what's idiomatic with the library you're using, only how the type system works :)
14:09:57 <merijn> aluink: Don't use that here!
14:09:58 <elliott> aluink: You don't want ExistentialQuantification.
14:10:03 <shachaf> aluink: When you're confused about type classes, ExistentialQuantification *sounds* like what you want. But it's not.
14:10:06 <aluink> oh, no I don't
14:10:13 <`ramses> quchen: http://www.haskell.org/haskellwiki/Pattern_guard
14:10:22 <aluink> yikes...too fast. trying to catch up
14:10:24 <`ramses> quchen: it's pattern matching inside guards
14:10:39 <monochrom> I agree with [("name", toJson n),("age", toJson a),("gender", toJson g)]. KISS
14:10:40 <merijn> aluink: elliott's suggestion is best
14:10:52 * ski is waiting for aluink to answer his question
14:11:08 <monochrom> the whole point of Value is toJson. so why not just toJson
14:12:33 <aluink> gah, and NOW the wife calls me. ok. thanks for the help. at risk of being rude. i've g2g. i appreciate it
14:14:58 <hpaste> “`ramses” pasted “Space leak” at http://hpaste.org/80896
14:15:16 <`ramses> could someone help me figure out why the enc function in that paste is leaking memory?
14:15:29 <hpaste> aluink pasted “JSON” at http://hpaste.org/80897
14:15:29 <Walther> Why does this not work correctly and takes an awful lot of time to calculate?
14:15:32 <Walther> sumEvenFibo a = sum $ [x | x <- map fibo [1..a], x `mod` 2 == 0, fibo x <= a]
14:15:39 <`ramses> it traverses a tree, and if the traversal is deep, memory builds up
14:16:08 <Walther> but if i remove the last condition (fibo x <= a) it becomes faster and outputs correctly
14:16:44 <Walther> assume fibo is a function that takes parameter n and returns the nth fibonacci's number
14:16:46 <hpaste> “`ramses” annotated “Space leak” with “Space leak, profiling report” at http://hpaste.org/80896#a80898
14:17:16 <Eduard_Munteanu> readMVar's description says "This function is atomic only if there are no other producers (i.e. threads calling putMVar) for this MVar.". Does this mean it's atomic only if there's a single writer?
14:17:47 <Eduard_Munteanu> Also, what do I do if I want multiple writers?
14:18:16 <c_wraith> readMVar isn't atomic in any way.
14:18:27 <c_wraith> The documentation is a bit misleading, there
14:18:38 <c_wraith> in the absence of other writers, though, it's guaranteed to not block.
14:18:46 <merijn> Eduard_Munteanu: It means "someone could have written to the MVar after you get the value out, so putting back will block you"
14:18:54 <Eduard_Munteanu> Ok, now I'm really confused how all this concurrency stuff works in Haskell.
14:19:14 <c_wraith> MVar is really simple. It has two basic operations: put and take
14:19:27 <merijn> Eduard_Munteanu: readMVar is really just "readMVar v = do { x <- takeMVar v; putMVar v x; return x }
14:19:29 <c_wraith> if you put into an empty MVar or take from a full one, it succeeds immediately
14:19:36 <Eduard_Munteanu> I just want some state shared by two threads.
14:19:44 <c_wraith> if you put into a full one, it blocks. If you take from an empty one, it blocks
14:19:52 <Walther> ideas?
14:20:00 <merijn> Eduard_Munteanu: You probably want IORef and/or TVar
14:20:33 <merijn> Eduard_Munteanu: The point of MVar is that it's a (potentially empty) box, and once it's full writing to it will block
14:20:39 <Eduard_Munteanu> Is IORef atomic in the presence of multiple threads?
14:20:51 <c_wraith> what do you mean by "atomic"?
14:20:59 <Eduard_Munteanu> merijn: looks more like some sort of channel/fifo to me
14:21:10 <c_wraith> reading an IORef and writing an IORef are each atomic
14:21:18 <c_wraith> no composition of those operations is atomic
14:21:19 <Eduard_Munteanu> c_wraith: I don't get partially-updated (undefined?) values.
14:21:20 <merijn> Eduard_Munteanu: MVar == bidirectional fifo of size 1
14:21:29 <merijn> Eduard_Munteanu: No, never
14:21:45 <Eduard_Munteanu> Ah, so a plain IORef should do.
14:21:49 <merijn> Eduard_Munteanu: You can only get ordering issues (i.e. read-before-write, and write-before-read)
14:22:08 <merijn> Eduard_Munteanu: But all reads and writes are atomic (same goes for MVar)
14:22:11 <ciaranm> is IORef sequentially consistent?
14:22:18 <merijn> ciaranm: Yes
14:22:22 <Eduard_Munteanu> I see.
14:22:47 <Eduard_Munteanu> But let's go further so I get things straight... how do you do locking, generally? Say, a critical section.
14:22:53 <elliott> MVars
14:22:55 <c_wraith> MVars are the locking primitive
14:22:58 <merijn> Eduard_Munteanu: The problem with readMVar is (as I just said) it's essentially just "take + put", if someone puts after your take but before put your put will block
14:22:59 <c_wraith> in GHC, anyway
14:23:00 <elliott> take an mvar to lock
14:23:02 <elliott> put it back once you're done
14:23:18 <Walther> halp, anyone? :)
14:23:22 <shachaf> mvars are so easy
14:23:22 <Eduard_Munteanu> Something like MVar () ?
14:23:30 <c_wraith> preferably using withMVar, to handle exceptions nicely
14:23:30 <monochrom> yes
14:23:48 <Eduard_Munteanu> Ah, thanks, that looks alright then.
14:23:49 <merijn> Eduard_Munteanu: Yes, and then do take/put at start/end to lock/unlock (or use withMVar)
14:24:06 <shachaf> Walther: I would help you but I'm boycotting "project euler" questions.
14:24:11 <shachaf> Sorry. :-(
14:24:20 <Eduard_Munteanu> Heh.
14:24:25 <merijn> modifyMVar also works, as long as all access use modifyMVar (or are nicely behaved)
14:24:33 <shachaf> Walther: My advice is to question your assumptions.
14:24:40 <crclark> Walther: fibo x <= a is calculating the fibonacci of a fibonacci. Is that what you want?
14:24:51 <ciaranm> like the assumption that project euler is a good idea
14:25:48 <Walther> I want to make sure the biggest number x in the list is the biggest fibonacci number under or equal to a
14:26:09 <merijn> Eduard_Munteanu: My personal heuristic if MVar for blocking/mutual exclusion, IORef/TVar for shared state that is potentially updated (but where the ordering of updates is irrelevant)
14:26:16 <Walther> and my main question is just - why does that exact last part break the code completely?
14:26:42 <ciaranm> Walther: that's a bad way of calculating fibonacci numbers
14:26:49 <merijn> Although TVar would work even if the ordering of updates *is* important :p
14:27:12 <crclark> Walther: the xs are already fibonacci numbers, because they are bound as "map fibo [1..a]"
14:27:13 <Walther> ciaranm: er, that line i pasted didn't even involve the fibo function
14:27:27 <ciaranm> Walther: it's still a bad way.
14:27:33 <shachaf> And yet I'd guess that ciaranm is correct.
14:28:02 <ciaranm> Walther: you can calculate the $blah of the first n fibonacci numbers satisfying $blah in constant time
14:28:04 <Eduard_Munteanu> I see.
14:28:21 <Walther> ciaranm: yes, they are. I just need to make sure that the biggest number is not a-th fibo but the fibo that is at maximum a
14:28:34 <Walther> ciaranm: sure, i'm not looking for an optimal solution here
14:28:41 <Walther> mainly trying to learn haskell
14:28:47 <ciaranm> write a compiler
14:28:52 <ciaranm> project euler is silly
14:28:54 <frerich_> Hm, I'm reading from a Chan; using readChan works fine, but getChanContents yields 'thread blocked indefinitely in an MVar operation'. Does anybody know why that would be? Is it a bug? My understanding was that getChanContents would get a list of all elements in the chan.
14:29:07 <Walther> ciaranm: for my first project in haskell? a bit too complicated tyvm
14:29:19 <crclark> Walther:  you want to check that x <= a, not fibo x <= a, as far as I understand your problem.
14:29:20 <ciaranm> Walther: you'll be surprised...
14:29:21 <merijn> frerich_: Did you close the write side of the channel?
14:29:54 <merijn> frerich_: Is the Chan accessible from another thread?
14:30:16 <frerich_> merijn: Hm, I see that getChanContents calls readChan recursively; it may be that the other thread, which used to write to the channel, terminated during the recursion.
14:30:17 <Walther> ciaranm: oh wow, i just missed the obvious, the list i'm building is already the fibo numbers...
14:30:25 <quchen> Walther: ProjectEuler is fine, just don't get lost in it. After doing 10 of the first 20 problems it'll not teach you much anymore.
14:30:32 <monochrom> 15 minutes since the beginning of question without anyone seeing actual code (of fibo). let us see if it gets longer
14:30:36 <merijn> frerich_: "thread blocked indefinitely in an MVar operation" == no other thread is capable of writing to this MVar you're blocked on
14:30:38 <ciaranm> Walther: if you have a list of fibonacci numbers, you're Doing It Wrong
14:30:56 <Walther> quchen: perhaps - but i'd like to also mention that i've literally written sub 20 lines of haskell in my life, so i have to start with something
14:30:59 <Eduard_Munteanu> Walther: you probably want stuff like http://www.haskell.org/haskellwiki/99_questions instead. Or perhaps LYAH's got some, dunno.
14:31:03 <ciaranm> Walther: if you have recursion, you're Doing It Terribly Wrong
14:31:11 <merijn> frerich_: getChanContents just infinitely reads from the Chan, so if the write side terminates and the Chan gets garbage collected that exception can happen
14:31:23 <quchen> Eduard_Munteanu: LYAH doesn't have practice problems iirc. :-(
14:31:26 <merijn> frerich_: There's no way to "close" a Chan so that getChanContents terminates
14:31:34 <frerich_> merijn: Hm
14:31:34 <Walther> Again: I don't care for 100% optimization yet
14:31:49 <Walther> i've written <20 lines of haskell, i still need to get used to it as a language
14:31:51 <ciaranm> Walther: this is not about optimisation. this is about using a good algorithm.
14:31:55 <Eduard_Munteanu> Also... http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/index.html
14:32:11 <Eduard_Munteanu> But I'm not sure how much you already know.
14:32:13 <Walther> ciaranm: i'll improve that while improving my skills in haskell. Gotta learn to walk before running.
14:32:15 <ciaranm> just sit down and write a compiler. it takes less than a weekend and is under 1000 lines of code.
14:32:25 <frerich_> merijn: I suppose I could use isEmptyChan and then readChan myself, but I see isEmptyChan is deprecated in favor of STM.TChan, so I'll look at that.
14:32:31 <quchen> ciaranm: This is about Walther writing his first list comprehensions. It's not about efficiency, not about finding the right solution, not about ProjectEuler.
14:32:49 <ciaranm> doing fibonacci properly won't improve your programming skills, since it's not a programming question...
14:32:52 <merijn> frerich_: You could use readChan + forever and then use async exceptions to close the channel
14:33:12 <Walther> the sole reason for me to select euler as a source of exercises was that well, it has a bunch of generic exercises that can be solved in any language
14:33:23 <merijn> frerich_: in GHC you can throw exceptions to a specific thread, so when the write finishes it could throw "done writing" to the reading thread so it know to abort
14:33:26 <Walther> and LYAH doesn't have exercises
14:33:41 <quchen> Walther: RWH however does. Have you looked at those?
14:33:58 <monochrom> but RWH is not at beginner level
14:33:59 <merijn> frerich_: Similarly, you could replace Chan with "(Chan a, IORef Bool)", and then set the IORef to True when the writer is done
14:34:01 <Walther> quchen: I've read the introduction of RWH, not much more, will look into that
14:34:13 <Eduard_Munteanu> Surely there are some exercises around... I mean, even Agda's got some nowadays. :)
14:34:15 <merijn> frerich_: TChan and friends are also an option, many solutions here :)
14:34:31 <Eduard_Munteanu> (we don't really have to make up our own anymore)
14:34:36 <Walther> monochrom: I've written some python and some java though, so I'm not a *complete* beginner, I have hopes that RWH doesn't start from too complicated things
14:34:47 <quchen> monochrom: The chapters aren't, but some of the exercises given helped me as a beginner. It's hard to find the good ones as a beginner though, that may be true.
14:35:05 <qasd> I want to turn my computer into a server. And I want to implement a protocol to speak to it. What do I need to do to connect to my computer? Obv I need an IP address and a port. But how do I connect to that directly from another computer? how do i establish a connection?
14:35:37 <quchen> Walther: Python and Java won't help you here. What's that quote - "most people can pick up Haskell in a week, programmers take longer"?
14:35:39 <crclark> Walther: there are good homework assignments for Haskell here: http://www.cs.rit.edu/~mtf/teaching/20113/psfp/assignments.html
14:35:45 <merijn> qasd: Google "unix socket programming", there's a bunch of intro's that summarise much better than we can
14:35:57 <Walther> crclark: woo, thanks!
14:35:58 <Eduard_Munteanu> qasd: that depends on what you want to "say" to it. Are you familiar with TCP's basics?
14:36:16 <merijn> qasd: (Assuming your server will be running linux or something, if you run windows it will mostly be the same, but I can't tell you where to start)
14:36:27 <hpaste> zhulikas pasted “http://projecteuler.net/problem=57” at http://hpaste.org/80900
14:36:44 <zhulikas> so, this is a working solution for problem #57...
14:36:58 <zhulikas> but I dislike the way I solve it
14:37:13 <zhulikas> this is basically a very ineffective recursion
14:37:29 <zhulikas> can anyone give me suggestions on how to optimize this to save intermediate values?
14:37:41 <qasd> merijn: does windows somehow use unix sockets?
14:37:42 <zhulikas> not sure if I am correct, but I want to memoize this 'f' function
14:38:05 <shachaf> What's with all the "project euler"?
14:38:21 <zhulikas> ah, it's just a place full of programming problems
14:38:26 <fmap> i love project euler
14:38:35 <zhulikas> yeah, me too
14:38:36 <Eduard_Munteanu> zhulikas: first, try moving f' to the toplevel.
14:38:40 <ciaranm> shachaf: ruby programmers do it and think they're learning maths, like how they think ruby teaches them to program
14:38:46 <merijn> qasd: Windows uses sockets too, the haskell code should be the same, but most intro's explain the interface using C
14:38:53 <zhulikas> sure, it isn't necessary for it to be in where block, ok...
14:39:02 <glguy> shachaf: It's for math people; you wouldn't understand :-p
14:39:15 * ciaranm glares at glguy 
14:39:20 <zhulikas> Eduard_Munteanu, I imagine it has to be a list of values so it could rely on existing calculations
14:39:33 <glguy> shachaf: call off your dog!
14:39:34 <zhulikas> like that example on memoization and fibonacci sequence
14:39:57 <ciaranm> memoisation is a stupid way of doing fibonacci
14:39:59 <qasd> oh
14:40:06 <Eduard_Munteanu> zhulikas: yeah, that'll definitely improve sharing. You also want to force the computation in a particular order.
14:40:31 <Eduard_Munteanu> ciaranm: yeah, but it's pretty useful as a Haskell exercise.
14:40:44 <monochrom> zhulikas: perhaps http://www.haskell.org/haskellwiki/Dynamic_programming_example helps you memoize
14:42:27 <zhulikas> I was kinda hoping for immediate suggestions for improvements...
14:42:47 <zhulikas> like 'rewrite your function like this: '
14:42:49 <zhulikas> :D
14:42:53 * Eduard_Munteanu didn't bother reading the problem statement though
14:43:33 <monochrom> yes, rewrite f' so it is an array or it reads an array. which is what I said in the URL
14:43:42 <zhulikas> yes.
14:43:44 <monochrom> perhaps f too
14:44:26 <zhulikas> so can I call that memoization if I just rely on runtime saving up already computed values in a list?
14:44:38 <zhulikas> or is it just glory of the haskell
14:44:38 <zhulikas> :)
14:44:42 <frerich_> Hm, is there an existing function like 'IO Bool -> IO a -> IO [a]' which collects the results of the second action while the first action yields true?
14:44:44 <Eduard_Munteanu> That's the idea, pretty much.
14:44:58 <zhulikas> cool
14:45:01 <monochrom> I don't know. I am living among people who can't agree on terminology
14:45:06 <zhulikas> so I've used memoization in my code before!
14:45:16 <zhulikas> heh, then I'll try to not use that term again :D
14:45:25 <zhulikas> let's just call it 'optimized code'
14:45:33 <monochrom> some people say, memoization means the compiler does it for you, your own array arrangement doesn't count. some other people say, it counts
14:45:39 <shachaf> frerich_: Nope.
14:45:59 <ciaranm> see, there are interesting things about continued fractions. and if you do that project euler exercise, you won't find out what they are. you don't need to do any iteration or recursion or looping to get the answer...
14:46:09 <zhulikas> if it didn't count, my function would work fast already
14:46:14 <merijn> frerich_: monad-loops?
14:46:35 <zhulikas> ciaranm, can I get more clues?
14:46:47 <monochrom> and there are also people who say: only your own array (or other containers) arrangement counts, the compiler doesn't count
14:46:56 <ciaranm> zhulikas: get a maths degree, then do some algebraic number theory!
14:47:01 <zhulikas> :D
14:47:20 <frerich_> merijn: HA! whileM it is, thanks! I'm relying too much on Hoogle (which doesn't search most packages)
14:47:48 <shachaf> frerich_: Ah, true, in C.M.Loops
14:48:44 <merijn> <3 monad-loops
14:48:52 <monochrom> it is so easy
14:50:56 <m0h3n> hi there
14:51:06 <m0h3n> is there a haskell bot here ?
14:51:21 <`ramses> @bot
14:51:21 <lambdabot> :)
14:51:29 <merijn> > "of " ++ " course"
14:51:31 <lambdabot>   "of  course"
14:51:38 <merijn> damn, I fail at spaces :p
14:52:05 <m0h3n> thanks
14:52:07 <ciaranm> > repeat "MONKEYS!"
14:52:08 <lambdabot>   ["MONKEYS!","MONKEYS!","MONKEYS!","MONKEYS!","MONKEYS!","MONKEYS!","MONKEYS...
14:52:08 <monochrom> please try not to fail at spaces. sometimes, spaces have to be done exactly right
14:52:12 <shajen> how to read left, right, up, down key press in haskell?
14:52:38 <ion> Using an appropriate UI toolkit. Or something like SDL.
14:52:50 <ion> Depends on what you’re doing.
14:52:58 <monochrom> about the same as how to do that in C
14:53:05 <shajen> simple game using control keys
14:53:09 <shajen> in console
14:53:30 <m0h3n> :m + Data.List
14:53:49 * monochrom would be thrilled if someone responded with "use Turbo C, it has a lib for that"
14:54:30 <m0h3n> tails [1..4]
14:54:32 <monochrom> lambdabot is pretty different from ghci. don't hold expectations.
14:54:38 <ion> shajen: ncurses or equivalent. (Someone mentioned a nice alternative here, i don’t remember its name.)
14:54:46 <shachaf> monochrom: Expectations will be held.
14:54:54 <monochrom> is that vty?
14:55:07 <m0h3n> monochrom: tails [1..4]
14:55:10 <`ramses> > tails [1..4] -- m0h3n use ">"
14:55:12 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
14:55:35 <Lethalman> zhulikas, your code is fast here, did you compile with ghc -O2 instead of running with ghci?
14:55:42 <monochrom> I only respond to !list, and only sometimes
14:55:50 <zhulikas> hah, did it!
14:56:04 <zhulikas> Lethalman, no, I didn't
14:56:09 <Lethalman> zhulikas, so do it :)
14:56:37 <m0h3n> lambdabot: replicate 5 5
14:56:45 <Lethalman> zhulikas, or what do you expect? to be less than 1 second or what?
14:56:56 <`ramses> m0h3n: look what I said above, use ">"
14:57:06 <m0h3n> aha ok sry
14:57:09 <zhulikas> Lethalman, what time does it print for you?
14:57:26 <m0h3n> >replicate 5 5
14:57:36 <Lethalman> zhulikas, it runs in 2.6 seconds here
14:57:43 <zhulikas> ok then
14:57:55 <ion> > replicate 5 5
14:57:57 <lambdabot>   [5,5,5,5,5]
14:57:58 <zhulikas> now it runs in 0.03s here
14:57:58 <zhulikas> :)
14:58:15 <m0h3n> aha the space :D
14:58:38 <hpaste> zhulikas pasted “Lethalman” at http://hpaste.org/80901
14:58:42 <zhulikas> this is how I did it
14:59:06 <zhulikas> damn, this simple technique is brilliant
14:59:15 <zhulikas> saving intermediate values
15:01:49 <Lethalman> zhulikas, indeed, but I show you another way without changing much the previous coded
15:01:54 <Lethalman> zhulikas, though it might not always work
15:02:09 <zhulikas> Lethalman, I compile through leksah
15:02:26 <zhulikas> it ran in 2.3s (apparently cpu is slightly better in this machine)
15:02:35 <zhulikas> and -O2 didn't help a bit
15:03:04 <zhulikas> so I assume either leksah already use that ghc option, or it is useless in this piece of code
15:03:04 <hpaste> Lethalman pasted “memoize hackage” at http://hpaste.org/80902
15:03:17 <Lethalman> zhulikas, ^^ that's pretty much your previous code, except with the fix
15:04:03 <Lethalman> memoFix is very handy in some cases, some other cases fix as is is handy too, some other cases you have to do like you did, etc. etc.
15:04:08 <zhulikas> huh
15:04:13 <zhulikas> let me grab the cabal package
15:04:16 <Lethalman> depends on what you are going to memoize, ecc.
15:04:44 <zhulikas> ExitFailure 1
15:04:45 <zhulikas> ok.
15:04:50 <zhulikas> so, how fast does it work now?
15:04:57 <zhulikas> with memoFix
15:05:18 <Lethalman> mh?
15:05:26 <zhulikas> cabal failed to install memoize :)
15:05:29 <zhulikas> I cannot run the code myself
15:05:33 <Lethalman> zhulikas, not nice :)
15:05:55 <zhulikas> I'll blame windows for this
15:06:02 <zhulikas> probably I need some C library which isn't on this machine
15:06:18 <Lethalman> zhulikas, 0.16s here, but not with timeIt... includes running the binary
15:06:26 <m0h3n> > zipWith (\x y -> x+y) [1..5] [3..7]
15:06:28 <lambdabot>   [4,6,8,10,12]
15:06:28 <zhulikas> ah, perfect
15:06:50 <zhulikas> so that should be the same amount of time
15:06:53 <Lethalman> zhulikas, but it was just to let you show how fix doesn't change much your code
15:06:55 <zhulikas> well, approximately
15:06:57 <monochrom> I don't think memoize needs a C lib
15:07:12 <zhulikas> Lethalman, that's a really nice function
15:07:14 <zhulikas> I'll look into it
15:07:48 <zhulikas> thanks :)
15:08:43 <zhulikas> wondering about scenarios when memoFix is necessary...
15:08:57 <zhulikas> it really does the same thing
15:09:05 <zhulikas> as simple list
15:09:16 <m0h3n> gys is Haskell better than Erlang in terms of performance and concurrency ?
15:09:50 <merijn> m0h3n: The answer is: it depends
15:09:51 <shachaf> GHC 7.6 does not yet support performance. That feature is planned for 7.8.
15:09:57 <Lethalman> lol
15:09:59 <merijn> shachaf++
15:09:59 <zhulikas> please refer to a countless battles of language wars online and theoretical performance mentioned on shootout.alioth.debian page
15:10:12 <m0h3n> depends on what ?
15:10:21 <zhulikas> m0h3n, on who writes the code :D
15:10:26 <mauke> ghc -fperformance=yes
15:10:35 <zhulikas> force performance?
15:10:38 <zhulikas> how about no?
15:10:52 <m0h3n> well if the coder is the same
15:11:05 <mauke> m0h3n: then yes
15:11:15 <mauke> assuming the coder is me, because I don't know shit about erlang
15:11:21 <zhulikas> :DD
15:11:25 <m0h3n> lol
15:11:30 <m0h3n> nice comparison
15:11:35 <m0h3n> :))
15:11:44 <johnw> just using the Perform monad!
15:11:45 <mauke> that's also how I know that gcc beats hand-written assembler code
15:11:54 <zhulikas> m0h3n, you should look for non-biased folk
15:12:06 <shachaf> I hear #erlang is non-biased.
15:12:07 <zhulikas> and that would most likely be somewhere else than #haskell
15:12:11 <zhulikas> haha :DD
15:12:17 <m0h3n> lol
15:12:34 <`ramses> zhulikas: have you ever met a non-biased person then?
15:12:38 <m0h3n> started to learn Haskell like two days ago
15:12:42 <m0h3n> looks nice
15:12:56 <zhulikas> `ramses, let's say someone who doesn't give a crap about any of these two languages
15:12:57 <zhulikas> :D
15:13:14 <`ramses> zhulikas: and you would mind that person's opinion then?
15:13:23 <m0h3n> been proramming in C++ for more than 12 years
15:13:52 <m0h3n> Haskell feels different :D
15:14:03 <zhulikas> m0h3n, if I were you, I'd look into what exactly are the numbers/performance for erlang's lightweight threads
15:14:23 <zhulikas> as judging from outside it seems like the strong side of erlang (At least that's what they promote)
15:14:32 <zhulikas> and then try to figure out how haskell does that
15:15:13 <m0h3n> zhulikas: good point
15:15:14 <zhulikas> m0h3n, in my opinion that's a long journey towards deciding which language is better
15:15:16 <shachaf> Erlang's lightweight threads have a performance of 8.
15:15:38 <zhulikas> full of traps and dangerous encounters
15:15:46 <johnw> shachaf: how fast are the heavyweight threads?
15:15:46 <zhulikas> you may even not survive that journey
15:15:48 <shanse> on a scale from 1 to webscale ...
15:15:50 <m0h3n> shachaf: in what scale ?
15:16:01 <zhulikas> kilograms pls
15:16:22 <shachaf> johnw: They don't even move.
15:17:17 <monochrom> in soviet russia, you run into heavyweight threads
15:18:00 <johnw> if middleweight threads train hard enough, they can sometimes beat a heavyweight thread
15:18:26 <shachaf> i love threads
15:18:30 <shachaf> they are so easy
15:18:44 <zhulikas> next time I will just not open my mouth
15:19:14 <zhulikas> anyway
15:19:18 <merijn> zhulikas: The strong side of Erlang are it's monitoring threads for error handling, hot code update/migration and low latency focus
15:19:31 <johnw> yeah, hot code update is pretty cool
15:19:37 <zhulikas> hot code update?
15:19:53 <zhulikas> like - updating code without recompilation/re-run ?
15:19:56 <frerich_> merijn: Hm, you don't happen to know whether there is some trick to let a program tell *which* MVar is blocking a thread?
15:19:58 <zhulikas> uhm, updating runtime
15:20:10 <frerich_> merijn: In case this "thread blocked indefinitely" error occurs.
15:20:20 * zhulikas googles
15:20:59 <Eduard_Munteanu> Also the whole distributed approach to various stuff, like Mnesia.
15:21:14 <merijn> frerich_: Not sure whether that's possible
15:21:14 <zhulikas> hey, hot swapping is cool :}
15:21:26 <merijn> frerich_: Maybe with the new-ish stack trace stuff?
15:21:34 <Lethalman> frerich_, that's what's annoying about ghc*
15:21:56 <zhulikas> when I first heard about hot swapping in programming, first thought which came to mind is evolutional programs
15:22:02 <zhulikas> which evolve on their own
15:22:16 <Eduard_Munteanu> The not-so-cool part is it hasn't got much of a type system, unfortunately.
15:22:19 * hackagebot gitlib 0.6.5 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.6.5 (JohnWiegley)
15:22:28 <zhulikas> eww :|
15:22:39 <merijn> Lethalman: About lazy evaluation really, the reason GHC didn't/doesn't have stack traces is that they're mostly useless in a lazy language
15:23:09 <Eduard_Munteanu> (regardless of whether or not "let it crash" works, I'd say it's a nice thing to have)
15:24:12 <Lethalman> merijn, I don't think it's useless to know where the an error came from
15:24:23 <Lethalman> being it lazy or not
15:24:33 <merijn> Eduard_Munteanu: Time to all learn Racket so we can have typed code while still using dynamically typed runtime metaprogramming
15:24:49 <monochrom> ghc has a stack. but it does crazy things
15:25:02 <Eduard_Munteanu> There's also CloudHaskell, I should check on that again.
15:25:08 <merijn> Lethalman: Oh? I create a thunk at the beginning of my program (that errors when evaluated), just before the end of my program I evaluate said thunk and get a stack trace for the end of the program
15:25:08 <zhulikas> oh yeah, me too
15:25:14 <zhulikas> cloud haskell looks cool
15:25:26 <merijn> Lethalman: You try and figure out that it's actually that thunk from the beginning that's crashing
15:26:03 <merijn> Anyhoo, time for me to go to bed
15:26:32 <Lethalman> merijn, what's +RTS -xc for then?
15:27:24 <shachaf> @where rts-xc
15:27:24 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
15:31:22 <monochrom> ghc has a stack. so it has a stack trace. but like I said, it is crazy, the interpretation is unlike other languages
15:32:14 <Lethalman> monochrom, but it's better than nothing?
15:32:32 <monochrom> yes
15:32:46 <Lethalman> that's enough...
15:33:13 <Lethalman> if you have N possible causes of an error, with a stack trace you can at least drop some of them
15:34:08 <monochrom> the other setback is that because of -O, some functions get inlined, so the stack trace mentions fewer functions than you would like
15:34:32 <cmccann> my programs only have one possible cause of an error
15:34:36 <cmccann> that cause is me doing something stupid
15:34:46 <monochrom> in extreme cases it just says: "main, then exception" :)
15:35:06 <elkng> can one use Haskell scripts same way as replacement for bash script for system wide needs ?
15:35:17 <Philippa_> I think someone mentioned me while I was out, anyone catch it?
15:35:28 <cmccann> monochrom: so you're saying that that only happens in exceptional cases, eh
15:35:30 <Lethalman> monochrom, of course you aren't going to use -O2, like in any other language
15:36:44 <Lethalman> cmccann, yes, that's exactly the point... unless you are the perfection doing everything right
15:37:05 <glguy> Like in other languages, you can miss the bug if you debug with different optimizations than you otherwise use
15:37:07 <zxq9> elkng: I suppose it would be sort of possible, but I don't think that's the most practical thing to try doing.
15:37:27 <Entroacceptor> zxq9: he just appeared in #emacs and asked the exact same thing there
15:38:06 <monochrom> he asked about haskell in #emacs?
15:38:08 <Lethalman> glguy, true, that kind of bug has a name :P but then other tools exist, like valgrind
15:38:10 <zxq9> Entroacceptor: lol About emacs, Haskell, or emacs-lisp?
15:38:22 <Entroacceptor> about emacs, there
15:38:37 <zxq9> do you smell a robot?
15:38:43 <Entroacceptor> or a troll
15:38:46 <monochrom> I wonder about ##c :)
15:39:09 <monochrom> ooohhh, can I use apl for shell scripting? :)
15:39:20 <monochrom> or excel :)
15:39:21 <zxq9> I'm not in there today so I can't check. Darn. That would have been funny.
15:39:44 <glguy> I've heard of C being used for scripting with tinyCC
15:39:49 <Entroacceptor> or he's just curious
15:41:10 <elkng> Entroacceptor: I want to find a way to apply haskel to learn it
15:41:18 <elkng> and also emacs lisp
15:41:26 <elkng> I trying to learn both
15:42:06 <zxq9> elkng: Guile and scsh is probably a more practical path, then.
15:42:08 <Philippa_> *grabs logs, discovers it's a tab-completion error* - n/m
15:42:51 <ion> PhilRod_: yeah
15:42:54 <Lethalman> elkng, a possibility is to rewrite some of your projects in haskell
15:43:13 <Lethalman> I rewrote part of my thesis in haskell for example, was interesting
15:44:50 <zxq9> elkng: Guile fits well for shell scripting (a Scheme implementation that isn't tied to a text editor at the hip), and there is a thing called Scheme Shell (scsh).
15:45:27 <ijp> zxq9: scsh is bitrotten no?
15:45:34 <ijp> it's certainly unmaintained
15:45:40 <zxq9> ijp: Wouldn't be surprised.
15:46:52 <zxq9> ijp: But he said he wants to learn, not write stuff that needs to be accepted by Fedora as system scripts.
15:51:04 <ijp> I'm not telling him not to learn scheme, just that scsh is dead.
15:56:11 <AtKaaZ> hi, is there any special place I could see clojure vs haskell differences?
16:03:13 <startling> AtKaaZ: no, but they're pretty different. Haskell is statically typed, compiled ahead-of-time, and pure.
16:03:36 <startling> well, compiled to binaries ahead-of-time (usually)
16:03:51 <AtKaaZ> can it do dynamic code at runtime maybe?
16:04:01 <AtKaaZ> (not sure if I need that to be honest)
16:04:27 <startling> sort of (see: ghci, mueval and lambdabot) but it's a pain afaict
16:04:33 <thoughtpolice> you can, but it's a bit trickier to pull off
16:06:55 <AtKaaZ> ok, let me ask you this(which is why I was recommended haskell): I wanted to be able to specify the same class in a bunch of places (sort of stating that this var is of this type) by using a placeholder so that if I wanted to change the type(/classname) I would do that in only one place(instead of search+replace), can this be done in haskell?
16:09:46 <startling> AtKaaZ: um, it could (with Template Haskell, probably) but that sounds kind of crazy and unnecessary
16:10:20 <AtKaaZ> ok, maybe I need to understand how haskell works first, to realize if I even need that anymore
16:10:43 <AtKaaZ> thanks in advance, I'm reading from here: http://www.haskell.org/haskellwiki/Introduction#Why_use_Haskell.3F
16:17:37 <ski> AtKaaZ : perhaps you want something like ML functors (see SML and O'Caml)
16:24:46 <sm> sounds like just type classes
16:25:23 <AtKaaZ> I dno, what I want is more like a macro ie. in c++ #define something java.io.File  then wherever i use "something" in the code, it will be replaced by that "java.io.File"
16:25:48 <sm> ok, well you can keep using CPP
16:26:07 <AtKaaZ> I'm not using that, but I remember it
16:27:20 <monochrom> you can define "type X = Int". then you can write type sigs "f :: X -> ()", and X means Int. later, you can change "type X = Int" to "type X = Double"
16:28:01 <AtKaaZ> that's nice
16:35:18 <AtKaaZ> thanks all, haskell&co is not what I want, at this time
16:40:04 <burbul> hlint is giving me a load of suggestions to change
16:40:12 <burbul> UniversalImplies _ _ _
16:40:12 <burbul> to
16:40:17 <burbul>  UniversalImplies{}
16:40:24 <burbul> why is this good practice?
16:40:36 <Philippa_> survives the parm count for UniversalImplies changing
16:41:17 <burbul> Normally I find that if I change the parameter count, I want to be forced to check every instance individually (to prevent silent changes in behaviour).
16:41:28 <Philippa_> also, u@UniversalImplies{} is better than rebuilding it to return
16:41:33 <burbul> (Similarly when you change types)
16:41:36 <mersx> .
16:41:44 <Philippa_> yeah. But that's one case that's genuinely parametric: you *don't care* about the parameters
16:41:47 <burbul> But thanks for the explanation
16:42:41 <hrumph> yo
16:43:02 <hrumph> i just got fedora 18. i'm having trouble getting yedod up and running again
16:43:14 <hrumph> getting it installed to be clear
16:44:07 <Philippa_> burbul: yeah, records are an interesting engineering trade-off in that regard? I generally try to use {} when I'm not using any of the parameters though, it's yet to land a bullet in my foot
16:56:53 <geri> what causes software to be non deterministic?
16:56:58 <geri> hi
16:57:00 <Canar> Prolog. :3
16:57:13 <Philippa_> cosmic rays!
16:57:22 <c_wraith> hardware
16:57:32 <Philippa_> geri: you'll have to tell us which kind of non-determinism you're interested in
16:57:46 <c_wraith> I mean, without hardware, software's inert.
16:57:55 <Philippa_> c_wraith: I hear it's worse running on wetware
16:57:56 <geri> how can you find errors in the algorithms causing non-determinstic behavior
16:57:57 <geri> ?
16:59:56 <seafood> Hey guys, so I'm about to write a parser in Haskell, something I haven't done in a long time. Is Parsec still the library of choice?
17:01:01 <bxc> seafood: it is for me
17:01:08 <c_wraith> geri: that still doesn't fully answer the question. Do you mean concurrency-related non-determinism? Or do you mean other sources of non-determinism, like uninitialized variables?
17:01:08 <geri> how can you find errors in the algorithms causing non-determinstic behavior?
17:01:24 <geri> c_wraith, sounds like non determinstic
17:01:26 <geri> yeah
17:01:50 <c_wraith> That wasn't really a yes or no question
17:01:52 <geri> i look for sources of non-determinism, like uninitialized variables?
17:01:55 <geri> !
17:02:22 <c_wraith> Ah, if you're looking for generic sources of all kinds of non-determinism, you're far beyond the scope of this channel
17:03:05 <bxc> seafood: maybe i'm just old though
17:03:44 <elliott> seafood: there's also attoparsec
17:03:52 <elliott> which may be more suitable for some use-cases
17:04:21 <Eduard_Munteanu> Or trifecta, but I'm not sure about the performance aspects.
17:05:13 <Philippa_> geri: do you mean sources of undefined behaviour?
17:05:20 <geri> yes
17:05:34 <Philippa_> you read the spec for the language you're working in, then hope demons don't emerge from your nose
17:05:37 <geri> like mssing synchronization in multithreaded is one error
17:06:18 <Philippa_> (really, it depends on the class of behaviour/what can trigger on it - some're simple, some have caused researchers to construct new formal logics to describe)
17:06:39 <mersx> xs is a list with 10 elements. if I get 10th element, ie xs !! 10, will prior 9 elements be evaluated or will they remain thunks?
17:06:42 <Philippa_> seafood: have you used parsec since the 2->3 transition?
17:06:54 <Philippa_> (if not, I'm trying to decide whether to apologise for my hand in it!)
17:07:06 <Philippa_> mersx: only the spine of the list
17:07:13 <Philippa_> so the cons cells, but not the items in them
17:07:19 <glguy> mersx: Do you know how to test that, say in GHCi?
17:07:21 * hackagebot smallcheck 0.6.2 - A property-based testing library  http://hackage.haskell.org/package/smallcheck-0.6.2 (RomanCheplyaka)
17:07:30 <mersx> glguy not really
17:07:40 <glguy> > [undefined, True] !! 1
17:07:42 <lambdabot>   True
17:07:48 <mersx> ah neat
17:10:00 <yitz> seafood: personally i usually use attoparsec. but parsec is included in the haskell platform, so it is arguably the standard parser combinator library.
17:29:04 <mersx> @src undefined
17:29:04 <lambdabot> undefined =  error "Prelude.undefined"
17:31:51 <augur> is there a good way to get haskell in tex without having to do anything special like use lhs2tex?
17:32:02 <augur> i dont need it for much, i just need a few type sigs inline
17:32:36 <geri> Philippa_, thats my answere: http://www.youtube.com/watch?v=gXRmNp4Wgb0 :D
18:26:39 <johnw> edwardk: if category-extras is now deprecated, where should I get Control.Functor.HigherOrder from?
18:40:32 <magicman> scan f = extend (cata f)
18:40:44 <shachaf> "The short version of the message is that monads are a way of getting around the immutability that is a central principle of functional programming. This means that within a language that has mutable data structures and functions, monads aren't really relevant and you don't need to worry about them."
18:40:53 <magicman> Specifically, in the case of lists, scanr f e = extend (foldr f e)
18:40:58 <magicman> Please tell me this is sensible.
18:41:00 <shachaf> From <http://www.i-programmer.info/news/167-javascript/5207-crockford-on-monads-and-gonads.html>. Crockford is actively harmful. :-(
18:41:19 <magicman> Would be pretty cool to see that scans are sensible for any Comonad.
18:41:33 <bradleyayers> shachaf: what part of what he said is wrong?
18:42:01 <shachaf> magicman: What is "extend" in the case of lists?
18:42:03 <johnw> non-IO monads don't "get around mutability".  Does the Maybe monad allow mutation?
18:42:14 <shachaf> bradleyayers: Crockford or the person I quoted?
18:42:16 <magicman> shachaf: tails
18:42:26 <bradleyayers> shachaf: sorry, i thought they were the same
18:42:38 <magicman> shachaf: I'm aware that lists aren't a Comonad, because it's missing coreturn :-/
18:42:44 <bradleyayers> johnw: fair enough
18:43:04 <shachaf> bradleyayers: Anyway, monads are not "a way of getting around the immutability that is a central principle of functional programming", and it's not the case that "within a language that has mutable data structures and functions, monads aren't really relevant and you don't need to worry about them".
18:43:07 <magicman> shachaf: But otherwise... I think it can work.
18:43:16 <shachaf> And also that wasn't really the message of the video.
18:43:23 <shachaf> I think that about covers it?
18:44:20 <shachaf> magicman: I'm not sure that makes much sense.
18:44:27 <shachaf> Do you have an example?
18:44:55 <magicman> Eh, just something I thought up after reading the Comonadit Trees post.
18:45:15 <magicman> *Comonadic
18:45:23 <magicman> http://5outh.blogspot.nl/2013/01/comonads.html
18:45:32 <shachaf> OK, but do you have an example?
18:45:50 <shachaf> @ty tails (foldr f e) -- this is a type error, so I'm probably just not understanding what you mean.
18:45:51 <lambdabot>     Couldn't match expected type `[a0]' with actual type `[a1] -> b0'
18:45:51 <lambdabot>     In the return type of a call of `foldr'
18:45:51 <lambdabot>     Probable cause: `foldr' is applied to too few arguments
18:46:00 <magicman> Err, right.
18:46:01 <shachaf> Do you mean to do "tails" first, and then fold?
18:46:37 <bradleyayers> shachaf: thanks :)
18:46:53 <magicman> Let me go back to notes I was making. I can't help but thinking there's *some* link between the scan* family and Comonad's extend function.
18:46:54 <bradleyayers> shachaf: it is a shame crockford is being misleading then
18:47:05 <magicman> *think
18:47:28 <johnw> isn't extend kind of the reverse of extend?
18:47:48 <johnw> scan generates the sublists, while extend sees the sublists as it walks through the list
18:47:54 <shachaf> johnw is kind of the reverse of johnw.
18:48:05 <johnw> so, step 1 of scan is a one element list, but step 1 of extend sees the whole list
18:48:25 <johnw> shachaf: it depends on how you divide me
18:48:43 <johnw> i mean, scan the reverse of extend
18:48:49 <johnw> haha
18:48:53 <shachaf> johnw: I divide you into five pieces and then reässemble them to get a two copies of you.
18:49:04 <xenocons> potentially offtopic: if i wanted to do semantic analysis of very short (3 to 10 words) english titles, what would be my first thing to learn?
18:49:11 <johnw> isn't reässemble kind of like so-1920s?
18:49:31 <johnw> xenocons: what kind of semantics are you interested in?
18:49:46 <johnw> are we talking "Sir", "Lord", "Captain"?
18:49:52 <xenocons> i guess the area of a topic
18:49:54 <johnw> those are all English Titles
18:50:09 <shachaf> johnw: I don't think that's very helpful.
18:50:16 <xenocons> essentially so i can work out 'similar' topics
18:50:42 <xenocons> but i dont think word distance will help due to diversity of choice
18:50:53 <johnw> bayesian filtering could help
18:50:59 <xenocons> hmm
18:51:02 <johnw> if you assemble statistics on a group of known titles for each category
18:51:15 <xenocons> like a word bag, then categorise?
18:51:33 <johnw> you could additionally take sequencing as a minor weight
18:51:34 <xenocons> i guess i dont know where to start in terms of choosing the known titles
18:51:58 <johnw> are these book titles
18:52:00 <johnw> ?
18:52:01 <magicman> Wait. extend f = fmap f . duplicate, where duplicate is tails.
18:52:03 <magicman> There we go.
18:52:08 <xenocons> johnw: conference talk titles
18:52:22 <shachaf> magicman: Sounds right.
18:52:28 <johnw> xenocons: you'd need a curated corpus to start from
18:52:30 <magicman> fmap (foldr f e) . tails === scanr f e
18:52:35 <johnw> in order to use a statistical model
18:52:51 <xenocons> johnw: yeh hm
18:52:51 <magicman> (this is what happens when I try to brain at almost 4 am XD)
18:52:59 <xenocons> hard part is getting a good curated corpus i guess
18:53:06 <johnw> isn't it always
18:53:13 <xenocons> heh
18:53:15 <pzuraq> is there a way to fold a list of chars?
18:53:21 <shachaf> Many ways.
18:53:26 <shachaf> "foldr" is one.
18:53:38 <pzuraq> what operator do you use?
18:53:49 <shachaf> Depends on what you want to do.
18:53:49 <pzuraq> (+) doesn't work it seems
18:53:57 <pzuraq> just concatenate them
18:53:57 <shachaf> Folding is a means, not an end.
18:54:03 <shachaf> What does that mean?
18:54:09 <shachaf> Give an example input and output.
18:54:09 <NemesisD> what's the difference between MonadReader and ReaderT
18:54:11 <pzuraq> turn them intro a string, I suppose
18:54:21 <shachaf> A String is a list of Chars.
18:54:23 <shachaf> @src String
18:54:23 <lambdabot> type String = [Char]
18:54:24 <johnw> MonadReader is a type class
18:54:30 <johnw> ReaderT is a newtype wrapper
18:54:38 <pzuraq> foldr op ['d','o','g'] = "dog"
18:54:39 <johnw> MonadReader m means that 'm' supports the Reader interface
18:54:49 <cmccann> > ['d', 'o', 'g']
18:54:50 <lambdabot>   "dog"
18:54:52 <pzuraq> ah
18:55:07 <johnw> ReaderT e m a means that you're transforming the monad m into a monad with a reader environment a
18:55:12 <shachaf> i love strings
18:55:14 <pzuraq> hmm, I was trying to experiment with reversing the order
18:55:21 <johnw> s/a$/e
18:55:21 <pzuraq> using fold rather than reverse
18:55:41 <cmccann> > foldl (flip (:)) "" "abcdef"
18:55:43 <lambdabot>   "fedcba"
18:55:58 <pzuraq> :O
18:56:01 <johnw> that fold really has nothing to do with characters even
18:56:03 <pzuraq> I was trying to do that earlier!
18:56:06 <magicman> I was going by the Extend typeclass in an old version of the comonad package.
18:56:09 <pzuraq> flip, that makes so much sense
18:56:21 <NemesisD> johnw: i'm doing a library that makes RPC calls, i want to store the authentication in the reader environment, shuld i be using ReaderT then?
18:56:28 <cmccann> > foldl (flip (:)) [] [1..10] -- as johnw said, not just characters
18:56:30 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:56:35 <johnw> NemesisD: if you also need IO, yes
18:56:36 <shachaf> pzuraq: Note that you can do it without flip.
18:56:43 <shachaf> flip is just for conveniene.
18:56:44 <shachaf> c
18:56:48 <johnw> NemesisD: maybe HaXR has some parts you can reuse?
18:57:07 <shachaf> > foldl (\x y -> y : x) [] [1..10] -- being able to do this is more fundamental than being able to use flip
18:57:09 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
18:57:26 <NemesisD> type RpcM m a = ReaderT Config m a ?
18:57:35 <johnw> yep
18:57:53 <johnw> i just made one of those the other day
18:57:59 <shachaf> What's with the GHC convention of sticking "M" at the end of your monads?
18:58:03 <pzuraq> yeah, we are learning about lambdas right now, they make much sense
18:58:09 <pzuraq> the language is awesome in a lot of ways
18:58:27 <monochrom> wait, GHC has that convention?
18:58:34 <NemesisD> johnw: i did a library before that did this but i was less experienced and pretty much copy pasted that idea without understanding it
18:58:51 <johnw> what, the ReaderT idea?
18:59:08 <cmccann> GHC also contains easy-to-understand terminology like "zonking".
18:59:28 <monochrom> I haven't seen that in GHC, but haha
18:59:51 <NemesisD> johnw: yeah. i was doing a google+ client and i stole the idea from a twitter client
19:00:11 <shachaf> monochrom: TcM, TcRnM, etc.
19:00:13 <johnw> and guess what, I'm using ReaderT for a remote call library ;)
19:00:20 <shachaf> In this case I was asking NemesisD specifically, though.
19:00:59 <cmccann> monochrom: https://github.com/ghc/ghc/blob/master/compiler/typecheck/TcHsSyn.lhs#L29
19:01:07 <johnw> gah, I hate it when "edwa" won't TAB complete
19:01:09 <NemesisD> johnw: cool! mine is bindings for the transmission torrent client rpc backend
19:03:32 <monochrom> we need to @tell edwardk about completion not working when he is away :)
19:03:51 <shachaf>  @tell edwa Completion isn't working while you're away!
19:04:06 * monochrom files this as a bug report on github!
19:04:46 <monochrom> "lens ticket #1394: nick completion no workie on irc"
19:05:48 <shachaf> monochrom: You should join #haskell-lens
19:06:41 * cmccann adds a comment to monochrom's ticket noting that the underlying bug may result in shachaf and elliott being left unsupervised which could have dire consequences
19:07:50 <shachaf> cmccann: Make yourself useful and work on issue #245
19:08:35 <shachaf> cmccann: (Really, I'm at a loss there. :-( )
19:08:45 <NemesisD> any of you guys use http-conduit
19:09:05 <monochrom> regrettably, I have nothing to contribute to #haskell-lens
19:09:13 <shachaf> NemesisD: Maybe #yesod would.
19:09:18 <shachaf> monochrom: How about puns?
19:09:28 <shachaf> edwardk :: Puns -> Lens
19:09:29 <cmccann> shachaf: how about adding some CPS transforms? that always helps.
19:09:40 <shachaf> cmccann: dolio said it couldn't be done or something.
19:10:30 <dolio> I think it requires a different kind of CPS transform that no one ever talks about.
19:10:53 <shachaf> What do you mean?
19:11:58 <dolio> The CPS transform that everyone is used to, and talks about, is the call-by-value CPS transform.
19:12:11 <dolio> There are different ones if you want to do call-by-name or need.
19:12:24 <dolio> But it's almost impossible to find information about them.
19:12:54 <dolio> And since that function you guys want to write is specifically about doing lazy stuff, I suspect you want the kind of transform that no one ever talks about.
19:15:34 <elliott> What would that look like?
19:16:19 <dolio> I think it involves extra Cont r around things you don't want to 'evaluate' yet.
19:16:38 <dolio> But as I said, I'm not really sure, because it's really hard to find any information about it.
19:16:54 <shachaf> That would give you non-strictness without sharing, wouldn't it?
19:17:05 <shachaf> Or, er, never mind.
19:17:12 <shachaf> I guess that was related to your point.
19:18:10 <dolio> Basically, my answer is: ask oleg.
19:18:41 <monochrom> use !list to find oleg with 1/3 probability :)
19:18:59 <shachaf> !list
19:19:00 <monochrom> shachaf: http://hackage.haskell.org/packages/archive/pkg-list.html
19:19:03 <shachaf> Aw.
19:19:17 <monochrom> bad luck
19:19:24 <shachaf> !list
19:19:28 <shachaf> I guess it's throttled.
19:19:29 <monochrom> oleg is not so easy to find! :)
19:19:35 <monochrom> yes I throttle it
19:19:43 <shachaf> monochrom: Perhaps you will find him in #haskell-lens.
19:19:49 <monochrom> haha
19:28:49 <jekor> Does anyone know of a way to override an instance declaration? I'd like to add debug output to the Monad instance for StateT.
19:29:59 <shachaf> hi jekor
19:30:03 <shachaf> I remember you from N years ago!
19:30:25 <cmccann> hi shachaf
19:30:30 <cmccann> I remember you from N minutes ago
19:30:38 <shachaf> hi syntaxglitch
19:30:42 <cmccann> haha
19:30:47 <cmccann> good memory.
19:31:26 <jekor> Hah! I still have the log of our conversation.
19:31:57 <shachaf> You made that language website, if I remember correctly.
19:32:04 <jekor> Yes. Good memory.
19:33:02 <shachaf> What you want to do is not possible in GHC as far as I know.
19:33:45 <jekor> That's what I had feared.
19:43:56 <NemesisD> should i use ReaderT from mtl or transformers?
19:44:03 <cmccann> yes
19:44:15 <dolio> It's the same ReaderT.
19:44:39 <NemesisD> how? they are in different packages
19:44:50 <dolio> mtl depends on transformers.
19:54:58 <yepyep> I've more or less finished reading the material in Learn You a Haskell.  Aside from perhaps Real World Haskell, are there any other recommended reading resources to build upon intermediate level Haskell?
19:55:50 <cmccann> not really
19:55:59 <shachaf> cmccann: That's where your book comes in.
19:56:08 <yepyep> I should rephrase that.  Does anyone have any particular suggestions for material to build upon that which is covered in LYAH?  I have of course looked at the Haskell wiki.
19:56:34 <cmccann> yepyep: no, and the lack of something like that is a known problem
19:56:51 <cmccann> the best thing to do where you are is jump in and start coding
19:57:39 <cmccann> also hang around various haskell community areas and if you hear something interesting, ask for more information
19:58:05 <shachaf> cmccann: Hmm, that sounds like an interesting approach.
19:58:10 <shachaf> Do you have more information on it?
19:58:30 <cmccann> the haskell community is full of people who tend to be enthusiastic and knowledgeable, the biggest danger is asking someone about something they really like and not being able to get them to shut up
19:58:48 <yepyep> haha
19:58:59 <byorgey> yepyep: there's the typeclassopedia
19:59:05 <shachaf> Note that sometimes people really like something and yet know almost nothing about it.
19:59:12 <cmccann> shachaf: I hear #haskell on freenode is a good place for that, you should go there
19:59:17 <shachaf> Oh, the Typeclssopedia is probably good.
19:59:49 <cmccann> there's probably a good reading list of haskell-related blogs too
20:00:01 <yepyep> This is a pretty amazing IRC channel.  I have to hand it to you guys/gals.
20:00:10 <cmccann> but I'm not sure what the best ones for that reading list would be
20:00:17 <cmccann> sigfpe's blog maybe
20:00:22 <yepyep> I went on a couple other IRC channels and it seemed like everyone was just idling
20:00:33 <yepyep> not haskell related, i should add
20:00:50 <shachaf> i love idling
20:00:50 <cmccann> yepyep: this is a big channel
20:00:52 <shachaf> it is so easy
20:00:53 <parcs> most people are idling here too
20:01:00 <cmccann> shachaf lies, he never idles
20:01:05 <cmccann> he's basically always in here talking
20:01:27 <yepyep> well I think it's the perception of idling
20:01:35 <shachaf> cmccann: Always in here talking over people.
20:01:37 <yepyep> I usually get a helpful answer on this channel
20:02:32 <shachaf> byorgey: You should have a dotted arrow between Category and Monoid!
20:02:42 <cmccann> usually people get two helpful answers and multiple unhelpful answers
20:03:23 <ski> @where typeclassopedia
20:03:23 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
20:03:24 <cmccann> like when someone asks a newbie question and then the whole channel spends an hour debating semantic minutia or abstraction golfing the original question into the most general form possible
20:03:53 <shachaf> Is there a word mathematicians use for "inlining
20:03:54 <shachaf> "?
20:04:12 <tim_heap> shachaf: substitute x in to y?
20:04:32 <ski> shachaf : why dotted ?
20:04:37 <tim_heap> My lecturers used to say 'Now sub this x into our equation y'
20:04:48 * ski just uses ordinary arrows for natural transformations
20:05:14 <shachaf> ski: I mean in the graph on Typeclassopedia.
20:06:14 * ski doesn't follow
20:06:29 <shachaf> This graph: http://www.haskell.org/wikiupload/d/df/Typeclassopedia-diagram.png
20:06:35 <shachaf> "Solid arrows point from the general to the specific; that is, if there is an arrow from Foo to Bar it means that every Bar is (or should be, or can be made into) a Foo."
20:06:39 <shachaf> "Dotted arrows indicate some other sort of relationship.
20:06:40 <shachaf> Monad and ArrowApply are equivalent."
20:06:56 <shachaf> Er, s/\n.*$/"/
20:06:59 <yepyep> Are there any fairly complete libraries for working with NetCDF files?  I looked at a couple projects but they seemed to be incomplete and not terribly well documented
20:08:18 <cmccann> yepyep: not that I can find
20:09:08 <yepyep> I need only a small subset of the library functions.  Perhaps that would be a good personal project to link the netCDF API via FFI
20:10:23 <cmccann> yepyep: depending on what you need to do it might actually be simpler to roll your own in pure haskell instead of muck about with the ffi.
20:14:03 <yepyep> anyways.  thanks for the info again
20:18:01 <NemesisD> hi guys, i'm having a hard time using aeson with attoparsec-conduit, attoparsec-conduit has sinkParser :: (AttoparsecInput a, MonadThrow m) => Parser a b -> GLSink a m b, I see lots of examples using sinkParser json, json :: Parser Value, but I wanted to parse into something in the class FromJSON, but all that exposes is parseJSON :: FromJSON a => Value -> Parser a
20:18:36 <NemesisD> so if json parses with a result of Value and parseJSON is Value -> Parser a, how would i combine them to get Parser a
20:22:28 <NemesisD> would it be something like parseJSON <=< (const json)?
20:25:46 <parcs> NemesisD: json >>= parseJSON
20:26:12 <parcs> NemesisD: what you said is correct too
20:48:02 <ski> NemesisD : alternatively `parseJSON =<< json'
21:08:15 <jekor> What does "Derived from the representation type" mean (output from -ddump-deriv). I was trying to see the derived implementation for a MonadState instance.
21:09:07 <monochrom> http://www.vex.net/~trebla/haskell/parsec-generally.xhtml
21:09:31 <shachaf> monochrom: Is that Continuation Parsec Style?
21:09:54 <shachaf> jekor: It probably means that GeneralizedNewtypeDeriving does some evil tricks, rather than generating Haskell code.
21:10:04 <monochrom> it contains that but it is the whole thing I presented to the Toronto Haskell meeting last week
21:10:04 <oio> is there a way to make this better looking with (.) operator ? (\n -> show n ++ ")")
21:10:23 <jekor> shachaf: Thanks. That at least gives me somewhere to look.
21:11:17 <shachaf> @pl (\n -> show n ++ ")")
21:11:17 <lambdabot> (++ ")") . show
21:11:24 <shachaf> Whether that is "better" is arguable.
21:11:50 <oio> for the eyes?
21:39:21 <vamega> Hi
21:39:21 <lambdabot> vamega: You have 1 new message. '/msg lambdabot @messages' to read it.
21:40:31 <caecusum> Can anyone point me to a good tutorial or reference for current versions of gtk2hs? The number of examples using deprecated events and such is high enough to make searching a real chore.
21:40:37 <vamega> I was wondering how feasible it would be to write a haskell ssh client over a 4 month period?
21:48:28 <oio> you should ask when people arent sleeping :D
21:53:51 <hrumph> yo
21:53:57 <hrumph> need some help to understand yesod
21:54:03 <hrumph> i'm learning about the joining systeem
21:54:34 <hrumph> so if use this system where i have a seperate join entity instead of using sql joins then should i still be using postresql?
21:54:46 <shachaf> Maybe #yesod would know.
21:55:04 <Casca> hello everyone
21:55:53 <vamega> hi
21:56:07 <hrumph> my basic question is what kind of backend should i use for most idiomatic usage of yesod?
21:56:59 <hrumph> btw i'm asking the same q's on #yesod without result
21:57:20 <shachaf> Well, that probably means that Yesod people aren't around. :-)
21:59:11 <kini> what word can I use to refer to the kind of evaluation that happens when you apply (reverse . reverse) to a list, for example?
21:59:11 <hrumph> the basic implication seems (to me) that its using a no sql idiom which would imply that the most ideal back end would be mongo db
22:00:10 <shachaf> monochrom: I think (*) is not a good way of computing a sum.
22:00:25 <monochrom> oh haha
22:01:08 <vamega> kini - I think that would be called an identity function
22:01:14 <kini> I've heard the word "spine-strict", but afaik that refers to a kind of datatype, not the actual evaluation
22:01:24 <kini> vamega: well, it's different from the identity in terms of its strictness behavior
22:01:36 <shachaf> kini: It could mean either, I think.
22:01:39 <hrumph> oto i'm reading somewhere else that someone had the easiest time with postgresql
22:01:47 <monochrom> fixed. this web server needs you to refresh to see the fix
22:01:51 <shachaf> It seems reasonable to me to say that (reverse . reverse) is strict in the spine of the list.
22:02:01 <kini> shachaf: so, "(reverse . reverse) spine-strictly evaluates a list" would be cromulent?
22:02:13 <vamega> spine-strict sounds over my head at the moment
22:02:18 <shachaf> I've never seen that used as an adverb.
22:02:28 <vamega> I'm still fairly new
22:02:40 <kini> vamega: don't worry, so am I :)
22:02:41 <shachaf> vamega: (reverse . reverse) is not the same as id
22:02:52 <shachaf> vamega: For example -- (reverse . reverse) [1..] is an infinite loop.
22:03:07 <centrinia> How do I recursively reinstall the dependencies that might be broken by cabal install --reinstall foobar?
22:03:30 <kini> well, in ghci, so is [1..] - to drive the point home even harder, head [1..] = 1 but head $ (reverse . reverse) [1..] will never return
22:03:43 <vamega> shachaf - That makes sense, but why isn't the composition of reverse and reverse not lazy?
22:04:08 <monochrom> order cabal to install a few packages at the top of the food chain
22:04:34 <shachaf> vamega: How could it be?
22:04:49 <shachaf> vamega: (reverse [1..]) can be a list.
22:04:57 <shachaf> But what is its first element?
22:05:04 <kini> vamega: reversing the list the first time has to be a strict operation; just because conceptually reversing something twice should result in nothing being done, doesn't mean that you can take a strict expression and build another expression around it that is lazier than its subexpression
22:05:05 <shachaf> kini: No, [1..] isn't an infinite loop in ghci.
22:05:29 <kini> shachaf: well, typing it into the prompt is. Isn't it? ... well, I guess it does produce incremental output, so it's not exactly a divergent computation...
22:05:38 <shachaf> vamega: To be able to reverse some list, you have to yield its *last* element first.
22:05:43 <vamega> Yes
22:05:46 <vamega> This makes sense
22:05:51 <shachaf> vamega: But an infinite list has no last element.
22:06:01 <shachaf> kini: Ah, I suppose infinite loop can mean that too. :-)
22:06:05 <kini> shachaf: I think vamega is saying, can't haskell see that reverse is an involution and optimize it away into the identity function?
22:06:19 <shachaf> No, that is not an optimization.
22:06:19 <vamega> No I wasn't saying that
22:06:22 <shachaf> That is changing semantics.
22:06:25 <kini> and I would say, I guess haskell doesn't like to "optimize" in ways that change semantics
22:06:26 <kini> exactly
22:06:38 <kini> vamega: oh, ok - sorry
22:06:41 <vamega> No problem
22:06:43 <shachaf> GHC does it anyway. :-) But usually only in ways you don't notice.
22:07:09 <vamega> I realize that special casing something like that would be pretty bad
22:07:23 <vamega> For example if you were for some inane reason trying to enter an infinite loop
22:07:36 <shachaf> vamega: The evaluation model of laziness is actually very straightforward.
22:07:59 <shachaf> There are a few simple rules that are followed to evaluate your code. Not much magic.
22:08:24 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml
22:08:36 <shachaf> People sometimes say, "GHC only evaluates what it needs to". That sounds like magic, because how does GHC know what it needs to evaluate?
22:08:41 * shachaf is trying to talk monochrom-style now.
22:08:48 <shachaf> I'm not very good at it.
22:09:23 <monochrom> GHC doesn't. and lazy evaluation is not about need
22:09:37 <vamega> I think I have a good grip on lazy evaluation
22:09:40 <monochrom> at least, not about human's subjective judgement of "need"
22:09:46 <vamega> Probably not perfectly accurate
22:09:59 <vamega> But I get the concepts of thunks
22:10:01 <shachaf> i love lazy evaluation
22:10:02 <shachaf> it is so easy
22:10:08 <shachaf> vamega: Lazy evaluation is not about thunks.
22:10:12 <vamega> Isn't it?
22:10:18 <monochrom> if b then 'x' else 'x' --- is b "needed"? very smart humans say no. but GHC has to do b anyway
22:10:31 <vamega> I mean you compute a thunk for each computation right?
22:10:39 <shachaf> monochrom: It is needed for the semantics of Haskell. :-)
22:10:40 <monochrom> define thunk
22:10:41 <vamega> And then only evaluate the ones you need?
22:11:26 <vamega> A thunk is just a value that has not been evaluated yet... isn't it?
22:11:31 <johnw> monochrom: you could create a rewrite rule that says \x y -> if x then y else y = const y
22:11:44 <shachaf> That would be invalid.
22:11:49 <monochrom> ah, that is treacherous
22:11:58 <johnw> shachaf: how so?  you are the rewrite wizard
22:12:03 <monochrom> then again, what can't we do with rewrite rules!
22:12:14 <shachaf> johnw: (if undefined then x else x) is undefined.
22:12:29 <monochrom> \x y -> undefined
22:12:31 <Casca> Hi all. I've just finished writing my first Haskell app. It's a solver for games of Hangman. Given a list of words and a string of the form __w__x_yz, it produces a list of matching words from the original list. I've achieved this by composing a bunch of calls to filter :: (a -> Bool) -> [a] -> [a]. I'd like to know if there's a more idiomatic way of achieving the same computation.
22:12:40 <Casca> Here's the code, if anyone is interested: https://github.com/LeandroLovisolo/Hangman/blob/f0f46b69fa263c648b02586102079ff320d8b665/Hangman.hs
22:12:40 <johnw> the rewrite rule can't handle if _ then x else x?
22:13:16 <shachaf> Handle?
22:13:27 <johnw> deal with, support, act properly upon
22:13:35 <tomoj> why can't I fold my Tree of strings? https://www.refheap.com/paste/2a607d060b48fc27d5edb1010
22:13:48 <shachaf> What's "properly"? I don't understand the goal.
22:13:54 <johnw> maybe i don't follow how rewrite rules work
22:14:05 <johnw> i want any if _ then x else x to be replaced by x
22:14:06 <monochrom> johnw, you can add any rewrite rule you like, but that particular rule violates Haskell 2010
22:14:23 <johnw> ah, is that what he means by "invalid"?
22:14:27 <monochrom> yes
22:15:40 <shachaf> tomoj: You have a ; instead of a "where".
22:16:23 <monochrom> more generally, case blah of {Ctor1{} -> x; Ctor2{} -> x} is not simply x either. if blah happens to be ⊥, the whole thing has to be ⊥ too, not x
22:16:28 <tomoj> oh, d'oh
22:17:42 <NemesisD> is there an appreciable difference between mtl and transformers' ReaderT or they literally the same?
22:18:02 <monochrom> they are the same. mtl adds type classes like MonadReader
22:18:02 <shachaf> 19:43 <dolio> It's the same ReaderT.
22:18:17 <shachaf> Literally, precisely the same.
22:18:34 <monochrom> mtl re-exports transformers
22:19:05 <shachaf> mtl reëxports transformers such as ReaderT :-)
22:19:17 <monochrom> this was due to the Peace Treaty Accord of Vienna 2008
22:19:21 <hpaste> NemesisD pasted “operating within ReaderT” at http://hpaste.org/80905
22:19:30 <NemesisD> could someone take a look at this then, i'm a bit stuck
22:19:37 <johnw> what is your stuckedness?
22:19:53 <johnw> ah, I see
22:20:00 <johnw> you need to add MonadBase IO m
22:20:06 <johnw> heh, this code looks *so* much like mine
22:20:12 <johnw> (add it as a constraint)
22:20:39 <NemesisD> johnw: must mean i'm on the right track :P
22:20:55 <monochrom> "transformers-base-0.4.1:Control.Monad.Base.MonadBase" suggests multiple versions to me
22:21:01 <NemesisD> although transformers still make head asplode
22:21:14 <shachaf> ==monochrom
22:21:20 <johnw> transformers just require vertical thinking
22:21:30 <johnw> rather than the horizontal thinking of composition
22:21:35 <shachaf> i love vertical thinking
22:21:37 <shachaf> it is so easy
22:21:43 <monochrom> I use diagonal thinking
22:21:57 <NemesisD> i think i typically use imperative thinking :/
22:22:03 <shachaf> monochrom's thinking is uncountable.
22:22:16 <NemesisD> i code ruby all day, then come home and do battle with GHC
22:22:29 <monochrom> and uncomputable
22:23:42 <magicman> Ah-hah! Comonad's law (extract . extend f == f) is equivalent to scanr's (head . scanr f e == foldr f e). (if we'd accept non-empty lists as being a comonad).
22:23:54 * magicman is still busy with this, sorry >_<
22:24:25 <NemesisD> johnw: what forces me to need to specify IO specifically? i haven't mentioned IO in the types anywhere yet
22:25:19 <johnw> withManager :: (MonadIO m, MonadBaseControl IO m, MonadThrow m, MonadUnsafeIO m) => (Manager -> ResourceT m a) -> m a
22:25:20 <johnw> that's why
22:25:34 <johnw> you can only use withManager in a monad that support MonadBaseControl IO m
22:26:08 <johnw> and MonadBaseControl IO has a constraint of MonadBase IO
22:26:09 <NemesisD> something's tellling me i should just leave the type off and see if i can get ghci to write it for me
22:26:21 <johnw> i bet that will work fine here
22:27:57 <johnw> shachaf: do you grok Representable well?  is it just a prototypical abstraction for any key/value container?
22:28:09 <shachaf> johnw: Which Representable?
22:28:15 <johnw> Representable functors
22:28:32 <johnw> i think edwardk's package is called representable-functors
22:28:53 <shachaf> OK, sure.
22:29:02 <shachaf> I wouldn't really call it key-value.
22:29:08 <johnw> indexable?
22:29:20 <shachaf> To say that a functor F is represented by a type X is to say that "F a" is isomorphic to "X -> a"
22:29:31 <shachaf> For example, Stream is representable by Nat.
22:29:31 <johnw> yeah, I've seen that definition over and over
22:29:53 <johnw> it's representable by Nat because a Stream can be indexed by a Nat position?
22:30:03 <shachaf> Right. (Nat -> x) ~ (Stream x)
22:30:06 <shachaf> s/x/a/g
22:30:06 <johnw> or am I fixating on the idea of "indexing"?
22:30:18 <shachaf> You can call it indexing if you like.
22:30:23 <shachaf> I don't think it'll either hurt or help.
22:31:18 <johnw> edwardk made a comment that I could represent a vector space as a representable functor, and I think what he meant is that "x" is my index type for the space, which will return the value for the related item in the vector (not sure about terminology there, I'm new to vector spaces)
22:31:42 <NemesisD> i'm going to have to put some work into this function yet. i like http-conduit but it is not easy to turn it into a no-exception/Either API
22:31:57 <dolio> That's backwards, though.
22:32:07 <dolio> Representable is F a ~ a -> X.
22:32:11 <johnw> so, if my vector space is {$1, 10€, 10£}, then X is the currency name and my a is the value
22:32:25 <shachaf> dolio: Oh, did I mix it up?
22:32:26 <johnw> NemesisD: use Failure
22:33:01 <shachaf> dolio: http://hackage.haskell.org/packages/archive/representable-functors/3.0.1/doc/html/Data-Functor-Representable.html seems to have (X -> a)
22:33:11 <NemesisD> johnw: i took a quick look at that, the api seemed pretty sparse, what does that get me?
22:33:13 <dolio> I know. But it's backwards.
22:33:30 <dolio> Relative to category theorists.
22:33:37 <johnw> NemesisD: if the return type is Failure String, you can case analyze differently depending on your needs
22:33:39 <shachaf> Ah, OK.
22:33:43 <shachaf> edwardk reversed it for fun?
22:34:00 <dolio> No. Just didn't know better at the time.
22:34:01 <johnw> if you analyze for Left/Right, you get an Either; if you analyze for Nothing/Just, you get a Maybe; if you are in IO, it will turn into an exception
22:34:40 <NemesisD> johnw: hmm. what do you mean by analyze in this context?
22:35:00 <shachaf> case x of Left _ -> ...; Right _ -> ...
22:35:20 <johnw> so, Failure leaves the particular representation of failure up to the user, rather than being decided by the library author
22:35:23 <dolio> This is, again, probably because category theorists care about presheaves being representable. And presheaves are C^op -> Set, or what have you.
22:35:46 <NemesisD> johnw, shachaf oh so if i change the return type to something like Either HttpException a, failure will use that?
22:35:55 <johnw> you don't have to do that, actually
22:36:07 <johnw> Failure is the only type you need to use, and its corresponding "fail" method
22:36:20 <johnw> it's a pretty slick little library, if incredibly small
22:36:27 <shachaf> NemesisD: I don't know anything about http-conduit.
22:36:35 <johnw> what it _doesn't_ give you is type-checking on possible exceptions
22:36:39 <johnw> which Either can give you
22:36:43 <dolio> Although when you move to profunctors, Ed pointed out that the terminology works better.
22:36:44 <shachaf> It sounds like a #yesod topic to me. :-) Others might disagree.
22:36:50 <NemesisD> shachaf: i see a failure method, which is e -> f v
22:36:54 <magicman> (=<<) . ana  doesn't seem as useful. Though it typechecks.
22:37:16 <dolio> Because P is representable by M if P ~ hom(-, M-), and often M is a monad.
22:37:29 * hackagebot hit 0.4.2 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.4.2 (VincentHanquez)
22:37:44 <dolio> So you often get things representable by monads and corepresentable by comonads.
22:38:03 <NemesisD> i personally despise exceptions in haskell, but since i'm writing a library i guess i have the choice of either leaving stuff in Failure (?) or only returning Eithers
22:38:46 <shachaf> i love exceptions in haskell
22:38:48 <shachaf> they are so easy
22:39:13 <NemesisD> shachaf: not sure if sarcastic
22:39:53 <NemesisD> i had to do some awful things recently to catch/handle multiple different exception types (all of which i had to discover by trial-and-error since they aren't communicated in the types anywhere)
22:40:08 * shachaf is not a huge fan of Haskell exceptions.
22:40:14 <shachaf> (But it could be worse. I think?)
22:40:34 <NemesisD> im not sure how it could be worse
22:40:41 <johnw> exceptions are a give and take
22:40:47 <NemesisD> i think maybe javascript has a worse exception system but im not sure
22:40:53 <johnw> encouraging people to write partial functions is bad
22:41:04 <johnw> forcing everyone to check return values everywhere is bad
22:41:24 <NemesisD> EitherT helped me quite a bit
22:41:35 <johnw> Either is a good balance, especially for pure code
22:41:43 <johnw> i try to only throw from IO
22:41:52 <NemesisD> but at the end of the day if i'm using a library, i'd rather confront errors when they crop up at compile time than runtime
22:42:56 <NemesisD> johnw: oh and speaking of Failure, do you happen to have any code on github or anything where you've used failure?
22:43:05 <johnw> http-conduit uses it, I believe
22:43:33 <johnw> NemesisD: http://www.haskell.org/haskellwiki/Failure
22:43:47 <johnw> see section 3
22:44:22 <johnw> a closely related library is Attempt (both are by Snoyman)
22:44:51 <johnw> attempt is more for handling things that aren't errors per es, but you want optionality with different result possibilities
22:45:34 <NemesisD> johnw: cool. i'll have a look
22:45:37 <NemesisD> thanks
22:45:46 <monochrom> "failure is not an option" "oh wait, it is"
22:46:15 <johnw> i love NP problems
22:46:16 <johnw> they are so hard
22:46:25 <nexx> lol
22:46:46 <shachaf> johnw: Don't you think that's a little overdone?
22:46:51 <johnw> LOL
22:47:00 <johnw> your wit is very dry, my friend
22:47:14 <monochrom> oh noes
22:47:32 <monochrom> I love newbies. they are so delicious
22:47:50 <johnw> i went to sleep early tonight, but the moment i grokked Representable I got too excited to stay asleep; oh Haskell, what have you done to me?
22:48:21 <monochrom> it eats your brain
22:49:24 <shachaf> johnw: Representable shouldn't keep you up -- imo it's pretty easy (i love it)
22:49:32 <johnw> that's the thing about all these abstraction
22:49:46 <johnw> you break your brain on them for days, and then when it clicks you feel almost let down by how simple they are
22:49:47 <shachaf> johnw: Next up: Representable Profunctors.
22:49:54 <monochrom> first they taught SML programmers Haskell, and you didn't speak up, because you were not an SML programmer. then they taught Smalltalk programmers Haskell, and you did not speak up, because...
22:49:56 <johnw> oh, nice
22:49:58 <johnw> where can I read?
22:50:01 <shachaf> It's actually simpler than representable functors.
22:50:10 <monochrom> by the time they taught you Haskell, everyone else already knew Haskell :)
22:50:13 <shachaf> p is representable by f if p a b ~ a -> f b
22:50:25 <johnw> nice
22:50:35 <johnw> i almost want to call it Kleisli Representation :)
22:51:05 <shachaf> Kleisli m is representable by m, sort of.
22:53:12 <johnw> dolio: isn't a representable functor f a ~ x -> a?
22:53:20 <johnw> you wrote f a ~ a -> x
22:53:25 <NemesisD> oh interesting, control-monad-exception adds a full list of throwable exceptions in a function's type
22:53:27 <shachaf> johnw: See the following discussion.
22:53:49 <johnw> ah, got it
22:54:39 <johnw> so in my vector space example, {$1, 10€, 10£}, a is the commodity and it would be called a vector space over commodities?
22:57:08 <monochrom> I prefer {$10, 1€, 1£}
22:57:53 <johnw> i'm not sure there's a vector space operation that will get you there... :)
23:19:15 <johnw> shachaf: is there a type class Foo f a with methods wrap :: a -> f a and unwrap :: f a -> a?
23:19:35 <johnw> or am I just fusing monad and comonad?
23:19:57 <shachaf> Lens has Settable
23:20:04 <shachaf> Well, Settable really means (~ Identity)
23:20:05 <johnw> how does that relate?
23:20:08 <shachaf> Well, not quite.
23:20:19 <shachaf> ?
23:20:30 <johnw> i don't get how what you said connects to what I said
23:20:38 <shachaf> Which thing?
23:20:46 <johnw> shachaf: is there a type class Foo f a with methods wrap :: a -> f a and unwrap :: f a -> a?
23:20:54 <shachaf> Which thing I said?
23:20:59 <johnw> Lens has Settable
23:21:09 <johnw> Settable only has untainted
23:21:12 <johnw> not "tainted"
23:21:13 <shachaf> Well, Settable has methods :: a -> f a and :: f a -> a
23:21:28 <shachaf> pure :: Settable f => a -> f a
23:21:32 <johnw> ah
23:21:47 <johnw> that's not part of the type class, ok
23:22:07 <shachaf> Yes it is. :-)
23:22:24 <johnw> well, not in the 3.7.3 docs I'm looking at
23:23:14 <shachaf> I see "class Applicative f => Settable f where"
23:23:28 <johnw> i see 3 methods
23:23:41 <johnw> untainted, untainted@, tainted@
23:24:10 <shachaf> And a superclass.
23:24:10 <johnw> oh, can I have type class that takes a constraint as a parameter?
23:24:18 <johnw> oh, that's right, sorry
23:24:41 <johnw> I would like: class Foo c a where foo :: c a => a
23:24:48 <johnw> is that possible?
23:25:03 <johnw> a type class that can take another type class as argument...
23:25:33 <shachaf> λ> class Foo c a where foo :: c a => a
23:25:33 <shachaf> λ>
23:25:38 <shachaf> It seems that ghci accepts it.
23:25:50 <shachaf> Why are you asking me rather than ghci? It's much more efficient at this sort of thing. :-)
23:26:20 <johnw> ah, you just need ConstraintKinds
23:26:28 <johnw> i dunno, sometimes I get shachaf-lazy
23:30:32 <monochrom> I love asking shachaf, it's so hard :)
23:45:45 <spacekitteh> if i have deltaT::Double, how do i make a sequence of increments of it? [0,deltaT,..] doesn't work :/
23:46:21 <spacekitteh> oh no second comma
23:46:30 <shachaf> iterate (+deltaT) 0 would also work.
