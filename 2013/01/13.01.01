00:08:44 <Lethalman> cmccann, hi I'm using mersenne-random this time that seem to work well
00:09:09 <Lethalman> cmccann, except that now x <- sequence $ repeat getDouble will be strict, thus I can't work with sequenced lazy lists
00:09:32 <Lethalman> why is that?
00:09:40 <cmccann> to be fair, laziness hasn't been doing you a lot of favors to day :[
00:09:53 <Lethalman> ahah
00:09:55 <cmccann> anyway, I'm not sure how mersenne-random works
00:11:21 <cmccann> using lazy lists is probably not ideal for you anyway, since you really do need to sequence the list somehow
00:11:57 <cmccann> and anything lazy enough to not do all the work when you sequence it is potentially going to also cause the same sort of problems you had earlier
00:12:02 <Lethalman> cmccann, I'd like a sequenced lazy list
00:12:12 <Lethalman> mh
00:12:28 <Lethalman> that means I have to rewrite everything in terms of foldlM & co
00:12:36 <cmccann> well, sequence has to traverse the whole list
00:12:47 <cmccann> it really can't be lazy
00:13:24 <cmccann> the only reason you could get a lazy list before is that it only needed the list but left the actual RNG stuff unevaluated
00:13:39 <Lethalman> why not? wouldn't it be something similar to map?
00:13:40 <Lethalman> @src sequence
00:13:40 <lambdabot> sequence []     = return []
00:13:40 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:13:40 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
00:14:13 * hackagebot cipher-aes128 0.1 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.1 (ThomasDuBuisson)
00:14:15 * hackagebot commsec 0.1 - Communications security  description: A basic communications security package that provides confidentiallity, integrity and replay detection.  http://hackage.haskell.org/package/commsec-0.1 (ThomasDuBuisson)
00:14:46 <Lethalman> cmccann, my idea is that you can get sample by sample anyway by evaluating the rng stuff
00:14:54 <cmccann> not really--sequence goes from [m a] to m [a], so it has to combine all the monadic actions from the list
00:15:17 <cmccann> what do you mean?
00:16:19 <Lethalman> cmccann, I see what you mean, somehow
00:16:29 <cmccann> (personally in your case I'd write something similar to foldlM that did exactly the kind of loop I wanted)
00:17:03 <Lethalman> cmccann, what I mean is: isn't there a mix between StdGen and this mersenne?
00:17:27 <Lethalman> where sequence would return a lazy list
00:17:39 <cmccann> beats me, sorry. you're outside the area of stuff I'm familiar with.
00:17:48 <cmccann> never used anything other than MonadRandom for stupidly simple stuff
00:18:00 <Lethalman> isn't that monads in general?
00:18:46 <cmccann> nah, your issue is pretty specific to State-like monads
00:19:15 <cmccann> in other monads it's a non-issue either because everything is strict always or it's lazy in a simpler way
00:20:07 <cmccann> e.g., if you were just using IO everywhere it would do everything no matter what when you used sequence
00:20:31 <cmccann> or if you were using lists of possibilities for your random distributions you'd have lazy lists everywhere
00:20:55 <Lethalman> foldlM (liftM . (\a _ -> a+1)) 0 samples is fine btw
00:21:23 <cmccann> what might be better suited to how you want to do this is to not use lists at all, but a monadic stream
00:21:54 <cmccann> which is basically a data structure version of what foldrM does, the same way a list corresponds to foldr
00:22:38 <cmccann> but I'm not sure what would be a good library to suggest for that, heh
00:23:57 <cmccann> anyway, I'm afraid it's 3:20am here and I really should be getting to bed :[
00:24:08 <cmccann> er, 3:20
00:24:25 <cmccann> wait I did type it right the first time
00:24:33 <cmccann> ok heh I clearly need sleep :T
00:24:36 <hpaste> randomclown pasted “<<loop>>” at http://hpaste.org/80046
00:25:00 <randomclown> can somebody else try and compile that with ghc and see if they get <<loop>> as the output instead of an integer?
00:25:31 <shachaf> If you're getting <<loop>>, presumably other people will too.
00:26:01 <shachaf> You have an unboxed array whose cells are defined in terms of itself.
00:26:08 <shachaf> Why wouldn't that <<loop>>?
00:26:30 <shachaf> "-- change to Data.Array fixes this" -- so what's the problem? :-)
00:26:35 <randomclown> wy
00:26:37 <randomclown> why*
00:26:43 <Lethalman> cmccann, thank you :)
00:26:47 <shachaf> Because an unboxed array is strict.
00:27:02 <randomclown> that should be a compile time error should it not?
00:27:42 <cmccann> Lethalman, yeah, sorry I couldn't help more :[
00:27:43 <shachaf> Why?
00:27:49 <shachaf> let x = x in x isn't a compile-time error.
00:27:54 <Lethalman> cmccann, np
00:28:03 <cmccann> you should bother shachaf instead, he's very helpful :D
00:28:16 <shachaf> hi cmccann
00:28:18 <cmccann> :D
00:28:26 <shachaf> 17:58 <cmccann> shachaf is in charge of rendering irrelevant moral judgments about various programming constructs
00:28:36 <shachaf> You don't want to bother me.
00:28:42 <cmccann> hahahaha
00:28:45 <tgeeky> (but don't bother tgeeky, he's drunk and otherwise unhelpful anyway)
00:29:00 <randomclown> so what is <<loop>> supposed to mean?
00:29:13 <shachaf> It means you have something defined in terms of itself.
00:29:37 <shachaf> Well, I suppose that' a bit vague.
00:30:04 <tgeeky> throw in the word 'unboxed'?
00:30:21 <shachaf> You can get <<loop>> without unboxing.
00:30:34 <shachaf> In fact you usually do.
00:30:43 <lispy> randomclown: GHC's runtime has a special case for programs that don't make progress (in a specific way) and errors out when it encounters them
00:30:56 <shachaf> randomclown: Do you know how that Array thing works with the normal Array?
00:31:01 <tgeeky> that sounds better, corrector, but still ambiguious
00:31:02 <shachaf> As in, how it gets evaluated.
00:31:58 <lispy> tgeeky: a flag is set when thunks are entered (or was it exited?) and when the rts enters a thunk that has the flag set it knows none of the state has changed since the previous entry ==> infinite loop.
00:32:09 <lispy> tgeeky: it's more concrete, but is it a better explanation?
00:32:29 <randomclown> So you are supposed to just import Data.Array, instead of Data.Array.Unboxed?
00:33:32 <randomclown> shachaf: how does the "Array thing" work with the normal Array?
00:34:09 <Lethalman> so, anybody can explain me why a foo <- sequence $ repeat getDouble (where getDouble is from mersenne random) would be evaluated strictly instead of returning a lazy list?
00:34:21 <Lethalman> in general, why is that with monads?
00:35:11 <lispy> Lethalman: different monads have different strictness properties.
00:35:45 <lispy> randomclown: I looked at your example. I wish I knew what the difference between the Unboxed and boxed variants is. Interesting case.
00:35:47 <Lethalman> lispy, ok, but I don't understand why it's not possible to evaluate step by step anyway
00:36:08 <cyphase> Happy PST New Year!
00:36:09 <lispy> :src sequence
00:36:13 <lispy> ?src sequence
00:36:14 <lambdabot> sequence []     = return []
00:36:14 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:36:14 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
00:36:19 <lispy> cyphase: happy new year!
00:36:41 <lispy> Lethalman: what monad is that? the IO monad?
00:36:42 <Lethalman> for example [getDouble, getDouble] why isn't it possible to get the first double... then the second double
00:36:44 <randomclown> In any case, the documentation on Data.Array.Unboxed states that it should be imported instead of Data.Array
00:36:46 <Lethalman> lispy, mersenne random
00:37:14 <lispy> Lethalman: I'm vaguely familiar with that library, but not the type of getDouble
00:37:26 <ion> shachaf: Yeah… Any ideas about how to make it better?
00:37:58 <lightquake> hm
00:38:17 <shachaf> ion: ?
00:38:31 <lispy> Lethalman: you could use an unsafeInterleaveIO here (I think even safely)...
00:38:46 <lightquake> Lethalman: it's *possible*, but that's not the semantics of the IO monad
00:38:59 <Lethalman> lightquake, I'm not using IO, it's mersenne random
00:39:21 <lightquake> what package?
00:39:31 <lightquake> in other words, what monad are you sequencing over?
00:39:32 <Lethalman> lightquake, mersenne random
00:39:32 <lispy> Lethalman: I can't find getDouble in that package
00:39:33 <Lethalman> :)
00:39:44 <Lethalman> let me see
00:39:46 <ion> shachaf: remit . base
00:39:56 <lispy> Lethalman: http://hackage.haskell.org/packages/archive/mersenne-random/1.0.0.1/doc/html/System-Random-Mersenne.html ?
00:40:13 <shachaf> ion: Well, an infix operator for review would be enough, wouldn't it?
00:40:51 <Lethalman> lispy, lightquake, http://hackage.haskell.org/packages/archive/monad-mersenne-random/0.1/doc/html/Control-Monad-Mersenne-Random.html
00:41:12 <Lethalman> regardless of the monad, why isn't it possible to stream over every monad?
00:41:31 <Lethalman> since the first item of the list is independent from the second item
00:41:44 <lightquake> Lethalman: because in this case you're carrying around the state of the RNG
00:41:50 <ion> shachaf: I suppose so, although having an operator for everything, out of which only a part is based on naming conventions, isn’t perfect either.
00:42:01 <shachaf> Because executing "foo :: m [a]" executes some effects and then yields a value.
00:42:03 <Lethalman> lightquake, let me understand
00:42:09 <shachaf> ion: Well, review is one of the fundamental operations.
00:42:14 <Lethalman> lightquake, if I evaluate the first, then I can't evaluate the second?
00:42:24 <Lethalman> I have to evaluate them both?
00:42:40 <lightquake> no, you can choose to only evaluate the first one
00:42:46 <lightquake> but you can't choose to only evaluate the second
00:42:59 <Lethalman> lightquake, I want to evaluate the first... then the second... on demand
00:43:03 <Lethalman> that is, a lazy list
00:43:41 <lightquake> and 'foo <- sequence $ repeat getDouble' hangs?
00:43:43 <lispy> Lethalman: Let's say you can generate this lazy list. each new element will force side-effects (potentially)
00:43:51 <Lethalman> lightquake, I'm doing foldlM (liftM . (satisfyCount satisfy)) 0 samples where I'd like to sequence samples >>= \xs -> length $ filter (satisfyCount) xs
00:44:10 <Lethalman> lightquake, yes it hangs
00:44:23 <shachaf> Lethalman: Take some concrete monad like Maybe.
00:44:31 <lightquake> hm
00:44:48 <shachaf> sequence :: [Maybe a] -> Maybe [a] will give you a Nothing if any element of the list is Nothing.
00:44:54 <shachaf> There's no way that can stream, right?
00:45:11 <Lethalman> shachaf, ok
00:45:51 * lispy notes that unsafeInterleaveIO (and variants) would work here if one does not mind asynchronous exceptions
00:46:02 <Lethalman> shachaf, thanks, so just to understand
00:46:02 <Lethalman> shachaf, System.Random has StdGen = StdGen Int32 Int32, and I can have lazy lists
00:46:07 <aristid> lispy: ugh
00:46:11 <Lethalman> but the problem with System.Random is not the monad but the generator itself
00:46:25 <Lethalman> because it's not StdGen !Int32 !Int32
00:46:43 <Lethalman> now, would a mix between System.Random and mersenne random exist?
00:46:55 <Lethalman> that is, a generator with bangs, and a monad that let me have lazy lists
00:47:19 <aristid> Lethalman: well there are packages that generalize System.Random. System.Random itself is limited to what it is.
00:48:13 <Lethalman> I was going to create a RandomGen instance with my StdGen that use bangs, then stopped by mersenne
00:56:53 <beaky> hello
00:57:08 <beaky> what is lazy evaluation?
00:58:02 <zomg> baby don't hurt me
00:58:04 <zomg> don't hurt me
00:58:06 <zomg> no more
00:58:15 <beaky> lol
00:58:53 <zomg> anyway, lazy evaluation just means that whatever you write isn't executed immediately, but only at the time when the result of that computation is needed for something else
01:01:06 <ion> beaky: Evaluating fst ("foo", "bar") doesn’t cause the "bar" to be evaluated. Evaluating take 20 [0..] doesn’t cause an infinite list to be evaluated.
01:02:22 <zomg> Anyone happen to know if there's some definition of how Haskell behaves in terms with lazy evaluation?
01:02:46 <zomg> I mean if I write some IO, does it actually apply to that as well, or is there some exceptions where it may or may not apply
01:02:55 <zomg> I know that strict versions of functions won't lazily evaluate
01:03:08 <beaky> so a thing that will terminate in a non-strict language will not necessarily terminate in a strict one?
01:03:17 <beaky> how do I strictify things in haskell?
01:03:46 <ion> beaky: With things like seq and !-patterns.
01:04:27 <ion> > error "seq causes this to be evaluated" `seq` "whenever this is evaluated"
01:04:31 <lambdabot>   mueval-core: Time limit exceeded
01:04:33 <ion> > error "seq causes this to be evaluated" `seq` "whenever this is evaluated"
01:04:35 <lambdabot>   "*Exception: seq causes this to be evaluated
01:04:58 <ion> > let f a = 42 in f undefined
01:04:59 <lambdabot>   42
01:05:01 <ion> > let f !a = 42 in f undefined
01:05:02 <lambdabot>   *Exception: Prelude.undefined
01:05:09 <beaky> so seq is some implementation magic that always evaluates its first argument/
01:05:23 <beaky> > 1 `seq` [1..]
01:05:24 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:05:41 <beaky> > [1..] `seq` 1
01:05:43 <lambdabot>   1
01:05:54 <beaky> O.o
01:05:58 <ion> It’s a primitive operation, yeah.
01:06:07 <beaky> what does seq mean?
01:06:17 <beaky> sequence?
01:06:22 <lightquake> i think so
01:06:36 <lightquake> [03:05:25] <beaky>	 > [1..] `seq` 1
01:06:43 <lightquake> 'evaluate' doesn't mean it evaluates the entire thing
01:06:51 <lightquake> just enough to check whether it's undefined or not, so to speak
01:07:02 <lightquake> > repeat undefined `seq` 1
01:07:04 <lambdabot>   1
01:08:39 <ion> seq only causes the evaluation of the first argument to WHNF. http://stackoverflow.com/a/6889335/584163
01:08:45 <ion> > [1..] `deepseq` 1
01:08:47 <lambdabot>   Not in scope: `deepseq'
01:08:47 <lambdabot>  Perhaps you meant `rdeepseq' (imported from Contro...
01:08:59 <ion> Ah, lambdabot doesn’t import that.
01:09:57 <ion> > length [1..] `seq` 1  -- should timeout
01:10:03 <lambdabot>   mueval: ExitFailure 1
01:10:03 <lambdabot>  mueval: Prelude.undefined
01:10:12 <lightquake> … what?
01:10:17 <aristid> :t rdeepseq
01:10:22 <lambdabot> NFData a => Strategy a
01:10:23 <lightquake> > length [1..] `seq` 1
01:10:27 <lambdabot>   mueval-core: Time limit exceeded
01:10:59 <aristid> lightquake: ion just demonstrated exactly that. didn't believe him?
01:11:15 <lightquake> no, i was just wondering why it exited with ExitFailure 1
01:11:37 <ion> I was wondering about the same thing.
01:11:50 <ion> But it’s not as if lambdabot is deterministic.
01:12:08 <beaky> lambdabot likes monoids
01:12:29 <shachaf> who doesn't?
01:12:57 <beaky> maybe object-oriented programmers don't :D
01:13:10 <ion> They use monoids, too.
01:13:14 <shachaf> :D
01:13:19 <ion> Some of them just don’t know it.
01:14:10 <beaky> object-oriented languages are like blub
01:14:18 <beaky> they prevent you from looking at things at a higher level
01:15:26 <zomg> beaky: you don't have enough design patterns if they prevent you from doing that!
01:15:56 <beaky> design patterns pop up when a language lacks proper first-class functions
01:17:45 <ion> beaky: Any language can be blub. Including Haskell.
01:18:58 <beaky> haskell might look like blub to Agda programmers
01:19:02 <ion> Also, OOP languages can be not blub. Blub is about people, not languages.
01:19:02 <Saizan> more generally a design pattern is needed when the language doesn't have a way to abstract over something
01:20:01 <Saizan> and that happens in all the languages i know of
01:20:51 <beaky> even haskell?
01:21:57 <b_> can a non polymorphic type be made am instance of Functor?
01:23:03 <ion> b: No, but lenses can help.
01:23:54 <b_> yeah, with lenses I have been able to define fmap/fold-like functions
01:24:10 <thoughtpolice> beaky: sure. before ghc 7.4, you couldn't abstract over kinds/constraints. this led to awkward hacks like Typeable1, and not being able to index constraints. for things that haven't been fixed, modules are an example, which probably have countless real ramifications
01:24:23 <beaky> ah
01:24:41 <Peaker_> only ghc7.6 fixes the Typeable1 thing, doesn't it?
01:25:22 <thoughtpolice> 7.4 has kind polymorphism, but no polymorphic kind *signatures*. using Proxy GHC can infer the correct polymorphic kind, but you can't -say- that in 7.4
01:25:37 <thoughtpolice> so overall 7.6 is just better :P
01:25:50 <b_> ion, are there any specific ways lens can help me define those kinds of instances?
01:26:03 <Peaker_> so 7.4 already solved the Typeable thing? I'm pretty sure it didn't because I couldn't derive Typeable for my types that had (*->*) params in 7.4
01:26:05 <shachaf> thoughtpolice: I like the thing where GHC calls every kind variable "k"
01:26:18 <thoughtpolice> k is the best variable, obviously.
01:26:23 <maky> why is :t [1]  Num a => [a]   but let a = [1]  :t a  becomes less general [Integer] ?
01:26:28 <shachaf> λ> data Foo k a
01:26:28 <shachaf> λ> :i Foo
01:26:28 <shachaf> data Foo k k k a 	-- Defined at <interactive>:2:6
01:26:50 <shachaf> b_: I think ion meant to use a lens instead of an instance.
01:27:05 <b_> ah ok, yeah
01:27:07 <shachaf> Though you might be able to use Each, or something like that.
01:27:15 <thoughtpolice> Peaker_: that's a bug in IIRC, which is part of the deriving mechanism that i'd classify as seperate. there are also bugs for deriving this kind of stuff for Generic, etc
01:27:19 <shachaf> (That's not in 3.7, though, I think.)
01:27:26 <b_> I use HEAD
01:27:56 * shachaf wonders whether the Derive{Functor,Foldable,Traversable} fix will go into GHC 7.6.2
01:28:24 <BMeph> maky: Defaults.
01:28:31 <thoughtpolice> shachaf: you should petition for it!
01:28:37 <shachaf> thoughtpolice: How do I petition for it?
01:28:56 <thoughtpolice> complain on the ticket, worst/loudest case, petition on the bug tracker
01:28:59 <shachaf> SPJ was very surprised by the bug's existence; everyone I talked to about it agreed that it was bad; twanvl wrote a patch that fixed it.
01:29:06 <shachaf> So now the state is "patch".
01:29:09 <thoughtpolice> i think RCs for 7.6.2 went out already, so you should do it now
01:29:13 <shachaf> What next?
01:29:17 <thoughtpolice> shachaf: yes, i saw that bug; the eta reduction one right?
01:29:23 <shachaf> Yep.
01:29:36 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/7436
01:29:37 <lightquake> which bug is this?
01:29:41 <thoughtpolice> shachaf: Igloo will merge it hopefully. but i asked him to merge another patch of mine a week or so ago and he said he wouldn't get to it until after the new year
01:29:41 <lightquake> ah
01:29:47 <shachaf> Oh, SPJ replied.
01:29:48 <yitz> > [[1..]] `seq` 42
01:29:50 <lambdabot>   42
01:29:52 <thoughtpolice> you might have better luck asking SPJ
01:29:53 <yitz> > let deepseq = seq . withStrategy rdeepseq in [[1..]] `deepseq` 42
01:29:57 <lambdabot>   mueval-core: Time limit exceeded
01:30:00 <thoughtpolice> he merged my patch the next day after i asked
01:30:00 <shachaf> I didn't see his reply.
01:30:44 <thoughtpolice> er, loudest case is petition on the *mailing list*.
01:30:46 * thoughtpolice is tired
01:31:25 <shachaf> thoughtpolice: I also have a patch for Traversable/Foldable instances that should go into base (not for 7.6.2, though) that I should probably submit to Igloo.
01:31:30 <shachaf> Mostly I did it because no one else is.
01:31:43 <thoughtpolice> what does it do?
01:32:25 <shachaf> Instances for (e,), (Either e), and Const e, I think.
01:32:31 <davorak> How would I, or what would I need to compose an arbitary number of lifts? Something like foldl1 (.) [lift, lift]?
01:32:56 <shachaf> Right now we orphan them in lens.
01:33:15 <shachaf> davorak: That won't work because all the functions in the list need to have the same type.
01:34:25 <maky> is there no way to keep generic Num type after assigning 1 to a variable? that kind of sucks.  let a = 1; :t a is [Integer] instead of Num a => a  like :t 1
01:34:54 <davorak> shachaf: Ok that makes sense. What is the smart way of going about it then? Template haskell, HList?
01:35:06 <thoughtpolice> maky: use -XNoMonoLocalBinds
01:35:11 <maky> s/[Integer]/Integer
01:35:27 <shachaf> davorak: That depends on what you're trying to do.
01:35:37 <shachaf> maky:
01:35:39 <shachaf> @where dmr
01:35:39 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
01:36:41 <thoughtpolice> maky: i think. it depends on what you're doing, but in general GHC does not generalize let bindings to have the most general type.
01:36:55 <thoughtpolice> you can fix this by just adding an annotation, IIRC
01:37:26 <shachaf> Adding an explicit signature is always good.
01:37:30 <shachaf> But it's a bit of a hassle in ghci.
01:37:51 <lightquake> what's the d in dmr?
01:38:41 <davorak> shachaf: I was trying to create a function that would lift and execute(right terminology?) through an arbitary number of proxy(pipes 3.0) layers.
01:39:15 * hackagebot dynamic-object 0.1.0.0 - Object-oriented programming with singleton methods  and duck typing.  http://hackage.haskell.org/package/dynamic-object-0.1.0.0 (TakayukiMuranushi)
01:41:56 <yitz> shachaf: nice bug!
01:43:11 <yitz> lightquake: dreaded
01:44:17 * hackagebot dynamic-object 0.1.0.1 - Object-oriented programming with singleton methods  and duck typing.  http://hackage.haskell.org/package/dynamic-object-0.1.0.1 (TakayukiMuranushi)
02:12:57 <Lethalman> how do I call "edges g" where g is a DynGraph?
02:14:06 <Lethalman> it gives me this error:http://paste.debian.net/220770/
02:14:19 <Lethalman> ivanm, ^^ any clue? :)
02:16:05 <ivanm> you should be able to
02:16:06 <ivanm> code?
02:16:39 <Lethalman> ivanm, ah ok I had to subg :: Gr String ()
02:17:01 <ivanm> oh, there weren't any types?
02:17:13 <Lethalman> ivanm, edges subg where subg = buildGr listOfContexts
02:17:42 <ivanm> that should work though, since DynGraph implies Graph
02:18:48 <Lethalman> > let foo = edges subg where subg = buildGr []
02:18:52 <lambdabot>   mueval-core: Time limit exceeded
02:18:53 <ivanm> oh, I think I know why; it doesn't know which DynGraph instance to pick
02:19:09 <ivanm> so yes, you need to give subg a type
02:19:16 * hackagebot sym 0.4.2 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.4.2 (AndersClaesson)
02:19:27 <ivanm> same as why "show . read" doesn't work
02:19:27 <Lethalman> ivanm, but anyway, whatever instance it is, it's still constrained to be DynGraph and thus Graph, isn't it?
02:19:31 <ivanm> yes
02:19:38 <ivanm> @type show . read
02:19:46 <lambdabot> String -> String
02:19:55 <ivanm> > (show . read) "2"
02:19:58 <lambdabot>   mueval-core: Time limit exceeded
02:21:13 <Lethalman> > let foo = edges subg where subg = buildGr []
02:21:14 <lambdabot>   not an expression: `let foo = edges subg where subg = buildGr []'
02:21:29 <Lethalman> > let subg = buildGr [] in edges subg
02:21:30 <lambdabot>   Not in scope: `buildGr'
02:21:30 <lambdabot>  Perhaps you meant `buildG' (imported from Data.Gra...
02:22:27 <Lethalman> ivanm, but between Show and Read there is no relation, right?
02:22:40 <ivanm> right
02:22:54 <ivanm> I've had similar issues in other code I was writing; it can be a pain
02:23:18 <Lethalman> show . read has a type at least
02:23:24 <Lethalman> edges . buildGr doesn't compile
02:23:28 <ivanm> that's why in the graph example in their paper on type families, SPJ et al tag the Edge type with the Graph type it comes from
02:24:13 <Lethalman> in other words, haskell can't choose between Graph and DynGraph for the resulting function type?
02:25:28 <ivanm> no
02:25:34 <ivanm> it can't choose the DynGraph instance to use
02:26:04 <ivanm> the error message is admittedly rather weird
02:26:21 <Lethalman> ivanm, ah the problem is in buildGr [] itself
02:26:25 <ivanm> it's analogous to the "show . read" example: it doesn't know how to read the value to be able to show it
02:26:26 <Lethalman> got it
02:26:45 <Lethalman> buildGr [] doesn't know what instance to use, regardless of "edges"
02:26:53 <ivanm> yes
02:27:05 <ivanm> if you returned the graph, it'd be OK, because it could figure out the context from how you called it
02:27:16 <Lethalman> right
02:27:35 <Lethalman> ivanm, I just thought buildGr would have been using an internal default type for creating the graph
02:27:36 <ivanm> but by immediately calling it with edges - and not having an intermediate result - it doesn't know which DynGraph instance to use (and hence which Graph instance)
02:27:48 <ivanm> Lethalman: nope; it uses & and empty under the hood
02:28:03 <Lethalman> alright
02:30:32 <Lethalman> is there a function Bool -> a -> Maybe a already such that if bool then Just a else a ? searched hoogle without any results ;)
02:30:38 <Lethalman> ops
02:30:39 <Lethalman> else Nothing
02:33:30 <Saizan> the closest i know of is guard
02:36:26 <ivanm> define a fold over Booleans such that (depending on your ordering): bool (const Nothing) Just ?
02:36:55 <Lethalman> \o/ that's too advanced for me
02:37:36 <ivanm> bool f t b = if b then t else f
02:38:15 <Lethalman> ivanm, yes just wanted to know if there's something like that already
02:38:26 <Lethalman> also, is there anything like mapMaybeM ?
02:38:39 <ivanm> @type Data.Traversable.mapM
02:38:40 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
02:38:57 <Lethalman> that's only map
02:39:14 <ivanm> yes, but on a Maybe
02:39:16 * hackagebot wai-extra 1.3.1.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.1.1 (MichaelSnoyman)
02:39:18 * hackagebot conduit 0.5.6 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.6 (MichaelSnoyman)
02:39:25 <Lethalman> ivanm, but mapMaybe also filters
02:39:28 <ivanm> one of the Traversable functions might be able to do something like that
02:39:31 <ivanm> Lethalman: no, not mapMaybe
02:40:08 <ivanm> no, it won't take your Bool constraint
02:40:30 <Lethalman> ivanm, I'm sorry but the description is a filter/map
02:40:37 <ivanm> yes, but over a Maybe, not over a list
02:40:59 <Lethalman> :t mapMaybe
02:41:00 <lambdabot> (a -> Maybe b) -> [a] -> [b]
02:41:12 <Lethalman> ^ this, but for a [m a]
02:41:15 <ivanm> here, t = Maybe
02:41:22 <Lethalman> ivanm, but that will only map, and not filter
02:41:25 <ivanm> so it's (Monad m) => (a -> m b) -> Maybe a -> m (Maybe b)
02:41:31 <Lethalman> no
02:41:31 <ivanm> well, yes
02:41:40 <ivanm> it doesn't do what you want
02:41:42 <ivanm> I realise that
02:41:49 <ivanm> I forgot you wanted to use a Bool
02:42:30 <Lethalman> i'd like (Monad m) => (a -> m Maybe b) -> t a -> m (t b)
02:43:16 <ivanm> that doesn't even make sense
02:44:05 <ivanm> @hoogle when
02:44:05 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
02:44:05 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
02:44:05 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
02:44:21 <Lethalman> why not?
02:44:25 <ivanm> @when False (return 3) :: Maybe Int
02:44:25 <lambdabot> Maybe you meant: what where wn
02:44:29 <ivanm> > when False (return 3) :: Maybe Int
02:44:30 <lambdabot>   Couldn't match expected type `GHC.Types.Int' with actual type `()'
02:44:37 <ivanm> Lethalman: "m Maybe b" isn't valid
02:44:43 <ivanm> > when False (return ()) :: Maybe ()
02:44:44 <Lethalman> m (Maybe b)
02:44:44 <lambdabot>   Just ()
02:44:54 <ivanm> OK, that makes more sense
02:45:01 <ivanm> but what do you expect it to do?
02:45:15 <chreekat> and what's t?
02:45:21 <ivanm> chreekat: a Traversable
02:45:35 <ivanm> Lethalman: I wonder whether either a Monoid or MonadPlus function will do what you want
02:45:55 <Lethalman> ivanm, the same as mapMaybe but for an [m a] rather than an [a]
02:46:06 <Lethalman> like mapM is for map, mapMaybeM would be for mapMaybe
02:46:10 <ivanm> why do you want a Monad suddenly in there?
02:46:11 <Lethalman> as simple as that
02:46:26 <ivanm> @type \ f -> sequence . mapMaybe f
02:46:28 <lambdabot> Monad m => (a1 -> Maybe (m a)) -> [a1] -> m [a]
02:46:36 <Lethalman> ivanm, I have an [m a] that I want to filter and map
02:46:52 <Lethalman> I can of course do map filterM
02:46:55 <ivanm> @type \ f -> liftM catMaybes . mapM f
02:46:56 <lambdabot> Monad m => (a1 -> m (Maybe a)) -> [a1] -> m [a]
02:47:24 <ivanm> you were talking about a Bool before though
02:47:52 <Lethalman> aww
02:47:52 <Lethalman> \o/ what's that :P
02:47:52 <Lethalman> @src catMaybes
02:47:52 <Lethalman> :t catMaybes
02:47:52 <lambdabot> catMaybes ls = [x | Just x <- ls]
02:47:53 <Lethalman> asked too much sorry :S
02:47:53 <lambdabot> [Maybe a] -> [a]
02:48:06 <Lethalman> ivanm, if foo then Just bar else Nothing
02:48:08 <chreekat> @type \ f -> fmap (mapMaybe f) . sequence
02:48:09 <lambdabot> (Monad f, Functor f) => (a -> Maybe b) -> [f a] -> f [b]
02:48:28 <ivanm> Lethalman: but within a Monad as well?
02:49:02 <Lethalman> ivanm, yes I'm in a function [(a, Double)] -> Rand [a]
02:49:19 <ivanm> so why bother with the Maybe if you just want to use it as a filter?
02:49:33 <Lethalman> ivanm, filter+map = mapMaybe
02:49:34 <ivanm> @hoogle mfilter
02:49:34 <lambdabot> Control.Monad mfilter :: MonadPlus m => (a -> Bool) -> m a -> m a
02:49:34 <lambdabot> package bloomfilter
02:49:43 <Lethalman> in a single pass
02:49:54 <ivanm> Lethalman: premature optimisation!
02:50:01 <Lethalman> ...
02:50:03 <Lethalman> oh please
02:50:12 <ivanm> especially when you compile with optimisations and fusion removes the intermediate list anyway
02:50:41 <Lethalman> I don't think I would be the only one to use a mapMaybeM
02:51:39 <Lethalman> also it's not about optimization, I'd want to know if there's such a mapMaybeM that's it
02:51:39 <Lethalman> apparently not, let me see catMaybes
02:51:42 <ivanm> Lethalman: does your actual filtering require the Monad?
02:51:52 <Lethalman> ivanm, yes because I call getDouble
02:52:02 <Lethalman> which is a Rand Double
02:52:09 <ivanm> so you randomly pick whether to keep a value or not? OK
02:52:35 <Lethalman> yes
02:52:38 <ivanm> I think a liftM map . filterM will suit your needs much better though
02:52:57 <Lethalman> yes that's what I'm going to do, except mapMaybeM would do the same that's it
02:53:09 <Lethalman> I don't care about optimization, just to know if it's possible
02:54:29 <ivanm> sure, it's possible
02:55:37 <Lethalman> ivanm, ok now I'm trying to understand something :P
02:55:54 <Lethalman> filterM (\(_,p) -> getDouble <= p) inputs
02:56:01 <Lethalman> of course getDouble <= p is broken
02:56:56 <ivanm> liftM (<=p) getDouble
02:57:10 <Lethalman> thought about something like that with liftM :S
02:58:02 <Lethalman> :t liftM (<=2)
02:58:03 <lambdabot> (Monad m, Num a1, Ord a1) => m a1 -> m Bool
02:59:07 <Lethalman> :t liftM (<=)
02:59:08 <lambdabot> (Monad m, Ord a1) => m a1 -> m (a1 -> Bool)
03:00:41 <ivanm> if Rand is an instance of Functor, you can also do: (<=p) <$> getDouble
03:02:14 <Lethalman> ivanm, unfortunately not :)
03:06:54 * Lethalman satisfied for now :)
03:07:02 <Lethalman> thanks for the help
03:07:45 <ivanm> np
03:08:45 <aar> hmm. are there really no working r-tree or quadtree packages on hackage?
03:09:17 * hackagebot graphviz 2999.15.0.1 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.15.0.1 (IvanMiljenovic)
03:10:51 <ivanm> aar: there's some quadtree implementations if memory serves
03:10:55 <ivanm> don't know about r-trees
03:11:09 <aar> all i found for quadtree was http://hackage.haskell.org/package/spacepart
03:11:13 <ivanm> aar: http://www.holumbus.org/hayoo/hayoo.html?query=quadtree
03:11:47 <niez> where can I find Data.Tree and Data.Tree.Zipper examples?
03:12:58 <aar> ivanm: thanks, i'll take a look at the code from gloss
03:13:13 <ivanm> niez: in what sense do you want examples?
03:13:35 <niez> example usage
03:13:50 <ivanm> Data.Tree is rather simple...
03:13:52 <ivanm> @src Tree
03:13:52 <lambdabot> Source not found. I am sorry.
03:14:11 <ivanm> from memory, data Tree a = Node a [Tree a]
03:16:11 <niez> ivan, it's not so simple when you are coming into haskell from c++
03:21:38 <ivanm> niez: well, what were you wanting to do with Data.Tree?
03:21:55 <ivanm> I mean, I've got code that uses it, but if you don't have much Haskell experience I don't know how much you'd understand
03:22:23 <ivanm> but simplistically: a Tree is defined as a Node containing a value, and a (possibly empty) list of sub-trees
03:23:17 <niez> yes, it looks simple, but the zipper thing looks wired
03:23:54 <ivanm> I haven't used Data.Tree.Zipper myself
03:24:01 <niez> i want to solve some ai problems using tree search
03:24:20 <ivanm> maybe you should familiarise yourself with list-based zippers first to understand how they work
03:26:45 <niez> I'm watching ai classes: http://www.udacity.com/view#Course/cs271/CourseRev/1/Unit/1001/Nugget/3001 (great lectures by the way)
03:27:06 <niez> and i've stuck, becouse the node nedd a pointer to parent
03:27:49 <niez> so i've searched a little and found zippers
03:28:03 <niez> is it the best way to go?
03:33:07 <ivanm> possibly; I've never used zippers before
03:33:12 <ivanm> but that's the reasoning behind them, yes
03:40:16 <Lethalman> oh any id [] is False :(
03:43:20 <Lethalman> is there an any that is True for []? :P
03:43:29 <Lethalman> otherwise I use a guard
03:44:10 <Lethalman> that is foo bar | (null bar) = True     | otherwise = any baz bar
03:44:17 * hackagebot Monaris 0.1.2 - A simple tetris clone  http://hackage.haskell.org/package/Monaris-0.1.2 (FumiakiKinoshita)
03:45:21 <byorgey> Lethalman: no, there isn't
03:45:27 <byorgey> that's kind of a strange thing to want =)
03:46:14 <Lethalman> byorgey, eheh not in my definitions
03:46:37 <Lethalman> byorgey, a node a is defended if for all b -> a there's a c -> b
03:47:09 <Jafet> > all []
03:47:10 <Lethalman> anyway with guards it works so...
03:47:11 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
03:47:11 <lambdabot>              with actua...
03:47:17 <Lethalman> > all id []
03:47:18 <lambdabot>   True
03:47:39 <Jafet> @src any
03:47:39 <lambdabot> any p =  or . map p
03:47:42 <Jafet> @src or
03:47:42 <lambdabot> or    =  foldr (||) False
03:48:00 <Lethalman> > or id []
03:48:01 <lambdabot>   The function `GHC.List.or' is applied to two arguments,
03:48:01 <lambdabot>  but its type `[GHC...
03:48:14 <Jafet> > foldr (||) True []
03:48:15 <lambdabot>   True
03:48:18 <Lethalman> uhm
03:49:03 <Lethalman> :t or
03:49:04 <lambdabot> [Bool] -> Bool
03:49:19 <Lethalman> let's see
03:50:01 <Lethalman> awesome thanks :)
03:51:01 <milStaja> :t and
03:51:02 <lambdabot> [Bool] -> Bool
03:52:08 <Lethalman> so anyTrue p = foldl' (||) True . map p :P
03:53:01 <shachaf> Better to use foldr.
03:53:09 <Lethalman> ah
03:53:52 <shachaf> But, as byorgey pointed out, that's a strange thing to want.
03:54:08 <shachaf> You should reëxamine your desires.
03:54:18 <shachaf> Actually that anyTrue thing you wrote is broken.
03:54:31 <shachaf> > foldl' (||) True [False]
03:54:32 <lambdabot>   True
03:54:45 <Lethalman> right
03:55:02 <Jafet> Reéxamine
03:55:10 <shachaf> The reason it's broken has to do with the reason it doesn't make sense.
03:55:30 <Lethalman> shachaf, my desires are fine
04:17:20 <Lethalman> I think I need untilM' but I don't know how to use it :S
04:18:20 <Lethalman> for example now I have foldlM (liftM . count) 0 $ replicate n sample, where sample :: Rand Something
04:18:41 <Lethalman> I count the number of Something that satisfy a particular condition, out of n samples
04:18:55 <Lethalman> Something is a Graph (shorter to say :P)
04:19:18 <Lethalman> now I want to go one step further, the "n" depends on the result of that count function
04:19:59 <Lethalman> I want to sample graphs until a condition is met based on the count function, and return the result of the count function itself in the end
04:20:10 <aar> argh. the only octree implementation in haskell doesn't support deletion :/
04:20:14 * Lethalman pastes a java version
04:20:17 <zomg> isn't untilM' pretty straightforward, you just give it two funcs, one as the body and second as the one to evaluate for whether to end or not end the looping
04:21:48 <Lethalman> zomg, but I don't want to return m (f a)
04:22:01 <mm_freak_> such an untilM is pretty useless without either lots of IOReffing or a monad transformer
04:22:01 <lambdabot> mm_freak_: You have 1 new message. '/msg lambdabot @messages' to read it.
04:22:36 <mm_freak_> @tell neutrino warp or snap
04:22:36 <lambdabot> Consider it noted.
04:23:10 <Lethalman> this is what I want to achieve: http://paste.debian.net/220788/
04:24:18 <zomg> Lethalman: what's wrong with m (f a) ?
04:24:29 <zomg> f is MonadPlus so I'd guess it could be a list just like in untilM
04:24:48 <Lethalman> zomg, I don't know, I've no idea of that a MonadPlus it... :S
04:24:50 <Lethalman> *is
04:25:18 <zomg> http://hackage.haskell.org/packages/archive/base/4.2.0.2/doc/html/Control-Monad.html#t:MonadPlus
04:25:32 <zomg> There's a list instance for it so I'd imagine you can just get a list from untilM'
04:26:23 <Lethalman> but I don't need a list, I only need a number
04:26:56 <Lethalman> this is my code for a fixed number of iterations: http://paste.debian.net/220789/
04:26:57 <zomg> then fold the result or something
04:27:06 <Lethalman> zomg, but then I would pass the list twice
04:27:19 <Lethalman> and it's a simulation I have to run many times
04:28:01 <zomg> If you want the number of iterations it looped I guess you could just do length result
04:28:04 * Lethalman is just clueless
04:28:30 <Lethalman> zomg, the mersenne random monad is highly strict, that will lead to having the whole list in memory
04:28:59 <Lethalman> that's why I'm not using length $ filter in my current code
04:29:26 <Lethalman> see the montecarlo function: http://paste.debian.net/220789/
04:45:13 <yitz> Lethalman: are you using dons' mersenne-random package? that's probably best.
04:45:45 <yitz> Lethalman: mersenne has IO built deeply inside, due to the nature of the standard C implementation everyone uses.
04:46:33 <yitz> Lethalman: if that's not good for you, use mwc-random instead of mersenne.
05:03:59 <Lethalman> yitz, yes I'm using mersenne but the pure monad
05:05:00 <Lethalman> it's like I need a state Int Rand a
05:05:16 <Lethalman> where I keep the number of successes
05:05:38 * Lethalman is still too newbie to go deep with that
05:08:18 <Lethalman> something like (Int, Rand a), so that foreach sample I have the number of successes until that sample, and decide whether to stop or not mh
05:09:52 <Lethalman> or maybe I can transform an [m a] into an [m (Int, a)]... so clueless :P
05:14:50 <Lethalman> or I just discard the samples and keep the successes... uhm
05:36:58 <Lethalman> omg omg it compiled... will it work?
05:41:59 <chreekat> Can I "import as Foo" in ghci? I.e., do something virtually like ":m + Data.Text as M"
05:42:23 <zomg> import qualified Foo as F
05:42:43 <chreekat> oh
05:42:52 <chreekat> then what's :m for? heh
05:43:00 <zomg> that's ghci specific
05:43:36 <chreekat> ...The question was specifically for ghci
05:43:43 <zomg> Err
05:43:46 <zomg> lol, sorry, I'm blind
05:44:03 <zomg> I think the import qualified thing should work in ghci as well
05:45:27 <chreekat> :D
05:45:37 <`ramses> chreekat: historical reason afaik, the qualified imports were added later on
05:45:43 <chreekat> No, it does, which led to my slightly tongue-in-cheek question about :m
05:46:00 <chreekat> thanks guys
05:46:01 <zomg> I think it's because :m can also "unimport" modules
05:46:30 <`ramses> but then there is no way to "unimport" modules which are imported qualified?
05:46:59 <chreekat> `ramses: just tested; I can "import qualified Data.Text as T" and then ":m - Data.Text" and T goes away
05:47:01 <zomg> :m doesn't care whether you used import or :m + to include the module
05:47:15 <chreekat> so, that's all pretty handy
05:47:20 <`ramses> ah, right :)
05:49:25 <Lethalman> awesome! scanl (liftM2 satisfy') (return 0) samples !! this way I map [Rand Graph] -> [Rand Int]
05:49:38 <Lethalman> now I can use untilM!
05:52:57 <chreekat> Speaking of Text, are there any Text-native formatting libraries around? I've just found Text.Printf but I thought I remembered seeing something more modern recently.
05:58:49 <hpaste> quchen pasted “Tail recursion and monads” at http://hpaste.org/80048
06:00:06 <c_wraith> quchen: it's not "tail recursive". Whether it runs in place or not depends on the definition of (>>=) for the monad it's operating in.
06:00:31 <c_wraith> quchen: for [], it's not in place, or even close.  For IO, it is
06:00:35 <merijn> quchen: You probably shouldn't care about tail recursion anyway
06:00:55 <merijn> As tail recursion is unrelated to resource consumption in a lazy language (unlike in a strict one)
06:01:15 <fmap> @hackage text-format -- chreekat
06:01:15 <lambdabot> http://hackage.haskell.org/package/text-format -- chreekat
06:01:35 <chreekat> fmap: thx
06:01:41 <merijn> quchen: Things that are tail recursive can still overflow the stack and things that are not tail recursive might not overflow the stack (for example, see the definition of map, which is not tail recursive but is perfectly fine i a lazy setting)
06:03:27 <quchen> merijn: That's what I know as "tail recursion modulo cons".
06:03:27 <lambdabot> quchen: You have 1 new message. '/msg lambdabot @messages' to read it.
06:04:50 <merijn> quchen: The only reason that tail recursion is desirable in strict languages in resource consumption, in a lazy language tail recursion is completely orthogonal to resource consumption, so why bother having a special case for the list case?
06:05:41 <quchen> So tail recursion is only good for avoiding space leaks? I always thought it also helps the GC and it's nice in general.
06:06:35 <c_wraith> tail recursion in haskell is entirely unrelated to space leaks
06:06:57 <merijn> quchen: You are absolutely right for *strict* languages, but in haskell none of those things apply
06:08:07 <c_wraith> for example, foldl is tail-recursive, but will easily leak space.
06:08:34 <c_wraith> foldr is not tail-recursive, but use of it can easily avoid leaking space.
06:08:47 <mysticc> Is there a decent place to get more familiar with ghc api except the haddock
06:09:05 <c_wraith> mysticc: wade through the code of hint or plugins?
06:09:10 <parcs> mysticc: the source code of ghci
06:23:00 <quchen> How do I send messages via Lambdabot?
06:23:08 <quchen> Tried @message, but wouldn't work. :-(
06:24:05 <bitonic> quchen: /msg or /query
06:24:22 * hackagebot Octree 0.3 - Simple unbalanced Octree for storing data about 3D points  http://hackage.haskell.org/package/Octree-0.3 (MichalGajda)
06:24:32 <bitonic> that’s just standard IRC
06:25:16 <quchen> bitonic: I didn't mean message Lambdabot, I meant using the "message in absence" service it offers.
06:25:46 <quchen> As in answer '09:03 < lambdabot> quchen: You have 1 new message. '/msg lambdabot @messages' to read it.'
06:26:11 <bitonic> quchen: ah sorry
06:26:23 <bitonic> @help
06:26:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:26:27 <bitonic> @help list
06:26:27 <lambdabot> list [module|command]
06:26:27 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
06:26:50 <bitonic> @help tell
06:26:50 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
06:26:54 <bitonic> quchen: ^^^
06:27:05 <quchen> Ah, thanks!
06:27:25 * bitonic is a bit confused after yesterday
06:30:40 <has> Hi. What could cause an error when I try to input negative values? Example: -3. (the interpreter complains I should declare Num in advance)
06:32:25 <quchen> has: Try (-3)
06:33:04 <quchen> 1 + -2 is interpreted as "1 operator+ operator- 2", so the interpreter complains
06:33:15 <bitonic> has: your question is quite unclear, what problem are you having?  the syntax for `-' can be annoying for reasons related to how Haskell treats operators, but I don’t see how that has anything to do with Num
06:34:42 <has> Thanks quchen it worked between parenthesis
06:35:05 <bootcode_> what do I need to get `-- >>> 1 + 2\n-- 3` like doctests to be executed? any docs on this somewhere?
06:36:30 <srhb> bootcode_: Have you seen the doctest package on Hackage?
06:36:57 <bootcode_> srhb: thank you, checking
06:40:20 <has> I have a function that rotates the content of a list, i.e., if I input [1,2,3] it outputs [[1,2,3],[2,3,1],[3,1,2]]. How can I store this result in order to manipulate with it later? My final goal is to create a function to calculate the normal form of a pitch-class set, which is the most compact form of representing this kind of set in music.
06:42:12 <chreekat> has: When is "later"?
06:42:59 <has> imediately
06:43:11 <has> for now I have a function that rotates
06:43:30 <chreekat> has: "let rots = rotate input in rest-of-function"
06:45:35 <has> Thanks Chreekat. Let me try it.
06:48:56 <has> Chreekat it caused a "parse error in pattern"
06:49:15 <has> let me upload the code
06:49:23 * hackagebot hackport 0.3.2 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.3.2 (SergeiTrofimovich)
06:50:15 <hpaste> has pasted “rotate” at http://hpaste.org/80050
06:53:01 <chreekat> has: Hm, we might need to expand the scope of the question some. You need to keep your rotate function at the top level.
06:54:06 <has> how can i do that?
06:54:18 <has> just identation?
06:54:30 <chreekat> Get rid of the 'let'; that's not how you want to use it, I think.
06:55:05 <has> I think I have tried that before...Let me try again
06:55:12 <chreekat> Have you written the normal form function already?
06:55:46 <Botje> has: where does the st on line 1 come from?
06:55:49 <has> not yet
06:56:49 <has> st will be a list created through selection of a cycle
06:56:52 <chreekat> has: Don't worry about "storing the results" yet; you have the function and that's all that matters so far.
06:57:53 <has> but I need to take the results of rotarus to compare the last element with the first and see which one is the smallest
06:58:08 <has> this smallets value will be my normal form
06:58:32 <has> I think I am think too imperatively yet...:(
06:58:37 <has> *thinking
06:59:35 <`ramses> instead of storing the result of rotarus, write the next step in your computation as a new function that will take the output of rotarus as input
07:00:03 <`ramses> then you can call these functions like newFunction $ rotarus input
07:00:06 <has> when I do let rots = rotarus [1,2,3]  on Prelude it works...
07:00:19 <`ramses> has ^^
07:00:49 <chreekat> has: The problem was you basically inverted how you're supposed to use let. Try reading the two sections starting here: http://learnyouahaskell.com/syntax-in-functions#where
07:01:37 <has> Ok, I will continue working on my syntax....Thanks...:)
07:02:07 <has> I am reading exactly this chapter
07:02:23 <has> Chapter 4 of Lipovaca
07:02:32 <chreekat> But `ramses has the best idea, which is to think in terms of writing a function that consumes the output from rotarus
07:03:13 <has> That was my idea but I dont know how. The syntax he wrote is still difficult for me
07:03:28 <has> But I wrote it down and am trying to analyze it
07:04:51 <has> A question about the irc: how do you highlight the nick in an open room?
07:05:33 <Lethalman> :t firstM
07:05:34 <lambdabot>     Not in scope: `firstM'
07:05:34 <lambdabot>     Perhaps you meant one of these:
07:05:34 <lambdabot>       `first' (imported from Control.Arrow),
07:05:40 <Lethalman> :S
07:07:06 <merijn> has: That depends on your IRC client
07:07:32 <has> it is colloquy
07:07:45 <merijn> Lethalman: That function is from the monad-loops package
07:08:21 <Lethalman> merijn, yes I'm using it, thought lambdabot already imported that package :P
07:08:32 * Lethalman is lazy at doing import in ghci to test types
07:08:39 <hpaste> “`ramses” annotated “rotate” with “rotate (annotation)” at http://hpaste.org/80050#a80052
07:08:50 <`ramses> has: ^^ something like that
07:09:10 <has> ^^
07:09:20 <has> ^^ ramses
07:09:41 <has> :(
07:09:58 <`ramses> (btw, you should make a habit of explicitely giving type signatures for top-level functions)
07:11:07 <`ramses> has: what's the sad face for?
07:12:05 <has> I am trying to highlight a nickname, but the documentation of colloquy takes this command for grant...but I will keep trying :)
07:13:04 <has> I am sill learning to use the irc ramses, sorry about that. I saw now that you upload something. Let me take a look. Thanks a lot
07:13:40 <`ramses> ah, ok, no problem, it just confused me
07:15:21 <has> thanks ramses, i will study your solution
07:15:48 <has> bye
07:16:03 <`ramses> has: I just outlined how you can write the next step of your problem as a new function which uses the output of the previous function
07:16:23 <`ramses> that way, you don't need to explicitely store the result of the first step
07:17:10 <`ramses> this kind of "data transformation pipeline" in which you chain multiple functions that each use the output of the previous one, is a pretty common idiom in functional programming
07:18:31 <srhb> `ramses: "has" has quit.
07:18:51 <`ramses> ah ok, the disadvantage of hiding parts and quits :)
07:19:01 <srhb> `ramses: Right. :)
07:20:20 <chreekat> Can't live with em, can't live without em :)
07:20:53 <`ramses> yeah, there ought to be an option to show them for people you've recently interacted with and hide them for all others...
07:21:10 <`ramses> just enabling them for everyone makes for such a terrible mess.
07:21:24 <chreekat> that sounds pretty slick indeed
07:21:26 <srhb> `ramses: Sounds like a good compromise.
07:21:45 <Lethalman> @src scanl
07:21:45 <lambdabot> scanl f q ls = q : case ls of
07:21:45 <lambdabot>     []   -> []
07:21:45 <lambdabot>     x:xs -> scanl f (f q x) xs
07:22:04 <`ramses> maybe I need to learn some perl and write an irssi plugin :)
07:22:32 <chreekat> Though you can also try relying on tab-completion to write out "has: "
07:23:04 <`ramses> chreekat: but prepending every message with a nick is also a bit tiresome...
07:23:42 <`ramses> (and it does not work that well with "has" because irssi auto-completes english words as well with tab)
07:23:46 <chreekat> Aye, but with no tag, I doubt any script could keep track of who you were trying to talk to..
07:25:10 <srhb> chreekat: You just have to initiate a conversation with them tagged, then put a timer on it
07:25:27 <`ramses> maybe I could make the script store all nicks that recently showed some activity, and remove nicks that haven't said anything for the last half hour or so
07:26:02 <`ramses> if someone hasn't said anything for half an hour or more, I'm probably not interested in seeing when they leave
07:29:56 <fabookchat> Do you know of any facebook app to chat on IRC with other facebook users that aren't on your friends list? It would be great such an app with a lot of great popular #rooms
07:30:44 <parcs> this is quite off topic
07:32:20 <Hafydd> As long as it doesn't use freenode.
07:34:24 * hackagebot yesod-core 1.1.7.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.7.1 (MichaelSnoyman)
07:34:43 <nexx> fabookchat why limit it to facebook users? If you would allow anyone, you can do it with a normal irc client
07:34:50 <Modius> Is it common generally to import Data.List everywhere unqualified?
07:35:23 <fabookchat> because facebook has 1 billion users so I see a great potential there
07:35:36 <byorgey> Modius: yes
07:37:19 <fabookchat> my mother doesnt use IRC but maybe she would  if there was a nice facebook app for chat
07:38:44 <`ramses> fabookchat: if you're just after an irc client embedded in facebook, you should probably start reading about the facebook app api. And unless you want to write it in haskell (which I doubt is even possible) you're quite off-topic here
07:38:45 <nexx> So basicly an irc client which is calld facebook something would cover most of it
07:39:04 <Modius> Is there a list of other things as nobrainer-common-useful as Data.List?  "Maybe" too?  Anything else?
07:39:39 <`ramses> Modius: I wouldn't start importing just anything unless you'll use it
07:39:50 <fabookchat> yes, a facebook app that was a nice IRC client
07:40:05 <Modius> I meant, once used (I'm avoiding warnings)
07:40:26 <`ramses> Modius: there are many...
07:40:39 <parcs> Modius: check out the modules in the 'base' package
07:43:29 <Modius> I know pattern matching can do this; but what's a (if it exists) more elegant way to go from Maybe a to Left a or Right "Some Error Here" via a function?
07:44:04 <byorgey> Modius: use the 'maybe' function
07:44:24 <byorgey> > maybe (Left "error") Right Nothing
07:44:25 <lambdabot>   Left "error"
07:44:29 <byorgey> > maybe (Left "error") Right (Just 3)
07:44:30 <lambdabot>   Right 3
07:44:52 <bitonic> Modius: pattern matching is very elegant and clear, btw.  I only use those combinators where it’s obvious
07:44:53 <Modius> Doh thanks didn't see that one, nobrainer
07:44:56 <byorgey> Modius: also, it's more idiomatic to use Left for errors
07:45:10 <`ramses> Right is right ;)
07:45:26 <Modius> Right is right really?  Fair enough
07:45:38 <byorgey> Right is right, and Left is what's left
07:49:21 <chreekat> Modius: Also check out 'note' in the errors package: http://hackage.haskell.org/packages/archive/errors/latest/doc/html/Control-Error-Util.html
07:57:33 <ion> modius: When you have the type like “Something a b c” for a container/generator of some value(s), the rightmost type parameter is the one that refers to them. Type classes such as Functor expect that.
08:07:43 <chreekat> Favored library for dealing with command-line args?
08:15:36 <chreekat> I'm gonna go with cmdargs
08:16:40 <bootcode> if I have a .cabal with a library and an executable section, how do I specify that the exec use al the build-deps of the lib?
08:20:21 <hiptobecubic> the lyah section on monadic programming is pretty nice
08:20:34 <hiptobecubic> It wasn't written yet last time i looked
08:20:37 <yitz> chreekat: cmdargs is great. it was the first alternative to the port of gnu getopt
08:20:39 * Lethalman having so many problems with randoms
08:21:36 <yitz> chreekat: now there are a huge number of other options. optparse-applicative has been getting a lot of press lately. there was a reddit thread last week you might want to look for.
08:22:10 <chreekat> yitz: Oh that sounds familiar. Thanks, I'll check it out. Gotta run for now!
08:22:13 * Lethalman doesn't have the strength to explain :(
08:22:14 <yitz> chreekat: i use cmdargs. it works for me, and i haven't had the time to check any of the newer packages yet.
08:22:49 <yitz> Lethalman: sorry to hear that.
08:23:16 <Lethalman> yitz, :P
08:23:40 <Lethalman> the problem is that sequence samples where samples is a [Rand Foo] from mersenne random will be stract
08:23:42 <Lethalman> strict
08:23:51 <yitz> Lethalman: i haven't done anything serious with randoms lately. but mwc-random has been getting a lot of positive press. worth looking into if you are using something else and having trouble.
08:24:14 <Lethalman> yitz, looked into the docs but I'm too newbie to understand
08:24:48 <Lethalman> yitz, will sequence [list of rands] be lazy or strict with mwc?
08:24:51 <Lethalman> that you know...
08:24:59 <yitz> Lethalman: with mersenne you must write your main loop directly in the IO monad. the C library keeps global state. and it is not thread safe. (in any language, they are all ports of the same C code)
08:25:29 <Lethalman> yitz, mersenne has a pure monad
08:25:30 <yitz> not ports, bindings. they all *are* the same C code
08:25:45 <Lethalman> which is what I'm using
08:26:07 <yitz> Lethalman: if so, it's a pure haskell port, and won't be nearly as fast, which is usually the reason people want to use mersenne in the first place.
08:26:34 <Lethalman> yitz, the problem is not that mersenne is not fast, but that it's too strict
08:26:49 <Lethalman> foo <- sequence samples will evaluate for an infinite list instead of being lazy
08:26:57 <Lethalman> and that makes things so hard... at least for me
08:27:43 <Lethalman> I can't understand a word in the mwc docs
08:28:29 <yitz> Lethalman: could be. don't know how that monad works, but it certainly would be hard to write a very useful monad around that ugly C wrapper. if you really want mersenne, i think you're best off using the dons' binding directly and doing it directly in the IO monad, with an explicity loop.
08:28:36 <yitz> *explicit
08:29:04 <Lethalman> yitz, it's not that I want to use mersenne, mwc would be fine if I only understood it :P
08:29:30 <pnielsen> Lethalman: statistics uses it if you want an example
08:30:13 <Lethalman> since two days, this is what I'd like to achieve: http://paste.debian.net/220832/
08:30:40 <Lethalman> I managed to do it for a fixed number of iterations with foldlM (liftM . satisfy') 0 samples... that will count the number of successes
08:31:09 <Lethalman> but then I'm not able to do much more given the list is not lazy... can't manipulate it
08:31:16 <Lethalman> pnielsen, thanks
08:33:05 * Lethalman already lost in statistics on how to generate a random number :P
08:33:26 <yitz> Lethalman: mwc looks pretty straightforward to me.
08:33:41 <Lethalman> yitz, I'm very newbie... I could understand System.Random and mersenne but that's too much
08:34:19 <Peaker_> bah... just wasted hours debugging an abuse of unsafePerformIO in Data.Hashable :-(
08:34:33 <Lethalman> what's the monad there?
08:34:43 <Peaker_> people use unsafePerformIO for convenience, it's so terrible :(
08:35:06 <yitz> Lethalman: just create a generator g, then call uniform g or uniformR (lo, hi) g, to get a single random value in either IO or ST.
08:35:28 <neutrino_> http://www.csis.pace.edu/~bergin/patterns/ppoop.html
08:35:28 <lambdabot> neutrino_: You have 4 new messages. '/msg lambdabot @messages' to read them.
08:36:08 * Lethalman this is the third random package I'm trying to use... hope it will be good
08:36:21 <yitz> Lethalman: or you can get a (strict and finite) vector of random values using uniformVector.
08:36:42 <yitz> Lethalman: truth is, it sounds like the random package is probably not your problem.
08:37:01 <Lethalman> yitz, random package is a problem because of StdGen Int Int instead of !Int !Int
08:37:15 <Lethalman> yitz, then mersenne package is a problem because I can't have a lazy SomeMonad [MySample]
08:37:19 <yitz> Lethalman: you're just stuck on how to generate random values while iterating over an infinite lazy list?
08:37:54 <yitz> Lethalman: what's the problem with StdGen Int Int ?
08:37:54 <Lethalman> yitz, I'm generating a [Rand Sample] and I'd like to have a lazy Rand [Sample]
08:38:11 <Lethalman> yitz, that it will create a lot of thunks, confirmed yesterday here with other people
08:38:35 <Lethalman> so while random package is lazy, it's too lazy... while mersenne is strict, it's too strict :P
08:38:44 <Lethalman> now I try this mwc
08:39:15 <neutrino_> i wonder what the most minimal computer is that would at some level present a suitable environment to execute an implementation of haskell
08:39:39 <neutrino_> would 4 KW of core be enough?
08:39:55 <neutrino_> and what about the instruction set?
08:40:11 <yitz> neutrino_: it depends what you'll accept as an "implementation".
08:41:09 <yitz> neutrino_: for example, jhc requires very little. furthermore, it compiles to standard C, so you can cross-compile the result to run on just about anything.
08:41:52 <yitz> neutrino_: but jhc doesn't support all of the language bells and whistles that ghc does, and therefore also doesn't support many of the libraries on hackage.
08:44:07 <yitz> Lethalman: the specific details of laziness and strictness shouldn't make much of a difference. that's just a question of style. anything you can implement using one you can implement using the other.
08:44:24 <yitz> Lethalman: it also makes a difference in performance.
08:44:39 <Lethalman> yitz, it's a difference for large set of data
08:44:53 <Lethalman> yitz, with the random package I get an ever growing heap
08:44:54 <yitz> Lethalman: you mean how long it will take for the large set of data?
08:45:04 <Lethalman> yitz, now how much space it takes
08:45:04 <yitz> Lethalman: so then you're using it wrong.
08:45:07 <Lethalman> *no
08:45:28 <Lethalman> yitz, try it yourself, create a list of random numbers with the random package and profile the heap
08:45:48 <Lethalman> with StdGen
08:46:08 <yitz> Lethalman: let's say you had a gigantic file of numbers instead of a random number generator. if you can write your program for that, you can write it for any of the random libraries too.
08:46:46 <Lethalman> yitz, no because the StdGen monad creates thunks
08:46:50 <Lethalman> it depends on the monad
08:47:20 <yitz> Lethalman: create and do what with them? store them in the heap? then yes. write them out to a file and make sure they are not in the heap? then no problem. do a calculation? well, it depends on the details of the calculation.
08:47:37 <Lethalman> yitz, sorry I can't continue this discussion, did this already yesterday for the whole day
08:48:09 <nus-> Lethalman, StdGen isn't a Monad
08:48:20 <Lethalman> nus-, Rand is and is based on StdGen
08:48:22 <yitz> Lethalman: how many values do you want to generate - order of magnitude?
08:49:25 * hackagebot handa-gdata 0.3.1 - Library and command-line utility for accessing Google services and APIs.  http://hackage.haskell.org/package/handa-gdata-0.3.1 (BrianBush)
08:49:56 <nus> Lethalman, Rand?
08:50:31 <nus> Control.Monad.Random?
08:51:25 <Lethalman> can't lose another explaining why StdGen and Rand is broken sorry
08:51:33 <Lethalman> I can paste the whole chat log of yesterday if you want
08:51:39 <monochrom> I have not heard of Rand
08:51:40 <Lethalman> *another day
08:51:59 <monochrom> then again, if you say it's broken, perhaps I need not hear about it
08:52:09 <nus> Lethalman, you're failing to explain what 'Rand' is
08:52:19 <Lethalman> nus, Control.Monad.Random yes
08:52:28 <Lethalman> which uses StdGen by default
08:53:42 <Subtrain> happy new year to everybody !
08:58:31 <hiptobecubic> I'm looking at the lyah section on Writer and it appears to be wrong as far as implementation. "Writer" is not exported as a data constructor, only the "writer" function
08:58:38 <hiptobecubic> http://learnyouahaskell.com/for-a-few-monads-more  am I confused about something?
08:58:55 <hiptobecubic> particularly the definition of   logNumber
09:01:43 <hpaste> yitz pasted “many lazy randoms” at http://hpaste.org/80054
09:02:50 <yitz> Lethalman: the program i just pasted creates a 65 MB file of random ASCII characters, 64 per line, in a few seconds. no stack overflow.
09:03:06 <yitz> Lethalman: using StdGen from System.Random.
09:04:05 <cmccann> hiptobecubic, not so much wrong as out of date
09:04:10 <cmccann> it was correct when it was written
09:04:30 <hiptobecubic> cmccann, ah ok. So why did it change to this smart constructor?
09:05:02 <cmccann> hiptobecubic, because Writer is now a synonym for WriterT Identity
09:05:13 <hiptobecubic> cmccann, ah ok. that was my next question :)
09:05:25 <cmccann> the WriterT constructor is exported, so you can use that
09:05:27 <Subtrain> #haskell_ru
09:05:34 <cmccann> @src writer
09:05:34 <lambdabot> Source not found.
09:05:37 <cmccann> pf.
09:06:24 <yitz> Lethalman: i'm running it now for 650 MB. it's taking a while, but running in a tiny constant amount of memory.
09:06:43 <yitz> ok done. no problem.
09:07:18 <cmccann> hiptobecubic, so now 'writer' is just WriterT . return or such
09:07:35 <cmccann> to be an easy replacement for any code previously using Writer as a constructor
09:07:40 <yitz> Lethalman: so you can do what you want with any of these libraries. System.Random will be quite slow, but will work. it's a question of how to use each library in a way that it uses constant memory.
09:08:13 <yitz> Lethalman: the problem is that you keep pointing to a paste of a very complicated program that people can't understand without studying it for a long tim.
09:08:17 <yitz> *time.
09:08:58 <hiptobecubic> cmccann, yeah. Ok thanks.
09:09:00 <yitz> Lethalman: try something simpler first, learn how to use the library you prefer. we'll help you with that. then you will be able to re-write your more complicated example to run in constant space.
09:10:01 <hiptobecubic> cmccann, it can't just be that though, no? You would need to specify the identity monad
09:10:26 <cmccann> that's the "return"
09:10:58 <cmccann> it's Identity because that's how Writer is defined
09:11:57 <_Vi> What term to use for calling a good Haskell code? Like "pythonic", but for Haskell. Is it just "ideomatic" or something more specific?
09:12:05 <cmccann> (I'm not sure what the actual implementation is, could be slightly different, eating lunch and too lazy to check :P)
09:12:28 <cmccann> _Vi, just "idiomatic Haskell" I think
09:13:40 <cmccann> good Haskell isn't handed down from on high like with python, though, so it's not as consistently defined
09:14:19 <Subtrain> `ramses http://hpaste.org/80015 about the last step...... you meant the guards?
09:14:43 <flebron> SPJ should give speeches every once in a while, denouncing unhaskellian practices
09:15:12 <Fuuzetsu> @src init
09:15:12 <lambdabot> init [x]    = []
09:15:12 <lambdabot> init (x:xs) = x : init xs
09:15:12 <lambdabot> init []     = undefined
09:16:05 <flebron> Is there a difference there between init [] = undefined and just... not writing that?
09:17:23 <darcissue> hello, how can i fix it? http://vpaste.net/inaIR
09:17:31 <k00mi_> flebron: it will give a different (worse IMO) error message
09:19:13 <Subtrain> http://hpaste.org/80015 can somebody explain to me what I'm suppose to do in the last step of this structural induction? please
09:19:25 <fmap> k00mi: how is it worse?
09:20:07 <fmap> k00mi: you will get filename and line number where error occured at least
09:22:04 <Subtrain> anyone?
09:23:35 <k00mi> fmap: i meant the error message when using undefined will be worse
09:24:02 <fmap> darcissue: I don't think darcs builds with ghc-7.6
09:24:26 * hackagebot zip-archive 0.1.3.1 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.1.3.1 (JohnMacFarlane)
09:24:28 <shapr> Who could I ask about improving compile times with ghc with 512MB of RAM on my Raspberry Pi?
09:24:28 * hackagebot alpha 1.0.15 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-1.0.15 (MarcCoiffier)
09:24:57 <byorgey> Subtrain: can you be more precise?  what exactly is the part you don't understand?
09:26:39 <shapr> Is anyone else writing Haskell code specifically for their Raspberry Pi?
09:27:11 <byorgey> darcissue: try  cabal install darcs -fforce-char8-encoding
09:27:44 <Subtrain> byorgey the thing is the person who explained it for me before told me to add the differend cases and I don't know further
09:29:03 <darcissue> byorgey: http://vpaste.net/X16XC
09:29:19 <byorgey> Subtrain: it looks more or less complete to me, although the notation is somewhat confused
09:29:34 <byorgey> Subtrain: do you understand what's already there?
09:30:08 <byorgey> darcissue: ah, fmap is right, darcs doesn't build with ghc-7.6
09:30:30 <byorgey> I don't know if it's just a simple matter of tweaking some constraints or if there is some more fundamental reason
09:30:35 <byorgey> darcissue: try asking in #darcs
09:30:51 <darcissue> byorgey: already, waiting for reply atm
09:30:57 <byorgey> ok
09:31:02 <Subtrain> byorgey yes I have to show the way that the parts get the same results just to fill in the definitions but I didn't understand that with the different cases ...maybe he meant the guards... :-/
09:31:40 <Hafydd> You also have to consider the case where not (p x).
09:32:00 <byorgey> Hafydd: that's essentially what the very last line is, I think
09:32:09 <byorgey> although it does not explicitly say anything about p
09:32:18 <byorgey> or 'otherwise'
09:32:50 <Modius> Anyone use GHC-mod?  Anyone tried to get it to check code against GHC and HLint at the same time, rather than as independent modes?
09:32:59 <Subtrain> so I have to write a case for p x ?
09:33:50 <Hafydd> Given that the actual meat of the proof is so trivial, I find it likely that the point of this is to learn how to lay out a proof - so it should be explicit.
09:36:36 <byorgey> Hafydd: yes, you're right.
09:37:16 <byorgey> Subtrain: there is already a case for p x written there, but the fact that you aren't sure tells me that you really ought to start over from the beginning.
09:38:14 <byorgey> Subtrain: to prove span p xs = (takeWhile p xs, dropWhile p xs)  by induction on xs, you first must prove that it is true when xs = [], and then when xs = x:xs' assuming that span p xs' = (takeWhile p xs', dropWhile p xs')
09:39:08 <byorgey> Subtrain: However, in the (x:xs') case, since the behavior of those functions depends on the result of  p x, you will have to split it into two cases, one where p x is True and one where p x is False
09:40:06 <byorgey> Subtrain: also, I would recommend using a lot more English in your proof.  with just a bunch of equations and code it is not clear what is going on.
09:40:51 <byorgey> "First, consider the case where xs = [].  In that case by definition  span p [] = ([], []), takeWhile p [] = [], and dropWhile p [] = []; therefore ..."
09:41:44 <byorgey> "Next suppose xs = x:xs'.  Assume as the induction hypothesis that the property holds for xs', that is, span p xs' =  (takeWhile p xs', dropWhile p xs')
09:42:03 <byorgey> ... We must consider two subcases, depending on whether p x is True or False ... "
09:42:11 <byorgey> you fill in the rest =)
09:43:31 <Lethalman> yitz, that makes me think StdGen with IO works as expected, what do you think happens here instead? http://paste.debian.net/220849/
09:43:49 <Subtrain> ok, thank you very much ^^
09:45:39 <Taneb> Hmm, I might upload this to Hackage
09:45:39 <gilligan-> evening
09:45:45 <Taneb> gilligan-, hey
09:45:49 <byorgey> hi gilligan-
09:46:22 <gilligan-> irc channel friendliness lisp : 0 / haskell : 1
09:46:26 <gilligan-> ;]
09:47:06 <byorgey> =)
09:47:36 <byorgey> gilligan-: #haskell is renowned for its friendliness.  I'm glad we haven't disappointed you so far.
09:48:22 <gilligan-> byorgey, first time for me here hehe. I just started to toy around with haskell for a bit. Found some spare time during the holidays
09:48:30 <byorgey> fun
09:48:50 <newsham> ?botsnack
09:48:50 <lambdabot> :)
09:48:51 <byorgey> gilligan-: well, feel free to ask questions here
09:49:04 <Taneb> Would anyone be interested in a library for a sort of type-level Data.Ord.comparing?
09:49:13 <NougatRillettes> To the one who was telling me about web in Haskell, have you checked Yesod ?
09:49:23 <byorgey> @type comparing
09:49:24 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
09:49:40 <byorgey> Taneb: what's your use case?
09:50:10 <gilligan-> The guy behind http://haskelllive.com/ doesn't happen to hang out here does he ?
09:50:25 <tcrayford> gilligan: he's on twitter at reinh
09:50:26 <tcrayford> iirc
09:50:26 <Taneb> byorgey, putting things without Ord instances which can be converted to things with Ord instances into Sets
09:50:34 <gilligan-> watched his videos on youtube earlier today. Thought they were rather nice
09:51:20 <byorgey> Taneb: yes, but why at the type level?
09:51:54 <yitz> Lethalman: not sure, those are weird, not idiomatic haskell. but those both look like the wrong way of doing things. func1 depends on the implementation of foldM, you'd have to investigate. func2 depends on whether the compiler leaves samples polymorphic when it first occurs.
09:51:56 <tcrayford> yeah. I'm actually kinda considering doing something like he did, probably at a slightly more advanced level, and probably behind a paywall. I think there's a lot of scope for teaching some (slightly) more advanced haskell through screencasts
09:52:22 <Taneb> byorgey, it's useful for some half-baked ideas I have for edwardk's upcoming tables library
09:52:34 <Lethalman> yitz, ok let's say I have a graph with probabilities, then I want to sample that graph by creating new graphs without probabilities
09:52:50 <Lethalman> yitz, and count the number of graph satisfying a condition
09:52:54 <bootcode> how would one get a (partially) typed AST out of GHC? For editor support purposes etc.
09:53:10 <byorgey> Taneb: oh cool, didn't know about tables
09:53:17 <Lethalman> yitz, that is I have a function that returns [Rand g Graph]... is that idiomatic?
09:53:37 <byorgey> Taneb: well, go ahead and upload it!  There's no requirement that anyone be interested =)
09:53:50 <byorgey> Taneb: maybe people can't even find out whether they're interested unless it's already on Hackage
09:54:04 <Taneb> I'll put in some docs first...
09:54:41 <edwardk> byorgey: tables needs lens 3.8 so it'll hit hackage shortly after
09:54:47 <byorgey> cool
09:55:09 <Lethalman> bah I'm still losing time explaining why Rand is bad
09:55:19 <byorgey> bootcode: I think you can do it using the GHC API but as far as I know it's not very straightforward
09:55:26 <Taneb> edwardk, I probably ought to tell you these half-baked ideas at some point
09:55:40 <byorgey> bootcode: luite or mgsloan might know
09:55:47 <yitz> Lethalman: sounds like a cool program. no i wouldn't do it that way. i'd have a Graph Prob, and traverse it to produce a Graph Value or whatever.
09:56:15 <Lethalman> yitz, I have to produce many graphs from that probabilistic graph
09:56:37 <Lethalman> yitz, so how would you do it?
09:57:22 <yitz> Lethalman: you *could* do that in a state monad of some kind - or even just an applicative. or just pass around the random generator.
09:57:50 <Lethalman> yitz, what's wrong with samples = replicate 100000 sample where sample is the function creating such graphs?
09:58:30 <mel-> hi. I have a problem with the union function contained in Data.List. On Hoogle it is described as "Duplicates, and elements of the first list, are removed from the the second list [...]" This is not really what it does. It does not 'remove' elements of the first list. Am I just reading it wrong? Next question: as I understand it is supposed to implement a set-theoretic functionality. so, why does it NOT
09:58:32 <mel-> remove duplicates from the first list?
09:59:16 <edwardk> mel-: its mostly an implementation detail
09:59:41 <edwardk> mel-: think of it this way, if the two lists you give are already 'set-like' then there won't be any such duplicates
09:59:55 <edwardk> if you want a real Set, use Data.Set from containers
10:00:16 <mel-> (actually I was looking for a function unique :: (Eq a) => [a] -> [a]
10:00:22 <mercury^> Is Monad (t m) not implied by (Monad m, MonadTrans t)?
10:00:41 <mel-> edwardk: but isn't the description wrong? it does not REMOVE elements from the first list. :)
10:01:10 <yitz> Lethalman: they aren't functions. they are a gigantic pile of monadic values, which you are then binding in some order using some algorithm. that's a whole lot of extra mental complexity to keep track of, and it's very likely to introduce dependencies on tiny details of the compiler implementation whose effects then get multiplied by huge numbers.
10:01:35 <edwardk> Duplicates, and elements of the first list, are removed from the the second list, but if the first list contains duplicates, so will the result. It is a special case of unionBy, which allows the programmer to supply their own equality test.
10:01:48 <edwardk> they are removed from the second list.
10:01:57 <Lethalman> yitz, then how do I do that? I'm clueless
10:02:19 <mel-> edwardk: yeah, well, i still don't understand the linguistics behind it.
10:02:44 <bootcode> mercury^: as I heard not, since monad laws not automatically get satisfied
10:02:52 <mel-> edwardk: to me it basically says "something is removed from the second list". that 'something' being duplicates and the first list elements
10:03:02 <bootcode> mercury^: in theory you would have to prove them for t m
10:04:08 <mercury^> bootcode: what is an example of a MonadTrans instance t that does not provide “Monad m ⇒ Monad (t m)”?
10:04:08 <edwardk> there is a funny comma in there, but overall i can parse it
10:04:31 <bootcode> mercury^: something with ListT was a usual black sheep I think, try googling it
10:04:33 <mel-> ok then. :)
10:05:19 <yitz> Lethalman: so, let's say it's a tree. then the direct elementary way is just a recursive function. sampleTree :: Tree Prob -> StdGen -> Tree Value
10:05:38 <yitz> Lethalman: you write the function to follow the structure. for a tree, something like this:
10:05:43 <Patrek> is it true that the equality constraint (~) is can be modeled by functional dependencies: "class (:~:) a b | a -> b, b -> a where"?
10:05:49 <Lethalman> yitz, the problem is not there
10:05:54 <Lethalman> yitz, I have to create many of them
10:06:04 <mercury^> bootcode: But in transformers it says instance (Monad m) => Monad (ListT m) where
10:06:10 <Lethalman> yitz, a list of such trees and count how many of them satisfy a function
10:06:13 <Taneb> edwardk, with the reflection library, do different values reified make a type error if you pretend they're the same, even if they're the same type?
10:06:14 <Lethalman> as simple as that
10:06:37 <edwardk> Taneb: they'll be different 's' values at the type level. each reification is a new 'type'
10:06:41 <Lethalman> yitz, imperatively is for 1..N { s = sample(); if (satisfies (s)) count++; }
10:06:46 <Taneb> edwardk, sweet
10:06:55 <bitonic> Patrek: well that does something similar but GHC can do much less with it
10:06:58 <edwardk> Reifies s Int and Reifies t Int  give you two different reified Int.
10:07:01 <yitz> sampleTree (Node leaf l r) g = Node val (sampleTree l g') (sampleTree r g'') where ...
10:07:04 <yitz> oh
10:07:21 <edwardk> mel-: unionBy eq xs ys        =  xs ++ foldl (flip (deleteBy eq)) (nubBy eq ys) xs
10:07:26 <bootcode> mercury^: see http://www.haskell.org/haskellwiki/ListT_done_right
10:07:30 <Patrek> bitonic: "class (:~:) a b | a -> b, b -> a where" optimization?
10:07:31 <bitonic> Patrek: the point about ~ is that it is embedded in the core calculus and GHC does all sorts of stuff with it (GADT indices, type families..)
10:07:42 <edwardk> mel-: thats exactly what happens you get the first list, then the second list is nubbed and elements of the first list are deleted fro it
10:07:49 <yitz> ok then
10:07:57 <bootcode> mercury^: well, it is made monad syntactically, but GHC can't check if the monad laws hold, so they may not
10:09:02 <bitonic> Patrek: mhm?
10:09:16 <Patrek> can't GADTs be converted to ADTs with constrained  existentials
10:09:33 <mel-> edwardk: ah, _that_ is how it should be parsed, okay. thanks :)
10:10:04 <byorgey> Patrek: yes, GADTs = ADTs + existentials + equality constraints
10:10:05 <yitz> Lethalman: like in the imperative implementation, you are best avoiding an infinite list of those though. if it's a list of known size, you can easily run the calculation that many times, ending with a result and the leftover generator.
10:10:06 <bitonic> Patrek: GADTs are ADTs but constructors can carry proofs of equality of some type parameter
10:10:13 <cmccann> oleg's "TypeCast" or whatever he called it, from the original HList stuff I think, is equivalent to (~) or nearly so, I think
10:10:30 <Lethalman> yitz, which is what I am doing in the paste, isn't it?
10:10:34 <mercury^> bootcode: yes, but I am trying to understand why one would write something such as “instance (MonadTrans t, MonadST m, Monad (t m)) => MonadST (t m)” (which is from monad-st).
10:10:37 <cmccann> it's used for the delayed unification trick that you can do with (~) now
10:10:43 <Patrek> "data X a where C :: X Int"  ~>  "data X a =  :~: a Int =>  C"
10:10:55 <bitonic> Patrek: so `data Foo a where; Bar :: Foo Int' is actually something like `data Foo a = Bar (a ~ Int)'
10:11:03 <Lethalman> yitz, or you mean doing the calculation without the list? rather directly recursively?
10:11:06 <cmccann> but I'm not sure GHC would be able to deduce as much from something that isn't ~ since that's special
10:11:16 <mercury^> bootcode: none of that is answered by what you say if any MonadTrans instance t also has Monad m ⇒ Monad (t m).
10:11:25 <mercury^> (and ListT does)
10:11:45 <yitz> Lethalman: yes that's a slightly different problem
10:12:13 <Lethalman> yitz, and you say that's more idiomatic? using the IO monad like I would do in imperative style?
10:12:14 <yitz> Lethalman: yes that's the most straightforward way.
10:12:16 <Lethalman> that surprises me
10:12:29 <Lethalman> I thought haskell was about lazy stuff, map, filter and whatelse
10:12:45 <Lethalman> and you're saying I should be writing a for just recursively in haskell?
10:12:46 <bitonic> Patrek, cmccann: yeah, much less, ~ has various rules that GHC can use to derive equalities that would not be derivable with fundeps
10:12:48 <yitz> Lethalman: not the IO monad for StdGen. but for mersenne, definitely.
10:13:04 <bitonic> Patrek: and obviously it does a lot of inference to infer the equalities
10:13:34 <cmccann> bitonic, both will try to forcibly unify two type variables, so GHC can still do quite a bit with either
10:13:39 <bootcode> mercury^: Well, maybe they just want to provide MonadST instance for what seems reasonable?
10:13:45 <Lethalman> yitz, so I should be writing imperative style in haskell because libraries can't handle laziness properly with prng
10:13:55 <mercury^> edwardk: can you cut through my confusion? :)
10:13:57 <Patrek> bitonic: "has various rules that GHC can use to derive equalities" can you bring an example?
10:14:14 <byorgey> Lethalman: the larger problem, I think, is that we are still figuring out how to make Haskell work well with big data
10:14:15 <edwardk> back
10:14:19 <bootcode> mercury^: that implication may hold, I don't know. But that is independent from whether the (Monad m, MonadTrans t) => Monad t m holds or not.
10:14:25 <edwardk> mercury^: trying to read what you have
10:14:31 <byorgey> Lethalman: laziness makes space usage really tricky to reason about.
10:14:31 <yitz> Lethalman: once you really have a feel for that, and how it behaves when you scale a simple model, then you can try moving to applicative or monadic which allows you to abstract over the structure and not hard-code the graph/tree/whatever structure in your traversal function.
10:14:47 <edwardk> mercury^ the MonadST instance is a little evil
10:15:03 <bitonic> Patrek: but anyway I believe in System Fc those fundeps would actually be translated to type equalities between the two types
10:15:17 <edwardk> because if someone comes up with a non-monad transformer that had something of kind (* -> *) in the last position, that instance would fail
10:15:23 <Lethalman> byorgey, I'm sorry, what's not idiomatic with http://paste.debian.net/220849/ ?
10:15:46 <edwardk> the alternative though is making everyone write instances with manual lifts, i figured i'd ship the library this way until someone complained
10:15:47 <byorgey> Lethalman: I didn't say it wasn't idiomatic.  It's very idiomatic.
10:15:58 <Lethalman> byorgey, asking because yitz saying it's not
10:16:03 <bitonic> @google System F with Type Equality Coercions
10:16:04 <yitz> Lethalman: if you've got that down for the simple model (a list say), then you can try differing graph/tree models and know that if there are problems it's not because of some silly laziness/strictness issue.
10:16:05 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/fc-tldi.pdf
10:16:06 <lambdabot> Title: System F with Type Equality Coercions
10:16:15 <bitonic> Patrek: ^^^ that’s the paper you need to learn about ~
10:16:26 <bitonic> @google OutsideIn(X)
10:16:29 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/jfp-outsidein.pdf
10:16:29 <lambdabot> Title: OutsideIn(X) Modular type inference with local assumptions
10:16:31 <Patrek> bitonic: yes, I read both
10:16:36 <byorgey> Lethalman: I'm just commenting on some of the larger issues you're running into.  Writing Haskell programs that process lots of data is very difficult.
10:16:37 <Lethalman> yitz, the problem is that the library doesn't allow lazy lists for solving that problem, as simple as that
10:16:40 <bitonic> Patrek: ^^^ and that’s for the inference
10:16:41 <yitz> byorgey: you didn't say it. i said it.
10:16:43 <mercury^> edwardk: I don't fully understand. What do you mean by “non-monad transformer”?
10:16:54 <bitonic> Patrek: OK, then you know as much as me :)
10:17:11 <Lethalman> byorgey, I can see, but this time it's mostly about the library being broken, so right now I'm trying mwc and see what happens
10:17:26 <Lethalman> or better, not broken but not suitable for lazy lists
10:17:57 <edwardk> mercury^: consider newtype Foo s (f :: * -> *) a = Foo { runFoo :: ST s a }
10:18:09 <Patrek> I would like to know, in theory, if a type system with fundeps + constrained existentials is as expressive as a system with equality constraint/type families/GADTs
10:18:09 <edwardk> mercury^: that instance would be wrong for that type
10:18:30 <edwardk> mercury^: but the alternative is writing 30+ instances and having to deal with end users writing instances
10:18:39 <edwardk> do i went with the hack
10:18:42 <edwardk> er so i
10:19:14 <yitz> Lethalman: it's not that it doesn't allow it, but requiring keeping state - the generator - brings the problem to a whole different level. state makes things harder. (in any language)
10:19:19 <edwardk> Patrek: sounds like a fun research question. let us know when you finish that Ph.D ;)
10:19:33 <Patrek>  hehe
10:19:37 <bitonic> Patrek: they sound similar in expressivity, but it’s probably very subtle, and I definitely can’t give you an answer :P
10:20:03 <Lethalman> yitz, doesn't allow? well, then why the paste exceeds heap size?
10:20:22 <yitz> byorgey: what's in that paste isn't unconditionally unidiomatic. but it's unidiomatic when you are planning to scale the calculation to huge numbers of iterations.
10:21:37 <yitz> Lethalman: because that's not the right way to use lists when you want to do huge numbers of iterations while keeping state.
10:22:16 <Lethalman> yitz, no because it's StdGen Int Int and not StdGen !Int !Int
10:22:19 <mercury^> edwardk: But where is the MonadTrans instance in your example?
10:22:33 <yitz> Lethalman: i doubt that's the only problem
10:22:44 <edwardk> Patrek: that said, system Fc has been deceptively powerful, so if i had to pick a side to come down on I'd guess its not as powerful
10:22:47 <Lethalman> yitz, it is, I just profiled yesterday, cmccann can say
10:22:58 <byorgey> yitz: well, that's kind of what I meant before.  It seems like it *should* work but it doesn't.  We (as a community) haven't yet figured out really good, simple ways to get things to scale.
10:23:23 <bitonic> I’m with edwardk, FWIW
10:23:29 <edwardk> mercury^: my point is that that can't be a MonadTrans, so the instance that we have will go fishing for a MonadTrans instance for (Foo s), not find one and complain and any attempt to provide your own instance for it will overlap and fail
10:23:30 <yitz> Lethalman: if you write the function in a way that the values get forced all along and then immediately discarded, you solve many many problems in a large iteration.
10:23:47 <edwardk> mercury^: that is the price of that somewhat sloppy instance
10:23:50 <Lethalman> yitz, that's what I do in the paste
10:24:14 <Lethalman> yitz, I'm bored sorry, repeating myself since yesterday
10:24:38 <yitz> byorgey: that method of doing the calculation is analagous to doing a large iteration over floating point numbers that depends in an essential way on very low-order bits
10:25:14 <yitz> byorgey: it's taking tiny details of the operational semantics that the compiler happens to be using and amplifying them
10:25:50 <yitz> Lethalman: sorry i know. i wasn't here yesterday. :P
10:26:06 <yitz> Lethalman: but i understand your frustration.
10:26:14 <edwardk> mercury^: remember instance dispatch just looks at the head. so anything of the form (t m)  with t :: (* -> *) -> * -> *    m :: (* -> *) will match that instance
10:26:14 <mercury^> edwardk: and adding Monad (t m) fixes that because (t m) has a different kind than t?
10:26:27 <Lethalman> yitz, that loop works perfectly with mersenne and not with StdGen
10:26:27 <edwardk> mercury^: no. its not fixed
10:26:46 <mercury^> I still do not understand the purpose of the Monad (t m) clause then.
10:26:48 <mercury^> :(
10:26:49 <edwardk> mercury^: the Monad (t m) is necessary because MonadTrans t, Monad m   doesn't give you a monad for (t m)
10:26:55 <edwardk> its needed internally to write that instance
10:27:07 <mercury^> Oh, I see.
10:27:36 <mercury^> But should MonadTrans t not depend on Monad (t m)?
10:27:43 <edwardk> it can't
10:28:01 <mercury^> Right, because there is no m on the right side.
10:28:07 <edwardk> it'd have to be class (forall m. Monad m => Monad (t m)) => MonadTrans t
10:28:20 <edwardk> and we don't have those universally quantified constraints
10:28:26 <yitz> Lethalman: could be. my own style tries hard to avoid doing anything that depends on the exact strictness/laziness properties of various layers of libraries. that is, when writing stuff i know i might want to scale to huge numbers of iterations.
10:28:30 <mercury^> Could that be typed with an extension or not at all?
10:28:40 <edwardk> there are no such extensions
10:28:49 <Lethalman> yitz, not very nice for a language
10:28:49 <edwardk> i have some stuff in my constraints package
10:28:55 <edwardk> and you can fake it with that
10:29:17 <yitz> Lethalman: i disagree. i have a style i am very comfortable with that i feel gives me the best of both worlds.
10:29:35 <edwardk> by making a member liftMonad :: Monad m :- Monad (t m)   and requiring the user write 'liftMonad = Sub Dict'  in each instance
10:30:21 <yitz> Lethalman: i need to program in imperative languages too for work. i'm very fluent at that too, in fact i was before i learned haskell, but now i notice how awkward it is.
10:31:33 <Lethalman> yitz, you should write a tutorial then, because most of tutorials out there tell about how haskell is cool with lazy lists, map, filter and so on
10:31:45 <yitz> Lethalman: let's ask edwardk how he would do these kinds of things.
10:31:52 <edwardk> ?
10:31:54 <yitz> Lethalman: it *is* very cool.
10:32:05 <yitz> edwardk: wait a sec.i didn't ask yet.
10:34:04 <yitz> edwardk: does lenses have a way of doing traversals over huge data structures while keeping state? our example is traversing a huge graph labeled with probabilities, and traversing it while carrying around a random generator to get a graph of sample values.
10:34:20 <edwardk> :t mapAccumLOf
10:34:22 <lambdabot> LensLike (State acc) s t a b -> (acc -> a -> (acc, b)) -> acc -> s -> (acc, t)
10:35:25 <edwardk> you can of course just use the lens directly to mapMOf (or just apply it) with any monad you want
10:35:33 <edwardk> so you can work with MonadRandom, etc.
10:35:44 <yitz> edwardk: will that work equally for any of the kinds of random generators? StdGen, which is very (overly?) lazy, mersenne which is very strict (wraps C code that keeps global state), mwc which is somewhere in the middle?
10:35:55 <edwardk> yep
10:36:51 <edwardk> :t both putStrLn ("hello","world")
10:36:52 <lambdabot> IO ((), ())
10:37:01 <edwardk> :t mapMOf_ both putStrLn ("hello","world")
10:37:02 <lambdabot> IO ()
10:37:07 <yitz> Lethalman: edwardk is the author of a very general library called lens. he also has plenty of experience using random generators heavily.
10:37:41 <yitz> Lethalman: i think lens might still have a learning curve for haskell beginners though.
10:38:08 <edwardk> yitz: i'm working on lowering the steepness of the learning curve with more tutorial material, but yeah its still a bit steep
10:38:35 <yitz> yes it's improving all the time. i believe there's a big future to this.
10:39:09 <mercury^> edwardk: and just to be sure: the problem with the instance is that there are valid transformers (for example constant ones?) that would not actually provide the MonadST instance?
10:39:18 <edwardk> mostly because i refuse to dumb down the more powerful applications and generality of the library to serve a broader less sophisticated audience, and prefer to elevate the latter with training material ;)
10:39:40 <edwardk> mercury^: no, there are perfectly valid things that have kind (* -> *) -> * -> * that are not monad transformers.
10:40:00 <edwardk> mercury^: that instance is a pleasant fiction that pretends those things don't exist
10:40:40 <mercury^> Ah, ok. But constant transformers would also be a problem, no?
10:41:10 <edwardk> yitz: there is no such thing as a constant transformer. "Does it even lift?" =)
10:41:11 <yitz> edwardk: no, there are already plenty of simple things. it's just that there is so much that you have to figure out what to use. the right documentation, and perhaps some slight tweaking of api, has the potential making it very simple to do simple things.
10:41:16 <Lethalman> awesome, then given a function sample :: PGraph -> Rand Graph and a function satisfy :: Graph -> Bool, how do I get sometimes like sequence (replicate N sample) >>= \xs -> length $ filter satisfy xs  to work?
10:41:27 <Lethalman> s/sometimes/something
10:42:11 <mercury^> edwardk: ok, thanks for all the clarifications. :)
10:42:22 <edwardk> Lethalman: couple of observations
10:42:24 <edwardk> :t replicateM
10:42:25 <lambdabot> Monad m => Int -> m a -> m [a]
10:42:37 <edwardk> you can use that rather than sequence (replicate N sample)
10:42:44 <Lethalman> ok thanks
10:42:56 <applicative> Lethalman: but sasmmple is a function type above...
10:42:58 <applicative> sample
10:43:14 <Lethalman> applicative, (sample pgraph)
10:43:15 <cmccann> edwardk, the apartment building two down and across the street from mine seems to be on fire, can I fix that with lenses?
10:43:23 <applicative> ah ok
10:43:57 <yitz> cmccann: too late, they should have used a constant transformer
10:44:01 <applicative> fmap (length . filter satisfy) (replicateM n (sample pgraph))?
10:44:09 <cmccann> yitz, apparently so
10:44:51 <applicative> length . filter satisfy <$> replicateM n (sample pgraph)
10:45:00 <edwardk> cmccann: yes, but gravitational lensing may result in some collateral damage.
10:45:24 <mercury^> edwardk: so if I have my own monad that I always want at the bottom of a transformer stack, writing an instance of the kind that you wrote for MonadST is not completely kosher? That's really sad.  But choosing instances based on the context is problematic for the compiler, I suppose?
10:45:32 <cmccann> ah, so you have gravitational lenses now?
10:45:47 <yitz> Lethalman: what applicative says. but that assumes that your Rand monad is well-behaved when scaling to huge amounts of data.
10:46:05 <edwardk> mercury^: no you can write your own monads at the bottom of the stack, just make sure it doesn't look like (* -> *) -> * -> *
10:46:37 <Lethalman> applicative, heap exhausted
10:46:53 <Lethalman> yitz, still that was his most obvious way to do the thing
10:46:53 <applicative> this is what yitz is saying.
10:47:16 <edwardk> newtype Foo x y z s a = Foo { runFoo :: ReaderT x (StateT y (ErrorT e (ST s))) a}  would work fine for instance
10:47:45 <edwardk> er ErrorT z
10:48:00 <edwardk> because z there has kind * not kind * -> * everything works out fine
10:48:10 <edwardk> er because s has kind * not kind * -> *
10:48:20 <shachaf> (Zipper h t o p i a)
10:48:33 <applicative> Lethalman: hm, so the checking satisfy and the length getting should be on the other side. you dont want a list really ?
10:48:33 <shachaf> edwardk: Have you considered renaming the Coil argument to u?
10:48:40 <edwardk> shachaf: =)
10:48:47 <mercury^> edwardk: but if my monad comes with a class so that I do not have to lift everything?
10:49:07 <edwardk> mercury^: that also works fine
10:49:14 <edwardk> mercury^: i'm not seeing what you see broken
10:49:19 <Lethalman> applicative, the problem is a little more complex, but yes I'm only interested in some folded value
10:49:52 <shachaf> So what are the two Ints here?
10:49:58 <mercury^> edwardk: well, for the class I would write an instance such as “(MonadMine m, MonadTrans t, Monad (t m)) ⇒ MonadMine (t m)”, right?
10:50:29 <edwardk> mercury^: thats a pretty evil instance
10:50:36 <mercury^> edwardk: so it has the same problem as MonadST, i.e. that it behaves incorrectly with respect to things of kind (* → *) → * → * that are not transformers.
10:50:41 <edwardk> you're committing the same sin i do in MonadST ;)
10:50:51 <mercury^> edwardk: exactly. But do I have a better option?
10:51:09 <edwardk> mercury^: yes, the right answer is to make separate instances by hand for every transformer to lift your class over them
10:51:20 <edwardk> mercury^: it sucks, its tedious and its the right answer
10:51:33 <mercury^> But that is incredibly tedious and does not compose well with extensions to the transformers.
10:51:40 <edwardk> mercury^: correct
10:51:44 <mercury^> The latter being especially bad.
10:51:46 <edwardk> but its the 'right answer'
10:51:51 <hpaste> bitonic pasted “inference in and out lets” at http://hpaste.org/80060
10:52:04 <mercury^> Should the right answer not be compatible with any future transformers though?
10:52:12 <mercury^> Why is it conceptually necessary for it not to?
10:52:25 <hpaste> bitonic annotated “inference in and out lets” with “inference in and out lets (annotation)” at http://hpaste.org/80060#a80061
10:52:50 <bitonic`> what’s the reason for the above?
10:53:14 <edwardk> no, basically it comes down to the fact that you have to choose normally between putting the instances with the class, or with the data type, or orphaning. orphaning is generally unforgivable, and if you didn't define the data type, you can only sanely put it with the class.
10:54:21 <edwardk> i've written dozens of packages this way, its tedious. if someone needs to work with yours and a monad transformer stack and some monad they didn't write they can always wrap their transformer stack in a newtype, use generalized new type deriving to get almost all the instances and write the one or two they need by hand
10:54:27 <edwardk> but they always have _some_ solution
10:54:36 <applicative> Lethalman: of course the obvious thing is somehow to make a ref holding the number ;of repetitions to go and the number that have 'satisfied' , but thats lame
10:55:04 <edwardk> with orphans the only solution is pain, with magic instances like my monad-st instance you always wind up with some shape you can't use.
10:55:05 <Lethalman> applicative, I'm using foldlM and it's fine
10:55:22 <applicative> strict left fold yes.
10:55:43 <edwardk> the moment i need anything that the monad-st instance can't handle, i'm fully prepared to go explode it into 30 instances
10:56:05 <applicative> Lethalman: which properly optimized amounts to the obvious ugly plan
10:56:13 <mercury^> edwardk: orphaning means the kind of thing you did with MonadST?
10:56:26 <edwardk> no
10:56:34 <edwardk> thats a pretty rare 4th option
10:57:20 <mercury^> Putting it with the class is what mtl and monads-tf do? Putting it with the datatype is what transformers would do if type families or some such were portable?
10:57:24 <edwardk> putting it with the class ensures that if you get the class you get the instance, putting it with the data type ensures that if you get the data type you get the instance. orphaning is when you put the instance in a 3rd party module unrelated to either
10:57:50 <edwardk> the weird over-general instance i use is rarely applicable
10:58:26 <cmccann> it would be nice if we had a structured and principled approach to managing orphan instances. it seems like there are many cases where they could work fine.
10:58:36 <cmccann> we just have no way of distinguishing reasonable use from bullshit use.
10:59:02 <mercury^> edwardk: the main application I see for such instances is to newtype wrap a Reader, so that you can stack multiple readers and all the monadic actions read from the correct level.
10:59:07 <cmccann> kind of like turning on undecidable instances to do stuff that's blatantly and trivially decidable but beyond GHC's comprehension
10:59:23 <edwardk> 'multiple readers' is almost always a bad idea =P
10:59:47 <mercury^> edwardk: but one reader is not extensible.
10:59:48 <edwardk> make one big reader and make lenses or even just methods to access the parts of it you want
10:59:52 <edwardk> sure it is
11:00:23 <mercury^> Oh, so I have to put all the methods from one level into a class.
11:00:32 <edwardk> class HasL10n t where l10n :: Lens' t L10n      instance HasL10n L10n where l10n = id
11:00:51 <edwardk> now you can work with foo :: (MonadReader t m, HasL10n t) => …
11:01:17 <mercury^> Ok, I see.
11:01:20 <edwardk> you can derive that class for free with makeClassy, or write it by hand
11:01:28 <edwardk> if you don't want to use something like lens
11:01:47 <edwardk> then you get one big composite environment, and stuff all the parts you need into it
11:01:54 <edwardk> same works with state, etc.
11:02:10 <edwardk> with Control.Monad.Error.Lens you'll even be able to extend the exception set
11:02:22 <edwardk> using custom prisms
11:04:53 <NougatRillettes> Why hasn't HAskell a keyword for memoization
11:05:04 <NougatRillettes> even a really basic one
11:05:17 <edwardk> NougatRillettes: there are several libraries that provide combinators for memoization
11:05:33 <tgeeky> NougatRillettes: haskell often takes the approach of: if it can be done as a library, why make it a language feature?
11:05:46 <edwardk> NougatRillettes: it comes down to the fact that how to memoize is somewhat tricky. do you memoize all arguments ever> do you use a LRU cache? etc
11:05:48 <tgeeky> NougatRillettes: I suspect that is the case here; but smarter people will correct me if I'm wrong
11:05:54 <bitonic> OK, I’ve got a simpler example:
11:05:57 <bitonic> one :: (forall a. a -> a) -> b -> b
11:06:00 <mercury^> edwardk: by the way, I recently wrote something like this, with monads-tf; what would be the equivalent using mtl? “type family Thread array; type instance Thread (Array s) = s; class (MonadReader m, EnvType m ~ Array (Thread (EnvType m))) ⇒ ReadArray m; instance (MonadReader m, EnvType m ~ Array (Thread (EnvType m)))”
11:06:00 <bitonic> one f = f
11:06:03 <bitonic> two = let x = flip one in x 'x' id
11:06:03 <simpson> NougatRillettes: Memoization is not trivial.
11:06:06 <bitonic> works
11:06:10 <bitonic> two = (flip one) 'x' id
11:06:13 <bitonic> doesn’t.  why?
11:06:36 <NougatRillettes> http://www.haskell.org/haskellwiki/Memoization#Memoizing_fix_point_operator
11:06:43 <NougatRillettes> thos one would be enough
11:06:48 <tgeeky> simpson: that's surely not the right argument? Lots of language features aren't trivial
11:06:51 <edwardk> mercury^: you do realize the monads-tf is unmaintained these days, right? it was an experiment that was tried and failed a couple of years ago and the current mtl is based on monads-fd and monads-tf was retired
11:07:00 <mercury^> edwardk: err, with “⇒ ReadArray m” missing at the end.
11:07:06 <NougatRillettes> so you don't have to code the application of the combinator yourself
11:07:16 <NougatRillettes> +that
11:07:22 <mercury^> edwardk: hmm, there was a new upload some time ago, I think.
11:07:23 <shachaf> bitonic: Because rank-2 types are hard.
11:07:40 <tgeeky> NougatRillettes: a memoizing fixed-point operator is rather specific compared to memoizing in general?
11:07:45 <bitonic> shachaf: that’s a bit vague
11:07:46 <simpson> NougatRillettes: Have you seen Data.MemoCombinators yet?
11:07:51 <simpson> NougatRillettes: http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html There you go!
11:07:56 <mercury^> edwardk: I would be more happy to switch if I knew how to do the above with mtl though. :)
11:08:00 <edwardk> NougatRillettes: http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.3/doc/html/Data-MemoCombinators.html
11:08:31 <applicative> NougatRillettes: what about Data.MemoCombinators
11:08:32 <simpson> Oh, yeah, the newer version's probably a better idea. :3
11:08:37 <Lethalman> mwc didn't satisfy me either... :P
11:08:53 * Lethalman gives up and writes the simulation in imperative style
11:08:54 <edwardk> NougatRillettes: this is also the purpose of my http://hackage.haskell.org/package/representable-tries
11:10:27 <binroot> Hey guys, I installed the permute library from Hackage, but ghci can't find it. I installed HTTP and it worked find. But it can't find Permute when searching in Data/
11:10:33 <binroot> any ideas?
11:10:37 <applicative> NougatRillettes: or the innocent looking http://hackage.haskell.org/packages/archive/uglymemo/0.1.0.1/doc/html/Data-MemoUgly.html
11:10:57 <edwardk> mercury^ EnvType m ~ Array (Thread (EnvType m)) seems suspiciously infinite to me
11:10:58 <bitonic> shachaf: I get the feeling that the issue here is that with `let' bindings the type variables will be all to the left and so the quantification is different
11:11:20 <bitonic> shachaf: but I can’t pinpoint what’s going on here, also because the error is quite bizarre
11:11:21 <applicative> binroot, is it a new instance of ghci?
11:11:29 <binroot> applicative: yea
11:11:30 * applicative begins with the most obvious
11:11:49 <shachaf> bitonic: You'll find similar issues with runST and lots of other rank-2 things.
11:12:04 <binroot> I can import Network.HTTP, but not Data.Permute
11:12:09 <mercury^> edwardk: it compiles just fine and does exactly what one wants. :)
11:12:18 <edwardk> NougatRillettes: the point is there are at least 3 libraries out there for doing this, not counting the ones that use evil memoization techniques under the hood like my 'intern' library, and its not clear which should be standard if any. there are lots of points in the design space
11:12:19 <applicative> binroot: does 'ghc-pkg list' show the permute library?
11:12:24 <edwardk> mercury^: using UndecidableInstances?
11:12:27 <mercury^> edwardk: yep.
11:12:36 <edwardk> mercury^: you're sitting on a timebomb i think ;)
11:12:37 <bitonic> shachaf: the weird issue with ST is the special case for ($), but I never encountered this
11:12:38 <binroot> applicative: yea, it shows permute-1.0
11:12:50 <shachaf> bitonic: The case isn't that special.
11:12:51 <NougatRillettes> ok I see edwardk :)
11:12:59 <bitonic> shachaf: that case is very special
11:13:02 <shachaf> > let dollar f = f in runST `dollar` return 5
11:13:03 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s a0'
11:13:03 <lambdabot>              with a...
11:13:06 <shachaf> > let dollar f x = f x in runST `dollar` return 5
11:13:07 <lambdabot>   Couldn't match expected type `forall s. GHC.ST.ST s t0'
11:13:07 <lambdabot>              with a...
11:13:13 <shachaf> Hmm.
11:13:17 <applicative> binroot: hm, can it be that there's more than one ghci around?
11:13:48 <edwardk> mercury^: lets unravel this to get to the point of 'ReadArray'
11:13:53 <binroot> applicative: what do you mean? like multiple running? I can try restarting. But I only have one installed
11:13:56 <shachaf> I guess it changed again?
11:14:19 <bitonic> shachaf: <http://www.haskell.org/pipermail/glasgow-haskell-users/2010-November/019431.html> “However, people so often write `runST $ do ...' that in GHC 7 I implemented a special typing rule, just for infix uses of ($).  Just think of (f $ x) as a new syntactic form, with the obvious typing rule, and away you go.”
11:14:49 <edwardk> mercury^: is that baically MonadReader (Array (Array (Array (Array (Array …)))))) m  ?
11:14:57 <shachaf> bitonic: At one point it wasn't the case.
11:15:05 <edwardk> or are you using the Thread (Array s)) to get it down to just Array s
11:15:07 <applicative> binroot: I meant that somehow the ghci you were running and the ghc-pkg you are running are not really from the same ghc install, but I guess thats not likely
11:15:24 <bitonic> shachaf: my quote says “in GHC 7 I implemented”...
11:16:16 <mercury^> edwardk: No, it's MonadReader (Array s) m.
11:16:39 <shachaf> Yes.
11:16:39 <bitonic> but anyway, I’d really like to know what the hell is going on in my example
11:16:39 <binroot> applicative: I did 'cabal install HTTP' which worked fine. But I did 'cabal install -p permute' which is having the problem
11:16:39 <binroot> you think that's the problem?
11:16:39 <edwardk> if its the latter, isn't that just class MonadReader (Array a) m => ReadArray a m
11:16:39 <edwardk> instance MonadReader (Array a) m => ReadArray a m
11:16:40 <edwardk> so why all the crazy ~'s?
11:16:48 <applicative> oh profiling libraries.  i'm surprised i'ts showing up in ghci though
11:16:49 <edwardk> you can go farther with constraint kinds
11:17:02 <edwardk> type MonadArray a m = MonadReader (Array a) m
11:17:49 <mercury^> edwardk: but I want to get rid of the ‘s’ parameter of the instance (because it is rarely relevant).
11:18:14 <mercury^> I.e. I do not want MonadArray to have two arguments.
11:18:58 <applicative> binroot: wait mayabe its simpler, is this the package http://hackage.haskell.org/package/permute-1.0 and the module name you were asking for
11:19:06 <binroot> applicative: yea
11:20:06 <edwardk> mercury^: then you're screwed
11:20:42 <edwardk> if its not relevant, then why are you requiring MonadArray for that combinator?
11:20:54 <edwardk> just limit your constraints to what you use in each combinator
11:21:05 <edwardk> and then the only time you mention that thing in the signature is when you are using it
11:21:44 <mercury^> edwardk: It is relevant sometimes, just like (World m) is sometimes relevant for MonadST.
11:21:49 <applicative> binroot: I'm clueless. I don't see how the difficulty can be that you did cabal install -p permute ; you could do ghc-pkg unregister permute and try again of course
11:22:06 <edwardk> mercury^: and when its relevant pass it through. ;)
11:23:12 <edwardk> my objection to monads-tf is entirely pragmatic. the rest of the ecosystem uses the mtl because its in the platform and the mtl and monads-tf needlessly collide on module names so library authors can't provide instances for both without relying on package imports or other unsavory unportable tricks
11:23:18 <binroot> applicative: weird, it's still now working. Can you try installing permute?
11:23:27 <binroot> applicative: maybe something is wrong with the package?
11:23:41 <edwardk> so by using monads-tf you cut yourself off from pretty much the entire world
11:23:45 <mercury^> edwardk: :/
11:23:56 <mercury^> edwardk: but you see why it is helpful for me in this case?
11:24:11 <edwardk> i see that you think it is. ;)
11:24:18 <mercury^> (The s in Array s being a World)
11:24:24 <gwern> ah, well, it's that time of year. time to judge how the haskell summer of code projets went and see how well I did in predicting: http://www.gwern.net/Haskell%20Summer%20of%20Code#predictions
11:24:30 <gwern> first up, scoutess
11:24:39 <applicative> binroot: it seems to work fine here. not sure what it could have been.
11:24:48 <binroot> applicative: hmm
11:24:57 <binroot> applicative:
11:25:24 <binroot> applicative: when I do 'ghc -v myfile.hs', it searches for Data.Permute in Data/ and doesn't find it
11:25:25 <edwardk> in practice i find the cost passing a type argument through a few signatures to note that i care about it to be far less than the cost of the alternatives you keep digging up =P
11:25:44 <gwern> ...does anyone at all use scoutess?
11:25:57 <applicative> binroot: but the module is Text.ParserCombinators.Perm
11:26:32 <applicative> binroot: this was my earlier theory you want cabal install permutation
11:26:44 <applicative> ... I think ...
11:27:01 <mercury^> edwardk: maybe I am being a bit stubborn and it does not matter much, but still it seems odd that one would have to write “ArrayAction s m ⇒ Int → m ()” and not just “ArrayAction m ⇒ Int → m ()”.
11:27:07 <applicative> hackage has run out of names
11:27:21 <stepkut> gwern: no, but we are still developing it :)
11:27:21 <binroot> applicative: *facepalm*
11:27:26 <binroot> applicative: thank you!
11:27:36 <applicative> ah we figured it out
11:27:39 <gwern> stepkut: that's it? a whole Soc and it's not usable?
11:28:03 <binroot> applicative: that works :)
11:28:54 <edwardk> mercury^: 2 characters there in exchange for not writing Thread (EnvType m)  or whatever abomination you have to write now ;)
11:29:07 <edwardk> > length "Thread (EnvType m)"
11:29:08 <lambdabot>   18
11:29:28 <edwardk> so if you use it in 1/9th of the function signatures, it pays off =P
11:29:57 * gwern notices scoutess isn't even on hackage, apparently
11:30:15 <stepkut> gwern: it requires cabal integration of sandboxes to be truely useful
11:31:25 <gwern> stepkut: so no one is actually using it
11:31:41 <stepkut> not at the moment
11:31:45 <holidayinn> How can I parse a string to an integer, but dealing errors myself rather than just dumping core?
11:32:12 <srhb> :t reads
11:32:13 <lambdabot> Read a => ReadS a
11:32:17 <srhb> Helpful.
11:32:43 <monochrom> see my http://www.vex.net/~trebla/haskell/reads.xhtml
11:32:53 <srhb> > reads "20" :: [(Int, String)]
11:32:55 <lambdabot>   [(20,"")]
11:33:01 <srhb> > reads "20abc" :: [(Int, String)]
11:33:02 <lambdabot>   [(20,"abc")]
11:33:10 <srhb> > reads "abc20abc" :: [(Int, String)]
11:33:11 <lambdabot>   []
11:33:31 <holidayinn> got it thanks
11:33:43 <holidayinn> i was looking for something with error or whatever in the title so overlooked that
11:33:58 <srhb> holidayinn: Luckily not necessary in this case. :)
11:34:18 <stepkut> gwern: the goals that were established at the beginnig were met, but those goals weren't actually intended to result in a finished product
11:34:43 <ion> > let readMay s = case reads s of [(a,"")] -> Just a; _ -> Nothing in readMay "20" :: Maybe Integer
11:34:44 <lambdabot>   Just 20
11:34:44 <gwern> stepkut: wouldn't be the first time google approved a bad soc idea
11:34:50 <stepkut> gwern: mostly, because it didn't makes sense to implement sandboxes when cabal was supposed to be getting them via a separate GSoC project
11:35:17 <stepkut> perhaps
11:35:27 <stepkut> there are a lot of people still interested in using scoutess
11:36:32 <merijn> ion: GHC now exports readMaybe in Text.Read which has type "Read a => String -> Maybe a", nicer to use than reads
11:36:41 <gwern> stepkut: regardless, it's a clear failure of my criteria specified back in april
11:36:53 <stepkut> gwern: good for you
11:37:03 <gwern> (next, loren davis's concurrent hashtable)
11:37:40 <holidayinn> merijn: readMaybe's what i was looking for - seems to be a much simpler idea than reads
11:37:52 <holidayinn> merijn: and in a monad so i can compose - nice
11:37:59 <pnielsen> srhb, ion: That is also in the Safe package
11:38:08 <ion> merijn: yeah
11:38:22 <merijn> holidayinn: Yeah, it's just a trivial wrapper around reads in practice, but much nicer than manually case-of'ing every time :)
11:38:39 <ion> > readMaybe "42" :: Maybe Integer -- Does lambdabot have a new enough GHC?
11:38:41 <lambdabot>   Not in scope: `readMaybe'
11:38:56 <Lethalman> cmccann, byorgey, edwardk, so I ended up with http://paste.debian.net/220876/ to achieve constant heap size, does it look haskellish enough? :S
11:38:57 <merijn> > Text.Read.readMaybe "42" :: Maybe Integer
11:38:59 <lambdabot>   Not in scope: `Text.Read.readMaybe'
11:39:24 <applicative> merijn: is it in the Prelude?
11:39:29 <pnielsen> http://hackage.haskell.org/packages/archive/safe/0.3.3/doc/html/Safe.html
11:39:38 <merijn> holidayinn: I think it's only available since GHC 7.4 (or maybe one version before), but if you use Haskell Platform your fine
11:39:42 <merijn> applicative: No, Text.Read
11:40:14 <applicative> merijn: ah yes, I found it.
11:40:22 <gwern> what the heck, it's not mentioned anywhere... has anyone heard anything at all about loren davis's concurrent hashtables?
11:41:22 <pnielsen> FWIW safe.readMay is simpler than Text.Read.readMaybe
11:41:33 <edwardk> gwern: he was ryan's student who failed at the midterm, no?
11:41:39 <gwern> edwardk: I have absolutely no idea
11:41:51 <merijn> pnielsen: Simpler? In what sense?
11:42:06 <gwern> edwardk: because I'm not seeing anything in google or anywhere beyond the initial proposals and then mentions of acceptance of his project
11:42:08 <pnielsen> merijn: http://hackage.haskell.org/packages/archive/safe/0.3.3/doc/html/src/Safe.html#readMay vs. http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Text-Read.html#readMaybe
11:42:17 <edwardk> gwern: let me check the email trail
11:42:52 <pnielsen> merijn: though I assume they compile down to the same
11:42:56 <edwardk> yeah, he failed at the midterm. he got a job and didn't have any time to put in
11:43:28 <gwern> edwardk: so he got a job and then failed the midterm milestone? or other way around
11:43:42 <edwardk> actually my bad. he cited family problems
11:44:00 <applicative> type families?
11:44:06 <pnielsen> lol
11:44:07 <edwardk> he vanished before the midterm, then came back and cited family problems, but we failed him at the midterm
11:44:21 * gwern shrugs. well, if he never delivered anything, then it was obviously a failed soc. wil just check edward kmett as my source
11:44:29 * hackagebot gitit 0.10.1.1 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.1.1 (JohnMacFarlane)
11:44:50 <edwardk> yeah, he never even got paid beyond the first $500 or so
11:45:10 <cmccann> Lethalman, it looks reasonably idiomatic at first glance if that's what you're asking
11:45:22 <holidayinn> Does cabal use semantic versioning? I was thinking that if I want to depend on, for example, text, I'll always have to specify an exact version number, as any version 0.n may totally change the API mightn't it?
11:45:34 <Lethalman> cmccann, yes that's what I was asking :) thanks
11:45:41 <gwern> edwardk: too bad. a good example that a previous SoC experience is no guarantee
11:45:42 <applicative> if you google haskell and hashtable you get lots of harrop. how I miss him....
11:45:50 <bootcode> any idea why doctest fails with a GHC error about overlapping instances, which lists the same instance (defined in that module) 3 times?
11:45:51 <gwern> applicative: what happened to him?
11:46:14 <edwardk> gwern: nothing bad. we just got better at tuning him out ;)
11:46:37 <cmccann> Lethalman, I could probably find SOMETHING to nitpick about if I looked at it long enough but seems fine overall
11:46:42 <applicative> gwern, he got married; I think his wife told him to shut up.   The first clause is true; the second I made up.
11:46:49 <gwern> hah
11:46:51 <gwern> maybe he mellowed out
11:46:52 <edwardk> bootcode: you probably have multiple versions of the same package in ghc-pkg and its loading a different one than the library
11:46:52 <cmccann> Lethalman, my biggest complaint would be that you're not using hpaste :P
11:47:06 <Lethalman> cmccann, ahah ok :)
11:47:22 <edwardk> bootcode: in lens i jump through hoops to generate an exact version list for all of the dependencies of my libraries and make my generated doctest harness use precisely those versions
11:47:24 <Lethalman> cmccann, have to check if it's usable with pastebinit
11:47:35 <edwardk> bootcode: because we had similar issues for some people building stackage
11:47:44 <merijn> Lethalman: Incidentally, hpaste will hlint your code and suggest cleanups
11:47:47 <cmccann> Lethalman, it gives you hlint output and syntax highlighting for Haskell, which is nice
11:47:55 <Lethalman> ah awesome
11:48:14 <Heffalump> I think he was married well before we encountered him. I think he actually started getting some work to do though.
11:48:18 <Lethalman> is there a commandline for hpaste?
11:48:31 <gwern> edwardk: so what about mdittmer's "Accelerating Haskell Application Development" ?
11:49:01 <Lethalman> sigh no hpaste in pastebinit
11:49:02 <merijn> Lethalman: I think one exists, yeah. But don't ask me for a name
11:49:17 <Lethalman> have to create it
11:49:31 * cmccann recalls one existing as well, and also can't remember what it would be called, heh
11:49:31 <Lethalman> (the conf file for pastebinit I mean ;) )
11:49:37 <merijn> Lethalman: http://code.google.com/p/pastepipe/ ?
11:49:46 <edwardk> he was the one who left around the midterm for work purposes.
11:50:13 <edwardk> "He stopped working on the project mostly. Although it actually started a week or two before mid term. This is because he already has a full time job researching and this project has been a secondary concern for him. So some combination of his research work deepening or his desire to keep up with GSoC lessening."
11:50:22 <edwardk> he passed the midterm and we failed him at the final.
11:50:23 <gwern> edwardk: so, loren left for pesonal/family reasons, and mdittner left for work reasons?
11:50:28 <edwardk> yeah
11:50:33 <Lethalman> merijn, ok thanks
11:50:33 <gwern> edwardk: wow, this wasn't a very good soc so far...
11:50:55 <edwardk> gwern: yeah. those two were kinda rough
11:51:18 <gwern> (scoutess was a dud, and the next two were simply failures, and it's not like there were *that* many projects)
11:51:46 <edwardk> i'm still somewhat hopeful about scoutess as i've been following a bit of the development and its still an actively going concern
11:51:47 <`ramses> :q
11:51:55 * byorgey thinks gwern is being a bit harsh on scoutess.
11:51:57 <edwardk> but by your draconian metrics 'dud' is appropriate =P
11:52:19 * gwern is so draconian, he demands useful things used by more than 1 person
11:52:33 <cmccann> it's more the time frame that's draconian here I think :P
11:52:52 <gwern> bah, I gave them like a quarter of a year after the soc ends before I began judging
11:53:02 <byorgey> gwern: at least I think you will find that #5 is a success =)
11:53:03 <gwern> it's not august anymore, neh?
11:53:06 <edwardk> gwern: i'm somewhat hopeful that we'll be able to set up a scoutess build farm, they stated in the application that it'd probably take more than the summer to complete
11:53:27 <roconnor> how do I tell ghc to use the haskell98 package?
11:53:47 <edwardk> roconnor: add haskell98 to the build-depends: list in the cabal file.
11:53:58 <byorgey> (and remove 'base')
11:53:58 <Heffalump> where's the list of projects?
11:54:11 <byorgey> Heffalump: http://www.gwern.net/Haskell%20Summer%20of%20Code#predictions
11:54:14 <edwardk> Heffalump: they took down last year's site
11:54:18 <gwern> the bastards
11:54:20 <gwern> I hate them so much
11:54:29 <edwardk> so its gwern's list and what i have in my notes, etc.
11:54:38 <gwern> would it be so effing hard to leave up some static html pages?
11:54:57 <Heffalump> the melange list is still there, but it seems incomplete
11:55:03 <gwern> it's absurd I have to act as an archivist for google
11:55:16 <byorgey> gwern: oh, and you can update #5 from last year, parallel builds with cabal is now released
11:55:17 <holidayinn> What does Cabal mean by "only already installed instances can be used"
11:55:23 <byorgey> gwern: I use it all the time
11:55:47 <edwardk> oh yeah it moved from socghop.appspot to google-melange
11:55:51 <roconnor> http://hpaste.org/80062 -- here is my error
11:56:02 <roconnor> utils/ghc-pkg/Main.hs:76:8:
11:56:03 <roconnor>     Could not find module `IO'
11:56:03 <gwern> byorgey: oh yeah? I'll look into that later, 2012's socs are more important right now
11:56:05 <roconnor>     It is a member of the hidden package `haskell98-2.0.0.1'.
11:56:27 <byorgey> gwern: sure
11:56:36 <edwardk> roconnor: my recommendation? update the code to use base, and drop the dep on haskell98 unless you have a real reason to depend on it
11:56:39 <gwern> byorgey: I didn't notice any of my cabal installs for the last few months being parallel or anything
11:56:59 <byorgey> gwern: you have to pass  -j
11:57:00 <edwardk> oh thats building ghc
11:57:03 <roconnor> edwardk: I'm not going to change ghc 6.12.3
11:57:05 <edwardk> good luck =)
11:59:06 <monochrom> no, the other alternative is to depend on haskell98 and do not depend on base
12:00:09 <edwardk> that too
12:00:10 <monochrom> but since you're on 6.12.3, you also have the option of depending on both. newer GHC will not like that though
12:00:31 <edwardk> monochrom: he's building 6.12.3, not on it
12:00:34 <gwern> where to find info on Mikhail Glushenkov's sandboxed builds...
12:00:38 <monochrom> oops
12:00:59 <gwern> edwardk: http://hackage.haskell.org/trac/hackage/wiki/SandboxedBuildsAndIsolatedEnvironments seems to imply that we can't actually use #5 yet
12:02:01 <gwern> as does http://blog.johantibell.com/2012/08/you-can-soon-play-in-cabal-sandbox.html - says no UI
12:02:10 <edwardk> gwern: he passed final evaluation, but i'm not sure about the current usability of it
12:03:17 <edwardk> it was one of those things where he worked the whole summer and put in a good faith effort, but where i think the task was too big
12:03:56 <byorgey> gwern: you can use it I think, with  'cabal sandbox-init' etc.
12:05:19 <byorgey> gwern: yes, you can use it in HEAD cabal, I just confirmed
12:05:37 <byorgey> it just doesn't yet have a polished UI
12:11:31 <gwern> byorgey: but no a released version?
12:12:02 <byorgey> gwern: not yet, the patches got merged after the 1.16 release
12:12:23 <cmccann> gwern, wasn't being in HEAD your criteria there anyway?
12:12:30 <edwardk> gwern: by that standard any cabal projects will 'fail' for a year or so before succeeding
12:12:45 <gwern> cmccann: ah, so it was. scratch the question mark, then
12:13:39 <gwern> on to #6 then. "Enable GHC to use multiple instances of a package for compilation"
12:14:02 <edwardk> gwern: you may need to follow up with kosmikus on this one
12:15:23 <gwern> edwardk: who's that?
12:16:02 <applicative> gwern 23Skidoo  last committed a few minutes ago https://github.com/haskell/cabal  https://github.com/23Skidoo/cabal maybe you should ask him
12:16:24 <edwardk> gwern: andres löh, mentor
12:16:39 <gwern> applicative: nah, i'm done with the sandbox judgment. i specified in teh HEAD, and byorgey says it's in HEAD. case closed
12:17:05 <gwern> edwardk: ah
12:17:15 <gwern> edwardk: did he pass but with useless patches or something?
12:17:35 <Lethalman> looks like PastePipe won't compile :(
12:17:55 <applicative> the sandbox business looks like it might be(come) a smashing success.
12:18:00 <edwardk> i seem to recall that he passed. i don't know about the usefulness of the patches though. i may have a log from talking to kosmikus at the end
12:19:41 * applicative thinks it should be cosmicus or else kosmikos or maybe kosmikē
12:19:47 <Lethalman> ah, haste
12:19:50 <gwern> edwardk: from the sound of http://hackage.haskell.org/trac/ghc/wiki/Commentary/GSoCMultipleInstances it's not in ghc HEAD and may never be
12:19:53 <edwardk> gwern: yeah for definitive info youll need to ping him
12:20:34 <edwardk> fair enough
12:21:56 <edwardk> gwern: it does sound relatively doomed until we get something more nix-like for package management
12:22:25 * gwern feels regret for predicting success at 65%. should've known that ghc socs are just as dangerous as cabal socs
12:23:08 <gwern> the fault is mine. no one guaranteed me it would be successful, and who would be better than me at predicting socs?
12:23:42 <chrisdone> can someone explain what this guy is talking about? it's CT so perhaps someone here can translate into haskell terms that i can understand http://news.ycombinator.com/reply?id=4993384&whence=item%3fid%3d4992603
12:24:06 <cmccann> gwern, are you doing better so far than "0% for everything" would have? :P
12:24:33 <gwern> cmccann: yes, but the proper comparison is more like a '60% for everything' predictor, sine that's the overall baserate
12:24:41 <r00723r0> Is Haskell homoiconic?
12:24:48 <applicative> gwern here is his and kosmikus' own account http://www.haskell.org/wikiupload/5/50/Hiw2012-philipp-schuster.pdf
12:24:49 <chrisdone> no
12:24:58 <chrisdone> that's usually reserved for lisp
12:25:05 <gwern> what about liskell
12:25:13 <chrisdone> i'd call that a lisp
12:25:54 <sclv> chrisdone: i know nobody else who would :-P
12:26:16 <edwardk> r00723r0: no
12:26:23 <gwern> applicative: thanks
12:26:35 <edwardk> r00723r0: we have a fairly rich syntax
12:26:41 <chrisdone> for me, lisp is about s-expressions and optionally quasiquotation
12:26:43 <applicative> and a video fwiw http://www.youtube.com/watch?v=h4QmkyN28Qs , gwern
12:26:54 <sclv> also i know the soc standards are v. rough.
12:27:06 <sclv> vis a vis "success" in this metric
12:27:40 <sclv> in that i'd consider something like this a modest success even if the patches as such don't get merged. because it meant mapping the design space of a tough problem in a serious way.
12:27:52 <sclv> that i'm pretty sure will serve us well in he future.
12:27:54 <Nereid> chrisdone: you mean like (g . h) *** (i . j) = (g *** i) . (h *** j)
12:27:55 <neutrino_> hi
12:29:45 <edwardk> gwern uses much more rigid guidelines for success than the rest of us do, but I can't get him to help with the actual selection process, only complain about it afterward =P
12:30:12 <gwern> applicative: I don't bother with videos. they're not part of my archival system, so I refuse to rely on them. youtube's particularly bad about videos just dying after a few years
12:30:14 <chrisdone> Nereid: hmmm, interesting
12:30:33 <applicative> I'm a little worried if this schuster guy gets dissed; he seems wonderful
12:30:45 <chrisdone> Nereid: ⊗ is ***?
12:30:47 <cmccann> edwardk, well obviously helping with selection would bias the results and interfere with gwern's ability to predict failure rates objectively
12:30:48 <Nereid> chrisdone: there was a typo in the post, which probably didn't help
12:30:49 <Nereid> yes
12:31:04 <Nereid> well, on objects it's (,), and on morphisms it's ***
12:31:30 <chrisdone> what is the typo?
12:31:49 <Nereid> it should read (g ∘ h) ⊗ (i ∘ j) = (g ⊗ i) ∘ (h ⊗ j)
12:32:11 <edwardk> cmccann: i'm more concerned with improving the actual process
12:32:12 <chrisdone> ah :/
12:32:46 <cmccann> edwardk, even aside from gwern's standards this year sounds less than inspiring :T
12:32:52 <cmccann> well, last year.
12:32:57 <cmccann> the most recent one.
12:32:59 <cmccann> whatever.
12:33:16 <edwardk> cmccann: it was a rough year. two students vanishing wasn't something we could have anticipated though
12:33:24 <cmccann> yeah
12:33:27 <edwardk> there were no particular hints in their applications
12:33:33 <applicative> cmccann: I'm not seeing that, the cabal sandbox seems on course; doesn't it seem it might be a major event?
12:33:55 <edwardk> i mean, even alpmestan vanished randomly the year prior when he went to be a student due to a failing computer or some such
12:34:42 <chrisdone> Nereid: oh, the comment was also badly formatted. so confused =)
12:34:44 <Nereid> heh
12:35:26 <applicative> cmcann and this multiple packages thing would be a miracle; small progress wouldn't be small, as sclv says
12:35:26 <byorgey> chrisdone: when I try to visit that link it says "you have to be logged in to comment"
12:35:35 <cmccann> applicative, sure, just the mixture of "unexpected vanishing" and "not ready to use yet" is kinda meh
12:35:52 <snowylike> vanishing students?
12:36:02 <cmccann> as far as the SoC itself goes
12:36:02 <byorgey> oh, Nereid is already explaining, nvm
12:36:03 <snowylike> sounds like some kind of magical forest with trolls and elfs
12:36:05 <chrisdone> byorgey: ah maybe it was a 'reply' link: http://news.ycombinator.com/item?id=4993384
12:36:13 <applicative> snowylike: yes, sign up for gsoc with a haskell project, and who knows
12:36:13 <Nereid> yeah I got that too.
12:36:24 <gwern> ok, next soc... "multiuser browser-based interactive ghci, hpaste.org meets tryhaskell.org, for improved teaching of those new to Haskell."
12:36:34 <applicative> snowylike: it's happens sometime, haskellers just *explode*...
12:36:38 <applicative> sometimes...
12:36:44 <chrisdone> i noticed someone below posted a properly formatted version, so i'm re-reading
12:37:06 <snowylike> i'd like to think that they lazily explode, which is why they disappear
12:37:07 <snowylike> they don't want to be examined
12:37:18 <chrisdone> haha, even the guy fixing the formatting got it wrong also. jesus, what a mess
12:38:13 <deus_rex> is there a name for an unordered pair {a,b} where it's permitted for a == b?
12:38:14 <byorgey> deus_rex: "unordered pair"
12:38:28 <gwern> dammit, f all the times for shapr to not be in irc
12:38:40 <croikle> multiset?
12:38:43 <deus_rex> hmm, i had read that an unordered pair requires distinct elements
12:39:25 <byorgey> deus_rex: perhaps some people define it that way, but that's not the meaning of "unordered pair" I know
12:39:51 <pantsman> if unordered pair is implemented as a set of 2 elements, maybe
12:40:13 <pantsman> set of size 2, I mean
12:40:31 <sclv> hah freaking set theorists messing everything up
12:40:37 <gwern> ah, at https://github.com/shapr/ghclive#readme
12:40:46 <Nereid> a multiset is probably the way to go
12:40:59 <chrisdone> gwern: he should be about on twitter or google+, if you want to poke him
12:41:17 <chrisdone> i'm also interested to see that project
12:41:28 <gwern> last edits 4 months ago... that's not a good sign
12:42:31 <chrisdone> iirc it was a little more than shapr expected, learning/development-wise, luite helped out a lot and i think he got it finished best he could, and, i *suspect* that's it
12:43:00 <chrisdone> (not to try to speak for shapr, of course)
12:43:32 <gwern> I didn't think my criterion was very strict: 'Judgment: whether multi-user sessions have gone live.' I didn't even specify that anyone had to use it, just that it was running on a server somewhere
12:43:41 <gwern> geez
12:43:46 <byorgey> it worked fairly well, but not quite well enough yet to really use it in practice
12:43:51 <byorgey> and it isn't up and running anywhere
12:44:12 <gwern> dammit that was 80% too. why shapr why
12:44:13 <byorgey> I don't think shapr has had time to continue working on it since the SOC ended
12:44:18 <gwern> (I trusted you!)
12:44:39 <sclv> its not for multi-user use as i recall
12:44:46 <byorgey> yes it is
12:45:05 <sclv> huh, i thought they didn't do the sandboxing stuff?
12:45:12 <chrisdone> sclv: one analogy was a "web lambdabot that you could put code on"
12:45:20 <sclv> right that was the initial goal
12:45:25 <sclv> or one initial goal
12:45:27 <Targen> @pl \x -> (x . map return =<<)
12:45:27 <lambdabot> (=<<) . (. map return)
12:45:40 <sclv> as i recall, they made the choice to build it out as a single-user tool instead
12:45:42 <byorgey> shapr definitely got multi-user stuff working, I played with it at the same time as other people
12:46:09 <byorgey> no, the whole goal was to have it be usable as an interactive teaching tool
12:46:16 <sclv> hmmm
12:46:42 <chrisdone> Nereid: thanks, btw, i get the point he was trying to make now
12:46:43 <sclv> i remember asking why it wasn't just up on a server somewhere, and being told that it was because you were supposed to install it yourself
12:46:55 <sclv> b/c of sandboxing issues
12:47:09 <Targen> Is there some way to splice names when using Template Haskell for declarations?  It’s rather ugly to build ASTs with combinators.
12:47:17 <byorgey> well, there are certainly sandboxing issues
12:47:25 <gwern> from the original description, it was supposed to be public: 'If tryhaskell allowed multiple users to view the same interpreter state, and allowed users to paste in new code, teaching and debugging would be much easier for people new to Haskell.'
12:47:30 <gwern> you don't install tryhaskell locally
12:47:35 <sclv> right -- so its usable by multiple trusted people
12:47:48 <sclv> but not by multiple randoms
12:47:48 <byorgey> sclv: but I think "install it yourself" means "install it somewhere and expose it only to people you trust"
12:47:51 <byorgey> right.
12:48:03 <sclv> ok, then we agree :-)
12:48:25 <Targen> I mean that it would be very nice to write something like concatMap (\x -> [d|data $x = $x|]) $ words "A Bunch Of Names Here"
12:48:30 <sclv> but that explains why its not just sitting in a demo server open to the public, unfortunately :-P
12:48:34 <sclv> erm, :-(
12:49:22 <^thief^> Can anyone point me at a good resource for learning how to *implement* a monad transformer (something like WriterT or StateT in particular)
12:49:53 <sclv> ^thief^: there's no one way to do it, unfortunately.
12:50:15 <cmccann> the best way to implement a monad transformer is to make a newtype around a stack of existing transformers
12:50:32 <sclv> right, was just going there
12:50:36 <chrisdone> i think the wikibook of haskell has implementation of monad transformers
12:50:52 <byorgey> ^thief^: barring cmccann's suggestion, the best way is to study the implementations of existing monad transformers
12:51:07 <cmccann> that said there's a bit of consistency to where the inner monad gets placed
12:51:14 <^thief^> and would it be a crazy idea to have a look at a haskell implementation's source
12:51:21 <sclv> not of transformers, no
12:51:26 <sclv> they're very straightforward code.
12:51:39 <^thief^> hmm, may have a look at the GHC github then I suppose
12:51:45 <cmccann> that's not part of GHC
12:51:46 <sclv> no need to go that deep
12:51:53 <^thief^> ah ok
12:51:56 <croikle> @source ReaderT
12:51:56 <lambdabot> ReaderT not available
12:52:13 <cmccann> ^thief^, http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/src/Control-Monad-Trans-State-Lazy.html#StateT
12:52:22 <sclv> or for all of them: http://hackage.haskell.org/package/transformers-0.3.0.0
12:52:26 <^thief^> perfect thanks
12:52:29 <cmccann> or in general the source links from... yeah, what sclv said
12:52:48 <cmccann> when you look at a module's page note the "source" links on the right-hand side
12:53:04 <sclv> the view source links on haddocks are one of the greatest things about the entire haskell ecosystem
12:53:06 <cmccann> next to the name/type/&c. of whatever is being defined
12:53:09 <^thief^> ah yea easily missed
12:53:16 <cmccann> sclv, and surprisingly easy to overlook
12:53:19 <cmccann> until you know they're there
12:53:59 <sclv> i never just promiscuously read every source file i could get my hands on until haskell
12:54:08 <chrisdone> gwern: i discovered recently that tryhaskell, presumably my mueval-interactive fork, and possibly, though i haven't investigated to confirm, creates lots of files in /tmp/ghc-12345—the typical temporary compilation files of ghc—and of course every time it's killed, i think, those files remain. ended up with tens of thousands of them in temp. i'll look into it somewhen and let you know if it's anything to worry about on your end, and a
12:54:08 <chrisdone> patch would be forthcoming if so, but just thought i'd share that
12:54:09 <cmccann> they really could be more visible than gray text on gray off to the side you're not reading otherwise
12:54:23 <croikle> unfortunately it's not easy to get cabal to make them for your local haddocks
12:54:28 <gwern> chrisdone: I feel like I've heard of that issue before
12:54:45 <chrisdone> gwern: via lambdabot or similar?
12:54:48 <gwern> chrisdone: it may've been why i filed a request for ghc to have an option to clean up its intermediates
12:55:00 <chrisdone> gwern: ah, heh =)
12:55:25 <Rarrikins> @check let f x = if x > 0 then -x else 0 in f (f x) == f (f (-x))
12:55:27 <lambdabot>   Not in scope: `myquickcheck'
12:55:28 <Rarrikins> :(
12:56:39 <byorgey> chrisdone: ah, yeah, I've had tons of those files show up in /tmp/ too
12:56:58 <byorgey> chrisdone: probably due to diagrams-builder's use of hint, though I've never been quite sure
12:58:37 <chrisdone> byorgey: ahhh
12:58:44 <chrisdone> the plot thickens
13:00:04 <byorgey> chrisdone: yeah, in my case nothing is ever getting killed
13:00:05 <luite> oh i think those tmp files aren't needed at all anymore if hint is updated to do qualified imports via the ghc api directly instead of through a dummy module. not sure if that would eliminate all tmp files though
13:00:18 <byorgey> just normal programs completing normally and leaving behind lots of crud in /tmp
13:00:33 <luite> what do the files contain?
13:02:08 <byorgey> I recently cleaned them all up, but right now /tmp contains 25 directories named  ghcNNNNN_0, all empty
13:02:29 <hrumph> hi
13:02:37 <hrumph> what's the best ide for haskell on linux?
13:03:34 <byorgey> luite, chrisdone: I'll try to pay more attention in the future and let you know what happens next time I use diagrams-builder
13:03:45 <Nereid> hrumph: leksah is an ide. but a lot of people use a text editor
13:04:08 <byorgey> EclipseFP is another IDE, convenient if you already are familiar with Eclipse + have it installed
13:04:18 <chrisdone> nod
13:04:22 <byorgey> (but probably not worth installing Eclipse just for that)
13:05:02 <hrumph> i'm using emacs now which is like but i feel that an ide might have certain advantages
13:05:23 <hrumph> big advantages in fact for haskell
13:05:28 <Nereid> there's a bunch of haskell stuff for emacs
13:05:53 <Nereid> http://www.haskell.org/haskellwiki/Emacs
13:05:54 <hrumph> how can i use emacs more like an ide?
13:06:14 <hrumph> ic
13:06:20 <hrumph> your pages discusses that
13:06:55 * gwern marks shapr not successful and moves on
13:07:26 <gwern> 'Haskell-Type-Exts'. very helpful, past me. what the heck is that
13:07:51 <cmccann> like haskell-src-exts
13:07:56 <cmccann> except for type checking instead of parsing
13:08:02 <chrisdone> it's a new library for doing type checking, belongs to an upcoming suite (haskell-suite)
13:08:08 <chrisdone> haskell-naming, haskell-packages, etc.
13:08:10 <gwern> ah, much better: https://www.google-melange.com/gsoc/project/google/gsoc2012/shayannajd/18001
13:10:02 <gwern> no hackage upload, huh
13:10:05 <cmccann> gwern, see also http://cleantypecheck.wordpress.com/
13:10:17 <cmccann> apparently the SoC was considered successful
13:10:32 <cmccann> but it was basically "add some features to a larger, currently incomplete project"
13:10:35 <gwern> cmccann: what soc considers successful is a superset of what I consider successful
13:10:53 <cmccann> so I'm not sure your "number of users" criteria really makes sense
13:11:03 <cmccann> sounds more like a "patches accepted to larger project" situation
13:11:20 <cmccann> like the "is it in HEAD" ones
13:11:58 <gwern> cmccann: well, it's not in HEAd either - http://hackage.haskell.org/package/haskell-type-exts hasn't been touched since april
13:12:47 <cmccann> yeah, I don't know if it was successful by your standards or not
13:13:22 <gwern> I am not keen on research-type projects for socs since they usually never go anywhere despite promises that they will...
13:13:34 <cmccann> chrisdone would probably know more since he's a prospective user for the package in question
13:13:56 <gwern> if your justification goes 'well, if i spend another couple socs on it, maybe someone somewhere will fin it useful before it bitrots because I got a real job', you're not going to impress me
13:14:25 <cmccann> well, if it's a useful contribution to an existing project that other people are continuing to work on that seems like a clear success
13:14:30 <cmccann> but I don't know if that's the case here or not
13:16:03 <cmccann> the lack of information about the whole thing seems more to do with the overall project, not the SoC :T
13:16:06 <neutrino> mm_freak_: still around? :)
13:16:25 <chrisdone> cmccann: development's still active, but yeah they are rather quiet about their work
13:16:55 <sclv> the talk at hiw was quite good
13:16:59 <cmccann> gwern, you'll probably have to pester the SoC mentor for solid answers
13:17:01 <sclv> on "haskell-suite"
13:17:28 <chrisdone> roman cheplyaka wanted to ask me about some dev they're doing on it, as fay is a canonical use-case for it
13:17:57 <cmccann> it kind of annoys me that a project as potentially useful as this doesn't have more information easily available >:[
13:18:06 <chrisdone> nod
13:18:17 <chrisdone> i have similar feelings about the status of hackage 2 sometimes
13:18:43 <chrisdone> we've been told "nearly there" for about three years. at some point i stopped caring
13:19:07 <gwern> hackage2 is an excellent example of failing to translate code into a genuine contribution. which is too bad, because reverse dependencies is important metadata for judging socs
13:20:07 <arbn> Isn't the source code for both of these projects available? You could always go ahead with it.
13:20:30 <chrisdone> what's more odd is that h2 is apparently done but there's friction with migrating it across
13:20:43 <chrisdone> or maintaining it in the future
13:20:53 <gwern> arbn: I'm busy with non-haskell things lately, and as chrisdone says, my understanding is that it's more of a sysadmin issue
13:20:57 <chrisdone> arbn: it's a case of "we don't have the keys to the kingdom"
13:21:02 <gwern> (not that I know html/web stuff in the first place)
13:21:39 <cmccann> last I saw it needed a bit of polish and would probably have needed some fixes and maintenance once it started getting actual use
13:21:58 <chrisdone> that, i am completely happy with
13:22:05 <cmccann> and nobody was both willing and able to take responsibility for making it all happen
13:22:14 <djshadow> Can lambdabot desugar a list comprehension? Google doesn't know
13:22:27 <chrisdone> i don't know what users there are out there that can't deal with an unstable hackage for a bit in exchange for totally sweet updates
13:22:40 <byorgey> djshadow: I don't think so
13:22:48 <byorgey> that might make a nice plugin
13:22:50 <chrisdone> as gwern's said in the past, if you depend on hackage for your job, sort out your priorities
13:23:22 <chrisdone> cmccann: ah, no one willing to DO the actual bugfixes and such. right. for free, anyway
13:23:56 <chrisdone> /r/haskell was very positive about crowdfunding for it
13:24:10 <cmccann> chrisdone, thing is it probably doesn't need so much work to justify the hassle of paying someone to take care of it
13:24:50 <chrisdone> could be
13:24:52 <cmccann> but I'm not sure where things stand currently
13:24:54 <elliott> @undo [x | x <- xs, p x]
13:24:54 <lambdabot> concatMap (\ x -> if p x then [x] else []) xs
13:24:56 <elliott> djshadow: yes
13:25:05 <cmccann> I ran out of free time last time I was messing with hackage stuff and never got back to it :[
13:25:14 <djshadow> elliott: can you elaborate on how?
13:25:35 <chrisdone> looks like haskell-desugar is active, from the tickets made, anyway https://github.com/shayan-najd/Haskell-Desugar/issues
13:25:40 <elliott> djshadow: not really sure what you mean
13:25:57 <ivanm> chrisdone: what of yours got onto the HN front page?
13:26:40 <sclv> http://news.ycombinator.com/item?id=4992603
13:27:51 <djshadow> elliott: well i asked if lambdabot can desugar list comprehensions, which you helpfully answered with "yes", but that's absolutely usless information unless you're good enough to tell **how** to get it to do that - what's the command?
13:28:00 * gwern punts on the haskell-type-exts judgment
13:30:54 <cmccann> djshadow, see a few lines previously
13:31:00 <cmccann> he already demosntrated :P
13:31:17 <djshadow> i hate that about irc - there is no way to tell when someone is using lambdabot to talk to you or not
13:32:02 <chrisdone> ivanm: http://chrisdone.com/z
13:32:09 <ivanm> chrisdone: just finished reading it :)
13:32:14 <chrisdone> :p
13:32:25 <gwern> djshadow: you're supposed to just be smart enough to understand
13:32:29 <ivanm> chrisdone: why does your comment macro return a string rather than just the unit value?
13:32:33 <gwern> maybe we should ban djshadow. clearly he is not worthy of us
13:32:45 <djshadow> gwern: what the fuck?
13:33:06 <gwern> profane language? in the sacred precincts of #haskell?
13:33:25 <ivanm> I agree with djshadow's sentiment, if not his choice of vocabulary
13:33:36 <mm_freak_> neutrino: yeah
13:34:01 <djshadow> what have I done wrong?
13:34:20 <gwern> you have offended the gods by your unworthiness!
13:35:04 <chrisdone> ivanm: because all macros take a string and return a string. all macros are String -> String. the output is then re-parsed into an AST
13:35:12 <ivanm> ahhhh, right
13:35:20 <gwern> but then again, _deorum iniuriae Diis curae_
13:35:36 <djshadow> gwern: you must be really really sad to get off from teasing beginners asking questions on the internet
13:35:36 * gwern is happy that he can at least mark the darcs soc a success as the code was merged into head
13:35:50 <gwern> djshadow: I'm just a little sad. less sad than I was before
13:36:02 <gwern> so your life hasn't been wasted! that should make you happy too
13:36:30 <Heffalump> his main vocation is looking for all possible flaws in gsoc projects ;-)
13:36:47 * elliott thinks djshadow may be taking gwern a few orders of magnitude too seriously.
13:36:51 <djshadow> gwern: people like you are part of the problem
13:37:05 <elliott> wow.
13:37:08 <gwern> Heffalump: indeed, on the first of january of every year, let every soccer look to his repos and fear! for gwern claus is coming to town
13:37:30 <gwern> he knows who's been naughty and nice
13:37:47 <gwern> "bah, humbug! I see no reverse dependencies! 'tis coal and an 'unsuccessful' for you!"
13:38:12 <chrisdone> welcome back…light
13:38:18 <elliott> backlight: hi djshadow :P
13:38:40 <backlight> sorry, i thought if i came back with a different name i could have a conservation wtihout getting abused
13:38:46 <chrisdone> backlight: don't feel offended please, gwern was only being ironic
13:39:06 <chrisdone> pity
13:39:08 <gwern> chrisdone: no no, let him get offended. then maybe he'll grow up and learn how to deal with the internet
13:39:11 <neutrino> mm_freak_: hey, i'm not sure if you got the context of my question that you answered before?
13:39:26 <chrisdone> gwern: HEY DON'T TALK TO ME LIKE THAT
13:39:44 <neutrino> mm_freak_: we were talking with someone here, i think Peaker, and he mentioned how he could create a lot of parallel contexts in C, which were even cheaper than haskell threads (which do cost 1K memory)
13:39:51 * chrisdone giggles at his own jokes
13:39:54 <gwern> *geez* dad, you're not the boss of me! I'll talk however I like!
13:40:09 <neutrino> mm_freak_: he said it's great for having a lot of open connections to very slow clients, for stuff like comet/web socket, etc
13:40:20 <shachaf> gwern: I heard dmwit was the boss of you.
13:40:24 <neutrino> mm_freak_: i was wondering if there's something similarly light-weight in haskell
13:40:35 <gwern> shachaf: I barely even know the man
13:41:01 <Heffalump> gwern: I think you're pushing on the "be nice" policy a bit
13:41:25 <gwern> Heffalump: don't try to censor me man! or I''ll tell the whole world the truth about the failed socs!
13:41:49 <Heffalump> feel free to try to wind me up :-)
13:42:14 <gwern> Heffalump: I know your secret. the truth is, those students never existed! you were just embezzling google funds for prostitutes
13:42:30 <Heffalump> isn't that what they're for?
13:42:32 <Rarrikins> I knew Haskell was shady!
13:43:12 <gwern> family problems and getting a job indeed! as if such humdrum things ever actually happened
13:43:34 <gwern> real soc failures happen for bizarre unique unpredictable reasons, like losing a leg to a llama
13:43:48 <gwern> (that happened in 2006 and is why bytestring was delayed a year)
13:43:57 <mm_freak_> neutrino: i don't think something more lightweight than what you get in haskell is possible…  remember that the RTS takes care of I/O for you, including polling
13:44:10 <mm_freak_> neutrino: a haskell program can easily handle hundreds of thousands of threads
13:44:31 * hackagebot cautious-file 1.0.2 - Ways to write a file cautiously, to reduce the chances of problems such as data loss due to crashes or power failures  http://hackage.haskell.org/package/cautious-file-1.0.2 (RobinGreen)
13:44:44 <neutrino> sure, but what about 100x more than is possible with threads?
13:44:58 <gwern> well. this was a really awful year for SoC. typechecking: ?; darcs: successful; sandbox: successful; scoutess: failed; hashtable: failed; accelerating: failed; packages: failed; tryhaskell: failed
13:45:10 <chrisdone> mmorrow is a REAL gsoc candidate
13:45:23 <chrisdone> he disappeared off the map, like some programmer's indiana jones
13:45:47 <neutrino> chrisdone: what happened to him?
13:45:52 <gwern> chrisdone: you swore never to speak of the matter again. I remind you of the reasons for that oath.
13:46:01 <sdfsd> @pl 3
13:46:01 <chrisdone> neutrino: no one ones. (literally, not joking, he just disappeared)
13:46:01 <lambdabot> 3
13:46:11 <chrisdone> er, s/ones/knows
13:46:27 <neutrino> chrisdone: so he got tired of doing gsoc, why is that so mysterious?
13:46:38 <Heffalump> and is gwern's accuracy at it's usual low level? :-)
13:46:42 <mm_freak_> neutrino: then you're pretty much screwed either way
13:46:43 <neutrino> people leave <whatever social network> forever every day
13:47:04 <mm_freak_> neutrino: if haskell can't handle it, epoll can't handle it
13:47:04 <sdfsd> @pl f s = s ++ "x"
13:47:04 <lambdabot> f = (++ "x")
13:47:05 <neutrino> mm_freak_: well apparently you can do something like that with C's concurrency contexts
13:47:17 <chrisdone> neutrino: nahh i mean he was a really active member of the community, lots of packages and talking in here all the time, and then his web site went down, he disappeared. =(
13:47:33 <neutrino> mm_freak_: it's just about the overhead in terms of that 1K of stuff each thread carries with itself
13:47:54 <neutrino> chrisdone: of what community? haskell?
13:48:01 <chrisdone> then again so did vixey, and others
13:48:02 <sdfsd> @pl f x y = x==y
13:48:02 <lambdabot> f = (==)
13:48:04 <neutrino> chrisdone: one of those happened in ruby too
13:48:06 <chrisdone> neutrino: yeah
13:48:09 <chrisdone> neutrino: like _why, yeah
13:48:32 <neutrino> yeah, it's just people with freaky problems and antisocial attitude
13:48:38 <mm_freak_> neutrino: the main overhead in that case is creation of the threads…  on my machine i can create and destroy one million threads in 800 ms
13:48:57 <chrisdone> or just getting a life, i suppose. it's amazing what a social life does to your hacking and interest in irc
13:49:01 <seliopou> I rememer mmorrow from a _while_ ago
13:49:09 <chrisdone> yeah, maybe 2008?
13:49:10 <seliopou> wasn't he on some sort of computational geometry tear at some point?
13:49:11 <neutrino> mm_freak_: ok sure, but one million threads is 1 GB of ram just for the threads.
13:49:23 <seliopou> he probably just graduated college or something
13:49:31 <chrisdone> hmm, don't remember. he was doing web dev in haskell at the time
13:49:57 <neutrino> chrisdone: possible, but when people actively retract themselves and clam up, that's antisocial (like that _why guy)
13:50:08 <mm_freak_> neutrino: can't confirm that, but i'd have to benchmark again
13:50:16 <jonkri> hi mm_freak_ :-)
13:50:30 <neutrino> mm_freak_: each thread eats up 1K by virtue of it even existing
13:50:31 <mm_freak_> hi there
13:50:34 <seliopou> guys...
13:50:37 <neutrino> mm_freak_: 1K * 1 million = 1 GB
13:50:39 <seliopou> what if mmorrow was _why?
13:50:51 <jonkri> guys: how can i catch an `error', such as "Prelude.tail: empty list"?
13:50:52 <neutrino> blown == mind
13:50:53 <Lethalman> neutrino, you can change the size of the threads iirc with some rts option
13:51:11 <neutrino> Lethalman: really? interesting. how low does it glo?
13:51:13 <neutrino> go
13:51:13 <seliopou> let the internet forensics begin
13:51:19 <Lethalman> neutrino, no idea
13:51:21 <jmcarthur> neutrino: that figure sounds wrong to me. 1 GB for a million threads? they must actually be doing quite a bit
13:51:31 <neptunepink> chrisdone: I do think I see you on the front page of hacker news...
13:51:38 <jmcarthur> neutrino: ghc threads can take <200 bytes each
13:51:46 <neutrino> jmcarthur: well, that's what i've read in several places, 1K per thread
13:51:49 <mm_freak_> neutrino: that would mean i can't confirm the 1 KiB overhead
13:51:52 <jmcarthur> neutrino: but their stacks grow on demand
13:51:54 <neutrino> 200 bytes.. that's much less
13:52:03 <mm_freak_> jonkri: 'catch'
13:52:04 <neutrino> right
13:52:20 <neutrino> plus, the stack-growing is expensive too, isn't it
13:52:29 <mm_freak_> jonkri: but "empty list" is not an error, but a bug
13:52:31 <jmcarthur> neutrino: so perhaps if you keep their stacks small (avoid needless chains of thunks in their workload) you can reduce that memory footprint significantly
13:52:57 <jmcarthur> stack growing can be expensive if you can't avoid doing it
13:52:59 <jonkri> mm_freak_: yeah, thanks :-)
13:53:08 <neutrino> one argument Peaker had was that in his C app he could preallocate enough space for his single context, so that he didn't have to allocate any new space (which costs time to do, and then performance because of the disparate data)
13:53:40 <mm_freak_> neutrino: you can achieve the best I/O performance by using epoll direct
13:53:48 <mm_freak_> directly without a threading abstraction over it
13:54:06 <neutrino> mm, yeah, you can i guess
13:54:12 <neutrino> but then you're in callback hell
13:54:19 <mm_freak_> exactly
13:54:35 <jonkri> mm_freak_: in what module does the catch that you are referring to reside?
13:54:40 <Lethalman> isn't it possible with some tricky haskell abstraction to do callbacks?
13:54:40 <Lethalman> ;)
13:54:45 <mm_freak_> also note that the threaded RTS has some additional overhead for each thread
13:54:54 <mm_freak_> the non-threaded RTS gives you lighter threads
13:55:04 <mm_freak_> jonkri: Control.Exception
13:55:05 <chrisdone> neptunepink: ヽ (＾▽＾) ﾉ
13:55:34 <chreekat> In the course of refactoring, imports often become unused. Is there some tool that finds unused imports in a source file? I hoped hlint might do something like that, but it appears not.
13:55:38 <DrChaos> what does the flip function do exactly? how does it work? is flip (:) the same as (++)?
13:56:00 <shachaf> @src flip
13:56:01 <lambdabot> flip f x y = f y x
13:56:08 <DrChaos> ah
13:56:10 <c_wraith> :t flip (:)
13:56:11 <elliott> flip (:) xs x = (:) x xs = x : xs
13:56:12 <lambdabot> [a] -> a -> [a]
13:56:15 <jonkri> mm_freak_: what if the function that calls `error' is pure?
13:56:15 <shachaf> @google what does the flip function do exactly? haskell
13:56:16 <lambdabot> http://learnyouahaskell.com/higher-order-functions
13:56:17 <lambdabot> Title: Higher Order Functions - Learn You a Haskell for Great Good!
13:56:24 <c_wraith> :t (Prelude.++)
13:56:25 <lambdabot> [a] -> [a] -> [a]
13:56:30 <chrisdone> the friendly way i wrote my article really seems to have struck a nerve. i've had several messages from people saying how they loved my personable tone of writing and that they really like me. weirdest feedback from an article i've ever had
13:56:31 <c_wraith> clearly, they aren't the same
13:57:23 <DrChaos> so flip (1:[]) == ([]:1)?
13:57:26 <mm_freak_> @hoogle a -> IO a
13:57:27 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
13:57:27 <lambdabot> Control.Exception evaluate :: a -> IO a
13:57:27 <lambdabot> Control.OldException evaluate :: a -> IO a
13:57:27 <c_wraith> no
13:57:33 <mm_freak_> jonkri: use 'evaluate'
13:57:47 <jonkri> oh, great :-)
13:57:52 <DrChaos> > flip (1:[])
13:57:54 <lambdabot>   Couldn't match expected type `a0 -> b0 -> c0'
13:57:54 <lambdabot>              with actual type...
13:57:57 <c_wraith> DrChaos: flip doesn't change the meaning of a function at all. It just changes the argument order
13:58:03 <Lethalman> @hoogle IO a -> a
13:58:03 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
13:58:03 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
13:58:04 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:58:06 <DrChaos> c_wraith: ah
13:58:11 <Rarrikins> DrChaos: flip flips arguments, not list elments or anything like that.
13:58:13 <Lethalman> that looks scary
13:58:23 <cmccann> chrisdone, being too likable? that's what you get for not spending enough time on IRC, probably.
13:58:25 <c_wraith> > flip (:) [] 1
13:58:26 <lambdabot>   [1]
13:58:48 <DrChaos> flip (:) [1] 1
13:58:58 <Lethalman> so there is a way to escape of IO with unsafe IO?
13:59:01 <DrChaos> I don't thik that will work
13:59:10 <DrChaos> > flip (:) [1] 1
13:59:11 <lambdabot>   [1,1]
13:59:16 <c_wraith> Lethalman: yes, but there's a reason it's labeled "unsafe"
13:59:24 <DrChaos> oh, nice
13:59:25 <Lethalman> c_wraith, of course :P
13:59:28 <chrisdone> cmccann: *grumble* am i doin it rite?
13:59:42 <Lethalman> c_wraith, why would one use it?
13:59:56 <jnhnum1> hi, I'm looking for the nicest way of using something like <$> and <*> for nested applicative functors.  specifically, in the Snap monad, I want to construct a Maybe object out of Maybe params
13:59:58 <cmccann> chrisdone, it's a start, better keep practicing though
14:00:08 <jnhnum1> can somebody tell me a nice way of doing this?
14:00:18 <c_wraith> Lethalman: the original use was for the FFI, since sometimes you import native functions that are pure in practice.
14:00:21 <cmccann> jnhnum1, nested how?
14:00:37 <jnhnum1> so I have two applicative functors f and g
14:00:42 <jnhnum1> and a function a -> b
14:00:44 <Lethalman> c_wraith, ah, so that you want a value out of the IO... I see somehow
14:00:48 <DrChaos> flip (:) x y = (:) y x
14:01:00 <jnhnum1> or a -> b -> c
14:01:02 <Lethalman> c_wraith, is it still used in modern haskell?
14:01:10 <DrChaos> > flip (:) [1,2] 3
14:01:11 <lambdabot>   [3,1,2]
14:01:12 <jnhnum1> and I want to be able to do something like f <$> x <*> y
14:01:18 <DrChaos> OH
14:01:21 <jnhnum1> where x is of type f (g a)
14:01:30 <jnhnum1> and y is of type f (g b)
14:01:35 <DrChaos> that's the same as (:) 3 [1,2]
14:01:39 <Rarrikins> > flip (/) 2 1
14:01:40 <c_wraith> Lethalman: It's used all the time in native bindings, still.  There are also cases of interesting functions that more or less require it to implement for one reason or another.
14:01:41 <lambdabot>   0.5
14:01:51 <Rarrikins> DrChaos: Yep
14:02:00 <DrChaos> Rarrikins: and yours is the same as 1 / 2
14:02:03 <Jafet> :t liftA2 (liftA2 ?f)
14:02:04 <lambdabot> (?f::a -> b -> c, Applicative f1, Applicative f) => f (f1 a) -> f (f1 b) -> f (f1 c)
14:02:21 <Lethalman> c_wraith, ok thanks
14:02:35 <c_wraith> Lethalman: http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice describes one interesting function that requires unsafePerformIO for its implementation
14:02:49 * cmccann has occasionally defined stuff like (<<*>>) = liftA2 (<*>)
14:03:05 <shachaf> «*»
14:03:12 <cmccann> so that what jnhnum1 wants would be written as f <<$>> x <<*>> y
14:03:13 <elliott> c_wraith: well, it's not really a function
14:03:20 <cmccann> shachaf, looks like a lexical error
14:03:32 <shachaf> True, because it's a quote.
14:03:38 <shachaf> Try ≪*≫
14:03:44 <jmcarthur> that function is also kind of unsafe, for that matter
14:03:56 <shachaf> That naturally extends to ⋘*⋙
14:04:12 <cmccann> shachaf, brilliant, I'm sure everyone will start using that
14:04:21 <c_wraith> yes, unamb is kind of unsafe itself. But it's at least a limited form of unsafe
14:04:28 <jmcarthur> it's quite unlimited
14:04:38 <cmccann> jnhnum1, anyway there's nothing defined in the standard libraries that gives you an immediately nice way to write that
14:04:45 <Lethalman> c_wraith, ok too much advanced for me :S
14:04:46 <c_wraith> well, it never breaks the type system, unlike unsafePerformIO
14:04:53 <jmcarthur> unamb has a proof obligation, which is not unusual, but unlike most pure functions with proof obligations, failing to satisfy the obligation results in nondeterminism
14:04:55 <jnhnum1> okay, but how do you define <<$>>?
14:04:58 <Heffalump> caches tend to require unsafePerformIO
14:04:59 <cmccann> if you have a lot of stuff using nested applicatives you could use a functor composition wrapper
14:05:04 <jnhnum1> :t liftA2 (<$>)
14:05:05 <lambdabot> (Functor f1, Applicative f) => f (a -> b) -> f (f1 a) -> f (f1 b)
14:05:29 <jnhnum1> :t liftA2 (<*>)
14:05:30 <jmcarthur> sure, you can't write unsafeCoerce with it, at least
14:05:30 <lambdabot> (Applicative f1, Applicative f) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
14:05:38 <cmccann> :t fmap . fmap
14:05:39 <c_wraith> jmcarthur: so *slightly* safer :)
14:05:39 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:06:01 <jnhnum1> so the type signature of liftA2 (<*>) is right, but for <<$>> I want (a -> b) -> f ( f1 a) -> f (f1 b), right?
14:06:07 <jnhnum1> oh
14:06:09 <jnhnum1> sorry
14:06:16 <jnhnum1> for some reason my window isn't auto-scrolling properly
14:06:31 <Peaker> mm_freak_, the topic earlier was mainly memory overhead -- in C you can have an extremely minimal context far lighter than a thread. you can do something similar in Haskell, but GC would have quite large walks to do
14:06:36 <jmcarthur> :t fmap.fmap
14:06:37 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:06:40 <shachaf> We need Applicative lenses. :-(
14:06:41 <jmcarthur> :t liftA2.liftA2
14:06:42 <lambdabot> (Applicative f1, Applicative f) => (a -> b -> c) -> f (f1 a) -> f (f1 b) -> f (f1 c)
14:07:19 <cmccann> note that (<*>) itself is "liftA2 ($)"
14:07:31 <cmccann> :t liftA2 . liftA2 . liftA2 $ ($)
14:07:32 <lambdabot> (Applicative f2, Applicative f1, Applicative f) => f (f1 (f2 (b -> c))) -> f (f1 (f2 b)) -> f (f1 (f2 c))
14:07:58 <gwern> damn. my predictions were worse than chance
14:08:22 <cmccann> or "liftA2 id" if you prefer :]
14:08:47 <c_wraith> Lethalman: that's fine. at least you got the point - there are cases where unsafePerformIO makes things possible that aren't otherwise.
14:09:02 <Lethalman> c_wraith, got it
14:09:46 <jnhnum1> :t liftA2 id
14:09:47 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
14:09:53 <Heffalump> Robert Harper's blog is good for advanced examples of that
14:10:10 <c_wraith> But it should be treated as a last resort. It generally isn't necessary for most "normal" tasks.
14:10:37 <c_wraith> I don't know about that.  Harper seems to think you need unsafePerformIO to write functions that can bail out early
14:10:45 <Heffalump> oh, I hadn't seen that
14:11:05 <jnhnum1> ok, how does liftA2 id even type-check?
14:11:19 <c_wraith> :t id `asTypeOf` ($)
14:11:20 <lambdabot> (a -> b) -> a -> b
14:11:25 <jnhnum1> id is type a -> a, but liftA2 takes an a -> b -> c as its first argument?
14:11:33 <jnhnum1> oh
14:11:39 <c_wraith> ($) is the same function as id
14:11:48 <c_wraith> (with a slightly more restricted type)
14:11:57 <shachaf> @ty unsafeCoerce `asTypeOf` ($)
14:11:58 <lambdabot> (a -> b) -> a -> b
14:12:23 <c_wraith> that's more like safeUncoerce
14:13:07 <Targen> @pl \ xs -> liftM2 (++) (mapM dA xs) (mapM dB xs)
14:13:07 <lambdabot> ap (liftM2 (++) . mapM dA) (mapM dB)
14:13:22 <Targen> Ah, I knew there had to be an ap in there somewhere.
14:13:57 <Lethalman> I'm reading a lot of Applicative in here
14:14:04 <Lethalman> why should one use applicative instead of monads?
14:14:40 <shachaf> Why should one use numbers instead of integers?
14:14:44 <cmccann> some applicative instances can't be monads, or would be horrifically inefficient as monads
14:14:59 <cmccann> also people like the cute infix notation
14:15:02 <mel-> when I have an Either data type, how do I check if it's value is a Left or Right?
14:15:16 <Lethalman> but there's no do syntax for them right?
14:15:18 <edwardk> shachaf: applicative lenses?
14:15:21 <elliott> mel-: case myEither of Left x -> ...; Right y -> ...
14:15:38 <mel-> aaah
14:15:46 <mel-> thank you
14:15:55 <cmccann> :t isLeft
14:15:56 <lambdabot> Not in scope: `isLeft'
14:15:59 <cmccann> why doesn't that exist, anyway
14:16:08 <shachaf> cmccann: There was a discussion on libraries@ recently.
14:16:11 <Jafet> isLeft = not . isRight
14:16:14 <Peaker> the lens stuff is one of the nicest examples of applicatives that aren't monads
14:16:17 <shachaf> @ty has _left
14:16:18 <lambdabot> Not in scope: `has'
14:16:19 * gwern finishes summing up 2012. on to paralell abal install
14:16:35 <shachaf> @ty has _left
14:16:36 <lambdabot> Either a c -> Bool
14:16:50 <shachaf> edwardk: I'm not sure if it makes much sense. It's probably related to the zipping thing we talked about once.
14:16:58 <edwardk> > has (element 20) [1..10]
14:17:02 <lambdabot>   mueval-core: Time limit exceeded
14:17:04 <Jafet> isWrong = not . isRight
14:17:04 <edwardk> > has (element 20) [1..10]
14:17:08 <lambdabot>   mueval-core: Time limit exceeded
14:17:14 <shachaf> > has (element 20) [1..10]
14:17:16 <lambdabot>   False
14:17:24 <shachaf> edwardk: *That's* how you do it.
14:17:30 <edwardk> apparently
14:18:14 <cmccann> lambdabot plays favorites it seems
14:18:29 <shachaf> @vixen do you play favorites?
14:18:29 <lambdabot> I'm glad I'm not Brezhnev. Being the Russian leader in the Kremlin. You never know if someone's tape recording what you say.
14:18:40 <jnhnum1> shachaf: where is libraries@?
14:18:47 <shachaf> jnhnum1: A mailing list.
14:19:13 <Jafet> That is possibly the most ironic nixon ever.
14:19:32 * hackagebot liblastfm 0.1.0.0 - Lastfm API interface  http://hackage.haskell.org/package/liblastfm-0.1.0.0 (MatveyAksenov)
14:20:50 <ivanm> chrisdone: are you still around?
14:25:08 <chrisdone> ivanm: yo
14:25:17 <ivanm> nvm, worked out what I wanted myself
14:25:40 <ivanm> btw, whilst hoogle --info can give docs, haskell-docs actually gives the argument documentation which is rather helpful
14:27:27 <Lethalman> :t <$>
14:27:31 <lambdabot> parse error on input `<$>'
14:27:33 <ivanm> :t (<$>)
14:27:34 <chrisdone> hoogle will get that once i'm done making cabal generate hoogle after every package install
14:27:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:27:39 <Lethalman> ty
14:27:46 <Lethalman> ok that's fmap
14:27:47 <chrisdone> still waiting for the go ahead from dcoutts, though. i think he's on holiday or something
14:27:53 <Lethalman> :t (<*>)
14:27:54 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:27:54 <ivanm> chrisdone: no, I think you misunderstand what i mean
14:28:07 <ivanm> chrisdone: hoogle --info finally
14:28:07 <ivanm> vs
14:28:13 <ivanm> haskell-docs Control.Exception finally
14:29:00 <ivanm> the latter tells you what the arguments to the function are (if it's documented)
14:29:36 <chrisdone> ivanm: yeah! i mean once i'm done with cabal, i'll be patching hoogle to do the stuff haskell-docs does, including displaying the args =)
14:29:44 <ivanm> ahhhhh :)
14:30:09 <chrisdone> i noticed it too, it's kinda weird but i imagine it's because hoodle parses the html output so it was "this'll do for now" =p
14:30:43 <ivanm> heh
14:30:48 <ivanm> rather than reading the actual haddock files?
14:30:52 <chrisdone> parsing the html output is probably more reliable (and faster) in the end, as i have to follow re-exports in haskell-docs
14:30:53 <chrisdone> yeah
14:31:20 <lennart_> off
14:31:26 <chrisdone> on!!
14:31:28 * ivanm was trying to hack on darcsden last night but failed as it became too much of a hassle upgrading it to a version of hsp that works with 7.6.1 :s
14:31:40 <chrisdone> D:
14:31:54 <chrisdone> hm, does anyone have an example of using parsec to parse tokens other than string characters?
14:32:05 <chrisdone> i've done it before but for the life o' me can't remember what i used it for :p
14:32:17 <ivanm> well, the hsx / hsx2hs pre-processor seems to emit hard-coded Strings, when hsp now wants Text :s
14:32:22 <chrisdone> just wanted to show a friend "look! parsec can be used to tokenize and parse!"
14:32:25 <ivanm> chrisdone: I think that's how quicksilver says he uses parsec
14:32:36 <chrisdone> quicksilver: got an example of that online?
14:32:55 <c_wraith> you could use parsec one to tokenize and a second time to parse...  Which honestly may not be a bad way to organize things
14:32:58 <c_wraith> *once
14:33:04 <donri> ivanm: should work with OverloadedStrings
14:33:06 <chrisdone> yeah exactly, that's what i've done before
14:33:13 <donri> but i think darcsden uses the old hsx/hsp
14:33:15 <chrisdone> just don't know even remember what for O_O
14:33:18 <ivanm> c_wraith: that's what I think I recall quicksilver saying he did
14:33:25 <ivanm> donri: yeah, trying to upgrade it
14:33:54 <ivanm> but trhsx (and hsx2hs which seems to be its replacement) both emit explicit :: String type sigs to values everywhere
14:33:59 <ivanm> so OverloadedStrings doesn't help :s
14:34:08 <donri> huh
14:34:10 <donri> stepkut: !
14:34:13 <illissius> > not `id` True
14:34:15 <lambdabot>   False
14:34:17 <c_wraith> That does sound like it would simplify the overall structure of what's going on
14:34:26 <illissius> woah.
14:34:30 <ivanm> hsx2hs only came out recently, but it needs deps loosened to build on 7.6.1 (TH dep too strict)
14:34:38 <c_wraith> keep all the messy tokenizing logic out of the core parser
14:34:42 <ivanm> illissius: id acts like ($)
14:34:52 <illissius> ivanm: I saw, I was just testing it out.
14:35:07 <deus_rex> @type ($)
14:35:08 <lambdabot> (a -> b) -> a -> b
14:35:10 <deus_rex> @type id
14:35:11 <lambdabot> a -> a
14:35:27 <chrisdone> i had to define some other combinators of course, because most of parsec's are specific to parsing chars
14:35:29 <deus_rex> oh neat
14:35:33 <ivanm> id f a = (id f) a = f a
14:35:38 <chrisdone> but other than that i used the monad very nicely. what the HELL did i use it on???
14:35:48 * chrisdone browses his github projects
14:35:50 <ivanm> polyparse can do the same
14:36:16 <illissius> did anyone ever manage to figure an intuitive English name for the binary operation of a semigroup/monoid? best I can come up with is "combine"...
14:36:28 <donri> ivanm: i think ironically those :: String annotations were added to make old hsx work with OverloadedStrings, and then the new hsp was ported to text after that ... but you'd think they'd been tested together ...
14:36:35 <ivanm> heh
14:36:45 <elliott> illissius: <>
14:36:52 <illissius> elliott: not english :(
14:37:09 <shachaf> times
14:37:11 <ivanm> donri: doesn't help when all the cabal files say that the homepage is on patch-tag, when they're really now on hub.darcs.net
14:37:21 <Lethalman> :t (->)
14:37:22 <lambdabot> parse error on input `->'
14:37:30 <ivanm> even hsx2hs, when it's never been on patch-tag
14:37:32 <ivanm> :k (->)
14:37:33 <lambdabot> * -> * -> *
14:37:53 <illissius> (problem statement: C++ doesn't have any operator suitable for being mappend for all types, so we need a named function/method (if we want to use it generically). but what to call it?)
14:38:05 <donri> ivanm: i know right :(
14:38:23 <deus_rex> :k (->) Int
14:38:24 <lambdabot> * -> *
14:38:25 <ivanm> Lethalman: -> isn't a function or value; it's a combination of syntax (case and lambda statements) and the data type of functions
14:38:53 <illissius> "times" is also what I found on wikipedia, but about the only monoid where that actually makes any sense is (1, *)...
14:38:56 <Lethalman> ok
14:38:59 <donri> though hsx2hs is just hsx fork, not a completely new package
14:40:24 <chrisdone> i've written some odd stuff http://hpaste.org/11423
14:40:39 <ivanm> donri: oh? why did Niklas fork his own package? :s
14:41:01 <donri> ivanm: well a renaming + major changes
14:41:14 <ivanm> ahhh, right, so an intended successor?
14:41:17 <donri> ivanm: renamed for consistency with precedents like hsc2hs
14:41:24 <ivanm> *nod*
14:43:02 <nus> illissius, 'bop'
14:43:20 <donri> i like how chrisdone made titles mandatory on hpaste, then his own titles are "."
14:43:51 <shachaf> chrisdone: Please make Author not mandatory.
14:44:21 <shachaf> Then I can stop writing "no one" and "mysterious stranger" and what not.
14:44:34 <donri> shachaf: just write "not shachaf" and no one will ever know it's you
14:45:07 <Maxdamantus> :t (Int ->)
14:45:08 <lambdabot> parse error on input `)'
14:45:09 <Maxdamantus> :k (Int ->)
14:45:10 <lambdabot> parse error on input `)'
14:46:20 <ivanm> @remember donri <shachaf> chrisdone: Please make Author not mandatory. [on hpaste] <donri> shachaf: just write "not shachaf" and no one will ever know it's you
14:46:20 <lambdabot> It is stored.
14:46:37 <ivanm> :k ((->) Int)
14:46:38 <lambdabot> * -> *
14:46:42 <ivanm> Maxdamantus: ^^
14:47:04 <chrisdone> shachaf: hm, whatever you enter should be stored in a cookie for next time. do you have cookies or javascript disabled?
14:47:05 <Maxdamantus> Yeah. Was just wondering if the other form would work.
14:47:41 <shachaf> chrisdone: I don't want to be listed as the author of my pastes, and I typically visit hpaste.org with a fresh browser session that has no cookies.
14:47:56 <gwern> you're that ashamed?
14:48:01 <shachaf> Quite.
14:48:13 <ivanm> just happened to come across this; I think it's awesome that a feature I added in for some reason I can't recall (UnknownAttribute) is actually getting used: http://hackage.haskell.org/packages/archive/xdot/0.1/doc/html/src/Graphics-XDot-Parser.html#getOperations
14:48:23 <shachaf> At any rate I don't see the point of requiring an author.
14:48:43 <ivanm> shachaf: one further entry field to fill in and hopefully discourage spammers?
14:48:45 <ivanm> *shrug*
14:49:00 <hpaste> bootcode pasted “doctest fail?” at http://hpaste.org/80072
14:49:42 <bootcode> any guess why does it seem to import the Functor instance twice (apparently it is triggered by the data definition in the $setup block)
14:49:44 <chrisdone> shachaf: sure. i can make it optional, no probs
14:49:47 <donri> i don't think that discourages spammers. there's a hidden anti-spam measure on hpaste that seems to work well anyway
14:50:09 <ivanm> bootcode: I think it doesn't know which Functor instance to use
14:50:21 <bootcode> ivanm: there is only one functor instance.
14:50:29 <bootcode> it prints the same twice
14:50:34 <shachaf> chrisdone: Thanks!
14:50:38 <ivanm> bootcode: doesn't make a difference; it doesn't know that there aren't any more
14:50:44 <ivanm> give it an explicit type
14:51:01 <ivanm> oh, you are, by using the constructor
14:51:30 <ivanm> weird :s
14:51:55 * ivanm misread the doctest code initially
14:53:34 <gwern> http://www.gwern.net/Haskell%20Summer%20of%20Code#results-2 feel free to whine
14:54:22 * chrisdone opens a bottle of asti
14:54:23 <gwern> 'but gwern, my blind grandmother uses ghciLiVE every day to create new crochet patterns for her cats' sweaters! why are you so full of hate'
14:55:02 * gwern was dipped, when he was born, by his mother into the River Haterade downstream of Styx. now he is made of hate except for his ankle
14:55:13 <donri> gwern: re scoutess, the repo has moved, there's a mailing list and a number of people frequenting the irc channel. but yea, it's far from ready to be used for even basic scenarios at the moment.
14:55:49 <gwern> donri: I'm impressed that people are apparently so interested even though it's still useless
14:55:58 <chrisdone> lol
14:56:06 <donri> \o/
14:56:22 <gwern> (usually, programs only get popular after they work)
14:57:34 <mauke> chrisdone: I was very disappointed when I finally got my sister to try tryhaskell.org and everything was broken!
14:58:20 <Lethalman> maybe.... I... sort of understood applicative.. maybe
14:58:28 <chrisdone> i'm sorry, dad. i'll try harder next time
14:58:48 <mauke> apparently you must allow code from google-analytics.com to run or the expression evaluator will work, but using "help" or any of the "lesson" commands will freeze everything
14:59:02 <mauke> super frustrating
14:59:52 <parcs> how does one declare an optional strParser with optparse-applicative?
14:59:55 <Lethalman> the problem of fmap is that if the function has more than one arguments, you'll get an f function and it's not possible to use it again with fmap?
15:00:08 <Lethalman> while with <*> it's possible?
15:00:11 <chrisdone> mauke: maybe i could make ga optional, i guess
15:00:23 <shachaf> Lethalman: fmap gives you lift1 :: (a -> b) -> f a -> f b
15:00:38 <Lethalman> yes
15:00:38 <shachaf> Applicative gives you that, and also lift0 :: a -> f a and lift2 :: (a -> b -> c) -> f a -> f b -> f c
15:01:07 <Lethalman> mh I thought it gave f (a -> b) -> f a -> f b
15:01:16 <cmccann> :t liftA2 ($)
15:01:18 <lambdabot> Applicative f => f (b -> c) -> f b -> f c
15:01:20 <shachaf> There are a bunch of formulations.
15:01:25 <mauke> chrisdone: yeah, I'm not really looking forward to figuring out how to add blocklist exceptions every time I want to show off the site
15:01:40 <mauke> so if you could fix it on your end, that would be great <3
15:02:25 <Lethalman> :t liftA1
15:02:27 <lambdabot>     Not in scope: `liftA1'
15:02:27 <lambdabot>     Perhaps you meant one of these:
15:02:27 <lambdabot>       `liftA' (imported from Control.Applicative),
15:02:29 <Lethalman> :t liftA2
15:02:31 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
15:02:38 <chrisdone> mauke: so i added a check to just not try if ga is disabled. can you check?
15:03:17 <donri> parcs: optional (strOption ...)
15:03:26 <chrisdone> (not sure how to actually disable specific scripts in chrome to test)
15:03:34 <nus> @ty fmap . fmap
15:03:35 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:03:44 <hpaste> “Anonymous Coward” pasted “Test paste for shachaf, I mean, that guy” at http://hpaste.org/80073
15:04:18 <hpaste> “Anonymous Coward” annotated “Test paste for shachaf, I mean, that guy” with “Test paste for shachaf, I mean, that guy (annotation)” at http://hpaste.org/80073#a80074
15:04:18 <nus> for 'not shachaf', you mean [-:
15:04:34 <mauke> chrisdone: everything seems to work
15:04:39 <mauke> chrisdone++
15:04:49 <chrisdone> cool =)
15:04:56 <parcs> donri: wouldn't that return Nothing if an invalid value was inputted
15:05:22 <donri> parcs: yes. what is the behavior you want?
15:05:34 <parcs> donri: i want it to default to a value if no value was inputted, and fail if a value failed to parse correctly
15:06:29 <donri> parcs: hm, i think that's something like, nullOption (reader validatorFunction <> value defaultValue)
15:07:06 <gwern> (dum de dum dum http://www.reddit.com/r/haskell/comments/15sjur/summer_of_code_2012_retrospective/ )
15:08:22 <chrisdone> i may have successfully got the term “z-expressions” coined into contemporary programmer lexicon
15:08:35 <chrisdone> just wait a while, everyone'll be using it! you'll see!
15:08:59 <chrisdone> gwern: i see your thumb twiddling, and i raise it, beard stroking
15:09:19 <gwern> chrisdone: yeah well i have a beard all around my face, so I can stroke with two hands!
15:09:36 <edwardk> gwern: your statement about ghclive is somewhat misleading. ghclive is not intended to be something you sit on a server and run. its a collaborative editing session. you start up the server locally, and tell someone the port number and they hack with you
15:09:52 <edwardk> its not sandboxed like tryhaskell, its not designed to set on a server and serve up sessions
15:09:54 <gwern> edwardk: as I wrote, it was advertised as being a public thing
15:10:20 <gwern> edwardk: shapr described it as for the www; he modeled it after a public www service; and he was looking into sandboxing ala mueval at the beginning
15:10:38 <gwern> edwardk: by abandoning sandboxing and limiting it to insecure use, he's drastically restricted the scope and utility of it
15:10:45 <edwardk> multiuser browser-based interactive ghci, hpaste.org meets tryhaskell.org, for improved teaching of those new to Haskell. (proposal)   -- it provides a multiuser browser-based interactive ghci. you start up a session and can show someone around
15:11:26 <edwardk> *shrug*
15:11:42 <edwardk> its a different tool for a different job than what you want it to be.
15:11:57 <parcs> donri: thanks
15:12:08 <donri> got it working?
15:12:34 <gwern> shapr was hired to produce something much more useful than he did
15:13:13 <Lethalman> :t (+) . (+3)
15:13:15 <lambdabot> Num a => a -> a -> a
15:13:30 <Lethalman> :t (+) <*> (+3)
15:13:32 <lambdabot> Num b => b -> b
15:13:47 <Lethalman> :t (+) <$> (+3)
15:13:48 <lambdabot> Num a => a -> a -> a
15:15:10 <edwardk> as someone intimately more involved in the process, i respectfully disagree. am i perfectly happy with the resulting scope of work? not entirely, could shae be doing more to carry it forward? perhaps, but the scope you want to project onto the project and the scope his mentor had him working under for the first half of the project largely differ.
15:15:58 <donri> i think the lack of sandboxing could make ghcilive *more* useful because you can showcase all of haskell
15:16:25 <donri> but a sandboxed public service could certainly be useful, too
15:16:41 <edwardk> had you deigned to contribute to the evaluation process and the discussions that happened around it you would be better informed, but as it is you are simply ripping into him for failing to meet your preconceptions.
15:16:54 <edwardk> donri: it would be, and its a perfectly reasonable tool to want
15:17:01 <edwardk> its just not the tool he labored to build
15:17:46 <gwern> donri: showcase what?
15:18:00 <edwardk> and to come along 6 months after the fact that say that that what he built isn't 'what we hired him to build' strikes me as disingenuous.
15:18:09 <donri> isn't the point of ghcilive teaching haskell by live examples?
15:18:10 <gwern> donri: you can permit IO and other things in a sandbox
15:18:42 <edwardk> for 2 months out of the damn project apfelmus had him practically researching how to do livecoding on the web in this stupid thing.
15:19:57 <gwern> what do you mean, researching how to do livecoding?
15:20:38 <Lethalman> :t (+) <$> (+3) <$> (*100)
15:20:39 <lambdabot> Num a => a -> a -> a
15:20:51 <Lethalman> :t (+) <$> (+3) <*> (*100)
15:20:52 <lambdabot> Num b => b -> b
15:20:53 <Lethalman> :S
15:21:07 <edwardk> I mean just that. heinrich and shapr had very very different ideas of the scope of the project and the difference between nice to haves and must haves. and in apfelmus's mind, the ability to live code with music streaming somehow from a haskell server fell on the must have side of that line.
15:21:21 <gwern> what
15:21:28 <edwardk> there is a reason why we switched mentors at the midterm
15:21:41 <gwern> didn't know that
15:21:54 <gwern> music streaming. what the heck.
15:21:57 <edwardk> so under the circumstances, i'm pretty happy with the result
15:22:36 <edwardk> there is a fair bit of mud to sling both directions, so i'm not being entirely fair to heinrich with that statement
15:22:42 <Lethalman> :t (+3) + (*100)
15:22:43 <gwern> edwardk: if you want to write something on the record about that apfelmus stuff, i'd be happy to quote it as extanuating circumstances or at least more context
15:22:43 <lambdabot> (Num a, Num (a -> a)) => a -> a
15:22:54 <Lethalman> ah
15:23:20 <edwardk> i'd rather just say that the mentor and student had rather strong differences in the scope of the project and we switched mentors mid-stream to salvage the project
15:23:35 <apriori_> hey guys.. any accelerate-cuda devs or advanced users here?
15:23:42 <edwardk> luite took over at the mid-term with me doing the final pass-fail evaluation
15:23:55 <Lethalman> :t (+) (+3) (*100)
15:23:56 <lambdabot> (Num a, Num (a -> a)) => a -> a
15:24:01 <gwern> edwardk: or I could just quote everything you said here, since there are public logs and hence that would not be against freenode policy or anything
15:24:08 <edwardk> feel free
15:24:25 <Lethalman> :t ((+) (+3)) (*100)
15:24:27 <lambdabot> (Num a, Num (a -> a)) => a -> a
15:24:40 <Lethalman> is this the same as (+) <$> (+3) <*> (*100) ?
15:24:48 <edwardk> i'll just use your decision to decide how frank to be with you in the future
15:24:59 <gwern> curses! you're cleverer than you look
15:40:06 <chrisdone> gwern: and he looks like aphex twin but won't admit it in case we find out
15:40:24 <gwern> who is this insect you speak of
15:41:38 <edwardk> chrisdone: more like his fat older brother ;)
15:42:41 <tgeeky> aphex quad?
15:42:58 <chrisdone> aphex twin: https://lh4.googleusercontent.com/-1oGpOrgHQ04/TqxDH_gjLUI/AAAAAAAAAGI/DQlg7ziQb78/s425/206527_10150212865315339_553770338_9111556_241939_n.jpeg
15:42:58 <chrisdone> edwardk: http://2.bp.blogspot.com/-Lyh6ANF9h5g/T_iuw65TokI/AAAAAAAAAE8/Zh4SthzzMyo/s1600/Picture+1.png
15:43:13 <edwardk> chrisdone: =)
15:43:30 <chrisdone> edwardk: yeah =p
15:43:58 <ion> http://www.bastwood.com/projects/aphex_face/aphex.png
15:44:32 <tgeeky> this is a trap, those are both barbra bush
15:46:17 <pqmodn> @pl (\(a,b,c) -> undefined) -- what gives?
15:46:18 <lambdabot> (line 1, column 8):
15:46:18 <lambdabot> unexpected "c"
15:46:18 <lambdabot> ambiguous use of a non associative operator
15:46:47 <mauke> 2-tuples only
15:47:27 <pqmodn> ah, okay
15:47:33 <deus_rex> @source zip
15:47:33 <lambdabot> zip not available
15:48:20 <deus_rex> any reason zip isn't implemented in terms of zipWith?
15:48:37 <mauke> @src zip
15:48:37 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
15:48:37 <lambdabot> zip _      _      = []
15:48:43 <startling> deus_rex: it's probably the reverse
15:48:48 <startling> @src zipWith
15:48:48 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
15:48:48 <lambdabot> zipWith _ _      _      = []
15:48:53 <startling> oh, nope
15:48:56 <Luke> "Could not find module `Text.Templating.Heist' It is a member of the hidden package `heist-0.8.2'." <-- I keep getting this error when trying to compile in emacs eshell even though heist 0.8.2 is installed and everything works from cabal on the normal term. any ideas?
15:50:58 <zomg> Luke: what command are you using to compile?
15:51:15 <Luke> zomg: :load in ghci
15:51:35 <Luke> zomg: really it may be that I'm trying to compile from ghci and have nothing to do with emacs. just trying ot give all the info
15:51:43 <zomg> Ah, yeah the package heist probably isn't exposed.. try :set -package heist
15:51:58 <Luke> checking
15:52:31 <Luke> zomg: the :set command executed successfully but didn't fix the problem
15:52:50 <Luke> also I've been doing this successfully for quite some time and now it just stopped working. Not sure what I changed
15:53:42 <croikle> did you install a newer version? that might hide the old one
15:55:10 <Luke> croikle: yeah it looks like a newer version is installed
15:55:21 <Luke> croikle: how does ghci know which version to use?
15:55:45 <croikle> dunno. you can hide the later version, I've had to do that once
15:55:47 <Luke> ah I did ":set -package hiest-0.8.2" and it fixed it
15:55:52 <Luke> so that was the problem
15:55:58 <Luke> ok cool - thanks guys
15:56:11 <croikle> swee
15:56:23 <Luke> what's the safe way to deregister the later version and just preserve the version I'm using?
15:56:30 <pqmodn> Lethalman: no, (+) <$> (+3) <*> (*100) has the type Num a => a -> a. notice the type constraints on your other examples mean functions must be numbers, eg (Num (a -> a))
15:56:40 <Luke> i'm pretty sure I installed the later version by mistake
15:56:40 <Nereid> Luke: probably hide instead of unregister. ghc-pkg hide
15:56:48 <Nereid> well you can unregister it if you want.
15:57:00 <Luke> will unregister remove the files as well?
15:57:03 <Nereid> no
15:57:08 <Luke> i have to do that by hand?
15:57:15 <Nereid> yes
15:57:22 <Nereid> well,
15:57:24 <Nereid> you don't have to
15:57:34 <Nereid> there's no harm in leaving the files there
15:57:35 <Luke> if I want them removed, I have to do it manually that is =)
15:57:37 <monochrom> use "ghc-pkg describe" to find out where the files are
15:57:38 <Luke> right
15:57:38 <Nereid> yes,
15:57:40 <Luke> ok thanks a lot
15:57:49 <Luke> cool cool thanks a lot guys
15:58:04 <Lethalman> pqmodn, ah, what does Num (a -> a) mean?
15:58:28 <Nereid> it means (a -> a) is an instance of the Num typeclass.
15:58:38 <Nereid> which usually signals that something's wrong.
15:59:11 <pqmodn> Lethalman: usual instances of Num are Int, Integer, etc. it means you can add, multiply, etc and treat these types as numbers.
15:59:18 <zomg> Can (a -> a) actually be a num? :P
15:59:25 <startling> yes.
15:59:26 <otters> Num a => Num (a -> a) can
15:59:33 <otters> actually, anything can be an instance of Num
15:59:36 <Luke> what's the cabal unregister command?
15:59:43 <Nereid> not cabal. ghc-pkg unregister
15:59:43 <otters> ghc-pkg unregister
15:59:44 <startling> ghc-pkg unregister
15:59:45 <monochrom> ghc-pkg unregister
15:59:46 <startling> jinx
15:59:47 <Nereid> haha
15:59:48 <Luke> hahaha
15:59:51 <Luke> thanks
15:59:51 <Nereid> brb
15:59:52 <otters> you owe me a soda
16:01:02 <Lethalman> pqmodn, yes, but is there a meaning for Num (a -> a) ? what's that?
16:01:26 <pqmodn> Lethalman: there is no built-in instance so you'd have to make up your own meaning
16:01:52 <Lethalman> that's much of a headache :S
16:02:01 <zomg> o_O
16:02:06 <zomg> How did you even get Num (a -> a)
16:02:07 <pqmodn> Lethalman: it's unlikely you meant Num (a -> a)
16:02:23 <pqmodn> @type (+) (* 3) (+ 100)
16:02:24 <lambdabot> (Num a, Num (a -> a)) => a -> a
16:02:46 <pqmodn> @type (* 3)
16:02:47 <lambdabot> Num a => a -> a
16:02:55 <Lethalman> pqmodn, I was trying to get from (+) <$> (+3) <*> (*100) to something without applicatives to understand what's going on
16:03:49 <pqmodn> Lethalman: (+) takes a number and gives you a number back. so if you try adding two things they must be instances of Num. that's why the type of your expression says (a -> a) must be a Num, because (* 3) is Num a => a -> a
16:04:02 <beaky> does haskell have multiple dispatch?
16:04:41 <parcs> this 120 LOC hpaste client compiles to an 18MB executable :(
16:04:42 <dmwit> What is multiple dispatch?
16:04:44 <pqmodn> so it's telling you (* 3) must be a Num, and (+ 100) must be a Num. both have the type a -> a (where a is an instance of Num). that's why you end up with Num (a -> a).
16:05:03 <beaky> multiple dispatch is when you choose a function depending on the types of multiple stuff
16:05:18 <Clint> parcs: stripped?
16:05:49 <pqmodn> beaky: you can have multiparameter type classes, but i don't think it's quite the same as what you mean
16:05:52 <hpaste> parcs pasted “Self-hosting test” at http://hpaste.org/80076
16:06:12 <beaky> ah
16:06:13 <parcs> Clint: 12MB stripped
16:06:15 <parcs> it works!
16:06:17 <beaky> what is multiple dispatch?
16:06:40 <jmcarthur> beaky: do you mean overloaded functions?
16:06:47 <mauke> beaky: ?
16:07:08 <jmcarthur> beaky: like how in C++ you can define multiple constructors that just take different types and numbers of parameters?
16:07:10 <Lethalman> pqmodn, right, so how would I rewrite the applicative form in a form without applicatives?
16:07:31 <jmcarthur> beaky: if that's what you mean, we don't quite have that
16:07:40 <pqmodn> Lethalman: your applicative expression is equivalent to (\x -> (x * 3) + (x * 100))
16:07:52 <nus> beaky, pattern matching is your multiple dispatch
16:07:59 <pqmodn> Lethalman: or you can write liftA2 (+) (* 3) (+ 100)
16:08:12 <mauke> > ((+) <$> (+3) <*> (*100)) x
16:08:13 <lambdabot>   x + 3 + x * 100
16:08:14 <Lethalman> pqmodn, ok, I still don't get how for functions but it's clear for other types
16:08:44 <pqmodn> Lethalman: it might help to look at the source for the Applicative (e ->) instance
16:08:55 <beaky> yes
16:08:56 <beaky> ah
16:10:23 <pqmodn> Lethalman: in fact it's probably helpful to start with Functor (e ->), then to Applicative, then to Monad. try defining them yourself
16:10:43 <Lethalman> ha! that's scary
16:11:02 <croikle> functor is not bad. the others are a little mind-bending at first
16:11:13 <mauke> just remember that A -> B is really (->) A B
16:11:23 <mauke> (and (A ->) is (->) A)
16:11:37 <pqmodn> yeah, i found that to be the trickiest part
16:11:46 <croikle> or inversely, the functor is A -> , not -> A
16:12:39 <Lethalman> mauke, that's clear to me
16:14:33 <Lethalman> :t (+) . (+3) . (*100)
16:14:34 * hackagebot sym 0.5 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.5 (AndersClaesson)
16:14:34 <lambdabot> Num a => a -> a -> a
16:14:36 * hackagebot bindings-cctools 3.6.1.0.1.0.0.1 - Bindings to the CCTools WorkQueue C library  http://hackage.haskell.org/package/bindings-cctools-3.6.1.0.1.0.0.1 (BadiAbdulWahid)
16:14:48 <Lethalman> :t (+) <$> (+3) <*> (*100)
16:14:49 <lambdabot> Num b => b -> b
16:14:53 <Lethalman> I thought it was the same, but it isn't
16:15:02 <mauke> . is <$>
16:15:06 <Lethalman> right
16:15:09 <mauke> <*> is not
16:15:26 <Lethalman> :t (+) <*> (+)
16:15:28 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = b0 -> b0
16:15:28 <lambdabot>     Expected type: b0 -> b0
16:15:28 <lambdabot>       Actual type: b0 -> b0 -> b0
16:15:32 <Lethalman> :t (+) <*> (+3)
16:15:33 <lambdabot> Num b => b -> b
16:15:54 <Lethalman> not very clear yet to me
16:16:12 <Lethalman> :t Just 2 <*> Just 3
16:16:13 <lambdabot> (Num a, Num (a -> b)) => Maybe b
16:16:19 <ion> lethalman: This may or may not be helpful: http://heh.fi/haskell/functors/#function-instance
16:16:29 <ion> > Just (+10) <*> Just 3
16:16:30 <lambdabot>   Just 13
16:17:09 <mauke> > (f <*> g) x
16:17:11 <lambdabot>   Ambiguous type variable `a0' in the constraints:
16:17:11 <lambdabot>    (GHC.Show.Show a0)
16:17:11 <lambdabot>     ...
16:17:21 <croikle> > (+10) <$> Just 3
16:17:22 <lambdabot>   Just 13
16:17:26 <Lethalman> ion, that was actually much useful thanks
16:17:36 <mauke> > ((f :: Expr -> Expr -> Expr) <*> g) x
16:17:37 <Lethalman> ion, it's just that with other types not being functions it's easier
16:17:38 <lambdabot>   f x (g x)
16:17:58 <pqmodn> in an expression p <$> f, p is a "pure function" applied to an "effectful argument". in your case, the effect is "takes an argument". now f <*> g, f is an "effectful function" applied to an "effectful argument". (+) takes an argument e to yield (\a -> e + a), and (+ 3) takes an argument too
16:18:00 <mauke> :t (<*>)
16:18:01 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:18:19 <mauke> :t (<*>) :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
16:18:20 <lambdabot> (e -> a -> b) -> (e -> a) -> e -> b
16:18:25 <mauke> @djinn (e -> (a -> b)) -> (e -> a) -> (e -> b)
16:18:25 <lambdabot> f a b c = a c (b c)
16:18:37 <ion> @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
16:18:38 <lambdabot> (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
16:18:42 <ion> @@ @djinn @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
16:18:43 <lambdabot>  f a b c = a c (b c)
16:18:52 <pqmodn> (aka, the S combinator)
16:19:35 * hackagebot cctools-workqueue 3.6.1.0.1.0.0.1 - High-level interface to CCTools' WorkQueue library  http://hackage.haskell.org/package/cctools-workqueue-3.6.1.0.1.0.0.1 (BadiAbdulWahid)
16:20:36 <pqmodn> @djinn (Maybe (a -> b) -> Maybe a -> Maybe b
16:20:40 <lambdabot> Cannot parse command
16:20:43 <pqmodn> @djinn Maybe (a -> b) -> Maybe a -> Maybe b
16:20:46 <lambdabot> f a b =
16:20:48 <lambdabot>     case a of
16:20:50 <lambdabot>     Nothing -> Nothing
16:20:52 <lambdabot>     Just c -> case b of
16:20:56 <lambdabot>               Nothing -> Nothing
16:20:58 <lambdabot> Plugin `djinn' failed with: thread killed
16:21:02 <ion> :-D
16:21:04 <mauke> haha
16:21:17 <pqmodn> ... maybe not!
16:21:30 <mauke> @djinn Maybe (a -> b) -> Maybe a -> Maybe b
16:21:30 <lambdabot> f a b =
16:21:30 <lambdabot>     case a of
16:21:30 <lambdabot>     Nothing -> Nothing
16:21:30 <lambdabot>     Just c -> case b of
16:21:30 <lambdabot>               Nothing -> Nothing
16:21:32 <lambdabot>               Just d -> Just (c d)
16:21:45 <deus_rex> how many ill-advised Call Me Maybe jokes were written in haskell this summer?
16:22:00 <Hafydd> Hahah.
16:22:04 <pqmodn> probably more "getting a stab" jokes :)
16:22:12 <ivanm> seeing as how summer is only 1/3 of the way through...
16:22:32 <deus_rex> this past Northern Hemisphere's summer*
16:22:44 <ion> @remember lambdabot f a b = case a of { Nothing -> Nothing; Just c -> case b of { Nothing -> Nothing; Plugin `djinn' failed with: thread killed
16:22:44 <lambdabot> I will remember.
16:23:03 <JoeyA> ... and will never hear the end of it
16:24:28 <hpaste> “Joey Adams” pasted “ByteQueue” at http://hpaste.org/80077
16:24:30 <JoeyA> ^ I made this module to test some IO stuff.  It's an STM-based byte queue that supports a limit on unread bytes.  Should I bother putting it on Hackage (i.e. would anyone else have a use for this) ?
16:26:16 <JoeyA> Although for real-world applications, it could use some optimization (e.g. chunk small writes before adding them to the channel)
16:30:20 <Lethalman> :t ($)
16:30:22 <lambdabot> (a -> b) -> a -> b
16:33:59 <Lethalman> night, thanks for all... haskell is very interesting but soooo hard :S
16:34:13 <mauke> haskell is the hardest metal known the man
16:34:15 <pqmodn> Lethalman: it takes time, which makes it fun. you'll get it :)
16:36:18 <kurtis> Hey guys, I have a question for you since you tend to think out of the box. This is sort of an abstract question; not really directly related to Haskell (yet). I've run into a predicament with building certain Web Services / SaaS Applications. Typical MVC-ish architectures are oriented around taking data and presenting it. That works *great* for a lot of Web Applications and sites. However, they put an emphasis on the data and the displ
16:36:18 <kurtis> ay of the data. I've run into an issue with Web Services where the functions are a "higher order" (if you will) and end up spending 90% of my time coding for edge cases (error handling) along with validating user input. Do you all have any suggestions on alternative architectures that might suite me well? Even something alternative or not typically applied to the web
16:36:33 <Lethalman> :t mempty
16:36:35 <lambdabot> Monoid a => a
16:38:14 <kurtis> I haven't had any luck as everyone in the Web Field seems to put an emphasis on data-first; Procedural languages are making it difficult for me as I code *way* too many lines to simply grab, validate, and process the Query and handle errors there-after. OOP makes it a little bit easier but then any custom or wierd requirements throws that gain right out the door. Hopefully this makes sense...
16:38:41 <cmccann> kurtis, have you looked at any of the Haskell web frameworks out there?
16:38:54 <cmccann> I suppose they're relatively conventional in their approach but I'm not sure.
16:39:01 <Lethalman> what's mempty useful for?
16:39:08 <JoeyA> kurtis: Sounds kinda like the "boundary issue", as described in the Yesod introduction: as much as your application is type safe on the inside, every boundary with the outside world still needs to be sanitized.
16:39:14 <JoeyA> http://www.yesodweb.com/book/introduction
16:39:28 <byorgey> Lethalman: it's the identity element for mappend
16:39:38 <JoeyA> Not recommending Yesod per se, I just really like the term "boundary issue"
16:39:40 <pqmodn> Lethalman: you can think of it as a "default value", if that helps
16:39:40 <byorgey> Lethalman: mempty `mappend` x == x == x `mappend` mempty
16:40:00 <Lethalman> but what's its use?
16:40:20 <kurtis> JoeyA, exactly. Unfortunately that's my issue no matter the language. The *closest* solution I've found is how Django generalizes Validation Logic and lets you build Classes and it will run the processing for you. However, that's a very specific application (HTML Forms). I like the term boundary issue as well :)
16:40:21 <startling> Lethalman: starting values, I guess
16:40:24 <croikle> foldr mappend mempty
16:40:29 <startling> ^ yeah
16:40:30 <shachaf> What's the use of an empty list?
16:40:32 <pqmodn> Lethalman: maybe you have some computation where you're adding numbers. if you have nothing to add together, mempty (0) is the result
16:40:38 <Lethalman> ok
16:40:58 <kurtis> cmccann, I have looked at the framework but it's been a while. I'm not sure if it has anything for me to gain but I will check it out again.
16:41:00 <byorgey> Lethalman: check out http://apfelmus.nfshost.com/articles/monoid-fingertree.html for an accessible presentation of one cool use of monoids
16:41:12 <byorgey> (there are lots)
16:41:13 <Lethalman> thanks
16:41:17 <JoeyA> kurtis: Are you already working on a program in Haskell?
16:41:28 <JoeyA> Or are you just anticipating issues that might arise for something you plan to work on?
16:41:57 <JoeyA> Or thinking "there has got to be a better way" after a bad experience on a previous project?
16:42:33 <cmccann> every time I do any web dev I start thinking "there has got to be a better way".
16:42:36 <zomg> kurtis: at least with forms I find Yesod's form package works quite nicely, you really need very little boilerplate working with it.
16:42:40 <kurtis> JoeyA, No. It's written in Python at the moment. This is my 3rd Web Service I've built and I have a large one on the way. I'm thinking about starting this one over and am seriously considering Haskell. I figure, just like you say, there's got to be a better way and I have hunch that Functional Languages (First-Order Functions and Haskell with its type safety) *might* be the answer
16:43:20 <kurtis> cmccann, haha I don't blame you!
16:43:25 <cmccann> kurtis, I'm not sure how much functional style really gains you on this issue
16:43:39 <cmccann> but type checking certainly can help if you use it right
16:44:20 <cmccann> I'm really thinking you should give yesod a try; dunno if you'll like it but it certainly emphasizes the value of static checking
16:44:23 <zomg> Yesod forms lets you pretty much just define your form in terms of its fields and the data produced from those, so it's really straightforward
16:44:35 * hackagebot hpasteit 0.1.0.0 - A command-line client for hpaste.org  http://hackage.haskell.org/package/hpasteit-0.1.0.0 (PatrickPalka)
16:44:37 <JoeyA> kurtis: The philosophy behind "boundary issue" should apply to any language, in my opinion.  The idea is, keep all the weird edge cases *outside*.
16:44:48 <zomg> and it does do a pretty good job of figuring out the typing for the data coming from the browser
16:46:13 <JoeyA> To do that, focus on mathematical consistency, not on "common sense" as common folk see it.
16:46:32 <JoeyA> kurtis: Suppose you have a function that returns all permutations of a list.
16:46:36 <JoeyA> > permutations [1,2,3]
16:46:37 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
16:46:53 <JoeyA> What do you think permutations [] should return?  (Don't run it)
16:46:56 <kurtis> cmccann, True. I'm not sure, either, to be honest. It probably sounds irrational but I'm hoping that jumping from a Data First (OOP) to a Function First (Functional Language) paradigm might have some magical sense for my particular problems. But I agree with JoeyA, the boundary issue really does apply to any language and maybe there's no clean way to do it without a lot of boilerplate
16:47:13 <kurtis> Undefined?
16:47:27 <kurtis> Or simply, []
16:47:33 <JoeyA> Well, think about some properties of permutations.
16:47:38 <JoeyA> > length $ permutations [1..3]
16:47:40 <lambdabot>   6
16:47:41 <JoeyA> > length $ permutations [1..4]
16:47:43 <lambdabot>   24
16:47:44 <JoeyA> > length $ permutations [1..5]
16:47:45 <lambdabot>   120
16:47:48 <JoeyA> See the pattern?
16:48:18 <Hafydd> Or alternatively think about that "permutations" actually means.
16:48:48 <kurtis> I see *a* pattern :)
16:48:53 <JoeyA> What is it?
16:49:11 <kurtis> I'm not quite sure what it is. Obviously something related to the number of permutations, haha
16:49:14 <JoeyA> What is length $ permutations [1..n] for n > 1 ?
16:49:34 <ivanm> JoeyA: it'd be n!, right?
16:49:38 <parcs> @where paste
16:49:38 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
16:49:41 <JoeyA> Right.
16:49:54 <kurtis> oh, okay. Thanks ivan
16:50:07 <JoeyA> kurtis: and what is 0! (0 factorial) ?
16:50:13 <ivanm> oh, whoops, didn't realise you were helping kurtis; I thought you were asking :s
16:50:31 <kurtis> 1?
16:50:35 <JoeyA> Right
16:50:42 <byorgey> > product [1..3]
16:50:43 <lambdabot>   6
16:50:48 <byorgey> > product []
16:50:49 <lambdabot>   1
16:51:19 <kurtis> So then the permutations for [] is simply [[]]?
16:51:21 <JoeyA> Right.  If you instead decided that product [] is 0, the implementation would have weird edge cases, and usage would trigger weird bugs.
16:51:21 <epta> I'm looking at http://hackage.haskell.org/package/hpasteit-0.1.0.0 and don't get why is it necessary to use these trailing zeroes. Isn't 0.1 equal to 0.1.0.0? So what is a point?
16:51:45 <ivanm> epta: personal preference
16:51:51 <ivanm> but it makes it more explicitly follow the PVP
16:51:52 <byorgey> kurtis: right! there is on permutation of the empty list, namely, the empty list.
16:52:03 <parcs> epta: it's what cabal fills in the version field by default
16:52:04 <byorgey> *one
16:52:06 <JoeyA> kurtis: Well, it doesn't have to be.  Suppose you're writing a function that does the same thing, and you don't know the term "permutations"
16:52:06 <ivanm> and this way, when you want to make it 0.1.0.1 you just have to edit one character, rather than add 4
16:52:06 <ion> I think 0.1.0.0 > 0.1
16:52:09 <Hafydd> That's a pretty demented way of coming to that conclusion.
16:52:12 <JoeyA> So it's up to you what permutations [] is.
16:52:25 <ivanm> @type Version
16:52:26 <lambdabot> Not in scope: data constructor `Version'
16:52:28 <ivanm> @hoogle Version
16:52:28 <lambdabot> Data.Version module Data.Version
16:52:28 <lambdabot> Data.Version Version :: [Int] -> [String] -> Version
16:52:28 <lambdabot> Data.Version data Version
16:52:46 <JoeyA> The idea is to come up with a definition of permutations that doesn't cause weird bugs to appear when you have an empty list.
16:52:53 <ivanm> IIRC, for Version, 0.1 == 0.1.0.0
16:53:00 <epta> Okay
16:53:16 <Hafydd> If you don't know what a word means, you shouldn't be writing a function for it.
16:53:53 <Hafydd> I suppose the world would be less awful if people followed the generalisation of that advice.
16:53:55 <ion> ivanm: Huh. A weird way to do it in a programmatic sense. Not that it matters IRL because people shouldn’t abuse whichever relation 0.1 and 0.1.0.0 have.
16:53:56 <JoeyA> kurtis: But if you can't figure out a clean, consistent way to handle the empty case, you could just throw an exception and "let it crash"
16:54:21 <pqmodn> Hafydd: the point was not to define permutation. it was to show how thinking mathematically can minimize edge cases
16:54:25 <ivanm> ion: yeah, I generally dont' like that 0.10 > 0.1, but it's lexicographic ordering or some such (I forget the term)
16:54:25 <JoeyA> This way, if it comes up in practice, you can fill in the hole in your program without introducing any regression (since it will always go from not working to working)
16:54:44 <Hafydd> pqmodn: that was not example of thinking mathematically; it was more like experimental physics.
16:54:58 <JoeyA> kurtis: Here's another example: modulus with negative numbers
16:55:18 <JoeyA> > [3 `mod` 5, 7 `mod` 5, 0 `mod` 5, 5 `mod` 5]
16:55:20 <lambdabot>   [3,2,0,0]
16:55:21 <kurtis> JoeyA, Okay, I think I see what you're saying. And I can completely agree with you on the logic, there. Let's say there's N point of failure for each given method, and you need to return a specific response based upon the error, and you have many, many methods. Would this still apply neatly?
16:55:25 <dmwit> > Data.Version.Version [0,1] [] < Data.Version.Version [0,1,0,0] []
16:55:27 <lambdabot>   Not in scope: data constructor `Data.Version.Version'Not in scope: data con...
16:55:33 <dmwit> Anyway, it's True.
16:55:46 <ivanm> huh
16:56:09 <ion> > [0,1] < [0,1,0,0]
16:56:10 <lambdabot>   True
16:56:12 <kurtis> Sorry, I should rephrase that. One sec.
16:57:07 <JoeyA> What *should* (-1) `mod` 7 be, for the sake of consistency?
16:57:07 <kurtis> Let's say you have one function. It accepts multiple variables. You need to throw a specific exception based upon the point of error. How would you deal with that?
16:57:22 <JoeyA> kurtis: When is throwing an exception a requirement?
16:58:33 <kurtis> JoeyA, I suppose Throwing an Exception is not a requirement. However, returning a "meaningful" value (in my requirements, a useful Response Message) is.
16:58:50 <JoeyA> A program is just one big function of inputs -> outputs.
16:58:55 <croikle> monads can chain error handling quite nicely
16:59:30 <JoeyA> So if you assume all inputs are valid, you shouldn't need error handling internally, and you can just produce the outputs.
17:00:08 <JoeyA> So filter out invalid inputs from the outside, and (optionally, but very useful) put assertions on the inside.
17:00:38 <JoeyA> kurtis: So, what kind of invalid inputs can you have?
17:00:57 <kurtis> JoeyA, that's exactly what I'm looking for. A way to do that. The problem I run into is having massive boilerplate or whatever it should be called dealing with the Input.
17:01:41 <JoeyA> Some I can think of: user gave invalid formatting for a field (too few/too many digits in credit card number, invalid date, etc.)
17:01:54 <JoeyA> File not found, database error (internal errors)
17:02:12 <kurtis> JoeyA, I think in my case, the question is not what "invalid" input can you have ... but rather, what "valid" input can you have
17:02:16 <JoeyA> Record not found (user tried to look something up, but the ID wasn't there)
17:02:29 <kurtis> But yes, you're hitting it
17:03:15 <JoeyA> It helps to have a good understanding of the mathematical notion of "undefined".
17:03:24 <JoeyA> It doesn't mean "I'll handle it a few levels up in the code"
17:03:38 <JoeyA> It means throwing your hands up in the air because you don't know what to do here.
17:04:53 <JoeyA> So consider a function that produces a valid output for every possible input.  That's called a "total function".
17:04:57 <kurtis> Would it be ignorant to accept "undefined" as a generic response to an unknown problem?
17:05:30 <JoeyA> kurtis: That's exactly it.
17:05:47 <kurtis> Okay, cool. I'm still with you then :)
17:05:49 <JoeyA> If you don't know how to handle it, log the failure and crash.
17:06:15 <JoeyA> It's like throwing an exception to yourself :-)
17:08:17 <JoeyA> But a useful property of throwing "undefined" is that you're saying: I assume this function will never receive this input.
17:08:45 <JoeyA> You're not saying "die if this happens", you're saying "it shouldn't ever happen"
17:08:58 <kurtis> That makes sense. Similar to division by 0.
17:09:09 <JoeyA> Right.
17:09:37 <JoeyA> When you divide by zero, the calculator is telling you to take a step back and look at the bigger picture.
17:09:59 <JoeyA> For example, 1/x as x approaches 0 from the positive direction.
17:10:10 <JoeyA> In that case, you can see x approaching infinity if you look at the graph.
17:10:39 <JoeyA> undefined is also called _|_ (bottom)
17:11:58 <kurtis> So I get the idea that it is feasible or even smart to define my logic within functions without worrying about Edge Cases within those functions. I'm just not sure if I see *how* to do that; not without a *ton* of boiler plate to filter out variable input before calling the functions. (Sorry if I'm going off course here)
17:12:45 <JoeyA> Well, you do that by filtering out invalid input :-)
17:12:50 <JoeyA> How much of it can there be?
17:13:31 <JoeyA> If it's a bunch of user-supplied forms, just handle invalid input in your form-handling code, and if it's valid, proceed to the next step.
17:13:35 <startling> kurtis: do you know Maybe?
17:14:16 <JoeyA> If it's data from some other service (not from a human being), don't go nuts trying to validate it.
17:14:35 <jmcarthur> on the other hand, that doesn't mean don't try to convert it into a more convenient form
17:14:43 <JoeyA> Right
17:14:46 <JoeyA> kurtis: Have you heard of the robustness principle?
17:15:07 <JoeyA> Originally, it was "programs should be liberal in what they accept, and conservative in what they generate"
17:15:08 <kurtis> Well in my previous project's case, there's a *ton* of input. It's not that a specific method requires a lot of input, it's that each function has a different set of input. I need to compensate for each. (Just for the knowledge, it's all JSON)
17:15:36 <JoeyA> But that turned out to be a bad idea in practice
17:15:52 <jmcarthur> JoeyA: oh?
17:16:05 <JoeyA> For example, consider what happens when a browser from one vendor accepts invalid code.
17:16:05 <kurtis> Sorry for using the words method and function interchangeably; I'm not speaking technical lingo
17:16:22 <JoeyA> Then people make sides that work for that browser, and they don't work for other browsers.
17:16:29 <JoeyA> sites*
17:16:44 <jmcarthur> people who are, themselves, violating the principle in question
17:17:26 <JoeyA> If your code is too lenient, people using your code will start producing invalid input.
17:17:33 <JoeyA> Then you have to be able to handle that invalid input going forward.
17:17:44 <jmcarthur> i think the principle is great when it's actually followed
17:19:02 <jmcarthur> the way i see it, it's not my fault that somebody took advantage of my program being liberal with its inputs unless i had put them under the impression that i guaranteed it
17:19:29 <ivanm> jmcarthur: so you need to accept liberal inputs and email the owner/maintainer of the site that uses dodgy code and tell them to fix it! :p
17:19:37 <parcs> bah, i completely missed the existence of PastePipe as i was writing this hpaste client -_-
17:20:02 <JoeyA> kurtis: What if you just be very strict about all the input you receive, and make the program crash immediately if the input is not valid.
17:20:16 <JoeyA> (Don't shut down the whole server; just give the user a generic error message)
17:20:41 <JoeyA> Then, find the root cause of the invalid data when it actually comes up, and address it then.
17:20:41 <mauke> 400 You suck
17:21:11 <Rarrikins> hAHA
17:21:39 <jmcarthur> ivanm: well, if i control the interface i would probably try to include a way to inform users of non-fatal issues automatically if it's important enough
17:21:40 <kurtis> JoeyA, I think a generic error message would be great! However, I don't think the guy on the other end of the line would be too happy with it.
17:21:58 <JoeyA> Well, figure out how often it occurs in practice.
17:22:13 <kurtis> (or specifically, it's in my requirements document that each possible error has a specific response)
17:22:14 <JoeyA> The thing is, if you speculate on how to handle it correctly, you might get it wrong.
17:22:26 <JoeyA> If you get it wrong, you can't fix the problem without changing the behavior of the site.
17:23:07 <JoeyA> If you just "let it crash", then if you implement handling later, it will strictly be an improvement.
17:23:21 <JoeyA> If you know how to handle the error now, by all means do it.
17:23:39 <pqmodn> i've found generally pushing error handling and validation to the "outside" works well. this makes the "inside" much simpler
17:23:47 <JoeyA> But if "90%" of your code is handling invalid input, you're probably taking it overboard.
17:24:28 <jmcarthur> let it crash only works when you get to define the interface. if you don't have that, you have to accept whatever bad inputs other existing interfaces accept, otherwise your program just crashes when others do not
17:25:13 <jmcarthur> i'm making a lot of tangential points, not really trying to get in the way of the more useful conversation going on
17:25:21 <jmcarthur> so sorry for distractions
17:25:48 <JoeyA> jmcarthur: Naw, you're fine.
17:26:13 <kurtis> JoeyA, very true. And it would follow the agile-ish method I've followed well. I still run into the problem of too much input validation. I may be taking it overboard, but I'm not quite sure how to handle it otherwise
17:26:42 <JoeyA> Well, where are you doing that input validation?  On input, or all over your codebase?
17:26:51 <JoeyA> (including your core business logic)
17:27:34 <kurtis> JoeyA, it started out within my codebase. It has slowly progressed to the "top of the chain" through the use of Exception Handling, although it's still within my code base. I'm beginning to think the Input Validation itself is a huge project all on its own
17:28:06 <lightquake> anybody here have experience with netwire?
17:28:47 <zomg> kurtis: input validation is often very specific to an application so yeah it would typically be a large project in most input-heavy applications, but you should be able to use abstraction to reduce boilerplate assuming you find patterns that can be abstracted
17:28:58 <lightquake> i'm trying to figure out how to construct a wire that expresses the notion of a click given the ability to poll for the mouse button state
17:29:23 <JoeyA> kurtis: Well, unless your input is really really complicated, validating and parsing input should be pretty easy to do.
17:29:38 <JoeyA> Err, "can be"
17:29:44 <JoeyA> Note the optimism :-)
17:29:48 <kurtis> zomg, I absolutely agree. That's what I started to do; identifying patterns and handling those problems with re-usable code
17:30:07 <JoeyA> kurtis: One really nice thing about Haskell is its algebraic data types.
17:30:22 <JoeyA> In OO languages, you have classes, which let you clump together a bunch of data.
17:30:37 <JoeyA> That is, A and B and C and D
17:30:43 <parcs> > "foo\    \nn"
17:30:45 <lambdabot>   "foonn"
17:30:47 <JoeyA> In Haskell, you can also have disjunctions in your data
17:30:50 <JoeyA> A or B or C or D
17:30:55 <JoeyA> :i Maybe
17:31:01 <JoeyA> @info Maybe
17:31:01 <lambdabot> Maybe
17:31:06 <JoeyA> :(
17:31:08 <parcs> @src Maybe
17:31:08 <lambdabot> data Maybe a = Nothing | Just a
17:31:15 <kurtis> JoeyA, haha it can get pretty complicated! It shouldn't be. But, I'm letting my client (a programmer as well) define the requirements. Perhaps *that* is my problem
17:31:39 <JoeyA> kurtis: I think I'll have to agree on that one.
17:32:42 <JoeyA> Another example: data Color = Red | Orange | Yellow | Green | Blue | Violet
17:33:02 <JoeyA> The functions in your code would pattern match on colors, e.g. case color of Red -> ...; Orange -> ... ; etc
17:33:23 <JoeyA> If you later add | Indigo, the compiler will catch all cases where you didn't handle Indigo
17:33:54 <Fuuzetsu> @src zipWith
17:33:54 <kurtis> The project has actually disintegrated (lost communications, very bad reputation hit on my end but that's another discussion). I'm hoping to rebuild it for him as a surprise for no charge. I just want to do it in a way that doesn't involve hard to read, error-prone, and disorganized code. Simpler requirements (particularly the Input) would make a *huge* difference.
17:33:54 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
17:33:54 <lambdabot> zipWith _ _      _      = []
17:33:54 <JoeyA> Unless you use the _ pattern which matches everything.
17:34:36 * hackagebot Monaris 0.1.3 - A simple tetris clone  http://hackage.haskell.org/package/Monaris-0.1.3 (FumiakiKinoshita)
17:34:41 <JoeyA> kurtis: fixing your code without fixing the requirements would be a disaster.
17:34:47 <kurtis> JoeyA, Yep, that is one of the things I love about Haskell. And have implemented similar functionality in my code based on the idea. It's just not as pretty in Python ;)
17:34:54 <JoeyA> It'd take a long time, and it'd take even longer if you had to learn a new language.
17:35:37 <JoeyA> Learning Haskell would be to your benefit, though, if only to improve the way you think about data.
17:35:38 <kurtis> JoeyA, Sad but I think you've got a point. I'll have to try to get back into contact with him because he's invested quite a bit of his personal time into the client of this Web Service
17:38:32 <kurtis> JoeyA, Very true. This is the 3rd Web Service I've worked on and I have a *huge* one coming up. I was hoping that Haskell (or functional languages in general) might help the process. While all of these things are possible in any language, I like the idea of the strict typing and the ability to test independent functions. As someone said earlier, there's probably no gain from Higher Order functions.
17:39:27 <JoeyA> Switching to Haskell won't give you immediate gains.  There's also a mindset change that comes with it.
17:39:49 <startling> so I've got a data Field = Field { _a, _b, _c, _d, _e, _f, _g, _h :: Bool }; makeLenses ''Field. How should I write a Simple Lens Field Word8?
17:40:18 <elliott> should probably just use "lens"
17:40:48 <startling> there's not a clever way using bitAt or whatever? dang
17:40:58 <edwardk> you can probably walk it and do something with bits
17:41:13 <shachaf> You could probably use partsOf and traverseBits or something.
17:41:18 <edwardk> say you have a traversal for it
17:41:23 <startling> :t partsOf
17:41:25 <lambdabot> Functor f => LensLike (Control.Lens.Internal.BazaarT a a f) s t a a -> LensLike f s t [a] [a]
17:41:31 <JoeyA> kurtis: Having a huge interface between client and server may mean the work was not split in a good place.
17:41:39 <edwardk> field k (Field a b c d e f g h) = Field <$> f a <*> f b <*> f c <*> ...
17:41:51 <edwardk> field k (Field a b c d e f g h) = Field <$> k a <*> k b <*> k c <*> ...
17:42:06 <elliott> good thing Field doesn't have three more elements or edwardk would have problems
17:42:16 <startling> :S
17:42:17 <edwardk> then you can read the bits out of it with myField^..field
17:42:27 <kurtis> JoeyA, hmm interesting. When would Haskell be a better choice? Other than the general "When to use Functional Languages" documents that a lot of people tend to put on the web? And yes -- I completely agree. The work was definitely heavy-handedly put on my end but I think the motivation was ease of developing future clients (other platforms)
17:42:28 <JoeyA> I like how the UNIX-HATERS Handbook describes X11: "a graphical client/server model that slices the interface down some arbitrary middle is like Solomon following through with his child-sharing strategy. The legs, heart, and left eye end up on the server, the arms and lungs go to the client, the head is left rolling around on the floor, and blood spurts everywhere."
17:42:29 <shachaf> startling: It might be better to represent Field as a Word8 and then have a lens into each of its bits.
17:42:40 <shachaf> Rather than as 8 Bools.
17:42:41 <startling> shachaf: hmmm, maybe
17:42:52 <edwardk> 0 & partsOf bits .~ myField^..field
17:43:04 <kurtis> haha, I like that
17:43:04 <startling> edwardk: woah, let me stare at that for a bit
17:43:06 <edwardk> would then give you a number with the bits equal to your individual bitfields
17:43:11 <edwardk> er
17:43:29 <edwardk> (0 :: Word8) & partsOf bits .~ myField^..fields
17:44:12 <edwardk> you can write back the other way by using Field False False False False … & partsOf fields .~ myWord8^..bits
17:44:51 <edwardk> it gets less ad hoc if you make an Each instance for Field
17:45:02 <edwardk> but that would at least work, even if its somewhat ugly
17:45:43 <edwardk> startling: if you make Field into a Word8 then you can use the bitAt lens directly to access the individual bools
17:46:01 <edwardk> and make up names for them, etc.
17:46:04 <startling> edwardk: yeah, that's what I'm playing with now. :)
17:46:48 <edwardk> data Field = Field Word8; makeIso ''Field  foo = from field.bitAt 0; bar = from field.bitAt 1; ...
17:47:05 <edwardk> gives you a wrapper around it if you want to smash other stuff in there
17:47:32 <startling> what does makeIso do differently than makeLens?
17:47:46 <edwardk> makeIso makes an isomorphism so you can construct it from a Word8 directly
17:47:51 <kurtis> By the way, JoeyA, thanks a lot for clearing my mind on the problem at hand. You've helped me identify the specific problems quite a bit!
17:48:04 <startling> doesn't makeLens do that for newtypes already, or was that changed?
17:48:06 <edwardk> (and the isomorphism name goes the other way)
17:48:32 <edwardk> i _think_ it was changed, but if it was it was changed months ago
17:48:55 <maky> can someone help me with these Text.Regex.PCRE errors?
17:48:56 <startling> it's been a while. :)
17:49:00 <hpaste> maky pasted “Text.Regex.PCRE linking (?) errors” at http://hpaste.org/80082
17:49:54 <edwardk> ok, i've written sell for the new generalize Bazaar, that means we should be able to do everything with them
17:50:00 <edwardk> er generalized
17:50:12 <edwardk> instance (RepresentableProfunctor p, CorepresentableProfunctor q, Applicative (Corep q))  => Sellable p (Bazaar p q) where
17:50:13 <edwardk>   sell = tabulatePro $ \ w -> Bazaar $ cotabulatePro $ \k -> pure (indexPro k w)
17:50:32 <edwardk> we really need shorter names for those =)
17:50:38 <maky> since I installed package that ships with PCRE library I expected everything to work oot of the box
17:51:09 <startling> yeah, the wrap-a-Word8-and-write-lenses-for-fields approach works much more nicely. thanks!
17:51:30 <edwardk> startling: we do something similar in Control.Lens.TH itself for working with a Set of flags
17:51:42 <edwardk> blah = flags.ix Blah
17:51:50 <startling> neat
17:52:12 <edwardk> that may be nicer if you outgrow a Word64 ;)
17:52:25 <startling> heh
17:55:04 <shachaf> Or you can just use Integer!
17:55:08 <shachaf> That has lots of bits.
17:55:19 <edwardk> shachaf: heh
17:55:39 <mikeplus64> hm, is there some kind of concurrent state monad? so you could have like do { forkIO (forkIO (getLine >>= put)); forever (get >>= putStrLn) }
17:55:41 <kurtis> Do you guys consider Haskell (or functional languages in general) better than Procedural/OOP languages for data transformations? For a specific example, converting some data (possibly an object when working in OOP) into a specific serialized format (e.g. JSON)? I'm trying to find pros/cons for the use of Haskell in Web Development
17:55:49 <mikeplus64> or is that where STM comes in? (i have no idea)
17:56:23 <mikeplus64> oh, google to the rescue, someone has made http://hackage.haskell.org/packages/archive/mstate/0.2.4/doc/html/Control-Concurrent-MState.html
17:57:01 <shachaf> That someone made it doesn't necessarily mean that you want it.
17:57:08 <shachaf> What are you trying to do?
17:57:27 <mikeplus64> i'm just wondering if it's possible or sane :)
17:57:34 <shachaf> Usually the sort of thing State gives and concurrency don't really work together.
18:01:51 <mikeplus64> i suppose in a situation where i would want a global thread safe mutable state, i really ought to just use IORefs/MVars/whatever, seeing as that's the (abridged) implementation of MState anyway
18:03:45 <sw2wolf> :t liftM
18:03:46 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
18:06:28 <maky> mikeplus64: can you describe your requirements?  what are you doing?
18:07:26 <mikeplus64> maky: i was just wondering if it is possible to make a concurrent State monad -- it is
18:08:36 <mikeplus64> i was working on an IRC bot and thinking it would be neat to represent everything in a State monad, but realised that say if i had the nick list for a channel in the environment, it wouldn't be "updated" in other threads unless I used an IORef or similar
18:08:54 <mikeplus64> then i realised it wouldn't be neat after all
18:13:16 <Jafet> @quote so.oop
18:13:16 <lambdabot> edwardk says: yo dawg, in haskell we can be so oop that even our accessors have UML diagrams describing their accessors.
18:14:48 <JoeyA> kurtis: Data transformation is Haskell's biggest forté.
18:14:59 <JoeyA> For JSON in particular, there's the aeson package.
18:16:40 <Jafet> The peano is its mezzoforte
18:16:42 <JoeyA> That's mainly for converting from JSON to a representation that's easier to work with in Haskell (namely, algebraic data types)
18:17:09 <edwardk> shachaf:   iseeks f = Pretext . lmap (lmap f) . runPretect   -- on two different profunctors. fun
18:17:18 <edwardk> er runPretext
18:26:34 <shachaf> edwardk: Why not add a dimap in there for good measure?
18:26:44 <edwardk> does it help?
18:27:25 <shachaf> dimap runPretext Pretext (lmap (lmap f))
18:27:34 <shachaf> iseeks = dimap runPretext Pretext . lmap . lmap
18:27:37 <shachaf> Or something.
18:28:12 <edwardk> hrmm
18:28:17 <shachaf> If you had an Iso you could just use it here with "over _Pretext", of course.
18:28:30 <edwardk> you like that pattern a lot
18:28:37 <Fuuzetsu> I feel horrible. I just put <*> specialised for lists into my Scheme program.
18:29:02 <shachaf> edwardk: Well, I had dozens of overFoo f = Foo . f . runFoo; underFoo = runFoo . f . Foo earlier.
18:29:15 <shachaf> Then I made them all into Isos and they all went away.
18:29:21 <shachaf> It's really nice for working with newtypes.
18:29:33 <shachaf> For one-argument functions, anyway. :-)
18:29:51 <edwardk> heh
18:30:15 <shachaf> instance Lensy (Indexed i)   where lensy   = over _Indexed   $ \r i a -> (a, r i a)
18:30:19 <shachaf> Things like that.
18:32:01 <shachaf> Fuuzetsu: Which specialization?
18:32:34 <shachaf> edwardk: For what it's worth I think the final @pled version is a too much.
18:32:57 <shachaf> But the pattern of applying a preprocessing step and a postprocessing step before/after applying a function is pretty common.
18:33:46 <edwardk> ok, i've enriched all the Bazaar/pretext variants with the measured profunctor
18:33:54 <edwardk> now to go modify all the combinators to use it
18:34:00 <shachaf> Finally we've eliminated every (->) in Bazaar!
18:34:04 <edwardk> =)
18:34:22 <shachaf> Functions are much too concrete for edwardk.
18:34:29 <edwardk> what part of newtype BazaarT p q (g :: * -> *) a b t = BazaarT { runBazaarT :: forall f. Applicative f => p a (f b) `q` f t } don't you understand?
18:34:29 <beaky> hello
18:35:18 <lispy> all of it
18:36:11 <shachaf> lispy: It's pretty simple, really. g is nonsense. p and q are just (->). a = b
18:36:20 <edwardk> lispy: instance (a ~ b, SelfAdjoint p, CorepresentableProfunctor q, Comonad (Corep q), Applicative (Corep q)) => Comonad (BazaarT p q g a b) where
18:36:31 <edwardk> that is basically stating what shachaf just said
18:36:40 <lispy> you can have infix types?
18:36:44 <lispy> i mean, with ``
18:36:46 <shachaf> So Bazaar a t = forall f. (a -> f a) -> f t
18:36:49 <edwardk> yeah with TypeOperators
18:37:02 <edwardk> shachaf: with an Applicative f => in there
18:37:05 <shachaf> Er, right.
18:37:14 <shachaf> Compare to
18:37:16 <shachaf> @ty flip mapM
18:37:17 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
18:37:25 <edwardk> ts the right hand side of that
18:37:34 <edwardk> @ty flip traverse
18:37:35 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
18:38:32 <edwardk> (forall f. Applicative f => (a -> f b) -> f t)    is very much like the the output of applying 'flip traverse' (aka 'for') to a value. its just that wrapped in a newtype
18:38:34 <edwardk> :t for
18:38:35 <lambdabot> [a] -> (a -> b) -> [b]
18:38:48 <edwardk> :t Data.Traversable.for
18:38:49 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
18:41:12 <shachaf> I think we've lospy.
18:44:17 <Fuuzetsu> shachaf: I just made it act on lists as it would in Haskell
18:44:43 <Fuuzetsu> (<*> (map (part2 equal?) (list 1 2 5 4)) (list 4 2 44 5))
18:44:45 <Fuuzetsu> (#f #f #f #f #f #t #f #f #f #f #f #t #t #f #f #f)
18:45:13 <lispy> oh scheme
18:45:16 <lispy> You so crazy
18:45:29 <Fuuzetsu> dynamic typing feels bad man
18:47:41 <Nisstyre> Fuuzetsu: what was the point of defining that?
18:48:25 <shachaf> Fuuzetsu: It sounds to me like you want liftA2, not <*>
18:49:56 <lispy> edwardk, shachaf: I'm sure lens is cool, but a) I can't see how to apply it in the code I have (this just means I need to play with examples more) b) the internals are mind boggling for someone who's only CT knowledge is from day to day haskell use
18:50:16 <shachaf> lispy: You don't need to know category theory!
18:50:22 <shachaf> Also it's not as scary as it looks.
18:50:40 <lispy> shachaf: read edwardk's explanations above :)
18:51:05 <edwardk> lispy: did you get a chance to watch the video?
18:51:07 <Fuuzetsu> shachaf: oo, I do indeed
18:51:12 <shachaf> lispy: What, the SelfAdjoint and CorepresentableProfunctor things?
18:51:35 <shachaf> You can ignore all that.
18:51:39 <edwardk> lispy: those classes are part of generalizations going on right now and are not indicative of the final form things will take
18:51:59 <shachaf> lispy: You should watch edwardk's talk!
18:52:00 <edwardk> lispy: we're brute forcing some bits to get more things to work together in HEAD right now
18:52:05 <edwardk> the talk helps a lot
18:52:20 <edwardk> https://www.youtube.com/watch?v=cefnmjtAolY&hd=1
18:52:27 <Fuuzetsu> is the buzzing removed?
18:52:31 <edwardk> Fuuzetsu: yes
18:52:34 <Fuuzetsu> neat
18:52:38 <jozefg> shachaf: is there a link to that talk somewhere?
18:52:40 <Fuuzetsu> by the way, it's impossible to see most slides
18:52:44 <edwardk> jozefg: https://www.youtube.com/watch?v=cefnmjtAolY&hd=1
18:52:49 <jozefg> Ahh there it is
18:53:00 <edwardk> Fuuzetsu: crank the resolution to 1080p or grab the slides from the top of the description
18:53:05 <jozefg> edwardk:  Thank you
18:53:20 <Fuuzetsu> edwardk: ah; I watched it when there was no link in the description. I'll have a look later.
18:53:22 <edwardk> i also hand-captioned about the first half of it
18:53:29 <jozefg> Now I just have to wait for it to load, internet at 10,000ft is sketchy at best
18:53:33 <edwardk> Fuuzetsu: the link was there all along it was just buried way at the bottom ;)
18:53:46 <Fuuzetsu> oh
18:54:24 <watermind> edwardk: I wish youtube had an option for two screens one with lecture, another with slides ... like in this wadler talk at infoQ http://www.infoq.com/presentations/Faith-Evolution-Programming-Languages
18:54:58 * lispy goes to watch the talk
18:57:33 <lispy> edwardk++ -- thanks for the 1080p
18:57:49 <shachaf> Perhaps it should be sclv++
18:57:59 <edwardk> rickasaurus++ even
18:58:38 <shachaf> Karma all around!
18:58:40 <shachaf> @karma+ java
18:58:40 <lambdabot> shachaf's karma lowered to 78.
18:58:43 <elliott> shachaf--
18:58:53 <shachaf> Someone spammed "shachaf++" in another channel.
18:58:57 <shachaf> That karma is mostly fake.
18:58:58 <edwardk> shachaf: hah
18:59:02 <shachaf> @karma+ java
18:59:03 <lambdabot> shachaf's karma lowered to 76.
18:59:03 <shachaf> @karma+ java
18:59:03 <lambdabot> shachaf's karma lowered to 75.
18:59:04 <shachaf> @karma+ java
18:59:04 <lambdabot> shachaf's karma lowered to 74.
18:59:08 <elliott> @karma java
18:59:08 <lambdabot> java has a karma of -1
18:59:11 <edwardk> @karma edwardk
18:59:11 <lambdabot> You have a karma of 22
18:59:37 <cmccann> @karma lambdabot
18:59:37 <lambdabot> lambdabot has a karma of 26
18:59:44 <cmccann> @karma karma
18:59:44 <lambdabot> karma has a karma of 1
18:59:48 <cmccann> fitting!
19:02:45 <JoeyA> @karma JoeyA
19:02:45 <lambdabot> You have a karma of 3
19:02:49 <startling> karma++
19:03:01 <startling> @karma+ karma
19:03:02 <lambdabot> karma's karma raised to 3.
19:03:29 <JoeyA> So is @karma+ pre-increment?
19:03:34 <JoeyA> @karma+ karma
19:03:34 <lambdabot> karma's karma raised to 4.
19:03:37 <JoeyA> @karma karma
19:03:37 <lambdabot> karma has a karma of 4
19:03:53 <JoeyA> apparently so
19:04:55 <jsmr> Where is the file that allows you to edit ghci's defaults (setting the editor to something other than notepad)? I tried looking  in C:\...\APPDATA\ghc on windows but couldn't find anything.
19:05:24 <shachaf> I think you'll have to make it yourself.
19:05:35 <shachaf> Put :set editor <cmd> in it.
19:05:53 <startling> karma--
19:06:00 <startling> @karma- karma
19:06:00 <lambdabot> karma's karma lowered to 2.
19:06:01 <monochrom> the GHC user guide has information on it. the GHC user guide is somewhere on your hard disk
19:06:02 <JoeyA> jsmr: Open up a terminal and type echo %APPDATA
19:06:18 <jsmr> with a .ghci filename?
19:06:18 <JoeyA> or echo $APPDATA, if it's a bash terminal (e.g. Git Bash or MSYS)
19:07:14 <JoeyA> On Linux, it's in ~/.ghc/ghci.conf (at least for me)
19:07:22 <JoeyA> On Windows, it's in %APPDATA\ghc
19:07:29 <shachaf> monochrom: I just learned about :seti from reading the GHC user guide!
19:07:33 <shachaf> Thanks, monochrom!
19:07:40 <monochrom> \∩/
19:07:50 <JoeyA> jsmr: http://stackoverflow.com/questions/3518619/how-to-configure-ghci-to-automatically-import-modules
19:08:17 <shachaf> jsmr: The GHC user guide does indeed answer your question.
19:08:28 <shachaf> Section 2.9, for the version I'm looking at.
19:08:34 <shachaf> Also section 2.8
19:09:01 <jsmr> Got it! Thanks
19:12:59 <lightquake> re-asking: does anybody know how i'd set up a wire for something like a mouse click in glfw/opengl?
19:13:01 <lightquake> using netwire
19:17:35 <watermind> is there any proposal to improve on the usability of implicit values?
19:17:50 <lpsmith> thoughtpolice, you are welcome!
19:18:18 <edwardk> watermind: mostly proposals to remove them, and to add holes, which would be an improvement ;)
19:19:20 <watermind> edwardk: hmm I never thought of holes like that... i.e. I can see how both approaches denote open terms
19:19:36 <shachaf> I used ImplicitParams as holes all the time.
19:19:49 <shachaf> I pretty much don't write Haskell code anymore when the types get complicated.
19:19:54 <edwardk> :t ?x + (0 :: Int)
19:19:55 <lambdabot> (?x::Int) => Int
19:20:33 <watermind> shachaf: that I can understand... I just don't see how holes would substitute implicits
19:20:51 <watermind> then again I'm not sure about the details of implementation of holes in haskell
19:20:56 <edwardk> watermind: it was more tongue in cheek that the major usecase most people have for implicits is fake holes ;)
19:21:11 <watermind> edwardk: right... that's not the use case I had in mind at all
19:21:56 <watermind> the way I see it, we have had global values since the very beginning:  nested functions
19:22:12 <edwardk> watermind: have you seen the reflection library?
19:22:16 <watermind> but nested functions are a pain
19:22:26 <watermind> edwardk: nope, never heard of it
19:22:32 <edwardk> @hackage reflection
19:22:32 <lambdabot> http://hackage.haskell.org/package/reflection
19:22:46 <edwardk> here is a paper linked from my haddocks there
19:22:51 <edwardk> er there
19:23:08 <edwardk> by oleg kiselyov and chung-chieh shan
19:23:25 <edwardk> the implementation is now many orders of magnitude faster than their approach
19:23:33 <edwardk> but the ideas from the paper are still good
19:23:47 <edwardk> they cover how i tend to solve the configuration problem
19:23:58 * shachaf hasn't read the paper.
19:24:11 <shachaf> I more or less understand how the "fast" implementation works.
19:24:37 <shachaf> The "slow" one looks complicated and confusing.
19:24:56 <edwardk> in particular reflection gives you reify :: a -> (forall s. Reifies s a => Proxy s -> r) -> r   for turning terms into types, that you can then reflect :: Reifies s a => p s -> a    back down
19:25:13 <watermind> edwardk: need to read this... the part where they use higher rank polymorphism and polymorphic recursion for this scares me a bit
19:25:16 <edwardk> e.g. reify 4 (\p -> reflect p + reflect p) gives you 8
19:25:39 <edwardk> the higher rank type is basically giving you a nested scope, its kind of like how runST works
19:26:06 <edwardk> the interesting part is you can reify anything, not just numbers, or storable data types
19:26:08 <shachaf> > let reify = (&); reflect = id in reify 4 (\p -> reflect p + reflect p)
19:26:10 <lambdabot>   8
19:26:30 <edwardk> and that because its an instance it can move over lambdas, etc.
19:26:34 <watermind> hmm right
19:26:51 <edwardk> just don't pay too much attention to how the sausage is made ;)
19:26:53 <shachaf> Cale: You should add reflection to lambdabot!
19:26:57 <elliott> watermind: if you think that's scary you should see the implementation the package uses by default
19:27:09 <watermind> :S
19:27:21 <shachaf> elliott: The unsafeCoerce Magic implementation?
19:27:26 <elliott> shachaf: the slow one basically goes reflecting naturals -> reflecting 8 naturals (a pointer)
19:27:30 <shachaf> That one looks pretty simple.
19:27:45 <elliott> yeah but it's less "safe"
19:27:48 <elliott> the slow one should work on anything
19:27:53 <elliott> well anything with 8 bit pointers..
19:27:56 <shachaf> Even 128-bit GHC?
19:28:57 <shachaf> elliott: My problem is that I have one of those new 8086 machines with 16-bit pointers.
19:29:16 <shachaf> So I guess I'm stuck with the other implementation.
19:29:35 * shapr runs cabal update on his Raspberry Pi
19:31:33 <Modius> Is there a trick for folding a Maybe?  I'm looking at foldable but can't get it to compile
19:31:46 <shachaf> That depends on what you're trying to do.
19:31:50 <shachaf> Fold it into what?
19:32:25 <Modius> A simple case - I want to "sum" the Maybe's contents, off of course an initial 0
19:32:36 <watermind> hmm the paper claims implicit parameters do exhibit some problems with sharing... I didn't expect that
19:33:00 <shachaf> With lens you can say sumOf folded :-)
19:33:12 <Modius> For now, interested in learning the regular fosd
19:33:14 <Modius> fold
19:33:14 <shachaf> Oh, Foldable.sum will work too.
19:34:11 <monochrom> haha 128-bit GHC. almost thought you were talking about cryptography, 128-bit keys are so secure!
19:34:32 <thoughtpolice> lpsmith: i've had fun writing this up so far, i may be able to put this little piece of code on hackage tomorrow or something, tutorial and all :P
19:35:51 <watermind> I probably just haven't given it enough thought... but I still find it odd that defining open terms ends up being so complicated, particulalrly in a pure non-strict language
19:36:06 <watermind> it is basically an ((->) env) monad
19:36:33 <watermind> so I'd expect a bit of syntactic sugar to do the trick
19:36:45 <elliott> one could argue the sugar is: (env -> value)
19:37:16 <cmccann> elliott, hm but which compiler extensions does (->) require
19:37:25 <elliott> -XHaskell2010
19:37:32 <watermind> elliott: that seems pretty explicit :P  unless I  didn't understand what you mean
19:37:52 <elliott> mostly kidding
19:38:19 <monochrom> by default, you shouldn't need -XHaskell2010, it's implied
19:38:33 <tmanny> ..
19:38:41 <shachaf> Implied in which compiler?
19:38:46 <monochrom> however, if you call cabal, it sets -XHaskell98 by default
19:38:52 <shachaf> Perhaps elliott is not using GHC.
19:38:52 <monochrom> GHC 7.4
19:39:26 <watermind> my point was that implicit values don't seem to do much more than an environment monad... or nested env monads...
19:39:31 <cmccann> there should be an -XNoHaskell flag that disables the actual language and only compiles stuff enabled by other extensions.
19:40:01 <monochrom> -XC++0x
19:40:02 <cmccann> almost as useful as the -XPolymorphismRestriction I've always wanted
19:40:12 * shapr waits for HaskellNet to cabal install on his Raspberry Pi
19:40:23 <watermind> implicits are a pain only because we still need to declare the 'environment' in every 'open term'
19:40:37 * elliott seconds the recommendation of reflection
19:40:48 <elliott> (you don't really need to care about the implementation to use it effectively)
19:41:24 <watermind> yeap, I'll definitely look into it and study that paper even
19:41:38 <watermind> I'm quite curious about their approach
19:42:09 <shachaf> elliott *and* edwardk are recommending reflection?
19:42:20 <shachaf> Incredible.
19:42:26 <watermind> shachaf: ?
19:42:31 <edwardk> shachaf: elliott was in part responsible for the current hack ;)
19:42:40 <shachaf> I know.
19:42:40 <elliott> somehow I suspect shachaf knows this
19:43:49 <watermind> ok guys thanks for the references! time to go to bed here
19:44:49 <shachaf> Next up: An unbiased panel of judges composed of edwardk, shachaf, elliott, ion, mgsloan, donri, and glguy have been assigned to give a fair report on lens.
19:45:22 <donri> sounds legit
19:45:46 <ion> It sucks, native records are best.
19:45:55 <elliott> 0/10 not enough profunctors
19:46:05 <elliott> also edwardk wouldn't let me export unsafeCoerce
19:46:11 <croikle> haha
19:46:20 <donri> i like it but often find i'm missing some operator
19:46:23 <elliott> haha
19:46:23 <edwardk> elliott: i'm letting you export it from profunctors.
19:46:29 <edwardk> speaking of which, where's my patch?
19:46:37 <edwardk> donri: hahahaha
19:46:40 <elliott> edwardk: well you see shachaf filed a GHC bug report about the whole (#) thing
19:46:45 <elliott> so it should be fixed by tomorrow anyway
19:47:13 <shachaf> Maybe we should just not care?
19:49:43 <tmanny> I am pretty new to haskell and I am playing around with forkIO and MVar, trying to get a feeling for them. can someone explain why is there a 2 or so second delay between what consumeData is getting vs what produceData should be producing?
19:50:05 <shachaf> tmanny: Not without seeing your code. :-)
19:50:12 <hpaste> tmanny pasted “threading issues” at http://hpaste.org/80087
19:50:33 <shachaf> I bet it's a Win32 thing.
19:51:03 <shachaf> Or maybe not?
19:51:06 <tmanny> could be
19:51:13 <shachaf> You do have a 1-second sleep in there.
19:51:49 <shachaf> That sleep is on every iteration of consumeData.
19:51:56 <tmanny> yes. but shouldnt I be getting most recently fetched POINT
19:51:59 <shachaf> What's the behavior you expect?
19:52:12 <shachaf> You don't overwrite an MVar with putMVar
19:52:20 <shachaf> If you try to write to a full MVar, you block until someone empties it.
19:52:32 <shachaf> Think of it as a channel of size 1.
19:54:15 <tmanny> ah ok, I misunderstood how MVar works then. so I should use modifyMVar instead
19:54:20 <donri> @src print
19:54:20 <lambdabot> print x = putStrLn (show x)
19:54:40 <croikle> no, just use an IOref instead
19:54:57 <monochrom> you do not know what modifyMVar does
19:55:04 <shachaf> The main point of MVars is this blocking behavior.
19:55:15 <tmanny> I see. I will look IOref up
19:56:15 <Skillsob> "print = putStrLn . show" would be more idiomatic, I think.
19:56:31 <tmanny> btw was evaluate needed in my code to ensure that getCursorPos gets executed in the producing thread?
19:56:34 <shachaf> There is no need to @plify everything!
19:56:41 <monochrom> no
19:56:51 <shachaf> tmanny: No, execution is distinct from evaluation.
19:57:04 <monochrom> evaluate does something else
19:58:09 <monochrom> consumeData should not be the one imposing delays. if anything, produceData should be the one imposing it
19:58:55 <monochrom> but you were probably working under the assumption that takeMVar did not block
20:00:03 <monochrom> the truth is, if the MVar is empty, takeMVar blocks
20:00:16 <tmanny> yes. should have read the documentation better before diving in. thanks for help everyone
20:09:22 <ivanm> @where pvp
20:09:22 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
20:09:49 <hpaste> “Jonathan Fischoff” pasted “Rank2Types issues” at http://hpaste.org/80088
20:10:21 <jfischoff> ^ I am confused about how to unpack a tuple with rank2types?
20:11:16 <elliott> jfischoff: Just doesntWork1 (x, y) = x should work
20:11:49 <shachaf> Yep.
20:11:59 <shachaf> Also doesn'tWork xy = toDouble (fst xy) should work
20:12:11 <simpson> So, I've got some FFI fun. I'm working with CInts, and I've got Ints, or maybe some newtype on Int. What's the right way to pass things into/out of my FFI calls? Do I GNTD and derive Num for my types?
20:12:11 <jfischoff> elliot: hmm its not compiling for me
20:12:22 <jfischoff> I'll paste the error
20:12:28 <shachaf> λ> let doesntWork1 :: (forall a. Floating a => (a, a)) -> Double; doesntWork1 (x,y) = x
20:12:31 <shachaf> Works in my ghci
20:12:42 <jfischoff> weird
20:12:49 <jfischoff> what extensions?
20:12:53 <shachaf> All of them.
20:13:00 <jfischoff> :p
20:13:14 <elliott> shachaf uses ghci -fglasgow-exts
20:13:18 <shachaf> Rank2Types
20:13:18 <hpaste> “Jonathan Fischoff” annotated “Rank2Types issues” with “Rank2Types issues (annotation)” at http://hpaste.org/80088#a80089
20:13:38 <elliott> jfischoff: That's not the code I said.
20:13:39 <shachaf> jfischoff: elliott didn't say toDouble x
20:14:08 <jfischoff> yes but I want to use toDouble
20:14:22 <jfischoff> why doesn't that work?
20:14:30 <elliott> welcome to rank-2 types
20:14:33 <shachaf> What you wrote is indeed trickier to type.
20:14:52 <shachaf> What I said works and also uses toDouble
20:16:16 <elliott> shachaf: What you said uses toDouble?
20:16:20 <elliott> Oh, the previous one
20:16:35 <elliott> jfischoff: basically it's because you use case
20:16:54 <jfischoff> elliot: what do you mean?
20:17:22 <shachaf> elliott: toDouble (case xy of (x,y) -> x) would also work :-)
20:18:01 <elliott> shachaf: well... yes
20:18:07 <elliott> "rank-2 types are hard"
20:18:15 <shachaf> You're asking GHC to do more than you think.
20:18:23 <shachaf> Think of forall as an explicit type argument.
20:18:37 <jfischoff> shachaf: ?
20:18:54 <jfischoff> like in Agda?
20:18:59 <shachaf> Yes.
20:19:03 <jfischoff> hmm
20:19:13 <jfischoff> okay
20:19:48 <Targen_> Is there a word for “non-bottom value”?
20:19:51 <shachaf> toDouble :: (/\a. Floating a => a) -> Double; toDouble f = f {Double} {DoubleDict}
20:19:54 <shachaf> Or something like that.
20:20:37 <JoeyA> simpson: Declare the FFI signature using CInt, or a newtype wrapper around CInt, for C int parameters.
20:21:02 <simpson> JoeyA: So, when people pass things in from above, how should I be marshalling?
20:21:13 <JoeyA> To convert to/from regular Int, use fromIntegral (unless you're worried about overflow/underflow due to size change)
20:21:24 <shachaf> doesn'tWork :: (/\a. Floating a => (a,a)) -> Double; doesn'tWork f = let g :: /\a. Floating a => a; g type dict = fst (f {Double} {DoubleDict}) in toDouble g
20:21:30 <JoeyA> simpson: What do you mean?  As in, what API should you expose?
20:21:34 <shachaf> Think of it as something like that, in bad pseudo-Agda.
20:21:39 <simpson> Nah, I don't particularly care. I was just wondering whether I need to do fromIntegral at every single spot.
20:21:42 <JoeyA> Or how to write the FFI signatures?
20:22:35 <jmcarthur> just use fromIntegral wherever a conversion makes sense, but prefer to use C types for the actual foreign calls
20:22:59 <simpson> 'k.
20:23:05 * jfischoff is thinking
20:23:21 <jmcarthur> and newtypes around C types should also be fine since they are supposed to have the same representation
20:23:43 <JoeyA> foreign import ccall "socketpair" c_socketpair :: CInt -> CInt -> CInt -> Ptr CInt -> IO CInt
20:23:53 <shachaf> jfischoff: I wrote that pretty confusingly, so I don't blame you if it was confusing. :-)
20:24:06 <jfischoff> :)
20:24:29 <jfischoff> shachaf: let me put up the code I am actually struggling wiht
20:24:30 <JoeyA> Don't use regular Int in FFI signatures, since it can have a different width than C integers, and that can result in problems on some platforms but not others.
20:24:41 * hackagebot regex-pcre-builtin 0.94.4.4.8.31 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.4.8.31 (AudreyTang)
20:24:50 <JoeyA> For example, on 64-bit GHC, Int is 64 bits, while CInt is 32 bits.
20:25:43 <nexx> :t liftA2
20:25:43 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
20:26:06 <JoeyA> If you do use Int in an FFI signature, the corresponding C type is HsInt, in #include "HsFFI.h" (if you were wondering)
20:26:43 <simpson> No, I'm really thinking about the layer directly above FFI.
20:27:27 <JoeyA> It's a tradeoff over how much control you want to give the user.
20:28:17 <JoeyA> If you're binding to a well-known portable API like curl or sqlite, you may want to provide a separate low-level binding, like this: http://hackage.haskell.org/packages/archive/direct-sqlite/latest/doc/html/Database-SQLite3-Bindings.html
20:29:30 <JoeyA> But for an API that varies from platform to platform (e.g. sockets), you may want to only expose a high-level API.
20:31:28 <JoeyA> simpson: Did I successfully dodge the question?  :-)
20:33:28 <lispy> edwardk: good talk. It does help.
20:33:56 <edwardk> do they seem less insane now?
20:34:41 <lispy> edwardk: I don't know if I'd go that far ;)
20:34:45 <edwardk> heh
20:34:53 <shachaf> Don't worry, edwardk is working on it.
20:34:59 <edwardk> yeah
20:34:59 <hpaste> “Jonathan Fischoff” pasted “More higher rank type issues” at http://hpaste.org/80091
20:35:34 <lispy> I'm looking at the video going, "I really need to pay more attention to all the things applicative has given us (eg., foldable/traversable)"
20:35:43 <tmanny> when was atomicWriteIORef added? I don't have it in ghc 7.4.1.
20:36:03 <lispy> @hoogle atomicWriteIORef
20:36:03 <lambdabot> No results found
20:36:15 <jfischoff> edwardk: enjoying AD but struggling with the higher rank types
20:36:47 <jfischoff> shachaf: did you see the paste? http://hpaste.org/80091
20:37:05 <JoeyA> tmanny: Added in 7.6.1
20:37:08 <Kinros> What does "letbinding = let x = 42 in x" mean in Haskell?
20:37:18 <jfischoff> I can write the maxent function in a way that compiles but then I can't use it :p
20:37:25 <shachaf> It means "letbinding = 42"
20:38:13 <Kinros> What does that mean, shachaf
20:38:24 <croikle>  letbinding = (let x = 42 in x)
20:38:43 <croikle> to compute (let x = 42 in x), let x = 42 and return x
20:38:56 <tmanny> thanks. hoogle needs updating too it seems. :)
20:39:01 <lispy> When I started Haskelling you could conceivably read all the ICFP papers and learn all the libraries. I don't know if that's still possible.
20:39:31 <lispy> In theory I could, but in practice I have to go to work, relax in the evenings, and also live my life :)
20:39:38 <Kinros> croikle: what does the "in x" do?
20:39:52 <lispy> It's amazing how fast the community has grown in the last few years
20:40:08 <nexx> Does somebody know why WinGHCi fails to start with "CreateGHCiProcess failed with failed with error 5: Access is denied."? GHCi starts normal.
20:40:21 <croikle> Kinros: it means x is the final expression
20:40:31 <croikle> > let x = 42 in x+x
20:40:32 <lambdabot>   84
20:40:41 <sclv> you can still read the icfp papers
20:40:45 <lispy> nexx: where did you find winghci? isn't that antiquated?
20:40:48 <croikle> > let x=2;y=3 in x + y
20:40:49 <lambdabot>   5
20:40:54 <sclv> but i don't know if you'd want to (read all of them that is)
20:41:06 <sclv> and every year of course there are more papers if you want to catch up
20:41:37 <lispy> sclv: that's a good point. ICFP's growth rate (number of papers) is pretty much flat
20:41:56 <tmanny> WinGHCI is part of haskell platform for windows. it is a gui version of ghci more or less
20:41:59 <lispy> ICFP was how many of the original haskell libraries got documented.
20:42:00 <nexx> Haskell Platform 2012.2.0.0.
20:42:10 <Kinros> croikle: I... better example?
20:43:37 <shachaf> Kinros: Do you have any introduction to Haskell that you're reading?
20:43:38 <croikle> it's basically binding temporary variables
20:43:39 <Kinros> croikle: i'm not sure i like all the functional definitinos they do, reminds me a lot of mathematica - and mathematica does it right because they run patterns on their functions... javascript doesn't
20:43:50 <shachaf> Kinros: They usually explain this, along with a bunch of relevant background.
20:44:17 <Kinros> croikle:  that is rather wieldy
20:46:13 <tmanny> nexx: it looks like adding C:\Program Files\Haskell Platform\...\bin\  directory to your path should fix the problem
20:47:46 <lispy> edwardk: that part around an hour and 23 minutes were you realized the MR was active...pretty epic
20:51:49 <Kinros> http://fay-lang.org/
20:51:50 <nexx> My god, clisp replaced path variable instead of adding to it /o\ Thanks tmanny
20:51:58 <Kinros> (Fay$$mult)((x))(_(x));... i'm looking at that.and it's.. weird.just syntatically
20:52:09 <Kinros> i don't get the purpose of (Fay$$mult) here... did they redefine how arguments are passed in functions?
20:52:12 <tmanny> nexx welcome
20:53:27 <ivanm> Kinros: I believe chrisdone has covered the design decisions for things like that on his blog
20:54:02 <Kinros> because it looks like they do_(function)(_arg1)(_arg2)and so on 
20:54:28 <Kinros> did they redefine how arguments are passed in functions in fay ?o.O because it looks like they do_(function)(_arg1)(_arg2)and so on
20:55:03 <simpson> JoeyA: Yeah, that's a pretty good non-answer.
20:55:44 <croikle> probably to allow for partial application?
20:57:11 <shapr> :-( Test/QuickCheck/All.hs:111:22: Template Haskell splice illegal in a stage-1 compiler
20:59:07 <JoeyA> simpson: What's the layer directly above the API?
21:00:06 <adnam> Kinros croikle: yes it's for partial application, _ is force
21:01:24 <donri> Kinros: it's how functions with multiple arguments are defined in haskell: as functions returning functions
21:01:36 <adnam> here's the definition: http://hpaste.org/80094
21:01:36 <edwardk> lispy: heh
21:01:37 <Kinros> adnam: what do you mean force?
21:02:19 <jfischoff> shachaf: okay I figured out how I need to work with rank2types
21:02:46 <jfischoff> shachaf: it seems like all my intermediate values just needed explicit types
21:02:47 <donri> Kinros: force evaluation. haskell is "lazy" (non-strict)
21:02:55 <shachaf> jfischoff: It happens with rank-2 types. :-)
21:02:59 <adnam> Kinros: $ is delay which produces a value/thunk but doesn't evaluate it, then you use _ to force the evaluation
21:03:34 <donri> Kinros: fay isn't just translating haskell *syntax* to javascript but also haskell *semantics*
21:03:40 <shachaf> Kinros: You should probably learn Haskell before looking at Fay-generated code.
21:03:47 <hpaste> “Jonathan Fischoff” annotated “More higher rank type issues” with “More higher rank type issues (annotation)” at http://hpaste.org/80091#a80095
21:06:09 <simpson> JoeyA: I'm mostly coding towards my own ends, so I guess I shouldn't worry too much.
21:10:44 <lispy> edwardk: despite all my years of haskelling, I still don't know when a type error is caused by the MR :)
21:13:06 <jozefg> edwardk: Did you consider putting the code up from the video in a little github repo?
21:13:08 <ivanm> lispy: when enabling the NMMR pragma fixes it! :p
21:13:36 <edwardk> jozefg: the slides are there. the code from the video is basically stuff from the repository ;)
21:13:46 * lispy was about to say that
21:14:01 <lispy> edwardk: this talk is really long. I keep taking breaks so that I will absorb it all.
21:14:06 <lispy> edwardk: It's good content though.
21:14:08 <ivanm> edwardk: finally got around to watching it the other day myself; apart from dealing with Text, ByteString, etc. how is the performance of lens?
21:14:27 <jozefg> lispy: I keep running to ghci to go figure out these types haha
21:14:42 <elliott> ivanm: normal use of lens generates excellent Core, generally
21:14:50 <ivanm> elliott: *nod*
21:15:00 <elliott> we have a lot of inlines and even some unsafeCoerces to work around a GHC optimiser infelicity
21:15:04 <lispy> edwardk: I really need to look at uniplate (probably the lens version). I've been doing some AST transformations at work and I'd always love to have a better abstraction than what I'm doing now.
21:15:08 <elliott> ideally the lens combinators just get "optimised away"
21:15:08 <edwardk> lispy: yeah i kept trying to figure out a way i could do a shorter presentation and get through the content and finally gave in and said its going to be a 2 hour talk
21:15:09 <ivanm> edwardk: is the choice of ordering of the type variables "s t a b" just for the pronounciation?
21:15:15 <edwardk> as it is i don't get to cover the template haskell bits at all
21:15:21 <ivanm> I'm guessing s == source, t == target
21:15:36 <edwardk> ivanm: no, it winds up so that a -> f b   from traversal matches the 'a' and 'b' from the lens/traversal type
21:15:44 <kfish> a = aaaargh, b == bleeding!
21:15:52 <edwardk> and that 's' matches the 's' in state when you look at (%=)
21:15:55 <edwardk> :t (%=)
21:15:57 <lambdabot> MonadState s m => Setting s s a b -> (a -> b) -> m ()
21:16:10 <elliott> s stands for sigma and t for teapot. they're from category theory.
21:16:16 <tmanny> should I use threadDelay 1 to avoid busy loop?
21:16:40 <kfish> tmanny, what kind of busy loop do you have and what problem is it causing?
21:16:41 <edwardk> ivanm: i used to just use 'a b c d' then shachaf convinced me to switch
21:16:54 <edwardk> notably by volunteering to do several thousand lines worth of edits
21:16:57 <lispy> tmanny: it really depends, but yes that will give you a sort of 'yield'
21:17:13 <donri> i liked the a b ta tb variant
21:17:22 <donri> or whatever that was
21:17:31 <lispy> tmanny: hmmm..on second thought, that will make a haskell thread delay, but that doesn't necessarily mean the rts yields to other processes
21:17:47 <ivanm> edwardk: switch just for the "stab" aspect?
21:17:47 <edwardk> donri: i'm not a fan since many of the examples we have aren't 'functor'-like at all
21:18:02 <donri> ah ok
21:18:24 <shachaf> ivanm: I mainly cared about "a" and "b" coming at the end.
21:18:32 <ivanm> shachaf: why is that?
21:18:33 <donri> b d a b
21:18:36 <shachaf> @ty mapM
21:18:38 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
21:18:38 <edwardk> ivanm: no the reason he sold me was the fact that as 'a b c d' the end user had to alpha rename c to a, d to b   and then reassign a to (f a)   and b to (f b) all in his head to get through the first version of the talk i did
21:18:41 <shachaf> ivanm: It matches mapM
21:18:42 <donri> uh c d
21:18:49 <lispy> edwardk: are you familiar with the ATerm library on hackage at all?
21:18:56 <ivanm> shachaf: ahhhh
21:19:00 <edwardk> this way they can get away without having to alpha rename variables out of their way in their heads
21:19:02 <edwardk> ATerm?
21:19:18 * ivanm sighs
21:19:30 <shachaf> edwardk: It used to be called Terming
21:19:36 <ivanm> I'm starting to think I need to cut functionality from my graphviz library just so that it compiles faster... :p
21:19:38 * elliott is pretty sure shachaf is just in it for the stabs
21:19:47 <edwardk> haven't seen it before
21:20:14 * shachaf was just making a lens joke there.
21:20:19 <lispy> edwardk: imagine a term type like data ATerm = Appl String [ATerm] | Int Int | String String, basically generic terms of something like uniterpreted functions
21:20:32 <edwardk> *nods*
21:20:39 <beaky> is Haskell a nice language for going through SICP?
21:20:57 <elliott> no
21:21:18 <beaky> it has nicer syntax than Scheme for the earlier chapters, but I don't know about how the later chapters (implementing a logic-programming DSL and writing a Scheme interpreter/compiler) will be done
21:21:22 <lispy> edwardk: if I wanted to use uniplate for this and do rewriting on an ATerm, would I be able to specify a matcher that looked at the String inside the Appl instead of treating all Appls the same?
21:21:49 <dolio> Writing a scheme interpreter shouldn't be that difficult.
21:21:59 <lispy> 48 hour scheme
21:22:01 <dolio> Except you'll probably have to write a parser.
21:22:04 <beaky> yeah
21:22:16 <donri> beaky: i think scheme is great for something like sicp because it focuses on procedural semantics over syntax
21:22:43 <edwardk> lispy: sure. rewrite $ \xs  -> case xs of Appl "Foo" ys -> Just (…); _ -> Nothing
21:22:49 <beaky> donri: right. I like how SICP and the course behind it focuses on basic programming ideas rather than language syntax
21:23:35 <lispy> edwardk: okay. That's good to know. When I glanced at some of the generic programming stuff before I thought it had to be either type or constructor directed and stopped looking at it since I have these obnoxious overly generic data types
21:24:08 <adnam> though it gets confusing when you're writing scheme code generating your custom scheme's macros etc :)
21:24:12 <edwardk> lispy: you don't even need 'Data' for the uniplate code in lens, just define a traversal to find say immediate sub-expressions in your expressions
21:24:17 <lispy> edwardk: In practice I'm approaching the problem from two different fronts. I'm trying to make the ATerm stuff work as a bandaid but also working with someone else to generate the proper Haskell ADTs from a specification of the language.
21:24:42 <edwardk> https://github.com/ekmett/lens/blob/master/examples/Plates.hs   shows a hand-written Plated instance
21:24:51 <lispy> the code generator is written in prolog, so I'm not very good at improving it
21:25:08 <dolio> Some of the example problems in SICP may not make sense in Haskell.
21:25:12 <beaky> most beginner programming courses I've seen just focus on details of a particular programming language. 'This is a for-loop', 'that is function overloading', etc, while SICP examines those constructs in depth and makes you implement those constructs.
21:25:53 <beaky> dolio: right; some of the beginning exercises I have seen are about how Scheme does things (the applicative vs. lazy evaluation)
21:25:55 <lispy> edwardk: thanks
21:25:56 <dolio> I think there are sometimes examples where half the content of the problem is dealing with the fact that in Scheme, people don't have algebraic data types, but instead build things out of cons pairs by convention.
21:26:58 <beaky> yes Haskell makes that part so much clearer
21:26:58 <dolio> So 50% of the problem in those cases is automatically solved or doesn't make sense.
21:27:21 <lispy> edwardk: it's a bit painful because the language I need an AST for is fortran...so a huge clunky definition with weird extras
21:28:19 <edwardk> lispy: you may want to check some of the code in Language.Haskell.TH.Lens -- there i generate traversals for doing alpha renaming on template-haskell, etc.
21:28:48 <tmanny> kfish, lispy I have a producer thread that puts a value into MVar every time it changes, and a consumer thread that fetches the value. is this idiomatic haskell producer/consumder code?
21:29:39 <tmanny> here is t link. http://hpaste.org/80096
21:29:43 <shachaf> tmanny: Everything people told you about MVars before still holds.
21:29:46 <tmanny> the*
21:30:03 <tmanny> shachaf: I know. I am using it properly this time
21:30:54 <shachaf> tmanny: Probably the "right" way to do this in Windows would be to wait for a mouse move event?
21:31:04 <lispy> edwardk: will do, that's in the lens repo on github?
21:31:19 <edwardk> lispy: yeah
21:31:36 <lispy> tmanny: are you an experienced haskell programmer?
21:31:55 <JoeyA> threadDelay 1 would be one helluva busy loop
21:32:01 <tmanny> shachaf: sure. but I am just doing this to get my feet wet with haskell threads
21:32:13 <JoeyA> threadDelay by itself has at least 1 microsecond of overhead, I suspect
21:32:35 <tmanny> lispy: no, I have been learning it for few weeks
21:32:37 <randomclown> @pl \x -> g (f x) (h x)
21:32:37 <lambdabot> liftM2 g f h
21:32:38 <shachaf> OK, but a busy loop in a Haskell thread is still going to be a busy loop. :-)
21:32:52 <JoeyA> And if it's Windows, the underlying wait function only has millisecond precision.
21:32:55 <shachaf> You can use Haskell threads and "wait for events" together quite well.
21:32:59 <JoeyA> So it might get rounded down to 0.
21:33:19 <pnielsen> threadDelay 1 = delay 1 microsecond
21:33:55 <pnielsen> probably not what you want, tmanny
21:34:10 <shachaf> I assume tmanny knows because their previous paste had threadDelay 1000000
21:34:11 <tmanny> pnielsen: yeah. but it was long enough to drop CPU usage from 50% to close to 0%
21:34:21 <lispy> tmanny: you can put values in an MVar to communicate them between two threads, but there are some caveats. One is that Haskell makes it easy to put a not-yet-evaluated thing in an MVar. Whether you want to do that or store something that has been fully (or partially) evaluated matters for performance. Long story short, if you want to learn haskell I wouldn't start with threads/MVars.
21:35:49 <lispy> tmanny: on the other hand, depending on what you want to do with the threads/mvars there are other librarys on hackage that may be an easier place to start. Orc and STM are both different ways to do this kind of thing.
21:37:03 <lispy> (I don't want to discourage you completely from threads/MVars but I hope you understand they are not typical beginner material :)
21:37:49 <Nereid> but we have strict MVars too
21:38:38 <Nereid> but yeah, concurrency stuff is probably something to hold off on if you're a beginner.
21:38:58 <Nereid> well.
21:39:03 <Nereid> you can if you want.
21:39:08 <lispy> edwardk: This probably already occurred to you, but since delimited continuations and zippers are dual, you could do something with del cont in your lens library :)
21:39:41 <JoeyA> I wouldn't worry about unevaluated values in an MVar this early on.  Seeing it in real life (a stack overflow) is more educational.
21:39:55 <edwardk> lispy: if you spend enough time with it, you'll find that lenses and Cont have a lot to do with one another. shachaf has a nice little example of the holey monoid stuff written cps'd like lens
21:40:55 <mikeplus64> Nereid: huh, never knew MVars were lazy. what is haskell's "strict MVar"?
21:41:17 <JoeyA> I don't think a strict MVar exists... unless someone has implemented it as a library.
21:41:17 <elliott> you can just seq things into an mvar
21:41:19 <mikeplus64> just x `seq` newMVar x or something less boring?
21:41:21 <JoeyA> Right
21:41:25 <elliott> evaluate x >>= newMVar
21:41:25 <Nereid> mikeplus64: strict-concurrent package
21:41:27 <elliott> subtly different
21:41:30 <Nereid> strict-concurrency
21:41:37 <mikeplus64> Nereid: i'll take a look
21:41:42 <mikeplus64> @hackage strict-concurrency
21:41:42 <lambdabot> http://hackage.haskell.org/package/strict-concurrency
21:42:36 <Nereid> ah it uses deepseq
21:43:03 <kennyd> is MVar intentionally lazy?
21:44:58 <Kinros> donri but javascript doesn't have that sort of shityou have to define thatfay isn't just translating, but also a javascript framework on top of it allllll
21:45:02 <JoeyA> Let me answer that by asking you this: is the a in [a] intentionally lazy?
21:45:15 <shachaf> edwardk: That doesn't actually fit into the lens pattern, though, does it?
21:45:17 <JoeyA> > length [undefined, undefined]
21:45:19 <lambdabot>   2
21:45:19 <shachaf> As in (p a b -> p s t)
21:45:36 <shachaf> And the CPSing gives you the same issues as DLists where the type is "too big"
21:45:42 <shachaf> (On the other hand Cont gives you that too.)
21:45:46 <vince-> what is a good IRC library?  I see fastirc, irc,  possibly others
21:45:55 <edwardk> shachaf: correct
21:46:42 <shachaf> The (.)-composition is still nice.
22:00:03 <donri> vince-: depends what you're doing
22:01:04 <donri> vince-: in the future, fastirc might get rewritten into something using netwire frp which is potentially real nice. for now, if you're writing an irc bot, ircbot is a useful package
22:01:27 <donri> mm_freak_: canhas fastirc?? dowant!
22:15:19 <slack1256> where can I look more lazy idioms?
22:15:34 <slack1256> the trick of dynamic programming with lazy array is cool, where should i look?
22:15:39 <slack1256> functional pearls?
22:22:21 <kfish> Nereid, thanks for the link to strict-concurrency; i've just been looking at it and the C.C.Chan.Strict looks like an old copy of C.C.Chan (from before the exception masking was added), but with a couple of $!/seq thrown in
22:22:36 <kfish> Nereid, do you know if that package is still maintained?
22:22:43 <Nereid> nope
22:23:29 <kfish> ok, the strict MVar part looks interesting (and it makes the seq calls in Chan.Strict redundant anyway ;)
22:25:21 <vince-> donri thanks
22:25:38 <vince-> is there a way to do this without a lambda?  map (\(f, s) -> (map toUpper f, s)) list
22:26:16 <vince-> (and without list comprehensions)
22:26:42 <shachaf> @pl map (\(f, s) -> (map toUpper f, s)) list
22:26:42 <lambdabot> map (first (map toUpper)) list
22:27:00 <slack1256> @pl map (\(f,s) -> (map toUpperf ,s)) list
22:27:00 <lambdabot> map ((,) (map toUpperf) . snd) list
22:27:58 <slack1256> although vince, sometimes lambdas are readablER than the alternative (as in this case IMO)
22:28:21 <vince-> yeah
22:28:45 <shachaf> over (mapped._1.mapped) toUpper list
22:28:47 <shachaf> (With lens)
22:29:40 <Nereid> I'm going to look at netwire now.
22:30:10 <vince-> haven't goten to lens yet but that looks interesting.  [(map toUpper f, s) | (f, s) <- list] is not bad either, possibly more readable than map + lambda
22:30:13 <lispy> slack1256: 'the trick of dynamic programming with lazy array' Do you mean, tying the knot?
22:30:24 <lispy> slack1256: if so, the haskellwiki has examples
22:30:36 <slack1256> shachaf: that looks cool
22:31:00 <slack1256> lispy: the trick of dynamic programming with lazy arrays apparently has no relation with tying the knot
22:31:17 <slack1256> but tying the knot is the kind of things I am looking for
22:31:39 <slack1256> trick where you use the semantic power of non-strict programming
22:33:51 <vince-> is it possible to define implicit conversions between types?
22:34:26 <mauke> no implicit conversions in haskell
22:34:32 <slack1256> for strings maybe
22:34:45 <mauke> all you get is polymorphic constants
22:35:05 <shachaf> mauke: Lenses get implicitly converted to traversals. What now?!
22:36:30 <mauke> I don't know how lenses work but they're either polymorphic values or lenses/traversals are type synonyms/specializations
22:37:02 <roconnor> a lens is a polymorphic constant
22:37:08 <mauke> an example of the latter: "strings get implicitly converted to lists"
22:37:21 <shachaf> Yes, they're polymorphic.
22:37:39 <mauke> it's printf all over again!
22:37:44 <shachaf> It's like fmap :: Functor f => ... turning into fmap :: Applicative f => ...
22:39:18 <tmanny> mauke: meaning lenses can cause runtime errors, or?
22:39:20 <edwardk> mauke: lens sneakily abuses the subtyping relationship that haskell does have (between classes) to get subtyping between the different lens types
22:39:25 <edwardk> tmanny: no
22:39:28 <mauke> tmanny: huh?
22:39:57 <roconnor> but really a lens isn't converted to a traversal implicity, rather a lens *is* a traversal
22:39:58 <tmanny> mauke: "printf all over again". thought that's what you meant
22:40:27 <mauke> tmanny: no, printf manages to accept a variable number of arguments by returning a polymorphic value
22:40:34 <mauke> which can be instantiated to a function type
22:40:52 <mauke> this is somewhat orthogonal to the runtime format string check stuff
22:41:55 * lispy wonders if everyone is talking about the same printf (we're all talking about Haskell's printf I hope)
22:42:08 <shachaf> lispy: I don't know about you. I'm talking about Text.Printf.Mauke.
22:42:38 <slack1256> mauke has his own module?
22:42:40 <slack1256> cool
22:43:09 <mauke> Text.Printf/Text.Printf.Mauke are equivalent for the purposes of this discussion
22:43:14 <shachaf> mauke: Feature request: %n in Text.Printf.Mauke
22:43:24 <mauke> shachaf: don't give me ideas
22:43:40 <lispy> mauke: how is your printf different than the older one?
22:44:07 <mauke> fixes a few bugs, adds features like %b and the v flag
22:45:17 <elliott> what's %n again?
22:45:40 <mauke> take pointer to int; store in it number of characters written so far
22:45:46 <elliott> mmm
22:45:57 <mauke> great for exploiting format string injections
22:47:35 <beaky> hello
22:49:14 <lispy> heya
22:49:44 * hackagebot sbv 2.9 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-2.9 (LeventErkok)
22:49:46 * hackagebot maxent 0.1.0.0 - Compute Maximum Entropy Distrubtions  http://hackage.haskell.org/package/maxent-0.1.0.0 (JonathanFischoff)
22:49:47 <lispy> > printf "%d" 1.2
22:49:48 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:49:48 <lambdabot>    (GHC.Show.Show a0)
22:49:48 <lambdabot>     ...
22:50:14 <mauke> :: String
22:50:23 <tmanny> mauke: how come %_ flag isnt using show to be more generic?
22:50:34 <lispy> > printf "%f" 1.2 :: String
22:50:35 <lambdabot>   "1.2"
22:51:13 <mauke> tmanny: how would it do that?
22:51:23 <mauke> also that is a bug in printf
22:51:37 <mauke> "%f" 1.2 is supposed to result in "1.200000"
22:51:53 <mauke> I don't remember whether my version actually does this
22:53:12 <shachaf> @let now m k d = k (\m' -> d (m <> m')); later f k d a = k (\m' -> d (f a <> m')); run l = l ($ mempty) id
22:53:14 <lambdabot>  Defined.
22:53:18 <shachaf> > run (now "x = " . later show . now ", y = " . later show) 3 5
22:53:20 <lambdabot>   "x = 3, y = 5"
22:53:41 <shachaf> Completely type-safe!
22:53:53 <mauke> yes, but useless
22:53:58 <tmanny> mauke: I dont know, I dont understand how it is implemented. is a flag tha uses show not possible?
22:54:44 * hackagebot basic-prelude 0.3.2.0 - An enhanced core prelude; a common foundation for alternate preludes.  http://hackage.haskell.org/package/basic-prelude-0.3.2.0 (MichaelSnoyman)
22:54:46 <mauke> tmanny: using show is not the problem; the trick is to accept argument types without having format string information at compile time
22:54:46 * hackagebot classy-prelude 0.4.3 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.4.3 (MichaelSnoyman)
22:54:55 <mauke> there's a PrintfArg class
22:55:15 <mauke> you can't do 'instance Show a => PrintfArg a where ...'
22:55:22 <mauke> well, you can, but it won't do anything useful
22:55:24 <lispy> typeclass-based prelude sounds like the wrong direction for a prelude rewrite
22:57:54 <AfC> I rather like the look of basic-prelude, though
22:59:08 <shachaf> lispy: It is.
22:59:48 * hackagebot classy-prelude-conduit 0.4.3 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.4.3 (MichaelSnoyman)
22:59:50 * hackagebot classy-prelude-yesod 0.1.0.0 - Provide a classy prelude including common Yesod functionality.  http://hackage.haskell.org/package/classy-prelude-yesod-0.1.0.0 (MichaelSnoyman)
22:59:52 * hackagebot persistent 1.1.3.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.1.3.2 (MichaelSnoyman)
22:59:54 * hackagebot persistent-mongoDB 1.1.5.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.1.5.1 (MichaelSnoyman)
22:59:56 * hackagebot persistent-template 1.1.2.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.1.2.1 (MichaelSnoyman)
23:00:12 <lispy> upload all the packages!
23:01:38 <ivanm> lispy: if snoyman is uploading all of them, then I would have expected a lot more out of hackagebot than that...
23:04:58 * hackagebot yaml 0.8.2 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.2 (MichaelSnoyman)
23:05:00 * hackagebot linearEqSolver 1.2 - Use SMT solvers to solve linear systems over integers and rationals  http://hackage.haskell.org/package/linearEqSolver-1.2 (LeventErkok)
23:05:04 <mysticc>  I can use '' to lift a type like Int to Name in TH. How do I lift types like Int -> Int. It gives parse error using ''?
23:05:15 <ivanm> ''(Int -> Int) ?
23:05:22 <ivanm> ''((->) Int Int) ?
23:05:45 <mysticc> ivanm: Parse error on (
23:06:05 <ivanm> hmmm
23:06:06 <ivanm> *shrug*
23:06:10 <ivanm> my TH-fu is low
23:06:26 <mysticc> >:t ''Int
23:06:29 <mysticc> >t ''Int
23:06:33 <mysticc> :t ''Int
23:06:34 <lambdabot>     Syntax error on ''Int
23:06:34 <lambdabot>     Perhaps you intended to use -XTemplateHaskell
23:06:50 <ivanm> mysticc: lambdabot doesn't know TH
23:06:57 <mysticc> Can I load that extension on  lambdabot?
23:07:05 <elliott> no
23:09:54 <startling> aw, doctest doesn't let me specify expected return values in hex?
23:10:13 <shachaf> It lets you specify them the same way ghci prints them.
23:10:19 <shachaf> All it does is run ghci
23:10:23 <johnw> why not pass your return value to a function that outputs hex
23:10:34 <Targen_> mysticc: You probably want something like arrowT `appT` conT ''Int `appT` conT ''Int
23:10:44 <startling> shachaf: so it's just a string comparison? dang
23:10:47 <mysticc> Targen_: That looks so messy
23:10:47 <Targen_> But, of course, that’s not precisely a name.
23:11:11 <shachaf> An alternative is to change your ghci printing function.
23:11:24 <Targen_> mysticc: [t|Int -> Int|] may do the trick, but it’s rather less flexible.
23:13:11 <mysticc> Targen_: Huh, I need to change my code then. I needed Name and was using conT internally in a function to convert to TypeQ because it makes easy to use things like ''Int.
23:18:10 <Targen_> mysticc: Indeed, you can’t so simply get a name for an arbitrary type.  You could of course splice a type declaration to a fresh name and then use that.
23:24:45 * hackagebot http-conduit 1.8.6.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.6.1 (MichaelSnoyman)
23:28:19 <startling> > foldr f [1, 2, 3]
23:28:20 <lambdabot>   No instance for (GHC.Show.Show ([a0] -> [t0]))
23:28:20 <lambdabot>    arising from a use of `M7...
23:28:35 <startling> > foldr f 1 [2, 3]
23:28:36 <lambdabot>   Ambiguous type variable `a0' in the constraints:
23:28:37 <lambdabot>    (GHC.Num.Num a0)
23:28:37 <lambdabot>      a...
23:28:40 <startling> blah
23:28:51 <mauke> > foldr f z [2, 3]
23:28:52 <lambdabot>   f 2 (f 3 z)
23:29:19 <startling> oh, that's how you do it
23:34:03 <lispy> > foldr f 1 [2,3] :: Expr
23:34:05 <lambdabot>   f 2 (f 3 1)
23:34:35 <lispy> > foldr f 0 [1 .. 10] :: Expr
23:34:36 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 0)))))))))
23:34:42 <lispy> so many parens...
23:36:55 <sp3ctum> i would call it "lispy", even
23:39:29 <Targen_> Is there some trick to write something like a let binding with the expression before the bindings?  Like where clauses, except it should be an expression, not some special feature of equations.
23:39:49 <Targen_> (or clauses or however they’re called)
23:40:21 <ion> Err… I didn’t quite get what you’re asking.
23:41:16 <Targen_> Something like "let foo in bar", but with bar syntactically before foo.  Like, "in bar let foo".
23:41:40 <Nisstyre-laptop> Targen_: postfix?
23:41:41 <Targen_> Just for readability.
23:41:44 <Nisstyre-laptop> er, prefix
23:41:50 <Targen_> Nisstyre-laptop: Indeed.
23:41:54 <ion> let result = bar; foo = something in result
23:42:12 <Targen_> Oh, hey, that’s a nice way to get it.  Thanks!
23:42:34 <Nisstyre-laptop> bar in foo let a
23:43:21 <mauke> let result = bar where bar = something in result
23:54:46 * hackagebot grammar-combinators 0.2.7 - A parsing library of context-free grammar combinators.  http://hackage.haskell.org/package/grammar-combinators-0.2.7 (DominiqueDevriese)
