00:00:02 <monochrom> oh! it says "dualize intuitionistic logic"
00:00:16 <startling> cmccann: oh right
00:00:56 <cmccann> anyway, dual-intuitionistic logic is a particular flavor of paraconsistent logic
00:01:01 <cmccann> the latter being the better known term
00:01:06 <cmccann> which isn't saying much
00:04:23 <cmccann> cf. http://en.wikipedia.org/wiki/Paraconsistent_logic and http://plato.stanford.edu/entries/logic-paraconsistent/
00:05:05 <simpson> I have a chain of lenses and I'd like to attach two different lenses onto the end, grab the results from both, and feed them into something else. Is there a good combinator for this?
00:05:09 * simpson should probably hpaste
00:05:39 <startling> lots of (.) ?
00:07:46 <shachaf> @ty alongside -- /me guesses randomly
00:07:47 <lambdabot> Functor f => LensLike (Context a b) s t a b -> LensLike (Context a' b') s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
00:07:50 <shachaf> I don't understand, though.
00:08:05 <simpson> That *might* be it. Lemme paste the naive version.
00:10:11 <hpaste> simpson pasted “Yet more lens” at http://hpaste.org/80795
00:10:22 <simpson> Something along these lines.
00:20:19 <sgk284> hey all, quick question. I have a value that I need to be strictly evaluated, so I defined: let strict x = seq x x
00:20:30 <sgk284> but I feel like that fn should already exist, does it?
00:21:07 <shachaf> No, it's useless.
00:21:08 <shachaf> seq x x = x
00:21:09 <simpson> Although alongside *is* pretty nifty.
00:22:18 <monochrom> first you need to understand this. "const True (seq (seq x x) x)" does not evaluate x. adding more seq does not change this.
00:22:45 <pdxleif> johnw: Reminds me a lil of the aim of that Boomerang language: bidirectional transforms on do-dads: http://www.seas.upenn.edu/~harmony/
00:23:54 <sgk284> hmm... so let me be clearer. I need a strict version of iterate, so I defined it as: let iterate' f x =  (x `seq` x) : iterate f (f x)
00:24:15 <sgk284> alternatively: let iterate' f x =  (strict x) : iterate f (f x)
00:24:18 <shachaf> That does nothing.
00:24:28 <sgk284> really? it seems to work
00:24:32 <shachaf> It doesn't.
00:24:53 <shachaf> Maybe you want iterate' f x = x `seq` (x : iterate f (f x)) or something.
00:25:08 <sgk284> shachaf: it works, just double checked
00:25:32 <shachaf> In that case, the same thing with (x) instead of (x `seq` x) also works.
00:25:41 <monochrom> you are not saying how you know. you are not offering it up for scrutiny
00:25:41 <cmccann> it certainly works, in that it will force x to be evaluated whenever x is forced to be evaluated.
00:25:49 <shachaf> Good point.
00:25:56 <sgk284> I'm just calculating: (iterate' fn x) !! 1000000
00:26:00 <shachaf> monochrom and cmccann gave better responses than mine.
00:26:03 <sgk284> without the strict version, I blow the stack
00:26:23 <shachaf> Can you paste some code that fails and some code that doesn't, and make them identical other than this?
00:26:27 <shachaf> Then I can run them and see.
00:26:32 <sgk284> which is why I wrote it the other way... but I'm new to haskell, so if that is wrong, I'd love t learn why
00:27:04 <shachaf> sgk284: monochrom's example is good.
00:27:13 <shachaf> > let x = error "crash" in const 1 (x)
00:27:15 <lambdabot>   1
00:27:16 <shachaf> > let x = error "crash" in const 1 (x `seq` x)
00:27:18 <lambdabot>   1
00:27:22 <shachaf> See? Not forced either way.
00:27:28 <sgk284> sorry about the lack of clarity, let me write a quick sample
00:35:42 <sgk284> shachaf: monochrom: hmm... ya know what, I must have been seeing things earlier. both versions are blowing the stack now.
00:35:47 <sgk284> I was wrong, my bad :)
00:35:57 <sgk284> thanks for clearing up seq for me though
00:36:02 <monochrom> the triumph of the scientific method
00:36:05 <sgk284> lol
00:36:13 <shachaf> i love seq
00:36:15 <shachaf> it is so easy
00:36:25 <sgk284> so, how would one write a strict version of iterate with seq? or is that not possible
00:36:42 <monochrom> it is in the scrollback buffer
00:36:45 <shachaf> sgk284: You could try what I said before.
00:37:11 <shachaf> There are some other alternatives, depending on exactly what kind of strictness you want.
00:38:54 <sgk284> shachaf: that works beautifully, thank you
00:39:58 <epta> I can get set product of 2 lists with `(\l1 l2 → [ [a,b] | a ← l1, b ← l2 ])'. How can I do same thing for list of list? So, `f [[1,2] [10,20,30]]' should be [[1,10],[1,20],[1,30],[2,10],[2,20],[2,30]]
00:40:21 <shachaf> > sequence [[1,2], [10,20,30]]
00:40:22 <lambdabot>   [[1,10],[1,20],[1,30],[2,10],[2,20],[2,30]]
00:41:13 <epta> Nice
00:43:36 <epta> It maybe sounds rude, but how can sequence be similated in python?
00:43:52 <simpson> epta: itertools.product()
00:44:23 <simpson> >>> from itertools import product; list(product([1,2],[10,20,30]))
00:44:25 <simpson> [(1, 10), (1, 20), (1, 30), (2, 10), (2, 20), (2, 30)]
00:44:29 <simpson> Also ask #python next time. :3
00:44:34 <epta> Ok
00:47:16 <frerich> <grin style="mr-burns">Excellent, both my Haskell books have been borrowed by different colleagues and one of them started a Yesod project which I can see in our internal Git server; my Haskell propaganda is showing an effect.</grin>
00:50:20 <kamatsu> so, Haskell highlighting in Vim is terrible
00:50:46 <fmap> ?
00:50:56 <kamatsu> sublime text and similar have much better highlighters, which can highlight type constructors, data constructors etc.
00:51:46 <kamatsu> has anyone made a solid highlighter for vim?
00:52:07 <bitonic> vim doesn’t highlight type/data constructors?
00:52:16 <kamatsu> nope
00:52:18 <bitonic> or do you mean that it doesn’t highlight them differently?
00:52:27 <kamatsu> well, they're just white
00:52:45 <simpson> Fortunately, theyr'e also capitalized. :3
00:52:46 <kamatsu> like ordinary text
00:52:55 * simpson can't spell tonight
00:53:00 <kamatsu> yeah, but i'd like to colorise them too
00:53:02 <bitonic> kamatsu: that’s peculiar.  you can always use emacs.
00:53:19 <kamatsu> or i can use a real editor, bitonic
00:53:23 <bitonic> eh eh.
00:53:53 <kamatsu> there's no reason why the highlighting is bad, it's just that it is, and no one has done anything about it
00:54:04 <kamatsu> which I find strange, because there are a number of vim-using haskellers
00:54:22 <simpson> kamatsu: Well, saying that vim is not a real editor is a bit harsh. Maybe you are looking for more of an IDE though.
00:54:31 <kamatsu> simpson: I was referring to emacs
00:54:46 <kamatsu> emacs is more of an editor framework than an editor
00:55:07 <kamatsu> i'm not looking for an IDE
00:55:30 <kamatsu> i'm just looking for something to detect capitalised words in a type signature and highlight them one color, and to detect capitalised words outside a type signature and highlight them another color
00:55:44 <kamatsu> i have no interest in changing editors
00:55:58 <osfameron> you could patch vim's syntax files
00:56:19 <kamatsu> yeah, I may have to, but I find it strange that no one has noticed or corrected this until now
00:56:48 <monochrom> colouring is pretty subjective
00:57:12 <osfameron> and having a capital first letter is already quite distinctive
00:57:28 * osfameron doesn't find syntax highlighting as useful in haskell as in perl/python/javascript
00:57:39 <simpson> kamatsu: There are plenty of non-standard Haskell syntax files for vim that I can find out on the Internets.
00:58:37 <kamatsu> i've been trying them
00:58:43 <kamatsu> most of them are worse, not better.
00:58:50 <simpson> Oh well.
00:59:20 <monochrom> I have a cunning plan. use a monochrome monitor. :)
00:59:34 <simpson> According to syntax/haskell.vim, the maintainer is haskell-cafe.
00:59:41 <monochrom> I heard that the amber ones are best. or were best.
00:59:44 <simpson> So maybe you should email -cafe and complain there. :3
00:59:52 <simpson> monochrom: In terms of eye-hurting, yes.
00:59:55 <monochrom> what?! haskell-cafe?!
01:00:40 <simpson> kamatsu: Also, read syntax/haskell.vim; there's a bunch of toggles you can set in your .vimrc to improve the experience.
01:04:00 <kamatsu> simpson: hm, how do I set those?
01:04:25 <simpson> kamatsu: In .vimrc. For example: let hs_highlight_boolean=1
01:05:08 <simpson> This is definitely enough highlighting for me; it's comparable to the highlighting I get in C and Python.
01:05:44 <mornfall> How do I read files in "modern" GHC? (A way that would get me Strings but not die of "invalid byte sequence"...)
01:05:47 <simpson> I can certainly see how things could get even better, but it'd be difficult since vim doesn't really have the ability to know which capitalized words are types and which are type constructors.
01:06:17 <mornfall> (readFile obviously doesn't work in GHC 7.4...)
01:06:17 <shachaf> mornfall: Read a ByteString, decode with lenientdecode?
01:09:32 <luite> mornfall: mkTextEncoding "UTF-8//IGNORE" >>= hSetEncoding myHandle
01:09:51 <mornfall> luite: I don't really have a handle if I use readFile, do I?
01:10:04 <mornfall> Come on, this is a perl script written in Haskell.
01:10:16 <luite> mornfall: yeah, you open the file first and then do hGetContents
01:10:21 <tdammers> simpson: in theory, one could determine whether something is in the type realm or the values realm using regexes
01:10:42 <tdammers> they would be horrible, horrible regexes though
01:11:33 <luite> mornfall: something like, withFile path ReadMode (\h -> mkTextEncoding  "UTF-8//IGNORE" >>= hSetEncoding h >> hGetContents h)
01:11:41 <simpson> tdammers: That would be pretty unpleasant though.
01:11:47 <simpson> I just shivered thinking about it.
01:11:48 <tdammers> certainly
01:12:16 <tdammers> if I had to do it, I'd probably write something that takes some kind of sane subset of BNF and automatically bakes regexes from that
01:12:43 <tdammers> one nuisance is that you have to keep track of matching parens
01:12:59 <luite> mornfall: though i suspect that will cause a laziness problem with hGetContents
01:13:02 <tdammers> (foo bar baz :: (String -> Integer))
01:13:08 <tdammers> vs.
01:13:28 <tdammers> (\foo bar :: String -> Integer)
01:13:30 <tdammers> or whatever
01:13:47 <mornfall> lenientDecode eats characters
01:14:20 <luite> mornfall: that's the text package though
01:14:28 <mornfall> Yes.
01:14:42 <mreh> what would be the fastest way to get raw pcm out to the speakers with haskell?
01:14:49 <mreh> could I just write to the sound device?
01:14:54 <`nand`> mreh: write to /dev/pcm :P
01:15:08 <mornfall> luite: But I'm parsing a CSV file. And lenientDecode happily eats quotes.
01:15:16 <mornfall> luite: So it's pretty useless.
01:15:34 <mornfall> Lemme try the handle variant.
01:15:38 <luite> that's odd... is the file the wrong format?
01:15:48 <luite> quotes should be valid chars :)
01:15:57 <mornfall> luite: It's just CP-1250 or some other 1-byte encoding.
01:16:01 <mornfall> luite: It's perfectly normal.
01:16:01 <luite> perhaps your locale encoding is wrong
01:16:11 <mornfall> No, my locale is UTF-8 as it should be.
01:16:27 <mornfall> Decoding files based on locale is plain wrong.
01:16:32 <luite> yeah is the text file encoding is different from locale you need to set the encoding
01:16:56 <mornfall> Uh, well, I just want the bytes.
01:17:30 <mornfall> As a String, because that's what the CSV library wants.
01:17:35 <monochrom> openBinaryFile. and use the bytestring version, not the standard version
01:18:05 <luite> mornfall: a string is a list of codepoints, not bytes
01:18:15 <luite> use ByteString or a list of Word8 if you want bytes
01:18:34 <mornfall> luite: Yeah, well, someone forgot to update the hackage.
01:19:30 <monochrom> use hSetEncoding
01:20:50 <mornfall> Actually, I did BSC.unpack <$> BSC.readFile f with BSC = Data.ByteString.Char8 which seems the most concise way to do that.
01:21:14 <luite> Char8 is kind of wrong though
01:22:51 <mornfall> luite: Well, what are the alternatives? Assume that I have to process CSV files with unspecified encoding. They all do have ASCII " and ASCII , as special characters.
01:23:12 <mornfall> luite: And the CSV library only takes a String.
01:23:38 <mornfall> So I guess the answer is, rewrite CSV to use ByteString, upload it to hackage, whatever.
01:24:31 <luite> nah i think that the CSV lib expecting String is correct
01:24:47 <mm_freak> shachaf: more answers to follow, probably…
01:24:51 <mornfall> luite: CSV is a text file without a provision to specify encoding...
01:24:59 <mornfall> luite: So you obviously can't decode it correctly.
01:25:23 <luite> mornfall: unless you know the encoding from the context
01:25:25 <mm_freak> having to log in already pisses me off
01:25:52 <mornfall> And since String is now supposed to be codepoints, you can't convert the file to a String correctly.
01:26:13 <mornfall> luite: Well, if you can, more power to you, but normally you can't.
01:26:30 <mornfall> luite: And the program crashing on a first malformed UTF sequence is just bogus.
01:26:59 <mornfall> I really hate python for doing that.
01:36:33 <Phlogistique> mauke> now you just need to understand 'data' and you're done! <- understanding 'codata' might be useful as well!
01:37:16 <Phlogistique> uhm, OK, this is like 10 days late
01:43:31 <nus> mornfall, have you looked at 'cassava'?
01:45:22 <mornfall> nus: Gosh, all I want is for the script to keep working. That package looks like a minor nuclear plant to me.
01:45:45 <mornfall> And since it works now, I can quit complaining and forget Haskell for a while again.
01:46:14 <jfischoff> is there anything inherently difficult with making a automatic integration system in an analogous way to the automatic differentiation packages?
01:46:43 <jfischoff> you would be building up a polynomial
01:46:53 <snowylike> there is, in fact, something difficult
01:47:05 <jfischoff> what is it?
01:47:11 <snowylike> how do you deal with arbitrarily complex, non-elementary functions?
01:47:48 <snowylike> okay, a bit more serious: read about risch's algorithm
01:47:55 <snowylike> it's the best you can do
01:47:56 <jfischoff> well you are ring were you can take the antiderivative
01:48:01 <jfischoff> so you don't have that
01:48:26 <jfischoff> have you seen beautiful differentiation?
01:48:39 <jfischoff> conal's post?
01:48:54 <snowylike> i don't think so, no
01:49:13 <jfischoff> ad packages don't handle anything
01:49:49 <jfischoff> Just what you can build with primitives
01:49:56 <jfischoff> I'm pretty sure that is always the case
01:50:02 <motiejus> I want to write a small plugin for lambdabot (which listens for github bot and executes a shell command). Is there a way to load the dynamically somehow, i.e. without adding it to lambdabot sources?
01:50:17 <jfischoff> it is possible to load dlls
01:50:29 <jfischoff> look at the plugin stuff that dons has or gabor
01:50:51 <motiejus> where exactly should I look at?
01:50:55 <snowylike> jfischoff: it seems i misunderstood you, by a very large margin
01:50:56 <jfischoff> one sec..
01:51:00 <shachaf> In theory I think it is, and lambdabot was even made as a sort of example.
01:51:03 <shachaf> In practice, good luck.
01:51:10 <motiejus> ;)
01:51:42 <jfischoff> https://github.com/ggreif/dynamic-loader
01:51:51 <jfischoff> moteijus^
01:52:50 <jfischoff> @tell conal is automatic integration impossible, difficult, or uninteresting?
01:52:50 <lambdabot> Consider it noted.
01:53:18 <motiejus> hm. do you know if anyone has done something like this with lambdabot?
01:53:23 <motiejus> (thanks for the link)
01:54:06 <shachaf> Yes, lambdabot was designed for this.
01:54:08 <shachaf> See hs-plugins.
01:54:35 <shachaf> As I said, though, good luck.
02:00:12 <frerich> Hm, is there some GHC warning flag so that it warns me if I accidentally define a function 'foo = foo' instead of 'foo = bar' (which is what I meant to do)?
02:00:53 <shachaf> A flag to warn on recursion?
02:00:57 <shachaf> Or on the special case "x = x"?
02:01:03 <frerich> Only on that special case, of course ;-)
02:01:32 <shachaf> Not in GHC.
02:01:36 <shachaf> Seems oddly special-case to me.
02:01:43 <shachaf> If you want it feel free to propose it, though?
02:02:49 <frerich> Not sure I understand - "feel free to propose it"? I was wondering whether there is some flag to GHC so that it yields a warning like "trivial recursion xyz, did you really mean to do this?"
02:03:06 <shachaf> <shachaf> Not in GHC.
02:03:25 <frerich> What do you mean with "feel free to propose it"?
02:03:39 <srhb> Feel free to ask the GHC devs to add it.
02:03:48 <shachaf> If you want a flag like that, and you think it'd be good, you can make a feature request.
02:03:50 <frerich> Ah
02:03:52 <shachaf> If other people agree it could be added.
02:03:53 <typoclass> frerich: he means you could talk to the ghc folks (via their trac bug tracker or whatever) about developing a flag like that
02:03:54 <mm_freak> frerich: you get a run-time exception for that one though
02:04:00 <shachaf> mm_freak: A useless one.
02:04:06 <shachaf> +RTS -xc makes it useful.
02:04:22 <mm_freak> i've never used -xc
02:04:40 <shachaf> It's more useful than an infinite loop, but not by much.
02:04:42 <typoclass> mm_freak: it's the newish stacktrace thingy, afaik
02:04:57 <mm_freak> ah, the "stack trace"
02:05:16 <shachaf> It'll tell you what thunk was being evaluated when encountering the <<loop>>.
02:05:25 <Saizan> frerich: there's a warning for shadowing variables, which is often correlated
02:05:32 <merk_> is there a built in function for looking up alist by snd?
02:05:52 <mm_freak> merk_: lookup k . map swap
02:06:17 <typoclass> @type lookup
02:06:19 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
02:06:21 <typoclass> merk_: ^^
02:07:03 <merk_> that reverses entire alist on every look up?
02:07:19 <merk_> typoclass: that looks up by fst
02:07:27 <mm_freak> merk_: yeah
02:07:40 <mm_freak> merk_: remember that haskell is lazy
02:07:45 <merk_> I am looking for a 2way association data structure
02:08:07 <mm_freak> merk_: [] is not your friend for association lists
02:08:22 <mm_freak> for two way association you would normally use IxSet
02:09:53 <merk_> ok thanks
02:10:21 <typoclass> merk_: a simple solution could be to have two lists [(a,b)] and [(b,a)], and doing any inserts/deletes on both
02:10:52 <mm_freak> that's slower, more complicated and more memory-heavy than using lookup k . map swap
02:11:24 <merk_> mm_freak: but doesnt that swap all the elements in worst case
02:11:28 <typoclass> mm_freak: right, but he didn't want it to involve map swap
02:11:40 <merk_> on every lookup
02:11:54 <mm_freak> then it's still smarter to just write your own lookup
02:12:15 <mm_freak> fmap fst . find ((== k) . snd)
02:12:40 <mSSM> If I want my program to spit out intermediate results, how would you do that? Simply print / putStrLn.show them? Or should I use something like the Writer monad? But that one is for stuff like log files, right?
02:12:46 <merijn> merk_: Well, yes, but the swap is hardly going to add much overhead to the lookup, I think
02:13:06 <mm_freak> merk_: you're forgetting that haskell is lazy…  it doesn't "do" the swapping…  likely the performance is just the same
02:13:28 <mm_freak> merk_: stop thinking operationally
02:13:40 <mm_freak> think naturally…  haskell is a natural language
02:13:51 <typoclass> mSSM: another option could be Debug.Trace.trace
02:14:30 <mm_freak> mSSM: produce intermediate results as a list…  if your original algorithm is a fold, your new algorithm is a scan
02:14:46 <typoclass> merk_: i'd try the simplest possible thing. you can always make it more complicated later, when profiling has shown it to be a bottleneck
02:15:08 <mm_freak> > foldl' (+) 0 [1..4]
02:15:10 <lambdabot>   10
02:15:13 <mm_freak> > scanl (+) 0 [1..4]
02:15:14 <lambdabot>   [0,1,3,6,10]
02:15:28 <mm_freak> now just consume and do whatever you want with the intermediate results
02:15:39 <mm_freak> to ignore the intermediate results, use 'last'
02:15:45 <tdammers> mSSM: Writer can be used for most anything that requires write-only accumulation of things
02:16:08 <tdammers> logging is a typical example, but that's not the only thing you can use it for
02:16:12 <mm_freak> and i vote against Writer
02:16:29 <mSSM> mm_freak: ok, thank you; I will think about that.
02:16:36 <tdammers> sure, if there is a more elegant solution that doesn't require Writer, then go for that
02:16:50 <mm_freak> there is always an elegant solution without Writer
02:16:56 <merk_> typoclass: yeah, performance wont matter either way
02:17:56 <mSSM> mm_freak: I have trouble "scaling up" simple solutions like using a fold (or a scan) to more complicated structures.
02:18:38 <merk_> is haskell smart enough to transform that map swap lookup into just iterating over the list and checking snd?
02:19:51 <mm_freak> mSSM: well, most algorithms can be turned into streams…  my strategy is:  first generate a stream, perhaps transform it, then consume it…  that allows me to write different kinds of consumers, pure ones to just return a result and heavy IO ones with concurrent progress bars, etc.
02:20:46 <mSSM> mm_freak: For example, what if I don't have a list (where you know the next value in the list), but a chain of successive grids, where each grid (i+1) depends on a probabilistic computation of grid i
02:21:07 <mm_freak> mSSM: that's a tree
02:21:14 <mm_freak> same thing, just with a tree instead of a list
02:21:43 <mm_freak> for every fold, there is also a scan
02:22:00 <mSSM> mm_freak: What I essentially did right now is transform a C solution to Haskell (using a mutable vector).
02:22:22 <mm_freak> foldTree :: (a -> b) -> (b -> b -> b) -> Tree a -> b
02:22:30 <quchen> mSSM: If you want to look inside your program for debugging, use Debug.Trace. Only use this for debugging though, and not for intermediate output relevant to the actual program.
02:22:34 <mm_freak> scanTree :: (a -> b) -> (b -> b -> b) -> Tree a -> Tree b
02:22:48 <mSSM> quchen: it's not for debugging; I actually want the result.
02:23:06 <mm_freak> now where you would normally use foldTree, just use scanTree
02:23:23 <quchen> mSSM: Then Debug.Trace is definitely wrong.
02:24:01 <quchen> mSSM: The Writer monad can be seen as a safe version of Debug.Trace in this case. It's not just for log files (as in text logs).
02:24:21 <mSSM> quchen: ok, thanks
02:24:22 <quchen> For example, I often use it to measure how many function applications a recursive structure does (using the Sum monoid)
02:24:36 <mm_freak> again, i vote against the Writer monad
02:24:40 <bartavelle> is there a base16-bytestring package that works with uppercase hex encoding ?
02:25:23 <mm_freak> don't make your nice declarative solution imperative by using a Writer…  firstly you have to mix algorithm/output logic, secondly your code becomes imperative
02:25:25 <typoclass> quchen: i didn't think of Debug.Trace as very unsafe. i think it's about the most benign use of ceiling cat functions
02:25:48 <tdammers> Writer is nice if for some reason you decide you want to express your algorithm in an imperative way, but personally, I think approaching problems from a functional perspective is usually the better solution
02:25:52 <mSSM> mm_freak: when you said tree, do you mean I should represent my Grid structure as a tree?
02:26:07 <mm_freak> mSSM: no, your solutions
02:26:32 <mm_freak> mSSM: another way is to use a probability monad
02:27:07 <quchen> typoclass: It contains unsafePerformIO and has side effects (as in it prints stuff outside of IO effectively). It won't screw up your program, but that doesn't mean it's good Haskell practice.
02:27:41 <Haskeller> hello :D
02:27:47 <srhb> Haskeller: Hello.
02:27:47 <Nereid> Debug.Trace is good for ... debugging.
02:27:49 <mm_freak> mSSM: you can take inspiration from the monte-carlo package
02:27:53 <quchen> typoclass: from the Debug.Trace haddock: Debug.Trace: Functions for tracing and monitoring execution. These can be useful for investigating bugs or performance problems. They should not be used in production code.
02:28:08 <mSSM> mm_freak: Yeah, I am doing an MC simulation.
02:28:18 <mm_freak> mSSM: but you can define your probability monad more sanely:  newtype Prob a = Prob [(Double, a)]
02:28:20 <quchen> Hello monsieur Haskeller
02:28:53 <Haskeller> hello
02:28:54 <mSSM> mm_freak: What do you mean by probability Monad?
02:28:55 <typoclass> quchen: yes, but how are the hidden side effects going to influence your program if they're only printing stuff to stdout?
02:29:04 <mm_freak> mSSM: at the end you get a list of solutions with their respective probabilities
02:29:04 <mSSM> mm_freak: You are not referring to a generator of random values?
02:29:07 <quchen> mm_freak: That sounds like the monad LYAH constructs in the last monad chapter
02:29:37 <Nereid> http://hackage.haskell.org/package/probability
02:29:49 <quchen> typoclass: unsafePerformIO won't screw up your program internally, but the output depends on evaluation order, so it's nondeterministic.
02:29:50 <mm_freak> mSSM: no, nothing random going on here
02:29:57 <typoclass> quchen: i agree anything with ceiling cat in it is not to be used lightly, but trace is really the least controversial thing among them
02:30:31 <mm_freak> mSSM: do x <- uniform [1..6]; y <- uniform ["heads", "tails"]; return (x, y)
02:30:45 <quchen> typoclass: tace is one of the safer unsafe functions, yeah, maybe.
02:30:59 <mSSM> mm_freak: That sounds like I would get a whole truckload of results.
02:31:10 <mm_freak> mSSM: you get a list of solutions with their probabilities
02:31:25 <quchen> typoclass: However, using trace for general ouptut is like writing everything in IO. In that case I prefer C.
02:33:07 <mm_freak> mSSM: if you define this monad using 'operational' or as a free monad, then you can actually choose what happens…  for the same action you can choose either to simulate or to calculate all solutions
02:35:35 <quchen> Is there some standard function to print to stderr by the way? Can't find one, but it seems to be a pretty natural function
02:35:49 <mm_freak> quchen: hPrint stderr?
02:36:32 <quchen> mm_freak: That works of course, but I thought of something like print' = hPrint stderr or something along the lines
02:36:41 <quchen> like print = hPrint stdout
02:36:53 <mm_freak> quchen: what's the point of that?
02:37:12 <quicksilver> hPrint/print isn't something you use very often anyway.
02:37:36 <quicksilver> much more often you want hPutStrLn and to do your own text formatting (possibly involving use of show)
02:37:53 <quchen> Arguably. In C++ it's quite handy to have cout/cerr.
02:38:17 <mm_freak> and in haskell it's handy to have hPrint stdout and hPrint stderr
02:38:25 <quchen> Alright :-)
02:38:35 <Jaak> and why not just define: printerr = hPrint stderr yourself?
02:39:06 <quchen> Jaak: That's what I'm doing. I just wondered whether I always did that when there's a standard function for it.
02:39:37 <mm_freak> quchen: a sensible program design would actually take the logging function as an argument
02:39:44 <quchen> (Which is kind of how learning Haskell works: reimplement things and then find out they're already in the standard libs)
02:39:47 <mSSM> mm_freak: To hold my hand a little more... You are not talking about the structure of my system (the 'grid')? You don't care that it is a a list, a map, a mutable vector or whatever, right?
02:40:12 <mm_freak> f log = do stuff; log "Done stuff."; stuff2 <* log "Ok, I'm done."
02:40:15 <quchen> mm_freak: So logging can easily be configured to go to some stream?
02:40:21 <mm_freak> f (hPrint stderr)
02:40:22 <mm_freak> yes
02:40:44 <quchen> mm_freak: I often just pipe my output wherever I want it. But I see the point, using the console is a little hacky
02:40:45 <mm_freak> mSSM: right…  i considered Grid as an opaque data type
02:41:26 <mSSM> mm_freak: and so when you talk about the action you mentioned above, what do you mean "choose either to simulate or to calculate all solutions"?
02:41:39 <mm_freak> quchen: often you don't want to use 'hPrint stderr'…  often you rather want something like 'putMVar logVar'
02:41:45 <mSSM> mm_freak: why would I want to have a list of solutions with probabilities?
02:42:45 <mm_freak> mSSM: i didn't say you would want to…  i said it's possible to get a list of solutions…  then you could fold/scan that list
02:42:47 <quchen> mm_freak: As in having a dedicated printing/logging thread? Good point
02:43:39 <mm_freak> quchen: if your program uses concurrency and multiple threads log, then you definitely want that
02:44:12 <mm_freak> quchen: withLogger :: ((forall a. (Show a) -> a -> IO ()) -> IO a) -> IO a
02:44:44 <mm_freak> of course that's equivalent to: withLogger :: ((String -> IO ()) -> IO a) -> IO a
02:44:47 <mm_freak> but it will be more to type
02:44:53 <quchen> mm_freak: Somewhat related: can I run into any problems when multiple threads are writing to the same Chan, and only one thread reads from it? Seems pretty robust to me, but my concurrent programming knowledge isn't very advanced
02:45:45 <mm_freak> quchen: the effect is that you can't in general predict the order in which elements come in
02:45:57 <mm_freak> and in that case you probably want TQueue
02:46:02 <mm_freak> i usually just use MVar
02:46:16 <quchen> Never heard of TQueue :x
02:46:41 <mm_freak> TQueue is TChan for a single reader
02:47:09 <quchen> Well, MVar only works if logging is slow compared to writing. (Which it probably is, but still it feels a little un-haskelly to me.)
02:47:27 <quchen> Ah, T as in STM stuff
02:47:47 <mm_freak> T as in Transactional
02:47:54 <mm_freak> MVar is more sensible in most cases
02:48:18 <mm_freak> it's a channel, but one that gives you some guarantees about speed/memory behavior
02:49:06 <quchen> Weird, Hoogle won't find TQueue, although it's in STM
02:49:46 <mm_freak> you can use an MVar as a shared variable, but the name is misleading…  i never use Chan
02:49:54 <mm_freak> it's too unpredictable
02:50:35 <quchen> mm_freak: I don't understand that. I always saw Chan like an MVar that doesn't lock when it's full.
02:50:51 <quchen> As in something you can write stuff to without worrying about whether it's full or not.
02:51:17 <mm_freak> quchen: you can do the same for MVar, too…  if the logger is congested, you don't get a program running amok with your memory
02:51:59 <quchen> mm_freak: Oh, right. My misconception was if a thread wants to write multiple times to an MVar stuff may be lost. That's not the case of course, as the thread stops until it can write.
02:52:12 <mm_freak> yes
02:52:23 <tdammers> MVar is kind of a one-element queue
02:52:40 <quchen> So do you use chans at all?
02:52:49 <mm_freak> most people do…  i don't
02:53:29 <quchen> Group wants lunch, gotta go. Thanks for the advice though
02:53:35 <quchen> I now like MVars more than before :-)
03:16:02 * hackagebot billboard-parser 1.0.0.0 - A parser for the Billboard chord dataset  http://hackage.haskell.org/package/billboard-parser-1.0.0.0 (BasDeHaas)
03:18:17 <merk_> looking up 500000 element alist by Int takes only 0.03 seconds. what is going on? :)
03:19:35 <shachaf> I think it's one of those things where computers are pretty fast.
03:19:50 <mSSM> What's wrong with this definition: (*) `on` fromIntegral $ (v1*v1) v2
03:19:55 <merk_> not haskell being smart?
03:19:59 <shachaf> If you try a 50000000 alist, does it become 3.00 seconds?
03:20:04 <mSSM> it gives me: cannot mix `on' [infixl 0] and `$' [infixr 0] in the same infix expression
03:20:07 <shachaf> mSSM: It's not a definition.
03:20:20 <shachaf> mSSM: OK, it's that you can't mix `on` and $
03:20:48 <shachaf> What's unclear about the error? Maybe I can clarify.
03:21:00 <fmap> mSSM: how do you expect it to mix infixl 0 and infixr 0?
03:21:14 <mSSM> Ok, I understand the problem
03:21:27 <mSSM> So I need to define myself a new (*')
03:21:29 <hiptobecubic> can lenses filter?
03:21:38 <hiptobecubic> or does that break some law some how
03:21:40 <shachaf> hiptobecubic: Not really. Well, sort of.
03:21:49 <shachaf> Filtering a traversal breaks the law if you change the predicate.
03:22:23 <shachaf> > over (traverse.filtered even) (*10) . over (traverse.filtered even) (+2) $ [1,2,3,4]
03:22:25 <lambdabot>   [1,40,3,60]
03:22:33 <hiptobecubic> so if i have a list of pairs lets say, and i want to filter ((== y) . fst)?
03:22:36 <shachaf> > over (traverse.filtered even) ((*10) . (+2)) $ [1,2,3,4]
03:22:38 <lambdabot>   [1,40,3,60]
03:22:43 <shachaf> > over (traverse.filtered even) (*10) . over (traverse.filtered even) (+1) $ [1,2,3,4]
03:22:44 <lambdabot>   [1,3,3,5]
03:22:46 <shachaf> > over (traverse.filtered even) ((*10) . (+1)) $ [1,2,3,4]
03:22:48 <lambdabot>   [1,30,3,50]
03:22:50 <shachaf> See what's going on there?
03:23:08 <shachaf> You want those two to be the same.
03:23:13 <hiptobecubic> i see
03:23:28 <shachaf> Anyway, in the case of a list you can "cheat" and not traverse at all, just fold.
03:23:28 <typoclass> fmap: maybe i'm missing something, but isn't fixing that error a matter of adding a pair of parens?
03:23:29 <merk_> shachaf: if I increase elements by N lookup time increases aprox by N too
03:24:05 <shachaf> > toListOf (traverse.traverse.filtered even) [[1,2,3],[4,5,6],[7,8,9]]
03:24:07 <lambdabot>   [2,4,6,8]
03:24:15 <fmap> typoclass: it is
03:24:32 <fmap> typoclass: but ghc doesn't know _where_ to add them
03:25:07 <typoclass> fmap: yeah
03:25:09 <hiptobecubic> I'm not understanding the third case of your first example
03:25:26 <hiptobecubic> oh right
03:25:28 <hiptobecubic> no i see
03:25:55 <hiptobecubic> so (even) returns different things in the two invocations
03:27:04 <hiptobecubic> but this isn't anything magical. One obviously does the two things in two loops and the other fuses them
03:27:18 <hiptobecubic> of of course they differ if the predicate changes
03:27:27 <hiptobecubic> why is this a problem
03:29:02 <hiptobecubic> I assume i dropped?
03:29:14 <fmap> what's a problem? not respecting laws?
03:29:47 <hiptobecubic> Did any of what i said get through? ending with "why is this a problem?"
03:29:53 <hiptobecubic> or is that what you are responding to
03:30:07 <fmap> yes
03:30:21 <hiptobecubic> ok sure. Then yes. Or better, why is this a law?
03:30:25 <merk_> mm_freak: and your map . swap is only 3 times slower on first lookup (still only 0.28 for almost 3 million int lookups), and the same as lookup every other time
03:30:32 <merk_> this is pretty awesome
03:31:32 <merk_> is traversing linked list likely being optimized away?
03:31:54 <shachaf> Optimized to what?
03:32:23 <merk_> I dont know, array, big-ass switch :)
03:32:36 <merk_> or if/else chain
03:33:23 <merk_> it seems too fast to include traversing the nodes
03:33:51 <shachaf> Linked lists are like loops.
03:33:51 <fmap> hiptobecubic: well, you generally want Setters act like Functors, so `over l f . over l g == over l (f . g)' is expected to hold
03:34:04 <shachaf> fmap is biased on this matter.
03:36:26 <hiptobecubic> i see
03:39:45 <hiptobecubic> exam time. thanks
03:39:52 <hiptobecubic> not on lenses, unfortunately :(
03:42:10 <mm_freak> merk_: i would expect it not to make any difference…  make sure you compile with -O
03:42:51 <mm_freak> merk_: and again, [] is not your friend
03:43:15 <mm_freak> unless you actually want to traverse a stream of key/value pairs
03:43:23 <merk_> mm_freak: I have. I looked up last element first btw
03:43:37 * merk_ compiled with -O2
03:45:26 <merk_> I just need lookup, but alist is more than efficient enough, I only have few dozen elements. I tested with more just to satisfy my curiosity
03:47:10 <merk_> what happens under the hood with map swap?  I would expect it to swap on every element, until it finds the one I was looking for
03:47:43 <mm_freak> merk_: that's what happens semantically
03:48:14 <mm_freak> merk_: operationally it may actually create a lookup function that compares the snds
03:49:06 <merk_> anyway here is my code
03:51:34 <hpaste> merk pasted “lookupSnd test” at http://hpaste.org/80799
03:54:19 <merk_> text file as first argument, number to look up as second. could have written that smarter (without text files), but oh well
03:54:57 <merk_> i ripped that apart from my actual program
03:56:18 <mm_freak> merk_: for me lookup x . map swap takes exactly as long as lookup k, where (k, x) is the earliest element for both cases
03:56:24 <mm_freak> as expected
03:56:48 <mm_freak> merk_: however, i've written my own version of 'lookup'
03:57:33 <merk_> interesting. not sure why the difference
03:57:45 <hpaste> “Ertugrul Söylemez” pasted “List lookup benchmark” at http://hpaste.org/80800
03:57:54 <mm_freak> merk_: that's my benchmark code
03:58:32 <mm_freak> (0, 18430380765570268684) is the earliest match for both searches, so they both need to traverse the same number of elements
03:58:53 <mm_freak> as expected both traversals need the same amount of time
03:59:07 <merk_> perhaps ghc can optimize more when you hardcode lookup elements?
03:59:32 <mm_freak> merk_: let's see
04:00:50 <mm_freak> merk_: still same running time
04:01:02 <mm_freak> i'm now reading the element from the command line
04:01:05 <mm_freak> using getArgs
04:01:26 <Walther> If I make a infinite list that is built by recursive definition, say, infinite list of fibonacci numbers through recursion, and need nth number in that list for something, and later n+1 th or n-1 th number, does it go through the whole recursive function again or does it store the values by default somewhere?
04:01:29 <mm_freak> again, as expected
04:02:03 <mm_freak> Walther: if you have a CAF, it stores the values
04:02:19 <mm_freak> Walther: a CAF is a top-level value that is not a function
04:02:49 <Walther> uhh
04:02:49 <mm_freak> Walther: in either case you're probably asking for memoization
04:03:19 <mm_freak> one simple way to memoize is to use sharing properly
04:03:36 <merijn> mm_freak: No, he's saying that he's defining the list probably like "fibs = 0 : 1 : zipWith fibs (tail fibs)", which should not be re-evaluated as long as it's in scope, no?
04:03:37 <Walther> what is the default behavior?
04:03:59 <merk_> mm_freak: you have no timing functions in your example. are you measuring program runtime?
04:04:06 <Walther> if there's simply a definition of an infinite list that is defined via a lambda that is recursive
04:04:16 <mm_freak> > let fibs = map fib [0..]; fib 0 = 0; fib 1 = 1; fib n = (fibs !! (n - 2)) + (fibs !! (n - 1)) in fibs
04:04:18 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:04:22 <mm_freak> that uses sharing
04:04:41 <merijn> mm_freak: I think your answer might be overcomplicating things for him
04:04:47 <mm_freak> Walther: while (!!) still traverses the list each time, the individual elements aren't recalculated along the way
04:04:53 <merijn> Walther: Can you pastebin a concrete example of what you have?
04:05:46 <Lethalman> > fix ((0:) . scanl (+) 1)
04:05:46 <mm_freak> merijn: i'm commenting out one and using shell 'time'
04:05:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:06:04 * hackagebot hakyll 4.0.0.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.0.0.0 (JasperVanDerJeugt)
04:06:32 <mm_freak> merk_: that was for you, not for merijn
04:08:02 <Walther> er- a = [x] | x <- (here a recursive fibonacci), sorry, i'm at work, so don't have any code with me
04:08:37 <Walther> and that's horribly wrong, sorry, just a beginner with haskel
04:10:58 <Walther> But if I just simply define an infinite list, with elements of it defined recursively, does it actually calculate all the numbers every time a number is needed
04:11:31 <quchen> Walther: No. In the example given by mm_freak for fibs above, each number in fibs is calculated only once.
04:12:14 <Walther> okay, nice.
04:12:15 <quchen> However, the code example uses (!!), so to get a previously calculated element, it traverses the list again. It doesn't have to re-caulculate values, but still walk all the way to the desired value.
04:12:35 <quchen> Traversing the list is of course very cheap to recalculating it, but it's not free.
04:12:58 <Walther> ah, so it will still have some nasty non-optimum stuff
04:13:07 <Walther> hence requiring some tweaking
04:13:25 <quchen> It's good for smaller lists, but if you're planning to print the first 10^6 fibos it's probably not the best solution.
04:13:58 <quchen> I'm assuming you're asking the general question about memoization and not how to calculate fibo effectively
04:14:42 <Walther> of course, asking how haskell lists operate in general case, when recursive definitions are involved
04:14:53 <Walther> not just efficient fibo :)
04:15:04 <quchen> @src (!!)
04:15:04 <lambdabot> xs     !! n | n < 0 = undefined
04:15:04 <lambdabot> []     !! _         = undefined
04:15:04 <lambdabot> (x:_)  !! 0         = x
04:15:04 <lambdabot> (_:xs) !! n         = xs !! (n-1)
04:15:16 <quchen> As you can see, xs !! n does n recursions
04:15:20 <merijn> Walther: In general, haskell lists are linked lists and as such they behave the same as linked lists in other languages (i.e. indexing the list means traversing all elements up to the index)
04:15:32 <merijn> Walther: How the list is generated is not really relevant
04:15:54 <quchen> So every time you use it, Haskell starts at the first element of a list and walks on until it's at the desired element.
04:16:04 * hackagebot MFlow 0.2.0.5 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.2.0.5 (AlbertoCorona)
04:16:08 <mm_freak> Walther: the point is, it makes a difference whether you define a list or a list /function/
04:16:10 <quchen> (!!) usually means you're giving up finding a better algorithm ;-)
04:16:15 <Walther> merijn: but it surprised me that the recursive definitions however are "stored" and "used" efficiently
04:16:50 <merijn> Walther: Recursive definitions aren't stored, if you define a list as a computation then it won't throw away the list until the result can be garbage collected
04:16:52 <Walther> as in, if you have already calculated nth fibo and n-1 th fibo, to calculate n+1th fibo you don't need to walk through the entire recursion anymore
04:16:58 <Walther> mmh.
04:17:03 <mm_freak> Walther: try "let x = 3^1000000 `mod` 101 in print (x, x)" vs. "print (3^1000000 `mod` 101, 3^1000000 `mod` 101)"
04:17:30 <merijn> Walther: If you define a top level list named "fibs", then the list will be computed "as necessary", but the result won't be garbage collected until the entire list is garbage collected
04:17:33 <mm_freak> in the former case the value will be calculated only once and then shared for the "in" part
04:17:39 * sopvop discovered http://en.wikipedia.org/wiki/Monadology -  First thought - Omg, I've become part of totalitarian cult
04:17:52 <Walther> mm_freak: makes sense
04:17:54 <mm_freak> Walther: the same happens for top level definitions
04:18:07 <mm_freak> 'fibs' is a /list/, not a list /function/
04:18:28 <Walther> okay, nice. Sounds like I should totally be using Haskell for our course of data structures and algorithms :P
04:18:38 <mm_freak> so it's shared within the recursive calls of 'fib' (and actually throughout all of your program)
04:18:48 <mm_freak> yes, you should =)
04:19:07 <Walther> a good excuse to kick my ass to learn haskell, to include it in coursework
04:19:40 <covi> @src mod
04:19:40 <lambdabot> Source not found. Do you think like you type?
04:19:56 <mm_freak> @src Integer mod
04:19:56 <lambdabot> Source not found. That's something I cannot allow to happen.
04:20:01 <mm_freak> @src mod Integer
04:20:01 <lambdabot> Source not found. :(
04:20:03 <covi> mm_freak: why is that calculation so fast? 3^BIG `mod` 101?
04:20:34 <mm_freak> covi: it isn't fast, but it's faster than this:  product (replicate 1000000 3) `mod` 101
04:20:50 <mm_freak> that's because it uses an exponentiation/squaring algorithm
04:21:05 <covi> point me to a link?
04:21:12 <mm_freak> so the running time is logarithmic wrt the size of the exponent
04:21:28 <mm_freak> covi: http://en.wikipedia.org/wiki/Square_and_multiply
04:21:30 <Nereid> although it still gets slow because you're still computing very large Integers
04:22:04 <covi> mm_freak: thx
04:23:26 <mm_freak> covi: the proper method to use here is this:  http://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method
04:23:44 <mm_freak> it's the same algorithm, but applies the modulo operation at every step, not just at the end
04:23:55 <mm_freak> that keeps the numbers small and the multiplications fast
04:24:05 <merk_> mm_freak: I cant figure out what is going on with your program.i exchanged xs and ys, removed map swap, but element is not found
04:24:42 <merk_> I get mem_commit failed, I guess after too many random numbers were generated
04:25:31 <mm_freak> merk_: make sure you spelled it correctly
04:25:36 <mm_freak> the source code i mean
04:25:49 <mm_freak> notice in particular lookup vs. lookup'
04:26:06 <mm_freak> merk_: if you ever get Nothing, you certainly have mistyped it
04:26:24 <merk_> I probably did something stupid, lets see
04:27:50 <merk_> yeah I renamed variable names, and in first lookup there was no swap
04:28:01 <merk_> same runtime in here too
04:29:26 <Nereid> hmm
04:29:27 <Nereid> @let takeBits 0 _ = []; takeBits x (a:as) | r == 0 = takeBits q as | r == 1 = a : takeBits q as where (q,r) = (x `divMod` 2)
04:29:29 <lambdabot>  Defined.
04:29:37 <Nereid> @let squares (*) = iterate (\a -> a*a)
04:29:39 <lambdabot>  Defined.
04:30:06 <Nereid> @let pow e (*) x n | n >= 0 = foldr (*) e . takeBits n $ squares (*) x
04:30:08 <lambdabot>  Defined.
04:30:26 <Nereid> @let mulMod n x y = (x * y) `mod` n
04:30:28 <lambdabot>  Defined.
04:30:33 <Nereid> > pow 1 (mulMod 101) 3 1000000
04:30:36 <lambdabot>   1
04:30:41 <Nereid> duh
04:30:47 <Nereid> phi(101) divides 1000000.
04:31:35 <mm_freak> Nereid: use n = 2^512 - 38117
04:31:45 <mm_freak> then you don't have that problem =)
04:32:15 <Nereid> > pow 1 (mulMod (2^512 - 38117)) 3 1000000
04:32:17 <lambdabot>   100709793737232017059533561005589956249813673882521041349587647569686606973...
04:32:21 <Nereid> bleh
04:32:46 <mm_freak> want a smaller number?  try 2^128 - 15449
04:33:58 <mm_freak> but in that case use 5 as the base, if you want full coverage…  with 2 and 3 you only get half coverage =)
04:34:58 <Walther> I wonder what kind of an algorithm / calculation has the best optimization ratio :P
04:35:09 <Walther> as in, from the "basic" definition, what "compresses" the most
04:35:24 <Walther> in complexity
04:35:33 <mm_freak> i think this particular algorithm is an excellent example
04:36:39 <quchen> Nereid: Wait, you can use (*) as a variable? Oh wow.
04:36:40 <merk_> mm_freak: how come builtin lookup throws stack space overflow?
04:37:09 <Nereid> quchen: sure, why not?
04:37:14 <mm_freak> quchen: up until GHC 7.6 you could also use (>~) as a type variable, but that's gone now =/
04:37:28 <Nereid> yep, no more type operator variables
04:37:41 <merk_> I replaced your lookup' with lookup and got stack overflow
04:37:57 <quchen> Nereid: I never thought about it. I only knew that you can't have ' as first character in a variable, so I never would've thought that fancier stuff would work.
04:38:08 <Nereid> well ' is quite different.
04:38:21 <mm_freak> merk_: that happens when you actually print the result rather than merely determining that it's there…  that's because the snds are defined in a way that each value depends on all previous values
04:38:24 <quchen> ' is kind of a letter in Haskell. If special letters don't work, then (@!!>) shouldn't work either.
04:38:32 <mm_freak> merk_: that builds up a chain of unevaluated thunks
04:38:33 <quchen> That's why I was surprised.
04:38:43 <merk_> ah
04:38:44 <Nereid> well ' is kind of a letter, and * is not a letter, it's a symbol.
04:39:23 <quchen> > let (`foo`) = (+) in 1 `foo` 2
04:39:24 <lambdabot>   <hint>:1:11: parse error on input `)'
04:39:31 <mm_freak> merk_: that's very common actually…  you want to generate lazily and traverse forcibly
04:39:31 <quchen> Oh. :-(
04:39:38 <mm_freak> merk_: that's what i'm doing in the code
04:39:38 <Nereid> well (`foo`) is invalid even in an expression
04:39:40 <Nereid> > pow 1 (*) x 13
04:39:42 <lambdabot>   x * (x * x * (x * x) * (x * x * (x * x) * (x * x * (x * x)) * 1))
04:40:00 <Nereid> no graph of what's shared :(
04:40:15 <Nereid> > takeBits 13 $ squares (*) x
04:40:17 <lambdabot>   [x,x * x * (x * x),x * x * (x * x) * (x * x * (x * x))]
04:40:18 <quchen> Huh? Where did that line come from
04:40:25 <mm_freak> quchen:
04:40:27 <mm_freak> :t x
04:40:29 <lambdabot> Expr
04:40:40 <mm_freak> nothing fancy =)
04:40:47 <mm_freak> > iterate f x
04:40:48 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
04:40:50 <quchen> Looks fancy to me
04:40:56 <Nereid> see the SimpleReflect module.
04:40:57 <quchen> What's Expr? TH stuff?
04:41:01 <quchen> Oh.
04:41:17 <quchen> And somewhere above you've written x :: Expr then?
04:41:22 <merijn> quchen: typeclass magic
04:41:29 <Nereid> lambdabot has it by default.
04:41:38 <mm_freak> quchen: data Expr = Expr :+ Expr | Expr :* Expr | Expr :$ Expr | IntExpr Int | …
04:41:42 <mm_freak> you could have defined that yourself
04:42:22 <quchen> @type x
04:42:23 <lambdabot> Expr
04:42:26 <mm_freak> you know, haskell is great for DSLs
04:42:34 <quchen> Heard of it.
04:42:46 <quchen> Fancy stuff that package
04:42:49 <Nereid> > takeBits 13 [0..]
04:42:51 <lambdabot>   [0,2,3]
04:42:59 <mm_freak> Expr a would be fancier
04:43:23 <merijn> To the phantom type machine!
04:43:32 <mm_freak> not a phatom type
04:43:35 <mm_freak> variable type
04:43:35 <quchen> Aaah, and SimpleReflect.something defines x :: Expr
04:43:40 <mm_freak> data Expr a = App (Expr a) (Expr a) | Var a
04:43:42 <quchen> So that's not automatically done
04:43:52 <mm_freak> that makes Expr a monad
04:44:04 <mm_freak> the leaf substitution monad
04:45:37 <mm_freak> showExpr :: (Show a) => Expr a -> String
04:45:48 <mm_freak> calcExpr :: Expr Void -> Integer
04:46:27 <quchen> @src Expr
04:46:27 <lambdabot> Source not found. You speak an infinite deal of nothing
04:46:30 <quchen> Hm.
04:46:41 <mm_freak> quchen: that's not the Expr from that library
04:47:07 <quchen> What is it then?
04:47:16 <mm_freak> i defined it above
04:47:18 <quchen> How many Exprs are we talking about here?
04:47:20 <quchen> Ooooh.
04:47:57 <quchen> Didn't see when you did that.
04:48:02 <quchen> Got the timestamp?
04:48:03 <mm_freak> have something fancier:  data Expr a = Var a | IntExpr Integer | Expr a :+ Expr a
04:48:51 <quchen> mm_freak: How do you get a custom Show instance for Lambdabot?
04:49:02 <mm_freak> you don't
04:49:20 <quchen> But then why does
04:49:22 <quchen> > x * x
04:49:23 <quchen> work
04:49:23 <lambdabot>   x * x
04:49:38 <quchen> > x * (x * x)
04:49:38 <mm_freak> there is a predefined Show instance for lambdabot's Expr
04:49:39 <lambdabot>   x * (x * x)
04:50:06 <quchen> And Lambdabot's Expr is Simplereflect's Expr?
04:50:21 <mm_freak> apparently, i don't know
04:50:40 <Nereid> it is.
04:50:45 <quchen> And you just overwrote the Expr with a custom implementation, and Lambdabot happily overwrites the type, but doesn't erase instances?
04:50:50 <quchen> That sounds awkward
04:50:53 <Nereid> no one overwrote Expr
04:51:07 <quchen> I thought mm_freak defined his own version
04:51:18 <Nereid> not in lambdabot
04:51:20 <quchen> I am confused.
04:51:43 <merk_> simllereflect looks pretty neat
04:51:48 <merk_> simple
04:52:01 <quchen> Could you point me to the line (i.e. time) where you made all the definitions that made this Expr stuff work?
04:52:24 <Nereid> no one here made anything work.
04:52:58 <Nereid> mm_freak didn't teach lambdabot anything.
04:53:12 <merk_>  > sum [1..5] :: Expr
04:53:22 <quchen> Oh, then I misunderstand 13:46 < mm_freak> quchen: that's not the Expr from that library
04:53:24 <Nereid> space.
04:53:25 <Nereid> > sum [1..5] :: Exp
04:53:27 <lambdabot>   Not in scope: type constructor or class `Exp'
04:53:27 <lambdabot>  Perhaps you meant `Expr' (im...
04:53:31 <Nereid> > sum [1..5] :: Expr
04:53:33 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5
04:53:34 <quchen> 13:47 < mm_freak> i defined it above
04:53:41 <Nereid> he "defined" it informally
04:53:49 <quchen> AAAaaaaaaaaaaaah
04:54:05 <Nereid> :V
04:54:22 <mm_freak> quchen: to define is not computer science terminology ;)
04:54:26 <mm_freak> get away from your C++ thinking =)
04:54:43 <quchen> Oh I'm not thinking C++ anymore
04:54:48 <quchen> Haskell made sure of that
04:55:46 <quchen> So to sum this all up: SimpleReflection defines the Expr type, and Num/... instances of that
04:55:58 <quchen> So it's a DSL for prettyprinting expressions
04:56:21 <Nereid> does it count as a DSL?
04:56:25 <Walther> btw, hoe are the runtimes of decently optimized haskell code versus decently optimized C / C++ code?
04:56:28 <Walther> how*
04:56:29 <mm_freak> sure it does
04:56:39 <Nereid> Walther: quite competitive.
04:56:43 <merijn> Walther: Depends a lot on the kind of code
04:56:48 <Nereid> depends on the code, sure.
04:56:52 <Nereid> but sometimes it's faster.
04:56:57 <mm_freak> Walther: i'm still waiting for a C programmer to outperform my prime search code =)
04:57:06 <quchen> mm_freak: Which one is that?
04:57:10 <merijn> Walther: For IO bound code I would say Haskell is clearly superior to C/C++ in every way
04:57:15 <Doikor> if you have a lot of time and are some kind of a c/c++ you will almost always end up with a faster c/c++ program
04:57:19 <mm_freak> http://hpaste.org/79286
04:57:34 <Doikor> but the time to make you spend to get that sligth advantage most of the time isnt worth it
04:57:45 <mm_freak> Doikor: "almost" means, whenever you're using only a single CPU core
04:58:00 <merijn> Walther: For computation bound code Haskell tends to be anywhere between slightly faster than C to the same speed as Java (i.e. slower than C, but still an order of magnitude or more faster than python/ruby)
04:58:11 <Doikor> mm_freak: c supports threads...
04:58:23 <Doikor> but you have to really, really good to make a good use of them
04:58:24 <quchen> mm_freak: Is Haskell actually faster at doing parallel stuff, or is it just much easier to write good parallel code with it?
04:58:30 <mm_freak> Doikor: but it doesn't support moving computations between threads
04:58:37 <Walther> yeah, that's what i'm mainly thinking about - in terms of multi-core / -thread programming
04:58:40 <merijn> quchen: I would say both in differing amounts, depending on your workload
04:58:50 <Walther> exactly what quchen asked
04:59:00 <merijn> Walther: multithread programming it's no context, haskell is by far better for your sanity for that
04:59:00 <Doikor> mm_freak: anything you can do with haskell you can do with c. the exact same implementation
04:59:06 <Doikor> might take a shit ton of time though.
04:59:07 <mm_freak> Doikor: C is inherently bound to its call stack paradigm…  that makes it weak for parallelization
04:59:09 <companion_cube> mm_freak: that is the job of the kernel
04:59:12 <Doikor> to write all those systems
04:59:14 <merijn> Walther: eh, s/context/contest
04:59:29 <Walther> merijn: in terms of writing and or performance
04:59:34 <quchen> So how true is 13:57 < mm_freak> Doikor: "almost" means, whenever you're using only a single CPU core
04:59:44 <quchen> As in "multicore and Haskell wins"
04:59:45 <merijn> Walther: In terms of writing, in terms of performance, see my previous answer
05:00:11 <mm_freak> Doikor: for example in C when you write "f(); g();", then f returns and the caller calls g…  why doesn't f jump to g directly?  that's what happens in haskell, because there is no call stack
05:00:13 <merijn> Also, note that this only applies up to about 12-ish cores, after that the GC starts to become a real bottleneck in current haskell
05:00:23 <Walther> merijn: Oh?
05:00:46 <Walther> after that C outperforms Haskell, or both slow down?
05:01:19 <Walther> I might be interested in supercomputing, and that has been one among the many reasons why i bear interest in learning haskell
05:01:26 <Doikor> mm_freak: nothing is stopping you from giving a pointer to that function and getting to the same end result.
05:01:28 <merijn> Walther: I'm not saying C magically outperforms Haskell in that scenario, but haskell doesn't scale very well beyond 12 cores, currently. Whether C is faster depends on how good you are at writing C for 12 cores :p
05:01:36 <Walther> heh
05:01:40 <quchen> mm_freak: I don't understand your prime code. In any case, what makes it faster than any C implementation?
05:01:54 <quchen> Simply the parMap?
05:02:01 <quchen> Or is the stuff above also a factor
05:02:04 <merijn> Walther: Having written a runtime for our concurrency management language in both C and Haskell, I can definitely say you should use haskell until profiling says otherwise :p
05:02:28 <mm_freak> quchen: Integer is faster than GMP's mpz_* interface, so you have to write really complicated mpn_* code to match the raw speed, and then you don't have it parallelized yet
05:02:39 <Doikor> your code just might be nearly unreadable and take like 10 times the development time to get it done but it can be done. C is low level enough to do everything
05:02:43 <merijn> Walther: For supercomputing it's really still Fortran, where it's at
05:02:43 <Walther> merijn: yeah, the thing is I've only really programmed java and python, and i've been thinking about whether to learn C or some functional next
05:02:52 <Doikor> if nothing else helps. write your haskell implementation in C and run your code in that
05:02:55 <Doikor> tada. C won.
05:02:57 <Walther> and haskell seems to be winning my prioritizing contest :P
05:03:10 <mm_freak> Doikor: the point is, optimal C code can only be as efficient as optimal haskell code, when you inline every function and never use recursion on the C side
05:03:15 <quchen> mm_freak: I thought Integer is based on a similar lib
05:03:26 <quchen> Wait, it's probably written in Haskell
05:03:29 <merijn> Walther: I would certainly recommend learning both Haskell and C
05:03:32 <mm_freak> quchen: it uses GMP, but not its mpz_* interface
05:03:54 <quchen> Are there multiple bigints in GMP?
05:03:55 <merijn> Walther: And like I said, if you *really* want to do supercomputing you will probably have to learn Fortran too
05:03:58 <Walther> merijn: of course, the more languages the better :P But even then I should totally pick something to learn *well*
05:04:07 <mm_freak> quchen: GHC haskell has lightweight memory management and uses the low level mpn_* interface
05:04:15 <mm_freak> quchen: mpz_* is built on mpn_*
05:04:31 <merijn> Walther: The more I know C, the more I am convinced about 3 people on this planet are capable of writing correct C, the rest is just mucking about
05:04:35 <quchen> Ah, so mpz is easier to use but slower? Something of that sort?
05:04:43 <mm_freak> quchen: yeah
05:05:03 <merijn> Walther: tbh, C is not all that hard to learn. The tricky bits are pointers and that's about it. Once you grok those the rest follows pretty naturally from your Java/Python knowledge
05:05:12 <quchen> And GHC uses the bare stuff of the C library, but in such a way that it's easy as pie to parallelize
05:05:15 <quchen> I see.
05:05:23 <Doikor> mm_freak: except you can manually optimize some cases (lime memory management) for that specific problem better then GHC does.
05:05:38 <Walther> merijn: plus, C is ugly ;)
05:05:43 <Doikor> if you are good enough. and thus most likely get a faster implementation.
05:05:58 <merijn> C is pretty, if you only ever deal with bytes and memory and no IO
05:05:59 <mSSM> `mapM_ (print.(/100).fromIntegral) [0..100]' gives me a nice list of x.dd (2 decimal places), however in my program (where the result of the function mapped over the Ints gives a Double), I get stuff like 2.30000001 ; where does the difference come from?
05:06:03 <Doikor> not that im saying you should write C unless you have some really good reason (kernel/driver work etc.)
05:06:04 <bxc> merijn: way too much fortran. I've got some funding to look at other interesting languages though
05:06:06 <merijn> Also, no multithreading
05:06:14 <merijn> bxc: Chappel?
05:06:23 <bxc> not really sure what i'll look at
05:06:23 <mm_freak> Doikor: that's true, but you can't really get anything better than "tightly packet bit array", which is why my program outperforms naive equivalent C code…  the non-naive, non-parallel variant is really hard to write in C
05:06:29 <Walther> not that it mattered in any way, but imho haskell, python, html, css are way prettier than C written :P
05:06:48 <merijn> bxc: It's a language people at Cray are working on to be the next big thing for HPC
05:06:51 <Lethalman> mSSM, doubles can't represent numbers perfectly
05:07:02 <Lethalman> mSSM, you have to use specific print functions to show only the relevant decimals
05:07:04 <merijn> bxc: So focussed on distributed cluster computation, etc.
05:07:05 <bxc> yeah i know what it is - its been around for ages
05:07:11 <Lethalman> in C it's %g, don't know about haskell
05:07:18 <Doikor> mm_freak: yes its hard but doable. Thats what i said from the start. You can end up with a faster solution in almost every case (some times it might be equal) but its really not worth the work
05:07:22 <bxc> merijn: theres a bunch of languages
05:07:24 <Walther> What are the real caveats / cons of Haskell at the moment? (Try to be honest, every language and compiler has their problems :P )
05:07:28 <Doikor> and the code is going to be almost impossible to understand
05:07:41 <mm_freak> mSSM: if you represent your number as a rational and the exponent is not a power of 2, then there is no exact floating point representation of that number
05:07:49 <Lethalman> Walther, no up-to-date gui libraries (i'm newbie though)
05:07:55 <mm_freak> mSSM: 1/1, 1/2, 1/4, 1/8 are fine
05:08:01 <mm_freak> mSSM: 1/5 and 1/10 are not
05:08:04 <bxc> merijn: in the context of this data storage library i've been contracted to do some dev work on, we've been focused on C and Fortran APIs because thats what everyone writes their stuff in; but theres some "looking forwards to the future..." stuff in that grant
05:08:09 <mm_freak> yes, exactly, the computer can't deal with 0.1 =)
05:08:15 <earthy> Walther: caveat: memory-usage can be hard to predict
05:08:21 <mSSM> mm_freak: But how come the function I gave gives me what I need?
05:08:25 <bxc> merijn: i'd like to look at some more declarative stuff because that fits in with what we were trying to do with the library
05:08:32 <merijn> Walther: Sometimes hard to understand exact performance ramifications of your code, GC doesn't scale very high yet (i.e. beyond 12 cores), GUI support is pretty abysmal, ecosystem is prone to aggressively deprecate libraries :p
05:08:34 <mSSM> mm_freak: As in, what's the result of simTemp i g ns t = mapM_ (runIsing i g ns) [t, (t-1) .. 0]
05:08:37 <Lethalman> mSSM, the problem is in the print function as I said, not in the result
05:08:37 <mSSM> oops
05:08:42 <earthy> Walther: (and memory usage can change dramatically due to innocuous-looking changes)
05:08:42 <mm_freak> mSSM: rounding error accidentally working for you instead of against you
05:08:46 <merk_> mm_freak: what would it take for C code to be equal to your haskell code?
05:08:49 <mSSM> mm_freak: ok
05:08:50 <Doikor> Walther: getting that senior developer who has been developing with imperative languages for 30 years who has a way bigger say then you on the language/framework for the next to understand why something like haskell could be a better solution
05:08:51 <mSSM> Lethalman: thanks
05:08:55 <mm_freak> merk_: a lot =)
05:09:01 <mSSM> mm_freak: thanks
05:09:02 <Doikor> thats the only problem i have atm :)
05:09:03 <merk_> :)
05:09:31 <mm_freak> > 0.1 + 0.1 < 0.2
05:09:33 <lambdabot>   False
05:09:41 <mm_freak> > 0.1 + 0.1 < (0.2 :: Float)
05:09:42 <lambdabot>   False
05:09:49 <mSSM> eww, so I need to use printf?
05:09:50 <mSSM> :(
05:10:07 <mm_freak> > 10*0.1 < 1
05:10:08 <lambdabot>   False
05:10:12 <earthy> Doikor: that's actually not too bad a caveat, especially if you coin it in terms of 'it's much easier to hire blub programmers than haskell programmers' for any popular value of blub (e.g. C#, Java, C++, JavaScript, PHP, Python...)
05:10:18 <mm_freak> > 10*0.1 < (1 :: Float)
05:10:20 <lambdabot>   False
05:10:24 <mm_freak> weird
05:10:39 <mm_freak> sum (replicate 10 0.1) < 1
05:10:40 <mm_freak> > sum (replicate 10 0.1) < 1
05:10:41 <lambdabot>   True
05:10:46 <mm_freak> ah, there we go
05:10:50 <Lethalman> lol
05:10:53 <mm_freak> rounding error not working for you =)
05:10:57 <Doikor> earthy: yeah buts its bad for my interest in learning more haskell.
05:11:07 <earthy> ah. yes.
05:11:42 <bxc> merijn: ultimately our apps run on 40k cores (so talk of stuff not scaling beyond 12 cores makes me laugh ;)
05:11:51 <mm_freak> Doikor: who are you talking to?  earthy didn't say anything…  you hear voices…  just learn haskell ;)
05:12:03 <Walther> ...can be though; a good programmer in a less-popular language might get paid better for "special knowledge"
05:12:42 <quchen> Walther: Becoming good at Haskell however has a drawback: working with another language hurts
05:12:47 <merijn> bxc: Yeah, but 40k cores I'm assuming you're talking multiple boxes, not a single box
05:13:01 <earthy> 40k cores in a single box... that'd *hurt*
05:13:04 <bxc> its a single "machine"
05:13:07 <bxc> bluegene
05:13:09 <merijn> bxc: You can just fire up multiple haskell processes to avoid the problem, i.e. 1 process per 12 cores
05:13:23 <Walther> kheh, parallel parallelism
05:13:25 <bxc> theres only 4096 cores per physical metal box
05:13:33 <tdammers> fun with floats:
05:13:38 <bxc> and that is running 1000 OS images roughly
05:13:38 <tdammers> > floor (17000000000000085 :: Double)
05:13:40 <lambdabot>   17000000000000084
05:13:42 <earthy> and probably those 4096 cores don't share the same memory, right?
05:13:56 <bxc> earthy: nope
05:14:18 <merijn> bxc: 4096 cores / 1000 OS images = 4 cores per OS, so no problem with haskell not scaling past 12
05:14:18 <bxc> so gc isn't a problem in that sense
05:14:34 <bxc> mostly the scalaing problems are algorithmic
05:14:46 <bxc> at least the ones i've had
05:14:57 <bxc> the slightest imbalance kills your scalability
05:15:03 <bxc> in load distribution
05:15:41 <bxc> all tightly coupled simulations - eg one giant global array across the whole machine
05:17:03 <earthy> oh joy. ;)
05:17:18 <bxc> modelling what such an array looks like in the programming language is my main interest
05:17:20 <mSSM> print returns IO (), but how does printf work? Text.Printf says it returns "either String or (IO a)", so how do I use it properly?
05:17:22 <earthy> merijn: 40k cores / 1000 OS images = 40 cores per OS...
05:17:31 <mSSM> putStrLn $ printf " ... " v1 v2 v3 ?
05:17:36 <bxc> its 4 cores per node, one OS per node
05:17:38 <merijn> earthy: He said 4096 cores per box
05:17:42 <earthy> yeah
05:17:43 <earthy> I misread
05:17:45 <bxc> anything else is me getting my multiplication wrong
05:18:07 <bxc> i may have a few factors of 4 off in various places ;)
05:18:14 <bxc> whats a few bitshifts amongst friends
05:18:59 <fmap> mSSM: no, `printf " ... "'
05:19:33 <mSSM> fmap: But what's (IO a) supposed to be?
05:19:47 <fmap> @ty (printf "" :: IO (), printf "" :: String)
05:19:48 <lambdabot> (IO (), String)
05:19:55 <fmap> mSSM: ?
05:20:09 <mSSM> ok, right
05:20:18 <earthy> oh, another caveat in learning Haskell: it is so much different from many other languages that if you don't use it in anger for a while the details fade away
05:21:47 <fmap> mSSM: haskell printf is basically printf+sprintf
05:22:40 <kennyd> mSSM printf will return IO or String depending on where you use it
05:23:48 <quchen> Are there common pitfalls when using parallelization? My ProjectEuler file is faster on a single core than on multiple ones. Each problem is a normal unparallelized function, and I'm using parMap rseq euler [1..N] to calculate the resulting numbers.
05:23:59 <quchen> Single core outperforms 4 cores every time. :-(
05:24:17 <chreekat> Two questions, unrelated, questionable importance: First is, how do you change ghci's prompt string?
05:24:25 <fmap> quchen: what's the type of euler?
05:24:27 <mSSM> fmap, kennyd alright, I got it, thank you. I was confused what (IO a) is supposed to be in this context. Can you give me an example where the result of a `printf' would _not_ be (IO () ) ?
05:24:41 <bxc> chreekat: mine changes when I import modules
05:24:55 <quchen> fmap: euler :: Int -> Maybe Integer
05:25:08 <quchen> Nothing if the problem hasn't been solved
05:25:13 <chreekat> bxc: I specifically interested in how people get a lambda character instead of the "> " at the end
05:25:15 <quchen> Just SOLUTION otherwise
05:25:21 <bxc> oh
05:25:21 <bxc> no idea
05:25:32 <quchen> chreekat: You can change it in ghci.conf
05:25:33 <kennyd> mSSM whenever you use it where string is expected. "foo" ++ printf "bar"
05:25:43 <quchen> Or just write :set prompt "sldjlsdj"
05:25:45 <quchen> in GHCi
05:25:50 <bxc> quchen: too much laziness?
05:26:04 <chreekat> quchen: thanks, somehow I had not discovered ghci.conf
05:26:23 <quchen> -- Nicely colored prompt
05:26:25 <quchen> :set prompt "\ESC[34;47m=== %s ================================\ESC[m\n\ESC[34mλ.\ESC[m "
05:26:36 <quchen> That's how my corresponding entry looks like
05:26:57 <quchen> bxc: What do you mean with that?
05:27:43 <bxc> is it using four cores to evaluate to an array of Maybe <somethunk> and then using just one core to evaluate <somethunk> when you try to output it to the console or a file or whatever?
05:28:21 <ashish> Hi
05:28:25 <bxc> quchen: theres stuff like 'force' which needs an NFData instance which might help?
05:28:39 <ion> chreekat: My .ghci: https://gist.github.com/3909552
05:28:39 <quchen> bxc: The evaluating line is: mapMaybe solveEuler [1..10^2] `using` parList rseq
05:28:40 <ashish> > :t pure 30
05:28:41 <lambdabot>   <hint>:1:1: parse error on input `:'
05:28:46 <quchen> solveEuler :: Int -> Maybe (Int, Integer)
05:28:53 <bxc> quchen: but what do you do with the result?
05:29:01 <chreekat> ion: thanks, i'll check it out!
05:29:02 <quchen> printf, essentially.
05:29:26 <bxc> so potentially all the meat of the work is done in response to you trying ot printf stuff
05:29:34 <ashish> I've a question which instance of Applicative is there when I do 'pure 30' on ghci. I think it's IO, but I'm not sure.
05:29:36 <bxc> perhaps
05:29:41 <quchen> OH! I see! Yeah that makes sense
05:29:46 <quchen> I'm using parList rseq
05:29:52 <bxc> i'm not sure
05:29:56 <bxc> but i've had that problem with multicore
05:30:03 <bxc> laziness is your arch enemy in the parallel case.
05:30:04 <quchen> But I'm rseqing tuples
05:30:13 <quchen> So rseq doesn't do anything
05:30:20 <quchen> I wonder why this makes it that much slower though
05:30:26 <bxc> how much slower?
05:30:27 <quchen> It's 17 vs 24 seconds
05:30:55 * bxc wonders if profiler can give info on how cores are being used
05:31:04 <quchen> bxc: Threadscope
05:31:09 <merijn> bxc: I think it can with Threadscope?
05:31:18 <quchen> ... which I skipped.
05:31:29 <quchen> But I think rdeepseq is good advice
05:31:33 <quchen> Oh WHNF pitfalls
05:31:35 <bxc> yes
05:33:04 <int-e> Is there a variant of hClose without implied hFlush? (Use case: writing to a pipe to a process that was killed; if it writes any data, the implied hFlush will get an error (broken pipe))
05:33:04 <chreekat> Second question: I remember reading somewhere about work someone had done (possibly to cabal itself) that streamlines the process of looking up a package's source repository and cloning it. Anyone remember that?
05:33:42 <merijn> int-e: No, that behaviour is posix compliant
05:34:07 <quchen> bxc: Neat, parallel is now 14s, single is still 17. Still bad for 4 cores, but I've got a few bottlenecks in there for sure.
05:34:07 <merijn> int-e: Unless the RTS people reimplemented the C standard library that's not possible, and even then it might not be possible
05:34:22 <bxc> quchen: ha thats not much speedup
05:34:27 <merijn> (depending on whether the data is being buffered userland or kernel)
05:34:39 <int-e> merijn: they already ignore the SIGPIPE signal and turn EPIPE into an exception.
05:34:44 <quchen> bxc: Well, at least a factor of 2 over the badly parallelized version :D
05:35:00 <merijn> int-e: So handle the exception?
05:35:26 <int-e> merijn: I can do that, but as far as I understand, the fd will still not be closed.
05:35:37 <int-e> merijn: but I guess I should check the implementation ...
05:36:33 <quchen> bxc: Yeah, I've got one problem that takes 12.5 seconds. That explains a lot.
05:37:37 <bxc> quchen: yeahs thats going to eat up a bunch
05:37:45 <bxc> quchen: can you parallelise inside that problem some more?
05:38:26 <quchen> bxc: I'm not trying to parallelize the algorithms, only the "euler :: ProblemID -> SolutionInteger" function
05:38:37 <quchen> So that the "print all solutions" function is fast
05:38:45 <bxc> well if the worst problem is 12.5s then you're pretty much done ;)
05:38:58 <quchen> Without that problem I've got 9s single and 6s multicore
05:39:21 <merijn> int-e: Hard to say, I think the fd will always be closed, "man close" only lists three possible errors: EBADF (doesn't apply), EINTR (might apply? probably not) and EIO (might apply?), but I thought the fd will always be closed? To be sure you have to check the implementation
05:39:21 <quchen> Still pretty bad parallelization. I suspect another bottleneck. In any case, you solved my deepseq problem, thanks!
05:39:41 <bxc> quchen: whats the 2nd longest problem? (i.e. the longest problem in that case?)
05:39:51 <bxc> (or in general whats the distribution of your problem times look like?)
05:40:16 <int-e> merijn: ok, this actually works (i.e., the handle is closed), since ghc 6.12.1, I guess... http://hackage.haskell.org/trac/ghc/ticket/3128
05:40:32 <int-e> merijn: (I checked the code which refers to that ticket in a comment)
05:42:00 <hkBst> I'm looking for a proper adjective for the difference between a programmer with and one without a mathematical foundation in computing. I've come up with skilled, enlightened, sophisticated, educated. Does anyone know of a better word?
05:42:06 <Walther> eh. With python you can run .py scripts by issuing 'python program_name.py' and in java, "java -jar program.jar". And those are the only ways i've been running homebrewn programs so far. (and some tiny things with ghci :l program.hs)
05:42:30 <fmap> mSSM: note that if `printf ... :: IO a' and you *use* that `a' then you would get run-time exception
05:42:34 <Walther> But if I wanted to create something that can be ran universally, what would it require / how would one do it (context: haskell)
05:42:43 <quchen> bxc: I can't seem to improve the speedup ratio. Oh well, at least the parallel version is a little faster than the nonparallel one.
05:43:17 <bxc> quchen: whats the distribution of run times on the individual tasks? if you have a few that take a long time (like that 12s one) then you probably need to be a bit more clever.
05:43:33 <quchen> bxc: I could give you the repo, but I doubt you want to read any of my code. So I'll just say thanks and leave that one for when I'm really loking for a weird problem to solve.
05:43:49 <quchen> bxc: Most problems are < .1 s, some take longer.
05:44:07 <quchen> I just removed stuff until parallel was 3s, nonparallel 4.5.
05:44:18 <quchen> It keeps staying that 4:3 ratio.
05:44:20 <Spockz> kosmikus: is it possible to let lhs2tex insert the result from \eval verbatim into the generated .tex document? So I can generate some (la)tex code with my Haskell program?
05:44:33 <bxc> "its not the "most" - its the few worst case ones
05:44:49 <bxc> try launching the few worst case ones first, rather than in their natural position in the list
05:45:19 <bxc> that might help with tiling the tasks onto the cores better
05:45:33 <bxc> (rather than eg a long one being launched near the end and leaving 3 cores doing nothing)
05:46:01 <quchen> bxc: Good point. Even if I remove the bottlenecks, if the calculation time are exponentially distributed, I'll just get a faster version of the same issue.
05:46:26 <quchen> This euler function isn't very homogeneous after all.
05:47:11 <quchen> You're a very good debugger without seeing any code :-D
05:49:07 <merk_> why didnt this work?
05:49:18 <merk_> > map (f . g) [1..5] :: [Expr]
05:49:19 <lambdabot>   Ambiguous type variable `a0' in the constraints:
05:49:20 <lambdabot>    (GHC.Show.Show a0)
05:49:20 <lambdabot>     ...
05:49:26 <bxc> quchen: its the same old same old problems.
05:49:49 <quchen> bxc: That's the nicer way of saying "RTFM" ;-)
05:50:41 <int-e> merijn: I know the error isn't coming from close(), it's the hFlush, i.e. a call to write().
05:51:09 <int-e> merijn: but since the handle is actually getting closed, I can just catch the error. thanks for making me look (whether intentional or not) :)
05:51:17 <dmwit> :t f
05:51:18 <lambdabot> FromExpr a => a
05:51:35 <dmwit> > map ((f :: Expr -> Expr) . g) [1..5] :: [Expr]
05:51:37 <lambdabot>   [f (g 1),f (g 2),f (g 3),f (g 4),f (g 5)]
05:51:46 <bxc> quchen: its parallel computing RTFM, though, not haskell rtfm
05:51:51 <dmwit> merk_: f and g are too polymorphic
05:52:41 <quchen> bxc: I'm glad Simon Marlow's book isn't out yet, so that'll be my excuse
05:52:58 <merk_> dmwit: Thanks. SimpleReflect is pretty awesome
05:53:33 <quchen> {-# LANGUAGE Yell_at_user_when_seq-ing_a_tuple #-}
05:53:42 <quchen> That would be great
05:54:16 <dmwit> Calling seq on a tuple can make good sense if the tuple is constructed correctly.
05:54:30 <quchen> ?
05:54:40 <quchen> What's an incorrect tuple?
05:54:58 <dmwit> e.g. (3,4) vs let x = 3; y = 4 in x `seq` y `seq` (x, y)
05:55:21 <dmwit> Calling seq on the resulting tuple makes a lot of sense.
05:55:37 <quchen> I still don't see that
05:55:54 <dmwit> Calling seq on the tuple constructed by the second expression forces the 3 and the 4.
05:56:12 <quchen> It does? Oh
05:56:48 <dmwit> Perhaps you have not yet understood what seq does. =)
05:57:01 <quchen> Looks like it.
05:57:08 <kolektiv> hi all. a question from someone working with languages where I know there isn't a good answer...
05:57:22 <kolektiv> has haskell come up with a workable approach to composing monads?
05:57:31 <merk_> seq just returns second argument right?
05:57:45 <dmwit> Monads can't be composed in general; however, we have a fairly large monad transformer library.
05:58:23 <dmwit> merk_: No; it also guarantees that by the time the second argument has returned its WHNF, the first argument has done, too.
05:58:35 <kolektiv> dmwit: could you use a monad transformer to create a monad which was essentially Maybe + Writer (for example?)
05:58:58 <dmwit> Yes, that's just WriterT m Maybe a, or MaybeT (Writer m) a
05:59:05 <dmwit> ?unmtl WriterT m Maybe a
05:59:05 <lambdabot> Maybe (a, m)
05:59:10 <dmwit> ?unmtl MaybeT (Writer m) a
05:59:10 <lambdabot> (Maybe a, m)
05:59:24 <dmwit> As here, not all orderings of monad transformers are equal. This is a Good Thing.
06:00:10 <kolektiv> yes i see what you mean - composition (or transform) shouldn't be commutative, sure :)
06:00:19 <dmwit> right =)
06:00:25 <kolektiv> dmwit: thanks, i'll take a look at monad transformers
06:00:35 <kosmikus> Spockz: yes
06:00:56 <kolektiv> dmwit: currently working in f# and ml, and i'm not sure i'll be able to implement a similar concept, but it's worth a look :)
06:01:02 <Spockz> kosmikus: the follow up question is, how?
06:01:06 <kosmikus> Spockz: it'll just not be reinterpreted by lhs2tex, iirc
06:01:15 <kosmikus> Spockz: so it has to be pure LaTeX
06:01:21 <Spockz> kosmikus: that is not a problem
06:01:44 <bxc> not all transformed monads are monads either
06:02:10 <dmwit> bxc: I guess you're referring to ListT? If so, I would just say ListT is not a monad transformer instead.
06:02:34 <quchen> merk_: seq is defined to be a bottom-checker. seq bottom _ = bottom, seq  _ x = x. To check whether a tuple is bottom, it's sufficient to check whether its WHNF is.
06:03:01 <kosmikus> Spockz: is it just \perform instead of \eval?
06:03:05 <kosmikus> Spockz: I have to check ...
06:03:48 <kolektiv> hmmm. looking at the semantics of monad transformers i think this probably isn't possible in f# - not going to work with the type system
06:04:11 <kolektiv> still, thanks for the suggestion, might suggest and interesting approach in future :)
06:04:17 <dmwit> F# doesn't have higher kinds, right?
06:04:21 <dmwit> Or is there some other problem?
06:04:28 <kolektiv> yeah, that's basically going to be the problem
06:04:47 <kolektiv> we'd need typeclasses or similar
06:05:03 <dmwit> Also, though it may not be possible to write a general transformer library, you can still expand out a transformer stack "by hand" so to speak, and have a pretty high assurance that this produces a good monad without trying to prove all the laws yourself.
06:05:32 <Spockz> kosmikus: If I add  \perform{5*5} to my .lhs file lhs2tex stops doing something somewhere. It doesn't use CPU time
06:05:36 <kolektiv> dmwit: that's actually what i've done essentially in a few places
06:05:45 <dmwit> Right. Super annoying.
06:06:24 <quchen> dmwit: Coming back to the tuple seq from above:
06:06:26 <quchen> > seq (let a = seq undefined 1 in (a,a)) 1
06:06:28 <lambdabot>   1
06:06:28 <kolektiv> dmwit: it works fine, and it's much nicer than not having monadic approaches available at all, but i always like to look for better ways!
06:06:44 <kolektiv> dmwit: (short of switching to haskell, i'm afraid)
06:06:52 <quchen> Isn't that calling seq on a tuple that contains a bottom?
06:06:55 <dmwit> > seq (let a = seq undefined 1 in seq a (a,a)) 1
06:06:56 <lambdabot>   *Exception: Prelude.undefined
06:07:18 <dmwit> > seq (let a = undefined in seq a (a,a)) 1
06:07:19 <lambdabot>   *Exception: Prelude.undefined
06:07:24 <quchen> Well there you're seq-ing a, not the tuple
06:07:31 <dmwit> I'm seq-ing both.
06:07:40 <quchen> Oh, right
06:08:41 <elliott> I wish there was a nice description of seq that didn't imply an "evaluation order" like (seq _|_ y = _|_, seq x y =y) does
06:08:58 <dmwit> elliott: That spec does not imply an evaluation order.
06:09:16 <dmwit> In fact, GHC does not promise to evaluate the first argument to seq before it evaluates the second argument to seq.
06:09:21 <dmwit> (If you want that, use pseq instead.)
06:09:23 <quchen> I think he meant "visual evaluation order"
06:09:26 <kosmikus> Spockz: you have %options ghci ?
06:09:44 <Spockz> kosmikus: yes, when I don't do that I get hGetLine errors :)
06:09:48 <quicksilver> GHC doesn't promise to evaluate seq's first argument *at all*.
06:10:05 <elliott> dmwit: Right, that's my point.
06:10:15 <elliott> dmwit: But if you tell someone seq is defined that way they'll think it checks the left argument firts.
06:10:19 <elliott> Since that's how pattern-matching works in Haskell.
06:10:19 <hpaste> kosmikus pasted “\perform example” at http://hpaste.org/80801
06:10:29 <dmwit> I see.
06:10:36 <kosmikus> Spockz: http://hpaste.org/80801
06:10:36 <dmwit> I feel that my previous description of seq does not have this flaw.
06:10:38 <kosmikus> ^^ works for me
06:10:53 <dmwit> (...and that was not by accident.)
06:10:54 <elliott> foo (Left x) y = Left x; foo x y = y  -- foo evaluates x to WHNF before y
06:11:10 <quicksilver> elliott: really?
06:11:14 <elliott> Er.
06:11:16 <elliott> Evaluates (Left x)
06:11:19 <quicksilver> elliott: I think you're assuming a certain state of mind there.
06:11:26 <elliott> dmwit: Right. Yours was a little operational for my tastes, though.
06:11:27 <quicksilver> _|_ isn't a pattern
06:11:45 <quicksilver> so it wouldn't occur to me to consider the seq _|_ y = _|_, seq x y =y definition as pattern matching
06:11:56 <elliott> quicksilver: Fair enough. It resembles a pattern to me.
06:12:07 <quchen> dmwit: So seq (let a = undefined in seq a (a,a)) 1 results in 1 at some point, and it's up to the compiler to decide whether that's before or after it finds out there's an undefined in there?
06:12:14 <dmwit> I think assuming that someone will *not* interpret it like a pattern match is asking too much.
06:12:19 <Spockz> kosmikus: my %options directive was above the include of polycode.fmt
06:12:21 <quicksilver> seq x y = y unless x is _|_
06:12:26 <quicksilver> is what I normally see/hear
06:12:40 <quicksilver> or seq x y = y if x is not _|_
06:12:47 <kosmikus> Spockz: that doesn't matter. it still works if I move it there.
06:13:15 <dmwit> quchen: Hm, I don't think so. It definitely can't evaluate to 1 before it finds out if the first argument is undefined or not.
06:13:17 <elliott> I normally say seq _|_ y = _|_, seq x y = y if x =/= _|_.
06:13:24 <elliott> But it's not ideal.
06:13:35 <kosmikus> Spockz: %options is uninitialized by default; it should probably default to %options ghci though. lhs2TeX was written in a time when ghci didn't exist, and hugs was the only interpreter.
06:13:37 <covi>  I am building a REPL, which essentially uses 'flushStr prompt >> getLine' to read user input. How can I add support for the left and right arrow keys? Right now, pressing these two keys inputs chars, not moving around the cursor.
06:13:43 <dmwit> quchen: It can evaluate to *undefined* before it finds out if the first argument is undefined, though.
06:13:45 <elliott> The repetition of the condition on x feels like it might discourage notions of pattern ordering.
06:14:08 <quchen> seq is confusing.
06:14:15 <quchen> Not the definition, but the usage.
06:14:15 <merk_> is this a good read for understanding laziness in haskell? http://en.m.wikibooks.org/wiki/Haskell/Laziness
06:14:19 <dmwit> quchen: e.g. in the world of Haskell where not all undefined's are the same, seq foo bar can evaluate to bar's undefined instead of foo's undefined.
06:14:44 <elliott> The thing to relise is that the difference between seq and pseq is only going to change what kind of _|_ you get (nontermination vs. some error message vs. another error message), or the efficiency of your code, unless you do something unsafe.
06:15:20 <elliott> (But the main reason to use seq in practice is efficiency, so...)
06:15:50 <elliott> The interesting thing about this quibble is that IIRC it's actually a mistake that the report doesn't specify seq evaluates its first argument firts.
06:16:39 <quchen> dmwit: Earlier you said that it makes sense to seq (let a = 2; b = 3 in a `seq` b `seq` (a,b)). So that implies that before the tuple constructor is created, a and b have to be evaluated. Right?
06:16:42 <hpaste> dmwit pasted “seq” at http://hpaste.org/80802
06:16:43 <Spockz> kosmikus: ah this is what I have https://gist.github.com/4210d771488be0f53130
06:16:54 <cardamon> hello
06:17:12 <dmwit> quchen: See that paste. Also, yes.
06:17:27 <elliott> It depends on what you mean by "tuple constructor is created".
06:17:44 <elliott> It could allocate and construct a tuple in memory, and then evaluate b, and then evaluate a.
06:18:32 <elliott> But you won't get a tuple out of it, in Haskell terms, until a and b are both evaluated.
06:18:53 <quchen> dmwit: So in order to decide whether (a,b) is bottom, the tuple defined as seq a (seq b (a,b)) has to be evaluated, and the tuple constructor is nested somewhere inside. The only possibility of finding out whether there actually is a tuple constructor is by evaluating the seqs at some point.
06:18:58 <quchen> ..?
06:19:14 <cardamon> I was fiddling with cabal-install and got in over my head.  It built xmonad without xinerama headers, and now I've got the headers.  How do I remove the old build? cabal-install version 0.14.0
06:19:21 <dmwit> quchen: uh...
06:19:28 <dmwit> quchen: I feel you're being a bit imprecise here.
06:19:34 <dmwit> quchen: The tuple (a,b) definitely is not bottom.
06:19:39 <applicative_> merk_: there is a good discussion of laziness, where to avoid it etc in here http://www.slideshare.net/tibbe/highperformance-haskell . The wikibook page seems good from a superficial reading
06:20:17 <kosmikus> Spockz: the file itself has to be accepted without error via the invocation from the %options line
06:20:38 <kosmikus> Spockz: calling ghci on your file gives line 7: unlit: Program line next to comment
06:20:39 <dmwit> quchen: ...and I feel that if you try to rephrase your question avoiding this imprecision, you will have already answered the question. =)
06:20:48 <merk_> applicative: thanks, I will read both.
06:20:50 <dmwit> and possibly reached enlightenment
06:21:40 <quicksilver> i hoped to reach enlightenment but Apple Maps directed me instead to IRC.
06:21:44 <Spockz> kosmikus: ah yes now it works! :)
06:22:16 <applicative_> cardamon: I can't remember how an xmonad installation is structured.  ghc-pkg unregister xmonad  ?  and maybe remove ~/.cabal/bin/xmonad  is there a binary inside ~/.xmonad?
06:22:21 <quchen> dmwit: So in order to decide whether "seq a (seq b (a,b))" is bottom, the thing defined as "seq a (seq b (a,b))" has to be evaluated, and the tuple constructor is nested somewhere inside. The only possibility of finding out whether there actually is a tuple constructor is by evaluating the seqs at some point.
06:22:27 <quchen> Better?
06:22:37 <quchen> I'm saying this in a "Right?" manner.
06:22:40 <dmwit> cardamon: cabal install --reinstall X11 xmonad xmonad-contrib
06:23:06 <applicative_> merk_: the tibbe thing is  more practical of course; I just remember a lot of things clicked for me when it came out.
06:23:18 <dmwit> quchen: That sounds pretty good to me.
06:23:44 <applicative_> --reinstall right
06:23:44 <quchen> dmwit: I'm slightly enlightened.
06:23:55 <cardamon> dmwit: The thing that concerns me is that that didn't take nearly as long as the first build.
06:24:23 <dmwit> cardamon: Did the configure step of X11 say "Xinerama headers: Yes"? If so, you should be good to go.
06:24:26 <dmwit> You can also check by running...
06:24:41 <dmwit>    ghc -e Graphics.X11.Xinerama.compiledWithXinerama
06:24:50 <dmwit> http://www.haskell.org/haskellwiki/Xmonad/Frequently_asked_question#Multi_head_or_xinerama_troubles
06:25:27 <dmwit> Oh, you should probably execute "xmonad --recompile" after that's all done, too.
06:25:33 <cardamon> dmwit: What if you built it from a darcs copy instead?
06:25:42 <dmwit> Since xmonad implements its own (broken) recompilation detection.
06:25:49 <cardamon> Does that change anything up?
06:25:54 <dmwit> Please specify the antecedent.
06:27:00 <dmwit> (What is "it"?)
06:27:09 <cardamon> xmonad.
06:27:44 <dmwit> Yep, just pass the path to the xmonad repository to the cabal install command instead of the package name xmonad.
06:28:05 <dmwit> So, something like cabal install --reinstall X11 ./xmonad ./xmonad-contrib, for example, if you have the xmonad and xmonad-contrib repositories in the current directory.
06:28:47 <cardamon> I followed along with the instructions on the download page, starting with grabbing the copy through darcs, until I started running into trouble, then I wined, moaned, and gnashed my teeth a bit when I couldn't find man pages, and then I asked people and started throwing commands, and then I successfully built it without Xinerama headers.
06:32:16 <cardamon> dmwit: It's working.  By which I mean doing a lot of work.  Which seems to be working.
06:36:36 <beaky> hello
06:36:40 <qwr> hmm. stupid problem - (executeFile "/bin/echo" False ["s\228\228sk"] Nothing) gives *** Exception: recoverEncode: invalid argument (invalid character)
06:36:50 <beaky> does haskell use normal-rder ealuation
06:36:55 <beaky> normal order evaluation*
06:37:10 <qwr> is there way to work around it in C locale?
06:37:40 <qwr> (bytestring version would help, for example)
06:37:47 <beaky> ?msg nickserv identify beaky aekonbii
06:37:47 <lambdabot> Not enough privileges
06:37:54 <beaky> oops
06:37:57 <dmwit> Use latin-1 encoding instead?
06:38:06 <dmwit> Is C locale really a requirement for some reason?
06:38:07 <HugoDaniel> does it make sense to use GADTs and type families on the same module ?
06:38:12 <HugoDaniel> how do they differ ?
06:38:13 <covi> beaky: it definitely does not use applicative order.
06:38:19 <quchen> beaky: Nobody's seen that.
06:38:36 <qwr> dmwit: some other things broke in non-C locale if i remeber correctly (i think posix regex)
06:39:13 <dmwit> HugoDaniel: It can make sense. GADTs are implemented as type families + existentials.
06:39:43 <dmwit> beaky: I don't believe Haskell the language specifies an evaluation order.
06:40:14 <beaky> ah
06:40:26 * qwr thinks. ok, i can probably write my own exec in foreign C...
06:40:29 <dmwit> If you want to ask about GHC, then any evaluation order that doesn't account for sharing is definitely wrong.
06:40:31 <beaky> I always think of evaluation in haskell as plugging in equations
06:40:34 <quicksilver> normal evaluation order is a good model, though
06:40:52 <quicksilver> because normal evaluation order always produces the same result as haskell
06:41:00 <quicksilver> but that doesn't mean compilers are forced to use it.
06:41:35 <applicative_> beaky I think the 'semantics' are supposed to agree with normal order.  'lazy' evaluation is a sort of optimization of normal order evaluation, I guess you'd say
06:41:35 <beaky> haskell code is screaming fast
06:41:51 <beaky> ah
06:42:47 <merk_> is this correct?  length [head x] evaluates x to [thunk : thunk].  and length (tail x) evaluates x to [thunk : thunk : ... thunk : []]
06:43:03 <applicative_> if square x = x * x and then I ask for square (20^20), normal order would think, that's 20^20 + 20^20, then evaluate 20^20 twice
06:43:19 <dmwit> merk_: I don't think head ever gets called at all in that.
06:43:34 <Jaak> > length [head undefined]
06:43:35 <lambdabot>   1
06:43:43 <merk_> dmwit: ah right
06:43:56 <applicative_> strict evaluation is a semantics-wrecking optimization of real (normal order) evaluation
06:45:08 <beaky> why is it called normal evaluation?
06:45:12 <beaky> normal order*
06:45:28 <merk_> was the tail part correct at least?
06:46:09 <applicative_> if i ask what's bippo (new,old), the first question is, whats bippo?
06:46:10 <dmwit> Seems right, if you treat the outermost [] as some sort of quotation mark.
06:47:42 <merk_> ok I see that [] is not needed last cons includes it
06:47:49 <merk_> as last cons
06:50:23 <covi> Is there anyone here who's familiar with System.Console.Haskeline? I have bunch of functions that work in the IO monad, but now I want to switch my REPL to this module. Do I have to change all those functions from IO to InputT?
06:51:29 <M30W> /bin/sh: -c: line 0: unexpected EOF while looking for matching `''
06:51:29 <M30W> /bin/sh: -c: line 1: syntax error: unexpected end of file
06:51:33 <M30W> O.o
06:51:54 <M30W> ♥
06:52:06 <M30W> /exec -o ghc -e 'putStrLn "\9829"'
06:52:12 <M30W> win :)
06:53:22 <quchen> M30W: What's going on there
06:54:14 <applicative_> covi: what youre worried about applying InputT . lift . lift . lift . lift . lift to everything ??
06:54:44 <M30W> quchen: escaped byte for the unicode heart
06:55:15 * applicative_ sees a heart
06:55:16 <bxc> are multilevel languages (in the sense of genralized arrows) the same as multistage languages (like in metaml)
06:55:26 <covi> applicative_: looks like I can just use liftIO
06:55:39 <M30W> useful when on a keyboard that just cant type it and i am ssh'd in and on irc. :)
06:55:55 <Botje> ctrl-shift-u 2665 in most linux terminals
06:56:06 <M30W> Botje: yes most
06:56:18 * hackagebot commsec 0.2 - Communications security  description: A basic communications security package that provides confidentiallity, integrity and replay detection.  http://hackage.haskell.org/package/commsec-0.2 (ThomasDuBuisson)
06:56:36 <`ramses> M30W: that just closes my terminal o.O
06:56:57 <applicative_> covi, yes. I was just amazed it was ReaderT ... (ReaderT ...(ReaderT ...(ReaderT ...(ReaderT ... m))))) a
06:57:04 <M30W> lolwat?
06:57:04 <Botje> `ramses: you should only put the ghc ... stuff.
06:57:24 <Botje> `ramses: exec will replace your bash process with the ghc process, killing your terminal when it's done.
06:57:24 <M30W> ex don't think that exec for the shell haha.
06:57:28 <covi> applicative_: what was?
06:57:48 <`ramses> ah! ok, learned something new today :)
06:57:55 <M30W> ghc will quit almost instantly. :P
06:58:18 <applicative_> covi the definition of InputT m a  -- newtype InputT m a = InputT {unInputT ::  ReaderT RunTerm (ReaderT (IORef History) (ReaderT (IORef KillRing) (ReaderT Prefs (ReaderT (Settings m) m)))) a} deriving (Monad, MonadIO, MonadException)
06:58:23 <M30W> you are meant to be learning haskell not shell mister `ramses haha.
06:58:36 <`ramses> useful nonetheless ;)
06:59:01 <`ramses> I always did a great haskell exam today, so I'm fine on that front for the rest of the day
06:59:07 * applicative_ learns shell here all the time
06:59:08 <`ramses> s/always/already
07:00:15 <M30W> haskell exams....
07:00:33 <applicative_> in the InputT monad, ReaderT (IORef blah) is doing the work of StateT
07:00:33 <M30W> where is the rest of the world when my school does visual basic!!!!!
07:00:38 <M30W> :'(
07:01:17 <`ramses> M30W: visual basic? really??
07:01:23 <`ramses> not even java
07:01:26 <M30W> fucking sadly.
07:01:40 <M30W> java, will be a "little"
07:01:56 <`ramses> that's sad indeed
07:01:57 <M30W> and *maybe* c and bloody game maker.
07:02:02 <M30W> wtf?????? D:
07:02:09 <applicative_> In the future, everything will be made of javascript
07:02:13 <Hafydd> If you think Java is better than VB, you may be inexperienced in VB and/or Java.
07:02:41 <M30W> they both suck. :)
07:02:52 <Hafydd> Compared to Haskell, quite possibly.
07:03:02 <M30W> quite true.
07:03:05 <M30W> *
07:03:34 <`ramses> I thought visual basic was a quite old language, but maybe I missed the new developments? I work part time as a java developer, so I know that part :)
07:03:48 <Hafydd> I assumed it was VB.NET.
07:04:05 <covi> applicative_: in which file did you read that?
07:04:14 <`ramses> I only now the vb I looked at as a teenager, and that was pretty awful
07:04:14 <M30W> ramses, vb.net isn't what my school plays with... old vb.
07:04:24 <Hafydd> Oh, well then...
07:04:35 <applicative_> covi: System.Console.Haskeline.InputT
07:04:36 <Hafydd> The comments above are better deserved.
07:04:58 <M30W> haskell will rule the world... give it time. :)
07:05:09 <`ramses> M30W: not so sure about that :)
07:05:15 <tdammers> vb.net is basically c# with a weird syntax and some dangerous options
07:05:36 <M30W> then work on it so you are sure about it as a fact!!! :)
07:05:44 <Hafydd> I was instructed in VB.NET in my secondary education, not that the teachers made use of any of VB.NET's features it has over VB.
07:06:07 <covi> applicative_: wow, that looks pretty ugly
07:06:14 <covi> applicative_: necessary to get shit done?
07:06:25 <applicative_> covi I see, in the end the definition is hidden, only InputT runInputT etc are exported
07:06:36 <M30W> covi: what are you attempting to do?
07:06:39 <`ramses> this is the vb at hand, I think: https://en.wikipedia.org/wiki/Visual_Basic
07:06:42 <covi> applicative_: of course
07:06:46 <flebron> Say I have a Data.Vector Bool v. Is there a way to set the kth element of v to True (returning v, with v ! k == True), in O(1)?
07:06:49 <`ramses> seems vb.net is some kind of succesor
07:06:53 <M30W> share a variable between threads and allow mutation?
07:06:54 <covi> M30W: I have gotten it done. Thanks for asking.
07:07:20 <M30W> okay. :)
07:07:50 * M30W is on his phone so has quite a small visable buffer. :P
07:07:52 <applicative_> covi: I'm not sure why he does it rather than ReaderT  (blah, IORef blah, IORef blah, ...) m a I'm sure there's a reason . Maybe tupling gets in the way
07:08:51 <M30W> <interactive>:1:1:
07:08:52 <M30W>     Not in scope: `putSrtLn'
07:08:52 <M30W>     Perhaps you meant `putStrLn' (imported from Prelude)
07:08:54 <M30W> O.o
07:09:05 <M30W> N900 ♥
07:09:20 <quchen> flebron: Vector only takes one argument.
07:09:21 <M30W> > putStrLn "N900 \9829" --lol
07:09:23 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
07:09:23 <lambdabot>    arising from a use of ...
07:09:32 <merijn> M30W: lambdabot doesn't do IO
07:09:33 <M30W> > "N900 \9829" --lol
07:09:34 <lambdabot>   "N900 \9829"
07:09:41 <M30W> merijn: i know. :P
07:09:42 <flebron> quchen, I know, v is the name of the variable, of type Data.Vector Bool.
07:09:46 <quchen> flebron: Oh, you meant v :: Vector Bool
07:09:48 <flebron> Yeah.
07:09:52 <applicative_> I think Vector Bool is the type
07:09:58 <applicative_> ah
07:10:05 <M30W> hoe to get him use the escape code?
07:10:07 <applicative_> update v
07:10:17 <M30W> don't want print -.-
07:10:32 <applicative_>  <5,9,2,7> // [(2,1),(0,3),(2,8)] = <3,9,8,7>
07:10:50 <`ramses> M30W: isn't it usually the shell that interpretes the escape code?
07:10:55 <flebron> right, that's O(n+m), m length of the vector, n length of list of updates
07:11:08 <M30W> ram not in this. :)
07:11:18 <quchen> flebron: Have you used mutable vectors?
07:11:25 <applicative_>  or if you like fromList [5,9,2,7] // [(2,1),(0,3),(2,8)] = fromList [3,9,8,7]
07:11:27 <flebron> Not yet, but I wouldn't be agains tit.
07:11:30 <flebron> *against it
07:11:32 <M30W> /exec -o ghc -e 'putStrLn "N900 \9829"'
07:11:45 <M30W> note single quotes on outside?
07:11:58 <M30W> shell doesn't touch.
07:11:59 <quchen> flebron: In any case, you can't update an immutable vector in O(1) in Haskell. You'll always have to copy it, which makes it O(n).
07:12:17 <M30W> and it's not $'\9829'
07:12:17 <flebron> What if I used mutable vectors?
07:12:29 <applicative_> fromList [True,True,True] // [(2,False)] fromList [True,True,False]
07:12:35 <M30W> \9829
07:12:35 <quchen> flebron: Updating mutable vectors is O(1).
07:12:50 <M30W> the shell doesn't know that escape.
07:12:57 <applicative_> quchen: if there is fusion there is no copying
07:13:06 <`ramses> M30W: okay, the terminal showing the shell then, I don't think ghc changes the escape code, does it?
07:13:21 <flebron> Ah, OK. I'll have to learn how to use mutable vectors then, thanks :)
07:13:22 <`ramses> s/changes/interpretes
07:13:23 <M30W> putstrln
07:13:25 <applicative_> flebron: you should use Data.Vector.Unboxed if you have a vector of Bools
07:13:39 <M30W> it is an escape sequence meaning it's raw bytestring
07:13:43 <M30W> byte *
07:14:01 <quchen> applicative_: That's true. However, I'm always careful about relying on compiler optimizations.
07:14:01 <flebron> yeah, that's true :)
07:14:17 <applicative_> flebron: you don't need mutable vectors until you know you aren't getting fusion
07:14:27 <quchen> flebron: Hack first, profile later :-)
07:14:48 <flebron> Won't I need to re-do a lot of the program if I decide to use mutable vectors later?
07:14:57 <flebron> (Well, I guess it depends on how small my program is :p)
07:14:57 <M30W> krefactor more after
07:14:58 <M30W> :)
07:15:06 <M30W> s/k//
07:15:12 <merijn> @hoogle Int -> [a] -> [[a]]
07:15:13 <lambdabot> Prelude drop :: Int -> [a] -> [a]
07:15:13 <lambdabot> Data.List drop :: Int -> [a] -> [a]
07:15:13 <lambdabot> Prelude take :: Int -> [a] -> [a]
07:15:25 <M30W> night world.
07:15:26 <applicative_> changing to Data.Vector.Unboxed is likely to make a bigger difference than using MVector
07:15:32 <M30W> Thu Jan 17 02:15:16 EST 2013
07:15:36 <M30W> @time
07:15:36 <lambdabot> Local time for M30W is Thu Jan 17 02:15:20 2013
07:15:44 <M30W> that works haha.
07:15:51 <M30W> night again
07:16:02 <BillyBlueHat> @time
07:16:03 <lambdabot> Local time for BillyBlueHat is Wed Jan 16 15:15:51 2013
07:16:06 <applicative_> @time
07:16:06 <lambdabot> Local time for applicative_ is Wed Jan 16 10:15:51 2013
07:16:09 <M30W> haskell ♥
07:16:31 <M30W> it ctcp time'd you guys btw lol
07:16:57 <sw17ch> @time
07:16:58 <lambdabot> Local time for sw17ch is 2013-01-16 15:16:43 +0000
07:16:59 <flebron> Hrmph. The use of this is in a backtracking algorithm for Hamiltonian cycle, used :: Vector Bool, where used !! i == True means I've already used i in my cycle. So the usual operation on it is set i, then a bunch of people check against the vector, and then unset i.
07:17:31 <sw17ch> Curious. Why is mine formatted differently?
07:17:51 <k00mi_> @time
07:17:52 <lambdabot> Local time for k00mi_ is Wed, 16 Jan 2013 16:17:35 +0100
07:17:54 <`ramses> sw17ch: you're special ;)
07:18:03 <sw17ch> hurray!
07:19:02 <Hafydd> Most likely because that's what your client reports.
07:19:05 <beaky> how do I think functionally?
07:19:16 * applicative_ looks into these 'Hamiltonian cycles' 
07:19:56 <applicative_> flebron: do you have simple code to hpaste or whatever?
07:19:58 <flebron> Just some backtracking, keeping track of a "used choice" in a graph.
07:20:18 <flebron> I've done the thing in C++, I've only written a small bit of the code in Haskell, but I can paste it.
07:21:01 <flebron> C++: http://liveworkspace.org/code/3Jyq9v$0
07:21:12 <hpaste> flebron pasted “Starting Hamiltonian Cycles” at http://hpaste.org/80803
07:21:32 <fragamus> which lens package is most popular
07:21:38 <srhb> lens
07:21:42 <fragamus> ty
07:21:42 <flebron> ^-- Haskell, though I've just build the adjacency list, finding the cycle would come later, once I know how to mark a node as used in the "used" vector :)
07:21:42 <srhb> At least nowadays :P
07:21:50 <applicative_> lens lens lens
07:22:03 <flebron> Oh, s/usados/used/, damned Spanish.
07:22:04 <fragamus> is there any reason i should be using any other
07:22:11 <oio> any idea why this doestn work
07:22:25 <hpaste> OiO pasted “Error” at http://hpaste.org/80804
07:22:54 <mSSM> Can I tell cabal-dev install to only compile one executable in my .cabal file?
07:22:58 <edwardk> fragamus: lens does a lot more than any of the other lens packages. traversals, prisms, etc. are things you tend to grow into over the course of using the library
07:22:58 <mSSM> i.e. one particular
07:23:17 <edwardk> none of the other 'lens' packages are structured in such a way that they can sanely offer those features
07:23:44 <edwardk> data-lens used to be pretty popular, but pretty much all its major users have switched to lens
07:24:11 <fragamus> that's good enough for fragamus
07:24:13 <edwardk> it had the benefit of being simple, but you couldn't do type changing assignment, couldn't focus/zoom deep in a monad transformer stack, etc.
07:24:27 <edwardk> basically i look back on it as charmingly crippled
07:24:46 <tdammers> jesus christ, now I have to look into lens, too
07:24:55 <fragamus> yeah
07:25:34 <fragamus> I'm installing it now : )
07:25:44 <edwardk> tdammers:  http://youtu.be/cefnmjtAolY?hd=1
07:25:57 <edwardk> there are slides linked from there
07:26:05 <edwardk> and the #haskell-lens channel is very supportive ;)
07:26:21 <applicative_> fragamus: you set up a script to keep reinstalling it from github
07:26:33 <fragamus> oh?
07:26:45 <applicative_> fragamus: I tried to do it by hand, but it was untenable....
07:26:46 <fragamus> wahuh
07:27:06 <applicative_> fragamus: just kidding
07:27:18 <fragamus> :P
07:27:55 <tdammers> edwardk: thanks, I'll go dive
07:30:04 <jerry0> is there a way to get a haskell array out of a C pointer without copying all the elements?
07:30:27 <fragamus> installed!!!
07:30:33 <jerry0> or rather, without copying any elements.
07:32:36 <geekosaur> jerry0, not really, no.  you can't generally manipulate C arrays/pointers from ghc, at least
07:34:43 <hiptobecubic> there's no way to pass in a pointer to 10 contiguous floats in memory and work with them? That can't be right.
07:35:50 <geekosaur> not without using Foreign.Marshall.Array
07:35:57 <jerry0> I can work with them the C way, dereferencing pointer etc. but it would be nice if GHC could wrap a haskell array around that pointer, so I can use regular haskell functions
07:36:05 <geekosaur> which will copy elements
07:36:18 <quicksilver> doesn't StorableArray have that semantics?
07:36:22 <srhb> Wouldn't Data.Vector.Storable be able to do something like that?
07:36:29 <quicksilver> i.e. using the same memory layout as C arrays
07:36:36 <jerry0> without copying the elements?
07:36:36 <jerry0> I'll check
07:37:03 <quicksilver> yes it does
07:37:10 <quicksilver> ""A storable array is an IO-mutable array which stores its contents in a contiguous memory block living in the C heap. Elements are stored according to the class Storable. You can obtain the pointer to the array contents to manipulate elements from languages like C""
07:38:02 <mSSM> Do I read this correctly, that if I use x86-64, my programs wil always be compiled with sse2 support? http://www.haskell.org/ghc/docs/latest/html/users_guide/options-platform.html
07:38:16 <srhb> Yes
07:38:27 <quicksilver> mSSM: SSE is the only floating point than x86-64 supports.
07:38:28 <mSSM> So no need for -fuse_sse2
07:38:36 <mSSM> ok, thanks
07:38:40 <quicksilver> it doesn't have an x87
07:42:06 <geekosaur> hm, IO-mutable, so it's not *quite* a normal Haskell value.  that makes sense
07:42:21 <beaky> are IO functions pure?
07:42:29 <beaky> or are they not referentially-transparent?
07:43:04 <hiptobecubic> you have no idea they could do pretty much anything
07:43:10 <hiptobecubic> idea, they*
07:43:14 <Saizan> beaky: computing the "IO X" value that describes the effects is pure
07:43:27 <Saizan> beaky: actually executing the effects is not
07:44:01 <fmap> should I expect a perfomance loss (aroung 5%) for splitting program into 2 modules (everything is {-# INLINEd #-})?
07:44:25 <beaky> why is ST pure while IO is impure?
07:44:32 <Saizan> beaky: in fact in a program like "do x <- getLine; .." you can't assume x is the same as getLine, while in "let x = getLine in .." you cam
07:44:35 <Saizan> *can
07:44:41 <beaky> ah
07:44:59 <beaky> so monadic bind for IO is impure?
07:45:10 <Saizan> it helps that in the first case x and getLine don't even have the same type
07:45:25 <mSSM> at the bottom of the mersenne random doc, the -fvia-c flag is used for compilation; do you have an idea what the idea behind that is? http://hackage.haskell.org/packages/archive/mersenne-random/1.0.0.1/doc/html/System-Random-Mersenne.html
07:45:38 <hiptobecubic> fvia-c has been dead a long time i think
07:45:46 <hiptobecubic> and that is probably old
07:45:52 <oio> is there a way to stop a list comprehension ?
07:46:01 <hiptobecubic> oio, that doesn't make sense
07:46:17 <Saizan> beaky: it would be impure if it were an assignment, but what happens is that you just pass a callback to (>>=)
07:46:45 <`ramses> oio: filter the result or improve the guards? the list is constructed lazily anyway btw, so these two are in fact equal
07:47:28 <Saizan> beaky: in the end only the runtime system executing your main action is doing anything impure, but that's outside haskell
07:48:03 <oio> lets say i need to cut a string when this character appears '|'
07:48:18 <`ramses> oio: look at takeWhile
07:48:34 <Saizan> beaky: OTOH GHC actually implements all this by having a few impure primitives and wrapping them in IO (taking care of properly sequencing the effects)
07:48:45 <`ramses> > takeWhile (/= '|') "test|string"
07:48:47 <lambdabot>   "test"
07:48:57 <beaky> ah
07:49:09 <Saizan> beaky: but that's an implementation detail
07:49:14 <`ramses> oio: is that what you mean?
07:49:25 <oio> prefect
07:49:33 <hiptobecubic> there's also dropWhile and split
07:50:15 <flebron> Say I have a [Maybe a]. What's a clean way of saying "The first non-Nothing value?" head. dropWhile Nothing? Is there something inside the Maybe monad that would make it cleaner?
07:50:32 <flebron> err, head . dropWhile isNothing.
07:51:14 <Botje> flebron: there's catMaybes
07:51:20 <`ramses> flebron: listToMaybe . catMaybes maybe?
07:51:24 <Botje> or head [ x | Just x <- xs ]
07:51:30 <flebron> Won't that "force execution" of the things?
07:51:34 <quicksilver> > sequence [Nothing, Just 1]
07:51:36 <lambdabot>   Nothing
07:51:40 <flebron> (Because it will have to pattern match)
07:51:42 <quicksilver> hmmm
07:51:44 <fmap> @ty msum
07:51:45 <lambdabot> MonadPlus m => [m a] -> m a
07:52:00 <`ramses> > listToMaybe . catMaybes $ [Nothin, Just 3]
07:52:02 <lambdabot>   Not in scope: data constructor `Nothin'
07:52:02 <lambdabot>  Perhaps you meant `Nothing' (impor...
07:52:05 <Botje> flebron: isNothing will also evaluate the list's items to decide whether they're Just or Nothing
07:52:06 <fmap> > msum [Nothing, Just 1]
07:52:07 <`ramses> > listToMaybe . catMaybes $ [Nothing, Just 3]
07:52:07 <lambdabot>   Just 1
07:52:07 <quicksilver> `ramses has the best I think
07:52:09 <lambdabot>   Just 3
07:52:14 <quicksilver> listToMaybe . catMaybes
07:52:24 <flebron> That is true, but it will stop (I would think) once it finds the first Just.
07:52:35 <flebron> Whereas catMaybes will evaluate them all.
07:52:37 <`ramses> flebron: isn't that what you asked?
07:52:39 <quicksilver> flebron: nope.
07:52:39 <Jaak> > mplus (Just 1) (Just 2)
07:52:41 <lambdabot>   Just 1
07:52:47 <quicksilver> flebron: (catMaybes won't evaluate them all)
07:52:47 <Jaak> yeah, the msum one is neat
07:53:05 <flebron> It won't? Huh. I thought it would.
07:53:07 <quicksilver> > listToMaybe . catMaybes $ [Nothing, Just 1, error "don't evaluate me"]
07:53:09 <lambdabot>   Just 1
07:53:16 <`ramses> flebron: it's lazy
07:53:19 <quicksilver> flebron: only if you consume all its result
07:53:32 <flebron> Alright, I'll catMaybes and just not consume after the first thing. Thanks :)
07:53:49 <mSSM> If I read this correctly http://hackage.haskell.org/trac/ghc/ticket/5165 then -fexcess-precision is also depricated?
07:53:53 <quicksilver> msum is shorter
07:54:02 <quicksilver> mSSM: yes. worrying about flags is also deprecated.
07:54:05 <`ramses> flebron: catMaybes is really just (filter isJust)
07:54:35 <quicksilver> `ramses: map fromJust . filter isJust
07:54:41 <Botje> `ramses: it also unpacks the Just constructors.
07:54:51 <`ramses> ah right :)
07:54:53 <Nereid> quicksilver: gross, partial functions.
07:55:09 <quicksilver> Nereid: catMaybes is nicer.
07:55:15 <Nereid> of course.
07:55:19 <quicksilver> but nothiing wrong with using partial functions in a provably correct way.
07:55:34 <Nereid> you still have to prove it.
07:55:39 <quicksilver> I have proved it.
07:56:09 <Jaak> > asum [Nothing]
07:56:10 <lambdabot>   Not in scope: `asum'
07:56:10 <lambdabot>  Perhaps you meant one of these:
07:56:10 <lambdabot>    `Data.Foldable.asu...
07:56:20 * hackagebot yesod-platform 1.1.7 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.7 (MichaelSnoyman)
07:56:29 <Jaak> > Data.Foldable.asum [Nothing]
07:56:31 <lambdabot>   Nothing
07:57:17 <Nereid> oh, I didn't know asum existed.
07:57:25 <Jaak> > msum []
07:57:26 <lambdabot>   No instance for (GHC.Show.Show (m0 a0))
07:57:26 <lambdabot>    arising from a use of `M36314272...
07:57:33 <Nereid> > msum [] :: Maybe ()
07:57:34 <lambdabot>   Nothing
07:57:35 <quicksilver> > msum [] :: Maybe Int
07:57:36 <lambdabot>   Nothing
07:58:23 <`ramses> huh, "msum []" gives "*** Exception: user error (mzero)" in my ghci instead of that type error
07:58:36 <Nereid> sure, because ghci defaults it to IO ()
07:58:38 <Nereid> or something
07:58:52 <quicksilver> ghci has -fenable-confusing-broken-defaulting-rules
07:59:56 <`ramses> Nereid: ah indeed :) didn't know IO was a MonadPlus
08:00:54 <merijn> `ramses: That's so you can use guard in IO, I think
08:00:55 <merijn> :t guard
08:00:57 <lambdabot> MonadPlus m => Bool -> m ()
08:01:33 <Nereid> wait
08:01:36 <quicksilver> well it's not just for that reason :)
08:01:52 <Nereid> IO is an instance of MonadPlus?
08:01:53 <quicksilver> it's a MonadPlus instance for catching exceptions
08:02:00 <quicksilver> although by 'catching' I mean ignoring
08:02:16 <quicksilver> well, doing something else but not specifically handling the error
08:02:39 <`ramses> it's the "use monoid for a semi-group" thing then
08:02:42 <Nereid> oh, in Control.Monad.Error
08:02:45 <merijn> Is there a "derive whatever you can" thing?
08:03:01 <`ramses> as it does not have an mzero
08:03:17 <merijn> :t mzero
08:03:18 <lambdabot> MonadPlus m => m a
08:03:37 <`ramses> it's there but it's bottom
08:04:04 <Nereid> > msum [Nothing, Just 1, Just 2]
08:04:05 <lambdabot>   Just 1
08:04:07 <oio> i want to produce a string only until this character '|' has been found certain number of times?
08:04:38 <absence> is there a library alternative to zip that keeps the tail?
08:04:42 <`ramses> oio: you could fold the string
08:05:15 <oio> could this work ?  until :: (a -> Bool) -> (a -> a) -> a -> a
08:05:58 <`ramses> oio: if you keep state for how much '|' you've seen so far in that type a
08:06:07 <`ramses> like a tuple of a counter and the resulting string
08:06:16 <`ramses> but a fold would probably look nicer
08:06:31 <Nereid> :t split
08:06:32 <lambdabot>     Ambiguous occurrence `split'
08:06:32 <lambdabot>     It could refer to either `System.Random.split',
08:06:32 <lambdabot>                              imported from `System.Random' at State/L.hs:51:1-20
08:06:35 <int-e> @type \p f -> head . dropWhile (not . p) . iterate f -- hmm
08:06:36 <lambdabot> (b -> Bool) -> (b -> b) -> b -> b
08:06:38 <Nereid> :t Data.List.split
08:06:39 <lambdabot>     Not in scope: `Data.List.split'
08:06:39 <lambdabot>     Perhaps you meant one of these:
08:06:39 <lambdabot>       `Data.List.splitAt' (imported from Data.List),
08:06:46 <Nereid> :t Data.List.Split.split
08:06:47 <lambdabot> Splitter a -> [a] -> [[a]]
08:07:29 <charlespz> Hi. I'd like a function to convert tuples to lists, as I often find that i need to do that and pattern matching each time is verbose. I'm tying myself in knots with functional dependencies, multi param typeclasses, flexible instances and so on. Could someone take a look for me? http://hpaste.org/80805
08:08:09 <charlespz> Obviously i mean homogenous tuples
08:08:12 <oio> how " if you keep state for how much '|' you've seen so far in that type a"
08:08:18 <Nereid> > concat . take 3 . Data.List.Split.split (keepDelimsL $ oneOf "|") $ "a|b|c|d|e"
08:08:20 <lambdabot>   "a|b|c"
08:08:21 <geekosaur> charlespz, it is indeed not easily doable.
08:09:09 <Saizan> charlespz: you want instance TList (a, a) a where
08:09:14 <charlespz> geekosaur: if I know how many items i want to return, i always return a tuple, as it seems good to put that into my type system
08:09:34 <quicksilver> `ramses: I think mzero for IO() is not _|_, but throwIO "something"
08:09:52 <strebe> charlespz: you -could- just make a structured type
08:09:57 <quicksilver> throw is a bit like _|_ but it doesn't generate an exception when evaluated - only when executed.
08:10:03 <quicksilver> that's not _|_.
08:10:09 <charlespz> strebe: ah yeah, not a bad idea
08:10:31 <geekosaur> charlespz, but if you later need to use that in circumstances where a different size may be wanted, you're not actually *using* that information from the type system, you;re throwing it away
08:11:43 <charlespz> geekosaur: my use case is edges for triangles - a triangle always has three edges, but sometimes i just want to map and concat from multiple triangles, so the number of edges is not required
08:11:58 <strebe> charlespz: in general, it's easy to get carried away with types, either trying to use them so specifically it ends up costing you a lot with little gain (haskell isn't dependently typed...), or not specifically enough (more rarely an issue in haskell, but doable)
08:12:08 <geekosaur> you might represent that latter case as a list of 3-tuples then
08:12:40 <flebron> Why can it be that I ghci foo.hs, and some function defined in foo.hs is not available to me in ghci?
08:13:03 <charlespz> geekosaur: ok, i think i'll use a list and stop worrying about it
08:13:04 <Saizan> ?type listOf
08:13:04 <quicksilver> flebron: it's loading the compiled version.
08:13:05 <lambdabot>     Not in scope: `listOf'
08:13:05 <lambdabot>     Perhaps you meant one of these:
08:13:05 <lambdabot>       `lastOf' (imported from Control.Lens),
08:13:13 <Nereid> toListOf
08:13:18 <Saizan> ?type tolistOf
08:13:19 <lambdabot>     Not in scope: `tolistOf'
08:13:19 <lambdabot>     Perhaps you meant one of these:
08:13:19 <lambdabot>       `toListOf' (imported from Control.Lens),
08:13:21 <Nereid> but lambdabot doesn't have each
08:13:25 <geekosaur> flebron, if it used a compiled version then only exported functions will be available in recent ghci
08:13:26 <quicksilver> flebron: either delete the .o file, or :load *foo.hs
08:13:26 <Saizan> meh
08:13:35 <geekosaur> ^^
08:13:35 <Nereid> > toListOf both (1,2)
08:13:36 <flebron> That did it :)
08:13:36 <lambdabot>   [1,2]
08:13:44 <flebron> Thanks quicksilver
08:13:54 <Saizan> > toListOf folded (1,2)
08:13:56 <lambdabot>   No instance for (Data.Foldable.Foldable ((,) t0))
08:13:56 <lambdabot>    arising from a use of ...
08:14:00 <quicksilver> geekosaur: 'recent'?
08:14:14 <edwardk> > (1,2)^..both
08:14:15 <lambdabot>   [1,2]
08:14:19 <geekosaur> that behavior was added sometime in 7.x
08:14:26 <quicksilver> geekosaur: it goes back at least to 6.4
08:14:31 <edwardk> > ([1,2,3,4],[5,6,7,8])^..both.traverse
08:14:32 <geekosaur> um?
08:14:33 <quicksilver> probably to the dawn of the interpreter.
08:14:33 <lambdabot>   [1,2,3,4,5,6,7,8]
08:14:40 <edwardk> > ([1,2,3,4],[5,6,7,8])^.both
08:14:41 <lambdabot>   [1,2,3,4,5,6,7,8]
08:14:49 <geekosaur> loading a compiled one by default in ghci is fairly recent
08:14:50 <quicksilver> (but 6.4 was the earliest ghc I used)
08:14:55 <Nereid> > [(1,2),(3,4),(5,6)] ^.. folded.both
08:14:57 <lambdabot>   [1,2,3,4,5,6]
08:15:28 <geekosaur> (it will load compiled modules preferentially but if you explicitly load a module via ghci foo.hs ir was only in recent 7.x that it used the compiled one)
08:16:20 * hackagebot singletons 0.8.4 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.8.4 (RichardEisenberg)
08:18:11 <flebron> Is there a way of importing a module but not exporting any of its functions, save for a few I choose? (I have a very long "hiding" list for Data.Vector, due to Prelude)
08:18:20 <flebron> s/exporting/importing/
08:18:42 <Saizan> import Foo (f,g,h)
08:19:09 <flebron> That hides everything else?
08:19:13 <charlespz> flebron: with a lot of the data structure modules, the intention is that you import qualified      import qualified Data.Set as Set
08:19:28 <charlespz> flebron: as so much of them conflicts with prelude
08:19:51 <Saizan> flebron: yep
08:20:00 <geekosaur> flebron, only the specified names are imported
08:20:04 <quicksilver> geekosaur: 6.12 and 6.8 both behave that way.
08:20:17 <quicksilver> geekosaur: I don't seem to have 6.6 or 6.4 around at the moment but I remember havving this issue with them too.
08:20:26 <flebron> charlespz, but it's so ugly to type v V.! 5 :(
08:20:54 <quicksilver> flebron: you do a separate import for the operator then :)
08:21:06 <quicksilver> import Data.Vector((!))
08:21:06 <oio> how to keep count of something ?
08:21:17 <quicksilver> oio: with your fingers?
08:21:34 <oio> is not enough
08:21:37 <geekosaur> there was a change of *some* kind in the early 7.x or late 6.x series that confused a lot of people...
08:22:00 <oio> keep count of things on a list comprension
08:22:05 <geekosaur> I recall it being that explicitly loaded source always compiled before but you seem to think that has always been that way...
08:22:25 <quicksilver> well that was my memory and I just tested 6.12 and 6.8
08:22:45 <quicksilver> oio: list comps don't keep count of how far they are down the list
08:22:52 <quicksilver> you'd have to count externally somehow
08:23:00 <quicksilver> can you be more specific
08:23:02 <quicksilver> ?
08:23:52 <oio> i have this string "Pregunta |Resp1 |Resp2 |Resp3 |Resp4 |NumRespCorrect" 	quest1 <- getLine
08:24:01 <`nand`> > [show n ++ ": " ++ show x | x <- "hello" | n <- [1..]]
08:24:03 <lambdabot>   ["1: 'h'","2: 'e'","3: 'l'","4: 'l'","5: 'o'"]
08:24:21 <merijn> mm_freak: Did you have documentation behind the Hackage text of Control.Wire somewhere?
08:24:27 <oio> this string* "Pregunta |Resp1 |Resp2 |Resp3 |Resp4 |NumRespCorrect"
08:24:32 <Nereid> oio: why not split at the '|'s?
08:25:16 <oio> wait
08:25:28 <oio> then put the first part
08:25:30 <Nereid> > splitOn "|" "a|bc|def|g"
08:25:31 <lambdabot>   ["a","bc","def","g"]
08:25:40 <oio> pnpr xs = takeWhile (/= '|') xs
08:25:57 <oio> Pregunta
08:26:45 <hpaste> flebron pasted “Style suggestions?” at http://hpaste.org/80807
08:27:24 <oio> then display the Resp part according to the number of '|' - 1
08:29:34 <`ramses> quicksilver: ah, ok, I have yet to look at exceptions in haskell.. :) but that makes more sense for IO's mzero
08:30:43 <quicksilver> > (fail "hi" :: Int -> Int) `seq` 1
08:30:45 <lambdabot>   *Exception: hi
08:30:51 <quicksilver> > (fail "hi" :: IO ()) `seq` 1
08:30:52 <lambdabot>   1
08:31:00 <quicksilver> `ramses: ^^ key difference
08:31:13 <tac> > [fail "head", fail "tail"] `seq` Nothing
08:31:14 <lambdabot>   Ambiguous type variable `m0' in the constraint:
08:31:15 <lambdabot>    (GHC.Base.Monad m0) aris...
08:31:19 <tac> > [fail "head", fail "tail"] `seq` 1
08:31:20 <lambdabot>   Ambiguous type variable `m0' in the constraint:
08:31:20 <lambdabot>    (GHC.Base.Monad m0) aris...
08:31:30 <Nereid> > [undefined] `seq` ()
08:31:30 <quicksilver> tac: you have to tell it which fail you're using.
08:31:31 <lambdabot>   ()
08:31:35 <tac> > [error "head", error "tail"] `seq` 1
08:31:36 <lambdabot>   1
08:31:49 <Nereid> > [undefined] `deepSeq` ()
08:31:51 <lambdabot>   Not in scope: `deepSeq'
08:31:51 <lambdabot>  Perhaps you meant `rdeepseq' (imported from Contro...
08:31:54 <Nereid> bleh
08:32:14 <Nereid> I got the case wrong anyway.
08:32:38 <`ramses> quicksilver: so the exception gives rise to an error only if it ends up in main ?
08:33:00 <Nereid> no, only if it gets executed.
08:33:31 <`ramses> isn't that the same? IO actions get executed when they end up in main, don't they?
08:33:46 <quicksilver> for a very weak notion of "end up in", yes.
08:33:57 <quicksilver> but exceptions don't always give rise to errors
08:34:00 <quicksilver> only uncaught ones.
08:34:19 <`ramses> yeah, I'm not being overly precise but I think we mean the same thing :)
08:34:32 <quicksilver> in the same sense that the entirety of a large C program "ends up in" main() :-)
08:34:46 <quicksilver> or perhaps I mean, just, the execution trace of...
08:35:23 <mSSM> Is it possible to construct an (immutable) vector from a Data.Map?
08:35:36 <Nereid> a vector of what?
08:35:56 <mSSM> Nereid: a vector where the key corresponds to the index, and the value to the element at that indedx
08:36:14 <`ramses> quicksilver: how would you put the condition for an IO action to actually get executed then? any haskell program is eventually one big IO action, isn't it?
08:36:48 <`ramses> people corrected me more then once here when I used the word "execution", saying nothing gets executed in haskell, only "applied"
08:37:19 <tromp_> the runtime system sure executes IO actions
08:37:53 <quicksilver> `ramses: I'm not sure why I'd be tryign to construct that condition.
08:38:02 <quicksilver> `ramses: what other languages are you familiar with?
08:38:09 <`ramses> tromp_: certainly, the question is what gets executed and what doesn't
08:38:17 <quicksilver> How would you write the condition for a line of perl/java/C/python to actually get executed?
08:38:37 <quicksilver> I mean this is a complex condition, really? It gets executed if program execution gets to that place....
08:38:56 <`ramses> quicksilver: the usual suspects, c, java, python, ruby, ...
08:39:00 <quicksilver> the difference in haskell is not the condition for a line of code to be executed
08:39:04 <quicksilver> that's much the same as any other
08:39:15 <quicksilver> the difference is actually in this *other* notion of evaluated
08:39:24 <quicksilver> it's evaluated that contains the difference
08:39:37 <`ramses> ok, maybe I'm having these strange thoughts due to some people making it unnecessary difficult in here :)
08:39:38 <quicksilver> what with evaluation being pure and referentially transparent &c &c
08:39:44 <`nand`> mSSM: vectors (as in Data.Vector) have a contiguous range of integers as index
08:39:59 <`nand`> mSSM: so what would any such function do for keys which are missing?
08:40:03 <quicksilver> so, it's true that every haskell program has a symbol 'main' and than main evaluates to an IO action
08:40:07 <tromp_> all the primitive IO actions that comprise main get executed
08:40:14 <quicksilver> and that that IO action describes the IO stuff which gets executed
08:40:26 <Nereid> `nand`: Array has such a function, namely, array; it puts undefined in the remaining places.
08:40:29 <quicksilver> but they're no more "in main" than every line of a C program is "in main()"
08:40:43 <Nereid> :t array
08:40:45 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
08:40:52 <`ramses> quicksilver: no, I indeed meant it as in the c case
08:40:59 <tromp_> but that's only defined once the program is done running:)
08:41:23 <Nereid> anyway
08:41:38 <Nereid> for vector, you can update with an assoc list with (//)
08:41:39 <`nand`> Nereid: if you want undefined, you can mix ‘replicate’ with unsafeLookup (or whatever)
08:41:46 <`nand`> err
08:41:48 <`nand`> not replicate, generate
08:41:52 <Nereid> :t (Data.Vector.//)
08:41:53 <lambdabot> Data.Vector.Vector a -> [(Int, a)] -> Data.Vector.Vector a
08:42:02 <`nand`> ah, or that
08:42:14 <`ramses> maybe I'm overthinking this, as it is actually quite clear to me, it's just a matter of phrasing it correctly
08:42:16 <Nereid> so start with a default vector, and update it.
08:42:21 <Nereid> mSSM: ^
08:42:34 <Nereid> oh, and use Map.toList to get such a thing out of your Map
08:42:56 <`ramses> tromp_: of course it will depend on runtime conditions in the end, but that's not really relevant here I think
08:43:09 <beaky> what is haskell very good at?
08:43:17 <Nereid> a lot of things.
08:43:22 <S11001001> fibonacci sequence
08:43:22 <beaky> that makes it curb-stomp languages like C++ or Java
08:43:33 <quicksilver> `ramses: probably. I have the strong impression you do understand it also :)
08:43:49 <Nereid> it's much more pleasant to use haskell than those languages?
08:43:51 <beaky> ah
08:44:01 <quicksilver> `ramses: "lies to schoolchildren" can be useful for explaining things and it's probably unfair of me to attack them so pedantically.
08:44:03 <`nand`> haskell is a very good language for presenting the first few numbers of the fibonacci sequence over IRC
08:44:06 <beaky> lol
08:44:15 <Nereid> > fix$(0:).scanl(+)1
08:44:16 <lambdabot>  Terminated
08:44:19 <beaky> and writing a one-liner quicksort
08:44:22 <Nereid> > fix$(0:).scanl(+)1
08:44:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:44:28 <mSSM> `nand`: thing is that I don't need the continuous range; I can be sure that my program never accesses those missing indices
08:44:44 <mSSM> `nand`: I just need O(1) lookup time instead of O(nlogn)
08:44:50 <`ramses> quicksilver: I don't understand what you mean by that last one?
08:45:10 <`ramses> where do the schoolchildren come from? :)
08:45:16 <beaky> how is babby formed?
08:45:19 <Nereid> mSSM: Map lookup time is log n, not n log n
08:45:35 <beaky> is it possible for Map lookup to be O(1)?
08:45:38 <Eduard_Munteanu> mSSM: building the vector is going to be O(n) anyways.
08:45:43 <Nereid> beaky: there are hash maps
08:45:45 <quicksilver> `ramses: it relates to a teaching technique where it is much simpler to say something which is not entirely true, but helps explanations.
08:45:46 <beaky> ah
08:45:55 <quicksilver> `ramses: because you can always learn the more complex stuff later.
08:46:09 <`ramses> quicksilver: ah ok :) yeah I think that does apply to learning haskell
08:46:17 <tromp_> haskell is bad for writing buggy code though
08:46:18 <quicksilver> `ramses: for example, to teach newtonian physics without worrying about relativistic effects, etc.
08:46:24 <mSSM> Eduard_Munteanu: n is 5, but I have 10^5 calls to lookup
08:46:25 * flebron is happy that haskell is becoming his go-to scripting language, as opposed to python
08:46:51 <`ramses> quicksilver: I'm actually quite familiar with that one as a theoretical physicist :)
08:46:53 <beaky> I still like python better for scripting :(
08:46:55 <mSSM> Eduard_Munteanu: so, making the vector is cheaper than lookup
08:47:05 <beaky> because of the library support for stuff
08:47:16 <flebron> haskell has quite a large library :)
08:47:17 <Nereid> mSSM: if you have the option, consider using a different structure like IntMap maybe
08:47:24 <Eduard_Munteanu> mSSM: log(10^5) = 5 :)
08:47:26 <Nereid> which has bounded-time lookup
08:47:43 <Nereid> although in practice log(n) is bounded too
08:47:44 <mSSM> Eduard_Munteanu: 10^5 * log(5) ;)
08:47:47 <quicksilver> `ramses: lucky choice :)
08:47:53 <beaky> does haskell have something like numpy?
08:48:13 <Eduard_Munteanu> Though that's the wrong argument to log.
08:48:38 <mSSM> Eduard_Munteanu: isn't n the size of the map structure?
08:48:43 <Eduard_Munteanu> Fair, makes sense.
08:48:56 <flebron> beaky, large integers are supported out of the box
08:49:11 <Eduard_Munteanu> mSSM: yeah, my mind was somewhere else.
08:49:39 <beaky> what about huge matrices?
08:49:42 <flebron> (there's hmatrix for the linear algebra stuff)
08:49:43 <mSSM> Nereid: Is vector able to handle negative Ints ?
08:49:45 <beaky> ah thanks
08:49:55 <beaky> and plotting? :D
08:50:12 <beaky> imagine making my number crunching code purely functional :D
08:50:18 <Nereid> mSSM: vector indexes are nonnegative.
08:50:20 <flebron> there's also numkell as a clone of numpy
08:50:31 <flebron> but i think hmatrix is more maintained
08:50:33 <mSSM> Nereid: that's a shame :(
08:50:41 <Nereid> is it?
08:50:56 <Nereid> indices*
08:51:26 <flebron> beaky, haskell has an interface to gnuplot
08:51:28 <mSSM> Nereid: yeah, that way I have to add and subtract the absolute of my lowest negative value
08:51:54 <mSSM> Nereid: index*
08:52:17 <Nereid> well, you'll have to deal with it  then
08:53:11 <quicksilver> not hard to write a transaltion layer for indices
08:53:19 <quicksilver> and support N-dimensions and slicing at the same time.
08:53:27 <quicksilver> I'm somewhat surprised if there isn't already one
08:53:51 <Nereid> mSSM: fwiw, Array lets you use arbitrary ranges for indices.
08:54:35 <Nereid> although Vector is supposed to be faster?
08:54:44 <Nereid> well
08:54:50 <Nereid> I dunno.
08:55:36 <fragamus> UH do you guys know where the README file ends up after installing a package
08:56:06 <Nereid> nowhere, unless the .cabal file says to put it somewhere.
08:56:17 <fragamus> kk
08:59:01 <Nereid> hmatrix is GPL? :/
08:59:10 <Nereid> I guess, if it uses GSL.
08:59:26 <mSSM> Nereid: cool, thanks
09:01:15 <Nereid> also, whoever was asking about making an array out of a C pointer a while ago
09:01:33 <Nereid> there's a StorableArray that lets you do just that.
09:02:37 <Nereid> ah, he's gone.
09:02:41 <Nereid> and was answered anyway
09:11:02 <chukcha> @help
09:11:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:11:15 <chukcha> @list
09:11:15 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:15:41 <chukcha> fmap (+10000) (Bankaccount 1)
09:19:30 <Lethalman> what's the reason why you haskellers use git instead of darcs?
09:19:45 <Lethalman> is it only because it's more used or any other reason?
09:19:54 <Philonous> Lethalman:  github
09:19:58 <Lethalman> more hosting etc.
09:20:17 <Lethalman> Philonous, ok
09:20:21 <Philonous> Lethalman:  Also, some people actually use darcs.
09:21:15 <n-dolio> I use darcs.
09:21:38 <Eduard_Munteanu> I think I like git more, but I haven't used darcs a lot.
09:21:59 <strebe> I use darcs as well as git. There are a number of reasons to prefer git, including it handling some use cases darcs is bad at, scaling better, etc
09:22:01 <Lethalman> looks like darcs.net offers hosting... will try it a day
09:24:48 <elliott> Lethalman: GHC used to be in darcs.
09:24:59 <elliott> But at one point darcs was really slow in certain scenarios and also generally just not very popular.
09:25:08 <elliott> So they switched.
09:25:38 <Lethalman> elliott, thanks for the hint
09:29:50 <tommd> msg :: Ping Tibbe
09:29:57 <tibbe> tommd: you called
09:30:09 <tommd> Do you have a release date planned for network?
09:30:17 <tommd> I'm looking to use sendBuf/recvBuf in anger.
09:30:48 <tibbe> tommd: sure, could you shoot me an email reminder, I can likely do it today
09:30:53 <tommd> Will do.
09:30:54 <tommd> Thanks!
09:32:35 <wuttf> I think having a central pkg database (hackage) is such a big feature of the Haskell platform
09:33:03 <wuttf> In other platforms, I have to install git, darcs, mercurial, bazaar, svn etc
09:33:09 <wuttf> *On
09:33:10 <lispy> wuttf: not sure what you mean. the HP and hackage are unrelated.
09:33:53 <wuttf> lispy: I don't really get what you don't get =)
09:33:53 <lispy> (or maybe you don't mean the Haskell Platform http://www.haskell.org/platform/)
09:34:24 <wuttf> Well yes, not that platform, more like in the general sense.
09:34:29 <lispy> ah
09:34:53 <wuttf> Sorry my English is really rusty, especially when I am tired.
09:35:42 <b52> 3 http://hpaste.org/report/76712 anyone?
09:35:54 <Dodek> wuttf: other languages have facilities comparable to hackage/cabal
09:36:19 <wuttf> Is it possible to analyze and traverse an arbitrary data structure with haskell? Like, a record in a record containing tuples containging records ... etc
09:37:09 * Lethalman I guess nobody will answer to that question... it's so direct compared to others that have the same answer :P
09:37:15 <wuttf> Dodek: I come from Go and there is no central repo there. You have to install VCSs to issue "go get"
09:37:44 <Dodek> wuttf: i guess the first was perl's CPAN
09:38:00 <Dodek> wuttf: but then, python and ruby have their stuff too.
09:38:12 <Dodek> wuttf: even common lisp got recently quicklisp
09:38:50 <`ramses> clojure has something comparable as well, and maven gives comparable features to, a.o., java
09:38:53 <glguy> wuttf: We have various generics and generic traversals and traversal building libraries
09:39:04 <wuttf> Dodek: Seems like I come from immature languages then =)
09:40:17 <tac> We also have data structures so bizarre, no mortal has ever traversed them and lived to tell the tale.
09:40:19 <lispy> Dodek: and ocaml has opam now
09:40:25 <wuttf> tac: :D
09:41:23 * hackagebot cipher-aes128 0.2 - AES128 using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.2 (ThomasDuBuisson)
09:41:25 * hackagebot readable 0.1.0.1 - Reading from Text and ByteString  http://hackage.haskell.org/package/readable-0.1.0.1 (DougBeardsley)
09:42:00 <`ramses> tac: the last element of [1..] is truly magical according to the myths
09:42:49 <HugoDaniel> is it possible to have data D = D (a, b) without puting a and b as type vars ?
09:43:13 <HugoDaniel> or with GADTs: data D where D :: (a, b) -> D
09:43:27 <danr> HugoDaniel: yes, they will be existentially quantified
09:43:43 <HugoDaniel> danr: ok, then is it possible to pattern match it ?
09:43:46 <`ramses> HugoDaniel: you wont be able to put anything in it though, I think
09:43:59 <HugoDaniel> i can construct it, but i cannot deconstruct it and fetch the tuple
09:44:17 <danr> HugoDaniel: correct
09:44:17 <`ramses> HugoDaniel: it's the other way around, you can destruct it but not construct it
09:44:22 <oio> is there a way to join ["abc","abc","abc"] and ["1)","2)","3)"] into ["1)abc","2)abc","3)abc"]
09:44:23 <`ramses> oh, really?
09:44:29 <danr> well, let's try
09:44:39 <`ramses> oio: zipWith (++)
09:44:41 <HugoDaniel> D (1,'a') should work :/
09:45:02 <HugoDaniel> but formD (D (a, b)) = (a,b) doesn't work
09:45:13 <danr> yeah
09:45:31 <HugoDaniel> can i make it work ?
09:45:48 <HugoDaniel> by specifying default values ?
09:46:11 <`ramses> seems I need to read up on existensials :s
09:47:17 <danr> HugoDaniel: maybe this will interest you: http://hpaste.org/80810
09:47:46 <danr> then you can pattern-match on your mysterious types
09:48:26 <int-e> b52: this sounds like your problem (same symptoms): http://sourceforge.net/tracker/index.php?func=detail&aid=3576397&group_id=73133&atid=536845
09:49:24 <b52> int-e: still no fix or somethin though
09:49:38 <bxc> danr: starting to look like agda..
09:49:58 <int-e> b52: read closely, the author describes what (s)he did to make it compile
09:50:08 <danr> bxc: ssh, you're exposing me :H)
09:50:31 <int-e> b52: (near the end of the post)
09:50:35 <danr> hmm that was supposed to be a :)
09:50:48 <HugoDaniel> danr: thanks, i am already using something similar but ghc isn't letting me use it :)
09:50:57 <int-e> danr: ssh is supposed to be encrypted.
09:51:04 <HugoDaniel> my idea is that i can later have stuff :: [D]
09:51:04 * int-e ducks
09:51:16 <danr> int-e: haha, yeah I though so too
09:51:32 <tibbe> tommd: thanks
09:51:34 * danr encourages puns
09:53:03 <Eduard_Munteanu> funpuns
09:53:07 <k00mi> HugoDaniel: you want heterogenous lists?
09:53:19 <gwern> :t \n b -> take n $ repeat b
09:53:21 <lambdabot> Int -> a -> [a]
09:53:56 <danr> too general type! lambdabot should be able to understand that b obviously stands for a Bool
09:54:17 <oio> it wotked thnanks
09:54:31 <HugoDaniel> k00mi: yes, but with all the type vars hidden :)
09:54:34 <oio> it is possible to use haskell without if then else ?
09:54:50 <S11001001> oio: you can patmat True, False, at minimum
09:55:04 <mSSM> How can I use the binary - operator for currying? E.g., I want to do something like `map (-8) [1,2,3]
09:55:06 <mSSM> '
09:55:07 <danr> oio: yeah and there are also guards
09:55:14 <danr> mSSM: use subtract instead
09:55:20 <k00mi> HugoDaniel: there are some implementations for that, did you search in the haskell wiki?
09:55:33 <oio> mmm ok ;D
09:55:37 <danr> @src subtract
09:55:37 <lambdabot> subtract x y = y - x
09:55:37 <HugoDaniel> k00mi: no, im currently using a mix of GADTs and type families
09:55:39 <mSSM> danr: thanks
09:55:57 <danr> np
09:58:18 <HugoDaniel> danr: you rock, im going to try specifying the tuples as you pasted
09:59:11 <k00mi> HugoDaniel: Data.Dynamic does what you want (if you don't want to do it yourself)
10:01:07 <HugoDaniel> k00mi: thanks :D
10:01:23 * hackagebot wl-pprint-terminfo 3.4 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.4 (EdwardKmett)
10:01:25 <HugoDaniel> whats the catch with dynamic ?
10:01:39 <HugoDaniel> ok, my data types need to be an instance of Typeable
10:02:12 <k00mi> exactly
10:03:53 <elliott> the catch is it's not very useful
10:06:05 <k00mi> how that? i never used it, just found it on the wiki
10:09:13 <`ramses> oio: no reason not to use if-then-else if it does what you need, though
10:17:04 <HugoDaniel> does this make sense: classe MyType a where data MyT a :: * ?
10:17:38 <mm_freak> merijn: what do you mean?
10:18:37 <mm_freak> HugoDaniel: it will be accepted by the compiler
10:18:54 <HugoDaniel> sorry, i mean having a type family with kind *
10:19:16 <mm_freak> the type family doesn't have kind *
10:23:16 <hpaste> glguy pasted “for HugoDaniel” at http://hpaste.org/80813
10:24:38 <oio> how to make an infinite list of one character
10:24:53 <mSSM> Is haskell able to handle unicode in e.g. variable declarations? What would happen if I say something like µ = 2
10:25:07 <HugoDaniel> :)
10:25:08 <HugoDaniel> thanks
10:25:08 <oio> ['(','('..]
10:25:09 <mSSM> And then `let µ' = µ^2'
10:25:43 <glguy> mSSM: What happened when you tried that in GHCi?
10:26:40 <mSSM> glguy: ghci liked it
10:27:00 <beaky> why is programming in haskell so much nicer than in java?
10:27:19 <Lethalman> beaky, because of type inference :S
10:27:25 <Lethalman> :P
10:27:29 <beaky> ah
10:27:34 <S11001001> because of all the neat ways to get the fibonacci sequence
10:27:50 <beaky> lol
10:29:01 <zeiris> because you're not forced to do useful things
10:29:10 <mm_freak> oio: repeat '('
10:29:13 <zeiris> avoid "success at all cost"! :)
10:29:16 <mm_freak> > repeat '('
10:29:16 <beaky> <sarcasm>seems that all Haskell can do is generate fibonacci sequences and infinite trees</sarcasm>
10:29:17 <dgpratt> because you don't have to program in the IO Monad all the time
10:29:17 <lambdabot>   "((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((...
10:29:23 <oio> yeah it worked
10:29:45 <applicative> mSSM: in theory it should accept anything that counts as 'upper case' and 'lower case' in unicode -- in the appropriate conditions
10:30:19 <beaky>  i am porting my C++ homework to haskell :D
10:30:35 <beaky> then submitting the haskell binary as the assignment
10:31:29 <mSSM> glguy: ghci liked it
10:31:31 <WaffleCat> I'm having trouble understanding this pattern match https://github.com/xmonad/xmonad/blob/master/XMonad/Config.hs#L165 -- XConfig is constructor specified with record syntax, but its definition includes much more than just modMask (https://github.com/xmonad/xmonad/blob/master/XMonad/Core.hs#L94)
10:31:37 <mSSM> glguy: sorry, didn't mean to post it twice
10:32:01 <mSSM> applicative: So I could in theory dump the entire unicode alphabet in there?
10:32:22 <mSSM> applicative: would be very nice to have the greek alphabet available to call e.g. constants
10:32:46 <mm_freak> beaky: make sure to find an excuse for the huge binary
10:32:58 <beaky> C++ binaries are larger
10:33:12 <mm_freak> beaky: i think you haven't compared
10:33:17 <beaky> ah
10:33:18 <Philonous> WaffleCat:  Record syntax allows you to match on a subset of the fields
10:33:22 <applicative> > filter isLower [minBound..maxBound]
10:33:23 <lambdabot>   "abcdefghijklmnopqrstuvwxyz\170\181\186\223\224\225\226\227\228\229\230\231...
10:34:12 <applicative> mSSM: in Data.Char there is 'generalCategory', I think ghc -- maybe Haskell 2010 -- uses that classification, but I'm not sure how.
10:34:21 <oio> could someone fix this
10:34:21 <oio> addnum xs i = zipWith (++) ( zipWith (++) (take i (repeat ")")) (take i [1..])) xs
10:34:27 <Philonous> WaffleCat:  The remaining fields a just ignored.
10:34:31 <Philonous> are*
10:35:10 <WaffleCat> Philonous: Ah, thanks!
10:37:24 <glguy> > let f n = take n $ map (\i -> show i ++ ")") [1..] in f 10
10:37:25 <lambdabot>   ["1)","2)","3)","4)","5)","6)","7)","8)","9)","10)"]
10:37:31 <glguy> oio: ^
10:38:28 <oio> it works but i dont know how = thnx
10:40:27 <beaky> how do i inherit from a typeclass
10:40:51 <Philonous> beaky:  Haskell is not object oriented
10:40:57 <beaky> ah
10:41:20 <zomg> beaky: you can add a constraint so that anything that implements typeclass A also must implement typeclass B
10:41:48 <glguy> You can't just map "C++ class" to "Haskell typeclass". They're pretty different
10:42:09 <zomg> Yeah I'd think of typeclasses more like interfaces
10:42:15 <mm_freak> beaky: a class in C++ is more like a type in haskell
10:42:25 <beaky> so it's like data
10:42:29 <applicative> beaky: one type class can have another as a constraint.
10:42:30 <mm_freak> yes
10:42:38 <applicative> @src Applicative
10:42:38 <lambdabot> class Functor f => Applicative f where
10:42:38 <lambdabot>     pure  :: a -> f a
10:42:38 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
10:42:49 <beaky> oh
10:42:52 <applicative> beaky: as ^^ Functor is presupposed by Applicative
10:42:54 <mm_freak> data A = A; data B = B A
10:42:59 <beaky> wow didnt know you can do that
10:43:12 <Lethalman> beaky, lyah says that
10:43:22 <applicative> @src Ord
10:43:22 <lambdabot> class  (Eq a) => Ord a  where
10:43:22 <lambdabot>     compare      :: a -> a -> Ordering
10:43:22 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
10:43:22 <lambdabot>     max, min         :: a -> a -> a
10:43:37 <applicative> and Eq is presupposed by Ord, or I guess 'extends' it
10:43:57 <beaky> i heard i should prefer data over typeclasses thouugh
10:43:59 <Lethalman> the problem comes with multiple type parameters, there you can't say extend anymore
10:44:07 <beaky> when i want polymorphic behaior
10:44:28 <applicative> yes, making up a new class is a dangerous act, generally
10:44:37 <zomg> beaky: let's just say I've written several sort-of-complex haskell apps and I haven't needed to define my own typeclasses :)
10:45:33 <mm_freak> beaky: think of type class instances as something global…  if you ever define an instance, it should be universal
10:45:43 <mm_freak> like Int is always a Num with the given semantics
10:45:45 <mm_freak> for everyone
10:46:15 <glguy> beaky: you don't pick between data and typeclass. Data goes in data
10:46:17 <mm_freak> i wrote huge libraries without defining a single type class in them
10:46:25 <beaky> how did languages without typeclasses (but with ADTs and first-class functions) fare without them?
10:46:39 <mm_freak> beaky: by defining helper types
10:47:02 <mm_freak> beaky: Num can be implemented as a type:  data Num a = Num { plus :: a -> a -> a, minus :: a -> a -> a, … }
10:47:12 <mm_freak> beaky: then "Num a =>" becomes "Num a ->"
10:47:32 <beaky> ah
10:47:56 <qwr> you can view that helper type as a first-class module
10:48:03 <beaky> do auxiliary types liek taht cluter things?
10:48:07 <beaky> like that clutter*
10:48:24 <mm_freak> beaky: no, they usually just turn your classy functions into higher order functions
10:48:29 <mm_freak> beaky: sort vs. sortBy
10:48:31 <qwr> what type-class provides, is that you can import the functions from module signature into your namespace
10:48:39 <beaky> ah
10:49:07 <pmade> Is there an IRC channel for the ghc-ios project?
10:49:22 <beaky> wow I can use Haskell to make iPhone apps?
10:49:42 <S11001001> beaky: you want to make iphone apps?
10:49:44 <pmade> beaky: That's my understanding, yes.
10:49:56 <srhb> Fairly sure it's not a pain-free experience though.
10:50:28 <pmade> https://github.com/ghc-ios/ghc/wiki
10:50:31 <beaky> I always wanted to build iPhone apps, but everytime I read some blogpost about obj-c and iphone programming under the mvc paradigm it seems more difficult to grasp than category theory
10:50:34 <applicative> beaky: I think write the app in javascript, and a web service in haskell....
11:00:18 <beaky> is it a good idea to use the `type` keyword?
11:00:28 <beaky> to treat functions as data types?
11:00:52 <c_wraith> The type keyword doesn't actually do that.
11:01:08 <beaky> ah
11:01:21 <c_wraith> newtype will do that
11:01:27 <glguy> "type" just gives a name to a type. If you're writing that type out a lot of you can name the pattern
11:01:28 <c_wraith> and newtyping a function is very common
11:01:31 <Philippa_> it's a good idea to use it if you weren't going to do something more typeful, because at least it lets you document what you're using types for
11:01:46 <Philippa_> (then you can turn it into a newtype later and the typechecker will throw errors in all the right places!)
11:02:02 <beaky> I've been using type a lot
11:02:11 <Philippa_> it's also good for readability if you've got some big types
11:02:25 <beaky> lets see what happens when I do %s/type/newtype/g and try to build the thing
11:02:29 <Philippa_> (also good for accidentally introducing polymorphic recursion - favourite way I've shot myself in the foot with the typechecker to date, that)
11:03:01 <beaky> what's polymmorphic recursion? that sounds like the perfect blend of OOP and FP
11:03:04 <Philippa_> what'll happen is you'll get a ton of errors telling you that you need to say "I want it to be the newtype here"
11:03:05 <beaky> polymorphic*
11:03:19 <Philippa_> it's where a polymorphic function calls itself, but for a different type
11:03:33 <c_wraith> MLs forbid polymorphic recursion.
11:03:40 <c_wraith> Haskell allows it, but only with a type signature
11:03:44 <beaky> haskell has polymorphic functions?
11:04:07 <`ramses> beaky: parametric polymorphism
11:04:12 <`ramses> :t sum
11:04:13 <lambdabot> Num a => [a] -> a
11:04:20 <`ramses> the a there is polymorphic
11:04:35 <lispy> :t id
11:04:37 <lambdabot> a -> a
11:04:58 <lispy> (just an example showing parametric polymorphism without type classes)
11:05:06 <beaky> ah
11:05:15 <beaky> looks like C++ templates :D
11:05:19 <Taneb> :t length
11:05:21 <lambdabot> [a] -> Int
11:05:55 <Philippa_> C++ templates look like a lousy version of this conflated with ML modules :p
11:06:28 <Taneb> I can think of one thing that C++ does better than Haskell
11:06:36 <Taneb> That is, be C++-ish
11:07:05 <lispy> beaky: kind of. template let you specialize on the type parameter (we can't do that) and we can make arguments about what a function does by using properties of thet type being parametric (for example with the type of id, we know that the function is either broken or doesn't inspect the value)
11:07:14 <HugoDaniel> C++ sucks more than haskell, hence its better than haskell at sucking
11:07:34 <elliott> I wish we had something conflated with ML modules.
11:07:51 <Philippa_> elliott: I just wish we had ML modules
11:10:00 <napping> Are there versions of Map which carry around the comparison function?
11:10:38 <Philippa_> napping: that's the way it's normally done in ML. Can't really do it 'well' in Haskell because you want the type to contain the comparison function
11:10:51 <beaky> hmm how do i achieve something liek C++'s template specialization in haskell
11:10:53 <beaky> like*
11:10:54 <napping> I've been reading some stuff about the design of typeclass-like features, and it seems to me the main loss from having locally scoped instances would be not knowing whether the current Ord is the same as the one it was constructed under
11:11:04 <beaky> I guess typeclasses or higher-order functions are the way to do it
11:11:21 <Philippa_> beaky: right
11:11:37 <Philippa_> (typeclasses are arguably syntactic sugar for "fill in the HOF parms like this...")
11:11:52 <Philippa_> napping: yep. Which is a major thing to lose
11:11:54 <napping> Philippa_: if you just care that you have a balanced tree you could get some use out of a type that's just Map a, and known to contain *some* total order
11:12:11 <Philippa_> napping: yeah, the read-only version's fine
11:12:26 <napping> or just add dependent types and index by the Ord instance
11:12:43 <Philippa_> you don't need full dependent types for that, either
11:13:02 <Philippa_> instances are their own sort, you just insist that there's no such thing as an 'anonymous instance'
11:13:07 <frerich__> Hm does anybody have some tips with using ByteStrings? For instance, I have 'import qualified Data.ByteString.Lazy.Char8 as BS' and been using that all the tip. Now I have some call 'BS.unpack url' call which fails because the function expects a BS.ByteString (So far, so good) but 'url' happens to be a "Data.ByteString.Internal.ByteString". According to the docs I should be getting just a 'ByteString', but it didn't say which...
11:13:22 <frerich__> FWIW this 'url' is the second element of the 'Header' tuple as documented at http://hackage.haskell.org/packages/archive/http-types/0.7.3.0.1/doc/html/Network-HTTP-Types-Header.html#t:Header
11:14:04 <napping> well, you need a type parameter that uniquely determines the function to use. If you are entirely dropping globally scoped typeclass things, it seems the parameter must be (some lifting of) the actually functions
11:14:05 <oio> lol my first haskell program opinions?
11:14:08 <hpaste> OiO pasted “First Prog” at http://hpaste.org/80817
11:14:11 <frerich__> Data.ByteString.Internal.ByteString seems 'internal
11:14:18 <geekosaur> frerich, thqat would be a strict ByteString since the full type doesn't point to the Lazy variant
11:14:36 <frerich__> geekosaur: Aaaah...
11:14:55 <frerich__> geekosaur: That's good to know, I should click the ByteString links to figure out *which* ByteString it is.
11:15:25 <frerich__> geekosaur: Thanks a lot, I guess I should figure out how to convert a lazy BS to a, well, non-lazy one.
11:15:27 <Philippa_> napping: it's enough for them to be globally /nameable/. The instances, that is - not the individual functions
11:15:52 <Philippa_> you end up with the constraint solver/instance dispatch hint being what's scoped
11:16:05 <Philippa_> (or to put it another way, you end up with a module language)
11:17:10 <Philippa_> (one that's nominal types only, so MLers will still complain, but hey :p )
11:19:19 <napping> that should do it
11:19:19 <napping> get a new thing-that-can-be-mentioned in types with the instance declaration, make sure there's no way to forge them
11:19:19 <napping> okay, I'm sold
11:21:06 <hpaste> beaky pasted “toy example” at http://hpaste.org/80818
11:21:23 <beaky> in that toy example, how do I annotate n?
11:21:29 <beaky> as Int?
11:22:01 <glguy> you could change "case n :: Int of"
11:22:31 <HugoDaniel> how is the syntax to use deriving in a type family declaration ?
11:22:33 <napping> Philippa_: I think a little sugar would preserve current types, like implicitly generating fresh names for anything mentioned in the prefix, and filling them in - (Ord a) => Map a -> Map a -> Map a short for (oa::Ord a) => Map oa a -> Map oa a -> Map oa a
11:22:37 <beaky> ah
11:23:20 <Philippa_> napping: only works when you're only using one instance at a time, but yeah
11:23:42 <Philippa_> (it should be inferrable /from Map's type/)
11:23:51 <Philippa_> (which, er, has a pi in it now)
11:24:06 <elliott> HugoDaniel: deriving howso?
11:24:36 <HugoDaniel> class MyD k where data MyT :: * deriving (Show) ?
11:25:33 <HugoDaniel> ghc docs have the syntax for data family but not for class
11:25:44 <HugoDaniel> here: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/type-families.html
11:25:53 <hpaste> wilfred pasted “attempting to install cabal-dev” at http://hpaste.org/80819
11:26:33 <wilfredh> I'm looking to install cabal-dev to so I can install some interesting Haskell projects without dependency issues
11:26:55 <wilfredh> sadly, I get the error http://hpaste.org/80819 upon `cabal install cabal-dev`. How should I resolve this?
11:27:12 <HugoDaniel> wilfredh: have you read this: http://bob.ippoli.to/archives/2013/01/11/getting-started-with-haskell/ ?
11:27:19 <wilfredh> I'm nervous that ghc would be broken with a --force-reinstalls
11:27:22 <napping> Philippa_: I think you might not even lose the current representation - if the instance becomes an implicit type-ish parameter, then that application could still be compiled to dictionary passing
11:27:28 <glguy> wilfredh: The cabal-dev on hackage doesn't work with GHC 7.6.1
11:27:48 <Philippa_> napping: yep, you can /always/ compile modules down to dictionary/structure-passing
11:28:37 <napping> well, my first thought was to make the maps existential and carry around there own functions, but it seems indexing them is enough to make it safe to leave the functions global
11:28:41 <HugoDaniel> yes
11:29:14 <napping> the paper is "The Implicit Calculus", by the way. A nice simple core calculus for type-directed instantiation, with some fancy features like higher-order rules
11:29:18 <wilfredh> glguy: is there a newer version of cabal-dev somewhere else?
11:29:54 <beaky> was the haskell language inspired by the pascal programming language in any way?
11:30:14 <glguy> wilfredh: There is the git repository which has some updates https://github.com/creswick/cabal-dev
11:30:15 <monochrom> cabal-dev on hackage has not even been updated for Haskell Platform which is already pretty old
11:31:04 <monochrom> that is, Haskell Platform is already at mtl 2.1.2 but cabal-dev is still at mtl-2.0.*
11:31:10 <Philippa_> napping: Cool, I shall take a look
11:31:21 <etrepum> cabal-dev on hackage is crap, install from git.
11:31:33 <monochrom> it is somewhat immoral to lag behind Haskell Platform IMO
11:31:39 <etrepum> yes
11:31:50 <Philippa_> napping: awesome, it's recent enough I have an excuse for having missed it too :p
11:32:11 <monochrom> and also somewhat immoral to just say "fixed in HEAD" and not release to hackage
11:32:15 <etrepum> https://github.com/creswick/cabal-dev/issues/74
11:32:41 <monochrom> don't ever upload to hackage if your idea of release is git
11:33:07 <napping> the extended report explains some of the design choices, and in particular that not too much depends on them
11:34:05 <Philippa_> *nod*
11:34:10 <etrepum> I have a feeling that cabal's sandbox features will obsolete cabal-dev before someone starts maintaining cabal-dev again
11:34:33 <wilfredh> perfect, that's installed it. Thanks.
11:35:36 <napping> etrepum: is that going to let us have multiple builds of the same package version against different dependencies?
11:36:04 <etrepum> napping: http://hackage.haskell.org/trac/hackage/wiki/SandboxedBuildsAndIsolatedEnvironments
11:37:24 <napping> etrepum: That doesn't suggest anything fancier than each sandbox doing a full rebuild
11:38:01 <napping> except "once ghc-pkg gets Nix-style package management, the --sandbox switch will be made the default
11:48:59 <beaky> can you define unary operators in haskell?
11:49:18 <Taneb> With an extension, yes
11:49:24 <Taneb> Ish
11:51:02 <beaky> in C++ I love to overload operators
11:51:03 <HugoDaniel> beaky: and extensions in haskell are really easy to use
11:51:58 <HugoDaniel> beaky: yes, but you have to be aware of the danger they bring, besides ruining readability of the code
11:52:23 <beaky> my code will read like a mathematical proof :D
11:52:47 <napping> There's a modest extension for postfix operators
11:52:48 <HugoDaniel> and how they are implemented, its no rocket sciente, just the linker doing name mangling and making sure that your code will hardly be binded with any other language/compiler out there
11:52:56 <hpaste> frerich pasted “Data.Conduit problem” at http://hpaste.org/80820
11:52:59 <beaky> heh
11:53:02 <napping> for prefix I think it's just (op) e
11:53:31 <napping> beaky: have you tried agda?
11:53:39 <HugoDaniel> beaky: it depends, overloading gives you different behaviour for the same operator, makes it depend on context, which can be *very* bad
11:53:57 <frerich__> Does anybody know what to make of the error message I pasted? FWIW httpLbs has the signature 'httpLbs :: (MonadBaseControl IO m, MonadResource m) => Request m -> Manager -> m (Response ByteString)', AFAICS I lack an instance of MonadResource for IO?
11:54:24 <hpaste> “Anonymous Coward” annotated “Parallel Matrix Multiplication” with “Parallel Matrix Multiplication (annotation)” at http://hpaste.org/55196#a80821
11:54:29 <frerich__> Hm, maybe runResourceT has something to do with it...
11:54:43 <beaky> what is agda?
11:55:05 <napping> for present purposes, a functional language with fancy mixfix and unicode syntax
11:55:11 <beaky> ah
11:55:20 <beaky> so it's like haskell++
11:55:24 <frerich__> Ha, indeed! I fixed it myself! :-)
11:55:26 <napping> define ++_ if you want prefix operators, if_then_else_ for conditional, etc.
11:56:03 <napping> also fancy dependent types, but you *could* just avoid using them if you want
11:56:51 <beaky> dependent types are like C++ class templates?
11:56:52 <napping> The tradeoff is that you must separate everything with spaces, as e.g. x≡y is a legal identifier
11:57:16 <napping> (one conventional name for arguments of type x ≡ y)
11:58:59 <HugoDaniel> beaky: /quit BUY BUY
11:59:44 <beaky> ? O.o
12:00:08 <Philippa_> beaky: it's probably a good idea to ignore the possibility things are related to C++ templates
12:00:43 <Philippa_> many things are, but that's because C++ templates are a total mess that happened by an accident of timing (including both research propagation and how much time we could throw at our compilers)
12:02:53 <napping> Also, most things you might think resemble templates are designed to have an actualy meaning independent of the details of how instantiation unfolds when they are used
12:03:15 <tac_> beaky: Dependent types allow you to have types that depend on values.
12:03:18 <beaky> ah
12:03:23 <tac_> Like "lists of length n" where n is a natural number
12:03:34 <tac_> or "the type of n by m matrices"
12:03:39 <beaky> haskell has lists of type t
12:03:52 <tac_> or "the type of strings that can be correctly parsed into JSON objects"
12:04:17 <tac_> "list of type t" is where a type depends on another type
12:04:23 <johnw> shapr: ping
12:04:24 <tac_> ie: it's a function from * -> *
12:04:34 <tac_> dependent types are functions such as Nat -> *
12:04:45 <tac_> Vect A n are vectors of type A with length n
12:04:45 <beaky> ah
12:04:51 <tac_> Vect has type * -> Nat -> *
12:05:15 <tac_> (* is often spelled "Type" or "Set" in these languages... Set in Agda, Type in Idris)
12:05:40 <beaky> haskell has lots of abstract stuff :(
12:06:04 <Taneb> Haskell has lots of abstract stuff :)
12:06:10 <beaky> :D
12:06:35 <tac_> Most type extensions are just very complicated, but underpowered variations on dependent types
12:06:43 <Taneb> Most of the abstract stuff Haskell has, it has because it's a good generalization of things that come up a lot
12:07:02 <jfischoff> edwardk: do Automatic Integration packages exist? Are they possible? Useful?
12:07:13 <edwardk> @hackage integration
12:07:13 <lambdabot> http://hackage.haskell.org/package/integration
12:07:35 <edwardk> that is the closest thing to a universal integrator that i have
12:08:23 <jfischoff> does it have to specialized for Double?
12:09:06 <edwardk> it could be generalized to bigger number types, but it needs a pretty massive constant table
12:09:16 <edwardk> baically its doing a change of variables on you
12:10:31 <jfischoff> hmm
12:10:47 <edwardk> open the source and look at the massive wall of constants i use
12:10:55 <edwardk> there is a script to generate them
12:10:59 <jfischoff> its also different because you aren't doing indefinite integration
12:11:23 <jfischoff> I would like something that had more of a antiderivative
12:11:25 <edwardk> you can pick end points or you can have me run an integral from 0 to infinity or neg infinity to infinity
12:11:47 <jfischoff> sure
12:11:50 <edwardk> 'automatic integration' isn't possible in general. the closest you can get is a bunch of tricks with pade approximants
12:12:00 <edwardk> that will get you something that is fairly robust
12:12:02 <jfischoff> okay
12:12:11 <jfischoff> thats wanted to know
12:12:26 <edwardk> piecewise chebyshev-pade approximation is the main tool used for this
12:12:41 <edwardk> i have a bunch of books and references i can dig up if you want to go deeper
12:13:38 <tobias_> can anyone explain me how IO and Monads works?
12:13:47 <tobias_> or a good tutorial ll also help
12:13:53 <Taneb> Ahaha
12:14:06 <gregory1> When I use the various state monads and the data structures attached to them such as Array.ST, does Haskell actually do any destructive updates, or is it all wrappers around pure values? Is the IO (and STM) monad the only one that does real destructive memory cell mutating updates?
12:14:29 <Taneb> tobias_, you do not need to worry about monads
12:14:41 <Taneb> Just use Haskell, and don't think about it
12:14:51 <Taneb> Eventually you'll realise that you already know them
12:14:51 <gregory1> tobias_: do you have a starting point question? it's a big broad topic
12:15:33 <napping> gregory1: ST also uses destructive updates
12:15:37 <tdammers> IMO, the most important thing about monads is that they're not really that special
12:15:58 <napping> (for that matter, updating thunks with the result values uses destructive updates, but that's unobservable in pure code)
12:16:03 <gregory1> napping: so how does that work when you might have multiple thunks being evaluated in parallel?
12:16:26 <napping> see "haskell on a shared memory multiprocessor"
12:16:33 <tac_> Is there any consensus on what the best approach to teaching monads is?
12:16:45 <gregory1> napping: yeah, i've read that paper, and i understand haskell's scheduler and thunks
12:17:00 <napping> in short, precisely because code is pure, it doesn't really matter if one thread tries to write a result and ends up being overwritten by another thread that was computing the same result
12:17:35 <gregory1> napping: but didn't you say that ST does real destructive updates, so modifying values in memory, so how do you stop data races from two thunks running in parallel?
12:17:51 <napping> so there's various flags and tricks to try to avoid two threads wasting time evaluating the same thing, but it's not necessary to use heavyweight synchronization to prevent it
12:18:03 <edwardk> gregory1: ST does real updates. but its done in such a way that you cant distinguish it from a pure implementation
12:18:11 <napping> well the thing about ST is that it uses the extra type parameter to make sure no effects escape
12:18:24 <edwardk> gregory1: two thinks can't access the same ST variables, they won't have the same 's' parameter.
12:18:31 <edwardk> there is no way to 'fork' a computation in ST (sanely)
12:18:32 <napping> so two threads could start the runST at the same time, but they'd allocate their own STRefs and stuff
12:19:02 <tac> gregory1: the ST monad uses the "s" in the type signature to prevent you from ever using the same ref in two threads
12:19:35 <edwardk> even if i nest another runST it'll get its own unique 's'
12:19:46 <gregory1> edwardk: no way to fork the monad - that makes sense to me
12:20:02 <gregory1> edwardk: and presumably i could fuck that over by using unsafeIO or something, and may get data races?
12:20:25 <napping> more like unsafeCoerce, but yeah
12:20:27 <edwardk> if you use unsafeIOtoST and unsafeSTtoIO you presumably know what you are doing
12:20:42 <edwardk> but those operations are in explicitly unsafe modules
12:21:00 <gregory1> and then ghc is safe to modify memory locations, knowing that the monad is only allowing one thread of execution at a time
12:21:48 <gregory1> and if i wanted concurrent or parallel updates to a mutable array, i would therefore have to use IORefs or TVars?
12:22:28 <edwardk> its more that runST is basically IO except because you can't fork, etc. you can know you'll get a deterministic result, since the result is deterministic its safe to runST to get a pure result from an ST calculation
12:22:31 <napping> Yeah, or a mutable array with update functions in IO ore STM
12:22:51 <edwardk> even though behind the scenes it makes up a little 'imperative world' and runs the calculation there before giving you back a pure result
12:22:57 <napping> unboxed arrays are much more efficient than something like an Array of IORef
12:23:02 <edwardk> its a deterministic result, so who cares if it was produced by side-effects?
12:23:21 <edwardk> we created all the resources we are mutating inside of the runST action, and you can't use them afterwards
12:23:27 <edwardk> the quantifier makes sure of that
12:23:33 <gregory1> edwardk: yeah but sometimes your problem isn't nondeterministic, like serving network clients on a shared data structure
12:23:42 <edwardk> those aren't ST calculations
12:23:57 <edwardk> ST is for small deterministic calculations in an otherwise pure context
12:24:02 <gregory1> and final question - how does ST do destructive updates outside of the IO monad? does it have compiler support, or does it safely use unsafePerformIO?
12:24:11 <tobias_> i do fear monad
12:24:14 <edwardk> e.g. you want to use some tarjan algorithm for working with disjoint set forests
12:24:22 <edwardk> it has compiler support
12:24:32 <gregory1> tobias_: they're nothing special, as soon as you get stuck trying to use them, just ask
12:24:34 <edwardk> it was one of the earliest motivations for adding rank-2 types to the language
12:24:39 <gregory1> edwardk: ok thanks that's very helpful
12:24:52 <napping> it's secretly the same compiler support :)
12:25:29 <beaky> what are some things that are hard to do in Haskell that are trivial in a dynamically-typed language like Lisp?
12:25:37 <napping> try :info on Control.Monad.ST and IO in ghci
12:26:05 <tac> beaky: metaprogramming is always clunkier in a statically typed language.
12:26:12 <napping> dynamically typed stuff
12:26:23 <beaky> ah
12:26:26 <tac> beaky: static typing, in a sense, was invented to PREVENT meta programming.
12:26:37 <gregory1> beaky: mocking data is a good concrete software engineering example
12:26:40 <tac> (in the context of logic, metaprogramming is a good way to generate paradoxes)
12:26:47 <gregory1> beaky: as in for a unit test
12:26:54 <beaky> I thought metaprogramming was a good thing, since Lisp folks always love to brag about it
12:27:05 <tac> It is powerful.
12:27:11 <tac> With great power comes great responsibility
12:27:13 <gregory1> beaky: but it makes it hard to reason about your program
12:27:40 <beaky> so types were invented to preserve semantics?
12:27:42 <tac> Hardcore Lispers tend to talk like they don't make mistakes to begin with, so it's not a problem for them :)
12:27:48 <napping> One good question is whether your metaprogram actually means anything on it's own, or just happens to generate useful code the way you apply the macro
12:28:11 <tac> Metaprogramming is often a good way to make a program much, much shorter.
12:28:26 <tobias_> i need to understand the basics first
12:28:36 <Philippa_> beaky: types were invented to deal with fundamental paradoxes in set theory
12:28:38 <napping> Guaranteeing that applying an abstraction always produces reasonable code is one of the main things type systems are for
12:28:49 <Philippa_> (really, Haskell's types are descended from Russell & Whitehead's)
12:29:22 <beaky> ah
12:29:54 <tac> Metaprogramming is letting your program talk about itself. To inspect its syntax. To change itself. To compile itself. Etc.
12:30:10 <tac> It's all very powerful, but you never know when doing something like that will cause problems.
12:30:21 <beaky> turing machines and von-neumann machines seem to do that. why don't more languages reflect that kind of thing too?
12:30:25 <beaky> oh
12:30:29 <napping> but if's usually not a big problem if you do it at compile time
12:30:34 <tac> You could change your program to be not-type-safe or not syntactically correct or to get stuck in a loop
12:30:58 <geekosaur> .oO { core wars }
12:31:00 <mreh> SDL-mixer fails with "C compiler cannot create executable"
12:31:08 <mreh> cabal install SDL-mixer
12:31:20 <`nand`> tac: only if the semantics of the metaprogramming language allow for such
12:31:22 <geekosaur> mreh, that's a "bug" in the package
12:31:28 <napping> on the other hand, with a sufficiently polymorphic type system you can make a lot of generic constructions into plain functions
12:31:35 <tac> yeah
12:31:35 <geekosaur> (the maintainer of the cabal package thinks it's perfectly sensible, sadly)
12:31:48 <mreh> geekosaur, did you find a way round it?
12:31:49 <Philippa_> beaky: It took a while to understand reflection well enough to implement on typical hardware, a while longer for RAM to be cheap enough, and a lot longer still for the ideas to propagate
12:31:54 <geekosaur> you are missing the C SDL-mixer library, or the cabal package can't find it
12:31:55 <hpaste> srhb pasted “YCHIM - Exercise 3” at http://hpaste.org/80824
12:32:16 <geekosaur> because of the way the cabal packge's configure is written, it references the C library in the "does the compiler work?" check
12:32:17 <tac> Metaprogramming also tends to be much, much harder to understand and maintain than normal code.
12:32:28 <geekosaur> so if the library is missing you get that inaccurate error
12:32:29 <srhb> I was helping a friend with You could have invented monads, and then I myself got stduck on exercise 3. See above paste. Can I get a nudge in the right direction?
12:32:32 <tac> You end up having to think about not only the code you write, but the code your code writes :(
12:32:35 <mreh> geekosaur, oh, very good :)
12:32:40 <mreh> yeah, that is a bug
12:32:42 <geekosaur> make sure the C SDL-mixer library is present
12:33:15 <tac> Metaprogramming is like compression for code. Your code is shorter, but more complex.
12:34:02 <Philippa_> but sometimes easier to keep track of the complexities in, of course
12:34:04 <monochrom> srhb: what is the desired type signature of (*)?
12:34:30 <monochrom> err nevermind, misread
12:34:34 <tac> :t (*)
12:34:36 <lambdabot> Num a => a -> a -> a
12:34:46 <mreh> geekosaur, have you tried to fix it for him?
12:34:46 <monochrom> maybe I should see YCHIM for real
12:34:59 <shachaf> srhb: You should probably include more context when asking questions like that. :-)
12:35:19 <shachaf> For example: What is (*)? What is lift? Are you trying to prove this for all monads, using the laws, or for this specific one?
12:35:44 <shachaf> Well, I guess you answer the first question there.
12:35:59 <srhb> Alright, sorry, I thought most people were familiar with that blog post.
12:36:10 <shachaf> Apparently lift f x = (f x,"")?
12:36:16 <shachaf> Are you allowed to inline that here?
12:37:19 <monochrom> lift f * lift g = bind (lift f) . (lift g), you get that first step right
12:37:24 <hpaste> srhb annotated “YCHIM - Exercise 3” with “YCHIM - Exercise 3 (annotation)” at http://hpaste.org/80824#a80825
12:37:39 <srhb> There are my definitions
12:37:51 <shachaf> OK, that's clearer.
12:37:53 <johnw> ah, much
12:38:05 <johnw> so lift is really just fmap here
12:38:11 <shachaf> No.
12:38:11 <monochrom> ah, it may be easiest to prove instead: (lift f * lift g) x = (lift (f . g)) x
12:38:13 <johnw> for a non-Functor instance
12:38:26 <shachaf> No, it's not fmap.
12:38:46 <johnw> because it's turning an x into an (f x,"")?
12:39:02 <johnw> oh, wait, never mind
12:39:09 <srhb> Right, I actually did think about that but was unsure whether that was allowable
12:39:24 <johnw> it's not fmap at all
12:39:34 <johnw> it's more like a return-apply
12:39:36 <srhb> That does make it quite a lot easier
12:39:40 <monochrom> it is extensional equality for functions. it is always allowed in functional programming
12:39:47 <shachaf> srhb: You may have an easier time if you comment out bind's type signature and give it a more generic one.
12:40:00 <srhb> (I think, now we'll see if I fail)
12:40:05 <shachaf> I don't know if that's allowed either. If it's not, you can always restore the old signature later. :-)
12:42:38 <geekosaur> mreh, I was not really in a position to do devel stuff at the time (and in fact I'm not really right now, either; I'm on a Mac missing some stuff and haven't had the chance to scrape it all together and make it work yet --- will probably end up throwing together a linux VM to do stuff in)
12:43:12 <mreh> geekosaur, macs dual boot dont' they?
12:43:25 <geekosaur> not automatically
12:43:26 <mreh> guy in my office runs windows on his!
12:43:35 <geekosaur> and I need this environment
12:43:48 <lispy> geekosaur: No idea what you were working on or what is broken, but I've been able to do pretty much arbitrary haskell on a mac. The main thing that trips me up is gtk2hs, but I even had that working once.
12:43:54 <johnw> i dual boot on a Mac, and run lots of VMs too
12:44:04 <mreh> http://www.meetup.com/London-HUG/events/88494702/
12:44:08 <mreh> who's going?
12:44:10 <johnw> gtk2hs works fine for me, with homebrew
12:44:31 <beaky> is the monadic return inspired by the return keyword in procedural programming languages?
12:44:43 <napping> I think so
12:45:05 <geekosaur> the choice was based on it (and has since been regarded a poor choice)
12:45:14 <beaky> ah :(
12:45:19 <beaky> what would have been a better name
12:45:20 <napping> Yeah, it doesn't have anything to do with control flow
12:45:36 <mreh> return was a bad choice
12:45:43 <mreh> ah yes
12:45:50 <napping> applicatives "pure" seems decent enough
12:45:59 * shachaf is not a huge fan of "pure"
12:45:59 <tac> beaky: no one knows why return is called return. It's a stupid name for it.
12:46:04 <beaky> haha
12:46:07 <tac> shachaf: what would you call it?
12:46:08 <beaky> :t pure
12:46:09 <Lethalman> napping, what's the meaning of pure at all?
12:46:09 <lambdabot> Applicative f => a -> f a
12:46:10 <shachaf> But whatever. Arguing about names that won't change is pointless.
12:46:31 <beaky> pure seems worse than return :(
12:46:37 <tac> shachaf: arguing makes a different. We got it changed to "pure" in idris.
12:46:43 <napping> it's at least not actively misleading
12:47:00 <shachaf> napping: It encourages the "monads are about impurity!!!!!" thing.
12:47:08 <tac> beaky: "pure" meaning "a value with no computational content" inside a monad or applicative
12:47:14 <beaky> ah
12:47:20 <beaky> then pure seems to be a nice name
12:47:26 <napping> do x <- fetch; when (x > 12) (return 12); tailCall x -- doesn't abort early and return 12
12:47:44 <mreh> pure is a good name
12:47:49 <mreh> it's the identity
12:47:56 <napping> shachaf: I guess there's "unit", but that seems a bit too vague
12:48:02 <napping> too generic, rather
12:48:07 <monochrom> as it stands, it already encourages the "applicatives are about impurity!!!" thing
12:48:34 <shachaf> In one sense Applicatives/Monads *are* about impurity.
12:48:43 <shachaf> But not in the sense that people usually think, and it just leads to confusion.
12:48:47 <monochrom> also, "computation" is a bit too vague, while we're comparing evil with evil
12:49:04 <Philippa_> eh, why not just call them "programs"?
12:49:06 <beaky> monoids seem pretty pure
12:49:13 <Philippa_> I mean, really :p
12:49:15 <clahey> Return makes sense to me.
12:49:24 <shachaf> i love monoids
12:49:32 <monochrom> they are so easy
12:49:34 <clahey> It's a value with no computational content that simply returns the given value when the computation is run.
12:49:39 <dblhelix> shachaf: what's not to love? :)
12:49:45 <hpaste> srhb annotated “YCHIM - Exercise 3” with “YCHIM - Exercise 3 (annotation) (annotation)” at http://hpaste.org/80824#a80826
12:49:49 <simpson> I think of "return" as "returning back into the monad, from which you cannot escape."
12:49:54 * Philippa_ doesn't like "pure" when things start nesting, but it's not the easiest thing to name - "yield"? "data"?
12:50:00 <simpson> Or maybe "Return to Witch Mountain."
12:50:12 <srhb> ^^^ Success, I think? Ugly though. :P But it was a lot more mechanical. Still not sure in which cases adding the variable on each side is legal.
12:50:12 <Taneb> Return to the Forbidden Planet
12:50:14 <napping> η ?
12:50:55 <napping> yield is still used elsewhere with control flow
12:51:11 <shachaf> yield is used for Continuation Parsec Style.
12:51:14 <shachaf> We can't take that.
12:51:21 <napping> perhaps "lift"?
12:51:33 <Philippa_> "drop" :p
12:51:53 <napping> maybe "leaf" if you want people to think of substitution rather than side effects and their canonical monads
12:52:01 <dblhelix> yield would be immediately associated with coroutines
12:52:03 <tac> We should all just use Hagino's categorical programming language and refuse ever to talk about individual inhabitants of a type.
12:52:11 <napping> or "value"?
12:52:30 <Philippa_> "embed"?
12:52:45 <tac> val would be nice
12:53:06 <tac> x <- [f 0, f 1, f2]; val (x + 1)
12:53:36 <shachaf> They're all pretty awful.
12:53:46 <shachaf> "return" has a good precedent and "pure" has a medium precedent.
12:54:09 <napping> shachaf: by what standard do you say they are awful?
12:54:44 <Iceland_jack> “wrap”?
12:55:00 <shachaf> Iceland_jack: No, that one's really bad, because monads etc. are not about wrapping.
12:55:06 <tac> napping: probably the imperial yardstick :P
12:55:42 <shachaf> napping: They give people who don't already know bad intuition (I think that was the standard people were aspiring to here).
12:55:56 <shachaf> That's probably because there's no way to give them good intuition, because they don't have the intuition.
12:56:23 <napping> some names seem to be clearly worse about giving people bad intuition - like "return" being expected to terminate the current do-block
12:56:48 <johnw> i don't think math even gives it a name beyond "eta", do they?
12:57:06 <beaky> math names are too terse
12:57:12 <beaky> programmers need more descriptive ones
12:57:30 <shachaf> Does benmachine/Ben Millwood tend to be around here?
12:57:32 <shachaf> I can't recall.
12:57:44 <simpson> > pi -- yeah, this is *far* too terse >:3
12:57:45 <lambdabot>   3.141592653589793
12:57:53 <thoughtpolice> preflex: seen benmachine
12:57:54 <preflex>  benmachine was last seen 143 days, 21 hours, 19 minutes and 11 seconds ago, saying: <private message>
12:58:10 <thoughtpolice> shachaf: well, he was apparently
12:59:07 <shachaf> Perhaps he still is, by another name.
13:04:32 <tac> shachaf: I've been benmachine in #ocaml and I think #scala the last few days
13:05:23 <lispy> I propose we replace 'return' with 'intoTheMonadWithYa'
13:05:34 <lispy> (You would have been too long)
13:06:22 <srhb> Okay, I guess I really do need an explanation. When is it okay to prove foo x = bar x instead of foo = bar?
13:06:25 <johnw> foldIntoTortilla
13:07:16 <Iceland_jack> goto!
13:07:36 <shachaf> Oh, he's online, just not in #haskell
13:07:43 <johnw> i guess the most accurate might be "contextualize"
13:08:11 <johnw> but then I like pure, because it declares what the value is, relative to the monadic context
13:08:20 <arianvp> yay. back on IRC
13:08:38 <clahey> into?
13:09:02 <clahey> srhb: Prove it for all x?
13:09:22 <clahey> srhb: What does foo = bar mean for functions though?
13:09:35 <srhb> Equivalence? I don't know. <_<
13:09:58 <clahey> srhb: So, I would say that functions are effectively the same if they return the same result for all inputs.
13:10:03 <johnw> it means identity, doesn't it?
13:10:04 <Cale> clahey: Two functions f and g are equal if and only if f x = g x for all x.
13:10:09 <johnw> foo = bar means foo is just another name for bar?
13:10:15 <clahey> srhb: That would be what it would mean in a mathematical sense.
13:10:24 <clahey> johnw: In the language, yes.
13:10:33 <srhb> Right. So I should just throw in the x anyway. :P
13:10:37 <clahey> johnw: But in a mathematical proof...
13:10:38 <Cale> Or are you talking about the declaration syntax specifically?
13:10:58 <johnw> clahey: in that case, we're not talking about the Haskell '=', are we
13:11:13 <clahey> johnw: No, but he used the word prove.
13:11:42 <srhb> So what are we doing if we prove the monad laws for some instance. We're not really proving? It's not really a Haskell '='?
13:11:51 <napping> srhb: it's fine unless you care about seqing the functions themselves - undefined x = (\x -> undefined) x
13:12:02 <Cale> The Haskell '=' is part of the syntax of declarations
13:12:21 <srhb> Ah, yes, of course.
13:12:33 <srhb> So when someone uses = in the monad laws, they are lying.
13:12:38 <Cale> heh
13:12:42 <srhb> (Or not speaking haskell)
13:12:46 <Cale> Well, they're not speaking Haskell
13:13:09 <srhb> Point being, there's no way to prove functional equivalence between two expressions in haskell?
13:13:29 <clahey> srhb: There's two ways to parse that English sentence.
13:13:37 <Cale> Well, any proof which was carried out *in* Haskell would be suspect, since as a logical system, Haskell is inconsistent.
13:13:52 <clahey> There is no way (to prove function equivalence between two expressions) by using Haskell.
13:14:04 <`ramses> Cale: so is any logical system, isn't it?
13:14:05 <clahey> But you can prove functional equivalence between two (expressions in Haskell)
13:14:09 <Cale> No.
13:14:12 <srhb> Huh? How?
13:14:15 <arianvp> ∀xf(x)≡g(x)
13:14:25 <strebe> `ramses: a system can't be complete and consistent, but it can be consistent
13:14:31 <clahey> `ramses: They can be incomplete instead.
13:14:52 <`ramses> ah right... sorry, didn't think enough before typing
13:14:57 <lispy> We have QC and we have haskell-src-* packages. Any technical reason why we don't use source fuzzing for testing ghc?
13:15:06 <lispy> Or is it a simple matter of no one has done it yet?
13:15:13 <Cale> The main point being that in Haskell, we have  fix :: forall a. (a -> a) -> a, and so we can write  fix id :: forall a. a  and prove anything.
13:15:23 <napping> lispy: not that I know of, but you might read about the trouble regher had doing it for C
13:15:27 <srhb> I think I got no smarter at all with respect to my actual question
13:15:42 <clahey> srhb: Well, one thing is that you can take the declaration syntax and actually use it in your proof as a mathematical statement.
13:15:45 <lispy> napping: perhaps fuzzing primarily works for dynamic languages?
13:15:49 <srhb> Right.
13:15:59 <Cale> srhb: I think I missed your actual question
13:16:02 <napping> lispy: nah, it's just that actually generating valid input programs can be a bit tricky
13:16:21 <clahey> srhb: So if I write Identity x >>= f = f x for example.
13:16:33 <arianvp> Doesn't the type system give enough hints to make you guess the right input?
13:16:35 <napping> also, having a reference compiler to test against is helpful
13:16:40 <lispy> napping: right. I just glanced a paper abstract where they used the grammar as input to help with that process. I'm sure it's still tricky in places.
13:16:43 <clahey> srhb: And then write return x = Identity x...
13:16:51 <Cale> lispy: I'm sure it could be quite useful to do that
13:17:00 <clahey> srhb: Now we can prove that return x >> f = f x for the Identity Monad.
13:17:05 <napping> avoiding undefined behavior in C was the trouble
13:17:10 <clahey> srhb: Just by doing substitution.
13:17:17 <napping> I guess you could try ghci or hugs against the compiled code
13:17:21 <napping> and maybe different -O levels
13:17:48 <clahey> srhb: What is it you're trying to prove?  Presumably some Monad law or Arrow law or something for a specific type?
13:18:07 <Cale> lispy: But it's not as obvious as "just use quickcheck" -- you need to be able to express properties that you'd like to test. If you generate a random piece of source code, I suppose you could do things like make sure that it parses successfully, but once it comes to semantics, things get harder.
13:18:17 <thoughtpolice> Cale: well, isn't that what "Fast and loose reasoning is morally correct" sort of addresses, re: fix? that we often reason about partial languages and programs written in them as if they were total, and for the most part that's OK?
13:18:35 <clahey> thoughtpolice: That's reasoning, not proving.
13:18:45 <srhb> clahey: The second one. The third one is where I just went "ok, let's say we can throw in x'es on what I'm trying to prove"
13:18:47 <srhb> clahey: http://hpaste.org/80824
13:18:49 <clahey> thoughtpolice: So yeah, for the most part that's okay, but it's not a proof.
13:18:49 <napping> Cale: the trick for C was differential testing whether a bunch of compilers agree
13:19:04 <Cale> thoughtpolice: Yeah, but people were talking about encoding the proofs of properties like the monad laws in Haskell itself as values of specially constructed types.
13:19:19 <thoughtpolice> ok, right. i was a little off
13:19:25 <clahey> srhb: The second what?
13:19:30 <`nand`> Cale: proofs aren't just “carried out in Haskell” - always under some mapping from some logic into (a subset of) Haskell; surely the question is “is the mapping of my logical system to Haskell done in a consistent way”, and not “is Haskell logically consistent”, because I think the latter makes no sense
13:19:32 <clahey> Oh, annotation.
13:19:32 <Philippa_> clahey: it does mean that you can write proofs about "Total Haskell" and they lift to the relevant fragment cleanly, though
13:19:37 <Cale> It's possible to do something like that, but it's less morally correct at that point, because it starts to get easy to screw that up.
13:20:14 <Philippa_> `nand`: the latter only doesn't make sense insofar as there's no negation per se, though
13:20:14 <Cale> `nand`: Haskell can be thought of as a logical system in itself.
13:20:53 <strebe> speaking of quick checks: Awodey says "For any set X, we have the group Aut(X) of automorphisms (or "permutations") of X, that is isomorphisms f: X->X." But how does the concept of a permutation of a set make sense?  I'm used to having sets defined as unordered, which would seem to preclude that?
13:20:59 <Cale> (it's just not a very good one for discussing truth and falsity of things)
13:21:19 <Cale> strebe: Do you know what a bijection is?
13:21:32 * hackagebot perceptron 0.1 - The perceptron learning algorithm.  http://hackage.haskell.org/package/perceptron-0.1 (StefanHoldermans)
13:21:43 <strebe> Cale: Yes
13:21:46 <Cale> A permutation on X is the same thing as a bijection X -> X
13:21:50 <clahey> srhb: Ah, so here's the thing.
13:22:03 <clahey> srhb: Did you use any properties or knowledge about what x is?
13:22:04 <`nand`> “endobijection”?
13:22:25 <lispy> Cale: I guess what people have had luck with in other languages (mainly javascript) is taking examples that misbehave and then fuzzing them to find more bugs. I agree that this approach isn't really appropriate for semantics.
13:22:28 <Cale> strebe: Or is that not what you're asking?
13:22:41 <Cale> lispy: hmmm...
13:22:46 <strebe> Cale: hmm. I guess I see how that make sense even without a concept of ordering; thank you
13:23:11 <lispy> Cale: https://www.usenix.org/conference/usenixsecurity12/fuzzing-code-fragments
13:23:22 <mm_freak> http://5outh.blogspot.de/ ⇐ who is this guy?
13:23:22 <Cale> strebe: Yeah, you're rearranging the elements of X with respect to each other, even if there's not necessarily a way to write them out in a row.
13:23:35 <srhb> clahey: No, I don't think I did.
13:23:51 <srhb> clahey: Well, actually if you go by my definition of bind, I did, but I could generalize that
13:24:09 <strebe> Cale: yep, now time to attack Cayley's theorem again. Thank you :-)
13:24:16 <clahey> srhb: Yeah, you should change those variables so that they're not all x.
13:24:25 <clahey> srhb: Make them y and z or x' and x''.
13:24:41 <clahey> Also, I would add a step between 6 and 8 in the third version.
13:25:07 <srhb> Is that even possible without some pseudosyntax?
13:25:08 <clahey> You have (a . b) x become a bx while skipping the step a (b x)
13:25:29 <srhb> Ah, yes, I actually went back and applied (.) before expanding bind.
13:26:14 <clahey> I would say apply . before applying bind or lift, but that's just a readability choice.
13:26:18 <Lethalman> pandoc is huge :S taking forever to compile :(
13:26:27 <clahey> Actually, I would do it a step at a time.
13:26:33 <clahey> Definition of *
13:26:36 <clahey> Apply .
13:26:57 <clahey> Definition of right copy of lift.
13:27:03 <TheRedMood> I am back!
13:27:04 <TheRedMood> :D
13:27:13 <clahey> srhb: Is this for a class?
13:27:17 <clahey> I always forget to ask.
13:27:28 <hpaste> srhb annotated “YCHIM - Exercise 3” with “YCHIM - Exercise 3 (annotation) (annotation) (annotation)” at http://hpaste.org/80824#a80829
13:27:41 <srhb> clahey: No, it's from "you could have invented monads"
13:27:54 <strebe> It says "First, define the Cayley representation Gbar of G to be the following group of permutations of a set: the set is just G itself, adn for each element g in G, we have the permutation gbar : G -> G, defined for all h in G by "acting on the left": gbar(h) = g dot h
13:27:59 <strebe> what does "acting on the left" mean?
13:28:12 <`nand`> you could have invented special relativity
13:28:40 <Cale> strebe: It's defining that
13:28:47 <srhb> clahey: Anyway, my real issue is: When can I, instead of proving "lift f * lift g = lift (f . g)"  prove "(lift f * lift g) x = (lift (f . g)) x" and conclude that it is the same proof of the same thing?
13:28:48 <Cale> strebe: oh, well...
13:28:54 <strebe> Cale: yes, and I'm not quite understanding the definition :/
13:29:03 <clahey> srhb: When you don't use any information about what x is.
13:29:08 <Cale> g . h is the group multiplication there
13:29:10 <srhb> That's all?
13:29:16 <clahey> srhb: Yep.
13:29:18 <shachaf> srhb: How careful are you being?
13:29:24 <srhb> I guess I should stop fussing then. :P
13:29:27 <shachaf> There are sometimes issues of seq and ⊥ to consider.
13:29:33 <srhb> shachaf: Ignoring those. :P
13:29:46 <clahey> Because what you need to prove is forall x . (lift f * lift g) x = (lift (f . g)) x
13:29:47 <shachaf> In that case, the only thing you can ever do with a function is apply it.
13:30:06 <srhb> clahey: Okay. I guess I just got confused when the x wasn't there in what I was asked to prove.
13:30:09 <srhb> shachaf: yay. :P
13:30:32 <strebe> Cale: Which yields... what? A particular bijection?
13:30:53 <shachaf> srhb: See also what monochrom said:
13:30:55 <shachaf> 12:39 <monochrom> it is extensional equality for functions. it is always allowed in functional programming
13:30:58 <Cale> strebe: So we're turning each group element g in G into a function g' : G -> G such that g'(h) = g*h, where * is the group multiplication. This g' must be a bijection, because (g^(-1))' will be its inverse.
13:31:04 <srhb> shachaf: I missed that. Thanks monochrom.
13:31:06 <`nand`> you can also refuse to apply it
13:31:19 <wuttf> How can I import the dot from here under a different name? http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Control-Category.html
13:31:41 <shachaf> wuttf: Import it qualified and then give it a different name locally.
13:31:42 <strebe> Cale: ah-hah, now it makes sense, and g' is what it's calling gbar. Thanks!
13:31:47 <Cale> yeah
13:31:47 <geekosaur> wuttf:  normally you'd import qualified Control.Category ((.)) as CC
13:31:57 <geekosaur> then the operator is CC..
13:31:57 <wuttf> shachaf: Tried that but the dot is messing me up
13:31:58 <Cale> I just can't write a bar, so I figured I'd use '
13:32:02 <shachaf> wuttf: Alternatively, don't use Prelude's (.).
13:32:10 <geekosaur> (which looks somewhat strange, an unfortunate side effect of how qualified names work in Haskell(
13:32:13 <strebe> (but why do they call it 'acting on the left'? it doesn't seem to pop up again soon)
13:32:25 <shachaf> wuttf: If GHC is giving you the "being messed up by an operator" error, try the flag -fdont-mess-with-me
13:32:33 <wuttf> shachaf: :D
13:32:36 * geekosaur *eyeroll*
13:32:47 <shachaf> Alternatively be more specific about the problem.
13:32:49 <`nand`> :t (Control.Category..)
13:32:51 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
13:32:54 <Cale> strebe: Because the function g' will, when given some element h in G, send it to g*h rather than h*g
13:32:59 <Cale> (or anything else)
13:33:18 <Cale> i.e. it attaches a g to the left of the h
13:33:24 <wuttf> Haha, very readable (Control.Category..)
13:33:32 <strebe> And is there a typo? It then says "This is indeed a permutation, since it has the action of g^(-1) as an inverse." - should that be gbar^(-1)?
13:33:37 <Cale> (we're talking about something somewhat syntactic here)
13:33:51 <strebe> Cale: hmm, ok
13:34:16 <Cale> I think "the action of" is intended as a synonym writing a bar
13:34:27 <strebe> ahhh
13:34:34 <Cale> synonym for*
13:34:49 <strebe> I wish there was an appendix of this stuff :-)
13:34:53 <clahey> shachaf: So, what needs to be proven regarding seq and bottom?
13:35:07 <Cale> bar{g^(-1)} is what you want
13:35:11 <shachaf> clahey: In what context?
13:35:15 * strebe nods
13:35:27 <clahey> shachaf: In proving that two expressions are equivalent.
13:35:40 <strebe> I've been stuck on this section for a few weeks due to this kind of syntactic thing
13:35:55 <shachaf> clahey: Well, it might be that f = ⊥, g = const ⊥
13:35:57 <clahey> In this case, I guess you can just prove that neither of them has a seq or a bottom.
13:36:00 <Cale> bar{g^-1} (bar{g} x) = bar{g^-1} (g*x) = g^(-1)*(g*x) = (g^(-1) * g) * x = 1 * x = x
13:36:01 <shachaf> So f x === g x for all x
13:36:05 <shachaf> But f =/= g
13:36:10 <shachaf> (You can distinguish with seq.)
13:36:32 <Cale> and bar{g} (bar{g^(-1)} x) = bar{g} (g^(-1)*x) = g*(g^(-1)*x) = (g * g^(-1)) * x = 1 * x = x
13:36:41 <clahey> ⊥ is denotationally the same as undefined?
13:36:43 <Cale> and so bar{g} and bar{g^(-1)} are inverse functions
13:36:51 <Cale> and so they are both bijections
13:37:09 <strebe> Thanks, that bit's clear now :)
13:37:37 <shachaf> clahey: undefined is an example of ⊥, along with infinite loops and so on.
13:37:55 <Cale> It's also possible to show that bar{g*h} = bar{g} . bar{h}
13:38:09 <strebe> *nod*
13:38:39 <Cale> So this bar is actually a group homomorphism G -> Sym(G).
13:38:47 <strebe> Sym?
13:38:58 <Cale> Ah, right
13:39:36 <Cale> Sym(X) is the symmetric group on X, the group of automorphisms of X in the category of sets.
13:39:46 <Cale> So we referred to that as Aut(X) above
13:40:08 <strebe> ahhh
13:40:09 <Cale> but in the case when G is a group, it's a little confusing to call that Aut(G)
13:40:41 <Cale> because Aut(G) would usually refer to the automorphisms of G in the category of groups
13:41:32 <Cale> I suppose you could subscript, so  Aut_Grp(G) and Aut_Set(G), or something :)
13:41:37 <strebe> Do you have a recommended book or chapter on basic group theory? It seems to pop up often enough that not having a grounding in it is being problematic
13:42:41 <Cale> Perhaps Dummit and Foote would be a good recommendation...
13:42:43 <Lethalman> (/usr/bin/ld: final link failed: No space left on device awesome)
13:44:18 <lispy> Cale: so the semantics they are concerned with is "Did it cause the interpreter to crash"
13:44:39 <Cale> lispy: Yeah, that kind of thing seems like it would be useful to do.
13:44:49 <lispy> Cale: so I can see why they published at a security conference
13:45:25 <Lethalman> if I install pandoc from debian
13:45:43 <lispy> Lethalman: and is the device out of space? :)
13:45:46 <Lethalman> how can I tell cabal to use the system version instead of installing its own?
13:45:58 <lispy> cabal is ignorant of the system
13:45:59 <Lethalman> lispy, you should ask "what" device first :P I don't know
13:46:41 <`nand`> device ‘awesome’?
13:46:48 <Lethalman> `nand`, lol no
13:47:24 <wuttf> shachaf: dot = CC..   "parse error on input 'CC..'"
13:47:26 <`nand`> maybe it has temporary files in a tmpfs; I ran into that issue once without realizing it
13:47:31 <`nand`> when my tmpfs grew and grew during a full system upgrade
13:47:31 <scooty-puff> does an existential quantified data type with no constraint actually require data, vs. newtype (short of the fact that its disallowed) - data A = forall a . A
13:47:34 <Lethalman> `nand`, probable
13:47:36 <`nand`> and eventually I ran out of RAM
13:47:37 <scooty-puff> *existentially
13:47:39 <Cale> strebe: It's worth noting that category theory provides a kind of explanation as to why group theory is important.
13:47:42 <wuttf> shachaf: import qualified Control.Category as CC, NoMonomorphismRestriction #-}
13:47:51 <shachaf> wuttf: "dot = ." -- parse error on input .
13:47:57 <Lethalman> `nand`, I try with gold
13:48:03 <shachaf> wuttf: You need to use parentheses, like `nand` did before.
13:48:05 <Lethalman> hoping that cabal works with gold
13:48:06 <Cale> strebe: Because every object of every category has an automorphism group. :)
13:48:14 <wuttf> CC.(.) ?
13:48:19 <`nand`> (CC..)
13:48:21 <shachaf> No, (CC..)
13:48:26 <shachaf> Like `nand` said before. :-)
13:48:38 <strebe> Cale: yeah, category theory seems so interwoven with so many branches of math that it's a bit staggering - in a good way, but.. :-)
13:48:49 <wuttf> `nand`: , shachaf Ty
13:49:52 <`nand`> most of mathematics is probably formally based on axiomatic set theory at some level, no?
13:50:02 <Cale> strebe: Categories naturally arise throughout mathematics because we are never content to study objects on their own. It's always more successful to study all the analogies and relationships between a wide class of structures, in order to be able to break problems involving complicated structures down in terms of solutions to many simpler ones.
13:50:17 <tac> `nand`: the mathematicians would probably claim that. (I would claim it's type theory all the way down :> )
13:50:25 <Cale> and once you have that sort of framework, it becomes natural to ask what relationships a structure has with itself
13:50:45 <strebe> Cale: agreed - it just makes bootstrapping a bit tricky
13:50:46 <`nand`> tac: until you formalize type theory via sets? :P
13:51:28 <`nand`> (then again, that isn't done in practice, is it?)
13:51:30 <tac> `nand`: Everyone knows about the type of sets, don't they :)
13:51:34 <Cale> and thereby get a powerful proof technique where you are able to prove something about a small part of your structure and then translate that around via these automorphisms.
13:51:55 <Lethalman> why the latest packages have unclickable modules? e.g. http://hackage.haskell.org/package/pandoc
13:51:59 <Cale> tac: Everyone knows about the set of types, don't they :)
13:52:04 <Lethalman> it happens for many other hackages
13:54:00 <geekosaur> Lethalman, it means the hoogle docs haven't been generated yet.  I get the impression something may be wrong with that; it's been noted on the haskell-cafe mailing list
13:54:42 <tac> Cale: The feeling I get from most math people is they would rather threaten to cut you, rather than listen to your thoughts on non-standard foundations
13:54:44 <Lethalman> geekosaur, ah ok
13:58:00 <Cale> tac: To be fair, things are somewhat designed such that foundations have only limited impact on how questions get answered.
13:58:30 <Cale> tac: You don't *want* things you're proving in, say, group theory, to be highly dependent on set theoretical foundations, if possible.
13:58:42 <Cale> Sometimes they are anyway
13:59:42 <tac> Right, right.
13:59:43 <Cale> Most mathematicians don't want to think about the differences between ZFC vs. other set theories, but have put in some time to become reasonably comfortable with ZFC.
13:59:46 <tac> Math is pretty good at modularity
14:00:04 <tac> yeah, I understand that all
14:00:56 <Cale> and there's something to be said for standards, given what little of them there are in mathematics :)
14:02:12 <Cale> Almost all of mathematics doesn't make use of the axiom of foundation/regularity or replacement.
14:02:21 <Cale> So there's that too.
14:03:45 <tac> Most mathematicians are quite fond of their excluded middle and AoC, though.
14:04:17 <tac> (although, I still don't fully understand the Axiom of Choice in set theory)
14:05:03 <Dodek> Cale: replacement is used all the time, i'd say
14:05:12 <[mth]> Is there any staight forward way of listing hackage packages that depend on specific package. For example I would like to see something take advantage of Control.Lens.Iso, so can I easily obtain a list of all packages that depend on lens?
14:05:22 <Cale> Dodek: Well, not in full generality, I think.
14:05:39 <edwardk> http://packdeps.haskellers.com/reverse/lens
14:05:43 <merijn> [mth]: There was a "reverse dependency" lookup site, but I forgot it
14:05:48 <merijn> oh, there you go :p
14:06:01 <merijn> edwardk: Is your haskell lens talk online somewhere yet?
14:06:07 <[mth]> edwardk: merijn: Thanks.
14:06:13 <shachaf> lens 3.8's Iso will be so much better.
14:06:25 <edwardk> Talk: http://youtu.be/cefnmjtAolY?hd=1 Slides: http://comonad.com/haskell/Lenses-Folds-and-Traversals-NYC.pdf
14:06:42 <edwardk> the new lens library is going out in 3-5 days
14:07:04 <Dodek> Cale: if you mean that axiom of specification is used more often then yes, that's true
14:07:09 <Dodek> Cale: it follows from replacement, though
14:07:30 <edwardk> if you have trouble with the audio still i close-captioned the first half of the video or so
14:07:50 <merijn> Also, which directory do I nuke if I want a fresh start of libraries? .ghc/arch-version, right?
14:08:00 <[mth]> Ok. Thanks. I might hold off then. The project has been using Data.Lens for a long while, so a couple of more days won't hurt.
14:08:29 <Cale> Dodek: Yeah, if you have the axiom of empty set, apparently.
14:09:31 <Dodek> really? existence of empty set easily follows from existence of any set.
14:09:42 <Cale> oh?
14:10:00 <Cale> You need comprehension/specification I would think
14:11:09 <merijn> edwardk: I'm assuming this is a typo in your slides? "result :: SEC (e -> a) (e -> b) a b"
14:11:29 <merijn> edwardk: Actually, no, I misparsed, nvm
14:11:34 * hackagebot MFlow 0.2.0.6 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.2.0.6 (AlbertoCorona)
14:12:17 * merijn should read better before opening his mouth...
14:12:56 <Cale> Usually the way you prove that the empty set exists is you start by using the set that the axiom of infinity gives you, and you use comprehension to restrict it using a predicate which is always false.
14:13:25 <Dodek> Cale: ah, yeah. i had a hard time defining intersection without specification.
14:14:35 <Cale> I think if you remove comprehension and empty set, there might be a model in which every set is infinite even :)
14:15:10 <Dodek> nah, you can easily get a singleton from replacement axiom
14:15:19 <Cale> oh, right
14:16:28 <Cale> A set theory without some form of comprehension is hardly a set theory at all
14:16:46 <Dodek> yeah.
14:16:53 <monochrom> God, the empty set from infinity, that is a sledgehammer
14:18:00 <Dodek> monochrom: well, other axioms let you create new sets from existing ones, or assert some properties of sets, but only axiom of infinity actually asserts existence of some set.
14:21:11 <tac> Axiom of infinite just says Nat : Set, right?
14:21:37 <Cale> It says that some superset of the (von Neumann) naturals is a set
14:23:06 <tac> Give me the inductive types axioms any day :P
14:23:33 <Cale> (well, it's only because it's easier to state that way, and we have comprehension so we can restrict that after)
14:23:52 <Cale> So morally, yeah, it's just that the naturals are a set.
14:24:17 <hpc> hmm
14:24:28 <hpc> it'd be interesting to go without any axioms that increase the size of a set
14:24:46 <Cale> Yeah, pairing sucks ;)
14:24:49 <tac> hpc: I don't think you can have any nontrivial functions in such a case
14:25:34 <merijn> Which GHC will be shipped with the next platform? 7.6?
14:25:43 <monochrom> likely still 7.4
14:25:47 <Cale> wat
14:25:50 <shachaf> monochrom: What?
14:25:57 <shachaf> I certainly hope it'll be 7.6.
14:26:10 <merijn> monochrom: Next platform release is May, I should hope we're not doing 7.4 still
14:26:11 <monochrom> see the haskell platform mailing list. there are reasons
14:26:25 <merijn> Else I'm gonna be really sad :(
14:26:31 <monochrom> perhaps I should find it for you?
14:26:40 <Cale> 7.2.2 best version
14:26:49 <hpc> heh
14:26:56 <merijn> travis-ci only supports platform for testing haskell code, so I can't have nice auto-testing for my current haskell stuff :\
14:27:13 <Heffalump> monochrom: where was sticking with 7.4 discussed?
14:27:14 <c_wraith> can we get a platform release for whatever version of GHC deleted code with type errors?
14:27:17 <shachaf> http://projects.haskell.org/pipermail/haskell-platform/2013-January/002390.html
14:27:22 <shachaf> Seems reliable.
14:28:39 <Cale> What an interesting thing to propose to a mailing list.
14:28:42 <Cale> ;)
14:29:11 <monochrom> I can't find it now. but the main reason is "so many hackage packages are not ready for 7.6"
14:29:22 <gienah> Heffalump: it wasn't as far as I know
14:29:29 <hpc> i am surprised more people don't try and sign mailing lists up for porn newsletters and such stuff
14:30:06 <merijn> hpc: Relatively easy to ban
14:30:15 <hpc> ah true
14:30:39 <monochrom> ah here: http://thread.gmane.org/gmane.comp.lang.haskell.platform/2334/focus=2338
14:32:02 <gienah> monochrom: of course that was after the announcement
14:32:15 <monochrom> perhaps I misread it. the real decision will be made in early February
14:32:44 <merijn> *fingers crossed*
14:33:26 <monochrom> or maybe early April
14:33:40 <monochrom> "support of the community to get common hackage packages working with that release before the April 8th date"
14:33:44 <Heffalump> since 7.6.1 is available now, at least that version is definitely going to make it in, isn't it?
14:34:03 <Heffalump> I think the final statement is about dealing with a last minute GHC release
14:34:38 <monochrom> "If the community would like the platform to use a GHC that is released in February, then" ... "support of the community to get common hackage packages working with that release before the April 8th date."
14:35:12 <gienah> during the planning of Haskell Platform 2012.4.0.0 I was hoping there would a vote on whether to use ghc 7.6 or 7.4, there wasn't though. I would have vote for ghc 7.6, but I guess I would have been outvoted.
14:36:43 <merijn> I would rather have 7.8 so I can play with holes, but 7.6 would be good enough to get my DataKinds code actually compiling
14:37:07 <shachaf> Holes don't give you very much that ImplicitParams don't, as far as I can tell.
14:37:24 <shachaf> Write your function, use ?hi as a "hole", compile.
14:38:12 <xnyhps> Doesn't work if you already have a type signature for that function.
14:38:21 <napping> shachaf: implicit params can't plausibly be extend to Agda-style interactive hole-filling
14:38:28 <xnyhps> You'll have to add (?hi :: ...) => yourself.
14:38:33 <shachaf> napping: True.
14:38:42 <shachaf> Well, maybe they can, who knows.
14:38:49 <shachaf> napping: But the state of holes in GHC HEAD is not that.
14:38:58 <napping> well, by horrible hacks like compiling, reading type errors, replacing buffer, etc
14:39:04 <shachaf> So there's no point in hoping for GHC 7.8 for that feature.
14:39:18 <shachaf> Also, ImplicitParams can be names, unlike HEAD holes.
14:39:21 <napping> yeah, exactly. The type and kind level stuff in 7.6 is nice, though
14:39:22 <shachaf> named
14:39:31 <shachaf> Yes, 7.6 is good.
14:39:46 <napping> If only we had a consistent subset of the language
14:40:06 <napping> or perhaps of the type language
14:41:46 <b52> http://paste.xinu.at/9O6iG/ does anyone know what could be wrong? trying to install wx
14:46:28 <geekosaur> b52, your ghc is recent enough (7.6.x?) to enforce some type constraints that were previously ignored
14:46:43 <gienah> b52: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/wxcore/files/wxcore-0.90.0.1-ghc-7.5.patch
14:47:42 <absence> can lens be used for things like map snd or even concat . map snd?
14:48:00 <monochrom> I think it can certainly do map snd
14:48:16 <monochrom> but I haven't learned how
14:48:31 <gienah> wx upstream are slow to apply fixes: https://github.com/jodonoghue/wxHaskell/pull/11
14:49:12 <b52> gienah: how do i apply it? i mean can i intercept cabal install somehow ?
14:49:38 <simpson> > over (traverse._2) (+1) [(1,2),(3,4),(5,6)] -- absence, monochrom
14:49:40 <lambdabot>   [(1,3),(3,5),(5,7)]
14:49:53 <hpc> b52: download the github version and cabal-install that
14:49:57 * simpson can't believe he learned how to lens
14:50:03 <hpc> (just run cabal-install in the directory with wxcore.cabal)
14:50:16 <hpc> er, "cabal install"
14:50:20 <gienah> b52: I've heard you can do something like: cabal unpack ... ; patch -p 1 < path_to_patch; cabal configure; cabal build; cabal install; or something like that
14:50:28 * gienah doesn't use cabal-install
14:50:48 <edwardk> absence: yes
14:51:02 <monochrom> please don't use the sequence "configure, build, install". either just "install", or "configure, build, haddock, copy, register"
14:51:18 <monochrom> erroneous folklore never dies
14:51:26 <Eduard_Munteanu> There, now you woke him up. :P
14:52:03 <hpc> monochrom: it doesn't help that "configure, build, install" is the standard path through make...
14:52:23 <gienah> hpc: I think that would require using the fork with the unapplied pull request
14:52:27 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/101796/
14:52:39 <absence> simpson: that's not quite what map snd does though :)
14:52:44 <fmap> > concatOf (traverse . _2) [(4, "hello"), (7, "world")]
14:52:45 <lambdabot>   "helloworld"
14:53:12 <absence> fmap: awesome!
14:53:19 <monochrom> to add confusion, "configure, build, install" is a correct sequence for Setup.hs
14:53:21 <edwardk> > [(1,2),(3,4)] & traverse %~ snd
14:53:22 <lambdabot>   [2,4]
14:53:37 <edwardk> > over traverse snd [(1,2),(3,4)]
14:53:39 <lambdabot>   [2,4]
14:53:44 <edwardk> > over mapped snd [(1,2),(3,4)]
14:53:46 <lambdabot>   [2,4]
14:53:58 <lispy> good thing there are a couple ways to do that
14:54:05 <monochrom> the whole cabal/Cabal UI is a mess of evolutional inconsistencies
14:54:15 <clahey> I don't remember what & is.
14:54:15 <edwardk> just showing you can use progressively less noise
14:54:19 <edwardk> (&) is flip ($)
14:54:24 <fmap> > [(1,2),(3,4)] ^.. folded . _2
14:54:25 <lambdabot>   [2,4]
14:55:28 <absence> the type i need is [(a,[b])] -> [b] but i get the idea :)
14:56:38 <zhulikas> > map snd [(1,2),(3,4)]
14:56:39 <lambdabot>   [2,4]
14:56:46 <zhulikas> > [(1,2),(3,4)] & traverse %~ snd
14:56:48 <lambdabot>   [2,4]
14:56:53 <zhulikas> so how is the second one any better?
14:57:34 <fmap> lens is not about `map snd'
14:57:39 <clahey> absence: concat!
14:58:06 <edwardk> zhulikas: because the lens approach scales to much much more complicated scenarios
14:58:12 <edwardk> fmap++
14:58:23 <zhulikas> fair enough
14:58:45 <`ramses> :t concatMap snd -- absence
14:58:46 <lambdabot> [(a, [b])] -> [b]
14:59:29 <b52> gienah: doesnt fix it
15:00:01 <absence> thanks for all the alternative suggestions, but my question was how to do concat . map snd with lenses :)
15:00:29 <absence> (which has been answered)
15:00:38 <edwardk> heh
15:00:54 <edwardk> :t concat . map snd
15:00:55 <lambdabot> [(a1, [a])] -> [a]
15:02:17 <gienah> b52: you need to patch wxdirect, then rebuild wxcore
15:03:17 <gienah> b52: https://github.com/gentoo-haskell/gentoo-haskell/raw/master/dev-haskell/wxdirect/files/wxdirect-0.90.0.1-ghc-7.5.patch
15:04:27 <gienah> b52: the wxdirect patch fixes code that is generated with wxdirect during the build of wxcore
15:05:03 <absence> > [(4, "hello"), (7, "world")] ^.. traverse._2.traverse
15:05:06 <lambdabot>   "helloworld"
15:05:14 <absence> fun
15:10:03 <b52> that would break nearly all my packages
15:10:50 * absence suspects one can write entire programs using nothing but lenses :p
15:13:00 <geekosaur> b52: the alternative is to downgrade to ghc 7.4.x which will probably break even more programs...
15:13:11 <geekosaur> / packages
15:16:55 <bitonic> geekosaur: 7.4.x should break very few packages
15:17:48 <sonOfRa> I'm currently experimenting a bit with commandline arguments. I want the arg to be either a path to a file, or a number. What is the smartest way to check this? I was thinking about checking the whole argument if each character is a digit, and if that is true, use it as a number, otherwise use it as a file path
15:17:55 <bitonic> since that’s what the platform uses (7.4.2)
15:17:58 <geekosaur> bitonic, in the sense that everything they have installed that isn;t part of the platform will need to be reinstalled
15:18:02 <sonOfRa> is there a better way to accomplish this?
15:18:20 <bitonic> geekosaur: oh OK.  that probably won’t take too long anywa...
15:19:40 <hpc> sonOfRa: i run your script on a bunch of log files
15:19:55 <hpc> the log files are numbered 1, 2, 3, 4, ...
15:20:04 <sonOfRa> yeah
15:20:05 <sonOfRa> i encountered that issue as well
15:20:30 <hpc> are you using a library to get the arguments?
15:20:43 <sonOfRa> System.Environment getArgs
15:20:45 <hpc> (beyond just getArgs + your own stuff)
15:20:46 <hpc> ah
15:21:17 <sonOfRa> i guess then something like
15:21:33 <sonOfRa> main -l filename or main 4 is a better approach
15:21:48 <hpc> indeed
15:22:29 <hpc> http://hackage.haskell.org/packages/archive/cmdargs/0.10.1/doc/html/System-Console-CmdArgs-Implicit.html -- this package seems promising
15:22:39 <hpc> from my 2 seconds of looking at it
15:23:01 <hpc> using getArgs doesn't generally work well beyond just the most basic things
15:23:34 <glguy> cmdargs is ok if you don't mind a lot of magic and the magic outcome is what you wanted
15:24:11 <hpc> heh
15:24:43 <hpc> i usually use this, to keep dependencies small
15:24:44 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-Console-GetOpt.html#g:1
15:26:00 * cmccann is not a fan of libraries that follow the "do what I mean, so long as I mean what the library's author would have meant in this situation" approach
15:26:36 * hackagebot coroutine-object 0.2 - Object-oriented programming realization using coroutine  http://hackage.haskell.org/package/coroutine-object-0.2 (IanWooKim)
15:26:38 * hackagebot xournal-types 0.5.0.1 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.5.0.1 (IanWooKim)
15:26:40 * hackagebot xournal-parser 0.5.0.1 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.5.0.1 (IanWooKim)
15:26:42 * hackagebot hoodle-types 0.1.1 - Data types for programs for hoodle file format  http://hackage.haskell.org/package/hoodle-types-0.1.1 (IanWooKim)
15:31:44 * hackagebot hoodle-builder 0.1.1 - text builder for hoodle file format  http://hackage.haskell.org/package/hoodle-builder-0.1.1 (IanWooKim)
15:31:46 * hackagebot hoodle-render 0.2.1 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.2.1 (IanWooKim)
15:31:48 * hackagebot hoodle-parser 0.1.1 - Hoodle file parser  http://hackage.haskell.org/package/hoodle-parser-0.1.1 (IanWooKim)
15:31:50 * hackagebot hoodle-core 0.9 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.9 (IanWooKim)
15:31:52 * hackagebot hoodle 0.1.1 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.1.1 (IanWooKim)
15:33:35 <augur> damnit hackagebot stop spammin
15:33:42 <augur> i know you're a bot and all but still
15:33:43 <augur> :|
15:44:57 <byorgey> jkkjkjjk;
15:44:57 <byorgey> '[6~
15:44:58 <byorgey>  
15:45:08 <byorgey> whoops
15:45:11 <FYCouch> hello, what term does haskell use to refer to the quantity of elements in an array?
15:45:14 <byorgey> that was my 16-month old =)
15:45:31 <FYCouch> byorgey: s/he has your intellect
15:45:37 <FYCouch> :P
15:45:50 <sipa> she's far above my level of comprehension already
15:46:00 <sipa> i don't understand anything of it!
15:46:05 <sipa> s/he
15:46:36 <Philippa_> byorgey: huh. I'm wondering if that's a record for youngest #haskeller
15:46:42 <elliott> .@remember byorgey <byorgey> jkkjkjjk;  <byorgey> '[6~  <byorgey>
15:47:34 <FYCouch> can someone answer my question please?
15:48:14 <wavewave> hoodle-0.1.1 is out!
15:48:37 <cmccann> wavewave: we know, hackagebot told us quite loudly
15:48:55 <wavewave> cmccann: ah.. yes. ;-P
15:48:59 <cmccann> :D
15:49:09 * geekosaur does not have an answer and is not sure there is one as phrased; it talks about bounds, but not so much beyond
15:49:37 <wavewave> hope that this version is worth trying.
15:49:43 <shachaf> himccann
15:49:56 * geekosaur is not sure the concept is supposed to have a meaning given the focus on bounds
15:50:34 <sipa> @pl \(x,y) -> x-y+1
15:50:34 <lambdabot> uncurry (flip flip 1 . ((+) .) . (-))
15:50:42 <cmccann> hishachaf
15:50:43 <sipa> @pl (\(x,y) -> x-y+1) . bounds
15:50:44 <lambdabot> uncurry (flip flip 1 . ((+) .) . (-)) . bounds
15:50:52 <Ralith> lol
15:51:10 <sipa> @let size = uncurry (flip flip 1 . ((+) .) . (-)) . bounds
15:51:12 <lambdabot>  Defined.
15:51:18 <geekosaur> that's kinda my point actually; it's difficult to talk about
15:51:28 <geekosaur> implying it's a discouraged concept
15:51:39 <shachaf> @ty size
15:51:40 <lambdabot> (Num b, Ix b) => Array b e -> b
15:51:41 <shachaf> @ty ((+1) . uncurry (-)) . bounds
15:51:42 <lambdabot> (Num b, Ix b) => Array b e -> b
15:51:45 <shachaf> ?
15:51:59 <FYCouch> in haskell there is no concept for the # of items in an array?
15:52:00 <geekosaur> (but note that Array is often considered to be a somewhat poor first cut, with Vector preferred)
15:52:03 <sipa> @pl (\(x,y) -> y-x+1) . bounds
15:52:03 <lambdabot> uncurry (flip flip 1 . ((+) .) . subtract) . bounds
15:52:12 <wavewave> cmccann: by the way, I am leaving michigan this summer
15:52:24 <shachaf> hi wavewave
15:52:27 <cmccann> wavewave: where to?
15:52:27 <geekosaur> FYCouch, you are supposed to think in terms of bounds; size kinda implies indexing from 0
15:52:28 <shachaf> Where are you going?
15:52:31 <wavewave> shachaf: hi!
15:52:36 <cmccann> anyway getting out of michigan sounds like a good idea all around
15:52:42 <FYCouch> well sure
15:52:42 <cmccann> I highly recommend it
15:52:46 <wavewave> CERN
15:52:50 <cmccann> :O
15:52:53 <wavewave> to Europe.
15:53:01 <FYCouch> geekosaur: what is 'bounds' with regards to array ?
15:53:10 <cmccann> wavewave: sounds exciting!
15:53:16 <geekosaur> left and right edges of the index space
15:53:16 <wavewave> cmccann: :-)
15:53:23 <wavewave> cmccann: thanks
15:53:23 <FYCouch> ok
15:53:31 <FYCouch> and what if i want to know how many elements are in an array?
15:53:41 <geekosaur> arrays are not automatically 0-indexed like lists; you specify when creating it the lower and upper bounds of the index
15:53:52 <geekosaur> see what sipa said above
15:54:09 <geekosaur> I don't recommend the @pl output for it though :)
15:54:10 <FYCouch> sipa said haskell, and i don't know haskell
15:54:20 <geekosaur> um
15:54:42 <wavewave> creating hoodle was so much fun. I learned a lot.
15:54:46 <FYCouch> so what is the term that refers to the qty of items in a list?
15:54:52 <cmccann> FYCouch: arrays are really not used that much anyway
15:54:56 <geekosaur> there is little haskell actually there, there is a very simple bit of arithmetic that should be fairly obvious considering what I told you
15:55:11 <Philippa_> FYCouch: "length"
15:55:13 <geekosaur> and to repeat again:  arrays are generally considered a poor first cut and vectors are preferred these days
15:55:15 <sipa> FYCouch: "number of elements"
15:55:24 <cmccann> wavewave: will you still be working on it? or will you no longer have time?
15:55:25 <wavewave> my code still smells though ;-/
15:55:29 <testhaskell> how many active users in the haskell community
15:55:36 <sipa> length is probably an acceptable english word for it
15:55:38 <hpc> 5
15:55:42 <FYCouch> geekosaur: what term is used to refer to qty of items in a vector?
15:56:19 <wavewave> cmccann: of course, i am going to work on improving hoodle all the time. This is the most important tool I use for my research. he
15:56:21 <Philippa_> hpc: and they're all called Simon
15:56:30 <sipa> FYCouch: for vectors, the function "length" is defined; so i guess length!
15:56:46 <FYCouch> ah
15:56:53 <hpc> nope, 2 simons, 2 elliots, and dons is so productive that he has 1000 nicks in channel right now
15:57:10 <cmccann> wavewave: you will have to introduce all your new colleagues to it as well!
15:57:11 <wavewave> i got to know a lot about designing rather big software. that's invaluable.
15:57:43 <wavewave> cmccann: yes.. that's actually what i am doing these days ;-)
15:59:01 <roadfish> when I do "runghc Setup build" to build my cabal package, I get "Could not find module" even though the module is installed in ~/.cabal. How do I build the package executable with modules from ~/.cabal?
15:59:27 <shachaf> roadfish: That happens automatically. Please provide more context.
15:59:45 <shachaf> (For example: The command you're running, and the exact error you get.)
15:59:57 <FYCouch> wavewave: i come from another platform. what is significant about a drawing app in haskell please?
16:00:01 <hpc> @where hpaste
16:00:01 <lambdabot> http://hpaste.org/
16:01:05 <wavewave> FYCouch: I couldn't understand your question. What do you want to discuss more specifically?
16:01:30 <FYCouch> sorry, i don't understand
16:01:33 <absence> i remember reading something about redefining (.) = fmap a long time ago. what could that be for? it doesn't seem compatible
16:01:42 <geekosaur> roadfish:  also note that "installed in ~/.cabal" is more or less meaningless.  is it listed in "ghc-pkg list" output?  files can be anywhere but not at all relevant if ghc-pkg doesn't show them
16:01:42 <roadfish> FYCouch: what is significant about a drawing app in any language?
16:02:22 <shachaf> absence: Compatible with what?
16:02:34 <shachaf> absence: fmap works just fine for function composition, if that's what you mean.
16:02:37 <Philippa_> FYCouch: Do you mean, how would Haskell make one easier to write/what features would be easier to implement?
16:02:39 <shachaf> > ((+1) `fmap` (*2)) 5
16:02:41 <lambdabot>   11
16:02:43 <geekosaur> absence:  fmap is a generalization.  on functions, fmap is (.).  some people want (.) to be the more general fmap instead of specialized to functions
16:02:55 <simpson> absence: instance (Functor (->) e)
16:02:58 <shachaf> *A* generalization, mind you.
16:03:06 <shachaf> There are other generalizations, like (Control.Category..).
16:03:15 <shachaf> They are not compatible.
16:03:32 <shachaf> (There is also (Data.Profunctor.rmap), though I guess that winds up being strictly inferior to fmap.)
16:03:35 <geekosaur> (which is why standard haskell hasn't tried to generalize (.))
16:03:36 <cmccann> honestly I don't think anybody other than Cale would generalize (.) as fmap...
16:04:03 <wavewave> I would say that nothing very spectacular about GUI programming in haskell. GUI programming is a kind of mess when need perfection.
16:04:21 <shachaf> cmccann: http://comonad.com/reader/2006/generalizing-dot/
16:04:30 <shachaf> (Isn't it cute?)
16:05:05 <Cale> :)
16:05:06 <wavewave> but in general, using a good programming language like haskell is good for programming in a very modular way.
16:05:09 <FYCouch> wavewave: how does GUI app building in haskell lack? given you just built this i'd like to know
16:05:33 <wavewave> FYCouch: library!
16:05:33 <Cale> cmccann: There are a few people who like (.) as fmap
16:05:38 <Philippa_> wavewave: Yep. Haskell does make it a lot easier to start building things that smell like version control into your app, though
16:05:39 <Cale> (at least)
16:05:43 <cmccann> Cale: apparently
16:06:08 * cmccann would rather "map" be "fmap"
16:06:09 <merlin_> Philippa_: what do you mean?
16:06:17 <elliott> can we get Prelude.(.) in lambdabot yet :(
16:06:36 <Cale> cmccann: I would definitely do that before I did (.) as fmap if I were changing things.
16:06:36 <wavewave> FYCouch:  gtk ecosystem in haskell is okay but others are not very promising.
16:06:37 <glguy> maybe we could ban lambdabot
16:06:43 <glguy> and get preflex to do eval for us
16:06:51 <cmccann> I think we should generalize (.) to be the (.) for Control.Lens.
16:06:55 <cmccann> that sounds like a good plan.
16:06:57 <wavewave> FYCouch: especially qt is not supported now.
16:07:01 <Philippa_> merlin_: keeping a history is a matter of, well, keeping a history. You don't have to rearchitect the entire app just to make it doable
16:07:04 <elliott> cmccann: that's (.) now :P
16:07:05 <absence> shachaf: compatible with my code :) redefining (.) to fmap gives screens of errors
16:07:08 <geekosaur> lambdabot should do "> " as haskell and ">> " as caleskell :)
16:07:12 <Cale> cmccann: (.) is different for Control.Lens?
16:07:15 <elliott> no
16:07:22 <shachaf> absence: I bet it's some silly thing like the monomorphism restriction.
16:07:23 <cmccann> that was the joke >:[
16:07:23 <elliott> geekosaur: I think the only Caleskellism left is (.).
16:07:27 <hpaste> roadfish pasted “can't find import in newly created cabal package” at http://hpaste.org/80834
16:07:31 <glguy> elliott: ++ is broken, too
16:07:33 <Cale> Nah, there's other stuff in L.hs
16:07:36 <edwardk> Cale: no, that was a joke
16:07:39 <Cale> "broken"
16:07:40 <Cale> lol
16:07:42 <shachaf> absence: You should specify an example complete with an error message rather than just saying it doesn't work. :-)
16:07:48 <wavewave> FYCouch: I haven't tried wxHaskell, but it seems that it looks okay as a library. but still that's just a beginning.
16:07:54 <elliott> :t (++)
16:07:55 <lambdabot> Monoid m => m -> m -> m
16:07:59 <Cale> It's not broken. It's just a separate definition that's in the local scope.
16:08:00 <glguy> :t (<>)
16:08:01 <lambdabot> Monoid m => m -> m -> m
16:08:01 <elliott> glguy: fair enough.
16:08:06 <cmccann> elliott: that looks like the right (++) to me!
16:08:08 <wavewave> FYCouch: .net is not supported at all.
16:08:10 <edwardk> the ++ one is just kinda gratuitous now that we have (<>)
16:08:11 <elliott> Cale: ...that every newbie perceives as what Haskell actually is
16:08:11 <roadfish> shachaf/geekosaur: here is extra context around my import problem.
16:08:16 <geekosaur> roadfish, use "cabal configure" etc.
16:08:23 <elliott> and will, inevitably, get confusing errors related to at some point
16:08:31 <geekosaur> or pass the --user option to configure and install
16:08:33 <elliott> (confusing because they don't relate back to the Haskell they have in GHCi, not because of the generalisation)
16:08:43 <shachaf> roadfish: It looks like you don't list it in build-depends?
16:08:50 <wavewave> FYCouch: if library space is filled, then doing GUI programming in haskell is just good. nothing very different from others in its basic.
16:08:52 <Cale> Well, there's always stuff that's going to be in scope in lambdabot which are not in scope in GHCi.
16:08:57 <geekosaur> hm, that's a good point too
16:09:11 <FYCouch> wavewave: ok nice
16:09:16 <Cale> because we're importing like 80 kajillion modules
16:09:22 <edwardk> we just need a #haskell package that brings into scope everything lambdabot does
16:09:23 <wavewave> FYCouch: but haskell excels when you start making abstraction!!
16:09:24 <FYCouch> haskewll :D
16:09:26 <elliott> Cale: But additions are fundamentally different to replacements.
16:09:37 <FYCouch> what do you like most about haskell abstraction wavewave ?
16:09:40 <cmccann> edwardk: yes, and I nominate elliott to maintain that
16:09:49 <wavewave> that's not just for GUI, though.
16:09:57 <elliott> import #haskell
16:10:01 <elliott> a great module name
16:10:04 <elliott> import Unsafe.Coerce#
16:10:17 <wavewave> in my case, I use coroutine a lot in my development.
16:10:40 <edwardk> elliott: i wonder if it works as a package name
16:10:52 <elliott> edwardk: I think just a-z0-9- do
16:10:59 <edwardk> shucks
16:11:08 <wavewave> I think coroutine, free monad, continuation monad or similar are the first abstraction to purify your code out of IO world.
16:11:18 <geekosaur> roadfish, so you need to (a) add "diagrams" to your build-depends (along with any other of those modules that you might be using); (b) verify that they are installed in the global package database OR use the --user option to have Setup search the user package database OR use "cabal configure", "cabal build", etc. which will add --user as needed
16:11:28 <edwardk> clearly i need to release http://hackage.haskell.org/package/haskell
16:11:48 <wavewave> FRP is rather too bold for me, so I didn't take it for hoodle (because I need to write down a "driver" for wacom tablet. )
16:12:12 <geekosaur> (those ORs all apply to (b); (a) is needed anyway, but the diagnostic you get would be different, it would tell you the package is present but hidden)
16:12:13 <elliott> edwardk: release the null string
16:12:16 <wavewave> but FRP is interesting approach. I am just waiting for it to be more mature.
16:12:19 * cmccann thinks "𝖀𝖓𝖘𝖆𝖋𝖊.𝕮𝖔𝖊𝖗𝖈𝖊" would be a good name, to make it more difficult to use
16:12:22 <FYCouch> FRP?
16:12:23 <merlin_> wavewave: what did you try? I am deciding between gtk and qt
16:12:28 <absence> shachaf: yes, it was more of a curiosity than a real problem, i don't need to define (.) = fmap :)
16:12:31 <edwardk> elliott: i've yet to bring myself to go below 2 character package names ;)
16:12:39 <wavewave> merlin_: definitely gtk .  qt is not supported.
16:12:40 * shachaf thinks cmccann will use any excuse to write in Fraktur.
16:12:46 <cmccann> shachaf: that too.
16:13:00 <edwardk> cmccann: that might fraktur the user base though
16:13:02 <wavewave> qtHaskell exist. but I never succeed in it working.. anyway it's outdated, not maintained.
16:13:05 <cmccann> haha
16:13:38 <merlin_> wavewave: yeah, shame that qtHaskell no longer seems to be maintained
16:14:01 <FYCouch> "cmccann	 thinks "𝖀𝖓𝖘𝖆𝖋𝖊.𝕮𝖔𝖊𝖗𝖈𝖊" would be a good name," <-- lol
16:14:20 <FYCouch> i could see some hispanic nerds with that tatood across their chest getting into gun fights
16:14:25 <wavewave> in fact, I already made a general C++/haskell binding utility called fficxx. I used it for HROOT (haskell binding for ROOT) Someday, I will try to make my own version of qtHaskell if time allows ;-P hehe
16:14:31 <FYCouch> tattood
16:14:46 <FYCouch> nerf gun fights, that is
16:14:49 <wavewave> C++ haskell binding is a big mess.
16:15:45 <roadfish> geekosaur/shachaf:thanks, I've got it compilng and running now
16:16:52 <wavewave> FYCouch: FRP = functional reactive programming
16:17:15 <FYCouch> url?
16:17:17 <wavewave> FYCouch: it's rather radically new approach for GUI programming.
16:17:43 <wavewave> http://www.haskell.org/haskellwiki/Functional_Reactive_Programming
16:18:11 <FYCouch> very kewl
16:18:26 <FYCouch> i was reading http://en.wikipedia.org/wiki/Functional_reactive_programming but your link is better
16:18:56 <wavewave> I think reactive-banana is most mature. but i haven't seriously tried it, so I do not know yet.
16:19:27 <roadfish> wavewave: I'm been reading about FRP for GUIs too. Am I correct in my impression that arrows are important to FRP GUI programming?
16:19:28 <wavewave> For haskell/javascript side, you can try elm (haskell-like language compiled to javascript)
16:19:45 <wavewave> roadfish: for arrowized FRP approach.
16:19:58 <wavewave> roadfish: FRP doesn't have to use arrow by definition.
16:20:12 <wavewave> roadfish: but arrow is a good abstraction.. so
16:22:16 <roadfish> I'm getting comfortable in using monads and understand a Maybe "grandparent" example that I read. But I still need to get my head around arrows. Still not really up on the "monad laws" and I understand therer are also "arrow laws" too.
16:22:45 <wavewave> roadfish: you can live without arrow quite well in haskell world.
16:22:47 <johnw> why do you need arrows?
16:22:48 <shachaf> roadfish: No, you don't need to worry about arrows.
16:22:58 <johnw> yes, I learned them and then almost never used them
16:23:02 <glguy> I 4th that
16:23:08 <shachaf> They're used in almost no Haskell programming, and they're not nearly as useful an abstraction for the most part.
16:23:29 <shachaf> I don't like this progression that the Internet seems to put on learning Haskell.
16:23:35 <elliott> shachaf: Except lenses!
16:23:38 <shachaf> You learn so and so, and then Monad, and then Arrow, and then ...
16:23:39 <elliott> (Above statement misleading.)
16:23:51 <shachaf> elliott: Arrow lenses don't exist.
16:23:55 <shachaf> They're like infinite traversals.
16:24:01 <nwf> Pardon a quick interruption from the peanut gallery; is there a recommended package for a data Fix f = ... definition or should I just roll my own?  (Not that it's hard, but rampant duplication makes me sad.)
16:24:14 <edwardk> johnw: as a blanket statement that someone will give me crap about, arrows are rarely the right abstraction
16:24:20 <roadfish> ok, is hard to tell how useful some abstraction is from just some assorted reading.
16:24:28 <shachaf> nwf: Maybe recursion-schemes?
16:24:40 <shachaf> Hmm, maybe not.
16:24:57 <shachaf> I tend to just define it myself.
16:24:58 <edwardk> recursion schemes does provide Fix/Mu and Nu
16:25:19 <shachaf> nwf: Also note that it can be newtype. :-)
16:25:27 <wavewave> roadfish: so.. as people here said ;-)
16:25:38 <edwardk> nwf: http://hackage.haskell.org/packages/archive/recursion-schemes/3.0.0.1/doc/html/Data-Functor-Foldable.html
16:25:44 <roadfish> I was wondering what areas arrows are used in. One comment that I read is that arrows are "generalized monads".
16:25:48 <shachaf> recursion-schemes does provide Fix/Mu and Nu.
16:25:55 <cmccann> roadfish: that's really not accurate
16:26:00 <shachaf> It also provides distZygoT and coelgot.
16:26:03 <shachaf> "just in case"
16:26:09 <edwardk> shachaf: they are recursion schemes
16:26:13 <shachaf> Sure.
16:26:24 <shachaf> It also provides... zygoHistoPrepro?
16:26:26 <shachaf> Come on.
16:26:26 <wavewave> by the way, I need to head back home now to ride a bus.
16:26:27 <edwardk> i figured i'd beat the notion of recursion schemes to death before giving up on them
16:26:30 <johnw> roadfish: the best article I ever read on them was this one: http://ertes.de/new/tutorials/arrows.html
16:26:36 <johnw> roadfish: but even then, the use is rare
16:26:39 <wavewave> so good to meet you and come back later!
16:26:54 <edwardk> shachaf: with a link to the joke page, yes
16:27:09 <shachaf> i love zygohistomorphic prepromorphisms
16:27:11 <shachaf> they are so easy
16:27:12 <roadfish> I've read jabs at inappropriate monad metaphors. I guess arrows are getting inappropriate metaphors too.
16:27:28 <edwardk> and it was important because it resulted in a bugfix for the published signature of zygoHistoPrepro ;)
16:27:37 <shachaf> roadfish: Correct!
16:28:17 <cmccann> leaving aside the issue of how useful they are, arrows are really not part of a coherent progression from Functor-related type classes
16:28:32 <cmccann> despite being compared to monads for various reasons that I don't think are helpful for beginners
16:30:39 <cmccann> other than not using Kleisli because bluh newtype wrapper boilerplate and using Arrow combinators with (->) to golf things on IRC I'm not aware of many Arrow instances that are actually used for anything
16:30:53 <cmccann> and the ones I am aware of are pretty much all variations on the automaton arrow
16:31:10 <shachaf> By the way, you could make a version of Kleisli that was composable with (.).
16:31:15 <shachaf> Except the type would be too big, alas.
16:31:47 <cmccann> shachaf: without creating ambiguous Category and Arrow instances vs. (->)?
16:31:57 <shachaf> No, no Arrow instance.
16:32:06 <cmccann> ah
16:32:09 <shachaf> Just a thing that could be composed with (.).
16:32:23 <johnw> arrows can be a handy way to gather meta state, instead of using a Free monad
16:32:25 <shachaf> The only possible purpose might be to make Tekmo happy, or something.
16:32:35 <shachaf> I never meta state I didn't like.
16:32:39 <johnw> lol
16:33:05 <cmccann> shachaf never meta pun he didn't like
16:33:06 <johnw> ζηθ!
16:33:22 <cmccann> shachaf loves puns, they are so easy.
16:33:58 <shachaf> cmccann: Now you understand.
16:34:07 <shachaf> cmccann: Hey, wasn't your homework to figure out prism?
16:34:25 <roadfish> So the document I read said that arrows are good for some FRP uses. Any opinion on that? And does anyone hear actually use FRP (yet)? Or is FRP a marginal abstraction like arrows?
16:34:25 <blackdog> hey, any recommendations for a dirt-simple interface for graphics manipulation?
16:34:37 <roadfish> s/hear/here
16:34:37 <blackdog> i want to be able to set a pixel to a colour. that's about it.
16:34:38 <cmccann> shachaf: yes, and I'm spending every bit as much effort on that as I did on my homework when I was in school
16:34:43 <johnw> FRP has a particular problem domain
16:34:44 <edwardk> shachaf only likes funpuns. he doesn't like the other ones
16:35:04 <shachaf> edwardk: I propose rot13 for Untypes/Unfunctions in lens.
16:35:11 * edwardk twitches
16:35:15 <shachaf> > map rot13 ["prism","lens"]
16:35:16 <lambdabot>   ["cevfz","yraf"]
16:35:30 <johnw> > rot13 "shachaf"
16:35:32 <lambdabot>   "funpuns"
16:35:32 <roadfish> blackdog: I'm looking at Diagrams. There is even a #diagrams channel. Do you want to generate image files or look at things on a window?
16:35:49 <roadfish> @hoogle diagrams
16:35:49 <lambdabot> package diagrams
16:35:49 <lambdabot> package diagrams-cairo
16:35:49 <lambdabot> package diagrams-core
16:35:50 <edwardk> > map rot13 ["prism","lens","traversal","getter","setter"]
16:35:51 <lambdabot>   ["cevfz","yraf","genirefny","trggre","frggre"]
16:35:55 <waynr> howdy folks
16:36:04 <shachaf> edwardk: Getter is pretty good.
16:36:09 <shachaf> You get the same set of letters.
16:36:09 <waynr> is there anyway to install a new haskell platform using cabal?
16:36:15 <edwardk> heh
16:36:15 <shachaf> Unfortunately not the same multiset.
16:36:23 <S11001001> @ty liftM singleton . head `asTypeOf` sequence
16:36:25 <lambdabot>     Precedence parsing error
16:36:25 <lambdabot>         cannot mix `.' [infixr 9] and `asTypeOf' [infixl 9] in the same infix expression
16:36:25 <lambdabot>     Not in scope: `singleton'
16:36:28 <shachaf> > rot13 "ravine" -- not as good as ravine
16:36:30 <lambdabot>   "enivar"
16:36:39 <merlin_> are #gtk and #gtk+ biggest gtk channels on freenode? they only have 10 and 14 users
16:36:53 <S11001001> @ty (liftM singleton . head) `asTypeOf` sequence
16:36:54 <lambdabot>     Not in scope: `singleton'
16:36:55 <lambdabot>     Perhaps you meant one of these:
16:36:55 <lambdabot>       `BS.singleton' (imported from Data.ByteString),
16:36:55 <shachaf> merlin_: I bet irc.gnome.org or something has bigger channels?
16:36:57 <S11001001> oh come on
16:37:15 <hpc> merlin_: could be the main channels are on different networks
16:37:21 <merlin_> shachaf: I will take a look
16:37:24 <S11001001> @ty (liftM (:[]) . head) `asTypeOf` sequence
16:37:25 <lambdabot> Monad m => [m a1] -> m [a1]
16:37:36 <S11001001> yes that's much better
16:40:57 <blackdog> roadfish: thanks, i'll have a look
16:41:09 <hpaste> glguy pasted “kleisli with (.)” at http://hpaste.org/80836
16:41:16 <glguy> shachaf: Is that what you had in mind?
16:41:45 <shachaf> @ty let lift f k x = k (\m -> x (m >>= f)) in lift
16:41:46 <lambdabot> Monad m => (a -> m b) -> ((m a -> t1) -> t) -> (m b -> t1) -> t
16:42:22 <shachaf> I think I was thinking of something like
16:42:51 <shachaf> Hmm, let me see.
16:43:11 <shachaf> glguy: Can't you just do lift = (>=>); run = ($ return) or something along those lines?
16:44:12 <shachaf> Hmm, not quite.
16:45:23 <shachaf> Oh, taht works.
16:45:32 <glguy> lift1 x = (>=> x)
16:45:35 <shachaf> @ty let lift = (>=>); run = ($ return); prompt s = putStrLn s >> getLine in run (lift prompt . lift prompt) "hi"
16:45:36 <lambdabot> IO String
16:45:45 <shachaf> glguy: Depends on the order you want. :-) But sure.
16:46:04 <shachaf> It's either (>=>) or (<=<)
16:46:45 <shachaf> This is just the usual (.)/id lifting.
16:48:05 <waynr> is there anyway to install a new haskell platform using cabal?
16:48:37 <shachaf> No.
16:49:06 <Eduard_Munteanu> HP is a binary distribution of various packages.
16:49:20 <shachaf> edwardk: Or source.
16:49:22 <Eduard_Munteanu> Cabal / cabal-install deals with source code
16:49:40 <Eduard_Munteanu> shachaf: you mean Eduard_Munteanu :)
16:49:44 <waynr> okay, just curious because i have a shell account that provides an older version of haskell than what i want to use
16:49:49 <Eduard_Munteanu> (pfew, that's a lot of tabs from 'ed' :D)
16:49:55 <shachaf> Eduard_Munteanu: I mean ed<tab>
16:50:02 <byorgey> blackdog: try JuicyPixel, perhaps
16:50:02 <shachaf> One of you is going to have to change your nick.
16:50:12 <waynr> er, an older version of "haskell-platform"
16:50:25 <blackdog> byorgey: ah, thanks, i'll look at that too.
16:50:29 <Eduard_Munteanu> shachaf: well, edwardk now answers to "lens", so I guess he's fine with that :P
16:50:46 <byorgey> blackdog: what else were you looking at?
16:50:57 <shachaf> edwardk: Have you considered changing your nick to "ed"?
16:51:00 <edwardk> =P
16:51:02 <shachaf> audreyt-style
16:51:04 <blackdog> byorgey: gloss was my first attempt
16:51:08 <waynr> maybe i will try a single-user installation of HP in my home directory
16:51:12 <blackdog> but it's all scalable vectors
16:51:23 <Eduard_Munteanu> waynr: that's probably better
16:51:25 <blackdog> i'm going through joy of clojure and noting the rough bits about doing it in haskell
16:51:27 <byorgey> blackdog: yeah, gloss is not designed to manipulate pixels
16:51:42 <byorgey> neither is diagrams, I thought I saw someone else recommend that
16:51:51 <e> problem solved
16:52:07 <Eduard_Munteanu> Wow, that's one short nick.
16:52:08 <shachaf> i love diagrams
16:52:10 <shachaf> they are so easy
16:52:38 <byorgey> =)
16:53:08 * shachaf has never actually used "diagrams".
16:53:11 <shachaf> But it sounds neat.
16:54:59 <byorgey> shachaf: haha, fair enough
16:55:58 <lispy> blackdog: where you want to set the pixel makes a big difference. If it's just in a .png, that's easy. If it's actually on the screen then we need more info.
16:56:28 <shachaf> setting pixels in a .png is easy
16:56:29 <blackdog> lispy: yeah, would prefer on the screen
16:57:48 <lispy> blackdog: as part of a normal gui program or do you want to use an opengl context?
16:58:11 <blackdog> lispy: i don't much care. ideally it'd be something i can poke from the repl.
16:58:28 <lispy> oh, you dun gone brought the repl into it.
16:58:42 <blackdog> lispy: basically, i'm just trying to replicate what they're doing in joy of clojure, to see at what point the wheels fall off
16:58:43 <lispy> blackdog: Well, plan on using the -fno-ghci-sandbox flag
16:59:22 <lispy> ghci + platform gui libs == Oh no, they abuse thread local storage!
16:59:34 <lispy> (the platform APIs abuse it not ghci)
16:59:59 <hpc> find me a gui lib that doesn't abuse it
17:00:12 <lispy> blackdog: Anyway, getting back to your question. I've always tried to do what you're doing from an opengl context. You might try one of the SDL libraries.
17:00:19 <blackdog> lispy: ok, thanks
17:00:45 <lispy> glfw-b is a really easy way to get an opengl context, but it sounds like it's more than what you want
17:01:20 <lispy> blackdog: I have example code here using opengl raw and glfw-b: https://github.com/dagit/nehe-tuts
17:01:39 * hackagebot network 2.4.1.0 - Low-level networking interface  http://hackage.haskell.org/package/network-2.4.1.0 (JohanTibell)
17:01:45 <Eduard_Munteanu> Why not something like Cairo? That should draw via OpenGL itself, depending on the platform.
17:01:52 <blackdog> lispy: so juicypixels will let me manipulate bitmaps, but nothing for displaying them?
17:02:11 <lispy> blackdog: nothing for displaying them. It barely has anything with IO in the type.
17:02:26 <Eduard_Munteanu> Also, IIRC, there was some info on getting Cairo to draw in an OpenGL context you set up.
17:03:25 <lispy> blackdog: on the one hand, most platform gui libraries give you full "canvas" access, it just won't be portable
17:03:38 <lispy> blackdog: So for example, on linux you could use the X11 bindings to do this
17:03:53 <lispy> on the Win32 bindings, but no idea what to use on the mac
17:04:26 <blackdog> lispy: i am beginning to see some of the appeal of the JVM :)
17:04:35 <lispy> yeah :(
17:04:38 <geekosaur> mac probably uses the x11 bindings
17:04:49 <hpc> blackdog: wait until you see how the JVM works :(
17:04:52 <lispy> blackdog: but if you use something like the AWT you quickly outgrow what you get
17:04:57 <geekosaur> on ML you'd need to install xquartz, the preloaded stub will deal with that
17:05:32 <johnw> cairo on Mac can use quartz
17:06:16 <johnw> you just install that, and gtk, with -fhave-quartz-gtk; and you have to install your gtk so that it links to quartz instead of X11
17:06:17 <geekosaur> can, but is that the default?  from what I've seen most C distributions take the lazy way out and use x11
17:06:18 <blackdog> lispy: this isn't a big professional thing - just want to show you can poke around in a playful environment
17:06:31 <johnw> no, x11 is the default
17:07:23 <geekosaur> (also gtk+ was still fairly buggy with quartz last time I tried it. some programs would mostly work, but for example xchat won't scroll)
17:07:57 <johnw> yeah, i stopped using gtk+quartz too
17:08:05 <johnw> i think threadscope was crashing or something
17:08:47 <frerich_> Hm I have written a little function which works like a web crawler (for a given URI, it recursively follows all links in the HTML code). The actual recursion is done using a foldM internally (for keeping track of which URLs we already visited). The signature is basically 'crawl :: S.Set URI -> URI -> IO [URI]'. Does anybody have some hints how to parallelize this so that it can download n pages simulationously (but it does need to synchronize on
17:08:47 <frerich_> accessing/updating the 'seen URIs' set)?
17:09:27 <johnw> frerich_: stm and monad-par should make that pretty easy to do
17:09:36 <shachaf> johnw: monad-par?
17:09:42 <shachaf> How would that help here?
17:09:45 <johnw> the concurrency monad
17:09:57 <johnw> it can make writing concurrent code easier, that's all
17:09:59 <neutrino> frerich_: data parallel haskell?
17:10:06 <shachaf> monad-par is for parallelism.
17:10:10 <shachaf> You can tell from the name. :-)
17:10:24 <johnw> oh, is it?  guess you're right
17:10:27 <johnw> ok, then stm and parallel-io
17:10:32 <johnw> which you can't tell from the name :)
17:10:51 * shachaf isn't sure about parallel-io.
17:10:59 <johnw> that's the one I use the most
17:11:12 <shachaf> But the package "async" may be useful here.
17:11:16 <johnw> true, that too
17:11:28 <neutrino> but it's such a perfect example problem for DPH
17:11:35 <johnw> parallel-io in general is awesome if you have a "mapM" which could just as easily be a "parMapM"
17:11:42 <johnw> beyond that, maybe it gets a little too clunky
17:12:06 <shachaf> parallel-io seems to encourage a global pool.
17:12:17 <johnw> using local pools with it is so easy
17:12:25 <johnw> just withPool, and there you go
17:12:34 <shachaf> i love local pools
17:12:36 <shachaf> they are so easy
17:13:00 <johnw> neutrino: DPH good for concurrency?
17:14:00 <geekosaur> dph is more intended for parallel numerics
17:14:27 <geekosaur> concurrent I/O, I get the impression it's not well suited for (and not well tested with)
17:14:56 <shachaf> It doesn't really make any sense to use DPH for concurrency.
17:17:20 <simpson> @hoogle (a -> b) -> (c -> d) -> Either a b -> Either c d -- wasn't there something like this?
17:17:20 <lambdabot> Parse error:
17:17:20 <lambdabot>   (a -> b) -> (c -> d) -> Either a b -> Either c d -- wasn't there something like this?
17:17:20 <lambdabot>                                                    ^
17:17:24 <simpson> @hoogle (a -> b) -> (c -> d) -> Either a b -> Either c d
17:17:24 <lambdabot> No results found
17:18:07 <shachaf> simpson: bimap
17:18:09 <geekosaur> does that even make sense?  maybe Either a c -> Either b d?
17:18:14 <shachaf> Er, right.
17:18:28 <shachaf> bimap is what geekosaur said.
17:18:55 <Eduard_Munteanu> There is a bifunctor thingy somewhere.
17:19:12 <Eduard_Munteanu> Though a bifunctor is more than just a functor in two arguments.
17:19:27 <simpson> Oh, derp, yeah, got 'em backwards.
17:19:33 <simpson> :t bimap
17:19:34 <lambdabot>     Not in scope: `bimap'
17:19:34 <lambdabot>     Perhaps you meant `imap' (imported from Control.Lens)
17:19:34 <shachaf> Eduard_Munteanu: It is?
17:19:41 <Nereid> ah, async looks useful.
17:19:49 <shachaf> i love async
17:19:50 <shachaf> it is so easy
17:20:03 <edwardk> i think shachaf is broken
17:20:17 <Nereid> lol
17:20:24 <Eduard_Munteanu> shachaf: yeah, you want those two functors to be coherent, some commutative diagrams I can't remember now
17:21:29 <Nereid> a bifunctor is literally a functor from a product of two categories.
17:21:53 <Nereid> oh, you're saying that's different from a mapping that's a functor in each argument separately.
17:22:31 <Nereid> which is actually fairly obvious.
17:22:44 <Eduard_Munteanu> Yeah.
17:22:52 <Nereid> because if *that* were the case, you'd have bimap f id = id, which is dumb.
17:28:36 <neutrino> hey guys, what was that technique in stm to wait for a specific TVar to assume a given value?
17:28:47 <neutrino> for example, wait for a list to become empty
17:28:56 <neutrino> you could do it in an atomic block
17:29:17 <applicative> > ['a'..'z']  & map (:"map") & unwords & text
17:29:19 <lambdabot>   amap bmap cmap dmap emap fmap gmap hmap imap jmap kmap lmap mmap nmap omap ...
17:29:45 <applicative> > ['m'..'z']  & map (:"map") & unwords & text
17:29:46 <lambdabot>   mmap nmap omap pmap qmap rmap smap tmap umap vmap wmap xmap ymap zmap
17:29:55 <napping> you mean retry?
17:30:13 <oio> what are some constrcuts i could use with pattern match?
17:30:24 <oio> like (:) @
17:30:27 <sipa> :t (&)
17:30:28 <lambdabot> a -> (a -> b) -> b
17:31:26 <oio> i feel pattern match is not very flexible ;(
17:31:30 <Eduard_Munteanu> oio: you can pattern-match on any data constructors.
17:31:39 <gwern> @quote pattern.*match
17:31:39 <lambdabot> lispy says: The crappy thing about using partial fun*** Exception: Pattern match failure
17:31:40 * hackagebot TypeCompose 0.9.8 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.9.8 (ConalElliott)
17:32:05 <Eduard_Munteanu> oio: depending on the case, you might also want to look at guards or perhaps view-patterns.
17:32:35 <oio> ok
17:33:37 <Cale> oio: Any value whose name starts with an uppercase letter or colon.
17:35:06 <CodeDmitry> Hello :)
17:35:18 <h-rex> hi
17:35:32 <CodeDmitry> I think i found a huge flaw in C/C++ language, which means i'm probably wrong
17:35:50 <geekosaur> it takes effort to find huge flaws in C?
17:35:57 <CodeDmitry> fundamental flaws yes
17:36:08 <CodeDmitry> C is the almost perfect C
17:36:18 <Eduard_Munteanu> Judging by the size of the standard, the attack surface is pretty large. ;)
17:36:32 <CodeDmitry> kinda but this is a really important one
17:36:42 <h-rex> what is it?
17:36:47 <CodeDmitry> In fortran, you can declare data using data keyword, and this data will be inserted into the executable at compile time
17:36:48 <shachaf> C/C++ is not a language.
17:36:58 <CodeDmitry> like "something equ something else" in assembly
17:37:07 <CodeDmitry> you can emulate it with predefined arrays
17:37:07 <Eduard_Munteanu> @karma C/C
17:37:07 <lambdabot> C/C has a karma of 370
17:37:20 <CodeDmitry> but predefined arrays don't have pattern matching
17:37:37 <CodeDmitry> Eg, what If i want an array of 100 1s followed by 100 2s
17:37:47 <CodeDmitry> id need to either make a huge declare statement
17:37:53 <shachaf> Does this have anything to do with Haskell?
17:38:00 <CodeDmitry> or resort to runtime allocation (Which kills cycles)
17:38:13 <cmccann> shachaf: C/C cancels to get 1, increment that to get 2, therefore C/C++ is actually two languages, qed
17:38:34 <geekosaur> mostly in C we do those by writing a script to generate the C initializer
17:38:35 <shachaf> cmccann: It's time you abandoned "qed" for ∎.
17:38:44 <CodeDmitry> whats a black box
17:38:46 <CodeDmitry> and where can i learn it
17:38:59 <cmccann> shachaf: it's in my abbreviations file but I was too lazy to grab it from another window
17:39:16 <shachaf> cmccann: Ctrl-Shift-U 2 2 0 E Space
17:39:40 <blackdog> shachaf: that's more keystrokes than qed!
17:39:48 <h-rex> 220E
17:40:06 <Eduard_Munteanu> Grr, can't find it in SCIM here.
17:40:07 <cmccann> yeah, in my editor it's just "qed", ctrl-B
17:40:33 <cmccann> holding down ctrl and shift at the same time is waaaaaaaay too much effort.
17:41:26 <h-rex> today I wrote my first useful Haskell library
17:41:39 <CodeDmitry> I find it odd that even though haskell being lazy doesn't directly imply that its coders are, but from i'm seeing... they are...
17:41:54 <cmccann> all programmers are lazy, it's a job requirement
17:41:55 <hpc> CodeDmitry: all the best programmers are lazy by default
17:42:11 <h-rex> ergo: the best code is lazy by default
17:42:14 <shachaf> i love being lazy
17:42:15 <shachaf> it is so easy
17:42:16 <CodeDmitry> I am very critical upon that conclusion
17:42:20 <frerich_> shachaf: Thanks for pointing out the async package earlier, it seems to be quite useful for my use case
17:42:35 <hpc> CodeDmitry: programmers who elect to be strictly lazy end up not having jobs :P
17:42:36 <cmccann> shachaf: that would have been much funnier if you'd left off the second line
17:42:45 <shachaf> cmccann: I'm sorry.
17:42:50 <cmccann> you should be.
17:43:01 <hpc> shachaf: WHAT HAVE YOU DONE THINK OF THE JOKES
17:43:03 <hpc> OH THE HILARITY
17:43:20 <h-rex> anybody that want to take a look at my code and see what can be improved?
17:43:35 <CodeDmitry> In any case, C should really have a way to declare an array through a pattern
17:43:50 <shachaf> h-rex: Don't ask it like that. Just put the code on hpaste.org and paste a link.
17:43:57 <CodeDmitry> eg, int myArray[] = {100 ints = 100, 100 ints = 200}
17:44:02 <h-rex> ok
17:44:07 <shachaf> h-rex: That way people don't have to commit to helping you, and then feel bad if they can't.
17:44:09 <Clint> no, make hpaste.org paste the link
17:44:09 <Eduard_Munteanu> CodeDmitry: dunno about Fortran (but I'd be inclined to say no), but what pattern-matching is there in C?
17:44:29 <CodeDmitry> fortran data statement is very primitive
17:44:32 <shachaf> CodeDmitry: Does this have anything to do with Haskell?
17:44:40 <h-rex> here is the github page:
17:44:41 <h-rex> https://github.com/bvssvni/haskell-groups/blob/master/groups.hs
17:44:46 <CodeDmitry> just wanted to bring up an interesting discussion, is it against the rules? :
17:44:51 <CodeDmitry> :\
17:45:02 <Eduard_Munteanu> CodeDmitry: #haskell-blah is better for stuff like that
17:45:12 <geekosaur> I think at this point tradition is too well entrenched and people will just keep using scripts to pregenerate such initializers
17:45:45 <CodeDmitry> how do i pm somebody
17:46:00 <h-rex> <name> <colon> <message>
17:46:13 <cmccann> I think he means /msg.
17:46:40 <Eduard_Munteanu> cmccann: I think h-rex meant what he said ;)
17:47:00 <cmccann> that is entirely possible.
17:47:03 <Eduard_Munteanu> CodeDmitry: let's talk in here.
17:47:10 <Eduard_Munteanu> Erm, #haskell-blah
17:47:14 <geekosaur> /msg or /privmsg
17:47:15 <shachaf> No, not #haskell-blah.
17:47:36 <CodeDmitry> I keep being threatened not to talk not about haskell in this chat...
17:47:42 <CodeDmitry> and I dont wanna make more enemies :\
17:48:15 <CodeDmitry> Especially when help on haskell is so hard to find
17:48:43 <Eduard_Munteanu> Private messages aren't an option either, at least for random chat / help requests etc.
17:49:15 <CodeDmitry> im in haskell blah
17:49:19 <frerich_> h-rex: I think your code could be simplified by using pattern matching a lot more. For instance, I think the first function could be replaced with 'group_index [] = []' and 'group_index (a:b:rest) = [a..b] ++ group_index rest'.
17:49:42 <h-rex> noted
17:50:11 <h-rex> ah I forgot
17:50:16 <applicative> what does your library define h-rex
17:50:27 <oio> best haskell multiplaform 3d engine?
17:50:35 <applicative> oh i see the groups ?
17:50:42 <h-rex> it does Boolean algebra on lists, but in a more efficient form
17:51:04 <h-rex> in a way such it doesn't have to access each item
17:51:13 <frerich_> h-rex: or group_Min could be 'group_min (x:_) (y:_) = min x y'
17:51:28 <h-rex> thanks
17:51:55 <frerich_> h-rex:: Just look closer at the places using !! or head or tail or fst. Chances are you don't need them
17:52:10 <h-rex> noted
17:54:19 <lispy> h-rex: we don't use tabs in haskell
17:54:35 <lispy> h-rex: Well, I suppose you can, but you won't be able to work with others
17:54:44 <h-rex> ok
17:55:07 <h-rex> I wrote this in TextEdit
17:55:18 <lispy> http://urchin.earth.li/~ian/style/haskell.html
17:55:29 <h-rex> gold
17:55:32 <lispy> that webpage explains some of the difficulties of using tabs
17:59:24 <h-rex> thanks for the feedback, I'll clean up my code
18:12:37 <applicative> is that style page consistent with https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md It would be nice to have more than one
18:16:41 * hackagebot TypeCompose 0.9.9 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.9.9 (ConalElliott)
18:29:50 <hpaste> author pasted “title” at http://hpaste.org/80840
18:32:23 <monochrom> firstly, inorder (Knoten up left right) = ...  you need the parentheses
18:32:27 <pauser> hello everyone, im trying to make an inorder function but ghci says im not that smart yet :D. Why can`t i just say inorder Empty = "" like in here http://hpaste.org/80840 ?
18:33:07 <pauser> what? how do you know that im asking ?
18:33:14 <geekosaur> [16 21:29] <hpaste> author pasted “title” at http://hpaste.org/80840
18:33:22 <Eduard_Munteanu> Heh.
18:33:23 <monochrom> secondly, type of "up" is "a". that's what you said in "inorder :: Baum a -> String". you cannot just pretend that "a" is "String". therefore, you cannot just go "... ++ up ++ ..."
18:33:30 <geekosaur> you neglected to fill in the prompts but you didnt tell it not to announce...
18:34:08 <pauser> i derived Show, is not that what i need ?
18:34:30 <geekosaur> haskell still won;t automatically convert things to strings
18:34:36 <hpaste> applicative annotated “title” with “title (annotation)” at http://hpaste.org/80840#a80841
18:34:45 <geekosaur> deriving Show just means you can use (show a) to make a String from an a
18:35:09 <monochrom> "deriving Show" does not help this one
18:35:38 <monochrom> how about this?  inorder :: (Show a) => Baum a -> String
18:35:53 <monochrom> inorder (Knoten up left right) = ... ++ show up ++ ...
18:36:18 <monochrom> "deriving Show" for Baum is completely unrelated
18:37:12 <applicative> ah yes, this is what my annotation did pauser , I mean, what monochrom said
18:37:21 <pauser>  inorder :: (Show a) . this just says that the parameter a shout become a string ?
18:37:49 <applicative> pauser: yes, you can give it Baum Int, but not Baum (Int -> Int) since the latter can't be 'shown'
18:37:55 <monochrom> no. it means "a" supports "show"
18:38:04 <geekosaur> ^^
18:38:16 <applicative> pauser: the same will hold for the derived Show, which has an implicit Show a => constraint
18:38:44 <applicative> 'show' makes a thing become a string I guess....
18:39:06 <Eduard_Munteanu> :t show
18:39:07 <lambdabot> Show a => a -> String
18:39:17 <applicative> pauser: but of course, Baum X is never a String
18:39:53 <hpaste> author annotated “title” with “title (annotation)” at http://hpaste.org/80840#a80842
18:40:12 <applicative> meinbaum = Knoten 1 (Knoten 2 (Knoten 3 Leer Leer) Leer) (Knoten 3 Leer Leer) -- missing a Leer or two in there
18:40:39 * Eduard_Munteanu wonders how monochrom knew pauser had joined the channel before answering, though
18:40:50 <applicative> pauser: you need to use 'show up' where you use up
18:40:51 <monochrom> I did not know
18:41:04 <Eduard_Munteanu> Ah, I guess you answered anyway.
18:41:26 <monochrom> I just assumed
18:41:31 <pauser> monochrom: how ?
18:41:32 <cmccann> also, anyone who pastes something they want feedback on is usually either in the channel or about to join
18:41:55 <monochrom> sorry, "how?" for what?
18:42:03 <pauser> applicative: well, why not at all parameter but just for up ?
18:42:13 <applicative> pauser: up can be an Int, a String, a Baum Int, or anything, so you need to use show on it, if the baah ++ show up ++ moo is to be a string
18:42:20 <Eduard_Munteanu> Yeah, I would have assumed he was already in the channel.
18:42:40 <applicative> pauser: because inorder is recursive; the signature shows it is a String
18:43:07 <applicative> I mean, that inorder left and inorder right are Strings; you just need to make up a string
18:44:30 <applicative> inorder takes a Baum (left or right); show takes a Show -able kind of thing whatever it is, and makes a String, so the whole ++ ++ line will make sense
18:44:31 <pauser> im asking because i thought inorder :: Show a => .. will make all the parameters converted to string
18:44:54 <monochrom> no, that is way off
18:46:01 <applicative> pauser: you see from your definition of the Baum a type, that the Knoten can have any sort of thing stored in them
18:46:09 <applicative> it is a polymorphic type
18:47:21 <applicative> but you won't be able to write inorder so that it will work for any kind of Baum - what about function types, or IO actions -- there can be Baume of these too
18:47:48 <applicative> inorder will only make sense if the things stored in the nodes are themselves show-able, stringable or whatever
18:48:07 <applicative> Show a => expresses this constraint on a legitimate inorder definition
18:49:31 <applicative> pauser: boolbaum = Knoten True (Knoten False (Knoten False Leer Leer) Leer) (Knoten True Leer Leer)
18:49:56 <applicative> show will work for this, as will inorder -- since Bool is a Show type
18:50:11 <applicative> or 'there is a Show instance for Bool' as we say
18:51:04 <pauser> how do i check if something is a type  :t Bool ?
18:52:16 <pauser> just founded as you say data  Bool  =  False | True deriving (Read, Show, Eq, Ord, Enum, Bounded) :D
18:54:06 <hpaste> applicative annotated “title” with “title (annotation) (annotation)” at http://hpaste.org/80840#a80843
18:54:29 <applicative> ^^^ here's a couple more example trees.
18:55:07 <applicative> in ghci you will see that inorder boolbaum already works
18:55:14 <Eduard_Munteanu> :k Bool
18:55:16 <lambdabot> *
18:55:35 <Eduard_Munteanu> pauser: you could use that, when you're confused ^^
18:56:12 <pauser> it tells this here: Bool :: *
18:56:28 <Eduard_Munteanu> :k False
18:56:30 <lambdabot> Not in scope: type constructor or class `False'
18:56:40 <Eduard_Munteanu> Oh, crap, bad advice.
18:56:53 <Eduard_Munteanu> Ever since ConstraintKinds I guess.
18:56:56 <applicative> @type True
18:56:58 <lambdabot> Bool
18:57:13 <pauser> applicative: thanks for the examples
18:57:17 <Eduard_Munteanu> Anyways, if you ask that question, perhaps there's something else you don't know.
18:57:32 <Eduard_Munteanu> It should be readily apparent whether something's a type or a value.
18:58:14 <pauser> http://zvon.org/other/haskell/Outputprelude/Bool_d.html :P
19:00:12 <applicative> there are probably documents on your system if you have the ghc
19:01:32 <applicative> it will be in  a directory named something/share/doc/ghc/html
19:02:09 <pauser> i think, this channel is the best because of the people :D
19:10:26 <shapr> johnw: pong
19:11:40 <shachaf> lispy: I don't know enough Agda to talk in #agda. I'm not sure I understand your question, though. Is it still relevant in Haskell?
19:11:43 * monochrom does not exactly like parsec's tokenPrim wanting next token's position, as opposed to current token's position
19:12:09 <lispy> shachaf: yeah, I should be able to motivate it in Haskell, but I'd prefer to see the dependent type solution
19:12:18 <shachaf> monochrom: Does it interfere with you Continuation Parsec Style?
19:12:27 <lispy> shachaf: suppose you want to check if a boolean function of arity-n is a tautology.
19:12:28 <shachaf> your
19:12:38 <monochrom> it doesn't. it makes something else awkward
19:12:48 <shachaf> i love continuation parsec style
19:13:15 <lispy> shachaf: you might define valid1 bf = bf True && bf False for arity-1, and then valid2 bf = bf True True && bf True False && bf False True && bf False False, for arity-2
19:13:35 <shachaf> lispy: Is there a particular reason to have that, rather than accepting a list like tac suggested?
19:14:00 <lispy> shachaf: when you get to 3 & 4, list comprehensions are better, valid3 bf = and [ bf p q r | p <- [True, False], q <- [True, False], r <- [True, False ]], etc
19:14:05 <shachaf> Well, OK, not just a list.
19:14:31 <lispy> shachaf: I'd prefer to pass in the arity (implicitly or explicitly) and then have the validn function feed the boolean function
19:14:55 <shachaf> OK.
19:15:26 <shachaf> It seems to me like your life will be easier if you represent your functions as exists n. Vect n Bool -> Bool or something.
19:16:06 <pyry`> Anyone had much luck with Data.Yaml? I seem to be having issues, and can't really tell where they're coming from.
19:16:53 <shachaf> pyry`: Data.Yaml looks bizarre to me, trying to fit YAML into JSON.
19:17:55 <shachaf> But if *you* can't tell where the issues are coming from, how can anyone else have a hope of doing it? You have a major advantage.
19:18:01 <pyry`> shachaf: perhaps. i managed to get aeson to work
19:18:13 <pyry`> shachaf: My hope was that someone else encountered them as well.
19:20:39 <shachaf> Does dons's answer at http://stackoverflow.com/questions/14368391/which-green-threads-libraries-are-available-for-c-that-can-match-the-performance make any sense?
19:26:46 <edwardk> pyry`: aheller is on here some times and he spent quite a bit of time beating on data.yaml/aeson
19:27:00 <edwardk> i avoid each like the plague ;)
19:27:43 <tac> What is the proper way to catch an IO exception in Haskell?
19:27:53 <shachaf> Control.Exception.catch
19:28:00 <shachaf> With ScopedTypeVariables or something. :-(
19:28:04 <pauser> another question: insertElem :: (Ord a), can i also use Eq like insertElem ::(Ord, Eq a) ?
19:28:14 <tac> shachaf: danke
19:28:22 <shachaf> pauser: That Eq is pointless, because Ord implies Eq.
19:28:24 <applicative> @type catch
19:28:25 <lambdabot> IO a -> (IOError -> IO a) -> IO a
19:28:29 <shachaf> Not that.
19:28:37 <shachaf> That catch is deprecated and gone in GHC 7.6.
19:28:48 <shachaf> Cale: Could you remove that from L.hs and import Control.Exception instead?
19:29:00 <tac> This is why I asked. It's hard to tell deprecated stuff from the current stuff
19:29:01 <pauser> ah I need to use Eq if i want to have both, right ?
19:29:14 <tac> @type Control.Exception.catch
19:29:16 <lambdabot> GHC.Exception.Exception e => IO a -> (e -> IO a) -> IO a
19:29:28 <shachaf> tac: Control.Lens makes it a bit easier.
19:29:28 <applicative> insertElem :: Ord a => Baum a -> a -> Baum a  makes sense
19:29:38 <tac> shachaf: how so?
19:29:48 <shachaf> catching _IOException :: IO r -> (IOException -> IO r) -> IO r
19:29:59 <shachaf> And also a bunch of other helpers.
19:30:02 <shachaf> See Control.Exception.Lens
19:30:08 <edwardk> >>> catching _AssertionFailed (assert False (return "uncaught")) $ \ _ -> return "caught"
19:30:15 <pauser> applicative: but in Ord there is no ==
19:30:20 <pauser> and i need it
19:30:21 <edwardk> >>> handling _NonTermination (\_ -> return "caught") ...
19:30:32 <tac> Does that require me learning wtf lenses are?
19:30:36 <applicative> @src Ord
19:30:36 <lambdabot> class  (Eq a) => Ord a  where
19:30:36 <lambdabot>     compare      :: a -> a -> Ordering
19:30:36 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
19:30:36 <lambdabot>     max, min         :: a -> a -> a
19:30:45 <edwardk> tac: probably
19:30:49 <tac> hmm
19:31:12 <edwardk> technically it requires you to learn what a prism is. there isn't a single lens in Control.Exception.Lens
19:31:12 <tac> so it's Prelude.catch that is deprecated?
19:31:21 <applicative> pauser: ^^^ class  (Eq a) => Ord a  where ... means a has to be an Eq instance with == and /= before you make an Ord instance with <=
19:31:29 <edwardk> tac: Control.Exception provides a much more powerful mechanism
19:31:55 <applicative> tac yes, I should have realize before @type -ing it
19:32:26 <tac> hmm
19:32:31 <pyry`> edwardk: thanks, i'll keep an eye out
19:32:43 <tac> What if I just want to catch any old exception?
19:32:52 <edwardk> catching id
19:32:53 <tac> It's saying I have an ambiguous constraint on the except e
19:33:18 <applicative> tac http://hackage.haskell.org/package/errors http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
19:33:20 <edwardk> or with Control.Exception use catch   with (\(e :: SomeException) -> ...)
19:33:31 <applicative> yeah, thats the downside of Control.Excpetion
19:33:51 <edwardk> Control.Exception.Lens is set up to use explicit prisms to avoid the scopedtypevariable mess
19:33:57 <tac> edwardk: yeah. Basically I want that, but I don't know what SomeException ought to be. Also, I can probably only class certain classes of exceptions that way
19:34:01 <shachaf> I like how GHC pretty more or less forces you to use an extension to write exception-handling Haskell code and stay sane.
19:34:09 <shachaf> tac: SomeException is a type.
19:34:09 <edwardk> tac: SomeException catches all Exceptions
19:34:16 <edwardk> tac: that wasn't a placeholder ;)
19:34:17 <tac> yeah... I just looked that up
19:34:23 <tac> Sometimes I can't tell when you people are being literally
19:34:25 <tac> literal*
19:34:30 <shachaf> On the other hand usually catching SomeException is considered a bad idea.
19:34:40 <edwardk> tac: yeah that literally drives me crazy
19:34:55 <applicative> or e :: IOException
19:34:57 <shachaf> edwardk is being figurative. He was already crazy.
19:35:02 <edwardk> shachaf: =)
19:35:16 <tac> crap.... man I don't actually __use__ haskell nearly enough
19:35:25 <shachaf> haskell is the devil
19:35:27 <tac> I need to add a pragma, but I can't remember the syntax
19:35:27 <shachaf> use php
19:35:35 <shachaf> {-# LANGUAGE Hi #-}
19:35:49 <tac> ty
19:36:02 <monochrom> {-# LANGUAGE Enhanced_PHP #-}
19:36:03 <shachaf> edwardk: This lastOf business is a huge rabbit hole.
19:36:10 <edwardk> heh
19:36:13 <shachaf> i love enhanced php
19:37:00 <applicative> {-# LANGUAGE Rank2PHP #-}
19:37:39 <monochrom> > fix ("I love \"" ++)
19:37:41 <lambdabot>   "I love \"I love \"I love \"I love \"I love \"I love \"I love \"I love \"I ...
19:37:51 <monochrom> > text (fix ("I love \"" ++))
19:37:56 <lambdabot>   mueval: ExitFailure 1
19:37:57 <lambdabot>  mueval: Prelude.undefined
19:38:10 <monochrom> unfortunately
19:38:51 <tac> Thank you guys
19:38:54 <tac> Thanks to your help
19:38:59 <erineh_> > "To " ++ fix ("love is to " ++)
19:39:00 <tac> I can now turn my roommate's lights on and off remotely
19:39:01 <lambdabot>   "To love is to love is to love is to love is to love is to love is to love ...
19:39:03 <tac> from my IRC bot
19:39:15 <tac> and my bot doesn't crash if his Raspberry Pi goes offline for some reason
19:39:20 <tac> Thanks to you
19:39:36 <erineh_> > "To" ++ fix (" love is to" ++) ++ " love."
19:39:38 <lambdabot>   "To love is to love is to love is to love is to love is to love is to love ...
19:39:50 * monochrom frowns. I understand switching lights remotely, but why IRC bot?
19:40:16 <tac> > ("I " ++ fix (" love" ++)) ++ "php"
19:40:19 <lambdabot>   "I  love love love love love love love love love love love love love love l...
19:40:28 <monochrom> soon, your IRC bot will remotely control my remote control helicopter too
19:40:31 <tac> (hint: it never gets to the "php" part)
19:40:35 <augur> Rank2PHP?
19:40:37 <augur> what is that :|
19:40:45 <tac> monochrom: Maybe I'm not around to turn off my roommate's lights
19:40:50 <monochrom> PHP enhanced with rank-2 types
19:41:06 <tac> maybe I allow everyone in our IRL channel should be able to turn his lights off
19:41:14 <monochrom> yeah ok, please use a web app rather than IRC! :)
19:41:16 <Eduard_Munteanu> So they're taking a top-down approach?
19:41:21 <erineh_> Rank2HP = Rank2HP Hypertext Processor
19:41:27 <applicative> > vcat $ map (text . (++ " It is so easy.") . ("I love "++)) $ drop 10 cake
19:41:29 <lambdabot>   I love Fish shaped candies. It is so easy.
19:41:30 <lambdabot>  I love Fish shaped solid waste....
19:41:37 <Eduard_Munteanu> They get rank-2 types before plain types? :P
19:41:51 <monochrom> I have a cunning plan!
19:42:14 <Eduard_Munteanu> Sod off, Baldrick. :P
19:42:14 <applicative> > cake & vcat . map (text . (++ " It is so easy.") . ("I love "++)) . drop 12
19:42:16 <lambdabot>   I love Fish shaped dirt. It is so easy.
19:42:16 <lambdabot>  I love Fish shaped ethylbenzene. I...
19:42:22 <monochrom> set up some twitter thing so that you switch lights by posting on twitter
19:42:33 <applicative> hey how come no prettyprint lenses??
19:42:38 <tac> monochrom: that's next on the docket
19:42:45 <monochrom> good!
19:42:57 <edwardk> applicative: see experimental/Control/Lens/Format.hs
19:43:04 <tac> monochrom: It's just the first step to my real plan
19:43:13 <edwardk> also github.com/ekmett/terminal.git   we're working on it ;)
19:43:27 <tac> Getting good enough futzing around with XMLRPC, IRC bots, and the Raspberry Pi to make a robot that will stalk my cat during the day
19:43:28 <applicative> edwardk: hm
19:43:33 <tac> complete with a webcam and legs
19:44:31 <monochrom> haha Eduard_Munteanu
19:44:34 <tac> Hacking done for the day. Thanks again for the help guyz
19:45:54 <monochrom> Edmund_Munteanu? :)
19:46:04 <applicative> Control.Lens.Format is tough reading
19:46:12 <edwardk> its still an experiment
19:46:24 <edwardk> we're not planning on shipping it in 3.8
19:46:38 <edwardk> you can use it like holeymonoid. that does have docs
19:46:44 <edwardk> but it fits into the lens framework instead
19:47:49 <shachaf> edwardk: So in elliott's scheme, Format might end being something like "representable by a monoid"?
19:47:57 <Eduard_Munteanu> monochrom: heh, I guess so
19:48:02 <shachaf> If it turns out that we can generalize it to p a b -> p (m -> a) (m -> b)
19:48:06 <erineh_> is it possible to "process the rest of the thing in a Chan then quit"
19:48:13 <erineh_> things
19:48:18 <shachaf> erineh_: No.
19:48:22 <shachaf> Someone can always add more.
19:48:31 <shachaf> You could add an explicit "I'm done" message to the Chan.
19:48:32 <erineh_> what if i hold an mvar locking the writes
19:48:58 <shachaf> What if you do?
19:49:08 <applicative> edwardk: youre on 3.7.3, 3.8 will be Friday?
19:49:20 <erineh_> then that stops people (following my protocol) from writing to the chan
19:49:23 <edwardk> '3-5 days'
19:49:28 <shachaf> edwardk: Some users are still on 3.3. :-(
19:49:40 <edwardk> shachaf: poor bastards
19:50:10 <monochrom> I still recommend having a special message to tell the reader to quit
19:50:28 <shachaf> erineh_: How will that help you?
19:50:30 <erineh_> who writes that message though
19:50:35 <edwardk> my usual way to get the reader to quit is to start writing about lenses
19:50:47 <shachaf> erineh_: A Chan has a few operations. One of them is to read. If you try to read from an empty Chan, it blocks.
19:51:06 <erineh_> yeah so in my case, if i block, i need to quit
19:51:15 <erineh_> or else block forever because i know it will never be written to again
19:51:24 <monochrom> or, use STM, so that you can listen to two channels at once, but normally the second channel is quiet until someone says "quit"
19:52:09 <erineh_> basically taking a write lock ensures that 'the rest of the messages ever' is finite
19:52:30 <edwardk> erineh_: then why is this thing you have a Chan in the first place?
19:52:48 <erineh_> so that things can send messages without blocking
19:52:54 <erineh_> oh no!
19:52:59 <monochrom> you ask, in my scheme, who writes the quit message. I ask, in your scheme, who raises the "from now on forbid further sending" flag
19:53:20 <erineh_> good call
19:53:45 <monochrom> or, in your another scheme, I ask, who tells the reader "from now on, blocking means quit, so don't bother waiting"
19:55:17 <erineh_> yep, the reader needs to lock, write QUIT, process all the messages. and senders will know (because of the write lock) that sending is impossible
19:58:08 <roadfish> is there a way to use ghci on cabal packages? you see, I got this weird MonadTrans compile error and I found webpages that said the wrong package was being pulled in. But the webpages said to build a cabal package ... which fixed my problem! But how can I use ghci on the top level .hs file that holds the main?
19:59:48 <monochrom> I don't understand. ghci uses all cabal packages you have installed. do nothing.
20:00:05 <shachaf> i love doing nothing
20:00:07 <shachaf> it is so easy
20:00:22 <monochrom> do you want an example:
20:00:24 <monochrom> err
20:00:26 <monochrom> do you want an example?
20:02:14 <monochrom> also, these days, I cannot see how there is a wrong package providing an unwanted MonadTrans
20:03:07 <roadfish> monochrom:The cabal package contains a single .hs file called diapang.hs and this file has a main. When I do ghc diapang.hs or ghci diapang.hs, I get "No instance for (MonadTrans ...etc)" error. But when I do "runghc Setup build", the package builds quite nicely.
20:03:30 <monochrom> also, logically, I am skeptical about the advice on the webpage. if you possess an undesirable MonadTrans, it means you possess an undesirable package, and the solution should be to remove packages, not add more packages
20:04:41 <roadfish> here is the webpage:
20:04:44 <roadfish>    http://stackoverflow.com/questions/10729291/lifting-trouble-with-resourcet
20:05:20 <monochrom> I don't really care about the webpage. what package is this so I can see what MonadTrans *it* is talking about?
20:05:38 <roadfish> amazingly, the advice worked. the webpage says that "Cabal will make sure you have the right versions of the libraries involved"
20:06:35 <roadfish> I will paste the code for you to try out. ... one moment
20:07:56 <hpaste> roadfish pasted “get MonadTrans error when doing ghc compile” at http://hpaste.org/80845
20:08:54 <roadfish> monochrom: this is the "program" ... created by me. I am just goofing around with diagrams and pango packages.
20:10:47 <roadfish> you can just put in into some file, say diapang.hs and the do "ghc diapang.hs". I got a weird MonadTrans compile error. And that stackoverflow.com webpages nailed my problem exactly.
20:11:35 <monochrom> what is the exact verbatim unabridged uncensored error message?
20:11:40 <geekosaur> what is this weird.. .that
20:12:10 <monochrom> of course, blind guesses are cheap, I can already offer blind guesses, you have too many mtl's installed
20:12:23 <shachaf> monochrom: Can I have a blind guess?
20:12:55 <roadfish> yes, I do seem to have an mtl problem
20:13:07 <shachaf> roadfish: I note that you still haven't fulfilled monochrom's request.
20:13:28 <monochrom> people never fulfill my request. I am used to it.
20:13:42 <shachaf> Always the same request.
20:13:47 <hpaste> roadfish pasted “verbatim error message when ghc compile but no error when compile in with cabal” at http://hpaste.org/80846
20:14:04 <roadfish> one moment please
20:14:15 <shachaf> roadfish: Looks like the issue is with multiple versions of "transformers".
20:14:18 <roadfish> I was just giving a bit extra info at the end
20:14:34 <geekosaur> yep, you have mul;tiple versions of transformers and different libraries are trying to use different versions
20:14:53 <shachaf> roadfish: You should specify package versions in your build-depends list.
20:15:18 <monochrom> the webpage's advice is a temporary workaround. it does not solve the real problem. it is not a solution.
20:15:44 <shachaf> monochrom: But it worked!
20:15:48 <shachaf> You can't argue with results, monochrom.
20:15:55 <roadfish> ok, I'm buying this. But should I try to remove one of the mtl libraries?
20:16:05 <monochrom> I can predict further problems
20:16:08 <shachaf> Did what I suggested not work?
20:16:39 <roadfish> I'm sorry ... is your suggesting to "specify package versions in your build-depends"?
20:16:50 <shachaf> Albert "Cassandra" Y. C. Lai
20:16:53 <shachaf> roadfish: Yes.
20:16:56 <shachaf> You specify a version of base.
20:16:57 <roadfish> but cabal is not having any trouble building it anyway
20:17:04 <shachaf> Yes it is.
20:17:09 <shachaf> It's picking the wrong versions of packages.
20:17:22 <roadfish> or is there some way to specify this package version within ghci?
20:17:31 <shachaf> Oh, within ghci is a different matter.
20:18:00 <shachaf> OK.
20:18:12 <shachaf> You're probably best off having only one version of transformers.
20:18:12 <monochrom> actually, there are flags for this for ghci too. but I would not recommend it. why bother.
20:18:34 <roadfish> I guess I can specify the package in the diapang.cabal file. I'm not sure yet how to do this. But that would only fix something that isn't broken anyway.
20:19:01 <monochrom> my recommendation is to allow at most one instance, for every lib, to live. at most one. use sandboxing if different projects want different versions.
20:19:02 <shachaf> You should do it anyway.
20:19:13 <shachaf> But indeed it won't help here.
20:19:18 <roadfish> ok, I like the idea of "only one version of the transformers". I will need to learn how to figure out what version I have and get rid of it.
20:19:46 <monochrom> specifying versions in project.cabal is orthogonal. it is for other people's sake, not for your promiscuity
20:20:00 <flebron> Is there a cleaner way of writing [toUpper h, toLower h], where h = head s?
20:20:27 <shachaf> What if s is empty?
20:20:32 <roadfish> I'm not quite sure what promiscuity means in this context. I assume that I shouldn't be promiscuous and will strive to not be that way.
20:20:47 <monochrom> promiscuity means possessing many versions
20:20:59 <flebron> shachaf: Already taken care of, previous definition of the function.
20:21:04 <monochrom> because it is what an upgrade whore does
20:21:20 <flebron> allCaps "" = [""], allCaps s = [x:xs | x <- [toUpper h, toLower h], xs <- allCaps $ tail s]
20:21:52 <flebron> (where h = head s). This gives, from "foo", ["foo", "Foo", "FOo", "FOO", "fOo", ....]
20:22:21 <flebron> oh i could allCaps s:ss :p
20:22:48 <flebron> allCaps (x:xs) = [y:ys | y <- [toUpper x, toLower x], ys <- allCaps xs] :)
20:22:53 <Cale> shachaf: I guess I can import the Control.Exception.catch, though there's not really any way to use it...
20:22:55 <shachaf> Much better.
20:23:02 <shachaf> Cale: Yes, but
20:23:24 <shachaf> 19:27 <tac> What is the proper way to catch an IO exception in Haskell?
20:23:26 <shachaf> 19:28 <applicative> @type catch
20:23:26 <shachaf> 19:28 <lambdabot> IO a -> (IOError -> IO a) -> IO a
20:24:02 <Cale> yeah
20:24:47 <shachaf> lambdabot's main goal is to be pedagogical
20:25:04 <shachaf> Hence the trouble with (.) = fmap, not that talking about that will change anything.
20:25:17 <monochrom> I thought lambdabot's main goal was special interest groups
20:25:24 <shachaf> Perhaps.
20:25:38 <monochrom> I mean, it has been my observation
20:26:12 <shachaf> monochrom: Hmm, Dijkstra's handwriting is nice.
20:26:16 <roadfish> ok, from ghc-pkg list, I see I have global mtl-2.0.1.0 and local mtl-2.1.2. I did an Ubuntu install of haskell-platform early on but have recently switched entirely exclusively using cabal install.
20:26:50 <monochrom> 2.0.1.0 sounds old
20:27:29 <roadfish> I'm thinking of doing an apt-get remove of the global mtl.
20:28:37 <monochrom> then again, cabal-dev still asks for it
20:29:23 <monochrom> (and skip the github rhetoric, I have heard that one already)
20:30:32 <roadfish> is this an instance of something called Cabal Hell ... Haskell DLL Hell?
20:30:39 <monochrom> yes
20:31:11 <monochrom> and it is worse than windows dll hell, because half of it is user self-inflicted, not author-inflicted
20:31:48 <johnw> roadfish: I'd reset your global .cabal
20:31:58 <johnw> rm -rf ~/.ghc ~/.cabal/lib ; cabal install -j world
20:32:07 <monochrom> that is not global
20:32:13 <johnw> making sure the haskell platform is nowhere to be found
20:32:21 <johnw> well, sorry, I meant user-global
20:32:24 <johnw> as opposed to cabal-dev
20:33:04 <monochrom> but the haskell platform in question is in global here. the /usr/lib kind of global. the apt-get kind of global
20:33:24 <roadfish> I see that apt-get remove wants to pull out 22 libghc-...-dev/prof packages
20:33:25 <johnw> is there any way to tell ghc/cabal to completely ignore ti?
20:33:49 <monochrom> no, because base is in global
20:35:10 <roadfish> Haskell Platform is promoted as a "batteries included" setup. But it seems these are like alkaline batteries and cabal is a NiMH charger.
20:35:57 <erineh_> lol
20:36:18 <monochrom> I wouldn't say that. I use the Haskell Platform too. and I cabal-install things *not* *already* *in* the Haskell Platform
20:36:19 <erineh_> i avoid haskell platform
20:36:33 <erineh_> on my platforms
20:36:54 <monochrom> what you have now is not making up your mind
20:37:13 <johnw> haskell platform seems to get in my way too much
20:37:28 <roadfish> I'm still inching out of newbie state. And in newbie state, the batteries included sounds good.
20:37:34 <johnw> but then, so does cabal itself, so maybe I'm the wrong person to ask
20:37:51 <monochrom> if you go with Haskell Platform, you do not allow a second transformer or a second parsec or... to exist. that is making up your mind one way.
20:38:07 <shachaf> i love the haskell platform
20:38:09 <shachaf> it is so easy
20:38:18 <johnw> do you have a macro for that, shachaf?
20:38:31 <johnw> a macro would make it even easier!
20:38:36 <shachaf> i love macros
20:38:36 <monochrom> if you ditch Haskell Platform, you do not allow it to exist, you remove it. that is making up your mind another way.
20:38:54 <roadfish> so apt-get remove haskell-platform might be a good idea.
20:39:18 <johnw> if you can even consider that it might be a good idea, I think it is a good idea
20:40:37 <roadfish> I wonder how much of this so-called hell is just global/user conflicts
20:41:00 <monochrom> there is user/user conflicts
20:43:01 <monochrom> you can and will easily have 3 versions of network, even if you only ever do "cabal install" to --user
20:43:55 <roadfish> what is that ghc flag that selects a package version?
20:44:28 <roadfish> ghc has so many flags. flag doesn't seem to be associated with "version"
20:44:37 <monochrom> -package network-2.0.1
20:45:20 <roadfish> ok, is in the PACKAGES section on the man page.
20:45:33 <roadfish> thanks ... and thanks to everyone for the heads up
20:45:47 <monochrom> when cabal calls ghc, it uses -hide-all-packages -package base-4.0 -package array-2.0 etc. actually -package-id
20:46:20 <roadfish> this sounds like a wise flag:
20:46:23 <roadfish>        -distrust-all   .... Distrust all packages by default
20:46:42 <monochrom> haha. but it is about Safe Haskell. completely unrelated
20:49:34 <monochrom> if you say "cabal install --constraint='bytestring install'", you will not get yet another copy of bytestring. similarly other packages
20:49:53 <monochrom> err, cabal install --constraint='bytestring installed'
20:50:12 <monochrom> you can also add an equivalent thing in your ~/.cabal/config
20:50:51 <roadfish> ok, "ghci -package mtl-2.0.1.0 diapang.hs" is doing the job. I guess juggling these package flags can get to be a hassle, but for now I see it as a lazy-newbie approach to sandboxing.
20:51:19 <hpaste> “Anonymous Coward” pasted “mapRM” at http://hpaste.org/80847
20:51:27 <roadfish> I have definitely learned a wack more about the plumbing of Haskell today.
20:51:49 <monochrom> you know what is really lazy sandboxing? check out -package-conf
20:52:21 <hpaste> “Anonymous Coward” annotated “mapRM” with “mapRM” at http://hpaste.org/80847#a80848
20:52:57 <roadfish> ok, haskell-platform and -package-conf ... I will extend out my lazy newbie state a bit longer now.
20:53:00 <erineh_> plumbing haha, is that like "moving parts" ;)
20:53:12 <overminder> Question.  I noticed that there is no right-to-left version of mapM in Data.Traversable so I implemented one at http://hpaste.org/80848. Does anyone think that would be useful?
20:53:41 <shachaf> On August 3, 2004 at time 23:50 EST, monochrom was wearing glasses.
20:54:00 <monochrom> yes, I believe so
20:54:20 <monochrom> can you mutate that state? :)
20:54:55 <shachaf> monochrom: A few minutes ago, it was the case that on August 3, 2004 at time 23:50, monochrom was not wearing glasses.
20:55:18 <monochrom> haha
20:56:22 <Nereid> uh so
20:56:44 <Nereid> how come Network.Socket.ByteString.Lazy.send doesn't exist on win32?
21:20:41 <shachaf> s
21:20:52 <shachaf> Ahem.
21:21:59 <geekosaur> k
21:22:37 <monochrom> μ
21:31:30 <lispy> ?remember roadfish Haskell Platform is promoted as a "batteries included" setup. But it seems these are like alkaline batteries and cabal is a NiMH charger.
21:31:30 <lambdabot> Good to know.
21:32:36 <lispy> for me the most useful thing in the HP is the ghc installer
21:32:39 <shachaf> Lead-acid batteries included.
21:32:42 <lispy> (Mainly on windows)
22:23:58 <nickkick> hahaha
22:24:00 <nickkick> hahaah
22:24:01 <nickkick> haha
22:24:02 <nickkick> haah
22:24:03 <nickkick> ahaha
22:24:04 <nickkick> ajhaha
22:24:05 <nickkick> a
22:24:07 <nickkick> afjgio hjrg
22:24:08 <nickkick> afaj;lkgjae
22:24:09 <nickkick> afdsfkj;a ljera
22:24:10 <nickkick> adsfjalksg
22:24:11 <nickkick> er gfad
22:24:11 <nickkick> g
22:24:11 <nickkick> ag
22:24:11 <nickkick> as
22:24:11 <nickkick> ga
22:24:11 <nickkick> dsga
22:24:12 <nickkick> dfg
22:24:12 <nickkick> ag
22:24:12 <nickkick> aew
22:24:13 <nickkick> rgt h
22:26:30 <xenocons> this is obviously a professional attack on #haskell
22:29:20 --- mode: ChanServ set +o edwardk
22:46:52 * hackagebot gitlib 0.6.4 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.6.4 (JohnWiegley)
22:52:57 --- mode: ChanServ set +o johnw
23:40:43 <hpaste> ierton pasted “breakpoint monad” at http://hpaste.org/80851
23:44:04 <hpaste> ierton pasted “BP example” at http://hpaste.org/80852
