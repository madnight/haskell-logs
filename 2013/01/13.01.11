00:02:32 <shachaf> SamanthaD: I'm not sure what PatrickRobotham was getting at (he's gone anyway), but maybe it was along the lines of constructive one big infinite list of primes, and then filtering against that.
00:02:48 <b__train> arrays are nice for sieves
00:03:53 <b__train> For sieving*
00:03:56 * applicative contemplates gutenberg-fibonacci-extras 
00:03:58 <shachaf> I.e. you have some infinite list primes = [2,3,5,7,...; then you can filter that list with a predicate. That predicate sees some number n, and checks numbers up to (sqrt n) from the very same list that you're building.
00:04:18 <shachaf> (Not that this is necessarily the best approach.)
00:05:12 <SamanthaD> shachaf: I kinda see what you're getting at. Sorta... I'm starting to feel the effects of exhaustion though!
00:24:55 <Ziarkaen> What's the terminology for makign functions using parentheses? e.g. (+1)
00:25:09 <croikle> section
00:26:05 <Ziarkaen> croikle, Thanks.
00:36:56 <covi> What is a 'token' in Parsec?
00:43:58 <applicative> covi: you mean in the sense of what is 'unconsed' from a stream, when you make a Stream instance?
00:46:16 <covi> applicative: Maybe I should look at what a Stream is in Parsec.
00:46:30 <covi> applicative: an abstraction over i/o ports?
00:46:37 <applicative> covi: or in the sense of makeTokenParser .  There are two notions in the library really .
00:46:58 <covi> I need an abstraction over i/o ports.
00:47:29 <covi> e.g. support sth like "port.nextToken()" (imperative syntax here)
00:50:25 <applicative> covi I see but what is nextToken doing there?
00:51:31 <covi> wait, never mind, it looks like ParsecToken can implement what I want
01:06:29 <frerich> A while ago I watched a screen cast of somebody writing a basic OCR application in Haskell. What I really liked was that he started with the topmost function (something like 'readImage :: Picture -> String') and then set 'readImage = undefined', compile. He then added lower-level functions, all being undefined as well, and implemented the higher-level functions in terms of that. Does anybody know whether this
01:06:29 <frerich>  style programming by composing function signatures all the time and using 'undefined' a lot has a common name?
01:07:03 <frerich> I was just reminded by it after reading about http://skillsmatter.com/course/haskell/well-typed-fast-track-to-haskell/wt-4939, (a training given by Anders Loeh) where he says that on day 1 they will be doing "type-directed program development; i.e. how to start from the type signature and systematically come up with a structurally recursive function definition"
01:07:28 <frerich> But it seems that 'type-directed program development' is not what the screencast I saw was doing, at least I don't get any such Google hits for those key words.
01:08:51 <snowylike> it sounds a bit like top-down development
01:10:09 <frerich> Right, but I was amazed how well it works in Haskell because of the strong type system, i.e. he would have a lot of utility functions being 'undefined' and yet he was able to use them just because of the type signatures. So he was able to type check at any point, very early on.
01:11:05 <snowylike> i don't think there's a specific name for that, it's just a peculiar thing you get with the type system combined with top-down development
01:12:59 <dropster> what is the preferred editor for Haskell ?
01:13:19 <dropster> im learning and are using notepad++ but maybe there is a better editor ?
01:13:34 <johnw> Emacs, of course!! ;-)
01:13:40 <merijn> dropster: Most people just use whatever editor they're already familiar with
01:14:00 <merijn> dropster: Lots of vim and emacs fans, but what I know of Notepad++ it should be just fine
01:14:02 <frerich> dropster: I believe a large number of Haskell develoeprs use either emacs or vim
01:14:05 <johnw> there is no "community-preferred editor"
01:14:24 <alec> i like vim because i find it easy to customize
01:14:28 <merijn> dropster: As long as you get syntax highlighting + auto-indent you're golden
01:14:32 <alec> i tried emacs for about 1 1/2 years
01:14:40 <merijn> alec: Clearly you've never tried to write your own vimscript code...
01:14:53 <alec> true, merijn, i just use others' plugins
01:15:02 <alec> but i have written some lines in my .vimrc
01:15:11 <alec> binding the F keys to different things
01:15:14 <alec> that was nice and easy
01:15:20 <merijn> I like vim as much as anyone, but it's scripting interface sucks balls
01:15:22 <beaky> why does template haskell take so long to compile? :(
01:15:32 <alec> i wouldn't know how to do that in emacs; but anyway, i agree, it's all about auto-indent and syntax highlighting
01:15:44 <merijn> alec: off-topic: Do you know CommandT? If not, you should look it up, it'll make your life so much better
01:15:54 <alec> i don't, but i will, merijn
01:16:30 <merijn> alec: https://wincent.com/products/command-t vim file opening for lazy people, best explanation is to just watch the demo video
01:16:35 <alec> nice
01:16:37 <frerich> merijn, alec: command-t has been superseded months ago, and its dependency on Ruby (and C) is very annoying. Try http://kien.github.com/ctrlp.vim/ instead
01:16:46 <bxc> and there i was thinking it was a monad transformer
01:16:51 <johnw> me too
01:16:53 <johnw> even googled fofr it
01:17:01 <johnw> i'm always looking for new monad transformers ;)
01:17:40 <merijn> frerich: Oh, what's the benefit of switching?
01:18:47 <frerich> merijn: CtrlP has no Ruby/C dependecy, so it's more portable (good if you use your same vim setup on multiple computers). It also has more features like: it can locate ther oot of your project automagically so no matter where you are, CtrlP always starts searching at the root of your tree.
01:19:11 <frerich> merijn: It also can open multiple matching files at once, it has session management (i.e. it can store the collected list of files across sessions) and it supports vim's regexps.
01:19:20 <johnw> #vim guys, please
01:19:37 <frerich> Right, I'll shut up.
01:21:35 <merijn> frerich: I remember reading it was significantly slower, though (due to no C), and my directory trees are sometimes very huge, so a speed decline would be very noticeable
01:22:22 <frerich> merijn: FUD
01:36:28 * hackagebot concraft 0.3.1 - Morphosyntactic tagging tool based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.3.1 (JakubWaszczuk)
01:56:41 <Bacta> FUCK!!!
01:58:52 --- mode: ChanServ set +o johnw
01:59:03 --- kick: Bacta was kicked by johnw (Inappropriate language)
01:59:07 --- mode: johnw set -o johnw
01:59:28 <merijn> Wait? Swearing is not allowed in #haskell? I must have been very lucky to not get kicked so far :>
01:59:39 <johnw> at least be artful about it
01:59:45 <snowylike> maybe it's not inappropriate in all contexts?
02:00:00 <Hafydd> I think the problem is more with just being obnoxious.
02:00:03 <johnw> if it's offensive, then it makes the channel look bad to newcomers
02:02:00 <kvda> it's annoying that HP is stuck with GHC 7.4 until May or whatever, if you're running OSX
02:02:32 <alpounet> kvda, you can install 7.6.1 just next to latest HP's GHC
02:03:11 <kvda> that will invalidate HP though, the HP installed libs won't work
02:03:13 <alpounet> just use --with-ghc and --with-hc-pkg flags with cabal-install for the one that won't be selected first in your PATH
02:03:15 <johnw> kvda: I use 7.4.2 for work, and 7.6.1 regularly for personal stuff
02:03:25 <merijn> kvda: Installing 7.6 on OSX is fairly easy, I have both running in parallel
02:03:31 <johnw> ah, HP is a bit of a pain
02:03:41 <kvda> hmm
02:03:48 <dropster> thx
02:03:49 <frerich> johnw: Hey, I only now realized your name is John Wiegley - are you the emacs & boost John, or is that somebody else?
02:03:51 <merijn> kvda: Just keep both installs? That way HP keeps working with 7.4 and you can use 7.6 for the stuff that needs it
02:03:54 <alpounet> kvda, they won't work with 7.6.1, you'll have to build other ones, but I tend to rebuild stuffs a lot since i'm using cabal-dev so that my user package db doesn't get messed up
02:04:02 <alpounet> merijn, yeah i'm doing the very same
02:04:03 <johnw> frerich: yep, that's me
02:04:23 <alpounet> boost, as in the C++ libraries?
02:04:26 <kvda> merijn, alpounet, right... i'll try that
02:04:33 <johnw> alpounet: yes
02:04:33 <frerich> johnw: Ah, I guess then I shouldn't have been surprised you would advocate emacs in public ;-)
02:04:42 <merijn> kvda: The install directories for both don't overlap, so they don't clobber each other's libraries. I just installed HP and then did a binary install of GHC 7.6 into ~/ghc
02:04:43 <alpounet> we probably have crossed paths a few years back then :)
02:05:10 <merijn> kvda: Now I can switch to 7.6 by just making sure "~/ghc/bin" is in my path first, which makes it use 7.6 + associated cabal and things
02:05:12 <kvda> how do i get the list of libs that come with HP though? I want the same libs with GHC 7.6 for Yesod
02:05:33 <wuttf> Are there any graphs about Haskell adoption rate, or about data which is an indicator of that?
02:05:37 <merijn> kvda: ghc-pkg list
02:06:04 <alpounet> kvda, cabal-installing yesod (or cabal-dev installing it) will take care of that, as long as you specifically say that it must be built with your 7.6.1 install
02:06:24 <alpounet> (using --with-ghc and --with-hc-pkg)
02:06:37 <johnw> alpounet: you and I might have crossed paths?
02:06:38 <merijn> wuttf: There's some website that track popularity (forgot the name), and there's also stuff like #code2012 http://www.code2012.com/
02:07:06 <wuttf> merijn: TIOBE, github, stackoverflow, I know them but I want something which shows it over time.
02:07:08 <alpounet> johnw, i hanged around a lot on the mailing list and the irc channel back then, and made a few contributions (was mostly phoenix related though)
02:07:44 <kvda> ok thanks guys, it's good to know that it's possible. is there any references to this online? It's rather late right now I'll have to try it another day
02:07:58 <alpounet> wuttf, I think Simon Peyton Jones has shown some figures about this in one of his talks this year
02:08:06 <merijn> I actually liked this bubble chart better: http://www.ioncannon.net/projects/code2012/
02:08:15 <alpounet> Haskell exchange I think
02:08:35 <johnw> i think Haskell is starting to really pick up, we're starting to achieve a critical mass with the quality of many of the essential libraries
02:08:43 <merijn> kvda: It's fairly simple, just follow the README (or INSTALL) in the GHC 7.6 binary package for OSX and make sure you run "./configure" with --prefix=path/to/install
02:08:51 <osfameron> johnw: though not with the documentation of those libraries ;-)
02:09:00 <merijn> kvda: Then make sure path/to/install is in your path before the 7.4 GHC to use 7.6
02:09:22 <frerich> johnw: Right except that for every given problem you have three packages on Hackage and usually only one of them is recommendable (but you never know which) :)
02:09:27 <kvda> right ok thank you, will definitely try this.
02:09:37 <wuttf> johnw: Yes, that's exactly what I am thinking about. I am a newcomer though, so I can't really compare.
02:09:42 <kvda> thanks again alpounet & merijn, very helpful. :)
02:09:45 <kvda> good night all
02:11:08 <wuttf> frerich: Some kind of rating, review system would solve this, or starring like on github, or simply displaying the time of the last update.
02:11:22 <alpounet> wuttf, I think it's in this talk: http://skillsmatter.com/podcast/scala/front-end-language-features
02:11:32 <wuttf> alpounet: Thank you.
02:11:35 <Lethalman> I've got a source code with Setup.hs (haskell-gi), how does one make it usually?
02:11:46 <alpounet> frerich, Hackage2 has some solutions for this
02:11:55 <alpounet> well, planned solution, not already written ones
02:12:51 <Lethalman> mh think I found it
02:13:56 <wuttf> Anyway the adoption increase can be mostly attributed to the end of the "PHP for web, C++ for almost everything else" age. There is an observable diversification of used programming languages.
02:14:01 <wuttf> (In the mainstream)
02:14:54 <alpounet> wuttf, that + the two recent Haskell books (i'm not even talking about the Yesod one, just RWH and LYAH) + the noise Yesod is making outside the Haskell community
02:15:34 * osfameron wonders if the autogeneration of "documentation" with haddock is one of the reason hackage's documentation sucks so much (in general)
02:15:59 <wuttf> alpounet: Probably, yes, good learning material is crucial
02:17:19 <yogsototh> Could some help me with this. I make an "import Hashable" and when I try to instanciate it with "instance Hashable X where hash X = myhash" I get a hash is not a (visible) method of class 'Hashable'.
02:17:39 <yogsototh> I believed the import should be enough.
02:18:39 <quicksilver> yogsototh: there is nothing wrong with your import
02:18:44 <quicksilver> but, hash is not a method of class Hashable
02:19:20 <quicksilver> http://hackage.haskell.org/packages/archive/hashable/1.2.0.4/doc/html/Data-Hashable.html
02:21:07 <yogsototh> quicksilver: Thanks, I read the doc for version 1.2.0.2, I didn't thought it will change the name. Thank a lot. I won't make this error again (hopefully).
02:21:19 <frerich> alpounet: Ah, I didn't realize that hackage2 is already available for testing (at least I suppose that's what new-hackage.haskell.org is);do you know whether there's a list of implementated improvements over the old hackage somewhere?
02:21:32 <yogsototh> quicksilver: it was 1.0.0.2, sorry.
02:21:40 <quicksilver> ah :)
02:21:47 <quicksilver> easy to do :)
02:22:08 <djcoin> merijn : where did ocaml go
02:22:40 <djcoin> on the code2012 stuff, it seems the name is stripped (ocam, in the chart, it is supposed to have 44 users but is not listed in the main page)
02:22:48 <djcoin> T_T
02:22:52 <alpounet> frerich, i don't think there are much of them already implemented. they're writing a nicely engineered hackage that will lend itself very well to writing a bunch of "plugins", like, i don't know, rating systems and whatever idea one can have.
02:23:27 <alpounet> frerich, of course, Duncan and the other people working on it already have a few ideas about the kind of stuffs that hackage 2 could have, but some stuffs must be done before people can start poking at these plugins
02:23:50 <alpounet> frerich, read the section about Hackage here: http://alpmestan.com/posts/2012-11-02-cabal-hackage-what-you-can-do-about-it.html
02:25:54 <gienah> wuttf: prog lang rankings: http://redmonk.com/sogrady/2012/09/12/language-rankings-9-12/
02:26:53 <wuttf> gienah: Thank you.
02:27:54 <wuttf> I wonder how the authors of Haskell feel about their language getting popular.
02:28:16 <gienah> wuttf: trying to "avoid success at all costs"
02:28:36 <wuttf> gienah: Is that important? :D
02:28:45 <wuttf> I thought it's a joke.
02:28:58 <merijn> wuttf: Naah, Simon explain the the bracketing is normally read wrong
02:29:16 <merijn> It "avoid (success at all costs)" not "(avoid success) at all costs"
02:29:35 <merijn> wuttf: SPJ actually talks about it in one of his presentations on typeclasses
02:29:35 <gienah> wuttf: latest strategy is to add more dependent types stuff to haskell, changing the language extensions to make it more powerful :-)
02:30:41 <wuttf> merijn: Haha =) Makes more sense.
02:31:29 <wuttf> I find it cool that most dependently typed languaes are based on haskell and/or implemented in Haskell
02:31:50 <merijn> Coq is neither
02:32:10 <wuttf> :-D Nitpick moar.
02:32:18 <merijn> (Coq's syntax therefore also sucks :p)
02:33:51 <wuttf> Well, the naming itself can tell you they don't really care about prettiness. It would make any marketing guy freak out.
02:34:39 <simpson> wuttf: To the French-speaking authors, it is not that big of a deal.
02:34:40 <merijn> wuttf: Hah, you wanna know what's a terrible language name (from a marketing perspective)?
02:34:55 <merijn> F*
02:34:59 <merijn> Try finding a hit for that :p
02:35:36 <wuttf> simon I may be childish, I find it amusing, and it makes me giggle
02:35:50 <wuttf> merijn: F*? Is that a language?
02:35:53 <merijn> Yeah
02:35:54 <merijn> https://research.microsoft.com/en-us/projects/fstar/
02:36:07 <merijn> A theoretically rather interesting one too
02:36:23 <wuttf> FStar is nice
02:36:58 <wuttf> Thank God they make TV adverts about programming languages... "Use Coq, it will make you happy."
02:37:03 <wuttf> dont make*
02:37:27 <wuttf> FStar sounds badass at least.
02:37:38 <Bacta> FUCK
02:37:42 <Bacta> MY
02:37:48 <Bacta> LIVERRR
02:38:06 <wuttf> ? :D
02:38:26 <Bacta> ASS IN MY EARRS
02:38:28 <Bacta> ASS!
02:38:30 <Bacta> ASS!
02:39:00 <wuttf> johnw: Another candidate.
02:39:21 --- mode: ChanServ set +o johnw
02:39:27 --- kick: Bacta was kicked by johnw (Kicked by johnw)
02:39:32 <johnw> sorry, I was in another channel
02:39:44 <hpaste> Lethalman pasted “cabal install language-c error” at http://hpaste.org/80580
02:40:13 <Lethalman> mh no
02:40:14 --- mode: johnw set +b *!*@202-180-112-138.callplus.net.nz
02:40:15 <Lethalman> no errors now -.-'
02:40:16 <wuttf> If he has tourette syndrome, you will be sued, johnw
02:40:29 <johnw> I actually have tourette syndrome, wuttf
02:40:38 <johnw> Bacta is banned now
02:40:40 <Lethalman> so
02:40:45 <Lethalman> I've installed language-c 0.4.2
02:40:56 <Lethalman> but c2hs installs 0.3.2 which fails
02:40:59 <Lethalman> and haskell-gi requires c2hs
02:41:05 <Lethalman> but can I do about it? bump the haskell-gi requirement?
02:41:11 <johnw> Lethalman: i'd download the c2hs tarball and edit the dependencies
02:41:18 <gienah> Lethalman: there was a patch to c2hs submitted upstream a while ago
02:41:29 <wuttf> johnw: Excuse me in this case.
02:41:31 <Lethalman> what's wrong with c2hs?
02:41:36 <Lethalman> why isn't it updated?
02:41:54 <johnw> wuttf: copralalia only affects 3% of TS sufferers
02:42:03 <johnw> even a very large conference of them, there was only one girl who had it
02:42:07 <gienah> Lethalman: I don't know, the patch seems to work
02:42:28 * Lethalman doesn't know why haskell-gi requires c2hs though
02:42:54 <wuttf> johnw: I see, I was brainwashed by south park it seems.
02:43:10 <gienah> Lethalman: there are c2hs patches here: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/c2hs/files
02:43:13 <merijn> tbf, the South Park episode on Tourette's was pretty freaking hilarious
02:43:19 <Lethalman> gienah, thanks
02:43:31 <Lethalman> gienah, I get the tarball with cabal download?
02:44:04 <merijn> Lethalman: "cabal unpack" grabs and extracts it
02:44:05 <gienah> Lethalman: yeah, then I guess cabal unpack it and apply the 2 patches listed here: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/c2hs/c2hs-0.16.4.ebuild
02:44:06 <johnw> wuttf: the media just loves what is shocking; the same way they portray Israel as a war-torn desert, when it fact its one of the most beautiful countries
02:44:11 <Lethalman> err unpack yes
02:44:35 <wuttf> johnw: Are you from Israel?
02:44:44 <johnw> no, but I've been there a couple times
02:44:54 <johnw> and my co-worker lives there
02:45:07 <merijn> johnw, wuttf: Actually, as far as I remember most of the Tourette's examples in South Park where twitches and similar non-verbal behaviours
02:45:12 <merijn> s/where/were
02:45:20 <merijn> But I might be drifting slightly off-topic here :)
02:45:28 <srhb> There's really a lot of off-topic going on in here these days.
02:45:35 <srhb> Please check out #haskell-blah
02:45:48 <johnw> i'll head over there
02:45:57 <merijn> srhb: It depends a lot on the time, #haskell seems really quiet (and therefore prone to topic drift) in the morning
02:46:03 <wuttf> johnw: I've encountered an advert which is supposed to be from Israel and what I find quite strange. Would be good to ask something from Israel to verify if it's fake or not.
02:46:08 <srhb> merijn: Right. :)
02:46:21 <johnw> wuttf: ask on -blah
02:47:11 <wuttf> johnw: Ty.
02:48:07 <Lethalman> gienah, will runghc Setup.hs install under .cabal/bin like other packages?
02:48:16 <Lethalman> I've configured with --ghc --user
02:48:25 <arbn> Does anyone know of a good article comparing/surveying Haskell persistence libraries?
02:48:53 <merijn> arbn: Not really, what kind of persistence are you looking for?
02:49:16 <merijn> arbn: External database or do you just need to save data in case of crash/power outage/whatever
02:49:50 <Lethalman> gienah, ok it does :-) fine
02:49:57 <merijn> Because in the latter case acid-state is pretty neat
02:49:59 <ippo> hi, I have a file containing a list of names. Every name is delimited by double quotes and a comma
02:50:25 <ippo> i'd like to read it as a list of strings, but the double quotes are giving me some problems using "read"
02:50:33 <ippo> a little help?
02:50:49 <Lethalman> c2hs: Prelude.read: no parse :'-( in runghc Setup.hs build of haskell-gi
02:50:52 * Lethalman contacts the author
02:51:20 <arbn> merijn: Well, because I need to deploy on various devices, including phones, I think I want to use sqlite. It also fits my needs well. I would prefer something a little higher-level than HDBC or sqlite-simple, though.
02:51:55 <arbn> merijn: The idea of writing lots of SQL inside a Haskell program isn't too appealing. :/
02:52:44 * Lethalman applies another c2hs patch :P
02:53:07 <johnw> arbn: you might want to check out 'persistent'
02:54:05 <srhb> ippo: Can you give an example?
02:54:14 <ippo> sure
02:54:33 <ippo> "anna","bob","charlie", ...
02:54:53 <arbn> johnw: Yeah. I was thinking about that, and I've used it before. The only trouble with persistent is... GHC-only extensions (rules out JHC, but I can probably cope with that), and lots of dependencies.
02:55:00 <fmap> > read . (\x -> "[" ++ x ++ "]") $ "\"annd\",\"bob\",\"charlie\"" :: [String]
02:55:02 <lambdabot>   ["annd","bob","charlie"]
02:55:06 <srhb> ippo: Sounds like one of the csv libraries might be very useful. You could also use wordsBy
02:55:21 <ippo> thanks, I'll look into it
02:55:26 <srhb> Wait, there's no such thing. Hmm.
02:55:33 <arbn> Is there anything like persistent that is a little lighter-weight and doesn't use TH?
02:56:01 <fmap> there is wordsBy in split
02:56:07 <ippo> or I'll just take the dumb route and roll my own "read" for this specific case
02:57:17 <fmap> > map read $ wordsBy (== ',') "\"anna\",\"bob\",\"charlie\"" :: [String]
02:57:19 <lambdabot>   ["anna","bob","charlie"]
02:57:40 <srhb> Oh, there is a wordsBy. I thought I was imagining things.
02:58:01 <srhb> @index wordsBy
02:58:01 <lambdabot> bzzt
02:58:15 <srhb> The index function is basically useless, isn't it.
02:58:19 <srhb> @hoogle wordsBy
02:58:19 <lambdabot> No results found
02:58:42 <fmap> Data.List.Split
02:59:12 <ippo> fmap, thanks a lot
02:59:21 <ippo> it really helped
03:00:07 <fmap> ippo: you welcome :)
03:02:01 <ippo> fmap: works like a charm :D
03:02:05 <ippo> bye bye
03:02:06 <srhb> why wordsBy is not in base is a mystery to me.
03:02:15 <srhb> Also you stole my five minutes of fame. :<
03:06:01 <Lethalman> how do I build only a specific executable with Setup.hs ?
03:15:06 <lzm> i'm having trouble running a compiled haskell program on debian6
03:15:19 <lzm> if i compile it normally it doesnt find libgmp.so.10
03:15:26 <lzm> if i compile it statically it hangs
03:15:48 <Lethalman> so nobody here using gtk3 I assume, what kind of gui are you using (if writing gui apps at all)?
03:23:04 <arbn> Lethalman: The only Haskell GUI program I've written used gtk2. Other than that... I tend to write the GUIs in other languages, and use Haskell to write the interesting stuff and provide it through a C library API.
03:23:40 <Lethalman> arbn, you use haskell to write c libraries?
03:24:09 <arbn> Lethalman: Well, technically they're Haskell libraries, aren't they? :P But, yes.
03:24:20 <Lethalman> arbn, yes, in that sense
03:24:28 <Lethalman> arbn, and you write the C interface by hand?
03:25:37 <arbn> Lethalman: I just use the FFI foreign C types. Sometimes I have to write my own wrappers.
03:25:40 <merijn> Lethalman: Haskel's FFI for exporting to C is pretty simple and easy to work with, with some of the auto-generating tools that generate wrappers to marshall custom datatypes it becomes fairly automatic
03:26:07 <arbn> I haven't used tools to generate wrappers yet. Maybe I should.
03:26:15 <arbn> What is the name of such a tool?
03:26:21 <merijn> c2hsc
03:26:28 <Lethalman> ah the FFI can be used to export too?
03:26:31 <merijn> And there are c2hs and hsc2c
03:26:36 <arbn> Lethalman: Yes. It's very easy.
03:26:37 <merijn> Lethalman: It goes both ways
03:26:42 <Lethalman> ah that's very nice
03:27:17 <arbn> Lethalman: So, it's not hard to use Haskell to write the backend to a GUI program that uses, say, C++, Objective-C, or whatever on the frontend.
03:28:03 <arbn> I've found it also helps me get the software architecture right. Strict separation between presentation and business logic, and all that.
03:29:52 <arbn> Although, the GUI situation in Haskell does need to be improved. :/ In general, I think most people are excited about in-browser stuff, so there's apathy about desktop GUI toolkits, and Haskell isn't easy to run on mobile platforms.
03:33:41 <covi> How can I see a list of functions exported by a module in ghci?
03:35:31 <fmap> :browse
03:53:16 <hiptobecubic> it always seemed weird to me how that works though. You are more running a haskell a program that calls some C functions than the  other way around no?
03:53:20 <hiptobecubic> Because of the RTS?
03:55:21 <marekw2143> hello, when we have function like :uncurry (^) . pair((2<), (<3)), then what why wyll we get back one argument functin?
03:55:34 <arbn> hiptobecubic: Not really. You start and stop the Haskell runtime from within the C program. So, it's like the C program keeps the RTS running, calls some functions as it needs them.
03:56:41 <quicksilver> I think it's like a C program and a Haskell program sharing a bed
03:56:48 <quicksilver> because the haskell RTS keeps threads running all the time
04:00:37 <marekw2143> what happens when we have function "f" taking two parameters, and will composite it with some other function "g" - then both first and second parameters of "f" will be results of "g"?
04:00:56 <elliott> No functions take two parameters.
04:01:05 <elliott> All functions take one parameter; (a -> b -> c) is just syntactic sugar for (a -> (b -> c)).
04:01:40 <elliott> ((f . g) x) is (f (g x)), so ((f . g) x y) is (f (g x) y).
04:01:54 <elliott> (Since (f x y) is just ((f x) y).)
04:02:59 <marekw2143> thanks :)
04:03:44 <bxc> though if you're pondering how it works, think about the uncurried form too...
04:04:07 <bxc> two parameters inside a pair, so that theres a single parameter that way
04:04:41 <marekw2143> well, I'm reading 'Introduction to functional programming using Haskell, 2nd edition"
04:05:04 <marekw2143> and there's example I've pasted: workday = uncurry (^) . pair ((Mon<=), (<=Fri))
04:05:44 <marekw2143> and (^) is defined like "Logical and", in curried form
04:06:11 <marekw2143> type of (^) is: Bool -> Bool -> Bool
04:06:26 <marekw2143> so when we'll apply uncurry we'll get: (Bool -> Bool) -> Bool  ?
04:06:35 <srhb> :t uncurry
04:06:36 <lambdabot> (a -> b -> c) -> (a, b) -> c
04:06:49 <srhb> So no.
04:07:08 <marekw2143> why no?
04:07:10 <srhb> :t uncurry (&&)
04:07:11 <lambdabot> (Bool, Bool) -> Bool
04:07:18 <srhb> Perhaps that is what you meant?
04:07:25 <bxc> because thats what currying/uncurrying *is*
04:07:59 <marekw2143> ok, so applying "Uncurry" for function of type: Bool -> Bool -> Bool will result in function of type: (Bool -> Bool) -> Bool
04:08:03 <srhb> No
04:08:08 <lzm> i cant compile cabal on a 512MB vps (out of memory when linking). any workaround for that?
04:08:12 <srhb> It results in (Bool, Bool) -> Bool
04:08:24 <marekw2143> sorry, true , you're right
04:08:56 <fmap> @ty uncurry `asAppliedTo` (undefined :: Bool -> Bool -> Bool)
04:08:57 <lambdabot> (Bool -> Bool -> Bool) -> (Bool, Bool) -> Bool
04:09:14 <hiptobecubic> wow
04:09:20 <hiptobecubic> @ty asAppliedTo
04:09:21 <lambdabot> (t -> b) -> t -> t -> b
04:09:59 <fmap> lzm: add swap space
04:10:07 <bxc> does that even need a definition to does it work just at the type level?
04:10:11 <bxc> (asAppliedTo)
04:10:19 <fmap> no
04:10:37 <elliott> asAppliedTo f _ = f
04:10:40 <Taneb> It's equal to const, I think
04:10:43 <fmap> well, `undefined' is enough
04:10:46 <hiptobecubic> lzm, i think some people have had luck switching to gold instead of ld
04:13:57 <Heather> Hello :P is there guru who can speed up haskell code?
04:14:39 <hpaste> “Heather Cynede” pasted “binary trees” at http://hpaste.org/80584
04:17:03 <merijn> Heather: I'm not very good at that, but have you profiled your code yet?
04:17:22 <Heather> merijn: profiled?
04:17:24 <merijn> Real World Haskell has a chapter on profiling and finding performance problems
04:17:29 <merijn> @where RWH
04:17:29 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
04:17:44 <merijn> Heather: Profiling analyses *where* your program is spending it's time
04:18:17 <Heather> hm
04:19:56 <lzm> hiptobecubic: gold-linked worked! thanks
04:20:08 <Lethalman> lzm, awesome good to know
04:20:18 * Lethalman might switch to gold as well
04:22:14 <timau> can someone help me with this syntax issues?
04:22:20 <hiptobecubic> lzm, sadly i had the same problem with a 2gb machine
04:22:28 <hiptobecubic> lzm, i hope you never need to use GL
04:22:29 <b__> merijn couldn't/didn't come to nl fp day I presume?
04:22:33 <rio> when trying to define an associative list, i tried "type AssocList k v = Eq k => [(k, v)]" and got an error about illegal polymorphic or qualified type. how is this done instead?
04:23:07 <bitonic> rio: you put the Eq constraint in each function operating on AssocList
04:23:44 <rio> ah!
04:23:54 <hpaste> timau pasted “can;t get this syntax right” at http://hpaste.org/80586
04:23:54 <hiptobecubic> rio, you usually don't want to put constraints on the data
04:24:01 <rio> i see
04:24:12 <merijn> b__: I could, but I already knew quite a bit of the things being discussed (or will get to hear about them soon) and Nijmegen is a bit far from Amsterdam
04:24:16 <hiptobecubic> rio, all that matters is that the data can do what the function expects of it
04:24:28 <merijn> b__: So I decided just going to work would be better and that I'd network some other day
04:24:40 <hiptobecubic> rio, and in fact, if it can do other things it wouldn't matter anyway because your program doesn't (and can't) care
04:24:42 <b__> ye are you coming cross functional?
04:25:05 <merijn> I was there last time, this I need to check. Tuesday is normal my martial arts practice night
04:25:14 <hiptobecubic> merijn, which one?
04:25:22 <b__> ah ok
04:25:22 <hiptobecubic> sorry, nevermind LUNCH TIME!
04:25:35 <hiptobecubic> gotta run
04:25:49 <merijn> b__: I might still be there, but I'm making that a last minute decision :p
04:26:02 <b__> a lot of talks from today are gonna be presented there too
04:26:24 <b__> giant queue for food
04:26:31 <b__> brought my own
04:26:37 <b__> win
04:26:50 <merijn> I'm assuming Jan's talk about Clash will be similar to the one he's giving at HiPEAC, so I can go to it there
04:27:15 <b__> yah probably
04:27:53 <b__> There's a lot less neat stuff about types etc in the talks
04:28:13 <hpaste> timau annotated “can;t get this syntax right” with “updated with errors” at http://hpaste.org/80586#a80588
04:28:59 <b__> im about the only attendant not at a university,  but no real theory yet
04:31:32 <E0000> > 0 ** 0
04:31:33 <lambdabot>   1.0
04:31:35 <E0000> o_O
04:31:49 <E0000> i thought that was nan
04:32:32 <merijn> Anything raised to 0 = 1
04:32:39 <hpaste> donri annotated “can;t get this syntax right” with “how about this” at http://hpaste.org/80586#a80589
04:32:43 <b__> NaN? As in not an instance of Num?
04:33:00 <E0000> > 0 / 0
04:33:01 <lambdabot>   NaN
04:33:12 <donri> timau: ^
04:33:19 <b__> rite
04:33:32 <Lethalman> > 0 % 0
04:33:33 <lambdabot>   Not in scope: `%'
04:33:33 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
04:33:40 <Lethalman> > 0 R.% 0
04:33:41 <E0000> > 0 ^^ 0
04:33:41 <lambdabot>   *Exception: Ratio.%: zero denominator
04:33:42 <lambdabot>   1.0
04:34:00 <timau> donri: thanks. so you used finally as infix function
04:34:22 <Taneb> > (0^0,0**0,0^^0)
04:34:24 <lambdabot>   (1,1.0,1.0)
04:34:25 <timau> kind of similar to my first try? how come it didnt work?
04:34:26 <donri> timau: it's how it's usually used
04:34:59 <merijn> timau: Putting parentheses around the do blocks should also have worked
04:35:06 <donri> timau: your first version assumes finally is a layout herald but it's an ordinary function
04:35:12 <merijn> timau: If you hadn't added the lambda's to it
04:35:21 <timau> ah ok
04:35:36 <E0000> "zero to the zero is one"
04:35:49 <E0000> all my maths classes down the drain xD
04:35:54 <lzm> some packages dont compile with gold-linker (it doesnt understand the --hash-size parameter)
04:35:59 <hpaste> merijn annotated “can;t get this syntax right” with “updated with errors (should work)” at http://hpaste.org/80586#a80590
04:36:03 <timau> this IO business is still like black magic to me
04:36:26 <Taneb> E0000: if you look at the graph of x^x and x^0, it makes sense
04:36:29 <johnw> timau: how so?
04:36:32 <donri> merijn: misaligned error there ;)
04:36:50 <E0000> Taneb: right.. but not x^y ;)
04:36:56 <merijn> donri: I edited in the browser and hpaste's style sheet is wrong (i.e. doesn't produce fixed width font in edit box)
04:37:13 <timau> johnw: I am struggling to get the simplest things work
04:37:15 <donri> ah. i have a user stylesheet to fix that on all sites
04:37:22 <Taneb> E0000: what's 0^-1?
04:37:29 <merijn> Speaking of which, who would I bug for that?
04:37:37 <donri> chrisdone
04:37:38 <E0000> Taneb: ERROR
04:37:42 <johnw> timau: do you want to show some code?
04:37:58 <Taneb> E0000: so 0^x is a silly graph anyway
04:38:17 <E0000> heh
04:38:35 <E0000> 'silly graph'
04:38:48 <merijn> timau: Have you tried writing IO code without do-notation? I am a firm believer that understanding the none-do notation helps grok the do-notation
04:38:53 <mauke> > x ^ 0
04:38:55 <lambdabot>   1
04:40:22 <covi> I am a little bit lost in Parsec. I am trying to build a parser for scheme. What confuses me is that, for instance, scheme's standard defines <self-evaluating> to be "number | character | string" (not exact), but I can't use Parsec to write "selfEval = number <|> character <|> string", because the arguments to <|> have to have the same type, which clearly is not the case here. What should I do (use) in such situation?
04:40:43 <hpaste> merijn annotated “can;t get this syntax right” with “updated with errors (look ma! No do-notation!)” at http://hpaste.org/80586#a80591
04:40:45 <E0000> Taneb: im writing a toy language, one of the operations is ^ and im trying to decide if 0^0 is an error or 1
04:40:54 <E0000> and i noticed haskell is 1
04:41:19 <Taneb> Depending who you ask, it's 0, 1, or error
04:41:20 <E0000> ill go with 1
04:41:21 <merijn> E0000: According to my math knowledge 0^0 = 1
04:41:31 <timau> johnw: I think I am struggling with very basics. earlier today I was wondering why putStrLn getLine doesnt work. turns out I have to do getLine >>= putStrLn, but I dont really get it why that works, or why I have to do that
04:41:32 <nicoo> merijn: Indeed
04:42:16 <E0000> timau: look at the types for those three things, getLine, >>=, and putStrLn
04:42:18 <merijn> E0000: Because x^0 is defined as 1 and x^n is defined as "x * (x^(n-1))", so x^0 is the base case
04:42:20 <johnw> timau: putStrLn wants a String, but getLine returns an "IO String".  The purpose of >>= is to get the String from the IO String return by getLine, and pass it to putStrLn as its argument
04:42:42 <mauke> s/returns/is/
04:42:52 <merijn> I dislike the explanation "get the String from"
04:42:52 <johnw> yes, thank you
04:42:53 <johnw> is
04:43:21 <mauke> "potentially get a String from, later"
04:43:39 <craigInnes> hi, im usingg gtk2hs right now and I am wondering if anyone knows if there is an equivalent to the "setUpdatePolicy" which range sliders have, but for text boxes?
04:43:41 <johnw> mauke: but when you're just starting, that does confuse matters
04:43:52 <mauke> johnw: I disagree
04:44:00 <johnw> mauke: because you already know how it works
04:44:03 <mauke> no
04:44:17 <elliott> @quote /bin/ls
04:44:17 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
04:44:30 <mauke> because I still remember when IO made sense to me
04:44:35 <merijn> timau: My preferred way of looking at it is this: "getLine :: IO String" is a "program fragment" that when run produces a String. "putStrLn" is a function that, given a String, returns a program fragment that prints that String when executed.
04:45:34 <merijn> timau: >>= is an operator that takes a program fragment that produces an a (i.e. something of type IO a) and a function that takes an "a" and returns a different program fragment and glues them together into a combined program fragment that does both things
04:45:58 <johnw> and the behavior of that will be that getLine returns a string that it passes to putStrLn :)
04:46:19 <merijn> johnw: I think the IO as programs is both clearer and more correct than saying that >>= gets things "out" of IO
04:46:22 <timau> that does make it clearer
04:46:37 <elliott> johnw: If you assemble (getLine >>= putStrLn), that gives you the same IO action that you can use multiple times to read and print entirely different strings.
04:46:57 <johnw> elliott: that's true in C's fputs(gets()) also
04:47:01 <elliott> The notion of a singular String inside is confusing and falls apart in a context where actions are first-class.
04:47:18 <merijn> timau: This also helps explain how Haskell is always pure. "getLine >>= putStrLn" always returns the exact same program fragment. *executing* the program fragment may produce different things due to side effects, but you can't execute them in haskell
04:47:36 <elliott> johnw: Not really. Imagine if you assigned that to a variable.
04:47:40 <merijn> timau: The only thing that can execute program fragments is the runtime system (which executes the "main" program fragment)
04:47:43 <elliott> C doesn't have a notion of first-class actions.
04:47:58 <johnw> elliott: yes, i don't believe in the containment metaphor much either
04:48:00 <mauke> johnw: fputs(gets()) gives you an int
04:48:02 <merijn> timau: So you just build your program by glueing smaller program fragment together into a single big main program fragment
04:49:29 <merijn> timau: The real interesting bit is that "program fragments" are first class, so you can pass them around like any other value (hence why you can give the "finally" function multiple "IO a" values to do something with). Hope that clears up some confusion :)
04:50:17 <merijn> :t repeat (putStrLn "whooo!")
04:50:19 <lambdabot> [IO ()]
04:50:44 <mauke> > let x = print 42 in length [x, x, x]
04:50:45 <lambdabot>   3
04:50:52 <merijn> :t let ioList = repeat (putStrLn "whooo!") in head ioList
04:50:53 <lambdabot> IO ()
04:50:57 <mauke> > let x = print 42 in x >> x >> x
04:50:58 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
04:50:58 <lambdabot>    arising from a use of ...
04:51:13 <johnw> timau: is any of this helping?
04:51:52 <merijn> johnw: He/she said it was at the start, but I dunno if I just overloaded his brain by explaining too much ;)
04:53:03 <timau> it did help, appreciate the expanations guys, you are a helpful bunch. :)
04:53:34 <johnw> i am still working to shed my C background
04:53:58 <johnw> i catch myself thinking in execution models, not value models
04:59:40 <zzKon> hello.i am on the 8th chapter of LYAH where the tree was implemented, and was wondering how come it isn't possible to specify Ord constraint in the type itself? so that we don't have to repeat it in functions that operate on the tree
05:00:19 <elliott> technically it is (I think the form with the constraint on the constructor might require an extension, but I forget), but it's generally not something you want to do
05:00:20 <johnw> I thought it discussed that somewhere...
05:00:47 <elliott> (Standardly, you can specify a constraint on the type, but you still have to repeat it in all your functions -- that version is useless and you should never use it.)
05:01:19 <E0000> zzKon: some of your functions may not depend on that constraint and would be more general
05:01:27 <zzKon> johnw it just said you usually don't want to specify the type constraint in type so that you don't have to repeat the constraint in all the the functions that operate on it instead of some
05:02:04 <merijn> elliott: datatype contexts are deprecated in Haskell2010
05:02:47 <merijn> zzKon: If you add the type constraint to your datatype *all* functions using that type demand the same constraint
05:02:53 <allsystemsarego> how can I wrap a derived "read" function such that it will return a Maybe?
05:03:13 <johnw> Just . read?
05:03:13 <merijn> allsystemsarego: New versions of GHC (7.6 and later?) have Text.Read.readMaybe
05:03:14 <zzKon> elliott yeah that is what i am wondering, is there any reason why it was done that way instead of functions inheriting type constraints from the type they accept as argument
05:03:21 <johnw> ah, I see
05:03:25 <merijn> allsystemsarego: Otherwise you'd want "reads" and wrap it manualy
05:03:28 <elliott> zzKon: it was done that way because even the haskell committee is fallible :)
05:03:33 <allsystemsarego> merijn, thanks, I''l look into that
05:03:43 <zzKon> elliott ok :)
05:03:46 <elliott> The standard version of constraints on the type is pretty much universally agreed to be a mistake, and I don't think anyone actually uses it except by accident.
05:04:06 <merijn> allsystemsarego: reads returns a list of tuples, you can pattern match on that and wrap it yourself. Googling should turn up some examples, I think
05:04:18 <merijn> elliott: Or by misunderstanding what it does
05:04:20 <elliott> zzKon: Repeating constraints in the function isn't so bad, though; you'll often find that not all your operations need the same constraints, so you can generalise them by omitting the constraints you don't need
05:08:39 <aavogt> allsystemsarego: there's a Text.Read.readMaybe in ghc >= 7.6
05:09:27 <merijn> aavogt: Beat you to it :p
05:09:46 <aavogt> missed that part
05:10:12 <merijn> On that note, I can't believe no one had the idea to export that function before 7.6...
05:10:22 <merijn> That seems like the single most obvious read function you'd want...
05:10:32 <johnw> got to agree with yout here
05:11:31 <alpounet> well, all the partial functions were first on the list, soooo...
05:12:36 <fmap> what's unfortunate is that readMaybe is in some obscure base module with such a long name
05:13:25 <quicksilver> Text.Read is obscure and has a long name?
05:13:34 <quicksilver> where else would you look for functions for reading text?
05:13:35 <zzKon> was about to say that :)
05:13:55 <quicksilver> merijn: what makes you think they didn't have the idea?
05:14:26 <fmap> I didn't know about Text.Read before someone mentioned readMaybe to me :[
05:15:34 <merijn> quicksilver: If they did, why didn't they do it?
05:15:53 <merijn> quicksilver: I didn't mean specifically from there. I think readMaybe should be in the Prelude instead of read...
05:15:59 <fmap> and I much rather prefer if `readMaybe' was `read' and `read' was `unsafeRead' or something
05:16:10 <merijn> fmap++
05:16:41 <quicksilver> merijn: people often think of things and then do them.
05:17:00 <allsystemsarego> fmap, but then read . show wouldn't be the identity function
05:17:03 <quicksilver> I'm pretty sure you can dig up mailing list posting in which people *think* of readMaybe going back many, many years
05:17:29 <E0000> heh read . show isnt the identity function
05:17:43 <allsystemsarego> oh
05:17:53 <quicksilver> but the people who think of it don't know where to submit paches, or how to get them approved, or what the liibrary change process is, or they can't be bothered, or they get diverted into bikeshedding
05:18:45 <merijn> > (read . show $ (1 :: Int)) :: Double
05:18:47 <lambdabot>   1.0
05:19:26 <E0000> polymorphic identity ;)
05:19:44 <E0000> :t read . show
05:19:45 <lambdabot> (Read b, Show a) => a -> b
05:20:29 <craigInnes> hi, im usingg gtk2hs right now and I am wondering if anyone knows if there is an equivalent to the "setUpdatePolicy" which range sliders have, but for text boxes?
05:21:38 <wuttf> Is there something like the id function but which prints a given value with unsafePerformIO (to aid debugging)
05:21:57 <srhb> Yes, trace
05:22:12 <wuttf> srhb: Ty.
05:22:13 <marekw2143> how to use "guards" inside "in" section of "let...in" expression?
05:22:18 <merijn> wuttf: You probably want to look at the entire Debug.Trace module
05:22:26 <Lethalman> wuttf, http://www.haskell.org/haskellwiki/Debugging
05:22:46 <srhb> marekw2143: case () of _ |
05:22:55 <marekw2143> srhb: thanks
05:22:58 <wuttf> merijn, Lethalman Simply printlining will suffice in my case.
05:23:06 <applicative> @quote oasis
05:23:06 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
05:23:23 <Lethalman> wuttf, that link references many methods, including trace
05:23:25 <srhb> That's a good quote :P
05:23:35 <merijn> srhb: Yeah, I like it too :)
05:23:41 <hiptobecubic> indeed
05:23:53 <hiptobecubic> Trace is the best
05:24:32 <lzm> how can i resolve the ambiguous declaration error in "E.catch (error "asd") (return . show)" ?
05:25:30 <aavogt> lzm: which exceptions do you want to catch?
05:25:49 <lzm> im throwing the exception with "error "some string""
05:25:56 <lzm> i just want to get that string back
05:26:00 <aavogt> you could get them all with:          E.catch (error "asd") (return . show . (`asTypeOf` (undefined :: SomeException))
05:26:09 <aavogt> )
05:26:12 <merijn> lzm: Explicitly annotate the type of the handler
05:26:42 <lzm> what is the type of the handler?
05:27:02 <merijn> lzm: It's too polymorphic, you could do "where handler :: SomeException -> IO String; handler = return . show" and then pass "handler" to catch
05:27:27 <leftover> hi
05:27:37 <merijn> lzm: If you want something less general than SomeException you should look at the different exception types and specify the one you want to catch instead
05:28:27 <leftover> I've a question about kinds
05:28:33 <lzm> oh i see. thanks
05:28:47 <srhb> leftover: Ask
05:29:16 <leftover> I'm using GHC 7.4.2, and when I do: :k Monad, I get (* -> *) -> Constraint, whereas when I do: :k Eq, I get: * -> Constraint.
05:29:23 <wuttf> 3 weeks ago when I started learning Haskell I had an aversion toward that the type signature differentiates between IO and pure bussiness, now I have an aversion toward other languages which do not. Is that normal?
05:29:46 <leftover> I looked at definitions of both, both require single parameter
05:30:11 <merijn> lzm: GHC decides which exceptions to catch based on the handler type, in your case your function can handle any exception type so it's ambiguous which it should pick. (ambiguous errors usually mean, provide more type info to help GHC decide what you meant)
05:30:32 <merijn> leftover: Correct
05:31:17 <merijn> leftover: The difference is in the type of the parameter they accept
05:31:24 <leftover> hmm
05:31:37 <merijn> leftover: Monad expects a single parameter that has type "* -> *", whereas Eq expects on that has type "*"
05:31:51 <leftover> oh, i see
05:32:07 <Lethalman> leftover, because of m a -> ...
05:32:09 <merijn> leftover: It's similar to the first argument to map being "a -> b" whereas the first argument of id is "a"
05:32:19 <leftover> so, GHC typesystem implicitly deduces it from the definition of functions Monad class supports
05:32:26 <leftover> s/supports/provides/
05:32:52 <merijn> leftover: Yeah, if you like there is an extension that lets you explicitly specify the signatures too, though
05:32:53 <zzKon> wuttf I experienced the same thing
05:33:07 <merijn> {-# LANGUAGE KindSignatures #-}, I think
05:33:31 <leftover> thanks merijn, Lethalman.
05:33:33 <merijn> wuttf: Yes! Before long you'll even write all your imperative stuff in Haskell!
05:33:52 <merijn> wuttf: Because doing 90% in IO in haskell is still nicer than doing it in many other languages :p
05:34:38 <wuttf> merijn: I can't decide if what I feel is revelation or irreversible brain damage.
05:34:47 <srhb> wuttf: Both.
05:34:56 <srhb> It's completely normal.
05:34:57 <wuttf> srhb: :-)
05:35:27 <merijn> @quote gloss
05:35:27 <lambdabot> cjeris says: Cale: I like how you conveniently gloss over the part where your head explodes.
05:35:50 <wuttf> :-DDDDDDDDD
05:37:08 <wuttf> I am only 3 weeks in the game but I already think that most of the criticism of Haskell stems from ignorance. First week I agreed with most of the blog posts saying
05:38:09 <wuttf> that monads suck and stuff
05:38:52 <merijn> wuttf: It's easier to complain and not learn anything than to change your way of thinking
05:39:02 <wuttf> But the more I understand them the less fuck I give about an occasional liftIO or something.
05:40:09 <johnank> I'm trying to install some haskell stuff on ubuntu 12.10, and finding problem after problem. is it generally known that packagers in ubuntu make it difficult? am i better off installing haskell-platform from source?
05:40:16 <wuttf> merijn: +1
05:41:12 <mgore> johnank: what problems are u talking about? i run ubuntu 12.10 too, maybe I can elp
05:41:45 <johnank> I can't find anyway to enable library profiling. I always get this error http://stackoverflow.com/questions/11711197/could-not-find-module-prelude-dyn-libraries-for-package-base
05:42:25 <johnw> johnank: you need to install the profiled base libraries
05:42:31 <johnw> i forget what they are called
05:43:05 <johnank> @johnw: you see, that's what I'm confused about - there seems to be a disconnect, with some libraries managed by cabal, and some by the package manager, and that's where the problems are
05:43:05 <lambdabot> Unknown command, try @list
05:43:40 <mgore> johnank: try installing ghc-prof package
05:44:20 <johnank> ah, there's also haskell-platform-prof - that might be where i want to start with
05:44:33 <mgore> yeah :)
05:44:41 <johnank> two package managers (i know cabal "isn't a package manager") never work well with each other
05:44:58 <johnank> all cabal knows is something is wrong, and it can't suggest that i use another program to install something else
05:45:06 <mgore> and in my experience, library management via cabal is preferable to using ubuntus repository
05:45:37 <applicative> johnank: yes I think you want haskell-platform-prof, else nothing that depends on it will build for profiling
05:45:58 <merijn> johnank: My solution is just "I only use cabal for installing haskell stuff beyond HP"
05:46:11 <mgore> +1
05:46:53 <johnank> merijn: here's where that breaks down - i write a generic app, not part of the haskell community, but just using haskell, then somehow that has to fit into the ubuntu package system
05:46:56 <applicative> johnank: you saw http://www.vex.net/~trebla/haskell/haskell-platform.xhtml by the way?
05:47:29 <johnank> applicative: yeah, thanks, i can install it from source, but i wanted to do it the ubuntu way if i could
05:47:51 <merijn> johnank: Distribute as binary ;)
05:48:46 <allsystemsarego> attempting to use "reads" leads to http://pastebin.com/raw.php?i=0UH85dE6 ideas?
05:48:48 <mauke> The paste 0UH85dE6 has been copied to http://hpaste.org/80592
05:48:50 <applicative> johnank: I was going to say what merijn did.
05:49:17 <applicative> johnank: I'm not sure how many apps do this for linux, darcs does I think.
05:49:44 <johnank> how does cabal cope if my haskell program needs an external command such as, i don't know, inkscape, to render svg to png or something? cabal can't install that dependency for you? and what if you're writing an application, that uses a haskell library, that depends on an inkscape binary, then you're responsbile for your libraries (or their libraries!) dependencies manually
05:50:00 <fmap> allsystemsarego: you need to specify what you want to read
05:50:33 <allsystemsarego> :t reads
05:50:34 <lambdabot> Read a => ReadS a
05:50:55 <fmap> It doesn't know what `Read a => a' you want
05:50:57 <merijn> johnank: cabal can check whether a program exists and report an error
05:51:08 <applicative> johnank: with an external command, it is no problem, it presupposes its existence.  With a library, there will be ugly breakdown in building, no?
05:51:31 <mgore> allsystemsarego: specifying type by appending ':: GameState' should do the trick
05:51:43 <allsystemsarego> ok, let me try that
05:52:13 <fmap> more like `ReadS GameState'
05:52:37 <mgore> yeah
05:53:04 <lzm> gridc-httpd: user error (RTS doesn't support multiple OS threads (use ghc -threaded when linking))
05:53:04 <fmap> wait, no
05:53:15 <lzm> i added -threaded to ghc-options in .cabal but the error continues
05:53:36 <fmap> `ReadS GameState' is `String -> [(GameState, String)]'
05:53:36 <allsystemsarego> mgore, nope, it says Couldn't match expected type `ReadS GameState' with actual type `[(a0, String)]'
05:54:04 <fmap> allsystemsarego: `:: [(GameState, String)]'
05:54:12 <allsystemsarego> ok, let me try it
05:54:22 <mgore> yeah, sorry, i misread 'reads' for 'read'.
05:55:01 <lzm> what is RTS?
05:55:11 <sipa> run time system
05:55:17 <allsystemsarego> that works :) thanks, now I'll try to figure out why, by myself
05:55:18 <applicative> lzm add -rtsopts
05:55:20 <applicative> ?
05:55:49 <applicative> lzm I take it you are using -RTS -Nx  ?
05:56:01 <lzm> i am using nothing
05:56:18 <applicative> lzm, also did you use cabal clean?
05:56:28 <lzm> i'll test that
05:58:10 <lzm> applicative: that did work, thanks!
05:58:24 <applicative> oh, excellent
06:12:42 <rio> [Type] is just syntactic sugar for [] Type, correct?
06:12:54 <shachaf> Correct.
06:13:31 <shachaf> (...Unless Type is a value.)
06:13:42 <rio> yeah, of course
06:13:57 <rio> then its syntactic sugar for k:[]
06:15:39 <lzm> i am unable to catch some exceptions with E.catch
06:15:48 <lzm> the error is passing right through
06:18:20 <lzm> the type of the handler is E.SomeException -> IO a though
06:19:06 <aavogt> > (catch $! (error "hi")) (print . show . (`asTypeOf` (undefined :: SomeException)))
06:19:07 <lambdabot>   Not in scope: type constructor or class `SomeException'
06:19:23 <aavogt> > (Control.Exception.catch $! (error "hi")) (print . show . (`asTypeOf` (undefined :: Control.Exception.SomeException)))
06:19:25 <lambdabot>   Not in scope: `Control.Exception.catch'Not in scope:
06:19:25 <lambdabot>    type constructor or...
06:19:40 <shachaf> aavogt: You're not going to make it work.
06:20:09 <lzm> can i only catch exceptions thrown in the same module or something?
06:20:10 <aavogt> shachaf: why can't lambdabot have exceptions?
06:20:53 <shachaf> aavogt: lambdabot doesn't do IO, and lambdabot doesn't do things that aren't imported.
06:21:01 <aavogt> one reason catch won't work is if you're forcing the value too early
06:21:11 <shachaf> lzm: What do you want people to say: Oh, that sounds like a familiar problem, do X?
06:21:15 <shachaf> @paste some code or something. :-)
06:21:15 <lambdabot> Haskell pastebin: http://hpaste.org/
06:21:15 <parcs> lzm: post code
06:21:36 <zzKon> lambda doesn't do IO for safety reasons?  isn't it running in a sandbox?
06:21:39 <zzKon> lambdabot
06:21:57 <shachaf> No sandbox as far I know, other than the "not running IO" thing.
06:22:06 <parcs> lzm: if i had to guess, you are probably getting hurt by excessive laziness
06:22:19 <quicksilver> well it's in a resource-limited process
06:22:21 <quicksilver> both time + memory
06:22:32 <shachaf> Well, yes.
06:22:39 <quicksilver> but it doesn't use any sophisticated sandbox approaches
06:22:44 <shachaf> Most code-evaluating bots let you do arbitrary IO, though.
06:22:53 <shachaf> (They have to.)
06:23:09 <shachaf> lambdabot's mechanism seems pretty suspicious to me.
06:23:09 <quicksilver> back when it was written, it seemed more elegant to rely on haskell's type system to make it safe
06:23:23 <quicksilver> these days it would make more sense to use something georgi-like
06:23:34 <shachaf> One problem is that GHC's type checker has bugs.
06:24:03 <shachaf> For example it's possible to write unsafeCoerce (and therefor unsafePerformIO) in the version of GHC that lambdabot is running.
06:24:18 <lzm> catcher: https://github.com/lessandro/gridc/blob/master/src/Httpd.hs#L108  thrower: https://github.com/lessandro/gridc/blob/master/src/GridC/Parser.hs#L20
06:25:13 <shachaf> lzm: Your exception is not being caught because it's not being thrown.
06:25:27 <parcs> use 'throw', not 'error'
06:25:42 <shachaf> @src error
06:25:42 <lambdabot> error s = throw (ErrorCall s)
06:25:58 <shachaf> That won't really make a differnce.
06:26:09 <parcs> oh
06:26:22 <shachaf> lzm: You have to cause your exception to be evaluated *within* the handler.
06:26:25 <parcs> in line 110 of Httpd.hs, use 'evaluate' not 'return'
06:26:36 <shachaf> Yes.
06:26:49 <shachaf> Of course, better yet: Don't use exceptions here.
06:26:52 <shachaf> Just return Either.
06:27:29 <lzm> i also throw things deep inside Codegen.hs
06:27:39 <lzm> using either would be painful
06:28:00 <shachaf> Possibly.
06:29:02 <lzm> E.evaluate works like a charm
06:29:05 <lzm> thank you all
06:32:39 <zzKon> does lambdabot have something similar to "eval" ?  or does it interface ghci?
06:34:03 <merijn> zzKon: It uses mueval
06:35:55 <applicative> lzm have you seen http://hackage.haskell.org/package/errors explained here http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
06:36:35 <zzKon> merijn, interesting. could that be used to allow users of my program to script certain things in haskell?
06:36:46 <applicative> lzm i've just been figuring it out lately it seems very well thought out.
06:36:48 <merijn> zzKon: Yes
06:36:53 <zzKon> nice
06:38:02 <Hugosthlm> Regarding my EclipseFP problem, see the comment here. EclipseFP now works nicely on my Ubuntu. Thanks for help! http://cnebula.blogspot.se/2012/07/hoogle-problem-in-eclipsefp-unexpected.html
06:38:44 <shachaf> preflex: seen johnw
06:38:44 <preflex>  johnw was last seen on #haskell 56 minutes and 13 seconds ago, saying: i forget what they are called
06:40:36 <decrement> so, how would one go about learning Haskell?
06:40:53 <bitonic> decrement: LYAH, ‘Programming in Haskell’, trying
06:40:53 <kennyd> @where LYAH
06:40:54 <lambdabot> http://www.learnyouahaskell.com/
06:41:24 <decrement> besides Real World Haskell, would any other book be a good followup to LYAH?
06:41:50 <bitonic> decrement: there aren’t many ‘Advanced Haskell’ books.  there are loads of interesting papers you can read
06:41:57 <rorywinston> is there a canonical example for a simple program that (a) does IO and (b) contains some sort of state, such as a simple game with a game loop? looking at different ways of handling this in haskell..
06:42:13 <merijn> decrement: The usual approach is a combination of blog posts, papers and wikibooks
06:42:32 <merijn> decrement: People here tend to have plenty of suggestions for those ;)
06:42:38 <bitonic> oh yes the Haskell wikibooks is good as well
06:42:54 <bitonic> the blog post quality is much less consistent :)
06:43:01 <merijn> rorywinston: Control.Lens has a Pong implementation in it's examples
06:43:16 <decrement> I'm just working myself through list comprehension and predicates
06:43:18 <merijn> rorywinston: Although the lens part of that might be confusing? :p
06:43:37 <bitonic> decrement: well then finish LYAH first
06:44:44 <magneticduck> not quite a haskell, question, but involves cabal and the SDL-ttf lib and linux in general
06:44:49 <magneticduck> hope I can ask here
06:44:58 <magneticduck> anyway, I'm trying to install SDL-ttf
06:45:04 <magneticduck> in my account here
06:45:21 <magneticduck> of course, it gives me an error that the library SDL_ttf isn't installed
06:45:26 <magneticduck> because I don't have it
06:45:28 <magneticduck> I installed it though
06:45:30 <magneticduck> with apt-get
06:45:31 <magneticduck> err
06:45:34 <magneticduck> one sec
06:45:55 <magneticduck> scratch this
06:45:58 <magneticduck> disregard my question
06:47:33 <mm_freak> rorywinston: there is an old demo that can load quake3 maps and allows you to walk through them and shoot around with your weapon:  frag
06:48:02 <mm_freak> it hasn't really evolved into a game, but the idea is:  see how it works and how it uses FRP, then take netwire and write a real game =)
06:49:15 <osfameron> netwire?
06:50:26 <merijn> mm_freak: Oh, is that demo on Hackage?
06:50:39 <merijn> osfameron: That's his FRP library :p
06:50:42 <applicative> osfameron: it's mm_freak 's favorite frp scheme
06:50:47 <osfameron> ah
06:50:58 <osfameron> duckduckgo didn't point to that
06:51:17 <merijn> @hackage netwire
06:51:17 <lambdabot> http://hackage.haskell.org/package/netwire
06:51:58 <osfameron> ooo, documentation
06:52:17 <HugoDaniel> [1]    2418 segmentation fault (core dumped)  ghci :/
06:52:32 <mm_freak> i'd go as far as saying that netwire is the only FRP library you can use for games
06:52:46 <mm_freak> for a tutorial introduction see the Control.Wire module
06:53:12 <mm21> mm_freak: why is that?
06:53:26 <osfameron> yeah. that's the one problem with the entry-page doc, it doesn't tell you which of the Module docs below to start with
06:53:41 <mm_freak> mm21: because other libraries are too slow or simply don't have the necessary features…  not to say they are bad, but they are good for other things
06:53:53 <mm_freak> for example reactive-banana is great for widget-based GUIs
06:54:13 <mm21> ok
06:55:56 <timau> something weird going on in here, can someone explain?
06:56:31 <hpaste> timau pasted “weird errors with `finally`” at http://hpaste.org/80597
06:57:01 <Sculptor> hi!
06:57:17 <merijn> timau: No line can be indented less than the block they're in
06:57:40 <applicative> the ` is on the same line as d in do
06:57:55 <merijn> timau: Without the indent the `finally` is considered as part of the same level as the do block it's supposed to be in
06:58:08 <timau> merijn: but if I remove x out of the picture it works
06:58:10 <rorywinston> @mm_freak: thanks man
06:58:10 <lambdabot> Unknown command, try @list
06:58:37 <rorywinston> merijn: thanks, ill have a look
06:58:42 * timau works regardless if I put space or not
06:58:56 <rorywinston> mm_freak: thanks that sounds interesting...
06:58:57 <applicative> timau: then its finally (do (error ..) ) putStr..
07:00:16 <applicative> timau, you dont need the second do in any case, since     error "hello"    `finally`      putStrLn (show x) is one expression, one action
07:00:23 <timau> applicative: oh, so in the second example I pasted only error is passed to finally?
07:00:39 <applicative> i might have been wrong about that, let me look again
07:01:34 <applicative> yes, that's right
07:01:40 <timau> in the real code second do (containing errors) has more lines, I would like finally to apply to all of them
07:01:50 <timau> containing error*
07:04:11 <timau> basically I want to do something like this.
07:04:54 <hpaste> timau annotated “weird errors with `finally`” with “weird errors with `finally` (annotation)” at http://hpaste.org/80597#a80598
07:05:45 <applicative> I wonder if finally will work here, given the dependence
07:09:00 <hpaste> applicative annotated “weird errors with `finally`” with “weird errors with `finally` (annotation) (annotation)” at http://hpaste.org/80597#a80599
07:09:17 <applicative> timau, I take it this bracketing is wrong? ^^^
07:10:13 <applicative> do didn't line up.
07:12:16 <timau> the general idea is fine, and works fine
07:12:17 <applicative> at first it seemed you were trying to get the extraction of x with foo inside the first arg of 'finally', but then use it in the second chunk
07:12:37 <timau> yes I want to clean x in finally
07:13:30 <timau> I dont really get why it worked with paenthesis, but not when I used finally as infix function, I couldnt access x then
07:13:41 <linduxed> hey guys, i was thinking of getting into doing some tests on my code and while reading this page http://ics.p.lodz.pl/~stolarek/blog/2012/10/code-testing-in-haskell/
07:13:56 <linduxed> i find out that comparing floats might be problematic
07:14:31 <linduxed> the guy from the blog solves the problem by creating an AEq (almost equal) class and does an instance for Double
07:15:04 <linduxed> it's about a quarter of the page in, just search for "AEq"
07:15:31 <linduxed> is there some more established way to do this, or should i rip his implimentation? (i've got some float compares to do)
07:16:44 <hpaste> applicative annotated “weird errors with `finally`” with “weird errors with `finally` (annotation) (annotation) (annotation)” at http://hpaste.org/80597#a80600
07:17:49 <applicative> timau, the do has to be somehow bracketed if its an argument of finally like so ^^^ which looks a l ittle silly
07:17:57 <zzKon> what is passed as first argument to `finally` if I omit parenthesis and align `finally` with do ?
07:18:29 <zzKon> I thought that's equal, and I always used the infix version
07:19:20 <timau> applicative: yeah, I think I prefer the first version
07:19:30 <applicative> it's rejected since x is not in scope, zzKon
07:23:23 <applicative> but there is a precedence that would work I think...
07:24:00 <hpaste> applicative annotated “weird errors with `finally`” with “weird errors with `finally` (annotation) (annotation) (annotation)” at http://hpaste.org/80597#a80602
07:25:06 <applicative> finally shouldn't be flipped there; I started with something else
07:26:40 <bxc> is there an automated way to show unused imports in source code?
07:27:23 <Lethalman> :t <|>
07:27:24 <lambdabot> parse error on input `<|>'
07:27:29 <Lethalman> :t (<|>)
07:27:30 <lambdabot> Alternative f => f a -> f a -> f a
07:28:04 <covi> How is Identity a monad instance?
07:28:10 <shachaf> bxc: GHC will tell you.
07:28:19 <shachaf> bxc: You might need -Wall or something.
07:28:24 <shachaf> -fwarn-unused-imports? I don't know.
07:28:54 <shachaf> covi: Trivially. :-)
07:28:55 <shachaf> (Is this one of the situation where you're allowed to say that?)
07:29:03 <applicative> return = Identity; (>=>) f g = g . runIdentity . f
07:29:23 <bxc> shachaf: oh. thanks.
07:29:26 <shachaf> covi: Are you asking what the implementations are, or why they satisfy the laws?
07:29:52 <applicative> laws:  (>=>) f return = Identity . runIdentity . f
07:30:10 <applicative>  (>=>) return g = g . runIdentity . Identity
07:30:21 * shachaf thinks the (>=>) presentation only obscures things.
07:30:34 <applicative> you would
07:31:30 <applicative> (>=>) f return = Identity . runIdentity . f = f ; (>=>) return g = g . runIdentity . Identity = g  to labor the obvious
07:31:43 <shachaf> That's still missing one law. :-)
07:32:26 <applicative> transitivity is too much typing for someone with no keyboard
07:33:03 <arbn> applicative: You're tapping a sheet of glass?
07:33:24 <applicative> no it's more ridiculous than that
07:33:36 <arbn> applicative: Clicking on a soft keyboard.
07:33:36 <quicksilver> if you're using the >=> version why write it prefix?
07:33:56 <quicksilver> isn't the analogy with . much clearer infix?
07:33:59 <applicative> quicksilver: I was just giving the idea, I regret everything; shachaf was right
07:34:12 <applicative> yes you are right too
07:34:23 <quicksilver> don't tell shachaf he's right
07:34:29 <covi> Can anyone familiar with Parsec enlighten me what the heck do s, u, Parsec, and ParsecT mean, in:  type Parsec s u = ParsecT s u Identity
07:34:29 <quicksilver> he'll become intolerable! :)
07:34:58 <covi> I know the doc says:  -- | @ParsecT s u m a@ is a parser with stream type @s@, user state type @u@, underlying monad @m@ and return type @a@.  Parsec is strict in the user state.
07:35:06 <covi> But can anyone give me a concrete example?
07:35:35 <covi> In particular, I didn't see any  instance Stream  definition in the Parsec source.
07:36:18 <applicative> quicksilver: youre right again, shachaf was wrong, as usual
07:36:59 <magneticduck> aaa, how the heck do I install the SDL_ttf package on ubuntu
07:37:02 <magneticduck> >_>
07:37:07 <magneticduck> it's a .rpm
07:37:21 <magneticduck> so, I have to give up on SDL on ubuntu?
07:37:34 <magneticduck> err..
07:37:52 <applicative> it would be clearer read with the last arg, Parsec s u a = ParsecT s u Identity a -- as opposed e.g. to ParsecT s u IO a
07:38:32 <plhk> is this something standard http://hpaste.org/80601 / how can i do better?
07:39:09 <covi> applicative: ????
07:39:50 <applicative> covi the Instances for Stream are defined in Parsec.String and Parsec.ByteString etc
07:40:04 <covi> plhk: try liftM
07:41:25 <applicative> so elsewhere we read that Parser a = Parsec String () a = ParsecT String () Identity a
07:41:34 <covi> applicative: thanks for pointing this out. I see that the definitions only contain `uncons'; how does this enable the stream instance to track the position within the stream
07:42:30 <applicative> covi, yeah, I was treating that as black box like the continuation passing definition of ParsecT .
07:42:37 <covi> applicative: so a Parser a is a "standard" parser that parses a string (the `s') and returns values of type a?
07:42:49 <applicative> that's right, it's the most primitive form.
07:43:11 <covi> shit, i didn't realize ParsecT's def. is cps
07:43:12 <applicative> we use () when we make a place for error things
07:43:25 <applicative> we use Identity when we make a place for other monad like IO
07:43:31 <covi> applicative: so all errors will be ignored?
07:44:12 <applicative> no, it's more elaborate than that, if I remember.
07:44:23 <mm21> what does "inhibits with a value of type e" mean?
07:44:53 <fmap> @ty \f -> head <$> map (mfilter f)
07:44:54 <lambdabot> MonadPlus m => (a -> Bool) -> [m a] -> m a
07:44:57 <mm21> from Control.Wire "From these inputs it either produces an output value of type b or inhibits with a value of type e,"
07:45:06 <applicative> We have to use String explicity, since Parsec wants to do Text and ByteString, so to get back to the simple pure string parser you use ParsecT String () Identity
07:45:07 <fmap> hmm
07:45:49 <Lethalman> :t mifilter
07:45:50 <lambdabot>     Not in scope: `mifilter'
07:45:50 <lambdabot>     Perhaps you meant one of these:
07:45:50 <lambdabot>       `mfilter' (imported from Control.Monad.Writer),
07:45:51 <Lethalman> :t mfilter
07:45:53 <lambdabot> MonadPlus m => (a -> Bool) -> m a -> m a
07:46:17 <covi> applicative: up to this point, I only understand why 'String' takes the place of 's'. Can you say more on the '()' and 'Identity'?
07:46:54 <applicative> Identity is just the 'identity monad' newtype Identity x = Identity {runIdentity :: x}
07:47:09 <applicative> you have to include it so that ParsecT works on 'monads' now.
07:48:00 <hpaste> MagneticDuck pasted “Trying to install SDL, help? :/” at http://hpaste.org/80603
07:48:09 <magneticduck> hope this is the right place
07:48:16 <magneticduck> can't install SDL-ttf
07:48:39 <applicative> > runIdentity $ do {x <- Identity 14; y <- Identity 12 ; return (x + y)}
07:48:41 <lambdabot>   26
07:48:41 <magneticduck> the .rpm is the binary from the download link given in cabal install's error
07:49:11 <covi> applicative: so whenever we use Identity in ParsecT, the monad 'm' actually does nothing?
07:50:12 <bxc> a few monads seem to be defined as a transformer first and then the monad you normally see as that transformer on the identity monad
07:50:19 <applicative> yeah, it's like you're making space for monads in general but don't really need one.  Most of what you write without a signature would be polymorphic in fact
07:50:51 <applicative> covi: as bxc says, this is typical with 'monad transformers'
07:51:05 <magneticduck> any help?
07:51:07 <magneticduck> :/
07:51:33 <applicative> it's a little since the monad transformer concept is written into what used to be simple monads, eg Parsec, State, Reader
07:51:46 <covi> applicative: isn't this the "overly polymorphic style"?
07:52:38 <covi> What is that 'u' in
07:52:38 <covi> data ParsecT s u m a = ParsecT { runParsecT :: State s u -> m (Consumed (m (Reply s u a))) }
07:52:51 <applicative> covi, I think it's one of these annoying things where, once you adjust to it, it's better, but it's a menace trying to figure it out.
07:53:52 <fmap> @google sdl-ttf ubuntu
07:53:53 <lambdabot> http://ubuntuforums.org/showthread.php?t=232277
07:53:53 <lambdabot> Title: SDL and TTF using g++ - Ubuntu Forums
07:53:54 <shachaf> covi: You should look at the definition of "State" to find out. :-)
07:54:15 <shachaf> covi: It looks like it's the user state.
07:54:20 <covi> applicative: exactly, i feel like i know what a monad transformer is and what monads are, but i am not able to decypher real-world code.
07:54:27 <shachaf> I.e. "your stuff"
07:54:32 <covi> shachaf: what is 'user state' anyway
07:54:39 <magneticduck> if there are any answer for my question, thanks in advance
07:54:41 <shachaf> Whatever you want, I assume.
07:54:49 <magneticduck> I'm going to be back in a bit
07:55:03 <shachaf> @google parsec user state
07:55:05 <lambdabot> http://stackoverflow.com/questions/6477541/user-state-in-parsec
07:55:05 <lambdabot> Title: haskell - User state in Parsec - Stack Overflow
07:56:03 <applicative> covi: I think monad transformers are easiest when you see real code, with tons of lifts, then you can see the whole do block as having layers starting from the left.
07:57:44 <applicative> sensible SO answer there
08:00:14 <covi> I should dive deeper into Parsec.
08:00:40 <covi> Trying to build a Scheme interpreter that should be able to parse comments and multi-line definitions.
08:02:58 <applicative> timau: http://hpaste.org/raw/80604  -- I think this exhibits the principle, maybe
08:03:00 <covi> Is type alias curried?
08:03:13 <applicative> in that case, yeah, 'partially applied'
08:03:54 <applicative> covi: I mean, the synonym declaration you quoted above, that's why I expanded it
08:04:28 <shergill> morning #haskell
08:04:37 <applicative> hullo shergill
08:04:54 <covi> kk
08:05:00 <covi> and, the definition of
08:05:02 <covi> newtype ParsecT s u m a
08:05:05 <covi> uses CPS?
08:05:38 <shachaf> It looks pretty CPSy to me.
08:05:39 <shergill> template haskell has been on my lists of things to dig into for a while now. i have little to no knowledge of it as template metaprogramming is implemented in haskell
08:05:39 <applicative> yes
08:05:59 <shergill> i have prior experience coding in lisp and so am familiar with lisp macros
08:06:10 <applicative> ddarius said, 'they said it was too slow, so I cps'd it'
08:06:12 <shergill> what resources would you guys/girls recommend?
08:06:31 <covi> Too hardcore :(
08:06:38 * hackagebot diagrams-qrcode 1.0.1 - Draw QR codes to SVG, PNG, PDF or PS files.  http://hackage.haskell.org/package/diagrams-qrcode-1.0.1 (FelipeLessa)
08:06:52 <shergill> i was thinking of starting with bulat's tutorials
08:06:53 <applicative> I can't believe it's like lisp macros, but since I don't know either, I won't hazard a guess...
08:07:18 <shergill> well haskell isn't homoiconic, but the intent, iiuc, is the same
08:08:31 <n-dolio> Yeah, you can't really make new syntax as such.
08:09:17 <n-dolio> Lisp's syntax is tree structure, and macros can manipulate that. But Haskell's isn't really.
08:09:45 <shergill> hmm. haskell doesn't have an ast?
08:10:01 <quicksilver> it's not "just" a simple tree like lisp
08:10:06 <quicksilver> certainly it's an AST
08:10:17 <quicksilver> there is also a big phase difference
08:10:25 <n-dolio> One might say that lisp macros don't manipulate an AST.
08:10:27 <n-dolio> That's the difference.
08:10:31 <quicksilver> lisp code is still trees even at runtime (well, in interpreters it is)
08:10:47 <quicksilver> GHC code is compiled machine code at runtime so it's definitely not manipulatable then
08:11:02 <quicksilver> except to the extent you reflect your own code into introspectable structures.
08:11:11 <shergill> right lisp does macros well coz of its homoiconicity
08:11:34 <applicative> quicksilver: I didn't know you were a ... a ... a  ...
08:11:38 <applicative> template haskell user
08:11:39 <shergill> i get that, i was just wondering what a good resource would be to get me started with template haskell
08:12:04 <srhb> I'm missing something here. I've installed xmonad-extras via cabal install, and there should be a module XMonad.Hooks.PerWindowKbdLayout -- but I can't import it. Where do I look on my filesystem to debug this?
08:12:09 <quicksilver> applicative: I'm not. I just know what it does.
08:12:22 <applicative> oh, the very high road
08:12:24 <zzKon> many lisp compilers to machine code
08:12:30 <zzKon> so that shouldn't matter
08:12:40 <zzKon> compile to+
08:13:18 <applicative> srhb it should be in home/.cabal   look in ghc-pkg list  or ghc-pkg list xmonad-extras?
08:13:32 <applicative> or rather, do one of them....
08:13:44 <zzKon> "<n-dolio> Yeah, you can't really make new syntax as such." <- isn't that the point of template haskell, to make new syntax?  I haven't used it yet
08:14:09 <srhb> applicative: Package is definitely there. One of the modules it provides seems not to be.
08:14:14 <n-dolio> zzKon: No. I'd say its uses are more along the lines of C++ templates.
08:14:28 <applicative> oh. srhb ghc-pkg find-module blah
08:14:36 <n-dolio> Or, uses of templates that aren't covered by having proper parametric polymorphism.
08:14:41 <zzKon> n-dolio compile time calculations, etc?
08:14:44 <absence> with the diagrams package, applying multiple transforms seems to be done by composing transform functions. applying e.g. thousands of transforms to a primitive causes an impressive ammount of thunks. is there a way to avoid this?
08:14:51 <n-dolio> zzKon: Code generation, etc. Yeah.
08:15:21 <merijn> What program should I use to generate tag files for Haskell?
08:16:13 <srhb> I think the docs are just lying. I see the code in the package, but the Module is clearly not provided. Weird.
08:16:34 <fmap> srhb: may be wrong version?
08:17:01 <srhb> fmap: Matches the version on the hackage docs.
08:17:51 <fmap> srhb: wrong flags?
08:17:53 <applicative> srhb: you need to give a flag to cabal-install it seems http://hpaste.org/raw/80605
08:18:07 <fmap> seems xmonad-extras abuses them heavily
08:18:19 <n-dolio> zzKon: You can repurpose existing syntax, but it's going to look really heavyweight for that, in addition to being painful.
08:18:20 <applicative> oh fmap is on this
08:18:44 <srhb> I.. see.
08:19:00 <n-dolio> zzKon: And there's no way to extend the parser, certainly.
08:19:02 <srhb> How painful.
08:19:04 <shergill> merijn: i use haskdogs for haskell projects (Which invokes hasktags internally)
08:20:07 <Saizan> absence: foldl' ?
08:20:20 <srhb> So how do I provide flags to cabal install_
08:20:22 <srhb> ?
08:20:39 <applicative> cabal install xmonad-extras --reinstall --flags="with-hlist with-template-haskell"
08:20:42 <merijn> shergill: Any clue whether that's feature compatible with exuberant ctags?
08:20:52 <srhb> applicative: Aha, thanks! I just tried --with_*
08:20:56 <Saizan> zzKon: there are quasiquoters for new syntax though
08:20:56 <applicative> except with underscores
08:21:04 <applicative> ah srhb yes
08:21:39 * hackagebot mathgenealogy 1.2.0 - Discover your (academic) ancestors!  http://hackage.haskell.org/package/mathgenealogy-1.2.0 (PeterRobinson)
08:21:50 <srhb> Well, it doesn't build anyway. I guess that explains the flag.
08:24:04 <fmap> :(
08:31:37 <winsnes> Is there some way to have Regex in Haskell without downloading external code?
08:31:50 <Taneb> @hackage regex-base
08:31:50 <lambdabot> http://hackage.haskell.org/package/regex-base
08:32:33 <hpaste> killy9999 pasted “What does this Core construct mean?” at http://hpaste.org/80606
08:32:58 <killy9999> can anyone tellk me what does "@" on line 4 mean?
08:33:24 <n-dolio> killy9999: Type application.
08:33:48 <winsnes> Taneb, I have tried to import Text.Regex.Base and Text.Regex.Posix but none of those work
08:33:53 <killy9999> what's a type application?
08:34:28 <n-dolio> killy9999: It means that : is a polymorphic function, and there it's being used at Int.
08:34:30 <killy9999> also, when I use -duppress-all "@" changes into cons ":"
08:34:33 <n-dolio> Or something along those lines.
08:35:05 <Taneb> winsnes, is "regex-base" displayed when you type "ghc-pkg list" into a terminal (without quotes, of course)
08:35:30 <killy9999> n-dolio: OK, I don't fully understand but that allows me to move on
08:35:32 <killy9999> thanks'
08:35:49 <n-dolio> killy9999: Core has all information about when polymorphic functions are instantiated to concrete types and such.
08:36:04 <n-dolio> And explicit types on things.
08:36:46 <killy9999> my confusion came from "GHC.Types.:"
08:36:50 <n-dolio> (:) :: forall a. a -> [a] -> [a], (:) @ Int :: Int -> [Int] -> [Int]
08:36:58 <absence> Saizan: i think i'll still end up with a long trans1.trans2.trans3.tran4..... until i apply it to the primitive
08:37:11 <killy9999> I thought of .: as one operator, not as assigning : a namespace of GHC.Types
08:37:22 <n-dolio> Oh, yeah.
08:38:48 <winsnes> Taneb, no it isn't. Very new to Debian so I have no idea how to install it either
08:39:16 <Taneb> winsnes, Haskell has its own library installer called Cabal
08:39:37 <Taneb> type "cabal install regex-posix --enable-documentation --haddock-hyperlink-source"
08:41:02 <Saizan> absence: yeah, my point was to keep applying to the primitive rather than composing them
08:43:21 <bitonic> is there a paper that introduced GADTs?
08:44:16 <craigInnes> is there  a way in haskell to make a timer that will fire a function in a set amount of time unless that timer is called again or stopped?
08:44:46 <winsnes> Taneb, Thank you very very much!
08:44:59 <Taneb> winsnes, we're all new once. It's no trouble :)
08:46:01 <parcs> craigInnes: yes
08:46:02 <magneticduck> 15:47:44          hpaste | MagneticDuck pasted “Trying to install     │ ag4ve
08:46:04 <magneticduck>                          | SDL, help? :/” at http://hpaste.org/80603
08:46:06 <magneticduck> any help pls?
08:46:08 <magneticduck> :x
08:46:18 <magneticduck> lol that didn't format well
08:46:25 <magneticduck> http://hpaste.org/80603
08:46:27 <magneticduck> there
08:47:19 <Taneb> I don't think you installed the SDL C library properly, just selected the package?
08:47:51 <absence> Saizan: i need to compose transforms, but i may be going about it the wrong way. there's a monoid instance here that looks interesting, going to poke around a bit
08:48:19 <magneticduck> ahah
08:51:32 <mm_freak> craigInnes: tid <- forkIO (threadDelay 1000000 >> c)
08:51:39 <mm_freak> to stop the timer, killThread tid
08:52:18 <mm_freak> for safety reasons you may want to do this instead:  tid <- forkIO (threadDelay 1000000 >> forkIO c)
08:53:39 <craigInnes> mm_freak: Thanks. Why is the second example safer. Also, the context i am doing this in is i want a timer to start every time a user makes a change in a text box, and only fire the function if the user remains idle for a few seconds.
08:54:04 <hpaste> DanBurton pasted “Free State” at http://hpaste.org/80607
08:54:08 <magneticduck> Taneb: the dpkg help page says 'i' is the flag to install a package
08:54:11 <mm_freak> craigInnes: oh, in that case there are safer ways to do it
08:54:22 <Taneb> magneticduck, hmm, I don't really know
08:54:30 <magneticduck> :/
08:54:37 <magneticduck> anyone here have TDL?
08:54:38 <mm_freak> craigInnes: to answer your question, the latter is safer, because otherwise the killThread may kill the thread even after the timer has elapsed, but before the function could complete
08:54:39 <magneticduck> anyone?
08:54:43 <magneticduck> >:0
08:54:43 <jerojasro> magneticduck: you need to install the development files (headers)
08:55:02 <magneticduck> ahaha
08:55:04 <magneticduck> of course
08:55:06 <magneticduck> >_>
08:55:12 <magneticduck> forgot that little thing
08:55:15 <magneticduck> eheh
08:55:17 <magneticduck> the headersw
08:55:20 <magneticduck> *headers
08:55:21 <magneticduck> yeah
08:55:23 <magneticduck> :|
08:55:24 <craigInnes> mm_freak: If it helps, I am also using gtk2hs. I am basically looking for something similar to what you can do with sliders, which is to set their update policy to be delayed.
08:55:25 <magneticduck> thanks
08:56:53 <craigInnes> mm_freak: You mentioned there were safer ways to do what I was after in the context I mentioned? Or did you just mean the second method you already said?
08:58:03 <mm_freak> craigInnes: well, an easy way is to fire up a thread that does the update after a short amount of time, just like what i just suggested, but save its ThreadId
08:58:15 <mm_freak> if another interaction happens, kill the thread and restart it
08:58:40 <mm_freak> that's "unsafe", because it's easy to get this wrong and do more updates than necessary
08:59:41 <mm_freak> another way is to use STM:  a thread waits for a boolean to become True and sets it to False in a transaction
09:00:09 <mm_freak> then in the next transaction it waits either for a timeout or for that variable to be set to True again by another thread
09:00:17 <mm_freak> if the latter happens, abort and rewait
09:00:27 <mm_freak> if the former happens, perform the update and start all over
09:03:31 <craigInnes> mm_freak: Okay, thanks. I will take a look at STMs and read up on my concurrency a little. Thanks for your help :)
09:04:13 <mm_freak> sure =)
09:07:44 <mm_freak> fix $ \again -> do atomically (readTVar wantUpdate >>= check >> writeTVar wantUpdate False); waitVar <- registerDelay 1000000; join . atomically $ again <$ (readTVar wantUpdate >>= check) <|> (update >> again) <$ (readTVar waitVar >>= check)
09:07:49 <mm_freak> that should work
09:10:44 <hpaste> MagneticDuck pasted “SDL-mixer not installing” at http://hpaste.org/80608
09:10:50 <magneticduck> alright
09:10:53 <magneticduck> what do I do here
09:10:55 <magneticduck> xD
09:10:57 <magneticduck> geez
09:11:03 <magneticduck> "C compiler cannot create executables"
09:11:05 <magneticduck> ..dafuq
09:11:13 <magneticduck> ummmmm
09:11:15 <magneticduck> xD
09:12:05 <magneticduck> any ideas?
09:12:13 <magneticduck> I'm really anxious to get programming in SDL
09:12:15 <magneticduck> :P
09:12:20 <magneticduck> s/in/with
09:13:06 <ClaudiusMaximus> magneticduck: is your /tmp mounted noexec?
09:14:03 <magneticduck> hm?
09:14:33 <magneticduck> ah
09:14:35 <magneticduck> I see
09:14:51 <magneticduck> yeah it seems the the package downloaded there is noex
09:14:57 <magneticduck> how do I change that even?
09:15:12 <magneticduck> wups multitasking
09:15:19 <magneticduck> how do I change that?
09:15:59 <ClaudiusMaximus> create a tmp folder somewhere you can run executables from and set the appropriate environment variable for cabal install
09:16:33 <ClaudiusMaximus> something like mkdir foo && TMP=/path/to/foo TMPDIR=/path/to/foo cabal install ...
09:17:14 <magneticduck> kk
09:17:22 <magneticduck> or should I just make my /tmp executable?
09:17:26 <magneticduck> I'm root here
09:17:34 <magneticduck> *I have root priviliges
09:17:37 <magneticduck> is that alright?
09:17:46 <ClaudiusMaximus> err wait
09:18:01 <ClaudiusMaximus> maybe it's some other issue
09:18:59 <ClaudiusMaximus> seems cabal-install runs /tmp/SDL-mixer-0.6.1-26429/SDL-mixer-0.6.1/dist/setup/setup successfully?  maybe try more -v to cabal-install
09:22:35 <heatsink> Is any type-level term with an arrow kind called a type constructor?
09:23:52 <heatsink> For example, would you say Either String is a type constructor?
09:25:05 <magneticduck> hmm, what's the default privilige mode for /tmp?
09:25:21 <quicksilver> heatsink: technically, no.
09:25:23 <`nand`> heatsink: now that I think about it, probably not
09:25:39 <quicksilver> heatsink: it would be an understandable abuse of terminology if you did.
09:25:57 <quicksilver> technically 'Either' is the type constructor and 'Either String' is partly applied - but it's not a constructor per se.
09:26:20 <quicksilver> there is some historical backing for that abuse though; classes like Monad and Functor used to be called 'constructor classes'
09:26:28 <`nand`> my intuition agrees with quicksilver
09:26:29 <shachaf> If you're talking with someone and you need to be that precise, just define your terminology.
09:26:45 <shachaf> If you decide to call anything of kind (a -> b) a constructor, I'd be fine with that.
09:26:50 <shachaf> People use words in lots of different ways.
09:26:54 <Saizan> tbf Either String still works a lot like a data-constructor wrt pattern matching
09:27:07 * quicksilver nods
09:27:49 <`nand`> you can also match on (,) Nothing just fine
09:28:38 <heatsink> Alright
09:28:49 <jerojasro> magneticduck: just ouy of curiosity, what distro are you using?
09:28:53 <jerojasro> *out of ...
09:29:25 <heatsink> In my experience, when people use "type constructor" for anythong of arrow kind, they use "type" only for terms of kind "*"
09:29:44 <heatsink> So if Either String isn't a type constructor, is it a type?
09:33:42 * `nand` thinks Either String is a perfectly fine type
09:33:51 <`nand`> for that matter, I think Monad is a perfectly fine type too
09:34:11 <`nand`> (though only with GHC+extensions)
09:34:19 <bullroarer> [42,13,22]
09:35:32 <heatsink> Here's a paper that uses the more inclusive "type constructor" terminology http://www.cis.upenn.edu/~sweirich/papers/hota/hota.pdf
09:36:31 <heatsink> Okay, so higher-kinded types can be called types
09:36:36 <`nand`> (for that matter, is there suitable terminology for “type of kind *”, other than “type of kind *”?)
09:36:46 <heatsink> Proper types
09:37:32 <S11001001> term types?
09:37:40 <heatsink> http://stackoverflow.com/a/6427289/507803
09:37:51 <heatsink> You can call them "proper types"
09:38:50 * Lethalman just heard about frege
09:44:56 <linduxed> hey guys, i was wondering how i could round something to the 2nd decimal?
09:45:21 <linduxed> like, 0.89972123 would be 0.90
09:45:43 <linduxed> or 1.12345 would be 1.12
09:45:56 <`nand`> > showCReal 2 0.89972123 -- cheating
09:45:58 <lambdabot>   "0.9"
09:45:59 <linduxed> round just goes for the closest integer
09:46:03 <`nand`> > showCReal 3 0.89972123
09:46:05 <lambdabot>   "0.9"
09:46:07 <shachaf> `nand`: Really, CReal?
09:46:20 <Ralith> linduxed: round (x*100)
09:46:22 <Ralith> :D
09:46:26 <linduxed> ....
09:46:27 <shachaf> > showFFloat (Just 2) 1.12345
09:46:30 <lambdabot>   can't find file: L.hs
09:46:31 <shachaf> > showFFloat (Just 2) 1.12345 ""
09:46:33 <lambdabot>   "1.12"
09:46:39 <shachaf> > showEFloat (Just 2) 1.12345 ""
09:46:40 <lambdabot>   "1.12e0"
09:46:43 <shachaf> > showGFloat (Just 2) 1.12345 ""
09:46:44 <lambdabot>   "1.12"
09:46:45 <`nand`> ah, neat
09:46:48 <shachaf> You have to pick which representation you want.
09:46:51 <Ralith> shachaf: what're those from?
09:46:56 <shachaf> @hoogle showFFloat
09:46:56 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
09:47:05 <linduxed> but, that is just a string representation
09:47:13 <Ralith> not actually very informative.
09:47:15 <shachaf> Oh, I thought you were wanting to show.
09:47:20 <linduxed> i thought one should get a Num or something like that
09:47:26 <shachaf> I blame `nand`!
09:47:29 <linduxed> no i want to just round the number
09:47:32 <Ralith> dammit `nand`
09:47:39 <`nand`> :(
09:47:46 <fmap> > (/100) . fromIntegral . round . (*100) $ 0.89972123
09:47:46 <`nand`> I blame tiredness!
09:47:47 <lambdabot>   0.9
09:48:26 <linduxed> fmap: ehm, i guess that works, but it looks a bit hacky :-/
09:48:30 <linduxed> maybe it's just me
09:48:56 <linduxed> i was thinking there was maybe a version of round that handled precision
09:48:59 <linduxed> or something like that
09:49:15 <`nand`> base 10 is a bit arbitrary in the first place
09:49:48 <`nand`> I'm not convinced that isn't the ‘best’ solution (assuming you factor it out to an extra function)
09:50:02 <linduxed> yeah, maybe you're right
09:50:14 <linduxed> i mean... it does work
09:50:18 <linduxed> oh well
09:50:22 <linduxed> thx for the tip!
09:50:44 <`nand`> you might run into issues with Double
09:50:52 <`nand`> if (*100) brings you into Infinity range
09:50:59 <`nand`> or something
09:51:07 <linduxed> pretty sure that won't be a problem in this case
09:51:14 <fmap> I guess there is a (bad) lens for that?
09:52:02 <`nand`> maybe a prism
09:52:20 <fmap> "there is" as in "should not be written"
09:52:25 <PineappleZombie> You need to have numbers exceeding 1e306 to get overflow. Not terribly serious
09:52:26 <Lethalman> what's the s in ST s a ?
09:52:26 <absence> http://hpaste.org/80613 <- can anyone see what i'm doing wrong here?
09:52:42 <`nand`> the traversal would add on the stuff that got rounded away while letting you modify the rounded part
09:52:44 <Lethalman> for State s a it's a state that I can access with get and put
09:52:51 <Lethalman> what about ST?
09:53:01 <`nand`> Lethalman: it's a phantom parameter used to distinguish different uses of ST from eachother
09:53:09 <shachaf> Lethalman: It's not anything.
09:53:16 <Lethalman> ok thanks
09:53:20 <shachaf> It's just used polymorphically.
09:53:41 <`nand`> in fact, the type of runST ensures that you can't ever fill in anything useful for ‘s’
09:54:33 <Lethalman> I still don't understand that much deeply but it's ok for now :)
09:54:55 <`nand`> long story short, it prevents you from illegally sharing ST stuff in between invocations of runST
09:55:47 <Lethalman> so STRefs are only local to a specific function?
09:56:05 <Lethalman> that is you can't pass an STRef to another :: ST s Foo function to use it?
09:56:19 <`nand`> sure you can, they just have to have the same parameter ‘s’
09:56:28 <monochrom> STRef is local to one runST session
09:56:35 <`nand`> ^
09:56:45 <Lethalman> ok
09:57:38 <monochrom> which is what `nand` said. "it prevents you from illegally sharing ST stuff in between invocations of runST"
09:57:46 <`nand`> like you could write a function :: STRef s Foo -> ST s Bar
09:58:56 <Ralith> shachaf: so where were you when people were telling me to use printf for low-precision float stringing
10:00:08 <Lethalman> `nand`, ah ok
10:00:16 <Lethalman> clear
10:01:45 <`nand`> Ralith: fun fact: printf uses showEFloat/showFFloat/showGFloat internally
10:01:54 <`nand`> you could have looked at the source to figure out what it's doing :D
10:02:15 <Lethalman> :t showGFloat
10:02:17 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
10:02:30 <shachaf> Ralith: I found out about show*Float by reading Text.Printf.
10:02:42 <`nand`> GFloat is what Double defaults to, or something; uses scientific notation only above 10m or so
10:03:03 <Ralith> `nand`: give me a M-. that Just Works and I might do just that.
10:03:22 <monochrom> I found out about show*Float by reading Numeric
10:03:26 <`nand`> M-.? Is that some emacs incantation?
10:03:28 <`^_^v> is there a ghci command to let me see the typeclasses that an instance of a type has
10:03:42 <c_wraith> `^_^v: :info
10:03:42 <shachaf> `^_^v: :i
10:03:49 <tibbe> I'm trying to unbork my MacBook Pro. Could someone with a MBP that doesn't use FileVault send me the output of "diskutil list"?
10:03:49 <`nand`> that sentence doesn't seem to make sense to me
10:03:52 <Ralith> common lisp was a high point of the "who needs docs, read the code" approach for me because it was so easy to navigate
10:04:09 <killy9999> I'm trying to learn how to read assembly generated by GHC
10:04:12 <killy9999> any good advice?
10:04:14 <`nand`> but I guess :i works for both possible interpretations of it
10:04:22 <killy9999> except fot "Don't do it"
10:04:28 <glguy> `^_^v: :i will only show you the typeclasses where every part of the instance is in scope, so in some cases you'll need to know the details of an instance to find it
10:04:46 <shachaf> killy9999: Advice: Read the STG paper. Read the dynamic pointer tagging paper. Read the "fast curry" paper?
10:04:52 <Ralith> `nand`: C-h k M-.
10:04:57 <Ralith> ^^
10:05:02 <shachaf> killy9999: Advice: First learn to read Core, and Cmm.
10:05:13 <shachaf> killy9999: -ddump-simpl and -ddump-cmm, respectively. -ddump-stg is also good.
10:05:16 <killy9999> shachaf: OK, I can read Core
10:05:30 <killy9999> which paper is the STG paper? the 80-page one?
10:05:31 <shachaf> killy9999: The Cmm has more or less the same content as the assembly but is much more readable.
10:05:39 <monochrom> try to see the correspondence between Core and Cmm
10:05:39 <shachaf> killy9999: Yep. :-)
10:05:43 * `nand` vaguely remembers some series of articles directly aimed towards ‘understanding GHC's internals’
10:05:53 <monochrom> then between Cmm and assembly
10:06:01 <shachaf> killy9999: Also the usual advice: Make very small programs, look at their output, change them a bit, look at their output
10:06:38 <monochrom> the GHC commentary should also contain much information
10:06:56 <killy9999> monochrom: yes, I'm reading through the commentary :)
10:06:58 <shachaf> killy9999: The biggest thing Cmm gives you over assembly is names, I think. For example, "if (Sp - 8 < something) jump some_gc_thing;"
10:07:12 <shachaf> Oh, the GHC commentary had a good page on this.
10:07:27 <`nand`> Ralith: I'm going to blindly assume it's some sort of ‘show the source code’ binding; in which case, I use !hoogle X
10:07:30 <shachaf> killy9999: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
10:07:57 <killy9999> shachaf: yeah, I have that page already open :)
10:08:11 <killy9999> I heard that STG paper is a bit dated
10:08:22 <shachaf> killy9999: Also there was a set of slides from the cs240h class at Stanford.
10:08:25 <`nand`> GHC's internals change continuously
10:08:29 <shachaf> killy9999: http://www.scs.stanford.edu/11au-cs240h/notes/ -- it was one of those.
10:08:40 <shachaf> killy9999: Yes, many of the things it describes are no longer relevant and/or true.
10:08:46 <shachaf> But the basic model is still there.
10:08:48 <Ralith> `nand`: it jumps the cursor to the definition of the value bound to the name under the cursor; this is really, really convenient for navigating large codebases, exploring things, and using code as docs.
10:08:56 <shachaf> killy9999: You should read the dynamic pointer tagging paper.
10:09:00 <shachaf> @where ptr-tag
10:09:00 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
10:09:17 <`nand`> Ralith: I see
10:09:22 <`nand`> Ralith: I use / for that
10:09:22 <killy9999> you're reading my mind. I was googling that
10:10:14 <shachaf> killy9999: That paper mentions, for example, that GHC doesn't do vectored-returns at all anymore
10:10:23 <Ralith> I haven't been able to find anything for haskell that works reliably or comprehensively.
10:10:29 <Ralith> anything similar*
10:10:34 <Ralith> and*
10:10:46 <killy9999> shachaf: I'm fine with that, I don't know what vectored-returns even are ;)
10:11:38 <shachaf> killy9999: That's a thing described in the STG paper. For example, when evaluating a Maybe, you push "Just" and "Nothing" continuations and then enter the Maybe.
10:11:50 <linduxed> gaaaah
10:11:54 <killy9999> Damn, that's a lot of information to read....
10:11:56 <shachaf> And then it calls one of them (possibly with an argument, in the Just case).
10:12:04 <linduxed> roundTo3Decimals = (/1000) . fromIntegral . round . (*1000)
10:12:13 <killy9999> I wonder how to proceed with reading of this
10:12:24 <linduxed> "Defaulting the following constraint*s) to type `Integer'
10:12:32 <linduxed> how can i avoid that warning
10:12:44 <killy9999> linuxed: provide type information
10:12:51 <glguy> use fromInteger instead of fromIntegral, perhaps
10:12:59 <killy9999> roundTo3Decimals :: Int
10:13:11 <shachaf> killy9999: David Terei's slides that I linked to might be a good start?
10:13:23 <shachaf> http://www.scs.stanford.edu/11au-cs240h/notes/ghc-slides.html
10:13:28 <glguy> linduxed: you don't need the fromIntegral . round, just round
10:13:34 <glguy> oh, nevermind
10:13:37 <HugoDaniel> im going to write a book titled "Debugging Haskell with unsafePerformIO"
10:13:53 <`nand`> killy9999: the defaulting comes from the Integral inside ‘fromIntegral . round’, not the result type
10:13:57 <`nand`> so what glguy said
10:14:00 <glguy> missed the next (/1000), but fromInteger will get rid fo the warning
10:14:04 <`nand`> fromInteger . round
10:14:07 <Ralith> linduxed: you want 'roundTo n = let factor = 10^n in (/factor) . fromIntegral . round . (*factor)
10:14:10 <Ralith> '
10:14:18 <killy9999> shachaf: thanks
10:16:05 <killy9999> Commentary on the GHC wiki says that Hoopl aims to replace Stg -> Cmm step
10:16:27 <killy9999> does this mean that a) STG will be removed; b) Cmm will be removed; c) both
10:18:16 <shachaf> I think d) neither?
10:18:27 <geekosaur> (d) neither; just the existing translation from one to the other will move into hoopl?
10:18:56 <geekosaur> (making it more modular and hopefully easier to maintain and extend)
10:19:15 <killy9999> I guess the Hoopl paper explains it?
10:20:02 <shachaf> Don't believe the Hoopla.
10:21:47 <killy9999> I have to say that this is getting frustrating
10:22:08 <parcs> i think it means that hoopl is used to perform optimization passes on the cmm
10:22:09 <killy9999> I spend hours trying to learn how GHC works and I don't feel I'm getting anywhere
10:22:48 <shachaf> killy9999: GHC generates very different sort of code from most other things.
10:23:04 <shachaf> The assembly can seem pretty backwards, partly because it is. :-)
10:23:38 <killy9999> shachaf: I don't mean only assembly
10:23:44 <shachaf> Sure.
10:23:46 <killy9999> I mean the compiler as a whole
10:23:56 <killy9999> I'd like to learn how it works and be able to develop it
10:24:04 <shachaf> It's a big project. Big projects take time to get into. :-)
10:24:16 <killy9999> yes, the certainly do
10:24:26 <killy9999> my problem is that I'm doing this alone
10:24:48 <killy9999> while it would be useful to have someone to tell me: learn this first, later learn this... and so on
10:25:02 <luite> what part of the compiler do you want to work on?
10:25:20 <shachaf> killy9999: You can write this sort of thing up as you go! Maybe it'll be helpful to someone else. :-)
10:25:26 <killy9999> luite: optimizations? not yet sure
10:25:52 <shachaf> killy9999: You should, like, totally make unboxed sums work!
10:26:01 <luite> killy9999: hm, there are two places where most of the optimizations happen, one is in Core, with Core to Core rewrites
10:26:04 <luite> the other is hoopl
10:26:05 <killy9999> shachaf: I actually find the old commentary quite useful
10:26:17 <shachaf> @where cpr
10:26:17 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
10:26:23 <shachaf> killy9999: Another one to read.
10:27:30 <killy9999> shachaf: I was hoping for at least one paper where I could say "I already read that one"...
10:28:17 <killy9999> aside from developing the compiler, I'd like to learn it to be able to write efficient libraries
10:28:27 <killy9999> I looked at the sources of stream-fusion today
10:28:35 <killy9999> and it has some pretty l33t h4X
10:29:00 <shachaf> @quote elliott lens
10:29:00 <lambdabot> elliott says: I think lens is the first library I've seen that promises letting you write abstract totally-inefficient-looking compositional code and getting reliably good compilation which has
10:29:00 <lambdabot> actually delivered on that promise.
10:29:49 <elliott> shachaf: That's now a lie.
10:29:53 <shachaf> (Except for the parts where that's not true... :-( I haven't figured out how to make some of those work yet.)
10:29:57 <elliott> Since it turns out we actually get terrible Core sometimes?
10:30:05 <shachaf> elliott: Which sometimes?
10:30:11 <elliott> The ones you're thinking of.
10:30:12 <shachaf> Things like lastOf (traverse._Just)?
10:30:18 <elliott> Yes.
10:30:20 <shachaf> My nemesis.
10:30:28 <luite> killy9999: ah definitely learn to read core then
10:30:50 <killy9999> luite: already know how to do that
10:31:03 <luite> killy9999: and cmm occasionally, it's a bit friendlier than assembly :)
10:33:11 <killy9999> I was actually thinking that I should learn GHC by starting from the parser
10:33:30 <killy9999> then typechecker, desugarer
10:33:41 <killy9999> and moving down towards codegen
10:33:53 <shachaf> Whatever works for you. :-)
10:34:02 * shachaf likes to pretend parsing isn't a thing that exists.
10:35:30 <killy9999> shachaf: well, I'm not interested in the parsing algorithm itself
10:35:40 <killy9999> more in the data structres used by the compiler
10:35:45 <killy9999> and logical flow of the compilation
10:39:18 <NemesisD> how can i import a qualified module in ghci?
10:40:08 <fmap> import qualified Module as M
10:40:32 <NemesisD> oh, is that new?
10:40:46 <shachaf> It's been a couple of years or something, hasn't it?
10:40:51 <shachaf> Since GHC 7 or so.
10:43:43 <NemesisD> sweet, i might actually get some use out of ghci then
10:43:53 <NemesisD>  now that i got it working with cabal-dev
11:01:42 * hackagebot hermit 0.1.6.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.1.6.0 (AndrewFarmer)
11:05:49 <aluink> any yesod dev here?
11:06:15 <linduxed> Ralith: didn't change a thing, still same warning
11:06:27 <Ralith> linduxed: I wasn't correcting the warning.
11:06:38 <linduxed> Ralith: oh i see
11:06:45 <Ralith> :p
11:08:10 <luite> aluink: possibly. also see #yesod
11:09:13 <aluink> luite: oh, thanks!
11:09:59 <linduxed> glguy: yeah, fromInteger worked!
11:11:42 * hackagebot hashable 1.2.0.5 - A class for types that can be converted to a hash value  http://hackage.haskell.org/package/hashable-1.2.0.5 (JohanTibell)
11:14:15 <applicative> aluink: I suppose you know but there is also #yesod
11:15:30 <applicative> ah luite has said this
11:16:27 <aluink> applicative: yeah, i'm there now. thanks all!
11:19:05 <vpetro> o
11:20:56 <luqui> Anyone know of a good purely functional union-find.  It doesn't have to have the same efficiency as the ephemeral one, just decent...
11:26:42 * hackagebot HLearn-algebra 0.1.2.0 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-0.1.2.0 (MikeIzbicki)
11:26:44 * hackagebot HLearn-distributions 0.2.2 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-0.2.2 (MikeIzbicki)
11:31:43 * hackagebot HLearn-algebra 0.1.2.1 - Algebraic foundation for homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-0.1.2.1 (MikeIzbicki)
11:31:45 * hackagebot HLearn-distributions 0.2.2.1 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-0.2.2.1 (MikeIzbicki)
11:35:51 <glguy> luqui: I did some union/find stuff 4 years ago, and I haven't really touched it since, but it might be a starting point: https://github.com/glguy/punionfind
11:36:20 <glguy> I explored a few implementations
11:42:41 <applicative> luite I see, were you reading this guy who does union find faster in ruby http://architects.dzone.com/articles/haskell-impressively-non
11:43:59 <c_wraith> union-find's algorithms are particularly unsuited to haskell.
11:44:46 <c_wraith> like, ridiculously unsuited.
11:45:01 <hpaste> applicative pasted “union findy” at http://hpaste.org/80619
11:45:05 <applicative> c_wraith: probably but this is curious for a number of reasons.
11:45:49 <c_wraith> that's a lot of code
11:47:37 <applicative> his stuff is just the beginning. I cut and pasted the bit of the deprecated version of the array library that he's using
11:48:11 <applicative> his is lines 50 - 150 or something
11:48:17 <c_wraith> DiffArray was removed because it's *slow*
11:49:36 <applicative> yes, but a blog article using it and entitled "Haskell: An Impressively Non-Performant Union Find" is a bit off the way
11:49:38 <applicative> wall
11:50:12 <elliott> is this another "I wrote a slow program in Haskell, it must suck" post
11:50:56 <c_wraith> elliott: not exactly.  It's *really* hard to make union-find not suck in haskell.  union-find is based on all kinds of crazy mutation
11:51:05 <elliott> yeah
11:51:10 <thoughtpolice> elliott: no he doesn't really bash anything. at the end he just concludes "maybe array's aren't the best in haskell?"
11:51:22 <applicative> arrays are the best in haskell !!
11:51:23 <elliott> fair enough
11:52:11 <hpaste> pancho pasted “Type contraints” at http://hpaste.org/80620
11:53:44 <pancho> Hi guys, very newbie question, what's the difference or what's the advantage of using type constraints to declare a function? Like case 1 vs. case 2 in http://hpaste.org/80620
11:54:10 <earthy> http://research.microsoft.com/en-us/um/people/crusso/ml2007/slides/puf-wml07-slides.pdf describes a good union-find
11:54:17 <thoughtpolice> c_wraith: there are some papers about implementing an efficient mutating union-find and wrapping it in a purely functional interface, IIRC. maybe that would be something worth putting on hackage
11:54:21 <Clint> pancho: the types you can use the function with
11:55:24 <pancho> Clint, Thank you!
11:56:00 <bmxx> is there a way to do this without a lambda?  withFile "foo.txt" ReadMode $ \h -> hGetLine h
11:56:26 <ClaudiusMaximus> @pl \h -> hGetLine h
11:56:26 <lambdabot> hGetLine
11:56:35 <applicative> I wonder if the ruby union find program is polymorphic ...
11:56:37 <bmxx> w00t
11:56:43 * hackagebot MFlow 0.2.0.3 - Web app server for stateful processes with safe, composable user interfaces.  http://hackage.haskell.org/package/MFlow-0.2.0.3 (AlbertoCorona)
11:56:49 <bmxx> haha
11:57:05 <bmxx> that was silly of me
11:57:09 <applicative> pancho, the second is better :)
11:57:13 <ClaudiusMaximus> @pl a b c $ d
11:57:13 <lambdabot> a b c d
11:57:30 <napping> thoughtpolice: isn't that the one persistent-equivalence on hackage implements?
11:57:35 <applicative> pancho: the type Int -> Int is better in some such cases, but not in that one of course.
11:58:44 <int-e> earthy: they use Baker arrays, is there any crucial difference to Haskell's implementation of diffarrays?
11:59:04 <newsham> http://www.thenewsh.com/~newsham/x/machine/questions/questions2.hs
11:59:26 <newsham> any suggestions on making it simpler?  especially on getting some of the IO out of the logic...
11:59:48 <earthy> int-e: no clue
11:59:53 <earthy> I've not read the thing ;)
12:00:06 <pancho> applicative, I think I get it, it's like if you use a declaration as in the second case you'd only use Integers, while if you use the first case (With a type constraint), you will be able to use all the types that belong to the same typeclass, right?
12:00:22 <shachaf> newsham: Sounds like you can use a free monad!
12:00:34 <shachaf> ...Or maybe something simpler here.
12:00:44 <newsham> shachaf: i had a coupon somewhere.. but i misplaced it
12:00:54 <applicative> yes, you are restriced by the 'concrete type'  to using it with Integer, not Int and whatever Integral type you come by.  But this means the type checker has more information
12:01:10 <int-e> earthy: The title has fooled me a couple of times now - I see it, get excited, then realise that essentially (as far as I understand, hence the question) they build union-find on diffarrays, and get disappointed.
12:01:33 <bmxx> can I assign a global variable to a value from IO ?
12:01:39 <applicative> pancho: but if you are always using it at Int then you would need another type.  Actually making the input Int, and output Integer is not unreasonable, but it would need fromIntegral somewhere
12:01:45 * hackagebot idna 0.2 - Implements IDNA (RFC 3490).  http://hackage.haskell.org/package/idna-0.2 (GeorgePollard)
12:01:47 <newsham> bmxx: IORefs
12:02:25 <newsham> bmxx: to make a global one, you'd need 'unsafePerformIO' too...
12:02:40 <shachaf> newsham: Hmm, let me see what that would mean in this case.
12:02:46 <applicative> main = do {ref <- newIORef 0; ... x <- readIORef ref
12:03:04 <newsham> shachaf: thank you
12:03:11 <earthy> int-e: well, the trick here is that essentially they write on top of MArray, but have proven the mutability-handling correct using Coq
12:03:32 <pancho> applicative, Thank you very much
12:05:59 <napping> I was a bit surprised that you can write classes like class (Ctx (F a)) => C a where type F a :: *
12:06:08 <parcs> http://www.youtube.com/watch?v=YScIPA8RbVE great talk
12:06:47 <bmxx> newsham nothing that's immutable? I don't really need mutability
12:07:25 <NemesisD> how do i convert a char to a word8
12:07:44 <newsham> bmxx: i'm not sure i understand.  you want to "assign" something to a global name and also have it immutable?
12:07:55 <c_wraith> napping: it doesn't actually do anything Type Families doesn't allow without that syntax - it just makes it easier to do, and warns if you forget to make a type instance for a type
12:08:02 <parcs> NemesisD: you can convert a char to an int with Data.Char.ord
12:08:03 <newsham> perhaps you should explain more what you want.. i think i misunderstood
12:08:13 <parcs> NemesisD: then you can convert the int to a word8 if you want
12:08:22 <napping> Char is unicode, might not be what you want
12:08:55 <NemesisD> parcs: how do i convert the int to a word8 though
12:09:01 <napping> c_wraith: I guess so, I was just a bit surprised it would be in scope there already
12:09:07 <bmxx> newsham immutable variables have to be assigned initially too (or initialized)
12:09:21 <bmxx> so yes that's what I want
12:09:25 <napping> or rather that that's considered a sufficiently well-founded definition to not get any more complaint than FlexibleContexts
12:09:45 <c_wraith> napping: ah, yeah, that is strange if you don't know how associated types desugar
12:09:49 <newsham> bmxx: if you write a program in the Reader monad all the code will have access to some immutable state thats been passed in
12:10:09 <newsham> bmxx: could you explain what you're doing?
12:10:40 <newsham> bmxx: is there a reason you dont want to just have a top level definition like "magic = 42" ?
12:10:57 <bmxx> yes. I don't want to hard code it but read it from a config file instead
12:11:04 <bmxx> not possible?
12:11:17 <newsham> bmxx: you can use "unsafePerformIO" to read it from a config file
12:11:46 <newsham> ie:   "magic = read $ unsafePerformIO $ readFile "/etc/magic.txt""
12:11:59 <bmxx> ah so it's possible without IORef
12:12:31 <bmxx> wait, that's just a function?
12:12:33 <newsham> you're basically telling the compiler that you're cheating and using IO as if it was a pure function and you promise that nothing bad will happen as a result
12:13:00 <newsham> ?type unsafePerformIO
12:13:03 <lambdabot> Not in scope: `unsafePerformIO'
12:13:17 <zzzzzbogus> http://maxim.livejournal.com/392587.html - Warp/Yesod vs Erlang Cowboy/Nitrogen vs Ocaml. Erlang and Ocaml win so benchmark is probably broken ;-)
12:13:24 <newsham> ?hoogle unsafePerformIO
12:13:24 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
12:13:24 <lambdabot> Foreign unsafePerformIO :: IO a -> a
12:13:26 <bmxx> :t read $ unsafePerformIO $ readFile "/etc/magic.txt"
12:13:27 <lambdabot> Not in scope: `unsafePerformIO'
12:14:10 <bmxx> the type is IO String I guess?  what I was asking is, can I have it be of String type?  assigned at runtime
12:14:18 <bmxx> not IO String
12:14:34 <bmxx> basically I want a global <-.  magic <- read $ ...
12:14:34 <napping> bmxx: if you do that, you also have to take care the calculation is not duplicated
12:14:41 <newsham> unsafePerformIO will take the "IO String" program and run it and get the String. and make pretend it was pure
12:15:21 <napping> which can include the compiler deciding it looks more efficient to recompute the value from the original definition (i.e. re-execute the read) every time it's used
12:15:59 <bmxx> I see.  so it's IO a -> a. I didn't even know such a function exists
12:16:20 <napping> Would it be too much trouble to pass the information around some other way? If you've already got a monad you could toss it in there
12:16:21 <bmxx> are there any issues I could encounter by using it like this
12:16:34 <bmxx> name is pretty threatening
12:16:48 <c_wraith> bmxx: if you don't put a NOINLINE pragma on the declaration, there are potential issues
12:16:53 <newsham> its a dirty function which should not be used without great care
12:17:00 <newsham> but it turns out to be useful in this kind of situation
12:17:12 <newsham> (even though you can probably still avoid using it if you tried harder :)
12:17:18 <napping> Pity we don't have parameterized modules
12:17:22 <c_wraith> bmxx: like, if it gets inlined, and it's loaded multiple times, and the config is changed
12:17:49 <bmxx> nasty :)
12:18:52 <napping> you might also be interested in the configurator package
12:18:57 <bmxx> seems like docs discourage it's use for things with sideffects. "For this to be safe, the IO computation should be free of side effects and independent of its environment. "
12:19:13 <c_wraith> That's for it to be 100% safe.
12:19:54 <napping> It doesn't help with this sort of threading stuff, but it does include various nifty things like a config file parser and inotify to inform you if it changes
12:20:34 <bmxx> napping sounds useful I'll check it out
12:27:47 <Lethalman> elliott, are you the one here? http://conal.net/papers/push-pull-frp/
12:28:12 <elliott> nope, he goes by conal on IRC
12:28:20 <Lethalman> ok :)
12:29:03 <newsham> bmxx: if /etc/magic.txt never changes and barring any filesystem errors, its pretty much a pure function..
12:29:48 <Rileld> I'm trying to install fsnotify, but cabal encounters compile errors. It seems that the time package fails to install. Why would this happen?
12:29:51 <hpaste> Rileld pasted “fsnotify install errors” at http://hpaste.org/80623
12:33:47 <parcs> NemesisD: fromIntegral
12:35:06 <monochrom> time comes with GHC, you should not need to rebuild it
12:37:08 <monochrom> and directory too
12:37:35 <monochrom> therefore, if cabal-install wants to rebuild them, your existing time is being shadowed by garbage
12:37:55 <Rileld> monochrom: what does "shadowed by garbage" mean?
12:38:24 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml#pigeon . in fact, see the whole thing
12:40:45 <bmxx> newsham yeah true
12:41:06 <Lethalman> :t trace
12:41:08 <lambdabot> Not in scope: `trace'
12:42:54 <DanielDiaz> if you are interested in shortest-path searches in a graph, what library would you use?
12:43:38 <Lethalman> in a source tarball i'm using runghc Setup.hs build and Debug.Trace for development, is there a better workflow?
12:51:04 <luxurymode> so in a type signature like, say, (==) :: (Eq a) => a -> a -> Bool  does the type variable a mean that both operands are necessarily of type a? trying to figure out if the type signature necessarily implies that both types are the same (or polymorphically so)
12:51:23 <luite> yes
12:53:21 <luxurymode> thanks luite. i guess it was a silly question. Just wanted to be sure that I was understanding correctly that the type variable always has the same meaning throughout the signature, though I suppose that's a rather silly question
12:53:59 <monochrom> it is like highschool algebra. x+x vs x+y
12:54:28 <b__> join #haskell-blah
12:54:48 <b__> die telephone die
12:54:58 <Rileld> monochrom: the cabal package requires time >= 1.4, but my ghc has time 1.2.0.3. How do I update time?
12:55:13 <monochrom> use a newer ghc
12:55:26 <monochrom> or an older fsnotify
12:55:31 <Lethalman> so I'm trying to figure out why haskell-gi is dead...... anybody knows a possible reason? trying to contact the authors in the meanwhile
12:55:47 <monochrom> or modify fsnotify to not require 1.4
12:55:53 <hpaste> “David ” pasted “ElementaryCounting” at http://hpaste.org/80627
12:56:05 <david1991> Hey, I have a question
12:56:29 <david1991> I've read that we could write functions with unlimited / unspecified amount of arguments in Haskell
12:56:37 <david1991> http://hpaste.org/80627
12:56:45 <geekosaur> you can but it's tricky
12:56:58 <david1991> yes, I have found a website explaining it
12:57:16 <david1991> http://stackoverflow.com/questions/3467279/how-to-create-a-polyvariadic-haskell-function
12:57:40 <david1991> here, so I thought maybe I can write a function that counts it arguments
12:57:44 <shachaf> david1991: You can't define instance CountArg a because it overlaps with your other instance.
12:58:08 <david1991> oh indeed... alright
12:58:21 <monochrom> count f = 1 + count (f undefined)
12:58:25 <david1991> well that can be fixed by putting it in context
12:58:37 <david1991> however, I have now th problem of what to do with ?????
12:58:44 <shachaf> You can do what monochrom said.
12:58:49 <Rileld> monochrom: Ok, I was using the haskell platform, but I guess I'll have to download and build a newer version of ghc.
12:58:50 <dawesbr> hey everyone, just had a functional programming exam in haskell, there was one part to a question I couldn't get, anyone want to give it a quick shot?
12:58:53 <shachaf> If you wanted to be a bit nicer about it, you could use Proxy.
12:59:31 <david1991> why would I use the undefined function?
12:59:45 <david1991> it doesn't fully makes sense to me I'm sorry :(
12:59:59 <monochrom> because "count _ = 0" in the base case
13:00:11 <Cale> dawesbr: sure
13:00:28 <david1991> yes, that I understand
13:00:37 <shachaf> Oh, maybe Proxy isn't right here.
13:01:07 <dawesbr> Given the function interleave (x:xs) (y:ys) = x:y:interleave xs ys, using the function interleaveList = foldr interleave [], define a function allpairs, which computes the cartesian product of two lists, each of which may be finite or infinite
13:01:24 <Rileld> Has anyone used this to install haskell: http://www.justhub.org/? Did it work well for you?
13:02:04 <dawesbr> (interleaveList takes a list of lists and returns a single list containing all elements from all lists in the list, such that each element of each input list is in some finite initial section of the result)
13:02:04 <monochrom> Rileld: "the"? ok, Haskell Platform has been at 2012.4.0.0 for a while and its ghc is 7.4.2 and its time is 1.4 and it's what I use now
13:02:09 <Cale> david1991: undefined is the only thing which belongs to every type, so if you don't know what type the parameter is, you kind of have to use it
13:03:46 <tazz> hello
13:03:47 <Rileld> monochrom: I'm on Fedora 17. I'm not sure how this stuff works, but my ghc is 7.0.4
13:04:10 <david1991> It still doesn't entirely work, since it now still says if I try count 4 3 2 1, that I have too many parameters
13:04:11 <david1991> http://pastebin.com/0qh3X27A
13:04:15 <monochrom> then either use a newer Fedora (if that make a difference) or don't use Fedora's GHC
13:04:15 <mauke> The paste 0qh3X27A has been copied to http://hpaste.org/80629
13:04:30 <monochrom> or what I said about older fsnotify or modifying fsnotify
13:05:22 <david1991> I can't see why it doesn't accept "more parameters" other than one... :(
13:05:54 <Rileld> monochrom: The older fsnotify's all depend on time 1.4, so I'll either try to modify the package, or update ghc
13:07:18 <monochrom> david1991, explain to me what "count 4 3 2 1" means and what's your logic
13:08:25 <monochrom> I was under the wrong impression that you just wanted "count True = 0" and "count not = 1" and "count (&&) = 2" etc
13:08:51 * Lethalman just felt smart on replacing $ with =<< :S thanks to all the noise in this channel :P
13:08:53 <david1991> well count 4 3 2 1, means that count is applied to 4, 3, 2 and 1... so the number of arguments are 4
13:09:19 <david1991> count 4 "test" "b" "c" should also return 4
13:09:33 <david1991> I just wanted to count the arguments, since it's kind of a variation on what I showed on StackOverflow
13:09:40 <aluink> @type (+) . (+ 1)
13:09:41 <lambdabot> Num a => a -> a -> a
13:09:43 <david1991> at least that's what I think...
13:09:45 <c_wraith> david1991: what would the type of this function be?
13:10:01 <aluink> @type (.)
13:10:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:10:11 <monochrom> then "count :: a -> Int" is wrong
13:10:13 <david1991> the count function you mean?
13:10:15 <Mortchek> I'm trying to understand Applicative. Is there some type that is a Functor for which there is no reasonable Applicative instance?
13:10:16 <c_wraith> yes
13:10:30 <david1991> how come it's wrong?
13:10:39 <david1991> I want to have a Int at the end right?
13:10:39 <c_wraith> that type says it has one argument
13:10:41 <monochrom> @type printf
13:10:42 <lambdabot> PrintfType r => String -> r
13:11:23 <david1991> icic so I can't say in the beginning that I want to end, since I have an undefined "between" value, is that what you guys are saying? (http://stackoverflow.com/questions/3467279/how-to-create-a-polyvariadic-haskell-function; I noticed there is no "end" type defined here too!)
13:14:01 <michaeltbaker> Hi, I'm trying implement Traversable for a new datatype, which I've done. But I want to use mapM_ with it, which does not work. What am I missing?
13:14:04 <aluink> can someone explain to my why the following type is what it is
13:14:11 <aluink> @type (.) (+)
13:14:12 <lambdabot> (Functor f, Num a) => f a -> f (a -> a)
13:14:20 <aluink> aghh, not that (.)
13:14:42 <shachaf> @ty (Prelude..) (+)
13:14:43 <lambdabot> Num b => (a -> b) -> a -> b -> b
13:14:46 <aluink> @type (Prelude.) (+)
13:14:47 <lambdabot> Not in scope: data constructor `Prelude'
13:14:48 <aluink> yes, that one
13:15:14 <aluink> the first argument to (Prelude..) is (a -> b)
13:15:33 <aluink> i'm guessing this is something related to currying that I don't understand
13:15:39 <Lethalman> aluink, because (.) wants two functions
13:15:50 <Lethalman> so you are partial applying it to (+)
13:15:59 <Lethalman> :t (Prelude..)
13:16:00 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:16:02 <fmap> @ty (Prelude..) `asAppliedTo` (+)
13:16:03 <lambdabot> Num b => (b -> b -> b) -> (a -> b) -> a -> b -> b
13:16:04 <napping> michaeltbaker: sounds like you are getting Control.Monad.mapM_ rather than Data.Foldable.mapM_
13:16:38 <Lethalman> and (+) wants two arguments instead of 1 :S
13:17:29 <aluink> right, i just don't understand how handing something of type (a -> a -> a) as a first argument to something that wants (a -> b) works
13:17:40 <Mortchek> What (+) returns is a value of type a -> a
13:17:53 <michaeltbaker> napping: Perfect. Thank you.
13:18:12 <aluink> Mortchek: ok, let me think on taht
13:18:30 <shachaf> @where hackage-mirror
13:18:30 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
13:18:47 <fmap> aluink: `(a -> a -> a)' is `(a -> (a -> a))'
13:18:54 <ion> z -> z -> z is the same as z -> (z -> z). If a -> b ~ z -> (z -> z) then a ~ z and b ~ z -> z.
13:19:33 <aluink> ion, ahh
13:19:59 <Mortchek> ion, how do you pronounce "~" there?
13:20:50 <sm> hdiff.luite.com is fantastic
13:21:22 <monochrom> "equal"
13:21:58 <ion> Haskell uses ~ for type equality constraints.
13:22:07 <Mortchek> Ah, okay.
13:22:11 <shachaf> GHC does, anyway.
13:22:15 <ion> Verily.
13:22:38 <aluink> @type (Prelude..)
13:22:39 <lambdabot> (b -> c) -> (a -> b) -> a -> c
13:22:50 <monochrom> because one day, they may want to use "=" as a type operator that does not mean "equal"
13:23:16 <Mortchek> @type (Prelude.+)
13:23:18 <lambdabot> Num a => a -> a -> a
13:23:42 <Mortchek> aluink, so b ~ a and c ~ a -> a in this case
13:24:11 <aluink> Mortchek: yep, that makes sense now
13:24:17 <ion> martchek: That is just confusing because the ‘a’s aren’t the same. :-P
13:24:23 <ion> @type ((Prelude..), (+))
13:24:24 <lambdabot> Num a1 => ((b -> c) -> (a -> b) -> a -> c, a1 -> a1 -> a1)
13:24:37 <aluink> i never thought of substituting a for (a -> a)
13:24:41 <aluink> it makes sense now!
13:24:42 <aluink> thanks all1
13:24:47 <aluink> all!*
13:25:15 <nus> @ty id
13:25:16 <lambdabot> a -> a
13:25:19 <nus> @ty flip id
13:25:20 <lambdabot> b -> (b -> c) -> c
13:26:27 <dgpratt> @src ap
13:26:27 <lambdabot> ap = liftM2 id
13:26:38 <dgpratt> that one broke my brain for a long while
13:26:59 <Mortchek> @src liftM2
13:26:59 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:27:24 <ion> > Just length <*> Just "foo"
13:27:25 <lambdabot>   Just 3
13:28:03 <Mortchek> @src liftM
13:28:03 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:31:25 <frerich> Hm, pity that the Foldable class doesn't also come with an 'unfold' function.
13:32:10 <c_wraith> Now I'm trying to come up with examples of things that can be folded but not unfolded
13:32:14 <tdammers> does anyone has any clue why cabal-dev upload hangs for me?
13:32:20 <parcs> @where zipper
13:32:20 <lambdabot> http://www.haskell.org/haskellwiki/Zipper
13:32:21 <tdammers> s/has/have
13:32:44 <parcs> what's the proper definition of a list zipper?
13:33:03 <parcs> data Zipper a = Zipper [a] a [a] or Zipper [a] (Maybe a) [a] ?
13:33:44 <Mortchek> Why doesn't Functor have a method for lifting things into the Functor? Is there some Functor where you can't do this?
13:34:02 <ion> If you want to allow an empty zipper, perhaps just Zipper a = Zipper [a] [a]
13:34:19 <croikle> tdammers: perhaps hackage is down
13:35:05 <tdammers> yep, apparently so
13:35:37 <absence> is there a shortcut syntax for (Monoid a, Monoid b) => ... ?
13:35:51 <hpc> absence: no
13:36:19 <absence> ok, thanks
13:36:25 <napping> Mortchek: Const is a functor
13:36:58 <hpc> absence: if it's a more complex constraint that you repeat often, you might be able to use ConstraintKinds
13:37:03 <glguy> hackage'll be restarted in a few minutes
13:37:12 <tdammers> that would be nice
13:37:14 <bgamari> oh man
13:37:36 <hpc> type BigConstraint k m s w r a b = (Monoid a, MonadWriter (m s) b, Monoid b, ...)
13:37:46 <bgamari> what an awful dependency conflict: statistics -> monad-par -> monad-par-extras -> cereal -> old bytestring
13:37:56 <Mortchek> napping, why doesn't it make sense to do that with Const?
13:38:04 * bgamari hasn't the slightest idea why monad-par depends upon monad-par-extras
13:38:22 <napping> a -> Const x a would have to invent an x
13:38:25 <absence> hpc: good to know :)
13:38:29 <bgamari> or for that matter, why any of these are using cereal and not binary
13:38:55 <glguy> cereal has better error handling behavior, for one
13:39:26 <parcs> up until recently, cereal was more powerful than binary. ie it had Generics support and incremental parsing
13:39:33 <jesyspa> I've got a bunch of state I'd like to keep track of.  I know some parts of my program will only need a subset of that state, but will still need to be able to modify it.  Can this be done elegantly?  I have something like this now, but it's not robust at all:
13:39:35 <hpaste> jesyspa pasted “Ugly state” at http://hpaste.org/80631
13:40:29 <Mortchek> napping, okay, I think I see that. Thanks.
13:41:06 <napping> Mortchek: you might want Applicative, if you haven't seen that
13:41:09 <bgamari> glguy, parcs, but binary is the GHC blessed package, yes?
13:41:23 <napping> "Pointed" would just have pure, but I don't think it has much use alone
13:41:37 <Mortchek> napping, I'm asking specifically because of Applicative. I wanted to understand why all Functors couldn't be Applicative.
13:41:51 <glguy> bgamari: So is filepath, but you won't use that for over cereal, either
13:42:14 <Lethalman> I have a tree structure, all with different types etc.
13:42:27 <napping> what about examples with pure but no sensible <$>?
13:42:30 <Lethalman> now if some condition met on a leaf, I have to remove the whole branch
13:42:34 <napping> <*>, rather
13:42:38 <Lethalman> any hints on doing this?
13:42:47 <Mortchek> napping, that'd be a good next step. Know of any?
13:43:10 <bgamari> glguy, anyways, now that they are nearly equivalent, it would be nice if we could move to one (which seems to be binary)
13:43:14 <Lethalman> that is removing all nodes from the leaf toward the top (except the root)
13:43:30 <bgamari> tibbe, Are there any plans to improve error handling in binary?
13:43:37 <Lethalman> should I look at Data.Traversable?
13:43:51 <bgamari> tibbe, the type of decode is a bit scary
13:43:54 <tibbe> bgamari: we already did a bit, it now actually returns Either instead of calling error
13:44:06 <bgamari> tibbe, Has that been released yet?
13:44:35 * bgamari could have sworn that it was FilePath -> a when he ported his cereal code a few weeks ago
13:45:26 <napping> it seems a bit silly to throw away values if you're doing the zipping version for lists, but I haven't checked much
13:46:14 <saml> case of x  {  Just foo -> f foo ;   Nothing -> defaultVal }    is there shortcut for this?
13:46:15 <tibbe> bgamari: hack age is acting up
13:46:21 <tibbe> bgamari: FilePath!?!?
13:46:24 <glguy> :t maybe
13:46:25 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:46:28 <saml> f <$> x <*> defaultVal ?
13:46:40 <tibbe> bgamari: Are you think of Data.Binary or Data.Binary.Get?
13:46:41 <glguy> hackage is currently running fsck and will be back when that's done
13:47:13 <saml> glguy, thanks
13:47:36 <NemesisD> hey guys, i'm trying to figure out what the best idiom for my library. say I have the concept of a CategoryName, its basically a string but in the interest of not wanting to mix up a CategoryName from other stringish type, i wanna do newtype CategoryName = CategoryName { categoryName :: String }
13:47:54 <NemesisD> is that the idomatic way to do it, or is newtype CategoryName = CategoryName String more common?
13:48:19 <napping> If pure makes distinguishable values, it seems like most of the laws are hard to break
13:48:33 <NemesisD> i lean towards the one with the explicit field because manipulating the string component would just be a matter of composing with categoryName
13:48:48 <frerich> Hm, 'sortBy (comparing fat) [(1,0),(2,1),(2,0),(1,1)]' gives '[(1,0),(1,1),(2,1),(2,0)]'. I'd like to sort the list first by 'fst' and then (as the "secondary criterion") by 'snd', so that I get [(1,0),(1,1),(2,0),(2,1)]. Does anybody know a nice way to do this? I seem to recall one could (&&&) for this somehow.
13:48:55 <frerich> s/fat/fst/
13:49:14 <tibbe> bgamari: I think we only expanded the API of Data.Binary.Get
13:49:29 <hpc> frerich: if you have the right instances in scope, sortBy (comparing fst <|> comparing snd)
13:49:32 <hpc> i think
13:49:37 <hpc> :t sortBy (comparing fst <|> comparing snd)
13:49:38 <lambdabot> (Ord a1, Ord a, Alternative ((->) (a, a1))) => [(a, a1)] -> [(a, a1)]
13:49:56 <hpc> > sortBy (comparing fst <|> comparing snd) [(1,0),(2,1),(2,0),(1,1)]
13:49:57 <lambdabot>   No instance for (Control.Applicative.Alternative ((->) (a0, a1)))
13:49:58 <lambdabot>    arisin...
13:50:04 <stepkut> shapr: so, the HaLVM people said that it would make for a good guide to follow, but doing an ARM port would basically require reimplementing at least 2/3s  of HalVM for ARM..since most of the code there is x86 stuff -- like the boot loader, drivers, etc
13:50:22 <glguy> frerich: That's the default instance for Ord (a,b)
13:50:25 <glguy> so just use sort
13:50:41 <hpc> glguy: i thought it was snd first
13:50:53 <kylcarte> NemesisD: using the record syntax gives you the deconstructor for free, so I'd go with that. You could still use CategoryName as a constructor (ie. CategoryName "foo" :: CategoryName)
13:50:56 <glguy> hpc: nope
13:51:05 <hpc> oh cool
13:51:11 <hpc> just as well because my solution was crap ;)
13:51:21 <frerich> glguy: Ah yeah, but I was wondering whether there's a more generic solution (say, if I have a custom data type with two fields instead of '(Int,Int)')
13:51:24 <`^_^v> is there a shorthand for this type of construct? filter (\x -> case x of Just _ -> True; Nothing -> False)
13:51:35 <Nereid> filter isJust
13:51:45 <hpc> :t catMaybes
13:51:46 <lambdabot> [Maybe a] -> [a]
13:51:48 <`^_^v> with a custom non-maybe type
13:51:49 <etrepum> does hackage have mirrors? seems to be down
13:51:49 <Nereid> that too
13:51:51 <glguy> :t :t comparing fst <> comparing snd
13:51:52 <lambdabot> parse error on input `:'
13:51:56 <glguy> :t comparing fst <> comparing snd
13:51:57 <lambdabot> (Ord a1, Ord a) => (a, a1) -> (a, a1) -> Ordering
13:51:58 <NemesisD> kylcarte: cool, thanks. and i justified in wanting to differentiate types like that? is that a common thing/something most people like?
13:52:03 <frerich> hpc: Crap? I never saw <|> before, but I thought the code looks kinda neat :-) Somebody (quicksilver?) whipped up something nice with (&&&) a while ago, but I forgot how that worked :-/
13:52:05 <hpc> glguy: dammit that's what it was
13:52:35 <hpc> frerich: it's a method of the Alternative typeclass; glguy got it with Monoid, or just use plain old sort
13:52:36 <Nereid> `^_^v: I bet there's a lensy/prismy way of doing it, but otherwise not really.
13:52:49 <kylcarte> sure, especially if you want to write some class instances on that type.
13:52:57 <Nereid> :t _just
13:52:58 <lambdabot> (Applicative f, Prismatic k) => k (a -> f b) (Maybe a -> f (Maybe b))
13:53:00 <glguy> `^_^v: filter isJust
13:53:20 <hpc> frerich: there's a neat Monoid instance for Ordering, where Eq ++ x = x, x ++ _ = x
13:53:27 <hpc> > LT ++ GT
13:53:29 <lambdabot>  Terminated
13:53:31 <hpc> > LT ++ GT
13:53:33 <lambdabot>   LT
13:53:40 <hpc> > EQ ++ GT
13:53:42 <lambdabot>   GT
13:53:45 <Lethalman> any hints please? :P I have a treeish structure, and I want to remove entire branches depending on a condition on a leaf
13:53:55 <Lethalman> that is, starting from a leaf, remove branches upwards
13:53:59 <hpc> frerich: and the monoid instance for functions "carries the ordering monoid over"
13:53:59 <saml> maybe defaultVal id someMaybe   -- is there shortcut for it?
13:54:02 <hpc> to put it very casually
13:54:12 <Nereid> Lethalman: do you have a concrete example?
13:54:14 <hpc> :t fromMaybe
13:54:15 <lambdabot> a -> Maybe a -> a
13:54:23 <saml> hpc, thansk
13:54:27 <Lethalman> Nereid, I'm trying to fix haskell-gi, so no :P
13:54:32 <hpc> @where hoogle
13:54:32 <lambdabot> http://haskell.org/hoogle
13:54:35 <Lethalman> Nereid, i'll explain the problem
13:54:53 <Nereid> hackage down?
13:55:01 <hpc> Nereid: it's restarting
13:55:05 <Nereid> ok
13:55:19 <Lethalman> Nereid, the tree here is something like Namespace (Class (Function (Arg (Type...)))) so you have many classes with many functions and many args with a type
13:55:54 <Lethalman> the condition is: if the type of this arg is non-existant, delete the whole function
13:56:32 <Lethalman> and since the type refers to a node in the same tree, I have to find the fixed point
13:56:41 <Nereid> > sequence [Just 1, Just 2]
13:56:42 <lambdabot>   Just [1,2]
13:56:44 <Nereid> > sequence [Just 1, Nothing]
13:56:45 <lambdabot>   Nothing
13:56:55 <Nereid> sounds kinda like this.
13:57:05 <Nereid> uh
13:57:06 <Nereid> hmm
13:57:16 <Lethalman> Nereid, talking to me?
13:57:18 <Nereid> yeah
13:57:24 <bgamari> tibbe, Data.Binary
13:57:27 <Lethalman> what's the point of that?
13:57:37 <bgamari> tibbe, Perhaps I was wrong on the count of FilePath
13:57:38 <Nereid> I don't konw.
13:57:48 <Lethalman> :S
13:57:58 <bgamari> unfortunately hackage is down so I'm powerless to find out
13:58:01 <tibbe> bgamari: you might be right, we didn't review Data.Binary
13:58:08 <kylcarte> NemesisD: that's precisely what it's intended for. You have a new type, it comes without any of the class instances predefined on the base type, so you can decide exactly how it behaves
13:58:14 <Lethalman> I was thinking of traverse to remove the branches, then finding the fixed point
13:59:11 <bgamari> binary isn't in the platform?
13:59:33 <frerich> hpc: Ah, the Monoid instance helps indeed, how crazy. I can do 'sortBy (mconcat [comparing fat, comparing snd])'
13:59:35 <Clint> binary's in the platform
13:59:38 <NemesisD> oh no hackage is down
13:59:44 <frerich> hpc: This is the generalization I was looking for!
13:59:53 <Clint> http://people.debian.org/~nomeata/platform.html
14:00:05 <Clint> or maybe it isn't
14:01:46 <hpc> frerich: :D
14:02:10 <hpc> frerich: i did something similar in perl by exploiting the "truthiness" of -1 and using (||)
14:02:16 <frerich> hpc: I wonder how anybody is supposed to figure that out… I only just found it in the haskell-cafe archive.
14:03:42 <frerich> hpc: And you can toggle the order of a criterion using 'flip', heh.
14:03:56 <frerich> Like 'mconcat [comparing fst, flip $ comparing snd]'
14:05:07 <hpc> frerich: another fun one is comparing things that would not normally be compared
14:06:06 <hpc> sortBy (comparing (== "0000-00-00")) -- sort an sql non-date to the top
14:06:42 <hpc> using the Ord instance for Bool
14:09:21 <Lethalman> mh no I can't use Traversable I think, because it needs a type parameter
14:09:39 <hrumph> hi
14:09:44 <hrumph> what happened to hackage?
14:10:08 <bgamari> hrumph, It's down again
14:10:19 <hrumph> when is going to not be down?
14:10:29 <glguy> real soon now
14:10:48 <int-e> it was up earlier today
14:11:03 <bgamari> does anyone understand the root cause of these outages?
14:11:05 <Heffalump> it's being rebooted at the moment
14:11:09 <Lethalman> @hoogle (t -> t) -> t -> t
14:11:09 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
14:11:10 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
14:11:10 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
14:11:27 <Heffalump> http://community.galois.com/pipermail/haskell-infrastructure/2013-January/000496.html
14:11:51 <bgamari> Hafydd, Ouch, that looks ugly
14:15:16 <frerich> hpc: I think this is so obscure, some little "sortByMany = sortBy . mconcat" would be nice in Data.List or so.
14:15:30 <ThrIce> I wanted to create a function that takes a list of Integers and returns an Int : this is what i did (i also did a recursive function that uses multiplication and addition to accomplish the samelet dec2int lst = read $ foldl (++) [] $ map (show) lst :: Integer
14:15:40 <ThrIce> let dec2int lst = read $ foldl (++) [] $ map (show) lst :: Integer
14:15:45 <ThrIce> sorry, that was the function
14:15:50 <hpc> frerich: it's not horribly obscure, but maybe a tiny package of sorting combinators would do the trick?
14:15:59 <hpc> hackage is down or i would see if one exists
14:16:22 <ThrIce> now there is the requirement too use "foldl and function composition"… Anyone got any ideas?
14:16:24 <frerich> hpc: It would certainly be interesting to me, and judging from the thread at http://www.haskell.org/pipermail/haskell-cafe/2008-December/052234.html some other people feel the same.
14:16:28 <ThrIce> to* use
14:17:01 <Lethalman> @hoogle (forall t1. t1 -> t1) -> t -> t
14:17:01 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
14:17:01 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
14:17:01 <lambdabot> Data.Data gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a
14:17:13 <frerich> hpc: Some things like Monoid are so crazy abstract that it would've never occurred to me they would be useful for such a problem
14:17:21 <Lethalman> mh maybe this Data.Data stuff
14:17:38 <Enigmagic> Lethalman: what are you trying to do?
14:18:05 <Lethalman> Enigmagic, I have a tree that has different types, and I'd like to remove some branches recursively based on certain conditions
14:18:19 <Lethalman> Enigmagic, the tree is not polymorphic
14:18:24 <hpc> frerich: a quick google search for "sorting combinators" gave nothing, so... https://github.com/headprogrammingczar/search-combinators
14:20:10 <Lethalman> like data T1 = T1 String [T2]; data T2 = T2 [T3]; data T3 = T3 String String
14:20:30 <frerich> hpc: yay :-)
14:21:31 <Enigmagic> Lethalman: well you're not going to get a function like (forall t1. t1 -> t1) -> t1 -> t1 that is very useful for that. the Data/Typeable approach can work if you're not real concerned about performance and compile time type checking
14:22:50 <hpc> frerich: all i have done so far is cabalize it; i will probably do more later but feel free to send a pull request
14:25:08 <absence> will a deep chain of Reader.local calls with e.g monoid setter lens as the modifier potentially cause a space leak?
14:26:06 <hpc> @src local
14:26:06 <lambdabot> Source not found. :(
14:26:08 <hpc> :t local
14:26:10 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
14:26:28 <hpc> probably, yes
14:26:35 <hpc> you have a stack of rs
14:27:25 <mun> hi
14:27:34 <mun> in higher-order logic type theory, what's a first-order function?
14:27:49 <absence> hpc: can i avoid that somehow?
14:28:07 <hpc> absence: in this case, using State would be a form of "tail call optimization"
14:28:26 <hpc> if you squint hard and see that the local rs are similar to a bunch of stack frames
14:28:46 <absence> hpc: i don't have to squint, that's what i use it for :)
14:29:11 <hpc> ooh, neat
14:29:12 <monochrom> I am not sure it is a space leak. you have N levels of information (and supposedly you do not want losing any), do you expect to use O(1) memory?
14:29:46 <absence> hpc: i use it to recursively transform graphics primitives
14:30:12 <absence> hpc: but i suspect it builds a huge pile of thunks
14:38:20 <absence> is there a way to find out if a function is passed a pile of thunks or evaluated data?
14:39:04 <linduxed> is there a way to color the ghci propmt?
14:39:11 <linduxed> or something like that
14:39:17 <linduxed> to make commands stand out and so on
14:39:26 <CodeDmitry> Hello :)
14:39:28 <shachaf> :set prompt "\ESC[32;5mλ> \ESC[0m"
14:39:33 <CodeDmitry> Can somebody help me with a simple problem?
14:39:35 <shachaf> But it's not as great as you might think.
14:40:56 <CodeDmitry> anyone help with a simple problem?
14:41:10 <simpson> CodeDmitry: Sure.
14:41:16 <CodeDmitry> okay so heres the idea
14:41:23 <CodeDmitry> a = ["assign1_interface", "assign1_implementation"];
14:41:29 <CodeDmitry> b = [a];
14:41:35 <CodeDmitry> c = ["assign2_interface", "assign2_implementation"];
14:41:39 <simpson> Stop.
14:41:42 <simpson> Use hpaste.org.
14:41:43 <CodeDmitry> how would i put c into b
14:41:46 <CodeDmitry> its 3 lines...
14:42:19 <CodeDmitry> if it was longer id pastebin
14:42:21 <simpson> Well, you can't change b.
14:42:25 <CodeDmitry> i know i cant
14:42:28 <simpson> What are you trying to do?
14:42:28 <CodeDmitry> but how would i solve this problem
14:42:47 <CodeDmitry> i want to make a "folder of assignments" in memory
14:42:56 <CodeDmitry> each assignment has an interface and implementation
14:43:04 <CodeDmitry> how would i rearrange this problem
14:43:06 <CodeDmitry> to make sense in haskell
14:43:42 <linduxed> shachaf: it's good enough  :-)
14:43:46 <CodeDmitry> ?
14:43:54 <shachaf> linduxed: I thought so too, at first!
14:44:06 <simpson> CodeDmitry: You can't just go with b = [a, c] instead?
14:44:12 <linduxed> shachaf: is somethign going to explode?
14:44:16 <CodeDmitry> no i cannot
14:44:27 <CodeDmitry> because i will want to add more "assignments" later
14:44:33 <CodeDmitry> its suppose to simulate a folder
14:44:35 <simpson> How will you add them?
14:44:35 <monochrom> this is not a simple problem
14:45:06 <CodeDmitry> its a simple problem in non functional languages
14:45:10 <CodeDmitry> :\
14:45:28 <CodeDmitry> in perl they have a saying, simple things should be simple, hard things should be possible
14:45:31 <otters> so use a non functional language
14:45:35 <glguy> CodeDmitry: You are misunderstanding what 'b' is
14:45:42 <glguy> b is the name of [a], it is not a variable
14:46:00 <glguy> You don't put stuff in a name
14:46:13 <CodeDmitry> b is a list of one item
14:46:22 <CodeDmitry> lists in haskell are immutable
14:46:37 <CodeDmitry> how would i find a more haskell friendly solution
14:46:51 <simpson> Maybe you'd start by thinking about how you would add another folder.
14:47:11 <CodeDmitry> and thats what im doing
14:47:13 <CodeDmitry> :P
14:47:16 <simpson> You'd probably use a function that takes the current list, and a folder, and returns a new list that has the folder appended.
14:47:46 <CodeDmitry> then how would i access "the folder as it is now"
14:48:30 <CodeDmitry> im thinking of lazy evaluations for this but idk how that works
14:49:10 <simpson> Well, I guess it depends on what you want "now" to mean.
14:49:19 <linduxed> i've got this code https://gist.github.com/4514645
14:49:35 <linduxed> hlint tells me that it thinks that every line has a redundant $
14:49:49 <linduxed> am i missing something here?
14:49:58 <linduxed> i don't see how i could take it out
14:49:58 <simpson> let a = ["first", "thing"]; b = ["second", "thing"] in b : [a]
14:50:06 <simpson> > let a = ["first", "thing"]; b = ["second", "thing"] in b : [a] -- derp
14:50:07 <lambdabot>   [["second","thing"],["first","thing"]]
14:50:52 <simpson> linduxed: Well, what does it suggest instead?
14:51:39 <linduxed> simpson: nothing, it just says "redundant $" for each line, at col 7 (so at the first ")
14:51:55 <linduxed> oh wait
14:52:06 * hackagebot hpaco-lib 0.18.0.0 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.18.0.0 (TobiasDammers)
14:52:08 * hackagebot hpaco 0.18.0.0 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.18.0.0 (TobiasDammers)
14:52:10 * hackagebot cipher-aes 0.1.6 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.1.6 (VincentHanquez)
14:52:19 <CodeDmitry> >.> sorry dad told me i have to watch sister in a few minutes
14:52:21 <linduxed> simpson: sorry, hahahaha
14:52:25 <simpson> Could you maybe do... @=? roundToDecimals 1 (seqSetsToProfileDistance fam1 fam2)
14:52:36 <CodeDmitry> has my question been addressed?
14:52:52 <linduxed> simpson: my editor advice tool or whatever one should call it mangled the advice
14:53:00 <simpson> CodeDmitry: Well, I think the big question is still about what you want your data structure to look like.
14:53:01 <linduxed> it does actually say exactly what you said
14:53:14 <linduxed> i don't see the point of that though... is that really prettier?
14:53:20 <linduxed> "more haskell"?
14:53:26 <CodeDmitry> i dont care waht my structure looks like, i want a simple way to store arbitrary amount of items in a list
14:53:31 <CodeDmitry> but know what the list is at the moment
14:53:39 <shapr> stepkut: much sadness :-(
14:53:40 <CodeDmitry> so i dont get confused in 1000 variables of diff lists
14:54:01 <simpson> CodeDmitry: There is no "at the moment" in the way that you're thinking of.
14:54:09 <stepkut> shapr: well, that is what I expected
14:54:19 <CodeDmitry> then how do you deal with such problems in haskell
14:54:31 <simpson> You restructure the problem.
14:54:36 <CodeDmitry> how
14:54:40 <stepkut> shapr: I think it means that most of the work is actual productive work that is ARM specific :)
14:54:41 <simpson> Right now, your problem is "how do I alter a list?"
14:54:48 <CodeDmitry> i dont care abbout altering list
14:55:02 <CodeDmitry> but i do want a list of items at runtime
14:55:07 <monochrom> I don't think anyone understands the question
14:55:11 <linduxed> where do i place ghci.conf?
14:55:16 <shapr> stepkut: That's a good point. I can only hope that HaLVM is actually a very tiny chunk of code, and that 2/3 of HaLVM is less than 100 lines!
14:55:36 <monochrom> $HOME/.ghc is a good place to play ghci.conf. but let me check again
14:55:42 <CodeDmitry> you haskell guys really make a simple problem of "dynamic lists" impossible dont you
14:55:42 <stepkut> shapr: :)
14:55:54 <linduxed> oh wait, found it
14:56:07 <simpson> CodeDmitry: This is the way the language works. If you have a list, and you append something, you get a *new* list.
14:56:16 <CodeDmitry> i dont mind that simpson
14:56:17 <simpson> The original list isn't altered.
14:56:27 <sclv> other than that, we have standard linked lists
14:56:32 <sclv> as a core data structure
14:56:32 <CodeDmitry> but it must have some way of redesigning the program to still meet satisfactions
14:56:36 <CodeDmitry> specifications*
14:56:44 <monochrom> but .ghci is even better than ghci.conf. you can put .ghci in "current directory"
14:56:44 <CodeDmitry> satisfy the specification*
14:56:58 <sclv> typically if you have lots of functions that just each alter a piece of data a little
14:57:05 <sclv> you don't give the result of each one a new name
14:57:11 <sclv> instead you compose them all together
14:57:23 <CodeDmitry> how does that work?
14:57:42 <sclv> instead of let x' = a x; x'' = b x'; x''' = c x'', we can just write: c . b . a $ x
14:57:47 <glguy> CodeDmitry: Your question is to vague for anyone to provide you meaningful help. Try explaining What you're actually trying to do and not how you think it should work
14:58:01 <sclv> if you write code the ugly looking way and put it on hpaste.org
14:58:07 <sclv> people would be glad to help you clean it up
14:58:18 <CodeDmitry> I am trying to make a program where a user can input two items, and store the two items in a list
14:58:25 <CodeDmitry> and put that list into a heirarchy of existing lists
14:58:34 <CodeDmitry> and continue asking for more 2 items
14:58:37 <sclv> [x,y] <- fmap read . getLine
14:58:45 <sclv> what do you mean hierarchy of existing lists?
14:58:46 <sclv> j
14:58:49 <monochrom> how does the user know that the input is stored?
14:59:03 <CodeDmitry> the user doesnt know, the user just knows that his input is stored in pairs in a list
14:59:14 <CodeDmitry> later, i can add functionality to extract these items if i want
14:59:17 <sclv> so you have a list of pairs of e.g. ints
14:59:37 <sclv> and the user can enter ints pairs, and they get stuck in that list?
14:59:53 <monochrom> not later. now. how to store depends on what queries are to be supported. I am serious.
14:59:54 <CodeDmitry> yes user inputs something like 5, 6
15:00:05 <CodeDmitry> the 5, 6 gets stored in a list
15:00:14 <CodeDmitry> then [5, 6] gets "somehow appended" to existing lists
15:00:22 <CodeDmitry> that is where it begins to be vague
15:00:24 <sclv> monochrom: I think its fine to stick with [(Int,Int)] for now
15:00:39 <otters> are the existing lists in a file somewhere?
15:00:40 <otters> or just in memory
15:00:45 <hpaste> glguy pasted “storing things” at http://hpaste.org/80634
15:00:49 <CodeDmitry> lets say they're in file for the sake of simplicity
15:01:10 <monochrom> then glguy's paste
15:01:10 <sclv> loop lst = do {newPair <- readPairFromIO; loop (newPair : lst)}
15:01:37 <sclv> yep, glguy nailed it
15:01:37 <monochrom> also see my number guessing game http://hpaste.org/52480
15:02:12 <CodeDmitry> thanks for the solutions, im still wrapping my mind around the way of thinking of it
15:02:19 <CodeDmitry> its a really different way of problem solving
15:02:30 <_Vi> Are there any online Haskell tests (to check current knowledge level)?
15:02:32 <monochrom> in my number guessing game, "answer", "lo", "hi" are "stored" and "modified" by passing parameters to the next recursive call
15:03:07 <CodeDmitry> ah
15:03:15 <monochrom> file is different. file does not need this parameter passing. just write to file, read from file
15:03:22 <CodeDmitry> haskell people solve this by using stacks?
15:03:31 <monochrom> there is no stack
15:03:33 <CodeDmitry> 1 variable, many scopes?
15:03:40 <CodeDmitry> recursion uses stack...
15:03:44 <_Vi> CodeDmitry, Stack is often not consumed due to TCO.
15:03:45 <CodeDmitry> its just implicit
15:03:45 <monochrom> not here
15:04:07 <monochrom> ok, there is stack, but used for other things, you have no idea
15:04:09 <Lethalman> @hoogle Bool -> a -> Maybe a
15:04:10 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
15:04:10 <lambdabot> Control.Exception assert :: Bool -> a -> a
15:04:10 <lambdabot> Control.OldException assert :: Bool -> a -> a
15:04:35 <CodeDmitry> actually i think utilizing stack and recursion could work...
15:04:39 <Lethalman> huh there's no function already such that if bool then Just x else Nothing
15:04:46 <sclv> these calls are tail calls
15:04:47 <CodeDmitry> ill leave the pain of stack overflow to be optimized by compiler into a loop
15:04:48 <sclv> they don't eat stack
15:04:53 <sclv> exactly
15:04:56 <simpson> CodeDmitry: Forget about stack.
15:05:03 <glguy> CodeDmitry: It's going to be important to forget the stuff you think you know from how other languages are implemented
15:05:17 <glguy> that stuff isn't univerfsal
15:05:21 <sclv> you can blow the stack in haskell just like anywhere else if your calls aren't tail calls
15:05:35 <sclv> so its not all magic
15:05:36 <CodeDmitry> sister came from preschool, gotta go for a bit
15:05:38 <CodeDmitry> thanks for solutions
15:05:42 <monochrom> I am frankly tired of a beginner being so sure of himself
15:05:56 <simpson> monochrom: Be nice; we were all beginners once. :3
15:05:57 <CodeDmitry> and the only way im gonna learn haskell is by analogies, not by completely forgetting
15:06:10 <sclv> sure
15:06:11 <CodeDmitry> you cant make somebody forget anything, as haskell users you should know that
15:06:23 <sclv> i forget things all the time
15:06:26 <sclv> its great!
15:06:30 <sclv> what were we talking about?
15:06:31 <simpson> CodeDmitry: You need to unlearn, not forget. It's difficult to do.
15:06:33 <monochrom> I was a beginner yes, but I tried very hard to be unsure
15:06:50 <simpson> I was 13 when I got started. I'm sure that I was an annoying brat. :3
15:07:23 <monochrom> I did not go around judging, "this is simple", "that uses stack", "map is O(n)"
15:07:24 <_Vi> CodeDmitry, One of analogies is to stop interpreting "=" as "assign", but as "means" or "is by definition".
15:07:26 <c_wraith> you can blow the stack in haskell even if your calls *are* tail recursive..
15:07:42 <stepkut> template haskell doesn't offer a way to get a Type from an Exp does it?
15:07:45 <parcs> what's the definition of fail for STM ?
15:08:17 <glguy> > runST (fail "")
15:08:19 <lambdabot>   *Exception:
15:08:28 <c_wraith> glguy: ST*M*
15:08:43 <glguy> Look at c_wraith, reading all the way to the end of the question
15:08:55 <c_wraith> I didn't read the question mark.
15:08:59 <monochrom> I bet STM's fail is retry. but I should test
15:09:14 <david1991> Hey guys, one hour ago or something, I asked here how I can define a function that can count its arguments using type classes. This means that "count 1 (id) (seq)" should evaluate to 3 as it has 3 arguments. Now I've created something, http://pastebin.com/XMBZzWns, which I think it should work, based on the idea of Text.Printf. However I get an error saying "Could not deduce r ~ Int"... can
15:09:14 <david1991> someone give me a hint?
15:09:19 <mauke> The paste XMBZzWns has been copied to http://hpaste.org/80635
15:09:33 <sclv> c_wraith: good point. i oversimplified too drastically there
15:10:03 <parcs> monochrom: i jsut tested it and it looks like it throws an exception :(
15:10:09 <Mortchek> david1991, how does it know whether to return a count or another function?
15:10:37 <david1991> it returns the amount of arguments
15:10:41 <fmap> parcs: why not mzero?
15:10:43 <david1991> I don't understand your question Mortchek
15:10:43 <monochrom> I guess the string parameter must be used some way :)
15:10:44 <Mortchek> david1991, all Haskell functions are in one parameter.
15:11:20 <david1991> Well my reasoning is as follows: suppose I have count 5 True "Hello" yes?
15:11:33 <david1991> the type of this function should be Int -> Bool -> String -> Int
15:11:46 <david1991> since it returns the amount of parameters (which is an Int).
15:12:09 <david1991> now is Int a Countable? yes!
15:12:17 <david1991> is String an All?
15:12:19 <david1991> yes!
15:12:27 <david1991> so is String -> Int a Countable?
15:12:29 <david1991> yes!
15:12:57 <david1991> so based on this, my Int -> Bool -> String -> Int is actually in the Countable context.
15:13:01 <Mortchek> david1991, let me rephrase my earlier question: How should it know when you're done giving it arguments?
15:14:02 <david1991> Well it typechecks, please see this http://stackoverflow.com/questions/3467279/how-to-create-a-polyvariadic-haskell-function
15:14:12 <shachaf> parcs: Are you sure you want a failed pattern match in STM to block?
15:14:49 <ion> 999 users
15:15:01 <david1991> In fact I'm doing something very similar... however I wonder why I get a deduce error
15:15:07 <Mortchek> david1991, you need some way to determine whether you're going to return a function or return a count.
15:15:24 <monochrom> haha, actually, now that you say it, I actually want a failed pattern match to block, to retry
15:15:25 <Mortchek> david1991, give a few examples of how you expect to call this function, and what the outputs should be.
15:15:32 <parcs> shachaf: yes!
15:15:39 <david1991> I call count 5 3 True
15:15:43 <david1991> and it should output 3
15:16:00 <david1991> count (id) (id) (seq) and it should output 3
15:16:03 <shachaf> You want it to count the number of arguments it's given?
15:16:06 <david1991> yes
15:16:15 <shachaf> OK, you should be able to do that Text.Printf-style, I think.
15:16:20 <david1991> I did that
15:16:21 <Mortchek> david1991, how should it know that when you hand it that True or that seq that it should return a count?
15:16:24 <shachaf> Oh.
15:16:36 <shachaf> Mortchek: The same way Text.Printf knows, presumably.
15:16:47 <david1991> I will paste my code again http://pastebin.com/XMBZzWns
15:16:48 <mauke> The paste XMBZzWns has been copied to http://hpaste.org/80635
15:16:51 <Mortchek> shachaf, that determines a head of time, based on the number of things to format.
15:16:55 <Mortchek> ahead*
15:17:03 <Mortchek> shachaf, david1991 seems to have no such way to determine.
15:17:13 <CodeDmitry> erm, a simpler problem, whats the simplest way to make a function that prints a list?
15:17:29 <david1991> I have no such way to determine indeed
15:18:02 <david1991> Mortchek, the stack overflow solution has also no such way to determine right?!
15:18:26 <Mortchek> david1991, which function are you referring to?
15:18:35 <Mortchek> +theoretical
15:19:04 <david1991> Please look here: http://stackoverflow.com/questions/3467279/how-to-create-a-polyvariadic-haskell-function
15:19:09 <Mortchek> I saw it.
15:19:10 <david1991> I am refer. to sumOf
15:19:30 <Mortchek> david1991, what's important there is the type signature.
15:19:35 <Mortchek> Notice the :: Integer
15:19:47 <david1991> OH!
15:19:55 <david1991> count 5 4 3 2 :: Int
15:19:57 <david1991> I meant
15:19:59 <david1991> oh sorry!
15:20:02 <david1991> Indeed
15:20:03 <david1991> I SEE!
15:20:05 <Mortchek> :)
15:20:18 <hpaste> glguy pasted “count function arguments” at http://hpaste.org/80636
15:20:20 <david1991> You are brilliant
15:20:25 <david1991> Mortchek
15:20:30 <shachaf> Mortchek: Oh, I was assuming the type signature was being specified.
15:20:30 <david1991> but still...
15:20:38 <david1991> if I run my code
15:20:41 <david1991> it fails
15:20:43 <Mortchek> Actually I had no idea how to solve this until I saw the sumOf example. I was just trying to get you to draw your own conclusion. :)
15:20:57 <david1991> ah I see, but it still fails XD
15:21:05 <david1991> as I cannot get it to run in GHCi
15:21:17 <monochrom> add more ":: Int"?
15:21:35 <david1991> no
15:21:38 <david1991> does not work
15:21:51 <david1991> I will try something different
15:22:24 <glguy> david1991: I don't think it will be useful, but my paste seems to do what you were asking for
15:23:08 <david1991> hmm let me study the code (thank you glguy)
15:23:37 <Mortchek> david1991, you could probably pretty straightforwardly modify sumOf, actually. Instead of adding the argument, add 1.
15:23:53 <Mortchek> Then you also don't need the Integral a constraint.
15:24:44 <david1991> yes I noticed that
15:24:54 <shapr> @quote
15:24:54 <lambdabot> sjanssen says: Quoth the Prelude, Chapter 6, verse 4:  Yeah verily shall repeat floweth cons cells over.
15:25:05 <david1991> =) thank you for your help guys!
15:26:04 <Mortchek> CodeDmitry, print does that
15:26:13 <Mortchek> CodeDmitry, or show
15:26:21 <Mortchek> (to get a string of it)
15:26:22 <CodeDmitry> >.> syntax?
15:26:27 <Mortchek> > print [1, 2, 3]
15:26:29 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
15:26:29 <lambdabot>    arising from a use of ...
15:26:29 <CodeDmitry> print my_list?
15:26:38 <Mortchek> Yes.
15:26:53 <Mortchek> It'll work in GHCi but lambdabot doesn't like to execute IO.
15:27:13 <CodeDmitry> isnt IO the whole point of running lambdabot to begin with?
15:27:22 <CodeDmitry> otherwise he's just a calculator
15:27:24 <Mortchek> lambdabot is useful for calculating pure expressions.
15:27:30 <CodeDmitry> ah
15:27:45 <glguy> CodeDmitry: most interesting Haskell code is pure and doesn't need IO
15:27:49 <monochrom> oh, we mean: lambdabot doesn't like to execute arbitrary IO
15:27:56 <Mortchek> Oh, yes :)
15:28:02 <CodeDmitry> glguy thats only true for interpreted haskell
15:28:12 <CodeDmitry> otherwise theres no point of running the program
15:28:23 <glguy> You're the expert
15:28:32 <monochrom> see what I mean?
15:28:41 <CodeDmitry> you guys are more sarcastic than the perl community
15:28:47 <Mortchek> quchen showed me a pretty cool completely pure language the other day. http://esolangs.org/wiki/Compute
15:29:19 <shachaf> CodeDmitry: Some of the people in here tend to be pretty nice. But you should try to be nice in turn.
15:29:54 <CodeDmitry> it's really hard to understand haskell community's definition of "nice" :\
15:30:13 <CodeDmitry> do you mean "thankful"?
15:30:28 <bgamari> CodeDmitry, Many people in this channel are extremely generous
15:30:38 <shachaf> I am not the Haskell community. I have my own definitions.
15:31:11 <bgamari> I started learning Haskell about 18 months ago and I've been pleasantly surprised by the number of people who are willing to take time out of their day to look at my silly problems
15:31:28 <CodeDmitry> That is  true, and I am very thankful to those who provide feedback in regards to my problems
15:31:58 <CodeDmitry> Still, I am a very assertive programmer, and haskell doesnt appear to like that, but
15:32:15 <CodeDmitry> ignore the last part
15:32:35 <Nereid> you don't get too far if you try to bring imperative intuitions to haskell programming.
15:32:37 <CodeDmitry> the only way to program in most language is in assertive ways, and i have no other ways to describe problems otherwise
15:33:11 <johnw> CodeDmitry: why doesn't Haskell like assertive programming?
15:33:19 <c_wraith> CodeDmitry: the other approach is to describe the results you want, not the mechanisms for implementing it.
15:33:36 <monochrom> becasue you have different meanings of "assertive". perhaps even conflicting meanings
15:33:46 <Nereid> whereas imperative languages use variables to hold mutable state, it's typically done differently here, where your state is threaded through function calls
15:34:02 <Nereid> which is why we use recursion instead of loops.
15:34:13 <shapr> CodeDmitry: Learning to think the way Haskell requires leads to more programming ability in imperative languages.
15:34:15 <Nereid> or rather, that is an example of it.
15:34:26 <shapr> CodeDmitry: But may lead to less enjoyment writing imperative languages.
15:35:20 <Jeanne-Kamikaze> I think it makes it more enjoying
15:35:50 <Nereid> > let fac n = fac' n 1; fac' 0 acc = acc; fac' n acc = fac' (n-1) (n*acc) in fac 7
15:35:51 <lambdabot>   5040
15:35:59 <monochrom> that is another episode of "half full, half empty"
15:36:31 <CodeDmitry> I enjoy all paradigms, this one is particularly challenging
15:36:41 <monochrom> half empty: "javascript is so horrid, it doesn't have types!"
15:36:47 <CodeDmitry> which is a good thing
15:36:54 <monochrom> half full: "javascript is so fun, it has lambda!"
15:37:00 <Lethalman> I'm reading an haskell file, but I don't know where a certain function name comes from
15:37:04 <CodeDmitry> javascript requires very assertive programming understanding
15:37:07 <Jeanne-Kamikaze> exactly
15:37:07 <Nereid> before you can ask what the value of acc is "now", when I'm evaluating fac 7, you have to know what "now" is.
15:37:09 <Lethalman> how can I understand that?
15:37:12 <CodeDmitry> makes it very hard to debug at times
15:37:23 <Lethalman> should I use an ide?
15:37:26 <johnw> Lethalman: :i functionName in ghci?
15:37:27 <CodeDmitry> but its still a very enjoyable language imo
15:37:41 <Lethalman> johnw, it's a name imported from a module
15:37:55 <glguy> CodeDmitry: What do you mean when you write "assertive programming"?
15:37:55 <Lethalman> johnw, also this is a project, not a single file (I was misleading)
15:38:21 <CodeDmitry> By assertive programming i mean compilers wont help you avoid errors
15:38:22 <johnw> Lethalman: :i should tell you which module it comes from
15:38:28 <CodeDmitry> so you cant assume your code is commands
15:38:30 <CodeDmitry> its requests
15:38:34 <Lethalman> johnw, so I have to load the whole project inside of ghci?
15:38:37 <CodeDmitry> meaning you have to check EVERYTHINg
15:38:47 <CodeDmitry> you have to assert 2+2 = 4
15:38:54 <CodeDmitry> :P
15:38:54 <johnw> Lethalman: I normally do that as a matter of course in Emacs; not quite sure how to do it from command-line
15:39:07 <monochrom> Lethalman: load up one file that uses that name, then :info that name
15:39:24 <Mortchek> CodeDmitry, sounds sort of like you are describing dynamic typing.
15:39:26 <sepp2k1> CodeDmitry: Ah, so by assertive you mean "containing lots of assert statements"? I think that's usually called "defensive".
15:39:51 <monochrom> but I also know another way. ghc -c -ddump-minimal-imports ThatFile.hs, then look at ThatFile.imports
15:39:59 <CodeDmitry> using assertion as a defensive technique, they're related
15:40:14 <Lethalman> monochrom, but then that file can't find other modules of the same project
15:40:17 <Jeanne-Kamikaze> related or the same ?
15:40:28 <CodeDmitry> assert being something that will immediatly tell you if you assumed wrong
15:40:37 <CodeDmitry> usually some print statement
15:40:43 <sepp2k1> Mortchek: Well, Haskell is statically typed and it's still possible that 2 + 2 /= 4 ;-)
15:40:55 <monochrom> you mean in ghci? then you haven't gave ghci enough information
15:41:03 <c_wraith> > let 2 + 2 = 5 in 2 + 2 == 4
15:41:04 <CodeDmitry> assert in C isnt quite the same because it's usually used at debugging, defensive code is there forever
15:41:04 <lambdabot>   False
15:41:08 <Lethalman> monochrom, because there are .chs files
15:41:10 <Mortchek> sepp2k1, yes well, Haskell also has a pretty rich type system. :)
15:41:16 <monochrom> oh oops, shoot, darn...
15:41:40 <S11001001> CodeDmitry: You can defensively type.
15:41:41 <Mortchek> Even if there are some things, like typeclass laws, that it can't express.
15:41:44 * Lethalman debugging this haskell project is getting very hard
15:41:49 <Lethalman> full of traces
15:41:50 <glguy> is today contrary day?
15:42:04 <CodeDmitry> you always defensively type, but haskell prevents of problems that absolutely require defensive code
15:42:16 <monochrom> then try my -ddump-minimal-imports, but you may have to first chase dependencies manually
15:42:25 <CodeDmitry> biggest problem with defensive code for me is it makes it harder to read what you are trying to do
15:42:38 <CodeDmitry> since eventually it can become larger than program itself
15:43:12 <Mortchek> That's why I usually don't bother with my own "typing" outside the language's type system.
15:43:16 <c_wraith> Fortunately, immutability removes many of the standard things that result in a need for defensive programming.
15:43:20 <S11001001> oh, I thought you were defending defensiveness; reading comprehension &c
15:43:49 <c_wraith> Those standard things being the myriad ways you can mutate data behind your own back, breaking your code's assumptions
15:44:01 <CodeDmitry> defensiveness is a big problem, cant live without it, but it breeds overly defensive code
15:44:03 <CodeDmitry> which is unreadable
15:44:16 <monochrom> nice, adding --make excuses you from manual dependency chasing!
15:44:21 <CodeDmitry> a simple print function can outgrow into a monster making sure that the system even has a screen
15:44:22 <CodeDmitry> >.>
15:45:03 <monochrom> ghc --make -c -ddump-minimal-imports ThatFile.hs
15:46:55 <SamanthaD> I need what I guess is the mathematical equivalent of spiritual guidance: I started learning Haskell because I wanted to be able to write ultra-reliable code but I feel like I just traded one type of bug (type conflicts) for another tye of bug (overflowing my stack with thunks)
15:46:58 <c_wraith> I didn't realize --make would work with stuff like that.  That's good to know.
15:47:12 <SamanthaD> I guess I can say I'm discouraged
15:47:32 <shachaf> SamanthaD: What I said yesterday holds, I think.
15:47:52 <CodeDmitry> pascal tends to be a more mathematical programming language from my experience. haskell discards a lot of mathematical concepts by denying volatile types
15:47:54 <SamanthaD> shachaf: a lot of stuff was said yesterday, could you refresh my memory?
15:48:06 <shachaf> SamanthaD: You want to get an intuition for GHC's evaluation model, which takes some time and getting used to.
15:48:25 <Mortchek> CodeDmitry, what are volatile types?
15:48:30 <shachaf> Once you do, things generally become much less magic.
15:48:44 <SamanthaD> shachaf: I know... that's why I haven't thrown Haskell against a wall and run screaming back to Scheme. I really can see it's a great language theoretically.
15:48:52 <CodeDmitry> volatile types are nonconst types, mathematical concepts often involve the use of :=
15:48:55 <shachaf> This is true for other languages/compilers too. But most of them have an evaluation model you're already familiar with.
15:49:00 <CodeDmitry> haskell has no :=
15:49:12 <Mortchek> CodeDmitry, what's a nonconst type?
15:49:17 <CodeDmitry> eg, matric row manipulation
15:49:22 <monochrom> SamanthaD: see my http://www.vex.net/~trebla/haskell/lazy.xhtml
15:49:25 <Mortchek> CodeDmitry, are you referring to mutability of variables?
15:49:32 <CodeDmitry> nonconst type being a type that cannot be changed at runtime
15:49:35 <CodeDmitry> or compile time
15:49:40 <CodeDmitry> nor*
15:49:41 <dolio> What mathematical concepts involve that?
15:49:52 <CodeDmitry> reserved bytes
15:49:52 <SamanthaD> monochrom: thanks. I had that in my to-read list already.
15:50:07 <napping> SamanthaD: philosophically, a stack overflow is at least failing safe
15:50:20 <CodeDmitry> matrix manipulation in schools is often tought throuhg :=
15:50:20 <Lethalman> +RTS -xc to get a stack trace = crash :'-(
15:50:23 * Lethalman clueless
15:50:27 <Mortchek> CodeDmitry, what is a language where types can change at runtime?
15:50:29 <CodeDmitry> eg R2 := R2 * 5
15:50:29 * Lethalman ranting
15:50:35 <CodeDmitry> you cant do that in haskell
15:50:51 <ion> codedmitry: R2' = R2 * 5
15:51:01 <SamanthaD> napping: Yes... but so is a type conflict in a strict/dynamic type system. But it still makes your program crash. Worse, a memory leak can take out more than just the program. It can grind the entire computer to a halt.
15:51:26 <SamanthaD> Mortchek: BASIC!
15:51:28 <ion> codedmitry: Also, you can have mutability in Haskell.
15:51:51 <SamanthaD> Mortcheck: Also C
15:52:13 <napping> depends what you meant by "type" conflict - I was thinking of cases where you make more type distinctions in Haskell, and catch things like perhaps not escaping strings propertly
15:52:13 <dolio> You don't seem to be talking about mathematics. You seem to be talking about (imperative) numerical algorithms.
15:52:17 <CodeDmitry> ion, you have to jump through so many hoops to do that, that that i can't make any comments on that
15:52:20 <Mortchek> I think I am misunderstanding what was meant for a type to change.
15:52:37 <CodeDmitry> haskell is not a language its a way of thinking, in my opinion
15:52:38 <Mortchek> The best interpretation I can come up with is that CodeDmitry is indeed talking about mutable variables.
15:52:54 <newsham> i'm pretty sure haskell is a language
15:52:57 <CodeDmitry> suppose the following mathematical example
15:53:01 <newsham> want a wikipedia cite?
15:53:08 <CodeDmitry> let M = 2 by 2 matrix [1 2 | 3 4]
15:53:21 <CodeDmitry> let M2 = 2 by 2 matrix [2 3 | 4 5]
15:53:26 <CodeDmitry> let C = M + M1
15:53:29 <SamanthaD> napping: Yeah... I guess I just needed a bit of encouragement. Still, I think I ought to learn ML for mission-critical applications. (Here I am deluding myself that I'll ever write something that's mission critical).
15:53:34 <CodeDmitry> this concept is very hard to replicate in haskell
15:53:57 * monochrom goes to wikipedia's Haskell article, adds "Haskell is a .... language [citation needed]"
15:54:09 <Jeanne-Kamikaze> CodeDmitry: what's so hard about it ?
15:54:41 <CodeDmitry> well, in this case it isnt, but then you start looping, it becomes more difficult
15:54:57 <Jeanne-Kamikaze> that's why you have recursion
15:54:58 <napping> depends a lot what you mean by mission critical
15:55:08 <CodeDmitry> and if you need to modify M to solve a linear system, it won't allow you
15:55:16 <SamanthaD> napping: if it crashes bad things happen
15:55:17 <dolio> No, you don't.
15:55:22 <Jeanne-Kamikaze> you create a new M
15:55:31 <Jeanne-Kamikaze> and you do have mutable data structures by the way
15:55:41 <Jeanne-Kamikaze> so yes, it will allow you
15:55:49 <napping> Then perhaps formally verified C is the way to go, at least you have CompCert
15:55:53 <CodeDmitry> recursive thinking is far more difficult than iterative
15:55:55 <Jeanne-Kamikaze> roll some ST monad, impure inside pure outside
15:56:02 <CodeDmitry> let me emphasize the *far*
15:56:05 <monochrom> SamanthaD, I can use Haskell for mission critical things, I can make it not crash, I can make it use a controlled amount of memory, etc
15:56:06 <dolio> Nope.
15:56:13 <Jeanne-Kamikaze> CodeDmitry: no it's not
15:56:19 <SamanthaD> napping: Though... since my real interests are in scientific computing a program crash really isn't that big a deal. You just kick the filing cabinet, swear a bit, and fix the program. A real disaster would be an undetected error in output.
15:56:20 <monochrom> or at least, s/Haskell/GHC's Haskell/
15:56:20 <CodeDmitry> it takes weeks to months for somebody to learn using monads
15:56:33 <CodeDmitry> i watched over 3 hours of monad lessons and i still cant tell a monad from a yumad
15:56:43 <napping> SamanthaD: as a matter of practice, you seem to be getting plenty of decent advice about how to avoid strictness issues in practice
15:56:44 <SamanthaD> monochrom: what kinda stuff do you use it for, if you don't mind me asking?
15:56:52 <elliott> The problem is that you watched over 3 hours of monad lessons rather than furthering your Haskell education without a strong focus on monads, most likely.
15:57:02 <monochrom> I haven't needed a mission-critical thing yet
15:57:14 <CodeDmitry> its very very VERY very hard to find good haskell examples which are isolated and comprehensive
15:57:31 <Jeanne-Kamikaze> LYAH is pretty isolated and comprehensive
15:57:31 <SamanthaD> monocrom: fair enough. I'm going to go read the papers and be happy.
15:57:32 <monochrom> or perhaps I have already written a mission-critical program without calling it missing-critical. the program has run for a long time, no crash no leak
15:58:00 <monochrom> ok, url: http://www.vex.net/~trebla/portfolio/index.html
15:58:01 <CodeDmitry> well designed programs dont crash or leak, they crash or leak if you code without watching your code
15:58:03 <CodeDmitry> thats why haskell is good
15:58:09 <CodeDmitry> it wont compile at all until you know your code
15:58:09 <gwern> @quote liver
15:58:10 <lambdabot> cbeust says: I've never been let down by PHP. When I started writing code in it, I knew exactly what to expect and what its level of abstraction was, and it's always delivered exactly that. Wish
15:58:10 <lambdabot> more languages lived to their expectations the way PHP did for me.
15:58:22 <monochrom> especially "A program that connects to both an Eggdrop IRC bot and an IRC server"
15:58:37 <CodeDmitry> Eg, haskell forces you to analyze your program before it compiles
15:58:54 <CodeDmitry> C++ doesn't have that because it assumes you are smart enough to look over your code
15:59:01 <CodeDmitry> and if u arent, you can make assertions to test it
15:59:05 <gwern> '18:56:16 < CodeDmitry> i watched over 3 hours of monad lessons and i still cant tell a monad from a yumad' <-- I think I see the problem there
15:59:09 <CodeDmitry> but hard code is very hard to debug assertively
15:59:30 <CodeDmitry> gwern what are you implying
15:59:45 <gwern> that 'ur doing it rong'
15:59:53 <CodeDmitry> isn't that obvious
15:59:57 <Jeanne-Kamikaze> maybe implement your own Maybe and State instead of watching
16:00:08 <gwern> programming isn't something you watch, it's soemthing you do
16:00:10 <Jeanne-Kamikaze> and translate loops to recursive functions
16:00:19 <CodeDmitry> telling that im doing it wrong is like saying 2+2 = 4, its obvious that im doing it wrong that is why i am here to learn how to deal with problems in a "normal way"
16:00:29 <CodeDmitry> then i can make decisions on what is right and wrong based on what works
16:00:34 <jesyspa> No, C++ forces you to analyze the error messages after it fails to compile, and it may very well be that the relevant code is much shorter.
16:00:39 <CodeDmitry> at this point, nothing works which is a problem
16:00:56 <SamanthaD> Thanks everyone, that bit of encouragement is all I really needed. Off to learn how to evaluate laziness!
16:01:04 <CodeDmitry> error messages in C++ are far better than in haskell for low level code
16:01:19 <Jeanne-Kamikaze> then you haven't used templates or lambdas
16:01:19 <CodeDmitry> but it takes about same amount of time to learn to read them in haskell and c++ imho
16:01:27 <gwern> CodeDmitry: which is a reason that most haskllers program bottomup in ghci
16:01:44 <CodeDmitry> precisely, ghci is a great debugging tool
16:01:45 <ion> [citation needed]
16:01:48 <gwern> if you have a gigantic program none of which does anything because you're writing it topdown...
16:01:50 <CodeDmitry> c++ is very hard to debug complicated programs
16:02:02 <CodeDmitry> you get error on types when you dont even deal with those types
16:02:07 <ion> Whoops, i forgot i had scrolled up and responded to an old comment. :-P
16:02:14 <SamanthaD> I love interactive prototyping <3
16:02:34 <CodeDmitry> which brings me back to my idea of "using low level code for high level problems and using high level code for low level problems"
16:02:43 <CodeDmitry> it's just asking for issues
16:02:44 <monochrom> ion, did you see my "monochrom goes to wikipedia's Haskell article, adds "Haskell is a .... language [citation needed]" ? :)
16:03:24 <ion> monochrom: I did, but my comment wasn’t related to that. :-)
16:04:02 <ion> <CodeDmitry> recursive thinking is far more difficult than iterative
16:04:10 <CodeDmitry> In any case, I still think the idea of "if it runs on haskell, it'll run anywhere" has some potential
16:04:46 <CodeDmitry> btw has anyone seen http://hammerprinciple.com/therighttool
16:04:48 <CodeDmitry> its pretty interesting
16:04:55 <SamanthaD> CodeDmitry: I dunno... I wouldn't take a recursive algorithm I developed in Haskell and try to plug it into C. Doing so might prove... interesting...
16:05:08 * gwern shrugs. if CodeDmitry insists on learning monads through videos, it's not going to work well. if he insists on writing big programs top down without building up functions in ghci, it's not going to work well. he'll either learn this, learn how to do haskell the hard way, or abandon haskell.
16:05:09 <CodeDmitry> Samantha thats not what I mean
16:05:16 <CodeDmitry> tail recursion isnt hard to turn into a loop
16:05:24 <CodeDmitry> but if the Haskell algorithm works
16:05:28 <Lethalman> whoohoooo fixed my first hackage project
16:05:31 <CodeDmitry> it can work in any language without expecting type errors
16:05:37 <Lethalman> but I don't know where to report the patch because the project is abandoned :P
16:05:38 <SamanthaD> CodeDmitry: Oh, I see what you mean now.
16:05:44 <napping> CodeDmitry: if you want to avoid stuff with monads, try main = interact strMain
16:05:54 <CodeDmitry> I mean haskell doesnt solve all problems, but it definitely makes more reliable algorithms
16:05:59 <CodeDmitry> at least it tries to
16:06:09 <CodeDmitry> yeah monads make porting ... interesting
16:06:26 <CodeDmitry> but im sure an experienced porter could learn to port monads systematically
16:06:46 <CodeDmitry> and optimization on haskell code shouldnt be that hard
16:06:51 <CodeDmitry> compared to optimizing assembly
16:06:54 <CodeDmitry> X D
16:06:58 <Jeanne-Kamikaze> if an experienced porter needs to learn to port, then they are not experienced ?
16:07:00 <napping> No point trying to learn how to abstract away common patterns if you don't have plenty of experience with the non-abstract way
16:07:14 <CodeDmitry> No experienced anyone ever stops learning
16:07:32 <CodeDmitry> the worst expert is the one who thinks he knows everything
16:07:39 <Jeanne-Kamikaze> well things you already learned you stop learning
16:07:46 <CodeDmitry> its a good selling point, but it cripples good decisions
16:08:35 <CodeDmitry> check http://hammerprinciple.com/therighttool/items/c/haskell out
16:08:40 <CodeDmitry> i find it somewhat interesting
16:08:49 <Jeanne-Kamikaze> why
16:09:15 <CodeDmitry> makes it easy to tell what "people" think of the arbitrary comparison of uncomparable languages
16:09:23 <CodeDmitry> its important to know what people think
16:09:36 <CodeDmitry> doesnt usually reflect reality, but helps appeal to people
16:09:46 <CodeDmitry> or understand how people think in general
16:09:46 <basdirks> helps appeal to sheep
16:10:01 <CodeDmitry> im sorry but the vast majority of people, are sheep
16:10:14 <basdirks> everyone is sheep, some are less tame though
16:10:24 <basdirks> but that kind of site is for lambs
16:10:24 <napping> http://hammerprinciple.com/therighttool/items/agda/haskell is rather more amusing
16:10:44 * elliott thinks this no longer has very much to do with Haskell.
16:10:59 <napping> For example, 2 of 3 who answers picked Haskell over Agda for "I would use this language for a desktop GUI project"
16:11:01 <CodeDmitry> i dont believe calling people sheep is the most productive way of grouping people
16:11:16 <CodeDmitry> nobody can be a master at everything, many decisions we make are because they simply seem right
16:11:20 <basdirks> of course you don't agree to anything
16:11:25 <CodeDmitry> like using a spoon to eat soup
16:11:35 <CodeDmitry> that doesnt make you a sheep does it?
16:11:48 <napping> but Agda clearly dominates at "Code written in this language will usually run in all the major implementations if it runs in one of them."
16:11:50 <SamanthaD> If I'm a sheep at least the wool isn't over my eyes!
16:12:02 <heatsink> Haskell is rated higher than Agda for both "this language is large" and "this language is minimal"
16:12:04 <CodeDmitry> But I mean, if there are "many programming languages"
16:12:12 <heatsink> Those categories seem to be in opposition
16:12:18 <CodeDmitry> you have to have certain irrational generalities about them
16:13:00 <johnw> actually, I was reading in my abstract algebra book the other day about the difference between minimality and smallness
16:13:16 <shachaf> johnw: Why are you +o?
16:13:17 <CodeDmitry> enlighten us
16:13:24 --- mode: johnw set -o johnw
16:13:33 <johnw> shachaf: because someone was abusing the channel very early this morning
16:13:49 <CodeDmitry> what is the difference between minimality and smallness in abstract algebra
16:14:33 <napping> "Syntax for Free" looks pretty interesting
16:15:14 <heatsink> What's the difference between minimality and smallness?
16:15:16 <CodeDmitry> Question of the day, what is the best programming language to implement a lolcode interpretor
16:15:21 <CodeDmitry> im betting on perl
16:15:47 <napping> I'm trying to make an evaluation function for typed patterns as in "Unembedding Domain-Specific Languages"
16:15:56 <basdirks> if someone else asked that question you would answer: "define best"
16:16:00 <johnw> i couldn't find it in the book
16:16:07 <johnw> it has to do with members of partially ordered sets
16:16:15 <basdirks> and then 2 hours of rhetoric101 would follow
16:16:22 <CodeDmitry> ugh so many people using domain specific... gotta go read what it means now
16:16:29 <napping> johnw: "minimal" is usually pretty clear, but I don't know about small
16:16:45 <shachaf> johnw: Did you know about the difference between linear orders and total orders?
16:16:50 <johnw> the book gave an example of when they differ, but I have to run now; ask me again later and I'll look harder for it
16:17:02 <johnw> shachaf: I know what total orders are, I'm not sure I know what linear orders are
16:17:07 <heatsink> arite
16:17:10 <napping> johnw: I have no idea what "small" would even mean in that context
16:17:17 <shachaf> johnw: (<), rather than (≤)
16:17:19 <johnw> gotta run now though, see you guys later tonight
16:17:20 <CodeDmitry> is xml a domain specific language?
16:17:50 <CodeDmitry> markup language is a language..
16:18:12 <johnw> shachaf: ah, thanks, that's easy
16:18:17 <CodeDmitry> i never write domain specific code...
16:18:17 <napping> CodeDmitry: the point of the first paper is to show by parametericity that (forall a . ((a -> a) -> a) -> (a -> a -> a) -> a) is actually a perfectly adequate representation of untyped lambda calculus
16:18:28 <shachaf> johnw: They're not equivalent.
16:18:57 <napping> gets a little hairy with Kripe logical relations and stuff, but there are nice examples translating back and forth from DeBruijn representations
16:19:15 <CodeDmitry> looking at that gives me a headache, and i cant see how lambda calculus relates in haskell, since haskell is a study of change
16:19:28 <CodeDmitry> haskell hastes change ...
16:20:01 <Eiam> reading that reminds me why i failed calculus so much
16:20:05 <Eiam> (3 times)
16:20:28 <Eiam> i don't translate forced knowledge into applied knowledge very well =)
16:20:33 <elliott> CodeDmitry: ? The lambda calculus is pure too.
16:20:43 <CodeDmitry> pure change?
16:20:52 <CodeDmitry> head=explode
16:20:56 <napping> the next takes it a bit farther, looking at adding some values and typed syntax and stuff, the idea being that you want to offer a nice hoas-ish syntax for your query language or whatever, and still be able to turn it into DeBruijn or something for optimization or serialization or whatever
16:21:27 <elliott> CodeDmitry: I don't understand.
16:21:43 <CodeDmitry> its okay, you don't have to understand, i don't know lambda calculus
16:21:53 <CodeDmitry> i just know what i was taught is "calculus"
16:21:59 <jmcarthur> CodeDmitry: is there a spec for lolcode somewhere?
16:22:07 <CodeDmitry> yeah
16:22:12 <jmcarthur> nevermind
16:22:14 <jmcarthur> i found some
16:22:27 <CodeDmitry> lolcode is very interesting
16:22:50 <jmcarthur> looks pretty run-of-the-mill to me, as a language
16:22:55 <jmcarthur> just silly syntax, is all
16:22:56 * Lethalman just managed to generate gtk3hs bindings from haskell-gi \o/
16:23:03 <CodeDmitry> although my idea to lolcode was to write lolcode, then transfer it into another language
16:23:08 <jmcarthur> does it have anything interesting, semantically?
16:23:16 <CodeDmitry> so that you can make university assignments in lolcode
16:23:17 <napping> jmcarthur: you might prefer Unlambda
16:23:21 <CodeDmitry> then submit them as serious programs
16:23:29 <jmcarthur> napping: yeah i am familiar with unlambda
16:23:47 <shachaf> Surely Lazy K is more popular here?
16:23:49 <jmcarthur> napping: it's just SK, right?
16:23:51 <napping> jmcarthur: I contributed the Haskell implementation
16:24:00 <timau> iis there a function that replaces one element in a list? (or rather returns a new list with replaced element)
16:24:10 <napping> nah, Unlambda throws in call-cc and some kind of crazy delay operation
16:24:14 <jmcarthur> ah
16:24:19 <shachaf> @unlambda `.u`.li
16:24:19 <lambdabot>   lu
16:25:13 <CodeDmitry> ugh why did c++ reimplement sizeof...
16:25:25 <SamanthaD> oh god... unlambda...
16:25:31 <Lethalman> timau, replace :)
16:25:36 <Lethalman> @hoogle replace
16:25:36 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Replace :: TextureFunction
16:25:36 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
16:25:36 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
16:25:38 <jmcarthur> i don't think i could take lolcode seriously long enough to write a compiler for it
16:25:50 <Lethalman> mh no Data.List.Utils perhaps
16:25:58 <timau> sorry, I meant replace an element given index
16:26:09 <shachaf> jmcarthur: It seems like a boring language with a mildly unusual syntax.
16:26:28 <napping> I guess if I baked type El t :: * into my "Representable" class, I'll probably need to bake some stuff for evaluation into the Pattern class too
16:26:32 * arfy hates lolspeak in any case. or rather, txt speak.
16:26:43 <shachaf> napping: What's Representable here?
16:26:57 <arfy> plz take me out l8r? ppl r coming 2 c me. just no
16:27:17 <absence> is ghc-core lazy or strict?
16:27:24 * shachaf suspect this whole thing is pretty off-topic for #haskell.
16:27:32 <shachaf> absence: Core is lazy, like Haskell.
16:27:37 <napping> shachaf: in "Unembedding Domain-Specific Languages", the typed representations have operators like tlam :: (exp a -> exp b) -> exp (a :-> b)
16:27:46 <shachaf> Though it's simpler.
16:27:48 <napping> then a type class constraining a and b
16:28:18 <CodeDmitry> im surprised haskell doesnt have units of measurement though
16:28:18 <absence> shachaf: there's no strict intermediate language before it goes to the backend?
16:28:31 <napping> In the paper they just consider a fixed language of types and their type class coughs up singleton in some GADT
16:28:36 <c_wraith> CodeDmitry: sure it does. There are packages for that on hackages
16:28:40 <c_wraith> *hackage
16:28:51 <c_wraith> ...  hackages of packages.  Where's Dr. Seuss?
16:28:53 <napping> could probably have used datakinds, if the paper was more recent
16:28:53 <CodeDmitry> i want to define my own units though
16:29:02 <CodeDmitry> well i dont want to, but sometimes i need to
16:29:07 <c_wraith> I think one of the packages allows that
16:29:13 <timau> is there a function like this?  setAt 0 'z' "foo"  ->  "zoo"
16:29:18 <CodeDmitry> that's not very confident
16:29:19 <CodeDmitry> :\
16:29:24 <shachaf> absence: Not really.
16:29:49 <napping> I'm not sure I can get reasonable extensibility by switching to a class, actually
16:30:06 <shachaf> > set (element 0) 'z' "foo"
16:30:07 <lambdabot>   "zoo"
16:30:33 <timau> nice
16:30:43 <shachaf> timau: (This is using COntrol.Lens)
16:30:47 <napping> parametricity in the "exp" type is crucial, but different interpretation functions might have different sets of "representable" types
16:31:37 <napping> but getting fancy enough with Constraint might work there
16:31:39 <Lethalman> :t set
16:31:40 <lambdabot> Setting s t a b -> b -> s -> t
16:31:59 <kennyd> shachaf that kind of reminds me of places in lisp
16:32:00 * Lethalman doesn't even try...
16:32:08 * hackagebot ConstraintKinds 0.0.2.0 - Repackages standard type classes with the ConstraintKinds extension  http://hackage.haskell.org/package/ConstraintKinds-0.0.2.0 (MikeIzbicki)
16:32:24 <shachaf> kennyd: Except without mutation!
16:32:27 <jmcarthur> absence: the STG machine natively supports laziness. i guess its implementation is where strictness comes in
16:32:34 <kennyd> shachaf yeah obviously
16:32:35 <shachaf> kennyd: Can places in lisp do
16:32:54 <shachaf> > set (traverse.element 0) 'z' ["foo","hello","norway"]
16:32:56 <lambdabot>   ["zoo","zello","zorway"]
16:34:18 <timau> lens is a third party lib?
16:34:32 <shachaf> Yes
16:34:51 <heatsink> Does ekmett count as a third party, or a component of Haskell?
16:35:03 <Lethalman> naively :) replace n x xs = (fst $ splitAt n xs) ++ [x] ++ (drop 1 (snd $ splitAt n xs))
16:35:32 <shachaf> Lethalman: You should pattern-match more. It's good for you.
16:35:37 <edwardk> heatsink: i've fought attempts at standardizing me. i fear what that would do for my rate of development ;)
16:35:49 <Lethalman> shachaf, would look bad on a one liner :P
16:35:55 <shachaf> Lethalman: It would look better.
16:36:00 <glguy> edwardk: It might help you stay young. Standardization processes tend to be very slow
16:36:08 <kennyd> shachaf I believe you would have to define your own place to accomplish that
16:36:08 <shachaf> Lethalman: (There are simple names for fst . splitAt n and snd . splitAt n)
16:36:17 <glguy> Imagine being edwardk-2013 for *years*
16:36:23 <Lethalman> shachaf, ?
16:36:28 <shachaf> drop and take?
16:36:41 <edwardk> live fast, die young, then other people have to do all the code maintenance
16:36:43 <Lethalman> right
16:36:47 <timau> is there a similar function in standard haskell li ?
16:36:50 <shachaf> But you should patttern-match.
16:36:51 <timau> setAt
16:36:56 <shachaf> timau: No.
16:36:59 <edwardk> timau: no there isn't
16:37:05 <Lethalman> shachaf, but that needs another let or where
16:37:13 <shachaf> timau: The main reason is proably that if you're doing a lot of indexing into lists, you're doing something wrong.
16:37:16 <edwardk> timau: in general if you have a list and you need to set things at specific positions in it you picked the wrong data structure
16:37:19 <shachaf> And you probably shouldn't be using lists. :-)
16:37:26 <shachaf> Lethalman: Yes, and?
16:37:39 <Lethalman> shachaf, and does that work in lambdabot?
16:37:51 <shachaf> replace n x xs = (fst $ splitAt n xs) ++ [x] ++ (drop 1 (snd $ splitAt n xs))
16:37:52 <shachaf> replace n x xs = let (a,b) = splitAt n xs in a ++ x ++ drop 1 b
16:38:01 <CodeDmitry> There is no wrong is computer science just ineffective in some dimension
16:38:02 <shachaf> This is shorter and simpler than what you wrote.
16:38:04 <Lethalman> ok
16:38:18 <shachaf> So you should pattern-match more. :-)
16:38:22 <CodeDmitry> Not everything has to be practical, some things have to be tested
16:38:31 <Nereid> not to mention it doesn't compute the splitAt twice
16:38:48 <Lethalman> > let replace n x xs = a ++ [x] ++ b where (a,b) = splitAt n xs in replace 2 5 [1,2,3,4,5]
16:38:50 <lambdabot>   [1,2,5,3,4,5]
16:38:58 <timau> i want to solve eight queens problem and I used list of lists to represent a chess board
16:39:07 <Lethalman> ok thought it didn't work in lambdabot
16:39:26 <CodeDmitry> oh god i just imagined what it would be if haskell allowed side effects, it would be unusable
16:39:28 <CodeDmitry> >.>
16:39:56 <Lethalman> > let replace n x xs = a ++ [x] ++ drop 1 b where (a,b) = splitAt n xs in replace 2 5 [1,2,3,4,5]
16:39:58 <lambdabot>   [1,2,5,4,5]
16:40:17 * Lethalman likes where more than let
16:40:19 <timau> should one use something other than [[Maybe Piece]] tp represent chess board?
16:40:27 <shachaf> Lists are almost certainly the wrong data structure here.
16:41:09 <edwardk> timau: Array (Int,Int) (Maybe Piece)     -- Map (Int, Int) Piece, etc. all of these give you faster access to individual elements
16:41:33 <edwardk> > M.fromList [(1,"Queen")] ^.at 1
16:41:35 <lambdabot>   Just "Queen"
16:41:41 <edwardk> > M.fromList [((1,1),"Queen")] ^.at (1,1)
16:41:43 <lambdabot>   Just "Queen"
16:41:46 <edwardk> > M.fromList [((1,1),"Queen")] ^.at (1,2)
16:41:47 <lambdabot>   Nothing
16:41:51 <saml> is lens good?
16:41:59 <Nereid> is haskell good?
16:42:03 <monochrom> yes to both
16:42:09 <ion> @faq Can Haskell be good?
16:42:09 <lambdabot> The answer is: Yes! Haskell can do that.
16:42:20 <Nereid> @faq is lens good?
16:42:20 <lambdabot> The answer is: Yes! Haskell can do that.
16:42:24 <Nereid> :(
16:42:52 <heatsink> @faq What should I eat for dinner tonight?
16:42:52 <lambdabot> The answer is: Yes! Haskell can do that.
16:43:30 <ion> > M.fromList [((1,1),"Queen")] & at (1,2) .~ Just "foo"
16:43:32 <lambdabot>   fromList [((1,1),"Queen"),((1,2),"foo")]
16:48:46 <Rileld> If anyone know how to use text-format, could you look at this paste, or just give me an example of a simple call to format? I'm banging my head against the wall trying to do this.
16:48:48 <hpaste> Rileld pasted “Can't figure out text-format?” at http://hpaste.org/80638
16:51:34 <shachaf> Rileld: Data.Text defines a type called "Text"
16:51:38 <shachaf> Rileld: Data.Text.Lazy also defines a type called "Text"
16:51:43 <shachaf> They aren't the same type.
16:52:08 * hackagebot hsc3-plot 0.13 - Haskell SuperCollider Plotting  http://hackage.haskell.org/package/hsc3-plot-0.13 (RohanDrape)
16:52:39 <timau> I installed lenses via cabal. should I have installed lens instead?
16:53:01 <Ralith> you should have installed lensii
16:53:02 <shachaf> Yes.
16:53:05 <Ralith> or possibly lensopodes
16:53:08 <CodeDmitry> what does cabal stand for
16:53:25 <Ralith> what does CodeDmitry stand for?
16:53:28 <CodeDmitry> each time i use it i think of "that programming language everyone types in caps"
16:53:55 <shapr> CodeDmitry: the cabal homepage expands the acronym
16:53:56 <CodeDmitry> CodeDmitry stands for my name, with a prefix which is arbitrary and misused
16:54:41 <shapr> CodeDmitry: When in doubt, use the google :-)
16:54:58 <edwardk> timau: you want lens, not lenses
16:54:58 <CodeDmitry> Sending people to google is a rather odd way to maintain a community
16:55:05 <Rileld> shachaf: what, why would it do that? Is there some way to convert one to the other?
16:55:14 <timau> thanks
16:55:18 <CodeDmitry> My general answer is, its much faster to get a response from the community than searching google
16:55:23 <CodeDmitry> searching google is like searching a hash function
16:55:25 <CodeDmitry> it could be fast
16:55:27 <shachaf> Rileld: Because they're both useful types.
16:55:29 <CodeDmitry> it could take forever
16:55:45 <shapr> CodeDmitry: that feels like you want me to do your homework for you too
16:55:45 <shachaf> Rileld: The documentation for Data.Text.Lazy should tell you how to convert
16:56:51 <Rileld> shachaf: I don't especially need this to be lazy. Is there some easier way of doing this that won't force me to convert back and forth?
16:57:31 <shapr> CodeDmitry: I think part of community maintenance is to try Google first and see if you can answer your own question that way before asking the community.
16:57:36 <linduxed> let's say that i've got two TestList. is there some way to group them to run them at the same time?
16:57:46 <CodeDmitry> shapr you're right in that respect
16:57:47 <linduxed> or should i group them in cabal or something?
16:58:05 <shapr> CodeDmitry: While the community can answer more quickly, the community is also a limited resource where overuse will cause removal of the questioner.
16:58:25 <CodeDmitry> sounds reasonable
16:59:20 <shachaf> Rileld: If something uses lazy Text, then it uses lazy Text, I think.
16:59:27 <shachaf> I don't know much about the specifics of the thing you're using.
17:02:07 <Rileld> shachaf: that makes two of us, lol. It's this http://hackage.haskell.org/packages/archive/text-format/0.3.0.7/doc/html/Data-Text-Format.html
17:03:43 <heatsink> To be an instance of Storable, does a type's stored form have to be memcpyable?
17:04:28 <timau> could setting an element in a 2d list be done more elegantly?
17:04:43 <hpaste> timau pasted “setting an element” at http://hpaste.org/80639
17:07:00 <fmap> > set (element 1 . element 1) 10 [[1,2,3],[4,5,6],[7,8,9]]
17:07:01 <lambdabot>   [[1,2,3],[4,10,6],[7,8,9]]
17:07:13 <shachaf> Rileld: Looks like it's using lazy Text, so just use lazy Text?
17:07:30 <timau> fmap that is pretty awesome
17:07:56 <hpaste> Rileld annotated “Can't figure out text-format?” with “Can't figure out text-format?” at http://hpaste.org/80638#a80640
17:08:49 <Rileld> shachaf: ya, I figured that part out. It seems that I'm not using the builder correctly too.
17:09:42 <Rileld> My change was to switch the import from Data.Text to Data.Text.Lazy
17:09:58 <shachaf> Rileld: Well, look at the type of format.
17:10:04 <invincible_tears> quick question: If I have a function that does something like (f 2) + f 2)...Haskell is smart enought to only calculate (f 2) ONCE, rigth?
17:10:21 <shachaf> invincible_tears: No. In many cases this is not a good optimization.
17:11:06 <invincible_tears> It's not? I must be missing something. I thought "f" is guaranteed to issue the same result for the same input
17:11:35 <shachaf> It is.
17:11:48 <elliott> invincible_tears: Sometimes GHC will only calculate it once but often it won't.
17:11:54 <shachaf> It's a valid transformation, but that's not the same as being a good optimization.
17:12:41 <shachaf> Of course, you can always say let x = f 2 in x + x
17:12:47 <glguy> invincible_tears: It might make a lot of sense when dealing with Ints, but it might not make sense in other situations
17:12:54 <Rileld> shachaf: Is the error for Format? I thought that part was OK, and the error was to do with B.fromString
17:13:28 <shachaf> Rileld: Well, you're passing that as an argument to format, so it had better match.
17:13:35 <shachaf> Look at the type for format. What is it?
17:13:50 <glguy> invincible_tears: If you want a good term to Google for to learn more, try "Common Subexpression Elimination"
17:14:31 <Rileld> shachaf: Sorry, we were talking about different formats. The type of the first argument to format is a Format
17:14:49 <shachaf> rileld: OK, that one looks fine. How about the second argument?
17:15:06 <invincible_tears> glguy: thanks
17:15:11 <shachaf> (Which is the one you were saying is the problem, after all.)
17:15:50 <Rileld> shachaf: It involves typeclasses, which is where I got confused. It should have type Params
17:16:12 <Rileld> shachaf: but I think the Builder is an instance
17:16:14 <shachaf> You're looking at the documentation you linked to, I assume.
17:16:22 <Rileld> ya
17:16:25 <shachaf> It should have a type which is an instance of Params.
17:16:32 <shachaf> Can you name some instances of Params?
17:16:51 <Rileld> Buildable?
17:17:00 <shachaf> Buildable isn't a type.
17:17:19 <shachaf> (Click the link "Params".)
17:18:33 <Rileld> Yeah, and there's a list of instances, like Buildable a => Params [a]
17:19:01 <shachaf> OK, so that means that [a] is an instance of Params, whenever a is an instance of Buildable.
17:19:09 <shachaf> So you should be able to pass a list to format.
17:19:23 <Rileld> A list of Buildable?
17:19:43 <shachaf> A list of a, where a is an instance of Buildable.
17:19:49 <shachaf> Types are very different from type classes.
17:19:54 <shachaf> Can you name some instances of Buildable?
17:20:27 <Rileld> Builder. It works!
17:20:33 <Rileld> Thanks!
17:21:14 <shachaf> Rileld: I think String/Text/something is also an instance.
17:21:19 <shachaf> So you can just use that directly.
17:23:33 <Rileld> Strings do work, but I have to explicitly type the list as :: [B.Builder]
17:48:13 <napping> Does anything have kind * -> Constraint?
17:48:42 <cmccann> :k ((~) ())
17:48:43 <lambdabot> * -> Constraint
17:48:54 <cmccann> probably not what you meant though :P
17:49:00 <napping> ah, type classes too
17:49:02 <glguy> :k Eq
17:49:03 <lambdabot> * -> Constraint
17:50:01 <napping> I'm trying to capture higher-order contexts with a class
17:50:52 <napping> like (forall a b . (C a, C b) ===> C (a -> b))
17:51:17 <hrumph> in yesod what is most conventional way to inject html into a form label?
17:51:32 <hrumph> should i just call renderHtml on a hamlet?
17:51:38 <shachaf> hrumph: Maybe #yesod would know.
17:51:40 <hrumph> and use this as the label text?
17:51:44 <absence> when i end up with a lot of [[[], [], []],[[],[]]] etc that i have to concatmap, is there a data structure that commonly fits better?
17:51:57 <shachaf> absence: Maybe a difference list or something?
17:52:03 <shachaf> That's too vague to be able to say much about.
17:52:08 <hrumph> shachaf: that channel is silent. I admit i don't know if yesod questions are ot here or not
17:52:39 <shachaf> I assume anyone who knows about Yeosd would be in the other channel.
17:53:03 <napping> I'll see if a function of type (C1 vars) => ((C2 vars) => x) -> x works as a proof that C1 implies C2
17:54:22 <glguy> napping: It shouldn't. Maybe report it as a bug if it does
17:55:03 <shapr> @quote
17:55:03 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
17:55:41 <napping> glguy: why shouldn't that work?
17:56:32 <napping> looks like a proper higher rank type to me
17:58:17 <caseyjames> Hi, I'm new to haskell.  I have a question about a system for storing processes in a database that I'm having trouble getting a start with.  Would someone here mind taking a look at a post to suggest some ideas as to how to solve it?
17:59:02 <shachaf> Usually your best bet is to just ask, rather than wait for someone to volunteer.
17:59:14 <SamanthaD> caseyjames: what's the question?
17:59:55 <caseyjames> Here is the thread.  I need to store all processes like an undo stack for deterministic regeneration.
17:59:55 <absence> shachaf: dlist looks like it could work, thanks
17:59:56 <caseyjames> http://www.haskell.org/pipermail/haskell-cafe/2013-January/105699.html
18:00:58 <glguy> napping: I see, you just want to use it as an explicit tool
18:03:06 <napping> that's the idea, though a type system for higher-order contexts would be nice sometimes too
18:05:09 <SamanthaD> caseyjames: I'm still new to Haskell and don't really know how to work with databases but what you seem to want to do would be really easy to implement with a list. You'd just cons the last function onte the list of functions.
18:05:53 <SamanthaD> caseyjames: I don't know if that helps or not...
18:07:15 <caseyjames> That seems simple. Wouod it work to get functions that are creating internal state.  If a function is composed of other functions which themselves create a random value etc
18:07:42 <napping> wow, needed ScopedTypeVariables and InstanceSigs together to type this, but it seems to work
18:08:03 <napping> oh, and an instance signature with an explicit forall has to list the type variables in the same order as the class
18:08:24 <napping> (whatever arbitrary order that is, if you didn't use an explicit forall there)
18:11:05 <SamanthaD> caseyjames: Well... I imagine if you have a bunch of functions that change state you could always take the list of functions from the last function entered to the target function and fold it to derive the program state at the time that said function was implemented. Maybe you would have to write inverse function though so it would be possible. Though, I imagine that an undo stack based on reversing functions (rather than just
18:11:05 <SamanthaD> rolling back to an earlier state) would need that anyway.
18:13:01 <caseyjames> SamanthaD: That helps. Its going to take a moment to reset my thinking in terms of lists but thank you for the sense.
18:13:16 <SamanthaD> caseyjames: thanks for the question, it was an interesting problem.
18:14:17 <SamanthaD> caseyjames: If you have a list of functions fs and a function to transform a function to its inverse called toOther maybe you could implement the undo like thus:
18:15:00 <SamanthaD> caseyjames: sec... I had something in my head but then it went away.
18:22:10 * hackagebot hsc3-cairo 0.13 - haskell supercollider cairo drawing  http://hackage.haskell.org/package/hsc3-cairo-0.13 (RohanDrape)
18:23:48 <_Vi> Are there any online Haskell tests (to check current knowledge level)?
18:24:27 <shachaf> I certify your knowledge at level 259.
18:25:53 <ivanm> _Vi: you need to be able to un-obfuscate the code on the Haskell page on uncyclopedia
18:25:54 <ivanm> ;-)
18:26:32 <_Vi> I mean from simple to complex tasks with a scale at the end ("beginner - intermediate - advanced - expert")
18:27:01 <cmccann> jokes aside, no, I don't think there's really anything like that
18:27:22 <_Vi> Other programming language seem to have them here and there.
18:27:44 <ivanm> we keep shifting our goal posts
18:27:49 * cmccann doesn't recall seeing anything like that before and isn't sure how it would really work
18:27:57 <cmccann> seems like it'd end up too arbitrary to be useful :T
18:27:58 <ivanm> though realistically, to be an expert you need to be called "Oleg" :p
18:28:02 <ivanm> cmccann: yeah
18:28:22 <deus_rex> what about 99 haskell exercises?
18:31:26 <SamanthaD> _Vi: I think you can be considered good at a language when you can confidently implement a significantly complex problem and do it confidently and in a reasonable amount of time.
18:31:38 <SamanthaD> oops... that was a bit redundant of me
18:31:55 <monochrom> there is not enough money behind an online Haskell test
18:32:11 <cmccann> SamanthaD: yes but was it confidently redundant?
18:32:19 <SamanthaD> _Vi: I would consider someone an expert at a language if they can implement their solution and then document that it's correct ;)
18:32:27 <SamanthaD> cmccann: haha!
18:32:28 <monochrom> whereas I can see e.g. an online javascript test is part of an ad for a paid javascript course
18:32:58 <_Vi> I sometimes feel like if I can implement almost any problem in any language (with enough time and without quality requirements although).
18:33:03 <SamanthaD> monochrom: Those tests are useful for telling you that you need to get better at Javascript with the Javascript course!
18:33:28 <SamanthaD> _Vi: well if you can implement any problem like than then I'd say you're "Intermediate"
18:34:04 <shachaf> Why do you care whether you are Beginner or Intermediate or Advanced at Haskell?
18:34:17 <shachaf> Maybe what you want to do with that information is something that can better be done another way.
18:34:30 <SamanthaD> shachaf: what if you're thinking of putting it on your resume?
18:34:44 <_Vi> Just if there were such test it may be interesting to click though it to see the number (and then revisit the test after a year).
18:35:17 <SamanthaD> shachaf: I imagine if I said I was an expert at Standard Blurb my potential boss would expect me to be able to do certain problems in certain amounts of times and at certain levels of confidence.
18:36:18 <SamanthaD> _Vi: 99 Haskell Problems might be your cup of tea :3
18:36:34 <shachaf> @where pi_10
18:36:34 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
18:36:37 <shachaf> Hmm, no.
18:36:38 <shachaf> @where e_10
18:36:38 <lambdabot> [show(sum$scanl div(100^n)[1..[4..]!!n])!!n|n<-[0..]]
18:36:46 <_Vi> It's for myself (just curious and like tests), not for bosses. /* My subjective "level of confidence" jumps from 0 to +Inf though NaN */
18:36:52 <shachaf> _Vi: You score one point for every character you manage to shorten that.
18:37:02 <shachaf> Actually I bet you score points exponentially.
18:37:11 <shachaf> @where pi_11 -- doesn't count
18:37:11 <lambdabot> [show(foldr(\k a->20*100^n+a*k`div`(2*k+1))0[1..[4,8..]!!n])!!n|n<-[0..]]
18:37:20 <shachaf> (That works but is too slow to be of any use.
18:37:22 <SamanthaD> _Vi: To be fair, I'd say all of our levels of confidence are NaN
18:40:03 <SamanthaD> There's actually an interesting phenomenon in psychology--off the top of my head I can't remember what the theory is called--where those who are novice in a particular field overestimate their own competence and underestimate others' whereas as they gain experience they begin to underestimate their competence and overestimate others'
18:40:18 <monochrom> Kruger-Dunning
18:40:26 <SamanthaD> monochrom: yes, that's it
18:40:28 <startling> Dunning-Kruger!
18:40:32 <cmccann> @google dunning-kruger effect
18:40:34 <lambdabot> http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect
18:40:34 <lambdabot> Title: Dunning–Kruger effect - Wikipedia, the free encyclopedia
18:41:31 <ksf> also quickly paraphrased as "dumb people think they're smart, smart people think they're dumb"
18:41:57 <monochrom> as a corollary, you should doubt advice from experts and opinion leaders. their advice works for people at their competency, and they give you that advice --- but clearly they overestimate your competency
18:41:59 <cmccann> which is misleading, because it's more about acquired skill than intelligence as such.
18:42:12 <_Vi> I usually try to gain at least some minimum info in each sphere that can happen to be near things I may be working at to avoid the effect.
18:42:21 <Ralith> in my experience smart people don't think they're dumb so much as recognize that there are very sharp limits to their knowledge, and that most things are outside those limits
18:42:33 <Ralith> oh wait this is #haskell
18:42:40 <Ralith> probably not the place for a discussion like that
18:42:52 <ksf> you can explain the whole thing quite easily with the information complexity of their thoughts: simple thoughts are way easier to grasp as whole, giving an air of much understanding, but simple thoughts also tend to overlook material facts.
18:43:07 <SamanthaD> Ralith: Clearly, we all know our competence is impeccable!
18:43:35 <Ralith> SamanthaD: that, and it's offtopic to go on at length about :p
18:44:39 <shachaf> I like to rate things on a scale of "devil" to "future".
18:44:43 * cmccann notes that #haskell is usually full of people who overestimate their ability to stay on-topic.
18:45:04 <ksf> in other news, I think I've come to the conclusion that FRP for GUIs ought to be considered harmful.
18:45:16 <ksf> not necessarily FRP for its semantics, but how it's actually practiced.
18:45:25 <monochrom> this is why I disbelieve in "understanding". it is a feeling. unreliable, unquantified, self-congratulating feeling.
18:45:50 <SamanthaD> ksf: why is FRP for GUIs harmful?
18:45:51 <cmccann> ksf: unfortunately I'd say the same about every approach to GUIs I've seen
18:45:55 <ksf> the model<->interface boundary gets blurred way too easy the way we do it.
18:46:07 <cmccann> if someone has figured out a sensible way to write GUI code I've never heard of it
18:46:24 <ksf> edje seems to get it vastly right, though I'm missing native supports for collections, there.
18:47:18 <shachaf> cmccann: My preferred approach to GUIs is not writing them.
18:47:24 <ksf> the general lesson one can learn from edje is "you should be able to change the whole interface without touching a single line of code".
18:47:26 <shachaf> Works pretty well for me.
18:47:32 <ksf> yes!
18:48:10 <ksf> a simple GUI ought to be derivable from the functions and data structures the application provides, and the rest can be left to designers.
18:48:15 <monochrom> wait, so what do you touch to change the whole interface?
18:48:27 <ksf> an interface description file.
18:48:29 <shachaf> monochrom: A column of code.
18:48:31 * cmccann is deeply skeptical of anything described as "change ___ without touching any code" where programming is concerned
18:48:36 <monochrom> haha shachaf
18:48:50 <monochrom> next, you're going to invent a diagonal of code, too
18:48:56 <cmccann> shachaf: why not a diagon--dammit monochrom
18:49:03 <monochrom> haha
18:49:04 <cmccann> >:[
18:49:12 <shachaf> monochrom: I hear Gödel or someone already did that.
18:49:17 <monochrom> true!
18:49:41 <cmccann> I don't think I want gödel building my GUIs though
18:50:02 <ksf> think "AJAX done right"
18:50:16 <shachaf> cmccann: Why not?
18:50:41 <ksf> ...where the javascript part is, strictly speaking, completely unnecessary.
18:50:47 <SamanthaD> shachaf: Because he wasn't a cognitive psychologist
18:50:49 <cmccann> shachaf: well obviously the project would always be incomplete
18:51:22 <monochrom> in some sense I disagree that a GUI can be derived from the data structures and operations
18:51:45 <ksf> well, it might not be pretty.
18:51:52 <SamanthaD> I agree with monochrom: A GUI should reflect good psychology. Data structures be damned.
18:51:57 <ksf> but it'd be functional, and a useable prototype.
18:52:06 <monochrom> I am talking principle. can't be done in principle. insufficient information.
18:52:08 <loblaw> Is this accurate: "All monads are applicatives, but only some applicatives are monads" ?
18:52:15 <shachaf> loblaw: Yes.
18:52:25 <shachaf> loblaw: Well, it's true that you can make any instance of Monad an instance of Applicative.
18:52:27 <loblaw> shachaf: Thanks
18:52:35 <cmccann> loblaw: in principle or in actual type checker requirements?
18:52:37 <shachaf> It's not necessarily true that they all *are* instances.
18:52:46 <cmccann> because there's no class constraint, alas.
18:52:53 <loblaw> In principle
18:52:56 <cmccann> then yes
18:53:02 <loblaw> Any monad can mechanically be translated into an applicative
18:53:04 <cmccann> pure = return, (<*>) = ap
18:53:23 <shachaf> Every monad is also an invariant functor. Haskell is missing many superclasses.
18:53:36 <monochrom> let's say my model is Int. no operation on it, even. just display it. Int is my sole data structure. the whole program. that is all.
18:53:49 <loblaw> shachaf: How does an invariant functor differ from a regular functor?
18:53:56 <ksf> monochrom, somewhat like a clock?
18:54:07 <shachaf> loblaw: You only get invmap :: (a -> b) -> (b -> a) -> f a -> f b
18:54:26 <shachaf> More or less any "normal" Haskell 98 type is an invariant functor.
18:54:39 <cmccann> what about the abnormal types?
18:54:45 <ksf> monochrom, is that int labelled as editable or not? is it constant? it definitely has an identifier, though.
18:54:47 <shachaf> cmccann: Like IORef?
18:54:52 <ksf> ...even though that identifier might suck.
18:55:16 <monochrom> even with just this, there are a million known legit ways of displaying that Int. show the decimal notation. show a sliding bar. show a sliding bar horizontally. show a sliding bar vertically. show a sliding bar diagonally. and then there will be another million legit ways yet to be discovered
18:55:21 <shachaf> cmccann: Hmm, I guess IOrefs aren't in the standard.
18:55:22 <monochrom> s/discover/invent/
18:55:41 <shachaf> cmccann: Are there any Haskell 98 types that aren't invariant functors?
18:55:44 <ksf> monochrom, yes. and the derived gui would use a simple one, like the decimal notation.
18:55:53 <ksf> the user could then choose a different one.
18:55:56 <ksf> or the designer.
18:56:06 <ksf> but the point is: you don't have to touch any application code for that.
18:56:14 <cmccann> shachaf: that's not jurisdiction. I'll let you figure it out.
18:56:25 <cmccann> s/not/not my/
18:56:44 <shachaf> cmccann: If you allow e.g. polymorphic components then it's certainly not true.
18:57:23 <cmccann> besides, I can't remember the last time I tried to stay within the bounds of haskell 98.
18:57:29 <cmccann> it's dreadfully boring there.
18:57:48 <E0000> within the bounds of SML ;)
18:58:13 <shachaf> I wish Haskell had a good way to stick superclasses in hierarchies.
18:59:18 <monochrom> ok, i grant you that every ground type has a default display way, and every algebraic data type over those ground types has a default display way defined recursively. now you run into a restriction. many useful data structures are not algebraic data types. what is the default display for a queue? what is the default display for a ring buffer?
18:59:42 <cmccann> shachaf: type classes are awkward that way.
18:59:55 <E0000> Queue [a] [a]
18:59:58 <cmccann> we should just go back to dictionary passing.
19:00:04 <monochrom> or rather, "what is" is a wrong question. the right question is "who writes"
19:00:07 <ksf> a queue is a list. a ring buffer a circular one.
19:00:13 <ksf> we'd also need sets etc.
19:00:59 <monochrom> essentially, where "deriving Show" fails is exactly where "derive GUI" fails
19:01:09 <ksf> and I'm not saying there ought to be a derivable interface for every possible haskell type, there ought to be a derivable interface for everything that can be put into the interface API.
19:02:19 <monochrom> sure, but I'm attacking the idea of drawing a line between "application code" and "interface description file"
19:02:30 <ksf> primitives, (non-recursive) ADTs, lists, sets, maps, typed functions
19:02:49 <ksf> ...and signals. actor-style.
19:02:57 * cmccann is not at all convinced that this approach will even generate a useful UI anyway
19:03:23 <ksf> it's not supposed to. GUI deriving is merely a development aid.
19:03:40 <ksf> so that you can turn knobs without worrying about widgets.
19:03:55 <cmccann> well, I don't see how it would aid development, either.
19:04:05 <cmccann> it doesn't sound like it would actually save any work anywhere.
19:04:16 <monochrom> let me talk about Show first. no one says, "define data structures in Haskell code. for how to show, if you want the non-default way, write in a non-Haskell show description language"
19:04:34 <monochrom> instead, we say, write both in Haskell
19:04:43 <ksf> yes, if you want, do!
19:04:44 <monochrom> I am saying, do the same thing for GUI
19:05:10 <ksf> but what's the connecting part between interface and application?
19:05:17 * cmccann wonders if monochrom is including TH splices under "writing in Haskell" here
19:05:27 <ksf> if it's properly defined and powerful, you can run both separately.
19:06:29 <cmccann> expecting the UI and application to be separable sounds like a recipe for making both crippled and unusable
19:06:47 <ksf> ever heard of MVC?
19:06:54 <cmccann> as demonstrated by any attempt to bolt a GUI onto an existing non-GUI tool
19:07:02 <monochrom> ever heard of MVC written in 3 different languages?
19:07:24 <ksf> you don't have to write it in three different languages.
19:07:24 <mun> in logic, what is the "head of an expression"?
19:07:36 <ksf> though a proper separation would mean that you could, if you really wanted to.
19:07:56 <ksf> the interface part, for one, usually doesn't need any turing-capacities, at all.
19:08:06 <ksf> the model, neither.
19:08:09 <ksf> only the controller.
19:08:15 <E0000> monochrom: sql, smarty, php ;)
19:08:25 <monochrom> haha ok!
19:08:50 * cmccann is not convinced that the MVC approach actually works in practice in the general case either
19:09:05 <ksf> me neither.
19:09:14 <E0000> MVC smells like a limitation in dysfunctional languages
19:09:24 <E0000> rather than a guiding principle
19:09:36 <ksf> but if you had a GUI that could introspect what some webpage offers json-wise and point+click yoeur interface elements etc, that'd be cool.
19:09:51 <cmccann> ksf: it'd be cool in theory and horrible in practice, I expect
19:10:02 <mauke> let's talk about \k -> m Leaf >>= k instead
19:10:16 <mauke> and why it might be equal to m
19:10:23 <ksf> consider xchat, which I'm sitting in front of, here. Why can't I just drag+drop the input line-editor to the top?
19:10:43 <ksf> only the layout changes, none of the data connections.
19:11:08 <shachaf> mauke: What's Leaf?
19:11:08 <cmccann> layout is only "only layout" in some situations
19:11:29 <mauke> shachaf: data Tree a = Leaf a | Node (Tree a) (Tree a)
19:11:35 <ksf> ...that's why I want e.g. collections to be primitives in that protocol.
19:11:38 <E0000> uhg drag and drop
19:11:50 <ksf> and things can activate and deactivate.
19:11:53 <ksf> and so on.
19:12:00 <shachaf> mauke: What's the trouble?
19:12:17 <mauke> I don't understand what my code means
19:12:20 <cmccann> ksf: sounds great on paper, sure
19:12:24 <cmccann> won't work
19:12:30 <cmccann> except on toy examples
19:12:32 <ksf> defeatist.
19:12:38 <mauke> shachaf: I'm trying to understand codensity
19:12:52 <shachaf> mauke: Oh, is this ezyang's exercises?
19:12:53 <cmccann> ksf: no, empiricist.
19:12:54 <mauke> I'm at the beginning of http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
19:13:06 <cmccann> which is mostly the same as defeatist where GUIs are involved, true.
19:13:27 <mauke> I've written treerep/treeabs by doing random things that typecheck
19:13:58 <cmccann> ksf: I'm more than willing to be convinced by a working implementation with non-trivial demonstrations
19:15:05 <ksf> I think the whole thing is unproblematic, unless you want to use things you'd use a canvas for in traditional toolkits.
19:15:11 <shapr> etrepum: What version of diagrams do you have installed?
19:15:13 <mauke> and I think I can prove treeabs . treerep = id, just not the other way around
19:15:53 <shachaf> mauke: Hmm, is CTree actually isomorphic to Tree?
19:16:00 <shachaf> I would think that it's bigger.
19:16:18 <shachaf> (But maybe I'm confusing that with something else.)
19:16:37 <mauke> it only says "Please write functions which witness the isomorphism between the abstract and concrete versions of trees."
19:16:41 <mauke> no explanation
19:16:45 <etrepum> shapr: whatever cabal installs from hackage, looks like diagrams-svg-0.6.0.1, diagrams-lib-0.6, diagrams-core-0.6
19:16:56 <shapr> spiffy
19:17:08 <mauke> I don't even know which one is "abstract" and which one's "concrete"
19:17:34 <shachaf> I assume Tree is concrete, CTree is abstract.
19:17:43 <mauke> yes, the C stands for abstract
19:17:55 <cmccann> a concrete tree doesn't sound very nice.
19:17:55 <shachaf> I think C stands for "continuation" or something.
19:18:24 <mauke> treeabs :: CTree a -> Tree a
19:18:33 <mauke> clearly Tree a is the abstract tree
19:18:40 <mauke> because that's what treeabs gives you
19:18:41 <cmccann> well clearly abs stands for absolute value
19:18:54 <etrepum> shapr: what are your thoughts on snap (vs. scotty, I guess)? It seems like a lot of people are using it
19:19:29 <shapr> etrepum: I've only gone through the snap tutorial quite a few months ago, so nothing much to say about it.
19:19:45 <shapr> etrepum: but I do really like scotty from what I've done with it.
19:20:15 <mauke> my functions are: treerep t = CTree (\k -> t >>= k);  treeabs (CTree m) = m Leaf
19:20:25 <mauke> does this actually mean anything?
19:20:28 <etrepum> shapr: yeah, scotty looks fine, I only worry that people wouldn't know what to do with it since it's not as popular
19:20:45 <etrepum> shapr: it is nice that scotty is WAI and runs on Warp though
19:21:11 <cmccann> if you stick to unpopular things you can always say you liked them before they were cool.
19:21:13 <shapr> etrepum: It's been my experience that people inside the Haskell community are willing to try all sorts of exciting things.
19:21:15 <mauke> .oO( treerep = (>>=); treeabs = ($ return) )
19:21:36 <shachaf> Yep.
19:22:21 <shachaf> Without the newtypes, treerep :: Tree a -> (a -> Tree r) -> Tree r; treeabs :: (forall r. (a -> Tree r) -> Tree r) -> Tree a
19:22:54 <shachaf> edwardk: whoa, dude, that's just like Bazaar.
19:23:18 <edwardk> shachaf: whats that from?
19:23:20 <edwardk> just tuned in
19:23:33 <mauke> treeabs . treerep = id because m >>= return = m by monadery
19:23:45 <shachaf> edwardk: From "Asymptotic Improvements of Computations over Free Monads"
19:23:55 <edwardk> shachaf: oh, yes
19:24:00 <shachaf> edwardk: Anyway, Codensity is just like Bazaar for (>>=)
19:24:16 <sclv> this is unsurprising.
19:24:17 <shachaf> I hadn't made the association.
19:24:19 <edwardk> this doesn't surprise me they both cps to fuse
19:24:24 <shachaf> sclv: Right.
19:24:30 <mauke> "trivial"
19:24:39 <shapr> etrepum: Have you tried using snap?
19:24:42 <edwardk> shachaf won't be happy with a patch i'm working up
19:24:56 <cmccann> that's the best kind of patch.
19:24:58 <etrepum> shapr: not yet
19:25:12 <shapr> etrepum: My approach to choosing a framework is to try using several different frameworks for about an hour or two, and see which one has the best combination of community/code/sanity.
19:25:16 <edwardk> its the 'explode Internal into a thousand pieces' patch
19:25:21 <shachaf> edwardk: Uh oh. :-(
19:25:48 <shachaf> edwardk: Is "newtype CTree a = CTree { unCTree :: forall r. (a -> Tree r) -> Tree r }" actually isomorphic to Tree?
19:25:57 <shachaf> I would think that it'd be bigger.
19:26:02 <shapr> etrepum: I do the same thing with movies, I'll watching anything someone suggest for 15 minutes, and unapologetically walk away if I still don't like it :-)
19:26:17 <edwardk> shachaf: good intuition. did you see my blog series on free monads?
19:26:43 <shachaf> Free Monads For Less? I think I read some of it but not all.
19:26:46 <etrepum> shapr: yeah, I'm mostly just basing my opinion on what I've read so far and what other people I know are using. I haven't gotten far enough into something to write web code yet
19:26:56 <edwardk> shachaf: thats exactly what that series is about
19:27:30 <ksf> cmccann, http://mpd.wikia.com/wiki/Protocol_Reference , just generalised.
19:27:31 <shachaf> edwardk: So the exercise at http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/ , "Please write functions which witness the isomorphism between the abstract and concrete versions of trees.", is wrong?
19:28:04 <ksf> ...and a better support for collections. bi-directional update etc.
19:29:02 <mauke> shachaf: just underspecified. "abstract and concrete versions of trees" isn't defined anywhere
19:29:13 <mauke> the next exercise is possibly even worse
19:30:18 <mauke> "node = _EXERCISE_ -- How do you construct a node in the case of the abstract version?"  <- well gee, that was the whole problem in treerep
19:30:41 <mauke> now that I have treerep/treeabs, I can just do node p q = treerep (Node (treeabs p) (treeabs q))
19:30:50 <sclv>  think that specification is fine
19:30:55 <sclv> obv he means Tree and CTree
19:30:59 <sclv> the type signatures give it away
19:31:01 <mauke> sclv: I don't think so
19:31:06 <sclv> you don't even need the explanitory text
19:31:18 <shachaf> I think the puzzle may be to do it "directly".
19:31:22 <mauke> also, why doesn't treeabs build an abstract tree?
19:31:34 <mauke> what are these names even
19:31:50 <sclv> he describes CTree as a tree abstracted over the leaves
19:31:54 <sclv> so its obvious what he means
19:31:57 <mauke> sclv: what
19:32:08 <mauke> what does "a tree abstracted over the leaves" mean?
19:32:17 <mauke> and he doesn't say that's what CTree is
19:32:18 <sclv> he writes: "Now abstract over the /leaves/ of the tree"
19:32:20 <mauke> yes
19:32:36 <sclv> it is a transformation of a tree where one has abstracted over the leaves
19:32:42 <mauke> that doesn't mean all values of type CTree a are abstracted trees
19:32:46 <sclv> i agree he doesn't describe what "abstracting over" means
19:32:47 <mauke> sclv: what does that mean?
19:32:52 <sclv> but the types are obvious
19:32:56 <mauke> no, they aren't
19:33:03 <mauke> otherwise I wouldn't be doing this exercise
19:33:11 <sclv> he has a function Tree a -> CTree a and he says there's an isomorphism
19:33:17 <sclv> i don't mean the answer is obvious
19:33:22 <sclv> i mean the question is obvious
19:33:34 <mauke> sclv: isomorphism between what, though?
19:33:38 <sclv> one obviously writes a function of that type that witnesses the isomorphism
19:33:42 <sclv> between Tree a and CTree a
19:33:49 <sclv> just like the **@#$@#$@#$ signature of the function
19:33:58 <mauke> yes, and that's where I'm stuck
19:34:06 <sclv> as in you can't write the function?
19:34:09 <edwardk> shachaf: easy counter-example; take Codensity ((->) s)    and write a 'State' instance for it
19:34:24 <shachaf> sclv: Are they actually isomorphic?
19:34:40 <monochrom> ok, so "CTree a" is the abstract tree because "it abstracts over the leaves?" does it follow that "Tree a" is the concrete tree because "it concretes over the leaves?"
19:34:43 <sclv> hahah i haven't worked that through. i'm just saying what he's asking for in the exercises is obvious
19:35:07 <monochrom> perhaps s/concretes/concretizes/
19:35:16 <sclv> because the leaves "are" concrete i suppose
19:35:26 <sclv> although a tree with concrete leaves doesn't sound very practical
19:35:27 <mauke> sclv: no, as in I've written treerep/treeabs and I don't see what they're doing, only that they typecheck
19:35:30 <sclv> i'd imagine it would fall down
19:36:39 <edwardk> shachaf: m and Codensity m are not isomorphic in general
19:36:53 <edwardk> m and Yoneda m are
19:36:57 <edwardk> Codensity m is 'bigger'
19:37:13 <mauke> shachaf: re: "do it directly" - then why does it say "don't use rep/abs in your implementation" only for the exercise after that?
19:37:41 <mauke> edwardk: ok, so is this exercise simply wrong or just underspecified?
19:37:45 <edwardk> Codensity ((->) e)    = forall r. (a -> e -> r) -> e -> r   ~ e -> (a, e)    ~ State e
19:37:51 <shachaf> mauke: Actually, maybe it only matters for the monad instance. I'm not sure.
19:37:53 <edwardk> its just slightly naive
19:38:07 <edwardk> you can go back and forth here
19:38:34 <sclv> it looks like a reasonable exercise set to me
19:38:35 <edwardk> the trick is that Codensity f is bigger than f so you lose some information coming back
19:39:32 <mauke> sclv: that doesn't help me, though
19:40:42 <edwardk> for that codensity ((->) e) category this is where parametricity leads to wrong intuitions, because there is a category for which you can take an adjunction and show that Codensity ((->) e) is the same size as ((->) e), but that isn't in hask.
19:40:44 <napping> how many of these does Djinn get?
19:40:49 <edwardk> shachaf: http://comonad.com/reader/2012/unnatural-transformations-and-quantifiers/ talks exactly about this issue
19:41:17 <napping> C-c C-a tends to cut the knot a bit too much
19:41:31 <napping> listrep :: Hughes a -> [a]; listrep = \z -> []
19:41:34 <napping> that sort of thing
19:42:29 <shachaf> napping: Well, (Hughes a) is certainly not isomorphic to [a]
19:42:40 <lewie> hello. what would be a canonical way to go about this in haskell?
19:42:56 <hpaste> lewie pasted “mapM_” at http://hpaste.org/80643
19:43:48 <mauke> m >>= f = CTree (\k -> (unCTree m Leaf >>= (\a -> unCTree (f a) Leaf)) >>= k)  -- wtf am I doing
19:43:58 <johnw> lewie: use a foldM and don't delay in the terminal case
19:44:35 <shachaf> mauke: You can write (>>=) for CTree without ever using Leaf.
19:44:52 <monochrom> @type intersperse
19:44:53 <lambdabot> a -> [a] -> [a]
19:44:54 <mauke> yes, but I can do it this way too without having to think
19:45:05 <mauke> and the "exercise" provides no guidance
19:45:14 <shachaf> Sure.
19:45:18 <lewie> johnw: how would I recognize terminal case?
19:45:34 <Mortchek> @type foldM
19:45:35 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:45:51 <Mortchek> The a is the terminal case
19:45:54 <monochrom> I offer: sequence_ (intersperse (threadDelay 100000) (map (putStrLn . show) the_list)
19:45:55 <mauke> this is basically the >>= instance for Tree mangled through treeabs/treerep, then inlined
19:46:13 <Mortchek> i.e., the second parameter
19:46:58 <lewie> monochrom: that is neat
19:47:32 <johnw> yeah, that is the better solution
19:47:44 <lewie> I will try to figure out the foldM version too, not getting it yet
19:47:47 <johnw> intersperse actions between a list of actions
19:47:53 <johnw> lewie: something along the lines of foldM (\acc x -> if acc == 0 then terminal else do print x; return acc - 1) (length xs) xs
19:47:55 <johnw> is one way
19:48:21 <mauke> 'return acc - 1' looks very wrong
19:48:35 <johnw> the whole expression is sloppy, forgive me
19:48:59 <monochrom> I also forgot one )
19:49:12 <Botje> foldr1 (\str m -> putStrLn (show str) >> threadDelay 100000 >> m) list ?
19:49:48 <johnw> Botje: nice
19:49:56 <Botje> (or even sequence [threadDelay ..., putStrLn ..., m])
19:50:34 <johnw> i think intersperse expresses the intention most succinctly
19:50:40 <johnw> because that's really what he's wanting to do
19:50:50 <Botje> yep, definitely
19:51:22 <johnw> monochrom: print = putStrLn . show :)
19:51:29 <monochrom> yikes
19:52:12 * hackagebot gitit 0.10.1.2 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.1.2 (JohnMacFarlane)
19:52:38 <johnw> sequence_ (intersperse (threadDelay 100000) (map print xs)).  Expressions like that are why I love the functional way
19:53:02 <Botje> go all out then
19:53:13 <Botje> threadDelay 100000 `intersperse` map print xs
19:53:29 <johnw> oh, heck yes
19:53:40 <johnw> lewie: bask in the glory
19:54:10 <lewie> :). thanks everyone
19:54:10 <Mortchek> It's like a poetry slam but instead of poetry it's functional programming
19:54:27 <johnw> i'd say it's also poetry
19:54:33 <Botje> trying to out-elegant each other!
19:54:39 <johnw> it's an expression that satisfies an aestethic
19:54:46 <E0000> > fmap (+1) (False, 2)
19:54:48 <lambdabot>   (False,3)
19:54:58 <d_m> hi folks, can someone explain what :-> does (or link me to a place to find out)?
19:55:05 <johnw> @hoogle (:->)
19:55:05 <lambdabot> Test.QuickCheck.Function data (:->) a c
19:55:05 <E0000> im getting an error in ghci
19:55:20 <E0000> where do iget the instance for (e, x)
19:55:21 <d_m> johnw: ah thanks. so it's just used by quickcheck?
19:55:22 <liyang> > (False, 2) & _1 %~ not
19:55:24 <lambdabot>   (True,2)
19:55:41 <johnw> d_m: as far as hoogle knows, but hoogle doesn't index all packages
19:55:48 <d_m> ok thanks
19:56:51 <jozefg> If anyone here is from the Twin Cities (Minnesota) http://redd.it/16eeyb
19:57:00 <E0000> i got it by importing Control.Monad.Instances....
19:57:24 <johnw> E0000: that's the place to get it
19:57:35 <E0000> alrighty
19:57:38 <mauke> I can recommend http://www.iai.uni-bonn.de/~jv/mpc08.pdf
19:58:15 <shachaf> mauke: Does it clear up the "rep"/"abs" thing? :-)
19:58:30 <mauke> "rep" yes, "abs" no
19:59:09 <mauke> but from what I've seen so far it's vastly superior to the exercises purporting to teach this stuff
19:59:39 <shachaf> The exercises seem to be taking the types from that paper and replacing the code with _EXERCISE_.
19:59:59 <mauke> yes, and changing names and removing explanations and definitions
20:00:31 <mauke> exercise: "Please write functions which witness the isomorphism between ...". paper: "We easily have abs ◦ rep = id."
20:00:49 <mauke> give me the paper any day
20:09:58 <deus_rex> Is there a quick way to convert a .lhs file to .hs?
20:10:09 <mauke> "What was abstraction over leaves in the previous section, now becomes abstraction over the return method of a monad"  <- not quite true
20:10:32 <mauke> it's actually abstracting over "bind points" as far as I can see
20:10:45 <mauke> and by "bind points" I mean things >>= hooks into
20:11:26 <shachaf> mauke: Leaf corresponds directly to Return, doesn't it?
20:11:38 <mauke> what is Return?
20:11:56 <shachaf> Oh, I'm not sure which part you're referring to.
20:12:11 <shachaf> I was talking about data Free f a = Return a | Wrap (f (Free f a))
20:12:37 <mauke> newtype C
20:13:20 <shachaf> OK, so Return is defined at the top of that page.
20:14:08 <mauke> er. ok?
20:14:13 <mauke> where are you going with this?
20:14:28 <shachaf> It seems like any statement you can make about leaves in Tree you can make about Returns in Free.
20:14:49 <shachaf> So do you also disagree that the abstraction was over leaves in the previous section?
20:16:13 <mauke> "also"?
20:16:46 <shachaf> Oh, I thought you meant you agreed with the first part of the sentence but not the second.
20:16:53 <shachaf> Anyway, OK.
20:17:38 <mauke> my intuition is that rep m = C (m >>=) means we "hook into" whatever >>= accesses in the base monad
20:17:58 <mauke> this includes all instances of return x, but maybe other things too
20:18:17 <shachaf> You would also say that (x ++) "hooks into" the end of the list, or something along those lines?
20:19:43 <mauke> good question
20:20:03 <mauke> intuitively no because it doesn't take a function, but let's see ...
20:20:51 <twmb> how does one go about proposing a successful project for Haskell for Google summer of code?
20:20:53 <shachaf> Well, (++) takes a list and an argument and replaces the [] in that list with your argument.
20:21:33 <ivanm> twmb: find a mentor, discuss it with them, then when emails go out calling for proposals respond with your proposal
20:21:55 <mauke> shachaf: you're right, it is exactly analogous
20:23:39 <mauke> oh wow, this idea might have applications in silly parsers
20:23:49 <mauke> preflex: calc 1 2 3 + *
20:23:49 <preflex>  7
20:24:25 <shachaf> preflex: calc 1 2 3
20:24:25 <preflex>  Too many operands
20:24:36 <shachaf> preflex: calc 1 2 +
20:24:37 <preflex>  3
20:24:45 <shachaf> preflex: calc 2 3 +
20:24:46 <preflex>  5
20:24:48 <shachaf> preflex: calc 1 5 *
20:24:48 <preflex>  5
20:24:59 * shachaf must be missing something.
20:25:53 <mauke> shachaf: operator precedence?
20:26:28 <mauke> the basic parsing algorithm works by repeatedly inserting nodes into a (partial) tree
20:27:02 <mauke> the connection is that it has to walk down from the root each time to find the insertion point
20:27:09 <mauke> hmm
20:27:21 <mauke> doesn't actually apply in this instance
20:28:45 <mauke> the source of potential inefficiency is the same: repeatedly walking down a tree to substitute a leaf
20:29:00 <mauke> but I don't think the solution applies
20:30:01 <shachaf> Is the preflex code online somewhere, by the way?
20:31:25 <mauke> (the version implemented in preflex constructs a syntax tree from the operators alone, then inserts the numbers at the leaves afterwards)
20:31:50 <mauke> shachaf: I don't think so
20:32:13 * hackagebot cipher-rc4 0.1.2 - Fast RC4 cipher implementation  http://hackage.haskell.org/package/cipher-rc4-0.1.2 (VincentHanquez)
20:32:25 <shachaf> So C m a is like (>>=), pre-applied to one argument.
20:32:46 <shachaf> Just like Bazaar is like traverse, pre-applied to one argument.
20:33:14 <mrxy> is there a capitalize function?  capitalize "foo"  => "Foo"
20:33:56 <shachaf> > map (_head %~ toUpper) ["foo", ""]
20:33:57 <lambdabot>   Not in scope: `_head'
20:33:57 <lambdabot>  Perhaps you meant one of these:
20:33:57 <lambdabot>    `head' (imported ...
20:33:59 <shachaf> > map (element 0 %~ toUpper) ["foo", ""]
20:34:00 <lambdabot>   ["Foo",""]
20:35:42 <mauke> shachaf: there's probably a better word for it but I've always called this kind of thing "predereferenced"
20:36:31 <shachaf> mauke: The function-applied-to-an-argument thing?
20:37:21 <shachaf> (Why dereferenced?)
20:38:27 <mauke> it's more general than that
20:39:30 <mauke> I don't know where I first came up with the name ... probably an interpreter written in C
20:41:13 <mauke> I think I found a way to save some runtime overhead by doing some parts of the work at compile time and caching the results
20:42:27 <mauke> and now the idea is linked to partial specialization / partial application in my head
20:42:46 <`nand`> what's C here? Is that Codensity or something?
20:42:50 <shachaf> Hmm, I'm not sure what that would look like in C.
20:43:05 <shachaf> `nand`: I think the most recent mention of C would be the language?
20:43:23 <`nand`> before that, ‘C m a’
20:43:34 <shachaf> That's Codensity, yes.
20:43:46 <shachaf> mauke: Note that Codensity's monad instance is identical to Cont's.
20:43:49 <shachaf> (And ContT's.)
20:43:57 <`nand`> Cont = Codensity Identity
20:44:06 <shachaf> `nand`: You mean Codensity (Const r)?
20:44:19 <`nand`> oh
20:44:24 <johnw> so is Codensity then the true mother of all monads?
20:44:47 <`nand`> yes, I do
20:45:05 <shachaf> johnw: In one sense, yes.
20:45:19 <`nand`> Codensity f is a Monad for any f
20:45:24 <`nand`> so one could say so
20:45:33 <shachaf> `nand`: I think one can say so more directly.
20:45:53 <shachaf> (>>=) :: forall m. Monad m => m a -> (forall b. (a -> m b) -> m b)
20:46:13 <johnw> well, I read an article showing how every monad can be expressed as a specialization of Cont, so if Cont is a specialization of Codensity...
20:46:35 <`nand`> do you mean http://blog.sigfpe.com/2008/12/mother-of-all-monads.html ?
20:46:41 <shachaf> Codensity m a = forall r. Cont (m r) a
20:46:42 <johnw> yep
20:47:00 <johnw> shachaf: so then we are using Cont to define Codensity, not the other way round?
20:47:13 <shachaf> Cont r a = Codensity (Const r) a
20:47:21 <johnw> ok :)
20:47:34 <shachaf> (Obviously Codensity is better, though.)
20:47:41 <shachaf> Codensity gives you that forall on the inside.
20:47:48 <shachaf> You can't write callCC for Codensity.
20:48:36 <`nand`> but you should be able to for Codensity (Const r) a?
20:49:02 <shachaf> Sure.
20:50:22 <shachaf> mauke: How is it more general?
20:51:12 <mauke> shachaf: it's not limited to functions and arguments
20:52:12 <mauke> (we are now reverse engineering the voices in my head)
20:53:50 <otters> this is the most verbose channel I'm in since weechat started logging
20:53:52 <otters> by a good 300,000 lines
20:54:13 <`nand`> I'm under the impression that #haskell-lens might be even more active
20:54:29 <`nand`> at certain times, at least
20:54:30 <johnw> lol
20:54:40 <edwardk> at least on a per-user basis
20:54:41 <johnw> it's a higher burst rate, for sure
20:54:47 <johnw> but #haskell has a higher sustained rate
20:54:51 <`nand`> yeah
20:55:10 <johnw> and sometimes #haskell ⊂ #haskell-lens
20:55:13 <shachaf> edwardk: Does Control.Monad.Codensity not have foo :: m a -> Codensity m a?
20:55:39 <shachaf> It has lowerCodensity.
20:55:49 <monochrom> haha
20:58:13 <`nand`> shachaf: lift :: Monad m => m a -> Codensity m a
20:58:26 <shachaf> Oh.
20:58:49 <shachaf> That's a good point.
20:58:51 <edwardk> shachaf: http://hackage.haskell.org/packages/archive/kan-extensions/3.1.1/doc/html/src/Control-Monad-Codensity.html#Codensity has the MonadTrans instance
20:58:52 <shachaf> edwardk: Neever mind!
20:59:32 <mauke> if I want non-local returns (like setjmp/longjmp), what is the best monad?
21:00:22 <E0000> Cont !
21:00:28 <`nand`> interesting: instance MonadReader r m => MonadState r (Codensity m)
21:00:30 <shachaf> Cont gives you setjmp.
21:00:37 <shachaf> It also gives you more than that, though.
21:00:40 <mauke> yeah
21:00:50 <shachaf> I think it depends on what you want to do.
21:00:54 <mauke> I only need continuations that can be fired once
21:00:57 <shachaf> Either is enough for some things.
21:01:00 <mauke> and only while their surrounding context is still alive
21:01:13 <shachaf> Is that like an exception?
21:01:17 <mauke> yes
21:01:24 <mauke> but uncatchable
21:01:25 <shachaf> Either sounds reasonable to me, then.
21:01:39 <shachaf> Hmm.
21:01:41 <mauke> I can catch Either, though
21:01:46 <Abhijit> hi
21:02:01 <Abhijit> i am trying the sample bot code from haskell site and i am getting error could not find module Network
21:02:08 <Abhijit> this is the tutorial http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
21:02:16 <Abhijit> i am running suse 12.2 and i have install haskell
21:02:57 <Abhijit> my ghc version is 7.4.2
21:03:02 <`nand`> Abhijit: maybe you're missing package ‘network’?
21:03:23 <Abhijit> ok
21:03:23 <mauke> print with_return { my ($ret) = @_; sub { $ret->($_[0] * 2); die }->(21); die };  # this is the Perl code I'm thinking of replicating. it should output 42
21:06:39 <johnw> ah, Perl code, I love it for making me love all other languages more
21:07:19 <shachaf> Is it strictly necessary to insult people's languages every time they bring them up?
21:07:37 <johnw> I didn't say a single bad thing about Perl there
21:07:37 <E0000> yes
21:07:52 <johnw> asserting a positive is not a contra-assertion of the negative
21:08:17 <johnw> what if I love Perl, still it just makes me love all other languages *more* :)
21:08:17 <drbean> I wonder if I need a cabal file to get ghc-mod to find my modules.
21:08:43 <thoughtpolice> drbean: you don't, if they're organized hierarchally. but if you have one, it will use it
21:08:46 <mauke> johnw: you disgust me
21:09:05 <johnw> ?
21:10:07 <mauke> I didn't say anything bad about you. what if everyone else disgusts me more?
21:10:29 <johnw> well, disgust is still on the negative side of the spectrum.  You could say that you admire me least of all
21:10:48 <johnw> which might still be a heck of a lot of admiring, if you *really* love everyone else
21:11:01 <shachaf> Oh, come on.
21:11:07 <johnw> because the fact is, I still use Perl
21:11:12 <johnw> so it was just humor, shachaf
21:11:13 <Clint> who doesn't
21:12:11 <mauke> ok, so with_return is callCC
21:12:48 <shachaf> Yes.
21:12:56 <shachaf> setjmp is (more or less) callCC (return . fix)
21:14:21 <mauke> I don't understand that
21:14:36 <mauke> probably because of the "or less" bits :-)
21:14:45 <shachaf> @google trebla setjmp
21:14:46 <lambdabot> http://www.vex.net/~trebla/haskell/cont-monad.xhtml
21:14:59 <shachaf> @where+ setjmp http://www.vex.net/~trebla/haskell/cont-monad.xhtml
21:14:59 <lambdabot> Done.
21:17:14 <mauke> the difference is that longjmp takes an argument
21:17:34 <shachaf> I think you can build that on top of this.
21:17:56 <dolio> The problem is that something like that is too good.
21:18:02 <dolio> You can jump to it out of the scope.
21:22:35 <hrumph> i haven't studied arrows yet
21:22:38 <hrumph> how important are they?
21:22:49 * quchen seconds that
21:22:49 <johnw> do you mean Arrows the library?
21:22:55 <hrumph> the concept
21:23:08 <hrumph> i think i can make the website without knowledge of that
21:23:12 <johnw> arrows are a generalization of functions; you use them implicitly pretty much all of the time
21:23:21 <quchen> I only abuse arrows to give me nice tuple functions :s
21:23:30 <johnw> there's really no reason to study them just to use Haskell
21:23:54 <mauke> hrumph: not important
21:24:16 <hrumph> well at the yesod site one of the examples uses the fanout operator
21:24:28 * `nand` keeps forgetting to add ‘deriving Show’ when playing around in GHCi
21:24:37 <hrumph> i wasn't pleased to have to figure out what it meant since i haven't studied that topic yet
21:24:39 <lewie> I got disconnected and lost the code pasted by monochrom earlier tonight, using intercalate to insert thread delay action between printing actions. can someone please repaste it?
21:24:54 <shachaf> 19:45 <monochrom> I offer: sequence_ (intersperse (threadDelay 100000) (map (putStrLn . show) the_list)
21:24:57 <shachaf> That?
21:24:58 <`nand`> :set -XStandaloneDeriving and ‘deriving instance Show Foo’ mitigates that somewhat; but it would still be cool if I could instruct GHCi to auto-derive Show or something
21:25:20 <shachaf> `nand`: Define a ghci command, :data, that append "deriving Show" to your declaration.
21:25:26 <mauke> lewie: see /topic for channel logs
21:26:04 <`nand`> shachaf: good idea
21:26:11 <lewie> ah so it was intersperse not intercalate. anyway, pretty awesome idea
21:26:12 <`nand`> (assuming I remember to type :data instead of data when I want a Show instance)
21:26:24 <`nand`> putStrLn . show = print
21:26:47 <lewie> yeah, heh. I did that originally
21:31:44 <hrumph> i'm finding learning yesod to be quite difficult
21:33:30 <shachaf> dolio: Why you can you jump to it out of the scope?
21:33:44 <shachaf> Oh, you mean this "setjmp" in general, not just the variety with the argument?
21:35:10 <dolio> Because it's a continuation, not a stack jump.
21:35:38 <johnw> hrumph: which part in particular?
21:36:11 <hrumph> all the typing
21:36:23 <hrumph> let me give you an example hold on
21:37:11 <hrumph> i had a long time understanding that RenderMessage master msg could just be Text
21:37:42 <roconnor> @type (<**>)
21:37:43 <lambdabot>     Ambiguous occurrence `<**>'
21:37:43 <lambdabot>     It could refer to either `Control.Applicative.<**>',
21:37:43 <lambdabot>                              imported from `Control.Applicative' at State/L.hs:4:1-26
21:37:52 <roconnor> @type (Control.Applicative.<**>)
21:37:53 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
21:37:58 <mrxy> is there a version of read, either standard or from a third party library, that throws a more descriptive error?  ideally "failed to parse <value> to <type>", or something similar
21:37:59 <hrumph> i don't understand why renderHtml has the types that it has
21:38:11 <hrumph> that's not yesod's problem though
21:38:18 <hrumph> i'm not using renderHtml anymore anyway
21:38:23 <johnw> hrumph: what is the typE?
21:38:59 <hrumph> it can have several types depending on what signature you give it
21:39:15 <johnw> that didn't really make sense to me
21:39:29 <hrumph> doesn't to me either i said i don't understand it
21:39:38 <johnw> what do you mean by "signature"?
21:40:05 <hrumph> wait i think i'm talking about the wrong thing
21:40:10 <`nand`> mrxy: there's ‘readEither’ which gives you Read a => Either String a; but it's not more descriptive than “Prelude.read: no parse”
21:40:12 <hrumph> i'm talking about the Hamlet blocks
21:40:29 <hrumph> the hamlet blocks can come to wildly different things depending on signatures
21:40:54 <shachaf> dolio: So what would be the alternative?
21:40:56 <hrumph> that confuses me no end and i don't have the foggiest clue what its all about. maybe it'll become clearer later on
21:41:04 <Nereid> that's called polymorphism
21:41:10 <johnw> can you define "signature" for me?
21:41:12 <johnw> do you mean type?
21:41:23 <`nand`> mrxy: you could make your own: readError s = maybe (Left $ "Could not parse `" ++ s ++ "'") Right (readMaybe s) -- or similar
21:41:26 <hrumph> yes the hamlet blocks have different types
21:41:30 <`nand`> throw in Typeable if you really want access to the type name
21:41:41 <mrxy> nanc nice thanks
21:41:43 <hrumph> i don't think i still have my examples but i'll look
21:42:08 <mauke> :t \s -> fix (\r -> case reads s of [(x, "")] -> x; _ -> error $ "failed to parse " ++ show s ++ " to " ++ show (typeOf r))
21:42:09 <lambdabot> (Read a, Typeable a) => String -> a
21:42:16 <johnw> yes, that is an example of polymorphism
21:42:35 <`nand`> oh, by “throws a more descriptive error” you meant an actual exception
21:42:36 <mauke> > (\s -> fix (\r -> case reads s of [(x, "")] -> x; _ -> error $ "failed to parse " ++ show s ++ " to " ++ show (typeOf r))) "123"
21:42:38 <lambdabot>   *Exception: failed to parse "123" to ()
21:42:39 <johnw> the concrete type of a particular hamlet block can depend on the type required by the function you're passing it to
21:42:46 <mauke> > (\s -> fix (\r -> case reads s of [(x, "")] -> x; _ -> error $ "failed to parse " ++ show s ++ " to " ++ show (typeOf r))) "123" :: Int
21:42:48 <lambdabot>   123
21:42:52 <dolio> shachaf: I don't know. Something with Either. But it's not that easy.
21:43:11 <E0000> does opengl work in a forkOS
21:43:19 <E0000> or do you have to use it from the main thread
21:43:24 <shachaf> Either has the problem mauke mentioned.
21:43:27 <hrumph> johnw: shouldn't something be done about that?
21:43:34 <johnw> hrumph: it's a huge feature
21:43:44 <johnw> if you want to "pin down" the type yourself, you can use a type annotation
21:43:47 <dolio> It's probably harder to emulate setjmp/longjmp faithfully than to do the less limited continuation.
21:44:12 <johnw> but trust me, you don't want to do that
21:44:18 <johnw> if you can show me some code, maybe I can help
21:44:32 <hrumph> i don't have any code that's not working at the moment
21:44:43 <johnw> so break some code and show it to me :)
21:44:43 <hrumph> i'm just having a rough time plowing through examples getting stuck here and there
21:44:54 <shachaf> dolio: I think mauke's original goal was an "uncatchable exception" out to a certain point.
21:45:16 <mauke> actually a non-local return
21:45:28 <mauke> because I'm thinking about Common Lisp-style conditions
21:45:58 <shachaf> This sounds like delimited continuations.
21:46:33 <mauke> limited delimited continuations :-)
21:46:52 <mrxy> what do common lisp conditions do that normal exceptions dont?
21:47:01 <johnw> they allow resuming
21:47:09 <hrumph> johnw: someone gave me ecellent advice. i wanted to make a form with radio buttons but in a table. that person suggested making a custom field. i'm going to give it a go tommorrow
21:47:43 <hrumph> with the custom field i'll be able to do  a table row for each radio button
21:48:05 <hrumph> johnw: do you agree with that approach?
21:48:28 <johnw> i use yesod, but i don't actually write web UIs with it
21:48:34 <johnw> so i'm not the person to ask about that kind of thing
21:50:32 <mauke> mrxy: http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html
21:51:25 <mauke> having recently implemented a condition system I can say that conditions are much less magical than they appear at first
21:52:02 <johnw> mauke: throwing a continuation would achieve the same thing, wouldn't it?
21:52:14 <mauke> johnw: same thing as what?
21:52:27 <johnw> conditions-with-resume
21:52:44 <mauke> it makes no sense to "resume" a condition
21:52:54 <mauke> the default behavior of 'signal' is to do nothing
21:52:58 <mrxy> mauke you implemented it in what language?
21:53:01 <mauke> mrxy: Perl
21:53:01 <johnw> i mean a restart, then
21:53:02 <sw2wolf> @hoogle free monad
21:53:03 <lambdabot> package control-monad-free
21:53:12 <johnw> whatever takes you back to the moment the condition was raised
21:53:22 <mauke> johnw: doesn't exist
21:53:27 <mrxy> would they be possible in haskell?
21:53:39 <mauke> also, restarts are basically dynamically scoped functions
21:54:02 <mauke> mrxy: probably?
21:54:21 <johnw> in http://en.wikibooks.org/wiki/Common_Lisp/Advanced_topics/Condition_System
21:54:27 <johnw> i mean the thing that lets you select RETRY
21:54:37 <mauke> what makes the whole thing (restarts and conditions (they're orthogonal)) useful is CL's ability to do a non-local return
21:54:40 <johnw> "go back and try to do what you were doing again"
21:55:58 <mauke> johnw: there's no code there
21:56:05 <lispy> PVP is kinda nice, package upper bounds create problems in practice. How to resolve it?
21:56:10 <mauke> not very useful for discussing this stuff
21:56:20 <johnw> mauke: i think RESTART-CASE is what allows it?
21:56:30 <johnw> anyway, n/m, this is taking too much work to describe
21:56:33 <shachaf> lispy: Write half the packages on Hackage, don't have upper bounds on dependencies on your own packages.
21:56:44 <mauke> johnw: restart-case is a macro around restart-bind and ... non-local return
21:56:53 <startling> lispy, I don't know, it sucks to get out of the tutorial and then be killed by an upper-level traversal right off the bat
21:57:47 <lispy> Want no hassle 'cabal install'
21:59:32 * lispy waits for darcs to finish
22:00:24 <lispy> shachaf: Some upper bounds are good. I'm just thinking we use them more often than we need them. Unfortunately, knowing which upper bounds you need is not really possible.
22:00:42 <lispy> (which ones you need *after* the fact)
22:01:03 <glguy> What's an "upper-level traversal"?
22:01:10 <shachaf> lispy: edwardk recently abandoned upper bounds on dependencies on other edwardk packages.
22:01:37 * `nand` believes in not preemptively restricting dependencies; only restrict what you know breaks
22:02:00 <lispy> shachaf: I don't blame him. I've started to do the same.
22:04:19 <shachaf> You can build exceptions on top of coroutines, right?
22:05:39 <johnw> shachaf: yes
22:05:42 <johnw> shachaf: see http://stackoverflow.com/questions/1995734/how-are-exceptions-implemented-under-the-hood
22:07:15 <shachaf> johnw: I'm not sure that answers much.
22:07:28 <johnw> it says that coroutines are a general case of which exceptions are a specialization
22:08:09 <shachaf> It says there's a general sort of thing of which coroutines and exceptions are both special cases.
22:09:12 <johnw> hmm
22:10:05 <johnw> i retract my answer then, pending further search
22:11:08 <SamanthaD> Odd thought... would I be that far off to postulate that a literal like 7 is just a function that return the value of seven?
22:11:34 <johnw> SamanthaD: it's not a function, it's a value
22:11:53 <lispy> SamanthaD: if you allowed for arity 0 functions, then sure
22:11:59 <SamanthaD> johnw: enh, I gess so. Oh well.
22:12:02 <johnw> a function in Haskell is always of type a -> b, for some a and b
22:13:24 <glguy> SamanthaD: You wouldn't be the first to confuse functions and values : http://conal.net/blog/posts/everything-is-a-function-in-haskell
22:13:41 <johnw> shachaf: http://stackoverflow.com/questions/3436471/how-are-coroutines-implemented?lq=1 claims "you can implement coroutines using exceptions and exceptions using coroutines")
22:15:19 <SamanthaD> So... if I were to write say, five = filter 5 [1..]
22:15:19 <SamanthaD> five is not a function?
22:15:32 <shachaf> five is a list.
22:15:34 <SamanthaD> I guess that makes sense
22:15:35 <shachaf> Alternative, a type error.
22:15:42 <shachaf> Because 5 is not (normally) a function.
22:15:50 <`nand`> note that numeric literals like 7 are polymorphic
22:15:57 <glguy> Functions in Haskell take exactly one argument
22:16:00 <`nand`> so you could instantiate them to functions, given a Num instance
22:16:03 <shachaf> `nand`: Yes, but that's only confusing things.
22:16:11 <`nand`> right, that's just being technical
22:16:12 <johnw> you'd need to say take 1 $ filter (==5) [1..]
22:16:15 <glguy> SamanthaD: but do read that blog post I linked to, it goes into a lot of this
22:16:16 <shachaf> SamanthaD: Everything you say still applies if we said 'a' instead of 5, right?
22:17:04 <SamanthaD> ghlguy: I loaded it in the background. I'm gonna go read it now.
22:17:09 <SamanthaD> shachaf: of course
22:17:30 <shachaf> OK, then ignore everything about polymorphic literals.
22:18:23 <SamanthaD> Anyway, thanks for the clarification. I'm going to read that blog post now.
22:19:41 <lispy> I guess the disappointing thing about not allowing nullary functions is the asymmetry between Nothing and Just. Just is a function but Nothing is not.
22:20:18 <johnw> that's why we have const
22:20:39 <lispy> I don't follow
22:20:57 <johnw> const Nothing is a function that always gives a Nothing, in the same way that Just is a function that gives a Just value
22:21:06 <johnw> the type is a -> Maybe a
22:21:17 <Nereid> more like a -> Maybe b
22:21:21 <johnw> ah, yes
22:21:25 <ion> shachaf: We want polymorphic character literals!
22:21:28 <E0000> im glad Nothing is not a function
22:21:31 <E0000> that makes no sense
22:21:34 <Nereid> exercise: show that any total such function is const Nothing
22:21:53 <Clint> mmm.. total
22:21:55 <johnw> Nereid: wait, why is it a -> Maybe b?
22:22:00 <Nereid> :t const Nothing
22:22:02 <lambdabot> b -> Maybe a
22:22:06 <Nereid> close enough
22:22:08 <ion> instance IsChar Int where fromChar = ord
22:22:09 <johnw> :t Just
22:22:11 <lambdabot> a -> Maybe a
22:22:24 <johnw> hmm... they aren't equal types?
22:22:30 <johnw> just isomorphic?
22:22:34 <Nereid> one is more general
22:22:37 <shachaf> They're not isomorphic.
22:22:41 <Nereid> :t const Nothing `asTypeOf` Just
22:22:42 <lambdabot> a -> Maybe a
22:22:55 <johnw> shachaf: they aren't?
22:23:08 <Nereid> a -> b and a -> a are different
22:23:17 <johnw> hm.. a -> Maybe a is a subset of a -> Maybe b, so i guess they are not
22:23:31 <Nereid> FSOV subset, sure
22:23:37 <Nereid> SFVO
22:23:38 <Nereid> FSVo.
22:23:40 <Nereid> I can't type.
22:23:42 <lispy> > Just `asTypeOf` const Nothing
22:23:43 <lambdabot>   No instance for (GHC.Show.Show (a0 -> Data.Maybe.Maybe a0))
22:23:43 <lambdabot>    arising from...
22:23:46 <johnw> npi
22:23:49 <lispy> :t Just `asTypeOf` const Nothing
22:23:50 <lambdabot> a -> Maybe a
22:24:10 <Nereid> FSVO
22:24:11 <Nereid> there we go.
22:24:11 <Clint> :t (const Nothing :: Maybe String) 555
22:24:13 <lambdabot>     Couldn't match expected type `Maybe String'
22:24:13 <lambdabot>                 with actual type `b0 -> a0'
22:24:13 <lambdabot>     In the return type of a call of `const'
22:24:22 <Clint> er
22:25:52 <lispy> I wonder if you could find/show a logical inconsistency when treating numbers, bools, Nothing, etc as nullary functions...
22:26:04 <E0000> its just unnecessary
22:26:43 <E0000> in like scheme and js you have to wrap everything in lambdas to keep it from being evaluated, im glad in haskell you dont because of laziness
22:27:07 <E0000> 6 is not a function
22:27:09 <E0000> its just 6
22:27:19 <Nereid> :t 6 a
22:27:20 <lambdabot> Num (Expr -> t) => t
22:27:25 <E0000> dammit
22:27:25 <E0000> lol
22:27:48 <Nereid> cale took away NumInstances.
22:27:53 <E0000> :t Nothing a
22:27:54 <lambdabot>     The function `Nothing' is applied to one argument,
22:27:54 <lambdabot>     but its type `Maybe a0' has none
22:27:54 <lambdabot>     In the expression: Nothing a
22:28:00 <Cale> Want it back?
22:28:04 <Nereid> no thanks
22:28:11 <Nereid> and while you're here, put (.) back to the Prelude version
22:28:18 <shachaf> ==Nereid
22:28:34 <`nand`> “The function `Nothing'” <- perhaps it's a bit odd for GHC to call it that when it isn't one
22:28:52 <Nereid> it's syntactically a function in that context.
22:29:03 <`nand`> ah
22:29:05 <`nand`> that makes sense
22:29:31 <lispy> This is interesting: http://encyclopedia.thefreedictionary.com/Empty+function
22:29:41 <shachaf> OK, so we have these four functions:
22:29:42 <shachaf> p a -> p (a,b); p a -> p (Either a b); p (a,b) -> p a; p (Either a b) -> p a
22:29:49 <shachaf> Right now we created four different classes for them.
22:29:57 <shachaf> What's a good generalization?
22:29:57 <Nereid> I'm out.
22:30:08 <shachaf> Nereid: :-(
22:30:23 <Nereid> p (f a) -> p (g a)
22:30:38 <shachaf> OK, and then what?
22:30:41 <Nereid> I dunno.
22:31:07 <shachaf> Note that any contravariant functor has the first and fourth functions; any normal Functor has the second and third.
22:31:16 <johnw> Profunctor?
22:31:43 <Nereid> "Sometimes, however, it is best not to consider the empty function to be constant"citation needed
22:31:44 <johnw> since it is a functor in both covariant and contravariant positions?
22:31:45 <Nereid> constant functions are those that factor through the terminal object in Set
22:31:58 <Nereid> :(
22:31:59 <lispy> The existence of an empty function from ∅ to ∅ is required to make the category of sets a category. (In a category, each objects need to have an "identity morphism", and only the empty function is the identity on the object ∅.) The existence of a unique empty function from ∅ into each set A means that the empty set is an initial object in the category of sets.
22:32:16 <Nereid> the empty set is the initial object in Set.
22:32:31 <elliott> shachaf: Also all our instances work for any copointed functor/pointed functor.
22:32:33 <elliott> Respectively.
22:32:34 <Nereid> having initial objects is a useful thing.
22:33:00 <lispy> Nereid: I was just quoting from the link I pasted
22:33:05 <Nereid> I know.
22:33:08 <shachaf> elliott: Rather than just (b,) and (Either b), you mean?
22:33:15 <elliott> Right.
22:33:36 <shachaf> We had to abandon that or something, didn't we?
22:33:36 <lispy> Using their notation, Nothing :: ∅ -> Maybe a
22:33:36 <elliott> Except the ones with the thing on the left are weird and don't work like that :(
22:33:36 <hpaste> “Edward Amsden” pasted “odd error while trying to make a ghc cross-compiler” at http://hpaste.org/80645
22:33:36 <elliott> They don't work for the Un versions, or rather I couldn't figure out how.
22:33:45 <fmapE> anybody have any clue about that error?
22:34:03 <fmapE> I'm trying to build a cross-compiler...which should have some chance of success according to the GHC wiki
22:34:18 <fmapE> but apparently ghc-cabal wants some random-numbered .o file in my root /tmp directory
22:45:13 <Nereid> lispy: no.
22:45:28 <Nereid> lispy: you want () -> Maybe a
22:45:38 <Nereid> ∅ is Void
22:46:03 <shachaf> ø -> Maybe a is not a difficult function to write.
22:46:43 <Nereid> ✈ -> Maybe ✆
22:46:51 <shachaf> Whoops.
22:47:01 <shachaf> I typed ø instead of ∅, didn't I.
22:47:04 <Nereid> yes
22:47:19 <shachaf> Sorry. :-(
22:47:24 <shachaf> ∅ø
22:47:31 <shachaf> Ø
22:52:22 <tao_> hello?
22:52:54 <lambdabot> welcome!
22:53:55 <tao_> :)
23:05:15 <tao_> i want to make a mud
23:05:24 <slack1256> how is that?
23:05:44 <slack1256> hello tao_ :-)
23:05:50 <tao_> :)
23:06:08 <tao_> the game is...
23:06:16 <slack1256> if you have any question, I'd be glad to help if I can
23:06:28 <tao_> oh, thank you
23:06:44 <tao_> i am a newbie. :)
23:07:24 <slack1256> :-)
23:07:43 <tao_> do you like make game, slack1256?
23:09:10 <slack1256> if do i like make games?
23:09:15 <slack1256> well, who doesn't?
23:09:28 <tao_> oh
23:09:43 <tao_> my english is poor. :(
23:09:55 <slack1256> I am also not a native speaker.
23:10:16 <slack1256> but it's OK, If we understand each other everything is fine
23:10:21 <tao_> much better than me..
23:10:35 <tao_> yeah, i think so.
23:11:04 <tao_> like speak to the people from space
23:11:15 <tao_> not earth
23:11:55 <slack1256> go step by step.
23:13:20 <tao_> oh, the game is like a mud, but the provide many command for player to build the world
23:14:10 <slack1256> how is this game called?
23:14:48 <tao_> YourMud
23:14:52 <tao_> https://github.com/hantaogo/YourMud
23:15:40 <tao_> the server can response message like ping pong now
23:17:00 <slack1256> yeah
23:17:21 <tao_> I's in trouble now because I'm not good at haskell
23:17:28 <E0000> ._.
23:17:52 <tao_> my poor english. :)
23:18:41 <slack1256> So, let me get this straight, you have a clear vision of your game
23:18:54 <slack1256> but don't know how to implement it in haskell
23:19:07 <tao_> yeah
23:19:36 <slack1256> how much haskell do you know? have you read the book or learned it on college?
23:20:42 <tao_> I had read "learn your a haskell.." and 100 page "Real World Haskell"
23:21:09 <E0000> learn you a haskell, great choice for poor english speakers : )
23:21:23 <tao_> i think so
23:21:48 <slack1256> yeah. it's also in french and russian.
23:22:07 <slack1256> and you want to disccuss how to aproach the project?
23:24:03 <tao_> maybe, just find this irc, and try to know some haskellers
23:24:52 <tao_> I will make clear vision by myself
23:24:57 <slack1256> ah, sorry, I was being too inquisitive :-)
23:25:09 <slack1256> I wish you good luck, I would like to play a bit once is finished.
23:25:24 <tao_> no,no,no
23:25:42 <tao_> thank you
23:25:49 <tao_> very much
23:26:22 <tao_> i also want to help if you like
23:27:22 <slack1256> if I have time :-) is on github so is just a clone apart
23:28:10 <tao_> ah, thank you, you can connect me by the email
23:29:15 <tao_> and when the game have a good version, i will tell you
23:30:01 <tao_> i am Tao Han
23:30:23 <slack1256> tao_: I would love to play :-)
23:30:45 <tao_> :) yeah! nice to meet you
23:30:55 <slack1256> I am Ruben Astudillo
23:31:00 <slack1256> nice to meet you too
23:31:20 <tao_> oh, nice to meet you, Ruben Astudillo!
23:31:32 <tao_> what's your email?
23:31:50 <slack1256> no need to. I am usually hanging on #haskell
23:32:01 <slack1256> once you are on freenode you can msg me.
23:32:05 <tao_> oh
23:32:18 <tao_> oh
23:34:04 <tao_> learning......
23:44:06 <XexoniXexillion> Are there any array libraries with similar performance (in access times) to vector, but which support multi-dimensional arrays?
23:44:23 <Cale> XexoniXexillion: There's repa...
23:44:34 <Cale> XexoniXexillion: also, you could just use the Ix instance for tuples directly
23:44:37 <Cale> to compute the indices
23:45:10 <XexoniXexillion> It also needs to work on GHC 6.12, which rules Repa out
23:45:12 <Cale> > rangeSize ((0,0),(100,100))
23:45:13 <lambdabot>   10201
23:45:29 <Cale> > index ((0,0),(100,100)) (30,52)
23:45:30 <lambdabot>   3082
23:45:32 <m3ga> XexoniXexillion: why 6.12? that's ancient
23:45:53 <XexoniXexillion> m3ga: Because getting a university to update things is near impossible
23:46:33 <m3ga> is this a linux/unix system? what about ghc in your homedir?
23:46:46 <slack1256> probably space quotas
23:48:21 <XexoniXexillion> m3ga: It's not an issue for me, it's for an assignment, which means it needs to run on what the students will have
23:48:59 <XexoniXexillion> Cale: thanks, I've never looked at the Ix class properly, I didn't realise it did that
23:49:20 <E0000> solved
23:49:29 <m3ga> XexoniXexillion: fair enough. look at either Array or Vector, both of which should work for 6.12.
23:54:11 <while2> ???
23:54:53 <Nereid> ??
23:55:16 <slack1256> everybody is sleeping. :-)
23:55:50 <E0000> threadDelay (8*3600*1000000)
23:56:06 <croikle> hah
23:56:12 <tao_> E0000, you are a robot?
23:56:40 <johnw> i think i just got some scheduler time
23:56:48 <E0000> tao_: usage !command <arg1> <arg2> ...
23:57:08 <tao_> :)
23:57:19 <tao_> i am sure you are.:)
23:57:23 * hackagebot cipher-aes 0.1.7 - Fast AES cipher implementation with advanced mode of operations  http://hackage.haskell.org/package/cipher-aes-0.1.7 (VincentHanquez)
23:57:27 <simon> regarding compiler optimizations: would one ever try to statically predict the size of the result of a list fold where the accumulated value is a list? I imagine in special (but not completely uncommon) cases, one could avoid temporary allocations.
23:58:21 <johnw> simon: could you give an example fold?
23:58:39 <johnw> in many cases, GHC will elide the temporaries automatically
23:59:04 <slack1256> simon: could you elaborate? the accum parameter is a list right?
23:59:09 <simon> slack1256, yes.
23:59:57 <slack1256> well, foldr is a catamorphism. does that implies that the result cannot be larger than the original list?
