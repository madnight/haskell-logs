00:06:45 <lgarron> So what should I do if "cabal install cabal-install" is running into issues?
00:07:08 <lgarron> I'm trying to resolve "cabal: Couldn't read cabal file "hashable/1.2.0.0/hashable.cabal"" and he internet seems to say update cabal.
00:07:52 <lgarron> 'cept it's having the same error, and I'm not getting any better at finding unreadable cabal files.
00:08:40 <mysticc> I am in a weird kind of type problem. I have a function hByteString :: A h => ByteString -> h and another function toByteString :: B h => h -> ByteString. Now I was writing a testcase one of myfunction which given list of pairs of ByteStrings, it tests them. But while using, map (\(a,b) -> toByteString (hByteString a) == b) pairByteString. I am getting all sorts of errors like could not deduce A h1, could not deduce B h1 etc? The type of my testfunction :: 
00:09:11 <elliott> that got cut off
00:09:14 <elliott> after "The type of my testfunction"
00:09:25 <mysticc> The type of my testfunction :: (A h,B h) => h -> [(ByteString,ByteString)] -> Test
00:09:57 <elliott> it's because it doesn't know which h you want to use for the toByteString and hByteString calls
00:10:03 <mysticc> I know what the problem is but I am not sure how to resolve it
00:10:25 <mysticc> currently it is
00:10:40 <elliott> if you turn on the ScopedTypeVariables extension you can put "forall h." in front of your signature
00:10:43 <elliott> and then say
00:10:45 <elliott> toByteString (hByteString a :: h)
00:10:47 <elliott> that's probably the simplest way
00:12:34 <mauke> testfunction h = map (\x -> f (g x `asTypeOf` h))
00:12:41 <mysticc> testStandardHashvalues elliott: Thanks
00:13:38 <mysticc> mauke: That also works. Thanks
00:29:46 * hackagebot yesod-platform 1.1.6 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.6 (MichaelSnoyman)
00:41:47 <beaky> what is the difference between OOP-style polymorphism through virtual dispatch and what Haskell supports (algebraic data types and pattern matching, and typeclasses)?
00:42:54 <Jafet> @where oohaskell
00:42:54 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
00:43:16 <Nisstyre-laptop> beaky: for starters Haskell's polymorphism is a property of the type system for both parametric and ad-hoc polymorphism (I know some people dislike the term ad-hoc)
00:44:30 <Jafet> Ad hoc, ergo non proper hoc
00:46:07 <beaky> ah
00:49:56 <akamaus> happy new year
00:52:37 <Ralith> bit late
00:53:17 <akamaus> better late than never :)
00:53:35 <akamaus> I'm going to make improvements in a small library implementing r-trees to make it better suit my needs. In particular, I need to create binary instance for efficient serialization. This leads me to two questions.
00:54:01 <akamaus> 1) Should I use derive package or write instances myself?
00:54:27 <Ralith> try deriving, and write your own if it's not efficient enough
00:55:09 <dibblego> does Data.Function#on generalise to higher arity in some library?
00:55:16 <akamaus> Should I place them in the same package (is it appropriate to create additional dependency on binary)  or in a separate one?
00:55:36 <akamaus> that ^ was the second one :)
00:58:06 <akamaus> Ralith, but how good are they? Basically, I have a tree structure and a bunch of record types like Point Word16 Word16
00:58:16 <elliott> same package is probably the best way, orphan instances are bad
00:58:51 <Ralith> akamaus: the easiest way to find out with certainty is to try it and see; is there some reason this is not viable?
00:59:18 <akamaus> Ralith, do you mean somethig like -dump-splices?
00:59:37 <Ralith> what?
01:02:03 <danr> Ralith: ghc -ddump-splices
01:02:11 <Ralith> what is that?
01:02:21 <danr> shows generated Template Haskell code
01:02:43 <akamaus> yep
01:02:45 <Ralith> oh, handy
01:03:05 <Ralith> but no, I mean write a testcase and examine its practical efficiency characteristics experimentally.
01:06:07 <akamaus> elliott, ok. Do you mean I also should spread the derivations accross the modules to avoid orphans?
01:06:55 <elliott> orphans are something you probably want to avoid in general
01:11:29 <danr> dibblego: not that I know, did you find one?
01:11:39 <dibblego> No.
01:11:50 <dibblego> :t let on3 f g a1 a2 a3 = on f g a1 a2 (g a3) in on3
01:11:51 <lambdabot> (b -> b -> b -> t) -> (a -> b) -> a -> a -> a -> t
01:13:14 <akamaus> elliott, what are practical consequences of having them?
01:13:58 <elliott> i think the wiki has a good article summarising the problems
01:14:47 * hackagebot free-game 0.3.0.2 - Create graphical applications for free.  http://hackage.haskell.org/package/free-game-0.3.0.2 (FumiakiKinoshita)
01:16:22 <dibblego> actually I think:
01:16:28 <dibblego> on0 = fmap
01:16:34 <dibblego> on1 = flip fmap
01:16:47 <dibblego> on1 = flip (fmap . fmap) -- oops
01:16:52 <dibblego> on2 = flip (fmap . fmap . fmap) -- etc
01:19:00 <danr> > flip (fmap . fmap) `asTypeOf` on
01:19:02 <lambdabot>   No instance for (GHC.Show.Show
01:19:02 <lambdabot>                     ((b0 -> b0 -> b0) -> (b0...
01:44:56 <neutrino> hello
01:45:01 <neutrino> are as-patterns lazy patterns?
01:45:38 <bitonic> neutrino: with as patterns you mean `foo@(Just bar)'?  in that case, no
01:45:46 <bitonic> they’re just like normal patterns
01:46:02 <Jafet> foo@bar has the same behaviour as bar
01:46:56 <neutrino> can you explain section 4.4 of the gentle introduction to haskell?
01:47:04 <neutrino> http://www.haskell.org/tutorial/haskell-98-tutorial.pdf
01:48:00 <bitonic> neutrino: so your question is “can you explain lazy patterns”?
01:48:16 <bitonic> or do you want me to explain that specific example?
01:48:33 <neutrino> sorry
01:48:59 <neutrino> on the second page the author uses as-patterns to make a lazy pattern
01:49:04 <neutrino> at least that's what i understood
01:49:19 <bitonic> no
01:49:42 <bitonic> you’re saying that `fib@(1:tfib)'?
01:50:07 <neutrino> yes, i'm talking about that
01:50:17 <neutrino> is it because the whole left hand side is a pattern?
01:50:22 <bitonic> mhm.  OK, the next paragraph is the confusing one
01:50:26 <ivanm> neutrino: ~ are lazy patterns
01:50:29 <ivanm> @src partition
01:50:29 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
01:50:29 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
01:50:29 <lambdabot>                               | otherwise = (ts, x:fs)
01:50:40 <ivanm> ^^ performs much worse if you remove the ~
01:51:14 <neutrino> right, however: i don't fully understand it but at the end of the section they say that if the whole lhs is a pattern then it has an implicit ~ in front of it
01:51:15 <bitonic> neutrino: but that’s because that pattern is a pattern binding
01:51:33 <neutrino> when is a pattern not a pattern binding?
01:52:18 <bitonic> neutrino: well, `foo (Just x) = x' is not a pattern binding
01:53:17 <bitonic> neutrino: with the pattern binding you are immediately pattern matching on what you are defining
01:53:26 <rohitkav> I want to install Haskell full package on my debian machine
01:53:27 <rohitkav> kindly help
01:53:44 <bitonic> rohitkav: `sudo apt-get install ghc haskell-platform'
01:53:45 <rohitkav> Bit confused what all to download from debian's site "http://packages.debian.org/squeeze/haskell-platform"
01:53:48 <rohitkav> ok
01:53:51 <rohitkav> will try bitonic
01:54:17 <rohitkav> I want to install snap framework as will, does this installation get me Cabal installed
01:54:21 <rohitkav> bitonic,
01:54:36 <ivanm> rohitkav: the haskell-platform includes cabal-install
01:54:39 <bitonic> rohitkav: yes.  I hope you are running something better than stable
01:54:45 <rohitkav> ok
01:54:47 <Jafet> "Put your hands over the desk, and step slowly away from the root account."
01:54:48 <rohitkav> thanks bitonic
01:55:02 <bitonic> Jafet: ehe
01:55:15 <rohitkav> 384MB download bitonic
01:55:20 <bitonic> rohitkav: yep.
01:55:26 <rohitkav> hmm
01:55:40 <Jafet> That's smaller than texlive-full!
01:58:17 <bitonic> rohitkav: did you read my comment on stable?  if you are running stable and you want to run snap the stock GHC is probably not going to work
01:58:49 <rohitkav> i would try yesod instead ? what you suggest bitonic
01:59:02 <bitonic> rohitkav: what distribution of debian do you have?
01:59:04 <Jafet> I don't know why people use this newfangled stable thing
01:59:16 <Jafet> Ol' sid has always worked for me.
01:59:42 <Jafet> That said, squeeze has 7.4.
02:00:25 <bitonic> Jafet: ?
02:00:25 <rohitkav> lxde	Debian GNU/Linux 6.0.6 (squeeze)
02:00:36 <rohitkav> bitonic, 	Debian GNU/Linux 6.0.6 (squeeze)
02:00:38 <bitonic> <http://packages.debian.org/search?keywords=ghc&searchon=names&suite=stable&section=all> says otherwise
02:01:17 <rohitkav> so only I asked bitonic
02:01:20 <rohitkav> what to do
02:01:26 <bitonic> rohitkav: right, so `apt-get install ghc' will get you ghc6.  I’d then suggest to get the GHC binaries from <http://www.haskell.org/ghc/download_ghc_7_4_2#binaries>
02:02:05 <shachaf> rohitkav: By "then" bitonic means "therefore", not "afterward"
02:02:07 <rohitkav> ok
02:02:08 <rohitkav> :)
02:02:19 <rohitkav> yes shachaf
02:05:58 <Jafet> bitonic: I see. Newfangled stable.
02:08:15 <bitonic> Jafet: what’s that?
02:08:52 <Jafet> I don't know, either.
02:14:42 <hpaste> dibblego pasted “ContraAp?” at http://hpaste.org/80098
02:15:35 <akamaus> I've made derive package the dependency of my library and now cabal complains there is no profiling libraries for it. Can I somehow suppress that? What's the point to have profiling version of compile-time code?
02:16:06 <Jafet> "heh"
02:16:16 <Lethalman> :t State random
02:16:17 <lambdabot>     Not in scope: data constructor `State'
02:16:18 <lambdabot>     Perhaps you meant `StateT' (imported from Control.Monad.State)
02:16:41 <Jafet> You could try to install the profiling-enabled library for derive.
02:16:42 <Taneb> :t state random
02:16:43 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
02:17:03 <Lethalman> thanks
02:17:12 <Lethalman> that's a headache
02:17:25 <Lethalman> :t state
02:17:26 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
02:17:40 <Lethalman> oh ok
02:17:46 <Lethalman> in LYAH it uses State random
02:17:58 <Taneb> LYAH is out of date on a couple of things
02:18:11 <Taneb> And the author hasn't been seen for years
02:18:13 <srhb> What's the lowercase state thing?
02:18:23 <Jafet> @src State
02:18:23 <lambdabot> Source not found. :(
02:18:39 <srhb> Or what's with it, rather.
02:18:39 <Jafet> State = StateT Identity
02:18:40 <Taneb> type State s a = StateT s Identity a
02:18:51 <Taneb> State is a type, not a newtype
02:18:55 <Taneb> So, no constructors
02:19:16 <srhb> That explains State, but not state, or what.
02:19:49 * hackagebot bumper 0.5.0.3 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.5.0.3 (ErikHesselink)
02:19:51 <shachaf> srhb: "state" is what "State" would be if it existed.
02:19:59 <shachaf> But ti can't exist since it's a type synonym, not a newtype.
02:20:08 <Taneb> Except generalized over every MonadState because that's possible
02:20:08 <shachaf> newtype State s a = State { runState :: s -> (a,s) }
02:20:26 <merijn> srhb: the state function is just to be compatible with old code that used State
02:20:40 <merijn> srhb: So you only have the uncapitalise it
02:20:52 <Jafet> #define State (state :: (s -> (a, s) -> State s a)
02:20:53 <merijn> srhb: It's just "StateT . return", I think
02:21:05 <srhb> Ah.
02:23:42 <shachaf> merijn: "to be compatible" in such a way that you still have to change your code.
02:23:58 <shachaf> Anyway, it's a nice function for expressing certain things.
02:24:05 <shachaf> Also you can get better performance from it.
02:24:51 <quicksilver> @hoogle state
02:24:52 <lambdabot> Control.Monad.State module Control.Monad.State
02:24:52 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
02:24:52 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
02:24:52 <merijn> shachaf: Sure, it's not ideal, but simpler than any other alternative (other than having a separate State newtype, which would be even more annoying...)
02:25:10 <quicksilver> it's more polymorphic than StateT. return isn't it?
02:25:16 <quicksilver> or are we talking about something else
02:25:24 <merijn> :t state
02:25:26 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
02:25:32 <merijn> :t StateT . return
02:25:34 <lambdabot> m (a, s) -> StateT s m a
02:26:01 <Lethalman> \o/
02:26:05 * Lethalman so confused :P
02:26:27 <shachaf> @ty StateT . (return .)
02:26:28 <lambdabot> Monad m => (s -> (a, s)) -> StateT s m a
02:26:47 <merijn> Lethalman: Don't worry, if you memorise "use the 'state' function where LYAH uses the 'State' constructor", that's all you need to understand for now
02:27:42 <Lethalman> merijn, yes I understand the concept of state and state monad
02:27:57 <Lethalman> maybe I wouldn't be able to write a state monad yet :P
02:28:05 <deus_rex> is there an idiomatic way to 'extend' a module locally in haskell? like, if I want to add some helpful functions to work with IntMaps, but I don't want them to conflict with identically-named functions I've written for working with Sets. Obviously I can't add them in the same module, but I can't figure out what I should call these new modules
02:28:15 <deus_rex> Data.IntMap.Extensions ?
02:28:26 <startling> deus_rex: sure
02:28:41 <srhb> Lethalman: You don't have to write one, you can use it just fine. :)
02:28:44 <merijn> deus_rex: That or something like "MyExtensions.IntMap" and "MyExtensions.Set"
02:28:50 <Lethalman> srhb, eheh yes
02:28:54 <deus_rex> i dunno if there's a standard, or even a way to mix these functions in with the modules I've imported from some other package
02:28:59 <deus_rex> (I'm guessing not)
02:29:04 <shachaf> deus_rex: When you import your module you can import it with the same name.
02:29:13 <shachaf> import qualified Data.Set as S; import qualified MyModule as S
02:29:31 <deus_rex> oooh
02:29:38 <deus_rex> nice :) thanks!
02:29:49 <merijn> deus_rex: Actually, if you do my suggestion (Extensions.IntMap) you can write your functions and re-export the Data.IntMap and Data.Set stuff from there so you don't need to import the other stuff
02:30:46 <merijn> deus_rex: "module MyExtensions.Set ({- your functions here -}, module Data.Set) where import Data.Set {- fuction definitions -}"
02:31:05 <merijn> deus_rex: Now importing "MyExtensions.Set" will also import everything in Data.Set
02:31:39 <shachaf> Oh, true, you can also reëxport Data.Set if you like.
02:31:50 <merijn> deus_rex: iow, there's multiple solutions, depending on your use case
02:33:00 <Jafet> Clearly you should fix containers by adding its types to a typeclass. Wait, I think that's been done.
02:33:06 <deus_rex> seems to be a common theme in haskell ;)
02:33:40 <akamaus> Jafet, installing profiling verions of derive turned out to be a major headache. It has dozen of indirect dependencies and I had to reinstall them one by one as well. Hope other modules using them are still functional :)
02:34:22 <Jafet> cabal install --reinstall --force --enable-library-profiling world
02:34:29 <Jafet> (If you want a bigger headache)
02:35:53 <Jafet> Actually, installing dependencies one by one is likely to break the dependency graph, so that might be a smaller headache
02:41:42 <akamaus> Jafet, Wow! Didn't know about 'world'! Will backup and try. Anyway, my cabal-install database is about three months old.
02:42:22 <Jafet> Nobody does, because it's not mentioned in the documentation.
02:47:36 <akamaus> Jafet, why so? Is it considered more unsafe than unsafePerformIO? :) Btw, could you please add my nick in front of messages addressed to me? This way I won't miss them.
03:24:50 * hackagebot python-pickle 0.2.0 - Serialization/deserialization using Python Pickle format.  http://hackage.haskell.org/package/python-pickle-0.2.0 (VoMinhThu)
03:25:09 <beaky> hello
03:25:15 <beaky> how do closures work?
03:26:05 <beaky> are they related to currying?
03:26:35 <bxc> anyone know off top of head which ghc DeriveGenerics appeared in and when/if that got into debian?
03:26:55 <Taneb> beaky, I've never actually worked out what a closure is
03:26:57 <startling> beaky: no, they're just a way to implement functions
03:27:12 <startling> beaky, when people talk about "closures" they just mean "lexical scoping"
03:27:19 <ion> > let a = 42 in (let b = a in b)  -- The free a in the inner expression refers to the a in scope from the outer expression.
03:27:21 <lambdabot>   42
03:27:46 <beaky> ah
03:28:00 <beaky> so lexical scoping is somethng that all programming languages have?
03:28:06 <ion> > let g = (let a = 42 in let f x = x + a in f) in g 100  -- A bit contrived; the same rules still apply.
03:28:07 <lambdabot>   142
03:28:20 <Jafet> It is something that all programming languages should have, but some don't.
03:28:25 <beaky> ah
03:28:29 <beaky> which ones don't?
03:29:23 <akamaus> Is there any analog of UTCTime which has Binary instance?
03:29:47 <Lethalman> :t Binary
03:29:48 <lambdabot> Not in scope: data constructor `Binary'
03:29:51 <Lethalman> :k Binary
03:29:52 <ion> akamaus: You could convert to, say, Integer or Rational.
03:29:52 <lambdabot> Not in scope: type constructor or class `Binary'
03:30:44 <HugoDaniel> hi
03:31:19 <Jafet> beaky: python, for example
03:32:00 <Lethalman> Jafet, why not?
03:32:17 <HugoDaniel> how can i create a dynamic datatype with template haskell ? i have my base datatype like data T = T Text Int Text and i want to create a datatype data DT = DT [Text] [Int] [Text] in template haskell so that if i need to change the base later this one gets automagically changed also
03:32:19 <Lethalman> in python you can create closures that refer the outer scope
03:32:56 <quicksilver> HugoDaniel: why not just data TT f = T (f Text) (f Int) (f Text)
03:32:59 <Jafet> If your language doesn't implement lexical scope correctly, it isn't lexically scoped.
03:33:05 <quicksilver> and use TT Identity and TT []
03:33:10 <mel-> good morning :)
03:33:12 <Lethalman> Jafet, and why python doesn't, sorry? can you give an example?
03:33:26 <Jafet> This should be well known. I guess python programmers don't know it
03:33:46 <bitonic> Jafet: python 3 is OK iirc
03:33:54 <Lethalman> so you can give an example where it doesn't work?
03:34:13 <HugoDaniel> quicksilver: thanks :D i haven't though of that
03:34:14 <bitonic> Lethalman: try `x = 0; def foo(): x += 1; foo()'
03:34:18 <HugoDaniel> let me see if it works for my case :D
03:34:29 <Lethalman> bitonic, that's global scope, we all know it
03:34:37 <Lethalman> bitonic, but defining functions inside functions is fine
03:34:46 <quicksilver> HugoDaniel: it might be a bit annoying unwrapping stuff.
03:34:49 <bitonic> Lethalman: ? that should work if you had lexical scope right, and it doesn’t
03:34:50 * hackagebot yesod-platform 1.1.6.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.6.1 (MichaelSnoyman)
03:35:05 <Lethalman> bitonic, ok, but it works inside functions
03:35:06 <Jafet> Lethalman: no, I don't collect these examples. You can search the web or ask #python.
03:35:43 <HugoDaniel> hey krugger  :D
03:35:43 <bitonic> Lethalman: yeah.  it’s not a big deal.
03:35:48 <Jafet> rwbarton used to have a list of devious examples of python being broken
03:36:02 <Lethalman> Jafet, s/broken/different
03:37:15 <Jafet> No, that was not a typo
03:39:45 <mysticc> Does function `all id` have any other name ?
03:40:02 <ion> @type [all id, and]
03:40:03 <lambdabot> [[Bool] -> Bool]
03:40:05 <Jafet> @src all
03:40:05 <lambdabot> all p =  and . map p
03:40:23 <mysticc> Jafet: Oh thanks
03:41:33 <mel-> point-free definitions of functions are awesome.
03:41:48 <Lethalman> what is point-free?
03:41:58 <Jafet> And all = and .: map, all.
03:42:05 <Martty_> tautological
03:42:07 <mel-> Lethalman: you know 'element-free'?
03:42:32 <bitonic> <http://www.haskell.org/pipermail/haskell-cafe/2013-January/105612.html>, any ideas appreciated
03:42:41 <Lethalman> mel-, no :S
03:42:53 <mel-> Lethalman: it means.... when defining f(x) instead of describing what happens with a certain x, you define really *f*.
03:42:54 <Lethalman> mel-, I tend to confuse definitions
03:43:07 <mel-> Lethalman: (the 'x' being the 'point')
03:43:13 <Lethalman> ok
03:43:43 <Lethalman> :k Maybe
03:43:44 <lambdabot> * -> *
03:43:48 <Lethalman> :k Maybe $ String
03:43:49 <lambdabot> Not in scope: type variable `$'
03:43:58 <mel-> Lethalman: (e.g. by function composition.)
03:44:00 <akamaus> ion, how to convert UTCTime to Integer? I can't see any approprite instances.
03:44:17 <Lethalman> mel-, got it, they are also a little more cryptic :P
03:44:28 <Lethalman> :t Maybe
03:44:29 <lambdabot> Not in scope: data constructor `Maybe'
03:44:42 <Lethalman> @src UTCTime
03:44:42 <lambdabot> Source not found. My brain just exploded
03:44:46 <Lethalman> :S
03:44:51 * Lethalman spamming
03:45:56 <ion> akamaus: I think (realToFrac . utcTimeToPOSIXSeconds) might work.
03:46:25 <ion> Well, that’s for Rational. (floor . utcTimeToPOSIXSeconds) for Integer.
03:46:58 <Lethalman> > Just $ 2
03:46:59 <lambdabot>   Just 2
03:47:06 <Lethalman> :t Just
03:47:07 <lambdabot> a -> Maybe a
03:52:16 <beaky> are cosures related to haskell's purely-functional data structures?
03:52:27 <ion> Not really.
03:52:38 <beaky> clsures*
03:52:41 <beaky> closures*
03:52:41 <akamaus> ion, thanks! That works. Btw, I had to import Data.Time.Clock.POSIX. Will it compile on Windows?
03:53:01 <ion> akamaus: It should. It’s just a representation of time based on a Fixed type.
03:54:15 <mysticc> @src flip
03:54:15 <lambdabot> flip f x y = f y x
03:54:58 <miasma> "I am personally not impressed with functional programming for my projects but admit that it can do some interesting things. One of which is to make code more complex and less readable while trying to make it less complex and more readable. Just my personal opinion, but I am well set in my ways."
03:55:08 <miasma> funny things that people say
03:55:54 <shachaf> miasma: Quoting a troll in the channel isn't extremely different from being a troll in the channel. :-)
03:56:12 <Jafet> bitonic: ghc does not infer higher-rank types unless they are let-bound
03:56:21 <t7> what kinda moron cant read this: flip <$> >>= just
03:56:49 <ion> t7: A Haskell compiler
03:56:49 <Lethalman> t7, what's that :S
03:56:56 <Lethalman> :t flip <$> >>= just
03:56:57 <lambdabot> parse error on input `>>='
03:56:59 <elliott> that is nonsense
03:57:06 <merijn> Lethalman: That was a joke ;)
03:57:18 <bitonic> Jafet: so what’s the inferred type for `flip one'?
03:57:26 * Lethalman tries to read everything in the channel until he can have time again to continue learning haskell :P
03:57:33 <Lethalman> :t just
03:57:35 <lambdabot>     Not in scope: `just'
03:57:35 <lambdabot>     Perhaps you meant `_just' (imported from Control.Lens)
03:57:35 <bitonic> the non-let bound `flip one'
03:58:23 <beaky> > let cons a b = \f -> f a b in let car x = x (\a b -> a) in let cdr x = x (\a b -> b) in let cadr = car . cdr in cadr (cons 1 (cons [1..10] 3)) -- is cons a closure?
03:58:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
03:58:35 <Jafet> No idea
03:58:55 <beaky> it feels so since it saves a and b
03:59:03 <Jafet> But eg. (\f -> f () id) (flip one)
03:59:08 <bitonic> Jafet: ah, <http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#id623016>
03:59:12 <Jafet> ghc also does not infer higher-rank for that one
03:59:41 <ion> beaky: Your cons doesn’t have any free variables, it doesn’t need to carry anything from an outer scope with it.
03:59:50 <beaky> ah
04:00:31 <beaky> it seems car and cdr are closures
04:00:59 <Jafet> Closure is a fancy term from the 60s that means "wow, didn't think it was that hard to implement functions"
04:00:59 <shachaf> beaky: You were unusually lucid earlier.
04:01:03 <shachaf> Can we go back to that?
04:01:05 <ion> beaky: They don’t have any free variables either.
04:01:20 <tcrayford> Jafet: the dude who invented them had good reasons for it
04:01:25 <beaky> oh
04:01:38 <tcrayford> Jafet: it was a huge hack at the time (I spent a while asking him about it once)
04:01:47 <beaky> wish someday I can implement those things myself so I will finally understand what a closure is ^^
04:01:58 <Jafet> Nearly every symbolic programming system today has closures, so it's not really something to care about unless you're implementing one.
04:02:19 <ion> foo x = x + y  -- x is bound, y is free. y comes from the environment, making this a closure.
04:02:33 <beaky> closures seem significant as I keep hearing 'objects are a poor man\'s closures' in flame wars
04:02:44 <beaky> ah
04:02:48 <tcrayford> beaky: closures are also the poor man's object
04:03:09 <tcrayford> beaky: for a more motivational argument: foo x = map (\y -> x + y) [1,2,3]
04:03:19 <ion> foo x y = x + y  -- not a closure, all variables are bound, or local if you will
04:03:21 <beaky> so I've been using closures all along in languages like C that have scoping rules?
04:03:26 <Jafet> ion: (+)!
04:03:39 <tcrayford> the anonymous function is a lambda there, because x comes from the outer scope
04:03:39 <mysticc> bitonic: Have you asked this on StackOverflow. I think you can get better explanations there.
04:03:46 <ion> jafet: Hehe, good point.
04:03:52 <bitonic> mysticc: I think that’s not the case
04:04:07 <ion> beaky: Yeah, (+) comes from the environment in both examples. I neglected that.
04:04:14 <beaky> oh
04:04:28 <beaky> > let add = (+) in add 1 2
04:04:29 <lambdabot>   3
04:04:35 <beaky> that's so neat :D
04:05:03 <tcrayford> lots of people consider languages without closures to be basically not worth dealing with anymore
04:05:25 <merijn> Everyone worth dealing with considers languages without closures not worth dealing with :p
04:05:35 <Jafet> Like C...
04:05:39 <beaky> C doesn't have closures?
04:05:43 <mysticc> bitonic: Why's that?
04:05:57 <Lethalman> beaky, not in the syntax
04:06:06 <merijn> Jafet: I'm a firm believer that *people* shouldn't write C, compilers/tools should produce C
04:06:11 <Lethalman> gcc has some kind of closure limited by the scope of the outer function
04:06:12 <t7> apple extensions have closures
04:06:20 <bitonic> mysticc: because I know that many good people read haskell-cafe, SO is vague
04:06:21 <merijn> (I say that as a person who spends most of his time writing C atm)
04:06:23 <beaky> http://stackoverflow.com/questions/4020419/closures-in-python makes it seem that python does
04:06:29 <t7> merijn: why not llvm or something?
04:06:33 <merijn> bitonic: Many good people also read SO
04:06:39 <beaky> standard C doesn't have lambdas or nested functions, so it probably doesnt :(
04:06:50 <mm_freak_> @tell donri right now i don't really get to working on fastirc yet, but it's definitely planned…  there will be two libraries, one IRC parser/printer and one FRP-based IRC session library
04:06:50 <lambdabot> Consider it noted.
04:06:55 <mysticc> bitonic: Yeah, but getting additional answers will not harm you.
04:06:56 <merijn> bitonic: I have seen many answers by conal and dons on SO
04:06:57 <Lethalman> yes, the most advanced syntax in C is that of gcc for nested functions
04:06:58 <Jafet> gcc does not implement closures properly, I think. g++ is obliged to implement it somewhat sensibly.
04:07:34 <merijn> The most advanced syntax in C is CPP :>
04:07:42 <bitonic> mysticc, merijn: I think it’s much easier for a message to get lost in SO.  anyway, it’s not important, I’m sure somebody will reply
04:07:55 <adek05> I read a stream of chars which consists of JSONs. Now I want to make of this list of strings, each element maybe but last being correct JSON. I could have done it by splitting at '}' but JSONs may be nested. Do you know how can I, possibly using parsec, parse it so that I get a list of JSONs and remaining chars from the end which do not form full JSON yet?
04:07:58 <tcrayford> beaky: this article: http://matt.might.net/articles/closure-conversion/ is kinda useful for understanding how closures (could) be implemented
04:08:49 <tcrayford> adek05: look into the aeson package, if I understand your query correctly
04:09:11 <Jafet> I didn't know prose had a free verse form...
04:09:39 <adek05> tcrayford: I think Aeson parses String to JSON. What I have here is Stream of data which I need to split into chunks which later could be parsed by Aeson
04:11:18 <tcrayford> adek05: right, but aeson supports leftover stuff via attoparsec (iirc from bos' blog posts on attoparsec). Seems like you should just be able to call attoparsec on the current chunk and figure out what's well formed and what needs more data
04:11:30 <tcrayford> adek05: I might be wrong on that though :(
04:13:08 <adek05> tcrayford: Oh, I haven't come across it, gonna check, thanks for hint
04:13:09 <miasma> shachaf: sorry for that if it sounded like trolling. i found this hilarious http://java.dzone.com/articles/no-more-excuses-use-null
04:13:39 <beaky> why is purely-functional programming so significant? what happens when you mix impure and pure code (like in ML/Scala and the scripting languages)?
04:14:01 <Jafet> You get work done faster
04:14:04 <Jafet> !!!
04:14:25 <beaky> ah
04:14:41 <ion> beaky: Side-effects contaminate everything. A little bit of launching the missiles makes the entire code that calls that function impure.
04:14:41 <Jafet> Purity is for pointy-hairs
04:14:43 <miasma> beaky: if you mix impure and pure code, you can have Nothing | Just a | null | Just null
04:14:50 <miasma> much more choice
04:14:51 * hackagebot grid 2.1.1 - Tools for working with regular grids\/graphs\/lattices.  http://hackage.haskell.org/package/grid-2.1.1 (AmyDeBuitleir)
04:15:00 <zenzike> I'm having strange issues with ghc not letting me have incoherent instances, even after using the pragma
04:15:09 <hpaste> zenzike pasted “random-fu” at http://hpaste.org/80100
04:15:16 <Jafet> ReallyIncoherentInstances
04:15:22 <ion> IncoherentCompiler
04:16:10 <Jafet> Your instance is so incoherent, that you haven't written it into that paste
04:16:14 <zenzike> as far as I can tell, random-fu isn't doing anything too crazy here
04:16:32 <zenzike> Jafet: heh, sorry the inchorence is in random-fu
04:16:43 <zenzike> https://github.com/mokus0/random-fu/blob/master/random-fu/src/Data/Random/Lift.hs
04:17:42 <beaky> so closures are essentially what you get when you treat functions as data?
04:18:04 <srhb> beaky: I remember my disappointment with SML when I followed that as an introductory course and we got to the IO part. Everything about purity was so nice, and then suddenly we just read a file (maybe) and all the safety was now gone and the functions impossible to inspect from their types.
04:18:22 <srhb> I was like durrr, what's the point then.
04:18:23 <Jafet> Better not read my haskell programs, then
04:18:53 <Lethalman> srhb, isn't it like that in haskell too?
04:18:53 <Jafet> zenzike: include the error message, as none of us are going to install random-fu to find out
04:19:06 <statusfailed> Lethalman: Only if you use unsafePerformIO, right?
04:19:11 <merijn> Lethalman: No, because any function that does that has IO in the type
04:19:22 <statusfailed> Jafet: random-fu is awesome though :D
04:19:29 <merijn> Lethalman: iow, any function that does *not* have IO in it's type does not do that
04:19:43 <beaky> haskell is pure by default :D
04:19:47 <Jafet> Well, maybe you can help zenzike.
04:19:57 <srhb> Lethalman: No, the monadic approach to IO means you get purity and referential transparancy AND IO.
04:20:04 <beaky> oh
04:20:11 <merijn> Lethalman: In SML "Int -> Int" could do failing IO to a file, whereas in Haskell it can't (keep in mind that unsafePerformIO is not haskell, 'cause it's not in the standard)
04:20:18 <Lethalman> you meant that in SML there was some IO operation that returned directly the value instead of IO value ?
04:20:19 <bitonic> you can write solid code in SML too, it’s a very good language
04:20:23 <srhb> Lethalman: Yes.
04:20:25 <merijn> Lethalman: Yes
04:20:27 <Lethalman> ah ok
04:20:32 * Lethalman maybe starting to understand something
04:20:33 <srhb> Lethalman: Like Haskell unsafePerformIO - only it was the ONLY way.
04:20:42 <Lethalman> alright
04:20:50 <ion> beaky: I’m not sure those concepts are very related either. A closure is just a function value/pointer/reference/whatever with a table of values it uses from its environment.
04:20:55 <Lethalman> srhb, so Int -> Int in haskell that does some operation means that it uses unsafePerformIO?
04:21:06 <elliott> merijn: ?
04:21:14 <elliott> merijn: unsafePerformIO is part of the standard, what do you mean?
04:21:15 <Lethalman> that is you can't escape monads if you don't do unsafe operations?
04:21:16 <beaky> ah
04:21:24 <srhb> Lethalman: If you have Int -> Int and it does IO, then it is using unsafePerformIO
04:21:25 <statusfailed> Jafet: fair point :D
04:21:26 <merijn> elliott: Well, it wasn't in H98 at least, I think?
04:21:28 <ion> beaky: If all variables are bound, the table is empty.
04:21:32 <merijn> elliott: Not sure about 2010
04:21:34 <hpaste> zenzike annotated “random-fu” with “random-fu (annotation)” at http://hpaste.org/80100#a80101
04:21:37 <elliott> merijn: It's in the FFI addendum and 2010.
04:21:38 <Lethalman> srhb, alright, that applies to any monad right?
04:21:45 <merijn> elliott: Ah
04:21:51 <srhb> Lethalman: Umm, no. I'm not sure what you mean by that
04:21:53 <zenzike> Jafet: there's the error, if that helps
04:22:00 <elliott> (as is that weird unsafeLocalState thing)
04:22:03 <Lethalman> srhb, if any function uses monad Foo, it must return Foo ?
04:22:13 <statusfailed> zenzike: that link doesn't seem to show the error for me
04:22:18 <srhb> Lethalman: You can extract values from some Monads safely.
04:22:25 <merijn> Lethalman: Depends on the monad
04:22:40 <merijn> Lethalman: For example, Maybe and list have functions that let you get values out of them
04:23:01 <merijn> Lethalman: It's just that the monad interface doesn't force you to provide such a function
04:23:07 <Lethalman> merijn, ok, but they return an error if it's not correct, right?
04:23:09 <srhb> Lethalman: foo (Left x) = x; foo (Right y) = y -- for Either a a, I believe
04:23:15 <Lethalman> merijn, I see
04:23:21 <merijn> Lethalman: Think of execState, that returns a value that's not in the State monad
04:23:24 <merijn> :t execState
04:23:25 <lambdabot> State s a -> s -> s
04:24:07 <elliott> merijn: actually I might be wrong about 2010.
04:24:09 <merijn> Lethalman: It's just that execState *only* works for State, and there's no function that works for *all* monads. (As opposed to return which can put a value into any monad)
04:24:14 <elliott> not sure if the unsafeLocalState thing is instead of or in addition to
04:25:03 <Lethalman> merijn, is that by design of Monad, or because it's practically hard to do it?
04:25:10 <merijn> Lethalman: So whether you can get a value out of a monad (and even what it means to "get a value out of") depends on the actual monad used.
04:25:23 <beaky> how do you get things done in a language that doesn't have closures? (C, Java, FORTRAN, and others)?
04:25:25 <srhb> Lethalman: The idea that you cannot extract a value from IO is inherent for its safety
04:25:25 <merijn> Lethalman: That's by design, because for some monads getting a value out makes no sense (i.e. STM/IO)
04:25:43 <Lethalman> ok
04:26:09 <zenzike> statusfailed: try refreshing
04:26:21 <merijn> Lethalman: Basically, "monads you can get things out of" are a subset of "all monads"
04:26:45 <srhb> proper subset* :P
04:27:06 <merijn> srhb: Unless specified I consider subset to mean proper subset
04:27:10 <srhb> Really?
04:27:20 <merijn> Then again, I'm not a mathematician
04:27:34 <srhb> Neither am I, but I am scared of their wrath.
04:27:35 <srhb> :P
04:28:07 <merijn> Lethalman: In the same sense that all monads are functors, but not every functor can be a monad
04:28:54 <lgarron> Phew, good to know nuking the Haskell platform and reinstalling works to fix some bugs.
04:29:13 <HugoDaniel> :D
04:29:18 <HugoDaniel> thats my approach as well
04:29:26 <hpc> oh god
04:29:26 <lgarron> It's not a great one.
04:29:28 <hpc> https://github.com/headprogrammingczar/php-haskell-prelude/pull/1
04:29:28 <HugoDaniel> rm -rf *
04:29:38 <HugoDaniel> rm -rf * (readmail reallyfast)
04:30:01 <srhb> hpc: Heresy!
04:30:08 <srhb> But I assume it's a joke.
04:31:10 <srhb> The description is hilarious: "All the static semantics and safety of PHP and all the dynamic flexibility of Haskell"
04:31:21 <merijn> hpc: <3
04:31:43 <Jafet> @hackage acme-php
04:31:43 <lambdabot> http://hackage.haskell.org/package/acme-php
04:31:58 <HugoDaniel> :D
04:31:58 <HugoDaniel> ahah
04:32:14 <Jafet> zenzike: both instances look equally specific to ghc, so it can't pick either
04:32:38 <Jafet> I don't know why a library needs three overlapping incoherent instances like that
04:32:56 <Jafet> ...especially if the instance definitions are equivalent
04:33:58 <hpc> Jafet: if you write the same instance 3 times, beetlejuice appears
04:37:32 <mel-> I'm imagining a world where many of the programs I have installed on my system are compiled Haskell programs. Now, if e.g. a bug gets fixed in one of the Haskell libraries used by several programs -- will I need to download new versions for all the programs using the broken library?
04:38:48 <Lethalman> merijn, mh I don't quite have the understanding why not every functor can be a monad
04:39:03 <Jafet> Quite likely. Note that this problem precludes the possibility of a world where most of a system consists of compiled haskell programs.
04:39:26 <t7> Lethalman: think about which laws are missing
04:39:44 <Lethalman> :t fmap
04:39:45 <Lethalman> :t (>>=)
04:39:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:39:46 <Jafet> Also, you are likely to compile them from source rather than download them.
04:39:46 <lambdabot> Monad m => m a -> (a -> m b) -> m b
04:40:50 <t7> oh im thinking monoid
04:40:52 <Lethalman> :t flip (>>=)
04:40:54 <lambdabot> Monad m => (a -> m b) -> m a -> m b
04:41:00 <Lethalman> that's very similar to fmap
04:41:08 <mel-> Jafet: Mhhh. That's pretty inefficient.
04:41:10 <t7> functor just lifts a function, right? it doesnt need to be assoc?
04:41:24 <burbul> I have a data type of Formulae in (essentially) the predicate calculus, and I need to compute some pretty complicated operations on it.
04:41:38 <Jafet> mel: fantastic deduction
04:42:11 <burbul> A simple example might be turning  (P & ... & Q & ... & Q=>R & ... &S) into (P & ... & Q & ... & R & ... &S)
04:42:24 <mel-> Jafet: thank you
04:42:29 <burbul> So the point is that one is picking out the different bits of the Formula and manipulating them, while leaving the rest alone.
04:42:39 <burbul> (And the bits that are manipulated might be rather deeply nested.)
04:42:56 <burbul> I think that the right way to deal with this is using zippers . To keep track of the locations that are being "modified"
04:42:59 <burbul> But I've never used them before
04:43:21 <statusfailed> zenzike: did you fix it?
04:43:22 <burbul> a) do zippers sounds sensible here and b) , which of the `zipper', `instant-zipper' packages , should I use?
04:43:30 <statusfailed> I just got back, and i'm having a look
04:43:40 <Jafet> Just use whichever data structures that are used by other solvers.
04:44:04 <burbul> I don't know anything about other solvers, or where to start looking
04:44:38 <burbul> Plus I've simplified a bit, so I'm not sure that the domain is really the same
04:44:47 <Jafet> In that case... sure, why not use zippers.
04:44:57 <burbul> Do you know what the difference between the two packages is?
04:46:02 <Jafet> instant-zipper sounds like it isn't
04:46:09 <Jafet> I mean, no
04:47:16 <burbul> thank you
04:48:25 <danr> which package to SHA hash Text?
04:48:47 <Jafet> @hackage SHA
04:48:47 <lambdabot> http://hackage.haskell.org/package/SHA
04:48:49 <statusfailed> zenzike: I know this doesn't solve your problem if you need state, but you can do 'main = sample (uniform 1 100 :: RVar Int) >>= print'
04:49:02 <danr> Jafet: yeah, it's for ByteStrings
04:49:10 <danr> but maybe it's just a matter of repacking
04:49:17 <Jafet> Data.Text.Encoding
04:50:05 <danr> Jafet: thanks
04:50:32 <NougatRillettes> why won't this work :  (\(n,s) -> Control.Monad.liftM ((,) n) s) . (\k -> k,getLine) ?
04:50:33 <merijn> Lethalman: This post tries to explain the difference between functors and monads, maybe it helps (I just skimmed it, and it seemed understandable, but don't blame me if it isn't :p) http://newartisans.com/2012/08/monads-in-pictures/
04:50:37 <NougatRillettes> >  (\(n,s) -> Control.Monad.liftM ((,) n) s) . (\k -> k,getLine)
04:50:39 <lambdabot>   Couldn't match expected type `(a0, m0 a10)'
04:50:39 <lambdabot>              with actual type `...
04:50:55 <neutrino> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020005.html
04:51:01 <neutrino> dot, dot, dot
04:52:19 <srhb> merijn: I really like that one. :)
04:52:48 <Lethalman> merijn, I got the difference, btw that's a very nice link thanks
04:53:24 <bootcode> >  (\(n,s) -> Control.Monad.liftM ((,) n) s) . (\k -> (k,getLine))
04:53:26 <lambdabot>   No instance for (GHC.Show.Show
04:53:26 <lambdabot>                     (a0 -> GHC.Types.IO (a0,...
04:53:40 <bootcode> NougatRillettes: you missed wrapping it in parens
04:54:11 <merijn> Lethalman: I thought another reasonable explanation (not about functors and monads, but about arrows and monads) was in one of the arrow papers, where they discuss how arrows are more general than monads (i.e. every monad is an arrow, but not every arrow is a monad)
04:54:36 <merijn> Lethalman: Although that one might be a bit confusing if you're not really comfortable with basic haskell yet
04:54:50 <Lethalman> merijn, I still don't know arrows
04:54:59 <startling> they're not a big deal
04:55:04 <Lethalman> but I grasped the monad and functor and applicative _concept_ :)
04:55:43 <merijn> Lethalman: Then they're not that big of a deal. The basic idea is fairly simple, just using it in practice can be tricky. Usually defining a monad interface is simpler
04:56:09 <merijn> (in the sense that seeing when your code could be an arrow can be tricky)
04:56:38 <NougatRillettes> bootcode: hm ?
04:57:35 <Lethalman> merijn, is there some problem in the interoperability of these concepts?
04:57:55 <Lethalman> do they lead to many ways to write a program?
04:59:51 <merijn> Lethalman: Not really, any monad can transformed into an arrow "for free" (there's a newtype wrapper for it, but nothing more needed), but some things cannnot be encoded by monads. The example used is that composing two monadic parsers using >>= the combined parser cannot use any static information about the first parser. Which is what arrows were supposed to solve
05:01:06 <Lethalman> ok thanks, I believe that's something I have to get into in practice to better understand the limits
05:01:08 <bootcode> NougatRillettes: instead \k -> k,f k try \k -> (k, f k)
05:01:08 <merijn> Lethalman: If your interested, I recommend reading the arrow paper (Generalising Monads to Arrows by Hughes) from the start until it stops making sense (the second half is a bit tricky to follow at times, but the first half alone is sufficiently interesting and stand-alone to be worth reading)
05:01:19 <merijn> s/your/you're
05:03:11 <NougatRillettes> oops, I was misreading the error output
05:03:16 <NougatRillettes> thanks :)
05:06:35 <statusfailed> Lethalman: I could be wrong, but I think merijn is suggesting that often it's tempting to use an Arrow where a Monad would suffice
05:06:43 <statusfailed> and I was scrolled up. dammit.
05:07:51 <Lethalman> statusfailed, but there's no special syntax for applicative functors and arrows, right?
05:08:08 <quicksilver> there is for arrows, although it's not terribly widely used
05:08:11 <merijn> Lethalman: Arrows have special notation to, but it is not very commonly used
05:08:42 <quicksilver> people have tried to do something for applicatives - there is an implementation in Conor McBride's "SHE" - but it's not acheived widespread consensus.
05:10:07 <srhb> merijn: They do?
05:10:21 <neutrino> DYK: haskell report 1.0 was released on april 1st.
05:10:33 <statusfailed> srhb: yep, it's like proc x -> do { r <- myArr -< x
05:10:37 <merijn> srhb: proc notation
05:10:40 <statusfailed> }
05:10:46 <quicksilver> @google ghc arrow notation
05:10:47 <lambdabot> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/arrow-notation.html
05:10:47 <lambdabot> Title: 7.13.�Arrow notation
05:10:51 <quicksilver> srhb: ^^
05:11:39 <srhb> Nice, I had no idea.
05:12:04 <srhb> Is there an extension that allows mixfix functions?
05:12:41 <shachaf> cabal install agda
05:12:46 <srhb> ;)
05:12:53 <srhb> I'd like to be able to run my programs afterwards.
05:13:08 <srhb> But yeah, why is Haskell not Agda is the real question.
05:13:29 <statusfailed> Because then what would Agda be? :D
05:13:34 <Eelis> because programming in dependent types is still too painful :)
05:14:09 <srhb> Someone ought to solve that. *nods*
05:14:16 <Eelis> people are working on it :P
05:14:19 <statusfailed> speaking of Agda, I have a question: what kind of things can it be used as a proof assistant for? I was thinking of learning it to fill in gaps in proofs in textbooks but I'm not sure if it is ggood for that
05:14:29 <zenzike> statusfailed: thanks for the pointer, I did already have the IO version working
05:14:43 <Eelis> statusfailed: i dunno about Agda, but Coq is ok for that
05:14:46 <zenzike> but I'm trying to do this purely deep inside something else
05:14:58 <statusfailed> zenzike: sorry, I couldn't figure out how to get it to work :\
05:15:25 <Eelis> statusfailed: sometimes "filling the gaps" in a textbook proof can turn up enough complexity that it results in new papers to publish though :/
05:15:26 <zenzike> Jafet: I realise the instances look equally specific, but I thought that GHC picked the first such instance in that caase
05:15:52 <Jafet> What is the "first" instance?
05:15:56 <zenzike> statusfailed: glad I'm not the only one
05:15:59 <Eelis> statusfailed: like when i tried to write down a textbook proof of quicksort's average case complexity in coq
05:16:11 <statusfailed> Eelis: I'm sure that's not the case here, it's mostly reasonably simple stuff
05:16:20 <zenzike> Jafet: first defined in the file? Admitedly that doesn't resolve what happens when there are several sources
05:16:25 <Eelis> statusfailed: then it's worth giving it a try. good fun! :)
05:16:37 <Jafet> That doesn't make sense; top-level blocks are not ordered.
05:17:00 <zenzike> Jafet: top level function definitions are ... I didn't think it was that much of a leap
05:17:01 <statusfailed> Eelis: sorry if this is a dumb question: can I do simple algebraic proofs and see the steps made from A to B?
05:17:18 <snowylike> Eelis: if i understand you correctly, there were interesting things about the proof that weren't yet published?
05:17:32 <Jafet> They are not. Function equations are ordered, but that's irrelevant.
05:19:03 <Lethalman> why would one choose agda over haskell?
05:19:17 <shachaf> They are not competing.
05:19:22 * Lethalman reading some agda examples but that's too hard
05:19:30 <zenzike> Jafet: sorry, I meant function equations. I can see that it's different, but I could equally imagine it working out with ordered instances too. Anyway, thanks for pinpointing the hole in my mind :-)
05:19:34 <mel-> is it not possible in Emacs to e.g. evaluate a marked region of Haskell code?
05:20:18 <Jafet> @quote learn.agda
05:20:18 <lambdabot> ManuelChakravarty says: We used to say, "Learn Haskell, it makes you a better Java programmer." Now we say, "Learn Agda, it makes you a better Haskell programmer."
05:21:05 <Lethalman> :S
05:21:17 <statusfailed> zenzike: I think I got it
05:22:21 <srhb> Lethalman: One doesn't really choose Agda over Haskell except for very specific reasons. :P
05:22:37 <hpaste> statusfailed pasted “Sampling purely in random-fu” at http://hpaste.org/80102
05:22:56 <statusfailed> zenzike: might be able to clean that up, but it seems to work
05:23:49 <b_> can I see derived types for Functor and Foldable?
05:24:16 <b_> derived instances*
05:26:10 <zenzike> statusfailed: thanks for looking into this. I was actually trying to avoid using StateT since it seemed silly when all I need is State. Still, thanks for prodding!
05:26:25 <srhb> zew
05:26:28 <srhb> Woops
05:27:10 <statusfailed> zenzike: ah, ok. Yeah, I kinda gave up 'cause I didn't understand the error
05:27:12 <statusfailed> heh
05:34:53 <fmap> b_: -ddump-deriv?
05:36:03 <zenzike> statusfailed: heh, yeah it's a bit of an odd one: ghc thinks that there's no overlapping instance that's more specific
05:42:01 <zenzike> statusfailed: I got it to work by providing an instance for 'Lift Identity (t Identity)'
05:46:37 <westchester> Hello! The GHC manual tells me that case is generally stricter than let. What about where? Is where just a syntactic dual of let with a different precedence, or will it affect strictness?
05:47:51 <merijn> westchester: I think where is identical to let (but I may be wrong)
05:48:22 <shachaf> westchester: where just gets turned into let.
05:48:32 <westchester> ok, great thanks
05:48:34 <merijn> westchester: afaik the only difference between let and where is scoping (i.e. where can scope over multiple guards)
05:48:39 <shachaf> But it's not really the same thing syntactically: let ... in ... is an expression; where isn't an expression.
05:48:45 <mel-> i prefer let, since i usually read from the top to the bottom
05:49:01 <shachaf> (In "foo = ... where ...", there "where" belongs to the binding. You can't say "x where x = 5" in some arbitrary place.)
05:49:29 <westchester> i prefer where as it puts the resulting value first, and then the gritty details second, and it looks more like math notation
05:49:54 <westchester> unrelated, where do I submit possible typos in the manual? via the same bug system as code bugs?
05:50:01 <latro`a> can case trigger corecursion?
05:50:08 <latro`a> (can't think of a nontrivial example)
05:50:12 <srhb> mel-: If you have multiple pattens in a function?
05:50:17 <merijn> westchester: Yeah, most people (including me) prefer where
05:50:36 <merijn> srhb: where only scopes over one pattern, doesn't it?
05:50:48 <merijn> srhb: I think it can only scope over multiple guards, not multiple patterns?
05:51:07 <latro`a> well, you can turn multiple patterns into multiple guards with PatternGuards
05:51:16 <latro`a> that's frequently not what you want, of course
05:51:28 <srhb> merijn: Eh, that's what I meant, yeah. :)
05:51:40 <merijn> srhb: Good, means I'm not going insane :p
05:51:43 <byorgey> westchester: yes, you can submit manual typo reports to the same bug tracker I think
05:53:44 <srhb> I guess we don't have the equivalent of "local ... in ..." in Haskell which scopes over multiple patterns. Unless we use Pattern guards (or just case)
05:54:04 <nilsi_> Hey, im a totally noob at haskell and there is one thing that i found different from other languages ive tested. Im using the editor textmate where im having a file called test.hs. in that file i just got: let [a,b,c] = "cat" in (a,b,c)
05:54:16 <nilsi_> when is running this i got the Parse error: naked expression at top level
05:54:28 <Botje> nilsi_: correct. files can only contain bindings.
05:54:46 <nilsi_> So I cant run this?
05:54:48 <latro`a> x = let [a,b,c] = "cat" in (a,b,c) is correct
05:55:11 <nilsi_> latro`a: ah thanks
05:55:30 <latro`a> does the same as x = ('a,'b','c')
05:55:56 <srhb> nilsi_: In order to "run" a program, you need a main function though. You would probably find it simpler to work in ghci for simple tests, where you can indeed write your let statement directly
05:56:20 <mel-> srhb: i'm not sure what you mean with that comment about multiple patterns
05:56:26 <nilsi_> Okey guys thanks.
05:56:34 <srhb> mel-: I meant guards, sorry.
05:56:40 <srhb> mel-: where scopes over multiple guards
05:57:04 <nilsi_> srhb: But if i want to run x = let [a,b,c] = "cat" in (a,b,c) in a main function. How do i do it?
05:57:16 <srhb> nilsi_: Depends what you mean by "run"
05:57:24 <latro`a> also depends on what you want the program to *do*
05:57:30 <mel-> srhb: i guess i would need an example to figure this out. :)
05:57:43 <latro`a> a program that just assigns a variable doesn't actually *do* anything
05:57:52 <latro`a> you could say, for example
05:58:01 <latro`a> x = let [a,b,c] = "cat" in (a,b,c)
05:58:05 <latro`a> main = print x
05:58:23 <nilsi_> latro`a: Ah, yea like that, thanks. just tried main = x
05:58:24 <latro`a> ^is a valid program that you can compile and run
05:58:31 <nilsi_> tyvm
05:58:42 <hpaste> merijn pasted “where + guards” at http://hpaste.org/80105
05:58:54 <merijn> mel-: Check out that paste, you can't do the same with let
06:03:07 <mel-> aaah, okay. so let + guards in this way does not work but where + guards does. thanks!
06:04:01 <Lethalman> :t guard
06:04:02 <lambdabot> MonadPlus m => Bool -> m ()
06:05:56 <srhb> Lethalman: That's something else entirely than what we discussed, just FYI. :-)
06:06:54 <Lethalman> srhb, ahah np just reminded me of guard, which I just forgot the definition of
06:07:37 <latro`a_> @src guard
06:07:37 <lambdabot> guard True  =  return ()
06:07:37 <lambdabot> guard False =  mzero
06:07:41 <latro`a_> ^
06:11:48 <fragamus> can anyone help shorten this:
06:11:49 <fragamus> randomHash = ((return . H.finalize . (H.update H.init)) <=< getBytes) 40
06:12:44 <fragamus> I think the parentheses are icky
06:13:33 <srhb> H.finalize . H.update H.init is identical to your bracketed version
06:13:52 <srhb> The outer one can be removed by using $ instead, I believe
06:14:07 <moops> what am i doing wrong here http://pastebin.com/rrVL2eg3 complete beginner
06:14:23 <mauke> The paste rrVL2eg3 has been copied to http://hpaste.org/80107
06:14:38 <Lethalman> :t map (print) [1, 2, 3]
06:14:40 <lambdabot> [IO ()]
06:14:47 <moops> changing line 7 to "    putStrLn "Hello, world"" will run fine
06:14:52 <Lethalman> mauke, you need an IO [()]
06:15:04 <Lethalman> moops, so try sequence $ map (print) [1, 2, 3]
06:15:11 <Lethalman> :t sequence $ map (print) [1, 2, 3]
06:15:13 <lambdabot> IO [()]
06:15:25 * Lethalman impressed he got the thing right! :P
06:15:51 <moops> same error
06:16:02 <`ramses> moops: you need to load the file
06:16:09 <`ramses> :l <filename>
06:16:36 <`ramses> ghci does not scan the filesystem to find modules
06:16:54 <moops> this is my only file, im in leksah
06:17:23 <`ramses> ow, don't know about leksah, but I'd say the file is not loaded in ghci
06:17:30 <moops> other programs have worked
06:17:37 <moops> er
06:17:47 <moops> ive written other things in this file and gotten them to run
06:17:51 <`ramses> by using :m to load custom modules?
06:18:00 <moops> theres a run button
06:18:27 <fragamus> so using your suggestions I now have this:
06:18:28 <fragamus> randomHash = (return . H.finalize . H.update H.init) <=< getBytes $ 40
06:18:37 <moops> for instance this works fine http://pastebin.com/3wCjJB8E
06:18:54 <mauke> The paste 3wCjJB8E has been copied to http://hpaste.org/80108
06:19:05 <fragamus> I like the <=< because it goes right to left like the . composition operator
06:19:14 <moops> oh now it works
06:19:25 <moops> i shouldnt be using this IDE probably
06:19:40 <fragamus> can I get rid of that last pair of parens?
06:20:10 <M30W> What is the correct term for the following data structure? x = {y = 1, z = "test"}
06:20:16 <fragamus> yes!
06:20:28 <`ramses> moops: btw, you probably want to use mapM_ instead of map
06:20:58 <moops> noted, thanks
06:21:34 <fragamus> randomHash = return . H.finalize . H.update H.init <=< getBytes $ 40
06:21:39 <`ramses> moops: maybe the IDE is just not configured correctly ?
06:21:50 <quicksilver> M30W: that's not quite correct haskell syntax at all.
06:21:50 <M30W> x = t { y = 1, z = "test" } -- *
06:21:59 <quicksilver> M30W: that's a record update
06:22:00 <fragamus> is there a way to get rid of the return?
06:22:05 <moops> `ramses: yea i think thats it
06:22:28 <M30W> quicksilver: Meaning?
06:22:37 <srhb> fragamus: Using Functor instead of Monad, maybe?
06:22:39 <M30W> Oh
06:22:50 <quicksilver> M30W: it creates a new value like 't', but with the y field set to 1 and the z field set to 'test'
06:22:53 <M30W> Redefining the values from t.
06:23:05 <fragamus> hmmm I'll have to read up on that idea
06:23:35 <srhb> fragamus: H.finalize . H.update H.init <$> getBytes $ 40 -- I think
06:23:50 <srhb> Modulo associativity and precedence.
06:23:57 <srhb> *cough*
06:24:05 <M30W> type t = t { x :: Int, z :: String }
06:24:13 <M30W> data *
06:24:15 <quicksilver> fragamus: (return . f <=< a) is just fmap f a
06:24:29 <quicksilver> fragamus: (which can also be written f <$> a, as srhb says)
06:24:47 <quicksilver> erm that's not quite true
06:25:19 <quicksilver> fmap f . a
06:25:42 <M30W> data X = X { a :: Int, b :: String, c :: Int } -- *
06:26:03 <M30W> What is the correct term to call that kinda of data structure?
06:26:35 <srhb> M30W: I suppose it's a product type
06:26:58 <srhb> M30W: More specifically a product of Int, String and Int.
06:27:12 <M30W> Okay.
06:27:36 <shachaf> M30W: A record.
06:27:39 <M30W> Greatful for extracting data from I must say :)
06:27:51 <M30W> shachaf: Just a record?
06:27:55 <srhb> Oh, yeah... I didn't think that was the question. :P
06:27:59 <quicksilver> I think record is just a notation.
06:28:03 <shachaf> I don't know what the uestion is.
06:28:11 <quicksilver> it's the same type as data X = X Int String Int
06:28:12 <srhb> shachaf: So you're trying every possible answer?
06:28:17 <shachaf> The correct name for that data type is obviously X.
06:28:30 <quicksilver> record notation just gives you a different (optional) syntax for match/extract/update
06:29:07 <M30W> shachaf: The correct term for the data structure. I.e 5 -> Int, [a, b, c] -> Array
06:29:13 <M30W> List in haskell *
06:29:30 <srhb> Wat.
06:29:41 <shachaf> There are no terms.
06:29:52 <M30W> Interesting.
06:29:54 * hackagebot snaplet-mongodb-minimalistic 0.0.6.6 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.6 (PetrPilar)
06:30:17 <M30W> So I continue to just call it a data struct?
06:30:54 <srhb> M30W: Or a type. *shrugs*
06:31:04 <M30W> Heh.
06:31:11 <srhb> M30W: No, really. I would. :P
06:31:45 <M30W> Lol
06:31:45 <srhb> M30W: More specifically you generally talk about data Person = Person { name :: String, age :: Int } as "the Person type"
06:31:49 <M30W> So data struct it is
06:32:02 <shachaf> Names don't matter.
06:32:09 <srhb> Not really, no.
06:32:28 <quicksilver> algebraic data type perhaps, M30W
06:32:30 <quicksilver> or just 'data'
06:32:35 <quicksilver> in a haskell context
06:33:05 <quicksilver> names might not matter in the absolute but, locally speaking, it helps to have a shared vocabulary for talking about things.
06:33:37 <M30W> ^ Hence I'm asking; been caught out a few times for "array" in here over the months hehe
06:34:25 <M30W> How might one have a type State being 1 of a list?
06:34:26 <srhb> M30W: Well, that's because List is not an Array type. Array is, though.
06:34:39 <srhb> M30W: I don't understand that question.
06:34:57 <M30W> I.e State may be one of [ "active", "inactive", "finished", "paused" ]
06:35:15 <quicksilver> data State = Active | Inactive | Finished | Paused
06:35:25 <quicksilver> is probably the most natural
06:36:23 <M30W> Thank-you
06:36:54 <fragamus> well i tried fmap but...
06:36:56 <fragamus> Expected type: Int -> ByteString
06:36:56 <fragamus>       Actual type: Int -> m0 ByteString
06:37:45 <fragamus> randomHash = (H.finalize . H.update H.init) `fmap` getBytes $ 40
06:37:57 <fragamus> thats the offending code
06:38:06 <b_> how come there aren't too many useful general typeclasses besides Functor, Applicative, Monoid, Traversable, Foldable, Monad, (Lens)?
06:38:22 <shachaf> fragamus: That's (fmap (...) getBytes) 40
06:38:26 <srhb> b_: Because they're just that general!
06:40:31 <quicksilver> fragamus: drop the $
06:40:45 <quicksilver> (H.finalize . H.update H.init) `fmap` getBytes 40
06:41:40 <fragamus> wow cool    thanx!
06:42:45 <yitz> fragamus: `fmap` (with the backticks) is called <$> (except the precedence might be a little different, not sure)
06:43:07 <fragamus> its working… i am using it now
06:43:19 <Lethalman> yitz, hi, in the end this is what I've written: http://hpaste.org/80109
06:43:22 <fragamus> randomHash = (H.finalize . H.update H.init) <$> getBytes 40
06:43:31 <Lethalman> yitz, does it look good at a first glance?
06:43:42 <fragamus> i think thats about as far as it can go
06:44:06 <fragamus> it seems ultimately concise
06:44:15 <srhb> Lethalman: Notice the hlint suggestions in the bottom. :)
06:44:51 <Lethalman> srhb, right... first times using hpaste... that's nice :)
06:45:33 <yitz> hi Lethalman!
06:45:38 <fragamus> whoops the parens can go away so it gets better!!!
06:45:51 <srhb> fragamus: Yes, <$> has lower precedence than .
06:46:05 <fragamus> ok now its the best it can be
06:48:20 <srhb> @index (<$>)
06:48:20 <lambdabot> bzzt
06:48:27 <srhb> Herp.
06:49:36 <t7> who is Lyndon Maydwell?
06:49:41 <t7> please stand up
06:49:46 <yitz> Lethalman: and it works? i.e. doesn't run out of memory, crash, whatever?
06:50:08 <papyrus> hi..
06:50:33 <Lethalman> yitz, constant heap size
06:50:43 <yitz> Lethalman: looks like that mersenne monad actually works for you. you just had to make sure to force the arguments to montecarlo each time to stop those thunks from piling up.
06:50:56 <yitz> Lethalman: great news! good work!
06:51:06 <Lethalman> yitz, it works, but I can't use lazy lists
06:51:17 <yitz> Lethalman: ok. not surprising.
06:51:30 <Lethalman> foo <- replicateM N sample will strictly create such a list
06:51:55 <yitz> Lethalman: and strictly creating infinite lists is usually not recommended
06:52:16 <yitz> :)
06:52:20 <Lethalman> ;)
06:52:44 <Lethalman> yitz, but that's possible with Rand of Control.Monad.Random, except that StdGen itself will add tons of thunks unfortunately
06:52:55 <Lethalman> that is, maybe there's a possibility to have both worlds
06:52:55 * yitz nods
06:53:12 <Lethalman> for example, a state next would work
06:53:14 <Lethalman> :t state next
06:53:16 <lambdabot> (MonadState s m, RandomGen s) => m Int
06:53:20 <Lethalman> yeah
06:53:26 <Lethalman> did I get it right? :D
06:53:28 * Lethalman should try it
06:53:43 <Lethalman> by rewriting next with bangs
06:54:21 <yitz> Lethalman: ok. an advantage of a generic State monad is that you can choose between a "lazy" one or a "strict" one.
06:55:36 <yitz> Lethalman: but that actually only affects the laziness of a certain part of the >>= operation of the monad. there are other places where the laziness/strictness might be wrong for you.
06:55:54 <yitz> Lethalman: you just have to experiment a little.
06:55:59 <Lethalman> yitz, yes I will try
06:56:13 <yitz> Lethalman: ok have fun!
06:57:55 <Lethalman> :)
07:08:32 <beaky> what is the limit to the number of variants I can have
07:08:43 <beaky> in an algebraic data type
07:19:00 <yitz> beaky: interesting question. probably quite a lot. i wonder which will crash first - ghc or your computer?
07:19:40 <yitz> beaky: definitely not more than maxBound :: Int
07:19:55 <shachaf> yitz: I don't think that's specified in the Report.
07:20:52 <yitz> shachaf: right. but i think ghc uses and Int to address them.
07:20:58 <yitz> *an
07:21:28 <shachaf> In GHC an Int is the size of a pointer, so it'll be tricky having more constructors than that.
07:21:35 <yitz> yes
07:21:47 <yitz> but there may be some much smaller practical limit than that.
07:22:05 <shachaf> Oh, surely.
07:22:17 * shachaf likes the magic primitive tagToEnum#
07:22:30 <srhb> What's that?
07:22:33 <yitz> similarly to list literals, which cause ghc to stop working very quickly when they are more than a few lines long.
07:22:40 <yitz> which is quite annoying
07:23:04 <shachaf> srhb: It's so magic that I can't tell you its type.
07:23:20 <shachaf> It turns an Int# tag -- like 0 or 1 -- into an enumerated type value -- like False or True.
07:23:31 <srhb> ... neat
07:23:34 <shachaf> Er, like 0# or 1#
07:23:39 <shachaf> You can get it from GHC.Prim
07:23:51 <shachaf> Feel free to try let x = tagToEnum# 2# :: Bool in x
07:24:06 <beaky> C++  boost::variant seems to have only 12 types bfore it blows up :(
07:24:36 <yitz> beaky: i think ghc can beat than handily
07:25:18 <beaky> it has only 20* types
07:26:00 <beaky> guess they didn't update for variadic templates yet :(
07:28:36 <Lethalman> @hoogle .&.
07:28:36 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
07:28:36 <lambdabot> Test.QuickCheck.Property (.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
07:28:36 <lambdabot> Test.QuickCheck (.&.) :: (Testable prop1, Testable prop2) => prop1 -> prop2 -> Property
07:28:57 <M30W> quicksilver: data State = Active | Inactive ... -- How to print the state?
07:29:37 <`ramses> M30W: add deriving Show
07:29:48 <`ramses> then you can use show to get a string representation
07:30:23 <M30W> Thanks
07:30:34 <M30W> Yes, I know. :)
07:30:50 <M30W>     Possible fix: add an instance declaration for (Show State)
07:30:54 <M30W> Hehe.
07:31:02 <`ramses> then why did you ask?
07:31:18 <`ramses> ah, you knew about show, you mean?
07:31:30 <quicksilver> or write your own print function which does whatever you want.
07:32:01 <`ramses> Show is a pretty easy typeclass, probably not bad to see how that works :)
07:32:29 <quicksilver> printState Active = "apple"; printState Inactive = "dolphin"; printState Finished = "Forty-Two"
07:32:31 <Lethalman> :t next
07:32:32 <lambdabot> RandomGen g => g -> (Int, g)
07:32:33 <Lethalman> :t state next
07:32:35 <lambdabot> (MonadState s m, RandomGen s) => m Int
07:32:46 <Lethalman> mh
07:32:51 <Lethalman> no probably not what I want
07:32:55 <quicksilver> you may not necessarily want to use the same representation as the names of the constructors, and it may  not be right to use 'Show' for what you want.
07:33:05 <quicksilver> on the other hand, deriving Show is certainly a quick way to get something working.
07:33:28 <M30W> quicksilver: Indeed.
07:33:41 <Lethalman> how do I create a monad that keeps the state of the generator yet I can return anything I want?
07:33:43 <M30W> And nice; thanks for mentioning that, beats making conditions later on :P
07:33:49 <Lethalman> like Rand a
07:36:17 <quicksilver> all monads have the property that you can return anything you want
07:36:23 <quicksilver> that is one of the requirements to be a monad
07:36:31 <quicksilver> (it's what the "return" operation guarantees)
07:38:19 <DrSyzygy> quicksilver: Translating this statement to category theory, this is what it means for monad to be a functor with a natural transformation from Id, right?
07:38:30 * DrSyzygy is asking for my own understanding, not for anyone elses. :-)
07:40:43 <quicksilver> DrSyzygy: Yes.
07:41:09 <quicksilver> return :: a -> m a is a natural transformation from Id.
07:46:18 <Lethalman> "omg omg" I did it
07:47:22 <srhb> Lethalman: :-) Congrats.
07:47:26 <Lethalman> lol
07:47:28 <Lethalman> thanks
07:47:35 <Lethalman> used my first state monad
07:47:45 <Lethalman> in the sense of calling state and so on
07:50:54 <neutrino> hi
07:56:28 <shapr> cabal install text keeps failing on my Raspberry Pi :-(
07:56:44 <quicksilver> shoulda bought a Raspberry Lambda.
07:57:04 <neutrino> hi shapr
07:57:10 <shapr> hi neutrino
07:57:29 <neutrino> can i also make fun :)
07:57:43 <neutrino> "it's because you only bought half a tau"
07:57:53 <shapr> :-P
07:58:00 <shapr> It looks like it's failing on Data.Text.Lazy
07:58:11 <shapr> It previously failed on QuickCheck2 because of the Template Haskell
07:58:17 <shapr> Does text use TH also?
07:59:05 <niteria> @src concat
07:59:06 <lambdabot> concat = foldr (++) []
07:59:37 <niteria> :t concat
07:59:39 <lambdabot> [[a]] -> [a]
08:00:26 <niteria> > concat [[a], [b], [c], [d]]
08:00:27 <lambdabot>   [a,b,c,d]
08:00:32 <danr> is it possible to sleep processes spawned with System.Process, and later wake them up?
08:00:39 <Lethalman> what's the difference between State and ST?
08:00:59 <danr> ST gives you STRefs (which work like IORefs) and ST-arrays
08:01:16 <danr> State is just threading another state argument around
08:02:15 <danr> I guess you could put it this way: with ST you can add more state as you please, but this has to be decided in advance with State
08:02:22 <danr> Lethalman: ^
08:02:44 <shachaf> That phrasing makes it sounds like ST is simply a better version of State.
08:02:50 <shachaf> In reality they're two different things.
08:04:43 <JoeyA> In Data.ByteString, why is hPutStrLn deprecated (in favor of importing from .Char8), but hGetLine isn't?
08:04:44 <Lethalman> @src replicate
08:04:44 <lambdabot> replicate n x = take n (repeat x)
08:04:53 <Lethalman> @src repeat
08:04:53 <lambdabot> repeat x = xs where xs = x : xs
08:04:57 <shapr> Ah, after running "cabal install text" for the third time while watching memory usage, I hit 100% RAM usage on file 31 of 39 and the whole thing falls over.
08:05:37 <Lethalman> @src sequence
08:05:37 <lambdabot> sequence []     = return []
08:05:38 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:05:38 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
08:05:47 <shapr> So, no more Haskell dev for my Raspberry Pi unless I get one of the recent 512MB Pis to use in place of my 256MB Pi
08:05:54 <Lethalman> right
08:06:05 <Lethalman> danr, mh ok
08:07:02 <danr> Lethalman: is it something in particular you had in mind using state for?
08:07:57 <Lethalman> danr, yes trying a more strict version of Rand
08:07:57 <Lethalman> danr, then replicateM 1000000 genRandom
08:07:58 <Lethalman> danr, if I use Control.Monad.State then I get a lazy list, but with lots of thunks
08:08:01 <shachaf> JoeyA: That's a good question. It probably ought to be.
08:08:11 <shachaf> JoeyA: Maybe it has something to do with line buffering modes or who knows what.
08:08:17 <Lethalman> danr, otherwise with State.Strict I will get the whole list in memory
08:09:38 <JoeyA> shachaf: Nope, it just looks for 8-bit '\n'
08:09:51 <chreekat> If I want to put tests for my functions in a separate file, do I need to explicitly create a module for my source file that can be imported by the test file?
08:10:01 <Lethalman> danr, I thought there was something in the middle, i.e. for which the state is kept strictly, and still use a lazy list
08:10:01 <Lethalman> maybe it's sequence that is lazy itself, let's see
08:10:01 <Lethalman> (in computing v)
08:10:01 <Lethalman> :t sequence
08:10:02 <lambdabot> Monad m => [m a] -> m [a]
08:10:38 <shachaf> JoeyA: Yes, but if the input mode is "line-buffered", the OS/terminal/something might still give you data line-at-a-time?
08:10:41 <shachaf> I don't know.
08:10:53 <shachaf> Looking for 0x0a isn't great when you're dealing with bytes.
08:10:57 <shachaf> JoeyA: You should report it as a bug!
08:13:09 <Lethalman> no way
08:13:51 <danr> Lethalman: I'm not sure, maybe you can get the state afterwards and just seq it. I never had this problem
08:14:22 <danr> Lethalman: did you try using randomRs?
08:14:49 <Lethalman> danr, yes
08:19:11 <Lethalman> @src state
08:19:11 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:24:48 <dublisk> Hi, trying to understand pattern matching on a list. If I do "foo (x:xs) = …" then x will refer to an element, and xs will be a list?
08:24:57 * hackagebot srcloc 0.4.0 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.4.0 (GeoffreyMainland)
08:25:00 <neutrino> hello
08:25:18 <mauke> dublisk: x will be the first element, xs will be the remaining list
08:25:24 <mauke> @src []
08:25:24 <lambdabot> data [] a = [] | a : [a]
08:25:33 <neutrino> what ways of describing the structure of a program are there, other than RPN (aka lisp-style AST), and von Neumann style?
08:27:34 <kennyd> > let foo (x:xs) = (x,xs) in foo [1..4]
08:27:36 <lambdabot>   (1,[2,3,4])
08:27:52 <kennyd> > let foo (x:y:ys) = (x,y,ys) in foo [1..4]
08:27:54 <lambdabot>   (1,2,[3,4])
08:28:12 <mauke> > case [1..4] of x : xs -> (x, xs)
08:28:14 <lambdabot>   (1,[2,3,4])
08:28:19 <mauke> > case "A" of x : xs -> (x, xs)
08:28:21 <lambdabot>   ('A',"")
08:29:37 <Lethalman> danr, I'm trying to understand if there's a way to get a lazy replicateM N genRandom without requiring a bunch of thunks
08:29:46 <Lethalman> but I'm failing at that
08:30:14 <Lethalman> I should try with something else than genRandom and see if it's a general issue or not
08:30:42 <danr> Lethalman: well if you don't evaluate your random numbers, you have to have a thunk there
08:31:07 <beaky> hello
08:31:13 <danr> and if you want your state after this lazy list, the spine of the list has to be evaluated
08:31:49 <Lethalman> danr, foo <- replicateM N genRandom ; return (last foo)
08:31:59 <beaky> what is the difference between an Array and an IOArray?
08:32:12 <c_wraith> beaky: pretty much everything
08:32:23 <Lethalman> danr, that's what I'd like to do without thunks, that's not possible because last will not evaluate the elements?
08:32:36 <c_wraith> beaky: Array is immutable, IOArray is mutable
08:32:48 <beaky> how are purely ufucyional arrays implemented
08:32:58 <beaky> functional*
08:33:33 <danr> Lethalman: er, yes?
08:33:35 <Lethalman> mh no it's not even that
08:33:45 <danr> I didn't quite get the question there
08:34:02 <c_wraith> beaky: as a block of memory with no operations to modify it? I mean.. There's nothing strange about the implementation
08:34:17 <Lethalman> danr, the question is: is there a possibility to achieve return (last foo) from that list, by not keeping thunks around?
08:34:32 <westchester> beaky: you also have vectors, which are lots of little arrays in a tree, so to modify one value you only have to modify the little array, and the chain of nodes pointing to it
08:34:57 * hackagebot keter 0.3.4.2 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.4.2 (MichaelSnoyman)
08:35:01 <westchester> beaky: so they're purely function arrays which have a more mutable interface, rather than just destroying the whole thing adn starting again with each modification
08:35:40 <shachaf> westchester: I don't think that's what any common Haskell library that uses the name "vector" does.
08:35:41 <beaky> ah
08:36:08 <westchester> westchester: really? there is some data structure with that implementation. some other language must call it vector then
08:36:19 <parcs> Lethalman: what do you mean by "not keeping thunks arounds"
08:36:21 <beaky> Data.Sequence?
08:36:43 <westchester> beaky: that's the badger
08:37:48 <hpaste> Lethalman pasted “Heap overflow” at http://hpaste.org/80111
08:37:53 <Lethalman> parcs, ^^
08:38:42 <parcs> Lethalman: and the problem is 'foo' right
08:39:04 <Lethalman> parcs, (last samples) will exceed heap size
08:39:14 <Lethalman> parcs, samples is lazy
08:39:38 <parcs> it's not actually lazy though
08:39:57 <Lethalman> parcs, if I return (1) it doesn't heap overflow, doesn't do the computation
08:40:32 <Lethalman> parcs, (head samples) works as well
08:40:45 <Lethalman> but (last samples) is keeping thunks of previous generators
08:41:07 <Lethalman> State.Strict will instead compute foo regardless of whether I use it or not
08:41:12 <Lethalman> I'd like to know if there's something in the middle
08:41:20 <Lethalman> not completely lazy and not completely strict
08:41:35 <Lethalman> ops, *compute samples
08:41:46 <neutrino> other than rpn and infix, are there no other ways to enter code/data/programs?
08:42:23 <srhb> neutrino: punchcards?
08:42:43 <parcs> Lethalman: does using State.Strict overflow the heap?
08:43:20 <Lethalman> parcs, yes because it computes the whole samples when I do samples <- ...
08:43:27 <Lethalman> even if I don't use samples
08:43:39 <neutrino> srhb: punch cards are an encoding, they're not a structuring
08:43:53 <neutrino> punch cards define a line of text per each punch card
08:44:03 <srhb> Lethalman, parcs: Maybe I'm completely wrong here, but doesn't the fact that you're not forcing s1' s1'' etc. mean you're still delaying the entire computation till the end?
08:44:17 <Lethalman> srhb, tried that as well
08:44:36 <Lethalman> I believe there's something in the middle that should be tweaked inside the monad
08:44:37 <parcs> srhb: no, because the next time you call myNext those variables will be forced
08:45:32 <gilligan_> Don't know what people around here consider good books for getting started with Haskell but i'm currently reading 'Real World Haskell' (O'Reilly) and its great
08:46:04 <Lethalman> maybe the problem is with last, but I tried last' (x:xs) = x `seq` (last' xs) without luck
08:46:13 <srhb> parcs: Alright, thanks.
08:46:26 <Lethalman> it's like every element in samples refer the previous element
08:46:52 <Lethalman> but even with return (length samples) there is a problem
08:46:53 <srhb> Lethalman: Well, if the problem is as you state, you could try enclosing your lazy version in a fake function first.
08:46:57 <Lethalman> that is, without actually evaluating anything
08:47:00 <srhb> Er, your strict version
08:48:35 <Lethalman> srhb, btw I solved without using lazy lists, that is working inside the monad recursively
08:48:40 <Lethalman> it was just curiosity
08:48:51 <srhb> Oh, okay.
08:48:56 <Lethalman> I'm still low knowledged to do something smarter than that
08:49:19 <srhb> Well, I'm fairly sucky at strictness analysis still, so I should just shut my mouth. ;)
08:49:34 <parcs> Lethalman: the whole of samples will always have to be computed if you want to access the last element of 'samples'
08:50:00 <Lethalman> parcs, computed ok, but while getting to the last element that could be done step by step without keeping thunks
08:50:05 <c_wraith> Lethalman: have you described the problem you're solving somewhere, rather than just attempted solutions?
08:50:25 <c_wraith> I don't understand why you'd generate a list of random numbers then not use them.
08:51:03 <parcs> Lethalman: nope, that's not how it works
08:51:11 <Lethalman> c_wraith, why do you care? the problem is that it exceeds the heap... I solved that particular problem as I said, I'm just curious to know if it's possible to execute that code with lazy lists so that it doesn't exceed the heap
08:51:43 <parcs> Lethalman: the entire list will have to be computed, and the state threaded, before performing 'return (last samples)'
08:51:45 <c_wraith> Lethalman: because it's almost certain you're structuring your solution to the problem in such a way as to defeat laziness.
08:52:29 <Lethalman> parcs, ok, that's because each element keeps track of the previous element due to the state monad?
08:52:58 <parcs> Lethalman: yeah. every (>>=) depends on the result of the previous computation. and there are 1000001 of them
08:53:02 <Lethalman> c_wraith, I wrote a lazy solution for that, I wanted to know if it was possible with lazy lists
08:53:31 <Lethalman> parcs, and isn't there a possibility to get to the last element by evaluating them step by step so to drop thunks?
08:53:50 <c_wraith> it probably is.
08:53:56 <parcs> Lethalman: i don't think so. monads are sort of non-compositional in that respect
08:54:11 <parcs> er, monadic combinators
08:54:38 <c_wraith> But everything you're describing is symptomatic of overcomplicated solutions
08:55:42 <Lethalman> c_wraith, what's complex in samples <- repeat sample ; return (length $ filter satisfy samples) ?
08:56:04 <c_wraith> the fact that you're using monadic binds
08:56:18 <Lethalman> sorry that's sequence $ repeat sample
08:58:38 <c_wraith> But you're getting too fixated on code. That's kind of my point. What's the purpose of the code?
08:59:14 <Lethalman> c_wraith, I solved the problem, it was curiosity
08:59:56 <c_wraith> And your curiosity is special and mine isn't?
09:00:42 <M30W> How would one go for cleanly getting the first 2 arguments from getArgs and ignoring the rest ?
09:01:02 <c_wraith> M30W: pattern match against (arg1:arg2:_)
09:01:12 <M30W> Oh I was close!
09:02:04 <M30W> c_wraith: Suggestion for error checking for that pattern?
09:02:11 <M30W> I.e not 2 arguments
09:02:17 <M30W> not even *
09:02:34 <dmwit> case args of arg1:arg2:_ -> success; _ -> error "you done mucked up"
09:02:50 <c_wraith> yeah, exactly what dmwit suggests.
09:02:50 <M30W> O.o
09:02:58 <shachaf> dmwit: You're just trading one ⊥ for another. :-(
09:03:01 <c_wraith> just put another alternative into the case
09:03:12 <c_wraith> admittedly, you can do something better than error in the failure case - probably.
09:03:25 <dmwit> shachaf: I'm demonstrating a pattern by which you can choose what to do instead of bottom.
09:03:30 <dmwit> Using another bottom is only one choice.
09:03:38 <srhb> c_wraith: Go down that road and you have to resocialize all your users!
09:03:39 <shachaf> Sure.
09:04:58 * hackagebot mainland-pretty 0.2.5 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.2.5 (GeoffreyMainland)
09:05:58 <M30W> dmwit: Smaller suggestion? :P I don't see why a case would be required for this single condition for if it matches?
09:06:20 <srhb> M30W: Because Haskell crashes if the pattern does not match (ie. empty list)
09:06:24 <dmwit> You don't have a single condition, you have two conditions.
09:06:33 <dmwit> One condition is you have enough arguments. The other condition is you don't.
09:06:54 <M30W> dmwit: haskell if?
09:07:08 <shachaf> M30W is probably annoyed that their main = do { (x:y:_) <- getArgs; ... } programs stops being flat with case-of.
09:07:14 <shachaf> I can understand that. I'm annoyed too.
09:07:39 <shachaf> Unfortunately I don't know a good solution to this problem in Haskell.
09:07:52 <dmwit> main = do { args <- getArgs; let x:y:_ = case args of { ... }; ... }
09:08:02 <dmwit> if you want to specify defaults
09:08:12 <shachaf> What if I want to fail and exit the program?
09:08:17 <shachaf> (Not with ⊥, please.)
09:08:37 <shachaf> Some sort of exception thing would work but it would be quite heavyweight.
09:08:41 <dmwit> main = do { args <- getArgs; x:y:_ <- case args of { ...with exitWith... }; ... }
09:08:43 <M30W> shachaf: ⊥ ?
09:08:51 <shachaf> (By "exception" thing I include early return with Either/whatever.)
09:09:03 <shachaf> dmwit: OK, that's using magical IO exitWith powers.
09:09:23 <dmwit> They're not magical, and I don't see why you shouldn't use them if your desired behavior is "exit the program".
09:09:23 <M30W> Oh boy
09:09:26 <dmwit> That's what it's for!
09:09:27 <shachaf> The problem of Haskell definitions getting way too nested with case-of in general is still there.
09:09:30 <M30W> Where'd the time go? O.o
09:09:33 <M30W> Thu Jan  3 04:09:16 EST 2013
09:09:35 <M30W> Night world ^_^
09:09:37 <shachaf> dmwit: That was just an example.
09:09:44 <parcs> sounds like a job for callCC
09:09:50 * shachaf will have to pick examples more carefully next time.
09:09:54 <quicksilver> I'm with dmwit, nothing magical about exitWith
09:09:57 <shachaf> parcs: EitherT would do as well as callCC
09:10:08 <deus_rex> @doc exitWith
09:10:08 <lambdabot> exitWith not available
09:10:11 <shachaf> Fine! I don't want to exit the program. Forget anything about exiting.
09:10:13 <deus_rex> @src exitWith
09:10:13 <lambdabot> Source not found. You type like i drive.
09:10:15 <quicksilver> you can put exit primitives into all kinds of monads
09:10:38 <parcs> the problem of excessive nesting exists in every language
09:10:43 <shachaf> In the average case, with IO or somet arbitrary monad, I would have to use a monad transformer.
09:11:11 <shachaf> Unfortunately monad transformers are ugly and a hack. This seems like a specialized problem that ought to have a nicer solution.
09:11:47 <shachaf> In your average imperativey language you can always say things like "if (args.length < 2) return false;", or what not.
09:11:50 <Philippa_> time for "failing lenses"?
09:11:51 <burbul> @hoogle (Zipper a -> b) -> [a] -> [b]
09:11:52 <lambdabot> Warning: Unknown type Zipper
09:11:52 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
09:12:15 <burbul> Hmmm... there should be some sort of mapZipper function with the type signature I've just given
09:12:28 <shachaf> Zipper isn't a type.
09:12:29 <burbul> like map, except each  'point' can see what the rest of the list looks like
09:12:35 <shachaf> Well, not in the standard library.
09:12:41 <burbul> Data.List.Zipper
09:12:50 <shachaf>     Could not find module `Data.List.Zipper'
09:12:50 <shachaf>     It is not a module in the current program, or in any known package.
09:12:51 <burbul> I don't know what the lambdabot knows about
09:12:58 <burbul> http://hackage.haskell.org/packages/archive/ListZipper/1.2.0.2/doc/html/Data-List-Zipper.html
09:13:26 <shachaf> That's certainly not standard library. I don't even have it installed. :-)
09:13:35 <quicksilver> shachaf: and in haskell you can simply have if length args < 2 then false else ....
09:13:39 <burbul> Are there any zippers in the standard library?
09:13:45 <shachaf> quicksilver: else indent
09:13:50 <quicksilver> simply evaluating to a value is the essence of an immediate return.
09:13:51 <Lethalman> @src guard :: IO ()
09:13:51 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:13:59 <Targen_> Pattern guards can sometimes help alleviate the nested case issue.
09:14:07 <shachaf> quicksilver: Using Either I could make code like this nice.
09:14:14 <nus> Lethalman, so, how does your heap allocation change, if you drop '!'s on 'Int32's  and remove `seq`s from myNext in http://hpaste.org/80111 ?
09:14:17 <parcs> shachaf: that's not necessarily true. there's a language extension to allow you to place the then and else on the same vertical line as the if
09:14:20 <burbul> I can define the function I want in terms of foldlz :: (b -> Zipper a -> b) -> b -> Zipper a -> b
09:14:26 <burbul> But it seems weird that it's not around already
09:14:33 <srhb> parcs: Isn't that default?
09:14:43 <parcs> not sure
09:14:45 <shachaf> > let f x = view chosen $ do { when (x < 2) (Left (-1)); Right (x^2) } in [f 1, f 5]
09:14:47 <lambdabot>   [-1,25]
09:14:53 <shachaf> See, that's pretty nice.
09:14:58 <Lethalman> nus, yes, the heap allocation is not only relative to the state monad but also to the generator now
09:15:08 <sclv> burbul: no
09:15:14 <Lethalman> nus, in that s1 and s2 will depend on previous generators
09:15:14 <sclv> no zippers in base
09:15:18 <burbul> thanks
09:15:19 <shachaf> parcs: OK, but I'm talking about case-of. I'd rather not use "if".
09:15:30 <sclv> also by Zipper i take it you mean "list zipper"?
09:15:33 <Lethalman> nus, or something like that, did the test a while ago though
09:15:36 <burbul> yes, in this case
09:15:45 <nus> Lethalman, I mean what do you achieve by '!'s and `seq`s?
09:15:56 <shachaf> There are many types which have been called "list zipper" over the years.
09:15:56 <nus> Lethalman, in that piece of code?
09:16:13 <shachaf> burbul: It seems like something the Zipper library you linked to ought to provide, if anything.
09:16:16 <parcs> shachaf: use explicit layout!
09:16:30 <shachaf> parcs: Nesting is the problem, not indentation.
09:16:46 <Philippa_> sclv: I think it's fair to consider the Platform standard by now
09:17:07 <shachaf> Philippa_: That doesn't have any list zippers either, so far as I know.
09:18:09 <shachaf> burbul: That "ListZipper" isn't really a zipper in the usual sense of the word.
09:18:14 <shachaf> Since it can represent empty lists.
09:19:59 <M30W> Interesting output from this code I ran out of curiosity. `forever $ forkIO $ putStrLn "This is a test"`
09:20:19 <c_wraith> heh.  putStrLn is not atomic
09:20:33 <c_wraith> Which is what you've probably just discovered
09:20:58 <M30W> ttle forkbomb :)
09:21:07 <M30W> Tiny little forkbomb :) *
09:21:13 <c_wraith> ctrl-c should kill that just fine
09:21:22 <M30W> Which ghci kills it's self lol
09:21:27 <Targen_> forkProcess may be more fun.
09:21:29 <c_wraith> oh, in ghci
09:21:35 <M30W> c_wraith: Yealol
09:21:43 <M30W> ThisTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT[1]    4662 killed     ghci
09:21:48 <M30W> ThTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT[1]    4668 killed     ghci
09:21:54 <M30W> Inconsistant
09:21:58 <Targen_> Or was that forkOS?
09:22:07 <M30W> IO *
09:22:38 <HugoDaniel> whats currently the "best" way to learn haskell ?
09:22:43 <`nand`> by writing it
09:22:45 <HugoDaniel> like crash-course/book/whatever
09:22:47 <HugoDaniel> yes
09:22:57 <M30W> @where lyah
09:22:57 <lambdabot> http://www.learnyouahaskell.com/
09:23:04 <Lethalman> nus, oh, nothing apparently... they are there because I tried it before without monad
09:23:16 <`nand`> Targen_: forkOS iirc
09:23:35 <Lethalman> nus, apparently with the state monad there's no real difference
09:24:08 <Targen_> Heh.  Ran forever $ forkIO ..., and the kernel OOM-killed my browser.  Watch out.
09:24:09 <M30W> HugoDaniel: I'm learning now by working on a project and relying only on haskell docs and irc to work with. Also, hacking together a powerful XMonad config was a great way to start. Understanding the language etc. :)
09:24:26 <`nand`> shachaf: list zipper clearly means ‘Top :>> [a] :>> a’
09:24:58 <M30W> HugoDaniel: Link I got lambdabot to say above; e-book. :)
09:25:43 <nus> Lethalman, so your hypothesis that strictness of the data constructor fields has to do with the issue is demonstrably false
09:25:46 <deus_rex> BONUS is a swell guy and you should buy the book if you find LYAH is helpful
09:26:25 <Lethalman> nus, yes, the point is whether the monad is strict or not
09:26:32 <HugoDaniel> yeah, bonus is cool
09:27:09 <Lethalman> nus, without the monad though, using seq will avoid thunks, or at least I've tested it some days ago
09:30:19 <nus> Lethalman, it's incorrect to speak of a monad as being strict or non-strict... some operations of some monads might be
09:30:58 <Targen_> Does lambdabot do IO?
09:31:12 <srhb> > putStrLn "blah"
09:31:13 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
09:31:13 <lambdabot>    arising from a use of ...
09:31:17 <srhb> Targen_: Apparently not!
09:31:34 <Targen_> Perhaps with some other command?  I’m not too familiar with it.
09:31:40 <srhb> Targen_: No.
09:32:00 <Lethalman> nus, whatever is related to State.Lazy and State.Strict
09:32:01 <Targen_> Ah. :(  I imagine it’s not too pleasant to sandbox.
09:32:35 <srhb> Targen_: Yep.
09:34:29 <nus> Lethalman, try playing with Data.Sequence for a change
09:34:59 * hackagebot random-source 0.3.0.4 - Generic basis for random number generators  http://hackage.haskell.org/package/random-source-0.3.0.4 (JamesCook)
09:40:01 * hackagebot random-fu 0.2.4.0 - Random number generation  http://hackage.haskell.org/package/random-fu-0.2.4.0 (JamesCook)
09:41:03 <M30W> O.o
09:41:16 <M30W> hackagebot >> Saying every change on hackage???
09:41:34 <M30W> Updates *
09:45:26 <mvj4_> yup
09:45:39 <mvj4_> there's also a twitter bot
09:58:48 <ToranLipse> If an algorithm runs at a^n * b^m, how do I write that in big O notation if I dont know what any of the variables will be before the algorithm starts?
10:01:11 <parcs> try ##compsci
10:01:33 <ToranLipse> Ok thanks.
10:01:49 <ToranLipse> Or not...
10:02:33 <HugoDaniel> how can i compare two functions for equality ?
10:02:33 <srhb> Snap!
10:02:39 <srhb> HugoDaniel: You can't, really.
10:04:08 <`ramses> HugoDaniel: evaluate them for all possible inputs and compare? :)
10:05:21 <HugoDaniel> ok
10:05:40 <HugoDaniel> can i render the function name as a string ?
10:05:56 <sclv> no
10:06:12 <sclv> you can stick your function inside some datatype you can compare
10:06:35 <sclv> or just build a datatype with each constructor representing a different function in your universe of functions
10:06:43 <sclv> but the only thing you can do with a function is apply it
10:07:14 <HugoDaniel> ok
10:07:18 <HugoDaniel> yes
10:08:00 <s_kilk> hi all, what's the best way to deal with possible failures when applying the read function?
10:08:18 <`ramses> s_kilk: tried reads?
10:08:58 <s_kilk> for example, i want to parse a CSV file into some something like (String, [Int]) data structures, but to also be safe on bad lines in the CSV file
10:09:16 <sclv> s_kilk: http://stackoverflow.com/questions/8066850/why-doesnt-haskells-prelude-read-return-a-maybe
10:09:24 <sclv> i thought we added it somewhere since then
10:09:26 <`ramses> > reads "ab" :: [(Int, String)]
10:09:27 <lambdabot>   []
10:09:29 <sclv> but i'm not sure in what version
10:09:30 <`ramses> > reads "23ab" :: [(Int, String)]
10:09:31 <lambdabot>   [(23,"ab")]
10:10:00 * hackagebot zip-archive 0.1.3.2 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.1.3.2 (JohnMacFarlane)
10:10:17 <s_kilk> @sclv thanks!
10:10:17 <lambdabot> Unknown command, try @list
10:10:17 <shachaf> sclv: It's in Text.Read in 7.6
10:10:50 <HugoDaniel> so i can do something like data MyFunctions a = Func1 (a -> Text) | Func2 (Int -> Int -> Int) | ...
10:10:51 <sclv> hah, so not in platform yet
10:10:55 <HugoDaniel> and then compare :P
10:11:02 <sclv> the wheels of haskell turn slowly but deliberately
10:11:23 <sclv> HugoDaniel: sure. but you'll only know if the constructors match
10:11:32 <HugoDaniel> yeah
10:11:34 <s_kilk> thanks rameses, that looks like the way to go
10:11:37 <HugoDaniel> it doesn't guarantee
10:11:38 <HugoDaniel> :/
10:11:40 <sclv> so you can't compare two functions of (Int -> Int -> Int) unless they're guarded by different constructors
10:11:52 <sclv> if you do MyFunctions = Add | Subtract | Mult
10:12:07 <sclv> and then you have an "interpret" that maps them to actual functions
10:12:16 <HugoDaniel> yeah
10:12:17 <HugoDaniel> :/
10:12:18 <HugoDaniel> okey
10:12:19 <sclv> then you can compare the uninterpreted values
10:12:27 <`ramses> HugoDaniel: functions are black boxes...
10:12:47 <sclv> HugoDaniel: what are you trying to do in particular?
10:18:12 <HugoDaniel> sclv: im trying to do a simpler version of IxSet
10:18:45 <sclv> ah, and you need function equality for serialization?
10:19:34 <sclv> all the template-haskell stuff with acid-state comes from needing to make functions serializable, etc.
10:20:01 <HugoDaniel> sclv: i was trying to do simple indices
10:20:15 <HugoDaniel> let me finish this, ill show you what i currently have
10:22:42 <Lethalman> is there a blog or something that posts interesting stuff for beginners from time to time?
10:23:17 <codeRat> quit
10:23:41 <HugoDaniel> sclv: http://hpaste.org/80113
10:23:52 <srhb> Lethalman: The subreddet for haskell tends to catch all these blog posts.
10:23:59 <srhb> Lethalman: subreddit*
10:24:32 <HugoDaniel> it doesn't compile im still half-way done with it
10:24:40 <sclv> i don't see where the function comparison comes in?
10:24:46 <HugoDaniel> the idea is that the functions don't need to be serialized
10:25:00 <HugoDaniel> they are compiled, and re-run whenever getData is called
10:25:14 <HugoDaniel> *safeGet
10:25:17 <Lethalman> srhb, right, not something to put in the home due to the high traffic I suppose :)
10:25:25 <Lethalman> will check it from time to time, thanks
10:25:34 <HugoDaniel> sclv: if i could compare functions i would have done the indices differently
10:25:48 <HugoDaniel> since i can't, ill just do it with a diff. constructor per index type :/
10:26:14 <sclv> ah, gotcha
10:27:33 <HugoDaniel> gotta go
10:27:36 <HugoDaniel> ttyl thanks
10:32:15 <M30W> Hmm..
10:32:48 <M30W> (port:_) <- getArgs -- How can I make it expect a number not a list of characters/string ?
10:33:28 <M30W> Other than, args <- getArgs; let port = read $ head args :: Int
10:33:36 <deus_rex> :t head <$> getArgs >>= return . read
10:33:37 <lambdabot> Not in scope: `getArgs'
10:33:45 <deus_rex> :t head <$> System.Environment.getArgs >>= return . read
10:33:47 <lambdabot> Read b => IO b
10:33:56 <deus_rex> :t head <$> System.Environment.getArgs >>= return . read :: Int
10:33:57 <lambdabot>     Couldn't match expected type `Int' with actual type `m0 b0'
10:33:57 <lambdabot>     In the expression:
10:33:57 <lambdabot>         head <$> System.Environment.getArgs >>= return . read :: Int
10:33:59 <deus_rex> :t head <$> System.Environment.getArgs >>= return . read :: IO Int
10:34:00 <lambdabot> IO Int
10:34:17 <S11001001> read.head, deus_rex
10:34:21 <M30W> Wha..?
10:34:31 <deus_rex> hmm
10:34:58 <M30W> :t System.Environment.getArgs >>= return . read . head :: IO Int
10:34:59 <mauke> portStr : _ <- getArgs; port <- readIO portStr
10:35:00 <lambdabot> IO Int
10:35:07 <deus_rex> I need to work on my monad-fu
10:35:20 <S11001001> :t read.head <$> System.Environment.getArgs
10:35:20 <deus_rex> :t (read.head) <$> System.Environment.getArgs
10:35:22 <lambdabot> Read b => IO b
10:35:22 <lambdabot> Read b => IO b
10:35:28 <S11001001> :]
10:35:41 <deus_rex> I thought that >>= return . f seemed a little weird
10:35:45 <S11001001> deus_rex: if you find yourself writing >>= return ...
10:36:28 <deus_rex> :)
10:36:53 <mauke> :t readIO . head =<< System.Environment.getArgs
10:36:55 <lambdabot> Read b => IO b
10:38:18 <Lethalman> :t (=<<)
10:38:19 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:38:35 <Lethalman> :t (=>>)
10:38:36 <lambdabot>     Not in scope: `=>>'
10:38:36 <lambdabot>     Perhaps you meant one of these:
10:38:36 <lambdabot>       `>>' (imported from Control.Monad.Writer),
10:38:43 <Lethalman> :t (>>=)
10:38:44 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:38:46 <M30W> :t (>>=)
10:38:47 <M30W> lol
10:38:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:38:55 <Lethalman> @src (=<<)
10:38:55 <lambdabot> f =<< x = x >>= f
10:39:01 <Lethalman> ok
10:39:10 <Lethalman> :t flip (>>=)
10:39:11 <lambdabot> Monad m => (a -> m b) -> m a -> m b
10:39:22 <M30W> O.o
10:39:28 <M30W> @src (>>=)
10:39:28 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:39:32 <M30W> :(
10:39:41 <srhb> M30W: It also depends on the specific monad.
10:39:49 <srhb> M30W: It's declared in each instance.
10:40:06 <M30W> srhb: What is?
10:40:07 <M30W> lol
10:40:08 * M30W lost
10:40:21 <srhb> M30W: The definition of (>>=) depends on the specific monad instance.
10:40:36 <srhb> M30W: So the list monad and the Maybe monad has different implementations of (>>=)
10:41:03 <mauke> @src [] (>>=)
10:41:03 <lambdabot> xs >>= f     = concatMap f xs
10:41:08 <mauke> @src Maybe (>>=)
10:41:08 <lambdabot> (Just x) >>= k      = k x
10:41:08 <lambdabot> Nothing  >>= _      = Nothing
10:41:16 <deus_rex> @src IO (>>=)
10:41:16 <lambdabot> m >>= k     = bindIO m k
10:42:14 <M30W> I.o
10:42:40 <joar> I'm getting     Illegal instance declaration for `Pretty String'
10:42:50 <joar> when trying to install the json2 package
10:42:51 <mauke> read on
10:43:54 <M30W> > read.head <$> ["6"] :: Int
10:43:55 <`nand`> joar: looks like it's not just you
10:43:55 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:43:56 <lambdabot>              with actual type ...
10:44:07 * M30W still confused on that one lol.
10:44:07 <`nand`> joar: hackage can't built it either
10:44:17 <`nand`> s/built/build/
10:44:32 <joar> `nand`: yeah, found the same error at http://hackage.haskell.org/packages/archive/json2/0.8.3/logs/failure/ghc-7.4
10:44:38 <joar> just after you said it :)
10:44:39 <srhb> > read . head $ ["6"] :: int
10:44:41 <lambdabot>   No instance for (GHC.Read.Read int1)
10:44:41 <lambdabot>    arising from a use of `Text.Read.re...
10:44:46 <srhb> Oh dear.
10:44:53 <srhb> > read . head $ ["6"] :: Int
10:44:55 <lambdabot>   6
10:45:08 <M30W> Heh
10:45:10 <mekeor> i'm looking for: (b -> c) -> Either a b -> Either a c… wait… erm… is it fmap?
10:45:17 <deus_rex> oh hm, it just occurred to me the connection between $ and <$>
10:45:23 <`nand`> mekeor: yes
10:45:24 <latro`a_> mekeor, yes
10:45:29 <mekeor> thanks
10:45:30 <mekeor> :)
10:45:39 <latro`a_> does the left version exist?
10:45:40 <`nand`> deus_rex: (<$>) ($) = ($) ?
10:45:45 <M30W> > read "6" :: Int
10:45:47 <lambdabot>   6
10:45:48 <joar> stability for the json2 package is experimental, I guess I'll pass then.
10:46:01 <`nand`> :t over _left -- latro`a_
10:46:02 <lambdabot> (a -> b) -> Either a c -> Either b c
10:46:08 <latro`a_> mm
10:46:11 <`nand`> latro`a_: or ‘lmap’ from Bifunctor or whatever
10:46:28 <`nand`> oh, it's called ‘first’ in bifunctors
10:46:49 <mekeor> or just: either f id x… maybe? ;) :D
10:47:23 <M30W> > let x = return ["5555"] in read . head x :: Int
10:47:25 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:47:25 <lambdabot>              with actual type ...
10:47:29 <M30W> :(
10:47:29 <`nand`> mekeor: that would have to be either (Left . f) Right
10:47:40 <mekeor> oops
10:47:45 <mekeor> :D
10:47:45 <mekeor> lol
10:47:49 <M30W> > let x = return ["5555"] in x >>= read . head :: Int
10:47:50 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:47:50 <lambdabot>              with actual type ...
10:48:01 <M30W> Yea... I'm lost ^_^
10:48:11 <kennyd> >  read . head <$> return ["6"] :: IO Int
10:48:12 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Types.Int))
10:48:12 <lambdabot>    arising fro...
10:48:47 <M30W> > read . head $ (return ["5"]) :: Int
10:48:48 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:48:48 <lambdabot>              with actual type...
10:48:49 <kennyd> (that would work if lambdabot ran IO actions)
10:48:53 <M30W> > read . head $ (return ["5"]) :: IO Int
10:48:54 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:48:54 <lambdabot>              with actual type...
10:49:05 <Lethalman> M30W, :t return
10:49:15 <M30W> :t return
10:49:16 <lambdabot> Monad m => a -> m a
10:49:35 <Lethalman> :t return :: IO [a]
10:49:36 <lambdabot>     Couldn't match expected type `IO [a]'
10:49:36 <lambdabot>                 with actual type `a0 -> m0 a0'
10:49:38 <lambdabot>     In the expression: return :: IO [a]
10:49:41 <Lethalman> :t return :: [a] -> IO [a]
10:49:42 <lambdabot> [a] -> IO [a]
10:49:51 <Lethalman> :t head
10:49:52 <lambdabot> [a] -> a
10:50:03 <Lethalman> M30W, head wants [a], not IO [a]
10:50:38 <M30W> How to strip down?
10:51:31 <kennyd> :t read . head <$> return ["6"] :: IO Int
10:51:32 <lambdabot> IO Int
10:52:07 <Lethalman> M30W, do { x <- return ["5"]; return (read $ head x) }
10:52:40 <M30W> > return ["5"] >>= return (read $ head)
10:52:42 <lambdabot>   Couldn't match expected type `GHC.Base.String'
10:52:42 <lambdabot>              with actual typ...
10:52:43 <Lethalman> M30W, or return ["5"] >>= return (read . head)
10:52:51 <M30W> Close
10:52:51 <Lethalman> yes
10:52:54 <Lethalman> :)
10:52:59 <M30W> > return ["5"] >>= return (read . head)
10:53:01 <lambdabot>   No instance for (GHC.Show.Show ([GHC.Base.String] -> b0))
10:53:01 <lambdabot>    arising from a...
10:53:03 <`nand`> Lethalman: you meant return . read . head
10:53:13 <M30W> > return ["5"] >>= return . read . head
10:53:14 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
10:53:14 <lambdabot>    arising from a use of `M10591014...
10:53:20 <M30W> > return ["5"] >>= return . read . head :: Int
10:53:22 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:53:22 <lambdabot>              with actual type ...
10:53:27 <M30W> :|
10:53:28 <Lethalman> `nand`, right :)
10:53:36 <Lethalman> M30W, that will still be IO Int
10:54:10 <M30W> How to take to just int????
10:54:17 <M30W> Btw, source = getArgs
10:54:24 <`nand`> you can't
10:55:01 <Lethalman> M30W, foo <- return ["5"] >>= return . read . head
10:55:06 <Lethalman> in foo you will have the int
10:55:08 <kennyd> x <- read . head <$> getArgs :: IO Int
10:55:22 <M30W> Ohhh
10:55:57 * `nand` wonders if it's considered acceptable to unsafePerformIO getArgs, since it won't vary throughout a program run
10:56:11 <M30W> downloader.hs:20:25: Not in scope: `<$>'
10:56:13 <M30W> Hehe..
10:56:20 <`nand`> M30W: import Control.Applicative
10:56:20 <M30W> Control.Monad?
10:56:23 <M30W> Oh
10:57:49 <hpaste> “Anonymous Coward” pasted “The _ after the field name triggers the error” at http://hpaste.org/80119
10:58:15 <M30W> Hmm
10:58:16 <kennyd> M30W you can omit `:: IO Int' part if type can be inferred from the use of x
10:59:00 <M30W> port <- read . head <$> getArgs :: IO Int
10:59:01 <M30W> sock <- listenOn $ PortNumber port
10:59:01 <M30W> putStrLn $ "Listening on " ++ show port
10:59:05 * M30W headache
10:59:38 <Nereid> yeah, it should be able to infer the type of port from its use in PortNumber
11:00:05 <deus_rex> > printf "Listening on %d\n" (2000 :: Int)
11:00:05 <M30W> Howtofix?
11:00:06 <lambdabot>   Ambiguous type variable `a0' in the constraints:
11:00:06 <lambdabot>    (GHC.Show.Show a0)
11:00:06 <lambdabot>     ...
11:00:16 <Nereid> which by the way is not Int
11:00:21 <Nereid> :t PortNumber
11:00:22 <lambdabot> Not in scope: data constructor `PortNumber'
11:00:25 <Nereid> @hoogle PortNumber
11:00:25 <lambdabot> Network PortNumber :: PortNumber -> PortID
11:00:25 <lambdabot> Network.BSD data PortNumber
11:00:25 <lambdabot> Network data PortNumber
11:00:29 <M30W> Nereid: Yea, I noticed.
11:00:32 <Nereid> PortNumber is not Int
11:01:00 <mauke> which one was the one you should never use? PortNum?
11:01:01 <M30W> But show won't work on PortNumber :P
11:01:18 <Nereid> yes it will
11:02:09 <M30W>     No instance for (Read PortNumber) arising from a use of `read'
11:02:11 <M30W> Really?
11:02:17 <Nereid> apparently so.
11:02:18 <M30W> err.
11:02:23 <Nereid> but it has a Num instance
11:02:26 <Nereid> so you can convert it from an Int
11:02:37 <Nereid> ... PortNumber (fromInteger potr)
11:02:39 <Nereid> port
11:02:43 <deus_rex> > show $ PortNumber 2000
11:02:45 <lambdabot>   Not in scope: data constructor `PortNumber'
11:02:48 <M30W> Hmm
11:02:50 <deus_rex> > show $ Network.PortNumber 2000
11:02:51 <lambdabot>   Not in scope: data constructor `Network.PortNumber'
11:02:54 <`nand`> λ show (1 :: PortNumber)
11:02:56 <`nand`> "1"
11:02:58 <`nand`> works fine here
11:03:03 <Nereid> yes, show works, but not read
11:03:47 <Modius> http://hpaste.org/80119  <-- problem with lenses, if I put a _ in the end of the field name I get the error listed; but that's what the example code does.  Should I deal with the Context thing, or look at the naming?  (I.e. do I have a lib problem or a syntactical one?)
11:04:17 <edwardk> Modius: looking
11:04:23 <M30W> Nereid: fromInteger didn't?
11:04:30 <M30W>     Couldn't match expected type `Integer' with actual type `Int'
11:04:33 <M30W> Oh hehe
11:04:35 <`nand`> (deriveLenses? I thought it was makeLenses. And what's with _ at the end of the name, as opposed to before it?)
11:04:37 <Nereid> M30W: well yes, port has to be an Integer now.
11:04:45 <M30W> Specfic much lol
11:04:45 <edwardk> oh thats data-lens or one of the other lens libs
11:04:49 <M30W> Yea, I noticed
11:04:59 <`nand`> oh that explains it
11:05:02 <`nand`> Modius: switch to lens :D
11:05:02 <Nereid> Modius: use lens ;)
11:05:05 <M30W> Is there any diff with Int and Integer?
11:05:08 <Nereid> yes
11:05:13 <M30W> Other than name?
11:05:15 <`nand`> yes
11:05:19 <M30W> What????
11:05:26 <`nand`> Int and Integer are completely separate types
11:05:28 <Nereid> Int is bounded, Integer can represent arbitrarily large integers.
11:05:30 <kennyd> Integer has arbitrary precision
11:05:42 <Nereid> > maxBound :: Int
11:05:43 <lambdabot>   9223372036854775807
11:05:45 <`nand`> kennyd: no, it has full precision :P
11:05:51 <mauke> > 2 ^ 123456 :: Integer
11:05:52 <lambdabot>  Terminated
11:05:57 <mauke> > 2 ^ 1234 :: Integer
11:05:58 <lambdabot>   295811224608098629060044695716103590786339687135372992239556207050657350796...
11:06:02 <`nand`> M30W: Int's size is machine-specific
11:06:10 <Nereid> > 2^1234 :: Int
11:06:12 <lambdabot>   0
11:06:16 <Nereid> ;)
11:06:19 <plat0> Can someone suggest which package to use for returning the result of an HTTP request as a String.  I want one that doesn't throw IO exceptions.  I don't see how to get Network.HTTP.Conduit to return failure in a Maybe, Either etc..
11:06:20 <c_wraith> Integer has an upper bound!  It just...  Won't fit in memory on any machine I know of. :)
11:07:42 <merk_> do monads exist so haskell can support IO?
11:07:49 <Modius> Dangit - there's a lens *and* lenses?
11:07:57 <mauke> merk_: no
11:07:59 <edwardk> Modius: yes. 'lenses' is old and busted
11:08:04 <edwardk> Modius: lens is the new hotness
11:08:24 <edwardk> Modius: its frustrating to me, too ;)
11:08:30 <M30W> Nice
11:08:43 <M30W> > 2^2^20
11:08:45 <lambdabot>   674114012549907340226906510470424543762018594853268828469449156767422707007...
11:08:45 <Modius> No uninstall on cabal either :P
11:08:50 <c_wraith> merk_: Monads existed long before haskell had an IO type. (though they weren't an abstraction in the standard library until haskell got the IO type)
11:08:51 <M30W> > 2^2^20 :: Integer
11:08:52 <lambdabot>   674114012549907340226906510470424543762018594853268828469449156767422707007...
11:08:52 <M30W> > 2^2^20 :: Int
11:08:53 <Nereid> cabal is not a package manager.
11:08:54 <lambdabot>   0
11:08:54 <mauke> LensEx
11:08:58 <Nereid> you can always ghc-pkg unregister it
11:08:59 <edwardk> Modius: ghc-pkg unregister lenses
11:09:06 <M30W> > maxBound :: Int
11:09:08 <lambdabot>   9223372036854775807
11:09:09 <edwardk> Modius: thats effectively 'cabal uninstall'
11:09:11 <M30W> > maxBound :: Integer
11:09:12 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
11:09:12 <lambdabot>    arising from...
11:09:20 <M30W> O.o
11:09:25 <Nereid> Integer isn't bounded.
11:09:28 <mauke> no maximum
11:09:31 <M30W> :t maxBound
11:09:32 <mauke> unlimited power
11:09:32 <M30W> Oh
11:09:32 <lambdabot> Bounded a => a
11:09:36 <deus_rex> > maxBound :: Char
11:09:38 <lambdabot>   '\1114111'
11:09:40 <M30W> Now I get it. :)
11:09:48 <c_wraith> @src Integer
11:09:48 <lambdabot> data Integer = S# Int#
11:09:48 <lambdabot>              | J# Int# ByteArray#
11:09:59 <Lethalman> \o/
11:09:59 <c_wraith> ...  Is that still the source these days?
11:10:10 <`nand`> that should be removed from @src if you ask me
11:10:11 <c_wraith> I thought there was a primop to get the size of a ByteArray# now
11:10:24 <c_wraith> Which is what that Int# is supposed to be, IIRC
11:10:51 <n-dolio> The Int# is the number of limbs or something.
11:11:15 <c_wraith> oh, some gmp optimization?
11:11:21 <n-dolio> Some kind of information that GMP needs.
11:11:37 <n-dolio> I think.
11:11:42 <OiO> -bash: cabal-macosx: command not found any idea why this happens already installed
11:11:48 <M30W> Oh, what exactly is gmp and why can't it be staticly linked in too?
11:12:00 <c_wraith> gmp is the GNU Multi-Precision math library
11:12:17 <M30W> And can't be linked in why?
11:12:19 <c_wraith> It can't be statically linked because it's GPL code
11:12:28 <c_wraith> and GHC is BSD
11:12:28 <M30W> Oh god
11:12:41 <M30W> Make BSD clone!!!
11:12:46 <mekeor> any nicer way for "foo x = case bar x of { … }" ?
11:12:56 <Clint> that's wrong
11:13:02 <Clint> it's LGPL
11:13:06 <Nereid> mekeor: why not multiple foo ... = ...
11:13:15 <Nereid> er
11:13:15 <Nereid> oh.
11:13:18 <Nereid> ViewPatterns.
11:13:19 <mekeor> Nereid: ;) :D :D
11:13:29 <Nereid> foo (bar -> ...) = ...
11:13:44 <mekeor> Nereid: are viewpatterns part of haskell2010 or (still) lang-ext?
11:13:55 <fmap> plat0: you may use `Control.Exception.try :: IO a -> IO (Either HttpException a)' with http-conduit I guess
11:13:59 <Nereid> I don't think they're in 2010
11:14:01 <`nand`> mekeor: foo = \case {...}
11:14:03 <n-dolio> Does GHC properly implement 'foo (bar -> C1) = ... ; foo (bar -> C2) = ... ; ...' as only doing one call to bar?
11:14:04 <`nand`> oh
11:14:04 <M30W> O.o
11:14:06 <`nand`> my bad
11:14:08 <`nand`> I missed the ‘bar’
11:14:13 <mekeor> :P
11:14:14 <Nereid> me too
11:14:19 <M30W> Why does the server still bind with a port that is higher than tcp/ip?
11:14:21 <Nereid> n-dolio: it seems so.
11:14:25 <M30W> can take *
11:14:26 <n-dolio> Ah, that's good.
11:14:35 <`nand`> foo = bar >>> \case {...}
11:14:38 <`nand`> ;)
11:14:46 <shachaf> n-dolio: I've read that it does.
11:15:07 <mekeor> `nand`: is "\case" haskell2010?
11:15:11 <Nereid> I don't know why I didn't answer with a definite "yes" when I know it does.
11:15:12 <Nereid> mekeor: no
11:15:14 <`nand`> no, it's LambdaCase
11:15:19 <mekeor> =(
11:15:21 <thoughtpolice> mekeor: no, it's LambdaCase, ghc 7.6+
11:15:29 <M30W> Did the port number just roll over?
11:15:35 <merk_> how do you call main? function? action?
11:15:36 <Nereid> probably.
11:15:44 <`nand`> merk_: ‘action’ should be alright
11:15:45 <Nereid> I'd call it an action.
11:15:47 * mekeor will go with the original version… keeping it pure haskell2010…
11:15:47 <`nand`> it's not a function
11:15:56 <Nereid> functions have -> in their type.
11:16:05 <Nereid> "IO action" is nice.
11:16:11 <n-dolio> Like 'Maybe (a -> b)'
11:16:25 <plat0> fmap: I'd rather use a library that avoids IO exceptions.  I don't like that style of programming.
11:16:31 <Nereid> n-dolio: no, the implication doesn't go that way.
11:16:40 <n-dolio> Oh. :)
11:16:56 <Nereid> :)
11:17:04 <merk_> and what is putStrLn, function or action?
11:17:12 <`nand`> function
11:17:13 <otters> action
11:17:14 <`nand`> :t putstrLn
11:17:15 <lambdabot>     Not in scope: `putstrLn'
11:17:15 <lambdabot>     Perhaps you meant one of these:
11:17:15 <lambdabot>       `putStrLn' (imported from Prelude),
11:17:16 <`nand`> oops
11:17:18 <`nand`> :t putStrLn
11:17:19 <lambdabot> String -> IO ()
11:17:23 <otters> oh
11:17:24 <M30W> Nereid: Can PortID be changed into an integer?
11:17:25 <`nand`> function from a String to an IO () action
11:17:27 <otters> function returning an action lel
11:17:58 <Nereid> M30W: PortID could be one of several things that may not be an integer.
11:18:28 <M30W> let x = PortNumber (fromInteger 6666777777)
11:18:35 <Nereid> PortNumber can be converted to an integer, as it's an instance of Integral.
11:18:37 <Nereid> :t fromIntegral
11:18:38 <lambdabot> (Integral a, Num b) => a -> b
11:18:41 <M30W> No error in code; so I want the value from that.
11:18:54 <Nereid> M30W: internally, it's a Word16
11:19:08 <Nereid> > 6666777777 :: Word16
11:19:09 <lambdabot>   62641
11:19:21 <M30W> Oh
11:19:51 <M30W> So I was right that it cycled through. :)
11:19:57 <M30W> Overflow much lol
11:20:14 <merk_> > maxBound :: Word16
11:20:16 <lambdabot>   65535
11:20:29 <M30W> > 2^16
11:20:30 <lambdabot>   65536
11:20:40 <M30W> > 2^16-1
11:20:41 <lambdabot>   65535
11:20:44 <M30W> :)
11:21:06 <merk_> yes :)
11:21:07 <Nereid> > sum [minBound .. maxBound :: Word16]
11:21:09 <lambdabot>   32768
11:21:10 <Nereid> :)
11:21:26 <M30W> > minBound :: Word16
11:21:27 <lambdabot>   0
11:21:34 <M30W> or sum
11:21:37 <M30W> lol
11:21:41 <M30W> Why say min??
11:21:54 <Nereid> because I wanted all of the Word16s.
11:21:56 <M30W> > sum [..maxBound::Word16]
11:21:58 <lambdabot>   <hint>:1:6: parse error on input `..'
11:22:07 <M30W> > sum [0 .. maxBound :: Word16]
11:22:09 <lambdabot>   32768
11:22:12 <Nereid> > sum [0..-1 :: Word16]
11:22:13 <lambdabot>   Not in scope: `..-'
11:22:17 <Nereid> > sum [0 .. -1 :: Word16]
11:22:19 <lambdabot>   32768
11:22:21 <Nereid> :p
11:22:25 <shachaf> c_wraith: The Int# isn't a size.
11:22:28 <M30W> Nice
11:22:35 <M30W> > sum [0.. :: Word16]
11:22:36 <lambdabot>   <hint>:1:10: parse error on input `::'
11:22:48 <M30W> > sum [0..-1:: Word16]
11:22:49 <lambdabot>   Not in scope: `..-'
11:22:51 <Nereid> > sum [0 :: Word16 ..]
11:22:53 <lambdabot>   32768
11:22:55 <M30W> No compact haha
11:22:56 <Nereid> sure.
11:22:56 <merk_> > [minBound .. maxBound] :: [Word16]
11:22:58 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:23:01 <Nereid> anyway.
11:23:02 <`nand`> > sum [0..] :: Word16
11:23:02 <Nereid> the point is that
11:23:03 <lambdabot>   32768
11:23:10 <Nereid> all the Word16s cancel in pairs except for 0 and 32768.
11:23:19 <Nereid> thanks `nand`.
11:23:25 <M30W> `nand`: was gonna try that but had a doubt for some reason lol
11:23:34 <M30W> > sum [0..] :: Word32
11:23:42 <M30W> No?
11:23:44 <lambdabot>   mueval: ExitFailure 1
11:23:44 <lambdabot>  mueval: Prelude.undefined
11:23:49 <`nand`> M30W: that's going to take a while :)
11:23:50 <shachaf> c_wraith: ...Or maybe it is, but in that case it's strange.
11:23:50 <M30W> Hehe
11:24:03 <danr> > succ (maxBound :: Word32)
11:24:07 <lambdabot>   mueval-core: Time limit exceeded
11:24:11 <M30W> time ghc -e 'sum [0..] :: Word32'
11:24:13 <M30W> Race ^_^
11:24:18 <M30W> ghc -e 'sum [0..] :: Word32'  0.58s user 0.09s system 95% cpu 0.692 total
11:24:26 <M30W> LOL!
11:24:28 <M30W>     Not in scope: type constructor or class `Word32'
11:24:33 <M30W> That might help...
11:24:36 <M30W> Which lib?
11:24:53 <`nand`> Data.Word or something
11:24:54 <M30W> @hoogle Word32
11:24:54 <lambdabot> Data.Word data Word32
11:26:01 <Nereid> it would help if you used the version of sum that didn't overflow the stack.
11:26:03 <Nereid> foldl' (+) 0
11:26:27 <M30W> time ghci <<< ':m + Data.Word ' <<< 'sum [0..] :: Word32' <<< ':q'
11:26:35 <M30W> Cheat method cause I don't wanna use man on ghc :P
11:27:00 <M30W> ghci <<< ':m + Data.Word ' <<< 'sum [0..] :: Word32' <<< ':q'  10.69s user 3.43s system 47% cpu 29.528 total
11:27:03 <M30W> :)
11:27:28 <Nereid> @let sum' = foldl' (+) 0
11:27:31 <lambdabot>  Defined.
11:27:40 <merk_> why is sum [0..] :: Word16 smaller than maxBound :: Word16 ?
11:27:57 <Nereid> because it's so large it overflows.
11:28:11 <M30W> merk_: It cycles from 0 -> -1 :: Word16
11:28:19 <merk_> ah
11:28:25 <Nereid> you're adding all the integers mod 2^16. all of them but 0 and 32768 cancel with their negative.
11:28:42 <Nereid> @let everything = [minBound..maxBound]
11:28:44 <lambdabot>  Defined.
11:28:46 <Modius> Noobin' with lenses - assume without them I'd do instanceVar { fieldName = newData } <-- What's the Lens equivalent?
11:28:47 <Nereid> > sum everything :: Int16
11:28:51 <lambdabot>   -3
11:28:53 <M30W> If you could only count to 5 and you try to count to 10, you're back at 5.
11:28:56 <Nereid> uh
11:28:58 <`nand`> Modius: instanceVar & fieldName .~ newData
11:29:07 <Nereid> > [minBound, maxBound] :: [Int16]
11:29:08 <M30W> if you try to count to 12, you're on 2
11:29:08 <lambdabot>   [-32768,32767]
11:29:13 <Nereid> uhhh
11:29:17 <Nereid> > sum everything :: Word16
11:29:19 <lambdabot>   32768
11:29:30 <M30W> lolwat?
11:29:34 <mauke> > everything ++ ""
11:29:34 <Nereid> where the hell does -3 come from.
11:29:35 <M30W> > everything
11:29:36 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
11:29:36 <lambdabot>   [()]
11:29:47 <M30W> :t everything
11:29:49 <lambdabot> (Bounded t, Enum t) => [t]
11:30:01 * hackagebot git-annex 3.20130102 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20130102 (JoeyHess)
11:30:05 <M30W> > everything:[]
11:30:05 <Nereid> > everything :: Int16
11:30:07 <lambdabot>   can't find file: L.hs
11:30:07 <lambdabot>   [[()]]
11:30:08 <Nereid> > everything :: [Int16]
11:30:10 <lambdabot>   [-32768,-32767,-32766,-32765,-32764,-32763,-32762,-32761,-32760,-32759,-327...
11:30:18 <Nereid> > drop 65530 everything :: [Int16]
11:30:21 <lambdabot>   [32762,32763,32764,32765,32766,32767]
11:30:26 <Nereid> ok, then what the fuck.
11:30:27 <Nereid> :p
11:30:32 <edwardk> Modius: instanceVar & fieldName .~ newData
11:30:32 <Nereid> > sum' everything :: Int16
11:30:34 <lambdabot>   -32768
11:30:34 <shachaf> > sum [minBound..maxBound]::Int16
11:30:35 <lambdabot>   -32768
11:30:43 <M30W> > maxBound :: Word2
11:30:45 <lambdabot>   Not in scope: type constructor or class `Word2'
11:30:45 <lambdabot>  Perhaps you meant one of t...
11:30:47 <Nereid> [12:28:29] <lambdabot>   -3
11:30:48 <M30W> :(
11:30:51 <M30W> > maxBound :: Word4
11:30:52 <lambdabot>   Not in scope: type constructor or class `Word4'
11:30:52 <lambdabot>  Perhaps you meant one of t...
11:30:53 <Nereid> lambdabot forgot to finish its line I guess.
11:30:53 <shachaf> > sum everything::Int16
11:30:55 <M30W> > maxBound :: Word8
11:30:55 <lambdabot>   -32768
11:30:56 <lambdabot>   255
11:31:03 <M30W> so it has 8!
11:31:07 <shachaf> This channel has way too much bot spam now.
11:31:13 <Nereid> it hasn't before?
11:31:20 <M30W> shachaf: Just now?
11:31:21 <Nereid> hadn't
11:31:25 <M30W> Nereid: ^^
11:31:37 <merk_> where is everything defined
11:31:40 <Modius> In lens is there a substitute for constructing a new record without doing ConstructorName { _fieldA = ..., _fieldB ... } ?
11:32:08 <`nand`> Modius: one way would be to use ConstructorName{} & fieldA .~ ... & fieldB .~ ...
11:32:08 <merk_> hoogle points to different everything
11:32:10 <`nand`> but that's unsafe
11:32:17 <edwardk> Modius: if you have a 'default' version of the full record you can use def & fieldA .~ x & fieldB .~ y & …
11:32:22 <`nand`> but you can use Default, yeah
11:32:35 <edwardk> or you can use `nand`'s partial hack
11:32:36 <M30W> merk_: 'everything' ?
11:32:41 <M30W> @src everything
11:32:41 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:32:43 <Modius> Thanks (interesting)
11:32:44 <`nand`> merk_: a few lines ago
11:32:58 <Modius> Would you ultimately recommend though, barring some default, to just use the { _fieldA, _fielbB } form?
11:32:58 <`nand`> <Nereid> @let everything = [minBound..maxBound]
11:33:18 <M30W> Heh
11:33:20 <`nand`> Modius: if no reasonable default can be constructed and you don't want the partial record warnings, then yeah, I guess so
11:33:23 <edwardk> Modius: the benefit of using the _fieldA, _fieldB form is the compiler will check that you've fully instantiated it
11:33:25 <M30W> @unlet everything
11:33:25 <lambdabot>   TemplateHaskell is not enabled
11:33:37 <M30W> how to remove lets ?
11:33:39 <M30W> O.o
11:33:41 <`nand`> @undefine
11:33:47 <`nand`> ..I thought
11:33:48 <M30W> @undefine everything
11:33:55 <M30W> O.o
11:34:02 <M30W> @unlet everything
11:34:02 <lambdabot>   TemplateHaskell is not enabled
11:34:05 <M30W> :P
11:34:09 <shachaf> edwardk: Could we get that check ourselves somehow with overExposed?
11:34:17 <M30W> @delet everything
11:34:17 <lambdabot>   TemplateHaskell is not enabled
11:34:19 <Modius> Je*** I feel like a tard trying to get my head around this (admittedly cool) stuff
11:34:24 <M30W> :(
11:34:34 <shachaf> edwardk: Hmm, no, some fields are monomorphic, so whatever I was thinking of wouldn't work.
11:34:35 <M30W> @let everything = Nothing
11:34:37 <lambdabot>  Defined.
11:34:39 <M30W> :)
11:34:43 <Nereid> > everything
11:34:45 <lambdabot>   Nothing
11:34:47 <merk_> is lambdabots' let global or per channel/query
11:34:49 <Nereid> :(
11:34:50 <edwardk> shachaf: possibly, maybe by starting with an empty record with all the fields set to some type the target doesn't unify with
11:35:00 <M30W> merk_: test it?
11:35:01 <Nereid> global
11:35:03 <`nand`> merk_: global
11:35:03 <shachaf> edwardk: Right, that's what I was thinking, but some fields are just Int or something.
11:35:07 <shachaf> You can't do much about htat.
11:35:08 <edwardk> er an empty exposed records
11:35:18 <edwardk> yeah
11:35:24 <M30W> Global ^_^
11:35:31 <Modius> Now that you guys mention it, I *do* have a default - it's building this off the last.
11:36:23 * M30W 's bot is nothing this complex lol. So simple - shell script; merging mpd with irc. :)
11:36:54 <M30W> With ops; locking and allowing me to run anything irc qise for client's /quote worthy communication lol. (raw)
11:36:57 <M30W> :)
11:37:52 <M30W> Modius: You newbie too?
11:38:03 <Modius> What's the best doc page for lens?  I don't see .~ on the hackage.haskell page
11:38:05 * M30W learning. :D
11:38:14 <`nand`> Modius: lens.github.com
11:38:18 <`nand`> go from there
11:38:18 <M30W> Ask edwardk I hear he loves to talk about lenses
11:38:25 <`nand`> Modius: I use http://ekmett.github.com/lens/doc-index-All.html as a reference
11:38:26 <edwardk> Modius: its down in there, its under Control.Lens.Setter
11:38:33 <edwardk> :t (.~)
11:38:34 <lambdabot> Setting s t a b -> b -> s -> t
11:38:43 <edwardk> `nand`: that one is somewhat of a bad reference because it shows lens HEAD
11:38:48 <edwardk> @hackage lens
11:38:48 <lambdabot> http://hackage.haskell.org/package/lens
11:38:52 <`nand`> but I use lens HEAD
11:38:57 <shachaf> Modius: Hayoo will also find it.
11:38:59 <shachaf> @where hayoo
11:38:59 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
11:39:05 <Nereid> lens 3.8 when??? :)
11:39:14 <edwardk> Modius: http://hackage.haskell.org/packages/archive/lens/3.7.1.2/doc/html/Control-Lens-Setter.html#v:.-126-
11:40:26 <edwardk> Modius: there is a nice video that provides a lens crash course, https://www.youtube.com/watch?v=cefnmjtAolY&hd=1  -- watch it in HD, slides are linked at the top of the description, and a quick 'getting started' tutorial on lens.github.com
11:48:43 <M30W> edwardk: Your video on youtube crashed firefox :P
11:48:46 <M30W> lol
11:48:49 <M30W> html5 </3
11:48:54 <edwardk> M30W: doh
11:51:53 <M30W> !pause
11:51:55 <M30W> wrong channel lol.
11:56:25 <shapr> hrm, for $150 I can buy a Freescale i.MX53 board with 1GB of RAM so I can build Raspberry Pi deb-builder for all the Haskell packages.
11:56:29 * shapr solicits donations
11:59:32 * BMeph arrests shapr for Internet Trafficing and solicitation! >;)
11:59:53 <shapr> ha
12:00:02 * hackagebot hascal 1.4.2 - A minimalistic but extensible and precise calculator  http://hackage.haskell.org/package/hascal-1.4.2 (MekeorMelire)
12:00:08 <c_wraith> I hear you're selling internets. Can I get one cheap?
12:00:31 <shapr> just put five dollars in an envelope... and mail it to the internet.
12:04:15 <M30W> Video froze D:
12:04:23 <M30W> Firefox *
12:04:32 <Modius> subScope = (scope &) . (sourcePosition %~) . (:) . FormSubElement   <-- and things start simplifying down to things like this.  Playing with lenses is good haskell training
12:04:56 <edwardk> Modius you can simplify that further
12:05:02 * hackagebot fluidsynth 0.1.0.0 - Haskell bindings to FluidSynth  http://hackage.haskell.org/package/fluidsynth-0.1.0.0 (CorbinSimpson)
12:05:04 <M30W> > over _left (+5) (Right "hello")
12:05:05 <edwardk> %~  is infixable as 'over'
12:05:06 <lambdabot>   Right "hello"
12:05:20 <M30W> > over _left (+5) (Left 7)
12:05:22 <lambdabot>   Left 12
12:05:40 <Lethalman> :t liftA2
12:05:41 <edwardk> subScope = (scope &) . over sourcePosition . (:) . FormSubElement   is a start, but we can go farther
12:05:42 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:05:46 <Modius> Silly me not reading the doc right (it wasn't used like this until I simplified)
12:05:48 <edwardk> :t (?foo &)
12:05:50 <lambdabot> (?foo::a) => (a -> b) -> b
12:05:50 <Lethalman> :t <$> . <*>
12:05:51 <lambdabot> parse error on input `<$>'
12:06:01 <Lethalman> :t (<$>) . (<*>)
12:06:03 <lambdabot> (Functor f, Applicative f1) => f1 (a -> b) -> f (f1 a) -> f (f1 b)
12:06:19 <edwardk> what is the type of subScope?
12:06:21 * simpson is a contributing member of society now!
12:06:22 <Modius> subScope is Int-><whatever>
12:06:28 <Lethalman> @src liftA2
12:06:28 <lambdabot> liftA2 f a b = f <$> a <*> b
12:06:52 <Modius> I already made it point-free on the int (main exercise I was doing, that was the haskell-learning thing I was talking abotu)
12:07:00 <edwardk> subScope i = over sourcePosition (FormSubElement i:)
12:07:14 <edwardk> something like that?
12:07:23 <Modius> Yeah; but isn't it preferable to get rid of the i?
12:07:28 <edwardk> why?
12:07:37 <M30W> > (1,2,3) & _1 .~ 6 & _2 .~ "test" & _3 .~ 9
12:07:39 <lambdabot>   (6,"test",9)
12:07:41 <edwardk> point free isn't an ends its an occasionally useful means
12:07:43 * BMeph quibbles: "= scope & over...
12:07:46 <BMeph> "
12:07:46 <edwardk> here it adds no clarity
12:07:47 * M30W like.
12:08:18 <Modius> This isn't toplevel, and I thought there were cases where non-pointfree led to recreating the thunk or something every time it was called
12:08:25 <edwardk> i can look at this definition of 'subScope' and immediately understang it
12:08:53 <edwardk> you get no extra thunk involved here because you were already going to build a composition. the eta-expansion is already present in your form
12:09:08 <edwardk> in fact you get a whole bunch of extra scopes for going into all those (.)s and flipping crap around
12:09:23 <edwardk> so if efficiency is your goal your attempted solution led you in the wrong direction
12:10:17 <edwardk> lens internally does lots of scary things to remain fast so you can write relatively sane code using it
12:10:52 <Modius> I think the code example you gave me is incorrect
12:10:54 <edwardk> BMeph: i was figuring the 'scope was a parameter, but it can be subScope i = over sourcePosition (FormSubElement i:) scope
12:10:56 <Modius> It didn't use the "scope" variable
12:11:04 <Modius> That's it
12:11:09 <edwardk> Modius: i was taking it as a parameter there
12:11:56 <Modius> It was educational converting it from how I originally had it to point-free, and educational too that that is probably not useful here for cosmetic *or* performance reasons.
12:12:12 <edwardk> *nods*
12:12:38 <edwardk> i write things in point free style pretty much only when it leads to increased clarity
12:13:00 <edwardk> that usually means using point free for only one arg, and not when it gets tricky under partially applied operators, etc.
12:13:10 <M30W> What would be the cleanest way to do the following? x hdl = do { y=... case y of; "a" -> dosomething; "b" -> dosomething; ....; x hdl }
12:13:15 <M30W> The xhdl part;
12:13:23 <M30W> err; I want a quit/exit for that loop
12:13:32 <M30W> If the case is "quit"
12:14:00 <simpson> loop = do { whether <- some_action; when whether $ loop } -- in general.
12:14:05 <mauke> ContT?
12:14:07 <Lethalman> :t . ($)
12:14:08 <lambdabot> parse error on input `.'
12:14:17 <Lethalman> :t <*> . ($)
12:14:19 <lambdabot> parse error on input `<*>'
12:14:20 <shachaf> mauke: Why ContT when you can use EitherT?
12:14:21 <Lethalman> :t (<*>) . ($)
12:14:22 <lambdabot> (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
12:14:30 <Lethalman> :t (<$>) . (<*>) . ($)
12:14:31 <lambdabot> Functor f => (a1 -> a -> b) -> f (a1 -> a) -> f (a1 -> b)
12:14:42 <mauke> shachaf: ContT is shorter
12:14:44 <Lethalman> mh that's not liftA2 right? :P
12:15:10 <mauke> @src liftA2
12:15:10 <lambdabot> liftA2 f a b = f <$> a <*> b
12:15:13 <mauke> @. pl src liftA2
12:15:13 <lambdabot> (line 1, column 1):
12:15:13 <lambdabot> unexpected end of input
12:15:14 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:16:03 <shachaf> Unfortunately @src cheats.
12:16:11 <shachaf> @@ @show @src liftA2
12:16:11 <lambdabot>  ""
12:16:43 <mauke> @pl liftA2 f a b = f <$> a <*> b
12:16:43 <lambdabot> liftA2 = (. (<*>)) . (.) . (<$>)
12:17:08 <Lethalman> I wouldn't ever come about that
12:18:32 <mauke> it's a mechanical process
12:18:34 <Modius> I will one day tackle the "iteratee" mountain
12:18:45 <mauke> IIRC wikipedia has an article about lambda elimination
12:18:54 <M30W> simpson: where loop = someaction >>= when $ loop
12:18:55 <M30W> ?
12:18:57 <shachaf> @google combinatory logic
12:18:57 <mauke> @hackage pipes
12:18:58 <shapr> Hrm, cabal configure finished, cabal build finished, but cabal install now wants to do a bunch of other stuff?
12:18:58 <shachaf> I think?
12:18:59 <lambdabot> http://en.wikipedia.org/wiki/Combinatory_logic
12:18:59 <lambdabot> Title: Combinatory logic - Wikipedia, the free encyclopedia
12:18:59 <lambdabot> http://hackage.haskell.org/package/pipes
12:20:08 <simpson> M30W: For that particular snippet, sure. I was just trying to point out "when" as a useful tool for doing this. See also "unless".
12:20:09 <thoughtpolice> edwardk: ping
12:20:13 <edwardk> pongish
12:20:13 * shapr tries cabal register
12:20:38 <shapr> Ok, that didn't work.
12:20:57 <edwardk> thoughtpolice: whats up?
12:20:59 <thoughtpolice> edwardk: you were working on an indexed monad library or something of the sorts recently, right? indexed on hackage seems quite a bit different from your github copy (the one on hackage was derived from yours though)
12:21:05 <Lethalman> why is this not liftA2 yet:
12:21:23 <Lethalman> foo f a b = (<*>) ((<$>) f a) b
12:21:31 <thoughtpolice> i'm wondering because while i'm working on this little delimited continuations library, i need indexed monads for answer type polymorphism. it's pretty easy to do simple examples with a single module that defines IxMonad
12:21:46 <shapr> Is there some way I can skip around 'cabal install' once configure and build have finished successfully?
12:21:49 <Lethalman> isn't that the right association of f <$> a <*> b ?
12:21:58 <edwardk> thoughtpolice: yes the one on hackage is an older one based on code of mine. the one on github is going to subsume it, but won't go out any time soon due to the need for stuff that probably won't be in until 7.8
12:21:58 <M30W> simpson: parseIn hdl = do { line <- hGetLine hdl; let (x:xs) = words line; case map toLower x of; "echo" -> echoCommand hdl xs; .... "quit" -> escapeloop; parseIn hdl }
12:22:01 <mauke> :t \f a b -> (<*>) ((<$>) f a) b
12:22:02 <lambdabot> Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
12:22:04 <thoughtpolice> but i was wondering if you had any opinions on indexed, and whether it'd be worth using
12:22:09 <mauke> :t liftA2
12:22:10 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
12:22:17 <Lethalman> is that ok? never seen a1 :P
12:22:26 <mauke> Lethalman: uh, it's just a variable
12:22:31 <Lethalman> mauke, alright
12:22:36 <simpson> M30W: You don't break out of loops; instead, you choose to continue looping.
12:22:39 <thoughtpolice> edwardk: ah, cool. really i wanted to be able to lift IO operations into my indexed Delim monad easily, but i already define my own IxMonad and a few combinators pretty faithfully
12:22:48 <M30W> simpson: Okay; how to condition that?
12:22:51 <thoughtpolice> and i just really don't want to go down a rabbit hole of defining Ix* monad transformers
12:22:54 <thoughtpolice> etc
12:22:55 <Lethalman> mauke, then a simpler point free version is:
12:23:07 <Lethalman> :t (<$>) . (<*>) . ($)
12:23:08 <lambdabot> Functor f => (a1 -> a -> b) -> f (a1 -> a) -> f (a1 -> b)
12:23:09 <edwardk> thoughtpolice: yeah ix monad transformers is why the hold up
12:23:14 <edwardk> thoughtpolice: right now product kinds are gimped
12:23:19 <Lethalman> mh... no
12:23:21 <Lethalman> :D
12:23:27 <thoughtpolice> edwardk: see here -> https://github.com/thoughtpolice/hs-asai/blob/master/examples/Tree.hs
12:23:31 <edwardk> thoughtpolice: you can't use them to make indexed monad transformers because they have an extra distinguishable 'Any' element
12:23:54 <edwardk> so for now you can only compose a base monad with an indexed one, you can't compose indices
12:24:03 <shapr> Aha! ghc --make Setup && ./Setup install
12:24:05 <thoughtpolice> it would be nice if i could actually have semi-unfied 'do' notation with an indexed transformer to provide lift operators
12:24:16 <thoughtpolice> then i can do 'lift $ putStrLn "trace delimted thingy here"' inside walk_tree'
12:24:17 <simon> @pl \x y -> nub $ x ++ y
12:24:17 <lambdabot> (nub .) . (++)
12:24:23 <thoughtpolice> which is more in line with oleg's original definition
12:24:23 <edwardk> 'indexed' hacks around this in places using the 'herp' and 'derp' combinators in the meantime, but its really not satisfying
12:24:26 <shapr> Now that HaskellNet is installed on my Raspberry Pi, time to try imapget with ssl!
12:24:31 <simpson> :t when -- M30W
12:24:32 <lambdabot> Monad m => Bool -> m () -> m ()
12:25:00 <edwardk> thoughtpolice: the version in indexed is based on conor's one parameter version. the indexed comonads used in lens head are based on the simpler 2-parameter version
12:25:21 <thoughtpolice> edwardk: hm, i think i understand. i'll look at your library. is this the thing where Any needs to change to become a type family?
12:25:25 <M30W> simpson: I'm quite new with haskell; mind suggesting what I could have?
12:25:26 <edwardk> i'm not sure which i like better. conor's version scales out to more scenarios, and is ideal in that its 'write one definition and you can use it for any kind'
12:25:39 <thoughtpolice> edwardk: is that gabriel's library?
12:25:39 <edwardk> thoughtpolice: yes, it is
12:25:51 <edwardk> thoughtpolice: he has one, but it doesn't go as far as i need it to
12:25:54 <byorgey> Any Windows users around?  Where do you expect programs to look for user-created configuration files?
12:26:03 <edwardk> his is also based on conor's approach
12:26:16 <`nand`> byorgey: %APPDATA% ?
12:26:17 <byorgey> e.g. where does cabal look for its config file on Windows?
12:26:38 <thoughtpolice> edwardk: so what's the deal with Any, it's a data type right now? the only thing i know about it vaguely is that "it's safe to unsafeCoerce from/to" i think?
12:26:39 <`nand`> cabal uses the ‘home’ folder, I think
12:26:46 <`nand`> ie. C:\Users\Foo\
12:26:58 <thoughtpolice> edwardk: i only know that because i remember SPJ mentioned making Any into a type family at one point but i got lost in details
12:27:10 <edwardk> thoughtpolice: any is an extra inhabitant of every kind. it exists as such because system Fc doesn't have polymorphism, so everything gets instantiated down to it in the end
12:27:47 <M30W> simpson: let x = True at the start; and on the quit case, set it to false ?
12:28:06 <simon> @pl foldr (\(_, x) y -> f x y)
12:28:06 <lambdabot> foldr (f . snd)
12:28:26 <byorgey> `nand`: is there a general preference between the two?
12:28:26 <edwardk> thoughtpolice: if it was a type family of the kind then you wouldn't be able to make other type families 'match' on it, and it'd cease to be an extra inhabitant, this helps. it isn't sufficient to my purposes because i also need the fact that t :: (k1,k2) to tell me t ~ '(x,y) for some x :: k1, y :: k2
12:28:30 <edwardk> thoughtpolice: thats the other side of my issue
12:28:53 <edwardk> thoughtpolice: 'herp' and 'derp' in indexed right now witness that equality via unsafeCoerce basically
12:29:15 <edwardk> thoughtpolice: but its mostly as a hack so i could explore the space more fully
12:29:40 <`nand`> byorgey: I think %APPDATA% is the idiomatic place to put it (you can distinguish between local/roaming/whatever, but I'd have to read up on their differences); the ‘home’ folder is just a hack some linux-friendly programs like to use for familiarity
12:29:45 <OIO> why doesnt work?
12:29:50 <`nand`> byorgey: actually, I think cabal uses %APPDATA%
12:30:00 <byorgey> `nand`: ah, ok
12:30:08 <thoughtpolice> edwardk: i see. so there are no really closed kinds a la DataKinds, since Any inhabits them all. because of that it's always possible to define family instances which match on Any, 'breaking' what closed families you -could- have?
12:30:11 <hpaste> OiO pasted “main.hs” at http://hpaste.org/80121
12:30:21 <edwardk> thoughtpolice: exactly
12:30:23 <`nand`> yeah, on my school machine I have a script to copy over the entire app data folder to the network partition to transfer it between machines
12:30:27 <`nand`> which includes cabal
12:30:35 <edwardk> (x,y) isn't really the product of x and y, its x * y + 1
12:30:37 <byorgey> `nand`: ah, and I see that System.Directory has a nice platform-independent 'getAppUserDataDirectory' function, nice
12:30:43 <edwardk> bcause of any
12:30:43 <byorgey> thanks!
12:30:55 <Nereid> edwardk: depends on what you mean by * and +
12:31:00 <Nereid> :p
12:31:07 <edwardk> Nereid: *shrug*
12:31:10 <thoughtpolice> edwardk: so looking at GHC's log there's something interesting here at least: https://github.com/ghc/ghc/commit/58470fb7b4a25c49b567e08740dc8df01a6c3710
12:31:41 <OIO> any idea why this doesnt work newbie in haskell
12:31:46 <thoughtpolice> edwardk: but the next commit immediately reverts the change of Any to a type family, because it breaks something in TypeLits right now
12:31:49 <thoughtpolice> :(
12:31:51 <OIO> http://hpaste.org/80121
12:32:09 <thoughtpolice> looking at this patch it would actually probably be really easy to add 'closed family' declarations to GHC
12:32:10 <edwardk> thoughtpolice: i'm pretty hopeful that it'll all work out. richard is pretty scarily smart and SPJ is at least aware of the issue and unlikely to let something this big fall on the floor.
12:32:16 <thoughtpolice> but i guess there's no point since we still have Any
12:32:28 <thoughtpolice> (as it is, anyway)
12:33:08 <`nand`> OIO: you probably want ‘not (elem x [0..9])’
12:33:28 <`nand`> or: not $ elem x [0..9]
12:33:32 <edwardk> thoughtpolice: the type lits issue was a known issue, and they need to change around parts of that code to accomodate
12:33:38 <OIO> and this     putStrLn  [x| x<-userLine,  notElem x [0..9] ]
12:33:57 <`nand`> OIO: you can also use:  filter (notElem x [0..9]) userLine
12:34:06 <`nand`> err
12:34:08 <`nand`> scratch that
12:34:20 <`nand`> (`notElem` [0..9])
12:34:31 <merk_> cabal does use %APPDATA%
12:34:45 <thoughtpolice> edwardk:
12:34:46 <thoughtpolice> -- | Derpendency projection. (Work around)
12:34:50 <thoughtpolice> :P
12:34:57 <edwardk> thoughtpolice: i was annoyed that day
12:35:02 * hackagebot hascal 2.0.0 - A minimalistic but extensible and precise calculator  http://hackage.haskell.org/package/hascal-2.0.0 (MekeorMelire)
12:35:04 * hackagebot splot 0.3.8 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.3.8 (EugeneKirpichov)
12:35:06 * hackagebot scrypt 0.3.6 - Stronger password hashing via sequential memory-hard functions.  http://hackage.haskell.org/package/scrypt-0.3.6 (FalkoPeters)
12:36:58 <M30W> simon: Help?
12:36:58 <OIO> getting this No instance for (Num Char)       arising from the literal `0'     Possible fix: add an instance declaration for (Num Char)     In the expression: 0     In the second argument of `notElem', namely `[0 .. 9]'     In the expression: notElem x [0 .. 9]
12:37:08 * M30W still stuck lol
12:37:43 <Nereid> OIO: yes, x is a Char but [0..9] is a list of numbers.
12:37:59 <Nereid> do you want ['0'..'9'] maybe?
12:38:10 <parcs> see also Data.Char.digitToInt
12:38:29 <thoughtpolice> edwardk: well, i think i'll roll with just my tiny IxMonad for now. you can't lift IO in Delim yet, but you can at least always return back the shifted continuation to an outer 'shell' that does what you want i think
12:38:51 <thoughtpolice> but if this works out and i can use indexed for Delim, that would be awesome :)
12:39:07 <OIO> Nereid this seems to work     putStrLn  [x| x<-userLine, notElem x ['0','1','2','3','4','5','6','7','8','9']]
12:39:13 <OIO> but doesnt look good
12:39:14 <Nereid> > ['0'..'9']
12:39:16 <lambdabot>   "0123456789"
12:39:58 <OIO> ok
12:40:28 <aniero> > filter (`notElem` ['0'..'9']) "foo123bar"
12:40:30 <lambdabot>   "foobar"
12:40:41 <Nereid> > filter (not . isDigit) "foo123bar"
12:40:42 <lambdabot>   "foobar"
12:41:15 <mekeor> edwardk has 1282 uploads to hackage. (only michael snoyman has more.) the person right behind edwardk in the ranking is henning thielemann with 457 uploads to hackage…
12:41:43 <aristid> mekeor: how many do i have?
12:41:46 <`nand`> mekeor: whence did you take this number?
12:42:21 <thoughtpolice> edwardk: so indexed is based vaguely on conor's design? which paper is that, and is it readable :P
12:42:47 <mekeor> `nand`: try the snippet at the bottom of http://uxl.dyndns.org/mekeor/pages/moved.html#hackage-highscore
12:43:04 <mekeor> aristid: what's your username?
12:43:11 <M30W> @src (.~)
12:43:11 <lambdabot> Source not found. I am sorry.
12:43:16 <M30W> :(
12:43:18 <thoughtpolice> edwardk: right now i'm just using the 'classic' indexed monad that has 3 parameters (ret :: a -> m s s a), like what you'd use for session types i believe (in this case the indexed variables represent in/out answer types)
12:43:24 <`nand`> mekeor: ah
12:43:51 <mekeor> aristid: AristidBreitkreuz? you have 80… :)
12:45:04 <aristid> mekeor: hmm... gamify the hackage uploads :D
12:45:22 <mekeor> :D heh
12:45:55 <byorgey> "Only four more uploads until Level 63!"
12:46:07 <mekeor> heheheheh :D
12:48:43 <aristid> byorgey: you're rank 25 :>
12:49:00 <byorgey> \o/
12:49:04 <aristid> liftM (zipWith (\a (x,y) -> (a,x,y)) [1..] . reverse . sort . map (\l -> (length l,head l)) . group . sort . map ((!!6) . words) . lines) (simpleHTTP (getRequest "http://hackage.haskell.org/packages/archive/log") >>= getResponseBody)
12:49:11 <deus_rex> anyone care to golf euler problem 16? What is the sum of the digits of the number 2^1000?
12:49:12 <byorgey> must... upload... more... packages...
12:49:20 <deus_rex> I managed "sum$digitToInt<$>show(2^1000)"
12:49:52 <shachaf> > 1366 -- do I win?
12:49:53 <lambdabot>  Terminated
12:49:59 <shachaf> > 1366
12:50:00 <lambdabot>   1366
12:50:01 <aristid> byorgey: must... beat... greg weber (in your case)
12:50:02 <srhb> Is the fact that I can't do deriving PersistEntity on a data type a limitation of the deriving mechanisms or a philosophical choice from the persistent authors?
12:50:03 <Nereid> you lose :D
12:50:15 <hpaste> me pasted “why damn parse error on where” at http://hpaste.org/80122
12:50:21 <mekeor> aristid: :D
12:50:32 <Nereid> whoever just pasted that, please also paste the error
12:50:35 * byorgey will probably make another upload tomorrow...
12:50:46 <aristid> and i must beat conrad parker
12:50:52 <hostess_fruit_pi> 99.hs:304:8: parse error (possibly incorrect indentation)
12:51:01 <hostess_fruit_pi> it's on the line with the "where"
12:51:13 <hostess_fruit_pi> If I do the where clause as a run-on, it takes it no problem
12:51:24 <byorgey> aristid: and Eric Kow
12:52:42 <Nereid> ah, layout.
12:52:49 <Nereid> hostess_fruit_pi: the let must be indented more than primeCalc
12:53:02 <Cale> hostess_fruit_pi: I haven't looked closely, but I'd want the let to start at least as deep as primeCalc
12:53:12 <hostess_fruit_pi> Wow. Really? That's kind of counter-intuitive.
12:53:12 <Cale> (well, should be more, yes)
12:53:18 <hostess_fruit_pi> (haskell newb)
12:53:33 <Cale> The let is part of the definition of primeCalc, so it should start on a deeper column.
12:54:17 <hostess_fruit_pi> ah. okay. Not so counter-intuitive. I get it now. Thing was driving me nuts. Thanks a lot.
12:54:24 <Cale> The way it actually works is that there are 4 keywords which introduce layout: where, let, of, and do
12:54:40 <Cale> and the first non-whitespace character after one of those sets the indentation level for the block
12:55:02 <Cale> So the p in primeCalc is setting the indentation level for that 'where' to the column that it's in.
12:55:08 <hostess_fruit_pi> Wow. Very nice to know.... Truthfully, I've just been winging it, imitating the kind of indenting I see here and there, and it usually works
12:55:29 <Nereid> http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#x7-210002.7
12:55:58 <Nereid> ^layout rules
12:56:02 <srhb> hostess_fruit_pi: If you're ever in doubt again, learn the layout rules. They're really simple: http://en.wikibooks.org/wiki/Haskell/Indentation
12:56:33 <hostess_fruit_pi> Very cool. Thank you, I'll copy/bookmark the information on my way out.
12:57:33 * M30W still can't get his loop to end only loop through when not.... eh I try something more..
12:58:45 <Cale> Yeah, the golden rule of indentation is what I hinted at before: siblings in the structure should line up vertically in terms of the column where they start, and when something is part of something else, it should start in a deeper column. I usually like to over-apply that rule, even in cases where it's not technically required, like with if-then-else-expressions.
12:58:59 <Cale> if foo
12:59:03 <Cale>    then bar
12:59:05 <Cale>    else quux
12:59:41 <M30W> How to check if is Right?
12:59:48 <srhb> M30W: Pattern match?
13:00:13 <Cale> M30W: Perhaps: case eitherSomething of Left e -> ...; Right x -> ...
13:00:33 <srhb> > let foo = Right 2 in case foo of (Right n) -> n
13:00:35 <lambdabot>   2
13:00:38 <srhb> Hurray!
13:00:50 <M30W> Cale: How about with a 'when' ?
13:01:44 <ipc9> anyone here?
13:01:52 <kennyd> > (+10) <$> Right 5
13:01:53 <lambdabot>   Right 15
13:02:00 <kennyd> > (+10) <$> Left "foo"
13:02:02 <lambdabot>   Left "foo"
13:02:03 <M30W> >let foo = Left 2 in case foo of (Right n) -> n; _ -> putStrLn "error"
13:02:08 <M30W> > let foo = Left 2 in case foo of (Right n) -> n; _ -> putStrLn "error"
13:02:10 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
13:02:10 <lambdabot>    arising from a use of ...
13:02:31 <Cale> ipc9: There are over 1000 users on the channel, someone's got to be awake :)
13:02:36 <ipc9> :)
13:02:43 <`nand`> though it's surprisingly dead at times
13:02:47 <`nand`> like 7:00 UTC-ish
13:02:50 <M30W> `nand`: lol
13:02:51 <`nand`> maybe earlier
13:02:59 <M30W> Thu Jan  3 08:02:42 EST 2013
13:03:06 <M30W> I haven't slept yet.
13:03:11 <M30W> The sun is bright lol
13:03:45 <zomg> Oh damnit, spend 15 minutes figuring out if there's some way to do what I want to do because I couldn't get it working with fmap
13:03:56 <zomg> then it turns out I was just being stupid and simply using return . fmap would have worked...
13:03:59 <zomg> durr
13:04:25 <ipc9> i am new to haskell and and getting tripped up on composition...i was wondering if someone could expand concatMap f =  foldr ((++) . f) []
13:05:03 <M30W> let foo = Left 2 in case foo of (Right n) -> n; (Left n) -> 2^n
13:05:09 <M30W> > let foo = Left 2 in case foo of (Right n) -> n; (Left n) -> 2^n
13:05:10 <lambdabot>   4
13:05:31 <shachaf> ipc9: concatMap f xs = foldr (\a b -> f a ++ b) [] xs
13:05:46 <Cale> concatMap f =  foldr ((++) . f) [] = foldr (\x xs -> ((++) . f) x xs) [] = foldr (\x xs -> (++) (f x) xs) [] = foldr (\x xs -> f x ++ xs) []
13:05:52 <Cale> Does that help?
13:06:28 <deus_rex> :t concatMap
13:06:29 <lambdabot> (a -> [b]) -> [a] -> [b]
13:06:33 <deus_rex> :t (++) . f
13:06:34 <lambdabot> (Functor f, Monoid a, FromExpr (f a)) => f (a -> a)
13:06:35 <ipc9> ...i am going to have to digest this
13:06:37 <Cale> Here's how I would think of it...
13:06:40 * shachaf notes that Cale's "xs" is not a list of things of the type of Cale's "x"
13:06:51 <Cale> shachaf: yes, that's true :)
13:07:09 <hpaste> M30W pasted “Look ESCAPE??” at http://hpaste.org/80123
13:07:14 <Cale> In general, foldr f z replaces each occurrence of (:) in a list with f, and the [] at the end (if any) with z
13:07:15 <M30W> loop *
13:08:01 <Cale> We can write concat by replacing all the occurrences of (:) in a list of lists with (++), and the [] at the end with []
13:08:12 <merk_> is that fold more efficient than more obvious concatMap f = concat . map f  ?
13:08:14 <Cale> concat = foldr (++) []
13:08:36 <Cale> merk_: If no optimisations are done by the compiler, then yes, it's an optimisation.
13:08:49 <Cale> merk_: But there are rewrite rules which end up making them equivalent.
13:08:56 <shachaf> merk_: The reason it exists is not really efficiency.
13:09:09 <Cale> Well, the original reason might have been efficiency :)
13:09:32 <Cale> Waaaay back before list fusion existed :)
13:09:41 <shachaf> Pre-rewrite rules, foldr probably wouldn't be the most efficient way to implement it either.
13:09:57 <M30W> Anyone mind telling me what I'm doing wrong? (hpaste bot has link above)
13:10:07 <edwardk> mekeor: to be fair snoyman has automated tools ;)
13:10:15 <Cale> ipc9: So, another thing we can do is to write map in terms of foldr
13:10:19 <aristid> edwardk: you don't?:)
13:10:30 <edwardk> aristid: sadly. too many dependencies
13:10:50 <Cale> ipc9: If we replace each (:) in the list with a function that applies f to its first parameter before adding it to the beginning of a given list
13:10:59 <aristid> edwardk: automate!
13:11:06 <Cale> Then we'll have accomplished the same thing as map
13:11:15 <Cale> That is,  map f = foldr ((:) . f) []
13:11:41 <edwardk> aristid: show me how to make something that can automatically generate a ton of fiddly little cabal files using the absolute minimum constraints and go hand edit tons of haskell source to make sure everything builds across as many versions as possible, etc.
13:11:53 <edwardk> its an inherently human task the way i have it set up
13:12:22 <shachaf> edwardk: Unfortunately tools that can automatically hand edit are beyond our reach at the moment.
13:12:45 <edwardk> the closest i have is a little 'upload' alias i use that does the sdist construction, validity check and pushing to hackage
13:12:59 <aristid> edwardk: finding the minimum constraints might be automatable, if you accept unnecessary computation (just try building it until you have constraints that let a build through and have the test suite pass)
13:12:59 <edwardk> but tweaking the version bounds on everything is the major pain point
13:13:02 <Cale> M30W: It looks like you're missing parens around the parameters to Right and Left?
13:13:27 <edwardk> so far the hackage updates are a pretty minimal part of my overall workflow
13:13:41 <edwardk> so ruining the rest of my workflow to improve 2% of it hardly seems worth it
13:13:44 <Cale> M30W: Right and Left only take one parameter, not three, so you have to write  Right (echoCommand hdl xs)
13:13:50 <aristid> edwardk: fair enough.
13:14:06 <M30W> Cale: or Right $ echoCommand hdl xs
13:14:09 <M30W> ?
13:14:11 <Cale> yes
13:14:11 <ipc9> Cale: i am working through what you said...its taking me some time
13:14:17 <M30W> Good.
13:14:21 <aristid> edwardk: sometimes automation can be more ideology than practical
13:14:23 <M30W> Still not working lol
13:14:24 <Cale> M30W: The next problem is that you're not working in the Either monad, but in IO
13:14:34 <M30W>     Couldn't match type `Either a3' with `IO'
13:14:44 <M30W> I see ^^ lol
13:14:46 <edwardk> and stackage and travis have provided me a pretty good integration server framework for smoking out when things are bad in aggregate
13:15:00 <Cale> M30W: So the thing on the right side of the <- needs to be an IO action, and not an Either () (IO ())
13:15:00 <M30W> Cale: How to be?
13:15:18 <M30W> Whaa?
13:15:19 <Cale> You could use let instead, if you didn't want to run the action, but I'm not sure here what you're trying to express.
13:15:28 <aristid> edwardk: have you succeeded building stackage on your mac?
13:16:03 <M30W> Cale: Tcp server; these are responces/commands and I want the quit command to stop this loop
13:16:18 <edwardk> aristid: yes. i do so quite regularly and it works modulo a couple of errors that are just port bindings, and what not causing packages that are disconnected from anything i use from failing here and there
13:16:38 <Cale> M30W: Well, Left () has type Either () b for some b, and  hPutStrLn hdl "pong" :: IO (), so  Right (hPutStrLn hdl "pong") :: Either a (IO ())
13:16:54 <Cale> and so unifying those, we get  Either () (IO ())
13:16:54 <ipc9> map thankYou ["Cale", "shachaf"]
13:17:08 <edwardk> i tend to run it when i go to bed
13:17:16 <Cale> M30W: Perhaps you wanted to actually run the IO actions involved here
13:17:41 <M30W> Cale: If the cases are valid; yes.
13:17:41 <Cale> e <- case map toLower x of "echo" ->
13:17:52 <aristid> edwardk: the problem i'm fighting with right now is that it seems to eat all my RAM and render the mac unusable. so i haven't let it finish yet
13:17:57 <M30W> Cale: I have that?
13:18:00 <Cale>        do v <- echoCommand hdl xs
13:18:02 <aristid> oh, gone
13:18:04 <aristid> well.
13:18:09 <Cale>           return (Right v)
13:18:19 <Eiam> I started programming about 12 years ago with C++ as my first language. I had 4 years of formalized classes where we learned 'fundamentals' like loops, linked lists, recursion, sorting & algorithms.  I let 'programming' lax for about 5 years after that, forgot pretty much all the C++ (thankfully?). I started again about 6 years ago with python, bash, ruby ,obj-c & javascript.  My coding still feels messy, haphazard &
13:18:19 <Eiam>  disorganized despite applying (or trying to?) MVC and modularization to code. I feel like I don't "get" it at a base level, like I'm always just putting together bits of code to make it work instead of 'understanding' something at a more basic level? I was hoping to try and 'relearn' things in haskell to make something I'm missing 'stick'. Doing "Learn you some haskell" made me feel yet again like I was just going to end up
13:18:19 <Eiam>  'putting together' peices instead of having a fundamental understanding of anything. Am I in the wrong place?
13:18:29 <M30W> echoCommand hdl xs >>= Right ?
13:18:32 <Cale> (sorry for that layout, it's a little awkward to get it right on IRC :)
13:18:43 <M30W> Cale: ^
13:18:52 <Cale> M30W: fmap Right (echoCommand hdl xs)
13:19:01 <M30W> @src fmap
13:19:01 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
13:19:08 <M30W> @. pl fmap
13:19:08 <lambdabot> Plugin `compose' failed with: Unknown command: "fmap"
13:19:12 <M30W> :|
13:19:15 <Cale> M30W: fmap isn't just one function
13:19:22 <Cale> It's the method of the Functor class
13:19:25 <Cale> :t fmap
13:19:27 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:19:31 <Lethalman> Eiam, the difference is that good pieces in haskell are good, while in other languages they always have some limited form... that's my understanding being a novice myself, and after writing a program for the second/third time
13:19:31 <M30W> It's mapping the function
13:19:34 <Cale> and implemented separately for each one
13:19:47 <Cale> So in this case, it has type  (a -> b) -> IO a -> IO b
13:20:39 <M30W> Cale: How would you write the parse loop/til quit ?
13:21:10 <Eiam> Lethalman: given the number of languages i've 'used' I'm starting to feel like maybe its not a language problem but a me problem =)
13:21:47 <Lethalman> Eiam, the language is all with what you express your things, it does matter
13:22:01 <M30W> Cale: I'm still lost.
13:22:21 <hpaste> Cale annotated “Look ESCAPE??” with “basic answer to looping” at http://hpaste.org/80123#a80124
13:22:29 <Cale> M30W: you could just do that
13:22:55 <srhb> Eiam: Sometimes jumping to a different paradigm can indeed help, but I think I have a friend that had that very same issue until he stuck with one language and really really learned it.
13:22:57 <M30W> Cale: Back to that :|
13:23:06 <srhb> Eiam: Haskell is a great language, you will enjoy being proficient in it.
13:23:11 <M30W> Cale: lol. I'm kinda trying to avoid that with Left/Right. :)
13:23:59 <Eiam> srhb: ha, I move jobs, they require new skillsets, new languages.
13:24:04 <Eiam> I'd enjoy being proficient in ANY language =)
13:24:25 <Eiam> truly proficient. not putting together code from stack overflow and stuff i already figured out and repurposing it
13:24:45 <srhb> Eiam: Right. Stick with one, any one (Haskell!) and keep at it. Converse with people who you are not ashamed to expose your idiocy to. ;)
13:25:12 <Eiam> oh, I tell people at work I'm an idiot
13:25:14 <Eiam> they just don't believe me
13:25:32 <Eiam> unless they read my code, then maybe they do, but I don't get code reviews too often unfortunately
13:25:38 <Eiam> left building my ship out of tape & glue
13:25:47 <Eiam> but hey it floats so nothing to worry about there right..
13:25:54 <Lethalman> Eiam, you should perhaps read code of other people
13:26:01 <Cale> Eiam: To some extent, solving problems is all about putting pieces together, but there are things you can do to make the pieces better.
13:26:10 <Rembane> Eiam: In the land of the blind, the one eyed man is king.
13:26:49 <Lethalman> Eiam, and by other people I don't refer to commercial products, that's often a pile of hacks... try reading some well organized and recognized as well written project in the FOSS world
13:26:52 <Eiam> Cale: other programmers cannot possible be trolling stack overflow for their problems, copy/pasting stuff & tweaking it. Re-using some snippet they wrote last week because hell if they remember exactly how to generate that from scratch
13:27:08 <srhb> Eiam: I didn't mean to put yourself down, I meant say when something really doesn't click with you and keep asking for that explanation that you're not getting. :)
13:27:15 <Cale> Eiam: One very powerful approach which we tend to like in the functional programming world is to design a language of problems in which your specific problem is easily expressed, and where the basic building blocks of that language have compositional solutions.
13:27:39 <pantsman> my favourite thing I have learned from haskell (or more generally, pure functional programming) is a proper appreciation of what really aids composition (putting pieces together)
13:28:18 <Cale> For example, suppose that you're writing a program to work with recipes, calculate their sugar content, print them out formatted nicely, and so on.
13:28:54 <Cale> You might design a language in which there are a bunch of "primitive recipes" consisting of, say, a fixed amount of a single ingredient
13:28:57 <Eiam> Cale: most of my work involves taking data from one system and turning it into something useful/actionable by exposing it into another system (typically a web front end with charts, or just lists of actionable data)
13:28:58 <gilligan_> what editor do most people in here use ? vim or emacs ? maybe even some IDE ?
13:29:04 <Cale> and then ways to transform and combine other recipes
13:29:24 <srhb> gilligan_: Vim or Emacs, most likely. The IDEs aren't really that mainstream for Haskell yet.
13:29:25 <`nand`> gilligan_: mixture of vim and emacs
13:29:28 <Cale> Say, scaling the amount of something, layering one thing on top of another, blending, and so on.
13:29:29 <`nand`> emacs seems to be slightly more popular
13:30:20 <|||tux||> the identation is way better in emacs
13:30:21 <gilligan_> vim with ghci running inside ConqueTerm is okay for me so far
13:30:37 * `nand` uses plain vim with syntax highlighting
13:30:53 <gilligan_> |||tux||, yeah that is what I was about to complain about - the indentation could be better
13:30:59 <Cale> Eiam: then in the end, calculating the sugar content of the whole recipe just amounts to replacing most of the combining operations with addition, and knowing the sugar content of the basic ingredients (of course, if you cook things, this will get complicated, but there ought to be a way to determine it :)
13:31:30 <`nand`> I think I'll always be using manual indentation (or, well, semi-manual; it keeps the same indentation level as the previous line but that's it)
13:31:31 <gilligan_> `nand`, really? ugh.. i've assorted loads of plugins that I couldn't live without :)
13:31:39 <Eiam> was thinking maybe i should back up to basics, The Structure and Interpretation of Computer Programs by Abelson and Sussman    or something
13:31:40 <Cale> Eiam: and from such a description, you can also write a program which collects up all amounts of the ingredients into a table, or writes out an English language description of how to make it
13:32:32 <`nand`> I don't think I'd ever be able to learn nearly about as much about programming by reading books about it as compared to actually programming
13:32:35 <Cale> Eiam: A similar approach was used to define a library for analysing exotic financial contracts.
13:32:58 <Cale> Eiam: and we also do this sort of thing to define drawing libraries, and parsers.
13:33:30 <Cale> Eiam: It tends to be really powerful in general, because you end up with something which doesn't just solve your problem, but also easily solves a lot of minor variations
13:33:38 <Rembane> gilligan_: Do you have a list of the must-have plugins for vim? :)
13:34:06 <Lethalman> Eiam, your world of translating stuff between systems and the web ecc. is intrinsically difficult to structure and manage...
13:34:13 <Cale> i.e. rather than just computing the value of one specific type of contract in terms of certain numerical inputs, you have a library which lets you compose many types of contracts
13:34:37 <gilligan_> Rembane, https://github.com/gilligan/.vim/blob/master/vimrc
13:35:14 <Cale> and extract from their descriptions various ways to estimate the value, or produce a human readable description, or do interactive case-analysis of what might happen to the contract in various situations.
13:35:24 <Rembane> gilligan_: Thanks.
13:35:50 <Cale> Eiam: Does that make any kind of sense? There's a talk about it and a paper if you're interested :)
13:36:01 <gilligan_> Rembane, essential = vundle, fugitive, ctrlp, syntastic, neocomplcache -- for me anyway
13:36:10 <Eiam> Lethalman: because people always tell me they want X, so I give them X, then they want X+Y, and I didn't design it to do X+Y and now I have to hack it, then they want Z, so in goes another hack, then the code is all a mess
13:36:22 <simon> @pl flip any
13:36:22 <lambdabot> flip any
13:36:33 <Lethalman> Eiam, as I said, that's normal in your environment
13:36:47 <Eiam> Cale: I'm catching up, moment.
13:36:52 <Lethalman> Eiam, where everything is needed within a certain date, you're limited in writing better stuff
13:36:59 <Rembane> gilligan_: Nice. Thanks.
13:37:10 <Eiam> Lethalman: everything was needed yesterday, why wasn't it done yesterday.
13:37:32 <Eiam> when your project dies in 2 months the time to structure it properly, why bother, its just going to rot and die anyway
13:37:39 <Eiam> maybe i need a new line of work ha
13:37:40 <Lethalman> Eiam, so I wouldn't worry about that, it's very hard to get things right and general from the very beginning
13:37:58 <lackity> Can I apply a filter and get both the positive list and the negative list?
13:38:00 <Cale> Eiam: This way of doing things that I'm suggesting tends to take a fair amount more thought in the outset, but quickly pays for itself.
13:38:22 <Cale> lackity: partition in Data.List might be what you want
13:38:26 <Lethalman> Eiam, rather, try reading some FOSS project, where there's no date to follow, people work on projects on free time and write and review new code for the better
13:38:29 <Cale> > partition even [1..10]
13:38:30 <Eiam> Cale: so you do things so general (which takes up a lot of time) in the hopes that in the future someone is going to need something that you now have the generalness to do
13:38:30 <lambdabot>   ([2,4,6,8,10],[1,3,5,7,9])
13:38:42 <Eiam> but in reality people want specific things with a couple specific tweaks. its a heavy upfront cost to pay
13:38:56 <lackity> Cale: thanks
13:39:05 <lackity> Cale: couldn't guess the name to search for it
13:39:10 <Eiam> its like they say, you tell a programmer to build a function to "Bomb CityA" and they give you a function to bomb(City) because hey, its more general
13:39:12 <Cale> Eiam: Well, the hope is that it's not *too* much harder to write a general library of simple pieces, and ways to put those pieces together, than to write a solution directly to your problem.
13:39:17 <Lethalman> Eiam, exactly, not to say that much abstraction in the end kills you because when you have to add a specific X, it might happen that you have to rethink the abstraction to include that _kind_ of X
13:39:25 <Eiam> except a lot more complex and if you really only ever wanted to bob CityA, the rest of that work was pointless
13:39:25 <Cale> Eiam: after all, you can just define only the pieces that you actually need
13:39:50 <Cale> and then extend that when the time comes
13:40:27 <Cale> Eiam: Sometimes it's not any more complex
13:40:36 <M30W> Hmm... ["35","63"] -> [35,63] How?
13:40:45 <Lethalman> Cale, yes, unfortunately in a java-like world people writes 3 stuff instead of 1, an abstract class and interface that nobody will ever use, and if they will use it's still limited :P
13:40:50 <Lethalman> *write
13:40:52 <M30W> > read ["35","63"] :: [Int}
13:40:54 <lambdabot>   <hint>:1:25: parse error on input `}'
13:40:56 <Nereid> map read?
13:40:57 <Cale> Quite often the definition of bomb will be simpler than the definition of bombCityA
13:41:00 <M30W> > read ["35","63"] :: [Int}
13:41:01 <lambdabot>   <hint>:1:25: parse error on input `}'
13:41:05 <M30W> > read ["35","63"] :: [Int]
13:41:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:41:06 <lambdabot>              with actual type...
13:41:12 <deus_rex> > map read ["35","63"] :: [Int]
13:41:13 <lambdabot>   [35,63]
13:41:14 <M30W> > map read ["35","63"] :: [Int]
13:41:16 <lambdabot>   [35,63]
13:41:19 <M30W> :)
13:41:43 <Eiam> Cale: if you have to bomb CityA, its really easy to hardcode cityA's coordinates. if you make a function to bomb ANY city, you have to add in logic & support to calculate & manage the location being ANYWHERE instead of just a very specific thing. with very specific climates and specific terrain
13:41:51 <Eiam> making it general means you have to support anything
13:41:51 <|||tux||>  ek
13:41:52 <Cale> Well, Java programmers frequently don't know how to properly abstract things, and you can hardly blame them because their language is making it difficult for them.
13:41:56 <deus_rex> > [ read n :: Int | n <- ["35","63"] ]
13:41:58 <lambdabot>   [35,63]
13:42:23 <Lethalman> Cale, yes, but the language means many things... it's not that you must never blame a language, including haskell
13:42:30 <zomg> Eiam: what about cities on other planets?
13:42:39 <Eiam> Cale: which means in comes the giant case/switch statement. well if its a cold climate the jet needs more fuel, if its a wet cliamte the jet needs a different type of bomb
13:42:41 <Eiam> and so on
13:42:51 <Eiam> all the sudden your nice bomb function is a cluster fuck of conditionals
13:42:57 <Lethalman> the language is very very important, more than what people usually think
13:42:57 <Cale> Why a giant case?
13:43:00 <aristid> > map (read :: String -> Int) ["35", "36"]
13:43:01 <lambdabot>   [35,36]
13:43:03 <M30W> Nice
13:43:25 <Cale> I disagree regarding the clusterfuck of conditionals.
13:43:32 <Eiam> Cale: thats what my code ends up being after long enough
13:43:36 <Eiam> i get so many random cases that are one off
13:44:06 <Eiam> people ask me why is that feature taking so long? well, for 80% of the cases it was straight forward. the remaining 20% are a bunch of edge cases and the data isn't quite right, so i have to identify it, reformat it and treat it different. over and over and over
13:44:31 <M30W> aristid: What about adding them in that map?
13:44:40 <aristid> M30W: adding what?
13:44:55 <M30W> aristid: each piece to the list
13:45:11 <aristid> M30W: ?
13:45:11 <Cale> Well, okay, if you do it badly, you can end up with something like that -- and to be quite honest, if you're writing a one-off program which you don't need to maintain, maybe that's even the fastest way to get it done.
13:45:12 <Eiam> I wrote this function one time in javascript to verify that any action that was performed, was actually performed. it would look at the state of a DOMTree to identify what it state it was in, then compare to see if the function was called properly moved the tree into the correct state. it was something like 400 lines of if/else
13:45:36 <Cale> However, the approach I'm advocating is not that :)
13:45:43 <Cale> The idea is to break the problem down in terms of its structural description, and solve the problem recursively in terms of that structure.
13:45:46 <Eiam> so you'd do something htne say "verifyState(myAction);"
13:45:53 <Eiam> how would you composite a function to handle that ?
13:46:03 <Eiam> without it being a bunch of if/else/case/switch
13:46:45 <zomg> Most of the time in Haskell if you use a case or an if, you can do it in other ways too
13:46:49 <Cale> I'm not sure that I understand your problem...
13:46:51 <zomg> I'd say the same applies to other languages too =)
13:47:08 <zomg> It's pretty hard to say how else you could've implemented a function without knowing exactly how it works though
13:47:17 <Eiam> yeah i suppose thats not enough information
13:47:54 <zomg> Tbh that's one of the things you learn with functional programming
13:47:58 <Eiam> okay. Success in the fuction would mean the tree looks like X. The tree could look like one of 200 different things. X being one of them. How do you modularly figure out what state you are actually in?
13:48:02 <M30W> > sum $ map(read :: String -> Int) ["25","64","75"]
13:48:04 <lambdabot>   164
13:48:12 <Eiam> i checked 200 states till I found one that matched
13:48:14 <Eiam> (basically)
13:48:25 <zomg> I suppose you would need to loop through the tree
13:48:27 <Eiam> and mentally thats the only thin I could think of
13:48:36 <Eiam> "time to start comparing"
13:48:45 <Cale> Eiam: Break down the description of success, and the tree, recursively, and compare the pieces.
13:49:45 <Cale> Eiam: You would have some kind of description of success which presumably would have its own tree structure
13:50:03 <Cale> and whose parts would correspond to small amounts of testing the structure of your other tree
13:50:10 <Eiam> sure, if the tree looks like ABC, and X is ABC, then you have tree ABC
13:50:15 <Eiam> else, you don't, compare the next
13:50:35 <Cale> So you shouldn't have 200 cases
13:50:53 <Cale> You should have maybe 3 or 4 cases, in a handful of places
13:51:03 <Cale> and then a way to put those together
13:51:26 <Cale> Of course, I don't know, maybe you really do have 200 different types of nodes and the thing is just a complete clusterfuck from the outset.
13:52:04 <Eiam> doing any sort of testing or automation in javascript is fucked from the outset is what I learned in that project
13:52:30 <Cale> Well, if you ask me, that's kind of true of all imperative languages ;)
13:52:38 <zomg> I find that hard to believe, having used javascript for quite a long time
13:52:47 <Eiam> hey, so I heard you have this automated way to test some stuff on a remote object tree of a remote abstracted object tree. I think you should build performance testing on top of that.
13:52:48 <zomg> It can be if you don't know the intricasies of the language though
13:52:49 <Cale> Mutation makes testing unduly hard
13:52:58 * Eiam blank stares. "Why not, what could possibly go wrong with so many abstraction layers"
13:53:24 <Cale> Because you often want to be able to check that certain equations hold: that f(x) = g(x) for various input data x.
13:53:46 <zomg> Honestly comparing two dom trees seems like a reasonable straightforward process to me
13:53:59 <Cale> But if f is allowed to destroy your x, you need to make copies of it, which is the first point of awkwardness.
13:54:06 <Eiam> zomg: sure. this was with iOS testing btw
13:54:15 <zomg> Oh
13:54:17 <Cale> and then secondly, in imperative programming, your f and g can have other effects
13:54:18 <zomg> Anything iOS is very "fun"
13:54:19 <zomg> ;>
13:54:20 <Eiam> if you've ever used Instruments, it gives you a DOM-esque tree of the app state
13:54:26 <Eiam> and you interact with it via JS
13:54:29 <Lethalman> Cale, not only mutation, but you convey with me that it's also the way types and abstractions are represented in other languages... it's not only about the programmer, but also at what a language makes you write things in a more natural manner
13:54:37 <Cale> Often things aren't in a nice form where you know what they can even change
13:54:39 <Eiam> so you see like <button name="blah" state=1">
13:54:51 <zomg> I've been working on some Objective-C stuff and I can't imagine why anyone would design a language like Objective-C
13:54:56 <Eiam> and you can say var buttons = buttons.name("blah").tap()
13:55:06 <Lethalman> zomg, nod
13:55:06 <zomg> It just feels like C with some random stuff slapped on top of it :P
13:55:19 <Eiam> zomg: like C with smalltalk slapped on top? =)
13:55:24 <Eiam> shocker
13:55:27 <zomg> Yeah something like that
13:55:27 <S11001001> zomg: it's not just random stuff, it's random Smalltalk stuff :P
13:55:36 <Lethalman> S11001001, ahah right
13:55:43 <Cale> So, you have to collect up all this information about the environment in which your programs are running, both before and after executing them, being very careful to avoid aliasing, and then compare the results before and after. That's assuming you can figure out all the state which is relevant.
13:55:50 <Cale> That makes testing very hard.
13:56:49 <Cale> Whether you're programming in Python or Java, or C++, that problem is the same.
13:56:51 <gilligan_> zomg, And yet i'd always go for ObjC instead of C++ if I had to choose between those two
13:56:57 <Cale> But in Haskell, it goes away :)
13:57:03 <Cale> (mostly)
13:57:24 <zomg> gilligan_: yeah it does seem like less of a pita in certain ways than C++ but it still feels like a mess :D
13:57:26 <Cale> If what you're testing are pure functions, then they only depend on their parameters, and only produce their result.
13:57:35 <Cale> and have no other effects
13:57:51 <Cale> This means you know they will behave the same way in a real program as they behave in isolation.
13:57:57 <|||tux||> C++ is pretty nice
13:58:15 <Cale> and it means that you don't have to awkwardly copy parameters to things along with bits of the environment beforehand
13:58:36 <zomg> IORef all the things!
13:59:26 <gilligan_> zomg, the syntax is a bit odd but it sure does a better job at being a OOP language
13:59:53 <srhb> gilligan_: What does?
13:59:53 <gilligan_> zomg, meanwhile c++ is getting worse and worse (hello c++11, i'm looking at you)
14:00:07 <gilligan_> srhb, ObjC
14:00:12 <zomg> Yeah can't comment on that as tbh I'm not good enough in either of them to be able to judge it well :)
14:00:13 <Cale> So while you might still have some limited scopes in which you're trying to work out whether an IO action does the right thing, to a large extent, you can push all the interesting work of determining what's going to happen into pure functions, and test those.
14:00:14 <srhb> gilligan_: Ah.
14:01:19 <Cale> Eiam: I'm not sure whether you were following that or not :)
14:02:11 <thalassarche> gilligan_: Why is C++11 worse than C++98 ?
14:02:24 <n-dolio> thalassarche: Lower number.
14:02:48 <hpc> > C
14:02:50 <lambdabot>   Not in scope: data constructor `C'
14:03:04 <hpc> if only you could define your own data types in lambdabot
14:04:55 <gilligan_> thalassarche, in that sense that they again did not try to just tidy things up but instead add more features
14:05:20 <gilligan_> thalassarche, c++ doesn't need more features imho, it needs less suckage
14:05:30 <Lethalman> hpc, you can still use functions right? :P
14:05:38 <hpc> yes
14:05:49 <hpc> but then you can't define a C constructor
14:05:53 <thalassarche> Don't we all love lambdas and type inference?
14:06:02 <Lethalman> hpc, constructor a b = (a,b) :P
14:06:10 <Cale> gilligan_: Yeah, the C++ language description is already hopelessly long. I'm not sure anyone in the world actually really understands C++.
14:06:13 <hpc> and thus can't write (C `mappend` _ = WorseThanCPlusPlusNinetyEight)
14:06:23 <zomg> Swizec: why do I see you popping up everywhere? =)
14:06:25 <Lethalman> hpc, lol
14:06:26 <n-dolio> I don't know if we love C++'s implementation of them.
14:06:31 <hpc> :t (++)
14:06:32 <lambdabot> Monoid m => m -> m -> m
14:06:38 <Swizec> zomg no idea :D
14:06:48 <Sculptor> Cale, maybe barney stroustrup does
14:06:56 <Lethalman> > (++) == mappend
14:06:58 <lambdabot>   No instance for (GHC.Classes.Eq (m0 -> m0 -> m0))
14:06:58 <lambdabot>    arising from a use of ...
14:07:01 <Lethalman> right
14:07:26 * Lethalman thought about references for a second, won't do it anymore... sorry!
14:07:48 <Lethalman> hpc, is ++ equal to mappend then?
14:07:57 <Nereid> :t (++)
14:07:59 <lambdabot> Monoid m => m -> m -> m
14:08:02 <hpc> in lambdabot
14:08:11 <hpc> :t (++11)
14:08:12 <lambdabot> (Num m, Monoid m) => m -> m
14:08:18 <hpc> sweet, and that parses right too
14:08:44 <Lethalman> ok, was asking because in my ghci I see [a] -> [a] -> [a]
14:08:46 <hpc> (you can never be sure in a language that allows _2 to be a single token)
14:08:57 <hpc> Lethalman: it's a lambdabot exclusive
14:09:06 <Lethalman> hpc, ok fine
14:09:07 <hpc> buy now and get (.) = fmap, absolutely free!
14:09:08 <Cale> He might have, at some point, understood each detail, but it's a little hard to imagine that, say, if all the copies of the C++ spec somehow burned in a fire, he could eventually reproduce it from memory.
14:09:42 <Lethalman> :t (.)
14:09:43 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:09:47 <Lethalman> oh... \o/
14:10:03 <hpc> we used to have a Num instance for functions that was fun too
14:10:10 <hpc> (sin**2 + cos**2) == 1
14:10:23 <hpc> and flip fs x = fmap ($ x) fs
14:10:26 <n-dolio> > 5 5
14:10:27 <lambdabot>   Could not deduce (GHC.Num.Num (a0 -> t))
14:10:27 <lambdabot>    arising from the ambiguity chec...
14:10:29 <hiptobecubic> Are most of the simple monads now done as transformers over the Identity monad?
14:10:34 <Cale> (even up to some kind of equivalence)
14:10:47 <Cale> hiptobecubic: The mtl ones are.
14:10:59 <hiptobecubic> what does 'mtl' mean?
14:11:03 <hiptobecubic> it's a package i know
14:11:03 <simpson> hiptobecubic: If the monad makes sense as a transformer, then yes, but not as a rule.
14:11:05 <hiptobecubic> but the name i mean.
14:11:09 <Cale> Monad transformer library
14:11:10 <srhb> Monad Transformer Library?
14:11:11 <hiptobecubic> monad...transformer lib?
14:11:14 <hiptobecubic> ok
14:11:21 <n-dolio> Someone was explaining in #haskell-blah a while back how people authoring the lambda proposal for C++ didn't really even understand the implications of what they wrote until after the fact.
14:11:50 <Cale> I don't see how they could be expected to, given how complicated C++ is.
14:12:08 <hiptobecubic> what's wrong with them?
14:12:14 <Lethalman> I have a problem compiling lambdabot
14:12:15 <hiptobecubic> the lambdas i mean, not the people.
14:12:15 <neutrino> what are the unexpected implications?
14:12:29 <Lethalman> where should I ask?
14:12:36 <Lethalman> haskell-src-exts-1.13.5 failed during the configure step. The exception was:
14:12:37 <Lethalman> ExitFailure 1
14:12:53 <jesyspa> Cale: Especially hearing the news about const.
14:12:56 <n-dolio> For instance, how by-value lambdas don't capture member variables by value, because member variables aren't actually 'in scope' per se, it's just that 'whatever' is sugar for 'this->whatever', and this is captured by-value.
14:12:58 <Cale> Lethalman: That's not the actual failure, look up in the log...
14:13:10 <n-dolio> So by-value lambdas can contain shared references that interfere with one another.
14:13:26 <Lethalman> Cale, sorry Resolving dependencies...
14:13:27 <Lethalman> [1 of 1] Compiling Main             ( /tmp/haskell-src-exts-1.13.5-8677/haskell-src-exts-1.13.5/Setup.hs, /tmp/haskell-src-exts-1.13.5-8677/haskell-src-exts-1.13.5/dist/setup/Main.o )
14:13:27 <Lethalman> /tmp/haskell-src-exts-1.13.5-8677/haskell-src-exts-1.13.5/Setup.hs:1:1:
14:13:27 <Lethalman>     Warning: In the use of `runTests'
14:13:27 <Lethalman>              (imported from Distribution.Simple, but defined in Distribution.Simple.UserHooks):
14:13:28 <Lethalman>              Deprecated: "Please use the new testing interface instead!"
14:13:30 <Lethalman> Linking /tmp/haskell-src-exts-1.13.5-8677/haskell-src-exts-1.13.5/dist/setup/setup ...
14:13:32 <Lethalman> Configuring haskell-src-exts-1.13.5...
14:13:34 <Lethalman> setup: The program happy version >=1.17 is required but it could not be found.
14:13:36 <Lethalman> cabal: Error: some packages failed to install:
14:13:38 <Lethalman> haskell-src-exts-1.13.5 failed during the configure step. The exception was:
14:13:40 <Lethalman> ExitFailure 1
14:13:42 <Lethalman> lambdabot-4.2.3.3 depends on haskell-src-exts-1.13.5 which failed to install.
14:13:44 <Lethalman> ops
14:13:46 <Lethalman> damn sorry all
14:13:48 <Lethalman> :-(
14:14:06 <neutrino> k-dolio: so they're actually not closuring their closure vars?
14:14:17 <simpson> Lethalman: You need a new(er) happy.
14:14:28 <Lethalman> simply-chris, happy?
14:14:46 <n-dolio> neutrino: by-value lambdas close over all variables in scope by-value, but 'this' is the variable in scope, not the member variable.
14:14:54 <neutrino> Lethalman: update your cabal
14:14:54 <simpson> Lethalman: It's part of the Haskell Platform and your distro should have it.
14:15:06 * hackagebot zip-archive 0.1.3.3 - Library for creating and modifying zip archives.  http://hackage.haskell.org/package/zip-archive-0.1.3.3 (JohnMacFarlane)
14:15:12 <n-dolio> And capturing 'this' by value still leaves you with shared references to the member variables of this.
14:15:22 <n-dolio> Because 'this' is a pointer.
14:15:27 <neutrino> n-dolio: yeah i got that - it's just ricockulous
14:15:38 <n-dolio> Well, yeah.
14:16:18 <Lethalman> simpson, neutrino it's 0.14.0 in debian unstable, should I get the experimental one 1.16.0.2 ?
14:16:28 <hiptobecubic> n-dolio, oh wow. yea
14:16:44 <neutrino> Lethalman: i meant the package list. update that.
14:16:48 <hiptobecubic> n-dolio, can you localize it somehow and just capture that one reference?
14:16:54 <neutrino> but yeah, just get a newer haskell platform
14:17:01 <n-dolio> Probably.
14:17:05 <Lethalman> neutrino, ah ok ;)
14:17:46 <hiptobecubic> I guess lyah needs a big update then when it comes to the monad chapter
14:18:10 <Lethalman> hiptobecubic, yes just stumbled upon State today in lyah
14:18:26 <neutrino> lyah needed a big update before it was written
14:18:37 <hiptobecubic> neutrino, awww. what's wrong with lyah?
14:18:59 <neutrino> well, the worst thing is that people get duped into reading something as reference which is not reference
14:19:06 <neutrino> there is no community based process to improving it
14:19:16 <hiptobecubic> it's a book
14:19:30 <Rembane> Is there a good reference out there?
14:19:32 <hiptobecubic> RWH has the worst "improvement process" possible.
14:19:36 <neutrino> in fact there is no bonus at all
14:19:48 <neutrino> why does it have the worst process possible?
14:19:54 <neutrino> being able to comment on sections is very powerful
14:19:59 <Eiam> Cale: sorry someone came into my office for a quick meeting. lemme scroll back
14:20:06 <hiptobecubic> Sure, except they are all hidden by default and completely ignored
14:20:10 <neutrino> if you need clarification on something, you can look in the comments, and ask or maybe even find a ready answer
14:20:21 <hiptobecubic> then you have 25 people that all say "hey this is still broken and nothing in this chapter works"
14:20:24 <neutrino> they're not hidden, there are prominent icons
14:20:32 <neutrino> only an idiot would ignore this facility
14:20:39 <sclv> lyah had an improvement process as it was written
14:20:47 <neutrino> yeah, it did too
14:20:49 <simpson> @tell edwardk I'd *really* like Trifecta 0.90; I released my other dependency, so that's all that's left. What needs to happen for Trifecta to have a new release?
14:20:49 <lambdabot> Consider it noted.
14:20:53 <neutrino> i contributed some fixes myself
14:20:54 <sclv> every article was posted to reddit
14:21:08 <neutrino> they were more for the website than the book though
14:21:12 <sclv> oh, i see, you weren't saying it as a criticism, but as a fact
14:21:36 <neutrino> yes, nowadays there is no way to improve the book
14:22:07 <neutrino> there used to be some contrived way before it got released, and even that is gone now
14:22:41 <neutrino> it's definitely criticism though. i hoped by now we'd gone past non-free software/knowledge/documents/processes/communities/whatever
14:22:50 <Eiam> Cale: Okay, so a function given one value always returns the same thing for the same value. so its OK for a function to have two different return types, depending on which input it gets?
14:22:59 <monochrom> community-based processes exist. see http://en.wikibooks.org/wiki/Haskell and in fact almost all of http://www.haskell.org/haskellwiki/Haskell . does not work any better if you ask me.
14:23:01 <srhb> Eiam: No
14:23:07 <Lethalman> neutrino, still the same error setup: The program happy version >=1.17 is required but it could not be found.... will get a newer cabal from experimental
14:23:17 <srhb> Eiam: The return type is always the same.
14:23:25 <neutrino> nono, the actual version of cabal won't change things
14:23:28 <neutrino> you could just break stuff
14:23:32 <Nereid> Eiam: however, you could make the return type an Either
14:23:35 <Eiam> srhb: you are saying that a function should always return the same type as a matter of design. its clearly not a requirement
14:23:37 <neutrino> just get a new haskell platform as someone else suggested Lethalman
14:23:42 <Nereid> Eiam: it is a requirement.
14:23:44 <srhb> Eiam: No, I'm saying it is a requirement
14:23:45 <Lethalman> neutrino, you mean a new ghc?
14:23:47 <Eiam> within haskell
14:23:58 <hiptobecubic> the wiki is just not a book. It's not "readable". You have to be searching for a topic
14:24:01 <srhb> Eiam: Yes.
14:24:07 <Eiam> im saying from a design standpoint
14:24:08 <hiptobecubic> You don't "work through" the wiki
14:24:12 <neutrino> there is a package called the "haskell platform", it bundles cabal, ghc, and a lot of libraries
14:24:16 <monochrom> the wikibook is a book
14:24:17 <Lethalman> neutrino, ah
14:24:25 <srhb> Eiam: Well, both.
14:24:30 <Eiam> it sounds like you agree with haskells design then, that the type can never change
14:24:31 <Lethalman> neutrino, thanks :)
14:24:36 <srhb> Eiam: I do.
14:24:47 <Nereid> types are determined at compile time.
14:24:50 <Lethalman> neutrino, so if that doesn't work I have to get the one from experimental I believe
14:24:54 <Eiam> yeah i was just struggling with documenting a function my boss wrote, it returns an array sometimes, empty or with objects, ors oethings returns a nil/null
14:25:00 <Eiam> and i was trying to figure out how to document two return types
14:25:02 <srhb> Eiam: Yikes!
14:25:04 <Eiam> (and having trouble)
14:25:07 <neutrino> hiptobecubic: many wikis have "paths" or "courses" which list pages to read one after the other.
14:25:17 <srhb> Eiam: Disgusting thing. :P
14:25:18 <hiptobecubic> monochrom, the wikibook yes. I meant the haskell.org wiki. I haven't gone through much of the wikibook though.
14:25:25 <neutrino> Lethalman: no, you don't need to get any "one" from "experimental"
14:25:28 <Eiam> so you would say that it should only ever return an array
14:25:37 <Eiam> srhb: then how about when it throws an error instead of returning at all?
14:25:49 <neutrino> Lethalman: the version of the happy ghc package has nothing to do with the version of the cabal program.
14:25:52 <Lethalman> neutrino, ok thanks, will let you know after I download the platform... I just installed singularly ghc and cabal-install until now
14:25:59 <srhb> Eiam: You can wrap several possible types in another
14:26:01 <Nereid> Eiam: you can return something like a Maybe or Either.
14:26:10 <srhb> Eiam: In Haskell you could have Either Error (Array Int)
14:26:22 <Lethalman> neutrino, aaaah so I might just install happy instead of the whole platform, let me see
14:26:37 <monochrom> just saying that a community-based book exists, and look how much it ever improved the situation!
14:26:38 <Eiam> oh haskell doesn't have a throw?
14:26:42 <neutrino> Lethalman: you really want to install platform.
14:26:50 <Nereid> Eiam: it does, but that can only be used in IO.
14:26:57 <srhb> Eiam: Or you could have three possibles: data OneOf a b c = First a | Second b | Third c
14:27:04 <srhb> Eiam: And so on...
14:27:12 <neutrino> Eiam: it has "error"
14:27:17 <Eiam> srhb: but that seems confusing because now you've got multiple return types, which I thought was just established were 'bad'
14:27:17 <Nereid> @let safeSqrt x = if x < 0 then Left "sqrt of negative" else Right (sqrt x)
14:27:19 <lambdabot>  Defined.
14:27:21 <Nereid> > safeSqrt 3
14:27:23 <lambdabot>   Right 1.7320508075688772
14:27:24 <Nereid> > safeSqrt (-2)
14:27:26 <lambdabot>   Left "sqrt of negative"
14:27:27 <srhb> Eiam: But the return type would still be OneOf a b c (with a b c filled in with concrete types)
14:27:40 <srhb> Eiam: No, the return type is OneOf a b c.
14:27:44 <monochrom> in fact both RWH and LYAH were *after* the wikibook
14:27:55 <neutrino> Eiam: in haskell there's no such thing as multiple return types in haskell, values in haskell are strongly typed and always only have one type.
14:28:40 <srhb> Eiam: Think of how lists can contain different types of values (but only one particular for any one list)
14:28:51 <Nereid> :t safeSqrt (3 :: Double)
14:28:52 <lambdabot> Either [Char] Double
14:28:54 <srhb> Eiam: You are return a list of Int, say, but it is ONE type, ie [Int]
14:29:01 <srhb> Eiam: Not two.
14:29:06 <neutrino> Eiam: in haskell, like in many other languages, you can have product types
14:29:28 <neutrino> Eiam: you can also have algebraic types (alternatives) which is what you're looking for
14:29:29 <Nereid> but unlike many other languages, you can also have su mtypes.
14:29:32 <Nereid> sum types.
14:29:36 <Nereid> like Either
14:29:46 <geekosaur> First, Second, and Third are not types, they are (if you think in terms of other languages) enums
14:30:05 <neutrino> sum types aka union types exist in many languages
14:30:07 <geekosaur> except they can carry additional data, so in reality they're more like tagged unions
14:30:09 <Nereid> they are sometimes called "tagged unions"
14:30:11 <Nereid> yeah
14:30:11 <neutrino> for example C and C-likes
14:30:12 * hackagebot shake 0.4 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.4 (NeilMitchell)
14:30:12 <Lethalman> Nereid, Either would be a simple struct in any other language
14:30:16 <srhb> Or value constructors, as we say. They construct values of type OneOf a b c
14:30:41 <Lethalman> neutrino, just realized lambdabot was packaged for debian :P
14:30:45 <Nereid> Lethalman: many languages don't really have sum types.
14:30:55 <neutrino> Lethalman: there you gooo
14:31:18 <Lethalman> Nereid, an approximation then
14:31:19 <neutrino> Nereid: which languages don't have sum types?
14:31:27 <Nereid> let's say C.
14:32:55 <Nereid> you can kind of do them but it's kind of gross and not very safe.
14:33:03 <neutrino> C has unions
14:33:18 <neutrino> besides, C is not a strongly typed language
14:33:27 <Nereid> it's not?
14:33:32 <neutrino> it only makes sense to talk about unions in languages that are strongly typed
14:33:40 <neutrino> no, it's a free for all, you can interpret anything as anything
14:33:55 <Nereid> you can too in Haskell, we have unsafeCoerce
14:34:08 <Lethalman> class Either<L,R> { boolean isLeft; L left, R right; }  :P
14:34:09 <neutrino> except in C it's idiomatic to do it
14:34:15 <neutrino> in Haskell it's only idiotic
14:34:15 <geekosaur> unions in C, in particular, are pretty much explicitly very weak; there is deliberately no tagging, hence no checking that what you put in is what you're getting out
14:34:30 <neutrino> right
14:34:37 <Nereid> Lethalman: sure. or even use a union { L left, R right }.
14:34:47 <Nereid> but there's nothing stopping you from using right if ifLeft is true.
14:34:54 <neutrino> but what i mean is that you can put anything you want inside a char, as long as it has the size of a char, and you'll be able to read it back
14:34:54 <Nereid> hence unsafe.
14:34:56 <|||tux||> Lethalman: or boost::variant
14:35:05 <geekosaur> union { float f; long l; } x; x.f = 1.0; printf("%d\n", x.l); /* completely valid */
14:35:10 <Nereid> neutrino: with explicit casts, sure.
14:35:23 <geekosaur> well, %ld
14:35:57 <|||tux||> Nereid: That would be undefinied behavoir (using left when there is a right) in C
14:36:04 <neutrino> but it's even funnier in "dynamic" language
14:36:04 <neutrino> s
14:36:11 <Nereid> |||tux||: sure, but the compiler won't stop you.
14:36:14 <neutrino> because really, any variable can hold any type
14:36:15 <Nereid> which is the point.
14:36:20 <neutrino> so it's like everything is one big union.
14:36:46 <Lethalman> I've installed lambdabot, how do I make it join an irc channel?
14:36:47 <|||tux||> Well, in C++ with boost you can use boost::variant, which is a bit safer
14:36:47 <neutrino> because why write a compiler if you can kludge together some piece of crap and call it the next step in programming language evolution
14:37:12 <Nereid> ok, sure.
14:37:16 <neutrino> Lethalman: you can just have this lambdabot here join your channel.
14:37:25 <Lethalman> neutrino, in another irc server?
14:37:30 <neutrino> no idea
14:37:39 <neutrino> Cale: do other irc servers work?
14:38:16 <Lethalman> neutrino, it was just for me and my friend (that I'm convincing) while learning haskell, so we can spam it :P
14:38:28 <Lethalman> didn't want to bother the lambdabot in this channel ;
14:38:39 <neutrino> you can spam this one in msg
14:38:42 <neutrino> i do it all day long
14:38:47 <Eiam> Cale: thanks
14:38:50 <Nereid> tell your friend to come to freenode. :p
14:38:55 <neutrino> but i guess you want to see each others' spam
14:38:57 <Eiam> neutrino, srhb thanks
14:39:00 <neutrino> makes sense
14:39:02 <neutrino> Eiam: yw
14:39:15 <Lethalman> neutrino, Nereid, right but in that channel there are other people that while seeing me and my friend spamming might get interested :P
14:39:19 <neutrino> Lethalman: bear in mind the lambdabot you have installed is a bit poorer
14:39:29 <srhb> Eiam: Welcome. Did it make sense? Otherwise shout. :-)
14:39:40 <neutrino> it will be missing some packages, definitions, etc
14:39:42 <Eiam> as much as I can comprehend
14:39:45 <neutrino> but in general it's still good
14:40:02 <neutrino> also i heard shapr was working on some interactive join-in haskell session thing
14:40:04 <srhb> Eiam: have some tests with Maybe and Either, it will be clearer.
14:40:15 <Lethalman> neutrino, yes, like (.) not being fmap ahah, but it's ok
14:40:20 <neutrino> where one guy can start a haskell session (ghci?) on a server and another girl can connect
14:40:24 <Lethalman> how can I make it join irc? can't see anything in the commands
14:40:33 <neutrino> no idea :\ sorry
14:40:43 <neutrino> i only use lamdabot locally for commands etc
14:41:04 <Nereid> you could take over a quieter channel that it's in
14:41:07 <neutrino> i have a vim plugin for it which lets me select a haskell code and run it through @pl
14:41:36 <Nereid> hm, #haskell-arcade is one. heh
14:41:41 <Nereid> sorry edwardk. :p
14:41:44 <Nereid> oh he's not here.
14:42:44 <sclv> byorgey: did you ever do a followup to themes on streams where you discussed Comonads for representable functors
14:42:45 <sclv> ?
14:44:37 <Lethalman> neutrino, ok managed to let it join irc ;)
14:50:13 * hackagebot GraphSCC 1.0.3 - Tarjan's algorithm for computing the strongly connected components of a graph.  http://hackage.haskell.org/package/GraphSCC-1.0.3 (IavorDiatchki)
14:54:04 <neutrino> @tell lethalman yay! have fun with lambdabot.
14:54:04 <lambdabot> Consider it noted.
14:58:42 <simpson> Hm. lens appears to not have a Plated equivalent of descendM... :c
14:59:15 <shachaf> I think we used to have that and took it out.
14:59:32 <shachaf> descendM = mapMOf plate
14:59:36 <shachaf> descendMOf = mapMOf
14:59:38 <simpson> So am I supposed to write my own Traversals if I would like to move through a data structure in a certain order?
15:01:54 <simpson> mapMOf plate appears to have the right type, and it should work. Now to replace my biplates...
15:02:15 <shachaf> simpson: Of course, if you're OK with Applicative instead of Monad, you don't even need mapMOf.
15:02:46 <Nereid> :t mapMOf
15:02:47 <lambdabot> LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
15:02:52 <Nereid> mhm
15:02:55 <simpson> shachaf: I'm still trying to migrate bit-by-bit and once I'm free of uniplate, I'll probably be simplifying my visitors even more.
15:03:09 <Nereid> :t plate
15:03:10 <lambdabot> (Applicative f, Plated a) => (a -> f a) -> a -> f a
15:04:06 <srhb> I like how the type variables spell out "STAB." It's what I want to do to my brain when I read that type.
15:04:11 <Nereid> :p
15:04:20 <simpson> shachaf: Also, yeah, at least one of these traversals requires State, so mapMOf is right.
15:04:35 <shachaf> simpson: State is a perfectly good Applicative.
15:04:47 <Nereid> any monad is.
15:04:50 <shachaf> (In fact every Monad is a perfectly good Applicative.)
15:04:59 <shachaf> (But sometimes you might not have the instance. But State does.)
15:05:08 <shachaf> simpson: Look at the type of plate.
15:05:19 <shachaf> srhb: You think *that's* bad?
15:05:37 <shachaf> ifindOf :: Profunctor q => Overloading (Indexed i) q (Accessor (Endo (Maybe a))) s t a b -> (i -> a -> Bool) -> q s (Maybe a)
15:05:38 <hpaste> MAD pasted “Fun with State and lens” at http://hpaste.org/80127
15:05:57 <shachaf> simpson: U MAD?
15:06:02 <simpson> shachaf: Yep.
15:06:25 <Taneb> takingWhile :: (RepresentableProfunctor p, Comonad (Rep p), Applicative f, Gettable f) => (a -> Bool) -> Overloading p (->) (Accessor (Endo (f s))) s s a a -> Overloading p (->) f s s a a
15:06:37 <srhb> shachaf: -_-
15:06:41 <franco00> what's the simplest way to play a .wav file in haskell (possibly portable. Possibly)?
15:07:00 <Nereid> @google haskell play wav file
15:07:01 <lambdabot> http://stackoverflow.com/questions/14005592/play-a-wav-file-with-haskell
15:07:01 <lambdabot> Title: audio - Play a wav file with Haskell - Stack Overflow
15:08:25 <Nereid> simpson: mapMOf = id
15:08:53 <shachaf> Sort of.
15:08:56 <franco00> meh, I did my homework, thanks
15:09:03 <Nereid> sure.
15:09:15 <Nereid> but it is, for any reasonable Monad.
15:09:21 <simpson> Nereid: Like I said, I'm just trying to get off of Uniplate first.
15:09:24 <Nereid> :p
15:10:45 <franco00> still, I wonder about portability
15:11:53 <franco00> as I had problems installing SDL on Win
15:28:18 <canta> how was that new ide called that was/is supposed to get released some day?
15:28:39 <|||tux||>  yeksah?
15:28:53 <|||tux||> leksah*
15:29:10 <shachaf> @google that new haskell ide
15:29:12 <lambdabot> http://leksah.org/
15:29:12 <lambdabot> Title: Leksah - Haskell IDE in Haskell
15:29:42 <|||tux||> > reverse "haskel"
15:29:44 <lambdabot>   "leksah"
15:29:48 <Lethalman> > sum [1..1000]
15:29:50 <lambdabot>   500500
15:29:50 <lambdabot> Lethalman: You have 1 new message. '/msg lambdabot @messages' to read it.
15:30:00 <Lethalman> this terminates on my local copy of lambdabot :-(
15:30:15 <|||tux||> > 1000*1001/2
15:30:17 <lambdabot>   500500.0
15:30:17 <Taneb> ...it terminates here as well
15:30:25 <Lethalman> Taneb, why is that?
15:30:31 <Taneb> Because it's finite?
15:30:31 <shachaf> You're stepping into a deep rabbit hole if you're trying to run a copy of lambdabot locally.
15:30:36 <shachaf> There is no help.
15:30:44 <Taneb> > 1000 * 1001 `div` 2
15:30:46 <Lethalman> Taneb, sorry, it says "Terminated" with no result :P
15:30:46 <lambdabot>   500500
15:30:50 <Lethalman> > sum [1..]
15:30:51 <shachaf> Taneb: Lethalman is being a big vague but I assume they mean "prints Terminated".
15:30:58 <Taneb> Okay
15:30:58 <lambdabot>   mueval: Prelude.undefined
15:30:58 <lambdabot>  mueval: ExitFailure 1
15:31:06 <Taneb> Listen to shachaf, Lethalman
15:31:21 <shachaf> Lethalman: Anyway, this is a great opportunity to develop your debugging skills.
15:31:28 <Lethalman> shachaf, :S
15:31:36 <shachaf> You'll need those debugging skills if you want any hope of getting lambdabot running.
15:31:47 <shachaf> Really. Just follow the "usual debugging procedure".
15:32:02 <Lethalman> which... is.. ?
15:32:06 <Nereid> what, insert trace everywhere?
15:32:08 <shachaf> Sometime I ought to write up an explanation of the "usual debugging procedure".
15:32:27 <Nereid> bang your head on the desk until it works?
15:32:30 <|||tux||> ghci ?
15:32:42 <Lethalman> or... is there any other lambdabot out there that I can let it join in another network? :P
15:33:04 <Nereid> you could take over #haskell-arcade which has been dead quiet forever
15:33:14 <Lethalman> :(
15:33:20 <Nereid> :p
15:33:22 <shachaf> There is no other lambdabot.
15:33:28 <shachaf> Don't take over #haskell-arcade
15:33:29 <shachaf> Not polite.
15:33:36 <shapr> why not?
15:33:40 <mstevens_> w
15:33:41 <Lethalman> even 1+2 says Terminated :P
15:34:03 <Lethalman> shachaf, the lambdabot here seems smarter (as I was told by neutrino :P)
15:34:38 <|||tux||> Maybe you need putStrLn $ show $ 3 + 4 ?
15:34:55 <shachaf> Lethalman: You can ask a proper lambdabot admin to join some other channel if you want.
15:34:58 <Lethalman> |||tux||, no :(
15:34:58 <shachaf> There are a bunch of them in here.
15:35:01 <simpson> Hm. Writing my own biplates is curious.
15:35:02 <Nereid> or that.
15:35:04 <shachaf> You can find a list in the lambdabot source.
15:35:07 <Nereid> as long as it's on freenode.
15:35:15 <Lethalman> Nereid, not freenode
15:35:16 <shachaf> Lethalman: However: I recommend the usual debugging procedure.
15:35:19 <shachaf> Find out what's failing.
15:35:27 <shachaf> "Terminated" isn't a very helpful message, but you have Tools.
15:35:57 <shachaf> Tool: The source code. You compiled lambdabot; presumably you can find the plugin that runs code, change it, and see what happens.
15:36:04 <Nereid> what's wrong with freenode?
15:36:04 <shachaf> But maybe you don't know Haskell well enough yet.
15:36:25 <Nereid> I think he got lambdabot from a debian package.
15:36:26 <Lethalman> shachaf, first I don't know haskell well enough, then I don't know the packaging system well enough, and then I have installed it from debian :P
15:36:36 <shachaf> OK then.
15:36:46 <shachaf> How about Instead of modifying it, just try to get the general gist of what it's doing.
15:36:51 <shachaf> Do you know how it's evaluating Haskell?
15:36:55 <shachaf> I think it runs an external program for it.
15:37:08 <Lethalman> probable
15:37:10 <shachaf> So a good step would be to try running that external program yourself, if it's installed.
15:37:18 <shachaf> If it's not installed, then you've figured out the problem!
15:37:40 <|||tux||> > sum [1..]
15:37:41 <Lethalman> right... let's strace:P
15:37:45 <lambdabot>   mueval-core: Time limit exceeded
15:37:46 <shachaf> (Also, installing lambdabot from a Debian package sounds like insanity to me. But that's mostly based on the limited experience I've actually had with lambdabot.)
15:37:52 <shachaf> Lethalman: strace was going to be my next suggestion.
15:37:56 <|||tux||> it uses mueval
15:38:00 <shachaf> It's pretty much the best UNIX program.
15:39:31 <Bobbduck> Quick question, I'm pretty new to haskell, if I do :t (==) . head, I get Eq b => [b] -> b Bool which I expected, but if I do: testFirst = (==) . head
15:39:32 <Lethalman> shachaf, mueval? :S
15:39:47 <Bobbduck> Then do :t testFirst, I get [()] -> () -> Bool, why does that happen?
15:40:01 <Nereid> Bobbduck: that's the monomorphism restriction.
15:40:10 <shachaf> strace
15:40:21 <shachaf> Bobbduck: Read this page:
15:40:22 <shachaf> @where dmr
15:40:22 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:40:27 <Bobbduck> Nereid: I'll do some reading, thanks
15:40:30 <Bobbduck> shachaf: checking it out now
15:40:36 <Nereid> easiest thing to do is to turn it off.
15:40:48 <Nereid> or you could give it an explicit type signature.
15:44:05 <simpson> Grar. This is head-hurting. Should I just write "normal" Lenses for my tree, instead of messing around with Plated and Traversable?
15:44:41 <shachaf> Plated, Traversable, and "normal" Lenses are three rather different things.
15:44:56 <shachaf> What are you trying to do?
15:45:29 <simpson> I have a type for an AST. I'd like to be able to express a handful of Uniplate-based transformations over the AST as things using lenses instead.
15:46:05 * simpson pastes
15:46:07 <shachaf> OK.
15:46:17 <shachaf> I think most Uniplate operations translate directly to operations that lens provides.
15:46:20 <hpaste> MAD pasted “AST! Yay?” at http://hpaste.org/80128
15:46:28 <simpson> Well, except for transformBi.
15:46:35 <Lethalman> shachaf, ok now the problem is the fact that lambdabot is so smart to pass +RTS -N2 -RTS and mueval says -N2 is too large
15:46:48 <shachaf> Lethalman: OK, so make it not pass that.
15:46:58 <Lethalman> shachaf, I don't know where's the configuration for that
15:47:18 <shachaf> simpson: I think it provides an equivalent of that too.
15:47:22 <shachaf> Lethalman: In the source code.
15:47:27 <Lethalman> eh
15:47:40 <shachaf> simpson: By the way, you can probably use Data.Data.Lens to write that whole Plated instance.
15:48:03 <shachaf> Or alternatively dispose with the Plated instance altogether. lens doesn't rely on instances the same way Uniplate does.
15:48:50 <simpson> shachaf: Well, I couldn't figure out how to obtain a Traversal that will traverse through all of the Durations in an Expression. Maybe I'm just not grokking it.
15:48:54 * Lethalman gives up, no time to mess with source code and recompilation
15:49:25 <shachaf> Lethalman: lambdabot is a project.
15:49:37 <shachaf> (An awful one.)
15:49:45 <dibblego> aw
15:50:02 <Nereid> is anyone working on a replacement?
15:50:05 <Bobbduck> Nereid, shachaf: Thanks, that helped
15:50:07 <Nereid> or successor
15:50:18 <shachaf> Nereid: You've been nominated.
15:50:28 <shachaf> (If you write Lambdabot 2.0 and it's good, Cale will switch to it.)
15:50:32 <Taneb> simpson, derive data/typeable instances, then just say "instance Plated Expression
15:50:33 <Taneb> "
15:50:34 <Nereid> (´・ω・｀)
15:50:38 <shachaf> simpson: OK, let's see.
15:50:51 <simpson> Taneb: It wasn't happy with me doing that before, but maybe I wasn't Doin' It Right.
15:51:09 <Taneb> Did you add a DeriveDataTypeable pragma?
15:51:20 <simpson> Yeah, I had one before. This *was* Uniplate'd.
15:52:09 <Taneb> You might need -XDefaultSignatures, but I'm not sure
15:52:17 <simpson> Okay, if I go back to the plain tree, and just ask for a Plated instance, I can get one.
15:53:06 <simpson> So how would I do the biplate-style traversal from that Plated instance?
15:53:25 <shachaf> simpson: Why don't you just use biplate, by the way?
15:53:31 <haroldk> Is it right that each time I write a function equation, it must have the same number of arguments? I thought it was best practice to avoid "foo x y = bar x y", and to write "foo = bar" instead, but if each version of a function must have the same number of arguments I can't do that can I?
15:53:39 <shachaf> (As in, lens's biplate.)
15:53:46 <shachaf> haroldk: It's right.
15:53:50 <shachaf> That's how it goes.
15:54:02 <simpson> shachaf: That was the plan and I wasn't sure why it wasn't working.
15:54:21 <haroldk> shachaf: so just a harmless limitation in the compiler that's exposed in the standard?
15:56:13 <shachaf> simpson: biplate :: Simpler Traversal Expression Duration
15:56:18 <shachaf> s/er/e/
15:56:29 <shachaf> (Given the appropriate Data and Typeable instances.)
15:56:49 <shachaf> haroldk: It's not really a limitation in the compiler.
15:56:55 <shachaf> The compiler is implementing the standard. :-)
15:57:00 <franco00>  /leave
15:57:04 <franco00> woops
15:57:20 <shachaf> If you figured out the appropriate semantics for it I doubt the GHC people would have a very hard time implementing it.
15:58:04 <shachaf> simpson: "wasn't working" isn't an error message I've ever gotten from GHC. :-)
15:58:13 <shachaf> I can't really help you without knowing what's going on.
16:00:37 <simpson> shachaf: Sorry. I'm just trying to figure out this one last visitor, and it's being a real pain.
16:02:04 <simpson> biplate is getting me Applicative f => (Duration -> f Duration) -> Expression -> f Expression -- but I can't quite get that to work with transformOf.
16:02:43 <shachaf> @ty transformOf
16:02:44 <lambdabot> SimpleSetting a a -> (a -> a) -> a -> a
16:02:57 <shachaf> That's not for biplatey operations. You can see that because it uses the same type everywhere.
16:03:21 <simpson> Right. So I gotta find something that'll let me work with that "inner" type.
16:03:39 <simpson> Oh, maybe transformOn.
16:04:11 <`nand`> shachaf: would it just work to have the compiler automatically eta-expand definition with fewer arguments than the definition with the most arguments?
16:04:22 <`nand`> definitions*
16:04:46 <shachaf> simpson: What are you actually trying to do?
16:04:50 <simpson> Aha! transformOn biplate did it.
16:04:53 <cmccann> `nand`, I would worry about that negatively impacting predictable sharing
16:04:59 <shachaf> simpson: I suspect transformOn isn't what you want.
16:05:04 <simpson> shachaf: Just trying to replace transformBi.
16:05:07 <`nand`> eg. “let foo 1 2 3 = bar; foo a = bat a” -> “let foo 1 2 3 = bar; foo a b c = bat a b c”
16:05:24 <`nand`> cmccann: I see it as a sugar-level syntax transformation
16:05:25 <shachaf> simpson: I don't know the uniplate vocabulary at all.
16:05:48 <shachaf> So describing things to me in terms of Uniplate operations doesn't help. :-)
16:05:50 <`nand`> it would type-check and compile as if you had written “foo a b c = bat a b c” in the first place
16:05:52 <johnw>  /znc *status unloadmod away
16:05:54 <cmccann> `nand`, my understanding is that eta expansion can change performance significantly
16:05:55 <johnw>  /znc *status unloadmod awaystore
16:06:08 <shachaf> Anyway, if it works, then OK.
16:06:14 <`nand`> cmccann: right, but in this case you'd have to eta expand manually one way or the other
16:06:19 <shachaf> But note that now you're using your Plated instance *and* biplate.
16:06:23 <shachaf> Which maybe isn't right?
16:06:30 <simpson> shachaf: Well, this is the biplate from Data.Data.Lens.
16:06:42 <shachaf> simpson: What are you trying to accomplish?
16:06:44 <shapr> johnw: I don't think that worked.
16:06:52 <johnw> oops :)
16:06:54 <cmccann> `nand`, yes, but it makes things change implicitly. that said, there are similar justifications for the monomorphism restriction
16:06:56 <shachaf> Can you say that at a high level without any Uniplate names? :-)
16:06:56 <simpson> shachaf: Trying to transform all Durations within a certain Expression.
16:07:04 <johnw> shapr: thanks, I was really wondering
16:07:04 <shachaf> "transform" meaning what?
16:07:37 <simpson> Take one of the values from the Expression, apply it to all the Durations (multiplying some numbers in them), and changing the top Expression to not have that value anymore.
16:07:59 <cmccann> `nand`, not saying it wouldn't work or shouldn't happen, just that I can see why it's not already done
16:08:00 <simpson> I just tested it, and it is working just like before, so I'm satisfied.
16:08:15 <shachaf> Hmm, I'm not sure I follow.
16:08:27 <`nand`> cmccann: fair enough
16:08:29 <shachaf> simpson: Does "over biplate yourfunction ast" work?
16:09:17 <haroldk> My program is spending 12% of its time calling fromIntegral to convert a Word8 to a Double - is there something I don't know about converting Word8 to Double?
16:09:39 <hpaste> MAD pasted “From uniplate to lens” at http://hpaste.org/80129
16:09:47 <simon> I find that I often want to foldr f (head xs) (tail xs), knowing that xs is non-empty. is there a variant of fold that assumes f :: a -> a -> a and that xs is non-empty?
16:09:58 <`nand`> simon: foldr1
16:10:05 <simon> `nand`, thanks.
16:10:12 <shachaf> simpson: Does it?
16:10:22 <srhb> simon: Equivalent variants for the other folds, too. :)
16:10:23 <shachaf> simon: You can find functions like that with Hoogle, by the way. :-)
16:10:33 <shachaf> @hoogle (a -> a -> a) -> [a] -> a
16:10:33 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
16:10:33 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
16:10:33 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
16:10:45 <NougatRillettes> hey i've got some weir issue :
16:10:58 <simon> shachaf, thanks :) yeah, the fact that I'm looking should suggest that I should go to bed.
16:11:01 <NougatRillettes> if I set DAtaKinds in my pragma, it won't be taken in account by ghci
16:11:08 <simon> s/looking/not looking/
16:11:09 <shachaf> NougatRillettes: Correct.
16:11:11 <cmccann> :set -XDataKinds
16:11:19 <simpson> shac
16:11:22 <NougatRillettes> yes I know this workaround
16:11:25 <NougatRillettes> but why ?
16:11:31 <shachaf> That's how it is.
16:11:33 <cmccann> you can also put that in a .ghci file if you want.
16:11:37 <simpson> shachaf: Yes, it works.
16:11:44 * simon adds some partial functions to his project
16:11:50 <NougatRillettes> shachaf: that's no answer
16:11:56 <simpson> shachaf: So "over" and "transformOn" are equivalent here, I guess?
16:11:56 <shachaf> simpson: OK. Then all you wanted to do was apply a function to every Duration in your structure?
16:12:03 <simpson> shachaf: Right.
16:12:11 <shachaf> So why didn't you say that? :-)
16:12:15 <shachaf> simpson: No, they're not really equivalent.
16:12:25 <cmccann> NougatRillettes, it's how GHCi works, there may not be any better explanation.
16:12:28 <simpson> I didn't know that that's what I wanted! It's hard to stop thinking in uniplate terms.
16:12:38 <shachaf> "over" is the lensy way of saying the thing you want to say, anyway.
16:12:45 <NougatRillettes> yes but why why DataKinds and not other pragma ?
16:12:56 <cmccann> it's the same for all pragmas.
16:12:56 <shachaf> > over (traverse._1) (*10) [(1,2),(3,4),(5,6)]
16:12:57 <NougatRillettes> or did I missed the fact that it is with other pragmas too
16:12:59 <`nand`> you can think of ‘over’ like a generalized ‘fmap’
16:13:00 <lambdabot>   [(10,2),(30,4),(50,6)]
16:13:01 <NougatRillettes> ah ok
16:13:05 <cmccann> just that some seem to behave differently
16:13:14 <NougatRillettes> thanks :)
16:13:26 <cmccann> depending on what context GHC is looking at when stuff is done &c.
16:13:30 <simpson> shachaf: I see. Now I know! I expect that other parts of this code will get simpler too, as I do more lens.
16:13:53 <cmccann> NougatRillettes, trust me, it can be very confusing if GHCi and the loaded module have different settings for stuff like NoImplicitPrelude
16:13:58 <shachaf> simpson: You could also derive this from, say, mapMOf
16:14:26 <shachaf> > runIdentity $ mapMOf (traverse._1) (\x -> Identity (x*10)) [(1,2),(3,4),(5,6)]
16:14:28 <lambdabot>   [(10,2),(30,4),(50,6)]
16:14:34 <simpson> shachaf: Mm. The next step is dealing with the gnarly State stuff; I had to have a manual descent in order to go through the AST in the right order.
16:14:57 <simpson> shachaf: Anyway, thank you so much for your help!
16:18:28 <mreh> uhh, anyone know of any resources on alsa-pcm? It comes with no documentation
16:18:44 <mreh> true to form Henning Thielmann :)
16:19:20 <mreh> otherwise I'll sit and read the source! At least I learn about extensible exceptions
16:22:11 <fmap> hmm, alsa-pcm is very strange package. where are all those Cs and Ts?
16:22:36 <shachaf> fmap: Welcome to Henningskell.
16:22:58 <simon> srhb, I'm writing a compiler for a reversible HDL as my bachelor's project :)
16:23:10 <mreh> fmap: T_T
16:23:20 <srhb> simon: In my world HDL is high density lipoprotein, please elaborate :P
16:23:32 <simon> srhb, for me it's Hardware Description Language.
16:23:41 <srhb> simon: Ah, of course. *facepalm* It's late for me, too :P
16:23:54 <simon> I said I'd go to bed an hour ago.
16:24:05 <simon> "I just have to fix all these type errors..."
16:24:11 <fmap> oh, it has 2 Ts actually
16:24:14 <srhb> ;)
16:25:20 <mreh> fmap: he usually puts a single T and or C in a module, which he then references using a qualified name, but haddock doesn't, so it looks incomprehensible
16:25:58 <mreh> that T could be from anywhere, so you have to hover over it to find out
16:26:35 <mreh> didn't someone talk about writing a Henningskell translator?
16:27:39 <Rembane> simon: Reversible HDL? You take silicon and get code?
16:33:40 <fragamus> I love <$>
16:33:55 <shapr> I love ($)
16:34:56 <shachaf> i love monoids
16:35:01 <nathanfh> I love (.) and (<=<)
16:35:14 <c_wraith> (<=<) is one of the best operators
16:35:38 <mreh> :t (<=<)
16:35:39 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
16:35:46 <mreh> I keep forgetting about that one
16:36:48 <simon> Rembane, as in a HDL that describes circuits that compute only injective functions.
16:37:03 <Rembane> simon: What is an injective fnction?
16:37:12 <Nereid> so an HDL for reversible circuits.
16:37:37 <simon> yes! :)
16:37:48 <Nereid> that makes more sense.
16:42:11 <simon> Rembane, http://en.wikipedia.org/wiki/Injective_function
16:42:14 <Transhumanist> On that note, quantum circuits are reversible circuits
16:42:17 <`nand`> Rembane: a function being injective means that if f(x) = f(y); then x = y
16:42:32 <`nand`> formulated differently, different inputs must have different outputs
16:43:02 <Rembane> `nand`: Sweet! :)
16:43:03 <c_wraith> so const () is the least-injective function function ever
16:43:05 <simon> (which makes it possible to take an output and map it to a distinct input and get a circuit that performs the inverse computation)
16:43:11 <Rembane> simon: Thank you
16:43:17 <shachaf> c_wraith: const ⊥
16:45:37 <`nand`> simon: (I don't know about the context) for it to be (totally) reversible, doesn't it have to be surjective as well?
16:52:27 <shapr> Can anyone recommend a good twitter client in Haskell?
16:52:33 <shapr> Or at least, a twitter client library?
16:52:38 <shapr> I want to write my own wapper.
16:52:58 <simon> `nand`, yes.
16:53:00 <lightquake> askitter?
16:53:29 <lightquake> doesn't seem to be on hackage though :/
16:53:50 <shapr> lightquake: https://github.com/killerswan/askitter/ ?
16:53:54 <lightquake> i wrote that a while ago then handed it off to killerswan; i'm not sure if any of the other ones work
16:53:55 <lightquake> yeah
16:54:06 <shapr> All the other libs I find are pretty old.
16:54:10 <simon> `nand`, I think the distinction is "both forward and backward deterministic", although I don't know exactly what it means.
16:54:22 <lightquake> yeah, and twitter's API changed
16:55:17 <shapr> lightquake: Ok, lemme see if it builds on my Raspberry Pi
16:55:39 <simon> `nand`, and yes, my target language consists of various reversible gates that are bijective.
16:55:58 * shapr git clones
16:56:35 <lightquake> maybe i should poke killerswan into uploading it to hackage?
16:56:56 <shapr> Oh, it doesn't do direct messages? :-(
16:58:15 <shapr> _Vi: Are you vi hart?
16:58:46 <_Vi> shapr, No. What is the "hart"?
16:59:00 <Nereid> my understanding was that reversible computation had to be bijective.
16:59:16 <Nereid> because you want the reverse to also be injective.
16:59:18 <shapr> _Vi: There's a person "Vi Hart" who makes nifty math videos on YouTube
17:01:25 <Adnauseam> <3 vihart
17:04:06 <epta> @hoogle Either a b -> Maybe b
17:04:06 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
17:04:06 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
17:04:06 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
17:04:51 <quchen> I just noticed that genericLength is implemented as "1 + length rest", which is not tail recursive. Why is that? The pattern with the worker wrapper done by the normal length function would also work for Integrals.
17:04:51 <lambdabot> quchen: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:05:03 <quchen> Is there a good reason it's written this way?
17:05:20 * hackagebot maxent 0.1.0.1 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.1.0.1 (JonathanFischoff)
17:07:01 <shapr> quchen: What could possibly be a good reason to do that?
17:08:02 <quchen> Less stack space?
17:09:14 <Nereid> @src genericLength
17:09:14 <lambdabot> genericLength []    = 0
17:09:14 <lambdabot> genericLength (_:l) = 1 + genericLength l
17:09:23 <c_wraith> It makes it possible for it to be lazy, if + is lazy enough
17:09:28 <shapr> oh, that's a point
17:09:40 <quchen> let gLength = gLength' 0; gLength' l [] = l; gLength' l (x:xs) = gLength' (l `seq` l+1) xs
17:09:51 <shapr> Is genericLength used for "atLeast n" code somewhere?
17:10:02 <`nand`> what about ‘fromIntegral . length’ ?
17:10:14 <Nereid> `nand`: doesn't work with lazy naturals, say
17:10:20 <`nand`> ah
17:10:25 <quchen> `nand`: That only fixes the type. For long lists you're overflowing.
17:11:00 <`nand`> quchen: not that breaking the Int32 limit is a practical concern for lists
17:11:17 <shapr> I know Richard Braakmann had some nifty code that only check that a list was at least N in length, thus making infinite lazy lists usable.
17:11:44 <shapr> lightquake: Yes, you should totally poke killerswan to upload a hackage for askitter!
17:11:54 <quchen> `nand`: Why? Implementation-wise, i.e. how GHC produces the linked list?
17:12:52 <Nereid> > foldr (\a n -> n+1) 0 [1..10]
17:12:53 <lambdabot>   10
17:12:57 <Nereid> > foldl' (\n a -> n+1) 0 [1..10]
17:12:59 <lambdabot>   10
17:14:27 <Nereid> ok, let's use [()] for lazy naturals.
17:14:38 <Nereid> > foldr (\n a -> ():n) [] [1..10]
17:14:39 <lambdabot>   No instance for (GHC.Enum.Enum [()])
17:14:39 <lambdabot>    arising from the arithmetic sequenc...
17:14:44 <Nereid> > foldr (\a n -> ():n) [] [1..10]
17:14:46 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
17:14:49 <Nereid> > foldr (\a n -> ():n) [] [1..]
17:14:50 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:14:56 <Nereid> > foldl' (\n a -> ():n) [] [1..10]
17:14:58 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
17:14:59 <Nereid> > foldl' (\n a -> ():n) [] [1..]
17:15:03 <lambdabot>   mueval-core: Time limit exceeded
17:15:08 <Nereid> > foldl (\n a -> ():n) [] [1..]
17:15:12 <lambdabot>   mueval-core: Time limit exceeded
17:17:49 <quchen> I also don't understand why the worker-wrapped version isn't lazy.
17:18:02 <quchen> let gLength = gLength' 0; gLength' l [] = l; gLength' l (x:xs) = gLength' (l `seq` l+1) xs
17:18:21 <quchen> Looks lazy enough to me.
17:18:27 <Nereid> seq is quite not lazy.
17:18:34 <DrChaos[S]> Hello, I defined this intersperse' function that should do the same as Data.List.intersperse. But, I can't seem to get it to work
17:18:37 <quchen> Well, that's the "l" parameter, not the list.
17:18:40 <Nereid> also, even withou seq, it also has to traverse the entire list before producing anything
17:18:55 <srhb> DrChaos[S]: Paste it to hpaste.org and tell us what the problem is
17:18:58 <quchen> Nereid: But in the "1+rest" implementation that's the same.
17:19:02 <Nereid> not true.
17:19:06 <Nereid> (+) may be lazy.
17:19:14 <quchen> It builds up 1+(1+(1+(1+...
17:19:23 <monochrom> ah, (+) is a class method of Num, you can program it to do whatever you want
17:19:33 <Nereid> let's say I wrote a Num instance for [()], where 1 = [()] and (+) = (++)
17:19:43 <quchen> OK
17:19:49 <Nereid> then it would build up [()] ++ ([()] ++ ...
17:20:02 <Nereid> you don't have to look very far to notice that it's a nonempty list
17:21:06 <Nereid> so genericLength (infinite list) would produce stuff right away.
17:21:12 <Nereid> which is exactly what this does:
17:21:30 <Nereid> > let g [] = []; g (_:xs) = [()] ++ g xs in g [1..]
17:21:33 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:22:08 <DrChaos[S]> OK guys, here's the broken intersperse function and the error text: http://vpaste.net/EqsJ9
17:23:01 <monochrom> your file has really grown
17:23:29 <DrChaos[S]> yes, it has
17:23:31 <Eduard_Munteanu> What package/module provides accurate wall clock times nowadays?
17:23:50 <monochrom> is getCurrentTime accurate enough?
17:24:17 <quchen> Nereid: Ah, OK.
17:24:36 <quchen> Now on the other hand: why would this be useful in a practical setting?
17:24:44 <Nereid> I don't know. :)
17:24:52 <quchen> Grrr
17:24:53 <Eduard_Munteanu> monochrom: picosecond resolution? Looks good.
17:25:12 <quchen> It's basically building a large (++) thunk compared to a tail recursive uhmmm thunk
17:27:44 <monochrom> tail recursion does not matter
17:27:48 <Nereid> Eduard_Munteanu: on unix, getCurrentTime is implemented with gettimeofday, which gives no better than microsecond resolution, and is still up to the OS.
17:28:12 <quchen> monochrom: Why would that be?
17:28:15 <Eduard_Munteanu> Yeah, sure.
17:28:23 <Eduard_Munteanu> Microsecond resolution is good.
17:28:31 <Nereid> on Windows, it uses GetSystemTimeAsFileTime which goes down to 100ns
17:28:36 <monochrom> large thunk does or does not matter depending on the laziness of the operators involved
17:29:25 <Nereid> the g above is better written as map (const ()), heh.
17:29:32 <Nereid> :t foldr ((:) . const ()) []
17:29:34 <lambdabot> [a] -> [()]
17:30:11 <quchen> monochrom: Could you elaborate a bit on that? Right now, I'm pretty much always trying to write everything tail recursive if it builds a huge thunk otherwise.
17:30:21 * hackagebot profunctors 3.1.2 - Haskell 98 Profunctors  http://hackage.haskell.org/package/profunctors-3.1.2 (EdwardKmett)
17:30:40 <Nereid> but apparently GetSystemTimeAsFileTime realistically only gives ~millisecond precision.
17:30:55 <mm_freak_> > (\c->init.foldr(\x->(x:).(c:))[]) 'x' "abc"
17:30:57 <lambdabot>   "axbxc"
17:31:11 <Nereid> > (\c->init.foldr(\x->(x:).(c:))[]) 'x' ""
17:31:13 <lambdabot>   "*Exception: Prelude.init: empty list
17:31:29 <monochrom> perhaps see my http://www.vex.net/~trebla/haskell/lazy.xhtml
17:32:31 <mm_freak_> > (\c->drop 1.foldr(\x->(:)c.(:)x)[]) 'x' "abc"
17:32:33 <lambdabot>   "axbxc"
17:33:08 <mm_freak_> > (\c->drop 1.foldr(((:)c.).(:))[]) 'x' "abc"
17:33:09 <lambdabot>   "axbxc"
17:33:27 <mm_freak_> at some point that's going to get shorter than actually writing "intersperse 'x'" =)
17:33:59 <monochrom> actually, "[()] ++ genericLength whatever" is clearly a small thunk
17:34:18 <monochrom> then you say, "but genericLength whatever will keep expanding"
17:34:44 <monochrom> ah, but depending on the outer context, it does not have to. this is haskell, not sml
17:36:22 <SmurfsYo> How many combinations of 8 items up to a length of 10 are there if repetitions are allowed?
17:36:36 <Sintendo> I've got a Maybe (e,[n]), is there a convenient way to strip this to Maybe [n]?
17:36:57 <quchen> Sintendo: fmap snd
17:37:15 <Sintendo> Oh right, thanks! :)
17:37:35 <mauke> > 8 ^ 10
17:37:37 <lambdabot>   1073741824
17:37:42 <SmurfsYo> Thanks.
17:37:48 <mauke> > sum [8 ^ n | n <- [0 .. 10]]
17:37:50 <lambdabot>   1227133513
17:37:50 <quchen> Not really.
17:37:55 <quchen> Yea, what mauke said
17:38:08 <quchen> (in second instance)
17:38:23 <SmurfsYo> Is that in answer to my question?
17:38:36 * shapr contacts the maintainer of HaskellNet asking for either an update or permission to NMU it
17:39:11 <quchen> Yes.
17:39:48 <monochrom> strange question. I wonder if we will get a calculus question next
17:39:54 <SmurfsYo> Ok thanks.
17:40:00 <shapr> Who's facundo on patch-tag.com? Does that person show up here on #haskell?
17:41:26 * shapr contacts the imapget maintainer, asking for an update or NMU permission
17:41:49 <mm_freak_> SmurfsYo: depending on what you mean by "combinations" the answer is either 1073741824 or 0
17:41:56 <shapr> Is there a way to ask Hackage for a list of packages that do not currently build? Would be neat to wander through and fix things.
17:42:08 <mm_freak_> oh, up to
17:42:18 <Nereid> repetitions allowed too
17:42:30 <mm_freak_> ok, then mauke gave the answer
17:43:43 <mm_freak_> > (sum . map (8^)) [0..10]
17:43:44 <lambdabot>   1227133513
17:44:59 <SmurfsYo> Yeh repitions are allowed.
17:46:22 <Nereid> > (1 - 8^11) `div` (1 - 8)
17:46:24 <lambdabot>   1227133513
17:46:28 <edwardk> @tell simpson it'll probably take a ~3 weeks to get trifecta 0.90 out the door. i need to fix the layout parser
17:46:28 <lambdabot> Consider it noted.
17:47:31 <simpson> edwardk: Alrighty, thanks.
17:47:31 <lambdabot> simpson: You have 1 new message. '/msg lambdabot @messages' to read it.
17:47:58 <simpson> edwardk: No rush, as long as you didn't decide to go in a different direction.
17:48:36 <edwardk> heh. writing a couple of signatures for isomorphisms into profunctor-extras, since isomorphisms are defined using profunctors, it leads to ever so clear signatures like:
17:48:37 <edwardk> idl :: (Profunctor p, Profunctor q, Profunctor r, Functor f) => p (q d c) (f (r d' c')) -> p (Procompose (->) q d c) (f (Procompose (->) r d' c'))
17:48:54 <Nereid> oh god
17:49:02 <edwardk> -- @'idl' :: ('Profunctor' q, 'Profunctor' r) => 'Iso' ('Procompose' (->) q d c) ('Procompose' (->) r d' c') (q d c) (q d' c')@
17:49:26 <edwardk> thats an isomorphism between q d c   <-> Procompose (->) q d c       in family form
17:49:39 <shapr> crap :-( Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure.
17:49:43 <edwardk> showing that (->) is a lax identity for profunctor composition
17:52:56 <shapr> yay! it built and registered anyway!
17:52:59 * shapr bops cheerfully
17:58:12 <shapr> Ok! Next task is to somehow scrape data out of google calendar and fire off a notification at about the right time. Does anyone have suggestions for how to do that in Haskell?
18:00:47 <c_wraith> I'd try the internet
18:01:22 <shapr> c_wraith: ooh good idea! Got anything more specific?
18:01:33 <c_wraith> maybe http?
18:01:41 <c_wraith> I've heard it's good for things like that.
18:02:03 <c_wraith> (But not the HTTP package.  No, not that.)
18:03:09 <stepkut> shapr: there is a google calendar API..
18:04:33 <shapr> stepkut: private calendar urls seem like the easiest/simplest approach, then parse ics or gcal's custom xml
18:05:12 <shapr> but the gcal API would be way more awesome
18:06:33 <shapr> aha http://hackage.haskell.org/package/iCalendar
18:06:55 <shapr> I love it when someone else already wrote the code for me.
18:08:21 <shapr> lispy: So it looks like I'll be covering twitter, email, google voice texts and google calendar events. What smartphone services do you think I'm missing?
18:15:42 <lispy> shapr: maybe utility things like note taking/list making?
18:16:11 <lispy> also, password vault
18:17:40 <shapr> lispy: I'll add those to the feature list, thanks
18:18:41 <shapr> Geez, building Haskell libs on the Pi is INCREDIBLY SLOW.
18:19:01 <lispy> shapr: there are a number of other "nice to have" things that involve the internet. transit apps, reddit apps, etc
18:19:16 <lispy> shapr: yeah, it really is. even hello world took a long time to build
18:19:41 <lispy> shapr: I borrowed a pi from a friend long enough to install ghc and find out that ghci doesn't run there
18:20:04 <startling> shapr: building libraries on my four-year-old macbook is incredibly slow. >:(
18:20:11 <lispy> shapr: can you do all your development testing on a VM with occasional testing on the pi?
18:20:12 <startling> fwiw I think it's mostly a memory issue
18:20:16 <shapr> I've found various improvements, but I'm soliciting donations for either a 512MB RAM Raspberry Pi ($40), or one of those Freescale i.MX53 quickstart boards with 1GB of RAM ($150).
18:20:23 <startling> lispy: why doesn't ghci work?
18:20:25 * hackagebot webserver 0.5.1.0 - HTTP server library  http://hackage.haskell.org/package/webserver-0.5.1.0 (JohnLato)
18:20:31 <shapr> startling: no second stage ghc
18:20:35 <lispy> startling: yeah, I find that with <= 1GB of ram, ghc is just dog slow
18:20:38 <kfish> w00t, new webserver!
18:20:47 <startling> shapr: what?
18:20:47 <shapr> I think that's because it's not registerized? I'm not exactly sure.
18:21:01 <startling> is this for ARM in general?
18:21:02 <shapr> startling: no ghci and thus no Template Haskell
18:21:04 <lispy> startling: perhaps because gnu ld doesn't deal well with split-objs (reason for memory usage)
18:21:24 <startling> lispy: yeah. linking is a huge portion of the time for me too
18:21:26 <shapr> startling: I'm not sure, I thought ghcarm.something said they did have a registerized ARM version
18:21:40 <startling> (even with the supposedly-better os x ld)
18:21:42 <shapr> lispy: ah, but you beat some of that with http://labs.scrive.com/2011/08/running-ghc-on-low-memory-computers/
18:21:46 <startling> shapr: huh, weird.
18:22:30 <Philippa_> shapr: you might want to put the Samsung A15/2GB board on the possibilities list? Though a chromebook with the same setup is actually cheaper
18:22:35 <startling> shapr: oh, looks cool
18:22:36 <shapr> ah the guy who does http://ghcarm.wordpress.com/ already has one of the i.MX53 boards!
18:22:56 <Philippa_> (I'm on one of those chromebooks right now)
18:23:16 <startling> Philippa_: how does it work for development?
18:23:25 <shapr> Any idea who does ghcarm.wordpress.com? I'd like to contact this person.
18:24:00 <Philippa_> startling: Slightly better than the netbooks I've owned, I guess. Would be nice to have GHCi though
18:24:09 <shapr> startling: Yes, GHC 7.4.1 is registerized on ARM/Linux: http://ghcarm.wordpress.com/2011/12/24/ghc-7-4-1-release-candidate-1-is-out/
18:24:41 <bgamari> shapr, I did the work on GHC's runtime linker for ARM
18:24:53 <shapr> bgamari: ooh, tell me more!
18:25:10 <bgamari> shapr, It is fully functional using the LLVM backend
18:25:35 <bgamari> shapr, The runtime linker was the last impediment to full support (including GHCi and TH)
18:26:05 <bgamari> shapr, Unfortunately, things seem to have broken since I did my work
18:26:08 <shapr> oh no :-(
18:26:23 <bgamari> HEAD didn't finish compiling last I saw
18:26:29 <shapr> So what needs to be done to fix it? I'd really like to have GHCi and TH on my Raspberry Pi!
18:26:49 <bgamari> shapr, that is a good question
18:27:11 <Philippa_> Heck, what needs to be done to get it supported in the next release?
18:27:11 <cheetah2> why is haskell so poplar?
18:27:25 * bgamari periodically git pulls and attempts a build on his Pandaboard, but something else always comes up before I think to check on the result
18:27:52 <Skillsob> cheetah2, because it's pure fun.
18:27:54 <shapr> cheetah2: Because lots of people like it.
18:27:56 <bgamari> cheetah2, Because it is a nice language
18:28:08 <Philippa_> because we can all say we were using it before the hipsters got to it :p
18:28:11 <bgamari> Philippa_, functionally, evernything is in place
18:28:30 <bgamari> Philippa_, All that remains is fixing bugs which may or may not exist
18:28:35 <Philippa_> bgamari: Cool. I'm guessing that wasn't the case for 7.6.1?
18:28:39 <shapr> bgamari: Is there some way I can contact you via email? I really want to get full ghci and TH on my Raspberry Pi!
18:29:07 <Philippa_> (I hear it's working somewhere in debian/armhf, but I'm using a hacked-up Ubuntu setup and if it's not in the LTS repos I'd rather build from source)
18:29:12 <bgamari> Philippa_, Things might have been working
18:29:21 <Philippa_> hrmm, how long do builds take on the pandaboard anyway?
18:29:22 <nyc> Got my phone back from the police. Battery was pulled, unclear if any other pieces are missing. The thing appears bricked.
18:29:24 <bgamari> Philippa_, about a day
18:29:43 <Philippa_> mmm. So maaaybe half a day if I'm lucky on this thing, except there'll be a lot more contention for RAM
18:29:57 <bgamari> Philippa_, The first release with my work was 7.4.2
18:30:08 <bgamari> Philippa_, LLVM is pretty rough to build
18:30:09 <lispy> shapr: if you tell ghc not to link who does the linking?
18:30:15 <Philippa_> cool, I should see what I can get out of 7.6.1 then
18:30:38 <shapr> lispy: You can separate the linking, then GHC doesn't use as much RAM
18:30:57 <lispy> shapr: ah, I get it
18:31:18 <lispy> shapr: BTW, if you build ghc with split-obj: False (in config.mk) then you get MUCH better ld performance
18:31:34 <Philippa_> bgamari: ah. Any advice there? I'm not used to compiling stuff I didn't either write or cabal install
18:31:42 <lispy> shapr: doing my trick to not split-objs and also using -c I bet you could get the memory usage down to something very small
18:31:51 <Philippa_> (I mean, I can do the basics if everything's working fine...)
18:32:09 <lispy> shapr: (and then you wouldn't have to disable optimizations)
18:32:23 <lispy> shapr: the gold linker may be of some value here as well
18:32:40 <hpaste> scooty-puff pasted “Alternative data structures” at http://hpaste.org/80134
18:32:40 <lispy> shapr: the linking thing bothers me enough that I keep thinking I should look into fixing gnu ld
18:33:21 <shapr> lispy: jmcarthur suggested that same trick, but that would require enough ARM resources to rebuild GHC, right?
18:33:22 <scooty-puff> i am having trouble telling which of the set of data structures is more compact in the previous hpaste
18:34:08 <shapr> I just want GHC working nicely on my Raspberry Pi with GHCi and TH. If that requires LLVM or gold, I'm okay with that.
18:34:12 <bgamari> Philippa_, GHC is pretty easy to build thankfully
18:34:54 <shapr> bgamari: so are you the person who writes ghcarm.wordpress.com?
18:35:01 <bgamari> Philippa_, You could start by looking at http://hackage.haskell.org/trac/ghc/wiki/Building/QuickStart
18:35:19 <bgamari> shapr, Nope, that's Gabor Greif IIRC
18:35:23 <shapr> ah, good to know
18:35:31 <bgamari> shapr, I'm not sure he's around anymore
18:35:38 <shapr> Did he disapear?
18:35:49 <shapr> Ah, heisenbug?
18:39:19 <bgamari> shapr, just haven't heard from/of him recently
18:40:03 <lispy> shapr: yes, but you could (in theory) build ghc on a qemu arm vm
18:40:13 <lispy> shapr: using as much desktop resources as you need
18:40:30 <shapr> Yah, that sort of failed recently...
18:40:40 <lispy> do you know why?
18:40:52 <shapr> patches wouldn't apply correctly: https://github.com/Torlus/qemu-rpi
18:41:37 <shapr> lispy: I'll try it again soon, I hope
18:41:50 <lispy> ah
18:41:52 <shapr> I'm in a hurry with this project because classes start again in seven days, and I doubt I'll have any time after that.
18:42:20 <shapr> and a qemu vm seems like a rabbit hole, even though I know it would be a good tooling setup step.
18:42:43 <lispy> it's too bad we don't have a ghc-lite
18:43:10 <lispy> haskell was invented on machines less powerful than the pi
18:43:29 <Philippa_> shapr: if I get it working on my chromebook, I might see about leaving the pi I've been loaned running a build
18:43:32 <shapr> I'm taking cal 1 and assembly, and the assembly instructor is notorious for giving way more homework than anyone has time to do...
18:43:36 <bgamari> shapr, memory is really the only issue
18:43:37 <lispy> I do sometimes wish ghc had the option that jhc has to translate to ansi C
18:43:42 <bgamari> CPU time is just a matter of waiting
18:43:48 <shapr> bgamari: True that
18:43:52 <bgamari> but once you start thrashing...
18:44:18 <Philippa_> mmm. Well, at least a pi's going to be using something with a comparatively fast seek time for swap
18:44:25 <Philippa_> (use a dedicated USB stick for the job?)
18:44:28 <shapr> So I need to contact Gabor and see if he will install Raspbian on his i.MX53 board.
18:44:41 <lispy> Given the libraries we have these days, I wonder how hard it would be to take haskell-src-exts + uniplate + language.c and build a translation to C
18:44:42 <Philippa_> (definitely don't use the same device that's doing all your other storage duties for it!)
18:44:58 <lispy> (obviously the RTS is still not easy to develop)
18:45:23 <Philippa_> point, the pi in front of me's a 256MB machine
18:45:29 * bgamari fires up another GHC build
18:45:32 <Philippa_> still, it's shut down most of the time, hence the offer
18:45:40 <shapr> Nowadays they only sell 512MB Raspberry Pi models.
18:45:46 <Philippa_> yeah, I know
18:45:59 <shapr> I wish I could get hold of one, I suspect it would make this project easier.
18:46:09 <lispy> yeah, 512mb would be enough
18:46:14 <lispy> that's close to what my linode has
18:46:26 <lispy> actually, I think it may be more
18:46:48 <lispy> oh, it's the same. But I built ghc from scratch on my linode
18:46:59 <bgamari> ahh, seems like ghc 7.6 finished on my pandaboard last time
18:47:02 <shapr> So it could be done with 512MB, that's good to know.
18:47:09 <shapr> bgamari: Yay! That's good to hear!
18:47:25 <lispy> shapr: at least on x86 with a registered build. I don't know how any of that changes memory usage.
18:47:37 <bgamari> and ghci starts
18:48:00 * shapr cheers
18:48:27 <shapr> lispy: I have no idea how armv6 memory usage would compare to x86 memory usage when building ghc
18:49:06 <shapr> bgamari: Would your binaries work for Raspbian? or would I need to get access to beefier system to build your source and produce debs?
18:52:33 * shapr follows bgamari on twitter
18:53:33 <bgamari> Possibly?
18:53:52 <bgamari> bah
18:54:03 <bgamari> armv7
18:54:06 <shapr> nooo
18:54:16 * bgamari can never keep these damn ARM revisions straight
18:54:29 * bgamari does have a raspberry pi around somewhere
18:54:39 <bgamari> I might be able to try putting together something
18:54:40 <shapr> bgamari: Do you have a more recent one with 512MB?
18:54:48 <bgamari> yep
18:54:50 <shapr> Yay!
18:55:01 <bgamari> I'm not sure I have a SD card large enough though
18:55:05 <bgamari> I'll have to look around
18:55:12 <shapr> So you could very likely build a ghc 7.6.* for the Raspberry Pi?
18:55:17 <shapr> bgamari: Want me to mail you one?
18:55:19 <bgamari> very likely
18:55:27 * hackagebot sizes 2.0.6 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.0.6 (JohnWiegley)
18:55:27 <bgamari> shapr, thanks for the offer but it's alright
18:55:28 * shapr attempts to bribe bgamari 
18:55:30 <shapr> heh, ok
18:55:40 <bgamari> shapr, I'll order one if not
18:55:55 <sclv> so i know that division on algebraic datatypes is a funny not necessarily sensical thing
18:56:12 <sclv> but is there some interpretation, if F and G are polynomial functors, of what F / G means?
18:56:33 <sclv> we can make them representable, if it helps
18:57:46 <shapr> bgamari: Ok, I'm excited!
19:00:34 <zxq9> Any recommendations for Qt/Haskell bindings? Only project I've found is pretty stale.
19:00:57 <bgamari> shapr, looks like I lack a large enough SD card but I'll have my friend Newegg send one over at his next convenience
19:02:20 <shapr> Ah yes, Newegg is a good friend of mine too!
19:02:35 <shapr> zxq9: I've only used the gtk2 bindings
19:06:10 <Modius> Whoever thought up hoogle deserves a medal
19:06:43 <Modius> It's soaking up my otherwise-useless questions
19:07:44 <jozefg> :t (.).(.).fmap
19:07:45 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:07:54 <jozefg> Weird...
19:08:07 <simpson> jozefg: (.) is fmap in lambdabot's mind.
19:09:14 <jozefg> simpsons: slightly different though right?
19:09:23 <jozefg> :t (.).(.).(.)
19:09:24 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
19:09:33 <jozefg> Oh wow that's interesting...
19:09:49 <jozefg> I wasn't expecting the functor constraints
19:11:29 <thetallguy> jozefg: I think that's a function of the bot.  You won't see them if you ask ghci the same question.
19:12:12 <jozefg> thetallguy: Yeah, I understand that it's using the (->) a instance of a functor but that type signature is too general I'd think...
19:14:59 <jozefg> Are ! and seq (and friends) the only ways to enforce strictness at arbitrary points in a Haskell program?
19:15:33 <bgamari> jozefg, there are the seq variants in deepseq
19:15:59 <bgamari> jozefg, there's also BangPatterns (if you aren't lumping that into "!")
19:16:14 <monochrom> case-of can also add strictness
19:18:25 <jozefg> bgamari:  Where can you use bang patterns? I didn't know about them (are they standard?)
19:18:44 <bgamari> jozefg, They are an extension (-XBangPatterns)
19:18:50 <monochrom> not standard. use {-# LANGUAGE BangPatterns #-} to enable
19:19:06 <monochrom> example: f !x = True
19:20:11 <bgamari> jozefg, http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/bang-patterns.html
19:20:21 <monochrom> g (!x : _) = False
19:21:30 <jozefg> Ah so that's to WHNF which is just the outer constructor right?
19:21:39 <monochrom> yes
19:24:10 <jozefg> Thank you, is it generally considered acceptable to use GHC extensions in production code?
19:24:49 <Philippa_> yep
19:25:00 <pdxleif> I'd say so.
19:25:08 <Philippa_> LANGUAGE pragmas help a lot on that front, too
19:25:21 <pdxleif> Fun for your co-workers doing code reviews: "Uh, WTH does that flag do?"
19:26:50 <arbn> jozefg: It's acceptable, but often even better not to use them, if it doesn't make the code much more complex.
19:27:22 <jozefg> pdxleif:  We probably have enough of that already, one guy in the lab has an obsession with APL-style 1 liners...
19:27:26 <Philippa_> but that's a tricky tradeoff if some of the complexity would be in client code for the library you're working on
19:28:35 <arbn> Yeah. Programming is a hard game. :/
19:28:41 <arbn> I'm not very good at it yet.
19:28:56 <pdxleif> jozefg: He runs all his code through the pointfree refactorer before checking it in?
19:30:11 <pdxleif> Just came as a shock to me, that I had to learn new language features / extensions, to do code reviews.  Guess the LANGUAGE pragama up top is a nice heads-up of that.
19:30:36 <jozefg> pdxleif: I have no idea, his ways are something of a mystery...
19:31:07 <jozefg> But the general rule is to not let Language pragmas bleed into the API?
19:31:22 <DrChaos> ihello
19:32:02 <thetallguy> jozefg: I think you'd be hard pressed not to use GHC extensions if you use any significant libraries.
19:33:01 <ivanm> thetallguy: yeah, using text without OverloadedStrings would be a pain
19:33:04 <cmccann> a lot of extensions are either expansions of existing features in an obvious way, or provide little beyond syntactic convenience.
19:33:31 <pdxleif> I dunno - I see plenty of examples of using a lib w/ a language pragma up top, e.g. OverloadedStrings: http://www.yesodweb.com/book/web-application-interface#hello-world-246
19:33:52 <cmccann> I wouldn't worry too much about those sort of extensions. once you know what they do they don't change anything fundamental.
19:34:31 <cmccann> on the other hand, something like TypeFamilies is, while useful, a significant addition to the language of something that simply doesn't exist otherwise.
19:34:43 <arbn> pdxleif: Yesod's design a little bit controversial. I like it, but I don't have a problem with requiring OverloadedStrings and Template Haskell all over the place.
19:34:46 <Nereid> I don't understand TypeFamilies.
19:34:58 <johnw> all happy type families are alike...
19:35:08 <jozefg> Thats true, do the sugar extensions have any plans to be included in the next standard?
19:35:29 * hackagebot profunctor-extras 3.1 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-3.1 (EdwardKmett)
19:35:32 <thetallguy> jozefg: but in general, I try not to use them until they've gone through a full version change
19:35:45 <cmccann> there are also a bunch of extensions that can be classified as "for convoluted metaprogramming purposes" which are hard to justify if they're exposed to client code beyond stuff like "use this top-level TH splice"
19:36:08 <thetallguy> Nereid: TypeFamilies are subtle, and I found the descriptions completely opaque at first
19:37:21 <cmccann> personally I think TypeFamilies are great, but I can also see why using them should require more justification in production code with a team involved
19:37:24 <arbn> cmccann: For Yesod, the quasioquoted TH languages are nice to get stuff like the type-checked HTML templates URL routing rules with convenient syntax.
19:37:29 <cmccann> compared something like, say, TypeSynonymInstances
19:37:34 <arbn> templates and URL routing*
19:37:38 <pdxleif> I want idiom brackets.  {-# LANGUAGE IdiomBrackets #-} ?
19:37:48 <cmccann> pdxleif, I wish :[
19:37:58 <thetallguy> pdxleif: I read that someone was using SHE to hack that
19:38:06 <cmccann> arbn, and yes, I'm familiar with the sort of stuff yesod does with QQ'ers. it's pretty neat.
19:38:44 <pdxleif> Yeah, I use she for that.  Idris has idiom brackets built-in, but they're [| |] instead of (| |), and don't seem to have the Alternative construct built-in.
19:38:45 <cmccann> SHE is the bastard child of the same person who invented the idea of idiom brackets
19:39:03 <cmccann> shenanigans like that are why SHE exists
19:39:32 <Philippa_> mmm. I still need to convince Conor that applicative do is occasionally a good idea and at least not worth turning down the patch for
19:39:40 <Philippa_> (OTOH, there is Frank)
19:39:51 <ivanm> when you have a QC test that very rarely fails and you think you've fixed why it fails, how can you tell if your fix worked if it's hard to get the failure case to arise with QC? :p
19:40:15 * thetallguy looks at Philippa_ suspiciously
19:40:20 <pdxleif> applicative do?
19:40:38 <thetallguy> more imperative idioms?
19:40:40 <lispy> ivanm: Can you temporarily remove the other properties and crank up the number of trials?
19:40:51 <ivanm> lispy: that's what I'm doing; still fails rarely
19:40:59 <lispy> ivanm: Figuring out an estimate of the failure rate would be good.
19:41:10 <Philippa_> thetallguy: There are plenty of non-imperative idioms where components still want identifiers. Parsing, logic programming...
19:41:10 <ivanm> but I think my fix just caused the test to fail for another reason... :s
19:41:16 <lispy> ivanm: save all the failures and look for similarities between them?
19:41:51 <thetallguy> Philippa_: I should probably look at what you are talking about before growling about it.
19:42:02 <ivanm> lispy: I know _why_ this particular case failed; and as it happens my fix wasn't all that great, just like I thought
19:42:06 <lispy> ivanm: the think the absolute higher priority is to characterize the hard to reproduce failure so that you can add some sort of test for it. So for example, if you only know 1 test case that triggers it, might as well add it explicitly for now
19:42:34 <Philippa_> thetallguy: It's otherwise just do notation, for applicatives, with a reasonably straightforward translation
19:42:52 <Philippa_> so the result line is allowed to refer to the things that precede it by name, but nothing else is
19:43:00 <ivanm> lispy: the Arbitrary instnaces are rather gnarly though, so hard to generalise the failure case
19:43:22 <Philippa_> I'd say it's about as imperative as let bindings are, but that's a provocative statement unto itself :p
19:43:41 <thetallguy> Philippa_: I was just about to say, sounds like applicative let.
19:43:46 <Philippa_> aaand I'm being summoned elsewhere
19:43:51 <Philippa_> sure. Do is monadic let
19:44:27 <thetallguy> Philippa_: hmmm, never heard that one, but indeed.  Thanks.
19:46:12 <Philippa_> thetallguy: that quip sums up a /lot/ of old arguments about monads, FWIW!
19:46:21 <arbn> Woah. I hadn't thought of it that way, either. Neat.
19:46:23 <Philippa_> (at least, assuming you understand ANF)
19:47:59 <arbn> Philippa_: Google isn't helping with the acronym ANF. What is it?
19:48:10 <thetallguy> http://en.wikipedia.org/wiki/A-normal_form
19:48:22 <arbn> thetallguy: Thanks.
19:54:01 <DrChaos> Hello. I try to write the function intersperse, but my implementation is only working on strings and has this weird error when you try to compile it. http://vpaste.net/tfjed
19:54:01 <DrChaos> > intersperse [1,2,3]
19:54:03 <lambdabot>   No instance for (GHC.Show.Show ([[t0]] -> [[t0]]))
19:54:03 <lambdabot>    arising from a use of...
19:54:40 * shapr swears at the iCalendar library on Hackage
19:54:56 <DrChaos> any way to fix the blasted error?
19:55:25 <DrChaos> if I delete the if statement and the else part, then it works but on the string "12" it would return "1,2,"
19:55:30 * hackagebot profunctor-extras 3.2 - Profunctor extras  http://hackage.haskell.org/package/profunctor-extras-3.2 (EdwardKmett)
19:55:58 <thetallguy> DrChaos: make your list element an instance of Show
19:56:41 <DrChaos> thetallguy -> huh? how do I do that?
19:57:13 <monochrom> no, don't
19:57:18 <monochrom> @type intersperse
19:57:19 <lambdabot> a -> [a] -> [a]
19:57:24 <monochrom> does not need Show
19:58:16 <monochrom> instead, explain your logic. I don't see why this code should make any sense and what it is trying to do
19:58:56 <thetallguy> Oh, indeed, I assumed you were running the function in ghci and getting that error.
19:59:07 <thetallguy> isperse (xs ++ y : ",") ys
19:59:13 <DrChaos> well....I should probably start over
19:59:46 <DrChaos> I think my function is illogical
19:59:58 <DrChaos> I don't really know what I'm doing
20:00:20 <thetallguy> Okay, now I'm confused
20:00:39 <monochrom> you should never write illogical code. use Intelligent Design, not mutation evolution.
20:01:13 <thetallguy> the error you pasted here isn't what is in the buffer
20:01:33 <jozefg> DrChaos: It may help if you try to write out the type signatures, that'll give you some insite into the problem
20:01:34 <DrChaos> I was thinking I could start a new list and for every item, push an item plus "," onto the list
20:02:08 <thetallguy> DrChaos: but if you put a "," into the list then the list must be of type [String]
20:02:28 * DrChaos is confused
20:02:39 <thetallguy> :t intercalate
20:02:40 <lambdabot> [a] -> [[a]] -> [a]
20:02:45 <Nisstyre> DrChaos: the type inference algorithm that Haskell uses will be easier to understand if you give everything (as much as possible) type annotations, then you can clearly see if something you wrote does not have the type you think it does
20:02:57 <DrChaos> Nisstyre -> ok
20:03:52 <thetallguy> DrChaos: what would intersperse' do if you gave it [1,2,3]
20:04:25 <Nisstyre> DrChaos: also, if a type is more constrained than you want it to be, that means you are using a function somewhere that adds the constraint, in your case there must be a function like (String -> String) or something that you are using
20:04:44 <DrChaos> thetallguy -> it would crash
20:04:44 <monochrom> y ++ ","  vs  y : ","
20:05:06 * Nisstyre is looking at the code now
20:05:09 <thetallguy> DrChaos: it would work in Scheme
20:05:21 <thetallguy> DrChaos: in haskell, it won't compile
20:05:56 <thetallguy> by your design, it would produce  [1,",",2,",",3]
20:06:16 <thetallguy> but that is a list with mixed types, which is not [a]
20:07:28 <Nisstyre> it's a heterogeneous list yeah
20:07:36 <Nisstyre> which is not what [a] is
20:07:43 <thetallguy> so try this: make    intersperse'' :: a -> [a] -> [a]
20:08:19 <thetallguy> such that    intersperse''   0 [1,2,3] = [1,0,2,0,3]
20:09:03 <DrChaos> oh, allow the user to specify a separator?
20:09:11 <thetallguy> indeed
20:09:33 <Nisstyre> DrChaos: which is what intersperse does
20:09:41 <thetallguy> DrChaos: when you understand why, you will have made a big step in understanding Haskell.
20:10:30 <DrChaos> thetallguy -> yeah, I want to make it so that each item in the input list is turned into a single character and tacked on to the beginning of a string that ends in ","
20:10:40 <DrChaos> or is that not the right way to go about it?
20:10:46 <thetallguy> DrChaos: you are thinking about strings.
20:11:03 <jozefg> Well that's a way to go about it, but then you gotta make sure you can turn your items into strings
20:11:14 <thetallguy> DrChaos: we think about things a little bit more generally
20:11:51 <DrChaos> ok...a little change in thinking for me
20:12:15 <jozefg> Story of Haskell (at least at first)
20:12:36 <thetallguy> DrChaos: intercalate inserts a single element into a list in (possibly) multiple locations, between all the other elements.
20:13:10 <thetallguy> intercalate knows nothing about the internals of type 'a', just that it works on a list of type [a]
20:13:49 <thetallguy> the type 'a' may be instantiated as anything.
20:14:03 <thetallguy> > intercalate 0 [1,2,3]
20:14:04 <lambdabot>   No instance for (GHC.Num.Num [a0])
20:14:04 <lambdabot>    arising from a use of `e_10123'
20:14:04 <lambdabot>  Poss...
20:14:17 <thetallguy> grr
20:15:05 <geekosaur> that's intersperse, I think
20:15:05 <startling> what package should I use to checksum a bytestring?
20:15:11 <kennyd> he is writing intersperse not intercalate
20:15:13 <geekosaur> > intercalate [0] [1,2,3]
20:15:15 <lambdabot>   No instance for (GHC.Num.Num [a0])
20:15:15 <lambdabot>    arising from a use of `e_10123'
20:15:15 <lambdabot>  Poss...
20:15:17 <Nisstyre> DrChaos: there are ways to get heterogeneous lists like you wanted in Haskell
20:15:19 <geekosaur> or not
20:15:27 <pnielsen> startling: what purpose? probably siphash
20:15:34 <Nisstyre> DrChaos: one way is with existentially quantified types, which is not recommended, e.g. "data Foo = forall a. Show a => Foo a"
20:15:50 <kennyd> > intersperse 0 [1..3]
20:15:52 <lambdabot>   [1,0,2,0,3]
20:16:10 <Nisstyre> then you can do [Foo 1, Foo ",", Foo 2]
20:16:13 <Nisstyre> but again, don't do this
20:16:30 <startling> pnielsen: I just want to check for consistency
20:16:44 <jozefg> Nisstyre: What other methods are there?
20:17:02 <Nisstyre> jozefg: I thought there were other ways, correct me if I'm wrong
20:17:12 <Nisstyre> I can't remember all of the extensions
20:17:30 <bgamari> startling, You should probably be asking "how do I want to check this bytestring for consistency?"
20:17:42 <bgamari> startling, what package you use is just an implementation detail
20:17:48 <Nisstyre> http://www.haskell.org/haskellwiki/Heterogenous_collections
20:17:51 <startling> bgamari: it doesn't matter much, it's for an example with lenses
20:17:51 <arbn> Nisstyre: You could use a universal type like Dynamic.
20:18:12 <Philippa_> bgamari: I set a build off a while ago btw
20:18:13 <Nisstyre> yeah
20:18:24 <bgamari> startling, I see, then perhaps hashable?
20:18:25 <Philippa_> was daft and forgot to time it properly, I'll likely be asleep when it completes
20:18:52 <arbn> I still don't really understand what difference using Dynamic vs Existential types makes, though.
20:18:59 <thetallguy> DrChaos: your goal is to pretty print a list, right?
20:19:01 <bgamari> Philippa_, Awesome!
20:19:09 <Nisstyre> arbn: I don't know if there are advantages to one
20:19:42 <Nisstyre> I just know that every time I've used existential types I ended up getting rid of them because they weren't worth the hassle
20:20:20 <jozefg> arbn: Dynamic is runtime, but should Existential be more verifiable at compile time?
20:21:03 * bgamari had forgotten how painful these ARM builds are
20:21:15 <pnielsen> startling: if it's just checking if a file probably isn't corrupted, CRC is fast and fine, but utterly useless for any other validation-with-any-certainty purposes
20:21:21 <Nisstyre> by far the cleanest solution is the first one there, just having multiple data constructors with each type you want as the parameter
20:21:40 <thetallguy> I was just considering getting a chromebook to run Ubuntu on to do GHC development...
20:21:46 <thetallguy> ...and then I came to my senses.
20:21:53 <pnielsen> sorry, lagging
20:22:31 <arbn> thetallguy: Chrome-books aren't really fitted for development. You're a developer, which means it's your duty to buy gratuitously powerful hardware. :P
20:22:44 <Philippa_> thetallguy: heh. Yeah, my ghci usage is fairly light, and the passive cooling is a plus for me
20:22:47 <jozefg> Nisstyre: Agreed, the only time I've needed Existential types is when I had a typeclass users implemented and code store those types in a heterogenous list
20:23:00 <startling> uh, using Data.Hashable.hash on any ByteString is getting me a "Process haskell bus error" o.o
20:23:14 <Philippa_> arbn: Hah. Some of us can't afford it, at least not at a suitable weight/battery life combination
20:25:04 <arbn> Philippa_: Yeah. Most developers seem to pretend they need more computational power than they actually do, anyway. :P
20:25:31 * hackagebot sizes 2.0.7 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.0.7 (JohnWiegley)
20:25:51 <Philippa_> arbn: oh, I need plenty of power for some use cases. Just, not development
20:26:02 <DrChaos> thetallguy -> yes, I want to pretty print a list
20:26:07 <Philippa_> (I haven't given my i7 a proper workout with the softsynth I purchased the other side of christmas yet...)
20:26:33 <Philippa_> (...it'll happily bring my 1.4GHz Core 2 Duo laptop to its knees with minimal effort though)
20:26:46 <thetallguy> DrChaos: okay, then I'm going to lure you in the direction we want you to go
20:27:11 <bgamari> startling, oh dear
20:27:19 <bgamari> startling, that sounds very bad
20:27:25 <bgamari> startling, which GHC version?
20:27:43 <Apocalisp> how would you express the behaviour of zip as a law?
20:27:52 <Apocalisp> as opposed to ap
20:27:56 <startling> bgamari: one second, updating bytestring and seeing if the problem persists
20:28:21 <DrChaos> thetallguy -> I want a character in between every item, in between every item except for the last item
20:28:25 <bgamari> startling, yep, hopefully upgradingfixes things
20:28:36 <DrChaos> e.g. [1,2,3] = "1,2,3" instead of "1,2,3,"
20:28:43 <pnielsen> hashable uses siphash fwiw
20:29:00 <thetallguy> DrChaos: right, but you've done two things there
20:29:14 <DrChaos> ah
20:29:24 <DrChaos> so one pattern is for a single item left?
20:29:38 <DrChaos> that's my burst of creativity there
20:29:39 <thetallguy> DrChaos: and if you break it down, you'll understand much more about haskell
20:29:55 <thetallguy> >map show [1,2,3]
20:30:09 <DrChaos> > map show [1,2,3]
20:30:11 <lambdabot>   ["1","2","3"]
20:30:17 <DrChaos> oh cool
20:30:20 <thetallguy> :t [1,2,3]
20:30:22 <lambdabot> Num t => [t]
20:30:30 <thetallguy> :t map show [1,2,3]
20:30:31 <lambdabot> [String]
20:30:41 <startling> pnielsen: oh, interesting, didn't know that
20:30:48 <DrChaos> a list of String is [[Char]]
20:31:06 <thetallguy> DrChaos: correct.  type String = [Char]
20:31:09 <DrChaos> I really don't quite get how to break it down yet
20:31:15 <thetallguy> :t ","
20:31:16 <lambdabot> [Char]
20:31:30 <DrChaos> oh yeah, I can see that
20:31:46 <thetallguy> > intercalate "," (map show [1,2,3])_
20:31:48 <lambdabot>   Pattern syntax in expression context: _
20:31:56 <thetallguy> > intercalate "," (map show [1,2,3])
20:31:57 <lambdabot>   "1,2,3"
20:32:39 <thetallguy> >map show  [(1,2),(2,3),(3,4)]
20:33:13 <thetallguy> I think the bot is drunk
20:33:57 <pnielsen> you forgot a space
20:33:58 <Nereid> no, you need to put a space after >
20:34:04 <DrChaos> it wants "> ", not ">"
20:34:27 <DrChaos> > map show [(1,2),(2,3),(3,4)]
20:34:29 <lambdabot>   ["(1,2)","(2,3)","(3,4)"]
20:34:32 <DrChaos> nice
20:34:35 <thetallguy> D'oh!
20:35:01 <thetallguy> intercalate "," $ map show [(1,2),(2,3),(3,4)]>
20:35:02 <DrChaos> is that defined on tuples with 3 items?
20:35:17 <thetallguy> :t map show
20:35:17 <Nereid> > over (mapped.both) show [(1,2),(2,3),(3,4)]
20:35:19 <lambdabot> Show a => [a] -> [String]
20:35:20 <lambdabot>   [("1","2"),("2","3"),("3","4")]
20:35:31 * hackagebot maxent 0.2.0.0 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.2.0.0 (JonathanFischoff)
20:35:36 <thetallguy> > intercalate "," $ map show [(1,2),(2,3),(3,4)]
20:35:38 <lambdabot>   "(1,2),(2,3),(3,4)"
20:36:21 <Nereid> > intercalate "," $ [(1,2),(2,3),(3,4)] ^.. mapped.both.to show
20:36:23 <lambdabot>   No instance for (Control.Lens.Classes.Settable
20:36:23 <lambdabot>                     (Control...
20:36:26 <Nereid> oops
20:36:35 <Nereid> > intercalate "," $ [(1,2),(2,3),(3,4)] ^.. traverse.both.to show
20:36:37 <lambdabot>   "1,2,2,3,3,4"
20:36:50 <thetallguy> DrChaos: ignore Nereid, he's playing with advanced stuff.
20:36:54 <thetallguy> :-D
20:36:56 <DrChaos> > intercalate ":" $ map show [(1,2),(2,3),(3,4)]
20:36:56 <DrChaos> the bot is drunk
20:36:57 <lambdabot>   "(1,2):(2,3):(3,4)"
20:36:57 <Nereid> yes, ignore me
20:37:12 <startling> bgamari: sorry for the wait, turns out a lot of things depend on the old ByteString. >.>
20:37:28 <monochrom> in soviet russia, you drink from the bot
20:37:43 <monochrom> tle!
20:38:05 <bgamari> startling, no worries, I really won't be of too much help anyways
20:39:05 <Modius> Is this lensMania new?  I'm on board, don't get me wrong; but I don't recall hearing about them 6 months ago.
20:39:14 <monochrom> it is new
20:39:20 <Nereid> lens is less than 6 months old
20:39:23 <arbn> Hehe. Whenever we have a beginner in here, it always leads to a tangent on lenses, free monads, generic traversals, or something similarly absurd. :P
20:39:29 <startling> Modius: misread that as lensMafia. :X
20:39:31 <thetallguy> Modius: it has seen recent advances.
20:39:40 <Modius> Oh, I met the lens mafia earlier today
20:39:42 <monochrom> mafia is also right
20:40:04 <Nereid> well, the idea of lenses has been around for a while, but the lens library is new
20:40:04 <Clint> just stall until it's all about prisms
20:40:14 <Modius> I'd used mapSnd (and imported some oddball library to get it) - before realising I could just   over _2
20:40:18 <Nereid> and the lens library contains a lot of cool things that aren't lenses.
20:40:21 <monochrom> don edwardk wants you to use lens and thank him. he may require your favour one day
20:40:46 <Nereid> Modius: :)
20:41:39 <Modius> I'm guessing that a lot of library drek out there could/should get replaced with more orthogonal operations based on this stuff.
20:41:56 <thetallguy> DrChaos:  good work with ":"
20:42:12 <thetallguy> DrChaos: what you said about tuples was not right.
20:42:45 <DrChaos> how was it not right?
20:42:58 <DrChaos> is show defined for a tuple that contains 3 items?
20:43:00 <thetallguy> DrChaos: map show  will turn a list of anything into a list of strings, as long as the elements of the list are elements of Show
20:43:09 <thetallguy> DrChaos: yes
20:43:18 <thetallguy> only mine contained just two
20:43:32 <thetallguy> > map show [(1,2,3,4,5)]
20:43:33 <lambdabot>   ["(1,2,3,4,5)"]
20:43:43 <Nereid> :t each
20:43:44 <lambdabot> Not in scope: `each'
20:43:46 <Nereid> aw.
20:46:02 <thetallguy> > map show [ [1], [2],[3]]
20:46:03 <lambdabot>   ["[1]","[2]","[3]"]
20:46:19 <DrChaos> does haskell support massively parallel operations? I want to create the worlds first viable quantum processor and RAM which will most likely enable me to write code to simulate a universe
20:46:31 <DrChaos> thetallguy -> let's continue breaking this apart
20:46:39 <arbn> DrChaos: ... seriously?
20:46:40 <Nisstyre> DrChaos: uh, well yeah, it does, but...
20:46:46 <thetallguy> DrChaos: lets master fold first... LOL
20:47:08 <DrChaos> ok
20:47:24 <arbn> DrChaos: I like the fact that you have high aspirations, though! Better to aim for the moon. :)
20:47:40 <Nisstyre> DrChaos: are you expecting to go into/are in physics?
20:47:47 <DrChaos> Nisstyre -> yes
20:47:58 <DrChaos> physics and computer science
20:48:04 <thetallguy> > foldr (\s t -> s ++ ", " ++ t) "" $ map show [1,2,3]
20:48:06 <lambdabot>   "1, 2, 3, "
20:48:46 <DrChaos> thetallguy -> whoa, that makes it simple. but is there any other way to implement intersperse without using foldr?
20:49:09 <thetallguy> DrChaos: your original implementation isn't far off
20:49:33 <thetallguy> DrChaos: you were just confused about homogeneous vs heterogeneous lists
20:49:41 <DrChaos> so the copy I uploaded to vpaste isn't far off?
20:51:40 <thetallguy> DrChaos:  intercalate m (x:y:zs) = x:m:(intercalate m (y:zs))
20:51:46 <shapr> bgamari: Is the build progressing? or has it failed horribly?
20:52:26 <thetallguy> DrChaos: needs a couple more cases, but I'll leave that to you.
20:52:40 <DrChaos> thetallguy -> blasted firefox won't start up
20:53:38 * DrChaos tries to curl download the paste
20:53:47 <Nereid> thetallguy1: not quite the right type but yeah
20:53:48 <dncr> hm why doesn't diffarray-0.1 build..
20:54:34 <thetallguy> Nereid: ?
20:54:42 <Nereid> :t intercalate
20:54:43 <lambdabot> [a] -> [[a]] -> [a]
20:54:53 <Nereid> :t fix $ \intercalate m (x:y:zs) -> x:m:(intercalate m (y:zs))
20:54:54 <lambdabot> a -> [a] -> [a]
20:54:54 <thetallguy> :lambdabot lies
20:55:32 <thetallguy> Prelude Data.List> :t intersperse
20:55:32 <thetallguy> intersperse :: a -> [a] -> [a]
20:55:53 <DrChaos> thetallguy -> ok can I break the line here? then isperse <line break here>
20:56:00 <Nereid> :t concat . fix $ \intercalate m (x:y:zs) -> x:[m]:(intercalate m (y:zs))
20:56:01 <lambdabot>     The lambda expression `\ intercalate m (x : y : zs)
20:56:01 <lambdabot>                              -> x : ... : (intercalate m (y : zs))'
20:56:01 <lambdabot>     has three arguments,
20:56:09 <Nereid> what?
20:56:26 <thetallguy> you added a \
20:56:30 <Nereid> I know.
20:56:37 <Nereid> :t concat . (fix $ \intercalate m (x:y:zs) -> x:[m]:(intercalate m (y:zs)))
20:56:38 <lambdabot>     Couldn't match expected type `[[a0]]'
20:56:39 <lambdabot>                 with actual type `[[t0]] -> [[t0]]'
20:56:39 <lambdabot>     Expected type: t0 -> [[a0]]
20:56:47 <Nereid> :t concat . (fix $ \intercalate m (x:y:zs) -> x:[m]:(intercalate [m] (y:zs)))
20:56:48 <lambdabot>     Couldn't match expected type `[[a0]]'
20:56:48 <lambdabot>                 with actual type `[[[t0]]] -> [[[t0]]]'
20:56:48 <lambdabot>     Expected type: [t0] -> [[a0]]
20:56:53 <Nereid> no that's not it.
20:56:53 <Nereid> duh
20:56:58 <bgamari> shapr, Tree was already built on Pandaboard
20:57:02 <Nereid> :t concat .: (fix $ \intercalate m (x:y:zs) -> x:[m]:(intercalate m (y:zs)))
20:57:03 <lambdabot> a -> [[a]] -> [a]
20:57:08 <bgamari> shapr, Building cabal-install now
20:57:09 <Nereid> oh wait
20:57:12 <Nereid> :t concat .: (fix $ \intercalate m (x:y:zs) -> x:m:(intercalate m (y:zs)))
20:57:13 <lambdabot> [a] -> [[a]] -> [a]
20:57:16 <Nereid> there.
20:57:28 <Nereid> so intercalate = concat .: intersperse
20:57:42 <Nereid> thetallguy: I also added a fix.
20:57:51 <Nereid> standard way to make an anonymous recursive function.
20:58:19 <Nereid> > (fix $ \fac n -> if n == 0 then 1 else n * fac (n-1)) 5
20:58:20 <lambdabot>   120
20:59:09 <hrumph> yo
20:59:34 <hrumph> how do i convert a string of digits to an integer?
20:59:47 <Nereid> > read "123" :: Integer
20:59:49 <lambdabot>   123
20:59:57 <thetallguy> DrChaos: hard for me to tell from here.  Line breaks are fine as long as you indent just a bit more.
21:00:33 * hackagebot maxent 0.2.0.1 - Compute Maximum Entropy Distributions  http://hackage.haskell.org/package/maxent-0.2.0.1 (JonathanFischoff)
21:04:38 <thetallguy> hrumph: if writing production code, consider maybeRead
21:05:01 <Nereid> readMaybe
21:05:13 <Nereid> that's relatively new though
21:05:14 <pnielsen> Safe.readMay :p
21:05:24 <pnielsen> been in safe for a while
21:05:24 <Nereid> you can always use reads, which is safe
21:05:56 <Nereid> :t \x -> case (reads x) of {[(y,"")] -> Just y; _ -> Nothing}
21:05:58 <lambdabot> Read a => String -> Maybe a
21:06:10 <pnielsen> and that's all the src of readMay
21:07:11 <dncr> where is readMaybe
21:07:21 <pnielsen> Text.Read
21:07:21 <thetallguy> Control.Applicative.Error
21:07:32 <thetallguy> that too, I think
21:07:45 <thetallguy> I forget if they are the same imlementation or not
21:07:47 <cheetah2> is haskell actually any better than other languages?
21:07:56 <thetallguy> cheetah2: absolutely
21:08:01 <pnielsen> cheetah2: no
21:08:06 <thetallguy> cheetah2: for some definition of better.
21:08:09 <DrChaos> cheetah2 -> it sure is different
21:08:12 <Nereid> readMaybe is in Text.Read, but only since base-4.6 (ghc 7.6)
21:08:14 <jfischoff> cheetah2: unfortunately yes.
21:08:26 <pnielsen> cheetah2: move along :p
21:13:05 <shapr> bgamari: What are the steps to build the whole thing for the Pi?
21:14:33 <Philippa_> shapr: what happens if you do what the stuff bgamari linked me to says?
21:14:54 <Philippa_> (assuming you've got an existing GHC of some sort)
21:15:57 <DrChaos> thetallguy -> if there are a few more cases I need to cover, then I'm pretty sure it's something to do with show
21:16:03 <shapr> Philippa_: What stuff is that? I didn't see the link
21:16:57 <thetallguy> DrChaos: nope, you need to cover lists of length zero and one
21:17:37 <DrChaos> thetallguy -> ah
21:17:38 <thetallguy> or rather, that's what my implementation was missing.  I think you had them in your original
21:18:30 <Philippa_> shapr: http://hackage.haskell.org/trac/ghc/wiki/Building/QuickStart etc
21:32:18 <cmccann> hm
21:33:01 <cmccann> anyone want to try to help solve a type hackery problem?
21:35:24 <Philippa_> right, first build failure's totally my fault: no LLVM
21:35:35 <Philippa_> (I think the trac needs updating for that?)
21:37:33 <thoughtpolice> Philippa_: if you have GHC on ARM, you do have llvm, it's part of the package deps in ubuntu (chromebook i suspect?) the annoying thing is ubuntu names the binaries things like 'llc-3.0', but GHC wants it to be 'llc'
21:37:56 <thoughtpolice> so i just symlink it in my ~/bin; ln -s `which llc-3.0` ~/bin/llc
21:37:56 <Philippa_> thoughtpolice: yes, chromebook. What should I do about it?
21:38:00 <thoughtpolice> do the same for 'opt-3.0'
21:38:10 <thoughtpolice> the Real Fix is to have GHC's ./configure script detect this stuff
21:38:14 <Philippa_> thanks
21:38:57 <thoughtpolice> Philippa_: opt-3.0 and llc-3.0 are the only ones you need. i think the GHC that ubuntu packages is a little tweaked to specifically use the -3.0 variants, hence why it works
21:39:15 <thoughtpolice> (since that's the only option on ARM)
21:40:06 <thoughtpolice> Philippa_: do not be surprised if it does not work. even the people trying to work on GHC have quite a challenge doing it :)
21:40:46 <Philippa_> *nod*
21:40:46 <thoughtpolice> but my odroid-u2 is coming soon, which i hope to make a GHC build machine; karel gardas runs the current ones, i think
21:41:24 <Philippa_> yeah. My want list is 7.6.1 on Precise, then ghci for the above, for now
21:41:29 <Philippa_> but right now? It's sleep
21:54:06 <aavogt> cmccann: what is it?
21:54:38 <cmccann> aavogt, http://stackoverflow.com/q/14133121/157360
21:54:44 <cmccann> the bit at the end of my answer
21:55:50 <cmccann> I can't figure out why it falls over any time there's a constraint on an instance :[
22:01:29 <cmccann> aavogt, it may just be that it's late and I'm missing something obvious but I don't see why it'd loop when there seems to be no actual looping possible based on the instance head :T
22:03:27 <hrumph> i'm writing strict validator functions so i can use read and don't need to use maybe read
22:06:49 <applicative> cmccann: very bold answering such a question!
22:07:12 <cmccann> applicative, hm? how's that?
22:07:30 <cmccann> stupid type hackery is usually my department :P
22:08:02 <applicative> cmccann: it didn't seem too hackish did it?  Im trying to figure it out
22:09:03 <cmccann> eh, it's a simple dodge to avoid what's clearly an explicit check that GHC does by abusing a largely unrelated feature
22:10:46 <cmccann> like I said, it's the same shady principles as a lot of disreputable type hackery, getting GHC to accept something sketchy because you expect it to handle it the way you want
22:12:33 <cmccann> and I suspect avoiding whatever is causing the looping is going to involve some additional shenanigans to raise the hackishness a fair bit
22:13:25 <applicative> wait I'm seeing now what '...turns out to be less than well-founded' means...
22:14:06 <applicative> ghci is looping somehow trying to typecheck it
22:14:18 <applicative> when I add McB''s types
22:14:52 <cmccann> yes, it will do that
22:15:34 <cmccann> what puzzles me is that any instance with a Differentiable constraint seems to do the same, not just the obviously ill-founded recursion from his instances
22:18:25 <applicative> I see, its the constraint  'instance (Differentiable f, Differentiable g) =>'  without it you can make an instance
22:19:00 <cmccann> yes
22:19:19 <cmccann> though of course it will complain about not satisfying the Differentiable constraint that was the whole point of this!
22:21:32 <aavogt> cmccann: can you express it with fundeps?
22:21:47 <cmccann> don't know, didn't try
22:21:54 <cmccann> I wouldn't expect that to help
22:22:06 <cmccann> but then again I didn't expect it to loop either
22:22:11 <aavogt> class Differentiable f x => Differentiable (f :: * -> *) (df :: * -> *) | f -> df
22:22:16 <aavogt> the 'x' isn't allowed
22:23:17 <cmccann> I'm pretty rusty where fundeps are concerned these days.
22:23:18 <aavogt> oops, it should be   Differentiable df x
22:24:33 <DrChaos> Hello. would somebody please help me with my intersperse' function? http://vpaste.net/WqFfw
22:24:43 <DrChaos> I feel that I am really close to a solution
22:25:21 <aavogt> in any case it seems like when you assert that (D f) is differentiable, you also say that (D (D f)) is... and ghc keeps looking for the end
22:26:00 <Rotaerk_> DrChaos, why is sep a parameter of isperse?
22:26:15 <DrChaos> Rotaerk_ -> OH
22:26:38 <DrChaos> replace "," in isperse with (show sep) and it will become clear
22:26:44 <Nereid> the type is totally wrong
22:27:00 <DrChaos> sep is a single character
22:27:04 <Nereid> you're saying you can take values of types a and [a], for *any* a, and return a list of chars
22:27:27 <DrChaos> yeah, I really don't know what to do about that
22:27:37 <cmccann> aavogt, hm, ideally it would just preserve that constraint until it's used in a specific context
22:27:39 <Rotaerk_> hmm I'm rusty with haskell... are the parameters of intersperse' not accessible from within isperse?
22:27:43 <Nereid> they are.
22:27:46 <applicative> The type is very odd. How is it possible except as intersperse _ xs = show $ length xs or something
22:27:55 <Nereid> anyway, intersperse has nothing to do with char
22:27:59 <hrumph> next Q how do i turn a string to an Int?
22:27:59 <johnw> DrChaos: just so you know, intersperse can be written as an extremely simple fold
22:28:11 <cmccann> aavogt, but now that you mention it I'd forgotten that class contexts are checked much more aggressively as a precondition
22:28:16 <DrChaos> johnw -> but I don't want to do it that way
22:28:17 <Nereid> johnw: not quite
22:28:26 <johnw> Nereid: intersperse sep = foldr (\x rest -> if null rest then [x] else x:sep:rest) []
22:28:32 <Nereid> oh fine
22:28:48 <johnw> DrChaos: ok
22:28:50 <Nereid> but it's probably more educational at this point to not use foldr
22:28:59 <johnw> i see, he wants to use recursion
22:29:09 <hrumph> i use show apparently
22:29:18 <cmccann> aavogt, hmmm ok it makes sense now, I think
22:29:33 <cmccann> but I don't think I'm going to come up with a workaround at 1:30am
22:29:35 <Nereid> DrChaos: I don't know where "," comes in. we're not dealing with chars here
22:29:46 <DrChaos> Nereid -> it seems like we are to me
22:29:50 <Nereid> intersperse makes sense for any type
22:29:58 <Nereid> > intersperse 0 [1,2,3]
22:30:00 <lambdabot>   [1,0,2,0,3]
22:30:06 <Nereid> those aren't Chars
22:30:15 <DrChaos> yeah I really don't know how you'd do that
22:30:22 <DrChaos> > intersperse ',' [1,2,3]
22:30:24 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
22:30:24 <lambdabot>    arising from the literal `1...
22:30:27 <DrChaos> ah
22:30:40 <DrChaos> it's just much more generic than that
22:30:46 <Nereid> > intersperse ',' "abc" -- because "abc" is a list of Char
22:30:47 <lambdabot>   "a,b,c"
22:30:54 <DrChaos> it would work if I tried intersperse ',' "123"
22:31:06 <mikeplus64> > intersperse ',' "123"
22:31:06 <Nereid> :t interspers
22:31:07 <Nereid> :t intersperse
22:31:08 <lambdabot>   "1,2,3"
22:31:08 <lambdabot>     Not in scope: `interspers'
22:31:08 <lambdabot>     Perhaps you meant one of these:
22:31:08 <lambdabot>       `intersperse' (imported from Data.List),
22:31:09 <lambdabot> a -> [a] -> [a]
22:32:00 <Nereid> > intersperse x [a,b,c]
22:32:02 <lambdabot>   [a,x,b,x,c]
22:32:15 <aavogt> cmccann: something like http://www.haskell.org/pipermail/haskell/2006-November/018705.html ?
22:33:01 <DrChaos> the last line is now:  isperse sep xs (y:ys) = isperse sep (xs ++ y : sep) ys
22:33:29 <cmccann> aavogt, possibly, I think this is a bit thornier but the same principles might apply
22:33:32 <DrChaos> cannot construct the infinite type a0 = [a0] in the first argument of (:), namely y
22:34:15 <Nereid> DrChaos: think about the types of things.
22:34:32 <Nereid> what are the types of xs, y, and ys?
22:34:34 <cmccann> aavogt, actually I just thought of something that might help!
22:35:38 * hackagebot http-date 0.0.4 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.4 (KazuYamamoto)
22:35:40 <DrChaos> with ys bound to [2,3] it's [Int]
22:35:51 <DrChaos> xs is [Int]
22:35:54 <DrChaos> y is Int
22:36:15 <pizzaplane> what about sep?
22:36:17 <Nereid> now does that agree with the type signature you gave?
22:36:21 <Nereid> oh er
22:36:24 <Nereid> yes, what about sep.
22:36:31 <Nereid> I forgot to ask abou tthat.
22:37:01 <DrChaos> sep has to be of the same type as the argument passed to intersperse'
22:37:12 <DrChaos> I mean, list passed to intersperse'
22:37:27 <DrChaos> so the same type as ys, in other words
22:37:33 <Nereid> and does it?
22:37:45 <Nereid> look at your type signature.
22:38:14 <DrChaos> well um...I meant without the list
22:38:25 <DrChaos> if ys is [Int], sep has to be of type Int
22:39:28 <pizzaplane> :t (:)
22:39:29 <lambdabot> a -> [a] -> [a]
22:39:44 <pizzaplane> so, "y : sep" gives an error
22:41:23 <Nereid> also
22:41:30 <Nereid> this looks very wrong
22:41:40 <Nereid> you're building up really long lists and appending to the end
22:41:48 <Nereid> don't do that.
22:41:58 <hpaste> Hrumph pasted “why parse error” at http://hpaste.org/80135
22:42:11 <hrumph> can anyone tell me why i get a parse error
22:42:28 <Nereid> numPattern x:y:z
22:42:31 <Nereid> is wrong
22:42:45 <Nereid> for a few reasons.
22:42:48 <aavogt> it needs parentheses
22:42:54 <hrumph> please don't judge the code. i am only a couple weeks into haskell now. i've done my reading so now i'm trying to cook up some code
22:42:59 <Nereid> first, as it is written, that is like (numPattern x):y:z
22:43:05 <hrumph> ah ok
22:43:10 <DrChaos> how would I avoid building up really long lists and appending to the end?
22:43:11 <Nereid> so you might fix it to write numPattern (x:y:z)
22:43:15 <Nereid> but that still isn't quite it
22:43:20 <Nereid> it'll parse, but not typecheck.
22:43:35 <applicative> DrChaos: The detour via isperse is coming from the fact that really there are three cases for intersperse', not just [] and (x:xs), I think
22:43:49 <Nereid> anyway,
22:43:53 <Nereid> the thing to write would be
22:43:56 <Nereid> numPattern [x,y,z]
22:44:18 <Nereid> (which is the same as numPattern (x:y:z:[])
22:44:50 <applicative> numPattern (x:y:z)
22:45:08 <applicative> oh z is a Char
22:45:31 <applicative> like Nereid says hrumph
22:45:37 <hrumph> ok
22:45:41 <hrumph> i see that
22:46:13 * applicative expresses gratitude for these pleasant type errors, directing attention away from cmccann and cmbride's 
22:46:30 <hrumph> i settled for (x:y:z:[])
22:46:35 <hrumph> i think that will do it
22:46:39 <Nereid> I'd write [x,y,z], personally.
22:46:45 <Nereid> well
22:46:53 <hrumph> oh in my client i see a smiley thing when i do that that's why i didn't understand what nereid was saying
22:46:59 <Nereid> I'd not use a list at all, and probably let it just take 3 Char parameters.
22:47:13 <Nereid> turn off smileys :)
22:47:28 <hrumph> the colon followed by the double open square bracket makes a smiley face in in my client. i  will defeinitely turn them off when i get around to it
22:47:31 <Nereid> numPattern x y z = ...
22:47:33 <hrumph> never been an issue until now
22:47:34 <applicative> hrumph: but wont this way  of putting it leave other-than-3-char things undecided?
22:47:50 <hrumph> applicative: no because i have other validator functions
22:48:18 <hrumph> i'm writing some pretend code pretending to validate form input
22:48:29 <Nereid> you don't want your validator to crash on invalid input I think.
22:48:30 <hrumph> its just an excercise that i'm doing for myself
22:48:36 <Nereid> so you better handle the case where the list doesn't have length 3.
22:49:14 <applicative> oh I was thinking you needed another line numPattern _ = False
22:49:35 <Nereid> ^
22:49:43 <hrumph> Nereid: i wrote that validator already
22:50:03 <Nereid> oh, well, whatever.
22:50:07 <hrumph> i have to make sure that the lazy evaluation either stops at that validator or i use a monad or something
22:50:08 <applicative> hm, isn't "12" a 'numPattern'?
22:50:09 <Nereid> non-total functions make Nereid sad.
22:50:22 * applicative too
22:50:45 <hrumph> because if it isn't length three i don't want it running the next validator
22:51:01 <Nereid> so shouldn't it return False instead of crash?
22:51:16 <hrumph> yeah i guess i can do that too
22:51:22 <applicative> hrumph: but maybe the arg should be a tuple (Char,Char,Char)
22:51:24 <DrChaos> applicative -> but I already have 3 cases
22:51:40 <DrChaos> on the last line, I need to fill in isperse sep xs (y:ys) = ...
22:51:51 <DrChaos> I do not know what to type where I put the ...
22:52:08 <Nereid> I don't know why you need a helper function at all.
22:52:12 <applicative> intersperse' _   []     = [] ; intersperse' sep (x:xs) = isperse sep [] (x:xs)
22:52:14 <hrumph> applicative: no i'm presenting its a string from a form representing someones age
22:52:29 <applicative> DrChaos: Oh I see three cases in the ispers thing
22:52:40 <cmccann> aavogt, applicative: I manged to get the sum types to work
22:53:06 <sdrodge> is there an easy way to have a type start from somewhere other than 0 for Enum?
22:53:19 <cmccann> turns out the recursive constraints can be broken down in a more well-founded way by limiting the constraint family itself
22:53:41 <DrChaos> Nereid -> the reason why I use a helper function is because I want to hide an implementation detail, namely the empty list passed into isperse
22:53:42 <applicative> ah type instance DiffConstraint (f :+: g) = (Differentiable f, Differentiable g)
22:53:51 <Nereid> sdrodge: you mean for your own data type?
22:53:56 <Nereid> just write your own Enum instance that way.
22:54:26 <sdrodge> Nereid: no very clean way to do it?
22:54:34 <Nereid> I don't think so.
22:54:59 <Nereid> I can think of an ugly way to do it.
22:55:06 <Nereid> but that's ugly.
22:55:07 <sdrodge> please share
22:55:14 <Nereid> it involves unsafeCoerce.
22:55:19 <cmccann> haha
22:55:21 <sdrodge> O_O
22:55:29 <Nereid> so, please don't.
22:56:44 <DrChaos> Nereid -> I'd like to write my function in another way that does not involve creating a new empty list, but I have no idea what to write
22:56:47 <Nereid> it's enough to define toEnum and fromEnum to get a complete Enum instance.
22:57:05 <aavogt> cmccann: ghc accepts this file for me http://hpaste.org/80136
22:57:06 <Nereid> DrChaos: new empty list? huh?
22:57:23 <DrChaos> Nereid -> you see the [] passed into isperse? that's the new empty list
22:57:30 <Nereid> intersperse sep [] = ...; intersperse sep [x] = ...; intersperse sep (x:xs) = ...
22:57:45 <cmccann> sdrodge, create a dummy newtype around your type, derive Enum for that, then implement the instance you want in terms of that with an added offset?
22:57:55 <Nereid> you can do it by just filling in the ..., with no helper functions, and recursion only in the 3rd case.
22:58:06 <aavogt> not so sure if splitting it up into two classes (which should be mutually recursive) still meets the requirements
22:58:13 <DrChaos> ok
22:58:30 <cmccann> aavogt, hmm interesting
22:58:32 <Nereid> cmccann: that was my thought too but you can't derive Enum of a newtype like that.
22:58:45 <cmccann> you can't? D:
22:58:47 <aavogt> hmm, maybe I'm missing one part to make it actually mutually recursive
22:58:52 <Nereid> I'm pretty sure
22:59:13 <DrChaos> SYN Flood (Linux Style) hahah
22:59:20 <applicative> DrChaos: I think a division of cases like this is the way to go intersperse' _   []     = [] ; intersperse' sep [x]    = ?? ; intersperse' sep (x:xs) = ??
22:59:21 <aavogt> yep there's a `Cycle in class declaration (via superclasses)'
22:59:46 <DrChaos> applicative -> ok
22:59:53 <cmccann> Nereid, oh yeah Enum isn't derivable even when it's painfully obvious that it could be
22:59:59 <cmccann> aavogt, :[
23:00:09 <Nereid> well, it's more like
23:00:29 <Nereid> it doesn't make sense to derive Enum (or any other class) of a newtype when the underlying type isn't an instance of that yet.
23:00:41 <DrChaos> Nereid -> ok, I don't know what to write after the equals sign in "intersperse' sep (x:xs) ="
23:00:52 <DrChaos> I want to avoid appending to the end of a list
23:00:58 <DrChaos> that's the goal
23:01:10 * DrChaos thinks it's time to go back to the drawing board
23:01:15 <Nereid> > intersperse s (x:undefined)
23:01:16 <lambdabot>   [x*Exception: Prelude.undefined
23:01:20 <Nereid> er
23:01:32 <Nereid> > intersperse s (x:y:undefined)
23:01:34 <lambdabot>   [x,s,y*Exception: Prelude.undefined
23:01:43 <cmccann> Nereid, yeah I guess so
23:01:44 <Nereid> you don't need to look very far into the list to tell what to output.
23:01:56 <Nereid> > intersperse s (x:undefined:undefined)
23:01:58 <lambdabot>   [x,s,*Exception: Prelude.un
23:02:07 <Nereid> Cale: why does that happen sometimes?
23:02:11 <cmccann> Nereid, I suppose you could exploit a derived instance of an unrelated, isomorphic type... but I think that's heading down the ugly rabbit hole
23:02:20 <Nereid> cmccann: yes, and then unsafeCoerce.
23:02:22 <DrChaos> Nereid -> oh, so look into the list and see if it contains two or more items?
23:02:36 <Nereid> DrChaos: you already know it does, because it fell through the first two cases
23:02:44 <DrChaos> oh right
23:02:53 <DrChaos> my brain is melting :/
23:02:57 <cmccann> Nereid, a function that actually translates between the types would also work, but that'd be needlessly inefficient
23:03:05 <Nereid> cmccann: and a lot more work.
23:03:10 <DrChaos> it's 1:02 in the morning here
23:03:22 <johnw> too much Chaos? :)
23:03:31 <DrChaos> yes
23:03:35 <johnw> i hear you there
23:03:42 <johnw> brain chaos gets me each night too
23:04:45 <DrChaos> it's ok, I can watch and see how the original Xbox got hacked to run Linux, maybe look into how they got the video game Mechwarrior to execute unsigned code
23:04:55 <zxq9> Any idea where the qtHaskell project is hosted now? The download links point to defunct SourceForge pages.
23:04:59 <DrChaos> too bad you can't really run Linux on something cool like that anymore
23:05:27 <Nereid> zxq9: http://qthaskell.berlios.de/ ?
23:05:53 <cmccann> aavogt, anyway thanks for giving it a shot, I'm off to sleep now
23:06:01 <Nereid> and then there's hqk
23:06:17 <cmccann> maybe applicative will figure it all out for me ;]
23:08:07 <zxq9> Nereid: That's the place that points to the sourceforcge download pages. The SF pages were taken down because up-to-date qtHaskell downloads are "hosted elsewhere already" and I can't seem to locate "elsewhere"!
23:08:40 <Nereid> huh?
23:08:49 <Nereid> points to a berlios download page for me.
23:09:02 <Nereid> which then points to sourceforge.
23:09:03 <Nereid> heh.
23:09:06 <Nereid> but then it works.
23:09:25 <zxq9> eh? I get "forbidden" and no download once I hit SourceFroce.
23:09:35 <zxq9> SourceForge*
23:09:38 <Nereid> I get "forbidden" and then it starts downloading anyway
23:09:46 <zxq9> I hate you.
23:09:51 <Nereid> :(
23:10:00 <zxq9> OK, I like you, but I will hold a grudge.
23:10:06 <Nereid> :|
23:10:17 <zxq9> I'll mess with the connection. I might wind up liking you after all.
23:10:27 <Nereid> ok
23:10:36 <Cale> Nereid: no idea
23:10:51 <Nereid> Cale: yeah, I got a numeric answer of -3 once when it really was -32768 truncated.
23:10:54 <Nereid> and then I was confused.
23:11:21 <Cale> I mean the weird behaviour with undefined
23:11:42 <Nereid> no, it has nothing to do with undefined.
23:12:05 <Nereid> except that the word got cut off.
23:12:22 <sdrodge> cmccann: I'm having trouble doing what you said and getting it to compile
23:12:36 <cmccann> sdrodge, yeah sorry, I was wrong :[
23:12:41 <cmccann> as Nereid pointed out
23:13:12 <sdrodge> oh, I guess I missed that
23:13:53 <zxq9> Nereid: Weird, it did work but required JavaScript redirection to be enabled. So I suppose I like you after all. Amazing compression rate, btw. 62.7MB to 3.1MB under bz2.
23:18:09 <DrChaos> Nereid -> I try the simple "intersperse' sep (x:xs) = intersperse' (x : sep)" but it doesn't work
23:18:26 <Nereid> read what you wrote carefully.
23:18:34 <DrChaos> I think my brain is fried... let me see
23:19:54 <DrChaos> type mismatch? just a wild guess
23:20:00 <DrChaos> wait
23:20:03 <DrChaos> no, that's not it
23:22:56 <DrChaos> I gotta go to bed
23:23:16 <johnw> zxq9: generally xz will do even better than that
23:30:41 * hackagebot crypto-random-api 0.2.0 - Simple random generators API for cryptography related code  http://hackage.haskell.org/package/crypto-random-api-0.2.0 (VincentHanquez)
23:30:43 * hackagebot crypto-numbers 0.1.1 - Cryptographic numbers: functions and algorithms  http://hackage.haskell.org/package/crypto-numbers-0.1.1 (VincentHanquez)
23:30:45 * hackagebot cprng-aes 0.3.2 - Crypto Pseudo Random Number Generator using AES in counter mode.  http://hackage.haskell.org/package/cprng-aes-0.3.2 (VincentHanquez)
23:30:47 * hackagebot crypto-pubkey 0.1.1 - Public Key cryptography  http://hackage.haskell.org/package/crypto-pubkey-0.1.1 (VincentHanquez)
23:58:35 <zxq9> Ah, so that's why nobody uses qtHaskell -- the license is completely mysterious.
23:59:27 <zxq9> I love it when a project is abandonned by the author, but remains unusable by both the community and business because of license ambiguities.
