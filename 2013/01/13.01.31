00:18:47 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
00:18:47 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Tue Jan 29 09:36:42 2013]
00:18:47 --- names: list (clog ketil luqui charliesome edsko jianmeng1 Itkovian basdirks mrtimuk nikita-0 JaRoel|4d JaffaCake hayashi eldariof janbanan Taneb MrWoohoo piotr__ sShintah Maarten_ MroiZo copumpkin rsuniev123 nimred neutrino ericmj estultic1a jollytime yitz lukexi [mth] moevenpick Afish Paprikac_ toekutr reckler andrewffff mceier hkBst Moggle desc|zenbook [[zz]] mugenken odi snowylike xpika yacks shurikas eis ThomasLocke ktosiek tjohnson kerrick LtWorf jesyspa ramkrsna)
00:18:47 --- names: list (Palmik nus BMeph nighty^ pzuraq hiroyuki_ fsvehla EarlGray dwn joneshf dfletcher_ sopvop mason2 fragamus RayNbow`TU Nereid akamaus bbloom frsoares VZakharov monqy sprang elkng hychen Jesin ccxCZ CoverSlide hiratara augur kennyd cog hamid eejaydubya otto_s tessier ptrf knz_ techlife tomboy64 preflex mauke gwern juhp TheInfosphere jxv Rarrikins_v xinming edwardk qinglingquan kamatsu glguy travitch__ Rickasaurus wollw miclorb chemist_ Khisanth sclv adlan)
00:18:47 --- names: list (radiobutton listofoptions imeredith WhereIsMySpoon cglazner studybot_ parcs c_wraith ctype_real JoeHazzers ulfdoz gbarboza robbe- favonia MnO2 mkouhei normanrichards julmuri TheRedMood Ralith cmears pxdr shutdown_-h_now zachk SHODAN julmae tsou DrCode SrPx Botje doomlord__ Gunni torkjak nnunley AntiSpamMeta isomorphic Polarina otters kfish cmccann happy4crazy Hermit noam__ ByronJohnson Tene mlh OlegYch|h tuttlem fgomez Ikoo joeyh kalizga fqsxr message144)
00:18:47 --- names: list (tobiassjosten smarter junsuijin eacameron perlite DexterLB phirox silasm VaporOne bholst mkaito hiroaki aib kmels Myk267 Ulrar archblob prophile nyc mgsloan stepcut araujo _jwest ftrvxmtrx dolio grey_area rjmt___ dabradley ssbr` niloc132 Zzompp tdammers tahu mysticc LeaChim bergey timemage kith yeltzooo jcsims nule liff u_quark reinoud ahihi xunatai brandonw dmarker nicoo speilberg0 lokydor amgarching cdidd alios hyko Swizec Amadiro peterhil- maksbotan)
00:18:47 --- names: list (M30W waterlaz Internet13 LAMMJohnson snoyberg monochrom no-n magaio Shapeshifter shepheb hamishmack wormphlegm yewton kniu wjlroe eL_Bart0 mannyv peterhil akahn jaspervdj purefn ski vadas Draconx SLi Nisstyre dv- nyingen aforemny cyphase tensorpudding bdowns ede reiddraper larks ClaudiusMaximus Eiam dmwit spoonbadger whaletechno rainmaker xplat blooberr sanjoyd sirchurchill chirpsalot Jaak revolve melter tomprince jlewis simon mm_freak latro`a Peaker frio)
00:18:47 --- names: list (jlamothe so jweijers frerich Soft bbee ormaaj zw01 Ornedan v605 dreixel Nanuq shergill ninegrid hvr colah_ My_Hearing ohrmazd drbean gnuvince aleator tavelram dju EvanR2 joar sgso aristid mrdomino pskept ft tazjin cow-orker boblehest lemao janin ent pettter mdf alpounet lusory jdavis MetaCosm Excureo Jonno_FTW Pantoufle joe9 Adios akosch marienz appelton mortberg jyyou Dodek mirsal kakos otterdam thirsteh eal_ albel727 Sebastien-L pnkbst rhodesd)
00:18:47 --- names: list (BlastHardcheese natte Entroacceptor Dashkal jbauman andrewsw Cryovat ousado MercuryRising IanKelling chance Eridius OnionKnight_ netj tromp Tesseraction gdeest guymann HaltingState Twey carlocci nlogax duairc tmiw lightquake Megant inverse gthorslund sgronblo confound brisbin covi anona Cthulhon bacon1989 descender `0660 SegFaultAX fxrh idnar macbr sohum thetallguy mahogny DT` fran niko Vorpal hpc betawaffle tom2221 joachifm mmaruseacph2 codertux arcatan)
00:18:47 --- names: list (Nanar KitB_ acharles Axman6 ehamberg obcode eataix Cale sm flori ezyang rmunroe jtannenbaum Tarential kshannon kini tamiko gcmalloc comak kosmikus caligula_ celery_ xaimus ziman ParahSailin mcsmash jaimef tridactyla fall_ tanakh__ Clint Sunhay identity Zariel milli tieTYT2 `nand` vmeson kopi edenc mjr84 vobi gemelen verrens levitation[A] linduxed crdueck codingkevin xymox n-dolio zoktar jabirali levi dcoutts wting taruti arafel krig kevinqcs yano wchun)
00:18:47 --- names: list (LeninParty mimi_vx adimit neptunepink notdan n_b bgamari jackhill jrockway capisce Jean ChongLi bentham wunki yumike raid ofan rfw__ snorble_ si14 tunixman Maxdamantus Tehnix Plex- hive-mind adnap inr MK_FG thorkilnaur ned faybot raek KaneTW Nimatek KitB Cerise antistrom dan_johnsin mateu_ jrib DigitalKiwi ps-auxw anachron dropdrive mefisto justdit MrKipper Starfire PGGB MrMeh canvon frontendloader formalcow chr1s leroux geekosaur rfw eviltwin_ lispy)
00:18:47 --- names: list (amiller_ gseitz Hafydd fayden _flow_ Belgarion0 gbeshers qwr integral dqd Baughn rio tg _br_ mike2 earthy ortmage nonymousa solarus dottedmag appamatto fotc cmsd2 mononofu Kuba TML Deewiant zugz dented42 pikhq luite k0ral decltype DrSyzygy PHO_ eyck mixi epta vhz ckx KaiSforza Tordek cross shachaf ahkurtz sipa Eelis magistr Jaxan mullein mimico Gurragchaa Ghoul_ FalkoPeters puzza007 etrepum gereedy bogner confab ivan\ willb wagle Nickeeh brainproxy elgot)
00:18:47 --- names: list (kranius totte nathanel_ b52 quicksilver bezik danr theorbtwo Debaser tswett Erstarrung yan_ magicman herself Nshag mahrz alang sajith mephx pyry` plhk bd_ pnielsen bapa harrison phrst Bwild birkenfeld Vq Walther edwtjo opqdonut Choko fabjan cajla icambridge Gothmog_ Gilly kobsu tweakism mollerstrand Dybber dsantiago upgrayeddd geoffh whoops Liebach bylzz bartavelle davean_ ido_ stephe- hanDerPeder barrucadu matzo seats qwandor|quassel deavidsedice McManiaC)
00:18:47 --- names: list (popx_ voyd xvilka Will| gspr Xeross Counter-Strike pdxleif_away saiam Boney Im_Also_Greg thetallguy1 liesen tanakh ethercrow Fubar^ chrra lucca ivan electrogeek Mortchek Natch dumbhat myme drmegahertz noj tomh alshain jodaro ccasin iulian boyscared jliikka mjrosenb bduc- Saizan rcl xenocons hirsch__ fireglow Happy0 ajcave munro vanseverk ciaranm fattrat wtw gdsx Estrellas lambdabot zorzar yam solirc Eliel Arnar drewr `micro alcz Igloo kloeri skp erineh_)
00:18:47 --- names: list (zomg s4msung sulaco_ wto anders^^ elemir fuho ion SeanTAllen stelleg_away lopex chrisbuchholz_ bobry mgeorgi_ arnihr_ Xorlev wilfredh percival__ ninzine Canar sunnavy Fuuzetsu knyppeldynan jubos fergusnoble majoh mikeplus64 hpd elliott arkx mzarella tvaalen jml kkris Gracenotes Viesti Enigmagic brett machisuji nominolo qz jix wumpus pigoz lazard kqr mux statusfailed shanse moben fionnan_ Razz_ matthavener heath pfoetchen xlr __main__ ibid Varakh tlockney)
00:18:47 --- names: list (zeiris osfameron FireFly aniero johnw em jtobin `bps gds flux Jello_Raptor felipe_ fryguybob Obfuscate jmcarthur davorak int-e edwinb Martty simply-chris emias schlumpi tomaw wereHamster asdfasdf cl_away ivan` sjl Adeon rntz sixohsix ique ernst idoru tomku f8_ mlinksva mornfall Athas Guest80754 DustyDingo newsham Heffalump CosmicRay suiside byorgey mroman Doikor Sagi pr endou faen sordina threedaymonk Rembane faheem jerojasro r126l brixen d-snp peltchu)
00:18:47 --- names: list (Laney mrshoe dilinger jlouis lahwran The_third_man alexanderte certainty Jonte simon__ Liskni_si a11235_ zenzike itzmjauz_ deggis companion_cube drek cods BrianHV mokus epsil mami thoughtpolice dixie norm2782_ elliottcable Ke bens klugez ggreg dyreshark ynik smash Chousuke x7 scgilardi ick saurik blackmirroxx jrslepak shrimpx SimonRC ahf koala_man mietek jayne Iceland_jack hackagebot mendez pqmodn banjiewen absence sully mrd bxc finnrobi guerrill1 mpu)
00:18:47 --- names: list (plat0 masquerade Ptival agundry Draggor hiredman mattp_ bstrie cynick tafryn mvj4_ Bigcheese XMunkki CindyLinz ]OLI[ pyrtsa liszt_ noplamodo peddie freiksenet MasseR cjay copton cebewee thalll kaol aszlig bcoppens froztbyte Valodim pharaun Derander kalven kmicu mechairoi @ChanServ \rs moonlite fmap lenstr srcerer lpsmith Raynes Nik_89 ocharles Fluky Spockz hpaste xnyhps othiym23 robbert _janne Boreeas juri_ Guest75608 endojelly koninkje_away JoshuaA ptek)
00:18:47 --- names: list (ghorn wolong rcj_ monique_)
00:19:41 <M30W> ion: What's wrong with having the escape sequences? :)
00:20:21 <ion> m30w: Different terminals have different capabilities. You need a database of them. A.k.a. terminfo.
00:20:44 <shachaf> What about termcap?
00:20:50 <shachaf> I hear that's a database of terminal capabilities.
00:23:25 <ion> terminfo > termcap
00:25:02 <shachaf> If you want a database of terminal information, sure.
00:26:09 <M30W> schovi: termcap /= extist.hs
00:26:19 <M30W> err
00:26:25 <M30W> schovi: Ignore that
00:26:28 <M30W> shachaf: ^^^^
00:26:48 <ion> terminfo (5)         - terminal capability data base
00:26:59 <schovi> sure :)
00:27:21 <shachaf> termcap (5)          - terminal capability database
00:27:30 <shachaf> I think a database is clearly superior to a data base?
00:27:42 <M30W> xD
00:27:53 <ion> A base of terminal capability data sounds good to me.
00:28:06 <M30W> xD
00:28:14 <shachaf> Maybe if it said "datum base" I'd trust it more.
00:29:01 <M30W> shachaf: Why?
00:37:29 <Nereid> M30W: because data is plural
00:37:48 <Nereid> but it's used as if it were singular all over for some reason
00:37:51 <M30W> I see
00:38:47 <jollytime> radii
00:45:55 <M30W> Eww.
00:46:03 <M30W> ion: terminfo.hs ... C!!
00:46:04 <M30W> :(
00:46:21 <M30W> Lol
00:47:08 <Industrial> What do I do with this (cabal) https://gist.github.com/623ab85f8198ab48d25d/0f9e86ac9d5b864968881bbaaad80657937fd24f ?
00:50:21 <johnw> first cabal install happy
00:50:24 <johnw> then try again
01:01:28 <Industrial> johnw, same error
01:01:43 <M30W> Industrial: ...
01:01:46 <johnw> whach does happy --version say?
01:01:53 <johnw> is ~/.cabal/bin  first on your PATH?
01:02:09 <M30W> Industrial: Your error said happy wasn't installed.. Are you sure you installed happy? :P Looking unhappy here :(
01:02:38 <M30W> =)
01:02:44 <Industrial> le sigh
01:02:47 <johnw> the error said it couldn't find happy >= 1.17
01:02:59 <M30W> Eh
01:03:50 <Industrial> well, it still says that, even though it installed 1.18
01:04:19 <johnw> and that happy is first on your PATH?
01:04:25 <johnw> next try cabal -v install...
01:04:28 <johnw> see what it's running
01:04:58 <Industrial> I have no idea where cabal installs this, I guess in my home?
01:06:18 <Industrial> johnw, https://gist.github.com/623ab85f8198ab48d25d/46f3e636635d3ab563823615e8521588fe2ff3c0
01:06:52 <johnw> i really don't know why it's not finding happy on your system
01:07:57 <Industrial> oh, sudo apt-get install happy :| sometimes I feel 'gifted'
01:12:48 <shachaf> Industrial: cabal installs happy in ~/.cabal/bin
01:12:52 <shachaf> You should add that to your PATH.
01:12:57 <shachaf> Better than using apt's version.
01:13:30 <Industrial> k
01:13:49 <M30W> ion: How do you use terminfo???
01:20:20 <ion> m30w: This will clear the screen: do t <- setupTermFromEnv; let { Just c = getCapability t (tiGetOutput1 "clear") }; runTermOutput t c
01:20:32 <ion> See terminfo(5) for the capability names.
01:20:57 <M30W> umm
01:22:19 <jollytime> mew.
01:23:07 <M30W> ion: Is that the shortest way possible?
01:24:17 <ion> m30w: You’ll only need to run setupTermFromEnv once, and you can make a function that runs getCapability and runTermOutput.
01:25:10 <M30W> So what... I pass this t throughout my game ?
01:26:56 <ion> You might want to use a higher-level library that uses terminfo. Perhaps vty (i haven’t used it though).
01:29:00 <M30W> To...... Clear the screen O.o
01:29:24 <pharaun> heard... good thing about vty
01:29:40 <ion> m30w: No, to make a game.
01:30:00 <ion> m30w: I assume clearing the screen is not the only thing your game will ever do with a terminal.
01:30:16 <M30W> ion: Text adventure
01:30:17 <mauke> if you're not doing anything fancy, stop trying to clear the screen
01:30:31 <M30W> Haha
01:30:32 <mauke> it annoys me as a user
01:30:34 <M30W> Nice -_-
01:30:37 <M30W> Fine
01:31:00 <mauke> also, putStr (replicate 999 '\n')
01:31:32 <ion> My terminal is 2000 lines high, you insensitive clod!
01:32:10 <ion> Or: why is my printer dumping out blank pages?
01:33:11 <M30W> mauke: Ew
01:33:33 <M30W> xD
01:36:32 <Vq> Or shell-out to: echo -ne '\033[2J\033[0;0H'
01:36:41 <Vq> Everyone uses ansi terminals, right?
01:38:21 * hackagebot shake 0.8 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.8 (NeilMitchell)
01:42:18 <ion> vq: If you shell-out you might as well do the right thing in there and use tput.
01:42:38 <mikeplus64> shachaf: https://github.com/mikeplus64/repl/blob/master/src/Language/Haskell/Repl.hs made it a bit cuter, but now it has one more neat feature over mueval: expressions like [0,1,2,let x = x in x] time out, but still return a result
01:42:51 <mikeplus64> > [0,1,2,let x = x in x]
01:42:55 <lambdabot>   mueval-core: Time limit exceeded
01:43:47 <mikeplus64> >>> prompt repl $ Expr "[0,1,2,let x = x in x]"
01:43:49 <mikeplus64> Partial ["[0,1,2,"]
01:43:54 <ion> nice
01:44:49 <ion> Does/will it support an equivalent to @type (using the exact same environment it uses for evaluating stuff)? I have wished mueval had that. Does is take advantage of Safe Haskell?
01:44:57 <mikeplus64> it does already
01:45:01 <mikeplus64> and yes
01:45:05 <ion> nice
01:45:12 <mikeplus64> after shachaf wrote unsafeCoerce in it a few times anyway :|
01:45:16 <ion> hah
01:48:32 <Nereid> mikeplus64: the code for prompt sounds like it could use async :>
01:48:57 <Nereid> maybe
01:49:07 <ion> mikeplus64: Some extensions you might consider adding to the defaults: BangPatterns, DeriveFoldable, DeriveTraversable, NoMonomorphismRestriction, Rank2Types, RecordWildCards, ScopedTypeVariables, TupleSections, ViewPatterns
01:49:08 <mikeplus64> maybe. it's pretty gross at the moment, but it works
01:49:20 <mikeplus64> ion: OK
01:49:52 <Nereid> I watched simon marlow's talk on async the other day and it was great.
01:49:59 <mikeplus64> i didn't, do you have a link?
01:50:02 <ion> Yeah, async seems very nice.
01:50:11 <Nereid> http://skillsmatter.com/podcast/home/high-performance-concurrency/te-6536
01:50:21 <mikeplus64> thanks
01:51:52 <M30W> It would be interesting to see bots for different languages in here. So people could compare when explaining/extinguishing/fueling flamewars
01:51:55 <M30W> :)
01:52:17 <Nereid> mikeplus64: async is basically a nice interface around forking and putting stuff in a MVar, so it's probably exactly what you could use there.
01:52:27 <mikeplus64> M30W: nah, there are plenty of offtopic chans on freenode, and everywhere else
01:52:37 <M30W> :P
01:52:49 <Nereid> well actually a TMVar
01:53:20 <mikeplus64> Nereid: sounds good (although i'm partial to redoing what i've done for the sake of cuteness[or maybe soundness. i'm not confident in myself] again)
01:54:35 <Nereid> hmm
01:55:57 <M30W> mikeplus64: Or even better #lang-wars
01:56:01 <M30W> :)
01:58:06 <ocharles> bah, my little app spends the majority of it's time in allocations for Data.Aeson.encode :(
01:58:58 <ocharles> but changing from Data.Set to Data.HashSet doubled performance :)
01:59:46 <Nereid> everyone loves unordered-containers
01:59:59 <mikeplus64> i'm getting a soft spot for hashtables
02:00:34 <mikeplus64> mutability is not the sin it's made out to be :(
02:00:42 <tdammers> I'm currently reviewing a Java web app... I've developed a third eye for hashdos vulnerabilities
02:00:52 <ion> What do hash tables have to do with mutability?
02:01:04 <mikeplus64> the package implements mutable hash tables
02:01:21 <ion> Ah, ok
02:01:23 <tdammers> so no soft spot here
02:01:54 <monqy> eyes are kind of soft
02:01:56 <merijn> ion,mikeplus64: GADTs and ExistentialQuantification? :> Or will it not support data definitions
02:02:31 <ion> merijn: GADTs were in the list already.
02:02:36 <mikeplus64> merijn: it does/will support data definitions
02:02:38 <merijn> Actually, given GADTs separate support for ExistentialQuantification is not that interesting...
02:02:47 <merijn> DataKinds and KindSignatures? :>
02:02:51 <mikeplus64> yes
02:02:54 <merijn> \o/
02:04:03 <quchen> Man, trying to color GHCi's output sucks. I've got a one-liner to parse and color standard (i.e. derived) Show instances, but I just can't make it the automatic printing function.
02:04:32 <quchen> There's the parameter where you can specify the autoprint function, but the problem then is that GHCi will forget "let" definitions on :r
02:04:44 <Nereid> indeed :(
02:05:00 <quchen> So much time wasted on that Prelude parser without imports.
02:05:12 <quchen> Okay, not "so much", but pointlessly much anyway as it turns out.
02:05:13 <Nereid> if you can solve that, *and* make incremental output work, I'll give you a nickel
02:05:57 <quchen> Nereid: That's the point of my miniparser (it's really just a mockup of a parser): work on infinite lists
02:06:04 <frerich> In a small program, which supports a 'verbose' switch, I pass a 'String -> IO ()' function along which can be used to print verbose output (this function is either putStrLn or return ()). However, it's a bit annoying to thread this argument all over the functions (some of those have fairly long types already), is there a nicer way to solve this? Maybe some kind of logging monad or so?
02:06:04 <Nereid> fun
02:06:10 <quchen> The only problem is getting GHCi to accept it.
02:06:34 <Nereid> frerich: ReaderT for the switch value maybe?
02:07:01 <shachaf> ReaderT is the obvious solution for just passing a value around.
02:07:48 <frerich> Never heard of ReaderT before heh, let me read up on it.
02:09:28 <Nereid> ReaderT is the same as adding an extra function argument to everything except that the passing and stuff is wrapped up and hidden
02:14:36 <srhb> What's a good data structure for representing and A* searching a 2d maze?
02:16:34 <mm_freak> srhb: any backtracking state monad like StateT Path Logic
02:17:11 <Lethalman> srhb, also search for "astar haskell", there's even one in Data.Graph
02:18:42 <mm_freak> StateT Path [] may be easier to use
02:18:53 <mm_freak> less syntax noise, but also probably a bit slower
02:19:11 <Lethalman> mm_freak, but it shouldn't backtrack in terms of the graph, it should take always the actual best node
02:19:34 <srhb> Path being what, actually?
02:20:12 <mm_freak> Lethalman: i'm assuming that there may be dead ends
02:20:27 <mm_freak> if all paths lead to the goal, then yes, no backtracking needed
02:20:45 <mm_freak> srhb: to keep the prior path segments and to support backtracking, if needed
02:20:53 <Lethalman> mm_freak, still not backtracking needed if you always pick the best in a list of node
02:21:10 <srhb> Hm. I'm still confused on how to represent the actual maze to be solved.
02:21:16 <mm_freak> Lethalman: the best one may lead to a dead end, in which case, you have to backtrack
02:21:25 <merijn> srhb: Zipper!
02:21:30 <Lethalman> mm_freak, take the next node in the sorted list of best nodes
02:21:40 <Nereid> srhb: a graph will do
02:21:41 <mm_freak> Lethalman: that's backtracking
02:21:55 <Lethalman> mm_freak, but not in terms of graph paths, it's in term of a sorted list of best nodes
02:22:00 <srhb> merijn: How do you mean? A Zipper on a list of lists?
02:22:24 <merijn> I was thinking graph zipper, but whatever works?
02:22:46 <osfameron> how can you zip on a graph?
02:23:04 * osfameron 's brane asplodes
02:23:13 <srhb> I'll never figure out Graph from containers. :P
02:23:20 <Nereid> you can have a zipper on any ADT
02:23:25 <Nereid> er
02:23:26 <mm_freak> Lethalman: StateT Path [] Path represents a computation that will produce all possible solutions…  all branches are tried in some order determined by the heuristic…  if a branch fails, it's an 'empty' branch, in which case backtracking in [] occurs
02:23:29 <hiptobecubic> osfameron, a zipper is a data structure. It's not a good name for it
02:23:34 <mm_freak> StateT Path [] is a backtracking monad
02:23:45 <hiptobecubic> osfameron, it's more like a "context" or a "focus" or something
02:23:58 <merijn> osfameron: How can't you zip on a graph?
02:23:59 <Nereid> StateT Path [] is also a "path parser" monad.
02:24:03 <osfameron> hiptobecubic: yeah.  I understand (ish) zippers on non-cyclic structures such as lists and trees
02:24:13 <mm_freak> yeah, a backtracking path parser monad
02:24:20 <hiptobecubic> osfameron, why does it matter if it's cyclic?
02:24:24 <osfameron> but a graph doesn't have a canonical root to ascend to
02:24:24 <mm_freak> combined with a zipper this gives a nice representation of mazes and solutions
02:24:26 <merijn> osfameron: What's the problem with having a cyclic structure? Sure, you have to tie the knot to built it
02:24:35 <merijn> But that you have to do anyway, zipper or not
02:24:48 <hiptobecubic> osfameron, so? A cyclic buffer doesn't have a first element, but you still manage to use it
02:24:50 <ion> mikeplus64: I wonder if there are any imports in my .ghci you’d deem useful for repl? https://gist.github.com/3909552
02:24:52 <merijn> osfameron: You don't need a root to ascend to in a zipper
02:25:06 <osfameron> hiptobecubic, merijn: ok, if you're saying it makes sense, then I'm sure you're right.  All I'm saying is that intuitively it seems different...
02:25:17 <Nereid> zippers are path
02:25:18 <Nereid> s
02:25:26 <mikeplus64> ion: woah that's a hefty import list
02:25:32 <merijn> osfameron: The trick is that zipper have nothing to do with roots, I think the canonical zipper example actually obscures this idea and it took me a while to get over it
02:25:45 <osfameron> ok, I'll have a think about it later
02:25:58 <osfameron> is tying the knot + zipper a fairly sensible way to do graphs then?
02:26:24 <osfameron> I thought you'd tend to represent graphs as adjacency matrices instead in purely FP datastructures?
02:26:24 <merijn> osfameron: You just explode one node in your structure as "current", when you move right (FSVO) you explode the node your moving to and implode ("zip") the node you leave into an actual graph node
02:26:32 <mikeplus64> ion: (but yes, thanks)
02:26:41 <Lethalman> but the thing here is just a state of a list of best nodes, a zipper would contain that so I wouldn't say it's a path in the graph
02:27:08 <merijn> osfameron: Depends on what you're doing, for graph analysis a matrix makes much more sense, for a navigation graphs (think game/maze) a zipper makes more sense, as you have a "current" location you can move from/to
02:27:08 <Nereid> zippers are paths FSVO path
02:27:09 <Lethalman> the state is (sorted list of best nodes to be visited, visited nodes)
02:27:12 <Nereid> :v
02:27:12 <Lethalman> where's the path here?
02:27:16 <osfameron> merijn: with the structure being cyclic, isn't there a danger that a node you've "changed" will still be pointed at (unchanged) via another route?
02:27:32 <merijn> osfameron: No, because you can only change the active node, which is not in the structure
02:27:46 <merijn> It's unzipped
02:28:06 <osfameron> merijn: ok, I'll have more of a think about this later!
02:29:31 <Nereid> hmm
02:29:34 <srhb> I should probable handle this problem from the bottom instead, making a graph ADT and parsing the 2D maze to such a graph.
02:29:38 <Lethalman> is zipper any useful for breadth first search?
02:29:54 <Nereid> @let m2l = Data.Foldable.toList :: Maybe a -> [a]
02:29:57 <lambdabot>  Defined.
02:30:15 <MasseR> Hmph. All my attempts to speed up computation using strategies end up slowing down from the original :<
02:30:32 <notdan> @source m2l
02:30:32 <lambdabot> m2l not available
02:30:34 <Nereid> oops
02:30:38 <Nereid> I want the other thing.
02:30:41 <notdan> @source Data.Foldable.toList
02:30:41 <lambdabot> Data.Foldable.toList not available
02:30:41 <Nereid> listToMaybe
02:31:02 <shachaf> @@let l2m = preview folded
02:31:04 <shachaf> @let l2m = preview folded
02:31:06 <lambdabot>  Defined.
02:31:18 <Nereid> no wait never mind.
02:31:35 <shachaf> @ty l2m
02:31:37 <lambdabot> (Foldable f, MonadReader (f b) m) => m (Maybe b)
02:31:43 <shachaf> good type
02:31:47 <Nereid> heh
02:31:47 <merijn> notdan: @src is just a "lookup" function that lookups of explicitly defined terms to "source", if you want to read the actual source, go to Hoogle and click the source link
02:32:26 <shachaf> merijn: That's not too effective when the actual source is defined three lines above.
02:32:27 <fmap> @ty (^? _head)
02:32:29 <lambdabot> Cons (->) (Accessor (First b)) t t b b => t -> Maybe b
02:32:35 <notdan> merijn: i see, i see
02:32:36 <notdan> thanks
02:32:45 <Nereid> fmap: _head is unsafe
02:32:51 <shachaf> Nereid: It is?
02:32:51 <Nereid> > [] ^? _head
02:32:54 <lambdabot>   Nothing
02:32:57 <Nereid> it isnt"/
02:32:58 <Nereid> ?
02:32:58 <Nereid> oh
02:33:04 <Nereid> where did I read that it was.
02:33:13 <shachaf> Maybe you're thinking of "head".
02:33:16 <fmap> > [] ^. _head
02:33:17 <Nereid> maybe.
02:33:19 <lambdabot>   ()
02:33:23 <fmap> wat
02:33:31 <Nereid> > ([] :: [Int]) ^. head
02:33:32 <Nereid> > ([] :: [Int]) ^. _head
02:33:35 <shachaf> "head" is a little-known function from an obscure module named after a musical form.
02:33:35 <lambdabot>   mueval-core: Time limit exceeded
02:33:35 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
02:33:36 <lambdabot>    arising from a use of...
02:33:43 <Nereid> > ([] :: [Int]) ^? _head
02:33:46 <lambdabot>   Nothing
02:33:48 <ion> fmap: mempty :: ()
02:34:02 <fmap> ah, defaulting
02:34:03 <fmap> sure
02:34:05 <DrSyzygy> shachaf: Fugue? Chacha? Waltz? Breakbeat?
02:35:09 <donri> > [a,b,c]^._head :: [Expr]
02:35:12 <lambdabot>   Couldn't match type `Debug.SimpleReflect.Expr.Expr'
02:35:12 <lambdabot>                 with `[...
02:35:12 <lambdabot> donri: You have 1 new message. '/msg lambdabot @messages' to read it.
02:35:20 <ion> > ([] :: Sum Integer) ^. head
02:35:23 <lambdabot>   Couldn't match expected type `Data.Monoid.Sum
02:35:24 <lambdabot>                              ...
02:35:26 <ion> > ([] :: Sum Integer) ^. _head
02:35:26 <Nereid> > [a,b,c]^.._head :: [Expr]
02:35:30 <lambdabot>   mueval-core: Time limit exceeded
02:35:30 <lambdabot>   mueval-core: Time limit exceeded
02:35:32 <Nereid> > [a,b,c]^.._head :: [Expr]
02:35:32 <ion> > ([] :: Sum Integer) ^. _head
02:35:36 <Nereid> lol
02:35:36 <lambdabot>   mueval-core: Time limit exceeded
02:35:36 <lambdabot>   mueval-core: Time limit exceeded
02:35:39 <ion> This isn’t working very well. :-D
02:35:42 <Nereid> > [a,b,c]^.._head :: [Expr]
02:35:44 <lambdabot>   [a]
02:35:48 <ion> > ([] :: Sum Integer) ^. _head
02:35:51 <lambdabot>   Couldn't match expected type `Data.Monoid.Sum
02:35:51 <lambdabot>                              ...
02:35:59 <Nereid> > ([] :: [Sum Integer]) ^. _head
02:36:00 <ion> d’oh
02:36:02 <lambdabot>   Sum {getSum = 0}
02:36:32 <Nereid> :t _head
02:36:33 <lambdabot> Cons (->) f s s a a => LensLike' f s a
02:36:33 <ion> The timeout probably shouldn’t be based on real time, but CPU time.
02:36:44 <shachaf> DrSyzygy: It should be called "Quodlibet".
02:36:50 <DrSyzygy> :-)
02:36:56 <edwardk> _head = _Cons._1
02:36:58 <fmap> I think _head was unsafe some time ago
02:37:08 <edwardk> fmap: forever ago in lens years
02:37:13 <shachaf> DID Y'ALL SEE MY FUN PUN
02:37:21 <edwardk> [1..10]^?_head
02:37:26 <edwardk> > [1..10]^?_head
02:37:28 <lambdabot>   Just 1
02:37:29 <edwardk> > []^?_head
02:37:32 <lambdabot>   Nothing
02:37:33 <tdammers> shachaf: if it helps you, I giggled a bit
02:37:46 <shachaf> AS IN (A) https://en.wikipedia.org/wiki/Quodlibet (B) https://en.wikipedia.org/wiki/Principle_of_explosion
02:37:49 <shachaf> JUST SAYIN'
02:37:56 <elkng> shachaf:  what are you talking about ?
02:38:06 <edwardk> bout 2 months back someone made a strong case for moving the partiality of those lenses into combinators. its worked out amazingly well.
02:38:15 <edwardk> you can use 'singular" to assert something will be there
02:38:22 <edwardk> > [1,2,3]^. singular _head
02:38:25 <lambdabot>   1
02:38:31 <edwardk> > [1,2,3]^?!  _head
02:38:34 <lambdabot>   1
02:38:34 <edwardk> or that
02:38:38 <Nereid> mm
02:38:43 <edwardk> > []^?! _head
02:38:45 <Nereid> :t singular
02:38:46 <lambdabot>   *Exception: (^?!): empty Fold
02:38:47 <lambdabot> (Functor f, Conjoined p) => Over p (Control.Lens.Internal.Bazaar.BazaarT p f a a) s t a a -> Over p f s t a a
02:38:47 <elkng>                    
02:38:58 <Nereid> uh
02:39:01 <edwardk> pay no attention to how that sausage gets made ;)
02:39:11 <edwardk> it provides a bunch of example sigs ;)
02:39:18 <Nereid> indeed
02:39:19 <shachaf> Hmm, is singular about linearity or just relevance?
02:39:31 <tdammers> shachaf: heh, I hadn't actually thought of *that* meaning
02:39:49 <edwardk> :t unsafeSingular
02:39:50 <lambdabot> (Functor f, Conjoined p) => Over p (Control.Lens.Internal.Bazaar.BazaarT p f a b) s t a b -> Over p f s t a b
02:39:53 <edwardk> that deals with both
02:39:58 <edwardk> :t singular
02:40:00 <lambdabot> (Functor f, Conjoined p) => Over p (Control.Lens.Internal.Bazaar.BazaarT p f a a) s t a a -> Over p f s t a a
02:40:03 <shachaf> tdammers: With this being a Prelude that contains partial functions.
02:40:11 <edwardk> with singular we can't change target types
02:40:20 <shachaf> Perhaps my puns are too good (and/or bad) for this earth.
02:40:28 <edwardk> unsafeSingular lets you in exchange for throwing errors ifthere is more than one target.
02:40:49 <Nereid> > [1,2,3]^. unsafeSingular _head
02:40:51 <lambdabot>   1
02:41:03 <edwardk> so singular works well with any relevant traversal, unsafeSingular really needs it to be linear.
02:41:10 <Nereid> > [1,2,3] & unsafeSingular _head .~ 'a'
02:41:11 <tdammers> shachaf: I figured quodlibet as in a collection of loosely related random things
02:41:12 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
02:41:12 <lambdabot>    arising from the literal `1...
02:41:23 <shachaf> tdammers: That too.
02:41:33 <edwardk> _head isn't a type changing lens
02:41:35 <Nereid> duh
02:41:36 <shachaf> It's a multi-way pun!
02:41:42 <tdammers> fun fact: 'Prelude' and 'Foreplay' are the same word in German
02:41:45 <tdammers> just sayin'
02:42:16 <shachaf> fun fact 0 = 1
02:42:20 <osfameron> heh, what's the word?
02:42:27 <shachaf>   | fact n = n * fact (n - 1)
02:42:32 <Nereid> :(
02:42:42 <Nereid> why shachaf.
02:42:48 <edwardk> shachaf: i had an old abandoned sigma-type-only type system that i called 'ex falso' the executable was quodlibet
02:42:48 <shachaf> why what
02:42:52 <Nereid> why you
02:42:58 <mauke> JSB Sebastian Bach, "Vorspiel und Fuge"
02:43:27 <ion> > let fun fact 0 = 1 | fact n = n * fun fact (n - 1) in fun "fact" 5
02:43:27 <DrSyzygy> So if we look in the Haskell module for foreplay, we find both head and tail ?
02:43:29 <lambdabot>   <hint>:1:20: parse error on input `|'
02:43:29 <mysticc> I was writing a parser and want to parse a datatype for which I have derived a show and read instance? How do I make a parser from the read instance of that datatype?
02:43:37 <osfameron> ah of course, "pre - lude" is literally "before - play"
02:43:38 <shachaf> edwardk: I've wondered what sigma-type-only type systems would be like.
02:43:42 <ion> Duh, too tired.
02:43:48 <shachaf> What are they like?
02:43:52 <mauke> (it's actually "Präludium")
02:44:02 <donri> shachaf: hah that's real syntax in some language isn't it
02:44:09 <edwardk> shachaf: at the time i was rather enamored of http://research.microsoft.com/en-us/um/people/simonpj/papers/not-not-ml/index.htm
02:44:17 <shachaf> donri: SoMe Language
02:44:22 <edwardk> this was 2006, and i as new to haskell
02:44:27 <donri> ah
02:44:42 <shachaf> SPJ has the best paper titles.
02:45:34 <mauke> http://www.pps.univ-paris-diderot.fr/~vouillon/smot/
02:45:48 <edwardk> anyways, when you take that approach, you wind up without meaningful pi types iirc, leaving you only sigma types to carry the work load. its been several years though
02:45:57 <edwardk> so i only remember the outline
02:46:27 <shachaf> Pi types. Pypes.
02:48:52 <shachaf> That paper has a very creative naming scheme.
02:49:09 <ion> craming scheme.
02:49:11 <ion> creme.
02:49:26 <shachaf> An intermediate language called "IL", strict and non-strict languages called "SL" and "LL", an abstract machine called "AM"
02:50:53 <elkng> its impossible to use keyboard and mouse with xbox or PS3 ?
02:51:03 <Nereid> xbox 360 yes, ps3 no
02:51:19 <Nereid> as in, you can't with 360, and can with ps3
02:51:42 <Nereid> as far as I know.
02:51:45 <Nereid> maybe I'mw rong.
02:51:51 <shachaf> I think it is possible with the former.
02:51:54 <shachaf> But also off-topic.
02:51:56 <Nereid> true.
02:52:06 <Nereid> I forgot what channel I was in.
02:58:52 <shachaf> Hmm.
02:59:07 <shachaf> If you have a nullary class, would instances for it have to be orphans?
02:59:20 <shachaf> Well, that or in the same module as the class.
03:00:07 <aleator> How on earth do I get the seconds out of DiffTime? I need to print it with a non-default show.
03:02:08 <Nereid> aleator: toRational from its Real instance would do it.
03:02:36 <Nereid> so would stuff from its RealFrac instance
03:02:44 <Nereid> :t floor
03:02:46 <lambdabot> (Integral b, RealFrac a) => a -> b
03:04:43 <Nereid> hmm
03:04:51 <Nereid> looks like it uses Data.Fixed.Pico as its underlying type.
03:05:38 <aleator> Nereid: Ah. Thanks. I missed that.
03:09:41 <osa1> why do some people prefer do{ ..; ..; } syntax over indentation based do ? I can understand if whole do block is used in one line or some smaller space but I can see some uses with one do-statement per line, but still used in { ; ; ; } syntax.
03:09:52 <shachaf> People prefer the syntax they prefer.
03:10:06 <shachaf> Arguments about syntax aren't worth the trouble.
03:10:16 <osfameron> maybe it seems more familiar from C/Perl/Javascript/etc. ?
03:10:22 <tdammers> I guess some people have had too much bad experiences with python
03:10:28 <osfameron> I preferred it for a day or two, and then got used to haskell's indentation rules
03:19:27 <merijn> osa1: I suspect brain damage from being dropped on their head as a kid :>
03:23:24 * hackagebot creatur 2.0.12 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-2.0.12 (AmyDeBuitleir)
03:23:40 <tdammers> personally, I prefer indentation-based for longer stuff, and plain (non-do) syntax for one-liners
03:25:57 <Maxdamantus> > text (text "monoids")
03:25:59 <lambdabot>   Couldn't match expected type `GHC.Base.String'
03:25:59 <lambdabot>              with actual typ...
03:26:05 <osa1> strange part is GHC authors also uses that syntax https://github.com/ghc/ghc/commit/677144b858f4a425e77399bdfbfcd43dbabd1488#L7R140
03:27:36 <johnw> huh, that change even changes some layout-based code to use ;.  Don't quite understand it
03:29:34 <xnyhps> I'm just following what I see most often in GHC there.
03:31:30 <yitz> osa1: i think those ghc modules have been around for a very long time. nowadays you very rarely see that style.
03:32:08 <yitz> osa1: but if you like it - go right ahead, don't let us stop you.
03:33:07 <osa1> I prefer indentation-based one, looks cleaner
03:33:15 <gspr> Suppose I have a  class Foo a where toPair :: a -> (Int, Int), or something like that. May I not used UndecidableInstances to say instance (Foo a) => Eq a where x == y = (toPair x) == (toPair y)?
03:33:24 * hackagebot tls 1.1.2.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.1.2.1 (KetilMalde)
03:33:29 <gspr> *used = use
03:33:29 <johnw> everyone is a domain expert when it comes to their preferences
03:33:51 <Nereid> johnw: where?
03:33:54 <donri> spj prefers braces and semicolons because it means you don't have to indent nested do's, that's why ghc uses that style
03:33:57 <donri> i hear.
03:34:03 <merijn> gspr: Wait, what the hell is that supposed to do?
03:34:04 <Nereid> er
03:34:24 <yitz> > let noop = show . text in noop . noop . noop $ "monoids"
03:34:27 <lambdabot>   "monoids"
03:35:13 <t7> :t text
03:35:14 <lambdabot> String -> Doc
03:35:26 <Nereid> text "hi" + 2
03:35:28 <Nereid> > text "hi" + 2
03:35:30 <lambdabot>   No instance for (GHC.Num.Num Text.PrettyPrint.HughesPJ.Doc)
03:35:31 <lambdabot>    arising from...
03:35:33 <Nereid> k
03:35:34 <gspr> merijn: I'm probably just confused now... so I want to say that instances of Foo are also instances of Eq, where equality is defined by representing as pairs?
03:36:00 <fmap> that instance will overlap with everything else
03:36:21 <gspr> yeah, it is.. I can't believe I've never encountered this before
03:36:42 <Nereid> constraints are ignored when checking for overlapping instances
03:36:52 <merijn> gspr: Why not just use
03:37:05 <merijn> (==) `on` toPair?
03:37:08 <gspr> I essentially want to say: "Everything that's an instance of this typeclass can be converted to another (fixed) type (say a pair in this example), and equality (say) is computed using that conversion."
03:37:14 <yitz> gspr: you can say that instances of Foo are required also to be instances of Eq; that's pretty standard.
03:37:26 <merijn> :t on
03:37:28 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
03:37:39 <Nereid> > (f `on` g) x y :: Expr
03:37:41 <gspr> yitz: I know, but I wanted to say "every instance of Foo is automatically an instance of Eq, here's how..."
03:37:41 <lambdabot>   Ambiguous type variable `b0' in the constraints:
03:37:41 <lambdabot>    (GHC.Show.Show b0)
03:37:41 <lambdabot>     ...
03:37:55 <merijn> gspr: You can't
03:38:01 <yitz> gspr: but to force the Eq instance of every Foo instance to be something specific, that's not the way classes are usually used, and it will cause all kinds of complications.
03:38:04 <gspr> merijn: Right.. it's coming back to me now :)
03:38:06 <merijn> gspr: Not in a way that's safe, at least
03:38:07 <Nereid> > ((f :: Expr -> Expr -> Expr) `on` (g :: Expr -> Expr)) x y
03:38:09 <lambdabot>   f (g x) (g y)
03:38:15 <Nereid> @src on
03:38:15 <lambdabot> (*) `on` f = \x y -> f x * f y
03:38:17 <gspr> I have of course seen this before... it's just been a while :)
03:38:23 <gspr> thanks, I should get another cup of coffee now :p
03:38:34 * gspr feels ashamed. Thanks
03:38:37 <gspr> .. for the help
03:39:13 <yitz> gspr: "here's how" doesn't make much sense. once you define Foo, people are allowed to make *any* type an instance of Foo, including many things you never imagined.
03:42:35 <gspr> yitz: Right, but I would then say "to be a Foo, your foo :: a -> Int (or a -> (Int, Int) in my first example) must be so sane that foo x == foo y, it also makes sense that x == y"
03:42:53 <gspr> but really, I do remember now that my question was silly and we cannot do this the way I wrote above :)
03:43:11 <gspr> *so sane that if...
04:00:06 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/7642
04:04:34 <bxc> how hardcore do i have to be to build my own ghc?
04:04:53 <bxc> (as in, how much grief is it going to givem etrying to get it to build)
04:05:08 <shachaf> ./boot && ./configure && make
04:05:14 <mauke> don't need boot
04:05:26 <bxc> (from version control, btw)
04:05:29 <merijn> bxc: Mostly it just takes a lot of time, I think
04:05:31 <shachaf> You don't?
04:05:33 <mauke> the only tricky part is that you need ghc to build ghc
04:05:42 <strebe_> bxc: http://hackage.haskell.org/trac/ghc/wiki/Building
04:05:46 <bxc> heh. well i have an OS ghc already
04:05:51 <merijn> Just install binary ghc, check out new ghc and build using old ghc
04:05:59 <merijn> heh
04:05:59 <bxc> just every now and then I see interesting stuff in head
04:06:06 <mauke> bxc: there's a README with instructions
04:06:08 <merijn> Which OS ships with ghc? :p
04:06:10 <shachaf> Like nullary classes!
04:06:15 <shachaf> I hear those might get into HEAD sometime.
04:06:17 <mauke> shachaf: oh, I was assuming a release version
04:06:19 <bxc> merijn: debian?
04:06:31 <bxc> at least in as much as it ships with vi
04:07:06 <bxc> anyway it sounds doable.
04:07:46 <shachaf> Trap, pitfall for using the ASSERT macro:
04:07:49 <shachaf> The ASSERT macro uses CPP, and if you are unwise enough to try to write assertions using primed variables (ASSERT (not $ intersectsBlockEnv b b')), one possible outcome is that CPP silently fails to expand the ASSERT, and you get this very baffling error message:
04:07:53 <shachaf> good pitfall
04:23:19 <knz> hey
04:23:43 <knz> what does "import qualified X as Y" mean, if there are multiple lines with different X's and the same Y?
04:23:47 <knz> does it merge the namesspaces?
04:24:16 <typoclass> knz: yeah
04:24:21 <knz> kthx
04:25:34 <typoclass> knz: if "foo" exists in the X1 and X2 modules which you both import qualified as Y, then Y.foo will give you an error ("ambiguous"). just like when you import X1 ; import X2, and then try to use "foo"
04:25:46 <knz> yep
04:26:00 <knz> that's what I epxected
04:33:25 * hackagebot nerf 0.4.0 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.4.0 (JakubWaszczuk)
04:38:49 <M30W> Parser time. :|
04:40:08 <M30W> Could anyone here suggest how to use parsec to replace this function? http://ix.io/4da
04:42:02 <Jaak> i don't think you could do much better than that with parsec, unless that's not the entire code you have
04:42:52 <Jaak> and it looks more like a lexing than parsing problem
04:43:42 <M30W> Need to also have optional arguments (depending on the exact type)
04:43:48 <M30W> Gonna split with words
04:43:53 <M30W> (Now parsec help?)
04:43:54 <M30W> Jaak:
04:44:25 <M30W> nsewud  -  should also work with full names :)
04:44:43 <M30W> w
04:49:14 <M30W> Jaak: ?
04:56:05 <wuttf> How come anyhow I format my code it works (as long as I use spaces)?!
04:56:55 <donri> you're not using any syntax that's a layout herald
04:56:57 <merijn> wuttf: tabs == 8 spaces
04:57:15 <mauke> wuttf: er. are you asking why your code works?
04:57:26 <merijn> mauke: I think so
04:57:37 <M30W> Whoah. Just complicated things :3
04:58:01 <wuttf> Yes. I mean, I have written some toy interpreters myself with significant whitespace, they were rigid as hell, and that was hard enough, writing something like GHC, I can't even imagine.
04:58:07 <merijn> wuttf: Basically, haskell doesn't care about how far you indent stuff, as long as you align things to the same indent and at least 1 space more than the previous indent
04:58:21 <mauke> you don't even have to align more
04:58:35 <mauke> you can get seamless nesting
04:58:39 <merijn> wuttf: i.e. if you write "case foo of" then it will align the indent to the first line indented beyond the c of case
04:58:43 <merijn> mauke: Really?
05:00:40 <srhb> Ugh. My brain doesn't bend this way. When building a graph from a 'Vector a' of 'Vector a's (where there's an edge from every element to every element above, below, left or right) do I simply map my way through the inner Vector?
05:00:40 <M30W> Norning world
05:00:44 <M30W> Morning *
05:01:15 <srhb> Directions imagined from seeing the Vector (Vector a) as a matrix
05:01:19 <wuttf> It's just jaw droppingly awesome.
05:02:34 <srhb> I think I'll end up with some infinite recursion with the list of Nodes connected to a given Node.. Hm.
05:03:06 <wuttf> My world is starting to feel like isToyLanguage x = x /= Haskell
05:04:13 <merijn> wuttf: And then you learn Agda and Haskell feels like "Fisher-Price: My First Type System" :p
05:04:17 <M30W> wuttf: isToyLanguage = (/= Haskell) :: Language -> Bool
05:04:35 <wuttf> M30W: :D Lol
05:05:01 <typoclass> @remember wuttf My world is starting to feel like isToyLanguage x = x /= Haskell
05:05:01 <lambdabot> Done.
05:05:02 <M30W> wuttf: isToyLanguage = (Haskell /=) :: Language -> Bool -- Cleaner
05:05:26 <hpaste> t7 pasted “Tried to write 'permutations' without looking at examples :|” at http://hpaste.org/81586
05:05:50 <typoclass> wuttf: same feeling here, btw =) when learning haskell, i kinda lost interest in python, shell, javascript, etc.
05:05:57 <wuttf> merijn: I will only touch Agda and the like when the awe of Haskell land will get old.
05:07:25 <t7> the Data.List one looks ugly too but atleast it doesnt have 'length' or 'last'
05:07:32 <wuttf> typoclass: I am kind of angry. A lot of effort is being spent on polishing turds (other languages).
05:08:29 <t7> merijn, lel
05:08:45 * M30W looks at parsec in confusion. :|
05:09:50 <merijn> @quote being.gentlemen
05:09:51 <lambdabot> No quotes match. My brain just exploded
05:09:53 <merijn> hmm
05:10:17 <merijn> @quote enlightened.gentlemen
05:10:17 <lambdabot> No quotes match. The more you drive -- the dumber you get.
05:10:31 <merijn> :O
05:10:36 <M30W> lol
05:10:36 <merijn> Lambdabot forgot my quote...
05:10:57 <merijn> @remember PenguinOfDoom Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
05:10:58 <lambdabot> I will remember.
05:11:30 <M30W> Anyone here mind helping me understand parsec?
05:11:50 <merijn> M30W: It helps if you have a more specific question :)
05:12:17 <M30W> merijn: One minute trying to fix my current parser :P
05:12:24 <M30W> (Not using parsec)
05:12:30 <M30W> (yet)
05:14:23 * M30W reverted code to working version and made it clear what I'm attempting to do. :)
05:14:27 <wuttf> In a pattern match I replaced a string constant with a "variable" and I got "Qualified name in binding position"
05:14:59 <sipa> wuttf: paste code?
05:15:01 <M30W> merijn: http://ix.io/4db
05:15:07 <wuttf> sipa: Right, sec
05:15:27 * M30W wonders when he reverted that go... old. haha
05:16:03 <danr> M30W: where is the problem?
05:17:15 <M30W> danr: Parsing the user input correctly; Intending to use the commented out definition for Interaction
05:17:36 <M30W> (Also a rename for Interaction would be appreciated too) =)
05:17:57 <danr> Commands?
05:18:08 <danr> maybe you should name your x function to parseCommand or something descriptive
05:18:32 <M30W> Haha; yea, was gonna do that when... I had the parsec parser.
05:19:26 <wuttf> sipa: NVM I think I wanted to use pattern matching in a way what does not make a lot of sense.
05:19:47 <danr> so if you use your other ADT for Interaction, you need to give these string arguments to Talk and Use and so forth in the function named x
05:20:12 <danr> x ("examine ":item) = Right (Examine item)
05:20:13 <danr> or so
05:20:29 <danr> uh
05:20:30 <M30W> Yea I did that but.. It's not a parsec parser.
05:20:37 <danr> right that doesn't type check, but
05:20:42 <M30W> I know
05:20:43 <M30W> That too
05:21:01 <danr> x s | ("examine ",item") <- splitAt (length "examine ") = Right (Examine item)
05:21:06 <danr> using PatternGuards
05:21:16 <danr> um and s as argument to splitAt
05:21:48 <M30W> danr: Hmmmmm.
05:21:58 <danr> anyway, did you have an actual quaestion or am I just saying things you already know? :)
05:21:58 <M30W> Still shouldn't typecheck
05:22:14 <M30W> As I'm not after a string for the item but an item literal.
05:22:24 <danr> ok, then you have to parse that too :)
05:22:29 <M30W> Which is in the room's data... rItems
05:23:08 <M30W> danr: Question is; how can I do all this with parsec?
05:23:24 <basdirks> is moving to GHC 7.6 going to be painful?
05:23:43 <danr> M30W: oh. well. did you use it before?
05:23:46 <M30W> basdirks: I have 7.6 (Stable in archlinux-repos) it's working fine.
05:23:48 <basdirks> ie. what packages will give me trouble
05:23:53 <danr> basdirks: darcs
05:23:59 <M30W> danr: I have never used parsec before.
05:24:17 <basdirks> jjjjkkkkkkkkkkkkkkkkjj
05:24:26 <danr> M30W: maybe start with the RWH chapter about it: http://book.realworldhaskell.org/read/using-parsec.html
05:24:41 <M30W> AHH
05:24:51 <M30W> Keep getting back to this page but it means nothing to me :|
05:25:28 * M30W is clueless on how to convert it into my text adventure.
05:25:44 <basdirks> does anyone know how 7.6 behaves on Mac?
05:26:17 <merijn> basdirks: Normal?
05:26:28 <M30W> basdirks: It alone shouldn't be platform dependant, depends on the packages.
05:26:28 <merijn> Not really sure what kind of answer you're expecting here...
05:26:46 <basdirks> merijn: known quirks?
05:26:57 <basdirks> if there are none: awesome
05:26:59 <merijn> Works For Me (TM)
05:27:29 <merijn> Just install the OSX binary somewhere and make sure it's in your PATH before any ghc from Platform
05:27:47 <basdirks> cool
05:28:22 <merijn> I use 7.4 from platform and then manually juggle my path when I want to play with 7.6 and so far everything has just worked
05:28:34 <M30W> danr: I also need to get the item name from the item list defined for the given room.
05:28:46 <M30W> (Before parsec can identify if it's valid or not)
05:28:49 <basdirks> I want to see what holes are like
05:30:13 <monoidal> basdirks: holes are not in 7.6
05:30:48 <merijn> But DataKinds and type promotion is! \o/
05:31:00 <monoidal> they're in 7.4
05:31:00 <shachaf> Just wait a couple of week for 7.8 to come out.
05:31:24 <M30W> danr: First time in attempt to use parsec and I start with something complicated. :|
05:31:24 <basdirks> oh i c
05:34:25 <srhb> Hum. Am I missing something, or is there no (!?)-like function for Data.Array?
05:34:59 <monoidal> srhb: what is (!?)
05:35:14 <basdirks> if I want to play with new GHC features, should I use HEAD or go with 7.6?
05:35:21 <srhb> (!?) :: Array i a -> i -> Maybe a
05:35:52 <srhb> @hoogle Array i a -> i -> Maybe a
05:35:53 <lambdabot> Data.Array (!) :: Ix i => Array i e -> i -> e
05:35:53 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
05:35:53 <lambdabot> Data.Graph.Inductive.Graph lab :: Graph gr => gr a b -> Node -> Maybe a
05:36:04 <srhb> How annoying.
05:36:05 <powergiant> Can somebody tell how I can do floating point operations without ending with things along the line of 3.9999999994e-3 ?
05:36:07 <hpaste> Powergiant pasted “Floating point” at http://hpaste.org/81587
05:36:19 <monoidal> basdirks: for very new, use HEAD, but even 7.6 gives many opportunities to play
05:37:00 <shachaf> srhb: I think lens can do it, for what it's worth.
05:37:31 <srhb> Yeah.
05:37:35 <typoclass> powergiant: in my opinion floating point is sneaky and too clever for its own good. it hat its niches, but i wish fixed point was more used
05:37:36 <shachaf> > listArray (0,5) "abcdef"
05:37:39 <lambdabot>   array (0,5) [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f')]
05:37:45 <typoclass> powergiant: check out Rational and Data.Fixed
05:37:46 <shachaf> > listArray (0,5) "abcdef" ^? ix 4
05:37:49 <lambdabot>   Just 'e'
05:37:50 <shachaf> > listArray (0,5) "abcdef" ^? ix 6
05:37:52 <lambdabot>   Nothing
05:38:57 <powergiant> typoclass: I'll lok at those. thanks! :)
05:40:17 <M30W> danr: ping
05:40:25 <danr> M30W: if you know BNF you could use bnfc or bnfc-meta
05:40:40 <M30W> bnfc?
05:41:06 <danr> it's a program called the bnf converter, which generates haskell datatypes and a parser given a BNF specification
05:41:31 <M30W> O.o
05:41:33 <M30W> Cheater
05:41:36 <M30W> Sounds nice
05:42:03 <danr> M30W: http://hackage.haskell.org/package/BNFC, http://bnfc.digitalgrammars.com/
05:42:21 <frerich> danr: Do you know whether there's something similiar for DTDs or RelaxNG schemata, i.e. something which generates data types and specialized XML parsers interpreting the defined language?
05:42:56 <danr> frerich: no, I don't know unfortunately
05:43:02 <danr> but admittedly that would be nice to have
05:43:18 <mm_freak_> typoclass: why?  what's wrong with floats compared to fixed points?
05:43:27 * hackagebot hastache 0.5.0 - Haskell implementation of Mustache templates  http://hackage.haskell.org/package/hastache-0.5.0 (SergeyLymar)
05:43:34 <M30W> formats/c-sharp/CSharpTop.hs:362:19: Not in scope: `catch'
05:43:39 <M30W> -_-
05:43:53 <danr> M30W: send in a patch!
05:44:02 <M30W> danr: Ughh
05:44:08 <M30W> Fri Feb  1 00:43:52 EST 2013
05:44:23 * M30W hasn't slept in too long; not gonna send an import patch now.
05:45:36 <danr> what timezone are you in? new zealand?
05:46:06 <M30W> danr: Also Item's name can contain spaces which doesn't help :P
05:46:06 <M30W> grab a b c d (grab all items) say hello (to person)
05:46:06 <M30W> where to person is optional.
05:46:06 <M30W> PARSER :(
05:46:17 <M30W> Output is easy; input.... D:
05:46:19 <M30W> danr: Aus
05:46:53 <M30W> Speaking of output... I need to figure out a way to display the information for which ways you can navigate.
05:48:11 <mm_freak_> edwardk: is tables ready for production?
05:48:15 <mm_freak_> or should i wait?
05:48:27 * hackagebot aws-sdk 0.10.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.10.0 (YusukeNomura)
05:49:54 <danr> M30W: bnfc compiled on my 7.6.1 installation
05:49:57 <hpaste> typoclass annotated “Floating point” with “Floating point (annotation)” at http://hpaste.org/81587#a81588
05:51:29 <typoclass> powergiant: i think a quick fix for your problem is just adding a type signature, to force it to use Rational (that's a fraction with an Integer numerator and Integer denominator). hint: if you compile the old code with -Wall, it actually warns you, "Defaulting to Double"
05:54:04 <typoclass> mm_freak_: well, basically the original question ... "why do simple straightforward calculations give weird stuff like 1.999999997". i always feel like to use floats correctly, you have to be a huge expert on all the stuff listed on http://en.wikipedia.org/wiki/Floating_point . which is more trouble than it's worth
05:55:18 <mm_freak_> typoclass: i accept your premise, but i reject your conclusion
05:55:23 <mm_freak_> fixed points make this worse
05:55:52 <mm_freak_> the problem is that the base is 2 and not the more human-compabile 10
05:56:32 <mm_freak_> what you need is either a floating point type with a different base (slow!) or an entirely different representation
05:56:47 <Nereid> CReal =)
05:57:12 <Nereid> honestly, using floating point for currencies is broken
05:57:19 <mm_freak_> powergiant: fixed points won't solve your problem, but likely make it worse…  try to understand floating point numbers and what it means to write numeraically stable code
05:57:39 <mm_freak_> numerically
05:58:53 <mm_freak_> and yes, what Nereid said
05:59:12 <Nereid> I don't know what you're advocating then.
05:59:18 <Nereid> float is bad, fixed point is bad.
05:59:26 <Nereid> (is fixed point that bad for this purpose?)
05:59:33 <mm_freak_> base 2 representation is bad for currencies
05:59:42 <Nereid> or some decimal thing sure.
05:59:47 <Nereid> or Rational.
05:59:58 <mm_freak_> Rational will explode quickly…  you need some pointy representation
06:00:00 <typoclass> Nereid: i'm not sure, i put Centi (from Data.Fixed) in his code and it seems to work well
06:00:15 <Nereid> sure, but now you're assuming the currency is divided into units of 100.
06:00:23 <Nereid> 1/100.
06:00:31 <Cale> Data.Fixed is decimal fixed point
06:00:38 * shachaf notes that the person who asked the question hasn't said anything for 20 minutes.
06:01:50 <mm_freak_> > 1 % 101 + 1 % 103
06:01:52 <lambdabot>   Not in scope: `%'
06:01:52 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)Not in...
06:02:01 <mm_freak_> > 1 R.% 101 + 1 R.% 103
06:02:03 <lambdabot>   204 % 10403
06:02:06 <powergiant> I fell the current discussion is slighty above my level, and don't have anything meaningfull to add.
06:02:16 <Nereid> > 1/101 + 1/103 :: Rational
06:02:18 <lambdabot>   204 % 10403
06:02:46 <mm_freak_> powergiant: the problem is that a floating point number is this:  m + 2^e, where m and e are integers
06:02:50 <typoclass> Nereid: yeah, but his program was about "for 15 cents, you need one dime and one nickel". i think it's reasonable to base this program on whole cents. i don't think the americans have coins with fractions of a cent
06:02:59 <Nereid> sure. :p
06:03:01 <mm_freak_> powergiant: a value like 0.1 can't be represented exactly in this system
06:03:06 <typoclass> Nereid: ;-)
06:03:32 <mm_freak_> huh?  did i write +?
06:03:43 <mm_freak_> powergiant: the problem is that a floating point number is this:  m * 2^e, where m and e are integers
06:03:47 <mm_freak_> sorry =)
06:04:44 <Nereid> e.g. the Kuwaiti dinar is divided into 1000 fils, and they actually have coins worth 5 fils.
06:04:45 <Nereid> apparently.
06:04:47 <powergiant> mm_freak_: Yes I understand that. It's just that there seems to be some disagrement to what a proper solution should be. I looked at Data.Fixed but honestly don't know what to make of it hehe
06:04:55 <hpaste> typoclass annotated “Floating point” with “Another alternative. But maybe it's not as good as Rational” at http://hpaste.org/81587#a81589
06:05:09 <typoclass> powergiant: ^^ second alternative for you
06:05:09 <mm_freak_> powergiant: basically any decimal representation with a high enough precision would suffice
06:05:12 <Nereid> do we have anything for floating decimal point?
06:05:20 <Nereid> er decimal floating point
06:05:37 <typoclass> Nereid: Rational with a denominator of 100 or 10000 or whatever?
06:05:45 <Nereid> I guess
06:05:50 <z3phyr> What all will be ammended in the standard for haskell prime
06:05:55 <z3phyr> ?
06:06:13 <mm_freak_> Rational would need to be normalized all the time (slow and inconvenient)
06:06:14 <Nereid> go see the haskell' site I guess
06:06:17 <z3phyr> in 2013.
06:06:37 <powergiant> typoclass: The second one makes sense to me.
06:07:22 <mm_freak_> powergiant: what's your main operation?  addition or multiplication?
06:07:27 <powergiant> but as Nereid said, I should properly look more into how numbers work.
06:07:36 <Nereid> did I say that? =)
06:07:43 <mm_freak_> i think, that was me =)
06:07:44 <typoclass> powergiant: right, the first just has output which is a little hard to read. "3 % 7" is a fraction, three sevenths. "0 % 1" is telling you "zero", "1 % 1" is "one"
06:07:46 <Nereid> there's some paper on like
06:07:53 <Nereid> what every computer scientist needs to know about floating point or so
06:08:00 <powergiant> mm_freak_: multiplication
06:08:02 <z3phyr> I wish they include concurrency in the standard :)
06:08:17 <hpaste> typoclass annotated “Floating point” with “And a third alternative. I like this one best” at http://hpaste.org/81587#a81590
06:08:25 <mm_freak_> powergiant: then to get additional precision and faster operations you may want to look into logarithmic floats
06:08:34 <jrajav> This one?
06:08:36 <jrajav> http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html
06:08:41 <jrajav> @Nereid
06:08:41 <lambdabot> Unknown command, try @list
06:08:47 <Nereid> yeah
06:09:10 <Nereid> everyone who uses floats should read that, really
06:09:14 <typoclass> powergiant: i think the easy way out is to use Int or Integer to represent whole cents. that lets you sidestep the whole float mess
06:09:21 <typoclass> (see hpaste)
06:09:43 <powergiant> typoclass: You make a strong point there
06:09:47 <mm_freak_> powergiant: logarithmic float means that a number y is represented as y = 10^(m * 2^e)
06:09:58 <typoclass> mm_freak_: btw, i'm not an expert ... any objections to using Int for whole cents?
06:09:59 <mm_freak_> the advantage is that multiplication is as cheap as addition
06:10:06 <Nereid> how is addition cheap there?
06:10:16 <mm_freak_> typoclass: his main operation is multiplication, so cent level is not precise enough
06:10:28 <Nereid> multiplication by what?
06:10:32 <Nereid> multiplying fractional dollars together?
06:10:37 <Nereid> multiplying by an integer?
06:10:41 <mm_freak_> Nereid: addition is expensive, but multiplication is cheap
06:10:45 <Nereid> if you're multiplying by an integer, it's fine.
06:11:03 <typoclass> jrajav: thanks, nice link
06:11:19 <Nereid> what about me :(
06:11:33 <typoclass> mm_freak_: could you elaborate? i see a fair bit of subtraction, but no multiplication
06:11:52 <z3phyr> Parallel scientific is using Haskell
06:11:53 <mm_freak_> typoclass: i didn't see the code, i asked him =)
06:12:07 <typoclass> mm_freak_: er ... ok =)
06:12:14 <Nereid> powergiant: anyway, Centi represents numbers internally as Integers, but the operations are such that they just look like exact multiples of 0.01
06:12:52 <z3phyr> How to get it included in 'jobs' and 'haskell in industry' ?
06:13:07 <jrajav> Don't some financial applications require fractional cents?
06:13:22 <typoclass> powergiant: anyway, i'd go with alternative #3, unless any experts voice any objections
06:13:27 * hackagebot repl 0.92 - IRC friendly REPL library.  http://hackage.haskell.org/package/repl-0.92 (MikeLedger)
06:14:13 <Nereid> I would too.
06:14:36 <z3phyr> http://www.parsci.com/jobs
06:14:58 <powergiant> Yes I'm going with whole numbers. Much better
06:15:06 <powergiant> (read easier)
06:15:19 <Nereid> not Centi?
06:15:31 <edwardk> mm_freak_: it has users now. the main thing i'd like to change would be a template haskell generator for the tabular instances but they are mostly boilerplate
06:15:55 <powergiant> Is there any reason to use Centi ?
06:16:38 <Nereid> you can keep using 0.01 and whatever.
06:17:18 <typoclass> powergiant: just to be clear, how the output looks is something that can be fixed. you can make your own show function for that
06:17:27 <Philippa> code I possibly shouldn't have written: allTheMetaTerm = Fix $ Stack $ O $ Annotate "OFFS" $ T $ Term $ V 1
06:17:44 <Nereid> most of those $ can be replaced with .
06:17:48 <Philippa> (it's a term from Hutton's Razor. Annotated "OFFS", for good reason)
06:17:54 <Nereid> :c
06:17:57 <Philippa> Nereid: I think you've missed the point :-)
06:18:00 <exicer> So would you guys suggest an average imperative programmer would get much from using Haskell  ?
06:18:07 <Nereid> I must have
06:18:19 <Nereid> everyone would get something out of using haskell, I think.
06:18:21 <Philippa> exicer: not a guy here, but yeah, definitely
06:18:27 <Nereid> at the very least, a fresh perspective.
06:18:38 * typoclass stops purring, hisses at philippa and backs away towards his hiding spot
06:18:39 <Philippa> heck, I've a linguist friend who's been learning Python and is positively excited to learn some Haskell
06:18:57 <exicer> Philippa: My apologies ;)
06:19:14 <typoclass> exicer: oh yes, absolutely =) it will make you a better programmer, no matter if you end up using haskell or another language
06:19:17 <exicer> Okay, so I can see it would be useful perspective
06:19:29 <Philippa> it also makes you cranky about type systems, though
06:19:46 <typoclass> Philippa: ... mostly lack thereof!
06:19:46 <exicer> But my concern is that it seems like it would take a very long time (if you are not some kind of super human) to get good enough with Haskell to actually use it on anything
06:19:52 <frerich> exicer: You'd most certainly get a lot out of it. Primarily frustration with whatever language you have to use at your day job.
06:20:18 <Philippa> exicer: depends on your problem domain. I reckon I'll have my linguist friend writing parsers /from scratch/ within a few hours
06:20:43 <z3phyr> Haskell would be a lot easier for a person with a primary functional background
06:20:47 <typoclass> exicer: check out this textbook, it's free
06:20:47 <exicer> Philippa: I'm working in Bioinformatics - it seems like it is a pretty applicable domain
06:20:49 <typoclass> @where lyah
06:20:49 <lambdabot> http://www.learnyouahaskell.com/
06:21:10 <Nereid> quite a good introduction, yes
06:21:10 <Philippa> *nod*
06:21:30 <Philippa> yeah, it's not one I've directly touched and you might have a few tedious concrete details to work out but I'd expect it to go well
06:21:37 <exicer> If it's going to take me 6 months to get to the point of being able to make something useful, it might be a bit too lengthy..
06:21:39 <mm_freak_> edwardk: i don't understand the makeLensesWith stuff yet, but i'll look into it
06:21:47 <z3phyr> first six chapters are really cool for total begins
06:22:05 <exicer> I actually already read the first 6 chapters, it seems ok
06:22:13 <Nereid> z3phyr: and the rest aren't?
06:22:29 <z3phyr> the rest are cooler
06:22:32 <Nereid> haha
06:22:34 <exicer> I/O seems very far away though!
06:22:34 <Nereid> :)
06:22:41 <z3phyr> I said *beginners*
06:22:42 <Philippa> *phew*, looks like that tunnel didn't quite take long enough to kill my TCP connection :-)
06:23:13 <Philippa> exicer: basic IO's pretty easy when you get there. The rest has a more subtle learning curve than a language like C, but suddenly goes *click* and you can do nearasdammit everything
06:23:52 <edwardk> mm_freak_: basically ideally you'd say something like makeTabular ''Foo ''fooId [CandidateHash ''fooBar, InvertedInt ''fooBaz]
06:23:54 <typoclass> exicer: i recall my first tiny haskell program was a tool like 'which' but listing all the paths where the binary was found, not just the first. it was 20 lines or so. start with something like that, you'll learn quite a bit of haskell and still have something more or less useful come out of it
06:24:06 <mm_freak_> edwardk: also is there supposed to be a type parameter for the row type?
06:24:22 <mm_freak_> (where "row type" would be Foo in the example)
06:24:31 <edwardk> Table t ~ [t]
06:24:37 <exicer> Well I shall dive in and have a go then
06:24:37 <edwardk> well logically anyways
06:24:42 <mm_freak_> yeah, i got that
06:24:47 <edwardk> in the Foo example. i bothered to make it parametric
06:24:53 <edwardk> so you can do things like
06:24:56 <exicer> I'm a pretty average programmer though, and I guess it may take me a rather long time to get anywhere!
06:25:15 <edwardk> test & rows.fooBar_ %~ length
06:25:18 <edwardk> and change that type
06:25:28 <edwardk> it was more for showing off the differences
06:25:36 <mm_freak_> exicer: the secret to I/O in haskell is to just use it =)
06:25:47 <frerich> exicer: Do you know Java?
06:25:49 <Philippa> exicer: So long as you've the confidence to risk doing that, you'll be just fine
06:25:59 <frerich> exicer: In particular, runnables?
06:26:02 <mm_freak_> edwardk: ah, i see
06:26:03 <exicer> I know Python pretty well
06:26:11 <exicer> frerich: I have used java, but not much and ages ago
06:26:12 <typoclass> Philippa: ("suble learning curve" is a good way of putting it. countless times i thought i've got it all figured out entirely. only to be in tears yelling at the compiler a day later)
06:26:28 <typoclass> exicer: good hunting then =) be sure to take your first bit of haskell, even if it's just a line or two, and put it on hpaste. the feedback from folks in here was invaluable to me
06:26:30 <typoclass> @where hpaste
06:26:30 <lambdabot> http://hpaste.org/
06:26:45 <exicer> Will do this evening!
06:26:51 <exicer> Thanks everyone :)
06:26:51 <edwardk> mm_freak_: e.g. you can do things like grouping, and using the group information in the new updated type, etc.
06:26:55 <mm_freak_> edwardk: what would i do for, say, a web application, when i need a table of persons?  would i just create a Person with the usual fields and a primary key and write a Tabular instance for it?
06:27:08 <edwardk> mm_freak_: yep
06:27:08 <mm_freak_> a person has a name and an age
06:27:28 <frerich> exicer: Hm, I'm sure there is an equivalent for this in Python as well, but I don't know what it is... what helped me in the beginning was to think that to do IO in haskell you don't actually do IO - you just compose things which when executed perform IO. You don't actually execute them yourself though (the runtime system does that). So your 'main' is actually one big 'IO action'.
06:27:35 <frerich> exicer: It's a flawed analogy, but it got me started.
06:27:39 <mm_freak_> edwardk: if i were to add the type parameter, i could switch the individual element types, right?
06:27:47 <edwardk> data Person = Person { _personName :: String, _personAge :: Int }; instance Tabular Person where …
06:27:52 <edwardk> mm_freak_: yep
06:27:55 <mm_freak_> data Person age = Person { …, _personAge :: age, … }
06:27:56 <tdammers> exicer: also, hlint. Try it.
06:27:58 <mm_freak_> like that?
06:28:00 <edwardk> exactly
06:28:04 <mm_freak_> alright
06:28:05 <mm_freak_> thanks
06:28:10 <mm_freak_> i'll give it a try
06:28:11 <edwardk> you can add whatever parameters you need
06:28:35 <edwardk> iirc taneb has a bunch of family tree stuff switched or in mid-change, and donri was converting a bunch of code to it already
06:28:45 <Philippa> typoclass: yeah. When you spend a while yelling at the compiler it occasionally smacks you over the head with the next detail you missed though
06:28:53 <mm_freak_> and i could then use that with a traversal to get the average age, Traversal (Person Int) (Person Double) Int Double, right?
06:29:18 <edwardk> yep
06:29:24 <mm_freak_> great…  makes sense =)
06:29:27 <mm_freak_> thanks
06:29:49 <mm_freak_> btw, why the makeLensesWith stuff in the example?
06:29:59 <mm_freak_> wouldn't i just use makeLenses?
06:30:06 <mm_freak_> with _ prepended
06:30:15 <donri> makeLenses is fine
06:30:49 <Eduard_Munteanu> Is there some library for atomic file operations? I'm appending some records to a file and I don't want a crash to leave a record half-written.
06:31:38 <edwardk> averageAge = (\(Sum x,Sum y) -> fromIntegral x / fromIntegral y) $ foldMapOf (rows.personAge) (\x -> (Sum x, Sum 1)) people
06:31:50 <edwardk> mm_freak_: i was matching an example from somewhere
06:32:01 <edwardk> you can use the normal style ;)
06:34:15 <Eduard_Munteanu> Maybe I should ask something else, though... I want to log some events to a file and later generate human-readable statistics. Any idea?
06:34:55 <Eduard_Munteanu> Expect a crashful environment.
06:35:30 <donri> Eduard_Munteanu: is this relevant? http://hackage.haskell.org/package/safer-file-handles
06:35:35 <typoclass> Eduard_Munteanu: don't worry about the logging, but make the reading robust enough that it can ignore half-written events?
06:35:42 <typoclass> (just an idea)
06:35:46 <edwardk> (with a better Average monoid that would suck less) =)
06:36:33 <Saizan> frerich: that's roughly the best model of IO we have
06:36:57 <donri> Eduard_Munteanu: or perhaps http://hackage.haskell.org/package/cautious-file
06:37:16 <Nereid> I don't know if I'd call it a model.
06:37:35 <Nereid> it doesn't really say anything about how to think IO is implemented.
06:37:46 <Eduard_Munteanu> donri: hm, the latter seems relevant
06:38:24 <Eduard_Munteanu> typoclass: I'd be fine with that, is there any format / writer / parser I could use? I don't feel like designing my own.
06:39:31 <typoclass> Eduard_Munteanu: i have some kind of rare parsec disability. i always end up doing "lines" and "words" and "stripPrefix" on the input. *shrug*
06:40:01 <Eduard_Munteanu> Heh, I know what that feels like.
06:40:25 <frerich> hehe
06:40:44 <hpaste> Powergiant pasted “Final Solution” at http://hpaste.org/81591
06:40:48 <mm_freak_> edwardk: that's quite a lot of boilerplate there…  i'll wait for the TH support =)
06:40:53 <powergiant> Solution I went with for anyone interested hehe
06:40:57 <edwardk> mm_freak_: fair enough
06:41:11 <edwardk> its pretty mechanical to write
06:41:11 <mm_freak_> but it looks very promising
06:41:12 <typoclass> powergiant: very good! i like it
06:41:24 <edwardk> i just haven't had time to write it
06:41:39 <powergiant> typoclass: Thanks :D
06:41:45 <edwardk> been too busy playing with something that can sit on top of it ;)
06:41:59 <mm_freak_> edwardk: no worries…  my code is currently based on IxSet, and i will switch whenever the TH stuff is ready =)
06:42:06 <edwardk> mm_freak_: https://github.com/ekmett/analytics/blob/master/examples/Closure.hs#L33
06:42:08 <mm_freak_> hehe ok
06:42:28 <edwardk> Edge and TC will eventually just use their Tabular instances
06:44:38 <hpaste> ocharles pasted “Ideas to optimize encoding via Aeson?” at http://hpaste.org/81592
06:44:59 <ocharles> Hey, I'm working on a web service that spits out what is basically a 1MB list of UUIDs in JSON
06:45:15 <ocharles> from profiling, the majority of the time is spent doing the actual rendering to JSON, not the actual logic
06:45:25 <ocharles> any ideas on things I could tweak to get this to run better?
06:49:36 <Eduard_Munteanu> Is there a way to sleep until the wall clock indicates a certain date/time?
06:50:14 <Eduard_Munteanu> I'd prefer not computing that value ahead of time and threadDelay-ing, because the clock might get adjusted.
06:50:55 <tdammers> ocharles: take the dirty route, ditch aeson, assume that your values are always valid UUIDs, and emit raw bytestrings with the json boilerplate inserted manually
06:50:59 <tdammers> ugh
06:51:40 <typoclass> Eduard_Munteanu: not sure if OSes offer that kind of thing
06:52:02 <Eduard_Munteanu> Well, how does cron work?
06:52:09 <frerich> Eduard_Munteanu : cron polls
06:52:19 <Eduard_Munteanu> Hm.
06:52:33 <Eduard_Munteanu> I should do that too then.
06:52:44 <frerich> If you want to guard against changes to the system clock, yeah.
06:52:51 <typoclass> Eduard_Munteanu: pretty sure it's something like, wake up every 10 mins and see if it's time to do something
06:58:28 * hackagebot todos 0.5.3.2 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.5.3.2 (IlyaPortnov)
07:02:54 <Eduard_Munteanu> BTW, anything better than threadDelay for sleeping?
07:03:14 <portnov> what's wrong with threadDelay?
07:03:43 <Eduard_Munteanu> Well, it's GHC-specific and takes an Int.
07:03:54 <Eduard_Munteanu> The latter is probably worse.
07:04:02 <typoclass> portnov: it can only sleep for 34 mins or some such, depending on the system
07:04:35 <portnov> there was somewhere a version which tooks Integer. It just calls threadDelay many times :)
07:05:11 <portnov> http://hackage.haskell.org/packages/archive/concurrent-extra/0.5/doc/html/Control-Concurrent-Thread-Delay.html that's it
07:07:35 <typoclass> Eduard_Munteanu: i wrote an implementation once. haven't released it, but here you go http://hpaste.org/81595
07:09:47 <tromp> > 1.023**500
07:09:49 <lambdabot>   86659.63511457191
07:10:23 <quicksilver> typoclass: yeah, and on a 64 bit system it can only sleep for 292 years.
07:10:26 <quicksilver> WEAKSAUCE.
07:10:49 <quicksilver> I have mail clients with an uptime of longer than that!
07:11:10 <typoclass> quicksilver: ok, but on a 32-bit system it's plausible you run into the problem =) and it silently does the wrong thing, which isn't helping
07:11:27 <quicksilver> it's actually 292 millenia
07:11:29 <quicksilver> my mistake.
07:13:29 * hackagebot xdg-userdirs 0.1.0.2 - Basic implementation of XDG user directories specification  http://hackage.haskell.org/package/xdg-userdirs-0.1.0.2 (IlyaPortnov)
07:13:29 <Eduard_Munteanu> quicksilver: ints are 32-bit on 64-bit Linux
07:13:59 <Eduard_Munteanu> The same is true for Windows, IIRC.
07:14:27 <Saizan> > maxBound :: Int
07:14:28 <typoclass> Eduard_Munteanu: this confirms that Ints are perfectly straightforward and nothing could possibly go wrong with them
07:14:29 <lambdabot>   9223372036854775807
07:14:42 <Eduard_Munteanu> Clearly :)
07:15:07 <Eduard_Munteanu> Int has corporate backing, by Microsoft and other vendors. :P
07:16:42 <portnov> > maxBound :: Word64
07:16:44 <lambdabot>   18446744073709551615
07:16:55 <portnov> > maxBound :: Integer
07:16:57 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
07:16:58 <lambdabot>    arising from...
07:17:03 <Eduard_Munteanu> Huh.
07:17:04 <portnov> nice.
07:17:14 <Eduard_Munteanu> > maxBound :: Word32
07:17:16 <lambdabot>   4294967295
07:17:29 <quicksilver> Eduard_Munteanu: 'ints' might be but 'Ints' are not.
07:17:38 <quicksilver> Eduard_Munteanu: please do pay most careful attention :)
07:18:07 <Eduard_Munteanu> I thought they were mapped to C's ints, save for the tag bits and such.
07:18:15 <quicksilver> wrong.
07:18:20 <quicksilver> there are no tag bits
07:18:24 <quicksilver> and they aren't mapped to C ints
07:18:25 <quicksilver> :)
07:18:36 <quicksilver> they are mapped to 'machine integers'
07:18:43 <quicksilver> which is 64 bit, on a 64 bit machine.
07:19:07 <Eduard_Munteanu> Ah, I suppose CInt is 32-bit then.
07:19:13 <typoclass> it'd be hilarious if it wasn't so sad
07:19:15 <quicksilver> I think the major C ABIs (linux, windows, etc) didn't have the courage to push int up to 64 bit, because of compatibility issues.
07:19:18 <Eduard_Munteanu> > maxBound :: CInt
07:19:20 <lambdabot>   Not in scope: type constructor or class `CInt'
07:19:20 <lambdabot>  Perhaps you meant one of th...
07:19:38 <quicksilver> I seem to recall that there have been standard C ABIs with 64 bit ints
07:19:40 <quicksilver> just not the major ones.
07:20:32 <Eduard_Munteanu> quicksilver: the least brave was Windows, they have a 32-bit long IIRC
07:22:23 <quicksilver> yes, that's right.
07:32:51 <shachaf> What are things of kind * -> #?
07:33:00 <shachaf> I can think of State# and unboxed tuples.
07:33:59 <monoidal> we need a kind-level hoogle
07:34:47 <tdammers> koogle :P
07:35:12 <shachaf> whoa, dude
07:35:18 <shachaf> This is unsafeCoercing between kinds.
07:35:30 <geekosaur> :t I#
07:35:32 <lambdabot>     Not in scope: data constructor `I#'
07:35:32 <lambdabot>     Perhaps you meant `In' (line 134)
07:35:36 <shachaf> Well, unsafeCoerce#ing
07:35:53 <gustavnils> :t map
07:35:54 <lambdabot> (a -> b) -> [a] -> [b]
07:36:05 <geekosaur> :t GHC.Prim.I#
07:36:07 <lambdabot> Not in scope: data constructor `GHC.Prim.I#'
07:36:09 <geekosaur> bah
07:36:35 <shachaf> @ty GHC.Exts.I#
07:36:37 <lambdabot> GHC.Prim.Int# -> Int
07:36:44 <shachaf> Nothing Prim about it.
07:37:02 <geekosaur> right, and I was thinkiung backwards anyway
07:38:24 <shachaf> @ty GHC.Prim.unsafeCoerce#
07:38:26 <lambdabot> a -> b
07:38:32 <shachaf> @ty GHC.Prim.unsafeCoerce# (# () #)
07:38:34 <lambdabot>     Couldn't match kind `ArgKind' against `(#)'
07:38:34 <lambdabot>     Kind incompatibility when matching types:
07:38:34 <lambdabot>       a0 :: ArgKind
07:38:46 <shachaf> @ty GHC.Prim.unsafeCoerce# (# 0# #)
07:38:47 <lambdabot>     Couldn't match kind `ArgKind' against `(#)'
07:38:48 <lambdabot>     Kind incompatibility when matching types:
07:38:48 <lambdabot>       a0 :: ArgKind
07:38:54 <shachaf> @ty GHC.Prim.unsafeCoerce# () :: (# () #)
07:38:56 <lambdabot> (# () #)
07:39:18 <shachaf> Should that work?
07:41:24 <ocharles> tdammers: there's no way i'm manually generating JSON
07:44:44 <tdammers> ocharles: hence, ugh
07:45:54 <burbul> I've just found an apparently variadic fn Text.Printf.printf
07:46:08 <burbul> how does it manage to accept a variable no of arguments?
07:46:14 <quicksilver> by overloading.
07:46:21 <quicksilver> it has an overloaded return type.
07:46:23 <burbul> Ahhhh
07:46:24 <Eduard_Munteanu> Typeclass trickery.
07:46:32 <quicksilver> it can either return a string (finished now) or a function (another argument)
07:46:47 <quicksilver> it's not really trickery, Eduard_Munteanu :)
07:46:52 <burbul> I didn't realise you were allowed to overload the return type.
07:46:57 <quicksilver> yup.
07:47:00 <burbul> does the compiler simply try every option?
07:47:10 <quicksilver> no, the compiler infers the type
07:47:13 <frerich> burbul: A very funk use of return type overloading is the regexp package
07:47:22 <quicksilver> and chooses that option
07:48:15 <burbul> @hoogle regexp
07:48:15 <lambdabot> package regexp-tries
07:48:16 <lambdabot> package regexpr
07:48:16 <lambdabot> package regexpr-symbolic
07:48:42 <frerich> burbul: I.e. '"Banana" ~= "a" :: Bool' tells you whether 'a' is in 'Banana', but treating it as an Int gives you the number of matches.
07:48:56 <burbul> neat
07:48:57 <frerich> Or if you ask for a String, you get the matched substring
07:49:10 <frerich> A list of strings gets all substrings and so on. It's funky, but I'm not sure I like it.
07:49:25 <burbul> not very Haskellish, you mean?
07:49:35 <frerich> I don't know about that, I'm an amateur at Haskell
07:49:49 <frerich> I do know that I never quite know what ~= does exactly, I alwayts have to look at the surrounding code to tell :)
07:50:00 <typoclass> frerich: that sounds pretty like a pretty straightforward use of typeclasses (unlike printf)
07:50:02 <frerich> Since depending on what type is used, the thing gives different answers.
07:50:32 <Eduard_Munteanu> Still, it's return type overloading.
07:51:02 <frerich> typoclass: Maybe, but it irritated me a bit (still does) so I have some aliases like 'numMatches' (which gets you an Int) or 'allMatches' or 'matches'.
07:51:18 <frerich> I.e. I 'encode' the return type in the name.
07:51:42 <frerich> but I suppose it may well be that I'm just not very used to reading Haskell code (indeed I'm not)
07:51:46 <Eduard_Munteanu> This way you encode the desired return type in the dictionary, at runtime.
07:52:06 <quicksilver> the idea of overloading =~ isn't a *horrible* idea
07:52:11 <quicksilver> but it goes much too far
07:52:19 <quicksilver> it has 8? 10? overloaded return types
07:52:20 <typoclass> frerich: sure, i'm not really sure if it's a good choice stylistically
07:52:38 <quicksilver> if it was just overloaded between Bool/Int/[List of Matches]
07:52:49 <quicksilver> that would be much more aesthetic to me.
07:53:34 <frerich> Yeah I think actually those are three rather common cases, and writing 'if "banana" ~= "a" then' or 'if "banana" ~= "a" > 10' doesn't look so bad.
07:54:22 <frerich> In  any case, when I learned about it (IIRC RWH mentions it) I thought it was really funky but that's only because you cannot overload functions based on your return type in C++ (the only statically typed language besides Pascal I know reasonably well)
07:56:03 <frerich> quicksilver: Actually, now that you are here - do you remember how I talked about getting more concurrency out of a web crawler and you suggested a pool of worker threads? Turned out that I went for that route, and the result in https://github.com/frerich/lambdacrawler/blob/master/src/Main.hs works rather well, too :-)
07:56:12 <quicksilver> \o/
07:56:23 <frerich> One problem I initially had: how to tell worker threads to terminate
07:56:37 <frerich> I couldn't see how to readTChan and also respect something else (like a select in POSIX)
07:57:16 <frerich> Somebody mentioned 'orElse' or something like that (some STM thing) but In the end I just went for a 'poison pill'; the TChan which the threads consume contains either a 'Scan uri' or a 'Stop' command.
07:57:21 * Eduard_Munteanu still feels like reaching for select() and non-blocking I/O
07:58:29 <frerich> Eduard_Munteanu : Ever since I discovered what forkIO does and how STM works, I never looked back.
08:04:26 <dskippy> I am having a weird problem calling readFile from WinGHCI. I wrote a program on my Linux machine and it works file, I ported it to Windows and I get a permission denied error when calling readFile. Problem is the file I am trying to open will open just fine for the same user in GVim or notepad.
08:05:23 <dskippy> I think the problem might be that WinGHCi is running as some unprivileged user or something, but that sounds weird. I don't understand Windows very well, sadly. Anyone know why WinGHCi is different from other programs regarding permissions?
08:06:45 <S11001001> dskippy: task manager should tell you what user owns the process
08:07:33 <dskippy> S11001001: Good thought. The same user owns GVim and WinGHCi
08:07:45 <dskippy> My Windows username, that is.
08:08:01 <quicksilver> arey ou trying to write to the file too?
08:08:11 <dskippy> Nope. Just call readFile.
08:08:14 <quicksilver> windows standard file locking means you can't read from a file you're writing to, I think.
08:08:57 <S11001001> dskippy: there's also xlocking by default.  is it open elsewhere when you try to open it?
08:09:02 <bitonic> it would be nice if there was a way to embed interpreters in ghci, e.g. have a way to enter the ‘other’ interpreter, with another context and other evaluation rules
08:09:13 <dskippy> Specifically I am trying to do this:
08:09:15 <dskippy> getDirectoryContents dir >>= readFile . ((dir++"\\")++) . head
08:09:17 <bitonic> but at the same time being able to interact with the embedded context in some way
08:09:37 <quicksilver> bitonic: yes, it would.
08:09:42 <dskippy> S11001001: nope, I had GVim closed to start.
08:10:59 <bitonic> quicksilver: I guess you can generalise this idea to some more general ghci API
08:11:28 <geekosaur> http://msdn.microsoft.com/en-us/library/windows/hardware/ff552060(v=vs.85).aspx and see what it's actually doing?
08:15:06 <magic> which one is better -- Gtk2HS or wxHaskell? or both are good equally?
08:15:22 <dcoutts> dunno about equally, but both are good
08:16:41 <`nand`> maybe it's a situation of both being equally bad
08:16:51 <Eduard_Munteanu> magic: I'd say gtk2hs is more mature and used more as well
08:17:35 <magic> Indeed I think so
08:18:16 <magic> It's so enough that leksah itself uses gtk2hs
08:18:20 <kennyd_> qtHaskell is the least mature of the three from what I understood?
08:18:35 <geekosaur> also I think not being updated
08:19:17 <dcoutts> magic: ThreadScope is another example, and works on linux, windows and osx
08:19:31 <magic> qt in general loves C++ :D
08:20:23 <Eduard_Munteanu> Unfortunately we don't have a gtk3hs yet. :(
08:21:10 <geekosaur> we might not; apparently there's a replacement in development that should be more maintainable, instead of just trying to retrofit gtk3 into a gtk2-based framework?
08:21:38 <dcoutts> geekosaur: oh yes?
08:21:49 <Eduard_Munteanu> I suspect GTK3 itself breaks compatibility with GTK2, so yeah, might do better.
08:21:54 <geekosaur> what I gleaned from last night's email, lemme see if I can find it
08:22:22 <dcoutts> gtk3 now has much better metadata than when I first wrote the binding generator used for the bulk of gtk2hs
08:23:23 <donri> would be nice to have something that works for any library using gobject introspection, but in a more static manner than what pygobject does
08:25:13 <dcoutts> donri: the tool I wrote semi-worked for other gobject based libs
08:25:54 <geekosaur> http://sourceforge.net/mailarchive/message.php?msg_id=30423429 and thread
08:25:55 <dcoutts> if one redid it now, you'd use the new gobject metadata and would be able to get it to work for any gobject lib
08:26:06 <geekosaur> haskell-gi
08:27:43 <ParahSailin> how do i make this lazy: foldl' (\a x -> a || odd x) False [0..]
08:28:02 <dcoutts> geekosaur: hmm, someone in that thread seems to think the .chs files are all hand written
08:28:25 <S11001001> ParahSailin: switch to foldr
08:28:30 <geekosaur> yeh, I noticed
08:28:34 <dcoutts> the code generator I wrote also (mostly) translated the documentation, into haddock markup
08:28:52 <S11001001> ParahSailin: or use foldMap with the Any/All newtype monoid (I forget exactly what they're called)
08:29:43 <dcoutts> geekosaur: ah ok, so haskell-gi is the glib/gobject binding generator
08:30:48 <S11001001> ParahSailin: obviously only the Any monoid would work in this case :)
08:31:37 <S11001001> ParahSailin: although I'm not sure what you hope to gain from evalling this.  Either it'll be True, or fail to terminate.
08:33:24 <ParahSailin> obviously that is a reduced example
08:35:24 <ParahSailin> ah, what i want is Prelude.any
08:47:41 <quchen> Is there some easy hack to make Backspace work in getLine?
08:49:12 <shachaf> The fastest way I know to get a key to work is to press it.
08:50:39 <c_wraith> quchen: if you're using line buffering at the console, it should always work.
08:51:14 <shachaf> It depends on a lot of things, like your console.
08:52:01 <applicative_> can you control it inside ghci? It seems to default sensible if I compile.
08:53:25 <applicative_> ah yes, it works in ghci do {hSetBuffering stdin LineBuffering; getLine >>= putStrLn . reverse}
08:53:47 <geekosaur> actually I would expect it to work in ghci, unless you have a weird setup like used to be sadly common on some unixes where backspace was set to ^H but overly smart shells used ^? instead and the terminal emulator set to send ^? for backspace
08:54:04 <geekosaur> (so backspacing only works as expected in the shell, not programs)
08:54:21 <applicative_> geekosaur: without doing anything, it shows up as \DEL in getLine >>= putStrLn
08:54:25 <applicative_> on os x
08:54:56 <applicative_> grr, I meant, inside ghci, without setting anything
08:56:11 <geekosaur> applicative_, that sounds like exactly the config I described
08:56:37 <applicative_> geekosaur: thats what I was wondering,
08:57:17 <geekosaur> POSIX uses ^H as backspace.  unfortunately there's this terminal config floating around probably developed by some BSDer (where DEL was the usual binding for backspace) that switches the terminal to send DEL, and shells let them get away with it
08:57:20 * applicative_ is a confessed unix idiot
08:58:28 <sclv> @remember JaffaCake (on zonking) It's named after the noise it makes.
08:58:28 <lambdabot> Nice!
08:58:35 <fizbin> Hey, in the definition of MonadError, what does the "| m->e" bit mean in: class (Monad m) => MonadError e m | m -> e where
08:58:55 <applicative_> fizbin: type dependency
08:59:14 <fizbin> Could you expand on that?
08:59:17 <geekosaur> it's a functional dependency telling the compiler that if it knows m, then exactly one e goes with it
08:59:19 <sclv> it means that each m uniquely implies an e
08:59:40 <sclv> its like a "normalized column" in a database
08:59:48 <sclv> m is the key
09:00:01 <applicative_> fizbin: so when you write instance MonadError String IO you don't get to have an instance MonadError Text IO too
09:00:05 <geekosaur> applicative_, are you using xterm or OS X Terminal, or something else?
09:00:26 <applicative_> Terminal.app
09:01:03 <fizbin> Ah, so it's a "There can be only one" kind of clause?
09:01:41 <ski> fizbin : it means `forall m. unique e. MonadError e m', which means `forall m e0 e1. (MonadError e0 m,MonadError e1 m) => e0 = e1', which means that if you have two instances with the same `m', then the two `e's must also be the same, which means that there can be at most one `e' for every `m', satisfying `MonadError e m'
09:01:46 <applicative_> hah, geekosaur I see in Preferences, an option 'Delete sends Control-H'  which I guess is on by default
09:02:08 <ski> fizbin : in short : each monad `m' being an instance of the class can only correspond to at most a *single* error type !
09:02:30 <fizbin> Okay.
09:02:31 <geekosaur> yeh, except it's off here.  (I use iTerm2 currently, and it's doing ^H for backspace.  I'm wondering if we're seeing the BSD influence at Apple now)
09:03:10 <ski> fizbin : so, if you say `instance MonadError MyError MyMonad', you can't also say `instance MonadError MyOtherError MyMonad'
09:03:28 <fizbin> Right, got it.
09:03:32 <geekosaur> fizbin, the point of this is you would like to not have to always tell it what error type you are using, so the functional dependency says that if it determines the e for some m at some point it can rely on that always being the right e.  otherwise you'd need to use more type signatures everywhere to reassure it
09:04:03 <ski> fizbin : .. and the point of this, apart from specifying this "functional dependency" in the type class is that you'll usually get much less ambiguity errors if you use FDs like this properly when declaring your classes
09:04:31 <hpc> an alternative to functional dependencies is type families
09:04:40 <hpc> though there's some things you can only express in one or the other
09:05:03 * `nand` .oO( forall m a b. (MonadError a m, MonadError b m) :- (a ~ b)  )
09:05:26 <ski> `nand` : wrong direction of the implication :)
09:05:38 <ski> (`:-' is `<=')
09:05:51 <hpc> ghc probably generates a term of that type internally, during compilation of FDs
09:06:36 <applicative_> the type families bit is somehow clear at first sight, you declare class MonadError where type ErrorType m :: * and then use ErrorType in the signatures, crashAll :: m a -> ErrorType m
09:06:46 <applicative_> ^^^ probably messing up the syntax as usual
09:07:29 <ski>   throwError :: MonadError m => ErrorType m -> m a  -- presumably
09:07:30 <applicative_> fizbin: this makes it clear that you cant have two instances for MonadError IO
09:09:41 * ski . o O ( "Consistent BackSpace and Delete Configuration" <http://www.ibb.net/~anne/keyboard/keyboard.html> )
09:09:57 <`nand`> ski: :- as in (Data.Constraint.:-) ?
09:10:21 <fizbin> Wait, why does the throwError signature make it clear that you can't have two instances?
09:10:24 <shachaf> Data.Constraint.☺
09:10:53 <ski> `nand` : hm, no, i was thinking of `:-' as in Prolog -- sorry, if that wasn't what you had in mind
09:11:27 <`nand`> I was thinking of Haskell; but that aside, GHC still can't infer (a ~ b) from the context (MonadError a m, MonadError b m)
09:12:48 <monoidal> `nand`: I believe HEAD can
09:13:52 <Saizan> it really conflicts with some instances you can write with UndecidableInstances on
09:14:14 <shachaf> are instances monoids?
09:14:17 <shachaf> i love monoids :D
09:14:34 <Saizan> no, they are not so easy
09:14:45 <shachaf> ah :(
09:15:11 <monochrom> yikes, this weekend, we will have a new meme
09:15:35 <hpc> monochrom: eh?
09:15:35 <Saizan> we will?
09:15:49 <monochrom> "is lazy evaluation like monoids? I love monoids"
09:16:05 <shachaf> monads are like endomorphic monoids :D
09:17:55 * Saizan wonders if shachaf is going to be ok
09:18:35 <shachaf> dr monochrom or: how i learned to stop worrying and love the monoids
09:19:21 <monochrom> @let monoidize "" = "please use a non-empty string"; monoidize s = (if last s = 's' then "are " else "is ") ++ s ++ " like monoids? I love monoids"
09:19:22 <lambdabot>   Parse error: =
09:19:35 <monochrom> @let monoidize "" = "please use a non-empty string"; monoidize s = (if last s == 's' then "are " else "is ") ++ s ++ " like monoids? I love monoids"
09:19:37 <lambdabot>  Defined.
09:19:45 <ski> i think you meant to `/msg lambdabot' that
09:20:03 <monochrom> no, I want you to see what I do
09:20:14 <shachaf> monochrom: "please use a non-empty string"?
09:20:20 <shachaf> You should've called is semigroupize
09:20:28 <hpc> haha
09:20:32 <monochrom> darn
09:20:44 <monochrom> @undefine
09:20:57 <monochrom> (see the benefit of letting you see it? :) )
09:21:17 <monochrom> @let monoidize "" = "I love monoids"; monoidize s = (if last s == 's' then "are " else "is ") ++ s ++ " like monoids? I love monoids"
09:21:19 <lambdabot>  Defined.
09:21:36 <hpc> > monoidize "laziness"
09:21:38 <lambdabot>   "are laziness like monoids? I love monoids"
09:21:52 <ParahSailin> @hoogle (a -> IO Bool) -> [a] -> IO Bool
09:21:53 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
09:21:53 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
09:21:53 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
09:24:51 <shachaf> @hoogle anyM
09:24:51 <lambdabot> package Ganymede
09:24:52 <lambdabot> Data.Graph.Inductive.Monad matchAnyM :: GraphM m gr => m (gr a b) -> m (GDecomp gr a b)
09:24:56 <shachaf> @package monad-loops has it
09:24:57 <lambdabot> http://hackage.haskell.org/package/monad-loops has it
09:31:52 <applicative_> fizbin: sorry I vanished in class MonadError m where type Errors m :: * ; crash :: Errors m then you do instance MonadError IO where type Errors = Text; crash = pack "crash!"
09:33:01 <applicative_> fizbin: you cant associate a new Error type with IO without changing the instance; another instance wouldn't make sense
09:33:26 <applicative_> i mean, any more than three Num instances for Float would make sense
09:34:18 <ParahSailin> @ty (fmap or <$>) . mapM
09:34:20 <lambdabot> (Monad f, Functor f) => (a -> f Bool) -> [a] -> f Bool
09:35:50 <fizbin> applicative_: I still don't see how what you're trying to say with that Errors type actually demonstrates anything.
09:36:38 <applicative_> fizbin: oh, it was just suppsed to illustrate the type familes way of writing what could be a functional dependency
09:38:00 <fizbin> Right; I don't understand why you've demonstrated a functional dependency there.
09:38:31 * hackagebot base 4.6.0.1 - Basic libraries  http://hackage.haskell.org/package/base-4.6.0.1 (IanLynagh)
09:38:51 <ski> @type fmap (getAny . Data.Foldable.fold . fmap Any) .: Data.Traversable.traverse
09:38:52 <lambdabot> (Applicative f, Traversable t) => (a -> f Bool) -> t a -> f Bool
09:39:10 <applicative_> the 'functional dependencies' version would be class MonadError m e | m -> e where crash :: e ; instance MonadError IO Text where crash = pack "crash"
09:39:32 <fizbin> Okay, I think I see what you were demonstrating.
09:39:58 <applicative_> which is a little less verbose. In this case I think the two langauge extensions amount to the same, elsewhere they differ
09:41:03 <fizbin> I still don't completely understand why MonadError is restricted in this fashion.
09:41:26 <fizbin> I think it has something to do with the type signature on catchError and how that's used.
09:43:32 * hackagebot unix 2.6.0.1 - POSIX functionality  http://hackage.haskell.org/package/unix-2.6.0.1 (IanLynagh)
09:45:28 <PolishDemon> what's the memory footprint of foldl vs foldr if not adding (prepending or to end) to a list?
09:45:56 <PolishDemon> lol memory footprint. cpu usage. :P whichever.
09:46:27 <applicative_> fizbin: actually exactly this opposition is shown between the mtl definition of MonadError and monads-tf http://hackage.haskell.org/packages/archive/monads-tf/0.1.0.1/doc/html/src/Control-Monad-Error-Class.html
09:46:39 <applicative_> vs http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/src/Control-Monad-Error-Class.html
09:46:51 <hpaste> “Anonymous Coward” pasted “IO Array Concat” at http://hpaste.org/81601
09:47:41 <jubos> hi, i had a question about the above paste.  Is it possible to concat two arrays while they are each inside an IO monad
09:47:44 <byorgey> PolishDemon: the question is not well-defined. it depends a lot on what combining function is used.
09:48:08 <PolishDemon> byorgey: fair enough. i mean in a simple context such as a recreation of maximum
09:48:10 <byorgey> PolishDemon: see http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
09:48:30 <PolishDemon> byorgey: perfect, thanks :D
09:48:46 <applicative_> PolishDemon: foldl is generally thought to be a loser, foldl' to be okay for strict operations like +
09:49:16 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml
09:49:58 <monochrom> max is similar to (+) in this regard. my article uses (+)
09:49:58 <applicative_> PolishDemon: the first 30 slides in here are excellent http://www.slideshare.net/tibbe/highperformance-haskell
09:50:10 <applicative_> dons says the Data.List definition of foldl' is wrong though
09:50:36 <monochrom> oh? does he mean seq vs pseq?
09:50:37 <PolishDemon> thanks guys! this is exactly what i was looking for
09:51:44 <applicative_> dons_foldl' f z0 xs0 = go z0 xs0 where go !z []     = z go !z (x:xs) = go (f z x) xs
09:53:50 <applicative_> Data.List.foldl' f z0 xs0 = lgo z0 xs0 where lgo z []     = z ; lgo z (x:xs) = let z' = f z x in z' `seq` lgo z' xs
09:54:36 <applicative_> that's a pretty subtle difference...
09:57:18 <linduxed> i've got an assignment where i get a distance matrix with the type [[(String, String, Double)]] where the strings are names. for the next part of the assignment it's "recommended to store the distance matrix as a Data.Map". two things here:
09:57:50 <linduxed> 1. how am i supposed to use Data.Map in a sensible way when the input data is formatted as (a,b,c) while fromList takes (a,b)?
09:58:17 <applicative_> let linduxed (a,b,c) = ((a,b),c)
09:58:24 <linduxed> 2. isn't Data.Map one-dimensional? the distance matrix is two-dimensional...
09:58:26 <alpounet> linduxed, fromList's a can be your data's (a,b), and fromList's b can be c
09:58:52 <linduxed> i guess that works... don't think it's very pretty but OK
09:59:07 <linduxed> i mean it's not my idea to use Data.Map anyway :-S
09:59:33 <linduxed> it just feels so damn shoehorned
09:59:50 <applicative_> fromDistanceMatrix = fromList . (\(a,b,c) -> ((a,b),c))
10:00:02 <applicative_> forgot a map
10:00:10 <applicative_> fromDistanceMatrix = fromList . map (\(a,b,c) -> ((a,b),c))
10:00:44 <linduxed> applicative_: yeah, that looks like it would work, thx
10:01:14 <linduxed> oh and btw
10:01:22 <linduxed> even more irritating
10:01:29 <linduxed> the distance matrix, it's symmetrical
10:01:56 <linduxed> but (a,b) isn't the same as (b,a) when it comes to keys
10:02:14 <linduxed> so it won't be removed as a duplicate normally would :-/
10:02:38 <elliott> you can make an unordered tuple type
10:02:38 <applicative_> Hm, not sure what's intended, maybe you should also add the reversed pairs??
10:03:19 <linduxed> applicative_: the whole story is written out here: https://github.com/linduxed/progp-molbio/tree/evoltree
10:03:49 <linduxed> applicative_: basically i've got everything done under the tasks headline, ut until "evolutionary trees"
10:04:12 <linduxed> i need to implement the Neighbor Joining algorithm
10:04:39 <linduxed> and for some reason the guys who gave the assignment added the task "The data structures Data.Set and Data.Map need to be used in meaningful ways."
10:06:37 <linduxed> with the "hint" that one should "probably" use Data.Set for the vertices in the resulting graph/tree
10:07:55 <linduxed> and "probably" use Data.Map for edges and a separate Data.Map for the distance matrix
10:11:03 <applicative_> hah, someone was working on the same problem last fall... with slightly different types
10:11:08 <applicative_> but I didn't say that
10:11:50 <linduxed> yeah, quite likely, since the course ran at that time, IIRC
10:12:09 <applicative_> hah  ... fromList (map(\(a,b,c) -> ((a,b),c)) dm) ...
10:13:04 <linduxed> well, once again, that doesn't eliminate duplicates which arise from the symmetry in the matrix
10:13:19 <linduxed> i'd need to have... hmmm
10:13:48 <linduxed> the cases where (a,b) already exists when it comes across (b,a)
10:13:59 <otters> @pl \(a,b,c) -> ((a,b),c)
10:14:00 <lambdabot> (line 1, column 7):
10:14:00 <lambdabot> unexpected "c"
10:14:00 <lambdabot> ambiguous use of a non associative operator
10:14:05 <linduxed> i would need these cases to be flipped
10:14:14 <otters> somebody should teach lambdabot uncurry3 and curry3
10:17:50 <basdirks> > read "0.1" :: Float
10:17:52 <lambdabot>   0.1
10:17:54 <basdirks> > read ".1" :: Float
10:17:55 <lambdabot>   *Exception: Prelude.read: no parse
10:21:15 <eacameron> how can I convince people in my company to start using haskell?
10:21:48 <basdirks> which part needs convincing?
10:21:48 <linduxed> eacameron: that's an extremely broad question
10:21:59 <koala_man> just don't tell them, and start writing twice as awesome apps in half the time
10:22:16 <eacameron> linduxed: I know...just probing peoples minds
10:23:13 <eacameron> I've done Eric Meijer's 10 week Channel 9 lesson over lunch break, I've won internal competitions...but people still look at it like it's from mars
10:23:16 <linduxed> eacameron: what kind of company is it (size + structure)? do you have a codebase already? are you starting a new project? are the people there open to changing languages? would a change in language be opposed by some department?
10:23:20 <linduxed> and so on...
10:23:39 <eacameron> linduxed: great questions
10:23:54 <basdirks> it's not from mars? =[
10:24:07 <eacameron> <100 people, large existing code-base (in C++ mostly) and some openness to using new languages
10:24:20 * applicative_ is from Mars, what's wrong with that...
10:24:40 <linduxed> eacameron: would the learning process needed to adapt a new language be economically feasible?
10:25:02 <`nand`> applicative_: blatant planetism engraved into our modern culture
10:25:21 <eacameron> linduxed: not sure...switching between Python/Ruby/Lua would be...but Haskell is not so easily picked up by coders in that realm
10:26:01 <eacameron> linduxed: you're taking this question more seriously than I meant it...but you're helpful ;)
10:26:03 <linduxed> eacameron: how much work would need to be done to bridge the haskell code to the C++ code? do you have compelling arguments for the switch which you could present to management?
10:26:10 <linduxed> *management/the-team
10:26:42 <linduxed> eacameron: dude... my fucking assignment has plagued me for a couple of days now.
10:26:46 <linduxed> serious face is on
10:27:34 <eacameron> linduxed: well...all the normal compelling arguments to switch to haskell in general, but what does management care about code quality and "projected" efficiency gains?? They want hard numbers :(
10:28:08 <linduxed> i was recently at a company which moved from i-don't-remember-what to erlang
10:28:21 <eacameron> linduxed: that's a great step in the right direction
10:28:32 <eacameron> linduxed: i'm sorry about your assignment ;)
10:29:00 <eacameron> that's what I'm interested in....success stories
10:29:01 <linduxed> basically, one of the coders had gotten a new assignment, thought about how to do it, had just recently picked up a book about erlang, so he wrote the thing in erlang
10:29:19 <linduxed> turned out that it was way better than the similar code in the old lang
10:29:26 <linduxed> so they wrote more and more in erlang
10:29:45 <linduxed> now most of their codebase is in erlang, and all the old code has been ported
10:30:04 <linduxed> moral of the story? start coding something better than the stuff you've already got
10:30:05 <eacameron> linduxed: very nice...wow...porting code would take forever where I'm at...we have way too much of it
10:30:27 <eacameron> linduxed: that's what I figured...but who will PQA/peer-review my Haskell code...they can't understand it
10:30:27 <applicative_> that's pretty cool
10:30:41 <applicative_> send it to dons
10:30:46 <linduxed> dons?
10:30:49 <eacameron> dons?
10:31:02 <elliott> dons?
10:31:13 * applicative_ cant see him either
10:31:32 <linduxed> eacameron: well, at first only he wrote erlang, but then the entire team started porting it with him... goes a bit faster that way
10:31:56 <eacameron> linduxed: yeah...that would be awesome...I'll keep dreaming and maybe one day it will happen ;)
10:32:26 <linduxed> eacameron: we'll you've gotta start that dream by working on it
10:32:52 <eacameron> yeah....I'm trying! we had an internal competition. I wrote the whole thing in haskell and won
10:32:56 <eacameron> people still aren't convinced
10:33:38 <eacameron> biggest problem is people will say, "How am I gonna change that in the future when I need to? don't know haskell?"
10:33:49 <eacameron> *I don't
10:34:06 <eacameron> but I hear what your saying
10:34:09 <eacameron> slow and steady wins the race
10:34:30 <Hafydd> *you're
10:35:29 <eacameron> linduxed: thanks for the thoughts...hope the best for your assignment...slow and steady wins the race I hear
10:36:14 <linduxed> eacameron: good luck to you too
10:36:24 <linduxed> although i don't know who'll need it most :-P
10:36:31 <linduxed> this shit is boggling my mind
10:39:45 <roadfish> @pl x line = not (line =~ "^ *#")
10:39:45 <lambdabot> (line 1, column 9):
10:39:45 <lambdabot> unexpected " "
10:39:45 <lambdabot> expecting operator
10:40:07 <roadfish> @pl x line = not (line =~ "pattern")
10:40:07 <lambdabot> (line 1, column 9):
10:40:08 <lambdabot> unexpected " "
10:40:08 <lambdabot> expecting operator
10:40:24 <otters> @pl \x line -> not (line =~ "pattern")
10:40:24 <lambdabot> (line 1, column 23):
10:40:24 <lambdabot> unexpected "~"
10:40:24 <lambdabot> expecting operator
10:40:27 <otters> heh
10:40:34 <otters> silly lambdabot
10:40:38 <roadfish> @pl x line = not (line + 33)
10:40:38 <lambdabot> x = not . (33 +)
10:40:56 <roadfish> guess it doesn't like =~
10:41:16 <c_wraith> the pl plugin doesn't actually parse haskell properly
10:41:57 <roadfish> ah well, manually swapping + for =~ is sufficient
10:42:25 <otters> Except I doubt (=~) is commutative
10:42:32 <otters> wait is that the proper word?
10:42:34 <otters> the arguments can be flipped
10:42:35 <c_wraith> yes
10:42:42 <mason3> imagine a list of list representing image, and I want to place one image on top of the other (think of layers in photoshop), and get a third list that combines those two images. how would I do that?
10:42:44 <roadfish> @pl x line = not (line - 33)
10:42:45 <lambdabot> x = not . subtract 33
10:42:55 <roadfish> @pl x line = not (line / 33)
10:42:55 <lambdabot> x = not . (/ 33)
10:42:56 <otters> @pl x line = not (line >> 33)
10:42:56 <lambdabot> x = not . (>> 33)
10:42:58 <otters> there
10:43:08 <c_wraith> pl has too many shortcutes
10:43:19 <c_wraith> (special cases, really)
10:43:19 <geekosaur> apropos typo :)
10:43:45 <ski> `x line = not (line =~ "^ *#")' isn't very hard to hand-pointless, though
10:44:15 <roadfish> I'm writing testcases and using regular expressions at the same time. So a bit of ~= and =~ confusion.
10:44:49 <roadfish> that's just an offside comment ... not relevant to this pl stuff
10:46:15 <pzuraq> what's the paste this channel uses again?
10:46:18 <pzuraq> gist?
10:46:27 <clahey> hpaste usually.
10:46:33 <ski> @paste
10:46:33 <lambdabot> Haskell pastebin: http://hpaste.org/
10:47:00 <pzuraq> http://hpaste.org/81602
10:47:14 <pzuraq> so I'm trying to figure out what's wrong here, getting an error on the Eq
10:47:27 <pzuraq> No instances for (Eq k, Eq v) arising from a use of `=='
10:47:55 <pzuraq> In the expression: (toList t1) == (toList t2)
10:48:05 <pzuraq> also apparently I have a redundant lambda...
10:48:06 <otters> pzuraq: on hpaste, you can choose for the bot to say your paste URL in the channel
10:48:13 <pzuraq> oh sweet
10:48:29 <roadfish> mason3:I'm playing with Diagrams these days. You might find that package useful for you purposes.
10:48:34 <roadfish> your purposes
10:48:53 <roadfish> mason3:check out http://projects.haskell.org/diagrams/tutorial/DiagramsTutorial.html
10:49:06 <roadfish> mason:although it might be more than you really want
10:49:08 <mason3> thanks roadfish I will take a look
10:49:34 <ski> pzuraq : `instance (Eq k,Eq v) => Eq (BST k v)'
10:50:01 <pzuraq> ah sweet
10:50:04 <pzuraq> thanks ski :)
10:50:05 <ski> pzuraq : you need to have equality on the keys a values, to be able to get equality on the `BST k v's
10:50:17 <pzuraq> makes sense
10:51:07 <ski> btw, since you have a non-structural `(==)', you should probably not export the data constructors `Empty' and `Bind' from the module
10:51:15 <ski> (well, `Empty' could be ok, i suppose)
10:51:57 <pzuraq> why wouldn't I want to export them?
10:52:54 <ski> because then users of the module would be able to tell apart BSTs `t0' and `t1' such that `t0 == t1' is `True'
10:53:23 <ski> generally, you want that if `(==)' returns `True', then users shouldn't be able to tell apart the two values
10:54:24 <ski> pzuraq : also, you don't need the brackets in `(toList t1) == (toList t2)', `deriving Show', `(Ord t) => '
10:54:46 <ski> `\t -> \(k,v) -> ' could be abbreviated to just `\t (k,v) -> ', if you prefer
10:55:26 <ski> `l ++ [(k,v)] ++ r' could be `l ++ (k,v) : r' -- but perhaps, you think that's ugly
10:56:18 <pzuraq> a bit
10:56:24 <pzuraq> but would it be more efficient?
10:56:35 <Feuerbach> no
10:56:41 <ski> perhaps -- perhaps the compiler would spot this anyway
10:57:26 <ski> pzuraq : for `(==)',`(<)',`(>)', i think one takes for granted that one of these must hold between two values -- so `otherwise' wouldn't be needed
10:57:43 <pzuraq> it's actually not working
10:58:01 <ski> but you can instead  case k `compare` k' of  and then match on `EQ',`LT',`GT'
10:58:05 <pzuraq> I think it's because if the key doesn't exist it gets caught in an infinite loop
10:58:20 <ski> @type \l x r -> l ++ x : r
10:58:21 <lambdabot> [a] -> a -> [a] -> [a]
10:58:33 * hackagebot hamlet 1.1.5 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.5 (MichaelSnoyman)
11:06:08 <cartetr> we need some counter stories posted to this FUD quora https://www.quora.com/Haskell/Why-choose-Haskell-for-web-applications/answer/Costya-Perepelitsa :(
11:09:14 <hpc> cartetr: i would if quora wasn't such a contemptable website
11:09:30 <cartetr> hpc pleaseeee :)
11:09:53 <hpc> if someone else wants to do it, i would start with something like
11:10:15 <hpc> wrap o c m = do {putStr o; m; putStr c}
11:10:24 <hpc> html = wrap "<html>" "</html>"
11:10:25 <hpc> ...
11:10:46 <clahey> hpc: Contemptable?
11:10:46 <hpc> header body = do
11:10:50 <hpc>   html $ do
11:10:53 <clahey> I just created an account.  Am I in trouble?
11:10:54 <hpc>     head $ do
11:10:55 <hpc>     styles
11:11:04 <hpc>   body ...
11:11:33 <hpc> clahey: i have noscript, so i can't read the page
11:12:07 <clahey> Ah, so no specific knowledge of badness besides requiring js.
11:12:22 <hpc> well it also prevents you from reading answers unless you log in
11:14:20 <uniquenick> even with js, the site seems to prefer giving me a little spinny "loading" image rather than doing anything
11:15:59 <hpc> cartetr: being able to CPS pretty much anything in haskell makes a lot of website logic easier
11:16:08 <cartetr> hpc yeah
11:16:18 <hpc> cartetr: for instance, this is my entire index page: http://hpaste.org/81603
11:17:19 <hpc> and if you want to require a user to be logged in for some specific thing, do something like
11:17:24 <carter> hpc yes: i've done haskell webdev, i'm just not the right person to explain why webdev in haskell is fine to a pythonista friend who reads stuff like this
11:17:26 <mason3> is there a memcmp equivalent for MArray ?
11:17:37 <carter> :)
11:17:43 <hpc> main = autoCGI . redirSecure . requireLoggedIn $ do ...
11:18:25 <Eduard_Munteanu> hpc: what framework do you use?
11:18:32 <hpc> Eduard_Munteanu: totally homebrew
11:18:38 <hpc> depends are hdbc-mysql and sha
11:18:52 <Eduard_Munteanu> And some CGI libs I presume, no?
11:19:04 <hpc> i just read from ENV and stdin
11:19:10 <Eduard_Munteanu> Ah, nice.
11:19:21 <monochrom> look at it from the bright side. a pythonista is likely to turn down hpc's approach anyway
11:19:33 <hpc> haha
11:20:16 * monochrom believes in self-selection. there is a reason a pythonista chose to be a pythonista, or a haskeller chose to be a haskeller
11:20:33 <hpc> monochrom: to be fair, i only wrote it that way to see if i could
11:20:39 <hpc> i would probably use happstack for a real site
11:20:53 <hpc> and the general style of code would be mostly unchanged
11:22:23 <carter> Eduard_Munteanu I've been pretty happy with Snap
11:22:35 <monochrom> perhaps mapArray id is memcpy
11:22:37 <clahey> hpc: Why the redundant do clauses?
11:23:13 <Eduard_Munteanu> I've been using Yesod.
11:23:13 <hpc> clahey: so the code intents in roughly the same way html would
11:23:21 <clahey> hpc: Ah.
11:23:37 <monochrom> other approaches include thaw . unsafeFreeze and unsafeThaw . freeze
11:24:30 <Hafydd> DO NO REFREEEZE
11:24:52 <hpc> arrays are like microwave burritos...
11:25:13 <monochrom> yikes haha
11:25:33 <clahey> hpc: You could do a lot of that with a ListT too in an interesting way.
11:25:39 <clahey> I think?
11:25:48 <clahey> I'm not suggesting it would be better, I just want to know if it's possible.
11:25:59 <hpc> ListT would do strange things
11:26:57 <clahey> Basically I want a Monad where you can write something like:
11:27:14 <hpc> oh god, i forgot i had code to generate javascript in here
11:27:15 <`nand`> hpc: is the output of this program made public anywhere?
11:27:26 <hpc> http://hpc.dyndns-web.com:8000/blog/
11:27:38 <ahokaomaeha> what was the command to check what packages would be affected if I did "cabal install <whatever>"?
11:27:47 <hpc> --dry-run, probably
11:27:50 <clahey> do post <- oncePerItem posts; h3 . blogLink $ post
11:28:06 <clahey> And it will run the second function once per item and then combine them with a monoid.
11:28:12 <clahey> The h3 . bloglink part, I mean.
11:28:27 <hpc> you may be thinking of the ZipList applicative
11:28:39 <linduxed> ok, let's try this again
11:28:42 <clahey> Perhaps.
11:28:48 <hpc> forM_ is easy enough anyway :P
11:28:54 <clahey> True enough.
11:29:19 <clahey> For some reason I don't like writing out lambda functions if it can be avoided in an easily readable way.
11:29:46 <hpc> me either; sometimes just immitating C is the readable way
11:30:01 <clahey> I know that post <- oncePerItem is just shorthand for oncePerItem >>= \post ->
11:30:08 <clahey> Or whatever it is.
11:30:17 <clahey> But I'm more comfortable with that for some reason.
11:30:21 <clahey> Maybe it's the C background.
11:30:49 <linduxed> i've got a a matrix with values like (String, String, Double). I want to use Data.Map fromList on that matrix, so i got the advice that I should use convert (a,b,c) to ((a,b),c). that's fine, but the matrix is symmetric, so i'll have a lot of ((x,y),z), ((y,x),z)
11:31:33 <linduxed> the z are the same, but the keys would be different, so i would have a lot of double entries, when they should really be filtered out as duplicates
11:31:48 <linduxed> how would it fix that?
11:31:53 <`nand`> Map x (Map y z) -- ?
11:32:21 <linduxed> `nand`: i'm sorry... not quite following
11:32:22 <`nand`> err no
11:32:29 <`nand`> that's the same thing as Map (x,y) z
11:32:55 <`nand`> you could create an ordered pair
11:32:59 <`nand`> and use that as an index
11:33:17 <linduxed> i don't know what an ordered pair is
11:33:40 <`nand`> pair :: Ord a => a -> a -> (a, a)
11:33:52 <`nand`> pair a b | a <= b = (a, b) | otherwise = (b, a)
11:34:14 <`nand`> ‘sorted pair’ would be better terminology
11:34:15 <shachaf> Some people might call that an unordered pair. :-)
11:34:21 <`nand`> because ordered pair means something else :)
11:36:12 <clahey> I would call that an unordered pair, yeah.
11:36:44 <elliott> A sorted pair type should be constructable from any two values.
11:36:49 <elliott> It's only the conversion back to a pair that should require Ord.
11:36:56 <elliott> (This lets you give an Applicative instance, etc.)
11:38:21 <clahey> elliott: Isn't the applicative instance built into the pair the right one?
11:38:34 <clahey> Built in to the tuple, I mean?
11:39:42 <elliott> clahey: well, this is if you define a separate type to (,) which I think is a good idea
11:40:43 <`nand`> clahey: the Applicative instance of the existing tuples would violate the invariant the moment you do anything
11:41:17 <`nand`> because you're not enforcing the property that liftA2 (<=) fst snd = const True
11:43:44 <clahey> `nand`: Ah, a good point.
11:43:59 <clahey> But in this case, I don't think the applicative instance is all that interesting then.
11:44:16 <clahey> The Functor instance is, and that also doesn't enforce the property.
11:44:33 <elliott> I am talking about instances you would defined for a separate unordered pair type.
11:44:37 <elliott> Those aren't the same as the instances (,) has.
11:46:00 <`nand`> in particular though that isn't a problem if you just redefine the Eq/Ord instances such that: (a,b) == (c,d) = sort [a,b] == sort [c,d]
11:46:13 <`nand`> (presumably under a newtype wrapper)
11:46:43 <elliott> You don't need Ord for Eq
11:46:49 <clahey> I think I might define the Eq instance as (a,b) == (c,d) = (a == c and b == d) or (a == d and b == c)
11:46:56 <elliott> Right, what clahey said.
11:47:00 <clahey> Sprinkle `
11:47:56 <clahey> Also, I can think of two different equally valid Ord instances.
11:47:56 <elliott> Oh, hmm, Applicative isn't actually possible.
11:48:24 <elliott> I remember someone pointing that out to me in here, actually...
11:48:59 <clahey> Delineated by the value of     pair 1 4 <= pair 2 3
11:49:25 <`nand`> why isn't Applicative possible?
11:49:49 <Taneb> How would you define (<*>)?
11:50:15 <`nand`> Pair f g <*> Pair x y = Pair (f x) (g y) -- ?
11:50:16 <elliott> `nand`: You need e.g. a Semigroup on the values.
11:50:21 <elliott> That violates the invariant.
11:50:26 <elliott> It orders f and g relative to x and y.
11:50:37 <`nand`> ah, yes
11:50:42 <`nand`> the intermediate internal ordering takes an effect now
11:51:05 <elliott> Maybe Semigroup isn't enough. I should just find the log where I worked out what you can do with this type...
11:51:31 <`nand`> (for one, what does it mean for a function to be ordered with respect to another?)
11:52:06 <shachaf> I think you'll find that working with unordered types in Haskell is awful.
11:52:11 <shachaf> hth
11:52:54 <elliott> shachaf: Yeah, who likes Set?
11:53:01 <shachaf> elliott: Set is awful?
11:53:15 <shachaf> Both covariant and contravariant Set.
12:15:40 <parcs> > []
12:15:42 <lambdabot>   []
12:19:30 <Ralith> shachaf: what would you do differently?
12:20:53 <exicer> Is there a way from ghci that I can check what a built in function does ?
12:24:33 <geekosaur> not in stock ghci.  might want to see http://www.haskell.org/haskellwiki/Ghci#GHCi_on_Acid
12:27:26 <Cale> Doesn't the :src thing just work the same way as lambdabot's though?
12:27:58 <Cale> I guess that might be better than nothing
12:28:20 <Cale> exicer: The easiest way to see the source code for things is to click the links along the right margin in the web documentation.
12:35:13 <DanBurton> ok guys I just had a wtf moment while using the optional semicolons
12:35:17 <DanBurton> http://ideone.com/LiaBIl
12:35:27 <geekosaur> I thought there was something more useful in there somewhere like an interface to hoogle
12:35:37 <DanBurton> I know how to fix it by adding more curly braces and semicolons, or by removing them, but why isn't this valid?
12:36:59 <DanBurton> I am trying to lure in the Java peoples, but if you can't write `let foo = bar;` as a single line in your semicolon-separated do block, then... ugh :(
12:38:29 <Iceland_jack> DanBurton: DanBurton: You can't fret over not being able to make Haskell look like Java
12:38:47 <DanBurton> Iceland_jack: oh yes I can
12:38:51 <DanBurton> this is me fretting :P
12:39:15 <Iceland_jack> Well golly gee, apparently you can
12:39:19 <Iceland_jack> carry on
12:44:32 <quicksilver> DanBurton: that looks like a bug to me.
12:45:20 <quicksilver> DanBurton: oh no it's not.
12:45:40 <byorgey> is it because the 'let' introduces layout?
12:45:42 <quicksilver> DanBurton: it assumes your semicolon is terminating the let
12:46:02 <quicksilver> DanBurton: you need   let {greeting = "Hello, " ++ name ++ "!"};
12:46:20 <quicksilver> also valid would be let {greeting = "Hello, " ++ name ++ "!";};
12:46:26 <quicksilver> if you're really keen on the semis.
12:48:48 <DanBurton> aw I just tried   let greeting = "Hello, " ++ name ++ "!";;   with two semis but nope :P
12:49:22 <DanBurton> so it seems buggy that it "assumes my semicolon is terminating the let"
12:50:01 <DanBurton> it greedily eats my semicolon, instead of realizing that I wanted that semicolon for a different purpose
12:50:50 <DanBurton> does Haskell 2010 specify this particular behavior?
12:50:56 <quicksilver> yes.
12:50:58 <quicksilver> I think so.
12:51:25 <int-e> > do let { a=1; b=a:b }; b; return 42
12:51:27 <lambdabot>   [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
12:52:24 * DanBurton is tempted to file a bug report
12:52:47 <int-e> the rules for blocks are designed to work well with layout
12:52:52 <quicksilver> I must admit I'm not quite sure
12:52:55 <DanBurton> oh im gonna try this in tryhaskell.org/hugs
12:52:55 <int-e> not to be pretty without layout
12:52:57 * geekosaur is tempted to agree, actually, but check the language report first; there might well be some peculiarity
12:53:13 <quicksilver> you *haven't* started the let with {
12:53:16 <quicksilver> that makes it a layout-let
12:53:22 <quicksilver> a layout-let embedded in a non-layout do.
12:53:50 <dmwit> > do let { a = 1; }; [a]
12:53:50 <quicksilver> I think what happens is that the position of putStrLn on the next line should obviously end the layout-let
12:53:52 <lambdabot>   [1]
12:53:54 <dmwit> huh
12:54:01 <dmwit> > do let {;}; [1]
12:54:03 <lambdabot>   [1]
12:54:06 <quicksilver> but having ended the layout-let
12:54:13 <geekosaur> there's your pecularity
12:54:15 <quicksilver> you're now in the non-layout-do
12:54:18 <quicksilver> which means you need a ;
12:54:22 <quicksilver> HOWEVER
12:54:34 <quicksilver> I thought the automatic "parse-error-inserts-semicolon"
12:54:39 <quicksilver> was supposed to save you here?
12:54:44 <DanBurton> > do let x = 3; [x]
12:54:46 <lambdabot>   <hint>:1:18: parse error (possibly incorrect indentation)
12:54:49 <quicksilver> or... is it "parse-error-inserts-brace" ?
12:54:56 <geekosaur> brace
12:54:56 <int-e> quicksilver: you're missing that it parses the [x] as part of the let block
12:55:33 <quicksilver> int-e: in whose example?
12:56:08 <int-e> > do let { y = 3; [x] {- this could continue as -} = [42] }; [x]
12:56:11 <lambdabot>   [42]
12:56:15 <DanBurton> basically I want to use "let" as a one-liner statement in a do block where each line is semicolon-terminated. It seems intuitive but is either not specified to work that way, or not implemented to work that way
12:56:42 <geekosaur> see what int-e just said for why that fails
12:56:58 <geekosaur> the point you're missing is that let *also* needs to use explicit braces; it too is a block
12:57:02 <quicksilver> int-e: I know that.
12:57:11 <quicksilver> in  DanBurton's example just there.
12:57:18 <quicksilver> but in his actual pasted code, there is a newline
12:57:26 <quicksilver> and it goes back to a column earlier than the binding
12:57:28 <DanBurton> > do { let x = 3; [x]; } -- no room for it to continue if it sees the ; after [x], right?
12:57:29 <lambdabot>   <hint>:1:20: parse error on input `;'
12:57:39 <quicksilver> so it can't parse putStrLn as part of the let block.
12:57:44 <monochrom> > do { let {x=3}; [x] }
12:57:46 <lambdabot>   [3]
12:57:58 <int-e> quicksilver: but the outer {} disable layout
12:58:34 <quicksilver> int-e: but the let without an { turns it back on
12:58:37 <quicksilver> I thought.
12:58:38 <monochrom> is not shorter than:
12:58:45 <DanBurton> monochrom: I'm trying to avoid the extra set of braces in the let statement to make it look like almost-Java
12:58:45 <quicksilver> perhaps that's where I was wrong.
12:58:46 <monochrom> > let {x=3} in [x]
12:58:47 <lambdabot>   [3]
12:59:01 <int-e> quicksilver: I believe you're wrong but I better check :)
12:59:12 <quicksilver> maybe the rule is simply "if you're nesting non-layout, you better use braces everywhere"
12:59:27 <quicksilver> because otherwise it has no hope of knowing where to close the bits.
12:59:29 <monochrom> not every dream of hacking syntax to look like java can come true
12:59:41 <DanBurton> the thing is, let without { can still have semicolons to delimit several definitions on one line
12:59:54 <DanBurton> > let x = 3; y = 4 in x + y
12:59:55 <lambdabot>   7
12:59:56 <quicksilver> layout-let can, yes.
13:00:05 <monochrom> sure. where does the let end?
13:00:18 <monochrom> if you say "let-in", the "in" ends it
13:00:27 <DanBurton> in this case it ends at "in"
13:00:31 <monochrom> if you use layout, the layout ends it
13:00:40 <monochrom> if you have eof, the eof ends it
13:00:45 <DanBurton> but in the event of a parse error, it should end in such a place as to avoid the parse error
13:01:32 <DanBurton> which is possible with "do { let x = 3; [x]; }", but not happening
13:01:35 <monochrom> ok, go propose it to the Haskell committee
13:01:40 <DanBurton> aight
13:01:43 <int-e> quicksilver: http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3 -- see what it says about "layout contexts" - no extra tokens are inserted inside an explicit context.
13:01:52 <monochrom> or fork GHC and implement it
13:02:00 <monochrom> or fork hugs
13:02:45 <int-e> quicksilver: or am I reading this wrong? tricky.
13:03:03 <Feuerbach> int-e: until the new context is pushed
13:04:39 <DanBurton> oh whoa I didn't realize that the L function was specified in the report
13:04:48 <Feuerbach> a very simple thing happens here, actually
13:05:02 <Feuerbach> let just "eats" that semicolon
13:05:20 <Feuerbach> it's terminated by layout a bit later, of course
13:05:21 <monochrom> http://tryhaskell.org/hugs/
13:05:28 <Feuerbach> if you put semicolon on the next line, it works
13:05:33 <DanBurton> but it shouldn't "eat" it. It should spit it back out when it runs into the parse error
13:05:45 <int-e> Feuerbach: aha! the ; has to be indented less than the let lines.
13:05:52 <Feuerbach> parse error happens later
13:05:55 <Feuerbach> when let block is finished
13:06:05 <Feuerbach> so it has nothing to do with that block
13:06:09 <Feuerbach> it cannot "played back"
13:06:11 <DanBurton> int-e: o_O!
13:06:31 <hpaste> int-e pasted “layout inside explicit block” at http://hpaste.org/81607
13:06:55 <int-e> so this works. and it's ugly. (even when the semicolon is 3 places further to the left)
13:07:08 <DanBurton> int-e: very clever, though
13:07:12 <DanBurton> int-e++
13:07:23 <int-e> quicksilver: thanks, you were right :)
13:08:17 <quicksilver> int-e: ah, so you need a semicolon to terminate let-as-a-statement
13:08:38 <quicksilver> but it needs to be placed somewhere it can't be misinterpreted as the end of a let-defn.
13:08:50 <quicksilver> this is why you should put semicolons at the beginnings of statements!
13:08:54 <quicksilver> it would have been fine then.
13:09:10 <monochrom> I used to do that. it was to help an old indenter
13:09:26 <int-e> DanBurton: you coul cheat and put semicolons *in front* of the "statements". do {<newline>  ;[1]<newline>  ;let x=1<newline>  ;[3]<newline>}
13:09:28 <DanBurton> I once wrote C code by putting semicolons at the beginnings. I showed it to the C irc channel and they were all quite amused
13:09:45 <int-e> oh quicksilver was faster
13:10:08 <quicksilver> they don't call me slowsilver.
13:10:12 <monochrom> haha
13:11:10 <skp> hey
13:11:21 <skp> I installed my own program with cabal install
13:11:41 <skp> (I should have used something more adapted since it’s WIP… anyways)
13:11:54 <skp> how do I uninstall it though ghc-pkg?
13:11:58 <skp> thanks in advance!
13:12:04 <skp> through*
13:12:28 <monochrom> "represent an invalid prefix of the Haskell grammar" does not stand for all possible parse errors
13:13:21 <monochrom> "let { x=3; print" is a valid prefix. witnessing completion: "let { x=3; print f = 4 }"
13:13:39 <timemage> DanBurton, in C, the semicolon is a terminator rather than a delimiter.  that's probably the most logical reason for putting it at the end of each line with the rest of the statement.  given the bickering that goes with question about where and when to place braces and parenthesis, it was probably amusing to find something else to fight about.
13:13:57 <monochrom> you may need unlimited lookahead to catch all parse errors
13:15:02 <monochrom> "let{x=3;[x]" is still a valid prefix. witnessing completion: "let{x=3;[x]=take 1 blah}"
13:15:19 <int-e> monochrom: try "="
13:15:50 <monochrom> you mean "let{x=3;="?
13:16:13 <int-e> > read . show $ repeat ' '
13:16:17 <lambdabot>   mueval-core: Time limit exceeded
13:16:23 <exicer> on the web documentation, is there some way to search by function name ?
13:16:44 <monochrom> then whether the computer inserts } or not, you still get a parse error
13:16:47 <DanBurton> timemage: one comment I particularly enjoyed was "I think that is the ugliest consistent C coding style I have ever seen". Yeah I had to adopt weird conventions like replacing } with ;} to make sure the final terminating semicolon was not missing
13:16:47 <int-e> monochrom: instead of hte let, actually. :)
13:16:54 <timemage> exicer, have you played with hoogle?
13:17:05 <monochrom> "={x=3;[x]"?
13:17:14 <exicer> timemage: Not at all! What is it ?
13:17:18 <DanBurton> exicer: you mean besides ctrl-f? ;)
13:17:20 <plat0> I'm puzzled why the implementation of Prelude.sum is not strict in its accumulator
13:17:23 <int-e> monochrom: no, "=". grrr. :)
13:17:25 <monochrom> I seriously don't know what you mean
13:17:40 <timemage> exicer, ehh, put hoogle into google.  stick a function name in the search box.  see what you get.
13:17:52 <int-e> monochrom: I want a valid haskell expression that starts with "=".
13:17:55 <exicer> timemage: Okay that is usefl
13:17:58 <DanBurton> plat0: in case you want to use a lazy numeric type
13:18:04 <exicer> DanBurton: I did not realise you could list everything on one page :p
13:18:08 <monochrom> ok, but I can't think of one
13:18:13 <int-e> monochrom: (I don't see any either)
13:19:06 <monochrom> if you see "=" as a prefix, then whether the computer adds } or not, it is still a parse error
13:19:11 <timemage> exicer, they have a search plugin.  if you find yourself using it a lot you might want to add that.
13:20:28 <int-e> monochrom: ok, now I understand what you're after. hmm.
13:21:06 <fizbin> Does anyone know of a good example of how to use ErrorT combined with a non-IO Monad like Maybe or List? I don't understand how or when to use runErrorT and when to use 'do' notation, and am having trouble keeping all the types straight.
13:21:32 <quicksilver> you use runErrorT when you want to unwrap it and get the actual Either back
13:21:42 <quicksilver> you don't use it, when you want to keep the errors hidden/implicit.
13:23:00 <monochrom> get your types straight first, then you will know where to add runErrorT
13:23:25 <fizbin> Okay, fair enough, so I won't use runErrorT. I'm still confused about how to handle these two monads that I'm running together, sort of.
13:23:34 <caseyjames> Hello, does anyone here code in C++ as well as Haskell.  I am working with FFI and am looking for effective approaches to C++ that avoid OOP without templates or boost::phoenix.  I would really appreciate some general tips.
13:23:36 <luqui> fizbin: typically you only use runErrorT once, at the "end" (more precisely, wrapped around the entire computation which needs to handle errors)
13:23:46 <fizbin> monochrom: I'd love to get my types straight, that's why I'm asking for examples.
13:24:26 <luqui> e.g.:    runErrorT $ do { foo;  bar;  when baz (fail ""); return quux }
13:24:47 <fizbin> What's the type of that, Either _ _ ?
13:24:49 <monochrom> except I don't combine ErrorT with Maybe or List
13:25:12 <luqui> fizbin: m (Either _ _), where m is the monad you are transforming
13:26:00 <monochrom> but I can do ErrorT String (State Int)
13:26:03 <luqui> so that runErrorT $ …  could be in another do block of the underlying monad
13:27:16 <luqui> forall <conditions>.  hmmm… effective C++ such that <conditions> -- can't think of anything.
13:27:26 <fizbin> Well, see, I've got this function written in do-notation style that parses one structure (a Text.XML.Light thing) into a (Maybe OutputStructure) and now I want to clean it up and turn some of the places where I'd end up returning Nothing into errors/Lefts, and keep some of them returning Right Nothing.
13:27:43 <monochrom> runState 0 (runErrorT (do {put 1; throwError "bye"}))
13:28:19 <luqui> fizbin: what is the semantic difference between Left err and Right Nothing?
13:28:27 <luqui> (i.e. why do you want to distinguish)
13:29:15 <monochrom> with some types: runState 0 (runErrorT (do {put 1; throwError "bye"} :: ErrorT String (State Int) ()) :: State Int (Either String ()))
13:29:20 <fizbin> The XML node was of the wrong type -> Right Nothing. The XML node was of the correct type but some of the attributes were missing or contradictory -> Left err.
13:29:35 <monochrom> > runState 0 (runErrorT (do {put 1; throwError "bye"}))
13:29:38 <lambdabot>   No instance for (GHC.Num.Num
13:29:38 <lambdabot>                     (Control.Monad.Trans.State...
13:29:49 <monochrom> oh, flipped arguments
13:29:55 <monochrom> > runState (runErrorT (do {put 1; throwError "bye"})) 0
13:29:57 <lambdabot>   (Left "bye",1)
13:31:45 <fizbin> Hrm. Okay. I still find this confusing, but that gives me a start to play with.
13:31:57 <fizbin> Thanks.
13:32:03 <luqui> fizbin: are you using that difference to aid your transformation in some way?  e.g. going thorugh all the nodes until you get a Just and then returning that one?  whereas the error would abort the computation immediately?
13:32:12 <monochrom> I refuse to cooperate with ErrorT e Maybe. especially when the Maybe is for yet another error
13:32:39 <luqui> monochrom: hang on, dude.  there may be purpose after all, let's find out
13:33:19 <fizbin> I'm currently taking the whole structure and doing a mapMaybe over the root node's children.
13:33:29 <monochrom> "The XML node was of the wrong type -> Right Nothing. The XML node was of the correct type but some of the attributes were missing or contradictory -> Left err." I think I already know the purpose, and it fits exactly what I said
13:34:14 <fizbin> There's a difference between "these are not the droid's you're looking for" and "these are the droids I'm looking for, but they're broken"
13:34:33 <monochrom> we're looking at ErrorT BadThingsFirstKind (ErrorT BadThingsSecondKind (ErrorT BadThingsThirdKind ...
13:35:00 <kmels> why would Ty have a Show instance in haddock but not in the source code for Ty? http://hackage.haskell.org/packages/archive/extcore/1.0.1/doc/html/Language-Core-Core.html#t:Ty
13:35:13 <hpaste> fragamus pasted “How's this” at http://hpaste.org/81609
13:35:13 <luqui> fizbin: yeah, if you plan to abort in both cases, I suggest losing the Maybe and using an ADT describing the possible errors
13:35:26 <monochrom> data BadThings = WrongNode | WrongAttribute. ErrorT BadThings Identity.
13:35:30 <kmels> I have a function Vdefg -> String that can print the Ty in it, but I can't call show on a Ty, and that seems weird
13:35:32 <fizbin> Except I don't plan to abort in both cases.
13:36:12 <luqui> fizbin: so it's more like my example above?
13:36:44 <luqui> yeah ok, sry took me a little while to process
13:36:58 <monochrom> use catchError to prevent aborting
13:37:02 <fizbin> What I plan to do is have a function that does [Element] -> Either String [MyOutputType] where the list I get with a Right is composed of those things that came out as "Right Just _" in the other function.
13:37:03 <luqui> fizbin: yeah ErrorT _ (Maybe a) seems reasonable.
13:37:29 <fizbin> (Or maybe some other error type instead of String. Not sure yet)
13:37:38 <luqui> monochrom: he is not treating Right Nothing as an error
13:37:59 <luqui> It may be reasonable to go with ErrorT _ [a]
13:38:13 <luqui> because [a] is the structure you're going for -- a list of matched nodes
13:38:40 <luqui> even if each "subcomputation" can only return 0 or 1, it makes sense to me to return [] or [x], because it indicates that you intend to concatenate
13:38:59 <fizbin> Ah, so I'd return [] where I was planning on returning Nothing. Fair.
13:39:19 <luqui> but that is mostly to appease monochrom, convincing him that Nothing doesn't indicate an error :-)
13:39:26 <hpaste> glguy pasted “exceptiont and maybe” at http://hpaste.org/81610
13:39:41 <glguy> It makes sense to me because ExceptionT shouldn't be grabbing "fail"
13:40:01 <luqui> data E = XTooBig | XTooBig eh?
13:40:21 <glguy> yeah, making a custom exception type is normal, that's just an example
13:40:23 <luqui> yeah ErrorT is kind of lame.
13:40:29 <glguy> oh, I mistyped 'y'
13:40:30 <glguy> :)
13:40:41 <glguy> whatevs :)
13:40:48 <luqui> because it constrains its error parameter, which makes it less composable
13:41:29 <fizbin> Um… Okay, that's a bit odd. The monads Either and Maybe feel opposite-composed there in the paste to how I want them eventually.
13:41:37 <luqui> it'll be fine for fizbin's case, but I usually reach for explicit-exception instead
13:42:05 <monochrom> fizbin, it is always opposite-composed
13:42:05 <fizbin> I think I will go with ErrorT _ [s]
13:42:14 <luqui> yeah there is a bit of backwardness in transformers.  to run x :: FooT Bar a, you runBar (runFooT x)
13:42:46 <uniquenick> is there something like intToDigit that works on the whole alphabet instead of just up to f?
13:42:59 <monochrom> ErrorT State is always runState (runErrorT). StateT Error is always runError (runStateT). the order is always flipped.
13:43:07 <luqui> uniquenick: you mean 0 -> 0, 1 -> 1, … a -> 10, b -> 11, z -> 36 ?
13:43:15 <uniquenick> exactly
13:43:23 <luqui> uniquenick: i doubt i
13:43:24 <luqui> t
13:43:55 <luqui> uniquenick: I like your nick, btw ;-)
13:44:32 <dmwit> :t (`lookup` ['0'..'9'] ++ ['a'..'z'])
13:44:34 <lambdabot>     The operator `lookup' [infixl 9] of a section
13:44:34 <lambdabot>         must have lower precedence than that of the operand,
13:44:34 <lambdabot>           namely `++' [infixr 5]
13:44:41 <dmwit> :t findIndex
13:44:43 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
13:45:06 <luqui> :t (`lookup` zip (['0'..'9'] ++ ['a'..'z']) [0..])
13:45:08 <lambdabot> (Enum b, Num b) => Char -> Maybe b
13:45:11 <dmwit> :t \c -> findIndex (c==) (['0'..'9'] ++ ['a'..'z'])
13:45:13 <lambdabot> Char -> Maybe Int
13:48:48 * hackagebot cabal-sign 0.1.0.0 - Sign and verify Cabal packages.  http://hackage.haskell.org/package/cabal-sign-0.1.0.0 (ChrisDone)
13:50:15 <monochrom> yikes, now we have a package-signing package!
13:50:35 <dmwit> What does it do?
13:50:38 <monochrom> I mean: nice, we now act on the haskell-cafe sign-your-package thread, not just talking
13:50:51 <monochrom> I'll link you to that thread
13:51:09 <yitz> monochrom: look on the bright side. maybe now apple will accept haskell ios apps for the app store.
13:51:19 <monochrom> it accounts of half of haskell-cafe messages today
13:51:49 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/103068
13:52:24 <plat0> How do I specify -O level to ghc-core?
13:53:07 <parcs> pass it to ghc-core?
13:53:57 <plat0> % ~/.cabal/bin/ghc-core -O2 test2.hs
13:53:57 <plat0> ghc-core: user error (unrecognized option `-O'
13:53:57 <plat0> unrecognized option `-2'
13:54:24 <horlicks> yitz: apple don't like haskell?
13:54:31 <horlicks> I was thinking of writing an app in haskell
13:55:04 <n-dolio> They lifted that policy a while ago.
13:55:28 <n-dolio> After long enough to kill flash->ios compilers.
13:56:11 <n-dolio> Or, the one Adobe was working on, at least.
13:56:12 <plat0> Oh, I need -- before the ghc options
13:56:40 <monochrom> you see how I don't use ghc-core
13:57:05 <monochrom> I type in "ghc -c -ddump-simpl -dsuppress-uniques -fforce-recomp" all the time :)
13:57:54 <plat0> Well I might do that
14:01:05 <monoidal> anyone know the reason why '[] :: [*] while [] :: [a]?
14:01:56 <monochrom> is "[] :: [*]" even true? where?
14:02:05 <hiptobecubic> '[]
14:02:07 <Taneb> One's a kind, the other's a type?
14:02:18 <monoidal> yes
14:02:21 <glguy> Prelude> :k '[]
14:02:21 <glguy> '[] :: [*]
14:02:34 <monoidal> ah. need to turn on -XPolyKinds
14:02:57 <monoidal> then ghci gives '[] :: [k]
14:03:05 <uniquenick> so "map (\x -> lookup x test) foo" gives me a [Maybe Char], and I want a Maybe [Char] instead, so I want to use >>= instead of map?
14:03:30 <monoidal> uniquenick: mapM
14:04:06 <monoidal> uniquenick: there's a function sequence :: Monad m => [m a] -> m a that you can try to write
14:04:12 <monoidal> uniquenick: mapM f x = sequence (map f x)
14:05:03 <uniquenick> oh right, if I had lists inside of lists then >>= would make sense right?  But it doesn't make sense for Maybes inside of a list
14:05:54 <monoidal> it makes sense for both lists and maybes
14:06:37 <monoidal> only the behavior is different. for lists, >>= is the same as concatMap (flipped), for >>= it is Nothing >>= _ = Nothing; Just x >>= f = f x
14:06:47 <monoidal> > sequence [Just 1, Just 2, Nothing]
14:06:49 <lambdabot>   Nothing
14:06:54 <monoidal> > sequence [Just 1, Just 2, Just 3]
14:06:56 <lambdabot>   Just [1,2,3]
14:07:01 <monoidal> > sequence [[0,1], [2,3], [4,5]]
14:07:03 <lambdabot>   [[0,2,4],[0,2,5],[0,3,4],[0,3,5],[1,2,4],[1,2,5],[1,3,4],[1,3,5]]
14:07:28 <Nisstyre-laptop> What would people recommend as far as functional priority queues go?
14:07:38 <monoidal> sequence [x1, x2, ..., xn] = do a1 <- x1; a2 <- x2; ... an <- xn; return [a1,a2,...,an]
14:09:48 <bitonic> Nisstyre-laptop: see PSQueue & co.
14:10:14 <Nisstyre-laptop> bitonic: is that the name of the package on hackage?
14:10:20 <Nisstyre-laptop> I shall check it out
14:10:25 <bitonic> Nisstyre-laptop: it is.  it links to relevant paper.
14:10:48 <Nisstyre-laptop> bitonic: neat, thanks
14:10:54 <Nisstyre-laptop> is it using finger trees?
14:11:42 <bitonic> Nisstyre-laptop: either that or tournament trees, can’t remember.  the package will answer better than me
14:11:47 <ezyang> Does fgl support SCC computation?
14:11:50 <elliott> monochrom: this -cafe thread makes me want to ban people from saying cabal is not a package manager
14:13:00 <Nisstyre-laptop> bitonic: package description doesn't say what it uses, but it's not a big deal anyway
14:13:13 <bitonic> Nisstyre-laptop: check the source of the tree ADT
14:13:21 <Nisstyre-laptop> yeah, I'll do that
14:13:30 <bitonic> or the paper
14:13:47 <sclv> elliott: cabal is not meant to manage or install haskell packages, or to download them, or to talk about them.
14:13:52 <Taneb> Is there a function ComonadStore s w => a -> w a -> w a
14:13:57 <sclv> or to reference them.
14:13:58 <Taneb> That sets the current location
14:14:01 <sclv> directly, or indirectly.
14:14:19 <ezyang> oh, apparently it's in the DFS module
14:14:24 <sclv> it is designed solely to not let you use haskell packages, in fact.
14:15:06 <elliott> sclv: It does that job very well.
14:15:07 <sclv> if you've ever used a haskell package in any fashion, from any source, you're probably doing it wrong
14:16:05 <sclv> people that heed this advice will have a perfect record with regards to package breaks!
14:17:47 <monochrom> too bad elliott, you can't ban people on haskell-cafe :)
14:18:03 <elliott> not until I am all-powerful
14:18:18 <Clint> you can reply to each and every one of them though
14:18:25 * monochrom is agnostic to "is cabal a package manager" debates, and generally pointless debates
14:18:33 <monochrom> @quote monochrom pointless
14:18:33 <lambdabot> monochrom says: All pointless debates can be settled by going polymorphic.
14:20:32 <monochrom> the debate is a wide-scope XY problem
14:24:16 <monochrom> "I want dependency chasing. I think it can be done by classifying cabal as a package manager"
14:25:15 <monochrom> "I am a sysadmin and I want coherent software on the system. I think it can be done by classifying cabal as not a package manager"
14:25:25 <luqui> what is the argument against cabal as a package manageR?
14:25:38 <glguy> it doesn't implement all the package manager things
14:26:16 <luqui> ok.  then it's a generalized package manager.
14:26:26 <glguy> some people thing that it's broken and should have the rest of package manager stuff implemented and some people think its missing those features because it isn't supposed to have them
14:26:40 <quicksilver> some people think it has already gone too far.
14:26:40 <monochrom> beware of that notion. you will then get degenerate package managers, too :)
14:26:55 <glguy> so pick your side and "contribute" to the mailing list ;)
14:26:55 <monochrom> tar -xzf is my degenerate package manager :)
14:26:57 <luqui> :-)
14:26:57 <quicksilver> some people speak loudly without actually understanding just to make the debate interesting.
14:27:09 <luqui> yes… "interesting"
14:27:14 <quicksilver> personally I just like to troll dcoutts_.
14:27:18 <Clint> i'm suspicious of any package manager that builds things from source
14:27:21 <quicksilver> but I normally do that in IRC not the mailing list.
14:27:47 <monochrom> what did you do to troll dcoutts? I want to know. perhaps an example?
14:27:50 <gienah> Clint: guess you should avoid Gentoo then
14:28:05 <Clint> gienah: i should, but i don't consider emerge to be a package manager
14:28:11 <monochrom> hahaha
14:28:23 <monochrom> (saw it coming, hehe)
14:28:30 <quicksilver> Seriously, there is a confusion cabal-the-library (primarily a build system, like 'make'), cabal-install-the-executable (a download-and-install program) and ghc-pkg (which can do certain pacakge maintenance things to installed packages)
14:28:48 <quicksilver> lots of haskell *veterans* get that confused, it's no wonder the newbies do.
14:29:09 <hpaste> I'm being attacked. -_- brb while I smash humans with my banhammer
14:29:17 <Clint> o_O
14:29:25 <glguy> If you want people to call it "cabal-install" you might rename the executable
14:29:29 <monochrom> that is not the most important confusion. consider the union of the three. is that a package manager now? I believe people actually mean that when they talk about the question
14:29:36 <glguy> unless we're distinguishing between cabal and Cabal
14:29:36 <quicksilver> monochrom: I occasionally make sweeping (incorrect) statements about things I don't understand in the hope that dcoutts_ (and, in the old days, Saizan) will come forward, correct me, and thus produce enlightenment.
14:30:02 <glguy> (general you)
14:30:13 <quicksilver> it's not a very savory habit, and I try not to :)
14:30:29 <monochrom> I see
14:30:33 <emacstheviking> Sometimes cabal makes me want to not use Haskell at all!
14:30:55 <monochrom> use hugs and cabal. greener pasture there.
14:31:36 <elliott> greener, since you can't actually install any packages with cabal
14:31:39 <elliott> and hence do not have to use it
14:32:32 <quicksilver> downloading packages is a simple task. It's helpful to have a tool which automates downloading and building.
14:32:46 <elliott> luqui: the argument seems to go like this:
14:32:52 * glguy has no idea who is being serious anymore
14:32:56 <quicksilver> satisfying dependencies is hard. generating consistent sets of versions is hard. Working out what things to recompile to regain a consistent set is hard.
14:32:58 <elliott> luqui: cabal is bad at being a package manager, as many people often point out.
14:33:05 <quicksilver> cabal-install doesn't make those things magically
14:33:07 <quicksilver> easy.
14:33:14 <quicksilver> it doesn't actually make them harder than they already were, though.
14:33:15 <elliott> luqui: therefore, it is not a package manager, which means it does not have to be changed to not be a bad package manager, since it is already not one
14:33:19 <quicksilver> but people still blame it.
14:33:52 <quicksilver> if you refrain from using cabal-install and want a library upgrade you still have a very hard problem to solve to work out which libraries need upgrading, and which merely need recompiling.
14:33:57 <luqui> elliott: yeah that definitely sounds more like a discussion about a label than about cabal
14:34:13 <mikeplus64> > [0,1,2,error "aaa"]
14:34:15 <lambdabot>   [0,1,2,*Exception: aaa
14:34:26 <luqui> i think of library versions as mutable state
14:34:35 <elliott> more seriously, whether it's intended as a package manager or not, people use it as one, it sort of kind of works as one, people expect it to work like one, people tell others to use it like one, it has features that make most sense in the context of a package manager
14:34:40 <luqui> as haskell fanatics, what are we bothering with it for?
14:34:43 <elliott> so regardless of intent, cabal being a bad package manager harms the infrastructure
14:34:48 <emacstheviking> Would it be "better" (whatever that means) to merge ghc-pkg and cabal and do away with cabal???
14:35:01 <nejucomo> Um...  What are the complaints about cabal?  How is it a bad package manager?
14:35:11 <hiptobecubic> it's write only, for one.
14:35:25 <luqui> nejucomo: it fails to solve the hard computational problems associated with dependencies
14:35:32 <emacstheviking> That's my point about ghc-pkg and cabal being merged right there!
14:35:42 <nejucomo> Do you mean it doesn't do ghc-pkg unregister gracefully?
14:35:45 <emacstheviking> yes
14:35:48 * elliott doesn't understand emacstheviking's proposal.
14:36:00 <elliott> In particular do you mean cabal the library or cabal-install?
14:36:00 <Raydiation> what is a monad? a function that uses partial application to store values?
14:36:05 <nejucomo> luqui: What are those?
14:36:24 <monochrom> haha, time to say: what have I started :)
14:36:32 <monoidal> Raydiation: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:36:36 <emacstheviking> I mean, instead of havint *two* tools, why not try to combine then and make it easier to learn the tool set... when I started with Haskell (about two years ago) it was my biggest issue until I learned that ghc-pkg is also to hand.
14:36:37 <mikeplus64> Raydiation: in a way, that's a lot of state-like monads, yeah
14:36:47 <Raydiation> ty
14:37:11 <nejucomo> emacstheviking: I'd disagree.  Having two separate tools that focus on different domains seems cleaner and easier to reason about.
14:37:27 <nejucomo> (-but I'm pretty used to thinks like the dpkg / apt-get dichotomy...)
14:37:43 <emacstheviking> I can agree now with my knowledge gained over those two years... but to start with it was hell! LOL
14:38:02 <uniquenick> is there a shortcut for doing something like "data Mytype = Option1 | Option2" and "mytypeConverter Option1 = 1; mytypeConverter Option2 = 2"?
14:38:03 <quicksilver> I think the "problem" with cabal is mostly that hackage doesn't have a curated consistent set of package versions
14:38:13 <emacstheviking> This week for example I've tried for a few days on and off to "cabal install hoodle" but to no avail!
14:38:15 <quicksilver> (not that this is not cabal's fault)
14:38:17 <elliott> nejucomo: you forgot apt-cache :)
14:38:21 <quicksilver> uniquenick: deriving Enum
14:38:24 <nejucomo> I mean, the absurdist extension of the "merge" argument is to merge ghc into cabal, too.  >;-)
14:38:28 <quicksilver> uniquenick: then 'fromEnum' is your myTypeConverter
14:38:42 <quicksilver> this is the difference with dpkg/rpm/whatever
14:38:46 <emacstheviking> Sometimes the dependency messages are just hard to fathom out so one walks away ...maybe for good, except I am a glutton for punishment.
14:38:47 <hiptobecubic> i don't think that's a problem with cabal
14:38:57 <quicksilver> (the package maintainers build curated consistent sets of versions for you)
14:39:05 <uniquenick> is there a more general shortcut?  my actual case returns Chars not ints, and they aren't sequential
14:39:26 <emacstheviking> why merge the compiler??? This is humour right? ;)
14:39:40 <nejucomo> Yes, I wasn't serious.
14:39:45 <monochrom> merge with a C++ compiler too, while we're at it :)
14:39:47 <quicksilver> uniquenick: I don't understand, what would be shorter?
14:39:55 <quicksilver> uniquenick: what kind of syntax do you imagine?
14:40:31 <emacstheviking> After 27 years as a software engineer I still don't understand how computers work sometimes! LOL... I once thought that a CPU could actually be an "enlightened" sentient form!
14:40:37 <nejucomo> quicksilver: I would prefer a toolchain that does not *rely* on a curated package set; although if someone wants to provide one, that's fine by me.
14:40:49 <mikeplus64> emacstheviking: who says they aren't? ;)
14:40:50 <quicksilver> nejucomo: no such toolchain exists.
14:41:12 <quicksilver> (as far as I know, unless it was nix?)
14:41:22 <emacstheviking> Ow, my head hurts now. You are right though. I read something recently about all of us being just  big computer experiment. Some serious thinkers there for sure.
14:41:25 <monochrom> hackage is a degenerated generalized curated package set
14:42:04 <Jesin> um
14:42:12 <nejucomo> quicksilver: What I mean I want the authors of software to be the authority on their software's dependencies, not a third party.
14:42:14 <emacstheviking> what he said
14:42:28 <quicksilver> nejucomo: OK, well that part kind of is what we have.
14:42:36 <Jesin> <emacstheviking> After 27 years as a software engineer I still don't understand how computers work sometimes! LOL... I once thought that a CPU could actually be an "enlightened" sentient form!
14:42:36 <Jesin> <mikeplus64> emacstheviking: who says they aren't? ;)
14:42:38 <quicksilver> nejucomo: but the package authors don't know the second order effects.
14:42:39 <nejucomo> Yet, I use debian, so I guess I'm all talk, no walk.  ;-)
14:42:51 <emacstheviking> Has anybody any experience of the "sandboxed" cabal setup; I keep meaning to try it out but I have so much installed... would I have to install everything again?
14:43:06 <startling> is there an IndexedPlated or am I making that up?
14:43:18 <nejucomo> quicksilver: It's completely fine for there to be a curated set, which patches the upstream source, just so long as the end-user toolchain lets the user choose.
14:43:24 <elliott> startling: not afaik
14:43:25 <Jesin> depends what you mean by that.
14:43:27 <Jesin> <_<
14:43:32 <nejucomo> *the user choose which authority they subscribe to.
14:43:35 <startling> elliott: dang
14:43:49 <elliott> startling: maybe it should! ask edwardk :P
14:44:03 <monochrom> emacstheviking: next time you switch to a new GHC version, everything you installed is useless. that may be a good time
14:44:39 <nejucomo> Oh wait, my coffee-fueled-soapbox-o-meter just chimed...
14:44:42 <Jesin> um
14:44:47 <Jesin> "sandboxed"?
14:45:04 <emacstheviking> localised cabal environments....
14:45:12 <Jesin> ah
14:45:28 <Jesin> isn't that just a matter of not passing --global ?
14:45:42 <nejucomo> emacstheviking: That would be a nice feature set...  perhaps it can be built outside of cabal itself.
14:45:51 <monochrom> you cannot omit --global. base is in global
14:45:56 <emacstheviking> sort of: except IIRC that all goes into ~/.cabal along with all other non-global so still risks of duff deps. etc
14:46:45 <carter> I will mention this: i do know of at least one effort in progress by the alphaheavy folks to build a better cabal-install
14:46:48 <carter> hackage thingy
14:46:52 <emacstheviking> What I have read is that people are setting up multiple cabal environments that are all isolated, maybe on a per-project basis to reduce problems with dependencies
14:46:56 <carter> for build plans, they're using an SMT solver!
14:47:12 <Ralith> what's the M stand for
14:47:14 <emacstheviking> SMT? Non-math person here! Medic, brain down!!
14:47:21 <carter> ('cause choosing the maximal versions with consistent constraints is kinda an integer programming problem)
14:47:26 <carter> hehe
14:47:40 <monochrom> I don't think SMT makes a difference wrt SAT for this
14:47:42 <emacstheviking> simeltaneous ... .. ?
14:47:46 <carter> Satisfiability modulo theoryies
14:47:53 <emacstheviking> (thud) Nurse!
14:48:04 <carter> basically SAT generalized so you can say inequalities over integers etc
14:48:15 <carter> instead of just and or not over booleans
14:48:18 <emacstheviking> I got A-level maths in the UK about 30 years ago so take it easy! ;)
14:48:26 <monochrom> oh, integer programming, then SMT is more convenient
14:48:35 <carter> "you write the problem down directly"
14:48:37 <carter> yeah
14:48:55 <startling> oh, cool, there's an -XDeriveTraversable
14:51:35 <carter> ttyl all,
14:54:25 <emacstheviking> OK, just jacked my head into the venerable wikipedia on SMT and decision problems... I think I can see the point of SMT and dependency calculations... that's the sort of thing I would have used Prolog for if I could remembe r how. Been a while on that one.
15:07:37 <lambdazerocool> Quick (noob) question on the dot operator. I've got a function "cube x = x**3" and another one "square x = x**2". When trying to compute "cube . square . 2" in GHCI, I get an error, but when I use "cube $ square $ 2", I get 64.0. Is there something I don't know about the (.) operator?
15:08:07 <hpc> (.) and ($) are two different things, and operator precedence is what makes things look odd
15:08:27 <sipa> lambdazerocool: you want (cube . square) 2, or cube . square $ 2
15:08:28 <hpc> cube . square . 2 = \x -> (cube (square (2 x)))
15:08:30 <hpc> which is wrong
15:08:42 <hpc> and cube $ square $ 2 = cube $ (square $ (2))
15:09:14 <hpc> and yeah, cube . square $ 2 = (cube . square) 2 = cube (square 2)
15:09:24 <lambdazerocool> i see, (cube . square) 2 is what i was after. thanks! (for the record - I did not mean "cube . square . 2", but rather, "cube . square 2", which also does not work due to precedence). Thanks a bunch everyone!
15:09:46 <lambdazerocool> sipa++
15:09:50 <sipa> cube . square 2 = \x -> (cube (square 2 x))
15:10:00 <lambdazerocool> hpc++
15:12:20 <nejucomo> What are sipa and hpc?
15:13:12 <nejucomo> :t ($)
15:13:14 <lambdabot> (a -> b) -> a -> b
15:13:42 <Iceland_jack> ($) ∷ (α → β) → (α → β)
15:13:43 <nejucomo> Does ($) introduce runtime overhead, or is it "magically" compiled out?
15:13:49 * hackagebot repl 0.95 - IRC friendly REPL library.  http://hackage.haskell.org/package/repl-0.95 (MikeLedger)
15:14:17 <luqui> nejucomo: they are people
15:14:20 <hpc> neutrino: sipa and hpc are robots
15:14:28 <hpc> they refer to themselves in the plural third person
15:14:51 <luqui> nejucomo: it is rather unmagically compiled out
15:14:58 <nejucomo> "People, robots, it's all the same in the 21st."
15:15:00 <Saizan> nejucomo: i expect it to get inlined away
15:15:01 <nejucomo> luqui: hehe...
15:15:17 <quicksilver> nejucomo: it's not really magical, but all "small" functions get inlined
15:15:21 <quicksilver> and $ is certainly small.
15:15:37 <quicksilver> so it has no overhead.
15:15:56 <quicksilver> except perhaps in a case like "map (map ($))"
15:16:27 <nejucomo> Hm.  Does inlining affect undefined results?  It there any way (f $ undefined) and (f undefined) could differ?
15:16:57 <lambdazerocool> also, is the overhead in map (map ($)) only because you're creating a number of instances of it to hang out until further notice?
15:17:16 <clahey> lambdazerocool: You're not creating anything.
15:17:20 <clahey> You're asking for a value.
15:17:27 <clahey> The compiler has to figure out how to give you that value.
15:17:44 <Saizan> yes, and the usual strategy is to create stuff
15:17:57 <clahey> Unless it can figure out how not to.
15:18:20 <clahey> In the case of map (map ($)), you're giving it a problem that it doesn't realize can be reduced to id.
15:18:24 <quicksilver> nejucomo: I don't think so.
15:18:37 <Saizan> if you force "map (map ($)) xs" you can reasonably expect that your heap will get populated with partially applied nodes
15:18:48 <clahey> Saizan: Why?
15:18:55 <clahey> Saizan: Oh, force.
15:18:57 <clahey> Yes, I see.
15:19:12 <mikeplus64> i'm curious about how much copying GHC does (and bad at reading assembly) with expressions like modifyIORef something (x: {- or some other update -})
15:19:29 <Saizan> i might be wrong though, maybe it just creates new cons cells
15:19:35 <quicksilver> lambdazerocool: it's not actually multiple instances of ($). All the ($)s will be pointeres to the same object.
15:19:48 <quicksilver> but it is a bunch of closures which will require work to reduce.
15:19:53 <quicksilver> which is not zero-overhead.
15:20:04 <thoughtpolice> mikeplus64: it won't necessarily introduce a copy. it will introduce allocations
15:20:07 <mikeplus64> Saizan: for that, that's what you'd think yeah, but what about say modifyIORef x (\r -> r {somefield = somevalue})?
15:20:31 <quicksilver> mikeplus64: you don't need to use modifyIORef to ask that question.
15:20:55 <quicksilver> mikeplus64: you can just ask the question "let t = r { somefield = somevalue } in (t,r)"
15:21:17 <lambdazerocool> clahe: due to lazy evaluation?
15:21:17 <lambdazerocool> clahey: or rather, map (map ($)) would just leave everything... evaluated when it gets evaluated?
15:21:17 <S11001001> @ty map $ map $ ($)
15:21:19 <lambdabot> [[a -> b]] -> [[a -> b]]
15:21:28 <mikeplus64> quicksilver: ok. does that copy r?
15:21:33 <quicksilver> mikeplus64: the answer is, "t and r are separate pointers to separate heap objects; all the fields in t point to the same place as all the fields in r, except one"
15:21:42 <quicksilver> mikeplus64: a 'shallow' copy of r, yes.
15:21:45 <mikeplus64> ah
15:21:53 <quicksilver> with one pointer changed.
15:22:19 <quicksilver> (in the first instance it's just a thunk, not even a copy, but once you reduce that thunk you get a shallow copy with one pointer changed)
15:23:00 <quicksilver> of course, if you never use r again it will be GCed, and if r gets GCed before it falls out of cache, its allocation was essentially free and it might as well never have existed.
15:23:03 <quicksilver> roughly.
15:24:51 <Saizan> lambdazerocool: if you evaluate "let xs = map ($) [id,not] in length xs" you get a heap that looks like "f = ($) id; g = ($) not; xs = [f,g]" and a result of 2
15:25:04 <clahey> Now that I think of it, couldn't it matter how ($) is implemented in Prelude?
15:25:28 <clahey> Is there some reason you couldn't write ($) :: (a -> b) -> a -> b; ($) = id
15:25:31 <clahey> @src ($)
15:25:32 <lambdabot> f $ x = f x
15:25:46 <quicksilver> clahey: that doesn't matter as long as id gets inlined too (which it does)
15:26:18 <quicksilver> f $ x = ((id f) x) = f x --- this reduction purely in the inliner
15:26:20 <clahey> quicksilver: Well, it depends on whether forcing map (map ($)) fs leaves a bunch of closures around, no?
15:26:32 <Saizan> not really
15:27:06 <clahey> What happens when you reduce (f $)?
15:27:41 <Saizan> well, it depends on what we mean by forcing
15:28:09 <Saizan> with length you get the closures around, with nf you probably don't
15:29:28 <Saizan> but you could still get the closures if the ($) passed to map gets compiled as a 2-argument function
15:29:57 <Saizan> so yeah, there maybe implementing as ($) = id could help
15:30:59 <clahey> Does it change the denotational semantics at all?
15:36:08 <Saizan> i think so
15:36:08 <Saizan> > (undefined$) `seq` ()
15:36:08 <lambdabot>   ()
15:36:08 <Saizan> > (id undefined) `seq` ()
15:36:08 <lambdabot>   *Exception: Prelude.undefined
15:36:08 <bitonic> I’ve asked this question before, but: are there emacs mode to handle alex/happy files?
15:36:08 <Saizan> (ghci doesn't do any optimization though)
15:36:08 <clahey> Saizan: So I suppose you can't arbitrarily change $ to id, but the language committee could?
15:39:05 <Saizan> clahey: can only be observed with seq though, so it's a bit dodgy
15:39:14 <lambdazerocool> > :t ($)
15:39:17 <lambdabot>   <hint>:1:1: parse error on input `:'
15:40:09 <tgeeky> lambdazerocool: use > ... to run code, and :t to typecheck code
15:40:14 <tgeeky> :t ($)
15:40:15 <lambdabot> (a -> b) -> a -> b
15:40:17 <Saizan> clahey: libraries@ actually, i wonder if there are cases where it's a pessimization though
15:40:28 <lambdazerocool> tgeeky++
15:40:33 <lambdazerocool> thanks!
15:41:16 <Saizan> clahey: or if the difference would still matter after inlining
15:41:53 <Saizan> i suppose GHC won't expand (\x -> x) to (\x y -> x y) though
15:42:31 <lambdazerocool> I believe ($) is actually defined as an infix operator. See above it goes (a -> b) -> a -> b, whereas id is of type (a -> a). Since ($) takes the left and applies to the right, it is not quite the same as the id function.
15:43:06 <Saizan> lambdazerocool: you can define it as ($) = id just fine
15:43:23 <Saizan> lambdazerocool: it just has a more restrictive type signature
15:43:41 <Saizan> :t id :: (a -> b) -> a -> b
15:43:42 <lambdabot> (a -> b) -> a -> b
15:43:47 <tgeeky> lambdazerocool: also, for what it's worth, belief typically doesn't factor into things when you have source code. Though there are a few instances where lambdabot's definition of things are different than standard haskell / GHC
15:44:28 <monoidal> f $ x = f x
15:44:33 <Saizan> here the belief was correct anyhow :)
15:44:54 <tgeeky> @. pl djinn (a -> b) -> a -> b
15:44:54 <lambdabot> f = id
15:45:01 <tgeeky> that settles it!
15:45:10 <Nisstyre-laptop> woah, you  can compose lambdabot commands?
15:45:23 <tgeeky> Nisstyre-laptop: yes you can
15:45:27 <Nisstyre-laptop> awesome
15:48:52 <clahey> lambdabot: It is defined as an infix operator, but that just affects the syntax, not the meaning.  You can define an infix operator using a normal function just fine.
15:49:22 <clahey> s/lambdabot/lambdazerocool/
15:50:09 <clahey> lambdazerocool: Perhaps more to the point it doesn't apply the left to the right.  It takes the left and returns a function which when given the right results in the left applied to the right.  Which is what id does as well.
15:50:52 <clahey> That is very cool that you can compose them.
15:51:01 <tgeeky> Nisstyre-laptop: it is pretty awesome, actually. I wish they would have allowed @. @pl @djinn kind of syntax, but you can't have everything
15:51:02 <clahey> (lambdabot commands that is.)
15:51:03 <Nisstyre-laptop> tgeeky: but then you could do "@. @pl @. @pl @djinn" or whatever right?
15:51:03 * Nisstyre-laptop couldn't think of another command to use there
16:09:47 <napping> GHC doesn
16:09:55 <napping> doesn't have pattern synonyms, does it?
16:10:37 <hpc__> napping: not under that name
16:13:25 <dncr> Does this exist in some form already: pairwise f (a1, b1) (a2, b2) = (f a1 a2, f b1 b2)
16:14:46 <monoidal> dncr: pairwise f = f *** f
16:14:53 <dncr> oh duh
16:14:56 <monoidal> um almost
16:16:07 <monoidal> @pl  \f (a1, b1) (a2, b2) -> (f a1 a2, f b1 b2)
16:16:08 <lambdabot> (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
16:16:57 <monoidal> @pl f (a,b) -> (f a, f b)
16:16:57 <lambdabot> (line 1, column 11):
16:16:57 <lambdabot> unexpected '>'
16:16:57 <lambdabot> expecting operator
16:17:01 <monoidal> @pl \f (a,b) -> (f a, f b)
16:17:02 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
16:18:09 <dncr> Yeah it's different, (f *** f) (a, b) = (f a, f b).
16:18:43 <dncr> :t on
16:18:45 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
16:22:06 <monoidal> :t \f a b -> uncurry (***) ((f *** f) a) b --dncr
16:22:08 <lambdabot> (b'1 -> b' -> c') -> (b'1, b'1) -> (b', b') -> (c', c')
16:23:46 <mjrosenb> @pl (\x -> f x . g x)
16:23:46 <lambdabot> liftM2 (.) f g
16:24:12 <monoidal> dncr: if you define appl (f,g) (x,y) = (f x, g y) i.e. appl = uncurry (***) then the function is \f a b -> (f,f) `appl` a `appl` b
16:24:19 <mjrosenb> @pl (\x -> (fmap f x) . g x)
16:24:19 <lambdabot> ap ((.) . fmap f) g
16:27:17 <dncr> monoidal: ah very cool
16:27:45 <monoidal> dncr: if you can use or convert to lists, it's zipWith
16:27:51 <dncr> monoidal: right
16:28:24 <mjrosenb> @pl (\x -> (fmap (f x)) . g x)
16:28:25 <lambdabot> ap ((.) . fmap . f) g
16:33:43 <theli0nheart> s
16:37:26 <mjrosenb> @pl (\x -> (fmap (f x)) $ g x)
16:37:26 <lambdabot> liftM2 fmap f g
16:37:40 <mjrosenb> ok, that makes *so* much more sense
17:05:54 <otters> there really needs to be some version of "case foo" that expands to "foo >>= \f -> case f"
17:06:47 <tac> otters: isn't that just lambdacase?
17:08:07 <otters> yeah, I guess so
17:12:50 * mjrosenb occasionally mises having lambdacase
17:24:28 <hpaste> schellsan pasted “unexpected semi colons” at http://hpaste.org/81620
17:24:45 <schellsan> is my indentation off here?
17:25:03 <schellsan> or am i abusing 'do notation?
17:25:10 <schellsan> (or both)
17:25:34 <ion> Try pasting the exact source code and the exact error.
17:25:58 <glguy> You can't have else on the same column as the if
17:26:29 <geekosaur> layout is fussy that way inside do
17:26:32 <ion> glguy: Didn’t Haskell 2010 do an evil change that allows that? Or was that a language extension or something?
17:26:59 <schellsan> glguy: thanks that was it
17:27:06 <schellsan> ion: thanks too!
17:27:18 <glguy> ion: You can do it in newer versions of GHC, it's the DoAndIfthenElse extension
17:27:24 <glguy> I think it might be on by default in the 7.6 series
17:28:03 <schellsan> what is the general style guide for 'if?
17:28:10 <ion> Next up: DoAndIfThenElseEvenMore where you can indent the “else” to the *left* from the “if” and the “do”.
17:28:23 <monoidal> Haskell 2010, includeing DoIfThenElse is default since GHC 7
17:28:45 <glguy> schellsan: What GHC are you using?
17:29:06 <ion> schellsan: Just like any other expression: when split into multiple lines, indent the ones beginning from the second line more than the first one. If splitting if-then-else, perhaps do it like this:
17:29:09 <ion> if …
17:29:09 <schellsan> glguy: right now 7.4.2
17:29:11 <ion>   then …
17:29:13 <ion>   else …
17:29:51 <ion> schellsan: Btw, “if null …” and “if isNothing …” are both better done with pattern matching.
17:30:21 <ion> case trackTbls of [] -> …; _ -> …
17:30:41 <ion> case compTime of Just t -> …; Nothing -> …
17:30:52 <johnw> the latter is better done with 'maybe'
17:31:13 <glguy> Not that it's a good idea to do this kind of partial matching in general, but:  let trackTbl:[] = trackTbls
17:31:25 <glguy> -->   let [trackTbl] = trackTbls
17:35:56 <schellsan> glguy: ahh - thanks
17:36:34 <schellsan> i didn't think about...well...what's the difference between [a] and a:[]?
17:36:56 <schellsan> besides the notation?
17:36:56 <glguy> 1 character ;)
17:37:01 <schellsan> :)
17:39:09 <ion> [a] is syntactic sugar for a:[]
17:41:29 <schellsan> which one is better?
17:41:59 <geekosaur> neither.  [a] is often easier to read
17:42:16 <schellsan> or were you saying there's a better way to do that kind of partial matching in general
17:42:27 <schellsan> (and what is 'partial mapping'?)
17:42:32 <schellsan> sorry
17:42:34 <schellsan> matching
17:42:43 <schellsan> someone here is talking about mapping :)
17:51:06 <monochrom> I can't find DoIfThenElse in Haskell 2010. I used to think it's there
17:54:09 <monochrom> interesting, it may be there in a subtle way. lexp -> do { stmts }. stmt -> exp ;. now look under exp
17:54:42 <monochrom> exp -> ... -> lexp -> if exp [;] then [;] else exp
17:54:52 <monochrom> see the [;]s. they were not in Haskell 98
17:54:58 <ion> schellsan: You usually use (:) when you want to insert an element in front of a list or deconstruct a list into the head and the tail. You usually use the sugar for the other cases.
17:56:08 <ion> schellsan: You’re matching partially if you don’t handle all the values the thing to be matched can take.
17:56:38 <monochrom> > do { x<-[1]; if True; then [x,x]; else [] }
17:56:39 <lambdabot>   [1,1]
17:56:45 <ion> > case Just 42 of Just x -> "This is partial and therefore bad (" ++ show x ++ ")"
17:56:50 <lambdabot>   mueval-core: Time limit exceeded
17:56:54 <monochrom> this is an evil way to support DoIfThenElse! :)
17:56:57 <ion> > case Just 42 of Just x -> "This is partial and therefore bad (" ++ show x ++ ")"
17:57:01 <lambdabot>   mueval-core: Time limit exceeded
17:57:06 <ion> …
17:57:08 <applicative_> man is that disgusting
17:57:12 <ion> > case Just 42 of Just x -> "This is partial and therefore bad (" ++ show x ++ ")"
17:57:14 <lambdabot>   "This is partial and therefore bad (42)"
17:57:17 <monochrom> no wonder I couldn't find it. I was only looking under do
17:57:19 <ion> > case Nothing of Just x -> "This is partial and therefore bad (" ++ show x ++ ")"
17:57:21 <lambdabot>   "*Exception: <interactive>:(3,1)-(4,22): Non-exhaustive patterns in case
17:57:29 <applicative_> the familar ` else statement `
17:57:54 <ion> monochrom: …Wow. That’s horrible. :-D
17:58:41 <monochrom> hey, this may have consequences
17:58:53 <monochrom> > if True; then 'x'; else 'y'
17:58:54 <lambdabot>   'x'
17:59:00 <monochrom> heheh!
17:59:22 <Hafydd> Oh no, that reminds me of bash
17:59:24 <monochrom> > if True then 'x'; else 'y'
17:59:26 <lambdabot>   'x'
17:59:32 <monochrom> > if True; then 'x' else 'y'
17:59:34 <lambdabot>   'x'
18:00:25 <monochrom> this is evilly clever
18:00:33 <applicative_> I guess goes with the desugaring of if p then a else b, into case p of True -> a; False -> b
18:00:34 <ion> FSVO clever
18:00:52 <schellsan> ion: i see, non-exaustive...
18:01:01 <ion> For some reason i read “evilly” as “pretty”
18:01:11 <applicative_> > case True of True -> 'x'; False -> 'y'
18:01:12 <lambdabot>   'x'
18:01:16 <monochrom> this is pretty evilly clever! :)
18:01:47 <monochrom> no, applicative_, consider if True; then 'x' else 'y', case True; of ...
18:02:05 <monochrom> they are not analogous
18:02:58 <applicative_> hm, I missing something. Not the first time...
18:05:01 <monochrom> so, you write like "do if True" on one line, "then x else y" next line, "then" lines up with "if", and then "return ()" last line, "return" lines up with "then". layout calls it "do { if True ; then x else y ; return z }"
18:05:45 <monochrom> note that we are still at the tokenizing level, not at the CFG level yet. nothing at this stage says ";" separates statements
18:06:35 <monochrom> but when you go to the CFG level, "lexp -> if exp [;] then exp [;] else exp" says, slurp up the whole "if True; then x else y" as one statement, not two statements
18:07:06 <monochrom> that is how clever it is. it doesn't even need much modification to the rule about do
18:07:55 <monochrom> hell, 0 change to the do rule, compare 98 and 2010
18:08:28 <monochrom> this has further consequences!
18:09:11 <monochrom> > do { x <- if True; then [1]; else []; return (x+1) }
18:09:13 <lambdabot>   [2]
18:09:30 <monochrom> wanna bet how it looks like with layout? :)
18:11:23 <applicative_> it looks horrible with layout.
18:11:34 <monochrom> hehehe
18:12:08 <noah__>  
18:12:11 <parcs> why?
18:12:12 <noah__> ignore that
18:12:48 <applicative_> I remember someone sensible complaining about the new rule, but I just ignored it; now I want to oppose it vigorously
18:13:10 * ski . o O ( `do if True; then x <- foo; else x <- bar; baz x' )
18:14:22 <hpaste> monochrom pasted “fun with do-if-then-else” at http://hpaste.org/81623
18:14:34 <yitz> it's hard not be smug. every major security vulnerability that gets a lot press, like the rails one this week, seems to stem directly from the lack of a real type system.
18:14:34 <applicative_> maybe I should just use {-#LANGUAGE Haskell98#-} then I can indulge my love of fib (n+1) = ...
18:14:42 <monochrom> parcs: tell me what you think of that paste :)
18:14:59 <Nisstyre> yitz: Ruby has a real type system -- everything is just the same type though
18:15:08 <Nisstyre> >.>
18:15:15 <monochrom> that is not a real type system
18:15:19 <yitz> Nisstyre: exactly
18:15:47 <Nisstyre> also I hate Ruby because it makes the same mistake most dynlangs do, which is having assignment be the same operator as declaration
18:15:49 * applicative_ isn't sure that the notion of a 'system' can get going with just one thing.
18:16:00 <monochrom> at least, my definition. real type system to me means fine-grained type differences. definitely not "only one type"
18:16:25 <Nisstyre> "Hey guys let's make mistakes that Scheme solved 30 years ago"
18:16:51 <applicative_> with haskell there are no major security vulnerabilities because the Russian egg-heads can't grok monads
18:17:03 <yitz> applicative_: you're right. but if i had tried to be more precise, my comment would not have fit reasonably into a single irc message.
18:17:08 <Nisstyre> applicative_: I think there are some Russian Haskellers
18:17:12 <Nisstyre> that opera singer dude comes to mind
18:17:25 <applicative_> Nisstyre: I take it all back then
18:17:48 <applicative_> Nisstyre: Russian opera singer Haskellers??
18:17:55 <Nisstyre> applicative_: yes, let me show you
18:18:00 <applicative_> !
18:18:02 <monochrom> that's fantastic :)
18:18:12 <schellsan> applicative_: what about chinese egg heads, can they grok monads?
18:18:21 <applicative_> schellsan: oh yes
18:18:23 <Nisstyre> http://stackoverflow.com/users/570689/
18:18:36 <schellsan> hold on to you socks
18:18:41 <monochrom> um, I'm a chinese egg head, and I grok monads, and I now grok how do-if-then-else is done, too!
18:18:55 <schellsan> :)
18:19:29 <monochrom> I also grok template haskell a few days ago
18:19:54 <Nisstyre> monochrom: do you grok Scheme macros?
18:19:58 <schellsan> i don't grok much of haskell yet :(
18:20:06 <yitz> monochrom: oh noes is this another caleskellism?
18:20:17 <schellsan> but it has been really rewarding none-the-less
18:20:55 <monochrom> I also grok parsec and ContT so much, I present to you: http://www.vex.net/~trebla/haskell/parsec-generally.xhtml#yield-intro
18:21:11 <monochrom> yitz, what is "this"? you mean do-if-then-else? it's in Haskell 2010
18:21:26 <yitz> monochrom: is it? without a pragma?
18:21:34 <monochrom> without pragma
18:21:46 <applicative_> monochrom can express all monads with ParsecT
18:21:47 <yitz> well what do you know
18:22:08 <monochrom> I can walk you through how Haskell 2010 does it again, if you want :)
18:22:12 <ski> #haskell.ru -- iirc
18:22:46 <ski> (i've certainly seen Haskell code with cyrillic names on <hpaste.org>)
18:23:18 <applicative_> the opera singer dude is pretty amazing.
18:23:46 <yitz> monochrom: i was wondering why it isn't listed in the ghc docs among ghc language extensions. that explains it.
18:23:48 <applicative_> hats off to Russia
18:30:10 * applicative_ figures if there can be haskellizing Academy Award winners, by not singers...
18:31:51 * BMeph_ wonders if applicative_ meant, "...besides sigfpe." ;þ
18:33:20 * applicative_ was thinking only of sigfpe, but of course dmitri's russian 'golden grammophones' come from singing.
18:33:39 <elliott> Nisstyre: applicative_: pretty sure that profile is a joke, by the way
18:33:54 <Nisstyre> elliott: is it? I thought it was legit
18:33:55 <elliott> although I forget what made me think that, I was puzzled by it a while ago
18:34:06 <elliott> I think the profile looked different at some point or something
18:34:07 * applicative_ would have said the same about sigfpe's blog....
18:34:22 <elliott> it's a very good story if true though :)
18:35:15 <applicative_> elliott: you're probably right. Either that, or he wrote his wikipedia entry, which has the same text.
18:35:40 <applicative_> on the other hand, maybe they go together.
18:36:31 <applicative_> Really, his first name is Simon.
18:38:07 <joellxx> Hi. I'm working with the portaudio haskell bindings which in turn use FFI to call the portaudio library. I'm getting an error I don't understand: on some runs I get "read: SoundziPortAudioziBase_d1YX: interrupted" where "read" is the name of my executable. What does interrupted mean in the context of FFI?
18:39:33 <geekosaur> the C library is badly written?
18:40:05 <geekosaur> (likely a timer interrupt is going off, and the library isn't smart enough to follow the posix standard and restart the read on EINTR)
18:40:26 <joellxx> I've written a small c program to test it the behaviour I'm tryiing to get and it seems to work fine...
18:40:55 <joellxx> The main jist of the program is that the c library is calling a haskell callback everytime it has audio data for it
18:41:26 <geekosaur> you aren't emulating the haskell runtime firing a periodic timer interrupt, I'd guess.  (although, hm.  maybe the runtime isn't properly stopping the timer when returning from a haskell callback?)
18:42:00 <geekosaur> if it uses a haskell callback, it can't be using the unsafe path that doesn't suspend the runtime
18:43:09 <joellxx> It's a safe foreign function... I was worried that was the problem and changed every function to safe, but that didn't solve anything
18:43:35 <joellxx> I'm not familiar with the periodic timer you mean
18:44:19 <latermus1> which haskell webserver is best for just displaying static images?
18:44:38 <applicative_> hm, the first example file just segfaults immediately for me
18:44:54 <yitz> Nisstyre: opera? wikipedia says "europop".
18:46:35 <Nisstyre> yitz: oh, I didn't know that
18:46:59 <geekosaur> joellxx, the haskell runtime (not your haskell code but the code that runs underneath it that is not under your control) uses a periodic timer interrupt.  is there something else you need to know about it?
18:47:35 <joellxx> geekosaur: ok, but as long as my FFI declarations are safe it shouldn't be an issue, correct?
18:48:02 <geekosaur> in theory.  I would expect the tmer to be shut down in C code but this sounds like it is not, or there is some other interrupt involved somewhere
18:48:04 <Axman6> geekosaur: you sure about that? I though it only did a context switch when a thread allocates
18:49:07 <Michael_> Whats the best way, now that I have a almost competent understanding of haskell, to start contributing to open source?
18:49:11 <geekosaur> it's not a context switch, I don't recall what it does but I mostly know about it due to it being broken 7.4.[12] in ways that make xmonad and xmobar go kinda nuts as shown in powertop
18:49:35 <Axman6> Michael_: find something you want to use that's broken, and fix it =)
18:49:36 <geekosaur> nonthreaded runtime; compiling -threaded is a workaround (which, hm, you might consider, joellxx)
18:50:20 <Michael_> Axman6: Is there a github equivalent for darcs, or is it more per project basis? Are they actually developed on hackage, or just hosted their?
18:50:33 <geekosaur> darcsden, patch-tag
18:50:44 <Axman6> there are some, but people tend to just use github these days
18:51:09 <geekosaur> joellxx, in fact, if you are running a 7.4 version of ghc it is possible you might be seeing the same bug
18:51:22 <joellxx> geekosaur: I am running 7.4.1, but I'm compiling with -threaded
18:51:34 <geekosaur> hm, so it shouldn't be using the timer at all I think
18:51:51 <geekosaur> wonder if something else is sending signals and the library is mishandling them for some reason
18:52:24 <geekosaur> (the "interrupted" means that something returned the C error code EINTR unexpectedly, which means a system call was interrupted by delivery of a signal)
18:53:19 <joellxx> well, maybe it's a sleep thing. My code's at http://hpaste.org/81624 . One thing that bothers me is that I say I want to sleep for 3 seconds, but the code never sleeps that long. Could this be related?
18:54:10 <geekosaur> that would be a different issue
18:54:28 <napping> does the library use or dislike receiving interrupts?
18:54:37 <geekosaur> 30000 is 30000 microseconds, or 30 milliseconds
18:54:48 <yitz> monochrom: oh horrors. you'd think they could have said a little more in the 2010 report about the do-if-then-else change than just "[;]"
18:55:00 <monochrom> hahaha
18:55:14 <joellxx> napping: I'm not sure. portaudio calls callbacks, but doesn't deal with interrupts (to my knowledge)
18:55:49 <monochrom> to be fair, what you want them to say would belong to a change log, not the main text
18:55:59 <joellxx> geekosaur: oh jeez, thanks for catching that
18:56:15 <geekosaur> you'd be amazed how many people make that mistake
18:56:31 <geekosaur> (quite regularly jhudging by how often it's mentioned in here)
18:56:36 <yitz> monochrom: i claim something should be said in the main text. a trick like that needs to be explained.
18:56:43 <Nereid> it would help to read the docs yes
18:56:56 <monochrom> I see. yeah
18:57:49 <joellxx> geekosaur: another thing that I've noticed is that this interrupt only happens after I print "done" (after the thread is woken up and we're about to finish the program). What happens when haskell wants to leave but an FFI is still running? I guess I'm fundamentally unclear on how the threading on FFI works for callbacks
18:59:15 <geekosaur> oh, are you trying to shut the program down from inside the callback?  I don't know for certain but my guess is that won't work because there's no way for the haskell runtime to notify the C code to shut doen; you'd need to find some way to return a "please shut down now" from the callback to C
19:00:28 <applicative_> Michael_: there are a huge number of projects on github many explicitly asking for contributions https://github.com/languages/Haskell but I suppose you've seen it.
19:01:37 <applicative_> yet another purely functional package manager ...
19:01:39 <joellxx> geekosaur: there is a official way: the callback has to return Complete instead of Continue... although I'm not sure how the timing would work. Presumably portaudio is always listening to the sound cards and wants to call my callbacks, but no matter when haskell exits I want to call terminate right before... do you understand what I mean?
19:02:31 <napping> applicative_: which package manager is that?
19:02:40 <geekosaur> I do, but that's not how it works.  callbacks run in what amounts to a separate copy of the haskell interpreter; what happens when that shuts down is your callback returns control to the C program
19:03:09 <applicative_> napping: for arch : https://github.com/fosskers/aura
19:03:18 <geekosaur> (this is not exactly correct but close enough)
19:04:05 <geekosaur> I should not clal it interpreter, its not actually an interpreter either.  but it's again close enough for hand grenades.  (technically it's a graph reducing engine)
19:04:39 <EvanR2> turing machines all the way down ;)
19:04:44 <yitz> Michael_: you dropped out of the channel just when applicative_ said something to you.
19:04:53 <geekosaur> (if you've heard people mention the STG machine in here, that's what is running)
19:05:15 <joellxx> so when I call startStream we have two threads: one of which is the c library that is presumably waiting on data and calling callbacks and the other is the initial haskell main thread which proceeds to call threadDelay. Is that correct?
19:05:24 <applicative_> ha, I guess I tab completed before he left, and hit return after
19:05:32 <Michael_> I'm really sorry yitz, is it possible to copy/paste what he said?
19:05:38 <applicative_> Michael_: there are a huge number of projects on github many explicitly asking for contributions https://github.com/languages/Haskell but I suppose you've seen it.
19:06:26 <applicative_> nothing exciting. I was trying to get to you express more about what interested you, thinking it might give someone a brilliant idea
19:06:37 <geekosaur> yes and no.  FFI code does get migrated to a separate thread but if you have callbacks then I'm not sure it can keep running the main thread while the FFI call is executing.  we're into stuff I don't understand very well now :(
19:06:56 <napping> do you need some kind of atexit in Haskell?
19:07:20 <geekosaur> napping, would not help here I'm afraid, even if it would
19:07:22 <YayMe> Anybody got time to do a code review of quick bit of code?
19:07:30 <joellxx> napping: I don't think so... I do need a way to cleanly shut down the portaudio library code before exiting haskell though (i think)
19:08:00 <geekosaur> the key point is that a callback runs in a different Haskell context which cannot forward a shutdown request "past" the FFI code that called it to the main Haskell context
19:08:16 <YayMe> It functions correctly (with tests to prove it) so just questions about style or better structure for the same functionality
19:08:41 <joellxx> geekosaur: are there any resources that I could read to understand this in more depth?
19:08:42 <geekosaur> best it could do is write to an IPC channel of some kind and then return to the FFI code that invoked it a "shut down now and give control back to the main Haskell context" value
19:08:54 <EvanR2> portaudio is going to be gone bye bye when the whole program shuts down, dont worry about that
19:09:46 <geekosaur> EvanR2, can the separate I/O-manager-plus-etc. fired up for the callback make the program shut down without throwing an uncaught exception or sending a fatal POSIX signal?
19:10:12 <napping> why do you think there's a whole separate I/O manager, capability, etc. spun up?
19:10:13 <geekosaur> I am under the mpression the FFI machinery does not allow the program to be completely shut down from a Haskell calback invoked by an FFI call
19:10:41 <geekosaur> because I've read the basic information on how FFI to Haskell callbacks work?
19:10:48 <napping> I think it just blocks the C thread calling in, and adds a new task into the usual scheduler
19:10:51 <EvanR2> i wasnt paying attention to the setup, if its a haskell program that calls C code, everything is gone when the main thread ends
19:10:51 <YayMe> http://codereview.stackexchange.com/questions/21126/ mostly just 3 functions (~20 lines) around the middle I feel should be doable less convoluted
19:11:02 <YayMe> any tips on those 3 functions?
19:11:15 <geekosaur> EvanR2, this is a Haskell program that calls C code that calls a Haskell callback
19:11:16 <joellxx> for what it's worth, sometimes I get a different error: "read: newBoundTask: RTS is not initialised; call hs_init() first". This happens much more infrequently but I also don't understand it
19:11:29 <geekosaur> and he's trying to exit the program from the callback, apparently
19:11:31 <EvanR2> the callback is going to be another thread
19:11:35 <napping> unless you are explicitly trying to start multiple haskell runtimes you won't start multiple runtimes
19:12:02 <EvanR2> if you put into an mvar the main thread is waiting on, everything will go bye bye
19:12:12 <EvanR2> i have no idea how it works though
19:12:18 <geekosaur> napping, see the other error just mentioned.  which is the "runtime" I am talking about; I am oversimplfying things a biut
19:12:40 <joellxx> geekosaur: i don't think I'm trying to exit from a callback, but i do want to exit the main thread while a callback might still be running
19:12:42 <napping> you are oversimplifying too much if you think callbacks from C are in any way isolated from the rest of the threads
19:12:53 <EvanR2> joellxx: it will exit
19:13:13 <geekosaur> ok, not exiting *from* the callback, that should work
19:13:23 <monochrom> why don't you cook up a simple scientific experiment to test your claims?
19:13:28 <geekosaur> but if you're getting the hs_init error sometimes then something else is severely wrong...
19:14:11 <geekosaur> normally you should only be getting that with your own C code that wants to call into Haskell as opposed to a Haskell callback via the FFI
19:14:27 <joellxx> EvanR2: i usually do exit cleanly, but maybe 10% of the time I get this interrupted error
19:14:35 <YayMe> Is there a way in haskell to at runtime turn data Thing = A | B into data Thing = A | B | C ? horrible idea I imagine, it just occurred to me that you can't do it, so I figured I'd verify I am correct about that
19:14:45 <yitz> YayMe: looks fine to me. (couldn't find validateUser though)
19:14:47 <joellxx> (that always happens at the end, after "done" but before terminating)
19:15:15 <geekosaur> YayMe, no, you can't add a new constructor at runtime, at least not like that
19:15:20 <EvanR2> joellxx: are there any adverse effects besides 'getting an error' after the program ends
19:15:31 <joellxx> EvanR2: No
19:15:35 <EvanR2> then screw it lol
19:16:25 <joellxx> EvanR2: haha. part of what bothers me is that I was getting segfaults... I've since compiled the library myself and now I'm getting these more specific errors
19:16:27 <yitz> EvanR2: there's always the "2> /dev/null" idiom
19:16:35 <YayMe> yitz: oh validate is the validateUser. Really you think that's all cleanly done? That's the first time I've presented any piece of code at all here that wasn't given lots of criticism
19:17:30 <otters> is there a good way to perform a computation that involves a lot of IO (Maybe a) and fail on the first Nothing
19:17:36 <otters> like MaybeT, but with IO involved
19:18:03 <EvanR2> MaybeT
19:18:12 <monochrom> is that not MaybeT IO?
19:18:35 <YayMe> otters: never made a monad transformer?
19:19:24 <elliott> otters: MaybeT IO?
19:19:25 <yitz> YayMe: oh didn't look at validate. the other ones are quite clear, i like them.
19:19:44 <otters> yeah, maybe I'm just confused
19:20:20 <yitz> YayMe: hmm, you don't need to do those folds manually in validate.
19:20:57 <otters> I thought that "inside" the MaybeT monad, in "a <- b" a would be type t instead of Maybe t
19:21:08 <otters> am I explaining myself properly or not
19:22:08 <EvanR2> otters: isnt that what you want
19:22:08 <yitz> YayMe: you don't even need the value at the end. so how about just: mapM_ (validateItem c1 c2 s1) i1
19:22:17 <YayMe> yitz: how should I validateItem against all the user's items and validateStore against all the user's stores?
19:22:22 <otters> EvanR2: I don't think that's what's happening
19:22:42 <yitz> YayMe: similarly for validateStores
19:22:43 <YayMe> yitz: oh yeah I foldl'd the >> because if it fails on the first item or store, it won't continue, map wouldn't do that
19:22:46 <johnw> otters: in MaybeT, a <- b yields a t, not a Maybe t; can you show us your code?
19:22:46 <EvanR2> in what
19:22:55 <otters> yeah, hang on
19:23:13 <yitz> YayMe: map doesn't, but mapM and mapM_ do.
19:23:29 <YayMe> yitz: oh, really? interesting!
19:23:30 <yitz> @src mapM_
19:23:30 <lambdabot> mapM_ f as = sequence_ (map f as)
19:23:36 <YayMe> ahh
19:23:42 <yitz> @src sequence_
19:23:42 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
19:24:10 <YayMe> I was in here the other day asking if there was an allegory for foldl (>>) and nobody mentioned mapM_
19:24:23 <YayMe> I know sequence but if I did it with sequence it would be just as unclear as my fold
19:24:39 <EvanR2> :t forM_
19:24:40 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
19:24:53 <EvanR2> classic
19:25:00 <YayMe> eh, the _ means drop the result right?
19:25:04 <EvanR2> yeah
19:25:17 <yitz> YayMe: well i think sequence_ [validateItem c1 c2 s1 y | y <- i1] is still more clear than the explicit fold.
19:25:36 <yitz> YayMe: right
19:25:37 <YayMe> you're right
19:25:38 <hpaste> otters pasted “MaybeT” at http://hpaste.org/81625
19:25:48 <YayMe> but I didn't think up that sequence hehe
19:26:25 <YayMe> it was like fmap . sequence or something but yeah mapM_ awesome that's the kind of tip I was looking for!
19:26:38 <yitz> YayMe: anyway, nice job, looks good
19:27:10 <YayMe> sweet!
19:27:11 <johnw> otters: you aren't using MaybeT, you're using liftIO to call an IO (Maybe Int), which is returning a Maybe Int
19:27:28 <johnw> could you just get rid of the runMaybeT and liftIO calls
19:27:47 <johnw> try defining foo as: foo :: MaybeT IO Int
19:27:51 <johnw> and then just "return 3"
19:28:06 <johnw> and drop the "liftIO" in the call to foo
19:28:11 <otters> well, foo is a substitute for actual functions I'm using which return IO (Maybe a)
19:28:26 <otters> although I may be able to change that, hang on
19:28:36 <johnw> then MaybeT isn't what you think it is :)
19:28:44 <otters> yeah evidently not
19:28:52 <otters> I just want the whole computation to fail when Nothing is encountered
19:29:06 <johnw> then you want MaybeT :)
19:29:08 <johnw> haha
19:29:20 <otters> so basically I have to do it myself
19:29:29 <johnw> well
19:29:42 <johnw> in test, after the "n <-"
19:29:45 <johnw> just put "n" on a line by itself
19:30:02 <johnw> that will cause MaybeT to short-circuit if "n" is a Nothing
19:31:01 <otters> yeah, but n is still Maybe a
19:31:06 <johnw> that's ok
19:31:17 <tieTYT> i've never used hoogle before.  Why does this describe Data.Map.Lazy? http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Map.html
19:31:40 <EvanR2> no you want to operate on just 'a'
19:31:49 <EvanR2> Nothing is useless to you at this point
19:31:57 <EvanR2> all youd do with it is 'return'
19:32:15 <YayMe> yitz: on the second point, design wise is that a common approach to create a bunch of get/set functions alongside your data model like that?
19:33:58 <yitz> YayMe: yes. unfortunately. lenses are a whole different approach to avoid the need for that, but that's almost like a new programming language (in my opinion)
19:33:58 <geekosaur> tieTYT, at the very top:  "This module re-exports the value lazy Data.Map.Lazy API, plus several deprecated value strict functions."
19:34:09 <yitz> a nice one though
19:34:20 <YayMe> yitz: yeah, I haven't picked up lenses just yet but I will
19:34:41 <johnw> otters: what I said is wrong
19:35:02 <geekosaur> and the why is that Data.Map was reorganized into strict and lazy variants, where there used to be only a lazy variant except for some functions that provided strict versions of some (not enough) operations
19:35:06 <YayMe> along with everything else if I stick with this for as many years as my stupid addiction to it seems to
19:35:13 <yitz> YayMe: me too. i'm a little hesitant to introduce something with so much machinery. anyone who ever maintains that code in the future will have to know all that.
19:35:24 <tieTYT> geekosaur: i see.  That's kind of cool that you can reimport modules
19:35:32 <hpaste> johnw pasted “otters.hs” at http://hpaste.org/81626
19:35:38 <tieTYT> so to me as the client, it looks like I just imported Data.Map
19:35:44 <johnw> that version is what I think you were asking for
19:35:59 <geekosaur> yeh, you can say module Foo (module Bar) where import Bar; ...
19:36:29 <tieTYT> is that "where" and "import" on the same line?
19:36:59 <yitz> YayMe: oh, for the getters you can use record syntax instead, that would be the usual approach.
19:37:39 <YayMe> yitz: people use record syntax commonly? I've avoided it to not pollute those who import
19:38:02 <EvanR2> import qualified
19:38:09 <EvanR2> records are great
19:38:47 <EvanR2> i wish other languages had foo { bar = baz }
19:39:05 <elliott> well, lenses are just a get+set function
19:39:09 <elliott> that's the entire idea
19:39:19 <YayMe> Didn't know people used it commonly, interesting
19:39:35 <EvanR2> pretty much every lib has records
19:39:51 <YayMe> yitz: Thanks for giving it the once over!
19:40:24 <tieTYT> there's something more important that's confusing me right now.  "Not exporting the value constructors of a data types makes them more abstract in such a way that we hide their implementation. Also, whoever uses our module can't pattern match against the value constructors."
19:40:35 <tieTYT> it also mentions that Data.Map doesn't export its value constructors
19:41:07 <tieTYT> and I looked at the previous chapter that talks about Data.Map and I noticed it didn't give any examples of functions that take as an argument.  How do you write a function like that?
19:41:07 <yitz> YayMe: np. again, nice neat code, a pleasure to read.
19:42:02 * geekosaur fails to comprehend question, sorry
19:42:32 <tac> tieTYT: You don't need to pattern match against an argument of a function.
19:42:52 <tieTYT> tac: can you give me an example?
19:43:08 <tac> @src id
19:43:08 <lambdabot> id x = x
19:43:19 <tieTYT> can I say functionName Map k a = ...
19:43:19 <tac> tieTYT: id is an example. It takes an argument without pattern matching.
19:43:20 <geekosaur> apparently I'm starting to pay for needing the primatene last night :/
19:43:40 <EvanR2> no
19:43:41 <geekosaur> not with a Map and you forgot the parens
19:43:57 <EvanR2> functionName myMap
19:44:01 <tieTYT> but isn't it common to want a function that takes a map as input?
19:44:13 <tac> tieTYT: there's nothing stopping you from doing that
19:44:17 <EvanR2> functionName myMap = M.size myMap
19:44:19 <geekosaur> you can do that, just don't try to take it apart
19:44:29 <napping> joellxx: you might want to read http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Signals
19:44:33 <EvanR2> take maps apart with M.split ;)
19:44:50 <tieTYT> EvanR2: would functionName have a type of :: Map k v -> ... ?
19:44:51 <tac> tieTYT: It just means you ONLY get the built-in functions for Map... along with anything you can write using those functions.
19:44:58 <EvanR2> tieTYT: yes
19:45:02 <tieTYT> ah ok
19:45:34 <tieTYT> and I assume I can use toList on myMap
19:45:40 <tieTYT> and all those other functions, to break it apart
19:45:51 <EvanR2> or combine
19:45:53 <tieTYT> alright thanks.  The book didn't mention this
19:45:54 <EvanR2> M.union
19:46:06 <tieTYT> (or I glossed over it)
19:46:27 <geekosaur> it may have taken it for granted, since maps are no different from anything else in that regard
19:46:39 <geekosaur> you can always pass something without pattern matching against it
19:46:42 <EvanR2> dont try to take apart Integer ;)
19:47:32 <geekosaur> foo (I# wtf) = ...
19:48:04 <geekosaur> except you also have to handle J# which is even more wtf
19:48:12 <EvanR2> God made the integers, all the rest is the work of man
19:48:30 <shachaf> S# and J#
19:48:44 <geekosaur> oh right, I# is Int
19:49:24 <geekosaur> in any case, not recommended :) you are startng to play with guts that will shoot back
19:49:59 <tieTYT> ok, back to the book
19:50:48 * ski . o O ( shooting guts doesn't sound very pleasant )
19:51:54 <geekosaur> (the small abomination hits)
19:52:07 * EvanR2 boots up prboom
19:59:30 <sclv> darn deletionists on stackoverflow: http://stackoverflow.com/q/14628383/371753
19:59:45 <sclv> you can't even vote to migrate to programmers.stackexchange anymore
20:00:05 <cmccann> flag for moderator attention if you want.
20:00:16 <cmccann> they can migrate if it seems convincing.
20:00:26 <elliott> sclv: that's because people voted to migrate lots of crap that was to on programmers.SE and it was repeatedly requested by the programmers.SE mods
20:00:34 <elliott> *OT on
20:00:51 <sclv> sure, but its maddening in cases like this
20:00:53 <elliott> that question just looks like trolling to me frankly :P
20:00:58 <elliott> "on a website somewhere"
20:01:04 <cmccann> anyway, that question is off-topic on SO one way or another
20:01:35 <sclv> the ridiculous thing is it was already closed ones
20:01:36 <cmccann> elliott: it's also posted by someone I recall as being frequently trollish on meta.SO
20:01:41 <cmccann> but eh
20:01:46 <sclv> once, even. and then voted for reopening
20:01:51 <sclv> i thought you couldn't reclose
20:02:44 <sclv> there's so freaking much genuinely low quality crap, i have no idea how on-the-bubble stuff always manages to be closed
20:02:52 * elliott is tempted to vote to delete that question since I'm pretty sure it has inflammatory intent besides it being off-topic, but fears the wrath of sclv :)
20:02:56 <cmccann> each person can only vote once each to close/reopen
20:03:18 <cmccann> if enough different people feel like it, questions can be closed and reopened an arbitrary number of times
20:03:54 <sclv> my review tools tell me there are 46.9K close votes to review
20:04:05 <sclv> i'm always dumbfounded when haskell stuff gets shut down so fast
20:04:48 <cmccann> pretty sure it prioritizes stuff in the queue. toward recent posts, if nothing else.
20:05:28 <applicative_> sclv: I voted to reopen it, but it still needs four more votes...
20:06:06 * applicative_ wonders what 'on the bubble' stuff is
20:06:28 * johnw too
20:06:32 <startling> it's when ski does his . o O ( thing )
20:06:36 <cmccann> haha
20:07:03 <applicative_> 'on the edge'
20:08:46 <sclv> sports term, not sure the origins. typically on the verge of being knocked out of a tournament or the like
20:10:20 * applicative_ is sending a copy of the Haskell Report to the UN, so that his language can be Truly Standardized
20:10:42 <yitz> sclv: good that it was closed. now your answer is there, and it closed before anyone said "but in reality it's implementation defined by ghc"
20:11:18 <sclv> haha, sure. i'm just getting touchy about the deletionists. so weird what stays and doesn't
20:11:21 <Adeon> @pl (\x -> (f x, ()))
20:11:22 <lambdabot> flip (,) () . f
20:11:23 <yitz> hey hi mauke and hi preflex !
20:11:42 <silasm> So the ((->) r) implementation for pure is K and for <*> is S in Control.Applicative. Can anyone explain to me why this is so?
20:11:44 <applicative_> if Haskell is Standardized by diverse international bureaux with high IQs like the Unicode Committee, does that mean it can never change?
20:12:12 <c_wraith> well, you say how well haskell 2011 and 2012 faired...
20:12:14 <applicative_> silasm: well, what are the types of K and S, as youd write them in Haskell
20:12:14 <c_wraith> *saw
20:13:00 <sclv> k and s are inject and apply. so it makes perfect sense that they would form an applicative over an environment
20:13:16 <silasm> applicative_: yeah, I get that. But the moment I realized that I had a braingasm the likes of which I haven't had for a long time.
20:13:20 <sclv> its pretty deep
20:13:38 <silasm> definitely.
20:13:56 <elliott> should rename SKI calculus the reader calculus :)
20:14:07 <silasm> elliott: why?
20:14:19 <elliott> ((->) r) ~ Reader r
20:14:45 * ski prefers the name "environment"
22:13:24 --- topic: '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]'
22:13:24 --- topic: set by monochrom!monokrom@toronto-hs-216-138-220-146.s-ip.magma.ca on [Tue Jan 29 09:36:42 2013]
22:13:24 --- names: list (clog tjohnson TheInfosphere rdesfo andreypopp ctype_real plutoniix Khisanth lusory slack1256 hiratara pzuraq mzero silkwood juxovec bark_ sarfraz hr_ litherum ptrf LAMMJohnson seafood techlife gwern gosshedd flebron_ kfish shintah hychen shergill hamid gthorslund tomboy64 drgreenthumb Nanuq Fuuzetsu bradleyayers arjovr jfischoff kcj cads centrinia hamishmack torkjak TDJACR alec__ bonhiu ajhager ffog joneshf adlan otto_s_ sepp2k1 dnolen glguy_ miclorb tiglog)
22:13:24 --- names: list (_jwest CoverSlide Amadiro jrajav xymox Gilly hashtree milessabin_ nus aniero ernst_ thetallguy2 subbyyy_ VaporOne OnionKnight_ edwardk preflex mauke _jmcarthur crooney ParahSai1in mgccl dncr nyc kushal sclv conal travitch gnuvince kalizga dreixel normanrichards Rickasaur Rickasaurus jamall BigOne chemist_ takeout weie phserr joellxx toekutr yc4891 blackmir1oxx2 dgpratt NihilistDandy studybot_ Tesseraction favonia rfw Targen mimi_vx synonymous tieTYT ulfdoz)
22:13:24 --- names: list (MK_FG YayMe MnO2 startling yacks mkouhei sanemat moonlite_ joar monqy Rotaerk nlogax carlocci augur segmond listofoptions pxdr happy4crazy hiroaki matzo EarlGray^ Nisstyre Natch Liskni_si joeytwiddle tac mahogny inr ahokaomaeha TheRedMood coeus_ latermus1 nanothief ick xinming blackmirroxx verrens VZakharov Hermit dolio Cale albel727 purefn kopi formalcow Eiam BMeph_ hpc__ notdan geekosaur kalven hajimehoshi yumike otters kamatsu tgeeky ozgura ceii jimt)
22:13:24 --- names: list (bytbox Mon_Ouie jcsims Vert frsoares Paprikachu waterlaz JaRoel|4d M30W harrison_ horlicks pettter imeredith bd_ Tarential nimred fran milli anders^^ tdammers jedws dogmaT etrepum whaletechno shutdown_-h_now conehead setmeaway boegel|zzz idivyanshu1 eb4890 zoktar mgsloan lucca Maarten_ neutrino cuttooth ben_d DexterLB julmuri glguy niloc132 mceier brixen nonymousa HaltingState prophile doomlord_ canta cdidd iulian nilg ssbr` Kallikanzarid Cryovat mornfall)
22:13:25 --- names: list (osfameron PGGB u_test_ Axman6 _flow_ Dodek liyang KitB adimit akamaus canvon kennyd_ b52 _br_ dm120769 mm_freak_ jlamothe levi Guest22595 ofan \rs FireFly icambridge brett norm2782 rfw__ matthavener xaimus qwandor david vili mirsal rmunoz hayashi sShintah [[zz]] kerrick nighty^ Nereid ccxCZ eejaydubya tessier knz juhp Rarrikins_v wollw radiobutton WhereIsMySpoon cglazner parcs c_wraith JoeHazzers gbarboza robbe- Ralith cmears SHODAN julmae tsou Botje)
22:13:25 --- names: list (doomlord__ Gunni AntiSpamMeta Polarina cmccann noam__ ByronJohnson Tene mlh fgomez Ikoo joeyh fqsxr message144 tobiassjosten smarter junsuijin perlite phirox silasm bholst mkaito Myk267 Ulrar stepcut araujo ftrvxmtrx dabradley Zzompp tahu mysticc LeaChim kith yeltzooo nule liff u_quark reinoud ahihi brandonw nicoo speilberg0 lokydor amgarching alios hyko Swizec maksbotan Internet13 monochrom no-n magaio Shapeshifter shepheb wormphlegm yewton kniu wjlroe)
22:13:25 --- names: list (eL_Bart0 peterhil akahn jaspervdj ski vadas Draconx dv- nyingen aforemny cyphase tensorpudding ede reiddraper larks ClaudiusMaximus spoonbadger rainmaker xplat blooberr sanjoyd sirchurchill chirpsalot Jaak revolve melter tomprince jlewis simon latro`a Peaker frio so jweijers frerich Soft bbee ormaaj zw01 Ornedan v605 ninegrid hvr colah_ My_Hearing drbean aleator tavelram dju EvanR2 sgso aristid mrdomino pskept ft tazjin cow-orker boblehest lemao janin ent mdf)
22:13:25 --- names: list (alpounet jdavis MetaCosm Excureo Jonno_FTW Pantoufle Adios akosch marienz appelton mortberg jyyou kakos otterdam thirsteh eal_ Sebastien-L pnkbst rhodesd BlastHardcheese natte Entroacceptor Dashkal jbauman andrewsw ousado MercuryRising IanKelling chance Eridius netj tromp gdeest guymann Twey duairc tmiw lightquake Megant sgronblo confound brisbin covi anona Cthulhon bacon1989 descender `0660 SegFaultAX fxrh idnar macbr sohum thetallguy DT` niko Vorpal)
22:13:25 --- names: list (betawaffle tom2221 joachifm mmaruseacph2 codertux arcatan Nanar KitB_ acharles ehamberg obcode eataix sm flori ezyang rmunroe kshannon kini tamiko gcmalloc comak kosmikus caligula_ celery_ ziman mcsmash jaimef tridactyla fall_ tanakh__ Clint Sunhay identity Zariel `nand` vmeson edenc mjr84 vobi gemelen levitation[A] linduxed crdueck codingkevin n-dolio jabirali dcoutts wting taruti arafel krig kevinqcs yano LeninParty neptunepink n_b bgamari jackhill jrockway)
22:13:25 --- names: list (Jean ChongLi bentham wunki raid snorble_ si14 tunixman Maxdamantus Tehnix Plex- hive-mind adnap thorkilnaur ned faybot raek KaneTW Nimatek Cerise antistrom dan_johnsin mateu_ jrib DigitalKiwi ps-auxw anachron dropdrive mefisto justdit MrKipper Starfire MrMeh frontendloader chr1s leroux eviltwin_ lispy amiller gseitz Hafydd fayden Belgarion0 gbeshers qwr integral dqd Baughn rio tg mike2 earthy ortmage solarus dottedmag appamatto cmsd2 mononofu Kuba TML)
22:13:25 --- names: list (Deewiant zugz dented42 pikhq k0ral decltype DrSyzygy PHO_ eyck mixi epta vhz ckx KaiSforza Tordek cross shachaf ahkurtz sipa Eelis magistr Jaxan mullein mimico Gurragchaa Ghoul_ FalkoPeters puzza007 gereedy bogner confab ivan\ willb wagle Nickeeh brainproxy elgot kranius totte nathanel_ quicksilver bezik danr theorbtwo Debaser tswett Erstarrung yan_ magicman herself Nshag mahrz alang sajith mephx pyry` plhk pnielsen bapa phrst Bwild birkenfeld Vq Walther)
22:13:25 --- names: list (edwtjo opqdonut Choko fabjan cajla Gothmog_ kobsu tweakism mollerstrand Dybber dsantiago upgrayeddd geoffh whoops Liebach bylzz bartavelle davean_ ido_ stephe- hanDerPeder barrucadu seats deavidsedice McManiaC popx_ voyd xvilka Will| gspr Xeross Counter-Strike pdxleif_away saiam Boney Im_Also_Greg liesen tanakh ethercrow Fubar^ chrra ivan electrogeek Mortchek dumbhat myme drmegahertz noj tomh alshain jodaro ccasin boyscared jliikka mjrosenb bduc- Saizan rcl)
22:13:25 --- names: list (xenocons hirsch__ fireglow Happy0 ajcave munro vanseverk ciaranm fattrat wtw gdsx Estrellas lambdabot zorzar yam solirc Eliel Arnar drewr `micro alcz Igloo kloeri skp erineh_ zomg s4msung sulaco_ wto elemir fuho ion stelleg_away lopex chrisbuchholz_ bobry mgeorgi_ arnihr_ wilfredh percival__ ninzine Canar sunnavy knyppeldynan jubos fergusnoble majoh mikeplus64 hpd elliott arkx tvaalen jml kkris mzarella Gracenotes Viesti Enigmagic machisuji nominolo qz jix)
22:13:25 --- names: list (wumpus pigoz lazard kqr mux statusfailed shanse moben fionnan_ Razz_ heath pfoetchen xlr __main__ ibid Varakh tlockney zeiris johnw jtobin `bps gds flux Jello_Raptor felipe_ fryguybob Obfuscate davorak int-e edwinb Martty simply-chris emias schlumpi tomaw wereHamster asdfasdf cl_away ivan` sjl Adeon rntz sixohsix ique idoru tomku f8_ mlinksva Athas DustyDingo newsham Heffalump CosmicRay suiside byorgey Sagi pr endou faen sordina threedaymonk Rembane faheem)
22:13:25 --- names: list (jerojasro r126l d-snp Laney peltchu mrshoe dilinger jlouis lahwran The_third_man monique_ rcj_ wolong ghorn ptek JoshuaA koninkje_away endojelly Guest75608 juri_ Boreeas _janne robbert othiym23 xnyhps hpaste Spockz Fluky ocharles Raynes lpsmith srcerer lenstr fmap @ChanServ mechairoi kmicu Derander pharaun Valodim froztbyte bcoppens aszlig kaol thalll cebewee copton cjay MasseR freiksenet peddie noplamodo liszt_ pyrtsa ]OLI[ CindyLinz XMunkki Bigcheese mvj4_)
22:13:25 --- names: list (tafryn cynick bstrie mattp_ hiredman Draggor agundry Ptival masquerade plat0 mpu guerrill1 dyreshark ggreg klugez bens Ke elliottcable dixie thoughtpolice mami epsil mokus BrianHV cods drek companion_cube deggis itzmjauz_ zenzike a11235_ simon__ Jonte certainty alexanderte ynik smash Chousuke x7 scgilardi saurik jrslepak shrimpx SimonRC ahf koala_man mietek jayne Iceland_jack hackagebot mendez pqmodn banjiewen absence sully mrd bxc finnrobi)
22:14:43 <mzero> did you run ghc-pkg check as the otuput asked?
22:15:33 <rdesfo> ya, there are alot of broken packages
22:16:18 <mzero> looks like your installation of hpsec is messed up - you could try cabal install --reinstall hspec-1.4.3   to reinstall it and (hopefully) unbreak it
22:17:33 <rdesfo> hspec-1.4.3 failed during the building phase. The exception was:
22:17:33 <rdesfo> ExitFailure 1
22:21:17 <mzero> !
22:21:38 <mzero> soundsl like your package installation set up is now hosed.
22:22:04 <rdesfo> :(
22:22:04 <mzero> is it reasonable to re-install all you need? (usually one cabal install --only-dependencies in some project will do it)
22:23:14 <rdesfo> where does cabal install all the packages?
22:23:25 <mzero> if so... you can try    blowing away    ~/.ghc/<version-of-ghc>
22:23:38 <mzero> that is where the user database of what is installed is kept
22:23:48 <rdesfo> ok thanks
22:24:00 <mzero> if it is gone, ghc will think you have no user installed packages, no matter where cabal left gunk
22:24:25 <mzero> (assuming you don't install packages --system)
22:33:27 <M30W> Blahh~!~!!
22:34:09 <M30W> Can someone please help me write a parsec parser???
22:34:27 <M30W> Help /= link to useless documentation
22:34:49 <M30W> Or RWH :|
22:35:28 <startling> M30W, have you seen the haddocks?
22:35:41 <startling> and/or the docs on the website?
22:35:42 <M30W> startling: Yea
22:35:52 <startling> M30W: do you have a specific question?
22:35:58 <tieTYT> it's weird how gradually the ghci errors make more and more sense
22:36:07 <tieTYT> i thought they were so cryptic at first
22:36:20 <M30W> startling: I've tried several times in writing a parsec parser.. No luck
22:36:38 <M30W> I've improved my current parser however; But I still don't have what I need.
22:37:01 <startling> M30W, um, okay.
22:37:11 <M30W> ["n","north"] -> Left North -- Also incase sencitive.
22:37:24 <hpaste> pharaun pasted “Type Error - Restricted IO” at http://hpaste.org/81628
22:37:32 <M30W> map toLower string fixes the case but not quite all I need :P
22:37:46 <pharaun> I'm probably just being very rusty, been about 2 months since i've touched any haskell code, i'm just not for sure why this is not working ^
22:38:05 <M30W> Or just "lower" in parsec. :)
22:38:49 <hpaste> “Anonymous Coward” annotated “Type Error - Restricted IO” with “Type Error - Restricted IO (annotation)” at http://hpaste.org/81628#a81629
22:39:25 <pharaun> oh
22:39:28 <pharaun> *facepalm*
22:39:40 <pharaun> i see why its not working, partial func
22:39:49 <pharaun> like i said, rusty rusty
22:40:25 <pharaun> @pl foo bar = UnsafeIO $ what (why hi)
22:40:25 <lambdabot> foo = const (UnsafeIO (what (why hi)))
22:40:39 <mzero> M30W - it might help if you hpaste'd your current parsec code
22:40:59 <pharaun> haha hmmph :)
22:41:59 <M30W> mzero: Current = not parsec hehe
22:42:27 <M30W> mzero: http://ix.io/4dY
22:42:30 <M30W> Current program
22:43:15 <M30W> mzero: Want to use parsec to manage the input to control everything correctly; Note the commented out definition for Interaction.
22:44:21 <M30W> After I have this I'll attempt to make a world.file which may get a bit annoying to get used to. But it
22:44:27 <M30W> 'll be easier to manage
22:46:39 * M30W wonders how parsec would go with generating an infinite tree. :)
22:48:03 <M30W> Also.. (Not meaning to skip ahead) but.. Would modifying a room flow through it's children (when they refer to it)? -- Hence infinite
22:48:16 <mzero> This kind of parser is very easy.      grabCmd = token "grab" >> return Grab       talkCmd = token "talk" >> Talk <$> name <*> textToEndOfLine
22:50:37 <mzero> now, you need to write some atoms like     token s = many space >> string s       and perhaps     word = many space >> many1 letter       and maybe     textToEndOfLine = many space >> many (satisfy (/= '\n') <* newline
22:51:12 <M30W> O.o
22:51:23 <M30W> You've lost me... Mind hpast'n what you suggest?
22:51:56 <mzero> give me a min. or two - I'm working up a fuller example that runs
22:52:05 <M30W> Okay. Thankyou sir.
22:56:11 <lispy> heelllllooooooo
22:56:16 <johnw> lispy!
22:56:25 <lispy> Hello, johnw
22:57:49 <johnw> having any Haskell fun tonight?
22:58:03 <johnw> I'm trying to add private repo support to joeyh's github-backup utility
22:59:14 <lispy> I finally read the shake paper tonight.
22:59:24 <lispy> I'm not sure what to make of shake, but then I like make.
22:59:37 <lispy> I'm skeptical about the dependency graph claims
22:59:43 <lispy> private repo support?
22:59:46 <Heffalump> which claims?
22:59:47 <TravisD> Can you use "where" in one part of a guarded function?
22:59:47 <Rotaerk> hmm... "Watch out when repeatedly using the ++ operator on long strings. When you put together two lists (even if you append a singleton list to a list, for instance: [1,2,3] ++ [4]), internally, Haskell has to walk through the whole list on the left side of ++."
22:59:56 <Rotaerk> that's from LYaH... that's not true is it?
23:00:04 <johnw> yes, it is true
23:00:10 <elliott> It's true, but maybe misleading.
23:00:16 <lispy> Heffalump: that make can't reasonably handle dynamic dependencies. It seems that chaining of rules works just fine.
23:00:20 <elliott> [1,2,3] ++ [4] will produce 1, 2, 3, then 4, incrementally.
23:00:25 <elliott> It won't process the whole left list before outputting any elements.
23:00:34 <Heffalump> Rotaerk: it's just like a singly linked list in C where you only have the head pointers
23:00:48 <geekosaur> Rotaerk, a list in Haskell is a singly linked list.  if you want something more optimal for string behavior look at Text or ByteString
23:00:55 <Heffalump> lispy: don't you have to include dynamically generated makefiles?
23:01:03 <Maxdamantus> > fix (++ [4])
23:01:06 <Rotaerk> I know what list it produces, but the text is suggesting that it has to actually iterate through the entire left list in order to complete the concatenation
23:01:06 <lambdabot>   mueval-core: Time limit exceeded
23:01:06 <geekosaur> (that is, "Foo" is 'F':'o':'o':[])
23:01:09 <Maxdamantus> > fix ([4] ++)
23:01:11 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
23:01:20 <geekosaur> yes, it does
23:01:24 <geekosaur> there is no end pointer
23:01:34 <lispy> Heffalump: what I do like about shake is that (if I understand it correctly) there is a sort of continuation style used to capture additional work. That seems quite slick.
23:01:35 <elliott> depending on what you mean by "complete", sure
23:01:58 <Rotaerk> it suggests that there's a performance concern, which there... doesn't seem to be
23:02:08 <ski> TravisD : iiuc, yes
23:02:39 <Rotaerk> ([4,4..] ++ [5]) !! 1 returns... if what LYaH is saying were true, it would never return
23:02:58 <lispy> Heffalump: Oh, you mean when you use something like gcc -MM?
23:03:01 <TravisD> ski: Ah, I couldn't figure out the syntax
23:03:39 <geekosaur> for short strings its fine.  for longer ones you can start to notice
23:03:41 <Heffalump> lispy: yes
23:03:52 <Heffalump> at least I'd assume that's what's meant by a dynamic dependency
23:03:56 <ski> TravisD : `where' must occur after all the guards attaching to the defining equation
23:03:57 <elliott> Rotaerk: No, that's not the case.
23:04:06 <TravisD> ski: Ah, I se
23:04:07 <TravisD> see*
23:04:10 <elliott> As I said: <elliott> [1,2,3] ++ [4] will produce 1, 2, 3, then 4, incrementally.  <elliott> It won't process the whole left list before outputting any elements.
23:04:29 <geekosaur> keep in mind that laziness means it's not even actually a linked list of characters; it's a linked list of code chunks that generate individual characters when evaluated.  (laziness)
23:04:42 <lispy> Heffalump: that's certainly an instance. But they give a different kind of example in the paper where a rule builds result.tar and depends on all the files that go into the tarball.
23:04:48 <Rotaerk> elliott: right, but that seems to be in conflict with LYaH
23:05:00 <elliott> What LYAH says is ambiguous.
23:05:11 <elliott> It is technically true if you interpret it right.
23:05:19 <elliott> I agree it is misleading.
23:05:31 <Rotaerk> well it also says "putting something at the end of a list that's fifty million entries long is going to take a while"
23:05:45 <Rotaerk> which seems unambiguous
23:06:31 <lispy> Heffalump: it's possible that I don't understand the problem their solving because I haven't worked on the makefiles for enough projects where code is generated in new files where the dependencies are non-obvious.
23:06:34 <geekosaur> it will, but it will take that while in a different place.  if for example you do that and then the whole thing is passed to putStrLn, it does the traversal then.  but it will anyway so you don't notice, which is one reason we get away with working with lists instead of vectors or etc.
23:06:40 <lispy> they're*
23:07:03 <geekosaur> basically, laziness means that things like that are not necessarily a gotcha but *can* bite you when you least expect it
23:07:23 <lispy> Heffalump: did you see the thing offer made by factis research?
23:07:32 <M30W> mzero: Having problems?
23:07:36 <lispy> Heffalump: the offer to help with darcs development?
23:07:38 <mzero> almost there
23:07:50 <M30W> mzero: Sweet; thanks man. ^_^
23:07:52 <Rotaerk> geekosaur: what it's suggesting is that (bigList ++ smallList) is somehow going to take longer than (smallList ++ bigList).  If you were to take either of those expressions and do, say, a putStrLn on them, they'd take the same time
23:08:27 <Heffalump> lispy: no, where?
23:09:25 <ski> Rotaerk : no
23:09:46 <geekosaur> Rotaerk, if all you do is putStrLn, they'll be the same.  but there are cases where it will matter.  sadly, laziness (well, non-strictness / data oriented evalulation) is such that simple examples are difficult to come up with
23:09:50 <hpaste> mzero pasted “AdventureParser” at http://hpaste.org/81630
23:09:50 <ski> Rotaerk : `putStrLn (bigString ++ smallString)' takes longer
23:10:01 <Rotaerk> why?
23:10:15 <M30W> mzero: -- These defs would be in some other module... About that; I merged for the paste :P
23:10:30 <geekosaur> will it?  should just traverse both at the same time, I'd think, and not matter if they're done that way or the other or even separately?
23:10:43 <mzero> M30W: okay - there - I admit there is a tiny bit of voodoo in there (you probably aren't used to +++ from Arrow.... and you can do what I did otherways too)
23:11:23 <Rotaerk> ski: iterating over N elements then M elements should take the same amount of time as the reverse
23:11:27 <ski> Rotaerk : and `putStrLn (((string0 ++ string1) ++ string2) ++ string3)' will take longer than `putStrLn (string0 ++ (string1 ++ (string2 ++ string3)))' -- the more nested (left vs. right) you go, the larger difference
23:11:40 <Rotaerk> okay, but why
23:12:12 <lispy> idea: use one of those weird type systems like clean has to ensure laziness is lazy, eg., thunks in the RTS are typed such that they are evaluated at most once
23:12:23 <ski> because `putStrLn (bigString ++ smallString)' traverses the final list -- but to build that, `bigString' must also be traversed
23:12:35 <M30W> mzero: Did you have a test use main.hs ?
23:12:41 <mzero> no
23:13:09 <M30W> Okay, thanks for the parser ^_^
23:13:14 <Rotaerk> ski: but it doesn't build a "final list"
23:13:16 <ski> due to laziness, the traversal of `bigString' happens interleaved with the (building and) traversal of the full list, so there isn't (necessarily) a latency problem here
23:13:19 <M30W> Still needs a little to do but yea. :)
23:13:23 <Rotaerk> hmm
23:13:29 <ski> yes, `(++)' builds a final list
23:13:31 <jerry`> ski then why do you say it's slower?
23:13:41 * edwardk needs to remove 'traversal' from his highlight list.
23:13:53 <lispy> traversal: heh
23:13:56 <mzero> M30W: whoops - I forget trys around all the commands - which is a bit of a pain, but needed
23:14:04 <mzero> since the keywords overlap in prefexes
23:14:18 <lispy> mzero: and now you know why parsec is not my favorite :(
23:14:21 <ski> jerry` : in `string0 ++ (string1 ++ (string2 ++ string3))', `string0',`string1',`string2' are all traversed once to build the final list
23:14:29 <jerry`> from what I got in both cases both lists are traversed once, since putStrLn has to go through all elements anyway
23:14:34 <jerry`> due to lazy evaluation
23:14:41 <M30W> mzero: Come again?
23:14:53 <lispy> johnw: have you been up to any Haskell fun tonight?
23:15:17 <johnw> I'm trying to add private repo support to joeyh's github-backup utility
23:15:23 <ski> in `((string0 ++ string1) ++ string2) ++ string3', `string0' is traversed once, then the copy of `string0' together with `string1' is traversed once, then the copy of the copy of `string0' together with the copy of `string1' together with the copy of `string2' is traversed once
23:15:27 <ski> jerry` : ok ?
23:15:34 <mzero> M30W: Parsec, by default, doesn't backtrack - so if it you try to parse "give bob axe", it'll match the 'g' in "grab" and then fail
23:15:34 <lispy> johnw: But, I can't tell if that answers my question :)
23:15:46 <johnw> ah, yes, it's fun
23:15:49 <mzero> you need to code the backup points
23:15:55 <jerry`> ski I thought that is the case as well, but earlier comments suggest different
23:16:11 <M30W> Ah
23:16:12 <M30W> I see
23:16:15 <lispy> M30W: not only does it match the 'g', but it consumes it.
23:16:17 <M30W> Wrap with try how?
23:16:30 <mzero> easy - one line change
23:16:31 <mzero> coming up....
23:16:32 <M30W> lispy: Yea figured
23:16:47 <ski> jerry` : the difference with laziness is only that this work is getting delayed (and therefore interleaved) -- it's only if you don't use part of the result that some of the work may get saved
23:16:52 <hpaste> mzero annotated “AdventureParser” with “AdventureParser (annotation)” at http://hpaste.org/81630#a81631
23:17:01 <johnw> lispy: you?
23:17:02 <mzero> just added try to keyword
23:17:09 <ski> jerry` : of course, this is all assuming no fusion optimization in the compiler
23:17:21 <lispy> johnw: I'm still ruminating on the paper I read. No haskell for me tonight :(
23:17:22 <Rotaerk> interesting
23:17:30 <M30W> Intersting
23:17:39 <M30W> Interesting *
23:17:44 <Rotaerk> interstring
23:18:06 <ski> jerry` : "both cases both lists are traversed once, since putStrLn has to go through all elements anyway" -- yes, but `(++)' additionally has to traverse the left list
23:18:19 <johnw> lispy: the majority of my day was spent turning gitlib into a fully abstract API, with the hope that "hit" will become a pure Haskell alternative backend to using hlibgit2
23:18:19 <mzero> notice how since your constructors follow the order and format of what you expect the commands to be, the parsers for each command are one-liners
23:18:30 * M30W is unsure if Item should be a string...
23:18:32 <M30W> mzero: ^
23:18:33 <mzero> (using <$> and <*> which are well worth learning)
23:18:51 <mzero> Well.... here, Parsec is forcing you to make a decision
23:19:00 <M30W> mzero: I use <$> often enough; what's <*> ?
23:19:08 <lispy> johnw: what is your goal with that project?
23:19:20 <jerry`> ski ++ is delayed until those elements are requested, which in the case of putStrLn is until end of big list at the beginning is reached. so are you sure that haskell runtime has to go through the big list all over again, instead of just continuing where it stopped?
23:19:28 <lispy> johnw: presumably the cannonical git impl. works and does everything?
23:19:45 <lispy> (it's okay if you can't say)
23:19:56 <johnw> ilspy: it's for writing Git utilities in Haskell, I already have three things I use it on
23:19:59 <mzero> if the *syntax* for item is just an alpha name, then this parser is right, and later you might, while executing the command find no such item and complain
23:20:03 <johnw> lispy: what do you mean by canonical?
23:20:05 <ski> jerry` : you are probably misinterpreting, due to you saying "go through the big list all over again"
23:20:09 <Rotaerk> does haskell have something similar to .NET's IEnumerable, where B ++ S *does* take the same amount of time as S ++ B, because it doesn't actually cache the results of the concatenation
23:20:24 <mzero> on the other hand, if you want the syntax to be dependent on what items are currently available, you need to change the item parser
23:20:35 <tgeeky> Rotaerk: DList ?
23:20:50 <M30W> mzero: Also you missed the Directions :P
23:20:58 <ski> jerry` : that sounds like : (a) `(++)' traverses `bigList'; (b) `putStrLn' traverses the copy of `bigList', which continues with (the original) `smallList'
23:21:11 <ski> jerry` : what actually happens is that (a) and (b) gets interleaved
23:21:19 <NemesisD> anyone familiar with the failure library? i can't figure out how one actually uses it practically
23:21:19 <M30W> mzero: How could I match "n" and "north" ?
23:21:20 <tgeeky> Rotaerk: http://hackage.haskell.org/package/dlist-0.5 ?
23:21:24 <ski> jerry` : but you still have to do "double work" for the elements of `bigList'
23:21:27 <mzero> item = do { spaces; itemName <- many1 letter; case lookup item inventory of { (Just i) -> return i; Nothing -> mzero }
23:21:43 <lispy> johnw: I mean git-core. I had the impression you're implementing git.
23:21:48 <johnw> lispy: ah, no
23:22:05 <NemesisD> trying to get my code to expose a no-exception API. all responses are instead Success a | Error String
23:22:13 <Rotaerk> tgeeky: hmm, not quite, I think, based on its description, but I'm not sure
23:22:14 <johnw> lispy: my library lets you interact with Git repositories in Haskell; I'm not trying to replace the command-line "git" utility
23:22:17 <mzero> you could right a parser    keywords :: [String] -> Parser ()      this should succeed if any of the strings match
23:22:44 <johnw> lispy: in fact I intend to have a gitlib-cmdline backend, which just shells out to Git, as the "reference" implementation
23:22:47 <Rotaerk> I'll look into it later; bed tim
23:22:58 <M30W> O.o
23:23:00 <lispy> johnw: cool
23:23:06 <M30W> I am confused. :|
23:23:13 <johnw> think of gitlib as just being a nicer set of types (maximizing the benefit of laziness and conduits) on top of Git
23:23:15 * lispy think it time for sleeps
23:23:25 * lispy nods
23:23:37 <M30W> I thought just adding ... Right (xxx) and adding the directions with Parser (Either Direction Interaction) and the extra commands>?
23:23:42 * tgeeky wakes up lispy and tells him to go to bed!
23:23:49 <Romey> :)
23:23:50 <NemesisD> how does failure work exactly? it puts the responsibility of how failure is handled into the monad you're using?
23:23:52 <mzero> keywords ks = spaces >> choice ( map string ks)
23:23:54 * lispy wakes up and heads up stairs
23:24:02 <lispy> night all
23:24:04 <Romey> hey
23:24:10 <Romey> can anyone help me decide something
23:24:11 <johnw> night
23:24:16 <ski> jerry` : it's like this : (b) `putStrLn' demands to know whether the list is empty or not; (a) `(++)' demands to know whether `bigList' is empty or not; let's assume it's not empty, so it makes a new cons node, with a delayed recursive call in the end; (a) `putStrLn' gets the `Char' and prints it, then continues with the rest of the string from the start again
23:24:21 <M30W> mzero: hmm
23:24:42 <Romey> i am new to functional programming and i am confused on which is the most suitable language for me
23:25:01 <Romey> erlang or haskell or clojure
23:25:09 <ski> jerry` : this continues until `(++)' discoverse `bigList' has been exhausted, at which point it just "replaces itself" with `smallList' (which now feeds its elements *directly* to `putStrLn' !)
23:25:19 <mzero> M30W:    if you were going to do that.. .then you'd need to have somethign liek         action = (Left <$> direction) <|> (Right <$> command)
23:25:35 <M30W> Hmmm
23:25:36 <johnw> Romey: you can rule out clojure if you don't want to be tied to the JVM
23:25:50 <M30W> Mind pasting a solution that does this? =)
23:25:55 <hpaste> NemesisD pasted “converting errors?” at http://hpaste.org/81632
23:26:00 <mzero> But I wouldn't reccomend that --- I'd add a constructor for Interaction like      Go Direction     --- and have parsers for the direction just apply Go
23:26:06 <NemesisD> could someone help me figure out what's going on there ^^
23:26:08 <mzero> (even though there is no keyword Go)
23:26:16 <Romey> clojure has a good multithread support though and that's something i really need
23:26:36 <NemesisD> data RPCResponse a = RPCSuccess a | RPCError String
23:26:39 <mzero> which "this" are you having trouble with?
23:26:45 <Romey> i am not sure how good multithread interaction is in haskel
23:27:02 <M30W> mzero: Managing the two different type sets
23:27:05 <M30W> (Direction vs Interaction)
23:27:08 <mzero> don't
23:27:28 <mzero> that is going to be awkward - add a constructor to Interaction for going
23:27:40 <M30W> Ah
23:27:41 <M30W> Nice
23:27:48 <mzero> it doesn't need to be parsed by "go" -- but in the program, you have the constructor to case on
23:28:09 <johnw> Romey: threading in Haskell is very nice, actually, between the async and stm libraries
23:28:35 * slack1256 agrees, async is super-nice!
23:28:54 <SamanthaD> hey!
23:28:57 <mzero> but notice that Parser here is a Monad and a Functor - so something like    action = (Left <$> direction) <|> (Right <$> command)     should be clear
23:29:18 <pharaun> this is probably a dumb question but for ex can i do this - test :: (MonadNIO a, MonadForkIO b) -> (a+b) () - somehow?
23:29:33 <mzero> "parse a direction, then lift Left over it.... otherwise   parse a command, then lift Right over it"   .... hence the type is    Either Direction Interaction
23:29:48 <pharaun> or do i need to define a new typeclass which has both MonadNIO and MonadForkIO as a parent?
23:31:23 <M30W> mzero: Yea.
23:31:59 <M30W> mzero: I think I'm gonna go with the Interaction Go method :P
23:32:34 <jerry`> ok I did a little test. why is func2 only 12% slower?
23:32:56 <hpaste> jerry pasted “appending vs prepending” at http://hpaste.org/81634
23:33:19 <jerry`> func1 is slower I meant, but only 12%
23:33:58 <M30W> Not in scope token, textToEndOfLine <*> hehe
23:34:18 <jerry`> if func1 has to go two times through the first 10 million elements, and func2 only once, shouldn't it be aprox 2x slower?
23:34:18 <M30W> That doesn't make sense :(
23:34:21 <M30W> mzero:
23:34:27 <mzero> M30W: one other note - some people like to write their parsers so that each parse consumes the _trialing_ spaces, not the _leading_
23:34:31 <mzero> there are pros and cons
23:34:45 <M30W> Oh nvm; was wrong file
23:35:34 <fmap> jerry`: left- and right- associative `(++)' is basically O(n^2) vs O(n) difference, single `xs ++ ys' may not show it
23:35:48 <jerry`> 100 million elements even
23:36:34 <jerry`> fmap prepending should be O(1), appending O(n). so that's 100 million iterations vs one
23:36:49 <fmap> ?
23:37:02 <M30W> Hmm
23:37:09 <jerry`> adding element at the beginning of a list is O(1), at the end O(n)
23:37:12 <M30W> mzero: I think I'm running incorrectly?
23:37:27 <mzero> ?
23:37:37 <NemesisD> grahhh i wish the compiler would tell me all the types its thinking about. It says it cannot deduce E.Exception e0 but does not show me where it thinks that e0 is so i can't write a clarifying typesig
23:37:39 <M30W> case praseCommand y of ..
23:37:49 <M30W> Sorry lagged
23:37:51 <mzero> λ: parseCommand "give bob axe"
23:37:51 <mzero> Right (Give "bob" "axe")
23:38:02 <jerry`> ski do you have any comments on these results?
23:38:15 <fmap> jerry`: that's not relevant here
23:38:17 <jerry`> would it be different under different circumstances?
23:38:25 <Maxdamantus> let fromTo a b = if a > b then [] else [a] ++ fromTo (succ a) b in sum $ fromTo 1 100000
23:38:26 <jerry`> fmap ok, why?
23:38:36 <Maxdamantus> > let fromTo a b = if a > b then [] else [a] ++ fromTo (succ a) b in sum $ fromTo 1 100000
23:38:38 <fmap> jerry`: `last' is what traverses list constructed while it traverses it :)
23:38:39 <lambdabot>   5000050000
23:38:59 <fmap> and it's O(n) in both cases
23:39:14 <Maxdamantus> > let fromTo a b = if a > b then [] else fromTo a (pred b) ++ [b] in sum $ fromTo 1 100000
23:39:17 <lambdabot>   mueval-core: Time limit exceeded
23:39:25 <jerry`> that is what I thought originally as well, and it looks like benchmark confirmed it
23:40:10 <ski> fmap : "left- and right- associative `(++)' is basically O(n^2) vs O(n) difference" can be misinterpreted
23:40:45 <ski> (but i know what you meant)
23:41:07 <fmap> ski: how to say it better?
23:41:10 <ski> jerry` : probably the overhead of printing the characters
23:41:20 <jerry`> ski I am only printing sizes
23:41:40 <jerry`> and it takes 2 and a half seconds, so not likely :)
23:42:19 <ski> perhaps try `map (:[])' and then either `foldl (++) []' or `foldr (++) []' ?
23:42:25 <jerry`> or rather, only printing the last element
23:42:59 <jerry`> no idea what you mean. can you update the code?
23:43:43 <ski>   funcL = (last . foldl (++) [] . map (: [])) [1 .. 100000000]
23:43:47 <M30W> Hmm
23:43:49 <ski>   funcR = (last . foldr (++) [] . map (: [])) [1 .. 100000000]
23:45:01 <M30W> mzero: Expected type: Either ParseError Interaction -> Interaction Actual type: Either ParseError Interaction -> Either String Interaction
23:45:04 <M30W> ??
23:45:28 <ski> `Interaction' is not `Either String Interaction'
23:45:36 <M30W> Yea I know
23:45:59 <mzero> yes - the parser I wrote returns an Either String Interaction ---- left side is an error message that it didn't parse, right side is a correct parse
23:46:04 <ski> possibly yuo need a `return' somewhere
23:46:23 <ski> oh, right, other dir
23:46:45 <mzero> if you don't want that (you have NoSuchCommand as a constructor, which I think is odd) then replace   (show +++ id)   with   either NoSuchCommand id
23:46:55 <jerry`> ski did you mean funcL = (last . foldl (++) [] . map (: [])) [1 .. 100000000] ++ [1]  ?
23:47:03 <mzero> er     either (const NoSuchCommand) id
23:47:17 <ski> fmap : hm, i would emphasize more that we're talking about *nested* left- resp. right- associated calls to `(++)' (and not just one call)
23:47:30 * Maxdamantus likes his example.
23:47:31 <ski> jerry` : no
23:47:52 <notdan> Are there any good libraries for Haskell for loading/working with 3D models (format does not matter)
23:48:21 <ski> (fmap : on my first read on your comment, you seemed to be saying something about `(xs ++ ys) ++ zs' vs. `xs ++ (ys ++ zs)')
23:48:53 <jerry`> oh foldr with : and foldl with ++. well that's quite different than earlier example
23:49:14 <ski> mzero : `left (const NoSuchCommand)', i suppose
23:49:35 <M30W> Yay
23:49:41 <M30W> Thank you very much mzero ^_^
23:50:33 <mzero> your welcome - just promise me you'll look up all the functions in there that you don't know, k?
23:50:53 <mzero> when you get that stuff under your belt, it'll start flowing easy
23:52:27 <ski> jerry` : `funcL' will build something of the shape `(((..((([] ++ [1]) ++ [2]) ++ [3])..) ++ [99999998]) ++ [99999999]) ++ [100000000]'
23:52:37 <ski> jerry` : while `funcR' will build something of the shape `[1] ++ ([2] ++ ([3] ++ (..([99999998] ++ ([99999999] ++ ([100000000] ++ [])))..)))'
23:52:41 <jerry`> I know
23:52:47 <ski> (assuming no fusion)
23:53:13 <ski> the latter ought to be linear in the length of the original list
23:53:24 <ski> while the former ought to be quadratic in the length of the original list
23:54:25 <ski> jerry` : .. and you know how such left-associatedness of )++)' calls can occur, indirectly, via recursion ?
23:56:10 <jerry``> I do, and understandwhy : is a lot more efficient in this case
23:56:20 <jerry``> but the original topic was funcThatTraversesList $ [1..100000] ++ [0]   vs funcThatTraversesList  $ [0] ++ [1..100000] .  and looks like they are more or less similarly efficient
23:56:42 <Taneb> I've I'm trying to FFI to a C++ vector, can I use Data.Vector.Storable or something?
23:56:45 <ski> (e.g. naive-`reverse')
23:57:40 <ski> the difference isn't as pronounced with only one append
23:58:20 <jerry``> but it should have been if it did what we thought. traversing a huge list once vs two times
