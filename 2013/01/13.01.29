00:01:45 <ninegrid> has anyone used orientdb from haskell?
00:01:57 * hackagebot authenticate 1.3.2.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2.1 (MichaelSnoyman)
00:06:56 <msxx> are they ghc bugs or holes in type system?
00:06:59 * hackagebot wai-handler-devel 1.3.0.4 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.3.0.4 (MichaelSnoyman)
00:07:05 <qnikst> hello is there a good way to call exec from haskell?
00:07:33 <shachaf> execve() the system call?
00:07:40 <shachaf> You can run programs but usually you let the RTS do it.
00:08:01 <shachaf> msxx: Are what?
00:08:03 <shachaf> Oh.
00:08:07 <shachaf> GHC bugs.
00:08:18 <shachaf> The Haskell type system is not supposed to let you write unsafeCoerce.
00:08:22 <msxx> good :)
00:08:27 <shachaf> Well, the GHC one isn't either.
00:08:41 <shachaf> But it's easier to have bugs in a complicated program like GHC. :-)
00:09:26 <qnikst> shachaf: yep, I've seen only run process that keep RTS alive after calling
00:10:57 <shachaf> @google haskell execve
00:10:59 <lambdabot> http://www.haskell.org/ghc/docs/5.02.1/set/process-primitives.html
00:10:59 <lambdabot> Title: Posix Process Primitives
00:11:05 <shachaf> Hmm, that's a bit old.
00:11:11 <shachaf> Over here Google finds http://hackage.haskell.org/packages/archive/unix/2.5.0.0/doc/html/System-Posix-Process.html
00:11:25 <qnikst> ah thanks
00:11:57 * hackagebot yackage 0.6.0.3 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.6.0.3 (MichaelSnoyman)
00:27:11 <hpaste> indomitus pasted “Binary Search Tree Node Removal” at http://hpaste.org/81460
00:28:34 <indomitus> can anyone help me with this: http://hpaste.org/81460
00:28:51 <simpson> I have two C libraries that thread in curious ways. How can I control the threading Haskell-side?
00:29:18 <shachaf> simpson: By writing code.
00:29:48 <simpson> shachaf: Isn't there something in the FFI about controlling which thread things will happen from?
00:30:10 <shachaf> Sure. There are lots of things.
00:31:02 <simpson> Well, I'm getting [xcb] Most likely this is a multi-threaded client and XInitThreads has not been called
00:31:07 <shachaf> "thread in curious ways" could mean many things.
00:31:17 <simpson> And I'm betting that it's because somehow an XCB call happened from a non-main thread.
00:31:35 <simpson> Which *should* be impossible, unless Haskell is spawning threads and not telling me.
00:31:39 <shachaf> If you have a library that uses thread-local storage, you probably want to use bound threads.
00:31:49 <shachaf> The RTS moves Haskell threads around between OS threads.
00:31:57 <shachaf> There's no guarantee that FFI calls will always happen on the same thread.
00:32:08 <fmap> indomitus: the error tries to say you don't have data constructor BST (which you don't)
00:32:46 <simpson> Can I do this when the libraries I'm using are already bound by somebody else's Haskell code?
00:32:52 <simpson> Or do I get to dig into the SDL bindings?
00:33:13 <ski> indomitus : i don't think you want to throw away `nr' respectively `nl' in the `k < nk' and `k > nk' cases
00:33:13 <shachaf> Is the library spawning its own threads?
00:33:17 <shachaf> You should read about forkIO and forkOS.
00:33:34 <shachaf> If you spawn a thread with forkOS, then any FFI calls that it does will be guaranteed to happen in the same OS thread.
00:33:41 <ski> indomitus : and you probably don't want to throw away `nr' *and* `ml' in the `k == nk' case
00:34:01 <simpson> What if the C library underneath spawns its own threads?
00:34:11 <ski> indomitus : also, you could case on `compare k nk', matching with `EQ',`LT',`GT'
00:34:35 <shachaf> simpson: That's a completely separate thing from Haskell threads.
00:35:07 <simpson> shachaf: So I'm currently not using *any* forkIO nor forkOS.
00:35:15 <shachaf> OK.
00:35:25 <shachaf> Are you compiling with -threaded?
00:35:39 <shachaf> If not, then it sounds like bound threads probably aren't your issue.
00:35:48 <simpson> Nope. I'm using  -Wall -O2 -rtsopts
00:36:41 <simpson> Well, I could probably ltrace to confirm, but I'm familiar with XCB/Xlib shenanigans. I'm pretty sure that (1) SDL doesn't call XInitThreads(), 'cause it's a priss, and (2) somebody's making an XCB call from a thread that doesn't own the XCB queue.
00:36:59 <simpson> And I'm gonna infer (3) SDL is being asked to make XCB calls from two different OS threads.
00:37:01 <shachaf> OK, well, I'd check who's spawning threads.
00:37:31 <shachaf> If you're not using fork* and you're not using -threaded, it seems to me like you wouldn't be making XCB calls from multiple OS threads.
00:37:33 <simpson> Is there a Haskell-side trace for that, or is it strace time?
00:37:44 <shachaf> Trace for what?
00:38:00 <shachaf> strace is a good first resort.
00:38:03 <simpson> For when/where threads are spawned.
00:38:04 <frerich> Is anybody aware of some sort of code generator which, given a DTD (or alternatively a Relax NG schema) generates an XML parser which not only validates against that schema but also extracts the information? Right now I'm working on an XML parser using xml-conduit, but implementing it is really dull since I just have to look at the Relax NG file and then write the appropriate parser code.
00:39:28 <flux> frerich, I don't know if there are actual modules for doing this, but I would probably use an XML parser, a DTD validator and then some XPATH queries for extracting the information?
00:39:40 <flux> but perhaps xml-conduit is better :)
00:40:24 <indomitus> fmap: thank you, aren't the first 3 lines the data constructor for BST, is it incomplete?
00:40:29 <frerich> flux: Right, that would work - but I'd like to extract (all) information. I basically have one ADT per element, so for '<person><firstName>Frerich</firstName><lastName>Raabe</lastName></person>' I have 'data Person { firstName :: FirstName, lastName :: LastName }'.
00:41:05 <frerich> flex: So I have a lot of boilerplate code,and I suspect that I could generate large parts (or all?) of it automatically given the schema/DTD
00:41:38 <fmap> indomitus: in the first 3 lines `BST' is type constructor and `Emp' and `Bind' are data constructors
00:41:48 <frerich> flex: http://relaxng.org/#code-generators only shows two things for Java :-/
00:41:58 * hackagebot yesod 1.1.8 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.8 (MichaelSnoyman)
00:42:24 <indomitus> ski: hmm i was throwing them away because i thought it would remove subtrees from the node I'm trying to delete
00:43:32 <indomitus> fmap: oh!! so i want to use bind instead of BST?
00:44:30 <ski> indomitus : i think the idea is that only remove the `Bind nk nv' part if `k == nk' -- but you have to keep the key-value pairs in the two subtrees, somehow
00:46:58 * hackagebot yesod-auth 1.1.4 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.4 (MichaelSnoyman)
00:47:00 * hackagebot yesod-core 1.1.8 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.8 (MichaelSnoyman)
00:51:41 <ohrmazd> http://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort#Haskell
00:51:49 <ohrmazd> doing some late night haskell study before bed
00:51:53 <fmap> indomitus: probably yes
00:52:02 * hackagebot yesod-form 1.2.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.2.1 (MichaelSnoyman)
00:52:04 * hackagebot yesod-routes 1.1.2 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.1.2 (MichaelSnoyman)
00:52:06 * hackagebot yesod-static 1.1.2 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.1.2 (MichaelSnoyman)
00:52:08 <ohrmazd> can someone help me understand the first version?
00:52:08 * hackagebot yesod-test 0.3.3.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.3.3.1 (MichaelSnoyman)
00:52:33 <shachaf> ohrmazd: Why would you want to bubblesort?
00:52:35 <shachaf> It's an evil algorithm.
00:52:40 <ohrmazd> i don't understand t | t == s
00:52:51 <ohrmazd> and _bsort s = s
00:52:53 <merijn> Ornedan_: It's a guard
00:52:54 <ohrmazd> the rest is pretty clear
00:52:56 <merijn> eh
00:53:10 <ohrmazd> shachaf, it's just nice to look at various sorting algorithms
00:53:11 <shachaf> ohrmazd: You don't understand the syntax? Or what?
00:53:16 <ohrmazd> yes, shachaf
00:53:18 <merijn> ohrmazd: It's basically saying for all pattern matches "t" (which is basically everything)
00:53:21 <shachaf> http://www.haskell.org/hoogle/ can look up syntax.
00:53:31 <merijn> Select the first guard that evaluates to true
00:53:31 <ohrmazd> ok, merijn
00:53:35 <ohrmazd> ahh
00:54:06 <merijn> ohrmazd: variable names without constructors can pattern match anything. The same goes for _bsort s = s
00:54:11 <EvanR2> :t deleteAt
00:54:12 <lambdabot>     Not in scope: `deleteAt'
00:54:12 <lambdabot>     Perhaps you meant one of these:
00:54:12 <lambdabot>       `M.deleteAt' (imported from Data.Map),
00:54:23 <merijn> ohrmazd: If it doesn't match the first _bsort case it will just return the list as-is
00:54:30 <ohrmazd> ok
00:54:47 <shachaf> ohrmazd: _bsort is just a name.
00:54:58 <ohrmazd> yes, i see that shachaf
00:55:08 <merijn> > let id a = a in (id 1, id 'a')
00:55:10 <lambdabot>   (1,'a')
00:55:28 <merijn> > let _bsort s = s in (_bsort 1, _bsort 'a')
00:55:30 <lambdabot>   (1,'a')
00:55:49 <ohrmazd> ok... so, merijn, t | t == s   -> t just returns the list as is in the case it's already sorted?
00:56:03 <shachaf> > let hi merijn = merijn in hi merijn
00:56:07 <lambdabot>   hello
00:56:48 <shachaf> ohrmazd: It means the same as: let t = _bsort s in if t == s then t else bsort t
00:57:02 <merijn> ohrmazd: More specifically t is pattern matched with the result of _bsort s, so "t == s" is equivalent to "_bsort s == s", the logic being "if _bsort doesn't change the list, then it must already be sorted"
00:57:27 <EvanR2> bubbasort
00:57:42 <merijn> It's a bit weird to write this using case-of and guards, imo
00:58:01 <merijn> An if/else would've been clearer
00:58:04 <ohrmazd> ok
00:59:05 <shachaf> merijn: Better yet not to write it at all.
00:59:44 <hpaste> merijn pasted “bsort using if/else” at http://hpaste.org/81461
00:59:48 <merijn> shachaf: Sure
00:59:56 <ohrmazd> ahh, thanks merijn
01:00:19 <merijn> eh
01:00:35 <merijn> Actually, maybe that should be "bsort t" in the final clause of the if/else
01:01:10 <merijn> Yeah, should be "bsort t", else you infinite loop :)
01:01:43 <ohrmazd> ok
01:02:16 <merijn> because "bsort s" will just run bsort with the exact same input infinitely, since it'll never match unless your original list was already sorted :p
01:02:36 <ohrmazd> merijn++
01:02:44 <ohrmazd> yes
01:02:50 <ohrmazd> i can see the infinite loop now
01:03:10 <ohrmazd> ok, wonderful
01:03:16 <ohrmazd> that makes for great bedtime reading
01:07:42 <EvanR2> is there a way to predict how much memory a Data.Map will use for ByteString keys and ByteString values
01:08:02 <msxx> is thre a way to uncurry printf?  something like uncurry printf "%d %s" (10, "foo")
01:08:22 <liyang> ohrmazd: http://catmacros.files.wordpress.com/2009/09/eternitycatwn9.jpg
01:08:24 <mSSM> Can I somehow store repa Shape's in an array?
01:08:34 <indomitus> fmap: ski: i figured it out! thanks for the help
01:08:55 <simpson> Well, found at least one problem.
01:09:00 <shachaf> > uncurry (printf "%d %s") (10 :: Int, "foo") :: String
01:09:01 <lambdabot>   "10 foo"
01:09:14 <simpson> A ForeignPtr was getting prematurely GC'd.
01:09:22 <msxx> oh, I thought varags made it not work
01:09:32 <msxx> so I didn't pay attention to error
01:09:33 <simpson> Is the correct way to express dependencies between ForeignPtrs to make an ADT which holds them?
01:09:33 <msxx> thanks
01:09:34 <liyang> Varargs? What varargs?
01:09:35 <shachaf> Haskell has no varargs.
01:09:42 <msxx> simulation of
01:09:46 <shachaf> printf is just a normal function with a weird type.
01:09:53 <shachaf> You should understand the general idea of how it works.
01:09:59 <msxx> there's some weird magic going on with printf that I don't understand
01:10:06 <shachaf> Go understand it!
01:10:09 <shachaf> hth
01:10:29 <shachaf> Really, look at Text/Printf.hs, figure out what's going on.
01:10:35 <msxx> I will take a look
01:12:39 <liyang> :t printf :: String -> String
01:12:41 <lambdabot> String -> String
01:12:47 <liyang> :t printf :: String -> Integer -> String
01:12:49 <lambdabot> String -> Integer -> String
01:12:56 <liyang> :t printf :: String -> Integer -> Double -> String
01:12:57 <lambdabot> String -> Integer -> Double -> String
01:13:07 <shachaf> Not type-safe. :-(
01:13:14 <liyang> Verily.
01:13:29 <Lethalman> :t printf
01:13:30 <lambdabot> PrintfType r => String -> r
01:13:40 <msxx> it's in the spirit of C :)
01:13:43 <Lethalman> huh
01:14:45 <liyang> Except C's printf will happily print a string as an integer, built-in compiler warnings aside.
01:15:07 <shachaf> Haskell printf needs %p
01:15:11 <shachaf> Er
01:15:12 <shachaf> %n
01:15:17 <shachaf> I should submit a patch to augustss
01:15:50 <mSSM> If I “let shList = Prelude.map (fromIndex (ix2 8 8)) [0..63]”, and then “fromList (ix1 64) shList”, GHC tells me to “Possible fix: add an instance declaration for (Target r0 DIM2)”, but I don't understand how that target is exactly supposed to look like. Why can't GHC infer what I want to store?
01:15:56 <mSSM> (this is Repa)
01:16:20 <shachaf> mSSM: When GHC says "Possible fix:", you should ignore that.
01:16:25 <shachaf> It's nearly always bad advice.
01:16:37 <mSSM> shachaf: I don't understand how to provide it with that.
01:16:40 <shachaf> It's getting taken out of 7.8
01:16:48 <Lethalman> shachaf, so the tricky behind PrintfType is the instance (PrintfArg a, PrintfType r) => PrintfType (a -> r) ?
01:16:53 <shachaf> Anyway, it looks like the problem is the DMR?
01:16:54 <mSSM> shachaf: Oh, I thought you were being sarcastic.
01:16:55 <shachaf> @where dmr
01:16:55 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
01:17:02 <shachaf> mSSM: Nope. It's bad advice.
01:17:16 <shachaf> mSSM: Try giving shList an explicit type.
01:21:08 <mSSM> shachaf: Thank you, it worked, though it doesn't look particularly beautiful! :D “fromList (ix1 64) shList :: Array Data.Array.Repa.Repr.Vector.V DIM1 DIM2”
01:21:52 <shachaf> mSSM: I suspect you could do other things, like: Turning off the Monomorphism Restriction (like I said earlier); using the value with a concrete type somewhere.
01:21:54 <mSSM> In this case, the vector has to store boxed values, right? I am not sure if I understood boxed/unboxed correctly.
01:22:20 <shachaf> In which case?
01:23:02 <mSSM> In the case of storing Shape types.
01:23:09 <mSSM> I.e. what I am doing here.
01:23:49 <shachaf> I don't know much about repa.
01:24:01 <mSSM> Ok
01:24:03 <shachaf> I guess DIM2 is just a fancy (Int,Int)?
01:26:25 <mSSM> shachaf: It's defined here [1]; DIM2 = DIM1 :. Int; DIM1 = DIM0 :. Int; DIM0 = Z. And finally, data Z = Z.  http://hackage.haskell.org/packages/archive/repa/3.2.3.1/doc/html/src/Data-Array-Repa-Index.html#DIM0
01:26:30 <mSSM> So I am not sure.
01:26:56 <shachaf> By "a fancy" I mean "isomorphic to".
01:27:23 <mSSM> I wouldn't know how haskell represents this internally. Isomorphic to - certainly.
01:27:49 <shachaf> Well, it probably has more ⊥s.
01:28:17 <mSSM> shachaf: Either way, what does that mean for me and Haskell?
01:28:45 <shachaf> I'm not sure what it means for you.
01:29:09 <mSSM> Is Haskell able to see it as an Unboxed value?
01:29:22 <shachaf> I don't know how unboxing works exactly.
01:29:29 <shachaf> I don't see an instance of Unbox, at least.
01:31:59 * hackagebot data-named 0.5.1 - Data types for named entities  http://hackage.haskell.org/package/data-named-0.5.1 (JakubWaszczuk)
01:37:01 * hackagebot nkjp 0.3 - Manipulating the National Corpus of Polish (NKJP)  http://hackage.haskell.org/package/nkjp-0.3 (JakubWaszczuk)
01:38:53 <b__> is there a parser-combinator library like parsec but _with_ ok docs?
01:41:02 <simpson> basdirks: Have you seen parsers?
01:41:18 <simpson> http://hackage.haskell.org/package/parsers
01:41:46 <simpson> It describes an abstract parser that could be parsec, attoparsec, or trifecta, and then gives you combinators on that.
01:42:12 <edwardk> and i actually bother to start documenting parsers
01:42:15 <edwardk> er bothered
01:42:27 <edwardk> it could definitely use more test cases though
01:42:33 <edwardk> (er, any?)
01:42:47 <basdirks> I was to write a Scheme
01:42:50 <basdirks> want*
01:43:05 <simpson> edwardk: Oh man! I just noticed that Parsing can be parameterized on any type, not just text-like types.
01:43:27 <simpson> So now I can do ometa-style higher-level parsers! Awesome.
01:43:27 <edwardk> simpson: Parsing doesn't care, yeah. its just CharParsing that wants it
01:43:41 <edwardk> but if you want to do your own token handling feel free
01:45:44 <basdirks> is parsers a good choice for writing a small Scheme?
01:46:29 <shachaf> I suspect parsing won't be the hard part of writing a Schemplementation.
01:46:54 <shachaf> (If you call your language Scheme, it should conform to RS or something.)
01:47:05 <dalaing1> basdirks: I used parsec when I worked through "write yourself a scheme in 48 hours"
01:47:14 <basdirks> yes R5RS shachaf
01:48:43 <dalaing1> dalaing1: ah, if you're aiming at R5RS then there's a chance that advice based on "write yourself a scheme" won't translate well, ignore me :)
01:49:23 <simpson> edwardk: Aha, there's a Stream instance in parsec for [t] and t, where [t] fixes t, so I could totally parse a list of tokens into a higher-level data type.
01:53:18 <basdirks> shachaf: at first I want to implement just a minimal subset
01:55:40 <edwardk> simpson: yeah. and there is a parsec-parsers package that provides an instance for parsers if you want to use any of my combinators or apply monad-transformers on top
01:55:48 <simpson> Nice.
01:56:59 * hackagebot fluidsynth 0.2.0.0 - Haskell bindings to FluidSynth  http://hackage.haskell.org/package/fluidsynth-0.2.0.0 (CorbinSimpson)
01:57:01 * hackagebot classy-prelude 0.4.4 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.4.4 (MichaelSnoyman)
02:01:15 <mSSM> Can I import several modules qualified with the same Prefix?
02:01:59 * hackagebot classy-prelude-conduit 0.4.4 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.4.4 (MichaelSnoyman)
02:02:58 <quchen> A couple of days ago there was a Haskell.reddit post about this mathematical structure that supports only differences, not sums. The example given was dates: their difference is a timespan, their sum doesn't make much sense. Do you remember the name of that structure? I can't find the post anymore.
02:03:11 <shachaf> Torsor?
02:03:29 <shachaf> Maybe I'm mixing it up.
02:04:26 <shachaf> Oh, yes, you're thinking of this post: http://ro-che.info/articles/2013-01-08-torsors.html
02:04:28 <quchen> shachaf: Right! Thanks. http://www.reddit.com/r/haskell/comments/166iju/subtractable_values_are_torsors/
02:04:37 <quchen> Exactly.
02:10:06 <Lethalman> about classyprelude, why is there a class for any method? for example, can't null be defined in terms of length? and length in terms of fold?
02:10:35 <mauke> no, null can't be defined in terms of length
02:11:03 <mauke> it's a fold, though
02:11:45 <Lethalman> mauke, map is a fold too?
02:11:49 <Lethalman> filter?
02:12:18 <mauke> yes
02:12:23 <merijn> Lethalman: Yes and yes
02:12:33 <Lethalman> why CanMap and CanFilter then?
02:12:59 <quicksilver> some times are mappable but not foldable I guess
02:12:59 <simpson> 'Cause it's too cool for Traversable and Foldable.
02:13:01 <merijn> Lethalman: The reason why null can't be defined in terms of length is because length doesn't return on infinite lists
02:13:15 <merijn> > null [1..]
02:13:16 <lambdabot>   False
02:13:21 <merijn> > length [1..]
02:13:25 <lambdabot>   mueval-core: Time limit exceeded
02:13:31 <Lethalman> merijn, thought about something like that :P ok that's fine
02:13:33 <shachaf> Lethalman: I don't recommend looking for for very much sense in the ClassyPrelude hierarchy.
02:13:45 <shachaf> They pretty much took every Prelude operation and made a class for it.
02:13:59 <Lethalman> quicksilver, for example?
02:14:00 <Lethalman> shachaf, I see
02:14:29 <Lethalman> one can still make an instance CanFold f => CanFilter f, I guess
02:14:56 <mauke> Lethalman: no
02:15:46 <simpson> I think you can build filter out of foldMap and duct tape...
02:15:47 <quicksilver> Lethalman: IO is a Functor which isn't Foldable.
02:15:55 <quicksilver> simpson: you can't, no.
02:16:14 <quicksilver> actually you can't build filter out of any of Functor, Foldable, Traversable, Monad, Applicative.
02:16:18 <Lethalman> quicksilver, what has that to do with filter?
02:16:38 <quicksilver> Lethalman: IO is CanMap but not CanFold.
02:16:50 <Lethalman> quicksilver, ah
02:17:15 <quicksilver> none of the standard structure classes let you create 'smaller objects' like filter does.
02:17:17 <Lethalman> quicksilver, but I wasn't arguing that
02:17:35 <mauke> hmm, mapping over an array in terms of foldr would be terribly inefficient
02:17:37 <Lethalman> quicksilver, I'm saying the opposite, if it CanFold it CanMap and CanFilter
02:17:49 <merijn> You can implement filter as a fold, no? Why can't you implement it as Foldable then?
02:18:04 <quicksilver> merijn: because the 'fold' you make is hard coded to produce lists.
02:18:18 <quicksilver> merijn: so you would need (:) and [] to be in a class.
02:18:19 <Lethalman> quicksilver, right
02:18:27 <quicksilver> if you want to produce 'same data type as you gave me' instead of list.
02:18:28 <Lethalman> quicksilver, but you can return a traversable maybe?
02:18:31 <Lethalman> depending on the caller context
02:18:32 <quicksilver> nope.
02:18:41 <quicksilver> traversable only lets you produce things 'the same size' as the input
02:18:45 <Lethalman> quicksilver, start with mempty then mappend
02:18:57 <quicksilver> right, if you add Monoid you can do it.
02:19:06 <quicksilver> but then you're always getting a very boring shape
02:19:08 <quicksilver> it's always linear
02:19:11 <Lethalman> ok
02:19:13 <quicksilver> ..so might as well be a list.
02:19:16 <merijn> quicksilver: I was thinking of "filter :: Foldable f => (a -> Bool) -> f a -> f a", still not possible?
02:19:27 <quicksilver> merijn: nope.
02:19:38 <quicksilver> merijn: Foldable gives you no tools to "make a new f"
02:19:39 <Lethalman> merijn, you don't know how to produce the output as I understood
02:19:42 <quicksilver> (for your output)
02:20:06 <quicksilver> except if that output is exactly the same size as the input
02:20:09 <quicksilver> (then you can use fmap)
02:20:11 <quicksilver> size + shape.
02:20:19 <quicksilver> but that doesn't sound very filter like.
02:20:34 <simpson> :t \p -> foldMap (\x -> if p x then [x] else []) -- quicksilver, it's possible
02:20:35 <lambdabot> Foldable t => (t1 -> Bool) -> t t1 -> [t1]
02:20:46 <quicksilver> simpson: that always produces a list.
02:20:50 <simpson> > let f p = foldMap (\x -> if p x then [x] else []) in f even [1..10]
02:20:52 <lambdabot>   [2,4,6,8,10]
02:20:59 <simpson> quicksilver: And filter always produces a list. What's the problem?
02:21:07 <mauke> simpson: ...
02:21:09 <merijn> simpson: We were discussing generalised filter
02:21:11 <quicksilver> the problem is we wanted to implement filter for other types.
02:21:28 <quicksilver> that would be the point of putting it in a typeclass.
02:21:41 <simpson> You moved the goalposts. I said originally only that I was pretty sure filter could be created from just foldMap.
02:21:56 <quicksilver> :)
02:21:58 <quicksilver> yup.
02:22:06 <M30W> Is there anything like an Either but works for different cases?
02:22:08 <shachaf> FSVO "filter"
02:22:08 <quicksilver> but that's ambiguous, unfortunately.
02:22:13 <simpson> (I'll admit that my lag makes the conversation awkward.)
02:22:20 <srhb> M30W: Different cases?
02:22:29 <M30W> srhb: North South East West
02:22:32 <shachaf> Oh, I see. I'm saying the same thing quicksilver was, or something.
02:22:40 <shachaf> Anyway instead of classy-prelude you should use lens.
02:22:47 <srhb> M30W: Not in base, can just make your own though.
02:22:59 <quicksilver> I say enough different things over time that, eventually, you're bound to say the same thing as me.
02:23:14 <srhb> M30W: It's very rare that you need such a thing though, are you doing it right :-)
02:23:25 <M30W> srhb: I don't know :)
02:23:41 <M30W> go 0 rooms North -> Just 1
02:23:49 <Lethalman> so in classy-prelude it might be possible to add instance (CanFold f, Monoid f) => CanFoo f
02:23:51 <srhb> M30W: Do you just need data Direction = North | South | East | West ?
02:23:56 <Lethalman> ?
02:24:02 <mauke> Lethalman: no
02:24:03 <M30W> srhb: I have that
02:24:05 <Lethalman> :S
02:24:14 <srhb> M30W: Then I don't understand what you wanted Either for.
02:24:31 <shachaf> Lethalman: Just like you can't add instance Monad m => Functor m
02:24:32 <M30W> Scratch that
02:24:43 <srhb> M30W: Perhaps you wanted Maybe Direction
02:24:57 <srhb> M30W: Or either SomeError Direction
02:25:02 <srhb> Either*
02:25:09 <M30W> srhb: with go/move, should I return (RoomID, Rooms) or just the number of the room requested ?
02:25:24 <srhb> No idea.
02:25:25 <M30W> (text adventure) :D
02:25:50 <merijn> M30W: Maybe you want a Zipper for movement?
02:25:51 <srhb> Doesn't sound like something you need to design around though, easy fix if your solution doesn't work out.
02:26:45 <M30W> Just (Room {rName = "", rDescription = "", rDirections = fromList [(North,1),(East,2),(South,4),(West,3)]})
02:26:50 <M30W> There is one room
02:27:00 * hackagebot safecopy 0.8.1 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.8.1 (DavidHimmelstrup)
02:27:22 <srhb> aWhy does a Room have a direction?
02:27:43 <M30W> srhb: So you can go that direction?
02:27:56 <srhb> Oh, it's the door.
02:28:05 <M30W> Btw, Directions = North | East | South | West | Up | Down
02:28:08 <srhb> What does the number on each "direction" mean then?
02:28:21 <M30W> srhb: Not doors but yea; think of a room as a scene
02:28:27 <merijn> srhb: The room it goes to, I think
02:28:39 <srhb> Aha.
02:28:42 <M30W> Yea.
02:28:47 <merijn> In which I stand by my suggestion of using a graph zipper instead
02:28:53 <shachaf> gripper
02:28:55 <srhb> Indeed.
02:29:06 <M30W> graph zipper?
02:29:25 <merijn> M30W: zipper for graphs instead of lists, there was a decent wikibook on them
02:30:05 <merijn> M30W: See http://www.haskell.org/haskellwiki/Zipper
02:30:14 <merijn> wikibook link is in the further reading there
02:30:22 <M30W> So.. Take my current room structure and use a graph ? I'm using Data.Map for both the Directions and Rooms
02:30:59 <M30W> I don't want a tree graph.
02:31:09 <merijn> M30W: Zippers are basically a nice way to have a data structure (like list or graph) and provide you a way to change the "current" node or move in multiple directions throughout the graph
02:31:23 <merijn> M30W: zippers aren't restricted to trees, they work on any graph
02:31:44 <M30W> merijn: And seemingly history strucutre throughout the adventure...
02:32:23 <merijn> The "history" view of zippers is a bit misleading
02:32:42 <M30W> Makes a back possible ?
02:32:47 <M30W> :P
02:33:01 <merijn> And only really works in trees. In graphs the notion of "back" or "history" doesn't make much sense, due to potential cycles
02:33:34 <M30W> fromList [(0,Room {rName = "", rDescription = "", rDirections = fromList [(North,1),(East,2),(South,4),(West,3)]}),(1,Room {rName = "", rDescription = "", rDirections = fromList [(South,0)]}),(2,Room {rName = "", rDescription = "", rDirections = fromList [(West,0)]}),(3,Room {rName = "", rDescription = "", rDirections = fromList [(East,0)]}),(4,Room {rName = "", rDescription = "", rDirections = fromList [(North,0)]})]
02:33:42 <M30W> Whoops didn't mean to send all 5 rooms
02:34:22 <merijn> M30W: A zipper is basically "active node + branches reachable from here" (i.e. the exits of your room), when you move east you "unzip" the east room and "rezip" the room you came from and add the zipped room as west exit for the new current room
02:34:23 <M30W> I have the movement dealt with; I have two lookups; one to select the room from the rooms given the current RoomID and Direction
02:35:08 <M30W> I'm not sure I follow.
02:36:06 <merijn> M30W: It's hard to explain without an example and I don't have time right now to hack one together
02:36:27 <M30W> :(
02:36:42 <M30W> But.. Basicly what I already have yea?
02:38:06 <merijn> No, your current approach is different. It'll work, but is perhaps less "nice", FSVO nice
02:40:22 <M30W> FSVO ?
02:40:39 <M30W> merijn:
02:40:52 <srhb> M30W: For some value of
02:41:11 <M30W> Oh
02:45:51 * M30W afk
02:52:00 * hackagebot hoogle 4.2.15 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.15 (NeilMitchell)
02:54:26 <quicksilver> merijn: FWIW I think that as part of natural programmer development you have to do it the manual way before you see the point of the zipper
02:54:47 <quicksilver> "trying to use a solution before you understand the problem"
03:03:51 <mSSM> Is it possible to qualify modules in ghci?
03:04:06 <mSSM> i.e. importing it `as <prefix' ?
03:04:14 <mikeplus64> import qualified Xyz as Zyx
03:04:44 <mikeplus64> that works in ghc 7.6.1, i don't remember for versoins before it
03:04:57 <mSSM> mikeplus64: that's when I load a file. I mean “:m +”
03:05:07 <mikeplus64> mSSM: it works in ghci
03:05:30 <mSSM> oh
03:05:32 <mSSM> cool!
03:06:14 <basdirks> how do we write `do { a <- string ";"; b <- manyTill anyChar (try newline); return $ a ++ b}' pf?
03:10:08 <basdirks> ah nvm: (++) <$> string ";" <*> manyTill anyChar (try newline)
03:15:22 <mSSM> mikeplus64: I am on ghc 7.6.1, and unfortunately `import qualified MOD as M' doesn't work :( It says “Failed to load interface for `R'” (when I qualify with R)
03:16:56 <merijn> quicksilver: I guess
03:24:29 <bitonic> is there a flag that enables only the default warnings?  I’m working with alex/happy files and I have -Wall set in cabal but I don’t want the warnings for the generated parsers to show up
03:25:23 <bitonic> ‘-w’ is a bit too much
03:25:59 <typoclass> bitonic: "-W" is documented as "enable normal warnings"
03:26:17 <bitonic> typoclass: oh, how did I skip that?  thanks
03:32:41 <wuttf> why can't I do type annotations on functions defined in let or where?
03:32:59 <shachaf> wuttf: It's a rare medical condition.
03:33:21 <typoclass> wuttf: try adding {-# LANGUAGE ScopedTypeVariables #-} at the top of your file
03:33:26 <wuttf> shachaf: You are having a funny day again?
03:33:33 <shachaf> typoclass: Huh? That's not related at all.
03:33:59 <shachaf> wuttf: Well, I'm not sure what to say. *I* can write type annotations on functions defined in let or where.
03:34:04 <TheRedMood> A union is list that can contain a element only once right?
03:34:19 <mauke> wuttf: have you tried a text editor?
03:34:21 <shachaf> TheRedMood: I've never heard that.
03:34:28 <wuttf> mauke: :DDDDDDD
03:34:29 <TheRedMood> So if there was a union of {2,3,4} and {2,3,4,5} it would end as {2,3,4,5}
03:34:29 <TheRedMood> ?
03:34:43 <typoclass> shachaf: not sure, may have misunderstood him. i'll come up with an example
03:34:50 <shachaf> TheRedMood: The word you're looking for is probably "set".
03:35:01 <TheRedMood> Ahh okay :)
03:35:03 <mauke> wuttf: (that is, your original question contains no useful information)
03:35:04 <shachaf> Union is an operation on sets.
03:35:06 <TheRedMood> Thanks :)
03:35:18 <bxc> Ineed scopedtypevariabels for this: x = let (q :: Double) = 7 in q
03:35:31 <wuttf> Hmm wait it works now. Wtf.
03:35:32 <bxc> which is what i interpret the original question to be
03:35:35 <mauke> bxc: no
03:35:44 <bxc> mauke: ...
03:35:45 <mauke> maybe pattern signatures or whatever it's called
03:35:58 <bxc> mauke: at least, ScopedTypeVariables makes it work for me.
03:36:02 <bxc> there may be a lesser one?
03:36:16 <shachaf> mauke: ScopedTypeVariables is what you're supposed to use now.
03:36:16 <mauke> > let q :: Double; q = 7 in q  -- of course, there's also this
03:36:18 <lambdabot>   7.0
03:36:20 <quicksilver> it used to be called PatternSignatures
03:36:20 <shachaf> PatternSignatures is deprecated.
03:36:24 <mauke> shachaf: hmm, I see
03:36:26 <quicksilver> but they bundled it into ScopedTypeVariables
03:36:28 <quicksilver> which was pretty odd
03:36:33 <quicksilver> since they're orthogonal concepts
03:36:44 <bxc> mostly ScopedTypevariables makes things work how I expect things to always work
03:36:45 <shachaf> But anyway wuttf was probably asking about the thing mauke said.
03:36:48 <quicksilver> but since they both seem sane and should both reasonably be enabled, I guess it doesn't matter.
03:36:57 <quicksilver> wuttf might just have had wrong indentation
03:36:57 <mauke> bxc: you're right
03:37:00 <quicksilver> who knows :)
03:37:14 <bxc> mauke: its also what GHC suggests I turn on
03:37:22 <shachaf> I hope forall gets into the standard.
03:37:24 <bxc> when i don't turn it on.
03:37:30 <mauke> > \(_ :: ()) -> ()
03:37:32 <lambdabot>   No instance for (GHC.Show.Show (() -> ()))
03:37:32 <lambdabot>    arising from a use of `M10387...
03:38:18 <shachaf> There used to be an old syntax that looked like f (x :: Int) (y :: Char) :: Int = ...
03:38:21 <shachaf> But that's gone.
03:38:27 <wuttf> quicksilver: a., Yeah, indentation b., I was reading code where all annotations in where/let were commented out
03:38:37 <hpaste> typoclass pasted “inline signatures” at http://hpaste.org/81463
03:38:46 <typoclass> here's what i meant earlier ^^
03:39:06 <shachaf> typoclass: Yes, but the question was about y :: Int; y = 321
03:39:12 <shachaf> And the answer is "it does work".
03:39:26 <wuttf> +1
03:39:42 <shachaf> Alternatively, wuttf's medical condition is intermittent.
03:39:47 <shachaf> The world may never know.
03:40:30 <mauke> heh, maybe lambdabot needs an excuse generator
03:41:57 <wuttf> My tardness never ceases to amaze me
03:42:48 <shachaf> Would people consider this JavaScript exercise trivial or a bit tricky? http://jsfiddle.net/Ttq5t/
03:43:47 <mauke> how do I know I've done it right?
03:43:49 <quicksilver> mauke: it could work by /msg'ing fsbot and relaying the result :)
03:44:16 <wuttf> shachaf: I can display an "a" in less lines :-P
03:44:27 <shachaf> mauke: My example there isn't that great because it doesn't use the values that promises yield.
03:44:52 <shachaf> It's supposed to show a, then show b after a second, then show c and done after a second.
03:45:17 <wuttf> Are you a teacher or sumthin
03:45:29 <mauke> wait, yield x = ($ x)?
03:45:33 <shachaf> Yes.
03:45:38 <mauke> y helo Cont
03:45:41 <shachaf> Yep.
03:46:25 <basdirks> shachaf: it's a bit tricky
03:46:54 <shachaf> But e.g. given a getLine promise and a putLine function that returns a promise, you could make function ask(s) { return putLine(s).then(function() { return getLine; }); }
03:47:02 * hackagebot hamlet 1.1.4 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.4 (MichaelSnoyman)
03:47:04 * hackagebot nerf 0.3.0 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.3.0 (JakubWaszczuk)
03:47:15 <shachaf> Which behaves a lot like IO actions, of course.
03:47:38 <shachaf> Anyway the point of this exercise is that this is tricky to write without types but trivial to write with types.
03:47:48 <shachaf> So I want to know whether the former is true.
03:47:49 <basdirks> well actually it's not tricky for a js developer
03:48:15 <shachaf> (By "trivial" I mean "djinn can do it".)
03:48:30 <mauke> I think it's very tricky
03:48:43 <basdirks> aga
03:48:44 <basdirks> aha*
03:50:34 <mauke> http://jsfiddle.net/Ttq5t/1/
03:50:36 <basdirks> well a junior js dev could do it, but I guess that isn't what you wanted to know
03:50:56 <mauke> the variable names certainly don't help
03:51:02 <shachaf> mauke: True.
03:51:06 <shachaf> My solution looked like Promise.prototype.then = function(k) { var orig_f = this.f; return new Promise(function(cb) { return orig_f(function(a) { return k(a).run(cb); }); }); };
03:51:17 <shachaf> OK, that's the same thing you ended up with.
03:51:41 <mauke> because I've already wrestled with Cont/ContT in Haskell :-)
03:51:46 <shachaf> Right.
03:51:53 <shachaf> @djinn-add data Cont r a = Cont ((a -> r) -> r)
03:52:00 <mauke> e.g. I know where the 'm b' part has to go, etc.
03:52:02 * hackagebot shakespeare 1.0.3 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.3 (MichaelSnoyman)
03:52:03 <shachaf> @djinn foo :: Cont r a -> (a -> Cont r b) -> Cont r b
03:52:03 <lambdabot> Cannot parse command
03:52:04 * hackagebot shakespeare-js 1.1.2 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.1.2 (MichaelSnoyman)
03:52:07 <shachaf> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
03:52:07 <lambdabot> f a b =
03:52:07 <lambdabot>     case a of
03:52:07 <lambdabot>     Cont c -> Cont (\ d ->
03:52:07 <lambdabot>                     c (\ e ->
03:52:07 <lambdabot>                        case b e of
03:52:09 <lambdabot>                        Cont f -> f d))
03:52:23 <shachaf> The JS code is pretty much that.
03:54:00 <mauke> I'd rename 'after' to 'wait' or something
03:54:01 <burbul> Is there an easy way to run my program (i.e. execute main in Main.hs and have the output go to stdout) through the interpreter, so I don't have to wait for it to compile?
03:54:18 <mauke> runghc Main.hs
03:54:27 <burbul> Thank you
03:54:32 <burbul> Thank you very much.
03:55:01 <shachaf> mauke: Sounds reasonable.
03:55:02 <shachaf> Or even sleep!
03:55:43 <shachaf> Writing JS in this style is completely impractical, of course, because of the syntactic noise if nothing else.
03:56:35 <shachaf> Maybe in some other untyped languages it'd be less awkward, and so easier to demonstrate.
03:57:02 * mauke resyntaxes
03:58:02 <merijn> burbul: You can even add "#!/usr/bin/env runghc" as the first line of your file to make the file directly executable using ./Main.hs
03:58:33 <typoclass> shachaf: fwiw, i gave up looking at the code after a minute or two due to the syntactic noise and general unclarity
03:59:12 <merijn> :t yield
03:59:13 <lambdabot> Not in scope: `yield'
03:59:37 <shachaf> yield :: IO (), of course.
03:59:44 <shachaf> (In Control.Concurrent.)
04:00:32 <mauke> behold: http://jsfiddle.net/Ttq5t/2/
04:00:38 <mauke> (warning: requires javascript)
04:02:42 <shachaf> That's a syntax error in my browser.
04:02:59 <mauke> sadly, most browsers don't support javascript[1]
04:03:16 <shachaf> Because they support ECMAScript rather than Mozilla's thing?
04:03:37 <mauke> [1] https://developer.mozilla.org/en-US/docs/JavaScript/New_in_JavaScript/1.8
04:07:33 <tdammers> the sad thing with javascript is that unlike with other languages, you are at the full mercy of the end-user's system as far as language version and features go
04:08:00 <bxc> thats the case with any language where you're supplying the source code...
04:08:14 <tdammers> bxc: not exactly
04:08:32 <bxc> its a difference of magnitude rather than happing/not happening i think?
04:08:46 <shachaf> mauke: http://jsfiddle.net/dj2Qa/
04:09:11 <tdammers> well, usually you get to at least specify what implementations your code is supposed to be run against
04:09:24 <shachaf> Actually I have this whole thing at http://slbkbs.org/toys/callfront.txt
04:10:32 <bxc> tdammers: this page best viewed in IE4.0?
04:10:37 <typoclass> shachaf: callfront, eh? everything but the callback, eh? cont for short, eh? =)
04:10:37 <bxc> at 640x480 resolution!
04:11:05 <typoclass> shachaf: nice =)
04:11:17 <bxc> it reminds me of when there was more unix in the world than just linux...
04:11:37 <tdammers> there's freebsd and solaris and a few more...
04:12:18 <bxc> its the horror of crossplatform programming.
04:12:29 <quicksilver> the most popular unix system in the world is windows.
04:12:35 <merijn> linux programmers are the worst
04:12:39 <tdammers> how is windows a unix system?
04:12:47 <merijn> tdammers: I think quicksilver means posix
04:12:52 <tdammers> mkay
04:12:58 <quicksilver> windows is POSIX certified as I recall
04:13:03 <bxc> i dunno what the posix stuff is like in windows these days? i only briefly looked at it about a decade ago...
04:13:07 <merijn> quicksilver: Only a small subset
04:13:10 <quicksilver> not sure if they have certified it for windows 8
04:13:13 <merijn> No pipes and sockets, for one
04:13:22 <shachaf> quicksilver: Not these days.
04:13:28 <shachaf> "Starting with Windows XP, the POSIX subsystem is not included as part of standard Windows distributions and has been replaced by Interix.[2]"
04:13:37 <tdammers> IIRC, windows *does* have pipes and sockets
04:13:43 <bxc> os/2 had pipes
04:13:52 <tdammers> you can't access them as conveniently through the filesystem, but they're there
04:13:54 <bxc> which makes me think win would
04:14:13 <merijn> tdammers: Not posix sockets
04:14:16 <quicksilver> anyhow this is offtopic. I was only making a boring point about certifications.
04:14:22 <merijn> tdammers: sockets aren't file descriptors in windows
04:14:22 <tdammers> merijn: no, not that
04:14:30 <bxc> being posix certified seems less useful than what IBM did with AIX which was "move towards being like linux where it was possible"
04:14:33 <tdammers> nothing is a file descriptor in windows :P
04:14:43 <shachaf> mauke: How's the regular expression library going? :-)
04:14:54 <merijn> tdammers: Obviously in a discussion about posix the remark "windows doesn't have sockets" should be taken to mean "windows doesn't have posix sockets"
04:15:23 <mauke> shachaf: haven't even started
04:15:25 <bxc> tdammers: but my original point was, I haven't seen anything that sticks out in my head that is a javascript portability issue that wasn't generally like something that you get/got in unix portability
04:15:34 <mauke> http://paste.scsys.co.uk/226384 - this could use some improvement
04:16:19 <tdammers> bxc: maybe... but javascript is high-level, and if I write relatively clean python code on Linux, I should expect it to run mostly unchanged on, say OS X
04:17:10 <merijn> bxc: I disagree, writing portable C is fairly easy. Easier than writing portable JS
04:17:15 <sunfun> good morning
04:17:23 <tdammers> merijn: indeed
04:18:06 <merijn> I say this as someone maintaining a decent size (50k+ LOC?) C codebase that runs on linux, OSX and FreeBSD (and presumably on any platform with a decently standards compliant C compilers + pthreads)
04:18:59 <tdammers> with C, at least, you don't have to make any performance concessions to get cross-platformness right
04:18:59 <zomg> Portable JS? Across browsers or what 'porting' does JS involve? =)
04:19:11 <tdammers> zomg: portable across JS implementations
04:19:23 <zomg> Ah, yeah then it can certainly be an.. interesting experience I suppose
04:19:30 <sunfun> would make sense to write an algorithm like rete in haskell?
04:19:39 <tdammers> what's more, it's a web developer's daily bread
04:19:57 <zomg> well with browsers it's not such a big deal these days
04:20:07 <zomg> I was thinking more like trying to write JS that runs in Node and say Rhino
04:20:08 <quicksilver> tdammers: merijn: JS/C cross platform compatibility to #haskell-overflow or elsewhere, pelase
04:20:12 <quicksilver> sunfun: yes, perfect sense.
04:20:59 <merijn> After googling rete I can't see why not
04:21:03 <sunfun> quicksilver: cool, i have to implement a project for an exam, an inference engine with a rete like algorithm
04:21:32 <sunfun> quicksilver: so do you think is it a good idea? Pattern matching using pattern matching ?
04:23:04 <merijn> Well, I guess a more important issue would be your current level of haskell skill, how much time you have and how big the project will be
04:23:11 <quicksilver> sunfun: there's no reason why not, haskell is a good language to implement algorithms in.
04:23:15 <mauke> preflex: excuse
04:23:16 <preflex>  no "any" key on keyboard
04:23:31 <shachaf> preflex: excuse
04:23:31 <preflex>  Software uses US measurements, but the OS is in metric...
04:23:35 <quicksilver> I'm not an expert on that details of rete or similar algorithms though.
04:25:10 <sunfun> quicksilver: thank you, i think it would be good to do something like that, just because I would make a pattern matching engine using a pattern matching language : )
04:38:21 <SantaClause> hi there
04:38:52 <Guest63367> ?
04:39:53 <typoclass> hello
04:46:34 <Peaker> hey, "ghc-core" doesn't seem to take -i as a cmdline option, how can I use it on a module in a project with multiple src dirs?
04:46:34 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
04:47:14 <shachaf> Peaker: Put command line arguments after the filename.
04:47:25 <shachaf> Alternatively use --
04:49:01 <Peaker> it seems to ignore my "-i" flags
04:49:32 <Peaker> oh, no space allowed after -i
04:52:13 <Peaker> shachaf, thanks..
04:52:38 <shachaf> That's a GHC thing.
04:52:42 <Peaker> interestingly, the profile hotspot name doesn't seem to exist in the output
04:54:14 <johnki> Hello all. When I show (-14) I get "-14", but if I show $ Just (-14) I get "Just (-14)". Where do those brackets come from? I understand why they're there, but if the Show instance of Integer isn't putting them there, what is the rule for derived Shows for ADTs about whether or not to insert them? Does it just looking for a leading hyphen? Or something else?
04:54:33 <mauke> :t showsPrec
04:54:34 <lambdabot> Show a => Int -> a -> ShowS
04:55:15 <shachaf> > showsPrec 6 (-14) ""
04:55:17 <lambdabot>   "-14"
04:55:18 <shachaf> > showsPrec 7 (-14) ""
04:55:20 <lambdabot>   "(-14)"
04:56:56 <johnki> mauke: thanks
05:02:37 <TheRedMood> Okay I have a question!
05:02:48 <TheRedMood> I am doing 25.2 / 3600
05:02:51 <TheRedMood> and it gives me out
05:03:03 <TheRedMood> 7.0e-3
05:03:14 <mauke> > 25.2 / 3600
05:03:15 <lambdabot>   7.0e-3
05:03:20 <TheRedMood> but going on a normal kalkulator it gives 0.007
05:03:38 <mauke> :t showFFloat
05:03:39 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
05:03:41 <TheRedMood> How should I interpit that number :0
05:03:48 <kranius> 7.0e-3 = 7.0 * 10^-3
05:03:49 <mauke> what do you mean by "interpit"?
05:03:55 <frerich> Interprete.
05:04:00 <TheRedMood> Yeah I know
05:04:02 <mauke> interpret?
05:04:09 <TheRedMood> But try doing that in ghc
05:04:13 <TheRedMood> ghci
05:04:15 <frerich> TheRedMood : Are you from Germany by any chance? I sense some germanisms.
05:04:21 <TheRedMood> Haha norwegian
05:04:28 <mauke> > showFFloat Nothing (25.2 / 3600)
05:04:28 <kranius> ie, 7.0e-3 = 0.007
05:04:29 <lambdabot>   No instance for (GHC.Show.Show GHC.Show.ShowS)
05:04:29 <lambdabot>    arising from a use of `M7...
05:04:33 <mauke> > showFFloat Nothing (25.2 / 3600) ""
05:04:34 <lambdabot>   "0.007"
05:05:21 <TheRedMood> What module is showFFloat part of?
05:05:41 <mauke> @index showFFloat
05:05:41 <lambdabot> Numeric
05:06:03 <TheRedMood> So what would i import
05:06:20 <kranius> Numerci
05:06:28 <kranius> Numeric*
05:20:06 <TheRedMood> Thanks
05:24:42 <shachaf> mauke: How would you phrase that exercise such that it doesn't seem so confusing?
05:24:55 <shachaf> I want it to be obvious what Promise should be but tricky to implement it.
05:29:56 <Peaker> ghc-core output is very unreadable still.. would be nice to normalize all the silly local var names to "a", "b", "c", etc
05:30:07 <shachaf> Peaker: Add -dsuppress-all to make it much more readable.
05:30:16 * shachaf needs to do some work on ghc-core
05:30:33 <Peaker> trying...
05:30:49 <shachaf> I took over maintaining it mostly to make in GHC 7.6-compatible, but I have a bunch of other ideas that would improve usability a lot.
05:30:54 <shachaf> Some of them are relatively easy.
05:31:41 <Peaker> --no-asm --no-cast makes the output empty?
05:32:02 <shachaf> Empty?
05:32:21 <shachaf> Doesn't seem empty to me.
05:32:31 <shachaf> Or what do you mean?
05:32:42 <Peaker> I get no output from it with any of these flags, apparently
05:32:56 <shachaf> Hmm.
05:33:00 <shachaf> Which version are you running?
05:33:00 <Peaker> ghc-core --no-asm Lamdu/Data/Expression/Infer.hs -w ghc-7.4.1 -i. -i../bottlelib/ -dsuppress-all >Infer.hs.core   ==>    no output and the file is empty
05:33:17 <Peaker> hard to tell, no --version flag
05:33:28 <shachaf> Good point. :-)
05:33:37 <Peaker> ghc-core-0.5.6 most likely
05:34:02 <shachaf> It's quite possible that it has to do with the >File
05:34:14 <shachaf> It's mostly meant for interactive use.
05:34:19 <mauke> shachaf: most of the operations have fairly simple prose explanations, but >>= doesn't
05:34:23 <shachaf> It's possible that HEAD will behave a little better there.
05:34:58 <Peaker> hmm.. it doesn't actually relate to the cmdline flags, maybe it relates to being run in an emacs shell buffer, rather than a terminal
05:35:09 <Peaker> yeah, that seems to be it
05:35:12 <shachaf> That's possible.
05:36:07 <shachaf> Peaker: What if you run it with PAGER=cat?
05:36:24 <shachaf> mauke: Right.
05:36:39 <shachaf> mauke: But most of the point of it is compositionality, so it's pretty important.
05:39:05 <Peaker> shachaf, then it seems to work even in the emacs shell buffer
05:39:34 <shachaf> Peaker: Do you think you could try ghc-core HEAD?
05:39:41 <Peaker> sure
05:39:43 * shachaf will look into this regardless.
05:39:59 <Peaker> https://github.com/shachaf/ghc-core ?
05:40:01 <shachaf> There are a few pager issues but HEAD might be a little better-behaved.
05:40:03 <shachaf> Yes.
05:41:39 <Peaker> still empty in emacs shell with no PAGER
05:42:45 <shachaf> OK.
05:43:03 <shachaf> Hmm.
05:43:26 <Peaker> the names are so horrible
05:44:46 <srhb> Shouldn't ./foo +RTS -p -- give me the time profile?
05:44:56 <shachaf> Does it not?
05:45:09 <srhb> No, I just get the RTS help output
05:45:20 <shachaf> Did you compile with -prof?
05:45:23 <srhb> Oh duh. I should read the help output.
05:45:24 <srhb> No.
05:45:24 <srhb> :P
05:45:35 <shachaf> Note: -prof is probably not enough.
05:45:40 <shachaf> You should read the user's guide on profiling.
05:45:54 <srhb> Alright, thanks.
05:47:03 <Peaker> debugging a large ghc-core output seems like a daunting, tedious task
05:47:16 <Peaker> (I'm having a 25% runtime degradation from ghc 7.4 to 7.6)
05:47:54 <aleator> What is the shortest way to express 'a value of type x, of which I don't care what it is?'
05:48:05 <merijn> aleator: undefined?
05:48:12 <merijn> :t undefined
05:48:13 <lambdabot> a
05:48:19 <merijn> :t (undefined :: Int)
05:48:20 <lambdabot> Int
05:48:29 <merijn> Alternatively, error
05:48:34 <srhb> shachaf: So why does it complain about not finding module Prelude when I try compiling with -prof ?
05:48:34 <aleator> merijn: That would get me 'undefined :: Int -> Bool -> String' which is bit verbose.
05:48:42 <merijn> :t error "Can't be arsed to type here"
05:48:43 <lambdabot> a
05:48:49 <shachaf> srhb: I guess you don't have profiling libraries installed?
05:48:59 <shachaf> Peaker: -dsuppress-all helps a lot. :-)
05:49:05 <merijn> aleator: Type inference will correctly infer the type for undefined
05:49:12 <merijn> :t undefined 1 1
05:49:14 <lambdabot> t
05:49:17 <srhb> Mumblemumble.
05:49:19 <aleator> merijn: No, the point is to express the type.
05:49:27 <merijn> :t undefined True 'c'
05:49:29 <lambdabot> t
05:49:32 <Peaker> shachaf, I enabled it, but for a large piece of code it still seems impractical.. basically inlining a huge module into one large function that's duplicated multiple times due to SPECIALIZE pragmas :(
05:49:40 <merijn> aleator: I don't think you can go much shorter?
05:49:43 <shachaf> Sure.
05:50:08 <shachaf> Generated code is awful, and the further removed from the actual code, the more awful.
05:50:16 <aleator> merijn: Best I can do is let x = undefined and then x :: String -> String.
05:50:35 <merijn> aleator: That's not really shorter than "undefined :: String -> String", though
05:50:40 <shachaf> Maybe start with profiling to find out what's really responsible for the degradation?
05:50:47 <Peaker> filing a ghc bug requires "minimizing" the example, but it's a pretty difficult thing to do
05:51:01 <Peaker> shachaf, I have a culprit, but it's inlined and its name disappears from the core
05:51:20 <shachaf> Does this still happen when you NOINLINE the culprit?
05:51:44 <merijn> shachaf: Wouldn't he need to know the culprit first to do that?
05:51:50 <aleator> merijn: Well 8 letters shorter is shorter if you have more than three on the same line
05:51:55 <shachaf> merijn: Well, he has one.
05:52:14 <merijn> shachaf: I interpreted that as "I see where things go wrong, I just don't know the name associated with that code"
05:52:35 <merijn> shachaf: i.e. he has the culprit, but doesn't know what it is called
05:52:41 <shachaf> Oh.
05:53:01 <shachaf> I guess that's a more sensible interpretation.
05:53:34 <Peaker> It is called "processRules"
05:53:38 <Peaker> but the inlining disappears it
05:53:42 <Peaker> I'll try to NOINLINE it and re-profile
05:53:43 <mSSM> I changed my program a bit to use repa, and now I get <<loop>> when executing it... any ideas what this might mean?
05:53:55 <mauke> mSSM: you've got an infinite loop
05:54:10 <mSSM> great
05:54:12 <mSSM> :)
05:54:25 <mSSM> mauke: Can I somehow tell haskell where precisely that loop is?
05:54:33 <mSSM> have haskell tell me*
05:54:49 <quicksilver> you've probably accidentally used recursion
05:54:49 <shachaf> @where rts-xc
05:54:49 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
05:54:57 <quicksilver> let a = ..... a .....
05:55:23 <Peaker> if repa is involved, likely that an array has become self-referential to compute its elements?
05:57:05 * hackagebot libsystemd-daemon 0.1.0.0 - Haskell bindings for libsystemd-daemon.  http://hackage.haskell.org/package/libsystemd-daemon-0.1.0.0 (CedricStaub)
05:57:07 * hackagebot hlibgit2 0.17.0.5 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.17.0.5 (JohnWiegley)
05:58:23 <simon> @pl concat $ replicate n s
05:58:24 <lambdabot> join (replicate n s)
05:59:26 <mauke> @pl \replicate -> concat $ replicate n s
05:59:26 <lambdabot> join . flip ($ n) s
06:03:43 <mSSM> What other option in the global cabal.config do I have to enable to allow for profiling?
06:04:01 <mSSM> I have library-profiling and executable-profiling = True
06:04:11 <mSSM> (or rather ... : True)
06:04:59 <johnw> i don't think you want executable-profiling always on
06:05:08 <johnw> but it's fine to always have library-profiling on
06:05:24 <shachaf> No real point to executable-profiling.
06:05:31 <shachaf> You can always recompile an executable, since nothing depends on it.
06:06:15 <johnw> also, library-profiling builds two libraries, but executable-profiling builds only one executable, so you only want to enable it if you actually need a profiled binary
06:09:03 <mSSM> Well, ok ... either way, I am building my program with `cabal-dev install --enable-executable-profiling' and I have `ghc-prof-options = -rtsopts -prof' and some others, but when I run the program with `+RTS -p' it tells me: `the flag -p requires the program to be build with -prof'
06:09:36 <johnw> to just to be sure: you're running the binary that's in cabal-dev/bin?
06:09:52 <mSSM> yes, ./cabal-dev/bin/BINARY
06:10:18 <johnw> hmm... i haven't seen that before, it always works for me
06:10:48 <mSSM> great :(
06:11:25 <mSSM> Is there another way to check if ghc really enables profiling during the run?
06:13:27 <shachaf> Not using cabal-dev works for me,
06:13:30 <shachaf> s/.$/./
06:13:52 <shachaf> You could try building and running it from dist/ rather than installing it.
06:15:27 <mSSM> I checked `cabal-dev install --enable-executable-profiling -v' for more verbosity, and it does not call ghc with the profiling flags!
06:16:46 <johnw> which executable is this?
06:16:55 <mSSM> I put the flags into the `ghc-options' line, and now profiling is enabled
06:17:05 * hackagebot embeddock 0.1.0.0 - In Haddock documentation embed the values from the same module  http://hackage.haskell.org/package/embeddock-0.1.0.0 (TakayukiMuranushi)
06:17:20 <mSSM> johnw: the one and only executable in the .cabal file of my project
06:17:39 <johnw> ah, do your project also have a library from which your executable is made?
06:17:46 <mSSM> no library
06:17:49 <johnw> ok
06:19:38 <Peaker> my 5 line profiling culprit function is 140 lines of incomprehensible Core :(
06:20:03 <mSSM> quicksilver: you were right, that's precisely what i did
06:20:05 <mSSM> thanks all!
06:20:45 <mSSM> Except that cabal-dev doesn't put the profiling in there.
06:20:47 <shachaf> Peaker: Ouch.
06:20:57 <mSSM> I don't like that - could that be because I use -git?
06:21:24 <Peaker> I guess I can give up on it and hope ghc improves in the long run...
06:21:36 <Peaker> our project is not geared towards any short term release anyway.
06:21:45 <Peaker> kind of a bummer that performance is so fragile though :-(
06:22:06 * hackagebot HTab 1.6.2 - Tableau based theorem prover for hybrid logics  http://hackage.haskell.org/package/HTab-1.6.2 (GuillaumeHoffmann)
06:22:29 <shachaf> This is in lamdu?
06:22:42 <shachaf> How easy is it to observe?
06:23:04 * shachaf could have a look.
06:23:14 <quicksilver> Peaker: some aspects of GHC optimisation are terribly fragile, yes :-(
06:23:36 <shachaf> Optimizing Haskell is hard. :·(
06:24:46 <Peaker> shachaf, it's a specific type inference benchmark
06:24:50 <Peaker> shachaf, not a gui thing
06:25:17 <Peaker> shachaf, make run_benchmark_infer
06:25:20 <Peaker> (in test/)
06:25:56 <Peaker> and   make run_profile_infer   to get a profile output of the same benchmark
06:26:42 <Saizan> no love for optimizing haskell?
06:27:20 <HugoDaniel> :)
06:27:29 <HugoDaniel> use the ffi
06:27:51 <mauke> ﬃ  -- optimized
06:28:10 <osfameron> ligatures--
06:28:17 <shachaf> @quote ligature
06:28:17 <lambdabot> shachaf says: U+006D   LATIN SMALL LIGATURE RN   [m]
06:28:21 <shachaf> Hmm.
06:28:22 <shachaf> @quote ligature
06:28:22 <lambdabot> shachaf says: U+FB03   LATIN SMALL LIGATURE FOREIGN FUNCTION INTERFACE [ﬃ]
06:28:23 <mSSM> that normal? ghc: panic! (the `impossible' happened)
06:28:32 <shachaf> mSSM: No, it's literally impossible.
06:28:43 <shachaf> Saizan: I wish. :-(
06:28:44 <Kostas> :D
06:29:13 <shachaf> Peaker: factorial is the benchmark in question?
06:29:16 * osfameron giggles at LIGATURE RN
06:30:50 <Peaker> shachaf, iirc it runs both that and euler1
06:31:22 <shachaf> I only see much of a difference in factorial.
06:31:40 <Peaker> shachaf, benchmark_Infer.hs and profile_Infer.hs both run both factorial and euler1
06:32:45 <Peaker> I see a large difference in both
06:33:02 <Peaker> 5->5.8(factorial), 7.4->8.9(euler1)
06:33:56 <Peaker> shachaf, what numbers do you get?
06:34:43 <shachaf> It turns out I wasn't running it with 7.4 at all.
06:34:49 <shachaf> GHC=... make vs. make GHC=...
06:36:00 <shachaf> Well, time to wait for criterion to install.
06:36:01 <shachaf> i love monoids
06:36:03 <shachaf> they are so easy
06:36:33 <amiller_> a monoid is a semigroup with an identity, a group is a monoid with an inverse
06:36:50 <amiller_> i've caught mself walking around repeating that to myself in the past couple weeks
06:37:04 <shachaf> monoids are so easy amiller_ :D
06:37:07 <shachaf> just ask Saizan :D
06:37:16 <mauke> what is the origin of this meme?
06:37:27 * `nand` 's best guess is from beaky
06:38:06 <Peaker> shachaf, btw, initially upgrading lens to 3.8 slowed it down significantly too, until I added INLINE pragmas to my lens compositions -- then it sped things up
06:38:21 <shachaf> Peaker: That's not good. :-(
06:38:47 <shachaf> Oh, compiling with ghc 7.4 prints out a monster error.
06:38:50 <fryguybob> To shachaf everything is literally easy.
06:39:00 <shachaf> No, it's just a warning.
06:39:05 <shachaf> Exciting arity
06:39:08 <shachaf> Do you get that too?
06:40:04 <byorgey> oh, exciting arity warnings
06:40:19 <byorgey> IIRC those are debugging messages accidentally printed as warnings?
06:40:30 <shachaf> Maybe they're not warnings.
06:40:36 <shachaf> But they're getting printed out.
06:40:50 <shachaf> Peaker: OK, I see a slowdown.
06:41:09 <byorgey> shachaf: yes, I mean it is a bug that they are printed.
06:41:17 <shachaf> Ah.
06:43:18 <Peaker> shachaf, yeah, exciting arity annoyed the hell out of me :) that's why I upgraded to 7.6, it only happens with new lens 3.8
06:43:34 <Peaker> shachaf, it's a debug print bug in 7.4.1
06:43:47 <shachaf> i love arities
06:43:50 <shachaf> they are so exciting
06:44:26 <Peaker> It's not just lots of output, it kills my emacs for like 30 seconds when it happens
06:46:08 <shachaf> Peaker: You should know that derived Functor/Foldable/Traversable instances are O(n^2)
06:46:24 <Peaker> shachaf, really? How come?
06:46:36 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/7436
06:46:40 <Peaker> How can the Functor instance be any different from what you write manually?
06:46:47 <Peaker> or do you mean compile-time?
06:46:51 <shachaf> Runtime.
06:47:07 <shachaf> It turns into e.g. fmap f (x:xs) = f x : fmap (\y -> f y) xs
06:47:14 <shachaf> So you get a big tower of eta-expansions.
06:47:47 <shachaf> Hopefully fixed in 7.6.2.
06:48:05 <johnw> why would it expand f into \y -> f y?
06:48:13 <shachaf> Reasons.
06:48:46 <`nand`> type checking or something?
06:49:01 <Peaker> shachaf, oh, awesome report by you, cool :)
06:49:32 <shachaf> Peaker: Yes, I found it while working on lens.
06:50:12 <amiller_> hm, i solved a problem by writing out a Traversable instance rather than letting it derive for me
06:50:22 <amiller_> how do i inspect what the derived solution was?
06:50:27 <shachaf> -ddump-deriv
06:52:06 * hackagebot sequential-index 0.2.0.1 - Sequential numbers that allow arbitrarily inserting numbers - for containers  http://hackage.haskell.org/package/sequential-index-0.2.0.1 (AristidBreitkreuz)
06:52:37 <shachaf> Peaker: Not that this will necessarily affect these benchmarks once, since they're probably walking small ASTs.
06:52:56 <shachaf> (And it applies equally to 7.4.1 and 7.6.1, of course.)
06:53:04 <shachaf> But you should be aware of it, since it looks like you're deriving a lot of instances.
06:53:52 <amiller_> oh phht, it wasn't even that the derived instance was bad
06:54:22 <amiller_> but that i just said "instance Traversable Tree" and provided no body, i thought that 'deriving' in front of that was optional, and somehow it typechecked and gave no warnings when running
06:54:56 <shachaf> amiller_: Yes, because of mutually recursive definitions. :-(
06:55:04 <shachaf> You have to override one of them, but it doesn't warn you.
06:55:19 <amiller_> ohhh. that actually makes sense to me
06:55:25 <shachaf> That's why I filed http://hackage.haskell.org/trac/ghc/ticket/7633 !
06:55:46 <shachaf> I should probably implement it too rather than just complaining.
06:56:20 <amiller_> i agree, it would have been jolly useful
06:56:24 <S11001001> amiller_: many classes document "minimum definition" for this reason, and have extra conditions, like (Using fmapDefault with a Traversable instance defined only by sequenceA will result in infinite recursion.)
06:57:04 <shachaf> S11001001: Ouch, that's an annoying condition that my proposal doesn't cover.
06:57:23 <shachaf> But oh well, you should probably be defining Traversable anyway.
06:57:49 <S11001001> shachaf: Can you generally cover x, y :: Int -> Int; x = y; y = x?
06:58:17 <shachaf> Generally?
06:58:28 <S11001001> fmapDefault being an ordinary function
06:58:38 <shachaf> Sure.
06:59:10 <shachaf> I know it doesn't cover it. It's just annoying.
06:59:16 <S11001001> Yeah.
06:59:54 <shachaf> Arguably sequenceA is nicer to define because it doesn't have a built-in fmap.
07:00:01 <S11001001> right
07:00:30 <shachaf> We did a lot of that in lens when we were trying to figure out types.
07:00:42 <shachaf> Puzzles like what's this class?
07:01:04 <shachaf> class Isoy g where iso :: Functor f => (s -> a) -> (b -> t) -> (g a -> f b) -> g s -> f t
07:01:07 <mroman> how dangerous is it to use unsafePerformIO with IORefs?
07:01:26 <shachaf> Depends on the context and on what you mean by dangerous.
07:01:32 <shachaf> (And on your GHC version.)
07:01:39 <shachaf> It's a very standard idiom for certain things.
07:01:40 <mroman> well
07:01:49 <mroman> turns out I need more state in my non-IO state monad.
07:02:00 <mroman> and I'm not keen on rewriting everything
07:03:05 <mroman> dangerous: What can go wrong with IORefs?
07:04:11 <mroman> I'm assuming if I use StateT to wrap the State Monad inside the IOMonad
07:04:19 <mroman> i have to rewrite everything too
07:04:32 <mroman> but I could try that
07:05:28 <geekosaur> this is where it's useful to use "type" for your monad, so you can rearrange it without having to change as many signatures
07:05:48 <mroman> I use type for my monad.
07:06:16 <mroman> However
07:06:19 <mroman> I'm using execState
07:06:24 <mroman> and that's pure code
07:08:12 <BlindRadish> Hello!
07:08:29 <shachaf> Peaker: Feature request: Don'tHaveParens rather than DontHaveParens
07:08:45 <shachaf> It's not so much that I care about punctuation as that I like putting it in identifier names just because I can.
07:10:50 <BlindRadish> I have a question - I want to shuffle a deck of cards, which is represented by a list of cards.  would it be better to take the head of the list and put it into a new list randomly, or should i take a random card from the old list and put it into a new list?  i could rotate the list until i reach a card...  what do you guys think?
07:11:34 <BlindRadish> I'm not stuck, I'm just wondering what's good practice.
07:11:45 <shachaf> I say construct a physics simulation of an actual deck of cards.
07:12:15 <BlindRadish> shachaf: nice
07:13:00 <BlindRadish> shachaf: what kinds of programs do you write?
07:13:16 <shachaf> Broken ones.
07:13:26 <BlindRadish> shachaf: nice.
07:14:38 <BlindRadish> why is this channel full of people who aren't actually here?
07:14:55 <`nand`> because we're waiting, silently
07:15:25 <BlindRadish> `nand`: for the big moment?
07:15:35 <s4msung> it's also called the "Idle RPG" game
07:15:57 <BlindRadish> s4msung: you ever play Progress Quest?
07:16:26 <EvanR> haha
07:16:38 <s4msung> ;D
07:16:39 <EvanR> i played progress quest so much it crashed
07:16:45 <EvanR> i guess due to int overflowing
07:18:04 <BlindRadish> EverR: dude! legendary.
07:18:13 <BlindRadish> EvanR: *
07:19:00 <EvanR> and so now i get paranoid about using int for anything
07:23:38 <BlindRadish> EvanR: lol
07:24:00 <int-e> EvanR: that's progress
07:24:21 <BlindRadish> i just don't work with unbounded concepts.
07:24:35 <BlindRadish> or if i do i use a magnitude more space than i need
07:24:48 <BlindRadish> potentially unbounded things, sure, but not in practice.
07:24:54 <EvanR> better watch out for lists and Maps capacity then
07:25:01 <BlindRadish> do explain!
07:25:14 <EvanR> or the maximum complexity allowed in an expression
07:25:38 <EvanR> things we would like to and usually take forgranted
07:25:41 <EvanR> for granted
07:25:46 <edwardk> mroman: you should rewrite it. dereferencing IORefs in pure code is going to blow up in your face sooner rather than later.
07:26:11 <shachaf> mroman: Oh, you meant *dereferencing* IORefs?
07:26:16 <shachaf> I thought you meant declaring global ones.
07:26:20 <shachaf> No, that's not such a good idea.
07:26:22 <EvanR> BlindRadish: no one thinks twice about how big a javascript object can be
07:26:30 <EvanR> or string
07:26:53 <EvanR> but double precision and ints get the short end
07:31:27 <mroman> I figured that I have to rewrite it.
07:31:47 <mroman> If I want to make it clean.
07:34:36 <Eduard_Munteanu> Is there a nicer syntax/combinators in 'lens' for constructing records from scratch? I mean, other than record syntax and using _-prefixed names.
07:34:57 <edwardk> Eduard_Munteanu: sadly no
07:35:06 <edwardk> _Foo # (x,y,z) is the closest we come
07:35:25 <edwardk> and thats basically the same as writing the constructor by hand
07:35:44 <Eduard_Munteanu> Hm, I see, thanks. I was hoping for some TH magic.
07:36:23 <johnw> i'd love see GHC 7.8 with LANGUAGE RecordLenses
07:36:37 <shachaf> I wouldn't.
07:36:38 <edwardk> johnw: i want 'exposed' first
07:36:47 <edwardk> and i'd rather have the theory bake more first
07:36:50 <shachaf> Lenses are not ready for it.
07:36:57 <johnw> ok, GHC 8.7
07:37:05 <applicative_> 'exposed' ?
07:37:35 <quicksilver> "monads exposed" (the blockbuster follow-up to the mindbending 'functors after dark')
07:37:55 <Eduard_Munteanu> I'd like TDNR + omitting _ from field names.
07:38:13 <Eduard_Munteanu> Not sure if I'm asking for ad-hoc polymorphism though.
07:38:35 <quicksilver> TDNR would be preferable to having my legs torn off by wild hyenas.
07:38:37 <quicksilver> but not much.
07:39:03 <functorsafterdar> 'type directed name resolution' sounds good for records but one senses it would have all sorts of horrible consequences?
07:39:26 <Eduard_Munteanu> Agda does it for constructors.
07:39:53 <applicative_> yeah I know, but there's a huge amount of control on what things can be in agda, God knows.
07:40:12 <applicative_> but I've never read anything about the theory of it
07:40:18 <ScriptDevil> Can someone explain when FlexibleInstances is needed and when it isn't?
07:40:42 <Eduard_Munteanu> Frankly, I'm unsure if there's a difference between TDNR and ad-hoc polymorphism.
07:41:00 <shachaf> ScriptDevil: Is http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances unclear?
07:41:29 <quicksilver> Eduard_Munteanu: we already have a pretty good mechanism for ad-hoc polymorphism in the form of typeclasses.
07:41:44 <quicksilver> No TDNR-proponent has yet explain to me why we should admit another one.
07:42:17 <quicksilver> especially if we lose even more of our tenuous grip on substitutability and principal typing.
07:43:14 <applicative_> newtype ZZ a b c = ZZ (a -> (b -> c)) ; instance Functor (ZZ () a) where   fmap f (ZZ x) () b = ZZ $ f $ x () b
07:43:19 <BlindRadish> how do i get the length of a list again?
07:43:24 <Eduard_Munteanu> :t length
07:43:25 <lambdabot> [a] -> Int
07:43:36 <BlindRadish> length [list]?
07:43:36 <Eduard_Munteanu> :t genericlength
07:43:38 <lambdabot>     Not in scope: `genericlength'
07:43:38 <lambdabot>     Perhaps you meant `genericLength' (imported from Data.List)
07:43:40 <Eduard_Munteanu> :t genericLength
07:43:42 <lambdabot> Num i => [b] -> i
07:43:54 <Eduard_Munteanu> bubaya: length list
07:44:08 <BlindRadish> thanks
07:44:17 <Eduard_Munteanu> Erm, BlindRadish, sorry.
07:44:38 <applicative_> ScriptDevil: I require FlexibleInstance for ZZ's Functor instance above, because I am trying to give one for the special case of ZZ () not ZZ a
07:44:43 <BlindRadish> ?
07:45:34 <applicative_> ScriptDevil: I could avoid this by giving an instance for ZZ a generally or wrapping newtype YY b c = YY (ZZ () b c)
07:45:59 <applicative_> grr, terrible typing as usual
07:46:10 <ScriptDevil> applicative_: Thanks!
07:46:12 <BlindRadish> shit i thought i could "take" half of a list without losing the other half. :(
07:46:38 <BlindRadish> it don't matter this is inefficient anyway.
07:46:50 <applicative_> @type span
07:46:51 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
07:47:20 <applicative_> @type splitAt
07:47:21 <lambdabot> Int -> [a] -> ([a], [a])
07:47:32 <FMKilo> anybody around to help?
07:48:00 <shachaf> There is only silence and some second-hand clothes.
07:48:11 <FMKilo> that's what I thought...
07:48:24 <FMKilo> might as well throw it out there...
07:48:30 * applicative_ only helps if it's homework
07:49:01 <BlindRadish> applicative_thanks
07:49:04 <EvanR> predatory homework doer
07:49:06 <FMKilo> I'm trying to get my irc bot to read a password from a file... I can identify if I have my password defined
07:49:10 <BlindRadish> applicative_: thanks
07:49:12 <EvanR> doing peoples homework for them so they dont learn anything
07:49:18 <EvanR> soaking up the exercises
07:50:05 <FMKilo> http://pastebin.com/hqfBfFS7 something like this...
07:50:09 <mauke> The paste hqfBfFS7 has been copied to http://hpaste.org/81472
07:50:24 <ScriptDevil> applicative_: I took some time to parse what you typed out. It is extremely clear now. So, am I right in saying that if I have a kind *->*, FlexibleINstances allows me to declare an instance for only an instantiation of that kind?
07:51:16 <quicksilver> FMKilo: your readFile looks fine.
07:51:29 <Sculptor> yo
07:51:31 <quicksilver> FMKilo: for some reason it thingks that the type of that do block is [] not IO.
07:51:32 <ScriptDevil> applicative_: By instantiation of the kind, I meant the kind restricted to a certain type without covering all types. Like a an instance for only [Int]
07:51:38 <quicksilver> FMKilo: what is the type of 'write' ?
07:51:54 <FMKilo> write :: String -> String -> Net ()
07:52:17 <quicksilver> FMKilo: what is 'Net' ?
07:52:40 <shachaf> I bet this is "roll your own IRC bot"
07:52:44 <FMKilo> the network interface?
07:52:59 <FMKilo> not exactly all my code...
07:53:04 <quicksilver> looks like roll your own IRC bot, yes
07:53:08 <quicksilver> I think you want
07:53:15 <quicksilver> liftIO (readFile ".password")
07:53:21 <shachaf> If I remember correctly roll your own IRC bot is outdated and not great.
07:53:22 <quicksilver> because that will lift readFile into the Net monad
07:53:23 <BlindRadish> how inefficient is ++?
07:53:31 <BlindRadish> should I be worried about it?
07:53:33 <quicksilver> although I still don't understand that error you pasted.
07:53:45 <FMKilo> thats what I'm saying..
07:53:53 <FMKilo> it confused the eff out of me
07:55:10 <FMKilo> http://pastebin.com/6R0m4Lt9
07:55:12 <mauke> The paste 6R0m4Lt9 has been copied to http://hpaste.org/81473
07:55:16 <Eduard_Munteanu> Bah, I really hate the order of arguments for run* functions.
07:55:54 <FMKilo> https://github.com/ProjectOpenCannibal/Hab/ if you want to look at what I don't really understand...
07:57:08 * hackagebot hlibgit2 0.17.0.6 - Low-level bindings to libgit2  http://hackage.haskell.org/package/hlibgit2-0.17.0.6 (JohnWiegley)
07:57:38 <shachaf> > (runState ?? 5) (modify (+1) >> get)
07:57:40 <lambdabot>   (6,6)
07:58:00 <shachaf> (??) is the "place holder" operator
07:58:36 <mauke> :t (??)
07:58:37 <lambdabot> Functor f => f (a -> b) -> a -> f b
07:59:04 <mauke> that's just flip
07:59:15 <shachaf> Right.
07:59:33 <FMKilo-bot> as I said, I can get auto auth while defining my password as a string, but I cannot seem to get it to work correctly with readfile.
08:00:00 <quicksilver> FMKilo: try: password <- io (readFile ".password")
08:00:02 <shachaf> > let f :: Int -> Int -> Int -> String; f = printf "i see %d and %d and %d." in (f 1 ?? 3) 8
08:00:04 <lambdabot>   "i see 1 and 8 and 3."
08:00:19 <shachaf> Unfortunately it has to be the next-to-last argument.
08:00:55 <johnw> > Just (+1) ?? 2
08:00:57 <lambdabot>   Just 3
08:01:02 <applicative_> ScriptDevil: sorry vanished, yes, FlexibleInstances lets you do e.g class ZZZZ a where zzzz :: a -> a; instance ZZZZ [Int] where zzzz xs = 1 : xs
08:01:40 <FMKilo> parse error on input <-
08:02:38 <quicksilver> FMKilo: ok well now your indentation is wrong or something. Paste the exact sourcecode you used to get that error.
08:02:49 <quicksilver> FMKilo: the whole Runbot.hs
08:02:53 <ScriptDevil> applicative_: Do I need FlexibleInstances when I have class ZZ a where zz:: a->a; instance ZZ Int where zz x = x+1?
08:03:22 <quicksilver> ScriptDevil: no, you don't. Why you care? FlexibleInstances is fine, use it always.
08:03:49 <FMKilo> http://pastebin.com/caCsmM6C
08:03:52 <mauke> The paste caCsmM6C has been copied to http://hpaste.org/81474
08:04:00 <ScriptDevil> quicksilver: I am trying to understand when it is needed. I think I got it now. :)
08:04:55 <quicksilver> FMKilo: ok, well, that's nonsense :)
08:05:03 <FMKilo> ..?
08:05:22 <quicksilver> FMKilo: password <- io (readFile ".password") is only sensible as part of a do-block
08:05:22 <FMKilo> as I said, not my code...
08:05:31 <quicksilver> which will later use the bound variable 'password'
08:05:35 <FMKilo> every time I try that..
08:05:46 <FMKilo> so what should it be?
08:06:01 <quicksilver> like in  your old code which said write "PRIVMSG" ( "nickserv something something" ++ password )
08:06:51 <quicksilver> you need to put this code where you're actually planning to send it to nicksev.
08:08:17 <BlindRadish> is "error" a keyword? i thought i saw it in code once
08:08:22 <applicative_> ScriptDevil: FlexibleContexts frequently goes in its train, instance ZZZZ [a] => ZZZZ (Maybe [a]) where zzzz = id
08:08:24 <otters> no, it's a function
08:08:35 <otters> BlindRadish: ^
08:08:45 <applicative_> ScriptDevil: here you are playing the same game in the context, i.e. before the =>
08:09:06 <applicative_> @type error
08:09:07 <lambdabot> [Char] -> a
08:09:17 <FMKilo> http://pastebin.com/3Dp7uEw0
08:09:19 <mauke> The paste 3Dp7uEw0 has been copied to http://hpaste.org/81476
08:09:42 <BlindRadish> oh i should use "maybe" to resolve this?
08:09:45 <applicative_> thanks mauke
08:10:02 <quicksilver> FMKilo: yes, that looks good to me.
08:10:06 <quicksilver> FMKilo: does it work?
08:10:14 <FMKilo> loading up now
08:10:28 <quchen> BlindRadish: error is an evil function you should avoid. Maybe/Either are much better for error handling.
08:11:15 <applicative_> @type Endo error
08:11:16 <lambdabot> Endo [Char]
08:11:46 <FMKilo> it works... :) thank you.
08:11:51 <quicksilver> FMKilo: :)
08:12:17 <FMKilo> http://pastebin.com/z9vvzu9v
08:12:21 <mauke> The paste z9vvzu9v has been copied to http://hpaste.org/81477
08:19:37 <BlindRadish> is 0 considered an even numbeR?
08:20:01 <shachaf> > even 0
08:20:03 <lambdabot>   True
08:20:05 <ScriptDevil> applicative_: :D Wonderful explanation. Thanks!
08:20:17 <tromp> what do you think even numbers are?
08:20:24 <BlindRadish> shachaf: thanks, man i feel dumb lol
08:20:39 <BlindRadish> tromp: numbers that can be divided by 2.
08:20:55 <BlindRadish> tromp: 0 can't technically be divided.
08:20:57 <tromp> or more simply, multiples of 2
08:21:21 <tromp> of course you can divide 0 by 2
08:21:34 <BlindRadish> tromp: depends on the definition, for example, some people don't consider 1 a prime number.
08:21:58 <tromp> that's quite unrelated
08:21:58 <startling> > 0 / 2
08:22:00 <lambdabot>   0.0
08:22:10 <ScriptDevil> BlindRadish: No it isn't. 0 can be divided by any number. 0/0 is indeterminate. But otherwise, it is fine.
08:23:08 <tromp> if you subtract an even number from another,  is the result even?
08:23:19 <tromp> any "technical" difficulty there?
08:24:30 <startling> I remember the teacher asking whether 0 was even or odd in 1st grade. One kid raised their hand and said, completely seriously, "even-odd".
08:24:47 <startling> kids are great.
08:25:07 <Eduard_Munteanu> Hm, looks like I can use Data.Map as an interval map for non-overlapping, adjacent intervals.
08:25:25 <int-e> startling: two is the odd prime (because it's even)
08:25:26 <Eduard_Munteanu> Using lookupLE and the like.
08:25:28 <zomg> startling: should've answered "no" or "yes", because that's always fun to do in an either-or question =)
08:25:38 <byorgey> there's no need to bring division into it anyway.  n is even iff there is some other integer k such that n = 2*k.
08:25:57 <byorgey> using that definition it's clear that 0 is even since 0 = 2*0.
08:26:03 <byorgey> s/other//
08:26:54 <byorgey> I guess tromp already pointed that out: "or more simply, multiples of 2"
08:26:56 <startling> byorgey, you're not adding anything constructive to this conversation
08:27:16 * shachaf thinks byorgey's addition was helpful.
08:27:37 <startling> shachaf, I don't know, it's not very intuitive.
08:27:38 <shachaf> Unless that was a pun on it being a nonconstructive definition?
08:28:10 <startling> 8)
08:28:14 <applicative_> "Haskell does not have full-fledged dependent types. For example, there is no way to create naturals as a subset of integers."  Heartbreaking
08:28:18 <PatrickRobotham> n is divisible by k if there exists an integer q such that n = q*k
08:28:26 <byorgey> it is too a constructive definition!
08:28:43 <PatrickRobotham> n is even if it is divisible by 2.
08:28:55 <Eduard_Munteanu> applicative_: seems like the wrong reason
08:28:58 <shachaf> PatrickRobotham, on the other hand, doesn't seem to be adding clarity.
08:29:12 <quicksilver> less meta conversation!
08:29:13 <quicksilver> more code!
08:29:16 <shachaf> byorgey: It's not as constructive as an algorithm for figuring out whether an integer is even!
08:29:32 <applicative_> Eduard_Munteanu: I was thinking it wasn't too great an advert for dependent types
08:29:40 <PatrickRobotham> shachaf: Check whether the last digit is 0,2,4,6 or 8.
08:29:53 <tromp> just check last bit
08:29:54 <BlindRadish> is there anyway i can tab freely in haskell?
08:30:04 <BlindRadish> the default whitespace kills me
08:30:05 <applicative_> NO
08:30:32 <BlindRadish> ugh.
08:30:37 <applicative_> your editor can manage it
08:30:38 <BlindRadish> i'm getting a parse error on |
08:30:51 * applicative_ is only pretending to dogmatism
08:31:09 <BlindRadish> i tried nesting |, is that why its complaining?
08:31:25 <BlindRadish> oh i think i got it!
08:31:39 <startling> BlindRadish: it's hard to tell from all the way over here!
08:31:47 <hpaste> bytbox pasted “Alternative to ScopedTypeVariables?” at http://hpaste.org/81480
08:32:02 <int-e> startling: you have to go back to telepathy 101.
08:32:17 <bytbox> is there any way to get around using -XScopedTypeVariables there?
08:33:15 <int-e> bytbox: that doesn't look sane - I doubt you'll ever be able to use the function 'c' there.
08:34:28 <startling> bytbox: you may be able to do it with asTypeOf
08:34:50 <startling> not that specific one, though
08:35:06 <startling> and yeah, that's going to get you into problems with ambiguity.
08:35:39 <hpaste> BlindRadish pasted “Coin -- not working” at http://hpaste.org/81481
08:35:58 <BlindRadish> help me figure out why its complaining?
08:37:02 <bytbox> startling: yuck. I think I'll go with Scoped, then...
08:37:03 <quicksilver> BlindRadish: it's complaining because that's illegal
08:37:05 <bytbox> int-e: what do you mean?
08:37:10 <bytbox> startling: thanks for the pointer, though
08:37:19 <quicksilver> BlindRadish: you can't nest |s like that
08:37:43 <bytbox> int-e: oh, never mind, I figured out what you mean
08:37:44 <int-e> bytbox: ghc will not guess the type of 'c' for you.
08:38:08 <startling> aren't guards only allowed for function definitions?
08:38:13 <int-e> bytbox: not without additional hints (a functional dependency on one of the A or B classes might do the trick, if it exists)
08:38:15 <quicksilver> startling: yes, of course.
08:38:18 <quicksilver> startling: jut not nested.
08:38:31 <bytbox> int-e: right. In my real code, I have such an additional hint - gotta fix my simplification
08:38:53 <startling> quicksilver: it's not the nesting that's his problem, then.
08:39:30 <startling> semantically, the problem is trying to put a guard immediately after something like "even size".
08:39:43 <startling> syntactically, I suspect the "where" is doing it.
08:39:46 <quicksilver> startling: that is what I was referring to by 'nesting |'
08:39:53 <quicksilver> startling: putting another | after a |.
08:40:31 <BlindRadish> quicksilver: i took them out, it still comlained.
08:40:39 <BlindRadish> quicksilver: i'll try again
08:40:40 <quicksilver> BlindRadish: the siplest thing might be just to use "if coin" for the inner level.
08:40:51 <hpaste> bytbox pasted “Alternative to ScopeTypeVariables (2)?” at http://hpaste.org/81482
08:40:56 <startling> quicksilver: "where" can only be placed at the end of a top-level definition iirc
08:40:59 <startling> errr
08:41:01 <startling> BlindRadish: ^
08:41:06 <bytbox> int-e: so I've got an extra data type, like so
08:41:13 <quicksilver> | even size = if coin then oll (take half outcomes) else roll (drop half outcomes)
08:41:33 <quicksilver> startling: not 'top-level'
08:41:36 <startling> BlindRadish, also, it looks like you think you're writing lisp
08:41:47 <quicksilver> startling: where can be attached to any equation, top-level or not
08:41:53 * bytbox wonders if this is typeclass-abuse
08:41:55 <quicksilver> but you're right that it must got at the end of the guards
08:41:58 <startling> quicksilver: oh, didn't know that, neat.
08:41:58 <quicksilver> not in between them.
08:42:04 <hpaste> applicative annotated “Coin -- not working” with “Coin -- not working (annotation)” at http://hpaste.org/81481#a81483
08:42:21 <applicative_> hm, didn't get rid of the excess brackets
08:42:39 <startling> BlindRadish: better!
08:42:58 <startling> BlindRadish: you need to indent everything after the "where"
08:43:14 <int-e> bytbox: ok. I can do that without scoped type variables, but it's ugly: define  aux :: A a c => C a b c -> a -> c; aux _ = f_a, then replace  f_a  by  aux <argument of c>
08:44:56 <quicksilver> applicative_: you also dropped the final otherwise.
08:44:58 <BlindRadish> startling: thanks but you took out the coin!  very important!
08:45:01 <quicksilver> applicative_: and broke the semantics.
08:45:18 <applicative_> did I, I couldn't follow the desired semantics
08:45:18 <startling> BlindRadish: oh, that was applicative_, not you.
08:45:37 <applicative_> BlindRadish: please ignore while I divine the desired semantics
08:45:44 <BlindRadish> startling: oh lol i thought it was you!
08:45:52 <startling> everyone is confused.
08:45:57 <BlindRadish> applicative_: thanks, no worries though
08:46:15 <BlindRadish> applicative_: i'm sure you have better things to do than give meh teh codez
08:46:17 <hpaste> quicksilver annotated “Coin -- not working” with “Coin -- not working (annotation)” at http://hpaste.org/81481#a81484
08:46:17 <bytbox> int-e: eh, ok; thanks. I'll probably stick with STV
08:46:33 <quicksilver> BlindRadish: annotated at the bottom
08:46:47 <quicksilver> only I lost the where clause? where did it go!
08:46:58 <startling> BlindRadish: what's "coin" do?
08:47:17 <BlindRadish> returns either true or false randomly
08:47:19 <hpaste> quicksilver annotated “Coin -- not working” with “Coin -- not working (annotation) (annotation)” at http://hpaste.org/81481#a81485
08:47:28 <startling> BlindRadish, uh
08:47:38 <quicksilver> BlindRadish: annotated *again* this time with the where clause back in.
08:47:50 <BlindRadish> the reason i do it this way instead of just picking a random number at random is because i have to generate one bit at a time to ensure entropy
08:47:50 <startling> BlindRadish, that's not going to work.
08:47:58 <applicative_> quicksilver: but the desired semantics fails the occurs check!
08:48:15 <startling> unless by "randomly" you mean "type 'True' or 'False' at random into the source code"
08:48:38 <quicksilver> well, yes, random numbers don't work the way you seem to think
08:48:44 <quicksilver> but, I was only fixing the *syntac*
08:48:46 <quicksilver> syntax
08:48:49 <startling> heh
08:48:55 <applicative_> oh coin is going to require a bit more work
08:49:02 <quicksilver> I'll leave you to ponder what the program should actually do.
08:49:29 <quicksilver> BlindRadish: I would recommend not using real TAB characters, too.
08:50:18 <BlindRadish> startling: lol it's just a prototype to etch out the bugs
08:50:39 <portnov> hi all
08:50:52 <BlindRadish> quicksilver: ah, so if i use space instead of tap, everything will be okay?
08:50:55 <typoclass> hello portnov
08:51:00 <startling> BlindRadish, your code will have to look a lot different in order to be pure.
08:51:00 <portnov> Q: is there any support for XML schema for xml-conduit?
08:51:12 <startling> BlindRadish: no, but it'll look nicer. :)
08:51:28 <BlindRadish> startling: i don't use monospace font
08:51:39 <BlindRadish> startling: can't see why anyone would.
08:52:41 <quicksilver> BlindRadish: well one reason to use a monospaced font is to make haskell layout line up.
08:52:43 <BlindRadish> quicksilver: * i don't use monospace font, can't see why anyone would.
08:53:04 <ScriptDevil> BlindRadish: Because it looks prettier? Try Inconsolata.
08:53:07 <quicksilver> if you don't wish to use a monospace font you'll have to be very careful to always start new layout constructs on a new line.
08:53:27 <quicksilver> so that means newline after every 'let', 'do', and 'of'
08:53:32 <typoclass> BlindRadish: i think it's just tradition. most programmers prefer monospace because most programmers always preferred monospace
08:53:39 <zomg> Not wanting to use monospace font sounds like something that graphics designers would say
08:53:41 <quicksilver> and, of course, you'll find it hard to read other programmers' code.
08:53:42 <zomg> :D
08:53:56 <BlindRadish> quicksilver: nah i can read anything like that fine and actually prefer the newline format
08:54:00 <startling> BlindRadish: it's going to be difficult to make things line up in Haskell
08:54:11 <quicksilver> BlindRadish: you won't always be able to.
08:54:18 <BlindRadish> quicksilver: didn't know that i /had/ to do it that way, and probably never would've figured it out, thanks!
08:54:23 <quicksilver> BlindRadish: there is haskell code which is ambiguous in a proportional font.
08:54:32 <hpaste> applicative annotated “Coin -- not working” with “Coin -- lamely parametrized” at http://hpaste.org/81481#a81486
08:54:45 <quicksilver> (ambiguous unless you have memorised the font-width table and have pixel perfect eyes, I mean)
08:56:07 <typoclass> BlindRadish: anyway, if you want to try out a monospace font just for fun, there's several pretty good (and free) ones these days. inconsolata is one, adobe source code is another
08:56:13 <applicative_> BlindRadish: is that something like the desired roll ^^^
09:02:58 <dino-> So, I have a mess I've made and need some cabal and package management advice..
09:03:15 <dino-> The mess is I've tried to do everything always global and have never so far used cabal-dev.
09:03:39 <portnov> ok, another question :)
09:03:43 <portnov> is HaXml alive?
09:03:47 <dino-> And today I have the predictable package mess that this gets eventually too after installing lots of stuff for various projects.
09:04:56 <dino-> so, what I'd like to do is reinstall ghc from scratch (this is ghc from the Arch Linux pacman repos), but the part I'm confused about is I'd like to make sure the global packages are gone as well.
09:05:06 <hpaste> applicative annotated “Coin -- not working” with “Coin -- now with moronic System.Randoml” at http://hpaste.org/81481#a81487
09:05:12 <dino-> is the only way really tracking down all the dirs by hand in /usr/local/... ?
09:05:51 <hpaste> “☃” annotated “Coin -- not working” with “Coin -- now with moronic System.Randoml (annotation)” at http://hpaste.org/81481#a81488
09:05:56 <typoclass> dino-: i think you could do ghc-pkg list to get a listing of the places where the packages are. i'd be surprised if it's more than about 3 directories
09:06:21 <applicative_> doesn't pacman get rid of them?
09:06:47 <dino-> typoclass: That's just the db, the actual files reside in /usr/local/lib/PackageName... dirs and also /usr/local/share and possibly share/doc
09:07:03 <dino-> applicative_: This is stuff installed with cabal-install
09:07:08 <dino-> Just the ghc was installed with pacman
09:07:49 <applicative_> ah if you get rid of the global package thingy it will be ok, like typoclass says
09:07:59 <typoclass> dino-: as far as i know it's not really recommended to use cabal to install things globally
09:08:03 <dino-> So, ok, looks like the way I've always done it. Track down the dirs in /usr/local/
09:08:06 <dino-> yeah
09:08:25 <dino-> Ok, so next question. Suppose I had a shiny new setup and I'm using cabal-dev for everything
09:08:51 <dino-> But I build something that has a binary that I would like placed in /usr/local/bin
09:09:03 <dino-> Can that be done?
09:09:10 <geekosaur> I would just symlink it there
09:09:23 <geekosaur> you could also copy it
09:09:37 <dino-> I see, so not part of cabal configure
09:10:01 <applicative_> dino-: it's just a matter of getting rid of something like /usr/local/lib/ghc-7.6.1
09:11:04 <dino-> applicative_: Right, but all of those installed with cabal install and --global have their own dirs outside of lib/ghc-7.6.1/
09:11:08 <applicative_> cabal install    --program-prefix=/usr/local or whatever??
09:11:18 <typoclass> dino-: yup, i think symlinking will be the clearest
09:11:58 <dino-> applicative_: Ah, I didn't know about that --program-prefix  Interesting
09:12:45 <applicative_> dino-: just install ghc in a local directory and put cabal-install in there too, then you trash everything with two uses of rm
09:15:17 <dino-> It's not that simple for removal. If you use cabal install --global MissingH, for instance, you end up with: /usr/local/lib/MissingH-1.2.0.0/ and /usr/local/share/doc/MissingH-1.2.0.0 and for some libraries you also get a dir in /usr/local/share and executables in /usr/local/bin
09:15:45 <dino-> But I will track all these down from the ghc-pkg list
09:15:45 <applicative_> yes, but why do cabal install --global
09:16:15 <dino-> Because I thought it was better for some reason, and partly because I do like the executables to be system-wide.
09:16:36 <applicative_> dino-: I agree the result with MissingH is pretty dreadful
09:17:23 <dino-> Thanks for helping, I will experiment with that --program-prefix
09:17:43 <dino-> it may be the best of both sides of this. Contained, user-specific messes and a globally installed binary
09:17:54 <applicative_> dino-: monochrom's little advice columns may be of some use, if you haven't seen them http://www.vex.net/~trebla/haskell/haskell-platform.xhtml http://www.vex.net/~trebla/haskell/sicp.xhtml
09:18:14 <typoclass> that seems like cabal is being a little weird. i'd have expected --global to create /usr/local/cabal/{lib,share,...}, similar to ~/.cabal/{lib,share,...}. i mean, it doesn't spam /home/dude/ with several different directories
09:18:42 <applicative_> dino-: right, that or symlinking, I think involving cabal install stuff with your package manager will just involve too much thinking
09:19:22 <applicative_> dino-: you might also inspect your ~/.cabal/config to see the options it's going by
09:20:30 <dino-> Will do, I do have to remove that user-install: False from it
09:21:28 <applicative_> typoclass: hm, my .cabal/config suggests it defaults to putting things in /usr/local ; while (--local) puts it in ~/.cabal
09:21:39 <dino-> typoclass: It's weird and it's not weird. I mean, stuff does get installed in these places by non-Haskell installations. Into /usr/lib/ for instance. There's a certain normality to it maybe?
09:22:14 <dino-> It's less weird if there were some automated uninstallation. But nobody has that. Not CPAN, or anything else.
09:22:27 <applicative_> dino-: anyway, you can adjust it to do what typoclass suggests
09:22:27 <geekosaur> linux distributions have a rule that all their packages install to standard locations (i.e. not /usr/local)
09:22:53 <applicative_> geekosaur: I think he's thinking of cabal install --global
09:23:18 <geekosaur> [29 12:21] <dino-> typoclass: It's weird and it's not weird. I mean, stuff does get installed in these places by non-Haskell installations. Into /usr/lib/ for instance. There's a certain normality to it maybe?
09:24:01 <applicative_> hm yes, I was thinking that was the reason cabal install --global uses
09:24:40 <applicative_> that is, its a theory about why cabal install --global defaults to /usr/local ?
09:25:42 <dino-> I could have mitigated this by setting a different prefix, like /usr/local/cabal  Ah well
09:25:50 <dino-> for everything, I mean
09:26:43 <typoclass> geekosaur: hm yeah, i dunno, i kinda like how ghc puts its stuff in /usr/lib/ghc-1.2.3/ and /usr/share/doc/ghc/ . similarly ~/.cabal/ . it doesn't seem to scatter haskell stuff into directories used by others. (arch linux here)
09:28:04 <dino-> Anyway, thanks again. Will get this figured out and try to build smarter with cabal-dev in the future.
09:28:36 <applicative_> dino-: yeah, that's what I was thinking. I never use --global, but maybe with that preference in the config file I wouldn't have a much reason not to
09:28:46 <applicative_> as much reason
09:29:49 <monochrom> who is calling my name in vain!
09:30:05 <applicative_> dino-: I don't know what the last word on cabal-dev, but notice that there are many forks on github, it hasn't been updated on hackage for some time
09:30:08 <monochrom> and yikes, GHC 7.6.2!
09:30:15 <applicative_> oh is it here
09:30:18 <ion> > (unwords . repeat) "monochrom"
09:30:22 <lambdabot>   "monochrom monochrom monochrom monochrom monochrom monochrom monochrom mono...
09:30:25 * monochrom downloaded 7.6.1 just yesterday!
09:31:25 * monochrom downloaded 7.6.1 just yesterday to test that template haskell [d|data D = D deriving Show|] works. was a bug in 7.4.2 and before
09:31:26 <applicative_> dino-: see now i'm going to remove my haskell universe with a few half-witted uses of rm
09:31:41 <aristid> monochrom: :P
09:32:10 <aristid> monochrom: just switched the irc tab cause my phone beeped to celebrate 7.6.2
09:32:18 <applicative_> hah
09:32:19 <monochrom> haha
09:32:33 <applicative_> is there any great advantage in 7.6.2 ?
09:32:52 <jang> it's at least 0.0.1 better
09:32:59 <monochrom> bug fixes
09:33:00 <aristid> applicative_: given that the bytestring shipped with 7.6.1 had a fatal bug, yes.
09:33:03 <applicative_> or was 7.6.1 seqfaulting on everything, but I just didn't notice
09:33:04 <glguy> applicative_: The typesystem is more sound
09:33:13 <glguy> applicative_: bytestring in 7.6.1 is broken
09:33:17 <monochrom> "A long-standing typechecker bug which allowed unsafeCoerce to be written has been fixed"
09:33:19 <applicative_> aristid: I did notice bytestring weirdness a couple times
09:33:20 <aristid> applicative_: it's also possible to build both unsafePerformIO and unsafeCoerce without extensions in 7.6.1
09:33:35 <monochrom> that is reason to NOT upgrade!
09:33:49 <aristid> oO
09:33:51 <applicative_> awesome, no way im upgrading
09:33:58 <aristid> no it isn't
09:34:02 <monochrom> why would anyone want fewer ways to obtain unsafeCoerce?! XD
09:34:22 <applicative_> "GHC will no longer exceed the maximum heap size"
09:34:34 <aristid> i should call the ops to detain these miscreants
09:36:42 --- mode: ChanServ set +o monochrom
09:36:57 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.2 http://v.gd/oXnqjU ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","If Hackage is down, try: http://hdiff.luite.com "]' by monochrom
09:37:12 <aristid> monochrom: now kick yourself for asking for more ways to unsafeCoerce, please
09:37:26 --- mode: monochrom set -o monochrom
09:39:13 <monochrom> Haskell Platform next version is likely to be associated with 7.6.2 then
09:39:41 <monochrom> basically "whatever GHC we have in February"
09:40:09 <aristid> monochrom: which is almost certain to be 7.6.2
09:40:21 <monochrom> "A bug which could cause segfaults when the -xc RTS flag is used has been fixed"
09:41:00 <monochrom> hahaha we abort your program while you abort your program so you have stacktraces to diagnose while you want stacktraces to diagnose
09:41:54 <monochrom> somehow this is the most hilarious list of bug fixes for a while :)
09:42:40 <monochrom> "A bug in the RTS, which could cause programs to hang or segfault just before they terminate, has been fixed"
09:43:08 <aristid> it's a nasty bug
09:44:53 <otters> looks like it's Quicktime for me
09:46:02 <otters> oops
09:50:26 <applicative_> dino-: I have my new ghc and am reinstalling my feeble world
09:51:03 <applicative_> Data.Text* is busy fusing
09:51:46 <typoclass> @remember applicative I have my new ghc and am reinstalling my feeble world
09:51:46 <lambdabot> Done.
09:51:52 <msxx> is there something like intersperse that takes a string?  doit "11" "foo"  => "f11o11o"
09:52:03 <S11001001> @ty intercalate
09:52:05 <lambdabot> [a] -> [[a]] -> [a]
09:52:28 <msxx> that won't work, it takes [[a]] not [a] as second parameter
09:52:53 <msxx> I guess I could make it [[a]] first though
09:53:01 <S11001001> > intercalate "11" (map (:[]) "foo")
09:53:02 <lambdabot>   "f11o11o"
09:53:57 <applicative_> > intercalate "ll" $ map return "foo"
09:53:59 <lambdabot>   "fllollo"
09:57:09 <johnw> yay, 7.6.2 is out!
09:57:11 * hackagebot functor-combo 0.3.3 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.3.3 (ConalElliott)
09:57:32 <Hermit> johnw: what's special about it?
09:57:48 <johnw> http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/release-7-6-2.html
09:58:06 <johnw> i think the first of those fixed bugs was even tweeted by edwardk recently
09:58:39 <plotr> how can I make hlint to ignore camel-case warnings?
09:58:39 <applicative_> somehow compiling highlighting kate with profiling seems a bit much
09:58:57 <applicative_> theres a configuration file plotr
09:59:20 <schellsan> what's the best way to import ByteString?
09:59:35 <schellsan> i've tried import Data.ByteString.Char8 as B
09:59:37 <johnw> schellsan: I use import ByteString (ByteString) ; import qualified ByteString as B
09:59:43 <mauke> import qualified Data.ByteString as B
09:59:56 <johnw> I try to avoid Char8
10:00:03 <Clint> import qualified Data.ByteString.Lazy as BL
10:00:05 <johnw> but if I do import it, I import it qualified as BC
10:00:14 <johnw> yeah, and BL for lazy
10:00:21 <johnw> and BLU for lazy unsafe, etc.
10:00:35 <plotr> applicative_: yepp, there's even command-line switch for that - the problem is that _values_ for that switch are not documented anywhere
10:00:56 <schellsan> i keep getting "Could not find module `Data.ByteString' It is a member of the hidden package `bytestring-0.9.2.1'."
10:02:07 <Hermit> johnw: what's wrong with Data.Bytestring.Char8?
10:02:11 <glguy> schellsan: You'll need to add bytestring to your cabal file's build-depends: section
10:02:27 <schellsan> ahhhhh
10:02:37 <johnw> Hermit: the fact that it ignores encoding
10:02:54 <Hermit> I see
10:02:58 <johnw> if you know that the bytestring is always plain ASCII data, then it's OK
10:03:13 <johnw> but Data.Text.Encoding.decodeUtf8 is a better way to make a string from a ByteString
10:03:36 <Hermit> hmm
10:03:53 <Hermit> now that you mention it, I was in need of such a thing some time ago when writing a bencode parser
10:04:37 <Hermit> since it mixes utf8 strings with binary blocks
10:04:52 <johnw> were you using attoparsec?
10:05:10 <zomg> Damn you Haskell
10:05:23 <zomg> Trying to use JavaScript and I just keep on writing ++ instead of +...
10:05:24 <zomg> lol
10:05:40 <typoclass> zomg: missing types yet?
10:05:55 <johnw> i found a website yesterday that explores category theory using javascript
10:05:57 <johnw> it was a bit surreal
10:06:05 <Hermit> johnw: no, it was a pet parser. It was one of my first attempts at parsing something in haskell. It had 4 mutually recursive functions or so. Not even state monad...
10:06:11 <typoclass> johnw: D.Text.E.decodeUtf8 is better how?
10:06:12 <applicative_> plotr: I'm defeated looking at the source.  I know I've done it in the past
10:06:24 <johnw> typoclass: in that it decodes UTF-8 :)
10:07:11 <plotr> applicative_: I've tried to copy-paste annotation pragmas from hlint docs but they seems to have zero effect on hlint
10:07:16 <donri> mm_freak: how's formwire coming along
10:07:55 <Hermit> zomg: so you can still write javascript without choking? That's really something
10:08:00 <typoclass> johnw: er right :) but what does D.Text do better than D.ByteString's utf8 decoding function? except that you sometimes need a Text, not a String, for some reason
10:08:05 <mroman> @hoogle Matrix
10:08:05 <lambdabot> Graphics.Rendering.OpenGL.GLU.Matrix module Graphics.Rendering.OpenGL.GLU.Matrix
10:08:05 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans class Matrix m
10:08:05 <lambdabot> Graphics.Rendering.OpenGL.GL.CoordTrans matrix :: (Matrix m, MatrixComponent c) => Maybe MatrixMode -> StateVar (m c)
10:08:14 <mroman> @hayoo Matrix
10:08:14 <lambdabot> Unknown command, try @list
10:08:30 <Hermit> zomg: I'm procrastinating like crazy when I got to do js. Actually, try to avoid it by any means.
10:08:31 <johnw> typoclass: I've never used B's UTF-8 decode, I thought he was just unpack.  I guess I've never using Strings with ByteStrings much
10:08:39 <plotr> found it! hlint -i "Use camelCase" hask_file.hs does the trick :)
10:09:45 <mroman> Is there a recommended matrix package?
10:09:54 <applicative_> HLint.Dollar - suggests the replacement a $ b $ c with a . b $ c. This hint is especially popular on the #haskell IRC channel.
10:09:57 <mroman> which supports multiplication/addition etc.
10:10:24 <johnw> mroman: hlearn, linear, hmatrix
10:10:48 <johnw> i think hmatrix uses OpenBLAS
10:12:09 <mroman> thx
10:12:14 <mroman> I'll look at hmatrix.
10:14:33 <mwatson> hi everyone
10:14:44 <arbn> mwatson: Hi.
10:15:14 <mm_freak> donri: see #happs
10:16:02 <applicative_> mroman: there is of course repa, but I guess it comes under the heading of Experimental still?
10:16:49 <applicative_> mroman: I notice the tutorial has kindly been updated for the new version http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial
10:17:24 <spoonbadger> hello everyone, sorry to join-and-question but does anyone have any interesting links to reading related to cfg grammars for parsing simple functional languages?
10:17:31 <spoonbadger> apart from the SJP book which i am working through
10:18:03 <spoonbadger> or possibly names of freenode channels more related to functional compiler design
10:18:17 <schellsan> okay - that seemed to work though now i'm struggling with the type checker wanting "Data.ByteString.Internal.ByteString"
10:18:31 <schellsan> instead of Data.Bytestring?
10:18:31 <applicative_> #ghc for example?
10:18:49 <basdirks> is SJP the Dual of SPJ?
10:19:00 <spoonbadger> hmmm. that would be an obvious one, facepalm in progress
10:19:00 <applicative_> schellsan: every strict bytestring has that type
10:19:03 <spoonbadger> sorry, spj
10:19:05 <basdirks> (I learned this joke from shachaf)
10:19:10 <arbn> spoonbadger: Which SPJ book?
10:19:17 <spoonbadger> "Implementation of..."
10:19:40 <schellsan> applicative: huh, i'm using pack "somestring", and the typechecker is telling me it can't match the type...
10:19:50 <schellsan> is there a gotcha here i'm missing?
10:20:08 <applicative_> schellsan: so maybe  you are using lazy bytestring?
10:20:08 <hpaste> plotr pasted “unix socket” at http://hpaste.org/81492
10:20:21 <applicative_> and it wants strict, or reciprocally
10:20:29 <typoclass> schellsan: have you tried Data.ByteString.Lazy instead of Data.ByteString ?
10:20:32 <plotr> any ideas why such a basic thing is not working?
10:20:42 <schellsan> it wouldn't say explicitly?
10:21:04 <plotr> perhaps there's simpler interface to work with unix sockets from haskell?
10:21:36 <arbn> spoonbadger: There's also "Implementing Function Languges: A Tutorial" by SPJ, which has the syntax of the Core language.
10:21:47 <arbn> Functional*
10:22:15 <spoonbadger> arbn: is that a book or a paper? If the latter I think might actually have a copy of that in the to-do folder :D
10:22:55 <applicative_> plotr: Fd's are wrapped newtype Fd = Fd CInt
10:22:57 <arbn> spoonbadger: It's about 300 pages and has an index... I'd count that as a book.
10:23:00 * arbn shrugs.
10:23:08 <spoonbadger> definitely book territory, shall go a searchin'
10:23:10 <spoonbadger> thank you!
10:23:26 <mroman> hm
10:23:31 <mroman> hmatrix on windows
10:23:34 <schellsan> when i import Data.ByteString.Lazy (pack) it complains "Couldn't match `Data.ByteString.Internal.ByteString`"
10:23:36 <mroman> not so good.
10:23:48 <mroman> ah well.
10:23:51 <plotr> applicative_: could you point to documentation or example?
10:24:01 <mroman> I can implement matrix multiplication by hand with lists.
10:24:08 <mroman> It's not performance critical or anything.
10:24:17 <johnw> mroman: at the very least use Data.Vector
10:24:20 <applicative_> plotr: Fd fd <- openFd "/tmp/mysocket" ReadWrite Nothing defaultFileFlags
10:25:08 <schellsan> maybe i'm just using it completely wrong?
10:25:22 <johnw> schellsan: that error makes you are mixing strict and lazy bytestrings somehow
10:25:22 <plotr> applicative_: thanks, what should I import to make this work?
10:25:22 <applicative_> mroman: use repa, it'll install just fine on windows (uh, maybe?)
10:25:55 <schellsan> i guess i'll look at this library's source to see what it is using?
10:26:39 <hpaste> typoclass pasted “Network.Socket example” at http://hpaste.org/81493
10:27:01 <typoclass> plotr: ^^ this code has worked for me in the past
10:27:36 <schellsan> johnw: the lib is doing "import qualified Data.ByteString.Char8 as B"
10:27:44 <plotr> typoclass: thanks a lot!
10:27:50 <schellsan> johnw: though when i do that i get the same error...
10:27:58 <hpaste> applicative annotated “unix socket” with “unix socket ??” at http://hpaste.org/81492#a81494
10:28:04 <typoclass> (i was connecting to the socket that the wpa_supplicant daemon is offering. it's called /var/.../ctrl_interface)
10:28:08 <typoclass> plotr: you're welcome
10:28:29 <applicative_> plotr: see paste ^^^
10:28:49 <schellsan> johnw: oops! new error... Couldn't match expected type `B.ByteString'             │Prelude Data.ByteString.Char8> pack "aoeusnth"                                       2 ||             with actual type `[Char]'
10:29:00 <schellsan> shoot - damn tmux...
10:29:07 <applicative_> plotr: a :: IO (Foreign.C.Types.CInt, Socket)
10:30:02 <plotr> applicative_: thanks, indeed - I've missed import System.Posix.Types
10:32:29 <schellsan> i got around it by using OverloadedStrings...that's not really a solution to the problem though
10:33:15 <johnw> OverloadedStrings is the one extension I use in every module
10:33:41 <typoclass> johnw: dude
10:33:52 <johnw> typoclass: yeah?
10:34:41 <typoclass> johnw: erm, was just expressing surprise
10:34:48 <johnw> at using OverloadedStrings?
10:35:13 <typoclass> johnw: yeah, i mean why do you use it so often? you use Text all the time?
10:35:26 <johnw> i use text and bytestring
10:35:37 <johnw> I like "foo" becomes whatever it needs to be
10:35:53 <johnw> and occasionally I need String (with Debug.Trace.trace)
10:36:02 <arbn> I take it that johnw is a web developer, or something? All web programming tends to use Text, because you're processing large HTML+CSS+JS documents.
10:36:14 <johnw> no, I am not a web developer
10:36:19 <arbn> Oh. OK.
10:36:50 <typoclass> right, that's handy then. i was getting annoyed the other day when http-conduit wanted me to convert things to ByteString a lot
10:38:58 <typoclass> i once made an OverloadedStrings instance that let me write shellscriptish stuff like main = do "ls something" ; "ps ...". if you make a mistake, the error messages that ghc produces get WAY funky
10:41:09 <conal> I'm looking for a functor-level variation of the Show class, with methods like "showF :: Show a => f a -> String". I sometimes roll my own, but maybe someone already has one on Hackage. Anyone such of such a class?
10:42:16 <johnw> conal: it just appends all the Shows?
10:42:56 <johnw> > foldMap show [1,2,3]
10:42:58 <typoclass> conal: it shows the stuff 'inside' the functor? how does it get at them?
10:42:58 <lambdabot>   "123"
10:43:04 <conal> johnw: no. it's a class. instances will do whatever rendering they want.
10:43:16 <johnw> ah, I see
10:43:47 <johnw> conal: http://hackage.haskell.org/packages/archive/fixplate/latest/doc/html/Data-Generics-Fixplate-Base.html#v:showF
10:43:53 <conal> it's useful for constructions that take functors as parameters and want to define a Show instance.
10:44:02 <binroot> Hey guys, I've posted lecture 3 of Intro Haskell here: http://shuklan.com/haskell
10:44:13 <binroot> It covers Types and Typeclasses
10:44:21 <typoclass> conal: hm ok
10:44:24 <conal> would be unnecessary if we had universally quantified constraints: (forall a. Show (f a)) => Show ...
10:44:25 <johnw> hmm.. that's too specific
10:44:32 <FMKilo>  okay, I was in here earlier.. I had some help getting my bot to read my password from a file.. but now it doesn't send the message to nickserv to auth...
10:44:45 <sclv> > 12 `div` negate 1
10:44:47 <lambdabot>   -12
10:44:56 <sclv> > negate 12 `div` negate 1
10:44:58 <lambdabot>   12
10:45:01 <conal> johnw: sweet. looks like what i want.
10:45:10 <FMKilo> http://pastebin.com/FvkrU56E
10:45:11 <sclv> (minBound :: Int) * negate 1
10:45:16 <mauke> The paste FvkrU56E has been copied to http://hpaste.org/81495
10:45:19 <sclv> > (minBound :: Int) * negate 1
10:45:21 <lambdabot>   -9223372036854775808
10:45:28 <sclv> > (minBound :: Int) `div` negate 1
10:45:28 <johnw> conal: also see http://hackage.haskell.org/packages/archive/data-treify/0.3.3/doc/html/Data-Reify-TGraph.html
10:45:30 <lambdabot>   *Exception: arithmetic overflow
10:45:33 <sclv> doh!
10:45:55 <johnw> but I'm not sure either is sufficiently general for what you were asking for
10:46:01 <conal> johnw: thanks. oh! it's one of mine.
10:46:05 <ion> fmkilo: You may have forgotten to paste the error message.
10:46:05 <johnw> haha :)
10:46:10 <FMKilo> http://pastebin.com/FvkrU56E
10:46:11 <mauke> The paste FvkrU56E has been copied to http://hpaste.org/81495
10:46:12 <sclv> i'm of two minds if this is something we should fix or not
10:46:14 <FMKilo> there is no error
10:46:50 <ion> Why is there a space between : and identify?
10:47:10 <FMKilo> good question
10:47:29 <FMKilo> it shouldn't matter tho
10:48:12 <FMKilo> nevermind, I think I got it..
10:48:14 <FMKilo> my mistake
10:49:47 <FMKilo> Thanks anyway
10:50:25 <FMKilo-bot> I
10:50:31 <FMKilo-bot> I appreciate your help sirs
10:50:52 <ion> You should abstract the various kinds of commands (such as PRIVMSG) into functions. There should be just a single place that handles the formatting of, say, the PRIVMSG command.
10:50:52 <FMKilo> I am currently having a problem tho
10:51:08 <conal> johnw: how did you find those ShowF classes?
10:51:11 <johnw> interesting error from GHC: internal error: PAP object entered!
10:51:19 <johnw> conal: i queried my private Hoogle for "showF"
10:51:30 <conal> johnw: oh, nice. :)
10:52:10 <johnw> yes, I like having a more complete search base; I just wish it would put results for which local documentation exists always at the top of the list
10:53:20 <FMKilo> I cannot seem to make my bot respond via private message only.. How would I manage this ?
10:53:39 <FMKilo> The source is located : https://github.com/ProjectOpenCannibal/Hab/
10:53:47 <sclv> hayoo found it too
10:54:07 <sclv> > (minBound :: Int) `div` negate 1
10:54:08 <lambdabot>   *Exception: arithmetic overflow
10:54:16 <sclv> seriously y'all, this doesn't bother you?
10:54:35 <typoclass> fwiw, hayoo also fairly quickly finds data-treify ... http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:showF
10:55:36 <conal> typoclass: ah. i didn't hang in long enough with hayoo
10:55:49 <johnw> i keep forgetting hayoo exists
10:56:27 <PolishDemon> hey all. can someone help me understand how to interpret something?
10:56:44 <typoclass> i think its user interface is somewhat weird, but a plus is that it searches everything and the dog
10:56:44 <PolishDemon> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]] -- not quite sure how to read this…
10:57:08 <byorgey> PolishDemon: what is zipWith' ?
10:57:18 <sclv> is also gotten somewhat smarter about type signatures
10:57:19 <sclv> a
10:57:26 <sclv> at least w/r/t/ alpha-equiv
10:57:27 <Peaker> shachaf, was away, yairchu (codeveloper) will probably dislike Don'tHaveParens :)
10:57:29 <PolishDemon> exactly what default zipWith is
10:57:46 <byorgey> PolishDemon: ok.  So do you understand what zipWith does?
10:57:50 <PolishDemon> takes a func, applies it to two parameters, concat'd as list
10:57:55 <PolishDemon> byorgey: yep
10:58:25 <byorgey> PolishDemon: so, we can just work out what that does by steps.
10:58:31 <Peaker> > zipWith (+) [1,2,3] [100,200,300]
10:58:33 <lambdabot>   [101,202,303]
10:58:40 <typoclass> @type zipWith
10:58:41 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
10:58:55 <conal> @type zipWith.zipWith.zipWith
10:58:57 <S11001001> @hoogle zipWith
10:58:57 <lambdabot> (a -> b -> c) -> [[[a]]] -> [[[b]]] -> [[[c]]]
10:58:57 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
10:58:57 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
10:58:57 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:59:03 <byorgey> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]] = [ zipWith' (*) [1,2,3] [3,2,2], zipWith' (*) [3,5,6] [3,4,5], ... ]
10:59:09 <typoclass> @type zipWith (*)
10:59:11 <lambdabot> Num c => [c] -> [c] -> [c]
10:59:14 <byorgey> PolishDemon: does that step make sense?
10:59:22 <S11001001> @hoogle class Zip
10:59:23 <lambdabot> No results found
10:59:35 <byorgey> it applies zipWith' (*) to each pair of sublists
11:00:46 <PolishDemon> byorgey: not quite sure i'm understanding, though. it's the second call to zipWith' that gets me.
11:00:58 <PolishDemon> high order funcs are confusing as hell to me right now :\
11:01:17 <FMKilo> https://github.com/ProjectOpenCannibal/Hab/commit/1e19f4f5161b50123efe3c773a78049e30153b35 anybody understand this?
11:01:25 <BlindRadish> is it legitamate to type list `length`?
11:01:54 <byorgey> PolishDemon: I'm suggesting that to start you not try to "understand" and just try to work out how it is evaluated.
11:02:37 <byorgey> PolishDemon: zipWith g [a,b,c] [d,e,f] = [g a d, g b e, g c f],  right?
11:02:45 <BlindRadish> cuz yoou can infix stuff like `xor`
11:02:57 <PolishDemon> byorgey: that's what i meant by "understand" i can't seem to wrap my head around what exactly is happening.
11:02:58 <PolishDemon> yes
11:03:11 <typoclass> PolishDemon: have you seen the two "@type" commands i wrote? (zipWith' (*)) is fixing the first argument, while leaving the other two arguments still to be determined
11:03:16 <byorgey> so we just apply that same pattern, but where  g = zipWith' (*), a = [1,2,3], and so on
11:03:52 <lispy> > zipWith (zipWith (*)) [[a,b,c],[c,e,f],[b,c,d]] [[c,b,b],[c,d,e],[e,d,c]]
11:03:53 <lambdabot>   [[a * c,b * b,c * b],[c * c,e * d,f * e],[b * e,c * d,d * c]]
11:03:59 <byorgey> and then we get what I wrote above:
11:04:02 <byorgey> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]] = [ zipWith' (*) [1,2,3] [3,2,2], zipWith' (*) [3,5,6] [3,4,5], ... ]
11:04:14 <PolishDemon> ah!
11:04:15 <FMKilo> > zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]] = [ zipWith' (*) [1,2,3] [3,2,2], zipWith' (*) [3,5,6] [3,4,5], ... ]
11:04:16 <lambdabot>   <hint>:1:77: parse error on input `='
11:04:38 <lispy> equational reasoning FTW
11:04:50 <lispy> with a huge assist from byorgey
11:04:54 <FMKilo> I just wanted to try lambdabot
11:04:59 <PolishDemon> byorgey: thanks :D getting a handle on how exactly it's being evaluated is a toughie for me right now. I suppose a pen and paper would help :P
11:05:12 <byorgey> PolishDemon: yes, pen and paper are often useful =)
11:05:17 <typoclass> PolishDemon: you could look at it like this: you have g = zipWith' (*), which means g :: (Num c) => [c] -> [c] -> [c]. it's a function that takes two lists and gives a list, all of them being a Num type. then you do zipWith' g [...] [...]. this is okay because zipWith' wants a function of two arguments
11:05:38 <byorgey> FMKilo: lambdabot only accepts expressions
11:06:20 <PolishDemon> typoclass: makes sense! I missed the fact that there was a list within a list, too, I think.
11:06:31 <PolishDemon> alright, cool. thanks guys :)
11:06:38 <FMKilo> how can I get a lambdabot?
11:07:06 <johnw> FMKilo: lambdabot is on Hackage: cabal install lambdabot
11:07:08 <typoclass> FMKilo: you can always talk to lambdabot privately
11:07:27 <FMKilo> I WANT ONE FOR MY OWN PURPOSES :)
11:07:28 <johnw> yes, or that
11:07:38 <johnw> FMKilo: I run my own lambdabot on my machine
11:08:00 <Lethalman> you want that for world domination purposes
11:08:07 <typoclass> FMKilo: enter /query lambdabot in your irc client. installing it is a bit difficult i've heard. do you know about ghci? it does 60% of what lambdabot does
11:08:24 <FMKilo> I use ghci.. I just want one...
11:08:26 <byorgey> johnw: is it easier to get lambdabot up and running these days?  Last time I tried required a valiant fight
11:08:31 <FMKilo> I want to examine it more than anything
11:08:58 <johnw> byorgey: it was work, but now that work is over :)
11:09:09 <johnw> byorgey: i have one all cabal-dev installed for Mac, if you want a tarball
11:09:19 <Lethalman> there's a couple of things you have to do, like wrapping mueval if you have a single core machine
11:09:30 <Lethalman> then wrapping djinn because the parsing is broken
11:09:36 <Lethalman> other than that it's fine
11:10:23 <FMKilo> how to cabal
11:19:45 <dino-> Hm, anybody else unable to install cabal-dev from Hackage? My ghc is 7.6.1 from Arch pacman.
11:20:19 <Taneb> Is there a channel for unholy combinations of yesod and happstack?
11:21:17 <schellsan> i installed cabal-dev yesterday from hackage (if that's where it comes from with cabal)
11:22:39 <typoclass> dino-: i think i keep hearing people asking about cabal-dev on ghc 7.6, which apparently causes problems. it's a regular topic. i think folks are having more luck with using cabal-dev from github, either the main one or a fork
11:23:04 <dino-> typoclass: Ok, will look there
11:23:17 <typoclass> dino-: also, i bet google can find you some mailing-list discussions
11:27:38 <byorgey> dino-: yes, the cabal-dev on Hackage is horribly old and outdated
11:27:49 <byorgey> AFAIK it doesn't even build on 7.4 without problems
11:28:41 <mauke> HaXml--  # installing programs with uppercase names
11:28:56 <mauke> llvm--  # installing programs with uppercase names
11:29:25 * byorgey hopes mauke does not notice BlogLiterately
11:30:13 <mauke> ... is there even a workaround?
11:30:20 <mauke> apart from uninstalling HaXml and llvm
11:30:22 <carter> mauke work around for what?
11:30:37 <typoclass> mauke: workaround by using the shift key?
11:30:40 <mauke> for rogue programs messing up my tab completion
11:30:41 <typoclass> =)
11:30:49 <mauke> typoclass: pressing the shift key has no effect
11:32:22 <mauke> I want F<tab> to expand to Funpack, not give me a list of other names
11:36:12 <mauke> rm++
11:40:59 <otters> this might be the wrong place to ask this question, but is there a cross-platform way to make a Haskell program ignore SIGHUP?
11:41:04 <otters> and does such a question even make sense?
11:41:13 <otters> no it does not
11:41:39 <n-dolio> Guess that's settled, then.
11:42:05 <chreekat> Ah, the well-loved self-answering questions. Happens to me all the time. [sorry i have no actual input to the matter]
11:42:43 * geekosaur has no idea whether the concept at all maps to Windows, aside from running something as a service
11:42:46 <typoclass> otters: posix is somewhat cross-platform. there's a System.Signal.Posix module, or some such
11:42:50 <geekosaur> or via detach
11:42:56 <x7a1c0b> if i have a module named Xy and inside that module i define a type Xy - how do i hide the value constructors? I tried module Xy (Xy()) where … but they still show up
11:43:34 <geekosaur> that actually sounds like a bug, () should not be the same as (..)
11:43:38 <otters> well what is the best way to write a haskell program that runs "in the background" (like an ircd)?
11:43:44 <geekosaur> module Xy (Xy) where ...
11:44:07 <mauke> otters: write a normal program and use external tools to daemonize it
11:44:07 <geekosaur> should export the type but not the data constructors
11:44:08 <BlindRadish> splitAt counts the elements rather than searching for the element given as a parameter, right?
11:44:22 <otters> mauke: that's what I already do, but...ok
11:44:44 <mauke> good! it really is the best way
11:44:48 <BlindRadish> the example is splitAt 3 [1,2,3,4,5,6] == [1,2,3],[4,5,6]
11:44:50 <otters> okay
11:44:55 <typoclass> otters: the poor man's way might be "yourthing &". i guess the best way would be to use djb's thing, "daemontools" or whatever the name was
11:44:57 <BlindRadish> not sure if 3 or 3rd lol
11:45:09 <mauke> BlindRadish: look at the type
11:45:11 <typoclass> > splitAt 3 "lolcats"
11:45:12 <lambdabot>   ("lol","cats")
11:45:15 <BlindRadish> thankds
11:45:23 <BlindRadish> thats what i figured but i wanted to make sure
11:45:31 <BlindRadish> so not splitAt "l" "lolcats" right?
11:45:57 <otters> typoclass: I was just thinking of bitlbee -D which makes bitlbee fork itself and run in the background
11:46:02 <typoclass> BlindRadish: nope, you'd have to use Data.List.Split, which you have to install separately
11:46:20 <BlindRadish> thanks
11:46:26 <typoclass> > break (== 'c') "lolcats lolcats" -- BlindRadish this may help, but breaks only once
11:46:27 <lambdabot>   ("lol","cats lolcats")
11:47:54 <BlindRadish> god the (list) [list] thing is super confusing
11:48:01 <BlindRadish> (x:xs) [x]
11:48:06 <BlindRadish> [x,x]
11:48:11 <x7a1c0b> geekosaur is using :load instead of import causing the problem?
11:48:22 <spoonbadger> noob though i am, i'd wager (x:xs) represents a tuple
11:48:32 <Nisstyre-laptop> what?
11:48:34 <BlindRadish> x:xs is the head and tail of a list
11:48:51 <BlindRadish> but is a list of lists a tuple?
11:48:53 <Nisstyre-laptop> (:) is the list constructor
11:48:54 <typoclass> BlindRadish: look for the ":", the parens are just syntactic noise.
11:49:04 <Nisstyre-laptop> BlindRadish: no, it isn't
11:49:05 <spoonbadger> aye, i know that. but the menality behind it might be that you see (x:xs) as a tuple of head/tail
11:49:08 <chreekat> spoonbadger: BlindRadish: try to ignore the parentheses and look at the between-bits. that is ":" versus ","
11:49:11 <geekosaur> x7a1c0b, yes, :load means it's the current module so everything in it is visible
11:49:16 <spoonbadger> rather than a list of contents
11:49:24 <typoclass> chreekat: you're absolutely right
11:49:30 <Nisstyre-laptop> except it's really not
11:49:41 <Nisstyre-laptop> a tuple has a specific meaning in Haskell
11:49:42 <geekosaur> (except, if it loads a compiled module, it can see only what's exported by it)
11:49:45 <Nisstyre-laptop> it's a product data type
11:49:59 <BlindRadish> so i say [a,b] = splitAt 5 "cutinhalf" ?
11:50:08 <BlindRadish> or (a,b)?
11:50:09 <otters> :t splitAt
11:50:10 <lambdabot> Int -> [a] -> ([a], [a])
11:50:23 <BlindRadish> i can name a list (a) right?
11:50:33 <BlindRadish> ((a),(b))?
11:50:41 <BlindRadish> or do i have to say (a,b)?
11:50:48 <BlindRadish> god its so confusing!
11:50:50 <Nisstyre-laptop> BlindRadish: if Haskell didn't have tuples you could implement them by doing "data Tuple a = Tuple a a"
11:50:53 <BlindRadish> thanks though
11:51:01 <ion> (a) = a
11:51:02 <typoclass> BlindRadish: yes you can use the name "a", but splitAt gives a tuple, not a list. look for the "," in its type
11:51:05 <ion> ((a),(a)) = (a,b)
11:51:10 <ion> err. ,(b)
11:51:19 <ion> (a,b) is a tuple, not a list.
11:51:39 <Nisstyre-laptop> actually my definition is wrong
11:51:40 <BlindRadish> so you can have lists of lists but splitAt returns a tuple?
11:51:48 <Nisstyre-laptop> should be "data Tuple a b = Tuple a b" I think
11:52:18 <fred1331> hello
11:52:28 <typoclass> BlindRadish: right, because splitAt always gives 2 things. there's no need for a list here. if it could give back any number of things, then it'd have to use a list
11:52:42 <Nisstyre-laptop> or some other sequence data type
11:52:48 <BlindRadish> ah that actually makes sense
11:53:14 <aristid> woohoo "GHCi, version 7.6.2: http://www.haskell.org/ghc/  :? for help"
11:53:20 <chreekat> Both tuples and lists hold some "thing". That "thing" could, in fact, be another list.. or another tuple. In splitAt's case, it's returning a tuple that holds lists.
11:53:51 <srhb> chreekat: That's a bit confusing. Tuples can hold many different things.
11:54:08 <Nisstyre-laptop> (a,b) ; a = [a]; b = [a]; (a,b) = ([a],[a])
11:54:18 <Nisstyre-laptop> that's basically what happens
11:54:53 <end3rW> Nisstyre-laptop: wouldn't it be "data Tuple a b = Tuple a b"? since tuples don't need to be homogeneous?
11:54:54 <ion> blindradish: Do you find it confusing that (a+b) does a summing operation and (a*c) does multiplication? (a:b) does a list cons and (a,b) creates a tuple. The only way the tuple is special in these examples is that it actually requires the () around.
11:55:02 <Nisstyre-laptop> end3rW: that's what I said
11:55:07 <Nisstyre-laptop> end3rW: I corrected myself
11:55:21 <ion> nisstyre: Wow, that was very confusing. :-P
11:55:28 <end3rW> oh sorry, seems like I didn't read that. my fault
11:55:42 <ion> nisstyre: (a,b); a = [c]; b = [c]; (a,b) = ([c],[c])
11:55:55 <srhb> What language is that?
11:56:02 <Nisstyre-laptop> ion: yeah my choice of type variable names was confusing
11:56:05 <typoclass> ion: (and to do sections, (,) needs an extra extension, but he probably doesn't care about that right now =) )
11:56:41 <Nisstyre-laptop> srhb: that's just a representation of the unification process
11:56:57 <srhb> Okay.
11:58:25 <Nisstyre-laptop> BlindRadish: do you sort of get it?
11:59:15 <Nisstyre-laptop> just remember that when you  see a type variable like 'a' it can be anything (assuming it doesn't have any constraints to specific type classes)
12:01:07 <hpaste> basdirks pasted “concatting Parser results. suggestions?” at http://hpaste.org/81496
12:03:28 <BlindRadish> i think i get it
12:03:50 <BlindRadish> but why does the comma throw an error on this code?:
12:04:09 <Nisstyre-laptop> BlindRadish: which code?
12:04:21 <BlindRadish> i was typing it in
12:04:25 <BlindRadish> but i found the bug i think
12:04:27 <BlindRadish> :D
12:04:29 <BlindRadish> thanks
12:04:37 <basdirks> someone familiar with parsing with Parsec care to have a peek at above hpaste? brb
12:15:59 <fmap> @ty sequence
12:16:00 <lambdabot> Monad m => [m a] -> m [a]
12:16:10 <fmap> basdirks: why not that and `concat'?
12:16:27 <chreekat> Ok, where we at with pointing sandboxed builds to other sandbox directories? I just tried to cabal-dev install cabal-install (say that five times fast), and it wants a version of Cabal that isn't available
12:16:52 <chreekat> fmap: basdirks: I had the same thought
12:18:15 <basdirks> does that work though? I might have a Parser Char, Parser String, and Parser [String] in the same combination
12:22:10 <chreekat> basdirks: alas
12:22:48 <BlindRadish> anyone like rock?
12:23:04 <BlindRadish> modern progrock?
12:23:05 <S11001001> basdirks: you can't get it back, though, so it buys not much more than fmap (:[])/fmap id/fmap concat
12:24:12 <basdirks> yes but I'd like to avoid having that in a billion places
12:24:45 <chreekat> I answered my own question thanks to the README on cabal-dev's github: I can use "cabal-dev add-source ../Cabal"
12:27:57 <sclv> dear upvote brigade, the highest rated haskell q on stackoverflow is currently closed, due to nonsense
12:28:00 <sclv> let's fix it: http://stackoverflow.com/questions/1012573/getting-started-with-haskell
12:29:02 <sclv> this one also probably should get some reopen votes: http://stackoverflow.com/questions/1253340/what-is-the-ecosystem-for-haskell-web-development
12:30:45 <Lethalman> sclv, about reopening... how does one vote for reopening? can't see an obvious UI for that
12:30:59 <sclv> if you have enough karma, you can vote to reopen
12:31:14 <sclv> the link is by the flag link
12:31:15 <sclv> i
12:31:21 <sclv> if you don't have enough karma, you can't see it
12:31:22 <keep_learning> Hello All
12:31:39 <parcs> stack overflow pisses me off
12:31:46 <Lethalman> ah ok
12:31:47 <parcs> what are they accomplishing by closing questions like that?
12:31:49 <BlindRadish> is it module per file or can i have multiple modules?
12:32:00 <chreekat> But I agree that neither of those questions are in line with SO's policy of "questions about actual code".
12:32:01 <parcs> BlindRadish: one module per file
12:32:05 <Lethalman> parcs, yes, some questions are fine and they close them... it's very annoying
12:32:43 <keep_learning> I am trying to learn Langauge-C and ran this code on interpreter execParser_ expressionP ( Data.ByteString.Char8.pack ( "int i = 3" ) ) nopos
12:32:50 <keep_learning> but I am getting error
12:33:01 <BlindRadish> parcs: thanks and everyone except "the eleet" hates stack overflow lol
12:33:41 <keep_learning> Could some one please tell me if its possible to run this in interpreter
12:33:47 <keep_learning> Left *** Exception: No match in record selector posFile
12:34:23 <parcs> keep_learning: is "int i = 3" an expression?
12:34:34 <parcs> keep_learning: i think the parser is just failing
12:37:20 <keep_learning> parcs, I think its assignment expression
12:37:30 * hackagebot shake 0.7 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.7 (NeilMitchell)
12:37:39 <tdammers> Lethalman: you can only vote to reopen once you have enough reputation
12:38:07 <parcs> keep_learning: "i = 3" is an assignment expression, "int i = 3" is a statement/declaration i think
12:38:34 <tdammers> this particular question has been closed because it's, basically, a "recommend some books" type question, and those are fine, but SO doesn't want them
12:39:07 <keep_learning> parcs, Thank you!
12:41:07 <sclv> its fine to have like one or two questions like that
12:41:16 <sclv> and these are highly rated questions with lots of info
12:41:24 <sclv> and they *used* to be totally acceptable
12:41:43 * sclv hates deletionism
12:42:17 <phserr> Hello everyone, can anyone point me to the right direction on representing Types specialized over values? as when you pass values to templates in c++
12:44:48 <phserr> Simplifying a bit - I have to represent some data that vary on number "bases" - data with different "bases" shouldn't be able to  be operated together. Is there a typesafe way of doing this or should I just check the "bases" in every function?
12:45:14 <sclv> one typically uses reflection for this
12:45:32 <sclv> @hackage reflection
12:45:32 <lambdabot> http://hackage.haskell.org/package/reflection
12:46:11 <ion> phserr: Can you give some examples of such bases?
12:46:27 <sclv> i assume you mean modular arith?
12:47:07 <phserr> ion: it's something like modular arithmethic - as sclv said
12:47:27 <sclv> anyway, the reflection package lets you do this. the paper the docs link to uses modular arith as a running example
12:47:42 <sclv> i have no idea why there's not an obvious hackage package providing safe modular arith directly
12:48:00 <phserr> sclv: thanks - I'm reading it right now
12:49:22 <parcs> c++ templates don't let you do what reflection does, does it?
12:54:05 <phserr> parcs: what I meant was - If I use values as parameters in templates, different types are generated using those values as bases (my use case) and that's a typesafe way of having what I want
12:54:57 <phserr> parcs: I'm still reading the reflection paper to see what it does and compare the approaches though
12:56:23 <amiller_> ah i'm frustrated again, https://gist.github.com/4659219
12:56:37 <amiller_> i think i don't understand the delicate way that laziness affects this tracing business
12:57:36 <amiller_> the premise is that i have a datatype and a function (in this case a binary tree, and a lookup function) expressed as a functor fixpoint and a catamorphism algebra
12:57:38 <tom2221> Hi. I've wrote a project that touches on topics upto monad transformers/parsec (which are the limits of my haskell ability). I now want to write a networking application, that will require the ability to concurrently handle receiving/transmissions a simple wire protocol over TCP or even UDP.
12:57:43 <tom2221> I've found http://hackage.haskell.org/package/network and http://hackage.haskell.org/package/network-conduit  and zeromq bindings. Are there any other notable alternatives that I should consider? (e.g. alternative low level APIs, or higher level libraries, such as Actors or some such)
12:57:57 <magic> @hackage math
12:57:57 <lambdabot> http://hackage.haskell.org/package/math
12:58:19 <Taneb> @hackage arithmoi
12:58:19 <lambdabot> http://hackage.haskell.org/package/arithmoi
12:58:21 <amiller_> and i can replace the ordinary fixpoint with one that adds monadic (or applicative) effects to the constructors/destructors
12:59:33 <sclv> tom2221: network is the base for writing a raw wire protocol
12:59:45 <parcs> phserr: i think type families, gadts + data kinds are more relevant than reflection, then
13:00:14 <magic> Taneb: thanks a lot for your help :)
13:00:38 <amiller_> i think the problem is that when i use lazy io and ask for the result i only observe the effects in the right order
13:01:03 <amiller_> whereas when i actually try to collect all the effects using State it actually is fundamentally evaluating the entire structure rather than just the parts that were traversed
13:01:06 <sclv> tom2221: but from your description, its not clear to me what sort of higher level api you might want?
13:01:19 <sclv> like are you doing rpcs, or streams of data, or...?
13:02:22 <sclv> network-fancy, if its still maintained, has some neat features as a simple layer over network, btw: http://hackage.haskell.org/package/network-fancy
13:03:15 <phserr> parcs: my haskell knowledge is somewhat vanilla - I suppose these are extensions. I will google for them. Thanks for these pointers
13:03:27 <dzhus> Can I match type operator applications on type level in instance declarations?
13:04:49 <dzhus> (http://dpaste.com/898995/)
13:05:29 <dzhus> yields http://dpaste.com/898996/
13:06:55 <monoidal> dzhus: + is supposed to be a type-level function, so no. it would be like doing f (x+y) = ... on the value level
13:08:58 <monoidal> dzhus: but, if you define say data (++) a b, you should be able to write instance (==) (n ++ m) (m ++ n)
13:09:15 <monoidal> it might not have the desired effect, however
13:14:43 <tom2221> sclv: I was open to suggestions. In the same way STM aims to improve upon having to deal with mutexes/semaphores/etc, I was interesting in whether are any higher level alternatives to the sockets api.
13:15:19 <sclv> it really depends what you want -- if you want distributed channels, there's packages for that. if you want rpcs, there's packages for that.
13:16:02 <sclv> there are lots of cool layers on network, but they're all suitable for different things. each is more handy and powerful, but by the same token less general.
13:16:04 <tom2221> sclv: I was interested in writing a distribution key/value store implementation. (Kademlia, chord, ...). I don't know what distributed channels are: I'll check them out.
13:16:20 <sclv> you might enjoy cloud-haskell and the distributed-process library
13:16:25 <sclv> although it has a learning curve
13:16:26 <dzhus> monoidal: what I'm trying to do is write equality constraint for type-level numerals which would support type-level addition, too.
13:16:58 <tom2221> sclv: Mmm yes, excellent. Thanks.
13:19:52 <BlindRadish> how do i duplicate a function into a list?
13:19:56 <BlindRadish> [f,f,f]?
13:20:15 <BlindRadish> i know, i'm nuts
13:20:22 <Iceland_jack> replicate?
13:20:23 <BlindRadish> just keeping you guys on yer toes ;)
13:20:26 <BlindRadish> replicate?
13:20:27 <BlindRadish> k
13:20:47 <ion> > replicate 3 (*100) <*> pure 42
13:20:48 <lambdabot>   [4200,4200,4200]
13:20:49 <BlindRadish> anyone listening to music?
13:20:57 <ion> > pure (*100) <*> replicate 3 42
13:20:59 <lambdabot>   [4200,4200,4200]
13:21:02 <Iceland_jack> no
13:21:31 <BlindRadish> hey iceland jack are you from iceland>
13:21:32 <BlindRadish> ?
13:21:34 <monoidal> dzhus: there's a (maturing) branch of GHC that adds naturals with such equations. I doubt you can add such rules like a+b=b+a and (a+b)+c=a+(b+c) and expect it to prove ((a+c)+b)+d=(b+c)+(d+a), for example
13:21:42 <Iceland_jack> Yeah I am
13:21:54 <BlindRadish> i think its great your country isn't paying the debt back lol
13:21:57 <monoidal> dzhus: in the current GHC - for naturals the solver might be intelligent enough
13:21:59 <BlindRadish> mega scam lol
13:22:07 <dzhus> monoidal: *not be*?
13:22:24 <Iceland_jack> I don't see how that's on topic
13:22:27 <monoidal> dzhus: ?
13:22:33 <BlindRadish> sorry just being friendly
13:23:54 <BlindRadish> its not every day i meet someone from iceland
13:24:58 <dzhus> monoidal: I don't get last two of your messages, do you think the solver from the main trunk is already intelligent enough or not?
13:25:35 <monoidal> dzhus: I think it is not
13:26:26 <dzhus> Ok, thanks.
13:34:29 <t7> am i silly for allways using case and never using pattern matching on function args?
13:34:47 <t7> i dont like the repetition
13:34:55 <S11001001> t7: yep
13:35:10 <S11001001> t7: repeating lets you declare which bits are relevant for each path
13:35:16 <EvanR> i use case when theres a lot of cases and the name is long
13:35:39 <S11001001> t7: e.g. map is map _ [] = []; map f (x:xs) = f x:map f xs; declares that f doesn't matter in the [] case
13:35:51 <EvanR> it think its silly if theres a performance difference for spelling the thing slightly different
13:36:04 <S11001001> t7: but I favor catamorphisms over both honestly
13:36:19 <S11001001> because they help write pointless code
13:37:32 * hackagebot coroutine-object 0.2.0 - Object-oriented programming realization using coroutine  http://hackage.haskell.org/package/coroutine-object-0.2.0 (IanWooKim)
13:37:34 * hackagebot hoodle-core 0.9.0.0 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.9.0.0 (IanWooKim)
13:38:27 <lennart_> > [ v | (_, v) <- (Just (1,13))]
13:38:29 <lambdabot>   Couldn't match expected type `[t0]'
13:38:29 <lambdabot>              with actual type `Data.May...
13:39:04 <lennart_> > do { (_, v) <- (Just (1,13)); return v }
13:39:06 <lambdabot>   Just 13
13:39:13 <parcs> > [ v | Just (_, v) <- [Just (1,13)] ]
13:39:15 <lambdabot>   [13]
13:39:23 <parcs> > [ v | Nothing <- [Just (1,13)] ]
13:39:25 <lambdabot>   []
13:41:37 <lennart_> what is the expansion of the list comprehension? can lambdabot expand it?
13:42:05 <Botje> that sounds like homework
13:42:36 * hackagebot hoodle 0.1.1.1 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.1.1.1 (IanWooKim)
13:42:41 <parcs> lennart_: the haskell report explains it well
13:43:31 <miniBill> I'm writing a toy project to better understand haskell, but I'm finding myself using too much parens
13:43:46 <miniBill> can I ask you to help my simplify an expression?
13:43:49 <johnw> sure
13:43:56 <miniBill> derivative v (Product (x:xs)) = Sum $ (Product ((derivative v x):xs)) : [(Product (x : [(derivative v $ Product xs)] ) )]
13:44:27 <miniBill> where Sum and Product are Sum [Expression] and Product [Expression], and Expression is = Sum ... | Product ... | ...
13:44:39 <johnw> derivative v (Product (x:xs)) = Sum $ (Product (derivative v x:xs)) : [Product (x : [derivative v $ Product xs] ) ]
13:45:00 <parcs> miniBill: why do you think you use too much parens?
13:45:03 <johnw> you may not need them for the second "Product" call either
13:45:14 <johnw> derivative v (Product (x:xs)) = Sum $ Product (derivative v x:xs) : [Product (x : [derivative v $ Product xs] ) ]
13:45:14 <parcs> parens aren't bad y'know
13:45:23 <miniBill> parcs: yes...
13:45:38 <miniBill> also, I think it would be possible to omit the v somehow
13:45:45 <johnw> in fact, I wouldn't use $ in that expression, I'd use "derivative v (Product xs)"
13:45:49 <miniBill> maybe defining derivative v = derivative' where ...
13:46:22 <lennart_> parcs: thanks, got it
13:47:03 <lennart_> i thought you could do any monad in list comprehensions
13:47:12 <johnw> enable monad comprehensions
13:47:35 <miniBill> derivative' (Product (x:xs)) = Sum $ Product (derivative' x:xs) : [Product (x : [derivative' (Product xs) ] ) ]
13:47:38 <miniBill> even better ^^
13:47:39 <parcs> then why are they called list comprehensions?
13:48:00 <johnw> parcs: how do you mean?
13:48:32 <parcs> never mind. :P
13:49:02 <monoidal> miniBill: x : [y] = [x,y]
13:51:17 <parcs> he's gone
13:51:43 <lennart_> johnw: thanks, works great
14:00:39 <eyebloom> Is there anyone on the channel who is familiar with "Types and Programming Languages" by Benjamin Pierce and might answer a few questions?
14:01:16 <Cale> eyebloom: sure
14:01:28 <Cale> (many people)
14:02:22 <eyebloom> I've just gotten to the section on recursive types and I'm trying to understand the notation involving the Mu symbol.
14:03:35 <eyebloom> For example he defines Natlist = μX. <nil:Unit, cons:{Nat, X}>
14:03:54 <eyebloom> I'm interpreting μ as a lambda for types.
14:04:12 <eyebloom> But it's unclear to me how this makes the term recursive.
14:04:37 <eyebloom> (The brackets mean type union in the book)
14:04:39 <Cale> It's similar to lambda in that it binds a variable, but that's kind of where the similarity ends.
14:05:03 <mauke> it's like fix\
14:06:07 <Walther> I might be into something useful in the near future and I'm considering building it with Haskell. How good is the a) audio and b) midi support in Haskell?
14:06:08 <Cale> Yeah, Natlist is the fixed point of the equation  Natlist = <nil: Unit, cons: {Nat, Natlist}> (in the equirecursive presentation)
14:06:36 <Walther> In a technical sense, would it make any sense to write a assignable midi synth with Haskell?
14:06:49 <johnw> Walther: I don't see why not
14:06:54 <Walther> Good.
14:07:16 <johnw> you can write kernel device drivers in Haskell.  Not exactly it's forté, but you can
14:07:22 <eyebloom> I see. I think I'm unclear how the equirecursive presentation reduces to the isorecursive if that's the correct way to describe it.
14:07:35 <Cale> Walther: I know that there are people who do music-related stuff in Haskell, but I also know that one of them is Henning Thielemann, who basically ruins libraries that he maintains by naming all the types T and all the typeclasses C
14:08:12 <Walther> hmm
14:08:13 <Cale> If it weren't for this fact, I would recommend Haskore
14:08:39 <Cale> (maybe you can get hold of an earlier version of it, from before he started maintaining it)
14:08:50 <Walther> I'll have to look into this. I recently became extremely frustrated from the fact that there isn't a foss alternative for Ableton Live's drum rack when toying around with Novation Launchpad
14:10:00 <Cale> eyebloom: The difference is whether there's an explicit constructor to pattern match away or not -- in the isorecursive thing, the two types there are isomorphic rather than equal, with functions in either direction between the two types which are inverses of each other
14:10:34 <Cale> (but the two types don't actually have any terms in common)
14:11:50 <Cale> In the equirecursive version, the two types in that equation have the same terms in them.
14:12:06 <Walther> I would love to have a simple thing: configurable n x n grid, assign mode where you click square and push button, repeat, and then play mode where you can drop audio samples on the grid and launch/cut them in realtime with the launchpad
14:12:24 <Walther> Shouldn't be that hard to do
14:12:32 * hackagebot HTTP 4000.2.7 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.7 (GaneshSittampalam)
14:13:02 <Cale> Walther: Well, apart from the fact that GUI stuff is annoying to write in every language :)
14:13:23 <Walther> Cale: heh :)
14:13:39 <eyebloom> I see so for example MyList = <nil: Unit, cons: {Nat, Mylist}> is just isomorphic to NatList? While if the are both equal to μX. <nil:Unit, cons:{Nat, X}> then both types are equal?
14:13:48 <Walther> But given the Launchpad's MIDI specs are available online ...this should be trivial
14:14:22 <Cale> eyebloom: Well, <nil: Unit, cons: {Nat, Mylist}> is isomorphic to Mylist in the isorecursive version.
14:14:48 <Cale> eyebloom: and there will be a function  Mylist -> <nil: Unit, cons: {Nat, Mylist}>, and one in the other direction
14:14:55 <Cale> which are inverses of each other
14:15:06 <Cale> (and provided by the construction of the recursive type)
14:15:20 <Walther> or for the generic case, recording a MIDI even t should be possible with some existing library
14:16:12 <BlindRadish> ugh mutables in haskell kill me
14:16:16 <BlindRadish> can't figure them out
14:16:31 <eyebloom> Do μ terms desugar into lambda terms?
14:16:34 <Botje> BlindRadish: mission accomplished!
14:16:40 <BlindRadish> need a monadic functor
14:16:53 <Cale> BlindRadish: Mutable what?
14:16:55 <BlindRadish> i refuse to pass something around when i could just store it
14:17:02 <BlindRadish> Word
14:17:12 <BlindRadish> not like "a word" but like a Word32
14:17:23 <BlindRadish> 00100100
14:17:26 <Cale> okay
14:17:44 <Cale> What are you actually doing with that?
14:18:02 <BlindRadish> its for a random number generator I've been beating my face against since I got started
14:18:17 <BlindRadish> a lot of people made a lot of different recommendations
14:18:31 <mauke> ... TyCon.algTcStupidTheta
14:18:35 <mauke> go home ghc, you're drunk
14:18:47 <Cale> Heh, you might be in one of the rare cases that State Word32 would be an appropriate monad to use.
14:19:07 <BlindRadish> yeah i get it - it's bad to use mutables
14:19:13 <mauke> no, it's not
14:19:13 <Cale> ?
14:19:15 <BlindRadish> but come on, there's like no way to do it lmao
14:19:24 <mauke> please stop laughing like a madman
14:19:30 <BlindRadish> this language is a cruel master
14:19:39 <Cale> But I *would* recommend writing at least some of the code in a direct fashion, taking an additional parameter and producing an additional result, in order to understand that way
14:19:44 <BlindRadish> muahahahahahaha bahahahahahaha gwafafafahahaha
14:19:50 <BlindRadish> anyone like Mastodon?
14:19:50 <johnw> BlindRadish: does this help: http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random-Class.html#t:MonadRandom
14:19:52 <mauke> you already said that before
14:20:19 <BlindRadish> nah I'm trying to roll my own
14:20:29 <Cale> BlindRadish: There are like 11 ways to work with different sorts of mutable state
14:20:35 <BlindRadish> those ones have terrible entropy lol
14:20:40 <Cale> BlindRadish: You could use IORefs in the IO monad
14:20:43 <Cale> or STRefs
14:20:50 <BlindRadish> State won't work?
14:20:57 <Cale> Or State
14:21:11 <Cale> Or you could use a custom monad designed around your random number generator
14:21:20 <BlindRadish> I need a functor, it doesn't have to be monadic I just can't call multithread it.
14:21:28 <johnw> Cale: won't State only work for PRNG?
14:21:32 <Cale> Or you could use MVars or TVars if you cared about concurrency
14:21:35 <BlindRadish> what I mean is, I can call it in any order, but not in parallel
14:22:08 <Cale> I don't understand your usage of the word functor there.
14:22:15 <BlindRadish> whats the best practice for "call whenever but lock/unlock"
14:22:27 <BlindRadish> a function with some data attached to it, and only it?
14:22:44 <BlindRadish> an object with 1 variable and 1 function
14:22:45 <Cale> class Functor f where
14:22:51 <Cale>   fmap :: (a -> b) -> f a -> f b
14:22:53 <BlindRadish> maybe not a Functor
14:23:09 <BlindRadish> i'll look that up though
14:23:18 <johnw> Cale: i think he means the C++ use of the word "functor"
14:23:27 <Cale> Ah, that's broken :)
14:23:56 <johnw> BlindRadish: "a function with some data attached to it, and only it?" is simply partial application
14:23:58 <Cale> BlindRadish: So you just want a pair consisting of a function and a value?
14:24:09 <BlindRadish> lol sorry for the cavespeak
14:24:11 <Cale> Or maybe just a function?
14:24:32 <Cale> Usually what C++ folks call functors we just call functions
14:24:41 <BlindRadish> me code in C++ uh uh
14:24:46 <BlindRadish> huh
14:25:23 <johnw> BlindRadish: if (+) is a function of two arguments, then (+) 2 creates a function of one argument that "carries around the value 2", if you want to think of it that way
14:25:47 <BlindRadish> okay so can I have the value it carries a mutable?  and can I lock/unlock that?
14:26:01 <johnw> if it's an TVar, yes
14:26:06 <Cale> The thing is, there's no way in (at least old versions of) C++ to locally define a function such that it captures the values of variables from the surrounding scope at its point of definition.
14:26:07 <mauke> yes, but it won't be a function
14:26:09 <johnw> you can make access to the TVar atomic using STM
14:26:10 <BlindRadish> oh thank god now we
14:26:14 <johnw> yeah, it won't be a function
14:26:15 <BlindRadish> we're getting along
14:26:21 <johnw> you want a pair type, like what Cale suggested
14:26:22 <mauke> johnw: or even MVar
14:26:35 <johnw> mauke: true
14:26:38 <BlindRadish> guys I'm getting confused now!
14:26:55 <Cale> Let's not worry about concurrency for the time being
14:26:57 <Cale> IORef
14:26:58 <hpaste> frerich pasted “Cabal source file dependencies” at http://hpaste.org/81497
14:26:59 <BlindRadish> try one more time, what do I do?  what should I look up?
14:27:01 <johnw> mauke: would you recommend introducing newcomers to MVar first, or TMVar?
14:27:08 <Cale> IORef first
14:27:16 <johnw> ok, IORef first
14:27:19 <BlindRadish> isn't that a hack?
14:27:26 <mauke> BlindRadish: no, why?
14:27:29 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
14:27:35 <BlindRadish> I'm thinking of unsafePerformIO
14:27:40 <mauke> johnw: MVar, I think
14:27:41 <frerich_> Hi, I have a small Cabal question - in that hpaste link which was just posted, should changing src/Arguments.hs trigger rebuilding the executable?
14:27:58 <Cale> BlindRadish: unsafePerformIO is a low-level hook that you ought not to use.
14:28:14 <Cale> (unless you know what you're doing and would otherwise end up modifying GHC)
14:28:33 <Cale> But that has nothing to do with this, apart from the connection to IO
14:28:40 <BlindRadish> YES! MVar! Love you mauke!
14:28:54 <mauke> o_O
14:29:09 <BlindRadish> I've been bashing my skull on this for days
14:29:18 <Cale> BlindRadish: MVar is like IORef, except for the fact that an MVar can be empty, and the semantics of blocking
14:29:37 <BlindRadish> The link is like "this is what you need and using it is simply {blah}"
14:29:39 <Cale> If you write to a full MVar, it waits until the MVar becomes empty
14:29:52 <johnw> there should be an optional warning flag for calling any function beginning with the word unsafe...
14:30:06 <Cale> or if you read from an empty MVar, it waits until something fills it
14:30:11 <BlindRadish> johnw: the flag is having to type unsafe lol
14:30:35 <Cale> BlindRadish: Did you look at the IORef documentation too?
14:30:43 <johnw> and not just unsafe*, but: unsafe*, undefined, error, throw
14:30:56 <BlindRadish> Cale: so I fill it when I create it, and "extract it" for use, then "put the modified version back"?
14:31:01 <Cale> throw is usually pretty safe
14:31:13 <johnw> I think throw sometimes encourages partial functions
14:31:16 <johnw> throwIO is OK
14:31:26 <BlindRadish> Cale: I will now that you suggested it!
14:31:40 <Cale> johnw: Oh, you're right, yes
14:33:21 <Cale> BlindRadish: So there's  newIORef :: a -> IO (IORef a), which takes an initial value for the memory cell and produces an IO action which when you run it, constructs a new memory cell with that initial value.
14:33:38 <Cale> BlindRadish: (which is the result of running that IO action)
14:34:45 <seydar> i think i need to reinstall GHC
14:35:04 <seydar> because when i do 'import System' and run `ghc disco.hs`, i get this: Could not find module `System' It is a member of the hidden package `haskell98-2.0.0.2'.
14:35:09 <Cale> BlindRadish: and then you have  readIORef :: IORef a -> IO a  which produces an IO action for reading the current value of the memory cell, and  writeIORef :: IORef a -> a -> IO ()  which produces the action which writes the given value into the given memory cell
14:35:33 <Cale> seydar: That's normal
14:35:44 <buppy> @pl (\str a b c -> str ++ foo a b c)
14:35:44 <lambdabot> (. foo) . (.) . (.) . (++)
14:36:10 <seydar> Cale: seydar standing by, please advise
14:36:14 <Cale> seydar: System is an old haskell98 package, it's deprecated in favour of some more-split-up packages
14:36:36 <Cale> like System.IO and System.Environment
14:36:51 <BlindRadish> Cale: thanks for the info!
14:37:05 <Cale> BlindRadish: So you can write something like:
14:37:09 <seydar> Cale: Which do I want?
14:37:28 <mauke> seydar: that depends on what you're trying to do
14:37:39 <seydar> mauke: derp. i forgot to say what i'm trying to do
14:37:44 <seydar> i'm trying to call getArgs
14:37:50 <mauke> Environment
14:37:53 <Cale> BlindRadish: do r <- newIORef 0; v <- readIORef r; writeIORef r 42; w <- readIORef r; print v; print w
14:38:07 <seydar> woohoo! thank you!
14:38:09 <Cale> BlindRadish: and you should see 0 and then 42
14:38:09 <mauke> seydar: http://www.haskell.org/hoogle/?q=getArgs
14:38:53 <seydar> so next question: what is the difference between using `ghc --make disco.hs` and `ghc disco.hs`?
14:38:59 <seydar> i don't notice any
14:39:11 <seydar> also my program doesn't yet compile so that may be why
14:39:27 <c_wraith> the --make flag tells GHC to chase down other modules and libraries you're using
14:39:44 <c_wraith> without it, it tries to compile only the module you give it as a standalone thing.
14:39:47 <mauke> seydar: none
14:39:54 <Cale> --make is default now
14:39:56 <mauke> c_wraith: your information is out of date
14:40:03 <c_wraith> ah
14:40:11 <c_wraith> still does that for versions of ghc I use!
14:40:24 <c_wraith> (one of these days, we'll get off of 7.0)
14:40:30 <mauke> 6.12 or something?
14:40:46 <Cale> I think that behaviour is new in 7.6?
14:41:02 <Cale> Maybe 7.4
14:41:29 <frerich_> I have 7.4.2 and --make appears to be the default.
14:41:41 <hiptobecubic> yes
14:41:58 <mauke> it was new in 7.0
14:42:16 <Cale> oh, apparently so!
14:42:21 <c_wraith> Hmm.  I guess I never have had need to notice it.  Everything I do is either single-module or uses cabal
14:42:42 <c_wraith> So yes, my data is ancient. (from before I started using cabal)
14:43:46 <seydar> how do i go from [IO Integer] to IO [Integer]?
14:43:47 <Cale> You can notice it with a single module program if you were to, say,  import Text.Parsec
14:43:55 <Cale> seydar: sequence
14:44:00 <seydar> WAIT NOBODY SAY ANYTHING
14:44:02 <seydar> liftM
14:44:06 <Cale> nope
14:44:08 <seydar> oh... sequence...
14:44:23 <Cale> sequence [] = return []
14:44:36 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:44:42 <Entroacceptor> @hoogle [IO a] -> IO [a]
14:44:42 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:44:42 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:44:42 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
14:45:09 <hiptobecubic> @src sequenceA
14:45:09 <lambdabot> Source not found. stty: unknown mode: doofus
14:45:14 <hiptobecubic> :/
14:45:15 <mauke> seydar: http://www.haskell.org/hoogle/?q=%5BIO%20Integer%5D%20-%3E%20IO%20%5BInteger%5D
14:45:25 <dino-> So, suppose I have a project that builds a binary, is there no way for me to build it with cabal (--user) or cabal-dev, but then install the binar(y/ies) and other /usr/local/ files globally?
14:45:26 <hiptobecubic> lambdabot hates me
14:45:45 <dino-> Sometimes it's not as simple as just copying a binary or symlinking.
14:45:48 <fmap> hiptobecubic: it's a class method
14:45:50 <fmap> @src Traversable
14:45:51 <lambdabot> class (Functor t, Foldable t) => Traversable t where
14:45:51 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
14:45:51 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
14:45:51 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
14:45:51 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
14:45:53 <dino-> If you use data-dir and data-files, for instance.
14:46:23 <seydar> mauke: dude that's some straight up black magic you got going on there in that search string
14:46:31 <seydar> mauke: thank you, i didn't know i could search by type
14:47:02 <mauke> your life has been improved.
14:47:06 <mauke> stand by for assimilation
14:47:11 <hiptobecubic> fmap, oh right. of course
14:47:18 <hiptobecubic> @src [] sequenceA
14:47:18 <lambdabot> Source not found. Sorry.
14:47:27 <hiptobecubic> @src [] (>>=)
14:47:27 <lambdabot> xs >>= f     = concatMap f xs
14:47:39 <mauke> preflex: excuse for incomplete @src database
14:47:39 <hiptobecubic> well, still nothing.
14:47:40 <preflex>  That would be because the software doesn't work.
14:48:01 <sclv> haahh
14:53:48 <arbn> As every LISP programmer knows.
14:54:06 <arbn> Oops. Wrong window.
14:54:10 * arbn hides.
14:54:25 <tac> arbn: lol
14:55:40 <hpaste> seydar pasted “seydar” at http://hpaste.org/81498
14:56:02 <seydar> yep. thank you hpaste, that's what i have a question on
14:56:15 <seydar> http://hpaste.org/81498 i'm having trouble converting strings to integers
14:56:28 <mauke> :t toInteger
14:56:29 <lambdabot> Integral a => a -> Integer
14:56:37 <mauke> toInteger takes a number, not a string
14:57:02 <seydar> so... how do i take a string and get a number?
14:57:26 <mauke> read
14:57:49 <seydar> intredasting
14:57:56 <seydar> thank you
15:03:56 * monochrom puts on GHC 7.6.2!
15:05:35 <Peaker> cool! I'm hoping it fixes my performance regression compared with 7.4.1
15:06:02 <mauke> The Glorious Glasgow Haskell Compilation System, version 7.6.2
15:06:21 <Peaker> GGHCS
15:11:24 <basdirks> aka the Haskell Compiler
15:11:43 <Peaker> We do pay the lip tax that there exists a Haskell beyond GHC :)
15:11:55 <srhb> Somewhere, in an alternate universe.
15:40:20 <polynomial2> hi, can someone explain this magic to me? https://github.com/bos/pronk/blob/master/app/App.hs#L147 I gather that Args{..} puts all the members of the data type into the scope of the function. the rest confuses me. what does the !? operator do for example?
15:41:19 <mauke> er
15:41:27 <mauke> that is the definition of ?!
15:41:30 <mauke> I mean !?
15:42:11 <polynomial2> mauke: so what's happening with let p = .... ?
15:42:16 <mauke> no
15:42:23 <mauke> that is not in the code
15:42:43 <polynomial2> right apologies, let p !? what ....
15:42:48 <Peaker> there's a nicer way to write that
15:42:56 <mauke> let (?!) = \p -> \what -> case p of { True -> Nothing; False -> Just ("Argument to " ++ what) }
15:43:02 <mauke> unsugared
15:43:12 <polynomial2> Peaker: essentially what I'm searching for is a way to validate arguments to a command like tool I am writing
15:44:03 <polynomial2> mauke: hrm ok, that helps a bit. is there a cool that unsugars code? maybe makes it easier for a newbie like me to understand
15:44:09 <polynomial2> *is there a tool
15:44:58 <mauke> I'm not aware of one
15:45:13 <srhb> Just push each argument into a lambda that encloses the rest of the function body, from the right.
15:45:37 <Iceland_jack> polynomial2: If you read the first chapters of LYAH you should understand that
15:46:00 <Peaker> polynomial2, made a pull request: https://github.com/Peaker/pronk/commit/01131c40f5ce99b105162f9bac49fbb53676ea89
15:46:42 <Peaker> oops, my pull req loses the "Argument to" prefix
15:51:19 <applicative> polynomial2: there are simpler examples of usage of the cmdargs package here http://spin.atomicobject.com/2012/12/13/using-haskells-cmdargs-package/
15:52:20 <polynomial2> applicative: I already have that piece completed, I'm just struggling with writing a validation routine for teh arguments i accept
15:52:36 <applicative> ah
15:55:23 <polynomial2> this is helpful though thanks. helping me pick up the basic vocabulary so I can actually google for things and find the relevant book chapters
15:56:18 <applicative> hm, are you sure the list comprehensions are that much clearer Peaker ? ... maybe....
15:56:59 <Peaker> applicative, it's a common idiom
15:57:38 <Peaker> (rather than a custom idiom)
15:57:40 <Peaker> also shorter
15:57:49 <applicative> I'm not objecting; it is shorter
15:58:45 <monoidal> Peaker: your diff removes ("Argument to " ++) present in the original
15:58:58 <mauke> <Peaker> oops, my pull req loses the "Argument to" prefix
15:59:02 <monoidal> ah, sorry
16:03:42 <Peaker> my hope was for nothing. 7.6.2 is still far slower than 7.4.1 :-(
16:03:50 <Peaker> (though it is slightly better than 7.6.1)
16:04:29 <applicative> oh really? ah well
16:05:32 <Peaker> (for my particular benchmark)
16:08:38 <itohans> Hello! Does anyone know how I can return a variable's primitive type in Haskell?
16:08:54 <mauke> what's a "primitive type"?
16:08:55 <hiptobecubic> itohans, meaning what?
16:08:59 <itohans> i.e "let x = 0 :: Int" with some function that takes x and returns "Int"
16:08:59 <NemesisD> since you can do [1..10], is it possible to define an instance that will let you do data Foo = Foo1 | Foo2, [Foo1..Foo2]
16:09:04 <polynomial2> Peaker: in your pull request, will printing the arguments fail before problems is no longer in scope https://github.com/Peaker/pronk/commit/01131c40f5ce99b105162f9bac49fbb53676ea89#L0R149
16:09:14 <mauke> itohans: ... the string "Int"?
16:09:16 <monochrom> in a REPL you can ask for types. in a Haskell program reflecting itself no.
16:09:43 <itohans> True, but x could be anything. Same with "let x = 'h' :: Char", take x and tell me it's a Char
16:09:44 <hiptobecubic> itohans, static typing kind of defeats this anyway
16:09:47 <monochrom> however, this feature has been proposed for a possible future standard
16:09:54 <mauke> itohans: ... the string "Char"?
16:10:11 <lispy> Has anyone tried to compile ghc with clang? Does it work?
16:10:15 <Peaker> polynomial2, "problems" scopes over the entire definition of "validateArgs"
16:10:21 <applicative> @type typeOf
16:10:22 <lambdabot> Typeable a => a -> TypeRep
16:10:32 <applicative> > typeOf (1 ::Int)
16:10:34 <lambdabot>   Int
16:10:43 <hiptobecubic> your function would either have Int built into the type signature or would take some typeclass like "typeable"
16:10:51 <itohans> That looks like it! Thank you!
16:10:55 <polynomial2> Peaker: ah I see, should have looked up the where keyword first instead of assuming it was just the previous line
16:10:55 <hiptobecubic> Oh.. there is already a typeable
16:10:59 <geekosaur> you can get something that will work as a String.  if this is a prerequisite for some kind of dynamic typing scheme, it probably won;t do what you intend
16:11:09 <applicative> itohans: ^^^ do you just want to know the type or do you want evil means of getting its name in a program?
16:11:31 <NemesisD> is [x..y] a special thing?
16:11:39 <itohans> applicative: I mostly just want to return a String representing the type.
16:11:56 <applicative> > show $ typeOf (1 ::Int)
16:11:58 <lambdabot>   "Int"
16:12:04 <monochrom> how special is special? I wouldn't say [x..y] is special. YMMV
16:12:07 <applicative> you'll regret this itohans
16:12:28 <applicative> > show (typeOf 1)
16:12:30 <lambdabot>   "Integer"
16:12:37 <itohans> applicative: Probably. I'm still learning =(
16:12:43 <NemesisD> monochrom: i mean is that a sugar in haskell that i can't use with my own abritrary ADTs?
16:12:51 <applicative> ^^^ itohans watch out for defaulting, type classes etc etc
16:12:53 <byorgey> itohans: the question is, why do you want that String?  what are you going to do with it once you have it?
16:13:10 <monochrom> ok, yes, it is sugar, cannot be in ADT
16:13:22 <applicative> itohans: you can always do case n of _ -> "Int"
16:13:33 <NemesisD> monochrom: so do i have to use range from class Ix then?
16:13:34 <itohans> byorgey: I need to do a check to make sure that two variables are of the same type. Returning a String was just an idea.
16:13:42 <monochrom> it's an Enum thing
16:14:01 <applicative> @type asTypeOf
16:14:03 <lambdabot> a -> a -> a
16:14:15 <mauke> now you have two problems
16:14:17 <NemesisD> ah i see now why i couldn't define succ for an ADT
16:14:22 <byorgey> itohans: Haskell is a statically typed language.  If you're checking types of things at runtime you're probably doing something wrong.
16:14:34 <applicative> itohans: if they are x and y then asTypeOf x y wont typecheck unless they are, or can be
16:14:44 <NemesisD> unless it was cyclical...
16:15:06 <byorgey> itohans: every variable already has a type.  What type a variable is cannot be diferent from one run of the program to the next.
16:15:15 <mauke> > [False .. True]
16:15:18 <lambdabot>   [False,True]
16:15:19 <byorgey> so you already know before you run the program whether they are going to be the same type or not.
16:15:32 <monochrom> while we are at it, Haskell has no subtype. do not imagine "two types X,Y where Y is a special case of X". please do not. please.
16:15:37 <monochrom> I beg you.
16:16:10 <itohans> byorgey, applicative: Here is an example of what I'm trying. https://gist.github.com/4661593
16:16:12 <nejucomo> I wonder where I can learn about side-channel analysis, performance, and ghc...
16:16:17 <hiptobecubic> what about typeclass with other typeclass constraints?
16:16:29 <applicative> that's just because Haskell isn't 'expressive enough' monochrom
16:16:30 <NemesisD> mauke: succ True ...
16:16:32 <monochrom> but then I also beg you to not "f :: a->b->Bool, so that f x y iff x and y have the same type"
16:16:38 <nejucomo> (AFAIK, side channel analysis requires a solid understanding of performance, which for haskell seems to require a good understanding of compilation strategy.)
16:16:44 <mauke> > succ True
16:16:45 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
16:16:50 <itohans> byorgey, applicative: The goal is to learn what sub-datatype a Token is returning.
16:17:00 <monochrom> however, like I said, the future is pretty dim. I mean bright! a future Haskell standard may have to support it!
16:17:02 <applicative> "Haskell does not have full-fledged dependent types. For example, there is no way to create naturals as a subset of integers. " uuuurrgh
16:17:16 <byorgey> itohans: you do that by pattern-matching.
16:17:23 <byorgey> itohans: you cannot do it by checking the type.
16:17:42 <monochrom> God. there is not sub-datatype. I beg you again.
16:17:55 <mauke> itohans: your Token type looks wrong
16:18:06 <mauke> I don't see why it takes a parameter
16:18:21 <monochrom> ok everything I beg for are denied. I'm going to dinner instead.
16:18:45 <NemesisD> mauke: i'm rolling my own ADT for day of week, and i wanted to do something like [Sunday..Saturday]
16:18:45 <nejucomo> Is it not possible with user-specified kinds or some such trickery to express an assertion that two types are the same?
16:18:49 <NemesisD> maybe a bad idea
16:18:49 <byorgey> right.  it should be something like  data Token = ReservedToken ReservedWords | IdToken IdentifiersAndLiterals | ...
16:18:52 <mauke> data Token = ReservedWords ReservedWords | IdentifiersAndLiterals IdentifiersAndLiterals | ErrorCodes ErrorCodes | Symbols Symbols | EndOfFile
16:18:55 <byorgey> itohans: ^^^
16:19:01 <mauke> confusing names due to your names being confusing
16:19:01 <byorgey> what mauke said.
16:19:02 <nejucomo> (I'm not saying doing so is a good idea...)
16:19:37 <itohans> mauke: Alright, forgive me if this is a stupid question, but what would that do?
16:19:47 <mauke> itohans: which part is unclear?
16:20:22 <itohans> mauke: I'm not sure how it's different than Token a = ReservedWords a | IdentifiersAndLiterals a | ...
16:20:25 <monoidal> applicative: did I express this poorly? I meant you cannot write Natural = {x : Integer, x >= 0}.
16:20:40 <mauke> itohans: I'm not sure how it's similar
16:20:41 <byorgey> itohans: it says that a Token consists of either a 'ReservedWords' constructor along with a value of type ReservedWords, or an 'IdentifiersAndLiterals' constructor along with a value of type IdentifiersAndLiterals, or...
16:21:00 <byorgey> itohans: it may be confusing to use the same names.  data constructor and type namespaces are entirely separate.
16:21:24 <byorgey> consider instead something like    data Token = RW ReservedWords | IAL IdentifiersAndLiterals | ...
16:21:31 <schellsan> thanks be to he that wrote simpleirc
16:21:33 <applicative> monoidal: no, it's just that that doesn't seem to be what the naturals are.  PositiveInteger = {x : Integer, x >= 0} maybe?
16:22:09 <itohans> byorgey: Alright, I think I'm starting to get it! So would it be possible to know if a Token has a "ReservedWords" type or an "IdentifiersAndLiterals" type, cleanly in Haskell?
16:22:25 <byorgey> itohans: yes, if you use the type I just wrote
16:22:30 <geekosaur> it does if you define it so
16:22:40 <byorgey> itohans: but let's use the correct terminology: a Token has type Token.
16:22:42 <applicative> monoidal: I think I was just alarmed that you called them 'the naturals' when a 'type distinction' is the perfect word for the difference, they have so little in common, Natural and Integer ; I don't know.
16:22:43 <mauke> itohans: except it's not a different type
16:22:59 <byorgey> a Token may *contain* a value of type ReservedWords, or IdentifiersAndLiterals, or...
16:23:08 <geekosaur> users of your module do not get to define their own whatever and pretend it's a Token; they must use the Token you define
16:23:18 <byorgey> itohans: and you can find out which by pattern-matching.
16:23:19 <itohans> Alright, yeah.
16:25:01 <itohans> byorgey: I'll rewrite it and see if I can figure out how you'd pattern-match it. I'm not quite sure how to return "ReservedWords" or "IdentifiersAndLiterals" through pattern-matching, though.
16:25:37 <mauke> @src Bool
16:25:37 <lambdabot> data Bool = False | True deriving (Eq, Ord)
16:25:56 <applicative> > dataTypeConstrs $ dataTypeOf ([]::[Char])
16:25:58 <lambdabot>   Not in scope: `dataTypeConstrs'Not in scope: `dataTypeOf'
16:25:58 <lambdabot>  Perhaps you mean...
16:26:03 <byorgey> itohans: you mean the literal string values "ReservedWords", ... ?
16:26:03 <applicative> :(
16:26:13 <geekosaur> myFunction (ReservedWords x) = ...; myFunction (IdentifiersAndLiterals x) = ...; ...
16:26:17 <byorgey> or values of those types?
16:26:18 <itohans> byorgey: Yeah, that part
16:26:29 <byorgey> itohans: see what geekosaur wrote ^^^
16:26:35 <itohans> byorgey: Well, both, really. But two separate functions
16:26:39 <itohans> geekosaur: Ahh, I see!
16:26:58 <itohans> Thanks everybody, this was extremely helpful =)
16:27:20 <byorgey> itohans: out of curiosity, is there a particular Haskell tutorial/book/etc. you've been reading?
16:27:50 <itohans> byorgey: Yeah, I've been reading http://learnyouahaskell.com/ primarily.
16:29:25 <byorgey> ok, LYAH's coverage of algebraic data types isn't that great IMO
16:29:49 <byorgey> you may want to find some other things to read about algebraic data types to reinforce your understanding
16:30:02 <itohans> byorgey: Do you have any specific examples in mind?
16:30:13 <kini> looks like the Eq typeclass in the Prelude has broken links to its source code in the hackage documentation listings
16:30:18 <kini> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Prelude.html#g:4
16:31:48 <byorgey> itohans: maybe try http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html and
16:32:58 <applicative> kini: that's because its a stub of some sort for haddock, the Real definition of Eq is somewhere else, GHC.Classes maybe?
16:33:27 <itohans> I'll read through it, thanks!
16:35:04 <lemao> What is the meaning of 'observable' in the context of Haskell? E.g. observable sharing
16:35:24 <mauke> it's when you can tell the difference
16:36:04 <elliott> well, Haskell implementations share whether you want them to or not
16:36:09 <elliott> observable sharing just means you get to see how they're doing it
16:37:34 <lemao> when thinking about deep or shallow embedding, would it mean that in a deep embedding it is possible to observe the syntax tree since it is explicit? As opposed to shallow embeeding where I can't 'traverse' the function calls?
16:37:36 * hackagebot hsparql 0.2.3 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  http://hackage.haskell.org/package/hsparql-0.2.3 (RobStewart)
16:41:01 <monochrom> yeah, a deep embedding allows you more queries because you recorded the answers in the first place
16:41:35 <kini> applicative: well, the link does point to http://hackage.haskell.org/packages/archive/%01/%02/doc/html/src/GHC-Classes.html, which suggests that GHC.Classes is the correct location
16:42:08 <monochrom> what are %01 and %02 doing there?
16:42:13 <kini> that's a good question
16:43:20 <monochrom> which package name is it?
16:46:39 <applicative> kini: here at last youre killing me... http://www.haskell.org/ghc/docs/7.6.2/html/libraries/ghc-prim-0.3.0.0/src/GHC-Classes.html#Eq
16:46:53 <crdueck> does GHC have a concurrent gc yet, or is it still parallel but stop-the-world? does anyone have some good links I can read on the current state of the gc and any plans for the future?
16:47:01 <applicative> kini, it's 7.6.2 -- up to the minute...
16:47:09 <kini> applicative: hurrah! :)
16:48:38 <bacon1989> so is there a way to really make the differences between function composition '.' and the parenthesis thing '$' really stick out?
16:49:02 <bacon1989> I feel like i've been using the function composition in all of the same places as the $ thing
16:49:46 <kini> bacon1989: I think it becomes more clear when you put the omitted parentheses in
16:50:10 <kini> a . b $ c = (a . b) c, whereas a $ b $ c = a (b c)
16:50:25 <applicative> kini: the haddocks for these really fundamental things are pretty misleading, in this case I kept looking in the wrong package for the source which is https://github.com/ghc/packages-ghc-prim/tree/master/GHC
16:50:49 <heatsink> > let { double x = x + x; quadruple = double . double } in quadruple 10
16:50:52 <lambdabot>   40
16:51:08 <heatsink> You would need to eta-expand that to use $
16:52:49 <bacon1989> so can it be seen as though function composition uses the dot as a placeholder to represent whatever comes next as the argument to the first function?
16:52:54 <bacon1989> but
16:53:19 <bacon1989> the dollar sign, is like a placeholder for a... function
16:53:22 <bacon1989> god dammit
16:53:42 <bacon1989> one is a placeholder for an argument, the other is a placeholder for a function?
16:53:48 <kini> . and $ are not placeholders, they're operators
16:53:57 <geekosaur> $ is the same as a space except the precedence is inverted:  space (function application) has highest precedence, $ has lowest
16:54:39 <kini> right. Whereas . is a constructor that builds a new function from two other functions by composing them (or piping / concatenating them if you think of functions as processes)
16:54:57 <geekosaur> I like to think of it as backwards parentheses:  some long thing $ some other long thing    is the same as    (some long thing) (some other long thing)
16:55:10 <bacon1989> ah ok
16:55:22 <geekosaur> put that way, it doesnt make much sense to use $ when neither side is very long
16:55:38 <bacon1989> f $ x $ y = f (x) (y)?
16:55:52 <monochrom> yes
16:55:53 <noah_> $ can be read as "applied to"
16:56:00 <bacon1989> but f . x . y = f(x(y))?
16:56:04 <monochrom> no
16:56:06 <Nisstyre> bacon1989: a function operator is just "t1 -> t2 -> t3" but it's used in infix form as opposed to prefix like the rest of Haskell
16:56:14 <geekosaur> @pl f $ x $ y
16:56:14 <lambdabot> f (x y)
16:56:15 <heatsink> f . x . y = \z -> f (x (y z))
16:56:25 <monochrom> sorry
16:56:29 <geekosaur> not f (x) (y)
16:57:05 <heatsink> Read "f . g . h" from right to left.
16:57:12 <bacon1989> Nisstyre: i see
16:57:15 <monochrom> you see I don't use $ enough to know. this should tell you something
16:57:30 <heatsink> I mean, the rightmost function is applied first, so it's easiest to read right-to-left.
16:57:38 <bacon1989> so was I right with f . x . y == f(x(y))?
16:57:43 <monochrom> no
16:58:05 <bacon1989> hmm
16:58:24 <heatsink> f $ x $ y = f (x (y))
16:58:28 <Axman6> f . x . y forms a pipeline, where the input is passed to y then the result is passed to x whose output is passed to f
16:58:42 <geekosaur> @unpl f . x . y
16:58:42 <lambdabot> (\ c -> f (x (y c)))
16:58:44 <Nisstyre> f . x . y = (\a -> f $ x $ y a)
16:58:48 <Peaker> f . x . y == \arg -> f (x (y (arg)))     (to keep the unnecessary parens)
16:58:49 <kini> in particular y needs to be a function
16:58:56 <Axman6> > (show . negate) 5
16:58:58 <lambdabot>   "-5"
16:59:00 <kini> whereas in f $ x $ y, y could just be, say, a Bool or something
16:59:15 <Axman6> > (show . negate . subtract 7) 5
16:59:17 <lambdabot>   "2"
16:59:40 <Axman6> > show . negate . subtract 7 $ 5 -- $ lets us remove the brackets
16:59:42 <lambdabot>   "2"
17:00:15 <bacon1989> so it lets you remove the brackets, because you can basically treat it as higher precedence?
17:00:30 <Axman6> so f . g . h $ x is the same as (f . g . h) x which is the same as f (g (h x))
17:00:43 <kini> bacon1989: that's technically called *lower* precedence, but yes
17:01:02 <kini> it's called "lower" because you do the things on the left and the right separately first, and then finally put them together using the $ at the end (lowest priority operation)
17:01:04 <bacon1989> oh my bad
17:01:39 <kini> the highest precedence operators have the highest priority to be applied "first" when breaking down the structure of an expression
17:02:04 <Nisstyre> > foldr (.) id $ replicate 5 (+1) $ 0
17:02:05 <lambdabot>   The first argument of ($) takes one argument,
17:02:05 <lambdabot>  but its type `[a0 -> a0]' ha...
17:02:26 <Nisstyre> -_-
17:02:32 <Peaker> > (foldr (.) id $ replicate 5 (+1)) 0
17:02:35 <lambdabot>   5
17:02:47 <Peaker> $ is right-associative :-(
17:02:51 <Nisstyre> yeah see I screw up $ all the time
17:02:59 <bacon1989> yeah
17:03:07 <bacon1989> it just seems like lately i've been messing it up with function composition
17:04:10 <Peaker> kini, with laziness, lowest-precedence is more likely to happen "first" than highest-precedence..
17:04:27 <kini> Peaker: right, that's why I put "first" in quotation marks :)
17:04:37 <bacon1989> haha
17:04:51 <bacon1989> the laziness is pretty rediculous
17:05:08 <bacon1989> was able to parse a 2gb file into a database using hGetContents
17:05:43 <bacon1989> (==) mind blown
17:06:34 <monochrom> "applied first when breaking down the structure of an expression" is correct. it says structure of expression, not evaluation order
17:28:21 <nejucomo> :t fix
17:28:23 <lambdabot> (a -> a) -> a
17:30:30 <nejucomo> :t splitAt
17:30:31 <lambdabot> Int -> [a] -> ([a], [a])
17:31:34 <nejucomo> I want to splitAt n repeatedly to produce a (chunks, leftOver) where every element of chunks has length n.
17:31:48 <nejucomo> What's a concise way to implement this (or a stdlib function)?
17:32:08 <mauke> Data.List.Split
17:32:49 <nejucomo> -except I need :: Int -> ByteString -> ([ByteString], ByteString)
17:35:51 <xFCoEx> :i SockAddr
17:36:55 <xFCoEx> :t SockAddrInet
17:36:57 <lambdabot> Not in scope: data constructor `SockAddrInet'
17:39:06 <crdueck> if I have a try $ a >>= b >>= c >> d expression, and an exception is thrown in a, b, or c, is d ever executed?
17:41:03 <xFCoEx> @run replicate 10  "arg"
17:41:04 <lambdabot>   ["arg","arg","arg","arg","arg","arg","arg","arg","arg","arg"]
17:41:10 <monochrom> no
17:43:00 <crdueck> monochrom: that was directed at me?
17:43:16 <monochrom> yes
17:43:29 <crdueck> alright thanks
17:51:57 <Peaker> data Foo a = A a | B Bar       how do I make a lens Traversal of all Bars in: Foo Bar   without manually pattern matching Foo (i.e: reusing auto-generated lenses)?
18:14:01 <bacon1989> I have a problem that i'm not too sure how to fix involving IO
18:14:10 <bacon1989> if I have a file
18:14:14 <bacon1989> that's say 2gb
18:14:27 <bacon1989> and I read it with hGetContents, it should be lazy
18:14:59 <bacon1989> but, what i'm currenlty doing is reading this file, parsing it into a list, and executing ms sql statements
18:15:20 <bacon1989> so I guess what I was wondering
18:15:50 <bacon1989> is their a way to use HDBC in such a way to process each individual parsed line from a mapping before moving onto the next element in thelist?
18:15:55 <bacon1989> and how would I go about doing that?
18:15:59 <monochrom> depending on the parser, the whole program may be lazy or not lazy
18:16:09 <bacon1989> c:/Users/benzap/Desktop/Projects/databasesClass/build $ ./main.exe
18:16:20 <bacon1989> woops, see
18:16:24 <bacon1989> i've been running it lol
18:16:41 <bacon1989> i'm trying to parse a file and insert it into a database
18:16:51 <bacon1989> and i keep getting 'out of memory'
18:17:17 <bacon1989> I have something like
18:17:19 <bacon1989>   theContent <- IO.hGetContents handle
18:17:21 <bacon1989>   return $ map P.parseLine_article_category $ lines theContent
18:17:44 <monochrom> that is lazy
18:17:51 <bacon1989> however
18:18:08 <monochrom> or rather, line-by-line lazy. if you have a 1GB line, you're hosed
18:18:10 <bacon1989> hmm i'll just post my code
18:18:25 <bacon1989> each line is small
18:19:05 <hpaste> bacon1989 pasted “Spot the unlazy” at http://hpaste.org/81501
18:19:16 <bacon1989> http://hpaste.org/81501
18:19:45 <fluffynukeit> hi all.  I want to expand a windows filepath shortcut when writing out a file.  For example, I want to put "%APPDATA%" into the file path in order to write a config file into the typical location on windows 7.  Any idea how to do this?
18:20:04 <lispy> "In short, on a register-rich architecture we believe that eval/apply would outperform push/enter by a significantly greater margin than on x86." <-- must be good news for the x86_64 and ARM ports of GHC
18:20:21 <bacon1989> so i'm assuming that mapM_ is not lazy
18:21:53 <monochrom> mapM_ is lazy on the list
18:22:02 <bacon1989> I had no issues populating my first two tables in my database
18:22:07 <bacon1989> but they were around 1gb and 100mb
18:22:19 <bacon1989> this one, however, is 2gb
18:22:28 <bacon1989> and it uses 2gb of memory
18:22:42 <monochrom> you have: [ ...x...y... | x <- map fst list, y <- map snd list ]. focus on that OK?
18:22:50 <Peaker> > mapM_ (const Nothing) $ [1..]
18:22:52 <lambdabot>   Nothing
18:23:34 <bacon1989> monochrom: are you suggesting that list comprehensions are not lazy?
18:23:44 <monochrom> let's even shrink it to [f x y | x<-map fst list, y <- map snd list]. first of all do you know what it does? in terms of what answer, rather than cost first
18:24:11 <Peaker> bacon1989, laziness does not magically mean constant memory size. If you keep around a reference to the head of a large list, it will take a lot of memory, whether the evaluation is lazy or not
18:24:14 <monochrom> list comprehension is lazy and it still doesn't matter
18:24:38 <bacon1989> hmm
18:24:52 <bacon1989> so there's something holding onto the head of the list, and I need to try and pipe it better?
18:25:10 <monochrom> do you want to answer my question?
18:25:44 <bacon1989> oh
18:26:11 <bacon1989> for ....x...y.... it produces a list from (x,y)
18:26:22 <bacon1989> i don't really know what ...x...y.... is though
18:26:35 <monochrom> [f x y | x<-map fst list, y <- map snd list]
18:27:11 <bacon1989> so it produces a list of functions consisting of the first element of the list of tuples and the second element of the list of tuples
18:27:18 <monochrom> list = [(1,'a'), (2,'b')]. what is [f x y | x<-map fst list, y <- map snd list]? be concrete
18:27:49 <bacon1989> [ (f 1 'a'), (f 2 'b')]
18:27:58 <monochrom> that is a wrong answer
18:28:11 <monochrom> [f 1 'a', f 1 'b', f 2 'a', f 2 'b']
18:28:19 <bacon1989> oh poop
18:28:29 <bacon1989> i need to replace , with
18:28:32 <bacon1989> |
18:28:33 <bacon1989> ?
18:28:52 <bacon1989> crap, I made this same mistake last time as well
18:28:57 <byorgey> > map (uncurry f) [(1,
18:28:59 <monochrom> and the cost for that answer: at some stage, the whole list [(1,'a'), (2,'b')] is fully generated and stays in memory
18:28:59 <lambdabot>   <hint>:1:21: parse error (possibly incorrect indentation)
18:29:08 <byorgey> > map (uncurry f) [(1, 'a'), (2,'b')]
18:29:10 <lambdabot>   Ambiguous type variable `b0' in the constraints:
18:29:10 <lambdabot>    (GHC.Show.Show b0)
18:29:10 <lambdabot>     ...
18:29:29 <bacon1989> that makes so much sense
18:29:38 <bacon1989> so it's basically like a cross product, right?
18:29:45 <bacon1989> there's no way in hell that last one was finishing
18:29:54 <monochrom> catList = zipWith (\(x,y) -> [HDBC.toSql (x::String), HDBC.toSql (y::String)] ) list
18:30:07 <monochrom> yes, cross product is exactly right
18:30:19 <bacon1989> thanks a lot
18:30:27 <bacon1989> i'll test out that zipWith
18:30:33 <monochrom> yikes, not zipWith. map.
18:30:49 <monochrom> catList = map (\(x,y) -> [HDBC.toSql (x::String), HDBC.toSql (y::String)] ) list
18:31:08 <monochrom> there is also a "parallel list comprehension" notation. I still haven't learned it
18:31:24 <bacon1989> yeah, I applied that on the previous two
18:31:31 <bacon1989> that's probably why they worked
18:31:41 <monochrom> but I hate having both "map fst list" and "map snd list" anyway!
18:32:03 <monochrom> oh! i see that now. | heh
18:33:27 <bacon1989> I don't really understand how map works with this?
18:33:36 <bacon1989> x and y are being mapped to each tuple?
18:33:54 <bacon1989> oh wait... is this that a pattern (x,y)?
18:34:00 <monochrom> yes, pattern matching
18:34:18 <bacon1989> ok, yeah I still have a lot to learn :)
18:34:22 <monochrom> each tuple is shoehorned into (x,y)
18:34:39 <monochrom> but changing "," to "|" works
18:36:01 <bacon1989> hmm
18:36:12 <bacon1989> i'm still getting rediculous memory usage
18:36:19 <bacon1989> i'm gonna see if I get out of memory
18:36:33 <bacon1989> that might not be the only issue with my code
18:37:05 <bacon1989> I feel like mapM_ (HDBC.execute stmt) catList
18:37:18 <bacon1989> isn't lazy, just because of the HDBC.execute
18:38:39 <monochrom> no. HDBC.execute sees one item from the list only. it doesn't even know there is a list
18:39:27 <monochrom> mapM_ is the one dealing with the list, but it is nice. it asks for head, calls HDBC.execute, repeat. it doesn't ask for the whole list upfront
18:39:33 <bacon1989> please ignore what I just said, I just didn't compile it when I ran it again
18:39:35 <bacon1989> :S
18:39:40 <monochrom> hahaha OK!
18:39:50 <bacon1989> it's using a steady 4mb now
18:39:52 <bacon1989> woop
18:39:56 <monochrom> good good
18:40:57 <bacon1989> yeah, that's what I assumed
18:41:04 <bacon1989> but I was worried about commit
18:41:15 <bacon1989> as though maybe the overhead was due to mssql acting up
18:41:25 <bacon1989> but I doubt that would be stored in memory
18:41:32 <monochrom> I see
18:45:30 <meretrix>  Hi. What's the easiest way to pass [SqlValue] to a data type constructor? I want to do something like "MyType $ map fromSql sqlValueList".
18:46:13 <meretrix> Is it possible to split the list over the required parameters?
18:46:35 <Clint> so you don't want [MyType]?
18:47:24 <meretrix> No. MyType is defined as "data MyType = MyType { x :: String, y :: Double, etc..}
18:47:55 <meretrix> I want to shove the list of values into a single type.
18:48:32 <Eduard_Munteanu> What's in an SqlValue?
18:49:30 <monochrom> case sqlValueList of [a,b] -> MyType (fromSql a) (fromSql b)
18:50:06 <monochrom> note: cannot "map fromSql list", type error, there is no such thing as ["web", 2.0]
18:51:02 <meretrix> Ah right.. ok so I have to type out each parameter then.
19:14:46 <amiller_> bah, now i think this Generic Storage paper is hopelessly flawed, because it fundamentally relies on a very strange quirk of lazy unsafeInterleaveIO
19:17:10 <sipa> amiller_: which quirk?
19:19:04 <amiller_> well, the quirk is that you can observe the effects in a different order than you would if you collected them programatically
19:19:40 <amiller_> i don't think i'm explaining that terribly clearly, but it looks like it's exactly what 'unsafe interleave io' means :p
19:20:17 <amiller_> glance at this gist: https://gist.github.com/4659219 or this paper if you're interested http://www.andres-loeh.de/GenericStorage/wgp10-genstorage.pdf
19:21:07 <amiller_> i have an action in the IO monad that prints a sequence of strings
19:21:29 <sipa> unsafe interleave io is dirty :)
19:21:34 <amiller_> what i wanted to do is replace it with an action in State [String] that just collects the strings so i can look at them later
19:22:01 <amiller_> but, i don't get the same sequence i origianlly observed, since i was observing the unsafe interleaved io
19:22:22 <amiller_> (at least writing this out has made me feel better that it's obvious!)
19:29:05 <tieTYT2> oh wow, I just discovered on accident that you can use point free notation on the lambdas you pass into higher order functions: fromList' = foldr (\(a, b) -> Map.insert a b) Map.empty
19:29:18 <tieTYT2> I forgot the second parameter of foldr's lambda
19:30:15 <shachaf> There's no such thing as point free notation.
19:30:30 <shachaf> It's just how Haskell works. There's no notation to it.
19:54:55 <YayMe> Is there a common function for foldl1 (>>)
19:56:48 <ion> yayme: These both have a different result value, but sequence and sequence_
19:57:05 <ion> fmap last . sequence
19:57:19 <YayMe> yeah last . sequence was as close as I was figuring
19:57:43 <YayMe> > sequence [Right 1, Left 2, Right 3, Left 4]
19:57:44 <lambdabot>   Left 2
19:58:11 <YayMe> ion: at that point, is it any easier to use that then foldl1 (>>) ?
19:58:49 <YayMe> > sequence_ [Right 1, Left 2, Right 3, Left 4]
19:58:51 <lambdabot>   Left 2
20:00:14 <YayMe> > sequence [Right 1, Right 2, Right 3]
20:00:16 <lambdabot>   Right [1,2,3]
20:00:37 <YayMe> > sequence_ [Right 1, Right 2, Right 3]
20:00:39 <lambdabot>   Right ()
20:00:59 <YayMe> Yeah, not quite getting it. think I'll stick with foldl1 (>>)
20:15:56 <latermuse> what is the monomorphism restriction?
20:16:56 <shachaf> @google what is the monomorphism restriction?
20:16:57 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
20:16:57 <lambdabot> Title: Monomorphism restriction - HaskellWiki
20:16:59 <Canar> If the Power Rangers was written in Haskell, they wouldn't be able to join together to make Megazord.
20:17:08 <Canar> That's the monomorphism restriction. ;)
20:17:10 <simon> I'm guessing f . g1 = f . g2  =>  g1 = g2
20:19:42 <shachaf> Guessing what?
20:20:31 <simon> I didn't know that the monomorphism restriction had a specific Haskell meaning, so I just googled monomorphism and found that law.
20:22:36 <simpson> I'd read the wiki entry.
20:28:18 <simon> yeah. :)
20:29:53 <fragamus> @hoogle [Maybe a] -> [a]
20:29:53 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
20:29:53 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
20:29:53 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
20:44:18 <fragamus> @pl "ox" !! (length (filter (==' ') s)  `mod` 2)
20:44:18 <lambdabot> "ox" !! (length (filter (' ' ==) s) `mod` 2)
20:45:34 <geekosaur> you didnt tell it what it could remove
20:45:52 <geekosaur> @pl \s -> "ox" !! (length (filter (==' ') s)  `mod` 2)
20:45:53 <lambdabot> ("ox" !!) . (`mod` 2) . length . filter (' ' ==)
20:47:40 <hpaste> Nejucomo pasted “refactoring fixed size "chunking" of ByteString” at http://hpaste.org/81514
20:47:58 <nejucomo> If anyone can suggest a cleaner way to do that, I'm all ears.
20:51:41 <fragamus> @pl Just (s & element i .~ (ox s))
20:51:41 <lambdabot> (line 1, column 22):
20:51:41 <lambdabot> unexpected "~"
20:51:41 <lambdabot> expecting white space
20:51:41 <lambdabot> ambiguous use of a right associative operator
20:56:58 <shergill> i want to override the constraints as specified in a package $foo's cabal file
20:57:42 * hackagebot peggy 0.3.2 - The Parser Generator for Haskell  http://hackage.haskell.org/package/peggy-0.3.2 (HideyukiTanaka)
20:57:48 <shergill> is there any other way than to download and modify the package locally?
20:59:59 <geekosaur> --constraint="foo == 1.0.0"
21:01:28 <shergill> geekosaur: if the cabal file lists 'foo < 0.9' that doesn't seem to override it
21:03:33 <osejniwde> how do i distribute haskell without source code?
21:04:02 <hpaste> Heatsink annotated “refactoring fixed size "chunking" of ByteString” with “refactoring fixed size "chunking" of ByteString (annotation)” at http://hpaste.org/81514#a81516
21:04:31 <heatsink> osejniwde, You can distribute a compiled binary
21:04:44 <osejniwde> the *.hi file?
21:05:01 <heatsink> The executable file
21:05:06 <heatsink> On Windows, it has an exe suffix
21:05:34 <osejniwde> heatsink: but what if i want to distribute a library?
21:05:45 <osejniwde> heatsink: without source
21:05:54 <simpson> osejniwde: Why would you do this?
21:05:56 <geekosaur> --constraint looks to be the biggest hammer, so I guess you can't override, sorry
21:06:08 <osejniwde> simpson: because i choose to
21:06:37 <geekosaur> osejniwde, ghc doesn't really support that; the way it handles cross-module inlining means that a given binary library has extremelytight constraints on where it will work
21:07:03 <osejniwde> geekosaur: ok thanks
21:07:07 <geekosaur> and you can probably neither drop it into another haskell environment and have it work, nor drop a replacement into such an environment and have it work
21:07:10 <heatsink> More generally, Haskell doesn't have an ABI specification, so different Haskell compilers are incompatible with each other.
21:07:34 <osejniwde> heatsink: hmm interesting
21:07:38 <simpson> You can certainly build libraries that use C linkage, though.
21:07:42 * hackagebot msgpack 0.7.2.5 - A Haskell implementation of MessagePack  http://hackage.haskell.org/package/msgpack-0.7.2.5 (HideyukiTanaka)
21:08:14 <osejniwde> simpson: yes but then every haskell file using another haskell library will have to do it though FFI
21:08:39 <simpson> osejniwde: Which is why it's better for everybody in the community if you don't try to hide your source.
21:09:25 <pharaun> hows iospec
21:09:25 <osejniwde> simpson: ok i will jump into this debate. if only there is a such a thing as a community can we expect somebody to do work for free
21:09:41 <pharaun> i've pondered about testing/controling my IO monad
21:10:45 <osejniwde> simpson: haskell community can't even document their libraries for free like say the ruby community or python community or scheme community etc does
21:10:54 <simpson> osejniwde: Well, this is Haskell. If your types are sufficiently interesting, most of the functions around those types will have obvious or simple implementations.
21:11:25 <osejniwde> simpson: i can't guess the function of reverse from its type
21:11:35 <simpson> Yeah, lists are pretty flexible. :3
21:11:50 <simpson> But you can probably guess it from the type and "reverses the order of a list."
21:12:44 * hackagebot msgpack-idl 0.2.1 - An IDL Compiler for MessagePack  http://hackage.haskell.org/package/msgpack-idl-0.2.1 (HideyukiTanaka)
21:12:46 * hackagebot CurryDB 0.1.1.0 - CurryDB: In-memory Key/Value Database  http://hackage.haskell.org/package/CurryDB-0.1.1.0 (HideyukiTanaka)
21:12:51 <osejniwde> simpson: yes that second part is missing. plus a lot of libraries are maintained by just one person. if that person disappears the library users will have to maintain it on their time
21:13:18 <osejniwde> osejniwde: in popular FOSS products there are more than one contributers
21:13:22 <simpson> osejniwde: This sounds like every closed-source-vs-open-source argument.
21:13:27 <simpson> Also stop talking to yourself. :3
21:13:45 <osejniwde> simpson: thanks. that is why i said i would jump into this debate
21:13:56 <Hafydd> Typical closed-source argument: "I have a compelling reason why I'm right, but it's proprietary."
21:14:12 <osejniwde> simpson: thanks for trying to potray me as an idiot and greedy
21:14:22 <simpson> osejniwde: Okay, fine.
21:14:34 <simpson> osejniwde: You're completely and totally right about everything.
21:14:40 <simpson> I'm clearly wrong here.
21:14:56 <osejniwde> simpson: rationality is not same as infallibility or omniscience
21:15:00 <osejniwde> got to go
21:15:11 * Clint squints.
21:19:14 <isomorphic> Does anybody know a good way of doing a multi-line evaluation in mueval?
21:21:51 <hagamoto> hi
21:22:02 <hagamoto> i know nothing about haskell
21:22:46 <tac> hi hagamoto
21:22:56 <tac> hagamoto: would you like to learn some?
21:23:10 <YayMe> hagamoto: neither do the vast majority of devs
21:23:23 <YayMe> > head [1,2,3]
21:23:25 <lambdabot>   1
21:23:31 <YayMe> > last [1,2,3]
21:23:32 <lambdabot>   3
21:23:39 <YayMe> hagamoto: Now you know something about haskell :)
21:23:48 <YayMe> welcome to the minority
21:24:42 <tac> @let even 0 = True; even 1 = False; even n = even (n-2)
21:24:43 <lambdabot>  <local>:3:41:
21:24:43 <lambdabot>      Ambiguous occurrence `even'
21:24:43 <lambdabot>      It could refer to either...
21:24:52 <tac> @type even
21:24:53 <lambdabot> Integral a => a -> Bool
21:24:55 <tac> doh
21:24:58 <YayMe> heh
21:25:03 <tac> > filter even [0..]
21:25:05 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
21:25:13 <tac> now you have a list of even numbers
21:25:18 <tac> in fact, all of them
21:25:19 <YayMe> hagamoto: What brings you here?
21:26:36 <YayMe> tac: nah, it won't turn over into string number concatenation tricks when it overflows a ulong will it?
21:27:02 <tac> YayMe: what now?
21:27:33 <tac> oh, when the int overflows?
21:27:39 <newsham> yayme: you can get finite precision Ints or non-overflowing Integers
21:27:45 <tac> > filter even [0 :: Integer..]
21:27:47 <tac> BAM
21:27:47 <lambdabot>   <hint>:1:19: parse error on input `Integer..'
21:27:49 <tac> damnit
21:27:53 <newsham> > maxBound :: Int
21:27:53 <YayMe> haha
21:27:55 <lambdabot>   9223372036854775807
21:27:55 <tac> > filter even [(0 :: Integer)..]
21:27:56 <newsham> > maxBound :: Integer
21:27:58 <tac> BAM
21:27:58 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
21:27:58 <lambdabot>   can't find file: L.hs
21:28:11 <tac> so much arbitrary size integers you can't even laugh
21:28:29 <YayMe> lambdabot doesn't like multiple inquiries at once lately I noticed
21:28:34 <YayMe> complains about L.hs heh
21:28:39 <newsham> lambdabot is broked
21:28:46 <arbn> > filter even [(-1 :: Integer), -2..]
21:28:48 <newsham> she's not been taking good care of herlse
21:28:49 <lambdabot>   [-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30,-32,-34,-36,-38,-4...
21:28:50 <newsham> herself
21:28:57 <arbn> tac: You forgot some even integers. :P
21:28:59 <geekosaur> race condition
21:29:06 <tac> arbn: psh. "negative numbers"
21:30:19 <newsham> > [0..] >>= (\n -> [n, negate (n+1)])
21:30:21 <lambdabot>   [0,-1,1,-2,2,-3,3,-4,4,-5,5,-6,6,-7,7,-8,8,-9,9,-10,10,-11,11,-12,12,-13,13...
21:30:33 <YayMe> > maxBound :: Integer
21:30:36 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
21:30:36 <lambdabot>    arising from...
21:30:51 <shachaf> hi newsham
21:31:08 <newsham> hi
21:31:12 <fragamus> @hoogle ([a],[a])->[a]
21:31:13 <lambdabot> Network.CGI.Protocol formEncode :: [(String, String)] -> String
21:31:13 <lambdabot> Network.CGI formEncode :: [(String, String)] -> String
21:31:13 <lambdabot> Network.HTTP.Base urlEncodeVars :: [(String, String)] -> String
21:31:28 <hagamoto> I want to learn haskell
21:31:37 <fragamus> you and everyone here
21:31:40 <hagamoto> i know erlang
21:31:40 <newsham> hagamoto: thats the first step
21:31:51 <hagamoto> so maybe I can get haskell too
21:32:07 <tac> > filter evens (map ints' [0..])
21:32:08 <lambdabot>   Not in scope: `evens'
21:32:09 <lambdabot>  Perhaps you meant `even' (imported from Prelude)
21:32:41 <hagamoto> and use it on the job
21:33:01 <YayMe> if you already know erlang you're a lot further along towards getting Haskell than most, especially wankers like me who spend all their time writing imperative code
21:33:02 <tac> > filter even (map ints' [0..])
21:33:05 <lambdabot>   [0,2,-2,4,-4,6,-6,8,-8,10,-10,12,-12,14,-14,16,-16,18,-18,20,-20,22,-22,24,...
21:33:19 <tac> arbn: ^ There. I gave you the rest
21:33:30 <YayMe> hagamoto: You use erlang on the job?
21:33:36 <arbn> tac: :)
21:33:37 <hagamoto> i will soon
21:34:04 <hagamoto> maybe haskell too
21:34:04 <tac> arbn: just be careful. If you just had an uncountable many more, Cantor would have gotten on your ass about such a function.
21:34:13 <hagamoto> so I should get going on it
21:34:21 <YayMe> hagamoto: You just get to use any language in your job?
21:34:37 <arbn> tac: Give me the set of all subsets of the positive integers! :P
21:34:38 <latermuse> YayMe: I get to too.
21:34:48 <YayMe> hagamoto: Or did you just get hired somewhere that does those languages?
21:34:50 <hagamoto> I get to use any language the smart guy in charge finds appropriate for a project
21:34:54 <YayMe> latermuse: lucky jerk. freelancer?
21:35:01 <hagamoto> the company uses erlang now
21:35:01 <tac> arbn: You're a mad man!
21:35:12 <latermuse> YayMe: Nope. Im just the wildcard ;)
21:35:23 <hagamoto> the smart guy is trying to work in haskell I think
21:35:23 <YayMe> hagamoto: Lucky you
21:35:23 <latermuse> research and development etc etc
21:35:27 <hagamoto> yeah
21:35:33 <Adeon> madness
21:35:35 <YayMe> latermuse: and work somewhere that apparently isn't on lockdown
21:36:04 <latermuse> YayMe: I work for one of the biggest websites
21:36:19 <hagamoto> latermuse: congrats
21:36:25 <YayMe> latermuse: can I? pretty please? hehe
21:36:40 <M30W> Could anyone here give me an example for how zippers could be used in a text adventure game?
21:37:06 <YayMe> I should go spend time on zippers...
21:37:17 <ninegrid> M30W: http://en.wikibooks.org/wiki/Haskell/Zippers
21:37:42 <M30W> ninegrid: I've seen this already.
21:37:55 <ninegrid> M30W: "DRY"
21:38:00 <M30W> ninegrid: ?
21:38:08 <ninegrid> Don't Repeat Yourself
21:39:10 <M30W> ninegrid: I am asking for an example of code that could be used to base a text adventure's room configuration.
21:39:27 <latermuse> YayMe: I get a lot of freedom, but it doesnt pay so well ;(
21:39:28 <ninegrid> M30W: ... that is what the article describes
21:41:10 <M30W> ninegrid: Yea, describes but doesn't have a full example of code that could be used to store the rooms
21:41:35 <tac> So I went to a hackerspace for the first time today
21:41:39 <M30W> It's almost only theory.
21:41:48 <arbn> tac: How was it? Hardware or software, mostly?
21:41:51 <tac> and I had realized... I have no idea what use Haskell is to the average person trying to solve real world problems
21:42:05 <tac> It was a good mix. Mostly hardware, but I talked to some python people there for a good part of it.
21:42:24 <ninegrid> M30W: what? ... looks pretty applied from where i'm sitting
21:42:42 <tac> All I could think of is it's good for writing code that's correct or building long-term, maintainable things.
21:42:55 <ninegrid> M30W: you could try to use google and type "haskell game text adventure" into the search box, you'll get results of people disclosing their source code
21:43:00 <tac> (But really, it isn't... yet.... because it's still stuck half-way in academia)
21:43:14 <tac> (compared to say, Python, Java, C#, any of them)
21:43:18 <arbn> tac: Doesn't everyone always need to write that's correct?
21:43:18 <M30W> ninegrid: None
21:43:22 <M30W> I've searched
21:43:40 <arbn> M30W: LambdaHack? Not sure if it uses zippers, but it's an engine for roguelikes.
21:44:03 <tac> arbn: I think correctness up-to-I-give-a-shit is the more important factor to most people D:
21:44:04 <M30W> Thanks
21:44:11 <ninegrid> M30W: http://ted.appspot.com/read/Haskell/AdventureGame.hs
21:44:16 <tac> (not to me. If it's not 100% correct, then it's 100% wrong)
21:44:50 <M30W> ninegrid: hmm
21:45:25 <arbn> tac: Haskell also seems to minimize keystrokes. Not as much as, say, an APL-descendant, but my Haskell code is more concise than what I would write in Python.
21:45:40 <fragamus> @pl "ox" !! ((ns s) `mod` 2)
21:45:40 <lambdabot> "ox" !! (ns s `mod` 2)
21:45:57 <tac> arbn: I'm not sure it always is.
21:46:08 <tac> not to say it couldn't be
21:46:34 <M30W> fragamus: lol. Use /msg lambdabot @pl :)
21:47:22 <fragamus> but then everybody wouldn't be able to see
21:47:37 <fragamus> :P
21:47:49 <ninegrid> M30W: here's a trove of zipper information http://okmij.org/ftp/continuations/zipper.html
21:47:58 <tac> fragamus: that's the argument *I* gave
21:49:08 <M30W> Lots to learn with zippers
21:49:38 <M30W> Strange looking trees. And someone said that they can refer in loops but I can't see any way for that?
21:49:44 <arbn> And zippers are a slippery slope leading to comonads.
21:49:56 <edwardk> and lenses
21:49:58 <YayMe> tac: Welcome to what industry has felt all along. Though I'm not certain I completely believe it 100%, there is tons of room where haskell can do things better for someone trying to get-it-done, just so few people realize that or where those spaces are. Everytime someone thinks of writing a state machine in a non FPL they should start walking on their hands because they're upside down
21:50:02 <shachaf> i love lenses
21:50:07 <shachaf> they are so easy
21:50:18 <YayMe> I heard that was monoids
21:50:27 <edwardk> > rezip $ zipper ("hello","world") & downward _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y'
21:50:30 <lambdabot>   ("jelly","world")
21:51:23 <M30W> Crazy man you are edwardk =)
21:51:32 <tac> YayMe: tru.
21:51:46 <tac> I guess I should come up with a good list of things that FPLs are great for
21:51:47 <ninegrid> i wanna look at that in vacuum
21:51:51 <M30W> What do you like more? Lenses or ... life?
21:51:53 <M30W> :)
21:52:56 <edwardk> lenses are a passing addiction ;)
21:53:10 <M30W> You are obsessed :P
21:53:11 <edwardk> i'll be onto something else that just abuses them heavily soon enough
21:53:14 <arbn> YayMe: Comonads are just one of the things monoids are good for. :P
21:53:46 * tac wish he understood comonads or lenses better
21:53:46 <YayMe> tac: any time you get any fixed-format type data, which a ton of software does. Any software that interfaces with devices or old-school software is going to run into this.
21:54:03 <tac> fixed format?
21:54:20 <tac> You mean fixed bitlength or something?
21:54:25 <YayMe> basically
21:54:28 <YayMe> doesn't have to be binary
21:54:53 <ihm> Hayes
21:55:02 <YayMe> could be ascii
21:55:03 <arbn> tac: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html <-- When I re-read this *slowly*, I felt that the use of comonads actually clicked for me.
21:55:40 <tac> yeah
21:55:43 <tac> I should walk through this example
21:55:51 <arbn> Still working on the lenses bit... :/ I don't quite get those yet.
21:55:56 <tac> It makes a difference when you actually code things up yourself
21:56:03 <ihm123> pl \x -> f x == g x
21:57:15 <ninegrid> arbn: i actually reproduced that in F#
22:00:21 <arbn> ninegrid: Is Comonad a very useful API in F#?
22:00:38 <ninegrid> it has no notion of such a thing
22:00:45 <ninegrid> at least, not built in
22:00:46 <YayMe> tac: and to be honest though, there's something to be said for the get-it-doneability when you can define your entire data model of 15 different types in 20 lines, and they're perfectly readable and understandable, the densisty is difficult sometimes but in the data type definitions it actually works beautifully
22:01:02 <ninegrid> making use of delayed execution using an object wrapper
22:01:06 <ninegrid> i can digup the source
22:01:09 <edwardk> arguably moreso that in haskell. same with in scala. in scala comonads are really useful because monad transformers in scala are utter crap
22:01:36 <edwardk> you can also use the comonad for things like futures which would want to live as comonads on a kleisli category here in haskell
22:01:59 <edwardk> in haskell i tend to use a lot more 'little comonads'
22:02:10 <YayMe> I think I like kleisli operator more than bind.
22:02:49 <arbn> edwardk: Ah. Interesting. I'll keep that in mind when I next attempt to code in Scala.
22:03:13 <edwardk> well what i mean by that is you wind up with something that would be a comonad except it needs some monadic effect sprinkled throughout.
22:03:39 <tac> edwardk: you would probably know this better than everyone. Is there an actual technical reason we use IO instead of OI?
22:03:51 <edwardk> tac: yeah, OI doesn't work
22:03:53 <tac> Or is it just a historical thing that we prefer monads to comonads?
22:04:15 <edwardk> every functor in haskell is 'strong'  http://comonad.com/reader/2008/deriving-strength-from-laziness/
22:04:38 <edwardk> this and the bias for values over continuations in our syntax pushes us in a direction where monads are stronger than comonads.
22:05:02 <tac> What is a strong functor? In plain english... or in plain category theory? :)
22:05:04 <edwardk> every comonad gives rise to a monad, not only that it gives rise to a monad-transformer. so OI would give rise to an IO monad transformer,
22:05:13 <edwardk> tac: thats the point of that post ;)
22:05:26 <edwardk> anyways strength basically destroys the argument for OI.
22:05:42 <edwardk> even in the original kieburtz paper its more a straw man of an idea than a concrete proposal
22:05:48 <M30W> nimred: The text adventureGame.hs you linked me to works without zippers for navigation.
22:05:51 <YayMe> edwardk: comonads are better for continuations?
22:06:01 <M30W> Kinda like how my current game works
22:06:17 <YayMe> s/better/good/
22:06:24 <tac> ah, I see the definition now
22:06:26 <edwardk> YayMe: no, but effectively strength is priveleged over costrength, and there are lots of consequences of not having an entirely cps'd world
22:07:04 <tac> ergg. Category Theory on wikipedia D:
22:07:27 <lispy> edwardk: what's an nsequence?
22:07:40 <edwardk> lispy: =P
22:07:41 <tac> "A strong monad over a monoidal category is a monad and a nat. trans such that these 3 enormous, unexplained diagrams commute
22:07:44 <YayMe> lispy: node.js
22:07:58 <M30W> nimred: Sorry wrong nick
22:08:01 <M30W> ninegrid: ^^^^^^
22:08:05 <tac> like any good math entry, I'm sure it's taken straight from some grad student's textbook
22:08:08 <edwardk> tac: a strong functor is one you can take (a, f b) -> f (a, b)  in a way you'd expect
22:08:16 <edwardk> in haskell, thats all of them
22:08:22 <tac> ah
22:08:32 <edwardk> costrength is f (Either a b) = Either (f a) b
22:08:36 <edwardk> thats much much more rare
22:08:58 <edwardk> ou need to be able to visit all the parts of 'f'
22:09:06 <shachaf> Costrength means "boring functor".
22:09:10 <edwardk> so traversable can play the role of a poor man's costrength
22:09:18 <edwardk> but its a little bigger than you want
22:09:32 <tac> This category theory is still beyond my level.
22:09:32 <edwardk> since you really want 'finitely traversable'
22:09:39 <tac> but thank you anyhow :)
22:09:47 <edwardk> just ignore the category theory
22:09:47 <edwardk> and look at the operation
22:09:52 <edwardk> f (Either a b) -> Either (f a) b
22:10:05 <tac> But I'd rather know the CT :)
22:10:18 <YayMe> edwardk: it feels like strength makes more sense for laziness and costrength would be more sensible for strict/eagerness (delete whichever of those two didn't make sense)
22:10:19 <edwardk> given an 'f' full of values, we want to prove there are no 'b's or give you one as proof there are some
22:10:31 <shachaf> Silly edwardk. All traversals are finite.
22:10:49 <edwardk> silly shachaf living in such a restricted world
22:10:51 <YayMe> edwardk: is that accurate to say in the common case or a stretch?
22:11:31 <shachaf> I call it "the real world".
22:11:34 <shachaf> It's restricted indeed. :-(
22:12:25 * shachaf actually thinks edwardk's argument is reasonable.
22:12:27 <edwardk> shachaf: i call it 'coq'. and playing with it can make you blind.. to the fact that in haskell we use infinite traversals all the time =P
22:13:08 <YayMe> if all traversals are finite and you're saying traversals are examples of costrength, I'm going to think it is reasonable to think costrength better in strictness and strength better in laziness
22:13:28 <edwardk> YayMe: in that sense its true
22:13:54 <edwardk> YayMe: was distracted =)
22:14:00 <shachaf> My arguments never involved roconnor's proofs. They were just along the lines of "associativity is requires, and it doesn't make sense in an infinite context".
22:14:09 <shachaf> Your argument was that the requirement was actually weaker than associativity.
22:14:36 <YayMe> No worries. Then that alone goes as good enough explanation why monads are so much more first class than comonads in haskell, cuz haskellers are lazy
22:14:46 <edwardk> no, the requirement is associativity. congratulations i give you the ability to use associativity, but nothing is infinite in a computational context. i can't do anything an infinite number of times before doing something else
22:15:10 <edwardk> YayMe: be careful. because there are monads that are codata and comonads that are data.
22:15:25 <edwardk> YayMe: its easy to be drawn into false dichotomies
22:15:34 <YayMe> edwardk: I don't have to be careful of that because I have no idea what it means! :D
22:15:36 <shachaf> My problem was with things like FMList.
22:15:51 <tac> IO is a codatical monad
22:15:56 <ninegrid> arbn: I had to extract some archives, here it is http://codepad.org/TdnD14IR and the output http://codepad.org/TY1TRRYP
22:16:23 <tac> How else do you loop in a total program? You need to stuff it in a codatical monad of some kind and fake "forever"
22:16:37 <YayMe> I've learned not to take any generalizations with but a grain of salt, there are too many overly clever haskellers proving and disproving every generalization that even they accept
22:17:10 <arbn> ninegrid: Ah. Cool.
22:17:28 <lispy> YayMe: I sometimes worry that #haskell is devolving into a less friendly atmosphere.
22:17:39 <tac> psh us?
22:17:44 <YayMe> ...codatical.. I am totally going to sleep now with that word added to my vocabulary. Thankyou, never has a word sounded closer to a funny word while being further from it at the same time
22:17:50 <edwardk> are not! *kicks lispy*
22:18:04 <tac> Kick him again! make the lesson count!
22:18:23 * lispy *cowers*
22:18:33 <ninegrid> arbn: seems codepad didn't like the output... the whole thing is here http://texas.ircgeeks.us/~dan/multiverse_2c1d
22:18:38 <tac> edwardk: How do you know so much category? Is it all just for programming? Do you have a degree in math or CS?
22:18:43 <tac> (for fun?)
22:18:59 * lispy can't read words in #haskell that start with "co" without wondering what the sans "co" word would mean
22:19:06 <YayMe> lispy: That would be dangerous because without bastions of helpful people, haskell which has endured regardless of lacking success for so long could actually die in ernest.
22:19:10 <edwardk> tac: i learned what little category theory i know through haskell. yes, yes and yes. ;)
22:19:22 <tac> cool
22:19:26 <pikhq> lispy: Indeed. How does one wers?
22:19:33 <edwardk> dolio and ddarius know a lot more category theory than i do
22:19:39 <edwardk> i just write a lot more haskell ;)
22:19:47 <lispy> pikhq: wers = roaring?
22:19:50 <pikhq> I guess.
22:19:55 <tac> I gotcha. (And yeah, they are smart cookies) :)
22:20:29 <arbn> The general consensus seems to be... learn CT if it seems fun, but it isn't necessary in order to be an expert Haskeller. I hope that's true.
22:20:31 <tac> It's kinda funny in that I would rather not have to read Haskell explanations of theories-stuff
22:20:37 <lispy> Yeah that edwardk guy, he just _acts_ like he knows haskell/CT. What a poser ;)
22:21:04 <tac> arbn: CT is totally frivolous from what I can tell.
22:21:08 <edwardk> my main strength is that i'm willing to take a core concept and rip one rule or one property off of it, and rederive the proofs in the edited context, this leads me to constructs that are lot more interesting and they force me to get to the substance of the proof of the more common objects.
22:21:13 <tac> The hard part is that other people who aren't you often like to stuff Haskell full of CT
22:22:06 <YayMe> edwardk: does learning CT make all the CT stuff in haskell totally natural, or is it helpful but you still have to learn the CT-in-haskell would you say?
22:22:21 <lispy> I was looking at SPJ's website again today. He really has an impressive publication list. So many *good* papers.
22:22:41 <tac> YayMe: From my experience, you need *something* to ground CT when you're learning it
22:22:41 * sclv_ thinks that the infinite traversals discussion is severely lombotomized by the lack of any distinction between concepts of infinity -- and use of constructive infinities in particular
22:22:54 <tac> Category Theory is weird because it applies to almost *any* kind of math subject
22:23:04 <tac> So you have to Bring Your Own Examples to class.
22:23:06 <chord> how does a functional language like Haskell implement a hash table as an array?
22:23:22 <sclv> almost anyone else would be amazingly lucky to have done like 1/8 of the papers spj has
22:23:22 <YayMe> if I can excuse learning CT with it'll make me a better haskeller I might actually try, what bit I have learned I find frankly thoroughly interesting, but I've always been drawn into frivolous mental puzzles
22:23:41 <edwardk> for instance lens takes a lot of categorical objects but it puts them together in a completely alien to a category theorist. it quantifies over things that a CT person just wouldn't. its like using a screwdriver to pick your ear.
22:24:02 <edwardk> YayMe: i had the benefit that i did a pure math degree and a pure cs degree and a long programming career before i tackled category theory (and haskell). so i had already developed a good sense of 'mathematical maturity', and as I suppose what is best summarized as  a "differential geometer" i was familiar enough with dualities to be comfortable with it.
22:24:03 <YayMe> edwardk: I used one to remove my tooth
22:24:13 <sclv> focusing on actually implementing an actual language that people actually use has given him so freaking much vis a vis the range of topics he's covered
22:24:27 <YayMe> codatical.. heh.. night all
22:24:31 <tac> night YayMe
22:24:34 <edwardk> sclv: definitely
22:24:57 <tac> sclv: SPJ is the master of all trades when it comes to programming.
22:25:12 <lispy> "<edwardk> [on the subject of lens and category theory] ...a CT person just wouldn't. its like using a screwdriver to pick your ear." <--- it's so great out of context
22:25:50 <edwardk> chord: in practice we don't. because an array is a pretty crappy data structure to manipulate purely functionally. hence why hashset is based on hash array mapped tries
22:27:08 <edwardk> chord: we have lots of things that can build arrays by summarizing over a data set all in one go rather efficiently but the common usecase of hash one thing and smash it into the table isn't a good fit. just say no to O(n) copying.
22:27:08 <tac> edwardk: Excuse me if I try to pick your brain at some point in the future about differential geometry
22:27:21 <edwardk> tac: sure. its rotting away in the back of it somewhere
22:28:02 <tac> I tried to learn a little differential geometry a couple years ago. Then, just earlier this year, I went back to some of it..
22:28:11 <tac> Knowing dependent types is such a boon
22:28:27 <tac> "A tangent bundle is just a sigma type!"
22:29:02 <tac> Of course Haskell's sigma types are weak! D:
22:29:14 <notdan> What's a tangent bundle?
22:30:15 <tac> notdan: In differential geometry, vectors are glued onto points of your space. Like, on earth, it doesn't make sense to say "left". Because left if you're in China is the opposite left if you're in Brazil.
22:30:37 <tac> So a tangent bundle is a pair of: 1) Where on Earth you are, and 2) what direction you mean
22:30:41 <edwardk> @google tangent bundle
22:30:42 <lambdabot> http://en.wikipedia.org/wiki/Tangent_bundle
22:30:42 <lambdabot> Title: Tangent bundle - Wikipedia, the free encyclopedia
22:31:04 <notdan> Ah, I see
22:33:09 <chord> edwardk: so you're saying hash table as an array performance isn't easily possible functionally?
22:34:27 <edwardk> chord: not without resorting to ST. its a different game. i give you access to every previous version of the hash table too, by just letting you hold an old one, so its a different thing in a purely functional world, a hash table is a bit of imperative ephemera. in a persistent setting some things cost an extra log factor.
22:34:40 <arbn> Huh. For some reason, I never realized that Cabal package names are case-sensitive.
22:35:00 <edwardk> if you go to implement the same properties that a functional hash table offer you in an imperative setting, amazingly the asymptotics match.
22:35:14 <chord> edwardk: ok so your job is to go back to university phd program and fix that log factor problem
22:36:11 <edwardk> chord: no. its fundamental to the universe
22:36:27 <edwardk> chord: collecting more degrees won't change this =P
22:36:42 <chord> edwardk: you give up so easily and yet you call yourself a computer scientist
22:36:46 <edwardk> you can play with substructural types to get it, you can work with clojure style ephemerons, etc.
22:36:48 <tac> lol
22:37:02 * tac has always been skeptical of computational complexity
22:37:04 <edwardk> chord: no. i just know the source of the problem. and wishing it away won't make it go away, since its provable that it exists.
22:37:05 <sclv> @quote use.a.hash
22:37:05 <lambdabot> sclv says: You have a problem and think "I'll use a hash function." Now you have intermittantly colliding problems.
22:37:21 <chord> edwardk: so you do research to find a way around the problem
22:37:58 <edwardk> chord: the proof holds regardless of implementation strategy. and i just offered you two ways around the problem =P
22:38:02 <sclv> chord: i look forward to your research on sorting in sub O(n) time
22:38:27 <chord> edwardk: so you just falsified your own proof, nice...
22:38:39 <sclv> well, this is fun
22:39:37 <edwardk> chord: no i changed the problem. i moved to a setting where i can have ephemeral objects (linear-or-uniqueness types) or where i can do mutation and you can't tell (ST)
22:40:05 <chord> edwardk: AH HA SO I CAUGHT YOU, NOW YOU ADMIT YOU CAN GET AROUND THE PROBLEM
22:40:26 <sclv> please don't shout. it's gauche.
22:41:37 <edwardk> chord: good night
22:41:43 <M30W> edwardk: Nice
22:41:58 <no-n> where's a good place to learn haskell from?
22:42:03 <M30W> chord: This channel is for support and sadly unlike in #php, it's not here do this for me. ;)
22:42:10 <M30W> no-n: Here
22:42:15 <M30W> @where lyah
22:42:15 <lambdabot> http://www.learnyouahaskell.com/
22:42:16 <M30W> There too
22:42:24 <no-n> ty
22:42:27 <M30W> Enjoy ^_^
22:42:38 <no-n> I wondered whether to read lyah or real world haskell
22:42:51 * M30W goes back to writing his text adventure with Maps and might check out zippers another time.
22:43:02 <M30W> no-n: lyah, then rwh
22:43:03 <M30W> :)
22:43:10 <no-n> but it looks like lyah is more brief, which is what I want ;)
22:43:14 <edwardk> M30W: i need to add more zipper docs to lens
22:43:18 * no-n very impatient man
22:43:48 <M30W> edwardk: Lenses too large; But if you make zipper management desierable with lenses then.... I might switch to it :P
22:44:17 <edwardk> M30W: lens isn't shrinking any time soon. and zippers in lens are already the nicest form of zipper i've ever used =P
22:44:37 <M30W> edwardk: Aren't you the one who made lenses ? ;)
22:44:45 <M30W> (well started atleast)
22:45:00 <M30W> Or am I just assuming?
22:45:03 <edwardk> M30W: with a lens zipper you can do things like jump around inside a Map to keys in log time
22:45:14 <edwardk> I wrote lens, yes.
22:45:19 <M30W> Yea. :)
22:45:25 <edwardk> I still push something like 70% of the commits to it.
22:45:52 <edwardk> But it is great having the support of that other 30% because they look in places I wouldn't.
22:46:20 <M30W> edwardk: Mission; make it modular ;) as in... package modular not just here this is a lens's definition, use it stand alone.
22:46:23 <M30W> :P
22:46:27 <edwardk> M30W: no.
22:46:36 <M30W> Haha, didn't expect a yes :P
22:46:39 <edwardk> https://github.com/ekmett/lens/wiki/faq#wiki-lens-core
22:46:51 <edwardk> M30W: https://github.com/ekmett/lens/issues/262
22:47:04 <edwardk> both of those address why there will not be a lens core.
22:47:19 <edwardk> I can't please everyone, so in this regard I choose to please myself.
22:47:19 <M30W> I see
22:47:37 <M30W> Fair enough
22:48:04 <M30W> Great job with the lenses I might add. ^_^ Bit too out of my spec for now tho.
22:48:24 <edwardk> If I shed all the 'inessential bits' of lens, we'd trim 20%, but we would gain no portability and a worse user experience.
22:49:20 <edwardk> we need the vast majority of our dependencies for our basic functionality, and we use ghc-specific extensions pretty much as soon as you hit indexed lenses, and you want template-haskell to make lens usable, so by the time you're done incorporating all of that and making it fast you have containers, unordered-containers, etc.
22:49:52 <chord> edwardk: what do you think of Scala?
22:50:12 <edwardk> we could possibly split out the zippers, possibly cripple the 'with-index' functionality and generally make users import 3 things and have 4 dependencies and it'd be a rats nest.
22:50:34 <edwardk> I write a lot of Scala professionally. I think it is a much better Java, and a much worse Haskell.
22:51:34 <M30W> Everything is a better Java.
22:51:35 <M30W> :)
22:51:42 <edwardk> M30W: =)
22:51:56 <M30W> Except *maybe* php.
22:52:00 <edwardk> Well, just in general, in terms of executing on the JVM stack it is the best option out there.
22:52:41 <chord> edwardk: what about Go?
22:52:59 <edwardk> chord: i think go would have been a great language had it been released in 1968.
22:53:25 <M30W> chord: What? Did you mean "Google Odd"?
22:53:28 <M30W> =)
22:53:30 <edwardk> http://cowlark.com/2009-11-15-go/ summarizes my opinions on go well.
22:53:38 <chord> edwardk: so then moving to dynamic languages, what about Ruby and Python?
22:53:42 <arbn> And Rust seems like a much better Go, anyway. :)
22:54:09 <edwardk> i write both when i must, and as little as possible =P
22:54:13 <M30W> edwardk: Nice; now what the hell is "Brand X" ?
22:54:21 <edwardk> M30W: keep reading. its a real language.
22:54:23 <Maxdamantus> Go was released in the early 90s under the pseudonym "Limbo".
22:55:08 <edwardk> Maxdamantus: well, they just share common roots in rob pike
22:55:13 <M30W> Looks a lot like a power shell
22:55:14 <M30W> :)
22:55:29 <edwardk> M30W: (its algol 68)
22:55:47 <Maxdamantus> edwardk: so does Newsqueak, but that's differenter.
22:56:02 <M30W> i see
22:56:14 <chord> edwardk: so you don't agree with these Ruby on Rails people?
22:56:51 <M30W> Wow; great language for back in 1968 :D
22:57:02 <edwardk> for me go missed the mark from a sapir-whorf perspective. http://en.wikipedia.org/wiki/Linguistic_relativity I can't think useful thoughts in go, because anything that I want to write can't be written. Not even the first-order generics I get out of C#. Exceptions if you're the compiler writer its APL all over again.
22:59:07 <edwardk> chord: in what sense? i enjoy programming in haskell. i'm sitting in the #haskell channel. ruby on rails gives you nice defaults and a syntax you can make do anything, haskell lets you statically type that all your crap won't blow up when put in production. rails is easy to get started with. we have 3 web frameworks in haskell i'd use before using rails, but that said, lens.github.com is put together with jekyll because its easy,
22:59:07 <edwardk>  so i'm not a zealot =P
22:59:27 <M30W> edwardk: c < algol68 < Haskell
23:00:22 <M30W> =)
23:00:51 <plat0> Which Scrap Your Boilerplate-style libraries are currently considered the most appropriate for use in new projects?
23:01:11 <edwardk> M30W: plat0 : Data.Data, GHC.Generics, and the lens version of uniplate ;)
23:01:28 <plat0> Oh I didn't know lens did plates
23:01:39 <plat0> But I did know lens does everything
23:01:41 <edwardk> > ("hello","world") & biplate %~ toUpper
23:01:43 <lambdabot>   ("HELLO","WORLD")
23:01:46 <plat0> so I should have made that deduction
23:01:58 <chord> edwardk: what about the people who say Scheme > Haskell
23:02:06 <edwardk> > ("hello",["world","!!!"]) ^.. biplate :: [String]
23:02:08 <lambdabot>   ["hello","world","!!!"]
23:02:19 <arbn> chord: Is this a record interview? Where can I read it once it's published?
23:02:22 <M30W> > map.map toLower ["hello","world"]
23:02:23 <lambdabot>   Couldn't match expected type `a0 -> b0'
23:02:23 <lambdabot>              with actual type `GHC....
23:02:26 <M30W> :(
23:02:35 <edwardk> chord: i'm old enough to know that lots of people believe lots of dumb things on the internet ;)
23:02:38 <arbn> recorded*
23:02:42 <edwardk> arbn: =)
23:02:44 * hackagebot language-lua 0.1.5 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.1.5 (OmerAgacan)
23:02:55 <aleator> Is there a biplate-kind of thing that allows changing the type of the resulting structure? I kinda need to do JavaAST -> Html right now..
23:03:00 <chord> edwardk: so yo think lisp and scheme are crap compared to haskell
23:03:22 <edwardk> chord: i like scheme. it has its points. homoiconicity is nice. scheme macros are amazing. i'm not willing to give up the type system to get them
23:03:30 <edwardk> and laziness reduces a lot of pressure on the macro system
23:03:32 <Maxdamantus> > (map . map) toLower ["hello","world"]
23:03:35 <lambdabot>   ["hello","world"]
23:03:41 <edwardk> so i fell the need for it a lot less here.
23:03:44 <edwardk> er feel
23:03:51 <M30W> > (map . map) toUpper ["hello","world"]
23:03:54 <lambdabot>   ["HELLO","WORLD"]
23:03:59 <M30W> I was close before :P
23:04:05 <ithinktoomuch> a == (:) (head(a) tail(a))
23:04:10 <ithinktoomuch> Shouldnt this be true.?
23:05:09 <M30W> > let a = "test" in (:) ((head a) . (tail a))
23:05:11 <lambdabot>   Couldn't match expected type `a0 -> b0'
23:05:11 <lambdabot>              with actual type `GHC....
23:05:50 <M30W> ithinktoomuch: use (head a):(tail a)
23:05:55 <chord> edwardk: so have the Ruby religious fanatics ever called you stupid for using Haskell?
23:05:58 <edwardk> now thats, scheme. on the lisp side, there is a lot of street cred for getting there first, you can't point to much in computer science we're still using 50 years later. i like scheme as a teaching tool, but if you want to take greenspun's tenth rule, it generalizes to haskell in that every sufficiently advanced lisp/scheme program has a haskell/ml program in the comments. http://en.wikipedia.org/wiki/Greenspun's_tenth_rule
23:06:02 <Maxdamantus> > let a = repeat id in head(a) tail(a)
23:06:04 <lambdabot>   No instance for (GHC.Show.Show (a0 -> a0))
23:06:04 <lambdabot>    arising from a use of `M29071...
23:06:20 <raek> > let a = "test" in (:) (head a) (tail a)
23:06:20 <tac> heh
23:06:22 <lambdabot>   "test"
23:06:24 <ithinktoomuch> @M30W : Yes, I tried that
23:06:24 <lambdabot> Unknown command, try @list
23:06:26 <tac> Greenspun had the best rule
23:06:45 <ithinktoomuch> @M30W: But why is what i wrote wrong?
23:06:45 <lambdabot> Unknown command, try @list
23:06:48 <edwardk> chord: not to my face ;)
23:06:55 <M30W> > let a = "test" in (head a):(tail a) == a
23:06:58 <lambdabot>   True
23:07:00 <M30W> ithinktoomuch: ^
23:07:08 <M30W> ithinktoomuch: Oh
23:07:10 <edwardk> on the other hand, i don't do a lot of web dev, so we don't overlap much ;)
23:07:17 <raek> ithinktoomuch: "(:) foo bar" is not the same as "(:) (foo bar)", it is the same as "(((:) foo) bar)"
23:07:26 * shachaf wonders whether chord is trying hard to start a flamewar.
23:07:31 <edwardk> shachaf: he is
23:07:43 <edwardk> so far it amuses me to answer =P
23:08:13 <ithinktoomuch> @raek: then this should work rght? a == (:) head(a) tail(a)
23:08:13 <lambdabot> Unknown command, try @list
23:08:22 <raek> "(:) (foo bar)" means apply foo with argument bar, and then apply (:) with the result
23:08:37 <ithinktoomuch> aah ok i get that
23:08:54 <ithinktoomuch> What about a == (:) head(a) tail(a) ?
23:09:08 <shachaf> ithinktoomuch: Haskell function application syntax isn't f(x)
23:09:15 <M30W> move your ( left 4 characters
23:09:15 <shachaf> It's f x
23:09:29 <shachaf> And "f x y" means "(f x) y"
23:09:29 <raek> ithinktoomuch: that doesn't work because you are trying to apply (:) with four arguments: 'head', 'a', 'tail' and 'a'
23:09:44 <shachaf> So "(:) head(a)" means "((:) head) a"
23:09:46 <raek> ithinktoomuch: a == head a : tail a
23:09:48 <chord> edwardk: ok some Ruby dude comes up to you and say Haskell is crap compared to Ruby you gotta write unit tests anyways so all that static typing is just an annoyance that slows you down; your response is...
23:09:50 <ithinktoomuch> ohhh
23:09:51 <plat0> edwardk: When you said "Data.Data, GHC.Generics, and the lens version of uniplate" are you saying that each of these can be used on their own, or they should be used together?  I basically want to write functions on a highly-mutually-recursive datatype.
23:09:55 <M30W> ithinktoomuch: "head(a)" -> "(head a)"
23:09:56 <M30W> fix
23:10:08 <M30W> This is not c :)
23:10:29 <raek> function application has the highest priority and is left associative
23:10:34 <edwardk> plat0: depends on what you want to do. lens uniplate basically does anything where you aren't working with lots of different types
23:10:41 <ithinktoomuch> thanks!
23:10:44 <ithinktoomuch> i got it to work
23:10:44 <ithinktoomuch> a == (:) (head a) (tail a )
23:10:58 <tac> @hoogle [a] -> Int -> [a]
23:10:59 <lambdabot> Prelude drop :: Int -> [a] -> [a]
23:10:59 <lambdabot> Data.List drop :: Int -> [a] -> [a]
23:10:59 <lambdabot> Prelude take :: Int -> [a] -> [a]
23:11:08 <raek> a b c + d e f == (((a b) c) + ((d e) f))
23:11:10 <tac> Is there a function that drops the i-th index from a list?
23:11:55 <shachaf> ithinktoomuch: That's true for almost every a.
23:12:09 <edwardk> chord: i honestly can say i've never had that happen
23:12:11 <shachaf> There's one exception where instead of being True, it crashes your program. :-)
23:12:14 <Maxdamantus> snd . filter ((/= i) . fst) . zip [1..]
23:12:18 <tac> @hoogle Int -> [a]  -> [a]
23:12:19 <lambdabot> Prelude drop :: Int -> [a] -> [a]
23:12:19 <lambdabot> Data.List drop :: Int -> [a] -> [a]
23:12:19 <lambdabot> Prelude take :: Int -> [a] -> [a]
23:12:30 <ithinktoomuch> @shachaf: what is taht?
23:12:30 <lambdabot> Unknown command, try @list
23:12:35 <chord> edwardk: but hypothetically
23:12:39 <M30W> ithinktoomuch: liftM2 (:) head tail
23:12:39 <shachaf> ithinktoomuch: An empty list.
23:12:40 <raek> ithinktoomuch: the empty list
23:12:46 <shachaf> edwardk: Haskell is crap compared to Ruby you gotta write unit tests anyways so all that static typing is just an annoyance that slows you down.
23:12:51 <M30W> (import Control.Monad (liftM2))
23:12:54 <ithinktoomuch> ohh yes.
23:12:55 <shachaf> (I'm currently writing Ruby code in the other window!)
23:13:04 <tac> shachaf: (blasphemy!)
23:13:06 <edwardk> chord: right now the most unreasonably persistent button pusher i've come across in the last few months is you. =P my usual response is /ignore or /kick =P
23:13:30 <edwardk> shachaf: that explains your use of unsafeCoerce.
23:13:34 * shachaf has the feeling edwardk might be hinting at something.
23:13:53 <plat0> edwardk: I want to recurse down values of type Decl from haskell-src-exts, and return for example "all the top-level variables bound in this definition" or "all the top-level variables referenced in this definition".  What's the best approach for this?
23:14:09 <edwardk> chord: in all honesty? i'm happy to let them persist in their delusions.
23:14:09 <M30W> ithinktoomuch: a == (liftM2 (:) head tail) a
23:14:11 <raek> > let a = "test" in a == case a of [] -> []; (x:xs) -> x:xs
23:14:13 <lambdabot>   True
23:14:25 <raek> > let a = [] in a == case a of [] -> []; (x:xs) -> x:xs
23:14:27 <lambdabot>   True
23:15:12 <raek> ithinktoomuch: ^
23:15:19 <M30W> ithinktoomuch: Cheat
23:15:22 <M30W> raek: *
23:15:31 <ithinktoomuch> ohh
23:15:43 <M30W> head (x:_) = x
23:15:44 <ithinktoomuch> ^M30W :
23:16:13 <ithinktoomuch> <interactive>:74:7: Not in scope: `liftM2'
23:16:36 <ithinktoomuch> I think I will read more, this is my first day with haskell.
23:16:39 <M30W> ithinktoomuch: 18:12         M30W | (import Control.Monad (liftM2))
23:16:46 <ithinktoomuch> But this IRC is really helpful
23:16:47 <M30W> ithinktoomuch: import Control.Monad (liftM2)
23:16:51 <ithinktoomuch> oh
23:17:16 <chord> edwardk: what do you think about F#?
23:17:19 <raek> ithinktoomuch: if you use pattern matching you answer the questions "is non-empty (therefore having a head and tail)" and "what is the head and tail of a list that is assumed to be non-empty" at the same time
23:17:21 <M30W> @pl \a -> (:) (head a) (tail a)
23:17:21 <lambdabot> liftM2 (:) head tail
23:17:33 <M30W> See ^_^ -- Just more or less expanded it
23:18:16 <ithinktoomuch> @raek : ohk cool
23:18:16 <lambdabot> Consider it noted.
23:18:31 <ithinktoomuch> Is the lambdabot an automatic bot of some kind?
23:18:33 <M30W> > liftM2 (:) (\(x:_) -> x) (\(_:xs) -> xs)
23:18:34 <Maxdamantus> > let id = \a -> (:) (head a) (tail a) in id []
23:18:36 <lambdabot>   No instance for (GHC.Show.Show ([a10] -> [a10]))
23:18:36 <lambdabot>    arising from a use of `...
23:18:37 <M30W> err
23:18:37 <lambdabot>   can't find file: L.hs
23:18:41 <edwardk> i think it has brought a lot of good to the .NET ecosystem, but it is a pretty crappy ML dialect in that you pay all the price of ML syntax, but you don't get ML modules in recompense, and its awkward to incrementally upgrade a c# project to it due to the need for separate assemblies.
23:18:42 <M30W> > liftM2 (:) (\(x:_) -> x) (\(_:xs) -> xs) "test"
23:18:44 <lambdabot>   "test"
23:18:52 <Maxdamantus> > let id = \a -> (:) (head a) (tail a) in id [] :: [Integer]
23:18:54 <lambdabot>   [*Exception: Prelude.head: empty list
23:19:22 <M30W> Lets expand moar :D
23:19:54 <Maxdamantus> @pl \r o a m -> m o a r
23:19:54 <lambdabot> flip (flip . (flip .) . flip . flip id)
23:20:06 <M30W> > (\a ((\(x:_) -> x) a):((\(_:xs) -> xs) a)) "test"
23:20:07 <lambdabot>   <hint>:1:6: Parse error in pattern: (\ (x : _) -> x)
23:20:11 <M30W> err
23:20:22 <M30W> Meh
23:20:39 <edwardk> I tend to write code in C# when forced onto the .NET stack. Easier to use LINQ, easier to hand off development, and i'm not confronted with the abomination that is 'Workflow'.
23:21:16 <M30W> > (\a -> ((\(x:_) -> x) a):((\(_:xs) -> xs) a)) "test"
23:21:17 <M30W> lol
23:21:18 <lambdabot>   "test"
23:21:26 <M30W> ithinktoomuch: ^_^ Does what you want :D
23:21:34 <M30W> In a very expanded fassion :P
23:21:42 <M30W> fashion *
23:22:11 <M30W> @pl (\a -> ((\(x:_) -> x) a):((\(_:xs) -> xs) a))
23:22:12 <lambdabot> liftM2 (:) head tail
23:22:17 <M30W> =)
23:22:48 <chord> edwardk: what do you think about bitcoin?
23:23:04 <M30W> chord: What do you think about IRC?
23:23:37 <edwardk> chord: re "how many times i failed college" I can safely say that I'm pretty sure I made it through my undergrad and graduate programs faster than anyone on this IRC network =P
23:24:11 <shachaf> This is like one of those logic puzzles.
23:24:18 <edwardk> shachaf: haha
23:24:45 <M30W> shachaf: What is?
23:24:45 <shachaf> edwardk: I'm not asking you what you think of dynamic typing. But if I did ask you, what would you say?
23:24:46 <snowylike> edwardk: since you're the guy with answers to everything - can you tell me why i like SML?
23:25:09 <chord> edwardk: so you don't know anything about bitcoin in other words
23:25:30 <edwardk> snowylike: head injury. i'd recommend not sleeping until you find medical supervision.
23:26:04 <edwardk> shachaf: i love catching bugs in production after i ship a product.
23:26:11 <shachaf> #haskell has three edwards: One always lies, one always tells the truth, and one only answers in zygohistomorphic prepromorphisms.
23:26:16 <M30W> 18:23      shachaf | This is like one of those logic puzzles.
23:26:20 <M30W> Where logic puzzle?
23:26:42 <snowylike> now, seriously - why all these questions?
23:27:03 <M30W> snowylike: This channel is for questions, Is it not? =)
23:27:32 <edwardk> M30W: the faster than anyone on this IRC network comment
23:27:42 <snowylike> M30W: well - maybe, i wouldn't know. But this isn't the sort of questions i typically see around here
23:27:58 <shachaf> edwardk: Oh, I just meant all these "what would you say if I asked you X?" questions
23:28:06 <edwardk> shachaf: ah
23:28:13 <shachaf> edwardk: My attitude is that once it's in production it's somebody else's problem.
23:28:18 <edwardk> shachaf: hahahah
23:28:21 <M30W> edwardk: Huh?
23:28:24 <shachaf> For that matter, it's somebody else's problem before it's in production.
23:28:32 <shachaf> Makes life easy.
23:29:24 <edwardk> M30W: (I finished my undergrad in a year, my first M.A. in a semester, then stuck around collecting degrees and teaching for a couple of years before returning to industry)
23:29:45 <M30W> Fun
23:29:58 <M30W> edwardk: I don't think I asked tho?
23:30:33 <edwardk> M30W: i misparsed your huh. nevermind.
23:30:43 <M30W> :P
23:31:01 <M30W> I was asking shachaf what he meant by "one of those logic puzzles"?
23:31:09 <M30W> Cause I don't see any logic puzzles =)
23:31:51 <edwardk> M30W: yes, and the logic puzzle i took it to be was "[02:23] edwardk: chord: re "how many times i failed college" I can safely say that I'm pretty sure I made it through my undergrad and graduate programs faster than anyone on this IRC network =P"
23:32:03 <edwardk> M30W: hence the huh causing me to elaborate
23:32:14 * edwardk points to the dead horse.
23:32:19 <edwardk> we should stop beating that.
23:34:29 <chord> you guys are boring now, i'm going to another channel
23:34:41 * shachaf sighs.
23:34:52 --- mode: ChanServ set +o shachaf
23:35:04 --- mode: shachaf set -o shachaf
23:35:56 <shachaf> Magic.
23:36:32 <edwardk> thank you
23:37:17 <edwardk> as bait target, i felt it would be in poor taste to reply with a /kick personally =P
23:39:18 <shachaf> edwardk: Thank the person who +oed me.
23:39:28 <edwardk> shachaf: haha
23:39:36 <edwardk> good trick
23:39:55 <M30W> ed?
23:40:13 <plat0> Past tense
23:40:20 <M30W> oh
23:40:23 <shachaf> I think copumpkin was trying to play good op/bad op without damaging his reputation.
23:40:26 <edwardk> =)
23:40:39 <edwardk> it was the bitcoin mention. clearly the last straw
23:40:46 <copumpkin> nope, just looked like shit was happening and I was too tired to get involved/actually read
23:40:47 <M30W> Haha
23:41:17 <copumpkin> omg bitcoins
23:41:47 <M30W> Any haskell bitcoin generators exist?
23:41:48 <akamaus> hi all. I need an advice :)  I'm working on some kind of RPC involving calling lua functions in a remote process. Till now I modelled it as subclass of Monad with a sole additional function luaRaw :: LuaCode -> m [LuaValue]. All worked well, but now In order to decrease latency I'm trying to run a list scripts  in one burst and collect the results after it. Current signature is too restricting. Any ideas how to relax it?
23:41:48 <M30W> :P
23:42:06 <M30W> akamaus: s/an advice/some advice/
23:42:21 <M30W> or an adviser
23:42:21 * shachaf wonders whethe a type class is the right solution.
23:42:57 <shachaf> Anyway, I'm not sure that I understand the issue.
23:42:59 <shachaf> hi monochrom
23:43:08 <shachaf> preflex: quote monochrom
23:43:09 <preflex>  <monochrom> einstein's theory implies that haskell cannot be faster than c
23:43:18 <edwardk> shachaf: hah
23:43:22 <M30W> preflex: quote shachaf
23:43:22 <preflex>  <shachaf> There was a study once where they gave one group real placebos and the other group fake placebos, and the effects were exactly the same.
23:43:26 <akamaus> M30W, thanks!
23:43:49 <M30W> akamaus: English tips/corrections are always nice to give out. ^_^
23:44:37 <akamaus> M30W, and easy compared to Haskell, I guess :)
23:44:40 <edwardk> shachaf: there can exist haskell code faster than c, it just can't interact with regular haskell. ask dons.
23:44:52 <M30W> akamaus: Depending on the issue =)
23:45:07 * M30W reads the rest of your comment
23:45:10 <M30W> tl;dr :P
23:46:33 <M30W> akamaus: Try commenting the definition and see what ghci gives you for the :t of the function?
23:46:37 <M30W> =)
23:46:43 <M30W> Cheat's method to get types xD
23:47:04 <shachaf> Would you say that everything exists?
23:47:38 <M30W> shachaf: ?
23:52:34 <no-n> is haskell haskell?
23:52:41 <arcatan> yes
23:52:46 <no-n> nice
23:52:58 <shachaf> are monoids easy?
23:53:43 <akamaus> M30W, I use things like returns so It would infer Monad anyway. I'm looking for a more radical ways of restructuring the computation. The point is what I don't really need sequencing, so Monad probably is  an overkill
23:54:20 <M30W> :P
23:56:41 <akamaus> M30W, I've added luaRawMulti :: [LuaCode] -> m [[LuaValue]], but my individual scripts depend on luaRaw and evaluating too eagerly, one by one. And I want to run a whole bunch of them in one turn.
23:59:00 <akamaus> M30W, moreover, each function I want to parallelize  runs exactly one computation on lua side. So looks like I don't need binds.
23:59:58 <M30W> akamaus: luaEvaluate . unlines $ [lines]
